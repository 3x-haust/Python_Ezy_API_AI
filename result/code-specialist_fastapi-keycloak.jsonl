{"repo_info": {"repo_name": "fastapi-keycloak", "repo_owner": "code-specialist", "repo_url": "https://github.com/code-specialist/fastapi-keycloak"}}
{"type": "test_file", "path": "tests/__init__.py", "content": "import pytest\n\nfrom fastapi_keycloak import FastAPIKeycloak\n\n\nclass BaseTestClass:\n    @pytest.fixture\n    def idp(self):\n        return FastAPIKeycloak(\n            server_url=\"http://localhost:8085/auth\",\n            client_id=\"test-client\",\n            client_secret=\"GzgACcJzhzQ4j8kWhmhazt7WSdxDVUyE\",\n            admin_client_secret=\"BIcczGsZ6I8W5zf0rZg5qSexlloQLPKB\",\n            realm=\"Test\",\n            callback_uri=\"http://localhost:8081/callback\",\n        )\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "def pytest_sessionstart(session):\n    # subprocess.call(['sh', './start_infra.sh'])\n    # print(\"Waiting for Keycloak to start\")\n    # sleep(60)  # Wait for startup\n    pass\n\n\ndef pytest_sessionfinish(session):\n    # subprocess.call(['sh', './stop_infra.sh'])\n    pass\n"}
{"type": "test_file", "path": "tests/app.py", "content": "from typing import List, Optional\n\nimport uvicorn\nfrom fastapi import FastAPI, Depends, Query, Body, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import SecretStr\n\nfrom fastapi_keycloak import (\n    FastAPIKeycloak,\n    HTTPMethod,\n    KeycloakUser,\n    OIDCUser,\n    UsernamePassword,\n    KeycloakError\n)\n\napp = FastAPI()\nidp = FastAPIKeycloak(\n    server_url=\"http://localhost:8085/auth\",\n    client_id=\"test-client\",\n    client_secret=\"GzgACcJzhzQ4j8kWhmhazt7WSdxDVUyE\",\n    admin_client_id=\"admin-cli\",\n    admin_client_secret=\"BIcczGsZ6I8W5zf0rZg5qSexlloQLPKB\",\n    realm=\"Test\",\n    callback_uri=\"http://localhost:8081/callback\",\n    scope=\"openid profile email\",\n)\nidp.add_swagger_config(app)\n\n\n# Custom error handler for showing Keycloak errors on FastAPI\n@app.exception_handler(KeycloakError)\nasync def keycloak_exception_handler(request: Request, exc: KeycloakError):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.reason},\n    )\n\n    \n# Admin\n\n\n@app.post(\"/proxy\", tags=[\"admin-cli\"])\ndef proxy_admin_request(\n    relative_path: str,\n    method: HTTPMethod,\n    additional_headers: dict = Body(None),\n    payload: dict = Body(None),\n):\n    return idp.proxy(\n        additional_headers=additional_headers,\n        relative_path=relative_path,\n        method=method,\n        payload=payload,\n    )\n\n\n@app.get(\"/identity-providers\", tags=[\"admin-cli\"])\ndef get_identity_providers():\n    return idp.get_identity_providers()\n\n\n@app.get(\"/idp-configuration\", tags=[\"admin-cli\"])\ndef get_idp_config():\n    return idp.open_id_configuration\n\n\n# User Management\n\n\n@app.get(\"/users\", tags=[\"user-management\"])\ndef get_users():\n    return idp.get_all_users()\n\n\n@app.get(\"/user\", tags=[\"user-management\"])\ndef get_user_by_query(query: str = None):\n    return idp.get_user(query=query)\n\n\n@app.post(\"/users\", tags=[\"user-management\"])\ndef create_user(\n    first_name: str, last_name: str, email: str, password: SecretStr, id: str = None\n):\n    return idp.create_user(\n        first_name=first_name,\n        last_name=last_name,\n        username=email,\n        email=email,\n        password=password.get_secret_value(),\n        id=id,\n    )\n\n\n@app.get(\"/user/{user_id}\", tags=[\"user-management\"])\ndef get_user(user_id: str = None):\n    return idp.get_user(user_id=user_id)\n\n\n@app.put(\"/user\", tags=[\"user-management\"])\ndef update_user(user: KeycloakUser):\n    return idp.update_user(user=user)\n\n\n@app.delete(\"/user/{user_id}\", tags=[\"user-management\"])\ndef delete_user(user_id: str):\n    return idp.delete_user(user_id=user_id)\n\n\n@app.put(\"/user/{user_id}/change-password\", tags=[\"user-management\"])\ndef change_password(user_id: str, new_password: SecretStr):\n    return idp.change_password(user_id=user_id, new_password=new_password)\n\n\n@app.put(\"/user/{user_id}/send-email-verification\", tags=[\"user-management\"])\ndef send_email_verification(user_id: str):\n    return idp.send_email_verification(user_id=user_id)\n\n\n# Role Management\n\n\n@app.get(\"/roles\", tags=[\"role-management\"])\ndef get_all_roles():\n    return idp.get_all_roles()\n\n\n@app.get(\"/role/{role_name}\", tags=[\"role-management\"])\ndef get_role(role_name: str):\n    return idp.get_roles([role_name])\n\n\n@app.post(\"/roles\", tags=[\"role-management\"])\ndef add_role(role_name: str):\n    return idp.create_role(role_name=role_name)\n\n\n@app.delete(\"/roles\", tags=[\"role-management\"])\ndef delete_roles(role_name: str):\n    return idp.delete_role(role_name=role_name)\n\n\n# Group Management\n\n\n@app.get(\"/groups\", tags=[\"group-management\"])\ndef get_all_groups():\n    return idp.get_all_groups()\n\n\n@app.get(\"/group/{group_name}\", tags=[\"group-management\"])\ndef get_group(group_name: str):\n    return idp.get_groups([group_name])\n\n\n@app.get(\"/group-by-path/{path: path}\", tags=[\"group-management\"])\ndef get_group_by_path(path: str):\n    return idp.get_group_by_path(path)\n\n\n@app.post(\"/groups\", tags=[\"group-management\"])\ndef add_group(group_name: str, parent_id: Optional[str] = None):\n    return idp.create_group(group_name=group_name, parent=parent_id)\n\n\n@app.delete(\"/groups\", tags=[\"group-management\"])\ndef delete_groups(group_id: str):\n    return idp.delete_group(group_id=group_id)\n\n\n# User Roles\n\n\n@app.post(\"/users/{user_id}/roles\", tags=[\"user-roles\"])\ndef add_roles_to_user(user_id: str, roles: Optional[List[str]] = Query(None)):\n    return idp.add_user_roles(user_id=user_id, roles=roles)\n\n\n@app.get(\"/users/{user_id}/roles\", tags=[\"user-roles\"])\ndef get_user_roles(user_id: str):\n    return idp.get_user_roles(user_id=user_id)\n\n\n@app.delete(\"/users/{user_id}/roles\", tags=[\"user-roles\"])\ndef delete_roles_from_user(user_id: str, roles: Optional[List[str]] = Query(None)):\n    return idp.remove_user_roles(user_id=user_id, roles=roles)\n\n\n# User Groups\n\n\n@app.post(\"/users/{user_id}/groups\", tags=[\"user-groups\"])\ndef add_group_to_user(user_id: str, group_id: str):\n    return idp.add_user_group(user_id=user_id, group_id=group_id)\n\n\n@app.get(\"/users/{user_id}/groups\", tags=[\"user-groups\"])\ndef get_user_groups(user_id: str):\n    return idp.get_user_groups(user_id=user_id)\n\n\n@app.delete(\"/users/{user_id}/groups\", tags=[\"user-groups\"])\ndef delete_groups_from_user(user_id: str, group_id: str):\n    return idp.remove_user_group(user_id=user_id, group_id=group_id)\n\n\n# Example User Requests\n\n\n@app.get(\"/protected\", tags=[\"example-user-request\"])\ndef protected(user: OIDCUser = Depends(idp.get_current_user())):\n    return user\n\n\n@app.get(\"/current_user/roles\", tags=[\"example-user-request\"])\ndef get_current_users_roles(user: OIDCUser = Depends(idp.get_current_user())):\n    return user.roles\n\n\n@app.get(\"/admin\", tags=[\"example-user-request\"])\ndef company_admin(\n    user: OIDCUser = Depends(idp.get_current_user(required_roles=[\"admin\"])),\n):\n    return f\"Hi admin {user}\"\n\n\n@app.post(\"/login\", tags=[\"example-user-request\"])\ndef login(user: UsernamePassword = Body(...)):\n    return idp.user_login(\n        username=user.username, password=user.password.get_secret_value()\n    )\n\n\n# Auth Flow\n\n\n@app.get(\"/login-link\", tags=[\"auth-flow\"])\ndef login_redirect():\n    return idp.login_uri\n\n\n@app.get(\"/callback\", tags=[\"auth-flow\"])\ndef callback(session_state: str, code: str):\n    return idp.exchange_authorization_code(session_state=session_state, code=code)\n\n\n@app.get(\"/logout\", tags=[\"auth-flow\"])\ndef logout():\n    return idp.logout_uri\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"app:app\", host=\"127.0.0.1\", port=8081)\n"}
{"type": "test_file", "path": "tests/test_integration.py", "content": "from time import sleep\nfrom typing import List\n\nimport httpretty as httpretty\nimport pytest as pytest\nfrom fastapi import FastAPI\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError\nfrom requests import ReadTimeout\n\nfrom fastapi_keycloak import HTTPMethod\nfrom fastapi_keycloak.model import KeycloakRole\nfrom tests import BaseTestClass\n\n\nclass TestAPIIntegration(BaseTestClass):\n    def test_properties(self, idp):\n        assert idp.public_key\n        assert idp.admin_token\n        assert idp.open_id_configuration\n        assert idp.logout_uri\n        assert idp.login_uri\n        assert idp.roles_uri\n        assert idp.token_uri\n        assert idp.authorization_uri\n        assert idp.user_auth_scheme\n        assert idp.providers_uri\n        assert idp.realm_uri\n        assert idp.users_uri\n\n    def test_admin_token(self, idp):\n        assert idp.admin_token\n        with pytest.raises(JWTError):  # Not enough segments\n            idp.admin_token = \"some rubbish\"\n\n        with pytest.raises(JWTError):  # Invalid crypto padding\n            idp.admin_token = \"\"\"\n            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n            \"\"\"\n\n    def test_add_swagger_config(self, idp):\n        app = FastAPI()\n        assert app.swagger_ui_init_oauth is None\n        idp.add_swagger_config(app)\n        assert app.swagger_ui_init_oauth == {\n            \"usePkceWithAuthorizationCodeGrant\": True,\n            \"clientId\": idp.client_id,\n            \"clientSecret\": idp.client_secret,\n        }\n\n    def test_user_auth_scheme(self, idp):\n        assert isinstance(idp.user_auth_scheme, OAuth2PasswordBearer)\n\n    def test_open_id_configuration(self, idp):\n        assert idp.open_id_configuration\n        assert type(idp.open_id_configuration) == dict\n\n    def test_proxy(self, idp):\n        response = idp.proxy(relative_path=\"/realms/Test\", method=HTTPMethod.GET)\n        assert type(response.json()) == dict\n\n    @httpretty.activate(allow_net_connect=False)\n    def test_timeout(self, idp):\n        def request_callback(request, url, headers):\n            sleep(1)\n            return 200, headers, 'OK'\n\n        httpretty.register_uri(httpretty.GET, f\"{idp.server_url}/timeout\", body=request_callback)\n        idp.timeout = 0.5\n\n        with pytest.raises(ReadTimeout):\n            idp.proxy(relative_path=\"/timeout\", method=HTTPMethod.GET)\n\n    def test_get_all_roles_and_get_roles(self, idp):\n        roles: List[KeycloakRole] = idp.get_all_roles()\n        assert roles\n        lookup = idp.get_roles(role_names=[role.name for role in roles])\n        assert lookup\n        assert len(roles) == len(lookup)\n\n    def test_get_identity_providers(self, idp):\n        assert idp.get_identity_providers() == []\n"}
{"type": "test_file", "path": "tests/test_functional.py", "content": "from typing import List\n\nimport pytest as pytest\nfrom fastapi import HTTPException\n\nfrom fastapi_keycloak import KeycloakError\nfrom fastapi_keycloak.exceptions import (\n    ConfigureTOTPException,\n    UpdatePasswordException,\n    UpdateProfileException,\n    UpdateUserLocaleException,\n    UserNotFound,\n    VerifyEmailException,\n)\nfrom fastapi_keycloak.model import (\n    KeycloakGroup,\n    KeycloakRole,\n    KeycloakToken,\n    KeycloakUser,\n    OIDCUser,\n)\nfrom tests import BaseTestClass\n\nTEST_PASSWORD = \"test-password\"\n\n\nclass TestAPIFunctional(BaseTestClass):\n    @pytest.fixture\n    def user(self, idp):\n        return idp.create_user(\n            first_name=\"test\",\n            last_name=\"user\",\n            username=\"user@code-specialist.com\",\n            email=\"user@code-specialist.com\",\n            password=TEST_PASSWORD,\n            enabled=True,\n            send_email_verification=False,\n        )\n\n    @pytest.fixture()\n    def users(self, idp):\n        assert idp.get_all_users() == []  # No users yet\n\n        # Create some test users\n        user_alice = idp.create_user(  # Create User A\n            first_name=\"test\",\n            last_name=\"user\",\n            username=\"testuser_alice@code-specialist.com\",\n            email=\"testuser_alice@code-specialist.com\",\n            password=TEST_PASSWORD,\n            enabled=True,\n            send_email_verification=False,\n        )\n        assert isinstance(user_alice, KeycloakUser)\n        assert len(idp.get_all_users()) == 1\n\n        # Try to create a user with the same username\n        with pytest.raises(KeycloakError):  # 'User exists with same username'\n            idp.create_user(\n                first_name=\"test\",\n                last_name=\"user\",\n                username=\"testuser_alice@code-specialist.com\",\n                email=\"testuser_alice@code-specialist.com\",\n                password=TEST_PASSWORD,\n                enabled=True,\n                send_email_verification=False,\n            )\n        assert len(idp.get_all_users()) == 1\n\n        user_bob = idp.create_user(  # Create User B\n            first_name=\"test\",\n            last_name=\"user\",\n            username=\"testuser_bob@code-specialist.com\",\n            email=\"testuser_bob@code-specialist.com\",\n            password=TEST_PASSWORD,\n            enabled=True,\n            send_email_verification=False,\n        )\n        assert isinstance(user_bob, KeycloakUser)\n        assert len(idp.get_all_users()) == 2\n        return user_alice, user_bob\n\n    def test_roles(self, idp, users):\n        user_alice, user_bob = users\n\n        # Check the roles\n        user_alice_roles = idp.get_user_roles(user_id=user_alice.id)\n        assert len(user_alice_roles) == 1\n        for role in user_alice_roles:\n            assert role.name in [\"default-roles-test\"]\n\n        user_bob_roles = idp.get_user_roles(user_id=user_bob.id)\n        assert len(user_bob_roles) == 1\n        for role in user_bob_roles:\n            assert role.name in [\"default-roles-test\"]\n\n        # Create a some roles\n        all_roles = idp.get_all_roles()\n        assert len(all_roles) == 3\n        for role in all_roles:\n            assert role.name in [\n                \"default-roles-test\",\n                \"offline_access\",\n                \"uma_authorization\",\n            ]\n\n        test_role_saturn = idp.create_role(\"test_role_saturn\")\n        all_roles = idp.get_all_roles()\n        assert len(all_roles) == 4\n        for role in all_roles:\n            assert role.name in [\n                \"default-roles-test\",\n                \"offline_access\",\n                \"uma_authorization\",\n                test_role_saturn.name,\n            ]\n\n        test_role_mars = idp.create_role(\"test_role_mars\")\n        all_roles = idp.get_all_roles()\n        assert len(all_roles) == 5\n        for role in all_roles:\n            assert role.name in [\n                \"default-roles-test\",\n                \"offline_access\",\n                \"uma_authorization\",\n                test_role_saturn.name,\n                test_role_mars.name,\n            ]\n\n        assert isinstance(test_role_saturn, KeycloakRole)\n        assert isinstance(test_role_mars, KeycloakRole)\n\n        # Check the roles again\n        user_alice_roles: List[KeycloakRole] = idp.get_user_roles(user_id=user_alice.id)\n        assert len(user_alice_roles) == 1\n        for role in user_alice_roles:\n            assert role.name in [\"default-roles-test\"]\n\n        user_bob_roles = idp.get_user_roles(user_id=user_bob.id)\n        assert len(user_bob_roles) == 1\n        for role in user_bob_roles:\n            assert role.name in [\"default-roles-test\"]\n\n        # Assign role to Alice\n        idp.add_user_roles(user_id=user_alice.id, roles=[test_role_saturn.name])\n        user_alice_roles: List[KeycloakRole] = idp.get_user_roles(user_id=user_alice.id)\n        assert len(user_alice_roles) == 2\n        for role in user_alice_roles:\n            assert role.name in [\"default-roles-test\", test_role_saturn.name]\n\n        # Assign roles to Bob\n        idp.add_user_roles(\n            user_id=user_bob.id, roles=[test_role_saturn.name, test_role_mars.name]\n        )\n        user_bob_roles: List[KeycloakRole] = idp.get_user_roles(user_id=user_bob.id)\n        assert len(user_bob_roles) == 3\n        for role in user_bob_roles:\n            assert role.name in [\n                \"default-roles-test\",\n                test_role_saturn.name,\n                test_role_mars.name,\n            ]\n\n        # Exchange the details for access tokens\n        keycloak_token_alice: KeycloakToken = idp.user_login(\n            username=user_alice.username, password=TEST_PASSWORD\n        )\n        assert idp.token_is_valid(keycloak_token_alice.access_token)\n        keycloak_token_bob: KeycloakToken = idp.user_login(\n            username=user_bob.username, password=TEST_PASSWORD\n        )\n        assert idp.token_is_valid(keycloak_token_bob.access_token)\n\n        # Check get_current_user Alice\n        current_user_function = idp.get_current_user()\n        current_user: OIDCUser = current_user_function(\n            token=keycloak_token_alice.access_token\n        )\n        assert current_user.sub == user_alice.id\n        assert len(current_user.roles) == 4  # Also includes all implicit roles\n        for role in current_user.roles:\n            assert role in [\n                \"default-roles-test\",\n                \"offline_access\",\n                \"uma_authorization\",\n                test_role_saturn.name,\n            ]\n\n        # Check get_current_user Bob\n        current_user_function = idp.get_current_user()\n        current_user: OIDCUser = current_user_function(\n            token=keycloak_token_bob.access_token\n        )\n        assert current_user.sub == user_bob.id\n        assert len(current_user.roles) == 5  # Also includes all implicit roles\n        for role in current_user.roles:\n            assert role in [\n                \"default-roles-test\",\n                \"offline_access\",\n                \"uma_authorization\",\n                test_role_saturn.name,\n                test_role_mars.name,\n            ]\n\n        # Check get_current_user Alice with role Saturn\n        current_user_function = idp.get_current_user(\n            required_roles=[test_role_saturn.name]\n        )\n        # Get Alice\n        current_user: OIDCUser = current_user_function(\n            token=keycloak_token_alice.access_token\n        )\n        assert current_user.sub == user_alice.id\n        # Get Bob\n        current_user: OIDCUser = current_user_function(\n            token=keycloak_token_bob.access_token\n        )\n        assert current_user.sub == user_bob.id\n\n        # Check get_current_user Alice with role Mars\n        current_user_function = idp.get_current_user(\n            required_roles=[test_role_mars.name]\n        )\n        # Get Alice\n        with pytest.raises(HTTPException):\n            current_user_function(\n                token=keycloak_token_alice.access_token\n            )  # Alice does not posses this role\n        # Get Bob\n        current_user: OIDCUser = current_user_function(\n            token=keycloak_token_bob.access_token\n        )\n        assert current_user.sub == user_bob.id\n\n        # Remove Role Mars from Bob\n        idp.remove_user_roles(user_id=user_bob.id, roles=[test_role_mars.name])\n        user_bob_roles: List[KeycloakRole] = idp.get_user_roles(user_id=user_bob.id)\n        assert len(user_bob_roles) == 2\n        for role in user_bob_roles:\n            assert role.name in [\n                \"default-roles-test\",\n                \"offline_access\",\n                \"uma_authorization\",\n                test_role_saturn.name,\n            ]\n\n        # Delete Role Saturn\n        idp.delete_role(role_name=test_role_saturn.name)\n\n        # Check Alice\n        user_alice_roles: List[KeycloakRole] = idp.get_user_roles(user_id=user_alice.id)\n        assert len(user_alice_roles) == 1\n        for role in user_alice_roles:\n            assert role.name in [\"default-roles-test\"]\n\n        # Check Bob\n        user_bob_roles = idp.get_user_roles(user_id=user_bob.id)\n        assert len(user_bob_roles) == 1\n        for role in user_bob_roles:\n            assert role.name in [\"default-roles-test\"]\n\n        # Clean up\n        idp.delete_role(role_name=test_role_mars.name)\n        idp.delete_user(user_id=user_alice.id)\n        idp.delete_user(user_id=user_bob.id)\n\n    def test_user_with_initial_roles(self, idp):\n        idp.create_role(\"role_a\")\n        idp.create_role(\"role_b\")\n\n        user: KeycloakUser = idp.create_user(\n            first_name=\"test\",\n            last_name=\"user\",\n            username=\"user@code-specialist.com\",\n            email=\"user@code-specialist.com\",\n            initial_roles=[\"role_a\", \"role_b\"],\n            password=TEST_PASSWORD,\n            enabled=True,\n            send_email_verification=False,\n        )\n        assert user\n\n        user_token: KeycloakToken = idp.user_login(\n            username=user.username, password=TEST_PASSWORD\n        )\n        decoded_token = idp._decode_token(\n            token=user_token.access_token, audience=\"account\"\n        )\n        oidc_user: OIDCUser = OIDCUser.parse_obj(decoded_token)\n        for role in [\"role_a\", \"role_b\"]:\n            assert role in oidc_user.roles\n\n        idp.delete_role(\"role_a\")\n        idp.delete_role(\"role_b\")\n        idp.delete_user(user.id)\n\n    def test_groups(self, idp):\n\n        # None of empty list groups\n        none_return = idp.get_groups([])\n        assert not none_return\n\n        # None of none param\n        none_return = idp.get_groups(None)\n        assert none_return is None\n\n        # Error create group\n        with pytest.raises(KeycloakError):\n            idp.create_group(group_name=None)\n\n        # Error get group\n        with pytest.raises(KeycloakError):\n            idp.get_group(group_id=None)\n\n        # Create the first group\n        foo_group: KeycloakGroup = idp.create_group(group_name=\"Foo Group\")\n        assert foo_group is not None\n        assert foo_group.name == \"Foo Group\"\n\n        # Get Empty Subgroups for group\n        empty_subgroups = idp.get_subgroups(foo_group, \"/nonexistent\")\n        assert empty_subgroups is None\n\n        # Find Group by invalid Path\n        invalid_group = idp.get_group_by_path(\"/nonexistent\")\n        assert invalid_group is None\n\n        # Create the second group\n        bar_group: KeycloakGroup = idp.create_group(group_name=\"Bar Group\")\n        assert bar_group is not None\n        assert bar_group.name == \"Bar Group\"\n\n        # Check if groups are registered\n        all_groups: List[KeycloakGroup] = idp.get_all_groups()\n        assert len(all_groups) == 2\n\n        # Check get_groups\n        groups: List[KeycloakGroup] = idp.get_groups(group_names=[foo_group.name])\n        assert len(groups) == 1\n        assert groups[0].name == foo_group.name\n\n        # Create Subgroup 1 by parent object\n        subgroup1: KeycloakGroup = idp.create_group(\n            group_name=\"Subgroup 01\", parent=foo_group\n        )\n        assert subgroup1 is not None\n        assert subgroup1.name == \"Subgroup 01\"\n        assert subgroup1.path == f\"{foo_group.path}/Subgroup 01\"\n\n        # Create Subgroup 2 by parent id\n        subgroup2: KeycloakGroup = idp.create_group(\n            group_name=\"Subgroup 02\", parent=foo_group.id\n        )\n        assert subgroup2 is not None\n        assert subgroup2.name == \"Subgroup 02\"\n        assert subgroup2.path == f\"{foo_group.path}/Subgroup 02\"\n\n        # Create Subgroup Level 3\n        subgroup_l3: KeycloakGroup = idp.create_group(\n            group_name=\"Subgroup l3\", parent=subgroup2\n        )\n        assert subgroup_l3 is not None\n        assert subgroup_l3.name == \"Subgroup l3\"\n        assert subgroup_l3.path == f\"{subgroup2.path}/Subgroup l3\"\n\n        # Create Subgroup Level 4\n        subgroup_l4: KeycloakGroup = idp.create_group(\n            group_name=\"Subgroup l4\", parent=subgroup_l3\n        )\n        assert subgroup_l4 is not None\n        assert subgroup_l4.name == \"Subgroup l4\"\n        assert subgroup_l4.path == f\"{subgroup_l3.path}/Subgroup l4\"\n\n        # Find Group by Path\n        foo_group = idp.get_group_by_path(foo_group.path)\n        assert foo_group is not None\n        assert len(foo_group.subGroups) == 2\n\n        # Find Subgroup by Path\n        subgroup_by_path = idp.get_group_by_path(subgroup2.path)\n        assert subgroup_by_path is not None\n        assert subgroup_by_path.id == subgroup2.id\n\n        # Find subgroup that does not exist\n        subgroup_by_path = idp.get_group_by_path(\"/The Subgroup/Not Exists\")\n        assert subgroup_by_path is None\n\n        # Clean up\n        idp.delete_group(group_id=bar_group.id)\n        idp.delete_group(group_id=foo_group.id)\n\n    def test_user_groups(self, idp, user):\n\n        # Check initial user groups\n        user_groups = idp.get_user_groups(user.id)\n        assert len(user_groups) == 0\n\n        # Create the first group and add to user\n        foo_group: KeycloakGroup = idp.create_group(group_name=\"Foo\")\n        idp.add_user_group(user_id=user.id, group_id=foo_group.id)\n\n        # Check if the user is in the group\n        user_groups = idp.get_user_groups(user.id)\n        assert len(user_groups) == 1\n        assert user_groups[0].id == foo_group.id\n\n        # Remove User of the group\n        idp.remove_user_group(user.id, foo_group.id)\n\n        # Check if the user has no group\n        user_groups = idp.get_user_groups(user.id)\n        assert len(user_groups) == 0\n\n        idp.delete_group(group_id=foo_group.id)\n        idp.delete_user(user_id=user.id)\n\n    @pytest.mark.parametrize(\n        \"action, exception\",\n        [\n            (\"update_user_locale\", UpdateUserLocaleException),\n            (\"CONFIGURE_TOTP\", ConfigureTOTPException),\n            (\"VERIFY_EMAIL\", VerifyEmailException),\n            (\"UPDATE_PASSWORD\", UpdatePasswordException),\n            (\"UPDATE_PROFILE\", UpdateProfileException),\n        ],\n    )\n    def test_login_exceptions(self, idp, action, exception, user):\n\n        # Get access, refresh and id token for the users\n        tokens = idp.user_login(username=user.username, password=TEST_PASSWORD)\n        assert tokens.access_token\n        assert tokens.refresh_token\n        assert tokens.id_token\n\n        user.requiredActions.append(action)  # Add an action\n        user: KeycloakUser = idp.update_user(user=user)  # Save the change\n\n        with pytest.raises(\n            exception\n        ):  # Expect the login to fail due to the verify email action\n            idp.user_login(username=user.username, password=TEST_PASSWORD)\n\n        user.requiredActions.remove(action)  # Remove the action\n        user: KeycloakUser = idp.update_user(user=user)  # Save the change\n        assert idp.user_login(\n            username=user.username, password=TEST_PASSWORD\n        )  # Login possible again\n\n        # Clean up\n        idp.delete_user(user_id=user.id)\n\n    def test_user_not_found_exception(self, idp):\n        with pytest.raises(UserNotFound):  # Expect the get to fail due to a non existent user\n            idp.get_user(user_id='abc')\n\n        with pytest.raises(UserNotFound):  # Expect the get to fail due to a failed query search\n            idp.get_user(query='username=\"some_non_existant_username\"')\n"}
{"type": "source_file", "path": "documentation/docs/examples/introduction/app.py", "content": "import uvicorn\nfrom fastapi import FastAPI, Depends\n\nfrom fastapi_keycloak import FastAPIKeycloak, OIDCUser\n\napp = FastAPI()\nidp = FastAPIKeycloak(\n    server_url=\"https://auth.some-domain.com/auth\",\n    client_id=\"some-client\",\n    client_secret=\"some-client-secret\",\n    admin_client_secret=\"admin-cli-secret\",\n    realm=\"some-realm-name\",\n    callback_uri=\"http://localhost:8081/callback\"\n)\nidp.add_swagger_config(app)\n\n@app.get(\"/admin\")\ndef admin(user: OIDCUser = Depends(idp.get_current_user(required_roles=[\"admin\"]))):\n    return f'Hi premium user {user}'\n\n\n@app.get(\"/user/roles\")\ndef user_roles(user: OIDCUser = Depends(idp.get_current_user)):\n    return f'{user.roles}'\n\n\nif __name__ == '__main__':\n    uvicorn.run('app:app', host=\"127.0.0.1\", port=8081)\n"}
{"type": "source_file", "path": "fastapi_keycloak/__init__.py", "content": "\"\"\"Keycloak API Client for integrating authentication and authorization with FastAPI\"\"\"\n\n__version__ = \"1.0.10\"\n\nfrom fastapi_keycloak.api import FastAPIKeycloak\nfrom fastapi_keycloak.model import (HTTPMethod, KeycloakError, KeycloakGroup,\n                                    KeycloakIdentityProvider, KeycloakRole,\n                                    KeycloakToken, KeycloakUser, OIDCUser,\n                                    UsernamePassword)\n\n__all__ = [\n    FastAPIKeycloak.__name__,\n    OIDCUser.__name__,\n    UsernamePassword.__name__,\n    HTTPMethod.__name__,\n    KeycloakError.__name__,\n    KeycloakUser.__name__,\n    KeycloakToken.__name__,\n    KeycloakRole.__name__,\n    KeycloakIdentityProvider.__name__,\n    KeycloakGroup.__name__,\n]\n"}
{"type": "source_file", "path": "documentation/docs/examples/full_example/full_example.py", "content": "from typing import List, Optional\n\nimport uvicorn\nfrom fastapi import FastAPI, Depends, Query, Body, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import SecretStr\n\nfrom fastapi_keycloak import (\n    FastAPIKeycloak,\n    OIDCUser,\n    UsernamePassword,\n    HTTPMethod,\n    KeycloakUser,\n    KeycloakGroup,\n    KeycloakError\n)\n\napp = FastAPI()\nidp = FastAPIKeycloak(\n    server_url=\"http://localhost:8085/auth\",\n    client_id=\"test-client\",\n    client_secret=\"GzgACcJzhzQ4j8kWhmhazt7WSdxDVUyE\",\n    admin_client_secret=\"BIcczGsZ6I8W5zf0rZg5qSexlloQLPKB\",\n    realm=\"Test\",\n    callback_uri=\"http://localhost:8081/callback\"\n)\nidp.add_swagger_config(app)\n\n\n# Custom error handler for showing Keycloak errors on FastAPI\n@app.exception_handler(KeycloakError)\nasync def keycloak_exception_handler(request: Request, exc: KeycloakError):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.reason},\n    )\n\n    \n# Admin\n\n@app.post(\"/proxy\", tags=[\"admin-cli\"])\ndef proxy_admin_request(\n    relative_path: str,\n    method: HTTPMethod,\n    additional_headers: dict = Body(None),\n    payload: dict = Body(None),\n):\n    return idp.proxy(\n        additional_headers=additional_headers,\n        relative_path=relative_path,\n        method=method,\n        payload=payload\n    )\n\n\n@app.get(\"/identity-providers\", tags=[\"admin-cli\"])\ndef get_identity_providers():\n    return idp.get_identity_providers()\n\n\n@app.get(\"/idp-configuration\", tags=[\"admin-cli\"])\ndef get_idp_config():\n    return idp.open_id_configuration\n\n\n# User Management\n\n@app.get(\"/users\", tags=[\"user-management\"])\ndef get_users():\n    return idp.get_all_users()\n\n\n@app.get(\"/user\", tags=[\"user-management\"])\ndef get_user_by_query(query: str = None):\n    return idp.get_user(query=query)\n\n\n@app.post(\"/users\", tags=[\"user-management\"])\ndef create_user(\n    first_name: str, last_name: str, email: str, password: SecretStr, id: str = None\n):\n    return idp.create_user(\n        first_name=first_name,\n        last_name=last_name,\n        username=email,\n        email=email,\n        password=password.get_secret_value(),\n        id=id\n    )\n\n\n@app.get(\"/user/{user_id}\", tags=[\"user-management\"])\ndef get_user(user_id: str = None):\n    return idp.get_user(user_id=user_id)\n\n\n@app.put(\"/user\", tags=[\"user-management\"])\ndef update_user(user: KeycloakUser):\n    return idp.update_user(user=user)\n\n\n@app.delete(\"/user/{user_id}\", tags=[\"user-management\"])\ndef delete_user(user_id: str):\n    return idp.delete_user(user_id=user_id)\n\n\n@app.put(\"/user/{user_id}/change-password\", tags=[\"user-management\"])\ndef change_password(user_id: str, new_password: SecretStr):\n    return idp.change_password(user_id=user_id, new_password=new_password)\n\n\n@app.put(\"/user/{user_id}/send-email-verification\", tags=[\"user-management\"])\ndef send_email_verification(user_id: str):\n    return idp.send_email_verification(user_id=user_id)\n\n\n# Role Management\n\n@app.get(\"/roles\", tags=[\"role-management\"])\ndef get_all_roles():\n    return idp.get_all_roles()\n\n\n@app.get(\"/role/{role_name}\", tags=[\"role-management\"])\ndef get_role(role_name: str):\n    return idp.get_roles([role_name])\n\n\n@app.post(\"/roles\", tags=[\"role-management\"])\ndef add_role(role_name: str):\n    return idp.create_role(role_name=role_name)\n\n\n@app.delete(\"/roles\", tags=[\"role-management\"])\ndef delete_roles(role_name: str):\n    return idp.delete_role(role_name=role_name)\n\n\n# Group Management\n\n@app.get(\"/groups\", tags=[\"group-management\"])\ndef get_all_groups():\n    return idp.get_all_groups()\n\n\n@app.get(\"/group/{group_name}\", tags=[\"group-management\"])\ndef get_group(group_name: str):\n    return idp.get_groups([group_name])\n\n\n@app.get(\"/group-by-path/{path: path}\", tags=[\"group-management\"])\ndef get_group_by_path(path: str):\n    return idp.get_group_by_path(path)\n\n\n@app.post(\"/groups\", tags=[\"group-management\"])\ndef add_group(group_name: str, parent_id: Optional[str] = None):\n    return idp.create_group(group_name=group_name, parent=parent_id)\n\n\n@app.delete(\"/groups\", tags=[\"group-management\"])\ndef delete_groups(group_id: str):\n    return idp.delete_group(group_id=group_id)\n\n\n# User Roles\n\n@app.post(\"/users/{user_id}/roles\", tags=[\"user-roles\"])\ndef add_roles_to_user(user_id: str, roles: Optional[List[str]] = Query(None)):\n    return idp.add_user_roles(user_id=user_id, roles=roles)\n\n\n@app.get(\"/users/{user_id}/roles\", tags=[\"user-roles\"])\ndef get_user_roles(user_id: str):\n    return idp.get_user_roles(user_id=user_id)\n\n\n@app.delete(\"/users/{user_id}/roles\", tags=[\"user-roles\"])\ndef delete_roles_from_user(user_id: str, roles: Optional[List[str]] = Query(None)):\n    return idp.remove_user_roles(user_id=user_id, roles=roles)\n\n\n# User Groups\n\n@app.post(\"/users/{user_id}/groups\", tags=[\"user-groups\"])\ndef add_group_to_user(user_id: str, group_id: str):\n    return idp.add_user_group(user_id=user_id, group_id=group_id)\n\n\n@app.get(\"/users/{user_id}/groups\", tags=[\"user-groups\"])\ndef get_user_groups(user_id: str):\n    return idp.get_user_groups(user_id=user_id)\n\n\n@app.delete(\"/users/{user_id}/groups\", tags=[\"user-groups\"])\ndef delete_groups_from_user(user_id: str, group_id: str):\n    return idp.remove_user_group(user_id=user_id, group_id=group_id)\n\n\n# Example User Requests\n\n@app.get(\"/protected\", tags=[\"example-user-request\"])\ndef protected(user: OIDCUser = Depends(idp.get_current_user())):\n    return user\n\n\n@app.get(\"/current_user/roles\", tags=[\"example-user-request\"])\ndef get_current_users_roles(user: OIDCUser = Depends(idp.get_current_user())):\n    return user.roles\n\n\n@app.get(\"/admin\", tags=[\"example-user-request\"])\ndef company_admin(user: OIDCUser = Depends(idp.get_current_user(required_roles=[\"admin\"]))):\n    return f\"Hi admin {user}\"\n\n\n@app.post(\"/login\", tags=[\"example-user-request\"])\ndef login(user: UsernamePassword = Body(...)):\n    return idp.user_login(\n        username=user.username, password=user.password.get_secret_value()\n    )\n\n\n# Auth Flow\n\n@app.get(\"/login-link\", tags=[\"auth-flow\"])\ndef login_redirect():\n    return idp.login_uri\n\n\n@app.get(\"/callback\", tags=[\"auth-flow\"])\ndef callback(session_state: str, code: str):\n    return idp.exchange_authorization_code(session_state=session_state, code=code)\n\n\n@app.get(\"/logout\", tags=[\"auth-flow\"])\ndef logout():\n    return idp.logout_uri\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"app:app\", host=\"127.0.0.1\", port=8081)\n"}
{"type": "source_file", "path": "documentation/docs/examples/quickstart/app.py", "content": "import uvicorn\nfrom fastapi import FastAPI, Depends\nfrom fastapi.responses import RedirectResponse\nfrom fastapi_keycloak import FastAPIKeycloak, OIDCUser\n\napp = FastAPI()\nidp = FastAPIKeycloak(\n    server_url=\"http://localhost:8085/auth\",\n    client_id=\"test-client\",\n    client_secret=\"GzgACcJzhzQ4j8kWhmhazt7WSdxDVUyE\",\n    admin_client_secret=\"BIcczGsZ6I8W5zf0rZg5qSexlloQLPKB\",\n    realm=\"Test\",\n    callback_uri=\"http://localhost:8081/callback\"\n)\nidp.add_swagger_config(app)\n\n\n@app.get(\"/\")  # Unprotected\ndef root():\n    return 'Hello World'\n\n\n@app.get(\"/user\")  # Requires logged in\ndef current_users(user: OIDCUser = Depends(idp.get_current_user())):\n    return user\n\n\n@app.get(\"/admin\")  # Requires the admin role\ndef company_admin(user: OIDCUser = Depends(idp.get_current_user(required_roles=[\"admin\"]))):\n    return f'Hi admin {user}'\n\n\n@app.get(\"/login\")\ndef login_redirect():\n    return RedirectResponse(idp.login_uri)\n\n\n@app.get(\"/callback\")\ndef callback(session_state: str, code: str):\n    return idp.exchange_authorization_code(session_state=session_state, code=code)  # This will return an access token\n\n\nif __name__ == '__main__':\n    uvicorn.run('app:app', host=\"127.0.0.1\", port=8081)\n"}
{"type": "source_file", "path": "fastapi_keycloak/api.py", "content": "from __future__ import annotations\n\nimport functools\nimport json\nfrom json import JSONDecodeError\nfrom typing import Any, Callable, List, Type, Union\nfrom urllib.parse import urlencode\n\nimport requests\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import ExpiredSignatureError, JWTError, jwt\nfrom jose.exceptions import JWTClaimsError\nfrom pydantic import BaseModel\nfrom requests import Response\n\nfrom fastapi_keycloak.exceptions import (\n    ConfigureTOTPException,\n    KeycloakError,\n    MandatoryActionException,\n    UpdatePasswordException,\n    UpdateProfileException,\n    UpdateUserLocaleException,\n    UserNotFound,\n    VerifyEmailException,\n)\nfrom fastapi_keycloak.model import (\n    HTTPMethod,\n    KeycloakGroup,\n    KeycloakIdentityProvider,\n    KeycloakRole,\n    KeycloakToken,\n    KeycloakUser,\n    OIDCUser,\n)\n\n\ndef result_or_error(\n        response_model: Type[BaseModel] = None, is_list: bool = False\n) -> List[BaseModel] or BaseModel or KeycloakError:\n    \"\"\"Decorator used to ease the handling of responses from Keycloak.\n\n    Args:\n        response_model (Type[BaseModel]): Object that should be returned based on the payload\n        is_list (bool): True if the return value should be a list of the response model provided\n\n    Returns:\n        BaseModel or List[BaseModel]: Based on the given signature and response circumstances\n\n    Raises:\n        KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n\n    Notes:\n        - Keycloak sometimes returns empty payloads but describes the error in its content (byte encoded)\n          which is why this function checks for JSONDecode exceptions.\n        - Keycloak often does not expose the real error for security measures. You will most likely encounter:\n          {'error': 'unknown_error'} as a result. If so, please check the logs of your Keycloak instance to get error\n          details, the RestAPI doesn't provide any.\n    \"\"\"\n\n    def inner(f):\n        @functools.wraps(f)\n        def wrapper(*args, **kwargs):\n            def create_list(json_data: List[dict]):\n                return [response_model.parse_obj(entry) for entry in json_data]\n\n            def create_object(json_data: dict):\n                return response_model.parse_obj(json_data)\n\n            result: Response = f(*args, **kwargs)  # The actual call\n\n            if (\n                    type(result) != Response\n            ):  # If the object given is not a response object, directly return it.\n                return result\n\n            if result.status_code in range(100, 299):  # Successful\n                if response_model is None:  # No model given\n\n                    try:\n                        return result.json()\n                    except JSONDecodeError:\n                        return result.content.decode(\"utf-8\")\n\n                else:  # Response model given\n                    if is_list:\n                        return create_list(result.json())\n                    else:\n                        return create_object(result.json())\n\n            else:  # Not Successful, forward status code and error\n                try:\n                    raise KeycloakError(\n                        status_code=result.status_code, reason=result.json()\n                    )\n                except JSONDecodeError:\n                    raise KeycloakError(\n                        status_code=result.status_code,\n                        reason=result.content.decode(\"utf-8\"),\n                    )\n\n        return wrapper\n\n    return inner\n\n\nclass FastAPIKeycloak:\n    \"\"\"Instance to wrap the Keycloak API with FastAPI\n\n    Attributes: _admin_token (KeycloakToken): A KeycloakToken instance, containing the access token that is used for\n    any admin related request\n\n    Example:\n        ```python\n        app = FastAPI()\n        idp = KeycloakFastAPI(\n            server_url=\"https://auth.some-domain.com/auth\",\n            client_id=\"some-test-client\",\n            client_secret=\"some-secret\",\n            admin_client_secret=\"some-admin-cli-secret\",\n            realm=\"Test\",\n            callback_uri=f\"http://localhost:8081/callback\"\n        )\n        idp.add_swagger_config(app)\n        ```\n    \"\"\"\n\n    _admin_token: str\n\n    def __init__(\n            self,\n            server_url: str,\n            client_id: str,\n            client_secret: str,\n            realm: str,\n            admin_client_secret: str,\n            callback_uri: str,\n            admin_client_id: str = \"admin-cli\",\n            scope: str = \"openid profile email\",\n            timeout: int = 10,\n    ):\n        \"\"\"FastAPIKeycloak constructor\n\n        Args:\n            server_url (str): The URL of the Keycloak server, with `/auth` suffix\n            client_id (str): The id of the client used for users\n            client_secret (str): The client secret\n            realm (str): The realm (name)\n            admin_client_id (str): The id for the admin client, defaults to 'admin-cli'\n            admin_client_secret (str): Secret for the `admin-cli` client\n            callback_uri (str): Callback URL of the instance, used for auth flows. Must match at least one\n            `Valid Redirect URIs` of Keycloak and should point to an endpoint that utilizes the authorization_code flow.\n            timeout (int): Timeout in seconds to wait for the server\n            scope (str): OIDC scope\n        \"\"\"\n        self.server_url = server_url\n        self.realm = realm\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.admin_client_id = admin_client_id\n        self.admin_client_secret = admin_client_secret\n        self.callback_uri = callback_uri\n        self.timeout = timeout\n        self.scope = scope\n        self._get_admin_token()  # Requests an admin access token on startup\n\n    @property\n    def admin_token(self):\n        \"\"\"Holds an AccessToken for the `admin-cli` client\n\n        Returns:\n            KeycloakToken: A token, valid to perform admin actions\n\n        Notes:\n            - This might result in an infinite recursion if something unforeseen goes wrong\n        \"\"\"\n        if self.token_is_valid(token=self._admin_token):\n            return self._admin_token\n        self._get_admin_token()\n        return self.admin_token\n\n    @admin_token.setter\n    def admin_token(self, value: str):\n        \"\"\"Setter for the admin_token\n\n        Args:\n            value (str): An access Token\n\n        Returns:\n            None: Inplace method, updates the _admin_token\n        \"\"\"\n        decoded_token = self._decode_token(token=value)\n        if not decoded_token.get(\"resource_access\").get(\n                \"realm-management\"\n        ) or not decoded_token.get(\"resource_access\").get(\"account\"):\n            raise AssertionError(\n                \"\"\"The access required was not contained in the access token for the `admin-cli`.\n                Possibly a Keycloak misconfiguration. Check if the admin-cli client has `Full Scope Allowed`\n                and that the `Service Account Roles` contain all roles from `account` and `realm_management`\"\"\"\n            )\n        self._admin_token = value\n\n    def add_swagger_config(self, app: FastAPI):\n        \"\"\"Adds the client id and secret securely to the swagger ui.\n        Enabling Swagger ui users to perform actions they usually need the client credentials, without exposing them.\n\n        Args:\n            app (FastAPI): Optional FastAPI app to add the config to swagger\n\n        Returns:\n            None: Inplace method\n        \"\"\"\n        app.swagger_ui_init_oauth = {\n            \"usePkceWithAuthorizationCodeGrant\": True,\n            \"clientId\": self.client_id,\n            \"clientSecret\": self.client_secret,\n        }\n\n    @functools.cached_property\n    def user_auth_scheme(self) -> OAuth2PasswordBearer:\n        \"\"\"Returns the auth scheme to register the endpoints with swagger\n\n        Returns:\n            OAuth2PasswordBearer: Auth scheme for swagger\n        \"\"\"\n        return OAuth2PasswordBearer(tokenUrl=self.token_uri)\n\n    def get_current_user(self, required_roles: List[str] = None, extra_fields: List[str] = None) -> Callable[OAuth2PasswordBearer, OIDCUser]:\n        \"\"\"Returns the current user based on an access token in the HTTP-header. Optionally verifies roles are possessed\n        by the user\n\n        Args:\n            required_roles List[str]: List of role names required for this endpoint\n            extra_fields List[str]: The names of the additional fields you need that are encoded in JWT\n\n        Returns:\n            Callable[OAuth2PasswordBearer, OIDCUser]: Dependency method which returns the decoded JWT content\n\n        Raises:\n            ExpiredSignatureError: If the token is expired (exp > datetime.now())\n            JWTError: If decoding fails or the signature is invalid\n            JWTClaimsError: If any claim is invalid\n            HTTPException: If any role required is not contained within the roles of the users\n        \"\"\"\n\n        def current_user(\n                token: OAuth2PasswordBearer = Depends(self.user_auth_scheme),\n        ) -> OIDCUser:\n            \"\"\"Decodes and verifies a JWT to get the current user\n\n            Args:\n                token OAuth2PasswordBearer: Access token in `Authorization` HTTP-header\n\n            Returns:\n                OIDCUser: Decoded JWT content\n\n            Raises:\n                ExpiredSignatureError: If the token is expired (exp > datetime.now())\n                JWTError: If decoding fails or the signature is invalid\n                JWTClaimsError: If any claim is invalid\n                HTTPException: If any role required is not contained within the roles of the users\n            \"\"\"\n            decoded_token = self._decode_token(token=token, audience=\"account\")\n            user = OIDCUser.parse_obj(decoded_token)\n            if required_roles:\n                for role in required_roles:\n                    if role not in user.roles:\n                        raise HTTPException(\n                            status_code=status.HTTP_403_FORBIDDEN,\n                            detail=f'Role \"{role}\" is required to perform this action',\n                        )\n\n            if extra_fields:\n                for field in extra_fields:\n                    user.extra_fields[field] = decoded_token.get(field, None)\n\n            return user\n\n        return current_user\n\n    @functools.cached_property\n    def open_id_configuration(self) -> dict:\n        \"\"\"Returns Keycloaks Open ID Connect configuration\n\n        Returns:\n            dict: Open ID Configuration\n        \"\"\"\n        response = requests.get(\n            url=f\"{self.realm_uri}/.well-known/openid-configuration\",\n            timeout=self.timeout,\n        )\n        return response.json()\n\n    def proxy(\n            self,\n            relative_path: str,\n            method: HTTPMethod,\n            additional_headers: dict = None,\n            payload: dict = None,\n    ) -> Response:\n        \"\"\"Proxies a request to Keycloak and automatically adds the required Authorization header. Should not be\n        exposed under any circumstances. Grants full API admin access.\n\n        Args:\n\n            relative_path (str): The relative path of the request.\n            Requests will be sent to: `[server_url]/[relative_path]`\n            method (HTTPMethod): The HTTP-verb to be used\n            additional_headers (dict): Optional headers besides the Authorization to add to the request\n            payload (dict): Optional payload to send\n\n        Returns:\n            Response: Proxied response\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        headers = {\"Authorization\": f\"Bearer {self.admin_token}\"}\n        if additional_headers is not None:\n            headers = {**headers, **additional_headers}\n\n        return requests.request(\n            method=method.name,\n            url=f\"{self.server_url}{relative_path}\",\n            data=json.dumps(payload),\n            headers=headers,\n            timeout=self.timeout,\n        )\n\n    def _get_admin_token(self) -> None:\n        \"\"\"Exchanges client credentials (admin-cli) for an access token.\n\n        Returns:\n            None: Inplace method that updated the class attribute `_admin_token`\n\n        Raises:\n            KeycloakError: If fetching an admin access token fails,\n            or the response does not contain an access_token at all\n\n        Notes:\n            - Is executed on startup and may be executed again if the token validation fails\n        \"\"\"\n        headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        data = {\n            \"client_id\": self.admin_client_id,\n            \"client_secret\": self.admin_client_secret,\n            \"grant_type\": \"client_credentials\",\n        }\n        response = requests.post(url=self.token_uri, headers=headers, data=data, timeout=self.timeout)\n        try:\n            self.admin_token = response.json()[\"access_token\"]\n        except JSONDecodeError as e:\n            raise KeycloakError(\n                reason=response.content.decode(\"utf-8\"),\n                status_code=response.status_code,\n            ) from e\n\n        except KeyError as e:\n            raise KeycloakError(\n                reason=f\"The response did not contain an access_token: {response.json()}\",\n                status_code=403,\n            ) from e\n\n    @functools.cached_property\n    def public_key(self) -> str:\n        \"\"\"Returns the Keycloak public key\n\n        Returns:\n            str: Public key for JWT decoding\n        \"\"\"\n        response = requests.get(url=self.realm_uri, timeout=self.timeout)\n        public_key = response.json()[\"public_key\"]\n        return f\"-----BEGIN PUBLIC KEY-----\\n{public_key}\\n-----END PUBLIC KEY-----\"\n\n    @result_or_error()\n    def add_user_roles(self, roles: List[str], user_id: str) -> dict:\n        \"\"\"Adds roles to a specific user\n\n        Args:\n            roles List[str]: Roles to add (name)\n            user_id str: ID of the user the roles should be added to\n\n        Returns:\n            dict: Proxied response payload\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        keycloak_roles = self.get_roles(roles)\n        return self._admin_request(\n            url=f\"{self.users_uri}/{user_id}/role-mappings/realm\",\n            data=[role.__dict__ for role in keycloak_roles],\n            method=HTTPMethod.POST,\n        )\n\n    @result_or_error()\n    def remove_user_roles(self, roles: List[str], user_id: str) -> dict:\n        \"\"\"Removes roles from a specific user\n\n        Args:\n            roles List[str]: Roles to remove (name)\n            user_id str: ID of the user the roles should be removed from\n\n        Returns:\n            dict: Proxied response payload\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        keycloak_roles = self.get_roles(roles)\n        return self._admin_request(\n            url=f\"{self.users_uri}/{user_id}/role-mappings/realm\",\n            data=[role.__dict__ for role in keycloak_roles],\n            method=HTTPMethod.DELETE,\n        )\n\n    @result_or_error(response_model=KeycloakRole, is_list=True)\n    def get_roles(self, role_names: List[str]) -> List[Any] | None:\n        \"\"\"Returns full entries of Roles based on role names\n\n        Args:\n            role_names List[str]: Roles that should be looked up (names)\n\n        Returns:\n             List[KeycloakRole]: Full entries stored at Keycloak. Or None if the list of requested roles is None\n\n        Notes:\n            - The Keycloak RestAPI will only identify RoleRepresentations that\n              use name AND id which is the only reason for existence of this function\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        if role_names is None:\n            return\n        roles = self.get_all_roles()\n        return list(filter(lambda role: role.name in role_names, roles))\n\n    @result_or_error(response_model=KeycloakRole, is_list=True)\n    def get_user_roles(self, user_id: str) -> List[KeycloakRole]:\n        \"\"\"Gets all roles of a user\n\n        Args:\n            user_id (str): ID of the user of interest\n\n        Returns:\n            List[KeycloakRole]: All roles possessed by the user\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.users_uri}/{user_id}/role-mappings/realm\", method=HTTPMethod.GET\n        )\n\n    @result_or_error(response_model=KeycloakRole)\n    def create_role(self, role_name: str) -> KeycloakRole:\n        \"\"\"Create a role on the realm\n\n        Args:\n            role_name (str): Name of the new role\n\n        Returns:\n            KeycloakRole: If creation succeeded, else it will return the error\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        response = self._admin_request(\n            url=self.roles_uri, data={\"name\": role_name}, method=HTTPMethod.POST\n        )\n        if response.status_code == 201:\n            return self.get_roles(role_names=[role_name])[0]\n        else:\n            return response\n\n    @result_or_error(response_model=KeycloakRole, is_list=True)\n    def get_all_roles(self) -> List[KeycloakRole]:\n        \"\"\"Get all roles of the Keycloak realm\n\n        Returns:\n            List[KeycloakRole]: All roles of the realm\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(url=self.roles_uri, method=HTTPMethod.GET)\n\n    @result_or_error()\n    def delete_role(self, role_name: str) -> dict:\n        \"\"\"Deletes a role on the realm\n\n        Args:\n            role_name (str): The role (name) to delte\n\n        Returns:\n            dict: Proxied response payload\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.roles_uri}/{role_name}\",\n            method=HTTPMethod.DELETE,\n        )\n\n    @result_or_error(response_model=KeycloakGroup, is_list=True)\n    def get_all_groups(self) -> List[KeycloakGroup]:\n        \"\"\"Get all base groups of the Keycloak realm\n\n        Returns:\n            List[KeycloakGroup]: All base groups of the realm\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(url=self.groups_uri, method=HTTPMethod.GET)\n\n    @result_or_error(response_model=KeycloakGroup, is_list=True)\n    def get_groups(self, group_names: List[str]) -> List[Any] | None:\n        \"\"\"Returns full entries of base Groups based on group names\n\n        Args:\n            group_names (List[str]): Groups that should be looked up (names)\n\n        Returns:\n            List[KeycloakGroup]: Full entries stored at Keycloak. Or None if the list of requested groups is None\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        if group_names is None:\n            return\n        groups = self.get_all_groups()\n        return list(filter(lambda group: group.name in group_names, groups))\n\n    def get_subgroups(self, group: KeycloakGroup, path: str):\n        \"\"\"Utility function to iterate through nested group structures\n\n        Args:\n            group (KeycloakGroup): Group Representation\n            path (str): Subgroup path\n\n        Returns:\n            KeycloakGroup: Keycloak group representation or none if not exists\n        \"\"\"\n        for subgroup in group.subGroups:\n            if subgroup.path == path:\n                return subgroup\n            elif subgroup.subGroups:\n                for subgroup in group.subGroups:\n                    if subgroups := self.get_subgroups(subgroup, path):\n                        return subgroups\n        # Went through the tree without hits\n        return None\n\n    @result_or_error(response_model=KeycloakGroup)\n    def get_group_by_path(\n            self, path: str, search_in_subgroups=True\n    ) -> KeycloakGroup or None:\n        \"\"\"Return Group based on path\n\n        Args:\n            path (str): Path that should be looked up\n            search_in_subgroups (bool): Whether to search in subgroups\n\n        Returns:\n            KeycloakGroup: Full entries stored at Keycloak. Or None if the path not found\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        groups = self.get_all_groups()\n\n        for group in groups:\n            if group.path == path:\n                return group\n            elif search_in_subgroups and group.subGroups:\n                for group in group.subGroups:\n                    if group.path == path:\n                        return group\n                    res = self.get_subgroups(group, path)\n                    if res is not None:\n                        return res\n\n    @result_or_error(response_model=KeycloakGroup)\n    def get_group(self, group_id: str) -> KeycloakGroup or None:\n        \"\"\"Return Group based on group id\n\n        Args:\n            group_id (str): Group id to be found\n\n        Returns:\n             KeycloakGroup: Keycloak object by id. Or None if the id is invalid\n\n        Notes:\n            - The Keycloak RestAPI will only identify GroupRepresentations that\n              use name AND id which is the only reason for existence of this function\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.groups_uri}/{group_id}\",\n            method=HTTPMethod.GET,\n        )\n\n    @result_or_error(response_model=KeycloakGroup)\n    def create_group(\n            self, group_name: str, parent: Union[KeycloakGroup, str] = None\n    ) -> KeycloakGroup:\n        \"\"\"Create a group on the realm\n\n        Args:\n            group_name (str): Name of the new group\n            parent (Union[KeycloakGroup, str]): Can contain an instance or object id\n\n        Returns:\n            KeycloakGroup: If creation succeeded, else it will return the error\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n\n        # If it's an objetc id get an instance of the object\n        if isinstance(parent, str):\n            parent = self.get_group(parent)\n\n        if parent is not None:\n            groups_uri = f\"{self.groups_uri}/{parent.id}/children\"\n            path = f\"{parent.path}/{group_name}\"\n        else:\n            groups_uri = self.groups_uri\n            path = f\"/{group_name}\"\n\n        response = self._admin_request(\n            url=groups_uri, data={\"name\": group_name}, method=HTTPMethod.POST\n        )\n        if response.status_code == 201:\n            return self.get_group_by_path(path=path, search_in_subgroups=True)\n        else:\n            return response\n\n    @result_or_error()\n    def delete_group(self, group_id: str) -> dict:\n        \"\"\"Deletes a group on the realm\n\n        Args:\n            group_id (str): The group (id) to delte\n\n        Returns:\n            dict: Proxied response payload\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.groups_uri}/{group_id}\",\n            method=HTTPMethod.DELETE,\n        )\n\n    @result_or_error()\n    def add_user_group(self, user_id: str, group_id: str) -> dict:\n        \"\"\"Add group to a specific user\n\n        Args:\n            user_id (str): ID of the user the group should be added to\n            group_id (str): Group to add (id)\n\n        Returns:\n            dict: Proxied response payload\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.users_uri}/{user_id}/groups/{group_id}\", method=HTTPMethod.PUT\n        )\n\n    @result_or_error(response_model=KeycloakGroup, is_list=True)\n    def get_user_groups(self, user_id: str) -> List[KeycloakGroup]:\n        \"\"\"Gets all groups of an user\n\n        Args:\n            user_id (str): ID of the user of interest\n\n        Returns:\n            List[KeycloakGroup]: All groups possessed by the user\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.users_uri}/{user_id}/groups\",\n            method=HTTPMethod.GET,\n        )\n    \n    @result_or_error(response_model=KeycloakUser, is_list=True)\n    def get_group_members(self, group_id: str):\n        \"\"\"Get all members of a group.\n        \n        Args:\n            group_id (str): ID of the group of interest\n\n        Returns:\n            List[KeycloakUser]: All users in the group. Note that\n            the user objects returned are not fully populated.\n        \n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.groups_uri}/{group_id}/members\",\n            method=HTTPMethod.GET,\n        )\n\n    @result_or_error()\n    def remove_user_group(self, user_id: str, group_id: str) -> dict:\n        \"\"\"Remove group from a specific user\n\n        Args:\n            user_id str: ID of the user the groups should be removed from\n            group_id str: Group to remove (id)\n\n        Returns:\n            dict: Proxied response payload\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.users_uri}/{user_id}/groups/{group_id}\",\n            method=HTTPMethod.DELETE,\n        )\n\n    @result_or_error(response_model=KeycloakUser)\n    def create_user(\n            self,\n            first_name: str,\n            last_name: str,\n            username: str,\n            email: str,\n            password: str,\n            enabled: bool = True,\n            initial_roles: List[str] = None,\n            send_email_verification: bool = True,\n            attributes: dict[str, Any] = None,\n    ) -> KeycloakUser:\n        \"\"\"\n\n        Args:\n            first_name (str): The first name of the new user\n            last_name (str): The last name of the new user\n            username (str): The username of the new user\n            email (str): The email of the new user\n            password (str): The password of the new user\n            initial_roles (List[str]): The roles the user should posses. Defaults to `None`\n            enabled (bool): True if the user should be able to be used. Defaults to `True`\n            send_email_verification (bool): If true, the email verification will be added as an required\n                                            action and the email triggered - if the user was created successfully.\n                                            Defaults to `True`\n            attributes (dict): attributes of new user\n\n        Returns:\n            KeycloakUser: If the creation succeeded\n\n        Notes:\n            - Also triggers the email verification email\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        data = {\n            \"email\": email,\n            \"username\": username,\n            \"firstName\": first_name,\n            \"lastName\": last_name,\n            \"enabled\": enabled,\n            \"credentials\": [\n                {\"temporary\": False, \"type\": \"password\", \"value\": password}\n            ],\n            \"requiredActions\": [\"VERIFY_EMAIL\" if send_email_verification else None],\n            \"attributes\": attributes,\n        }\n        response = self._admin_request(\n            url=self.users_uri, data=data, method=HTTPMethod.POST\n        )\n        if response.status_code != 201:\n            return response\n        user = self.get_user(query=f\"username={username}\")\n        if send_email_verification:\n            self.send_email_verification(user.id)\n        if initial_roles:\n            self.add_user_roles(initial_roles, user.id)\n            user = self.get_user(user_id=user.id)\n        return user\n\n    @result_or_error()\n    def change_password(\n            self, user_id: str, new_password: str, temporary: bool = False\n    ) -> dict:\n        \"\"\"Exchanges a users' password.\n\n        Args:\n            temporary (bool): If True, the password must be changed on the first login\n            user_id (str): The user ID of interest\n            new_password (str): The new password\n\n        Returns:\n            dict: Proxied response payload\n\n        Notes:\n            - Possibly should be extended by an old password check\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        credentials = {\n            \"temporary\": temporary,\n            \"type\": \"password\",\n            \"value\": new_password,\n        }\n        return self._admin_request(\n            url=f\"{self.users_uri}/{user_id}/reset-password\",\n            data=credentials,\n            method=HTTPMethod.PUT,\n        )\n\n    @result_or_error()\n    def send_email_verification(self, user_id: str) -> dict:\n        \"\"\"Sends the email to verify the email address\n\n        Args:\n            user_id (str): The user ID of interest\n\n        Returns:\n            dict: Proxied response payload\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.users_uri}/{user_id}/send-verify-email\",\n            method=HTTPMethod.PUT,\n        )\n\n    @result_or_error(response_model=KeycloakUser)\n    def get_user(self, user_id: str = None, query: str = \"\") -> KeycloakUser:\n        \"\"\"Queries the keycloak API for a specific user either based on its ID or any **native** attribute\n\n        Args:\n            user_id (str): The user ID of interest\n            query: Query string. e.g. `email=testuser@codespecialist.com` or `username=codespecialist`\n\n        Returns:\n            KeycloakUser: If the user was found\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        if user_id is None:\n            response = self._admin_request(\n                url=f\"{self.users_uri}?{query}\", method=HTTPMethod.GET\n            )\n            if not response.json():\n                raise UserNotFound(\n                    status_code = status.HTTP_404_NOT_FOUND,\n                    reason=f\"User query with filters of [{query}] did no match any users\"\n                )\n            return KeycloakUser(**response.json()[0])\n        else:\n            response = self._admin_request(\n                url=f\"{self.users_uri}/{user_id}\", method=HTTPMethod.GET\n            )\n            if response.status_code == status.HTTP_404_NOT_FOUND:\n                raise UserNotFound(\n                    status_code = status.HTTP_404_NOT_FOUND,\n                    reason=f\"User with user_id[{user_id}] was not found\"\n                )\n            return KeycloakUser(**response.json())\n\n    @result_or_error(response_model=KeycloakUser)\n    def update_user(self, user: KeycloakUser):\n        \"\"\"Updates a user. Requires the whole object.\n\n        Args:\n            user (KeycloakUser): The (new) user object\n\n        Returns:\n            KeycloakUser: The updated user\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n\n        Notes: - You may alter any aspect of the user object, also the requiredActions for instance. There is no\n        explicit function for updating those as it is a user update in essence\n        \"\"\"\n        response = self._admin_request(\n            url=f\"{self.users_uri}/{user.id}\", data=user.__dict__, method=HTTPMethod.PUT\n        )\n        if response.status_code == 204:  # Update successful\n            return self.get_user(user_id=user.id)\n        return response\n\n    @result_or_error()\n    def delete_user(self, user_id: str) -> dict:\n        \"\"\"Deletes an user\n\n        Args:\n            user_id (str): The user ID of interest\n\n        Returns:\n            dict: Proxied response payload\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(\n            url=f\"{self.users_uri}/{user_id}\",\n            method=HTTPMethod.DELETE\n        )\n\n    @result_or_error(response_model=KeycloakUser, is_list=True)\n    def get_all_users(self) -> List[KeycloakUser]:\n        \"\"\"Returns all users of the realm\n\n        Returns:\n            List[KeycloakUser]: All Keycloak users of the realm\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(url=self.users_uri, method=HTTPMethod.GET)\n\n    @result_or_error(response_model=KeycloakIdentityProvider, is_list=True)\n    def get_identity_providers(self) -> List[KeycloakIdentityProvider]:\n        \"\"\"Returns all configured identity Providers\n\n        Returns:\n            List[KeycloakIdentityProvider]: All configured identity providers\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        return self._admin_request(url=self.providers_uri, method=HTTPMethod.GET).json()\n\n    @result_or_error(response_model=KeycloakToken)\n    def user_login(self, username: str, password: str) -> KeycloakToken:\n        \"\"\"Models the password OAuth2 flow. Exchanges username and password for an access token. Will raise detailed\n        errors if login fails due to requiredActions\n\n        Args:\n            username (str): Username used for login\n            password (str): Password of the user\n\n        Returns:\n            KeycloakToken: If the exchange succeeds\n\n        Raises:\n            HTTPException: If the credentials did not match any user\n            MandatoryActionException: If the login is not possible due to mandatory actions\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299, != 400, != 401)\n            UpdateUserLocaleException: If the credentials we're correct but the has requiredActions of which the first\n            one is to update his locale\n            ConfigureTOTPException: If the credentials we're correct but the has requiredActions of which the first one\n            is to configure TOTP\n            VerifyEmailException: If the credentials we're correct but the has requiredActions of which the first one\n            is to verify his email\n            UpdatePasswordException: If the credentials we're correct but the has requiredActions of which the first one\n            is to update his password\n            UpdateProfileException: If the credentials we're correct but the has requiredActions of which the first one\n            is to update his profile\n\n        Notes:\n            - To avoid calling this multiple times, you may want to check all requiredActions of the user if it fails\n            due to a (sub)instance of an MandatoryActionException\n        \"\"\"\n        headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        data = {\n            \"client_id\": self.client_id,\n            \"client_secret\": self.client_secret,\n            \"username\": username,\n            \"password\": password,\n            \"grant_type\": \"password\",\n            \"scope\": self.scope,\n        }\n        response = requests.post(url=self.token_uri, headers=headers, data=data, timeout=self.timeout)\n        if response.status_code == 401:\n            raise HTTPException(status_code=401, detail=\"Invalid user credentials\")\n        if response.status_code == 400:\n            user: KeycloakUser = self.get_user(query=f\"username={username}\")\n            if len(user.requiredActions) > 0:\n                reason = user.requiredActions[0]\n                exception = {\n                    \"update_user_locale\": UpdateUserLocaleException(),\n                    \"CONFIGURE_TOTP\": ConfigureTOTPException(),\n                    \"VERIFY_EMAIL\": VerifyEmailException(),\n                    \"UPDATE_PASSWORD\": UpdatePasswordException(),\n                    \"UPDATE_PROFILE\": UpdateProfileException(),\n                }.get(\n                    reason,  # Try to return the matching exception\n                    # On custom or unknown actions return a MandatoryActionException by default\n                    MandatoryActionException(\n                        detail=f\"This user can't login until the following action has been \"\n                               f\"resolved: {reason}\"\n                    ),\n                )\n                raise exception\n        return response\n\n    @result_or_error(response_model=KeycloakToken)\n    def exchange_authorization_code(\n            self, session_state: str, code: str\n    ) -> KeycloakToken:\n        \"\"\"Models the authorization code OAuth2 flow. Opening the URL provided by `login_uri` will result in a\n        callback to the configured callback URL. The callback will also create a session_state and code query\n        parameter that can be exchanged for an access token.\n\n        Args:\n            session_state (str): Salt to reduce the risk of successful attacks\n            code (str): The authorization code\n\n        Returns:\n            KeycloakToken: If the exchange succeeds\n\n        Raises:\n            KeycloakError: If the resulting response is not a successful HTTP-Code (>299)\n        \"\"\"\n        headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        data = {\n            \"client_id\": self.client_id,\n            \"client_secret\": self.client_secret,\n            \"code\": code,\n            \"session_state\": session_state,\n            \"grant_type\": \"authorization_code\",\n            \"redirect_uri\": self.callback_uri,\n        }\n        return requests.post(url=self.token_uri, headers=headers, data=data, timeout=self.timeout)\n\n    def _admin_request(\n            self,\n            url: str,\n            method: HTTPMethod,\n            data: dict = None,\n            content_type: str = \"application/json\",\n    ) -> Response:\n        \"\"\"Private method that is the basis for any requests requiring admin access to the api. Will append the\n        necessary `Authorization` header\n\n        Args:\n            url (str): The URL to be called\n            method (HTTPMethod): The HTTP verb to be used\n            data (dict): The payload of the request\n            content_type (str): The content type of the request\n\n        Returns:\n            Response: Response of Keycloak\n        \"\"\"\n        headers = {\n            \"Content-Type\": content_type,\n            \"Authorization\": f\"Bearer {self.admin_token}\",\n        }\n        return requests.request(\n            method=method.name, url=url, data=json.dumps(data), headers=headers, timeout=self.timeout,\n        )\n\n    @functools.cached_property\n    def login_uri(self):\n        \"\"\"The URL for users to login on the realm. Also adds the client id, the callback and the scope.\"\"\"\n        params = {\n            \"scope\": self.scope,\n            \"response_type\": \"code\",\n            \"client_id\": self.client_id,\n            \"redirect_uri\": self.callback_uri,\n        }\n        return f\"{self.authorization_uri}?{urlencode(params)}\"\n\n    @functools.cached_property\n    def authorization_uri(self):\n        \"\"\"The authorization endpoint URL\"\"\"\n        return self.open_id_configuration.get(\"authorization_endpoint\")\n\n    @functools.cached_property\n    def token_uri(self):\n        \"\"\"The token endpoint URL\"\"\"\n        return self.open_id_configuration.get(\"token_endpoint\")\n\n    @functools.cached_property\n    def logout_uri(self):\n        \"\"\"The logout endpoint URL\"\"\"\n        return self.open_id_configuration.get(\"end_session_endpoint\")\n\n    @functools.cached_property\n    def realm_uri(self):\n        \"\"\"The realm's endpoint URL\"\"\"\n        return f\"{self.server_url}/realms/{self.realm}\"\n\n    @functools.cached_property\n    def users_uri(self):\n        \"\"\"The users endpoint URL\"\"\"\n        return self.admin_uri(resource=\"users\")\n\n    @functools.cached_property\n    def roles_uri(self):\n        \"\"\"The roles endpoint URL\"\"\"\n        return self.admin_uri(resource=\"roles\")\n\n    @functools.cached_property\n    def groups_uri(self):\n        \"\"\"The groups endpoint URL\"\"\"\n        return self.admin_uri(resource=\"groups\")\n\n    @functools.cached_property\n    def _admin_uri(self):\n        \"\"\"The base endpoint for any admin related action\"\"\"\n        return f\"{self.server_url}/admin/realms/{self.realm}\"\n\n    @functools.cached_property\n    def _open_id(self):\n        \"\"\"The base endpoint for any opendid connect config info\"\"\"\n        return f\"{self.realm_uri}/protocol/openid-connect\"\n\n    @functools.cached_property\n    def providers_uri(self):\n        \"\"\"The endpoint that returns all configured identity providers\"\"\"\n        return self.admin_uri(resource=\"identity-provider/instances\")\n\n    def admin_uri(self, resource: str):\n        \"\"\"Returns a admin resource URL\"\"\"\n        return f\"{self._admin_uri}/{resource}\"\n\n    def open_id(self, resource: str):\n        \"\"\"Returns a openip connect resource URL\"\"\"\n        return f\"{self._open_id}/{resource}\"\n\n    def token_is_valid(self, token: str, audience: str = None) -> bool:\n        \"\"\"Validates an access token, optionally also its audience\n\n        Args:\n            token (str): The token to be verified\n            audience (str): Optional audience. Will be checked if provided\n\n        Returns:\n            bool: True if the token is valid\n        \"\"\"\n        try:\n            self._decode_token(token=token, audience=audience)\n            return True\n        except (ExpiredSignatureError, JWTError, JWTClaimsError):\n            return False\n\n    def _decode_token(\n            self, token: str, options: dict = None, audience: str = None\n    ) -> dict:\n        \"\"\"Decodes a token, verifies the signature by using Keycloaks public key. Optionally verifying the audience\n\n        Args:\n            token (str):\n            options (dict):\n            audience (str): Name of the audience, must match the audience given in the token\n\n        Returns:\n            dict: Decoded JWT\n\n        Raises:\n            ExpiredSignatureError: If the token is expired (exp > datetime.now())\n            JWTError: If decoding fails or the signature is invalid\n            JWTClaimsError: If any claim is invalid\n        \"\"\"\n        if options is None:\n            options = {\n                \"verify_signature\": True,\n                \"verify_aud\": audience is not None,\n                \"verify_exp\": True,\n            }\n        return jwt.decode(\n            token=token, key=self.public_key, options=options, audience=audience\n        )\n\n    def __str__(self):\n        \"\"\"String representation\"\"\"\n        return \"FastAPI Keycloak Integration\"\n\n    def __repr__(self):\n        \"\"\"Debug representation\"\"\"\n        return f\"{self.__str__()} <class {self.__class__} >\"\n"}
{"type": "source_file", "path": "fastapi_keycloak/model.py", "content": "from enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, SecretStr, Field\n\nfrom fastapi_keycloak.exceptions import KeycloakError\n\n\nclass HTTPMethod(Enum):\n    \"\"\"Represents the basic HTTP verbs\n\n    Values:\n        - GET: get\n        - POST: post\n        - DELETE: delete\n        - PUT: put\n    \"\"\"\n\n    GET = \"get\"\n    POST = \"post\"\n    DELETE = \"delete\"\n    PUT = \"put\"\n\n\nclass KeycloakUser(BaseModel):\n    \"\"\"Represents a user object of Keycloak.\n\n    Attributes:\n        id (str):\n        createdTimestamp (int):\n        username (str):\n        enabled (bool):\n        totp (bool):\n        emailVerified (bool):\n        firstName (Optional[str]):\n        lastName (Optional[str]):\n        email (Optional[str]):\n        disableableCredentialTypes (List[str]):\n        requiredActions (List[str]):\n        realmRoles (List[str]):\n        notBefore (int):\n        access (dict):\n        attributes (Optional[dict]):\n\n    Notes: Check the Keycloak documentation at https://www.keycloak.org/docs-api/15.0/rest-api/index.html for\n    details. This is a mere proxy object.\n    \"\"\"\n\n    id: str\n    createdTimestamp: int\n    username: str\n    enabled: bool\n    totp: bool\n    emailVerified: bool\n    firstName: Optional[str] = None\n    lastName: Optional[str] = None\n    email: Optional[str] = None\n    disableableCredentialTypes: List[str]\n    requiredActions: List[str]\n    realmRoles: Optional[List[str]] = None\n    notBefore: int\n    access: Optional[dict] = None\n    attributes: Optional[dict] = None\n\n\nclass UsernamePassword(BaseModel):\n    \"\"\"Represents a request body that contains username and password\n\n    Attributes:\n        username (str): Username\n        password (str): Password, masked by swagger\n    \"\"\"\n\n    username: str\n    password: SecretStr\n\n\nclass OIDCUser(BaseModel):\n    \"\"\"Represents a user object of Keycloak, parsed from access token\n\n    Attributes:\n        sub (str):\n        iat (int):\n        exp (int):\n        scope (str):\n        email_verified (bool):\n        name (Optional[str]):\n        given_name (Optional[str]):\n        family_name (Optional[str]):\n        email (Optional[str]):\n        preferred_username (Optional[str]):\n        realm_access (dict):\n        resource_access (dict):\n        extra_fields (dict):\n\n    Notes: Check the Keycloak documentation at https://www.keycloak.org/docs-api/15.0/rest-api/index.html for\n    details. This is a mere proxy object.\n    \"\"\"\n\n    azp: Optional[str] = None\n    sub: str\n    iat: int\n    exp: int\n    scope: Optional[str] = None\n    email_verified: bool\n    name: Optional[str] = None\n    given_name: Optional[str] = None\n    family_name: Optional[str] = None\n    email: Optional[str] = None\n    preferred_username: Optional[str] = None\n    realm_access: Optional[dict] = None\n    resource_access: Optional[dict] = None\n    extra_fields: dict = Field(default_factory=dict)\n\n    @property\n    def roles(self) -> List[str]:\n        \"\"\"Returns the roles of the user\n\n        Returns:\n            List[str]: If the realm access dict contains roles\n        \"\"\"\n        if not self.realm_access and not self.resource_access:\n            raise KeycloakError(\n                status_code=404,\n                reason=\"The 'realm_access' and 'resource_access' sections of the provided access token are missing.\",\n            )\n        roles = []\n        if self.realm_access:\n            if \"roles\" in self.realm_access:\n                roles += self.realm_access[\"roles\"]\n        if self.azp and self.resource_access:\n            if self.azp in self.resource_access:\n                if \"roles\" in self.resource_access[self.azp]:\n                    roles += self.resource_access[self.azp][\"roles\"]\n        if not roles:\n            raise KeycloakError(\n                status_code=404,\n                reason=\"The 'realm_access' and 'resource_access' sections of the provided access token did not \"\n                       \"contain any 'roles'\",\n            )\n        return roles\n\n    def __str__(self) -> str:\n        \"\"\"String representation of an OIDCUser\"\"\"\n        return self.preferred_username\n\n\nclass KeycloakIdentityProvider(BaseModel):\n    \"\"\"Keycloak representation of an identity provider\n\n    Attributes:\n        alias (str):\n        internalId (str):\n        providerId (str):\n        enabled (bool):\n        updateProfileFirstLoginMode (str):\n        trustEmail (bool):\n        storeToken (bool):\n        addReadTokenRoleOnCreate (bool):\n        authenticateByDefault (bool):\n        linkOnly (bool):\n        firstBrokerLoginFlowAlias (str):\n        config (dict):\n\n    Notes: Check the Keycloak documentation at https://www.keycloak.org/docs-api/15.0/rest-api/index.html for\n    details. This is a mere proxy object.\n    \"\"\"\n\n    alias: str\n    internalId: str\n    providerId: str\n    enabled: bool\n    updateProfileFirstLoginMode: str\n    trustEmail: bool\n    storeToken: bool\n    addReadTokenRoleOnCreate: bool\n    authenticateByDefault: bool\n    linkOnly: bool\n    firstBrokerLoginFlowAlias: str\n    config: dict\n\n\nclass KeycloakRole(BaseModel):\n    \"\"\"Keycloak representation of a role\n\n    Attributes:\n        id (str):\n        name (str):\n        composite (bool):\n        clientRole (bool):\n        containerId (str):\n\n    Notes: Check the Keycloak documentation at https://www.keycloak.org/docs-api/15.0/rest-api/index.html for\n    details. This is a mere proxy object.\n    \"\"\"\n\n    id: str\n    name: str\n    composite: bool\n    clientRole: bool\n    containerId: str\n\n\nclass KeycloakToken(BaseModel):\n    \"\"\"Keycloak representation of a token object\n\n    Attributes:\n        access_token (str): An access token\n        refresh_token (str): An a refresh token, default None\n        id_token (str): An issued by the Authorization Server token id, default None\n    \"\"\"\n\n    access_token: str\n    refresh_token: Optional[str] = None\n    id_token: Optional[str] = None\n\n    def __str__(self):\n        \"\"\"String representation of KeycloakToken\"\"\"\n        return f\"Bearer {self.access_token}\"\n\n\nclass KeycloakGroup(BaseModel):\n    \"\"\"Keycloak representation of a group\n\n    Attributes:\n        id (str):\n        name (str):\n        path (Optional[str]):\n        realmRoles (Optional[str]):\n    \"\"\"\n\n    id: str\n    name: str\n    path: Optional[str] = None\n    realmRoles: Optional[List[str]] = None\n    subGroups: Optional[List[\"KeycloakGroup\"]] = None\n\n\nKeycloakGroup.update_forward_refs()\n"}
{"type": "source_file", "path": "fastapi_keycloak/exceptions.py", "content": "from fastapi import HTTPException\n\n\nclass KeycloakError(Exception):\n    \"\"\"Thrown if any response of keycloak does not match our expectation\n\n    Attributes:\n        status_code (int): The status code of the response received\n        reason (str): The reason why the requests did fail\n    \"\"\"\n\n    def __init__(self, status_code: int, reason: str):\n        self.status_code = status_code\n        self.reason = reason\n        super().__init__(f\"HTTP {status_code}: {reason}\")\n\nclass UserNotFound(Exception):\n    \"\"\"Thrown when a user lookup fails.\n\n    Attributes:\n        status_code (int): The status code of the response received\n        reason (str): The reason why the requests did fail\n    \"\"\"\n    def __init__(self, status_code: int, reason: str):\n        self.status_code = status_code\n        self.reason = reason\n        super().__init__(f\"HTTP {status_code}: {reason}\")\n\nclass MandatoryActionException(HTTPException):\n    \"\"\"Throw if the exchange of username and password for an access token fails\"\"\"\n\n    def __init__(self, detail: str) -> None:\n        super().__init__(status_code=400, detail=detail)\n\n\nclass UpdateUserLocaleException(MandatoryActionException):\n    \"\"\"Throw if the exchange of username and password for an access token fails due to the update_user_locale\n    requiredAction\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(detail=\"This user can't login until he updated his locale\")\n\n\nclass ConfigureTOTPException(MandatoryActionException):\n    \"\"\"Throw if the exchange of username and password for an access token fails due to the CONFIGURE_TOTP\n    requiredAction\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(detail=\"This user can't login until he configured TOTP\")\n\n\nclass VerifyEmailException(MandatoryActionException):\n    \"\"\"Throw if the exchange of username and password for an access token fails due to the VERIFY_EMAIL\n    requiredAction\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(detail=\"This user can't login until he verified his email\")\n\n\nclass UpdatePasswordException(MandatoryActionException):\n    \"\"\"Throw if the exchange of username and password for an access token fails due to the UPDATE_PASSWORD\n    requiredAction\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(detail=\"This user can't login until he updated his password\")\n\n\nclass UpdateProfileException(MandatoryActionException):\n    \"\"\"Throw if the exchange of username and password for an access token fails due to the UPDATE_PROFILE\n    requiredAction\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(detail=\"This user can't login until he updated his profile\")\n"}
{"type": "source_file", "path": "setup.py", "content": "#!/usr/bin/env python\n\n# This has only been added to allow editable dev installs, pyproject.toml replaces setup.py\n# e.g. pip install -e .\n\nimport setuptools\n\nif __name__ == \"__main__\":\n    setuptools.setup()\n"}

{"repo_info": {"repo_name": "ttobot", "repo_owner": "Daco2020", "repo_url": "https://github.com/Daco2020/ttobot"}}
{"type": "test_file", "path": "test/test_point.py", "content": "import datetime\n\nimport pytest\n\nfrom pytest_mock import MockerFixture\nfrom app.models import Content, User\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.point import PointService\n\n\n@pytest.mark.parametrize(\n    \"user, point_name, point\",\n    [\n        (\n            User(\n                user_id=\"유저아이디\",\n                name=\"제출 내역이 없는 영콤보\",\n                channel_name=\"채널이름\",\n                channel_id=\"채널아이디\",\n                intro=\"업데이트 예정입니다.\",\n                contents=[],\n                cohort=\"10기\",\n                deposit=\"100000\",\n            ),\n            None,\n            None,\n        ),\n        (\n            User(\n                user_id=\"유저아이디\",\n                name=\"전전 회차에 미제출한 일콤보\",\n                channel_name=\"채널이름\",\n                channel_id=\"채널아이디\",\n                intro=\"업데이트 예정입니다.\",\n                contents=[\n                    Content(\n                        dt=\"2024-11-24 15:00:00\",\n                        user_id=\"유저아이디\",\n                        username=\"유저이름\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"직전 회차 제출 글\",\n                        category=\"일상 & 생각\",\n                        tags=\"태그1,태그2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-10-27 15:00:00\",\n                        user_id=\"유저아이디\",\n                        username=\"유저이름\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"전전전 회차 제출 글\",\n                        category=\"일상 & 생각\",\n                        tags=\"태그1,태그2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                ],\n                cohort=\"10기\",\n                deposit=\"100000\",\n            ),\n            \"글 제출 콤보\",\n            \"10\",\n        ),\n        (\n            User(\n                user_id=\"유저아이디\",\n                name=\"이콤보\",\n                channel_name=\"채널이름\",\n                channel_id=\"채널아이디\",\n                intro=\"업데이트 예정입니다.\",\n                contents=[\n                    Content(\n                        dt=\"2024-11-24 15:00:00\",\n                        user_id=\"유저아이디\",\n                        username=\"유저이름\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"직전 회차 제출 글\",\n                        category=\"일상 & 생각\",\n                        tags=\"태그1,태그2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-11-10 15:00:00\",\n                        user_id=\"유저아이디\",\n                        username=\"유저아이디\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"직전 회차 제출 글\",\n                        category=\"일상 & 생각\",\n                        tags=\"태그1,태그2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                ],\n                cohort=\"10기\",\n                deposit=\"100000\",\n            ),\n            \"글 제출 콤보\",\n            \"20\",\n        ),\n        (\n            User(\n                user_id=\"유저아이디\",\n                name=\"중간에 패스가 있는 삼콤보\",\n                channel_name=\"채널이름\",\n                channel_id=\"채널아이디\",\n                intro=\"업데이트 예정입니다.\",\n                contents=[\n                    Content(\n                        dt=\"2024-11-24 15:00:00\",\n                        user_id=\"유저아이디\",\n                        username=\"유저이름\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"직전 회차 제출 글\",\n                        category=\"일상 & 생각\",\n                        tags=\"태그1,태그2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-11-10 15:00:00\",\n                        user_id=\"유저아이디\",\n                        username=\"유저아이디\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"전전 회차 제출 글\",\n                        category=\"일상 & 생각\",\n                        tags=\"태그1,태그2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-10-27 15:00:00\",\n                        user_id=\"유저아이디\",\n                        username=\"유저아이디\",\n                        type=\"pass\",\n                        content_url=\"\",\n                        title=\"전전전 회차 패스 글\",\n                        category=\"\",\n                        tags=\"\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-10-13 15:00:00\",\n                        user_id=\"유저아이디\",\n                        username=\"유저아이디\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"전전전전 회차 제출 글\",\n                        category=\"일상 & 생각\",\n                        tags=\"태그1,태그2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                ],\n                cohort=\"10기\",\n                deposit=\"100000\",\n            ),\n            \"글 제출 3콤보 보너스\",\n            \"300\",\n        ),\n    ],\n)\ndef test_grant_if_post_submitted_continuously(\n    user: User,\n    point_name: str | None,\n    point: str | None,\n    point_service: PointService,\n    mocker: MockerFixture,\n) -> None:\n    \"\"\"\n    연속으로 글을 제출한다면 연속 콤보에 따른 보너스 포인트를 지급합니다.\n    현재 회차 제출에 대한 연속 콤보 포인트는 지급입니다. (현재 회차는 제출 건은 반영되지 않습니다.)\n\n\n    - 1콤보(2회 연속 제출) 라면 콤보 포인트는 10점 입니다.\n        - 중간에 미제출 했다면 콤보는 다시 시작합니다.\n    - 2콤보(3회 연속 제출) 라면 콤보 포인트는 20점 입니다.\n    - 3콤보(4회 연속 제출) 라면 콤보 포인트는 300점 입니다.\n        - 중간에 패스를 한 경우 콤보는 연장됩니다.\n    \"\"\"\n    # given\n    mocker.patch(\n        \"app.models.DUE_DATES\",\n        [\n            datetime.datetime(2024, 9, 29).date(),  # 0회차 (시작일)\n            datetime.datetime(2024, 10, 13).date(),  # 1회차\n            datetime.datetime(2024, 10, 27).date(),  # 2회차\n            datetime.datetime(2024, 11, 10).date(),  # 3회차\n            datetime.datetime(2024, 11, 24).date(),  # 4회차\n            datetime.datetime(2024, 12, 8).date(),  # 5회차 (현재 회차)\n        ],\n    )\n    mocker.patch(\n        \"app.models.tz_now\",\n        return_value=datetime.datetime(2024, 11, 25, 15, 0, 0),\n    )\n    mocker.patch.object(\n        SlackRepository,\n        \"get_user\",\n        return_value=user,\n    )\n\n    # when\n    result = point_service.grant_if_post_submitted_continuously(user_id=user.user_id)\n\n    # then\n    if point_name is None:  # 제출 내역이 없는 경우\n        assert result is None\n\n    else:\n        expected_message = f\"<@{user.user_id}>님 `{point_name}`(으)로 `{point}`포인트를 획득했어요! 🎉\\n총 포인트와 내역은 또봇 [홈] 탭에서 확인할 수 있어요.\"\n        assert result == expected_message\n"}
{"type": "test_file", "path": "test/test_reminder.py", "content": "from datetime import timedelta\nfrom typing import cast\n\nfrom slack_bolt.async_app import AsyncApp\n\nimport pytest\nfrom pytest_mock import MockerFixture\nfrom app.models import Content, User\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.background import BackgroundService\nfrom app.utils import tz_now\nfrom test.conftest import FakeSlackApp\n\n\n@pytest.mark.asyncio\nasync def test_send_reminder_message_to_user(\n    background_service: BackgroundService,\n    slack_app: FakeSlackApp,\n    mocker: MockerFixture,\n) -> None:\n    \"\"\"\n    리마인드 대상 유저에게 메시지를 전송하는지 확인합니다.\n    - 현재 회차를 제출하지 않은 인원에게 리마인드 메시지를 전송해야 합니다.\n    - 현재 기수에 해당하는 인원에게 리마인드 메시지를 전송해야 합니다.\n    \"\"\"\n    # given\n    mocker.patch(\n        \"app.models.DUE_DATES\",\n        [\n            tz_now().date() - timedelta(days=14),  # 직전 회차 마감일\n            tz_now().date(),  # 현재 회차 마감일\n        ],\n    )\n    mocker.patch.object(\n        SlackRepository,\n        \"fetch_users\",\n        return_value=[\n            User(\n                user_id=\"리마인드 비대상1\",\n                name=\"슬랙봇\",\n                channel_name=\"-\",  # bot\n                channel_id=\"test_channel_id\",\n                intro=\"-\",\n                contents=[],\n                cohort=\"9기\",\n            ),\n            User(\n                user_id=\"리마인드 비대상2\",\n                name=\"장득현\",\n                channel_name=\"test_channel\",\n                channel_id=\"test_channel_id\",\n                intro=\"\",\n                contents=[],\n                cohort=\"8기\",  # 지난 기수 참여자\n            ),\n            User(\n                user_id=\"리마인드 비대상3\",\n                name=\"김은찬\",\n                channel_name=\"test_channel\",\n                channel_id=\"test_channel_id\",\n                intro=\"안녕하세요. 김은찬입니다.\",\n                contents=[\n                    Content(  # 이미 제출한 경우\n                        dt=(tz_now() - timedelta(days=1)).strftime(\"%Y-%m-%d %H:%M:%S\"),\n                        user_id=\"리마인드 비대상3\",\n                        username=\"김은찬\",\n                        type=\"submit\",\n                    ),\n                ],\n                cohort=\"10기\",\n            ),\n            User(\n                user_id=\"리마인드 대상1\",\n                name=\"변덕순\",\n                channel_name=\"test_channel\",\n                channel_id=\"test_channel_id\",\n                intro=\"안녕하세요. 덕순입니다.\",\n                contents=[],  # 제출하지 않은 경우\n                cohort=\"10기\",\n            ),\n            User(\n                user_id=\"리마인드 대상2\",\n                name=\"장득현\",\n                channel_name=\"test_channel\",\n                channel_id=\"test_channel_id\",\n                intro=\"안녕하세요. 장득현입니다.\",\n                contents=[\n                    Content(  # 지난 회차 제출한 경우\n                        dt=(tz_now() - timedelta(days=15)).strftime(\n                            \"%Y-%m-%d %H:%M:%S\"\n                        ),\n                        user_id=\"리마인드 대상2\",\n                        username=\"장득현\",\n                        type=\"submit\",\n                    ),\n                ],\n                cohort=\"10기\",\n            ),\n        ],\n    )\n    slack_client_mock = mocker.patch.object(slack_app.client, \"chat_postMessage\")\n\n    # when\n    await background_service.send_reminder_message_to_user(cast(AsyncApp, slack_app))\n\n    # then\n    assert slack_client_mock.call_count == 3\n    assert slack_client_mock.call_args_list[0].kwargs[\"channel\"] == \"리마인드 대상1\"\n    assert (\n        slack_client_mock.call_args_list[0].kwargs[\"text\"]\n        == \"👋 안녕하세요! 오늘은 글 제출 마감일이에요.\\n지난 2주 동안 배우고 경험한 것들을 자정까지 나눠주세요.\\n변덕순 님의 이야기를 기다릴게요!🙂\"\n    )\n    assert slack_client_mock.call_args_list[1].kwargs[\"channel\"] == \"리마인드 대상2\"\n    assert (\n        slack_client_mock.call_args_list[1].kwargs[\"text\"]\n        == \"👋 안녕하세요! 오늘은 글 제출 마감일이에요.\\n지난 2주 동안 배우고 경험한 것들을 자정까지 나눠주세요.\\n장득현 님의 이야기를 기다릴게요!🙂\"\n    )\n    assert (\n        slack_client_mock.call_args_list[2].kwargs[\"text\"]\n        == \"총 2 명에게 리마인드 메시지를 전송했습니다.\"\n    )\n"}
{"type": "source_file", "path": "app/api/deps.py", "content": "from fastapi import Depends\nfrom app.api.repositories import ApiRepository\nfrom app.api.services import ApiService\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.point import PointService\n\n\ndef api_repo() -> ApiRepository:\n    return ApiRepository()\n\n\ndef api_service(api_repo: ApiRepository = Depends(api_repo)) -> ApiService:\n    return ApiService(api_repo=api_repo)\n\n\ndef point_service() -> PointService:\n    return PointService(SlackRepository())\n"}
{"type": "source_file", "path": "app/api/auth.py", "content": "from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\nimport jwt\nfrom app import models\nfrom app.config import settings\n\n\nfrom fastapi import Depends, HTTPException, Response\n\n\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any\nfrom app.api.deps import api_repo\nfrom app.api.repositories import ApiRepository\n\nfrom app.utils import tz_now\n\n\ndef login(response: Response, payload: dict[str, Any]):\n    token = encode_token(payload=payload, expires_delta=timedelta(days=1))\n    set_cookie(response=response, key=\"access_token\", value=token)\n\n\ndef set_cookie(\n    response: Response,\n    key: str,\n    value: str,\n) -> None:\n    \"\"\"응답에 쿠키를 설정합니다.\"\"\"\n    response.set_cookie(\n        key=key,\n        value=value,\n        max_age=60 * 60 * 24,\n        expires=datetime.now(timezone.utc) + timedelta(days=1),\n        domain=settings.SERVER_DOMAIN,\n        path=\"/\",\n        httponly=True,\n        secure=True,\n    )\n\n\ndef encode_token(\n    payload: dict[str, Any],\n    expires_delta: timedelta,\n    algorithm: str = \"HS256\",\n) -> str:\n    \"\"\"토큰을 생성합니다.\"\"\"\n    payload[\"iss\"] = \"ttobot\"\n    payload[\"iat\"] = iat = tz_now()\n    payload[\"exp\"] = iat + expires_delta\n    return jwt.encode(\n        payload,\n        settings.SECRET_KEY,\n        algorithm=algorithm,\n    )\n\n\ndef decode_token(\n    token: str,\n    algorithm: str = \"HS256\",\n) -> dict[str, Any]:\n    \"\"\"토큰을 디코딩합니다.\"\"\"\n    options = {\"verify_exp\": True, \"verify_iss\": True}\n    return jwt.decode(\n        token,\n        settings.SECRET_KEY,\n        issuer=\"ttobot\",\n        algorithms=[algorithm],\n        options=options,\n    )\n\n\nsecurity = HTTPBearer(auto_error=False)\n\n\nasync def current_user(\n    credentials: HTTPAuthorizationCredentials | None = Depends(security),\n    api_repo: ApiRepository = Depends(api_repo),\n) -> models.SimpleUser:\n    \"\"\"현재 유저를 조회합니다.\"\"\"\n    token = credentials and credentials.credentials\n    if not token:\n        raise HTTPException(status_code=403, detail=\"토큰이 존재하지 않습니다.\")\n\n    try:\n        decoded_payload = decode_token(token)\n    except Exception:\n        raise HTTPException(\n            status_code=403, detail=f\"토큰이 유효하지 않습니다. token: {token}\"\n        )\n\n    if decoded_payload.get(\"type\") == \"refresh\":\n        raise HTTPException(\n            status_code=403, detail=f\"토큰이 유효하지 않습니다. token: {token}\"\n        )\n\n    user_id = decoded_payload.get(\"user_id\", \"\")\n    user = api_repo.get_user(user_id) if user_id else None\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=f\"유저가 존재하지 않습니다. user_id: {user_id}\",\n        )\n\n    return models.SimpleUser.model_validate(user.model_dump())\n"}
{"type": "source_file", "path": "app/api/views/__init__.py", "content": ""}
{"type": "source_file", "path": "app/bigquery/client.py", "content": "from enum import StrEnum\nimport orjson\nfrom typing import Any\n\nfrom google.cloud import bigquery\nfrom google.oauth2 import service_account\nfrom app.config import settings\n\nimport pandas as pd\nfrom pandas_gbq import to_gbq\n\ncredentials = service_account.Credentials.from_service_account_info(\n    info=settings.BIGQUERY_CREDENTIALS\n)\n\n\nclass TableNameEnum(StrEnum):\n    COMMENTS_LOG = \"comments_log\"\n    POSTS_LOG = \"posts_log\"\n    EMOJIS_LOG = \"emojis_log\"\n\n\nclass BigqueryClient:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self) -> None:\n        if not hasattr(self, \"_initialized\"):\n            self.credentials = credentials\n            self.project_id = self.credentials.project_id\n            self.database_id = settings.BIGQUERY_DATABASE_ID\n            self.client = bigquery.Client(\n                credentials=credentials, project=self.project_id\n            )\n            self.schemas = {\n                TableNameEnum.COMMENTS_LOG: self._read_schema(\n                    \"app/bigquery/schemas/comments_log.json\"\n                ),\n                TableNameEnum.POSTS_LOG: self._read_schema(\n                    \"app/bigquery/schemas/posts_log.json\"\n                ),\n                TableNameEnum.EMOJIS_LOG: self._read_schema(\n                    \"app/bigquery/schemas/emojis_log.json\"\n                ),\n            }\n            self._initialized = True\n\n    def create_table(\n        self,\n        table_name: TableNameEnum,\n        partition: bool = False,\n        partition_key: str | None = None,\n    ) -> None:\n        \"\"\"\n        파이썬에서 빅쿼리 테이블을 생성합니다.\n\n        Parameters\n        ----------\n        table_name : str\n            테이블 이름\n        partition : bool, optional\n            파티션 키를 만들것인지 체크, by default False\n        partition_key : str, optional\n            파티션 키를 만든다면 어떤 컬럼을 사용할 것인지 명시, by default None\n        \"\"\"\n        table_path = f\"{self.project_id}.{self.database_id}.{table_name}\"\n        table = bigquery.Table(table_path, schema=self.schemas[table_name])\n\n        if partition is True:\n            partitioning = bigquery.TimePartitioning(\n                type_=bigquery.TimePartitioningType.DAY,\n                field=partition_key,  # 분할하려는 필드\n            )\n            table.time_partitioning = partitioning\n\n        self.client.create_table(table)\n        print(f\"{table_path}가 정상적으로 생성 됐습니다.\")\n\n    def run_query_to_dataframe(self, query: str) -> pd.DataFrame:\n        \"\"\"\n        빅쿼리에 직접 쿼리를 날립니다\n\n        Parameters\n        ----------\n\n        \"\"\"\n        return self.client.query(query=query).result().to_dataframe()\n\n    def read_table(\n        self,\n        table_name: TableNameEnum,\n        where_clause: str | None = None,\n    ) -> pd.DataFrame:\n        \"\"\"\n        빅쿼리 테이블을 판다스로 읽어옵니다.\n\n        Parameters\n        ----------\n        table_name : str\n            테이블명\n        where_clause : str\n            조건절을 입력합니다. 만약 파티션 키가 있는데 조건절을 입력하지 않으면 에러가 발생합니다, by default None\n        \"\"\"\n        table_path = f\"{self.project_id}.{self.database_id}.{table_name}\"\n        table = self.client.get_table(table_path)\n\n        if not table.time_partitioning:\n            qr = f\"\"\"\n            SELECT *\n            FROM `{table_path}`\n            \"\"\"\n        else:\n            if not where_clause:\n                raise ValueError(\"where_clause 파티션 조건절을 추가하세요\")\n            qr = f\"\"\"\n                SELECT *\n                FROM `{table_path}`\n                WHERE {where_clause}\n                \"\"\"\n\n        return self.client.query(qr).to_dataframe()\n\n    def update_table(\n        self,\n        df: pd.DataFrame,\n        table_name: TableNameEnum,\n        if_exists: str,\n    ) -> None:\n        \"\"\"\n        파이썬에서 빅쿼리 테이블을 업데이트 합니다.\n\n        Parameters\n        ----------\n        df : pd.DataFrame\n            판다스 데이터프레임\n        table_name : str\n            테이블명\n        if_exists : str\n            테이블이 만약에 존재한다면 어떤 조건을 사용할 것인지 3가지 사용가능 - fail, replace, append\n        \"\"\"\n        table_path = f\"{self.project_id}.{self.database_id}.{table_name}\"\n        to_gbq(\n            dataframe=df,\n            destination_table=table_path,\n            credentials=self.credentials,\n            if_exists=if_exists,\n            table_schema=self.schemas[table_name],\n        )\n        print(f\"{table_path}가 정상적으로 적재 됐습니다.\")\n\n    def delete_table(\n        self,\n        table_name: TableNameEnum,\n        where_clause: str,\n    ) -> None:\n        \"\"\"\n        파이썬에서 빅쿼리 내에서 특정 조건에 해당하는 데이터를 삭재합니다.\n        데이터 업데이트 시 중복 적재를 방지하는 용도로 사용합니다.\n\n        Parameters\n        ----------\n        table_name : str\n            테이블명\n        where_clause : str\n            삭제 조건을 입력합니다.\n        \"\"\"\n        table_path = f\"{self.project_id}.{self.database_id}.{table_name}\"\n        qr = f\"\"\"\n        DELETE FROM `{table_path}`\n        {where_clause}\n        \"\"\"\n        query_job = self.client.query(qr)\n        query_job.result()\n\n        print(f\"{table_path}의 {where_clause}가 정상적으로 삭제 됐습니다.\")\n\n    def upsert_table(\n        self,\n        *,\n        target_table: str,\n        source_table: str,\n    ) -> None:\n        \"\"\"\n        아래와 같이 값이 존재하는 경우 update, 값이 없는 경우 insert하는 로직을 진행\n        MERGE merge_example.table_data T\n        USING merge_example.table_changes S\n        ON T.id = S.id\n        WHEN MATCHED THEN\n        UPDATE SET value = s.value\n        WHEN NOT MATCHED THEN\n        INSERT (id, value) VALUES(id, value)\n\n        Parameters\n        ----------\n        target_table : str\n            변경 대상 테이블명\n        source_table : str\n            소스 테이블명\n        \"\"\"\n        target_path = f\"{self.project_id}.{self.database_id}.{target_table}\"\n        source_path = f\"{self.project_id}.{self.database_id}.{source_table}\"\n\n        qr = f\"\"\"\n        MERGE {target_path} T\n        USING {source_path} S\n        ON T.post_id = S.post_id AND T.createtime = S.createtime\n        WHEN MATCHED THEN\n        UPDATE SET\n            channel_id = S.channel_id,\n            message_type = S.message_type,\n            user_id = S.user_id,\n            createtime = S.createtime,\n            tddate = S.tddate,\n            text = S.text,\n            reactions = S.reactions\n        WHEN NOT MATCHED THEN\n            INSERT (channel_id, message_type, post_id, user_id, ts, createtime, tddate, text, permalink, reactions)\n            VALUES (channel_id, message_type, post_id, user_id, ts, createtime, tddate, text, permalink, reactions)\n        \"\"\"\n\n        query_job = self.client.query(qr)\n        query_job.result()\n\n        print(f\"{target_path}의 upsert가 정상적으로 진행 됐습니다.\")\n\n    def _read_schema(self, file_path: str) -> list[dict[str, Any]]:\n        \"\"\"\n        스키마를 읽어옵니다.\n\n        Parameters\n        ----------\n        file_path : str\n            json 스키마가 저장된 주소\n\n        Returns\n        -------\n        list[dict[str, Any]]\n            스키마 파일\n        \"\"\"\n        with open(file_path, encoding=\"utf-8\") as json_file:\n            data = orjson.loads(json_file.read())\n        return data\n"}
{"type": "source_file", "path": "app/api/dto.py", "content": "from typing import Any\nfrom pydantic import BaseModel, Field\n\n\nclass ContentResponse(BaseModel):\n    count: int = Field(..., description=\"조건에 맞는 콘텐츠의 총 개수\", examples=[1])\n    data: list[dict[str, Any]] = Field(\n        ...,\n        description=\"조회된 콘텐츠의 배열\",\n        examples=[\n            [\n                {\n                    \"user_id\": \"U07NTP9MGH4\",\n                    \"title\": \"Python aiocache 로 비동기 Slack API 요청 캐싱하기\",\n                    \"content_url\": \"https://daco2020.tistory.com/854\",\n                    \"dt\": \"2024-10-03 22:31:56\",\n                    \"category\": \"기술 & 언어\",\n                    \"tags\": \"Python,Slack API,Cache,캐싱,비동기 함수,비동기 캐싱\",\n                    \"ts\": \"1727962316.649959\",\n                    \"name\": \"김은찬\",\n                    \"cohort\": \"10기\",\n                    \"job_category\": \"풀스택\",\n                    \"relevance\": 0,\n                }\n            ]\n        ],\n    )\n\n\nclass PaperPlaneResponse(BaseModel):\n    count: int = Field(\n        ..., description=\"조건에 맞는 종이비행기의 총 개수\", examples=[1]\n    )\n    data: list[dict[str, Any]] = Field(\n        ...,\n        description=\"조회된 종이비행기의 배열\",\n        examples=[\n            {\n                \"count\": 1,\n                \"data\": [\n                    {\n                        \"id\": \"BLayCX1727143294282\",\n                        \"sender_id\": \"U02HPESDZT3\",\n                        \"sender_name\": \"김은찬\",\n                        \"receiver_id\": \"U06EV0G3QUA\",\n                        \"receiver_name\": \"성연찬\",\n                        \"text\": \"테스트\",\n                        \"text_color\": \"#FFFFFF\",\n                        \"bg_color\": \"blush_rosybrown\",\n                        \"color_label\": \"#BC8F8F\",\n                        \"created_at\": \"2024-09-24 11:01:34\",\n                    }\n                ],\n            }\n        ],\n    )\n\n\nclass SendMessageDTO(BaseModel):\n    channel_id: str = Field(..., description=\"채널 ID\")\n    message: str = Field(..., description=\"메시지\")\n"}
{"type": "source_file", "path": "app/api/views/login.py", "content": "from datetime import timedelta\nfrom typing import cast\nfrom slack_bolt import BoltRequest\nfrom app import models\nfrom fastapi import APIRouter, Depends, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom app.api.auth import decode_token, encode_token\nfrom app.api.auth import current_user\nfrom app.api.deps import api_service\nfrom app.api.services import ApiService\nfrom app.config import settings\nfrom slack_bolt.oauth.oauth_settings import OAuthSettings\nfrom slack_sdk.oauth.state_store import FileOAuthStateStore\nfrom slack_bolt.oauth.oauth_flow import OAuthFlow\nfrom jwt import PyJWTError\n\nrouter = APIRouter()\n\noauth_settings = OAuthSettings(\n    client_id=settings.SLACK_CLIENT_ID,\n    client_secret=settings.SLACK_CLIENT_SECRET,\n    scopes=[\"channels:read\", \"groups:read\", \"chat:write\"],\n    state_store=FileOAuthStateStore(expiration_seconds=600, base_dir=\"./data/states\"),\n    user_scopes=[\"identity.basic\"],\n    redirect_uri=f\"https://{settings.CLIENT_DOMAIN}/slack/callback\",\n)\n\noauth_flow = OAuthFlow(settings=oauth_settings)\n\n\n@router.get(\"/slack/login\")\nasync def slack_login(request: Request):\n    state = oauth_flow.issue_new_state(request=cast(BoltRequest, request))\n    url = oauth_settings.authorize_url_generator.generate(state=state)\n    return JSONResponse(content={\"redirect_url\": url})\n\n\n@router.get(\"/slack/auth\")\nasync def slack_auth(\n    request: Request,\n    code: str | None = None,\n    state: str | None = None,\n    error: str | None = None,\n):\n    if error:\n        raise HTTPException(status_code=404, detail=f\"Slack OAuth Error: {error}\")\n\n    if not code:\n        raise HTTPException(\n            status_code=403, detail=\"Slack OAuth Error: Invalid authentication code\"\n        )\n\n    result = oauth_flow.run_installation(code=code)\n    if not result:\n        raise HTTPException(\n            status_code=403, detail=\"Slack OAuth Error: Failed to run installation\"\n        )\n\n    access_token = encode_token(\n        payload={\"user_id\": result.user_id},\n        expires_delta=timedelta(days=1),\n    )\n    refresh_token = encode_token(\n        payload={\"user_id\": result.user_id, \"type\": \"refresh\"},\n        expires_delta=timedelta(days=7),\n    )\n    return JSONResponse(\n        status_code=200,\n        content={\n            \"access_token\": access_token,\n            \"refresh_token\": refresh_token,\n        },\n    )\n\n\n@router.get(\"/slack/auth/refresh\")\nasync def slack_auth_refresh(\n    refresh_token: str,\n    service: ApiService = Depends(api_service),\n):\n    try:\n        decoded_payload = decode_token(refresh_token)\n        if decoded_payload.get(\"type\") != \"refresh\":\n            return HTTPException(status_code=403, detail=\"토큰이 유효하지 않습니다.\")\n\n        user = service.get_user_by(user_id=decoded_payload[\"user_id\"])\n        if not user:\n            return HTTPException(status_code=404, detail=\"해당하는 유저가 없습니다.\")\n\n    except PyJWTError:\n        return HTTPException(status_code=403, detail=\"토큰이 유효하지 않습니다.\")\n\n    access_token = encode_token(\n        payload={\"user_id\": user.user_id}, expires_delta=timedelta(days=1)\n    )\n    return JSONResponse(\n        status_code=200,\n        content={\n            \"access_token\": access_token,\n        },\n    )\n\n\n@router.get(\"/slack/me\")\nasync def get_me(user: models.SimpleUser = Depends(current_user)):\n    \"\"\"로그인 유저의 정보를 반환합니다.\"\"\"\n    return user\n"}
{"type": "source_file", "path": "app/slack/components/static_select.py", "content": "from typing import Any\n\n\ndef options(options: list[str]) -> list[dict[str, Any]]:\n    return [\n        {\n            \"text\": {\"type\": \"plain_text\", \"text\": value},\n            \"value\": value,\n        }\n        for value in options\n    ]\n"}
{"type": "source_file", "path": "app/bigquery/queue.py", "content": "import asyncio\nfrom datetime import date, datetime\nfrom typing import TypedDict\n\nimport pandas as pd\n\nfrom app.bigquery.client import BigqueryClient, TableNameEnum\n\n\nclass CommentDataType(TypedDict):\n    user_id: str\n    channel_id: str\n    ts: str  # 상위 메시지 timestamp\n    comment_ts: str  # 댓글 timestamp\n    tddate: date\n    createtime: datetime\n    text: str\n\n\nclass EmojiDataType(TypedDict):\n    user_id: str\n    channel_id: str\n    ts: str\n    reactions_ts: str\n    tddate: date\n    createtime: datetime\n    reaction: str\n\n\nclass PostDataType(TypedDict):\n    user_id: str\n    channel_id: str\n    ts: str\n    tddate: date\n    createtime: datetime\n    text: str\n\n\nqueue_lock = asyncio.Lock()\n\ncomments_upload_queue: list[CommentDataType] = []\nemojis_upload_queue: list[EmojiDataType] = []\nposts_upload_queue: list[PostDataType] = []\n\n\nclass BigqueryQueue:\n    def __init__(self, client: BigqueryClient) -> None:\n        self._client = client\n\n    async def upload(self) -> None:\n        global comments_upload_queue, emojis_upload_queue, posts_upload_queue\n\n        async with queue_lock:\n            temp_comments_queue = list(comments_upload_queue)\n            if temp_comments_queue:\n                await asyncio.to_thread(\n                    self._client.update_table,\n                    pd.DataFrame(temp_comments_queue),\n                    TableNameEnum.COMMENTS_LOG,\n                    \"append\",\n                )\n                comments_upload_queue = [\n                    entry\n                    for entry in comments_upload_queue\n                    if entry not in temp_comments_queue\n                ]\n\n            temp_emojis_queue = list(emojis_upload_queue)\n            if temp_emojis_queue:\n                await asyncio.to_thread(\n                    self._client.update_table,\n                    pd.DataFrame(temp_emojis_queue),\n                    TableNameEnum.EMOJIS_LOG,\n                    \"append\",\n                )\n                emojis_upload_queue = [\n                    entry\n                    for entry in emojis_upload_queue\n                    if entry not in temp_emojis_queue\n                ]\n\n            temp_posts_queue = list(posts_upload_queue)\n            if temp_posts_queue:\n                await asyncio.to_thread(\n                    self._client.update_table,\n                    pd.DataFrame(temp_posts_queue),\n                    TableNameEnum.POSTS_LOG,\n                    \"append\",\n                )\n                posts_upload_queue = [\n                    entry\n                    for entry in posts_upload_queue\n                    if entry not in temp_posts_queue\n                ]\n"}
{"type": "source_file", "path": "app/api/services.py", "content": "from datetime import datetime, timedelta\nimport random\nfrom zoneinfo import ZoneInfo\n\nfrom fastapi import HTTPException, status\nfrom app import models, store\nfrom app.api.repositories import ApiRepository\nfrom app.utils import tz_now\nfrom app.config import settings\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom slack_sdk.models.blocks import (\n    SectionBlock,\n    ContextBlock,\n    MarkdownTextObject,\n)\nfrom app.constants import paper_plane_color_maps\n\n\nclass ApiService:\n    def __init__(self, api_repo: ApiRepository) -> None:\n        self._repo = api_repo\n\n    def get_user_by(self, user_id: str) -> models.User | None:\n        \"\"\"특정 유저를 조회합니다.\"\"\"\n        return self._repo.get_user(user_id)\n\n    async def send_paper_plane(\n        self,\n        sender_id: str,\n        sender_name: str,\n        receiver_id: str,\n        text: str,\n        client: AsyncWebClient,\n    ) -> models.PaperPlane:\n        \"\"\"종이비행기를 보냅니다.\"\"\"\n        receiver = self.get_user_by(user_id=receiver_id)\n        if not receiver:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"받는 사람을 찾을 수 없어요. 😢\",\n            )\n        color_map = random.choice(paper_plane_color_maps)\n        model = models.PaperPlane(\n            sender_id=sender_id,\n            sender_name=sender_name,\n            receiver_id=receiver_id,\n            receiver_name=receiver.name,\n            text=text,\n            text_color=color_map[\"text_color\"],\n            bg_color=color_map[\"bg_color\"],\n            color_label=color_map[\"color_label\"],\n        )\n        self._repo.create_paper_plane(model)\n        store.paper_plane_upload_queue.append(model.to_list_for_sheet())\n\n        await client.chat_postMessage(\n            channel=settings.THANKS_CHANNEL,\n            text=f\"💌 *<@{receiver_id}>* 님에게 종이비행기가 도착했어요!\",\n            blocks=[\n                SectionBlock(\n                    text=f\"💌 *<@{receiver_id}>* 님에게 종이비행기가 도착했어요!\\n\\n\",\n                ),\n                ContextBlock(\n                    elements=[\n                        MarkdownTextObject(\n                            text=\">받은 종이비행기는 `/종이비행기` 명령어 -> [주고받은 종이비행기 보기] 를 통해 확인할 수 있어요.\"\n                        )\n                    ],\n                ),\n            ],\n        )\n\n        await client.chat_postMessage(\n            channel=sender_id,\n            text=f\"💌 *<@{sender_id}>* 님에게 종이비행기를 보냈어요!\",\n            blocks=[\n                SectionBlock(\n                    text=f\"💌 *<@{receiver_id}>* 님에게 종이비행기를 보냈어요!\\n\\n\",\n                ),\n                ContextBlock(\n                    elements=[\n                        MarkdownTextObject(\n                            text=\">보낸 종이비행기는 `/종이비행기` 명령어 -> [주고받은 종이비행기 보기] 를 통해 확인할 수 있어요.\"\n                        )\n                    ],\n                ),\n            ],\n        )\n\n        return model\n\n    def fetch_sent_paper_planes(\n        self,\n        user_id: str,\n        offset: int,\n        limit: int,\n    ) -> tuple[int, list[models.PaperPlane]]:\n        \"\"\"유저가 보낸 종이비행기를 가져옵니다.\"\"\"\n        return self._repo.fetch_sent_paper_planes(\n            sender_id=user_id,\n            offset=offset,\n            limit=limit,\n        )\n\n    def fetch_received_paper_planes(\n        self,\n        user_id: str,\n        offset: int,\n        limit: int,\n    ) -> tuple[int, list[models.PaperPlane]]:\n        \"\"\"유저가 받은 종이비행기를 가져옵니다.\"\"\"\n        return self._repo.fetch_received_paper_planes(\n            receiver_id=user_id, offset=offset, limit=limit\n        )\n\n    def fetch_current_week_paper_planes(\n        self,\n        user_id: str,\n    ) -> list[models.PaperPlane]:\n        \"\"\"이번 주 종이비행기를 가져옵니다.\"\"\"\n        today = tz_now()\n\n        # 지난주 토요일 00시 계산\n        last_saturday = today - timedelta(days=(today.weekday() + 2) % 7)\n        start_dt = last_saturday.replace(hour=0, minute=0, second=0, microsecond=0)\n\n        # 이번주 금요일 23:59:59 계산\n        this_friday = start_dt + timedelta(days=6)\n        end_dt = this_friday.replace(hour=23, minute=59, second=59, microsecond=999999)\n\n        paper_planes = []\n        for plane in self._repo.fetch_paper_planes(sender_id=user_id):\n            plane_created_ad = datetime.fromisoformat(plane.created_at).replace(\n                tzinfo=ZoneInfo(\"Asia/Seoul\")\n            )\n            if start_dt <= plane_created_ad <= end_dt:\n                paper_planes.append(plane)\n\n        return paper_planes\n"}
{"type": "source_file", "path": "app/slack/event_handler.py", "content": "import re\nimport traceback\nfrom app.config import settings\nfrom slack_bolt.async_app import AsyncApp\nfrom slack_sdk.web.async_client import AsyncWebClient\n\nfrom app.logging import log_event\nfrom loguru import logger\nfrom slack_bolt.request import BoltRequest\nfrom slack_bolt.response import BoltResponse\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\nfrom slack_sdk.models.blocks import SectionBlock\nfrom slack_sdk.models.views import View\n\nfrom typing import Any, Callable, cast\n\nfrom app.slack.events import community as community_events\nfrom app.slack.events import contents as contents_events\nfrom app.slack.events import core as core_events\nfrom app.slack.events import log as log_events\nfrom app.slack.events import subscriptions as subscriptions_events\nfrom app.exception import BotException\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.base import SlackService\nfrom app.slack.services.point import PointService\nfrom app.slack.types import MessageBodyType\n\n\napp = AsyncApp(\n    client=AsyncWebClient(\n        token=settings.SLACK_BOT_TOKEN,\n        timeout=8,\n    ),\n)\n\n\n@app.middleware\nasync def log_event_middleware(\n    req: BoltRequest,\n    resp: BoltResponse,\n    next: Callable,\n) -> None:\n    \"\"\"이벤트를 로그로 남깁니다.\"\"\"\n    body = req.body\n    if body.get(\"command\"):\n        event = body.get(\"command\")\n        type = \"command\"\n    elif body.get(\"type\") == \"view_submission\":\n        event = body.get(\"view\", {}).get(\"callback_id\")\n        type = \"view_submission\"\n    elif body.get(\"type\") == \"block_actions\":\n        event = body.get(\"actions\", [{}])[0].get(\"action_id\")\n        type = \"block_actions\"\n    elif body.get(\"event\"):\n        event = body.get(\"event\", {}).get(\"type\")\n        type = \"event\"\n    else:\n        event = \"unknown\"\n        type = \"unknown\"\n\n    if event not in [\n        \"message\",\n        \"member_joined_channel\",\n        \"reaction_added\",\n        \"reaction_removed\",\n    ]:\n        # message 와 reaction 은 handle 함수에서 별도로 로깅합니다.\n        description = event_descriptions.get(str(event), \"알 수 없는 이벤트\")\n\n        # 종이비행기 메시지 전송 완료 이벤트는 내용을 로그에 포함시키지 않는다.\n        if description == \"종이비행기 메시지 전송 완료\":\n            req.context[\"event\"] = event\n            await next()\n\n        log_event(\n            actor=req.context.user_id,\n            event=event,  # type: ignore\n            type=type,\n            description=description,\n            body=body,\n        )\n\n    req.context[\"event\"] = event\n    await next()\n\n\n@app.middleware\nasync def dependency_injection_middleware(\n    req: BoltRequest,\n    resp: BoltResponse,\n    next: Callable,\n) -> None:\n    \"\"\"서비스 객체를 주입합니다.\"\"\"\n    event = req.context.get(\"event\")\n    user_id = req.context.user_id\n    channel_id = req.context.channel_id\n\n    if event in [\n        \"app_mention\",\n        \"channel_created\",\n        \"member_joined_channel\",\n        \"reaction_added\",\n        \"reaction_removed\",\n        \"message\",\n    ]:\n        # 해당 이벤트는 의존성 주입을 하지 않습니다.\n        # 메시지의 경우 handle_message 에서 의존성 주입을 합니다.\n        await next()\n        return\n\n    repo = SlackRepository()\n    user = repo.get_user(cast(str, user_id))\n    if user:\n        req.context[\"service\"] = SlackService(repo=repo, user=user)\n        req.context[\"point_service\"] = PointService(repo=repo)\n        req.context[\"user\"] = user\n        await next()\n        return\n\n    # TODO: 10기 멤버 등록 후에는 불필요하므로 제거\n    if event == \"app_home_opened\":\n        # 등록되지 않는 멤버는 의존성을 주입하지 않습니다.\n        req.context[\"service\"] = None\n        req.context[\"point_service\"] = None\n        req.context[\"user\"] = None\n        await next()\n        return\n\n    if user_id is None:\n        # 일부 슬랙 봇은 사용자 아이디가 없을 수 있습니다.\n        return\n\n    message = (\n        \"🥲 사용자 정보를 추가해주세요. 👉🏼 \"\n        f\"event: `{event}` \"\n        f\"channel: <#{channel_id}> \"\n        f\"user_id: {user_id}\"\n    )\n    await app.client.chat_postMessage(channel=settings.ADMIN_CHANNEL, text=message)\n    logger.error(message)\n    raise BotException(\"사용자 정보를 찾을 수 없어요.\")\n\n\n@app.error\nasync def handle_error(error, body):\n    \"\"\"이벤트 핸들러에서 발생한 에러를 처리합니다.\"\"\"\n    logger.error(f'\"{str(error)}\"')\n    trace = traceback.format_exc()\n    logger.debug(dict(body=body, error=trace))\n\n    # 단순 값 에러는 사용자에게 알리지 않습니다.\n    if isinstance(error, ValueError):\n        raise error\n\n    # 사용자에게 에러를 알립니다.\n    if re.search(r\"[\\u3131-\\uD79D]\", str(error)):\n        # 한글로 핸들링하는 메시지만 사용자에게 전송합니다.\n        message = str(error)\n    else:\n        message = \"예기치 못한 오류가 발생했어요.\"\n\n    text = f\"🥲 {message}\\n\\n👉🏼 문제가 해결되지 않는다면 <#{settings.BOT_SUPPORT_CHANNEL}> 채널로 문의해주세요.\"\n    if trigger_id := body.get(\"trigger_id\"):\n        await app.client.views_open(\n            trigger_id=trigger_id,\n            view=View(\n                type=\"modal\",\n                title={\"type\": \"plain_text\", \"text\": \"잠깐!\"},\n                blocks=[SectionBlock(text=text)],\n            ),\n        )\n\n    # 관리자에게 에러를 알립니다.\n    await app.client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=f\"🫢: {error=} 🕊️: {trace=} 👉🏼 💌: {body=}\",\n    )\n\n\n@app.event(\"message\")\nasync def handle_message(\n    ack: AsyncAck,\n    body: MessageBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n) -> None:\n    await ack()\n\n    event: dict[str, Any]\n    subtype: str | None\n    user_id: str\n    channel_id: str\n    thread_ts: str | None\n    ts: str\n    is_thread: bool\n\n    event = body.get(\"event\", {})  # type: ignore\n    subtype = event.get(\"subtype\")\n\n    # 1. 메시지 타입에 따른 변수 할당\n    # 1-1. 메시지 수정 및 파일 공유 외의 subtype 이벤트는 처리하지 않습니다.\n    # 자세한 subtype 이 궁금하다면 https://api.slack.com/events/message 참고.\n    if subtype and subtype not in [\"message_changed\", \"file_share\"]:\n        return\n\n    # 1-2. 메시지 수정 이벤트를 처리합니다.\n    elif subtype == \"message_changed\":\n        # 이미 봇이 댓글을 단 경우는 커피챗 인증 절차가 진행된 경우이므로 처리하지 않습니다.\n        if settings.TTOBOT_USER_ID in event.get(\"message\", {}).get(\"reply_users\", []):\n            return\n\n        user_id = event.get(\"message\", {}).get(\"user\")\n        channel_id = event[\"channel\"]\n        thread_ts = event.get(\"message\", {}).get(\"thread_ts\")\n        ts = event.get(\"message\", {}).get(\"ts\")\n        is_thread = thread_ts != ts if thread_ts else False\n\n    # 1-3. subtype 이 file_share 이거나 없는 경우를 처리합니다.\n    else:\n        user_id = event[\"user\"]\n        channel_id = event[\"channel\"]\n        thread_ts = event.get(\"thread_ts\")\n        ts = event[\"ts\"]\n        is_thread = thread_ts != ts if thread_ts else False\n\n        if is_thread:\n            await log_events.handle_comment_data(body=body)\n        else:  # TODO: 댓글이 post_data 로 들어오는 경우가 있는지 확인 필요.\n            await log_events.handle_post_data(body=body)\n\n    # 2. user_id 가 없는 이벤트(일부 슬랙 봇)는 처리하지 않습니다.\n    if user_id is None:\n        return\n\n    # 3. 사용자가 문의사항을 남기면 관리자에게 알립니다.\n    if (\n        channel_id in [settings.BOT_SUPPORT_CHANNEL, settings.SUPPORT_CHANNEL]\n        and not is_thread\n        and subtype != \"message_changed\"\n    ):\n        repo = SlackRepository()\n        user = repo.get_user(user_id)\n        if not user:\n            await _notify_missing_user_info(client, user_id)\n            return\n\n        message = f\"👋🏼 <#{user.channel_id}>채널의 {user.name}님이 <#{channel_id}>을 남겼어요. 👀 <@{settings.SUPER_ADMIN}> <@{settings.ADMIN_IDS[1]}>\"\n        await client.chat_postMessage(channel=settings.ADMIN_CHANNEL, text=message)\n        return\n\n    # 4. 커피챗 인증 메시지를 처리합니다.\n    elif channel_id == settings.COFFEE_CHAT_PROOF_CHANNEL:\n        repo = SlackRepository()\n        user = repo.get_user(user_id)\n        if not user:\n            await _notify_missing_user_info(client, user_id)\n            return\n\n        description = event_descriptions.get(\n            \"coffee_chat_proof_message\", \"알 수 없는 이벤트\"\n        )\n        log_event(\n            actor=user.user_id,\n            event=\"coffee_chat_proof_message\",\n            type=\"message\",\n            description=description,\n            body=body,\n        )\n\n        service = SlackService(repo=repo, user=user)\n        point_service = PointService(repo=repo)\n        await community_events.handle_coffee_chat_message(\n            ack=ack,\n            body=body,\n            say=say,\n            client=client,\n            user=user,\n            service=service,\n            point_service=point_service,\n            subtype=subtype,\n            is_thread=is_thread,\n            ts=ts,\n        )\n        return\n\n\nasync def _notify_missing_user_info(client: AsyncWebClient, user_id: str):\n    text = f\"🥲 사용자 정보를 추가해주세요. 👉🏼 user_id: {user_id}\"\n    await client.chat_postMessage(channel=settings.ADMIN_CHANNEL, text=text)\n    logger.error(text)\n\n\n@app.event(\"member_joined_channel\")\nasync def handle_member_joined_channel(ack, body) -> None:\n    await ack()\n\n\n# community\napp.action(\"cancel_coffee_chat_proof_button\")(\n    community_events.cancel_coffee_chat_proof_button\n)\napp.action(\"submit_coffee_chat_proof_button\")(\n    community_events.submit_coffee_chat_proof_button\n)\napp.view(\"submit_coffee_chat_proof_view\")(\n    community_events.submit_coffee_chat_proof_view\n)\napp.command(\"/종이비행기\")(community_events.paper_plane_command)\n\n# contents\napp.command(\"/제출\")(contents_events.submit_command)\napp.view(\"submit_view\")(contents_events.submit_view)\napp.action(\"intro_modal\")(contents_events.open_intro_modal)\n# app.action(\"forward_message\")(contents_events.forward_message)\napp.view(\"edit_intro_view\")(contents_events.edit_intro_view)\napp.view(\"submit_intro_view\")(contents_events.submit_intro_view)\napp.action(\"contents_modal\")(contents_events.contents_modal)\napp.action(\"bookmark_modal\")(contents_events.bookmark_modal)\napp.view(\"bookmark_view\")(contents_events.create_bookmark_view)\napp.command(\"/패스\")(contents_events.pass_command)\napp.view(\"pass_view\")(contents_events.pass_view)\napp.command(\"/검색\")(contents_events.search_command)\napp.view(\"submit_search\")(contents_events.submit_search)\napp.action(\"web_search\")(contents_events.web_search)\napp.view(\"back_to_search_view\")(contents_events.back_to_search_view)\napp.command(\"/북마크\")(contents_events.bookmark_command)\napp.action(\"open_bookmark_page_view\")(contents_events.bookmark_page_view)\napp.action(\"bookmark_overflow_action\")(contents_events.open_overflow_action)\napp.action(\"next_bookmark_page_action\")(contents_events.handle_bookmark_page)\napp.action(\"prev_bookmark_page_action\")(contents_events.handle_bookmark_page)\napp.view(\"handle_bookmark_page_view\")(contents_events.handle_bookmark_page)\n\n# core\napp.event(\"app_mention\")(core_events.handle_app_mention)\napp.event(\"channel_created\")(core_events.handle_channel_created)\napp.command(\"/예치금\")(core_events.open_deposit_view)\napp.command(\"/제출내역\")(core_events.open_submission_history_view)\napp.command(\"/도움말\")(core_events.open_help_view)\napp.command(\"/관리자\")(core_events.admin_command)\napp.action(\"sync_store_select\")(core_events.handle_sync_store)\napp.action(\"invite_channel\")(core_events.handle_invite_channel)\napp.view(\"invite_channel_view\")(core_events.handle_invite_channel_view)\napp.event(\"app_home_opened\")(core_events.handle_home_tab)\napp.action(\"open_deposit_view\")(core_events.open_deposit_view)\napp.action(\"open_submission_history_view\")(core_events.open_submission_history_view)\napp.action(\"open_help_view\")(core_events.open_help_view)\napp.action(\"open_point_history_view\")(core_events.open_point_history_view)\napp.action(\"open_point_guide_view\")(core_events.open_point_guide_view)\napp.action(\"send_paper_plane_message\")(core_events.send_paper_plane_message)\napp.action(\"open_paper_plane_url\")(core_events.open_paper_plane_url)\napp.view(\"send_paper_plane_message_view\")(core_events.send_paper_plane_message_view)\napp.action(\"open_paper_plane_guide_view\")(core_events.open_paper_plane_guide_view)\napp.action(\"open_coffee_chat_history_view\")(core_events.open_coffee_chat_history_view)\napp.action(\"download_point_history\")(core_events.download_point_history)\napp.action(\"download_coffee_chat_history\")(core_events.download_coffee_chat_history)\napp.action(\"download_submission_history\")(core_events.download_submission_history)\napp.action(\"open_subscribe_member_view\")(\n    subscriptions_events.open_subscribe_member_view\n)\napp.action(\"subscribe_member\")(subscriptions_events.subscribe_member)\napp.action(\"unsubscribe_member\")(subscriptions_events.unsubscribe_member)\n\n# log\napp.event(\"reaction_added\")(log_events.handle_reaction_added)\napp.event(\"reaction_removed\")(log_events.handle_reaction_removed)\napp.action(\"open_subscription_permalink\")(\n    subscriptions_events.open_subscription_permalink\n)\n\n\nevent_descriptions = {\n    \"/제출\": \"글 제출 시작\",\n    \"submit_view\": \"글 제출 완료\",\n    \"intro_modal\": \"다른 유저의 자기소개 확인\",\n    # \"forward_message\": \"다른 채널로 메시지 전송\",\n    \"edit_intro_view\": \"자기소개 수정 시작\",\n    \"submit_intro_view\": \"자기소개 수정 완료\",\n    \"contents_modal\": \"다른 유저의 제출한 글 목록 확인\",\n    \"bookmark_modal\": \"북마크 저장 시작\",\n    \"bookmark_view\": \"북마크 저장 완료\",\n    \"/패스\": \"글 패스 시작\",\n    \"pass_view\": \"글 패스 완료\",\n    \"/검색\": \"글 검색 시작\",\n    \"submit_search\": \"글 검색 완료\",\n    \"web_search\": \"웹 검색 시작\",\n    \"back_to_search_view\": \"글 검색 다시 시작\",\n    \"/북마크\": \"북마크 조회\",\n    \"bookmark_overflow_action\": \"북마크 메뉴 선택\",\n    \"next_bookmark_page_action\": \"다음 북마크 페이지\",\n    \"prev_bookmark_page_action\": \"이전 북마크 페이지\",\n    \"handle_bookmark_page_view\": \"북마크 페이지 이동\",\n    \"app_mention\": \"앱 멘션\",\n    \"/예치금\": \"예치금 조회\",\n    \"/제출내역\": \"제출내역 조회\",\n    \"/관리자\": \"관리자 메뉴 조회\",\n    \"/도움말\": \"도움말 조회\",\n    \"coffee_chat_proof_message\": \"커피챗 인증 메시지\",\n    \"cancel_coffee_chat_proof_button\": \"커피챗 인증 안내 닫기\",\n    \"submit_coffee_chat_proof_button\": \"커피챗 인증 제출 시작\",\n    \"submit_coffee_chat_proof_view\": \"커피챗 인증 제출 완료\",\n    \"sync_store_select\": \"데이터 동기화\",\n    \"invite_channel\": \"채널 초대\",\n    \"invite_channel_view\": \"채널 초대 완료\",\n    \"app_home_opened\": \"홈 탭 열림\",\n    \"open_deposit_view\": \"예치금 조회\",\n    \"open_submission_history_view\": \"제출내역 조회\",\n    \"open_help_view\": \"도움말 조회\",\n    \"open_point_history_view\": \"포인트 내역 조회\",\n    \"open_point_guide_view\": \"포인트 가이드 조회\",\n    \"send_paper_plane_message\": \"종이비행기 메시지 전송 시작\",\n    \"open_paper_plane_url\": \"종이비행기 URL 열기\",\n    \"open_paper_plane_guide_view\": \"종이비행기 가이드 조회\",\n    \"open_coffee_chat_history_view\": \"커피챗 내역 조회\",\n    \"download_point_history\": \"포인트 내역 다운로드\",\n    \"download_coffee_chat_history\": \"커피챗 내역 다운로드\",\n    \"download_submission_history\": \"제출내역 다운로드\",\n    \"send_paper_plane_message_view\": \"종이비행기 메시지 전송 완료\",\n    \"channel_created\": \"채널 생성\",\n    \"/종이비행기\": \"종이비행기 모달 열기\",\n    \"subscribe_member\": \"멤버 구독 완료\",\n    \"open_subscribe_member_view\": \"멤버 구독 모달 열기\",\n    \"open_subscription_permalink\": \"구독한 멤버의 새 글 보기\",\n    \"unsubscribe_member\": \"멤버 구독 취소\",\n}\n"}
{"type": "source_file", "path": "app/api/views/contents.py", "content": "from enum import StrEnum\nfrom typing import Any, Literal\nimport polars as pl\n\nfrom starlette import status\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom app.api.auth import current_user\nfrom app.constants import ContentCategoryEnum, ContentSortEnum\nfrom app.api import dto\nfrom app.models import SimpleUser\nfrom app.utils import translate_keywords\nfrom app.config import settings\nfrom app.slack.event_handler import app as slack_app\nfrom slack_sdk.errors import SlackApiError\n\n\nclass JobCategoryEnum(StrEnum):\n    DATA_SCIENCE = \"데이터과학\"\n    DATA_ANALYSIS = \"데이터분석\"\n    DATA_ENGINEERING = \"데이터엔지니어\"\n    BACKEND = \"백엔드\"\n    ANDROID = \"안드\"\n    INFRA = \"인프라\"\n    FULL_STACK = \"풀스택\"\n    FRONTEND = \"프론트\"\n    FLUTTER = \"플러터\"\n    AI = \"ai\"\n    IOS = \"ios\"\n    ML = \"ml\"\n    PMPO = \"pmpo\"\n\n\nrouter = APIRouter()\n\n\n@router.get(\n    \"/contents\",\n    status_code=status.HTTP_200_OK,\n    response_model=dto.ContentResponse,\n)\nasync def fetch_contents(\n    keyword: str,\n    offset: int = 0,\n    limit: int = Query(default=50, le=50),\n    category: ContentCategoryEnum | None = None,\n    order_by: ContentSortEnum = ContentSortEnum.DT,\n    descending: bool = True,\n    job_category: JobCategoryEnum | None = None,\n) -> dto.ContentResponse:\n    \"\"\"조건에 맞는 콘텐츠를 가져옵니다.\"\"\"\n    # TODO: LIKE 컬럼 추가하기\n    # TODO: 결과가 없을 경우, 글감 추천하기 <- 클라이언트가 처리\n    # TODO: 북마크 글 연동하기\n    # TODO: 큐레이션 탭 추가하기\n\n    # 원본 데이터 불러오기\n    users_df = pl.read_csv(\n        \"store/users.csv\",\n        columns=[\"user_id\", \"name\", \"cohort\", \"channel_name\"],\n    )\n    contents_df = pl.read_csv(\n        \"store/contents.csv\",\n        columns=[\n            \"user_id\",\n            \"title\",\n            \"content_url\",\n            \"dt\",\n            \"category\",\n            \"tags\",\n            \"ts\",\n        ],\n    )\n\n    # 직군 필터링\n    if job_category:\n        users_df = (\n            users_df.filter(pl.col(\"channel_name\").str.contains(f\"(?i){job_category}\"))\n            .with_columns(pl.lit(job_category).alias(\"job_category\"))\n            .drop(\"channel_name\")\n        )\n    else:\n        job_categories = [category.value for category in JobCategoryEnum]\n        users_df = users_df.with_columns(\n            pl.col(\"channel_name\")\n            .apply(lambda x: next((cat for cat in job_categories if cat in x), None))\n            .alias(\"job_category\")\n        ).drop(\"channel_name\")\n\n    # 유니크한 콘텐츠만 가져오기\n    joined_df = contents_df.unique(subset=[\"content_url\"]).join(\n        users_df, on=\"user_id\", how=\"inner\"\n    )\n\n    if keyword == \"전체보기\":\n        # '전체보기'는 최신순으로 정렬하여 반환\n        contents = joined_df.sort([\"dt\"], descending=descending)\n        count = len(contents)\n        data = list(\n            map(\n                lambda x: {**x, \"relevance\": 0},\n                contents.slice(offset, limit).to_dicts(),\n            )\n        )\n        return dto.ContentResponse(count=count, data=data)\n\n    if category:\n        contents_df = contents_df.filter(contents_df[\"category\"] == category)\n\n    # 키워드 추출, TODO: 명사 단위로 쪼개서 검색하기\n    keywords = [\n        keyword.lower()\n        for keyword in keyword.replace(\",\", \" \").replace(\"/\", \" \").split(\" \")\n        if keyword\n    ]\n    keywords.extend(translate_keywords(keywords))\n\n    # 키워드 매칭\n    matched_dfs = [\n        joined_df.filter(\n            joined_df.apply(lambda row: match_keyword(keyword, row)).to_series()\n        )\n        for keyword in set(keywords)\n    ]\n    if not matched_dfs:\n        return dto.ContentResponse(count=0, data=[])\n\n    # 관련도 추가\n    combined_df: pl.DataFrame = pl.concat(matched_dfs)\n    grouped_df = combined_df.groupby(\"content_url\").agg(pl.count().alias(\"relevance\"))\n\n    contents = joined_df.join(grouped_df, on=\"content_url\", how=\"inner\").sort(\n        [order_by, \"dt\"], descending=[descending, True]\n    )\n\n    count = len(contents)\n    data = contents.slice(offset, limit).to_dicts()\n    return dto.ContentResponse(count=count, data=data)\n\n\ndef match_keyword(keyword: str, row: tuple) -> bool:\n    return keyword in f\"{row[1]},{row[5]},{row[7]}\".lower()  # title, tags, name\n\n\n@router.get(\n    \"/messages\",\n    status_code=status.HTTP_200_OK,\n)\nasync def get_message(\n    ts: str,\n    channel_id: str,\n    multiple_messages: bool = False,\n    type: Literal[\"message\", \"reply\"] = \"message\",\n    user: SimpleUser = Depends(current_user),\n) -> dict[str, Any] | list[dict[str, Any]]:\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"수정 권한이 없습니다.\")\n\n    try:\n        if type == \"message\":\n            data = await slack_app.client.conversations_history(\n                channel=channel_id,\n                latest=ts,\n                inclusive=True,\n                limit=10 if multiple_messages else 1,\n            )\n        else:\n            data = await slack_app.client.conversations_replies(\n                channel=channel_id, ts=ts, inclusive=True, limit=1\n            )\n\n        if multiple_messages:\n            return [\n                {\n                    \"ts\": message[\"ts\"],\n                    \"text\": message[\"text\"],\n                    \"blocks\": message[\"blocks\"],\n                    \"attachments\": message.get(\"attachments\", []),\n                }\n                for message in data[\"messages\"]\n            ]\n\n        message = next((msg for msg in data[\"messages\"] if msg[\"ts\"] == ts), None)\n        if not message:\n            raise HTTPException(status_code=404, detail=\"콘텐츠를 찾을 수 없습니다.\")\n\n        text = message[\"text\"]\n        blocks = message[\"blocks\"]\n        attachments = message.get(\"attachments\", [])\n\n        return {\n            \"text\": text,\n            \"blocks\": blocks,\n            \"attachments\": attachments,\n        }\n\n    except SlackApiError as e:\n        raise HTTPException(status_code=409, detail=str(e))\n\n\nclass UpdateMessageRequest(dto.BaseModel):\n    text: str\n    blocks: list[dict[str, Any]]\n    attachments: list[dict[str, Any]]\n\n\n@router.post(\n    \"/messages\",\n    status_code=status.HTTP_200_OK,\n)\nasync def update_message(\n    ts: str,\n    channel_id: str,\n    data: UpdateMessageRequest,\n    user: SimpleUser = Depends(current_user),\n):\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"수정 권한이 없습니다.\")\n\n    try:\n        await slack_app.client.chat_update(\n            channel=channel_id,\n            ts=ts,\n            text=data.text,\n            blocks=data.blocks,\n            attachments=data.attachments,\n        )\n\n        permalink_res = await slack_app.client.chat_getPermalink(\n            channel=channel_id,\n            message_ts=ts,\n        )\n\n        return {\"permalink\": permalink_res[\"permalink\"]}\n\n    except SlackApiError as e:\n        raise HTTPException(status_code=409, detail=str(e))\n"}
{"type": "source_file", "path": "app/api/views/paper_planes.py", "content": "from pydantic import BaseModel\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom app.api.auth import current_user\nfrom app.api.deps import api_service\nfrom app.api.services import ApiService\nfrom app.api import dto\nfrom app.constants import BOT_IDS\nfrom app.models import SimpleUser\nfrom app.config import settings\nfrom app.slack.event_handler import app as slack_app\n\nrouter = APIRouter()\n\n\nclass SendPaperPlaneCreateIn(BaseModel):\n    receiver_id: str\n    text: str\n\n\n@router.post(\n    \"/paper-planes\",\n    status_code=status.HTTP_201_CREATED,\n)\nasync def send_paper_plane(\n    dto: SendPaperPlaneCreateIn,\n    service: ApiService = Depends(api_service),\n    user: SimpleUser = Depends(current_user),\n) -> dict[str, str]:\n    \"\"\"종이비행기를 보냅니다.\"\"\"\n    if user.user_id == dto.receiver_id:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"종이비행기는 자신에게 보낼 수 없어요. 😉\",\n        )\n\n    if len(dto.text) > 300:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"종이비행기 메시지는 300자 이내로 작성해주세요. 😉\",\n        )\n\n    if dto.receiver_id in BOT_IDS:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"봇에게 종이비행기를 보낼 수 없어요. 😉\",\n        )\n\n    if user.user_id == settings.SUPER_ADMIN:\n        pass\n    else:\n        pass\n        # paper_planes = service.fetch_current_week_paper_planes(user_id=user.user_id)\n        # if len(paper_planes) >= 7:\n        #     raise HTTPException(\n        #         status_code=status.HTTP_400_BAD_REQUEST,\n        #         detail=\"종이비행기는 한 주에 7개까지 보낼 수 있어요. (토요일 00시에 충전)\",\n        #     )\n\n    await service.send_paper_plane(\n        sender_id=user.user_id,\n        sender_name=user.name,\n        receiver_id=dto.receiver_id,\n        text=dto.text,\n        client=slack_app.client,\n    )\n    return {\"message\": \"종이비행기를 보냈습니다.\"}\n\n\n@router.get(\n    \"/paper-planes/sent\",\n    status_code=status.HTTP_200_OK,\n    response_model=dto.PaperPlaneResponse,\n)\nasync def fetch_sent_paper_planes(\n    offset: int = 0,\n    limit: int = Query(default=1000, le=1000),  # TODO: 무한 스크롤 구현 시 수정\n    service: ApiService = Depends(api_service),\n    user: SimpleUser = Depends(current_user),\n) -> dto.PaperPlaneResponse:\n    \"\"\"조건에 맞는 종이비행기를 가져옵니다.\"\"\"\n    count, data = service.fetch_sent_paper_planes(\n        user_id=user.user_id, offset=offset, limit=limit\n    )\n    return dto.PaperPlaneResponse(\n        count=count, data=[each.model_dump() for each in data]\n    )\n\n\n@router.get(\n    \"/paper-planes/received\",\n    status_code=status.HTTP_200_OK,\n    response_model=dto.PaperPlaneResponse,\n)\nasync def fetch_received_paper_planes(\n    offset: int = 0,\n    limit: int = Query(default=1000, le=1000),  # TODO: 무한 스크롤 구현 시 수정\n    service: ApiService = Depends(api_service),\n    user: SimpleUser = Depends(current_user),\n) -> dto.PaperPlaneResponse:\n    \"\"\"조건에 맞는 종이비행기를 가져옵니다.\"\"\"\n    count, data = service.fetch_received_paper_planes(\n        user_id=user.user_id, offset=offset, limit=limit\n    )\n    return dto.PaperPlaneResponse(\n        count=count, data=[each.model_dump() for each in data]\n    )\n"}
{"type": "source_file", "path": "app/slack/__init__.py", "content": ""}
{"type": "source_file", "path": "app/logging.py", "content": "import datetime\nimport decimal\nimport uuid\nimport orjson\n\nfrom typing import Any, Mapping\n\nfrom pydantic import BaseModel\nfrom app.utils import tz_now, tz_now_to_str\nfrom loguru import logger\n\n\ndef filter(record):\n    record[\"time\"] = tz_now().strftime(\"%Y-%m-%d %H:%M:%S.%f%z\")\n    message = record[\"message\"].replace('\"', \"'\")\n    record[\"message\"] = f'\"{message}\"'\n    return True\n\n\nlogger.add(\"store/logs.csv\", format=\"{time},{level},{message}\", filter=filter)\n\n\ndef default(obj: Any) -> str | list[Any] | dict[str, Any]:\n    if isinstance(obj, (decimal.Decimal, uuid.UUID)):\n        return str(obj)\n    elif isinstance(obj, set):\n        return list(obj)\n    elif isinstance(obj, datetime.datetime):\n        return obj.isoformat()\n    elif isinstance(obj, datetime.date):\n        return obj.isoformat()\n    elif isinstance(obj, bytes):\n        return obj.decode(\"utf-8\")\n    elif isinstance(obj, BaseModel):\n        return obj.model_dump()\n    else:\n        return \"This object cannot be serialized.\"\n\n\ndef log_event(\n    actor: str | None,\n    event: str,\n    type: str,\n    description: str = \"\",\n    body: Mapping[str, Any] = {},\n) -> None:\n    try:\n        data = dict(\n            actor=actor,\n            event=event,\n            type=type,\n            description=description,\n            timestamp=tz_now_to_str(),\n            body=body,\n        )\n        logger.info(orjson.dumps(data, default=default).decode(\"utf-8\"))\n    except Exception as e:\n        logger.debug(f\"Failed to log event: {str(e)}\")\n"}
{"type": "source_file", "path": "app/api/views/inflearn.py", "content": "from typing import Any\nfrom starlette import status\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom app.api.auth import current_user\nfrom app.models import SimpleUser\nfrom app.config import settings\n\nimport csv\n\nrouter = APIRouter()\n\n\n@router.get(\n    \"/inflearn/coupons\",\n    status_code=status.HTTP_200_OK,\n)\nasync def fetch_inflearn_coupons(\n    user: SimpleUser = Depends(current_user),\n) -> dict[str, Any]:\n    \"\"\"인프런 쿠폰 정보를 가져옵니다.\"\"\"\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"조회 권한이 없습니다.\")\n\n    with open(\"store/_inflearn_coupon.csv\", encoding=\"utf-8\") as f:\n        reader = csv.DictReader(f)\n        data = [each for each in reader]\n\n    return {\"data\": data}\n"}
{"type": "source_file", "path": "app/api/views/point.py", "content": "import asyncio\nfrom enum import StrEnum\nfrom typing import Any\n\nfrom starlette import status\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom app.api.auth import current_user\nfrom app.api.deps import point_service\nfrom app.models import SimpleUser\nfrom app.slack.services.point import PointService\nfrom app.slack_notification import send_point_noti_message\nfrom app.config import settings\nfrom app.slack.event_handler import app as slack_app\n\n\nclass PointTypeEnum(StrEnum):\n    CURATION = \"curation\"\n    VILLAGE_CONFERENCE = \"village_conference\"\n    SPECIAL = \"special\"\n\n\nrouter = APIRouter()\n\n\n@router.post(\n    \"/points\",\n    status_code=status.HTTP_200_OK,\n)\nasync def grant_points(\n    user_ids: list[str],\n    point_type: PointTypeEnum,\n    text: str = \"\",\n    point: int = 0,\n    reason: str = \"\",\n    user: SimpleUser = Depends(current_user),\n    point_service: PointService = Depends(point_service),\n) -> dict[str, Any]:\n    \"\"\"\n    관리자가 여러 유저에게 포인트를 지급하는 API입니다.\n    \"\"\"\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"지급 권한이 없습니다.\")\n\n    if point_type == PointTypeEnum.CURATION:\n        for user_id in user_ids:\n            message = point_service.grant_if_curation_selected(user_id)\n            await send_point_noti_message(\n                client=slack_app.client,\n                channel=user_id,\n                text=text + \"\\n\" + message,\n            )\n            await asyncio.sleep(1)\n        return {\"message\": \"큐레이션 선정 포인트를 지급했습니다.\"}\n\n    elif point_type == PointTypeEnum.VILLAGE_CONFERENCE:\n        for user_id in user_ids:\n            message = point_service.grant_if_village_conference_participated(user_id)\n            await send_point_noti_message(\n                client=slack_app.client,\n                channel=user_id,\n                text=text + \"\\n\" + message,\n            )\n            await asyncio.sleep(1)\n        return {\"message\": \"빌리지 반상회 참여 포인트를 지급했습니다.\"}\n\n    elif point_type == PointTypeEnum.SPECIAL:\n        if not point or not reason:\n            raise HTTPException(\n                status_code=400,\n                detail=\"특별 보너스 포인트는 point와 reason이 필요합니다.\",\n            )\n        for user_id in user_ids:\n            message = point_service.grant_if_special_point(user_id, point, reason)\n            await send_point_noti_message(\n                client=slack_app.client,\n                channel=user_id,\n                text=text + \"\\n\" + message,\n            )\n            await asyncio.sleep(1)\n        return {\"message\": \"특별 포인트를 지급했습니다.\"}\n"}
{"type": "source_file", "path": "app/config.py", "content": "from typing import Any\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    ENV: str\n    SERVER_DOMAIN: str\n    CLIENT_DOMAIN: str\n\n    SLACK_BOT_TOKEN: str\n    SLACK_APP_TOKEN: str\n    SLACK_CLIENT_ID: str\n    SLACK_CLIENT_SECRET: str\n\n    SCOPE: list[str]\n    JSON_KEYFILE_DICT: dict[str, Any]\n    SPREAD_SHEETS_URL: str\n    DEPOSIT_SHEETS_URL: str\n    SECRET_KEY: str\n    BIGQUERY_CREDENTIALS: dict[str, Any]\n    BIGQUERY_DATABASE_ID: str\n\n    NOTICE_CHANNEL: str\n    BOT_SUPPORT_CHANNEL: str\n    SUPPORT_CHANNEL: str\n    THANKS_CHANNEL: str\n    COFFEE_CHAT_PROOF_CHANNEL: str\n    ADMIN_CHANNEL: str\n    ADMIN_IDS: list[str]\n    TTOBOT_USER_ID: str\n    SUPER_ADMIN: str\n\n    POINT_MAP: dict[str, Any]\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "app/client.py", "content": "from typing import Any\nfrom app.logging import logger\nfrom app.config import settings\n\nfrom gspread import authorize, Spreadsheet, Worksheet\nfrom oauth2client.service_account import ServiceAccountCredentials\nfrom app.models import StoreModel\n\n\ncredentials = ServiceAccountCredentials.from_json_keyfile_dict(\n    settings.JSON_KEYFILE_DICT, settings.SCOPE\n)\ngc = authorize(credentials)\n\n\nclass SpreadSheetClient:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(\n        self,\n        doc: Spreadsheet = gc.open_by_url(settings.SPREAD_SHEETS_URL),\n        sheets: dict[str, Worksheet] | None = None,\n    ) -> None:\n        if not hasattr(self, \"_initialized\"):\n            self._doc = doc\n            self._sheets = (\n                {\n                    \"contents\": self._doc.worksheet(\"contents\"),\n                    \"users\": self._doc.worksheet(\"users\"),\n                    \"logs\": self._doc.worksheet(\"logs\"),\n                    \"backup\": self._doc.worksheet(\"backup\"),\n                    \"bookmark\": self._doc.worksheet(\"bookmark\"),\n                    \"coffee_chat_proof\": self._doc.worksheet(\"coffee_chat_proof\"),\n                    \"point_histories\": self._doc.worksheet(\"point_histories\"),\n                    \"paper_plane\": self._doc.worksheet(\"paper_plane\"),\n                    \"subscriptions\": self._doc.worksheet(\"subscriptions\"),\n                }\n                if not sheets\n                else sheets\n            )\n            self._initialized = True\n\n    def get_values(self, sheet_name: str, column: str = \"\") -> list[list[str]]:\n        \"\"\"스프레드 시트로 부터 값을 가져옵니다.\"\"\"\n        if column:\n            return self._sheets[sheet_name].get_values(column)\n        else:\n            return self._sheets[sheet_name].get_all_values()\n\n    def backup(self, values: list[list[str]]) -> None:\n        \"\"\"백업 시트에 데이터를 업로드 합니다.\"\"\"\n        # TODO: 추후 백업 시트를 자동 생성할 수 있도록 변경 필요\n        sheet = self._sheets[\"backup\"]\n        sheet.clear()\n        self._batch_append_rows(values, sheet, batch_size=1000)\n\n    def clear(self, sheet_name: str) -> None:\n        \"\"\"해당 시트의 모든 데이터를 삭제합니다.\"\"\"\n        self._sheets[sheet_name].clear()\n\n    def upload(self, sheet_name: str, values: list[list[str]]) -> None:\n        \"\"\"해당 시트에 데이터를 하나씩 업로드 합니다.\"\"\"\n        sheet = self._sheets[sheet_name]\n        for value in values:\n            sheet.append_row(value)\n\n    def bulk_upload(self, sheet_name: str, values: list[list[str]]) -> None:\n        \"\"\"해당 시트에 데이터를 업로드 합니다.\"\"\"\n        sheet = self._sheets[sheet_name]\n        self._batch_append_rows(values, sheet, batch_size=1000)\n\n    def update_bookmark(self, sheet_name: str, obj: StoreModel) -> None:\n        \"\"\"해당 객체 정보를 시트에 업데이트 합니다.\"\"\"\n        sheet = self._sheets[sheet_name]\n        records = sheet.get_all_records()\n\n        target_record = dict()\n        row_number = 2  # 1은 인덱스가 0부터 시작하기 때문이며 나머지 1은 시드 헤더 행이 있기 때문.\n        for idx, record in enumerate(records):\n            # TODO: 추후 조건 바꾸기\n            if obj.user_id == record[\"user_id\"] and obj.content_ts == str(  # type: ignore\n                record[\"content_ts\"]\n            ):\n                target_record = record\n                row_number += idx\n                break\n\n        values = obj.to_list_for_sheet()\n\n        if not target_record:\n            logger.error(f\"시트에 해당 값이 존재하지 않습니다. {values}\")\n\n        sheet.update(f\"A{row_number}:G{row_number}\", [values])\n\n    def update_subscription(\n        self,\n        sheet_name: str,\n        subscription_dict: dict[str, Any],\n    ) -> None:\n        \"\"\"해당 객체 정보를 시트에 업데이트 합니다.\"\"\"\n        sheet = self._sheets[sheet_name]\n        records = sheet.get_all_records()\n\n        target_record = dict()\n        row_number = 2  # 1은 인덱스가 0부터 시작하기 때문이며 나머지 1은 시드 헤더 행이 있기 때문.\n        for idx, record in enumerate(records):\n            if subscription_dict[\"id\"] == record[\"id\"]:\n                target_record = record\n                row_number += idx\n                break\n\n        values = list(subscription_dict.values())\n\n        if not target_record:\n            logger.error(f\"시트에 해당 값이 존재하지 않습니다. {values}\")\n\n        sheet.update(f\"A{row_number}:G{row_number}\", [values])\n\n    def update_user(self, sheet_name: str, values: list[str]) -> None:\n        \"\"\"유저 정보를 시트에 업데이트 합니다.\"\"\"\n        # TODO: 추후 업데이트 함수 통합하기\n        sheet = self._sheets[sheet_name]\n        records = sheet.get_all_records()\n\n        target_record = dict()\n        row_number = 2  # 1은 인덱스가 0부터 시작하기 때문이며 나머지 1은 시드 헤더 행이 있기 때문.\n        for idx, record in enumerate(records):\n            if values[0] == record[\"user_id\"]:\n                target_record = record\n                row_number += idx\n                break\n\n        if not target_record:\n            logger.error(f\"시트에 해당 값이 존재하지 않습니다. {values}\")\n\n        sheet.update(f\"A{row_number}:F{row_number}\", [values])\n\n    def _batch_append_rows(\n        self,\n        values: list[list[str]],\n        sheet: Worksheet,\n        batch_size: int,\n    ) -> None:\n        for i in range(0, len(values), batch_size):\n            batch = values[i : i + batch_size]\n            sheet.append_rows(batch)\n"}
{"type": "source_file", "path": "app/bigquery/__init__.py", "content": ""}
{"type": "source_file", "path": "app/exception.py", "content": "class BotException(Exception):\n    def __init__(self, message: str) -> None:\n        self.message = message\n        super().__init__(self.message)\n\n\nclass ClientException(Exception):\n    def __init__(self, message: str) -> None:\n        self.message = message\n        super().__init__(self.message)\n"}
{"type": "source_file", "path": "app/slack/events/__init__.py", "content": ""}
{"type": "source_file", "path": "app/__init__.py", "content": "import traceback\n\nfrom app.bigquery.client import BigqueryClient\nfrom app.bigquery.queue import BigqueryQueue\nfrom app.logging import logger\n\nfrom zoneinfo import ZoneInfo\nfrom app.client import SpreadSheetClient\nfrom app.slack.repositories import SlackRepository\nfrom fastapi import FastAPI, Request\nfrom apscheduler.triggers.interval import IntervalTrigger\nfrom app.config import settings\nfrom app.store import Store\nfrom app.api.views.contents import router as contents_router\nfrom app.api.views.login import router as login_router\nfrom app.api.views.paper_planes import router as paper_planes_router\nfrom app.api.views.point import router as point_router\nfrom app.api.views.inflearn import router as inflearn_router\nfrom app.api.views.message import router as message_router\nfrom slack_bolt.adapter.socket_mode.aiohttp import AsyncSocketModeHandler\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.slack.services.background import BackgroundService\n\n\nfrom slack_bolt.async_app import AsyncApp\nfrom app.slack.event_handler import app as slack_app\n\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.triggers.cron import CronTrigger\n\n\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\n        \"https://geultto-post-board.netlify.app\",\n        \"https://geultto-paper-plane.vercel.app\",\n        \"http://localhost:3000\",\n    ],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nslack_handler = AsyncSocketModeHandler(\n    app=slack_app,\n    app_token=settings.SLACK_APP_TOKEN,\n)\n\n\n@app.get(\"/\")\nasync def health(request: Request) -> bool:\n    return True\n\n\napp.include_router(contents_router, prefix=\"/v1\")\napp.include_router(login_router, prefix=\"/v1\")\napp.include_router(paper_planes_router, prefix=\"/v1\")\napp.include_router(point_router, prefix=\"/v1\")\napp.include_router(inflearn_router, prefix=\"/v1\")\napp.include_router(message_router, prefix=\"/v1\")\n\nif settings.ENV == \"prod\":\n    async_schedule = AsyncIOScheduler(daemon=True, timezone=ZoneInfo(\"Asia/Seoul\"))\n\n    @app.on_event(\"startup\")\n    async def startup():\n        # 서버 저장소 동기화\n        store = Store(client=SpreadSheetClient())\n\n        # # 업로드 스케줄러\n        async_schedule.add_job(\n            upload_queue, \"interval\", seconds=20, args=[store, slack_app]\n        )\n\n        # 로그 업로드 스케줄러\n        log_trigger = IntervalTrigger(minutes=1, timezone=ZoneInfo(\"Asia/Seoul\"))\n        async_schedule.add_job(upload_logs, trigger=log_trigger, args=[store])\n\n        # 빅쿼리 업로드 스케줄러\n        bigquery_trigger = IntervalTrigger(minutes=10, timezone=ZoneInfo(\"Asia/Seoul\"))\n        queue = BigqueryQueue(client=BigqueryClient())\n        async_schedule.add_job(upload_bigquery, trigger=bigquery_trigger, args=[queue])\n\n        # 멤버 구독 알림 스케줄러: 매일 오전 8시\n        subscribe_trigger = CronTrigger(\n            hour=8,\n            minute=0,\n            timezone=\"Asia/Seoul\",\n        )\n        async_schedule.add_job(\n            subscribe_job, trigger=subscribe_trigger, args=[slack_app]\n        )\n\n        # 스케줄러 시작\n        async_schedule.start()\n\n        # 슬랙 소켓 모드 실행\n        await slack_handler.connect_async()\n\n    async def upload_queue(store: Store, slack_app: AsyncApp) -> None:\n        \"\"\"업로드 큐에 있는 데이터를 업로드합니다.\"\"\"\n        try:\n            await store.upload_queue()\n        except Exception as e:\n            trace = traceback.format_exc()\n            error = f\"시트 업로드 중 에러가 발생했어요. {str(e)} {trace}\"\n            message = f\"🫢: {error=} 🕊️: {trace=}\"\n            logger.error(message)\n\n            # 관리자에게 에러를 알립니다.\n            await slack_app.client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=message,\n            )\n\n    async def upload_logs(store: Store) -> None:\n        store.upload_all(\"logs\")\n        store.initialize_logs()\n\n    async def upload_bigquery(queue: BigqueryQueue) -> None:\n        try:\n            await queue.upload()\n        except Exception as e:\n            trace = traceback.format_exc()\n            error = f\"빅쿼리 업로드 중 에러가 발생했어요. {str(e)} {trace}\"\n            message = f\"🫢: {error=} 🕊️: {trace=}\"\n            logger.error(message)\n\n            await slack_app.client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=message,\n            )\n\n    async def subscribe_job(slack_app: AsyncApp) -> None:\n        slack_service = BackgroundService(repo=SlackRepository())\n        try:\n            await slack_service.prepare_subscribe_message_data()\n            await slack_service.send_subscription_messages(slack_app)\n        except Exception as e:\n            trace = traceback.format_exc()\n            error = f\"멤버 구독 알림 전송 중 에러가 발생했어요. {str(e)} {trace}\"\n            message = f\"🫢: {error=} 🕊️: {trace=}\"\n            logger.error(message)\n\n            await slack_app.client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=message,\n            )\n\n    @app.on_event(\"shutdown\")\n    async def shutdown():\n        # 서버 저장소 업로드\n        await slack_handler.close_async()\n\n        store = Store(client=SpreadSheetClient())\n        await store.upload_queue()\n        store.upload_all(\"logs\")\n        store.initialize_logs()\n\n        queue = BigqueryQueue(client=BigqueryClient())\n        await queue.upload()\n\n        async_schedule.shutdown(wait=True)\n\nelse:\n\n    @app.on_event(\"startup\")\n    async def startup():\n        # 슬랙 소켓 모드 실행\n        await slack_handler.connect_async()\n"}
{"type": "source_file", "path": "app/api/repositories.py", "content": "import csv\nfrom app import models\nimport polars as pl\n\n\nclass ApiRepository:\n    def __init__(self) -> None: ...\n\n    def get_user(self, user_id: str) -> models.User | None:\n        \"\"\"특정 유저를 조회합니다.\"\"\"\n        df = pl.read_csv(\n            \"store/users.csv\", dtypes={\"deposit\": pl.Utf8}\n        )  # pl은 deposit 을 int로 인식하기 때문에 str로 변경\n        users = df.filter(pl.col(\"user_id\") == user_id).to_dicts()\n\n        return models.User(**users[0]) if users else None\n\n    def fetch_users(self) -> list[models.User]:\n        \"\"\"모든 유저를 조회합니다.\"\"\"\n        df = pl.read_csv(\"store/users.csv\", dtypes={\"deposit\": pl.Utf8})\n        return [models.User(**row) for row in df.to_dicts()]\n\n    def fetch_sent_paper_planes(\n        self,\n        sender_id: str,\n        offset: int,\n        limit: int,\n    ) -> tuple[int, list[models.PaperPlane]]:\n        \"\"\"유저가 보낸 종이비행기를 가져옵니다.\"\"\"\n        df = pl.read_csv(\"store/paper_plane.csv\")\n        data = df.filter(pl.col(\"sender_id\") == sender_id).sort(\n            \"created_at\", descending=True\n        )\n        count = len(data)\n        paper_planes = data.slice(offset, limit).to_dicts()\n        return count, [models.PaperPlane(**paper_plane) for paper_plane in paper_planes]\n\n    def fetch_received_paper_planes(\n        self,\n        receiver_id: str,\n        offset: int,\n        limit: int,\n    ) -> tuple[int, list[models.PaperPlane]]:\n        \"\"\"유저가 받은 종이비행기를 가져옵니다.\"\"\"\n        df = pl.read_csv(\"store/paper_plane.csv\")\n        data = df.filter(pl.col(\"receiver_id\") == receiver_id).sort(\n            \"created_at\", descending=True\n        )\n        count = len(data)\n        paper_planes = data.slice(offset, limit).to_dicts()\n        return count, [models.PaperPlane(**paper_plane) for paper_plane in paper_planes]\n\n    def fetch_paper_planes(self, sender_id: str) -> list[models.PaperPlane]:\n        \"\"\"종이비행기를 가져옵니다.\"\"\"\n        with open(\"store/paper_plane.csv\") as f:\n            reader = csv.DictReader(f)\n            paper_planes = [\n                models.PaperPlane(**paper_plane)  # type: ignore\n                for paper_plane in reader\n                if paper_plane[\"sender_id\"] == sender_id\n            ]\n            return paper_planes\n\n    def create_paper_plane(self, paper_plane: models.PaperPlane) -> None:\n        \"\"\"종이비행기를 생성합니다.\"\"\"\n        with open(\"store/paper_plane.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(paper_plane.to_list_for_csv())\n"}
{"type": "source_file", "path": "app/constants.py", "content": "import datetime\nfrom enum import Enum\n\n\nURL_REGEX = r\"((http|https):\\/\\/)?[a-zA-Z0-9.-]+(\\.[a-zA-Z]{2,})\"\nMAX_PASS_COUNT = 2\nDUE_DATES = [  # 글또 시작일 을 포함한 오름차순 마감일 리스트\n    datetime.datetime(2024, 9, 29).date(),  # 0회차 - 글또 10기 시작\n    datetime.datetime(2024, 10, 13).date(),  # 1회차\n    datetime.datetime(2024, 10, 27).date(),  # 2회차\n    datetime.datetime(2024, 11, 10).date(),  # 3회차\n    datetime.datetime(2024, 11, 24).date(),  # 4회차\n    # datetime.datetime(2024, 12, 8).date(),  # 비상계엄으로 인한 2주 연장\n    datetime.datetime(2024, 12, 22).date(),  # 5회차\n    datetime.datetime(2025, 1, 5).date(),  # 6회차\n    datetime.datetime(2025, 1, 19).date(),  # 7회차\n    datetime.datetime(2025, 2, 2).date(),  # 8회차\n    datetime.datetime(2025, 2, 16).date(),  # 9회차\n    datetime.datetime(2025, 3, 2).date(),  # 10회차\n    datetime.datetime(2025, 3, 16).date(),  # 11회차\n    datetime.datetime(2025, 3, 30).date(),  # 12회차\n    datetime.datetime(2025, 4, 13).date(),  # 추가회차(임시)\n]\n\n\nclass ContentCategoryEnum(str, Enum):\n    CODETREE = \"코드트리 x 글또 블로그 챌린지 2기\"\n    GILBUT = \"길벗 책 리뷰\"\n    HANBIT = \"한빛미디어 책 리뷰\"\n    PROJECT = \"프로젝트\"\n    TECH = \"기술 & 언어\"\n    CULTURE = \"조직 & 문화\"\n    JOB = \"취준 & 이직\"\n    DAILY = \"일상 & 생각 & 회고\"\n    ETC = \"기타\"\n\n\nclass ContentSortEnum(str, Enum):\n    DT = \"dt\"\n    RELEVANCE = \"relevance\"\n    # LIKE = \"like\" # TODO: 추후 추가하기\n\n\nremind_message = \"\"\"👋 안녕하세요! 오늘은 글 제출 마감일이에요.\n지난 2주 동안 배우고 경험한 것들을 자정까지 나눠주세요.\n{user_name} 님의 이야기를 기다릴게요!🙂\"\"\"\n\n\n# fmt: off\n\n# paper_plane_color_maps = [\n#     {\"color_label\": \"fiery_red\", \"bg_color\": \"#FF4500\", \"text_color\": \"#FFFFFF\"},  # 불꽃 같은 빨간색\n#     {\"color_label\": \"fresh_green\", \"bg_color\": \"#32CD32\", \"text_color\": \"#FFFFFF\"},  # 싱그러운 초록색\n#     {\"color_label\": \"sky_blue\", \"bg_color\": \"#1E90FF\", \"text_color\": \"#FFFFFF\"},  # 맑은 하늘색\n#     {\"color_label\": \"bright_gold\", \"bg_color\": \"#FFD700\", \"text_color\": \"#000000\"},  # 밝은 금색\n#     {\"color_label\": \"deep_violet\", \"bg_color\": \"#8A2BE2\", \"text_color\": \"#FFFFFF\"},  # 진한 보라색\n#     {\"color_label\": \"ripe_tomato\", \"bg_color\": \"#FF6347\", \"text_color\": \"#FFFFFF\"},  # 잘 익은 토마토색\n#     {\"color_label\": \"cool_steelblue\", \"bg_color\": \"#4682B4\", \"text_color\": \"#FFFFFF\"},  # 차가운 스틸블루\n#     {\"color_label\": \"soft_slateblue\", \"bg_color\": \"#6A5ACD\", \"text_color\": \"#FFFFFF\"},  # 부드러운 슬레이트블루\n#     {\"color_label\": \"pastel_chartreuse\", \"bg_color\": \"#A9F2A5\", \"text_color\": \"#2F4F4F\"},  # 파스텔 차트레즈\n#     {\"color_label\": \"vivid_deeppink\", \"bg_color\": \"#FF1493\", \"text_color\": \"#FFFFFF\"},  # 선명한 딥핑크\n#     {\"color_label\": \"blush_rosybrown\", \"bg_color\": \"#BC8F8F\", \"text_color\": \"#FFFFFF\"},  # 블러쉬 로지브라운\n#     {\"color_label\": \"peach_silver\", \"bg_color\": \"#FFDAB9\", \"text_color\": \"#8B4513\"},  # 복숭아빛 실버\n#     {\"color_label\": \"muted_seagreen\", \"bg_color\": \"#8FBC8F\", \"text_color\": \"#FFFFFF\"},  # 차분한 바다초록색\n#     {\"color_label\": \"soft_lightcoral\", \"bg_color\": \"#F08080\", \"text_color\": \"#FFFFFF\"},  # 부드러운 라이트코랄\n#     {\"color_label\": \"lavender_gray\", \"bg_color\": \"#E6E6FA\", \"text_color\": \"#4B0082\"},  # 라벤더 그레이\n#     {\"color_label\": \"sunset_orange\", \"bg_color\": \"#FF7F50\", \"text_color\": \"#FFFFFF\"},  # 석양 오렌지\n#     {\"color_label\": \"ocean_teal\", \"bg_color\": \"#008080\", \"text_color\": \"#FFFFFF\"},  # 바다 청록색\n#     {\"color_label\": \"midnight_blue\", \"bg_color\": \"#191970\", \"text_color\": \"#FFFFFF\"},  # 자정의 파란색\n#     {\"color_label\": \"buttercup_yellow\", \"bg_color\": \"#FFDD44\", \"text_color\": \"#000000\"},  # 버터컵 옐로우\n#     {\"color_label\": \"rosewood\", \"bg_color\": \"#65000B\", \"text_color\": \"#FFFFFF\"}  # 로즈우드\n# ]\n\n\n# 발렌타인 버전\npaper_plane_color_maps = [\n    {\"color_label\": \"valentine_1\", \"bg_color\": \"#BC2026\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_2\", \"bg_color\": \"#862A2A\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_3\", \"bg_color\": \"#2A1010\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_4\", \"bg_color\": \"#D48E52\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_5\", \"bg_color\": \"#774A23\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_6\", \"bg_color\": \"#291707\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_7\", \"bg_color\": \"#FFEBBD\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_8\", \"bg_color\": \"#F0C86D\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_9\", \"bg_color\": \"#DC9E0D\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_10\", \"bg_color\": \"#BCA0C3\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_11\", \"bg_color\": \"#7E5389\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_12\", \"bg_color\": \"#99A799\", \"text_color\": \"#E2FAE2\"},\n    {\"color_label\": \"valentine_13\", \"bg_color\": \"#EAA4C8\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_14\", \"bg_color\": \"#C26D99\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_15\", \"bg_color\": \"#913263\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_16\", \"bg_color\": \"#FFB7CF\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_17\", \"bg_color\": \"#FF95AF\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_18\", \"bg_color\": \"#FF5680\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_19\", \"bg_color\": \"#80C4BC\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_20\", \"bg_color\": \"#49ABA0\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_21\", \"bg_color\": \"#1E7D72\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_22\", \"bg_color\": \"#17635A\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_23\", \"bg_color\": \"#223943\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_24\", \"bg_color\": \"#264A28\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_25\", \"bg_color\": \"#6F9370\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_26\", \"bg_color\": \"#2C612D\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_27\", \"bg_color\": \"#0C380D\", \"text_color\": \"#EEE1E1\"}\n]\n\n# # 크리스마스 버전\n# paper_plane_color_maps = [\n#     {\"color_label\": \"christmas_1\", \"bg_color\": \"#BC2026\", \"text_color\": \"#FFCCCC\"},  # 불꽃 같은 빨간색\n#     {\"color_label\": \"christmas_2\", \"bg_color\": \"#118911\", \"text_color\": \"#E2FAE2\"},  # 싱그러운 초록색\n#     {\"color_label\": \"christmas_3\", \"bg_color\": \"#EBB84E\", \"text_color\": \"#252525\"},  # 맑은 하늘색\n#     {\"color_label\": \"christmas_4\", \"bg_color\": \"#DB7F3E\", \"text_color\": \"#F2DED0\"},  # 밝은 금색\n#     {\"color_label\": \"christmas_5\", \"bg_color\": \"#74528F\", \"text_color\": \"#F5EBFC\"},  # 진한 보라색\n#     {\"color_label\": \"christmas_6\", \"bg_color\": \"#874544\", \"text_color\": \"#F7E3E3\"},  # 잘 익은 토마토색\n# ]\n\n# fmt: on\n\n\n# 10기 1_채널 아이디 상수\nPRIMARY_CHANNEL = [\n    \"C07P09BTQAW\",  # 1_대나무숲_고민_공유\n    \"C07PXJR6KRP\",  # 1_소모임_홍보\n    \"C07PD016V7T\",  # 1_자료_공유\n    \"C07NKNYTFN3\",  # 1_자유_홍보\n    \"C07P09N1XM0\",  # 1_자유로운담소\n    \"C07PP3V0524\",  # 1_큐레이션\n    \"C07PP3A5GGG\",  # 1_온라인_모각글\n    \"C07NKNP2RSB\",  # 1_자기소개\n    \"C07PG0G4RQD\",  # 1_감사는_비행기를_타고\n    \"C07NTLWAWR4\",  # 1_커피챗_또는_모임_후기\n    \"C07NKP4M69M\",  # 1_커피챗_번개_모각글_하실_분\n    \"C08BCU9C5BN\",  # 1_글또_커피챗_조_공유\n    \"C05J87UPC3F\",  # dev 채널 1 (로컬 테스트 채널)\n    \"C07PD0VMHJM\",  # dev 채널 2 (또봇 크루 채널)\n]\n\n\nBOT_IDS = [\n    \"U07PJ6J7FFV\",\n    \"U07P0BB4YKV\",\n    \"U07PFJCHHFF\",\n    \"U07PK8CLGKW\",\n    \"U07P8E69V3N\",\n    \"U07PB8HF4V8\",\n    \"U07PAMU09AS\",\n    \"U07PSF2PKKK\",\n    \"U07PK195U74\",\n    \"U04GVDM0R4Y\",\n    \"USLACKBOT\",\n]\n"}
{"type": "source_file", "path": "app/api/views/message.py", "content": "from typing import Any\nfrom starlette import status\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom app.api.auth import current_user\nfrom app.api.dto import SendMessageDTO\nfrom app.models import SimpleUser\nfrom app.config import settings\nfrom app.slack.event_handler import app as slack_app\n\n\nrouter = APIRouter()\n\n\n@router.post(\n    \"/send-messages\",\n    status_code=status.HTTP_200_OK,\n)\nasync def send_messages(\n    dto_list: list[SendMessageDTO],\n    user: SimpleUser = Depends(current_user),\n) -> dict[str, Any]:\n    \"\"\"메시지를 보냅니다.\"\"\"\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"메시지 전송 권한이 없습니다.\")\n\n    for dto in dto_list:\n        await slack_app.client.chat_postMessage(\n            channel=dto.channel_id,\n            text=dto.message,\n        )\n\n    return {\"message\": \"메시지를 보냈습니다.\"}\n"}
{"type": "source_file", "path": "app/models.py", "content": "from __future__ import annotations\n\nfrom abc import abstractmethod\n\nfrom enum import Enum\nfrom zoneinfo import ZoneInfo\nfrom pydantic import BaseModel, Field, field_validator\nimport datetime\nfrom app.constants import DUE_DATES, MAX_PASS_COUNT\nfrom app.exception import BotException\n\nfrom app.utils import generate_unique_id, tz_now, tz_now_to_str\n\n\nclass User(BaseModel):\n    user_id: str  # 슬랙 아이디\n    name: str  # 이름\n    channel_name: str  # 코어채널 이름\n    channel_id: str  # 코어채널 아이디\n    intro: str  # 자기소개\n    deposit: str = \"\"  # 예치금\n    cohort: str = \"\"  # 기수\n    contents: list[Content] = []  # 제출한 콘텐츠\n\n    @field_validator(\"contents\", mode=\"before\")\n    def get_contents(cls, v: list[Content]) -> list[Content]:\n        \"\"\"콘텐츠를 생성일시 오름차순으로 정렬하여 반환합니다.\"\"\"\n        return sorted(v, key=lambda content: content.dt_)\n\n    @property\n    def pass_count(self) -> int:\n        \"\"\"pass 횟수를 반환합니다.\"\"\"\n        return len([content for content in self.contents if content.type == \"pass\"])\n\n    @property\n    def is_prev_pass(self) -> bool:\n        \"\"\"직전에 pass 했는지 여부를 반환합니다.\"\"\"\n        try:\n            recent_content = self.recent_content\n        except Exception:\n            return False\n\n        if recent_content.type != \"pass\":\n            return False\n\n        return self._is_prev_pass(recent_content)\n\n    def _is_prev_pass(self, recent_content: Content) -> bool:\n        \"\"\"전전회차 마감일 초과, 현재 날짜 이하 사이에 pass 했는지 여부를 반환합니다.\"\"\"\n        now_date = tz_now().date()\n        second_latest_due_date = DUE_DATES[-2]\n        for i, due_date in enumerate(DUE_DATES):\n            if now_date <= due_date:\n                second_latest_due_date = DUE_DATES[i - 2]\n                break\n        return second_latest_due_date < recent_content.date <= now_date\n\n    @property\n    def recent_content(self) -> Content:\n        \"\"\"최근 콘텐츠를 반환합니다.\"\"\"\n        return self.contents[-1]\n\n    @property\n    def content_urls(self) -> list[str]:\n        \"\"\"유저의 모든 콘텐츠 url 을 반환합니다.\"\"\"\n        return [content.content_url for content in self.contents]\n\n    def fetch_contents(self, descending: bool = False) -> list[Content]:\n        \"\"\"콘텐츠를 생성일시 내림차순으로 정렬하여 반환합니다.\"\"\"\n        if descending:\n            return sorted(self.contents, key=lambda content: content.dt_, reverse=True)\n        return self.contents\n\n    def get_due_date(self) -> tuple[int, datetime.date]:\n        \"\"\"현재 회차와 마감일을 반환합니다.\"\"\"\n        now_date = tz_now().date()\n        for i, due_date in enumerate(DUE_DATES):\n            if now_date <= due_date:\n                round = i\n                return round, due_date\n        raise BotException(\"지금은 글또 글 제출 기간이 아니에요.\")\n\n    @property\n    def is_submit(self) -> bool:\n        \"\"\"현재 회차의 제출여부를 반환합니다.\"\"\"\n        try:\n            recent_content = self.recent_content\n        except Exception:\n            return False\n\n        if recent_content.type != \"submit\":\n            return False\n\n        now_date = tz_now().date()\n        for i, due_date in enumerate(DUE_DATES):\n            if now_date <= due_date:  # 현재 날짜가 보다 같거나 크면 현재 마감일이다.\n                # 현재 마감일의 직전 마감일을 구한다.\n                latest_due_date = DUE_DATES[i - 1]\n                break\n\n        # 최근 제출한 콘텐츠의 날짜가 직전 마감일 초과, 현재 날짜 이하 라면 제출했다고 판단한다.\n        return latest_due_date < recent_content.date <= now_date\n\n    def get_submit_status(self) -> dict[int, str]:\n        \"\"\"현재 회차는 제외한 회차별 제출 여부를 반환합니다.\"\"\"\n        submit_status = {}\n        for i, due_date in enumerate(DUE_DATES):\n            # 0회차는 시작일이므로 제외한다.\n            if i == 0:\n                continue\n\n            # 현재 회차는 제출 여부를 판단하지 않는다.\n            if due_date >= tz_now().date():\n                break\n\n            # 기본값은 미제출\n            submit_status[i] = \"미제출\"\n\n            # 콘텐츠의 제출 날짜가 직전 마감일 초과, 마감일 이하 라면 제출했다고 판단한다.\n            for content in self.fetch_contents():\n                latest_due_date = DUE_DATES[i - 1]\n                if latest_due_date < content.date <= due_date:\n                    if content.type == \"submit\":\n                        submit_status[i] = \"제출\"\n                    elif content.type == \"pass\":\n                        submit_status[i] = \"패스\"\n                    else:\n                        submit_status[i] = \"미제출\"\n\n        return submit_status\n\n    def get_continuous_submit_count(self) -> int:\n        \"\"\"내림차순으로 연속으로 제출한 횟수를 반환합니다.\"\"\"\n        count = 0\n        submit_status = self.get_submit_status()\n        for _, v in sorted(submit_status.items(), reverse=True):\n            if v == \"제출\":\n                count += 1\n            elif v == \"패스\":  # 패스는 연속 제출 횟수에 포함하지 않는다.\n                continue\n            else:  # 미제출은 연속 제출 횟수를 끊는다.\n                break\n        return count\n\n    def check_channel(self, channel_id: str) -> None:\n        \"\"\"코어 채널이 일치하는지 체크합니다.\"\"\"\n        if self.channel_id == \"ALL\":\n            return\n        if self.channel_id != channel_id:\n            raise BotException(\n                f\"{self.name} 님의 코어 채널 <#{self.channel_id}> 에서 다시 시도해주세요.\"\n            )\n\n    @property\n    def submission_guide_message(self) -> str:\n        \"\"\"제출 모달 가이드 메시지를 반환합니다.\"\"\"\n        round, due_date = self.get_due_date()\n        guide_message = f\"현재 회차는 {round}회차, 마감일은 {due_date} 이에요.\"\n        if self.is_submit:\n            guide_message += f\"\\n({self.name} 님은 이미 {round}회차 글을 제출했어요)\"\n        else:\n            guide_message += (\n                f\"\\n({self.name} 님은 아직 {round}회차 글을 제출하지 않았어요)\"\n            )\n        guide_message += (\n            f\"\\n제출 메시지는 코어 채널인 <#{self.channel_id}> 에 표시됩니다.\"\n        )\n        return guide_message\n\n    def check_pass(self) -> None:\n        \"\"\"pass 사용 가능 여부를 체크합니다.\"\"\"\n        if self.pass_count >= MAX_PASS_COUNT:\n            message = \"사용할 수 있는 pass 가 없어요.\"\n            raise BotException(message)\n        if self.is_prev_pass:\n            message = (\n                \"직전 회차에 pass 를 사용했기 때문에 연속으로 pass 를 사용할 수 없어요.\"\n            )\n            raise BotException(message)\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.user_id,\n            self.channel_name,\n            self.name,\n            self.channel_id,\n            self.intro,\n            self.cohort,\n        ]\n\n\nclass SimpleUser(BaseModel):\n    user_id: str\n    name: str\n    channel_name: str\n    channel_id: str\n    intro: str\n    cohort: str\n\n\nclass StoreModel(BaseModel):\n    ...\n\n    @abstractmethod\n    def to_list_for_csv(self) -> list[str]:\n        \"\"\"csv 파일에 쓰기 위한 리스트를 반환합니다.\"\"\"\n        ...\n\n    @abstractmethod\n    def to_list_for_sheet(self) -> list[str]:\n        \"\"\"구글 시트에 쓰기 위한 리스트를 반환합니다.\"\"\"\n        ...\n\n\nclass Content(StoreModel):\n    dt: str = Field(default_factory=tz_now_to_str)\n    user_id: str\n    username: str\n    description: str = \"\"\n    type: str\n    content_url: str = \"\"\n    title: str = \"\"\n    category: str = \"\"\n    tags: str = \"\"\n    curation_flag: str = \"N\"  # \"Y\", \"N\"\n    ts: str = \"\"\n    feedback_intensity: str = \"HOT\"  # \"MILD\", \"HOT\", \"FIRE\", \"DIABLO\"\n\n    def __hash__(self) -> int:\n        return hash(self.ts)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Content):\n            return NotImplemented\n        return self.ts == other.ts\n\n    @property\n    def dt_(self) -> datetime.datetime:\n        \"\"\"생성일시를 datetime 객체로 반환합니다.\"\"\"\n        return datetime.datetime.strptime(self.dt, \"%Y-%m-%d %H:%M:%S\").replace(\n            tzinfo=ZoneInfo(\"Asia/Seoul\")\n        )\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"생성일시를 date 객체로 반환합니다.\"\"\"\n        return self.dt_.date()\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.user_id,\n            self.username,\n            self.title,\n            self.content_url,\n            self.dt,\n            self.category,\n            self.description,\n            self.type,\n            self.tags,\n            self.curation_flag,\n            self.ts,\n            self.feedback_intensity,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.user_id,\n            self.username,\n            self.title,\n            self.content_url,\n            self.dt,\n            self.category,\n            self.description,\n            self.type,\n            self.tags,\n            self.curation_flag,\n            self.ts,\n            self.feedback_intensity,\n        ]\n\n    def get_round(self) -> int:\n        \"\"\"컨텐츠의 회차를 반환합니다.\"\"\"\n        for i, due_date in enumerate(DUE_DATES):\n            if self.date <= due_date:\n                return i\n        raise BotException(\"글또 활동 기간이 아니에요.\")\n\n    @classmethod\n    def fieldnames(self) -> list[str]:\n        return [\n            \"user_id\",\n            \"username\",\n            \"title\",\n            \"content_url\",\n            \"dt\",\n            \"category\",\n            \"description\",\n            \"type\",\n            \"tags\",\n            \"curation_flag\",\n            \"ts\",\n            \"feedback_intensity\",\n        ]\n\n\nclass BookmarkStatusEnum(str, Enum):\n    ACTIVE = \"ACTIVE\"\n    DELETED = \"DELETED\"\n\n\nclass Bookmark(StoreModel):\n    user_id: str\n    content_user_id: str\n    content_ts: str  # content fk 역할을 한다.\n    note: str = \"\"\n    status: BookmarkStatusEnum = BookmarkStatusEnum.ACTIVE\n    created_at: str = Field(default_factory=tz_now_to_str)\n    updated_at: str = Field(default_factory=tz_now_to_str)\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.user_id,\n            self.content_user_id,\n            self.content_ts,\n            self.note,\n            self.status,\n            self.created_at,\n            self.updated_at,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.user_id,\n            self.content_user_id,\n            self.content_ts,\n            self.note,\n            self.status,\n            self.created_at,\n            self.updated_at,\n        ]\n\n\nclass CoffeeChatProof(StoreModel):\n    ts: str  # id\n    thread_ts: str = \"\"  # 스레드로 인증한 경우 상위 id 추가\n    user_id: str\n    text: str\n    image_urls: str = \"\"  # url1,url2,url3 형태\n    selected_user_ids: str = \"\"  # id1,id2,id3 형태\n    participant_call_thread_ts: str = \"\"  # 커피챗 참여자 호출 스레드 id\n    created_at: str = Field(default_factory=tz_now_to_str)\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.ts,\n            self.thread_ts,\n            self.user_id,\n            self.text,\n            self.image_urls,\n            self.selected_user_ids,\n            self.participant_call_thread_ts,\n            self.created_at,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.ts,\n            self.thread_ts,\n            self.user_id,\n            self.text,\n            self.image_urls,\n            self.selected_user_ids,\n            self.participant_call_thread_ts,\n            self.created_at,\n        ]\n\n    @classmethod\n    def fieldnames(self) -> list[str]:\n        return [\n            \"ts\",\n            \"thread_ts\",\n            \"user_id\",\n            \"text\",\n            \"image_urls\",\n            \"selected_user_ids\",\n            \"participant_call_thread_ts\",\n            \"created_at\",\n        ]\n\n\nclass PointCategory(str, Enum):\n    WRITING = \"글쓰기\"\n    NETWORKING = \"네트워크\"\n    USER_TO_USER = \"유저 간\"\n    OTHER = \"기타\"\n\n\nclass PointHistory(BaseModel):\n    id: str = Field(default_factory=generate_unique_id)\n    user_id: str\n    reason: str\n    point: int\n    category: PointCategory | str\n    created_at: str = Field(default_factory=tz_now_to_str)\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.id,\n            self.user_id,\n            self.reason,\n            str(self.point),\n            self.category,\n            self.created_at,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.id,\n            self.user_id,\n            self.reason,\n            str(self.point),\n            self.category,\n            self.created_at,\n        ]\n\n    @classmethod\n    def fieldnames(self) -> list[str]:\n        return [\n            \"id\",\n            \"user_id\",\n            \"reason\",\n            \"point\",\n            \"category\",\n            \"created_at\",\n        ]\n\n\nclass PaperPlane(StoreModel):\n    id: str = Field(default_factory=generate_unique_id)\n    sender_id: str\n    sender_name: str\n    receiver_id: str\n    receiver_name: str\n    text: str\n    text_color: str\n    bg_color: str\n    color_label: str\n    created_at: str = Field(default_factory=tz_now_to_str)\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.id,\n            self.sender_id,\n            self.sender_name,\n            self.receiver_id,\n            self.receiver_name,\n            self.text,\n            self.text_color,\n            self.bg_color,\n            self.color_label,\n            self.created_at,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.id,\n            self.sender_id,\n            self.sender_name,\n            self.receiver_id,\n            self.receiver_name,\n            self.text,\n            self.text_color,\n            self.bg_color,\n            self.color_label,\n            self.created_at,\n        ]\n\n\nclass SubscriptionStatusEnum(str, Enum):\n    ACTIVE = \"ACTIVE\"\n    CANCELED = \"CANCELED\"\n\n\nclass Subscription(StoreModel):\n    id: str = Field(default_factory=generate_unique_id)\n    user_id: str\n    target_user_id: str\n    target_user_channel: str\n    status: SubscriptionStatusEnum = SubscriptionStatusEnum.ACTIVE\n    created_at: str = Field(default_factory=tz_now_to_str)\n    updated_at: str = \"\"\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.id,\n            self.user_id,\n            self.target_user_id,\n            self.target_user_channel,\n            self.status,\n            self.created_at,\n            self.updated_at,\n        ]\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.id,\n            self.user_id,\n            self.target_user_id,\n            self.target_user_channel,\n            self.status,\n            self.created_at,\n            self.updated_at,\n        ]\n"}
{"type": "source_file", "path": "app/slack/events/community.py", "content": "import asyncio\nimport requests\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom app.exception import BotException\nfrom app.models import User\nfrom app.slack_notification import send_point_noti_message\nfrom app.slack.services.base import SlackService\nfrom app.slack.services.point import PointService\nfrom app.slack.types import (\n    ActionBodyType,\n    CommandBodyType,\n    MessageBodyType,\n    ViewBodyType,\n)\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\nfrom slack_sdk.models.views import View\nfrom slack_sdk.models.blocks import (\n    SectionBlock,\n    MarkdownTextObject,\n    InputBlock,\n    UserMultiSelectElement,\n    ActionsBlock,\n    ContextBlock,\n    ButtonElement,\n    DividerBlock,\n)\nfrom app.config import settings\nfrom app.utils import dict_to_json_str, json_str_to_dict\n\n\nasync def handle_coffee_chat_message(\n    ack: AsyncAck,\n    body: MessageBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n    subtype: str | None,  # file_share, message_changed, None\n    is_thread: bool,\n    ts: str,\n) -> None:\n    \"\"\"커피챗 인증 메시지인지 확인하고, 인증 모달을 전송합니다.\"\"\"\n    await ack()\n\n    if not is_thread:\n        # 1초 대기하는 이유는 메시지 보다 더 먼저 전송 되어 오류가 발생할 수 있기 때문입니다.\n        await asyncio.sleep(1)\n        text = f\"<@{user.user_id}> 님 커피챗 인증을 시작하려면 아래 `커피챗 인증` 버튼을 눌러주세요.\\n만약 인증을 원치 않으시면 `안내 닫기` 버튼을 눌러주세요.\"\n        await client.chat_postEphemeral(\n            user=user.user_id,\n            channel=body[\"event\"][\"channel\"],\n            text=text,\n            blocks=[\n                SectionBlock(text=text),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"안내 닫기\",\n                            action_id=\"cancel_coffee_chat_proof_button\",\n                        ),\n                        ButtonElement(\n                            text=\"커피챗 인증\",\n                            action_id=\"submit_coffee_chat_proof_button\",\n                            value=ts,\n                            style=\"primary\",\n                        ),\n                    ]\n                ),\n            ],\n        )\n        return\n\n    # 인증글에 답글로 커피챗 인증을 하는 경우\n    if is_thread and subtype != \"message_changed\":\n        try:\n            service.check_coffee_chat_proof(\n                thread_ts=str(body[\"event\"][\"thread_ts\"]),\n                user_id=body[\"event\"][\"user\"],\n            )\n        except BotException:\n            # 이 에러는 인증 글에 대한 답글이 아니거나 이미 인증한 경우, 인증 대상이 아닌 경우임.\n            return\n\n        service.create_coffee_chat_proof(\n            ts=str(body[\"event\"][\"ts\"]),\n            thread_ts=str(body[\"event\"][\"thread_ts\"]),\n            user_id=body[\"event\"][\"user\"],\n            text=body[\"event\"][\"text\"],\n            files=body[\"event\"].get(\"files\", []),  # type: ignore\n            selected_user_ids=\"\",\n        )\n\n        await client.reactions_add(\n            channel=body[\"event\"][\"channel\"],\n            timestamp=body[\"event\"][\"ts\"],\n            name=\"white_check_mark\",\n        )\n\n        # 댓글 인증 포인트 지급\n        text = point_service.grant_if_coffee_chat_verified(\n            user_id=body[\"event\"][\"user\"]\n        )\n        await send_point_noti_message(\n            client=client, channel=body[\"event\"][\"user\"], text=text\n        )\n        return\n\n\nasync def cancel_coffee_chat_proof_button(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"커피챗 인증 안내를 닫습니다.\"\"\"\n    await ack()\n\n    requests.post(\n        body[\"response_url\"],\n        json={\n            \"response_type\": \"ephemeral\",\n            \"delete_original\": True,\n        },\n        timeout=5.0,\n    )\n\n\nasync def submit_coffee_chat_proof_button(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"커피챗 인증을 제출합니다.\"\"\"\n    await ack()\n\n    private_metadata = dict_to_json_str(\n        {\n            \"ephemeral_url\": body[\"response_url\"],\n            \"message_ts\": body[\"actions\"][0][\"value\"],\n        }\n    )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=\"커피챗 인증\",\n            submit=\"커피챗 인증하기\",\n            callback_id=\"submit_coffee_chat_proof_view\",\n            private_metadata=private_metadata,\n            blocks=[\n                SectionBlock(\n                    text=\":coffee: 커피챗에 참여한 멤버들을 모두 선택해주세요.\"\n                ),\n                ContextBlock(\n                    elements=[\n                        MarkdownTextObject(\n                            text=\"멤버 인력란을 한 번 더 누르면 멤버를 검색할 수 있어요.\\n모바일에서 멤버가 검색되지 않는다면 데스크탑에서 진행해주세요.\"\n                        )\n                    ]\n                ),\n                InputBlock(\n                    block_id=\"participant\",\n                    label=\"커피챗 참여 멤버\",\n                    optional=False,\n                    element=UserMultiSelectElement(\n                        action_id=\"select\",\n                        placeholder=\"참여한 멤버들을 모두 선택해주세요.\",\n                        initial_users=[user.user_id],\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def submit_coffee_chat_proof_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    say: AsyncSay,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"커피챗 인증을 처리합니다.\"\"\"\n    selected_users = body[\"view\"][\"state\"][\"values\"][\"participant\"][\"select\"][\n        \"selected_users\"\n    ]\n    if len(selected_users) < 2:\n        await ack(\n            response_action=\"errors\",\n            errors={\n                \"participant\": \"커피챗 인증은 본인 포함 최소 2명 이상의 멤버를 선택해야 합니다.\"\n            },\n        )\n        return\n\n    await ack()\n\n    private_metadata = json_str_to_dict(body[\"view\"][\"private_metadata\"])\n    ephemeral_url = private_metadata[\"ephemeral_url\"]\n    message_ts = private_metadata[\"message_ts\"]\n\n    history = await client.conversations_history(\n        channel=settings.COFFEE_CHAT_PROOF_CHANNEL,\n        latest=message_ts,\n        limit=1,\n        inclusive=True,\n    )\n    message = history[\"messages\"][0]\n\n    await client.reactions_add(\n        channel=settings.COFFEE_CHAT_PROOF_CHANNEL,\n        timestamp=message_ts,\n        name=\"white_check_mark\",\n    )\n\n    # 포인트 지급\n    text = point_service.grant_if_coffee_chat_verified(user_id=user.user_id)\n    await send_point_noti_message(client=client, channel=user.user_id, text=text)\n\n    participant_call_text = \",\".join(\n        f\"<@{selected_user}>\"\n        for selected_user in selected_users\n        if selected_user != user.user_id  # 본인 제외\n    )\n\n    participant_call_thread_ts = \"\"\n    if participant_call_text:\n        res = await client.chat_postMessage(\n            channel=settings.COFFEE_CHAT_PROOF_CHANNEL,\n            thread_ts=message_ts,\n            text=f\"{participant_call_text} \\n\\n커피챗 인증을 위해 스레드로 후기를 남겨주세요. 인증이 확인된 멤버는 ✅가 표시돼요.\\n\\n커피챗 인증 내역은 <@{settings.TTOBOT_USER_ID}> 의 `홈` 탭 -> `내 커피챗 인증 내역 보기` 버튼을 통해 확인할 수 있어요.\",\n        )\n        participant_call_thread_ts = res.get(\"ts\", \"\")\n\n    service.create_coffee_chat_proof(\n        ts=message_ts,\n        thread_ts=\"\",\n        user_id=user.user_id,\n        text=message[\"text\"],\n        files=message.get(\"files\", []),\n        selected_user_ids=\",\".join(\n            selected_user\n            for selected_user in selected_users\n            if selected_user != user.user_id\n        ),\n        participant_call_thread_ts=participant_call_thread_ts,\n    )\n\n    # 나에게만 표시 메시지 수정하는 요청(slack bolt 에서는 지원하지 않음)\n    requests.post(\n        ephemeral_url,\n        json={\n            \"response_type\": \"ephemeral\",\n            \"delete_original\": True,\n        },\n        timeout=5.0,\n    )\n\n\nasync def paper_plane_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"종이비행기 명령을 처리합니다.\"\"\"\n    await ack()\n\n    remain_paper_planes: str | int\n    if user.user_id == settings.SUPER_ADMIN:\n        remain_paper_planes = \"∞\"\n    else:\n        remain_paper_planes = \"∞\"\n        # paper_planes = service.fetch_current_week_paper_planes(user_id=user.user_id)\n        # remain_paper_planes = 7 - len(paper_planes) if len(paper_planes) < 7 else 0\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            callback_id=\"paper_plane_command\",\n            title={\"type\": \"plain_text\", \"text\": \"종이비행기\"},\n            blocks=[\n                SectionBlock(text=\"✈️ *종이비행기란?*\"),\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": (\n                                \"종이비행기는 글또 멤버에게 따뜻한 감사나 응원의 메시지를 보낼 수 있는 기능이에요.\\n\"\n                                # \"매주 토요일 0시에 7개가 충전되며, 한 주 동안 자유롭게 원하는 분께 보낼 수 있어요.\\n\"\n                                f\"*{user.name[1:]}* 님이 이번 주에 보낼 수 있는 종이비행기 수는 현재 *{remain_paper_planes}개* 입니다.\"\n                            ),\n                        }\n                    ]\n                ),\n                DividerBlock(),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"종이비행기 보내기\",\n                            action_id=\"send_paper_plane_message\",\n                            style=\"primary\",\n                        ),\n                        ButtonElement(\n                            text=\"주고받은 종이비행기 보기\",\n                            action_id=\"open_paper_plane_url\",\n                            url=\"https://geultto-paper-plane.vercel.app\",\n                        ),\n                    ]\n                ),\n                DividerBlock(),\n                # 사용 방법 안내\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*✍️ 어떤 내용을 보내면 좋을까요?*\",\n                    }\n                ),\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": \"종이비행기 메시지를 작성할 때는 아래 내용을 참고해보세요. 😉\\n\\n\"\n                            \"*`구체적인 상황`* - 어떤 활동이나 대화에서 고마움을 느꼈는지 이야기해요.\\n\"\n                            \"*`구체적인 내용`* - 그 사람이 어떤 도움을 줬거나, 어떤 말을 해줬는지 적어보세요.\\n\"\n                            \"*`효과와 감사 표현`* - 그 행동이 나에게 어떤 영향을 주었는지, 얼마나 감사한지 표현해요.\\n\"\n                            \"*`앞으로의 기대`* - 앞으로도 계속 함께해주길 바라는 마음을 전해보세요!\",\n                        }\n                    ]\n                ),\n                DividerBlock(),\n                # 예시 메시지\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*💌 종이비행기 메시지 예시*\\n\",\n                    }\n                ),\n                # 예시 1: 스터디 활동\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": '예시 1: 스터디 활동\\n>\"00 스터디에서 항상 열정적으로 참여해주셔서 정말 감사해요! 덕분에 저도 더 열심히 하게 되고, 많은 배움을 얻고 있어요. 앞으로도 함께 성장해나갈 수 있으면 좋겠어요! 😊\"',\n                        }\n                    ]\n                ),\n                # 예시 2: 커피챗 대화\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": '예시 2: 커피챗 대화\\n>\"지난번 커피챗에서 나눈 대화가 정말 인상 깊었어요. 개발에 대한 생각을 나누고 조언을 주셔서 고맙습니다! 다음에도 또 이런 기회가 있으면 좋겠네요!\"',\n                        }\n                    ]\n                ),\n                # 예시 3: 반상회 발표\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": '예시 3: 반상회 발표\\n>\"최근 반상회에서 발표하신 모습이 인상적이었어요! 멀리서 지켜보면서 많은 영감을 받았답니다. 😊 나중에 기회가 된다면 커피챗으로 더 깊게 이야기를 나눌 수 있으면 좋겠어요!\"',\n                        }\n                    ]\n                ),\n                DividerBlock(),\n                # 가이드 마무리\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": \"이제 진심을 담은 메시지를 종이비행기로 전달해보세요! ✈️\",\n                        }\n                    ]\n                ),\n            ],\n        ),\n    )\n"}
{"type": "source_file", "path": "app/slack/events/contents.py", "content": "import csv\nimport re\n\nimport pandas as pd\n\nfrom app.slack_notification import send_point_noti_message\nfrom app.slack.components import static_select\nfrom app.constants import MAX_PASS_COUNT, ContentCategoryEnum\nfrom app.exception import BotException, ClientException\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom slack_sdk.models.views import View\nfrom slack_sdk.models.blocks import (\n    Block,\n    SectionBlock,\n    InputBlock,\n    PlainTextInputElement,\n    ContextBlock,\n    MarkdownTextObject,\n    DividerBlock,\n    OverflowMenuElement,\n    Option,\n    ActionsBlock,\n    ButtonElement,\n    StaticSelectElement,\n    UrlInputElement,\n)\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\n\nfrom app import models, store\nfrom app.slack.services.base import SlackService\nfrom app.slack.services.point import PointService\nfrom app.slack.types import (\n    ActionBodyType,\n    BlockActionBodyType,\n    CommandBodyType,\n    OverflowActionBodyType,\n    ViewBodyType,\n    ViewType,\n)\nfrom app.utils import dict_to_json_str, json_str_to_dict, tz_now_to_str\nfrom app.config import settings\n\n\nasync def submit_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"글 제출 시작\"\"\"\n    await ack()\n    callback_id = \"submit_view\"\n\n    # 어드민 유저는 제출하는 곳에 메세지가 전송됩니다.\n    private_metadata = (\n        body[\"channel_id\"] if user.user_id in settings.ADMIN_IDS else user.channel_id\n    )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            private_metadata=private_metadata,\n            callback_id=callback_id,\n            title=\"또봇\",\n            submit=\"제출\",\n            blocks=[\n                SectionBlock(\n                    block_id=\"required_section\",\n                    text=user.submission_guide_message,\n                ),\n                InputBlock(\n                    block_id=\"content_url\",\n                    label=\"글 링크\",\n                    element=UrlInputElement(\n                        action_id=\"url_text_input-action\",\n                        placeholder=\"노션 링크는 하단 '글 제목'을 필수로 입력해주세요.\",\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"category\",\n                    label=\"카테고리\",\n                    element=StaticSelectElement(\n                        action_id=\"category_select\",\n                        placeholder=\"글의 카테고리를 선택해주세요.\",\n                        options=static_select.options(\n                            [category.value for category in ContentCategoryEnum]\n                        ),\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"curation\",\n                    label=\"큐레이션\",\n                    element=StaticSelectElement(\n                        action_id=\"curation_select\",\n                        placeholder=\"글을 큐레이션 대상에 포함할까요?\",\n                        options=[\n                            Option(text=\"큐레이션 대상이 되고 싶어요!\", value=\"Y\"),\n                            Option(text=\"아직은 부끄러워요~\", value=\"N\"),\n                        ],\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"feedback_intensity\",\n                    label=\"피드백 강도\",\n                    element=StaticSelectElement(\n                        action_id=\"feedback_intensity_select\",\n                        initial_option=Option(text=\"🧄 보통맛\", value=\"HOT\"),\n                        options=[\n                            Option(text=\"🌱 순한맛\", value=\"MILD\"),\n                            Option(text=\"🧄 보통맛\", value=\"HOT\"),\n                            Option(text=\"🌶️ 매운맛\", value=\"FIRE\"),\n                            Option(text=\"☠️ 지옥맛\", value=\"DIABLO\"),\n                        ],\n                    ),\n                ),\n                DividerBlock(),\n                InputBlock(\n                    block_id=\"tag\",\n                    label=\"태그\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"tags_input\",\n                        placeholder=\"태그1,태그2,태그3, ... \",\n                        multiline=False,\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"description\",\n                    label=\"하고 싶은 말\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"text_input\",\n                        placeholder=\"하고 싶은 말이 있다면 남겨주세요.\",\n                        multiline=True,\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"manual_title_input\",\n                    label=\"글 제목(직접 입력)\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"title_input\",\n                        placeholder=\"'글 제목'을 직접 입력합니다.\",\n                        multiline=False,\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def submit_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"글 제출 완료\"\"\"\n    # 슬랙 앱이 구 버전일 경우 일부 block 이 사라져 키에러가 발생할 수 있음\n    content_url = view[\"state\"][\"values\"][\"content_url\"][\"url_text_input-action\"][\n        \"value\"\n    ]\n    channel_id = view[\"private_metadata\"]\n    username = body[\"user\"][\"username\"]\n    is_submit = user.is_submit\n\n    try:\n        service.validate_url(view, content_url)\n        title = await service.get_title(view, content_url)\n    except (ValueError, ClientException) as e:\n        await ack(response_action=\"errors\", errors={\"content_url\": str(e)})\n        raise e\n\n    # 참고: ack 로 에러를 반환할 경우, 그전에 ack() 를 호출하지 않아야 한다.\n    await ack()\n\n    try:\n        content = await service.create_submit_content(\n            title,\n            content_url,\n            username,\n            view,  # type: ignore # TODO: 원자 값을 넘기도록 수정\n        )\n\n        # 해당 text 는 슬랙 활동 탭에서 표시되는 메시지이며, 누가 어떤 링크를 제출했는지 확인합니다. (alt_text 와 유사한 역할)\n        text = f\"*<@{content.user_id}>님 제출 완료.* 링크 : *<{content.content_url}|{re.sub('<|>', '', title if content.title != 'title unknown.' else content.content_url)}>*\"\n        message = await client.chat_postMessage(\n            channel=channel_id,\n            text=text,\n            blocks=[\n                SectionBlock(text=service.get_chat_message(content)),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"자기소개 보기\",\n                            action_id=\"intro_modal\",\n                            value=content.user_id,\n                        ),\n                        ButtonElement(\n                            text=\"이전 작성글 보기\",\n                            action_id=\"contents_modal\",\n                            value=content.user_id,\n                        ),\n                        ButtonElement(\n                            text=\"북마크 추가📌\",\n                            action_id=\"bookmark_modal\",\n                            value=dict_to_json_str(\n                                {\n                                    \"user_id\": content.user_id,\n                                    \"dt\": content.dt,\n                                }\n                            ),\n                        ),\n                        ButtonElement(\n                            text=\"멤버 구독하기🔔\",\n                            action_id=\"open_subscribe_member_view\",\n                            value=dict_to_json_str({\"target_user_id\": content.user_id}),\n                        ),\n                    ],\n                ),\n            ],\n        )\n        content.ts = message.get(\"ts\", \"\")\n\n        await service.update_user_content(content)\n\n    except Exception as e:\n        message = f\"{user.name}({user.channel_name}) 님의 제출이 실패했어요. {str(e)}\"  # type: ignore\n        raise BotException(message)  # type: ignore\n\n    # 포인트 지급 1. 글 제출 시 포인트 지급\n    submission_point_msg, is_additional = point_service.grant_if_post_submitted(\n        user_id=content.user_id, is_submit=is_submit\n    )\n    await send_point_noti_message(\n        client=client,\n        channel=content.user_id,\n        text=submission_point_msg,\n    )\n\n    # 추가 제출의 경우 연속 콤보, 채널 랭킹 포인트 지급을 하지 않는다.\n    if not is_additional:\n        # 포인트 지급 2.\n        combo_point_msg = point_service.grant_if_post_submitted_continuously(\n            user_id=content.user_id\n        )\n        if combo_point_msg:\n            await send_point_noti_message(\n                client=client,\n                channel=content.user_id,\n                text=combo_point_msg,\n            )\n\n        # 포인트 지급 3.\n        ranking_point_msg = (\n            point_service.grant_if_post_submitted_to_core_channel_ranking(\n                user_id=content.user_id\n            )\n        )\n        if ranking_point_msg:\n            await send_point_noti_message(\n                client=client,\n                channel=content.user_id,\n                text=ranking_point_msg,\n            )\n\n    if content.curation_flag == \"Y\":\n        # 포인트 지급 4. 큐레이션 대상 글 제출 시 포인트 지급\n        curation_point_msg = point_service.grant_if_curation_requested(\n            user_id=content.user_id\n        )\n        await send_point_noti_message(\n            client=client,\n            channel=content.user_id,\n            text=curation_point_msg,\n        )\n\n    if content.user_id == settings.SUPER_ADMIN:\n        _modify_super_admin_subscription_channel(channel_id, content.user_id)\n\n        # 슈퍼 어드민이 글을 제출한 경우 구독자들의 시트 데이터를 업데이트 한다.\n        subscriptions = service.fetch_subscriptions_by_target_user_id(content.user_id)\n        for subscription in subscriptions:\n            subscription.updated_at = tz_now_to_str()\n            store.subscription_update_queue.append(subscription.model_dump())\n\n\ndef _modify_super_admin_subscription_channel(channel_id: str, user_id: str) -> None:\n    # 슈퍼 어드민의 경우 subscriptions.csv 파일에서 target_user_channel 값을 현재 채널로 업데이트 한다.\n    # 이를 통해 슈퍼 어드민이 어느 채널에 글을 제출해도 구독자들에게 정확한 알림을 보낼 수 있게 한다.\n    df = pd.read_csv(\"store/subscriptions.csv\")\n    df.loc[df[\"target_user_id\"] == user_id, \"target_user_channel\"] = channel_id\n    df.to_csv(\"store/subscriptions.csv\", index=False, quoting=csv.QUOTE_ALL)\n\n\n# TODO: 방학기간에 담소에도 글을 보낼지에 대한 메시지 전송 로직\n# async def forward_message(\n#     ack: AsyncAck,\n#     body: ActionBodyType,\n#     client: AsyncWebClient,\n#     service: SlackService,\n#     point_service: PointService,\n# ) -> None:\n#     await ack()\n\n#     content_ts = body[\"actions\"][0][\"value\"]\n#     source_channel = body[\"channel\"][\"id\"]\n#     # target_channel = \"C05J4FGB154\"  # 자유로운 담소 채널 ID 테스트용\n#     target_channel = \"C0672HTT36C\"  # 자유로운 담소 채널 ID 운영용\n\n#     permalink_response = await client.chat_getPermalink(\n#         channel=source_channel, message_ts=content_ts\n#     )\n#     permalink = permalink_response[\"permalink\"]\n#     content = service.get_content_by(ts=content_ts)\n\n#     # 담소 채널에 보내는 메시지\n#     text = f\"<@{content.user_id}>님이 글을 공유했어요! \\n👉 *<{permalink}|{content.title}>*\"\n#     await client.chat_postMessage(channel=target_channel, text=text)\n\n#     # 나에게만 표시 메시지 수정하는 요청(slack bolt 에서는 지원하지 않음)\n#     requests.post(\n#         body[\"response_url\"],\n#         json={\n#             \"response_type\": \"ephemeral\",\n#             \"text\": f\"<#{target_channel}> 에 전송되었어요. 📨\",\n#             \"replace_original\": True,\n#             # \"delete_original\": True, # 삭제도 가능\n#         },\n#     )\n\n\nasync def open_intro_modal(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"다른 유저의 자기소개 확인\"\"\"\n    await ack()\n\n    other_user_id = body[\"actions\"][0][\"value\"]\n    other_user = service.get_user(other_user_id)\n    intro_text = other_user.intro.replace(\"\\\\n\", \"\\n\") or \"자기소개가 비어있어요. 😢\"\n\n    is_self = user.user_id == other_user_id\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{other_user.name}님의 소개\",\n            submit=\"자기소개 수정\" if is_self else None,\n            callback_id=\"edit_intro_view\" if is_self else None,\n            close=\"닫기\",\n            blocks=[SectionBlock(text=intro_text)],\n        ),\n    )\n\n\nasync def edit_intro_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"자기소개 수정 시작\"\"\"\n    await ack(\n        response_action=\"update\",\n        view=View(\n            type=\"modal\",\n            callback_id=\"submit_intro_view\",\n            title=\"자기소개 수정\",\n            submit=\"자기소개 제출\",\n            close=\"닫기\",\n            blocks=[\n                SectionBlock(text=\"자신만의 개성있는 소개문구를 남겨주세요. 😉\"),\n                InputBlock(\n                    block_id=\"description\",\n                    label=\"자기소개 내용\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"edit_intro\",\n                        multiline=True,\n                        max_length=2000,\n                        placeholder={\n                            \"type\": \"plain_text\",\n                            \"text\": f\"{user.intro[:100]} ... \",\n                        },\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def submit_intro_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"자기소개 수정 완료\"\"\"\n    new_intro = view[\"state\"][\"values\"][\"description\"][\"edit_intro\"][\"value\"] or \"\"\n    service.update_user_intro(user.user_id, new_intro=new_intro)\n\n    await ack(\n        {\n            \"response_action\": \"update\",\n            \"view\": {\n                \"type\": \"modal\",\n                \"callback_id\": \"submit_intro_view\",\n                \"title\": {\"type\": \"plain_text\", \"text\": \"자기소개 수정 완료\"},\n                \"close\": {\"type\": \"plain_text\", \"text\": \"닫기\"},\n                \"blocks\": [\n                    {\n                        \"type\": \"image\",\n                        \"image_url\": \"https://media1.giphy.com/media/g9582DNuQppxC/giphy.gif\",  # noqa E501\n                        \"alt_text\": \"success\",\n                    },\n                    {\n                        \"type\": \"rich_text\",  # rich_text 는 블록 객체로 사용할 수 없음\n                        \"elements\": [\n                            {\n                                \"type\": \"rich_text_section\",\n                                \"elements\": [\n                                    {\n                                        \"type\": \"text\",\n                                        \"text\": \"자기소개 수정이 완료되었습니다. 👏🏼👏🏼👏🏼\\n다시 [자기소개 보기] 버튼을 눌러 확인해보세요!\",  # noqa E501\n                                    }\n                                ],\n                            }\n                        ],\n                    },\n                ],\n            },\n        }\n    )\n\n\nasync def contents_modal(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"다른 유저의 제출한 글 목록 확인\"\"\"\n    await ack()\n\n    other_user_id = body[\"actions\"][0][\"value\"]\n    other_user = service.get_user(other_user_id)\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{other_user.name}님의 작성글\",\n            close=\"닫기\",\n            blocks=_fetch_blocks(other_user.contents[::-1]),\n        ),\n    )\n\n\nasync def bookmark_modal(\n    ack: AsyncAck,\n    body: BlockActionBodyType | OverflowActionBodyType,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"북마크 저장 시작\"\"\"\n    await ack()\n\n    # TODO: 글 검색에서 넘어온 경우 북마크 저장 후 검색 모달로 돌아가야 함\n\n    actions = body[\"actions\"][0]\n    is_overflow = actions[\"type\"] == \"overflow\"  # TODO: 분리필요\n    if is_overflow:\n        content_value = json_str_to_dict(actions[\"selected_option\"][\"value\"])  # type: ignore\n    else:\n        content_value = json_str_to_dict(actions[\"value\"])  # type: ignore\n\n    content = service.get_content_by(\n        user_id=content_value[\"user_id\"],\n        dt=content_value[\"dt\"],\n    )\n    bookmark = service.get_bookmark(user.user_id, content.ts)\n    if bookmark is not None:\n        # 이미 북마크가 되어 있다면 사용자에게 알린다.\n        view = View(\n            type=\"modal\",\n            title=\"북마크\",\n            close=\"닫기\",\n            blocks=[SectionBlock(text=\"\\n이미 북마크한 글이에요. 😉\")],\n        )\n    else:\n        view = View(\n            type=\"modal\",\n            private_metadata=dict_to_json_str(\n                {\n                    \"content_user_id\": content.user_id,\n                    \"content_ts\": content.ts,\n                }\n            ),\n            callback_id=\"bookmark_view\",\n            title=\"북마크\",\n            submit=\"북마크 추가\",\n            blocks=[\n                SectionBlock(\n                    block_id=\"required_section\",\n                    text=\"\\n북마크한 글은 `/북마크` 명령어로 확인할 수 있어요.\",\n                ),\n                InputBlock(\n                    block_id=\"bookmark_note\",\n                    label=\"메모\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"text_input\",\n                        placeholder=\"북마크에 대한 메모를 남겨주세요.\",\n                        multiline=True,\n                    ),\n                ),\n            ],\n        )\n\n    if is_overflow:\n        await client.views_update(view_id=body[\"view\"][\"id\"], view=view)  # type: ignore\n    else:\n        await client.views_open(trigger_id=body[\"trigger_id\"], view=view)\n\n\nasync def create_bookmark_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"북마크 저장 완료\"\"\"\n    await ack()\n\n    private_metadata = json_str_to_dict(view[\"private_metadata\"])\n    content_user_id = private_metadata[\"content_user_id\"]\n    content_ts = private_metadata[\"content_ts\"]\n\n    value = view[\"state\"][\"values\"][\"bookmark_note\"][\"text_input\"][\"value\"]\n    note = value if value else \"\"  # 유저가 입력하지 않으면 None 으로 전달 된다.\n    service.create_bookmark(\n        user_id=user.user_id,\n        content_user_id=content_user_id,\n        content_ts=content_ts,\n        note=note,\n    )\n\n    await ack(\n        response_action=\"update\",\n        view=View(\n            type=\"modal\",\n            title=\"북마크\",\n            close=\"닫기\",\n            blocks=[SectionBlock(text=\"\\n북마크를 추가했어요. 😉\")],\n        ),\n    )\n\n\nasync def pass_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"글 패스 시작\"\"\"\n    await ack()\n\n    round, due_date = user.get_due_date()\n    user.check_pass()\n\n    # 어드민 유저는 제출하는 곳에 메세지가 전송됩니다.\n    private_metadata = (\n        body[\"channel_id\"] if user.user_id in settings.ADMIN_IDS else user.channel_id\n    )\n\n    if user.is_submit:\n        await client.views_open(\n            trigger_id=body[\"trigger_id\"],\n            view=View(\n                type=\"modal\",\n                title=\"패스\",\n                close=\"닫기\",\n                blocks=[\n                    SectionBlock(\n                        text=f\"🤗 {user.name} 님은 이미 {round}회차 (마감일: {due_date}) 글을 제출했어요.\\n`/제출내역` 명령어로 글 제출 내역을 확인해주세요.\"\n                    )\n                ],\n            ),\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            private_metadata=private_metadata,\n            callback_id=\"pass_view\",\n            title=\"또봇\",\n            submit=\"패스\",\n            blocks=[\n                SectionBlock(\n                    block_id=\"required_section\",\n                    text=f\"패스 하려면 아래 '패스' 버튼을 눌러주세요.\\\n                        \\n\\n아래 유의사항을 확인해주세요.\\\n                        \\n- 현재 회차는 {round}회차, 마감일은 {due_date} 이에요.\\\n                        \\n- 패스는 연속으로 사용할 수 없어요.\\\n                        \\n- 남은 패스는 {MAX_PASS_COUNT - user.pass_count}번 이에요.\\\n                        \\n- 패스 메시지는 코어 채널인 <#{user.channel_id}> 채널에 표시됩니다.\",\n                ),\n                InputBlock(\n                    block_id=\"description\",\n                    optional=True,\n                    label=\"하고 싶은 말\",\n                    element=PlainTextInputElement(\n                        action_id=\"text_input\",\n                        placeholder=\"하고 싶은 말이 있다면 남겨주세요.\",\n                        multiline=True,\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def pass_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"글 패스 완료\"\"\"\n    await ack()\n\n    channel_id = view[\"private_metadata\"]\n\n    try:\n        content = await service.create_pass_content(ack, body, view)\n        message = await client.chat_postMessage(\n            channel=channel_id,\n            text=service.get_chat_message(content),\n        )\n        content.ts = message.get(\"ts\", \"\")\n        await service.update_user_content(content)\n    except Exception as e:\n        message = f\"{user.name}({user.channel_name}) 님의 패스가 실패했어요. {str(e)}\"  # type: ignore\n        raise BotException(message)  # type: ignore\n\n\nasync def search_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"글 검색 시작\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=_get_search_view(),\n    )\n\n\nasync def submit_search(\n    ack: AsyncAck,\n    body: ViewBodyType | ActionBodyType,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"글 검색 완료\"\"\"\n    name = _get_name(body)\n    category = _get_category(body)\n    keyword = _get_keyword(body)\n\n    contents = service.fetch_contents(keyword, name, category)\n\n    await ack(\n        response_action=\"update\",\n        view=View(\n            type=\"modal\",\n            callback_id=\"back_to_search_view\",\n            title=f\"총 {len(contents)} 개의 글이 있어요. 🔍\",\n            submit=\"다시 검색\",\n            blocks=_fetch_blocks(contents),\n        ),\n    )\n\n\nasync def web_search(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"웹 검색 시작(외부 링크로 이동)\"\"\"\n    await ack()\n\n\ndef _fetch_blocks(contents: list[models.Content]) -> list[Block]:\n    blocks: list[Block] = []\n    blocks.append(SectionBlock(text=\"결과는 최대 20개까지만 표시해요.\"))\n    for content in contents:\n\n        if not content.content_url:\n            # content_url 이 없는 경우는 패스이므로 제외\n            continue\n\n        blocks.append(DividerBlock())\n        blocks.append(\n            SectionBlock(\n                text=f\"*<{content.content_url}|{re.sub('<|>', '', content.title)}>*\",\n                accessory=OverflowMenuElement(\n                    action_id=\"bookmark_modal\",\n                    options=[\n                        Option(\n                            text=\"북마크 추가📌\",\n                            value=dict_to_json_str(\n                                {\n                                    \"user_id\": content.user_id,\n                                    \"dt\": content.dt,\n                                }\n                            ),\n                        )\n                    ],\n                ),\n            )\n        )\n        blocks.append(\n            ContextBlock(\n                elements=[\n                    MarkdownTextObject(text=f\"> 카테고리: {content.category}\"),\n                    MarkdownTextObject(\n                        text=f\"> 태그: {content.tags}\" if content.tags else \" \"\n                    ),\n                ]\n            )\n        )\n        if len(blocks) > 60:\n            # 최대 60개의 블록만 반환\n            # 그 이상은 Slack Modal 제한에 걸릴 수 있음\n            return blocks\n    return blocks\n\n\nasync def back_to_search_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"글 검색 다시 시작\"\"\"\n    await ack(\n        response_type=\"update\",\n        view=_get_search_view(),\n    )\n\n\ndef _get_category(body):\n    category = (\n        body.get(\"view\", {})\n        .get(\"state\", {})\n        .get(\"values\", {})\n        .get(\"category_search\", {})\n        .get(\"chosen_category\", {})\n        .get(\"selected_option\", {})\n        .get(\"value\", \"전체\")\n    )\n    return category\n\n\ndef _get_name(body) -> str:\n    name = (\n        body.get(\"view\", {})\n        .get(\"state\", {})\n        .get(\"values\", {})\n        .get(\"author_search\", {})\n        .get(\"author_name\", {})\n        .get(\"value\", \"\")\n    )\n    return name\n\n\ndef _get_keyword(body) -> str:\n    keyword = (\n        body.get(\"view\", {})\n        .get(\"state\", {})\n        .get(\"values\", {})\n        .get(\"keyword_search\", {})\n        .get(\"keyword\", {})\n        .get(\"value\", \"\")\n    ) or \"\"\n    return keyword\n\n\nasync def bookmark_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"북마크 조회\"\"\"\n    await ack()\n\n    bookmarks = service.fetch_bookmarks(user.user_id)\n    content_ids = [bookmark.content_ts for bookmark in bookmarks]\n    contents = service.fetch_contents_by_ids(content_ids)\n    content_matrix = _get_content_metrix(contents)\n\n    view = View(\n        type=\"modal\",\n        title=f\"총 {len(contents)} 개의 북마크가 있어요.\",\n        blocks=_fetch_bookmark_blocks(content_matrix, bookmarks),\n        callback_id=\"handle_bookmark_page_view\",\n        private_metadata=dict_to_json_str({\"page\": 1}),\n    )\n\n    if len(content_matrix) > 1:\n        view.blocks.append(\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"다음 페이지\",\n                        style=\"primary\",\n                        action_id=\"next_bookmark_page_action\",\n                    )\n                ]\n            )\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=view,\n    )\n\n\nasync def bookmark_page_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"북마크 조회\"\"\"\n    await ack()\n\n    bookmarks = service.fetch_bookmarks(user.user_id)\n    content_ids = [bookmark.content_ts for bookmark in bookmarks]\n    contents = service.fetch_contents_by_ids(content_ids)\n    content_matrix = _get_content_metrix(contents)\n\n    view = View(\n        type=\"modal\",\n        title=f\"총 {len(contents)} 개의 북마크가 있어요.\",\n        blocks=_fetch_bookmark_blocks(content_matrix, bookmarks),\n        callback_id=\"handle_bookmark_page_view\",\n        private_metadata=dict_to_json_str({\"page\": 1}),\n    )\n\n    if len(content_matrix) > 1:\n        view.blocks.append(\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"다음 페이지\",\n                        style=\"primary\",\n                        action_id=\"next_bookmark_page_action\",\n                    )\n                ]\n            )\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=view,\n    )\n\n\nasync def handle_bookmark_page(\n    ack: AsyncAck,\n    body: ViewBodyType | OverflowActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"북마크 페이지 이동\"\"\"\n    await ack()\n\n    bookmarks = service.fetch_bookmarks(user.user_id)\n    content_ids = [bookmark.content_ts for bookmark in bookmarks]\n    contents = service.fetch_contents_by_ids(content_ids)\n    content_matrix = _get_content_metrix(contents)\n    action_id = body[\"actions\"][0][\"action_id\"] if body.get(\"actions\") else None  # type: ignore\n    private_metadata = body.get(\"view\", {}).get(\"private_metadata\")\n    page = json_str_to_dict(private_metadata).get(\"page\", 1) if private_metadata else 1\n\n    if action_id == \"next_bookmark_page_action\":\n        page += 1\n    elif action_id == \"prev_bookmark_page_action\":\n        page -= 1\n\n    view = View(\n        type=\"modal\",\n        title=f\"총 {len(contents)} 개의 북마크가 있어요.\",\n        blocks=_fetch_bookmark_blocks(content_matrix, bookmarks, page=page),\n        callback_id=\"handle_bookmark_page_view\",\n        private_metadata=dict_to_json_str({\"page\": page}),\n    )\n\n    button_elements = []\n    if page != 1:\n        button_elements.append(\n            ButtonElement(\n                text=\"이전 페이지\",\n                style=\"primary\",\n                action_id=\"prev_bookmark_page_action\",\n            )\n        )\n    if len(content_matrix) > page:\n        button_elements.append(\n            ButtonElement(\n                text=\"다음 페이지\",\n                style=\"primary\",\n                action_id=\"next_bookmark_page_action\",\n            )\n        )\n\n    if button_elements:\n        view.blocks.append(ActionsBlock(elements=button_elements))\n\n    if body[\"type\"] == \"block_actions\":\n        await client.views_update(\n            view_id=body[\"view\"][\"id\"],\n            view=view,\n        )\n    else:\n        await client.views_open(\n            trigger_id=body[\"trigger_id\"],\n            view=view,\n        )\n\n\ndef _fetch_bookmark_blocks(\n    content_matrix: dict[int, list[models.Content]],\n    bookmarks: list[models.Bookmark],\n    page: int = 1,\n) -> list[Block]:\n    blocks: list[Block] = []\n    blocks.append(SectionBlock(text=f\"{len(content_matrix)} 페이지 중에 {page} 페이지\"))\n    for content in content_matrix.get(page, []):\n\n        if not content.content_url:\n            # content_url 이 없는 경우는 패스이므로 제외\n            continue\n\n        blocks.append(DividerBlock())\n        blocks.append(\n            SectionBlock(\n                text=f\"*<{content.content_url}|{re.sub('<|>', '', content.title)}>*\",\n                accessory=OverflowMenuElement(\n                    action_id=\"bookmark_overflow_action\",\n                    options=[\n                        Option(\n                            value=dict_to_json_str(\n                                {\n                                    \"action\": \"remove_bookmark\",\n                                    \"content_ts\": content.ts,\n                                }\n                            ),\n                            text=\"북마크 취소📌\",\n                        ),\n                        Option(\n                            value=dict_to_json_str(\n                                {\n                                    \"action\": \"view_note\",\n                                    \"content_ts\": content.ts,\n                                }\n                            ),\n                            text=\"메모 보기✏️\",\n                        ),\n                    ],\n                ),\n            )\n        )\n\n        note = [\n            bookmark.note for bookmark in bookmarks if content.ts == bookmark.content_ts\n        ][0]\n        blocks.append(\n            ContextBlock(elements=[MarkdownTextObject(text=f\"\\n> 메모: {note}\")])\n        )\n\n        if len(blocks) > 60:\n            # 최대 60개의 블록만 반환\n            # 그 이상은 Slack Modal 제한에 걸릴 수 있음\n            return blocks\n\n    return blocks\n\n\nasync def open_overflow_action(\n    ack: AsyncAck,\n    body: OverflowActionBodyType,\n    client: AsyncWebClient,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"북마크 메뉴 선택\"\"\"\n    await ack()\n\n    title = \"\"\n    text = \"\"\n    value = json_str_to_dict(body[\"actions\"][0][\"selected_option\"][\"value\"])\n    if value[\"action\"] == \"remove_bookmark\":\n        title = \"북마크 취소📌\"\n        service.update_bookmark(\n            user.user_id,\n            value[\"content_ts\"],\n            new_status=models.BookmarkStatusEnum.DELETED,\n        )\n        text = \"북마크를 취소했어요.\"\n    elif value[\"action\"] == \"view_note\":\n        title = \"북마크 메모✏️\"\n        bookmark = service.get_bookmark(user.user_id, value[\"content_ts\"])\n        text = bookmark.note if bookmark and bookmark.note else \"메모가 없어요.\"\n\n    await client.views_update(\n        view_id=body[\"view\"][\"id\"],\n        view=View(\n            type=\"modal\",\n            callback_id=\"handle_bookmark_page_view\",\n            private_metadata=body[\"view\"][\"private_metadata\"],  # example: {\"page\": 1}\n            title=title,\n            submit=\"돌아가기\",\n            blocks=[SectionBlock(text=text)],\n        ),\n    )\n\n\ndef _get_content_metrix(\n    contents: list[models.Content], contents_per_page: int = 20\n) -> dict[int, list[models.Content]]:\n    \"\"\"컨텐츠를 2차원 배열로 변환합니다.\"\"\"\n\n    content_matrix = {}\n    for i, v in enumerate(range(0, len(contents), contents_per_page)):\n        content_matrix.update({i + 1: contents[v : v + contents_per_page]})\n    return content_matrix\n\n\ndef _get_search_view():\n    return View(\n        type=\"modal\",\n        callback_id=\"submit_search\",\n        title=\"글 검색 🔍\",\n        submit=\"검색\",\n        blocks=[\n            SectionBlock(\n                block_id=\"description_section\",\n                text=\"원하는 조건의 글을 검색할 수 있어요.\",\n            ),\n            InputBlock(\n                block_id=\"keyword_search\",\n                label=\"검색어\",\n                optional=True,\n                element=PlainTextInputElement(\n                    action_id=\"keyword\",\n                    placeholder=\"검색어를 입력해주세요.\",\n                    multiline=False,\n                ),\n            ),\n            InputBlock(\n                block_id=\"author_search\",\n                label=\"글 작성자\",\n                optional=True,\n                element=PlainTextInputElement(\n                    action_id=\"author_name\",\n                    placeholder=\"이름을 입력해주세요.\",\n                    multiline=False,\n                ),\n            ),\n            InputBlock(\n                block_id=\"category_search\",\n                label=\"카테고리\",\n                element=StaticSelectElement(\n                    action_id=\"chosen_category\",\n                    placeholder=\"카테고리 선택\",\n                    initial_option=Option(value=\"전체\", text=\"전체\"),\n                    options=static_select.options(\n                        [category.value for category in ContentCategoryEnum] + [\"전체\"]\n                    ),\n                ),\n            ),\n            SectionBlock(\n                text=\"웹으로 검색하시려면 [웹 검색] 버튼을 눌러주세요.\",\n                accessory=ButtonElement(\n                    text=\"웹 검색\",\n                    action_id=\"web_search\",\n                    url=\"https://vvd.bz/d2HG\",\n                    style=\"primary\",\n                ),\n            ),\n        ],\n    )\n"}
{"type": "source_file", "path": "app/slack/types.py", "content": "from typing import TypedDict\n\n\nclass AppMentionEvent(TypedDict):\n    user: str\n    type: str\n    ts: str\n    client_msg_id: str\n    text: str\n    team: str\n    blocks: list[dict]\n    channel: str\n    event_ts: str\n\n\nclass Authorization(TypedDict):\n    enterprise_id: str\n    team_id: str\n    user_id: str\n    is_bot: bool\n    is_enterprise_install: bool\n\n\nclass AppMentionBodyType(TypedDict):\n    token: str\n    team_id: str\n    api_app_id: str\n    event: AppMentionEvent\n    type: str\n    event_id: str\n    event_time: int\n    authorizations: list[Authorization]\n    is_ext_shared_channel: bool\n    event_context: str\n\n\nclass CommandBodyType(TypedDict):\n    token: str\n    team_id: str\n    team_domain: str\n    channel_id: str\n    channel_name: str\n    user_id: str\n    user_name: str\n    command: str\n    text: str\n    api_app_id: str\n    is_enterprise_install: str\n    response_url: str\n    trigger_id: str\n\n\nclass TeamType(TypedDict):\n    id: str\n    domain: str\n\n\nclass UserType(TypedDict):\n    id: str\n    username: str\n    name: str\n    team_id: str\n\n\nclass ViewType(TypedDict):\n    id: str\n    team_id: str\n    type: str\n    blocks: list[dict]\n    private_metadata: str\n    callback_id: str\n    state: dict[str, dict]\n    hash: str\n    title: dict[str, str]\n    clear_on_close: bool\n    notify_on_close: bool\n    close: str\n    submit: dict[str, str]\n    previous_view_id: str\n    root_view_id: str\n    app_id: str\n    external_id: str\n    app_installed_team_id: str\n    bot_id: str\n\n\nclass ViewBodyType(TypedDict):\n    type: str\n    team: TeamType\n    user: UserType\n    api_app_id: str\n    token: str\n    trigger_id: str\n    view: ViewType\n    response_urls: list[str]\n    is_enterprise_install: bool\n    enterprise: str\n\n\nclass ContainerType(TypedDict):\n    type: str\n    message_ts: str\n    channel_id: str\n    is_ephemeral: bool\n\n\nclass ChannelType(TypedDict):\n    id: str\n    name: str\n\n\nclass MessageType(TypedDict):\n    user: str\n    type: str\n    ts: str\n    bot_id: str\n    app_id: str\n    text: str\n    team: str\n    blocks: list[dict]\n\n\nclass ActionType(TypedDict):\n    action_id: str\n    block_id: str\n    text: dict[str, str]\n    value: str\n    type: str\n    action_ts: str\n    selected_user: str | None\n\n\nclass ActionBodyType(TypedDict):\n    type: str\n    user: UserType\n    api_app_id: str\n    token: str\n    container: ContainerType\n    trigger_id: str\n    team: TeamType\n    enterprise: str\n    is_enterprise_install: bool\n    channel: ChannelType\n    message: MessageType\n    state: dict[str, dict]\n    response_url: str\n    view: ViewType\n    actions: list[ActionType]\n\n\nclass OverflowActionType(TypedDict):\n    type: str\n    action_id: str\n    block_id: str\n    selected_option: dict[str, str]\n    action_ts: str\n\n\nclass OverflowActionBodyType(TypedDict):\n    type: str\n    user: UserType\n    api_app_id: str\n    token: str\n    container: ContainerType\n    trigger_id: str\n    team: TeamType\n    enterprise: str\n    is_enterprise_install: bool\n    view: ViewType\n    actions: list[OverflowActionType]\n\n\nclass BlockActionBodyType(TypedDict):\n    type: str\n    user: UserType\n    api_app_id: str\n    token: str\n    container: ContainerType\n    trigger_id: str\n    team: TeamType\n    enterprise: str\n    is_enterprise_install: bool\n    channel: ChannelType\n    message: MessageType\n    state: dict[str, dict]\n    response_url: str\n    actions: list[ActionType]\n\n\nclass MessageChangedMessageType(TypedDict):\n    user: str\n    type: str\n    client_msg_id: str\n    text: str\n    team: str\n    attachments: list[dict]\n    blocks: list[dict]\n    ts: str\n\n\nclass PreviousMessageType(TypedDict):\n    user: str\n    type: str\n    ts: str\n    client_msg_id: str\n    text: str\n    team: str\n    blocks: list[dict]\n\n\nclass MessageChangedEventType(TypedDict):\n    type: str\n    subtype: str\n    message: MessageChangedMessageType\n    previous_message: PreviousMessageType\n    channel: str\n    hidden: bool\n    ts: str\n    event_ts: str\n    channel_type: str\n\n\nclass MessageDeletedEventType(TypedDict):\n    type: str\n    subtype: str\n    previous_message: PreviousMessageType\n    channel: str\n    hidden: bool\n    ts: str\n    event_ts: str\n    deleted_ts: str\n    channel_type: str\n\n\nclass MessageEvent(TypedDict):\n    user: str\n    type: str\n    ts: str\n    client_msg_id: str\n    text: str\n    team: str\n    blocks: list[dict]\n    channel: str\n    event_ts: str\n    channel_type: str\n    thread_ts: str | None  # 상위 메시지의 timestamp\n\n\nclass MessageBodyType(TypedDict):\n    token: str\n    team_id: str\n    context_team_id: str\n    context_enterprise_id: str | None\n    api_app_id: str\n    event: MessageEvent  # | MessageChangedEventType | MessageDeletedEventType\n    type: str  # event_callback\n    event_id: str\n    event_time: int\n    authorizations: list[Authorization]\n    is_ext_shared_channel: bool\n    event_context: str\n\n\nclass ReactionEventItem(TypedDict):\n    type: str\n    channel: str\n    ts: str\n\n\nclass ReactionEvent(TypedDict):\n    user: str\n    type: str\n    reaction: str\n    item: ReactionEventItem\n    item_user: str\n    event_ts: str\n\n\nclass ReactionBodyType(TypedDict):\n    token: str\n    team_id: str\n    context_team_id: str\n    context_enterprise_id: str | None\n    api_app_id: str\n    event: ReactionEvent\n    type: str\n    event_id: str\n    event_time: int\n    authorizations: list[Authorization]\n    is_ext_shared_channel: bool\n    event_context: str\n\n\nclass HomeTabEventType(TypedDict):\n    type: str  # app_home_opened\n    user: str\n    channel: str\n    tab: str  # home\n    view: ViewType\n    event_ts: str\n\n\nclass ChannelCreatedChannelType(TypedDict):\n    id: str\n    name: str\n    is_channel: bool\n    is_group: bool\n    is_im: bool\n    is_mpim: bool\n    is_private: bool\n    created: int\n    is_archived: bool\n    is_general: bool\n    unlinked: int\n    name_normalized: str\n    is_shared: bool\n    is_frozen: bool\n    is_org_shared: bool\n    is_pending_ext_shared: bool\n    pending_shared: list\n    context_team_id: str\n    updated: int\n    parent_conversation: None\n    creator: str\n    is_ext_shared: bool\n    shared_team_ids: list[str]\n    pending_connected_team_ids: list\n    topic: dict[str, str]\n    purpose: dict[str, str]\n    previous_names: list[str]\n\n\nclass ChannelCreatedEventType(TypedDict):\n    type: str\n    channel: ChannelCreatedChannelType\n    event_ts: str\n\n\nclass ChannelCreatedBodyType(TypedDict):\n    token: str\n    team_id: str\n    api_app_id: str\n    event: ChannelCreatedEventType\n    type: str\n    event_id: str\n    event_time: int\n    authorizations: list[Authorization]\n    is_ext_shared_channel: bool\n"}
{"type": "source_file", "path": "app/slack/events/subscriptions.py", "content": "from datetime import datetime\nfrom app.constants import BOT_IDS\nfrom app.models import User\nfrom app.slack.services.base import SlackService\nfrom app.slack.types import (\n    ActionBodyType,\n    OverflowActionBodyType,\n)\n\nfrom slack_sdk.models.blocks import (\n    Block,\n    Option,\n    OverflowMenuElement,\n    SectionBlock,\n    DividerBlock,\n    UserSelectElement,\n    ActionsBlock,\n    ContextBlock,\n    MarkdownTextObject,\n)\nfrom slack_sdk.models.views import View\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\nfrom slack_sdk.web.async_client import AsyncWebClient\n\nfrom app.utils import json_str_to_dict\n\n\nasync def open_subscribe_member_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n) -> None:\n    \"\"\"멤버 구독 모달을 엽니다.\"\"\"\n    await ack()\n\n    target_user_value = body[\"actions\"][0].get(\"value\")\n    if not target_user_value:\n        target_user_id = None\n        message = \"\"\n    else:\n        target_user_id = json_str_to_dict(target_user_value)[\"target_user_id\"]\n        message = _process_user_subscription(user, service, target_user_id)\n\n    view = _get_subscribe_member_view(\n        user_id=user.user_id,\n        service=service,\n        message=message,\n        initial_target_user_id=target_user_id,\n    )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=view,\n    )\n\n\nasync def subscribe_member(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n) -> None:\n    \"\"\"멤버를 구독합니다.\"\"\"\n    await ack()\n    target_user_id = body[\"actions\"][0].get(\"selected_user\")\n    if not target_user_id:\n        return\n\n    message = _process_user_subscription(user, service, target_user_id)\n    view = _get_subscribe_member_view(\n        user_id=user.user_id, service=service, message=message\n    )\n\n    await client.views_update(\n        view_id=body[\"view\"][\"id\"],\n        view=view,\n    )\n\n\ndef _process_user_subscription(\n    user: User,\n    service: SlackService,\n    target_user_id: str,\n) -> str:\n    \"\"\"\n    멤버 구독을 처리합니다.\n    만약, 구독이 성공하면 빈 문자열을 반환하고, 실패하면 에러 메시지를 반환합니다.\n    \"\"\"\n    message = \"\"\n    if target_user_id == user.user_id:\n        message = \"⚠️ 자기 자신은 구독할 수 없어요.\"\n\n    if target_user_id in BOT_IDS:\n        message = \"⚠️ 봇은 구독할 수 없어요.\"\n\n    if len(service.fetch_subscriptions_by_user_id(user_id=user.user_id)) >= 5:\n        message = \"⚠️ 구독은 최대 5명까지 가능해요.\"\n\n    target_user = service.get_only_user(target_user_id)\n    if not target_user:\n        message = \"⚠️ 구독할 멤버를 찾을 수 없습니다.\"\n\n    if any(\n        subscription.target_user_id == target_user_id\n        for subscription in service.fetch_subscriptions_by_user_id(user_id=user.user_id)\n    ):\n        message = \"⚠️ 이미 구독한 멤버입니다.\"\n\n    if not message:\n        service.create_subscription(\n            user_id=user.user_id,\n            target_user_id=target_user_id,\n            target_user_channel=target_user.channel_id,\n        )\n\n    return message\n\n\nasync def unsubscribe_member(\n    ack: AsyncAck,\n    body: OverflowActionBodyType,\n    client: AsyncWebClient,\n    say: AsyncSay,\n    user: User,\n    service: SlackService,\n) -> None:\n    \"\"\"멤버 구독을 취소합니다.\"\"\"\n    await ack()\n\n    subscription_id = body[\"actions\"][0][\"selected_option\"][\"value\"]\n    service.cancel_subscription(subscription_id)\n\n    view = _get_subscribe_member_view(user_id=user.user_id, service=service)\n\n    await client.views_update(\n        view_id=body[\"view\"][\"id\"],\n        view=view,\n    )\n\n\nasync def open_subscription_permalink(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n) -> None:\n    \"\"\"구독한 멤버의 새 글을 엽니다. 로깅을 위한 이벤트입니다.\"\"\"\n    await ack()\n\n\ndef _get_subscribe_member_view(\n    *,\n    user_id: str,\n    service: SlackService,\n    initial_target_user_id: str | None = None,\n    message: str = \"\",\n) -> View:\n    \"\"\"구독 목록과, 멤버를 구독할 수 있는 뷰를 반환합니다.\"\"\"\n    user_subscriptions = service.fetch_subscriptions_by_user_id(user_id=user_id)\n    subscription_list_blocks = [\n        SectionBlock(\n            text=f\"<@{subscription.target_user_id}> 님을 {datetime.strptime(subscription.created_at[:10], '%Y-%m-%d').strftime('%Y년 %m월 %d일')} 부터 구독하고 있어요.\",\n            accessory=OverflowMenuElement(\n                action_id=\"unsubscribe_member\",\n                options=[\n                    Option(text=\"구독 취소\", value=subscription.id),\n                ],\n            ),\n        )\n        for subscription in user_subscriptions\n    ]\n    if subscription_list_blocks:\n        subscription_list_blocks = [\n            SectionBlock(text=\"*구독 목록*\"),\n            *subscription_list_blocks,\n        ]\n\n    subscribe_blocks: list[Block] = []\n    subscribe_blocks.append(SectionBlock(text=\"*구독 하기*\"))\n    subscribe_blocks.append(\n        ActionsBlock(\n            elements=[\n                UserSelectElement(\n                    action_id=\"subscribe_member\",\n                    placeholder=\"구독할 멤버를 선택해주세요.\",\n                    initial_user=initial_target_user_id,\n                ),\n            ],\n            block_id=\"select_target_user\",\n        )\n    )\n    if message:\n        subscribe_blocks.append(\n            ContextBlock(elements=[MarkdownTextObject(text=f\"*{message}*\")])\n        )\n    subscribe_blocks.append(\n        ContextBlock(\n            elements=[\n                MarkdownTextObject(\n                    text=\"구독한 멤버가 글을 제출하면 다음 날 오전 8시(한국 시간)에 DM으로 알림을 받을 수 있어요. 구독은 최대 5명까지 구독할 수 있으며, 취소는 구독 목록 우측의 `...` 또는 `더보기` 버튼을 통해 할 수 있어요.\"\n                ),\n            ],\n        )\n    )\n    view = View(\n        type=\"modal\",\n        title=\"멤버 구독\",\n        close=\"닫기\",\n        blocks=[\n            SectionBlock(\n                text=f\"<@{user_id}> 님은 현재 {len(user_subscriptions)}명을 구독하고 있어요.\"\n            ),\n            DividerBlock(),\n            *subscribe_blocks,\n            DividerBlock(),\n            *subscription_list_blocks,\n        ],\n    )\n\n    return view\n"}
{"type": "source_file", "path": "app/slack/services/point.py", "content": "from pydantic import BaseModel\nfrom app.exception import BotException\nfrom app.models import PointHistory, User\nfrom app.slack.repositories import SlackRepository\nfrom app.config import settings\nfrom app import store\nfrom enum import Enum\n\n# 동기부여와 자극을 주는 포인트는 공개 채널에 알림을 준다.\n# 수동으로 받는 포인트는 디엠 으로 알림을 준다.\n\n# fmt: off\nclass PointMap(Enum):\n    글_제출_기본 = settings.POINT_MAP[\"글_제출_기본\"]\n    글_제출_추가 = settings.POINT_MAP[\"글_제출_추가\"]\n    글_제출_콤보 = settings.POINT_MAP[\"글_제출_콤보\"]\n    글_제출_3콤보_보너스 = settings.POINT_MAP[\"글_제출_3콤보_보너스\"]\n    글_제출_6콤보_보너스 = settings.POINT_MAP[\"글_제출_6콤보_보너스\"]\n    글_제출_9콤보_보너스 = settings.POINT_MAP[\"글_제출_9콤보_보너스\"]\n    글_제출_코어채널_1등 = settings.POINT_MAP[\"글_제출_코어채널_1등\"]\n    글_제출_코어채널_2등 = settings.POINT_MAP[\"글_제출_코어채널_2등\"]\n    글_제출_코어채널_3등 = settings.POINT_MAP[\"글_제출_코어채널_3등\"]\n    커피챗_인증 = settings.POINT_MAP[\"커피챗_인증\"]\n    공지사항_확인_이모지 = settings.POINT_MAP[\"공지사항_확인_이모지\"]\n    큐레이션_요청 = settings.POINT_MAP[\"큐레이션_요청\"]\n    큐레이션_선정 = settings.POINT_MAP[\"큐레이션_선정\"]\n    빌리지_반상회_참여 = settings.POINT_MAP[\"빌리지_반상회_참여\"]\n    자기소개_작성 = settings.POINT_MAP[\"자기소개_작성\"]\n    성윤을_잡아라 = settings.POINT_MAP[\"성윤을_잡아라\"]\n    특별_보너스 = {\"point\": 0, \"reason\": \"특별 보너스\", \"category\": \"기타\"}\n\n# fmt: on\n    @property\n    def point(self) -> int:\n        return self.value[\"point\"]  # type: ignore\n\n    @property\n    def reason(self) -> str:\n        return self.value[\"reason\"]  # type: ignore\n\n    @property\n    def category(self) -> str:\n        return self.value[\"category\"]  # type: ignore\n\n    @classmethod\n    def set_special_bonus(cls, point: int, reason: str) -> \"PointMap\":\n        \"\"\"특별 보너스 포인트를 동적으로 생성합니다.\"\"\"\n        special_bonus = cls.특별_보너스\n        special_bonus._value_ = {\"point\": point, \"reason\": reason, \"category\": \"기타\"}\n        return special_bonus\n\n\nclass UserPoint(BaseModel):\n    user: User\n    point_histories: list[PointHistory]\n    \n    @property\n    def total_point(self) -> int:\n        return sum([point_history.point for point_history in self.point_histories])\n\n\n    @property\n    def point_history_text(self) -> str:\n        text = \"\"\n        for point_history in self.point_histories[:20]:\n            text += f\"[{point_history.created_at}] - *{point_history.point}점* :: {point_history.reason}\\n\"\n\n        if not text:\n            text = \"아직 포인트 획득 내역이 없어요. 😅\\n또봇 [홈] 탭 -> [포인트 획득 방법 알아보기] 에서 방법을 확인해보세요.\"\n\n        return text\n\n\n\nclass PointService:\n    def __init__(self, repo: SlackRepository) -> None:\n        self._repo = repo\n\n    def get_user_point(self, user_id: str) -> UserPoint:\n        \"\"\"포인트 히스토리를 포함한 유저를 가져옵니다.\"\"\"\n        user = self._repo.get_user(user_id)\n        if not user:\n            raise BotException(\"존재하지 않는 유저입니다.\")\n        point_histories = self._repo.fetch_point_histories(user_id)\n        return UserPoint(user=user, point_histories=point_histories)\n\n    def add_point_history(self, user_id: str, point_info: PointMap, point: int | None = None) -> str:\n        \"\"\"포인트 히스토리를 추가하고 알림 메시지를 반환합니다.\"\"\"\n        if not point:\n            point = point_info.point\n        \n        point_history=PointHistory(\n            user_id=user_id,\n            reason=point_info.reason,\n            point=point,\n            category=point_info.category,\n        )\n        self._repo.add_point(point_history=point_history)\n        store.point_history_upload_queue.append(point_history.to_list_for_sheet())\n        return f\"<@{user_id}>님 `{point_info.reason}`(으)로 `{point}`포인트를 획득했어요! 🎉\\n총 포인트와 내역은 또봇 [홈] 탭에서 확인할 수 있어요.\"\n\n    def grant_if_post_submitted(self, user_id: str, is_submit: bool) -> tuple[str, bool]:\n        \"\"\"글쓰기 포인트 지급 1. 글을 제출하면 기본 포인트를 지급합니다. 글을 이미 제출했다면 추가 포인트를 지급합니다.\"\"\"\n        user = self._repo.get_user(user_id)\n\n        if not user:\n            raise BotException(\"유저 정보가 없어 글 제출 포인트를 지급할 수 없습니다.\")\n\n        # TODO: 추후 분리할 것\n        if is_submit:\n            is_additional = True\n            point_info = PointMap.글_제출_추가\n            return self.add_point_history(user_id, point_info), is_additional\n        else: \n            is_additional = False\n            point_info = PointMap.글_제출_기본\n            return self.add_point_history(user_id, point_info), is_additional\n        \n    def grant_if_post_submitted_continuously(self, user_id: str) -> str | None:\n        \"\"\"글쓰기 포인트 지급 2. 글을 연속으로 제출한다면 추가 포인트를 지급합니다.\"\"\"\n        user = self._repo.get_user(user_id)\n\n        if not user:\n            raise BotException(\"유저 정보가 없어 글 제출 포인트를 지급할 수 없습니다.\")\n        \n        continuous_submit_count = user.get_continuous_submit_count()\n        if continuous_submit_count <= 0: \n            return None\n        \n        combo_point = None\n        if continuous_submit_count == 9:\n            point_info = PointMap.글_제출_9콤보_보너스\n        elif continuous_submit_count == 6:\n            point_info = PointMap.글_제출_6콤보_보너스\n        elif continuous_submit_count == 3:\n            point_info = PointMap.글_제출_3콤보_보너스\n        else:\n            # 3,6,9 외에는 연속 제출 횟수에 따라 연속 포인트를 지급합니다.\n            point_info = PointMap.글_제출_콤보\n            combo_point = point_info.point * continuous_submit_count\n            \n        return self.add_point_history(user_id, point_info, point=combo_point)\n\n\n    def grant_if_post_submitted_to_core_channel_ranking(self, user_id: str) -> str | None:\n        \"\"\"글 제출 포인트 지급 3. 코어채널 제출 순위에 따라 추가 포인트를 지급합니다.\"\"\"\n        user = self._repo.get_user(user_id)\n\n        if not user:\n            raise BotException(\"유저 정보가 없어 글 제출 포인트를 지급할 수 없습니다.\")\n        \n        rank_map = {}\n        channel_users = self._repo.fetch_channel_users(user.channel_id)\n        for channel_user in channel_users:\n            if channel_user.is_submit is True:\n                content = channel_user.recent_content\n                rank_map[channel_user.user_id] = content.ts\n        \n        rank_user_ids = sorted(rank_map, key=lambda x: rank_map[x])[:3]\n        if user.user_id in rank_user_ids:\n            rank = rank_user_ids.index(user.user_id) + 1\n            if rank == 1:\n                point_info = PointMap.글_제출_코어채널_1등\n            elif rank == 2:\n                point_info = PointMap.글_제출_코어채널_2등\n            else:\n                point_info = PointMap.글_제출_코어채널_3등\n\n            return self.add_point_history(user_id, point_info)\n        \n        return None\n\n    def grant_if_coffee_chat_verified(self, user_id: str) -> str:\n        \"\"\"\n        공개: 커피챗 인증을 한 경우 포인트를 지급합니다.\n        공개채널에 알림을 줍니다.\n        \"\"\"\n        point_info = PointMap.커피챗_인증\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_notice_emoji_checked(self, user_id: str) -> str:\n        \"\"\"공지사항을 확인한 경우 포인트를 지급합니다.\"\"\"\n        point_info = PointMap.공지사항_확인_이모지\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_super_admin_post_reacted(self, user_id: str) -> str:\n        \"\"\"슈퍼 어드민 글에 이모지를 단 경우 포인트를 지급합니다.\"\"\"\n        point_info = PointMap.성윤을_잡아라\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_curation_requested(self, user_id: str) -> str:\n        \"\"\"큐레이션을 요청한 경우 포인트를 지급합니다.\"\"\"\n        point_info = PointMap.큐레이션_요청\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_curation_selected(self, user_id: str) -> str:\n        \"\"\"\n        수동: 큐레이션이 선정된 경우 포인트를 지급합니다.\n        DM으로 알림을 줍니다.\n        \"\"\"\n        point_info = PointMap.큐레이션_선정\n        return self.add_point_history(user_id, point_info)\n\n\n    def grant_if_village_conference_participated(\n        self, user_id: str\n    ):\n        \"\"\"\n        수동: 빌리지 반상회에 참여한 경우 포인트를 지급합니다.\n        DM으로 알림을 줍니다.\n        \"\"\"\n        point_info = PointMap.빌리지_반상회_참여\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_introduction_written(self, user_id: str) -> str:\n        \"\"\"\n        수동: 자기소개를 작성한 경우 포인트를 지급합니다.\n        DM으로 알림을 줍니다.\n        \"\"\"\n        point_info = PointMap.자기소개_작성\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_special_point(self, user_id: str, point: int, reason: str) -> str:\n        \"\"\"\n        수동: 특별한 경우 포인트를 지급합니다.\n        DM으로 알림을 줍니다.\n        \"\"\"\n        point_info = PointMap.set_special_bonus(point=point, reason=reason)\n        return self.add_point_history(user_id, point_info)\n"}
{"type": "source_file", "path": "app/slack/repositories.py", "content": "import csv\nfrom typing import Any\nimport pandas as pd\nimport polars as pl\n\nfrom app import store\nfrom app import models\nfrom app.exception import BotException\nfrom app.utils import tz_now_to_str\n\n\nclass SlackRepository:\n    def __init__(self) -> None: ...\n\n    def get_user(self, user_id: str) -> models.User | None:\n        \"\"\"유저와 콘텐츠를 가져옵니다.\"\"\"\n        if user := self._get_user(user_id):\n            user.contents = self._fetch_contents(user_id)\n            return user\n        return None\n\n    def get_only_user(self, user_id: str) -> models.User | None:\n        \"\"\"유저만 가져옵니다.\"\"\"\n        if user := self._get_user(user_id):\n            return user\n        return None\n\n    def fetch_users(self) -> list[models.User]:\n        \"\"\"모든 유저를 가져옵니다.\"\"\"\n        users = [models.User(**user) for user in self._fetch_users()]\n        for user in users:\n            user.contents = self._fetch_contents(user.user_id)\n        return users\n\n    def _get_user(self, user_id: str) -> models.User | None:\n        \"\"\"유저를 가져옵니다.\"\"\"\n        users = self._fetch_users()\n        for user in users:\n            if user[\"user_id\"] == user_id:\n                return models.User(**user)\n        return None\n\n    def _fetch_users(self) -> list[dict[str, Any]]:\n        \"\"\"모든 유저를 가져옵니다.\"\"\"\n        with open(\"store/users.csv\") as f:\n            reader = csv.DictReader(f)\n            users = [dict(row) for row in reader]\n            return users\n\n    def _fetch_contents(self, user_id: str) -> list[models.Content]:\n        \"\"\"유저의 콘텐츠를 오름차순(날짜)으로 정렬하여 가져옵니다.\"\"\"\n        with open(\"store/contents.csv\") as f:\n            reader = csv.DictReader(f)\n            contents = [\n                models.Content(**content)\n                for content in reader\n                if content[\"user_id\"] == user_id\n            ]\n            return contents\n\n    def update(self, user: models.User) -> None:\n        \"\"\"유저의 콘텐츠를 업데이트합니다.\"\"\"\n        # TODO: upload 로 이름 변경 필요\n        if not user.contents:\n            raise BotException(\"업데이트 대상 content 가 없어요.\")\n        store.content_upload_queue.append(user.recent_content.to_list_for_sheet())\n        with open(\"store/contents.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(user.recent_content.to_list_for_csv())\n\n    def fetch_contents(self) -> list[models.Content]:\n        \"\"\"모든 콘텐츠를 가져옵니다.\"\"\"\n        with open(\"store/contents.csv\") as f:\n            reader = csv.DictReader(f)\n            contents = [\n                models.Content(**content)\n                for content in reader\n                if content[\"type\"] == \"submit\"\n            ]\n            return sorted(contents, key=lambda content: content.dt_, reverse=True)\n\n    def fetch_contents_by_keyword(self, keyword: str) -> list[models.Content]:\n        \"\"\"키워드가 포함된 콘텐츠를 가져옵니다.\"\"\"\n        with open(\"store/contents.csv\") as f:\n            reader = csv.DictReader(f)\n            contents = [\n                models.Content(**content)\n                for content in reader\n                if keyword.lower()\n                in (content[\"title\"] + content[\"description\"] + content[\"tags\"]).lower()\n                and content[\"type\"] == \"submit\"\n            ]\n            return sorted(contents, key=lambda content: content.dt_, reverse=True)\n\n    def get_user_id_by_name(self, name: str) -> str | None:\n        \"\"\"이름으로 user_id를 가져옵니다.\"\"\"\n        with open(\"store/users.csv\") as f:\n            reader = csv.DictReader(f)\n            matching_users = [user for user in reader if name in user[\"name\"]]\n\n        if len(matching_users) == 1:  # 이름 부분 일치가 하나인 경우에만 반환\n            return matching_users[0][\"user_id\"]\n        elif len(matching_users) > 1:\n            for user in matching_users:\n                if user[\"name\"] == name:\n                    return user[\"user_id\"]\n        return None\n\n    def fetch_user_ids_by_name(self, name: str) -> list[str]:\n        \"\"\"이름으로 user_ids를 가져옵니다.\"\"\"\n        with open(\"store/users.csv\") as f:\n            reader = csv.DictReader(f)\n            return [user[\"user_id\"] for user in reader if name in user[\"name\"]]\n\n    def create_bookmark(self, bookmark: models.Bookmark) -> None:\n        \"\"\"북마크를 생성합니다.\"\"\"\n        with open(\"store/bookmark.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(bookmark.to_list_for_csv())\n\n    def get_bookmark(\n        self,\n        user_id: str,\n        content_ts: str,\n        status: models.BookmarkStatusEnum = models.BookmarkStatusEnum.ACTIVE,\n    ) -> models.Bookmark | None:\n        bookmarks = self.fetch_bookmarks(user_id, status)\n        for bookmark in bookmarks:\n            if bookmark.content_ts == content_ts:\n                return bookmark\n        return None\n\n    def fetch_bookmarks(\n        self,\n        user_id: str,\n        status: models.BookmarkStatusEnum = models.BookmarkStatusEnum.ACTIVE,\n    ) -> list[models.Bookmark]:\n        \"\"\"유저의 삭제되지 않은 북마크를 내림차순으로 가져옵니다.\"\"\"\n        with open(\"store/bookmark.csv\") as f:\n            reader = csv.DictReader(f)\n            bookmarks = [\n                models.Bookmark(**bookmark)  # type: ignore\n                for bookmark in reader\n                if bookmark[\"user_id\"] == user_id and bookmark[\"status\"] == status\n            ]\n\n        return sorted(bookmarks, key=lambda bookmark: bookmark.created_at, reverse=True)\n\n    def update_bookmark(\n        self,\n        content_ts: str,\n        new_note: str = \"\",\n        new_status: models.BookmarkStatusEnum = models.BookmarkStatusEnum.ACTIVE,\n    ) -> None:\n        \"\"\"북마크를 업데이트합니다.\"\"\"\n        df = pd.read_csv(\"store/bookmark.csv\", dtype=str, na_filter=False)\n\n        if new_note:\n            df.loc[df[\"content_ts\"] == content_ts, \"note\"] = new_note\n        if new_status:\n            df.loc[df[\"content_ts\"] == content_ts, \"status\"] = new_status\n        if new_note or new_status:\n            df.loc[df[\"content_ts\"] == content_ts, \"updated_at\"] = tz_now_to_str()\n\n        df.to_csv(\"store/bookmark.csv\", index=False, quoting=csv.QUOTE_ALL)\n\n    def update_user_intro(\n        self,\n        user_id: str,\n        new_intro: str,\n    ) -> None:\n        \"\"\"유저 정보를 업데이트합니다.\"\"\"\n        df = pd.read_csv(\"store/users.csv\", dtype=str, na_filter=False)\n        df.loc[df[\"user_id\"] == user_id, \"intro\"] = new_intro\n        df.to_csv(\"store/users.csv\", index=False, quoting=csv.QUOTE_ALL)\n\n        if user := self._get_user(user_id):\n            store.user_update_queue.append(user.to_list_for_sheet())\n\n    def get_content_by(\n        self,\n        ts: str | None = None,\n        user_id: str | None = None,\n        dt: str | None = None,\n        content_url: str | None = None,\n    ) -> models.Content | None:\n        \"\"\"\n        콘텐츠를 조회합니다.\n        - 우선적으로 ts(타임스탬프)를 기준으로 검색합니다. 이는 Unique한 값입니다.\n        - ts가 없을 경우, user_id와 dt(생성일시)를 조합하여 검색합니다. 이는 Unique한 값입니다.\n        - content_url 이 있을 경우, content_url을 검색합니다. 이는 Unique한 값입니다.\n        - Unique한 값이 아닌 경우, 검색된 결과 중 가장 최신의 결과를 반환합니다.\n        \"\"\"\n        with open(\"store/contents.csv\") as f:\n            reader = csv.DictReader(f)\n            contents = [\n                models.Content(**content)  # type: ignore\n                for content in reader\n                if content[\"ts\"] == ts\n                or (content[\"user_id\"] == user_id and content[\"dt\"] == dt)\n                or (content[\"content_url\"] == content_url)\n            ]\n\n        if not contents:\n            return None\n\n        return sorted(contents, key=lambda content: content.dt_, reverse=True)[0]\n\n    def create_coffee_chat_proof(self, proof: models.CoffeeChatProof) -> None:\n        \"\"\"커피챗 인증을 생성합니다.\"\"\"\n        with open(\n            \"store/coffee_chat_proof.csv\", \"a\", newline=\"\", encoding=\"utf-8\"\n        ) as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(proof.to_list_for_csv())\n\n    def get_coffee_chat_proof(self, ts: str) -> models.CoffeeChatProof | None:\n        \"\"\"ts로 커피챗 인증을 조회합니다.\"\"\"\n        with open(\"store/coffee_chat_proof.csv\") as f:\n            reader = csv.DictReader(f)\n            proofs = [\n                models.CoffeeChatProof(**proof)  # type: ignore\n                for proof in reader\n                if proof[\"ts\"] == ts\n            ]\n\n        if not proofs:\n            return None\n\n        return proofs[0]\n\n    def fetch_coffee_chat_proofs(\n        self,\n        *,\n        thread_ts: str | None = None,\n        user_id: str | None = None,\n    ) -> list[models.CoffeeChatProof]:\n        \"\"\"thread_ts로 커피챗 인증을 조회합니다.\"\"\"\n        with open(\"store/coffee_chat_proof.csv\") as f:\n            reader = csv.DictReader(f)\n            proofs = [\n                models.CoffeeChatProof(**proof)  # type: ignore\n                for proof in reader\n                if (not thread_ts or proof[\"thread_ts\"] == thread_ts)\n                and (not user_id or proof[\"user_id\"] == user_id)\n            ]\n            return sorted(proofs, key=lambda proof: proof.ts, reverse=True)\n\n    def add_point(self, point_history: models.PointHistory) -> None:\n        \"\"\"포인트를 추가합니다.\"\"\"\n        with open(\"store/point_histories.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(point_history.to_list_for_csv())\n\n    def fetch_point_histories(self, user_id: str) -> list[models.PointHistory]:\n        \"\"\"포인트 히스토리를 가져옵니다.\"\"\"\n        with open(\"store/point_histories.csv\") as f:\n            reader = csv.DictReader(f)\n            point_histories = [\n                models.PointHistory(**point_history)  # type: ignore\n                for point_history in reader\n                if point_history[\"user_id\"] == user_id\n            ]\n            return sorted(\n                point_histories, key=lambda point: point.created_at, reverse=True\n            )\n\n    def fetch_channel_users(self, channel_id: str) -> list[models.User]:\n        \"\"\"\n        채널의 유저를 가져옵니다.\n        성능향상을 위해 polars를 사용합니다.\n        \"\"\"\n        users_df = pl.read_csv(\"store/users.csv\", dtypes={\"deposit\": pl.Utf8})\n        users = users_df.filter(pl.col(\"channel_id\") == channel_id).to_dicts()\n        users = [models.User(**user) for user in users]\n\n        contents_df = pl.read_csv(\"store/contents.csv\", dtypes={\"ts\": pl.Utf8})\n        for user in users:\n            contents = contents_df.filter(pl.col(\"user_id\") == user.user_id).to_dicts()\n            user.contents = [models.Content(**content) for content in contents]\n\n        return users\n\n    def create_paper_plane(self, paper_plane: models.PaperPlane) -> None:\n        \"\"\"종이비행기를 생성합니다.\"\"\"\n        with open(\"store/paper_plane.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(paper_plane.to_list_for_csv())\n\n    def fetch_paper_planes(self, sender_id: str) -> list[models.PaperPlane]:\n        \"\"\"종이비행기를 가져옵니다.\"\"\"\n        with open(\"store/paper_plane.csv\") as f:\n            reader = csv.DictReader(f)\n            paper_planes = [\n                models.PaperPlane(**paper_plane)  # type: ignore\n                for paper_plane in reader\n                if paper_plane[\"sender_id\"] == sender_id\n            ]\n            return paper_planes\n\n    def create_subscription(self, subscription: models.Subscription) -> None:\n        \"\"\"구독을 생성합니다.\"\"\"\n        with open(\"store/subscriptions.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(subscription.to_list_for_csv())\n\n    def cancel_subscription(self, subscription_id: str) -> None:\n        \"\"\"구독을 취소합니다.\"\"\"\n        df = pd.read_csv(\"store/subscriptions.csv\", dtype=str, na_filter=False)\n        df.loc[df[\"id\"] == subscription_id, \"status\"] = (\n            models.SubscriptionStatusEnum.CANCELED\n        )\n        df.to_csv(\"store/subscriptions.csv\", index=False, quoting=csv.QUOTE_ALL)\n\n    def fetch_subscriptions(self) -> list[models.Subscription]:\n        \"\"\"모든 구독 내역을 가져옵니다.\"\"\"\n        with open(\"store/subscriptions.csv\") as f:\n            reader = csv.DictReader(f)\n            subscriptions = [\n                models.Subscription(**subscription)  # type: ignore\n                for subscription in reader\n                if subscription[\"status\"] == models.SubscriptionStatusEnum.ACTIVE\n            ]\n            return subscriptions\n\n    def fetch_subscriptions_by_user_id(\n        self,\n        user_id: str,\n    ) -> list[models.Subscription]:\n        \"\"\"유저의 구독 내역을 가져옵니다.\"\"\"\n        with open(\"store/subscriptions.csv\") as f:\n            reader = csv.DictReader(f)\n            subscriptions = [\n                models.Subscription(**subscription)  # type: ignore\n                for subscription in reader\n                if subscription[\"status\"] == models.SubscriptionStatusEnum.ACTIVE\n                and subscription[\"user_id\"] == user_id\n            ]\n            return subscriptions\n\n    def fetch_subscriptions_by_target_user_id(\n        self,\n        target_user_id: str,\n    ) -> list[models.Subscription]:\n        \"\"\"타겟 유저를 기준으로 구독 내역을 가져옵니다.\"\"\"\n        with open(\"store/subscriptions.csv\") as f:\n            reader = csv.DictReader(f)\n            subscriptions = [\n                models.Subscription(**subscription)  # type: ignore\n                for subscription in reader\n                if subscription[\"status\"] == models.SubscriptionStatusEnum.ACTIVE\n                and subscription[\"target_user_id\"] == target_user_id\n            ]\n            return subscriptions\n\n    def get_subscription(\n        self,\n        subscription_id: str,\n        status: models.SubscriptionStatusEnum = models.SubscriptionStatusEnum.ACTIVE,\n    ) -> models.Subscription | None:\n        \"\"\"구독을 가져옵니다.\"\"\"\n        with open(\"store/subscriptions.csv\") as f:\n            reader = csv.DictReader(f)\n            for subscription in reader:\n                if (\n                    subscription[\"id\"] == subscription_id\n                    and subscription[\"status\"] == status\n                ):\n                    return models.Subscription(**subscription)  # type: ignore\n        return None\n"}
{"type": "source_file", "path": "app/store.py", "content": "import asyncio\nimport csv\nimport os\nfrom typing import Any\nfrom app.client import SpreadSheetClient\nfrom app.logging import log_event\nfrom app.models import Bookmark\n\nqueue_lock = asyncio.Lock()\n\ncontent_upload_queue: list[list[str]] = []\nbookmark_upload_queue: list[list[str]] = []\nbookmark_update_queue: list[Bookmark] = []  # TODO: 추후 타입 수정 필요\nuser_update_queue: list[list[str]] = []\ncoffee_chat_proof_upload_queue: list[list[str]] = []\npoint_history_upload_queue: list[list[str]] = []\npaper_plane_upload_queue: list[list[str]] = []\nsubscription_upload_queue: list[list[str]] = []\nsubscription_update_queue: list[dict[str, Any]] = []\n\n\nclass Store:\n    def __init__(self, client: SpreadSheetClient) -> None:\n        self._client = client\n\n    def pull_all(self) -> None:\n        \"\"\"데이터를 가져와 서버 저장소를 동기화합니다.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"users\", values=self._client.get_values(\"users\"))\n        self.write(\"contents\", values=self._client.get_values(\"contents\"))\n        self.write(\"bookmark\", values=self._client.get_values(\"bookmark\"))\n        self.write(\n            \"coffee_chat_proof\", values=self._client.get_values(\"coffee_chat_proof\")\n        )\n        self.write(\"point_histories\", values=self._client.get_values(\"point_histories\"))\n        self.write(\"paper_plane\", values=self._client.get_values(\"paper_plane\"))\n        self.write(\"subscriptions\", values=self._client.get_values(\"subscriptions\"))\n\n    def pull_users(self) -> None:\n        \"\"\"유저 데이터를 가져와 서버 저장소를 동기화합니다.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"users\", values=self._client.get_values(\"users\"))\n\n    def pull_contents(self) -> None:\n        \"\"\"콘텐츠 데이터를 가져와 서버 저장소를 동기화합니다.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"contents\", values=self._client.get_values(\"contents\"))\n\n    def pull_bookmark(self) -> None:\n        \"\"\"북마크 데이터를 가져와 서버 저장소를 동기화합니다.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"bookmark\", values=self._client.get_values(\"bookmark\"))\n\n    def pull_coffee_chat_proof(self) -> None:\n        \"\"\"커피챗 인증 데이터를 가져와 서버 저장소를 동기화합니다.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\n            \"coffee_chat_proof\", values=self._client.get_values(\"coffee_chat_proof\")\n        )\n\n    def pull_point_histories(self) -> None:\n        \"\"\"포인트 내역 데이터를 가져와 서버 저장소를 동기화합니다.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"point_histories\", values=self._client.get_values(\"point_histories\"))\n\n    def pull_paper_plane(self) -> None:\n        \"\"\"종이비행기 데이터를 가져와 서버 저장소를 동기화합니다.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"paper_plane\", values=self._client.get_values(\"paper_plane\"))\n\n    def pull_subscriptions(self) -> None:\n        \"\"\"구독 내역 데이터를 가져와 서버 저장소를 동기화합니다.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"subscriptions\", values=self._client.get_values(\"subscriptions\"))\n\n    def write(self, table_name: str, values: list[list[str]]) -> None:\n        \"\"\"데이터를 저장소에 저장합니다.\"\"\"\n        with open(f\"store/{table_name}.csv\", \"w\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerows(values)\n\n    def read(self, table_name: str) -> list[list[str]]:\n        \"\"\"저장소에서 데이터를 읽어옵니다.\"\"\"\n        with open(f\"store/{table_name}.csv\") as f:\n            reader = csv.reader(f, quoting=csv.QUOTE_ALL)\n            data = list(reader)\n        return data\n\n    def upload_all(self, table_name: str) -> None:\n        \"\"\"해당 테이블의 모든 데이터를 업로드합니다.\"\"\"\n        values = self.read(table_name)\n        self._client.bulk_upload(table_name, values)\n\n    async def upload_queue(self) -> None:\n        \"\"\"새로 추가된 queue 가 있다면 upload 합니다.\"\"\"\n        global content_upload_queue\n        global bookmark_upload_queue\n        global bookmark_update_queue\n        global user_update_queue\n        global coffee_chat_proof_upload_queue\n        global point_history_upload_queue\n        global paper_plane_upload_queue\n        global subscription_upload_queue\n        global subscription_update_queue\n\n        async with queue_lock:\n            temp_content_upload_queue = list(content_upload_queue)\n            if temp_content_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"contents\",\n                    temp_content_upload_queue,\n                )\n                content_upload_queue = self.initial_queue(\n                    queue=content_upload_queue,\n                    temp_queue=temp_content_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_contents\",\n                    type=\"content\",\n                    description=f\"{len(temp_content_upload_queue)}개 콘텐츠 업로드\",\n                    body={\n                        \"temp_content_upload_queue\": temp_content_upload_queue,\n                        \"content_upload_queue\": content_upload_queue,  # 디버깅을 위해 추가\n                    },\n                )\n\n            temp_bookmark_upload_queue = list(bookmark_upload_queue)\n            if temp_bookmark_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"bookmark\",\n                    temp_bookmark_upload_queue,\n                )\n                bookmark_upload_queue = self.initial_queue(\n                    queue=bookmark_upload_queue,\n                    temp_queue=temp_bookmark_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_bookmarks\",\n                    type=\"content\",\n                    description=f\"{len(temp_bookmark_upload_queue)}개 북마크 업로드\",\n                    body={\"temp_bookmark_upload_queue\": temp_bookmark_upload_queue},\n                )\n\n            temp_bookmark_update_queue = list(bookmark_update_queue)\n            if temp_bookmark_update_queue:\n                for bookmark in temp_bookmark_update_queue:\n                    await asyncio.to_thread(\n                        self._client.update_bookmark,\n                        \"bookmark\",\n                        bookmark,\n                    )\n                bookmark_update_queue = self.initial_queue(\n                    queue=bookmark_update_queue,\n                    temp_queue=temp_bookmark_update_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"updated_bookmarks\",\n                    type=\"content\",\n                    description=f\"{len(temp_bookmark_update_queue)}개 북마크 업데이트\",\n                    body={\"temp_bookmark_update_queue\": temp_bookmark_update_queue},\n                )\n\n            temp_user_update_queue = list(user_update_queue)\n            if temp_user_update_queue:\n                for values in temp_user_update_queue:\n                    await asyncio.to_thread(\n                        self._client.update_user,\n                        \"users\",\n                        values,\n                    )\n                user_update_queue = self.initial_queue(\n                    queue=user_update_queue,\n                    temp_queue=temp_user_update_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"updated_user_introduction\",\n                    type=\"user\",\n                    description=f\"{len(temp_user_update_queue)}개 유저 자기소개 업데이트\",\n                    body={\"temp_user_update_queue\": temp_user_update_queue},\n                )\n\n            temp_coffee_chat_proof_upload_queue = list(coffee_chat_proof_upload_queue)\n            if temp_coffee_chat_proof_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"coffee_chat_proof\",\n                    temp_coffee_chat_proof_upload_queue,\n                )\n                coffee_chat_proof_upload_queue = self.initial_queue(\n                    queue=coffee_chat_proof_upload_queue,\n                    temp_queue=temp_coffee_chat_proof_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_coffee_chat_proofs\",\n                    type=\"community\",\n                    description=f\"{len(temp_coffee_chat_proof_upload_queue)}개 커피챗 인증 업로드\",\n                    body={\n                        \"temp_coffee_chat_proof_upload_queue\": temp_coffee_chat_proof_upload_queue\n                    },\n                )\n\n            temp_point_history_upload_queue = list(point_history_upload_queue)\n            if temp_point_history_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"point_histories\",\n                    temp_point_history_upload_queue,\n                )\n                point_history_upload_queue = self.initial_queue(\n                    queue=point_history_upload_queue,\n                    temp_queue=temp_point_history_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_point_histories\",\n                    type=\"point\",\n                    description=f\"{len(temp_point_history_upload_queue)}개 포인트 내역 업로드\",\n                    body={\n                        \"temp_point_history_upload_queue\": temp_point_history_upload_queue\n                    },\n                )\n\n            temp_paper_plane_upload_queue = list(paper_plane_upload_queue)\n            if temp_paper_plane_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"paper_plane\",\n                    temp_paper_plane_upload_queue,\n                )\n                paper_plane_upload_queue = self.initial_queue(\n                    queue=paper_plane_upload_queue,\n                    temp_queue=temp_paper_plane_upload_queue,\n                )\n                # log_event(\n                #     actor=\"system\",\n                #     event=\"uploaded_paper_plane\",\n                #     type=\"community\",\n                #     description=f\"{len(temp_paper_plane_upload_queue)}개 종이비행기 업로드\",\n                #     body=\"\",  # 종이 비행기는 로그에 내용을 포함하지 않는다.\n                # )\n\n            temp_subscription_upload_queue = list(subscription_upload_queue)\n            if temp_subscription_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"subscriptions\",\n                    temp_subscription_upload_queue,\n                )\n                subscription_upload_queue = self.initial_queue(\n                    queue=subscription_upload_queue,\n                    temp_queue=temp_subscription_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_subscription\",\n                    type=\"subscription\",\n                    description=f\"{len(temp_subscription_upload_queue)}개 구독 내역 업로드\",\n                    body={\n                        \"temp_subscription_upload_queue\": temp_subscription_upload_queue\n                    },\n                )\n\n            temp_subscription_update_queue = list(subscription_update_queue)\n            if temp_subscription_update_queue:\n                for subscription_dict in temp_subscription_update_queue:\n                    await asyncio.to_thread(\n                        self._client.update_subscription,\n                        \"subscriptions\",\n                        subscription_dict,\n                    )\n                subscription_update_queue = self.initial_queue(\n                    queue=subscription_update_queue,\n                    temp_queue=temp_subscription_update_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"updated_subscriptions\",\n                    type=\"subscription\",\n                    description=f\"{len(temp_subscription_update_queue)}개 구독 내역 업데이트\",\n                    body={\n                        \"temp_subscription_update_queue\": temp_subscription_update_queue\n                    },\n                )\n\n    def backup(self, table_name: str) -> None:\n        values = self.read(table_name)\n        self._client.backup(values)\n\n    def initialize_logs(self) -> None:\n        \"\"\"로그를 초기화합니다.\"\"\"\n        open(\"store/logs.csv\", \"w\").close()\n\n    def initial_queue(self, *, queue: list, temp_queue: list) -> list:\n        \"\"\"queue 에서 temp_queue 를 제거한 값을 반환합니다.\"\"\"\n        return [entry for entry in queue if entry not in temp_queue]\n"}
{"type": "source_file", "path": "app/slack_notification.py", "content": "from app.logging import logger\n\n\nfrom slack_sdk.web.async_client import AsyncWebClient\n\n\nfrom typing import Any\n\n\nasync def send_point_noti_message(\n    client: AsyncWebClient,\n    channel: str,\n    text: str,\n    **kwargs: Any,\n) -> None:\n    \"\"\"포인트 알림 메시지를 전송합니다.\"\"\"\n    try:\n        await client.chat_postMessage(channel=channel, text=text)\n    except Exception as e:\n        kwargs_str = \", \".join([f\"{k}: {v}\" for k, v in kwargs.items()])\n        text = text.replace(\"\\n\", \" \")\n        logger.error(\n            f\"포인트 알림 전송 에러 👉 error: {str(e)} :: channel(user_id): {channel} text: {text} {kwargs_str}\"\n        )\n        pass\n"}
{"type": "source_file", "path": "scripts/commit-msg-convention.py", "content": "#!/usr/bin/python3\n\nimport re\nimport sys\n\nCOMMIT_MESSAGE_REGEX = (\n    r'^((revert: \")?(feat|fix|docs|style|refactor|perf|test|ci|build|chore)'\n    r\"(\\(.*\\))?!?:\\s.{1,50})\"\n)\n\n\ndef valid_commit_message(message: str) -> bool:\n    \"\"\"\n    Function to validate the commit message\n    Args:\n        message (str): The message to validate\n    Returns:\n        bool: True for valid messages, False otherwise\n    \"\"\"\n    if not re.match(COMMIT_MESSAGE_REGEX, message):\n        print(\n            \"Proper commit message format is required for automated changelog\"\n            \"generation. Examples:\\n\\n\"\n        )\n        print(\"feat(compiler): add 'comments' option\")\n        print(\"fix(v-model): handle events on blur (close #28)\\n\\n\")\n        print(\"See COMMIT_CONVENTION from Notion for more details.\\n\")\n        print(\n            \"You can also use cz commit to interactively \"\n            \"generate a commit message.\\n\"\n        )\n        return False\n\n    print(\"Commit message is valid.\")\n    return True\n\n\ndef main() -> None:\n    \"\"\"Main function.\"\"\"\n    message_file = sys.argv[1]\n    try:\n        txt_file = open(message_file, \"r\")\n        commit_message = txt_file.read()\n    finally:\n        txt_file.close()\n\n    if not valid_commit_message(commit_message):\n        sys.exit(1)\n\n    sys.exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "app/slack/events/log.py", "content": "import csv\nfrom datetime import datetime, timedelta\nimport os\n\nfrom app.bigquery.queue import CommentDataType, EmojiDataType, PostDataType\nfrom app.constants import PRIMARY_CHANNEL\nfrom app.logging import log_event\nfrom app.slack_notification import send_point_noti_message\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.point import PointService\nfrom app.slack.types import MessageBodyType, ReactionBodyType\nfrom app.bigquery import queue as bigquery_queue\nfrom app.config import settings\nfrom slack_bolt.async_app import AsyncAck\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom app.utils import tz_now_to_str\nfrom aiocache import cached\n\n\nasync def handle_comment_data(body: MessageBodyType) -> None:\n    data = CommentDataType(\n        user_id=body[\"event\"][\"user\"],\n        channel_id=body[\"event\"][\"channel\"],\n        ts=body[\"event\"][\"thread_ts\"],  # type: ignore\n        comment_ts=body[\"event\"][\"ts\"],\n        tddate=datetime.fromtimestamp(float(body[\"event\"][\"ts\"])).date(),\n        createtime=datetime.fromtimestamp(float(body[\"event\"][\"ts\"])),\n        text=body[\"event\"][\"text\"],\n    )\n    bigquery_queue.comments_upload_queue.append(data)\n\n\nasync def handle_post_data(body: MessageBodyType) -> None:\n    data = PostDataType(\n        user_id=body[\"event\"][\"user\"],\n        channel_id=body[\"event\"][\"channel\"],\n        ts=body[\"event\"][\"ts\"],\n        tddate=datetime.fromtimestamp(float(body[\"event\"][\"ts\"])).date(),\n        createtime=datetime.fromtimestamp(float(body[\"event\"][\"ts\"])),\n        text=body[\"event\"][\"text\"],\n    )\n    bigquery_queue.posts_upload_queue.append(data)\n\n\nasync def handle_reaction_added(\n    ack: AsyncAck,\n    body: ReactionBodyType,\n    client: AsyncWebClient,\n) -> None:\n    \"\"\"리액션 추가 이벤트를 처리합니다.\"\"\"\n    await ack()\n\n    data = EmojiDataType(\n        user_id=body[\"event\"][\"user\"],\n        channel_id=body[\"event\"][\"item\"][\"channel\"],\n        ts=body[\"event\"][\"item\"][\"ts\"],\n        reactions_ts=body[\"event\"][\"event_ts\"],\n        tddate=datetime.fromtimestamp(float(body[\"event\"][\"event_ts\"])).date(),\n        createtime=datetime.fromtimestamp(float(body[\"event\"][\"event_ts\"])),\n        reaction=body[\"event\"][\"reaction\"],\n    )\n    bigquery_queue.emojis_upload_queue.append(data)\n\n    # 공지사항을 이모지로 확인하면 포인트를 지급합니다.\n    if (\n        body[\"event\"][\"item\"][\"channel\"] == settings.NOTICE_CHANNEL\n        and body[\"event\"][\"reaction\"] == \"noti-check\"\n    ):\n        channel_id = body[\"event\"][\"item\"][\"channel\"]\n        ts = body[\"event\"][\"item\"][\"ts\"]\n\n        if await _is_thread_message(\n            client=client,\n            channel_id=channel_id,\n            ts=ts,\n        ):\n            return\n\n        user_id = body[\"event\"][\"user\"]\n        notice_ts = body[\"event\"][\"item\"][\"ts\"]\n\n        if _is_checked_notice(user_id, notice_ts):\n            return\n\n        # 공지사항 날짜가 3일 보다 이전이라면 패스합니다.\n        if datetime.fromtimestamp(float(notice_ts)) < datetime.now() - timedelta(\n            days=3\n        ):\n            return\n\n        point_service = PointService(repo=SlackRepository())\n        text = point_service.grant_if_notice_emoji_checked(user_id=user_id)\n        await send_point_noti_message(\n            client=client,\n            channel=user_id,\n            text=text,\n            notice_ts=notice_ts,\n        )\n\n        _write_checked_notice(user_id, notice_ts)\n\n        log_event(\n            actor=user_id,\n            event=\"checked_notice\",\n            type=body[\"event\"][\"type\"],\n            description=\"공지사항 확인\",\n            body=body,\n        )\n        return\n\n    # 성윤님이 1_채널에 제출한 글에 이모지를 달면 포인트를 지급합니다.\n    if (\n        body[\"event\"][\"item\"][\"channel\"] in PRIMARY_CHANNEL\n        and body.get(\"event\", {}).get(\"item_user\") == settings.TTOBOT_USER_ID\n        and body[\"event\"][\"reaction\"] == \"catch-kyle\"\n    ):\n        user_id = body[\"event\"][\"user\"]\n        post_ts = body[\"event\"][\"item\"][\"ts\"]\n        channel_id = body[\"event\"][\"item\"][\"channel\"]\n\n        if _is_checked_super_admin_post(user_id, post_ts):\n            return\n\n        # 글 제출 날짜가 1일 보다 이전이라면 패스합니다.\n        if datetime.fromtimestamp(float(post_ts)) < datetime.now() - timedelta(days=1):\n            return\n\n        content = SlackRepository().get_content_by(ts=post_ts)\n        if content is None or content.user_id != settings.SUPER_ADMIN:\n            return\n\n        point_service = PointService(repo=SlackRepository())\n        text = point_service.grant_if_super_admin_post_reacted(user_id=user_id)\n        await send_point_noti_message(\n            client=client,\n            channel=user_id,\n            text=text,\n            post_ts=post_ts,\n        )\n\n        _write_checked_super_admin_post(\n            user_id,\n            post_ts,\n            channel_id,\n        )\n\n        log_event(\n            actor=user_id,\n            event=\"reacted_super_admin_post\",\n            type=body[\"event\"][\"type\"],\n            description=\"'성윤을 잡아라' 성공\",\n            body=body,\n        )\n\n\ndef _is_thread_message_cache_key_builder(func, *args, **kwargs):\n    # `args`에서 `client`를 제외하고 `channel_id`와 `ts`만 사용해 키를 생성\n    if \"channel_id\" in kwargs and \"ts\" in kwargs:\n        channel_id = kwargs[\"channel_id\"]\n        ts = kwargs[\"ts\"]\n    else:\n        # 위치 인자를 사용할 때 `args`에서 두 번째와 세 번째 인자 사용\n        channel_id = args[1]\n        ts = args[2]\n    return f\"{func.__name__}:{channel_id}:{ts}\"\n\n\n@cached(ttl=60, key_builder=_is_thread_message_cache_key_builder)\nasync def _is_thread_message(client: AsyncWebClient, channel_id: str, ts: str) -> bool:\n    \"\"\"\n    메시지가 스레드 메시지인지 확인합니다.\n    캐시를 사용하여 동일한 메시지에 대한 중복 요청을 방지합니다.\n    캐시를 사용하는 이유는 슬랙 API의 제한 때문입니다.\n    conversations_replies(Web API Tier 3): 50+ per minute limit\n    \"\"\"\n    res = await client.conversations_replies(channel=channel_id, ts=ts)\n    messages: list[dict] = res.get(\"messages\", [])\n    for message in messages:\n        # 대상 메시지를 찾습니다.\n        if message[\"ts\"] == ts:\n            thread_ts = message.get(\"thread_ts\")\n\n            # thread_ts 가 없다면 일반 메시지 입니다. 단, 댓글이 있다면 thread_ts 가 있습니다.\n            if not thread_ts:\n                return False\n\n            # thread_ts 가 대상 ts 와 일치하면 스레드 메시지가 아닌 댓글이 있는 일반 메시지입니다.\n            if thread_ts == ts:\n                return False\n\n            # thread_ts 가 대상 ts 와 일치하지 않으면 일반 메시지가 아닌 스레드 메시지입니다.\n            else:\n                return True\n\n    return False\n\n\ndef _is_checked_notice(user_id: str, notice_ts: str) -> bool:\n    \"\"\"이전에 공지를 확인한 적이 있는지 확인합니다.\"\"\"\n    file_path = \"store/_checked_notice.csv\"\n    file_exists = os.path.isfile(file_path)\n\n    if file_exists:\n        with open(file_path) as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                if row[\"user_id\"] == user_id and row[\"notice_ts\"] == notice_ts:\n                    return True\n\n    return False\n\n\ndef _write_checked_notice(user_id: str, notice_ts: str) -> None:\n    \"\"\"공지 확인 기록을 저장합니다.\"\"\"\n    # 공지 확인 기록은 스프레드시트에 업로드 하지 않습니다. 이 경우 파일명 앞에 _를 붙입니다.\n    file_path = \"store/_checked_notice.csv\"\n    file_exists = os.path.isfile(file_path)\n\n    with open(file_path, \"a\", newline=\"\", encoding=\"utf-8\") as f:\n        writer = csv.DictWriter(\n            f,\n            fieldnames=[\"user_id\", \"notice_ts\", \"created_at\"],\n            quoting=csv.QUOTE_ALL,\n        )\n\n        if not file_exists:\n            writer.writeheader()\n\n        writer.writerow(\n            {\n                \"user_id\": user_id,\n                \"notice_ts\": notice_ts,\n                \"created_at\": tz_now_to_str(),\n            }\n        )\n\n\ndef _is_checked_super_admin_post(user_id: str, post_id: str) -> bool:\n    \"\"\"이전에 성윤님 글을 확인한 적이 있는지 확인합니다.\"\"\"\n    file_path = \"store/_checked_super_admin_post.csv\"\n    file_exists = os.path.isfile(file_path)\n\n    if file_exists:\n        with open(file_path) as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                if row[\"user_id\"] == user_id and row[\"post_id\"] == post_id:\n                    return True\n\n    return False\n\n\ndef _write_checked_super_admin_post(\n    user_id: str, post_id: str, channel_id: str\n) -> None:\n    \"\"\"성윤님 글 확인 기록을 저장합니다.\"\"\"\n    # 이 기록은 스프레드시트에 업로드 하지 않습니다. 이 경우 파일명 앞에 _를 붙입니다.\n    file_path = \"store/_checked_super_admin_post.csv\"\n    file_exists = os.path.isfile(file_path)\n\n    with open(file_path, \"a\", newline=\"\", encoding=\"utf-8\") as f:\n        writer = csv.DictWriter(\n            f,\n            fieldnames=[\"user_id\", \"post_id\", \"channel_id\", \"created_at\"],\n            quoting=csv.QUOTE_ALL,\n        )\n\n        if not file_exists:\n            writer.writeheader()\n\n        writer.writerow(\n            {\n                \"user_id\": user_id,\n                \"post_id\": post_id,\n                \"channel_id\": channel_id,\n                \"created_at\": tz_now_to_str(),\n            }\n        )\n\n\nasync def handle_reaction_removed(\n    ack: AsyncAck,\n    body: ReactionBodyType,\n):\n    \"\"\"리액션 삭제 이벤트를 처리합니다.\"\"\"\n    await ack()\n"}
{"type": "source_file", "path": "app/slack/services/__init__.py", "content": ""}
{"type": "source_file", "path": "app/slack/services/base.py", "content": "from datetime import datetime, timedelta\nimport random\nimport re\nfrom typing import Any\nfrom zoneinfo import ZoneInfo\n\nimport httpx\nfrom app.constants import URL_REGEX\nfrom app.logging import logger\nfrom app.exception import BotException, ClientException\nfrom app.slack.repositories import SlackRepository\nfrom app import models\nfrom app import store\nfrom app.constants import paper_plane_color_maps\n\nfrom bs4 import BeautifulSoup\n\nfrom app.utils import tz_now, tz_now_to_str\n\n\nclass SlackService:\n    def __init__(self, repo: SlackRepository, user: models.User) -> None:\n        self._repo = repo\n        self._user = user\n\n    def fetch_contents(\n        self,\n        keyword: str | None = None,\n        name: str | None = None,\n        category: str = \"전체\",\n    ) -> list[models.Content]:\n        \"\"\"콘텐츠를 조건에 맞춰 가져옵니다.\"\"\"\n        if keyword:\n            contents = self._repo.fetch_contents_by_keyword(keyword)\n        else:\n            contents = self._repo.fetch_contents()\n\n        if name:\n            user_ids = self._repo.fetch_user_ids_by_name(name)\n            contents = [content for content in contents if content.user_id in user_ids]\n\n        if category != \"전체\":\n            contents = [content for content in contents if content.category == category]\n\n        return contents\n\n    def get_user(self, user_id) -> models.User:\n        \"\"\"유저와 콘텐츠 정보를 가져옵니다.\"\"\"\n        user = self._repo.get_user(user_id)\n        if not user:\n            raise BotException(\"해당 유저 정보가 없어요.\")\n        return user\n\n    def get_only_user(self, user_id) -> models.User:\n        \"\"\"유저 정보만 가져옵니다.\"\"\"\n        user = self._repo.get_only_user(user_id)\n        if not user:\n            raise BotException(\"해당 유저 정보가 없어요.\")\n        return user\n\n    async def create_submit_content(\n        self,\n        title: str,\n        content_url: str,\n        username: str,\n        view: dict[str, Any],\n    ) -> models.Content:\n        \"\"\"제출 콘텐츠를 생성합니다.\"\"\"\n        content = models.Content(\n            user_id=self._user.user_id,\n            username=username,\n            title=title,\n            content_url=content_url,\n            category=self._get_category(view),\n            description=self._get_description(view),\n            type=\"submit\",\n            tags=self._get_tags(view),\n            curation_flag=self._get_curation_flag(view),\n            feedback_intensity=self._get_feedback_intensity(view),\n        )\n        return content\n\n    async def update_user_content(self, content: models.Content) -> None:\n        \"\"\"유저의 콘텐츠를 업데이트합니다.\"\"\"\n        self._user.contents.append(content)\n        self._repo.update(self._user)\n\n    async def create_pass_content(self, ack, body, view) -> models.Content:\n        \"\"\"패스 콘텐츠를 생성합니다.\"\"\"\n        content = models.Content(\n            user_id=body[\"user\"][\"id\"],\n            username=body[\"user\"][\"username\"],\n            description=self._get_description(view),\n            type=\"pass\",\n        )\n        return content\n\n    def get_chat_message(self, content: models.Content) -> str:\n        if content.type == \"submit\":\n            title = content.title.replace(\"\\n\", \" \")\n            message = f\"\\n>>>🎉 *<@{content.user_id}>님 제출 완료.*\\\n                {self._description_message(content.description)}\\\n                \\n링크 : *<{content.content_url}|{re.sub('<|>', '', title if content.title != 'title unknown.' else content.content_url)}>*\\\n                \\n카테고리 : {content.category}\\\n                {self._tag_message(content.tags)}\"  # noqa E501\n        else:\n            message = f\"\\n>>>🙏🏼 *<@{content.user_id}>님 패스 완료.*\\\n                {self._description_message(content.description)}\"\n        return message\n\n    def _get_description(self, view) -> str:\n        description: str = view[\"state\"][\"values\"][\"description\"][\"text_input\"][\"value\"]\n        if not description:\n            return \"\"\n        return description\n\n    def _get_tags(self, view) -> str:\n        raw_tag: str = view[\"state\"][\"values\"][\"tag\"][\"tags_input\"][\"value\"]\n        if not raw_tag:\n            return \"\"\n        deduplication_tags = list(dict.fromkeys(raw_tag.split(\",\")))\n        tags = \",\".join(tag.strip() for tag in deduplication_tags if tag)\n        return tags\n\n    def _get_category(self, view) -> str:\n        category: str = view[\"state\"][\"values\"][\"category\"][\"category_select\"][\n            \"selected_option\"\n        ][\"value\"]\n        return category\n\n    def _get_curation_flag(self, view) -> str:\n        curation_flag: str = view[\"state\"][\"values\"][\"curation\"][\"curation_select\"][\n            \"selected_option\"\n        ][\"value\"]\n        return curation_flag\n\n    def _get_feedback_intensity(self, view) -> str:\n        feedback_intensity: str = view[\"state\"][\"values\"][\"feedback_intensity\"][\n            \"feedback_intensity_select\"\n        ][\"selected_option\"][\"value\"]\n        return feedback_intensity\n\n    async def get_title(self, view, url: str) -> str:\n\n        try:\n            async with httpx.AsyncClient() as client:\n                response = await client.get(url)\n                if response.status_code == 404:\n                    raise ClientException(\n                        f\"비공개 글이거나, url을 찾을 수 없어요. 상태 코드 : {response.status_code}\"\n                    )\n                if response.status_code >= 400:\n                    raise ClientException(\n                        f\"url에 문제가 있어 확인이 필요해요. 상태 코드 : {response.status_code}\"\n                    )\n\n            # 제목을 직접 입력한 경우에는 status_code만 확인 후에 return\n            title_input = view[\"state\"][\"values\"][\"manual_title_input\"][\"title_input\"][\n                \"value\"\n            ]\n            if title_input:\n                return title_input\n\n            soup = BeautifulSoup(response.content, \"html.parser\", from_encoding=\"utf-8\")\n            title = soup.find(\"title\")\n            if not title:\n                raise ClientException(\n                    \"'글 제목'을 찾을 수 없습니다. 모달 하단에 직접 입력해주세요.\"\n                )\n            return title.text.strip()\n\n        except ClientException as e:\n            raise e\n        except Exception as e:\n            logger.debug(str(e))\n            raise ClientException(\"url 에 문제가 있어요. 확인 후 다시 시도해주세요.\")\n\n    def _description_message(self, description: str) -> str:\n        description_message = f\"\\n\\n💬 '{description}'\\n\" if description else \"\"\n        return description_message\n\n    def _tag_message(self, tag: str) -> str:\n        tag_message = (\n            \"\\n태그 : \" + \" \".join([f\"`{t.strip()}`\" for t in tag.split(\",\")])\n            if tag\n            else \"\"\n        )\n        return tag_message\n\n    def validate_url(self, view, content_url: str) -> None:\n        if not re.match(URL_REGEX, content_url):\n            raise ValueError(\"링크는 url 형식이어야 해요.\")\n\n        try:\n            content = self.get_content_by(content_url=content_url)\n            if content:\n                raise ValueError(\"이미 제출한 url 이에요.\")\n        except BotException:\n            # 존재하지 않는 url 인 경우 통과\n            pass\n\n        if \"tistory.com/manage/posts\" in content_url:\n            # 티스토리 posts 페이지는 글 링크가 아니므로 제외합니다.\n            raise ValueError(\"잠깐! 입력한 링크가 '글 링크'가 맞는지 확인해주세요.\")\n        if \"blog.naver.com\" in content_url and \"redirect\" in content_url.lower():\n            # 네이버 블로그 리다이렉트 링크는 글 링크가 아니므로 제외합니다.\n            raise ValueError(\n                \"잠깐! 입력한 링크는 리다이렉트 링크입니다. 다시 확인해주세요.\"\n            )\n        if (\n            \"notion.\" in content_url\n            or \"oopy.io\" in content_url\n            or \".site\" in content_url\n            or \"blog.naver\" in content_url\n        ):\n            # notion.so, notion.site, oopy.io 는 title 을 크롤링하지 못하므로 직접 입력을 받는다.\n            # blog.naver 는 title 태그에 블로그 타이틀이 들어오기 때문에 글 제목을 직접 입력을 받는다.\n            # 글 제목을 입력한 경우 통과.\n            if (\n                view[\"state\"][\"values\"]\n                .get(\"manual_title_input\", {})\n                .get(\"title_input\", {})\n                .get(\"value\")\n            ):\n                return None\n            raise ValueError(\n                \"노션 또는 네이버 링크는 하단 '글 제목'을 필수로 입력해주세요.\"\n            )\n\n    def create_bookmark(\n        self,\n        user_id: str,\n        content_user_id: str,\n        content_ts: str,\n        note: str = \"\",\n    ) -> models.Bookmark:\n        \"\"\"북마크를 생성합니다.\"\"\"\n        bookmark = models.Bookmark(\n            user_id=user_id,\n            content_user_id=content_user_id,\n            content_ts=content_ts,\n            note=note,\n        )\n        self._repo.create_bookmark(bookmark)\n        store.bookmark_upload_queue.append(bookmark.to_list_for_sheet())\n        return bookmark\n\n    def get_bookmark(self, user_id: str, content_ts: str) -> models.Bookmark | None:\n        \"\"\"북마크를 가져옵니다.\"\"\"\n        bookmark = self._repo.get_bookmark(user_id, content_ts)\n        return bookmark\n\n    def fetch_bookmarks(self, user_id: str) -> list[models.Bookmark]:\n        \"\"\"유저의 북마크를 모두 가져옵니다.\"\"\"\n        # TODO: 키워드로 검색 기능 추가\n        bookmarks = self._repo.fetch_bookmarks(user_id)\n        return bookmarks\n\n    def fetch_contents_by_ids(\n        self, content_ids: list[str], keyword: str = \"\"\n    ) -> list[models.Content]:\n        \"\"\"컨텐츠 아이디로 Contents 를 가져옵니다.\"\"\"\n        if keyword:\n            contents = self._repo.fetch_contents_by_keyword(keyword)\n        else:\n            contents = self._repo.fetch_contents()\n        return [content for content in contents if content.ts in content_ids]\n\n    def update_bookmark(\n        self,\n        user_id: str,\n        content_ts: str,\n        new_note: str = \"\",\n        new_status: models.BookmarkStatusEnum = models.BookmarkStatusEnum.ACTIVE,\n    ) -> None:\n        \"\"\"북마크를 업데이트합니다.\"\"\"\n        # TODO: 북마크 삭제와 수정 분리할 것\n        self._repo.update_bookmark(content_ts, new_note, new_status)\n        bookmark = self._repo.get_bookmark(user_id, content_ts, status=new_status)\n        if bookmark:\n            store.bookmark_update_queue.append(bookmark)\n\n    def update_user_intro(\n        self,\n        user_id: str,\n        new_intro: str,\n    ) -> None:\n        \"\"\"사용자의 자기소개를 수정합니다.\"\"\"\n        if self._user.user_id != user_id:\n            raise BotException(\"본인의 자기소개만 수정할 수 있습니다.\")\n        self._repo.update_user_intro(user_id, new_intro)\n\n    def fetch_users(self) -> list[models.User]:\n        users = [models.User(**user) for user in self._repo._fetch_users()]\n        return users\n\n    def get_content_by(\n        self,\n        *,\n        ts: str | None = None,\n        user_id: str | None = None,\n        dt: str | None = None,\n        content_url: str | None = None,\n    ) -> models.Content:\n        content = self._repo.get_content_by(\n            ts=ts,\n            user_id=user_id,\n            dt=dt,\n            content_url=content_url,\n        )\n        if not content:\n            raise BotException(\"해당 콘텐츠 정보가 없어요.\")\n\n        return content\n\n    def fetch_coffee_chat_proofs(\n        self,\n        user_id: str,\n    ) -> list[models.CoffeeChatProof]:\n        \"\"\"커피챗 인증 내역을 가져옵니다.\"\"\"\n        return self._repo.fetch_coffee_chat_proofs(user_id=user_id)\n\n    def create_coffee_chat_proof(\n        self,\n        ts: str,\n        thread_ts: str,\n        user_id: str,\n        text: str,\n        files: list[dict[str, Any]],\n        selected_user_ids: str,\n        participant_call_thread_ts: str = \"\",\n    ) -> models.CoffeeChatProof:\n        \"\"\"커피챗 인증글을 생성합니다.\"\"\"\n        try:\n            image_urls = \",\".join(file[\"url_private\"] for file in files)\n        except KeyError:\n            image_urls = \"\"\n\n        coffee_chat_proof = models.CoffeeChatProof(\n            ts=ts,\n            thread_ts=thread_ts,\n            user_id=user_id,\n            text=text,\n            image_urls=image_urls,\n            selected_user_ids=selected_user_ids,\n            participant_call_thread_ts=participant_call_thread_ts,\n        )\n        self._repo.create_coffee_chat_proof(coffee_chat_proof)\n        store.coffee_chat_proof_upload_queue.append(\n            coffee_chat_proof.to_list_for_sheet()\n        )\n        return coffee_chat_proof\n\n    def check_coffee_chat_proof(\n        self,\n        thread_ts: str,\n        user_id: str,\n    ) -> None:\n        \"\"\"\n        커피챗 인증 가능 여부를 확인합니다.\n\n        1. 스레드의 상위 메시지(thread_ts)로 기존 커피챗 인증 글(ts)이 존재하지 않으면, 인증할 수 없습니다.\n        2. 인증 대상자 목록(selected_user_ids)에 해당 사용자의 user_id가 포함되어 있지 않으면, 인증할 수 없습니다.\n        3. 동일한 user_id로 이미 커피챗 인증이 되어 있는 경우, 중복 인증을 할 수 없습니다.\n        \"\"\"\n        parent_proof = self._repo.get_coffee_chat_proof(ts=thread_ts)\n        if not parent_proof:\n            raise BotException(\"커피챗 인증글을 찾을 수 없어요.\")\n\n        if user_id not in parent_proof.selected_user_ids:\n            raise BotException(\"커피챗 인증 대상이 아니에요.\")\n\n        proofs = self._repo.fetch_coffee_chat_proofs(thread_ts=thread_ts)\n        for proof in proofs:\n            if proof.user_id == user_id:\n                raise BotException(\"이미 답글로 커피챗을 인증했어요.\")\n\n    def create_paper_plane(\n        self,\n        *,\n        sender: models.User,\n        receiver: models.User,\n        text: str,\n    ) -> models.PaperPlane:\n        \"\"\"리액션을 생성합니다.\"\"\"\n        color_map = random.choice(paper_plane_color_maps)\n        model = models.PaperPlane(\n            sender_id=sender.user_id,\n            sender_name=sender.name,\n            receiver_id=receiver.user_id,\n            receiver_name=receiver.name,\n            text=text,\n            text_color=color_map[\"text_color\"],\n            bg_color=color_map[\"bg_color\"],\n            color_label=color_map[\"color_label\"],\n        )\n        self._repo.create_paper_plane(model)\n        store.paper_plane_upload_queue.append(model.to_list_for_sheet())\n        return model\n\n    def fetch_current_week_paper_planes(\n        self,\n        user_id: str,\n    ) -> list[models.PaperPlane]:\n        \"\"\"이번 주 종이비행기를 가져옵니다.\"\"\"\n        today = tz_now()\n\n        # 지난주 토요일 00시 계산\n        last_saturday = today - timedelta(days=(today.weekday() + 2) % 7)\n        start_dt = last_saturday.replace(hour=0, minute=0, second=0, microsecond=0)\n\n        # 이번주 금요일 23:59:59 계산\n        this_friday = start_dt + timedelta(days=6)\n        end_dt = this_friday.replace(hour=23, minute=59, second=59, microsecond=999999)\n\n        paper_planes = []\n        for plane in self._repo.fetch_paper_planes(sender_id=user_id):\n            plane_created_ad = datetime.fromisoformat(plane.created_at).replace(\n                tzinfo=ZoneInfo(\"Asia/Seoul\")\n            )\n            if start_dt <= plane_created_ad <= end_dt:\n                paper_planes.append(plane)\n\n        return paper_planes\n\n    def fetch_subscriptions_by_user_id(\n        self,\n        user_id: str,\n    ) -> list[models.Subscription]:\n        \"\"\"유저의 구독 내역을 가져옵니다.\"\"\"\n        return self._repo.fetch_subscriptions_by_user_id(user_id)\n\n    def fetch_subscriptions_by_target_user_id(\n        self,\n        target_user_id: str,\n    ) -> list[models.Subscription]:\n        \"\"\"타겟 유저의 구독 내역을 가져옵니다.\"\"\"\n        return self._repo.fetch_subscriptions_by_target_user_id(target_user_id)\n\n    def create_subscription(\n        self, user_id: str, target_user_id: str, target_user_channel: str\n    ) -> models.Subscription:\n        \"\"\"구독을 생성합니다.\"\"\"\n        subscription = models.Subscription(\n            user_id=user_id,\n            target_user_id=target_user_id,\n            target_user_channel=target_user_channel,\n        )\n        self._repo.create_subscription(subscription)\n        store.subscription_upload_queue.append(subscription.to_list_for_sheet())\n        return subscription\n\n    def get_subscription(self, subscription_id: str) -> models.Subscription | None:\n        \"\"\"구독을 가져옵니다.\"\"\"\n        return self._repo.get_subscription(subscription_id)\n\n    def cancel_subscription(self, subscription_id: str) -> None:\n        \"\"\"구독을 취소합니다.\"\"\"\n        self._repo.cancel_subscription(subscription_id)\n        subscription = self._repo.get_subscription(\n            subscription_id, status=models.SubscriptionStatusEnum.CANCELED\n        )\n        if subscription:\n            subscription.updated_at = tz_now_to_str()\n            store.subscription_update_queue.append(subscription.model_dump())\n"}
{"type": "source_file", "path": "app/slack/events/core.py", "content": "import asyncio\nimport csv\nimport os\nfrom typing import TypedDict\nimport tenacity\nimport pandas as pd\n\nfrom app.client import SpreadSheetClient\nfrom app.config import settings\nfrom app.constants import BOT_IDS\nfrom app.models import CoffeeChatProof, Content, PointHistory, User\nfrom app.slack.services.base import SlackService\nfrom app.slack.services.point import PointMap, PointService\nfrom app.slack.types import (\n    ActionBodyType,\n    AppMentionBodyType,\n    ChannelCreatedBodyType,\n    CommandBodyType,\n    HomeTabEventType,\n    ViewBodyType,\n    ViewType,\n)\nfrom app.store import Store\n\nfrom slack_sdk.models.blocks import (\n    Block,\n    Option,\n    StaticSelectElement,\n    SectionBlock,\n    DividerBlock,\n    ActionsBlock,\n    ButtonElement,\n    PlainTextInputElement,\n    ChannelMultiSelectElement,\n    UserSelectElement,\n    InputBlock,\n    TextObject,\n    HeaderBlock,\n    ContextBlock,\n    MarkdownTextObject,\n)\nfrom slack_sdk.models.views import View\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom slack_sdk.errors import SlackApiError\n\nfrom app.utils import ts_to_dt\n\n\nasync def handle_app_mention(\n    ack: AsyncAck,\n    body: AppMentionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n) -> None:\n    \"\"\"앱 멘션 호출 시 도움말 메시지를 전송합니다.\"\"\"\n    await ack()\n\n\nasync def open_deposit_view(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"예치금을 조회합니다.\"\"\"\n    await ack()\n\n    if not user.deposit:\n        text = \"현재 예치금 확인 중이에요.\"\n    else:\n        # 남은 패스 수\n        remained_pass_count = 2\n        remained_pass_count -= user.pass_count\n\n        # 미제출 수\n        submit_status = user.get_submit_status()\n        not_submitted_count = list(submit_status.values()).count(\"미제출\")\n\n        # 커피챗 인증 수\n        coffee_chat_proofs = service.fetch_coffee_chat_proofs(user_id=user.user_id)\n        coffee_chat_proofs_count = len(coffee_chat_proofs)\n\n        text = (\n            f\"{user.name[1:]}님의 현재 남은 예치금은 {format(int(user.deposit), ',d')} 원 이에요.\"\n            + f\"\\n\\n- 남은 패스 수 : {remained_pass_count} 개\"\n            + f\"\\n- 글 미제출 수 : {not_submitted_count} 개\"\n            + f\"\\n- 커피챗 인증 수 : {coffee_chat_proofs_count} 개\"\n            # + f\"\\n반상회 참여 : (추후 제공 예정)\"  # TODO: 추후 반상회 참여 시 예치금에 변동이 있다면 추가. (모임 크루에서 결정)\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{user.name}님의 예치금 현황\",\n            close=\"닫기\",\n            blocks=[\n                SectionBlock(text=text),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=\"글 미제출 시 예치금 10,000원이 차감됩니다.\"\n                            \"\\n커피챗 인증 시 1회당 예치금 5,000원이 더해집니다. (최대 2회)\",\n                        ),\n                    ]\n                ),\n            ],\n        ),\n    )\n\n\nasync def open_submission_history_view(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"제출 내역을 조회합니다.\"\"\"\n    await ack()\n\n    round, due_date = user.get_due_date()\n    guide_message = f\"\\n현재 회차는 {round}회차, 마감일은 {due_date} 이에요.\"\n    header_blocks = [SectionBlock(text={\"type\": \"mrkdwn\", \"text\": guide_message})]\n\n    blocks: list[Block] = []\n    max_items = 12\n    for content in user.fetch_contents(descending=True)[:max_items]:\n        blocks.append(DividerBlock())\n        round = content.get_round()\n        if content.type == \"submit\":\n            submit_head = f\"✅  *{round}회차 제출*  |  {content.dt}\"\n            blocks.append(\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": f\"{submit_head}\\n링크 - *<{content.content_url}|{content.title}>*\",\n                    }\n                )\n            )\n        else:  # 패스인 경우\n            pass_head = f\"▶️  *{round}회차 패스*  |  {content.dt}\"\n            blocks.append(\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": pass_head,\n                    }\n                )\n            )\n\n    footer_blocks = []\n    if blocks:\n        footer_blocks = [\n            DividerBlock(),\n            SectionBlock(\n                text=\"글 제출 내역은 최근 12개까지만 표시됩니다.\\n전체 내역을 확인하려면 아래 버튼을 눌러주세요.\",\n            ),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"전체 내역 다운로드\",\n                        action_id=\"download_submission_history\",\n                        value=\"download_submission_history\",\n                        style=\"primary\",\n                    ),\n                ],\n            ),\n        ]\n    else:\n        blocks.append(\n            SectionBlock(text={\"type\": \"mrkdwn\", \"text\": \"글 제출 내역이 없어요.\"})\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title={\"type\": \"plain_text\", \"text\": f\"{user.name}님의 글 제출 내역\"},\n            close={\"type\": \"plain_text\", \"text\": \"닫기\"},\n            blocks=header_blocks + blocks + footer_blocks,\n        ),\n    )\n\n\nasync def download_submission_history(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"글 제출 내역을 CSV 파일로 다운로드합니다.\"\"\"\n    await ack()\n\n    response = await client.conversations_open(users=user.user_id)\n    dm_channel_id = response[\"channel\"][\"id\"]\n\n    contents = user.fetch_contents()\n    if not contents:\n        await client.chat_postMessage(\n            channel=dm_channel_id, text=\"글 제출 내역이 없습니다.1\"\n        )\n        return None\n\n    # 사용자의 제출내역을 CSV 파일로 임시 저장 후 전송\n    temp_dir = \"temp/submission_histories\"\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir)\n\n    temp_file_path = f\"{temp_dir}/{user.name}-글-제출-내역.csv\"\n    with open(temp_file_path, \"w\", newline=\"\") as csvfile:\n        writer = csv.DictWriter(\n            csvfile,\n            Content.fieldnames(),\n            quoting=csv.QUOTE_ALL,\n        )\n        writer.writeheader()\n        writer.writerows([each.model_dump() for each in contents])\n\n    res = await client.files_upload_v2(\n        channel=dm_channel_id,  #####\n        file=temp_file_path,\n        initial_comment=f\"<@{user.user_id}> 님의 글 제출 내역 입니다.\",\n    )\n\n    await client.chat_postMessage(\n        channel=dm_channel_id,\n        text=f\"<@{user.user_id}> 님의 <{res['file']['permalink']}|글 제출 내역> 입니다.\",\n    )\n\n    # 임시로 생성한 CSV 파일을 삭제\n    os.remove(temp_file_path)\n\n\nasync def open_help_view(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"도움말을 조회합니다.\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title={\"type\": \"plain_text\", \"text\": \"또봇 도움말\"},\n            close={\"type\": \"plain_text\", \"text\": \"닫기\"},\n            blocks=[\n                # 인사말 섹션\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"👋🏼 *반가워요!*\\n저는 글또 활동을 도와주는 *또봇* 이에요. \"\n                        \"여러분이 글로 더 많이 소통할 수 있도록 다양한 기능을 제공하고 있어요.\",\n                    }\n                ),\n                DividerBlock(),\n                # 명령어 안내\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*💬 사용 가능한 명령어 안내*\\n\\n\"\n                        \"*`/제출`* - 이번 회차의 글을 제출할 수 있어요.\\n\"\n                        \"*`/패스`* - 이번 회차의 글을 패스할 수 있어요.\\n\"\n                        \"*`/제출내역`* - 자신의 글 제출내역을 볼 수 있어요.\\n\"\n                        \"*`/검색`* - 다른 사람들의 글을 검색할 수 있어요.\\n\"\n                        \"*`/북마크`* - 북마크한 글을 볼 수 있어요.\\n\"\n                        \"*`/예치금`* - 현재 남은 예치금을 알려드려요.\\n\"\n                        \"*`/도움말`* - 또봇 사용법을 알려드려요.\\n\"\n                        \"*`/종이비행기`* - 종이비행기를 보낼 수 있어요.\\n\",\n                    }\n                ),\n                DividerBlock(),\n                # 문의 및 코드 안내\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"🙌 *도움이 필요하신가요?*\\n\\n\"\n                        f\"궁금한 사항이 있다면 <#{settings.BOT_SUPPORT_CHANNEL}> 채널로 문의해주세요!\\n\"\n                        \"또봇 코드가 궁금하다면 👉🏼 *<https://github.com/Daco2020/ttobot|또봇 깃허브>* 로 놀러오세요~ 🤗\",\n                    }\n                ),\n            ],\n        ),\n    )\n\n\nasync def admin_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"관리자 메뉴를 조회합니다.\"\"\"\n    await ack()\n\n    if user.user_id not in settings.ADMIN_IDS:\n        raise PermissionError(\"`/관리자` 명령어는 관리자만 호출할 수 있어요. 🤭\")\n\n    text = \"관리자 메뉴입니다.\"\n    await client.chat_postEphemeral(\n        channel=body[\"channel_id\"],\n        user=user.user_id,\n        text=text,\n        blocks=[\n            SectionBlock(text=text),\n            DividerBlock(),\n            SectionBlock(text=\"1. 테이블을 동기화합니다.\"),\n            ActionsBlock(\n                block_id=\"sync_store_block\",\n                elements=[\n                    StaticSelectElement(\n                        placeholder=\"동기화 선택\",\n                        action_id=\"sync_store_select\",\n                        options=[\n                            Option(text=\"전체\", value=\"전체\"),\n                            Option(text=\"유저\", value=\"유저\"),\n                            Option(text=\"컨텐츠\", value=\"컨텐츠\"),\n                            Option(text=\"북마크\", value=\"북마크\"),\n                            Option(text=\"커피챗 인증\", value=\"커피챗 인증\"),\n                            Option(text=\"포인트 히스토리\", value=\"포인트 히스토리\"),\n                            Option(text=\"종이비행기\", value=\"종이비행기\"),\n                            Option(text=\"구독\", value=\"구독\"),\n                        ],\n                    ),\n                ],\n            ),\n            DividerBlock(),\n            SectionBlock(text=\"2. 특정 멤버를 특정 채널에 초대합니다.\"),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"채널 초대\",\n                        action_id=\"invite_channel\",\n                        value=\"invite_channel\",\n                    ),\n                ],\n            ),\n        ],\n    )\n\n\nasync def handle_sync_store(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"데이터 동기화를 수행합니다.\"\"\"\n    await ack()\n\n    value = body[\"state\"][\"values\"][\"sync_store_block\"][\"sync_store_select\"][\n        \"selected_option\"\n    ][\"value\"]\n\n    try:\n        await client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL, text=f\"{value} 데이터 동기화 시작\"\n        )\n        # # TODO: 슬랙으로 백업파일 보내기\n        store = Store(client=SpreadSheetClient())\n\n        if value == \"전체\":\n            store.pull_all()\n        elif value == \"유저\":\n            store.pull_users()\n        elif value == \"컨텐츠\":\n            store.pull_contents()\n        elif value == \"북마크\":\n            store.pull_bookmark()\n        elif value == \"커피챗 인증\":\n            store.pull_coffee_chat_proof()\n        elif value == \"포인트 히스토리\":\n            store.pull_point_histories()\n        elif value == \"종이비행기\":\n            store.pull_paper_plane()\n        elif value == \"구독\":\n            store.pull_subscriptions()\n        else:\n            await client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=\"동기화 테이블이 존재하지 않습니다.\",\n            )\n\n        await client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL, text=f\"{value} 데이터 동기화 완료\"\n        )\n\n    except Exception as e:\n        await client.chat_postMessage(channel=settings.ADMIN_CHANNEL, text=str(e))\n\n\nasync def handle_invite_channel(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"채널 초대를 수행합니다.\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=\"채널 초대\",\n            submit=\"채널 초대하기\",\n            callback_id=\"invite_channel_view\",\n            close=\"닫기\",\n            blocks=[\n                SectionBlock(\n                    text=\"초대하고 싶은 멤버와 채널을 선택해주세요.\",\n                ),\n                InputBlock(\n                    block_id=\"user\",\n                    label=\"멤버\",\n                    optional=False,\n                    element=UserSelectElement(\n                        action_id=\"select_user\",\n                        placeholder=\"멤버를 선택해주세요.\",\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"channel\",\n                    label=\"채널\",\n                    optional=True,\n                    element=ChannelMultiSelectElement(\n                        action_id=\"select_channels\",\n                        placeholder=\"채널을 선택하지 않으면 모든 공개 채널에 초대합니다.\",\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def handle_invite_channel_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"채널 초대를 수행합니다.\"\"\"\n    await ack()\n\n    values = body[\"view\"][\"state\"][\"values\"]\n    user_id = values[\"user\"][\"select_user\"][\"selected_user\"]\n    channel_ids = values[\"channel\"][\"select_channels\"][\"selected_channels\"]\n\n    if not channel_ids:\n        channel_ids = await _fetch_public_channel_ids(client)\n\n    await client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=f\"<@{user_id}> 님의 채널 초대를 시작합니다.\\n\\n채널 수 : {len(channel_ids)} 개\\n\",\n    )\n\n    for channel_id in channel_ids:\n        await _invite_channel(client, user_id, channel_id)\n\n    await client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=\"채널 초대가 완료되었습니다.\",\n    )\n\n\n@tenacity.retry(\n    stop=tenacity.stop_after_attempt(3),\n    wait=tenacity.wait_fixed(1),\n    reraise=True,\n)\nasync def _fetch_public_channel_ids(client: AsyncWebClient) -> list[str]:\n    \"\"\"모든 공개 채널의 아이디를 조회합니다.\"\"\"\n    res = await client.conversations_list(limit=500, types=\"public_channel\")\n    return [channel[\"id\"] for channel in res[\"channels\"]]\n\n\n@tenacity.retry(\n    stop=tenacity.stop_after_attempt(3),\n    wait=tenacity.wait_fixed(1),\n    reraise=True,\n)\nasync def _invite_channel(\n    client: AsyncWebClient,\n    user_id: str,\n    channel_id: str,\n) -> None:\n    \"\"\"채널에 멤버를 초대합니다.\"\"\"\n    try:\n        await client.conversations_invite(channel=channel_id, users=user_id)\n        result = \" -> ✅ (채널 초대)\"\n    except SlackApiError as e:\n        # 봇이 채널에 없는 경우, 채널에 참여하고 초대합니다.\n        if e.response[\"error\"] == \"not_in_channel\":\n            await client.conversations_join(channel=channel_id)\n            await client.conversations_invite(channel=channel_id, users=user_id)\n            result = \" -> ✅ (또봇도 함께 채널 초대)\"\n        elif e.response[\"error\"] == \"already_in_channel\":\n            result = \" -> ✅ (이미 채널에 참여 중)\"\n        elif e.response[\"error\"] == \"cant_invite_self\":\n            result = \" -> ✅ (또봇이 자기 자신을 초대)\"\n        else:\n            link = \"<https://api.slack.com/methods/conversations.invite#errors|문서 확인하기>\"\n            result = f\" -> 😵 ({e.response['error']}) 👉 {link}\"\n\n    await client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=f\"\\n<#{channel_id}>\" + result,\n    )\n\n\nasync def handle_home_tab(\n    event: HomeTabEventType,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n):\n    \"\"\"홈 탭을 열었을 때의 이벤트를 처리합니다.\"\"\"\n    if not user:\n        await client.views_publish(\n            user_id=event[\"user\"],\n            view=View(\n                type=\"home\",\n                blocks=[\n                    HeaderBlock(\n                        text=\"👋 반가워요! 저는 또봇이에요.\",\n                    ),\n                    DividerBlock(),\n                    SectionBlock(\n                        text=\"[홈] 탭은 글또 OT 이후에 공개될 예정이에요. 🙇‍♂️\\n만약 OT 이후에도 해당 화면이 표시된다면 [0_글또봇질문] 채널로 문의해주세요.\",\n                    ),\n                ],\n            ),\n        )\n        return\n\n    # 포인트 히스토리를 포함한 유저를 가져온다.\n    user_point_history = point_service.get_user_point(user_id=user.user_id)\n    combo_count = user.get_continuous_submit_count()\n\n    current_combo_point = \"\"\n    if combo_count < 1:\n        pass\n    elif combo_count in [3, 6, 9]:\n        current_combo_point = \"*+ ???(특별 콤보 보너스)* \"\n    else:\n        current_combo_point = (\n            \"*+ \" + str(PointMap.글_제출_콤보.point * combo_count) + \"(콤보 보너스)* \"\n        )\n\n    remain_paper_planes: str | int\n    if user.user_id == settings.SUPER_ADMIN:\n        remain_paper_planes = \"∞\"\n    else:\n        remain_paper_planes = \"∞\"\n        # paper_planes = service.fetch_current_week_paper_planes(user_id=user.user_id)\n        # remain_paper_planes = 7 - len(paper_planes) if len(paper_planes) < 7 else 0\n\n    # 홈 탭 메시지 구성\n    await client.views_publish(\n        user_id=user.user_id,\n        view=View(\n            type=\"home\",\n            blocks=[\n                # 포인트 시스템 섹션\n                HeaderBlock(\n                    text=\"🍭 내 글또 포인트\",\n                ),\n                SectionBlock(\n                    text=f\"현재 *{user.name[1:]}* 님이 획득한 총 포인트는 *{user_point_history.total_point} point* 입니다.\",\n                ),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=f\"이번 회차에 글을 제출하면 *100* {current_combo_point}point 를 얻을 수 있어요.\",\n                        ),\n                    ],\n                ),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"포인트 획득 내역 보기\",\n                            action_id=\"open_point_history_view\",\n                            value=\"open_point_history_view\",\n                        ),\n                        ButtonElement(\n                            text=\"포인트 획득 방법 알아보기\",\n                            action_id=\"open_point_guide_view\",\n                            value=\"open_point_guide_view\",\n                        ),\n                    ],\n                ),\n                DividerBlock(),\n                # 종이비행기 섹션\n                HeaderBlock(\n                    text=\"✈️ 종이비행기 보내기\",\n                ),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=f\"종이비행기는 글또 멤버에게 따뜻한 감사나 응원의 메시지를 보낼 수 있는 기능이에요.\\n*{user.name[1:]}* 님이 이번 주에 보낼 수 있는 종이비행기 수는 현재 *{remain_paper_planes}개* 입니다. 😊\",\n                        ),\n                    ],\n                ),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"종이비행기 보내기\",\n                            action_id=\"send_paper_plane_message\",\n                            style=\"primary\",\n                        ),\n                        ButtonElement(\n                            text=\"주고받은 종이비행기 보기\",\n                            action_id=\"open_paper_plane_url\",\n                            url=\"https://geultto-paper-plane.vercel.app\",\n                        ),\n                        ButtonElement(\n                            text=\"어떤 내용을 보내면 좋을까요?\",\n                            action_id=\"open_paper_plane_guide_view\",\n                            value=\"open_paper_plane_guide_view\",\n                        ),\n                    ],\n                ),\n                DividerBlock(),\n                # 글 제출 내역 관리 섹션\n                HeaderBlock(\n                    text=\"📚 슬기로운 글또 생활\",\n                ),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=f\"*{user.name[1:]}* 님이 궁금해할만한 내용들을 모아봤어요.\",\n                        ),\n                    ],\n                ),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"내가 제출한 글 보기\",\n                            action_id=\"open_submission_history_view\",\n                            value=\"open_submission_history_view\",\n                        ),\n                        ButtonElement(\n                            text=\"내가 북마크한 글 보기\",\n                            action_id=\"open_bookmark_page_view\",\n                            value=\"open_bookmark_page_view\",\n                        ),\n                        ButtonElement(\n                            text=\"내 커피챗 인증 내역 보기\",\n                            action_id=\"open_coffee_chat_history_view\",\n                            value=\"open_coffee_chat_history_view\",\n                        ),\n                        ButtonElement(\n                            text=\"남아있는 예치금 보기\",\n                            action_id=\"open_deposit_view\",\n                            value=\"open_deposit_view\",\n                        ),\n                        ButtonElement(\n                            text=\"또봇 기능 살펴보기\",\n                            action_id=\"open_help_view\",\n                            value=\"open_help_view\",\n                        ),\n                    ],\n                ),\n                DividerBlock(),\n                HeaderBlock(\n                    text=\"🍧 또봇 실험실\",\n                ),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=\"또봇의 새로운 기능들을 가장 먼저 만나보세요. 🤗\\n\"\n                            f\"버그 제보와 아이디어 제안은 <#{settings.BOT_SUPPORT_CHANNEL}> 채널로 부탁드려요. 🙏\",\n                        ),\n                    ],\n                ),\n                DividerBlock(),\n                SectionBlock(text=\"🔔 멤버 구독\"),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=\"구독한 멤버가 글을 제출하면 새 글 알림을 받을 수 있어요!\\n\"\n                            \"이 기능은 멤버의 제안으로 만들어졌어요. Special thanks to 채정현 🙇‍♂️\",\n                        ),\n                    ],\n                ),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"멤버 구독하기\",\n                            action_id=\"open_subscribe_member_view\",\n                            style=\"primary\",\n                        ),\n                    ]\n                ),\n            ],\n        ),\n    )\n\n\nasync def open_point_history_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"포인트 히스토리를 조회합니다.\"\"\"\n    await ack()\n\n    user_point_history = point_service.get_user_point(user_id=user.user_id)\n\n    footer_blocks: list[Block] = []\n    if user_point_history.total_point > 0:\n        footer_blocks = [\n            DividerBlock(),\n            SectionBlock(\n                text=\"포인트 획득 내역은 최근 20개까지만 표시됩니다.\\n전체 내역을 확인하려면 아래 버튼을 눌러주세요.\",\n            ),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"전체 내역 다운로드\",\n                        action_id=\"download_point_history\",\n                        value=\"download_point_history\",\n                        style=\"primary\",\n                    ),\n                ],\n            ),\n        ]\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{user_point_history.user.name}님의 포인트 획득 내역\",\n            close=\"닫기\",\n            blocks=[\n                SectionBlock(\n                    text=f\"총 *{user_point_history.total_point} point* 를 획득하셨어요.\",\n                ),\n                DividerBlock(),\n                SectionBlock(text=user_point_history.point_history_text),\n                *footer_blocks,\n            ],\n        ),\n    )\n\n\nasync def download_point_history(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"포인트 히스토리를 CSV 파일로 다운로드합니다.\"\"\"\n    await ack()\n\n    response = await client.conversations_open(users=user.user_id)\n    dm_channel_id = response[\"channel\"][\"id\"]\n\n    user_point = point_service.get_user_point(user_id=user.user_id)\n    if not user_point.point_histories:\n        await client.chat_postMessage(\n            channel=dm_channel_id, text=\"포인트 획득 내역이 없습니다.\"\n        )\n        return None\n\n    # 사용자의 제출내역을 CSV 파일로 임시 저장 후 전송\n    temp_dir = \"temp/point_histories\"\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir)\n\n    temp_file_path = f\"{temp_dir}/{user.name}-포인트-획득-내역.csv\"\n    with open(temp_file_path, \"w\", newline=\"\") as csvfile:\n        writer = csv.DictWriter(\n            csvfile,\n            PointHistory.fieldnames(),\n            quoting=csv.QUOTE_ALL,\n        )\n        writer.writeheader()\n        writer.writerows([each.model_dump() for each in user_point.point_histories])\n\n    res = await client.files_upload_v2(\n        channel=dm_channel_id,\n        file=temp_file_path,\n        initial_comment=f\"<@{user.user_id}> 님의 포인트 획득 내역 입니다.\",\n    )\n\n    await client.chat_postMessage(\n        channel=dm_channel_id,\n        text=f\"<@{user.user_id}> 님의 <{res['file']['permalink']}|포인트 획득 내역> 입니다.\",\n    )\n\n    # 임시로 생성한 CSV 파일을 삭제\n    os.remove(temp_file_path)\n\n\nasync def open_point_guide_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"포인트 획득 방법을 조회합니다.\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title={\"type\": \"plain_text\", \"text\": \"포인트 획득 방법\"},\n            close={\"type\": \"plain_text\", \"text\": \"닫기\"},\n            blocks=[\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"포인트는 다음과 같은 방법으로 획득할 수 있어요.\",\n                    }\n                ),\n                DividerBlock(),\n                # 글 제출 관련 포인트\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*🏆 글 제출 관련 포인트*\\n\"\n                        \"*`글 제출하기`* - 글을 제출하면 기본 *100 포인트* 획득\\n\"\n                        \"*`추가 글 제출`* - 동일 회차에 글을 추가로 제출할 때마다 *100 포인트* 획득\\n\"\n                        \"*`회차 연속 제출 콤보`* - 꾸준히 작성하면 *??? 포인트* 획득(꽤 많아요)\\n\"\n                        \"*`코어 채널 순위`* - 코어 채널 제출 순서에 따라 1, 2, 3등 각각 *50/30/20 포인트* 획득\",\n                    }\n                ),\n                DividerBlock(),\n                # 참여 관련 포인트\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*🏡 참여 관련 포인트*\\n\"\n                        \"*`커피챗 인증`* - 커피챗을 인증하면 *50 포인트* 획득\\n\"\n                        \"*`빌리지 반상회 참여`* - 반상회 참여 시 *50 포인트* 획득(수동 지급)\",\n                    }\n                ),\n                DividerBlock(),\n                # 큐레이션 관련 포인트\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*✍️ 큐레이션 관련 포인트*\\n\"\n                        \"*`큐레이션 요청`* - 글 제출 시 큐레이션을 요청하면 *10 포인트* 획득\\n\"\n                        \"*`큐레이션 선정`* - 큐레이션에 선정되면 추가 *200 포인트* 획득(수동 지급)\",\n                    }\n                ),\n                DividerBlock(),\n                # 공지사항 관련 포인트\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*📢 공지사항 관련 포인트*\\n\"\n                        \"*`공지사항 이모지`* - 공지사항에 :noti-check: 이모지를 3일 내에 남기면 *10 포인트* 획득\",\n                    }\n                ),\n                DividerBlock(),\n                # 자기소개 작성 포인트\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*👋 자기소개 작성 포인트*\\n\"\n                        \"*`자기소개 작성하기`* - 자기소개 작성 시 *100 포인트* 획득(수동 지급)\",\n                    }\n                ),\n                DividerBlock(),\n                # 기타 지급 포인트\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*🎁 기타 지급 포인트*\\n\"\n                        \"*`성윤을 잡아라`* - '1_[채널]'에서 성윤님 제출 글에 :catch-kyle: 이모지를 1일 내에 남기면 *30 포인트* 획득\",\n                    }\n                ),\n            ],\n        ),\n    )\n\n\nasync def send_paper_plane_message(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"종이비행기 메시지를 전송합니다.\"\"\"\n    await ack()\n\n    initial_user_id = body[\"actions\"][0].get(\"value\")\n    view = View(\n        type=\"modal\",\n        title=\"종이비행기 보내기\",\n        callback_id=\"send_paper_plane_message_view\",\n        close=\"닫기\",\n        submit=\"보내기\",\n        blocks=[\n            SectionBlock(\n                text=\"종이비행기에 전하고 싶은 마음을 적어주세요.\",\n            ),\n            ContextBlock(\n                elements=[\n                    MarkdownTextObject(\n                        text=f\"종이비행기를 보내면 <#{settings.THANKS_CHANNEL}> 채널로 알림이 전송됩니다.\"\n                        \"\\n[받는 사람]은 종이비행기를 확인할 때 [보낸 사람]을 알 수 있습니다.\"\n                    )\n                ],\n            ),\n            InputBlock(\n                block_id=\"paper_plane_receiver\",\n                label=\"받는 사람\",\n                element=UserSelectElement(\n                    action_id=\"select_user\",\n                    placeholder=\"받는 사람을 선택해주세요.\",\n                    initial_user=initial_user_id,\n                ),\n            ),\n            InputBlock(\n                block_id=\"paper_plane_message\",\n                label=\"메시지\",\n                element=PlainTextInputElement(\n                    max_length=300,\n                    action_id=\"paper_plane_message\",\n                    placeholder=\"종이비행기로 전할 마음을 적어주세요.\",\n                    multiline=True,\n                ),\n            ),\n        ],\n    )\n\n    callback_id = body.get(\"view\", {}).get(\"callback_id\")\n    if callback_id == \"paper_plane_command\":\n        # callback_id 가 있다면 모달에서 발생한 액션이므로 기존 모달을 업데이트합니다.\n        await client.views_update(\n            view_id=body[\"view\"][\"id\"],\n            view=view,\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=view,\n    )\n\n\nasync def send_paper_plane_message_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"종이비행기 메시지를 전송합니다.\"\"\"\n    values = body[\"view\"][\"state\"][\"values\"]\n    receiver_id = values[\"paper_plane_receiver\"][\"select_user\"][\"selected_user\"]\n    text = values[\"paper_plane_message\"][\"paper_plane_message\"][\"value\"]\n\n    if user.user_id == receiver_id:\n        await ack(\n            response_action=\"errors\",\n            errors={\n                \"paper_plane_receiver\": \"종이비행기는 자신에게 보낼 수 없어요. 😉\",\n            },\n        )\n        return\n\n    if len(text) > 300:\n        await ack(\n            response_action=\"errors\",\n            errors={\n                \"paper_plane_message\": \"종이비행기 메시지는 300자 이내로 작성해주세요. 😉\",\n            },\n        )\n        return\n\n    if receiver_id in BOT_IDS:\n        await ack(\n            response_action=\"errors\",\n            errors={\n                \"paper_plane_message\": \"봇에게 종이비행기를 보낼 수 없어요. 😉\",\n            },\n        )\n        return\n\n    if user.user_id == settings.SUPER_ADMIN:\n        pass\n    else:\n        pass\n        # paper_planes = service.fetch_current_week_paper_planes(user_id=user.user_id)\n        # if len(paper_planes) >= 7:\n        #     await ack(\n        #         response_action=\"errors\",\n        #         errors={\n        #             \"paper_plane_receiver\": \"종이비행기는 한 주에 7개까지 보낼 수 있어요. (토요일 00시에 충전)\",\n        #         },\n        #     )\n        #     return\n\n    await ack()\n\n    receiver = service.get_user(user_id=receiver_id)\n    service.create_paper_plane(\n        sender=user,\n        receiver=receiver,\n        text=text,\n    )\n\n    await client.chat_postMessage(\n        channel=settings.THANKS_CHANNEL,\n        text=f\"💌 *<@{receiver_id}>* 님에게 종이비행기가 도착했어요!\",\n        blocks=[\n            SectionBlock(\n                text=f\"💌 *<@{receiver_id}>* 님에게 종이비행기가 도착했어요!\\n\\n\",\n            ),\n            ContextBlock(\n                elements=[\n                    MarkdownTextObject(\n                        text=\">받은 종이비행기는 `/종이비행기` 명령어 -> [주고받은 종이비행기 보기] 를 통해 확인할 수 있어요.\"\n                    )\n                ],\n            ),\n        ],\n    )\n\n    await client.chat_postMessage(\n        channel=user.user_id,\n        text=f\"💌 *<@{receiver_id}>* 님에게 종이비행기를 보냈어요!\",\n        blocks=[\n            SectionBlock(\n                text=f\"💌 *<@{receiver_id}>* 님에게 종이비행기를 보냈어요!\\n\\n\",\n            ),\n            ContextBlock(\n                elements=[\n                    MarkdownTextObject(\n                        text=\">보낸 종이비행기는 `/종이비행기` 명령어 -> [주고받은 종이비행기 보기] 를 통해 확인할 수 있어요.\"\n                    )\n                ],\n            ),\n        ],\n    )\n\n    # 인프런 쿠폰 지급 로직\n    inflearn_coupon = get_inflearn_coupon(user_id=user.user_id)\n    if not inflearn_coupon:\n        # 인프런 쿠폰이 존재하지 않다면 관리자에게 알립니다.\n        await client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL,\n            text=f\"💌 *<@{user.user_id}>* 님의 인프런 쿠폰이 존재하지 않아요.\",\n        )\n        return None\n    elif inflearn_coupon[\"status\"] == \"received\":\n        # 이미 쿠폰을 받았다면 종이비행기를 보내지 않습니다.\n        return None\n    else:\n        # 인프런 쿠폰을 받지 않았다면 할인쿠폰 코드와 함께 종이비행기를 보냅니다.\n        text = (\n            f\"{inflearn_coupon['user_name'][1:]}님의 따뜻함이 글또를 더 따뜻하게 만들었어요. 이에 감사한 마음을 담아 [인프런 할인 쿠폰]을 보내드려요.\\n\\n\"\n            \"- 할인율 : 30%\\n\"\n            \"- 사용 기한 : 2025. 3. 30. 23:59 까지\\n\"\n            f\"- 쿠폰 코드 : **{inflearn_coupon['code']}**\\n\"\n            \"- 쿠폰 등록 : 쿠폰 등록 하러가기\\n\\n\"\n            \"쿠폰 코드를 [할인쿠폰 코드 입력란]에 등록하면 사용할 수 있어요.\"\n        )\n\n        ttobot = service.get_user(user_id=settings.TTOBOT_USER_ID)\n        service.create_paper_plane(\n            sender=ttobot,\n            receiver=user,\n            text=text,\n        )\n        update_inflearn_coupon_status(user_id=user.user_id, status=\"received\")\n\n        await asyncio.sleep(\n            5\n        )  # 종이비행기 메시지 전송 후 5초 뒤에 전송. 이유는 바로 전송할 경우 본인 전송 알림 메시지와 구분이 어려움.\n\n        try:\n            await client.chat_postMessage(\n                channel=user.user_id,\n                text=f\"💌 *<@{settings.TTOBOT_USER_ID}>* 의 깜짝 선물이 담긴 종이비행기가 도착했어요!🎁\",\n                blocks=[\n                    SectionBlock(\n                        text=f\"💌 *<@{settings.TTOBOT_USER_ID}>* 의 깜짝 선물이 담긴 종이비행기가 도착했어요!🎁\\n\\n\",\n                    ),\n                    ContextBlock(\n                        elements=[\n                            MarkdownTextObject(\n                                text=\">받은 종이비행기는 `/종이비행기` 명령어 -> [주고받은 종이비행기 보기] 를 통해 확인할 수 있어요.\"\n                            )\n                        ],\n                    ),\n                ],\n            )\n            return None\n        except Exception as e:\n            await client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=f\"💌 *<@{user.user_id}>* 님에게 인프런 쿠폰을 보냈으나 메시지 전송에 실패했어요. {e}\",\n            )\n            return None\n\n\nclass InflearnCoupon(TypedDict):\n    user_id: str\n    user_name: str\n    code: str\n    status: str\n\n\ndef get_inflearn_coupon(user_id: str) -> InflearnCoupon | None:\n    \"\"\"인프런 쿠폰 코드를 반환합니다.\"\"\"\n    try:\n        df = pd.read_csv(\n            \"store/_inflearn_coupon.csv\", encoding=\"utf-8\", quoting=csv.QUOTE_ALL\n        )\n    except FileNotFoundError:\n        return None\n\n    coupon_row = df[df[\"user_id\"] == user_id]\n    if not coupon_row.empty:\n        return coupon_row.iloc[0].to_dict()\n    return None\n\n\ndef update_inflearn_coupon_status(user_id: str, status: str) -> None:\n    \"\"\"인프런 쿠폰 수령 상태를 업데이트합니다.\"\"\"\n    df = pd.read_csv(\"store/_inflearn_coupon.csv\", encoding=\"utf-8\")\n    df.loc[df[\"user_id\"] == user_id, \"status\"] = status\n    df.to_csv(\n        \"store/_inflearn_coupon.csv\",\n        index=False,\n        encoding=\"utf-8\",\n        quoting=csv.QUOTE_ALL,\n    )\n\n\nasync def open_paper_plane_url(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"종이비행기 페이지를 엽니다.\"\"\"\n    # 해당 이벤트는 로그를 위해 ack만 수행합니다.\n    await ack()\n\n\nasync def open_paper_plane_guide_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"종이비행기 사용 방법을 조회합니다.\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title={\"type\": \"plain_text\", \"text\": \"종이비행기 사용 방법\"},\n            close={\"type\": \"plain_text\", \"text\": \"닫기\"},\n            blocks=[\n                # 사용 방법 안내\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*✍️ 어떤 내용을 보내면 좋을까요?*\\n\"\n                        \"종이비행기 메시지를 작성할 때는 아래 내용을 참고해보세요. 😉\\n\\n\"\n                        \"*`구체적인 상황`* - 어떤 활동이나 대화에서 고마움을 느꼈는지 이야기해요.\\n\"\n                        \"*`구체적인 내용`* - 그 사람이 어떤 도움을 줬거나, 어떤 말을 해줬는지 적어보세요.\\n\"\n                        \"*`효과와 감사 표현`* - 그 행동이 나에게 어떤 영향을 주었는지, 얼마나 감사한지 표현해요.\\n\"\n                        \"*`앞으로의 기대`* - 앞으로도 계속 함께해주길 바라는 마음을 전해보세요!\",\n                    }\n                ),\n                DividerBlock(),\n                # 예시 메시지\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*💌 종이비행기 메시지 예시*\\n\",\n                    }\n                ),\n                # 예시 1: 스터디 활동\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": '예시 1: 스터디 활동\\n>\"00 스터디에서 항상 열정적으로 참여해주셔서 정말 감사해요! 덕분에 저도 더 열심히 하게 되고, 많은 배움을 얻고 있어요. 앞으로도 함께 성장해나갈 수 있으면 좋겠어요! 😊\"',\n                        }\n                    ]\n                ),\n                # 예시 2: 커피챗 대화\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": '예시 2: 커피챗 대화\\n>\"지난번 커피챗에서 나눈 대화가 정말 인상 깊었어요. 개발에 대한 생각을 나누고 조언을 주셔서 고맙습니다! 다음에도 또 이런 기회가 있으면 좋겠네요!\"',\n                        }\n                    ]\n                ),\n                # 예시 3: 반상회 발표\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": '예시 3: 반상회 발표\\n>\"최근 반상회에서 발표하신 모습이 인상적이었어요! 멀리서 지켜보면서 많은 영감을 받았답니다. 😊 나중에 기회가 된다면 커피챗으로 더 깊게 이야기를 나눌 수 있으면 좋겠어요!\"',\n                        }\n                    ]\n                ),\n                DividerBlock(),\n                # 가이드 마무리\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"이제 진심을 담은 메시지를 종이비행기로 전달해보세요! ✈️\",\n                    }\n                ),\n            ],\n        ),\n    )\n\n\nasync def open_coffee_chat_history_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"커피챗 히스토리를 조회합니다.\"\"\"\n    await ack()\n\n    coffee_chat_proofs = service.fetch_coffee_chat_proofs(user_id=user.user_id)\n\n    blocks: list[Block] = []\n    for proof in coffee_chat_proofs:\n        blocks.append(SectionBlock(text=f\"*{ts_to_dt(proof.ts).strftime('%Y-%m-%d')}*\"))\n        text = proof.text[:100] + \" ...\" if len(proof.text) >= 100 else proof.text\n        blocks.append(ContextBlock(elements=[MarkdownTextObject(text=f\"> {text}\")]))\n\n    footer_blocks = (\n        [\n            DividerBlock(),\n            SectionBlock(\n                text=\"커피챗 내역은 최근 10개까지만 표시됩니다.\\n전체 내역을 확인하려면 아래 버튼을 눌러주세요.\",\n            ),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"전체 내역 다운로드\",\n                        action_id=\"download_coffee_chat_history\",\n                        value=\"download_coffee_chat_history\",\n                        style=\"primary\",\n                    ),\n                ],\n            ),\n        ]\n        if blocks\n        else []\n    )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{user.name}님의 커피챗 인증 내역\",\n            close=\"닫기\",\n            blocks=(\n                SectionBlock(\n                    text=f\"총 *{len(coffee_chat_proofs)}* 개의 커피챗 내역이 있어요.\",\n                ),\n                DividerBlock(),\n                *(\n                    blocks[:20]\n                    if blocks\n                    else [SectionBlock(text=\"아직 커피챗 인증 내역이 없어요.\")]\n                ),\n                *footer_blocks,\n            ),\n        ),\n    )\n\n\nasync def download_coffee_chat_history(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"커피챗 히스토리를 CSV 파일로 다운로드합니다.\"\"\"\n    await ack()\n\n    response = await client.conversations_open(users=user.user_id)\n    dm_channel_id = response[\"channel\"][\"id\"]\n\n    proofs = service.fetch_coffee_chat_proofs(user_id=user.user_id)\n    if not proofs:\n        await client.chat_postMessage(\n            channel=dm_channel_id, text=\"커피챗 인증 내역이 없습니다.\"\n        )\n        return None\n\n    # 사용자의 제출내역을 CSV 파일로 임시 저장 후 전송\n    temp_dir = \"temp/coffee_chat_proofs\"\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir)\n\n    temp_file_path = f\"{temp_dir}/{user.name}-커피챗-인증-내역.csv\"\n    with open(temp_file_path, \"w\", newline=\"\") as csvfile:\n        writer = csv.DictWriter(\n            csvfile,\n            CoffeeChatProof.fieldnames(),\n            quoting=csv.QUOTE_ALL,\n        )\n        writer.writeheader()\n        writer.writerows([each.model_dump() for each in proofs])\n\n    res = await client.files_upload_v2(\n        channel=dm_channel_id,\n        file=temp_file_path,\n        initial_comment=f\"<@{user.user_id}> 님의 커피챗 인증 내역 입니다.\",\n    )\n\n    await client.chat_postMessage(\n        channel=dm_channel_id,\n        text=f\"<@{user.user_id}> 님의 <{res['file']['permalink']}|커피챗 인증 내역> 입니다.\",\n    )\n\n    # 임시로 생성한 CSV 파일을 삭제\n    os.remove(temp_file_path)\n\n\nasync def handle_channel_created(\n    ack: AsyncAck,\n    body: ChannelCreatedBodyType,\n    client: AsyncWebClient,\n):\n    \"\"\"공개 채널 생성 이벤트를 처리합니다.\"\"\"\n    await ack()\n\n    channel_id = body[\"event\"][\"channel\"][\"id\"]\n    await client.conversations_join(channel=channel_id)\n    await client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=f\"새로 만들어진 <#{channel_id}> 채널에 또봇이 참여했습니다. 😋\",\n    )\n"}
{"type": "source_file", "path": "app/slack/services/background.py", "content": "import csv\nfrom datetime import timedelta\nimport os\nimport traceback\nfrom typing import TypedDict\n\nimport pandas as pd\nimport tenacity\nfrom app.constants import remind_message\nfrom app.logging import log_event\nfrom app.models import User\nfrom app.slack.repositories import SlackRepository\nfrom slack_sdk.models.blocks import (\n    SectionBlock,\n    TextObject,\n    ActionsBlock,\n    ContextBlock,\n    ButtonElement,\n    DividerBlock,\n)\n\nfrom slack_bolt.async_app import AsyncApp\nfrom app.config import settings\n\n\nimport asyncio\n\nfrom app.utils import dict_to_json_str, tz_now\n\n\nclass SubscriptionMessage(TypedDict):\n    user_id: str\n    target_user_id: str\n    target_user_channel: str\n    ts: str\n    title: str\n    dt: str\n\n\nclass BackgroundService:\n    def __init__(self, repo: SlackRepository) -> None:\n        self._repo = repo\n\n    async def send_reminder_message_to_user(self, slack_app: AsyncApp) -> None:\n        \"\"\"사용자에게 리마인드 메시지를 전송합니다.\"\"\"\n        users = self._repo.fetch_users()\n\n        target_users: list[User] = []\n        for user in users:\n            if user.cohort != \"10기\":  # 10기 외의 사용자 제외\n                continue\n            if user.channel_name == \"-\":  # 채널 이름이 없는 경우 제외\n                continue\n            if user.is_submit:  # 이미 제출한 경우 제외\n                continue\n\n            target_users.append(user)\n\n        for user in target_users:\n            log_event(\n                actor=\"slack_reminder_service\",\n                event=\"send_reminder_message_to_user\",\n                type=\"reminder\",\n                description=f\"{user.name} 님에게 리마인드 메시지를 전송합니다.\",\n            )\n\n            await slack_app.client.chat_postMessage(\n                channel=user.user_id,\n                text=remind_message.format(user_name=user.name),\n            )\n\n            # 슬랙은 메시지 전송을 초당 1개를 권장하기 때문에 1초 대기합니다.\n            # 참고문서: https://api.slack.com/methods/chat.postMessage#rate_limiting\n            await asyncio.sleep(1)\n\n        await slack_app.client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL,\n            text=f\"총 {len(target_users)} 명에게 리마인드 메시지를 전송했습니다.\",\n        )\n\n    async def prepare_subscribe_message_data(self) -> None:\n        \"\"\"사용자에게 구독 알림 메시지 목록을 임시 CSV 파일로 저장합니다.\"\"\"\n\n        # 기존 임시 파일 삭제\n        if os.path.exists(\"store/_subscription_messages.csv\"):\n            os.remove(\"store/_subscription_messages.csv\")\n\n        # 모든 구독 정보를 가져옵니다\n        subscriptions = self._repo.fetch_subscriptions()\n\n        # 구독 대상자들의 user_id를 중복 없이 set으로 추출합니다\n        target_user_ids = {\n            subscription.target_user_id for subscription in subscriptions\n        }\n\n        yesterday = (tz_now() - timedelta(days=1)).date()\n        contents_df = pd.read_csv(\"store/contents.csv\")\n\n        # dt 컬럼을 datetime 타입으로 변환하고 date 부분만 추출합니다\n        contents_df[\"dt\"] = pd.to_datetime(contents_df[\"dt\"]).dt.date\n\n        # 구독 대상자의 콘텐츠 중 어제 작성된 제출 글만 필터링합니다\n        filtered_contents = contents_df[\n            (contents_df[\"user_id\"].isin(target_user_ids))\n            & (contents_df[\"dt\"] == yesterday)\n            & (contents_df[\"type\"] == \"submit\")\n        ]\n\n        # 구독 알림 메시지 데이터를 저장할 리스트\n        subscription_messages: list[SubscriptionMessage] = []\n\n        # 각 구독 대상자별로 처리를 시작합니다\n        for target_user_id in target_user_ids:\n            target_contents = filtered_contents[\n                filtered_contents[\"user_id\"] == target_user_id\n            ]\n\n            # 해당 구독 대상자의 콘텐츠가 없으면 다음 대상자로 넘어갑니다\n            if len(target_contents) == 0:\n                continue\n\n            # 현재 구독 대상자를 구독하는 모든 구독자 정보를 가져옵니다\n            target_subscriptions = self._repo.fetch_subscriptions_by_target_user_id(\n                target_user_id\n            )\n\n            # 구독자에게 보낼 알림을 배열에 담습니다.\n            for subscription in target_subscriptions:\n                for _, content in target_contents.iterrows():\n                    subscription_messages.append(\n                        {\n                            \"user_id\": subscription.user_id,\n                            \"target_user_id\": target_user_id,\n                            \"target_user_channel\": subscription.target_user_channel,\n                            \"ts\": content[\"ts\"],\n                            \"title\": content[\"title\"],\n                            \"dt\": content[\"dt\"],\n                        }\n                    )\n\n        # 임시 CSV 파일에 저장합니다.\n        if subscription_messages:\n            pd.DataFrame(subscription_messages).to_csv(\n                \"store/_subscription_messages.csv\",\n                index=False,\n                quoting=csv.QUOTE_ALL,\n            )\n\n    async def send_subscription_messages(self, slack_app: AsyncApp) -> None:\n        \"\"\"사용자에게 구독 알림 메시지를 전송합니다.\"\"\"\n        if not os.path.exists(\"store/_subscription_messages.csv\"):\n            return\n\n        df = pd.read_csv(\"store/_subscription_messages.csv\")\n        for _, row in df.iterrows():\n            try:\n                message: SubscriptionMessage = row.to_dict()\n                await self._send_subscription_message(slack_app, message)\n\n            except Exception as e:\n                trace = traceback.format_exc()\n                error_message = f\"⚠️ <@{row['user_id']}>님의 구독 알림 메시지 전송에 실패했습니다. 오류: {e} {trace}\"\n                log_event(\n                    actor=\"slack_subscribe_service\",\n                    event=\"send_subscription_message_to_user\",\n                    type=\"error\",\n                    description=error_message,\n                )\n                await slack_app.client.chat_postMessage(\n                    channel=settings.ADMIN_CHANNEL,\n                    text=error_message,\n                )\n                continue\n\n        await slack_app.client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL,\n            text=f\"총 {len(df['user_id'].unique())} 명에게 {len(df)} 개의 구독 알림 메시지를 전송했습니다.\",\n        )\n\n    @tenacity.retry(\n        stop=tenacity.stop_after_attempt(3),\n        wait=tenacity.wait_fixed(1),\n        reraise=True,\n    )\n    async def _send_subscription_message(\n        self, slack_app: AsyncApp, message: SubscriptionMessage\n    ) -> None:\n        permalink_res = await slack_app.client.chat_getPermalink(\n            message_ts=message[\"ts\"],\n            channel=message[\"target_user_channel\"],\n        )\n\n        text = f\"구독하신 <@{message['target_user_id']}>님의 새로운 글이 올라왔어요! 🤩\"\n        blocks = [\n            SectionBlock(\n                text=text,\n            ),\n            ContextBlock(\n                elements=[\n                    TextObject(\n                        type=\"mrkdwn\",\n                        text=f\"글 제목 : {message['title']}\\n제출 날짜 : {message['dt'][:4]}년 {int(message['dt'][5:7])}월 {int(message['dt'][8:10])}일\",\n                    ),\n                ],\n            ),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"글 보러가기\",\n                        action_id=\"open_subscription_permalink\",\n                        url=permalink_res[\"permalink\"],\n                        style=\"primary\",\n                        value=dict_to_json_str(\n                            {\n                                \"user_id\": message[\"user_id\"],  # 구독자\n                                \"ts\": message[\"ts\"],  # 클릭한 콘텐츠 id\n                            }\n                        ),\n                    ),\n                    ButtonElement(\n                        text=\"감사의 종이비행기 보내기\",\n                        action_id=\"send_paper_plane_message\",\n                        value=message[\"target_user_id\"],\n                    ),\n                ]\n            ),\n            DividerBlock(),\n        ]\n        await slack_app.client.chat_postMessage(\n            channel=message[\"user_id\"],\n            text=text,\n            blocks=blocks,\n        )\n\n        # 슬랙은 메시지 전송을 초당 1개를 권장하기 때문에 1초 대기합니다.\n        # 참고문서: https://api.slack.com/methods/chat.postMessage#rate_limiting\n        await asyncio.sleep(1)\n"}
{"type": "source_file", "path": "app/utils.py", "content": "import csv\nimport random\nimport string\nfrom typing import Any\nimport orjson\nimport regex as re\nimport datetime\n\nfrom zoneinfo import ZoneInfo\n\nimport googletrans\n\n\ndef tz_now(tz: str = \"Asia/Seoul\") -> datetime.datetime:\n    \"\"\"현재시간 반환합니다.\"\"\"\n    return datetime.datetime.now(tz=ZoneInfo(tz))\n\n\ndef tz_now_to_str(tz: str = \"Asia/Seoul\") -> str:\n    \"\"\"현재시간을 문자열로 반환합니다.\"\"\"\n    return datetime.datetime.strftime(tz_now(tz), \"%Y-%m-%d %H:%M:%S\")\n\n\ndef generate_unique_id() -> str:\n    \"\"\"고유한 ID를 생성합니다.\"\"\"\n    # 무작위 문자열 6자리 + 밀리 세컨즈(문자로 치환된)\n    random_str = \"\".join(random.choices(string.ascii_letters + string.digits, k=6))\n    return f\"{random_str}{str(int(datetime.datetime.now().timestamp() * 1000))}\"\n\n\ndef is_english(text):\n    \"\"\"영어인지 한글인지 판별합니다.\"\"\"\n    if re.match(\"^[a-zA-Z]+$\", text):\n        return True\n    elif re.match(\"^[가-힣]+$\", text):\n        return False\n    else:\n        return None\n\n\ndef translate_keywords(keywords: list[str]) -> list[str]:\n    \"\"\"키워드를 번역합니다.\"\"\"\n    translator = googletrans.Translator()\n    results = []\n    for keyword in keywords:\n        value = is_english(keyword)\n        if value is True:\n            # 영어 -> 한글 번역, 한글이 없는 단어는 그대로 영어가 나올 수 있음.\n            results.append(translator.translate(keyword, dest=\"ko\").text.lower())\n        elif value is False:\n            results.append(translator.translate(keyword, dest=\"en\").text.lower())\n        else:\n            continue\n    return results\n\n\ndef remove_emoji(message: str) -> str:\n    \"\"\"이모지를 제거합니다.\"\"\"\n    emoji_code_pattern = re.compile(r\":[a-zA-Z0-9_\\-]+:|:\\p{Script=Hangul}+:\")\n    return emoji_code_pattern.sub(r\"\", message)\n\n\ndef slack_link_to_markdown(text):\n    \"\"\"Slack 링크를 마크다운 링크로 변환합니다.\"\"\"\n    pattern = re.compile(r\"<(http[s]?://[^\\|]+)\\|([^\\>]+)>\")\n    return pattern.sub(r\"[\\2](\\1)\", text)\n\n\ndef convert_user_id_to_name(message: str) -> str:\n    \"\"\"슬랙 메시지에서 user_id를 name으로 변경합니다.\"\"\"\n    with open(\"store/users.csv\") as f:\n        reader = csv.DictReader(f)\n        user_dict = {row[\"user_id\"]: row[\"name\"] for row in reader}\n\n    user_ids = re.findall(\"<@([A-Z0-9]+)>\", message)\n\n    for user_id in user_ids:\n        name = user_dict.get(user_id, user_id)\n        message = message.replace(f\"<@{user_id}>\", name)\n\n    return message\n\n\ndef dict_to_json_str(data: dict[str, Any]) -> str:\n    \"\"\"dict를 json string으로 변환합니다.\"\"\"\n    return orjson.dumps(data).decode(\"utf-8\")\n\n\ndef json_str_to_dict(data: str) -> dict[str, Any]:\n    \"\"\"json string을 dict로 변환합니다.\"\"\"\n    return orjson.loads(data)\n\n\ndef ts_to_dt(ts: str) -> datetime.datetime:\n    \"\"\"timestamp를 datetime으로 변환합니다.\"\"\"\n    return datetime.datetime.fromtimestamp(float(ts))\n"}

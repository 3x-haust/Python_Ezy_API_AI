{"repo_info": {"repo_name": "FastAPI-SaaS-Template", "repo_owner": "shekhuverma", "repo_url": "https://github.com/shekhuverma/FastAPI-SaaS-Template"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/database_test.py", "content": "import pytest\n\nfrom src.db import services\nfrom src.schemas import admins, users\n\n\n@pytest.mark.asyncio\nasync def test_create_get_user(CreateUser_data, db) -> None:\n    created_user = await services.create_user(CreateUser_data, db)\n    assert created_user.txid == CreateUser_data.txid\n\n\n@pytest.mark.asyncio\nasync def test_activate_license(CreateUser_data, db):\n    license = users.License(license=CreateUser_data.License_Key)\n    End_Date, product = await services.activate_license(license, db)\n    assert CreateUser_data.End_Date == End_Date\n    assert CreateUser_data.product == product\n    get_user = await services.get_user(txid=CreateUser_data.txid, db=db)\n    assert get_user.License_Activated is True\n\n\n@pytest.mark.asyncio\nasync def test_add_user(CreateUser_data, db):\n    result = await services.add_user(CreateUser_data, db)\n    # becuase we have already created a user in database it should return user already exists\n    assert result == {\"Error\": \"The orderID already Exists!\"}\n\n\n@pytest.mark.asyncio\nasync def test_update_user(CreateUser_data, EditUser_data, db):\n    user = await services.get_user(CreateUser_data.txid, db)\n    result = await services.update_user(user, EditUser_data, db=db)\n    assert result.product == users.Product.ProductB\n    assert result.email_id == \"testing_new123@gmail.com\"\n    assert result.contact_no == \"111111111\"\n\n\n@pytest.mark.asyncio\nasync def test_reset_licence_activated(CreateUser_data, db):\n    user = await services.get_user(CreateUser_data.txid, db)\n    user = await services.reset_licence_activated(user, db)\n    assert user.License_Activated is False\n\n\n@pytest.mark.asyncio\nasync def test_db_delete_user(CreateUser_data, db):\n    user = await services.get_user(CreateUser_data.txid, db)\n    await services.delete_user(user, db=db)\n    assert await services.get_user(CreateUser_data.txid, db) is None\n\n\n@pytest.mark.asyncio\nasync def test_create_admin(admin_data, db):\n    admin = await services.create_admin(admin_data, db)\n    assert admin.username == admin_data.username\n\n\n@pytest.mark.asyncio\nasync def test_get_admin(admin_data, db):\n    admin = await services.get_admin(admin_data.username, db)\n    admin = admins.AdminInDB.model_validate(admin)\n    assert admin.username == admin_data.username\n    assert admin.scope == admin_data.scope\n\n\n@pytest.mark.asyncio\nasync def test_delete_admin(admin_data, db):\n    result = await services.delete_admin(admin_data.username, db)\n    assert result == {\"Success\": f\"Admin with username {admin_data.username} deleted!\"}\n"}
{"type": "test_file", "path": "tests/admin_test.py", "content": "from fastapi.testclient import TestClient\n\nfrom src.main import app\n\nclient = TestClient(app)\n\n\ndef test_login(login_credentials):\n    response = client.post(\"/login\", data=login_credentials)\n    assert response.status_code == 200\n    token = response.json()[\"access_token\"]\n    assert token is not None\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "import datetime\nimport random\nimport string\n\nimport pytest\nfrom dateutil.relativedelta import relativedelta\nfrom fastapi.testclient import TestClient\n\nfrom src.db import database\nfrom src.main import app\nfrom src.schemas import admins, users\nfrom src.security.license import LicenseGen\nfrom src.settings import SUPERUSER_LOGIN, SUPERUSER_PASSWORD\n\nclient = TestClient(app)\n\n\n@pytest.fixture(scope=\"session\")\ndef db():\n    return database.SessionLocal()\n\n\n@pytest.fixture(scope=\"session\")\ndef admin_data():\n    return admins.CreateAdmin(\n        username=\"testing\",\n        scope=admins.Scopes.admin,\n        password=\"testing\",\n    )\n\n\n@pytest.fixture(scope=\"session\")\ndef CreateUser_data():\n    license = LicenseGen()\n    TxID = \"\".join(random.choices(string.ascii_letters + string.digits, k=16))\n    test_user = users.CreateUser(\n        txid=TxID,\n        amount=1111,\n        payment_method=\"NA\",\n        product=users.Product.ProductA,\n        email_id=\"testing@gmail.com\",\n        contact_no=\"9999999999\",\n        subscription=12,\n        order_date=datetime.datetime.now(datetime.UTC),\n        License_Key=license.create(TxID + \"testing@gmail.com\"),\n        License_Activated=False,\n        Start_Date=datetime.date.today(),  # add the actual order date\n        End_Date=datetime.date.today() + relativedelta(months=12),\n    )\n    return test_user\n\n\n@pytest.fixture(scope=\"session\")\ndef AddUser_data():\n    TxID = \"\".join(random.choices(string.ascii_letters + string.digits, k=16))\n    Email = (\n        \"\".join(random.choices(string.ascii_letters + string.digits, k=5))\n        + \"@testing.com\"\n    )\n    test_user = users.AddUser(\n        txid=TxID,\n        amount=1111,\n        product=users.Product.ProductA,\n        email_id=Email,\n        contact_no=\"9999999999\",\n        subscription=12,\n        order_date=datetime.datetime.now(datetime.UTC),\n    )\n    return test_user\n\n\n@pytest.fixture(scope=\"session\")\ndef EditUser_data():\n    edit_user = users.EditUser(\n        product=users.Product.ProductB,\n        email_id=\"testing_new123@gmail.com\",\n        contact_no=\"111111111\",\n    )\n    return edit_user\n\n\n@pytest.fixture(scope=\"session\")\ndef login_credentials():\n    return {\n        \"username\": SUPERUSER_LOGIN,\n        \"password\": SUPERUSER_PASSWORD,\n        \"scope\": \"admin\",\n    }\n\n\n@pytest.fixture(scope=\"session\")\ndef login(login_credentials):\n    response = client.post(\"/login\", data=login_credentials)\n    assert response.status_code == 200\n    token = response.json()[\"access_token\"]\n    assert token is not None\n    return token\n"}
{"type": "test_file", "path": "tests/user_test.py", "content": "import httpx\nimport pytest\n\nfrom src.db import services\nfrom src.main import app\nfrom src.schemas.users import Product\n\napp = httpx.ASGITransport(app=app)\n\n\n@pytest.mark.asyncio(scope=\"session\")\nasync def test_add_user(AddUser_data, login, db) -> None:\n    async with httpx.AsyncClient(\n        transport=app, base_url=\"http://localhost:8000\"\n    ) as client:\n        response = await client.post(\n            \"users/add\",\n            content=AddUser_data.model_dump_json(),\n            headers={\n                \"Authorization\": f\"Bearer {login}\",\n                \"Content-Type\": \"application/json\",\n                \"accept\": \"application/json\",\n            },\n        )\n    get_user = await services.get_user(txid=AddUser_data.txid, db=db)\n    assert response.status_code == 200\n    assert AddUser_data.txid == get_user.txid\n\n\n# there is some issue with this function, not able to test the function\n@pytest.mark.asyncio(scope=\"session\")\nasync def test_edit_user(AddUser_data, EditUser_data, login, db) -> None:\n    async with httpx.AsyncClient(\n        transport=app, base_url=\"http://localhost:8000\"\n    ) as client:\n        response = await client.put(\n            f\"users/?TxnId={AddUser_data.txid}\",\n            content=EditUser_data.model_dump_json(),\n            headers={\n                \"Authorization\": f\"Bearer {login}\",\n                \"Content-Type\": \"application/json\",\n                \"accept\": \"application/json\",\n            },\n        )\n    assert response.status_code == 200\n    result = await services.get_user(AddUser_data.txid, db)\n    assert result.product == Product.ProductB\n    assert result.email_id == \"testing_new123@gmail.com\"\n    assert result.contact_no == \"111111111\"\n\n\n@pytest.mark.asyncio(scope=\"session\")\nasync def test_delete_user(AddUser_data, login, db) -> None:\n    async with httpx.AsyncClient(\n        transport=app, base_url=\"http://localhost:8000\"\n    ) as client:\n        response = await client.delete(\n            f\"users/?TxnId={AddUser_data.txid}\",\n            headers={\"Authorization\": f\"Bearer {login}\"},\n        )\n    assert response.status_code == 200\n    assert await services.get_user(AddUser_data.txid, db) is None\n"}
{"type": "source_file", "path": "src/db/database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import declarative_base, sessionmaker\n\nfrom src.settings import get_db_url\n\nSQLALCHEMY_DATABASE_URL = get_db_url()\n\nprint(SQLALCHEMY_DATABASE_URL)\n\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\n\n# Each instance of SessionLocal class will be a database session\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nBase = declarative_base()\n"}
{"type": "source_file", "path": "alembic/env.py", "content": "from logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config, pool\n\nfrom alembic import context\nfrom src.db import model\nfrom src.settings import get_db_url\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = model.Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\nconfiguration = config.get_section(config.config_ini_section, {})\nconfiguration[\"sqlalchemy.url\"] = get_db_url()\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(\n        url=configuration[\"sqlalchemy.url\"],\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n\n    connectable = engine_from_config(\n        configuration,\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(connection=connection, target_metadata=target_metadata)\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "alembic/versions/2024_05_17_initialising_models.py", "content": "\"\"\"Initialising Models\n\nRevision ID: 6f215625f963\nRevises:\nCreate Date: 2024-05-17 16:51:38.563910\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"6f215625f963\"\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"admins\",\n        sa.Column(\"username\", sa.String(), nullable=False),\n        sa.Column(\"disabled\", sa.Boolean(), nullable=True),\n        sa.Column(\"scope\", sa.Enum(\"admin\", \"edit\", name=\"scopes\"), nullable=True),\n        sa.Column(\"hashed_password\", sa.String(), nullable=True),\n        sa.PrimaryKeyConstraint(\"username\"),\n    )\n    op.create_index(op.f(\"ix_admins_username\"), \"admins\", [\"username\"], unique=False)\n    op.create_table(\n        \"users\",\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"txid\", sa.String(), nullable=True),\n        sa.Column(\"amount\", sa.FLOAT(), nullable=True),\n        sa.Column(\"payment_method\", sa.String(), nullable=True),\n        sa.Column(\"product\", sa.String(), nullable=True),\n        sa.Column(\"email_id\", sa.String(), nullable=True),\n        sa.Column(\"contact_no\", sa.String(), nullable=True),\n        sa.Column(\"subscription\", sa.Integer(), nullable=True),\n        sa.Column(\"order_date\", sa.DateTime(), nullable=True),\n        sa.Column(\"Start_Date\", sa.DATE(), nullable=True),\n        sa.Column(\"End_Date\", sa.DATE(), nullable=True),\n        sa.Column(\"License_Key\", sa.String(), nullable=True),\n        sa.Column(\"License_Activated\", sa.Boolean(), nullable=True),\n        sa.PrimaryKeyConstraint(\"id\"),\n        sa.UniqueConstraint(\"License_Key\"),\n        sa.UniqueConstraint(\"txid\"),\n    )\n    op.create_index(op.f(\"ix_users_id\"), \"users\", [\"id\"], unique=False)\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f(\"ix_users_id\"), table_name=\"users\")\n    op.drop_table(\"users\")\n    op.drop_index(op.f(\"ix_admins_username\"), table_name=\"admins\")\n    op.drop_table(\"admins\")\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "src/schemas/__init__.py", "content": ""}
{"type": "source_file", "path": "src/db/services.py", "content": "import datetime\n\nfrom sqlalchemy import and_, func\nfrom sqlalchemy.orm import Session\n\nfrom src.db import database, model\nfrom src.schemas import admins, users\nfrom src.security.utils import get_password_hash\n\n\ndef save_db():\n    session = database.SessionLocal()\n    try:\n        yield session\n    finally:\n        session.close()\n\n\nasync def create_user(user: users.CreateUser, db: Session) -> users.User:\n    contact = model.Users(**user.model_dump())\n    db.add(contact)\n    db.commit()\n    db.refresh(contact)\n    return users.User.model_validate(contact)\n\n\nasync def get_users_all(\n    db: Session,\n    txnId=None,\n    emailId=None,\n    contactNo=None,\n    product=None,\n    startDate=None,\n    endDate=None,\n):\n    filters = []\n    if txnId is not None:\n        # doing this to make the search case insensitive\n        txnId = txnId.lower()\n        user = db.query(model.Users).filter(func.lower(model.Users.txid) == txnId).all()\n        if user is not None:\n            return {\"data\": user, \"total\": 1}\n        else:\n            return {\"Error\": \"User Does not exist or TxID is Invalid!\"}\n\n    if contactNo is not None:\n        search = \"%{}\".format(contactNo)\n\n        user = db.query(model.Users).filter(model.Users.contact_no.like(search))\n        count = user.count()\n        user = user.all()\n        if user is not None:\n            return {\"data\": user, \"total\": count}\n        else:\n            return {\"Error\": \"User Does not exist or TxID is Invalid!\"}\n\n    if emailId is not None:\n        emailId = emailId.lower()\n        user = db.query(model.Users).filter(func.lower(model.Users.email_id) == emailId)\n        count = user.count()\n        user = user.all()\n        if user is not None:\n            return {\"data\": user, \"total\": count}\n        else:\n            return {\"Error\": \"User Does not exist or TxID is Invalid!\"}\n\n    if product is not None:\n        filters.append(model.Users.product == users.Product[product].value)\n    if startDate is not None:\n        filters.append(func.date(model.Users.order_date) >= startDate)\n    if endDate is not None:\n        filters.append(func.date(model.Users.order_date) <= endDate)\n\n    user = db.query(model.Users).filter(and_(*filters))\n    filtered_length = user.count()\n    user = user.all()\n\n    return {\"data\": user, \"total\": filtered_length}\n\n\nasync def get_users(\n    db: Session,\n    skip=1,  # This is actually Page Number\n    limit=10,  # This is actually Page Size\n    txnId=None,\n    emailId=None,\n    contactNo=None,\n    product=None,\n    startDate=None,\n    endDate=None,\n):\n    # if we don't do -1 then it will skip the first row everytime\n    start = (skip - 1) * limit\n    filtered_length = 0\n    filters = []\n    if txnId is not None:\n        # doing this to make the search case insensitive\n        txnId = txnId.lower()\n        user = db.query(model.Users).filter(func.lower(model.Users.txid) == txnId).all()\n        if user is not None:\n            return {\"data\": user, \"total\": 1}\n        else:\n            return {\"Error\": \"User Does not exist or TxID is Invalid!\"}\n\n    if contactNo is not None:\n        search = \"%{}\".format(contactNo)\n\n        user = db.query(model.Users).filter(model.Users.contact_no.like(search))\n        count = user.count()\n        user = user.all()\n        if user is not None:\n            return {\"data\": user, \"total\": count}\n        else:\n            return {\"Error\": \"User Does not exist or TxID is Invalid!\"}\n\n    if emailId is not None:\n        emailId = emailId.lower()\n        user = db.query(model.Users).filter(func.lower(model.Users.email_id) == emailId)\n        count = user.count()\n        user = user.all()\n        if user is not None:\n            return {\"data\": user, \"total\": count}\n        else:\n            return {\"Error\": \"User Does not exist or TxID is Invalid!\"}\n\n    if product is not None:\n        filters.append(model.Users.product == users.Product[product].value)\n    if startDate is not None:\n        filters.append(func.date(model.Users.order_date) >= startDate)\n    if endDate is not None:\n        filters.append(func.date(model.Users.order_date) <= endDate)\n\n    user = db.query(model.Users).filter(and_(*filters)).order_by(model.Users.id.desc())\n    filtered_length = user.count()\n\n    user = user.offset(start).limit(limit).all()\n    return {\"data\": user, \"total\": filtered_length}\n\n\nasync def add_user(user: users.CreateUser, db: Session) -> users.User:\n    temp = await get_user(user.txid, db)\n    if temp is None:\n        # print(\"Testing\")\n        return await create_user(user, db)\n    else:\n        # print({\"Error\": \"The orderID already Exists!\"})\n        return {\"Error\": \"The orderID already Exists!\"}\n\n\nasync def get_user(txid: str, db: Session) -> users.User:\n    user = db.query(model.Users).filter(model.Users.txid == txid).first()\n    return user\n\n\nasync def delete_user(user: model.Users, db: Session):\n    db.delete(user)\n    db.commit()\n\n\nasync def update_user(user: model.Users, edit_user: users.EditUser, db: Session):\n    setattr(user, \"product\", edit_user.product)\n    setattr(user, \"email_id\", edit_user.email_id)\n    setattr(user, \"contact_no\", edit_user.contact_no)\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n    return users.User.model_validate(user)\n\n\nasync def activate_license(license: users.License, db: Session) -> list:\n    user = (\n        db.query(model.Users).filter(model.Users.License_Key == license.license).first()\n    )\n    # License key not found in the database\n    if user is None:\n        return None\n\n    else:\n        # License Key is expired\n        if user.End_Date < datetime.date.today():\n            return None\n\n        # Setting the license to activated so that it cannot be used again\n        elif user.License_Activated is False:\n            user.License_Activated = True\n            db.commit()\n            return [user.End_Date, user.product]\n\n        # License is already activated\n        else:\n            return None\n\n\nasync def reset_licence_activated(user: model.Users, db: Session):\n    setattr(user, \"License_Activated\", False)\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n    return users.User.model_validate(user)\n\n\nasync def create_admin(admin_data: admins.CreateAdmin, db: Session):\n    admin = admins.AdminInDB(\n        **admin_data.model_dump(),\n        hashed_password=get_password_hash(admin_data.password),\n    )\n    admin = model.Admins(**admin.model_dump())\n    db.add(admin)\n    db.commit()\n    db.refresh(admin)\n    return admins.AdminInDB.model_validate(admin)\n\n\nasync def get_admin(admin_username: str, db: Session):\n    admin = (\n        db.query(model.Admins).filter(model.Admins.username == admin_username).first()\n    )\n    return admin\n\n\nasync def delete_admin(admin_username: str, db: Session):\n    admin = await get_admin(admin_username, db)\n    if admin is None:\n        return {\"Success\": f\"Admin with username {admin_username} doesn't exist!\"}\n    else:\n        db.delete(admin)\n        db.commit()\n        return {\"Success\": f\"Admin with username {admin_username} deleted!\"}\n"}
{"type": "source_file", "path": "src/router/__init__.py", "content": ""}
{"type": "source_file", "path": "src/router/admin.py", "content": "from datetime import timedelta\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, Response, Security, status\nfrom fastapi.security import OAuth2PasswordRequestForm\n\nfrom src.db import services\nfrom src.schemas import admins\nfrom src.security.jwt import create_access_token\nfrom src.security.security import get_current_active_user\nfrom src.security.utils import authenticate_user, get_password_hash\nfrom src.settings import JWTconfig\n\nrouter = APIRouter(tags=[\"Admin\"])\n\n\n@router.post(\"/login\")\nasync def login(\n    response: Response,\n    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],\n    db: Annotated[any, Depends(services.save_db)],\n):\n    user = await authenticate_user(db, form_data.username, form_data.password)\n    print(\"___ USER ___\")\n    print(user)\n    print(\"___ USER ___\")\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or Password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    # Checking whether if user has selected a scope or not\n    if form_data.scopes != []:\n        # Checking if the user has the provided permissions\n        if user.scope not in form_data.scopes:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Not enough Permissions 1\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n\n    access_token_expires = timedelta(minutes=JWTconfig.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username, \"scopes\": form_data.scopes},\n        expires_delta=access_token_expires,\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n\n# need to complete this one\n@router.post(\"/Admin/add\")\nasync def add_user(\n    db: Annotated[any, Depends(services.save_db)],\n    add_admin: admins.CreateAdmin,\n    current_user: Annotated[\n        any,\n        Security(get_current_active_user, scopes=[admins.Scopes.admin]),\n    ],\n):\n    create_admin = admins.AdminInDB(\n        username=add_admin.username,\n        scope=add_admin.scope,\n        hashed_password=get_password_hash(add_admin.password),\n    )\n    return await services.create_admin(create_admin, db)\n\n\n@router.delete(\"/Admin/delete\")\nasync def delete_user(\n    db: Annotated[any, Depends(services.save_db)],\n    username: str,\n    current_user: Annotated[\n        any,\n        Security(get_current_active_user, scopes=[admins.Scopes.admin]),\n    ],\n):\n    return await services.delete_admin(username, db)\n    return await services.delete_admin(username, db)\n"}
{"type": "source_file", "path": "src/docs/docs.py", "content": "tags_metadata = [\n    {\n        \"name\": \"Webhook\",\n        \"description\": \"To Recieve Webhooks from any services such as payment gateways\",\n    },\n    {\n        \"name\": \"License Key Validation\",\n        \"description\": \"This Endpoint is being used to verify the type of license\",\n    },\n    {\n        \"name\": \"Testing\",\n        \"description\": \"Just for testing the API\",\n    },\n    {\n        \"name\": \"Admin\",\n        \"description\": \"Enpoints for login and managing admins\",\n    },\n    {\n        \"name\": \"Users\",\n        \"description\": \"Enpoints for managing users\",\n    },\n]\n"}
{"type": "source_file", "path": "src/db/model.py", "content": "from sqlalchemy import DATE, FLOAT, Boolean, Column, DateTime, Enum, Integer, String\n\nfrom src.db.database import Base\nfrom src.schemas import admins\n\n\n# Refer to README.md for more details\nclass Users(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    txid = Column(String, unique=True)\n    amount = Column(FLOAT)\n    payment_method = Column(String)\n    product = Column(String)\n    email_id = Column(String)\n    contact_no = Column(String)\n    subscription = Column(Integer)\n    order_date = Column(DateTime)\n    Start_Date = Column(DATE)\n    End_Date = Column(DATE)\n    License_Key = Column(String, unique=True)\n    License_Activated = Column(Boolean)\n\n\nclass Admins(Base):\n    __tablename__ = \"admins\"\n\n    username = Column(String, primary_key=True, index=True)\n    disabled = Column(Boolean, default=False)\n    scope = Column(Enum(admins.Scopes), default=None)\n    hashed_password = Column(String)\n"}
{"type": "source_file", "path": "src/_init_db.py", "content": "import asyncio\n\nfrom src.db import database, services\nfrom src.schemas import admins\nfrom src.settings import SUPERUSER_LOGIN, SUPERUSER_PASSWORD\n\n# To add the superuser to newly created database\nasyncio.run(\n    services.create_admin(\n        admins.CreateAdmin(\n            username=SUPERUSER_LOGIN,\n            scope=admins.Scopes.admin,\n            password=SUPERUSER_PASSWORD,\n        ),\n        database.SessionLocal(),\n    )\n)\n\nasyncio.run(\n    services.create_admin(\n        admins.CreateAdmin(\n            username=\"string\",\n            scope=None,\n            password=\"string\",\n        ),\n        database.SessionLocal(),\n    )\n)\n"}
{"type": "source_file", "path": "src/db/__init__.py", "content": ""}
{"type": "source_file", "path": "src/__init__.py", "content": ""}
{"type": "source_file", "path": "src/router/user.py", "content": "import csv\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom dateutil.relativedelta import relativedelta\nfrom fastapi import APIRouter, Depends, File, Response, Security, UploadFile, status\nfrom fastapi.exceptions import HTTPException\n\nfrom src.db import services\nfrom src.schemas import admins, users\nfrom src.security.license import LicenseGen\nfrom src.security.security import get_current_active_user, get_current_user\nfrom src.utils import csv_utils\n\nrouter = APIRouter(\n    prefix=\"/users\",\n    tags=[\"Users\"],\n)\n\n\n@router.get(\"/downloadcsv\")\nasync def get_all_users(\n    current_user: Annotated[\n        any,\n        Security(get_current_user),\n    ],\n    db: Annotated[any, Depends(services.save_db)],\n    txnId: str | None = None,\n    product: str | None = None,\n    startDate: str | None = None,\n    endDate: str | None = None,\n    emailId: str | None = None,\n    contactNo: str | None = None,\n):\n    return await services.get_users_all(\n        db, txnId, emailId, contactNo, product, startDate, endDate\n    )\n\n\n@router.get(\"/all\")\nasync def get_users(\n    current_user: Annotated[\n        any,\n        Security(get_current_user),\n    ],\n    db: Annotated[any, Depends(services.save_db)],\n    skip: int = 1,  # This is actually Page Number\n    limit: int = 10,  # This is actually Page Size\n    txnId: str | None = None,\n    product: str | None = None,\n    startDate: str | None = None,\n    endDate: str | None = None,\n    emailId: str | None = None,\n    contactNo: str | None = None,\n):\n    return await services.get_users(\n        db, skip, limit, txnId, emailId, contactNo, product, startDate, endDate\n    )\n\n\n@router.get(\"/\")\nasync def get_user(\n    current_user: Annotated[\n        any,\n        Security(get_current_user),\n    ],\n    db: Annotated[any, Depends(services.save_db)],\n    TxnId: str,\n):\n    user = await services.get_user(TxnId, db)\n    if user is not None:\n        return user\n    else:\n        return {\"Error\": \"User Does not exist or TxID is Invalid!\"}\n\n\n@router.post(\"/add\")\nasync def add_user(\n    db: Annotated[any, Depends(services.save_db)],\n    current_user: Annotated[\n        any,\n        Security(\n            get_current_active_user, scopes=[admins.Scopes.edit, admins.Scopes.admin]\n        ),\n    ],\n    adduser: users.AddUser,\n    license: Annotated[LicenseGen, Depends()],\n):\n    data = users.CreateUser(\n        txid=adduser.txid,\n        amount=adduser.amount,\n        payment_method=\"NA\",\n        product=adduser.product,\n        email_id=adduser.email_id,\n        contact_no=adduser.contact_no,\n        subscription=adduser.subscription,\n        order_date=adduser.order_date,\n        License_Key=license.create(adduser.txid + adduser.email_id),\n        License_Activated=False,\n        Start_Date=adduser.order_date.date(),  # add the actual order date\n        End_Date=adduser.order_date.date() + relativedelta(months=adduser.subscription),\n    )\n    return await services.add_user(data, db)\n\n\n@router.delete(\"/\")\nasync def delete_user(\n    TxnId: str,\n    db: Annotated[any, Depends(services.save_db)],\n    current_user: Annotated[\n        any,\n        Security(\n            get_current_active_user, scopes=[admins.Scopes.edit, admins.Scopes.admin]\n        ),\n    ],\n):\n    user = await services.get_user(TxnId, db)\n    if user is not None:\n        await services.delete_user(user, db)\n    else:\n        return {\"Error\": \"User Does not exist\"}\n\n\n@router.put(\"/\")\nasync def edit_user(\n    TxnId: str,\n    edit_user: users.EditUser,\n    db: Annotated[any, Depends(services.save_db)],\n    current_user: Annotated[\n        any,\n        Security(\n            get_current_active_user, scopes=[admins.Scopes.edit, admins.Scopes.admin]\n        ),\n    ],\n):\n    print(edit_user)\n    user = await services.get_user(TxnId, db)\n    if user is None:\n        raise HTTPException(status_code=400, detail=\"User Does not exist\")\n        # pass\n    else:\n        return await services.update_user(user, edit_user, db)\n\n\n@router.post(\n    \"/Verifylicence\", status_code=status.HTTP_200_OK, tags=[\"License Key Validation\"]\n)\nasync def Verifylicence(\n    license_key: users.License,\n    db: Annotated[any, Depends(services.save_db)],\n):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    result = await services.activate_license(license_key, db)\n    if result is None:\n        raise credentials_exception\n    else:\n        return result\n\n\n@router.post(\"/uploadcsv\")\nasync def upload_CSV(\n    current_user: Annotated[\n        any,\n        Security(\n            get_current_active_user, scopes=[admins.Scopes.edit, admins.Scopes.admin]\n        ),\n    ],\n    db: Annotated[any, Depends(services.save_db)],\n    Notify_pabbly: bool,\n    response: Response,\n    license: Annotated[LicenseGen, Depends()],\n    file: UploadFile = File(...),\n):\n    email_ids = []\n    file_extension = file.filename.split(\".\")[-1]  # Getting the uploaded filename\n    file_name = file.filename.split(\".\")[0]  # Getting the uploaded file extension\n\n    if file_extension.lower() != \"csv\":\n        response.status_code = status.HTTP_400_BAD_REQUEST\n        return {\"Message\": \"Please upload only CSV file\"}\n\n    file_location = csv_utils.csv_file_name(file_name)\n\n    try:\n        contents = file.file.read()\n        with open(file_location, \"wb\") as f:\n            f.write(contents)\n    except Exception:\n        response.status_code = status.HTTP_400_BAD_REQUEST\n        return {\"Message\": \"There was an error uploading the file\"}\n    finally:\n        file.file.close()\n\n    if csv_utils.header_validator(file_location) is False:\n        response.status_code = status.HTTP_400_BAD_REQUEST\n        return {\n            \"Message\": \"\"\" Please Upload the CSV file in correct format \\n tx_id, user_email, user_phone, amount, order_date, duration, product\"\"\"\n        }\n\n    data_validation_result = csv_utils.data_validator(file_location)\n    if data_validation_result is not True:\n        response.status_code = status.HTTP_400_BAD_REQUEST\n        print(data_validation_result)\n        return {\"Message\": data_validation_result}\n\n    with open(file_location, encoding=\"utf-8-sig\") as f:\n        # Now that we have validated the CSV, we are reading the lines one by one\n        for RP_reponse in csv.DictReader(f, skipinitialspace=True):\n            # print(RP_reponse)\n\n            # Checking user does not exists\n            if await services.get_user(RP_reponse[\"tx_id\"], db=db) is None:\n                data = users.CreateUser(\n                    txid=RP_reponse[\"tx_id\"],\n                    amount=RP_reponse[\"amount\"],\n                    payment_method=\"NA\",\n                    product=RP_reponse[\"product\"],\n                    email_id=RP_reponse[\"user_email\"],\n                    contact_no=RP_reponse[\"user_phone\"],\n                    subscription=RP_reponse[\"duration\"],\n                    order_date=datetime.strptime(RP_reponse[\"order_date\"], \"%Y-%m-%d\"),\n                    License_Key=license.create(\n                        RP_reponse[\"tx_id\"] + RP_reponse[\"user_email\"]\n                    ),\n                    License_Activated=False,\n                    Start_Date=RP_reponse[\"order_date\"],  # add the actual order date\n                    End_Date=datetime.strptime(RP_reponse[\"order_date\"], \"%Y-%m-%d\")\n                    + relativedelta(months=int(RP_reponse[\"duration\"])),\n                )\n                await services.create_user(data, db=db)\n            else:\n                email_ids.append(\n                    {\"tx_id\": RP_reponse[\"tx_id\"], \"email\": RP_reponse[\"user_email\"]}\n                )\n\n    if len(email_ids) == 0:\n        print({\"Message\": f\"Successfully Uplaoded the CSV file {file_name}\"})\n        return {\"Message\": f\"Successfully Uplaoded the CSV file {file_name}\"}\n    else:\n        print(\n            {\n                \"Records\": email_ids,\n                \"file_name\": file_location,\n            }\n        )\n        return {\n            \"email_ids\": email_ids,\n            \"file_name\": file_location,\n        }\n\n\n@router.post(\"/uploadcsv_skip_replace\")\nasync def uploadcsv_skip_replace(\n    current_user: Annotated[\n        any,\n        Security(\n            get_current_active_user, scopes=[admins.Scopes.edit, admins.Scopes.admin]\n        ),\n    ],\n    db: Annotated[any, Depends(services.save_db)],\n    skip_replace_data: users.SkipReplaceUser,\n    license: Annotated[LicenseGen, Depends()],\n):\n    print(skip_replace_data.file_name)\n    email_list = skip_replace_data.emails\n\n    for record in email_list:\n        if record.replace:\n            print(\"here\")\n            with open(skip_replace_data.file_name) as f:\n                # Now that we have validated the CSV, we are reading the lines one by one\n                for row in csv.DictReader(f, skipinitialspace=True):\n                    if row[\"tx_id\"] == record.tx_id:\n                        await delete_user(row[\"tx_id\"], db=db)\n                        data = users.CreateUser(\n                            txid=row[\"tx_id\"],\n                            amount=row[\"amount\"],\n                            payment_method=\"NA\",\n                            product=row[\"product\"],\n                            email_id=row[\"user_email\"],\n                            contact_no=row[\"user_phone\"],\n                            subscription=row[\"duration\"],\n                            order_date=datetime.strptime(row[\"order_date\"], \"%Y-%m-%d\"),\n                            License_Key=license.create(\n                                row[\"tx_id\"] + row[\"user_email\"]\n                            ),\n                            License_Activated=False,\n                            Start_Date=row[\"order_date\"],  # add the actual order date\n                            End_Date=datetime.strptime(row[\"order_date\"], \"%Y-%m-%d\")\n                            + relativedelta(months=int(row[\"duration\"])),\n                        )\n                        await services.create_user(data, db=db)\n                        await services.create_user(data, db=db)\n"}
{"type": "source_file", "path": "src/docs/__init__.py", "content": ""}
{"type": "source_file", "path": "src/main.py", "content": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI, Request, status\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import JSONResponse  # for example\n\nfrom src.db import services\nfrom src.docs.docs import tags_metadata\nfrom src.router import admin, user\nfrom src.security.license import LicenseGen\n\napp = FastAPI(openapi_tags=tags_metadata)\n\n\n@app.exception_handler(RequestValidationError)\nasync def value_error_exception_handler(request: Request, exc: RequestValidationError):\n    error = exc.errors()[0]\n    print(error)\n    return JSONResponse(\n        status_code=400,\n        content={\"Message\": f\"Error in {error['loc'][1]}, {error['msg']}\"},\n    )\n\n\norigins = [\"http://localhost\", \"http://localhost:8000\", \"http://localhost:3000\", \"*\"]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\napp.include_router(admin.router)\napp.include_router(user.router)\n\n\n# Just for testing the public IP\n@app.get(\"/\", tags=[\"Testing\"])\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n# To create a new user using webhook trigger\n@app.post(\"/webhook\", status_code=status.HTTP_202_ACCEPTED, tags=[\"Webhook\"])\nasync def webhook(\n    request: Request,\n    db: Annotated[any, Depends(services.save_db)],\n    license: Annotated[LicenseGen, Depends()],\n):\n    result = await request.json()\n    print(result)\n    return result\n\n    # Example of how to create a new user whenever the webhook is triggered\n    # product_name = \"For testing\"\n\n    # orderDate = datetime.strptime(\n    #     result[\"date_completed\"].split()[0], \"%Y-%m-%d\"\n    # ).date()\n    # data = users.CreateUser(\n    #     txid=result[\"transaction_id\"],\n    #     amount=result[\"total\"],\n    #     payment_method=\"NA\",\n    #     product=product_name,\n    #     email_id=result[\"billing_email\"],\n    #     contact_no=result[\"billing_phone\"],\n    #     subscription=12,\n    #     order_date=result[\"date_completed\"],\n    #     License_Key=license.create(result[\"transaction_id\"] + result[\"billing_email\"]),\n    #     License_Activated=False,\n    #     Start_Date=orderDate,  # add the actual order date\n    #     End_Date=orderDate + relativedelta(months=12),\n    # )\n    # # to give the data to some other automation service, fox ex pabbly\n    # pabbly_data = data.model_dump()\n    # pabbly_trigger(pabbly_data)\n    # return await services.create_user(data, db=db)\n"}
{"type": "source_file", "path": "src/schemas/users.py", "content": "import datetime\nfrom enum import Enum\n\nfrom pydantic import BaseModel, ConfigDict, EmailStr\n\n\n# You can replace these with the actual products\nclass Product(str, Enum):\n    ProductA = \"Product A\"\n    ProductB = \"Product B\"\n\n    # used for input, output, type conversions and validation\n\n\nclass BaseUser(BaseModel):\n    txid: str\n    amount: float\n    payment_method: str\n    product: str\n    email_id: str\n    contact_no: str\n    subscription: int\n    order_date: datetime.datetime\n    Start_Date: datetime.date\n    End_Date: datetime.date\n    License_Key: str\n    License_Activated: bool\n\n\nclass User(BaseUser):\n    model_config = ConfigDict(from_attributes=True)\n\n\n# Just for naming\nclass CreateUser(BaseUser):\n    pass\n\n\nclass License(BaseModel):\n    license: str\n\n\n# used for adding a new user\nclass AddUser(BaseModel):\n    txid: str\n    amount: float\n    product: str\n    email_id: EmailStr\n    contact_no: str\n    order_date: datetime.datetime  # when adding user manually it also gives datetime\n    subscription: int\n\n\n# # used for editing the user data\nclass EditUser(BaseModel):\n    product: str\n    email_id: EmailStr\n    contact_no: str\n\n\nclass Email(BaseModel):\n    email: str\n    tx_id: str\n    skip: bool\n    replace: bool\n\n\nclass SkipReplaceUser(BaseModel):\n    emails: list[Email]\n    file_name: str\n"}
{"type": "source_file", "path": "src/schemas/admins.py", "content": "from enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Scopes(str, Enum):\n    admin = \"admin\"\n    edit = \"edit\"\n\n\nclass Admin(BaseModel):\n    username: str\n    disabled: bool | None = False\n    scope: Optional[Scopes] = None\n\n\n# To create new admin\nclass CreateAdmin(Admin):\n    password: str\n\n\n# To store admin in the database\nclass AdminInDB(Admin):\n    hashed_password: str\n\n    model_config = ConfigDict(from_attributes=True)\n"}
{"type": "source_file", "path": "src/security/__init__.py", "content": ""}
{"type": "source_file", "path": "src/security/jwt.py", "content": "import datetime\n\nfrom jose import jwt\n\nfrom src.settings import JWTconfig\n\n# JWT means \"JSON Web Tokens\".\n# It's a standard to codify a JSON object in a long dense string without spaces\n# It is not encrypted, so, anyone could recover the information from the contents\n\n\ndef create_access_token(data: dict, expires_delta: datetime.timedelta | None = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.datetime.now(datetime.UTC) + expires_delta\n    else:\n        expire = datetime.datetime.now(datetime.UTC) + datetime.timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(\n        to_encode, JWTconfig.SECRET_KEY, algorithm=JWTconfig.ALGORITHM\n    )\n    return encoded_jwt\n"}
{"type": "source_file", "path": "src/schemas/token.py", "content": "from pydantic import BaseModel\n\nfrom src.schemas import admins\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: str | None = None\n    scopes: list[admins.Scopes] = []\n"}
{"type": "source_file", "path": "src/security/license.py", "content": "from base64 import b64decode, b64encode\n\nfrom Crypto.Cipher import AES\n\nfrom src.settings import LicenseGenSettings\n\n\nclass LicenseGen:\n    def __init__(self):\n        self.IV = LicenseGenSettings.INITIALISATION_VECTOR.encode(\"utf8\")\n        self.str_key = LicenseGenSettings.SECRET_KEY\n        self.aes_obj = AES.new(self.str_key.encode(\"utf-8\"), AES.MODE_CFB, self.IV)\n\n    def create(self, str_to_enc):\n        hx_enc = self.aes_obj.encrypt(str_to_enc.encode(\"utf8\"))\n        mret = b64encode(hx_enc).decode(\"utf-8\")\n        return mret\n\n    def decrypt(self, enc_str):\n        str_tmp = b64decode(enc_str.encode(\"utf-8\"))\n        str_dec = self.aes_obj.decrypt(str_tmp)\n        mret = str_dec.decode(\"utf-8\")\n        return mret\n"}
{"type": "source_file", "path": "src/security/security.py", "content": "from typing import Annotated\n\nfrom fastapi import Depends, HTTPException, Security, status\nfrom fastapi.security import OAuth2PasswordBearer, SecurityScopes\nfrom jose import ExpiredSignatureError, JWTError, jwt\n\nfrom src.db import services\nfrom src.schemas.admins import Admin\nfrom src.schemas.token import TokenData\nfrom src.security.utils import get_user\nfrom src.settings import JWTconfig\n\noauth2_scheme = OAuth2PasswordBearer(\n    tokenUrl=\"login\",\n    scopes={\n        \"admin\": \"Read/Write/Delete Users and Create Admin\",\n        \"edit\": \"Read/Write/Delete\",\n    },\n)\n\n\nasync def get_current_user(\n    token: Annotated[str, Depends(oauth2_scheme)],\n    security_scopes: SecurityScopes,\n    db: Annotated[any, Depends(services.save_db)],\n):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"not allowed\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(\n            token, JWTconfig.SECRET_KEY, algorithms=[JWTconfig.ALGORITHM]\n        )\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_scopes = payload.get(\"scopes\", [])\n        # Creating an instance of pydantic model\n        token_data = TokenData(username=username, scopes=token_scopes)\n        print(token_data)\n    except ExpiredSignatureError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Session Expired. Please Login Again\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        ) from exc\n    except JWTError as exc:\n        raise credentials_exception from exc\n    user = await get_user(db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    print(f\"token scopes = {token_data.scopes}\")\n    print(f\"security_scopes scopes = {security_scopes.scopes}\")\n\n    # If no scope is required by the endpoint return the user\n    if security_scopes.scopes == []:\n        return user\n    else:\n        if token_data.scopes == []:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Not enough permissions\",\n                headers={\"WWW-Authenticate\": \"bearer\"},\n            )\n        # Checking only first becuase we will always pass only one scope\n        elif token_data.scopes[0] not in security_scopes.scopes:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Not enough permissions\",\n                headers={\"WWW-Authenticate\": \"bearer\"},\n            )\n        return user\n\n\nasync def get_current_active_user(\n    current_user: Annotated[Admin, Security(get_current_user)],\n):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n"}
{"type": "source_file", "path": "src/utils/csv_utils.py", "content": "import csv\nimport os\nfrom datetime import datetime\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom src.schemas import users\nfrom src.settings import CSV_FOLDER\n\nCORRECT_HEADER = [\n    \"tx_id\",\n    \"user_email\",\n    \"user_phone\",\n    \"amount\",\n    \"order_date\",\n    \"duration\",\n    \"product\",\n]\n\n\ndef csv_file_name(uploaded_filename: str, extension=\".csv\"):\n    return os.path.join(\n        CSV_FOLDER,\n        uploaded_filename + \"_\" + datetime.now().strftime(\"%Y%m%d%H%M%S\") + extension,\n    )\n\n\ndef header_validator(csv_file_path) -> bool:\n    with open(csv_file_path, encoding=\"utf-8-sig\") as f:\n        headers = csv.DictReader(f).fieldnames\n        print(headers)\n        if headers != CORRECT_HEADER:\n            return False\n    return True\n\n\ndef data_validator(csv_file_path):\n    with open(csv_file_path, encoding=\"utf-8-sig\") as f:\n        for RP_reponse in csv.DictReader(f, skipinitialspace=True):\n            try:\n                data = users.CreateUser(  # noqa: F841\n                    txid=RP_reponse[\"tx_id\"],\n                    amount=RP_reponse[\"amount\"],\n                    payment_method=\"NA\",\n                    product=RP_reponse[\"product\"],\n                    email_id=RP_reponse[\"user_email\"],\n                    contact_no=RP_reponse[\"user_phone\"],\n                    subscription=RP_reponse[\"duration\"],\n                    order_date=datetime.strptime(RP_reponse[\"order_date\"], \"%Y-%m-%d\"),\n                    License_Key=\"temp_license\",\n                    License_Activated=False,\n                    Start_Date=RP_reponse[\"order_date\"],  # add the actual order date\n                    End_Date=datetime.strptime(RP_reponse[\"order_date\"], \"%Y-%m-%d\")\n                    + relativedelta(months=int(RP_reponse[\"duration\"])),\n                )\n            except ValueError as e:\n                return f\"{e} in row {RP_reponse}\"\n\n    return True\n"}
{"type": "source_file", "path": "src/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "src/settings.py", "content": "import os\n\nfrom dotenv import load_dotenv\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nload_dotenv()\n\nDEBUG = os.getenv(\"DEBUG\")\n\nSUPERUSER_LOGIN = os.getenv(\"SUPERUSER_LOGIN\")\nSUPERUSER_PASSWORD = os.getenv(\"SUPERUSER_PASSWORD\")\n\nCSV_FOLDER = \"CSV_Uploads\"\n\n\nclass JWTconfig(BaseSettings):\n    # to get a string like this run:\n    # openssl rand -hex 32\n    SECRET_KEY: str = \"9ebde6d2b2e67230fa346e926bbbdf64eee1c0baaf7b3db6d14d8890aff26066\"\n\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n\n    ALGORITHM: str = \"HS256\"\n\n    model_config = SettingsConfigDict(case_sensitive=True)\n\n\nclass LicenseGenSettings(BaseSettings):\n    # must be 16/24/32 bytes long\n    SECRET_KEY: str = \"abcdefghijklmnop\"\n\n    # must be 16 bytes long\n    INITIALISATION_VECTOR: str = \"qrstuvwxyzabcdef\"\n\n\ndef get_db_url():\n    user = os.getenv(\"POSTGRES_USER\", \"postgres\")\n    password = os.getenv(\"POSTGRES_PASSWORD\", \"\")\n    server = os.getenv(\"POSTGRES_SERVER\", \"localhost\")\n    port = os.getenv(\"POSTGRES_PORT\", \"5432\")\n    db = os.getenv(\"POSTGRES_DB\", \"app\")\n\n    return f\"postgresql://{user}:{password}@{server}:{port}/{db}\"\n\n\nJWTconfig = JWTconfig()\nLicenseGenSettings = LicenseGenSettings()\n"}
{"type": "source_file", "path": "src/security/utils.py", "content": "from passlib.context import CryptContext\n\nfrom src.db import services\nfrom src.schemas.admins import AdminInDB\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\n\nasync def get_user(db, username: str):\n    return await services.get_admin(admin_username=username, db=db)\n\n\nasync def authenticate_user(db, username: str, password: str) -> AdminInDB | None:\n    user = await get_user(db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user\n"}

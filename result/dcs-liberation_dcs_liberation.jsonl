{"repo_info": {"repo_name": "dcs_liberation", "repo_owner": "dcs-liberation", "repo_url": "https://github.com/dcs-liberation/dcs_liberation"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/ato/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/ato/flightstate/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/ato/flightstate/test_actionstate.py", "content": "from collections.abc import Iterator\nfrom datetime import timedelta, datetime\n\nfrom dcs.task import Task\n\nfrom game.ato.flightstate.actionstate import ActionState\nfrom game.flightplan.waypointactions.taskcontext import TaskContext\nfrom game.flightplan.waypointactions.waypointaction import WaypointAction\n\n\nclass TestAction(WaypointAction):\n    def describe(self) -> str:\n        return \"\"\n\n    def update_state(\n        self, state: ActionState, time: datetime, duration: timedelta\n    ) -> timedelta:\n        return timedelta()\n\n    def iter_tasks(self, ctx: TaskContext) -> Iterator[Task]:\n        yield from []\n\n\ndef test_actionstate() -> None:\n    action = TestAction()\n    state = ActionState(action)\n    assert not state.is_finished()\n    state.finish()\n    assert state.is_finished()\n"}
{"type": "test_file", "path": "tests/ato/test_flightplan.py", "content": "from typing import cast, Any\n\nimport pytest\nfrom dcs import Point\nfrom dcs.terrain import Caucasus\n\nfrom game.ato import Flight, FlightWaypoint\nfrom game.ato.flightplans.custom import CustomFlightPlan, CustomLayout\nfrom game.ato.flightplans.flightplan import FlightPlan\nfrom game.ato.flightwaypointtype import FlightWaypointType\n\n\n@pytest.fixture(name=\"unescorted_flight_plan\")\ndef unescorted_flight_plan_fixture() -> FlightPlan[Any]:\n    point = Point(0, 0, Caucasus())\n    departure = FlightWaypoint(\"\", FlightWaypointType.TAKEOFF, point)\n\n    waypoints = [\n        FlightWaypoint(f\"{i}\", FlightWaypointType.NAV, point) for i in range(10)\n    ]\n    return CustomFlightPlan(cast(Flight, object()), CustomLayout(departure, waypoints))\n\n\n@pytest.fixture(name=\"escorted_flight_plan\")\ndef escorted_flight_plan_fixture() -> FlightPlan[Any]:\n    point = Point(0, 0, Caucasus())\n    departure = FlightWaypoint(\"\", FlightWaypointType.TAKEOFF, point)\n\n    waypoints = [\n        FlightWaypoint(f\"{i}\", FlightWaypointType.NAV, point) for i in range(10)\n    ]\n    waypoints[1].wants_escort = True\n    waypoints[2].wants_escort = True\n    waypoints[3].wants_escort = True\n    waypoints[5].wants_escort = True\n    waypoints[7].wants_escort = True\n    waypoints[8].wants_escort = True\n    return CustomFlightPlan(cast(Flight, object()), CustomLayout(departure, waypoints))\n\n\ndef test_escorted_flight_plan_escorted_waypoints(\n    escorted_flight_plan: FlightPlan[Any],\n) -> None:\n    assert [w.name for w in escorted_flight_plan.escorted_waypoints()] == [\n        \"1\",\n        \"2\",\n        \"3\",\n        \"5\",\n        \"7\",\n        \"8\",\n    ]\n\n\ndef test_escorted_flight_plan_request_escort_at(\n    escorted_flight_plan: FlightPlan[Any],\n) -> None:\n    wp = escorted_flight_plan.request_escort_at()\n    assert wp is not None\n    assert wp.name == \"1\"\n\n\ndef test_escorted_flight_plan_dismiss_escort_at(\n    escorted_flight_plan: FlightPlan[Any],\n) -> None:\n    wp = escorted_flight_plan.dismiss_escort_at()\n    assert wp is not None\n    assert wp.name == \"8\"\n\n\ndef test_unescorted_flight_plan_escorted_waypoints(\n    unescorted_flight_plan: FlightPlan[Any],\n) -> None:\n    assert not list(unescorted_flight_plan.escorted_waypoints())\n\n\ndef test_unescorted_flight_plan_request_escort_at(\n    unescorted_flight_plan: FlightPlan[Any],\n) -> None:\n    assert unescorted_flight_plan.request_escort_at() is None\n\n\ndef test_unescorted_flight_plan_dismiss_escort_at(\n    unescorted_flight_plan: FlightPlan[Any],\n) -> None:\n    assert unescorted_flight_plan.dismiss_escort_at() is None\n"}
{"type": "test_file", "path": "tests/callsigns/test_callsign_generator.py", "content": "import pytest\n\nfrom dcs.countries import countries_by_name\n\nfrom game.callsigns.callsigngenerator import (\n    Callsign,\n    EasternGroupIdRegistry,\n    WesternGroupIdRegistry,\n    RoundRobinNameAllocator,\n)\n\n\ndef test_callsign() -> None:\n\n    valid_callsign = Callsign(\"Enfield\", 2, 3)\n    assert str(valid_callsign) == \"Enfield23\"\n    assert valid_callsign.group_name() == \"Enfield-2\"\n    assert valid_callsign.pydcs_dict(\"USA\") == {\"name\": \"Enfield23\", 1: 1, 2: 2, 3: 3}\n\n    # Invalid callsign, group ID too large.\n    with pytest.raises(ValueError):\n        Callsign(\"Enfield\", 1000, 3)\n\n    # Invalid callsign, group ID zero.\n    with pytest.raises(ValueError):\n        Callsign(\"Enfield\", 0, 3)\n\n    # Invalid callsign, unit ID zero.\n    with pytest.raises(ValueError):\n        Callsign(\"Enfield\", 1, 0)\n\n    # Invalid callsign, unit ID too large.\n    with pytest.raises(ValueError):\n        Callsign(\"Enfield\", 1, 11)\n\n\ndef test_western_group_id_registry() -> None:\n    registry = WesternGroupIdRegistry(countries_by_name[\"USA\"]())\n\n    # Check registry increments group IDs.\n    assert registry.alloc_group_id(\"Enfield\") == 1\n    assert registry.alloc_group_id(\"Enfield\") == 2\n\n    # Check allocation on a new name Springfield.\n    assert registry.alloc_group_id(\"Springfield\") == 1\n\n    # Check release of Enfield-1.\n    registry.release_group_id(Callsign(\"Enfield\", 1, 1))\n    assert registry.alloc_group_id(\"Enfield\") == 1\n\n    # Reset and check allocation og Enfield-1 and Springfield-1.\n    registry.reset()\n    assert registry.alloc_group_id(\"Enfield\") == 1\n    assert registry.alloc_group_id(\"Springfield\") == 1\n\n\ndef test_eastern_group_id_registry() -> None:\n    registry = EasternGroupIdRegistry()\n\n    # Check registry increments group IDs.\n    assert registry.alloc_group_id() == 1\n    assert registry.alloc_group_id() == 2\n\n    # Check release.\n    registry.release_group_id(Callsign(None, 1, 1))\n    assert registry.alloc_group_id() == 1\n\n    # Reset and check allocation.\n    registry.reset()\n    assert registry.alloc_group_id() == 1\n\n\ndef test_round_robin_allocator() -> None:\n    allocator = RoundRobinNameAllocator([\"A\", \"B\", \"C\"])\n\n    assert allocator.allocate() == \"A\"\n    assert allocator.allocate() == \"B\"\n    assert allocator.allocate() == \"C\"\n    assert allocator.allocate() == \"A\"\n"}
{"type": "test_file", "path": "tests/campaignloader/test_controlpointconfig.py", "content": "from game.campaignloader.controlpointconfig import ControlPointConfig\n\n\ndef test_from_empty_data() -> None:\n    config = ControlPointConfig.from_data({})\n    assert not config.ferry_only\n\n\ndef test_from_data() -> None:\n    config = ControlPointConfig.from_data(\n        {\n            \"ferry_only\": True,\n        }\n    )\n    assert config.ferry_only\n\n\ndef iter_from_data() -> None:\n    data = dict(\n        ControlPointConfig.iter_from_data(\n            {\n                0: {},\n                \"named\": {\"ferry_only\": True},\n            }\n        )\n    )\n    assert data == {\n        0: ControlPointConfig(ferry_only=False),\n        \"named\": ControlPointConfig(ferry_only=True),\n    }\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "from pathlib import Path\nfrom zipfile import ZipFile\n\nimport pytest\n\n\n@pytest.fixture\ndef tmp_zip(tmp_path: Path) -> Path:\n    zip_path = tmp_path / \"test.zip\"\n    with ZipFile(zip_path, \"w\"):\n        pass\n    return zip_path\n"}
{"type": "test_file", "path": "tests/data/test_doctrine.py", "content": "import pytest\n\nfrom game.data.doctrine import Doctrine, GroundUnitProcurementRatios\nfrom game.data.units import UnitClass\n\n\ndef test_ground_unit_procurement_ratios_empty() -> None:\n    r = GroundUnitProcurementRatios({})\n    for unit_class in UnitClass:\n        assert r.for_unit_class(unit_class) == 0.0\n\n\ndef test_ground_unit_procurement_ratios_single_item() -> None:\n    r = GroundUnitProcurementRatios({UnitClass.TANK: 1})\n    for unit_class in UnitClass:\n        if unit_class == UnitClass.TANK:\n            assert r.for_unit_class(unit_class) == 1.0\n        else:\n            assert r.for_unit_class(unit_class) == 0.0\n\n\ndef test_ground_unit_procurement_ratios_multiple_items() -> None:\n    r = GroundUnitProcurementRatios({UnitClass.TANK: 1, UnitClass.ATGM: 1})\n    for unit_class in UnitClass:\n        if unit_class in [UnitClass.TANK, UnitClass.ATGM]:\n            assert r.for_unit_class(unit_class) == 0.5\n        else:\n            assert r.for_unit_class(unit_class) == 0.0\n\n\ndef test_ground_unit_procurement_ratios_from_dict() -> None:\n    r = GroundUnitProcurementRatios.from_dict({\"Tank\": 1, \"ATGM\": 1})\n    for unit_class in UnitClass:\n        if unit_class in [UnitClass.TANK, UnitClass.ATGM]:\n            assert r.for_unit_class(unit_class) == 0.5\n        else:\n            assert r.for_unit_class(unit_class) == 0.0\n\n\ndef test_doctrine() -> None:\n    # This test checks for the presence of a doctrine named \"modern\" as this doctrine is used as a default\n    modern_doctrine = Doctrine.named(\"modern\")\n    assert modern_doctrine.name == \"modern\"\n"}
{"type": "test_file", "path": "tests/dcs/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/dcs/test_lasercodeconfig.py", "content": "from game.dcs.lasercodeconfig import (\n    SinglePropertyLaserCodeConfig,\n    MultiplePropertyLaserCodeConfig,\n    LaserCodeConfig,\n)\n\n\ndef test_singlepropertylasercodeproperty() -> None:\n    config = SinglePropertyLaserCodeConfig(\"code\", 3)\n    assert list(config.iter_prop_ids()) == [\"code\"]\n    assert config.property_dict_for_code(1688) == {\"code\": 688}\n    assert config.property_dict_for_code(1000) == {\"code\": 0}\n    assert config.property_dict_for_code(1234) == {\"code\": 234}\n    assert config.property_dict_for_code(1) == {\"code\": 1}\n\n\ndef test_multiplepropertylasercodeproperty() -> None:\n    config = MultiplePropertyLaserCodeConfig(\n        [\n            (\"digit0\", 0),\n            (\"digit1\", 1),\n            (\"digit2\", 2),\n        ],\n    )\n    assert list(config.iter_prop_ids()) == [\"digit0\", \"digit1\", \"digit2\"]\n    assert config.property_dict_for_code(1688) == {\n        \"digit0\": 8,\n        \"digit1\": 8,\n        \"digit2\": 6,\n    }\n    assert config.property_dict_for_code(1000) == {\n        \"digit0\": 0,\n        \"digit1\": 0,\n        \"digit2\": 0,\n    }\n    assert config.property_dict_for_code(1234) == {\n        \"digit0\": 4,\n        \"digit1\": 3,\n        \"digit2\": 2,\n    }\n    assert config.property_dict_for_code(1) == {\"digit0\": 1, \"digit1\": 0, \"digit2\": 0}\n\n\ndef test_lasercodeconfig_from_yaml() -> None:\n    config = LaserCodeConfig.from_yaml(\n        {\"pylon\": 0, \"property\": {\"id\": \"code\", \"digits\": 3}}\n    )\n    assert config.property_dict_for_code(1688) == {\"code\": 688}\n\n    config = LaserCodeConfig.from_yaml(\n        {\n            \"pylon\": 1,\n            \"properties\": [\n                {\"id\": \"digit0\", \"digit\": 0},\n                {\"id\": \"digit1\", \"digit\": 1},\n                {\"id\": \"digit2\", \"digit\": 2},\n            ],\n        }\n    )\n    assert config.property_dict_for_code(1688) == {\n        \"digit0\": 8,\n        \"digit1\": 8,\n        \"digit2\": 6,\n    }\n"}
{"type": "test_file", "path": "tests/flightplan/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/flightplan/test_ipsolver.py", "content": "import random\nimport uuid\nfrom collections.abc import Iterator\nfrom contextlib import contextmanager\nfrom pathlib import Path\n\nimport pytest\nfrom dcs.terrain import Caucasus\nfrom shapely import Point, MultiPolygon, Polygon, unary_union\n\nfrom game.data.doctrine import Doctrine\nfrom game.flightplan.ipsolver import IpSolver\nfrom game.flightplan.waypointsolver import NoSolutionsError\nfrom game.flightplan.waypointstrategy import point_at_heading\nfrom game.utils import Heading, nautical_miles, feet, Distance, meters\nfrom tests.flightplan.waypointsolvertestcasereducer import WaypointSolverTestCaseReducer\n\n# The Falklands is nearly 1000 nmi diagonal. We'll use that as a radius for a bit of\n# overkill.\nMAP_RADIUS = nautical_miles(1000)\n\n# Aircraft like the B-1 have a combat range closer to 3000 nmi, but we don't have\n# maps big enough for that to matter. 600 nmi is still a *very* distant target for\n# our campaigns.\nMAX_TARGET_DISTANCE = nautical_miles(500)\n\n# 200 nmi is roughly the max range of the SA-5, which has the greatest range of\n# anything in DCS.\nMAX_THREAT_RANGE = nautical_miles(200)\n\nMAX_THREAT_DISTANCE = MAX_TARGET_DISTANCE + MAX_THREAT_RANGE\n\n\nTHIS_DIR = Path(__file__).parent\nTEST_CASE_DIRECTORY = THIS_DIR / \"testcases\"\n\n\ndef fuzz_threat() -> Polygon:\n    threat_range_m = random.triangular(\n        feet(500).meters, MAX_THREAT_RANGE.meters, nautical_miles(40).meters\n    )\n    threat_distance = meters(\n        random.triangular(0, MAX_THREAT_DISTANCE.meters, nautical_miles(100).meters)\n    )\n    threat_position = point_at_heading(Point(0, 0), Heading.random(), threat_distance)\n    return threat_position.buffer(threat_range_m)\n\n\n@pytest.fixture(name=\"fuzzed_target_distance\")\ndef fuzzed_target_distance_fixture() -> Distance:\n    return meters(\n        random.triangular(0, MAX_TARGET_DISTANCE.meters, nautical_miles(100).meters)\n    )\n\n\n@pytest.fixture(name=\"fuzzed_threat_poly\")\ndef fuzzed_threat_poly_fixture() -> MultiPolygon:\n    number_of_threats = random.randint(0, 100)\n    polys = unary_union([fuzz_threat() for _ in range(number_of_threats)])\n    if isinstance(polys, MultiPolygon):\n        return polys\n    return MultiPolygon([polys])\n\n\n@pytest.fixture(name=\"fuzzed_solver\")\ndef fuzzed_solver_fixture(\n    fuzzed_target_distance: Distance, fuzzed_threat_poly: MultiPolygon, tmp_path: Path\n) -> IpSolver:\n    target_heading = Heading.from_degrees(random.uniform(0, 360))\n    departure = Point(0, 0)\n    target = point_at_heading(departure, target_heading, fuzzed_target_distance)\n    solver = IpSolver(\n        departure, target, random.choice(Doctrine.all_doctrines()), fuzzed_threat_poly\n    )\n    solver.set_debug_properties(tmp_path, Caucasus())\n    return solver\n\n\n@contextmanager\ndef capture_fuzz_failures(solver: IpSolver) -> Iterator[None]:\n    try:\n        yield\n    except NoSolutionsError as ex:\n        test_case_directory = TEST_CASE_DIRECTORY / str(uuid.uuid4())\n        assert solver.debug_output_directory\n        WaypointSolverTestCaseReducer(\n            solver.debug_output_directory, test_case_directory\n        ).reduce()\n        ex.add_note(f\"Reduced test case was written to {test_case_directory}\")\n        raise\n\n\n@pytest.mark.fuzztest\n@pytest.mark.parametrize(\"run_number\", range(500))\ndef test_fuzz_ipsolver(fuzzed_solver: IpSolver, run_number: int) -> None:\n    with capture_fuzz_failures(fuzzed_solver):\n        fuzzed_solver.solve()\n\n\ndef test_can_construct_solver_with_empty_threat() -> None:\n    IpSolver(Point(0, 0), Point(0, 0), Doctrine.named(\"coldwar\"), MultiPolygon([]))\n"}
{"type": "test_file", "path": "tests/flightplan/test_waypointsolver.py", "content": "import json\nfrom collections.abc import Iterator\nfrom pathlib import Path\n\nimport pytest\nfrom dcs.terrain import Caucasus\nfrom shapely.geometry import Point, MultiPolygon\nfrom shapely.geometry.base import BaseGeometry\n\nfrom game.flightplan.waypointsolver import WaypointSolver, NoSolutionsError\nfrom game.flightplan.waypointstrategy import WaypointStrategy\n\n\nclass NoSolutionsStrategy(WaypointStrategy):\n    def __init__(self) -> None:\n        super().__init__(MultiPolygon([]))\n\n    def find(self) -> Point | None:\n        return None\n\n\nclass PointStrategy(WaypointStrategy):\n    def __init__(self, x: float, y: float) -> None:\n        super().__init__(MultiPolygon([]))\n        self.point = Point(x, y)\n\n    def find(self) -> Point | None:\n        return self.point\n\n\nclass OriginStrategy(PointStrategy):\n    def __init__(self) -> None:\n        super().__init__(0, 0)\n\n\nclass DebuggableStrategy(NoSolutionsStrategy):\n    def __init__(self, distance_factor: int) -> None:\n        super().__init__()\n        center = Point(0, 0)\n        self.exclude(\"foo\", center.buffer(1 * distance_factor))\n        self.exclude(\n            \"bar\",\n            center.buffer(3 * distance_factor).difference(\n                center.buffer(2 * distance_factor)\n            ),\n        )\n\n\nclass SolverWithInputs(WaypointSolver):\n    def describe_inputs(self) -> Iterator[tuple[str, BaseGeometry]]:\n        yield \"foo\", Point(0, 0)\n        yield \"bar\", Point(1, 1)\n\n\ndef test_solver_tries_strategies_in_order() -> None:\n    solver = WaypointSolver()\n    solver.add_strategy(OriginStrategy())\n    solver.add_strategy(PointStrategy(1, 1))\n    assert solver.solve() == Point(0, 0)\n\n\ndef test_individual_failed_strategies_do_not_fail_solver() -> None:\n    solver = WaypointSolver()\n    solver.add_strategy(NoSolutionsStrategy())\n    solver.add_strategy(OriginStrategy())\n    assert solver.solve() == Point(0, 0)\n\n\ndef test_no_solutions_raises() -> None:\n    solver = WaypointSolver()\n    solver.add_strategy(NoSolutionsStrategy())\n    with pytest.raises(NoSolutionsError):\n        solver.solve()\n\n\ndef test_no_strategies_raises() -> None:\n    solver = WaypointSolver()\n    with pytest.raises(ValueError):\n        solver.solve()\n\n\ndef test_success_does_not_dump_debug_info(tmp_path: Path) -> None:\n    solver = WaypointSolver()\n    solver.set_debug_properties(tmp_path, Caucasus())\n    solver.add_strategy(OriginStrategy())\n    solver.solve()\n    assert not list(tmp_path.iterdir())\n\n\ndef test_no_solutions_dumps_debug_info(tmp_path: Path) -> None:\n    center = Point(0, 0)\n    solver = WaypointSolver()\n    solver.set_debug_properties(tmp_path, Caucasus())\n    strategy_0 = DebuggableStrategy(distance_factor=1)\n    strategy_1 = DebuggableStrategy(distance_factor=2)\n    strategy_1.prerequisite(center).is_safe()\n    solver.add_strategy(strategy_0)\n    solver.add_strategy(strategy_1)\n    with pytest.raises(NoSolutionsError):\n        solver.solve()\n\n    strategy_0_path = tmp_path / \"0.json\"\n    strategy_1_path = tmp_path / \"1.json\"\n    assert set(tmp_path.iterdir()) == {\n        tmp_path / \"solver.json\",\n        strategy_0_path,\n        strategy_1_path,\n    }\n\n    with strategy_0_path.open(\"r\", encoding=\"utf-8\") as metadata_file:\n        data = json.load(metadata_file)\n    assert data[\"type\"] == \"FeatureCollection\"\n    assert data[\"metadata\"][\"name\"] == \"DebuggableStrategy\"\n    assert data[\"metadata\"][\"prerequisites\"] == []\n    assert len(data.keys()) == 3\n    features = data[\"features\"]\n    assert len(features) == 2\n    for debug_info, feature in zip(strategy_0.iter_debug_info(), features):\n        assert debug_info.to_geojson(solver.to_geojson) == feature\n\n    with strategy_1_path.open(\"r\", encoding=\"utf-8\") as metadata_file:\n        data = json.load(metadata_file)\n    assert data[\"type\"] == \"FeatureCollection\"\n    assert data[\"metadata\"][\"name\"] == \"DebuggableStrategy\"\n    assert data[\"metadata\"][\"prerequisites\"] == [\n        {\n            \"requirement\": \"is safe\",\n            \"satisfied\": True,\n            \"subject\": solver.to_geojson(center),\n        }\n    ]\n    assert len(data.keys()) == 3\n    features = data[\"features\"]\n    assert len(features) == 2\n    for debug_info, feature in zip(strategy_1.iter_debug_info(), features):\n        assert debug_info.to_geojson(solver.to_geojson) == feature\n\n\ndef test_no_solutions_dumps_inputs(tmp_path: Path) -> None:\n    solver = SolverWithInputs()\n    solver.set_debug_properties(tmp_path, Caucasus())\n    solver.add_strategy(NoSolutionsStrategy())\n    with pytest.raises(NoSolutionsError):\n        solver.solve()\n\n    inputs_path = tmp_path / \"solver.json\"\n    with inputs_path.open(encoding=\"utf-8\") as inputs_file:\n        data = json.load(inputs_file)\n    assert data == {\n        \"type\": \"FeatureCollection\",\n        \"metadata\": {\n            \"name\": \"SolverWithInputs\",\n            \"terrain\": \"Caucasus\",\n        },\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"properties\": {\"description\": \"foo\"},\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [34.265515188456, 45.129497060328966],\n                },\n            },\n            {\n                \"type\": \"Feature\",\n                \"properties\": {\"description\": \"bar\"},\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [34.265528100962584, 45.1295059189547],\n                },\n            },\n        ],\n    }\n\n\ndef test_solver_inputs_appear_in_strategy_features(tmp_path: Path) -> None:\n    solver = SolverWithInputs()\n    solver.set_debug_properties(tmp_path, Caucasus())\n    solver.add_strategy(PointStrategy(2, 2))\n    solver.dump_debug_info()\n\n    strategy_path = tmp_path / \"0.json\"\n    with strategy_path.open(encoding=\"utf-8\") as inputs_file:\n        data = json.load(inputs_file)\n    assert data == {\n        \"type\": \"FeatureCollection\",\n        \"metadata\": {\n            \"name\": \"PointStrategy\",\n            \"prerequisites\": [],\n        },\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"properties\": {\"description\": \"foo\"},\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [34.265515188456, 45.129497060328966],\n                },\n            },\n            {\n                \"type\": \"Feature\",\n                \"properties\": {\"description\": \"bar\"},\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [34.265528100962584, 45.1295059189547],\n                },\n            },\n            {\n                \"type\": \"Feature\",\n                \"properties\": {\"description\": \"solution\"},\n                \"geometry\": {\n                    \"coordinates\": [34.265541013473154, 45.12951477757893],\n                    \"type\": \"Point\",\n                },\n            },\n        ],\n    }\n\n\ndef test_to_geojson(tmp_path: Path) -> None:\n    solver = WaypointSolver()\n    solver.set_debug_properties(tmp_path, Caucasus())\n    assert solver.to_geojson(Point(0, 0)) == {\n        \"coordinates\": [34.265515188456, 45.129497060328966],\n        \"type\": \"Point\",\n    }\n\n    assert solver.to_geojson(MultiPolygon([])) == {\n        \"type\": \"MultiPolygon\",\n        \"coordinates\": [],\n    }\n"}
{"type": "test_file", "path": "tests/flightplan/test_waypointsolver_regression_tests.py", "content": "from pathlib import Path\n\nimport pytest\n\nfrom game.flightplan.waypointsolverloader import WaypointSolverLoader\n\nTHIS_DIR = Path(__file__).parent\nTEST_CASES_DIR = THIS_DIR / \"testcases\"\n\n# Set to True to regenerate the debug files for each test case. After doing this, format\n# the test cases with `npx prettier -w tests/flightplan/testcases` for readability.\nUPDATE_TEST_CASES = False\n\n\n@pytest.mark.parametrize(\"test_case\", TEST_CASES_DIR.glob(\"**/solver.json\"))\ndef test_waypoint_solver_regression_tests(test_case: Path) -> None:\n    loader = WaypointSolverLoader(test_case)\n    solver = loader.load()\n    if UPDATE_TEST_CASES:\n        solver.set_debug_properties(test_case.parent, loader.terrain)\n    solver.solve()\n    if UPDATE_TEST_CASES:\n        solver.dump_debug_info()\n"}
{"type": "test_file", "path": "tests/flightplan/test_waypointsolverloader.py", "content": "import json\nfrom pathlib import Path\n\nimport pytest\n\nfrom game.flightplan.ipsolver import IpSolver\nfrom game.flightplan.waypointsolverloader import WaypointSolverLoader\n\n\ndef test_waypointsolverloader(tmp_path: Path) -> None:\n    debug_info_path = tmp_path / \"solver.json\"\n    debug_info_path.write_text(\n        json.dumps(\n            {\n                \"type\": \"FeatureCollection\",\n                \"metadata\": {\n                    \"name\": \"IpSolver\",\n                    \"terrain\": \"Falklands\",\n                    \"doctrine\": \"coldwar\",\n                },\n                \"features\": [\n                    {\n                        \"type\": \"Feature\",\n                        \"properties\": {\"description\": \"departure\"},\n                        \"geometry\": {\n                            \"type\": \"Point\",\n                            \"coordinates\": [-59.17351849883801, -52.46892777233296],\n                        },\n                    },\n                    {\n                        \"type\": \"Feature\",\n                        \"properties\": {\"description\": \"target\"},\n                        \"geometry\": {\n                            \"type\": \"Point\",\n                            \"coordinates\": [-59.12970828579045, -52.51860490233211],\n                        },\n                    },\n                    {\n                        \"type\": \"Feature\",\n                        \"properties\": {\"description\": \"threat_zones\"},\n                        \"geometry\": {\"type\": \"MultiPolygon\", \"coordinates\": []},\n                    },\n                ],\n            }\n        )\n    )\n    solver = WaypointSolverLoader(debug_info_path).load()\n    assert isinstance(solver, IpSolver)\n    assert solver.doctrine.name == \"coldwar\"\n    assert solver.threat_zones.is_empty\n    assert solver.departure.x == pytest.approx(0, abs=1e-8)\n    assert solver.departure.y == pytest.approx(0, abs=1e-8)\n    assert solver.target.x == pytest.approx(-5436.058, abs=0.001)\n    assert solver.target.y == pytest.approx(3138.51, abs=0.001)\n"}
{"type": "test_file", "path": "tests/flightplan/test_waypointstrategy.py", "content": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\nfrom pytest import approx\nfrom shapely.geometry import Point, MultiPolygon\n\nfrom game.flightplan.waypointstrategy import WaypointStrategy, angle_between_points\nfrom game.utils import meters, Heading\n\n\ndef test_safe_prerequisite_safe_point() -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    strategy.prerequisite(Point(0, 0)).is_safe()\n    assert strategy.prerequisites_are_satisfied()\n\n\ndef test_safe_prerequisite_unsafe_point() -> None:\n    strategy = WaypointStrategy(MultiPolygon([Point(0, 0).buffer(1)]))\n    strategy.prerequisite(Point(0, 0)).is_safe()\n    assert not strategy.prerequisites_are_satisfied()\n\n\ndef test_no_solution_if_prerequisites_failed() -> None:\n    \"\"\"Verify that no solution is found if prerequisites are not satisfied.\n\n    This test has a 1-meter radius threat zone about the center of the plane. It has a\n    prerequisite for a safe center, which will fail. The test verifies that even if\n    there are no .require() constraints that would prevent finding a solution, failed\n    prerequisites still prevent it (prerequisites differ from constraints in that they\n    will prevent any of the other operations from happening without needing to location\n    constraints, which is important because it allows strategies to avoid defending\n    against invalid cases).\n    \"\"\"\n    strategy = WaypointStrategy(MultiPolygon([Point(0, 0).buffer(1)]))\n    strategy.prerequisite(Point(0, 0)).is_safe()\n    # This constraint won't actually apply, but it's required before calling find() so\n    # we need to set it even though it's not actually relevant to the test.\n    strategy.nearest(Point(0, 0))\n    assert strategy.find() is None\n\n\ndef test_has_solution_if_prerequisites_satisfied() -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    strategy.prerequisite(Point(0, 0)).is_safe()\n    strategy.nearest(Point(0, 0))\n    assert strategy.find() is not None\n\n\ndef test_require_nearest() -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    center = Point(0, 0)\n    strategy.nearest(center)\n    assert strategy.find() == center\n\n\ndef test_find_without_nearest_raises() -> None:\n    with pytest.raises(RuntimeError):\n        WaypointStrategy(MultiPolygon([])).find()\n\n\ndef test_multiple_nearest_raises() -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    strategy.nearest(Point(0, 0))\n    with pytest.raises(RuntimeError):\n        strategy.nearest(Point(0, 0))\n\n\ndef test_require_at_least() -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    center = Point(0, 0)\n    strategy.require().at_least(meters(10)).away_from(center)\n    strategy.nearest(center)\n    solution = strategy.find()\n    assert solution is not None\n    assert solution.distance(center) == approx(10, 0.1)\n\n\ndef test_require_at_most() -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    center = Point(0, 0)\n    strategy.require().at_most(meters(1)).away_from(center)\n    strategy.nearest(Point(10, 0))\n    solution = strategy.find()\n    assert solution is not None\n    assert solution.distance(center) <= 1\n\n\ndef test_require_safe() -> None:\n    threat = MultiPolygon([Point(0, 0).buffer(10)])\n    strategy = WaypointStrategy(threat)\n    strategy.require().safe()\n    strategy.nearest(Point(0, 0))\n    solution = strategy.find()\n    assert solution is not None\n    assert not solution.intersects(threat)\n\n\ndef test_require_maximum_turn_to() -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    turn_point = Point(1, 0)\n    turn_target = Point(0, 0)\n    strategy.require().maximum_turn_to(turn_point, turn_target, Heading(90))\n    strategy.nearest(Point(0, 1))\n    pre_turn_heading = Heading.from_degrees(\n        angle_between_points(strategy.find(), turn_point)\n    )\n    post_turn_heading = Heading.from_degrees(\n        angle_between_points(turn_point, turn_target)\n    )\n    assert pre_turn_heading.angle_between(post_turn_heading) <= Heading(90)\n\n\ndef test_combined_constraints() -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    center = Point(0, 0)\n    offset = Point(1, 0)\n    midpoint = Point(0.5, 0)\n    strategy.require().at_least(meters(1)).away_from(center)\n    strategy.require().at_least(meters(1)).away_from(offset)\n    strategy.nearest(midpoint)\n    solution = strategy.find()\n    assert solution is not None\n    assert solution.distance(center) == approx(1, rel=0.1, abs=0.1)\n    assert solution.distance(offset) == approx(1, rel=0.1, abs=0.1)\n    assert solution.distance(midpoint) < 1\n\n\ndef test_threat_tolerance(tmp_path: Path) -> None:\n    home = Point(20, 0)\n    target = Point(-1, 0)\n    max_distance = meters(5)\n    threat = MultiPolygon([Point(0, 0).buffer(10)])\n    strategy = WaypointStrategy(threat)\n    strategy.require().at_most(max_distance).away_from(target)\n    strategy.threat_tolerance(target, max_distance, meters(1))\n    strategy.require().safe()\n    strategy.nearest(home)\n    solution = strategy.find()\n    assert solution is not None\n    # Max distance of 5 from -1, so the point should be at 4. Home is at 20.\n    assert solution.distance(home) == 16\n\n\ndef test_threat_tolerance_does_nothing_if_no_threats(tmp_path: Path) -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    strategy.threat_tolerance(Point(0, 0), meters(1), meters(1))\n    assert strategy._threat_tolerance is None\n\n\ndef test_no_solutions() -> None:\n    strategy = WaypointStrategy(MultiPolygon([]))\n    strategy.require().at_most(meters(1)).away_from(Point(0, 0))\n    strategy.require().at_least(meters(2)).away_from(Point(0, 0))\n    strategy.nearest(Point(0, 0))\n    assert strategy.find() is None\n\n\ndef test_debug() -> None:\n    center = Point(0, 0)\n    threat = MultiPolygon([center.buffer(5)])\n    strategy = WaypointStrategy(threat)\n    strategy.require().at_most(meters(10)).away_from(center, \"center\")\n    strategy.require().at_least(meters(2)).away_from(center)\n    strategy.require().safe()\n    strategy.nearest(center)\n    solution = strategy.find()\n    assert solution is not None\n    debug_info = list(strategy.iter_debug_info())\n    assert len(debug_info) == 4\n    max_distance_debug, min_distance_debug, safe_debug, solution_debug = debug_info\n    assert max_distance_debug.description == \"at most 10 meters away from center\"\n    assert max_distance_debug.geometry.distance(center) == approx(10, 0.1)\n    assert min_distance_debug.description == \"at least 2 meters away from POINT (0 0)\"\n    assert max_distance_debug.geometry.boundary.distance(center) == approx(10, 0.1)\n    assert safe_debug.description == \"safe\"\n    assert safe_debug.geometry == threat\n    assert solution_debug.description == \"solution\"\n    assert solution_debug.geometry == solution\n\n\ndef test_debug_info_omits_solution_if_none() -> None:\n    center = Point(0, 0)\n    strategy = WaypointStrategy(MultiPolygon([]))\n    strategy.require().at_most(meters(1)).away_from(center)\n    strategy.require().at_least(meters(2)).away_from(center)\n    strategy.nearest(center)\n    debug_infos = list(strategy.iter_debug_info())\n    assert len(debug_infos) == 2\n"}
{"type": "test_file", "path": "tests/flightplan/waypointactions/test_engagetargets.py", "content": "from datetime import datetime, timedelta\n\nfrom dcs.task import Targets\n\nfrom game.ato.flightstate.actionstate import ActionState\nfrom game.flightplan.waypointactions.engagetargets import EngageTargets\nfrom game.flightplan.waypointactions.taskcontext import TaskContext\nfrom game.utils import meters\n\n\ndef test_engage_targets() -> None:\n    tasks = list(\n        EngageTargets(\n            meters(100), [Targets.All.Air.Planes, Targets.All.Air.Helicopters]\n        ).iter_tasks(TaskContext(datetime.now()))\n    )\n    assert len(tasks) == 1\n    task = tasks[0]\n    assert task.id == \"EngageTargets\"\n    assert task.params[\"targetTypes\"] == {\n        1: Targets.All.Air.Planes,\n        2: Targets.All.Air.Helicopters,\n    }\n    assert task.params[\"value\"] == \"Planes;Helicopters\"\n    assert task.params[\"maxDist\"] == 100\n\n\ndef test_engage_targets_update_state() -> None:\n    task = EngageTargets(meters(100), [Targets.All])\n    state = ActionState(task)\n    assert not task.update_state(state, datetime.now(), timedelta())\n    assert state.is_finished()\n\n\ndef test_engage_targets_description() -> None:\n    assert (\n        EngageTargets(meters(100), [Targets.All]).describe() == \"Searching for targets\"\n    )\n"}
{"type": "test_file", "path": "tests/flightplan/waypointactions/test_hold.py", "content": "from datetime import datetime, timedelta\n\nfrom game.ato.flightstate.actionstate import ActionState\nfrom game.flightplan.waypointactions.hold import Hold\nfrom game.flightplan.waypointactions.taskcontext import TaskContext\nfrom game.utils import meters, kph\n\n\ndef test_hold_tasks() -> None:\n    t0 = datetime(1999, 3, 28)\n    tasks = list(\n        Hold(lambda: t0 + timedelta(minutes=5), meters(8000), kph(400)).iter_tasks(\n            TaskContext(t0 + timedelta(minutes=1))\n        )\n    )\n    assert len(tasks) == 1\n    task = tasks[0]\n    assert task.id == \"ControlledTask\"\n    assert task.params[\"stopCondition\"][\"time\"] == 4 * 60\n    assert task.params[\"task\"][\"id\"] == \"Orbit\"\n    assert task.params[\"task\"][\"params\"][\"altitude\"] == 8000\n    assert task.params[\"task\"][\"params\"][\"pattern\"] == \"Circle\"\n    assert task.params[\"task\"][\"params\"][\"speed\"] == kph(400).meters_per_second\n\n\ndef test_hold_task_at_or_after_push() -> None:\n    t0 = datetime(1999, 3, 28)\n    assert not list(\n        Hold(lambda: t0, meters(8000), kph(400)).iter_tasks(TaskContext(t0))\n    )\n    assert not list(\n        Hold(lambda: t0, meters(8000), kph(400)).iter_tasks(\n            TaskContext(t0 + timedelta(minutes=1))\n        )\n    )\n\n\ndef test_hold_tick() -> None:\n    t0 = datetime(1999, 3, 28)\n    task = Hold(lambda: t0 + timedelta(minutes=5), meters(8000), kph(400))\n    state = ActionState(task)\n    assert not task.update_state(state, t0, timedelta())\n    assert not state.is_finished()\n    assert not task.update_state(state, t0 + timedelta(minutes=1), timedelta(minutes=1))\n    assert not state.is_finished()\n    assert not task.update_state(state, t0 + timedelta(minutes=2), timedelta(minutes=1))\n    assert not state.is_finished()\n    assert not task.update_state(state, t0 + timedelta(minutes=3), timedelta(minutes=1))\n    assert not state.is_finished()\n    assert not task.update_state(state, t0 + timedelta(minutes=4), timedelta(minutes=1))\n    assert not state.is_finished()\n    assert not task.update_state(state, t0 + timedelta(minutes=5), timedelta(minutes=1))\n    assert state.is_finished()\n    assert task.update_state(\n        state, t0 + timedelta(minutes=6), timedelta(minutes=1)\n    ) == timedelta(minutes=1)\n    assert state.is_finished()\n\n\ndef test_hold_description() -> None:\n    assert (\n        Hold(\n            lambda: datetime(1999, 3, 28) + timedelta(minutes=5), meters(8000), kph(400)\n        ).describe()\n        == \"Holding until 00:05:00\"\n    )\n"}
{"type": "test_file", "path": "tests/flightplan/waypointoptions/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/flightplan/waypointoptions/test_formation.py", "content": "from datetime import datetime\n\nfrom dcs.task import OptFormation\n\nfrom game.flightplan.waypointactions.taskcontext import TaskContext\nfrom game.flightplan.waypointoptions.formation import Formation\n\n\ndef test_formation() -> None:\n    tasks = list(Formation.LINE_ABREAST_OPEN.iter_tasks(TaskContext(datetime.now())))\n    assert len(tasks) == 1\n    task = tasks[0]\n    assert task.dict() == OptFormation.line_abreast_open().dict()\n"}
{"type": "test_file", "path": "tests/flightplan/waypointsolvertestcasereducer.py", "content": "from __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom pathlib import Path\nfrom typing import Any, TypeVar, Generic\n\nfrom shapely import Point, MultiPolygon\nfrom shapely.geometry import shape\n\nfrom game.data.doctrine import Doctrine\nfrom game.flightplan.ipsolver import IpSolver\nfrom game.flightplan.waypointsolver import WaypointSolver, NoSolutionsError\nfrom game.flightplan.waypointsolverloader import WaypointSolverLoader\nfrom game.theater.theaterloader import TERRAINS_BY_NAME\n\nReducerT = TypeVar(\"ReducerT\")\n\n\ndef doctrine_from_name(name: str) -> Doctrine:\n    return Doctrine.named(name)\n\n\nclass Reducer(Generic[ReducerT], Iterator[ReducerT], ABC):\n    @abstractmethod\n    def accept(self) -> None: ...\n\n    @abstractmethod\n    def reject(self) -> None: ...\n\n\nclass MultiPolyReducer(Reducer[MultiPolygon]):\n    def __init__(self, multipoly: MultiPolygon) -> None:\n        self._multipoly: MultiPolygon | None = multipoly\n        self._previous_poly: MultiPolygon | None = None\n        self._remove_index = 0\n\n    def __next__(self) -> MultiPolygon:\n        if self._multipoly is None:\n            raise StopIteration\n        return self._multipoly\n\n    def _reduce_poly(self) -> None:\n        assert self._multipoly is not None\n        polys = list(self._multipoly.geoms)\n        if not polys or self._remove_index >= len(polys):\n            self._multipoly = None\n            return\n\n        del polys[self._remove_index]\n        self._previous_poly = self._multipoly\n        self._multipoly = MultiPolygon(polys)\n\n    def accept(self) -> None:\n        self._reduce_poly()\n\n    def reject(self) -> None:\n        self._multipoly = self._previous_poly\n        self._previous_poly = None\n        self._remove_index += 1\n        self._reduce_poly()\n\n\nclass IpSolverReducer(Reducer[IpSolver]):\n    def __init__(\n        self,\n        departure: Point,\n        target: Point,\n        doctrine: Doctrine,\n        threat_zones: MultiPolygon,\n    ) -> None:\n        self.departure = departure\n        self.target = target\n        self.doctrine = doctrine\n        self.threat_zones_reducer = MultiPolyReducer(threat_zones)\n\n    @staticmethod\n    def from_metadata_and_feature_collection(\n        metadata: dict[str, Any], feature_collection: dict[str, Any]\n    ) -> IpSolverReducer:\n        departure: Point | None = None\n        target: Point | None = None\n        threat_zones: MultiPolygon | None = None\n        for feature in feature_collection[\"features\"]:\n            description = feature[\"properties\"][\"description\"]\n            geometry = feature[\"geometry\"]\n            match description:\n                case \"departure\":\n                    departure = shape(geometry)\n                case \"target\":\n                    target = shape(geometry)\n                case \"threat_zones\":\n                    threat_zones = shape(geometry)\n\n        if departure is None:\n            raise KeyError(\"feature collection has no departure point\")\n        if target is None:\n            raise KeyError(\"feature collection has no target point\")\n        if threat_zones is None:\n            raise KeyError(\"feature collection has no threat zones\")\n\n        return IpSolverReducer(\n            departure,\n            target,\n            doctrine_from_name(metadata[\"doctrine\"]),\n            threat_zones,\n        )\n\n    def __next__(self) -> IpSolver:\n        return IpSolver(\n            self.departure, self.target, self.doctrine, next(self.threat_zones_reducer)\n        )\n\n    def accept(self) -> None:\n        self.threat_zones_reducer.accept()\n\n    def reject(self) -> None:\n        self.threat_zones_reducer.reject()\n\n\nclass WaypointSolverTestCaseReducer:\n    def __init__(self, debug_directory: Path, out_dir: Path) -> None:\n        self.debug_directory = debug_directory\n        self.out_dir = out_dir\n        if self.out_dir.exists():\n            raise ValueError(f\"out_dir {out_dir} already exists\")\n\n    @staticmethod\n    def _reducer_from_solver(solver: WaypointSolver) -> Reducer[Any]:\n        if isinstance(solver, IpSolver):\n            return IpSolverReducer(\n                solver.departure, solver.target, solver.doctrine, solver.threat_zones\n            )\n        else:\n            raise KeyError(f\"Unhandled waypoint solver {solver.__class__.__name__}\")\n\n    def reduce(self) -> None:\n        loader = WaypointSolverLoader(self.debug_directory / \"solver.json\")\n        solver = loader.load()\n        last_broken: WaypointSolver | None = None\n        reducer = self._reducer_from_solver(solver)\n        for solver in reducer:\n            try:\n                solver.solve()\n                reducer.reject()\n            except NoSolutionsError:\n                last_broken = solver\n                reducer.accept()\n\n        if last_broken is None:\n            raise RuntimeError(\"all cases succeeded, nothing to reduce\")\n\n        self.out_dir.mkdir(parents=True)\n        last_broken.set_debug_properties(\n            self.out_dir, TERRAINS_BY_NAME[loader.load_data()[\"metadata\"][\"terrain\"]]\n        )\n        last_broken.dump_debug_info()\n"}
{"type": "test_file", "path": "tests/lasercodes/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/lasercodes/test_lasercode.py", "content": "import pytest\n\nfrom game.lasercodes import ILaserCodeRegistry\nfrom game.lasercodes.lasercode import LaserCode\n\n\nclass MockRegistry(ILaserCodeRegistry):\n    def __init__(self) -> None:\n        self.release_count = 0\n\n    def alloc_laser_code(self) -> LaserCode:\n        raise NotImplementedError\n\n    def release_code(self, code: LaserCode) -> None:\n        self.release_count += 1\n\n\n@pytest.fixture(name=\"registry\")\ndef mock_registry() -> MockRegistry:\n    return MockRegistry()\n\n\ndef test_lasercode_code(registry: ILaserCodeRegistry) -> None:\n    assert LaserCode(1688, registry).code == 1688\n\n    # 1113 doesn't comply to the rules, but is the only code valid for FC3 aircraft like\n    # the A-10A.\n    assert LaserCode(1113, registry).code == 1113\n\n    # The first digit must be 1\n    with pytest.raises(ValueError):\n        # And be exactly 4 digits\n        LaserCode(2688, registry)\n\n    # The code must be exactly 4 digits\n    with pytest.raises(ValueError):\n        LaserCode(888, registry)\n    with pytest.raises(ValueError):\n        LaserCode(18888, registry)\n\n    # 0 and 9 are invalid digits\n    with pytest.raises(ValueError):\n        LaserCode(1088, registry)\n    with pytest.raises(ValueError):\n        LaserCode(1608, registry)\n    with pytest.raises(ValueError):\n        LaserCode(1680, registry)\n    with pytest.raises(ValueError):\n        LaserCode(1988, registry)\n    with pytest.raises(ValueError):\n        LaserCode(1698, registry)\n    with pytest.raises(ValueError):\n        LaserCode(1689, registry)\n\n    # The second digit is further constrained to be 5, 6, or 7.\n    with pytest.raises(ValueError):\n        LaserCode(1188, registry)\n    with pytest.raises(ValueError):\n        LaserCode(1288, registry)\n    with pytest.raises(ValueError):\n        LaserCode(1388, registry)\n    with pytest.raises(ValueError):\n        LaserCode(1488, registry)\n    with pytest.raises(ValueError):\n        LaserCode(1888, registry)\n\n\ndef test_lasercode_release(registry: MockRegistry) -> None:\n    code = LaserCode(1688, registry)\n    assert registry.release_count == 0\n    code.release()\n    assert registry.release_count == 1\n    code.release()\n    assert registry.release_count == 2\n"}
{"type": "test_file", "path": "tests/lasercodes/test_lasercoderegistry.py", "content": "from game.lasercodes.lasercoderegistry import LaserCodeRegistry\n\n\ndef test_initial_laser_codes() -> None:\n    reg = LaserCodeRegistry()\n    assert list(reg.available_codes)[:5] == [1688, 1687, 1686, 1685, 1684]\n    assert list(reg.available_codes)[-5:] == [1715, 1714, 1713, 1712, 1711]\n    assert len(reg.available_codes) == 192\n\n\ndef test_alloc_laser_code() -> None:\n    reg = LaserCodeRegistry()\n    assert reg.alloc_laser_code().code == 1688\n    assert 1688 not in reg.available_codes\n    assert len(reg.available_codes) == 191\n\n\ndef test_release_code() -> None:\n    reg = LaserCodeRegistry()\n    code = reg.alloc_laser_code()\n    code.release()\n    assert code.code in reg.available_codes\n    assert len(reg.available_codes) == 192\n    code.release()\n    assert len(reg.available_codes) == 192\n"}
{"type": "test_file", "path": "tests/missiongenerator/aircraft/test_bingoestimator.py", "content": "import pytest\nfrom dcs import Point\nfrom dcs.terrain import Terrain, Caucasus\n\nfrom game.ato import FlightWaypoint\nfrom game.ato.flightwaypointtype import FlightWaypointType\nfrom game.dcs.aircrafttype import FuelConsumption\nfrom game.missiongenerator.aircraft.bingoestimator import BingoEstimator\nfrom game.utils import nautical_miles\n\n\n@pytest.fixture(name=\"terrain\")\ndef terrain_fixture() -> Terrain:\n    return Caucasus()\n\n\n@pytest.fixture(name=\"waypoints\")\ndef waypoints_fixture(terrain: Terrain) -> list[FlightWaypoint]:\n    return [\n        FlightWaypoint(\n            \"\", FlightWaypointType.NAV, Point(0, nautical_miles(d).meters, terrain)\n        )\n        for d in range(101)\n    ]\n\n\ndef test_legacy_bingo_estimator(\n    waypoints: list[FlightWaypoint], terrain: Terrain\n) -> None:\n    estimator = BingoEstimator(None, Point(0, 0, terrain), None, waypoints)\n    assert estimator.estimate_bingo() == 3000\n    assert estimator.estimate_joker() == estimator.estimate_bingo() + 1000\n    estimator = BingoEstimator(\n        None, Point(0, 0, terrain), Point(0, 5, terrain), waypoints\n    )\n    assert estimator.estimate_bingo() == 4000\n    assert estimator.estimate_joker() == estimator.estimate_bingo() + 1000\n\n\ndef test_fuel_consumption_based_bingo_estimator(\n    waypoints: list[FlightWaypoint], terrain: Terrain\n) -> None:\n    consumption = FuelConsumption(100, 50, 10, 25, 1000)\n    estimator = BingoEstimator(consumption, Point(0, 0, terrain), None, waypoints)\n    assert estimator.estimate_bingo() == 2000\n    assert estimator.estimate_joker() == estimator.estimate_bingo() + 1000\n    estimator = BingoEstimator(\n        consumption, Point(0, 0, terrain), Point(0, 5, terrain), waypoints\n    )\n    assert estimator.estimate_bingo() == 2000\n    assert estimator.estimate_joker() == estimator.estimate_bingo() + 1000\n"}
{"type": "test_file", "path": "tests/persistence/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/persistence/conftest.py", "content": "import datetime\nfrom typing import cast\n\nimport pytest\n\nfrom game import Game\nfrom game.persistence import SaveManager\n\n\nclass StubGame:\n    def __init__(self) -> None:\n        self.date = datetime.date.min\n        self.save_manager = SaveManager(cast(Game, self))\n\n\n@pytest.fixture\ndef game() -> Game:\n    return cast(Game, StubGame())\n"}
{"type": "test_file", "path": "tests/persistence/test_savegamebundle.py", "content": "import datetime\nfrom pathlib import Path\nfrom zipfile import ZipFile\n\nimport pytest\n\nfrom game import Game\nfrom game.persistence.savegamebundle import SaveGameBundle\n\n\n@pytest.fixture\ndef tmp_bundle(tmp_zip: Path) -> SaveGameBundle:\n    return SaveGameBundle(tmp_zip)\n\n\ndef test_save_player_new_save(game: Game, tmp_bundle: SaveGameBundle) -> None:\n    with ZipFile(tmp_bundle.bundle_path, \"r\") as zip_file:\n        with pytest.raises(KeyError):\n            zip_file.read(SaveGameBundle.MANUAL_SAVE_NAME)\n    tmp_bundle.save_player(game, copy_from=None)\n\n    with ZipFile(tmp_bundle.bundle_path, \"r\") as zip_file:\n        assert zip_file.namelist() == [SaveGameBundle.MANUAL_SAVE_NAME]\n\n\ndef test_save_player_existing_save(game: Game, tmp_bundle: SaveGameBundle) -> None:\n    game.date = datetime.date.min\n    tmp_bundle.save_start_of_turn(game)\n    tmp_bundle.save_player(game, copy_from=tmp_bundle)\n\n    test_date = datetime.date.today()\n    game.date = test_date\n    tmp_bundle.save_player(game, copy_from=tmp_bundle)\n\n    assert tmp_bundle.load_start_of_turn().date == datetime.date.min\n    assert tmp_bundle.load_player().date == test_date\n\n\ndef test_save_last_turn(game: Game, tmp_bundle: SaveGameBundle) -> None:\n    with ZipFile(tmp_bundle.bundle_path, \"r\") as zip_file:\n        with pytest.raises(KeyError):\n            zip_file.read(SaveGameBundle.LAST_TURN_SAVE_NAME)\n    tmp_bundle.save_last_turn(game)\n\n    with ZipFile(tmp_bundle.bundle_path, \"r\") as zip_file:\n        assert zip_file.namelist() == [SaveGameBundle.LAST_TURN_SAVE_NAME]\n\n\ndef test_save_start_of_turn(game: Game, tmp_bundle: SaveGameBundle) -> None:\n    with ZipFile(tmp_bundle.bundle_path, \"r\") as zip_file:\n        with pytest.raises(KeyError):\n            zip_file.read(SaveGameBundle.START_OF_TURN_SAVE_NAME)\n    tmp_bundle.save_start_of_turn(game)\n\n    with ZipFile(tmp_bundle.bundle_path, \"r\") as zip_file:\n        assert zip_file.namelist() == [SaveGameBundle.START_OF_TURN_SAVE_NAME]\n\n\ndef test_save_pre_sim_checkpoint(game: Game, tmp_bundle: SaveGameBundle) -> None:\n    with ZipFile(tmp_bundle.bundle_path, \"r\") as zip_file:\n        with pytest.raises(KeyError):\n            zip_file.read(SaveGameBundle.PRE_SIM_CHECKPOINT_SAVE_NAME)\n    tmp_bundle.save_pre_sim_checkpoint(game)\n\n    with ZipFile(tmp_bundle.bundle_path, \"r\") as zip_file:\n        assert zip_file.namelist() == [SaveGameBundle.PRE_SIM_CHECKPOINT_SAVE_NAME]\n\n\ndef test_failed_save_leaves_original_intact(\n    game: Game, tmp_bundle: SaveGameBundle\n) -> None:\n    expect_date = datetime.date.today()\n    game.date = expect_date\n    tmp_bundle.save_player(game, copy_from=None)\n\n    # Add some non-pickleable member to the game to cause an error on save.\n    def local_f() -> None:\n        pass\n\n    game.garbage = local_f  # type: ignore\n    with pytest.raises(AttributeError):\n        tmp_bundle.save_player(game, copy_from=tmp_bundle)\n\n    assert tmp_bundle.load_player().date == expect_date\n\n\ndef test_load_reads_correct_data(game: Game, tmp_bundle: SaveGameBundle) -> None:\n    last_turn_date = datetime.date.today() - datetime.timedelta(days=2)\n    game.date = last_turn_date\n    tmp_bundle.save_last_turn(game)\n\n    start_of_turn_date = datetime.date.today() - datetime.timedelta(days=1)\n    game.date = start_of_turn_date\n    tmp_bundle.save_start_of_turn(game)\n\n    player_date = datetime.date.today()\n    game.date = player_date\n    tmp_bundle.save_player(game, copy_from=tmp_bundle)\n\n    assert tmp_bundle.load_last_turn().date == last_turn_date\n    assert tmp_bundle.load_start_of_turn().date == start_of_turn_date\n    assert tmp_bundle.load_player().date == player_date\n\n\ndef test_load_from_absent_file_raises(tmp_bundle: SaveGameBundle) -> None:\n    tmp_bundle.bundle_path.unlink(missing_ok=True)\n    with pytest.raises(FileNotFoundError):\n        tmp_bundle.load_last_turn()\n\n\ndef test_load_from_absent_member_raises(game: Game, tmp_bundle: SaveGameBundle) -> None:\n    tmp_bundle.save_start_of_turn(game)\n    with pytest.raises(KeyError):\n        tmp_bundle.load_last_turn()\n"}
{"type": "test_file", "path": "tests/persistence/test_savemanager.py", "content": "import datetime\nfrom pathlib import Path\nfrom unittest.mock import Mock\n\nimport pytest\nfrom pytest_mock import MockerFixture\n\nfrom game import Game\nfrom game.persistence import SaveManager, set_dcs_save_game_directory\n\n\n@pytest.fixture(autouse=True)\ndef mock_setup_last_save_file(mocker: MockerFixture) -> Mock:\n    return mocker.patch(\"qt_ui.liberation_install.setup_last_save_file\")\n\n\n@pytest.fixture(autouse=True)\ndef mock_save_config(mocker: MockerFixture) -> Mock:\n    return mocker.patch(\"qt_ui.liberation_install.save_config\")\n\n\n@pytest.fixture(autouse=True)\ndef setup_persistence_paths(tmp_path: Path) -> None:\n    set_dcs_save_game_directory(tmp_path)\n\n\n@pytest.fixture\ndef save_manager(game: Game) -> SaveManager:\n    return game.save_manager\n\n\ndef test_new_savemanager_saves_to_autosave(save_manager: SaveManager) -> None:\n    assert save_manager.default_save_location == save_manager.autosave_path\n\n\ndef test_savemanager_saves_to_last_save_location(save_manager: SaveManager) -> None:\n    save_manager.player_save_location = Path(\"Saves/foo.liberation.zip\")\n    assert save_manager.default_save_location == save_manager.player_save_location\n\n\ndef test_saving_without_name_saves_to_autosave_path(save_manager: SaveManager) -> None:\n    assert not save_manager.autosave_path.exists()\n    save_manager.save_player()\n    assert save_manager.autosave_path.exists()\n\n\ndef test_saving_with_name_updates_last_save_location(\n    save_manager: SaveManager, tmp_path: Path\n) -> None:\n    save_path = tmp_path / \"foo.liberation.zip\"\n    assert not save_path.exists()\n    save_manager.save_player(override_destination=save_path)\n    assert save_path.exists()\n    assert save_manager.last_saved_bundle is not None\n    assert save_manager.last_saved_bundle.bundle_path == save_path\n\n\ndef test_player_save_location(save_manager: SaveManager, tmp_path: Path) -> None:\n    assert save_manager.player_save_location is None\n    save_manager.save_last_turn()\n    assert save_manager.player_save_location is None\n    save_manager.save_start_of_turn()\n    assert save_manager.player_save_location is None\n    expect_location = tmp_path / \"player.liberation.zip\"\n    save_manager.save_player(override_destination=expect_location)\n    assert save_manager.player_save_location == expect_location\n\n\ndef test_saving_updates_preferences_with_save_location(\n    save_manager: SaveManager, mock_setup_last_save_file: Mock, mock_save_config: Mock\n) -> None:\n    save_manager.save_player()\n    mock_setup_last_save_file.assert_called_once_with(\n        str(save_manager.default_save_location)\n    )\n    mock_save_config.assert_called_once()\n\n\ndef test_non_player_saves_do_not_update_preferences(\n    save_manager: SaveManager, mock_setup_last_save_file: Mock\n) -> None:\n    save_manager.save_last_turn()\n    mock_setup_last_save_file.assert_not_called()\n    save_manager.save_start_of_turn()\n    mock_setup_last_save_file.assert_not_called()\n\n\ndef test_load_game_loads_correct_data(save_manager: SaveManager) -> None:\n    test_date = datetime.date.today()\n    assert save_manager.game.date != test_date\n    save_manager.game.date = test_date\n    save_manager.save_player()\n    game = SaveManager.load_player_save(save_manager.default_save_location)\n    assert game.date == test_date\n\n\ndef test_loading_missing_save_raises() -> None:\n    with pytest.raises(FileNotFoundError):\n        SaveManager.load_player_save(Path(\"does not exist\"))\n\n\ndef test_saving_after_autosave_copies_autosave_members(\n    save_manager: SaveManager, tmp_path: Path\n) -> None:\n    save_manager.save_start_of_turn()\n\n    save_path = tmp_path / \"foo.liberation.zip\"\n    save_manager.save_player(override_destination=save_path)\n\n    SaveManager.load_start_of_turn(save_path)\n\n\ndef test_failed_save_does_not_update_last_saved_path(\n    save_manager: SaveManager, tmp_path: Path\n) -> None:\n    expect_date = datetime.date.today()\n    save_manager.game.date = expect_date\n    save_manager.save_player()\n    assert save_manager.last_saved_bundle is not None\n    expect_path = save_manager.last_saved_bundle.bundle_path\n\n    # Add some non-pickleable member to the game to cause an error on save.\n    def local_f() -> None:\n        pass\n\n    save_manager.game.garbage = local_f  # type: ignore\n    with pytest.raises(AttributeError):\n        save_manager.save_player(\n            override_destination=tmp_path / \"badsave.liberation.zip\"\n        )\n\n    assert save_manager.last_saved_bundle.bundle_path == expect_path\n\n\ndef test_load_reads_correct_data(save_manager: SaveManager) -> None:\n    last_turn_date = datetime.date.today() - datetime.timedelta(days=2)\n    save_manager.game.date = last_turn_date\n    save_manager.save_last_turn()\n\n    start_of_turn_date = datetime.date.today() - datetime.timedelta(days=1)\n    save_manager.game.date = start_of_turn_date\n    save_manager.save_start_of_turn()\n\n    player_date = datetime.date.today()\n    save_manager.game.date = player_date\n    save_manager.save_player()\n\n    assert save_manager.last_saved_bundle is not None\n    bundle_path = save_manager.last_saved_bundle.bundle_path\n    assert SaveManager.load_last_turn(bundle_path).date == last_turn_date\n    assert SaveManager.load_start_of_turn(bundle_path).date == start_of_turn_date\n    assert SaveManager.load_player_save(bundle_path).date == player_date\n\n\ndef test_save_after_loading_foreign_save(\n    save_manager: SaveManager, tmp_path: Path\n) -> None:\n    \"\"\"Tests that we can save games that were copied from another machine.\n\n    Regression test for https://github.com/dcs-liberation/dcs_liberation/issues/2756.\n    \"\"\"\n    # To simulate the situation from the bug, we save a game to a directory, move it out\n    # of that directory, delete the directory, then attempt to load and save the game.\n    # It should save to the new location. If it tries to save to the old location, it\n    # will fail because the directory does not exist.\n\n    # Create the save on \"the other machine\"...\n    bad_directory = tmp_path / \"other-machine\"\n    bad_directory.mkdir()\n    bad_save_path = bad_directory / \"foo.liberation.zip\"\n    save_manager.save_player(override_destination=bad_save_path)\n\n    good_save_path = tmp_path / \"foo.liberation.zip\"\n    bad_save_path.rename(good_save_path)\n    bad_directory.rmdir()\n\n    game = SaveManager.load_player_save(good_save_path)\n    assert game.save_manager.player_save_location == good_save_path\n    game.save_manager.save_player()\n"}
{"type": "test_file", "path": "tests/test_daytimemap.py", "content": "from datetime import time\n\nimport pytest\n\nfrom game.theater.daytimemap import DaytimeMap\nfrom game.timeofday import TimeOfDay\n\n\ndef test_range_of() -> None:\n    m = DaytimeMap(\n        dawn=(time(hour=6), time(hour=9)),\n        day=(time(hour=9), time(hour=18)),\n        dusk=(time(hour=18), time(hour=20)),\n        night=(time(hour=0), time(hour=5)),\n    )\n\n    assert m.range_of(TimeOfDay.Dawn) == (time(hour=6), time(hour=9))\n    assert m.range_of(TimeOfDay.Day) == (time(hour=9), time(hour=18))\n    assert m.range_of(TimeOfDay.Dusk) == (time(hour=18), time(hour=20))\n    assert m.range_of(TimeOfDay.Night) == (time(hour=0), time(hour=5))\n\n\ndef test_best_guess_time_of_day_at() -> None:\n    night_at_midnight = DaytimeMap(\n        dawn=(time(hour=6), time(hour=9)),\n        day=(time(hour=9), time(hour=18)),\n        dusk=(time(hour=18), time(hour=20)),\n        night=(time(hour=0), time(hour=5)),\n    )\n\n    assert night_at_midnight.best_guess_time_of_day_at(time(hour=0)) == TimeOfDay.Night\n    assert night_at_midnight.best_guess_time_of_day_at(time(hour=5)) == TimeOfDay.Night\n    assert night_at_midnight.best_guess_time_of_day_at(time(hour=6)) == TimeOfDay.Dawn\n    assert night_at_midnight.best_guess_time_of_day_at(time(hour=7)) == TimeOfDay.Dawn\n    assert night_at_midnight.best_guess_time_of_day_at(time(hour=9)) == TimeOfDay.Day\n    assert night_at_midnight.best_guess_time_of_day_at(time(hour=10)) == TimeOfDay.Day\n    assert night_at_midnight.best_guess_time_of_day_at(time(hour=18)) == TimeOfDay.Dusk\n    assert night_at_midnight.best_guess_time_of_day_at(time(hour=19)) == TimeOfDay.Dusk\n\n    night_before_midnight = DaytimeMap(\n        dawn=(time(hour=6), time(hour=9)),\n        day=(time(hour=9), time(hour=18)),\n        dusk=(time(hour=18), time(hour=20)),\n        night=(time(hour=22), time(hour=5)),\n    )\n\n    assert (\n        night_before_midnight.best_guess_time_of_day_at(time(hour=0)) == TimeOfDay.Night\n    )\n    assert (\n        night_before_midnight.best_guess_time_of_day_at(time(hour=1)) == TimeOfDay.Night\n    )\n    assert (\n        night_before_midnight.best_guess_time_of_day_at(time(hour=22))\n        == TimeOfDay.Night\n    )\n    assert (\n        night_before_midnight.best_guess_time_of_day_at(time(hour=23))\n        == TimeOfDay.Night\n    )\n    assert (\n        night_before_midnight.best_guess_time_of_day_at(time(hour=6)) == TimeOfDay.Dawn\n    )\n\n    night_after_midnight = DaytimeMap(\n        dawn=(time(hour=6), time(hour=9)),\n        day=(time(hour=9), time(hour=18)),\n        dusk=(time(hour=18), time(hour=20)),\n        night=(time(hour=2), time(hour=5)),\n    )\n\n    assert (\n        night_after_midnight.best_guess_time_of_day_at(time(hour=0)) == TimeOfDay.Dusk\n    )\n    assert (\n        night_after_midnight.best_guess_time_of_day_at(time(hour=23)) == TimeOfDay.Dusk\n    )\n    assert (\n        night_after_midnight.best_guess_time_of_day_at(time(hour=2)) == TimeOfDay.Night\n    )\n    assert (\n        night_after_midnight.best_guess_time_of_day_at(time(hour=6)) == TimeOfDay.Dawn\n    )\n\n\ndef test_whole_hours_only() -> None:\n    with pytest.raises(ValueError):\n        DaytimeMap(\n            dawn=(time(minute=6), time(hour=9)),\n            day=(time(hour=9), time(hour=18)),\n            dusk=(time(hour=18), time(hour=20)),\n            night=(time(hour=2), time(hour=5)),\n        )\n    with pytest.raises(ValueError):\n        DaytimeMap(\n            dawn=(time(hour=6), time(hour=9)),\n            day=(time(second=9), time(hour=18)),\n            dusk=(time(hour=18), time(hour=20)),\n            night=(time(hour=2), time(hour=5)),\n        )\n    with pytest.raises(ValueError):\n        DaytimeMap(\n            dawn=(time(hour=6), time(hour=9)),\n            day=(time(hour=9), time(hour=18)),\n            dusk=(time(hour=18), time(microsecond=20)),\n            night=(time(hour=2), time(hour=5)),\n        )\n"}
{"type": "test_file", "path": "tests/test_factions.py", "content": "import json\nimport unittest\nfrom pathlib import Path\n\nimport pytest\nfrom dcs.helicopters import AH_64A, UH_1H\nfrom dcs.planes import (\n    AV8BNA,\n    A_10A,\n    A_10C,\n    A_10C_2,\n    B_1B,\n    B_52H,\n    E_2C,\n    E_3A,\n    FA_18C_hornet,\n    F_117A,\n    F_14B,\n    F_15C,\n    F_15E,\n    F_16C_50,\n    KC130,\n    KC_135,\n    MQ_9_Reaper,\n)\nfrom dcs.ships import LHA_Tarawa, Stennis\nfrom dcs.vehicles import Armor, Artillery, Infantry, Unarmed\n\nfrom game.factions.faction import Faction\n\nTHIS_DIR = Path(__file__).parent\nRESOURCES_DIR = THIS_DIR / \"resources\"\n\n\nclass TestFactionLoader(unittest.TestCase):\n    def setUp(self) -> None:\n        pass\n\n    @pytest.mark.skip(reason=\"Faction unit names in the json files are outdated\")\n    def test_load_valid_faction(self) -> None:\n        with (RESOURCES_DIR / \"valid_faction.json\").open(\"r\") as data:\n            faction = Faction.from_dict(json.load(data))\n\n            self.assertEqual(faction.country, \"USA\")\n            self.assertEqual(faction.name, \"USA 2005\")\n            self.assertEqual(faction.authors, \"Khopa\")\n            self.assertEqual(faction.description, \"This is a test description\")\n\n            self.assertIn(F_15C, faction.aircrafts)\n            self.assertIn(F_15E, faction.aircrafts)\n            self.assertIn(F_14B, faction.aircrafts)\n            self.assertIn(FA_18C_hornet, faction.aircrafts)\n            self.assertIn(F_16C_50, faction.aircrafts)\n            self.assertIn(A_10A, faction.aircrafts)\n            self.assertIn(AV8BNA, faction.aircrafts)\n            self.assertIn(UH_1H, faction.aircrafts)\n            self.assertIn(AH_64A, faction.aircrafts)\n            self.assertIn(B_52H, faction.aircrafts)\n            self.assertIn(B_1B, faction.aircrafts)\n            self.assertIn(F_117A, faction.aircrafts)\n            self.assertIn(A_10C, faction.aircrafts)\n            self.assertIn(A_10C_2, faction.aircrafts)\n\n            self.assertEqual(len(faction.awacs), 1)\n            self.assertIn(E_3A, faction.awacs)\n            self.assertIn(E_2C, faction.awacs)\n\n            self.assertEqual(len(faction.tankers), 2)\n            self.assertIn(KC_135, faction.tankers)\n            self.assertIn(KC130, faction.tankers)\n\n            self.assertTrue(faction.has_jtac)\n            self.assertEqual(faction.jtac_unit, MQ_9_Reaper)\n\n            self.assertIn(Armor.M_1_Abrams, faction.frontline_units)\n            self.assertIn(Armor.M1134_Stryker_ATGM, faction.frontline_units)\n            self.assertIn(Armor.M1126_Stryker_ICV, faction.frontline_units)\n            self.assertIn(Armor.M_2_Bradley, faction.frontline_units)\n            self.assertIn(Armor.LAV_25, faction.frontline_units)\n            self.assertIn(Armor.M1043_HMMWV_Armament, faction.frontline_units)\n            self.assertIn(Armor.M1045_HMMWV_TOW, faction.frontline_units)\n\n            self.assertIn(Artillery.MLRS, faction.artillery_units)\n            self.assertIn(Artillery.M_109, faction.artillery_units)\n\n            self.assertIn(Unarmed.M_818, faction.logistics_units)\n\n            self.assertIn(Infantry.Soldier_M4, faction.infantry_units)\n            self.assertIn(Infantry.Soldier_M249, faction.infantry_units)\n\n            self.assertIn(Stennis.name, faction.naval_units)\n            self.assertIn(LHA_Tarawa.name, faction.naval_units)\n\n            self.assertIn(\"mod\", faction.requirements.keys())\n            self.assertIn(\"Some mod is required\", faction.requirements.values())\n\n            self.assertEqual(4, len(faction.carrier_names))\n            self.assertEqual(5, len(faction.helicopter_carrier_names))\n\n    @pytest.mark.skip(reason=\"Faction unit names in the json files are outdated\")\n    def test_load_valid_faction_with_invalid_country(self) -> None:\n        with (RESOURCES_DIR / \"invalid_faction_country.json\").open(\"r\") as data:\n            try:\n                Faction.from_dict(json.load(data))\n                self.fail(\"Should have thrown assertion error\")\n            except AssertionError as e:\n                pass\n"}
{"type": "test_file", "path": "tests/test_pilot.py", "content": "import pytest\nfrom faker import Faker\n\nfrom game.squadrons.pilot import Pilot, PilotStatus\n\n\n@pytest.fixture(scope=\"function\")\ndef pilot() -> Pilot:\n    return Pilot(\"John Doe\")\n\n\ndef test_pilot_creation() -> None:\n    new_pilot = Pilot(\"John Doe\")\n    assert new_pilot.name == \"John Doe\"\n    assert new_pilot.status == PilotStatus.Active\n\n\ndef test_pilot_active(pilot: Pilot) -> None:\n    assert pilot.status == PilotStatus.Active\n\n\ndef test_pilot_alive(pilot: Pilot) -> None:\n    assert pilot.alive == True\n\n\ndef test_pilot_on_leave(pilot: Pilot) -> None:\n    pilot.send_on_leave()\n    assert pilot.status == PilotStatus.OnLeave\n    assert pilot.on_leave == True\n    pilot.return_from_leave()\n    assert pilot.status == PilotStatus.Active\n    # mypy thinks this line is unreachable. It isn't.\n    assert pilot.on_leave == False  # type: ignore\n\n\ndef test_pilot_on_leave_twice(pilot: Pilot) -> None:\n    pilot.send_on_leave()\n    assert pilot.status == PilotStatus.OnLeave\n    with pytest.raises(RuntimeError):\n        pilot.send_on_leave()\n\n\ndef test_pilot_not_on_leave(pilot: Pilot) -> None:\n    with pytest.raises(RuntimeError):\n        pilot.return_from_leave()\n\n\ndef test_pilot_dead(pilot: Pilot) -> None:\n    pilot.kill()\n    assert pilot.status == PilotStatus.Dead\n\n\ndef test_pilot_record(pilot: Pilot) -> None:\n    pilot.record.missions_flown == 0\n\n\ndef test_missions_flown(pilot: Pilot) -> None:\n    pilot.record.missions_flown = 1\n    assert pilot.record.missions_flown == 1\n\n\ndef test_random_pilot_name() -> None:\n    faker = Faker()\n    random_pilot = Pilot.random(faker)\n    assert random_pilot.name\n"}
{"type": "test_file", "path": "tests/test_radios.py", "content": "from typing import Callable\n\nimport pytest\n\nfrom game.radio.radios import MHz, RadioFrequency, kHz\n\n\n@pytest.mark.parametrize(\"units,factory\", [(\"kHz\", kHz), (\"MHz\", MHz)])\ndef test_radio_parsing(units: str, factory: Callable[..., RadioFrequency]) -> None:\n    assert RadioFrequency.parse(f\"0 {units}\") == factory(0)\n    assert RadioFrequency.parse(f\"0.0 {units}\") == factory(0)\n    assert RadioFrequency.parse(f\"255 {units}\") == factory(255)\n    assert RadioFrequency.parse(f\"255.5 {units}\") == factory(255, 500)\n    assert RadioFrequency.parse(f\"255.500 {units}\") == factory(255, 500)\n    assert RadioFrequency.parse(f\"255.050 {units}\") == factory(255, 50)\n    assert RadioFrequency.parse(f\"255.005 {units}\") == factory(255, 5)\n    assert RadioFrequency.parse(f\"255.0 {units}\") == factory(255)\n\n    with pytest.raises(ValueError):\n        RadioFrequency.parse(\"\")\n    with pytest.raises(ValueError):\n        RadioFrequency.parse(\"255\")\n    with pytest.raises(ValueError):\n        RadioFrequency.parse(f\" 255 {units}\")\n    with pytest.raises(ValueError):\n        RadioFrequency.parse(f\"255 {units} \")\n    with pytest.raises(ValueError):\n        RadioFrequency.parse(f\"255 {units.lower()}\")\n    with pytest.raises(ValueError):\n        RadioFrequency.parse(f\"255. {units}\")\n    with pytest.raises(ValueError):\n        RadioFrequency.parse(f\".0 {units}\")\n    with pytest.raises(ValueError):\n        RadioFrequency.parse(f\"0. {units}\")\n    with pytest.raises(ValueError):\n        RadioFrequency.parse(f\"255.5555 {units}\")\n"}
{"type": "test_file", "path": "tests/test_sidc.py", "content": "from game.sidc import (\n    LandInstallationEntity,\n    StandardIdentity,\n    Status,\n    SymbolIdentificationCode,\n    SymbolSet,\n)\n\n\ndef test_sidc() -> None:\n    sidc = SymbolIdentificationCode(\n        standard_identity=StandardIdentity.FRIEND,\n        symbol_set=SymbolSet.LAND_INSTALLATIONS,\n        status=Status.PRESENT_DAMAGED,\n        entity=LandInstallationEntity.AIPORT_AIR_BASE,\n    )\n    assert str(sidc) == \"10032030001213010000\"\n"}
{"type": "test_file", "path": "tests/test_tacan.py", "content": "import pytest\n\nfrom game.radio.tacan import (\n    OutOfTacanChannelsError,\n    TacanBand,\n    TacanChannel,\n    TacanRegistry,\n    TacanUsage,\n)\n\nALL_VALID_X_TR = [1, *range(31, 46 + 1), *range(64, 126 + 1)]\nALL_VALID_X_A2A = [*range(37, 63 + 1), *range(100, 126 + 1)]\n\n\ndef test_allocate_first_few_channels() -> None:\n    registry = TacanRegistry()\n    chan1 = registry.alloc_for_band(TacanBand.X, TacanUsage.TransmitReceive)\n    chan2 = registry.alloc_for_band(TacanBand.X, TacanUsage.TransmitReceive)\n    chan3 = registry.alloc_for_band(TacanBand.X, TacanUsage.TransmitReceive)\n    assert chan1 == TacanChannel(1, TacanBand.X)\n    assert chan2 == TacanChannel(31, TacanBand.X)\n    assert chan3 == TacanChannel(32, TacanBand.X)\n\n\ndef test_allocate_different_usages() -> None:\n    \"\"\"Make sure unallocated channels for one use don't make channels unavailable for other usage\"\"\"\n    registry = TacanRegistry()\n\n    chanA2AX = registry.alloc_for_band(TacanBand.X, TacanUsage.AirToAir)\n    chanA2AY = registry.alloc_for_band(TacanBand.Y, TacanUsage.AirToAir)\n    assert chanA2AX == TacanChannel(37, TacanBand.X)\n    assert chanA2AY == TacanChannel(37, TacanBand.Y)\n\n    chanTRX = registry.alloc_for_band(TacanBand.X, TacanUsage.TransmitReceive)\n    chanTRY = registry.alloc_for_band(TacanBand.Y, TacanUsage.TransmitReceive)\n    assert chanTRX == TacanChannel(1, TacanBand.X)\n    assert chanTRY == TacanChannel(1, TacanBand.Y)\n\n\ndef test_reserve_all_valid_transmit_receive() -> None:\n    registry = TacanRegistry()\n    print(\"All valid x\", ALL_VALID_X_TR)\n\n    for num in ALL_VALID_X_TR:\n        registry.mark_unavailable(TacanChannel(num, TacanBand.X))\n\n    with pytest.raises(OutOfTacanChannelsError):\n        registry.alloc_for_band(TacanBand.X, TacanUsage.TransmitReceive)\n\n    # Check that we still can allocate an a2a channel even\n    # though the T/R channels are used up\n    chanA2A = registry.alloc_for_band(TacanBand.X, TacanUsage.AirToAir)\n    assert chanA2A == TacanChannel(47, TacanBand.X)\n\n\ndef test_reserve_all_valid_a2a() -> None:\n    registry = TacanRegistry()\n    print(\"All valid x\", ALL_VALID_X_A2A)\n\n    for num in ALL_VALID_X_A2A:\n        registry.mark_unavailable(TacanChannel(num, TacanBand.X))\n\n    with pytest.raises(OutOfTacanChannelsError):\n        registry.alloc_for_band(TacanBand.X, TacanUsage.AirToAir)\n\n    # Check that we still can allocate an a2a channel even\n    # though the T/R channels are used up\n    chanTR = registry.alloc_for_band(TacanBand.X, TacanUsage.TransmitReceive)\n    assert chanTR == TacanChannel(1, TacanBand.X)\n\n\ndef test_reserve_again() -> None:\n    registry = TacanRegistry()\n    registry.mark_unavailable(TacanChannel(1, TacanBand.X))\n    registry.mark_unavailable(TacanChannel(1, TacanBand.X))\n\n\ndef test_tacan_parsing() -> None:\n    assert TacanChannel.parse(\"1X\") == TacanChannel(1, TacanBand.X)\n    assert TacanChannel.parse(\"1Y\") == TacanChannel(1, TacanBand.Y)\n    assert TacanChannel.parse(\"10X\") == TacanChannel(10, TacanBand.X)\n    assert TacanChannel.parse(\"100X\") == TacanChannel(100, TacanBand.X)\n\n    with pytest.raises(ValueError):\n        TacanChannel.parse(\"1000X\")\n    with pytest.raises(ValueError):\n        TacanChannel.parse(\"0X\")\n    with pytest.raises(ValueError):\n        TacanChannel.parse(\"1Z\")\n    with pytest.raises(ValueError):\n        TacanChannel.parse(\"X\")\n    with pytest.raises(ValueError):\n        TacanChannel.parse(\"1\")\n    with pytest.raises(ValueError):\n        TacanChannel.parse(\"1 X\")\n    with pytest.raises(ValueError):\n        TacanChannel.parse(\" 1X\")\n    with pytest.raises(ValueError):\n        TacanChannel.parse(\"1X \")\n    with pytest.raises(ValueError):\n        TacanChannel.parse(\"1x\")\n"}
{"type": "test_file", "path": "tests/theater/test_controlpoint.py", "content": "import pytest\nfrom typing import Any\n\nfrom dcs.terrain.terrain import Airport\nfrom game.ato.flighttype import FlightType\nfrom game.theater.controlpoint import Airfield, Carrier, Lha, OffMapSpawn, Fob\n\n\ndef test_mission_types_friendly(mocker: Any) -> None:\n    \"\"\"\n    Test the mission types that can be planned against friendly control points\n    \"\"\"\n    # Airfield\n    mocker.patch(\"game.theater.controlpoint.Airfield.is_friendly\", return_value=True)\n    airport = Airport(None, None)  # type: ignore\n    airport.name = \"test\"  # required for Airfield.__init__\n    airfield = Airfield(airport, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(airfield.mission_types(for_player=True))\n    assert len(mission_types) == 3\n    assert FlightType.AEWC in mission_types\n    assert FlightType.REFUELING in mission_types\n    assert FlightType.BARCAP in mission_types\n\n    # Carrier\n    mocker.patch(\"game.theater.controlpoint.Carrier.is_friendly\", return_value=True)\n    carrier = Carrier(name=\"test\", at=None, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(carrier.mission_types(for_player=True))\n    assert len(mission_types) == 3\n    assert FlightType.AEWC in mission_types\n    assert FlightType.REFUELING in mission_types\n    assert FlightType.BARCAP in mission_types\n\n    # LHA\n    mocker.patch(\"game.theater.controlpoint.Lha.is_friendly\", return_value=True)\n    lha = Lha(name=\"test\", at=None, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(lha.mission_types(for_player=True))\n    assert len(mission_types) == 3\n    assert FlightType.AEWC in mission_types\n    assert FlightType.REFUELING in mission_types\n    assert FlightType.BARCAP in mission_types\n\n    # Fob\n    mocker.patch(\"game.theater.controlpoint.Fob.is_friendly\", return_value=True)\n    fob = Fob(name=\"test\", at=None, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(fob.mission_types(for_player=True))\n    assert len(mission_types) == 2\n    assert FlightType.AEWC in mission_types\n    assert FlightType.BARCAP in mission_types\n\n    # Off map spawn\n    mocker.patch(\"game.theater.controlpoint.OffMapSpawn.is_friendly\", return_value=True)\n    off_map_spawn = OffMapSpawn(name=\"test\", position=None, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(off_map_spawn.mission_types(for_player=True))\n    assert len(mission_types) == 0\n\n\ndef test_mission_types_enemy(mocker: Any) -> None:\n    \"\"\"\n    Test the mission types that can be planned against enemy control points\n    \"\"\"\n    # Airfield\n    mocker.patch(\"game.theater.controlpoint.Airfield.is_friendly\", return_value=False)\n    airport = Airport(None, None)  # type: ignore\n    airport.name = \"test\"  # required for Airfield.__init__\n    airfield = Airfield(airport, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(airfield.mission_types(for_player=True))\n    assert len(mission_types) == 8\n    assert FlightType.OCA_AIRCRAFT in mission_types\n    assert FlightType.OCA_RUNWAY in mission_types\n    assert FlightType.AIR_ASSAULT in mission_types\n    assert FlightType.ESCORT in mission_types\n    assert FlightType.TARCAP in mission_types\n    assert FlightType.SEAD_ESCORT in mission_types\n    assert FlightType.SWEEP in mission_types\n    assert FlightType.REFUELING in mission_types\n\n    # Carrier\n    mocker.patch(\"game.theater.controlpoint.Carrier.is_friendly\", return_value=False)\n    carrier = Carrier(name=\"test\", at=None, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(carrier.mission_types(for_player=True))\n    assert len(mission_types) == 5\n    assert FlightType.ANTISHIP in mission_types\n    assert FlightType.ESCORT in mission_types\n    assert FlightType.TARCAP in mission_types\n    assert FlightType.SEAD_ESCORT in mission_types\n    assert FlightType.SWEEP in mission_types\n\n    # LHA\n    mocker.patch(\"game.theater.controlpoint.Lha.is_friendly\", return_value=False)\n    lha = Lha(name=\"test\", at=None, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(lha.mission_types(for_player=True))\n    assert len(mission_types) == 5\n    assert FlightType.ANTISHIP in mission_types\n    assert FlightType.ESCORT in mission_types\n    assert FlightType.TARCAP in mission_types\n    assert FlightType.SEAD_ESCORT in mission_types\n    assert FlightType.SWEEP in mission_types\n\n    # Fob\n    mocker.patch(\"game.theater.controlpoint.Fob.is_friendly\", return_value=False)\n    fob = Fob(name=\"test\", at=None, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(fob.mission_types(for_player=True))\n    assert len(mission_types) == 6\n    assert FlightType.AIR_ASSAULT in mission_types\n    assert FlightType.ESCORT in mission_types\n    assert FlightType.TARCAP in mission_types\n    assert FlightType.SEAD_ESCORT in mission_types\n    assert FlightType.SWEEP in mission_types\n    assert FlightType.STRIKE in mission_types\n\n    # Off map spawn\n    mocker.patch(\n        \"game.theater.controlpoint.OffMapSpawn.is_friendly\", return_value=False\n    )\n    off_map_spawn = OffMapSpawn(name=\"test\", position=None, theater=None, starts_blue=True)  # type: ignore\n    mission_types = list(off_map_spawn.mission_types(for_player=True))\n    assert len(mission_types) == 0\n"}
{"type": "test_file", "path": "tests/test_zipfileext.py", "content": "from pathlib import Path\nfrom zipfile import ZipFile\n\nimport pytest\n\nfrom game.zipfileext import ZipFileExt\n\n\ndef test_remove_member_does_nothing_if_member_is_not_present(tmp_zip: Path) -> None:\n    expect_mtime = tmp_zip.stat().st_mtime\n    ZipFileExt.remove_member(tmp_zip, \"c\", missing_ok=True)\n    assert tmp_zip.stat().st_mtime == expect_mtime\n\n\ndef test_remove_member_raises_if_missing_not_ok(tmp_zip: Path) -> None:\n    with pytest.raises(ValueError):\n        ZipFileExt.remove_member(tmp_zip, \"c\")\n\n\ndef test_remove_member(tmp_zip: Path) -> None:\n    with ZipFile(tmp_zip, \"w\") as zip_file:\n        zip_file.writestr(\"a\", \"foo\")\n        zip_file.writestr(\"b\", \"bar\")\n\n    ZipFileExt.remove_member(tmp_zip, \"a\")\n\n    with ZipFile(tmp_zip, \"r\") as zip_file:\n        with pytest.raises(KeyError):\n            zip_file.read(\"a\")\n        # Yes, we wrote a str, but ZipFile.read always returns bytes, and ZipFile.write\n        # requires an intermediate file. It's hard to write bytes, and hard to read str.\n        # This is all the single-byte range of UTF-8 anyway, so it doesn't matter.\n        assert zip_file.read(\"b\") == b\"bar\"\n"}
{"type": "test_file", "path": "tests/theater/test_landmap.py", "content": "import os\nimport pytest\n\nfrom shapely.geometry import MultiPolygon, Polygon\n\nfrom dcs.terrain.caucasus.caucasus import Caucasus\nfrom game.theater import landmap\n\n\ndef test_miz() -> None:\n    \"\"\"\n    Test miz generation and loading\n    \"\"\"\n    test_map = landmap.Landmap(\n        inclusion_zones=MultiPolygon([Polygon([(0, 0), (0, 1), (1, 0)])]),\n        exclusion_zones=MultiPolygon([Polygon([(1, 1), (0, 1), (1, 0)])]),\n        sea_zones=MultiPolygon([Polygon([(0, 0), (0, 2), (1, 0)])]),\n    )\n    test_filename = \"test.miz\"\n    landmap.to_miz(test_map, Caucasus(), test_filename)\n    assert os.path.isfile(\"test.miz\")\n    loaded_map = landmap.from_miz(\"test.miz\")\n    assert test_map.inclusion_zones.equals_exact(\n        loaded_map.inclusion_zones, tolerance=1e-6\n    )\n    assert test_map.sea_zones.equals_exact(loaded_map.sea_zones, tolerance=1e-6)\n    assert test_map.exclusion_zones.equals_exact(\n        loaded_map.exclusion_zones, tolerance=1e-6\n    )\n\n    if os.path.isfile(test_filename):\n        os.remove(test_filename)\n"}
{"type": "test_file", "path": "tests/theater/test_theatergroundobject.py", "content": "import pytest\nfrom typing import Any\n\nfrom dcs.mapping import Point\nfrom dcs.terrain import Terrain\nfrom game.ato.flighttype import FlightType\nfrom game.theater.presetlocation import PresetLocation\nfrom game.theater.theatergroundobject import (\n    BuildingGroundObject,\n    CarrierGroundObject,\n    LhaGroundObject,\n    MissileSiteGroundObject,\n    CoastalSiteGroundObject,\n    SamGroundObject,\n    VehicleGroupGroundObject,\n    EwrGroundObject,\n    ShipGroundObject,\n    IadsBuildingGroundObject,\n)\nfrom game.theater.controlpoint import OffMapSpawn\nfrom game.utils import Heading\n\n\ndef test_mission_types_friendly(mocker: Any) -> None:\n    \"\"\"\n    Test the mission types that can be planned against friendly Theater Ground Objects\n    \"\"\"\n    # Set up dummy inputs\n    dummy_location = PresetLocation(\n        name=\"dummy_location\", position=Point(0, 0, None), heading=Heading(0)  # type: ignore\n    )\n    dummy_control_point = OffMapSpawn(\n        name=\"dummy_control_point\",\n        position=Point(0, 0, None),  # type: ignore\n        theater=None,  # type: ignore\n        starts_blue=True,\n    )\n\n    # Patch is_friendly as it's difficult to set up a proper ControlPoint\n    mocker.patch(\"game.theater.controlpoint.OffMapSpawn.is_friendly\", return_value=True)\n\n    for ground_object_type in [\n        CarrierGroundObject,\n        LhaGroundObject,\n        MissileSiteGroundObject,\n        CoastalSiteGroundObject,\n        SamGroundObject,\n        VehicleGroupGroundObject,\n        EwrGroundObject,\n        ShipGroundObject,\n    ]:\n        ground_object = ground_object_type(  # type: ignore\n            name=\"test\",\n            location=dummy_location,\n            control_point=dummy_control_point,\n        )\n        mission_types = list(ground_object.mission_types(for_player=True))\n        assert mission_types == [FlightType.BARCAP]\n\n    for ground_object_type in [BuildingGroundObject, IadsBuildingGroundObject]:  # type: ignore\n        ground_object = ground_object_type(  # type: ignore\n            name=\"test\",\n            category=\"ammo\",\n            location=dummy_location,\n            control_point=dummy_control_point,\n        )\n        mission_types = list(ground_object.mission_types(for_player=True))\n        assert mission_types == [FlightType.BARCAP]\n\n\ndef test_mission_types_enemy(mocker: Any) -> None:\n    \"\"\"\n    Test the mission types that can be planned against enemy Theater Ground Objects\n    \"\"\"\n    # Set up dummy inputs\n    dummy_location = PresetLocation(\n        name=\"dummy_location\", position=Point(0, 0, None), heading=Heading(0)  # type: ignore\n    )\n    dummy_control_point = OffMapSpawn(\n        name=\"dummy_control_point\",\n        position=Point(0, 0, None),  # type: ignore\n        theater=None,  # type: ignore\n        starts_blue=True,\n    )\n\n    # Patch is_friendly as it's difficult to set up a proper ControlPoint\n    mocker.patch(\n        \"game.theater.controlpoint.OffMapSpawn.is_friendly\", return_value=False\n    )\n\n    building = BuildingGroundObject(\n        name=\"test\",\n        category=\"ammo\",\n        location=dummy_location,\n        control_point=dummy_control_point,\n    )\n    mission_types = list(building.mission_types(for_player=False))\n    assert len(mission_types) == 6\n    assert FlightType.STRIKE in mission_types\n    assert FlightType.REFUELING in mission_types\n    assert FlightType.ESCORT in mission_types\n    assert FlightType.TARCAP in mission_types\n    assert FlightType.SEAD_ESCORT in mission_types\n    assert FlightType.SWEEP in mission_types\n\n    iads_building = IadsBuildingGroundObject(\n        name=\"test\",\n        category=\"ammo\",\n        location=dummy_location,\n        control_point=dummy_control_point,\n    )\n    mission_types = list(iads_building.mission_types(for_player=False))\n    assert len(mission_types) == 7\n    assert FlightType.STRIKE in mission_types\n    assert FlightType.REFUELING in mission_types\n    assert FlightType.ESCORT in mission_types\n    assert FlightType.TARCAP in mission_types\n    assert FlightType.SEAD_ESCORT in mission_types\n    assert FlightType.SWEEP in mission_types\n    assert FlightType.DEAD in mission_types\n\n    for ground_object_type in [\n        CarrierGroundObject,\n        LhaGroundObject,\n        ShipGroundObject,\n    ]:\n        ground_object = ground_object_type(  # type: ignore\n            name=\"test\",\n            location=dummy_location,\n            control_point=dummy_control_point,\n        )\n        mission_types = list(ground_object.mission_types(for_player=False))\n        assert len(mission_types) == 7\n        assert FlightType.ANTISHIP in mission_types\n        assert FlightType.STRIKE in mission_types\n        assert FlightType.REFUELING in mission_types\n        assert FlightType.ESCORT in mission_types\n        assert FlightType.TARCAP in mission_types\n        assert FlightType.SEAD_ESCORT in mission_types\n        assert FlightType.SWEEP in mission_types\n\n    sam = SamGroundObject(\n        name=\"test\",\n        location=dummy_location,\n        control_point=dummy_control_point,\n    )\n    mission_types = list(sam.mission_types(for_player=False))\n    assert len(mission_types) == 8\n    assert FlightType.DEAD in mission_types\n    assert FlightType.SEAD in mission_types\n    assert FlightType.STRIKE in mission_types\n    assert FlightType.REFUELING in mission_types\n    assert FlightType.ESCORT in mission_types\n    assert FlightType.TARCAP in mission_types\n    assert FlightType.SEAD_ESCORT in mission_types\n    assert FlightType.SWEEP in mission_types\n\n    ewr = EwrGroundObject(\n        name=\"test\",\n        location=dummy_location,\n        control_point=dummy_control_point,\n    )\n    mission_types = list(ewr.mission_types(for_player=False))\n    assert len(mission_types) == 7\n    assert FlightType.DEAD in mission_types\n    assert FlightType.STRIKE in mission_types\n    assert FlightType.REFUELING in mission_types\n    assert FlightType.ESCORT in mission_types\n    assert FlightType.TARCAP in mission_types\n    assert FlightType.SEAD_ESCORT in mission_types\n    assert FlightType.SWEEP in mission_types\n\n    for ground_object_type in [  # type: ignore\n        CoastalSiteGroundObject,\n        MissileSiteGroundObject,\n    ]:\n        ground_object = ground_object_type(  # type: ignore\n            name=\"test\",\n            location=dummy_location,\n            control_point=dummy_control_point,\n        )\n        mission_types = list(ground_object.mission_types(for_player=False))\n        assert len(mission_types) == 7\n        assert FlightType.BAI in mission_types\n        assert FlightType.STRIKE in mission_types\n        assert FlightType.REFUELING in mission_types\n        assert FlightType.ESCORT in mission_types\n        assert FlightType.TARCAP in mission_types\n        assert FlightType.SEAD_ESCORT in mission_types\n        assert FlightType.SWEEP in mission_types\n\n    vehicles = VehicleGroupGroundObject(\n        name=\"test\",\n        location=dummy_location,\n        control_point=dummy_control_point,\n    )\n    mission_types = list(vehicles.mission_types(for_player=False))\n    assert len(mission_types) == 7\n    assert FlightType.BAI in mission_types\n    assert FlightType.STRIKE in mission_types\n    assert FlightType.REFUELING in mission_types\n    assert FlightType.ESCORT in mission_types\n    assert FlightType.TARCAP in mission_types\n    assert FlightType.SEAD_ESCORT in mission_types\n    assert FlightType.SWEEP in mission_types\n"}
{"type": "source_file", "path": "docs/conf.py", "content": "# Configuration file for the Sphinx documentation builder.\n#\n# For the full list of built-in configuration values, see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Project information -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\nproject = \"DCS Liberation\"\ncopyright = \"2025, DCS Liberation Team\"\nauthor = \"DCS Liberation Team\"\nrelease = \"14.0.0\"\n\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\nextensions = [\n    \"myst_parser\",\n    \"sphinx_rtd_theme\",\n    \"sphinx.ext.autosectionlabel\",\n    \"sphinx.ext.todo\",\n]\n\ntemplates_path = [\"_templates\"]\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\n\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\nhtml_theme = \"sphinx_rtd_theme\"\nhtml_static_path = [\"_static\"]\n\ntodo_include_todos = True\n"}
{"type": "source_file", "path": "game/__init__.py", "content": "from .game import Game\nfrom .version import VERSION\n"}
{"type": "source_file", "path": "game/aircraftparkinglocation.py", "content": ""}
{"type": "source_file", "path": "game/armedforces/forcegroup.py", "content": "from __future__ import annotations\n\nimport logging\nimport random\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any, ClassVar, Iterator, Optional, TYPE_CHECKING, Type\n\nimport yaml\nfrom dcs.unittype import ShipType, StaticType, UnitType as DcsUnitType, VehicleType\n\nfrom game.data.groups import GroupTask\nfrom game.dcs.groundunittype import GroundUnitType\nfrom game.dcs.helpers import static_type_from_name\nfrom game.dcs.shipunittype import ShipUnitType\nfrom game.dcs.unittype import UnitType\nfrom game.layout import LAYOUTS\nfrom game.layout.layout import TgoLayout, TgoLayoutUnitGroup\nfrom game.point_with_heading import PointWithHeading\nfrom game.theater.theatergroundobject import (\n    IadsGroundObject,\n    IadsBuildingGroundObject,\n    NavalGroundObject,\n)\nfrom game.theater.theatergroup import IadsGroundGroup, IadsRole, TheaterGroup\nfrom game.utils import escape_string_for_lua\n\nif TYPE_CHECKING:\n    from game import Game\n    from game.factions.faction import Faction\n    from game.theater import TheaterGroundObject, ControlPoint, PresetLocation\n\n\n@dataclass\nclass ForceGroup:\n    \"\"\"A logical group of multiple units and layouts which have a specific tasking.\n\n    ForceGroups will be generated during game and coalition initialization based on\n    generic layouts and preset forcegroups.\n\n    Every ForceGroup must have at least one unit, one task and one layout.\n\n    A preset ForceGroup can for example be a S-300 SAM Battery which used many\n    different unit types which all together handle a specific tasking (AirDefense)\n    For this example the ForceGroup would consist of SR, TR, LN and so on next to\n    statics. This group also has the Tasking LORAD and can have multiple (at least one)\n    layouts which will be used to generate the actual DCS Group from it.\n    \"\"\"\n\n    name: str\n    units: list[UnitType[Any]]\n    statics: list[Type[DcsUnitType]]\n    tasks: list[GroupTask] = field(default_factory=list)\n    layouts: list[TgoLayout] = field(default_factory=list)\n\n    _by_name: ClassVar[dict[str, ForceGroup]] = {}\n    _loaded: bool = False\n\n    @staticmethod\n    def for_layout(layout: TgoLayout, faction: Faction) -> ForceGroup:\n        \"\"\"Create a ForceGroup from the given TgoLayout which is usable by the faction\n\n        This will iterate through all possible TgoLayoutGroups and check if the\n        unit_types are accessible by the faction. All accessible units will be added to\n        the force group\n        \"\"\"\n        units: set[UnitType[Any]] = set()\n        statics: set[Type[DcsUnitType]] = set()\n        for unit_group in layout.all_unit_groups:\n            if unit_group.optional and not unit_group.fill:\n                continue\n            for unit_type in unit_group.possible_types_for_faction(faction):\n                if issubclass(unit_type, VehicleType):\n                    units.add(next(GroundUnitType.for_dcs_type(unit_type)))\n                elif issubclass(unit_type, ShipType):\n                    units.add(next(ShipUnitType.for_dcs_type(unit_type)))\n                elif issubclass(unit_type, StaticType):\n                    statics.add(unit_type)\n\n        return ForceGroup(\n            \", \".join([t.description for t in layout.tasks]),\n            list(units),\n            list(statics),\n            layout.tasks,\n            [layout],\n        )\n\n    def __str__(self) -> str:\n        return self.name\n\n    def has_unit_for_layout_group(self, unit_group: TgoLayoutUnitGroup) -> bool:\n        for unit in self.units:\n            if (\n                unit.dcs_unit_type in unit_group.unit_types\n                or unit.unit_class in unit_group.unit_classes\n            ):\n                return True\n        return False\n\n    def initialize_for_faction(self, faction: Faction) -> ForceGroup:\n        \"\"\"Initialize a ForceGroup for the given Faction.\n        This adds accessible units to LayoutGroups with the fill property\"\"\"\n        for layout in self.layouts:\n            for unit_group in layout.all_unit_groups:\n                if unit_group.fill and not self.has_unit_for_layout_group(unit_group):\n                    for unit_type in unit_group.possible_types_for_faction(faction):\n                        if issubclass(unit_type, VehicleType):\n                            self.units.append(\n                                next(GroundUnitType.for_dcs_type(unit_type))\n                            )\n                        elif issubclass(unit_type, ShipType):\n                            self.units.append(\n                                next(ShipUnitType.for_dcs_type(unit_type))\n                            )\n                        elif issubclass(unit_type, StaticType):\n                            self.statics.append(unit_type)\n        return self\n\n    @classmethod\n    def from_preset_group(cls, name: str) -> ForceGroup:\n        if not cls._loaded:\n            cls._load_all()\n        preset_group = cls._by_name[name]\n        # Return a copy of the PresetGroup as new ForceGroup\n        return ForceGroup(\n            name=str(preset_group.name),\n            units=list(preset_group.units),\n            statics=list(preset_group.statics),\n            tasks=list(preset_group.tasks),\n            layouts=list(preset_group.layouts),\n        )\n\n    def has_access_to_dcs_type(self, type: Type[DcsUnitType]) -> bool:\n        return (\n            any(unit.dcs_unit_type == type for unit in self.units)\n            or type in self.statics\n        )\n\n    def dcs_unit_types_for_group(\n        self, unit_group: TgoLayoutUnitGroup\n    ) -> list[Type[DcsUnitType]]:\n        \"\"\"Return all available DCS Unit Types which can be used in the given\n        TgoLayoutGroup\"\"\"\n        unit_types = [\n            t for t in unit_group.unit_types if self.has_access_to_dcs_type(t)\n        ]\n\n        alternative_types = []\n        for accessible_unit in self.units:\n            if accessible_unit.unit_class in unit_group.unit_classes:\n                unit_types.append(accessible_unit.dcs_unit_type)\n            if accessible_unit.unit_class in unit_group.fallback_classes:\n                alternative_types.append(accessible_unit.dcs_unit_type)\n\n        return unit_types or alternative_types\n\n    def unit_types_for_group(\n        self, unit_group: TgoLayoutUnitGroup\n    ) -> Iterator[UnitType[Any]]:\n        for dcs_type in self.dcs_unit_types_for_group(unit_group):\n            if issubclass(dcs_type, VehicleType):\n                yield next(GroundUnitType.for_dcs_type(dcs_type))\n            elif issubclass(dcs_type, ShipType):\n                yield next(ShipUnitType.for_dcs_type(dcs_type))\n\n    def statics_for_group(\n        self, unit_group: TgoLayoutUnitGroup\n    ) -> Iterator[Type[DcsUnitType]]:\n        for dcs_type in self.dcs_unit_types_for_group(unit_group):\n            if issubclass(dcs_type, StaticType):\n                yield dcs_type\n\n    def random_dcs_unit_type_for_group(\n        self, unit_group: TgoLayoutUnitGroup\n    ) -> Type[DcsUnitType]:\n        \"\"\"Return random DCS Unit Type which can be used in the given TgoLayoutGroup\"\"\"\n        return random.choice(self.dcs_unit_types_for_group(unit_group))\n\n    def merge_group(self, new_group: ForceGroup) -> None:\n        \"\"\"Merge the group with another similar group.\"\"\"\n        # Unified name for the resulting group\n        self.name = \", \".join([t.description for t in self.tasks])\n        # merge units, statics and layouts\n        self.units = list(set(self.units + new_group.units))\n        self.statics = list(set(self.statics + new_group.statics))\n        self.layouts = list(set(self.layouts + new_group.layouts))\n\n    def generate(\n        self,\n        name: str,\n        location: PresetLocation,\n        control_point: ControlPoint,\n        game: Game,\n    ) -> TheaterGroundObject:\n        \"\"\"Create a random TheaterGroundObject from the available templates\"\"\"\n        layout = random.choice(self.layouts)\n        return self.create_ground_object_for_layout(\n            layout, name, location, control_point, game\n        )\n\n    def create_ground_object_for_layout(\n        self,\n        layout: TgoLayout,\n        name: str,\n        location: PresetLocation,\n        control_point: ControlPoint,\n        game: Game,\n    ) -> TheaterGroundObject:\n        \"\"\"Create a TheaterGroundObject for the given template\"\"\"\n        go = layout.create_ground_object(name, location, control_point)\n        # Generate all groups using the randomization if it defined\n        for tgo_group in layout.groups:\n            for unit_group in tgo_group.unit_groups:\n                # Choose a random unit_type for the group\n                try:\n                    unit_type = self.random_dcs_unit_type_for_group(unit_group)\n                except IndexError:\n                    if unit_group.optional:\n                        # If group is optional it is ok when no unit_type is available\n                        continue\n                    # if non-optional this is a error\n                    raise RuntimeError(\n                        f\"No accessible unit for {self.name} - {unit_group.name}\"\n                    )\n                tgo_group_name = f\"{name} ({tgo_group.group_name})\"\n                self.create_theater_group_for_tgo(\n                    go, unit_group, tgo_group_name, game, unit_type\n                )\n\n        return go\n\n    def create_theater_group_for_tgo(\n        self,\n        ground_object: TheaterGroundObject,\n        unit_group: TgoLayoutUnitGroup,\n        group_name: str,\n        game: Game,\n        unit_type: Type[DcsUnitType],\n        unit_count: Optional[int] = None,\n    ) -> None:\n        \"\"\"Create a TheaterGroup and add it to the given TGO\"\"\"\n        # Random UnitCounter if not forced\n        if unit_count is None:\n            # Choose a random group_size based on the layouts unit_count\n            unit_count = unit_group.group_size\n        if unit_count == 0:\n            # No units to be created so dont create a theater group for them\n            return\n        # Generate Units\n        units = unit_group.generate_units(ground_object, unit_type, unit_count)\n        # Get or create the TheaterGroup\n        ground_group = ground_object.group_by_name(group_name)\n        if ground_group is not None:\n            # TheaterGroup with this name exists already. Extend it\n            ground_group.units.extend(units)\n        else:\n            # TheaterGroup with the name was not created yet\n            ground_group = TheaterGroup.from_template(\n                game.next_group_id(), group_name, units, ground_object\n            )\n            # Special handling when part of the IADS (SAM, EWR, IADS Building, Navy)\n            if (\n                isinstance(ground_object, IadsGroundObject)\n                or isinstance(ground_object, IadsBuildingGroundObject)\n                or isinstance(ground_object, NavalGroundObject)\n            ):\n                # Recreate the TheaterGroup as IadsGroundGroup\n                ground_group = IadsGroundGroup.from_group(ground_group)\n                if unit_group.sub_task is not None:\n                    # Use the special sub_task of the TheaterGroup\n                    iads_task = unit_group.sub_task\n                else:\n                    # Use the primary task of the ForceGroup\n                    iads_task = self.tasks[0]\n                # Set the iads_role according the the task for the group\n                ground_group.iads_role = IadsRole.for_task(iads_task)\n\n            ground_object.groups.append(ground_group)\n\n        # A layout has to be created with an orientation of 0 deg.\n        # Therefore the the clockwise rotation angle is always the heading of the\n        # groundobject without any calculation needed\n        rotation = ground_object.heading\n\n        # Assign UniqueID, name and align relative to ground_object\n        for unit in units:\n            unit.id = game.next_unit_id()\n            # Add unit name escaped so that we do not have scripting issues later\n            unit.name = escape_string_for_lua(\n                unit.unit_type.variant_id if unit.unit_type else unit.type.name\n            )\n            unit.position = PointWithHeading.from_point(\n                ground_object.position + unit.position,\n                # Align heading to GroundObject defined by the campaign designer\n                unit.position.heading + rotation,\n            )\n            if (\n                unit.unit_type is not None\n                and isinstance(unit.unit_type, GroundUnitType)\n                and unit.unit_type.reversed_heading\n            ):\n                # Reverse the heading of the unit\n                unit.position.heading = unit.position.heading.opposite\n            # Rotate unit around the center to align the orientation of the group\n            unit.position.rotate(ground_object.position, rotation)\n\n    @classmethod\n    def _load_all(cls) -> None:\n        for file in Path(\"resources/groups\").glob(\"*.yaml\"):\n            if not file.is_file():\n                raise RuntimeError(f\"{file.name} is not a valid ForceGroup\")\n\n            with file.open(encoding=\"utf-8\") as data_file:\n                data = yaml.safe_load(data_file)\n\n            name = data[\"name\"]\n\n            group_tasks = [GroupTask.by_description(n) for n in data.get(\"tasks\")]\n            if not group_tasks:\n                logging.error(f\"ForceGroup {name} has no valid tasking\")\n                continue\n\n            units: list[UnitType[Any]] = []\n            for unit in data.get(\"units\"):\n                if GroundUnitType.exists(unit):\n                    units.append(GroundUnitType.named(unit))\n                elif ShipUnitType.exists(unit):\n                    units.append(ShipUnitType.named(unit))\n                else:\n                    logging.error(f\"Unit {unit} of ForceGroup {name} is invalid\")\n            if len(units) == 0:\n                logging.error(f\"ForceGroup {name} has no valid units\")\n                continue\n\n            statics = []\n            for static in data.get(\"statics\", []):\n                static_type = static_type_from_name(static)\n                if static_type is None:\n                    logging.error(f\"Static {static} for {file} is not valid\")\n                else:\n                    statics.append(static_type)\n\n            layouts = [LAYOUTS.by_name(n) for n in data.get(\"layouts\")]\n            if not layouts:\n                logging.error(f\"ForceGroup {name} has no valid layouts\")\n                continue\n\n            force_group = ForceGroup(\n                name=name,\n                units=units,\n                statics=statics,\n                tasks=group_tasks,\n                layouts=layouts,\n            )\n\n            cls._by_name[force_group.name] = force_group\n\n        cls._loaded = True\n"}
{"type": "source_file", "path": "game/armedforces/armedforces.py", "content": "from __future__ import annotations\n\nimport random\nfrom typing import TYPE_CHECKING, Iterator, Optional\nfrom game.data.groups import GroupTask\nfrom game.armedforces.forcegroup import ForceGroup\nfrom game.layout import LAYOUTS\nfrom game.profiling import logged_duration\n\nif TYPE_CHECKING:\n    from game.factions.faction import Faction\n\n\nclass ArmedForces:\n    \"\"\"Represents all ForceGroups which are available to the faction\"\"\"\n\n    def __init__(self, faction: Faction):\n        self.forces: list[ForceGroup] = []\n        with logged_duration(f\"Loading armed forces for {faction.name}\"):\n            self._load_forces(faction)\n\n    def add_or_update_force_group(self, new_group: ForceGroup) -> None:\n        \"\"\"Adds or update a forcegroup depending if a forcegroup with the exact same\n        tasking already exists\"\"\"\n        # Check if a force group with the same tasking already exists\n        for force_group in self.forces:\n            if force_group.tasks == new_group.tasks:\n                # Update existing group if tasks are equal\n                force_group.merge_group(new_group)\n                return\n        # Add a new force group\n        self.forces.append(new_group)\n\n    def _load_forces(self, faction: Faction) -> None:\n        \"\"\"Initialize the ArmedForces for the given faction.\n        This will create a ForceGroup for each generic Layout and PresetGroup\"\"\"\n\n        # Generate ForceGroup for all generic layouts by iterating over\n        # all layouts which are usable by the given faction.\n        for layout in LAYOUTS.layouts:\n            if layout.generic and layout.usable_by_faction(faction):\n                # Creates a faction compatible GorceGroup\n                self.add_or_update_force_group(ForceGroup.for_layout(layout, faction))\n\n        # Add all preset groups afterwards to prevent them being merged with generics\n        for preset_group in faction.preset_groups:\n            self.forces.append(preset_group.initialize_for_faction(faction))\n\n    def groups_for_task(self, group_task: GroupTask) -> Iterator[ForceGroup]:\n        for force_group in self.forces:\n            if group_task in force_group.tasks:\n                yield force_group\n\n    def groups_for_tasks(self, tasks: list[GroupTask]) -> list[ForceGroup]:\n        groups = []\n        for task in tasks:\n            for group in self.groups_for_task(task):\n                if group not in groups:\n                    groups.append(group)\n        return sorted(groups, key=lambda g: g.name)\n\n    def random_group_for_task(self, group_task: GroupTask) -> Optional[ForceGroup]:\n        unit_groups = list(self.groups_for_task(group_task))\n        return random.choice(unit_groups) if unit_groups else None\n"}
{"type": "source_file", "path": "game/atcdata.py", "content": "from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom dcs.task import Modulation\nfrom dcs.terrain import Airport\n\nfrom game.radio.radios import RadioFrequency\n\n\n@dataclass\nclass AtcData:\n    hf: RadioFrequency\n    vhf_fm: RadioFrequency\n    vhf_am: RadioFrequency\n    uhf: RadioFrequency\n\n    @classmethod\n    def from_pydcs(cls, airport: Airport) -> Optional[AtcData]:\n        if airport.atc_radio is None:\n            return None\n        return AtcData(\n            RadioFrequency(airport.atc_radio.hf_hz, Modulation.FM),\n            RadioFrequency(airport.atc_radio.vhf_low_hz, Modulation.FM),\n            RadioFrequency(airport.atc_radio.vhf_high_hz, Modulation.AM),\n            RadioFrequency(airport.atc_radio.uhf_hz, Modulation.AM),\n        )\n"}
{"type": "source_file", "path": "game/ato/airtaaskingorder.py", "content": "from dataclasses import dataclass, field\nfrom typing import List\n\nfrom game.ato.package import Package\n\n\n@dataclass\nclass AirTaskingOrder:\n    \"\"\"The entire ATO for one coalition.\"\"\"\n\n    #: The set of all planned packages in the ATO.\n    packages: List[Package] = field(default_factory=list)\n\n    def add_package(self, package: Package) -> None:\n        \"\"\"Adds a package to the ATO.\"\"\"\n        self.packages.append(package)\n\n    def remove_package(self, package: Package) -> None:\n        \"\"\"Removes a package from the ATO.\"\"\"\n        # Remove all the flights individually so the database gets updated.\n        for flight in list(package.flights):\n            package.remove_flight(flight)\n        self.packages.remove(package)\n\n    def clear(self) -> None:\n        \"\"\"Removes all packages from the ATO.\"\"\"\n        # Remove all packages individually so the database gets updated.\n        for package in list(self.packages):\n            self.remove_package(package)\n"}
{"type": "source_file", "path": "game/ato/__init__.py", "content": "from .flight import Flight\nfrom .flighttype import FlightType\nfrom .flightwaypoint import FlightWaypoint\nfrom .package import Package\n"}
{"type": "source_file", "path": "game/ato/closestairfields.py", "content": "\"\"\"Objective adjacency lists.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Dict, Iterator, List, Optional, TYPE_CHECKING\n\nfrom game.utils import Distance\n\nif TYPE_CHECKING:\n    from game.theater import ConflictTheater, ControlPoint, MissionTarget\n\n\nclass ClosestAirfields:\n    \"\"\"Precalculates which control points are closes to the given target.\"\"\"\n\n    def __init__(\n        self, target: MissionTarget, all_control_points: List[ControlPoint]\n    ) -> None:\n        self.target = target\n        # This cache is configured once on load, so it's important that it is\n        # complete and deterministic to avoid different behaviors across loads.\n        # E.g. https://github.com/dcs-liberation/dcs_liberation/issues/819\n        self.closest_airfields: List[ControlPoint] = sorted(\n            all_control_points, key=lambda c: self.target.distance_to(c)\n        )\n\n    @property\n    def operational_airfields(self) -> Iterator[ControlPoint]:\n        return (c for c in self.closest_airfields if c.runway_is_operational())\n\n    def _airfields_within(\n        self, distance: Distance, operational: bool\n    ) -> Iterator[ControlPoint]:\n        airfields = (\n            self.operational_airfields if operational else self.closest_airfields\n        )\n        for cp in airfields:\n            if cp.distance_to(self.target) < distance.meters:\n                yield cp\n            else:\n                break\n\n    def operational_airfields_within(\n        self, distance: Distance\n    ) -> Iterator[ControlPoint]:\n        \"\"\"Iterates over all airfields within the given range of the target.\n\n        Note that this iterates over *all* airfields, not just friendly\n        airfields.\n        \"\"\"\n        return self._airfields_within(distance, operational=True)\n\n    def all_airfields_within(self, distance: Distance) -> Iterator[ControlPoint]:\n        \"\"\"Iterates over all airfields within the given range of the target.\n\n        Note that this iterates over *all* airfields, not just friendly\n        airfields.\n        \"\"\"\n        return self._airfields_within(distance, operational=False)\n\n\nclass ObjectiveDistanceCache:\n    theater: Optional[ConflictTheater] = None\n    closest_airfields: Dict[str, ClosestAirfields] = {}\n\n    @classmethod\n    def set_theater(cls, theater: ConflictTheater) -> None:\n        if cls.theater is not None:\n            cls.closest_airfields = {}\n        cls.theater = theater\n\n    @classmethod\n    def get_closest_airfields(cls, location: MissionTarget) -> ClosestAirfields:\n        if cls.theater is None:\n            raise RuntimeError(\"Call ObjectiveDistanceCache.set_theater before using\")\n\n        if location.name not in cls.closest_airfields:\n            cls.closest_airfields[location.name] = ClosestAirfields(\n                location, cls.theater.controlpoints\n            )\n        return cls.closest_airfields[location.name]\n"}
{"type": "source_file", "path": "game/ato/flight.py", "content": "from __future__ import annotations\n\nimport uuid\nfrom collections.abc import Iterator\nfrom datetime import datetime, timedelta\nfrom typing import Any, List, Optional, TYPE_CHECKING\n\nfrom dcs import Point\nfrom dcs.planes import C_101CC, C_101EB, Su_33\n\nfrom .flightmembers import FlightMembers\nfrom .flightroster import FlightRoster\nfrom .flightstate import FlightState, Navigating, Uninitialized\nfrom .flightstate.killed import Killed\nfrom ..sidc import (\n    Entity,\n    SidcDescribable,\n    StandardIdentity,\n    Status,\n    SymbolSet,\n)\n\nif TYPE_CHECKING:\n    from game.callsigns.callsigngenerator import Callsign\n    from game.dcs.aircrafttype import AircraftType\n    from game.sim.gameupdateevents import GameUpdateEvents\n    from game.sim.simulationresults import SimulationResults\n    from game.squadrons import Squadron, Pilot\n    from game.theater import ControlPoint\n    from game.transfers import TransferOrder\n    from game.data.weapons import WeaponType\n    from .flightmember import FlightMember\n    from .flightplans.flightplan import FlightPlan\n    from .flighttype import FlightType\n    from .flightwaypoint import FlightWaypoint\n    from .package import Package\n    from .starttype import StartType\n\n\nclass Flight(SidcDescribable):\n    def __init__(\n        self,\n        package: Package,\n        country: str,\n        squadron: Squadron,\n        count: int,\n        flight_type: FlightType,\n        start_type: StartType,\n        divert: Optional[ControlPoint],\n        custom_name: Optional[str] = None,\n        cargo: Optional[TransferOrder] = None,\n        roster: Optional[FlightRoster] = None,\n        callsign: Optional[Callsign] = None,\n    ) -> None:\n        self.id = uuid.uuid4()\n        self.package = package\n        self.country = country\n        self.coalition = squadron.coalition\n        self.squadron = squadron\n        self.flight_type = flight_type\n        self.squadron.claim_inventory(count)\n        if roster is None:\n            self.roster = FlightMembers(self, initial_size=count)\n        else:\n            self.roster = FlightMembers.from_roster(self, roster)\n        self.divert = divert\n        self.start_type = start_type\n        self.custom_name = custom_name\n        self.use_same_loadout_for_all_members = True\n\n        # Only used by transport missions.\n        self.cargo = cargo\n\n        self.callsign = callsign\n\n        # Flight properties that can be set in the mission editor. This is used for\n        # things like HMD selection, ripple quantity, etc. Any values set here will take\n        # the place of the defaults defined by DCS.\n        #\n        # This is a part of the Flight rather than the Loadout because DCS does not\n        # associate these choices with the loadout, and we don't want to reset these\n        # options when players switch loadouts.\n        self.props: dict[str, Any] = {}\n\n        # Used for simulating the travel to first contact.\n        self.state: FlightState = Uninitialized(self, squadron.settings)\n\n        # Will be replaced with a more appropriate FlightPlan later, but start with a\n        # cheaply constructed one since adding more flights to the package may affect\n        # the optimal layout.\n        from .flightplans.flightplanbuildertypes import FlightPlanBuilderTypes\n\n        self._flight_plan_builder = FlightPlanBuilderTypes.for_flight(self)(self)\n\n    @property\n    def flight_plan(self) -> FlightPlan[Any]:\n        return self._flight_plan_builder.get_or_build()\n\n    def degrade_to_custom_flight_plan(self) -> None:\n        from .flightplans.custom import Builder as CustomBuilder\n\n        self._flight_plan_builder = CustomBuilder(self, self.flight_plan.waypoints[1:])\n        self.recreate_flight_plan()\n        # We need to clear the existing actions/options when moving the waypoints into\n        # the new flight plan because the actions/options that are currently set will be\n        # the actions of whatever flight plan was previously used.\n        # https://github.com/dcs-liberation/dcs_liberation/issues/3189\n        for waypoint in self.flight_plan.iter_waypoints():\n            waypoint.actions.clear()\n            waypoint.options.clear()\n\n    def __getstate__(self) -> dict[str, Any]:\n        state = self.__dict__.copy()\n        # Avoid persisting the flight state since that's not (currently) used outside\n        # mission generation. This is a bit of a hack for the moment and in the future\n        # we will need to persist the flight state, but for now keep it out of save\n        # compat (it also contains a generator that cannot be pickled).\n        del state[\"state\"]\n        return state\n\n    def __setstate__(self, state: dict[str, Any]) -> None:\n        state[\"state\"] = Uninitialized(self, state[\"squadron\"].settings)\n        self.__dict__.update(state)\n\n    @property\n    def blue(self) -> bool:\n        return self.squadron.player\n\n    @property\n    def standard_identity(self) -> StandardIdentity:\n        return StandardIdentity.FRIEND if self.blue else StandardIdentity.HOSTILE_FAKER\n\n    @property\n    def sidc_status(self) -> Status:\n        return Status.PRESENT if self.alive else Status.PRESENT_DESTROYED\n\n    @property\n    def symbol_set_and_entity(self) -> tuple[SymbolSet, Entity]:\n        return SymbolSet.AIR, self.flight_type.entity_type\n\n    @property\n    def departure(self) -> ControlPoint:\n        return self.squadron.location\n\n    @property\n    def arrival(self) -> ControlPoint:\n        return self.squadron.arrival\n\n    @property\n    def count(self) -> int:\n        return self.roster.max_size\n\n    @property\n    def client_count(self) -> int:\n        return self.roster.player_count\n\n    @property\n    def unit_type(self) -> AircraftType:\n        return self.squadron.aircraft\n\n    @property\n    def is_helo(self) -> bool:\n        return self.unit_type.dcs_unit_type.helicopter\n\n    @property\n    def points(self) -> List[FlightWaypoint]:\n        return self.flight_plan.waypoints[1:]\n\n    def position(self) -> Point:\n        return self.state.estimate_position()\n\n    def resize(self, new_size: int) -> None:\n        self.squadron.claim_inventory(new_size - self.count)\n        self.roster.resize(new_size)\n\n    def set_pilot(self, index: int, pilot: Optional[Pilot]) -> None:\n        self.roster.set_pilot(index, pilot)\n\n    @property\n    def missing_pilots(self) -> int:\n        return self.roster.missing_pilots\n\n    def iter_members(self) -> Iterator[FlightMember]:\n        yield from self.roster.members\n\n    def set_flight_type(self, var: FlightType) -> None:\n        self.flight_type = var\n\n        # Update _flight_plan_builder so that the builder class remains relevant\n        # to the flight type\n        from .flightplans.flightplanbuildertypes import FlightPlanBuilderTypes\n\n        self._flight_plan_builder = FlightPlanBuilderTypes.for_flight(self)(self)\n\n    def return_pilots_and_aircraft(self) -> None:\n        self.roster.clear()\n        self.squadron.claim_inventory(-self.count)\n\n    def max_takeoff_fuel(self) -> Optional[float]:\n        # Special case so Su 33 and C101 can take off\n        unit_type = self.unit_type.dcs_unit_type\n        if unit_type == Su_33:\n            if self.flight_type.is_air_to_air:\n                return Su_33.fuel_max / 2.2\n            else:\n                return Su_33.fuel_max * 0.8\n        elif unit_type in {C_101EB, C_101CC}:\n            return unit_type.fuel_max * 0.5\n        return None\n\n    def any_member_has_weapon_of_type(self, weapon_type: WeaponType) -> bool:\n        return any(\n            m.loadout.has_weapon_of_type(weapon_type) for m in self.iter_members()\n        )\n\n    def __repr__(self) -> str:\n        if self.custom_name:\n            return f\"{self.custom_name} {self.count} x {self.unit_type}\"\n        return f\"[{self.flight_type}] {self.count} x {self.unit_type}\"\n\n    def __str__(self) -> str:\n        if self.custom_name:\n            return f\"{self.custom_name} {self.count} x {self.unit_type}\"\n        return f\"[{self.flight_type}] {self.count} x {self.unit_type}\"\n\n    def abort(self) -> None:\n        from .flightplans.rtb import RtbFlightPlan\n\n        self._flight_plan_builder = RtbFlightPlan.builder_type()(self)\n        plan = self._flight_plan_builder.get_or_build()\n\n        self.set_state(\n            Navigating(\n                self,\n                self.squadron.settings,\n                plan.abort_index,\n                has_aborted=True,\n            )\n        )\n\n    def set_state(self, state: FlightState) -> None:\n        self.state = state\n\n    def on_game_tick(\n        self, events: GameUpdateEvents, time: datetime, duration: timedelta\n    ) -> None:\n        self.state.on_game_tick(events, time, duration)\n\n    def should_halt_sim(self) -> bool:\n        return self.state.should_halt_sim()\n\n    @property\n    def alive(self) -> bool:\n        return self.state.alive\n\n    def kill(self, results: SimulationResults, events: GameUpdateEvents) -> None:\n        # This is a bit messy while we're in transition from turn-based to turnless\n        # because we want the simulation to have minimal impact on the save game while\n        # turns exist so that loading a game is essentially a way to reset the\n        # simulation to the start of the turn. As such, we don't actually want to mark\n        # pilots killed or reduce squadron aircraft availability, but we do still need\n        # the UI to reflect that aircraft were lost and avoid generating those flights\n        # when the mission is generated.\n        #\n        # For now we do this by logging the kill in the SimulationResults, which is\n        # similar to the Debriefing. We also set the flight's state to Killed, which\n        # will prevent it from being spawned in the mission and updates the SIDC.\n        # This does leave an opportunity for players to cheat since the UI won't stop\n        # them from cancelling a dead flight, returning the aircraft to the pool. Not a\n        # big deal for now.\n        # TODO: Support partial kills.\n        self.set_state(\n            Killed(self.state.estimate_position(), self, self.squadron.settings)\n        )\n        events.update_flight(self)\n        for pilot in self.roster.iter_pilots():\n            if pilot is not None:\n                results.kill_pilot(self, pilot)\n\n    def recreate_flight_plan(self, dump_debug_info: bool = False) -> None:\n        self._flight_plan_builder.regenerate(dump_debug_info)\n"}
{"type": "source_file", "path": "game/ato/flightplans/bai.py", "content": "from __future__ import annotations\n\nfrom typing import Type\n\nfrom game.theater.theatergroundobject import TheaterGroundObject\nfrom .formationattack import (\n    FormationAttackBuilder,\n    FormationAttackFlightPlan,\n    FormationAttackLayout,\n)\nfrom .invalidobjectivelocation import InvalidObjectiveLocation\nfrom .waypointbuilder import StrikeTarget\nfrom ..flightwaypointtype import FlightWaypointType\n\n\nclass BaiFlightPlan(FormationAttackFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n\nclass Builder(FormationAttackBuilder[BaiFlightPlan, FormationAttackLayout]):\n    def layout(self) -> FormationAttackLayout:\n        location = self.package.target\n\n        from game.transfers import Convoy\n\n        targets: list[StrikeTarget] = []\n        if isinstance(location, TheaterGroundObject):\n            for group in location.groups:\n                if group.units:\n                    targets.append(\n                        StrikeTarget(f\"{group.group_name} at {location.name}\", group)\n                    )\n        elif isinstance(location, Convoy):\n            targets.append(StrikeTarget(location.name, location))\n        else:\n            raise InvalidObjectiveLocation(self.flight.flight_type, location)\n\n        return self._build(FlightWaypointType.INGRESS_BAI, targets)\n\n    def build(self, dump_debug_info: bool = False) -> BaiFlightPlan:\n        return BaiFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/formation.py", "content": "from __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom functools import cached_property\nfrom typing import Any, TYPE_CHECKING, TypeGuard, TypeVar\n\nfrom game.typeguard import self_type_guard\nfrom game.utils import Speed\nfrom .flightplan import FlightPlan\nfrom .loiter import LoiterFlightPlan, LoiterLayout\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass FormationLayout(LoiterLayout, ABC):\n    nav_to: list[FlightWaypoint]\n    join: FlightWaypoint\n    split: FlightWaypoint\n    refuel: FlightWaypoint\n    nav_from: list[FlightWaypoint]\n\n\nLayoutT = TypeVar(\"LayoutT\", bound=FormationLayout)\n\n\nclass FormationFlightPlan(LoiterFlightPlan[LayoutT], ABC):\n    @property\n    @abstractmethod\n    def package_speed_waypoints(self) -> set[FlightWaypoint]: ...\n\n    @property\n    def combat_speed_waypoints(self) -> set[FlightWaypoint]:\n        return self.package_speed_waypoints\n\n    @cached_property\n    def best_flight_formation_speed(self) -> Speed:\n        \"\"\"The best speed this flight is capable at all formation waypoints.\n\n        To ease coordination with other flights, we aim to have a single mission\n        speed used by the formation for all waypoints. As such, this function\n        returns the highest ground speed that the flight is capable of flying at\n        all of its formation waypoints.\n        \"\"\"\n        speeds = []\n        for previous_waypoint, waypoint in self.edges():\n            if waypoint in self.package_speed_waypoints:\n                speeds.append(\n                    self.best_speed_between_waypoints(previous_waypoint, waypoint)\n                )\n        return min(speeds)\n\n    def speed_between_waypoints(self, a: FlightWaypoint, b: FlightWaypoint) -> Speed:\n        if b in self.package_speed_waypoints:\n            # Should be impossible, as any package with at least one\n            # FormationFlightPlan flight needs a formation speed.\n            assert self.package.formation_speed is not None\n            return self.package.formation_speed\n        return super().speed_between_waypoints(a, b)\n\n    @property\n    def travel_time_to_rendezvous(self) -> timedelta:\n        \"\"\"The estimated time between the first waypoint and the join point.\"\"\"\n        return self._travel_time_to_waypoint(self.layout.join)\n\n    @property\n    @abstractmethod\n    def join_time(self) -> datetime: ...\n\n    @property\n    @abstractmethod\n    def split_time(self) -> datetime: ...\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.layout.join:\n            return self.join_time\n        elif waypoint == self.layout.split:\n            return self.split_time\n        return None\n\n    @property\n    def push_time(self) -> datetime:\n        return self.join_time - self.travel_time_between_waypoints(\n            self.layout.hold, self.layout.join\n        )\n\n    @property\n    def mission_begin_on_station_time(self) -> datetime | None:\n        return None\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        return self.split_time\n\n    @self_type_guard\n    def is_formation(\n        self, flight_plan: FlightPlan[Any]\n    ) -> TypeGuard[FormationFlightPlan[Any]]:\n        return True\n"}
{"type": "source_file", "path": "game/ato/flightplans/antiship.py", "content": "from __future__ import annotations\n\nfrom typing import Type\n\nfrom game.theater import NavalControlPoint\nfrom game.theater.theatergroundobject import NavalGroundObject\nfrom .formationattack import (\n    FormationAttackBuilder,\n    FormationAttackFlightPlan,\n    FormationAttackLayout,\n)\nfrom .invalidobjectivelocation import InvalidObjectiveLocation\nfrom .waypointbuilder import StrikeTarget\nfrom ..flightwaypointtype import FlightWaypointType\n\n\nclass AntiShipFlightPlan(FormationAttackFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n\nclass Builder(FormationAttackBuilder[AntiShipFlightPlan, FormationAttackLayout]):\n    def layout(self) -> FormationAttackLayout:\n        location = self.package.target\n\n        from game.transfers import CargoShip\n\n        if isinstance(location, NavalControlPoint):\n            targets = self.anti_ship_targets_for_tgo(location.find_main_tgo())\n        elif isinstance(location, NavalGroundObject):\n            targets = self.anti_ship_targets_for_tgo(location)\n        elif isinstance(location, CargoShip):\n            targets = [StrikeTarget(location.name, location)]\n        else:\n            raise InvalidObjectiveLocation(self.flight.flight_type, location)\n\n        return self._build(FlightWaypointType.INGRESS_ANTI_SHIP, targets)\n\n    @staticmethod\n    def anti_ship_targets_for_tgo(tgo: NavalGroundObject) -> list[StrikeTarget]:\n        return [StrikeTarget(f\"{g.group_name} at {tgo.name}\", g) for g in tgo.groups]\n\n    def build(self, dump_debug_info: bool = False) -> AntiShipFlightPlan:\n        return AntiShipFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/escort.py", "content": "from __future__ import annotations\n\nfrom typing import Type\n\nfrom .formationattack import (\n    FormationAttackBuilder,\n    FormationAttackFlightPlan,\n    FormationAttackLayout,\n)\nfrom .waypointbuilder import WaypointBuilder\n\n\nclass EscortFlightPlan(FormationAttackFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n\nclass Builder(FormationAttackBuilder[EscortFlightPlan, FormationAttackLayout]):\n    def layout(self) -> FormationAttackLayout:\n        assert self.package.waypoints is not None\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n        ingress, target = builder.escort(\n            self.package.waypoints.ingress, self.package.target\n        )\n        hold = builder.hold(self._hold_point())\n        join = builder.join(self.package.waypoints.join)\n        split = builder.split(self.package.waypoints.split)\n        refuel = builder.refuel(self.package.waypoints.refuel)\n\n        return FormationAttackLayout(\n            departure=builder.takeoff(self.flight.departure),\n            hold=hold,\n            nav_to=builder.nav_path(\n                hold.position, join.position, self.doctrine.combat_altitude\n            ),\n            join=join,\n            ingress=ingress,\n            targets=[target],\n            split=split,\n            refuel=refuel,\n            nav_from=builder.nav_path(\n                refuel.position,\n                self.flight.arrival.position,\n                self.doctrine.combat_altitude,\n            ),\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> EscortFlightPlan:\n        return EscortFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/aewc.py", "content": "from __future__ import annotations\n\nfrom datetime import timedelta\nfrom typing import Type\n\nfrom game.ato.flightplans.ibuilder import IBuilder\nfrom game.ato.flightplans.patrolling import PatrollingFlightPlan, PatrollingLayout\nfrom game.ato.flightplans.waypointbuilder import WaypointBuilder\nfrom game.utils import Distance, Heading, Speed, feet, knots, meters, nautical_miles\n\n\nclass AewcFlightPlan(PatrollingFlightPlan[PatrollingLayout]):\n    @property\n    def patrol_duration(self) -> timedelta:\n        return timedelta(hours=4)\n\n    @property\n    def patrol_speed(self) -> Speed:\n        altitude = self.layout.patrol_start.alt\n        if self.flight.unit_type.preferred_patrol_speed(altitude) is not None:\n            return self.flight.unit_type.preferred_patrol_speed(altitude)\n        return knots(390)\n\n    @property\n    def engagement_distance(self) -> Distance:\n        # TODO: Factor out a common base of the combat and non-combat race-tracks.\n        # No harm in setting this, but we ought to clean up a bit.\n        return meters(0)\n\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n\nclass Builder(IBuilder[AewcFlightPlan, PatrollingLayout]):\n    def layout(self) -> PatrollingLayout:\n        racetrack_half_distance = nautical_miles(30).meters\n\n        location = self.package.target\n\n        closest_boundary = self.threat_zones.closest_boundary(location.position)\n        heading_to_threat_boundary = Heading.from_degrees(\n            location.position.heading_between_point(closest_boundary)\n        )\n        distance_to_threat = meters(\n            location.position.distance_to_point(closest_boundary)\n        )\n        orbit_heading = heading_to_threat_boundary\n\n        # Station 80nm outside the threat zone.\n        threat_buffer = nautical_miles(80)\n        if self.threat_zones.threatened(location.position):\n            orbit_distance = distance_to_threat + threat_buffer\n        else:\n            orbit_distance = distance_to_threat - threat_buffer\n\n        racetrack_center = location.position.point_from_heading(\n            orbit_heading.degrees, orbit_distance.meters\n        )\n\n        racetrack_start = racetrack_center.point_from_heading(\n            orbit_heading.right.degrees, racetrack_half_distance\n        )\n\n        racetrack_end = racetrack_center.point_from_heading(\n            orbit_heading.left.degrees, racetrack_half_distance\n        )\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n\n        if self.flight.unit_type.patrol_altitude is not None:\n            altitude = self.flight.unit_type.patrol_altitude\n        else:\n            altitude = feet(25000)\n\n        racetrack = builder.race_track(racetrack_start, racetrack_end, altitude)\n\n        return PatrollingLayout(\n            departure=builder.takeoff(self.flight.departure),\n            nav_to=builder.nav_path(\n                self.flight.departure.position, racetrack_start, altitude\n            ),\n            nav_from=builder.nav_path(\n                racetrack_end, self.flight.arrival.position, altitude\n            ),\n            patrol_start=racetrack[0],\n            patrol_end=racetrack[1],\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> AewcFlightPlan:\n        return AewcFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/formationattack.py", "content": "from __future__ import annotations\n\nfrom abc import ABC\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom typing import TYPE_CHECKING, TypeVar\n\nfrom dcs import Point\n\nfrom game.flightplan import HoldZoneGeometry\nfrom game.theater import MissionTarget\nfrom game.utils import Speed, meters\nfrom .flightplan import FlightPlan\nfrom .formation import FormationFlightPlan, FormationLayout\nfrom .ibuilder import IBuilder\nfrom .waypointbuilder import StrikeTarget, WaypointBuilder\nfrom .. import FlightType\nfrom ..flightwaypoint import FlightWaypoint\nfrom ..flightwaypointtype import FlightWaypointType\n\nif TYPE_CHECKING:\n    from ..flight import Flight\n\n\n@dataclass(frozen=True)\nclass FormationAttackLayout(FormationLayout):\n    ingress: FlightWaypoint\n    targets: list[FlightWaypoint]\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield self.hold\n        yield from self.nav_to\n        yield self.join\n        yield self.ingress\n        yield from self.targets\n        yield self.split\n        if self.refuel is not None:\n            yield self.refuel\n        yield from self.nav_from\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nclass FormationAttackFlightPlan(FormationFlightPlan[FormationAttackLayout], ABC):\n    @property\n    def package_speed_waypoints(self) -> set[FlightWaypoint]:\n        return {\n            self.layout.ingress,\n            self.layout.split,\n        } | set(self.layout.targets)\n\n    def speed_between_waypoints(self, a: FlightWaypoint, b: FlightWaypoint) -> Speed:\n        # FlightWaypoint is only comparable by identity, so adding\n        # target_area_waypoint to package_speed_waypoints is useless.\n        if b.waypoint_type == FlightWaypointType.TARGET_GROUP_LOC:\n            # Should be impossible, as any package with at least one\n            # FormationFlightPlan flight needs a formation speed.\n            assert self.package.formation_speed is not None\n            return self.package.formation_speed\n        return super().speed_between_waypoints(a, b)\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        return self.layout.targets[0]\n\n    @property\n    def target_area_waypoint(self) -> FlightWaypoint:\n        return FlightWaypoint(\n            \"TARGET AREA\",\n            FlightWaypointType.TARGET_GROUP_LOC,\n            self.package.target.position,\n            meters(0),\n            \"RADIO\",\n        )\n\n    @property\n    def join_time(self) -> datetime:\n        travel_time = self.total_time_between_waypoints(\n            self.layout.join, self.layout.ingress\n        )\n        return self.ingress_time - travel_time\n\n    @property\n    def split_time(self) -> datetime:\n        travel_time_ingress = self.total_time_between_waypoints(\n            self.layout.ingress, self.target_area_waypoint\n        )\n        travel_time_egress = self.total_time_between_waypoints(\n            self.target_area_waypoint, self.layout.split\n        )\n        minutes_at_target = 0.75 * len(self.layout.targets)\n        timedelta_at_target = timedelta(minutes=minutes_at_target)\n        return (\n            self.ingress_time\n            + travel_time_ingress\n            + timedelta_at_target\n            + travel_time_egress\n        )\n\n    @property\n    def ingress_time(self) -> datetime:\n        tot = self.tot\n        travel_time = self.total_time_between_waypoints(\n            self.layout.ingress, self.target_area_waypoint\n        )\n        return tot - travel_time\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.layout.ingress:\n            return self.ingress_time\n        elif waypoint in self.layout.targets:\n            return self.tot\n        return super().tot_for_waypoint(waypoint)\n\n\nFlightPlanT = TypeVar(\"FlightPlanT\", bound=FlightPlan[FormationAttackLayout])\nLayoutT = TypeVar(\"LayoutT\", bound=FormationAttackLayout)\n\n\nclass FormationAttackBuilder(IBuilder[FlightPlanT, LayoutT], ABC):\n    def _build(\n        self,\n        ingress_type: FlightWaypointType,\n        targets: list[StrikeTarget] | None = None,\n    ) -> FormationAttackLayout:\n        assert self.package.waypoints is not None\n        builder = WaypointBuilder(self.flight, self.coalition, targets)\n\n        target_waypoints: list[FlightWaypoint] = []\n        if targets is not None:\n            for target in targets:\n                target_waypoints.append(\n                    self.target_waypoint(self.flight, builder, target)\n                )\n        else:\n            target_waypoints.append(\n                self.target_area_waypoint(\n                    self.flight, self.flight.package.target, builder\n                )\n            )\n\n        hold = builder.hold(self._hold_point())\n        join = builder.join(self.package.waypoints.join)\n        join.wants_escort = True\n\n        ingress = builder.ingress(\n            ingress_type, self.package.waypoints.ingress, self.package.target\n        )\n        ingress.wants_escort = True\n\n        for target_waypoint in target_waypoints:\n            target_waypoint.wants_escort = True\n\n        split = builder.split(self.package.waypoints.split)\n        split.wants_escort = True\n        refuel = builder.refuel(self.package.waypoints.refuel)\n\n        return FormationAttackLayout(\n            departure=builder.takeoff(self.flight.departure),\n            hold=hold,\n            nav_to=builder.nav_path(\n                hold.position, join.position, self.doctrine.combat_altitude\n            ),\n            join=join,\n            ingress=ingress,\n            targets=target_waypoints,\n            split=split,\n            refuel=refuel,\n            nav_from=builder.nav_path(\n                refuel.position,\n                self.flight.arrival.position,\n                self.doctrine.combat_altitude,\n            ),\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    @staticmethod\n    def target_waypoint(\n        flight: Flight, builder: WaypointBuilder, target: StrikeTarget\n    ) -> FlightWaypoint:\n        if flight.flight_type in {FlightType.ANTISHIP, FlightType.BAI}:\n            return builder.bai_group(target)\n        elif flight.flight_type == FlightType.DEAD:\n            return builder.dead_point(target)\n        elif flight.flight_type == FlightType.SEAD:\n            return builder.sead_point(target)\n        else:\n            return builder.strike_point(target)\n\n    @staticmethod\n    def target_area_waypoint(\n        flight: Flight, location: MissionTarget, builder: WaypointBuilder\n    ) -> FlightWaypoint:\n        if flight.flight_type == FlightType.DEAD:\n            return builder.dead_area(location)\n        elif flight.flight_type == FlightType.SEAD:\n            return builder.sead_area(location)\n        elif flight.flight_type == FlightType.OCA_AIRCRAFT:\n            return builder.oca_strike_area(location)\n        else:\n            return builder.strike_area(location)\n\n    def _hold_point(self) -> Point:\n        assert self.package.waypoints is not None\n        origin = self.flight.departure.position\n        target = self.package.target.position\n        join = self.package.waypoints.join\n        ip = self.package.waypoints.ingress\n        return HoldZoneGeometry(\n            target, origin, ip, join, self.coalition, self.theater\n        ).find_best_hold_point()\n"}
{"type": "source_file", "path": "game/ato/flightplans/standard.py", "content": "from __future__ import annotations\n\nfrom abc import ABC\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING, TypeVar\n\nfrom game.ato.flightplans.flightplan import FlightPlan, Layout\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass StandardLayout(Layout, ABC):\n    arrival: FlightWaypoint\n    divert: FlightWaypoint | None\n    bullseye: FlightWaypoint\n\n\nLayoutT = TypeVar(\"LayoutT\", bound=StandardLayout)\n\n\nclass StandardFlightPlan(FlightPlan[LayoutT], ABC):\n    \"\"\"Base type for all non-custom flight plans.\n\n    We can't reason about custom flight plans so they get special treatment, but all\n    others are guaranteed to have certain properties like departure and arrival points,\n    potentially a divert field, and a bullseye\n    \"\"\"\n"}
{"type": "source_file", "path": "game/ato/flightplans/refuelingflightplan.py", "content": "from abc import ABC\n\nfrom game.utils import Distance, Speed, knots, meters\nfrom .patrolling import PatrollingFlightPlan, PatrollingLayout\n\n\nclass RefuelingFlightPlan(PatrollingFlightPlan[PatrollingLayout], ABC):\n    @property\n    def patrol_speed(self) -> Speed:\n        # TODO: Could use self.flight.unit_type.preferred_patrol_speed(altitude).\n        if self.flight.unit_type.patrol_speed is not None:\n            return self.flight.unit_type.patrol_speed\n        # ~280 knots IAS at 21000.\n        return knots(400)\n\n    @property\n    def engagement_distance(self) -> Distance:\n        # TODO: Factor out a common base of the combat and non-combat race-tracks.\n        # No harm in setting this, but we ought to clean up a bit.\n        return meters(0)\n"}
{"type": "source_file", "path": "game/ato/flightmember.py", "content": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom game.ato.loadouts import Loadout\nfrom game.lasercodes import LaserCode\n\nif TYPE_CHECKING:\n    from game.squadrons import Pilot\n\n\nclass FlightMember:\n    def __init__(self, pilot: Pilot | None, loadout: Loadout) -> None:\n        self.pilot = pilot\n        self.loadout = loadout\n        self.use_custom_loadout = False\n        self.tgp_laser_code: LaserCode | None = None\n        self.weapon_laser_code: LaserCode | None = None\n        self.properties: dict[str, bool | float | int] = {}\n\n    def assign_tgp_laser_code(self, code: LaserCode) -> None:\n        if self.tgp_laser_code is not None:\n            raise RuntimeError(\n                f\"{self.pilot} already has already been assigned laser code \"\n                f\"{self.tgp_laser_code}\"\n            )\n        self.tgp_laser_code = code\n\n    def release_tgp_laser_code(self) -> None:\n        if self.tgp_laser_code is None:\n            raise RuntimeError(f\"{self.pilot} has no assigned laser code\")\n\n        if self.weapon_laser_code == self.tgp_laser_code:\n            self.weapon_laser_code = None\n        self.tgp_laser_code.release()\n        self.tgp_laser_code = None\n\n    @property\n    def is_player(self) -> bool:\n        if self.pilot is None:\n            return False\n        return self.pilot.player\n"}
{"type": "source_file", "path": "game/ato/flightmembers.py", "content": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom typing import Optional, TYPE_CHECKING\n\nfrom .flightmember import FlightMember\nfrom .flightroster import FlightRoster\nfrom .iflightroster import IFlightRoster\nfrom .loadouts import Loadout\n\nif TYPE_CHECKING:\n    from game.squadrons import Pilot\n    from .flight import Flight\n\n\nclass FlightMembers(IFlightRoster):\n    def __init__(self, flight: Flight, initial_size: int = 0) -> None:\n        self.flight = flight\n        self.members: list[FlightMember] = []\n        self.resize(initial_size)\n\n    @staticmethod\n    def from_roster(flight: Flight, roster: FlightRoster) -> FlightMembers:\n        members = FlightMembers(flight)\n        loadout = Loadout.default_for(flight)\n        members.members = [FlightMember(p, loadout) for p in roster.pilots]\n        return members\n\n    def iter_pilots(self) -> Iterator[Pilot | None]:\n        yield from (m.pilot for m in self.members)\n\n    def pilot_at(self, idx: int) -> Pilot | None:\n        return self.members[idx].pilot\n\n    @property\n    def max_size(self) -> int:\n        return len(self.members)\n\n    @property\n    def player_count(self) -> int:\n        return len([m for m in self.members if m.is_player])\n\n    @property\n    def missing_pilots(self) -> int:\n        return len([m for m in self.members if m.pilot is None])\n\n    def resize(self, new_size: int) -> None:\n        if self.max_size > new_size:\n            for member in self.members[new_size:]:\n                if (pilot := member.pilot) is not None:\n                    self.flight.squadron.return_pilot(pilot)\n                if (code := member.tgp_laser_code) is not None:\n                    code.release()\n            self.members = self.members[:new_size]\n            return\n        if self.max_size:\n            loadout = self.members[0].loadout.clone()\n        else:\n            loadout = Loadout.default_for(self.flight)\n        for _ in range(new_size - self.max_size):\n            member = FlightMember(self.flight.squadron.claim_available_pilot(), loadout)\n            member.use_custom_loadout = loadout.is_custom\n            self.members.append(member)\n\n    def set_pilot(self, index: int, pilot: Optional[Pilot]) -> None:\n        if pilot is not None:\n            self.flight.squadron.claim_pilot(pilot)\n        if (current_pilot := self.pilot_at(index)) is not None:\n            self.flight.squadron.return_pilot(current_pilot)\n        self.members[index].pilot = pilot\n\n    def clear(self) -> None:\n        self.flight.squadron.return_pilots(\n            [p for p in self.iter_pilots() if p is not None]\n        )\n        for member in self.members:\n            if (code := member.tgp_laser_code) is not None:\n                code.release()\n\n    def use_same_loadout_for_all_members(self) -> None:\n        if not self.members:\n            return\n        loadout = self.members[0].loadout\n        for member in self.members[1:]:\n            # Do not clone the loadout, we want any changes in the UI to be mirrored\n            # across all flight members.\n            member.loadout = loadout\n\n    def use_distinct_loadouts_for_each_member(self) -> None:\n        for member in self.members:\n            member.loadout = member.loadout.clone()\n"}
{"type": "source_file", "path": "game/ato/flightplans/airlift.py", "content": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING, Type\n\nfrom game.theater.missiontarget import MissionTarget\nfrom game.utils import feet\nfrom .ibuilder import IBuilder\nfrom .planningerror import PlanningError\nfrom .standard import StandardFlightPlan, StandardLayout\nfrom .waypointbuilder import WaypointBuilder\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass AirliftLayout(StandardLayout):\n    nav_to_pickup: list[FlightWaypoint]\n    # There will not be a pickup waypoint when the pickup airfield is the departure\n    # airfield for cargo planes, as the cargo is pre-loaded. Helicopters will still pick\n    # up the cargo near the airfield.\n    pickup: FlightWaypoint | None\n    # pickup_zone will be used for player flights to create the CTLD stuff\n    ctld_pickup_zone: FlightWaypoint | None\n    nav_to_drop_off: list[FlightWaypoint]\n    # There will not be a drop-off waypoint when the drop-off airfield and the arrival\n    # airfield is the same for a cargo plane, as planes will land to unload and we don't\n    # want a double landing. Helicopters will still drop their cargo near the airfield\n    # before landing.\n    drop_off: FlightWaypoint | None\n    # drop_off_zone will be used for player flights to create the CTLD stuff\n    ctld_drop_off_zone: FlightWaypoint | None\n    nav_to_home: list[FlightWaypoint]\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield from self.nav_to_pickup\n        if self.pickup is not None:\n            yield self.pickup\n        if self.ctld_pickup_zone is not None:\n            yield self.ctld_pickup_zone\n        yield from self.nav_to_drop_off\n        if self.drop_off is not None:\n            yield self.drop_off\n        if self.ctld_drop_off_zone is not None:\n            yield self.ctld_drop_off_zone\n        yield from self.nav_to_home\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nclass AirliftFlightPlan(StandardFlightPlan[AirliftLayout]):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        # The TOT is the time that the cargo will be dropped off. If the drop-off\n        # location is the arrival airfield and this is not a helicopter flight, there\n        # will not be a separate drop-off waypoint; the arrival landing waypoint is the\n        # drop-off waypoint.\n        return self.layout.drop_off or self.layout.arrival\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        # TOT planning isn't really useful for transports. They're behind the front\n        # lines so no need to wait for escorts or for other missions to complete.\n        return None\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        return None\n\n    @property\n    def mission_begin_on_station_time(self) -> datetime | None:\n        return None\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        return self.package.time_over_target\n\n\nclass Builder(IBuilder[AirliftFlightPlan, AirliftLayout]):\n    def layout(self) -> AirliftLayout:\n        cargo = self.flight.cargo\n        if cargo is None:\n            raise PlanningError(\n                \"Cannot plan transport mission for flight with no cargo.\"\n            )\n\n        altitude = feet(1500)\n        altitude_is_agl = True\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n\n        pickup = None\n        drop_off = None\n        pickup_zone = None\n        drop_off_zone = None\n\n        if cargo.origin != self.flight.departure:\n            pickup = builder.cargo_stop(cargo.origin)\n        if cargo.next_stop != self.flight.arrival:\n            drop_off = builder.cargo_stop(cargo.next_stop)\n\n        if self.flight.is_helo:\n            # Create CTLD Zones for Helo flights\n            pickup_zone = builder.pickup_zone(\n                MissionTarget(\n                    \"Pickup Zone\", cargo.origin.position.random_point_within(1000, 200)\n                )\n            )\n            drop_off_zone = builder.dropoff_zone(\n                MissionTarget(\n                    \"Dropoff zone\",\n                    cargo.next_stop.position.random_point_within(1000, 200),\n                )\n            )\n            # Show the zone waypoints only to the player\n            pickup_zone.only_for_player = True\n            drop_off_zone.only_for_player = True\n\n        nav_to_pickup = builder.nav_path(\n            self.flight.departure.position,\n            cargo.origin.position,\n            altitude,\n            altitude_is_agl,\n        )\n\n        return AirliftLayout(\n            departure=builder.takeoff(self.flight.departure),\n            nav_to_pickup=nav_to_pickup,\n            pickup=pickup,\n            ctld_pickup_zone=pickup_zone,\n            nav_to_drop_off=builder.nav_path(\n                cargo.origin.position,\n                cargo.next_stop.position,\n                altitude,\n                altitude_is_agl,\n            ),\n            drop_off=drop_off,\n            ctld_drop_off_zone=drop_off_zone,\n            nav_to_home=builder.nav_path(\n                cargo.origin.position,\n                self.flight.arrival.position,\n                altitude,\n                altitude_is_agl,\n            ),\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> AirliftFlightPlan:\n        return AirliftFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/airassault.py", "content": "from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Iterator, TYPE_CHECKING, Type\n\nfrom game.ato.flightplans.standard import StandardFlightPlan, StandardLayout\nfrom game.theater.controlpoint import ControlPointType\nfrom game.theater.missiontarget import MissionTarget\nfrom game.utils import Distance, feet, meters\nfrom .ibuilder import IBuilder\nfrom .planningerror import PlanningError\nfrom .uizonedisplay import UiZone, UiZoneDisplay\nfrom .waypointbuilder import WaypointBuilder\nfrom ..flightwaypoint import FlightWaypointType\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass AirAssaultLayout(StandardLayout):\n    # The pickup point is optional because we don't always need to load the cargo. When\n    # departing from a carrier, LHA, or off-map spawn, the cargo is pre-loaded.\n    pickup: FlightWaypoint | None\n    nav_to_ingress: list[FlightWaypoint]\n    ingress: FlightWaypoint\n    drop_off: FlightWaypoint\n    # This is an implementation detail used by CTLD. The aircraft will not go to this\n    # waypoint. It is used by CTLD as the destination for unloaded troops.\n    target: FlightWaypoint\n    nav_to_home: list[FlightWaypoint]\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        if self.pickup is not None:\n            yield self.pickup\n        yield from self.nav_to_ingress\n        yield self.ingress\n        yield self.drop_off\n        yield self.target\n        yield from self.nav_to_home\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nclass AirAssaultFlightPlan(StandardFlightPlan[AirAssaultLayout], UiZoneDisplay):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        return self.layout.drop_off\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.tot_waypoint:\n            return self.tot\n        return None\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        return None\n\n    @property\n    def ctld_target_zone_radius(self) -> Distance:\n        return meters(2500)\n\n    @property\n    def mission_begin_on_station_time(self) -> datetime | None:\n        return None\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        return self.package.time_over_target\n\n    def ui_zone(self) -> UiZone:\n        return UiZone(\n            [self.layout.target.position],\n            self.ctld_target_zone_radius,\n        )\n\n\nclass Builder(IBuilder[AirAssaultFlightPlan, AirAssaultLayout]):\n    def layout(self) -> AirAssaultLayout:\n        if not self.flight.is_helo:\n            raise PlanningError(\"Air assault is only usable by helicopters\")\n        assert self.package.waypoints is not None\n\n        altitude = self.doctrine.helicopter.air_assault_nav_altitude\n        altitude_is_agl = self.flight.is_helo\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n\n        if self.flight.departure.cptype in [\n            ControlPointType.AIRCRAFT_CARRIER_GROUP,\n            ControlPointType.LHA_GROUP,\n            ControlPointType.OFF_MAP,\n        ]:\n            # Off_Map spawns will be preloaded\n            # Carrier operations load the logistics directly from the carrier\n            pickup = None\n            pickup_position = self.flight.departure.position\n        else:\n            # TODO The calculation of the Pickup LZ is currently randomized. This\n            # leads to the problem that we can not gurantee that the LZ is clear of\n            # obstacles. This has to be improved in the future so that the Mission can\n            # be autoplanned. In the current state the User has to check the created\n            # Waypoints for the Pickup and Dropoff LZs are free of obstacles.\n            # Create a special pickup zone for Helos from Airbase / FOB\n            pickup = builder.pickup_zone(\n                MissionTarget(\n                    \"Pickup Zone\",\n                    self.flight.departure.position.random_point_within(1200, 600),\n                )\n            )\n            pickup_position = pickup.position\n        assault_area = builder.assault_area(self.package.target)\n        heading = self.package.target.position.heading_between_point(pickup_position)\n\n        # TODO we can not gurantee a safe LZ for DropOff. See comment above.\n        drop_off_zone = MissionTarget(\n            \"Dropoff zone\",\n            self.package.target.position.point_from_heading(heading, 1200),\n        )\n\n        return AirAssaultLayout(\n            departure=builder.takeoff(self.flight.departure),\n            pickup=pickup,\n            nav_to_ingress=builder.nav_path(\n                pickup_position,\n                self.package.waypoints.ingress,\n                altitude,\n                altitude_is_agl,\n            ),\n            ingress=builder.ingress(\n                FlightWaypointType.INGRESS_AIR_ASSAULT,\n                self.package.waypoints.ingress,\n                self.package.target,\n            ),\n            drop_off=builder.dropoff_zone(drop_off_zone),\n            target=assault_area,\n            nav_to_home=builder.nav_path(\n                drop_off_zone.position,\n                self.flight.arrival.position,\n                altitude,\n                altitude_is_agl,\n            ),\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> AirAssaultFlightPlan:\n        return AirAssaultFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/__init__.py", "content": ""}
{"type": "source_file", "path": "game/ato/flightplans/sweep.py", "content": "from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom typing import Iterator, TYPE_CHECKING, Type\n\nfrom dcs import Point\nfrom dcs.task import Targets\n\nfrom game.flightplan import HoldZoneGeometry\nfrom game.flightplan.waypointactions.engagetargets import EngageTargets\nfrom game.flightplan.waypointoptions.formation import Formation\nfrom game.utils import Heading, nautical_miles\nfrom .ibuilder import IBuilder\nfrom .loiter import LoiterFlightPlan, LoiterLayout\nfrom .waypointbuilder import WaypointBuilder\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass SweepLayout(LoiterLayout):\n    nav_to: list[FlightWaypoint]\n    sweep_start: FlightWaypoint\n    sweep_end: FlightWaypoint\n    nav_from: list[FlightWaypoint]\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield self.hold\n        yield from self.nav_to\n        yield self.sweep_start\n        yield self.sweep_end\n        yield from self.nav_from\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nclass SweepFlightPlan(LoiterFlightPlan[SweepLayout]):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def combat_speed_waypoints(self) -> set[FlightWaypoint]:\n        return {self.layout.sweep_end}\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        return self.layout.sweep_end\n\n    def default_tot_offset(self) -> timedelta:\n        return -timedelta(minutes=5)\n\n    @property\n    def sweep_start_time(self) -> datetime:\n        travel_time = self.total_time_between_waypoints(\n            self.layout.sweep_start, self.layout.sweep_end\n        )\n        return self.sweep_end_time - travel_time\n\n    @property\n    def sweep_end_time(self) -> datetime:\n        return self.tot\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.layout.sweep_start:\n            return self.sweep_start_time\n        if waypoint == self.layout.sweep_end:\n            return self.sweep_end_time\n        return None\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.layout.hold:\n            return self.push_time\n        return None\n\n    @property\n    def push_time(self) -> datetime:\n        return self.sweep_end_time - self.travel_time_between_waypoints(\n            self.layout.hold, self.layout.sweep_end\n        )\n\n    @property\n    def mission_begin_on_station_time(self) -> datetime | None:\n        return None\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        return self.sweep_end_time\n\n    def add_waypoint_actions(self) -> None:\n        super().add_waypoint_actions()\n        self.layout.sweep_start.set_option(Formation.LINE_ABREAST_OPEN)\n        self.layout.sweep_start.add_action(\n            EngageTargets(\n                nautical_miles(50),\n                [\n                    Targets.All.Air.Planes.Fighters,\n                    Targets.All.Air.Planes.MultiroleFighters,\n                ],\n            )\n        )\n\n\nclass Builder(IBuilder[SweepFlightPlan, SweepLayout]):\n    def layout(self) -> SweepLayout:\n        assert self.package.waypoints is not None\n        target = self.package.target.position\n        heading = Heading.from_degrees(\n            self.package.waypoints.join.heading_between_point(target)\n        )\n        start_pos = target.point_from_heading(\n            heading.degrees, -self.doctrine.sweep.distance.meters\n        )\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n        start, end = builder.sweep(start_pos, target, self.doctrine.combat_altitude)\n\n        hold = builder.hold(self._hold_point())\n\n        return SweepLayout(\n            departure=builder.takeoff(self.flight.departure),\n            hold=hold,\n            nav_to=builder.nav_path(\n                hold.position, start.position, self.doctrine.combat_altitude\n            ),\n            nav_from=builder.nav_path(\n                end.position,\n                self.flight.arrival.position,\n                self.doctrine.combat_altitude,\n            ),\n            sweep_start=start,\n            sweep_end=end,\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def _hold_point(self) -> Point:\n        assert self.package.waypoints is not None\n        origin = self.flight.departure.position\n        target = self.package.target.position\n        join = self.package.waypoints.join\n        ip = self.package.waypoints.ingress\n        return HoldZoneGeometry(\n            target, origin, ip, join, self.coalition, self.theater\n        ).find_best_hold_point()\n\n    def build(self, dump_debug_info: bool = False) -> SweepFlightPlan:\n        return SweepFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/sead.py", "content": "from __future__ import annotations\n\nfrom datetime import timedelta\nfrom typing import Type\n\nfrom .formationattack import (\n    FormationAttackBuilder,\n    FormationAttackFlightPlan,\n    FormationAttackLayout,\n)\nfrom ..flightwaypointtype import FlightWaypointType\n\n\nclass SeadFlightPlan(FormationAttackFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    def default_tot_offset(self) -> timedelta:\n        return -timedelta(minutes=1)\n\n\nclass Builder(FormationAttackBuilder[SeadFlightPlan, FormationAttackLayout]):\n    def layout(self) -> FormationAttackLayout:\n        return self._build(FlightWaypointType.INGRESS_SEAD)\n\n    def build(self, dump_debug_info: bool = False) -> SeadFlightPlan:\n        return SeadFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/invalidobjectivelocation.py", "content": "from __future__ import annotations\n\nfrom game.ato import FlightType\nfrom game.ato.flightplans.planningerror import PlanningError\nfrom game.theater import MissionTarget\n\n\nclass InvalidObjectiveLocation(PlanningError):\n    \"\"\"Raised when the objective location is invalid for the mission type.\"\"\"\n\n    def __init__(self, task: FlightType, location: MissionTarget) -> None:\n        super().__init__(f\"{location.name} is not valid for {task} missions.\")\n"}
{"type": "source_file", "path": "game/ato/flightplans/custom.py", "content": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING, Type\n\nfrom .flightplan import FlightPlan, Layout\nfrom .ibuilder import IBuilder\nfrom .waypointbuilder import WaypointBuilder\nfrom .. import Flight\nfrom ..flightwaypointtype import FlightWaypointType\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass CustomLayout(Layout):\n    custom_waypoints: list[FlightWaypoint]\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield from self.custom_waypoints\n\n\nclass CustomFlightPlan(FlightPlan[CustomLayout]):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        target_types = (\n            FlightWaypointType.PATROL_TRACK,\n            FlightWaypointType.TARGET_GROUP_LOC,\n            FlightWaypointType.TARGET_POINT,\n            FlightWaypointType.TARGET_SHIP,\n        )\n        for waypoint in self.waypoints:\n            if waypoint in target_types:\n                return waypoint\n        return self.layout.departure\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.tot_waypoint:\n            return self.package.time_over_target\n        return None\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        return None\n\n    @property\n    def mission_begin_on_station_time(self) -> datetime | None:\n        return None\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        return self.package.time_over_target\n\n\nclass Builder(IBuilder[CustomFlightPlan, CustomLayout]):\n    def __init__(\n        self, flight: Flight, waypoints: list[FlightWaypoint] | None = None\n    ) -> None:\n        super().__init__(flight)\n        if waypoints is None:\n            waypoints = []\n        self.waypoints = waypoints\n\n    def layout(self) -> CustomLayout:\n        builder = WaypointBuilder(self.flight, self.coalition)\n        return CustomLayout(builder.takeoff(self.flight.departure), self.waypoints)\n\n    def build(self, dump_debug_info: bool = False) -> CustomFlightPlan:\n        return CustomFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/flightplanbuildertypes.py", "content": "from __future__ import annotations\n\nfrom typing import Any, TYPE_CHECKING, Type\n\nfrom game.ato import FlightType\nfrom game.theater.controlpoint import NavalControlPoint\nfrom game.theater.frontline import FrontLine\nfrom .aewc import AewcFlightPlan\nfrom .airassault import AirAssaultFlightPlan\nfrom .airlift import AirliftFlightPlan\nfrom .antiship import AntiShipFlightPlan\nfrom .bai import BaiFlightPlan\nfrom .barcap import BarCapFlightPlan\nfrom .cas import CasFlightPlan\nfrom .dead import DeadFlightPlan\nfrom .escort import EscortFlightPlan\nfrom .ferry import FerryFlightPlan\nfrom .ibuilder import IBuilder\nfrom .ocaaircraft import OcaAircraftFlightPlan\nfrom .ocarunway import OcaRunwayFlightPlan\nfrom .packagerefueling import PackageRefuelingFlightPlan\nfrom .planningerror import PlanningError\nfrom .sead import SeadFlightPlan\nfrom .shiprecoverytanker import RecoveryTankerFlightPlan\nfrom .strike import StrikeFlightPlan\nfrom .sweep import SweepFlightPlan\nfrom .tarcap import TarCapFlightPlan\nfrom .theaterrefueling import TheaterRefuelingFlightPlan\n\nif TYPE_CHECKING:\n    from game.ato import Flight\n\n\nclass FlightPlanBuilderTypes:\n    @staticmethod\n    def for_flight(flight: Flight) -> Type[IBuilder[Any, Any]]:\n        if flight.flight_type is FlightType.REFUELING:\n            target = flight.package.target\n            if target.is_friendly(flight.squadron.player) and isinstance(\n                target, NavalControlPoint\n            ):\n                return RecoveryTankerFlightPlan.builder_type()\n            if target.is_friendly(flight.squadron.player) or isinstance(\n                target, FrontLine\n            ):\n                return TheaterRefuelingFlightPlan.builder_type()\n            return PackageRefuelingFlightPlan.builder_type()\n\n        builder_dict: dict[FlightType, Type[IBuilder[Any, Any]]] = {\n            FlightType.ANTISHIP: AntiShipFlightPlan.builder_type(),\n            FlightType.BAI: BaiFlightPlan.builder_type(),\n            FlightType.BARCAP: BarCapFlightPlan.builder_type(),\n            FlightType.CAS: CasFlightPlan.builder_type(),\n            FlightType.DEAD: DeadFlightPlan.builder_type(),\n            FlightType.ESCORT: EscortFlightPlan.builder_type(),\n            FlightType.OCA_AIRCRAFT: OcaAircraftFlightPlan.builder_type(),\n            FlightType.OCA_RUNWAY: OcaRunwayFlightPlan.builder_type(),\n            FlightType.SEAD: SeadFlightPlan.builder_type(),\n            FlightType.SEAD_ESCORT: EscortFlightPlan.builder_type(),\n            FlightType.STRIKE: StrikeFlightPlan.builder_type(),\n            FlightType.SWEEP: SweepFlightPlan.builder_type(),\n            FlightType.TARCAP: TarCapFlightPlan.builder_type(),\n            FlightType.AEWC: AewcFlightPlan.builder_type(),\n            FlightType.TRANSPORT: AirliftFlightPlan.builder_type(),\n            FlightType.FERRY: FerryFlightPlan.builder_type(),\n            FlightType.AIR_ASSAULT: AirAssaultFlightPlan.builder_type(),\n        }\n        try:\n            return builder_dict[flight.flight_type]\n        except KeyError as ex:\n            raise PlanningError(\n                f\"{flight.flight_type} flight plan generation not implemented\"\n            ) from ex\n"}
{"type": "source_file", "path": "game/ato/flightplans/ferry.py", "content": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING, Type\n\nfrom game.utils import feet\nfrom .ibuilder import IBuilder\nfrom .planningerror import PlanningError\nfrom .standard import StandardFlightPlan, StandardLayout\nfrom .waypointbuilder import WaypointBuilder\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass FerryLayout(StandardLayout):\n    nav_to_destination: list[FlightWaypoint]\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield from self.nav_to_destination\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nclass FerryFlightPlan(StandardFlightPlan[FerryLayout]):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        return self.layout.arrival\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        # TOT planning isn't really useful for ferries. They're behind the front\n        # lines so no need to wait for escorts or for other missions to complete.\n        return None\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        return None\n\n    @property\n    def mission_begin_on_station_time(self) -> datetime | None:\n        return None\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        return self.package.time_over_target\n\n\nclass Builder(IBuilder[FerryFlightPlan, FerryLayout]):\n    def layout(self) -> FerryLayout:\n        if self.flight.departure == self.flight.arrival:\n            raise PlanningError(\n                f\"Cannot plan ferry self.flight: departure and arrival are both \"\n                f\"{self.flight.departure}\"\n            )\n\n        altitude_is_agl = self.flight.unit_type.dcs_unit_type.helicopter\n        altitude = (\n            feet(1500)\n            if altitude_is_agl\n            else self.flight.unit_type.preferred_patrol_altitude\n        )\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n        return FerryLayout(\n            departure=builder.takeoff(self.flight.departure),\n            nav_to_destination=builder.nav_path(\n                self.flight.departure.position,\n                self.flight.arrival.position,\n                altitude,\n                altitude_is_agl,\n            ),\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> FerryFlightPlan:\n        return FerryFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/capbuilder.py", "content": "from __future__ import annotations\n\nimport copy\nimport random\nfrom abc import ABC\nfrom typing import Any, TYPE_CHECKING, TypeVar\n\nfrom dcs import Point\nfrom shapely.geometry import Point as ShapelyPoint\n\nfrom game.utils import Heading, meters, nautical_miles\nfrom .flightplan import FlightPlan\nfrom .patrolling import PatrollingLayout\nfrom ..closestairfields import ObjectiveDistanceCache\nfrom ..flightplans.ibuilder import IBuilder\nfrom ..flightplans.planningerror import PlanningError\n\nif TYPE_CHECKING:\n    from game.theater import MissionTarget\n\nFlightPlanT = TypeVar(\"FlightPlanT\", bound=FlightPlan[Any])\nLayoutT = TypeVar(\"LayoutT\", bound=PatrollingLayout)\n\n\nclass CapBuilder(IBuilder[FlightPlanT, LayoutT], ABC):\n    def cap_racetrack_for_objective(\n        self, location: MissionTarget, barcap: bool\n    ) -> tuple[Point, Point]:\n        closest_cache = ObjectiveDistanceCache.get_closest_airfields(location)\n        closest_friendly_field = (\n            None  # keep track of closest frieldly airfield in case we need it\n        )\n        for airfield in closest_cache.operational_airfields:\n            # If the mission is a BARCAP of an enemy airfield, find the *next*\n            # closest enemy airfield.\n            if airfield == self.package.target:\n                continue\n            if airfield.captured != self.is_player:\n                closest_airfield = airfield\n                break\n            elif closest_friendly_field is None:\n                closest_friendly_field = airfield\n        else:\n            if barcap:\n                # If planning a BARCAP, we should be able to find at least one enemy\n                # airfield. If we can't, it's an error.\n                raise PlanningError(\"Could not find any enemy airfields\")\n            else:\n                # if we cannot find any friendly or enemy airfields other than the target,\n                # there's nothing we can do\n                if closest_friendly_field is None:\n                    raise PlanningError(\n                        \"Could not find any enemy or friendly airfields\"\n                    )\n\n                # If planning other race tracks (TARCAPs, currently), the target may be\n                # the only enemy airfield. In this case, set the race track orientation using\n                # a virtual point equi-distant from but opposite to the target from the closest\n                # friendly airfield like below, where F is the closest friendly airfield, T is\n                # the sole enemy airfield and V the virtual point\n                #\n                # F ---- T ----- V\n                #\n                # We need to create this virtual point, rather than using F to make sure\n                # the race track is aligned towards the target.\n                closest_friendly_field_position = copy.deepcopy(\n                    closest_friendly_field.position\n                )\n                closest_airfield = closest_friendly_field\n                closest_airfield.position.x = (\n                    2 * self.package.target.position.x\n                    - closest_friendly_field_position.x\n                )\n                closest_airfield.position.y = (\n                    2 * self.package.target.position.y\n                    - closest_friendly_field_position.y\n                )\n\n        heading = Heading.from_degrees(\n            location.position.heading_between_point(closest_airfield.position)\n        )\n\n        position = ShapelyPoint(\n            self.package.target.position.x, self.package.target.position.y\n        )\n\n        if barcap:\n            # BARCAPs should remain far enough back from the enemy that their\n            # commit range does not enter the enemy's threat zone. Include a 5nm\n            # buffer.\n            distance_to_no_fly = (\n                meters(position.distance(self.threat_zones.all))\n                - self.doctrine.cap.engagement_range\n                - nautical_miles(5)\n            )\n            max_track_length = self.doctrine.cap.max_track_length\n        else:\n            # Other race tracks (TARCAPs, currently) just try to keep some\n            # distance from the nearest enemy airbase, but since they are by\n            # definition in enemy territory they can't avoid the threat zone\n            # without being useless.\n            min_distance_from_enemy = nautical_miles(20)\n            distance_to_airfield = meters(\n                closest_airfield.position.distance_to_point(\n                    self.package.target.position\n                )\n            )\n            distance_to_no_fly = distance_to_airfield - min_distance_from_enemy\n\n            # TARCAPs fly short racetracks because they need to react faster.\n            max_track_length = self.doctrine.cap.min_track_length + 0.3 * (\n                self.doctrine.cap.max_track_length - self.doctrine.cap.min_track_length\n            )\n\n        min_cap_distance = min(\n            self.doctrine.cap.min_distance_from_cp, distance_to_no_fly\n        )\n        max_cap_distance = min(\n            self.doctrine.cap.max_distance_from_cp, distance_to_no_fly\n        )\n\n        end = location.position.point_from_heading(\n            heading.degrees,\n            random.randint(int(min_cap_distance.meters), int(max_cap_distance.meters)),\n        )\n\n        track_length = random.randint(\n            int(self.doctrine.cap.min_track_length.meters),\n            int(max_track_length.meters),\n        )\n        start = end.point_from_heading(heading.opposite.degrees, track_length)\n        return start, end\n"}
{"type": "source_file", "path": "game/ato/flightplans/theaterrefueling.py", "content": "from __future__ import annotations\n\nfrom datetime import timedelta\nfrom typing import Type\n\nfrom game.utils import Heading, feet, meters, nautical_miles\nfrom .ibuilder import IBuilder\nfrom .patrolling import PatrollingLayout\nfrom .refuelingflightplan import RefuelingFlightPlan\nfrom .waypointbuilder import WaypointBuilder\n\n\nclass TheaterRefuelingFlightPlan(RefuelingFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def patrol_duration(self) -> timedelta:\n        # Add 30 minutes to desired_player_mission_duration as TOTs for flights\n        # can sit up to this time. This extension means the tanker remains on\n        # station for the flights' return.\n        return (\n            self.flight.coalition.game.settings.desired_player_mission_duration\n            + timedelta(minutes=30)\n        )\n\n\nclass Builder(IBuilder[TheaterRefuelingFlightPlan, PatrollingLayout]):\n    def layout(self) -> PatrollingLayout:\n        racetrack_half_distance = nautical_miles(20).meters\n\n        location = self.package.target\n\n        closest_boundary = self.threat_zones.closest_boundary(location.position)\n        heading_to_threat_boundary = Heading.from_degrees(\n            location.position.heading_between_point(closest_boundary)\n        )\n        distance_to_threat = meters(\n            location.position.distance_to_point(closest_boundary)\n        )\n        orbit_heading = heading_to_threat_boundary\n\n        # Station 70nm outside the threat zone.\n        threat_buffer = nautical_miles(70)\n        if self.threat_zones.threatened(location.position):\n            orbit_distance = distance_to_threat + threat_buffer\n        else:\n            orbit_distance = distance_to_threat - threat_buffer\n\n        racetrack_center = location.position.point_from_heading(\n            orbit_heading.degrees, orbit_distance.meters\n        )\n\n        racetrack_start = racetrack_center.point_from_heading(\n            orbit_heading.right.degrees, racetrack_half_distance\n        )\n\n        racetrack_end = racetrack_center.point_from_heading(\n            orbit_heading.left.degrees, racetrack_half_distance\n        )\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n\n        tanker_type = self.flight.unit_type\n        if tanker_type.patrol_altitude is not None:\n            altitude = tanker_type.patrol_altitude\n        else:\n            altitude = feet(21000)\n\n        racetrack = builder.race_track(racetrack_start, racetrack_end, altitude)\n\n        return PatrollingLayout(\n            departure=builder.takeoff(self.flight.departure),\n            nav_to=builder.nav_path(\n                self.flight.departure.position, racetrack_start, altitude\n            ),\n            nav_from=builder.nav_path(\n                racetrack_end, self.flight.arrival.position, altitude\n            ),\n            patrol_start=racetrack[0],\n            patrol_end=racetrack[1],\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> TheaterRefuelingFlightPlan:\n        return TheaterRefuelingFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/flightplan.py", "content": "\"\"\"Flight plan generation.\n\nFlights are first planned generically by either the player or by the\nMissionPlanner. Those only plan basic information like the objective, aircraft\ntype, and the size of the flight. The FlightPlanBuilder is responsible for\ngenerating the waypoints for the mission.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom typing import Any, Generic, TYPE_CHECKING, TypeGuard, TypeVar\n\nfrom game.typeguard import self_type_guard\nfrom game.utils import Distance, Speed, meters\nfrom .planningerror import PlanningError\nfrom ..flightwaypointtype import FlightWaypointType\nfrom ..starttype import StartType\nfrom ..traveltime import GroundSpeed\n\nif TYPE_CHECKING:\n    from game.theater import ControlPoint\n    from ..flight import Flight\n    from ..flightwaypoint import FlightWaypoint\n    from ..package import Package\n    from .formation import FormationFlightPlan\n    from .loiter import LoiterFlightPlan\n    from .patrolling import PatrollingFlightPlan\n\n\n@dataclass(frozen=True)\nclass Layout(ABC):\n    departure: FlightWaypoint\n\n    @property\n    def waypoints(self) -> list[FlightWaypoint]:\n        \"\"\"A list of all waypoints in the flight plan, in order.\"\"\"\n        return list(self.iter_waypoints())\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        \"\"\"Iterates over all waypoints in the flight plan, in order.\"\"\"\n        raise NotImplementedError\n\n\nLayoutT = TypeVar(\"LayoutT\", bound=Layout)\n\n\nclass FlightPlan(ABC, Generic[LayoutT]):\n    def __init__(self, flight: Flight, layout: LayoutT) -> None:\n        self.flight = flight\n        self.layout = layout\n        self.tot_offset = self.default_tot_offset()\n\n    @property\n    def package(self) -> Package:\n        return self.flight.package\n\n    @property\n    def waypoints(self) -> list[FlightWaypoint]:\n        \"\"\"A list of all waypoints in the flight plan, in order.\"\"\"\n        return list(self.iter_waypoints())\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        \"\"\"Iterates over all waypoints in the flight plan, in order.\"\"\"\n        yield from self.layout.iter_waypoints()\n\n    def edges(\n        self, until: FlightWaypoint | None = None\n    ) -> Iterator[tuple[FlightWaypoint, FlightWaypoint]]:\n        \"\"\"A list of all paths between waypoints, in order.\"\"\"\n        waypoints = self.waypoints\n        if until is None:\n            last_index = len(waypoints)\n        else:\n            last_index = waypoints.index(until) + 1\n\n        return zip(self.waypoints[:last_index], self.waypoints[1:last_index])\n\n    def best_speed_between_waypoints(\n        self, a: FlightWaypoint, b: FlightWaypoint\n    ) -> Speed:\n        \"\"\"Desired ground speed between points a and b.\"\"\"\n        factor = 1.0\n        if b.waypoint_type == FlightWaypointType.ASCEND_POINT:\n            # Flights that start airborne already have some altitude and a good\n            # amount of speed.\n            factor = 0.5\n        elif b.waypoint_type == FlightWaypointType.LOITER:\n            # On the way to the hold point the AI won't climb unless they're in\n            # formation, so slowing down the flight lead gives them more time to\n            # form up and climb.\n            # https://forums.eagle.ru/forum/english/digital-combat-simulator/dcs-world-2-5/dcs-wishlist-aa/7121300-ai-flights-will-not-climb-to-hold-point-because-wingman-not-joined\n            #\n            # Plus, it's a loiter point so there's no reason to hurry.\n            factor = 0.75\n        # TODO: Adjust if AGL.\n        # We don't have an exact heightmap, but we should probably be performing\n        # *some* adjustment for NTTR since the minimum altitude of the map is\n        # near 2000 ft MSL.\n        return GroundSpeed.for_flight(self.flight, min(a.alt, b.alt)) * factor\n\n    def speed_between_waypoints(self, a: FlightWaypoint, b: FlightWaypoint) -> Speed:\n        return self.best_speed_between_waypoints(a, b)\n\n    @property\n    def combat_speed_waypoints(self) -> set[FlightWaypoint]:\n        return set()\n\n    def fuel_consumption_between_points(\n        self, a: FlightWaypoint, b: FlightWaypoint\n    ) -> float | None:\n        ppm = self.fuel_rate_to_between_points(a, b)\n        if ppm is None:\n            return None\n        distance = meters(a.position.distance_to_point(b.position))\n        return distance.nautical_miles * ppm\n\n    def fuel_rate_to_between_points(\n        self, a: FlightWaypoint, b: FlightWaypoint\n    ) -> float | None:\n        if self.flight.unit_type.fuel_consumption is None:\n            return None\n        if a.waypoint_type is FlightWaypointType.TAKEOFF:\n            return self.flight.unit_type.fuel_consumption.climb\n        if b in self.combat_speed_waypoints:\n            return self.flight.unit_type.fuel_consumption.combat\n        return self.flight.unit_type.fuel_consumption.cruise\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        \"\"\"The waypoint that is associated with the package TOT, or None.\n\n        Note that the only flight plans that should have no target waypoints are\n        user-planned missions without any useful waypoints and flight plans that\n        failed to generate. Nevertheless, we have to defend against it.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def tot(self) -> datetime:\n        return self.package.time_over_target + self.tot_offset\n\n    def max_distance_from(self, cp: ControlPoint) -> Distance:\n        \"\"\"Returns the farthest waypoint of the flight plan from a ControlPoint.\n        :arg cp The ControlPoint to measure distance from.\n        \"\"\"\n        if not self.waypoints:\n            return meters(0)\n        return max(\n            [meters(cp.position.distance_to_point(w.position)) for w in self.waypoints]\n        )\n\n    def default_tot_offset(self) -> timedelta:\n        \"\"\"This flight's offset from the package's TOT.\n\n        Positive values represent later TOTs. An offset of -2 minutes is used\n        for a flight that has a TOT 2 minutes before the rest of the package.\n        \"\"\"\n        return timedelta()\n\n    def _travel_time_to_waypoint(self, destination: FlightWaypoint) -> timedelta:\n        total = timedelta()\n\n        if destination not in self.waypoints:\n            raise PlanningError(\n                f\"Did not find destination waypoint {destination} in \"\n                f\"waypoints for {self.flight}\"\n            )\n\n        for previous_waypoint, waypoint in self.edges(until=destination):\n            total += self.total_time_between_waypoints(previous_waypoint, waypoint)\n\n        # Trim microseconds. Our simulation tick rate is 1 second, so anything that\n        # takes 100.1 or 100.9 seconds will take 100 seconds. DCS doesn't handle\n        # sub-second resolution for tasks anyway, nor are they interesting from a\n        # mission planning perspective, so there's little value to keeping them in the\n        # model.\n        return timedelta(seconds=math.floor(total.total_seconds()))\n\n    def total_time_between_waypoints(\n        self, a: FlightWaypoint, b: FlightWaypoint\n    ) -> timedelta:\n        \"\"\"Returns the total time spent between a and b.\n\n        The total time between waypoints differs from the travel time in that it may\n        include additional time for actions such as loitering.\n        \"\"\"\n        return self.travel_time_between_waypoints(a, b)\n\n    def travel_time_between_waypoints(\n        self, a: FlightWaypoint, b: FlightWaypoint\n    ) -> timedelta:\n        error_factor = 1.05\n        speed = self.speed_between_waypoints(a, b)\n        distance = meters(a.position.distance_to_point(b.position))\n        return timedelta(hours=distance.nautical_miles / speed.knots * error_factor)\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        raise NotImplementedError\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        raise NotImplementedError\n\n    def request_escort_at(self) -> FlightWaypoint | None:\n        try:\n            return next(self.escorted_waypoints())\n        except StopIteration:\n            return None\n\n    def dismiss_escort_at(self) -> FlightWaypoint | None:\n        try:\n            return list(self.escorted_waypoints())[-1]\n        except IndexError:\n            return None\n\n    def escorted_waypoints(self) -> Iterator[FlightWaypoint]:\n        for waypoint in self.iter_waypoints():\n            if waypoint.wants_escort:\n                yield waypoint\n\n    def takeoff_time(self) -> datetime:\n        return self.tot - self._travel_time_to_waypoint(self.tot_waypoint)\n\n    def minimum_duration_from_start_to_tot(self) -> timedelta:\n        return (\n            self._travel_time_to_waypoint(self.tot_waypoint)\n            + self.estimate_startup()\n            + self.estimate_ground_ops()\n        )\n\n    def startup_time(self) -> datetime:\n        return (\n            self.takeoff_time() - self.estimate_startup() - self.estimate_ground_ops()\n        )\n\n    def estimate_startup(self) -> timedelta:\n        if self.flight.start_type is StartType.COLD:\n            if self.flight.client_count:\n                return timedelta(minutes=10)\n            else:\n                # The AI doesn't seem to have a real startup procedure.\n                return timedelta(minutes=2)\n        return timedelta()\n\n    def estimate_ground_ops(self) -> timedelta:\n        if self.flight.start_type in {StartType.RUNWAY, StartType.IN_FLIGHT}:\n            return timedelta()\n        if self.flight.departure.is_fleet:\n            return timedelta(minutes=2)\n        else:\n            return timedelta(minutes=8)\n\n    @property\n    @abstractmethod\n    def mission_begin_on_station_time(self) -> datetime | None:\n        \"\"\"The time that the mission is first on-station.\n\n        Not all mission types will have a time when they can be considered on-station.\n        Missions that patrol or loiter (CAPs, CAS, refueling, AEW&C, etc) will have this\n        defined, but strike-like missions will not.\n        \"\"\"\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        \"\"\"The time that the mission is complete and the flight RTBs.\"\"\"\n        raise NotImplementedError\n\n    @self_type_guard\n    def is_loiter(\n        self, flight_plan: FlightPlan[Any]\n    ) -> TypeGuard[LoiterFlightPlan[Any]]:\n        return False\n\n    @self_type_guard\n    def is_patrol(\n        self, flight_plan: FlightPlan[Any]\n    ) -> TypeGuard[PatrollingFlightPlan[Any]]:\n        return False\n\n    @self_type_guard\n    def is_formation(\n        self, flight_plan: FlightPlan[Any]\n    ) -> TypeGuard[FormationFlightPlan[Any]]:\n        return False\n\n    def add_waypoint_actions(self) -> None:\n        pass\n"}
{"type": "source_file", "path": "game/ato/flightplans/barcap.py", "content": "from __future__ import annotations\n\nimport random\nfrom datetime import timedelta\nfrom typing import Type\n\nfrom game.theater import FrontLine\nfrom game.utils import Distance, Speed, feet\nfrom .capbuilder import CapBuilder\nfrom .invalidobjectivelocation import InvalidObjectiveLocation\nfrom .patrolling import PatrollingFlightPlan, PatrollingLayout\nfrom .waypointbuilder import WaypointBuilder\n\n\nclass BarCapFlightPlan(PatrollingFlightPlan[PatrollingLayout]):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def patrol_duration(self) -> timedelta:\n        return self.flight.coalition.doctrine.cap.duration\n\n    @property\n    def patrol_speed(self) -> Speed:\n        return self.flight.unit_type.preferred_patrol_speed(\n            self.layout.patrol_start.alt\n        )\n\n    @property\n    def engagement_distance(self) -> Distance:\n        return self.flight.coalition.doctrine.cap.engagement_range\n\n\nclass Builder(CapBuilder[BarCapFlightPlan, PatrollingLayout]):\n    def layout(self) -> PatrollingLayout:\n        location = self.package.target\n\n        if isinstance(location, FrontLine):\n            raise InvalidObjectiveLocation(self.flight.flight_type, location)\n\n        start_pos, end_pos = self.cap_racetrack_for_objective(location, barcap=True)\n\n        preferred_alt = self.flight.unit_type.preferred_patrol_altitude\n        randomized_alt = preferred_alt + feet(random.randint(-2, 1) * 1000)\n        patrol_alt = max(\n            self.doctrine.cap.min_patrol_altitude,\n            min(self.doctrine.cap.max_patrol_altitude, randomized_alt),\n        )\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n        start, end = builder.race_track(start_pos, end_pos, patrol_alt)\n\n        return PatrollingLayout(\n            departure=builder.takeoff(self.flight.departure),\n            nav_to=builder.nav_path(\n                self.flight.departure.position, start.position, patrol_alt\n            ),\n            nav_from=builder.nav_path(\n                end.position, self.flight.arrival.position, patrol_alt\n            ),\n            patrol_start=start,\n            patrol_end=end,\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> BarCapFlightPlan:\n        return BarCapFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/dead.py", "content": "from __future__ import annotations\n\nimport logging\nfrom typing import Type\n\nfrom game.theater.theatergroundobject import (\n    EwrGroundObject,\n    SamGroundObject,\n)\nfrom .formationattack import (\n    FormationAttackBuilder,\n    FormationAttackFlightPlan,\n    FormationAttackLayout,\n)\nfrom .invalidobjectivelocation import InvalidObjectiveLocation\nfrom ..flightwaypointtype import FlightWaypointType\n\n\nclass DeadFlightPlan(FormationAttackFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n\nclass Builder(FormationAttackBuilder[DeadFlightPlan, FormationAttackLayout]):\n    def layout(self) -> FormationAttackLayout:\n        location = self.package.target\n\n        is_ewr = isinstance(location, EwrGroundObject)\n        is_sam = isinstance(location, SamGroundObject)\n        if not is_ewr and not is_sam:\n            logging.exception(\n                f\"Invalid Objective Location for DEAD flight {self.flight=} at \"\n                f\"{location=}\"\n            )\n            raise InvalidObjectiveLocation(self.flight.flight_type, location)\n\n        return self._build(FlightWaypointType.INGRESS_DEAD)\n\n    def build(self, dump_debug_info: bool = False) -> DeadFlightPlan:\n        return DeadFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/strike.py", "content": "from __future__ import annotations\n\nfrom typing import Type\n\nfrom game.theater import TheaterGroundObject\nfrom .formationattack import (\n    FormationAttackBuilder,\n    FormationAttackFlightPlan,\n    FormationAttackLayout,\n)\nfrom .invalidobjectivelocation import InvalidObjectiveLocation\nfrom .waypointbuilder import StrikeTarget\nfrom ..flightwaypointtype import FlightWaypointType\n\n\nclass StrikeFlightPlan(FormationAttackFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n\nclass Builder(FormationAttackBuilder[StrikeFlightPlan, FormationAttackLayout]):\n    def layout(self) -> FormationAttackLayout:\n        location = self.package.target\n\n        if not isinstance(location, TheaterGroundObject):\n            raise InvalidObjectiveLocation(self.flight.flight_type, location)\n\n        targets: list[StrikeTarget] = []\n        for idx, unit in enumerate(location.strike_targets):\n            targets.append(StrikeTarget(f\"{unit.type.id} #{idx}\", unit))\n\n        return self._build(FlightWaypointType.INGRESS_STRIKE, targets)\n\n    def build(self, dump_debug_info: bool = False) -> StrikeFlightPlan:\n        return StrikeFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/tarcap.py", "content": "from __future__ import annotations\n\nimport random\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom typing import TYPE_CHECKING, Type\n\nfrom game.utils import Distance, Speed, feet\nfrom .capbuilder import CapBuilder\nfrom .patrolling import PatrollingFlightPlan, PatrollingLayout\nfrom .waypointbuilder import WaypointBuilder\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass TarCapLayout(PatrollingLayout):\n    refuel: FlightWaypoint | None\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield from self.nav_to\n        yield self.patrol_start\n        yield self.patrol_end\n        if self.refuel is not None:\n            yield self.refuel\n        yield from self.nav_from\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nclass TarCapFlightPlan(PatrollingFlightPlan[TarCapLayout]):\n    @property\n    def patrol_duration(self) -> timedelta:\n        # Note that this duration only has an effect if there are no\n        # flights in the package that have requested escort. If the package\n        # requests an escort the CAP self.flight will remain on station for the\n        # duration of the escorted mission, or until it is winchester/bingo.\n        return self.flight.coalition.doctrine.cap.duration\n\n    @property\n    def patrol_speed(self) -> Speed:\n        return self.flight.unit_type.preferred_patrol_speed(\n            self.layout.patrol_start.alt\n        )\n\n    @property\n    def engagement_distance(self) -> Distance:\n        return self.flight.coalition.doctrine.cap.engagement_range\n\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def combat_speed_waypoints(self) -> set[FlightWaypoint]:\n        return {self.layout.patrol_start, self.layout.patrol_end}\n\n    def default_tot_offset(self) -> timedelta:\n        return -timedelta(minutes=2)\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.layout.patrol_end:\n            return self.patrol_end_time\n        return super().depart_time_for_waypoint(waypoint)\n\n    @property\n    def patrol_start_time(self) -> datetime:\n        start = self.package.escort_start_time\n        if start is not None:\n            return start + self.tot_offset\n        return self.tot\n\n    @property\n    def patrol_end_time(self) -> datetime:\n        end = self.package.escort_end_time\n        if end is not None:\n            return end\n        return super().patrol_end_time\n\n\nclass Builder(CapBuilder[TarCapFlightPlan, TarCapLayout]):\n    def layout(self) -> TarCapLayout:\n        location = self.package.target\n\n        preferred_alt = self.flight.unit_type.preferred_patrol_altitude\n        randomized_alt = preferred_alt + feet(random.randint(-2, 1) * 1000)\n        patrol_alt = max(\n            self.doctrine.cap.min_patrol_altitude,\n            min(self.doctrine.cap.max_patrol_altitude, randomized_alt),\n        )\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n        orbit0p, orbit1p = self.cap_racetrack_for_objective(location, barcap=False)\n\n        start, end = builder.race_track(orbit0p, orbit1p, patrol_alt)\n\n        refuel = None\n        nav_from_origin = orbit1p\n\n        if self.package.waypoints is not None:\n            refuel = builder.refuel(self.package.waypoints.refuel)\n            nav_from_origin = refuel.position\n\n        return TarCapLayout(\n            departure=builder.takeoff(self.flight.departure),\n            nav_to=builder.nav_path(\n                self.flight.departure.position, orbit0p, patrol_alt\n            ),\n            nav_from=builder.nav_path(\n                nav_from_origin, self.flight.arrival.position, patrol_alt\n            ),\n            patrol_start=start,\n            patrol_end=end,\n            refuel=refuel,\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> TarCapFlightPlan:\n        return TarCapFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/cas.py", "content": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\nfrom datetime import timedelta\nfrom typing import TYPE_CHECKING, Type\n\nfrom game.theater import FrontLine\nfrom game.utils import Distance, Speed, kph, meters, dcs_to_shapely_point\nfrom .ibuilder import IBuilder\nfrom .invalidobjectivelocation import InvalidObjectiveLocation\nfrom .patrolling import PatrollingFlightPlan, PatrollingLayout\nfrom .uizonedisplay import UiZone, UiZoneDisplay\nfrom .waypointbuilder import WaypointBuilder\nfrom ..flightwaypointtype import FlightWaypointType\nfrom ...flightplan.ipsolver import IpSolver\nfrom ...persistence.paths import waypoint_debug_directory\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass CasLayout(PatrollingLayout):\n    ingress: FlightWaypoint\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield from self.nav_to\n        yield self.ingress\n        yield self.patrol_start\n        yield self.patrol_end\n        yield from self.nav_from\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nclass CasFlightPlan(PatrollingFlightPlan[CasLayout], UiZoneDisplay):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def patrol_duration(self) -> timedelta:\n        return self.flight.coalition.doctrine.cas.duration\n\n    @property\n    def patrol_speed(self) -> Speed:\n        # 2021-08-02: patrol_speed will currently have no effect because\n        # CAS doesn't use OrbitAction. But all PatrollingFlightPlan are expected\n        # to have patrol_speed\n        return kph(0)\n\n    @property\n    def engagement_distance(self) -> Distance:\n        from game.missiongenerator.frontlineconflictdescription import FRONTLINE_LENGTH\n\n        return meters(FRONTLINE_LENGTH) / 2\n\n    @property\n    def combat_speed_waypoints(self) -> set[FlightWaypoint]:\n        return {self.layout.ingress, self.layout.patrol_start, self.layout.patrol_end}\n\n    def ui_zone(self) -> UiZone:\n        midpoint = (\n            self.layout.patrol_start.position + self.layout.patrol_end.position\n        ) / 2\n        return UiZone(\n            [midpoint],\n            self.engagement_distance,\n        )\n\n\nclass Builder(IBuilder[CasFlightPlan, CasLayout]):\n    def layout(self, dump_debug_info: bool) -> CasLayout:\n        location = self.package.target\n\n        if not isinstance(location, FrontLine):\n            raise InvalidObjectiveLocation(self.flight.flight_type, location)\n\n        from game.missiongenerator.frontlineconflictdescription import (\n            FrontLineConflictDescription,\n        )\n\n        bounds = FrontLineConflictDescription.frontline_bounds(location, self.theater)\n        patrol_start = bounds.left_position\n        patrol_end = bounds.right_position\n\n        start_distance = patrol_start.distance_to_point(self.flight.departure.position)\n        end_distance = patrol_end.distance_to_point(self.flight.departure.position)\n        if end_distance < start_distance:\n            patrol_start, patrol_end = patrol_end, patrol_start\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n\n        is_helo = self.flight.unit_type.dcs_unit_type.helicopter\n        patrol_altitude = self.doctrine.resolve_combat_altitude(is_helo)\n        use_agl_patrol_altitude = is_helo\n\n        ip_solver = IpSolver(\n            dcs_to_shapely_point(self.flight.departure.position),\n            dcs_to_shapely_point(patrol_start),\n            self.doctrine,\n            self.threat_zones.all,\n        )\n        ip_solver.set_debug_properties(\n            waypoint_debug_directory() / \"IP\", self.theater.terrain\n        )\n        ingress_point_shapely = ip_solver.solve()\n        if dump_debug_info:\n            ip_solver.dump_debug_info()\n\n        ingress_point = patrol_start.new_in_same_map(\n            ingress_point_shapely.x, ingress_point_shapely.y\n        )\n\n        patrol_start_waypoint = builder.nav(\n            patrol_start, patrol_altitude, use_agl_patrol_altitude\n        )\n        patrol_start_waypoint.name = \"FLOT START\"\n        patrol_start_waypoint.pretty_name = \"FLOT start\"\n        patrol_start_waypoint.description = \"FLOT boundary\"\n        patrol_start_waypoint.wants_escort = True\n\n        patrol_end_waypoint = builder.nav(\n            patrol_end, patrol_altitude, use_agl_patrol_altitude\n        )\n        patrol_end_waypoint.name = \"FLOT END\"\n        patrol_end_waypoint.pretty_name = \"FLOT end\"\n        patrol_end_waypoint.description = \"FLOT boundary\"\n        patrol_end_waypoint.wants_escort = True\n\n        ingress = builder.ingress(\n            FlightWaypointType.INGRESS_CAS, ingress_point, location\n        )\n        ingress.description = f\"Ingress to provide CAS at {location}\"\n\n        return CasLayout(\n            departure=builder.takeoff(self.flight.departure),\n            nav_to=builder.nav_path(\n                self.flight.departure.position,\n                ingress_point,\n                patrol_altitude,\n                use_agl_patrol_altitude,\n            ),\n            nav_from=builder.nav_path(\n                patrol_end,\n                self.flight.arrival.position,\n                patrol_altitude,\n                use_agl_patrol_altitude,\n            ),\n            ingress=ingress,\n            patrol_start=patrol_start_waypoint,\n            patrol_end=patrol_end_waypoint,\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> CasFlightPlan:\n        return CasFlightPlan(self.flight, self.layout(dump_debug_info))\n"}
{"type": "source_file", "path": "game/ato/flightplans/rtb.py", "content": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING, Type\n\nfrom game.utils import feet\nfrom .ibuilder import IBuilder\nfrom .standard import StandardFlightPlan, StandardLayout\nfrom .waypointbuilder import WaypointBuilder\nfrom ..flightstate import InFlight\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass RtbLayout(StandardLayout):\n    abort_location: FlightWaypoint\n    nav_to_destination: list[FlightWaypoint]\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield self.abort_location\n        yield from self.nav_to_destination\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nclass RtbFlightPlan(StandardFlightPlan[RtbLayout]):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def abort_index(self) -> int:\n        return 1\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        return self.layout.abort_location\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        return None\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        return None\n\n    @property\n    def mission_begin_on_station_time(self) -> datetime | None:\n        return None\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        return self.tot\n\n\nclass Builder(IBuilder[RtbFlightPlan, RtbLayout]):\n    def layout(self) -> RtbLayout:\n        if not isinstance(self.flight.state, InFlight):\n            raise RuntimeError(f\"Cannot abort {self} because it is not in flight\")\n\n        current_position = self.flight.state.estimate_position()\n        current_altitude, altitude_reference = self.flight.state.estimate_altitude()\n\n        altitude_is_agl = self.flight.unit_type.dcs_unit_type.helicopter\n        altitude = (\n            feet(1500)\n            if altitude_is_agl\n            else self.flight.unit_type.preferred_patrol_altitude\n        )\n        builder = WaypointBuilder(self.flight, self.flight.coalition)\n        abort_point = builder.nav(\n            current_position, current_altitude, altitude_reference == \"RADIO\"\n        )\n        abort_point.name = \"ABORT AND RTB\"\n        abort_point.pretty_name = \"Abort and RTB\"\n        abort_point.description = \"Abort mission and return to base\"\n        return RtbLayout(\n            departure=builder.takeoff(self.flight.departure),\n            abort_location=abort_point,\n            nav_to_destination=builder.nav_path(\n                current_position,\n                self.flight.arrival.position,\n                altitude,\n                altitude_is_agl,\n            ),\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> RtbFlightPlan:\n        return RtbFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightroster.py", "content": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom typing import Optional, TYPE_CHECKING\n\nfrom game.ato.iflightroster import IFlightRoster\n\nif TYPE_CHECKING:\n    from game.squadrons import Squadron, Pilot\n\n\nclass FlightRoster(IFlightRoster):\n    def __init__(self, squadron: Squadron, initial_size: int = 0) -> None:\n        self.squadron = squadron\n        self.pilots: list[Optional[Pilot]] = []\n        self.resize(initial_size)\n\n    def iter_pilots(self) -> Iterator[Pilot | None]:\n        yield from self.pilots\n\n    def pilot_at(self, idx: int) -> Pilot | None:\n        return self.pilots[idx]\n\n    @property\n    def max_size(self) -> int:\n        return len(self.pilots)\n\n    def resize(self, new_size: int) -> None:\n        if self.max_size > new_size:\n            self.squadron.return_pilots(\n                [p for p in self.pilots[new_size:] if p is not None]\n            )\n            self.pilots = self.pilots[:new_size]\n            return\n        self.pilots.extend(\n            [\n                self.squadron.claim_available_pilot()\n                for _ in range(new_size - self.max_size)\n            ]\n        )\n\n    def set_pilot(self, index: int, pilot: Optional[Pilot]) -> None:\n        if pilot is not None:\n            self.squadron.claim_pilot(pilot)\n        if (current_pilot := self.pilots[index]) is not None:\n            self.squadron.return_pilot(current_pilot)\n        self.pilots[index] = pilot\n\n    def clear(self) -> None:\n        self.squadron.return_pilots([p for p in self.pilots if p is not None])\n"}
{"type": "source_file", "path": "game/ato/flightplans/waypointbuilder.py", "content": "from __future__ import annotations\n\nimport random\nfrom dataclasses import dataclass\nfrom typing import (\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    TYPE_CHECKING,\n    Tuple,\n    Union,\n)\n\nfrom dcs.mapping import Point, Vector2\n\nfrom game.ato.flightwaypoint import AltitudeReference, FlightWaypoint\nfrom game.ato.flightwaypointtype import FlightWaypointType\nfrom game.theater import (\n    ControlPoint,\n    MissionTarget,\n    OffMapSpawn,\n    TheaterGroundObject,\n    TheaterUnit,\n)\nfrom game.utils import Distance, feet, meters, nautical_miles\n\nif TYPE_CHECKING:\n    from game.coalition import Coalition\n    from game.transfers import MultiGroupTransport\n    from game.theater.theatergroup import TheaterGroup\n    from game.ato.flight import Flight\n\n\n@dataclass(frozen=True)\nclass StrikeTarget:\n    name: str\n    target: Union[TheaterGroundObject, TheaterGroup, TheaterUnit, MultiGroupTransport]\n\n\nclass WaypointBuilder:\n    def __init__(\n        self,\n        flight: Flight,\n        coalition: Coalition,\n        targets: Optional[List[StrikeTarget]] = None,\n    ) -> None:\n        self.flight = flight\n        self.doctrine = coalition.doctrine\n        self.threat_zones = coalition.opponent.threat_zone\n        self.navmesh = coalition.nav_mesh\n        self.targets = targets\n        self._bullseye = coalition.bullseye\n\n    @property\n    def is_helo(self) -> bool:\n        return self.flight.is_helo\n\n    def takeoff(self, departure: ControlPoint) -> FlightWaypoint:\n        \"\"\"Create takeoff waypoint for the given arrival airfield or carrier.\n\n        Note that the takeoff waypoint will automatically be created by pydcs\n        when we create the group, but creating our own before generation makes\n        the planning code simpler.\n\n        Args:\n            departure: Departure airfield or carrier.\n        \"\"\"\n        position = departure.position\n        if isinstance(departure, OffMapSpawn):\n            return FlightWaypoint(\n                \"NAV\",\n                FlightWaypointType.NAV,\n                position,\n                self.doctrine.resolve_rendezvous_altitude(self.is_helo),\n                description=\"Enter theater\",\n                pretty_name=\"Enter theater\",\n            )\n\n        return FlightWaypoint(\n            \"TAKEOFF\",\n            FlightWaypointType.TAKEOFF,\n            position,\n            meters(0),\n            alt_type=\"RADIO\",\n            description=\"Takeoff\",\n            pretty_name=\"Takeoff\",\n        )\n\n    def land(self, arrival: ControlPoint) -> FlightWaypoint:\n        \"\"\"Create descent waypoint for the given arrival airfield or carrier.\n\n        Args:\n            arrival: Arrival airfield or carrier.\n        \"\"\"\n        position = arrival.position\n        if isinstance(arrival, OffMapSpawn):\n            return FlightWaypoint(\n                \"NAV\",\n                FlightWaypointType.NAV,\n                position,\n                self.doctrine.resolve_rendezvous_altitude(self.is_helo),\n                description=\"Exit theater\",\n                pretty_name=\"Exit theater\",\n            )\n\n        return FlightWaypoint(\n            \"LANDING\",\n            FlightWaypointType.LANDING_POINT,\n            position,\n            meters(0),\n            alt_type=\"RADIO\",\n            description=\"Land\",\n            pretty_name=\"Land\",\n            control_point=arrival,\n        )\n\n    def divert(self, divert: Optional[ControlPoint]) -> Optional[FlightWaypoint]:\n        \"\"\"Create divert waypoint for the given arrival airfield or carrier.\n\n        Args:\n            divert: Divert airfield or carrier.\n        \"\"\"\n        if divert is None:\n            return None\n\n        position = divert.position\n        altitude_type: AltitudeReference\n        if isinstance(divert, OffMapSpawn):\n            altitude = self.doctrine.resolve_rendezvous_altitude(self.is_helo)\n            altitude_type = \"BARO\"\n        else:\n            altitude = meters(0)\n            altitude_type = \"RADIO\"\n\n        return FlightWaypoint(\n            \"DIVERT\",\n            FlightWaypointType.DIVERT,\n            position,\n            altitude,\n            alt_type=altitude_type,\n            description=\"Divert\",\n            pretty_name=\"Divert\",\n            only_for_player=True,\n            control_point=divert,\n        )\n\n    def bullseye(self) -> FlightWaypoint:\n        return FlightWaypoint(\n            \"BULLSEYE\",\n            FlightWaypointType.BULLSEYE,\n            self._bullseye.position,\n            meters(0),\n            description=\"Bullseye\",\n            pretty_name=\"Bullseye\",\n            only_for_player=True,\n        )\n\n    def hold(self, position: Point) -> FlightWaypoint:\n        alt_type: AltitudeReference = \"BARO\"\n        if self.is_helo:\n            alt_type = \"RADIO\"\n\n        return FlightWaypoint(\n            \"HOLD\",\n            FlightWaypointType.LOITER,\n            position,\n            self.doctrine.resolve_rendezvous_altitude(self.is_helo),\n            alt_type,\n            description=\"Wait until push time\",\n            pretty_name=\"Hold\",\n        )\n\n    def join(self, position: Point) -> FlightWaypoint:\n        alt_type: AltitudeReference = \"BARO\"\n        if self.is_helo:\n            alt_type = \"RADIO\"\n\n        return FlightWaypoint(\n            \"JOIN\",\n            FlightWaypointType.JOIN,\n            position,\n            self.doctrine.resolve_combat_altitude(self.is_helo),\n            alt_type,\n            description=\"Rendezvous with package\",\n            pretty_name=\"Join\",\n        )\n\n    def refuel(self, position: Point) -> FlightWaypoint:\n        alt_type: AltitudeReference = \"BARO\"\n        if self.is_helo:\n            alt_type = \"RADIO\"\n\n        return FlightWaypoint(\n            \"REFUEL\",\n            FlightWaypointType.REFUEL,\n            position,\n            self.doctrine.resolve_combat_altitude(self.is_helo),\n            alt_type,\n            description=\"Refuel from tanker\",\n            pretty_name=\"Refuel\",\n        )\n\n    def recovery_tanker(self, position: Point) -> FlightWaypoint:\n        alt_type: AltitudeReference = \"BARO\"\n\n        return FlightWaypoint(\n            \"RECOVERY\",\n            FlightWaypointType.RECOVERY_TANKER,\n            position,\n            feet(6000),\n            alt_type,\n            description=\"Recovery tanker for aircraft carriers\",\n            pretty_name=\"Recovery\",\n        )\n\n    def split(self, position: Point) -> FlightWaypoint:\n        alt_type: AltitudeReference = \"BARO\"\n        if self.is_helo:\n            alt_type = \"RADIO\"\n\n        return FlightWaypoint(\n            \"SPLIT\",\n            FlightWaypointType.SPLIT,\n            position,\n            self.doctrine.resolve_combat_altitude(self.is_helo),\n            alt_type,\n            description=\"Depart from package\",\n            pretty_name=\"Split\",\n        )\n\n    def ingress(\n        self,\n        ingress_type: FlightWaypointType,\n        position: Point,\n        objective: MissionTarget,\n    ) -> FlightWaypoint:\n        alt_type: AltitudeReference = \"BARO\"\n        if self.is_helo:\n            alt_type = \"RADIO\"\n\n        return FlightWaypoint(\n            \"INGRESS\",\n            ingress_type,\n            position,\n            self.doctrine.resolve_combat_altitude(self.is_helo),\n            alt_type,\n            description=f\"INGRESS on {objective.name}\",\n            pretty_name=f\"INGRESS on {objective.name}\",\n            targets=objective.strike_targets,\n        )\n\n    def bai_group(self, target: StrikeTarget) -> FlightWaypoint:\n        return self._target_point(target, f\"ATTACK {target.name}\")\n\n    def dead_point(self, target: StrikeTarget) -> FlightWaypoint:\n        return self._target_point(target, f\"STRIKE {target.name}\")\n\n    def sead_point(self, target: StrikeTarget) -> FlightWaypoint:\n        return self._target_point(target, f\"STRIKE {target.name}\")\n\n    def strike_point(self, target: StrikeTarget) -> FlightWaypoint:\n        return self._target_point(target, f\"STRIKE {target.name}\")\n\n    @staticmethod\n    def _target_point(target: StrikeTarget, description: str) -> FlightWaypoint:\n        return FlightWaypoint(\n            target.name,\n            FlightWaypointType.TARGET_POINT,\n            target.target.position,\n            meters(0),\n            \"RADIO\",\n            description=description,\n            pretty_name=description,\n            # The target waypoints are only for the player's benefit. AI tasks for\n            # the target are set on the ingress point so that they begin their attack\n            # *before* reaching the target.\n            only_for_player=True,\n        )\n\n    def strike_area(self, target: MissionTarget) -> FlightWaypoint:\n        return self._target_area(f\"STRIKE {target.name}\", target)\n\n    def sead_area(self, target: MissionTarget) -> FlightWaypoint:\n        # Set flyover with ingress altitude to allow the flight to search and engage\n        # the target group at the ingress alt without suicide dive\n        return self._target_area(\n            f\"SEAD on {target.name}\",\n            target,\n            flyover=True,\n            altitude=self.doctrine.combat_altitude,\n            alt_type=\"BARO\",\n        )\n\n    def dead_area(self, target: MissionTarget) -> FlightWaypoint:\n        return self._target_area(f\"DEAD on {target.name}\", target)\n\n    def oca_strike_area(self, target: MissionTarget) -> FlightWaypoint:\n        return self._target_area(f\"ATTACK {target.name}\", target, flyover=True)\n\n    def assault_area(self, target: MissionTarget) -> FlightWaypoint:\n        \"\"\"A destination waypoint used by air-assault ground troops.\n\n        This waypoint is an implementation detail for CTLD and should not be followed by\n        aircraft.\n        \"\"\"\n        # TODO: Add a property that can hide this waypoint from the player's flight\n        # plan.\n        return self._target_area(f\"ASSAULT {target.name}\", target)\n\n    @staticmethod\n    def _target_area(\n        name: str,\n        location: MissionTarget,\n        flyover: bool = False,\n        altitude: Distance = meters(0),\n        alt_type: AltitudeReference = \"RADIO\",\n    ) -> FlightWaypoint:\n        waypoint = FlightWaypoint(\n            name,\n            FlightWaypointType.TARGET_GROUP_LOC,\n            location.position,\n            altitude,\n            alt_type,\n            description=name,\n            pretty_name=name,\n        )\n\n        # Most target waypoints are only for the player's benefit. AI tasks for\n        # the target are set on the ingress point so they begin their attack\n        # *before* reaching the target.\n        #\n        # The exception is for flight plans that require passing over the\n        # target. For example, OCA strikes need to get close enough to detect\n        # the targets in their engagement zone or they will RTB immediately.\n        if flyover:\n            waypoint.flyover = True\n        else:\n            waypoint.only_for_player = True\n        return waypoint\n\n    @staticmethod\n    def race_track_start(position: Point, altitude: Distance) -> FlightWaypoint:\n        \"\"\"Creates a racetrack start waypoint.\n\n        Args:\n            position: Position of the waypoint.\n            altitude: Altitude of the racetrack.\n        \"\"\"\n        return FlightWaypoint(\n            \"RACETRACK START\",\n            FlightWaypointType.PATROL_TRACK,\n            position,\n            altitude,\n            description=\"Orbit between this point and the next point\",\n            pretty_name=\"Race-track start\",\n        )\n\n    @staticmethod\n    def race_track_end(position: Point, altitude: Distance) -> FlightWaypoint:\n        \"\"\"Creates a racetrack end waypoint.\n\n        Args:\n            position: Position of the waypoint.\n            altitude: Altitude of the racetrack.\n        \"\"\"\n        return FlightWaypoint(\n            \"RACETRACK END\",\n            FlightWaypointType.PATROL,\n            position,\n            altitude,\n            description=\"Orbit between this point and the previous point\",\n            pretty_name=\"Race-track end\",\n        )\n\n    def race_track(\n        self, start: Point, end: Point, altitude: Distance\n    ) -> Tuple[FlightWaypoint, FlightWaypoint]:\n        \"\"\"Creates two waypoint for a racetrack orbit.\n\n        Args:\n            start: The beginning racetrack waypoint.\n            end: The ending racetrack waypoint.\n            altitude: The racetrack altitude.\n        \"\"\"\n        return (\n            self.race_track_start(start, altitude),\n            self.race_track_end(end, altitude),\n        )\n\n    @staticmethod\n    def orbit(start: Point, altitude: Distance) -> FlightWaypoint:\n        \"\"\"Creates an circular orbit point.\n\n        Args:\n            start: Position of the waypoint.\n            altitude: Altitude of the racetrack.\n        \"\"\"\n\n        return FlightWaypoint(\n            \"ORBIT\",\n            FlightWaypointType.LOITER,\n            start,\n            altitude,\n            description=\"Anchor and hold at this point\",\n            pretty_name=\"Orbit\",\n        )\n\n    @staticmethod\n    def sweep_start(position: Point, altitude: Distance) -> FlightWaypoint:\n        \"\"\"Creates a sweep start waypoint.\n\n        Args:\n            position: Position of the waypoint.\n            altitude: Altitude of the sweep in meters.\n        \"\"\"\n        return FlightWaypoint(\n            \"SWEEP START\",\n            FlightWaypointType.INGRESS_SWEEP,\n            position,\n            altitude,\n            description=\"Proceed to the target and engage enemy aircraft\",\n            pretty_name=\"Sweep start\",\n        )\n\n    @staticmethod\n    def sweep_end(position: Point, altitude: Distance) -> FlightWaypoint:\n        \"\"\"Creates a sweep end waypoint.\n\n        Args:\n            position: Position of the waypoint.\n            altitude: Altitude of the sweep in meters.\n        \"\"\"\n        return FlightWaypoint(\n            \"SWEEP END\",\n            FlightWaypointType.EGRESS,\n            position,\n            altitude,\n            description=\"End of sweep\",\n            pretty_name=\"Sweep end\",\n        )\n\n    def sweep(\n        self, start: Point, end: Point, altitude: Distance\n    ) -> Tuple[FlightWaypoint, FlightWaypoint]:\n        \"\"\"Creates two waypoint for a racetrack orbit.\n\n        Args:\n            start: The beginning of the sweep.\n            end: The end of the sweep.\n            altitude: The sweep altitude.\n        \"\"\"\n        return self.sweep_start(start, altitude), self.sweep_end(end, altitude)\n\n    def escort(\n        self,\n        ingress: Point,\n        target: MissionTarget,\n    ) -> Tuple[FlightWaypoint, FlightWaypoint]:\n        \"\"\"Creates the waypoints needed to escort the package.\n\n        Args:\n            ingress: The package ingress point.\n            target: The mission target.\n        \"\"\"\n        alt_type: AltitudeReference = \"BARO\"\n        if self.is_helo:\n            alt_type = \"RADIO\"\n\n        # This would preferably be no points at all, and instead the Escort task\n        # would begin on the join point and end on the split point, however the\n        # escort task does not appear to work properly (see the longer\n        # description in gen.aircraft.JoinPointBuilder), so instead we give\n        # the escort flights a flight plan including the ingress point and target area.\n        ingress_wp = self.ingress(FlightWaypointType.INGRESS_ESCORT, ingress, target)\n\n        return ingress_wp, FlightWaypoint(\n            \"TARGET\",\n            FlightWaypointType.TARGET_GROUP_LOC,\n            target.position,\n            self.doctrine.resolve_combat_altitude(self.is_helo),\n            alt_type,\n            description=\"Escort the package\",\n            pretty_name=\"Target area\",\n        )\n\n    @staticmethod\n    def pickup_zone(pick_up: MissionTarget) -> FlightWaypoint:\n        \"\"\"Creates a pickup landing zone waypoint\n        This waypoint is used to generate the Trigger Zone used for AirAssault and\n        AirLift using the CTLD plugin (see LogisticsGenerator)\n        \"\"\"\n        return FlightWaypoint(\n            \"PICKUPZONE\",\n            FlightWaypointType.PICKUP_ZONE,\n            pick_up.position,\n            meters(0),\n            \"RADIO\",\n            description=f\"Pick up cargo from {pick_up.name}\",\n            pretty_name=\"Pick-up zone\",\n        )\n\n    @staticmethod\n    def dropoff_zone(drop_off: MissionTarget) -> FlightWaypoint:\n        \"\"\"Creates a dropoff landing zone waypoint\n        This waypoint is used to generate the Trigger Zone used for AirAssault and\n        AirLift using the CTLD plugin (see LogisticsGenerator)\n        \"\"\"\n        return FlightWaypoint(\n            \"DROPOFFZONE\",\n            FlightWaypointType.DROPOFF_ZONE,\n            drop_off.position,\n            meters(0),\n            \"RADIO\",\n            description=f\"Drop off cargo at {drop_off.name}\",\n            pretty_name=\"Drop-off zone\",\n        )\n\n    @staticmethod\n    def cargo_stop(control_point: ControlPoint) -> FlightWaypoint:\n        \"\"\"Creates a cargo stop waypoint.\n        This waypoint is used by AirLift as a landing and stopover waypoint\n        \"\"\"\n        return FlightWaypoint(\n            \"CARGOSTOP\",\n            FlightWaypointType.CARGO_STOP,\n            control_point.position,\n            meters(0),\n            \"RADIO\",\n            description=f\"Stop for cargo at {control_point.name}\",\n            pretty_name=\"Cargo stop\",\n            control_point=control_point,\n        )\n\n    @staticmethod\n    def nav(\n        position: Point, altitude: Distance, altitude_is_agl: bool = False\n    ) -> FlightWaypoint:\n        \"\"\"Creates a navigation point.\n\n        Args:\n            position: Position of the waypoint.\n            altitude: Altitude of the waypoint.\n            altitude_is_agl: True for altitude is AGL. False if altitude is MSL.\n        \"\"\"\n        alt_type: AltitudeReference = \"BARO\"\n        if altitude_is_agl:\n            alt_type = \"RADIO\"\n\n        return FlightWaypoint(\n            \"NAV\",\n            FlightWaypointType.NAV,\n            position,\n            altitude,\n            alt_type,\n            description=\"NAV\",\n            pretty_name=\"Nav\",\n        )\n\n    def nav_path(\n        self, a: Point, b: Point, altitude: Distance, altitude_is_agl: bool = False\n    ) -> List[FlightWaypoint]:\n        path = self.clean_nav_points(self.navmesh.shortest_path(a, b))\n        return [self.nav(self.perturb(p), altitude, altitude_is_agl) for p in path]\n\n    def clean_nav_points(self, points: Iterable[Point]) -> Iterator[Point]:\n        # Examine a sliding window of three waypoints. `current` is the waypoint\n        # being checked for prunability. `previous` is the last emitted waypoint\n        # before `current`. `nxt` is the waypoint after `current`.\n        previous: Optional[Point] = None\n        current: Optional[Point] = None\n        for nxt in points:\n            if current is None:\n                current = nxt\n                continue\n            if previous is None:\n                previous = current\n                current = nxt\n                continue\n\n            if self.nav_point_prunable(previous, current, nxt):\n                current = nxt\n                continue\n\n            yield current\n            previous = current\n            current = nxt\n\n    def nav_point_prunable(self, previous: Point, current: Point, nxt: Point) -> bool:\n        previous_threatened = self.threat_zones.path_threatened(previous, current)\n        next_threatened = self.threat_zones.path_threatened(current, nxt)\n        pruned_threatened = self.threat_zones.path_threatened(previous, nxt)\n        previous_distance = meters(previous.distance_to_point(current))\n        distance = meters(current.distance_to_point(nxt))\n        distance_without = previous_distance + distance\n        if distance > distance_without:\n            # Don't prune paths to make them longer.\n            return False\n\n        # We could shorten the path by removing the intermediate\n        # waypoint. Do so if the new path isn't higher threat.\n        if not pruned_threatened:\n            # The new path is not threatened, so safe to prune.\n            return True\n\n        # The new path is threatened. Only allow if both paths were\n        # threatened anyway.\n        return previous_threatened and next_threatened\n\n    @staticmethod\n    def perturb(point: Point) -> Point:\n        deviation = nautical_miles(1)\n        x_adj = random.randint(int(-deviation.meters), int(deviation.meters))\n        y_adj = random.randint(int(-deviation.meters), int(deviation.meters))\n        return point + Vector2(x_adj, y_adj)\n"}
{"type": "source_file", "path": "game/ato/flightstate/__init__.py", "content": "from .completed import Completed\nfrom .flightstate import FlightState\nfrom .incombat import InCombat\nfrom .inflight import InFlight\nfrom .killed import Killed\nfrom .navigating import Navigating\nfrom .startup import StartUp\nfrom .takeoff import Takeoff\nfrom .taxi import Taxi\nfrom .uninitialized import Uninitialized\nfrom .waitingforstart import WaitingForStart\n"}
{"type": "source_file", "path": "game/ato/flightplans/uizonedisplay.py", "content": "import abc\nfrom dataclasses import dataclass\n\nfrom dcs import Point\n\nfrom game.utils import Distance\n\n\n@dataclass(frozen=True)\nclass UiZone:\n    points: list[Point]\n    radius: Distance\n\n\nclass UiZoneDisplay(abc.ABC):\n    @abc.abstractmethod\n    def ui_zone(self) -> UiZone: ...\n"}
{"type": "source_file", "path": "game/ato/flightplans/shiprecoverytanker.py", "content": "from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom typing import Iterator, Type\n\nfrom game.ato.flightplans.ibuilder import IBuilder\nfrom game.ato.flightplans.standard import StandardFlightPlan, StandardLayout\nfrom game.ato.flightplans.waypointbuilder import WaypointBuilder\nfrom game.ato.flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass RecoveryTankerLayout(StandardLayout):\n    nav_to: list[FlightWaypoint]\n    recovery_ship: FlightWaypoint\n    nav_from: list[FlightWaypoint]\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield from self.nav_to\n        yield self.recovery_ship\n        yield from self.nav_from\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nclass RecoveryTankerFlightPlan(StandardFlightPlan[RecoveryTankerLayout]):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        return self.layout.recovery_ship\n\n    @property\n    def mission_begin_on_station_time(self) -> datetime:\n        return self.package.time_over_target\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        return self.patrol_end_time\n\n    @property\n    def patrol_start_time(self) -> datetime:\n        return self.package.time_over_target\n\n    @property\n    def patrol_end_time(self) -> datetime:\n        return self.tot + timedelta(hours=2)\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.tot_waypoint:\n            return self.tot\n        return None\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.tot_waypoint:\n            return self.mission_departure_time\n        return None\n\n\nclass Builder(IBuilder[RecoveryTankerFlightPlan, RecoveryTankerLayout]):\n    def layout(self) -> RecoveryTankerLayout:\n        builder = WaypointBuilder(self.flight, self.coalition)\n\n        # TODO: Propagate the ship position to the Tanker's TOT,\n        # so that we minimize the tanker's need to catch up to the carrier.\n        recovery_ship = self.package.target.position\n        recovery_tanker = builder.recovery_tanker(recovery_ship)\n\n        # We don't have per aircraft cruise altitudes, so just reuse patrol altitude?\n        tanker_type = self.flight.unit_type\n        nav_cruise_altitude = tanker_type.preferred_patrol_altitude\n\n        return RecoveryTankerLayout(\n            departure=builder.takeoff(self.flight.departure),\n            nav_to=builder.nav_path(\n                self.flight.departure.position, recovery_ship, nav_cruise_altitude\n            ),\n            nav_from=builder.nav_path(\n                recovery_ship, self.flight.arrival.position, nav_cruise_altitude\n            ),\n            recovery_ship=recovery_tanker,\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> RecoveryTankerFlightPlan:\n        return RecoveryTankerFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/planningerror.py", "content": "from __future__ import annotations\n\n\nclass PlanningError(RuntimeError):\n    \"\"\"Raised when the flight planner was unable to create a flight plan.\"\"\"\n"}
{"type": "source_file", "path": "game/ato/flightplans/packagerefueling.py", "content": "from __future__ import annotations\n\nfrom datetime import datetime, timedelta\nfrom typing import Type\n\nfrom dcs import Point\n\nfrom game.utils import Distance, Heading, feet, meters\nfrom .ibuilder import IBuilder\nfrom .patrolling import PatrollingLayout\nfrom .refuelingflightplan import RefuelingFlightPlan\nfrom .waypointbuilder import WaypointBuilder\nfrom ..flightwaypoint import FlightWaypoint\nfrom ..flightwaypointtype import FlightWaypointType\n\n\nclass PackageRefuelingFlightPlan(RefuelingFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n    @property\n    def patrol_duration(self) -> timedelta:\n        # TODO: Only consider aircraft that can refuel with this tanker type.\n        refuel_time_minutes = 5\n        for self.flight in self.package.flights:\n            flight_size = self.flight.roster.max_size\n            refuel_time_minutes = refuel_time_minutes + 4 * flight_size + 1\n\n        return timedelta(minutes=refuel_time_minutes)\n\n    def target_area_waypoint(self) -> FlightWaypoint:\n        return FlightWaypoint(\n            \"TARGET AREA\",\n            FlightWaypointType.TARGET_GROUP_LOC,\n            self.package.target.position,\n            meters(0),\n            \"RADIO\",\n        )\n\n    @property\n    def patrol_start_time(self) -> datetime:\n        altitude = self.flight.unit_type.patrol_altitude\n\n        if altitude is None:\n            altitude = Distance.from_feet(20000)\n\n        assert self.package.waypoints is not None\n\n        # Cheat in a FlightWaypoint for the split point.\n        split: Point = self.package.waypoints.split\n        split_waypoint: FlightWaypoint = FlightWaypoint(\n            \"SPLIT\", FlightWaypointType.SPLIT, split, altitude\n        )\n\n        # Cheat in a FlightWaypoint for the refuel point.\n        refuel: Point = self.package.waypoints.refuel\n        refuel_waypoint: FlightWaypoint = FlightWaypoint(\n            \"REFUEL\", FlightWaypointType.REFUEL, refuel, altitude\n        )\n\n        delay_target_to_split: timedelta = self.total_time_between_waypoints(\n            self.target_area_waypoint(), split_waypoint\n        )\n        delay_split_to_refuel: timedelta = self.total_time_between_waypoints(\n            split_waypoint, refuel_waypoint\n        )\n\n        return (\n            self.package.time_over_target\n            + delay_target_to_split\n            + delay_split_to_refuel\n            - timedelta(minutes=1.5)\n        )\n\n\nclass Builder(IBuilder[PackageRefuelingFlightPlan, PatrollingLayout]):\n    def layout(self) -> PatrollingLayout:\n        package_waypoints = self.package.waypoints\n        assert package_waypoints is not None\n\n        racetrack_half_distance = Distance.from_nautical_miles(20).meters\n\n        racetrack_center = package_waypoints.refuel\n\n        split_heading = Heading.from_degrees(\n            racetrack_center.heading_between_point(package_waypoints.split)\n        )\n        home_heading = split_heading.opposite\n\n        racetrack_start = racetrack_center.point_from_heading(\n            split_heading.degrees, racetrack_half_distance\n        )\n\n        racetrack_end = racetrack_center.point_from_heading(\n            home_heading.degrees, racetrack_half_distance\n        )\n\n        builder = WaypointBuilder(self.flight, self.coalition)\n\n        tanker_type = self.flight.unit_type\n        if tanker_type.patrol_altitude is not None:\n            altitude = tanker_type.patrol_altitude\n        else:\n            altitude = feet(21000)\n\n        racetrack = builder.race_track(racetrack_start, racetrack_end, altitude)\n\n        return PatrollingLayout(\n            departure=builder.takeoff(self.flight.departure),\n            nav_to=builder.nav_path(\n                self.flight.departure.position, racetrack_start, altitude\n            ),\n            nav_from=builder.nav_path(\n                racetrack_end, self.flight.arrival.position, altitude\n            ),\n            patrol_start=racetrack[0],\n            patrol_end=racetrack[1],\n            arrival=builder.land(self.flight.arrival),\n            divert=builder.divert(self.flight.divert),\n            bullseye=builder.bullseye(),\n        )\n\n    def build(self, dump_debug_info: bool = False) -> PackageRefuelingFlightPlan:\n        return PackageRefuelingFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/ocaaircraft.py", "content": "from __future__ import annotations\n\nimport logging\nfrom typing import Type\n\nfrom game.theater import Airfield\nfrom .formationattack import (\n    FormationAttackBuilder,\n    FormationAttackFlightPlan,\n    FormationAttackLayout,\n)\nfrom .invalidobjectivelocation import InvalidObjectiveLocation\nfrom ..flightwaypointtype import FlightWaypointType\n\n\nclass OcaAircraftFlightPlan(FormationAttackFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n\nclass Builder(FormationAttackBuilder[OcaAircraftFlightPlan, FormationAttackLayout]):\n    def layout(self) -> FormationAttackLayout:\n        location = self.package.target\n\n        if not isinstance(location, Airfield):\n            logging.exception(\n                f\"Invalid Objective Location for OCA/Aircraft flight \"\n                f\"{self.flight=} at {location=}.\"\n            )\n            raise InvalidObjectiveLocation(self.flight.flight_type, location)\n\n        return self._build(FlightWaypointType.INGRESS_OCA_AIRCRAFT)\n\n    def build(self, dump_debug_info: bool = False) -> OcaAircraftFlightPlan:\n        return OcaAircraftFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/patrolling.py", "content": "from __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom typing import Any, TYPE_CHECKING, TypeGuard, TypeVar\n\nfrom game.ato.flightplans.standard import StandardFlightPlan, StandardLayout\nfrom game.typeguard import self_type_guard\nfrom game.utils import Distance, Speed\nfrom .uizonedisplay import UiZone, UiZoneDisplay\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n    from .flightplan import FlightPlan\n\n\n@dataclass(frozen=True)\nclass PatrollingLayout(StandardLayout):\n    nav_to: list[FlightWaypoint]\n    patrol_start: FlightWaypoint\n    patrol_end: FlightWaypoint\n    nav_from: list[FlightWaypoint]\n\n    def iter_waypoints(self) -> Iterator[FlightWaypoint]:\n        yield self.departure\n        yield from self.nav_to\n        yield self.patrol_start\n        yield self.patrol_end\n        yield from self.nav_from\n        yield self.arrival\n        if self.divert is not None:\n            yield self.divert\n        yield self.bullseye\n\n\nLayoutT = TypeVar(\"LayoutT\", bound=PatrollingLayout)\n\n\nclass PatrollingFlightPlan(StandardFlightPlan[LayoutT], UiZoneDisplay, ABC):\n    @property\n    @abstractmethod\n    def patrol_duration(self) -> timedelta:\n        \"\"\"Maximum time to remain on station.\"\"\"\n\n    @property\n    @abstractmethod\n    def patrol_speed(self) -> Speed:\n        \"\"\"Racetrack speed TAS.\"\"\"\n\n    @property\n    @abstractmethod\n    def engagement_distance(self) -> Distance:\n        \"\"\"The maximum engagement distance.\n\n        The engagement range of any Search Then Engage task, or the radius of a Search\n        Then Engage in Zone task. Any enemies of the appropriate type for this mission\n        within this range of the flight's current position (or the center of the zone)\n        will be engaged by the flight.\n        \"\"\"\n\n    @property\n    def patrol_start_time(self) -> datetime:\n        return self.tot\n\n    @property\n    def patrol_end_time(self) -> datetime:\n        # TODO: This is currently wrong for CAS.\n        # CAS missions end when they're winchester or bingo. We need to\n        # configure push tasks for the escorts rather than relying on timing.\n        return self.patrol_start_time + self.patrol_duration\n\n    def tot_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.layout.patrol_start:\n            return self.patrol_start_time\n        return None\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.layout.patrol_end:\n            return self.patrol_end_time\n        return None\n\n    @property\n    def package_speed_waypoints(self) -> set[FlightWaypoint]:\n        return {self.layout.patrol_start, self.layout.patrol_end}\n\n    @property\n    def tot_waypoint(self) -> FlightWaypoint:\n        return self.layout.patrol_start\n\n    @property\n    def mission_begin_on_station_time(self) -> datetime:\n        return self.patrol_start_time\n\n    @property\n    def mission_departure_time(self) -> datetime:\n        return self.patrol_end_time\n\n    @self_type_guard\n    def is_patrol(\n        self, flight_plan: FlightPlan[Any]\n    ) -> TypeGuard[PatrollingFlightPlan[Any]]:\n        return True\n\n    def ui_zone(self) -> UiZone:\n        return UiZone(\n            [self.layout.patrol_start.position, self.layout.patrol_end.position],\n            self.engagement_distance,\n        )\n"}
{"type": "source_file", "path": "game/ato/flightplans/ocarunway.py", "content": "from __future__ import annotations\n\nimport logging\nfrom typing import Type\n\nfrom game.theater import Airfield\nfrom .formationattack import (\n    FormationAttackBuilder,\n    FormationAttackFlightPlan,\n    FormationAttackLayout,\n)\nfrom .invalidobjectivelocation import InvalidObjectiveLocation\nfrom ..flightwaypointtype import FlightWaypointType\n\n\nclass OcaRunwayFlightPlan(FormationAttackFlightPlan):\n    @staticmethod\n    def builder_type() -> Type[Builder]:\n        return Builder\n\n\nclass Builder(FormationAttackBuilder[OcaRunwayFlightPlan, FormationAttackLayout]):\n    def layout(self) -> FormationAttackLayout:\n        location = self.package.target\n\n        if not isinstance(location, Airfield):\n            logging.exception(\n                f\"Invalid Objective Location for OCA/Runway flight \"\n                f\"{self.flight=} at {location=}.\"\n            )\n            raise InvalidObjectiveLocation(self.flight.flight_type, location)\n\n        return self._build(FlightWaypointType.INGRESS_OCA_RUNWAY)\n\n    def build(self, dump_debug_info: bool = False) -> OcaRunwayFlightPlan:\n        return OcaRunwayFlightPlan(self.flight, self.layout())\n"}
{"type": "source_file", "path": "game/ato/flightplans/loiter.py", "content": "from __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom typing import Any, TYPE_CHECKING, TypeGuard, TypeVar\n\nfrom game.flightplan.waypointactions.hold import Hold\nfrom game.typeguard import self_type_guard\nfrom game.utils import Speed\nfrom .flightplan import FlightPlan\nfrom .standard import StandardFlightPlan, StandardLayout\n\nif TYPE_CHECKING:\n    from ..flightwaypoint import FlightWaypoint\n\n\n@dataclass(frozen=True)\nclass LoiterLayout(StandardLayout, ABC):\n    hold: FlightWaypoint\n\n\nLayoutT = TypeVar(\"LayoutT\", bound=LoiterLayout)\n\n\nclass LoiterFlightPlan(StandardFlightPlan[LayoutT], ABC):\n    @property\n    def hold_duration(self) -> timedelta:\n        return timedelta(minutes=5)\n\n    @property\n    @abstractmethod\n    def push_time(self) -> datetime: ...\n\n    def depart_time_for_waypoint(self, waypoint: FlightWaypoint) -> datetime | None:\n        if waypoint == self.layout.hold:\n            return self.push_time\n        return None\n\n    def total_time_between_waypoints(\n        self, a: FlightWaypoint, b: FlightWaypoint\n    ) -> timedelta:\n        travel_time = super().total_time_between_waypoints(a, b)\n        if a != self.layout.hold:\n            return travel_time\n        return travel_time + self.hold_duration\n\n    @self_type_guard\n    def is_loiter(\n        self, flight_plan: FlightPlan[Any]\n    ) -> TypeGuard[LoiterFlightPlan[Any]]:\n        return True\n\n    def provide_push_time(self) -> datetime:\n        return self.push_time\n\n    def add_waypoint_actions(self) -> None:\n        hold = self.layout.hold\n        speed = self.flight.unit_type.patrol_speed\n        if speed is None:\n            speed = Speed.from_mach(0.6, hold.alt)\n        hold.add_action(Hold(self.provide_push_time, hold.alt, speed))\n"}
{"type": "source_file", "path": "game/ato/flightplans/ibuilder.py", "content": "from __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Generic, TYPE_CHECKING, TypeVar\n\nfrom game.navmesh import NavMeshError\nfrom .flightplan import FlightPlan, Layout\nfrom .planningerror import PlanningError\nfrom ..packagewaypoints import PackageWaypoints\n\nif TYPE_CHECKING:\n    from game.coalition import Coalition\n    from game.data.doctrine import Doctrine\n    from game.theater import ConflictTheater\n    from game.threatzones import ThreatZones\n    from ..flight import Flight\n    from ..package import Package\n\n\nFlightPlanT = TypeVar(\"FlightPlanT\", bound=FlightPlan[Any])\nLayoutT = TypeVar(\"LayoutT\", bound=Layout)\n\n\nclass IBuilder(ABC, Generic[FlightPlanT, LayoutT]):\n    def __init__(self, flight: Flight) -> None:\n        self.flight = flight\n        self._flight_plan: FlightPlanT | None = None\n\n    def get_or_build(self) -> FlightPlanT:\n        if self._flight_plan is None:\n            self.regenerate()\n            assert self._flight_plan is not None\n        return self._flight_plan\n\n    def regenerate(self, dump_debug_info: bool = False) -> None:\n        try:\n            self._generate_package_waypoints_if_needed(dump_debug_info)\n            self._flight_plan = self.build(dump_debug_info)\n            self._flight_plan.add_waypoint_actions()\n        except NavMeshError as ex:\n            color = \"blue\" if self.flight.squadron.player else \"red\"\n            raise PlanningError(\n                f\"Could not plan {color} {self.flight.flight_type.value} from \"\n                f\"{self.flight.departure} to {self.package.target}\"\n            ) from ex\n\n    def _generate_package_waypoints_if_needed(self, dump_debug_info: bool) -> None:\n        # Package waypoints are only valid for offensive missions. Skip this if the\n        # target is friendly.\n        if self.package.target.is_friendly(self.is_player):\n            return\n\n        if self.package.waypoints is None or dump_debug_info:\n            self.package.waypoints = PackageWaypoints.create(\n                self.package, self.coalition, dump_debug_info\n            )\n\n    @property\n    def theater(self) -> ConflictTheater:\n        return self.flight.departure.theater\n\n    @abstractmethod\n    def build(self, dump_debug_info: bool = False) -> FlightPlanT: ...\n\n    @property\n    def package(self) -> Package:\n        return self.flight.package\n\n    @property\n    def coalition(self) -> Coalition:\n        return self.flight.coalition\n\n    @property\n    def is_player(self) -> bool:\n        return self.coalition.player\n\n    @property\n    def doctrine(self) -> Doctrine:\n        return self.coalition.doctrine\n\n    @property\n    def threat_zones(self) -> ThreatZones:\n        return self.coalition.opponent.threat_zone\n"}

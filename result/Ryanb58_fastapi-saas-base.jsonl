{"repo_info": {"repo_name": "fastapi-saas-base", "repo_owner": "Ryanb58", "repo_url": "https://github.com/Ryanb58/fastapi-saas-base"}}
{"type": "test_file", "path": "app/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "app/tests/test_login.py", "content": "from app.tests.conftests import TestBase\nfrom app.models.account import Account\n\n\nclass LoginTestCase(TestBase):\n    def test_success(self):\n        self.create_system_admin()\n        payload = {\"username\": \"admin@example.com\", \"password\": \"password123\"}\n        response = self.client.post(\"/auth/token\", data=payload)\n        assert response.status_code == 200\n        assert response.json().get(\"access_token\", False)\n        assert response.json().get(\"token_type\", False) == \"bearer\"\n\n    def test_invalid(self):\n        self.create_system_admin()\n        payload = {\"username\": \"admin@example.com\", \"password\": \"password\"}\n        response = self.client.post(\"/auth/token\", data=payload)\n        assert response.status_code == 401\n"}
{"type": "test_file", "path": "app/tests/test_email_addresses.py", "content": "from unittest.mock import patch\n\nfrom app.tests.conftests import TestBase\nfrom app.models.account import Account\nfrom app.models.account import EmailAddress\nfrom app.controllers.account import create_email_address\nfrom app.controllers.account import create_token_from_id\n\nclass EmailAddressTestCase(TestBase):\n    @patch(\"app.controllers.account.send_email\")\n    def test_create(self, mock_send_email):\n        self.create_system_admin()\n        assert self.db_session.query(EmailAddress).count() == 1\n        payload = {\"email\": \"another@example.com\"}\n        response = self.client.post(\n            \"/email_addresses\", json=payload, headers=self.auth_headers()\n        )\n        assert response.status_code == 201\n        assert self.db_session.query(EmailAddress).count() == 2\n        # Adding a new email address should send a verification email.\n        mock_send_email.assert_called_once()\n\n    def test_get(self):\n        self.create_system_admin()\n        payload = {\"email\": \"another@example.com\"}\n        response = self.client.get(\n            \"/email_addresses\", json=payload, headers=self.auth_headers()\n        )\n        assert response.status_code == 200\n        assert len(response.json()) == 1\n\n    def test_verify(self):\n        admin_obj = self.create_system_admin()\n\n        # Add new unverified email address to user.\n        email_obj = create_email_address(\n            self.db_session, \n            \"michael.scott@gmail.com\", \n            admin_obj.id, \n            send_verification_email=False)\n\n        token = create_token_from_id(email_obj.id)\n        response = self.client.post(\n            \"/email_addresses/verify?token={}\".format(token)\n        )\n        assert response.status_code == 200\n"}
{"type": "test_file", "path": "app/tests/test_accounts.py", "content": "from app.tests.conftests import TestBase\n\n\nclass AccountsTestCase(TestBase):\n    def test_unauth_list(self):\n        resp = self.client.get(\"/accounts\")\n        assert resp.status_code == 401\n\n    def test_list(self):\n        self.create_system_admin()\n        resp = self.client.get(\"/accounts\", headers=self.auth_headers())\n        assert resp.status_code == 200\n"}
{"type": "test_file", "path": "app/tests/test_members.py", "content": "import responses\nfrom unittest.mock import patch\n\nfrom app.tests.conftests import TestBase\nfrom app.models.account import Account\nfrom app.models.account import EmailAddress\nfrom app.controllers.tenant import create_tenant_and_account\nfrom app.controllers.account import create_account\n\n\nclass MembersTestCase(TestBase):\n    @patch(\"app.controllers.account.send_email\")\n    @responses.activate\n    def test_get(self, mock_send_email):\n        # Mock out request to stripe.\n        responses.add(\n            responses.POST,\n            \"https://api.stripe.com/v1/customers\",\n            json={\"id\": 1},\n            status=200,\n        )\n\n        tenant_account = {\n            \"first_name\": \"Andy\",\n            \"last_name\": \"Benard\",\n            \"email\": \"andy.bernard@example.com\",\n            \"password\": \"password123\",\n            \"name\": \"Dunder Mifflin Scranton\",\n            \"slug\": \"dunder-mifflin-scranton\",\n            \"is_active\": True,\n            \"is_verified\": True,\n        }\n        tenant_obj = create_tenant_and_account(self.db_session, **tenant_account)\n\n        headers = self.auth_headers(email=tenant_account.get(\"email\"))\n        response = self.client.get(\n            \"/members?tenant_id={}\".format(tenant_obj.id), headers=headers\n        )\n\n        assert response.status_code == 200\n        assert len(response.json()) == 1\n\n    @responses.activate\n    def test_add_existing_account_as_member(self):\n        # Mock out request to stripe.\n        responses.add(\n            responses.POST,\n            \"https://api.stripe.com/v1/customers\",\n            json={\"id\": 1},\n            status=200,\n        )\n\n        # Create the account that will join the tenant.\n        account_obj = create_account(\n            self.db_session,\n            first_name=\"Jim\",\n            last_name=\"Halpert\",\n            email=\"jim.halpert@example.com\",\n            password=\"password123\",\n            is_active=True,\n            is_verified=True,\n            send_registration_email=False,\n        )\n\n        # Setup tenant and admin account.\n        tenant_account = {\n            \"first_name\": \"Andy\",\n            \"last_name\": \"Benard\",\n            \"email\": \"andy.bernard@example.com\",\n            \"password\": \"password123\",\n            \"name\": \"Dunder Mifflin Scranton\",\n            \"slug\": \"dunder-mifflin-scranton\",\n            \"is_active\": True,\n            \"is_verified\": True,\n            \"do_send_emails\": False\n        }\n        tenant_obj = create_tenant_and_account(self.db_session, **tenant_account)\n\n        # Add member\n        payload = {\n            \"tenant_id\": tenant_obj.id,\n            \"email\": \"jim.halpert@example.com\",\n        }\n        headers = self.auth_headers(email=tenant_account.get(\"email\"))\n        response = self.client.post(\"/members\", json=payload, headers=headers)\n        assert response.status_code == 201\n\n        headers = self.auth_headers(email=tenant_account.get(\"email\"))\n        response = self.client.get(\n            \"/members?tenant_id={}\".format(tenant_obj.id), headers=headers\n        )\n        assert response.status_code == 200\n        assert len(response.json()) == 2\n\n    # @patch(\"app.controllers.account.send_email\")\n    # @responses.activate\n    # def test_add_new_account_as_member(self, mock_send_email):\n    #     # Mock out request to stripe.\n    #     responses.add(\n    #         responses.POST,\n    #         \"https://api.stripe.com/v1/customers\",\n    #         json={\"id\": 1},\n    #         status=200,\n    #     )\n\n    #     # Setup tenant and admin account.\n    #     tenant_account = {\n    #         \"first_name\": \"Andy\",\n    #         \"last_name\": \"Benard\",\n    #         \"email\": \"andy.bernard@example.com\",\n    #         \"password\": \"password123\",\n    #         \"name\": \"Dunder Mifflin Scranton\",\n    #         \"slug\": \"dunder-mifflin-scranton\",\n    #         \"is_active\": True,\n    #         \"is_verified\": True,\n    #     }\n    #     tenant_obj = create_tenant_and_account(self.db_session, **tenant_account)\n\n    #     # Add member\n    #     payload = {\n    #         \"tenant_id\": tenant_obj.id,\n    #         \"email\": \"jim.halpert@example.com\",\n    #     }\n    #     headers = self.auth_headers(email=tenant_account.get(\"email\"))\n    #     response = self.client.post(\"/members\", json=payload, headers=headers)\n    #     assert response.status_code == 201\n\n    #     headers = self.auth_headers(email=tenant_account.get(\"email\"))\n    #     response = self.client.get(\n    #         \"/members?tenant_id={}\".format(tenant_obj.id), headers=headers\n    #     )\n    #     assert response.status_code == 200\n    #     assert len(response.json()) == 2\n"}
{"type": "test_file", "path": "app/tests/conftests.py", "content": "# From @euri10 -- https://gitter.im/tiangolo/fastapi?at=5cd915ed56271260f95275ac\n\nimport asyncio\nfrom unittest import TestCase\n\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy_utils import create_database, database_exists, drop_database\n\nfrom starlette.config import environ\nfrom starlette.testclient import TestClient\n\n# This sets `os.environ`, but provides some additional protection.\n# If we placed it below the application import, it would raise an error\n# informing us that 'TESTING' had already been read from the environment.\n\nenviron[\"TESTING\"] = \"True\"\nenviron[\"EMAILS_ENABLED\"] = \"False\"\n\nfrom app.main import app  # isort:skip\nfrom app.database import engine, Base, DBSession\n\n\nclass TestBase(TestCase):\n    def setUp(self):\n        self.db_session = DBSession()\n        self.connection = engine.connect()\n\n        # # Configure Search DDL triggers.\n        Base.metadata.drop_all(self.connection)\n        Base.metadata.create_all(self.connection)\n\n        self.client = TestClient(app)\n\n    def tearDown(self):\n        self.db_session.rollback()\n        self.db_session.close()\n\n    def create_system_admin(self, *args, **kwargs):\n        from app.controllers.account import create_account\n        from app.schemas.account import AccountCreate\n\n        return create_account(\n            self.db_session,\n            first_name=\"Admin\",\n            last_name=\"Istrator\",\n            email=\"admin@example.com\",\n            password=\"password123\",\n            is_system_admin=True,\n            is_active=True,\n            send_registration_email=False,\n        )\n\n    def auth_headers(self, email=\"admin@example.com\", password=\"password123\"):\n        payload = {\"username\": email, \"password\": password}\n        resp = self.client.post(\"/auth/token\", data=payload)\n        return {\"Authorization\": \"Bearer \" + resp.json().get(\"access_token\")}\n"}
{"type": "test_file", "path": "app/tests/test_register.py", "content": "import responses\nfrom unittest.mock import patch\n\nfrom app.tests.conftests import TestBase\nfrom app.models.account import Account, EmailAddress\nfrom app.models.tenant import Tenant\nfrom app.controllers.account import (\n    create_token_from_id,\n    verify_email_address,\n)\n\n\nclass RegisterTestCase(TestBase):\n    @patch(\"app.controllers.account.send_email\")\n    @responses.activate\n    def test_success(self, mock_send_email):\n        # Mock out request to stripe.\n        responses.add(\n            responses.POST,\n            \"https://api.stripe.com/v1/customers\",\n            json={\"id\": 1},\n            status=200,\n        )\n\n        # Make sure no emails have been sent.\n        mock_send_email.assert_not_called()\n\n        payload = {\n            \"first_name\": \"Andy\",\n            \"last_name\": \"Benard\",\n            \"email\": \"andy.bernard@example.com\",\n            \"password\": \"password123\",\n            \"name\": \"Dunder Mifflin Scranton\",\n            \"slug\": \"dunder-mifflin-scranton\",\n        }\n        response = self.client.post(\"/auth/register\", json=payload)\n\n        # Validate that the registration email was sent.\n        mock_send_email.assert_called_once()\n\n        assert response.status_code == 201\n        assert self.db_session.query(Account).count() == 1\n        assert self.db_session.query(Tenant).count() == 1\n        assert self.db_session.query(Tenant).first().accounts.count() == 1\n\n        # Should not be able to login until after they have verified their email.\n        payload = {\"username\": \"andy.bernard@example.com\", \"password\": \"password123\"}\n        response = self.client.post(\"/auth/token\", data=payload)\n        assert response.status_code == 409\n\n        # Get the signed jwt and try to validate the account.\n        email_obj = (\n            self.db_session.query(EmailAddress)\n            .filter(EmailAddress.email == \"andy.bernard@example.com\")\n            .first()\n        )\n        token = create_token_from_id(email_obj.id)\n        response = self.client.post(\n            \"/auth/verify?token={}\".format(token)\n        )\n        assert response.status_code == 200\n\n        payload = {\"username\": \"andy.bernard@example.com\", \"password\": \"password123\"}\n        response = self.client.post(\"/auth/token\", data=payload)\n        assert response.status_code == 200\n"}
{"type": "source_file", "path": "app/controllers/account.py", "content": "from datetime import datetime, timedelta\n\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\nimport jwt\n\nfrom app.schemas import account as schemas\nfrom app.models.account import Account\nfrom app.models.account import EmailAddress\nfrom app.models.account import Password\nfrom app.utils.email import send_email\nfrom app.settings import SECRET_KEY\nfrom app.settings import FRONTEND_BASE_URL\nfrom app.settings import EMAIL_TOKEN_EXPIRE_MINUTES\n#### Accounts\n\n# to get a string like this run:\n# openssl rand -hex 32\nALGORITHM = \"HS256\"\n\ndef mark_account_as_verified_and_active(db_session: Session, token:int):\n    \"\"\"Mark an account as verified and active.\"\"\"\n    account_id = get_id_from_token(token)\n    if not account_id:\n        raise NotImplementedError(\"Invalid token.\")\n    account_obj = db_session.query(Account).get(account_id)\n \n    # Mark account as active.\n    account_obj.is_active = True\n\n    # Mark email as verified.\n    email_obj = account_obj.primary_email_address\n    email_obj.verified = True\n    email_obj.verified_on = datetime.now()\n\n    db_session.add(account_obj)\n    db_session.add(email_obj)\n    db_session.commit()\n\n\ndef get_account(db_session: Session, id: int):\n    return db_session.query(Account).filter(Account.id == id).first()\n\n\ndef get_account_by_email(db_session: Session, email: str):\n    email_obj = (\n        db_session.query(EmailAddress).filter(EmailAddress.email == email).first()\n    )\n    if not email_obj:\n        return None\n    return email_obj.account\n\n\ndef get_accounts(db_session: Session, skip: int = 0, limit: int = 100):\n    return db_session.query(Account).offset(skip).limit(limit).all()\n\n\ndef create_account(\n    db_session: Session,\n    first_name: str,\n    last_name: str,\n    email: str,\n    password: str,\n    is_system_admin: bool = False,\n    is_active: bool = False,\n    send_registration_email: bool = True,\n    is_verified: bool = False,\n):\n    \"\"\"Create an user account.\"\"\"\n    account_obj = Account(\n        first_name=first_name,\n        last_name=last_name,\n        is_system_admin=is_system_admin,\n        is_active=is_active,\n    )\n    db_session.add(account_obj)\n    db_session.flush()\n\n    email_obj = EmailAddress(\n        account_id=account_obj.id, email=email, primary=True, verified=is_verified\n    )\n\n    password_obj = Password(account_id=account_obj.id, password=password)\n\n    db_session.add(email_obj)\n    db_session.add(password_obj)\n    db_session.commit()\n\n    # Send registration email.\n    if send_registration_email:\n        token = create_token_from_id(email_obj.id)\n        registration_link = \"{}/{}/verify?token={}\".format(\n            FRONTEND_BASE_URL, email_obj.id, token\n        )\n        send_email(\n            to_email=email,\n            subject=\"Welcome!\",\n            body=\"\"\"Weclome to the website. \n            <p />Please use the following link to continue your registration. \n            <p /><a href=\"{}\">{}</a>\n            \"\"\".format(\n                registration_link, registration_link\n            ),\n        )\n\n    db_session.refresh(account_obj)\n\n    return account_obj\n\n\n#### Email Addresses\n\n\ndef get_email_addresses(\n    db_session: Session, account_id: int = None, skip: int = 0, limit: int = 100\n):\n    return (\n        db_session.query(EmailAddress)\n        .filter(EmailAddress.account_id == account_id)\n        .all()\n        or []\n    )\n\n\ndef create_email_address(\n    db_session: Session,\n    email: str,\n    account_id: int,\n    send_verification_email: bool = True,\n):\n    \"\"\"Add an email_address to a users account.\"\"\"\n    email_obj = EmailAddress(\n        account_id=account_id, email=email, primary=False, verified=False\n    )\n\n    db_session.add(email_obj)\n    db_session.commit()\n    db_session.refresh(email_obj)\n\n    # Send verification email.\n    if send_verification_email:\n        token = create_token_from_id(email_obj.id)\n        verification_link = \"{}/{}/verify?token={}\".format(\n            FRONTEND_BASE_URL, email_obj.id, token\n        )\n        send_email(\n            to_email=email,\n            subject=\"Verify your email!\",\n            body=\"\"\"Email Verification. \n            <p />Please use the following link to verify your email address. \n            <p /><a href=\"{}\">{}</a>\n            \"\"\".format(\n                verification_link, verification_link\n            ),\n        )\n\n    return email_obj\n\n\ndef create_token_from_id(id):\n    \"\"\"\n    Create a token that can be used to verify a email address.\n    \n    Expires in 1 hour.\n    \"\"\"\n    to_encode = {\n        \"id\": id,\n    }\n    expire = datetime.utcnow() + timedelta(minutes=EMAIL_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt.decode(\"utf-8\")\n\n\ndef get_id_from_token(token):\n    \"\"\"Get an id from a signed token.\"\"\"\n    try:\n        token = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n    except jwt.ExpiredSignatureError:\n        # Signature has expired\n        return False\n    except Exception:\n        return False\n\n    return token.get(\"id\")\n\n\ndef mark_email_as_verified(db_session: Session, email_id: int):\n    \"\"\"Mark an email id as verified and account as active.\"\"\"\n    email_obj = db_session.query(EmailAddress).get(email_id)\n\n    # Mark email as verified.\n    email_obj.verified = True\n    email_obj.verified_on = datetime.now()\n\n    db_session.add(email_obj)\n    db_session.commit()\n\n\ndef verify_email_address(db_session: Session, token: str):\n    email_id = get_id_from_token(token)\n    if not email_id:\n        raise NotImplementedError(\"Invalid token.\")\n\n    mark_email_as_verified(db_session, email_id)\n"}
{"type": "source_file", "path": "app/controllers/billing.py", "content": "import stripe\n\nfrom app.settings import STRIPE_API_SECRET\nfrom app.settings import STRIPE_DEFAULT_PLAN_ID\n\nstripe.api_key = STRIPE_API_SECRET\n\ndef create_customer(email, full_name, tenant_obj):\n    \"\"\"Create a customer object in stripe.\"\"\"\n\n    customer_resp = stripe.Customer.create(\n        email=email,\n        description=\"Customer for {}\".format(email),\n        name=full_name,\n        metadata={\"tenant_id\": tenant_obj.id},\n    )\n\n    # TODO: Record the customer_id from stripe.\n    return customer_resp\n\n\ndef create_subscription(customer_stripe_id, plan_stripe_ids):\n    \"\"\"Subscribe customer to strip plan.\"\"\"\n    plan_stripe_ids = [STRIPE_DEFAULT_PLAN_ID]\n\n    return stripe.Subscription.create(\n        customer=customer_stripe_id,\n        items=[{\"plan\": plan_id} for plan_id in plan_stripe_ids],\n    )\n\n\ndef cancel_subscription(subscription_stripe_id):\n    \"\"\"Cancel someones subscription.\"\"\"\n    stripe.Subscription.delete(subscription_stripe_id)\n\n\ndef get_product_plans(product_strip_id):\n    pass\n"}
{"type": "source_file", "path": "app/controllers/__init__.py", "content": ""}
{"type": "source_file", "path": "app/controllers/auth.py", "content": "from datetime import datetime, timedelta\n\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session\nfrom starlette.status import HTTP_401_UNAUTHORIZED\nimport jwt\n\nfrom app.dependencies import get_db\nfrom app.schemas.auth import Token\nfrom app.schemas.account import Account\nfrom app.controllers.account import get_account\nfrom app.controllers.account import get_account_by_email\nfrom app.models.account import Password\nfrom app.settings import SECRET_KEY\nfrom app.settings import ACCESS_TOKEN_EXPIRE_MINUTES\n\n# to get a string like this run:\n# openssl rand -hex 32\nALGORITHM = \"HS256\"\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/token\")\n\n\ndef authenticate_user(db_session: Session, username: str, plaintext_password: str):\n    account_obj = get_account_by_email(db_session, email=username)\n\n    # Must have an account.\n    if not account_obj:\n        return False\n\n    password_obj = (\n        db_session.query(Password)\n        .filter_by(account_id=account_obj.id)\n        .order_by(Password.created_on.desc())\n        .first()\n    )\n    if not password_obj.is_correct_password(plaintext_password):\n        return False\n    return account_obj\n\n\ndef create_access_token(*, data: dict, expires_delta: timedelta = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n"}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/config.py", "content": "from starlette.config import Config\n\nconfig = Config(\".env\")\n"}
{"type": "source_file", "path": "app/models/account.py", "content": "\"\"\"Account based models.\"\"\"\nfrom sqlalchemy import (\n    Boolean,\n    Column,\n    ForeignKey,\n    Integer,\n    String,\n    DateTime,\n    LargeBinary,\n)\nfrom sqlalchemy.orm import relationship, backref\nfrom sqlalchemy.ext.hybrid import hybrid_property, hybrid_method\nfrom passlib.context import CryptContext\n\nfrom app.models.base import BaseModel\n\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\nclass Account(BaseModel):\n    __tablename__ = \"accounts\"\n\n    id = Column(Integer, primary_key=True, index=True)\n\n    first_name = Column(String(100))\n    last_name = Column(String(100))\n\n    is_system_admin = Column(Boolean, default=False)\n    is_active = Column(Boolean, default=False)\n\n    def __repr__(self):\n        return \"<Account {} - {} {}>\".format(self.id, self.first_name, self.last_name)\n\n    @property\n    def email(self):\n        return self.email_addresses.filter_by(primary=True).first().email\n\n    @property\n    def primary_email_address(self):\n        return self.email_addresses.filter_by(primary=True).first()\n\n    @property\n    def full_name(self):\n        return \"{} {}\".format(self.first_name, self.last_name)\n\n\nclass EmailAddress(BaseModel):\n    __tablename__ = \"email_addresses\"\n\n    id = Column(Integer, primary_key=True)\n    # uuid = Column(\n    #     UUID(as_uuid=True), unique=True, nullable=False, default=uuid.uuid4\n    # )\n\n    account_id = Column(\n        Integer, ForeignKey(\"accounts.id\", ondelete=\"CASCADE\"), nullable=True\n    )\n    account = relationship(\n        \"Account\",\n        backref=backref(\"email_addresses\", passive_deletes=True, lazy=\"dynamic\"),\n    )\n\n    email = Column(String(256), unique=True, nullable=False)\n    primary = Column(Boolean(), nullable=True)\n    verified = Column(Boolean(), nullable=True)\n    verified_on = Column(DateTime, nullable=True)\n\n    def __repr__(self):\n        return \"<EmailAddress {}>\".format(self.email)\n\n\nclass Password(BaseModel):\n    __tablename__ = \"passwords\"\n\n    id = Column(Integer, primary_key=True)\n\n    account_id = Column(\n        Integer, ForeignKey(\"accounts.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    account = relationship(\n        \"Account\", backref=backref(\"passwords\", passive_deletes=True), lazy=True\n    )\n\n    # _password = Column(LargeBinary(256), nullable=False)\n    _password = Column(String(256), nullable=False)\n\n    def __repr__(self):\n        return \"<Password %r>\".format(self.account_id)\n\n    def validate_password(self, plaintext_password):\n        \"\"\"If invalid raise ValidationError, else return True\"\"\"\n\n        if len(plaintext_password) < 8:\n            raise Exception(\"Password must be at 8 or more characters long.\")\n\n        return True\n\n    @hybrid_property\n    def password(self):\n        return self._password\n\n    @password.setter\n    def password(self, plain_password):\n        self.validate_password(plain_password)\n        self._password = pwd_context.hash(plain_password)\n\n    @hybrid_method\n    def is_correct_password(self, plain_password):\n        return pwd_context.verify(plain_password, self.password)\n\n\n# class PasswordReset(BaseModel):\n#     id = Column(Integer, primary_key=True)\n\n#     account_id = Column(\n#         Integer, ForeignKey(\"account.id\", ondelete=\"CASCADE\"), nullable=False\n#     )\n#     account = relationship(\n#         \"Account\",\n#         backref=backref(\"password_resets\", passive_deletes=True),\n#         lazy=True,\n#     )\n\n#     token = Column(String(1024), nullable=False)\n\n#     def __repr__(self):\n#         return \"<Password %r>\".format(self.account_id)\n\n#     @hybrid_method\n#     def is_valid(self):\n#         from flask_jwt_extended import decode_token\n\n#         try:\n#             decode_token(self.token)\n#             return True\n#         except (jwt.DecodeError, jwt.ExpiredSignatureError):\n#             return False\n"}
{"type": "source_file", "path": "app/models/__init__.py", "content": ""}
{"type": "source_file", "path": "app/controllers/members.py", "content": "\"\"\"\nControl the members that are apart of a Tenant.\n\"\"\"\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\n\nfrom app.schemas import tenant as schemas\nfrom app.models.tenant import Tenant, TenantAccount\nfrom app.models.account import EmailAddress\nfrom app.controllers.billing import stripe\nfrom app.controllers.account import create_account\nfrom app.controllers.account import get_account_by_email\nfrom app.utils.email import send_email\nfrom app.settings import FRONTEND_BASE_URL\nfrom app.settings import LOGIN_URL_PATH\n\n\ndef get_members(db_session: Session, tenant_id: int, skip: int = 0, limit: int = 100):\n    return (\n        db_session.query(TenantAccount)\n        .filter(TenantAccount.tenant_id == tenant_id)\n        .offset(skip)\n        .limit(limit)\n        .all()\n    )\n\n\ndef get_member_by_email(db_session: Session, tenant_id: int, email: str):\n    \"\"\"Return the member if they are apart of this tenant.\"\"\"\n    account_obj = get_account_by_email(db_session, email)\n    # Check if email address exists.\n    return (\n        db_session.query(TenantAccount)\n        .filter(\n            TenantAccount.tenant_id == tenant_id, TenantAccount.account == account_obj\n        )\n        .first()\n    )\n\n\ndef add_member(\n    db_session: Session, tenant_id: int, email: str, do_send_email: bool = True\n):\n    \"\"\"Add a new member to the tenant.\"\"\"\n    tenant_obj = db_session.query(Tenant).get(tenant_id)\n    # If email address:\n    email_obj = (\n        db_session.query(EmailAddress).filter(EmailAddress.email == email).first()\n    )\n    if email_obj and email_obj.account:\n        # Account already exists, go ahead and add them.\n        tenant_account_obj = TenantAccount()\n        tenant_account_obj.tenant_id = tenant_id\n        tenant_account_obj.account_id = email_obj.account_id\n        db_session.add(tenant_account_obj)\n        db_session.commit()\n\n        # TODO: Send email telling them we added them.\n        if do_send_email:\n            # send_email()\n            # Send the email!\n            send_email(\n                to_email=email,\n                subject=f\"You've been added to {tenant_obj.name}\",\n                body=(\n                    f\"Weclome to {tenant_obj.name}.\"\n                    f\"<p />You have been invited into the new group. Please use the link below to login.\"\n                    f\"<p /><a href='{FRONTEND_BASE_URL}{LOGIN_URL_PATH}'>Login</a>\"\n                ),\n            )\n    else:\n        # Never been apart of this site.\n        # Create relationship\n        tenant_account_obj = TenantAccount()\n        tenant_account_obj.tenant_id = tenant_id\n        tenant_account_obj.email_address = email\n        db_session.add(tenant_account_obj)\n        db_session.commit()\n        # Send registration invite.\n"}
{"type": "source_file", "path": "app/database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\n# SQLALCHEMY_DATABASE_URL = \"sqlite://\"\nSQLALCHEMY_DATABASE_URL = \"postgresql://postgres:password@db/db\"\n\n\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\n\nDBSession = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nBase = declarative_base()\nBase.metadata.bind = engine\n"}
{"type": "source_file", "path": "app/routers/__init__.py", "content": ""}
{"type": "source_file", "path": "app/models/tenant.py", "content": "\"\"\"Tenant models.\"\"\"\nfrom sqlalchemy import (\n    Boolean,\n    Column,\n    ForeignKey,\n    Integer,\n    String,\n    DateTime,\n    LargeBinary,\n)\nfrom sqlalchemy.orm import relationship, backref\nfrom sqlalchemy.ext.hybrid import hybrid_property, hybrid_method\n\nfrom app.models.base import BaseModel\n\n\nclass Tenant(BaseModel):\n    \"\"\"A customer/workspace in the system.\"\"\"\n\n    __tablename__ = \"tenants\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(128))\n    slug = Column(String(128), unique=True)  # Slug of the name for the URL.\n\n    billing_email = Column(String(256), unique=True, nullable=True)\n    stripe_customer_id = Column(String(128), unique=True, nullable=True)\n    stripe_subscription_id = Column(String(128), unique=True, nullable=True)\n\n    def __repr__(self):\n        return \"<Tenant {} - {}>\".format(self.id, self.name)\n\n\nclass TenantAccount(BaseModel):\n    \"\"\"\n    Through table for M2M relationship between a Tenant and Accounts.\n    \"\"\"\n\n    __tablename__ = \"tenant_account\"\n    id = Column(Integer, primary_key=True, index=True)\n\n    tenant_id = Column(\n        Integer, ForeignKey(\"tenants.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    tenant = relationship(\n        \"Tenant\",\n        backref=backref(\"accounts\", passive_deletes=True, lazy=\"dynamic\"),\n        lazy=True,\n    )\n\n    account_id = Column(\n        Integer, ForeignKey(\"accounts.id\", ondelete=\"CASCADE\"), nullable=True\n    )\n    account = relationship(\n        \"Account\",\n        backref=backref(\"tenants\", passive_deletes=True, lazy=\"dynamic\"),\n        lazy=True,\n    )\n\n    # Use this field in case the user doesn't have an account yet.\n    email_address = Column(String, nullable=True)\n\n    def __repr__(self):\n        return \"<TenantAccount {} - Tenant ID: {} - Account ID: {}>\".format(\n            self.id, self.tenant_id, self.account_id\n        )\n"}
{"type": "source_file", "path": "app/controllers/tenant.py", "content": "from sqlalchemy.orm import Session\nfrom fastapi import Depends\n\nfrom app.schemas import tenant as schemas\nfrom app.models.tenant import Tenant, TenantAccount\n\nfrom app.controllers.billing import stripe\nfrom app.controllers.account import create_account\n\n\ndef get_tenant(db_session: Session, id: int):\n    return db_session.query(Tenant).filter(Tenant.id == id).first()\n\n\ndef get_tenants(db_session: Session, skip: int = 0, limit: int = 100):\n    return db_session.query(Tenant).offset(skip).limit(limit).all()\n\n\ndef add_account_to_tenant(db_session: Session, account_id, tenant_id):\n    \"\"\"Create relationship between tenant and account.\"\"\"\n\n    tenant_account_obj = TenantAccount(tenant_id=tenant_id, account_id=account_id)\n\n    db_session.add(tenant_account_obj)\n    db_session.commit()\n    return tenant_account_obj\n\n\ndef create_tenant_and_account(\n    db_session: Session,\n    name: str,\n    slug: str,\n    first_name: str,\n    last_name: str,\n    email: str,\n    password: str,\n    is_active: bool = False,\n    is_verified: bool = False,\n    do_send_emails: bool = True\n):\n    \"\"\"Create a tenant and an account.\"\"\"\n\n    tenant_obj = Tenant(name=name, slug=slug, billing_email=email)\n    db_session.add(tenant_obj)\n    db_session.flush()\n\n    # New tenant = New Customer in stripe.\n    customer_resp = stripe.Customer.create(\n        email=email,\n        description=\"Customer for {}<{}>\".format(name, email),\n        name=name,\n        metadata={\"tenant_id\": tenant_obj.id},\n    )\n\n    # Record the Customer ID from stripe.\n    tenant_obj.stripe_customer_id = customer_resp.get(\"id\")\n\n    db_session.commit()\n\n    # Create account\n    account_obj = create_account(\n        db_session,\n        first_name,\n        last_name,\n        email,\n        password,\n        is_active=is_active,\n        is_verified=is_verified,\n        send_registration_email=do_send_emails\n    )\n\n    # Add relationship between account to tenant.\n    add_account_to_tenant(db_session, account_obj.id, tenant_obj.id)\n\n    db_session.refresh(tenant_obj)\n\n    return tenant_obj\n\n\ndef get_tenant_by_name(db_session: Session, name: str):\n    \"\"\"Get a tenant by name.\"\"\"\n    return db_session.query(Tenant).filter(Tenant.name == name).first()\n"}
{"type": "source_file", "path": "app/dependencies/__init__.py", "content": "from app.database import DBSession\n\n# Dependency\ndef get_db():\n    try:\n        db_session = DBSession()\n        yield db_session\n    finally:\n        db_session.close()\n"}
{"type": "source_file", "path": "app/dependencies/auth.py", "content": "from fastapi import Depends, FastAPI, HTTPException\n\nfrom sqlalchemy.orm import Session\nfrom starlette.status import HTTP_401_UNAUTHORIZED\nimport jwt\nfrom jwt import PyJWTError\n\nfrom app.dependencies import get_db\nfrom app.controllers.auth import oauth2_scheme, SECRET_KEY, ALGORITHM, get_account\nfrom app.schemas.auth import TokenData\n\n\nasync def get_current_account(\n    db_session: Session = Depends(get_db), token: str = Depends(oauth2_scheme)\n):\n    credentials_exception = HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        account_id: str = payload.get(\"sub\")\n        if account_id is None:\n            raise credentials_exception\n        token_data = TokenData(account_id=account_id)\n    except PyJWTError:\n        raise credentials_exception\n    account = get_account(db_session, id=token_data.account_id)\n    if account is None:\n        raise credentials_exception\n    return account\n\n\n# async def get_current_active_account(current_user: Account = Depends(get_current_account)):\n#     if current_user.disabled:\n#         raise HTTPException(status_code=400, detail=\"Inactive user\")\n#     return current_user\n"}
{"type": "source_file", "path": "app/models/base.py", "content": "import datetime\n\nfrom sqlalchemy import Column, DateTime\n\nfrom app.database import Base\n\n\nclass BaseModel(Base):\n    \"\"\"Base data model for all objects\"\"\"\n\n    __abstract__ = True\n\n    created_on = Column(DateTime, nullable=False, default=datetime.datetime.utcnow)\n    updated_on = Column(DateTime, nullable=True, onupdate=datetime.datetime.utcnow)\n"}
{"type": "source_file", "path": "app/main.py", "content": "from typing import List\n\nfrom fastapi import Depends, FastAPI, Header, HTTPException\nimport uvicorn\nfrom sqlalchemy.orm import Session\n\nfrom app.dependencies import get_db\nfrom app.dependencies.auth import get_current_account\nfrom app.database import engine, Base\n\nfrom app.routers import accounts\nfrom app.routers import auth\nfrom app.routers import email_addresses\nfrom app.routers import members\nfrom app.routers import tenants\n\n# Create tables in database.\nBase.metadata.create_all(bind=engine)\n\n# Initialize FastAPI\napp = FastAPI(\n    title=\"FastAPI Base\",\n    description=\"This is a base app to be used in the future for real SAAS apps and hackathons.\",\n    version=\"0.0.1\",\n    docs_url=\"/docs\",\n    redoc_url=None,\n)\n\n# Startup Actions\n@app.on_event(\"startup\")\nasync def create_admin():\n    \"\"\"If admin account doesn't exist, create it.\"\"\"\n    from app.database import DBSession\n    from app.controllers.account import create_account\n    from app.controllers.account import get_account_by_email\n\n    db_session = DBSession()\n    account_data = {\n        \"email\": \"admin@example.com\",\n        \"password\": \"password123\",\n        \"first_name\": \"Admin\",\n        \"last_name\": \"Istrator\",\n        \"is_system_admin\": True,\n        \"is_active\": True,\n    }\n    account_obj = get_account_by_email(db_session, email=account_data[\"email\"])\n    if account_obj:\n        return\n\n    create_account(db_session, **account_data)\n    db_session.close()\n\n\n# Add routers\napp.include_router(\n    auth.router,\n    prefix=\"/auth\",\n    tags=[\"auth\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\napp.include_router(\n    accounts.router,\n    prefix=\"/accounts\",\n    tags=[\"accounts\"],\n    dependencies=[Depends(get_current_account)],\n    responses={404: {\"description\": \"Not found\"}},\n)\napp.include_router(\n    email_addresses.router,\n    prefix=\"/email_addresses\",\n    tags=[\"email_addresses\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\napp.include_router(\n    members.router,\n    prefix=\"/members\",\n    tags=[\"members\"],\n    dependencies=[Depends(get_current_account)],\n    responses={404: {\"description\": \"Not found\"}},\n)\napp.include_router(\n    tenants.router,\n    prefix=\"/tenants\",\n    tags=[\"tenants\"],\n    dependencies=[Depends(get_current_account)],\n    responses={404: {\"description\": \"Not found\"}},\n)\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"}
{"type": "source_file", "path": "app/routers/accounts.py", "content": "from typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom app.dependencies import get_db\nfrom app.schemas import account as schemas\nfrom app.controllers.account import get_account_by_email\nfrom app.controllers.account import get_account\nfrom app.controllers.account import get_accounts\nfrom app.controllers.account import create_account\nfrom app.dependencies.auth import get_current_account\n\nrouter = APIRouter()\n\n\n@router.post(\"/\", response_model=schemas.Account)\ndef create_one(\n    account: schemas.AccountCreate,\n    db_session: Session = Depends(get_db),\n    current_user: schemas.Account = Depends(get_current_account),\n):\n    db_account = get_account_by_email(db_session, email=account.email)\n    if db_account:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n\n    # Can not create a system admin if you yourself are not one.\n    if not current_user.is_system_admin:\n        account.is_system_admin = False\n\n    return create_account(\n        db_session,\n        account.first_name,\n        account.last_name,\n        account.email,\n        account.password,\n        account.is_system_admin,\n    )\n\n\n@router.get(\"/\", response_model=List[schemas.Account])\ndef read_many(skip: int = 0, limit: int = 100, db_session: Session = Depends(get_db)):\n    accounts = get_accounts(db_session, skip=skip, limit=limit)\n    return accounts\n\n\n@router.get(\"/me\", response_model=schemas.Account)\nasync def read_me(current_user: schemas.Account = Depends(get_current_account)):\n    \"\"\"Get logged in user details.\"\"\"\n    return current_user\n\n\n@router.get(\"/{id}\", response_model=schemas.Account)\ndef read_one(id: int, db_session: Session = Depends(get_db)):\n    db_account = get_account(db_session, id=id)\n    if db_account is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return db_account\n"}
{"type": "source_file", "path": "app/dependencies/tenant.py", "content": "from fastapi import Depends, FastAPI, HTTPException\n\nfrom sqlalchemy.orm import Session\n\nfrom app.dependencies import get_db\nfrom app.models.tenant import Tenant\n\n\nasync def get_tenant(tenant_id: int = None, db_session: Session = Depends(get_db)):\n    \"\"\"Get the tenant id from the url.\"\"\"\n    if not tenant_id:\n        return None\n    return db_session.query(Tenant).get(tenant_id)\n"}
{"type": "source_file", "path": "app/schemas/auth.py", "content": "from pydantic import BaseModel\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    account_id: int = None\n"}
{"type": "source_file", "path": "app/schemas/account.py", "content": "from datetime import datetime\nfrom typing import List\n\nfrom pydantic import BaseModel\n\n\nclass AccountBase(BaseModel):\n    email: str\n    first_name: str\n    last_name: str\n\n\nclass AccountCreate(AccountBase):\n    password: str\n    is_system_admin: bool\n\n\nclass Account(AccountBase):\n    id: int\n    is_system_admin: bool\n\n    class Config:\n        orm_mode = True\n\n\nclass EmailAddressBase(BaseModel):\n    email: str\n\n\nclass EmailAddressCreate(EmailAddressBase):\n    account_id: int = None\n\n\nclass EmailAddress(EmailAddressBase):\n    id: int\n    primary: bool\n    verified: bool\n    verified_on: datetime = None\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "app/schemas/__init__.py", "content": "from .account import Account, AccountCreate\nfrom .auth import Token, TokenData\nfrom .tenant import Tenant, TenantCreate, TenantDetails\n"}
{"type": "source_file", "path": "app/routers/tenants.py", "content": "from typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom app.dependencies import get_db\nimport app.schemas as schemas\nfrom app.controllers.tenant import get_tenant_by_name\nfrom app.controllers.tenant import get_tenant\nfrom app.controllers.tenant import get_tenants\n\n# from app.controllers.tenant import create_tenant\nfrom app.dependencies.auth import get_current_account\n\nrouter = APIRouter()\n\n# @router.post(\"/\", response_model=schemas.Tenant)\n# def create_one(tenant: schemas.TenantCreate, db_session: Session = Depends(get_db), current_user: schemas.Account = Depends(get_current_account)):\n#     db_tenant = get_tenant_by_name(db_session, name=tenant.name)\n#     if db_tenant:\n#         raise HTTPException(status_code=400, detail=\"Name already registered\")\n\n#     return create_tenant(db_session, tenant=tenant)\n\n\n@router.get(\"/\", response_model=List[schemas.Tenant])\ndef read_many(skip: int = 0, limit: int = 100, db_session: Session = Depends(get_db)):\n    tenants = get_tenants(db_session, skip=skip, limit=limit)\n    return tenants\n\n\n@router.get(\"/{id}\", response_model=schemas.TenantDetails)\ndef read_one(id: int, db_session: Session = Depends(get_db)):\n    db_tenant = get_tenant(db_session, id=id)\n    if db_tenant is None:\n        raise HTTPException(status_code=404, detail=\"Tenant not found\")\n    return db_tenant\n"}
{"type": "source_file", "path": "app/routers/members.py", "content": "from typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom starlette.status import HTTP_201_CREATED, HTTP_200_OK\n\nfrom app.dependencies import get_db\nfrom app.schemas import member as schemas\nfrom app.schemas.account import Account as AccountSchema\nfrom app.controllers.members import get_members\nfrom app.controllers.members import get_member_by_email\nfrom app.controllers.members import add_member\nfrom app.dependencies.auth import get_current_account\n\nrouter = APIRouter()\n\n\n@router.get(\"\", response_model=List[schemas.TenantAccount], status_code=HTTP_200_OK)\ndef read_many(\n    skip: int = 0,\n    limit: int = 100,\n    tenant_id: int = None,\n    db_session: Session = Depends(get_db),\n):\n    return get_members(db_session, tenant_id=tenant_id, skip=skip, limit=limit)\n\n\n@router.post(\"\", response_model=schemas.MemberCreate, status_code=HTTP_201_CREATED)\ndef add_one(\n    member: schemas.MemberCreate,\n    db_session: Session = Depends(get_db),\n    current_user: AccountSchema = Depends(get_current_account),\n):\n    # Make sure email isn't already added.\n    db_member = get_member_by_email(\n        db_session, tenant_id=member.tenant_id, email=member.email\n    )\n    if db_member:\n        raise HTTPException(status_code=400, detail=\"Account has already been invited.\")\n\n    # Invite the user.\n    return add_member(db_session, tenant_id=member.tenant_id, email=member.email)\n"}
{"type": "source_file", "path": "app/routers/email_addresses.py", "content": "from typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom starlette.status import HTTP_201_CREATED, HTTP_200_OK\n\nfrom app.dependencies import get_db\nfrom app.schemas import account as schemas\nfrom app.controllers.account import (\n    get_email_addresses,\n    create_email_address,\n    get_account_by_email,\n    verify_email_address,\n)\nfrom app.dependencies.auth import get_current_account\n\nrouter = APIRouter()\n\n\n@router.post(\"/verify\", status_code=HTTP_200_OK)\ndef verify_email(token: str = \"\", db_session: Session = Depends(get_db)):\n    verify_email_address(db_session, token)\n    return\n\n\n@router.post(\"\", response_model=schemas.EmailAddress, status_code=HTTP_201_CREATED)\ndef create_one(\n    email: schemas.EmailAddressCreate,\n    db_session: Session = Depends(get_db),\n    current_user: schemas.Account = Depends(get_current_account),\n):\n    # Can not add an email address that is already in use.\n    db_email = get_account_by_email(db_session, email=email.email)\n    if db_email:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n\n    # Set the account_id from the current logged in user.\n    account_id = current_user.id\n\n    return create_email_address(db_session, email.email, account_id)\n\n\n@router.get(\"\", response_model=List[schemas.EmailAddress], status_code=HTTP_200_OK)\ndef read_many(\n    skip: int = 0,\n    limit: int = 100,\n    db_session: Session = Depends(get_db),\n    current_user: schemas.Account = Depends(get_current_account),\n):\n    return get_email_addresses(\n        db_session, account_id=current_user.id, skip=skip, limit=limit\n    )\n"}
{"type": "source_file", "path": "app/schemas/tenant.py", "content": "from datetime import datetime\nfrom typing import List\n\nfrom pydantic import BaseModel\n\n\nclass TenantBase(BaseModel):\n    name: str\n\n\nclass TenantCreate(TenantBase):\n    billing_email: str\n\n\nclass Tenant(TenantBase):\n    id: int\n    slug: str\n\n    class Config:\n        orm_mode = True\n\n\nclass TenantDetails(Tenant):\n    billing_email: str\n\n\nclass TenantAccountCreate(BaseModel):\n    name: str\n    slug: str\n    first_name: str\n    last_name: str\n    email: str\n    password: str\n"}
{"type": "source_file", "path": "app/settings.py", "content": "from starlette.config import Config\nfrom starlette.datastructures import URL, Secret\n\n\nconfig = Config(\".env\")\n\nTESTING = config('TESTING', cast=bool, default=False)\n\nSECRET_KEY = config(\"SECRET_KEY\", cast=str, default=False)\n\nFRONTEND_BASE_URL = config(\"FRONTEND_BASE_URL\", cast=str, default=\"\")\nLOGIN_URL_PATH = config(\"LOGIN_URL_PATH\", cast=str, default=\"/login\")\n\nEMAIL_TOKEN_EXPIRE_MINUTES = config(\"EMAIL_TOKEN_EXPIRE_MINUTES\", cast=int, default=30)\nACCESS_TOKEN_EXPIRE_MINUTES = config(\"ACCESS_TOKEN_EXPIRE_MINUTES\", cast=int, default=30)\n\nSMTP_HOST = config(\"SMTP_HOST\", cast=str, default=False)\nSMTP_PORT = config(\"SMTP_PORT\", cast=str, default=False)\nSMTP_USERNAME = config(\"SMTP_USERNAME\", cast=str, default=False)\nSMTP_PASSWORD = config(\"SMTP_PASSWORD\", cast=str, default=False)\n\nSTRIPE_API_SECRET = config(\"STRIPE_API_SECRET\", cast=str, default=False)\nSTRIPE_DEFAULT_PLAN_ID = config(\"STRIPE_DEFAULT_PLAN_ID\", cast=str, default=False)"}
{"type": "source_file", "path": "app/routers/auth.py", "content": "from datetime import datetime, timedelta\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session\nfrom starlette.status import HTTP_200_OK, HTTP_401_UNAUTHORIZED, HTTP_201_CREATED, HTTP_409_CONFLICT\n\nfrom app.dependencies import get_db\nfrom app.controllers.auth import (\n    ACCESS_TOKEN_EXPIRE_MINUTES,\n    Token,\n    authenticate_user,\n    create_access_token,\n)\nfrom app.dependencies.auth import get_current_account\nfrom app.schemas.tenant import TenantAccountCreate\nfrom app.controllers.tenant import create_tenant_and_account\nfrom app.controllers.account import mark_account_as_verified_and_active\n\nrouter = APIRouter()\n\n\n@router.post(\"/verify\", status_code=HTTP_200_OK)\ndef verify_account(token: str = \"\", db_session: Session = Depends(get_db)):\n    mark_account_as_verified_and_active(db_session, token)\n    return\n\n\n@router.post(\"/token\", response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends(),\n    db_session: Session = Depends(get_db),\n):\n    account_obj = authenticate_user(db_session, form_data.username, form_data.password)\n    if not account_obj:\n        raise HTTPException(\n            status_code=HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    # Account must be active.\n    if not account_obj.is_active:\n        raise HTTPException(\n            status_code=HTTP_409_CONFLICT, detail=\"Account disabled\",\n        )\n\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": account_obj.id}, expires_delta=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n\n@router.post(\"/register\", status_code=HTTP_201_CREATED)\ndef register(\n    tenant_account: TenantAccountCreate, db_session: Session = Depends(get_db)\n):\n    tenant_obj = create_tenant_and_account(\n        db_session,\n        tenant_account.name,\n        tenant_account.slug,\n        tenant_account.first_name,\n        tenant_account.last_name,\n        tenant_account.email,\n        tenant_account.password,\n    )\n    if not tenant_obj:\n        raise HTTPException(\n            status_code=HTTP_401_UNAUTHORIZED,\n            detail=\"Error creating new account/tenant.\",\n        )\n    return {\"msg\": \"Please check your email.\"}\n"}
{"type": "source_file", "path": "app/schemas/member.py", "content": "from datetime import datetime\nfrom typing import List\n\nfrom pydantic import BaseModel\n\n\nclass TenantAccount(BaseModel):\n    id: int\n    account_id: int\n    tenant_id: int\n\n    class Config:\n        orm_mode = True\n\n\nclass MemberCreate(BaseModel):\n    tenant_id: int\n    email: str\n"}
{"type": "source_file", "path": "app/utils/email.py", "content": "from email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom typing import Union, Optional, List\nimport smtplib\n\nfrom jinja2 import Template\n\nfrom app.settings import TESTING\nfrom app.settings import SMTP_HOST\nfrom app.settings import SMTP_PORT\nfrom app.settings import SMTP_USERNAME\nfrom app.settings import SMTP_PASSWORD\n\ndef send_email(to_email: str, subject: str, body: str):\n    \"\"\"Send an email.\"\"\"\n    msg = MIMEMultipart(\"alternative\")\n    # me == the sender's email address\n    # you == the recipient's email address\n    msg[\"Subject\"] = subject\n    msg[\"From\"] = \"noreply@example.com\"\n    msg[\"To\"] = to_email\n\n    # Get the contents of the template.\n    with open(\"app/templates/email/empty.html\", \"r\") as template:\n        # Parse\n        template = Template(template.read())\n\n    # inject the body.\n    text = body\n    html = template.render(body=body)\n\n    msg.attach(MIMEText(text, \"plain\"))\n    msg.attach(MIMEText(html, \"html\"))\n    \n    if TESTING:\n        # Do not send an actual email if unittesting.\n        return\n\n    smtpObj = smtplib.SMTP(SMTP_HOST)\n    smtpObj.send_message(msg)\n"}

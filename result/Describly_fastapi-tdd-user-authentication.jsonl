{"repo_info": {"repo_name": "fastapi-tdd-user-authentication", "repo_owner": "Describly", "repo_url": "https://github.com/Describly/fastapi-tdd-user-authentication"}}
{"type": "test_file", "path": "tests/test_user_routes/test_user_registration.py", "content": "from tests.conftest import USER_NAME, USER_EMAIL, USER_PASSWORD\n\ndef test_create_user(client):\n    data = {\n        \"name\": USER_NAME,\n        \"email\": USER_EMAIL,\n        \"password\": USER_PASSWORD\n    }\n    response = client.post('/users', json=data)\n    assert response.status_code == 201\n    assert \"password\" not in response.json()\n    \n\ndef test_create_user_with_existing_email(client, inactive_user):\n    data = {\n        \"name\": \"Keshari Nandan\",\n        \"email\": inactive_user.email,\n        \"password\": USER_PASSWORD\n    }\n    response = client.post(\"/users/\", json=data)\n    assert response.status_code != 201\n\n\ndef test_create_user_with_invalid_email(client):\n    data = {\n        \"name\": \"Keshari Nandan\",\n        \"email\": \"keshari.com\",\n        \"password\": USER_PASSWORD\n    }\n    response = client.post(\"/users/\", json=data)\n    assert response.status_code != 201\n\n\ndef test_create_user_with_empty_password(client):\n    data = {\n        \"name\": \"Keshari Nandan\",\n        \"email\": USER_EMAIL,\n        \"password\": \"\"\n    }\n    response = client.post(\"/users/\", json=data)\n    assert response.status_code != 201\n\n\ndef test_create_user_with_numeric_password(client):\n    data = {\n        \"name\": \"Keshari Nandan\",\n        \"email\": USER_EMAIL,\n        \"password\": \"1232382318763\"\n    }\n    response = client.post(\"/users/\", json=data)\n    assert response.status_code != 201\n\n\ndef test_create_user_with_char_password(client):\n    data = {\n        \"name\": \"Keshari Nandan\",\n        \"email\": USER_EMAIL,\n        \"password\": \"asjhgahAdF\"\n    }\n    response = client.post(\"/users/\", json=data)\n    assert response.status_code != 201\n\n\ndef test_create_user_with_alphanumeric_password(client):\n    data = {\n        \"name\": \"Keshari Nandan\",\n        \"email\": USER_EMAIL,\n        \"password\": \"sjdgajhGG27862\"\n    }\n    response = client.post(\"/users/\", json=data)\n    assert response.status_code != 201"}
{"type": "test_file", "path": "tests/test_user_routes/test_user_login.py", "content": "\"\"\"\n1. User should be able to login\n2. User should not be able to login with incorrect password\n3. Inactive user should not be able to login.\n4. Unverified user should not be able to login.\n.....\n\"\"\"\n\nfrom tests.conftest import USER_PASSWORD\n\n\ndef test_user_login(client, test_session, user):\n    data = {'username': user.email, 'password': USER_PASSWORD}\n    response = client.post('/auth/login', data=data)\n    assert response.status_code == 200\n    assert response.json()['access_token'] is not None\n    assert response.json()['refresh_token'] is not None\n    assert response.json()['expires_in'] is not None\n\n\ndef test_user_login_wrong_password(client, user):\n    response = client.post('/auth/login', data={'username': user.email, 'password': 'wrong_password'})\n    assert response.status_code == 400\n    assert response.json()['detail'] == 'Incorrect email or password.'\n\n\ndef test_user_login_wrong_email(client):\n    response = client.post('/auth/login', data={'username': 'abc@describly.com', 'password': USER_PASSWORD})\n    assert response.status_code == 400\n\n\ndef test_user_login_inactive_account(client, inactive_user):\n    response = client.post('/auth/login', data={'username': inactive_user.email, 'password': USER_PASSWORD})\n    assert response.status_code == 400\n\n\ndef test_user_login_unverified(client, unverified_user):\n    response = client.post('/auth/login', data={'username': unverified_user.email, 'password': USER_PASSWORD})\n    assert response.status_code == 400"}
{"type": "test_file", "path": "tests/test_user_routes/test_reset_password.py", "content": "\"\"\"\n1. User should be able to reset his password with conmbination of valid token and valid email\n2. User can not reset password with invalid token\n3. User can not reset password with invalid email\n4. User can not reset password with any email and valid token\n\"\"\"\n\nfrom app.config.security import hash_password\nfrom app.utils.email_context import FORGOT_PASSWORD\n\n\nNEW_PASSWORD = \"321#Describly\"\n\ndef _get_token(user):\n    string_context = user.get_context_string(context=FORGOT_PASSWORD)\n    return hash_password(string_context)\n\ndef test_reset_password(client, user):\n    data = {\n        \"token\": _get_token(user),\n        \"email\": user.email,\n        \"password\": NEW_PASSWORD\n    }\n    response = client.put(\"/auth/reset-password\", json=data)\n    assert response.status_code == 200\n    del data['token']\n    del data['email']\n    data['username'] = user.email\n    login_resp = client.post(\"/auth/login\", data=data)\n    assert login_resp.status_code == 200\n    \ndef test_reset_password_invalid_token(client, user):\n    data = {\n        \"token\": \"sakjdhajksdhaksjhdjkadh\",\n        \"email\": user.email,\n        \"password\": NEW_PASSWORD\n    }\n    response = client.put(\"/auth/reset-password\", json=data)\n    assert response.status_code == 400\n    del data['token']\n    del data['email']\n    data['username'] = user.email\n    login_resp = client.post(\"/auth/login\", data=data)\n    assert login_resp.status_code != 200\n    \ndef test_reset_password_invalid_email(client, user):\n    data = {\n        \"token\": _get_token(user),\n        \"email\": \"describly.com\",\n        \"password\": NEW_PASSWORD\n    }\n    response = client.put(\"/auth/reset-password\", json=data)\n    assert response.status_code == 422\n    del data['token']\n    del data['email']\n    data['username'] = user.email\n    login_resp = client.post(\"/auth/login\", data=data)\n    assert login_resp.status_code != 200\n    \ndef test_reset_password_invalid_email(client, user):\n    data = {\n        \"token\": _get_token(user),\n        \"email\": \"nandan@describly.com\",\n        \"password\": NEW_PASSWORD\n    }\n    response = client.put(\"/auth/reset-password\", json=data)\n    assert response.status_code == 400\n    del data['token']\n    del data['email']\n    data['username'] = user.email\n    login_resp = client.post(\"/auth/login\", data=data)\n    assert login_resp.status_code != 200\n"}
{"type": "test_file", "path": "tests/test_user_routes/test_refresh_token.py", "content": "\"\"\"\n1. User shoud be able to generate the login token with valid refresh token.\n2. User should not be able to generate login token with invalid refresh token.\n.....\n\"\"\"\n\nimport logging\nfrom app.services.user import _generate_tokens\n\n\ndef test_refresh_token(client, user, test_session):\n    data = _generate_tokens(user, test_session)\n    header = {\n        \"refresh-token\": data['refresh_token']\n    }\n    response = client.post(\"/auth/refresh\", json={}, headers=header)\n    assert response.status_code == 200\n    assert 'access_token' in response.json()\n    assert 'refresh_token' in response.json()\n    \ndef test_refresh_token_with_invalid_token(client, user, test_session):\n    data = _generate_tokens(user, test_session)\n    header = {\n        \"refresh-token\": 'sakdhasjkdhahdjkahdjka'\n    }\n    response = client.post(\"/auth/refresh\", json={}, headers=header)\n    assert response.status_code == 400\n    assert 'access_token' not in response.json()\n    assert 'refresh_token' not in response.json()"}
{"type": "test_file", "path": "tests/test_user_routes/test_get_user.py", "content": "\"\"\"\n1. Only authenticated user should be able to fetch the user details\n2. A request with invalid token should not be entertained.\n/users/me\n\"\"\"\n\nfrom app.services.user import _generate_tokens\n\n\ndef test_fetch_me(client, user, test_session):\n    data = _generate_tokens(user, test_session)\n    headers = {\n        \"Authorization\": f\"Bearer {data['access_token']}\"\n    }\n    response = client.get(\"/users/me\", headers=headers)\n    assert response.status_code == 200\n    assert response.json()['email'] == user.email\n    \ndef test_fetch_me_invalid_token(client, user, test_session):\n    data = _generate_tokens(user, test_session)\n    headers = {\n        \"Authorization\": f\"Bearer {data['access_token'][:-6]}sakd2r\"\n    }\n    response = client.get(\"/users/me\", headers=headers)\n    assert response.status_code == 401\n    assert 'email' not in response.json()\n    assert 'id' not in response.json()\n    \n\ndef test_fetch_user_detail_by_id(auth_client, user):\n    response = auth_client.get(f\"/users/{user.id}\")\n    assert response.status_code == 200\n    assert response.json()['email'] == user.email"}
{"type": "test_file", "path": "tests/test_user_routes/test_user_verification.py", "content": "\"\"\"\n1 - Test if the user account action is working\n2 - Test activation link valid only once\n3 - Test activation is not allowing invalid token\n4 - Test activation is not allowining invalid email\n\"\"\"\nimport time\nfrom app.config.security import hash_password\nfrom app.models.user import User\nfrom app.utils.email_context import USER_VERIFY_ACCOUNT\n\n\ndef test_user_account_verification(client, inactive_user, test_session):\n    token_context = inactive_user.get_context_string(USER_VERIFY_ACCOUNT)\n    token = hash_password(token_context)\n    data = {\n        \"email\": inactive_user.email,\n        \"token\": token\n    }\n    response = client.post('/users/verify', json=data)\n    assert response.status_code == 200\n    activated_user = test_session.query(User).filter(User.email == inactive_user.email).first()\n    assert activated_user.is_active is True\n    assert activated_user.verified_at is not None\n\n\ndef test_user_link_doesnot_work_twice(client, inactive_user, test_session):\n    token_context = inactive_user.get_context_string(USER_VERIFY_ACCOUNT)\n    token = hash_password(token_context)\n    time.sleep(1)\n    data = {\n        \"email\": inactive_user.email,\n        \"token\": token\n    }\n    response = client.post('/users/verify', json=data)\n    assert response.status_code == 200\n    ## Account is activated now, let make another call to check if that works, \n    # it should not work though\n    response = client.post('/users/verify', json=data)\n    assert response.status_code != 200\n    \n    \ndef test_user_invalid_token_does_not_work(client, inactive_user, test_session):\n    data = {\n        \"email\": inactive_user.email,\n        \"token\": \"aksdajskdhakhdjkadhakjdhjahdjka\"\n    }\n    response = client.post('/users/verify', json=data)\n    assert response.status_code != 200\n    activated_user = test_session.query(User).filter(User.email == inactive_user.email).first()\n    assert activated_user.is_active is False\n    assert activated_user.verified_at is None\n    \ndef test_user_invalid_email_does_not_work(client, inactive_user, test_session):\n    token_context = inactive_user.get_context_string(USER_VERIFY_ACCOUNT)\n    token = hash_password(token_context)\n    data = {\n        \"email\": \"nandan@describly.com\",\n        \"token\": token\n    }\n    response = client.post('/users/verify', json=data)\n    assert response.status_code != 200\n    activated_user = test_session.query(User).filter(User.email == inactive_user.email).first()\n    assert activated_user.is_active is False\n    assert activated_user.verified_at is None\n\n    "}
{"type": "test_file", "path": "tests/test_user_routes/test_forgot_password.py", "content": "\"\"\"\n1. User should be able to send forgot password request\n2. User shoudl not be able to send forgot password request with invalid email address\n3. Unverified should not be able to request forgot password email\n4. InActive user should not be able to request forgot password email\n\"\"\"\nfrom app.config.email import fm\n\ndef test_user_can_send_forgot_password_request(client, user):\n    fm.config.SUPPRESS_SEND = 0\n    data = {'email': user.email}\n    response = client.post('/auth/forgot-password', json=data)\n    assert response.status_code == 200\n\n\ndef test_user_can_not_send_forgot_password_request_with_invalid_email(client, user):\n    data = {'email': 'invalid_email'}\n    response = client.post('/auth/forgot-password', json=data)\n    assert response.status_code == 422\n\n\ndef test_unverified_user_can_not_send_forgot_password_request(client, unverified_user):\n    data = {'email': unverified_user.email}\n    response = client.post('/auth/forgot-password', json=data)\n    assert response.status_code == 400\n\n\ndef test_in_active_user_can_not_send_forgot_password_request(client, inactive_user):\n    data = {'email': inactive_user.email}\n    response = client.post('/auth/forgot-password', json=data)\n    assert response.status_code == 400\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "from datetime import datetime\nimport sys\nimport os\nfrom typing import Generator\n\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom starlette.testclient import TestClient\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom app.main import app\nfrom app.config.email import fm\nfrom app.config.database import Base, get_session\nfrom app.models.user import User\nfrom app.config.security import hash_password\nfrom app.services.user import _generate_tokens\n\nUSER_NAME = \"Keshari Nandan\"\nUSER_EMAIL = \"keshari@describly.com\"\nUSER_PASSWORD = \"123#Describly\"\n\nengine = create_engine(\"sqlite:///./fastapi.db\")\nSessionTesting = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\n@pytest.fixture(scope=\"function\")\ndef test_session() -> Generator:\n    session = SessionTesting()\n    try:\n        yield session\n    finally:\n        session.close()\n\n\n@pytest.fixture(scope=\"function\")\ndef app_test():\n    Base.metadata.create_all(bind=engine)\n    yield app\n    Base.metadata.drop_all(bind=engine)\n\n\n@pytest.fixture(scope=\"function\")\ndef client(app_test, test_session):\n    def _test_db():\n        try:\n            yield test_session\n        finally:\n            pass\n\n    app_test.dependency_overrides[get_session] = _test_db\n    fm.config.SUPPRESS_SEND = 1\n    return TestClient(app_test)\n\n@pytest.fixture(scope=\"function\")\ndef auth_client(app_test, test_session, user):\n    def _test_db():\n        try:\n            yield test_session\n        finally:\n            pass\n\n    app_test.dependency_overrides[get_session] = _test_db\n    fm.config.SUPPRESS_SEND = 1\n    data = _generate_tokens(user, test_session)\n    client = TestClient(app_test)\n    client.headers['Authorization'] = f\"Bearer {data['access_token']}\"\n    return client\n\n\n@pytest.fixture(scope=\"function\")\ndef inactive_user(test_session):\n    model = User()\n    model.name = USER_NAME\n    model.email = USER_EMAIL\n    model.password = hash_password(USER_PASSWORD)\n    model.updated_at = datetime.utcnow()\n    model.is_active = False\n    test_session.add(model)\n    test_session.commit()\n    test_session.refresh(model)\n    return model\n\n@pytest.fixture(scope=\"function\")\ndef user(test_session):\n    model = User()\n    model.name = USER_NAME\n    model.email = USER_EMAIL\n    model.password = hash_password(USER_PASSWORD)\n    model.updated_at = datetime.utcnow()\n    model.verified_at = datetime.utcnow()\n    model.is_active = True\n    test_session.add(model)\n    test_session.commit()\n    test_session.refresh(model)\n    return model\n\n@pytest.fixture(scope=\"function\")\ndef unverified_user(test_session):\n    model = User()\n    model.name = USER_NAME\n    model.email = USER_EMAIL\n    model.password = hash_password(USER_PASSWORD)\n    model.updated_at = datetime.utcnow()\n    model.is_active = True\n    test_session.add(model)\n    test_session.commit()\n    test_session.refresh(model)\n    return model"}
{"type": "source_file", "path": "alembic/versions/8e9ec5b17730_create.py", "content": "\"\"\"create\n\nRevision ID: 8e9ec5b17730\nRevises: \nCreate Date: 2023-10-22 09:09:17.072828\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = '8e9ec5b17730'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('name', sa.String(length=150), nullable=True),\n    sa.Column('email', sa.String(length=255), nullable=True),\n    sa.Column('password', sa.String(length=100), nullable=True),\n    sa.Column('is_active', sa.Boolean(), nullable=True),\n    sa.Column('verified_at', sa.DateTime(), nullable=True),\n    sa.Column('updated_at', sa.DateTime(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f('ix_users_email'), table_name='users')\n    op.drop_table('users')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "app/config/email.py", "content": "import os\nfrom pathlib import Path\nfrom fastapi_mail import FastMail, MessageSchema, MessageType, ConnectionConfig\nfrom fastapi.background import BackgroundTasks\nfrom app.config.settings import get_settings\n\nsettings = get_settings()\n\nconf = ConnectionConfig(\n    MAIL_USERNAME=os.environ.get(\"MAIL_USERNAME\", \"\"),\n    MAIL_PASSWORD=os.environ.get(\"MAIL_PASSWORD\", \"\"),\n    MAIL_PORT=os.environ.get(\"MAIL_PORT\", 1025),\n    MAIL_SERVER=os.environ.get(\"MAIL_SERVER\", \"smtp\"),\n    MAIL_STARTTLS=os.environ.get(\"MAIL_STARTTLS\", False),\n    MAIL_SSL_TLS=os.environ.get(\"MAIL_SSL_TLS\", False),\n    MAIL_DEBUG=True,\n    MAIL_FROM=os.environ.get(\"MAIL_FROM\", 'noreply@test.com'),\n    MAIL_FROM_NAME=os.environ.get(\"MAIL_FROM_NAME\", settings.APP_NAME),\n    TEMPLATE_FOLDER=Path(__file__).parent.parent / \"templates\",\n    USE_CREDENTIALS=os.environ.get(\"USE_CREDENTIALS\", True)\n)\n\nfm = FastMail(conf)\n\n\nasync def send_email(recipients: list, subject: str, context: dict, template_name: str,\n                     background_tasks: BackgroundTasks):\n    message = MessageSchema(\n        subject=subject,\n        recipients=recipients,\n        template_body=context,\n        subtype=MessageType.html\n    )\n\n    background_tasks.add_task(fm.send_message, message, template_name=template_name)\n"}
{"type": "source_file", "path": "app/config/security.py", "content": "import logging\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nimport jwt\nfrom passlib.context import CryptContext\nimport base64\nfrom sqlalchemy.orm import joinedload, Session\nfrom datetime import datetime, timedelta\nfrom app.config.database import get_session\nfrom app.config.settings import get_settings\nfrom app.models.user import UserToken\n\nSPECIAL_CHARACTERS = ['@', '#', '$', '%', '=', ':', '?', '.', '/', '|', '~', '>']\n\nsettings = get_settings()\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\n\n\ndef hash_password(password):\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef is_password_strong_enough(password: str) -> bool:\n    if len(password) < 8:\n        return False\n\n    if not any(char.isupper() for char in password):\n        return False\n\n    if not any(char.islower() for char in password):\n        return False\n\n    if not any(char.isdigit() for char in password):\n        return False\n\n    if not any(char in SPECIAL_CHARACTERS for char in password):\n        return False\n\n    return True\n\n\ndef str_encode(string: str) -> str:\n    return base64.b85encode(string.encode('ascii')).decode('ascii')\n\n\ndef str_decode(string: str) -> str:\n    return base64.b85decode(string.encode('ascii')).decode('ascii')\n\n\ndef get_token_payload(token: str, secret: str, algo: str):\n    try:\n        payload = jwt.decode(token, secret, algorithms=algo)\n    except Exception as jwt_exec:\n        logging.debug(f\"JWT Error: {str(jwt_exec)}\")\n        payload = None\n    return payload\n\n\ndef generate_token(payload: dict, secret: str, algo: str, expiry: timedelta):\n    expire = datetime.utcnow() + expiry\n    payload.update({\"exp\": expire})\n    return jwt.encode(payload, secret, algorithm=algo)\n\n\nasync def get_token_user(token: str, db):\n    payload = get_token_payload(token, settings.JWT_SECRET, settings.JWT_ALGORITHM)\n    if payload:\n        user_token_id = str_decode(payload.get('r'))\n        user_id = str_decode(payload.get('sub'))\n        access_key = payload.get('a')\n        user_token = db.query(UserToken).options(joinedload(UserToken.user)).filter(UserToken.access_key == access_key,\n                                                 UserToken.id == user_token_id,\n                                                 UserToken.user_id == user_id,\n                                                 UserToken.expires_at > datetime.utcnow()\n                                                 ).first()\n        if user_token:\n            return user_token.user\n    return None\n\n\nasync def load_user(email: str, db):\n    from app.models.user import User\n    try:\n        user = db.query(User).filter(User.email == email).first()\n    except Exception as user_exec:\n        logging.info(f\"User Not Found, Email: {email}\")\n        user = None\n    return user\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_session)):\n    user = await get_token_user(token=token, db=db)\n    if user:\n        return user\n    raise HTTPException(status_code=401, detail=\"Not authorised.\")"}
{"type": "source_file", "path": "alembic/versions/9d8957ab5c48_create.py", "content": "\"\"\"create\n\nRevision ID: 9d8957ab5c48\nRevises: 8e9ec5b17730\nCreate Date: 2023-10-23 09:24:11.065820\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = '9d8957ab5c48'\ndown_revision: Union[str, None] = '8e9ec5b17730'\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('user_tokens',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('access_key', sa.String(length=250), nullable=True),\n    sa.Column('refresh_key', sa.String(length=250), nullable=True),\n    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),\n    sa.Column('expires_at', sa.DateTime(), nullable=False),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index(op.f('ix_user_tokens_access_key'), 'user_tokens', ['access_key'], unique=False)\n    op.create_index(op.f('ix_user_tokens_refresh_key'), 'user_tokens', ['refresh_key'], unique=False)\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f('ix_user_tokens_refresh_key'), table_name='user_tokens')\n    op.drop_index(op.f('ix_user_tokens_access_key'), table_name='user_tokens')\n    op.drop_table('user_tokens')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "app/utils/string.py", "content": "import secrets\n\ndef unique_string(byte: int = 8) -> str:\n    return secrets.token_urlsafe(byte)"}
{"type": "source_file", "path": "app/responses/base.py", "content": "\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass BaseResponse(BaseModel):\n    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)"}
{"type": "source_file", "path": "app/schemas/user.py", "content": "\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass RegisterUserRequest(BaseModel):\n    name: str\n    email: EmailStr\n    password: str\n    \n    \nclass VerifyUserRequest(BaseModel):\n    token: str\n    email: EmailStr\n    \nclass EmailRequest(BaseModel):\n    email: EmailStr\n    \nclass ResetRequest(BaseModel):\n    token: str\n    email: EmailStr\n    password: str\n    "}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import FastAPI\nfrom app.routes import user\n\ndef create_application():\n    application = FastAPI()\n    application.include_router(user.user_router)\n    application.include_router(user.guest_router)\n    application.include_router(user.auth_router)\n    return application\n\n\napp = create_application()\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hi, I am Describly. Awesome - Your setrup is done & working.\"}"}
{"type": "source_file", "path": "app/routes/user.py", "content": "\nfrom fastapi import APIRouter, BackgroundTasks, Depends, status, Header\nfrom fastapi.responses import JSONResponse\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session\n\nfrom app.config.database import get_session\nfrom app.responses.user import UserResponse, LoginResponse\nfrom app.schemas.user import RegisterUserRequest, ResetRequest, VerifyUserRequest, EmailRequest\nfrom app.services import user\nfrom app.config.security import get_current_user, oauth2_scheme\n\n\nuser_router = APIRouter(\n    prefix=\"/users\",\n    tags=[\"Users\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n\nauth_router = APIRouter(\n    prefix=\"/users\",\n    tags=[\"Users\"],\n    responses={404: {\"description\": \"Not found\"}},\n    dependencies=[Depends(oauth2_scheme), Depends(get_current_user)]\n)\n\nguest_router = APIRouter(\n    prefix=\"/auth\",\n    tags=[\"Auth\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n\n@user_router.post(\"\", status_code=status.HTTP_201_CREATED, response_model=UserResponse)\nasync def register_user(data: RegisterUserRequest, background_tasks: BackgroundTasks, session: Session = Depends(get_session)):\n    return await user.create_user_account(data, session, background_tasks)\n\n@user_router.post(\"/verify\", status_code=status.HTTP_200_OK)\nasync def verify_user_account(data: VerifyUserRequest, background_tasks: BackgroundTasks, session: Session = Depends(get_session)):\n    await user.activate_user_account(data, session, background_tasks)\n    return JSONResponse({\"message\": \"Account is activated successfully.\"})\n\n@guest_router.post(\"/login\", status_code=status.HTTP_200_OK, response_model=LoginResponse)\nasync def user_login(data: OAuth2PasswordRequestForm = Depends(), session: Session = Depends(get_session)):\n    return await user.get_login_token(data, session)\n\n@guest_router.post(\"/refresh\", status_code=status.HTTP_200_OK, response_model=LoginResponse)\nasync def refresh_token(refresh_token = Header(), session: Session = Depends(get_session)):\n    return await user.get_refresh_token(refresh_token, session)\n\n\n@guest_router.post(\"/forgot-password\", status_code=status.HTTP_200_OK)\nasync def forgot_password(data: EmailRequest, background_tasks: BackgroundTasks, session: Session = Depends(get_session)):\n    await user.email_forgot_password_link(data, background_tasks, session)\n    return JSONResponse({\"message\": \"A email with password reset link has been sent to you.\"})\n\n@guest_router.put(\"/reset-password\", status_code=status.HTTP_200_OK)\nasync def reset_password(data: ResetRequest, session: Session = Depends(get_session)):\n    await user.reset_user_password(data, session)\n    return JSONResponse({\"message\": \"Your password has been updated.\"})\n\n@auth_router.get(\"/me\", status_code=status.HTTP_200_OK, response_model=UserResponse)\nasync def fetch_user(user = Depends(get_current_user)):\n    return user\n\n\n@auth_router.get(\"/{pk}\", status_code=status.HTTP_200_OK, response_model=UserResponse)\nasync def get_user_info(pk, session: Session = Depends(get_session)):\n    return await user.fetch_user_detail(pk, session)"}
{"type": "source_file", "path": "app/services/email.py", "content": "from fastapi import BackgroundTasks\nfrom app.config.settings import get_settings\nfrom app.models.user import User\nfrom app.config.email import send_email\nfrom app.utils.email_context import USER_VERIFY_ACCOUNT, FORGOT_PASSWORD\n\nsettings = get_settings()\n\n\nasync def send_account_verification_email(user: User, background_tasks: BackgroundTasks):\n    from app.config.security import hash_password\n    string_context = user.get_context_string(context=USER_VERIFY_ACCOUNT)\n    token = hash_password(string_context)\n    activate_url = f\"{settings.FRONTEND_HOST}/auth/account-verify?token={token}&email={user.email}\"\n    data = {\n        'app_name': settings.APP_NAME,\n        \"name\": user.name,\n        'activate_url': activate_url\n    }\n    subject = f\"Account Verification - {settings.APP_NAME}\"\n    await send_email(\n        recipients=[user.email],\n        subject=subject,\n        template_name=\"user/account-verification.html\",\n        context=data,\n        background_tasks=background_tasks\n    )\n    \n    \nasync def send_account_activation_confirmation_email(user: User, background_tasks: BackgroundTasks):\n    data = {\n        'app_name': settings.APP_NAME,\n        \"name\": user.name,\n        'login_url': f'{settings.FRONTEND_HOST}'\n    }\n    subject = f\"Welcome - {settings.APP_NAME}\"\n    await send_email(\n        recipients=[user.email],\n        subject=subject,\n        template_name=\"user/account-verification-confirmation.html\",\n        context=data,\n        background_tasks=background_tasks\n    )\n    \nasync def send_password_reset_email(user: User, background_tasks: BackgroundTasks):\n    from app.config.security import hash_password\n    string_context = user.get_context_string(context=FORGOT_PASSWORD)\n    token = hash_password(string_context)\n    reset_url = f\"{settings.FRONTEND_HOST}/reset-password?token={token}&email={user.email}\"\n    data = {\n        'app_name': settings.APP_NAME,\n        \"name\": user.name,\n        'activate_url': reset_url,\n    }\n    subject = f\"Reset Password - {settings.APP_NAME}\"\n    await send_email(\n        recipients=[user.email],\n        subject=subject,\n        template_name=\"user/password-reset.html\",\n        context=data,\n        background_tasks=background_tasks\n    )"}
{"type": "source_file", "path": "app/config/settings.py", "content": "import os\nfrom functools import lru_cache\nfrom pydantic_settings import BaseSettings\nfrom pathlib import Path\nfrom dotenv import load_dotenv\nfrom urllib.parse import quote_plus\n\nenv_path = Path(\".\") / \".env\"\nload_dotenv(dotenv_path=env_path)\n\n\nclass Settings(BaseSettings):\n\n    # App\n    APP_NAME:  str = os.environ.get(\"APP_NAME\", \"FastAPI\")\n    DEBUG: bool = bool(os.environ.get(\"DEBUG\", False))\n    \n    # FrontEnd Application\n    FRONTEND_HOST: str = os.environ.get(\"FRONTEND_HOST\", \"http://localhost:3000\")\n\n    # MySql Database Config\n    MYSQL_HOST: str = os.environ.get(\"MYSQL_HOST\", 'localhost')\n    MYSQL_USER: str = os.environ.get(\"MYSQL_USER\", 'root')\n    MYSQL_PASS: str = os.environ.get(\"MYSQL_PASSWORD\", 'secret')\n    MYSQL_PORT: int = int(os.environ.get(\"MYSQL_PORT\", 3306))\n    MYSQL_DB: str = os.environ.get(\"MYSQL_DB\", 'fastapi')\n    DATABASE_URI: str = f\"mysql+pymysql://{MYSQL_USER}:%s@{MYSQL_HOST}:{MYSQL_PORT}/{MYSQL_DB}\" % quote_plus(MYSQL_PASS)\n\n    # JWT Secret Key\n    JWT_SECRET: str = os.environ.get(\"JWT_SECRET\", \"649fb93ef34e4fdf4187709c84d643dd61ce730d91856418fdcf563f895ea40f\")\n    JWT_ALGORITHM: str = os.environ.get(\"ACCESS_TOKEN_ALGORITHM\", \"HS256\")\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.environ.get(\"ACCESS_TOKEN_EXPIRE_MINUTES\", 3))\n    REFRESH_TOKEN_EXPIRE_MINUTES: int = int(os.environ.get(\"REFRESH_TOKEN_EXPIRE_MINUTES\", 1440))\n\n    # App Secret Key\n    SECRET_KEY: str = os.environ.get(\"SECRET_KEY\", \"8deadce9449770680910741063cd0a3fe0acb62a8978661f421bbcbb66dc41f1\")\n\n\n@lru_cache()\ndef get_settings() -> Settings:\n    return Settings()\n"}
{"type": "source_file", "path": "app/utils/email_context.py", "content": "USER_VERIFY_ACCOUNT = \"verify-account\"\nFORGOT_PASSWORD = \"password-reset\""}
{"type": "source_file", "path": "app/models/user.py", "content": "from datetime import datetime\nfrom sqlalchemy import Boolean, Column, DateTime, Integer, String, func, ForeignKey\nfrom app.config.database import Base\nfrom sqlalchemy.orm import mapped_column, relationship\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String(150))\n    email = Column(String(255), unique=True, index=True)\n    password = Column(String(100))\n    is_active = Column(Boolean, default=False)\n    verified_at = Column(DateTime, nullable=True, default=None)\n    updated_at = Column(DateTime, nullable=True, default=None, onupdate=datetime.now)\n    created_at = Column(DateTime, nullable=False, server_default=func.now())\n    \n    tokens = relationship(\"UserToken\", back_populates=\"user\")\n\n    def get_context_string(self, context: str):\n        return f\"{context}{self.password[-6:]}{self.updated_at.strftime('%m%d%Y%H%M%S')}\".strip()\n    \n    \n\nclass UserToken(Base):\n    __tablename__ = \"user_tokens\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    user_id = mapped_column(ForeignKey('users.id'))\n    access_key = Column(String(250), nullable=True, index=True, default=None)\n    refresh_key = Column(String(250), nullable=True, index=True, default=None)\n    created_at = Column(DateTime, nullable=False, server_default=func.now())\n    expires_at = Column(DateTime, nullable=False)\n    \n    user = relationship(\"User\", back_populates=\"tokens\")"}
{"type": "source_file", "path": "app/config/database.py", "content": "from app.config.settings import get_settings\nfrom sqlalchemy.orm import sessionmaker, declarative_base\nfrom typing import Generator\nfrom sqlalchemy import create_engine\n\nsettings = get_settings()\n\nengine = create_engine(settings.DATABASE_URI,\n                       pool_pre_ping=True,\n                       pool_recycle=3600,\n                       pool_size=20,\n                       max_overflow=0)\n\nSessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)\nBase = declarative_base()\n\n\ndef get_session() -> Generator:\n    session = SessionLocal()\n    try:\n        yield session\n    finally:\n        session.close()\n"}
{"type": "source_file", "path": "app/responses/user.py", "content": "from typing import Union\nfrom datetime import datetime\nfrom pydantic import EmailStr, BaseModel\nfrom app.responses.base import BaseResponse\n\n\nclass UserResponse(BaseResponse):\n    id: int\n    name: str\n    email: EmailStr\n    is_active: bool\n    created_at: Union[str, None, datetime] = None\n    \n    \n\nclass LoginResponse(BaseModel):\n    access_token: str\n    refresh_token: str\n    expires_in: int\n    token_type: str = \"Bearer\""}
{"type": "source_file", "path": "app/services/user.py", "content": "\n\nfrom datetime import datetime, timedelta\nimport logging\nfrom sqlalchemy.orm import joinedload\nfrom fastapi import HTTPException\nfrom app.config.security import generate_token, get_token_payload, hash_password, is_password_strong_enough, load_user, str_decode, str_encode, verify_password\nfrom app.models.user import User, UserToken\nfrom app.services.email import send_account_activation_confirmation_email, send_account_verification_email, send_password_reset_email\nfrom app.utils.email_context import FORGOT_PASSWORD, USER_VERIFY_ACCOUNT\nfrom app.utils.string import unique_string\nfrom app.config.settings import get_settings\n\nsettings = get_settings()\n\nasync def create_user_account(data, session, background_tasks):\n    \n    user_exist = session.query(User).filter(User.email == data.email).first()\n    if user_exist:\n        raise HTTPException(status_code=400, detail=\"Email is already exists.\")\n    \n    if not is_password_strong_enough(data.password):\n        raise HTTPException(status_code=400, detail=\"Please provide a strong password.\")\n    \n    \n    user = User()\n    user.name = data.name\n    user.email = data.email\n    user.password = hash_password(data.password)\n    user.is_active = False\n    user.updated_at = datetime.utcnow()\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n    \n    # Account Verification Email\n    await send_account_verification_email(user, background_tasks=background_tasks)\n    return user\n    \n    \nasync def activate_user_account(data, session, background_tasks):\n    user = session.query(User).filter(User.email == data.email).first()\n    if not user:\n        raise HTTPException(status_code=400, detail=\"This link is not valid.\")\n    \n    user_token = user.get_context_string(context=USER_VERIFY_ACCOUNT)\n    try:\n        token_valid = verify_password(user_token, data.token)\n    except Exception as verify_exec:\n        logging.exception(verify_exec)\n        token_valid = False\n    if not token_valid:\n        raise HTTPException(status_code=400, detail=\"This link either expired or not valid.\")\n    \n    user.is_active = True\n    user.updated_at = datetime.utcnow()\n    user.verified_at = datetime.utcnow()\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n    # Activation confirmation email\n    await send_account_activation_confirmation_email(user, background_tasks)\n    return user\n\n\nasync def get_login_token(data, session):\n    # verify the email and password\n    # Verify that user account is verified\n    # Verify user account is active\n    # generate access_token and refresh_token and ttl\n    \n    user = await load_user(data.username, session)\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Email is not registered with us.\")\n    \n    if not verify_password(data.password, user.password):\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password.\")\n    \n    if not user.verified_at:\n        raise HTTPException(status_code=400, detail=\"Your account is not verified. Please check your email inbox to verify your account.\")\n    \n    if not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Your account has been dactivated. Please contact support.\")\n        \n    # Generate the JWT Token\n    return _generate_tokens(user, session)\n\n\nasync def get_refresh_token(refresh_token, session):\n    token_payload = get_token_payload(refresh_token, settings.SECRET_KEY, settings.JWT_ALGORITHM)\n    if not token_payload:\n        raise HTTPException(status_code=400, detail=\"Invalid Request.\")\n    \n    refresh_key = token_payload.get('t')\n    access_key = token_payload.get('a')\n    user_id = str_decode(token_payload.get('sub'))\n    user_token = session.query(UserToken).options(joinedload(UserToken.user)).filter(UserToken.refresh_key == refresh_key,\n                                                 UserToken.access_key == access_key,\n                                                 UserToken.user_id == user_id,\n                                                 UserToken.expires_at > datetime.utcnow()\n                                                 ).first()\n    if not user_token:\n        raise HTTPException(status_code=400, detail=\"Invalid Request.\")\n    \n    user_token.expires_at = datetime.utcnow()\n    session.add(user_token)\n    session.commit()\n    return _generate_tokens(user_token.user, session)\n\n\ndef _generate_tokens(user, session):\n    refresh_key = unique_string(100)\n    access_key = unique_string(50)\n    rt_expires = timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)\n\n    user_token = UserToken()\n    user_token.user_id = user.id\n    user_token.refresh_key = refresh_key\n    user_token.access_key = access_key\n    user_token.expires_at = datetime.utcnow() + rt_expires\n    session.add(user_token)\n    session.commit()\n    session.refresh(user_token)\n\n    at_payload = {\n        \"sub\": str_encode(str(user.id)),\n        'a': access_key,\n        'r': str_encode(str(user_token.id)),\n        'n': str_encode(f\"{user.name}\")\n    }\n\n    at_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = generate_token(at_payload, settings.JWT_SECRET, settings.JWT_ALGORITHM, at_expires)\n\n    rt_payload = {\"sub\": str_encode(str(user.id)), \"t\": refresh_key, 'a': access_key}\n    refresh_token = generate_token(rt_payload, settings.SECRET_KEY, settings.JWT_ALGORITHM, rt_expires)\n    return {\n        \"access_token\": access_token,\n        \"refresh_token\": refresh_token,\n        \"expires_in\": at_expires.seconds\n    }\n    \nasync def email_forgot_password_link(data, background_tasks, session):\n    user = await load_user(data.email, session)\n    if not user.verified_at:\n        raise HTTPException(status_code=400, detail=\"Your account is not verified. Please check your email inbox to verify your account.\")\n    \n    if not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Your account has been dactivated. Please contact support.\")\n    \n    await send_password_reset_email(user, background_tasks)\n    \n    \nasync def reset_user_password(data, session):\n    user = await load_user(data.email, session)\n    \n    if not user:\n        raise HTTPException(status_code=400, detail=\"Invalid request\")\n        \n    \n    if not user.verified_at:\n        raise HTTPException(status_code=400, detail=\"Invalid request\")\n    \n    if not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Invalid request\")\n    \n    user_token = user.get_context_string(context=FORGOT_PASSWORD)\n    try:\n        token_valid = verify_password(user_token, data.token)\n    except Exception as verify_exec:\n        logging.exception(verify_exec)\n        token_valid = False\n    if not token_valid:\n        raise HTTPException(status_code=400, detail=\"Invalid window.\")\n    \n    user.password = hash_password(data.password)\n    user.updated_at = datetime.now()\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n    # Notify user that password has been updated\n    \n    \nasync def fetch_user_detail(pk, session):\n    user = session.query(User).filter(User.id == pk).first()\n    if user:\n        return user\n    raise HTTPException(status_code=400, detail=\"User does not exists.\")"}
{"type": "source_file", "path": "alembic/env.py", "content": "from logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\nfrom app.config.database import Base\n\nfrom alembic import context\n\n# Import All Models\nfrom app.models.user import *\n\nfrom app.config.settings import get_settings\nsettings = get_settings()\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\nconfig.set_main_option('sqlalchemy.url', settings.DATABASE_URI.replace(\"%\", \"%%\"))\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}

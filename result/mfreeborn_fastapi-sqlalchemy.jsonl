{"repo_info": {"repo_name": "fastapi-sqlalchemy", "repo_owner": "mfreeborn", "repo_url": "https://github.com/mfreeborn/fastapi-sqlalchemy"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/conftest.py", "content": "import sys\n\nimport pytest\nfrom fastapi import FastAPI\nfrom starlette.testclient import TestClient\n\n\n@pytest.fixture\ndef app():\n    return FastAPI()\n\n\n@pytest.fixture\ndef client(app):\n    with TestClient(app) as c:\n        yield c\n\n\n@pytest.fixture\ndef DBSessionMiddleware():\n    from fastapi_sqlalchemy import DBSessionMiddleware\n\n    yield DBSessionMiddleware\n\n\n@pytest.fixture\ndef db():\n    from fastapi_sqlalchemy import db\n\n    yield db\n\n    # force reloading of module to clear global state\n\n    try:\n        del sys.modules[\"fastapi_sqlalchemy\"]\n    except KeyError:\n        pass\n\n    try:\n        del sys.modules[\"fastapi_sqlalchemy.middleware\"]\n    except KeyError:\n        pass\n"}
{"type": "test_file", "path": "tests/test_session.py", "content": "from unittest.mock import Mock, patch\n\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import Session\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nfrom fastapi_sqlalchemy.exceptions import MissingSessionError, SessionNotInitialisedError\n\n# TODO Add tests.\n"}
{"type": "source_file", "path": "examples/legacy/models.py", "content": "from sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.orm import declarative_base, sessionmaker\n\nfrom fastapi_sqlalchemy import db\n\n\n# Define the User class representing the \"users\" database table\n# Using the SQLAlchemy Base property instead of defining your own\nclass User(db.Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    email = Column(String)\n\n    def __repr__(self):\n        return f\"User(id={self.id}, name='{self.name}',email='{self.email}')\"\n"}
{"type": "source_file", "path": "examples/legacy/app.py", "content": "from typing import Optional\n\nfrom fastapi import FastAPI\nfrom models import User, db\nfrom pydantic import BaseModel\n\nfrom fastapi_sqlalchemy import DBSessionMiddleware\n\napp = FastAPI()\n\n# Add DB session middleware with db_url specified\napp.add_middleware(DBSessionMiddleware, db_url=\"sqlite:///example.db\")\n\n\n# Endpoint to retrieve all users\n@app.get(\"/users\")\ndef get_users():\n    \"\"\"\n    Retrieve a list of all users.\n\n    Returns:\n        List[User]: A list of User objects.\n    \"\"\"\n    return db.session.query(User).all()\n\n\n# Pydantic model for creating new users\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\n\n# Endpoint to add a new user\n@app.post(\"/add_user\")\ndef add_user(user_data: UserCreate):\n    \"\"\"\n    Add a new user to the database.\n\n    Args:\n        user_data (UserCreate): User data including name and email.\n\n    Returns:\n        dict: A message indicating the success of the operation.\n    \"\"\"\n    user = User(**user_data.dict())\n    db.session.add(user)\n    db.session.commit()\n    return {\"message\": \"User created successfully\"}\n\n\n# Pydantic model for updating user information\nclass UserUpdate(UserCreate):\n    id: int\n    name: Optional[str]\n    email: Optional[str]\n\n\n# Endpoint to update user information\n@app.post(\"/update_user\")\ndef update_user(user_data: UserUpdate):\n    \"\"\"\n    Update user information in the database.\n\n    Args:\n        user_data (UserUpdate): User data including ID, name, and email for updating.\n\n    Returns:\n        dict: A message indicating the success of the operation.\n    \"\"\"\n    user = db.session.query(User).filter_by(id=user_data.id).first()\n    if user_data.name:\n        user.name = user_data.name\n    if user_data.email:\n        user.email = user_data.email\n    db.session.add(user)\n    db.session.commit()\n    return {\"message\": \"User updated successfully\"}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n"}
{"type": "source_file", "path": "examples/multi_db/models/posts.py", "content": "from sqlalchemy import Column, Integer, MetaData, String, create_engine\nfrom sqlalchemy.orm import DeclarativeMeta, declarative_base, sessionmaker\n\nfrom fastapi_sqlalchemy import SQLAlchemy\n\nfrom . import BaseModel\n\n# Create a SQLAlchemy instance with a connection to the SQLite database \"post.db\"\npost_db = SQLAlchemy(\"sqlite:///post.db\")\n\n\n# Define the User class representing the \"posts\" database table\n# using the SQLAlchemy Base property instead of defining your own\n# And inheriting from the BaseModel class for type hinting and helpful builtin methods and properties\nclass Post(BaseModel, post_db.Base):\n    __tablename__ = \"posts\"\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    content = Column(String)\n    user_id = Column(Integer)\n"}
{"type": "source_file", "path": "examples/multi_db/app.py", "content": "# Import necessary modules and classes\nfrom typing import Optional\n\nfrom fastapi import FastAPI\nfrom models.posts import Post, post_db  # Import the Post model and post_db database instance\nfrom models.users import User, user_db  # Import the User model and user_db database instance\nfrom pydantic import BaseModel\n\nfrom fastapi_sqlalchemy import (\n    DBSessionMiddleware,  # Import the DBSessionMiddleware for database sessions\n)\n\n# Create a FastAPI application instance\napp = FastAPI()\n\n# Add the DBSessionMiddleware as a middleware to the FastAPI app, connecting it to the specified databases\napp.add_middleware(DBSessionMiddleware, db=[post_db, user_db])\n\n\n# Define an endpoint for retrieving all users\n@app.get(\"/users\")\ndef get_users():\n    \"\"\"\n    Endpoint to retrieve a list of all users.\n    Returns:\n        List[User]: A list of User objects representing all users in the database.\n    \"\"\"\n    return User.get_all()\n\n\n# Define a Pydantic model for creating a new user\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\n\n# Define an endpoint for adding a new user\n@app.post(\"/add_user\")\ndef add_user(user_data: UserCreate):\n    \"\"\"\n    Endpoint to add a new user to the database.\n    Args:\n        user_data (UserCreate): User data provided in the request body.\n    Returns:\n        dict: A message indicating the success of the operation.\n    \"\"\"\n    user = User(**user_data.dict())\n    user.save()\n    return {\"message\": \"User created successfully\"}\n\n\n# Define a Pydantic model for updating user information\nclass UserUpdate(UserCreate):\n    id: int\n    name: Optional[str]\n    email: Optional[str]\n\n\n# Define an endpoint for updating user information\n@app.post(\"/update_user\")\ndef update_user(user_data: UserUpdate):\n    \"\"\"\n    Endpoint to update user information in the database.\n    Args:\n        user_data (UserUpdate): User data provided in the request body.\n    Returns:\n        dict: A message indicating the success of the operation.\n    \"\"\"\n    user = User.get(id=user_data.id)\n    user.update(**user_data.dict())\n    user.save()\n    return {\"message\": \"User updated successfully\"}\n\n\n# Define a Pydantic model for retrieving posts by user ID\nclass UserPosts(BaseModel):\n    user_id: int\n\n\n# Define an endpoint for retrieving posts by user ID\n@app.get(\"/posts\")\ndef get_posts(user: UserPosts):\n    \"\"\"\n    Endpoint to retrieve posts by a specific user ID.\n    Args:\n        user (UserPosts): User ID provided in the query parameters.\n    Returns:\n        List[Post]: A list of Post objects belonging to the specified user.\n    \"\"\"\n    posts = Post.get_all(user_id=user.user_id)\n    return posts\n\n\n# Define a Pydantic model for creating a new post\nclass PostCreate(UserPosts):\n    title: str\n    content: str\n\n\n# Define an endpoint for adding a new post\n@app.post(\"/add_post\")\ndef add_post(post_data: PostCreate):\n    \"\"\"\n    Endpoint to add a new post to the database.\n    Args:\n        post_data (PostCreate): Post data provided in the request body.\n    Returns:\n        dict: A message indicating the success of the operation.\n    \"\"\"\n    post = Post(**post_data.dict())\n    post.save()\n    return {\"message\": \"Post created successfully\"}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n"}
{"type": "source_file", "path": "examples/single_db/app.py", "content": "from typing import Optional\n\nfrom fastapi import FastAPI\nfrom models import User, db\nfrom pydantic import BaseModel\n\nfrom fastapi_sqlalchemy import DBSessionMiddleware\n\napp = FastAPI()\n\n# Add SQLAlchemy session middleware to manage database sessions\napp.add_middleware(DBSessionMiddleware, db=db)\n\n\n# Endpoint to retrieve all users\n@app.get(\"/users\")\ndef get_users():\n    \"\"\"\n    Retrieve a list of all users.\n\n    Returns:\n        List[User]: A list of User objects.\n    \"\"\"\n    return User.query.all()\n\n\n# Pydantic model for creating new users\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\n\n# Endpoint to add a new user\n@app.post(\"/add_user\")\ndef add_user(user_data: UserCreate):\n    \"\"\"\n    Add a new user to the database.\n\n    Args:\n        user_data (UserCreate): User data including name and email.\n\n    Returns:\n        dict: A message indicating the success of the operation.\n    \"\"\"\n    user = User(**user_data.model_dump())\n    print(user)\n    user.save()\n    return {\"message\": \"User created successfully\"}\n\n\n# Pydantic model for updating user information\nclass UserUpdate(UserCreate):\n    id: int\n    name: Optional[str]\n    email: Optional[str]\n\n\n# Endpoint to update user information\n@app.post(\"/update_user\")\ndef update_user(user_data: UserUpdate):\n    \"\"\"\n    Update user information in the database.\n\n    Args:\n        user_data (UserUpdate): User data including ID, name, and email for updating.\n\n    Returns:\n        dict: A message indicating the success of the operation.\n    \"\"\"\n    user = User.query.filter_by(id=user_data.id).first()\n    print(user)\n    user.update(**user_data.model_dump())\n    user.save()\n    return {\"message\": \"User updated successfully\"}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n"}
{"type": "source_file", "path": "examples/multi_db/models/__init__.py", "content": "import inspect\nfrom typing import Dict, List\n\nfrom sqlalchemy import Column\n\nfrom fastapi_sqlalchemy import ModelBase\n\n\nclass BaseModel(ModelBase):\n    @classmethod\n    def new(cls, **kwargs):\n        obj = cls(**kwargs)\n        obj.save()\n        return obj\n\n    @classmethod\n    def get(cls, **kwargs):\n        result: cls = cls.query.filter_by(**kwargs).first()\n        return result\n\n    @classmethod\n    def get_all(cls, **kwargs):\n        result: List[cls] = cls.query.filter_by(**kwargs).all()\n        return result\n\n    def update(self, **kwargs):\n        for column, value in kwargs.items():\n            setattr(self, column, value)\n\n        self.save()\n        return self\n\n    def __repr__(self):\n        try:\n            columns = dict(\n                (column.name, getattr(self, column.name)) for column in self.__table__.columns\n            )\n\n        except:\n            o = {}\n            members = inspect.getmembers(self)\n            for name, obj in members:\n                if type(obj) == Column:\n                    o[name] = obj\n            columns = o\n\n        column_strings = []\n        for column, value in columns.items():\n            column_strings.append(f\"{column}: {value}\")\n\n        repr = f\"<{self.__class__.__name__} {', '.join(column_strings)}>\"\n        return repr\n"}
{"type": "source_file", "path": "examples/multi_db/models/users.py", "content": "# Import necessary modules and classes\nfrom sqlalchemy import Column, Integer, String, create_engine  # Import SQLAlchemy components\nfrom sqlalchemy.orm import (  # Import SQLAlchemy components\n    DeclarativeMeta,\n    declarative_base,\n    sessionmaker,\n)\n\nfrom fastapi_sqlalchemy import SQLAlchemy  # Import the SQLAlchemy extension\n\nfrom . import BaseModel  # Import the custom BaseModel\n\n# Create a SQLAlchemy instance with a connection to the SQLite database \"user.db\"\nuser_db = SQLAlchemy(\"sqlite:///user.db\")\n\n\n# Define the User class representing the \"users\" database table\n# Using the SQLAlchemy Base property instead of defining your own\n# And inheriting from the BaseModel class for type hinting and helpful builtin methods and properties\nclass User(BaseModel, user_db.Base):\n    \"\"\"\n    Represents a user in the database.\n\n    Attributes:\n        id (int): The primary key of the user.\n        name (str): The name of the user.\n        email (str): The email address of the user.\n    \"\"\"\n\n    # Name of the database table associated with this class\n    __tablename__ = \"users\"\n\n    # Columns corresponding to the attributes of the User class\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    email = Column(String)\n"}
{"type": "source_file", "path": "fastapi_sqlalchemy/decorators.py", "content": "import ast\nimport asyncio\nimport inspect\nfrom functools import wraps\nfrom typing import Any, Awaitable, Callable, Self\n\nfrom curio.meta import from_coroutine\n\n\ndef awaitable(asyncfunc):\n    def coroutine(syncfunc):\n        @wraps(syncfunc)\n        def wrapper(cls, *args, **kwargs):\n            is_awaited = False\n            for code in inspect.getframeinfo(inspect.currentframe().f_back).code_context:\n                try:\n                    ast_tree = ast.parse(code.strip())\n                    for node in ast.walk(ast_tree):\n                        if isinstance(node, ast.Await):\n                            is_awaited = True\n                except:\n                    pass\n            if from_coroutine():\n                if is_awaited:\n                    return asyncfunc(cls, *args, **kwargs)\n                else:\n                    return syncfunc(cls, *args, **kwargs)\n            else:\n                return syncfunc(cls, *args, **kwargs)\n\n        return wrapper\n\n    return coroutine\n"}
{"type": "source_file", "path": "fastapi_sqlalchemy/extensions.py", "content": "from __future__ import annotations\n\nimport ast\nimport asyncio\nimport gc\nimport inspect\nimport warnings\nfrom contextvars import ContextVar, Token\nfrom functools import wraps\nfrom typing import Any, Dict, List, Literal, Optional, Type, Union\n\nfrom curio.meta import from_coroutine\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.orm import DeclarativeMeta as DeclarativeMeta_\nfrom sqlalchemy.orm import Query, Session, declarative_base, sessionmaker\nfrom sqlalchemy.types import BigInteger\n\nfrom .exceptions import SessionNotAsync, SessionNotInitialisedError, SQLAlchemyAsyncioMissing\nfrom .types import ModelBase\n\ntry:\n    import sqlalchemy.ext.asyncio\n\n    sqlalchemy_asyncio = True\nexcept ImportError:\n    sqlalchemy_asyncio = False\ntry:\n    from sqlalchemy.ext.asyncio import (\n        AsyncEngine,\n        AsyncSession,\n        async_sessionmaker,\n        create_async_engine,\n    )\nexcept ImportError:\n    create_async_engine = None\n\n_session: ContextVar[Dict[str, Dict[SQLAlchemy, Session | AsyncSession]]] = ContextVar(\n    \"_session\", default={\"sync\": {}, \"async\": {}}\n)\n\n\ndef start_session() -> Token[Dict[str, Session | AsyncSession]]:\n    return _session.set({\"sync\": {}, \"async\": {}})\n\n\ndef reset_session(token: Token[Dict[str, Session | AsyncSession]]) -> None:\n    _session.reset(token)\n\n\nclass DBSession:\n    def __init__(self, db: SQLAlchemy):\n        self.db = db\n        self.child_session_sync = False\n        self.child_session_async = False\n\n    def __enter__(self):\n        if not isinstance(self.db.sync_session_maker, sessionmaker):\n            raise SessionNotInitialisedError\n        session = self.db.sync_session_maker(**self.db.sync_session_args)\n        session_dict = _session.get()\n        if not session_dict[\"sync\"].get(self.db):\n            session_dict[\"sync\"][self.db] = session\n            _session.set(session_dict)\n        else:\n            self.child_session_sync = True\n        return self.db\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type is not None:\n            self.db.sync_session.rollback()\n\n        elif self.db.commit_on_exit:\n            try:\n                self.db.sync_session.commit()\n                self.db.sync_session.rollback()\n            except:\n                pass\n        try:\n            if not self.child_session_sync:\n                self.db.sync_session.close()\n                session_dict = _session.get()\n                session_dict[\"sync\"].pop(self.db)\n                _session.set(session_dict)\n        except:\n            pass\n\n    async def __aenter__(self):\n        if not isinstance(self.db.async_session_maker, async_sessionmaker):\n            raise SessionNotInitialisedError\n        session = self.db.async_session_maker(**self.db.async_session_args)\n        session_dict = _session.get()\n        if not session_dict[\"async\"].get(self.db):\n            session_dict[\"async\"][self.db] = session\n            _session.set(session_dict)\n        else:\n            self.child_session_async = True\n        return self.db\n\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        if exc_type is not None:\n            await self.db.session.rollback()\n        elif self.db.commit_on_exit:\n            try:\n                await self.db.session.commit()\n                await self.db.session.rollback()\n            except:\n                pass\n        try:\n            if not self.child_session_async:\n                await self.db.session.close()\n                session_dict = _session.get()\n                session_dict[\"async\"].pop(self.db)\n                _session.set(session_dict)\n        except:\n            pass\n\n\nclass SQLAlchemy:\n    def __init__(\n        self,\n        url: Optional[URL] = None,\n        *,\n        async_url: Optional[URL] = None,\n        custom_engine: Optional[Engine] = None,\n        async_custom_engine: Optional[AsyncEngine] = None,\n        engine_args: Dict[str, Any] = None,\n        async_engine_args: Dict[str, Any] = None,\n        session_args: Dict[str, Any] = None,\n        async_session_args: Dict[str, Any] = None,\n        commit_on_exit: bool = False,\n        verbose: Literal[0, 1, 2, 3] = 0,\n        async_: bool = False,\n        expire_on_commit: Optional[bool] = False,\n        extended: bool = True,\n        _session_manager: DBSession = DBSession,\n    ):\n        self.initiated = False\n        self._Base: Type[DeclarativeMeta] = declarative_base(\n            metaclass=DeclarativeMeta, cls=ModelBase\n        )\n        setattr(self._Base, \"db\", self)\n        self.url = url\n        self.async_url = async_url\n        self.custom_engine = custom_engine\n        self.async_custom_engine = async_custom_engine\n        self.engine_args = engine_args or {}\n        self.async_engine_args = async_engine_args or {}\n        self.sync_session_args = session_args or {}\n        self.async_session_args = async_session_args or {}\n        self.commit_on_exit = commit_on_exit\n        self.session_manager: DBSession = _session_manager\n        self.verbose = verbose\n        self.extended = extended\n        if async_ and not async_sessionmaker:\n            raise SQLAlchemyAsyncioMissing(\"async_sessionmaker\")\n        self.async_ = async_\n        self.expire_on_commit = expire_on_commit\n        self._check_optional_components()\n        self._session_maker: sessionmaker = None\n        self.engine: Engine = None\n        self.async_engine: AsyncEngine = None\n        self.sync_session_maker: sessionmaker = None\n        self.async_session_maker: async_sessionmaker = None\n        if self.url:\n            self.init()\n        self.sync_session_args[\"expire_on_commit\"] = self.async_session_args[\"expire_on_commit\"] = (\n            False\n        )\n\n    def init(self, url: Optional[URL] = None, **options) -> None:\n        if url:\n            self.url = url\n        for key, value in options.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n            else:\n                raise AttributeError(f\"Attribute {key} not a valid attribute.\")\n        if not self.custom_engine and not self.url:\n            raise ValueError(\"You need to pass a url or a custom_engine parameter.\")\n        if not self.async_custom_engine and not self.async_url and self.async_:\n            raise ValueError(\"You need to pass a async_url or a async_custom_engine parameter.\")\n        self.engine = self._create_sync_engine()\n        self.async_engine = self._create_async_engine()\n        self.sync_session_maker = self._make_sync_session_maker()\n        self.async_session_maker = self._make_async_session_maker()\n\n        self.initiated = True\n        self.metadata = False\n\n    def create_all(self):\n        self._Base.metadata.create_all(self.engine)\n        self.metadata = True\n        return None\n\n    def drop_all(self, *, confirmed=False):\n        if not confirmed:\n            inp = \"\"\n            while not inp.lower() in [\"y\", \"n\"]:\n                inp = input(\n                    \"Are you sure you want to drop all tables? (This cannot be undone) (y/n): \"\n                )\n                if inp == \"n\":\n                    return None\n                else:\n                    continue\n        for obj in gc.get_objects():\n            if type(obj) == Session:\n                if obj.get_bind() == self.engine.url:\n                    obj.rollback()\n                    obj.close()\n            elif type(obj) == AsyncSession:\n                loop = asyncio.get_event_loop()\n                if obj.get_bind() == self.engine.url:\n                    loop.run_in_executor(None, obj.rollback)\n                    loop.run_in_executor(None, obj.close)\n        self._Base.metadata.drop_all(self.engine)\n        return None\n\n    def print(self, *values):\n        if self.verbose >= 3:\n            print(*values, flush=True)\n\n    def info(self, *values):\n        if self.verbose >= 2:\n            print(*values, flush=True)\n\n    def warning(self, message: str):\n        if self.verbose >= 1:\n            warnings.warn(message)\n\n    def sync_context(self, func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if not self.initiated:\n                self.init()\n            with self():\n                return func(*args, **kwargs)\n\n        return wrapper\n\n    def async_context(self, func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            if not self.initiated:\n                self.init()\n            async with self():\n                return await func(*args, **kwargs)\n\n        return wrapper\n\n    def _check_optional_components(self):\n        exceptions = []\n        if not sqlalchemy_asyncio and self.async_:\n            raise SQLAlchemyAsyncioMissing()\n        async_classes = [async_sessionmaker, create_async_engine]\n        if self.async_:\n            for cls in async_classes:\n                if not cls:\n                    exceptions.append(SQLAlchemyAsyncioMissing(cls.__name__))\n        if not self.async_ and all(async_classes):\n            self.print(\n                \"sqlalchemy[asyncio] is installed, to use set async_=True in SQLAlchemy constructor.\"\n            )\n\n        if exceptions:\n            raise Exception(*exceptions)\n\n    def _make_sync_session_maker(self) -> sessionmaker:\n        return sessionmaker(bind=self.engine, **self.sync_session_args)\n\n    def _make_async_session_maker(self) -> async_sessionmaker:\n        if self.async_:\n            return async_sessionmaker(bind=self.async_engine, **self.async_session_args)\n\n    def _create_sync_engine(self) -> Union[AsyncEngine, Engine]:\n        if self.custom_engine:\n            return self.custom_engine\n        else:\n            return create_engine(self.url, **self.engine_args)\n\n    def _create_async_engine(self) -> AsyncEngine:\n        if self.async_:\n            if self.async_custom_engine:\n                return self.async_custom_engine\n            else:\n                return create_async_engine(self.async_url, **self.async_engine_args)\n\n    def __call__(self) -> SQLAlchemy:\n        local_session = self.session_manager(db=self)\n        return local_session\n\n    def __enter__(self) -> SQLAlchemy:\n        return self()\n\n    def __exit__(self) -> None:\n        pass\n\n    async def __aenter__(self) -> SQLAlchemy:\n        return self()\n\n    async def __aexit__(self) -> None:\n        pass\n\n    @property\n    def session(self) -> Union[Session, AsyncSession]:\n        sessions = _session.get()\n        if sessions[\"async\"].get(self):\n            return sessions[\"async\"][self]\n        elif sessions[\"sync\"].get(self):\n            return sessions[\"sync\"][self]\n        else:\n            raise SessionNotInitialisedError\n\n    @property\n    def sync_session(self) -> Session:\n        sessions = _session.get()\n        if sessions[\"sync\"].get(self):\n            return sessions[\"sync\"][self]\n        elif sessions[\"async\"].get(self):\n            return sessions[\"async\"][self].sync_session\n        else:\n            raise SessionNotInitialisedError\n\n    def _make_dialects(self) -> None:\n        self.BigInteger = BigInteger()\n        self.BigInteger.with_variant()\n        return None\n\n    @property\n    def BaseModel(self) -> Type[ModelBase]:\n        return self._Base\n\n    @property\n    def Base(self) -> Type[DeclarativeMeta]:\n        return self._Base\n\n\nclass DeclarativeMeta(DeclarativeMeta_):\n    db: SQLAlchemy\n    session: Session\n\n    def __init__(self, name, bases, attrs):\n        for base in bases:\n            if hasattr(base, \"db\"):\n                self.db = base.db\n                break\n        super().__init__(name, bases, attrs)\n\n    @property\n    def session(self) -> Union[Session, AsyncSession]:\n        return self.db.session\n\n    @property\n    def query(self) -> Query:\n        return self.db.session.query(self)\n\n\ndb: SQLAlchemy = SQLAlchemy()\n"}
{"type": "source_file", "path": "examples/single_db/models.py", "content": "from sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.orm import declarative_base, sessionmaker\n\nfrom fastapi_sqlalchemy import ModelBase, SQLAlchemy\n\ndb = SQLAlchemy(url=\"sqlite:///example.db\")\n\n\n# Define the User class representing the \"users\" database table\n# Using the SQLAlchemy Base property instead of defining your own\n# And inheriting from the BaseModel class for type hinting and helpful builtin methods and properties\nclass User(ModelBase, db.Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    email = Column(String)\n\n    def __repr__(self):\n        return f\"User(id={self.id}, name='{self.name}',email='{self.email}')\"\n"}
{"type": "source_file", "path": "fastapi_sqlalchemy/exceptions.py", "content": "from typing import List\n\n\nclass MissingSessionError(Exception):\n    \"\"\"Excetion raised for when the user tries to access a database session before it is created.\"\"\"\n\n    def __init__(self):\n        msg = \"\"\"\n        No session found! Either you are not currently in a request context,\n        or you need to manually create a session context by using a `db` instance as\n        a context manager e.g.:\n\n        with db():\n            db.session.query(User).all()\n        \"\"\"\n\n        super().__init__(msg)\n\n\nclass SessionNotInitialisedError(Exception):\n    \"\"\"Exception raised when the user creates a new DB session without first initialising it.\"\"\"\n\n    def __init__(self):\n        msg = \"\"\"\n        Session not initialised! Ensure that DBSessionMiddleware has been initialised before\n        attempting database access.\n        \"\"\"\n\n        super().__init__(msg)\n\n\nclass SessionNotAsync(TypeError):\n    \"\"\"Exception raised when the user calls sync_session from within a synchronous function.\"\"\"\n\n    def __init__(self):\n        msg = \"\"\"\n        Session not async! Ensure that you are calling sync_session from within an asynchronous function.\n        \"\"\"\n        super().__init__(msg)\n\n\nclass DBSessionType(TypeError):\n    \"\"\"Exception raised when the user passes an object to DBSessionMiddleware that is not of DBSession or List[DBSession] type.\"\"\"\n\n    def __init__(self):\n        msg = \"\"\"\n        Middleware not initialised! Ensure that db is of type DBSession or List[DBSession].\n        \"\"\"\n\n        super().__init__(msg)\n\n\nclass SQLAlchemyType(TypeError):\n    \"\"\"Exception raised when the user passes an object to DBSessionMiddleware that is not of SQLAlchemy or List[SQLAlchemy] or URL type.\"\"\"\n\n    def __init__(self):\n        msg = \"\"\"\n        Middleware not initialized! Ensure that db is of type SQLAlchemy or List[SQLAlchemy] or URL.\n        \"\"\"\n\n        super().__init__(msg)\n\n\nclass NonTableQuery(TypeError):\n    \"\"\"Exception raised when the user attempts to call .query on a non-table object.\"\"\"\n\n    def __init__(self):\n        msg = \"\"\"\n        Non-table object! Ensure that the object you are querying is a table.\n        \"\"\"\n\n        super().__init__(msg)\n\n\nclass SQLAlchemyAsyncioMissing(ImportError):\n    \"\"\"Exception raised when the user attempts to use the async_ parameter without installing SQLAlchemy-Asyncio.\"\"\"\n\n    def __init__(self, missing: str = \"sqlalchemy.ext.asyncio\"):\n        if \"sqlalchemy.ext.asyncio\" not in missing:\n            missing = \"sqlalchemy.ext.asyncio\" + str(\n                missing if missing[0] == \".\" else \".\" + missing\n            )\n\n        msg = \"\"\"\n        {package} is missing, please install using 'pip install sqlalchemy[asyncio]' or set async_ = False when initializing fastapi_sqlalchemy.SQLAlchemy.\n        \"\"\".format(\n            package=missing\n        )\n\n        super().__init__(msg)\n\n\nclass BuiltinNonExistent(AttributeError):\n    \"\"\"Exception raised when the user attempts to map a builtin property that does not exist.\"\"\"\n\n    def __init__(self, prop: str):\n        msg = f\"\"\"Builtin {prop} does not exist!\"\"\"\n\n        super().__init__(msg)\n\n\nclass TooManyBuiltinOverrides(AttributeError):\n    \"\"\"Exception raised when the user attempts to map a builtin property that does not exist.\"\"\"\n\n    def __init__(self, prop: str):\n        msg = f\"\"\"Too many builtin overrides! Strict maximum of 1 builtin override per model.\"\"\"\n\n        super().__init__(msg)\n"}
{"type": "source_file", "path": "fastapi_sqlalchemy/__init__.py", "content": "from .extensions import SQLAlchemy, db\nfrom .middleware import DBSessionMiddleware\nfrom .types import ModelBase\n\n__all__ = [\"db\", \"DBSessionMiddleware\", \"SQLAlchemy\"]\n\n__version__ = \"0.5.3\"\n"}
{"type": "source_file", "path": "fastapi_sqlalchemy/types.py", "content": "from __future__ import annotations\n\nimport ast\nimport asyncio\nimport inspect\nfrom typing import Any, Awaitable, Callable, Coroutine, List, Optional, Self, Union, overload\n\nfrom curio.meta import from_coroutine\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import DeclarativeMeta as DeclarativeMeta_\nfrom sqlalchemy.orm import Query, Session, aliased\nfrom sqlalchemy.sql import ColumnExpressionArgument\n\nfrom .decorators import awaitable\n\n\nclass ModelBase(object):\n    query: Query\n    session: Session | AsyncSession\n\n    def __new__(cls, *args, **kwargs):\n        obj = super().__new__(cls)\n        if isinstance(obj.db.session, AsyncSession):\n            obj.query = cls.db.sync_session.query(cls)\n        else:\n            obj.query = cls.db.session.query(cls)\n        return obj\n\n    @property\n    def session(self) -> Session | AsyncSession:\n        return self.db.session\n\n    @property\n    def sync_session(self) -> Session:\n        return self.db.sync_session\n\n    async def new(cls, **kwargs) -> Self:\n        obj: Self = cls(**kwargs)\n        await obj.save()\n        return obj\n\n    @classmethod\n    @awaitable(new)\n    def new(cls: Self, **kwargs) -> Union[Coroutine[Any, Any, Self], Self]:\n        obj: Self = cls(**kwargs)\n        obj.save()\n        return obj\n\n    async def get_all(cls, *criterion: ColumnExpressionArgument[bool], **kwargs: Any) -> List[Self]:\n        if criterion:\n            stmt = select(cls).filter(*criterion)\n        else:\n            stmt = select(cls).filter_by(**kwargs)\n        result = await cls.session.execute(stmt)\n        objs = result.scalars().all()\n        return objs\n\n    @classmethod\n    @awaitable(get_all)\n    def get_all(\n        cls, *criterion: ColumnExpressionArgument[bool], **kwargs: Any\n    ) -> Union[List[Self], Coroutine[Any, Any, List[Self]]]:\n        if criterion:\n            lst: List[Self] = cls.query.filter(*criterion, **kwargs).all()\n        else:\n            lst: List[Self] = cls.query.filter_by(**kwargs).all()\n        return lst\n\n    async def get(cls, *criterion: ColumnExpressionArgument[bool], **kwargs: Any) -> Self:\n        if criterion:\n            result = await cls.session.execute(select(cls).filter(*criterion))\n        else:\n            result = await cls.session.execute(select(cls).filter_by(**kwargs))\n        return result.scalars().first()\n\n    @classmethod\n    @awaitable(get)\n    def get(\n        cls, *criterion: ColumnExpressionArgument[bool], **kwargs: Any\n    ) -> Union[Coroutine[Any, Any, Self], Self]:\n        if criterion:\n            return cls.query.filter(*criterion, **kwargs).first()\n        return cls.query.filter_by(**kwargs).first()\n\n    async def save(self) -> None:\n        t_e = self.session.sync_session.expire_on_commit\n        self.session.expire_on_commit = False\n        try:\n            self.session.add(self)\n        except:\n            pass\n        await self.session.commit()\n        self.session.sync_session.expire_on_commit = t_e\n\n    @awaitable(save)\n    def save(self) -> None:\n        try:\n            self.sync_session.add(self)\n        except:\n            pass\n        self.sync_session.commit()\n\n    async def update(self, **kwargs):\n        for attr, value in kwargs.items():\n            setattr(self, attr, value)\n        await self.save()\n\n    @awaitable(update)\n    def update(self, **kwargs):\n        for attr, value in kwargs.items():\n            setattr(self, attr, value)\n        self.save()\n\n    async def delete(self):\n        await self.session.delete(self)\n        await self.session.commit()\n\n    @awaitable(delete)\n    def delete(self):\n        self.sync_session.delete(self)\n        self.sync_session.commit()\n"}
{"type": "source_file", "path": "setup.py", "content": "import re\nfrom pathlib import Path\n\nfrom setuptools import setup\n\nwith open(Path(\"fastapi_sqlalchemy\") / \"__init__.py\", encoding=\"utf-8\") as fh:\n    version = re.search(r'__version__ = \"(.*?)\"', fh.read(), re.M).group(1)\n\nwith open(\"README.md\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name=\"FastAPI-SQLAlchemy-improved\",\n    version=version,\n    url=\"https://github.com/Ewen-Zippedscript/fastapi-sqlalchemy\",\n    project_urls={\n        \"Code\": \"https://github.com/Ewen-Zippedscript/fastapi-sqlalchemy\",\n        \"Issue tracker\": \"https://github.com/Ewen-Zippedscript/fastapi-sqlalchemy/issues\",\n    },\n    license=\"MIT\",\n    author=\"Ewen Lorimer\",\n    author_email=\"ewen@zippedscript.com\",\n    description=\"Adds simple SQLAlchemy support with multiple databases to FastAPI.\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    packages=[\"fastapi_sqlalchemy\"],\n    package_data={\"fastapi_sqlalchemy\": [\"py.typed\"]},\n    zip_safe=False,\n    python_requires=\">=3.7\",\n    install_requires=[\"starlette>=0.12.9\", \"SQLAlchemy>=1.2\", \"fastapi>=0.52.0\", \"curio>=1.6\"],\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Environment :: Web Environment\",\n        \"Framework :: AsyncIO\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Topic :: Internet :: WWW/HTTP :: HTTP Servers\",\n        \"Topic :: Internet :: WWW/HTTP :: Dynamic Content\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n    ],\n)\n"}
{"type": "source_file", "path": "fastapi_sqlalchemy/sqlalchemy_types.py", "content": "from sqlalchemy import BigInteger, TypeDecorator\n\n\nclass BigIntegerType(TypeDecorator):\n    impl = BigInteger\n"}
{"type": "source_file", "path": "fastapi_sqlalchemy/middleware.py", "content": "from __future__ import annotations\n\nimport asyncio\nimport inspect\nimport logging\nfrom contextlib import AsyncExitStack, ExitStack\nfrom typing import Dict, List, Optional, Union\n\nfrom curio.meta import from_coroutine\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.orm import sessionmaker\nfrom starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint\nfrom starlette.requests import Request\nfrom starlette.types import ASGIApp\n\nfrom .exceptions import SQLAlchemyType\nfrom .extensions import SQLAlchemy\nfrom .extensions import db as db_\nfrom .extensions import reset_session, start_session\n\n\nclass DBStateMap:\n    def __init__(self):\n        self.dbs: Dict[URL, sessionmaker] = {}\n        self.initialized = False\n\n    def __getitem__(self, item: URL) -> sessionmaker:\n        return self.dbs[item]\n\n    def __setitem__(self, key: URL, value: sessionmaker) -> None:\n        if not self.initialized:\n            self.dbs[key] = value\n        else:\n            raise ValueError(\"DBStateMap is already initialized\")\n\n\ndef is_async():\n    try:\n        asyncio.get_running_loop()\n        return True\n    except RuntimeError:\n        return False\n\n\nclass DBSessionMiddleware(BaseHTTPMiddleware):\n    def __init__(\n        self,\n        app: ASGIApp,\n        db: Optional[Union[List[SQLAlchemy], SQLAlchemy]] = None,\n        db_url: Optional[URL] = None,\n        **options,\n    ):\n        super().__init__(app)\n        self.state_map = DBStateMap()\n        if not (type(db) == list or type(db) == SQLAlchemy) and not db_url:\n            raise SQLAlchemyType()\n        if db_url and not db:\n            global db_\n            if not db_.initiated:\n                db_.init(url=db_url, **options)\n            self.dbs = [db_]\n        if type(db) == SQLAlchemy:\n            self.dbs = [\n                db,\n            ]\n        elif type(db) == list:\n            self.dbs = db\n        for db in self.dbs:\n            db.create_all()\n\n    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint):\n        req_async = False\n        try:\n            for route in self.app.app.app.routes:\n                if route.path == request.scope[\"path\"]:\n                    req_async = inspect.iscoroutinefunction(route.endpoint)\n        except:\n            req_async = False\n        token = start_session()\n        exception = None\n        async with AsyncExitStack() as async_stack:\n            with ExitStack() as sync_stack:\n                contexts = [\n                    await async_stack.enter_async_context(ctx())\n                    for ctx in self.dbs\n                    if ctx.async_ and req_async\n                ]\n                contexts.extend([sync_stack.enter_context(ctx()) for ctx in self.dbs])\n                try:\n                    response = await call_next(request)\n                except Exception as e:\n                    exception = e\n                    for db in self.dbs:\n                        db.session.rollback()\n\n        if exception:\n            raise exception\n\n        reset_session(token)\n        return response\n\n        # if req_async:\n        #     return dispatch_inner()\n        # else:\n        #     with ExitStack() as stack:\n        #         contexts = [stack.enter_context(ctx()) for ctx in self.dbs]\n        #         response = call_next(request)\n        # return response\n"}

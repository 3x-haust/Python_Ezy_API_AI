{"repo_info": {"repo_name": "he-weather-bot", "repo_owner": "daya0576", "repo_url": "https://github.com/daya0576/he-weather-bot"}}
{"type": "test_file", "path": "telegram_bot/tests/__init__.py", "content": "# -*- coding: utf-8 -*-\n"}
{"type": "test_file", "path": "telegram_bot/tests/test_weather_warning.py", "content": "import asyncio\nimport time\n\nimport pytest\nfrom dotenv import load_dotenv\n\nload_dotenv(\".env_test\")\nfrom telegram_bot.database.models import Chat, DingBots\nfrom telegram_bot.cron import tasks\nfrom telegram_bot.intergration.weather.models.warn_model import WarnModel\n\nfake_warn_model = WarnModel(\"text\", \"type\", \"level\")\nsame_fake_warn_model = WarnModel(\"text\", \"type\", \"level\")\ndiff_fake_warn_model = WarnModel(\"text_diff\", \"type\", \"level\")\nfake_chat = Chat()\nfake_chat.latitude = 123\nfake_chat.longitude = 123\nfake_ding_bot = DingBots()\n\n\n@pytest.fixture(scope=\"function\")\ndef mockit(mocker):\n    # mock weather api\n    warning_mock = mocker.patch(\n        'telegram_bot.intergration.weather.he_weather_client.HeWeatherClient.get_weather_warning')\n    warning_mock.return_value = WarnModel(\"text\", \"type\", \"level\")\n    # mock telegram api\n    message_mock = mocker.patch('telegram_bot.service.telegram.TelegramMessageService.send_text')\n    mocker.patch('telegram_bot.service.dingtalk.DingBotMessageService.send_text')\n    return warning_mock, message_mock\n\n\ndef test_diff_warnings(mockit):\n    warning_mock, message_mock = mockit\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    assert message_mock.call_count == 1\n\n    # same warnings\n    warning_mock.return_value = same_fake_warn_model\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    assert message_mock.call_count == 1\n\n    # different warnings\n    warning_mock.return_value = diff_fake_warn_model\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    assert message_mock.call_count == 2\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    assert message_mock.call_count == 2\n\n    # waiting for cache expire\n    time.sleep(1)\n"}
{"type": "test_file", "path": "telegram_bot/tests/test_app.py", "content": "import pytest\nfrom dotenv import load_dotenv\nfrom fastapi.testclient import TestClient\n\n\n@pytest.fixture(scope='session', autouse=True)\ndef load_env():\n    load_dotenv(\".env_test\")\n\n\n@pytest.fixture\ndef client():\n    from telegram_bot import app\n    # app.app.config['TESTING'] = True\n    client = TestClient(app.app)\n    return client\n\n\ndef test_route(client):\n    response = client.get(\"/\")\n    assert response.status_code == 200\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/he_weather_client.py", "content": "import asyncio\nimport random\nfrom typing import Dict, List, Optional\n\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\nfrom telegram_bot.intergration.location.he_location_client import Location\nfrom telegram_bot.intergration.weather.base_weather_client import WeatherClient\nfrom telegram_bot.intergration.weather.const import (\n    WEATHER_6H_MESSAGE_TEMPLATE,\n    WEATHER_2D_MESSAGE_TEMPLATE,\n)\nfrom telegram_bot.intergration.weather.models.he_weather_model import HeWeatherModel\nfrom telegram_bot.intergration.weather.models.warn_model import WarnModel\nfrom telegram_bot.settings import aio_lru_cache_1h\nfrom telegram_bot.utils.date_util import DateUtil\nfrom telegram_bot.utils.retry_util import tries\n\n\nclass HeWeatherClient(WeatherClient):\n    \"\"\"和风天气客户端\"\"\"\n\n    # 和风生活指数选项，随机选择\n    LIFE_OPTIONS = tuple(range(1, 17))\n\n    def __init__(self, http_client: HttpClient, key: str):\n        self.http_client = http_client\n        self.key = key\n\n    #################################### 对外接口 ####################################\n    @aio_lru_cache_1h\n    async def get_weather_forecast(self, location: Location) -> str:\n        weather_3d_data, forecast_air, life_1d = await asyncio.gather(\n            self._get_weather_3d(location),\n            self._get_air_now(location),\n            self._get_indices_1d(location, random.choice(self.LIFE_OPTIONS)),\n        )\n        d1_forecast_dict, d2_forecast_dict = weather_3d_data[:2]\n\n        # 构建天气预报数据模型\n        d1_forecast = HeWeatherModel.build(\n            d1_forecast_dict, air_now=forecast_air, indices=life_1d\n        )\n        d2_forecast = HeWeatherModel.build(d2_forecast_dict)\n\n        # 组装最终天气文案\n        extra = \"\"\n        if d1_forecast.warning_text:\n            extra = f\"⚠️{d1_forecast.warning_text}\"\n        elif d1_forecast.life_text:\n            extra = d1_forecast.life_text\n\n        return WEATHER_2D_MESSAGE_TEMPLATE.format(\n            location=location.name,\n            d1=DateUtil.get_day_of_week(location.tz, 0),\n            d2=DateUtil.get_day_of_week(location.tz, 1),\n            d1_pretty=str(d1_forecast),\n            d2_pretty=str(d2_forecast),\n            extra=extra,\n        )\n\n    async def get_weather_warning(self, location: Location) -> Optional[WarnModel]:\n        \"\"\"获取自然灾害信息\"\"\"\n        warning_list = await self._get_warning_now(location)\n        if not warning_list:\n            return\n\n        w = warning_list[0]\n        return WarnModel(w[\"text\"], w[\"typeName\"], w[\"level\"])\n\n    async def get_weather_6h_forecast_text(self, location: Location) -> str:\n        d = await self._get_weather_hour(location)\n        hour = DateUtil.get_cur_hour(location.tz)\n        hours_text = \"\\n\".join(\n            f\"{(hour + i) % 24:02d}:00：{d[i]['text']} {d[i]['temp']}℃\" for i in range(6)\n        )\n\n        return WEATHER_6H_MESSAGE_TEMPLATE.format(\n            location=location.name, hours=hours_text\n        )\n\n    #################################### 原始接口 ####################################\n    @tries(times=5)\n    async def _do_get(self, api_type, weather_type, params: Dict) -> Dict:\n        url = f\"https://devapi.qweather.com/v7/{api_type}/{weather_type}\"\n        params.update(key=self.key)\n        return await self.http_client.get(url, params)\n\n    async def _get_weather_3d(self, location: Location) -> List:\n        \"\"\"城市天气API / 逐天天气预报\"\"\"\n        result = await self._do_get(\n            \"weather\", \"3d\", {\"location\": location.get_location()}\n        )\n        return result.get(\"daily\", [])\n\n    async def _get_weather_hour(self, location: Location) -> List:\n        \"\"\"城市天气API / 逐小时天气预报\"\"\"\n        result = await self._do_get(\n            \"weather\", \"24h\", {\"location\": location.get_location()}\n        )\n        return result.get(\"hourly\", [])\n\n    async def _get_indices_1d(self, location: Location, indices_type) -> List:\n        \"\"\"天气指数API / 天气生活指数\"\"\"\n        params = {\"location\": location.get_location(), \"type\": indices_type}\n        result = await self._do_get(\"indices\", \"1d\", params)\n        return result.get(\"daily\", [])\n\n    async def _get_air_now(self, location: Location) -> Dict:\n        \"\"\"空气API / 实时空气质量\"\"\"\n        result = await self._do_get(\"air\", \"now\", {\"location\": location.get_location()})\n        return result.get(\"now\", {})\n\n    async def _get_warning_now(self, location: Location) -> List[Dict]:\n        \"\"\"天气灾害预警\"\"\"\n        result = await self._do_get(\n            \"warning\", \"now\", {\"location\": location.get_location()}\n        )\n        return result.get(\"warning\", [])\n\n    def get_weather_photo(self, location) -> str:\n        pass\n"}
{"type": "source_file", "path": "telegram_bot/controllers/meta.py", "content": "from fastapi import Depends, APIRouter\nfrom loguru import logger\nfrom sqlalchemy.orm import Session\nfrom starlette.responses import RedirectResponse\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db, get_db_session\nfrom telegram_bot.settings import aio_lru_cache_1h, settings\n\nrouter = APIRouter()\n\n\n@aio_lru_cache_1h\nasync def get_user_count(db):\n    return crud.get_user_count(db)\n\n\n@router.get(\"/users/count\")\nasync def active_users_count(db: Session = Depends(get_db)):\n    \"\"\"活跃用户总数\"\"\"\n    badge_url = f\"https://img.shields.io/badge/users-{await get_user_count(db)}-blue\"\n    return RedirectResponse(badge_url)\n\n\n@router.get(\"/\")\nasync def index():\n    return \"hello\"\n\n\n@router.get(\"/config\")\nasync def config():\n    logger.info(settings)\n    return \"OK\"\n\n\n@router.get(\"/sentry\")\nasync def test_sentry():\n    return 1 / 0\n\n\n@router.get(\"/users\")\nasync def users():\n    with get_db_session() as db:\n        return crud.get_users(db)\n\n\n@router.get(\"/user_count\")\nasync def user_count():\n    with get_db_session() as db:\n        return await get_user_count(db)\n"}
{"type": "source_file", "path": "telegram_bot/controllers/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/controllers/release.py", "content": "import asyncio\n\nfrom fastapi import Depends, APIRouter\nfrom loguru import logger\nfrom sentry_sdk import capture_exception\nfrom sqlalchemy.orm import Session\n\nfrom telegram_bot.database import crud, models\nfrom telegram_bot.database.database import get_db\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.settings import aio_lru_cache_partial, settings\nfrom telegram_bot.telegram.dispatcher import dp\nfrom telegram_bot.telegram.keyboard.keyboard_markup_factory import KeyboardMarkUpFactory\n\nrouter = APIRouter()\nONE_YEAR = 60 * 60 * 24 * 365\n\nV0_1_0 = \"\"\"\nv0.1.1 稳定正式版已发布。如有任何问题，请联系 @daya233\n\n**✨ FEATURES**\n1. 支持自定义通知时间（所在地时区）\n2. 支持开启/关闭订阅\n3. 告警样式优化（新增 emoji）\n4. 支持群订阅\n\n**🌝 BUG FiX**\n1. 修复重复投递的问题\n2. 修复消息丢失的问题（使命必达）\n\"\"\"\n\n\n@aio_lru_cache_partial(ttl=ONE_YEAR)\nasync def do_release(chat: models.Chat):\n    \"\"\"发送版本更新\"\"\"\n    markup = KeyboardMarkUpFactory.build_main_menu(chat)\n    await TelegramMessageService.send_keyboard_markup(dp.bot, chat.chat_id, V0_1_0, markup, parse_mode=\"Markdown\")\n\n    return True\n\n\n@router.get(\"/release_v1\")\nasync def cron_handler(db: Session = Depends(get_db)):\n    if not settings.DO_RELEASE:\n        return {\"message\": \"disable\"}\n\n    all_active_users = crud.get_active_users(db)\n\n    # 并行处理，单个 exception 不中断其他任务\n    results = await asyncio.gather(\n        *[do_release(user) for user in all_active_users],\n        return_exceptions=True\n    )\n    # 汇总异常处理\n    success = 0\n    for result in results:\n        if not isinstance(result, Exception):\n            success += 1\n            continue\n        logger.exception(result)\n        capture_exception(result)\n\n    logger.info(f\"released! {success}/{len(results)})\")\n    return {\"message\": f\"{success}/{len(results)}\"}\n"}
{"type": "source_file", "path": "telegram_bot/intergration/dingding/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/cron/__init__.py", "content": "from apscheduler.events import EVENT_ALL, JobExecutionEvent\nfrom apscheduler.jobstores.redis import RedisJobStore\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom loguru import logger\nfrom pytz import utc\nfrom sentry_sdk import capture_exception\n\nfrom telegram_bot.settings import redis_config\n\njobstores = {\n    \"default\": RedisJobStore(\n        host=redis_config.host, port=redis_config.port, password=redis_config.password\n    )\n}\njob_defaults = {}\nexecutors = {\n    \"default\": {\"type\": \"threadpool\", \"max_workers\": 10},\n}\n\n\ndef my_listener(event: JobExecutionEvent):\n    if isinstance(event, JobExecutionEvent):\n        logger.info(f\"my_listener: {event.scheduled_run_time}\")\n        if event.exception:\n            capture_exception(error=event.exception)\n            logger.exception(str(event.exception), \"The job crashed :(\")\n    else:\n        logger.info(f\"my_listener: {event}\")\n\n\nscheduler = AsyncIOScheduler(timezone=utc)\nscheduler.add_listener(my_listener, EVENT_ALL)\n"}
{"type": "source_file", "path": "telegram_bot/database/models.py", "content": "from datetime import datetime\nfrom typing import Iterable, Tuple\n\nfrom sqlalchemy import (\n    Boolean,\n    Column,\n    String,\n    BigInteger,\n    Integer,\n    DateTime,\n    UniqueConstraint,\n    ForeignKey,\n)\nfrom sqlalchemy.orm import relationship\n\nfrom .database import Base\nfrom ..intergration.location.he_location_client import Location\n\n\nclass Chat(Base):\n    __tablename__ = \"users\"\n\n    chat_id = Column(BigInteger, primary_key=True, index=True)\n    is_active = Column(Boolean, default=True)\n\n    latitude = Column(String)\n    longitude = Column(String)\n    city = Column(String, nullable=False)\n    city_name = Column(String, nullable=False)\n    time_zone = Column(String, nullable=False)\n\n    # 外键：https://docs.sqlalchemy.org/en/14/orm/basic_relationships.html\n    cron_jobs = relationship(\"CronJobs\", backref=\"parent\")\n    ding_bot = relationship(\"DingBots\", back_populates=\"chat\", uselist=False)\n    locations = relationship(\"Locations\", backref=\"parent\")\n\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    @property\n    def location(self):\n        return Location(\n            name=self.city_name,\n            lat=float(self.latitude),\n            lon=float(self.longitude),\n            tz=self.time_zone,\n        )\n\n    def is_location_exist(self):\n        return self.latitude and self.longitude\n\n    @property\n    def sub_hours(self) -> Tuple:\n        return tuple(job.hour for job in self.cron_jobs)\n\n    @property\n    def all_locations(self) -> Iterable[Location]:\n        return [self.location, *(x.location for x in self.locations)]\n\n    def __str__(self) -> str:\n        return f\"chat_{self.chat_id}_{self.city_name}({self.location})\"\n\n    def __repr__(self) -> str:\n        return f\"chat_{self.chat_id}\"\n\n\nclass CronJobs(Base):\n    __tablename__ = \"cron_jobs\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    chat_id = Column(BigInteger, ForeignKey(\"users.chat_id\"))\n    hour = Column(String, nullable=False)\n\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    __table_args__ = (UniqueConstraint(\"chat_id\", \"hour\"),)\n\n\nclass DingBots(Base):\n    __tablename__ = \"ding_bots\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    token = Column(String, index=True)\n\n    chat_id = Column(BigInteger, ForeignKey(\"users.chat_id\"))\n    chat = relationship(\"Chat\", back_populates=\"ding_bot\")\n\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    def __str__(self) -> str:\n        return f\"ding_bot_{self.token}\"\n\n    __repr__ = __str__\n\n\nclass Locations(Base):\n    __tablename__ = \"locations\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    chat_id = Column(BigInteger, ForeignKey(\"users.chat_id\"))\n\n    latitude = Column(String)\n    longitude = Column(String)\n    city = Column(String, nullable=False)\n    city_name = Column(String, nullable=False)\n    time_zone = Column(String, nullable=False)\n\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    @property\n    def location(self):\n        return Location(\n            name=self.city_name,\n            lat=float(self.latitude),\n            lon=float(self.longitude),\n            tz=self.time_zone,\n        )\n\n    def __str__(self) -> str:\n        return f\"location_{self.chat_id}_{self.city_name}({self.location})\"\n\n    def __repr__(self) -> str:\n        return f\"location_{self.chat_id}\"\n"}
{"type": "source_file", "path": "telegram_bot/intergration/__init__.py", "content": "from telegram_bot.intergration.dingding.dingbot import DingBotClient\nfrom telegram_bot.intergration.http.httpx_client import HttpxClient\nfrom telegram_bot.intergration.http.request_http_client import RequestHttpClient\nfrom telegram_bot.intergration.location.he_location_client import HeLocationClient\nfrom telegram_bot.intergration.weather.he_weather_client import HeWeatherClient\nfrom telegram_bot.intergration.weather.wttr_weather_client import AsciiWeatherClient\n\n# HTTP 客户端\nfrom telegram_bot.settings import settings\n\nrequest_cli = RequestHttpClient()\nhttpx_cli = HttpxClient()\n\n# 和风天气预报客户端\nhe_weather = HeWeatherClient(httpx_cli, settings.HE_WEATHER_API_TOKEN)\nascii_weather = AsciiWeatherClient()\nhe_location_client = HeLocationClient(httpx_cli)\n\n# 钉钉客户端\nding_bot_client = DingBotClient(httpx_cli)\n\n__all__ = [\n    \"he_weather\",\n    \"ascii_weather\",\n    \"he_location_client\",\n    \"ding_bot_client\"\n]\n"}
{"type": "source_file", "path": "telegram_bot/intergration/http/httpx_client.py", "content": "from typing import Dict, Optional\n\nimport httpx\nfrom loguru import logger\nfrom tenacity import retry, stop_after_attempt\n\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\n\n\nclass HttpxClient(HttpClient):\n    def __init__(self):\n        transport = httpx.AsyncHTTPTransport(retries=3)\n        timeout = httpx.Timeout(15.0, connect=60.0)\n        self.client = httpx.AsyncClient(transport=transport, timeout=timeout)\n\n    @retry(stop=stop_after_attempt(3))\n    async def get(self, url: str, params: Optional[Dict] = None) -> Dict:\n        logger.info(f\"[http][get][request]{url}\")\n        r = await self.client.get(url, params=params)\n        logger.info(f\"[http][get][response]{url},{r.status_code},{r.json()}\")\n\n        r.raise_for_status()\n        return r.json()\n\n    @retry(stop=stop_after_attempt(3))\n    async def post(self, url: str, params: Optional[Dict] = None) -> Dict:\n        logger.info(f\"[http][post][request]{url}\")\n        headers = {\"Content-Type\": \"application/json\"}\n        r = await self.client.post(url, json=params, headers=headers)\n        logger.info(f\"[http][post][response]{url},{r.status_code},{r.json()}\")\n\n        r.raise_for_status()\n        return r.json()\n"}
{"type": "source_file", "path": "telegram_bot/database/crud.py", "content": "from typing import Iterable, List\n\nfrom sqlalchemy.orm import Session, make_transient\nfrom sqlalchemy import func\n\nfrom telegram_bot.database import models\nfrom telegram_bot.intergration.location.he_location_client import Location\n\n\ndef is_user_exists(db: Session, chat_id: str) -> bool:\n    return (\n        db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first() is not None\n    )\n\n\ndef get_user(db: Session, chat_id: str) -> models.Chat:\n    return db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n\n\ndef get_users(db: Session, skip: int = 0, limit: int = 100000) -> List[models.Chat]:\n    return db.query(models.Chat).offset(skip).limit(limit).all()\n\n\ndef get_user_locations(db: Session, chat_id: str) -> Iterable[Location]:\n    chat = db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n    if not chat:\n        return []\n    yield chat.location\n\n    locations = filter_locations(db, chat_id)\n    yield from [x.location for x in locations]\n\n\ndef get_active_users(\n    db: Session, skip: int = 0, limit: int = 100000\n) -> List[models.Chat]:\n    return (\n        db.query(models.Chat)\n        .filter(models.Chat.is_active.is_(True))\n        .offset(skip)\n        .limit(limit)\n        .all()\n    )\n\n\ndef get_user_count(db: Session) -> int:\n    return db.query(func.count(models.Chat.chat_id)).scalar()\n\n\ndef update_user_status(db: Session, chat_id: str, is_active: bool):\n    user = db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n    if user:\n        user.is_active = is_active\n        db.merge(user)\n    db.commit()\n\n\ndef update_location_name(db: Session, chat_id: str, location_name: str) -> None:\n    chat = db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n    if chat:\n        chat.city_name = location_name\n        chat.city = location_name\n        db.merge(chat)\n    db.commit()\n\n\ndef migrate_user_by_chat_id(db: Session, chat_id: str, new_chat_id: str):\n    user: models.Chat = (\n        db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n    )\n    if not user:\n        raise Exception(f\"chat_id does not exist: {chat_id}!!\")\n\n    db.expunge(user)\n    make_transient(user)\n    user.chat_id = new_chat_id\n    db.add(user)\n\n    # 复制订阅的定时任务\n    cron_job_list = (\n        db.query(models.CronJobs).filter(models.CronJobs.chat_id == chat_id).all()\n    )\n    for cron_job in cron_job_list:\n        db.expunge(cron_job)\n        make_transient(cron_job)\n        cron_job.chat_id = new_chat_id\n        cron_job.id = None\n        db.add(cron_job)\n\n    db.commit()\n\n\ndef update_or_create_user_by_location(\n    db: Session, chat_id: str, location: Location\n) -> models.Chat:\n    chat = models.Chat(\n        chat_id=int(chat_id),\n        latitude=\"{:.2f}\".format(location.lat),\n        longitude=\"{:.2f}\".format(location.lon),\n        city=location.name,\n        city_name=location.name,\n        time_zone=location.tz,\n    )\n\n    if db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first():\n        # update\n        chat = db.merge(chat)\n    else:\n        # create\n        chat.is_active = True\n        db.add(chat)\n\n    db.commit()\n    db.refresh(chat)\n    return chat\n\n\ndef add_location(db: Session, chat_id: str, location: Location) -> models.Chat:\n    sub_location = models.Locations(\n        chat_id=int(chat_id),\n        latitude=\"{:.2f}\".format(location.lat),\n        longitude=\"{:.2f}\".format(location.lon),\n        city=location.name,\n        city_name=location.name,\n        time_zone=location.tz,\n    )\n    db.add(sub_location)\n    db.commit()\n    db.refresh(sub_location)\n    return sub_location\n\n\ndef filter_locations(db: Session, chat_id: str) -> List[models.Locations]:\n    return db.query(models.Locations).filter(models.Locations.chat_id == chat_id).all()\n\n\ndef get_ding_bot(db: Session, chat_id: str) -> models.DingBots:\n    chat = get_user(db, chat_id)\n    return chat.ding_bot\n\n\ndef update_or_create_ding_bot(db: Session, chat_id: str, ding_token: str):\n    ding_bot = get_ding_bot(db, chat_id)\n    if ding_bot:\n        # update\n        ding_bot.token = ding_token\n        db.merge(ding_bot)\n    else:\n        # create\n        ding_bot = models.DingBots(token=ding_token, chat_id=chat_id)\n        db.add(ding_bot)\n\n    db.commit()\n\n\ndef remove_ding_bot(db: Session, chat_id: str):\n    dingbot = (\n        db.query(models.DingBots).filter(models.DingBots.chat_id == chat_id).first()\n    )\n\n    if dingbot:\n        db.delete(dingbot)\n        db.commit()\n        return True\n    return False\n\n\ndef remove_sub_location(db: Session, location_id: str) -> bool:\n    location = (\n        db.query(models.Locations).filter(models.Locations.id == location_id).first()\n    )\n    if location:\n        db.delete(location)\n        db.commit()\n        return True\n    return False\n\n\ndef get_cron_job(db, chat_id, hour):\n    return (\n        db.query(models.CronJobs)\n        .filter(models.CronJobs.chat_id == chat_id)\n        .filter(models.CronJobs.hour == hour)\n        .first()\n    )\n\n\ndef create_or_delete_cron_job(db: Session, chat_id: int, hour: str):\n    cron_job = (\n        db.query(models.CronJobs)\n        .filter(models.CronJobs.chat_id == chat_id)\n        .filter(models.CronJobs.hour == hour)\n        .first()\n    )\n\n    if cron_job:\n        db.delete(cron_job)\n        created = False\n    else:\n        cron_job_to_create = models.CronJobs(chat_id=chat_id, hour=hour)\n        db.add(cron_job_to_create)\n        created = True\n\n    db.commit()\n\n    return cron_job, created\n\n\ndef get_active_cron_jobs_by_hour(db: Session, hour: str):\n    return (\n        db.query(models.CronJobs)\n        .filter(models.CronJobs.hour == hour)\n        .filter(models.CronJobs.parent.is_active is True)\n        .all()\n    )\n"}
{"type": "source_file", "path": "telegram_bot/cron/tasks.py", "content": "from typing import List\nfrom telegram_bot.database import models\nfrom telegram_bot.intergration import he_weather\nfrom telegram_bot.intergration.location.he_location_client import Location\nfrom telegram_bot.service.dingtalk import DingBotMessageService\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.settings import aio_lru_cache_1h, aio_lru_cache_24h\nfrom telegram_bot.telegram.dispatcher import dp\nfrom tenacity import retry, stop_after_attempt\n\n\nasync def _do_send_weather_message(\n    chat: models.Chat, ding_bot: models.DingBots, text: str\n):\n    await TelegramMessageService.send_text(dp.bot, chat.chat_id, text)\n    if ding_bot:\n        await DingBotMessageService.send_text(ding_bot.token, text)\n    # 注意：必须返回值，以确保缓存生效\n    return True\n\n\nnotify_with_1h_cache = retry(stop=stop_after_attempt(3))(\n    aio_lru_cache_1h(_do_send_weather_message)\n)\n\nnotify_with_24h_cache = retry(stop=stop_after_attempt(3))(\n    aio_lru_cache_24h(_do_send_weather_message)\n)\n\n\nasync def cron_send_weather(\n    chat: models.Chat, locations: List[Location], ding_bot: models.DingBots\n):\n    \"\"\"定时发送天气预报\"\"\"\n    for location in locations:\n        text = await he_weather.get_weather_forecast(location)\n        await notify_with_1h_cache(chat, ding_bot, text)\n    return True\n\n\nasync def cron_send_warning(chat: models.Chat, ding_bot: models.DingBots):\n    \"\"\"定时发送天气预警信息\"\"\"\n    if warnModel := await he_weather.get_weather_warning(chat.location):\n        # 预警信息可能持续超过 1h，故新增幂等操作\n        # 如果 24h 内有新增预警信息，不影响发送\n        await notify_with_24h_cache(chat, ding_bot, str(warnModel))\n    return True\n"}
{"type": "source_file", "path": "telegram_bot/database/database.py", "content": "from contextlib import contextmanager\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nfrom telegram_bot.settings import settings\n\nSQLALCHEMY_DATABASE_URL = settings.DATABASE_URL\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL,\n    pool_pre_ping=True,\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nBase = declarative_base()\n\n\n# Dependency\ndef get_db() -> SessionLocal:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\n@contextmanager\ndef get_db_session():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "telegram_bot/intergration/dingding/dingbot.py", "content": "from typing import Dict\n\nfrom telegram_bot.intergration.exceptions import DingBotException\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\n\nWEBHOOK_TEMPLATE = \"https://oapi.dingtalk.com/robot/send?access_token={}\"\nERRCODE_KEY = \"errcode\"\n\n\nclass DingBotClient:\n    def __init__(self, http_client: HttpClient):\n        self.http_client = http_client\n\n    async def _do_execute(self, webhook: str, param: Dict):\n        d = await self.http_client.post(webhook, param)\n        if d.get(ERRCODE_KEY) != 0:\n            # https://developers.dingtalk.com/document/app/server-api-error-codes-1\n            raise DingBotException(f\"dingding hook failed: {d}\")\n\n    async def send_text(self, token, msg):\n        webhook = WEBHOOK_TEMPLATE.format(token)\n        param = {\"msgtype\": \"text\", \"text\": {\"content\": msg}}\n        await self._do_execute(webhook, param)\n"}
{"type": "source_file", "path": "telegram_bot/dependencies.py", "content": "from aiogram import Dispatcher, Bot\n\nfrom telegram_bot.telegram.dispatcher import dp\n\n\ndef bot_dispatcher() -> Dispatcher:\n    \"\"\"\n    Set context manually for properly processing webhook updates.\n    \"\"\"\n    Bot.set_current(dp.bot)\n    Dispatcher.set_current(dp)\n    return dp\n\n\ndef telegram_bot() -> Bot:\n    return dp.bot\n"}
{"type": "source_file", "path": "telegram_bot/cron/cron.py", "content": "from datetime import datetime, timedelta\n\nimport pytz\nfrom fastapi import APIRouter, Depends\nfrom loguru import logger\nfrom sqlalchemy.orm import Session\n\nfrom telegram_bot.cron import scheduler\nfrom telegram_bot.cron.tasks import cron_send_weather, cron_send_warning\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db\nfrom telegram_bot.utils.date_util import DateUtil\n\nQPM_LIMIT = 100 * 1.5\nONE_MINUTE = 60 * 1000\nAPI_COUNT = 5\n# 限流: https://dev.qweather.com/docs/start/glossary#qpm\nMIL_SECONDS_INTERVAL = ONE_MINUTE / (QPM_LIMIT * API_COUNT)\n# 天气预警触发\nVALID_WARNING_CHECK_HOURS = (0, 6, 9, 12, 15, 18, 21)\n\nrouter = APIRouter()\n\n\n@router.get(\"/cron\")\nasync def cron_handler(db: Session = Depends(get_db)):\n    \"\"\"外部请求触发的定时任务，每个小时执行一次\"\"\"\n    count = 0\n    for i, chat in enumerate(crud.get_active_users(db)):\n        run_date = datetime.now(pytz.utc) + timedelta(\n            milliseconds=i * MIL_SECONDS_INTERVAL\n        )\n\n        # 用户定时订阅判断逻辑\n        cur_hour = str(DateUtil.get_cur_hour(str(chat.time_zone)))\n        if cur_hour not in chat.sub_hours:\n            continue\n\n        job = scheduler.add_job(\n            cron_send_weather,\n            args=(chat, chat.all_locations, chat.ding_bot),\n            trigger=\"date\",\n            run_date=run_date,\n            misfire_grace_time=None,\n        )\n        count += 1\n        logger.info(f\"[cron][add_job][send_weather]{job}\")\n\n    return {\"total\": count}\n\n\n@router.get(\"/cron_1h\")\nasync def one_hour_cron_handler(db: Session = Depends(get_db)):\n    \"\"\"每个小时执行一次，自然灾害预警信息获取\"\"\"\n    now = datetime.now(pytz.timezone(\"Asia/Shanghai\"))\n    if now.hour not in VALID_WARNING_CHECK_HOURS:\n        return {\"total\": 0}\n\n    count = 0\n    for i, chat in enumerate(crud.get_active_users(db)):\n        # 仅针对主动开启订阅的用户检查投递预警信息\n        if not chat.cron_jobs:\n            continue\n\n        run_date = now + timedelta(milliseconds=i * MIL_SECONDS_INTERVAL)\n        job = scheduler.add_job(\n            cron_send_warning,\n            args=(chat, chat.ding_bot),\n            trigger=\"date\",\n            run_date=run_date,\n            misfire_grace_time=None,\n        )\n        count += 1\n        logger.info(f\"[cron][add_job][send_warning]{job}\")\n\n    return {\"total\": count}\n"}
{"type": "source_file", "path": "telegram_bot/intergration/http/base_http_client.py", "content": "from abc import ABC, abstractmethod\nfrom typing import Dict\n\n\nclass HttpClient(ABC):\n    @abstractmethod\n    async def get(self, url: str, params: Dict = None) -> Dict:\n        pass\n\n    @abstractmethod\n    async def post(self, url: str, params: Dict = None) -> Dict:\n        pass\n"}
{"type": "source_file", "path": "telegram_bot/intergration/exceptions.py", "content": "class DingBotException(Exception):\n    pass\n"}
{"type": "source_file", "path": "telegram_bot/intergration/http/request_http_client.py", "content": "from typing import Dict, List\n\nfrom loguru import logger\nfrom requests_futures.sessions import FuturesSession\n\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\n\n\nclass RequestHttpClient(HttpClient):\n    async def post(self, url: str, params: Dict = None) -> Dict:\n        pass\n\n    def __init__(self):\n        self.session = FuturesSession()\n\n    async def get(self, url, params=None) -> Dict:\n        logger.info(f\"[http][get][request]{url}\")\n        r = self.session.get(url).result()\n        logger.info(f\"[http][get][response]{url},{r.status_code},{r.json()}\")\n        if r.status_code == 200:\n            return r.json()\n\n    def get_responses(self, urls: List[str]):\n        \"\"\"\n        利用线程池调用外部获取资源\n        \"\"\"\n        for url in urls:\n            logger.info(f\"[http][get][request],{url}\")\n        futures = [self.session.get(url) for url in urls]\n\n        responses = []\n        for f in futures:\n            r = f.result()\n            logger.info(f\"[http][get][response],{r.status_code},{r.json()}\")\n            if r.status_code == 200:\n                responses.append(r.json())\n\n        return responses\n"}
{"type": "source_file", "path": "telegram_bot/database/schemas.py", "content": "from pydantic import BaseModel\n\n\nclass UserBase(BaseModel):\n    lat: str\n    lon: str\n    city: str\n    city_name: str\n    tz: str\n\n\nclass UserCreate(UserBase):\n    chat_id: str\n\n\nclass User(UserBase):\n    id: int\n    is_active: bool\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "telegram_bot/controllers/webhook.py", "content": "from typing import Any, Dict\nfrom urllib.parse import urljoin\n\nfrom aiogram import Dispatcher, Bot\nfrom aiogram.types import Update\nfrom fastapi import APIRouter, Body, Depends\nfrom loguru import logger\nfrom starlette.responses import Response\nfrom starlette.status import HTTP_200_OK\n\nfrom telegram_bot.dependencies import bot_dispatcher, telegram_bot\nfrom telegram_bot.settings import settings\n\nrouter = APIRouter()\n\n\n@router.post(\"/hook\")\nasync def webhook_handler(\n    update_raw: Dict[str, Any] = Body(...),\n    dp: Dispatcher = Depends(bot_dispatcher),\n) -> Response:\n    \"\"\"Set route /hook with POST method will trigger this method.\"\"\"\n    telegram_update = Update(**update_raw)\n    Dispatcher.set_current(dp)\n    Bot.set_current(dp.bot)\n    await dp.process_update(telegram_update)\n    return Response(status_code=HTTP_200_OK)\n\n\nif not settings.is_production:\n\n    @router.on_event(\"startup\")\n    async def set_webhook() -> None:\n        \"\"\"\n        Tell Telegram API about new webhook on app startup.\n\n        We need to check current webhook url first, because Telegram API has\n        strong rate limit for `set_webhook` method.\n        \"\"\"\n        bot = telegram_bot()\n\n        webhook_endpoint = router.url_path_for(\"webhook_handler\")\n        url = urljoin(settings.TELEGRAM_BOT_WEBHOOK_ENDPOINT, webhook_endpoint)\n\n        current_url = (await bot.get_webhook_info())[\"url\"]\n\n        if current_url != url:\n            await bot.set_webhook(url=url)\n            logger.warning(\"webhook updated!\")\n\n\n@router.on_event(\"shutdown\")\nasync def disconnect_storage() -> None:\n    \"\"\"\n    Close connection to storage.\n\n    We don't use storage at this moment, but in future...\n    \"\"\"\n    dispatcher = bot_dispatcher()\n    await dispatcher.storage.close()\n    await dispatcher.storage.wait_closed()\n"}
{"type": "source_file", "path": "telegram_bot/intergration/location/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/intergration/weather/const.py", "content": "WEATHER_2D_MESSAGE_TEMPLATE = \"\"\"\\\n📍{location}   \n\n今天{d1}，白天{d1_pretty}\n明天{d2}，白天{d2_pretty}\n\n{extra}\n\"\"\"\n\nWEATHER_6H_MESSAGE_TEMPLATE = \"\"\"\\\n📍{location}   \n\n{hours}\n\"\"\"\n"}
{"type": "source_file", "path": "telegram_bot/__init__.py", "content": "# -*- coding: utf-8 -*-\n\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/base_weather_client.py", "content": "from abc import ABC, abstractmethod\n\n\nclass WeatherClient(ABC):\n    @abstractmethod\n    def get_weather_forecast(self, location) -> str:\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_weather_photo(self, location) -> str:\n        raise NotImplementedError\n\n    def __str__(self) -> str:\n        return self.__class__.__name__\n\n    __repr__ = __str__\n"}
{"type": "source_file", "path": "telegram_bot/intergration/location/he_location_client.py", "content": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom httpx import HTTPError\nfrom retry import retry\n\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\nfrom telegram_bot.settings import settings\n\nKEY = settings.HE_WEATHER_API_TOKEN\n\n\n@dataclass\nclass Location:\n    name: str\n    lat: float\n    lon: float\n    tz: str\n    province: Optional[str] = \"\"\n    country: Optional[str] = \"\"\n    url: Optional[str] = \"\"\n\n    def get_location(self):\n        return f\"{self.lon},{self.lat}\" if self.lat and self.lon else self.name\n\n    def __eq__(self, o: \"Location\") -> bool:\n        return self.lat == o.lat and self.lon == o.lon and self.name == o.name\n\n    def __hash__(self) -> int:\n        return hash((self.lat, self.lon, self.name))\n\n    def __str__(self):\n        return f\"{self.lon},{self.lat},{self.name}\"\n\n    __repr__ = __str__\n\n\nclass HeLocationClient:\n    def __init__(self, http_client: HttpClient):\n        self.http_client = http_client\n\n    URL = f\"https://geoapi.qweather.com/v2/city/lookup?location={{}}&key={KEY}\"\n\n    @retry((HTTPError,), tries=3, delay=1, backoff=2)\n    async def _fetch(self, location_id: str) -> Optional[Location]:\n        url = self.URL.format(location_id)\n        d = await self.http_client.get(url)\n\n        location_list = d.get(\"location\")\n        if not location_list:\n            return\n\n        d_location = location_list[0]\n        return Location(\n            name=d_location[\"name\"],\n            lat=float(d_location[\"lat\"]),\n            lon=float(d_location[\"lon\"]),\n            tz=d_location[\"tz\"],\n            province=d_location[\"adm1\"],\n            country=d_location[\"country\"],\n            url=d_location[\"fxLink\"],\n        )\n\n    async def get_location_by_city_keywords(self, keywords) -> Optional[Location]:\n        if not keywords:\n            return\n        return await self._fetch(keywords)\n\n    async def get_location_by_lat_lon(self, lat, lon) -> Optional[Location]:\n        if not (lat or lon):\n            return\n        return await self._fetch(f\"{lon},{lat}\")\n"}
{"type": "source_file", "path": "telegram_bot/app.py", "content": "# -*- coding: utf-8 -*-\nimport sys\n\nfrom fastapi import FastAPI\nfrom loguru import logger\nimport sentry_sdk\nfrom sentry_sdk.integrations.asgi import SentryAsgiMiddleware\nimport uvicorn\n\nfrom telegram_bot.controllers import meta, release, webhook\nfrom telegram_bot.cron import cron, scheduler\nfrom telegram_bot.database import models\nfrom telegram_bot.database.database import engine\nfrom telegram_bot.settings import settings\n\n# 日志格式设置\nlogger.remove()\nFORMAT = \"<level>{level: <6}</level> <green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> <level>{message}</level>\"\nlogger.add(sys.stdout, colorize=True, format=FORMAT, diagnose=False)\n\napp = FastAPI()\napp.include_router(meta.router)\napp.include_router(webhook.router)\napp.include_router(cron.router)\napp.include_router(release.router)\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    # 定时任务\n    scheduler.start()\n    logger.info(\"starting cron service..\", scheduler)\n\n    # 数据库更新\n    logger.info(\"updating database schema..\")\n    models.Base.metadata.create_all(bind=engine)\n\n\n# sentry middleware\nif settings.SENTRY_URL:\n    logger.info(\"start sentry...\")\n    sentry_sdk.init(\n        dsn=settings.SENTRY_URL,\n        # Set traces_sample_rate to 1.0 to capture 100%\n        # of transactions for performance monitoring.\n        traces_sample_rate=1.0,\n        # Set profiles_sample_rate to 1.0 to profile 100%\n        # of sampled transactions.\n        # We recommend adjusting this value in production.\n        profiles_sample_rate=1.0,\n    )\n    app = SentryAsgiMiddleware(app)\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"app:app\", host=\"127.0.0.1\", port=5000, log_level=\"info\", reload=True)\n"}
{"type": "source_file", "path": "telegram_bot/intergration/http/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/intergration/weather/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/database/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/intergration/weather/wttr_weather_client.py", "content": "import requests\n\nfrom telegram_bot.intergration.weather.base_weather_client import WeatherClient\n\n\nclass AsciiWeatherClient(WeatherClient):\n    def get_weather_photo(self, location) -> str:\n        return f\"wttr.in/31.23,121.47.png?2nFqQ\"\n\n    def get_weather_forecast(self, location) -> str:\n        return requests.get(f\"http://wttr.in/shanghai\").text\n"}
{"type": "source_file", "path": "telegram_bot/telegram/add_location.py", "content": "from typing import Optional\nfrom aiogram import types\nfrom aiogram.dispatcher import FSMContext\nfrom aiogram.dispatcher.filters import Text\nfrom aiogram.dispatcher.filters.state import StatesGroup, State\nfrom aiogram.types import ContentType\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db_session\nfrom telegram_bot.intergration import he_location_client, he_weather\nfrom telegram_bot.intergration.location.he_location_client import Location\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.telegram.dispatcher import dp\n\n\nasync def _get_location_from_message(message: types.Message) -> Optional[\"Location\"]:\n    # 1. 用户定位位置\n    if message.location:\n        return await he_location_client.get_location_by_lat_lon(\n            message.location.latitude, message.location.longitude\n        )\n\n    # 2. 关键字定位\n    return await he_location_client.get_location_by_city_keywords(message.text.strip())\n\n\nclass Form(StatesGroup):\n    add_location = State()\n\n\n@dp.message_handler(commands=\"add_sub_locations\")\nasync def add_location(message: types.Message):\n    # 检查用户是否已经设置城市主位置\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        if not crud.get_user(db, chat_id):\n            await TelegramMessageService.send_text(\n                dp.bot, chat_id, \"请先设置主城市位置。  /set_location\"\n            )\n            return\n\n    # 开始添加城市子位置\n    await Form.add_location.set()\n    await TelegramMessageService.send_text(\n        dp.bot, chat_id, \"请回复新增城市关键字，或者模糊定位。  /cancel\"\n    )\n\n\n@dp.message_handler(state=\"*\", commands=\"cancel\")\n@dp.message_handler(Text(equals=\"cancel\", ignore_case=True), state=\"*\")\nasync def cancel_handler(message: types.Message, state: FSMContext):\n    \"\"\"\n    Allow user to cancel any action\n    \"\"\"\n    current_state = await state.get_state()\n    if current_state is None:\n        return\n\n    await state.finish()\n    await message.reply(\"已取消\")\n\n\n@dp.message_handler(state=Form.add_location, content_types=ContentType.LOCATION)\n@dp.message_handler(state=Form.add_location, content_types=ContentType.VENUE)\n@dp.message_handler(state=Form.add_location, content_types=ContentType.TEXT)\nasync def process_location(message: types.Message, state: FSMContext):\n    location = await _get_location_from_message(message)\n    if not location:\n        return await message.reply(\"找不到输入的城市，试试其他关键字 /cancel\")\n\n    # 更新用户所属位置\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        user = crud.add_location(db, chat_id, location)\n    await message.reply(\n        f\"城市信息已新增：{location.province}{user.city_name}\"\n        f\"({user.latitude},{user.longitude})\\n{location.url}\"\n    )\n\n    # 更新位置后，发送天气预报\n    text = await he_weather.get_weather_forecast(user.location)\n    text = f\"\\n{text}\"\n    await TelegramMessageService.send_text(dp.bot, chat_id, text)\n\n    # Finish conversation\n    await state.finish()\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/models/he_weather_model.py", "content": "from dataclasses import dataclass\nfrom typing import Dict, List\n\n\n@dataclass\nclass HeWeatherModel:\n    w_day: str\n    w_night: str\n\n    temp_min: str\n    temp_max: str\n    temp_now: str\n\n    air_aqi: str\n    air_text: str\n\n    life_text: str\n    warning_text: str\n\n    @classmethod\n    def build(cls, weather_daily: Dict, weather_now: Dict = None, air_now: Dict = None, indices: List = None,\n              warning: List = None):\n        weather_now = weather_now or {}\n        air_now = air_now or {}\n        indices_d1 = indices[0] if indices else {}\n        warning_first = warning[0] if warning else {}\n        return cls(\n            weather_daily.get(\"textDay\", \"\"),\n            weather_daily.get(\"textNight\", \"\"),\n            weather_daily.get(\"tempMin\", \"\"),\n            weather_daily.get(\"tempMax\", \"\"),\n            weather_now.get(\"temp\", \"\"),\n            air_now.get(\"aqi\", \"\"),\n            air_now.get(\"category\", \"\"),\n            indices_d1.get(\"text\", \"\"),\n            warning_first.get(\"text\", \"\"),\n        )\n\n    @staticmethod\n    def with_emoji(day_text):\n        emoji_map = {\"晴\": \"☀️\", \"晴间多云\": \"🌤\", \"雷阵雨\": \"⛈\"}\n        if emoji := emoji_map.get(day_text):\n            return emoji\n\n        if \"雪\" in day_text:\n            return \"❄️\"\n        if \"雨\" in day_text:\n            return \"🌧\"\n        if \"云\" in day_text or \"阴\" in day_text:\n            return \"☁️\"\n\n        return \"\"\n\n    @property\n    def w_day_with_emoji(self):\n        return f\"{self.with_emoji(self.w_day)}{self.w_day}\"\n\n    @property\n    def w_night_with_emoji(self):\n        return self.w_night + self.with_emoji(self.w_night)\n\n    def __str__(self) -> str:\n        d_str = f\"{self.w_day_with_emoji}\"\n\n        if self.temp_min and self.temp_max:\n            d_str += f\"({self.temp_min}°~{self.temp_max}°)\"\n\n        if self.w_night != self.w_day:\n            d_str += f\"，夜间{self.w_night}\"\n        if self.air_aqi and self.air_text:\n            d_str += f\"，空气{self.air_text}({self.air_aqi})\"\n\n        return d_str\n"}
{"type": "source_file", "path": "telegram_bot/telegram/__init__.py", "content": "\"\"\" manually import to be reachable \"\"\"\nfrom telegram_bot.telegram import (\n    callbacks,\n    update_location,\n    add_location,\n    update_dingbot,\n    exception,\n)\n\n__all__ = [\n    \"bot\",\n    \"dispatcher\",\n]\n"}
{"type": "source_file", "path": "telegram_bot/settings.py", "content": "from dataclasses import dataclass\nfrom functools import partial\nfrom typing import Optional\nfrom urllib.parse import urlparse\n\nfrom aiocache import Cache, cached\nfrom aiogram.contrib.fsm_storage.memory import MemoryStorage\nfrom pydantic import BaseSettings, SecretStr\n\n\nclass Settings(BaseSettings):\n    TELEGRAM_BOT_API_KEY: SecretStr\n    TELEGRAM_BOT_WEBHOOK_ENDPOINT: str\n    HE_WEATHER_API_TOKEN: str\n    DATABASE_URL: str\n    REDIS_URL: Optional[str] = \"\"\n    SENTRY_URL: Optional[str] = \"\"\n    ENV: str = \"production\"\n    CACHE_TTL: int = 60 * 59\n    DEFAULT_TIMEZONE: str = \"Asia/Shanghai\"\n    PROXY: Optional[str] = \"\"\n    DO_RELEASE: bool = False\n    DOMAIN: Optional[str] = \"localhost\"\n\n    @property\n    def is_production(self):\n        return self.ENV == \"production\"\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n\n@dataclass\nclass RedisConfig:\n    host: str\n    port: int\n    user: Optional[str]\n    password: Optional[str]\n\n    def __init__(self, url) -> None:\n        parsed_redis_url = urlparse(url)\n        if parsed_redis_url.hostname is None or parsed_redis_url.port is None:\n            raise ValueError(f\"invalid redis url: {url}\")\n        self.user, self.password, self.host, self.port = (\n            parsed_redis_url.username,\n            parsed_redis_url.password,\n            parsed_redis_url.hostname,\n            int(parsed_redis_url.port),\n        )\n\n\nsettings = Settings()\nredis_config = RedisConfig(settings.REDIS_URL)\n# dispatcher_storage = RedisStorage(\n#     host=redis_config.host, port=redis_config.port, password=redis_config.password\n# )\ndispatcher_storage = MemoryStorage()\n\naio_lru_cache_partial = partial(\n    cached,\n    cache=Cache.REDIS,\n    endpoint=redis_config.host,\n    port=redis_config.port,\n    password=redis_config.password,\n)\naio_lru_cache_1h = aio_lru_cache_partial(ttl=settings.CACHE_TTL)\naio_lru_cache_24h = aio_lru_cache_partial(ttl=settings.CACHE_TTL * 24)\n"}
{"type": "source_file", "path": "telegram_bot/telegram/keyboard/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/service/dingtalk.py", "content": "import functools\n\nimport sentry_sdk\nfrom loguru import logger\n\nfrom telegram_bot.intergration import ding_bot_client\nfrom telegram_bot.intergration.exceptions import DingBotException\n\n\ndef service_template(f):\n    @functools.wraps(f)\n    async def inner(token: str, msg: str):\n        try:\n            await f(token, msg)\n        except DingBotException as e:\n            logger.error(e)\n            sentry_sdk.capture_exception(e, \"钉钉发送异常\")\n        except Exception as e:\n            logger.error(e)\n            sentry_sdk.capture_exception(e)\n        else:\n            logger.info(f\"message send to {token}, msg: {msg}\")\n\n    return inner\n\n\nclass DingBotMessageService:\n    \"\"\"钉钉自定义机器人发送消息，包含异常处理\"\"\"\n\n    @staticmethod\n    @service_template\n    async def send_text(token: str, msg: str):\n        if not token or not msg:\n            raise ValueError(f\"参数非法,token:{token},msg:{msg}\")\n        await ding_bot_client.send_text(token, msg)\n"}
{"type": "source_file", "path": "telegram_bot/service/telegram.py", "content": "import functools\nfrom typing import Union\n\nimport sentry_sdk\nfrom aiogram import Bot\nfrom aiogram.utils.exceptions import (\n    BadRequest,\n    BotBlocked,\n    UserDeactivated,\n    ChatNotFound,\n    BotKicked,\n    MigrateToChat,\n    CantTalkWithBots,\n    Unauthorized,\n)\nfrom loguru import logger\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db_session\n\n\ndef service_template(f):\n    @functools.wraps(f)\n    async def inner(bot: Bot, chat_id: str, *args, **kwargs):\n        try:\n            await f(bot, chat_id, *args, **kwargs)\n        except (\n            BotBlocked,\n            UserDeactivated,\n            ChatNotFound,\n            BotKicked,\n            CantTalkWithBots,\n        ) as e:\n            logger.warning(f\"bot blocked by {chat_id},{str(e)}\")\n            with get_db_session() as db:\n                crud.update_user_status(db, chat_id, False)\n        except Unauthorized as e:\n            if e.text and \"the group chat was deleted\" in e.text:\n                logger.warning(f\"{bot} of group was deleted\")\n        except BadRequest as e:\n            if e.text == \"Not enough rights to send text messages to the chat\":\n                logger.warning(f\"bot not enough rights to send text messages to the chat\")\n                with get_db_session() as db:\n                    crud.update_user_status(db, chat_id, False)\n        except MigrateToChat as e:\n            with get_db_session() as db:\n                crud.update_user_status(db, chat_id, False)\n                crud.migrate_user_by_chat_id(db, chat_id, str(e.migrate_to_chat_id))\n        except Exception as e:\n            logger.error(e)\n            sentry_sdk.capture_exception(e)\n        else:\n            logger.info(f\"message send to {chat_id},args={args},kwargs={kwargs}\")\n\n    return inner\n\n\nclass TelegramMessageService:\n    @staticmethod\n    @service_template\n    async def send_text(bot: Bot, chat_id: Union[int, str], text: str):\n        await bot.send_message(chat_id=chat_id, text=text)\n\n    @staticmethod\n    @service_template\n    async def send_markdown(bot: Bot, chat_id: str, text: str):\n        await bot.send_message(chat_id=chat_id, text=text, parse_mode=\"MarkdownV2\")\n\n    @staticmethod\n    @service_template\n    async def send_keyboard_markup(\n        bot: Bot, chat_id: str, text: str, reply_markup=None, parse_mode=\"MarkdownV2\"\n    ):\n        await bot.send_message(\n            chat_id=chat_id, text=text, parse_mode=parse_mode, reply_markup=reply_markup\n        )\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/models/warn_model.py", "content": "from dataclasses import dataclass\n\nTEMPLATE = \"\"\"\\\n{prefix} {typeName}{level}预警\n\n{text}\n\"\"\"\n\n\n@dataclass\nclass WarnModel:\n    text: str\n    typeName: str\n    level: str\n    prefix: str = \"⚠️\"\n\n    def __str__(self) -> str:\n        return TEMPLATE.format(\n            prefix=self.prefix,\n            level=self.level,\n            typeName=self.typeName,\n            text=self.text\n        )\n"}
{"type": "source_file", "path": "telegram_bot/telegram/exception.py", "content": "from aiogram import types\nfrom aiogram.utils.exceptions import BotBlocked, MessageNotModified\nfrom loguru import logger\nfrom sentry_sdk import capture_exception\n\nfrom telegram_bot.telegram.dispatcher import dp\n\n\n@dp.errors_handler(exception=BotBlocked, )\nasync def global_error_handler(update: types.Update, e):\n    logger.warning(e)\n    return True\n\n\n@dp.errors_handler(exception=MessageNotModified)\nasync def global_error_handler(update: types.Update, e):\n    logger.warning(e)\n    return True\n\n\n@dp.errors_handler(exception=Exception)\nasync def global_error_handler(update: types.Update, e: Exception):\n    capture_exception(e)\n    logger.exception(e)\n    return True\n"}
{"type": "source_file", "path": "telegram_bot/service/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/telegram/bot.py", "content": "from aiogram import Bot\n\nfrom telegram_bot.settings import settings\n\nbot = Bot(\n    token=settings.TELEGRAM_BOT_API_KEY.get_secret_value(),\n    proxy=settings.PROXY\n)\n# bot.timeout = 3\n"}
{"type": "source_file", "path": "telegram_bot/telegram/callbacks.py", "content": "from aiogram import types\n\nfrom telegram_bot.database import crud, models\nfrom telegram_bot.database.database import get_db_session\nfrom telegram_bot.intergration import he_weather\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.settings import aio_lru_cache_24h\nfrom telegram_bot.telegram.dispatcher import dp\nfrom telegram_bot.telegram.keyboard.keyboard_markup_factory import (\n    HOURS_TEMPLATE,\n    REMOVE_LOCATION_PREFIX,\n    KeyboardMarkUpFactory,\n    WELCOME_TEXT,\n    GET_WEATHER,\n    UPDATE_LOCATION,\n    ENABLE_SUB,\n    DISABLE_SUB,\n    UPDATE_SUB_CRON,\n    BACK,\n    hour_decode,\n)\nfrom telegram_bot.telegram.update_location import update_location\n\n\ndef registered(func):\n    async def wrapper(message: types.Message):\n        chat_id = str(message.chat.id)\n        with get_db_session() as db:\n            if not crud.is_user_exists(db, chat_id):\n                return await update_location(message)\n\n        await func(message)\n\n    return wrapper\n\n\n@dp.message_handler(commands=[\"weather\"])\n@registered\nasync def handle_weather(message: types.Message) -> None:\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        locations = crud.get_user_locations(db, chat_id)\n\n    for location in locations:\n        text = await he_weather.get_weather_forecast(location)\n        await TelegramMessageService.send_text(dp.bot, chat_id, text)\n\n\nasync def do_send_warning_message(chat: models.Chat, text: str):\n    await TelegramMessageService.send_text(dp.bot, chat.chat_id, text)\n    # 注意：必须返回值，以确保缓存生效\n    return True\n\n\nnotify_with_24h_cache = aio_lru_cache_24h(do_send_warning_message)\n\n\n@dp.message_handler(commands=[\"warning\"])\n@registered\nasync def handle_weather(message: types.Message) -> None:\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        user = crud.get_user(db, chat_id)\n        locations = crud.get_user_locations(db, chat_id)\n\n    for location in locations:\n        if text := await he_weather.get_weather_warning(location):\n            await notify_with_24h_cache(user, text)\n\n\n@dp.message_handler(commands=[\"weather_6h\"])\n@registered\nasync def handle_weather(message: types.Message) -> None:\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        locations = crud.get_user_locations(db, chat_id)\n\n    for location in locations:\n        text = await he_weather.get_weather_6h_forecast_text(location)\n        await TelegramMessageService.send_text(dp.bot, chat_id, text)\n\n\n@dp.message_handler(commands=[\"id\"])\n@registered\nasync def handle_chat_id(message: types.Message) -> None:\n    chat_id = message.chat.id\n    await TelegramMessageService.send_text(dp.bot, chat_id, chat_id)\n\n\n@dp.message_handler(commands=[\"help\", \"start\"])\nasync def handle_help(message: types.Message) -> None:\n    with get_db_session() as db:\n        user = crud.get_user(db, message.chat.id)\n    reply_markup = KeyboardMarkUpFactory.build_main_menu(user)\n    await TelegramMessageService.send_keyboard_markup(\n        dp.bot, message.chat.id, WELCOME_TEXT, reply_markup\n    )\n\n\n@dp.message_handler(commands=[\"subscribe\"])\n@registered\nasync def handle_sub(message: types.Message) -> None:\n    with get_db_session() as db:\n        crud.update_user_status(db, message.chat.id, True)\n        await TelegramMessageService.send_text(dp.bot, message.chat.id, \"已开启定时订阅\")\n\n        user = crud.get_user(db, message.chat.id)\n        reply_markup = KeyboardMarkUpFactory.build_cron_options(user)\n        await TelegramMessageService.send_keyboard_markup(\n            dp.bot, message.chat.id, WELCOME_TEXT, reply_markup\n        )\n\n\n@dp.message_handler(commands=[\"unsubscribe\"])\n@registered\nasync def handle_unsub(message: types.Message) -> None:\n    with get_db_session() as db:\n        crud.update_user_status(db, message.chat.id, False)\n    await TelegramMessageService.send_text(dp.bot, message.chat.id, \"已关闭定时订阅\")\n\n\n@dp.callback_query_handler(text=GET_WEATHER)\nasync def weather_callback_handler(query: types.CallbackQuery):\n    await handle_weather(query.message)\n    await query.answer(\"\")\n\n\n@dp.callback_query_handler(text=UPDATE_LOCATION)\nasync def location_callback_handler(query: types.CallbackQuery):\n    await update_location(query.message)\n    await query.answer(\"\")\n\n\n@dp.callback_query_handler(text=ENABLE_SUB)\n@dp.callback_query_handler(text=DISABLE_SUB)\nasync def update_subscription_callback_handler(query: types.CallbackQuery):\n    is_enable = query.data == ENABLE_SUB\n    with get_db_session() as db:\n        crud.update_user_status(db, query.message.chat.id, is_enable)\n        text = \"已开启订阅\" if is_enable else \"已关闭订阅\"\n        user = crud.get_user(db, query.message.chat.id)\n        await query.answer(text)\n        await query.message.edit_reply_markup(\n            KeyboardMarkUpFactory.build_cron_options(user)\n        )\n\n\n@dp.callback_query_handler(text=UPDATE_SUB_CRON)\nasync def sub_cron_callback_handler(query: types.CallbackQuery):\n    with get_db_session() as db:\n        user = crud.get_user(db, query.message.chat.id)\n        await query.message.edit_reply_markup(\n            KeyboardMarkUpFactory.build_cron_options(user)\n        )\n        await query.answer(\"\")\n\n\n@dp.callback_query_handler(text=BACK)\nasync def exit_callback_handler(query: types.CallbackQuery):\n    with get_db_session() as db:\n        user = crud.get_user(db, query.message.chat.id)\n        await query.message.edit_reply_markup(\n            KeyboardMarkUpFactory.build_main_menu(user)\n        )\n        await query.answer(\"\")\n\n\n@dp.callback_query_handler(lambda callback_query: callback_query.data in HOURS_TEMPLATE)\nasync def sub_cron_update_callback_handler(query: types.CallbackQuery):\n    hour = hour_decode(query.data)\n    chat_id = query.message.chat.id\n\n    with get_db_session() as db:\n        # 激活用户\n        crud.update_user_status(db, query.message.chat.id, True)\n        user = crud.get_user(db, query.message.chat.id)\n\n        # 新增/删除订阅\n        cron_job, created = crud.create_or_delete_cron_job(db, chat_id, hour)\n        if created:\n            await query.answer(\"订阅成功\")\n        else:\n            await query.answer(\"已取消\")\n\n        db.refresh(user)\n        cron_sub_menu = KeyboardMarkUpFactory.build_cron_options(user)\n        await query.message.edit_reply_markup(cron_sub_menu)\n\n\n@dp.message_handler(commands=[\"delete_sub_locations\"])\nasync def remove_ding_token(message: types.Message) -> None:\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        locations = crud.filter_locations(db, chat_id)\n    if not locations:\n        await message.reply(\"不存在其他子位置\")\n        return\n\n    mark_up = KeyboardMarkUpFactory.build_sub_locations(locations)\n    await TelegramMessageService.send_keyboard_markup(\n        dp.bot, chat_id, \"单击城市删除👇\", mark_up\n    )\n\n\n@dp.callback_query_handler(\n    lambda callback_query: REMOVE_LOCATION_PREFIX in callback_query.data\n)\nasync def delete_sub_location_update_callback_handler(query: types.CallbackQuery):\n    location_id = query.data.replace(REMOVE_LOCATION_PREFIX, \"\")\n    chat_id = str(query.message.chat.id)\n\n    with get_db_session() as db:\n        deleted = crud.remove_sub_location(db, location_id)\n        if not deleted:\n            return\n\n        await query.answer(\"删除成功\")\n\n        locations = crud.filter_locations(db, chat_id)\n        cron_sub_menu = KeyboardMarkUpFactory.build_sub_locations(locations)\n        await query.message.edit_reply_markup(cron_sub_menu)\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/models/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/telegram/keyboard/keyboard_markup_factory.py", "content": "import itertools\nfrom typing import List, Optional, Union\n\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\nfrom telegram_bot.database import crud, models\nfrom telegram_bot.database.database import get_db, get_db_session\n\nWELCOME_TEXT = \"\"\"\\\n基于「和风」的天气预报机器人；根据定位查询精准实时天气，并每天自动播报。\n\n如有任何问题，请联系 @daya233    \n\"\"\"\n\nENABLE_SUB, DISABLE_SUB = \"enable_sub\", \"disable_sub\"\nGET_WEATHER, UPDATE_LOCATION = \"weather\", \"edit\"\nUPDATE_SUB_CRON = \"update_cron\"\nBACK = \"back\"\n\nREMOVE_LOCATION_PREFIX = \"remove_location_\"\n\n# fmt: off\ndef hour_encode(hour: Union[int, str]) -> str: return f\"cron_{hour}\"\ndef hour_decode(hour: str) -> str: return hour.replace(\"cron_\", \"\")\n# fmt: on\nHOURS = tuple(str(x) for x in range(0, 24, 2))\nHOURS_TEMPLATE = tuple(hour_encode(x) for x in range(0, 24, 2))\n\n\nclass KeyboardMarkUpFactory:\n    @staticmethod\n    def build_main_menu(chat: \"models.Chat\") -> InlineKeyboardMarkup:\n        keyboard_markup = InlineKeyboardMarkup(row_width=6)\n\n        # 第一行：天气获取\n        weather_button = InlineKeyboardButton(\"获取实时天气\", callback_data=GET_WEATHER)\n        keyboard_markup.add(weather_button)\n\n        # 第二行：自定义配置\n        inline_buttons = [InlineKeyboardButton(\"更新位置\", callback_data=UPDATE_LOCATION)]\n        if chat and chat.is_location_exist:\n            sub_cron_button = InlineKeyboardButton(\n                \"定时订阅\", callback_data=UPDATE_SUB_CRON\n            )\n            inline_buttons.append(sub_cron_button)\n\n        star_button = InlineKeyboardButton(\n            \"关注项目✨\", url=\"https://github.com/daya0576/he_weather_bot\"\n        )\n        inline_buttons.append(star_button)\n        keyboard_markup.row(*inline_buttons)\n\n        return keyboard_markup\n\n    @staticmethod\n    def build_cron_options(chat: \"models.Chat\") -> Optional[InlineKeyboardMarkup]:\n        if not chat:\n            return\n\n        keyboard_markup = InlineKeyboardMarkup(row_width=6)\n\n        chunk_size = 6\n        for x in range(0, len(HOURS), chunk_size):\n            inline_btn_list = []\n            for hour in HOURS[x : x + chunk_size]:\n                hour_formatted = f\"{hour}✓\" if hour in chat.sub_hours else hour\n                btn = InlineKeyboardButton(\n                    hour_formatted, callback_data=hour_encode(hour)\n                )\n                inline_btn_list.append(btn)\n            keyboard_markup.row(*inline_btn_list)\n\n        back_btn = InlineKeyboardButton(\"返回\", callback_data=BACK)\n        keyboard_markup.add(back_btn)\n        return keyboard_markup\n\n    @staticmethod\n    def build_sub_locations(\n        locations: List[\"models.Locations\"],\n    ) -> Optional[InlineKeyboardMarkup]:\n        keyboard_markup = InlineKeyboardMarkup(row_width=6)\n\n        chunk_size = 4\n        for i in range(0, len(locations), chunk_size):\n            inline_position_list = []\n            for location in locations[i : i + chunk_size]:\n                btn = InlineKeyboardButton(\n                    str(location.city_name),\n                    callback_data=f\"{REMOVE_LOCATION_PREFIX}{location.id}\",\n                )\n                inline_position_list.append(btn)\n            keyboard_markup.row(*inline_position_list)\n\n        return keyboard_markup\n"}
{"type": "source_file", "path": "telegram_bot/telegram/dispatcher.py", "content": "from aiogram import Dispatcher\nfrom aiogram.contrib.middlewares.logging import LoggingMiddleware\n\nfrom telegram_bot.settings import dispatcher_storage\nfrom telegram_bot.telegram.bot import bot\n\n\"\"\"\nhelp - 帮助\nweather - 获取实时天气（最近两天）\nweather_6h - 获取实时天气（最近六小时）\nset_location - 更新位置\nsubscribe - 开启订阅\nunsubscribe - 关闭订阅\nset_ding_bot - 新增钉钉机器人同步\ndelete_ding_bot - 移除钉钉同步\nadd_sub_locations - 新增子位置（支持多个城市）\ndelete_sub_locations - 移除子位置\n\"\"\"\ndp = Dispatcher(bot, storage=dispatcher_storage)\ndp.middleware.setup(LoggingMiddleware())\n"}
{"type": "source_file", "path": "telegram_bot/utils/date_util.py", "content": "# -*- coding: utf-8 -*-\nfrom datetime import datetime, timedelta\n\nimport pytz\n\n\nclass DateUtil:\n    @staticmethod\n    def get_day_of_week(time_zone, day=0):\n        \"\"\"获取未来 N 天的周 X\"\"\"\n        d = {0: \"周一\", 1: \"周二\", 2: \"周三\", 3: \"周四\", 4: \"周五\", 5: \"周六\", 6: \"周日\"}\n\n        tz = pytz.timezone(time_zone)\n        cur_time = datetime.now(tz) + timedelta(days=day)\n        return d[cur_time.weekday()]\n\n    @staticmethod\n    def get_cur_hour(time_zone: str = 'UTC') -> int:\n        \"\"\"根据时区获取当前的小时\"\"\"\n        tz = pytz.timezone(time_zone)\n        return datetime.now(tz).hour\n\n    @staticmethod\n    def get_now_for_human() -> str:\n        tz = pytz.timezone(\"Asia/Shanghai\")\n        return datetime.now(tz).strftime(\"YYYY-MM-DDTHH:MM:SS\")\n"}
{"type": "source_file", "path": "telegram_bot/telegram/update_location.py", "content": "from typing import Optional\nfrom aiogram import types\nfrom aiogram.dispatcher import FSMContext\nfrom aiogram.dispatcher.filters import Text\nfrom aiogram.dispatcher.filters.state import StatesGroup, State\nfrom aiogram.types import ContentType\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db_session\nfrom telegram_bot.intergration import he_location_client, he_weather\nfrom telegram_bot.intergration.location.he_location_client import Location\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.telegram.dispatcher import dp\n\n\nasync def _get_location_from_message(message: types.Message) -> Optional[\"Location\"]:\n    # 1. 用户定位位置\n    if message.location:\n        return await he_location_client.get_location_by_lat_lon(\n            message.location.latitude, message.location.longitude\n        )\n\n    # 2. 关键字定位\n    return await he_location_client.get_location_by_city_keywords(message.text.strip())\n\n\nclass Form(StatesGroup):\n    location = State()\n\n\n@dp.message_handler(commands=\"set_location\")\nasync def update_location(message: types.Message):\n    await Form.location.set()\n    await TelegramMessageService.send_text(\n        dp.bot, message.chat.id, \"请回复当前城市关键字，或者模糊定位。  /cancel\"\n    )\n\n\n@dp.message_handler(state=\"*\", commands=\"cancel\")\n@dp.message_handler(Text(equals=\"cancel\", ignore_case=True), state=\"*\")\nasync def cancel_handler(message: types.Message, state: FSMContext):\n    \"\"\"\n    Allow user to cancel any action\n    \"\"\"\n    current_state = await state.get_state()\n    if current_state is None:\n        return\n\n    await state.finish()\n    await message.reply(\"已取消\")\n\n\n@dp.message_handler(state=Form.location, content_types=ContentType.LOCATION)\n@dp.message_handler(state=Form.location, content_types=ContentType.VENUE)\n@dp.message_handler(state=Form.location, content_types=ContentType.TEXT)\nasync def process_location(message: types.Message, state: FSMContext):\n    location = await _get_location_from_message(message)\n    if not location:\n        return await message.reply(\"找不到输入的城市，试试其他关键字 /cancel\")\n\n    # 更新用户所属位置\n    with get_db_session() as db:\n        user = crud.update_or_create_user_by_location(db, message.chat.id, location)\n    await message.reply(\n        f\"城市信息已更新：{location.province}{user.city_name}\"\n        f\"({user.latitude},{user.longitude})\\n{location.url}\"\n    )\n\n    # 更新位置后，发送天气预报\n    text = await he_weather.get_weather_forecast(user.location)\n    text = f\"\\n{text}\"\n    await TelegramMessageService.send_text(dp.bot, message.chat.id, text)\n\n    # Finish conversation\n    await state.finish()\n"}
{"type": "source_file", "path": "telegram_bot/telegram/update_dingbot.py", "content": "import re\n\nfrom aiogram import types\nfrom aiogram.dispatcher import FSMContext\nfrom aiogram.dispatcher.filters import Text\nfrom aiogram.dispatcher.filters.state import StatesGroup, State\nfrom aiogram.types import ContentType\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db_session\nfrom telegram_bot.intergration import he_weather\nfrom telegram_bot.service.dingtalk import DingBotMessageService\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.telegram.callbacks import registered\nfrom telegram_bot.telegram.dispatcher import dp\n\nRE_PATTERN = re.compile(\n    r\"https://oapi\\.dingtalk\\.com/robot/send\\?access_token=([a-zA-Z0-9]+)\"\n)\n\n\nasync def extra_ding_token_from_message(text) -> str:\n    if not text:\n        return \"\"\n    if m := RE_PATTERN.match(text.strip()):\n        return m.group(1)\n\n\nclass Form(StatesGroup):\n    set_ding_token = State()\n    set_location_alias = State()\n\n\n@dp.message_handler(state=\"*\", commands=\"cancel\")\n@dp.message_handler(Text(equals=\"cancel\", ignore_case=True), state=\"*\")\nasync def cancel_handler(message: types.Message, state: FSMContext):\n    \"\"\"\n    Allow user to cancel any action\n    \"\"\"\n    current_state = await state.get_state()\n    if current_state is None:\n        return\n\n    await state.finish()\n    await message.reply(\"已取消\")\n\n\n@dp.message_handler(commands=\"set_ding_bot\")\n@registered\nasync def update_ding_token(message: types.Message):\n    await Form.set_location_alias.set()\n    await TelegramMessageService.send_text(dp.bot, message.chat.id, \"Hi！请回复定位别名，例如上海外滩\")\n\n\n@dp.message_handler(commands=\"delete_ding_bot\")\n@registered\nasync def remove_ding_token(message: types.Message):\n    with get_db_session() as db:\n        is_delete_bot = crud.remove_ding_bot(db, message.chat.id)\n\n    if is_delete_bot:\n        return await message.reply(\"已取消关联\")\n    else:\n        return await message.reply(\"不存在关联\")\n\n\n@dp.message_handler(state=Form.set_ding_token, content_types=ContentType.TEXT)\n@dp.message_handler(state=Form.set_ding_token, content_types=ContentType.ANY)\nasync def process_ding_token(message: types.Message, state: FSMContext):\n    ding_bot_token = await extra_ding_token_from_message(message.text)\n    if not ding_bot_token:\n        return await message.reply(\n            \"机器人的Webhook地址非法!\"\n            \"\\n参考格式：https://oapi.dingtalk.com/robot/send?access_token=XXXXXX\"\n            \"\\n取消输入：/cancel\"\n        )\n\n    with get_db_session() as db:\n        crud.update_or_create_ding_bot(db, message.chat.id, ding_bot_token)\n\n    # 发送测试消息\n    with get_db_session() as db:\n        chat = crud.get_user(db, chat_id=message.chat.id)\n    text = await he_weather.get_weather_forecast(chat.location)\n    await DingBotMessageService.send_text(ding_bot_token, text)\n    await message.reply(\"钉钉Token关联成功，请注意查收测试消息~\")\n    await state.finish()\n\n\n@dp.message_handler(state=Form.set_location_alias, content_types=ContentType.TEXT)\n@dp.message_handler(state=Form.set_location_alias, content_types=ContentType.ANY)\nasync def process_ding_token_alias(message: types.Message, state: FSMContext):\n    location_name = message.text.strip()\n    if not location_name or len(location_name) > 10:\n        return await message.reply(\"别名长度过长！\")\n\n    with get_db_session() as db:\n        crud.update_location_name(db, message.chat.id, location_name)\n\n    await TelegramMessageService.send_text(\n        dp.bot, message.chat.id, \"请输入自定义机器人Webhook地址\"\n    )\n    await Form.set_ding_token.set()\n"}
{"type": "source_file", "path": "telegram_bot/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/utils/exceptions.py", "content": "class TooManyTriesException(BaseException):\n    pass\n"}

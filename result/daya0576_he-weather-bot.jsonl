{"repo_info": {"repo_name": "he-weather-bot", "repo_owner": "daya0576", "repo_url": "https://github.com/daya0576/he-weather-bot"}}
{"type": "test_file", "path": "telegram_bot/tests/__init__.py", "content": "# -*- coding: utf-8 -*-\n"}
{"type": "test_file", "path": "telegram_bot/tests/test_weather_warning.py", "content": "import asyncio\nimport time\n\nimport pytest\nfrom dotenv import load_dotenv\n\nload_dotenv(\".env_test\")\nfrom telegram_bot.database.models import Chat, DingBots\nfrom telegram_bot.cron import tasks\nfrom telegram_bot.intergration.weather.models.warn_model import WarnModel\n\nfake_warn_model = WarnModel(\"text\", \"type\", \"level\")\nsame_fake_warn_model = WarnModel(\"text\", \"type\", \"level\")\ndiff_fake_warn_model = WarnModel(\"text_diff\", \"type\", \"level\")\nfake_chat = Chat()\nfake_chat.latitude = 123\nfake_chat.longitude = 123\nfake_ding_bot = DingBots()\n\n\n@pytest.fixture(scope=\"function\")\ndef mockit(mocker):\n    # mock weather api\n    warning_mock = mocker.patch(\n        'telegram_bot.intergration.weather.he_weather_client.HeWeatherClient.get_weather_warning')\n    warning_mock.return_value = WarnModel(\"text\", \"type\", \"level\")\n    # mock telegram api\n    message_mock = mocker.patch('telegram_bot.service.telegram.TelegramMessageService.send_text')\n    mocker.patch('telegram_bot.service.dingtalk.DingBotMessageService.send_text')\n    return warning_mock, message_mock\n\n\ndef test_diff_warnings(mockit):\n    warning_mock, message_mock = mockit\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    assert message_mock.call_count == 1\n\n    # same warnings\n    warning_mock.return_value = same_fake_warn_model\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    assert message_mock.call_count == 1\n\n    # different warnings\n    warning_mock.return_value = diff_fake_warn_model\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    assert message_mock.call_count == 2\n    asyncio.run(tasks.cron_send_warning(fake_chat, fake_ding_bot))\n    assert message_mock.call_count == 2\n\n    # waiting for cache expire\n    time.sleep(1)\n"}
{"type": "test_file", "path": "telegram_bot/tests/test_app.py", "content": "import pytest\nfrom dotenv import load_dotenv\nfrom fastapi.testclient import TestClient\n\n\n@pytest.fixture(scope='session', autouse=True)\ndef load_env():\n    load_dotenv(\".env_test\")\n\n\n@pytest.fixture\ndef client():\n    from telegram_bot import app\n    # app.app.config['TESTING'] = True\n    client = TestClient(app.app)\n    return client\n\n\ndef test_route(client):\n    response = client.get(\"/\")\n    assert response.status_code == 200\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/he_weather_client.py", "content": "import asyncio\nimport random\nfrom typing import Dict, List, Optional\n\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\nfrom telegram_bot.intergration.location.he_location_client import Location\nfrom telegram_bot.intergration.weather.base_weather_client import WeatherClient\nfrom telegram_bot.intergration.weather.const import (\n    WEATHER_6H_MESSAGE_TEMPLATE,\n    WEATHER_2D_MESSAGE_TEMPLATE,\n)\nfrom telegram_bot.intergration.weather.models.he_weather_model import HeWeatherModel\nfrom telegram_bot.intergration.weather.models.warn_model import WarnModel\nfrom telegram_bot.settings import aio_lru_cache_1h\nfrom telegram_bot.utils.date_util import DateUtil\nfrom telegram_bot.utils.retry_util import tries\n\n\nclass HeWeatherClient(WeatherClient):\n    \"\"\"ÂíåÈ£éÂ§©Ê∞îÂÆ¢Êà∑Á´Ø\"\"\"\n\n    # ÂíåÈ£éÁîüÊ¥ªÊåáÊï∞ÈÄâÈ°πÔºåÈöèÊú∫ÈÄâÊã©\n    LIFE_OPTIONS = tuple(range(1, 17))\n\n    def __init__(self, http_client: HttpClient, key: str):\n        self.http_client = http_client\n        self.key = key\n\n    #################################### ÂØπÂ§ñÊé•Âè£ ####################################\n    @aio_lru_cache_1h\n    async def get_weather_forecast(self, location: Location) -> str:\n        weather_3d_data, forecast_air, life_1d = await asyncio.gather(\n            self._get_weather_3d(location),\n            self._get_air_now(location),\n            self._get_indices_1d(location, random.choice(self.LIFE_OPTIONS)),\n        )\n        d1_forecast_dict, d2_forecast_dict = weather_3d_data[:2]\n\n        # ÊûÑÂª∫Â§©Ê∞îÈ¢ÑÊä•Êï∞ÊçÆÊ®°Âûã\n        d1_forecast = HeWeatherModel.build(\n            d1_forecast_dict, air_now=forecast_air, indices=life_1d\n        )\n        d2_forecast = HeWeatherModel.build(d2_forecast_dict)\n\n        # ÁªÑË£ÖÊúÄÁªàÂ§©Ê∞îÊñáÊ°à\n        extra = \"\"\n        if d1_forecast.warning_text:\n            extra = f\"‚ö†Ô∏è{d1_forecast.warning_text}\"\n        elif d1_forecast.life_text:\n            extra = d1_forecast.life_text\n\n        return WEATHER_2D_MESSAGE_TEMPLATE.format(\n            location=location.name,\n            d1=DateUtil.get_day_of_week(location.tz, 0),\n            d2=DateUtil.get_day_of_week(location.tz, 1),\n            d1_pretty=str(d1_forecast),\n            d2_pretty=str(d2_forecast),\n            extra=extra,\n        )\n\n    async def get_weather_warning(self, location: Location) -> Optional[WarnModel]:\n        \"\"\"Ëé∑ÂèñËá™ÁÑ∂ÁÅæÂÆ≥‰ø°ÊÅØ\"\"\"\n        warning_list = await self._get_warning_now(location)\n        if not warning_list:\n            return\n\n        w = warning_list[0]\n        return WarnModel(w[\"text\"], w[\"typeName\"], w[\"level\"])\n\n    async def get_weather_6h_forecast_text(self, location: Location) -> str:\n        d = await self._get_weather_hour(location)\n        hour = DateUtil.get_cur_hour(location.tz)\n        hours_text = \"\\n\".join(\n            f\"{(hour + i) % 24:02d}:00Ôºö{d[i]['text']} {d[i]['temp']}‚ÑÉ\" for i in range(6)\n        )\n\n        return WEATHER_6H_MESSAGE_TEMPLATE.format(\n            location=location.name, hours=hours_text\n        )\n\n    #################################### ÂéüÂßãÊé•Âè£ ####################################\n    @tries(times=5)\n    async def _do_get(self, api_type, weather_type, params: Dict) -> Dict:\n        url = f\"https://devapi.qweather.com/v7/{api_type}/{weather_type}\"\n        params.update(key=self.key)\n        return await self.http_client.get(url, params)\n\n    async def _get_weather_3d(self, location: Location) -> List:\n        \"\"\"ÂüéÂ∏ÇÂ§©Ê∞îAPI / ÈÄêÂ§©Â§©Ê∞îÈ¢ÑÊä•\"\"\"\n        result = await self._do_get(\n            \"weather\", \"3d\", {\"location\": location.get_location()}\n        )\n        return result.get(\"daily\", [])\n\n    async def _get_weather_hour(self, location: Location) -> List:\n        \"\"\"ÂüéÂ∏ÇÂ§©Ê∞îAPI / ÈÄêÂ∞èÊó∂Â§©Ê∞îÈ¢ÑÊä•\"\"\"\n        result = await self._do_get(\n            \"weather\", \"24h\", {\"location\": location.get_location()}\n        )\n        return result.get(\"hourly\", [])\n\n    async def _get_indices_1d(self, location: Location, indices_type) -> List:\n        \"\"\"Â§©Ê∞îÊåáÊï∞API / Â§©Ê∞îÁîüÊ¥ªÊåáÊï∞\"\"\"\n        params = {\"location\": location.get_location(), \"type\": indices_type}\n        result = await self._do_get(\"indices\", \"1d\", params)\n        return result.get(\"daily\", [])\n\n    async def _get_air_now(self, location: Location) -> Dict:\n        \"\"\"Á©∫Ê∞îAPI / ÂÆûÊó∂Á©∫Ê∞îË¥®Èáè\"\"\"\n        result = await self._do_get(\"air\", \"now\", {\"location\": location.get_location()})\n        return result.get(\"now\", {})\n\n    async def _get_warning_now(self, location: Location) -> List[Dict]:\n        \"\"\"Â§©Ê∞îÁÅæÂÆ≥È¢ÑË≠¶\"\"\"\n        result = await self._do_get(\n            \"warning\", \"now\", {\"location\": location.get_location()}\n        )\n        return result.get(\"warning\", [])\n\n    def get_weather_photo(self, location) -> str:\n        pass\n"}
{"type": "source_file", "path": "telegram_bot/controllers/meta.py", "content": "from fastapi import Depends, APIRouter\nfrom loguru import logger\nfrom sqlalchemy.orm import Session\nfrom starlette.responses import RedirectResponse\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db, get_db_session\nfrom telegram_bot.settings import aio_lru_cache_1h, settings\n\nrouter = APIRouter()\n\n\n@aio_lru_cache_1h\nasync def get_user_count(db):\n    return crud.get_user_count(db)\n\n\n@router.get(\"/users/count\")\nasync def active_users_count(db: Session = Depends(get_db)):\n    \"\"\"Ê¥ªË∑ÉÁî®Êà∑ÊÄªÊï∞\"\"\"\n    badge_url = f\"https://img.shields.io/badge/users-{await get_user_count(db)}-blue\"\n    return RedirectResponse(badge_url)\n\n\n@router.get(\"/\")\nasync def index():\n    return \"hello\"\n\n\n@router.get(\"/config\")\nasync def config():\n    logger.info(settings)\n    return \"OK\"\n\n\n@router.get(\"/sentry\")\nasync def test_sentry():\n    return 1 / 0\n\n\n@router.get(\"/users\")\nasync def users():\n    with get_db_session() as db:\n        return crud.get_users(db)\n\n\n@router.get(\"/user_count\")\nasync def user_count():\n    with get_db_session() as db:\n        return await get_user_count(db)\n"}
{"type": "source_file", "path": "telegram_bot/controllers/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/controllers/release.py", "content": "import asyncio\n\nfrom fastapi import Depends, APIRouter\nfrom loguru import logger\nfrom sentry_sdk import capture_exception\nfrom sqlalchemy.orm import Session\n\nfrom telegram_bot.database import crud, models\nfrom telegram_bot.database.database import get_db\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.settings import aio_lru_cache_partial, settings\nfrom telegram_bot.telegram.dispatcher import dp\nfrom telegram_bot.telegram.keyboard.keyboard_markup_factory import KeyboardMarkUpFactory\n\nrouter = APIRouter()\nONE_YEAR = 60 * 60 * 24 * 365\n\nV0_1_0 = \"\"\"\nv0.1.1 Á®≥ÂÆöÊ≠£ÂºèÁâàÂ∑≤ÂèëÂ∏É„ÄÇÂ¶ÇÊúâ‰ªª‰ΩïÈóÆÈ¢òÔºåËØ∑ËÅîÁ≥ª @daya233\n\n**‚ú® FEATURES**\n1. ÊîØÊåÅËá™ÂÆö‰πâÈÄöÁü•Êó∂Èó¥ÔºàÊâÄÂú®Âú∞Êó∂Âå∫Ôºâ\n2. ÊîØÊåÅÂºÄÂêØ/ÂÖ≥Èó≠ËÆ¢ÈòÖ\n3. ÂëäË≠¶Ê†∑Âºè‰ºòÂåñÔºàÊñ∞Â¢û emojiÔºâ\n4. ÊîØÊåÅÁæ§ËÆ¢ÈòÖ\n\n**üåù BUG FiX**\n1. ‰øÆÂ§çÈáçÂ§çÊäïÈÄíÁöÑÈóÆÈ¢ò\n2. ‰øÆÂ§çÊ∂àÊÅØ‰∏¢Â§±ÁöÑÈóÆÈ¢òÔºà‰ΩøÂëΩÂøÖËææÔºâ\n\"\"\"\n\n\n@aio_lru_cache_partial(ttl=ONE_YEAR)\nasync def do_release(chat: models.Chat):\n    \"\"\"ÂèëÈÄÅÁâàÊú¨Êõ¥Êñ∞\"\"\"\n    markup = KeyboardMarkUpFactory.build_main_menu(chat)\n    await TelegramMessageService.send_keyboard_markup(dp.bot, chat.chat_id, V0_1_0, markup, parse_mode=\"Markdown\")\n\n    return True\n\n\n@router.get(\"/release_v1\")\nasync def cron_handler(db: Session = Depends(get_db)):\n    if not settings.DO_RELEASE:\n        return {\"message\": \"disable\"}\n\n    all_active_users = crud.get_active_users(db)\n\n    # Âπ∂Ë°åÂ§ÑÁêÜÔºåÂçï‰∏™ exception ‰∏ç‰∏≠Êñ≠ÂÖ∂‰ªñ‰ªªÂä°\n    results = await asyncio.gather(\n        *[do_release(user) for user in all_active_users],\n        return_exceptions=True\n    )\n    # Ê±áÊÄªÂºÇÂ∏∏Â§ÑÁêÜ\n    success = 0\n    for result in results:\n        if not isinstance(result, Exception):\n            success += 1\n            continue\n        logger.exception(result)\n        capture_exception(result)\n\n    logger.info(f\"released! {success}/{len(results)})\")\n    return {\"message\": f\"{success}/{len(results)}\"}\n"}
{"type": "source_file", "path": "telegram_bot/intergration/dingding/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/cron/__init__.py", "content": "from apscheduler.events import EVENT_ALL, JobExecutionEvent\nfrom apscheduler.jobstores.redis import RedisJobStore\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom loguru import logger\nfrom pytz import utc\nfrom sentry_sdk import capture_exception\n\nfrom telegram_bot.settings import redis_config\n\njobstores = {\n    \"default\": RedisJobStore(\n        host=redis_config.host, port=redis_config.port, password=redis_config.password\n    )\n}\njob_defaults = {}\nexecutors = {\n    \"default\": {\"type\": \"threadpool\", \"max_workers\": 10},\n}\n\n\ndef my_listener(event: JobExecutionEvent):\n    if isinstance(event, JobExecutionEvent):\n        logger.info(f\"my_listener: {event.scheduled_run_time}\")\n        if event.exception:\n            capture_exception(error=event.exception)\n            logger.exception(str(event.exception), \"The job crashed :(\")\n    else:\n        logger.info(f\"my_listener: {event}\")\n\n\nscheduler = AsyncIOScheduler(timezone=utc)\nscheduler.add_listener(my_listener, EVENT_ALL)\n"}
{"type": "source_file", "path": "telegram_bot/database/models.py", "content": "from datetime import datetime\nfrom typing import Iterable, Tuple\n\nfrom sqlalchemy import (\n    Boolean,\n    Column,\n    String,\n    BigInteger,\n    Integer,\n    DateTime,\n    UniqueConstraint,\n    ForeignKey,\n)\nfrom sqlalchemy.orm import relationship\n\nfrom .database import Base\nfrom ..intergration.location.he_location_client import Location\n\n\nclass Chat(Base):\n    __tablename__ = \"users\"\n\n    chat_id = Column(BigInteger, primary_key=True, index=True)\n    is_active = Column(Boolean, default=True)\n\n    latitude = Column(String)\n    longitude = Column(String)\n    city = Column(String, nullable=False)\n    city_name = Column(String, nullable=False)\n    time_zone = Column(String, nullable=False)\n\n    # Â§ñÈîÆÔºöhttps://docs.sqlalchemy.org/en/14/orm/basic_relationships.html\n    cron_jobs = relationship(\"CronJobs\", backref=\"parent\")\n    ding_bot = relationship(\"DingBots\", back_populates=\"chat\", uselist=False)\n    locations = relationship(\"Locations\", backref=\"parent\")\n\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    @property\n    def location(self):\n        return Location(\n            name=self.city_name,\n            lat=float(self.latitude),\n            lon=float(self.longitude),\n            tz=self.time_zone,\n        )\n\n    def is_location_exist(self):\n        return self.latitude and self.longitude\n\n    @property\n    def sub_hours(self) -> Tuple:\n        return tuple(job.hour for job in self.cron_jobs)\n\n    @property\n    def all_locations(self) -> Iterable[Location]:\n        return [self.location, *(x.location for x in self.locations)]\n\n    def __str__(self) -> str:\n        return f\"chat_{self.chat_id}_{self.city_name}({self.location})\"\n\n    def __repr__(self) -> str:\n        return f\"chat_{self.chat_id}\"\n\n\nclass CronJobs(Base):\n    __tablename__ = \"cron_jobs\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    chat_id = Column(BigInteger, ForeignKey(\"users.chat_id\"))\n    hour = Column(String, nullable=False)\n\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    __table_args__ = (UniqueConstraint(\"chat_id\", \"hour\"),)\n\n\nclass DingBots(Base):\n    __tablename__ = \"ding_bots\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    token = Column(String, index=True)\n\n    chat_id = Column(BigInteger, ForeignKey(\"users.chat_id\"))\n    chat = relationship(\"Chat\", back_populates=\"ding_bot\")\n\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    def __str__(self) -> str:\n        return f\"ding_bot_{self.token}\"\n\n    __repr__ = __str__\n\n\nclass Locations(Base):\n    __tablename__ = \"locations\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    chat_id = Column(BigInteger, ForeignKey(\"users.chat_id\"))\n\n    latitude = Column(String)\n    longitude = Column(String)\n    city = Column(String, nullable=False)\n    city_name = Column(String, nullable=False)\n    time_zone = Column(String, nullable=False)\n\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    @property\n    def location(self):\n        return Location(\n            name=self.city_name,\n            lat=float(self.latitude),\n            lon=float(self.longitude),\n            tz=self.time_zone,\n        )\n\n    def __str__(self) -> str:\n        return f\"location_{self.chat_id}_{self.city_name}({self.location})\"\n\n    def __repr__(self) -> str:\n        return f\"location_{self.chat_id}\"\n"}
{"type": "source_file", "path": "telegram_bot/intergration/__init__.py", "content": "from telegram_bot.intergration.dingding.dingbot import DingBotClient\nfrom telegram_bot.intergration.http.httpx_client import HttpxClient\nfrom telegram_bot.intergration.http.request_http_client import RequestHttpClient\nfrom telegram_bot.intergration.location.he_location_client import HeLocationClient\nfrom telegram_bot.intergration.weather.he_weather_client import HeWeatherClient\nfrom telegram_bot.intergration.weather.wttr_weather_client import AsciiWeatherClient\n\n# HTTP ÂÆ¢Êà∑Á´Ø\nfrom telegram_bot.settings import settings\n\nrequest_cli = RequestHttpClient()\nhttpx_cli = HttpxClient()\n\n# ÂíåÈ£éÂ§©Ê∞îÈ¢ÑÊä•ÂÆ¢Êà∑Á´Ø\nhe_weather = HeWeatherClient(httpx_cli, settings.HE_WEATHER_API_TOKEN)\nascii_weather = AsciiWeatherClient()\nhe_location_client = HeLocationClient(httpx_cli)\n\n# ÈíâÈíâÂÆ¢Êà∑Á´Ø\nding_bot_client = DingBotClient(httpx_cli)\n\n__all__ = [\n    \"he_weather\",\n    \"ascii_weather\",\n    \"he_location_client\",\n    \"ding_bot_client\"\n]\n"}
{"type": "source_file", "path": "telegram_bot/intergration/http/httpx_client.py", "content": "from typing import Dict, Optional\n\nimport httpx\nfrom loguru import logger\nfrom tenacity import retry, stop_after_attempt\n\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\n\n\nclass HttpxClient(HttpClient):\n    def __init__(self):\n        transport = httpx.AsyncHTTPTransport(retries=3)\n        timeout = httpx.Timeout(15.0, connect=60.0)\n        self.client = httpx.AsyncClient(transport=transport, timeout=timeout)\n\n    @retry(stop=stop_after_attempt(3))\n    async def get(self, url: str, params: Optional[Dict] = None) -> Dict:\n        logger.info(f\"[http][get][request]{url}\")\n        r = await self.client.get(url, params=params)\n        logger.info(f\"[http][get][response]{url},{r.status_code},{r.json()}\")\n\n        r.raise_for_status()\n        return r.json()\n\n    @retry(stop=stop_after_attempt(3))\n    async def post(self, url: str, params: Optional[Dict] = None) -> Dict:\n        logger.info(f\"[http][post][request]{url}\")\n        headers = {\"Content-Type\": \"application/json\"}\n        r = await self.client.post(url, json=params, headers=headers)\n        logger.info(f\"[http][post][response]{url},{r.status_code},{r.json()}\")\n\n        r.raise_for_status()\n        return r.json()\n"}
{"type": "source_file", "path": "telegram_bot/database/crud.py", "content": "from typing import Iterable, List\n\nfrom sqlalchemy.orm import Session, make_transient\nfrom sqlalchemy import func\n\nfrom telegram_bot.database import models\nfrom telegram_bot.intergration.location.he_location_client import Location\n\n\ndef is_user_exists(db: Session, chat_id: str) -> bool:\n    return (\n        db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first() is not None\n    )\n\n\ndef get_user(db: Session, chat_id: str) -> models.Chat:\n    return db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n\n\ndef get_users(db: Session, skip: int = 0, limit: int = 100000) -> List[models.Chat]:\n    return db.query(models.Chat).offset(skip).limit(limit).all()\n\n\ndef get_user_locations(db: Session, chat_id: str) -> Iterable[Location]:\n    chat = db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n    if not chat:\n        return []\n    yield chat.location\n\n    locations = filter_locations(db, chat_id)\n    yield from [x.location for x in locations]\n\n\ndef get_active_users(\n    db: Session, skip: int = 0, limit: int = 100000\n) -> List[models.Chat]:\n    return (\n        db.query(models.Chat)\n        .filter(models.Chat.is_active.is_(True))\n        .offset(skip)\n        .limit(limit)\n        .all()\n    )\n\n\ndef get_user_count(db: Session) -> int:\n    return db.query(func.count(models.Chat.chat_id)).scalar()\n\n\ndef update_user_status(db: Session, chat_id: str, is_active: bool):\n    user = db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n    if user:\n        user.is_active = is_active\n        db.merge(user)\n    db.commit()\n\n\ndef update_location_name(db: Session, chat_id: str, location_name: str) -> None:\n    chat = db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n    if chat:\n        chat.city_name = location_name\n        chat.city = location_name\n        db.merge(chat)\n    db.commit()\n\n\ndef migrate_user_by_chat_id(db: Session, chat_id: str, new_chat_id: str):\n    user: models.Chat = (\n        db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first()\n    )\n    if not user:\n        raise Exception(f\"chat_id does not exist: {chat_id}!!\")\n\n    db.expunge(user)\n    make_transient(user)\n    user.chat_id = new_chat_id\n    db.add(user)\n\n    # Â§çÂà∂ËÆ¢ÈòÖÁöÑÂÆöÊó∂‰ªªÂä°\n    cron_job_list = (\n        db.query(models.CronJobs).filter(models.CronJobs.chat_id == chat_id).all()\n    )\n    for cron_job in cron_job_list:\n        db.expunge(cron_job)\n        make_transient(cron_job)\n        cron_job.chat_id = new_chat_id\n        cron_job.id = None\n        db.add(cron_job)\n\n    db.commit()\n\n\ndef update_or_create_user_by_location(\n    db: Session, chat_id: str, location: Location\n) -> models.Chat:\n    chat = models.Chat(\n        chat_id=int(chat_id),\n        latitude=\"{:.2f}\".format(location.lat),\n        longitude=\"{:.2f}\".format(location.lon),\n        city=location.name,\n        city_name=location.name,\n        time_zone=location.tz,\n    )\n\n    if db.query(models.Chat).filter(models.Chat.chat_id == chat_id).first():\n        # update\n        chat = db.merge(chat)\n    else:\n        # create\n        chat.is_active = True\n        db.add(chat)\n\n    db.commit()\n    db.refresh(chat)\n    return chat\n\n\ndef add_location(db: Session, chat_id: str, location: Location) -> models.Chat:\n    sub_location = models.Locations(\n        chat_id=int(chat_id),\n        latitude=\"{:.2f}\".format(location.lat),\n        longitude=\"{:.2f}\".format(location.lon),\n        city=location.name,\n        city_name=location.name,\n        time_zone=location.tz,\n    )\n    db.add(sub_location)\n    db.commit()\n    db.refresh(sub_location)\n    return sub_location\n\n\ndef filter_locations(db: Session, chat_id: str) -> List[models.Locations]:\n    return db.query(models.Locations).filter(models.Locations.chat_id == chat_id).all()\n\n\ndef get_ding_bot(db: Session, chat_id: str) -> models.DingBots:\n    chat = get_user(db, chat_id)\n    return chat.ding_bot\n\n\ndef update_or_create_ding_bot(db: Session, chat_id: str, ding_token: str):\n    ding_bot = get_ding_bot(db, chat_id)\n    if ding_bot:\n        # update\n        ding_bot.token = ding_token\n        db.merge(ding_bot)\n    else:\n        # create\n        ding_bot = models.DingBots(token=ding_token, chat_id=chat_id)\n        db.add(ding_bot)\n\n    db.commit()\n\n\ndef remove_ding_bot(db: Session, chat_id: str):\n    dingbot = (\n        db.query(models.DingBots).filter(models.DingBots.chat_id == chat_id).first()\n    )\n\n    if dingbot:\n        db.delete(dingbot)\n        db.commit()\n        return True\n    return False\n\n\ndef remove_sub_location(db: Session, location_id: str) -> bool:\n    location = (\n        db.query(models.Locations).filter(models.Locations.id == location_id).first()\n    )\n    if location:\n        db.delete(location)\n        db.commit()\n        return True\n    return False\n\n\ndef get_cron_job(db, chat_id, hour):\n    return (\n        db.query(models.CronJobs)\n        .filter(models.CronJobs.chat_id == chat_id)\n        .filter(models.CronJobs.hour == hour)\n        .first()\n    )\n\n\ndef create_or_delete_cron_job(db: Session, chat_id: int, hour: str):\n    cron_job = (\n        db.query(models.CronJobs)\n        .filter(models.CronJobs.chat_id == chat_id)\n        .filter(models.CronJobs.hour == hour)\n        .first()\n    )\n\n    if cron_job:\n        db.delete(cron_job)\n        created = False\n    else:\n        cron_job_to_create = models.CronJobs(chat_id=chat_id, hour=hour)\n        db.add(cron_job_to_create)\n        created = True\n\n    db.commit()\n\n    return cron_job, created\n\n\ndef get_active_cron_jobs_by_hour(db: Session, hour: str):\n    return (\n        db.query(models.CronJobs)\n        .filter(models.CronJobs.hour == hour)\n        .filter(models.CronJobs.parent.is_active is True)\n        .all()\n    )\n"}
{"type": "source_file", "path": "telegram_bot/cron/tasks.py", "content": "from typing import List\nfrom telegram_bot.database import models\nfrom telegram_bot.intergration import he_weather\nfrom telegram_bot.intergration.location.he_location_client import Location\nfrom telegram_bot.service.dingtalk import DingBotMessageService\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.settings import aio_lru_cache_1h, aio_lru_cache_24h\nfrom telegram_bot.telegram.dispatcher import dp\nfrom tenacity import retry, stop_after_attempt\n\n\nasync def _do_send_weather_message(\n    chat: models.Chat, ding_bot: models.DingBots, text: str\n):\n    await TelegramMessageService.send_text(dp.bot, chat.chat_id, text)\n    if ding_bot:\n        await DingBotMessageService.send_text(ding_bot.token, text)\n    # Ê≥®ÊÑèÔºöÂøÖÈ°ªËøîÂõûÂÄºÔºå‰ª•Á°Æ‰øùÁºìÂ≠òÁîüÊïà\n    return True\n\n\nnotify_with_1h_cache = retry(stop=stop_after_attempt(3))(\n    aio_lru_cache_1h(_do_send_weather_message)\n)\n\nnotify_with_24h_cache = retry(stop=stop_after_attempt(3))(\n    aio_lru_cache_24h(_do_send_weather_message)\n)\n\n\nasync def cron_send_weather(\n    chat: models.Chat, locations: List[Location], ding_bot: models.DingBots\n):\n    \"\"\"ÂÆöÊó∂ÂèëÈÄÅÂ§©Ê∞îÈ¢ÑÊä•\"\"\"\n    for location in locations:\n        text = await he_weather.get_weather_forecast(location)\n        await notify_with_1h_cache(chat, ding_bot, text)\n    return True\n\n\nasync def cron_send_warning(chat: models.Chat, ding_bot: models.DingBots):\n    \"\"\"ÂÆöÊó∂ÂèëÈÄÅÂ§©Ê∞îÈ¢ÑË≠¶‰ø°ÊÅØ\"\"\"\n    if warnModel := await he_weather.get_weather_warning(chat.location):\n        # È¢ÑË≠¶‰ø°ÊÅØÂèØËÉΩÊåÅÁª≠Ë∂ÖËøá 1hÔºåÊïÖÊñ∞Â¢ûÂπÇÁ≠âÊìç‰Ωú\n        # Â¶ÇÊûú 24h ÂÜÖÊúâÊñ∞Â¢ûÈ¢ÑË≠¶‰ø°ÊÅØÔºå‰∏çÂΩ±ÂìçÂèëÈÄÅ\n        await notify_with_24h_cache(chat, ding_bot, str(warnModel))\n    return True\n"}
{"type": "source_file", "path": "telegram_bot/database/database.py", "content": "from contextlib import contextmanager\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nfrom telegram_bot.settings import settings\n\nSQLALCHEMY_DATABASE_URL = settings.DATABASE_URL\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL,\n    pool_pre_ping=True,\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nBase = declarative_base()\n\n\n# Dependency\ndef get_db() -> SessionLocal:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\n@contextmanager\ndef get_db_session():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "telegram_bot/intergration/dingding/dingbot.py", "content": "from typing import Dict\n\nfrom telegram_bot.intergration.exceptions import DingBotException\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\n\nWEBHOOK_TEMPLATE = \"https://oapi.dingtalk.com/robot/send?access_token={}\"\nERRCODE_KEY = \"errcode\"\n\n\nclass DingBotClient:\n    def __init__(self, http_client: HttpClient):\n        self.http_client = http_client\n\n    async def _do_execute(self, webhook: str, param: Dict):\n        d = await self.http_client.post(webhook, param)\n        if d.get(ERRCODE_KEY) != 0:\n            # https://developers.dingtalk.com/document/app/server-api-error-codes-1\n            raise DingBotException(f\"dingding hook failed: {d}\")\n\n    async def send_text(self, token, msg):\n        webhook = WEBHOOK_TEMPLATE.format(token)\n        param = {\"msgtype\": \"text\", \"text\": {\"content\": msg}}\n        await self._do_execute(webhook, param)\n"}
{"type": "source_file", "path": "telegram_bot/dependencies.py", "content": "from aiogram import Dispatcher, Bot\n\nfrom telegram_bot.telegram.dispatcher import dp\n\n\ndef bot_dispatcher() -> Dispatcher:\n    \"\"\"\n    Set context manually for properly processing webhook updates.\n    \"\"\"\n    Bot.set_current(dp.bot)\n    Dispatcher.set_current(dp)\n    return dp\n\n\ndef telegram_bot() -> Bot:\n    return dp.bot\n"}
{"type": "source_file", "path": "telegram_bot/cron/cron.py", "content": "from datetime import datetime, timedelta\n\nimport pytz\nfrom fastapi import APIRouter, Depends\nfrom loguru import logger\nfrom sqlalchemy.orm import Session\n\nfrom telegram_bot.cron import scheduler\nfrom telegram_bot.cron.tasks import cron_send_weather, cron_send_warning\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db\nfrom telegram_bot.utils.date_util import DateUtil\n\nQPM_LIMIT = 100 * 1.5\nONE_MINUTE = 60 * 1000\nAPI_COUNT = 5\n# ÈôêÊµÅ: https://dev.qweather.com/docs/start/glossary#qpm\nMIL_SECONDS_INTERVAL = ONE_MINUTE / (QPM_LIMIT * API_COUNT)\n# Â§©Ê∞îÈ¢ÑË≠¶Ëß¶Âèë\nVALID_WARNING_CHECK_HOURS = (0, 6, 9, 12, 15, 18, 21)\n\nrouter = APIRouter()\n\n\n@router.get(\"/cron\")\nasync def cron_handler(db: Session = Depends(get_db)):\n    \"\"\"Â§ñÈÉ®ËØ∑Ê±ÇËß¶ÂèëÁöÑÂÆöÊó∂‰ªªÂä°ÔºåÊØè‰∏™Â∞èÊó∂ÊâßË°å‰∏ÄÊ¨°\"\"\"\n    count = 0\n    for i, chat in enumerate(crud.get_active_users(db)):\n        run_date = datetime.now(pytz.utc) + timedelta(\n            milliseconds=i * MIL_SECONDS_INTERVAL\n        )\n\n        # Áî®Êà∑ÂÆöÊó∂ËÆ¢ÈòÖÂà§Êñ≠ÈÄªËæë\n        cur_hour = str(DateUtil.get_cur_hour(str(chat.time_zone)))\n        if cur_hour not in chat.sub_hours:\n            continue\n\n        job = scheduler.add_job(\n            cron_send_weather,\n            args=(chat, chat.all_locations, chat.ding_bot),\n            trigger=\"date\",\n            run_date=run_date,\n            misfire_grace_time=None,\n        )\n        count += 1\n        logger.info(f\"[cron][add_job][send_weather]{job}\")\n\n    return {\"total\": count}\n\n\n@router.get(\"/cron_1h\")\nasync def one_hour_cron_handler(db: Session = Depends(get_db)):\n    \"\"\"ÊØè‰∏™Â∞èÊó∂ÊâßË°å‰∏ÄÊ¨°ÔºåËá™ÁÑ∂ÁÅæÂÆ≥È¢ÑË≠¶‰ø°ÊÅØËé∑Âèñ\"\"\"\n    now = datetime.now(pytz.timezone(\"Asia/Shanghai\"))\n    if now.hour not in VALID_WARNING_CHECK_HOURS:\n        return {\"total\": 0}\n\n    count = 0\n    for i, chat in enumerate(crud.get_active_users(db)):\n        # ‰ªÖÈíàÂØπ‰∏ªÂä®ÂºÄÂêØËÆ¢ÈòÖÁöÑÁî®Êà∑Ê£ÄÊü•ÊäïÈÄíÈ¢ÑË≠¶‰ø°ÊÅØ\n        if not chat.cron_jobs:\n            continue\n\n        run_date = now + timedelta(milliseconds=i * MIL_SECONDS_INTERVAL)\n        job = scheduler.add_job(\n            cron_send_warning,\n            args=(chat, chat.ding_bot),\n            trigger=\"date\",\n            run_date=run_date,\n            misfire_grace_time=None,\n        )\n        count += 1\n        logger.info(f\"[cron][add_job][send_warning]{job}\")\n\n    return {\"total\": count}\n"}
{"type": "source_file", "path": "telegram_bot/intergration/http/base_http_client.py", "content": "from abc import ABC, abstractmethod\nfrom typing import Dict\n\n\nclass HttpClient(ABC):\n    @abstractmethod\n    async def get(self, url: str, params: Dict = None) -> Dict:\n        pass\n\n    @abstractmethod\n    async def post(self, url: str, params: Dict = None) -> Dict:\n        pass\n"}
{"type": "source_file", "path": "telegram_bot/intergration/exceptions.py", "content": "class DingBotException(Exception):\n    pass\n"}
{"type": "source_file", "path": "telegram_bot/intergration/http/request_http_client.py", "content": "from typing import Dict, List\n\nfrom loguru import logger\nfrom requests_futures.sessions import FuturesSession\n\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\n\n\nclass RequestHttpClient(HttpClient):\n    async def post(self, url: str, params: Dict = None) -> Dict:\n        pass\n\n    def __init__(self):\n        self.session = FuturesSession()\n\n    async def get(self, url, params=None) -> Dict:\n        logger.info(f\"[http][get][request]{url}\")\n        r = self.session.get(url).result()\n        logger.info(f\"[http][get][response]{url},{r.status_code},{r.json()}\")\n        if r.status_code == 200:\n            return r.json()\n\n    def get_responses(self, urls: List[str]):\n        \"\"\"\n        Âà©Áî®Á∫øÁ®ãÊ±†Ë∞ÉÁî®Â§ñÈÉ®Ëé∑ÂèñËµÑÊ∫ê\n        \"\"\"\n        for url in urls:\n            logger.info(f\"[http][get][request],{url}\")\n        futures = [self.session.get(url) for url in urls]\n\n        responses = []\n        for f in futures:\n            r = f.result()\n            logger.info(f\"[http][get][response],{r.status_code},{r.json()}\")\n            if r.status_code == 200:\n                responses.append(r.json())\n\n        return responses\n"}
{"type": "source_file", "path": "telegram_bot/database/schemas.py", "content": "from pydantic import BaseModel\n\n\nclass UserBase(BaseModel):\n    lat: str\n    lon: str\n    city: str\n    city_name: str\n    tz: str\n\n\nclass UserCreate(UserBase):\n    chat_id: str\n\n\nclass User(UserBase):\n    id: int\n    is_active: bool\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "telegram_bot/controllers/webhook.py", "content": "from typing import Any, Dict\nfrom urllib.parse import urljoin\n\nfrom aiogram import Dispatcher, Bot\nfrom aiogram.types import Update\nfrom fastapi import APIRouter, Body, Depends\nfrom loguru import logger\nfrom starlette.responses import Response\nfrom starlette.status import HTTP_200_OK\n\nfrom telegram_bot.dependencies import bot_dispatcher, telegram_bot\nfrom telegram_bot.settings import settings\n\nrouter = APIRouter()\n\n\n@router.post(\"/hook\")\nasync def webhook_handler(\n    update_raw: Dict[str, Any] = Body(...),\n    dp: Dispatcher = Depends(bot_dispatcher),\n) -> Response:\n    \"\"\"Set route /hook with POST method will trigger this method.\"\"\"\n    telegram_update = Update(**update_raw)\n    Dispatcher.set_current(dp)\n    Bot.set_current(dp.bot)\n    await dp.process_update(telegram_update)\n    return Response(status_code=HTTP_200_OK)\n\n\nif not settings.is_production:\n\n    @router.on_event(\"startup\")\n    async def set_webhook() -> None:\n        \"\"\"\n        Tell Telegram API about new webhook on app startup.\n\n        We need to check current webhook url first, because Telegram API has\n        strong rate limit for `set_webhook` method.\n        \"\"\"\n        bot = telegram_bot()\n\n        webhook_endpoint = router.url_path_for(\"webhook_handler\")\n        url = urljoin(settings.TELEGRAM_BOT_WEBHOOK_ENDPOINT, webhook_endpoint)\n\n        current_url = (await bot.get_webhook_info())[\"url\"]\n\n        if current_url != url:\n            await bot.set_webhook(url=url)\n            logger.warning(\"webhook updated!\")\n\n\n@router.on_event(\"shutdown\")\nasync def disconnect_storage() -> None:\n    \"\"\"\n    Close connection to storage.\n\n    We don't use storage at this moment, but in future...\n    \"\"\"\n    dispatcher = bot_dispatcher()\n    await dispatcher.storage.close()\n    await dispatcher.storage.wait_closed()\n"}
{"type": "source_file", "path": "telegram_bot/intergration/location/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/intergration/weather/const.py", "content": "WEATHER_2D_MESSAGE_TEMPLATE = \"\"\"\\\nüìç{location}   \n\n‰ªäÂ§©{d1}ÔºåÁôΩÂ§©{d1_pretty}\nÊòéÂ§©{d2}ÔºåÁôΩÂ§©{d2_pretty}\n\n{extra}\n\"\"\"\n\nWEATHER_6H_MESSAGE_TEMPLATE = \"\"\"\\\nüìç{location}   \n\n{hours}\n\"\"\"\n"}
{"type": "source_file", "path": "telegram_bot/__init__.py", "content": "# -*- coding: utf-8 -*-\n\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/base_weather_client.py", "content": "from abc import ABC, abstractmethod\n\n\nclass WeatherClient(ABC):\n    @abstractmethod\n    def get_weather_forecast(self, location) -> str:\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_weather_photo(self, location) -> str:\n        raise NotImplementedError\n\n    def __str__(self) -> str:\n        return self.__class__.__name__\n\n    __repr__ = __str__\n"}
{"type": "source_file", "path": "telegram_bot/intergration/location/he_location_client.py", "content": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom httpx import HTTPError\nfrom retry import retry\n\nfrom telegram_bot.intergration.http.base_http_client import HttpClient\nfrom telegram_bot.settings import settings\n\nKEY = settings.HE_WEATHER_API_TOKEN\n\n\n@dataclass\nclass Location:\n    name: str\n    lat: float\n    lon: float\n    tz: str\n    province: Optional[str] = \"\"\n    country: Optional[str] = \"\"\n    url: Optional[str] = \"\"\n\n    def get_location(self):\n        return f\"{self.lon},{self.lat}\" if self.lat and self.lon else self.name\n\n    def __eq__(self, o: \"Location\") -> bool:\n        return self.lat == o.lat and self.lon == o.lon and self.name == o.name\n\n    def __hash__(self) -> int:\n        return hash((self.lat, self.lon, self.name))\n\n    def __str__(self):\n        return f\"{self.lon},{self.lat},{self.name}\"\n\n    __repr__ = __str__\n\n\nclass HeLocationClient:\n    def __init__(self, http_client: HttpClient):\n        self.http_client = http_client\n\n    URL = f\"https://geoapi.qweather.com/v2/city/lookup?location={{}}&key={KEY}\"\n\n    @retry((HTTPError,), tries=3, delay=1, backoff=2)\n    async def _fetch(self, location_id: str) -> Optional[Location]:\n        url = self.URL.format(location_id)\n        d = await self.http_client.get(url)\n\n        location_list = d.get(\"location\")\n        if not location_list:\n            return\n\n        d_location = location_list[0]\n        return Location(\n            name=d_location[\"name\"],\n            lat=float(d_location[\"lat\"]),\n            lon=float(d_location[\"lon\"]),\n            tz=d_location[\"tz\"],\n            province=d_location[\"adm1\"],\n            country=d_location[\"country\"],\n            url=d_location[\"fxLink\"],\n        )\n\n    async def get_location_by_city_keywords(self, keywords) -> Optional[Location]:\n        if not keywords:\n            return\n        return await self._fetch(keywords)\n\n    async def get_location_by_lat_lon(self, lat, lon) -> Optional[Location]:\n        if not (lat or lon):\n            return\n        return await self._fetch(f\"{lon},{lat}\")\n"}
{"type": "source_file", "path": "telegram_bot/app.py", "content": "# -*- coding: utf-8 -*-\nimport sys\n\nfrom fastapi import FastAPI\nfrom loguru import logger\nimport sentry_sdk\nfrom sentry_sdk.integrations.asgi import SentryAsgiMiddleware\nimport uvicorn\n\nfrom telegram_bot.controllers import meta, release, webhook\nfrom telegram_bot.cron import cron, scheduler\nfrom telegram_bot.database import models\nfrom telegram_bot.database.database import engine\nfrom telegram_bot.settings import settings\n\n# Êó•ÂøóÊ†ºÂºèËÆæÁΩÆ\nlogger.remove()\nFORMAT = \"<level>{level: <6}</level> <green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> <level>{message}</level>\"\nlogger.add(sys.stdout, colorize=True, format=FORMAT, diagnose=False)\n\napp = FastAPI()\napp.include_router(meta.router)\napp.include_router(webhook.router)\napp.include_router(cron.router)\napp.include_router(release.router)\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    # ÂÆöÊó∂‰ªªÂä°\n    scheduler.start()\n    logger.info(\"starting cron service..\", scheduler)\n\n    # Êï∞ÊçÆÂ∫ìÊõ¥Êñ∞\n    logger.info(\"updating database schema..\")\n    models.Base.metadata.create_all(bind=engine)\n\n\n# sentry middleware\nif settings.SENTRY_URL:\n    logger.info(\"start sentry...\")\n    sentry_sdk.init(\n        dsn=settings.SENTRY_URL,\n        # Set traces_sample_rate to 1.0 to capture 100%\n        # of transactions for performance monitoring.\n        traces_sample_rate=1.0,\n        # Set profiles_sample_rate to 1.0 to profile 100%\n        # of sampled transactions.\n        # We recommend adjusting this value in production.\n        profiles_sample_rate=1.0,\n    )\n    app = SentryAsgiMiddleware(app)\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"app:app\", host=\"127.0.0.1\", port=5000, log_level=\"info\", reload=True)\n"}
{"type": "source_file", "path": "telegram_bot/intergration/http/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/intergration/weather/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/database/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/intergration/weather/wttr_weather_client.py", "content": "import requests\n\nfrom telegram_bot.intergration.weather.base_weather_client import WeatherClient\n\n\nclass AsciiWeatherClient(WeatherClient):\n    def get_weather_photo(self, location) -> str:\n        return f\"wttr.in/31.23,121.47.png?2nFqQ\"\n\n    def get_weather_forecast(self, location) -> str:\n        return requests.get(f\"http://wttr.in/shanghai\").text\n"}
{"type": "source_file", "path": "telegram_bot/telegram/add_location.py", "content": "from typing import Optional\nfrom aiogram import types\nfrom aiogram.dispatcher import FSMContext\nfrom aiogram.dispatcher.filters import Text\nfrom aiogram.dispatcher.filters.state import StatesGroup, State\nfrom aiogram.types import ContentType\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db_session\nfrom telegram_bot.intergration import he_location_client, he_weather\nfrom telegram_bot.intergration.location.he_location_client import Location\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.telegram.dispatcher import dp\n\n\nasync def _get_location_from_message(message: types.Message) -> Optional[\"Location\"]:\n    # 1. Áî®Êà∑ÂÆö‰Ωç‰ΩçÁΩÆ\n    if message.location:\n        return await he_location_client.get_location_by_lat_lon(\n            message.location.latitude, message.location.longitude\n        )\n\n    # 2. ÂÖ≥ÈîÆÂ≠óÂÆö‰Ωç\n    return await he_location_client.get_location_by_city_keywords(message.text.strip())\n\n\nclass Form(StatesGroup):\n    add_location = State()\n\n\n@dp.message_handler(commands=\"add_sub_locations\")\nasync def add_location(message: types.Message):\n    # Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÁªèËÆæÁΩÆÂüéÂ∏Ç‰∏ª‰ΩçÁΩÆ\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        if not crud.get_user(db, chat_id):\n            await TelegramMessageService.send_text(\n                dp.bot, chat_id, \"ËØ∑ÂÖàËÆæÁΩÆ‰∏ªÂüéÂ∏Ç‰ΩçÁΩÆ„ÄÇ  /set_location\"\n            )\n            return\n\n    # ÂºÄÂßãÊ∑ªÂä†ÂüéÂ∏ÇÂ≠ê‰ΩçÁΩÆ\n    await Form.add_location.set()\n    await TelegramMessageService.send_text(\n        dp.bot, chat_id, \"ËØ∑ÂõûÂ§çÊñ∞Â¢ûÂüéÂ∏ÇÂÖ≥ÈîÆÂ≠óÔºåÊàñËÄÖÊ®°Á≥äÂÆö‰Ωç„ÄÇ  /cancel\"\n    )\n\n\n@dp.message_handler(state=\"*\", commands=\"cancel\")\n@dp.message_handler(Text(equals=\"cancel\", ignore_case=True), state=\"*\")\nasync def cancel_handler(message: types.Message, state: FSMContext):\n    \"\"\"\n    Allow user to cancel any action\n    \"\"\"\n    current_state = await state.get_state()\n    if current_state is None:\n        return\n\n    await state.finish()\n    await message.reply(\"Â∑≤ÂèñÊ∂à\")\n\n\n@dp.message_handler(state=Form.add_location, content_types=ContentType.LOCATION)\n@dp.message_handler(state=Form.add_location, content_types=ContentType.VENUE)\n@dp.message_handler(state=Form.add_location, content_types=ContentType.TEXT)\nasync def process_location(message: types.Message, state: FSMContext):\n    location = await _get_location_from_message(message)\n    if not location:\n        return await message.reply(\"Êâæ‰∏çÂà∞ËæìÂÖ•ÁöÑÂüéÂ∏ÇÔºåËØïËØïÂÖ∂‰ªñÂÖ≥ÈîÆÂ≠ó /cancel\")\n\n    # Êõ¥Êñ∞Áî®Êà∑ÊâÄÂ±û‰ΩçÁΩÆ\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        user = crud.add_location(db, chat_id, location)\n    await message.reply(\n        f\"ÂüéÂ∏Ç‰ø°ÊÅØÂ∑≤Êñ∞Â¢ûÔºö{location.province}{user.city_name}\"\n        f\"({user.latitude},{user.longitude})\\n{location.url}\"\n    )\n\n    # Êõ¥Êñ∞‰ΩçÁΩÆÂêéÔºåÂèëÈÄÅÂ§©Ê∞îÈ¢ÑÊä•\n    text = await he_weather.get_weather_forecast(user.location)\n    text = f\"\\n{text}\"\n    await TelegramMessageService.send_text(dp.bot, chat_id, text)\n\n    # Finish conversation\n    await state.finish()\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/models/he_weather_model.py", "content": "from dataclasses import dataclass\nfrom typing import Dict, List\n\n\n@dataclass\nclass HeWeatherModel:\n    w_day: str\n    w_night: str\n\n    temp_min: str\n    temp_max: str\n    temp_now: str\n\n    air_aqi: str\n    air_text: str\n\n    life_text: str\n    warning_text: str\n\n    @classmethod\n    def build(cls, weather_daily: Dict, weather_now: Dict = None, air_now: Dict = None, indices: List = None,\n              warning: List = None):\n        weather_now = weather_now or {}\n        air_now = air_now or {}\n        indices_d1 = indices[0] if indices else {}\n        warning_first = warning[0] if warning else {}\n        return cls(\n            weather_daily.get(\"textDay\", \"\"),\n            weather_daily.get(\"textNight\", \"\"),\n            weather_daily.get(\"tempMin\", \"\"),\n            weather_daily.get(\"tempMax\", \"\"),\n            weather_now.get(\"temp\", \"\"),\n            air_now.get(\"aqi\", \"\"),\n            air_now.get(\"category\", \"\"),\n            indices_d1.get(\"text\", \"\"),\n            warning_first.get(\"text\", \"\"),\n        )\n\n    @staticmethod\n    def with_emoji(day_text):\n        emoji_map = {\"Êô¥\": \"‚òÄÔ∏è\", \"Êô¥Èó¥Â§ö‰∫ë\": \"üå§\", \"Èõ∑ÈòµÈõ®\": \"‚õà\"}\n        if emoji := emoji_map.get(day_text):\n            return emoji\n\n        if \"Èõ™\" in day_text:\n            return \"‚ùÑÔ∏è\"\n        if \"Èõ®\" in day_text:\n            return \"üåß\"\n        if \"‰∫ë\" in day_text or \"Èò¥\" in day_text:\n            return \"‚òÅÔ∏è\"\n\n        return \"\"\n\n    @property\n    def w_day_with_emoji(self):\n        return f\"{self.with_emoji(self.w_day)}{self.w_day}\"\n\n    @property\n    def w_night_with_emoji(self):\n        return self.w_night + self.with_emoji(self.w_night)\n\n    def __str__(self) -> str:\n        d_str = f\"{self.w_day_with_emoji}\"\n\n        if self.temp_min and self.temp_max:\n            d_str += f\"({self.temp_min}¬∞~{self.temp_max}¬∞)\"\n\n        if self.w_night != self.w_day:\n            d_str += f\"ÔºåÂ§úÈó¥{self.w_night}\"\n        if self.air_aqi and self.air_text:\n            d_str += f\"ÔºåÁ©∫Ê∞î{self.air_text}({self.air_aqi})\"\n\n        return d_str\n"}
{"type": "source_file", "path": "telegram_bot/telegram/__init__.py", "content": "\"\"\" manually import to be reachable \"\"\"\nfrom telegram_bot.telegram import (\n    callbacks,\n    update_location,\n    add_location,\n    update_dingbot,\n    exception,\n)\n\n__all__ = [\n    \"bot\",\n    \"dispatcher\",\n]\n"}
{"type": "source_file", "path": "telegram_bot/settings.py", "content": "from dataclasses import dataclass\nfrom functools import partial\nfrom typing import Optional\nfrom urllib.parse import urlparse\n\nfrom aiocache import Cache, cached\nfrom aiogram.contrib.fsm_storage.memory import MemoryStorage\nfrom pydantic import BaseSettings, SecretStr\n\n\nclass Settings(BaseSettings):\n    TELEGRAM_BOT_API_KEY: SecretStr\n    TELEGRAM_BOT_WEBHOOK_ENDPOINT: str\n    HE_WEATHER_API_TOKEN: str\n    DATABASE_URL: str\n    REDIS_URL: Optional[str] = \"\"\n    SENTRY_URL: Optional[str] = \"\"\n    ENV: str = \"production\"\n    CACHE_TTL: int = 60 * 59\n    DEFAULT_TIMEZONE: str = \"Asia/Shanghai\"\n    PROXY: Optional[str] = \"\"\n    DO_RELEASE: bool = False\n    DOMAIN: Optional[str] = \"localhost\"\n\n    @property\n    def is_production(self):\n        return self.ENV == \"production\"\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n\n@dataclass\nclass RedisConfig:\n    host: str\n    port: int\n    user: Optional[str]\n    password: Optional[str]\n\n    def __init__(self, url) -> None:\n        parsed_redis_url = urlparse(url)\n        if parsed_redis_url.hostname is None or parsed_redis_url.port is None:\n            raise ValueError(f\"invalid redis url: {url}\")\n        self.user, self.password, self.host, self.port = (\n            parsed_redis_url.username,\n            parsed_redis_url.password,\n            parsed_redis_url.hostname,\n            int(parsed_redis_url.port),\n        )\n\n\nsettings = Settings()\nredis_config = RedisConfig(settings.REDIS_URL)\n# dispatcher_storage = RedisStorage(\n#     host=redis_config.host, port=redis_config.port, password=redis_config.password\n# )\ndispatcher_storage = MemoryStorage()\n\naio_lru_cache_partial = partial(\n    cached,\n    cache=Cache.REDIS,\n    endpoint=redis_config.host,\n    port=redis_config.port,\n    password=redis_config.password,\n)\naio_lru_cache_1h = aio_lru_cache_partial(ttl=settings.CACHE_TTL)\naio_lru_cache_24h = aio_lru_cache_partial(ttl=settings.CACHE_TTL * 24)\n"}
{"type": "source_file", "path": "telegram_bot/telegram/keyboard/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/service/dingtalk.py", "content": "import functools\n\nimport sentry_sdk\nfrom loguru import logger\n\nfrom telegram_bot.intergration import ding_bot_client\nfrom telegram_bot.intergration.exceptions import DingBotException\n\n\ndef service_template(f):\n    @functools.wraps(f)\n    async def inner(token: str, msg: str):\n        try:\n            await f(token, msg)\n        except DingBotException as e:\n            logger.error(e)\n            sentry_sdk.capture_exception(e, \"ÈíâÈíâÂèëÈÄÅÂºÇÂ∏∏\")\n        except Exception as e:\n            logger.error(e)\n            sentry_sdk.capture_exception(e)\n        else:\n            logger.info(f\"message send to {token}, msg: {msg}\")\n\n    return inner\n\n\nclass DingBotMessageService:\n    \"\"\"ÈíâÈíâËá™ÂÆö‰πâÊú∫Âô®‰∫∫ÂèëÈÄÅÊ∂àÊÅØÔºåÂåÖÂê´ÂºÇÂ∏∏Â§ÑÁêÜ\"\"\"\n\n    @staticmethod\n    @service_template\n    async def send_text(token: str, msg: str):\n        if not token or not msg:\n            raise ValueError(f\"ÂèÇÊï∞ÈùûÊ≥ï,token:{token},msg:{msg}\")\n        await ding_bot_client.send_text(token, msg)\n"}
{"type": "source_file", "path": "telegram_bot/service/telegram.py", "content": "import functools\nfrom typing import Union\n\nimport sentry_sdk\nfrom aiogram import Bot\nfrom aiogram.utils.exceptions import (\n    BadRequest,\n    BotBlocked,\n    UserDeactivated,\n    ChatNotFound,\n    BotKicked,\n    MigrateToChat,\n    CantTalkWithBots,\n    Unauthorized,\n)\nfrom loguru import logger\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db_session\n\n\ndef service_template(f):\n    @functools.wraps(f)\n    async def inner(bot: Bot, chat_id: str, *args, **kwargs):\n        try:\n            await f(bot, chat_id, *args, **kwargs)\n        except (\n            BotBlocked,\n            UserDeactivated,\n            ChatNotFound,\n            BotKicked,\n            CantTalkWithBots,\n        ) as e:\n            logger.warning(f\"bot blocked by {chat_id},{str(e)}\")\n            with get_db_session() as db:\n                crud.update_user_status(db, chat_id, False)\n        except Unauthorized as e:\n            if e.text and \"the group chat was deleted\" in e.text:\n                logger.warning(f\"{bot} of group was deleted\")\n        except BadRequest as e:\n            if e.text == \"Not enough rights to send text messages to the chat\":\n                logger.warning(f\"bot not enough rights to send text messages to the chat\")\n                with get_db_session() as db:\n                    crud.update_user_status(db, chat_id, False)\n        except MigrateToChat as e:\n            with get_db_session() as db:\n                crud.update_user_status(db, chat_id, False)\n                crud.migrate_user_by_chat_id(db, chat_id, str(e.migrate_to_chat_id))\n        except Exception as e:\n            logger.error(e)\n            sentry_sdk.capture_exception(e)\n        else:\n            logger.info(f\"message send to {chat_id},args={args},kwargs={kwargs}\")\n\n    return inner\n\n\nclass TelegramMessageService:\n    @staticmethod\n    @service_template\n    async def send_text(bot: Bot, chat_id: Union[int, str], text: str):\n        await bot.send_message(chat_id=chat_id, text=text)\n\n    @staticmethod\n    @service_template\n    async def send_markdown(bot: Bot, chat_id: str, text: str):\n        await bot.send_message(chat_id=chat_id, text=text, parse_mode=\"MarkdownV2\")\n\n    @staticmethod\n    @service_template\n    async def send_keyboard_markup(\n        bot: Bot, chat_id: str, text: str, reply_markup=None, parse_mode=\"MarkdownV2\"\n    ):\n        await bot.send_message(\n            chat_id=chat_id, text=text, parse_mode=parse_mode, reply_markup=reply_markup\n        )\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/models/warn_model.py", "content": "from dataclasses import dataclass\n\nTEMPLATE = \"\"\"\\\n{prefix} {typeName}{level}È¢ÑË≠¶\n\n{text}\n\"\"\"\n\n\n@dataclass\nclass WarnModel:\n    text: str\n    typeName: str\n    level: str\n    prefix: str = \"‚ö†Ô∏è\"\n\n    def __str__(self) -> str:\n        return TEMPLATE.format(\n            prefix=self.prefix,\n            level=self.level,\n            typeName=self.typeName,\n            text=self.text\n        )\n"}
{"type": "source_file", "path": "telegram_bot/telegram/exception.py", "content": "from aiogram import types\nfrom aiogram.utils.exceptions import BotBlocked, MessageNotModified\nfrom loguru import logger\nfrom sentry_sdk import capture_exception\n\nfrom telegram_bot.telegram.dispatcher import dp\n\n\n@dp.errors_handler(exception=BotBlocked, )\nasync def global_error_handler(update: types.Update, e):\n    logger.warning(e)\n    return True\n\n\n@dp.errors_handler(exception=MessageNotModified)\nasync def global_error_handler(update: types.Update, e):\n    logger.warning(e)\n    return True\n\n\n@dp.errors_handler(exception=Exception)\nasync def global_error_handler(update: types.Update, e: Exception):\n    capture_exception(e)\n    logger.exception(e)\n    return True\n"}
{"type": "source_file", "path": "telegram_bot/service/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/telegram/bot.py", "content": "from aiogram import Bot\n\nfrom telegram_bot.settings import settings\n\nbot = Bot(\n    token=settings.TELEGRAM_BOT_API_KEY.get_secret_value(),\n    proxy=settings.PROXY\n)\n# bot.timeout = 3\n"}
{"type": "source_file", "path": "telegram_bot/telegram/callbacks.py", "content": "from aiogram import types\n\nfrom telegram_bot.database import crud, models\nfrom telegram_bot.database.database import get_db_session\nfrom telegram_bot.intergration import he_weather\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.settings import aio_lru_cache_24h\nfrom telegram_bot.telegram.dispatcher import dp\nfrom telegram_bot.telegram.keyboard.keyboard_markup_factory import (\n    HOURS_TEMPLATE,\n    REMOVE_LOCATION_PREFIX,\n    KeyboardMarkUpFactory,\n    WELCOME_TEXT,\n    GET_WEATHER,\n    UPDATE_LOCATION,\n    ENABLE_SUB,\n    DISABLE_SUB,\n    UPDATE_SUB_CRON,\n    BACK,\n    hour_decode,\n)\nfrom telegram_bot.telegram.update_location import update_location\n\n\ndef registered(func):\n    async def wrapper(message: types.Message):\n        chat_id = str(message.chat.id)\n        with get_db_session() as db:\n            if not crud.is_user_exists(db, chat_id):\n                return await update_location(message)\n\n        await func(message)\n\n    return wrapper\n\n\n@dp.message_handler(commands=[\"weather\"])\n@registered\nasync def handle_weather(message: types.Message) -> None:\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        locations = crud.get_user_locations(db, chat_id)\n\n    for location in locations:\n        text = await he_weather.get_weather_forecast(location)\n        await TelegramMessageService.send_text(dp.bot, chat_id, text)\n\n\nasync def do_send_warning_message(chat: models.Chat, text: str):\n    await TelegramMessageService.send_text(dp.bot, chat.chat_id, text)\n    # Ê≥®ÊÑèÔºöÂøÖÈ°ªËøîÂõûÂÄºÔºå‰ª•Á°Æ‰øùÁºìÂ≠òÁîüÊïà\n    return True\n\n\nnotify_with_24h_cache = aio_lru_cache_24h(do_send_warning_message)\n\n\n@dp.message_handler(commands=[\"warning\"])\n@registered\nasync def handle_weather(message: types.Message) -> None:\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        user = crud.get_user(db, chat_id)\n        locations = crud.get_user_locations(db, chat_id)\n\n    for location in locations:\n        if text := await he_weather.get_weather_warning(location):\n            await notify_with_24h_cache(user, text)\n\n\n@dp.message_handler(commands=[\"weather_6h\"])\n@registered\nasync def handle_weather(message: types.Message) -> None:\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        locations = crud.get_user_locations(db, chat_id)\n\n    for location in locations:\n        text = await he_weather.get_weather_6h_forecast_text(location)\n        await TelegramMessageService.send_text(dp.bot, chat_id, text)\n\n\n@dp.message_handler(commands=[\"id\"])\n@registered\nasync def handle_chat_id(message: types.Message) -> None:\n    chat_id = message.chat.id\n    await TelegramMessageService.send_text(dp.bot, chat_id, chat_id)\n\n\n@dp.message_handler(commands=[\"help\", \"start\"])\nasync def handle_help(message: types.Message) -> None:\n    with get_db_session() as db:\n        user = crud.get_user(db, message.chat.id)\n    reply_markup = KeyboardMarkUpFactory.build_main_menu(user)\n    await TelegramMessageService.send_keyboard_markup(\n        dp.bot, message.chat.id, WELCOME_TEXT, reply_markup\n    )\n\n\n@dp.message_handler(commands=[\"subscribe\"])\n@registered\nasync def handle_sub(message: types.Message) -> None:\n    with get_db_session() as db:\n        crud.update_user_status(db, message.chat.id, True)\n        await TelegramMessageService.send_text(dp.bot, message.chat.id, \"Â∑≤ÂºÄÂêØÂÆöÊó∂ËÆ¢ÈòÖ\")\n\n        user = crud.get_user(db, message.chat.id)\n        reply_markup = KeyboardMarkUpFactory.build_cron_options(user)\n        await TelegramMessageService.send_keyboard_markup(\n            dp.bot, message.chat.id, WELCOME_TEXT, reply_markup\n        )\n\n\n@dp.message_handler(commands=[\"unsubscribe\"])\n@registered\nasync def handle_unsub(message: types.Message) -> None:\n    with get_db_session() as db:\n        crud.update_user_status(db, message.chat.id, False)\n    await TelegramMessageService.send_text(dp.bot, message.chat.id, \"Â∑≤ÂÖ≥Èó≠ÂÆöÊó∂ËÆ¢ÈòÖ\")\n\n\n@dp.callback_query_handler(text=GET_WEATHER)\nasync def weather_callback_handler(query: types.CallbackQuery):\n    await handle_weather(query.message)\n    await query.answer(\"\")\n\n\n@dp.callback_query_handler(text=UPDATE_LOCATION)\nasync def location_callback_handler(query: types.CallbackQuery):\n    await update_location(query.message)\n    await query.answer(\"\")\n\n\n@dp.callback_query_handler(text=ENABLE_SUB)\n@dp.callback_query_handler(text=DISABLE_SUB)\nasync def update_subscription_callback_handler(query: types.CallbackQuery):\n    is_enable = query.data == ENABLE_SUB\n    with get_db_session() as db:\n        crud.update_user_status(db, query.message.chat.id, is_enable)\n        text = \"Â∑≤ÂºÄÂêØËÆ¢ÈòÖ\" if is_enable else \"Â∑≤ÂÖ≥Èó≠ËÆ¢ÈòÖ\"\n        user = crud.get_user(db, query.message.chat.id)\n        await query.answer(text)\n        await query.message.edit_reply_markup(\n            KeyboardMarkUpFactory.build_cron_options(user)\n        )\n\n\n@dp.callback_query_handler(text=UPDATE_SUB_CRON)\nasync def sub_cron_callback_handler(query: types.CallbackQuery):\n    with get_db_session() as db:\n        user = crud.get_user(db, query.message.chat.id)\n        await query.message.edit_reply_markup(\n            KeyboardMarkUpFactory.build_cron_options(user)\n        )\n        await query.answer(\"\")\n\n\n@dp.callback_query_handler(text=BACK)\nasync def exit_callback_handler(query: types.CallbackQuery):\n    with get_db_session() as db:\n        user = crud.get_user(db, query.message.chat.id)\n        await query.message.edit_reply_markup(\n            KeyboardMarkUpFactory.build_main_menu(user)\n        )\n        await query.answer(\"\")\n\n\n@dp.callback_query_handler(lambda callback_query: callback_query.data in HOURS_TEMPLATE)\nasync def sub_cron_update_callback_handler(query: types.CallbackQuery):\n    hour = hour_decode(query.data)\n    chat_id = query.message.chat.id\n\n    with get_db_session() as db:\n        # ÊøÄÊ¥ªÁî®Êà∑\n        crud.update_user_status(db, query.message.chat.id, True)\n        user = crud.get_user(db, query.message.chat.id)\n\n        # Êñ∞Â¢û/Âà†Èô§ËÆ¢ÈòÖ\n        cron_job, created = crud.create_or_delete_cron_job(db, chat_id, hour)\n        if created:\n            await query.answer(\"ËÆ¢ÈòÖÊàêÂäü\")\n        else:\n            await query.answer(\"Â∑≤ÂèñÊ∂à\")\n\n        db.refresh(user)\n        cron_sub_menu = KeyboardMarkUpFactory.build_cron_options(user)\n        await query.message.edit_reply_markup(cron_sub_menu)\n\n\n@dp.message_handler(commands=[\"delete_sub_locations\"])\nasync def remove_ding_token(message: types.Message) -> None:\n    chat_id = str(message.chat.id)\n    with get_db_session() as db:\n        locations = crud.filter_locations(db, chat_id)\n    if not locations:\n        await message.reply(\"‰∏çÂ≠òÂú®ÂÖ∂‰ªñÂ≠ê‰ΩçÁΩÆ\")\n        return\n\n    mark_up = KeyboardMarkUpFactory.build_sub_locations(locations)\n    await TelegramMessageService.send_keyboard_markup(\n        dp.bot, chat_id, \"ÂçïÂáªÂüéÂ∏ÇÂà†Èô§üëá\", mark_up\n    )\n\n\n@dp.callback_query_handler(\n    lambda callback_query: REMOVE_LOCATION_PREFIX in callback_query.data\n)\nasync def delete_sub_location_update_callback_handler(query: types.CallbackQuery):\n    location_id = query.data.replace(REMOVE_LOCATION_PREFIX, \"\")\n    chat_id = str(query.message.chat.id)\n\n    with get_db_session() as db:\n        deleted = crud.remove_sub_location(db, location_id)\n        if not deleted:\n            return\n\n        await query.answer(\"Âà†Èô§ÊàêÂäü\")\n\n        locations = crud.filter_locations(db, chat_id)\n        cron_sub_menu = KeyboardMarkUpFactory.build_sub_locations(locations)\n        await query.message.edit_reply_markup(cron_sub_menu)\n"}
{"type": "source_file", "path": "telegram_bot/intergration/weather/models/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/telegram/keyboard/keyboard_markup_factory.py", "content": "import itertools\nfrom typing import List, Optional, Union\n\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\nfrom telegram_bot.database import crud, models\nfrom telegram_bot.database.database import get_db, get_db_session\n\nWELCOME_TEXT = \"\"\"\\\nÂü∫‰∫é„ÄåÂíåÈ£é„ÄçÁöÑÂ§©Ê∞îÈ¢ÑÊä•Êú∫Âô®‰∫∫ÔºõÊ†πÊçÆÂÆö‰ΩçÊü•ËØ¢Á≤æÂáÜÂÆûÊó∂Â§©Ê∞îÔºåÂπ∂ÊØèÂ§©Ëá™Âä®Êí≠Êä•„ÄÇ\n\nÂ¶ÇÊúâ‰ªª‰ΩïÈóÆÈ¢òÔºåËØ∑ËÅîÁ≥ª @daya233    \n\"\"\"\n\nENABLE_SUB, DISABLE_SUB = \"enable_sub\", \"disable_sub\"\nGET_WEATHER, UPDATE_LOCATION = \"weather\", \"edit\"\nUPDATE_SUB_CRON = \"update_cron\"\nBACK = \"back\"\n\nREMOVE_LOCATION_PREFIX = \"remove_location_\"\n\n# fmt: off\ndef hour_encode(hour: Union[int, str]) -> str: return f\"cron_{hour}\"\ndef hour_decode(hour: str) -> str: return hour.replace(\"cron_\", \"\")\n# fmt: on\nHOURS = tuple(str(x) for x in range(0, 24, 2))\nHOURS_TEMPLATE = tuple(hour_encode(x) for x in range(0, 24, 2))\n\n\nclass KeyboardMarkUpFactory:\n    @staticmethod\n    def build_main_menu(chat: \"models.Chat\") -> InlineKeyboardMarkup:\n        keyboard_markup = InlineKeyboardMarkup(row_width=6)\n\n        # Á¨¨‰∏ÄË°åÔºöÂ§©Ê∞îËé∑Âèñ\n        weather_button = InlineKeyboardButton(\"Ëé∑ÂèñÂÆûÊó∂Â§©Ê∞î\", callback_data=GET_WEATHER)\n        keyboard_markup.add(weather_button)\n\n        # Á¨¨‰∫åË°åÔºöËá™ÂÆö‰πâÈÖçÁΩÆ\n        inline_buttons = [InlineKeyboardButton(\"Êõ¥Êñ∞‰ΩçÁΩÆ\", callback_data=UPDATE_LOCATION)]\n        if chat and chat.is_location_exist:\n            sub_cron_button = InlineKeyboardButton(\n                \"ÂÆöÊó∂ËÆ¢ÈòÖ\", callback_data=UPDATE_SUB_CRON\n            )\n            inline_buttons.append(sub_cron_button)\n\n        star_button = InlineKeyboardButton(\n            \"ÂÖ≥Ê≥®È°πÁõÆ‚ú®\", url=\"https://github.com/daya0576/he_weather_bot\"\n        )\n        inline_buttons.append(star_button)\n        keyboard_markup.row(*inline_buttons)\n\n        return keyboard_markup\n\n    @staticmethod\n    def build_cron_options(chat: \"models.Chat\") -> Optional[InlineKeyboardMarkup]:\n        if not chat:\n            return\n\n        keyboard_markup = InlineKeyboardMarkup(row_width=6)\n\n        chunk_size = 6\n        for x in range(0, len(HOURS), chunk_size):\n            inline_btn_list = []\n            for hour in HOURS[x : x + chunk_size]:\n                hour_formatted = f\"{hour}‚úì\" if hour in chat.sub_hours else hour\n                btn = InlineKeyboardButton(\n                    hour_formatted, callback_data=hour_encode(hour)\n                )\n                inline_btn_list.append(btn)\n            keyboard_markup.row(*inline_btn_list)\n\n        back_btn = InlineKeyboardButton(\"ËøîÂõû\", callback_data=BACK)\n        keyboard_markup.add(back_btn)\n        return keyboard_markup\n\n    @staticmethod\n    def build_sub_locations(\n        locations: List[\"models.Locations\"],\n    ) -> Optional[InlineKeyboardMarkup]:\n        keyboard_markup = InlineKeyboardMarkup(row_width=6)\n\n        chunk_size = 4\n        for i in range(0, len(locations), chunk_size):\n            inline_position_list = []\n            for location in locations[i : i + chunk_size]:\n                btn = InlineKeyboardButton(\n                    str(location.city_name),\n                    callback_data=f\"{REMOVE_LOCATION_PREFIX}{location.id}\",\n                )\n                inline_position_list.append(btn)\n            keyboard_markup.row(*inline_position_list)\n\n        return keyboard_markup\n"}
{"type": "source_file", "path": "telegram_bot/telegram/dispatcher.py", "content": "from aiogram import Dispatcher\nfrom aiogram.contrib.middlewares.logging import LoggingMiddleware\n\nfrom telegram_bot.settings import dispatcher_storage\nfrom telegram_bot.telegram.bot import bot\n\n\"\"\"\nhelp - Â∏ÆÂä©\nweather - Ëé∑ÂèñÂÆûÊó∂Â§©Ê∞îÔºàÊúÄËøë‰∏§Â§©Ôºâ\nweather_6h - Ëé∑ÂèñÂÆûÊó∂Â§©Ê∞îÔºàÊúÄËøëÂÖ≠Â∞èÊó∂Ôºâ\nset_location - Êõ¥Êñ∞‰ΩçÁΩÆ\nsubscribe - ÂºÄÂêØËÆ¢ÈòÖ\nunsubscribe - ÂÖ≥Èó≠ËÆ¢ÈòÖ\nset_ding_bot - Êñ∞Â¢ûÈíâÈíâÊú∫Âô®‰∫∫ÂêåÊ≠•\ndelete_ding_bot - ÁßªÈô§ÈíâÈíâÂêåÊ≠•\nadd_sub_locations - Êñ∞Â¢ûÂ≠ê‰ΩçÁΩÆÔºàÊîØÊåÅÂ§ö‰∏™ÂüéÂ∏ÇÔºâ\ndelete_sub_locations - ÁßªÈô§Â≠ê‰ΩçÁΩÆ\n\"\"\"\ndp = Dispatcher(bot, storage=dispatcher_storage)\ndp.middleware.setup(LoggingMiddleware())\n"}
{"type": "source_file", "path": "telegram_bot/utils/date_util.py", "content": "# -*- coding: utf-8 -*-\nfrom datetime import datetime, timedelta\n\nimport pytz\n\n\nclass DateUtil:\n    @staticmethod\n    def get_day_of_week(time_zone, day=0):\n        \"\"\"Ëé∑ÂèñÊú™Êù• N Â§©ÁöÑÂë® X\"\"\"\n        d = {0: \"Âë®‰∏Ä\", 1: \"Âë®‰∫å\", 2: \"Âë®‰∏â\", 3: \"Âë®Âõõ\", 4: \"Âë®‰∫î\", 5: \"Âë®ÂÖ≠\", 6: \"Âë®Êó•\"}\n\n        tz = pytz.timezone(time_zone)\n        cur_time = datetime.now(tz) + timedelta(days=day)\n        return d[cur_time.weekday()]\n\n    @staticmethod\n    def get_cur_hour(time_zone: str = 'UTC') -> int:\n        \"\"\"Ê†πÊçÆÊó∂Âå∫Ëé∑ÂèñÂΩìÂâçÁöÑÂ∞èÊó∂\"\"\"\n        tz = pytz.timezone(time_zone)\n        return datetime.now(tz).hour\n\n    @staticmethod\n    def get_now_for_human() -> str:\n        tz = pytz.timezone(\"Asia/Shanghai\")\n        return datetime.now(tz).strftime(\"YYYY-MM-DDTHH:MM:SS\")\n"}
{"type": "source_file", "path": "telegram_bot/telegram/update_location.py", "content": "from typing import Optional\nfrom aiogram import types\nfrom aiogram.dispatcher import FSMContext\nfrom aiogram.dispatcher.filters import Text\nfrom aiogram.dispatcher.filters.state import StatesGroup, State\nfrom aiogram.types import ContentType\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db_session\nfrom telegram_bot.intergration import he_location_client, he_weather\nfrom telegram_bot.intergration.location.he_location_client import Location\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.telegram.dispatcher import dp\n\n\nasync def _get_location_from_message(message: types.Message) -> Optional[\"Location\"]:\n    # 1. Áî®Êà∑ÂÆö‰Ωç‰ΩçÁΩÆ\n    if message.location:\n        return await he_location_client.get_location_by_lat_lon(\n            message.location.latitude, message.location.longitude\n        )\n\n    # 2. ÂÖ≥ÈîÆÂ≠óÂÆö‰Ωç\n    return await he_location_client.get_location_by_city_keywords(message.text.strip())\n\n\nclass Form(StatesGroup):\n    location = State()\n\n\n@dp.message_handler(commands=\"set_location\")\nasync def update_location(message: types.Message):\n    await Form.location.set()\n    await TelegramMessageService.send_text(\n        dp.bot, message.chat.id, \"ËØ∑ÂõûÂ§çÂΩìÂâçÂüéÂ∏ÇÂÖ≥ÈîÆÂ≠óÔºåÊàñËÄÖÊ®°Á≥äÂÆö‰Ωç„ÄÇ  /cancel\"\n    )\n\n\n@dp.message_handler(state=\"*\", commands=\"cancel\")\n@dp.message_handler(Text(equals=\"cancel\", ignore_case=True), state=\"*\")\nasync def cancel_handler(message: types.Message, state: FSMContext):\n    \"\"\"\n    Allow user to cancel any action\n    \"\"\"\n    current_state = await state.get_state()\n    if current_state is None:\n        return\n\n    await state.finish()\n    await message.reply(\"Â∑≤ÂèñÊ∂à\")\n\n\n@dp.message_handler(state=Form.location, content_types=ContentType.LOCATION)\n@dp.message_handler(state=Form.location, content_types=ContentType.VENUE)\n@dp.message_handler(state=Form.location, content_types=ContentType.TEXT)\nasync def process_location(message: types.Message, state: FSMContext):\n    location = await _get_location_from_message(message)\n    if not location:\n        return await message.reply(\"Êâæ‰∏çÂà∞ËæìÂÖ•ÁöÑÂüéÂ∏ÇÔºåËØïËØïÂÖ∂‰ªñÂÖ≥ÈîÆÂ≠ó /cancel\")\n\n    # Êõ¥Êñ∞Áî®Êà∑ÊâÄÂ±û‰ΩçÁΩÆ\n    with get_db_session() as db:\n        user = crud.update_or_create_user_by_location(db, message.chat.id, location)\n    await message.reply(\n        f\"ÂüéÂ∏Ç‰ø°ÊÅØÂ∑≤Êõ¥Êñ∞Ôºö{location.province}{user.city_name}\"\n        f\"({user.latitude},{user.longitude})\\n{location.url}\"\n    )\n\n    # Êõ¥Êñ∞‰ΩçÁΩÆÂêéÔºåÂèëÈÄÅÂ§©Ê∞îÈ¢ÑÊä•\n    text = await he_weather.get_weather_forecast(user.location)\n    text = f\"\\n{text}\"\n    await TelegramMessageService.send_text(dp.bot, message.chat.id, text)\n\n    # Finish conversation\n    await state.finish()\n"}
{"type": "source_file", "path": "telegram_bot/telegram/update_dingbot.py", "content": "import re\n\nfrom aiogram import types\nfrom aiogram.dispatcher import FSMContext\nfrom aiogram.dispatcher.filters import Text\nfrom aiogram.dispatcher.filters.state import StatesGroup, State\nfrom aiogram.types import ContentType\n\nfrom telegram_bot.database import crud\nfrom telegram_bot.database.database import get_db_session\nfrom telegram_bot.intergration import he_weather\nfrom telegram_bot.service.dingtalk import DingBotMessageService\nfrom telegram_bot.service.telegram import TelegramMessageService\nfrom telegram_bot.telegram.callbacks import registered\nfrom telegram_bot.telegram.dispatcher import dp\n\nRE_PATTERN = re.compile(\n    r\"https://oapi\\.dingtalk\\.com/robot/send\\?access_token=([a-zA-Z0-9]+)\"\n)\n\n\nasync def extra_ding_token_from_message(text) -> str:\n    if not text:\n        return \"\"\n    if m := RE_PATTERN.match(text.strip()):\n        return m.group(1)\n\n\nclass Form(StatesGroup):\n    set_ding_token = State()\n    set_location_alias = State()\n\n\n@dp.message_handler(state=\"*\", commands=\"cancel\")\n@dp.message_handler(Text(equals=\"cancel\", ignore_case=True), state=\"*\")\nasync def cancel_handler(message: types.Message, state: FSMContext):\n    \"\"\"\n    Allow user to cancel any action\n    \"\"\"\n    current_state = await state.get_state()\n    if current_state is None:\n        return\n\n    await state.finish()\n    await message.reply(\"Â∑≤ÂèñÊ∂à\")\n\n\n@dp.message_handler(commands=\"set_ding_bot\")\n@registered\nasync def update_ding_token(message: types.Message):\n    await Form.set_location_alias.set()\n    await TelegramMessageService.send_text(dp.bot, message.chat.id, \"HiÔºÅËØ∑ÂõûÂ§çÂÆö‰ΩçÂà´ÂêçÔºå‰æãÂ¶Ç‰∏äÊµ∑Â§ñÊª©\")\n\n\n@dp.message_handler(commands=\"delete_ding_bot\")\n@registered\nasync def remove_ding_token(message: types.Message):\n    with get_db_session() as db:\n        is_delete_bot = crud.remove_ding_bot(db, message.chat.id)\n\n    if is_delete_bot:\n        return await message.reply(\"Â∑≤ÂèñÊ∂àÂÖ≥ËÅî\")\n    else:\n        return await message.reply(\"‰∏çÂ≠òÂú®ÂÖ≥ËÅî\")\n\n\n@dp.message_handler(state=Form.set_ding_token, content_types=ContentType.TEXT)\n@dp.message_handler(state=Form.set_ding_token, content_types=ContentType.ANY)\nasync def process_ding_token(message: types.Message, state: FSMContext):\n    ding_bot_token = await extra_ding_token_from_message(message.text)\n    if not ding_bot_token:\n        return await message.reply(\n            \"Êú∫Âô®‰∫∫ÁöÑWebhookÂú∞ÂùÄÈùûÊ≥ï!\"\n            \"\\nÂèÇËÄÉÊ†ºÂºèÔºöhttps://oapi.dingtalk.com/robot/send?access_token=XXXXXX\"\n            \"\\nÂèñÊ∂àËæìÂÖ•Ôºö/cancel\"\n        )\n\n    with get_db_session() as db:\n        crud.update_or_create_ding_bot(db, message.chat.id, ding_bot_token)\n\n    # ÂèëÈÄÅÊµãËØïÊ∂àÊÅØ\n    with get_db_session() as db:\n        chat = crud.get_user(db, chat_id=message.chat.id)\n    text = await he_weather.get_weather_forecast(chat.location)\n    await DingBotMessageService.send_text(ding_bot_token, text)\n    await message.reply(\"ÈíâÈíâTokenÂÖ≥ËÅîÊàêÂäüÔºåËØ∑Ê≥®ÊÑèÊü•Êî∂ÊµãËØïÊ∂àÊÅØ~\")\n    await state.finish()\n\n\n@dp.message_handler(state=Form.set_location_alias, content_types=ContentType.TEXT)\n@dp.message_handler(state=Form.set_location_alias, content_types=ContentType.ANY)\nasync def process_ding_token_alias(message: types.Message, state: FSMContext):\n    location_name = message.text.strip()\n    if not location_name or len(location_name) > 10:\n        return await message.reply(\"Âà´ÂêçÈïøÂ∫¶ËøáÈïøÔºÅ\")\n\n    with get_db_session() as db:\n        crud.update_location_name(db, message.chat.id, location_name)\n\n    await TelegramMessageService.send_text(\n        dp.bot, message.chat.id, \"ËØ∑ËæìÂÖ•Ëá™ÂÆö‰πâÊú∫Âô®‰∫∫WebhookÂú∞ÂùÄ\"\n    )\n    await Form.set_ding_token.set()\n"}
{"type": "source_file", "path": "telegram_bot/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "telegram_bot/utils/exceptions.py", "content": "class TooManyTriesException(BaseException):\n    pass\n"}

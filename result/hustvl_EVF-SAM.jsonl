{"repo_info": {"repo_name": "EVF-SAM", "repo_owner": "hustvl", "repo_url": "https://github.com/hustvl/EVF-SAM"}}
{"type": "source_file", "path": "demo.py", "content": "import gradio as gr\nfrom inference import sam_preprocess, beit3_preprocess\nfrom transformers import AutoTokenizer\nimport torch\nimport numpy as np\nimport sys\nimport time\n\nversion = sys.argv[1]\nif \"effi\" in version:\n    model_type = \"effi\"\nelif \"sam2\" in version:\n    model_type = \"sam2\"\nelse:\n    model_type = \"ori\"\n\ntokenizer = AutoTokenizer.from_pretrained(\n        version,\n        padding_side=\"right\",\n        use_fast=False,\n    )\n\nkwargs = {\n    \"torch_dtype\": torch.half,\n}\nif model_type==\"ori\":\n    from model.evf_sam import EvfSamModel\n    model = EvfSamModel.from_pretrained(version, low_cpu_mem_usage=True, **kwargs).cuda().eval()\nelif model_type==\"effi\":\n    from model.evf_effisam import EvfEffiSamModel\n    model = EvfEffiSamModel.from_pretrained(version, low_cpu_mem_usage=True, **kwargs).cuda().eval()\nelif model_type==\"sam2\":\n    from model.evf_sam2 import EvfSam2Model\n    model = EvfSam2Model.from_pretrained(version, low_cpu_mem_usage=True, **kwargs)\n    del model.visual_model.memory_encoder\n    del model.visual_model.memory_attention\n    model = model.cuda().eval()\n\n\n@torch.no_grad()\ndef pred(image_np, prompt, semantic_type):\n    # end = time.time()\n    original_size_list = [image_np.shape[:2]]\n\n    image_beit = beit3_preprocess(image_np, 224).to(dtype=model.dtype, device=model.device)\n\n    image_sam, resize_shape = sam_preprocess(image_np, model_type=model_type)\n    image_sam = image_sam.to(dtype=model.dtype, device=model.device)\n\n    if semantic_type:\n        prompt = \"[semantic] \" + prompt\n    input_ids = tokenizer(prompt, return_tensors=\"pt\")[\"input_ids\"].to(device=model.device)\n\n    # infer\n    pred_mask = model.inference(\n        image_sam.unsqueeze(0),\n        image_beit.unsqueeze(0),\n        input_ids,\n        resize_list=[resize_shape],\n        original_size_list=original_size_list,\n    )\n    pred_mask = pred_mask.detach().cpu().numpy()[0]\n    pred_mask = pred_mask > 0\n\n    visualization = image_np.copy()\n    visualization[pred_mask] = (\n        image_np * 0.5\n        + pred_mask[:, :, None].astype(np.uint8) * np.array([220, 120, 50]) * 0.5\n    )[pred_mask]\n    # print(time.time() - end)\n    return visualization/255.0, pred_mask.astype(np.float16)\n\ndemo = gr.Interface(\n    fn=pred,\n    inputs=[\n        gr.components.Image(type=\"numpy\", label=\"Image\", image_mode=\"RGB\"), \n        gr.components.Textbox(label=\"Prompt\", info=\"Use a phrase or sentence to describe the object you want to segment. Currently we only support English\"),\n        gr.components.Checkbox(False, label=\"semantic level\", info=\"check this if you want to segment body parts or background or multi objects (only available with latest evf-sam checkpoint)\")],        \n    outputs=[\n        gr.components.Image(type=\"numpy\", label=\"visulization\"), \n        gr.components.Image(type=\"numpy\", label=\"mask\")],\n    examples=[[\"assets/zebra.jpg\", \"zebra top left\"], [\"assets/bus.jpg\", \"bus going to south common\"], [\"assets/carrots.jpg\", \"3carrots in center with ice and greenn leaves\"]],\n    title=\"EVF-SAM referring expression segmentation\",\n    allow_flagging=\"never\"\n)\n# demo.launch()\ndemo.launch(\n    share=False,\n    server_name=\"0.0.0.0\",\n    server_port=10001\n)\n"}
{"type": "source_file", "path": "model/configuration_evf.py", "content": "# coding=utf-8\n# Copyright 2022 EleutherAI and the HuggingFace Inc. team. All rights reserved.\n#\n# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n# and OPT implementations in this library. It has been modified from its\n# original forms to accommodate minor architectural differences compared\n# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\" Evf model configuration\"\"\"\n\nfrom transformers.configuration_utils import PretrainedConfig\nfrom transformers.utils import logging\n\nlogger = logging.get_logger(__name__)\n\nEVF_PRETRAINED_CONFIG_ARCHIVE_MAP = {}\n\n\nclass EvfConfig(PretrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`EvfSam`].\n\n    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PretrainedConfig`] for more information.\n\n    Args:\n        hidden_size (`int`, *optional*, defaults to 4096):\n            Dimension of the hidden representations.\n        pretraining_tp (`int`, *optional*, defaults to `1`):\n            Experimental feature. Tensor parallelism rank used during pretraining. Please refer to [this\n            document](https://huggingface.co/docs/transformers/parallelism) to understand more about it. This value is\n            necessary to ensure exact reproducibility of the pretraining results. Please refer to [this\n            issue](https://github.com/pytorch/pytorch/issues/76232).\n        rope_scaling (`Dict`, *optional*):\n            Dictionary containing the scaling configuration for the RoPE embeddings. Currently supports three scaling\n            strategies: linear and dynamic. Their scaling factor must be an float greater than 1. The expected format\n            is `{\"type\": strategy name, \"factor\": scaling factor}`. When using this flag, don't update\n            `max_position_embeddings` to the expected new maximum. See the following thread for more information on how\n            these scaling strategies behave:\n            https://www.reddit.com/r/LocalLLaMA/comments/14mrgpr/dynamically_scaled_rope_further_increases/. This is an\n            experimental feature, subject to breaking API changes in future versions.\n\n        Example:\n\n    ```python\n\n    >>> configuration = EvfConfig()\n    >>> model = EvfSam(configuration)\n\n    >>> # Accessing the model configuration\n    >>> configuration = model.config\n    ```\"\"\"\n    model_type = \"evf\"\n    keys_to_ignore_at_inference = [\"past_key_values\"]\n\n    def __init__(\n        self,\n        hidden_size=768,\n        pad_token_id=1,\n        bos_token_id=0,\n        eos_token_id=2,\n        pretraining_tp=1,\n        tie_word_embeddings=False,\n        rope_scaling=None,\n        out_dim=256,\n        **kwargs,\n    ):\n        self.hidden_size = hidden_size\n        self.out_dim = out_dim\n\n        # self.pretraining_tp = pretraining_tp\n        # self.rope_scaling = rope_scaling\n        # self._rope_scaling_validation()\n\n        super().__init__(\n            pad_token_id=pad_token_id,\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            tie_word_embeddings=tie_word_embeddings,\n            **kwargs,\n        )\n\n    def _rope_scaling_validation(self):\n        \"\"\"\n        Validate the `rope_scaling` configuration.\n        \"\"\"\n        if self.rope_scaling is None:\n            return\n\n        if not isinstance(self.rope_scaling, dict) or len(self.rope_scaling) != 2:\n            raise ValueError(\n                \"`rope_scaling` must be a dictionary with with two fields, `name` and `factor`, \"\n                f\"got {self.rope_scaling}\"\n            )\n        rope_scaling_type = self.rope_scaling.get(\"type\", None)\n        rope_scaling_factor = self.rope_scaling.get(\"factor\", None)\n        if rope_scaling_type is None or rope_scaling_type not in [\"linear\", \"dynamic\"]:\n            raise ValueError(\n                f\"`rope_scaling`'s name field must be one of ['linear', 'dynamic'], got {rope_scaling_type}\"\n            )\n        if rope_scaling_factor is None or not isinstance(rope_scaling_factor, float) or rope_scaling_factor <= 1.0:\n            raise ValueError(f\"`rope_scaling`'s factor field must be an float > 1, got {rope_scaling_factor}\")\n"}
{"type": "source_file", "path": "model/EfficientSAM/efficient_sam/efficient_sam.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom typing import Any, List, Tuple, Type\n\nimport torch\nimport torch.nn.functional as F\n\nfrom torch import nn, Tensor\n\nfrom .efficient_sam_decoder import MaskDecoder, PromptEncoder\nfrom .efficient_sam_encoder import ImageEncoderViT\nfrom .two_way_transformer import TwoWayAttentionBlock, TwoWayTransformer\n\nclass EfficientSam(nn.Module):\n    mask_threshold: float = 0.0\n    image_format: str = \"RGB\"\n\n    def __init__(\n        self,\n        image_encoder: ImageEncoderViT,\n        prompt_encoder: PromptEncoder,\n        decoder_max_num_input_points: int,\n        mask_decoder: MaskDecoder,\n        pixel_mean: List[float] = [0.485, 0.456, 0.406],\n        pixel_std: List[float] = [0.229, 0.224, 0.225],\n    ) -> None:\n        \"\"\"\n        SAM predicts object masks from an image and input prompts.\n\n        Arguments:\n          image_encoder (ImageEncoderViT): The backbone used to encode the\n            image into image embeddings that allow for efficient mask prediction.\n          prompt_encoder (PromptEncoder): Encodes various types of input prompts.\n          mask_decoder (MaskDecoder): Predicts masks from the image embeddings\n            and encoded prompts.\n          pixel_mean (list(float)): Mean values for normalizing pixels in the input image.\n          pixel_std (list(float)): Std values for normalizing pixels in the input image.\n        \"\"\"\n        super().__init__()\n        self.image_encoder = image_encoder\n        self.prompt_encoder = prompt_encoder\n        self.decoder_max_num_input_points = decoder_max_num_input_points\n        self.mask_decoder = mask_decoder\n        self.register_buffer(\n            \"pixel_mean\", torch.Tensor(pixel_mean).view(1, 3, 1, 1), False\n        )\n        self.register_buffer(\n            \"pixel_std\", torch.Tensor(pixel_std).view(1, 3, 1, 1), False\n        )\n\n    @torch.jit.export\n    def predict_masks(\n        self,\n        image_embeddings: torch.Tensor,\n        batched_points: torch.Tensor,\n        batched_point_labels: torch.Tensor,\n        multimask_output: bool,\n        input_h: int,\n        input_w: int,\n        output_h: int = -1,\n        output_w: int = -1,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predicts masks given image embeddings and prompts. This only runs the decoder.\n\n        Arguments:\n          image_embeddings: A tensor of shape [B, C, H, W] or [B*max_num_queries, C, H, W]\n          batched_points: A tensor of shape [B, max_num_queries, num_pts, 2]\n          batched_point_labels: A tensor of shape [B, max_num_queries, num_pts]\n        Returns:\n          A tuple of two tensors:\n            low_res_mask: A tensor of shape [B, max_num_queries, 256, 256] of predicted masks\n            iou_predictions: A tensor of shape [B, max_num_queries] of estimated IOU scores\n        \"\"\"\n\n        batch_size, max_num_queries, num_pts, _ = batched_points.shape\n        num_pts = batched_points.shape[2]\n        rescaled_batched_points = self.get_rescaled_pts(batched_points, input_h, input_w)\n\n        if num_pts > self.decoder_max_num_input_points:\n            rescaled_batched_points = rescaled_batched_points[\n                :, :, : self.decoder_max_num_input_points, :\n            ]\n            batched_point_labels = batched_point_labels[\n                :, :, : self.decoder_max_num_input_points\n            ]\n        elif num_pts < self.decoder_max_num_input_points:\n            rescaled_batched_points = F.pad(\n                rescaled_batched_points,\n                (0, 0, 0, self.decoder_max_num_input_points - num_pts),\n                value=-1.0,\n            )\n            batched_point_labels = F.pad(\n                batched_point_labels,\n                (0, self.decoder_max_num_input_points - num_pts),\n                value=-1.0,\n            )\n\n        sparse_embeddings = self.prompt_encoder(\n            rescaled_batched_points.reshape(\n                batch_size * max_num_queries, self.decoder_max_num_input_points, 2\n            ),\n            batched_point_labels.reshape(\n                batch_size * max_num_queries, self.decoder_max_num_input_points\n            ),\n        )\n\n        sparse_embeddings = sparse_embeddings.view(\n            batch_size,\n            max_num_queries,\n            sparse_embeddings.shape[1],\n            sparse_embeddings.shape[2],\n        )\n        low_res_masks, iou_predictions = self.mask_decoder(\n            image_embeddings,\n            self.prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            multimask_output=multimask_output,\n        )\n        _, num_predictions, low_res_size, _ = low_res_masks.shape\n\n        if output_w > 0 and output_h > 0:\n            output_masks = F.interpolate(\n                low_res_masks, (output_h, output_w), mode=\"bicubic\"\n            )\n            output_masks = torch.reshape(\n                output_masks,\n                (batch_size, max_num_queries, num_predictions, output_h, output_w),\n            )\n        else:\n            output_masks = torch.reshape(\n                low_res_masks,\n                (\n                    batch_size,\n                    max_num_queries,\n                    num_predictions,\n                    low_res_size,\n                    low_res_size,\n                ),\n            )\n        iou_predictions = torch.reshape(\n            iou_predictions, (batch_size, max_num_queries, num_predictions)\n        )\n        return output_masks, iou_predictions\n\n    def get_rescaled_pts(self, batched_points: torch.Tensor, input_h: int, input_w: int):\n        return torch.stack(\n            [\n                torch.where(\n                    batched_points[..., 0] >= 0,\n                    batched_points[..., 0] * self.image_encoder.img_size / input_w,\n                    -1.0,\n                ),\n                torch.where(\n                    batched_points[..., 1] >= 0,\n                    batched_points[..., 1] * self.image_encoder.img_size / input_h,\n                    -1.0,\n                ),\n            ],\n            dim=-1,\n        )\n\n    @torch.jit.export\n    def get_image_embeddings(self, batched_images) -> torch.Tensor:\n        \"\"\"\n        Predicts masks end-to-end from provided images and prompts.\n        If prompts are not known in advance, using SamPredictor is\n        recommended over calling the model directly.\n\n        Arguments:\n          batched_images: A tensor of shape [B, 3, H, W]\n        Returns:\n          List of image embeddings each of of shape [B, C(i), H(i), W(i)].\n          The last embedding corresponds to the final layer.\n        \"\"\"\n        batched_images = self.preprocess(batched_images)\n        return self.image_encoder(batched_images)\n\n    def forward(\n        self,\n        batched_images: torch.Tensor,\n        batched_points: torch.Tensor,\n        batched_point_labels: torch.Tensor,\n        scale_to_original_image_size: bool = True,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predicts masks end-to-end from provided images and prompts.\n        If prompts are not known in advance, using SamPredictor is\n        recommended over calling the model directly.\n\n        Arguments:\n          batched_images: A tensor of shape [B, 3, H, W]\n          batched_points: A tensor of shape [B, num_queries, max_num_pts, 2]\n          batched_point_labels: A tensor of shape [B, num_queries, max_num_pts]\n\n        Returns:\n          A list tuples of two tensors where the ith element is by considering the first i+1 points.\n            low_res_mask: A tensor of shape [B, 256, 256] of predicted masks\n            iou_predictions: A tensor of shape [B, max_num_queries] of estimated IOU scores\n        \"\"\"\n        batch_size, _, input_h, input_w = batched_images.shape\n        image_embeddings = self.get_image_embeddings(batched_images)\n        return self.predict_masks(\n            image_embeddings,\n            batched_points,\n            batched_point_labels,\n            multimask_output=True,\n            input_h=input_h,\n            input_w=input_w,\n            output_h=input_h if scale_to_original_image_size else -1,\n            output_w=input_w if scale_to_original_image_size else -1,\n        )\n\n    def preprocess(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Normalize pixel values and pad to a square input.\"\"\"\n        if (\n            x.shape[2] != self.image_encoder.img_size\n            or x.shape[3] != self.image_encoder.img_size\n        ):\n            x = F.interpolate(\n                x,\n                (self.image_encoder.img_size, self.image_encoder.img_size),\n                mode=\"bilinear\",\n            )\n        return (x - self.pixel_mean) / self.pixel_std\n\n\ndef build_efficient_sam(encoder_patch_embed_dim, encoder_num_heads, checkpoint=None):\n    img_size = 1024\n    encoder_patch_size = 16\n    encoder_depth = 12\n    encoder_mlp_ratio = 4.0\n    encoder_neck_dims = [256, 256]\n    decoder_max_num_input_points = 6\n    decoder_transformer_depth = 2\n    decoder_transformer_mlp_dim = 2048\n    decoder_num_heads = 8\n    decoder_upscaling_layer_dims = [64, 32]\n    num_multimask_outputs = 3\n    iou_head_depth = 3\n    iou_head_hidden_dim = 256\n    activation = \"gelu\"\n    normalization_type = \"layer_norm\"\n    normalize_before_activation = False\n\n    assert activation == \"relu\" or activation == \"gelu\"\n    if activation == \"relu\":\n        activation_fn = nn.ReLU\n    else:\n        activation_fn = nn.GELU\n\n    image_encoder = ImageEncoderViT(\n        img_size=img_size,\n        patch_size=encoder_patch_size,\n        in_chans=3,\n        patch_embed_dim=encoder_patch_embed_dim,\n        normalization_type=normalization_type,\n        depth=encoder_depth,\n        num_heads=encoder_num_heads,\n        mlp_ratio=encoder_mlp_ratio,\n        neck_dims=encoder_neck_dims,\n        act_layer=activation_fn,\n    )\n\n    image_embedding_size = image_encoder.image_embedding_size\n    encoder_transformer_output_dim = image_encoder.transformer_output_dim\n\n    sam = EfficientSam(\n        image_encoder=image_encoder,\n        prompt_encoder=PromptEncoder(\n            embed_dim=encoder_transformer_output_dim,\n            image_embedding_size=(image_embedding_size, image_embedding_size),\n            input_image_size=(img_size, img_size),\n        ),\n        decoder_max_num_input_points=decoder_max_num_input_points,\n        mask_decoder=MaskDecoder(\n            transformer_dim=encoder_transformer_output_dim,\n            transformer=TwoWayTransformer(\n                depth=decoder_transformer_depth,\n                embedding_dim=encoder_transformer_output_dim,\n                num_heads=decoder_num_heads,\n                mlp_dim=decoder_transformer_mlp_dim,\n                activation=activation_fn,\n                normalize_before_activation=normalize_before_activation,\n            ),\n            num_multimask_outputs=num_multimask_outputs,\n            activation=activation_fn,\n            normalization_type=normalization_type,\n            normalize_before_activation=normalize_before_activation,\n            iou_head_depth=iou_head_depth - 1,\n            iou_head_hidden_dim=iou_head_hidden_dim,\n            upscaling_layer_dims=decoder_upscaling_layer_dims,\n        ),\n        pixel_mean=[0.485, 0.456, 0.406],\n        pixel_std=[0.229, 0.224, 0.225],\n    )\n    if checkpoint is not None:\n        with open(checkpoint, \"rb\") as f:\n            state_dict = torch.load(f, map_location=\"cpu\")\n        sam.load_state_dict(state_dict[\"model\"])\n    return sam\n"}
{"type": "source_file", "path": "model/EfficientSAM/efficient_sam/efficient_sam_encoder.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom typing import List, Optional, Tuple, Type\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass LayerNorm2d(nn.Module):\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        x = self.weight[:, None, None] * x + self.bias[:, None, None]\n        return x\n\n\nclass PatchEmbed(nn.Module):\n    \"\"\"2D Image to Patch Embedding\"\"\"\n\n    def __init__(\n        self,\n        img_size,\n        patch_size,\n        in_chans,\n        embed_dim,\n    ):\n        super().__init__()\n        self.proj = nn.Conv2d(\n            in_chans,\n            embed_dim,\n            kernel_size=(patch_size, patch_size),\n            stride=(patch_size, patch_size),\n            bias=True,\n        )\n\n    def forward(self, x):\n        B, C, H, W = x.shape\n        x = self.proj(x)\n        return x\n\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        num_heads,\n        qkv_bias,\n        qk_scale=None,\n    ):\n        super().__init__()\n        self.num_heads = num_heads\n        head_dim = dim // num_heads\n        self.scale = qk_scale or head_dim**-0.5\n        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)\n        self.proj = nn.Linear(dim, dim)\n\n    def forward(self, x):\n        B, N, C = x.shape\n        qkv = (\n            self.qkv(x)\n            .reshape(B, N, 3, self.num_heads, C // self.num_heads)\n            .permute(2, 0, 3, 1, 4)\n        )\n        q, k, v = (\n            qkv[0],\n            qkv[1],\n            qkv[2],\n        )\n        attn = (q @ k.transpose(-2, -1)) * self.scale\n        attn = attn.softmax(dim=-1)\n        x = (attn @ v).transpose(1, 2).reshape(B, N, C)\n        x = self.proj(x)\n        return x\n\n\nclass Mlp(nn.Module):\n    def __init__(\n        self,\n        in_features,\n        hidden_features=None,\n        out_features=None,\n        act_layer=nn.GELU,\n    ):\n        super().__init__()\n        out_features = out_features or in_features\n        hidden_features = hidden_features or in_features\n        self.fc1 = nn.Linear(in_features, hidden_features)\n        self.act = act_layer()\n        self.fc2 = nn.Linear(hidden_features, out_features)\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.act(x)\n        x = self.fc2(x)\n        return x\n\n\nclass Block(nn.Module):\n    def __init__(\n        self,\n        dim,\n        num_heads,\n        mlp_ratio=4.0,\n        qkv_bias=False,\n        qk_scale=None,\n        act_layer=nn.GELU,\n    ):\n        super().__init__()\n        self.norm1 = nn.LayerNorm(dim, eps=1e-6)\n        self.attn = Attention(\n            dim,\n            num_heads=num_heads,\n            qkv_bias=qkv_bias,\n            qk_scale=qk_scale,\n        )\n        self.norm2 = nn.LayerNorm(dim, eps=1e-6)\n        mlp_hidden_dim = int(dim * mlp_ratio)\n        self.mlp = Mlp(\n            in_features=dim,\n            hidden_features=mlp_hidden_dim,\n            act_layer=act_layer,\n        )\n\n    def forward(self, x):\n        x = x + self.attn(self.norm1(x))\n        x = x + self.mlp(self.norm2(x))\n        return x\n\n\n@torch.jit.export\ndef get_abs_pos(\n    abs_pos: torch.Tensor, has_cls_token: bool, hw: List[int]\n) -> torch.Tensor:\n    \"\"\"\n    Calculate absolute positional embeddings. If needed, resize embeddings and remove cls_token\n        dimension for the original embeddings.\n    Args:\n        abs_pos (Tensor): absolute positional embeddings with (1, num_position, C).\n        has_cls_token (bool): If true, has 1 embedding in abs_pos for cls token.\n        hw (Tuple): size of input image tokens.\n\n    Returns:\n        Absolute positional embeddings after processing with shape (1, H, W, C)\n    \"\"\"\n    h = hw[0]\n    w = hw[1]\n    if has_cls_token:\n        abs_pos = abs_pos[:, 1:]\n    xy_num = abs_pos.shape[1]\n    size = int(math.sqrt(xy_num))\n    assert size * size == xy_num\n\n    if size != h or size != w:\n        new_abs_pos = F.interpolate(\n            abs_pos.reshape(1, size, size, -1).permute(0, 3, 1, 2),\n            size=(h, w),\n            mode=\"bicubic\",\n            align_corners=False,\n        )\n        return new_abs_pos.permute(0, 2, 3, 1)\n    else:\n        return abs_pos.reshape(1, h, w, -1)\n\n\n# Image encoder for efficient SAM.\nclass ImageEncoderViT(nn.Module):\n    def __init__(\n        self,\n        img_size: int,\n        patch_size: int,\n        in_chans: int,\n        patch_embed_dim: int,\n        normalization_type: str,\n        depth: int,\n        num_heads: int,\n        mlp_ratio: float,\n        neck_dims: List[int],\n        act_layer: Type[nn.Module],\n    ) -> None:\n        \"\"\"\n        Args:\n            img_size (int): Input image size.\n            patch_size (int): Patch size.\n            in_chans (int): Number of input image channels.\n            patch_embed_dim (int): Patch embedding dimension.\n            depth (int): Depth of ViT.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            act_layer (nn.Module): Activation layer.\n        \"\"\"\n        super().__init__()\n\n        self.img_size = img_size\n        self.image_embedding_size = img_size // ((patch_size if patch_size > 0 else 1))\n        self.transformer_output_dim = ([patch_embed_dim] + neck_dims)[-1]\n        self.pretrain_use_cls_token = True\n        pretrain_img_size = 224\n        self.patch_embed = PatchEmbed(img_size, patch_size, in_chans, patch_embed_dim)\n        # Initialize absolute positional embedding with pretrain image size.\n        num_patches = (pretrain_img_size // patch_size) * (\n            pretrain_img_size // patch_size\n        )\n        num_positions = num_patches + 1\n        self.pos_embed = nn.Parameter(torch.zeros(1, num_positions, patch_embed_dim))\n        self.blocks = nn.ModuleList()\n        for i in range(depth):\n            vit_block = Block(patch_embed_dim, num_heads, mlp_ratio, True)\n            self.blocks.append(vit_block)\n        self.neck = nn.Sequential(\n            nn.Conv2d(\n                patch_embed_dim,\n                neck_dims[0],\n                kernel_size=1,\n                bias=False,\n            ),\n            LayerNorm2d(neck_dims[0]),\n            nn.Conv2d(\n                neck_dims[0],\n                neck_dims[0],\n                kernel_size=3,\n                padding=1,\n                bias=False,\n            ),\n            LayerNorm2d(neck_dims[0]),\n        )\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        assert (\n            x.shape[2] == self.img_size and x.shape[3] == self.img_size\n        ), \"input image size must match self.img_size\"\n        x = self.patch_embed(x)\n        # B C H W -> B H W C\n        x = x.permute(0, 2, 3, 1)\n        x = x + get_abs_pos(\n            self.pos_embed, self.pretrain_use_cls_token, [x.shape[1], x.shape[2]]\n        )\n        num_patches = x.shape[1]\n        assert x.shape[2] == num_patches\n        x = x.reshape(x.shape[0], num_patches * num_patches, x.shape[3])\n        for blk in self.blocks:\n            x = blk(x)\n        x = x.reshape(x.shape[0], num_patches, num_patches, x.shape[2])\n        x = self.neck(x.permute(0, 3, 1, 2))\n        return x\n"}
{"type": "source_file", "path": "model/EfficientSAM/efficient_sam/__init__.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\nfrom .build_efficient_sam import (\n    build_efficient_sam_vitt,\n    build_efficient_sam_vits,\n)\n"}
{"type": "source_file", "path": "demo_video.py", "content": "import sys\nimport time\nimport os\nimport gradio as gr\nimport torch\nimport numpy as np\nimport cv2\nfrom tqdm import tqdm\nfrom transformers import AutoTokenizer\nfrom inference import beit3_preprocess\n\nversion = sys.argv[1]\ntokenizer = AutoTokenizer.from_pretrained(\n        version,\n        padding_side=\"right\",\n        use_fast=False,\n    )\n\nfrom model.evf_sam2_video import EvfSam2Model\nkwargs = {\n    \"torch_dtype\": torch.half,\n}\nmodel = EvfSam2Model.from_pretrained(version, low_cpu_mem_usage=True, **kwargs).cuda().eval()\n\nfourcc = cv2.VideoWriter_fourcc(*'mp4v')\n\n@torch.no_grad()\ndef pred(video_path, prompt, semantic_type):\n    # end = time.time()\n    torch.autocast(device_type=\"cuda\", dtype=torch.float16).__enter__()\n    if torch.cuda.get_device_properties(0).major >= 8:\n        # turn on tfloat32 for Ampere GPUs (https://pytorch.org/docs/stable/notes/cuda.html#tensorfloat-32-tf32-on-ampere-devices)\n        torch.backends.cuda.matmul.allow_tf32 = True\n        torch.backends.cudnn.allow_tf32 = True\n    os.system(\"rm -rf demo_temp\")\n    os.makedirs(\"demo_temp/input_frames\", exist_ok=True)\n    os.system(\"ffmpeg -i {} -q:v 2 -start_number 0 demo_temp/input_frames/'%05d.jpg'\".format(video_path))\n    input_frames = sorted(os.listdir(\"demo_temp/input_frames\"))\n    image_np = cv2.imread(\"demo_temp/input_frames/00000.jpg\")\n    image_np = cv2.cvtColor(image_np, cv2.COLOR_BGR2RGB)\n\n    height, width, channels = image_np.shape\n\n    image_beit = beit3_preprocess(image_np, 224).to(dtype=model.dtype, device=model.device)\n\n    if semantic_type:\n        prompt = \"[semantic] \" + prompt\n    input_ids = tokenizer(prompt, return_tensors=\"pt\")[\"input_ids\"].to(device=model.device)\n\n    # infer\n    output = model.inference(\n        \"demo_temp/input_frames\",\n        image_beit.unsqueeze(0),\n        input_ids,\n    )\n    # save visualization\n    video_writer = cv2.VideoWriter(\"demo_temp/out.mp4\", fourcc, 30, (width,height))\n    pbar = tqdm(input_frames)\n    pbar.set_description(\"generating video: \")\n    for i, file in enumerate(pbar):\n        img = cv2.imread(os.path.join(\"demo_temp/input_frames\", file))\n        vis = img + np.array([0, 0, 128]) * output[i][1].transpose(1,2,0)\n        vis = np.clip(vis, 0, 255)\n        vis = np.uint8(vis)\n        video_writer.write(vis)\n    video_writer.release()\n    return \"demo_temp/out.mp4\"\n    \n    # print(time.time() - end)\n\ndemo = gr.Interface(\n    fn=pred,\n    inputs=[\n        gr.components.Video(label=\"Input video\"), \n        gr.components.Textbox(label=\"Prompt\", info=\"Use a phrase or sentence to describe the object you want to segment. Currently we only support English\"),\n        gr.components.Checkbox(False, label=\"semantic level\", info=\"check this if you want to segment body parts or background or multi objects (only available with latest evf-sam checkpoint)\")],\n    outputs=[\n        gr.components.Video(label=\"Output video\")],\n    title=\"EVF-SAM2 referring expression segmentation\",\n    description=\"Please don't upload long video. It takes about 1 min to process 150 frames.\",\n    allow_flagging=\"never\"\n)\ndemo.launch()\n# demo.launch(\n#     share=False,\n#     server_name=\"0.0.0.0\",\n#     server_port=10001\n# )\n"}
{"type": "source_file", "path": "model/segment_anything/__init__.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom .automatic_mask_generator import SamAutomaticMaskGenerator\nfrom .build_sam import (build_sam, build_sam_vit_b, build_sam_vit_h,\n                        build_sam_vit_l, sam_model_registry)\nfrom .predictor import SamPredictor\n"}
{"type": "source_file", "path": "model/EfficientSAM/efficient_sam/mlp.py", "content": "from typing import Type\n\nfrom torch import nn\n\n\n# Lightly adapted from\n# https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py # noqa\nclass MLPBlock(nn.Module):\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,\n        num_layers: int,\n        act: Type[nn.Module],\n    ) -> None:\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(\n            nn.Sequential(nn.Linear(n, k), act())\n            for n, k in zip([input_dim] + h, [hidden_dim] * num_layers)\n        )\n        self.fc = nn.Linear(hidden_dim, output_dim)\n\n    def forward(self, x):\n        for layer in self.layers:\n            x = layer(x)\n        return self.fc(x)\n"}
{"type": "source_file", "path": "model/evf_sam.py", "content": "from typing import List\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom transformers import PreTrainedModel, AutoConfig, AutoModelForCausalLM\nfrom .segment_anything import build_sam_vit_h\nfrom .unilm.beit3.modeling_utils import BEiT3Wrapper, _get_base_config, _get_large_config\nfrom .configuration_evf import EvfConfig\n\ndef dice_loss(\n    inputs: torch.Tensor,\n    targets: torch.Tensor,\n    num_masks: float,\n    scale=1000,  # 100000.0,\n    eps=1e-6,\n):\n    \"\"\"\n    Compute the DICE loss, similar to generalized IOU for masks\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    \"\"\"\n    inputs = inputs.sigmoid()\n    inputs = inputs.flatten(1, 2)\n    targets = targets.flatten(1, 2)\n    numerator = 2 * (inputs / scale * targets).sum(-1)\n    denominator = (inputs / scale).sum(-1) + (targets / scale).sum(-1)\n    loss = 1 - (numerator + eps) / (denominator + eps)\n    loss = loss.sum() / (num_masks + 1e-8)\n    return loss\n\n\ndef sigmoid_ce_loss(\n    inputs: torch.Tensor,\n    targets: torch.Tensor,\n    num_masks: float,\n):\n    \"\"\"\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    Returns:\n        Loss tensor\n    \"\"\"\n    loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction=\"none\")\n    loss = loss.flatten(1, 2).mean(1).sum() / (num_masks + 1e-8)\n    return loss\n\n\n\nclass EvfSamModel(PreTrainedModel):\n    config_class = EvfConfig\n    def __init__(\n        self,\n        config,\n        **kwargs\n    ):\n        super(EvfSamModel, self).__init__(config)\n\n        self.config = config\n        self.vision_pretrained = kwargs.get(\"vision_pretrained\", None)\n        self.encoder_pretrained = kwargs.get(\"encoder_pretrained\", None)\n        self.dice_loss_weight = kwargs.get(\"dice_loss_weight\", None)\n        self.bce_loss_weight = kwargs.get(\"bce_loss_weight\", None)\n        self.train_mask_decoder = kwargs.get(\"train_mask_decoder\", False)\n        self.train_prompt_encoder = kwargs.get(\"train_prompt_encoder\", False)\n        self.initialize_evf_modules(config)\n\n\n    def initialize_evf_modules(self, config):\n        # SAM\n        if config.sam_scale==\"huge\":\n            self.visual_model = build_sam_vit_h(self.vision_pretrained)\n        else:\n            raise NotImplementedError\n        \n        for param in self.visual_model.parameters():\n            param.requires_grad = False\n        if self.train_mask_decoder:\n            self.visual_model.mask_decoder.train()\n            for param in self.visual_model.mask_decoder.parameters():\n                param.requires_grad = True\n        if self.train_prompt_encoder:\n            self.visual_model.prompt_encoder.no_mask_embed.requires_grad_(True)\n            \n        # beit-3\n        if self.config.mm_extractor_scale == \"base\":\n            beit_config = _get_base_config()\n        elif self.config.mm_extractor_scale == \"large\":\n            beit_config = _get_large_config()\n        else:\n            raise AttributeError(f\"model config should contain key 'mm_extractor_scale', with value 'base' or 'large'.\")\n\n        self.mm_extractor = BEiT3Wrapper(beit_config)\n        if self.encoder_pretrained is not None:\n            beit_state_dict = torch.load(self.encoder_pretrained)[\"model\"]\n            self.mm_extractor.load_state_dict(\n                beit_state_dict, \n                strict=False\n            )\n\n        for param in self.mm_extractor.parameters():\n            param.requires_grad = True\n                \n        # Projection layer\n        in_dim = config.hidden_size\n        assert in_dim==beit_config.encoder_embed_dim, \\\n            f\"projection layer dim {in_dim} mismatch with mm_extractor dim {beit_config.encoder_embed_dim}\"\n        out_dim = config.out_dim\n        text_fc = [\n            nn.Linear(in_dim, in_dim),\n            nn.ReLU(),\n            nn.Linear(in_dim, out_dim)\n        ]\n        self.text_hidden_fcs = nn.ModuleList([nn.Sequential(*text_fc)])\n        self.text_hidden_fcs.train()\n        for param in self.text_hidden_fcs.parameters():\n            param.requires_grad = True\n\n    def get_visual_embs(self, pixel_values: torch.FloatTensor):\n        with torch.no_grad():\n            image_embeddings_list = []\n            for i in range(pixel_values.shape[0]):\n                torch.cuda.empty_cache()\n                image_embeddings = self.visual_model.image_encoder(\n                    pixel_values[i].unsqueeze(0)\n                )\n                image_embeddings_list.append(image_embeddings)\n            torch.cuda.empty_cache()\n            image_embeddings = torch.cat(image_embeddings_list, 0)\n        return image_embeddings\n\n    def forward(\n        self,\n        images: torch.FloatTensor,\n        images_evf: torch.FloatTensor,\n        input_ids: torch.LongTensor,\n        attention_masks: torch.LongTensor,\n        offset: torch.LongTensor,\n        masks_list: List[torch.FloatTensor],\n        label_list: List[torch.Tensor],\n        resize_list: List[tuple],\n        inference: bool = False,\n        **kwargs,\n    ):\n        image_embeddings = self.get_visual_embs(images)\n        batch_size = image_embeddings.shape[0]\n        assert batch_size == len(offset) - 1\n\n        images_evf_list = []\n        for i in range(len(offset) - 1):\n            start_i, end_i = offset[i], offset[i + 1]\n            images_evf_i = (\n                images_evf[i]\n                .unsqueeze(0)\n                .expand(end_i - start_i, -1, -1, -1)\n                .contiguous()\n            )\n            images_evf_list.append(images_evf_i)\n        images_evf = torch.cat(images_evf_list, dim=0)\n\n        multimask_output = False\n        output = self.mm_extractor.beit3(\n            visual_tokens=images_evf, \n            textual_tokens=input_ids, \n            text_padding_position=~attention_masks\n            )\n\n        feat = output[\"encoder_out\"][:, :1, ...]\n\n        feat = self.text_hidden_fcs[0](feat)\n        feat = torch.split(feat, [offset[i+1] - offset[i] for i in range(len(offset)-1)])\n\n        pred_masks = []\n        for i in range(len(feat)):\n            (\n                sparse_embeddings,\n                dense_embeddings,\n            ) = self.visual_model.prompt_encoder(\n                points=None,\n                boxes=None,\n                masks=None,\n                text_embeds=feat[i],\n            )\n            sparse_embeddings = sparse_embeddings.to(feat[i].dtype)\n            low_res_masks, iou_predictions = self.visual_model.mask_decoder(\n                image_embeddings=image_embeddings[i].unsqueeze(0),\n                image_pe=self.visual_model.prompt_encoder.get_dense_pe(),\n                sparse_prompt_embeddings=sparse_embeddings,\n                dense_prompt_embeddings=dense_embeddings,\n                multimask_output=multimask_output,\n            )\n\n            if multimask_output:\n                sorted_ids = torch.argsort(iou_predictions, dim=-1, descending=True)\n                low_res_masks = torch.take_along_dim(low_res_masks, sorted_ids[..., None, None], dim=1)[:, :1]\n          \n            pred_mask = self.visual_model.postprocess_masks(\n                low_res_masks,\n                input_size=resize_list[i],\n                original_size=label_list[i].shape,\n            )\n            pred_masks.append(pred_mask[:, 0])\n\n        gt_masks = masks_list\n\n        if inference:\n            return {\n                \"pred_masks\": pred_masks,\n                \"gt_masks\": gt_masks,\n            }\n\n        mask_bce_loss = 0\n        mask_dice_loss = 0\n        num_masks = 0\n        for batch_idx in range(len(pred_masks)):\n            gt_mask = gt_masks[batch_idx]\n            pred_mask = pred_masks[batch_idx]\n\n            assert (\n                gt_mask.shape[0] == pred_mask.shape[0]\n            ), \"gt_mask.shape: {}, pred_mask.shape: {}\".format(\n                gt_mask.shape, pred_mask.shape\n            )\n            mask_bce_loss += (\n                sigmoid_ce_loss(pred_mask, gt_mask, num_masks=gt_mask.shape[0])\n                * gt_mask.shape[0]\n            )\n            mask_dice_loss += (\n                dice_loss(pred_mask, gt_mask, num_masks=gt_mask.shape[0])\n                * gt_mask.shape[0]\n            )\n            num_masks += gt_mask.shape[0]\n\n        mask_bce_loss = self.bce_loss_weight * mask_bce_loss / (num_masks + 1e-8)\n        mask_dice_loss = self.dice_loss_weight * mask_dice_loss / (num_masks + 1e-8)\n        mask_loss = mask_bce_loss + mask_dice_loss\n\n        loss = mask_loss\n\n        return {\n            \"loss\": loss,\n            \"mask_bce_loss\": mask_bce_loss,\n            \"mask_dice_loss\": mask_dice_loss,\n            \"mask_loss\": mask_loss,\n        }\n    \n    def inference(\n            self,\n            images,\n            images_evf,\n            input_ids,\n            resize_list,\n            original_size_list,\n            multimask_output=False,\n        ):\n        with torch.no_grad():\n            image_embeddings = self.visual_model.image_encoder(images)\n        multimask_output = multimask_output\n\n        output = self.mm_extractor.beit3(visual_tokens=images_evf, textual_tokens=input_ids, text_padding_position=torch.zeros_like(input_ids))\n\n        feat = output[\"encoder_out\"][:, :1, ...]\n        feat = self.text_hidden_fcs[0](feat)\n        (\n            sparse_embeddings,\n            dense_embeddings,\n        ) = self.visual_model.prompt_encoder(\n            points=None,\n            boxes=None,\n            masks=None,\n            text_embeds=feat,\n        )\n        sparse_embeddings = sparse_embeddings.to(feat.dtype)\n        low_res_masks, iou_predictions = self.visual_model.mask_decoder(\n            image_embeddings=image_embeddings,\n            image_pe=self.visual_model.prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            dense_prompt_embeddings=dense_embeddings,\n            multimask_output=multimask_output,\n        )\n        if multimask_output:\n            sorted_ids = torch.argsort(iou_predictions, dim=-1, descending=True)\n            low_res_masks = torch.take_along_dim(low_res_masks, sorted_ids[..., None, None], dim=1)[:, :1]\n\n        pred_mask = self.visual_model.postprocess_masks(\n            low_res_masks,\n            input_size=resize_list[0],\n            original_size=original_size_list[0],\n        )\n\n        return pred_mask[:, 0]\n\n\nAutoConfig.register(\"evf\", EvfConfig)\nAutoModelForCausalLM.register(EvfConfig, EvfSamModel)"}
{"type": "source_file", "path": "model/segment_anything/modeling/mask_decoder.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import List, Tuple, Type\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nfrom .common import LayerNorm2d\n\n\nclass MaskDecoder(nn.Module):\n    def __init__(\n        self,\n        *,\n        transformer_dim: int,\n        transformer: nn.Module,\n        num_multimask_outputs: int = 3,\n        activation: Type[nn.Module] = nn.GELU,\n        iou_head_depth: int = 3,\n        iou_head_hidden_dim: int = 256,\n    ) -> None:\n        \"\"\"\n        Predicts masks given an image and prompt embeddings, using a\n        transformer architecture.\n\n        Arguments:\n          transformer_dim (int): the channel dimension of the transformer\n          transformer (nn.Module): the transformer used to predict masks\n          num_multimask_outputs (int): the number of masks to predict\n            when disambiguating masks\n          activation (nn.Module): the type of activation to use when\n            upscaling masks\n          iou_head_depth (int): the depth of the MLP used to predict\n            mask quality\n          iou_head_hidden_dim (int): the hidden dimension of the MLP\n            used to predict mask quality\n        \"\"\"\n        super().__init__()\n        self.transformer_dim = transformer_dim\n        self.transformer = transformer\n\n        self.num_multimask_outputs = num_multimask_outputs\n\n        self.iou_token = nn.Embedding(1, transformer_dim)\n        self.num_mask_tokens = num_multimask_outputs + 1\n        self.mask_tokens = nn.Embedding(self.num_mask_tokens, transformer_dim)\n\n        self.output_upscaling = nn.Sequential(\n            nn.ConvTranspose2d(\n                transformer_dim, transformer_dim // 4, kernel_size=2, stride=2\n            ),\n            LayerNorm2d(transformer_dim // 4),\n            activation(),\n            nn.ConvTranspose2d(\n                transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2\n            ),\n            activation(),\n        )\n        self.output_hypernetworks_mlps = nn.ModuleList(\n            [\n                MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3)\n                for i in range(self.num_mask_tokens)\n            ]\n        )\n\n        self.iou_prediction_head = MLP(\n            transformer_dim, iou_head_hidden_dim, self.num_mask_tokens, iou_head_depth\n        )\n\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        multimask_output: bool,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks given image and prompt embeddings.\n\n        Arguments:\n          image_embeddings (torch.Tensor): the embeddings from the image encoder\n          image_pe (torch.Tensor): positional encoding with the shape of image_embeddings\n          sparse_prompt_embeddings (torch.Tensor): the embeddings of the points and boxes\n          dense_prompt_embeddings (torch.Tensor): the embeddings of the mask inputs\n          multimask_output (bool): Whether to return multiple masks or a single\n            mask.\n\n        Returns:\n          torch.Tensor: batched predicted masks\n          torch.Tensor: batched predictions of mask quality\n        \"\"\"\n        masks, iou_pred = self.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=image_pe,\n            sparse_prompt_embeddings=sparse_prompt_embeddings,\n            dense_prompt_embeddings=dense_prompt_embeddings,\n        )\n\n        # Select the correct mask or masks for output\n        if multimask_output:\n            mask_slice = slice(1, None)\n        else:\n            mask_slice = slice(0, 1)\n        masks = masks[:, mask_slice, :, :]\n        iou_pred = iou_pred[:, mask_slice]\n\n        # Prepare output\n        return masks, iou_pred\n\n    def predict_masks(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"Predicts masks. See 'forward' for more details.\"\"\"\n        # Concatenate output tokens\n        output_tokens = torch.cat(\n            [self.iou_token.weight, self.mask_tokens.weight], dim=0\n        )\n        output_tokens = output_tokens.unsqueeze(0).expand(\n            sparse_prompt_embeddings.size(0), -1, -1\n        )\n\n        tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)\n\n        # image_embeddings: [1, C, H, W], tokens: [B, N, C]\n        # dense_prompt_embeddings: [B, C, H, W]\n        # Expand per-image data in batch direction to be per-mask\n        src = torch.repeat_interleave(image_embeddings, tokens.shape[0], dim=0)\n        src = src + dense_prompt_embeddings\n        pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)\n        b, c, h, w = src.shape\n\n        # Run the transformer\n        hs, src = self.transformer(src, pos_src, tokens)\n        iou_token_out = hs[:, 0, :]\n        mask_tokens_out = hs[:, 1 : (1 + self.num_mask_tokens), :]\n\n        # Upscale mask embeddings and predict masks using the mask tokens\n        src = src.transpose(1, 2).view(b, c, h, w)\n        upscaled_embedding = self.output_upscaling(src)\n        hyper_in_list: List[torch.Tensor] = []\n        for i in range(self.num_mask_tokens):\n            hyper_in_list.append(\n                self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :])\n            )\n        hyper_in = torch.stack(hyper_in_list, dim=1)\n        b, c, h, w = upscaled_embedding.shape\n        masks = (hyper_in @ upscaled_embedding.view(b, c, h * w)).view(\n            b, self.num_mask_tokens, h, w\n        )\n\n        # Generate mask quality predictions\n        iou_pred = self.iou_prediction_head(iou_token_out)\n\n        return masks, iou_pred\n\n\n# Lightly adapted from\n# https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py # noqa\nclass MLP(nn.Module):\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,\n        num_layers: int,\n        sigmoid_output: bool = False,\n    ) -> None:\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(\n            nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim])\n        )\n        self.sigmoid_output = sigmoid_output\n\n    def forward(self, x):\n        for i, layer in enumerate(self.layers):\n            x = F.relu(layer(x)) if i < self.num_layers - 1 else layer(x)\n        if self.sigmoid_output:\n            x = F.sigmoid(x)\n        return x\n"}
{"type": "source_file", "path": "model/evf_effisam.py", "content": "from typing import List, Tuple\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom transformers import PreTrainedModel, AutoConfig, AutoModelForCausalLM\nfrom .EfficientSAM.efficient_sam.build_efficient_sam import build_efficient_sam_vits, build_efficient_sam_vitt\nfrom .unilm.beit3.modeling_utils import BEiT3Wrapper, _get_base_config, _get_large_config\nfrom .configuration_evf import EvfConfig\n\n\ndef dice_loss(\n    inputs: torch.Tensor,\n    targets: torch.Tensor,\n    num_masks: float,\n    scale=1000,  # 100000.0,\n    eps=1e-6,\n):\n    \"\"\"\n    Compute the DICE loss, similar to generalized IOU for masks\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    \"\"\"\n    inputs = inputs.sigmoid()\n    inputs = inputs.flatten(1, 2)\n    targets = targets.flatten(1, 2)\n    numerator = 2 * (inputs / scale * targets).sum(-1)\n    denominator = (inputs / scale).sum(-1) + (targets / scale).sum(-1)\n    loss = 1 - (numerator + eps) / (denominator + eps)\n    loss = loss.sum() / (num_masks + 1e-8)\n    return loss\n\n\ndef sigmoid_ce_loss(\n    inputs: torch.Tensor,\n    targets: torch.Tensor,\n    num_masks: float,\n):\n    \"\"\"\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    Returns:\n        Loss tensor\n    \"\"\"\n    loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction=\"none\")\n    loss = loss.flatten(1, 2).mean(1).sum() / (num_masks + 1e-8)\n    return loss\n\n\n\nclass EvfEffiSamModel(PreTrainedModel):\n    config_class = EvfConfig\n    def __init__(\n        self,\n        config,\n        **kwargs\n    ):\n        super(EvfEffiSamModel, self).__init__(config)\n\n        self.config = config\n        self.vision_pretrained = kwargs.get(\"vision_pretrained\", None)\n        self.encoder_pretrained = kwargs.get(\"encoder_pretrained\", None)\n        self.dice_loss_weight = kwargs.get(\"dice_loss_weight\", None)\n        self.bce_loss_weight = kwargs.get(\"bce_loss_weight\", None)\n        self.train_mask_decoder = kwargs.get(\"train_mask_decoder\", False)\n        self.initialize_evf_modules(config)\n\n\n    def initialize_evf_modules(self, config):\n        # EffiSAM\n        if config.sam_scale==\"tiny\":\n            self.visual_model = build_efficient_sam_vitt(self.vision_pretrained)\n        elif config.sam_scale==\"small\":\n            # vits scale, or without pretrained weight (self.vision_pretrained=None)\n            self.visual_model = build_efficient_sam_vits(self.vision_pretrained)\n        else: \n            raise NotImplementedError\n        \n        for param in self.visual_model.parameters():\n            param.requires_grad = False\n        if self.train_mask_decoder:\n            self.visual_model.mask_decoder.train()\n            for param in self.visual_model.mask_decoder.parameters():\n                param.requires_grad = True\n\n        # beit-3\n        if self.config.mm_extractor_scale == \"base\":\n            beit_config = _get_base_config()\n        elif self.config.mm_extractor_scale == \"large\":\n            beit_config = _get_large_config()\n        else:\n            raise AttributeError(f\"model config should contain key 'mm_extractor_scale', with value 'base' or 'large'.\")\n\n        self.mm_extractor = BEiT3Wrapper(beit_config)\n        if self.encoder_pretrained is not None:\n            beit_state_dict = torch.load(self.encoder_pretrained)[\"model\"]\n            self.mm_extractor.load_state_dict(\n                beit_state_dict, \n                strict=False\n            )\n\n        for param in self.mm_extractor.parameters():\n            param.requires_grad = True\n                \n        # Projection layer\n        in_dim = config.hidden_size\n        assert in_dim==beit_config.encoder_embed_dim, \\\n            f\"projection layer dim {in_dim} mismatch with mm_extractor dim {beit_config.encoder_embed_dim}\"\n        out_dim = config.out_dim\n        text_fc = [\n            nn.Linear(in_dim, in_dim),\n            nn.ReLU(),\n            nn.Linear(in_dim, out_dim)\n        ]\n        self.text_hidden_fcs = nn.ModuleList([nn.Sequential(*text_fc)])\n        self.text_hidden_fcs.train()\n        for param in self.text_hidden_fcs.parameters():\n            param.requires_grad = True\n\n    def get_visual_embs(self, pixel_values: torch.Tensor):\n        with torch.no_grad():\n            image_embeddings_list = []\n            for i in range(pixel_values.shape[0]):\n                torch.cuda.empty_cache()\n                image_embeddings = self.visual_model.image_encoder(\n                    pixel_values[i].unsqueeze(0)\n                )\n                image_embeddings_list.append(image_embeddings)\n            torch.cuda.empty_cache()\n            image_embeddings = torch.cat(image_embeddings_list, 0)\n        return image_embeddings\n\n    def forward(\n        self,\n        images: torch.Tensor,\n        images_evf: torch.Tensor,\n        input_ids: torch.Tensor,\n        attention_masks: torch.Tensor,\n        offset: torch.Tensor,\n        masks_list: List[torch.Tensor],\n        label_list: List[torch.Tensor],\n        resize_list: List[tuple],\n        inference: bool = False,\n        **kwargs,\n    ):\n        image_embeddings = self.get_visual_embs(images)\n        batch_size = image_embeddings.shape[0]\n        assert batch_size == len(offset) - 1\n\n        images_evf_list = []\n        for i in range(len(offset) - 1):\n            start_i, end_i = offset[i], offset[i + 1]\n            images_evf_i = (\n                images_evf[i]\n                .unsqueeze(0)\n                .expand(end_i - start_i, -1, -1, -1)\n                .contiguous()\n            )\n            images_evf_list.append(images_evf_i)\n        images_evf = torch.cat(images_evf_list, dim=0)\n\n        multimask_output = False\n        output = self.mm_extractor.beit3(\n            visual_tokens=images_evf, \n            textual_tokens=input_ids, \n            text_padding_position=~attention_masks\n            )\n\n        feat = output[\"encoder_out\"][:, :1, ...]\n\n        feat = self.text_hidden_fcs[0](feat)\n        feat = torch.split(feat, [offset[i+1] - offset[i] for i in range(len(offset)-1)])\n\n        pred_masks = []\n        for i in range(len(feat)):\n            sparse_embeddings = feat[i].unsqueeze(0)\n            sparse_embeddings = sparse_embeddings.to(feat[i].dtype)\n            low_res_masks, iou_predictions = self.visual_model.mask_decoder(\n                image_embeddings=image_embeddings[i].unsqueeze(0),\n                image_pe=self.visual_model.prompt_encoder.get_dense_pe(),\n                sparse_prompt_embeddings=sparse_embeddings,\n                multimask_output=multimask_output,\n            )\n\n            if multimask_output:\n                sorted_ids = torch.argsort(iou_predictions, dim=-1, descending=True)\n                low_res_masks = torch.take_along_dim(low_res_masks, sorted_ids[..., None, None], dim=1)\n          \n            pred_mask = self.postprocess_masks(\n                low_res_masks[:, :1],\n                input_size=resize_list[i],\n                original_size=label_list[i].shape,\n            )\n            pred_masks.append(pred_mask[:, 0])\n\n        gt_masks = masks_list\n\n        if inference:\n            return {\n                \"pred_masks\": pred_masks,\n                \"gt_masks\": gt_masks,\n            }\n\n        mask_bce_loss = 0\n        mask_dice_loss = 0\n        num_masks = 0\n        for batch_idx in range(len(pred_masks)):\n            gt_mask = gt_masks[batch_idx]\n            pred_mask = pred_masks[batch_idx]\n\n            assert (\n                gt_mask.shape[0] == pred_mask.shape[0]\n            ), \"gt_mask.shape: {}, pred_mask.shape: {}\".format(\n                gt_mask.shape, pred_mask.shape\n            )\n            mask_bce_loss += (\n                sigmoid_ce_loss(pred_mask, gt_mask, num_masks=gt_mask.shape[0])\n                * gt_mask.shape[0]\n            )\n            mask_dice_loss += (\n                dice_loss(pred_mask, gt_mask, num_masks=gt_mask.shape[0])\n                * gt_mask.shape[0]\n            )\n            num_masks += gt_mask.shape[0]\n\n        mask_bce_loss = self.bce_loss_weight * mask_bce_loss / (num_masks + 1e-8)\n        mask_dice_loss = self.dice_loss_weight * mask_dice_loss / (num_masks + 1e-8)\n        mask_loss = mask_bce_loss + mask_dice_loss\n\n        loss = mask_loss\n\n        return {\n            \"loss\": loss,\n            \"mask_bce_loss\": mask_bce_loss,\n            \"mask_dice_loss\": mask_dice_loss,\n            \"mask_loss\": mask_loss,\n        }\n    \n    def postprocess_masks(\n        self,\n        masks: torch.Tensor,\n        input_size: Tuple[int, ...],\n        original_size: Tuple[int, ...],\n    ) -> torch.Tensor:\n        \"\"\"\n        pre-process of Effi-SAM is different from SAM, where there is no padding,\n        so cropping is not needed in post-process.\n        \"\"\"\n\n        dtype = masks.dtype\n\n        # masks = F.interpolate(\n        #     masks.float(),\n        #     (1024, 1024),\n        #     mode=\"bilinear\",\n        #     align_corners=False,\n        # )\n        # masks = masks.to(dtype)\n        # masks = masks[..., : input_size[0], : input_size[1]]\n\n        masks = F.interpolate(\n            masks, original_size, mode=\"bilinear\", align_corners=False\n        )\n        masks = masks.to(dtype)\n        return masks\n    \n    def inference(\n            self,\n            images,\n            images_evf,\n            input_ids,\n            resize_list,\n            original_size_list,\n            multimask_output=False,\n        ):\n        with torch.no_grad():\n            image_embeddings = self.visual_model.image_encoder(images)\n\n        output = self.mm_extractor.beit3(visual_tokens=images_evf, textual_tokens=input_ids, text_padding_position=torch.zeros_like(input_ids))\n\n        feat = output[\"encoder_out\"][:, :1, ...]\n        feat = self.text_hidden_fcs[0](feat)\n        sparse_embeddings = feat.unsqueeze(0)\n        sparse_embeddings = sparse_embeddings.to(feat.dtype)\n        low_res_masks, iou_predictions = self.visual_model.mask_decoder(\n            image_embeddings=image_embeddings,\n            image_pe=self.visual_model.prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            multimask_output=multimask_output,\n        )\n        if multimask_output:\n            sorted_ids = torch.argsort(iou_predictions, dim=-1, descending=True)\n            low_res_masks = torch.take_along_dim(low_res_masks, sorted_ids[..., None, None], dim=1)\n        \n        pred_mask = self.postprocess_masks(\n            low_res_masks[:, :1],\n            input_size=resize_list[0],\n            original_size=original_size_list[0],\n        )\n\n        return pred_mask[:, 0]\n\n\nAutoConfig.register(\"evf\", EvfConfig)\nAutoModelForCausalLM.register(EvfConfig, EvfEffiSamModel)\n"}
{"type": "source_file", "path": "model/segment_anything/utils/__init__.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n"}
{"type": "source_file", "path": "model/segment_anything/build_sam.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom functools import partial\n\nimport torch\n\nfrom .modeling import (ImageEncoderViT, MaskDecoder, PromptEncoder, Sam,\n                       TwoWayTransformer)\n\n\ndef build_sam_vit_h(checkpoint=None):\n    return _build_sam(\n        encoder_embed_dim=1280,\n        encoder_depth=32,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[7, 15, 23, 31],\n        checkpoint=checkpoint,\n    )\n\n\nbuild_sam = build_sam_vit_h\n\n\ndef build_sam_vit_l(checkpoint=None):\n    return _build_sam(\n        encoder_embed_dim=1024,\n        encoder_depth=24,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[5, 11, 17, 23],\n        checkpoint=checkpoint,\n    )\n\n\ndef build_sam_vit_b(checkpoint=None):\n    return _build_sam(\n        encoder_embed_dim=768,\n        encoder_depth=12,\n        encoder_num_heads=12,\n        encoder_global_attn_indexes=[2, 5, 8, 11],\n        checkpoint=checkpoint,\n    )\n\n\nsam_model_registry = {\n    \"default\": build_sam_vit_h,\n    \"vit_h\": build_sam_vit_h,\n    \"vit_l\": build_sam_vit_l,\n    \"vit_b\": build_sam_vit_b,\n}\n\n\ndef _build_sam(\n    encoder_embed_dim,\n    encoder_depth,\n    encoder_num_heads,\n    encoder_global_attn_indexes,\n    checkpoint=None,\n):\n    prompt_embed_dim = 256\n    image_size = 1024\n    vit_patch_size = 16\n    image_embedding_size = image_size // vit_patch_size\n    sam = Sam(\n        image_encoder=ImageEncoderViT(\n            depth=encoder_depth,\n            embed_dim=encoder_embed_dim,\n            img_size=image_size,\n            mlp_ratio=4,\n            norm_layer=partial(torch.nn.LayerNorm, eps=1e-6),\n            num_heads=encoder_num_heads,\n            patch_size=vit_patch_size,\n            qkv_bias=True,\n            use_rel_pos=True,\n            global_attn_indexes=encoder_global_attn_indexes,\n            window_size=14,\n            out_chans=prompt_embed_dim,\n        ),\n        prompt_encoder=PromptEncoder(\n            embed_dim=prompt_embed_dim,\n            image_embedding_size=(image_embedding_size, image_embedding_size),\n            input_image_size=(image_size, image_size),\n            mask_in_chans=16,\n        ),\n        mask_decoder=MaskDecoder(\n            num_multimask_outputs=3,\n            transformer=TwoWayTransformer(\n                depth=2,\n                embedding_dim=prompt_embed_dim,\n                mlp_dim=2048,\n                num_heads=8,\n            ),\n            transformer_dim=prompt_embed_dim,\n            iou_head_depth=3,\n            iou_head_hidden_dim=256,\n        ),\n        pixel_mean=[123.675, 116.28, 103.53],\n        pixel_std=[58.395, 57.12, 57.375],\n    )\n    sam.eval()\n    if checkpoint is not None:\n        with open(checkpoint, \"rb\") as f:\n            state_dict = torch.load(f)\n        sam.load_state_dict(state_dict, strict=False)\n    return sam\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/backbones/hieradet.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom functools import partial\nfrom typing import List, Tuple, Union\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom model.segment_anything_2.sam2.modeling.backbones.utils import (\n    PatchEmbed,\n    window_partition,\n    window_unpartition,\n)\n\nfrom model.segment_anything_2.sam2.modeling.sam2_utils import DropPath, MLP\n\n\ndef do_pool(x: torch.Tensor, pool: nn.Module, norm: nn.Module = None) -> torch.Tensor:\n    if pool is None:\n        return x\n    # (B, H, W, C) -> (B, C, H, W)\n    x = x.permute(0, 3, 1, 2)\n    x = pool(x)\n    # (B, C, H', W') -> (B, H', W', C)\n    x = x.permute(0, 2, 3, 1)\n    if norm:\n        x = norm(x)\n\n    return x\n\n\nclass MultiScaleAttention(nn.Module):\n    def __init__(\n        self,\n        dim: int,\n        dim_out: int,\n        num_heads: int,\n        q_pool: nn.Module = None,\n    ):\n        super().__init__()\n\n        self.dim = dim\n        self.dim_out = dim_out\n\n        self.num_heads = num_heads\n        head_dim = dim_out // num_heads\n        self.scale = head_dim**-0.5\n\n        self.q_pool = q_pool\n        self.qkv = nn.Linear(dim, dim_out * 3)\n        self.proj = nn.Linear(dim_out, dim_out)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        B, H, W, _ = x.shape\n        # qkv with shape (B, H * W, 3, nHead, C)\n        qkv = self.qkv(x).reshape(B, H * W, 3, self.num_heads, -1)\n        # q, k, v with shape (B, H * W, nheads, C)\n        q, k, v = torch.unbind(qkv, 2)\n\n        # Q pooling (for downsample at stage changes)\n        if self.q_pool:\n            q = do_pool(q.reshape(B, H, W, -1), self.q_pool)\n            H, W = q.shape[1:3]  # downsampled shape\n            q = q.reshape(B, H * W, self.num_heads, -1)\n\n        # Torch's SDPA expects [B, nheads, H*W, C] so we transpose\n        x = F.scaled_dot_product_attention(\n            q.transpose(1, 2),\n            k.transpose(1, 2),\n            v.transpose(1, 2),\n        )\n        # Transpose back\n        x = x.transpose(1, 2)\n        x = x.reshape(B, H, W, -1)\n\n        x = self.proj(x)\n\n        return x\n\n\nclass MultiScaleBlock(nn.Module):\n    def __init__(\n        self,\n        dim: int,\n        dim_out: int,\n        num_heads: int,\n        mlp_ratio: float = 4.0,\n        drop_path: float = 0.0,\n        norm_layer: Union[nn.Module, str] = \"LayerNorm\",\n        q_stride: Tuple[int, int] = None,\n        act_layer: nn.Module = nn.GELU,\n        window_size: int = 0,\n    ):\n        super().__init__()\n\n        if isinstance(norm_layer, str):\n            norm_layer = partial(getattr(nn, norm_layer), eps=1e-6)\n\n        self.dim = dim\n        self.dim_out = dim_out\n        self.norm1 = norm_layer(dim)\n\n        self.window_size = window_size\n\n        self.pool, self.q_stride = None, q_stride\n        if self.q_stride:\n            self.pool = nn.MaxPool2d(\n                kernel_size=q_stride, stride=q_stride, ceil_mode=False\n            )\n\n        self.attn = MultiScaleAttention(\n            dim,\n            dim_out,\n            num_heads=num_heads,\n            q_pool=self.pool,\n        )\n        self.drop_path = DropPath(drop_path) if drop_path > 0.0 else nn.Identity()\n\n        self.norm2 = norm_layer(dim_out)\n        self.mlp = MLP(\n            dim_out,\n            int(dim_out * mlp_ratio),\n            dim_out,\n            num_layers=2,\n            activation=act_layer,\n        )\n\n        if dim != dim_out:\n            self.proj = nn.Linear(dim, dim_out)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        shortcut = x  # B, H, W, C\n        x = self.norm1(x)\n\n        # Skip connection\n        if self.dim != self.dim_out:\n            shortcut = do_pool(self.proj(x), self.pool)\n\n        # Window partition\n        window_size = self.window_size\n        if window_size > 0:\n            H, W = x.shape[1], x.shape[2]\n            x, pad_hw = window_partition(x, window_size)\n\n        # Window Attention + Q Pooling (if stage change)\n        x = self.attn(x)\n        if self.q_stride:\n            # Shapes have changed due to Q pooling\n            window_size = self.window_size // self.q_stride[0]\n            H, W = shortcut.shape[1:3]\n\n            pad_h = (window_size - H % window_size) % window_size\n            pad_w = (window_size - W % window_size) % window_size\n            pad_hw = (H + pad_h, W + pad_w)\n\n        # Reverse window partition\n        if self.window_size > 0:\n            x = window_unpartition(x, window_size, pad_hw, (H, W))\n\n        x = shortcut + self.drop_path(x)\n        # MLP\n        x = x + self.drop_path(self.mlp(self.norm2(x)))\n        return x\n\n\nclass Hiera(nn.Module):\n    \"\"\"\n    Reference: https://arxiv.org/abs/2306.00989\n    \"\"\"\n\n    def __init__(\n        self,\n        embed_dim: int = 96,  # initial embed dim\n        num_heads: int = 1,  # initial number of heads\n        drop_path_rate: float = 0.0,  # stochastic depth\n        q_pool: int = 3,  # number of q_pool stages\n        q_stride: Tuple[int, int] = (2, 2),  # downsample stride bet. stages\n        stages: Tuple[int, ...] = (2, 3, 16, 3),  # blocks per stage\n        dim_mul: float = 2.0,  # dim_mul factor at stage shift\n        head_mul: float = 2.0,  # head_mul factor at stage shift\n        window_pos_embed_bkg_spatial_size: Tuple[int, int] = (14, 14),\n        # window size per stage, when not using global att.\n        window_spec: Tuple[int, ...] = (\n            8,\n            4,\n            14,\n            7,\n        ),\n        # global attn in these blocks\n        global_att_blocks: Tuple[int, ...] = (\n            12,\n            16,\n            20,\n        ),\n        return_interm_layers=True,  # return feats from every stage\n    ):\n        super().__init__()\n\n        assert len(stages) == len(window_spec)\n        self.window_spec = window_spec\n\n        depth = sum(stages)\n        self.q_stride = q_stride\n        self.stage_ends = [sum(stages[:i]) - 1 for i in range(1, len(stages) + 1)]\n        assert 0 <= q_pool <= len(self.stage_ends[:-1])\n        self.q_pool_blocks = [x + 1 for x in self.stage_ends[:-1]][:q_pool]\n        self.return_interm_layers = return_interm_layers\n\n        self.patch_embed = PatchEmbed(\n            embed_dim=embed_dim,\n        )\n        # Which blocks have global att?\n        self.global_att_blocks = global_att_blocks\n\n        # Windowed positional embedding (https://arxiv.org/abs/2311.05613)\n        self.window_pos_embed_bkg_spatial_size = window_pos_embed_bkg_spatial_size\n        self.pos_embed = nn.Parameter(\n            torch.zeros(1, embed_dim, *self.window_pos_embed_bkg_spatial_size)\n        )\n        self.pos_embed_window = nn.Parameter(\n            torch.zeros(1, embed_dim, self.window_spec[0], self.window_spec[0])\n        )\n\n        dpr = [\n            x.item() for x in torch.linspace(0, drop_path_rate, depth)\n        ]  # stochastic depth decay rule\n\n        cur_stage = 1\n        self.blocks = nn.ModuleList()\n\n        for i in range(depth):\n            dim_out = embed_dim\n            # lags by a block, so first block of\n            # next stage uses an initial window size\n            # of previous stage and final window size of current stage\n            window_size = self.window_spec[cur_stage - 1]\n\n            if self.global_att_blocks is not None:\n                window_size = 0 if i in self.global_att_blocks else window_size\n\n            if i - 1 in self.stage_ends:\n                dim_out = int(embed_dim * dim_mul)\n                num_heads = int(num_heads * head_mul)\n                cur_stage += 1\n\n            block = MultiScaleBlock(\n                dim=embed_dim,\n                dim_out=dim_out,\n                num_heads=num_heads,\n                drop_path=dpr[i],\n                q_stride=self.q_stride if i in self.q_pool_blocks else None,\n                window_size=window_size,\n            )\n\n            embed_dim = dim_out\n            self.blocks.append(block)\n\n        self.channel_list = (\n            [self.blocks[i].dim_out for i in self.stage_ends[::-1]]\n            if return_interm_layers\n            else [self.blocks[-1].dim_out]\n        )\n\n    def _get_pos_embed(self, hw: Tuple[int, int]) -> torch.Tensor:\n        h, w = hw\n        window_embed = self.pos_embed_window\n        pos_embed = F.interpolate(self.pos_embed, size=(h, w), mode=\"bicubic\")\n        pos_embed = pos_embed + window_embed.tile(\n            [x // y for x, y in zip(pos_embed.shape, window_embed.shape)]\n        )\n        pos_embed = pos_embed.permute(0, 2, 3, 1)\n        return pos_embed\n\n    def forward(self, x: torch.Tensor) -> List[torch.Tensor]:\n        x = self.patch_embed(x)\n        # x: (B, H, W, C)\n\n        # Add pos embed\n        x = x + self._get_pos_embed(x.shape[1:3])\n\n        outputs = []\n        for i, blk in enumerate(self.blocks):\n            x = blk(x)\n            if (i == self.stage_ends[-1]) or (\n                i in self.stage_ends and self.return_interm_layers\n            ):\n                feats = x.permute(0, 3, 1, 2)\n                outputs.append(feats)\n\n        return outputs\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/__init__.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nfrom hydra import initialize_config_module\n\ninitialize_config_module(\"model/segment_anything_2/sam2_configs\", version_base=\"1.2\")\n"}
{"type": "source_file", "path": "model/evf_sam2.py", "content": "from typing import List\nimport os\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom transformers import PreTrainedModel, AutoConfig, AutoModelForCausalLM\nfrom .segment_anything_2.sam2.build_sam import build_sam2\nfrom .unilm.beit3.modeling_utils import BEiT3Wrapper, _get_base_config, _get_large_config\nfrom .configuration_evf import EvfConfig\nfrom .segment_anything_2.sam2.utils.misc import load_video_frames\nfrom collections import OrderedDict\n\n\n\ndef dice_loss(\n    inputs: torch.Tensor,\n    targets: torch.Tensor,\n    num_masks: float,\n    scale=1000,  # 100000.0,\n    eps=1e-6,\n):\n    \"\"\"\n    Compute the DICE loss, similar to generalized IOU for masks\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    \"\"\"\n    inputs = inputs.sigmoid()\n    inputs = inputs.flatten(1, 2)\n    targets = targets.flatten(1, 2)\n    numerator = 2 * (inputs / scale * targets).sum(-1)\n    denominator = (inputs / scale).sum(-1) + (targets / scale).sum(-1)\n    loss = 1 - (numerator + eps) / (denominator + eps)\n    loss = loss.sum() / (num_masks + 1e-8)\n    return loss\n\n\ndef sigmoid_ce_loss(\n    inputs: torch.Tensor,\n    targets: torch.Tensor,\n    num_masks: float,\n):\n    \"\"\"\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    Returns:\n        Loss tensor\n    \"\"\"\n    loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction=\"none\")\n    loss = loss.flatten(1, 2).mean(1).sum() / (num_masks + 1e-8)\n    return loss\n\nclass EvfSam2Model(PreTrainedModel):\n    config_class = EvfConfig\n    def __init__(\n        self,\n        config,\n        **kwargs\n    ):\n        super(EvfSam2Model, self).__init__(config)\n\n        self.config = config\n        self.vision_pretrained = kwargs.get(\"vision_pretrained\", None)\n        self.encoder_pretrained = kwargs.get(\"encoder_pretrained\", None)\n        self.dice_loss_weight = kwargs.get(\"dice_loss_weight\", None)\n        self.bce_loss_weight = kwargs.get(\"bce_loss_weight\", None)\n        self.train_mask_decoder = kwargs.get(\"train_mask_decoder\", False)\n        self.train_prompt_encoder = kwargs.get(\"train_prompt_encoder\", False)\n        self.initialize_evf_modules(config)\n        self._bb_feat_sizes = [\n            (256, 256),\n            (128, 128),\n            (64, 64),\n        ]\n\n    def initialize_evf_modules(self, config):\n        # SAM\n        if config.sam_scale==\"large\":\n            self.visual_model = build_sam2(\"sam2_hiera_l.yaml\", self.vision_pretrained, device=None)\n        elif config.sam_scale==\"tiny\":\n            self.visual_model = build_sam2(\"sam2_hiera_t.yaml\", self.vision_pretrained, device=None)\n        else:\n            raise NotImplementedError\n        \n        for param in self.visual_model.parameters():\n            param.requires_grad = False\n        if self.train_mask_decoder:\n            self.visual_model.sam_mask_decoder.train()\n            for param in self.visual_model.mask_decoder.parameters():\n                param.requires_grad = True\n        if self.train_prompt_encoder:\n            self.visual_model.sam_prompt_encoder.no_mask_embed.requires_grad_(True)\n            \n        # beit-3\n        if self.config.mm_extractor_scale == \"base\":\n            beit_config = _get_base_config()\n        elif self.config.mm_extractor_scale == \"large\":\n            beit_config = _get_large_config()\n        else:\n            raise AttributeError(f\"model config should contain key 'mm_extractor_scale', with value 'base' or 'large'.\")\n\n        self.mm_extractor = BEiT3Wrapper(beit_config)\n        if self.encoder_pretrained is not None:\n            beit_state_dict = torch.load(self.encoder_pretrained)[\"model\"]\n            self.mm_extractor.load_state_dict(\n                beit_state_dict, \n                strict=False\n            )\n\n        for param in self.mm_extractor.parameters():\n            param.requires_grad = True\n                \n        # Projection layer\n        in_dim = config.hidden_size\n        assert in_dim==beit_config.encoder_embed_dim, \\\n            f\"projection layer dim {in_dim} mismatch with mm_extractor dim {beit_config.encoder_embed_dim}\"\n        out_dim = config.out_dim\n        text_fc = [\n            nn.Linear(in_dim, in_dim),\n            nn.ReLU(),\n            nn.Linear(in_dim, out_dim)\n        ]\n        self.text_hidden_fcs = nn.ModuleList([nn.Sequential(*text_fc)])\n        self.text_hidden_fcs.train()\n        for param in self.text_hidden_fcs.parameters():\n            param.requires_grad = True\n\n    def postprocess_masks(self, masks: torch.Tensor, orig_hw) -> torch.Tensor:\n        \"\"\"\n        Perform PostProcessing on output masks.\n        \"\"\"\n        masks = masks.float()\n        masks = F.interpolate(masks, orig_hw, mode=\"bilinear\", align_corners=False)\n        return masks\n\n    def forward(\n        self,\n        images: torch.FloatTensor,\n        images_evf: torch.FloatTensor,\n        input_ids: torch.LongTensor,\n        attention_masks: torch.LongTensor,\n        offset: torch.LongTensor,\n        masks_list: List[torch.FloatTensor],\n        label_list: List[torch.Tensor],\n        resize_list: List[tuple],\n        inference: bool = False,\n        **kwargs,\n    ):\n        # image_embeddings = self.get_visual_embs(images)     \n        backbone_out = self.visual_model.forward_image(images)\n        # dict_keys(['vision_features', 'vision_pos_enc', 'backbone_fpn'])\n        _, image_embeddings, _, _ = self.visual_model._prepare_backbone_features(backbone_out)\n        image_embeddings = [_.to(images.dtype) for _ in image_embeddings]\n        batch_size = images.shape[0]\n        if self.visual_model.directly_add_no_mem_embed:\n            image_embeddings[-1] = image_embeddings[-1] + self.visual_model.no_mem_embed\n\n        feats = [\n            feat.permute(1, 2, 0).view(batch_size, -1, *feat_size)\n            for feat, feat_size in zip(image_embeddings[::-1], self._bb_feat_sizes[::-1])\n        ][::-1]\n        _features = {\"image_embed\": feats[-1], \"high_res_feats\": feats[:-1]}\n        \n\n        assert batch_size == len(offset) - 1\n\n        images_evf_list = []\n        for i in range(len(offset) - 1):\n            start_i, end_i = offset[i], offset[i + 1]\n            images_evf_i = (\n                images_evf[i]\n                .unsqueeze(0)\n                .expand(end_i - start_i, -1, -1, -1)\n                .contiguous()\n            )\n            images_evf_list.append(images_evf_i)\n        images_evf = torch.cat(images_evf_list, dim=0)\n\n        multimask_output = True\n        output = self.mm_extractor.beit3(\n            visual_tokens=images_evf, \n            textual_tokens=input_ids, \n            text_padding_position=~attention_masks\n            )\n\n        feat = output[\"encoder_out\"][:, :1, ...]\n\n        feat = self.text_hidden_fcs[0](feat)\n        feat = torch.split(feat, [offset[i+1] - offset[i] for i in range(len(offset)-1)])\n\n        pred_masks = []\n\n        for i in range(len(feat)):\n            (\n                sparse_embeddings,\n                dense_embeddings,\n            ) = self.visual_model.sam_prompt_encoder(\n                points=None,\n                boxes=None,\n                masks=None,\n                text_embeds=feat[i],\n            )\n            sparse_embeddings = sparse_embeddings.to(feat[i].dtype)\n            high_res_features = [\n                feat_level[i].unsqueeze(0)\n                for feat_level in _features[\"high_res_feats\"]\n            ]\n            low_res_masks, iou_predictions, _, _ = self.visual_model.sam_mask_decoder(\n                image_embeddings=_features[\"image_embed\"][i].unsqueeze(0),\n                image_pe=self.visual_model.sam_prompt_encoder.get_dense_pe(),\n                sparse_prompt_embeddings=sparse_embeddings,\n                dense_prompt_embeddings=dense_embeddings,\n                multimask_output=multimask_output,\n                repeat_image = True,\n                high_res_features=high_res_features,\n            )\n\n            if multimask_output:\n                sorted_ids = torch.argsort(iou_predictions, dim=-1, descending=True)\n                low_res_masks = torch.take_along_dim(low_res_masks, sorted_ids[..., None, None], dim=1)[:, :1]\n          \n            pred_mask = self.postprocess_masks(\n                low_res_masks,\n                orig_hw=label_list[i].shape,\n            )\n            pred_masks.append(pred_mask[:, 0])\n\n        gt_masks = masks_list\n\n        if inference:\n            return {\n                \"pred_masks\": pred_masks,\n                \"gt_masks\": gt_masks,\n            }\n\n        mask_bce_loss = 0\n        mask_dice_loss = 0\n        num_masks = 0\n        for batch_idx in range(len(pred_masks)):\n            gt_mask = gt_masks[batch_idx]\n            pred_mask = pred_masks[batch_idx]\n\n            assert (\n                gt_mask.shape[0] == pred_mask.shape[0]\n            ), \"gt_mask.shape: {}, pred_mask.shape: {}\".format(\n                gt_mask.shape, pred_mask.shape\n            )\n            mask_bce_loss += (\n                sigmoid_ce_loss(pred_mask, gt_mask, num_masks=gt_mask.shape[0])\n                * gt_mask.shape[0]\n            )\n            mask_dice_loss += (\n                dice_loss(pred_mask, gt_mask, num_masks=gt_mask.shape[0])\n                * gt_mask.shape[0]\n            )\n            num_masks += gt_mask.shape[0]\n\n        mask_bce_loss = self.bce_loss_weight * mask_bce_loss / (num_masks + 1e-8)\n        mask_dice_loss = self.dice_loss_weight * mask_dice_loss / (num_masks + 1e-8)\n        mask_loss = mask_bce_loss + mask_dice_loss\n\n        loss = mask_loss\n\n        return {\n            \"loss\": loss,\n            \"mask_bce_loss\": mask_bce_loss,\n            \"mask_dice_loss\": mask_dice_loss,\n            \"mask_loss\": mask_loss,\n        }\n\n    def inference(\n            self,\n            images,\n            images_evf,\n            input_ids,\n            resize_list,\n            original_size_list,\n            multimask_output=True,\n        ):\n        with torch.no_grad():\n            backbone_out = self.visual_model.forward_image(images)\n            # dict_keys(['vision_features', 'vision_pos_enc', 'backbone_fpn'])\n            _, image_embeddings, _, _ = self.visual_model._prepare_backbone_features(backbone_out)\n            image_embeddings = [_.to(images.dtype) for _ in image_embeddings]\n            batch_size = images.shape[0]\n            if self.visual_model.directly_add_no_mem_embed:\n                image_embeddings[-1] = image_embeddings[-1] + self.visual_model.no_mem_embed\n\n            feats = [\n                feat.permute(1, 2, 0).view(batch_size, -1, *feat_size)\n                for feat, feat_size in zip(image_embeddings[::-1], self._bb_feat_sizes[::-1])\n            ][::-1]\n            _features = {\"image_embed\": feats[-1], \"high_res_feats\": feats[:-1]}\n        \n\n        multimask_output = multimask_output\n\n        output = self.mm_extractor.beit3(visual_tokens=images_evf, textual_tokens=input_ids, text_padding_position=torch.zeros_like(input_ids))\n\n        feat = output[\"encoder_out\"][:, :1, ...]\n        feat = self.text_hidden_fcs[0](feat)\n        (\n            sparse_embeddings,\n            dense_embeddings,\n        ) = self.visual_model.sam_prompt_encoder(\n            points=None,\n            boxes=None,\n            masks=None,\n            text_embeds=feat,\n        )\n        high_res_features = _features[\"high_res_feats\"]\n        sparse_embeddings = sparse_embeddings.to(feat.dtype)\n        low_res_masks, iou_predictions, _, _ = self.visual_model.sam_mask_decoder(\n            image_embeddings=_features[\"image_embed\"],\n            image_pe=self.visual_model.sam_prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            dense_prompt_embeddings=dense_embeddings,\n            multimask_output=multimask_output,\n            repeat_image = True,\n            high_res_features=high_res_features,\n        )\n        if multimask_output:\n            sorted_ids = torch.argsort(iou_predictions, dim=-1, descending=True)\n            low_res_masks = torch.take_along_dim(low_res_masks, sorted_ids[..., None, None], dim=1)[:, :1]\n\n        pred_mask = self.postprocess_masks(\n            low_res_masks,\n            orig_hw=original_size_list[0],\n        )\n\n        return pred_mask[:, 0]\n\n\nAutoConfig.register(\"evf\", EvfConfig)\nAutoModelForCausalLM.register(EvfConfig, EvfSam2Model)"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/build_sam.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport logging\n\nimport torch\nfrom hydra import compose\nfrom hydra.utils import instantiate\nfrom omegaconf import OmegaConf\n\ndef build_sam2(\n    config_file,\n    ckpt_path=None,\n    device=\"cuda\",\n    mode=\"eval\",\n    hydra_overrides_extra=[],\n    apply_postprocessing=True,\n):\n\n    if apply_postprocessing:\n        hydra_overrides_extra = hydra_overrides_extra.copy()\n        hydra_overrides_extra += [\n            # dynamically fall back to multi-mask if the single mask is not stable\n            \"++model.sam_mask_decoder_extra_args.dynamic_multimask_via_stability=true\",\n            \"++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_delta=0.05\",\n            \"++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_thresh=0.98\",\n        ]\n    # Read config and init model\n    cfg = compose(config_name=config_file, overrides=hydra_overrides_extra)\n    OmegaConf.resolve(cfg)\n    model = instantiate(cfg.model, _recursive_=True)\n    _load_checkpoint(model, ckpt_path)\n    if device:\n        model = model.to(device)\n    if mode == \"eval\":\n        model.eval()\n    return model\n\n\ndef build_sam2_video_predictor(\n    config_file,\n    ckpt_path=None,\n    device=\"cuda\",\n    mode=\"eval\",\n    hydra_overrides_extra=[],\n    apply_postprocessing=True,\n):\n    hydra_overrides = [\n        \"++model._target_=model.segment_anything_2.sam2.sam2_video_predictor.SAM2VideoPredictor\",\n    ]\n    if apply_postprocessing:\n        hydra_overrides_extra = hydra_overrides_extra.copy()\n        hydra_overrides_extra += [\n            # dynamically fall back to multi-mask if the single mask is not stable\n            \"++model.sam_mask_decoder_extra_args.dynamic_multimask_via_stability=true\",\n            \"++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_delta=0.05\",\n            \"++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_thresh=0.98\",\n            # the sigmoid mask logits on interacted frames with clicks in the memory encoder so that the encoded masks are exactly as what users see from clicking\n            \"++model.binarize_mask_from_pts_for_mem_enc=true\",\n            # fill small holes in the low-res masks up to `fill_hole_area` (before resizing them to the original video resolution)\n            \"++model.fill_hole_area=8\",\n        ]\n    hydra_overrides.extend(hydra_overrides_extra)\n\n    # Read config and init model\n    cfg = compose(config_name=config_file, overrides=hydra_overrides)\n    OmegaConf.resolve(cfg)\n    model = instantiate(cfg.model, _recursive_=True)\n    _load_checkpoint(model, ckpt_path)\n    if device:\n        model = model.to(device)\n    if mode == \"eval\":\n        model.eval()\n    return model\n\n\ndef _load_checkpoint(model, ckpt_path):\n    if ckpt_path is not None:\n        sd = torch.load(ckpt_path, map_location=\"cpu\")[\"model\"]\n        missing_keys, unexpected_keys = model.load_state_dict(sd)\n        if missing_keys:\n            logging.error(missing_keys)\n            raise RuntimeError()\n        if unexpected_keys:\n            logging.error(unexpected_keys)\n            raise RuntimeError()\n        logging.info(\"Loaded checkpoint sucessfully\")\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/automatic_mask_generator.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n# Adapted from https://github.com/facebookresearch/segment-anything/blob/main/segment_anything/automatic_mask_generator.py\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport numpy as np\nimport torch\nfrom torchvision.ops.boxes import batched_nms, box_area  # type: ignore\n\nfrom model.segment_anything_2.sam2.modeling.sam2_base import SAM2Base\nfrom model.segment_anything_2.sam2.sam2_image_predictor import SAM2ImagePredictor\nfrom model.segment_anything_2.sam2.utils.amg import (\n    area_from_rle,\n    batch_iterator,\n    batched_mask_to_box,\n    box_xyxy_to_xywh,\n    build_all_layer_point_grids,\n    calculate_stability_score,\n    coco_encode_rle,\n    generate_crop_boxes,\n    is_box_near_crop_edge,\n    mask_to_rle_pytorch,\n    MaskData,\n    remove_small_regions,\n    rle_to_mask,\n    uncrop_boxes_xyxy,\n    uncrop_masks,\n    uncrop_points,\n)\n\n\nclass SAM2AutomaticMaskGenerator:\n    def __init__(\n        self,\n        model: SAM2Base,\n        points_per_side: Optional[int] = 32,\n        points_per_batch: int = 64,\n        pred_iou_thresh: float = 0.8,\n        stability_score_thresh: float = 0.95,\n        stability_score_offset: float = 1.0,\n        mask_threshold: float = 0.0,\n        box_nms_thresh: float = 0.7,\n        crop_n_layers: int = 0,\n        crop_nms_thresh: float = 0.7,\n        crop_overlap_ratio: float = 512 / 1500,\n        crop_n_points_downscale_factor: int = 1,\n        point_grids: Optional[List[np.ndarray]] = None,\n        min_mask_region_area: int = 0,\n        output_mode: str = \"binary_mask\",\n        use_m2m: bool = False,\n        multimask_output: bool = True,\n    ) -> None:\n        \"\"\"\n        Using a SAM 2 model, generates masks for the entire image.\n        Generates a grid of point prompts over the image, then filters\n        low quality and duplicate masks. The default settings are chosen\n        for SAM 2 with a HieraL backbone.\n\n        Arguments:\n          model (Sam): The SAM 2 model to use for mask prediction.\n          points_per_side (int or None): The number of points to be sampled\n            along one side of the image. The total number of points is\n            points_per_side**2. If None, 'point_grids' must provide explicit\n            point sampling.\n          points_per_batch (int): Sets the number of points run simultaneously\n            by the model. Higher numbers may be faster but use more GPU memory.\n          pred_iou_thresh (float): A filtering threshold in [0,1], using the\n            model's predicted mask quality.\n          stability_score_thresh (float): A filtering threshold in [0,1], using\n            the stability of the mask under changes to the cutoff used to binarize\n            the model's mask predictions.\n          stability_score_offset (float): The amount to shift the cutoff when\n            calculated the stability score.\n          mask_threshold (float): Threshold for binarizing the mask logits\n          box_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks.\n          crop_n_layers (int): If >0, mask prediction will be run again on\n            crops of the image. Sets the number of layers to run, where each\n            layer has 2**i_layer number of image crops.\n          crop_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks between different crops.\n          crop_overlap_ratio (float): Sets the degree to which crops overlap.\n            In the first crop layer, crops will overlap by this fraction of\n            the image length. Later layers with more crops scale down this overlap.\n          crop_n_points_downscale_factor (int): The number of points-per-side\n            sampled in layer n is scaled down by crop_n_points_downscale_factor**n.\n          point_grids (list(np.ndarray) or None): A list over explicit grids\n            of points used for sampling, normalized to [0,1]. The nth grid in the\n            list is used in the nth crop layer. Exclusive with points_per_side.\n          min_mask_region_area (int): If >0, postprocessing will be applied\n            to remove disconnected regions and holes in masks with area smaller\n            than min_mask_region_area. Requires opencv.\n          output_mode (str): The form masks are returned in. Can be 'binary_mask',\n            'uncompressed_rle', or 'coco_rle'. 'coco_rle' requires pycocotools.\n            For large resolutions, 'binary_mask' may consume large amounts of\n            memory.\n          use_m2m (bool): Whether to add a one step refinement using previous mask predictions.\n          multimask_output (bool): Whether to output multimask at each point of the grid.\n        \"\"\"\n\n        assert (points_per_side is None) != (\n            point_grids is None\n        ), \"Exactly one of points_per_side or point_grid must be provided.\"\n        if points_per_side is not None:\n            self.point_grids = build_all_layer_point_grids(\n                points_per_side,\n                crop_n_layers,\n                crop_n_points_downscale_factor,\n            )\n        elif point_grids is not None:\n            self.point_grids = point_grids\n        else:\n            raise ValueError(\"Can't have both points_per_side and point_grid be None.\")\n\n        assert output_mode in [\n            \"binary_mask\",\n            \"uncompressed_rle\",\n            \"coco_rle\",\n        ], f\"Unknown output_mode {output_mode}.\"\n        if output_mode == \"coco_rle\":\n            try:\n                from pycocotools import mask as mask_utils  # type: ignore  # noqa: F401\n            except ImportError as e:\n                print(\"Please install pycocotools\")\n                raise e\n\n        self.predictor = SAM2ImagePredictor(\n            model,\n            max_hole_area=min_mask_region_area,\n            max_sprinkle_area=min_mask_region_area,\n        )\n        self.points_per_batch = points_per_batch\n        self.pred_iou_thresh = pred_iou_thresh\n        self.stability_score_thresh = stability_score_thresh\n        self.stability_score_offset = stability_score_offset\n        self.mask_threshold = mask_threshold\n        self.box_nms_thresh = box_nms_thresh\n        self.crop_n_layers = crop_n_layers\n        self.crop_nms_thresh = crop_nms_thresh\n        self.crop_overlap_ratio = crop_overlap_ratio\n        self.crop_n_points_downscale_factor = crop_n_points_downscale_factor\n        self.min_mask_region_area = min_mask_region_area\n        self.output_mode = output_mode\n        self.use_m2m = use_m2m\n        self.multimask_output = multimask_output\n\n    @torch.no_grad()\n    def generate(self, image: np.ndarray) -> List[Dict[str, Any]]:\n        \"\"\"\n        Generates masks for the given image.\n\n        Arguments:\n          image (np.ndarray): The image to generate masks for, in HWC uint8 format.\n\n        Returns:\n           list(dict(str, any)): A list over records for masks. Each record is\n             a dict containing the following keys:\n               segmentation (dict(str, any) or np.ndarray): The mask. If\n                 output_mode='binary_mask', is an array of shape HW. Otherwise,\n                 is a dictionary containing the RLE.\n               bbox (list(float)): The box around the mask, in XYWH format.\n               area (int): The area in pixels of the mask.\n               predicted_iou (float): The model's own prediction of the mask's\n                 quality. This is filtered by the pred_iou_thresh parameter.\n               point_coords (list(list(float))): The point coordinates input\n                 to the model to generate this mask.\n               stability_score (float): A measure of the mask's quality. This\n                 is filtered on using the stability_score_thresh parameter.\n               crop_box (list(float)): The crop of the image used to generate\n                 the mask, given in XYWH format.\n        \"\"\"\n\n        # Generate masks\n        mask_data = self._generate_masks(image)\n\n        # Encode masks\n        if self.output_mode == \"coco_rle\":\n            mask_data[\"segmentations\"] = [\n                coco_encode_rle(rle) for rle in mask_data[\"rles\"]\n            ]\n        elif self.output_mode == \"binary_mask\":\n            mask_data[\"segmentations\"] = [rle_to_mask(rle) for rle in mask_data[\"rles\"]]\n        else:\n            mask_data[\"segmentations\"] = mask_data[\"rles\"]\n\n        # Write mask records\n        curr_anns = []\n        for idx in range(len(mask_data[\"segmentations\"])):\n            ann = {\n                \"segmentation\": mask_data[\"segmentations\"][idx],\n                \"area\": area_from_rle(mask_data[\"rles\"][idx]),\n                \"bbox\": box_xyxy_to_xywh(mask_data[\"boxes\"][idx]).tolist(),\n                \"predicted_iou\": mask_data[\"iou_preds\"][idx].item(),\n                \"point_coords\": [mask_data[\"points\"][idx].tolist()],\n                \"stability_score\": mask_data[\"stability_score\"][idx].item(),\n                \"crop_box\": box_xyxy_to_xywh(mask_data[\"crop_boxes\"][idx]).tolist(),\n            }\n            curr_anns.append(ann)\n\n        return curr_anns\n\n    def _generate_masks(self, image: np.ndarray) -> MaskData:\n        orig_size = image.shape[:2]\n        crop_boxes, layer_idxs = generate_crop_boxes(\n            orig_size, self.crop_n_layers, self.crop_overlap_ratio\n        )\n\n        # Iterate over image crops\n        data = MaskData()\n        for crop_box, layer_idx in zip(crop_boxes, layer_idxs):\n            crop_data = self._process_crop(image, crop_box, layer_idx, orig_size)\n            data.cat(crop_data)\n\n        # Remove duplicate masks between crops\n        if len(crop_boxes) > 1:\n            # Prefer masks from smaller crops\n            scores = 1 / box_area(data[\"crop_boxes\"])\n            scores = scores.to(data[\"boxes\"].device)\n            keep_by_nms = batched_nms(\n                data[\"boxes\"].float(),\n                scores,\n                torch.zeros_like(data[\"boxes\"][:, 0]),  # categories\n                iou_threshold=self.crop_nms_thresh,\n            )\n            data.filter(keep_by_nms)\n        data.to_numpy()\n        return data\n\n    def _process_crop(\n        self,\n        image: np.ndarray,\n        crop_box: List[int],\n        crop_layer_idx: int,\n        orig_size: Tuple[int, ...],\n    ) -> MaskData:\n        # Crop the image and calculate embeddings\n        x0, y0, x1, y1 = crop_box\n        cropped_im = image[y0:y1, x0:x1, :]\n        cropped_im_size = cropped_im.shape[:2]\n        self.predictor.set_image(cropped_im)\n\n        # Get points for this crop\n        points_scale = np.array(cropped_im_size)[None, ::-1]\n        points_for_image = self.point_grids[crop_layer_idx] * points_scale\n\n        # Generate masks for this crop in batches\n        data = MaskData()\n        for (points,) in batch_iterator(self.points_per_batch, points_for_image):\n            batch_data = self._process_batch(\n                points, cropped_im_size, crop_box, orig_size, normalize=True\n            )\n            data.cat(batch_data)\n            del batch_data\n        self.predictor.reset_predictor()\n\n        # Remove duplicates within this crop.\n        keep_by_nms = batched_nms(\n            data[\"boxes\"].float(),\n            data[\"iou_preds\"],\n            torch.zeros_like(data[\"boxes\"][:, 0]),  # categories\n            iou_threshold=self.box_nms_thresh,\n        )\n        data.filter(keep_by_nms)\n\n        # Return to the original image frame\n        data[\"boxes\"] = uncrop_boxes_xyxy(data[\"boxes\"], crop_box)\n        data[\"points\"] = uncrop_points(data[\"points\"], crop_box)\n        data[\"crop_boxes\"] = torch.tensor([crop_box for _ in range(len(data[\"rles\"]))])\n\n        return data\n\n    def _process_batch(\n        self,\n        points: np.ndarray,\n        im_size: Tuple[int, ...],\n        crop_box: List[int],\n        orig_size: Tuple[int, ...],\n        normalize=False,\n    ) -> MaskData:\n        orig_h, orig_w = orig_size\n\n        # Run model on this batch\n        points = torch.as_tensor(points, device=self.predictor.device)\n        in_points = self.predictor._transforms.transform_coords(\n            points, normalize=normalize, orig_hw=im_size\n        )\n        in_labels = torch.ones(\n            in_points.shape[0], dtype=torch.int, device=in_points.device\n        )\n        masks, iou_preds, low_res_masks = self.predictor._predict(\n            in_points[:, None, :],\n            in_labels[:, None],\n            multimask_output=self.multimask_output,\n            return_logits=True,\n        )\n\n        # Serialize predictions and store in MaskData\n        data = MaskData(\n            masks=masks.flatten(0, 1),\n            iou_preds=iou_preds.flatten(0, 1),\n            points=points.repeat_interleave(masks.shape[1], dim=0),\n            low_res_masks=low_res_masks.flatten(0, 1),\n        )\n        del masks\n\n        if not self.use_m2m:\n            # Filter by predicted IoU\n            if self.pred_iou_thresh > 0.0:\n                keep_mask = data[\"iou_preds\"] > self.pred_iou_thresh\n                data.filter(keep_mask)\n\n            # Calculate and filter by stability score\n            data[\"stability_score\"] = calculate_stability_score(\n                data[\"masks\"], self.mask_threshold, self.stability_score_offset\n            )\n            if self.stability_score_thresh > 0.0:\n                keep_mask = data[\"stability_score\"] >= self.stability_score_thresh\n                data.filter(keep_mask)\n        else:\n            # One step refinement using previous mask predictions\n            in_points = self.predictor._transforms.transform_coords(\n                data[\"points\"], normalize=normalize, orig_hw=im_size\n            )\n            labels = torch.ones(\n                in_points.shape[0], dtype=torch.int, device=in_points.device\n            )\n            masks, ious = self.refine_with_m2m(\n                in_points, labels, data[\"low_res_masks\"], self.points_per_batch\n            )\n            data[\"masks\"] = masks.squeeze(1)\n            data[\"iou_preds\"] = ious.squeeze(1)\n\n            if self.pred_iou_thresh > 0.0:\n                keep_mask = data[\"iou_preds\"] > self.pred_iou_thresh\n                data.filter(keep_mask)\n\n            data[\"stability_score\"] = calculate_stability_score(\n                data[\"masks\"], self.mask_threshold, self.stability_score_offset\n            )\n            if self.stability_score_thresh > 0.0:\n                keep_mask = data[\"stability_score\"] >= self.stability_score_thresh\n                data.filter(keep_mask)\n\n        # Threshold masks and calculate boxes\n        data[\"masks\"] = data[\"masks\"] > self.mask_threshold\n        data[\"boxes\"] = batched_mask_to_box(data[\"masks\"])\n\n        # Filter boxes that touch crop boundaries\n        keep_mask = ~is_box_near_crop_edge(\n            data[\"boxes\"], crop_box, [0, 0, orig_w, orig_h]\n        )\n        if not torch.all(keep_mask):\n            data.filter(keep_mask)\n\n        # Compress to RLE\n        data[\"masks\"] = uncrop_masks(data[\"masks\"], crop_box, orig_h, orig_w)\n        data[\"rles\"] = mask_to_rle_pytorch(data[\"masks\"])\n        del data[\"masks\"]\n\n        return data\n\n    @staticmethod\n    def postprocess_small_regions(\n        mask_data: MaskData, min_area: int, nms_thresh: float\n    ) -> MaskData:\n        \"\"\"\n        Removes small disconnected regions and holes in masks, then reruns\n        box NMS to remove any new duplicates.\n\n        Edits mask_data in place.\n\n        Requires open-cv as a dependency.\n        \"\"\"\n        if len(mask_data[\"rles\"]) == 0:\n            return mask_data\n\n        # Filter small disconnected regions and holes\n        new_masks = []\n        scores = []\n        for rle in mask_data[\"rles\"]:\n            mask = rle_to_mask(rle)\n\n            mask, changed = remove_small_regions(mask, min_area, mode=\"holes\")\n            unchanged = not changed\n            mask, changed = remove_small_regions(mask, min_area, mode=\"islands\")\n            unchanged = unchanged and not changed\n\n            new_masks.append(torch.as_tensor(mask).unsqueeze(0))\n            # Give score=0 to changed masks and score=1 to unchanged masks\n            # so NMS will prefer ones that didn't need postprocessing\n            scores.append(float(unchanged))\n\n        # Recalculate boxes and remove any new duplicates\n        masks = torch.cat(new_masks, dim=0)\n        boxes = batched_mask_to_box(masks)\n        keep_by_nms = batched_nms(\n            boxes.float(),\n            torch.as_tensor(scores),\n            torch.zeros_like(boxes[:, 0]),  # categories\n            iou_threshold=nms_thresh,\n        )\n\n        # Only recalculate RLEs for masks that have changed\n        for i_mask in keep_by_nms:\n            if scores[i_mask] == 0.0:\n                mask_torch = masks[i_mask].unsqueeze(0)\n                mask_data[\"rles\"][i_mask] = mask_to_rle_pytorch(mask_torch)[0]\n                mask_data[\"boxes\"][i_mask] = boxes[i_mask]  # update res directly\n        mask_data.filter(keep_by_nms)\n\n        return mask_data\n\n    def refine_with_m2m(self, points, point_labels, low_res_masks, points_per_batch):\n        new_masks = []\n        new_iou_preds = []\n\n        for cur_points, cur_point_labels, low_res_mask in batch_iterator(\n            points_per_batch, points, point_labels, low_res_masks\n        ):\n            best_masks, best_iou_preds, _ = self.predictor._predict(\n                cur_points[:, None, :],\n                cur_point_labels[:, None],\n                mask_input=low_res_mask[:, None, :],\n                multimask_output=False,\n                return_logits=True,\n            )\n            new_masks.append(best_masks)\n            new_iou_preds.append(best_iou_preds)\n        masks = torch.cat(new_masks, dim=0)\n        return masks, torch.cat(new_iou_preds, dim=0)\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/__init__.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n"}
{"type": "source_file", "path": "model/segment_anything/utils/amg.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom copy import deepcopy\nfrom itertools import product\nfrom typing import Any, Dict, Generator, ItemsView, List, Tuple\n\nimport numpy as np\nimport torch\n\n\nclass MaskData:\n    \"\"\"\n    A structure for storing masks and their related data in batched format.\n    Implements basic filtering and concatenation.\n    \"\"\"\n\n    def __init__(self, **kwargs) -> None:\n        for v in kwargs.values():\n            assert isinstance(\n                v, (list, np.ndarray, torch.Tensor)\n            ), \"MaskData only supports list, numpy arrays, and torch tensors.\"\n        self._stats = dict(**kwargs)\n\n    def __setitem__(self, key: str, item: Any) -> None:\n        assert isinstance(\n            item, (list, np.ndarray, torch.Tensor)\n        ), \"MaskData only supports list, numpy arrays, and torch tensors.\"\n        self._stats[key] = item\n\n    def __delitem__(self, key: str) -> None:\n        del self._stats[key]\n\n    def __getitem__(self, key: str) -> Any:\n        return self._stats[key]\n\n    def items(self) -> ItemsView[str, Any]:\n        return self._stats.items()\n\n    def filter(self, keep: torch.Tensor) -> None:\n        for k, v in self._stats.items():\n            if v is None:\n                self._stats[k] = None\n            elif isinstance(v, torch.Tensor):\n                self._stats[k] = v[torch.as_tensor(keep, device=v.device)]\n            elif isinstance(v, np.ndarray):\n                self._stats[k] = v[keep.detach().cpu().numpy()]\n            elif isinstance(v, list) and keep.dtype == torch.bool:\n                self._stats[k] = [a for i, a in enumerate(v) if keep[i]]\n            elif isinstance(v, list):\n                self._stats[k] = [v[i] for i in keep]\n            else:\n                raise TypeError(f\"MaskData key {k} has an unsupported type {type(v)}.\")\n\n    def cat(self, new_stats: \"MaskData\") -> None:\n        for k, v in new_stats.items():\n            if k not in self._stats or self._stats[k] is None:\n                self._stats[k] = deepcopy(v)\n            elif isinstance(v, torch.Tensor):\n                self._stats[k] = torch.cat([self._stats[k], v], dim=0)\n            elif isinstance(v, np.ndarray):\n                self._stats[k] = np.concatenate([self._stats[k], v], axis=0)\n            elif isinstance(v, list):\n                self._stats[k] = self._stats[k] + deepcopy(v)\n            else:\n                raise TypeError(f\"MaskData key {k} has an unsupported type {type(v)}.\")\n\n    def to_numpy(self) -> None:\n        for k, v in self._stats.items():\n            if isinstance(v, torch.Tensor):\n                self._stats[k] = v.detach().cpu().numpy()\n\n\ndef is_box_near_crop_edge(\n    boxes: torch.Tensor, crop_box: List[int], orig_box: List[int], atol: float = 20.0\n) -> torch.Tensor:\n    \"\"\"Filter masks at the edge of a crop, but not at the edge of the original image.\"\"\"\n    crop_box_torch = torch.as_tensor(crop_box, dtype=torch.float, device=boxes.device)\n    orig_box_torch = torch.as_tensor(orig_box, dtype=torch.float, device=boxes.device)\n    boxes = uncrop_boxes_xyxy(boxes, crop_box).float()\n    near_crop_edge = torch.isclose(boxes, crop_box_torch[None, :], atol=atol, rtol=0)\n    near_image_edge = torch.isclose(boxes, orig_box_torch[None, :], atol=atol, rtol=0)\n    near_crop_edge = torch.logical_and(near_crop_edge, ~near_image_edge)\n    return torch.any(near_crop_edge, dim=1)\n\n\ndef box_xyxy_to_xywh(box_xyxy: torch.Tensor) -> torch.Tensor:\n    box_xywh = deepcopy(box_xyxy)\n    box_xywh[2] = box_xywh[2] - box_xywh[0]\n    box_xywh[3] = box_xywh[3] - box_xywh[1]\n    return box_xywh\n\n\ndef batch_iterator(batch_size: int, *args) -> Generator[List[Any], None, None]:\n    assert len(args) > 0 and all(\n        len(a) == len(args[0]) for a in args\n    ), \"Batched iteration must have inputs of all the same size.\"\n    n_batches = len(args[0]) // batch_size + int(len(args[0]) % batch_size != 0)\n    for b in range(n_batches):\n        yield [arg[b * batch_size : (b + 1) * batch_size] for arg in args]\n\n\ndef mask_to_rle_pytorch(tensor: torch.Tensor) -> List[Dict[str, Any]]:\n    \"\"\"\n    Encodes masks to an uncompressed RLE, in the format expected by\n    pycoco tools.\n    \"\"\"\n    # Put in fortran order and flatten h,w\n    b, h, w = tensor.shape\n    tensor = tensor.permute(0, 2, 1).flatten(1)\n\n    # Compute change indices\n    diff = tensor[:, 1:] ^ tensor[:, :-1]\n    change_indices = diff.nonzero()\n\n    # Encode run length\n    out = []\n    for i in range(b):\n        cur_idxs = change_indices[change_indices[:, 0] == i, 1]\n        cur_idxs = torch.cat(\n            [\n                torch.tensor([0], dtype=cur_idxs.dtype, device=cur_idxs.device),\n                cur_idxs + 1,\n                torch.tensor([h * w], dtype=cur_idxs.dtype, device=cur_idxs.device),\n            ]\n        )\n        btw_idxs = cur_idxs[1:] - cur_idxs[:-1]\n        counts = [] if tensor[i, 0] == 0 else [0]\n        counts.extend(btw_idxs.detach().cpu().tolist())\n        out.append({\"size\": [h, w], \"counts\": counts})\n    return out\n\n\ndef rle_to_mask(rle: Dict[str, Any]) -> np.ndarray:\n    \"\"\"Compute a binary mask from an uncompressed RLE.\"\"\"\n    h, w = rle[\"size\"]\n    mask = np.empty(h * w, dtype=bool)\n    idx = 0\n    parity = False\n    for count in rle[\"counts\"]:\n        mask[idx : idx + count] = parity\n        idx += count\n        parity ^= True\n    mask = mask.reshape(w, h)\n    return mask.transpose()  # Put in C order\n\n\ndef area_from_rle(rle: Dict[str, Any]) -> int:\n    return sum(rle[\"counts\"][1::2])\n\n\ndef calculate_stability_score(\n    masks: torch.Tensor, mask_threshold: float, threshold_offset: float\n) -> torch.Tensor:\n    \"\"\"\n    Computes the stability score for a batch of masks. The stability\n    score is the IoU between the binary masks obtained by thresholding\n    the predicted mask logits at high and low values.\n    \"\"\"\n    # One mask is always contained inside the other.\n    # Save memory by preventing unnecessary cast to torch.int64\n    intersections = (\n        (masks > (mask_threshold + threshold_offset))\n        .sum(-1, dtype=torch.int16)\n        .sum(-1, dtype=torch.int32)\n    )\n    unions = (\n        (masks > (mask_threshold - threshold_offset))\n        .sum(-1, dtype=torch.int16)\n        .sum(-1, dtype=torch.int32)\n    )\n    return intersections / unions\n\n\ndef build_point_grid(n_per_side: int) -> np.ndarray:\n    \"\"\"Generates a 2D grid of points evenly spaced in [0,1]x[0,1].\"\"\"\n    offset = 1 / (2 * n_per_side)\n    points_one_side = np.linspace(offset, 1 - offset, n_per_side)\n    points_x = np.tile(points_one_side[None, :], (n_per_side, 1))\n    points_y = np.tile(points_one_side[:, None], (1, n_per_side))\n    points = np.stack([points_x, points_y], axis=-1).reshape(-1, 2)\n    return points\n\n\ndef build_all_layer_point_grids(\n    n_per_side: int, n_layers: int, scale_per_layer: int\n) -> List[np.ndarray]:\n    \"\"\"Generates point grids for all crop layers.\"\"\"\n    points_by_layer = []\n    for i in range(n_layers + 1):\n        n_points = int(n_per_side / (scale_per_layer**i))\n        points_by_layer.append(build_point_grid(n_points))\n    return points_by_layer\n\n\ndef generate_crop_boxes(\n    im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float\n) -> Tuple[List[List[int]], List[int]]:\n    \"\"\"\n    Generates a list of crop boxes of different sizes. Each layer\n    has (2**i)**2 boxes for the ith layer.\n    \"\"\"\n    crop_boxes, layer_idxs = [], []\n    im_h, im_w = im_size\n    short_side = min(im_h, im_w)\n\n    # Original image\n    crop_boxes.append([0, 0, im_w, im_h])\n    layer_idxs.append(0)\n\n    def crop_len(orig_len, n_crops, overlap):\n        return int(math.ceil((overlap * (n_crops - 1) + orig_len) / n_crops))\n\n    for i_layer in range(n_layers):\n        n_crops_per_side = 2 ** (i_layer + 1)\n        overlap = int(overlap_ratio * short_side * (2 / n_crops_per_side))\n\n        crop_w = crop_len(im_w, n_crops_per_side, overlap)\n        crop_h = crop_len(im_h, n_crops_per_side, overlap)\n\n        crop_box_x0 = [int((crop_w - overlap) * i) for i in range(n_crops_per_side)]\n        crop_box_y0 = [int((crop_h - overlap) * i) for i in range(n_crops_per_side)]\n\n        # Crops in XYWH format\n        for x0, y0 in product(crop_box_x0, crop_box_y0):\n            box = [x0, y0, min(x0 + crop_w, im_w), min(y0 + crop_h, im_h)]\n            crop_boxes.append(box)\n            layer_idxs.append(i_layer + 1)\n\n    return crop_boxes, layer_idxs\n\n\ndef uncrop_boxes_xyxy(boxes: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0, x0, y0]], device=boxes.device)\n    # Check if boxes has a channel dimension\n    if len(boxes.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return boxes + offset\n\n\ndef uncrop_points(points: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0]], device=points.device)\n    # Check if points has a channel dimension\n    if len(points.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return points + offset\n\n\ndef uncrop_masks(\n    masks: torch.Tensor, crop_box: List[int], orig_h: int, orig_w: int\n) -> torch.Tensor:\n    x0, y0, x1, y1 = crop_box\n    if x0 == 0 and y0 == 0 and x1 == orig_w and y1 == orig_h:\n        return masks\n    # Coordinate transform masks\n    pad_x, pad_y = orig_w - (x1 - x0), orig_h - (y1 - y0)\n    pad = (x0, pad_x - x0, y0, pad_y - y0)\n    return torch.nn.functional.pad(masks, pad, value=0)\n\n\ndef remove_small_regions(\n    mask: np.ndarray, area_thresh: float, mode: str\n) -> Tuple[np.ndarray, bool]:\n    \"\"\"\n    Removes small disconnected regions and holes in a mask. Returns the\n    mask and an indicator of if the mask has been modified.\n    \"\"\"\n    import cv2  # type: ignore\n\n    assert mode in [\"holes\", \"islands\"]\n    correct_holes = mode == \"holes\"\n    working_mask = (correct_holes ^ mask).astype(np.uint8)\n    n_labels, regions, stats, _ = cv2.connectedComponentsWithStats(working_mask, 8)\n    sizes = stats[:, -1][1:]  # Row 0 is background label\n    small_regions = [i + 1 for i, s in enumerate(sizes) if s < area_thresh]\n    if len(small_regions) == 0:\n        return mask, False\n    fill_labels = [0] + small_regions\n    if not correct_holes:\n        fill_labels = [i for i in range(n_labels) if i not in fill_labels]\n        # If every region is below threshold, keep largest\n        if len(fill_labels) == 0:\n            fill_labels = [int(np.argmax(sizes)) + 1]\n    mask = np.isin(regions, fill_labels)\n    return mask, True\n\n\ndef coco_encode_rle(uncompressed_rle: Dict[str, Any]) -> Dict[str, Any]:\n    from pycocotools import mask as mask_utils  # type: ignore\n\n    h, w = uncompressed_rle[\"size\"]\n    rle = mask_utils.frPyObjects(uncompressed_rle, h, w)\n    rle[\"counts\"] = rle[\"counts\"].decode(\"utf-8\")  # Necessary to serialize with json\n    return rle\n\n\ndef batched_mask_to_box(masks: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Calculates boxes in XYXY format around masks. Return [0,0,0,0] for\n    an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.\n    \"\"\"\n    # torch.max below raises an error on empty inputs, just skip in this case\n    if torch.numel(masks) == 0:\n        return torch.zeros(*masks.shape[:-2], 4, device=masks.device)\n\n    # Normalize shape to CxHxW\n    shape = masks.shape\n    h, w = shape[-2:]\n    if len(shape) > 2:\n        masks = masks.flatten(0, -3)\n    else:\n        masks = masks.unsqueeze(0)\n\n    # Get top and bottom edges\n    in_height, _ = torch.max(masks, dim=-1)\n    in_height_coords = in_height * torch.arange(h, device=in_height.device)[None, :]\n    bottom_edges, _ = torch.max(in_height_coords, dim=-1)\n    in_height_coords = in_height_coords + h * (~in_height)\n    top_edges, _ = torch.min(in_height_coords, dim=-1)\n\n    # Get left and right edges\n    in_width, _ = torch.max(masks, dim=-2)\n    in_width_coords = in_width * torch.arange(w, device=in_width.device)[None, :]\n    right_edges, _ = torch.max(in_width_coords, dim=-1)\n    in_width_coords = in_width_coords + w * (~in_width)\n    left_edges, _ = torch.min(in_width_coords, dim=-1)\n\n    # If the mask is empty the right edge will be to the left of the left edge.\n    # Replace these boxes with [0, 0, 0, 0]\n    empty_filter = (right_edges < left_edges) | (bottom_edges < top_edges)\n    out = torch.stack([left_edges, top_edges, right_edges, bottom_edges], dim=-1)\n    out = out * (~empty_filter).unsqueeze(-1)\n\n    # Return to original shape\n    if len(shape) > 2:\n        out = out.reshape(*shape[:-2], 4)\n    else:\n        out = out[0]\n\n    return out\n"}
{"type": "source_file", "path": "model/segment_anything/utils/onnx.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Tuple\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\n\nfrom ..modeling import Sam\nfrom .amg import calculate_stability_score\n\n\nclass SamOnnxModel(nn.Module):\n    \"\"\"\n    This model should not be called directly, but is used in ONNX export.\n    It combines the prompt encoder, mask decoder, and mask postprocessing of Sam,\n    with some functions modified to enable model tracing. Also supports extra\n    options controlling what information. See the ONNX export script for details.\n    \"\"\"\n\n    def __init__(\n        self,\n        model: Sam,\n        return_single_mask: bool,\n        use_stability_score: bool = False,\n        return_extra_metrics: bool = False,\n    ) -> None:\n        super().__init__()\n        self.mask_decoder = model.mask_decoder\n        self.model = model\n        self.img_size = model.image_encoder.img_size\n        self.return_single_mask = return_single_mask\n        self.use_stability_score = use_stability_score\n        self.stability_score_offset = 1.0\n        self.return_extra_metrics = return_extra_metrics\n\n    @staticmethod\n    def resize_longest_image_size(\n        input_image_size: torch.Tensor, longest_side: int\n    ) -> torch.Tensor:\n        input_image_size = input_image_size.to(torch.float32)\n        scale = longest_side / torch.max(input_image_size)\n        transformed_size = scale * input_image_size\n        transformed_size = torch.floor(transformed_size + 0.5).to(torch.int64)\n        return transformed_size\n\n    def _embed_points(\n        self, point_coords: torch.Tensor, point_labels: torch.Tensor\n    ) -> torch.Tensor:\n        point_coords = point_coords + 0.5\n        point_coords = point_coords / self.img_size\n        point_embedding = self.model.prompt_encoder.pe_layer._pe_encoding(point_coords)\n        point_labels = point_labels.unsqueeze(-1).expand_as(point_embedding)\n\n        point_embedding = point_embedding * (point_labels != -1)\n        point_embedding = (\n            point_embedding\n            + self.model.prompt_encoder.not_a_point_embed.weight * (point_labels == -1)\n        )\n\n        for i in range(self.model.prompt_encoder.num_point_embeddings):\n            point_embedding = (\n                point_embedding\n                + self.model.prompt_encoder.point_embeddings[i].weight\n                * (point_labels == i)\n            )\n\n        return point_embedding\n\n    def _embed_masks(\n        self, input_mask: torch.Tensor, has_mask_input: torch.Tensor\n    ) -> torch.Tensor:\n        mask_embedding = has_mask_input * self.model.prompt_encoder.mask_downscaling(\n            input_mask\n        )\n        mask_embedding = mask_embedding + (\n            1 - has_mask_input\n        ) * self.model.prompt_encoder.no_mask_embed.weight.reshape(1, -1, 1, 1)\n        return mask_embedding\n\n    def mask_postprocessing(\n        self, masks: torch.Tensor, orig_im_size: torch.Tensor\n    ) -> torch.Tensor:\n        masks = F.interpolate(\n            masks,\n            size=(self.img_size, self.img_size),\n            mode=\"bilinear\",\n            align_corners=False,\n        )\n\n        prepadded_size = self.resize_longest_image_size(orig_im_size, self.img_size).to(\n            torch.int64\n        )\n        masks = masks[..., : prepadded_size[0], : prepadded_size[1]]  # type: ignore\n\n        orig_im_size = orig_im_size.to(torch.int64)\n        h, w = orig_im_size[0], orig_im_size[1]\n        masks = F.interpolate(masks, size=(h, w), mode=\"bilinear\", align_corners=False)\n        return masks\n\n    def select_masks(\n        self, masks: torch.Tensor, iou_preds: torch.Tensor, num_points: int\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        # Determine if we should return the multiclick mask or not from the number of points.\n        # The reweighting is used to avoid control flow.\n        score_reweight = torch.tensor(\n            [[1000] + [0] * (self.model.mask_decoder.num_mask_tokens - 1)]\n        ).to(iou_preds.device)\n        score = iou_preds + (num_points - 2.5) * score_reweight\n        best_idx = torch.argmax(score, dim=1)\n        masks = masks[torch.arange(masks.shape[0]), best_idx, :, :].unsqueeze(1)\n        iou_preds = iou_preds[torch.arange(masks.shape[0]), best_idx].unsqueeze(1)\n\n        return masks, iou_preds\n\n    @torch.no_grad()\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        point_coords: torch.Tensor,\n        point_labels: torch.Tensor,\n        mask_input: torch.Tensor,\n        has_mask_input: torch.Tensor,\n        orig_im_size: torch.Tensor,\n    ):\n        sparse_embedding = self._embed_points(point_coords, point_labels)\n        dense_embedding = self._embed_masks(mask_input, has_mask_input)\n\n        masks, scores = self.model.mask_decoder.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=self.model.prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embedding,\n            dense_prompt_embeddings=dense_embedding,\n        )\n\n        if self.use_stability_score:\n            scores = calculate_stability_score(\n                masks, self.model.mask_threshold, self.stability_score_offset\n            )\n\n        if self.return_single_mask:\n            masks, scores = self.select_masks(masks, scores, point_coords.shape[1])\n\n        upscaled_masks = self.mask_postprocessing(masks, orig_im_size)\n\n        if self.return_extra_metrics:\n            stability_scores = calculate_stability_score(\n                upscaled_masks, self.model.mask_threshold, self.stability_score_offset\n            )\n            areas = (upscaled_masks > self.model.mask_threshold).sum(-1).sum(-1)\n            return upscaled_masks, scores, stability_scores, areas, masks\n\n        return upscaled_masks, scores, masks\n"}
{"type": "source_file", "path": "inference_video.py", "content": "import argparse\nimport os\nimport sys\n\nimport cv2\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom torchvision import transforms\nfrom torchvision.transforms.functional import InterpolationMode\nfrom transformers import AutoTokenizer, BitsAndBytesConfig\nfrom model.segment_anything.utils.transforms import ResizeLongestSide\n\n\ndef parse_args(args):\n    parser = argparse.ArgumentParser(description=\"EVF infer\")\n    parser.add_argument(\"--version\", required=True)\n    parser.add_argument(\"--vis_save_path\", default=\"./infer\", type=str)\n    parser.add_argument(\n        \"--precision\",\n        default=\"fp16\",\n        type=str,\n        choices=[\"fp32\", \"bf16\", \"fp16\"],\n        help=\"precision for inference\",\n    )\n    parser.add_argument(\"--image_size\", default=224, type=int, help=\"image size\")\n    parser.add_argument(\"--model_max_length\", default=512, type=int)\n\n    parser.add_argument(\"--local-rank\", default=0, type=int, help=\"node rank\")\n    parser.add_argument(\"--load_in_8bit\", action=\"store_true\", default=False)\n    parser.add_argument(\"--load_in_4bit\", action=\"store_true\", default=False)\n    parser.add_argument(\"--model_type\", default=\"ori\", choices=[\"ori\", \"effi\", \"sam2\"])\n    parser.add_argument(\"--image_path\", type=str, default=\"assets/zebra.jpg\")\n    parser.add_argument(\"--prompt\", type=str, default=\"zebra top left\")\n    \n    return parser.parse_args(args)\n\ndef beit3_preprocess(x: np.ndarray, img_size=224) -> torch.Tensor:\n    '''\n    preprocess for BEIT-3 model.\n    input: ndarray\n    output: torch.Tensor\n    '''\n    beit_preprocess = transforms.Compose([\n        transforms.ToTensor(),\n        transforms.Resize((img_size, img_size), interpolation=InterpolationMode.BICUBIC), \n        transforms.Normalize(mean=(0.5, 0.5, 0.5), std=(0.5, 0.5, 0.5))\n    ])\n    return beit_preprocess(x)\n\ndef init_models(args):\n    tokenizer = AutoTokenizer.from_pretrained(\n        args.version,\n        padding_side=\"right\",\n        use_fast=False,\n    )\n\n    torch_dtype = torch.float32\n    if args.precision == \"bf16\":\n        torch_dtype = torch.bfloat16\n    elif args.precision == \"fp16\":\n        torch_dtype = torch.half\n\n    kwargs = {\"torch_dtype\": torch_dtype}\n    if args.load_in_4bit:\n        kwargs.update(\n            {\n                \"torch_dtype\": torch.half,\n                \"quantization_config\": BitsAndBytesConfig(\n                    llm_int8_skip_modules=[\"visual_model\"],\n                    load_in_4bit=True,\n                    bnb_4bit_compute_dtype=torch.float16,\n                    bnb_4bit_use_double_quant=True,\n                    bnb_4bit_quant_type=\"nf4\",\n                ),\n            }\n        )\n    elif args.load_in_8bit:\n        kwargs.update(\n            {\n                \"torch_dtype\": torch.half,\n                \"quantization_config\": BitsAndBytesConfig(\n                    llm_int8_skip_modules=[\"visual_model\"],\n                    load_in_8bit=True,\n                ),\n            }\n        )\n\n    if args.model_type==\"sam2\":\n        from model.evf_sam2_video import EvfSam2Model\n        model = EvfSam2Model.from_pretrained(\n            args.version, low_cpu_mem_usage=True, **kwargs\n        )\n\n    if (not args.load_in_4bit) and (not args.load_in_8bit):\n        model = model.cuda()\n    model.eval()\n\n    return tokenizer, model\n\ndef main(args):\n    args = parse_args(args)\n    # use float16 for the entire notebook\n    torch.autocast(device_type=\"cuda\", dtype=torch.float16).__enter__()\n\n    if torch.cuda.get_device_properties(0).major >= 8:\n        # turn on tfloat32 for Ampere GPUs (https://pytorch.org/docs/stable/notes/cuda.html#tensorfloat-32-tf32-on-ampere-devices)\n        torch.backends.cuda.matmul.allow_tf32 = True\n        torch.backends.cudnn.allow_tf32 = True\n\n    # clarify IO\n    image_path = args.image_path\n    if not os.path.exists(image_path):\n        print(\"File not found in {}\".format(image_path))\n        exit()\n    prompt = args.prompt\n\n    os.makedirs(args.vis_save_path, exist_ok=True)\n\n    # initialize model and tokenizer\n    tokenizer, model = init_models(args)\n\n    # preprocess    \n    image_np = cv2.imread(image_path+\"/00000.jpg\")\n    image_np = cv2.cvtColor(image_np, cv2.COLOR_BGR2RGB)\n    # original_size_list = [image_np.shape[:2]]\n\n    image_beit = beit3_preprocess(image_np, args.image_size).to(dtype=model.dtype, device=model.device)\n\n    input_ids = tokenizer(prompt, return_tensors=\"pt\")[\"input_ids\"].to(device=model.device)\n\n    # infer\n    output = model.inference(\n        image_path,\n        image_beit.unsqueeze(0),\n        input_ids,\n        # original_size_list=original_size_list,\n    )\n    # save visualization\n    files = os.listdir(image_path)\n    files.sort()\n    for i, file in enumerate(files):\n        img = cv2.imread(os.path.join(image_path, file))\n        out = img + np.array([0,0,128]) * output[i][1].transpose(1,2,0)\n        cv2.imwrite(os.path.join(args.vis_save_path, file), out)\n\nif __name__ == \"__main__\":\n    main(sys.argv[1:])"}
{"type": "source_file", "path": "inference.py", "content": "import argparse\nimport os\nimport sys\n\nimport cv2\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom torchvision import transforms\nfrom torchvision.transforms.functional import InterpolationMode\nfrom transformers import AutoTokenizer, BitsAndBytesConfig\nfrom model.segment_anything.utils.transforms import ResizeLongestSide\n\n\n\ndef parse_args(args):\n    parser = argparse.ArgumentParser(description=\"EVF infer\")\n    parser.add_argument(\"--version\", required=True)\n    parser.add_argument(\"--vis_save_path\", default=\"./infer\", type=str)\n    parser.add_argument(\n        \"--precision\",\n        default=\"fp16\",\n        type=str,\n        choices=[\"fp32\", \"bf16\", \"fp16\"],\n        help=\"precision for inference\",\n    )\n    parser.add_argument(\"--image_size\", default=224, type=int, help=\"image size\")\n    parser.add_argument(\"--model_max_length\", default=512, type=int)\n\n    parser.add_argument(\"--local-rank\", default=0, type=int, help=\"node rank\")\n    parser.add_argument(\"--load_in_8bit\", action=\"store_true\", default=False)\n    parser.add_argument(\"--load_in_4bit\", action=\"store_true\", default=False)\n    parser.add_argument(\"--model_type\", default=\"ori\", choices=[\"ori\", \"effi\", \"sam2\"])\n    parser.add_argument(\"--image_path\", type=str, default=\"assets/zebra.jpg\")\n    parser.add_argument(\"--prompt\", type=str, default=\"zebra top left\")\n    \n    return parser.parse_args(args)\n\n\ndef sam_preprocess(\n    x: np.ndarray,\n    pixel_mean=torch.Tensor([123.675, 116.28, 103.53]).view(-1, 1, 1),\n    pixel_std=torch.Tensor([58.395, 57.12, 57.375]).view(-1, 1, 1),\n    img_size=1024,\n    model_type=\"ori\") -> torch.Tensor:\n    '''\n    preprocess of Segment Anything Model, including scaling, normalization and padding.  \n    preprocess differs between SAM and Effi-SAM, where Effi-SAM use no padding.\n    input: ndarray\n    output: torch.Tensor\n    '''\n    assert img_size==1024, \\\n        \"both SAM and Effi-SAM receive images of size 1024^2, don't change this setting unless you're sure that your employed model works well with another size.\"\n    \n    # Normalize colors\n    if model_type==\"ori\":\n        x = ResizeLongestSide(img_size).apply_image(x)\n        h, w = resize_shape = x.shape[:2]\n        x = torch.from_numpy(x).permute(2,0,1).contiguous()\n        x = (x - pixel_mean) / pixel_std\n        # Pad\n        padh = img_size - h\n        padw = img_size - w\n        x = F.pad(x, (0, padw, 0, padh))\n    else:\n        x = torch.from_numpy(x).permute(2,0,1).contiguous()\n        x = F.interpolate(x.unsqueeze(0), (img_size, img_size), mode=\"bilinear\", align_corners=False).squeeze(0)\n        x = (x - pixel_mean) / pixel_std\n        resize_shape = None\n    \n    return x, resize_shape\n\ndef beit3_preprocess(x: np.ndarray, img_size=224) -> torch.Tensor:\n    '''\n    preprocess for BEIT-3 model.\n    input: ndarray\n    output: torch.Tensor\n    '''\n    beit_preprocess = transforms.Compose([\n        transforms.ToTensor(),\n        transforms.Resize((img_size, img_size), interpolation=InterpolationMode.BICUBIC, antialias=None), \n        transforms.Normalize(mean=(0.5, 0.5, 0.5), std=(0.5, 0.5, 0.5))\n    ])\n    return beit_preprocess(x)\n\ndef init_models(args):\n    tokenizer = AutoTokenizer.from_pretrained(\n        args.version,\n        padding_side=\"right\",\n        use_fast=False,\n    )\n\n    torch_dtype = torch.float32\n    if args.precision == \"bf16\":\n        torch_dtype = torch.bfloat16\n    elif args.precision == \"fp16\":\n        torch_dtype = torch.half\n\n    kwargs = {\"torch_dtype\": torch_dtype}\n    if args.load_in_4bit:\n        kwargs.update(\n            {\n                \"torch_dtype\": torch.half,\n                \"quantization_config\": BitsAndBytesConfig(\n                    llm_int8_skip_modules=[\"visual_model\"],\n                    load_in_4bit=True,\n                    bnb_4bit_compute_dtype=torch.float16,\n                    bnb_4bit_use_double_quant=True,\n                    bnb_4bit_quant_type=\"nf4\",\n                ),\n            }\n        )\n    elif args.load_in_8bit:\n        kwargs.update(\n            {\n                \"torch_dtype\": torch.half,\n                \"quantization_config\": BitsAndBytesConfig(\n                    llm_int8_skip_modules=[\"visual_model\"],\n                    load_in_8bit=True,\n                ),\n            }\n        )\n\n    if args.model_type==\"ori\":\n        from model.evf_sam import EvfSamModel\n        model = EvfSamModel.from_pretrained(\n            args.version, low_cpu_mem_usage=True, **kwargs\n        )\n    elif args.model_type==\"effi\":\n        from model.evf_effisam import EvfEffiSamModel\n        model = EvfEffiSamModel.from_pretrained(\n            args.version, low_cpu_mem_usage=True, **kwargs\n        )\n    elif args.model_type==\"sam2\":\n        from model.evf_sam2 import EvfSam2Model\n        model = EvfSam2Model.from_pretrained(\n            args.version, low_cpu_mem_usage=True, **kwargs\n        )\n\n    if (not args.load_in_4bit) and (not args.load_in_8bit):\n        model = model.cuda()\n    model.eval()\n\n    return tokenizer, model\n\ndef main(args):\n    args = parse_args(args)\n    # use float16 for the entire notebook\n    torch.autocast(device_type=\"cuda\", dtype=torch.float16).__enter__()\n\n    if torch.cuda.get_device_properties(0).major >= 8:\n        # turn on tfloat32 for Ampere GPUs (https://pytorch.org/docs/stable/notes/cuda.html#tensorfloat-32-tf32-on-ampere-devices)\n        torch.backends.cuda.matmul.allow_tf32 = True\n        torch.backends.cudnn.allow_tf32 = True\n\n    # clarify IO\n    image_path = args.image_path\n    if not os.path.exists(image_path):\n        print(\"File not found in {}\".format(image_path))\n        exit()\n    prompt = args.prompt\n\n    os.makedirs(args.vis_save_path, exist_ok=True)\n    save_path = \"{}/{}_vis.png\".format(\n        args.vis_save_path, os.path.basename(image_path).split(\".\")[0]\n    )\n\n    # initialize model and tokenizer\n    tokenizer, model = init_models(args)\n\n    # preprocess\n    image_np = cv2.imread(image_path)\n    image_np = cv2.cvtColor(image_np, cv2.COLOR_BGR2RGB)\n    original_size_list = [image_np.shape[:2]]\n\n    image_beit = beit3_preprocess(image_np, args.image_size).to(dtype=model.dtype, device=model.device)\n\n    image_sam, resize_shape = sam_preprocess(image_np, model_type=args.model_type)\n    image_sam = image_sam.to(dtype=model.dtype, device=model.device)\n\n    input_ids = tokenizer(prompt, return_tensors=\"pt\")[\"input_ids\"].to(device=model.device)\n\n    # infer\n    pred_mask = model.inference(\n        image_sam.unsqueeze(0),\n        image_beit.unsqueeze(0),\n        input_ids,\n        resize_list=[resize_shape],\n        original_size_list=original_size_list,\n    )\n    pred_mask = pred_mask.detach().cpu().numpy()[0]\n    pred_mask = pred_mask > 0\n\n    # save visualization\n    save_img = image_np.copy()\n    save_img[pred_mask] = (\n        image_np * 0.5\n        + pred_mask[:, :, None].astype(np.uint8) * np.array([50, 120, 220]) * 0.5\n    )[pred_mask]\n    save_img = cv2.cvtColor(save_img, cv2.COLOR_RGB2BGR)\n\n    cv2.imwrite(save_path, save_img)\n\nif __name__ == \"__main__\":\n    main(sys.argv[1:])"}
{"type": "source_file", "path": "model/EfficientSAM/efficient_sam/efficient_sam_decoder.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import List, Tuple, Type\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom .mlp import MLPBlock\n\n\nclass PromptEncoder(nn.Module):\n    def __init__(\n        self,\n        embed_dim: int,\n        image_embedding_size: Tuple[int, int],\n        input_image_size: Tuple[int, int],\n    ) -> None:\n        \"\"\"\n        Encodes prompts for input to SAM's mask decoder.\n\n        Arguments:\n          embed_dim (int): The prompts' embedding dimension\n          image_embedding_size (tuple(int, int)): The spatial size of the\n            image embedding, as (H, W).\n          input_image_size (int): The padded size of the image as input\n            to the image encoder, as (H, W).\n        \"\"\"\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.input_image_size = input_image_size\n        self.image_embedding_size = image_embedding_size\n        self.pe_layer = PositionEmbeddingRandom(embed_dim // 2)\n        self.invalid_points = nn.Embedding(1, embed_dim)\n        self.point_embeddings = nn.Embedding(1, embed_dim)\n        self.bbox_top_left_embeddings = nn.Embedding(1, embed_dim)\n        self.bbox_bottom_right_embeddings = nn.Embedding(1, embed_dim)\n\n    def get_dense_pe(self) -> torch.Tensor:\n        \"\"\"\n        Returns the positional encoding used to encode point prompts,\n        applied to a dense set of points the shape of the image encoding.\n\n        Returns:\n          torch.Tensor: Positional encoding with shape\n            1x(embed_dim)x(embedding_h)x(embedding_w)\n        \"\"\"\n        return self.pe_layer(self.image_embedding_size).unsqueeze(0)\n\n    def _embed_points(\n        self,\n        points: torch.Tensor,\n        labels: torch.Tensor,\n    ) -> torch.Tensor:\n        \"\"\"Embeds point prompts.\"\"\"\n\n        points = points + 0.5  # Shift to center of pixel\n        point_embedding = self.pe_layer.forward_with_coords(\n            points, self.input_image_size\n        )\n        invalid_label_ids = torch.eq(labels, -1)[:,:,None]\n        point_label_ids = torch.eq(labels, 1)[:,:,None]\n        topleft_label_ids = torch.eq(labels, 2)[:,:,None]\n        bottomright_label_ids = torch.eq(labels, 3)[:,:,None]\n        point_embedding = point_embedding + self.invalid_points.weight[:,None,:] * invalid_label_ids\n        point_embedding = point_embedding + self.point_embeddings.weight[:,None,:] * point_label_ids\n        point_embedding = point_embedding + self.bbox_top_left_embeddings.weight[:,None,:] * topleft_label_ids\n        point_embedding = point_embedding + self.bbox_bottom_right_embeddings.weight[:,None,:] * bottomright_label_ids\n        return point_embedding\n\n    def forward(\n        self,\n        coords,\n        labels,\n    ) -> torch.Tensor:\n        \"\"\"\n        Embeds different types of prompts, returning both sparse and dense\n        embeddings.\n\n        Arguments:\n          points: A tensor of shape [B, 2]\n          labels: An integer tensor of shape [B] where each element is 1,2 or 3.\n\n        Returns:\n          torch.Tensor: sparse embeddings for the points and boxes, with shape\n            BxNx(embed_dim), where N is determined by the number of input points\n            and boxes.\n        \"\"\"\n        return self._embed_points(coords, labels)\n\n\nclass PositionEmbeddingRandom(nn.Module):\n    \"\"\"\n    Positional encoding using random spatial frequencies.\n    \"\"\"\n\n    def __init__(self, num_pos_feats: int) -> None:\n        super().__init__()\n        self.register_buffer(\n            \"positional_encoding_gaussian_matrix\", torch.randn((2, num_pos_feats))\n        )\n\n    def _pe_encoding(self, coords: torch.Tensor) -> torch.Tensor:\n        \"\"\"Positionally encode points that are normalized to [0,1].\"\"\"\n        # assuming coords are in [0, 1]^2 square and have d_1 x ... x d_n x 2 shape\n        coords = 2 * coords - 1\n        coords = coords @ self.positional_encoding_gaussian_matrix\n        coords = 2 * np.pi * coords\n        # outputs d_1 x ... x d_n x C shape\n        return torch.cat([torch.sin(coords), torch.cos(coords)], dim=-1)\n\n    def forward(self, size: Tuple[int, int]) -> torch.Tensor:\n        \"\"\"Generate positional encoding for a grid of the specified size.\"\"\"\n        h, w = size\n        device = self.positional_encoding_gaussian_matrix.device\n        grid = torch.ones([h, w], device=device, dtype=self.positional_encoding_gaussian_matrix.dtype)\n        y_embed = grid.cumsum(dim=0) - 0.5\n        x_embed = grid.cumsum(dim=1) - 0.5\n        y_embed = y_embed / h\n        x_embed = x_embed / w\n\n        pe = self._pe_encoding(torch.stack([x_embed, y_embed], dim=-1))\n        return pe.permute(2, 0, 1)  # C x H x W\n\n    def forward_with_coords(\n        self, coords_input: torch.Tensor, image_size: Tuple[int, int]\n    ) -> torch.Tensor:\n        \"\"\"Positionally encode points that are not normalized to [0,1].\"\"\"\n        coords = coords_input.clone()\n        coords[:, :, 0] = coords[:, :, 0] / image_size[1]\n        coords[:, :, 1] = coords[:, :, 1] / image_size[0]\n        # remove to(float) here, don't know why original implementation add this\n        return self._pe_encoding(coords)  # B x N x C\n\n\nclass MaskDecoder(nn.Module):\n    def __init__(\n        self,\n        *,\n        transformer_dim: int,\n        transformer: nn.Module,\n        num_multimask_outputs: int,\n        activation: Type[nn.Module],\n        normalization_type: str,\n        normalize_before_activation: bool,\n        iou_head_depth: int,\n        iou_head_hidden_dim: int,\n        upscaling_layer_dims: List[int],\n    ) -> None:\n        \"\"\"\n        Predicts masks given an image and prompt embeddings, using a\n        transformer architecture.\n\n        Arguments:\n          transformer_dim (int): the channel dimension of the transformer\n          transformer (nn.Module): the transformer used to predict masks\n          num_multimask_outputs (int): the number of masks to predict\n            when disambiguating masks\n          activation (nn.Module): the type of activation to use when\n            upscaling masks\n          iou_head_depth (int): the depth of the MLP used to predict\n            mask quality\n          iou_head_hidden_dim (int): the hidden dimension of the MLP\n            used to predict mask quality\n        \"\"\"\n        super().__init__()\n        self.transformer_dim = transformer_dim\n        self.transformer = transformer\n\n        self.num_multimask_outputs = num_multimask_outputs\n\n        self.iou_token = nn.Embedding(1, transformer_dim)\n        if num_multimask_outputs > 1:\n            self.num_mask_tokens = num_multimask_outputs + 1\n        else:\n            self.num_mask_tokens = 1\n        self.mask_tokens = nn.Embedding(self.num_mask_tokens, transformer_dim)\n        output_dim_after_upscaling = transformer_dim\n\n        self.final_output_upscaling_layers = nn.ModuleList([])\n        for idx, layer_dims in enumerate(upscaling_layer_dims):\n            self.final_output_upscaling_layers.append(\n                nn.Sequential(\n                    nn.ConvTranspose2d(\n                        output_dim_after_upscaling,\n                        layer_dims,\n                        kernel_size=2,\n                        stride=2,\n                    ),\n                    nn.GroupNorm(1, layer_dims)\n                    if idx < len(upscaling_layer_dims) - 1\n                    else nn.Identity(),\n                    activation(),\n                )\n            )\n            output_dim_after_upscaling = layer_dims\n\n        self.output_hypernetworks_mlps = nn.ModuleList(\n            [\n                MLPBlock(\n                    input_dim=transformer_dim,\n                    hidden_dim=transformer_dim,\n                    output_dim=output_dim_after_upscaling,\n                    num_layers=2,\n                    act=activation,\n                )\n                for i in range(self.num_mask_tokens)\n            ]\n        )\n\n        self.iou_prediction_head = MLPBlock(\n            input_dim=transformer_dim,\n            hidden_dim=iou_head_hidden_dim,\n            output_dim=self.num_mask_tokens,\n            num_layers=iou_head_depth,\n            act=activation,\n        )\n\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        multimask_output: bool,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks given image and prompt embeddings.\n\n        Arguments:\n          image_embeddings: A tensor of shape [B, C, H, W] or [B*max_num_queries, C, H, W]\n          image_pe (torch.Tensor): positional encoding with the shape of image_embeddings (the batch dimension is broadcastable).\n          sparse_prompt_embeddings (torch.Tensor): the embeddings of the points and boxes\n          multimask_output (bool): Whether to return multiple masks or a single\n            mask.\n\n        Returns:\n          torch.Tensor: batched predicted masks\n          torch.Tensor: batched predictions of mask quality\n        \"\"\"\n\n        (\n            batch_size,\n            max_num_queries,\n            sparse_embed_dim_1,\n            sparse_embed_dim_2,\n        ) = sparse_prompt_embeddings.shape\n\n        (\n            _,\n            image_embed_dim_c,\n            image_embed_dim_h,\n            image_embed_dim_w,\n        ) = image_embeddings.shape\n\n        # Tile the image embedding for all queries.\n        image_embeddings_tiled = torch.tile(\n            image_embeddings[:, None, :, :, :], [1, max_num_queries, 1, 1, 1]\n        ).view(\n            batch_size * max_num_queries,\n            image_embed_dim_c,\n            image_embed_dim_h,\n            image_embed_dim_w,\n        )\n        sparse_prompt_embeddings = sparse_prompt_embeddings.reshape(\n            batch_size * max_num_queries, sparse_embed_dim_1, sparse_embed_dim_2\n        )\n        masks, iou_pred = self.predict_masks(\n            image_embeddings=image_embeddings_tiled,\n            image_pe=image_pe,\n            sparse_prompt_embeddings=sparse_prompt_embeddings,\n        )\n\n        if multimask_output and self.num_multimask_outputs > 1:\n            return masks[:, 1:, :], iou_pred[:, 1:]\n        else:\n            return masks[:, :1, :], iou_pred[:, :1]\n\n    def predict_masks(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"Predicts masks. See 'forward' for more details.\"\"\"\n        # Concatenate output tokens\n        output_tokens = torch.cat(\n            [self.iou_token.weight, self.mask_tokens.weight], dim=0\n        )\n        output_tokens = output_tokens.unsqueeze(0).expand(\n            sparse_prompt_embeddings.size(0), -1, -1\n        )\n        tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)\n        # Expand per-image data in batch direction to be per-mask\n        pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)\n        b, c, h, w = image_embeddings.shape\n        hs, src = self.transformer(image_embeddings, pos_src, tokens)\n        iou_token_out = hs[:, 0, :]\n        mask_tokens_out = hs[:, 1 : (1 + self.num_mask_tokens), :]\n\n        # Upscale mask embeddings and predict masks using the mask tokens\n        upscaled_embedding = src.transpose(1, 2).view(b, c, h, w)\n\n        for upscaling_layer in self.final_output_upscaling_layers:\n            upscaled_embedding = upscaling_layer(upscaled_embedding)\n        hyper_in_list: List[torch.Tensor] = []\n        for i, output_hypernetworks_mlp in enumerate(self.output_hypernetworks_mlps):\n            hyper_in_list.append(output_hypernetworks_mlp(mask_tokens_out[:, i, :]))\n        hyper_in = torch.stack(hyper_in_list, dim=1)\n        b, c, h, w = upscaled_embedding.shape\n        masks = (hyper_in @ upscaled_embedding.view(b, c, h * w)).view(b, -1, h, w)\n        # Generate mask quality predictions\n        iou_pred = self.iou_prediction_head(iou_token_out)\n        return masks, iou_pred\n"}
{"type": "source_file", "path": "frame2video.py", "content": "import cv2\nimport os\n \n#\nfolder_path = 'vis/elephant'#\n \n#.jpg\nimage_files = sorted(os.listdir(folder_path))\n \n#\nimage_path = os.path.join(folder_path,image_files[0])\nfirst_image = cv2.imread(image_path)\nheight,width,channels = first_image.shape\n \n#\noutput_path = 'vis/elephant.mp4'\nfps = 30.0 #\nfourcc = cv2.VideoWriter_fourcc(*'mp4v') #\n \n#\nvideo_writer = cv2.VideoWriter(output_path,fourcc,fps,(width,height))\n \n#\nfor image_file in image_files:\n    image_path = os.path.join(folder_path,image_file)\n    image = cv2.imread(image_path)\n    video_writer.write(image)\n \n#\nvideo_writer.release()"}
{"type": "source_file", "path": "model/segment_anything/modeling/prompt_encoder.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Any, Optional, Tuple, Type\n\nimport numpy as np\nimport torch\nfrom torch import nn\n\nfrom .common import LayerNorm2d\n\n\nclass PromptEncoder(nn.Module):\n    def __init__(\n        self,\n        embed_dim: int,\n        image_embedding_size: Tuple[int, int],\n        input_image_size: Tuple[int, int],\n        mask_in_chans: int,\n        activation: Type[nn.Module] = nn.GELU,\n    ) -> None:\n        \"\"\"\n        Encodes prompts for input to SAM's mask decoder.\n\n        Arguments:\n          embed_dim (int): The prompts' embedding dimension\n          image_embedding_size (tuple(int, int)): The spatial size of the\n            image embedding, as (H, W).\n          input_image_size (int): The padded size of the image as input\n            to the image encoder, as (H, W).\n          mask_in_chans (int): The number of hidden channels used for\n            encoding input masks.\n          activation (nn.Module): The activation to use when encoding\n            input masks.\n        \"\"\"\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.input_image_size = input_image_size\n        self.image_embedding_size = image_embedding_size\n        self.pe_layer = PositionEmbeddingRandom(embed_dim // 2)\n\n        self.num_point_embeddings: int = 4  # pos/neg point + 2 box corners\n        point_embeddings = [\n            nn.Embedding(1, embed_dim) for i in range(self.num_point_embeddings)\n        ]\n        self.point_embeddings = nn.ModuleList(point_embeddings)\n        self.not_a_point_embed = nn.Embedding(1, embed_dim)\n\n        self.mask_input_size = (\n            4 * image_embedding_size[0],\n            4 * image_embedding_size[1],\n        )\n        self.mask_downscaling = nn.Sequential(\n            nn.Conv2d(1, mask_in_chans // 4, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans // 4),\n            activation(),\n            nn.Conv2d(mask_in_chans // 4, mask_in_chans, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans),\n            activation(),\n            nn.Conv2d(mask_in_chans, embed_dim, kernel_size=1),\n        )\n        self.no_mask_embed = nn.Embedding(1, embed_dim)\n\n    def get_dense_pe(self) -> torch.Tensor:\n        \"\"\"\n        Returns the positional encoding used to encode point prompts,\n        applied to a dense set of points the shape of the image encoding.\n\n        Returns:\n          torch.Tensor: Positional encoding with shape\n            1x(embed_dim)x(embedding_h)x(embedding_w)\n        \"\"\"\n        return self.pe_layer(self.image_embedding_size).unsqueeze(0)\n\n    def _embed_points(\n        self,\n        points: torch.Tensor,\n        labels: torch.Tensor,\n        pad: bool,\n    ) -> torch.Tensor:\n        \"\"\"Embeds point prompts.\"\"\"\n        points = points + 0.5  # Shift to center of pixel\n        if pad:\n            padding_point = torch.zeros((points.shape[0], 1, 2), device=points.device)\n            padding_label = -torch.ones((labels.shape[0], 1), device=labels.device)\n            points = torch.cat([points, padding_point], dim=1)\n            labels = torch.cat([labels, padding_label], dim=1)\n        point_embedding = self.pe_layer.forward_with_coords(\n            points, self.input_image_size\n        )\n        point_embedding[labels == -1] = 0.0\n        point_embedding[labels == -1] += self.not_a_point_embed.weight\n        point_embedding[labels == 0] += self.point_embeddings[0].weight\n        point_embedding[labels == 1] += self.point_embeddings[1].weight\n        return point_embedding\n\n    def _embed_boxes(self, boxes: torch.Tensor) -> torch.Tensor:\n        \"\"\"Embeds box prompts.\"\"\"\n        boxes = boxes + 0.5  # Shift to center of pixel\n        coords = boxes.reshape(-1, 2, 2)\n        corner_embedding = self.pe_layer.forward_with_coords(\n            coords, self.input_image_size\n        )\n        corner_embedding[:, 0, :] += self.point_embeddings[2].weight\n        corner_embedding[:, 1, :] += self.point_embeddings[3].weight\n        return corner_embedding\n\n    def _embed_masks(self, masks: torch.Tensor) -> torch.Tensor:\n        \"\"\"Embeds mask inputs.\"\"\"\n        mask_embedding = self.mask_downscaling(masks)\n        return mask_embedding\n\n    def _get_batch_size(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n        text_embeds: Optional[torch.Tensor],\n    ) -> int:\n        \"\"\"\n        Gets the batch size of the output given the batch size of the input prompts.\n        \"\"\"\n        if points is not None:\n            return points[0].shape[0]\n        elif boxes is not None:\n            return boxes.shape[0]\n        elif masks is not None:\n            return masks.shape[0]\n        elif text_embeds is not None:\n            return text_embeds.shape[0]\n        else:\n            return 1\n\n    def _get_device(self) -> torch.device:\n        return self.point_embeddings[0].weight.device\n\n    def forward(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n        text_embeds: Optional[torch.Tensor],\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Embeds different types of prompts, returning both sparse and dense\n        embeddings.\n\n        Arguments:\n          points (tuple(torch.Tensor, torch.Tensor) or none): point coordinates\n            and labels to embed.\n          boxes (torch.Tensor or none): boxes to embed\n          masks (torch.Tensor or none): masks to embed\n\n        Returns:\n          torch.Tensor: sparse embeddings for the points and boxes, with shape\n            BxNx(embed_dim), where N is determined by the number of input points\n            and boxes.\n          torch.Tensor: dense embeddings for the masks, in the shape\n            Bx(embed_dim)x(embed_H)x(embed_W)\n        \"\"\"\n        bs = self._get_batch_size(points, boxes, masks, text_embeds)\n        sparse_embeddings = torch.empty(\n            (bs, 0, self.embed_dim), device=self._get_device()\n        )\n        if points is not None:\n            coords, labels = points\n            point_embeddings = self._embed_points(coords, labels, pad=(boxes is None))\n            sparse_embeddings = torch.cat([sparse_embeddings, point_embeddings], dim=1)\n        if boxes is not None:\n            box_embeddings = self._embed_boxes(boxes)\n            sparse_embeddings = torch.cat([sparse_embeddings, box_embeddings], dim=1)\n\n        if text_embeds is not None:\n            sparse_embeddings = torch.cat([sparse_embeddings, text_embeds], dim=1)\n\n        if masks is not None:\n            dense_embeddings = self._embed_masks(masks)\n        else:\n            dense_embeddings = self.no_mask_embed.weight.reshape(1, -1, 1, 1).expand(\n                bs, -1, self.image_embedding_size[0], self.image_embedding_size[1]\n            )\n\n        return sparse_embeddings, dense_embeddings\n\n\nclass PositionEmbeddingRandom(nn.Module):\n    \"\"\"\n    Positional encoding using random spatial frequencies.\n    \"\"\"\n\n    def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -> None:\n        super().__init__()\n        if scale is None or scale <= 0.0:\n            scale = 1.0\n        self.register_buffer(\n            \"positional_encoding_gaussian_matrix\",\n            scale * torch.randn((2, num_pos_feats)),\n        )\n\n    def _pe_encoding(self, coords: torch.Tensor) -> torch.Tensor:\n        \"\"\"Positionally encode points that are normalized to [0,1].\"\"\"\n        # assuming coords are in [0, 1]^2 square and have d_1 x ... x d_n x 2 shape\n        coords = 2 * coords - 1\n\n        if coords.dtype != self.positional_encoding_gaussian_matrix.dtype:\n            coords = coords.to(self.positional_encoding_gaussian_matrix.dtype)\n\n        coords = coords @ self.positional_encoding_gaussian_matrix\n        coords = 2 * np.pi * coords\n        # outputs d_1 x ... x d_n x C shape\n        return torch.cat([torch.sin(coords), torch.cos(coords)], dim=-1)\n\n    def forward(self, size: Tuple[int, int]) -> torch.Tensor:\n        \"\"\"Generate positional encoding for a grid of the specified size.\"\"\"\n        h, w = size\n        device: Any = self.positional_encoding_gaussian_matrix.device\n        grid = torch.ones(\n            (h, w), device=device, dtype=self.positional_encoding_gaussian_matrix.dtype\n        )\n        y_embed = grid.cumsum(dim=0) - 0.5\n        x_embed = grid.cumsum(dim=1) - 0.5\n        y_embed = y_embed / h\n        x_embed = x_embed / w\n\n        pe = self._pe_encoding(torch.stack([x_embed, y_embed], dim=-1))\n        return pe.permute(2, 0, 1)  # C x H x W\n\n    def forward_with_coords(\n        self, coords_input: torch.Tensor, image_size: Tuple[int, int]\n    ) -> torch.Tensor:\n        \"\"\"Positionally encode points that are not normalized to [0,1].\"\"\"\n        coords = coords_input.clone()\n        coords[:, :, 0] = coords[:, :, 0] / image_size[1]\n        coords[:, :, 1] = coords[:, :, 1] / image_size[0]\n        return self._pe_encoding(coords.to(torch.float))  # B x N x C\n"}
{"type": "source_file", "path": "model/segment_anything/modeling/common.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Type\n\nimport torch\nimport torch.nn as nn\n\n\nclass MLPBlock(nn.Module):\n    def __init__(\n        self,\n        embedding_dim: int,\n        mlp_dim: int,\n        act: Type[nn.Module] = nn.GELU,\n    ) -> None:\n        super().__init__()\n        self.lin1 = nn.Linear(embedding_dim, mlp_dim)\n        self.lin2 = nn.Linear(mlp_dim, embedding_dim)\n        self.act = act()\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        return self.lin2(self.act(self.lin1(x)))\n\n\n# From https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py # noqa\n# Itself from https://github.com/facebookresearch/ConvNeXt/blob/d1fa8f6fef0a165b27399986cc2bdacc92777e40/models/convnext.py#L119  # noqa\nclass LayerNorm2d(nn.Module):\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        x = self.weight[:, None, None] * x + self.bias[:, None, None]\n        return x\n"}
{"type": "source_file", "path": "model/EfficientSAM/efficient_sam/two_way_transformer.py", "content": "import math\nfrom typing import Tuple, Type\nimport torch\nfrom torch import nn, Tensor\nfrom .mlp import MLPBlock\n\n\n\n\nclass TwoWayTransformer(nn.Module):\n    def __init__(\n        self,\n        depth: int,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int,\n        activation: Type[nn.Module],\n        normalize_before_activation: bool,\n        attention_downsample_rate: int = 2,\n    ) -> None:\n        \"\"\"\n        A transformer decoder that attends to an input image using\n        queries whose positional embedding is supplied.\n\n        Args:\n          depth (int): number of layers in the transformer\n          embedding_dim (int): the channel dimension for the input embeddings\n          num_heads (int): the number of heads for multihead attention. Must\n            divide embedding_dim\n          mlp_dim (int): the channel dimension internal to the MLP block\n          activation (nn.Module): the activation to use in the MLP block\n        \"\"\"\n        super().__init__()\n        self.depth = depth\n        self.embedding_dim = embedding_dim\n        self.num_heads = num_heads\n        self.mlp_dim = mlp_dim\n        self.layers = nn.ModuleList()\n\n        for i in range(depth):\n            curr_layer = TwoWayAttentionBlock(\n                embedding_dim=embedding_dim,\n                num_heads=num_heads,\n                mlp_dim=mlp_dim,\n                activation=activation,\n                normalize_before_activation=normalize_before_activation,\n                attention_downsample_rate=attention_downsample_rate,\n                skip_first_layer_pe=(i == 0),\n            )\n            self.layers.append(curr_layer)\n\n        self.final_attn_token_to_image = AttentionForTwoWayAttentionBlock(\n            embedding_dim,\n            num_heads,\n            downsample_rate=attention_downsample_rate,\n        )\n        self.norm_final_attn = nn.LayerNorm(embedding_dim)\n\n    def forward(\n        self,\n        image_embedding: Tensor,\n        image_pe: Tensor,\n        point_embedding: Tensor,\n    ) -> Tuple[Tensor, Tensor]:\n        \"\"\"\n        Args:\n          image_embedding (torch.Tensor): image to attend to. Should be shape\n            B x embedding_dim x h x w for any h and w.\n          image_pe (torch.Tensor): the positional encoding to add to the image. Must\n            have the same shape as image_embedding.\n          point_embedding (torch.Tensor): the embedding to add to the query points.\n            Must have shape B x N_points x embedding_dim for any N_points.\n\n        Returns:\n          torch.Tensor: the processed point_embedding\n          torch.Tensor: the processed image_embedding\n        \"\"\"\n\n        # BxCxHxW -> BxHWxC == B x N_image_tokens x C\n        bs, c, h, w = image_embedding.shape\n        image_embedding = image_embedding.flatten(2).permute(0, 2, 1)\n        image_pe = image_pe.flatten(2).permute(0, 2, 1)\n\n        # Prepare queries\n        queries = point_embedding\n        keys = image_embedding\n\n        # Apply transformer blocks and final layernorm\n        for idx, layer in enumerate(self.layers):\n            queries, keys = layer(\n                queries=queries,\n                keys=keys,\n                query_pe=point_embedding,\n                key_pe=image_pe,\n            )\n\n        # Apply the final attention layer from the points to the image\n        q = queries + point_embedding\n        k = keys + image_pe\n        attn_out = self.final_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm_final_attn(queries)\n        return queries, keys\n\n\nclass TwoWayAttentionBlock(nn.Module):\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int,\n        activation: Type[nn.Module],\n        normalize_before_activation: bool,\n        attention_downsample_rate: int = 2,\n        skip_first_layer_pe: bool = False,\n    ) -> None:\n        \"\"\"\n        A transformer block with four layers: (1) self-attention of sparse\n        inputs, (2) cross attention of sparse inputs to dense inputs, (3) mlp\n        block on sparse inputs, and (4) cross attention of dense inputs to sparse\n        inputs.\n\n        Arguments:\n          embedding_dim (int): the channel dimension of the embeddings\n          num_heads (int): the number of heads in the attention layers\n          mlp_dim (int): the hidden dimension of the mlp block\n          activation (nn.Module): the activation of the mlp block\n          skip_first_layer_pe (bool): skip the PE on the first layer\n        \"\"\"\n        super().__init__()\n        self.self_attn = AttentionForTwoWayAttentionBlock(embedding_dim, num_heads)\n        self.norm1 = nn.LayerNorm(embedding_dim)\n\n        self.cross_attn_token_to_image = AttentionForTwoWayAttentionBlock(\n            embedding_dim,\n            num_heads,\n            downsample_rate=attention_downsample_rate,\n        )\n        self.norm2 = nn.LayerNorm(embedding_dim)\n\n        self.mlp = MLPBlock(\n            embedding_dim,\n            mlp_dim,\n            embedding_dim,\n            1,\n            activation,\n        )\n\n        self.norm3 = nn.LayerNorm(embedding_dim)\n\n        self.norm4 = nn.LayerNorm(embedding_dim)\n        self.cross_attn_image_to_token = AttentionForTwoWayAttentionBlock(\n            embedding_dim,\n            num_heads,\n            downsample_rate=attention_downsample_rate,\n        )\n\n        self.skip_first_layer_pe = skip_first_layer_pe\n\n    def forward(\n        self, queries: Tensor, keys: Tensor, query_pe: Tensor, key_pe: Tensor\n    ) -> Tuple[Tensor, Tensor]:\n        # Self attention block\n        if not self.skip_first_layer_pe:\n            queries = queries + query_pe\n        attn_out = self.self_attn(q=queries, k=queries, v=queries)\n        queries = queries + attn_out\n        queries = self.norm1(queries)\n\n        # Cross attention block, tokens attending to image embedding\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm2(queries)\n\n        # MLP block\n        mlp_out = self.mlp(queries)\n        queries = queries + mlp_out\n        queries = self.norm3(queries)\n\n        # Cross attention block, image embedding attending to tokens\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_image_to_token(q=k, k=q, v=queries)\n        keys = keys + attn_out\n        keys = self.norm4(keys)\n\n        return queries, keys\n\n\nclass AttentionForTwoWayAttentionBlock(nn.Module):\n    \"\"\"\n    An attention layer that allows for downscaling the size of the embedding\n    after projection to queries, keys, and values.\n    \"\"\"\n\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        downsample_rate: int = 1,\n    ) -> None:\n        super().__init__()\n        self.embedding_dim = embedding_dim\n        self.internal_dim = embedding_dim // downsample_rate\n        self.num_heads = num_heads\n        assert (\n            self.internal_dim % num_heads == 0\n        ), \"num_heads must divide embedding_dim.\"\n        self.c_per_head = self.internal_dim / num_heads\n        self.inv_sqrt_c_per_head = 1.0 / math.sqrt(self.c_per_head)\n\n        self.q_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.k_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.v_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.out_proj = nn.Linear(self.internal_dim, embedding_dim)\n        self._reset_parameters()\n\n    def _reset_parameters(self) -> None:\n        # The fan_out is incorrect, but matches pytorch's initialization\n        # for which qkv is a single 3*embedding_dim x embedding_dim matrix\n        fan_in = self.embedding_dim\n        fan_out = 3 * self.internal_dim\n        # Xavier uniform with our custom fan_out\n        bnd = math.sqrt(6 / (fan_in + fan_out))\n        nn.init.uniform_(self.q_proj.weight, -bnd, bnd)\n        nn.init.uniform_(self.k_proj.weight, -bnd, bnd)\n        nn.init.uniform_(self.v_proj.weight, -bnd, bnd)\n        # out_proj.weight is left with default initialization, like pytorch attention\n        nn.init.zeros_(self.q_proj.bias)\n        nn.init.zeros_(self.k_proj.bias)\n        nn.init.zeros_(self.v_proj.bias)\n        nn.init.zeros_(self.out_proj.bias)\n\n    def _separate_heads(self, x: Tensor, num_heads: int) -> Tensor:\n        b, n, c = x.shape\n        x = x.reshape(b, n, num_heads, c // num_heads)\n        return x.transpose(1, 2)  # B x N_heads x N_tokens x C_per_head\n\n    def _recombine_heads(self, x: Tensor) -> Tensor:\n        b, n_heads, n_tokens, c_per_head = x.shape\n        x = x.transpose(1, 2)\n        return x.reshape(b, n_tokens, n_heads * c_per_head)  # B x N_tokens x C\n\n    def forward(self, q: Tensor, k: Tensor, v: Tensor) -> Tensor:\n        # Input projections\n        q = self.q_proj(q)\n        k = self.k_proj(k)\n        v = self.v_proj(v)\n\n        # Separate into heads\n        q = self._separate_heads(q, self.num_heads)\n        k = self._separate_heads(k, self.num_heads)\n        v = self._separate_heads(v, self.num_heads)\n\n        # Attention\n        _, _, _, c_per_head = q.shape\n        attn = q @ k.permute(0, 1, 3, 2)  # B x N_heads x N_tokens x N_tokens\n        attn = attn * self.inv_sqrt_c_per_head\n        attn = torch.softmax(attn, dim=-1)\n        # Get output\n        out = attn @ v\n        out = self._recombine_heads(out)\n        out = self.out_proj(out)\n        return out\n"}
{"type": "source_file", "path": "model/segment_anything/automatic_mask_generator.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport numpy as np\nimport torch\nfrom torchvision.ops.boxes import batched_nms, box_area  # type: ignore\n\nfrom .modeling import Sam\nfrom .predictor import SamPredictor\nfrom .utils.amg import (MaskData, area_from_rle, batch_iterator,\n                        batched_mask_to_box, box_xyxy_to_xywh,\n                        build_all_layer_point_grids, calculate_stability_score,\n                        coco_encode_rle, generate_crop_boxes,\n                        is_box_near_crop_edge, mask_to_rle_pytorch,\n                        remove_small_regions, rle_to_mask, uncrop_boxes_xyxy,\n                        uncrop_masks, uncrop_points)\n\n\nclass SamAutomaticMaskGenerator:\n    def __init__(\n        self,\n        model: Sam,\n        points_per_side: Optional[int] = 32,\n        points_per_batch: int = 64,\n        pred_iou_thresh: float = 0.88,\n        stability_score_thresh: float = 0.95,\n        stability_score_offset: float = 1.0,\n        box_nms_thresh: float = 0.7,\n        crop_n_layers: int = 0,\n        crop_nms_thresh: float = 0.7,\n        crop_overlap_ratio: float = 512 / 1500,\n        crop_n_points_downscale_factor: int = 1,\n        point_grids: Optional[List[np.ndarray]] = None,\n        min_mask_region_area: int = 0,\n        output_mode: str = \"binary_mask\",\n    ) -> None:\n        \"\"\"\n        Using a SAM model, generates masks for the entire image.\n        Generates a grid of point prompts over the image, then filters\n        low quality and duplicate masks. The default settings are chosen\n        for SAM with a ViT-H backbone.\n\n        Arguments:\n          model (Sam): The SAM model to use for mask prediction.\n          points_per_side (int or None): The number of points to be sampled\n            along one side of the image. The total number of points is\n            points_per_side**2. If None, 'point_grids' must provide explicit\n            point sampling.\n          points_per_batch (int): Sets the number of points run simultaneously\n            by the model. Higher numbers may be faster but use more GPU memory.\n          pred_iou_thresh (float): A filtering threshold in [0,1], using the\n            model's predicted mask quality.\n          stability_score_thresh (float): A filtering threshold in [0,1], using\n            the stability of the mask under changes to the cutoff used to binarize\n            the model's mask predictions.\n          stability_score_offset (float): The amount to shift the cutoff when\n            calculated the stability score.\n          box_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks.\n          crop_n_layers (int): If >0, mask prediction will be run again on\n            crops of the image. Sets the number of layers to run, where each\n            layer has 2**i_layer number of image crops.\n          crop_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks between different crops.\n          crop_overlap_ratio (float): Sets the degree to which crops overlap.\n            In the first crop layer, crops will overlap by this fraction of\n            the image length. Later layers with more crops scale down this overlap.\n          crop_n_points_downscale_factor (int): The number of points-per-side\n            sampled in layer n is scaled down by crop_n_points_downscale_factor**n.\n          point_grids (list(np.ndarray) or None): A list over explicit grids\n            of points used for sampling, normalized to [0,1]. The nth grid in the\n            list is used in the nth crop layer. Exclusive with points_per_side.\n          min_mask_region_area (int): If >0, postprocessing will be applied\n            to remove disconnected regions and holes in masks with area smaller\n            than min_mask_region_area. Requires opencv.\n          output_mode (str): The form masks are returned in. Can be 'binary_mask',\n            'uncompressed_rle', or 'coco_rle'. 'coco_rle' requires pycocotools.\n            For large resolutions, 'binary_mask' may consume large amounts of\n            memory.\n        \"\"\"\n\n        assert (points_per_side is None) != (\n            point_grids is None\n        ), \"Exactly one of points_per_side or point_grid must be provided.\"\n        if points_per_side is not None:\n            self.point_grids = build_all_layer_point_grids(\n                points_per_side,\n                crop_n_layers,\n                crop_n_points_downscale_factor,\n            )\n        elif point_grids is not None:\n            self.point_grids = point_grids\n        else:\n            raise ValueError(\"Can't have both points_per_side and point_grid be None.\")\n\n        assert output_mode in [\n            \"binary_mask\",\n            \"uncompressed_rle\",\n            \"coco_rle\",\n        ], f\"Unknown output_mode {output_mode}.\"\n        if output_mode == \"coco_rle\":\n            from pycocotools import \\\n                mask as mask_utils  # type: ignore # noqa: F401\n\n        if min_mask_region_area > 0:\n            import cv2  # type: ignore # noqa: F401\n\n        self.predictor = SamPredictor(model)\n        self.points_per_batch = points_per_batch\n        self.pred_iou_thresh = pred_iou_thresh\n        self.stability_score_thresh = stability_score_thresh\n        self.stability_score_offset = stability_score_offset\n        self.box_nms_thresh = box_nms_thresh\n        self.crop_n_layers = crop_n_layers\n        self.crop_nms_thresh = crop_nms_thresh\n        self.crop_overlap_ratio = crop_overlap_ratio\n        self.crop_n_points_downscale_factor = crop_n_points_downscale_factor\n        self.min_mask_region_area = min_mask_region_area\n        self.output_mode = output_mode\n\n    @torch.no_grad()\n    def generate(self, image: np.ndarray) -> List[Dict[str, Any]]:\n        \"\"\"\n        Generates masks for the given image.\n\n        Arguments:\n          image (np.ndarray): The image to generate masks for, in HWC uint8 format.\n\n        Returns:\n           list(dict(str, any)): A list over records for masks. Each record is\n             a dict containing the following keys:\n               segmentation (dict(str, any) or np.ndarray): The mask. If\n                 output_mode='binary_mask', is an array of shape HW. Otherwise,\n                 is a dictionary containing the RLE.\n               bbox (list(float)): The box around the mask, in XYWH format.\n               area (int): The area in pixels of the mask.\n               predicted_iou (float): The model's own prediction of the mask's\n                 quality. This is filtered by the pred_iou_thresh parameter.\n               point_coords (list(list(float))): The point coordinates input\n                 to the model to generate this mask.\n               stability_score (float): A measure of the mask's quality. This\n                 is filtered on using the stability_score_thresh parameter.\n               crop_box (list(float)): The crop of the image used to generate\n                 the mask, given in XYWH format.\n        \"\"\"\n\n        # Generate masks\n        mask_data = self._generate_masks(image)\n\n        # Filter small disconnected regions and holes in masks\n        if self.min_mask_region_area > 0:\n            mask_data = self.postprocess_small_regions(\n                mask_data,\n                self.min_mask_region_area,\n                max(self.box_nms_thresh, self.crop_nms_thresh),\n            )\n\n        # Encode masks\n        if self.output_mode == \"coco_rle\":\n            mask_data[\"segmentations\"] = [\n                coco_encode_rle(rle) for rle in mask_data[\"rles\"]\n            ]\n        elif self.output_mode == \"binary_mask\":\n            mask_data[\"segmentations\"] = [rle_to_mask(rle) for rle in mask_data[\"rles\"]]\n        else:\n            mask_data[\"segmentations\"] = mask_data[\"rles\"]\n\n        # Write mask records\n        curr_anns = []\n        for idx in range(len(mask_data[\"segmentations\"])):\n            ann = {\n                \"segmentation\": mask_data[\"segmentations\"][idx],\n                \"area\": area_from_rle(mask_data[\"rles\"][idx]),\n                \"bbox\": box_xyxy_to_xywh(mask_data[\"boxes\"][idx]).tolist(),\n                \"predicted_iou\": mask_data[\"iou_preds\"][idx].item(),\n                \"point_coords\": [mask_data[\"points\"][idx].tolist()],\n                \"stability_score\": mask_data[\"stability_score\"][idx].item(),\n                \"crop_box\": box_xyxy_to_xywh(mask_data[\"crop_boxes\"][idx]).tolist(),\n            }\n            curr_anns.append(ann)\n\n        return curr_anns\n\n    def _generate_masks(self, image: np.ndarray) -> MaskData:\n        orig_size = image.shape[:2]\n        crop_boxes, layer_idxs = generate_crop_boxes(\n            orig_size, self.crop_n_layers, self.crop_overlap_ratio\n        )\n\n        # Iterate over image crops\n        data = MaskData()\n        for crop_box, layer_idx in zip(crop_boxes, layer_idxs):\n            crop_data = self._process_crop(image, crop_box, layer_idx, orig_size)\n            data.cat(crop_data)\n\n        # Remove duplicate masks between crops\n        if len(crop_boxes) > 1:\n            # Prefer masks from smaller crops\n            scores = 1 / box_area(data[\"crop_boxes\"])\n            scores = scores.to(data[\"boxes\"].device)\n            keep_by_nms = batched_nms(\n                data[\"boxes\"].float(),\n                scores,\n                torch.zeros_like(data[\"boxes\"][:, 0]),  # categories\n                iou_threshold=self.crop_nms_thresh,\n            )\n            data.filter(keep_by_nms)\n\n        data.to_numpy()\n        return data\n\n    def _process_crop(\n        self,\n        image: np.ndarray,\n        crop_box: List[int],\n        crop_layer_idx: int,\n        orig_size: Tuple[int, ...],\n    ) -> MaskData:\n        # Crop the image and calculate embeddings\n        x0, y0, x1, y1 = crop_box\n        cropped_im = image[y0:y1, x0:x1, :]\n        cropped_im_size = cropped_im.shape[:2]\n        self.predictor.set_image(cropped_im)\n\n        # Get points for this crop\n        points_scale = np.array(cropped_im_size)[None, ::-1]\n        points_for_image = self.point_grids[crop_layer_idx] * points_scale\n\n        # Generate masks for this crop in batches\n        data = MaskData()\n        for (points,) in batch_iterator(self.points_per_batch, points_for_image):\n            batch_data = self._process_batch(\n                points, cropped_im_size, crop_box, orig_size\n            )\n            data.cat(batch_data)\n            del batch_data\n        self.predictor.reset_image()\n\n        # Remove duplicates within this crop.\n        keep_by_nms = batched_nms(\n            data[\"boxes\"].float(),\n            data[\"iou_preds\"],\n            torch.zeros_like(data[\"boxes\"][:, 0]),  # categories\n            iou_threshold=self.box_nms_thresh,\n        )\n        data.filter(keep_by_nms)\n\n        # Return to the original image frame\n        data[\"boxes\"] = uncrop_boxes_xyxy(data[\"boxes\"], crop_box)\n        data[\"points\"] = uncrop_points(data[\"points\"], crop_box)\n        data[\"crop_boxes\"] = torch.tensor([crop_box for _ in range(len(data[\"rles\"]))])\n\n        return data\n\n    def _process_batch(\n        self,\n        points: np.ndarray,\n        im_size: Tuple[int, ...],\n        crop_box: List[int],\n        orig_size: Tuple[int, ...],\n    ) -> MaskData:\n        orig_h, orig_w = orig_size\n\n        # Run model on this batch\n        transformed_points = self.predictor.transform.apply_coords(points, im_size)\n        in_points = torch.as_tensor(transformed_points, device=self.predictor.device)\n        in_labels = torch.ones(\n            in_points.shape[0], dtype=torch.int, device=in_points.device\n        )\n        masks, iou_preds, _ = self.predictor.predict_torch(\n            in_points[:, None, :],\n            in_labels[:, None],\n            multimask_output=True,\n            return_logits=True,\n        )\n\n        # Serialize predictions and store in MaskData\n        data = MaskData(\n            masks=masks.flatten(0, 1),\n            iou_preds=iou_preds.flatten(0, 1),\n            points=torch.as_tensor(points.repeat(masks.shape[1], axis=0)),\n        )\n        del masks\n\n        # Filter by predicted IoU\n        if self.pred_iou_thresh > 0.0:\n            keep_mask = data[\"iou_preds\"] > self.pred_iou_thresh\n            data.filter(keep_mask)\n\n        # Calculate stability score\n        data[\"stability_score\"] = calculate_stability_score(\n            data[\"masks\"],\n            self.predictor.model.mask_threshold,\n            self.stability_score_offset,\n        )\n        if self.stability_score_thresh > 0.0:\n            keep_mask = data[\"stability_score\"] >= self.stability_score_thresh\n            data.filter(keep_mask)\n\n        # Threshold masks and calculate boxes\n        data[\"masks\"] = data[\"masks\"] > self.predictor.model.mask_threshold\n        data[\"boxes\"] = batched_mask_to_box(data[\"masks\"])\n\n        # Filter boxes that touch crop boundaries\n        keep_mask = ~is_box_near_crop_edge(\n            data[\"boxes\"], crop_box, [0, 0, orig_w, orig_h]\n        )\n        if not torch.all(keep_mask):\n            data.filter(keep_mask)\n\n        # Compress to RLE\n        data[\"masks\"] = uncrop_masks(data[\"masks\"], crop_box, orig_h, orig_w)\n        data[\"rles\"] = mask_to_rle_pytorch(data[\"masks\"])\n        del data[\"masks\"]\n\n        return data\n\n    @staticmethod\n    def postprocess_small_regions(\n        mask_data: MaskData, min_area: int, nms_thresh: float\n    ) -> MaskData:\n        \"\"\"\n        Removes small disconnected regions and holes in masks, then reruns\n        box NMS to remove any new duplicates.\n\n        Edits mask_data in place.\n\n        Requires open-cv as a dependency.\n        \"\"\"\n        if len(mask_data[\"rles\"]) == 0:\n            return mask_data\n\n        # Filter small disconnected regions and holes\n        new_masks = []\n        scores = []\n        for rle in mask_data[\"rles\"]:\n            mask = rle_to_mask(rle)\n\n            mask, changed = remove_small_regions(mask, min_area, mode=\"holes\")\n            unchanged = not changed\n            mask, changed = remove_small_regions(mask, min_area, mode=\"islands\")\n            unchanged = unchanged and not changed\n\n            new_masks.append(torch.as_tensor(mask).unsqueeze(0))\n            # Give score=0 to changed masks and score=1 to unchanged masks\n            # so NMS will prefer ones that didn't need postprocessing\n            scores.append(float(unchanged))\n\n        # Recalculate boxes and remove any new duplicates\n        masks = torch.cat(new_masks, dim=0)\n        boxes = batched_mask_to_box(masks)\n        keep_by_nms = batched_nms(\n            boxes.float(),\n            torch.as_tensor(scores),\n            torch.zeros_like(boxes[:, 0]),  # categories\n            iou_threshold=nms_thresh,\n        )\n\n        # Only recalculate RLEs for masks that have changed\n        for i_mask in keep_by_nms:\n            if scores[i_mask] == 0.0:\n                mask_torch = masks[i_mask].unsqueeze(0)\n                mask_data[\"rles\"][i_mask] = mask_to_rle_pytorch(mask_torch)[0]\n                mask_data[\"boxes\"][i_mask] = boxes[i_mask]  # update res directly\n        mask_data.filter(keep_by_nms)\n\n        return mask_data\n"}
{"type": "source_file", "path": "model/EfficientSAM/efficient_sam/build_efficient_sam.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom .efficient_sam import build_efficient_sam\n\ndef build_efficient_sam_vitt(checkpoint=None):\n    return build_efficient_sam(\n        encoder_patch_embed_dim=192,\n        encoder_num_heads=3,\n        checkpoint=checkpoint,\n    ).eval()\n\n\ndef build_efficient_sam_vits(checkpoint=None):\n    return build_efficient_sam(\n        encoder_patch_embed_dim=384,\n        encoder_num_heads=6,\n        checkpoint=checkpoint,\n    ).eval()\n"}
{"type": "source_file", "path": "model/segment_anything/predictor.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Optional, Tuple\n\nimport numpy as np\nimport torch\n\nfrom .modeling import Sam\nfrom .utils.transforms import ResizeLongestSide\n\n\nclass SamPredictor:\n    def __init__(\n        self,\n        sam_model: Sam,\n    ) -> None:\n        \"\"\"\n        Uses SAM to calculate the image embedding for an image, and then\n        allow repeated, efficient mask prediction given prompts.\n\n        Arguments:\n          sam_model (Sam): The model to use for mask prediction.\n        \"\"\"\n        super().__init__()\n        self.model = sam_model\n        self.transform = ResizeLongestSide(sam_model.image_encoder.img_size)\n        self.reset_image()\n\n    def set_image(\n        self,\n        image: np.ndarray,\n        image_format: str = \"RGB\",\n    ) -> None:\n        \"\"\"\n        Calculates the image embeddings for the provided image, allowing\n        masks to be predicted with the 'predict' method.\n\n        Arguments:\n          image (np.ndarray): The image for calculating masks. Expects an\n            image in HWC uint8 format, with pixel values in [0, 255].\n          image_format (str): The color format of the image, in ['RGB', 'BGR'].\n        \"\"\"\n        assert image_format in [\n            \"RGB\",\n            \"BGR\",\n        ], f\"image_format must be in ['RGB', 'BGR'], is {image_format}.\"\n        if image_format != self.model.image_format:\n            image = image[..., ::-1]\n\n        # Transform the image to the form expected by the model\n        input_image = self.transform.apply_image(image)\n        input_image_torch = torch.as_tensor(input_image, device=self.device)\n        input_image_torch = input_image_torch.permute(2, 0, 1).contiguous()[\n            None, :, :, :\n        ]\n\n        self.set_torch_image(input_image_torch, image.shape[:2])\n\n    @torch.no_grad()\n    def set_torch_image(\n        self,\n        transformed_image: torch.Tensor,\n        original_image_size: Tuple[int, ...],\n    ) -> None:\n        \"\"\"\n        Calculates the image embeddings for the provided image, allowing\n        masks to be predicted with the 'predict' method. Expects the input\n        image to be already transformed to the format expected by the model.\n\n        Arguments:\n          transformed_image (torch.Tensor): The input image, with shape\n            1x3xHxW, which has been transformed with ResizeLongestSide.\n          original_image_size (tuple(int, int)): The size of the image\n            before transformation, in (H, W) format.\n        \"\"\"\n        assert (\n            len(transformed_image.shape) == 4\n            and transformed_image.shape[1] == 3\n            and max(*transformed_image.shape[2:]) == self.model.image_encoder.img_size\n        ), f\"set_torch_image input must be BCHW with long side {self.model.image_encoder.img_size}.\"\n        self.reset_image()\n\n        self.original_size = original_image_size\n        self.input_size = tuple(transformed_image.shape[-2:])\n        input_image = self.model.preprocess(transformed_image)\n        self.features = self.model.image_encoder(input_image)\n        self.is_image_set = True\n\n    def predict(\n        self,\n        point_coords: Optional[np.ndarray] = None,\n        point_labels: Optional[np.ndarray] = None,\n        box: Optional[np.ndarray] = None,\n        mask_input: Optional[np.ndarray] = None,\n        multimask_output: bool = True,\n        return_logits: bool = False,\n    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Predict masks for the given input prompts, using the currently set image.\n\n        Arguments:\n          point_coords (np.ndarray or None): A Nx2 array of point prompts to the\n            model. Each point is in (X,Y) in pixels.\n          point_labels (np.ndarray or None): A length N array of labels for the\n            point prompts. 1 indicates a foreground point and 0 indicates a\n            background point.\n          box (np.ndarray or None): A length 4 array given a box prompt to the\n            model, in XYXY format.\n          mask_input (np.ndarray): A low resolution mask input to the model, typically\n            coming from a previous prediction iteration. Has form 1xHxW, where\n            for SAM, H=W=256.\n          multimask_output (bool): If true, the model will return three masks.\n            For ambiguous input prompts (such as a single click), this will often\n            produce better masks than a single prediction. If only a single\n            mask is needed, the model's predicted quality score can be used\n            to select the best mask. For non-ambiguous prompts, such as multiple\n            input prompts, multimask_output=False can give better results.\n          return_logits (bool): If true, returns un-thresholded masks logits\n            instead of a binary mask.\n\n        Returns:\n          (np.ndarray): The output masks in CxHxW format, where C is the\n            number of masks, and (H, W) is the original image size.\n          (np.ndarray): An array of length C containing the model's\n            predictions for the quality of each mask.\n          (np.ndarray): An array of shape CxHxW, where C is the number\n            of masks and H=W=256. These low resolution logits can be passed to\n            a subsequent iteration as mask input.\n        \"\"\"\n        if not self.is_image_set:\n            raise RuntimeError(\n                \"An image must be set with .set_image(...) before mask prediction.\"\n            )\n\n        # Transform input prompts\n        coords_torch, labels_torch, box_torch, mask_input_torch = None, None, None, None\n        if point_coords is not None:\n            assert (\n                point_labels is not None\n            ), \"point_labels must be supplied if point_coords is supplied.\"\n            point_coords = self.transform.apply_coords(point_coords, self.original_size)\n            coords_torch = torch.as_tensor(\n                point_coords, dtype=torch.float, device=self.device\n            )\n            labels_torch = torch.as_tensor(\n                point_labels, dtype=torch.int, device=self.device\n            )\n            coords_torch, labels_torch = coords_torch[None, :, :], labels_torch[None, :]\n        if box is not None:\n            box = self.transform.apply_boxes(box, self.original_size)\n            box_torch = torch.as_tensor(box, dtype=torch.float, device=self.device)\n            box_torch = box_torch[None, :]\n        if mask_input is not None:\n            mask_input_torch = torch.as_tensor(\n                mask_input, dtype=torch.float, device=self.device\n            )\n            mask_input_torch = mask_input_torch[None, :, :, :]\n\n        masks, iou_predictions, low_res_masks = self.predict_torch(\n            coords_torch,\n            labels_torch,\n            box_torch,\n            mask_input_torch,\n            multimask_output,\n            return_logits=return_logits,\n        )\n\n        masks_np = masks[0].detach().cpu().numpy()\n        iou_predictions_np = iou_predictions[0].detach().cpu().numpy()\n        low_res_masks_np = low_res_masks[0].detach().cpu().numpy()\n        return masks_np, iou_predictions_np, low_res_masks_np\n\n    @torch.no_grad()\n    def predict_torch(\n        self,\n        point_coords: Optional[torch.Tensor],\n        point_labels: Optional[torch.Tensor],\n        boxes: Optional[torch.Tensor] = None,\n        mask_input: Optional[torch.Tensor] = None,\n        multimask_output: bool = True,\n        return_logits: bool = False,\n    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks for the given input prompts, using the currently set image.\n        Input prompts are batched torch tensors and are expected to already be\n        transformed to the input frame using ResizeLongestSide.\n\n        Arguments:\n          point_coords (torch.Tensor or None): A BxNx2 array of point prompts to the\n            model. Each point is in (X,Y) in pixels.\n          point_labels (torch.Tensor or None): A BxN array of labels for the\n            point prompts. 1 indicates a foreground point and 0 indicates a\n            background point.\n          boxes (np.ndarray or None): A Bx4 array given a box prompt to the\n            model, in XYXY format.\n          mask_input (np.ndarray): A low resolution mask input to the model, typically\n            coming from a previous prediction iteration. Has form Bx1xHxW, where\n            for SAM, H=W=256. Masks returned by a previous iteration of the\n            predict method do not need further transformation.\n          multimask_output (bool): If true, the model will return three masks.\n            For ambiguous input prompts (such as a single click), this will often\n            produce better masks than a single prediction. If only a single\n            mask is needed, the model's predicted quality score can be used\n            to select the best mask. For non-ambiguous prompts, such as multiple\n            input prompts, multimask_output=False can give better results.\n          return_logits (bool): If true, returns un-thresholded masks logits\n            instead of a binary mask.\n\n        Returns:\n          (torch.Tensor): The output masks in BxCxHxW format, where C is the\n            number of masks, and (H, W) is the original image size.\n          (torch.Tensor): An array of shape BxC containing the model's\n            predictions for the quality of each mask.\n          (torch.Tensor): An array of shape BxCxHxW, where C is the number\n            of masks and H=W=256. These low res logits can be passed to\n            a subsequent iteration as mask input.\n        \"\"\"\n        if not self.is_image_set:\n            raise RuntimeError(\n                \"An image must be set with .set_image(...) before mask prediction.\"\n            )\n\n        if point_coords is not None:\n            points = (point_coords, point_labels)\n        else:\n            points = None\n\n        # Embed prompts\n        sparse_embeddings, dense_embeddings = self.model.prompt_encoder(\n            points=points,\n            boxes=boxes,\n            masks=mask_input,\n        )\n\n        # Predict masks\n        low_res_masks, iou_predictions = self.model.mask_decoder(\n            image_embeddings=self.features,\n            image_pe=self.model.prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            dense_prompt_embeddings=dense_embeddings,\n            multimask_output=multimask_output,\n        )\n\n        # Upscale the masks to the original image resolution\n        masks = self.model.postprocess_masks(\n            low_res_masks, self.input_size, self.original_size\n        )\n\n        if not return_logits:\n            masks = masks > self.model.mask_threshold\n\n        return masks, iou_predictions, low_res_masks\n\n    def get_image_embedding(self) -> torch.Tensor:\n        \"\"\"\n        Returns the image embeddings for the currently set image, with\n        shape 1xCxHxW, where C is the embedding dimension and (H,W) are\n        the embedding spatial dimension of SAM (typically C=256, H=W=64).\n        \"\"\"\n        if not self.is_image_set:\n            raise RuntimeError(\n                \"An image must be set with .set_image(...) to generate an embedding.\"\n            )\n        assert (\n            self.features is not None\n        ), \"Features must exist if an image has been set.\"\n        return self.features\n\n    @property\n    def device(self) -> torch.device:\n        return self.model.device\n\n    def reset_image(self) -> None:\n        \"\"\"Resets the currently set image.\"\"\"\n        self.is_image_set = False\n        self.features = None\n        self.orig_h = None\n        self.orig_w = None\n        self.input_h = None\n        self.input_w = None\n"}
{"type": "source_file", "path": "model/segment_anything/modeling/image_encoder.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Optional, Tuple, Type\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom .common import LayerNorm2d, MLPBlock\n\n\n# This class and its supporting functions below lightly adapted from the ViTDet backbone available at: https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/vit.py # noqa\nclass ImageEncoderViT(nn.Module):\n    def __init__(\n        self,\n        img_size: int = 1024,\n        patch_size: int = 16,\n        in_chans: int = 3,\n        embed_dim: int = 768,\n        depth: int = 12,\n        num_heads: int = 12,\n        mlp_ratio: float = 4.0,\n        out_chans: int = 256,\n        qkv_bias: bool = True,\n        norm_layer: Type[nn.Module] = nn.LayerNorm,\n        act_layer: Type[nn.Module] = nn.GELU,\n        use_abs_pos: bool = True,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        window_size: int = 0,\n        global_attn_indexes: Tuple[int, ...] = (),\n    ) -> None:\n        \"\"\"\n        Args:\n            img_size (int): Input image size.\n            patch_size (int): Patch size.\n            in_chans (int): Number of input image channels.\n            embed_dim (int): Patch embedding dimension.\n            depth (int): Depth of ViT.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            qkv_bias (bool): If True, add a learnable bias to query, key, value.\n            norm_layer (nn.Module): Normalization layer.\n            act_layer (nn.Module): Activation layer.\n            use_abs_pos (bool): If True, use absolute positional embeddings.\n            use_rel_pos (bool): If True, add relative positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n            window_size (int): Window size for window attention blocks.\n            global_attn_indexes (list): Indexes for blocks using global attention.\n        \"\"\"\n        super().__init__()\n        self.img_size = img_size\n        self.embed_dim = embed_dim\n        self.out_chans = out_chans\n\n        self.patch_embed = PatchEmbed(\n            kernel_size=(patch_size, patch_size),\n            stride=(patch_size, patch_size),\n            in_chans=in_chans,\n            embed_dim=embed_dim,\n        )\n\n        self.pos_embed: Optional[nn.Parameter] = None\n        if use_abs_pos:\n            # Initialize absolute positional embedding with pretrain image size.\n            self.pos_embed = nn.Parameter(\n                torch.zeros(\n                    1, img_size // patch_size, img_size // patch_size, embed_dim\n                )\n            )\n\n        self.blocks = nn.ModuleList()\n        for i in range(depth):\n            block = Block(\n                dim=embed_dim,\n                num_heads=num_heads,\n                mlp_ratio=mlp_ratio,\n                qkv_bias=qkv_bias,\n                norm_layer=norm_layer,\n                act_layer=act_layer,\n                use_rel_pos=use_rel_pos,\n                rel_pos_zero_init=rel_pos_zero_init,\n                window_size=window_size if i not in global_attn_indexes else 0,\n                input_size=(img_size // patch_size, img_size // patch_size),\n            )\n            self.blocks.append(block)\n\n        self.neck = nn.Sequential(\n            nn.Conv2d(\n                embed_dim,\n                out_chans,\n                kernel_size=1,\n                bias=False,\n            ),\n            LayerNorm2d(out_chans),\n            nn.Conv2d(\n                out_chans,\n                out_chans,\n                kernel_size=3,\n                padding=1,\n                bias=False,\n            ),\n            LayerNorm2d(out_chans),\n        )\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = self.patch_embed(x)\n        if self.pos_embed is not None:\n            x = x + self.pos_embed\n\n        for blk in self.blocks:\n            x = blk(x)\n\n        dtype = x.dtype\n        if dtype == torch.float16:  # prevent overflow\n            with torch.autocast(device_type=\"cuda\", dtype=torch.float32):\n                x = self.neck(x.permute(0, 3, 1, 2))\n            x = x.to(dtype)\n        else:\n            x = self.neck(x.permute(0, 3, 1, 2))\n        return x\n\n\nclass Block(nn.Module):\n    \"\"\"Transformer blocks with support of window attention and residual propagation blocks\"\"\"\n\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int,\n        mlp_ratio: float = 4.0,\n        qkv_bias: bool = True,\n        norm_layer: Type[nn.Module] = nn.LayerNorm,\n        act_layer: Type[nn.Module] = nn.GELU,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        window_size: int = 0,\n        input_size: Optional[Tuple[int, int]] = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            dim (int): Number of input channels.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            qkv_bias (bool): If True, add a learnable bias to query, key, value.\n            norm_layer (nn.Module): Normalization layer.\n            act_layer (nn.Module): Activation layer.\n            use_rel_pos (bool): If True, add relative positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n            window_size (int): Window size for window attention blocks. If it equals 0, then\n                use global attention.\n            input_size (tuple(int, int) or None): Input resolution for calculating the relative\n                positional parameter size.\n        \"\"\"\n        super().__init__()\n        self.norm1 = norm_layer(dim)\n        self.attn = Attention(\n            dim,\n            num_heads=num_heads,\n            qkv_bias=qkv_bias,\n            use_rel_pos=use_rel_pos,\n            rel_pos_zero_init=rel_pos_zero_init,\n            input_size=input_size if window_size == 0 else (window_size, window_size),\n        )\n\n        self.norm2 = norm_layer(dim)\n        self.mlp = MLPBlock(\n            embedding_dim=dim, mlp_dim=int(dim * mlp_ratio), act=act_layer\n        )\n\n        self.window_size = window_size\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        shortcut = x\n        x = self.norm1(x)\n        # Window partition\n        if self.window_size > 0:\n            H, W = x.shape[1], x.shape[2]\n            x, pad_hw = window_partition(x, self.window_size)\n\n        x = self.attn(x)\n        # Reverse window partition\n        if self.window_size > 0:\n            x = window_unpartition(x, self.window_size, pad_hw, (H, W))\n\n        x = shortcut + x\n        x = x + self.mlp(self.norm2(x))\n\n        return x\n\n\nclass Attention(nn.Module):\n    \"\"\"Multi-head Attention block with relative position embeddings.\"\"\"\n\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int = 8,\n        qkv_bias: bool = True,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        input_size: Optional[Tuple[int, int]] = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            dim (int): Number of input channels.\n            num_heads (int): Number of attention heads.\n            qkv_bias (bool):  If True, add a learnable bias to query, key, value.\n            rel_pos (bool): If True, add relative positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n            input_size (tuple(int, int) or None): Input resolution for calculating the relative\n                positional parameter size.\n        \"\"\"\n        super().__init__()\n        self.num_heads = num_heads\n        head_dim = dim // num_heads\n        self.scale = head_dim**-0.5\n\n        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)\n        self.proj = nn.Linear(dim, dim)\n\n        self.use_rel_pos = use_rel_pos\n        if self.use_rel_pos:\n            assert (\n                input_size is not None\n            ), \"Input size must be provided if using relative positional encoding.\"\n            # initialize relative positional embeddings\n            self.rel_pos_h = nn.Parameter(torch.zeros(2 * input_size[0] - 1, head_dim))\n            self.rel_pos_w = nn.Parameter(torch.zeros(2 * input_size[1] - 1, head_dim))\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        B, H, W, _ = x.shape\n        # qkv with shape (3, B, nHead, H * W, C)\n        qkv = (\n            self.qkv(x).reshape(B, H * W, 3, self.num_heads, -1).permute(2, 0, 3, 1, 4)\n        )\n        # q, k, v with shape (B * nHead, H * W, C)\n        q, k, v = qkv.reshape(3, B * self.num_heads, H * W, -1).unbind(0)\n\n        attn = (q * self.scale) @ k.transpose(-2, -1)\n\n        if self.use_rel_pos:\n            attn = add_decomposed_rel_pos(\n                attn, q, self.rel_pos_h, self.rel_pos_w, (H, W), (H, W)\n            )\n\n        attn = attn.softmax(dim=-1)\n        x = (\n            (attn @ v)\n            .view(B, self.num_heads, H, W, -1)\n            .permute(0, 2, 3, 1, 4)\n            .reshape(B, H, W, -1)\n        )\n        x = self.proj(x)\n\n        return x\n\n\ndef window_partition(\n    x: torch.Tensor, window_size: int\n) -> Tuple[torch.Tensor, Tuple[int, int]]:\n    \"\"\"\n    Partition into non-overlapping windows with padding if needed.\n    Args:\n        x (tensor): input tokens with [B, H, W, C].\n        window_size (int): window size.\n\n    Returns:\n        windows: windows after partition with [B * num_windows, window_size, window_size, C].\n        (Hp, Wp): padded height and width before partition\n    \"\"\"\n    B, H, W, C = x.shape\n\n    pad_h = (window_size - H % window_size) % window_size\n    pad_w = (window_size - W % window_size) % window_size\n    if pad_h > 0 or pad_w > 0:\n        x = F.pad(x, (0, 0, 0, pad_w, 0, pad_h))\n    Hp, Wp = H + pad_h, W + pad_w\n\n    x = x.view(B, Hp // window_size, window_size, Wp // window_size, window_size, C)\n    windows = (\n        x.permute(0, 1, 3, 2, 4, 5).contiguous().view(-1, window_size, window_size, C)\n    )\n    return windows, (Hp, Wp)\n\n\ndef window_unpartition(\n    windows: torch.Tensor,\n    window_size: int,\n    pad_hw: Tuple[int, int],\n    hw: Tuple[int, int],\n) -> torch.Tensor:\n    \"\"\"\n    Window unpartition into original sequences and removing padding.\n    Args:\n        windows (tensor): input tokens with [B * num_windows, window_size, window_size, C].\n        window_size (int): window size.\n        pad_hw (Tuple): padded height and width (Hp, Wp).\n        hw (Tuple): original height and width (H, W) before padding.\n\n    Returns:\n        x: unpartitioned sequences with [B, H, W, C].\n    \"\"\"\n    Hp, Wp = pad_hw\n    H, W = hw\n    B = windows.shape[0] // (Hp * Wp // window_size // window_size)\n    x = windows.view(\n        B, Hp // window_size, Wp // window_size, window_size, window_size, -1\n    )\n    x = x.permute(0, 1, 3, 2, 4, 5).contiguous().view(B, Hp, Wp, -1)\n\n    if Hp > H or Wp > W:\n        x = x[:, :H, :W, :].contiguous()\n    return x\n\n\ndef get_rel_pos(q_size: int, k_size: int, rel_pos: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Get relative positional embeddings according to the relative positions of\n        query and key sizes.\n    Args:\n        q_size (int): size of query q.\n        k_size (int): size of key k.\n        rel_pos (Tensor): relative position embeddings (L, C).\n\n    Returns:\n        Extracted positional embeddings according to relative positions.\n    \"\"\"\n    max_rel_dist = int(2 * max(q_size, k_size) - 1)\n    # Interpolate rel pos if needed.\n    if rel_pos.shape[0] != max_rel_dist:\n        # Interpolate rel pos.\n        rel_pos_resized = F.interpolate(\n            rel_pos.reshape(1, rel_pos.shape[0], -1).permute(0, 2, 1),\n            size=max_rel_dist,\n            mode=\"linear\",\n        )\n        rel_pos_resized = rel_pos_resized.reshape(-1, max_rel_dist).permute(1, 0)\n    else:\n        rel_pos_resized = rel_pos\n\n    # Scale the coords with short length if shapes for q and k are different.\n    q_coords = torch.arange(q_size)[:, None] * max(k_size / q_size, 1.0)\n    k_coords = torch.arange(k_size)[None, :] * max(q_size / k_size, 1.0)\n    relative_coords = (q_coords - k_coords) + (k_size - 1) * max(q_size / k_size, 1.0)\n\n    return rel_pos_resized[relative_coords.long()]\n\n\ndef add_decomposed_rel_pos(\n    attn: torch.Tensor,\n    q: torch.Tensor,\n    rel_pos_h: torch.Tensor,\n    rel_pos_w: torch.Tensor,\n    q_size: Tuple[int, int],\n    k_size: Tuple[int, int],\n) -> torch.Tensor:\n    \"\"\"\n    Calculate decomposed Relative Positional Embeddings from :paper:`mvitv2`.\n    https://github.com/facebookresearch/mvit/blob/19786631e330df9f3622e5402b4a419a263a2c80/mvit/models/attention.py   # noqa B950\n    Args:\n        attn (Tensor): attention map.\n        q (Tensor): query q in the attention layer with shape (B, q_h * q_w, C).\n        rel_pos_h (Tensor): relative position embeddings (Lh, C) for height axis.\n        rel_pos_w (Tensor): relative position embeddings (Lw, C) for width axis.\n        q_size (Tuple): spatial sequence size of query q with (q_h, q_w).\n        k_size (Tuple): spatial sequence size of key k with (k_h, k_w).\n\n    Returns:\n        attn (Tensor): attention map with added relative positional embeddings.\n    \"\"\"\n    q_h, q_w = q_size\n    k_h, k_w = k_size\n    Rh = get_rel_pos(q_h, k_h, rel_pos_h)\n    Rw = get_rel_pos(q_w, k_w, rel_pos_w)\n\n    B, _, dim = q.shape\n    r_q = q.reshape(B, q_h, q_w, dim)\n    rel_h = torch.einsum(\"bhwc,hkc->bhwk\", r_q, Rh)\n    rel_w = torch.einsum(\"bhwc,wkc->bhwk\", r_q, Rw)\n\n    attn = (\n        attn.view(B, q_h, q_w, k_h, k_w)\n        + rel_h[:, :, :, :, None]\n        + rel_w[:, :, :, None, :]\n    ).view(B, q_h * q_w, k_h * k_w)\n\n    return attn\n\n\nclass PatchEmbed(nn.Module):\n    \"\"\"\n    Image to Patch Embedding.\n    \"\"\"\n\n    def __init__(\n        self,\n        kernel_size: Tuple[int, int] = (16, 16),\n        stride: Tuple[int, int] = (16, 16),\n        padding: Tuple[int, int] = (0, 0),\n        in_chans: int = 3,\n        embed_dim: int = 768,\n    ) -> None:\n        \"\"\"\n        Args:\n            kernel_size (Tuple): kernel size of the projection layer.\n            stride (Tuple): stride of the projection layer.\n            padding (Tuple): padding size of the projection layer.\n            in_chans (int): Number of input image channels.\n            embed_dim (int): Patch embedding dimension.\n        \"\"\"\n        super().__init__()\n\n        self.proj = nn.Conv2d(\n            in_chans, embed_dim, kernel_size=kernel_size, stride=stride, padding=padding\n        )\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = self.proj(x)\n        # B C H W -> B H W C\n        x = x.permute(0, 2, 3, 1)\n        return x\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/backbones/__init__.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n"}
{"type": "source_file", "path": "eval.py", "content": "import argparse\nimport os\nimport sys\n\nimport cv2\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom transformers import AutoTokenizer, BitsAndBytesConfig\n\nfrom model.evf_sam import EvfSamModel\nimport os\nfrom model.segment_anything.utils.transforms import ResizeLongestSide\nfrom utils.utils import (AverageMeter, ProgressMeter, Summary, dict_to_cuda,\n                         intersectionAndUnionGPU)\nfrom utils.dataset import collate_fn, ValDataset, Resize\nfrom functools import partial\nimport tqdm\nfrom torch.utils.data import DataLoader, DistributedSampler\nfrom torch.nn.parallel import DistributedDataParallel\nimport torch.distributed as dist\n\n\ndef parse_args(args):\n    parser = argparse.ArgumentParser(description=\"EVF eval\")\n    parser.add_argument(\"--version\")\n    parser.add_argument(\n        \"--precision\",\n        default=\"fp16\",\n        type=str,\n        choices=[\"fp32\", \"bf16\", \"fp16\"],\n        help=\"precision for inference\",\n    )\n    parser.add_argument(\"--image_size\", default=224, type=int, help=\"image size\")\n    parser.add_argument(\"--val_dataset\", default=\"refcoco|unc|testA\", type=str, \n                        choices=[\"refcoco|unc|val\", \"refcoco|unc|testA\", \"refcoco|unc|testB\", \n                                 \"refcoco+|unc|val\", \"refcoco+|unc|testA\", \"refcoco+|unc|testB\", \n                                 \"refcocog|umd|val\", \"refcocog|umd|test\"])\n    parser.add_argument(\"--dataset_dir\", default=\"./dataset\", type=str)\n    parser.add_argument(\"--local_rank\", default=0, type=int, help=\"node rank\")\n    parser.add_argument(\"--load_in_8bit\", action=\"store_true\", default=False)\n    parser.add_argument(\"--load_in_4bit\", action=\"store_true\", default=False)\n    parser.add_argument(\"--model_type\", default=\"ori\", choices=[\"ori\", \"effi\", \"sam2\"])\n    return parser.parse_args(args)\n\n\ndef main(args):\n    args = parse_args(args)\n    dist.init_process_group('nccl', init_method=\"env://\")\n    rank = int(os.environ[\"LOCAL_RANK\"])\n    torch.cuda.set_device(rank)\n    # Create model\n    tokenizer = AutoTokenizer.from_pretrained(\n        args.version,\n        padding_side=\"right\",\n        use_fast=False,\n    )\n\n    torch_dtype = torch.float32\n    if args.precision == \"bf16\":\n        torch_dtype = torch.bfloat16\n    elif args.precision == \"fp16\":\n        torch_dtype = torch.half\n\n    kwargs = {\"torch_dtype\": torch_dtype}\n    if args.load_in_4bit:\n        kwargs.update(\n            {\n                \"torch_dtype\": torch.half,\n                \"quantization_config\": BitsAndBytesConfig(\n                    load_in_4bit=True,\n                    bnb_4bit_compute_dtype=torch.float16,\n                    bnb_4bit_use_double_quant=True,\n                    bnb_4bit_quant_type=\"nf4\",\n                    llm_int8_skip_modules=[\"visual_model\"],\n                ),\n            }\n        )\n    elif args.load_in_8bit:\n        kwargs.update(\n            {\n                \"torch_dtype\": torch.half,\n                \"quantization_config\": BitsAndBytesConfig(\n                    llm_int8_skip_modules=[\"visual_model\"],\n                    load_in_8bit=True,\n                ),\n            }\n        )\n\n    if args.model_type==\"ori\":\n        from model.evf_sam import EvfSamModel\n        model = EvfSamModel.from_pretrained(args.version, low_cpu_mem_usage=True, **kwargs)\n    elif args.model_type==\"sam2\":\n        from model.evf_sam2 import EvfSam2Model\n        model = EvfSam2Model.from_pretrained(args.version, low_cpu_mem_usage=True, **kwargs)\n    elif args.model_type==\"effi\":\n        from model.evf_effisam import EvfEffiSamModel\n        model = EvfEffiSamModel.from_pretrained(args.version, low_cpu_mem_usage=True, **kwargs)\n\n    if (not args.load_in_4bit) and (not args.load_in_8bit):\n        model = model.cuda()\n\n    model = DistributedDataParallel(model, device_ids=[rank])\n    model.eval()\n\n    val_dataset = ValDataset(\n        args.dataset_dir,\n        args.val_dataset,\n        args.image_size,\n        model_type=args.model_type,\n        transform=ResizeLongestSide(1024) if args.model_type==\"ori\" else Resize(1024)\n    )\n    sampler = DistributedSampler(val_dataset, shuffle=False, drop_last=False, rank=rank)\n    val_loader = DataLoader(\n        val_dataset,\n        batch_size=1,\n        shuffle=False,\n        pin_memory=False,\n        sampler=sampler,\n        collate_fn=partial(\n            collate_fn,\n            tokenizer=tokenizer,\n            local_rank=rank,\n        ),\n    )\n    args.log_dir = \"runs\"\n    os.makedirs(args.log_dir, exist_ok=True)\n    giou, ciou = validate(val_loader, model, args)\n    if rank==0:\n        print(args.val_dataset)\n        print(\"giou{:.3f}_ciou{:.3f}\".format(giou, ciou))\n    dist.destroy_process_group()\n\ndef validate(val_loader, model, args):\n    intersection_meter = AverageMeter(\"Intersec\", \":6.3f\", Summary.SUM)\n    union_meter = AverageMeter(\"Union\", \":6.3f\", Summary.SUM)\n    acc_iou_meter = AverageMeter(\"gIoU\", \":6.3f\", Summary.SUM)\n\n    for input_dict in tqdm.tqdm(val_loader):\n        torch.cuda.empty_cache()\n\n        input_dict = dict_to_cuda(input_dict)\n        if args.precision == \"fp16\":\n            input_dict[\"images\"] = input_dict[\"images\"].half()\n            input_dict[\"images_evf\"] = input_dict[\"images_evf\"].half()\n        elif args.precision == \"bf16\":\n            input_dict[\"images\"] = input_dict[\"images\"].bfloat16()\n            input_dict[\"images_evf\"] = input_dict[\"images_evf\"].bfloat16()\n        else:\n            input_dict[\"images\"] = input_dict[\"images\"].float()\n            input_dict[\"images_evf\"] = input_dict[\"images_evf\"].float()\n\n        with torch.no_grad():\n            output_dict = model(**input_dict)\n\n        pred_masks = output_dict[\"pred_masks\"]\n        masks_list = output_dict[\"gt_masks\"][0].int()\n        output_list = (pred_masks[0] > 0).int()\n        assert len(pred_masks) == 1\n        intersection, union, acc_iou = 0.0, 0.0, 0.0\n        for mask_i, output_i in zip(masks_list, output_list):\n            intersection_i, union_i, _ = intersectionAndUnionGPU(\n                output_i.contiguous().clone(), mask_i.contiguous(), 2, ignore_index=255\n            )\n            intersection += intersection_i\n            union += union_i\n            acc_iou += intersection_i / (union_i + 1e-10)\n            acc_iou[union_i == 0] += 1.0  # no-object target\n        intersection, union = intersection.cpu().numpy(), union.cpu().numpy()\n        acc_iou = acc_iou.cpu().numpy() / masks_list.shape[0]\n\n        intersection_meter.update(intersection)\n        union_meter.update(union)\n        acc_iou_meter.update(acc_iou, n=masks_list.shape[0])\n\n    intersection_meter.all_reduce()\n    union_meter.all_reduce()\n    acc_iou_meter.all_reduce()\n\n    iou_class = intersection_meter.sum / (union_meter.sum + 1e-10)\n    ciou = iou_class[1]\n    giou = acc_iou_meter.avg[1]\n\n    return giou, ciou\n\nif __name__ == \"__main__\":\n    main(sys.argv[1:])\n"}
{"type": "source_file", "path": "model/segment_anything/modeling/sam.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Any, Dict, List, Tuple\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nfrom .image_encoder import ImageEncoderViT\nfrom .mask_decoder import MaskDecoder\nfrom .prompt_encoder import PromptEncoder\n\n\nclass Sam(nn.Module):\n    mask_threshold: float = 0.0\n    image_format: str = \"RGB\"\n\n    def __init__(\n        self,\n        image_encoder: ImageEncoderViT,\n        prompt_encoder: PromptEncoder,\n        mask_decoder: MaskDecoder,\n        pixel_mean: List[float] = [123.675, 116.28, 103.53],\n        pixel_std: List[float] = [58.395, 57.12, 57.375],\n    ) -> None:\n        \"\"\"\n        SAM predicts object masks from an image and input prompts.\n\n        Arguments:\n          image_encoder (ImageEncoderViT): The backbone used to encode the\n            image into image embeddings that allow for efficient mask prediction.\n          prompt_encoder (PromptEncoder): Encodes various types of input prompts.\n          mask_decoder (MaskDecoder): Predicts masks from the image embeddings\n            and encoded prompts.\n          pixel_mean (list(float)): Mean values for normalizing pixels in the input image.\n          pixel_std (list(float)): Std values for normalizing pixels in the input image.\n        \"\"\"\n        super().__init__()\n        self.image_encoder = image_encoder\n        self.prompt_encoder = prompt_encoder\n        self.mask_decoder = mask_decoder\n        self.register_buffer(\n            \"pixel_mean\", torch.Tensor(pixel_mean).view(-1, 1, 1), False\n        )\n        self.register_buffer(\"pixel_std\", torch.Tensor(pixel_std).view(-1, 1, 1), False)\n\n    @property\n    def device(self) -> Any:\n        return self.pixel_mean.device\n\n    @torch.no_grad()\n    def forward(\n        self,\n        batched_input: List[Dict[str, Any]],\n        multimask_output: bool,\n    ) -> List[Dict[str, torch.Tensor]]:\n        \"\"\"\n        Predicts masks end-to-end from provided images and prompts.\n        If prompts are not known in advance, using SamPredictor is\n        recommended over calling the model directly.\n\n        Arguments:\n          batched_input (list(dict)): A list over input images, each a\n            dictionary with the following keys. A prompt key can be\n            excluded if it is not present.\n              'image': The image as a torch tensor in 3xHxW format,\n                already transformed for input to the model.\n              'original_size': (tuple(int, int)) The original size of\n                the image before transformation, as (H, W).\n              'point_coords': (torch.Tensor) Batched point prompts for\n                this image, with shape BxNx2. Already transformed to the\n                input frame of the model.\n              'point_labels': (torch.Tensor) Batched labels for point prompts,\n                with shape BxN.\n              'boxes': (torch.Tensor) Batched box inputs, with shape Bx4.\n                Already transformed to the input frame of the model.\n              'mask_inputs': (torch.Tensor) Batched mask inputs to the model,\n                in the form Bx1xHxW.\n          multimask_output (bool): Whether the model should predict multiple\n            disambiguating masks, or return a single mask.\n\n        Returns:\n          (list(dict)): A list over input images, where each element is\n            as dictionary with the following keys.\n              'masks': (torch.Tensor) Batched binary mask predictions,\n                with shape BxCxHxW, where B is the number of input prompts,\n                C is determined by multimask_output, and (H, W) is the\n                original size of the image.\n              'iou_predictions': (torch.Tensor) The model's predictions\n                of mask quality, in shape BxC.\n              'low_res_logits': (torch.Tensor) Low resolution logits with\n                shape BxCxHxW, where H=W=256. Can be passed as mask input\n                to subsequent iterations of prediction.\n        \"\"\"\n        input_images = torch.stack(\n            [self.preprocess(x[\"image\"]) for x in batched_input], dim=0\n        )\n        image_embeddings = self.image_encoder(input_images)\n\n        outputs = []\n        for image_record, curr_embedding in zip(batched_input, image_embeddings):\n            if \"point_coords\" in image_record:\n                points = (image_record[\"point_coords\"], image_record[\"point_labels\"])\n            else:\n                points = None\n            sparse_embeddings, dense_embeddings = self.prompt_encoder(\n                points=points,\n                boxes=image_record.get(\"boxes\", None),\n                masks=image_record.get(\"mask_inputs\", None),\n            )\n            low_res_masks, iou_predictions = self.mask_decoder(\n                image_embeddings=curr_embedding.unsqueeze(0),\n                image_pe=self.prompt_encoder.get_dense_pe(),\n                sparse_prompt_embeddings=sparse_embeddings,\n                dense_prompt_embeddings=dense_embeddings,\n                multimask_output=multimask_output,\n            )\n            masks = self.postprocess_masks(\n                low_res_masks,\n                input_size=image_record[\"image\"].shape[-2:],\n                original_size=image_record[\"original_size\"],\n            )\n            masks = masks > self.mask_threshold\n            outputs.append(\n                {\n                    \"masks\": masks,\n                    \"iou_predictions\": iou_predictions,\n                    \"low_res_logits\": low_res_masks,\n                }\n            )\n        return outputs\n\n    def postprocess_masks(\n        self,\n        masks: torch.Tensor,\n        input_size: Tuple[int, ...],\n        original_size: Tuple[int, ...],\n    ) -> torch.Tensor:\n        \"\"\"\n        Remove padding and upscale masks to the original image size.\n\n        Arguments:\n          masks (torch.Tensor): Batched masks from the mask_decoder,\n            in BxCxHxW format.\n          input_size (tuple(int, int)): The size of the image input to the\n            model, in (H, W) format. Used to remove padding.\n          original_size (tuple(int, int)): The original size of the image\n            before resizing for input to the model, in (H, W) format.\n\n        Returns:\n          (torch.Tensor): Batched masks in BxCxHxW format, where (H, W)\n            is given by original_size.\n        \"\"\"\n\n        dtype = masks.dtype\n\n        masks = F.interpolate(\n            masks.float(),\n            (self.image_encoder.img_size, self.image_encoder.img_size),\n            mode=\"bilinear\",\n            align_corners=False,\n            antialias=None\n        )\n        # masks = masks.to(dtype)\n        masks = masks[..., : input_size[0], : input_size[1]]\n        masks = F.interpolate(\n            masks, original_size, mode=\"bilinear\", align_corners=False\n        )\n        return masks\n\n    def preprocess(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Normalize pixel values and pad to a square input.\"\"\"\n        # Normalize colors\n        x = (x - self.pixel_mean) / self.pixel_std\n\n        # Pad\n        h, w = x.shape[-2:]\n        padh = self.image_encoder.img_size - h\n        padw = self.image_encoder.img_size - w\n        x = F.pad(x, (0, padw, 0, padh))\n        return x\n"}
{"type": "source_file", "path": "model/evf_sam2_video.py", "content": "from typing import List\nimport os\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom transformers import PreTrainedModel, AutoConfig, AutoModelForCausalLM\nfrom .segment_anything_2.sam2.build_sam import build_sam2, build_sam2_video_predictor\nfrom .unilm.beit3.modeling_utils import BEiT3Wrapper, _get_base_config, _get_large_config\nfrom .configuration_evf import EvfConfig\nfrom .segment_anything_2.sam2.utils.misc import load_video_frames\nfrom collections import OrderedDict\n\n\n\ndef dice_loss(\n    inputs: torch.Tensor,\n    targets: torch.Tensor,\n    num_masks: float,\n    scale=1000,  # 100000.0,\n    eps=1e-6,\n):\n    \"\"\"\n    Compute the DICE loss, similar to generalized IOU for masks\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    \"\"\"\n    inputs = inputs.sigmoid()\n    inputs = inputs.flatten(1, 2)\n    targets = targets.flatten(1, 2)\n    numerator = 2 * (inputs / scale * targets).sum(-1)\n    denominator = (inputs / scale).sum(-1) + (targets / scale).sum(-1)\n    loss = 1 - (numerator + eps) / (denominator + eps)\n    loss = loss.sum() / (num_masks + 1e-8)\n    return loss\n\n\ndef sigmoid_ce_loss(\n    inputs: torch.Tensor,\n    targets: torch.Tensor,\n    num_masks: float,\n):\n    \"\"\"\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    Returns:\n        Loss tensor\n    \"\"\"\n    loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction=\"none\")\n    loss = loss.flatten(1, 2).mean(1).sum() / (num_masks + 1e-8)\n    return loss\n\nclass EvfSam2Model(PreTrainedModel):\n    config_class = EvfConfig\n    def __init__(\n        self,\n        config,\n        **kwargs\n    ):\n        super(EvfSam2Model, self).__init__(config)\n\n        self.config = config\n        self.vision_pretrained = kwargs.get(\"vision_pretrained\", None)\n        self.encoder_pretrained = kwargs.get(\"encoder_pretrained\", None)\n        self.dice_loss_weight = kwargs.get(\"dice_loss_weight\", None)\n        self.bce_loss_weight = kwargs.get(\"bce_loss_weight\", None)\n        self.train_mask_decoder = kwargs.get(\"train_mask_decoder\", False)\n        self.train_prompt_encoder = kwargs.get(\"train_prompt_encoder\", False)\n        self.initialize_evf_modules(config)\n        self._bb_feat_sizes = [\n            (256, 256),\n            (128, 128),\n            (64, 64),\n        ]\n\n    def initialize_evf_modules(self, config):\n        # SAM\n        if config.sam_scale==\"large\":\n            self.visual_model = build_sam2_video_predictor(\"sam2_hiera_l.yaml\", self.vision_pretrained, device=None)\n        elif config.sam_scale==\"tiny\":\n            self.visual_model = build_sam2_video_predictor(\"sam2_hiera_t.yaml\", self.vision_pretrained, device=None)\n        else:\n            raise NotImplementedError\n        \n        for param in self.visual_model.parameters():\n            param.requires_grad = False\n        if self.train_mask_decoder:\n            self.visual_model.sam_mask_decoder.train()\n            for param in self.visual_model.mask_decoder.parameters():\n                param.requires_grad = True\n        if self.train_prompt_encoder:\n            self.visual_model.sam_prompt_encoder.no_mask_embed.requires_grad_(True)\n            \n        # beit-3\n        if self.config.mm_extractor_scale == \"base\":\n            beit_config = _get_base_config()\n        elif self.config.mm_extractor_scale == \"large\":\n            beit_config = _get_large_config()\n        else:\n            raise AttributeError(f\"model config should contain key 'mm_extractor_scale', with value 'base' or 'large'.\")\n\n        self.mm_extractor = BEiT3Wrapper(beit_config)\n        if self.encoder_pretrained is not None:\n            beit_state_dict = torch.load(self.encoder_pretrained)[\"model\"]\n            self.mm_extractor.load_state_dict(\n                beit_state_dict, \n                strict=False\n            )\n\n        for param in self.mm_extractor.parameters():\n            param.requires_grad = True\n                \n        # Projection layer\n        in_dim = config.hidden_size\n        assert in_dim==beit_config.encoder_embed_dim, \\\n            f\"projection layer dim {in_dim} mismatch with mm_extractor dim {beit_config.encoder_embed_dim}\"\n        out_dim = config.out_dim\n        text_fc = [\n            nn.Linear(in_dim, in_dim),\n            nn.ReLU(),\n            nn.Linear(in_dim, out_dim)\n        ]\n        self.text_hidden_fcs = nn.ModuleList([nn.Sequential(*text_fc)])\n        self.text_hidden_fcs.train()\n        for param in self.text_hidden_fcs.parameters():\n            param.requires_grad = True\n\n\n    def postprocess_masks(self, masks: torch.Tensor, orig_hw) -> torch.Tensor:\n        \"\"\"\n        Perform PostProcessing on output masks.\n        \"\"\"\n        masks = masks.float()\n        masks = F.interpolate(masks, orig_hw, mode=\"bilinear\", align_corners=False)\n        return masks\n\n\n    def inference(\n            self,\n            video_path,\n            images_evf,\n            input_ids,\n        ):\n        predictor = self.visual_model\n        inference_state = predictor.init_state(video_path=video_path)\n        predictor.reset_state(inference_state)\n\n        output = self.mm_extractor.beit3(visual_tokens=images_evf, textual_tokens=input_ids, text_padding_position=torch.zeros_like(input_ids))\n\n        feat = output[\"encoder_out\"][:, :1, ...]\n        feat = self.text_hidden_fcs[0](feat)\n\n        ann_frame_idx = 0  # the frame index we interact with\n        ann_obj_id = 1  # give a unique id to each object we interact with (it can be any integers)\n\n        _, out_obj_ids, out_mask_logits = predictor.add_new_text(\n            inference_state=inference_state,\n            frame_idx=ann_frame_idx,\n            obj_id=ann_obj_id,\n            text=feat\n        )\n\n        # run propagation throughout the video and collect the results in a dict\n        video_segments = {}  # video_segments contains the per-frame segmentation results\n        for out_frame_idx, out_obj_ids, out_mask_logits in predictor.propagate_in_video(inference_state):\n            video_segments[out_frame_idx] = {\n                out_obj_id: (out_mask_logits[i] > 0.0).cpu().numpy()\n                for i, out_obj_id in enumerate(out_obj_ids)\n            }\n\n        return video_segments\n  \n\nAutoConfig.register(\"evf\", EvfConfig)\nAutoModelForCausalLM.register(EvfConfig, EvfSam2Model)"}
{"type": "source_file", "path": "model/segment_anything/modeling/__init__.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom .image_encoder import ImageEncoderViT\nfrom .mask_decoder import MaskDecoder\nfrom .prompt_encoder import PromptEncoder\nfrom .sam import Sam\nfrom .transformer import TwoWayTransformer\n"}
{"type": "source_file", "path": "model/segment_anything/modeling/transformer.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom typing import Tuple, Type\n\nimport torch\nfrom torch import Tensor, nn\n\nfrom .common import MLPBlock\n\n\nclass TwoWayTransformer(nn.Module):\n    def __init__(\n        self,\n        depth: int,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n    ) -> None:\n        \"\"\"\n        A transformer decoder that attends to an input image using\n        queries whose positional embedding is supplied.\n\n        Args:\n          depth (int): number of layers in the transformer\n          embedding_dim (int): the channel dimension for the input embeddings\n          num_heads (int): the number of heads for multihead attention. Must\n            divide embedding_dim\n          mlp_dim (int): the channel dimension internal to the MLP block\n          activation (nn.Module): the activation to use in the MLP block\n        \"\"\"\n        super().__init__()\n        self.depth = depth\n        self.embedding_dim = embedding_dim\n        self.num_heads = num_heads\n        self.mlp_dim = mlp_dim\n        self.layers = nn.ModuleList()\n\n        for i in range(depth):\n            self.layers.append(\n                TwoWayAttentionBlock(\n                    embedding_dim=embedding_dim,\n                    num_heads=num_heads,\n                    mlp_dim=mlp_dim,\n                    activation=activation,\n                    attention_downsample_rate=attention_downsample_rate,\n                    skip_first_layer_pe=(i == 0),\n                )\n            )\n\n        self.final_attn_token_to_image = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n        self.norm_final_attn = nn.LayerNorm(embedding_dim)\n\n    def forward(\n        self,\n        image_embedding: Tensor,\n        image_pe: Tensor,\n        point_embedding: Tensor,\n    ) -> Tuple[Tensor, Tensor]:\n        \"\"\"\n        Args:\n          image_embedding (torch.Tensor): image to attend to. Should be shape\n            B x embedding_dim x h x w for any h and w.\n          image_pe (torch.Tensor): the positional encoding to add to the image. Must\n            have the same shape as image_embedding.\n          point_embedding (torch.Tensor): the embedding to add to the query points.\n            Must have shape B x N_points x embedding_dim for any N_points.\n\n        Returns:\n          torch.Tensor: the processed point_embedding\n          torch.Tensor: the processed image_embedding\n        \"\"\"\n        # BxCxHxW -> BxHWxC == B x N_image_tokens x C\n        bs, c, h, w = image_embedding.shape\n        image_embedding = image_embedding.flatten(2).permute(0, 2, 1)\n        image_pe = image_pe.flatten(2).permute(0, 2, 1)\n\n        # Prepare queries\n        queries = point_embedding\n        keys = image_embedding\n\n        # Apply transformer blocks and final layernorm\n        for layer in self.layers:\n            queries, keys = layer(\n                queries=queries,\n                keys=keys,\n                query_pe=point_embedding,\n                key_pe=image_pe,\n            )\n\n        # Apply the final attention layer from the points to the image\n        q = queries + point_embedding\n        k = keys + image_pe\n        attn_out = self.final_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm_final_attn(queries)\n\n        return queries, keys\n\n\nclass TwoWayAttentionBlock(nn.Module):\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int = 2048,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n        skip_first_layer_pe: bool = False,\n    ) -> None:\n        \"\"\"\n        A transformer block with four layers: (1) self-attention of sparse\n        inputs, (2) cross attention of sparse inputs to dense inputs, (3) mlp\n        block on sparse inputs, and (4) cross attention of dense inputs to sparse\n        inputs.\n\n        Arguments:\n          embedding_dim (int): the channel dimension of the embeddings\n          num_heads (int): the number of heads in the attention layers\n          mlp_dim (int): the hidden dimension of the mlp block\n          activation (nn.Module): the activation of the mlp block\n          skip_first_layer_pe (bool): skip the PE on the first layer\n        \"\"\"\n        super().__init__()\n        self.self_attn = Attention(embedding_dim, num_heads)\n        self.norm1 = nn.LayerNorm(embedding_dim)\n\n        self.cross_attn_token_to_image = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n        self.norm2 = nn.LayerNorm(embedding_dim)\n\n        self.mlp = MLPBlock(embedding_dim, mlp_dim, activation)\n        self.norm3 = nn.LayerNorm(embedding_dim)\n\n        self.norm4 = nn.LayerNorm(embedding_dim)\n        self.cross_attn_image_to_token = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n\n        self.skip_first_layer_pe = skip_first_layer_pe\n\n    def forward(\n        self, queries: Tensor, keys: Tensor, query_pe: Tensor, key_pe: Tensor\n    ) -> Tuple[Tensor, Tensor]:\n        # Self attention block\n        if self.skip_first_layer_pe:\n            queries = self.self_attn(q=queries, k=queries, v=queries)\n        else:\n            q = queries + query_pe\n            attn_out = self.self_attn(q=q, k=q, v=queries)\n            queries = queries + attn_out\n        queries = self.norm1(queries)\n\n        # Cross attention block, tokens attending to image embedding\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm2(queries)\n\n        # MLP block\n        mlp_out = self.mlp(queries)\n        queries = queries + mlp_out\n        queries = self.norm3(queries)\n\n        # Cross attention block, image embedding attending to tokens\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_image_to_token(q=k, k=q, v=queries)\n        keys = keys + attn_out\n        keys = self.norm4(keys)\n\n        return queries, keys\n\n\nclass Attention(nn.Module):\n    \"\"\"\n    An attention layer that allows for downscaling the size of the embedding\n    after projection to queries, keys, and values.\n    \"\"\"\n\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        downsample_rate: int = 1,\n    ) -> None:\n        super().__init__()\n        self.embedding_dim = embedding_dim\n        self.internal_dim = embedding_dim // downsample_rate\n        self.num_heads = num_heads\n        assert (\n            self.internal_dim % num_heads == 0\n        ), \"num_heads must divide embedding_dim.\"\n\n        self.q_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.k_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.v_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.out_proj = nn.Linear(self.internal_dim, embedding_dim)\n\n    def _separate_heads(self, x: Tensor, num_heads: int) -> Tensor:\n        b, n, c = x.shape\n        x = x.reshape(b, n, num_heads, c // num_heads)\n        return x.transpose(1, 2)  # B x N_heads x N_tokens x C_per_head\n\n    def _recombine_heads(self, x: Tensor) -> Tensor:\n        b, n_heads, n_tokens, c_per_head = x.shape\n        x = x.transpose(1, 2)\n        return x.reshape(b, n_tokens, n_heads * c_per_head)  # B x N_tokens x C\n\n    def forward(self, q: Tensor, k: Tensor, v: Tensor) -> Tensor:\n        # Input projections\n        q = self.q_proj(q)\n        k = self.k_proj(k)\n        v = self.v_proj(v)\n\n        # Separate into heads\n        q = self._separate_heads(q, self.num_heads)\n        k = self._separate_heads(k, self.num_heads)\n        v = self._separate_heads(v, self.num_heads)\n\n        # Attention\n        _, _, _, c_per_head = q.shape\n        attn = q @ k.permute(0, 1, 3, 2)  # B x N_heads x N_tokens x N_tokens\n        attn = attn / math.sqrt(c_per_head)\n        attn = torch.softmax(attn, dim=-1)\n\n        # Get output\n        out = attn @ v\n        out = self._recombine_heads(out)\n        out = self.out_proj(out)\n\n        return out\n"}
{"type": "source_file", "path": "model/segment_anything/utils/transforms.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom copy import deepcopy\nfrom typing import Tuple\n\nimport numpy as np\nimport torch\nfrom torch.nn import functional as F\nfrom torchvision.transforms.functional import resize  # type: ignore\nfrom torchvision.transforms.functional import to_pil_image\n\n\nclass ResizeLongestSide:\n    \"\"\"\n    Resizes images to the longest side 'target_length', as well as provides\n    methods for resizing coordinates and boxes. Provides methods for\n    transforming both numpy array and batched torch tensors.\n    \"\"\"\n\n    def __init__(self, target_length: int) -> None:\n        self.target_length = target_length\n\n    def apply_image(self, image: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects a numpy array with shape HxWxC in uint8 format.\n        \"\"\"\n        target_size = self.get_preprocess_shape(\n            image.shape[0], image.shape[1], self.target_length\n        )\n        return np.array(resize(to_pil_image(image), target_size, antialias=None))\n\n    def apply_coords(\n        self, coords: np.ndarray, original_size: Tuple[int, ...]\n    ) -> np.ndarray:\n        \"\"\"\n        Expects a numpy array of length 2 in the final dimension. Requires the\n        original image size in (H, W) format.\n        \"\"\"\n        old_h, old_w = original_size\n        new_h, new_w = self.get_preprocess_shape(\n            original_size[0], original_size[1], self.target_length\n        )\n        coords = deepcopy(coords).astype(float)\n        coords[..., 0] = coords[..., 0] * (new_w / old_w)\n        coords[..., 1] = coords[..., 1] * (new_h / old_h)\n        return coords\n\n    def apply_boxes(\n        self, boxes: np.ndarray, original_size: Tuple[int, ...]\n    ) -> np.ndarray:\n        \"\"\"\n        Expects a numpy array shape Bx4. Requires the original image size\n        in (H, W) format.\n        \"\"\"\n        boxes = self.apply_coords(boxes.reshape(-1, 2, 2), original_size)\n        return boxes.reshape(-1, 4)\n\n    def apply_image_torch(self, image: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Expects batched images with shape BxCxHxW and float format. This\n        transformation may not exactly match apply_image. apply_image is\n        the transformation expected by the model.\n        \"\"\"\n        # Expects an image in BCHW format. May not exactly match apply_image.\n        target_size = self.get_preprocess_shape(\n            image.shape[0], image.shape[1], self.target_length\n        )\n        return F.interpolate(\n            image, target_size, mode=\"bilinear\", align_corners=False, antialias=True\n        )\n\n    def apply_coords_torch(\n        self, coords: torch.Tensor, original_size: Tuple[int, ...]\n    ) -> torch.Tensor:\n        \"\"\"\n        Expects a torch tensor with length 2 in the last dimension. Requires the\n        original image size in (H, W) format.\n        \"\"\"\n        old_h, old_w = original_size\n        new_h, new_w = self.get_preprocess_shape(\n            original_size[0], original_size[1], self.target_length\n        )\n        coords = deepcopy(coords).to(torch.float)\n        coords[..., 0] = coords[..., 0] * (new_w / old_w)\n        coords[..., 1] = coords[..., 1] * (new_h / old_h)\n        return coords\n\n    def apply_boxes_torch(\n        self, boxes: torch.Tensor, original_size: Tuple[int, ...]\n    ) -> torch.Tensor:\n        \"\"\"\n        Expects a torch tensor with shape Bx4. Requires the original image\n        size in (H, W) format.\n        \"\"\"\n        boxes = self.apply_coords_torch(boxes.reshape(-1, 2, 2), original_size)\n        return boxes.reshape(-1, 4)\n\n    @staticmethod\n    def get_preprocess_shape(\n        oldh: int, oldw: int, long_side_length: int\n    ) -> Tuple[int, int]:\n        \"\"\"\n        Compute the output size given input size and target long side length.\n        \"\"\"\n        scale = long_side_length * 1.0 / max(oldh, oldw)\n        newh, neww = oldh * scale, oldw * scale\n        neww = int(neww + 0.5)\n        newh = int(newh + 0.5)\n        return (newh, neww)\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/sam/mask_decoder.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import List, Optional, Tuple, Type\n\nimport torch\nfrom torch import nn\n\nfrom model.segment_anything_2.sam2.modeling.sam2_utils import LayerNorm2d, MLP\n\n\nclass MaskDecoder(nn.Module):\n    def __init__(\n        self,\n        *,\n        transformer_dim: int,\n        transformer: nn.Module,\n        num_multimask_outputs: int = 3,\n        activation: Type[nn.Module] = nn.GELU,\n        iou_head_depth: int = 3,\n        iou_head_hidden_dim: int = 256,\n        use_high_res_features: bool = False,\n        iou_prediction_use_sigmoid=False,\n        dynamic_multimask_via_stability=False,\n        dynamic_multimask_stability_delta=0.05,\n        dynamic_multimask_stability_thresh=0.98,\n        pred_obj_scores: bool = False,\n        pred_obj_scores_mlp: bool = False,\n        use_multimask_token_for_obj_ptr: bool = False,\n    ) -> None:\n        \"\"\"\n        Predicts masks given an image and prompt embeddings, using a\n        transformer architecture.\n\n        Arguments:\n          transformer_dim (int): the channel dimension of the transformer\n          transformer (nn.Module): the transformer used to predict masks\n          num_multimask_outputs (int): the number of masks to predict\n            when disambiguating masks\n          activation (nn.Module): the type of activation to use when\n            upscaling masks\n          iou_head_depth (int): the depth of the MLP used to predict\n            mask quality\n          iou_head_hidden_dim (int): the hidden dimension of the MLP\n            used to predict mask quality\n        \"\"\"\n        super().__init__()\n        self.transformer_dim = transformer_dim\n        self.transformer = transformer\n\n        self.num_multimask_outputs = num_multimask_outputs\n\n        self.iou_token = nn.Embedding(1, transformer_dim)\n        self.num_mask_tokens = num_multimask_outputs + 1\n        self.mask_tokens = nn.Embedding(self.num_mask_tokens, transformer_dim)\n\n        self.pred_obj_scores = pred_obj_scores\n        if self.pred_obj_scores:\n            self.obj_score_token = nn.Embedding(1, transformer_dim)\n        self.use_multimask_token_for_obj_ptr = use_multimask_token_for_obj_ptr\n\n        self.output_upscaling = nn.Sequential(\n            nn.ConvTranspose2d(\n                transformer_dim, transformer_dim // 4, kernel_size=2, stride=2\n            ),\n            LayerNorm2d(transformer_dim // 4),\n            activation(),\n            nn.ConvTranspose2d(\n                transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2\n            ),\n            activation(),\n        )\n        self.use_high_res_features = use_high_res_features\n        if use_high_res_features:\n            self.conv_s0 = nn.Conv2d(\n                transformer_dim, transformer_dim // 8, kernel_size=1, stride=1\n            )\n            self.conv_s1 = nn.Conv2d(\n                transformer_dim, transformer_dim // 4, kernel_size=1, stride=1\n            )\n\n        self.output_hypernetworks_mlps = nn.ModuleList(\n            [\n                MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3)\n                for i in range(self.num_mask_tokens)\n            ]\n        )\n\n        self.iou_prediction_head = MLP(\n            transformer_dim,\n            iou_head_hidden_dim,\n            self.num_mask_tokens,\n            iou_head_depth,\n            sigmoid_output=iou_prediction_use_sigmoid,\n        )\n        if self.pred_obj_scores:\n            self.pred_obj_score_head = nn.Linear(transformer_dim, 1)\n            if pred_obj_scores_mlp:\n                self.pred_obj_score_head = MLP(transformer_dim, transformer_dim, 1, 3)\n\n        # When outputting a single mask, optionally we can dynamically fall back to the best\n        # multimask output token if the single mask output token gives low stability scores.\n        self.dynamic_multimask_via_stability = dynamic_multimask_via_stability\n        self.dynamic_multimask_stability_delta = dynamic_multimask_stability_delta\n        self.dynamic_multimask_stability_thresh = dynamic_multimask_stability_thresh\n\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        multimask_output: bool,\n        repeat_image: bool,\n        high_res_features: Optional[List[torch.Tensor]] = None,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks given image and prompt embeddings.\n\n        Arguments:\n          image_embeddings (torch.Tensor): the embeddings from the image encoder\n          image_pe (torch.Tensor): positional encoding with the shape of image_embeddings\n          sparse_prompt_embeddings (torch.Tensor): the embeddings of the points and boxes\n          dense_prompt_embeddings (torch.Tensor): the embeddings of the mask inputs\n          multimask_output (bool): Whether to return multiple masks or a single\n            mask.\n\n        Returns:\n          torch.Tensor: batched predicted masks\n          torch.Tensor: batched predictions of mask quality\n          torch.Tensor: batched SAM token for mask output\n        \"\"\"\n        masks, iou_pred, mask_tokens_out, object_score_logits = self.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=image_pe,\n            sparse_prompt_embeddings=sparse_prompt_embeddings,\n            dense_prompt_embeddings=dense_prompt_embeddings,\n            repeat_image=repeat_image,\n            high_res_features=high_res_features,\n        )\n\n        # Select the correct mask or masks for output\n        if multimask_output:\n            masks = masks[:, 1:, :, :]\n            iou_pred = iou_pred[:, 1:]\n        elif self.dynamic_multimask_via_stability and not self.training:\n            masks, iou_pred = self._dynamic_multimask_via_stability(masks, iou_pred)\n        else:\n            masks = masks[:, 0:1, :, :]\n            iou_pred = iou_pred[:, 0:1]\n\n        if multimask_output and self.use_multimask_token_for_obj_ptr:\n            sam_tokens_out = mask_tokens_out[:, 1:]  # [b, 3, c] shape\n        else:\n            # Take the mask output token. Here we *always* use the token for single mask output.\n            # At test time, even if we track after 1-click (and using multimask_output=True),\n            # we still take the single mask token here. The rationale is that we always track\n            # after multiple clicks during training, so the past tokens seen during training\n            # are always the single mask token (and we'll let it be the object-memory token).\n            sam_tokens_out = mask_tokens_out[:, 0:1]  # [b, 1, c] shape\n\n        # Prepare output\n        return masks, iou_pred, sam_tokens_out, object_score_logits\n\n    def predict_masks(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        repeat_image: bool,\n        high_res_features: Optional[List[torch.Tensor]] = None,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"Predicts masks. See 'forward' for more details.\"\"\"\n        # Concatenate output tokens\n        s = 0\n        if self.pred_obj_scores:\n            output_tokens = torch.cat(\n                [\n                    self.obj_score_token.weight,\n                    self.iou_token.weight,\n                    self.mask_tokens.weight,\n                ],\n                dim=0,\n            )\n            s = 1\n        else:\n            output_tokens = torch.cat(\n                [self.iou_token.weight, self.mask_tokens.weight], dim=0\n            )\n        output_tokens = output_tokens.unsqueeze(0).expand(\n            sparse_prompt_embeddings.size(0), -1, -1\n        )\n        tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)\n\n        # Expand per-image data in batch direction to be per-mask\n        if repeat_image:\n            src = torch.repeat_interleave(image_embeddings, tokens.shape[0], dim=0)\n        else:\n            assert image_embeddings.shape[0] == tokens.shape[0]\n            src = image_embeddings\n        src = src + dense_prompt_embeddings\n        assert (\n            image_pe.size(0) == 1\n        ), \"image_pe should have size 1 in batch dim (from `get_dense_pe()`)\"\n        pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)\n        b, c, h, w = src.shape\n\n        # Run the transformer\n        hs, src = self.transformer(src, pos_src, tokens)\n        iou_token_out = hs[:, s, :]\n        mask_tokens_out = hs[:, s + 1 : (s + 1 + self.num_mask_tokens), :]\n\n        # Upscale mask embeddings and predict masks using the mask tokens\n        src = src.transpose(1, 2).view(b, c, h, w)\n        if not self.use_high_res_features:\n            upscaled_embedding = self.output_upscaling(src)\n        else:\n            dc1, ln1, act1, dc2, act2 = self.output_upscaling\n            feat_s0, feat_s1 = high_res_features\n            upscaled_embedding = act1(ln1(dc1(src) + feat_s1))\n            upscaled_embedding = act2(dc2(upscaled_embedding) + feat_s0)\n\n        hyper_in_list: List[torch.Tensor] = []\n        for i in range(self.num_mask_tokens):\n            hyper_in_list.append(\n                self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :])\n            )\n        hyper_in = torch.stack(hyper_in_list, dim=1)\n        b, c, h, w = upscaled_embedding.shape\n        masks = (hyper_in @ upscaled_embedding.view(b, c, h * w)).view(b, -1, h, w)\n\n        # Generate mask quality predictions\n        iou_pred = self.iou_prediction_head(iou_token_out)\n        if self.pred_obj_scores:\n            assert s == 1\n            object_score_logits = self.pred_obj_score_head(hs[:, 0, :])\n        else:\n            # Obj scores logits - default to 10.0, i.e. assuming the object is present, sigmoid(10)=1\n            object_score_logits = 10.0 * iou_pred.new_ones(iou_pred.shape[0], 1)\n\n        return masks, iou_pred, mask_tokens_out, object_score_logits\n\n    def _get_stability_scores(self, mask_logits):\n        \"\"\"\n        Compute stability scores of the mask logits based on the IoU between upper and\n        lower thresholds, similar to https://github.com/fairinternal/onevision/pull/568.\n        \"\"\"\n        mask_logits = mask_logits.flatten(-2)\n        stability_delta = self.dynamic_multimask_stability_delta\n        area_i = torch.sum(mask_logits > stability_delta, dim=-1).float()\n        area_u = torch.sum(mask_logits > -stability_delta, dim=-1).float()\n        stability_scores = torch.where(area_u > 0, area_i / area_u, 1.0)\n        return stability_scores\n\n    def _dynamic_multimask_via_stability(self, all_mask_logits, all_iou_scores):\n        \"\"\"\n        When outputting a single mask, if the stability score from the current single-mask\n        output (based on output token 0) falls below a threshold, we instead select from\n        multi-mask outputs (based on output token 1~3) the mask with the highest predicted\n        IoU score. This is intended to ensure a valid mask for both clicking and tracking.\n        \"\"\"\n        # The best mask from multimask output tokens (1~3)\n        multimask_logits = all_mask_logits[:, 1:, :, :]\n        multimask_iou_scores = all_iou_scores[:, 1:]\n        best_scores_inds = torch.argmax(multimask_iou_scores, dim=-1)\n        batch_inds = torch.arange(\n            multimask_iou_scores.size(0), device=all_iou_scores.device\n        )\n        best_multimask_logits = multimask_logits[batch_inds, best_scores_inds]\n        best_multimask_logits = best_multimask_logits.unsqueeze(1)\n        best_multimask_iou_scores = multimask_iou_scores[batch_inds, best_scores_inds]\n        best_multimask_iou_scores = best_multimask_iou_scores.unsqueeze(1)\n\n        # The mask from singlemask output token 0 and its stability score\n        singlemask_logits = all_mask_logits[:, 0:1, :, :]\n        singlemask_iou_scores = all_iou_scores[:, 0:1]\n        stability_scores = self._get_stability_scores(singlemask_logits)\n        is_stable = stability_scores >= self.dynamic_multimask_stability_thresh\n\n        # Dynamically fall back to best multimask output upon low stability scores.\n        mask_logits_out = torch.where(\n            is_stable[..., None, None].expand_as(singlemask_logits),\n            singlemask_logits,\n            best_multimask_logits,\n        )\n        iou_scores_out = torch.where(\n            is_stable.expand_as(singlemask_iou_scores),\n            singlemask_iou_scores,\n            best_multimask_iou_scores,\n        )\n        return mask_logits_out, iou_scores_out\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/sam/transformer.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nimport warnings\nfrom functools import partial\nfrom typing import Tuple, Type\n\nimport torch\nimport torch.nn.functional as F\nfrom torch import nn, Tensor\n\nfrom model.segment_anything_2.sam2.modeling.position_encoding import apply_rotary_enc, compute_axial_cis\n\nfrom model.segment_anything_2.sam2.modeling.sam2_utils import MLP\nfrom model.segment_anything_2.sam2.utils.misc import get_sdpa_settings\n\nwarnings.simplefilter(action=\"ignore\", category=FutureWarning)\nOLD_GPU, USE_FLASH_ATTN, MATH_KERNEL_ON = get_sdpa_settings()\n\n\nclass TwoWayTransformer(nn.Module):\n    def __init__(\n        self,\n        depth: int,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n    ) -> None:\n        \"\"\"\n        A transformer decoder that attends to an input image using\n        queries whose positional embedding is supplied.\n\n        Args:\n          depth (int): number of layers in the transformer\n          embedding_dim (int): the channel dimension for the input embeddings\n          num_heads (int): the number of heads for multihead attention. Must\n            divide embedding_dim\n          mlp_dim (int): the channel dimension internal to the MLP block\n          activation (nn.Module): the activation to use in the MLP block\n        \"\"\"\n        super().__init__()\n        self.depth = depth\n        self.embedding_dim = embedding_dim\n        self.num_heads = num_heads\n        self.mlp_dim = mlp_dim\n        self.layers = nn.ModuleList()\n\n        for i in range(depth):\n            self.layers.append(\n                TwoWayAttentionBlock(\n                    embedding_dim=embedding_dim,\n                    num_heads=num_heads,\n                    mlp_dim=mlp_dim,\n                    activation=activation,\n                    attention_downsample_rate=attention_downsample_rate,\n                    skip_first_layer_pe=(i == 0),\n                )\n            )\n\n        self.final_attn_token_to_image = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n        self.norm_final_attn = nn.LayerNorm(embedding_dim)\n\n    def forward(\n        self,\n        image_embedding: Tensor,\n        image_pe: Tensor,\n        point_embedding: Tensor,\n    ) -> Tuple[Tensor, Tensor]:\n        \"\"\"\n        Args:\n          image_embedding (torch.Tensor): image to attend to. Should be shape\n            B x embedding_dim x h x w for any h and w.\n          image_pe (torch.Tensor): the positional encoding to add to the image. Must\n            have the same shape as image_embedding.\n          point_embedding (torch.Tensor): the embedding to add to the query points.\n            Must have shape B x N_points x embedding_dim for any N_points.\n\n        Returns:\n          torch.Tensor: the processed point_embedding\n          torch.Tensor: the processed image_embedding\n        \"\"\"\n        # BxCxHxW -> BxHWxC == B x N_image_tokens x C\n        bs, c, h, w = image_embedding.shape\n        image_embedding = image_embedding.flatten(2).permute(0, 2, 1)\n        image_pe = image_pe.flatten(2).permute(0, 2, 1)\n\n        # Prepare queries\n        queries = point_embedding\n        keys = image_embedding\n\n        # Apply transformer blocks and final layernorm\n        for layer in self.layers:\n            queries, keys = layer(\n                queries=queries,\n                keys=keys,\n                query_pe=point_embedding,\n                key_pe=image_pe,\n            )\n\n        # Apply the final attention layer from the points to the image\n        q = queries + point_embedding\n        k = keys + image_pe\n        attn_out = self.final_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm_final_attn(queries)\n\n        return queries, keys\n\n\nclass TwoWayAttentionBlock(nn.Module):\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int = 2048,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n        skip_first_layer_pe: bool = False,\n    ) -> None:\n        \"\"\"\n        A transformer block with four layers: (1) self-attention of sparse\n        inputs, (2) cross attention of sparse inputs to dense inputs, (3) mlp\n        block on sparse inputs, and (4) cross attention of dense inputs to sparse\n        inputs.\n\n        Arguments:\n          embedding_dim (int): the channel dimension of the embeddings\n          num_heads (int): the number of heads in the attention layers\n          mlp_dim (int): the hidden dimension of the mlp block\n          activation (nn.Module): the activation of the mlp block\n          skip_first_layer_pe (bool): skip the PE on the first layer\n        \"\"\"\n        super().__init__()\n        self.self_attn = Attention(embedding_dim, num_heads)\n        self.norm1 = nn.LayerNorm(embedding_dim)\n\n        self.cross_attn_token_to_image = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n        self.norm2 = nn.LayerNorm(embedding_dim)\n\n        self.mlp = MLP(\n            embedding_dim, mlp_dim, embedding_dim, num_layers=2, activation=activation\n        )\n        self.norm3 = nn.LayerNorm(embedding_dim)\n\n        self.norm4 = nn.LayerNorm(embedding_dim)\n        self.cross_attn_image_to_token = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n\n        self.skip_first_layer_pe = skip_first_layer_pe\n\n    def forward(\n        self, queries: Tensor, keys: Tensor, query_pe: Tensor, key_pe: Tensor\n    ) -> Tuple[Tensor, Tensor]:\n        # Self attention block\n        if self.skip_first_layer_pe:\n            queries = self.self_attn(q=queries, k=queries, v=queries)\n        else:\n            q = queries + query_pe\n            attn_out = self.self_attn(q=q, k=q, v=queries)\n            queries = queries + attn_out\n        queries = self.norm1(queries)\n\n        # Cross attention block, tokens attending to image embedding\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm2(queries)\n\n        # MLP block\n        mlp_out = self.mlp(queries)\n        queries = queries + mlp_out\n        queries = self.norm3(queries)\n\n        # Cross attention block, image embedding attending to tokens\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_image_to_token(q=k, k=q, v=queries)\n        keys = keys + attn_out\n        keys = self.norm4(keys)\n\n        return queries, keys\n\n\nclass Attention(nn.Module):\n    \"\"\"\n    An attention layer that allows for downscaling the size of the embedding\n    after projection to queries, keys, and values.\n    \"\"\"\n\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        downsample_rate: int = 1,\n        dropout: float = 0.0,\n        kv_in_dim: int = None,\n    ) -> None:\n        super().__init__()\n        self.embedding_dim = embedding_dim\n        self.kv_in_dim = kv_in_dim if kv_in_dim is not None else embedding_dim\n        self.internal_dim = embedding_dim // downsample_rate\n        self.num_heads = num_heads\n        assert (\n            self.internal_dim % num_heads == 0\n        ), \"num_heads must divide embedding_dim.\"\n\n        self.q_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.k_proj = nn.Linear(self.kv_in_dim, self.internal_dim)\n        self.v_proj = nn.Linear(self.kv_in_dim, self.internal_dim)\n        self.out_proj = nn.Linear(self.internal_dim, embedding_dim)\n\n        self.dropout_p = dropout\n\n    def _separate_heads(self, x: Tensor, num_heads: int) -> Tensor:\n        b, n, c = x.shape\n        x = x.reshape(b, n, num_heads, c // num_heads)\n        return x.transpose(1, 2)  # B x N_heads x N_tokens x C_per_head\n\n    def _recombine_heads(self, x: Tensor) -> Tensor:\n        b, n_heads, n_tokens, c_per_head = x.shape\n        x = x.transpose(1, 2)\n        return x.reshape(b, n_tokens, n_heads * c_per_head)  # B x N_tokens x C\n\n    def forward(self, q: Tensor, k: Tensor, v: Tensor) -> Tensor:\n        # Input projections\n        q = self.q_proj(q)\n        k = self.k_proj(k)\n        v = self.v_proj(v)\n\n        # Separate into heads\n        q = self._separate_heads(q, self.num_heads)\n        k = self._separate_heads(k, self.num_heads)\n        v = self._separate_heads(v, self.num_heads)\n\n        dropout_p = self.dropout_p if self.training else 0.0\n        # Attention\n        with torch.backends.cuda.sdp_kernel(\n            enable_flash=USE_FLASH_ATTN,\n            # if Flash attention kernel is off, then math kernel needs to be enabled\n            enable_math=(OLD_GPU and dropout_p > 0.0) or MATH_KERNEL_ON,\n            enable_mem_efficient=OLD_GPU,\n        ):\n            out = F.scaled_dot_product_attention(q, k, v, dropout_p=dropout_p)\n\n        out = self._recombine_heads(out)\n        out = self.out_proj(out)\n\n        return out\n\n\nclass RoPEAttention(Attention):\n    \"\"\"Attention with rotary position encoding.\"\"\"\n\n    def __init__(\n        self,\n        *args,\n        rope_theta=10000.0,\n        # whether to repeat q rope to match k length\n        # this is needed for cross-attention to memories\n        rope_k_repeat=False,\n        feat_sizes=(32, 32),  # [w, h] for stride 16 feats at 512 resolution\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n\n        self.compute_cis = partial(\n            compute_axial_cis, dim=self.internal_dim // self.num_heads, theta=rope_theta\n        )\n        freqs_cis = self.compute_cis(end_x=feat_sizes[0], end_y=feat_sizes[1])\n        self.freqs_cis = freqs_cis\n        self.rope_k_repeat = rope_k_repeat\n\n    def forward(\n        self, q: Tensor, k: Tensor, v: Tensor, num_k_exclude_rope: int = 0\n    ) -> Tensor:\n        # Input projections\n        q = self.q_proj(q)\n        k = self.k_proj(k)\n        v = self.v_proj(v)\n\n        # Separate into heads\n        q = self._separate_heads(q, self.num_heads)\n        k = self._separate_heads(k, self.num_heads)\n        v = self._separate_heads(v, self.num_heads)\n\n        # Apply rotary position encoding\n        w = h = math.sqrt(q.shape[-2])\n        self.freqs_cis = self.freqs_cis.to(q.device)\n        if self.freqs_cis.shape[0] != q.shape[-2]:\n            self.freqs_cis = self.compute_cis(end_x=w, end_y=h).to(q.device)\n        if q.shape[-2] != k.shape[-2]:\n            assert self.rope_k_repeat\n\n        num_k_rope = k.size(-2) - num_k_exclude_rope\n        q, k[:, :, :num_k_rope] = apply_rotary_enc(\n            q,\n            k[:, :, :num_k_rope],\n            freqs_cis=self.freqs_cis,\n            repeat_freqs_k=self.rope_k_repeat,\n        )\n\n        dropout_p = self.dropout_p if self.training else 0.0\n        # Attention\n        with torch.backends.cuda.sdp_kernel(\n            enable_flash=USE_FLASH_ATTN,\n            # if Flash attention kernel is off, then math kernel needs to be enabled\n            enable_math=(OLD_GPU and dropout_p > 0.0) or MATH_KERNEL_ON,\n            enable_mem_efficient=OLD_GPU,\n        ):\n            out = F.scaled_dot_product_attention(q, k, v, dropout_p=dropout_p)\n\n        out = self._recombine_heads(out)\n        out = self.out_proj(out)\n\n        return out\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/sam/__init__.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/memory_attention.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Optional\n\nimport torch\nfrom torch import nn, Tensor\n\nfrom model.segment_anything_2.sam2.modeling.sam.transformer import RoPEAttention\n\nfrom model.segment_anything_2.sam2.modeling.sam2_utils import get_activation_fn, get_clones\n\n\nclass MemoryAttentionLayer(nn.Module):\n\n    def __init__(\n        self,\n        activation: str,\n        cross_attention: nn.Module,\n        d_model: int,\n        dim_feedforward: int,\n        dropout: float,\n        pos_enc_at_attn: bool,\n        pos_enc_at_cross_attn_keys: bool,\n        pos_enc_at_cross_attn_queries: bool,\n        self_attention: nn.Module,\n    ):\n        super().__init__()\n        self.d_model = d_model\n        self.dim_feedforward = dim_feedforward\n        self.dropout_value = dropout\n        self.self_attn = self_attention\n        self.cross_attn_image = cross_attention\n\n        # Implementation of Feedforward model\n        self.linear1 = nn.Linear(d_model, dim_feedforward)\n        self.dropout = nn.Dropout(dropout)\n        self.linear2 = nn.Linear(dim_feedforward, d_model)\n\n        self.norm1 = nn.LayerNorm(d_model)\n        self.norm2 = nn.LayerNorm(d_model)\n        self.norm3 = nn.LayerNorm(d_model)\n        self.dropout1 = nn.Dropout(dropout)\n        self.dropout2 = nn.Dropout(dropout)\n        self.dropout3 = nn.Dropout(dropout)\n\n        self.activation_str = activation\n        self.activation = get_activation_fn(activation)\n\n        # Where to add pos enc\n        self.pos_enc_at_attn = pos_enc_at_attn\n        self.pos_enc_at_cross_attn_queries = pos_enc_at_cross_attn_queries\n        self.pos_enc_at_cross_attn_keys = pos_enc_at_cross_attn_keys\n\n    def _forward_sa(self, tgt, query_pos):\n        # Self-Attention\n        tgt2 = self.norm1(tgt)\n        q = k = tgt2 + query_pos if self.pos_enc_at_attn else tgt2\n        tgt2 = self.self_attn(q, k, v=tgt2)\n        tgt = tgt + self.dropout1(tgt2)\n        return tgt\n\n    def _forward_ca(self, tgt, memory, query_pos, pos, num_k_exclude_rope=0):\n        kwds = {}\n        if num_k_exclude_rope > 0:\n            assert isinstance(self.cross_attn_image, RoPEAttention)\n            kwds = {\"num_k_exclude_rope\": num_k_exclude_rope}\n\n        # Cross-Attention\n        tgt2 = self.norm2(tgt)\n        tgt2 = self.cross_attn_image(\n            q=tgt2 + query_pos if self.pos_enc_at_cross_attn_queries else tgt2,\n            k=memory + pos if self.pos_enc_at_cross_attn_keys else memory,\n            v=memory,\n            **kwds,\n        )\n        tgt = tgt + self.dropout2(tgt2)\n        return tgt\n\n    def forward(\n        self,\n        tgt,\n        memory,\n        pos: Optional[Tensor] = None,\n        query_pos: Optional[Tensor] = None,\n        num_k_exclude_rope: int = 0,\n    ) -> torch.Tensor:\n\n        # Self-Attn, Cross-Attn\n        tgt = self._forward_sa(tgt, query_pos)\n        tgt = self._forward_ca(tgt, memory, query_pos, pos, num_k_exclude_rope)\n        # MLP\n        tgt2 = self.norm3(tgt)\n        tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt2))))\n        tgt = tgt + self.dropout3(tgt2)\n        return tgt\n\n\nclass MemoryAttention(nn.Module):\n    def __init__(\n        self,\n        d_model: int,\n        pos_enc_at_input: bool,\n        layer: nn.Module,\n        num_layers: int,\n        batch_first: bool = True,  # Do layers expect batch first input?\n    ):\n        super().__init__()\n        self.d_model = d_model\n        self.layers = get_clones(layer, num_layers)\n        self.num_layers = num_layers\n        self.norm = nn.LayerNorm(d_model)\n        self.pos_enc_at_input = pos_enc_at_input\n        self.batch_first = batch_first\n\n    def forward(\n        self,\n        curr: torch.Tensor,  # self-attention inputs\n        memory: torch.Tensor,  # cross-attention inputs\n        curr_pos: Optional[Tensor] = None,  # pos_enc for self-attention inputs\n        memory_pos: Optional[Tensor] = None,  # pos_enc for cross-attention inputs\n        num_obj_ptr_tokens: int = 0,  # number of object pointer *tokens*\n    ):\n        if isinstance(curr, list):\n            assert isinstance(curr_pos, list)\n            assert len(curr) == len(curr_pos) == 1\n            curr, curr_pos = (\n                curr[0],\n                curr_pos[0],\n            )\n\n        assert (\n            curr.shape[1] == memory.shape[1]\n        ), \"Batch size must be the same for curr and memory\"\n\n        output = curr\n        if self.pos_enc_at_input and curr_pos is not None:\n            output = output + 0.1 * curr_pos\n\n        if self.batch_first:\n            # Convert to batch first\n            output = output.transpose(0, 1)\n            curr_pos = curr_pos.transpose(0, 1)\n            memory = memory.transpose(0, 1)\n            memory_pos = memory_pos.transpose(0, 1)\n\n        for layer in self.layers:\n            kwds = {}\n            if isinstance(layer.cross_attn_image, RoPEAttention):\n                kwds = {\"num_k_exclude_rope\": num_obj_ptr_tokens}\n\n            output = layer(\n                tgt=output,\n                memory=memory,\n                pos=memory_pos,\n                query_pos=curr_pos,\n                **kwds,\n            )\n        normed_output = self.norm(output)\n\n        if self.batch_first:\n            # Convert back to seq first\n            normed_output = normed_output.transpose(0, 1)\n            curr_pos = curr_pos.transpose(0, 1)\n\n        return normed_output\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/sam2_utils.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nimport copy\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\ndef select_closest_cond_frames(frame_idx, cond_frame_outputs, max_cond_frame_num):\n    \"\"\"\n    Select up to `max_cond_frame_num` conditioning frames from `cond_frame_outputs`\n    that are temporally closest to the current frame at `frame_idx`. Here, we take\n    - a) the closest conditioning frame before `frame_idx` (if any);\n    - b) the closest conditioning frame after `frame_idx` (if any);\n    - c) any other temporally closest conditioning frames until reaching a total\n         of `max_cond_frame_num` conditioning frames.\n\n    Outputs:\n    - selected_outputs: selected items (keys & values) from `cond_frame_outputs`.\n    - unselected_outputs: items (keys & values) not selected in `cond_frame_outputs`.\n    \"\"\"\n    if max_cond_frame_num == -1 or len(cond_frame_outputs) <= max_cond_frame_num:\n        selected_outputs = cond_frame_outputs\n        unselected_outputs = {}\n    else:\n        assert max_cond_frame_num >= 2, \"we should allow using 2+ conditioning frames\"\n        selected_outputs = {}\n\n        # the closest conditioning frame before `frame_idx` (if any)\n        idx_before = max((t for t in cond_frame_outputs if t < frame_idx), default=None)\n        if idx_before is not None:\n            selected_outputs[idx_before] = cond_frame_outputs[idx_before]\n\n        # the closest conditioning frame after `frame_idx` (if any)\n        idx_after = min((t for t in cond_frame_outputs if t >= frame_idx), default=None)\n        if idx_after is not None:\n            selected_outputs[idx_after] = cond_frame_outputs[idx_after]\n\n        # add other temporally closest conditioning frames until reaching a total\n        # of `max_cond_frame_num` conditioning frames.\n        num_remain = max_cond_frame_num - len(selected_outputs)\n        inds_remain = sorted(\n            (t for t in cond_frame_outputs if t not in selected_outputs),\n            key=lambda x: abs(x - frame_idx),\n        )[:num_remain]\n        selected_outputs.update((t, cond_frame_outputs[t]) for t in inds_remain)\n        unselected_outputs = {\n            t: v for t, v in cond_frame_outputs.items() if t not in selected_outputs\n        }\n\n    return selected_outputs, unselected_outputs\n\n\ndef get_1d_sine_pe(pos_inds, dim, temperature=10000):\n    \"\"\"\n    Get 1D sine positional embedding as in the original Transformer paper.\n    \"\"\"\n    pe_dim = dim // 2\n    dim_t = torch.arange(pe_dim, dtype=torch.float32, device=pos_inds.device)\n    dim_t = temperature ** (2 * (dim_t // 2) / pe_dim)\n\n    pos_embed = pos_inds.unsqueeze(-1) / dim_t\n    pos_embed = torch.cat([pos_embed.sin(), pos_embed.cos()], dim=-1)\n    return pos_embed\n\n\ndef get_activation_fn(activation):\n    \"\"\"Return an activation function given a string\"\"\"\n    if activation == \"relu\":\n        return F.relu\n    if activation == \"gelu\":\n        return F.gelu\n    if activation == \"glu\":\n        return F.glu\n    raise RuntimeError(f\"activation should be relu/gelu, not {activation}.\")\n\n\ndef get_clones(module, N):\n    return nn.ModuleList([copy.deepcopy(module) for i in range(N)])\n\n\nclass DropPath(nn.Module):\n    # adapted from https://github.com/huggingface/pytorch-image-models/blob/main/timm/layers/drop.py\n    def __init__(self, drop_prob=0.0, scale_by_keep=True):\n        super(DropPath, self).__init__()\n        self.drop_prob = drop_prob\n        self.scale_by_keep = scale_by_keep\n\n    def forward(self, x):\n        if self.drop_prob == 0.0 or not self.training:\n            return x\n        keep_prob = 1 - self.drop_prob\n        shape = (x.shape[0],) + (1,) * (x.ndim - 1)\n        random_tensor = x.new_empty(shape).bernoulli_(keep_prob)\n        if keep_prob > 0.0 and self.scale_by_keep:\n            random_tensor.div_(keep_prob)\n        return x * random_tensor\n\n\n# Lightly adapted from\n# https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py # noqa\nclass MLP(nn.Module):\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,\n        num_layers: int,\n        activation: nn.Module = nn.ReLU,\n        sigmoid_output: bool = False,\n    ) -> None:\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(\n            nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim])\n        )\n        self.sigmoid_output = sigmoid_output\n        self.act = activation()\n\n    def forward(self, x):\n        for i, layer in enumerate(self.layers):\n            x = self.act(layer(x)) if i < self.num_layers - 1 else layer(x)\n        if self.sigmoid_output:\n            x = F.sigmoid(x)\n        return x\n\n\n# From https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py # noqa\n# Itself from https://github.com/facebookresearch/ConvNeXt/blob/d1fa8f6fef0a165b27399986cc2bdacc92777e40/models/convnext.py#L119  # noqa\nclass LayerNorm2d(nn.Module):\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        x = self.weight[:, None, None] * x + self.bias[:, None, None]\n        return x\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/memory_encoder.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom typing import Tuple\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom model.segment_anything_2.sam2.modeling.sam2_utils import DropPath, get_clones, LayerNorm2d\n\n\nclass MaskDownSampler(nn.Module):\n    \"\"\"\n    Progressively downsample a mask by total_stride, each time by stride.\n    Note that LayerNorm is applied per *token*, like in ViT.\n\n    With each downsample (by a factor stride**2), channel capacity increases by the same factor.\n    In the end, we linearly project to embed_dim channels.\n    \"\"\"\n\n    def __init__(\n        self,\n        embed_dim=256,\n        kernel_size=4,\n        stride=4,\n        padding=0,\n        total_stride=16,\n        activation=nn.GELU,\n    ):\n        super().__init__()\n        num_layers = int(math.log2(total_stride) // math.log2(stride))\n        assert stride**num_layers == total_stride\n        self.encoder = nn.Sequential()\n        mask_in_chans, mask_out_chans = 1, 1\n        for _ in range(num_layers):\n            mask_out_chans = mask_in_chans * (stride**2)\n            self.encoder.append(\n                nn.Conv2d(\n                    mask_in_chans,\n                    mask_out_chans,\n                    kernel_size=kernel_size,\n                    stride=stride,\n                    padding=padding,\n                )\n            )\n            self.encoder.append(LayerNorm2d(mask_out_chans))\n            self.encoder.append(activation())\n            mask_in_chans = mask_out_chans\n\n        self.encoder.append(nn.Conv2d(mask_out_chans, embed_dim, kernel_size=1))\n\n    def forward(self, x):\n        return self.encoder(x)\n\n\n# Lightly adapted from ConvNext (https://github.com/facebookresearch/ConvNeXt)\nclass CXBlock(nn.Module):\n    r\"\"\"ConvNeXt Block. There are two equivalent implementations:\n    (1) DwConv -> LayerNorm (channels_first) -> 1x1 Conv -> GELU -> 1x1 Conv; all in (N, C, H, W)\n    (2) DwConv -> Permute to (N, H, W, C); LayerNorm (channels_last) -> Linear -> GELU -> Linear; Permute back\n    We use (2) as we find it slightly faster in PyTorch\n\n    Args:\n        dim (int): Number of input channels.\n        drop_path (float): Stochastic depth rate. Default: 0.0\n        layer_scale_init_value (float): Init value for Layer Scale. Default: 1e-6.\n    \"\"\"\n\n    def __init__(\n        self,\n        dim,\n        kernel_size=7,\n        padding=3,\n        drop_path=0.0,\n        layer_scale_init_value=1e-6,\n        use_dwconv=True,\n    ):\n        super().__init__()\n        self.dwconv = nn.Conv2d(\n            dim,\n            dim,\n            kernel_size=kernel_size,\n            padding=padding,\n            groups=dim if use_dwconv else 1,\n        )  # depthwise conv\n        self.norm = LayerNorm2d(dim, eps=1e-6)\n        self.pwconv1 = nn.Linear(\n            dim, 4 * dim\n        )  # pointwise/1x1 convs, implemented with linear layers\n        self.act = nn.GELU()\n        self.pwconv2 = nn.Linear(4 * dim, dim)\n        # modified by ZhangYx from self.gamma to self.weight. Due to (https://github.com/facebookresearch/segment-anything-2/issues/85)\n        self.weight = (\n            nn.Parameter(layer_scale_init_value * torch.ones((dim)), requires_grad=True)\n            if layer_scale_init_value > 0\n            else None\n        )\n        self.drop_path = DropPath(drop_path) if drop_path > 0.0 else nn.Identity()\n\n    def forward(self, x):\n        input = x\n        x = self.dwconv(x)\n        x = self.norm(x)\n        x = x.permute(0, 2, 3, 1)  # (N, C, H, W) -> (N, H, W, C)\n        x = self.pwconv1(x)\n        x = self.act(x)\n        x = self.pwconv2(x)\n        if self.weight is not None:\n            x = self.weight * x\n        x = x.permute(0, 3, 1, 2)  # (N, H, W, C) -> (N, C, H, W)\n\n        x = input + self.drop_path(x)\n        return x\n\n\nclass Fuser(nn.Module):\n    def __init__(self, layer, num_layers, dim=None, input_projection=False):\n        super().__init__()\n        self.proj = nn.Identity()\n        self.layers = get_clones(layer, num_layers)\n\n        if input_projection:\n            assert dim is not None\n            self.proj = nn.Conv2d(dim, dim, kernel_size=1)\n\n    def forward(self, x):\n        # normally x: (N, C, H, W)\n        x = self.proj(x)\n        for layer in self.layers:\n            x = layer(x)\n        return x\n\n\nclass MemoryEncoder(nn.Module):\n    def __init__(\n        self,\n        out_dim,\n        mask_downsampler,\n        fuser,\n        position_encoding,\n        in_dim=256,  # in_dim of pix_feats\n    ):\n        super().__init__()\n\n        self.mask_downsampler = mask_downsampler\n\n        self.pix_feat_proj = nn.Conv2d(in_dim, in_dim, kernel_size=1)\n        self.fuser = fuser\n        self.position_encoding = position_encoding\n        self.out_proj = nn.Identity()\n        if out_dim != in_dim:\n            self.out_proj = nn.Conv2d(in_dim, out_dim, kernel_size=1)\n\n    def forward(\n        self,\n        pix_feat: torch.Tensor,\n        masks: torch.Tensor,\n        skip_mask_sigmoid: bool = False,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        ## Process masks\n        # sigmoid, so that less domain shift from gt masks which are bool\n        if not skip_mask_sigmoid:\n            masks = F.sigmoid(masks)\n        masks = self.mask_downsampler(masks)\n\n        ## Fuse pix_feats and downsampled masks\n        # in case the visual features are on CPU, cast them to CUDA\n        pix_feat = pix_feat.to(masks.device)\n\n        x = self.pix_feat_proj(pix_feat)\n        x = x + masks\n        x = self.fuser(x)\n        x = self.out_proj(x)\n\n        pos = self.position_encoding(x).to(x.dtype)\n\n        return {\"vision_features\": x, \"vision_pos_enc\": [pos]}\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/backbones/utils.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\"\"\"Some utilities for backbones, in particular for windowing\"\"\"\n\nfrom typing import Tuple\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\ndef window_partition(x, window_size):\n    \"\"\"\n    Partition into non-overlapping windows with padding if needed.\n    Args:\n        x (tensor): input tokens with [B, H, W, C].\n        window_size (int): window size.\n    Returns:\n        windows: windows after partition with [B * num_windows, window_size, window_size, C].\n        (Hp, Wp): padded height and width before partition\n    \"\"\"\n    B, H, W, C = x.shape\n\n    pad_h = (window_size - H % window_size) % window_size\n    pad_w = (window_size - W % window_size) % window_size\n    if pad_h > 0 or pad_w > 0:\n        x = F.pad(x, (0, 0, 0, pad_w, 0, pad_h))\n    Hp, Wp = H + pad_h, W + pad_w\n\n    x = x.view(B, Hp // window_size, window_size, Wp // window_size, window_size, C)\n    windows = (\n        x.permute(0, 1, 3, 2, 4, 5).contiguous().view(-1, window_size, window_size, C)\n    )\n    return windows, (Hp, Wp)\n\n\ndef window_unpartition(windows, window_size, pad_hw, hw):\n    \"\"\"\n    Window unpartition into original sequences and removing padding.\n    Args:\n        x (tensor): input tokens with [B * num_windows, window_size, window_size, C].\n        window_size (int): window size.\n        pad_hw (Tuple): padded height and width (Hp, Wp).\n        hw (Tuple): original height and width (H, W) before padding.\n    Returns:\n        x: unpartitioned sequences with [B, H, W, C].\n    \"\"\"\n    Hp, Wp = pad_hw\n    H, W = hw\n    B = windows.shape[0] // (Hp * Wp // window_size // window_size)\n    x = windows.view(\n        B, Hp // window_size, Wp // window_size, window_size, window_size, -1\n    )\n    x = x.permute(0, 1, 3, 2, 4, 5).contiguous().view(B, Hp, Wp, -1)\n\n    if Hp > H or Wp > W:\n        x = x[:, :H, :W, :].contiguous()\n    return x\n\n\nclass PatchEmbed(nn.Module):\n    \"\"\"\n    Image to Patch Embedding.\n    \"\"\"\n\n    def __init__(\n        self,\n        kernel_size: Tuple[int, ...] = (7, 7),\n        stride: Tuple[int, ...] = (4, 4),\n        padding: Tuple[int, ...] = (3, 3),\n        in_chans: int = 3,\n        embed_dim: int = 768,\n    ):\n        \"\"\"\n        Args:\n            kernel_size (Tuple): kernel size of the projection layer.\n            stride (Tuple): stride of the projection layer.\n            padding (Tuple): padding size of the projection layer.\n            in_chans (int): Number of input image channels.\n            embed_dim (int):  embed_dim (int): Patch embedding dimension.\n        \"\"\"\n        super().__init__()\n        self.proj = nn.Conv2d(\n            in_chans, embed_dim, kernel_size=kernel_size, stride=stride, padding=padding\n        )\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = self.proj(x)\n        # B C H W -> B H W C\n        x = x.permute(0, 2, 3, 1)\n        return x\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/sam/prompt_encoder.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Any, Optional, Tuple, Type\n\nimport numpy as np\nimport torch\nfrom torch import nn\n# from model.segment_anything_2.sam2.modeling.position_encoding import PositionEmbeddingRandom\n\nfrom model.segment_anything_2.sam2.modeling.sam2_utils import LayerNorm2d\n\n\nclass PromptEncoder(nn.Module):\n    def __init__(\n        self,\n        embed_dim: int,\n        image_embedding_size: Tuple[int, int],\n        input_image_size: Tuple[int, int],\n        mask_in_chans: int,\n        activation: Type[nn.Module] = nn.GELU,\n    ) -> None:\n        \"\"\"\n        Encodes prompts for input to SAM's mask decoder.\n\n        Arguments:\n          embed_dim (int): The prompts' embedding dimension\n          image_embedding_size (tuple(int, int)): The spatial size of the\n            image embedding, as (H, W).\n          input_image_size (int): The padded size of the image as input\n            to the image encoder, as (H, W).\n          mask_in_chans (int): The number of hidden channels used for\n            encoding input masks.\n          activation (nn.Module): The activation to use when encoding\n            input masks.\n        \"\"\"\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.input_image_size = input_image_size\n        self.image_embedding_size = image_embedding_size\n        self.pe_layer = PositionEmbeddingRandom(embed_dim // 2)\n\n        self.num_point_embeddings: int = 4  # pos/neg point + 2 box corners\n        point_embeddings = [\n            nn.Embedding(1, embed_dim) for i in range(self.num_point_embeddings)\n        ]\n        self.point_embeddings = nn.ModuleList(point_embeddings)\n        self.not_a_point_embed = nn.Embedding(1, embed_dim)\n\n        self.mask_input_size = (\n            4 * image_embedding_size[0],\n            4 * image_embedding_size[1],\n        )\n        self.mask_downscaling = nn.Sequential(\n            nn.Conv2d(1, mask_in_chans // 4, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans // 4),\n            activation(),\n            nn.Conv2d(mask_in_chans // 4, mask_in_chans, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans),\n            activation(),\n            nn.Conv2d(mask_in_chans, embed_dim, kernel_size=1),\n        )\n        self.no_mask_embed = nn.Embedding(1, embed_dim)\n\n    def get_dense_pe(self) -> torch.Tensor:\n        \"\"\"\n        Returns the positional encoding used to encode point prompts,\n        applied to a dense set of points the shape of the image encoding.\n\n        Returns:\n          torch.Tensor: Positional encoding with shape\n            1x(embed_dim)x(embedding_h)x(embedding_w)\n        \"\"\"\n        return self.pe_layer(self.image_embedding_size).unsqueeze(0)\n\n    def _embed_points(\n        self,\n        points: torch.Tensor,\n        labels: torch.Tensor,\n        pad: bool,\n    ) -> torch.Tensor:\n        \"\"\"Embeds point prompts.\"\"\"\n        points = points + 0.5  # Shift to center of pixel\n        if pad:\n            padding_point = torch.zeros((points.shape[0], 1, 2), device=points.device)\n            padding_label = -torch.ones((labels.shape[0], 1), device=labels.device)\n            points = torch.cat([points, padding_point], dim=1)\n            labels = torch.cat([labels, padding_label], dim=1)\n        point_embedding = self.pe_layer.forward_with_coords(\n            points, self.input_image_size\n        )\n        point_embedding[labels == -1] = 0.0\n        point_embedding[labels == -1] += self.not_a_point_embed.weight\n        point_embedding[labels == 0] += self.point_embeddings[0].weight\n        point_embedding[labels == 1] += self.point_embeddings[1].weight\n        point_embedding[labels == 2] += self.point_embeddings[2].weight\n        point_embedding[labels == 3] += self.point_embeddings[3].weight\n        return point_embedding\n\n    def _embed_boxes(self, boxes: torch.Tensor) -> torch.Tensor:\n        \"\"\"Embeds box prompts.\"\"\"\n        boxes = boxes + 0.5  # Shift to center of pixel\n        coords = boxes.reshape(-1, 2, 2)\n        corner_embedding = self.pe_layer.forward_with_coords(\n            coords, self.input_image_size\n        )\n        corner_embedding[:, 0, :] += self.point_embeddings[2].weight\n        corner_embedding[:, 1, :] += self.point_embeddings[3].weight\n        return corner_embedding\n\n    def _embed_masks(self, masks: torch.Tensor) -> torch.Tensor:\n        \"\"\"Embeds mask inputs.\"\"\"\n        mask_embedding = self.mask_downscaling(masks)\n        return mask_embedding\n\n    def _get_batch_size(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n        text_embeds: Optional[torch.Tensor],\n    ) -> int:\n        \"\"\"\n        Gets the batch size of the output given the batch size of the input prompts.\n        \"\"\"\n        if points is not None:\n            return points[0].shape[0]\n        elif boxes is not None:\n            return boxes.shape[0]\n        elif masks is not None:\n            return masks.shape[0]\n        elif text_embeds is not None:\n            return text_embeds.shape[0]\n        else:\n            return 1\n\n    def _get_device(self) -> torch.device:\n        return self.point_embeddings[0].weight.device\n\n    def forward(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n        text_embeds: Optional[torch.Tensor],\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Embeds different types of prompts, returning both sparse and dense\n        embeddings.\n\n        Arguments:\n          points (tuple(torch.Tensor, torch.Tensor) or none): point coordinates\n            and labels to embed.\n          boxes (torch.Tensor or none): boxes to embed\n          masks (torch.Tensor or none): masks to embed\n\n        Returns:\n          torch.Tensor: sparse embeddings for the points and boxes, with shape\n            BxNx(embed_dim), where N is determined by the number of input points\n            and boxes.\n          torch.Tensor: dense embeddings for the masks, in the shape\n            Bx(embed_dim)x(embed_H)x(embed_W)\n        \"\"\"\n        bs = self._get_batch_size(points, boxes, masks, text_embeds)\n        sparse_embeddings = torch.empty(\n            (bs, 0, self.embed_dim), device=self._get_device()\n        )\n        if points is not None:\n            coords, labels = points\n            point_embeddings = self._embed_points(coords, labels, pad=(boxes is None))\n            sparse_embeddings = torch.cat([sparse_embeddings, point_embeddings], dim=1)\n        if boxes is not None:\n            box_embeddings = self._embed_boxes(boxes)\n            sparse_embeddings = torch.cat([sparse_embeddings, box_embeddings], dim=1)\n\n        if text_embeds is not None:\n            sparse_embeddings = torch.cat([sparse_embeddings, text_embeds], dim=1)\n\n        if masks is not None:\n            dense_embeddings = self._embed_masks(masks)\n        else:\n            dense_embeddings = self.no_mask_embed.weight.reshape(1, -1, 1, 1).expand(\n                bs, -1, self.image_embedding_size[0], self.image_embedding_size[1]\n            )\n\n        return sparse_embeddings, dense_embeddings\n\n\nclass PositionEmbeddingRandom(nn.Module):\n    \"\"\"\n    Positional encoding using random spatial frequencies.\n    \"\"\"\n\n    def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -> None:\n        super().__init__()\n        if scale is None or scale <= 0.0:\n            scale = 1.0\n        self.register_buffer(\n            \"positional_encoding_gaussian_matrix\",\n            scale * torch.randn((2, num_pos_feats)),\n        )\n\n    def _pe_encoding(self, coords: torch.Tensor) -> torch.Tensor:\n        \"\"\"Positionally encode points that are normalized to [0,1].\"\"\"\n        # assuming coords are in [0, 1]^2 square and have d_1 x ... x d_n x 2 shape\n        coords = 2 * coords - 1\n\n        if coords.dtype != self.positional_encoding_gaussian_matrix.dtype:\n            coords = coords.to(self.positional_encoding_gaussian_matrix.dtype)\n\n        coords = coords @ self.positional_encoding_gaussian_matrix\n        coords = 2 * np.pi * coords\n        # outputs d_1 x ... x d_n x C shape\n        return torch.cat([torch.sin(coords), torch.cos(coords)], dim=-1)\n\n    def forward(self, size: Tuple[int, int]) -> torch.Tensor:\n        \"\"\"Generate positional encoding for a grid of the specified size.\"\"\"\n        h, w = size\n        device: Any = self.positional_encoding_gaussian_matrix.device\n        grid = torch.ones(\n            (h, w), device=device, dtype=self.positional_encoding_gaussian_matrix.dtype\n        )\n        y_embed = grid.cumsum(dim=0) - 0.5\n        x_embed = grid.cumsum(dim=1) - 0.5\n        y_embed = y_embed / h\n        x_embed = x_embed / w\n\n        pe = self._pe_encoding(torch.stack([x_embed, y_embed], dim=-1))\n        return pe.permute(2, 0, 1)  # C x H x W\n\n    def forward_with_coords(\n        self, coords_input: torch.Tensor, image_size: Tuple[int, int]\n    ) -> torch.Tensor:\n        \"\"\"Positionally encode points that are not normalized to [0,1].\"\"\"\n        coords = coords_input.clone()\n        coords[:, :, 0] = coords[:, :, 0] / image_size[1]\n        coords[:, :, 1] = coords[:, :, 1] / image_size[0]\n        return self._pe_encoding(coords.to(torch.float))  # B x N x C\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/position_encoding.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom typing import Any, Optional, Tuple\n\nimport numpy as np\n\nimport torch\nfrom torch import nn\n\n\nclass PositionEmbeddingSine(nn.Module):\n    \"\"\"\n    This is a more standard version of the position embedding, very similar to the one\n    used by the Attention is all you need paper, generalized to work on images.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_pos_feats,\n        temperature: int = 10000,\n        normalize: bool = True,\n        scale: Optional[float] = None,\n    ):\n        super().__init__()\n        assert num_pos_feats % 2 == 0, \"Expecting even model width\"\n        self.num_pos_feats = num_pos_feats // 2\n        self.temperature = temperature\n        self.normalize = normalize\n        if scale is not None and normalize is False:\n            raise ValueError(\"normalize should be True if scale is passed\")\n        if scale is None:\n            scale = 2 * math.pi\n        self.scale = scale\n\n        self.cache = {}\n\n    def _encode_xy(self, x, y):\n        # The positions are expected to be normalized\n        assert len(x) == len(y) and x.ndim == y.ndim == 1\n        x_embed = x * self.scale\n        y_embed = y * self.scale\n\n        dim_t = torch.arange(self.num_pos_feats, dtype=torch.float32, device=x.device)\n        dim_t = self.temperature ** (2 * (dim_t // 2) / self.num_pos_feats)\n\n        pos_x = x_embed[:, None] / dim_t\n        pos_y = y_embed[:, None] / dim_t\n        pos_x = torch.stack(\n            (pos_x[:, 0::2].sin(), pos_x[:, 1::2].cos()), dim=2\n        ).flatten(1)\n        pos_y = torch.stack(\n            (pos_y[:, 0::2].sin(), pos_y[:, 1::2].cos()), dim=2\n        ).flatten(1)\n        return pos_x, pos_y\n\n    @torch.no_grad()\n    def encode_boxes(self, x, y, w, h):\n        pos_x, pos_y = self._encode_xy(x, y)\n        pos = torch.cat((pos_y, pos_x, h[:, None], w[:, None]), dim=1)\n        return pos\n\n    encode = encode_boxes  # Backwards compatibility\n\n    @torch.no_grad()\n    def encode_points(self, x, y, labels):\n        (bx, nx), (by, ny), (bl, nl) = x.shape, y.shape, labels.shape\n        assert bx == by and nx == ny and bx == bl and nx == nl\n        pos_x, pos_y = self._encode_xy(x.flatten(), y.flatten())\n        pos_x, pos_y = pos_x.reshape(bx, nx, -1), pos_y.reshape(by, ny, -1)\n        pos = torch.cat((pos_y, pos_x, labels[:, :, None]), dim=2)\n        return pos\n\n    @torch.no_grad()\n    def forward(self, x: torch.Tensor):\n        cache_key = (x.shape[-2], x.shape[-1])\n        if cache_key in self.cache:\n            return self.cache[cache_key][None].repeat(x.shape[0], 1, 1, 1)\n        y_embed = (\n            torch.arange(1, x.shape[-2] + 1, dtype=torch.float32, device=x.device)\n            .view(1, -1, 1)\n            .repeat(x.shape[0], 1, x.shape[-1])\n        )\n        x_embed = (\n            torch.arange(1, x.shape[-1] + 1, dtype=torch.float32, device=x.device)\n            .view(1, 1, -1)\n            .repeat(x.shape[0], x.shape[-2], 1)\n        )\n\n        if self.normalize:\n            eps = 1e-6\n            y_embed = y_embed / (y_embed[:, -1:, :] + eps) * self.scale\n            x_embed = x_embed / (x_embed[:, :, -1:] + eps) * self.scale\n\n        dim_t = torch.arange(self.num_pos_feats, dtype=torch.float32, device=x.device)\n        dim_t = self.temperature ** (2 * (dim_t // 2) / self.num_pos_feats)\n\n        pos_x = x_embed[:, :, :, None] / dim_t\n        pos_y = y_embed[:, :, :, None] / dim_t\n        pos_x = torch.stack(\n            (pos_x[:, :, :, 0::2].sin(), pos_x[:, :, :, 1::2].cos()), dim=4\n        ).flatten(3)\n        pos_y = torch.stack(\n            (pos_y[:, :, :, 0::2].sin(), pos_y[:, :, :, 1::2].cos()), dim=4\n        ).flatten(3)\n        pos = torch.cat((pos_y, pos_x), dim=3).permute(0, 3, 1, 2)\n        self.cache[cache_key] = pos[0]\n        return pos\n\n\nclass PositionEmbeddingRandom(nn.Module):\n    \"\"\"\n    Positional encoding using random spatial frequencies.\n    \"\"\"\n\n    def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -> None:\n        super().__init__()\n        if scale is None or scale <= 0.0:\n            scale = 1.0\n        self.register_buffer(\n            \"positional_encoding_gaussian_matrix\",\n            scale * torch.randn((2, num_pos_feats)),\n        )\n\n    def _pe_encoding(self, coords: torch.Tensor) -> torch.Tensor:\n        \"\"\"Positionally encode points that are normalized to [0,1].\"\"\"\n        # assuming coords are in [0, 1]^2 square and have d_1 x ... x d_n x 2 shape\n        coords = 2 * coords - 1\n        coords = coords @ self.positional_encoding_gaussian_matrix\n        coords = 2 * np.pi * coords\n        # outputs d_1 x ... x d_n x C shape\n        return torch.cat([torch.sin(coords), torch.cos(coords)], dim=-1)\n\n    def forward(self, size: Tuple[int, int]) -> torch.Tensor:\n        \"\"\"Generate positional encoding for a grid of the specified size.\"\"\"\n        h, w = size\n        device: Any = self.positional_encoding_gaussian_matrix.device\n        grid = torch.ones((h, w), device=device, dtype=torch.float32)\n        y_embed = grid.cumsum(dim=0) - 0.5\n        x_embed = grid.cumsum(dim=1) - 0.5\n        y_embed = y_embed / h\n        x_embed = x_embed / w\n\n        pe = self._pe_encoding(torch.stack([x_embed, y_embed], dim=-1))\n        return pe.permute(2, 0, 1)  # C x H x W\n\n    def forward_with_coords(\n        self, coords_input: torch.Tensor, image_size: Tuple[int, int]\n    ) -> torch.Tensor:\n        \"\"\"Positionally encode points that are not normalized to [0,1].\"\"\"\n        coords = coords_input.clone()\n        coords[:, :, 0] = coords[:, :, 0] / image_size[1]\n        coords[:, :, 1] = coords[:, :, 1] / image_size[0]\n        return self._pe_encoding(coords.to(torch.float))  # B x N x C\n\n\n# Rotary Positional Encoding, adapted from:\n# 1. https://github.com/meta-llama/codellama/blob/main/llama/model.py\n# 2. https://github.com/naver-ai/rope-vit\n# 3. https://github.com/lucidrains/rotary-embedding-torch\n\n\ndef init_t_xy(end_x: int, end_y: int):\n    t = torch.arange(end_x * end_y, dtype=torch.float32)\n    t_x = (t % end_x).float()\n    t_y = torch.div(t, end_x, rounding_mode=\"floor\").float()\n    return t_x, t_y\n\n\ndef compute_axial_cis(dim: int, end_x: int, end_y: int, theta: float = 10000.0):\n    freqs_x = 1.0 / (theta ** (torch.arange(0, dim, 4)[: (dim // 4)].float() / dim))\n    freqs_y = 1.0 / (theta ** (torch.arange(0, dim, 4)[: (dim // 4)].float() / dim))\n\n    t_x, t_y = init_t_xy(end_x, end_y)\n    freqs_x = torch.outer(t_x, freqs_x)\n    freqs_y = torch.outer(t_y, freqs_y)\n    freqs_cis_x = torch.polar(torch.ones_like(freqs_x), freqs_x)\n    freqs_cis_y = torch.polar(torch.ones_like(freqs_y), freqs_y)\n    return torch.cat([freqs_cis_x, freqs_cis_y], dim=-1)\n\n\ndef reshape_for_broadcast(freqs_cis: torch.Tensor, x: torch.Tensor):\n    ndim = x.ndim\n    assert 0 <= 1 < ndim\n    assert freqs_cis.shape == (x.shape[-2], x.shape[-1])\n    shape = [d if i >= ndim - 2 else 1 for i, d in enumerate(x.shape)]\n    return freqs_cis.view(*shape)\n\n\ndef apply_rotary_enc(\n    xq: torch.Tensor,\n    xk: torch.Tensor,\n    freqs_cis: torch.Tensor,\n    repeat_freqs_k: bool = False,\n):\n    xq_ = torch.view_as_complex(xq.float().reshape(*xq.shape[:-1], -1, 2))\n    xk_ = (\n        torch.view_as_complex(xk.float().reshape(*xk.shape[:-1], -1, 2))\n        if xk.shape[-2] != 0\n        else None\n    )\n    freqs_cis = reshape_for_broadcast(freqs_cis, xq_)\n    xq_out = torch.view_as_real(xq_ * freqs_cis).flatten(3)\n    if xk_ is None:\n        # no keys to rotate, due to dropout\n        return xq_out.type_as(xq).to(xq.device), xk\n    # repeat freqs along seq_len dim to match k seq_len\n    if repeat_freqs_k:\n        r = xk_.shape[-2] // xq_.shape[-2]\n        freqs_cis = freqs_cis.repeat(*([1] * (freqs_cis.ndim - 2)), r, 1)\n    xk_out = torch.view_as_real(xk_ * freqs_cis).flatten(3)\n    return xq_out.type_as(xq).to(xq.device), xk_out.type_as(xk).to(xk.device)\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/sam2_base.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\nimport torch.distributed\nimport torch.nn.functional as F\n\nfrom torch.nn.init import trunc_normal_\n\nfrom model.segment_anything_2.sam2.modeling.sam.mask_decoder import MaskDecoder\nfrom model.segment_anything_2.sam2.modeling.sam.prompt_encoder import PromptEncoder\nfrom model.segment_anything_2.sam2.modeling.sam.transformer import TwoWayTransformer\nfrom model.segment_anything_2.sam2.modeling.sam2_utils import get_1d_sine_pe, MLP, select_closest_cond_frames\n\n# a large negative value as a placeholder score for missing objects\nNO_OBJ_SCORE = -1024.0\n\n\nclass SAM2Base(torch.nn.Module):\n    def __init__(\n        self,\n        image_encoder,\n        memory_attention,\n        memory_encoder,\n        num_maskmem=7,  # default 1 input frame + 6 previous frames\n        image_size=512,\n        backbone_stride=16,  # stride of the image backbone output\n        sigmoid_scale_for_mem_enc=1.0,  # scale factor for mask sigmoid prob\n        sigmoid_bias_for_mem_enc=0.0,  # bias factor for mask sigmoid prob\n        # During evaluation, whether to binarize the sigmoid mask logits on interacted frames with clicks\n        binarize_mask_from_pts_for_mem_enc=False,\n        use_mask_input_as_output_without_sam=False,  # on frames with mask input, whether to directly output the input mask without using a SAM prompt encoder + mask decoder\n        # The maximum number of conditioning frames to participate in the memory attention (-1 means no limit; if there are more conditioning frames than this limit,\n        # we only cross-attend to the temporally closest `max_cond_frames_in_attn` conditioning frames in the encoder when tracking each frame). This gives the model\n        # a temporal locality when handling a large number of annotated frames (since closer frames should be more important) and also avoids GPU OOM.\n        max_cond_frames_in_attn=-1,\n        # on the first frame, whether to directly add the no-memory embedding to the image feature\n        # (instead of using the transformer encoder)\n        directly_add_no_mem_embed=False,\n        # whether to use high-resolution feature maps in the SAM mask decoder\n        use_high_res_features_in_sam=False,\n        # whether to output multiple (3) masks for the first click on initial conditioning frames\n        multimask_output_in_sam=False,\n        # the minimum and maximum number of clicks to use multimask_output_in_sam (only relevant when `multimask_output_in_sam=True`;\n        # default is 1 for both, meaning that only the first click gives multimask output; also note that a box counts as two points)\n        multimask_min_pt_num=1,\n        multimask_max_pt_num=1,\n        # whether to also use multimask output for tracking (not just for the first click on initial conditioning frames; only relevant when `multimask_output_in_sam=True`)\n        multimask_output_for_tracking=False,\n        # Whether to use multimask tokens for obj ptr; Only relevant when both\n        # use_obj_ptrs_in_encoder=True and multimask_output_for_tracking=True\n        use_multimask_token_for_obj_ptr: bool = False,\n        # whether to use sigmoid to restrict ious prediction to [0-1]\n        iou_prediction_use_sigmoid=False,\n        # The memory bank's temporal stride during evaluation (i.e. the `r` parameter in XMem and Cutie; XMem and Cutie use r=5).\n        # For r>1, the (self.num_maskmem - 1) non-conditioning memory frames consist of\n        # (self.num_maskmem - 2) nearest frames from every r-th frames, plus the last frame.\n        memory_temporal_stride_for_eval=1,\n        # if `add_all_frames_to_correct_as_cond` is True, we also append to the conditioning frame list any frame that receives a later correction click\n        # if `add_all_frames_to_correct_as_cond` is False, we conditioning frame list to only use those initial conditioning frames\n        add_all_frames_to_correct_as_cond=False,\n        # whether to apply non-overlapping constraints on the object masks in the memory encoder during evaluation (to avoid/alleviate superposing masks)\n        non_overlap_masks_for_mem_enc=False,\n        # whether to cross-attend to object pointers from other frames (based on SAM output tokens) in the encoder\n        use_obj_ptrs_in_encoder=False,\n        # the maximum number of object pointers from other frames in encoder cross attention (only relevant when `use_obj_ptrs_in_encoder=True`)\n        max_obj_ptrs_in_encoder=16,\n        # whether to add temporal positional encoding to the object pointers in the encoder (only relevant when `use_obj_ptrs_in_encoder=True`)\n        add_tpos_enc_to_obj_ptrs=True,\n        # whether to add an extra linear projection layer for the temporal positional encoding in the object pointers to avoid potential interference\n        # with spatial positional encoding (only relevant when both `use_obj_ptrs_in_encoder=True` and `add_tpos_enc_to_obj_ptrs=True`)\n        proj_tpos_enc_in_obj_ptrs=False,\n        # whether to only attend to object pointers in the past (before the current frame) in the encoder during evaluation\n        # (only relevant when `use_obj_ptrs_in_encoder=True`; this might avoid pointer information too far in the future to distract the initial tracking)\n        only_obj_ptrs_in_the_past_for_eval=False,\n        # Whether to predict if there is an object in the frame\n        pred_obj_scores: bool = False,\n        # Whether to use an MLP to predict object scores\n        pred_obj_scores_mlp: bool = False,\n        # Only relevant if pred_obj_scores=True and use_obj_ptrs_in_encoder=True;\n        # Whether to have a fixed no obj pointer when there is no object present\n        # or to use it as an additive embedding with obj_ptr produced by decoder\n        fixed_no_obj_ptr: bool = False,\n        # Soft no object, i.e. mix in no_obj_ptr softly,\n        # hope to make recovery easier if there is a mistake and mitigate accumulation of errors\n        soft_no_obj_ptr: bool = False,\n        use_mlp_for_obj_ptr_proj: bool = False,\n        # extra arguments used to construct the SAM mask decoder; if not None, it should be a dict of kwargs to be passed into `MaskDecoder` class.\n        sam_mask_decoder_extra_args=None,\n        compile_image_encoder: bool = False,\n    ):\n        super().__init__()\n\n        # Part 1: the image backbone\n        self.image_encoder = image_encoder\n        # Use level 0, 1, 2 for high-res setting, or just level 2 for the default setting\n        self.use_high_res_features_in_sam = use_high_res_features_in_sam\n        self.num_feature_levels = 3 if use_high_res_features_in_sam else 1\n        self.use_obj_ptrs_in_encoder = use_obj_ptrs_in_encoder\n        self.max_obj_ptrs_in_encoder = max_obj_ptrs_in_encoder\n        if use_obj_ptrs_in_encoder:\n            # A conv layer to downsample the mask prompt to stride 4 (the same stride as\n            # low-res SAM mask logits) and to change its scales from 0~1 to SAM logit scale,\n            # so that it can be fed into the SAM mask decoder to generate a pointer.\n            self.mask_downsample = torch.nn.Conv2d(1, 1, kernel_size=4, stride=4)\n        self.add_tpos_enc_to_obj_ptrs = add_tpos_enc_to_obj_ptrs\n        if proj_tpos_enc_in_obj_ptrs:\n            assert add_tpos_enc_to_obj_ptrs  # these options need to be used together\n        self.proj_tpos_enc_in_obj_ptrs = proj_tpos_enc_in_obj_ptrs\n        self.only_obj_ptrs_in_the_past_for_eval = only_obj_ptrs_in_the_past_for_eval\n\n        # Part 2: memory attention to condition current frame's visual features\n        # with memories (and obj ptrs) from past frames\n        self.memory_attention = memory_attention\n        self.hidden_dim = memory_attention.d_model\n\n        # Part 3: memory encoder for the previous frame's outputs\n        self.memory_encoder = memory_encoder\n        self.mem_dim = self.hidden_dim\n        if hasattr(self.memory_encoder, \"out_proj\") and hasattr(\n            self.memory_encoder.out_proj, \"weight\"\n        ):\n            # if there is compression of memories along channel dim\n            self.mem_dim = self.memory_encoder.out_proj.weight.shape[0]\n        self.num_maskmem = num_maskmem  # Number of memories accessible\n        # Temporal encoding of the memories\n        self.maskmem_tpos_enc = torch.nn.Parameter(\n            torch.zeros(num_maskmem, 1, 1, self.mem_dim)\n        )\n        trunc_normal_(self.maskmem_tpos_enc, std=0.02)\n        # a single token to indicate no memory embedding from previous frames\n        self.no_mem_embed = torch.nn.Parameter(torch.zeros(1, 1, self.hidden_dim))\n        self.no_mem_pos_enc = torch.nn.Parameter(torch.zeros(1, 1, self.hidden_dim))\n        trunc_normal_(self.no_mem_embed, std=0.02)\n        trunc_normal_(self.no_mem_pos_enc, std=0.02)\n        self.directly_add_no_mem_embed = directly_add_no_mem_embed\n        # Apply sigmoid to the output raw mask logits (to turn them from\n        # range (-inf, +inf) to range (0, 1)) before feeding them into the memory encoder\n        self.sigmoid_scale_for_mem_enc = sigmoid_scale_for_mem_enc\n        self.sigmoid_bias_for_mem_enc = sigmoid_bias_for_mem_enc\n        self.binarize_mask_from_pts_for_mem_enc = binarize_mask_from_pts_for_mem_enc\n        self.non_overlap_masks_for_mem_enc = non_overlap_masks_for_mem_enc\n        self.memory_temporal_stride_for_eval = memory_temporal_stride_for_eval\n        # On frames with mask input, whether to directly output the input mask without\n        # using a SAM prompt encoder + mask decoder\n        self.use_mask_input_as_output_without_sam = use_mask_input_as_output_without_sam\n        self.multimask_output_in_sam = multimask_output_in_sam\n        self.multimask_min_pt_num = multimask_min_pt_num\n        self.multimask_max_pt_num = multimask_max_pt_num\n        self.multimask_output_for_tracking = multimask_output_for_tracking\n        self.use_multimask_token_for_obj_ptr = use_multimask_token_for_obj_ptr\n        self.iou_prediction_use_sigmoid = iou_prediction_use_sigmoid\n\n        # Part 4: SAM-style prompt encoder (for both mask and point inputs)\n        # and SAM-style mask decoder for the final mask output\n        self.image_size = image_size\n        self.backbone_stride = backbone_stride\n        self.sam_mask_decoder_extra_args = sam_mask_decoder_extra_args\n        self.pred_obj_scores = pred_obj_scores\n        self.pred_obj_scores_mlp = pred_obj_scores_mlp\n        self.fixed_no_obj_ptr = fixed_no_obj_ptr\n        self.soft_no_obj_ptr = soft_no_obj_ptr\n        if self.fixed_no_obj_ptr:\n            assert self.pred_obj_scores\n            assert self.use_obj_ptrs_in_encoder\n        if self.pred_obj_scores and self.use_obj_ptrs_in_encoder:\n            self.no_obj_ptr = torch.nn.Parameter(torch.zeros(1, self.hidden_dim))\n            trunc_normal_(self.no_obj_ptr, std=0.02)\n        self.use_mlp_for_obj_ptr_proj = use_mlp_for_obj_ptr_proj\n\n        self._build_sam_heads()\n        self.add_all_frames_to_correct_as_cond = add_all_frames_to_correct_as_cond\n        self.max_cond_frames_in_attn = max_cond_frames_in_attn\n\n        # Model compilation\n        if compile_image_encoder:\n            # Compile the forward function (not the full module) to allow loading checkpoints.\n            print(\n                \"Image encoder compilation is enabled. First forward pass will be slow.\"\n            )\n            self.image_encoder.forward = torch.compile(\n                self.image_encoder.forward,\n                mode=\"max-autotune\",\n                fullgraph=True,\n                dynamic=False,\n            )\n\n    @property\n    def device(self):\n        return next(self.parameters()).device\n\n    def forward(self, *args, **kwargs):\n        raise NotImplementedError(\n            \"Please use the corresponding methods in SAM2VideoPredictor for inference.\"\n            \"See notebooks/video_predictor_example.ipynb for an example.\"\n        )\n\n    def _build_sam_heads(self):\n        \"\"\"Build SAM-style prompt encoder and mask decoder.\"\"\"\n        self.sam_prompt_embed_dim = self.hidden_dim\n        self.sam_image_embedding_size = self.image_size // self.backbone_stride\n\n        # build PromptEncoder and MaskDecoder from SAM\n        # (their hyperparameters like `mask_in_chans=16` are from SAM code)\n        self.sam_prompt_encoder = PromptEncoder(\n            embed_dim=self.sam_prompt_embed_dim,\n            image_embedding_size=(\n                self.sam_image_embedding_size,\n                self.sam_image_embedding_size,\n            ),\n            input_image_size=(self.image_size, self.image_size),\n            mask_in_chans=16,\n        )\n        self.sam_mask_decoder = MaskDecoder(\n            num_multimask_outputs=3,\n            transformer=TwoWayTransformer(\n                depth=2,\n                embedding_dim=self.sam_prompt_embed_dim,\n                mlp_dim=2048,\n                num_heads=8,\n            ),\n            transformer_dim=self.sam_prompt_embed_dim,\n            iou_head_depth=3,\n            iou_head_hidden_dim=256,\n            use_high_res_features=self.use_high_res_features_in_sam,\n            iou_prediction_use_sigmoid=self.iou_prediction_use_sigmoid,\n            pred_obj_scores=self.pred_obj_scores,\n            pred_obj_scores_mlp=self.pred_obj_scores_mlp,\n            use_multimask_token_for_obj_ptr=self.use_multimask_token_for_obj_ptr,\n            **(self.sam_mask_decoder_extra_args or {}),\n        )\n        if self.use_obj_ptrs_in_encoder:\n            # a linear projection on SAM output tokens to turn them into object pointers\n            self.obj_ptr_proj = torch.nn.Linear(self.hidden_dim, self.hidden_dim)\n            if self.use_mlp_for_obj_ptr_proj:\n                self.obj_ptr_proj = MLP(\n                    self.hidden_dim, self.hidden_dim, self.hidden_dim, 3\n                )\n        else:\n            self.obj_ptr_proj = torch.nn.Identity()\n        if self.proj_tpos_enc_in_obj_ptrs:\n            # a linear projection on temporal positional encoding in object pointers to\n            # avoid potential interference with spatial positional encoding\n            self.obj_ptr_tpos_proj = torch.nn.Linear(self.hidden_dim, self.mem_dim)\n        else:\n            self.obj_ptr_tpos_proj = torch.nn.Identity()\n\n    def _forward_sam_heads(\n        self,\n        backbone_features,\n        point_inputs=None,\n        mask_inputs=None,\n        text_inputs=None,\n        high_res_features=None,\n        multimask_output=False,\n    ):\n        \"\"\"\n        Forward SAM prompt encoders and mask heads.\n\n        Inputs:\n        - backbone_features: image features of [B, C, H, W] shape\n        - point_inputs: a dictionary with \"point_coords\" and \"point_labels\", where\n          1) \"point_coords\" has [B, P, 2] shape and float32 dtype and contains the\n             absolute pixel-unit coordinate in (x, y) format of the P input points\n          2) \"point_labels\" has shape [B, P] and int32 dtype, where 1 means\n             positive clicks, 0 means negative clicks, and -1 means padding\n        - mask_inputs: a mask of [B, 1, H*16, W*16] shape, float or bool, with the\n          same spatial size as the image.\n        - high_res_features: either 1) None or 2) or a list of length 2 containing\n          two feature maps of [B, C, 4*H, 4*W] and [B, C, 2*H, 2*W] shapes respectively,\n          which will be used as high-resolution feature maps for SAM decoder.\n        - multimask_output: if it's True, we output 3 candidate masks and their 3\n          corresponding IoU estimates, and if it's False, we output only 1 mask and\n          its corresponding IoU estimate.\n\n        Outputs:\n        - low_res_multimasks: [B, M, H*4, W*4] shape (where M = 3 if\n          `multimask_output=True` and M = 1 if `multimask_output=False`), the SAM\n          output mask logits (before sigmoid) for the low-resolution masks, with 4x\n          the resolution (1/4 stride) of the input backbone_features.\n        - high_res_multimasks: [B, M, H*16, W*16] shape (where M = 3\n          if `multimask_output=True` and M = 1 if `multimask_output=False`),\n          upsampled from the low-resolution masks, with shape size as the image\n          (stride is 1 pixel).\n        - ious, [B, M] shape, where (where M = 3 if `multimask_output=True` and M = 1\n          if `multimask_output=False`), the estimated IoU of each output mask.\n        - low_res_masks: [B, 1, H*4, W*4] shape, the best mask in `low_res_multimasks`.\n          If `multimask_output=True`, it's the mask with the highest IoU estimate.\n          If `multimask_output=False`, it's the same as `low_res_multimasks`.\n        - high_res_masks: [B, 1, H*16, W*16] shape, the best mask in `high_res_multimasks`.\n          If `multimask_output=True`, it's the mask with the highest IoU estimate.\n          If `multimask_output=False`, it's the same as `high_res_multimasks`.\n        - obj_ptr: [B, C] shape, the object pointer vector for the output mask, extracted\n          based on the output token from the SAM mask decoder.\n        \"\"\"\n        B = backbone_features.size(0)\n        device = backbone_features.device\n        assert backbone_features.size(1) == self.sam_prompt_embed_dim\n        assert backbone_features.size(2) == self.sam_image_embedding_size\n        assert backbone_features.size(3) == self.sam_image_embedding_size\n\n        # a) Handle point prompts\n        if point_inputs is not None:\n            sam_point_coords = point_inputs[\"point_coords\"]\n            sam_point_labels = point_inputs[\"point_labels\"]\n            assert sam_point_coords.size(0) == B and sam_point_labels.size(0) == B\n        else:\n            # If no points are provide, pad with an empty point (with label -1)\n            sam_point_coords = torch.zeros(B, 1, 2, device=device)\n            sam_point_labels = -torch.ones(B, 1, dtype=torch.int32, device=device)\n        sam_point_prompt = (sam_point_coords, sam_point_labels)\n        # added by YxZhang to forbid contemporary using text prompt and point prompt\n        if text_inputs is not None:\n            sam_point_prompt = None\n\n        # b) Handle mask prompts\n        if mask_inputs is not None:\n            # If mask_inputs is provided, downsize it into low-res mask input if needed\n            # and feed it as a dense mask prompt into the SAM mask encoder\n            assert len(mask_inputs.shape) == 4 and mask_inputs.shape[:2] == (B, 1)\n            if mask_inputs.shape[-2:] != self.sam_prompt_encoder.mask_input_size:\n                sam_mask_prompt = F.interpolate(\n                    mask_inputs.float(),\n                    size=self.sam_prompt_encoder.mask_input_size,\n                    align_corners=False,\n                    mode=\"bilinear\",\n                    antialias=True,  # use antialias for downsampling\n                )\n            else:\n                sam_mask_prompt = mask_inputs\n        else:\n            # Otherwise, simply feed None (and SAM's prompt encoder will add\n            # a learned `no_mask_embed` to indicate no mask input in this case).\n            sam_mask_prompt = None\n\n        sparse_embeddings, dense_embeddings = self.sam_prompt_encoder(\n            points=sam_point_prompt,\n            boxes=None,\n            masks=sam_mask_prompt,\n            text_embeds=text_inputs\n        )\n        (\n            low_res_multimasks,\n            ious,\n            sam_output_tokens,\n            object_score_logits,\n        ) = self.sam_mask_decoder(\n            image_embeddings=backbone_features,\n            image_pe=self.sam_prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            dense_prompt_embeddings=dense_embeddings,\n            multimask_output=multimask_output,\n            repeat_image=False,  # the image is already batched\n            high_res_features=high_res_features,\n        )\n        if self.pred_obj_scores:\n            is_obj_appearing = object_score_logits > 0\n\n            # Mask used for spatial memories is always a *hard* choice between obj and no obj,\n            # consistent with the actual mask prediction\n            low_res_multimasks = torch.where(\n                is_obj_appearing[:, None, None],\n                low_res_multimasks,\n                NO_OBJ_SCORE,\n            )\n\n        # convert masks from possibly bfloat16 (or float16) to float32\n        # (older PyTorch versions before 2.1 don't support `interpolate` on bf16)\n        low_res_multimasks = low_res_multimasks.float()\n        high_res_multimasks = F.interpolate(\n            low_res_multimasks,\n            size=(self.image_size, self.image_size),\n            mode=\"bilinear\",\n            align_corners=False,\n        )\n\n        sam_output_token = sam_output_tokens[:, 0]\n        if multimask_output:\n            # take the best mask prediction (with the highest IoU estimation)\n            best_iou_inds = torch.argmax(ious, dim=-1)\n            batch_inds = torch.arange(B, device=device)\n            low_res_masks = low_res_multimasks[batch_inds, best_iou_inds].unsqueeze(1)\n            high_res_masks = high_res_multimasks[batch_inds, best_iou_inds].unsqueeze(1)\n            if sam_output_tokens.size(1) > 1:\n                sam_output_token = sam_output_tokens[batch_inds, best_iou_inds]\n        else:\n            low_res_masks, high_res_masks = low_res_multimasks, high_res_multimasks\n\n        # Extract object pointer from the SAM output token (with occlusion handling)\n        obj_ptr = self.obj_ptr_proj(sam_output_token)\n        if self.pred_obj_scores:\n            # Allow *soft* no obj ptr, unlike for masks\n            if self.soft_no_obj_ptr:\n                # Only hard possible with gt\n                assert not self.teacher_force_obj_scores_for_mem\n                lambda_is_obj_appearing = object_score_logits.sigmoid()\n            else:\n                lambda_is_obj_appearing = is_obj_appearing.float()\n\n            if self.fixed_no_obj_ptr:\n                obj_ptr = lambda_is_obj_appearing * obj_ptr\n            obj_ptr = obj_ptr + (1 - lambda_is_obj_appearing) * self.no_obj_ptr\n\n        return (\n            low_res_multimasks,\n            high_res_multimasks,\n            ious,\n            low_res_masks,\n            high_res_masks,\n            obj_ptr,\n            object_score_logits,\n        )\n\n    def _use_mask_as_output(self, backbone_features, high_res_features, mask_inputs):\n        \"\"\"\n        Directly turn binary `mask_inputs` into a output mask logits without using SAM.\n        (same input and output shapes as in _forward_sam_heads above).\n        \"\"\"\n        # Use -10/+10 as logits for neg/pos pixels (very close to 0/1 in prob after sigmoid).\n        out_scale, out_bias = 20.0, -10.0  # sigmoid(-10.0)=4.5398e-05\n        mask_inputs_float = mask_inputs.float()\n        high_res_masks = mask_inputs_float * out_scale + out_bias\n        low_res_masks = F.interpolate(\n            high_res_masks,\n            size=(high_res_masks.size(-2) // 4, high_res_masks.size(-1) // 4),\n            align_corners=False,\n            mode=\"bilinear\",\n            antialias=True,  # use antialias for downsampling\n        )\n        # a dummy IoU prediction of all 1's under mask input\n        ious = mask_inputs.new_ones(mask_inputs.size(0), 1).float()\n        if not self.use_obj_ptrs_in_encoder:\n            # all zeros as a dummy object pointer (of shape [B, C])\n            obj_ptr = torch.zeros(\n                mask_inputs.size(0), self.hidden_dim, device=mask_inputs.device\n            )\n        else:\n            # produce an object pointer using the SAM decoder from the mask input\n            _, _, _, _, _, obj_ptr, _ = self._forward_sam_heads(\n                backbone_features=backbone_features,\n                mask_inputs=self.mask_downsample(mask_inputs_float),\n                high_res_features=high_res_features,\n            )\n        # In this method, we are treating mask_input as output, e.g. using it directly to create spatial mem;\n        # Below, we follow the same design axiom to use mask_input to decide if obj appears or not instead of relying\n        # on the object_scores from the SAM decoder.\n        is_obj_appearing = torch.any(mask_inputs.flatten(1).float() > 0.0, dim=1)\n        is_obj_appearing = is_obj_appearing[..., None]\n        lambda_is_obj_appearing = is_obj_appearing.float()\n        object_score_logits = out_scale * lambda_is_obj_appearing + out_bias\n        if self.pred_obj_scores:\n            if self.fixed_no_obj_ptr:\n                obj_ptr = lambda_is_obj_appearing * obj_ptr\n            obj_ptr = obj_ptr + (1 - lambda_is_obj_appearing) * self.no_obj_ptr\n\n        return (\n            low_res_masks,\n            high_res_masks,\n            ious,\n            low_res_masks,\n            high_res_masks,\n            obj_ptr,\n            object_score_logits,\n        )\n\n    def forward_image(self, img_batch: torch.Tensor):\n        \"\"\"Get the image feature on the input batch.\"\"\"\n        backbone_out = self.image_encoder(img_batch)\n        if self.use_high_res_features_in_sam:\n            # precompute projected level 0 and level 1 features in SAM decoder\n            # to avoid running it again on every SAM click\n            backbone_out[\"backbone_fpn\"][0] = self.sam_mask_decoder.conv_s0(\n                backbone_out[\"backbone_fpn\"][0]\n            )\n            backbone_out[\"backbone_fpn\"][1] = self.sam_mask_decoder.conv_s1(\n                backbone_out[\"backbone_fpn\"][1]\n            )\n        return backbone_out\n\n    def _prepare_backbone_features(self, backbone_out):\n        \"\"\"Prepare and flatten visual features.\"\"\"\n        backbone_out = backbone_out.copy()\n        assert len(backbone_out[\"backbone_fpn\"]) == len(backbone_out[\"vision_pos_enc\"])\n        assert len(backbone_out[\"backbone_fpn\"]) >= self.num_feature_levels\n\n        feature_maps = backbone_out[\"backbone_fpn\"][-self.num_feature_levels :]\n        vision_pos_embeds = backbone_out[\"vision_pos_enc\"][-self.num_feature_levels :]\n\n        feat_sizes = [(x.shape[-2], x.shape[-1]) for x in vision_pos_embeds]\n        # flatten NxCxHxW to HWxNxC\n        vision_feats = [x.flatten(2).permute(2, 0, 1) for x in feature_maps]\n        vision_pos_embeds = [x.flatten(2).permute(2, 0, 1) for x in vision_pos_embeds]\n\n        return backbone_out, vision_feats, vision_pos_embeds, feat_sizes\n\n    def _prepare_memory_conditioned_features(\n        self,\n        frame_idx,\n        is_init_cond_frame,\n        current_vision_feats,\n        current_vision_pos_embeds,\n        feat_sizes,\n        output_dict,\n        num_frames,\n        track_in_reverse=False,  # tracking in reverse time order (for demo usage)\n    ):\n        \"\"\"Fuse the current frame's visual feature map with previous memory.\"\"\"\n        B = current_vision_feats[-1].size(1)  # batch size on this frame\n        C = self.hidden_dim\n        H, W = feat_sizes[-1]  # top-level (lowest-resolution) feature size\n        device = current_vision_feats[-1].device\n        # The case of `self.num_maskmem == 0` below is primarily used for reproducing SAM on images.\n        # In this case, we skip the fusion with any memory.\n        if self.num_maskmem == 0:  # Disable memory and skip fusion\n            pix_feat = current_vision_feats[-1].permute(1, 2, 0).view(B, C, H, W)\n            return pix_feat\n\n        num_obj_ptr_tokens = 0\n        # Step 1: condition the visual features of the current frame on previous memories\n        if not is_init_cond_frame:\n            # Retrieve the memories encoded with the maskmem backbone\n            to_cat_memory, to_cat_memory_pos_embed = [], []\n            # Add conditioning frames's output first (all cond frames have t_pos=0 for\n            # when getting temporal positional embedding below)\n            assert len(output_dict[\"cond_frame_outputs\"]) > 0\n            # Select a maximum number of temporally closest cond frames for cross attention\n            cond_outputs = output_dict[\"cond_frame_outputs\"]\n            selected_cond_outputs, unselected_cond_outputs = select_closest_cond_frames(\n                frame_idx, cond_outputs, self.max_cond_frames_in_attn\n            )\n            t_pos_and_prevs = [(0, out) for out in selected_cond_outputs.values()]\n            # Add last (self.num_maskmem - 1) frames before current frame for non-conditioning memory\n            # the earliest one has t_pos=1 and the latest one has t_pos=self.num_maskmem-1\n            # We also allow taking the memory frame non-consecutively (with r>1), in which case\n            # we take (self.num_maskmem - 2) frames among every r-th frames plus the last frame.\n            r = self.memory_temporal_stride_for_eval\n            for t_pos in range(1, self.num_maskmem):\n                t_rel = self.num_maskmem - t_pos  # how many frames before current frame\n                if t_rel == 1:\n                    # for t_rel == 1, we take the last frame (regardless of r)\n                    if not track_in_reverse:\n                        # the frame immediately before this frame (i.e. frame_idx - 1)\n                        prev_frame_idx = frame_idx - t_rel\n                    else:\n                        # the frame immediately after this frame (i.e. frame_idx + 1)\n                        prev_frame_idx = frame_idx + t_rel\n                else:\n                    # for t_rel >= 2, we take the memory frame from every r-th frames\n                    if not track_in_reverse:\n                        # first find the nearest frame among every r-th frames before this frame\n                        # for r=1, this would be (frame_idx - 2)\n                        prev_frame_idx = ((frame_idx - 2) // r) * r\n                        # then seek further among every r-th frames\n                        prev_frame_idx = prev_frame_idx - (t_rel - 2) * r\n                    else:\n                        # first find the nearest frame among every r-th frames after this frame\n                        # for r=1, this would be (frame_idx + 2)\n                        prev_frame_idx = -(-(frame_idx + 2) // r) * r\n                        # then seek further among every r-th frames\n                        prev_frame_idx = prev_frame_idx + (t_rel - 2) * r\n                out = output_dict[\"non_cond_frame_outputs\"].get(prev_frame_idx, None)\n                if out is None:\n                    # If an unselected conditioning frame is among the last (self.num_maskmem - 1)\n                    # frames, we still attend to it as if it's a non-conditioning frame.\n                    out = unselected_cond_outputs.get(prev_frame_idx, None)\n                t_pos_and_prevs.append((t_pos, out))\n\n            for t_pos, prev in t_pos_and_prevs:\n                if prev is None:\n                    continue  # skip padding frames\n                # \"maskmem_features\" might have been offloaded to CPU in demo use cases,\n                # so we load it back to GPU (it's a no-op if it's already on GPU).\n                feats = prev[\"maskmem_features\"].cuda(non_blocking=True)\n                to_cat_memory.append(feats.flatten(2).permute(2, 0, 1))\n                # Spatial positional encoding (it might have been offloaded to CPU in eval)\n                maskmem_enc = prev[\"maskmem_pos_enc\"][-1].cuda()\n                maskmem_enc = maskmem_enc.flatten(2).permute(2, 0, 1)\n                # Temporal positional encoding\n                maskmem_enc = (\n                    maskmem_enc + self.maskmem_tpos_enc[self.num_maskmem - t_pos - 1]\n                )\n                to_cat_memory_pos_embed.append(maskmem_enc)\n\n            # Construct the list of past object pointers\n            if self.use_obj_ptrs_in_encoder:\n                max_obj_ptrs_in_encoder = min(num_frames, self.max_obj_ptrs_in_encoder)\n                # First add those object pointers from selected conditioning frames\n                # (optionally, only include object pointers in the past during evaluation)\n                if not self.training and self.only_obj_ptrs_in_the_past_for_eval:\n                    ptr_cond_outputs = {\n                        t: out\n                        for t, out in selected_cond_outputs.items()\n                        if (t >= frame_idx if track_in_reverse else t <= frame_idx)\n                    }\n                else:\n                    ptr_cond_outputs = selected_cond_outputs\n                pos_and_ptrs = [\n                    # Temporal pos encoding contains how far away each pointer is from current frame\n                    (abs(frame_idx - t), out[\"obj_ptr\"])\n                    for t, out in ptr_cond_outputs.items()\n                ]\n                # Add up to (max_obj_ptrs_in_encoder - 1) non-conditioning frames before current frame\n                for t_diff in range(1, max_obj_ptrs_in_encoder):\n                    t = frame_idx + t_diff if track_in_reverse else frame_idx - t_diff\n                    if t < 0 or (num_frames is not None and t >= num_frames):\n                        break\n                    out = output_dict[\"non_cond_frame_outputs\"].get(\n                        t, unselected_cond_outputs.get(t, None)\n                    )\n                    if out is not None:\n                        pos_and_ptrs.append((t_diff, out[\"obj_ptr\"]))\n                # If we have at least one object pointer, add them to the across attention\n                if len(pos_and_ptrs) > 0:\n                    pos_list, ptrs_list = zip(*pos_and_ptrs)\n                    # stack object pointers along dim=0 into [ptr_seq_len, B, C] shape\n                    obj_ptrs = torch.stack(ptrs_list, dim=0)\n                    # a temporal positional embedding based on how far each object pointer is from\n                    # the current frame (sine embedding normalized by the max pointer num).\n                    if self.add_tpos_enc_to_obj_ptrs:\n                        t_diff_max = max_obj_ptrs_in_encoder - 1\n                        tpos_dim = C if self.proj_tpos_enc_in_obj_ptrs else self.mem_dim\n                        obj_pos = torch.tensor(pos_list, device=device)\n                        obj_pos = get_1d_sine_pe(obj_pos / t_diff_max, dim=tpos_dim)\n                        obj_pos = self.obj_ptr_tpos_proj(obj_pos)\n                        obj_pos = obj_pos.unsqueeze(1).expand(-1, B, self.mem_dim)\n                    else:\n                        obj_pos = obj_ptrs.new_zeros(len(pos_list), B, self.mem_dim)\n                    if self.mem_dim < C:\n                        # split a pointer into (C // self.mem_dim) tokens for self.mem_dim < C\n                        obj_ptrs = obj_ptrs.reshape(\n                            -1, B, C // self.mem_dim, self.mem_dim\n                        )\n                        obj_ptrs = obj_ptrs.permute(0, 2, 1, 3).flatten(0, 1)\n                        obj_pos = obj_pos.repeat_interleave(C // self.mem_dim, dim=0)\n                    to_cat_memory.append(obj_ptrs)\n                    to_cat_memory_pos_embed.append(obj_pos)\n                    num_obj_ptr_tokens = obj_ptrs.shape[0]\n                else:\n                    num_obj_ptr_tokens = 0\n        else:\n            # for initial conditioning frames, encode them without using any previous memory\n            if self.directly_add_no_mem_embed:\n                # directly add no-mem embedding (instead of using the transformer encoder)\n                pix_feat_with_mem = current_vision_feats[-1] + self.no_mem_embed\n                pix_feat_with_mem = pix_feat_with_mem.permute(1, 2, 0).view(B, C, H, W)\n                return pix_feat_with_mem\n\n            # Use a dummy token on the first frame (to avoid emtpy memory input to tranformer encoder)\n            to_cat_memory = [self.no_mem_embed.expand(1, B, self.mem_dim)]\n            to_cat_memory_pos_embed = [self.no_mem_pos_enc.expand(1, B, self.mem_dim)]\n\n        # Step 2: Concatenate the memories and forward through the transformer encoder\n        memory = torch.cat(to_cat_memory, dim=0)\n        memory_pos_embed = torch.cat(to_cat_memory_pos_embed, dim=0)\n\n        pix_feat_with_mem = self.memory_attention(\n            curr=current_vision_feats,\n            curr_pos=current_vision_pos_embeds,\n            memory=memory,\n            memory_pos=memory_pos_embed,\n            num_obj_ptr_tokens=num_obj_ptr_tokens,\n        )\n        # reshape the output (HW)BC => BCHW\n        pix_feat_with_mem = pix_feat_with_mem.permute(1, 2, 0).view(B, C, H, W)\n        return pix_feat_with_mem\n\n    def _encode_new_memory(\n        self,\n        current_vision_feats,\n        feat_sizes,\n        pred_masks_high_res,\n        is_mask_from_pts,\n    ):\n        \"\"\"Encode the current image and its prediction into a memory feature.\"\"\"\n        B = current_vision_feats[-1].size(1)  # batch size on this frame\n        C = self.hidden_dim\n        H, W = feat_sizes[-1]  # top-level (lowest-resolution) feature size\n        # top-level feature, (HW)BC => BCHW\n        pix_feat = current_vision_feats[-1].permute(1, 2, 0).view(B, C, H, W)\n        if self.non_overlap_masks_for_mem_enc and not self.training:\n            # optionally, apply non-overlapping constraints to the masks (it's applied\n            # in the batch dimension and should only be used during eval, where all\n            # the objects come from the same video under batch size 1).\n            pred_masks_high_res = self._apply_non_overlapping_constraints(\n                pred_masks_high_res\n            )\n        # scale the raw mask logits with a temperature before applying sigmoid\n        binarize = self.binarize_mask_from_pts_for_mem_enc and is_mask_from_pts\n        if binarize and not self.training:\n            mask_for_mem = (pred_masks_high_res > 0).float()\n        else:\n            # apply sigmoid on the raw mask logits to turn them into range (0, 1)\n            mask_for_mem = torch.sigmoid(pred_masks_high_res)\n        # apply scale and bias terms to the sigmoid probabilities\n        if self.sigmoid_scale_for_mem_enc != 1.0:\n            mask_for_mem = mask_for_mem * self.sigmoid_scale_for_mem_enc\n        if self.sigmoid_bias_for_mem_enc != 0.0:\n            mask_for_mem = mask_for_mem + self.sigmoid_bias_for_mem_enc\n        maskmem_out = self.memory_encoder(\n            pix_feat, mask_for_mem, skip_mask_sigmoid=True  # sigmoid already applied\n        )\n        maskmem_features = maskmem_out[\"vision_features\"]\n        maskmem_pos_enc = maskmem_out[\"vision_pos_enc\"]\n\n        return maskmem_features, maskmem_pos_enc\n\n    def track_step(\n        self,\n        frame_idx,\n        is_init_cond_frame,\n        current_vision_feats,\n        current_vision_pos_embeds,\n        feat_sizes,\n        point_inputs,\n        mask_inputs,\n        output_dict,\n        num_frames,\n        track_in_reverse=False,  # tracking in reverse time order (for demo usage)\n        # Whether to run the memory encoder on the predicted masks. Sometimes we might want\n        # to skip the memory encoder with `run_mem_encoder=False`. For example,\n        # in demo we might call `track_step` multiple times for each user click,\n        # and only encode the memory when the user finalizes their clicks. And in ablation\n        # settings like SAM training on static images, we don't need the memory encoder.\n        run_mem_encoder=True,\n        # The previously predicted SAM mask logits (which can be fed together with new clicks in demo).\n        prev_sam_mask_logits=None,\n        text_inputs=None,\n    ):\n        current_out = {\"point_inputs\": point_inputs, \"mask_inputs\": mask_inputs}\n        # High-resolution feature maps for the SAM head, reshape (HW)BC => BCHW\n        if len(current_vision_feats) > 1:\n            high_res_features = [\n                x.permute(1, 2, 0).view(x.size(1), x.size(2), *s)\n                for x, s in zip(current_vision_feats[:-1], feat_sizes[:-1])\n            ]\n        else:\n            high_res_features = None\n        if mask_inputs is not None and self.use_mask_input_as_output_without_sam:\n            # When use_mask_input_as_output_without_sam=True, we directly output the mask input\n            # (see it as a GT mask) without using a SAM prompt encoder + mask decoder.\n            pix_feat = current_vision_feats[-1].permute(1, 2, 0)\n            pix_feat = pix_feat.view(-1, self.hidden_dim, *feat_sizes[-1])\n            sam_outputs = self._use_mask_as_output(\n                pix_feat, high_res_features, mask_inputs\n            )\n        else:\n            # fused the visual feature with previous memory features in the memory bank\n            pix_feat_with_mem = self._prepare_memory_conditioned_features(\n                frame_idx=frame_idx,\n                is_init_cond_frame=is_init_cond_frame,\n                current_vision_feats=current_vision_feats[-1:],\n                current_vision_pos_embeds=current_vision_pos_embeds[-1:],\n                feat_sizes=feat_sizes[-1:],\n                output_dict=output_dict,\n                num_frames=num_frames,\n                track_in_reverse=track_in_reverse,\n            )\n            # apply SAM-style segmentation head\n            # here we might feed previously predicted low-res SAM mask logits into the SAM mask decoder,\n            # e.g. in demo where such logits come from earlier interaction instead of correction sampling\n            # (in this case, any `mask_inputs` shouldn't reach here as they are sent to _use_mask_as_output instead)\n            if prev_sam_mask_logits is not None:\n                assert point_inputs is not None and mask_inputs is None\n                mask_inputs = prev_sam_mask_logits\n            multimask_output = self._use_multimask(is_init_cond_frame, point_inputs)\n            sam_outputs = self._forward_sam_heads(\n                backbone_features=pix_feat_with_mem,\n                point_inputs=point_inputs,\n                mask_inputs=mask_inputs,\n                high_res_features=high_res_features,\n                multimask_output=multimask_output,\n                text_inputs=text_inputs\n            )\n        (\n            _,\n            _,\n            _,\n            low_res_masks,\n            high_res_masks,\n            obj_ptr,\n            _,\n        ) = sam_outputs\n\n        current_out[\"pred_masks\"] = low_res_masks\n        current_out[\"pred_masks_high_res\"] = high_res_masks\n        current_out[\"obj_ptr\"] = obj_ptr\n\n        # Finally run the memory encoder on the predicted mask to encode\n        # it into a new memory feature (that can be used in future frames)\n        if run_mem_encoder and self.num_maskmem > 0:\n            high_res_masks_for_mem_enc = high_res_masks\n            maskmem_features, maskmem_pos_enc = self._encode_new_memory(\n                current_vision_feats=current_vision_feats,\n                feat_sizes=feat_sizes,\n                pred_masks_high_res=high_res_masks_for_mem_enc,\n                is_mask_from_pts=(point_inputs is not None),\n            )\n            current_out[\"maskmem_features\"] = maskmem_features\n            current_out[\"maskmem_pos_enc\"] = maskmem_pos_enc\n        else:\n            current_out[\"maskmem_features\"] = None\n            current_out[\"maskmem_pos_enc\"] = None\n\n        return current_out\n\n    def _use_multimask(self, is_init_cond_frame, point_inputs):\n        \"\"\"Whether to use multimask output in the SAM head.\"\"\"\n        num_pts = 0 if point_inputs is None else point_inputs[\"point_labels\"].size(1)\n        multimask_output = (\n            self.multimask_output_in_sam\n            and (is_init_cond_frame or self.multimask_output_for_tracking)\n            and (self.multimask_min_pt_num <= num_pts <= self.multimask_max_pt_num)\n        )\n        return multimask_output\n\n    def _apply_non_overlapping_constraints(self, pred_masks):\n        \"\"\"\n        Apply non-overlapping constraints to the object scores in pred_masks. Here we\n        keep only the highest scoring object at each spatial location in pred_masks.\n        \"\"\"\n        batch_size = pred_masks.size(0)\n        if batch_size == 1:\n            return pred_masks\n\n        device = pred_masks.device\n        # \"max_obj_inds\": object index of the object with the highest score at each location\n        max_obj_inds = torch.argmax(pred_masks, dim=0, keepdim=True)\n        # \"batch_obj_inds\": object index of each object slice (along dim 0) in `pred_masks`\n        batch_obj_inds = torch.arange(batch_size, device=device)[:, None, None, None]\n        keep = max_obj_inds == batch_obj_inds\n        # suppress overlapping regions' scores below -10.0 so that the foreground regions\n        # don't overlap (here sigmoid(-10.0)=4.5398e-05)\n        pred_masks = torch.where(keep, pred_masks, torch.clamp(pred_masks, max=-10.0))\n        return pred_masks\n"}
{"type": "source_file", "path": "model/segment_anything_2/sam2/modeling/backbones/image_encoder.py", "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import List, Optional\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass ImageEncoder(nn.Module):\n    def __init__(\n        self,\n        trunk: nn.Module,\n        neck: nn.Module,\n        scalp: int = 0,\n    ):\n        super().__init__()\n        self.trunk = trunk\n        self.neck = neck\n        self.scalp = scalp\n        assert (\n            self.trunk.channel_list == self.neck.backbone_channel_list\n        ), f\"Channel dims of trunk and neck do not match. Trunk: {self.trunk.channel_list}, neck: {self.neck.backbone_channel_list}\"\n\n    def forward(self, sample: torch.Tensor):\n        # Forward through backbone\n        features, pos = self.neck(self.trunk(sample))\n        if self.scalp > 0:\n            # Discard the lowest resolution features\n            features, pos = features[: -self.scalp], pos[: -self.scalp]\n\n        src = features[-1]\n        output = {\n            \"vision_features\": src,\n            \"vision_pos_enc\": pos,\n            \"backbone_fpn\": features,\n        }\n        return output\n\n\nclass FpnNeck(nn.Module):\n    \"\"\"\n    A modified variant of Feature Pyramid Network (FPN) neck\n    (we remove output conv and also do bicubic interpolation similar to ViT\n    pos embed interpolation)\n    \"\"\"\n\n    def __init__(\n        self,\n        position_encoding: nn.Module,\n        d_model: int,\n        backbone_channel_list: List[int],\n        kernel_size: int = 1,\n        stride: int = 1,\n        padding: int = 0,\n        fpn_interp_model: str = \"bilinear\",\n        fuse_type: str = \"sum\",\n        fpn_top_down_levels: Optional[List[int]] = None,\n    ):\n        \"\"\"Initialize the neck\n        :param trunk: the backbone\n        :param position_encoding: the positional encoding to use\n        :param d_model: the dimension of the model\n        :param neck_norm: the normalization to use\n        \"\"\"\n        super().__init__()\n        self.position_encoding = position_encoding\n        self.convs = nn.ModuleList()\n        self.backbone_channel_list = backbone_channel_list\n        for dim in backbone_channel_list:\n            current = nn.Sequential()\n            current.add_module(\n                \"conv\",\n                nn.Conv2d(\n                    in_channels=dim,\n                    out_channels=d_model,\n                    kernel_size=kernel_size,\n                    stride=stride,\n                    padding=padding,\n                ),\n            )\n\n            self.convs.append(current)\n        self.fpn_interp_model = fpn_interp_model\n        assert fuse_type in [\"sum\", \"avg\"]\n        self.fuse_type = fuse_type\n\n        # levels to have top-down features in its outputs\n        # e.g. if fpn_top_down_levels is [2, 3], then only outputs of level 2 and 3\n        # have top-down propagation, while outputs of level 0 and level 1 have only\n        # lateral features from the same backbone level.\n        if fpn_top_down_levels is None:\n            # default is to have top-down features on all levels\n            fpn_top_down_levels = range(len(self.convs))\n        self.fpn_top_down_levels = list(fpn_top_down_levels)\n\n    def forward(self, xs: List[torch.Tensor]):\n\n        out = [None] * len(self.convs)\n        pos = [None] * len(self.convs)\n        assert len(xs) == len(self.convs)\n        # fpn forward pass\n        # see https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/fpn.py\n        prev_features = None\n        # forward in top-down order (from low to high resolution)\n        n = len(self.convs) - 1\n        for i in range(n, -1, -1):\n            x = xs[i]\n            lateral_features = self.convs[n - i](x)\n            if i in self.fpn_top_down_levels and prev_features is not None:\n                top_down_features = F.interpolate(\n                    prev_features.to(dtype=torch.float32),\n                    scale_factor=2.0,\n                    mode=self.fpn_interp_model,\n                    align_corners=(\n                        None if self.fpn_interp_model == \"nearest\" else False\n                    ),\n                    antialias=False,\n                )\n                prev_features = lateral_features + top_down_features\n                if self.fuse_type == \"avg\":\n                    prev_features /= 2\n            else:\n                prev_features = lateral_features\n            x_out = prev_features\n            out[i] = x_out\n            pos[i] = self.position_encoding(x_out).to(x_out.dtype)\n\n        return out, pos\n"}

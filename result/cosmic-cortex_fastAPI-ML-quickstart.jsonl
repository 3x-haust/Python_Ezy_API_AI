{"repo_info": {"repo_name": "fastAPI-ML-quickstart", "repo_owner": "cosmic-cortex", "repo_url": "https://github.com/cosmic-cortex/fastAPI-ML-quickstart"}}
{"type": "test_file", "path": "api/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "api/tests/api/__init__.py", "content": ""}
{"type": "test_file", "path": "api/tests/api/test_api.py", "content": "import pytest\nimport random\nimport tempfile\nfrom pathlib import Path\nfrom itertools import product\n\nfrom starlette.testclient import TestClient\nfrom starlette.status import HTTP_200_OK, HTTP_422_UNPROCESSABLE_ENTITY\n\nfrom api.ml.model import n_features\n\n\n@pytest.mark.parametrize(\"n_instances\", range(1, 10))\ndef test_predict(n_instances: int, test_client: TestClient):\n    fake_data = [[random.random() for _ in range(n_features)] for _ in range(n_instances)]\n    response = test_client.post(\"/predict\", json={\"data\": fake_data})\n    assert response.status_code == HTTP_200_OK\n    assert len(response.json()[\"data\"]) == n_instances\n\n\n@pytest.mark.parametrize(\n    \"n_instances, test_data_n_features\",\n    product(range(1, 10), [n for n in range(1, 20) if n != n_features]),\n)\ndef test_predict_with_wrong_input(\n    n_instances: int, test_data_n_features: int, test_client: TestClient\n):\n    fake_data = [[random.random() for _ in range(test_data_n_features)] for _ in range(n_instances)]\n    response = test_client.post(\"/predict\", json={\"data\": fake_data})\n    assert response.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n\ndef test_predict_csv(test_client: TestClient):\n    data_path = Path(__file__).parent / \"data_correct.csv\"\n    with open(data_path, \"r\") as csv_file:\n        response = test_client.post(\"/predict_csv\", files={\"csv_file\": csv_file})\n        assert response.status_code == HTTP_200_OK\n\n\ndef test_predict_csv_with_wrong_input(test_client: TestClient):\n    data_path = Path(__file__).parent / \"data_incorrect.csv\"\n    with open(data_path, \"r\") as csv_file:\n        response = test_client.post(\"/predict_csv\", files={\"csv_file\": csv_file})\n        assert response.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n\ndef test_predict_csv_with_noncsv_file(test_client: TestClient):\n    with open(__file__, \"r\") as file:\n        response = test_client.post(\"/predict_csv\", files={\"csv_file\": file})\n        assert response.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n"}
{"type": "test_file", "path": "api/tests/mocks.py", "content": "import numpy as np\n\n\nclass MockModel:\n    def __init__(self, model_path: str = None):\n        self._model_path = None\n        self._model = None\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        n_instances = len(X)\n        return np.random.rand(n_instances)\n\n    def train(self, X: np.ndarray, y: np.ndarray):\n        return self\n\n    def save(self):\n        pass\n\n    def load(self):\n        return self\n"}
{"type": "test_file", "path": "api/tests/conftest.py", "content": "import pytest\nfrom starlette.testclient import TestClient\n\nfrom ..main import app\n\nfrom ..ml.model import get_model\nfrom .mocks import MockModel\n\n\ndef get_model_override():\n    model = MockModel()\n    return model\n\n\napp.dependency_overrides[get_model] = get_model_override\n\n\n@pytest.fixture()\ndef test_client():\n    return TestClient(app)\n"}
{"type": "source_file", "path": "api/__init__.py", "content": ""}
{"type": "source_file", "path": "api/main.py", "content": "import numpy as np\nimport pandas as pd\n\nfrom typing import List\n\nfrom fastapi import FastAPI, File, UploadFile, HTTPException, Depends\nfrom pydantic import BaseModel, ValidationError, validator\nfrom starlette.status import HTTP_422_UNPROCESSABLE_ENTITY\n\nfrom .ml.model import Model, get_model, n_features\n\n\nclass PredictRequest(BaseModel):\n    data: List[List[float]]\n\n    @validator(\"data\")\n    def check_dimensionality(cls, v):\n        for point in v:\n            if len(point) != n_features:\n                raise ValueError(f\"Each data point must contain {n_features} features\")\n\n        return v\n\n\nclass PredictResponse(BaseModel):\n    data: List[float]\n\n\napp = FastAPI()\n\n\n@app.post(\"/predict\", response_model=PredictResponse)\ndef predict(input: PredictRequest, model: Model = Depends(get_model)):\n    X = np.array(input.data)\n    y_pred = model.predict(X)\n    result = PredictResponse(data=y_pred.tolist())\n\n    return result\n\n\n@app.post(\"/predict_csv\")\ndef predict_csv(csv_file: UploadFile = File(...), model: Model = Depends(get_model)):\n    try:\n        df = pd.read_csv(csv_file.file).astype(float)\n    except:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=\"Unable to process file\"\n        )\n\n    df_n_instances, df_n_features = df.shape\n    if df_n_features != n_features:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=f\"Each data point must contain {n_features} features\",\n        )\n\n    y_pred = model.predict(df.to_numpy().reshape(-1, n_features))\n    result = PredictResponse(data=y_pred.tolist())\n\n    return result\n"}
{"type": "source_file", "path": "api/ml/__init__.py", "content": ""}
{"type": "source_file", "path": "api/ml/model.py", "content": "import joblib\nimport numpy as np\nfrom pathlib import Path\n\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.datasets import load_boston\n\n\nclass Model:\n    def __init__(self, model_path: str = None):\n        self._model = None\n        self._model_path = model_path\n        self.load()\n\n    def train(self, X: np.ndarray, y: np.ndarray):\n        self._model = RandomForestRegressor()\n        self._model.fit(X, y)\n        return self\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        return self._model.predict(X)\n\n    def save(self):\n        if self._model is not None:\n            joblib.dump(self._model, self._model_path)\n        else:\n            raise TypeError(\"The model is not trained yet, use .train() before saving\")\n\n    def load(self):\n        try:\n            self._model = joblib.load(self._model_path)\n        except:\n            self._model = None\n        return self\n\n\nmodel_path = Path(__file__).parent / \"model.joblib\"\nn_features = load_boston(return_X_y=True)[0].shape[1]\nmodel = Model(model_path)\n\n\ndef get_model():\n    return model\n\n\nif __name__ == \"__main__\":\n    X, y = load_boston(return_X_y=True)\n    model.train(X, y)\n    model.save()\n"}

{"repo_info": {"repo_name": "Mirror-Flowers", "repo_owner": "Ky0toFu", "repo_url": "https://github.com/Ky0toFu/Mirror-Flowers"}}
{"type": "test_file", "path": "tests/test_analyzers.py", "content": "import unittest\r\nfrom pathlib import Path\r\nfrom core.analyzers.context_analyzer import ContextAnalyzer\r\nfrom code_analyzer import AnalyzerConfig\r\n\r\nclass TestContextAnalyzer(unittest.TestCase):\r\n    def setUp(self):\r\n        self.analyzer = ContextAnalyzer(AnalyzerConfig())\r\n        \r\n    def test_analyze_file(self):\r\n        test_file = Path(__file__).parent / 'test_data' / 'simple.py'\r\n        self.analyzer.analyze_project_context([test_file])\r\n        context = self.analyzer.get_file_context(str(test_file))\r\n        self.assertIsNotNone(context)\r\n        \r\n    def tearDown(self):\r\n        self.analyzer.clear_analysis()\r\n\r\nif __name__ == '__main__':\r\n    unittest.main() "}
{"type": "source_file", "path": "backend/config.py", "content": "from pydantic_settings import BaseSettings\r\nfrom typing import Dict, List\r\nimport os\r\nfrom enum import Enum\r\nfrom pathlib import Path\r\nfrom urllib.parse import urlparse\r\n\r\nclass LogLevel(str, Enum):\r\n    DEBUG = \"DEBUG\"\r\n    INFO = \"INFO\"\r\n    WARNING = \"WARNING\"\r\n    ERROR = \"ERROR\"\r\n    CRITICAL = \"CRITICAL\"\r\n\r\nclass Settings(BaseSettings):\r\n    # API配置\r\n    OPENAI_API_KEY: str = os.getenv(\"OPENAI_API_KEY\", \"\")\r\n    OPENAI_API_BASE: str = os.getenv(\"OPENAI_API_BASE\", \"\")\r\n    OPENAI_MODEL: str = os.getenv(\"OPENAI_MODEL\", \"\")\r\n    \r\n    # 日志配置\r\n    LOG_LEVEL: LogLevel = os.getenv(\"LOG_LEVEL\", LogLevel.INFO)\r\n    LOG_FORMAT: str = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\r\n    \r\n    # 向量数据库配置\r\n    VECTOR_MODEL: str = \"all-MiniLM-L6-v2\"\r\n    VECTOR_CHUNK_SIZE: int = 500\r\n    VECTOR_CHUNK_OVERLAP: int = 100\r\n    \r\n    # 支持的文件类型\r\n    SUPPORTED_LANGUAGES: Dict[str, str] = {\r\n        '.php': 'php',\r\n        '.java': 'java',\r\n        '.py': 'python',\r\n        '.js': 'javascript'\r\n    }\r\n    \r\n    # 服务器配置\r\n    HOST: str = os.getenv(\"HOST\", \"127.0.0.1\")\r\n    PORT: int = int(os.getenv(\"PORT\", \"8000\"))\r\n    \r\n    # CORS 配置\r\n    CORS_ORIGINS: List[str] = [\r\n        \"http://localhost:3000\",     # React 开发服务器\r\n        \"http://127.0.0.1:3000\",\r\n        \"http://localhost:8000\",     # FastAPI 服务器\r\n        \"http://127.0.0.1:8000\",\r\n    ]\r\n    \r\n    def get_default_models(self, api_base: str) -> Dict[str, List[str]]:\r\n        \"\"\"根据API地址返回默认支持的模型列表\"\"\"\r\n        domain = urlparse(api_base).netloc\r\n        logger.info(f\"部分匹配到域名: {domain}\")\r\n        \r\n        if \"siliconflow\" in domain:\r\n            return {\r\n                \"Chat\": [\r\n                    \"01-ai/Yi-1.5-34B-Chat-16K\",\r\n                    \"01-ai/Yi-1.5-6B-Chat\",\r\n                    \"01-ai/Yi-1.5-9B-Chat-16K\",\r\n                    \"THUDM/chatglm3-6b\",\r\n                    \"THUDM/glm-4-9b-chat\"\r\n                ],\r\n                \"Embedding\": [\r\n                    \"BAAI/bge-large-zh-v1.5\",\r\n                    \"BAAI/bge-large-en-v1.5\"\r\n                ]\r\n            }\r\n        else:\r\n            return {\r\n                \"Chat\": [\"01-ai/Yi-1.5-34B-Chat-16K\"],\r\n                \"Embedding\": [\"BAAI/bge-large-zh-v1.5\"]\r\n            }\r\n\r\n    class Config:\r\n        env_file = \".env\"\r\n        extra = \"allow\"\r\n        use_enum_values = True\r\n\r\nclass PathSettings:\r\n    def __init__(self, settings: Settings):\r\n        self._project_root = Path(__file__).parent.parent\r\n        \r\n        # 创建必要的目录\r\n        self.upload_dir = self._ensure_dir(\"uploads\")\r\n        self.vector_store_dir = self._ensure_dir(\"vector_store\")\r\n        self.log_dir = self._ensure_dir(\"logs\")\r\n        self.config_dir = self._ensure_dir(\"config\")  # 添加配置目录\r\n        self.log_file = self.log_dir / \"app.log\"\r\n        \r\n    def _ensure_dir(self, name: str) -> Path:\r\n        path = self._project_root / name\r\n        path.mkdir(parents=True, exist_ok=True)\r\n        return path\r\n\r\n# 创建全局配置实例\r\nsettings = Settings()\r\npaths = PathSettings(settings)\r\n\r\n# 确保所有必要的目录存在\r\nfor directory in [paths.upload_dir, paths.log_dir, paths.vector_store_dir]:\r\n    os.makedirs(directory, exist_ok=True) "}
{"type": "source_file", "path": "backend/app.py", "content": "import sys\nfrom pathlib import Path\n\n# 添加项目根目录到 Python 路径\nproject_root = Path(__file__).parent.parent\nsys.path.append(str(project_root))\n\nfrom fastapi import FastAPI, UploadFile, File, HTTPException, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, validator\nfrom openai import AsyncOpenAI\nimport os\nfrom typing import List, Optional, Dict, Set, Tuple\nimport aiohttp\nimport logging\nfrom pydantic_settings import BaseSettings\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse\nfrom enum import Enum\nfrom urllib.parse import urlparse\nimport asyncio\nimport zipfile\nfrom pathlib import Path\nimport tempfile\nimport json\nfrom core.analyzers import CoreAnalyzer\nfrom .config import settings, paths\nfrom .services import CodeAuditService\n\n# 只保留 ModelType 枚举，但不作为默认配置\nclass ModelType(str, Enum):\n    GPT35 = \"gpt-3.5-turbo\"\n    GPT4 = \"gpt-4\"\n    CLAUDE = \"claude-2\"\n    CLAUDE3 = \"claude-3\"\n\n# 配置日志\nlogging.basicConfig(\n    level=getattr(logging, str(settings.LOG_LEVEL)),\n    format=settings.LOG_FORMAT,\n    handlers=[\n        logging.FileHandler(str(paths.log_file)),\n        logging.StreamHandler()\n    ]\n)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title=\"Mirror-Flowers\")\n\n# 添加 CORS 支持\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.CORS_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# 修改静态文件路径\nstatic_path = Path(__file__).parent / \"static\"\nif not static_path.exists():\n    static_path.mkdir(parents=True)\n\n# 挂载静态文件\napp.mount(\"/static\", StaticFiles(directory=str(static_path)), name=\"static\")\n\n# 确保上传目录存在\nos.makedirs(str(paths.upload_dir), exist_ok=True)\n\n# 添加新的数据模型\nclass ProjectAuditResult(BaseModel):\n    file_path: str\n    language: str\n    vulnerabilities: List[dict]\n    related_files: List[str]\n    context_analysis: str\n\nclass ProjectAnalysis:\n    def __init__(self):\n        self.file_dependencies: Dict[str, Set[str]] = {}  # 文件依赖关系\n        self.shared_variables: Dict[str, Set[str]] = {}   # 共享变量\n        self.function_calls: Dict[str, Set[str]] = {}     # 函数调用关系\n        self.vulnerability_context: Dict[str, List[dict]] = {}  # 漏洞上下文\n\n    def add_dependency(self, file: str, depends_on: str):\n        if file not in self.file_dependencies:\n            self.file_dependencies[file] = set()\n        self.file_dependencies[file].add(depends_on)\n\n    def add_shared_variable(self, file: str, variable: str):\n        if file not in self.shared_variables:\n            self.shared_variables[file] = set()\n        self.shared_variables[file].add(variable)\n\n    def add_function_call(self, source_file: str, target_file: str):\n        if source_file not in self.function_calls:\n            self.function_calls[source_file] = set()\n        self.function_calls[source_file].add(target_file)\n\n    def get_related_files(self, file: str) -> Set[str]:\n        \"\"\"获取与指定文件相关的所有文件\"\"\"\n        related = set()\n        if file in self.file_dependencies:\n            related.update(self.file_dependencies[file])\n        if file in self.function_calls:\n            related.update(self.function_calls[file])\n        return related\n\n# 依赖注入函数\nasync def get_audit_service() -> CodeAuditService:\n    \"\"\"获取代码审计服务实例\"\"\"\n    try:\n        service = CodeAuditService()\n        await service.ensure_initialized()  # 只调用 ensure_initialized\n        return service\n    except Exception as e:\n        logger.error(f\"获取审计服务失败: {str(e)}\")\n        raise HTTPException(\n            status_code=500,\n            detail=f\"服务初始化失败: {str(e)}\"\n        )\n\n# 添加请求体模型\nclass ConfigureRequest(BaseModel):\n    api_key: str\n    api_base: Optional[str] = None\n    model: Optional[str] = None  # 添加模型选择\n\n# 修改获取可用模型的API\n@app.get(\"/api/models\")\nasync def get_available_models(\n    audit_service: CodeAuditService = Depends(get_audit_service)\n):\n    \"\"\"获取当前API地址支持的模型列表\"\"\"\n    try:\n        # 如果没有 API 配置，先尝试加载保存的配置\n        if not audit_service.api_base:\n            await audit_service.load_config()\n        \n        api_base = audit_service.api_base or settings.OPENAI_API_BASE\n        api_key = audit_service.openai_api_key or settings.OPENAI_API_KEY\n        \n        if not api_base.endswith('/v1'):\n            api_base = api_base.rstrip('/') + '/v1'\n            \n        # 创建 OpenAI 客户端\n        client = AsyncOpenAI(\n            api_key=api_key,\n            base_url=api_base\n        )\n        \n        try:\n            # 直接从 API 获取模型列表\n            models_response = await client.models.list()\n            available_models = [m.id for m in models_response.data]\n            \n            # 按类型分类模型\n            models_by_type = {\n                \"Chat\": [],\n                \"Image\": [],\n                \"Audio\": [],\n                \"Embedding\": []\n            }\n            \n            for model_id in available_models:\n                if model_id.startswith('01-ai/'):\n                    models_by_type[\"Chat\"].append(model_id)\n                elif any(x in model_id.lower() for x in ['sd', 'stable-diffusion']):\n                    models_by_type[\"Image\"].append(model_id)\n                elif any(x in model_id.lower() for x in ['speech', 'voice', 'audio']):\n                    models_by_type[\"Audio\"].append(model_id)\n                elif 'embedding' in model_id.lower():\n                    models_by_type[\"Embedding\"].append(model_id)\n                else:\n                    models_by_type[\"Chat\"].append(model_id)\n            \n            # 获取当前使用的模型\n            current_model = audit_service.model\n            if not current_model:\n                # 如果没有设置当前模型，从可用模型中选择一个\n                chat_models = models_by_type.get(\"Chat\", [])\n                yi_models = [m for m in chat_models if m.startswith('01-ai/Yi-1.5')]\n                current_model = yi_models[0] if yi_models else (chat_models[0] if chat_models else None)\n                if current_model:\n                    audit_service.model = current_model\n                    await audit_service.save_config()\n            \n            logger.info(f\"当前API地址: {api_base}\")\n            logger.info(f\"可用模型: {models_by_type}\")\n            logger.info(f\"当前使用的模型: {current_model}\")\n            \n            return {\n                \"models\": models_by_type,\n                \"current_model\": current_model\n            }\n            \n        except Exception as e:\n            logger.error(f\"从API获取模型列表失败: {str(e)}\")\n            # 如果API获取失败，使用默认配置\n            default_models = {\n                \"Chat\": [\n                    \"01-ai/Yi-1.5-34B-Chat-16K\",\n                    \"01-ai/Yi-1.5-6B-Chat\",\n                    \"01-ai/Yi-1.5-9B-Chat-16K\",\n                    \"THUDM/chatglm3-6b\",\n                    \"THUDM/glm-4-9b-chat\"\n                ],\n                \"Embedding\": [\n                    \"BAAI/bge-large-zh-v1.5\",\n                    \"BAAI/bge-large-en-v1.5\"\n                ]\n            }\n            current_model = audit_service.model or default_models[\"Chat\"][0]\n            return {\n                \"models\": default_models,\n                \"current_model\": current_model\n            }\n            \n    except Exception as e:\n        logger.error(f\"获取模型列表失败: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# 修改配置路由\n@app.post(\"/api/configure\")\nasync def configure_api(\n    config: ConfigureRequest,\n    audit_service: CodeAuditService = Depends(get_audit_service)\n):\n    \"\"\"配置OpenAI API设置\"\"\"\n    try:\n        await audit_service.configure_openai(\n            config.api_key, \n            config.api_base,\n            config.model\n        )\n        return {\n            \"status\": \"success\", \n            \"message\": \"API配置已更新\",\n            \"model\": audit_service.model\n        }\n    except Exception as e:\n        logger.error(f\"配置更新失败: {str(e)}\")\n        raise HTTPException(status_code=400, detail=str(e))\n\n@app.post(\"/api/audit\")\nasync def audit_code(\n    file: UploadFile = File(...),\n    api_key: str = None,\n    api_base: str = None,\n    audit_service: CodeAuditService = Depends(get_audit_service)\n):\n    \"\"\"审计代码，支持自定义API设置\"\"\"\n    try:\n        content = await file.read()\n        code = content.decode()\n        \n        # 获取文件扩展名并检查支持的类型\n        file_extension = os.path.splitext(file.filename)[1].lower()\n        language = audit_service._check_file_type(file.filename)\n        \n        logger.info(f\"开始分析{file.filename}\")\n        \n        result = await audit_service.analyze_code(code, language, api_key, api_base)\n        return result\n    except UnicodeDecodeError:\n        raise HTTPException(status_code=400, detail=\"文件编码错误\")\n    except Exception as e:\n        logger.error(f\"处理文件时发生错误: {str(e)}\")\n        if isinstance(e, HTTPException):\n            raise e\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/api/audit/project\")\nasync def audit_project(\n    project: UploadFile = File(...),\n    api_key: str = None,\n    api_base: str = None,\n    audit_service: CodeAuditService = Depends(get_audit_service)\n):\n    \"\"\"审计整个项目代码\"\"\"\n    try:\n        # 保存上传的项目文件\n        project_path = await save_project_file(project)\n        \n        # 执行项目分析\n        results = await audit_service.analyze_project(project_path)\n        \n        # 直接返回分析结果，不要再包装一层\n        return {\n            **results,  # 展开 results 对象\n            \"project_path\": project_path\n        }\n        \n    except Exception as e:\n        logger.error(f\"项目审计失败: {str(e)}\")\n        # 发生错误时返回一个完整的错误响应\n        empty_report = audit_service._generate_empty_report()\n        return {\n            \"status\": \"error\",\n            \"message\": str(e),\n            \"suspicious_files\": [],\n            \"ai_verification\": {},\n            \"report\": empty_report,\n            \"summary\": empty_report[\"summary\"],\n            \"details\": empty_report[\"details\"],\n            \"recommendations\": empty_report[\"recommendations\"],\n            \"project_path\": project_path if 'project_path' in locals() else None\n        }\n\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\"}\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"\n    根路径处理程序，返回API基本信息\n    \"\"\"\n    return {\n        \"name\": \"Mirror-Flowers\",\n        \"version\": \"1.0.0\",\n        \"status\": \"running\",\n        \"endpoints\": {\n            \"audit\": \"/api/audit\",\n            \"configure\": \"/api/configure\",\n            \"health\": \"/health\",\n            \"docs\": \"/docs\"\n        }\n    }\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request, exc):\n    \"\"\"\n    全局异常处理\n    \"\"\"\n    error_msg = str(exc)\n    logger.error(f\"发生错误: {error_msg}\")\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"内部服务器错误\",\n            \"detail\": error_msg\n        }\n    )\n\n@app.middleware(\"http\")\nasync def log_requests(request, call_next):\n    \"\"\"\n    请求日志中间件\n    \"\"\"\n    logger.info(f\"收到请求: {request.method} {request.url}\")\n    response = await call_next(request)\n    logger.info(f\"响应状态码: {response.status_code}\")\n    return response\n\nasync def save_project_file(project: UploadFile) -> str:\n    \"\"\"保存上传的项目文件\"\"\"\n    try:\n        temp_dir = os.path.join(str(paths.upload_dir), f\"project_{os.urandom(8).hex()}\")\n        os.makedirs(temp_dir, exist_ok=True)\n        \n        file_path = os.path.join(temp_dir, project.filename)\n        with open(file_path, \"wb\") as f:\n            content = await project.read()\n            f.write(content)\n            \n        # 如果是压缩文件，解压\n        if file_path.endswith(('.zip', '.tar.gz')):\n            import zipfile\n            with zipfile.ZipFile(file_path, 'r') as zip_ref:\n                zip_ref.extractall(temp_dir)\n            os.remove(file_path)\n            \n        return temp_dir\n        \n    except Exception as e:\n        logger.error(f\"保存项目文件失败: {str(e)}\")\n        raise \n\n@app.get(\"/ui\")\nasync def serve_spa():\n    \"\"\"\n    服务前端单页应用\n    \"\"\"\n    return FileResponse(str(static_path / \"index.html\")) "}
{"type": "source_file", "path": "core/analyzers/config_analyzer.py", "content": "class ConfigAnalyzer:\r\n    def __init__(self):\r\n        self.dangerous_configs = {\r\n            'php': {\r\n                'allow_url_fopen': 'On',\r\n                'allow_url_include': 'On',\r\n                'display_errors': 'On',\r\n                'expose_php': 'On'\r\n            },\r\n            'java': {\r\n                'debug': 'true',\r\n                'trace': 'true',\r\n                'security.basic.enabled': 'false'\r\n            }\r\n        }\r\n        \r\n        # 添加更多配置检查规则\r\n        self.security_rules = {\r\n            'authentication': {\r\n                'required_settings': ['session.cookie_secure', 'session.cookie_httponly'],\r\n                'forbidden_settings': ['session.use_only_cookies=0']\r\n            },\r\n            'file_upload': {\r\n                'check_settings': ['upload_max_filesize', 'max_file_uploads'],\r\n                'risk_values': ['unlimited', '-1']\r\n            },\r\n            'error_reporting': {\r\n                'production_settings': {\r\n                    'display_errors': 'Off',\r\n                    'log_errors': 'On',\r\n                    'error_reporting': 'E_ALL & ~E_DEPRECATED & ~E_STRICT'\r\n                }\r\n            }\r\n        }\r\n        \r\n    def analyze(self, config_files):\r\n        \"\"\"增强的配置分析\"\"\"\r\n        issues = []\r\n        \r\n        for file_path in config_files:\r\n            config_type = self._detect_config_type(file_path)\r\n            \r\n            # 基本配置检查\r\n            basic_issues = self._check_dangerous_settings(file_path, config_type)\r\n            issues.extend(basic_issues)\r\n            \r\n            # 环境特定检查\r\n            env_issues = self._check_environment_specific(file_path, config_type)\r\n            issues.extend(env_issues)\r\n            \r\n            # 安全规则检查\r\n            security_issues = self._check_security_rules(file_path, config_type)\r\n            issues.extend(security_issues)\r\n            \r\n        return self._prioritize_issues(issues) "}
{"type": "source_file", "path": "backend/services.py", "content": "from core.analyzers import CoreAnalyzer\r\nfrom core.database import CodeVectorStore\r\nfrom .config import settings, paths\r\nimport logging\r\nfrom typing import Dict, Any, List\r\nimport asyncio\r\nfrom openai import AsyncOpenAI\r\nimport json\r\nfrom pathlib import Path\r\nimport os\r\nimport re\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass CodeAuditService:\r\n    def __init__(self):\r\n        self.core_analyzer = None\r\n        self.vector_store = None\r\n        self.openai_api_key = settings.OPENAI_API_KEY\r\n        self.api_base = settings.OPENAI_API_BASE\r\n        self.model = settings.OPENAI_MODEL\r\n        self.config_file = paths.config_dir / \"api_config.json\"\r\n        \r\n    async def ensure_initialized(self):\r\n        \"\"\"确保服务已初始化\"\"\"\r\n        try:\r\n            # 加载保存的配置\r\n            await self.load_config()\r\n            \r\n            # 如果有配置，验证并更新模型\r\n            if self.openai_api_key and self.api_base:\r\n                try:\r\n                    # 确保 API 基础 URL 正确\r\n                    if not self.api_base.endswith('/v1'):\r\n                        self.api_base = self.api_base.rstrip('/') + '/v1'\r\n                        \r\n                    client = AsyncOpenAI(\r\n                        api_key=self.openai_api_key,\r\n                        base_url=self.api_base\r\n                    )\r\n                    models_response = await client.models.list()\r\n                    available_models = [m.id for m in models_response.data]\r\n                    \r\n                    # 验证当前模型\r\n                    if not self.model or self.model not in available_models:\r\n                        # 选择一个默认的可用模型\r\n                        yi_models = [m for m in available_models if m.startswith('01-ai/Yi-1.5')]\r\n                        self.model = yi_models[0] if yi_models else available_models[0]\r\n                        await self.save_config()\r\n                        \r\n                except Exception as e:\r\n                    logger.warning(f\"API验证失败，使用默认配置: {str(e)}\")\r\n                    # 如果验证失败，使用默认配置\r\n                    if not self.model:\r\n                        self.model = settings.OPENAI_MODEL\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"服务初始化失败: {str(e)}\")\r\n            raise\r\n            \r\n    async def ensure_analysis_ready(self):\r\n        \"\"\"确保分析所需的组件已初始化\"\"\"\r\n        if not self.vector_store:\r\n            self.vector_store = CodeVectorStore(\r\n                persist_directory=paths.vector_store_dir\r\n            )\r\n        \r\n        if not self.core_analyzer:\r\n            self.core_analyzer = CoreAnalyzer()\r\n            \r\n    async def save_config(self):\r\n        \"\"\"保存API配置\"\"\"\r\n        config = {\r\n            \"api_key\": self.openai_api_key,\r\n            \"api_base\": self.api_base,\r\n            \"model\": self.model\r\n        }\r\n        self.config_file.parent.mkdir(parents=True, exist_ok=True)\r\n        with open(self.config_file, 'w') as f:\r\n            json.dump(config, f)\r\n            \r\n    async def load_config(self):\r\n        \"\"\"加载保存的API配置\"\"\"\r\n        try:\r\n            if self.config_file.exists():\r\n                with open(self.config_file, 'r') as f:\r\n                    config = json.load(f)\r\n                self.openai_api_key = config.get(\"api_key\")\r\n                self.api_base = config.get(\"api_base\")\r\n                self.model = config.get(\"model\")\r\n                logger.info(f\"已加载保存的配置，使用模型: {self.model}\")\r\n        except Exception as e:\r\n            logger.error(f\"加载配置失败: {str(e)}\")\r\n            \r\n    async def configure_openai(self, api_key: str, api_base: str = None, model: str = None):\r\n        \"\"\"配置OpenAI API设置\"\"\"\r\n        try:\r\n            self.openai_api_key = api_key\r\n            # 确保 API 基础 URL 正确\r\n            if api_base:\r\n                if not api_base.endswith('/v1'):\r\n                    api_base = api_base.rstrip('/') + '/v1'\r\n                self.api_base = api_base\r\n            \r\n            # 验证配置\r\n            client = AsyncOpenAI(\r\n                api_key=self.openai_api_key,\r\n                base_url=self.api_base\r\n            )\r\n            \r\n            try:\r\n                # 获取可用模型列表\r\n                models_response = await client.models.list()\r\n                available_models = [m.id for m in models_response.data]\r\n                logger.info(f\"API配置成功，可用模型: {available_models}\")\r\n                \r\n                # 如果指定了模型，验证是否可用\r\n                if model:\r\n                    # 对于某些API，模型ID可能需要添加前缀\r\n                    model_variants = [\r\n                        model,\r\n                        f\"01-ai/{model}\",\r\n                        model.replace(\"01-ai/\", \"\")\r\n                    ]\r\n                    \r\n                    for variant in model_variants:\r\n                        if variant in available_models:\r\n                            self.model = variant\r\n                            logger.info(f\"使用指定模型: {self.model}\")\r\n                            break\r\n                    else:\r\n                        logger.warning(f\"选择的模型 {model} 不在可用模型列表中\")\r\n                        # 选择一个默认的可用模型\r\n                        yi_models = [m for m in available_models if m.startswith('01-ai/Yi-1.5')]\r\n                        self.model = yi_models[0] if yi_models else available_models[0]\r\n                else:\r\n                    # 选择一个默认的可用模型\r\n                    yi_models = [m for m in available_models if m.startswith('01-ai/Yi-1.5')]\r\n                    self.model = yi_models[0] if yi_models else available_models[0]\r\n                    \r\n                logger.info(f\"最终使用模型: {self.model}\")\r\n                \r\n                # 保存配置\r\n                await self.save_config()\r\n                    \r\n            except Exception as e:\r\n                logger.error(f\"API配置验证失败: {str(e)}\")\r\n                raise ValueError(f\"API配置无效: {str(e)}\")\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"配置 OpenAI API 失败: {str(e)}\")\r\n            raise\r\n\r\n    async def analyze_project(self, project_path: str) -> Dict[str, Any]:\r\n        \"\"\"分析整个项目\"\"\"\r\n        try:\r\n            # 1. 初始化分析器和向量数据库\r\n            await self.ensure_initialized()\r\n            await self.ensure_analysis_ready()\r\n            \r\n            # 2. 预处理：检查项目类型和文件有效性\r\n            project_type = self._detect_project_type(project_path)\r\n            logger.info(f\"检测到项目类型: {project_type}\")\r\n            \r\n            # 3. 本地静态扫描\r\n            logger.info(\"开始静态扫描...\")\r\n            # 直接传递项目路径，而不是文件列表\r\n            suspicious_files = await self.core_analyzer._static_scan(project_path)\r\n            \r\n            if not suspicious_files:\r\n                logger.info(\"未发现可疑代码\")\r\n                return {\r\n                    \"status\": \"success\",\r\n                    \"message\": \"未发现可疑代码\",\r\n                    \"suspicious_files\": [],\r\n                    \"ai_verification\": {},\r\n                    \"summary\": {\r\n                        \"total_files\": len(self._get_valid_files(project_path, project_type)),\r\n                        \"total_issues\": 0,\r\n                        \"risk_level\": \"low\"\r\n                    },\r\n                    \"recommendations\": []\r\n                }\r\n            \r\n            # 4. 导入向量数据库\r\n            logger.info(\"导入向量数据库...\")\r\n            try:\r\n                await self.core_analyzer._import_to_vector_store(project_path)\r\n            except Exception as e:\r\n                logger.error(f\"导入向量数据库失败: {str(e)}\")\r\n                # 继续执行，不中断流程\r\n            \r\n            # 5. AI 深度分析\r\n            logger.info(\"开始AI验证...\")\r\n            try:\r\n                results = await self.core_analyzer._ai_verify_suspicious(suspicious_files)\r\n            except Exception as e:\r\n                logger.error(f\"AI验证失败: {str(e)}\")\r\n                results = {}\r\n            \r\n            # 6. 生成最终报告\r\n            return {\r\n                \"status\": \"success\",\r\n                \"message\": \"分析完成\",\r\n                \"project_type\": project_type,\r\n                \"suspicious_files\": suspicious_files,\r\n                \"ai_verification\": results,\r\n                \"summary\": {\r\n                    \"total_files\": len(self._get_valid_files(project_path, project_type)),\r\n                    \"suspicious_files\": len(suspicious_files),\r\n                    \"total_issues\": sum(len(file.get(\"issues\", [])) for file in suspicious_files),\r\n                    \"risk_level\": self._calculate_risk_level(suspicious_files)\r\n                },\r\n                \"recommendations\": self._generate_recommendations(suspicious_files, results)\r\n            }\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"项目分析失败: {str(e)}\")\r\n            return {\r\n                \"status\": \"error\",\r\n                \"message\": str(e),\r\n                \"project_type\": \"unknown\",\r\n                \"suspicious_files\": [],\r\n                \"ai_verification\": {},\r\n                \"summary\": {\r\n                    \"total_files\": 0,\r\n                    \"suspicious_files\": 0,\r\n                    \"total_issues\": 0,\r\n                    \"risk_level\": \"unknown\"\r\n                },\r\n                \"recommendations\": []\r\n            }\r\n\r\n    def _detect_project_type(self, project_path: str) -> str:\r\n        \"\"\"检测项目类型\"\"\"\r\n        try:\r\n            project_path = Path(project_path)\r\n            \r\n            # 检查特征文件\r\n            indicators = {\r\n                'php': ['composer.json', 'index.php', '.php'],\r\n                'python': ['requirements.txt', 'setup.py', '.py'],\r\n                'javascript': ['package.json', '.js', '.ts'],\r\n                'java': ['pom.xml', 'build.gradle', '.java']\r\n            }\r\n            \r\n            # 统计各类型文件数量\r\n            type_counts = {k: 0 for k in indicators.keys()}\r\n            \r\n            # 遍历项目文件\r\n            for file_path in project_path.rglob('*'):\r\n                if file_path.is_file():\r\n                    # 检查特征文件\r\n                    file_name = file_path.name.lower()\r\n                    file_ext = file_path.suffix.lower()\r\n                    \r\n                    for lang, patterns in indicators.items():\r\n                        if any(pattern in file_name or pattern == file_ext for pattern in patterns):\r\n                            type_counts[lang] += 1\r\n            \r\n            # 根据文件数量判断项目类型\r\n            if any(type_counts.values()):\r\n                project_type = max(type_counts.items(), key=lambda x: x[1])[0]\r\n                logger.info(f\"检测到项目类型: {project_type}\")\r\n                return project_type\r\n            \r\n            return \"unknown\"\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"项目类型检测失败: {str(e)}\")\r\n            return \"unknown\"\r\n\r\n    def _get_valid_files(self, project_path: str, project_type: str) -> List[str]:\r\n        \"\"\"获取指定项目类型的有效文件\"\"\"\r\n        try:\r\n            project_path = Path(project_path)\r\n            valid_files = []\r\n            \r\n            # 定义项目类型对应的文件扩展名\r\n            type_extensions = {\r\n                'php': ['.php'],\r\n                'python': ['.py', '.pyw'],\r\n                'javascript': ['.js', '.jsx', '.ts', '.tsx'],\r\n                'java': ['.java', '.jsp']\r\n            }\r\n            \r\n            # 获取当前项目类型支持的扩展名\r\n            valid_extensions = type_extensions.get(project_type, [])\r\n            if project_type == \"auto\":\r\n                valid_extensions = [ext for exts in type_extensions.values() for ext in exts]\r\n            \r\n            # 忽略的目录\r\n            ignore_dirs = {\r\n                'node_modules', 'venv', '.git', '.svn', '__pycache__',\r\n                'vendor', 'dist', 'build', 'target', 'tests', 'test'\r\n            }\r\n            \r\n            # 遍历项目文件\r\n            for file_path in project_path.rglob('*'):\r\n                try:\r\n                    # 检查是否在忽略目录中\r\n                    if any(ignore_dir in file_path.parts for ignore_dir in ignore_dirs):\r\n                        continue\r\n                    \r\n                    # 检查是否为文件\r\n                    if not file_path.is_file():\r\n                        continue\r\n                    \r\n                    # 检查是否为隐藏文件\r\n                    if file_path.name.startswith('.'):\r\n                        continue\r\n                    \r\n                    # 检查扩展名\r\n                    if file_path.suffix.lower() in valid_extensions:\r\n                        # 检查文件是否可读\r\n                        try:\r\n                            with open(file_path, 'r', encoding='utf-8'):\r\n                                pass\r\n                            valid_files.append(str(file_path))\r\n                        except (UnicodeDecodeError, PermissionError):\r\n                            continue\r\n                        \r\n                except Exception as e:\r\n                    logger.error(f\"处理文件失败 {file_path}: {str(e)}\")\r\n                    continue\r\n                \r\n            logger.info(f\"找到 {len(valid_files)} 个有效的源代码文件\")\r\n            return valid_files\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"获取有效文件失败: {str(e)}\")\r\n            return []\r\n\r\n    async def _import_suspicious_to_vector_store(self, suspicious_files: List[Dict[str, Any]]):\r\n        \"\"\"仅导入可疑文件及其相关文件到向量数据库\"\"\"\r\n        try:\r\n            code_snippets = []\r\n            for file_info in suspicious_files:\r\n                file_path = Path(file_info[\"file_path\"])  # 转换为 Path 对象\r\n                \r\n                # 获取文件内容，尝试不同的编码\r\n                content = None\r\n                encodings = ['utf-8', 'gbk', 'latin1']\r\n                for encoding in encodings:\r\n                    try:\r\n                        with open(file_path, \"r\", encoding=encoding) as f:\r\n                            content = f.read()\r\n                        break\r\n                    except UnicodeDecodeError:\r\n                        continue\r\n                        \r\n                if content is None:\r\n                    logger.warning(f\"无法读取文件 {file_path}，跳过\")\r\n                    continue\r\n                \r\n                # 添加可疑文件\r\n                code_snippets.append({\r\n                    \"code\": content,\r\n                    \"file_path\": str(file_path),  # 转换回字符串\r\n                    \"line_start\": 1,\r\n                    \"line_end\": len(content.splitlines()),\r\n                    \"metadata\": {\r\n                        \"type\": \"suspicious\",\r\n                        \"issues_json\": json.dumps(file_info.get(\"issues\", [])),\r\n                        \"language\": file_info.get(\"language\", \"unknown\")\r\n                    }\r\n                })\r\n                \r\n                # 获取相关文件\r\n                related_files = self._get_related_files(str(file_path))  # 传入字符串\r\n                for related_file in related_files:\r\n                    related_path = Path(related_file)\r\n                    if related_path != file_path:\r\n                        # 尝试不同的编码读取相关文件\r\n                        related_content = None\r\n                        for encoding in encodings:\r\n                            try:\r\n                                with open(related_path, \"r\", encoding=encoding) as f:\r\n                                    related_content = f.read()\r\n                                break\r\n                            except UnicodeDecodeError:\r\n                                continue\r\n                                \r\n                        if related_content is None:\r\n                            logger.warning(f\"无法读取相关文件 {related_path}，跳过\")\r\n                            continue\r\n                            \r\n                        code_snippets.append({\r\n                            \"code\": related_content,\r\n                            \"file_path\": str(related_path),  # 转换回字符串\r\n                            \"line_start\": 1,\r\n                            \"line_end\": len(related_content.splitlines()),\r\n                            \"metadata\": {\r\n                                \"type\": \"related\",\r\n                                \"related_to\": str(file_path),  # 转换回字符串\r\n                                \"language\": self._check_file_type(str(related_path))\r\n                            }\r\n                        })\r\n            \r\n            # 批量导入向量数据库\r\n            if code_snippets:\r\n                await self.vector_store.add_code_to_store(code_snippets)\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"导入向量数据库失败: {str(e)}\")\r\n            raise\r\n        \r\n    def _generate_empty_report(self) -> Dict[str, Any]:\r\n        \"\"\"生成空的分析报告\"\"\"\r\n        return {\r\n            \"summary\": {\r\n                \"total_files\": 0,\r\n                \"total_issues\": 0,\r\n                \"risk_level\": \"low\",\r\n                \"scan_time\": None,\r\n                \"project_info\": {\r\n                    \"name\": None,\r\n                    \"path\": None,\r\n                    \"files_scanned\": 0\r\n                }\r\n            },\r\n            \"details\": {\r\n                \"suspicious_files\": [],\r\n                \"ai_verification\": {},\r\n                \"scan_coverage\": {\r\n                    \"total_files\": 0,\r\n                    \"scanned_files\": 0,\r\n                    \"coverage_rate\": 0\r\n                }\r\n            },\r\n            \"recommendations\": []\r\n        }\r\n        \r\n    def _generate_report(self, suspicious_files: List[Dict[str, Any]], ai_results: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"生成分析报告\"\"\"\r\n        try:\r\n            total_files = len(suspicious_files)\r\n            total_issues = sum(len(file_info.get(\"issues\", [])) for file_info in suspicious_files)\r\n            \r\n            return {\r\n                \"summary\": {\r\n                    \"total_files\": total_files,\r\n                    \"total_issues\": total_issues,\r\n                    \"risk_level\": self._calculate_risk_level(suspicious_files),\r\n                    \"scan_time\": None,  # TODO: 添加扫描时间\r\n                    \"project_info\": {\r\n                        \"name\": None,  # TODO: 添加项目名称\r\n                        \"path\": None,  # TODO: 添加项目路径\r\n                        \"files_scanned\": total_files\r\n                    }\r\n                },\r\n                \"details\": {\r\n                    \"suspicious_files\": [\r\n                        {\r\n                            \"file_path\": file_info[\"file_path\"],\r\n                            \"language\": file_info.get(\"language\", \"unknown\"),\r\n                            \"issues\": file_info.get(\"issues\", []),\r\n                            \"ai_analysis\": ai_results.get(file_info[\"file_path\"], {})\r\n                        }\r\n                        for file_info in suspicious_files\r\n                    ],\r\n                    \"scan_coverage\": {\r\n                        \"total_files\": total_files,\r\n                        \"scanned_files\": total_files,\r\n                        \"coverage_rate\": 100 if total_files > 0 else 0\r\n                    }\r\n                },\r\n                \"recommendations\": self._generate_recommendations(suspicious_files, ai_results)\r\n            }\r\n        except Exception as e:\r\n            logger.error(f\"生成报告失败: {str(e)}\")\r\n            return self._generate_empty_report()\r\n        \r\n    def _calculate_risk_level(self, suspicious_files: List[Dict]) -> str:\r\n        \"\"\"计算整体风险等级\"\"\"\r\n        try:\r\n            high_count = 0\r\n            medium_count = 0\r\n            low_count = 0\r\n            \r\n            for file in suspicious_files:\r\n                for issue in file.get(\"issues\", []):\r\n                    severity = issue.get(\"severity\", \"\").lower()\r\n                    if severity == \"high\":\r\n                        high_count += 1\r\n                    elif severity == \"medium\":\r\n                        medium_count += 1\r\n                    elif severity == \"low\":\r\n                        low_count += 1\r\n            \r\n            if high_count > 0:\r\n                return \"high\"\r\n            elif medium_count > 0:\r\n                return \"medium\"\r\n            elif low_count > 0:\r\n                return \"low\"\r\n            else:\r\n                return \"info\"\r\n            \r\n        except Exception:\r\n            return \"unknown\"\r\n        \r\n    def _generate_recommendations(self, suspicious_files: List[Dict], ai_results: Dict) -> List[Dict]:\r\n        \"\"\"生成修复建议\"\"\"\r\n        recommendations = []\r\n        try:\r\n            for file in suspicious_files:\r\n                file_path = file.get(\"file_path\", \"\")\r\n                ai_result = ai_results.get(file_path, {}).get(\"ai_analysis\", {})\r\n                \r\n                if isinstance(ai_result, dict):\r\n                    recs = ai_result.get(\"recommendations\", [])\r\n                    for rec in recs:\r\n                        if isinstance(rec, dict):\r\n                            recommendations.append({\r\n                                \"file\": file_path,\r\n                                \"issue\": rec.get(\"issue\", \"\"),\r\n                                \"solution\": rec.get(\"solution\", \"\")\r\n                            })\r\n                        \r\n        except Exception as e:\r\n            logger.error(f\"生成修复建议失败: {str(e)}\")\r\n        \r\n        return recommendations\r\n\r\n    def _get_related_files(self, file_path: str) -> List[str]:\r\n        \"\"\"获取与指定文件相关的文件\"\"\"\r\n        try:\r\n            related_files = []\r\n            file_path = Path(file_path)  # 转换为 Path 对象\r\n            file_dir = file_path.parent\r\n            \r\n            # 1. 检查同目录下的文件\r\n            for f in file_dir.iterdir():\r\n                if f.is_file() and f != file_path:\r\n                    related_files.append(str(f))  # 转换为字符串\r\n            \r\n            # 2. 检查包含关系\r\n            with open(file_path, 'r', encoding='utf-8') as f:\r\n                content = f.read()\r\n                \r\n            # 检查 PHP 的 include/require\r\n            if file_path.suffix.lower() == '.php':\r\n                includes = re.findall(r'(?:include|require)(?:_once)?\\s*[\\'\"]([^\\'\"]+)[\\'\"]', content)\r\n                for inc in includes:\r\n                    inc_path = file_dir / inc  # 使用 Path 对象的 / 运算符\r\n                    if inc_path.exists():\r\n                        related_files.append(str(inc_path))\r\n            \r\n            # 检查 Python 的 import\r\n            elif file_path.suffix.lower() == '.py':\r\n                imports = re.findall(r'(?:from|import)\\s+([\\w.]+)', content)\r\n                for imp in imports:\r\n                    imp_parts = imp.split('.')\r\n                    imp_path = file_dir.joinpath(*imp_parts).with_suffix('.py')\r\n                    if imp_path.exists():\r\n                        related_files.append(str(imp_path))\r\n            \r\n            # 检查 JavaScript 的 require/import\r\n            elif file_path.suffix.lower() in ('.js', '.jsx', '.ts', '.tsx'):\r\n                imports = re.findall(r'(?:require|import)\\s*[\\(\\{]\\s*[\\'\"]([^\\'\"]+)[\\'\"]', content)\r\n                for imp in imports:\r\n                    imp_path = file_dir / imp  # 基本路径\r\n                    # 检查多个可能的扩展名\r\n                    possible_exts = ['.js', '.jsx', '.ts', '.tsx']\r\n                    for ext in possible_exts:\r\n                        full_path = imp_path.with_suffix(ext)\r\n                        if full_path.exists():\r\n                            related_files.append(str(full_path))\r\n                            break\r\n            \r\n            return list(set(related_files))  # 去重\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"获取相关文件失败 {file_path}: {str(e)}\")\r\n            return []\r\n\r\n    def _check_file_type(self, file_path: str) -> str:\r\n        \"\"\"检查文件类型\"\"\"\r\n        ext = Path(file_path).suffix.lower()  # 使用 Path 对象获取扩展名\r\n        language_map = {\r\n            '.py': 'python',\r\n            '.js': 'javascript',\r\n            '.ts': 'typescript',\r\n            '.jsx': 'react',\r\n            '.tsx': 'react',\r\n            '.php': 'php',\r\n            '.java': 'java',\r\n            '.cs': 'csharp',\r\n            '.go': 'go',\r\n            '.rb': 'ruby',\r\n            '.html': 'html',\r\n            '.css': 'css',\r\n            '.sql': 'sql'\r\n        }\r\n        return language_map.get(ext, 'unknown')\r\n\r\n    async def analyze_code(self, code: str, language: str, api_key: str = None, api_base: str = None) -> Dict[str, Any]:\r\n        \"\"\"分析单个代码文件\"\"\"\r\n        try:\r\n            # 初始化\r\n            await self.ensure_initialized()\r\n            await self.ensure_analysis_ready()\r\n            \r\n            # 进行代码分析\r\n            issues = self.core_analyzer._check_suspicious(code, f\"temp.{language}\")\r\n            \r\n            if not issues:\r\n                empty_report = self._generate_empty_report()\r\n                return {\r\n                    \"status\": \"success\",\r\n                    \"message\": \"未发现可疑代码\",\r\n                    \"issues\": [],\r\n                    \"report\": empty_report,\r\n                    \"summary\": empty_report[\"summary\"],\r\n                    \"details\": empty_report[\"details\"],\r\n                    \"recommendations\": empty_report[\"recommendations\"]\r\n                }\r\n            \r\n            # 生成报告\r\n            report = self._generate_report([{\r\n                \"file_path\": f\"temp.{language}\",\r\n                \"issues\": issues,\r\n                \"language\": language\r\n            }], {})\r\n            \r\n            return {\r\n                \"status\": \"success\",\r\n                \"issues\": issues,\r\n                \"report\": report,\r\n                \"summary\": report[\"summary\"],\r\n                \"details\": report[\"details\"],\r\n                \"recommendations\": report[\"recommendations\"]\r\n            }\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"代码分析失败: {str(e)}\")\r\n            empty_report = self._generate_empty_report()\r\n            return {\r\n                \"status\": \"error\",\r\n                \"message\": str(e),\r\n                \"issues\": [],\r\n                \"report\": empty_report,\r\n                \"summary\": empty_report[\"summary\"],\r\n                \"details\": empty_report[\"details\"],\r\n                \"recommendations\": empty_report[\"recommendations\"]\r\n            }\r\n\r\n    def scan_project(self, project_path: str) -> List[str]:\r\n        \"\"\"扫描项目文件\"\"\"\r\n        valid_files = []\r\n        try:\r\n            # 添加调试日志\r\n            logger.debug(f\"开始扫描项目: {project_path}\")\r\n            \r\n            for root, _, files in os.walk(project_path):\r\n                for file in files:\r\n                    file_path = os.path.join(root, file)\r\n                    # 添加调试日志\r\n                    logger.debug(f\"检查文件: {file_path}\")\r\n                    if file_path.endswith(('.php', '.blade.php', '.js', '.ts', '.tsx', '.py')):\r\n                        valid_files.append(file_path)\r\n                        logger.debug(f\"添加有效文件: {file_path}\")\r\n                        \r\n            logger.info(f\"找到 {len(valid_files)} 个有效的源代码文件\")\r\n            return valid_files\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"扫描项目失败: {str(e)}\")\r\n            return [] "}
{"type": "source_file", "path": "core/analyzers/dependency_analyzer.py", "content": "import json\r\n\r\nclass DependencyAnalyzer:\r\n    def __init__(self):\r\n        self.vulnerability_database = self._load_vulnerability_database()\r\n        self.dependency_graph = {}\r\n        \r\n    def analyze_dependencies(self, project_files):\r\n        \"\"\"完整的项目依赖分析\"\"\"\r\n        issues = []\r\n        for file in project_files:\r\n            if file.endswith('pom.xml'):\r\n                issues.extend(self._analyze_maven_dependencies(file))\r\n            elif file.endswith('package.json'):\r\n                issues.extend(self._analyze_npm_dependencies(file))\r\n            elif file.endswith('requirements.txt'):\r\n                issues.extend(self._analyze_python_dependencies(file))\r\n            elif file.endswith('composer.json'):\r\n                issues.extend(self._analyze_composer_dependencies(file))\r\n        return issues\r\n\r\n    def _analyze_maven_dependencies(self, pom_file):\r\n        \"\"\"分析Maven依赖\"\"\"\r\n        try:\r\n            with open(pom_file, 'r') as f:\r\n                content = f.read()\r\n            dependencies = self._parse_pom_xml(content)\r\n            return self._check_dependencies(dependencies, 'maven')\r\n        except Exception as e:\r\n            return [{'error': f'Maven依赖分析失败: {str(e)}'}]\r\n\r\n    def _analyze_npm_dependencies(self, package_file):\r\n        \"\"\"分析NPM依赖\"\"\"\r\n        try:\r\n            with open(package_file, 'r') as f:\r\n                data = json.load(f)\r\n            dependencies = {**data.get('dependencies', {}), **data.get('devDependencies', {})}\r\n            return self._check_dependencies(dependencies, 'npm')\r\n        except Exception as e:\r\n            return [{'error': f'NPM依赖分析失败: {str(e)}'}]\r\n\r\n    def _analyze_python_dependencies(self, requirements_file):\r\n        \"\"\"分析Python依赖\"\"\"\r\n        try:\r\n            with open(requirements_file, 'r') as f:\r\n                dependencies = {}\r\n                for line in f:\r\n                    if '==' in line:\r\n                        name, version = line.strip().split('==')\r\n                        dependencies[name] = version\r\n            return self._check_dependencies(dependencies, 'python')\r\n        except Exception as e:\r\n            return [{'error': f'Python依赖分析失败: {str(e)}'}]\r\n\r\n    def _check_dependencies(self, dependencies, ecosystem):\r\n        \"\"\"检查依赖的安全问题\"\"\"\r\n        issues = []\r\n        for name, version in dependencies.items():\r\n            # 检查已知漏洞\r\n            vulns = self._check_known_vulnerabilities(name, version, ecosystem)\r\n            if vulns:\r\n                issues.extend(vulns)\r\n            \r\n            # 检查版本过时\r\n            if self._is_outdated_version(name, version, ecosystem):\r\n                issues.append({\r\n                    'type': 'outdated_dependency',\r\n                    'name': name,\r\n                    'current_version': version,\r\n                    'latest_version': self._get_latest_version(name, ecosystem),\r\n                    'ecosystem': ecosystem,\r\n                    'severity': 'medium',\r\n                    'recommendation': '建议更新到最新的稳定版本'\r\n                })\r\n            \r\n            # 检查许可证\r\n            license_issue = self._check_license_compatibility(name, ecosystem)\r\n            if license_issue:\r\n                issues.append(license_issue)\r\n                \r\n        return issues\r\n\r\n    def analyze(self, dependencies):\r\n        \"\"\"分析项目依赖中的安全问题\"\"\"\r\n        vulnerabilities = []\r\n        \r\n        for dep in dependencies:\r\n            if dep in self.vulnerability_database:\r\n                vulnerabilities.append({\r\n                    'type': 'vulnerable_dependency',\r\n                    'name': dep,\r\n                    'version': dependencies[dep],\r\n                    'known_vulnerabilities': self.vulnerability_database[dep],\r\n                    'severity': 'high',\r\n                    'recommendation': '更新到最新的安全版本'\r\n                })\r\n                \r\n        return vulnerabilities "}
{"type": "source_file", "path": "code_analyzer.py", "content": "import ast\nfrom typing import Dict, Set, List, Optional, Union\nfrom pathlib import Path\nfrom dataclasses import dataclass\n\n@dataclass\nclass AnalyzerConfig:\n    max_workers: int = 4  # 并行处理的最大线程数\n    ignore_patterns: List[str] = None  # 要忽略的文件模式\n    follow_imports: bool = True  # 是否分析导入的模块\n    max_depth: int = 3  # 分析的最大深度\n    encoding: str = 'utf-8'  # 文件编码\n\nclass CodeAnalyzer:\n    def __init__(self, config: Optional[AnalyzerConfig] = None):\n        self.config = config or AnalyzerConfig()\n        self.dependencies: Dict[str, Set[str]] = {}\n        self.globals: Dict[str, Set[str]] = {}\n        self.function_calls: Dict[str, Set[str]] = {}\n        self.class_hierarchy: Dict[str, List[str]] = {}\n        self.variable_usages: Dict[str, Set[str]] = {}  # 存储变量使用位置\n\n    def _analyze_dependencies(self, content: str, file_path: str) -> None:\n        \"\"\"分析文件的导入依赖关系\"\"\"\n        tree = ast.parse(content)\n        \n        class ImportVisitor(ast.NodeVisitor):\n            def __init__(self, analyzer, file_path):\n                self.analyzer = analyzer\n                self.file_path = file_path\n                self.aliases = {}  # 记录导入别名\n                \n            def visit_Import(self, node):\n                for name in node.names:\n                    self.analyzer.dependencies.setdefault(self.file_path, set()).add(name.name)\n                    if name.asname:\n                        self.aliases[name.asname] = name.name\n                        \n            def visit_ImportFrom(self, node):\n                module = node.module if node.module else ''\n                for name in node.names:\n                    full_name = f\"{module}.{name.name}\" if module else name.name\n                    self.analyzer.dependencies.setdefault(self.file_path, set()).add(full_name)\n                    if name.asname:\n                        self.aliases[name.asname] = full_name\n                        \n            def visit_Name(self, node):\n                # 检查是否使用了导入的别名\n                if node.id in self.aliases:\n                    self.analyzer.dependencies.setdefault(self.file_path, set()).add(self.aliases[node.id])\n                self.generic_visit(node)\n        \n        visitor = ImportVisitor(self, file_path)\n        visitor.visit(tree)\n\n    def _analyze_globals(self, content: str, file_path: str) -> None:\n        \"\"\"分析全局变量\"\"\"\n        tree = ast.parse(content)\n        \n        class GlobalVisitor(ast.NodeVisitor):\n            def __init__(self, analyzer, file_path):\n                self.analyzer = analyzer\n                self.file_path = file_path\n                self.current_scope = None\n                \n            def visit_Module(self, node):\n                old_scope = self.current_scope\n                self.current_scope = 'module'\n                self.generic_visit(node)\n                self.current_scope = old_scope\n                \n            def visit_Global(self, node):\n                for name in node.names:\n                    self.analyzer.globals.setdefault(self.file_path, set()).add(name)\n                    \n            def visit_Assign(self, node):\n                if self.current_scope == 'module' and isinstance(node.targets[0], ast.Name):\n                    self.analyzer.globals.setdefault(self.file_path, set()).add(node.targets[0].id)\n                self.generic_visit(node)\n        \n        visitor = GlobalVisitor(self, file_path)\n        visitor.visit(tree)\n\n    def _analyze_function_calls(self, content: str, file_path: str) -> None:\n        \"\"\"分析函数调用关系\"\"\"\n        tree = ast.parse(content)\n        \n        class FunctionCallVisitor(ast.NodeVisitor):\n            def __init__(self, analyzer, file_path):\n                self.analyzer = analyzer\n                self.file_path = file_path\n                self.current_function = None\n                self.current_class = None\n                \n            def visit_ClassDef(self, node):\n                old_class = self.current_class\n                self.current_class = node.name\n                self.generic_visit(node)\n                self.current_class = old_class\n                \n            def visit_FunctionDef(self, node):\n                old_function = self.current_function\n                if self.current_class:\n                    self.current_function = f\"{self.current_class}.{node.name}\"\n                else:\n                    self.current_function = node.name\n                self.generic_visit(node)\n                self.current_function = old_function\n                \n            def visit_Call(self, node):\n                if not self.current_function:\n                    return\n                \n                caller = f\"{self.file_path}:{self.current_function}\"\n                \n                if isinstance(node.func, ast.Name):\n                    callee = node.func.id\n                elif isinstance(node.func, ast.Attribute):\n                    # 处理方法调用\n                    if isinstance(node.func.value, ast.Name):\n                        callee = f\"{node.func.value.id}.{node.func.attr}\"\n                    else:\n                        callee = node.func.attr\n                else:\n                    return\n                    \n                self.analyzer.function_calls.setdefault(caller, set()).add(callee)\n                self.generic_visit(node)\n        \n        visitor = FunctionCallVisitor(self, file_path)\n        visitor.visit(tree)\n\n    def _analyze_class_hierarchy(self, content: str, file_path: str) -> None:\n        \"\"\"分析类继承关系\"\"\"\n        tree = ast.parse(content)\n        \n        class ClassVisitor(ast.NodeVisitor):\n            def __init__(self, analyzer, file_path):\n                self.analyzer = analyzer\n                self.file_path = file_path\n                self.current_module = None\n                \n            def visit_Module(self, node):\n                for imp in node.body:\n                    if isinstance(imp, ast.ImportFrom):\n                        self.current_module = imp.module\n                self.generic_visit(node)\n                \n            def visit_ClassDef(self, node):\n                class_name = f\"{self.file_path}:{node.name}\"\n                bases = []\n                for base in node.bases:\n                    if isinstance(base, ast.Name):\n                        bases.append(base.id)\n                    elif isinstance(base, ast.Attribute):\n                        # 处理完整的模块路径\n                        parts = []\n                        current = base\n                        while isinstance(current, ast.Attribute):\n                            parts.append(current.attr)\n                            current = current.value\n                        if isinstance(current, ast.Name):\n                            parts.append(current.id)\n                        bases.append('.'.join(reversed(parts)))\n                if bases:\n                    self.analyzer.class_hierarchy[class_name] = bases\n        \n        visitor = ClassVisitor(self, file_path)\n        visitor.visit(tree)\n\n    def _analyze_variable_usage(self, content: str, file_path: str) -> None:\n        \"\"\"分析变量的使用位置\"\"\"\n        tree = ast.parse(content)\n        \n        class VariableVisitor(ast.NodeVisitor):\n            def __init__(self, analyzer, file_path):\n                self.analyzer = analyzer\n                self.file_path = file_path\n                self.current_function = None\n                self.current_class = None\n                \n            def visit_ClassDef(self, node):\n                old_class = self.current_class\n                self.current_class = node.name\n                self.generic_visit(node)\n                self.current_class = old_class\n                \n            def visit_FunctionDef(self, node):\n                old_function = self.current_function\n                scope = f\"{self.current_class}.{node.name}\" if self.current_class else node.name\n                self.current_function = scope\n                self.generic_visit(node)\n                self.current_function = old_function\n                \n            def visit_Name(self, node):\n                if isinstance(node.ctx, (ast.Load, ast.Store)):\n                    scope = f\"{self.file_path}:{self.current_function}\" if self.current_function else self.file_path\n                    self.analyzer.variable_usages.setdefault(node.id, set()).add(scope)\n                self.generic_visit(node)\n                \n            def visit_Attribute(self, node):\n                if isinstance(node.ctx, (ast.Load, ast.Store)) and isinstance(node.value, ast.Name):\n                    if node.value.id == 'self' and self.current_class:\n                        # 记录实例变量\n                        var_name = f\"{self.current_class}.{node.attr}\"\n                        scope = f\"{self.file_path}:{self.current_function}\"\n                        self.analyzer.variable_usages.setdefault(var_name, set()).add(scope)\n                self.generic_visit(node)\n        \n        visitor = VariableVisitor(self, file_path)\n        visitor.visit(tree)\n\n    def get_file_dependencies(self, file_path: str) -> set:\n        \"\"\"获取指定文件的依赖\"\"\"\n        return self.dependencies.get(file_path, set())\n\n    def get_file_globals(self, file_path: str) -> set:\n        \"\"\"获取指定文件的全局变量\"\"\"\n        return self.globals.get(file_path, set())\n\n    def get_function_calls(self, function_name: str) -> set:\n        \"\"\"获取指定函数调用的其他函数\"\"\"\n        return self.function_calls.get(function_name, set())\n\n    def get_class_bases(self, class_name: str) -> list:\n        \"\"\"获取指定类的父类\"\"\"\n        return self.class_hierarchy.get(class_name, [])\n\n    def get_variable_usages(self, variable_name: str) -> set:\n        \"\"\"获取变量的所有使用位置\"\"\"\n        return self.variable_usages.get(variable_name, set())\n\n    def analyze_file(self, content: str, file_path: Union[str, Path]) -> None:\n        \"\"\"分析单个文件的所有关系\n        \n        Args:\n            content (str): 文件内容\n            file_path (Union[str, Path]): 文件路径\n            \n        Raises:\n            SyntaxError: 当文件包含语法错误时\n            Exception: 其他分析错误\n        \"\"\"\n        if isinstance(file_path, Path):\n            file_path = str(file_path)\n        try:\n            # 分析文件依赖\n            self._analyze_dependencies(content, file_path)\n            \n            # 分析全局变量\n            self._analyze_globals(content, file_path)\n            \n            # 分析函数调用关系\n            self._analyze_function_calls(content, file_path)\n            \n            # 分析类继承关系\n            self._analyze_class_hierarchy(content, file_path)\n            \n            # 分析变量使用位置\n            self._analyze_variable_usage(content, file_path)\n        except SyntaxError:\n            print(f\"语法错误: {file_path}\")\n        except Exception as e:\n            print(f\"分析错误 {file_path}: {str(e)}\")\n\n    def get_file_analysis(self, file_path: str) -> dict:\n        \"\"\"获取指定文件的完整分析结果\"\"\"\n        return {\n            'dependencies': self.get_file_dependencies(file_path),\n            'globals': self.get_file_globals(file_path),\n            'function_calls': {\n                caller: self.get_function_calls(caller)\n                for caller in self.function_calls\n                if caller.startswith(f\"{file_path}:\")\n            },\n            'class_hierarchy': {\n                class_name: self.get_class_bases(class_name)\n                for class_name in self.class_hierarchy\n                if class_name.startswith(f\"{file_path}:\")\n            }\n        } "}
{"type": "source_file", "path": "core/analyzers/core_analyzer.py", "content": "from typing import List, Dict, Any\r\nfrom pathlib import Path\r\nimport logging\r\nfrom .taint_analyzer import TaintAnalyzer\r\nfrom .security_analyzer import SecurityAnalyzer\r\nfrom .framework_analyzer import FrameworkAnalyzer\r\nfrom ..database.vector_store import CodeVectorStore\r\nimport json\r\nimport asyncio\r\nfrom typing import Optional\r\nimport os\r\nimport ast\r\nimport re\r\nfrom backend.config import settings\r\nfrom openai import AsyncOpenAI\r\nfrom .parsers import CodeParser\r\nfrom .visitors import PHPASTVisitor, TypeScriptASTVisitor\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass CoreAnalyzer:\r\n    def __init__(self):\r\n        self.taint_analyzer = TaintAnalyzer()\r\n        self.security_analyzer = SecurityAnalyzer() \r\n        self.framework_analyzer = FrameworkAnalyzer()\r\n        self.vector_store = CodeVectorStore()\r\n        self.parser = CodeParser()\r\n        self.issues = []\r\n        \r\n    async def analyze_project(self, project_path: str) -> Dict[str, Any]:\r\n        \"\"\"分析整个项目\r\n        \r\n        1. 首先进行本地静态扫描\r\n        2. 将代码导入向量数据库\r\n        3. 对可疑代码进行AI验证\r\n        \"\"\"\r\n        try:\r\n            project_path = Path(project_path)\r\n            \r\n            # 1. 本地静态扫描\r\n            suspicious_files = await self._static_scan(str(project_path))\r\n            \r\n            # 2. 导入向量数据库\r\n            await self._import_to_vector_store(str(project_path))\r\n            \r\n            # 3. AI验证可疑代码\r\n            results = await self._ai_verify_suspicious(suspicious_files)\r\n            \r\n            return {\r\n                \"status\": \"success\",\r\n                \"message\": \"分析完成\",\r\n                \"suspicious_files\": suspicious_files,\r\n                \"ai_verification\": results,\r\n                \"summary\": {\r\n                    \"total_files\": len(suspicious_files),\r\n                    \"total_issues\": sum(len(file.get(\"issues\", [])) for file in suspicious_files),\r\n                    \"risk_level\": self._calculate_risk_level(suspicious_files)\r\n                },\r\n                \"recommendations\": self._generate_recommendations(suspicious_files, results)\r\n            }\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"Project analysis failed: {str(e)}\")\r\n            return {\r\n                \"status\": \"error\",\r\n                \"message\": str(e),\r\n                \"suspicious_files\": [],\r\n                \"ai_verification\": {},\r\n                \"summary\": {\r\n                    \"total_files\": 0,\r\n                    \"total_issues\": 0,\r\n                    \"risk_level\": \"unknown\"\r\n                },\r\n                \"recommendations\": []\r\n            }\r\n\r\n    def _parse_code(self, content: str, file_path: str) -> Any:\r\n        \"\"\"解析代码为AST\"\"\"\r\n        try:\r\n            if not isinstance(file_path, (str, Path)):\r\n                logger.error(f\"无效的文件路径类型: {type(file_path)}\")\r\n                return None\r\n                \r\n            # 使用 CodeParser 进行解析\r\n            parser = CodeParser()\r\n            result = parser.parse(content, file_path)\r\n            \r\n            # 确保返回有效的结果\r\n            if not result or not isinstance(result, dict):\r\n                logger.error(f\"解析结果无效: {file_path}\")\r\n                return None\r\n                \r\n            # 确保必要的字段存在\r\n            if 'ast' not in result:\r\n                logger.error(f\"解析结果缺少AST: {file_path}\")\r\n                return None\r\n                \r\n            return result['ast']  # 只返回AST部分\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"解析代码失败 {file_path}: {str(e)}\")\r\n            return None\r\n            \r\n    def analyze_file(self, content: str, file_path: str) -> List[Dict]:\r\n        \"\"\"分析单个文件\"\"\"\r\n        try:\r\n            # 检查文件是否存在\r\n            if not os.path.exists(file_path):\r\n                logger.error(f\"文件不存在: {file_path}\")\r\n                return []\r\n                \r\n            # 检查文件类型\r\n            ext = os.path.splitext(file_path)[1].lower()\r\n            if not ext:\r\n                logger.error(f\"无法确定文件类型: {file_path}\")\r\n                return []\r\n                \r\n            # 检查可疑代码\r\n            issues = self._check_suspicious(content, file_path)\r\n            \r\n            # 如果是PHP文件，进行额外的安全检查\r\n            if ext == '.php' or ext == '.blade.php':\r\n                try:\r\n                    parser = CodeParser()\r\n                    ast = parser.parse(content, file_path)\r\n                    if ast and isinstance(ast, dict) and 'ast' in ast:\r\n                        security_context = self._check_security_context(ast['ast'], file_path)\r\n                        if not security_context.get('has_validation', False):\r\n                            issues.append({\r\n                                'type': 'security',\r\n                                'line': ast.get('line', 0),\r\n                                'description': '缺少输入验证',\r\n                                'severity': 'medium',\r\n                                'file': file_path\r\n                            })\r\n                except Exception as e:\r\n                    logger.error(f\"检查安全上下文失败: {str(e)}\")\r\n                    \r\n            return issues\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"分析文件失败 {file_path}: {str(e)}\")\r\n            return []\r\n\r\n    def _check_suspicious(self, content: str, file_path: str) -> List[Dict[str, Any]]:\r\n        \"\"\"检查文件是否包含可疑代码\"\"\"\r\n        try:\r\n            # 获取文件扩展名\r\n            file_path = str(file_path)  # 确保是字符串\r\n            if file_path.endswith('.blade.php'):\r\n                ext = '.blade.php'\r\n            else:\r\n                ext = os.path.splitext(file_path)[1].lower()\r\n            \r\n            # 根据文件类型进行检查\r\n            if ext == '.php' or ext == '.blade.php':\r\n                issues = self._simple_php_check(content)\r\n            elif ext in ['.js', '.ts', '.tsx']:\r\n                issues = self._simple_js_check(content)\r\n            else:\r\n                issues = self._simple_code_check(content)\r\n                \r\n            # 添加文件路径信息\r\n            for issue in issues:\r\n                issue['file'] = file_path\r\n                \r\n            return issues\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"检查代码失败 {file_path}: {str(e)}\")\r\n            return []\r\n\r\n    async def _static_scan(self, project_path: str) -> List[Dict[str, Any]]:\r\n        \"\"\"静态扫描项目文件\"\"\"\r\n        suspicious_files = []\r\n        try:\r\n            project_path = str(project_path)\r\n            valid_files = []\r\n            \r\n            # 扫描文件\r\n            for root, _, files in os.walk(project_path):\r\n                for file in files:\r\n                    file_path = os.path.join(root, file)\r\n                    if file_path.endswith(('.php', '.blade.php', '.js', '.ts', '.tsx', '.py')):\r\n                        valid_files.append(file_path)\r\n                        logger.debug(f\"添加有效文件: {file_path}\")\r\n                        \r\n            logger.info(f\"找到 {len(valid_files)} 个待分析文件\")\r\n            \r\n            # 分析每个文件\r\n            for file_path in valid_files:\r\n                try:\r\n                    # 读取文件内容\r\n                    content = self._read_file_content(file_path)\r\n                    if not content:\r\n                        logger.warning(f\"无法读取文件内容: {file_path}\")\r\n                        continue\r\n                        \r\n                    logger.debug(f\"开始分析文件: {file_path}\")\r\n                    \r\n                    # 检查可疑代码\r\n                    issues = self._check_suspicious(content, file_path)\r\n                    if issues:\r\n                        suspicious_files.append({\r\n                            \"file_path\": file_path,\r\n                            \"issues\": issues,\r\n                            \"language\": self._detect_language(file_path),\r\n                            \"context\": self._get_context_info(file_path)\r\n                        })\r\n                        logger.debug(f\"发现 {len(issues)} 个问题: {file_path}\")\r\n                        \r\n                except Exception as e:\r\n                    logger.error(f\"分析文件失败 {file_path}: {str(e)}\")\r\n                    continue\r\n                    \r\n            logger.info(f\"扫描完成，发现 {len(suspicious_files)} 个可疑文件\")\r\n            return suspicious_files\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"静态扫描失败: {str(e)}\")\r\n            return []\r\n\r\n    def _filter_false_positives(self, issues: List[Dict], content: str, \r\n                              file_path: str) -> List[Dict]:\r\n        \"\"\"过滤误报\"\"\"\r\n        filtered = []\r\n        for issue in issues:\r\n            # 1. 检查是否在安全上下文中\r\n            if self._is_in_safe_context(issue, content):\r\n                continue\r\n            \r\n            # 2. 检查是否有足够的验证\r\n            if self._has_sufficient_validation(issue, content):\r\n                continue\r\n            \r\n            # 3. 检查是否在测试代码中\r\n            if self._is_test_code(file_path):\r\n                continue\r\n            \r\n            filtered.append(issue)\r\n        return filtered\r\n\r\n    def _is_in_safe_context(self, issue: Dict, content: str) -> bool:\r\n        \"\"\"检查是否在安全上下文中\"\"\"\r\n        try:\r\n            # 获取问题所在行的上下文\r\n            lines = content.splitlines()\r\n            issue_line = lines[issue.get('line', 1) - 1]\r\n            \r\n            # 检查是否有安全处理\r\n            safe_patterns = [\r\n                r'escape', r'htmlspecialchars', r'sanitize',\r\n                r'validate', r'filter', r'prepared'\r\n            ]\r\n            \r\n            # 向上查找5行\r\n            start = max(0, issue.get('line', 1) - 5)\r\n            context_lines = lines[start:issue.get('line', 1)]\r\n            \r\n            return any(any(pattern in line for pattern in safe_patterns)\r\n                      for line in context_lines)\r\n        except Exception as e:\r\n            logger.error(f\"检查安全上下文失败: {str(e)}\")\r\n            return False\r\n\r\n    async def _scan_single_file(self, file_path: Path) -> Optional[Dict[str, Any]]:\r\n        \"\"\"扫描单个文件\"\"\"\r\n        try:\r\n            # 尝试不同的编码读取文件\r\n            content = None\r\n            encodings = ['utf-8', 'gbk', 'latin1']\r\n            for encoding in encodings:\r\n                try:\r\n                    with open(file_path, \"r\", encoding=encoding) as f:\r\n                        content = f.read()\r\n                    break\r\n                except UnicodeDecodeError:\r\n                    continue\r\n                \r\n            if content is None:\r\n                logger.warning(f\"无法读取文件 {file_path}，跳过\")\r\n                return None\r\n            \r\n            # 并发执行各类分析\r\n            taint_task = asyncio.create_task(self.taint_analyzer.analyze(content))\r\n            security_task = asyncio.create_task(self.security_analyzer.analyze(content))\r\n            framework_task = asyncio.create_task(\r\n                self.framework_analyzer.analyze_framework(\r\n                    content,\r\n                    self._detect_framework(content)\r\n                )\r\n            )\r\n            \r\n            # 等待所有分析完成\r\n            taint_issues, security_issues, framework_issues = await asyncio.gather(\r\n                taint_task, security_task, framework_task\r\n            )\r\n            \r\n            return {\r\n                \"file_path\": str(file_path),  # 转换为字符串\r\n                \"issues\": {\r\n                    \"taint\": taint_issues,\r\n                    \"security\": security_issues,\r\n                    \"framework\": framework_issues\r\n                },\r\n                \"language\": self._detect_language(file_path)\r\n            }\r\n        except Exception as e:\r\n            logger.error(f\"Error scanning {file_path}: {str(e)}\")\r\n            return None\r\n\r\n    async def _import_to_vector_store(self, project_path: str) -> None:\r\n        \"\"\"将源代码导入向量数据库\"\"\"\r\n        try:\r\n            code_snippets = []\r\n            project_path = Path(project_path)  # 转换为 Path 对象\r\n            \r\n            for file_path in project_path.rglob(\"*\"):\r\n                if not self._is_source_file(file_path):\r\n                    continue\r\n                    \r\n                try:\r\n                    # 尝试不同的编码读取文件\r\n                    content = None\r\n                    encodings = ['utf-8', 'gbk', 'latin1']\r\n                    for encoding in encodings:\r\n                        try:\r\n                            with open(file_path, \"r\", encoding=encoding) as f:\r\n                                content = f.read()\r\n                            break\r\n                        except UnicodeDecodeError:\r\n                            continue\r\n                            \r\n                    if content is None:\r\n                        logger.warning(f\"无法读取文件 {file_path}，跳过\")\r\n                        continue\r\n                        \r\n                    code_snippets.append({\r\n                        \"code\": content,\r\n                        \"file_path\": str(file_path),  # 转换为字符串\r\n                        \"line_start\": 1,\r\n                        \"line_end\": len(content.splitlines()),\r\n                        \"metadata\": {\r\n                            \"framework\": self._detect_framework(content),\r\n                            \"language\": self._detect_language(file_path)\r\n                        }\r\n                    })\r\n                    \r\n                except Exception as e:\r\n                    logger.error(f\"Error importing {file_path}: {str(e)}\")\r\n                    \r\n            if code_snippets:\r\n                await self.vector_store.add_code_to_store(code_snippets)\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"导入向量数据库失败: {str(e)}\")\r\n            raise\r\n\r\n    async def _ai_verify_suspicious(self, suspicious_files: List[Dict[str, Any]]) -> Dict[str, Any]:\r\n        \"\"\"AI验证可疑代码\"\"\"\r\n        # 从配置文件读取API设置\r\n        config_path = Path(__file__).parent.parent.parent / \"config\" / \"api_config.json\"\r\n        if config_path.exists():\r\n            with open(config_path, \"r\") as f:\r\n                config = json.load(f)\r\n                api_key = config.get(\"api_key\")\r\n                api_base = config.get(\"api_base\")\r\n                model = config.get(\"model\")\r\n        else:\r\n            api_key = settings.OPENAI_API_KEY\r\n            api_base = settings.OPENAI_API_BASE\r\n            model = settings.OPENAI_MODEL\r\n\r\n        if not api_key:\r\n            raise ValueError(\"未配置API密钥\")\r\n\r\n        # 创建 OpenAI 客户端\r\n        client = AsyncOpenAI(\r\n            api_key=api_key,\r\n            base_url=api_base\r\n        )\r\n\r\n        results = {}\r\n        \r\n        for file_info in suspicious_files:\r\n            file_path = file_info[\"file_path\"]\r\n            \r\n            try:\r\n                # 获取文件内容\r\n                content = self._get_file_content(file_path)\r\n                if not content:\r\n                    continue\r\n                    \r\n                # 构建分析提示\r\n                prompt = f\"\"\"请对以下代码进行安全审计并以JSON格式返回分析结果：\r\n\r\n文件路径: {file_path}\r\n发现的问题: {json.dumps(file_info.get('issues', []), ensure_ascii=False)}\r\n\r\n源代码:\r\n{content}\r\n\r\n请以以下JSON格式返回分析结果：\r\n{{\r\n    \"vulnerability_confirmation\": {{\r\n        \"dangerous_function\": {{\r\n            \"is_false_positive\": false,\r\n            \"evidence\": \"具体的漏洞证据\"\r\n        }}\r\n    }},\r\n    \"impact_analysis\": {{\r\n        \"dangerous_function\": {{\r\n            \"severity\": \"high/medium/low\",\r\n            \"exploit_conditions\": \"利用条件描述\",\r\n            \"impact_scope\": \"影响范围描述\"\r\n        }}\r\n    }},\r\n    \"remediation_suggestions\": {{\r\n        \"dangerous_function\": {{\r\n            \"code_level_fix\": \"具体的代码修复建议\",\r\n            \"secure_coding_practices\": \"安全编码建议\",\r\n            \"security_configuration_suggestions\": \"安全配置建议\"\r\n        }}\r\n    }},\r\n    \"correlation_analysis\": {{\r\n        \"dangerous_function\": {{\r\n            \"association\": \"漏洞关联性分析\",\r\n            \"exploit_combination\": \"组合利用分析\",\r\n            \"overall_remediation_strategy\": \"整体修复策略\"\r\n        }}\r\n    }}\r\n}}\"\"\"\r\n\r\n                # 调用AI API\r\n                results[file_path] = {\r\n                    \"issues\": file_info.get('issues', []),\r\n                    \"similar_code\": [],\r\n                    \"ai_analysis\": await self._call_ai_api(prompt)\r\n                }\r\n                \r\n            except Exception as e:\r\n                logger.error(f\"AI分析失败 {file_path}: {str(e)}\")\r\n                continue\r\n        \r\n        return results\r\n\r\n    def _is_source_file(self, file_path: Path) -> bool:\r\n        \"\"\"检查是否为源代码文件\"\"\"\r\n        try:\r\n            # 检查是否为文件\r\n            if not file_path.is_file():\r\n                return False\r\n            \r\n            # 获取文件扩展名（转换为小写）\r\n            ext = file_path.suffix.lower()\r\n            \r\n            # 支持的文件类型\r\n            supported_extensions = {\r\n                # Web\r\n                '.php', '.html', '.htm', '.js', '.jsx', '.ts', '.tsx', '.vue', '.css',\r\n                # Python\r\n                '.py', '.pyw', '.pyx',\r\n                # Java\r\n                '.java', '.jsp', '.jspx',\r\n                # .NET\r\n                '.cs', '.vb', '.aspx', '.ascx',\r\n                # 其他\r\n                '.go', '.rb', '.pl', '.sh', '.sql'\r\n            }\r\n            \r\n            # 忽略的目录\r\n            ignore_dirs = {'node_modules', 'venv', '.git', '.svn', '__pycache__', \r\n                          'vendor', 'dist', 'build', 'target'}\r\n            \r\n            # 检查是否在忽略目录中\r\n            if any(part in ignore_dirs for part in file_path.parts):\r\n                return False\r\n            \r\n            # 检查是否为隐藏文件\r\n            if file_path.name.startswith('.'):\r\n                return False\r\n            \r\n            # 检查扩展名\r\n            return ext in supported_extensions\r\n        \r\n        except Exception as e:\r\n            logger.error(f\"检查文件类型失败 {file_path}: {str(e)}\")\r\n            return False\r\n\r\n    def _detect_language(self, file_path: str) -> str:\r\n        \"\"\"检测文件语言类型\"\"\"\r\n        try:\r\n            # 确保file_path是字符串类型\r\n            file_path = str(file_path)\r\n            \r\n            # 处理特殊情况\r\n            if file_path.endswith('.blade.php'):\r\n                return 'php'\r\n                \r\n            # 获取扩展名\r\n            ext = os.path.splitext(file_path)[1].lower()\r\n            \r\n            # 语言映射\r\n            language_map = {\r\n                '.php': 'php',\r\n                '.js': 'javascript',\r\n                '.ts': 'typescript',\r\n                '.tsx': 'typescript',\r\n                '.py': 'python'\r\n            }\r\n            \r\n            return language_map.get(ext, 'unknown')\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"检测语言类型失败 {file_path}: {str(e)}\")\r\n            return 'unknown'\r\n\r\n    def _detect_framework(self, content: str) -> str:\r\n        \"\"\"检测使用的框架\"\"\"\r\n        framework_patterns = {\r\n            'laravel': [\r\n                r'use\\s+Illuminate\\\\',\r\n                r'extends\\s+Controller',\r\n                r'Laravel\\\\',\r\n            ],\r\n            'thinkphp': [\r\n                r'use\\s+think\\\\',\r\n                r'extends\\s+Controller',\r\n                r'namespace\\s+app\\\\',\r\n            ],\r\n            'django': [\r\n                r'from\\s+django\\.',\r\n                r'models\\.Model',\r\n                r'@login_required',\r\n            ],\r\n            'flask': [\r\n                r'from\\s+flask\\s+import',\r\n                r'@app\\.route',\r\n                r'Flask\\(',\r\n            ],\r\n            'express': [\r\n                r'express\\(\\)',\r\n                r'app\\.get\\(',\r\n                r'app\\.post\\(',\r\n            ],\r\n            'spring': [\r\n                r'@Controller',\r\n                r'@RequestMapping',\r\n                r'@Autowired',\r\n            ]\r\n        }\r\n        \r\n        detected_frameworks = []\r\n        \r\n        for framework, patterns in framework_patterns.items():\r\n            if any(re.search(pattern, content) for pattern in patterns):\r\n                detected_frameworks.append(framework)\r\n            \r\n        return detected_frameworks[0] if detected_frameworks else 'unknown'\r\n\r\n    def _get_file_content(self, file_path: str) -> str:\r\n        \"\"\"获取文件内容\"\"\"\r\n        try:\r\n            # 确保file_path是字符串类型\r\n            file_path = str(file_path)\r\n            \r\n            # 尝试不同的编码\r\n            encodings = ['utf-8', 'gbk', 'latin1']\r\n            for encoding in encodings:\r\n                try:\r\n                    with open(file_path, \"r\", encoding=encoding) as f:\r\n                        return f.read()\r\n                except UnicodeDecodeError:\r\n                    continue\r\n                \r\n            logger.warning(f\"无法读取文件 {file_path}\")\r\n            return \"\"\r\n        \r\n        except Exception as e:\r\n            logger.error(f\"获取文件内容失败 {file_path}: {str(e)}\")\r\n            return \"\"\r\n            \r\n    def _generate_analysis_prompt(self, issues: List[Dict], similar_code: List) -> str:\r\n        \"\"\"生成更详细的AI分析提示\"\"\"\r\n        try:\r\n            # 确保 issues 是可序列化的\r\n            if isinstance(issues, str):\r\n                try:\r\n                    issues = json.loads(issues)\r\n                except json.JSONDecodeError:\r\n                    issues = []\r\n            \r\n            # 格式化 issues\r\n            issues_str = json.dumps(issues, indent=2, ensure_ascii=False) if issues else \"[]\"\r\n            \r\n            # 格式化 similar_code\r\n            similar_code_str = json.dumps(similar_code, indent=2, ensure_ascii=False) if similar_code else \"[]\"\r\n            \r\n            prompt = f\"\"\"请分析以下代码中的安全漏洞：\r\n\r\n发现的问题：\r\n{issues_str}\r\n\r\n相似代码上下文：\r\n{similar_code_str}\r\n\r\n请提供以下分析：\r\n1. 漏洞确认\r\n   - 验证每个发现的漏洞是否为误报\r\n   - 提供漏洞存在的具体证据\r\n\r\n2. 影响分析\r\n   - 评估每个漏洞的实际危害\r\n   - 分析漏洞的利用条件\r\n   - 评估漏洞的影响范围\r\n\r\n3. 修复建议\r\n   - 提供具体的代码级修复方案\r\n   - 建议的安全编码实践\r\n   - 相关的安全配置建议\r\n\r\n4. 关联分析\r\n   - 分析漏洞间的关联性\r\n   - 评估组合利用的可能性\r\n   - 建议的整体修复策略\r\n\r\n请以JSON格式返回分析结果。\r\n\"\"\"\r\n            return prompt\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"生成分析提示失败: {str(e)}\")\r\n            return \"\"\r\n        \r\n    async def _call_ai_api(self, prompt: str) -> Dict:\r\n        \"\"\"调用AI API进行代码分析\"\"\"\r\n        try:\r\n            # 从配置文件读取API设置\r\n            config_path = Path(__file__).parent.parent.parent / \"config\" / \"api_config.json\"\r\n            if config_path.exists():\r\n                with open(config_path, \"r\") as f:\r\n                    config = json.load(f)\r\n                    api_key = config.get(\"api_key\")\r\n                    api_base = config.get(\"api_base\")\r\n                    model = config.get(\"model\")\r\n            else:\r\n                # 如果配置文件不存在,使用环境变量或默认值\r\n                api_key = settings.OPENAI_API_KEY\r\n                api_base = settings.OPENAI_API_BASE\r\n                model = settings.OPENAI_MODEL\r\n\r\n            if not api_key:\r\n                raise ValueError(\"未配置API密钥\")\r\n\r\n            # 创建 OpenAI 客户端\r\n            client = AsyncOpenAI(\r\n                api_key=api_key,\r\n                base_url=api_base\r\n            )\r\n            \r\n            # 调用 API\r\n            response = await client.chat.completions.create(\r\n                model=model,\r\n                messages=[\r\n                    {\"role\": \"system\", \"content\": \"你是一个专业的代码安全审计专家。请分析代码中的安全问题并提供修复建议。\"},\r\n                    {\"role\": \"user\", \"content\": prompt}\r\n                ],\r\n                temperature=0.2,\r\n                max_tokens=2000\r\n            )\r\n            \r\n            # 获取响应文本\r\n            analysis_text = response.choices[0].message.content\r\n            \r\n            # 尝试从响应文本中提取JSON内容\r\n            try:\r\n                # 如果返回的是markdown代码块，提取其中的JSON内容\r\n                if analysis_text.startswith('```') and analysis_text.endswith('```'):\r\n                    # 移除markdown代码块标记\r\n                    json_str = analysis_text.split('\\n', 1)[1].rsplit('\\n', 1)[0]\r\n                    if json_str.startswith('json'):\r\n                        json_str = json_str[4:].strip()\r\n                    analysis_data = json.loads(json_str)\r\n                else:\r\n                    # 直接尝试解析JSON\r\n                    analysis_data = json.loads(analysis_text)\r\n                    \r\n                # 构造前端期望的响应格式\r\n                return {\r\n                    \"status\": \"success\",\r\n                    \"analysis\": {\r\n                        # 将对象转换为格式化的JSON字符串\r\n                        \"raw_text\": json.dumps(analysis_data, ensure_ascii=False, indent=2),\r\n                        \"summary\": {\r\n                            \"risk_level\": analysis_data.get(\"impact_analysis\", {})\r\n                                .get(\"dangerous_function\", {})\r\n                                .get(\"severity\", \"unknown\"),\r\n                            \"vulnerability_count\": len(analysis_data.get(\"vulnerability_confirmation\", {}))\r\n                        },\r\n                        \"vulnerabilities\": [\r\n                            {\r\n                                \"type\": vuln_type,\r\n                                \"severity\": vuln_data.get(\"severity\", \"unknown\"),\r\n                                \"description\": vuln_data.get(\"evidence\", \"\")\r\n                            }\r\n                            for vuln_type, vuln_data in analysis_data.get(\"vulnerability_confirmation\", {}).items()\r\n                        ],\r\n                        \"recommendations\": [\r\n                            {\r\n                                \"issue\": rec_type,\r\n                                \"solution\": (\r\n                                    f\"{rec_data.get('code_level_fix', '')}\\n\"\r\n                                    f\"{rec_data.get('secure_coding_practices', '')}\"\r\n                                ).strip()\r\n                            }\r\n                            for rec_type, rec_data in analysis_data.get(\"remediation_suggestions\", {}).items()\r\n                        ]\r\n                    }\r\n                }\r\n                \r\n            except json.JSONDecodeError as e:\r\n                logger.error(f\"JSON解析失败: {str(e)}\")\r\n                # 如果JSON解析失败，返回原始文本\r\n                return {\r\n                    \"status\": \"success\",\r\n                    \"analysis\": {\r\n                        \"raw_text\": analysis_text,\r\n                        \"summary\": self._extract_summary(analysis_text),\r\n                        \"vulnerabilities\": self._extract_vulnerabilities(analysis_text),\r\n                        \"recommendations\": self._extract_recommendations(analysis_text)\r\n                    }\r\n                }\r\n                \r\n        except Exception as e:\r\n            logger.error(f\"AI API调用失败: {str(e)}\")\r\n            return {\r\n                \"status\": \"error\",\r\n                \"message\": str(e)\r\n            }\r\n\r\n    def _extract_summary(self, text: str) -> Dict:\r\n        \"\"\"从AI响应中提取摘要信息\"\"\"\r\n        try:\r\n            # 使用正则表达式提取关键信息\r\n            risk_level = re.search(r'风险等级[：:]\\s*(\\w+)', text)\r\n            vuln_count = re.search(r'漏洞数量[：:]\\s*(\\d+)', text)\r\n            \r\n            return {\r\n                \"risk_level\": risk_level.group(1) if risk_level else \"unknown\",\r\n                \"vulnerability_count\": int(vuln_count.group(1)) if vuln_count else 0\r\n            }\r\n        except Exception:\r\n            return {\"risk_level\": \"unknown\", \"vulnerability_count\": 0}\r\n\r\n    def _extract_vulnerabilities(self, text: str) -> List[Dict]:\r\n        \"\"\"从AI响应中提取漏洞信息\"\"\"\r\n        vulnerabilities = []\r\n        try:\r\n            # 使用正则表达式匹配漏洞描述块\r\n            vuln_blocks = re.finditer(\r\n                r'漏洞类型[：:]\\s*(.+?)\\n.*?严重程度[：:]\\s*(.+?)\\n.*?描述[：:]\\s*(.+?)\\n',\r\n                text,\r\n                re.DOTALL\r\n            )\r\n            \r\n            for block in vuln_blocks:\r\n                vulnerabilities.append({\r\n                    \"type\": block.group(1).strip(),\r\n                    \"severity\": block.group(2).strip(),\r\n                    \"description\": block.group(3).strip()\r\n                })\r\n                \r\n        except Exception:\r\n            pass\r\n        return vulnerabilities\r\n\r\n    def _extract_recommendations(self, text: str) -> List[Dict]:\r\n        \"\"\"从AI响应中提取修复建议\"\"\"\r\n        recommendations = []\r\n        try:\r\n            # 使用正则表达式匹配修复建议块\r\n            rec_blocks = re.finditer(\r\n                r'问题[：:]\\s*(.+?)\\n.*?修复建议[：:]\\s*(.+?)\\n',\r\n                text,\r\n                re.DOTALL\r\n            )\r\n            \r\n            for block in rec_blocks:\r\n                recommendations.append({\r\n                    \"issue\": block.group(1).strip(),\r\n                    \"solution\": block.group(2).strip()\r\n                })\r\n                \r\n        except Exception:\r\n            pass\r\n        return recommendations\r\n\r\n    def _analyze_ast(self, content: str, file_path: str) -> List[Dict[str, Any]]:\r\n        \"\"\"分析AST结构\"\"\"\r\n        issues = []\r\n        try:\r\n            # 解析代码获取AST\r\n            ast = self._parse_code(content, file_path)\r\n            if not ast:\r\n                return []\r\n                \r\n            # 根据文件类型选择不同的访问器\r\n            ext = os.path.splitext(file_path)[1].lower()\r\n            if ext == '.php' or ext == '.blade.php':\r\n                visitor = PHPASTVisitor()\r\n            elif ext in ['.js', '.ts', '.tsx']:\r\n                visitor = TypeScriptASTVisitor()\r\n            else:\r\n                return []\r\n                \r\n            # 访问AST节点\r\n            issues.extend(visitor.visit(ast))\r\n            \r\n            # 添加文件信息\r\n            for issue in issues:\r\n                issue['file'] = file_path\r\n                \r\n            return issues\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"AST分析失败 {file_path}: {str(e)}\")\r\n            return []\r\n            \r\n    def _analyze_dataflow(self, content: str, file_path: str) -> List[Dict[str, Any]]:\r\n        \"\"\"数据流分析\"\"\"\r\n        issues = []\r\n        try:\r\n            # 获取文件类型\r\n            ext = os.path.splitext(file_path)[1].lower()\r\n            \r\n            # 根据文件类型进行不同的数据流分析\r\n            if ext == '.php' or ext == '.blade.php':\r\n                # 检查用户输入\r\n                issues.extend(self._check_user_input(content))\r\n                \r\n                # 检查数据库操作\r\n                issues.extend(self._check_database_operations(content))\r\n                \r\n                # 检查文件操作\r\n                issues.extend(self._check_file_operations(content))\r\n                \r\n            elif ext in ['.js', '.ts', '.tsx']:\r\n                # 检查DOM操作\r\n                issues.extend(self._check_dom_operations(content))\r\n                \r\n                # 检查AJAX调用\r\n                issues.extend(self._check_ajax_calls(content))\r\n                \r\n            # 添加文件信息\r\n            for issue in issues:\r\n                issue['file'] = file_path\r\n                \r\n            return issues\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"数据流分析失败 {file_path}: {str(e)}\")\r\n            return []\r\n            \r\n    def _merge_issues(self, *issue_lists: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\r\n        \"\"\"合并并去重问题列表\"\"\"\r\n        merged = []\r\n        try:\r\n            # 使用集合去重\r\n            seen = set()\r\n            \r\n            for issues in issue_lists:\r\n                for issue in issues:\r\n                    # 创建唯一标识\r\n                    key = (\r\n                        issue.get('type', ''),\r\n                        issue.get('line', 0),\r\n                        issue.get('description', ''),\r\n                        issue.get('file', '')\r\n                    )\r\n                    \r\n                    if key not in seen:\r\n                        seen.add(key)\r\n                        merged.append(issue)\r\n                        \r\n            return merged\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"合并问题失败: {str(e)}\")\r\n            return []\r\n            \r\n    def _has_sufficient_validation(self, node: Any, context: Dict) -> bool:\r\n        \"\"\"检查是否有足够的输入验证\"\"\"\r\n        try:\r\n            # 检查是否有输入验证\r\n            validation_funcs = {\r\n                'filter_var', 'filter_input', 'htmlspecialchars',\r\n                'strip_tags', 'addslashes', 'mysql_real_escape_string'\r\n            }\r\n            \r\n            # 检查前置验证\r\n            if not isinstance(context, dict):\r\n                return False\r\n            \r\n            if context.get('has_validation', False):\r\n                return True\r\n            \r\n            # 检查当前节点的验证\r\n            if isinstance(node, dict):\r\n                calls = self._find_function_calls(node)\r\n                for call in calls:\r\n                    if isinstance(call, dict) and call.get('name', '') in validation_funcs:\r\n                        return True\r\n            \r\n            return False\r\n        \r\n        except Exception as e:\r\n            logger.error(f\"检查输入验证失败: {str(e)}\")\r\n            return False\r\n\r\n    def _find_function_calls(self, node: Dict) -> List[Dict]:\r\n        \"\"\"查找函数调用\"\"\"\r\n        calls = []\r\n        try:\r\n            if isinstance(node, dict):\r\n                if node.get('type') == 'CallExpression':\r\n                    calls.append({\r\n                        'name': node.get('callee', {}).get('name', ''),\r\n                        'line': node.get('loc', {}).get('start', {}).get('line', 0)\r\n                    })\r\n                \r\n                # 递归查找子节点\r\n                for value in node.values():\r\n                    if isinstance(value, (dict, list)):\r\n                        calls.extend(self._find_function_calls(value))\r\n            \r\n            elif isinstance(node, list):\r\n                for item in node:\r\n                    calls.extend(self._find_function_calls(item))\r\n        \r\n        except Exception as e:\r\n            logger.error(f\"查找函数调用失败: {str(e)}\")\r\n        \r\n        return calls\r\n\r\n    def _check_user_input(self, content: str) -> List[Dict[str, Any]]:\r\n        \"\"\"检查用户输入\"\"\"\r\n        issues = []\r\n        try:\r\n            # 实现用户输入检查逻辑\r\n            # 这里可以根据需要实现不同的检查逻辑\r\n            return issues\r\n        except Exception as e:\r\n            logger.error(f\"检查用户输入失败: {str(e)}\")\r\n            return []\r\n\r\n    def _check_database_operations(self, content: str) -> List[Dict[str, Any]]:\r\n        \"\"\"检查数据库操作\"\"\"\r\n        issues = []\r\n        try:\r\n            # 实现数据库操作检查逻辑\r\n            # 这里可以根据需要实现不同的检查逻辑\r\n            return issues\r\n        except Exception as e:\r\n            logger.error(f\"检查数据库操作失败: {str(e)}\")\r\n            return []\r\n\r\n    def _check_file_operations(self, content: str) -> List[Dict[str, Any]]:\r\n        \"\"\"检查文件操作\"\"\"\r\n        issues = []\r\n        try:\r\n            # 实现文件操作检查逻辑\r\n            # 这里可以根据需要实现不同的检查逻辑\r\n            return issues\r\n        except Exception as e:\r\n            logger.error(f\"检查文件操作失败: {str(e)}\")\r\n            return []\r\n\r\n    def _check_dom_operations(self, content: str) -> List[Dict[str, Any]]:\r\n        \"\"\"检查DOM操作\"\"\"\r\n        issues = []\r\n        try:\r\n            # 实现DOM操作检查逻辑\r\n            # 这里可以根据需要实现不同的检查逻辑\r\n            return issues\r\n        except Exception as e:\r\n            logger.error(f\"检查DOM操作失败: {str(e)}\")\r\n            return []\r\n\r\n    def _check_ajax_calls(self, content: str) -> List[Dict[str, Any]]:\r\n        \"\"\"检查AJAX调用\"\"\"\r\n        issues = []\r\n        try:\r\n            # 实现AJAX调用检查逻辑\r\n            # 这里可以根据需要实现不同的检查逻辑\r\n            return issues\r\n        except Exception as e:\r\n            logger.error(f\"检查AJAX调用失败: {str(e)}\")\r\n            return []\r\n\r\n    def _is_test_code(self, file_path: str) -> bool:\r\n        \"\"\"检查是否为测试代码\"\"\"\r\n        try:\r\n            # 实现测试代码检查逻辑\r\n            # 这里可以根据需要实现不同的检查逻辑\r\n            return False\r\n        except Exception as e:\r\n            logger.error(f\"检查测试代码失败: {str(e)}\")\r\n            return False\r\n\r\n    def _is_infinite_loop(self, ast: Any) -> bool:\r\n        \"\"\"检查是否为无限循环\"\"\"\r\n        try:\r\n            # 实现无限循环检查逻辑\r\n            # 这里可以根据需要实现不同的检查逻辑\r\n            return False\r\n        except Exception as e:\r\n            logger.error(f\"检查无限循环失败: {str(e)}\")\r\n            return False\r\n\r\n    def _get_context_info(self, file_path: str) -> Dict:\r\n        \"\"\"获取文件上下文信息\"\"\"\r\n        try:\r\n            # 实现获取文件上下文信息的逻辑\r\n            # 这里可以根据需要实现不同的获取逻辑\r\n            return {}\r\n        except Exception as e:\r\n            logger.error(f\"获取文件上下文信息失败: {str(e)}\")\r\n            return {}\r\n\r\n    def _calculate_risk_level(self, suspicious_files: List[Dict[str, Any]]) -> str:\r\n        \"\"\"计算风险等级\"\"\"\r\n        try:\r\n            # 实现计算风险等级的逻辑\r\n            # 这里可以根据需要实现不同的计算逻辑\r\n            return \"unknown\"\r\n        except Exception as e:\r\n            logger.error(f\"计算风险等级失败: {str(e)}\")\r\n            return \"unknown\"\r\n\r\n    def _generate_recommendations(self, suspicious_files: List[Dict[str, Any]], results: Dict[str, Any]) -> List[Dict]:\r\n        \"\"\"生成推荐建议\"\"\"\r\n        try:\r\n            # 实现生成推荐建议的逻辑\r\n            # 这里可以根据需要实现不同的生成逻辑\r\n            return []\r\n        except Exception as e:\r\n            logger.error(f\"生成推荐建议失败: {str(e)}\")\r\n            return []\r\n\r\n    def _simple_php_check(self, content: str) -> List[Dict[str, Any]]:\r\n        \"\"\"简单的PHP代码检查\"\"\"\r\n        issues = []\r\n        try:\r\n            # 危险函数列表\r\n            dangerous_functions = [\r\n                'eval', 'exec', 'system', 'shell_exec', 'passthru',\r\n                'popen', 'proc_open', 'pcntl_exec', '`', 'assert'\r\n            ]\r\n            \r\n            # SQL注入风险函数\r\n            sql_functions = [\r\n                'mysql_query', 'mysqli_query', 'pg_query',\r\n                'sqlite_query', 'db_query'\r\n            ]\r\n            \r\n            # 文件操作风险函数\r\n            file_functions = [\r\n                'fopen', 'file_get_contents', 'file_put_contents',\r\n                'unlink', 'rmdir', 'mkdir', 'rename', 'copy'\r\n            ]\r\n            \r\n            # 按行检查代码\r\n            lines = content.split('\\n')\r\n            for i, line in enumerate(lines, 1):\r\n                # 检查危险函数\r\n                for func in dangerous_functions:\r\n                    if f\"{func}(\" in line:\r\n                        issues.append({\r\n                            'type': 'dangerous_function',\r\n                            'line': i,\r\n                            'description': f'发现危险函数: {func}',\r\n                            'severity': 'high'\r\n                        })\r\n                        \r\n                # 检查SQL注入风险\r\n                for func in sql_functions:\r\n                    if f\"{func}(\" in line and '$_' in line:\r\n                        issues.append({\r\n                            'type': 'sql_injection',\r\n                            'line': i,\r\n                            'description': f'可能的SQL注入风险: {func}',\r\n                            'severity': 'high'\r\n                        })\r\n                        \r\n                # 检查文件操作风险\r\n                for func in file_functions:\r\n                    if f\"{func}(\" in line and '$_' in line:\r\n                        issues.append({\r\n                            'type': 'file_operation',\r\n                            'line': i,\r\n                            'description': f'不安全的文件操作: {func}',\r\n                            'severity': 'medium'\r\n                        })\r\n                        \r\n            return issues\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"PHP代码检查失败: {str(e)}\")\r\n            return []\r\n            \r\n    def _simple_js_check(self, content: str) -> List[Dict[str, Any]]:\r\n        \"\"\"简单的JavaScript代码检查\"\"\"\r\n        issues = []\r\n        try:\r\n            # 危险函数列表\r\n            dangerous_functions = [\r\n                'eval', 'Function', 'setTimeout', 'setInterval',\r\n                'execScript', 'document.write'\r\n            ]\r\n            \r\n            # XSS风险函数\r\n            xss_functions = [\r\n                'innerHTML', 'outerHTML', 'insertAdjacentHTML',\r\n                'document.write', 'document.writeln'\r\n            ]\r\n            \r\n            # 按行检查代码\r\n            lines = content.split('\\n')\r\n            for i, line in enumerate(lines, 1):\r\n                # 检查危险函数\r\n                for func in dangerous_functions:\r\n                    if func in line:\r\n                        issues.append({\r\n                            'type': 'dangerous_function',\r\n                            'line': i,\r\n                            'description': f'发现危险函数: {func}',\r\n                            'severity': 'high'\r\n                        })\r\n                        \r\n                # 检查XSS风险\r\n                for func in xss_functions:\r\n                    if func in line:\r\n                        issues.append({\r\n                            'type': 'xss',\r\n                            'line': i,\r\n                            'description': f'可能的XSS风险: {func}',\r\n                            'severity': 'high'\r\n                        })\r\n                        \r\n            return issues\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"JavaScript代码检查失败: {str(e)}\")\r\n            return []\r\n            \r\n    def _simple_code_check(self, content: str) -> List[Dict[str, Any]]:\r\n        \"\"\"通用代码检查\"\"\"\r\n        issues = []\r\n        try:\r\n            # 通用危险模式\r\n            dangerous_patterns = [\r\n                (r'password\\s*=\\s*[\\'\"][^\\'\"]+[\\'\"]', '硬编码密码'),\r\n                (r'api[_-]?key\\s*=\\s*[\\'\"][^\\'\"]+[\\'\"]', '硬编码API密钥'),\r\n                (r'secret[_-]?key\\s*=\\s*[\\'\"][^\\'\"]+[\\'\"]', '硬编码密钥'),\r\n                (r'token\\s*=\\s*[\\'\"][^\\'\"]+[\\'\"]', '硬编码令牌')\r\n            ]\r\n            \r\n            # 按行检查代码\r\n            lines = content.split('\\n')\r\n            for i, line in enumerate(lines, 1):\r\n                # 检查危险模式\r\n                for pattern, desc in dangerous_patterns:\r\n                    if re.search(pattern, line, re.I):\r\n                        issues.append({\r\n                            'type': 'sensitive_data',\r\n                            'line': i,\r\n                            'description': f'发现敏感信息: {desc}',\r\n                            'severity': 'medium'\r\n                        })\r\n                        \r\n            return issues\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"通用代码检查失败: {str(e)}\")\r\n            return []\r\n\r\n    def _read_file_content(self, file_path: str) -> Optional[str]:\r\n        \"\"\"读取文件内容\"\"\"\r\n        try:\r\n            # 尝试使用UTF-8编码读取\r\n            try:\r\n                with open(file_path, 'r', encoding='utf-8') as f:\r\n                    content = f.read()\r\n                    if content:\r\n                        logger.debug(f\"成功读取文件(UTF-8): {file_path}\")\r\n                        return content\r\n            except UnicodeDecodeError:\r\n                # 如果UTF-8失败，尝试GBK编码\r\n                with open(file_path, 'r', encoding='gbk') as f:\r\n                    content = f.read()\r\n                    if content:\r\n                        logger.debug(f\"成功读取文件(GBK): {file_path}\")\r\n                        return content\r\n                        \r\n            logger.warning(f\"文件内容为空: {file_path}\")\r\n            return None\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"读取文件失败 {file_path}: {str(e)}\")\r\n            return None"}
{"type": "source_file", "path": "core/analyzers/__init__.py", "content": "from .core_analyzer import CoreAnalyzer\r\nfrom .taint_analyzer import TaintAnalyzer\r\nfrom .security_analyzer import SecurityAnalyzer\r\nfrom .framework_analyzer import FrameworkAnalyzer\r\nfrom .dependency_analyzer import DependencyAnalyzer\r\nfrom .config_analyzer import ConfigAnalyzer\r\n\r\n__all__ = [\r\n    'CoreAnalyzer',\r\n    'TaintAnalyzer',\r\n    'SecurityAnalyzer',\r\n    'FrameworkAnalyzer',\r\n    'DependencyAnalyzer',\r\n    'ConfigAnalyzer'\r\n] "}
{"type": "source_file", "path": "core/analyzers/context_analyzer.py", "content": "from code_analyzer import CodeAnalyzer\nfrom typing import Dict, Set, List, Any, Optional, Union\nfrom pathlib import Path\nfrom concurrent.futures import ThreadPoolExecutor\nimport logging\nfrom functools import lru_cache\nfrom tqdm import tqdm\nimport json\nfrom code_analyzer import AnalyzerConfig\n\nlogger = logging.getLogger(__name__)\n\nclass ContextAnalyzer:\n    def __init__(self, config: Optional[AnalyzerConfig] = None):\n        self.code_analyzer = CodeAnalyzer(config)\n        self._cache: Dict[str, bool] = {}  # 缓存分析结果\n        \n    def analyze_project_context(self, files: List[Union[str, Path]]) -> None:\n        \"\"\"分析项目整体上下文\n        \n        Args:\n            files: 要分析的文件路径列表\n            \n        Example:\n            analyzer = ContextAnalyzer()\n            analyzer.analyze_project_context(['file1.py', 'file2.py'])\n        \"\"\"\n        with ThreadPoolExecutor(max_workers=self.code_analyzer.config.max_workers) as executor:\n            list(tqdm(\n                executor.map(self._analyze_file_context, files),\n                total=len(files),\n                desc=\"分析项目文件\"\n            ))\n            \n    def _analyze_file_context(self, file_path: Union[str, Path]) -> None:\n        \"\"\"分析单个文件的上下文\"\"\"\n        try:\n            # 检查缓存\n            if file_path in self._cache:\n                return\n            \n            # 检查文件是否存在\n            if not Path(file_path).exists():\n                raise FileNotFoundError(f\"文件不存在: {file_path}\")\n            \n            # 检查文件是否是 Python 文件\n            if not str(file_path).endswith('.py'):\n                raise ValueError(f\"不是 Python 文件: {file_path}\")\n            \n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n            \n            self.code_analyzer.analyze_file(content, file_path)\n            self._cache[file_path] = True\n        \n        except (UnicodeDecodeError, FileNotFoundError, ValueError) as e:\n            logger.error(f\"分析文件失败 {file_path}: {str(e)}\")\n        except Exception as e:\n            logger.exception(f\"未知错误 {file_path}: {str(e)}\")\n        \n    @lru_cache(maxsize=128)\n    def get_call_graph(self, function_name: str) -> Dict[str, Any]:\n        \"\"\"获取函数调用图\n        \n        Args:\n            function_name: 要分析的函数名\n            \n        Returns:\n            包含函数调用关系的字典，格式为:\n            {\n                'name': 函数名,\n                'calls': 该函数调用的其他函数集合,\n                'called_by': 调用该函数的其他函数集合\n            }\n        \"\"\"\n        calls = self.code_analyzer.get_function_calls(function_name)\n        called_by = set()\n        \n        # 查找调用该函数的其他函数\n        for caller, callees in self.code_analyzer.function_calls.items():\n            if function_name in callees:\n                called_by.add(caller)\n                \n        return {\n            'name': function_name,\n            'calls': calls,\n            'called_by': called_by\n        }\n        \n    @lru_cache(maxsize=128)\n    def get_variable_scope(self, variable_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"获取变量作用域\"\"\"\n        # 在所有文件中查找该变量的定义\n        defined_in = set()\n        for file_path, globals_set in self.code_analyzer.globals.items():\n            if variable_name in globals_set:\n                defined_in.add(file_path)\n        \n        if defined_in:\n            # 获取变量的使用信息\n            usage_info = self._find_variable_usage(variable_name)\n            return {\n                'type': 'global',\n                'defined_in': list(defined_in),\n                'used_in': usage_info\n            }\n        return None\n\n    def _find_variable_usage(self, variable_name: str) -> Dict[str, Any]:\n        \"\"\"查找变量的使用位置\"\"\"\n        usages = self.code_analyzer.get_variable_usages(variable_name)\n        \n        # 将使用位置按文件分组\n        usage_by_file = {}\n        for usage in usages:\n            if ':' in usage:\n                file_path, function_name = usage.split(':', 1)\n                usage_by_file.setdefault(file_path, set()).add(function_name)\n            else:\n                # 模块级别的使用\n                usage_by_file.setdefault(usage, set()).add('module_level')\n        \n        return {\n            'files': list(usage_by_file.keys()),\n            'details': {\n                file_path: {\n                    'module_level': 'module_level' in functions,\n                    'functions': [f for f in functions if f != 'module_level']\n                }\n                for file_path, functions in usage_by_file.items()\n            }\n        }\n\n    def get_file_context(self, file_path: str) -> dict:\n        \"\"\"获取文件的完整上下文信息\"\"\"\n        return {\n            'code_analysis': self.code_analyzer.get_file_analysis(file_path)\n        }\n\n    def get_project_analysis(self) -> dict:\n        \"\"\"获取项目整体分析结果\"\"\"\n        return {\n            'all_dependencies': self.code_analyzer.dependencies,\n            'all_globals': self.code_analyzer.globals,\n            'function_call_graph': self.code_analyzer.function_calls,\n            'class_hierarchy_graph': self.code_analyzer.class_hierarchy,\n            'variable_usage_map': self.code_analyzer.variable_usages\n        }\n\n    def clear_cache(self):\n        \"\"\"清除缓存\"\"\"\n        self._cache.clear()\n\n    def validate_analysis(self) -> List[str]:\n        \"\"\"验证分析结果的完整性和一致性\n        \n        Returns:\n            发现的问题列表\n        \"\"\"\n        issues = []\n        \n        # 检查函数调用的一致性\n        for caller, callees in self.code_analyzer.function_calls.items():\n            if ':' not in caller:\n                issues.append(f\"无效的调用者格式: {caller}\")\n            \n        # 检查类继承的有效性\n        for class_name, bases in self.code_analyzer.class_hierarchy.items():\n            if ':' not in class_name:\n                issues.append(f\"无效的类名格式: {class_name}\")\n            \n        # 检查变量使用的有效性\n        for var_name, usages in self.code_analyzer.variable_usages.items():\n            for usage in usages:\n                if ':' not in usage and not usage.endswith('.py'):\n                    issues.append(f\"无效的变量使用位置: {usage}\")\n                \n        return issues \n\n    def clear_analysis(self) -> None:\n        \"\"\"清理所有分析结果\"\"\"\n        self._cache.clear()\n        self.code_analyzer.dependencies.clear()\n        self.code_analyzer.globals.clear()\n        self.code_analyzer.function_calls.clear()\n        self.code_analyzer.class_hierarchy.clear()\n        self.code_analyzer.variable_usages.clear()\n\n    def save_analysis(self, output_path: Union[str, Path]) -> None:\n        \"\"\"保存分析结果到文件\"\"\"\n        result = {\n            'dependencies': {k: list(v) for k, v in self.code_analyzer.dependencies.items()},\n            'globals': {k: list(v) for k, v in self.code_analyzer.globals.items()},\n            'function_calls': {k: list(v) for k, v in self.code_analyzer.function_calls.items()},\n            'class_hierarchy': self.code_analyzer.class_hierarchy,\n            'variable_usages': {k: list(v) for k, v in self.code_analyzer.variable_usages.items()}\n        }\n        \n        with open(output_path, 'w', encoding='utf-8') as f:\n            json.dump(result, f, indent=2)\n            \n    def load_analysis(self, input_path: Union[str, Path]) -> None:\n        \"\"\"从文件加载分析结果\"\"\"\n        with open(input_path, 'r', encoding='utf-8') as f:\n            data = json.load(f)\n            \n        self.code_analyzer.dependencies = {k: set(v) for k, v in data['dependencies'].items()}\n        self.code_analyzer.globals = {k: set(v) for k, v in data['globals'].items()}\n        self.code_analyzer.function_calls = {k: set(v) for k, v in data['function_calls'].items()}\n        self.code_analyzer.class_hierarchy = data['class_hierarchy']\n        self.code_analyzer.variable_usages = {k: set(v) for k, v in data['variable_usages'].items()} \n\n    def get_analysis_stats(self) -> Dict[str, Any]:\n        \"\"\"获取分析结果的统计信息\"\"\"\n        return {\n            'total_files': len(self.code_analyzer.dependencies),\n            'total_functions': len({\n                func.split(':')[1] \n                for func in self.code_analyzer.function_calls.keys()\n            }),\n            'total_classes': len(self.code_analyzer.class_hierarchy),\n            'total_globals': sum(len(vars) for vars in self.code_analyzer.globals.values()),\n            'dependencies_stats': {\n                'total': sum(len(deps) for deps in self.code_analyzer.dependencies.values()),\n                'by_file': {\n                    file: len(deps) \n                    for file, deps in self.code_analyzer.dependencies.items()\n                }\n            }\n        } "}
{"type": "source_file", "path": "core/analyzers/rules.py", "content": "SECURITY_RULES = {\r\n    'php': {\r\n        'dangerous_functions': [\r\n            {\r\n                'pattern': r'eval\\s*\\(',\r\n                'description': '使用eval()函数可能导致代码注入',\r\n                'severity': 'high',\r\n                'category': 'code_injection',\r\n                'cwe': 'CWE-95'\r\n            },\r\n            # ... 更多规则\r\n        ],\r\n        'sql_injection': [\r\n            {\r\n                'pattern': r'\\$_(?:GET|POST|REQUEST)\\s*\\[.*?\\].*?(?:SELECT|INSERT|UPDATE|DELETE)',\r\n                'description': '直接使用用户输入构造SQL语句',\r\n                'severity': 'high',\r\n                'category': 'sql_injection',\r\n                'cwe': 'CWE-89'\r\n            }\r\n        ],\r\n        # ... 更多类型\r\n    },\r\n    'python': {\r\n        'dangerous_functions': [\r\n            {\r\n                'pattern': r'subprocess\\.(?:call|Popen|run)',\r\n                'description': '使用subprocess可能导致命令注入',\r\n                'severity': 'high',\r\n                'category': 'command_injection',\r\n                'cwe': 'CWE-78'\r\n            }\r\n        ],\r\n        # ... 更多规则\r\n    }\r\n} "}
{"type": "source_file", "path": "core/analyzers/vulnerability_patterns.py", "content": "VULNERABILITY_PATTERNS = {\r\n    'sql_injection': {\r\n        'patterns': [\r\n            r'(?i)SELECT.*FROM.*WHERE.*=\\s*[\\'\"].*[\\'\"]\\s*\\+',\r\n            r'(?i)INSERT\\s+INTO.*VALUES.*\\+',\r\n            r'(?i)UPDATE.*SET.*=.*\\+',\r\n            r'(?i)DELETE\\s+FROM.*WHERE.*=.*\\+'\r\n        ],\r\n        'risk_level': 'high',\r\n        'description': 'SQL注入漏洞'\r\n    },\r\n    'xss': {\r\n        'patterns': [\r\n            r'(?i)innerHTML\\s*=',\r\n            r'(?i)document\\.write\\(',\r\n            r'(?i)eval\\(',\r\n            r'(?i)<script[^>]*>.*</script>'\r\n        ],\r\n        'risk_level': 'high',\r\n        'description': 'XSS跨站脚本漏洞'\r\n    },\r\n    # 添加更多漏洞特征...\r\n} "}
{"type": "source_file", "path": "core/analyzers/visitors.py", "content": "from typing import List, Dict, Any\r\nimport ast\r\nfrom phply.phpast import *\r\nimport esprima\r\n\r\nclass PHPASTVisitor:\r\n    def __init__(self):\r\n        self.issues = []\r\n        \r\n    def visit(self, nodes: List[Any]) -> None:\r\n        \"\"\"访问PHP AST节点\"\"\"\r\n        if not isinstance(nodes, list):\r\n            nodes = [nodes]\r\n            \r\n        for node in nodes:\r\n            if node is None:\r\n                continue\r\n            method = f'visit_{node.__class__.__name__}'\r\n            visitor = getattr(self, method, self.generic_visit)\r\n            visitor(node)\r\n        \r\n    def generic_visit(self, node: Any) -> None:\r\n        \"\"\"通用访问方法\"\"\"\r\n        for field in node.__dict__.values():\r\n            if isinstance(field, (list, tuple)):\r\n                for item in field:\r\n                    if hasattr(item, '__dict__'):\r\n                        self.visit(item)\r\n            elif hasattr(field, '__dict__'):\r\n                self.visit(field)\r\n                    \r\n    def visit_FunctionCall(self, node: FunctionCall) -> None:\r\n        \"\"\"访问函数调用\"\"\"\r\n        if isinstance(node.name, str):\r\n            func_name = node.name\r\n        elif hasattr(node.name, 'name'):\r\n            func_name = node.name.name\r\n        else:\r\n            func_name = str(node.name)\r\n            \r\n        if self._is_dangerous_function(func_name):\r\n            self.issues.append({\r\n                \"type\": \"dangerous_function\",\r\n                \"description\": f\"使用了危险函数 {func_name}\",\r\n                \"severity\": \"high\",\r\n                \"line\": node.lineno if hasattr(node, 'lineno') else None\r\n            })\r\n        self.generic_visit(node)\r\n        \r\n    def _is_dangerous_function(self, func_name: str) -> bool:\r\n        \"\"\"检查是否为危险函数\"\"\"\r\n        dangerous_functions = {\r\n            'eval', 'exec', 'system', 'shell_exec', 'passthru',\r\n            'file_get_contents', 'file_put_contents', 'fopen',\r\n            'mysql_query', 'mysqli_query'\r\n        }\r\n        return func_name in dangerous_functions\r\n\r\nclass TypeScriptASTVisitor:\r\n    def __init__(self):\r\n        self.issues = []\r\n        \r\n    def visit(self, node: esprima.nodes.Node) -> None:\r\n        \"\"\"访问TypeScript/JavaScript AST节点\"\"\"\r\n        if not node:\r\n            return\r\n            \r\n        method = f'visit_{node.type}'\r\n        visitor = getattr(self, method, self.generic_visit)\r\n        visitor(node)\r\n        \r\n        # 访问子节点\r\n        for key, value in node.__dict__.items():\r\n            if isinstance(value, list):\r\n                for item in value:\r\n                    if isinstance(item, esprima.nodes.Node):\r\n                        self.visit(item)\r\n            elif isinstance(value, esprima.nodes.Node):\r\n                self.visit(value)\r\n                \r\n    def visit_CallExpression(self, node: esprima.nodes.Node) -> None:\r\n        \"\"\"访问函数调用\"\"\"\r\n        func_name = self._get_function_name(node.callee)\r\n        if self._is_dangerous_function(func_name):\r\n            self.issues.append({\r\n                \"type\": \"dangerous_function\",\r\n                \"description\": f\"使用了危险函数 {func_name}\",\r\n                \"severity\": \"high\",\r\n                \"line\": node.loc.start.line if hasattr(node, 'loc') else None\r\n            })\r\n        \r\n    def _get_function_name(self, node: esprima.nodes.Node) -> str:\r\n        \"\"\"获取函数名\"\"\"\r\n        if node.type == 'Identifier':\r\n            return node.name\r\n        elif node.type == 'MemberExpression':\r\n            obj = self._get_function_name(node.object)\r\n            prop = node.property.name if hasattr(node.property, 'name') else str(node.property)\r\n            return f\"{obj}.{prop}\"\r\n        return \"unknown\"\r\n        \r\n    def _is_dangerous_function(self, func_name: str) -> bool:\r\n        \"\"\"检查是否为危险函数\"\"\"\r\n        dangerous_functions = {\r\n            'eval', 'Function', 'setTimeout', 'setInterval',\r\n            'document.write', 'innerHTML', 'execScript'\r\n        }\r\n        return func_name in dangerous_functions "}
{"type": "source_file", "path": "core/analyzers/framework_analyzer.py", "content": "class FrameworkAnalyzer:\r\n    def __init__(self):\r\n        self.framework_rules = {\r\n            'spring': {\r\n                'security_checks': {\r\n                    'csrf': [\r\n                        r'@EnableWebSecurity(?!.*csrf\\(\\)\\.disable\\(\\))',\r\n                        r'csrf\\(\\)\\.disable\\(\\)'\r\n                    ],\r\n                    'auth': [\r\n                        r'@PreAuthorize',\r\n                        r'@Secured',\r\n                        r'SecurityContextHolder'\r\n                    ],\r\n                    'cors': [\r\n                        r'@CrossOrigin\\(.*allowCredentials\\s*=\\s*true.*\\)',\r\n                        r'addCorsMappings\\('\r\n                    ]\r\n                },\r\n                'dangerous_configs': [\r\n                    r'security\\.basic\\.enabled\\s*=\\s*false',\r\n                    r'management\\.security\\.enabled\\s*=\\s*false'\r\n                ]\r\n            },\r\n            'django': {\r\n                'security_checks': {\r\n                    'csrf': [\r\n                        r'@csrf_exempt',\r\n                        r'CSRF_COOKIE_SECURE\\s*=\\s*False'\r\n                    ],\r\n                    'auth': [\r\n                        r'@login_required',\r\n                        r'@permission_required'\r\n                    ],\r\n                    'xss': [\r\n                        r'mark_safe\\(',\r\n                        r'safe\\s+filter'\r\n                    ]\r\n                },\r\n                'dangerous_configs': [\r\n                    r'DEBUG\\s*=\\s*True',\r\n                    r'ALLOWED_HOSTS\\s*=\\s*\\[\\s*\\'\\*\\'\\s*\\]'\r\n                ]\r\n            },\r\n            'express': {\r\n                'security_checks': {\r\n                    'helmet': [\r\n                        r'app\\.use\\(helmet\\(\\)\\)',\r\n                        r'app\\.use\\(cors\\(\\)\\)'\r\n                    ],\r\n                    'auth': [\r\n                        r'passport\\.authenticate',\r\n                        r'jwt\\.verify'\r\n                    ],\r\n                    'input': [\r\n                        r'body-parser',\r\n                        r'express-validator'\r\n                    ]\r\n                },\r\n                'dangerous_configs': [\r\n                    r'app\\.disable\\(.*trust\\s*proxy.*\\)',\r\n                    r'app\\.use\\(bodyParser\\.raw\\(\\)\\)'\r\n                ]\r\n            },\r\n            'hibernate': {\r\n                'security_checks': {\r\n                    'sql': [\r\n                        r'createQuery\\(.*\\+.*\\)',\r\n                        r'createSQLQuery\\(.*\\+.*\\)'\r\n                    ],\r\n                    'cache': [\r\n                        r'@Cache\\(',\r\n                        r'setCacheable\\('\r\n                    ],\r\n                    'validation': [\r\n                        r'@Valid',\r\n                        r'@Validated'\r\n                    ]\r\n                },\r\n                'dangerous_configs': [\r\n                    r'show_sql\\s*=\\s*true',\r\n                    r'hibernate\\.format_sql\\s*=\\s*true'\r\n                ]\r\n            }\r\n        }\r\n\r\n    def analyze_framework(self, code: str, framework: str) -> dict:\r\n        \"\"\"分析框架特定的安全问题\"\"\"\r\n        if framework not in self.framework_rules:\r\n            return {\"error\": f\"不支持的框架: {framework}\"}\r\n\r\n        issues = []\r\n        rules = self.framework_rules[framework]\r\n\r\n        # 检查安全配置\r\n        for check_type, patterns in rules['security_checks'].items():\r\n            for pattern in patterns:\r\n                matches = re.finditer(pattern, code)\r\n                for match in matches:\r\n                    issues.append({\r\n                        'type': f'{framework}_{check_type}_issue',\r\n                        'pattern': pattern,\r\n                        'location': self._get_location(code, match.start()),\r\n                        'description': self._get_issue_description(framework, check_type, pattern),\r\n                        'severity': self._calculate_severity(framework, check_type)\r\n                    })\r\n\r\n        # 检查危险配置\r\n        for pattern in rules['dangerous_configs']:\r\n            matches = re.finditer(pattern, code)\r\n            for match in matches:\r\n                issues.append({\r\n                    'type': f'{framework}_dangerous_config',\r\n                    'pattern': pattern,\r\n                    'location': self._get_location(code, match.start()),\r\n                    'description': f'发现危险的{framework}配置',\r\n                    'severity': 'high'\r\n                })\r\n\r\n        return {\r\n            'framework': framework,\r\n            'issues': issues,\r\n            'analysis_summary': self._generate_summary(issues)\r\n        }\r\n\r\n    def _get_location(self, code: str, pos: int) -> dict:\r\n        \"\"\"获取代码位置信息\"\"\"\r\n        lines = code[:pos].splitlines()\r\n        return {\r\n            'line': len(lines),\r\n            'column': len(lines[-1]) if lines else 0\r\n        }\r\n\r\n    def _calculate_severity(self, framework: str, check_type: str) -> str:\r\n        \"\"\"计算问题严重程度\"\"\"\r\n        high_severity = {\r\n            'spring': ['csrf', 'auth'],\r\n            'django': ['csrf', 'auth'],\r\n            'express': ['helmet', 'auth'],\r\n            'hibernate': ['sql']\r\n        }\r\n        \r\n        if framework in high_severity and check_type in high_severity[framework]:\r\n            return 'high'\r\n        return 'medium'\r\n\r\n    def _get_issue_description(self, framework: str, check_type: str, pattern: str) -> str:\r\n        \"\"\"获取问题描述\"\"\"\r\n        descriptions = {\r\n            'spring': {\r\n                'csrf': 'Spring Security CSRF 保护配置问题',\r\n                'auth': 'Spring Security 认证授权配置问题',\r\n                'cors': 'Spring CORS 配置可能存在安全风险'\r\n            },\r\n            'django': {\r\n                'csrf': 'Django CSRF 保护被禁用',\r\n                'auth': 'Django 认证装饰器使用不当',\r\n                'xss': 'Django XSS 防护被绕过'\r\n            },\r\n            'express': {\r\n                'helmet': 'Express 安全中间件配置问题',\r\n                'auth': 'Express 认证机制实现问题',\r\n                'input': 'Express 输入验证配置问题'\r\n            },\r\n            'hibernate': {\r\n                'sql': 'Hibernate SQL 注入风险',\r\n                'cache': 'Hibernate 缓存配置问题',\r\n                'validation': 'Hibernate 验证配置问题'\r\n            }\r\n        }\r\n        \r\n        return descriptions.get(framework, {}).get(check_type, '未知问题')\r\n\r\n    def _generate_summary(self, issues: list) -> str:\r\n        \"\"\"生成分析总结\"\"\"\r\n        if not issues:\r\n            return \"未发现框架相关的安全问题\"\r\n            \r\n        summary = \"框架安全分析总结:\\n\"\r\n        severity_count = {'high': 0, 'medium': 0, 'low': 0}\r\n        \r\n        for issue in issues:\r\n            severity_count[issue['severity']] += 1\r\n            \r\n        summary += f\"- 高危问题: {severity_count['high']} 个\\n\"\r\n        summary += f\"- 中危问题: {severity_count['medium']} 个\\n\"\r\n        summary += f\"- 低危问题: {severity_count['low']} 个\\n\"\r\n        \r\n        return summary "}
{"type": "source_file", "path": "core/analyzers/dataflow_analyzer.py", "content": "from typing import Dict, List, Set, Any\r\nfrom pathlib import Path\r\nimport ast\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass Variable:\r\n    def __init__(self, name: str, value=None, tainted=False):\r\n        self.name = name\r\n        self.value = value\r\n        self.tainted = tainted\r\n        self.sources = set()  # 变量来源\r\n        self.sinks = set()    # 变量去向\r\n        self.line_no = None   # 定义行号\r\n        self.references = []  # 引用位置\r\n\r\nclass DataFlowAnalyzer:\r\n    def __init__(self):\r\n        self.variables: Dict[str, Variable] = {}\r\n        self.taint_sources = {\r\n            'php': ['$_GET', '$_POST', '$_REQUEST', '$_COOKIE', '$_FILES'],\r\n            'python': ['request.form', 'request.args', 'request.files'],\r\n            'javascript': ['document.location', 'window.location', 'URL parameters']\r\n        }\r\n        self.sensitive_sinks = {\r\n            'php': {\r\n                'sql': ['mysql_query', 'mysqli_query', 'PDO::query'],\r\n                'command': ['exec', 'system', 'shell_exec', 'passthru'],\r\n                'file': ['file_get_contents', 'file_put_contents', 'fopen']\r\n            },\r\n            'python': {\r\n                'sql': ['execute', 'executemany', 'raw'],\r\n                'command': ['subprocess.run', 'os.system', 'os.popen'],\r\n                'file': ['open', 'read', 'write']\r\n            }\r\n        }\r\n\r\n    def analyze(self, content: str, file_path: str) -> List[Dict[str, Any]]:\r\n        \"\"\"执行数据流分析\"\"\"\r\n        issues = []\r\n        try:\r\n            # 1. 构建AST\r\n            tree = self._parse_code(content, file_path)\r\n            if not tree:\r\n                return []\r\n\r\n            # 2. 变量追踪\r\n            self._track_variables(tree)\r\n\r\n            # 3. 污点分析\r\n            taint_issues = self._taint_analysis()\r\n            issues.extend(taint_issues)\r\n\r\n            # 4. 变量传播分析\r\n            propagation_issues = self._analyze_propagation()\r\n            issues.extend(propagation_issues)\r\n\r\n            # 5. 上下文分析\r\n            context_issues = self._analyze_context(tree)\r\n            issues.extend(context_issues)\r\n\r\n            return issues\r\n\r\n        except Exception as e:\r\n            logger.error(f\"数据流分析失败 {file_path}: {str(e)}\")\r\n            return []\r\n\r\n    def _track_variables(self, tree: ast.AST) -> None:\r\n        \"\"\"追踪变量定义和使用\"\"\"\r\n        class VariableTracker(ast.NodeVisitor):\r\n            def __init__(self, analyzer):\r\n                self.analyzer = analyzer\r\n                self.scope_stack = []\r\n\r\n            def visit_Assign(self, node):\r\n                for target in node.targets:\r\n                    if isinstance(target, ast.Name):\r\n                        var = Variable(target.id)\r\n                        var.line_no = node.lineno\r\n                        # 分析赋值来源\r\n                        if isinstance(node.value, ast.Call):\r\n                            var.sources.add(self._get_call_source(node.value))\r\n                        self.analyzer.variables[target.id] = var\r\n                self.generic_visit(node)\r\n\r\n            def visit_Call(self, node):\r\n                # 记录函数调用中的变量使用\r\n                if isinstance(node.func, ast.Name):\r\n                    func_name = node.func.id\r\n                    for arg in node.args:\r\n                        if isinstance(arg, ast.Name) and arg.id in self.analyzer.variables:\r\n                            self.analyzer.variables[arg.id].sinks.add(func_name)\r\n                self.generic_visit(node)\r\n\r\n            def _get_call_source(self, node):\r\n                if isinstance(node.func, ast.Name):\r\n                    return node.func.id\r\n                elif isinstance(node.func, ast.Attribute):\r\n                    return f\"{self._get_call_source(node.func.value)}.{node.func.attr}\"\r\n                return \"unknown\"\r\n\r\n        tracker = VariableTracker(self)\r\n        tracker.visit(tree)\r\n\r\n    def _taint_analysis(self) -> List[Dict[str, Any]]:\r\n        \"\"\"执行污点分析\"\"\"\r\n        issues = []\r\n        for var_name, var in self.variables.items():\r\n            # 检查变量是否来自污点源\r\n            if self._is_from_taint_source(var):\r\n                var.tainted = True\r\n                # 检查是否流向敏感接收器\r\n                for sink in var.sinks:\r\n                    if self._is_sensitive_sink(sink):\r\n                        issues.append({\r\n                            \"type\": \"taint_flow\",\r\n                            \"description\": f\"污点数据从 {list(var.sources)} 流向敏感接收器 {sink}\",\r\n                            \"severity\": \"high\",\r\n                            \"line\": var.line_no,\r\n                            \"variable\": var_name,\r\n                            \"source\": list(var.sources),\r\n                            \"sink\": sink\r\n                        })\r\n        return issues\r\n\r\n    def _analyze_propagation(self) -> List[Dict[str, Any]]:\r\n        \"\"\"分析变量传播\"\"\"\r\n        issues = []\r\n        # 构建变量依赖图\r\n        dependency_graph = self._build_dependency_graph()\r\n        # 分析变量传播链\r\n        for var_name in self.variables:\r\n            propagation_chain = self._get_propagation_chain(var_name, dependency_graph)\r\n            if len(propagation_chain) > 1:  # 存在传播链\r\n                if any(self._is_from_taint_source(self.variables[v]) for v in propagation_chain):\r\n                    issues.append({\r\n                        \"type\": \"variable_propagation\",\r\n                        \"description\": f\"发现污点数据传播链: {' -> '.join(propagation_chain)}\",\r\n                        \"severity\": \"medium\",\r\n                        \"propagation_chain\": propagation_chain\r\n                    })\r\n        return issues\r\n\r\n    def _analyze_context(self, tree: ast.AST) -> List[Dict[str, Any]]:\r\n        \"\"\"分析代码上下文\"\"\"\r\n        issues = []\r\n        # 分析异常处理\r\n        exception_issues = self._analyze_exception_handling(tree)\r\n        issues.extend(exception_issues)\r\n        # 分析条件判断\r\n        condition_issues = self._analyze_conditions(tree)\r\n        issues.extend(condition_issues)\r\n        # 分析循环结构\r\n        loop_issues = self._analyze_loops(tree)\r\n        issues.extend(loop_issues)\r\n        return issues\r\n\r\n    def _is_from_taint_source(self, var: Variable) -> bool:\r\n        \"\"\"检查变量是否来自污点源\"\"\"\r\n        return any(source in self.taint_sources.get(self.language, []) \r\n                  for source in var.sources)\r\n\r\n    def _is_sensitive_sink(self, sink: str) -> bool:\r\n        \"\"\"检查是否为敏感接收器\"\"\"\r\n        for category in self.sensitive_sinks.get(self.language, {}):\r\n            if sink in self.sensitive_sinks[self.language][category]:\r\n                return True\r\n        return False\r\n\r\n    def _build_dependency_graph(self) -> Dict[str, Set[str]]:\r\n        \"\"\"构建变量依赖图\"\"\"\r\n        graph = {}\r\n        for var_name, var in self.variables.items():\r\n            graph[var_name] = set()\r\n            for ref in var.references:\r\n                if isinstance(ref, ast.Name) and ref.id in self.variables:\r\n                    graph[var_name].add(ref.id)\r\n        return graph\r\n\r\n    def _get_propagation_chain(self, start: str, graph: Dict[str, Set[str]], \r\n                             visited: Set[str] = None) -> List[str]:\r\n        \"\"\"获取变量传播链\"\"\"\r\n        if visited is None:\r\n            visited = set()\r\n        if start in visited:\r\n            return []\r\n        visited.add(start)\r\n        chain = [start]\r\n        for next_var in graph.get(start, set()):\r\n            if next_var not in visited:\r\n                sub_chain = self._get_propagation_chain(next_var, graph, visited)\r\n                if sub_chain:\r\n                    chain.extend(sub_chain)\r\n        return chain "}
{"type": "source_file", "path": "core/analyzers/taint_analyzer.py", "content": "import re\r\n\r\nclass TaintAnalyzer:\r\n    def __init__(self):\r\n        self.sources = set([\r\n            'GET', 'POST', 'REQUEST', 'FILES', 'COOKIE',\r\n            'file_get_contents', 'fgets', 'fread',\r\n            'stdin', '$_SERVER', '$_ENV', 'getenv',\r\n            'mysqli_query', 'mysql_query', 'PDO->query',\r\n            'curl_exec', 'file', 'readfile', 'unserialize'\r\n        ])\r\n        self.sinks = set([\r\n            'eval', 'exec', 'system', 'shell_exec',\r\n            'passthru', 'popen', 'proc_open',\r\n            'include', 'include_once', 'require', 'require_once',\r\n            'mysqli_query', 'mysql_query', 'PDO->query',\r\n            'echo', 'print', 'printf',\r\n            'header',\r\n            'file_put_contents', 'fwrite',\r\n            'unserialize',\r\n            'mail'\r\n        ])\r\n        self.sanitizers = set([\r\n            'htmlspecialchars', 'htmlentities', 'strip_tags',\r\n            'addslashes', 'escapeshellarg', 'escapeshellcmd'\r\n        ])\r\n        self.vulnerability_types = {\r\n            'rce': ['eval', 'exec', 'system', 'shell_exec'],\r\n            'sqli': ['mysqli_query', 'mysql_query', 'PDO->query'],\r\n            'xss': ['echo', 'print', 'printf'],\r\n            'file_inclusion': ['include', 'include_once', 'require'],\r\n            'file_operation': ['file_put_contents', 'fwrite'],\r\n            'deserialization': ['unserialize'],\r\n            'header_injection': ['header', 'mail']\r\n        }\r\n        \r\n        # 添加变量追踪映射\r\n        self.variable_mapping = {}\r\n        \r\n        # 添加函数调用栈\r\n        self.call_stack = []\r\n        \r\n        # 添加更多的漏洞模式\r\n        self.vulnerability_patterns = {\r\n            'sql_injection': {\r\n                'risk_functions': ['query', 'execute'],\r\n                'safe_patterns': [r'\\?|:[a-zA-Z_][a-zA-Z0-9_]*'],  # 参数化查询模式\r\n                'risk_patterns': [r\".*\\+.*'.*|.*'.*\\+.*\"]  # 字符串拼接模式\r\n            },\r\n            'xss': {\r\n                'risk_functions': ['echo', 'print'],\r\n                'safe_patterns': [r'htmlspecialchars\\(.*\\)|htmlentities\\(.*\\)'],\r\n                'risk_patterns': [r'<.*>|javascript:']\r\n            },\r\n            'path_traversal': {\r\n                'risk_functions': ['file_get_contents', 'fopen'],\r\n                'risk_patterns': [r'\\.\\.\\/|\\.\\.\\\\']\r\n            }\r\n        }\r\n        \r\n        # 添加更细粒度的漏洞检测规则\r\n        self.detection_rules = {\r\n            'java': {\r\n                'sql_injection': {\r\n                    'patterns': [\r\n                        r'.*Statement\\.executeQuery\\(.*\\+.*\\)',\r\n                        r'.*Statement\\.execute\\(.*\\+.*\\)',\r\n                        r'.*PreparedStatement.*\\+.*\\)'\r\n                    ],\r\n                    'safe_patterns': [\r\n                        r'PreparedStatement.*\\?.*\\)',\r\n                        r'.*createQuery\\(.*:.*\\)'\r\n                    ]\r\n                },\r\n                'command_injection': {\r\n                    'patterns': [\r\n                        r'Runtime\\.exec\\(.*\\+.*\\)',\r\n                        r'ProcessBuilder.*\\+.*\\)',\r\n                    ],\r\n                    'safe_patterns': [\r\n                        r'Runtime\\.exec\\(new String\\[\\].*\\)'\r\n                    ]\r\n                },\r\n                'xxe': {\r\n                    'patterns': [\r\n                        r'DocumentBuilder.*parse\\(',\r\n                        r'SAXParser.*parse\\(',\r\n                        r'XMLReader.*parse\\('\r\n                    ],\r\n                    'safe_patterns': [\r\n                        r'setFeature\\(.*XMLConstants\\.FEATURE_SECURE_PROCESSING.*true\\)'\r\n                    ]\r\n                }\r\n            }\r\n        }\r\n        \r\n        # 添加框架特定的漏洞模式\r\n        self.framework_patterns = {\r\n            'spring': {\r\n                'unsafe_redirects': [\r\n                    r'redirect:.*\\+',\r\n                    r'sendRedirect\\(.*\\+.*\\)'\r\n                ],\r\n                'csrf_vulnerable': [\r\n                    r'@CrossOrigin\\(.*allowCredentials\\s*=\\s*true.*\\)',\r\n                    r'@RequestMapping.*method\\s*=\\s*RequestMethod\\.POST.*(?!@CrossOrigin)'\r\n                ]\r\n            },\r\n            'hibernate': {\r\n                'hql_injection': [\r\n                    r'createQuery\\(.*\\+.*\\)',\r\n                    r'createSQLQuery\\(.*\\+.*\\)'\r\n                ]\r\n            }\r\n        }\r\n        \r\n        # 添加 Python 相关的检测规则\r\n        self.detection_rules['python'] = {\r\n            'command_injection': {\r\n                'patterns': [\r\n                    r'os\\.system\\(.*\\+.*\\)',\r\n                    r'subprocess\\.call\\(.*\\+.*\\)',\r\n                    r'subprocess\\.Popen\\(.*\\+.*\\)',\r\n                    r'eval\\(.*\\+.*\\)',\r\n                    r'exec\\(.*\\+.*\\)'\r\n                ],\r\n                'safe_patterns': [\r\n                    r'subprocess\\.run\\([^,]+,\\s*shell\\s*=\\s*False\\)',\r\n                    r'shlex\\.quote\\(.*\\)'\r\n                ]\r\n            },\r\n            'sql_injection': {\r\n                'patterns': [\r\n                    r'execute\\(.*\\+.*\\)',\r\n                    r'executemany\\(.*\\+.*\\)',\r\n                    r'raw\\(.*\\+.*\\)',\r\n                    r'\\.format\\(.*\\)'\r\n                ],\r\n                'safe_patterns': [\r\n                    r'execute\\([^,]+,\\s*\\(.*\\)\\)',\r\n                    r'execute\\([^,]+,\\s*\\[.*\\]\\)'\r\n                ]\r\n            },\r\n            'path_traversal': {\r\n                'patterns': [\r\n                    r'open\\(.*\\+.*\\)',\r\n                    r'os\\.path\\.join\\(.*\\+.*\\)',\r\n                    r'__import__\\(.*\\+.*\\)'\r\n                ],\r\n                'safe_patterns': [\r\n                    r'os\\.path\\.abspath\\(.*\\)',\r\n                    r'os\\.path\\.realpath\\(.*\\)'\r\n                ]\r\n            },\r\n            'deserialization': {\r\n                'patterns': [\r\n                    r'pickle\\.loads\\(',\r\n                    r'yaml\\.load\\(',\r\n                    r'marshal\\.loads\\('\r\n                ],\r\n                'safe_patterns': [\r\n                    r'yaml\\.safe_load\\(',\r\n                    r'json\\.loads\\('\r\n                ]\r\n            }\r\n        }\r\n\r\n        # 添加 JavaScript 相关的检测规则\r\n        self.detection_rules['javascript'] = {\r\n            'xss': {\r\n                'patterns': [\r\n                    r'innerHTML\\s*=',\r\n                    r'outerHTML\\s*=',\r\n                    r'document\\.write\\(',\r\n                    r'eval\\(',\r\n                    r'\\$\\(.*\\)\\.html\\('\r\n                ],\r\n                'safe_patterns': [\r\n                    r'textContent\\s*=',\r\n                    r'innerText\\s*=',\r\n                    r'createElement\\('\r\n                ]\r\n            },\r\n            'dom_xss': {\r\n                'patterns': [\r\n                    r'location\\s*=',\r\n                    r'location\\.href\\s*=',\r\n                    r'location\\.search',\r\n                    r'location\\.hash'\r\n                ],\r\n                'safe_patterns': [\r\n                    r'encodeURIComponent\\(',\r\n                    r'encodeURI\\('\r\n                ]\r\n            },\r\n            'prototype_pollution': {\r\n                'patterns': [\r\n                    r'Object\\.assign\\(',\r\n                    r'Object\\.prototype',\r\n                    r'\\.__proto__',\r\n                    r'\\.constructor\\.prototype'\r\n                ]\r\n            },\r\n            'insecure_randomness': {\r\n                'patterns': [\r\n                    r'Math\\.random\\(',\r\n                ],\r\n                'safe_patterns': [\r\n                    r'crypto\\.getRandomValues\\(',\r\n                    r'window\\.crypto\\.subtle'\r\n                ]\r\n            }\r\n        }\r\n\r\n        # 添加框架特定的检测规则\r\n        self.framework_patterns['django'] = {\r\n            'csrf_vulnerable': [\r\n                r'@csrf_exempt',\r\n                r'CSRF_COOKIE_SECURE\\s*=\\s*False'\r\n            ],\r\n            'sql_injection_risk': [\r\n                r'raw\\(',\r\n                r'extra\\(',\r\n                r'RawSQL\\('\r\n            ]\r\n        }\r\n\r\n        self.framework_patterns['express'] = {\r\n            'nosql_injection': [\r\n                r'findOne\\(.*\\+.*\\)',\r\n                r'find\\(.*\\+.*\\)',\r\n                r'update\\(.*\\+.*\\)'\r\n            ],\r\n            'security_misconfiguration': [\r\n                r'app\\.disable\\(.*trust\\s*proxy.*\\)',\r\n                r'app\\.use\\(bodyParser\\.raw\\(\\)\\)'\r\n            ]\r\n        }\r\n    \r\n    def analyze(self, ast_tree):\r\n        \"\"\"\r\n        执行污点分析\r\n        \"\"\"\r\n        vulnerabilities = []\r\n        \r\n        # 遍历AST寻找污点传播路径\r\n        for node in ast_tree.traverse():\r\n            if self._is_source(node):\r\n                taint = self._track_taint(node)\r\n                if taint:\r\n                    vulnerabilities.append(taint)\r\n                    \r\n        return vulnerabilities\r\n    \r\n    def _is_source(self, node):\r\n        \"\"\"检查节点是否为污点源\"\"\"\r\n        # 实现基本的污点源检查\r\n        if hasattr(node, 'name'):\r\n            return str(node.name) in self.sources\r\n        return False\r\n\r\n    def _track_taint(self, node):\r\n        \"\"\"增强的污点追踪\"\"\"\r\n        if not node:\r\n            return None\r\n            \r\n        vulnerabilities = []\r\n        visited = set()\r\n        \r\n        def track_recursive(current_node, taint_chain=None, context=None):\r\n            if not current_node or id(current_node) in visited:\r\n                return\r\n                \r\n            visited.add(id(current_node))\r\n            taint_chain = taint_chain or []\r\n            context = context or {}\r\n            \r\n            # 记录变量赋值\r\n            if self._is_assignment(current_node):\r\n                self._track_variable_assignment(current_node)\r\n            \r\n            # 函数调用分析\r\n            if self._is_function_call(current_node):\r\n                self._analyze_function_call(current_node, context)\r\n            \r\n            # 条件语句分析\r\n            if self._is_condition(current_node):\r\n                self._analyze_condition_branch(current_node, context)\r\n            \r\n            # 检查是否经过安全的过滤\r\n            if self._is_sanitized(current_node, context):\r\n                context['sanitized'] = True\r\n                return\r\n            \r\n            # 检查漏洞模式\r\n            vuln = self._check_vulnerability_patterns(current_node, context)\r\n            if vuln:\r\n                vulnerabilities.append(vuln)\r\n            \r\n            # 递归分析\r\n            for child in self._get_node_children(current_node):\r\n                track_recursive(child, taint_chain + [current_node], context.copy())\r\n        \r\n        track_recursive(node)\r\n        return vulnerabilities\r\n\r\n    def _calculate_severity(self, vuln_type):\r\n        \"\"\"计算漏洞严重程度\"\"\"\r\n        severity_map = {\r\n            'rce': 'critical',\r\n            'sqli': 'high',\r\n            'xss': 'medium',\r\n            'file_inclusion': 'high',\r\n            'file_operation': 'medium',\r\n            'deserialization': 'high',\r\n            'header_injection': 'medium'\r\n        }\r\n        return severity_map.get(vuln_type, 'low')\r\n\r\n    def _get_vulnerability_type(self, node):\r\n        \"\"\"确定漏洞类型\"\"\"\r\n        if hasattr(node, 'name'):\r\n            node_name = str(node.name)\r\n            for vuln_type, sinks in self.vulnerability_types.items():\r\n                if node_name in sinks:\r\n                    return vuln_type\r\n        return 'unknown'\r\n\r\n    def _extract_context(self, node):\r\n        \"\"\"提取漏洞上下文\"\"\"\r\n        context = {\r\n            'code_snippet': self._get_code_snippet(node),\r\n            'variables': self._get_related_variables(node),\r\n            'function_scope': self._get_function_scope(node)\r\n        }\r\n        return context\r\n        \r\n    def _is_sink(self, node):\r\n        \"\"\"检查节点是否为危险函数\"\"\"\r\n        if hasattr(node, 'name'):\r\n            return str(node.name) in self.sinks\r\n        return False\r\n\r\n    def _analyze_function_call(self, node, context):\r\n        \"\"\"分析函数调用的安全性\"\"\"\r\n        if not hasattr(node, 'name'):\r\n            return\r\n            \r\n        func_name = str(node.name)\r\n        \r\n        # 检查是否是高风险函数\r\n        for vuln_type, patterns in self.vulnerability_patterns.items():\r\n            if func_name in patterns['risk_functions']:\r\n                # 分析函数参数\r\n                args = self._get_function_args(node)\r\n                for arg in args:\r\n                    if self._is_tainted(arg, context):\r\n                        # 检查是否使用了安全的编码/过滤方式\r\n                        if not self._has_safe_encoding(arg, patterns['safe_patterns']):\r\n                            context['risks'].append({\r\n                                'type': vuln_type,\r\n                                'function': func_name,\r\n                                'argument': str(arg)\r\n                            })\r\n\r\n    def _track_variable_assignment(self, node):\r\n        \"\"\"追踪变量赋值\"\"\"\r\n        if hasattr(node, 'target') and hasattr(node, 'value'):\r\n            var_name = str(node.target)\r\n            self.variable_mapping[var_name] = {\r\n                'value': str(node.value),\r\n                'tainted': self._is_tainted(node.value),\r\n                'sanitized': self._is_sanitized(node.value),\r\n                'location': self._get_node_location(node)\r\n            }\r\n\r\n    def _analyze_condition_branch(self, node, context):\r\n        \"\"\"分析条件分支中的安全检查\"\"\"\r\n        if hasattr(node, 'test'):\r\n            # 检查是否包含安全验证\r\n            if self._has_security_check(node.test):\r\n                context['security_checked'] = True\r\n            \r\n            # 检查是否有风险的条件判断\r\n            if self._has_risky_condition(node.test):\r\n                context['risks'].append({\r\n                    'type': 'unsafe_condition',\r\n                    'condition': str(node.test),\r\n                    'location': self._get_node_location(node)\r\n                })\r\n\r\n    def _has_security_check(self, node):\r\n        \"\"\"检查是否包含安全验证\"\"\"\r\n        security_patterns = [\r\n            r'validate|verify|check|auth|permission',\r\n            r'is[A-Z]|has[A-Z]',\r\n            r'sanitize|escape|encode'\r\n        ]\r\n        node_str = str(node)\r\n        return any(re.search(pattern, node_str, re.I) for pattern in security_patterns)\r\n\r\n    def _get_data_flow_path(self, node):\r\n        \"\"\"获取数据流路径\"\"\"\r\n        path = []\r\n        current = node\r\n        while current and hasattr(current, 'parent'):\r\n            path.append({\r\n                'type': type(current).__name__,\r\n                'value': str(current),\r\n                'location': self._get_node_location(current)\r\n            })\r\n            current = current.parent\r\n        return path[::-1]\r\n\r\n    def _analyze_framework_specific(self, node, context):\r\n        \"\"\"分析框架特定的安全问题\"\"\"\r\n        framework = self._detect_framework(context)\r\n        if framework and framework in self.framework_patterns:\r\n            patterns = self.framework_patterns[framework]\r\n            for vuln_type, rules in patterns.items():\r\n                if self._match_patterns(str(node), rules):\r\n                    return {\r\n                        'type': vuln_type,\r\n                        'framework': framework,\r\n                        'location': self._get_node_location(node),\r\n                        'severity': 'high',\r\n                        'description': f'发现{framework}框架相关的{vuln_type}漏洞'\r\n                    }\r\n        return None\r\n\r\n    def _analyze_data_validation(self, node):\r\n        \"\"\"分析数据验证逻辑\"\"\"\r\n        validation_info = {\r\n            'has_validation': False,\r\n            'validation_type': None,\r\n            'validation_coverage': 0.0\r\n        }\r\n        \r\n        # 检查是否使用了验证注解\r\n        if self._has_validation_annotations(node):\r\n            validation_info['has_validation'] = True\r\n            validation_info['validation_type'] = 'annotation'\r\n            \r\n        # 检查是否有手动验证代码\r\n        elif self._has_manual_validation(node):\r\n            validation_info['has_validation'] = True\r\n            validation_info['validation_type'] = 'manual'\r\n            \r\n        # 计算验证覆盖率\r\n        validation_info['validation_coverage'] = self._calculate_validation_coverage(node)\r\n        \r\n        return validation_info\r\n\r\n    def _analyze_authentication(self, node, context):\r\n        \"\"\"分析认证相关的安全问题\"\"\"\r\n        auth_issues = []\r\n        \r\n        # 检查认证绕过\r\n        if self._check_auth_bypass(node):\r\n            auth_issues.append({\r\n                'type': 'auth_bypass',\r\n                'severity': 'critical',\r\n                'location': self._get_node_location(node)\r\n            })\r\n            \r\n        # 检查权限检查\r\n        if not self._has_permission_check(node):\r\n            auth_issues.append({\r\n                'type': 'missing_permission_check',\r\n                'severity': 'high',\r\n                'location': self._get_node_location(node)\r\n            })\r\n            \r\n        return auth_issues\r\n\r\n    def _analyze_secure_configuration(self, node):\r\n        \"\"\"分析安全配置\"\"\"\r\n        config_issues = []\r\n        \r\n        # 检查安全标头配置\r\n        if not self._has_security_headers(node):\r\n            config_issues.append({\r\n                'type': 'missing_security_headers',\r\n                'severity': 'medium'\r\n            })\r\n            \r\n        # 检查安全cookie配置\r\n        if not self._has_secure_cookie_config(node):\r\n            config_issues.append({\r\n                'type': 'insecure_cookie_config',\r\n                'severity': 'medium'\r\n            })\r\n            \r\n        return config_issues\r\n\r\n    def _analyze_language_specific(self, node, language):\r\n        \"\"\"基于语言特性的分析\"\"\"\r\n        if language not in self.detection_rules:\r\n            return None\r\n            \r\n        rules = self.detection_rules[language]\r\n        node_str = str(node)\r\n        \r\n        for vuln_type, patterns in rules.items():\r\n            # 检查危险模式\r\n            if 'patterns' in patterns:\r\n                for pattern in patterns['patterns']:\r\n                    if re.search(pattern, node_str):\r\n                        # 检查是否有安全模式\r\n                        if 'safe_patterns' in patterns:\r\n                            if any(re.search(safe_pattern, node_str) \r\n                                  for safe_pattern in patterns['safe_patterns']):\r\n                                continue\r\n                                \r\n                        return {\r\n                            'type': vuln_type,\r\n                            'language': language,\r\n                            'location': self._get_node_location(node),\r\n                            'code': node_str,\r\n                            'severity': self._calculate_severity(vuln_type),\r\n                            'description': f'发现{language}代码中的{vuln_type}漏洞'\r\n                        }\r\n        return None\r\n\r\n    def _check_js_specific_issues(self, node):\r\n        \"\"\"检查JavaScript特有的安全问题\"\"\"\r\n        issues = []\r\n        \r\n        # 检查不安全的第三方脚本引用\r\n        if self._is_script_tag(node):\r\n            if not self._has_integrity_check(node):\r\n                issues.append({\r\n                    'type': 'insecure_script_include',\r\n                    'severity': 'medium',\r\n                    'location': self._get_node_location(node),\r\n                    'recommendation': '添加 SRI (Subresource Integrity) 校验'\r\n                })\r\n                \r\n        # 检查敏感信息泄露\r\n        if self._contains_sensitive_data(node):\r\n            issues.append({\r\n                'type': 'sensitive_data_exposure',\r\n                'severity': 'high',\r\n                'location': self._get_node_location(node),\r\n                'recommendation': '避免在前端代码中硬编码敏感信息'\r\n            })\r\n            \r\n        return issues\r\n\r\n    def _check_python_specific_issues(self, node):\r\n        \"\"\"检查Python特有的安全问题\"\"\"\r\n        issues = []\r\n        \r\n        # 检查不安全的模块导入\r\n        if self._is_import(node):\r\n            if self._is_dangerous_import(node):\r\n                issues.append({\r\n                    'type': 'dangerous_import',\r\n                    'severity': 'medium',\r\n                    'location': self._get_node_location(node),\r\n                    'recommendation': '谨慎使用潜在危险的模块'\r\n                })\r\n                \r\n        # 检查调试配置\r\n        if self._is_debug_config(node):\r\n            issues.append({\r\n                'type': 'debug_enabled',\r\n                'severity': 'medium',\r\n                'location': self._get_node_location(node),\r\n                'recommendation': '在生产环境中禁用调试模式'\r\n            })\r\n            \r\n        return issues "}
{"type": "source_file", "path": "core/analyzers/parsers.py", "content": "from typing import Any, Optional, List, Dict\r\nimport logging\r\nfrom pathlib import Path\r\nimport ast\r\nimport re\r\nfrom phply import phplex, phpparse\r\nimport esprima\r\nimport os\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass CodeParser:\r\n    def __init__(self):\r\n        # 添加更多的检查规则\r\n        self.php_dangerous_patterns = {\r\n            'dangerous_functions': [\r\n                'eval', 'exec', 'system', 'shell_exec', 'passthru',\r\n                'popen', 'proc_open', 'pcntl_exec', '`', 'assert'\r\n            ],\r\n            'sql_functions': [\r\n                'mysql_query', 'mysqli_query', 'pg_query',\r\n                'sqlite_query', 'db_query'\r\n            ],\r\n            'file_operations': [\r\n                'fopen', 'file_get_contents', 'file_put_contents',\r\n                'unlink', 'rmdir', 'mkdir', 'rename', 'copy'\r\n            ],\r\n            'weak_crypto': [\r\n                'md5(', 'sha1(', 'mcrypt_', 'base64_encode('\r\n            ],\r\n            'insecure_configs': [\r\n                'display_errors = On',\r\n                'allow_url_fopen = On',\r\n                'allow_url_include = On'\r\n            ],\r\n            'xss_vulnerable': [\r\n                'echo $_', 'print $_', 'printf $_',\r\n                'echo htmlspecialchars($_', 'print htmlspecialchars($_'\r\n            ]\r\n        }\r\n        \r\n        self.js_dangerous_patterns = {\r\n            'dangerous_functions': [\r\n                'eval(', 'Function(', 'setTimeout(', 'setInterval(',\r\n                'execScript(', 'document.write('\r\n            ],\r\n            'xss_functions': [\r\n                'innerHTML', 'outerHTML', 'insertAdjacentHTML',\r\n                'document.write', 'document.writeln'\r\n            ],\r\n            'weak_crypto': [\r\n                'Math.random()', 'crypto.getRandomValues('\r\n            ],\r\n            'sensitive_data': [\r\n                'localStorage.setItem(', 'sessionStorage.setItem('\r\n            ]\r\n        }\r\n        \r\n    def parse(self, content: str, file_path: str) -> Optional[Dict]:\r\n        \"\"\"根据文件类型选择合适的解析器\"\"\"\r\n        try:\r\n            if not isinstance(file_path, (str, Path)):\r\n                logger.error(f\"无效的文件路径类型: {type(file_path)}\")\r\n                return None\r\n            \r\n            file_path = str(file_path)\r\n            ext = os.path.splitext(file_path)[1].lower()\r\n            if not ext:\r\n                return None\r\n                \r\n            # 根据扩展名选择解析器\r\n            if ext == '.php' or ext == '.blade.php':\r\n                ast_result = self.parse_php(content)\r\n                if ast_result:\r\n                    return {\r\n                        'type': 'php',\r\n                        'ast': ast_result,\r\n                        'content': content,\r\n                        'file_path': file_path,\r\n                        'suffix': ext\r\n                    }\r\n            elif ext == '.py':\r\n                ast_result = self.parse_python(content)\r\n                if ast_result:\r\n                    return {\r\n                        'type': 'python',\r\n                        'ast': ast_result,\r\n                        'content': content,\r\n                        'file_path': file_path,\r\n                        'suffix': ext\r\n                    }\r\n            elif ext in ['.js', '.ts', '.tsx']:\r\n                ast_result = self.parse_typescript(content)\r\n                if ast_result:\r\n                    return {\r\n                        'type': 'javascript',\r\n                        'ast': ast_result,\r\n                        'content': content,\r\n                        'file_path': file_path,\r\n                        'suffix': ext\r\n                    }\r\n            \r\n            # 确保所有必要字段都有默认值\r\n            result = self._create_empty_result()\r\n            result.update({\r\n                'content': content,\r\n                'file_path': file_path,\r\n                'suffix': ext\r\n            })\r\n            \r\n            return result\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"解析失败: {str(e)}\")\r\n            return None\r\n            \r\n    def _get_file_extension(self, file_path: str) -> Optional[str]:\r\n        \"\"\"获取文件扩展名，支持复合扩展名\"\"\"\r\n        try:\r\n            # 处理特殊情况：.blade.php\r\n            if file_path.endswith('.blade.php'):\r\n                return '.blade.php'\r\n            return os.path.splitext(file_path)[1].lower()\r\n        except Exception as e:\r\n            logger.error(f\"获取文件扩展名失败: {str(e)}\")\r\n            return None\r\n            \r\n    def parse_python(self, content: str) -> Optional[ast.AST]:\r\n        \"\"\"解析Python代码\"\"\"\r\n        try:\r\n            return ast.parse(content)\r\n        except Exception as e:\r\n            logger.error(f\"Python解析失败: {str(e)}\")\r\n            return None\r\n            \r\n    def parse_php(self, content: str) -> Optional[Any]:\r\n        \"\"\"解析PHP代码\"\"\"\r\n        try:\r\n            # 预处理 PHP 代码\r\n            content = self._preprocess_php(content)\r\n            if not content:\r\n                return None\r\n            \r\n            # 创建新的词法分析器\r\n            lexer = phplex.lexer.clone()\r\n            \r\n            # 使用 phply 的解析器\r\n            try:\r\n                from phply.phpparse import make_parser\r\n                parser = make_parser()\r\n                ast = parser.parse(content, lexer=lexer)\r\n                \r\n                if not ast:\r\n                    logger.warning(\"PHP解析器返回空AST，使用备用解析方法\")\r\n                    return None\r\n                    \r\n                # 进行深度安全分析\r\n                security_analysis = self._analyze_php_security(content, ast)\r\n                \r\n                # 返回完整的结构\r\n                result = self._create_empty_result()\r\n                result.update({\r\n                    'ast': ast,\r\n                    'type': 'php',\r\n                    'content': content,\r\n                    'suffix': '.php',\r\n                    'security_issues': security_analysis['issues'],\r\n                    'recommendations': security_analysis['recommendations'],  # 添加建议\r\n                    'dependencies': self._extract_php_dependencies(content),\r\n                    'framework': self._detect_php_framework(content)\r\n                })\r\n                return result\r\n                \r\n            except (ImportError, AttributeError, SyntaxError) as e:\r\n                logger.warning(f\"PHP解析器错误: {str(e)}，使用备用解析方法\")\r\n                return None\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"PHP解析失败: {str(e)}\")\r\n            return None\r\n            \r\n    def _analyze_php_security(self, content: str, ast: Any) -> List[Dict]:\r\n        \"\"\"分析PHP代码的安全问题\"\"\"\r\n        issues = []\r\n        recommendations = []  # 添加建议列表\r\n        try:\r\n            # 1. 检查危险模式\r\n            for category, patterns in self.php_dangerous_patterns.items():\r\n                for pattern in patterns:\r\n                    matches = re.finditer(pattern, content)\r\n                    for match in matches:\r\n                        line_number = content.count('\\n', 0, match.start()) + 1\r\n                        issue = {\r\n                            'type': category,\r\n                            'line': line_number,\r\n                            'description': f'发现{category}: {pattern}',\r\n                            'severity': 'high' if category in ['dangerous_functions', 'sql_functions'] else 'medium',\r\n                            'code_context': self._get_line_context(content, line_number)\r\n                        }\r\n                        issues.append(issue)\r\n                        \r\n                        # 根据问题类型添加相应的建议\r\n                        if category == 'dangerous_functions':\r\n                            recommendations.append({\r\n                                'title': '危险函数使用建议',\r\n                                'description': f'建议替换危险函数 {pattern}，使用更安全的替代方案',\r\n                                'solution': self._get_security_recommendations(category, pattern),\r\n                                'severity': 'high'\r\n                            })\r\n                        elif category == 'sql_functions':\r\n                            recommendations.append({\r\n                                'title': 'SQL注入风险建议',\r\n                                'description': '使用参数化查询来防止SQL注入',\r\n                                'solution': self._get_security_recommendations(category, pattern),\r\n                                'severity': 'high'\r\n                            })\r\n                        # ... 其他类型的建议\r\n            \r\n            return {\r\n                'issues': issues,\r\n                'recommendations': recommendations  # 返回建议列表\r\n            }\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"安全分析失败: {str(e)}\")\r\n            return {'issues': [], 'recommendations': []}\r\n            \r\n    def _get_line_context(self, content: str, line_number: int, context_lines: int = 3) -> Dict:\r\n        \"\"\"获取代码行的上下文\"\"\"\r\n        try:\r\n            lines = content.splitlines()\r\n            start = max(0, line_number - context_lines - 1)\r\n            end = min(len(lines), line_number + context_lines)\r\n            \r\n            return {\r\n                'before': lines[start:line_number-1],\r\n                'line': lines[line_number-1],\r\n                'after': lines[line_number:end]\r\n            }\r\n        except Exception:\r\n            return {'before': [], 'line': '', 'after': []}\r\n            \r\n    def _extract_php_dependencies(self, content: str) -> List[str]:\r\n        \"\"\"提取PHP代码的依赖关系\"\"\"\r\n        dependencies = []\r\n        try:\r\n            # 检查 use 语句\r\n            use_matches = re.finditer(r'use\\s+([\\w\\\\]+)(?:\\s+as\\s+\\w+)?;', content)\r\n            for match in use_matches:\r\n                dependencies.append(match.group(1))\r\n                \r\n            # 检查 require/include 语句\r\n            require_matches = re.finditer(r'(?:require|include)(?:_once)?\\s*[\\'\"]([^\\'\"]+)[\\'\"]', content)\r\n            for match in require_matches:\r\n                dependencies.append(match.group(1))\r\n                \r\n            return list(set(dependencies))\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"提取依赖关系失败: {str(e)}\")\r\n            return []\r\n            \r\n    def _detect_php_framework(self, content: str) -> str:\r\n        \"\"\"检测PHP框架类型\"\"\"\r\n        try:\r\n            framework_patterns = {\r\n                'laravel': [\r\n                    r'use\\s+Illuminate\\\\',\r\n                    r'extends\\s+Controller',\r\n                    r'Laravel\\\\',\r\n                ],\r\n                'thinkphp': [\r\n                    r'use\\s+think\\\\',\r\n                    r'extends\\s+Controller',\r\n                    r'namespace\\s+app\\\\',\r\n                ],\r\n                'symfony': [\r\n                    r'use\\s+Symfony\\\\',\r\n                    r'extends\\s+AbstractController',\r\n                    r'Bundle\\\\',\r\n                ],\r\n                'yii': [\r\n                    r'use\\s+yii\\\\',\r\n                    r'extends\\s+Controller',\r\n                    r'Yii::',\r\n                ]\r\n            }\r\n            \r\n            for framework, patterns in framework_patterns.items():\r\n                if any(re.search(pattern, content) for pattern in patterns):\r\n                    return framework\r\n                    \r\n            return 'unknown'\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"检测框架失败: {str(e)}\")\r\n            return 'unknown'\r\n            \r\n    def _create_empty_ast(self) -> Dict:\r\n        \"\"\"创建空的 AST 结构 - 已废弃，使用 _create_empty_result 替代\"\"\"\r\n        return self._create_empty_result()\r\n            \r\n    def _preprocess_php(self, content: str) -> str:\r\n        \"\"\"预处理 PHP 代码\"\"\"\r\n        try:\r\n            if not content:\r\n                return ''\r\n            \r\n            # 移除 BOM 标记\r\n            content = content.replace('\\ufeff', '')\r\n            \r\n            # 移除 PHP 标签\r\n            content = re.sub(r'<\\?(?:php)?\\s+|\\?>', '', content)\r\n            \r\n            # 处理命名空间\r\n            content = re.sub(r'namespace\\s+[\\w\\\\]+\\s*;', '', content)\r\n            \r\n            # 处理 use 语句\r\n            content = re.sub(r'use\\s+[\\w\\\\]+(?:\\s+as\\s+\\w+)?\\s*;', '', content)\r\n            \r\n            # 移除注释\r\n            content = re.sub(r'//.*$|/\\*.*?\\*/', '', content, flags=re.MULTILINE|re.DOTALL)\r\n            \r\n            # 移除空行\r\n            content = '\\n'.join(line for line in content.splitlines() if line.strip())\r\n            \r\n            return content\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"PHP代码预处理失败: {str(e)}\")\r\n            return ''\r\n            \r\n    def parse_typescript(self, content: str) -> Optional[Any]:\r\n        \"\"\"解析TypeScript/JavaScript代码\"\"\"\r\n        try:\r\n            return esprima.parseScript(content, {'loc': True, 'range': True})\r\n        except Exception as e:\r\n            logger.error(f\"TypeScript/JavaScript解析失败: {str(e)}\")\r\n            return None \r\n\r\n    def _create_empty_result(self) -> Dict:\r\n        \"\"\"创建空的结果结构\"\"\"\r\n        return {\r\n            'type': 'unknown',\r\n            'ast': None,\r\n            'content': '',\r\n            'file_path': '',\r\n            'suffix': '',\r\n            'line': 0,\r\n            'body': [],\r\n            'loc': {'start': {'line': 1}},\r\n            'start_line': 0,\r\n            'end_line': 0,\r\n            'start_column': 0,\r\n            'end_column': 0\r\n        }\r\n\r\n    def _get_security_recommendations(self, category: str, pattern: str) -> str:\r\n        \"\"\"获取安全建议\"\"\"\r\n        recommendations = {\r\n            'dangerous_functions': {\r\n                'eval': '使用更安全的方式如配置文件或数据库来存储和处理数据',\r\n                'exec': '使用PHP内置函数或安全的库来执行系统命令',\r\n                'system': '使用escapeshellcmd()和escapeshellarg()函数转义命令参数',\r\n                'shell_exec': '使用proc_open()函数并严格控制命令参数'\r\n            },\r\n            'sql_functions': {\r\n                'mysql_query': '使用PDO或mysqli预处理语句',\r\n                'mysqli_query': '使用预处理语句和参数绑定',\r\n                'pg_query': '使用pg_prepare()和pg_execute()'\r\n            },\r\n            'file_operations': {\r\n                'fopen': '验证文件路径，使用realpath()函数',\r\n                'file_get_contents': '检查URL或文件路径的合法性',\r\n                'file_put_contents': '使用临时文件和原子操作'\r\n            },\r\n            'weak_crypto': {\r\n                'md5': '使用password_hash()函数进行密码哈希',\r\n                'sha1': '使用更强的哈希算法如SHA-256或SHA-3',\r\n                'base64_encode': '不要用于加密，只用于编码'\r\n            }\r\n        }\r\n        \r\n        category_recommendations = recommendations.get(category, {})\r\n        return category_recommendations.get(pattern, '遵循安全编码规范，进行输入验证和转义')\r\n\r\nclass PHPParser:\r\n    def parse_file(self, file_path):\r\n        \"\"\"解析PHP文件并返回上下文\"\"\"\r\n        try:\r\n            # 基础验证\r\n            if not file_path:\r\n                logger.error(\"文件路径为空\")\r\n                return self._create_default_context(file_path)\r\n                \r\n            file_path = str(file_path)\r\n            if not os.path.exists(file_path):\r\n                logger.error(f\"文件不存在: {file_path}\")\r\n                return self._create_default_context(file_path)\r\n                \r\n            # 读取文件内容\r\n            content = self._read_file_content(file_path)\r\n            if content is None:\r\n                return self._create_default_context(file_path)\r\n                \r\n            # 获取文件扩展名\r\n            ext = self._get_file_extension(file_path)\r\n            if not ext:\r\n                return self._create_default_context(file_path)\r\n                \r\n            # 解析内容\r\n            parser = CodeParser()\r\n            parse_result = parser.parse(content, file_path)\r\n            \r\n            if parse_result is None:\r\n                logger.error(f\"解析内容失败: {file_path}\")\r\n                return self._create_default_context(file_path)\r\n                \r\n            # 构建上下文，确保使用正确的文件路径和扩展名\r\n            context = self._create_context_from_result(parse_result, file_path)\r\n            \r\n            # 额外的验证，确保suffix字段存在且有效\r\n            if not context.get('suffix'):\r\n                context['suffix'] = ext\r\n                \r\n            return context\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"解析文件时发生错误: {str(e)}\")\r\n            return self._create_default_context(file_path)\r\n            \r\n    def _create_default_context(self, file_path: Optional[str] = None) -> Dict:\r\n        \"\"\"创建默认的上下文结构\"\"\"\r\n        ext = self._get_file_extension(file_path) if file_path else ''\r\n        return {\r\n            'line': 0,\r\n            'suffix': ext or '.php',  # 确保有默认扩展名\r\n            'content': '',\r\n            'file_path': str(file_path) if file_path else '',\r\n            'type': 'php',  # 明确指定类型\r\n            'ast': None,\r\n            'body': [],\r\n            'loc': {'start': {'line': 1}},\r\n            'start_line': 0,\r\n            'end_line': 0,\r\n            'start_column': 0,\r\n            'end_column': 0\r\n        }\r\n        \r\n    def _get_file_extension(self, file_path: Optional[str]) -> str:\r\n        \"\"\"获取文件扩展名\"\"\"\r\n        try:\r\n            if not file_path:\r\n                return '.php'\r\n                \r\n            if file_path.endswith('.blade.php'):\r\n                return '.blade.php'\r\n                \r\n            ext = os.path.splitext(file_path)[1].lower()\r\n            return ext if ext else '.php'\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"获取文件扩展名失败: {str(e)}\")\r\n            return '.php'\r\n            \r\n    def _read_file_content(self, file_path: str) -> Optional[str]:\r\n        \"\"\"读取文件内容\"\"\"\r\n        try:\r\n            with open(file_path, 'r', encoding='utf-8') as f:\r\n                return f.read()\r\n        except UnicodeDecodeError:\r\n            try:\r\n                with open(file_path, 'r', encoding='gbk') as f:\r\n                    return f.read()\r\n            except Exception as e:\r\n                logger.error(f\"读取文件失败 {file_path}: {str(e)}\")\r\n                return None\r\n                \r\n    def _create_context_from_result(self, parse_result: Dict, file_path: str) -> Dict:\r\n        \"\"\"从解析结果创建上下文\"\"\"\r\n        ext = self._get_file_extension(file_path)\r\n        return {\r\n            'line': parse_result.get('line', 0),\r\n            'suffix': parse_result.get('suffix', ext),  # 使用文件实际扩展名作为后备\r\n            'content': parse_result.get('content', ''),\r\n            'file_path': parse_result.get('file_path', file_path),  # 使用实际文件路径\r\n            'type': parse_result.get('type', 'php'),  # 默认为php类型\r\n            'ast': parse_result.get('ast'),\r\n            'body': parse_result.get('body', []),\r\n            'loc': parse_result.get('loc', {'start': {'line': 1}}),\r\n            'start_line': parse_result.get('start_line', 0),\r\n            'end_line': parse_result.get('end_line', 0),\r\n            'start_column': parse_result.get('start_column', 0),\r\n            'end_column': parse_result.get('end_column', 0)\r\n        }\r\n        \r\n    def _validate_context(self, context: Dict) -> bool:\r\n        \"\"\"验证上下文的完整性\"\"\"\r\n        try:\r\n            required_keys = ['line', 'suffix', 'content', 'file_path', 'type', 'ast']\r\n            \r\n            # 检查所有必需的键是否存在\r\n            missing_keys = [k for k in required_keys if k not in context]\r\n            if missing_keys:\r\n                logger.error(f\"上下文缺少必要的键: {missing_keys}\")\r\n                return False\r\n                \r\n            # 验证类型\r\n            if not isinstance(context['line'], int):\r\n                logger.error(f\"line 必须是整数类型，当前类型: {type(context['line'])}\")\r\n                return False\r\n                \r\n            if not isinstance(context['suffix'], str):\r\n                logger.error(f\"suffix 必须是字符串类型，当前类型: {type(context['suffix'])}\")\r\n                return False\r\n                \r\n            if not isinstance(context['content'], str):\r\n                logger.error(f\"content 必须是字符串类型，当前类型: {type(context['content'])}\")\r\n                return False\r\n                \r\n            return True\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"验证上下文时发生错误: {str(e)}\")\r\n            return False\r\n            \r\n    def check_security_context(self, context):\r\n        \"\"\"检查安全上下文\"\"\"\r\n        try:\r\n            # 如果上下文为空或不是字典类型，返回空列表\r\n            if not context or not isinstance(context, dict):\r\n                logger.error(f\"无效的上下文: {type(context)}\")\r\n                return []\r\n                \r\n            # 验证必要字段\r\n            required_keys = ['line', 'suffix', 'content', 'file_path', 'type', 'ast']\r\n            if not all(key in context for key in required_keys):\r\n                missing_keys = [k for k in required_keys if k not in context]\r\n                logger.error(f\"上下文缺少必要的键: {missing_keys}\")\r\n                return []\r\n                \r\n            # 验证字段类型并提供默认值\r\n            context['line'] = int(context.get('line', 0))\r\n            context['suffix'] = str(context.get('suffix', ''))\r\n            context['content'] = str(context.get('content', ''))\r\n            \r\n            # 执行安全检查\r\n            security_issues = []\r\n            \r\n            # 检查 AST\r\n            if context.get('ast'):\r\n                # 实现基于 AST 的安全检查逻辑\r\n                pass\r\n                \r\n            # 检查原始内容\r\n            if context.get('content'):\r\n                # 实现基于内容的安全检查逻辑\r\n                pass\r\n                \r\n            return security_issues\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"检查安全上下文时发生错误: {str(e)}\")\r\n            return [] "}
{"type": "source_file", "path": "setup.py", "content": "from setuptools import setup, find_packages\r\n\r\nsetup(\r\n    name=\"mirror-flowers\",\r\n    version=\"1.0.0\",\r\n    description=\"AI-driven Code Security Audit Tool\",\r\n    author=\"Ky0toFu\",\r\n    author_email=\"\",  # 如果有的话\r\n    url=\"https://github.com/Ky0toFu/Mirror-Flowers\",\r\n    packages=find_packages(),\r\n    install_requires=[\r\n        \"fastapi\",\r\n        \"uvicorn\",\r\n        \"python-multipart\",\r\n        \"aiofiles\",\r\n        \"httpx\",\r\n        \"openai\",\r\n        \"chromadb\",\r\n        \"sentence-transformers\",\r\n        \"pydantic\",\r\n        \"pydantic-settings\",\r\n        \"python-dotenv\",\r\n        \"langchain\",\r\n        \"langchain-community\",\r\n    ],\r\n    extras_require={\r\n        \"dev\": [\r\n            \"pytest\",\r\n            \"pytest-asyncio\",\r\n            \"black\",\r\n            \"isort\",\r\n            \"flake8\",\r\n            \"mypy\",\r\n        ]\r\n    },\r\n    classifiers=[\r\n        \"Development Status :: 4 - Beta\",\r\n        \"Intended Audience :: Developers\",\r\n        \"License :: OSI Approved :: MIT License\",\r\n        \"Programming Language :: Python :: 3.8\",\r\n        \"Programming Language :: Python :: 3.9\",\r\n        \"Programming Language :: Python :: 3.10\",\r\n        \"Topic :: Security\",\r\n    ],\r\n    python_requires=\">=3.8\",\r\n) "}
{"type": "source_file", "path": "core/analyzers/security_analyzer.py", "content": "class SecurityAnalyzer:\r\n    def __init__(self):\r\n        self.patterns = {\r\n            'weak_crypto': [\r\n                r'md5\\(',\r\n                r'sha1\\(',\r\n                r'crypt\\(',\r\n                r'des_encrypt\\('\r\n            ],\r\n            'hardcoded_secrets': [\r\n                r'password\\s*=\\s*[\\'\"][^\\'\"]+[\\'\"]',\r\n                r'secret\\s*=\\s*[\\'\"][^\\'\"]+[\\'\"]',\r\n                r'api_key\\s*=\\s*[\\'\"][^\\'\"]+[\\'\"]'\r\n            ],\r\n            'insecure_config': [\r\n                r'display_errors\\s*=\\s*On',\r\n                r'allow_url_include\\s*=\\s*On',\r\n                r'register_globals\\s*=\\s*On'\r\n            ],\r\n            'csrf_vulnerability': [\r\n                r'form.*method=[\\'\"]post[\\'\"].*(?!.*csrf)',\r\n                r'ajax\\.post\\(.*(?!.*token)'\r\n            ]\r\n        }\r\n        \r\n    def analyze(self, code, file_type):\r\n        \"\"\"执行安全分析\"\"\"\r\n        vulnerabilities = []\r\n        \r\n        # 根据文件类型选择不同的分析策略\r\n        if file_type == 'php':\r\n            vulnerabilities.extend(self._analyze_php(code))\r\n        elif file_type == 'java':\r\n            vulnerabilities.extend(self._analyze_java(code))\r\n            \r\n        return vulnerabilities "}
{"type": "source_file", "path": "core/parsers/java_parser.py", "content": "import javalang\r\n\r\nclass JavaParser:\r\n    def parse(self, code: str):\r\n        \"\"\"\r\n        解析Java代码生成AST\r\n        \"\"\"\r\n        try:\r\n            ast = javalang.parse.parse(code)\r\n            return ast\r\n        except Exception as e:\r\n            raise Exception(f\"Java解析错误: {str(e)}\") "}
{"type": "source_file", "path": "core/database/vector_store.py", "content": "from typing import List, Dict, Any\r\nimport numpy as np\r\nfrom langchain_chroma import Chroma\r\nfrom langchain_huggingface import HuggingFaceEmbeddings\r\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\r\nimport logging\r\nimport asyncio\r\nfrom backend.config import settings, paths\r\nimport json\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass CodeVectorStore:\r\n    def __init__(self, persist_directory: str = \"vector_store\"):\r\n        \"\"\"初始化向量数据库\"\"\"\r\n        self.embeddings = HuggingFaceEmbeddings(\r\n            model_name=\"all-MiniLM-L6-v2\"\r\n        )\r\n        self.vector_store = Chroma(\r\n            persist_directory=str(persist_directory),\r\n            embedding_function=self.embeddings,\r\n            collection_name=\"code_snippets\"\r\n        )\r\n        self.text_splitter = RecursiveCharacterTextSplitter(\r\n            chunk_size=settings.VECTOR_CHUNK_SIZE,\r\n            chunk_overlap=settings.VECTOR_CHUNK_OVERLAP\r\n        )\r\n        \r\n    def _prepare_metadata(self, metadata: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"准备元数据，将复杂类型转换为字符串\"\"\"\r\n        processed = {}\r\n        for key, value in metadata.items():\r\n            if isinstance(value, (str, int, float, bool)):\r\n                processed[key] = value\r\n            else:\r\n                # 将复杂类型转换为 JSON 字符串\r\n                processed[key] = json.dumps(value)\r\n        return processed\r\n        \r\n    async def add_code_to_store(self, code_snippets: List[Dict[str, Any]]):\r\n        \"\"\"添加代码到向量数据库\"\"\"\r\n        try:\r\n            texts = []\r\n            metadatas = []\r\n            \r\n            for snippet in code_snippets:\r\n                texts.append(snippet[\"code\"])\r\n                metadata = {\r\n                    \"file_path\": snippet[\"file_path\"],\r\n                    \"line_start\": snippet[\"line_start\"],\r\n                    \"line_end\": snippet[\"line_end\"]\r\n                }\r\n                \r\n                if \"metadata\" in snippet:\r\n                    extra_metadata = self._prepare_metadata(snippet[\"metadata\"])\r\n                    metadata.update(extra_metadata)\r\n                    \r\n                metadatas.append(metadata)\r\n            \r\n            # 使用 asyncio.to_thread 包装同步操作\r\n            await asyncio.to_thread(\r\n                self.vector_store.add_texts,\r\n                texts=texts,\r\n                metadatas=metadatas\r\n            )\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"Error adding code to vector store: {str(e)}\")\r\n            raise\r\n\r\n    async def search_similar_code(self, query: str, n_results: int = 5, threshold: float = 0.8) -> List[Dict[str, Any]]:\r\n        \"\"\"搜索相似代码片段，增加相似度阈值过滤\"\"\"\r\n        try:\r\n            # 使用 asyncio.to_thread 包装同步操作\r\n            results = await asyncio.to_thread(\r\n                self.vector_store.similarity_search_with_score,\r\n                query,\r\n                k=n_results * 2  # 获取更多结果用于过滤\r\n            )\r\n            \r\n            # 过滤低相似度结果\r\n            filtered_results = [\r\n                {\r\n                    \"code\": doc.page_content,\r\n                    \"metadata\": doc.metadata,\r\n                    \"similarity\": score\r\n                }\r\n                for doc, score in results\r\n                if score >= threshold\r\n            ]\r\n            \r\n            # 返回前n_results个结果\r\n            return filtered_results[:n_results]\r\n            \r\n        except Exception as e:\r\n            logger.error(f\"Error searching vector store: {str(e)}\")\r\n            raise "}
{"type": "source_file", "path": "core/database/__init__.py", "content": "from .vector_store import CodeVectorStore\r\n\r\n__all__ = ['CodeVectorStore'] "}
{"type": "source_file", "path": "core/parsers/php_parser.py", "content": "import ast\r\nimport subprocess\r\nimport tempfile\r\nimport os\r\n\r\nclass PHPParser:\r\n    def parse(self, code: str):\r\n        \"\"\"\r\n        解析PHP代码生成AST\r\n        使用 php -l 进行语法检查\r\n        \"\"\"\r\n        try:\r\n            # 创建临时文件存储PHP代码\r\n            with tempfile.NamedTemporaryFile(suffix='.php', mode='w', delete=False) as tmp:\r\n                tmp.write(code)\r\n                tmp_path = tmp.name\r\n\r\n            # 使用 PHP 命令行进行语法检查\r\n            result = subprocess.run(['php', '-l', tmp_path], \r\n                                 capture_output=True, \r\n                                 text=True)\r\n            \r\n            # 清理临时文件\r\n            os.unlink(tmp_path)\r\n            \r\n            if \"No syntax errors detected\" not in result.stdout:\r\n                raise Exception(result.stderr)\r\n            \r\n            # 这里可以添加更详细的AST分析\r\n            # 目前先返回简单的语法检查结果\r\n            return {\r\n                \"type\": \"php_file\",\r\n                \"syntax_valid\": True,\r\n                \"content\": code\r\n            }\r\n            \r\n        except subprocess.CalledProcessError as e:\r\n            raise Exception(f\"PHP解析错误: {str(e)}\")\r\n        except Exception as e:\r\n            raise Exception(f\"PHP解析错误: {str(e)}\") "}
{"type": "source_file", "path": "examples/basic_usage.py", "content": "from core.analyzers.context_analyzer import ContextAnalyzer\r\nfrom code_analyzer import AnalyzerConfig\r\n\r\ndef analyze_single_file():\r\n    \"\"\"单文件分析示例\"\"\"\r\n    config = AnalyzerConfig()\r\n    analyzer = ContextAnalyzer(config)\r\n    \r\n    # 分析单个文件\r\n    analyzer.analyze_project_context(['example.py'])\r\n    \r\n    # 获取分析结果\r\n    context = analyzer.get_file_context('example.py')\r\n    print(\"文件分析结果:\", context)\r\n    \r\n    # 获取函数调用图\r\n    call_graph = analyzer.get_call_graph('main')\r\n    print(\"函数调用图:\", call_graph)\r\n    \r\n    # 清理\r\n    analyzer.clear_analysis()\r\n\r\nif __name__ == '__main__':\r\n    analyze_single_file() "}

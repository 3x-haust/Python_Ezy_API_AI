{"repo_info": {"repo_name": "whisper.api", "repo_owner": "innovatorved", "repo_url": "https://github.com/innovatorved/whisper.api"}}
{"type": "test_file", "path": "app/tests/__init__.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.core.config import settings\nfrom app.main import app\nfrom app.tests.utils.utils import override_get_db, get_db\n\n# Create test database\nTEST_DATABASE_URL = settings.TEST_DATABASE_URL\nengine = create_engine(TEST_DATABASE_URL)\nTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\n# Define test client\n@pytest.fixture(scope=\"module\")\ndef test_client():\n    with TestClient(app) as client:\n        yield client\n\n\n# Define test database\n@pytest.fixture(scope=\"module\")\ndef test_db():\n    db = TestingSessionLocal()\n    yield db\n    db.close()\n\n\n# Override get_db function for testing\n@pytest.fixture(autouse=True)\ndef override_get_db(monkeypatch):\n    monkeypatch.setattr(\"app.api.dependencies.get_db\", get_db)\n"}
{"type": "test_file", "path": "app/tests/test_api/test_users.py", "content": "import uuid\n\nfrom fastapi.testclient import TestClient\nfrom app.main import app\n\nfrom app.tests.utils.utils import fake_user_details, get_new_fake_pwd\n\nclient = TestClient(app)\n\ntest_user_details = fake_user_details()\n\n\ndef test_create_user():\n    data = {\n        \"email\": test_user_details[\"email\"],\n        \"username\": test_user_details[\"username\"],\n        \"password\": test_user_details[\"password\"],\n    }\n    response = client.post(\"/api/v1/users/\", json=data)\n    print(response.content)\n    test_user_details[\"user_id\"] = response.json()[\"id\"]\n    assert response.status_code == 201\n    assert response.json()[\"email\"] == test_user_details[\"email\"]\n    assert response.json()[\"username\"] == test_user_details[\"username\"]\n\n\ndef test_create_user_invalid_email():\n    test_user_details_2 = fake_user_details()\n\n    data = {\n        \"email\": \"invalid_email\",\n        \"username\": test_user_details_2[\"username\"],\n        \"password\": test_user_details_2[\"password\"],\n    }\n    response = client.post(f\"/api/v1/users/\", json=data)\n    assert response.status_code == 422\n    assert \"value_error\" in response.json()[\"detail\"][0][\"type\"]\n    assert \"Invalid email\" in response.json()[\"detail\"][0][\"msg\"]\n\n\ndef test_create_user_invalid_password():\n    data = {\n        \"email\": test_user_details[\"email\"],\n        \"username\": test_user_details[\"username\"],\n        \"password\": \"short\",\n    }\n    response = client.post(\"/api/v1/users/\", json=data)\n    assert response.status_code == 422\n    assert (\n        \"Password must be at least 6 characters long\"\n        in response.json()[\"detail\"][0][\"msg\"]\n    )\n\n\ndef test_read_user():\n    response = client.get(f\"/api/v1/users/{test_user_details['user_id']}\")\n    assert response.status_code == 200\n    assert response.json()[\"email\"] == test_user_details[\"email\"]\n    assert response.json()[\"username\"] == test_user_details[\"username\"]\n\n\ndef test_read_user_not_found():\n    response = client.get(f\"/api/v1/users/{uuid.uuid4()}\")\n\n    assert response.status_code == 404\n    assert response.json()[\"detail\"] == \"User not found\"\n\n\ndef test_check_update_password():\n    new_password = get_new_fake_pwd()\n    data = {\n        \"current_password\": test_user_details[\"password\"],\n        \"new_password\": new_password,\n    }\n    response = client.put(\n        f\"/api/v1/users/{test_user_details['user_id']}/update_password/\", json=data\n    )\n    assert response.status_code == 200\n    assert response.json()[\"email\"] == test_user_details[\"email\"]\n    assert response.json()[\"username\"] == test_user_details[\"username\"]\n\n\ndef test_check_update_password_invalid_current_password():\n    new_password = get_new_fake_pwd()\n    data = {\"current_password\": \"wrong_password\", \"new_password\": new_password}\n    response = client.put(\n        f\"/api/v1/users/{test_user_details['user_id']}/update_password/\", json=data\n    )\n    assert response.status_code == 400\n    assert response.json()[\"detail\"] == \"Incorrect password\"\n\n\ndef test_check_update_password_not_found():\n    data = {\"current_password\": \"wrong_password\", \"new_password\": \"new_password\"}\n    response = client.put(f\"/api/v1/users/{uuid.uuid4()}/update_password/\", json=data)\n    assert response.status_code == 404\n    assert response.json()[\"detail\"] == \"User not found\"\n\n\ndef test_delete_user_not_found():\n    response = client.delete(f\"/api/v1/users/{uuid.uuid4()}/delete\")\n    assert response.status_code == 404\n    assert response.json()[\"detail\"] == \"User not found\"\n"}
{"type": "test_file", "path": "app/tests/test_core/test_config.py", "content": "from app.core.config import settings\n\n\ndef test_settings():\n    assert settings.API_V1_STR == \"/api/v1\"\n    assert settings.PROJECT_NAME == \"Whisper API\"\n"}
{"type": "test_file", "path": "app/tests/test_core/test_server.py", "content": "from fastapi.testclient import TestClient\nfrom app.main import app\nfrom app.core.config import settings\n\nclient = TestClient(app)\n\n\ndef test_ping_main():\n    response = client.get(\"/ping\")\n    assert response.status_code == 200\n    assert response.json() == {\"ping\": \"pong\"}\n"}
{"type": "test_file", "path": "app/tests/test_core/test_database.py", "content": "from sqlalchemy.orm import Session\nfrom app.core.database import SessionLocal\nfrom app.core.models.User import UserController\n\nfrom app.tests.utils.utils import fake_user_details\n\n\ndef test_create_user(db: Session = SessionLocal()):\n    test_user_details = fake_user_details()\n    USER = UserController(db)\n    USER.create(\n        test_user_details[\"username\"],\n        test_user_details[\"email\"],\n        test_user_details[\"password\"],\n    )\n    data = USER.details()\n    assert data.id is not None\n    assert data.email == test_user_details[\"email\"]\n    assert data.is_active is True\n"}
{"type": "test_file", "path": "app/tests/test_core/test_security.py", "content": "from fastapi import HTTPException\nfrom app.core.security import verify_password, get_password_hash\n\n\ndef test_password_hashing():\n    password = \"testpassword\"\n    hashed_password = get_password_hash(password)\n    assert hashed_password != password\n\n\ndef test_password_verification():\n    password = \"testpassword\"\n    hashed_password = get_password_hash(password)\n    assert verify_password(password, hashed_password)\n    assert not verify_password(\"wrongpassword\", hashed_password)\n\n\ndef test_password_verification_exception():\n    password = \"testpassword\"\n    hashed_password = get_password_hash(password)\n    try:\n        verify_password(\"wrongpassword\", hashed_password)\n    except HTTPException as exc:\n        assert exc.status_code == 401\n        assert exc.detail == \"Incorrect email or password\"\n"}
{"type": "test_file", "path": "app/tests/conftest.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.core.config import settings\nfrom app.core.database import Base\nfrom app.core.database import SessionLocal\n\n\n@pytest.fixture(scope=\"module\")\ndef test_app():\n    # set up test app with client\n    from app.main import app\n\n    client = TestClient(app)\n    # set up test database\n    TEST_DATABASE_URL = settings.TEST_DATABASE_URL\n    engine = create_engine(TEST_DATABASE_URL)\n    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n    Base.metadata.create_all(bind=engine)\n    # yield the app and database session to the test\n    try:\n        yield client, TestingSessionLocal()\n    finally:\n        # clean up test database\n        Base.metadata.drop_all(bind=engine)\n\n\n@pytest.fixture(scope=\"function\")\ndef db_session():\n    # set up a new database session for each test\n    session = SessionLocal()\n    try:\n        yield session\n    finally:\n        session.close()\n"}
{"type": "test_file", "path": "app/tests/utils/constant.py", "content": ""}
{"type": "test_file", "path": "app/tests/utils/utils.py", "content": "from sqlalchemy.orm import Session\nfrom app.core.database import SessionLocal\n\nfrom faker import Faker\n\nfake = Faker()\n\n\ndef override_get_db():\n    \"\"\"\n    Override the get_db function for testing\n    \"\"\"\n    try:\n        db = SessionLocal()\n        yield db\n    finally:\n        db.close()\n\n\ndef get_db():\n    \"\"\"\n    Get a new database session\n    \"\"\"\n    try:\n        db = SessionLocal()\n        yield db\n    finally:\n        db.close()\n\n\ndef fake_user_details():\n    test_user_details = {\n        \"email\": fake.email(),\n        \"username\": fake.user_name(),\n        \"password\": fake.password(),\n    }\n    return test_user_details\n\n\ndef get_new_fake_pwd():\n    return fake.password()\n"}
{"type": "test_file", "path": "app/tests/test_api/test_ping.py", "content": "# File: whisper.api/app/tests/test_api/__init__.py\n\nfrom fastapi.testclient import TestClient\nfrom app.main import app\n\nclient = TestClient(app)\n\n\ndef test_ping_main():\n    response = client.get(\"/ping\")\n    assert response.status_code == 200\n    assert response.json() == {\"ping\": \"pong\"}\n"}
{"type": "source_file", "path": "app/api/models/user.py", "content": "import uuid\nimport re\nfrom datetime import datetime\n\n\nfrom pydantic import ConfigDict, BaseModel, Field, field_validator\nfrom typing import Optional\n\nfrom sqlalchemy import Column, Integer, String, Boolean\n\nfrom app.core.database import Base\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\n\nclass UserBase(BaseModel):\n    email: str\n    username: str\n\n\nclass UserResponse(UserBase):\n    id: uuid.UUID = Field(..., alias=\"id\")\n    is_active: Optional[bool] = None\n    created_at: datetime = Field(..., alias=\"created_at\")\n    model_config = ConfigDict(\n        from_attributes=True,\n    )\n\n\nclass PasswordUpdate(BaseModel):\n    current_password: str\n    new_password: str\n\n\nclass User_GET_TOKEN(BaseModel):\n    email: str\n    password: str\n\n\nclass Response_Token(BaseModel):\n    token: str\n\n\nclass User(UserBase):\n    password: str\n\n    @field_validator(\"email\")\n    def email_must_be_valid(cls, v):\n        if not re.match(r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\", v):\n            raise ValueError(\"Invalid email address\")\n        return v\n\n    @field_validator(\"password\")\n    def password_must_be_long(cls, v):\n        if len(v) < 6:\n            raise ValueError(\"Password must be at least 6 characters long\")\n        return v\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass UpdateUser(UserBase):\n    current_password: str\n\n\nclass UserDeletedResponse(BaseModel):\n    detail: str = Field(..., alias=\"detail\")\n    model_config = ConfigDict(from_attributes=True)\n"}
{"type": "source_file", "path": "app/api/models/__init__.py", "content": "from .user import User\nfrom .transcribe import Transcription\n"}
{"type": "source_file", "path": "app/__init__.py", "content": "from fastapi import FastAPI\n\nfrom app.api import api_router\nfrom app.core.config import settings\n\n\ndef create_app() -> FastAPI:\n    app = FastAPI(title=settings.PROJECT_NAME, version=settings.PROJECT_VERSION)\n    app.include_router(api_router, prefix=settings.API_V1_STR)\n    return app\n\n\napp = create_app()\n"}
{"type": "source_file", "path": "app/api/models/transcribe.py", "content": "import uuid\n\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nfrom sqlalchemy.dialects.postgresql import UUID\n\nfrom sqlalchemy import Column, Integer, String, Boolean, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom app.core.database import Base\n\n\nclass Transcription(BaseModel):\n    text: str\n    filename: str\n"}
{"type": "source_file", "path": "app/api/endpoints/users.py", "content": "from uuid import UUID\n\nfrom fastapi import APIRouter, status, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom app.api.models.user import (\n    User,\n    UserResponse,\n    PasswordUpdate,\n    UserDeletedResponse,\n    User_GET_TOKEN,\n    Response_Token,\n)\nfrom app.core.database import get_db\nfrom app.core.models.User import UserController\n\nfrom app.utils import logger\n\nrouter = APIRouter()\n\n\n@router.post(\"/\", status_code=status.HTTP_201_CREATED, response_model=UserResponse)\nasync def create_user(user: User, db: Session = Depends(get_db)):\n    try:\n        USER = UserController(db)\n        USER.create(\n            username=user.username,\n            email=user.email,\n            password=user.password,\n        )\n\n        return UserResponse.model_validate(USER.details())\n    except HTTPException as exc:\n        logger.error(exc)\n        raise exc\n    except Exception as exc:\n        logger.error(exc)\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc)\n        ) from exc\n\n\n@router.post(\n    \"/get_token\", status_code=status.HTTP_200_OK, response_model=Response_Token\n)\nasync def get_user_token(user: User_GET_TOKEN, db: Session = Depends(get_db)):\n    try:\n        USER = UserController(db)\n        token = USER.read_token(user.email, user.password)\n        return {\"token\": token}\n    except HTTPException as exc:\n        logger.error(exc)\n        raise exc\n    except Exception as exc:\n        logger.error(exc)\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc)\n        ) from exc\n\n\n@router.get(\"/{user_id}/\", status_code=status.HTTP_200_OK, response_model=UserResponse)\nasync def read_user(user_id: UUID, db: Session = Depends(get_db)):\n    try:\n        USER = UserController(db)\n        USER.read(user_id)\n        return UserResponse.model_validate(USER.details())\n    except HTTPException as exc:\n        logger.error(exc)\n        raise exc\n    except Exception as exc:\n        logger.error(exc)\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc)\n        ) from exc\n\n\n@router.put(\n    \"/{user_id}/update_password/\",\n    status_code=status.HTTP_200_OK,\n    response_model=UserResponse,\n)\nasync def update_password(\n    user_id: UUID, password: PasswordUpdate, db: Session = Depends(get_db)\n):\n    try:\n        USER = UserController(db)\n        USER.update_password(user_id, password.current_password, password.new_password)\n        return UserResponse.model_validate(USER.details())\n    except HTTPException as exc:\n        logger.error(exc)\n        raise exc\n    except Exception as exc:\n        logger.error(exc)\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc)\n        ) from exc\n\n\n@router.delete(\n    \"/{user_id}/delete\",\n    status_code=status.HTTP_200_OK,\n    response_model=UserDeletedResponse,\n)\nasync def delete_user(user_id: UUID, db: Session = Depends(get_db)):\n    try:\n        USER = UserController(db)\n        USER.delete(user_id)\n        return {\"detail\": \"User Deleted\"}\n    except HTTPException as exc:\n        logger.error(exc)\n        raise exc\n    except Exception as exc:\n        logger.error(exc)\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc)\n        ) from exc\n"}
{"type": "source_file", "path": "app/api/endpoints/__init__.py", "content": "# File: whisper.api/app/api/endpoints/__init__.py\n\nfrom fastapi import APIRouter\n\nfrom . import users, transcribe\n\nrouter = APIRouter()\n\nrouter.include_router(users.router, prefix=\"/users\", tags=[\"users\"])\nrouter.include_router(transcribe.router, prefix=\"/transcribe\", tags=[\"transcribe\"])\n"}
{"type": "source_file", "path": "app/api/__init__.py", "content": "# File: whisper.api/app/api/__init__.py\n\nfrom fastapi import APIRouter\nfrom .endpoints import users, transcribe\n\napi_router = APIRouter()\n\napi_router.include_router(users.router, prefix=\"/users\", tags=[\"users\"])\napi_router.include_router(transcribe.router, prefix=\"/transcribe\", tags=[\"transcribe\"])\n"}
{"type": "source_file", "path": "app/api/endpoints/transcribe.py", "content": "from typing import Annotated, List, Union\n\nfrom fastapi import APIRouter, File, UploadFile, Request, Header, HTTPException\nfrom fastapi.background import BackgroundTasks\n\nfrom app.core.database import SessionLocal\n\nfrom app.utils.utils import (\n    save_audio_file,\n    transcribe_file,\n    get_audio_duration,\n    get_model_name,\n)\nfrom app.core.models import AuthTokenController, TranscribeController\nfrom app.api.models import Transcription\n\nrouter = APIRouter()\ndatabase = SessionLocal()\n\n\n@router.post(\"/\", response_model=Transcription)\nasync def post_audio(\n    background_tasks: BackgroundTasks,\n    request: Request,\n    file: UploadFile = File(...),\n    model: str = \"tiny.en.q5\",\n    Authentication: Annotated[Union[str, None], Header()] = None,\n):\n    try:\n        userId = AuthTokenController(database).get_userid_from_token(Authentication)\n        file_path = save_audio_file(file)\n        [data, output_audio_path] = transcribe_file(file_path, get_model_name(model))\n        background_tasks.add_task(\n            create_transcribe_record, database, userId, data, output_audio_path\n        )\n\n        return Transcription(filename=file.filename, text=data)\n    except Exception as exc:\n        raise HTTPException(status_code=400, detail=exc.__str__())\n\n\ndef create_transcribe_record(database, userId, data, file_path):\n    duration = get_audio_duration(file_path)\n    TranscribeController(database).create(user_id=userId, text=data, duration=duration)\n"}
{"type": "source_file", "path": "app/api/models/ping.py", "content": "from pydantic import BaseModel\n\n\nclass PingResponse(BaseModel):\n    ping: str\n"}
{"type": "source_file", "path": "app/core/database.py", "content": "from sqlalchemy import create_engine, MetaData\nfrom sqlalchemy.orm import sessionmaker, declarative_base\n\nfrom app.core.config import settings\n\nPOSTGRES_DATABASE_URL = settings.POSTGRES_DATABASE_URL\n\nmeta = MetaData()\n\nengine = create_engine(POSTGRES_DATABASE_URL)\nBase = declarative_base(metadata=meta)\n\nBase.metadata.create_all(engine)\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "app/core/errors.py", "content": "from fastapi import Request, Response\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import HTTPException, RequestValidationError\n\n\nasync def error_handler(request: Request, exc: Exception) -> JSONResponse:\n    \"\"\"\n    Error handler function for FastAPI.\n\n    Args:\n        request: The HTTP request that caused the error.\n        exc: The exception that was raised.\n\n    Returns:\n        The error response.\n    \"\"\"\n\n    return JSONResponse(\n        status_code=500,\n        content={\"detail\": str(exc)},\n    )\n"}
{"type": "source_file", "path": "app/core/models/AuthToken.py", "content": "import uuid\nimport random\nimport string\n\nfrom app.core.config import settings\n\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy import Column, String, Boolean, ForeignKey, DateTime\nfrom sqlalchemy.orm import relationship\n\nfrom sqlalchemy.sql import func\n\nfrom app.core.database import Base\n\n\nclass AuthToken(Base):\n    __tablename__ = \"auth_tokens\"\n\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    token = Column(String, unique=True, index=True)\n    user_id = Column(UUID(as_uuid=True), ForeignKey(\"users.id\"))\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    user = relationship(\"UserInDB\", back_populates=\"auth_tokens\")\n\n    def __init__(self, user_id: UUID, token: str):\n        self.user_id = user_id\n        self.token = token\n\n\nclass AuthTokenController:\n    AuthToken = AuthToken\n\n    def __init__(self, database):\n        self.db = database\n\n    def get_userid_from_token(self, token) -> str:\n        user = self.db.query(AuthToken).filter(AuthToken.token == token).first()\n        if not user:\n            raise Exception(\"Invalid Token!\")\n        return user.user_id\n\n    def get_token_from_user_id(self, user_id: UUID) -> str:\n        token = self.db.query(AuthToken).filter(AuthToken.user_id == user_id).first()\n        if not token:\n            raise Exception(\"Invalid Token!\")\n        self.auth_token = token\n\n    def create(self, user_id: UUID):\n        self.user_id = user_id\n        self.token = self.create_token()\n        self.auth_token = AuthToken(self.user_id, self.token)\n        self.db.add(self.auth_token)\n        self.db.commit()\n        self.db.refresh(self.auth_token)\n\n    def get_token(self):\n        return self.auth_token.token\n\n    def create_token(self):\n        token = self.generate_bearer_token()\n        return token\n\n    def generate_bearer_token(self):\n        token_prefix = str(uuid.uuid4()).replace(\"-\", \"\")\n        token_suffix = \"\".join(\n            random.choices(\n                string.ascii_uppercase + string.ascii_lowercase + string.digits, k=32\n            )\n        )\n        return f\"{token_prefix}{token_suffix}\"\n\n    @staticmethod\n    def validate_bearer_token(request_token: str):\n        ...\n"}
{"type": "source_file", "path": "app/core/__init__.py", "content": "from .config import settings\nfrom .database import Base, engine, SessionLocal\nfrom .security import get_password_hash, verify_password\n\n__all__ = [\n    \"settings\",\n    \"Base\",\n    \"engine\",\n    \"SessionLocal\",\n    \"get_password_hash\",\n    \"verify_password\",\n]\n"}
{"type": "source_file", "path": "app/core/models/User.py", "content": "import uuid\n\nfrom app.core.config import settings\n\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy import Column, String, Boolean, DateTime\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom sqlalchemy import or_\nfrom app.core.database import Base\n\nfrom app.core.security import get_password_hash, verify_password\nfrom app.utils.utils import is_valid_email, is_valid_password\n\nfrom app.core.models import AuthTokenController\nfrom fastapi import HTTPException, status\n\n\nclass UserInDB(Base):\n    __tablename__ = \"users\"\n\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    username = Column(String, unique=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n    is_active = Column(Boolean, default=True)\n    transcribes = relationship(\"TranscibeInDB\", back_populates=\"user\")\n    auth_tokens = relationship(\"AuthToken\", back_populates=\"user\")\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n\n    def __init__(self, username: str, email: str, hashed_password: str):\n        self.username = username\n        self.email = email\n        self.hashed_password = hashed_password\n\n    def data(self):\n        return {\n            \"id\": self.id,\n            \"username\": self.username,\n            \"email\": self.email,\n            \"created_at\": self.created_at,\n        }\n\n\nclass UserController:\n    UserInDB = UserInDB\n\n    def __init__(self, database):\n        self.db = database\n\n    def create(self, username: str, email: str, password: str, init_token: bool = True):\n        if not is_valid_email(email):\n            raise HTTPException(\n                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=\"Invalid Email\"\n            )\n        if not is_valid_password(password):\n            raise HTTPException(\n                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n                detail=\"Invalid Password\",\n            )\n\n        is_user_exists: Boolean = self.CheckUserIsExistsByEmailAndUsername(\n            email, username\n        )\n        if is_user_exists:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"Email or Username Already Registered\",\n            )\n\n        self.username = username\n        self.email = email\n        self.hashed_password = get_password_hash(password)\n\n        self.db_user = UserInDB(\n            username=self.username,\n            email=self.email,\n            hashed_password=self.hashed_password,\n        )\n        self.db.add(self.db_user)\n        self.db.commit()\n        self.db.refresh(self.db_user)\n        self.user = self.db_user.data()\n\n        if init_token == False:\n            return\n        AuthTokenController(self.db).create(self.db_user.id)\n\n    def read_token(self, email: str, password: str):\n        self.read_by_email(email)\n        if not verify_password(password, self.db_user.hashed_password):\n            raise HTTPException(status_code=400, detail=\"Incorrect password\")\n        TOKEN = AuthTokenController(self.db)\n        TOKEN.get_token_from_user_id(self.db_user.id)\n        return TOKEN.get_token()\n\n    def CheckUserIsExistsByEmailAndUsername(self, email: str, username: str):\n        db_user = (\n            self.db.query(UserInDB)\n            .filter(or_(UserInDB.email == email, UserInDB.username == username))\n            .first()\n        )\n        if db_user:\n            return True\n        return False\n\n    def read_by_email(self, email: str):\n        self.db_user = self.db.query(UserInDB).filter(UserInDB.email == email).first()\n        if not self.db_user:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found\"\n            )\n        self.user = self.db_user.data()\n\n    def read(self, user_id: uuid.UUID):\n        self.db_user = self.db.query(UserInDB).filter(UserInDB.id == user_id).first()\n        if not self.db_user:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found\"\n            )\n        self.user = self.db_user.data()\n\n    def update_password(\n        self, user_id: uuid.UUID, current_password: str, new_password: str\n    ):\n        self.read(user_id)\n        if verify_password(current_password, self.db_user.hashed_password):\n            self.db_user.hashed_password = get_password_hash(new_password)\n            self.db.commit()\n            self.db.refresh(self.db_user)\n            self.user = self.db_user.data()\n        else:\n            raise HTTPException(status_code=400, detail=\"Incorrect password\")\n\n    def delete(self, user_id: uuid.UUID):\n        self.read(user_id)\n        self.db.delete(self.db_user)\n        self.db.commit()\n        return user_id\n\n    def details(self):\n        return self.db_user\n\n    def detailsInJSON(self):\n        return self.user\n"}
{"type": "source_file", "path": "app/core/models/__init__.py", "content": "from .AuthToken import AuthToken, AuthTokenController\nfrom .User import UserInDB\nfrom .Transcribe import TranscibeInDB, TranscribeController\n\nfrom app.core.database import Base, engine\n\n\nBase.metadata.create_all(engine)\n"}
{"type": "source_file", "path": "app/utils/__init__.py", "content": "import logging\n\nfrom .utils import get_all_routes, print_routes\n\nlogger = logging.getLogger(__name__)\n"}
{"type": "source_file", "path": "app/utils/exception.py", "content": "import logging\n\nlogger = logging.getLogger(__name__)\nfrom fastapi import HTTPException, status\n\n\ndef handle_exceptions(func):\n    async def wrapper(*args, **kwargs):\n        try:\n            return await func(*args, **kwargs)\n        except HTTPException as exc:\n            logger.error(exc)\n            raise exc\n        except Exception as exc:\n            logger.error(exc)\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc)\n            ) from exc\n\n    return wrapper\n"}
{"type": "source_file", "path": "app/core/models/Transcribe.py", "content": "from datetime import datetime, timedelta\n\nimport uuid\nfrom app.core.config import settings\n\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy import Column, String, Boolean, ForeignKey, DateTime, Integer\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy.sql import func\n\nfrom app.core.database import Base, engine\n\n\nclass TranscibeInDB(Base):\n    __tablename__ = \"transcribe_data\"\n\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    text = Column(String)\n    audio_duration = Column(Integer)\n    user_id = Column(UUID(as_uuid=True), ForeignKey(\"users.id\"))\n    user = relationship(\"UserInDB\", back_populates=\"transcribes\")\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n\n    def __init__(self, user_id, text, audio_duration):\n        self.text = text\n        self.audio_duration = audio_duration\n        self.user_id = user_id\n\n\nclass TranscribeController:\n    TranscibeInDB = TranscibeInDB\n\n    def __init__(self, database):\n        self.db = database\n\n    def create(self, user_id: UUID, text: str, duration: int):\n        try:\n            self.user_id = user_id\n            self.text = text\n            self.audio_duration = duration\n            self.transcribe_data = TranscibeInDB(\n                user_id=self.user_id, text=self.text, audio_duration=self.audio_duration\n            )\n            self.db.add(self.transcribe_data)\n            self.db.commit()\n            self.db.refresh(self.transcribe_data)\n        except Exception as e:\n            self.db.rollback()\n            raise e\n"}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import RedirectResponse\n\n\nfrom app.api import api_router\nfrom app.core.config import settings\nfrom app.core.errors import error_handler\nfrom app.api.models.ping import PingResponse\n\nfrom app.utils import print_routes\nfrom app.utils.checks import run_checks\n\nif not run_checks():\n    raise Exception(\"Failed to pass all checks\")\n\n\napp = FastAPI(\n    title=settings.PROJECT_NAME, openapi_url=f\"{settings.API_V1_STR}/openapi.json\"\n)\n\n# Set all CORS enabled origins\nif settings.BACKEND_CORS_ORIGINS:\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n\n@app.get(\"/\", include_in_schema=False)\nasync def redirect_to_docs():\n    return RedirectResponse(url=\"/docs\")\n\n\n@app.get(\"/ping\", tags=[\"ping\"], response_model=PingResponse)\nasync def ping():\n    return {\"ping\": \"pong\"}\n\n\n# Include routers\napp.include_router(api_router, prefix=settings.API_V1_STR)\n\n# # Error handlers\napp.add_exception_handler(500, error_handler)\n\n# Print all routes\nprint_routes(app)\n"}
{"type": "source_file", "path": "app/core/config.py", "content": "from os import environ as env\n\nfrom typing import Any, Dict, List, Optional, Union\nfrom pydantic import AnyHttpUrl, field_validator\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    API_V1_STR: str = \"/api/v1\"\n\n    PROJECT_NAME: str = \"Whisper API\"\n    PROJECT_VERSION: str = \"0.1.0\"\n    SECRET_KEY: str = env.get(\"SECRET_KEY\")\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = (\n        env.get(\"ACCESS_TOKEN_EXPIRE_MINUTES\") or 60 * 24 * 7\n    )\n\n    SERVER_NAME: str = env.get(\"SERVER_NAME\")\n    SERVER_HOST: AnyHttpUrl = env.get(\"SERVER_HOST\")\n\n    POSTGRES_DATABASE_URL: str = env.get(\"POSTGRES_DATABASE_URL\")\n    TEST_DATABASE_URL: str = env.get(\"POSTGRES_DATABASE_URL\")\n\n    BACKEND_CORS_ORIGINS: List[AnyHttpUrl] = [\n        \"http://localhost:3000\",\n        \"http://localhost:8080\",\n        \"http://localhost:8000\",\n    ]\n\n    @field_validator(\"SECRET_KEY\")\n    def secret_key_must_be_set(cls, v: Optional[str], values: Dict[str, Any]) -> str:\n        if not v:\n            raise ValueError(\"SECRET_KEY must be set\")\n        return v\n\n    @field_validator(\"SERVER_NAME\")\n    def server_name_must_be_set(cls, v: Optional[str], values: Dict[str, Any]) -> str:\n        if not v:\n            raise ValueError(\"SERVER_NAME must be set\")\n        return v\n\n    @field_validator(\"SERVER_HOST\")\n    def server_host_must_be_set(\n        cls, v: Optional[str], values: Dict[str, Any]\n    ) -> AnyHttpUrl:\n        if not v:\n            raise ValueError(\"SERVER_HOST must be set\")\n        return v\n\n    @field_validator(\"POSTGRES_DATABASE_URL\")\n    def postgres_db_url_must_be_set(\n        cls, v: Optional[str], values: Dict[str, Any]\n    ) -> str:\n        if not v:\n            raise ValueError(\"POSTGRES_DATABASE_URL must be set\")\n        return v\n\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "app/utils/checks.py", "content": "import os\nfrom app.utils.constant import model_names, model_urls\nfrom app.utils.utils import download_file\n\n\ndef run_checks():\n    try:\n        if not check_models_exist():\n            return False\n        return True\n    except Exception as exc:\n        print(\"Error in run_checks: {}\".format(str(exc)))\n        return False\n\n\ndef check_models_exist():\n    try:\n        for key, value in model_names.items():\n            if os.path.exists(os.path.join(os.getcwd(), \"models\", value)):\n                print(\"Model {} exists\".format(key))\n            else:\n                print(\"Model {} does not exist\".format(key))\n                download_model(key)\n        return True\n    except Exception as exc:\n        print(\"Error in check_models_exist: {}\".format(str(exc)))\n        return False\n\n\ndef download_model(model_key: str):\n    try:\n        print(\"Downloading model {} from {}\".format(model_key, model_urls[model_key]))\n        download_file(\n            model_urls[model_key],\n            os.path.join(os.getcwd(), \"models\", model_names[model_key]),\n        )\n        print(\"Downloaded model {} from {}\".format(model_key, model_urls[model_key]))\n    except Exception as exc:\n        print(\"Error in download_models: {}\".format(str(exc)))\n"}
{"type": "source_file", "path": "app/utils/utils.py", "content": "from fastapi import HTTPException\nimport os\nimport re\nimport urllib\nimport subprocess\nimport uuid\nimport logging\nimport wave\nimport gdown\nfrom tqdm import tqdm\n\n\nfrom .constant import model_names\n\n\ndef get_all_routes(app):\n    routes = []\n    for route in app.routes:\n        routes.append(\n            {\n                \"path\": route.path,\n                \"name\": route.name,\n                \"methods\": list(route.methods),\n            }\n        )\n    return routes\n\n\ndef print_routes(app):\n    routes = get_all_routes(app)\n    print(\"\\n\\n\")\n    print(\"Path\" + \" \" * 45 + \"Name\" + \" \" * 45 + \"Methods\")\n    print(\"-\" * 105)\n    for route in routes:\n        print(\n            f\"{route['path']}\"\n            + \" \" * (48 - len(route[\"path\"]))\n            + f\"{route['name']}\"\n            + \" \" * (48 - len(route[\"name\"]))\n            + f\"{', '.join(route['methods'])}\"\n        )\n    print(\"\\n\")\n\n\ndef transcribe_file(path: str = None, model=\"ggml-model-whisper-tiny.en-q5_1.bin\"):\n    \"\"\"./binary/whisper -m models/ggml-tiny.en.bin -f Rev.mp3 out.wav -nt --output-text out1.txt\"\"\"\n    try:\n        if path is None:\n            raise HTTPException(status_code=400, detail=\"No path provided\")\n        rand = uuid.uuid4()\n        outputFilePath: str = f\"transcribe/{rand}.txt\"\n        output_audio_path: str = f\"audio/{rand}.wav\"\n        command: str = f\"./binary/whisper -m models/{model} -f {path} {output_audio_path} -nt --output-text {outputFilePath}\"\n        execute_command(command)\n        f = open(outputFilePath, \"r\")\n        data = f.read()\n        f.close()\n        return [data, output_audio_path]\n    except Exception as exc:\n        logging.error(exc)\n        raise HTTPException(status_code=400, detail=exc.__str__())\n\n\ndef execute_command(command: str) -> str:\n    try:\n        result = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT)\n        return result.decode(\"utf-8\").strip()\n    except subprocess.CalledProcessError as exc:\n        logging.error(exc.output.decode(\"utf-8\").strip())\n        raise HTTPException(status_code=400, detail=\"Error while transcribing\")\n\n\ndef save_audio_file(file=None):\n    if file is None:\n        return \"\"\n    path = f\"audio/{uuid.uuid4()}.mp3\"\n    with open(path, \"wb\") as f:\n        f.write(file.file.read())\n    return path\n\n\ndef get_audio_duration(audio_file):\n    \"\"\"Gets the duration of the audio file in seconds.\n\n    Args:\n      audio_file: The path to the audio file.\n\n    Returns:\n      The duration of the audio file in seconds.\n    \"\"\"\n\n    with wave.open(audio_file, \"rb\") as f:\n        frames = f.getnframes()\n        sample_rate = f.getframerate()\n        duration = frames / sample_rate\n        rounded_duration = int(round(duration, 0))\n\n    return rounded_duration\n\n\ndef get_model_name(model: str = None):\n    if model is None:\n        model = \"tiny.en.q5\"\n\n    if model in model_names.keys():\n        return model_names[model]\n\n    return model_names[\"tiny.en.q5\"]\n\n\ndef download_from_drive(url, output):\n    try:\n        gdown.download(url, output, quiet=False)\n        return True\n    except:\n        raise HTTPException(\n            status_code=400, detail=\"Error Occured in Downloading model from Gdrive\"\n        )\n\n\ndef download_file(url, filepath):\n    try:\n        filename = os.path.basename(url)\n\n        with tqdm(\n            unit=\"B\", unit_scale=True, unit_divisor=1024, miniters=1, desc=filename\n        ) as progress_bar:\n            urllib.request.urlretrieve(\n                url,\n                filepath,\n                reporthook=lambda block_num, block_size, total_size: progress_bar.update(\n                    block_size\n                ),\n            )\n\n        print(\"File downloaded successfully!\")\n    except Exception as exc:\n        raise HTTPException(status_code=400, detail=f\"An error occurred: {exc}\")\n\n\ndef is_valid_email(email: str) -> bool:\n    email_regex = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n    return bool(re.match(email_regex, email))\n\n\ndef is_valid_password(password: str) -> bool:\n    if len(password) < 6:\n        return False\n    return True\n\n\ndef is_field_valid(**kwargs) -> bool:\n    for key, value in kwargs.items():\n        if key == \"email\":\n            if not is_valid_email(value):\n                return False\n        elif key == \"password\":\n            if not is_valid_password(value):\n                return False\n        elif key == \"username\":\n            if len(value) < 3:\n                return False\n        else:\n            return False\n    return True\n"}
{"type": "source_file", "path": "app/core/security.py", "content": "from passlib.context import CryptContext\nfrom fastapi import HTTPException\n\nfrom app.core.config import settings\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nALGORITHM = \"HS256\"\nSECRET_KEY = settings.SECRET_KEY\n\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"\n    Hashes a password using bcrypt algorithm\n    \"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(password: str, hash: str) -> bool:\n    \"\"\"\n    Verifies a password against a bcrypt hash\n    \"\"\"\n    is_valid = pwd_context.verify(password, hash)\n    if not is_valid:\n        return False\n    return True\n"}
{"type": "source_file", "path": "app/utils/constant.py", "content": "model_names = {\n    \"tiny.en\": \"ggml-tiny.en.bin\",\n    \"tiny.en.q5\": \"ggml-model-whisper-tiny.en-q5_1.bin\",\n    \"base.en.q5\": \"ggml-model-whisper-base.en-q5_1.bin\",\n}\n\nmodel_urls = {\n    \"tiny.en\": \"https://firebasestorage.googleapis.com/v0/b/model-innovatorved.appspot.com/o/ggml-model-whisper-base.en-q5_1.bin?alt=media\",\n    \"tiny.en.q5\": \"https://firebasestorage.googleapis.com/v0/b/model-innovatorved.appspot.com/o/ggml-model-whisper-tiny.en-q5_1.bin?alt=media\",\n    \"base.en.q5\": \"https://firebasestorage.googleapis.com/v0/b/model-innovatorved.appspot.com/o/ggml-model-whisper-base.en-q5_1.bin?alt=media\",\n}\n"}

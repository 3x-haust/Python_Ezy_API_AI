{"repo_info": {"repo_name": "heuristics", "repo_owner": "nogibjj", "repo_url": "https://github.com/nogibjj/heuristics"}}
{"type": "test_file", "path": "test_fetch_cities.py", "content": "from fetch_cities_lat_long import main, my_cities, create_cities_dataframe\nimport pytest\n\n# create a list of cities\ncity_list = my_cities(\"New York\", \"Knoxville\", \"Los Angeles\", \"Chicago\")\n# create a dataframe of cities and their latitudes and longitudes\ndf = create_cities_dataframe(city_list)\n\n\n@pytest.mark.slow\ndef test_my_cities():\n    \"\"\"Test my_cities function\"\"\"\n    assert my_cities(\"New York\", \"Knoxville\", \"Los Angeles\", \"Chicago\") == [\n        \"New York\",\n        \"Knoxville\",\n        \"Los Angeles\",\n        \"Chicago\",\n    ]\n\n\n@pytest.mark.slow\ndef test_main():\n    \"\"\"Test main function\"\"\"\n    assert main(count=1) == None\n"}
{"type": "test_file", "path": "tests/test_merge_sort.py", "content": "from algorithms.merge_sort import (\n    random_string,\n    create_pairs,\n    sort_pair,\n    sort_groups,\n    merge_sort,\n)\nimport pytest\n\n# build a fixture to test the create_pairs function\n@pytest.fixture\ndef ranstring():\n    return \"abzd\"\n\n\n@pytest.fixture\ndef list_pairs():\n    return \"ha\"\n\n\n# test each function in the merge_sort.py file\ndef test_random_string():\n    \"\"\"Test random_string function\"\"\"\n    assert len(random_string(4)) == 4\n\n\ndef test_create_pairs(ranstring):\n    \"\"\"Test create_pairs function\"\"\"\n\n    # assert len(create_pairs(ranstring)) == 2\n    assert create_pairs(ranstring) == [\"ab\", \"zd\"]\n\n\ndef test_sort_pair(list_pairs):\n    \"\"\"Test sort_pair function\"\"\"\n    assert sort_pair(\"ab\") == \"ab\"\n    assert sort_pair(\"ba\") == \"ab\"\n    assert sort_pair(list_pairs) == \"ah\"\n\n\ndef test_sort_groups():\n    \"\"\"Test sort_groups function\"\"\"\n    assert sort_groups([\"ca\", \"cd\"]) == \"accd\"\n\n\ndef test_merge_sort():\n    \"\"\"Test merge sort\"\"\"\n\n    assert merge_sort(\"ZENOVW\").startswith(\"E\")\n    assert merge_sort(\"ZENOVW\").endswith(\"W\")\n"}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "test_tsp_dict.py", "content": "from tsp_dict import tsp\nfrom pytest import fixture\n\n\n@fixture\ndef cities():\n    return {\n        \"New York\": {\n            \"New York\": 0,\n            \"Chicago\": 800,\n            \"Denver\": 1400,\n            \"Los Angeles\": 2100,\n        },\n        \"Chicago\": {\"New York\": 800, \"Chicago\": 0, \"Denver\": 600, \"Los Angeles\": 1300},\n        \"Denver\": {\"New York\": 1400, \"Chicago\": 600, \"Denver\": 0, \"Los Angeles\": 700},\n        \"Los Angeles\": {\n            \"New York\": 2100,\n            \"Chicago\": 1300,\n            \"Denver\": 700,\n            \"Los Angeles\": 0,\n        },\n    }\n\n\ndef test_tsp(cities):\n    assert tsp(cities), _ == 4000\n"}
{"type": "test_file", "path": "test_greedy_coin.py", "content": "# write a test for greedy_coin\nfrom greedy_coin import greedy_coin\n\n\ndef test_greedy_coin():\n    assert greedy_coin(0.25) == {0.25: 1, 0.10: 0, 0.05: 0, 0.01: 0}\n    assert greedy_coin(1.51) == {0.25: 6, 0.10: 0, 0.05: 0, 0.01: 1}\n"}
{"type": "test_file", "path": "test_tsp_pandas.py", "content": "from pytest import fixture\nfrom tsp_pandas import create_cities, tsp_pandas\n\n\n@fixture\ndef cities():\n    return create_cities()\n\n\ndef test_tsp_pandas(cities):\n    df_shortest, total_distance = tsp_pandas(cities)\n    assert total_distance < 100000000\n"}
{"type": "test_file", "path": "tests/test_roulette.py", "content": "from probability.roulette import simulate_spins, build_wheel, calculate_winnings\nimport pytest\n\n\n@pytest.fixture\ndef wheel():\n    return build_wheel()\n\n\ndef test_calculate_winnings_red(wheel):\n    results = simulate_spins(wheel, 2)\n    assert -2 <= calculate_winnings(results, 1, 2, color=\"red\") <= 2\n\n\ndef test_calculate_winnings_black(wheel):\n    results = simulate_spins(wheel, 2)\n    assert -2 <= calculate_winnings(results, 1, 2, color=\"black\") <= 2\n\n\ndef test_calculate_winnings_green(wheel):\n    results = simulate_spins(wheel, 2)\n    assert -2 <= calculate_winnings(results, 1, 2, color=\"green\") <= 34\n\n\ndef test_calculate_winnings_num(wheel):\n    results = simulate_spins(wheel, 2)\n    assert -2 <= calculate_winnings(results, 1, 2, number=1) <= 70\n"}
{"type": "source_file", "path": "coin.py", "content": "# build a greedy algorithm to find the minimum number of coins\ndef main():\n    # get change amount from user\n    while True:\n        change = float(input(\"Change owed: \"))\n        if change > 0:\n            break\n    # convert change to cents\n    cents = round(change * 100)\n    # initialize coin count\n    coins = 0\n    # greedy algorithm\n    while cents >= 25:\n        cents -= 25\n        coins += 1\n    while cents >= 10:\n        cents -= 10\n        coins += 1\n    while cents >= 5:\n        cents -= 5\n        coins += 1\n    while cents >= 1:\n        cents -= 1\n        coins += 1\n    # print result\n    print(coins)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "algo-translations/greedy_coin.py", "content": "#!/usr/bin/env python\n\"\"\" Greedy Coin Change Algorithm\n1. The function greedy_coin takes one argument, the amount of change to be given to the customer.\n2. The function prints a statement to tell the customer how much change they are getting.\n3. The function initializes a list of coins (quarters, dimes, nickels, and pennies) and a dictionary that maps the coins to their denominations.\n4. The function initializes a dictionary that will hold the number of coins of each type.\n5. The function goes through the list of coins and initializes the dictionary with a value of 0 for each coin.\n6. The function goes through the list of coins.\n7. The function subtracts the coin from the amount of change the customer is getting until the amount of change is less than the coin.\n8. The function then increments the number of coins of that type by 1.\n9. The function prints the number of each coin type the customer is getting.\n10. The function returns the dictionary with the number of each coin type. \n\"\"\"\n\nimport click\n\n\ndef greedy_coin(change):\n    \"\"\"Return a dictionary with the coin type as the key and the number of coins as the value\"\"\"\n\n    print(f\"Your change for {change}: \")\n    coins = [0.25, 0.10, 0.05, 0.01]\n    coin_lookup = {0.25: \"quarter\", 0.10: \"dime\", 0.05: \"nickel\", 0.01: \"penny\"}\n    coin_dict = {}\n    for coin in coins:\n        coin_dict[coin] = 0\n    for coin in coins:\n        while change >= coin:\n            change -= coin\n            coin_dict[coin] += 1\n    for coin in coin_dict:\n        if coin_dict[coin] > 0:\n            print(f\"{coin_dict[coin]} {coin_lookup[coin]}\")\n    return coin_dict\n\n\n@click.command()\n@click.argument(\"change\", type=float)\ndef main(change):\n    \"\"\"Return the minimum number of coins for a given change\n\n    Example: ./greedy_coin.py 0.99\n    \"\"\"\n    greedy_coin(change)\n\n\nif __name__ == \"__main__\":\n    # pylint: disable=no-value-for-parameter\n    main()\n"}
{"type": "source_file", "path": "algorithms/merge_sort.py", "content": "#!/usr/bin/env python\n\n\"\"\"Merge Sort Algorithm in Python\n\nStill needs work, not robust enough to handle all cases and long strings\nPython sorted is more complete and robust than this.  Danger... Danger Will Robinson\n\n\"\"\"\n\nimport random\nimport string\nimport click\n\n# create a random string of characters\ndef random_string(length=4):\n    \"\"\"Generate a random string of characters\"\"\"\n\n    letters = string.ascii_lowercase\n    return \"\".join(random.choice(letters) for i in range(length))\n\n\ndef create_pairs(text):\n    \"\"\"Create pairs of characters from a string\"\"\"\n\n    print(f\"Parsing unsorted string: {text}\")\n    pairs = []\n    for i in range(0, len(text), 2):\n        pairs.append(text[i : i + 2])\n    return pairs\n\n\ndef sort_pair(pair):\n    \"\"\"Sort a pair of characters\"\"\"\n\n    print(f\"Sorting pair: {pair}\")\n    if pair[0] > pair[1]:\n        new_pair = pair[1] + pair[0]\n    else:\n        new_pair = pair\n    print(f\"Sorted pair: {new_pair}\")\n    return new_pair\n\n\ndef sort_groups(pairs):\n    \"\"\"Sort lists of pairs into list\"\"\"\n\n    print(f\"Sorting pairs: {pairs}\")\n    current_pairs = []\n    for pair in pairs:\n        # first sort the pair\n        sorted_pair = sort_pair(pair)\n        if len(current_pairs) < 1:\n            current_pairs.append(sorted_pair)\n            print(f\"Current pairs: {current_pairs}\")\n            continue\n        elif len(current_pairs) == 1:\n            current_pairs.append(sorted_pair)\n            print(f\"Current pairs: {current_pairs} length2\")\n            first_item = current_pairs[0][0]\n            second_item = current_pairs[1][0]\n            if first_item < second_item:\n                continue\n            else:\n                # swap positions if first item is greater than second item\n                current_pairs = [current_pairs[1], current_pairs[0]]\n    return \"\".join(current_pairs)\n\n\n# Create a function that process lists of pairs two at a time\ndef merge_sort(text=None, chunks=2, length=4):\n    \"\"\"Merge sort a string of characters in N chunks\"\"\"\n\n    if text is None:\n        text = random_string(length)\n    rtext = text\n    print(f\"Processing Unsorted string: {rtext}\")\n    pairs = create_pairs(rtext)\n    total = []\n    for i in range(0, len(pairs), chunks):\n        print(f\"Processing pairs: {pairs[i:i+chunks]}\")\n        sorted_pairs = sort_groups(pairs[i : i + chunks])\n        total.append(sorted_pairs)\n    # return the sorted pairs\n    return \"\".join(total)\n\n\n@click.command()\n@click.option(\"--length\", default=4, help=\"Length of string to sort\")\n@click.option(\"--chunks\", default=2, help=\"Number of chunks to sort\")\n@click.option(\"--text\", default=None, help=\"Text to sort\")\ndef main(text, chunks, length):\n    \"\"\"Merge sort a string of characters in N chunks\"\"\"\n\n    print(merge_sort(text, chunks, length))\n\n\nif __name__ == \"__main__\":\n    # pylint: disable=no-value-for-parameter\n    main()\n"}
{"type": "source_file", "path": "fetch_cities_lat_long.py", "content": "#!/usr/bin/env python\n\n\"\"\"\nThis is a command-line tool that figures out the shortest distance to visit all cities in a list.\n\"\"\"\n\n\nimport geopy\nimport geopy.distance\nimport pandas as pd\nfrom random import shuffle\nimport click\n\n# build a function that takes variable length argument of strings and returns a list of cities\ndef my_cities(*args):\n    \"\"\"Build a list of cities from input\"\"\"\n    return list(args)\n\n\ndef create_cities_dataframe(cities=None):\n    \"\"\"Create a Pandas DataFrame of cities and their latitudes and longitudes\"\"\"\n\n    if cities is None:\n        cities = [\n            \"New York\",\n            \"Knoxville\",\n            \"Birmingham\",\n            \"Baltimore\",\n            \"Bangor\",\n            \"Cleveland\",\n            \"Chicago\",\n            \"Denver\",\n            \"Los Angeles\",\n            \"San Francisco\",\n            \"Raleigh\",\n            \"Seattle\",\n            \"Boston\",\n            \"Houston\",\n            \"Dallas\",\n            \"Miami\",\n            \"Atlanta\",\n            \"Fort Worth\",\n            \"Phoenix\",\n            \"San Diego\",\n        ]\n\n    # create a list to hold the latitudes and longitudes\n    latitudes = []\n    longitudes = []\n    # loop through the cities list and get the latitudes and longitudes\n    for city in cities:\n        geolocator = geopy.geocoders.Nominatim(user_agent=\"tsp_pandas\")\n        location = geolocator.geocode(city)\n        latitudes.append(location.latitude)\n        longitudes.append(location.longitude)\n    # create a dataframe from the cities, latitudes, and longitudes\n    df = pd.DataFrame(\n        {\n            \"city\": cities,\n            \"latitude\": latitudes,\n            \"longitude\": longitudes,\n        }\n    )\n    return df\n\n\ndef tsp(cities_df):\n    \"\"\"Traveling Salesman Problem using Pandas and Geopy\"\"\"\n\n    # create a list of cities\n    city_list = cities_df[\"city\"].to_list()\n    # shuffle the list to randomize the order of the cities\n    shuffle(city_list)\n    print(f\"Randomized city_list: {city_list}\")\n    # create a list of distances\n    distance_list = []\n    # loop through the list\n    for i in range(len(city_list)):\n        # if i is not the last item in the list\n        if i != len(city_list) - 1:\n            # get the distance between the current city and the next city\n            distance = geopy.distance.distance(\n                (\n                    cities_df[cities_df[\"city\"] == city_list[i]][\"latitude\"].values[0],\n                    cities_df[cities_df[\"city\"] == city_list[i]][\"longitude\"].values[0],\n                ),\n                (\n                    cities_df[cities_df[\"city\"] == city_list[i + 1]][\"latitude\"].values[\n                        0\n                    ],\n                    cities_df[cities_df[\"city\"] == city_list[i + 1]][\n                        \"longitude\"\n                    ].values[0],\n                ),\n            ).miles\n            # append the distance to the distance list\n            distance_list.append(distance)\n        # if i is the last item in the list\n        else:\n            # get the distance between the current city and the first city\n            distance = geopy.distance.distance(\n                (\n                    cities_df[cities_df[\"city\"] == city_list[i]][\"latitude\"].values[0],\n                    cities_df[cities_df[\"city\"] == city_list[i]][\"longitude\"].values[0],\n                ),\n                (\n                    cities_df[cities_df[\"city\"] == city_list[0]][\"latitude\"].values[0],\n                    cities_df[cities_df[\"city\"] == city_list[0]][\"longitude\"].values[0],\n                ),\n            ).miles\n            # append the distance to the distance list\n            distance_list.append(distance)\n    # return the sum of the distance list and the city list\n    total_distance = sum(distance_list)\n    return total_distance, city_list\n\n\ndef main(count, df=None):\n    \"\"\"Main function that runs the tsp similution multiple times\"\"\"\n    # create a list to hold the distances\n    distance_list = []\n    # create a list to hold the city lists\n    city_list_list = []\n    # loop through the simulation\n    if df is None:\n        cdf = create_cities_dataframe()\n    else:\n        cdf = df\n    for i in range(count):  # run the simulation x times\n        # get the distance and city list\n        distance, city_list = tsp(cdf)\n        print(f\"Running similation: {i}:  Found total distance: {distance}\")\n        # append the distance to the distance list\n        distance_list.append(distance)\n        # append the city list to the city list list\n        city_list_list.append(city_list)\n    # get the index of the shortest distance\n    shortest_distance_index = distance_list.index(min(distance_list))\n    # print the shortest distance\n    print(\"Shortest Distance: {}\".format(min(distance_list)))\n    # print the cities visited\n    print(\"Cities Visited: {}\".format(city_list_list[shortest_distance_index]))\n\n\n# create click group\n@click.group()\ndef cli():\n    \"\"\"This is a command-line tool that figures out the shortest distance to visit all cities in a list.\"\"\"\n\n\n# create a click command that takes a variable number of arguments of cities passed in\n@cli.command(\"cities\")\n@click.argument(\"cities\", nargs=-1)\n@click.option(\"--count\", default=5, help=\"Number of simulations to run\")\ndef cities_cli(cities, count):\n    \"\"\"This is a command-line tool that figures out the shortest distance to visit all cities in a list.\n\n    Example: ./fetch_cities_lat_long.py cities \"New York\" \"Knoxville\" --count 2\n    \"\"\"\n\n    # create a list of cities\n    city_list = my_cities(*cities)\n    # create a dataframe of cities and their latitudes and longitudes\n    cities_df = create_cities_dataframe(city_list)\n    # run the tsp function\n    main(count, cities_df)\n\n\n# add click command that runs the similation x times\n@cli.command(\"simulate\")\n@click.option(\"--count\", default=10, help=\"Number of times to run the simulation.\")\ndef simulate(count):\n    \"\"\"Run the simulation x times and print the shortest distance and cities visited.\n\n    Example:\n        ./fetch_cities_lat_long.py simulate --count 15\n\n    \"\"\"\n\n    print(f\"Running simulation {count} times\")\n    main(count)\n\n\nif __name__ == \"__main__\":\n    cli()\n\n\n# run the main function\nif __name__ == \"__main__\":\n    # pylint: disable=no-value-for-parameter\n    main()\n"}
{"type": "source_file", "path": "greedy_coin.py", "content": "#!/usr/bin/env python\n\"\"\" Greedy Coin Change Algorithm\n1. The function greedy_coin takes one argument, the amount of change to be given to the customer.\n2. The function prints a statement to tell the customer how much change they are getting.\n3. The function initializes a list of coins (quarters, dimes, nickels, and pennies) and a dictionary that maps the coins to their denominations.\n4. The function initializes a dictionary that will hold the number of coins of each type.\n5. The function goes through the list of coins and initializes the dictionary with a value of 0 for each coin.\n6. The function goes through the list of coins.\n7. The function subtracts the coin from the amount of change the customer is getting until the amount of change is less than the coin.\n8. The function then increments the number of coins of that type by 1.\n9. The function prints the number of each coin type the customer is getting.\n10. The function returns the dictionary with the number of each coin type. \n\"\"\"\n\nimport click\n\n\ndef greedy_coin(change):\n    \"\"\"Return a dictionary with the coin type as the key and the number of coins as the value\"\"\"\n\n    print(f\"Your change for {change}: \")\n    coins = [0.25, 0.10, 0.05, 0.01]\n    coin_lookup = {0.25: \"quarter\", 0.10: \"dime\", 0.05: \"nickel\", 0.01: \"penny\"}\n    coin_dict = {}\n    for coin in coins:\n        coin_dict[coin] = 0\n    for coin in coins:\n        while change >= coin:\n            change -= coin\n            coin_dict[coin] += 1\n    for coin in coin_dict:\n        if coin_dict[coin] > 0:\n            print(f\"{coin_dict[coin]} {coin_lookup[coin]}\")\n    return coin_dict\n\n\n@click.command()\n@click.argument(\"change\", type=float)\ndef main(change):\n    \"\"\"Return the minimum number of coins for a given change\n\n    Example: ./greedy_coin.py 0.99\n    \"\"\"\n    greedy_coin(change)\n\n\nif __name__ == \"__main__\":\n    # pylint: disable=no-value-for-parameter\n    main()\n"}
{"type": "source_file", "path": "algorithms/__init__.py", "content": ""}
{"type": "source_file", "path": "probability/roulette.py", "content": "#!/usr/bin/env python\n\"\"\"\nExamples of routines for simulating a roulette wheel.\nThe big takeaway is the concept of the law of large numbers.\nRoulette has a negative expected value, so you will lose money in the long run.\n\nFuture improvements:\n\n    * Allow for bets on multiple numbers and colors as well as odd/even, etc\n    * Allow for different bets on different spins\n    * Jupyter notebook with interactive widgets to show historical results\n    * Add a web interface to allow for bets and results using streamlit or gradio\n\n\"\"\"\nimport pandas as pd\nimport click\nimport sys\n\n\ndef build_wheel():\n    \"\"\"\n    Roulette wheel with 38 slots and probabilities of landing on each slot\n    \"\"\"\n\n    wheel = pd.DataFrame(\n        [\n            [0, \"green\", 0],\n            [1, \"red\", 1],\n            [2, \"black\", 2],\n            [3, \"red\", 3],\n            [4, \"black\", 4],\n            [5, \"red\", 5],\n            [6, \"black\", 6],\n            [7, \"red\", 7],\n            [8, \"black\", 8],\n            [9, \"red\", 9],\n            [10, \"black\", 10],\n            [11, \"black\", 11],\n            [12, \"red\", 12],\n            [13, \"black\", 13],\n            [14, \"red\", 14],\n            [15, \"black\", 15],\n            [16, \"red\", 16],\n            [17, \"black\", 17],\n            [18, \"red\", 18],\n            [19, \"red\", 19],\n            [20, \"black\", 20],\n            [21, \"red\", 21],\n            [22, \"black\", 22],\n            [23, \"red\", 23],\n            [24, \"black\", 24],\n            [25, \"red\", 25],\n            [26, \"black\", 26],\n            [27, \"red\", 27],\n            [28, \"black\", 28],\n            [29, \"black\", 29],\n            [30, \"red\", 30],\n            [31, \"black\", 31],\n            [32, \"red\", 32],\n            [33, \"black\", 33],\n            [34, \"red\", 34],\n            [35, \"black\", 35],\n            [36, \"red\", 36],\n            [37, \"green\", 0],\n        ],\n        columns=[\"slot\", \"color\", \"number\"],\n    )\n    # add the probabilities of landing on each slot\n    wheel[\"probability\"] = [1 / 38] * 38\n    return wheel\n\n\ndef spin_wheel(wheel):\n    \"\"\"\n    Simulate a single spin of the roulette wheel\n    \"\"\"\n    return wheel.sample(n=1, weights=\"probability\")\n\n\ndef simulate_spins(wheel, spins):\n    \"\"\"\n    Simulate multiple spins of the roulette wheel\n    \"\"\"\n    results = []\n    for _ in range(spins):\n        results.append(spin_wheel(wheel))\n    return pd.concat(results)\n\n\ndef generate_report(results, full_report=False):\n    \"\"\"\n    Generate a report on the results of the roulette wheel simulation\n    \"\"\"\n    print(f\"Total number of spins: {len(results)}\")\n    if full_report:\n        print(\n            f\"Number of times each number landed: {results['number'].value_counts()[results['number'].value_counts() > 1]}\"\n        )\n    # only print the color\n    print(f\"Number of times each color landed:\\n {results['color'].value_counts()}\")\n\n\ndef calculate_winnings(results, bet, count, color=None, number=None):\n    \"\"\"\n    Calculate the winnings of the roulette wheel simulation\n    using bet amount and number of spins for each color or number bet\n    \"\"\"\n    color_winnings = 0\n    number_winnings = 0\n    total_amount_bet = count * bet\n\n    if color == \"red\":\n        color_winnings = (\n            results[results[\"color\"] == \"red\"][\"slot\"].count() * (bet * 2)\n            - total_amount_bet\n        )\n    elif color == \"black\":\n        color_winnings = (\n            results[results[\"color\"] == \"black\"][\"slot\"].count() * (bet * 2)\n            - total_amount_bet\n        )\n    elif color == \"green\":\n        color_winnings = (\n            results[results[\"color\"] == \"green\"][\"slot\"].count() * (bet * 17)\n            - total_amount_bet\n        )\n\n    if number:\n        number_winnings = (\n            results[results[\"number\"] == number][\"slot\"].count() * (bet * 35)\n            - total_amount_bet\n        )\n        ncount = results[results[\"number\"] == number][\"slot\"].count()\n        print(f\"Total count for number bet on [{number}]: {ncount}\")\n\n    grand_total = sum([color_winnings, number_winnings])\n    return grand_total\n\n\n# build a function to print each run of the wheel with red and black colors using click style\ndef print_wheel(results):\n    \"\"\"\n    Print the results of the roulette wheel simulation\n    \"\"\"\n    for _, row in results.iterrows():\n        if row[\"color\"] == \"red\":\n            click.secho(f\"{row['slot']}\", fg=\"red\", nl=False)\n        elif row[\"color\"] == \"black\":\n            click.secho(f\"{row['slot']}\", fg=\"black\", nl=False)\n        else:\n            # if the number is 37 replace it with 00 and don't print number\n            if row[\"slot\"] == 37:\n                click.secho(\"00\", fg=\"green\", nl=False)\n            else:\n                click.secho(f\"{row['slot']}\", fg=\"green\", nl=False)\n        click.echo(\" \", nl=False)\n    click.echo()\n\n\n@click.group()\ndef cli():\n    \"\"\"\n    A group of commands for simulating a roulette wheel\n    \"\"\"\n\n\n@cli.command(\"spin\")\n@click.option(\"--count\", default=1, help=\"Total count of spins\")\n@click.option(\n    \"--color\", type=click.Choice([\"red\", \"black\", \"green\"]), help=\"Color to bet on\"\n)\n@click.option(\"--bet\", default=1, help=\"Amount to bet on each spin\")\n@click.option(\"--bet\", default=1, help=\"Amount of money to bet\")\n@click.option(\n    \"--number_bet\", default=None, help=\"Number to bet on\", type=click.IntRange(0, 36)\n)\ndef spin_option(count, bet, number_bet, color):\n    \"\"\"\n    Spin the roulette wheel:\n\n     Example:\n        Ten spins of the wheel with a bet of $1 on red\n        ./roulette.py spin --count 10 --color red --bet 1\n\n    \"\"\"\n    print(f\"Selected number of spins: {count}\")\n    if not number_bet and not color:\n        print(\"No bet selected\")\n    else:\n        print(f\"Selected bet amount: {bet}\")\n    if number_bet and color:\n        print(\"Can't bet on color and number at the same time\")\n        # exit the program if both color and number are selected\n        sys.exit()\n\n    print(f\"Selected number to bet on: {number_bet}\")\n    print(f\"Selected color to bet on: {color}\")\n\n    # build the wheel\n    wheel = build_wheel()\n    # simulate the spins\n    results = simulate_spins(wheel, count)\n    # print the results\n    print_wheel(results)\n    generate_report(results)\n    # print the winnings\n    total_winnings = calculate_winnings(\n        results=results, bet=bet, count=count, color=color, number=number_bet\n    )\n    print(f\"Total winnings: {total_winnings}\")\n\n\n# run the cli\nif __name__ == \"__main__\":\n    cli()\n"}
{"type": "source_file", "path": "parallel/__init__.py", "content": ""}
{"type": "source_file", "path": "heuristics/correlation_recommender_system.py", "content": "#!/usr/bin/env python\n\"\"\"Recommender system based on correlation between users and items.\"\"\""}
{"type": "source_file", "path": "probability/monty_hall.py", "content": "#!/usr/bin/env python\n\"\"\"Monty Hall problem simulation.\"\"\""}
{"type": "source_file", "path": "probability/poker.py", "content": "#!/usr/env/bin python\n\"\"\"\nA poker hand simulator\n\nFuture updates:\n\n- Add a web version\n- add granularity to the simulation to allow for hands of same type to be ranked:  \ni.e. 2 pair of 10s and 2 pair of 9s.  Currently, the simulator will only rank the\nhighest pair in each hand.\n\n\"\"\"\n\nimport random\nimport click\n\n\ndef deck_of_cards():\n    \"\"\"\n    Create a deck of cards\n    \"\"\"\n    suits = [\"H\", \"D\", \"C\", \"S\"]\n    ranks = [str(i) for i in range(2, 11)] + [\"J\", \"Q\", \"K\", \"A\"]\n    deck = []\n    for suit in suits:\n        for rank in ranks:\n            deck.append(rank + suit)\n    return deck\n\n\ndef full_name_suit(suit):\n    \"\"\"\n    Return the full name of the suit\n    \"\"\"\n    if suit == \"H\":\n        return \"Hearts\"\n    elif suit == \"D\":\n        return \"Diamonds\"\n    elif suit == \"C\":\n        return \"Clubs\"\n    elif suit == \"S\":\n        return \"Spades\"\n    else:\n        return \"Unknown\"\n\n\ndef deal_hand(deck, n=5):\n    \"\"\"\n    Deal a hand of cards\n    \"\"\"\n    return random.sample(deck, n)\n\n\ndef display_poker_hand():\n    \"\"\"Returns all possible poker hands with rank\"\"\"\n\n    poker_hand_rank = {\n        \"Royal Flush\": 10,\n        \"Straight Flush\": 9,\n        \"Four of a Kind\": 8,\n        \"Full House\": 7,\n        \"Flush\": 6,\n        \"Straight\": 5,\n        \"Three of a Kind\": 4,\n        \"Two Pair\": 3,\n        \"One Pair\": 2,\n        \"High Card\": 1,\n    }\n    return poker_hand_rank\n\n\n# build an example poker hand of all types of hands\ndef build_poker_hand():\n    \"\"\"\n    Build all example poker hands\n    \"\"\"\n    poker_hand = {\n        \"Royal Flush\": [\"10H\", \"JH\", \"QH\", \"KH\", \"AH\"],\n        \"Straight Flush\": [\"9H\", \"10H\", \"JH\", \"QH\", \"KH\"],\n        \"Four of a Kind\": [\"10H\", \"10D\", \"10C\", \"10S\", \"AH\"],\n        \"Full House\": [\"10H\", \"10D\", \"10C\", \"AH\", \"AD\"],\n        \"Flush\": [\"10H\", \"JH\", \"QH\", \"KH\", \"2H\"],\n        \"Straight\": [\"9H\", \"10D\", \"JC\", \"QH\", \"KH\"],\n        \"Three of a Kind\": [\"10H\", \"10D\", \"10C\", \"KH\", \"AH\"],\n        \"Two Pair\": [\"10H\", \"10D\", \"JC\", \"JH\", \"KH\"],\n        \"One Pair\": [\"10H\", \"10D\", \"JC\", \"QH\", \"KH\"],\n        \"High Card\": [\"10H\", \"JD\", \"JC\", \"QH\", \"KH\"],\n    }\n    return poker_hand\n\n\n# build function that displays the probability of each hand of poker\ndef display_poker_hand_probability():\n    \"\"\"\n    Display the probability of each hand of poker\n    \"\"\"\n    poker_hand_probability = {\n        \"Royal Flush\": 0.000154,\n        \"Straight Flush\": 0.00139,\n        \"Four of a Kind\": 0.0240,\n        \"Full House\": 0.140,\n        \"Flush\": 0.196,\n        \"Straight\": 0.39,\n        \"Three of a Kind\": 2.11,\n        \"Two Pair\": 4.75,\n        \"One Pair\": 42.2,\n        \"High Card\": 50.1,\n    }\n    return poker_hand_probability\n\n\ndef evaluate_poker_hand(hand):\n    \"\"\"\n    Evaluate a poker hand\n    \"\"\"\n    # sort the hand\n    hand = sorted(hand)\n    # check for a flush\n    if len(set([card[-1] for card in hand])) == 1:\n        # check for a straight\n        if len(set([card[:-1] for card in hand])) == 5:\n            # check for a royal flush\n            if hand[0][:-1] == \"10\" and hand[-1][:-1] == \"A\":\n                return \"Royal Flush\"\n            else:\n                return \"Straight Flush\"\n        else:\n            return \"Flush\"\n    # check for a straight\n    elif len(set([card[:-1] for card in hand])) == 5:\n        return \"Straight\"\n    # check for a four of a kind\n    elif len(set([card[:-1] for card in hand])) == 2:\n        if len(set([card[:-1] for card in hand if card[:-1] == hand[0][:-1]])) == 1:\n            return \"Four of a Kind\"\n        else:\n            return \"Full House\"\n    # check for a three of a kind\n    elif len(set([card[:-1] for card in hand])) == 3:\n        if len(set([card[:-1] for card in hand if card[:-1] == hand[0][:-1]])) == 1:\n            return \"Three of a Kind\"\n        else:\n            return \"Two Pair\"\n    # check for a pair\n    elif len(set([card[:-1] for card in hand])) == 4:\n        return \"One Pair\"\n    else:\n        return \"High Card\"\n\n\ndef simulate_hands(deck, hands):\n    \"\"\"\n    Simulate multiple hands of cards\n    \"\"\"\n    results = []\n    for _ in range(hands):\n        results.append(deal_hand(deck))\n    return results\n\n\n# build a function to play two hands against each other\ndef play_poker_hand(hand1, hand2):\n    \"\"\"\n    Play two poker hands against each other\n    \"\"\"\n\n    hand1_rank = evaluate_poker_hand(hand1)\n    hand2_rank = evaluate_poker_hand(hand2)\n    hand1_rank_value = display_poker_hand()[hand1_rank]\n    hand2_rank_value = display_poker_hand()[hand2_rank]\n    # print the hands as well as the rank and type of hand\n    print(\"Hand 1: {} - {} - {}\".format(hand1, hand1_rank, hand1_rank_value))\n    print(\"Hand 2: {} - {} - {}\".format(hand2, hand2_rank, hand2_rank_value))\n    # determine the winner\n    if hand1_rank_value > hand2_rank_value:\n        return {\"winner\": \"Hand 1\", \"hand\": hand1}\n    elif hand1_rank_value < hand2_rank_value:\n        return {\"winner\": \"Hand 2\", \"hand\": hand2}\n    else:\n        return {\"winner\": \"Tie\", \"hand\": hand1}\n\n\n@click.group()\ndef cli():\n    \"\"\"\n    A poker hand simulator\n    \"\"\"\n\n\n@cli.command(\"info\")\n@click.option(\n    \"--probability\", is_flag=True, help=\"Display the probability of each hand of poker\"\n)\ndef info(probability):\n    \"\"\"\n    Displays all possible winning hands with examples\n    \"\"\"\n\n    poker_hand_rank = display_poker_hand()\n    poker_hand = build_poker_hand()\n    if probability:\n        poker_hand_probability = display_poker_hand_probability()\n        for hand, _ in poker_hand_rank.items():\n            # print probability of each hand with click colors and example and 1 in x chance\n            click.secho(\n                \"{} - {} - 1 in {:,} - {:4f}%\".format(\n                    hand,\n                    poker_hand[hand],\n                    1 / poker_hand_probability[hand],\n                    poker_hand_probability[hand],\n                ),\n                fg=\"yellow\",\n            )\n    else:\n        for hand in poker_hand_rank:\n            click.secho(f\"{hand}: ({poker_hand_rank[hand]})\", fg=\"green\")\n            click.secho(f\"{poker_hand[hand]}\", fg=\"white\")\n\n\n@cli.command(\"deal\")\n@click.option(\"--hands\", default=1, help=\"Number of hands to simulate\")\ndef deal(hands):\n    \"\"\"\n    Deal a hand of cards\n    \"\"\"\n    deck = deck_of_cards()\n    results = simulate_hands(deck, hands)\n    for hand in results:\n        # color the cards using click style\n        for card in hand:\n            if card[-1] in [\"H\", \"D\"]:\n                click.secho(f\"{card} \", fg=\"red\", nl=False)\n            else:\n                click.secho(f\"{card} \", fg=\"black\", nl=False)\n        click.echo()\n        # print the hand rank\n        hand_rank = evaluate_poker_hand(hand)\n        click.echo(f\"Hand Rank: {hand_rank}\")\n\n\n# build a play function that takes a bet\n@cli.command(\"play\")\n@click.option(\"name\", \"--name\", default=\"Player\", help=\"Name of the player\")\n@click.option(\"hand\", \"--hand\", default=1, help=\"Hand to play\")\n@click.option(\"--bet\", default=1, help=\"Amount of money to bet\")\ndef play(bet, name, hand):\n    \"\"\"\n    Play a hand of poker against the computer with a bet\n    \"\"\"\n\n    deck = deck_of_cards()\n    hand1 = deal_hand(deck)\n    hand2 = deal_hand(deck)\n    status = play_poker_hand(hand1, hand2)\n    # print the winner and the amount of money won or lost\n    if status[\"winner\"] == \"Hand 1\" and hand == 1:\n        click.secho(f\"{name} wins ${bet}! with Hand1\", fg=\"green\")\n    elif status[\"winner\"] == \"Hand 2\":\n        click.secho(f\"{name} loses ${bet}! with Hand2\", fg=\"red\")\n    elif status[\"winner\"] == \"Tie\":\n        click.secho(\"It's a tie!\", fg=\"yellow\")\n\n\n# build an interactive play function that takes a bet\n@cli.command(\"interactive\")\n@click.option(\"name\", \"--name\", default=\"Player\", help=\"Name of the player\")\n@click.option(\"rounds\", \"--rounds\", default=1, help=\"Number of rounds to play\")\n@click.option(\"money\", \"--money\", default=100, help=\"Amount of money to start with\")\ndef interactive(name, rounds, money):\n    \"\"\"\n    Play a hand of poker against the computer with a bet\n    \"\"\"\n    bet = 0\n    history = {\n        \"rounds\": 0,\n        \"expected_value\": {},\n        \"probability_of_hand\": {},\n        \"bet\": {},\n        \"wins\": 0,\n        \"losses\": 0,\n        \"ties\": 0,\n        \"money\": money,\n    }\n\n    for i in range(1, rounds + 1):\n        print(f\"Round {i}:  Money: ${history['money']}\")\n        deck = deck_of_cards()\n        hand1 = deal_hand(deck)\n        hand2 = deal_hand(deck)\n        hand_probability = display_poker_hand_probability()[evaluate_poker_hand(hand1)]\n        print(\"Hand 1: {} - {}\".format(hand1, evaluate_poker_hand(hand1)))\n        # print probability of hand1 rounded to 2 decimal places\n        print(\"Probability of Hand 1: {:.2f}%\".format(hand_probability))\n        # ask user how much they want to bet\n        bet = click.prompt(\"How much would you like to bet?\", type=int)\n        status = play_poker_hand(hand1, hand2)\n        history[\"probability_of_hand\"][f\"round{i}\"] = hand_probability\n        expected_value = (1 - (hand_probability * 0.01)) * abs(bet)\n        history[\"expected_value\"][f\"round{i}\"] = expected_value\n        history[\"bet\"][f\"round{i}\"] = bet\n        # print the winner and the amount of money won or lost\n        if status[\"winner\"] == \"Hand 1\":\n            click.secho(f\"{name} wins ${bet}! with Hand1\", fg=\"green\")\n        elif status[\"winner\"] == \"Hand 2\":\n            click.secho(f\"{name} loses ${bet}! with Hand2\", fg=\"red\")\n            bet = bet * -1\n        elif status[\"winner\"] == \"Tie\":\n            bet = 0\n            click.secho(\"It's a tie!\", fg=\"yellow\")\n\n        # update the history\n        history[\"rounds\"] += 1\n        history[\"money\"] += bet\n        if status[\"winner\"] == \"Hand 1\":\n            history[\"wins\"] += 1\n        elif status[\"winner\"] == \"Hand 2\":\n            history[\"losses\"] += 1\n        elif status[\"winner\"] == \"Tie\":\n            history[\"ties\"] += 1\n    # print the history\n    click.secho(f\"Rounds: {history['rounds']}\", fg=\"green\")\n    click.secho(f\"Wins: {history['wins']}\", fg=\"green\")\n    click.secho(f\"Losses: {history['losses']}\", fg=\"red\")\n    click.secho(f\"Ties: {history['ties']}\", fg=\"yellow\")\n    click.secho(f\"Money: {history['money']}\", fg=\"green\")\n    click.secho(f\"Expected Value: {history['expected_value']}\", fg=\"green\")\n    click.secho(f\"Probability of Hand: {history['probability_of_hand']}\", fg=\"green\")\n    click.secho(f\"Bets: {history['bet']}\", fg=\"green\")\n    # sum of expected value vs money\n    expected_value = sum(history[\"expected_value\"].values())\n    click.secho(\n        f\"Expected Value Total: {expected_value} vs Money {history['money']}\", fg=\"red\"\n    )\n\n\nif __name__ == \"__main__\":\n    cli()\n"}
{"type": "source_file", "path": "heuristics/__init__.py", "content": ""}
{"type": "source_file", "path": "probability/startup_game.py", "content": "#!/usr/bin/env python\n\nimport random\nimport click\n\n\ndef generate_true_false(probability=0.23, num=4):\n    \"\"\"Return True/False with probability\n\n    Args:\n        probability (floating point decimal): probability of True/False ex. [0.5, 0.5] or [0.023, 0.977]\n        num (int): number of scenarios to generate\n\n    \"\"\"\n    # print probability as a percentage with 2 decimal places and % sign using f-string\n    print(f\"Probability of True: {probability*100:.2f}%\")\n    scene_probability = [probability, 1 - probability]\n    scenarios = [\n        random.choices([True, False], scene_probability)[0] for _ in range(num)\n    ]\n    print(\"Startup SUCCESS: {}\".format(scenarios.count(True)))\n    print(\"Startup FAIL: {}\".format(scenarios.count(False)))\n    # print actual ratio of True/False formatted to 4 decimal places and percentage\n    print(\"Ratio True/False: {:.4f}%\".format(scenarios.count(True) / num * 100))\n    return scenarios\n\n\n# create function that accepts value of startup, percentage of company owned and a number of scenarios\ndef calculate_value(\n    startup_valuation=100000000,\n    percent_owned=0.01,\n    simulations=4,\n    probability=0.23,\n):\n    \"\"\"Select the amount of startups worked for in a row\n    Assumes 1 in 43 startups succeed\n    Assumes 1% of company owned\n    Assumes 100 million valuation\n    Assumes 4 startups worked for in a row (about 16 years of career)\n    \"\"\"\n    total = 0\n    for simulation in range(1, simulations + 1):\n        # generate scenarios with probability 0.5\n        scenarios = generate_true_false(probability, simulations)\n        # if True, add value of startup to total\n        if scenarios[0]:\n            total += startup_valuation * percent_owned\n        # if False, subtract value of startup from total\n        else:\n            total -= 0\n        # print total value of startup\n        print(f\"Cumulative Total value of startup: {total} Company #{simulation}\")\n    return total\n\n\n# create function that uses calculate_value function to determine how many people earned money from startups and total\ndef calculate_value_multiple(\n    startup_valuation=100000000,\n    percent_owned=0.01,\n    simulations=4,\n    probability=0.023,\n    people=1000,\n):\n    \"\"\"Calculate the value of startup for multiple people\n\n    Args:\n        startup_valuation (int): value of startup\n        percent_owned (float): percent of company owned\n        simulations (int): number of startups worked for in a row\n        probability (float): probability of startup success\n        people (int): number of people to simulate\n\n    Returns:\n        int: total value of startup for all people\n    \"\"\"\n    total = 0\n    count_people_making_money = 0\n    for person in range(1, people + 1):\n        # calculate value of startup for each person\n        if (\n            calculate_value(startup_valuation, percent_owned, simulations, probability)\n            > 0\n        ):\n            count_people_making_money += 1\n        total += calculate_value(\n            startup_valuation=startup_valuation,\n            percent_owned=percent_owned,\n            simulations=simulations,\n            probability=probability,\n        )\n        print(f\"Total value of startup for all people: {total} Person #{person}\")\n    # print average value of startup for all people\n    print(f\"Average value of startup for all people: {total/people}\")\n    # print how many people earned money from startup\n    print(f\"Number of people making money from startup: {count_people_making_money}\")\n    # print how many people making no money from startup\n    print(\n        f\"Number of people making no money from startup: {people - count_people_making_money}\"\n    )\n    # print percentage of people making money from startup\n    print(\n        f\"Percentage of people making money from startup: {count_people_making_money/people*100:.2f}%\"\n    )\n\n    return total\n\n\ndef simulate_investor(\n    startup_valuation=None, investments=None, simulations=100, probability=0.023\n):\n    \"\"\"Simulate a venture capitalist investing in a porfolio of companies\"\"\"\n    total = 0\n    low_range, high_range = startup_valuation\n    low_range_investments, high_range_investments = investments\n    accumulated_investments = 0\n    print(\n        f\"low range investments: {low_range_investments} high range investments: {high_range_investments}\"\n    )\n    for simulation in range(1, simulations + 1):\n        # generate scenarios with probability 0.5\n        scenarios = generate_true_false(probability, simulations)\n        # if True, add value of startup to total\n        percentage_owned = random.uniform(0.25, 0.50)\n        startup_valuation = random.randint(low_range, high_range)\n        amount_invested = random.randint(low_range_investments, high_range_investments)\n        accumulated_investments += amount_invested\n        # print accumulated_investment in millions\n        print(f\"Cumulative INVESTMENT: {accumulated_investments/1000000:.2f} million\")   \n        print(f\"Cumulative PAYOUT: {total/1000000:.2f} million\")\n        print(f\"Percentage owned: {percentage_owned}\")\n        if scenarios[0]:\n            total += startup_valuation * percentage_owned\n        # if False skip\n        else:\n            continue\n    return_on_investment = total - accumulated_investments\n    try:\n        percentage_return_on_investment = return_on_investment / total * 100\n    except ZeroDivisionError:\n        percentage_return_on_investment = 0\n    payoff_dictionary = {\n        \"percentage_return_on_investment\": percentage_return_on_investment,\n        \"amount_invested\": accumulated_investments,\n        \"amount_returned\": total,\n        \"return_on_investment\": return_on_investment,\n    }\n    return payoff_dictionary\n\n\ndef sanity_test(num):\n    \"\"\"Show the ratio of True/False is close to the probability via law or large numbers\"\"\"\n\n    # generate 10 scenarios with probability 0.5\n    generate_true_false([0.5, 0.5], num)\n    # generate 10 scenarios with probability 0.023 (1 in 43 startups succeed)\n    generate_true_false([0.023, 0.977], num)\n\n\n@click.group()\ndef cli():\n    \"\"\"Startup Game Simulator\"\"\"\n\n\n# add a command to the cli\n@cli.command(\"sanity\")\n@click.option(\"--num\", default=100, help=\"Number of scenarios to generate\")\ndef sanity(num):\n    \"\"\"Sanity test the simulation with a small number of scenarios\n\n    Example:\n        python startup_game.py sanity --num 10\n    \"\"\"\n\n    sanity_test(num=num)\n\n\n@cli.command(\"vcportfolio\")\n@click.option(\n    \"--startup_valuation\", default=\"10000000, 10000000000\", help=\"Value of startup range\"\n)\n@click.option(\n    \"--simulations\", default=100, help=\"Number of startups worked for in a row\"\n)\n@click.option(\"--probability\", default=0.023, help=\"Probability of startup success\")\n@click.option(\n    \"--investments\", default=\"10000, 10000000\", help=\"Amount invested range\"\n)\ndef vcportfolio(startup_valuation, simulations, probability, investments):\n    \"\"\"Simulate a venture capitalist investing in a porfolio of companies\n\n    Example:\n        python startup_game.py vcportfolio --startup_valuation (1000000, 100000000) --simulations 100 --probability 0.23\n    \"\"\"\n    startup_valuation = tuple(map(int, startup_valuation.split(\",\")))\n    investment_range = tuple(map(int, investments.split(\",\")))\n    print(f\"Startup Valuation: {startup_valuation}\")\n    print(f\"Investments: {investments}\")\n    click.echo(click.style(f\"Startup Valuation: {startup_valuation}\", fg=\"green\"))\n    click.echo(\n        click.style(f\"Simulations (Companies in Portfolio): {simulations}\", fg=\"green\")\n    )\n    click.echo(click.style(f\"Probability of success: {probability}\", fg=\"green\"))\n    # show return on investment for venture capitalist\n    roi = simulate_investor(\n        startup_valuation=startup_valuation,\n        investments=investment_range,\n        simulations=simulations,\n        probability=probability,\n    )\n    try:\n        click.echo(click.style(f\"Amount Invested: ${roi['amount_invested']/1000000:.2f}M\", fg=\"green\"))\n        click.echo(click.style(f\"Amount Returned: ${roi['amount_returned']/1000000:.2f}M\", fg=\"green\"))\n        click.echo(click.style(f\"Return on Investment: ${roi['return_on_investment']/1000000:.2f}M\", fg=\"green\"))\n        click.echo(click.style(f\"Percentage Return on Investment: {roi['percentage_return_on_investment']:.2f}%\", fg=\"green\"))\n    except TypeError:\n        click.echo(click.style(f\"Amount Invested: ${roi/1000000:.2f}M\", fg=\"green\"))\n        click.echo(click.style(f\"Amount Returned: ${roi/1000000:.2f}M\", fg=\"green\"))\n        click.echo(click.style(f\"Return on Investment: ${roi/1000000:.2f}M\", fg=\"green\"))\n        click.echo(click.style(f\"Percentage Return on Investment: 0%\", fg=\"green\"))\n\n@cli.command(\"simulate\")\n@click.option(\"--startup_valuation\", default=100000000, help=\"Value of startup\")\n@click.option(\"--percent_owned\", default=0.01, help=\"Percent of company owned\")\n@click.option(\"--simulations\", default=4, help=\"Number of startups worked for in a row\")\n@click.option(\"--probability\", default=0.023, help=\"Probability of success\")\ndef simulate(startup_valuation, percent_owned, simulations, probability):\n    \"\"\"Simulate a startup career\n\n    Example:\n        python startup_game.py simulate --startup_valuation 100000000 --percent_owned 0.01 --simulations 4 --probability 0.023\n    \"\"\"\n\n    total = calculate_value(startup_valuation, percent_owned, simulations, probability)\n    # use click colors to print total\n    click.secho(\"Total: {}\".format(total), fg=\"green\")\n\n\n# add a command to the cli\n@cli.command(\"simulate_multiple\")\n@click.option(\"--startup_valuation\", default=100000000, help=\"Value of startup\")\n@click.option(\"--percent_owned\", default=0.01, help=\"Percent of company owned\")\n@click.option(\"--simulations\", default=4, help=\"Number of startups worked for in a row\")\n@click.option(\"--probability\", default=0.023, help=\"Probability of success\")\n@click.option(\"--people\", default=1000, help=\"Number of people to simulate\")\ndef simulate_multiple(\n    startup_valuation, percent_owned, simulations, probability, people\n):\n    \"\"\"Simulate a startup career for multiple people\n\n    Example:\n        python startup_game.py simulate_multiple --startup_valuation 100000000\\\n            --percent_owned 0.01 --simulations 4 --probability 0.023 --people 1000\n    \"\"\"\n\n    total = calculate_value_multiple(\n        startup_valuation, percent_owned, simulations, probability, people\n    )\n    # use click colors to print total\n    click.secho(\"Total Earned: {}\".format(total), fg=\"green\")\n\n\n# run the code\nif __name__ == \"__main__\":\n    cli()\n"}
{"type": "source_file", "path": "status_predator_prey.py", "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nA simple predator-prey model using status strategies:  [\"dominance\", \"virtue\", \"achievment\"]\n\nInitial idea is figure out group membership effects on the predator-prey model where it is a zero sum game to achieve status.\n\nhttps://scientific-python.readthedocs.io/en/latest/notebooks_rst/3_Ordinary_Differential_Equations/02_Examples/Lotka_Volterra_model.html\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\nOther ideas:\n\n* Can we model an iterative prisoner's dilemma where multiple group memberships create a better outcome in status by playing the game\na metaheruistic game?\n\npossibile inspiration: https://github.com/INASIC/predator-prey_systems/blob/master/Modelling%20Predator-Prey%20Systems%20in%20Python.ipynb\n\n\"\"\"\nfrom random import random\n\nTOTAL_STATUS = 100\n\n\ndef get_status():\n    return random() * TOTAL_STATUS\n\n\ndef get_status_group(status):\n    if status < 25:\n        return \"low\"\n    elif status < 50:\n        return \"mid\"\n    else:\n        return \"high\"\n"}
{"type": "source_file", "path": "probability/making_nfl.py", "content": "#!/usr/bin/env python\n\nnfl_data_2014 = {\n    \"high_school_players\": 1086627,\n    \"drafted\": 256,\n    \"income_after_tax\": 252000,\n    \"years_to_play\": 3,\n    \"three_year_income\": 756000,\n    \"ncca_players\": 70147,\n    \"hs_to_ncca\": 0.065,\n    \"ncca_to_nfl\": 0.016,\n    \"hs_to_nfl\": 0.065 * 0.016,\n}\nexpected_value = nfl_data_2014[\"hs_to_nfl\"] * nfl_data_2014[\"three_year_income\"]\n# print odds of making it to the NFL are\nprint(\n    \"Odds of making it to the NFL are 1 in %s\"\n    % (nfl_data_2014[\"high_school_players\"] / nfl_data_2014[\"drafted\"])\n)\n\nprint(f\"Expected value of pursing NFL career: ${round(expected_value, 0)}\")\n# print percentage of high school players that make it to the NFL rounded to 1 decimal places\nprint(\n    f\"Percentage of high school players that make it to the NFL: {nfl_data_2014['hs_to_nfl'] * 100:.1f}%\"\n)\n"}
{"type": "source_file", "path": "tsp_dict.py", "content": "#!/usr/bin/env python\n\nimport random\n\n\ndef tsp(cities):\n    # create a list of cities\n    city_list = list(cities.keys())\n    # shuffle the list\n    random.shuffle(city_list)\n    # create a list of distances\n    distance_list = []\n    # loop through the list\n    for i in range(len(city_list)):\n        # if i is not the last item in the list\n        if i != len(city_list) - 1:\n            # get the distance between the current city and the next city\n            distance = cities[city_list[i]][city_list[i + 1]]\n            # append the distance to the distance list\n            distance_list.append(distance)\n        # if i is the last item in the list\n        else:\n            # get the distance between the current city and the first city\n            distance = cities[city_list[i]][city_list[0]]\n            # append the distance to the distance list\n            distance_list.append(distance)\n    # return the sum of the distance list and the city list\n    return sum(distance_list), city_list\n\n\n# main function\ndef main():\n    # create a dictionary of 10 American cities and their distances from each other\n    cities = {\n        \"New York\": {\n            \"New York\": 0,\n            \"Chicago\": 800,\n            \"Denver\": 1400,\n            \"Los Angeles\": 2100,\n        },\n        \"Chicago\": {\"New York\": 800, \"Chicago\": 0, \"Denver\": 600, \"Los Angeles\": 1300},\n        \"Denver\": {\"New York\": 1400, \"Chicago\": 600, \"Denver\": 0, \"Los Angeles\": 700},\n        \"Los Angeles\": {\n            \"New York\": 2100,\n            \"Chicago\": 1300,\n            \"Denver\": 700,\n            \"Los Angeles\": 0,\n        },\n    }\n\n    # call the tsp function and unpack the return values\n    distance, city_list = tsp(cities)\n    # print the distance and city list\n    print(\"The distance is {} and the city list is {}\".format(distance, city_list))\n\n    # call the tsp function\n    return tsp(cities)\n\n\ndef run():\n    # create a list of distances\n    distance_list = []\n    # create a list of city lists\n    city_list = []\n    # loop 100 times\n    for _ in range(100):\n        # call the main function\n        distance, cities = main()\n        # append the distance to the distance list\n        distance_list.append(distance)\n        # append the city list to the city list\n        city_list.append(cities)\n    # get the index of the minimum distance\n    index = distance_list.index(min(distance_list))\n    # print the minimum distance and the city list\n    print(min(distance_list), city_list[index])\n\n\nif __name__ == \"__main__\":\n    run()\n"}
{"type": "source_file", "path": "tsp_pandas.py", "content": "import numpy as np\nimport random\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\nimport pandas as pd\n\n\ndef create_cities():\n    df = pd.DataFrame(\n        {\n            \"city\": [\n                \"New York\",\n                \"Los Angeles\",\n                \"Chicago\",\n                \"Houston\",\n                \"Philadelphia\",\n                \"Phoenix\",\n                \"San Antonio\",\n                \"San Diego\",\n                \"Dallas\",\n                \"San Jose\",\n            ],\n            \"latitude\": [\n                40.7128,\n                34.0522,\n                41.8781,\n                29.7604,\n                39.9526,\n                33.4484,\n                29.4241,\n                32.7157,\n                32.7767,\n                37.3382,\n            ],\n            \"longitude\": [\n                -74.006,\n                -118.2437,\n                -87.6298,\n                -95.3698,\n                -75.1652,\n                -112.0740,\n                -98.4936,\n                -117.1611,\n                -96.7970,\n                -121.8863,\n            ],\n        }\n    )\n    return df\n\n\ndef tsp_pandas(df):\n    # create a new dataframe that will hold the shortest path\n    df_shortest = pd.DataFrame(columns=[\"city\", \"latitude\", \"longitude\"])\n    # randomly select a starting city\n    start_city = random.choice(df[\"city\"])\n    # add the starting city to the shortest path dataframe\n    df_shortest = df_shortest.append(df[df[\"city\"] == start_city])\n    # remove the starting city from the original dataframe\n    df = df[df[\"city\"] != start_city]\n    # loop through the original dataframe until it is empty\n    while not df.empty:\n        # create a list of distances from the last city in the shortest path to each city in the original dataframe\n        distances = []\n        for index, row in df.iterrows():\n            distance = np.sqrt(\n                (row[\"latitude\"] - df_shortest.iloc[-1][\"latitude\"]) ** 2\n                + (row[\"longitude\"] - df_shortest.iloc[-1][\"longitude\"]) ** 2\n            )\n            distances.append(distance)\n        # find the index of the city in the original dataframe that is closest to the last city in the shortest path\n        closest_city_index = distances.index(min(distances))\n        # add the closest city to the shortest path dataframe\n        df_shortest = df_shortest.append(df.iloc[closest_city_index])\n        # remove the closest city from the original dataframe\n        df = df.drop(df.index[closest_city_index])\n    # calculate the total distance of the shortest path\n    total_distance = 0\n    for index, row in df_shortest.iterrows():\n        if index == 0:\n            continue\n        distance = np.sqrt(\n            (row[\"latitude\"] - df_shortest.iloc[index - 1][\"latitude\"]) ** 2\n            + (row[\"longitude\"] - df_shortest.iloc[index - 1][\"longitude\"]) ** 2\n        )\n        total_distance += distance\n    # return the shortest path dataframe and the total distance\n    return df_shortest, total_distance\n\n\ndef main():\n    df = create_cities()\n    min_distance = 100000000\n    for _ in range(100):\n        df_shortest, total_distance = tsp_pandas(df)\n        if total_distance < min_distance:\n            min_distance = total_distance\n            min_df = df_shortest\n    print(min_df)\n    print(min_distance)\n\n\n# call main\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "translator.py", "content": "# build a for loop in python\nfor i in range(5):\n    print(i)\n\n# bash version\n# for i in {0..4}\n# do\n#    echo $i\n# done\n\n## csharp version\n# for (int i = 0; i < 5; i++)\n# {\n#    Console.WriteLine(i);\n# }\n"}

{"repo_info": {"repo_name": "rsocket-py", "repo_owner": "rsocket", "repo_url": "https://github.com/rsocket/rsocket-py"}}
{"type": "test_file", "path": "examples/test_examples.py", "content": "import os\nimport signal\nimport subprocess\nfrom time import sleep\n\nimport pytest\n\n\n@pytest.mark.timeout(20)\n@pytest.mark.parametrize('server_cli, client_cli', (\n        (\n                lambda unused_tcp_port: os.spawnlp(os.P_NOWAIT, 'python3', 'python3', './server.py',\n                                                   str(unused_tcp_port)),\n                lambda unused_tcp_port: subprocess.Popen(['python3', './client.py', str(unused_tcp_port)])\n        ),\n        (\n                lambda unused_tcp_port: os.spawnlp(os.P_NOWAIT, 'python3', 'python3', './server_quic.py',\n                                                   str(unused_tcp_port)),\n                lambda unused_tcp_port: subprocess.Popen(['python3', './client_quic.py', str(unused_tcp_port)])\n        ),\n        (\n                lambda unused_tcp_port: os.spawnlp(os.P_NOWAIT, 'python3', 'python3', './server_with_routing.py',\n                                                   '--port', str(unused_tcp_port)),\n                lambda unused_tcp_port: subprocess.Popen(['python3', './client_with_routing.py', str(unused_tcp_port)])\n        ),\n        (\n                lambda unused_tcp_port: run_java_class('io.rsocket.pythontest.ServerWithFragmentation',\n                                                       unused_tcp_port),\n                lambda unused_tcp_port: subprocess.Popen(['python3', './client_with_routing.py', str(unused_tcp_port)])\n        ),\n        (\n                lambda unused_tcp_port: os.spawnlp(os.P_NOWAIT, 'python3', 'python3', './server_with_routing.py',\n                                                   '--port', str(unused_tcp_port)),\n                lambda unused_tcp_port: subprocess.Popen(['python3', './client_rx.py', str(unused_tcp_port)])\n        ),\n        (\n                lambda unused_tcp_port: os.spawnlp(os.P_NOWAIT, 'python3', 'python3', './server_aiohttp_websocket.py',\n                                                   str(unused_tcp_port)),\n                lambda unused_tcp_port: subprocess.Popen(['python3', './client_websocket.py', str(unused_tcp_port)])\n        ),\n        (\n                lambda unused_tcp_port: os.spawnlp(os.P_NOWAIT, 'python3', 'python3', 'server_aiohttp_websocket.py',\n                                                   '--port', str(unused_tcp_port),\n                                                   '--with-ssl'),\n                lambda unused_tcp_port: subprocess.Popen(\n                    ['python3', './client_websocket.py', '--port', str(unused_tcp_port), '--with-ssl'])\n        ),\n        (\n                lambda unused_tcp_port: os.spawnlp(os.P_NOWAIT, 'python3', 'python3', './server_quart_websocket.py',\n                                                   '--port', str(unused_tcp_port)),\n                lambda unused_tcp_port: subprocess.Popen(\n                    ['python3', './client_websocket.py', '--port', str(unused_tcp_port)])\n        ),\n        (\n                lambda unused_tcp_port: run_java_class('io.rsocket.pythontest.Server', unused_tcp_port),\n                lambda unused_tcp_port: subprocess.Popen(\n                    ['python3', './run_against_example_java_server.py', str(unused_tcp_port)])\n        ),\n        (\n                lambda unused_tcp_port: os.spawnlp(os.P_NOWAIT, 'python3', 'python3', './server_with_routing.py',\n                                                   '--port', str(unused_tcp_port)),\n                lambda unused_tcp_port: subprocess.Popen(['java',\n                                                          '-cp', 'java/target/rsocket-examples-1.jar',\n                                                          'io.rsocket.pythontest.Client',\n                                                          '%d' % unused_tcp_port])\n        ),\n        (\n                lambda unused_tcp_port: os.spawnlp(os.P_NOWAIT, 'python3', 'python3', './server_with_lease.py',\n                                                   str(unused_tcp_port)),\n                lambda unused_tcp_port: subprocess.Popen(['java',\n                                                          '-cp', 'java/target/rsocket-examples-1.jar',\n                                                          'io.rsocket.pythontest.ClientWithLease',\n                                                          '%d' % unused_tcp_port])\n        ),\n))\ndef test_client_server_combinations(unused_tcp_port, server_cli, client_cli):\n    pid = server_cli(unused_tcp_port)\n\n    try:\n        sleep(2)\n        client = client_cli(unused_tcp_port)\n        client.wait(timeout=20)\n\n        assert client.returncode == 0\n    finally:\n        os.kill(pid, signal.SIGTERM)\n\n\ndef run_java_class(java_class: str, unused_tcp_port: int):\n    return os.spawnlp(os.P_NOWAIT, 'java', 'java',\n                      '-cp', 'java/target/rsocket-examples-1.jar', java_class,\n                      '%d' % unused_tcp_port)\n"}
{"type": "test_file", "path": "examples/tutorial/test_tutorials.py", "content": "import os\nimport signal\nimport subprocess\nfrom time import sleep\n\nimport pytest\n\n\n@pytest.mark.timeout(20)\n@pytest.mark.parametrize('step',\n                         [\n                             'step0',\n                             'step1',\n                             'step2',\n                             'step3',\n                             'step4',\n                             'step5',\n                             'step6',\n                             'step7',\n                             'step8',\n                             'reactivex']\n\n                         )\ndef test_client_server_combinations(step):\n    pid = os.spawnlp(os.P_NOWAIT, 'python3', 'python3', f'./{step}/chat_server.py')\n\n    try:\n        sleep(2)\n        client = subprocess.Popen(['python3', f'./{step}/chat_client.py'])\n        client.wait(timeout=20)\n\n        assert client.returncode == 0\n    finally:\n        os.kill(pid, signal.SIGTERM)\n"}
{"type": "test_file", "path": "performance/test_performance.py", "content": "import asyncio\nfrom contextlib import asynccontextmanager\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nimport pytest\n\nfrom performance.performance_client import PerformanceClient\nfrom performance.performance_server import run_server\nfrom rsocket.rsocket_server import RSocketServer\nfrom tests.tools.helpers import measure_time\n\n\n@pytest.mark.timeout(5)\n@pytest.mark.performance\nasync def test_request_response(unused_tcp_port):\n    async with run_against_server(unused_tcp_port) as client:\n        result = await record_runtime('request_response', client.request_response)\n\n        assert result is not None\n\n\n@pytest.mark.timeout(300)\n@pytest.mark.performance\nasync def test_request_stream(unused_tcp_port):\n    async with run_against_server(unused_tcp_port) as client:\n        arguments = dict(response_count=1,\n                         response_size=1_000_000)\n        result = await record_runtime(f'request_stream {arguments}',\n                                      lambda: client.request_stream(**arguments), iterations=1)\n\n        assert result is not None\n\n\n@pytest.mark.performance\nasync def test_large_request():\n    async with run_with_client(6565) as client:\n        result = await measure_time(client.large_request())\n        print(result.delta)\n\n\n@asynccontextmanager\nasync def run_against_server(unused_tcp_port: int) -> PerformanceClient:\n    server_ready = asyncio.Event()\n\n    server: Optional[RSocketServer] = None\n\n    def on_ready(rs):\n        nonlocal server\n        server_ready.set()\n        server = rs\n\n    server_task = asyncio.create_task(run_server(unused_tcp_port, on_ready=on_ready))\n\n    try:\n        await asyncio.sleep(1)  # wait for server\n        async with run_with_client(unused_tcp_port) as client:\n            await server_ready.wait()\n            yield client\n    finally:\n        await server.close()\n        server_task.cancel()\n\n\n@asynccontextmanager\nasync def run_with_client(unused_tcp_port):\n    async with PerformanceClient(unused_tcp_port) as client:\n        yield client\n\n\nasync def record_runtime(request_type, coroutine_generator, iterations=1000, output_filename='results.csv'):\n    run_times = []\n    last_result = None\n\n    for i in range(iterations):\n        start_time = datetime.now()\n        last_result = await coroutine_generator()\n        run_times.append(datetime.now() - start_time)\n\n    average_runtime = sum(run_times, timedelta(0)) / len(run_times)\n\n    with open(output_filename, 'a') as fd:\n        fd.write(f'{request_type}, {iterations}, {average_runtime.total_seconds()}\\n')\n\n    return last_result\n"}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/conftest.py", "content": "import functools\nimport logging\nimport re\nimport sys\nimport pytest\n\nfrom rsocket.frame_parser import FrameParser\nfrom tests.tools.fixtures_aioquic import pipe_factory_quic\nfrom tests.tools.fixtures_http3 import pipe_factory_http3\nfrom tests.tools.fixtures_quart import pipe_factory_quart_websocket\nfrom tests.tools.fixtures_tcp import pipe_factory_tcp\nfrom tests.tools.helpers_aiohttp import pipe_factory_aiohttp_websocket\nfrom tests.tools.fixtures_websockets import pipe_factory_websockets\n\npytest_plugins = [\n    \"tests.tools.fixtures_shared\",\n    \"tests.tools.fixtures_aiohttp\",\n    \"tests.tools.fixtures_graphql\",\n]\n\n\ndef setup_logging(level=logging.DEBUG, use_file: bool = False):\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n    console_handler.setLevel(level)\n\n    handlers = [console_handler]\n\n    if use_file:\n        file_handler = logging.FileHandler('tests.log')\n        file_handler.setFormatter(formatter)\n        file_handler.setLevel(level)\n        handlers.append(file_handler)\n\n    logging.basicConfig(level=level, handlers=handlers)\n\n\nsetup_logging(logging.WARN)\n\ntested_transports = [\n    'tcp',\n    'quart',\n    'aiohttp'\n]\n\nif sys.version_info[:3] < (3, 11, 5):\n    tested_transports += [\n        'quic',\n        'http3',\n        # 'websockets'\n    ]\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\"markers\", \"allow_error_log: marks tests which are allowed to have errors in the log\")\n\n\n@pytest.fixture(autouse=True)\ndef fail_on_error_log(caplog, request):\n    allow_log_error_marker = request.node.get_closest_marker('allow_error_log')\n\n    yield\n\n    def is_allowed_error(record):\n        message = record.message\n        if allow_log_error_marker is not None:\n            if 'regex_filter' in allow_log_error_marker.kwargs:\n                regex = re.compile(allow_log_error_marker.kwargs['regex_filter'])\n                return regex.search(message) is not None\n            return True\n\n        return False\n\n    records = caplog.get_records('call')\n    errors = [record.message for record in records if\n              record.levelno >= logging.ERROR and not is_allowed_error(record)]\n    assert not errors\n\n\n@pytest.fixture(params=tested_transports)\nasync def lazy_pipe(request, aiohttp_raw_server, unused_tcp_port, generate_test_certificates):  # noqa: F811\n    transport_id = request.param\n\n    logging.info('Testing transport %s on port %s (lazy)', transport_id, unused_tcp_port)\n\n    pipe_factory = get_pipe_factory_by_id(aiohttp_raw_server, transport_id, generate_test_certificates)\n    yield functools.partial(pipe_factory, unused_tcp_port)\n\n\n@pytest.fixture(params=tested_transports)\nasync def lazy_pipe_with_id(request, aiohttp_raw_server, unused_tcp_port, generate_test_certificates):  # noqa: F811\n    transport_id = request.param\n\n    logging.info('Testing transport %s on port %s (lazy)', transport_id, unused_tcp_port)\n\n    pipe_factory = get_pipe_factory_by_id(aiohttp_raw_server, transport_id, generate_test_certificates)\n    yield transport_id, functools.partial(pipe_factory, unused_tcp_port)\n\n\n@pytest.fixture(params=tested_transports)\nasync def pipe(request, aiohttp_raw_server, unused_tcp_port, generate_test_certificates):  # noqa: F811\n    transport_id = request.param\n\n    logging.info('Testing transport %s on port %s', transport_id, unused_tcp_port)\n\n    pipe_factory = get_pipe_factory_by_id(aiohttp_raw_server, transport_id, generate_test_certificates)\n    async with pipe_factory(unused_tcp_port) as components:\n        yield components\n\n\n@pytest.fixture\nasync def pipe_tcp(unused_tcp_port):\n    logging.info('Testing transport tcp (explicitly) on port %s', unused_tcp_port)\n\n    async with pipe_factory_tcp(unused_tcp_port) as components:\n        yield components\n\n\n@pytest.fixture\nasync def lazy_pipe_tcp(unused_tcp_port):  # noqa: F811\n    logging.info('Testing transport tcp (explicitly) on port %s (lazy)', unused_tcp_port)\n\n    yield functools.partial(pipe_factory_tcp, unused_tcp_port)\n\n\ndef get_pipe_factory_by_id(aiohttp_raw_server,\n                           transport_id: str,\n                           generate_test_certificates):  # noqa: F811\n    if transport_id == 'tcp':\n        return pipe_factory_tcp\n    if transport_id == 'quart':\n        return pipe_factory_quart_websocket\n    if transport_id == 'aiohttp':\n        return functools.partial(pipe_factory_aiohttp_websocket, aiohttp_raw_server)\n    if transport_id == 'quic':\n        return functools.partial(pipe_factory_quic, generate_test_certificates)\n    if transport_id == 'http3':\n        return functools.partial(pipe_factory_http3, generate_test_certificates)\n    if transport_id == 'websockets':\n        return pipe_factory_websockets\n\n\n@pytest.fixture\ndef pipe_factory_by_id(aiohttp_raw_server, unused_tcp_port, generate_test_certificates):\n    def factory(transport_id):\n        return get_pipe_factory_by_id(aiohttp_raw_server, transport_id, generate_test_certificates)\n\n    return factory\n\n\n@pytest.fixture\nasync def pipe_tcp_without_auto_connect(unused_tcp_port):\n    logging.info('Testing transport tcp (explicitly) on port %s (no-autoconnect)', unused_tcp_port)\n\n    async with pipe_factory_tcp(unused_tcp_port, auto_connect_client=False) as components:\n        yield components\n\n\n@pytest.fixture\ndef frame_parser():\n    return FrameParser()\n"}
{"type": "test_file", "path": "tests/reactivestreams/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/reactivestreams/test_reactivestreams.py", "content": "from reactivestreams import reactivestreams\n\n\ndef test_reactivestreams():\n    assert reactivestreams() == 'reactivestreams-0.1'\n"}
{"type": "test_file", "path": "tests/rsocket/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/rsocket/cloudevents/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/rsocket/cloudevents/test_route_cloud_events.py", "content": "import json\n\nfrom cloudevents.conversion import to_json, from_json\nfrom cloudevents.pydantic import CloudEvent\n\nfrom rsocket.cloudevents.serialize import cloud_event_deserialize, cloud_event_serialize\nfrom rsocket.extensions.helpers import composite, route\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\n\n\nasync def test_routed_cloudevents(lazy_pipe):\n    router = RequestRouter(cloud_event_deserialize,\n                           cloud_event_serialize)\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response('cloud_event')\n    async def response_request(value: CloudEvent) -> CloudEvent:\n        return CloudEvent.create(attributes={\n            'type': 'io.spring.event.Foo',\n            'source': 'https://spring.io/foos'\n        }, data=json.dumps(json.loads(value.data)))\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        event = CloudEvent.create(attributes={\n            'type': 'io.spring.event.Foo',\n            'source': 'https://spring.io/foos'\n        }, data=json.dumps({'value': 'Dave'}))\n\n        response = await client.request_response(Payload(data=to_json(event), metadata=composite(route('cloud_event'))))\n\n        response_event = from_json(CloudEvent, response.data)\n        response_data = json.loads(response_event.data)\n\n        assert response_data['value'] == 'Dave'\n"}
{"type": "test_file", "path": "tests/rsocket/helpers.py", "content": "import asyncio\nimport json\nimport os\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom datetime import timedelta, datetime\nfrom math import ceil\nfrom typing import Tuple, Any\nfrom typing import Type, Callable\n\nfrom rsocket.frame_helpers import str_to_bytes, ensure_bytes\nfrom rsocket.helpers import create_future, noop\nfrom rsocket.logger import logger\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler, RequestHandler\nfrom rsocket.rsocket_base import RSocketBase\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.transport import Transport\n\n\ndef data_bits(data: bytes, name: str = None):\n    return ''.join(format(byte, '08b') for byte in data)\n\n\ndef build_frame(*items) -> bytes:\n    frame_bits = ''.join(items)\n    bits_length = len(frame_bits)\n    nearest_round_length = int(8 * ceil(bits_length / 8.))\n    frame_bits = frame_bits.ljust(nearest_round_length, '0')\n    return bitstring_to_bytes(frame_bits)\n\n\ndef bitstring_to_bytes(s: str) -> bytes:\n    return int(s, 2).to_bytes((len(s) + 7) // 8, byteorder='big')\n\n\ndef bits(bit_count, value, comment) -> str:\n    return f'{value:b}'.zfill(bit_count)\n\n\ndef future_from_payload(request: Payload):\n    return create_future(to_test_response_payload(request))\n\n\ndef to_test_response_payload(request):\n    return Payload(b'data: ' + request.data,\n                   b'meta: ' + request.metadata)\n\n\ndef assert_no_open_streams(client: RSocketBase, server: RSocketBase):\n    logger().info('Checking for open client streams')\n\n    if client is not None:\n        assert len(client._stream_control._streams) == 0, 'Client has open streams'\n\n    logger().info('Checking for open server streams')\n\n    if server is not None:\n        assert len(server._stream_control._streams) == 0, 'Server has open streams'\n\n\nclass IdentifiedHandler(BaseRequestHandler):\n    def __init__(self, server_id: int, delay=timedelta(0)):\n        self._delay = delay\n        self._server_id = server_id\n\n\nclass IdentifiedHandlerFactory:\n    def __init__(self,\n                 server_id: int,\n                 handler_factory: Type[IdentifiedHandler],\n                 delay=timedelta(0),\n                 on_handler_create: Callable[[RequestHandler], None] = noop):\n        self._on_handler_create = on_handler_create\n        self._delay = delay\n        self._server_id = server_id\n        self._handler_factory = handler_factory\n\n    def factory(self) -> BaseRequestHandler:\n        handler = self._handler_factory(self._server_id, self._delay)\n        self._on_handler_create(handler)\n        return handler\n\n\nasync def force_closing_connection(transport, delay=timedelta(0)):\n    await asyncio.sleep(delay.total_seconds())\n    await transport.close()\n\n\n@dataclass\nclass ServerContainer:\n    server: RSocketServer = None\n    transport: Transport = None\n\n\ndef get_components(pipe) -> Tuple[RSocketServer, RSocketClient]:\n    return pipe\n\n\ndef to_json_bytes(item: Any) -> bytes:\n    return str_to_bytes(json.dumps(item))\n\n\ndef create_data(base: bytes, multiplier: int, limit: float = None):\n    return b''.join([ensure_bytes(str(i)) + base for i in range(multiplier)])[0:limit]\n\n\ndef create_large_random_data(size: int):\n    return bytearray(os.urandom(size))\n\n\ndef benchmark_method(method: Callable, iterations: int) -> float:\n    with measure_runtime() as result:\n        for i in range(iterations):\n            method()\n\n    return result.time.total_seconds() * 1000 / iterations\n\n\n@dataclass\nclass Result:\n    time: timedelta = None\n\n\n@contextmanager\ndef measure_runtime():\n    result = Result()\n    start = datetime.now()\n    yield result\n    result.time = datetime.now() - start\n"}
{"type": "test_file", "path": "tests/rsocket/misbehaving_rsocket.py", "content": "from rsocket.frame import Frame\nfrom rsocket.transports.transport import Transport\n\n\nclass MisbehavingRSocket:\n    def __init__(self, transport: Transport):\n        self._transport = transport\n\n    async def send_frame(self, frame: Frame):\n        await self._transport.send_frame(frame)\n\n\nclass BrokenFrame:\n    def __init__(self, content: bytes):\n        self._content = content\n\n    def serialize(self) -> bytes:\n        return self._content\n\n\nclass UnknownFrame(Frame):\n    def __init__(self):\n        super().__init__(34)\n\n    def parse(self, buffer: bytes, offset: int):\n        pass\n"}
{"type": "test_file", "path": "tests/rsocket/test_authentication.py", "content": "from asyncio import Event\nfrom typing import Optional\n\nimport pytest\n\nfrom rsocket.error_codes import ErrorCode\nfrom rsocket.exceptions import RSocketApplicationError, RSocketUnknownAuthType\nfrom rsocket.extensions.authentication import AuthenticationSimple\nfrom rsocket.extensions.authentication_types import WellKnownAuthenticationTypes\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.extensions.helpers import composite, authenticate_simple, authenticate_bearer\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import create_response\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom tests.rsocket.helpers import bits, data_bits, build_frame\n\n\nasync def test_authentication_frame_bearer():\n    data = build_frame(\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_AUTHENTICATION.value.id, 'Mime ID'),\n        bits(24, 9, 'Metadata length'),\n        bits(1, 1, 'Well known authentication type'),\n        bits(7, WellKnownAuthenticationTypes.BEARER.value.id, 'Authentication ID'),\n        data_bits(b'abcd1234')\n    )\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(data)\n\n    auth = composite_metadata.items[0].authentication\n    assert auth.token == b'abcd1234'\n\n    serialized_data = composite_metadata.serialize()\n\n    assert serialized_data == data\n\n\nasync def test_authentication_frame_simple():\n    data = build_frame(\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_AUTHENTICATION.value.id, 'Mime ID'),\n        bits(24, 19, 'Metadata length'),\n        bits(1, 1, 'Well known authentication type'),\n        bits(7, WellKnownAuthenticationTypes.SIMPLE.value.id, 'Authentication ID'),\n        bits(16, 8, 'Username length'),\n        data_bits(b'username'),\n        data_bits(b'password')\n    )\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(data)\n\n    auth = composite_metadata.items[0].authentication\n    assert auth.username == b'username'\n    assert auth.password == b'password'\n\n    serialized_data = composite_metadata.serialize()\n\n    assert serialized_data == data\n\n\nasync def test_authentication_success_on_setup(lazy_pipe):\n    class Handler(BaseRequestHandler):\n        def __init__(self):\n            self._authenticated = False\n\n        async def on_setup(self,\n                           data_encoding: bytes,\n                           metadata_encoding: bytes,\n                           payload: Payload):\n            composite_metadata = self._parse_composite_metadata(payload.metadata)\n            authentication: AuthenticationSimple = composite_metadata.items[0].authentication\n            if authentication.username != b'user' or authentication.password != b'12345':\n                raise Exception('Authentication rejected')\n\n            self._authenticated = True\n\n        async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n            if not self._authenticated:\n                raise RSocketApplicationError(\"Not authenticated\")\n\n            return create_response(b'response')\n\n    async with lazy_pipe(\n            client_arguments={'setup_payload': Payload(metadata=composite(authenticate_simple('user', '12345')))},\n            server_arguments={'handler_factory': Handler}) as (server, client):\n        result = await client.request_response(Payload(b'request'))\n\n        assert result.data == b'response'\n\n\n@pytest.mark.allow_error_log(regex_filter='(Protocol|Setup|Unknown) error')\nasync def test_authentication_failure_on_setup(lazy_pipe):\n    received_error_event = Event()\n    received_error: Optional[tuple] = None\n\n    class ServerHandler(BaseRequestHandler):\n        def __init__(self):\n            self._authenticated = False\n\n        async def on_setup(self,\n                           data_encoding: bytes,\n                           metadata_encoding: bytes,\n                           payload: Payload):\n            composite_metadata = self._parse_composite_metadata(payload.metadata)\n            authentication: AuthenticationSimple = composite_metadata.items[0].authentication\n            if authentication.username != b'user' or authentication.password != b'12345':\n                raise Exception('Authentication error')\n\n            self._authenticated = True\n\n        async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n            if not self._authenticated:\n                raise Exception(\"Not authenticated\")\n\n            return create_response(b'response')\n\n    class ClientHandler(BaseRequestHandler):\n        async def on_error(self, error_code: ErrorCode, payload: Payload):\n            nonlocal received_error\n            received_error = (error_code, payload)\n            received_error_event.set()\n\n    async with lazy_pipe(\n            client_arguments={\n                'handler_factory': ClientHandler,\n                'setup_payload': Payload(metadata=composite(authenticate_simple('user', 'wrong_password')))\n            },\n            server_arguments={\n                'handler_factory': ServerHandler\n            }) as (server, client):\n\n        with pytest.raises(RuntimeError):\n            await client.request_response(Payload(b'request'))\n\n        await received_error_event.wait()\n\n        assert received_error[0] == ErrorCode.REJECTED_SETUP\n        assert received_error[1] == Payload(b'Authentication error', b'')\n\n\nasync def test_authentication_types_unknown_id_raises_exception():\n    with pytest.raises(RSocketUnknownAuthType):\n        WellKnownAuthenticationTypes.require_by_id(98987)\n\n\nasync def test_authentication_types_unknown_name_returns_none():\n    result = WellKnownAuthenticationTypes.get_by_name(b'non-existing-authentication-type')\n\n    assert result is None\n\n\ndef test_authentication_type_require_by_id():\n    mimetype = WellKnownAuthenticationTypes.require_by_id(0x01)\n\n    assert mimetype is WellKnownAuthenticationTypes.BEARER.value.name\n\n\ndef test_authentication_type_get_by_name():\n    mimetype = WellKnownAuthenticationTypes.get_by_name(b'bearer')\n\n    assert mimetype is WellKnownAuthenticationTypes.BEARER.value.id\n\n\ndef test_metadata_authentication_bearer():\n    metadata = build_frame(\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_AUTHENTICATION.value.id, 'Mime ID'),\n        bits(24, 6, 'Metadata length'),\n        bits(1, 1, 'Well known authentication type'),\n        bits(7, WellKnownAuthenticationTypes.BEARER.value.id, 'Authentication ID'),\n        data_bits(b'12345'),\n    )\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(metadata)\n\n    assert composite_metadata.items[0].authentication.token == b'12345'\n\n    assert composite_metadata.serialize() == metadata\n\n    metadata_from_helper = composite(authenticate_bearer('12345'))\n\n    assert metadata_from_helper == metadata\n\n\nasync def test_authentication_helper_bearer():\n    metadata = composite(authenticate_bearer('token'))\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(metadata)\n\n    assert composite_metadata.items[0].authentication.token == b'token'\n"}
{"type": "test_file", "path": "tests/rsocket/test_cli_command.py", "content": "import io\nimport sys\nimport tempfile\nfrom asyncio import sleep\n\nimport pytest\nfrom asyncclick.testing import CliRunner\nfrom decoy import Decoy\n\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.cli.command import parse_uri, build_composite_metadata, create_request_payload, get_metadata_value, \\\n    create_setup_payload, normalize_data, normalize_limit_rate, RequestType, get_request_type, parse_headers, \\\n    normalize_metadata_mime_type, execute_request, command\nfrom rsocket.extensions.helpers import route, authenticate_simple, authenticate_bearer\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.frame import MAX_REQUEST_N\nfrom rsocket.helpers import create_future, create_response\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom tests.rsocket.helpers import create_data\nfrom tests.tools.fixtures_quart import pipe_factory_quart_websocket\nfrom tests.tools.fixtures_tcp import pipe_factory_tcp\n\n\ndef test_parse_uri():\n    parsed = parse_uri('tcp://localhost:6565')\n\n    assert parsed.schema == 'tcp'\n    assert parsed.port == 6565\n    assert parsed.host == 'localhost'\n\n\ndef test_parse_uri_wss():\n    parsed = parse_uri('wss://localhost/path')\n\n    assert parsed.schema == 'wss'\n    assert parsed.port is None\n    assert parsed.host == 'localhost'\n    assert parsed.path == 'path'\n\n\n@pytest.mark.parametrize('route_path, auth_simple, auth_bearer, expected', (\n        (None, None, None, []),\n        ('path1', None, None, [route('path1')]),\n        ('path1', 'user:pass', None, [route('path1'), authenticate_simple('user', 'pass')]),\n        ('path1', None, 'token', [route('path1'), authenticate_bearer('token')]),\n        ('path1', 'user:pass', 'token', Exception),\n))\ndef test_build_composite_metadata(route_path, auth_simple, auth_bearer, expected):\n    if isinstance(expected, list):\n        actual = build_composite_metadata(auth_simple, route_path, auth_bearer)\n\n        assert actual == expected\n    else:\n        with pytest.raises(expected):\n            build_composite_metadata(auth_simple, route_path, auth_bearer)\n\n\ndef test_create_request_payload():\n    payload = create_request_payload(\n        None, None, None\n    )\n\n    assert payload.data is None\n    assert payload.metadata is None\n\n\n@pytest.mark.parametrize('composite_items, metadata, expected', (\n        ([], None, None),\n        ([], 'metadata1', b'metadata1'),\n        ([route('somewhere')], b'metadata1', b'\\xfe\\x00\\x00\\n\\tsomewhere'),\n))\ndef test_get_metadata_value(composite_items, metadata, expected):\n    result = get_metadata_value(composite_items, metadata)\n\n    assert result == expected\n\n\n@pytest.mark.parametrize('data, metadata, expected', (\n        (None, None, None),\n        ('data', None, Payload(b'data')),\n        ('data', 'metadata', Payload(b'data', b'metadata')),\n        (None, 'metadata', Payload(None, b'metadata')),\n))\ndef test_create_setup_payload(data, metadata, expected):\n    result = create_setup_payload(data, metadata)\n\n    assert result == expected\n\n\ndef test_normalize_data():\n    data = normalize_data(None, None)\n\n    assert data is None\n\n\ndef test_normalize_data_from_file():\n    with tempfile.NamedTemporaryFile() as fd:\n        fixture_data = create_data(b'1234567890', 20)\n        fd.write(fixture_data)\n        fd.flush()\n\n        data = normalize_data(None, fd.name)\n\n        assert data == fixture_data\n\n\ndef test_normalize_data_from_stdin():\n    fixture_data = create_data(b'1234567890', 20)\n    stdin = io.BytesIO(fixture_data)\n    sys.stdin = stdin\n\n    data = normalize_data('-', None)\n\n    assert data == fixture_data\n\n\ndef test_normalize_data_from_stdin_takes_precedence_over_load_from_file():\n    with tempfile.NamedTemporaryFile() as fd:\n        fixture_data_file = create_data(b'1234567890', 20)\n        fd.write(fixture_data_file)\n        fd.flush()\n\n        fixture_data_stdin = create_data(b'0987654321', 20)\n        stdin = io.BytesIO(fixture_data_stdin)\n        sys.stdin = stdin\n\n        data = normalize_data('-', fd.name)\n\n        assert data == fixture_data_stdin\n\n\n@pytest.mark.parametrize('limit_rate, expected', (\n        (MAX_REQUEST_N, MAX_REQUEST_N),\n        (None, MAX_REQUEST_N),\n        (3, 3),\n        (0, MAX_REQUEST_N),\n        (-5, MAX_REQUEST_N),\n))\ndef test_normalize_limit_rate(limit_rate, expected):\n    result = normalize_limit_rate(limit_rate)\n\n    assert result == expected\n\n\n@pytest.mark.parametrize('is_request, stream, fnf, metadata_push, channel, interaction_model, expected', (\n        (None, None, None, None, None, None, Exception),\n        (True, None, None, None, None, None, RequestType.response),\n        (None, True, None, None, None, None, RequestType.stream),\n        (None, None, True, None, None, None, RequestType.fnf),\n        (None, None, None, True, None, None, RequestType.metadata_push),\n        (None, None, None, None, True, None, RequestType.channel),\n        (None, None, None, None, None, 'request_channel', RequestType.channel),\n        (None, None, None, None, True, RequestType.response, Exception),\n        (None, None, None, True, True, None, Exception),\n))\ndef test_get_request_type(is_request, stream, fnf, metadata_push, channel, interaction_model, expected):\n    if isinstance(expected, RequestType):\n        actual = get_request_type(is_request, stream, fnf, metadata_push, channel, interaction_model)\n\n        assert actual == expected\n    else:\n        with pytest.raises(expected):\n            get_request_type(is_request, stream, fnf, metadata_push, channel, interaction_model)\n\n\n@pytest.mark.parametrize('headers, expected', (\n        (None, None),\n        (['a=b'], {'a': 'b'}),\n        ([], None),\n))\ndef test_parse_headers(headers, expected):\n    actual = parse_headers(headers)\n\n    assert actual == expected\n\n\n@pytest.mark.parametrize('composite_items, metadata_mime_type, expected', (\n        ([], 'application/json', 'application/json'),\n        ([route('path')], 'application/json', WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA),\n))\ndef test_normalize_metadata_mime_type(composite_items, metadata_mime_type, expected):\n    actual = normalize_metadata_mime_type(composite_items, metadata_mime_type)\n\n    assert actual == expected\n\n\nasync def test_execute_request_response(decoy: Decoy):\n    client = decoy.mock(cls=AwaitableRSocket)\n\n    decoy.when(await client.request_response(Payload())).then_return(Payload(b'abc'))\n\n    result = await execute_request(client, RequestType.response, 3, Payload())\n\n    assert result.data == b'abc'\n\n\nasync def test_execute_request_stream(decoy: Decoy):\n    client = decoy.mock(cls=AwaitableRSocket)\n\n    decoy.when(await client.request_stream(Payload(), limit_rate=3)).then_return([Payload(b'abc')])\n\n    result = await execute_request(client, RequestType.stream, 3, Payload())\n\n    assert result[0].data == b'abc'\n\n\nasync def test_execute_request_channel(decoy: Decoy):\n    client = decoy.mock(cls=AwaitableRSocket)\n\n    decoy.when(await client.request_channel(Payload(), limit_rate=3)).then_return([Payload(b'abc')])\n\n    result = await execute_request(client, RequestType.channel, 3, Payload())\n\n    assert result[0].data == b'abc'\n\n\nasync def test_execute_request_fnf(decoy: Decoy):\n    client = decoy.mock(cls=AwaitableRSocket)\n\n    decoy.when(client.fire_and_forget(Payload())).then_return(create_future(None))\n\n    result = await execute_request(client, RequestType.fnf, 3, Payload())\n\n    assert result is None\n\n\nasync def test_execute_command_tcp_request(unused_tcp_port):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            await sleep(4)\n            return create_response(b'response from test')\n\n    async with pipe_factory_tcp(unused_tcp_port,\n                                client_arguments={},\n                                server_arguments={'handler_factory': Handler}):\n        runner = CliRunner()\n        uri = f'tcp://localhost:{unused_tcp_port}'\n        result = await runner.invoke(command, ['--request', uri])\n\n        assert result.stdout == 'response from test\\n'\n        assert result.exit_code == 0\n\n\nasync def test_execute_command_websocket_request(unused_tcp_port):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            await sleep(4)\n            return create_response(b'response from test')\n\n    async with pipe_factory_quart_websocket(unused_tcp_port,\n                                            client_arguments={},\n                                            server_arguments={'handler_factory': Handler}):\n        runner = CliRunner()\n        uri = f'ws://localhost:{unused_tcp_port}'\n        result = await runner.invoke(command, ['--request', uri])\n\n        assert result.stdout == 'response from test\\n'\n        assert result.exit_code == 0\n"}
{"type": "test_file", "path": "tests/rsocket/test_composite_metadata.py", "content": "from typing import cast\n\nimport pytest\n\nfrom rsocket.exceptions import RSocketError\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.extensions.helpers import composite, data_mime_type, data_mime_types, route, authenticate_simple, \\\n    metadata_item\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.extensions.routing import RoutingMetadata\nfrom rsocket.extensions.stream_data_mimetype import StreamDataMimetypes, StreamDataMimetype\nfrom tests.rsocket.helpers import measure_runtime\n\n\ndef test_tag_composite_metadata_too_long():\n    routing = RoutingMetadata(tags=[('some data too long %s' % ''.join(['x'] * 256)).encode()])\n    composite_metadata = CompositeMetadata()\n    composite_metadata.items.append(routing)\n\n    with pytest.raises(RSocketError):\n        composite_metadata.serialize()\n\n\ndef test_data_mime_type_composite_metadata():\n    data = composite(data_mime_type(WellKnownMimeTypes.APPLICATION_JSON))\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(data)\n\n    assert len(composite_metadata.items) == 1\n    metadata_item_1 = cast(StreamDataMimetype, composite_metadata.items[0])\n    assert metadata_item_1.data_encoding == b'application/json'\n\n    assert composite_metadata.serialize() == data\n\n\ndef test_data_mime_types_composite_metadata():\n    data = composite(data_mime_types(\n        WellKnownMimeTypes.APPLICATION_JSON,\n        WellKnownMimeTypes.TEXT_XML\n    ))\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(data)\n\n    assert len(composite_metadata.items) == 1\n    from typing import cast\n    metadata_item_1 = cast(StreamDataMimetypes, composite_metadata.items[0])\n\n    assert metadata_item_1.data_encodings[0] == b'application/json'\n    assert metadata_item_1.data_encodings[1] == b'text/xml'\n\n    assert composite_metadata.serialize() == data\n\n\ndef test_composite_metadata_find_by_mimetype():\n    data = composite(\n        data_mime_types(\n            WellKnownMimeTypes.APPLICATION_JSON,\n            WellKnownMimeTypes.TEXT_XML\n        ),\n        route('login'),\n        authenticate_simple('abcd', '1234'),\n        metadata_item(b'some_data_1', WellKnownMimeTypes.TEXT_PLAIN),\n        metadata_item(b'some_data_2', WellKnownMimeTypes.TEXT_PLAIN),\n        metadata_item(b'{\"key\":1}', WellKnownMimeTypes.APPLICATION_JSON),\n    )\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(data)\n\n    plain_text = composite_metadata.find_by_mimetype(WellKnownMimeTypes.TEXT_PLAIN)\n\n    assert len(plain_text) == 2\n    assert plain_text[0].content == b'some_data_1'\n    assert plain_text[1].content == b'some_data_2'\n\n    authentication_items = composite_metadata.find_by_mimetype(WellKnownMimeTypes.MESSAGE_RSOCKET_AUTHENTICATION)\n    assert authentication_items[0].authentication.password == b'1234'\n\n\ndef test_composite_metadata_parse_performance():\n    data = composite(\n        data_mime_types(\n            WellKnownMimeTypes.APPLICATION_JSON,\n            WellKnownMimeTypes.TEXT_XML\n        ),\n        route('login'),\n        authenticate_simple('abcd', '1234'),\n        metadata_item(b'some_data_1', WellKnownMimeTypes.TEXT_PLAIN),\n        metadata_item(b'some_data_2', WellKnownMimeTypes.TEXT_PLAIN),\n        metadata_item(b'{\"key\":1}', WellKnownMimeTypes.APPLICATION_JSON),\n    )\n\n    composite_metadata = CompositeMetadata()\n\n    with measure_runtime() as result:\n        for i in range(100):\n            composite_metadata.items = []\n            composite_metadata.parse(data)\n\n    print(result.time.total_seconds() / 100 * 1000)\n"}
{"type": "test_file", "path": "tests/rsocket/test_concurrency.py", "content": "import asyncio\nimport logging\nfrom typing import Tuple, Optional\n\nimport pytest\n\nfrom rsocket.async_helpers import async_range\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import utf8_decode, create_response\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.streams.stream_from_async_generator import StreamFromAsyncGenerator\nfrom tests.tools.helpers import measure_time\n\n\nasync def test_concurrent_streams(pipe: Tuple[RSocketServer, RSocketClient]):\n    class Handler(BaseRequestHandler):\n\n        def __init__(self, server_done: Optional[asyncio.Event] = None):\n            self._server_done = server_done\n\n        async def request_stream(self, payload: Payload):\n            count = int(utf8_decode(payload.data))\n\n            async def generator():\n                async for index in async_range(count):\n                    yield Payload(ensure_bytes('Feed Item: {}/{}'.format(index, count))), index == count - 1\n\n            return StreamFromAsyncGenerator(generator)\n\n    server, client = pipe\n\n    server.set_handler_using_factory(Handler)\n\n    request_1 = asyncio.create_task(measure_time(AwaitableRSocket(client).request_stream(Payload(b'2000'))))\n\n    request_2 = asyncio.create_task(measure_time(AwaitableRSocket(client).request_stream(Payload(b'10'))))\n\n    results = (await request_1, await request_2)\n\n    print(results[0].delta, results[1].delta)\n    delta = abs(results[0].delta - results[1].delta)\n\n    assert len(results[0].result) == 2000\n    assert len(results[1].result) == 10\n    # assert delta > 0.2\n\n\n@pytest.mark.timeout(30)\nasync def test_concurrent_fragmented_responses(lazy_pipe_with_id):\n    transport_id, lazy_pipe = lazy_pipe_with_id\n\n    transport_parameter_map = {\n        'tcp': (0.3, 4.5),\n        'aiohttp': (0.6, 7),\n        'quart': (1, 8.5),\n        'quic': (4, 13),\n        'http3': (5, 20),\n    }\n\n    expected_delta, expected_runtime = transport_parameter_map[transport_id]\n\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            data = 'a' * 100 * int(utf8_decode(request.data))\n            return create_response(ensure_bytes(data))\n\n    async with lazy_pipe(\n            server_arguments={'handler_factory': Handler, 'fragment_size_bytes': 100},\n            client_arguments={'fragment_size_bytes': 100}) as (server, client):\n        async def run():\n            request_1 = asyncio.create_task(measure_time(client.request_response(Payload(b'10000'))))\n\n            request_2 = asyncio.create_task(measure_time(client.request_response(Payload(b'10'))))\n            return await request_1, await request_2\n\n        logging.debug(\"Starting concurrent requests\")\n\n        measure_result = await measure_time(run())\n\n        results = measure_result.result\n\n        # assert measure_result.delta < expected_runtime\n\n        print(results[0].delta, results[1].delta)\n        delta_time = abs(results[0].delta - results[1].delta)\n\n        assert len(results[0].result.data) == 10000 * 100\n        assert len(results[1].result.data) == 10 * 100\n        # assert delta_time > expected_delta\n\n        await asyncio.sleep(1)\n"}
{"type": "test_file", "path": "tests/rsocket/test_connection_lost.py", "content": "import asyncio\nimport logging\nfrom asyncio import Event\nfrom asyncio.base_events import Server\nfrom datetime import timedelta\nfrom typing import Optional, Tuple\n\nimport pytest\nfrom asyncstdlib import sync\n\nfrom reactivestreams.publisher import Publisher\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.error_codes import ErrorCode\nfrom rsocket.exceptions import RSocketProtocolError\nfrom rsocket.frame import Frame\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.logger import logger\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.streams.stream_from_async_generator import StreamFromAsyncGenerator\nfrom rsocket.transports.aioquic_transport import rsocket_connect, rsocket_serve\nfrom rsocket.transports.tcp import TransportTCP\nfrom rsocket.transports.transport import Transport\nfrom tests.rsocket.helpers import future_from_payload, IdentifiedHandlerFactory, \\\n    IdentifiedHandler, force_closing_connection, ServerContainer\n\n\nclass ServerHandler(IdentifiedHandler):\n    def __init__(self, server_id: int, delay=timedelta(0)):\n        super().__init__(server_id, delay)\n        self._delay = delay\n\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        await asyncio.sleep(self._delay.total_seconds())\n        return future_from_payload(Payload(payload.data + (' server %d' % self._server_id).encode(), payload.metadata))\n\n    async def request_stream(self, payload: Payload) -> Publisher:\n        return StreamFromAsyncGenerator(self.feed, delay_between_messages=self._delay)\n\n    async def feed(self):\n        for x in range(10):\n            value = Payload('Feed Item: {}'.format(x).encode('utf-8'))\n            yield value, x == 2\n\n\nasync def test_connection_lost(unused_tcp_port):\n    logging.info('Testing transport tcp (explicitly) on port %s', unused_tcp_port)\n\n    index_iterator = iter(range(1, 3))\n\n    wait_for_server = Event()\n    transport: Optional[Transport] = None\n    client_connection: Optional[Tuple] = None\n\n    class ClientHandler(BaseRequestHandler):\n        async def on_close(self, rsocket, exception: Optional[Exception] = None):\n            logger().info('Test Reconnecting')\n            await rsocket.reconnect()\n\n    def session(*tcp_connection):\n        nonlocal server, transport\n        transport = TransportTCP(*tcp_connection)\n        server = RSocketServer(transport,\n                               IdentifiedHandlerFactory(next(index_iterator), ServerHandler).factory)\n        wait_for_server.set()\n\n    async def start():\n        nonlocal service, client\n        service = await asyncio.start_server(session, host, port)\n\n        async def transport_provider():\n            while True:\n                try:\n                    nonlocal client_connection\n                    client_connection = await asyncio.open_connection(host, port)\n                    yield TransportTCP(*client_connection)\n                except Exception:\n                    logger().error('Client connection error', exc_info=True)\n                    raise\n\n        client = RSocketClient(transport_provider(), handler_factory=ClientHandler)\n\n    service: Optional[Server] = None\n    server: Optional[RSocketServer] = None\n    client: Optional[RSocketClient] = None\n    port = unused_tcp_port\n    host = 'localhost'\n\n    await start()\n\n    try:\n        async with client as connection:\n            await wait_for_server.wait()\n            wait_for_server.clear()\n            response1 = await connection.request_response(Payload(b'request 1'))\n\n            await force_closing_connection(transport)\n\n            await server.close()  # cleanup async tasks from previous server to avoid errors (?)\n            await wait_for_server.wait()\n            response2 = await connection.request_response(Payload(b'request 2'))\n\n            assert response1.data == b'data: request 1 server 1'\n            assert response2.data == b'data: request 2 server 2'\n    finally:\n        await server.close()\n\n        service.close()\n\n\nclass FailingTransport(Transport):\n\n    async def connect(self):\n        raise Exception\n\n    async def send_frame(self, frame: Frame):\n        pass\n\n    async def next_frame_generator(self):\n        pass\n\n    async def close(self):\n        pass\n\n\n@pytest.mark.allow_error_log(regex_filter='Connection error')\nasync def test_tcp_connection_failure(unused_tcp_port: int):\n    logging.info('Testing transport tcp (explicitly) on port %s', unused_tcp_port)\n\n    index_iterator = iter(range(1, 3))\n\n    wait_for_server = Event()\n    transport: Optional[Transport] = None\n    client_connection: Optional[Tuple] = None\n\n    class ClientHandler(BaseRequestHandler):\n        async def on_connection_error(self, rsocket, exception: Optional[Exception] = None):\n            logger().info('Test Reconnecting (connection error)')\n            await rsocket.reconnect()\n\n        async def on_close(self, rsocket, exception: Optional[Exception] = None):\n            logger().info('Test Reconnecting (closed)')\n            await rsocket.reconnect()\n\n    def session(*connection):\n        nonlocal server, transport\n        transport = TransportTCP(*connection)\n        server = RSocketServer(transport,\n                               IdentifiedHandlerFactory(next(index_iterator), ServerHandler).factory)\n        wait_for_server.set()\n\n    async def start():\n        nonlocal service, client\n        service = await asyncio.start_server(session, host, port)\n\n        async def transport_provider():\n            try:\n                nonlocal client_connection\n                client_connection = await asyncio.open_connection(host, port)\n                yield TransportTCP(*client_connection)\n\n                yield FailingTransport()\n\n                client_connection = await asyncio.open_connection(host, port)\n                yield TransportTCP(*client_connection)\n            except Exception:\n                logger().error('Client connection error', exc_info=True)\n                raise\n\n        client = RSocketClient(transport_provider(), handler_factory=ClientHandler)\n\n    service: Optional[Server] = None\n    server: Optional[RSocketServer] = None\n    client: Optional[RSocketClient] = None\n    port = unused_tcp_port\n    host = 'localhost'\n\n    await start()\n\n    try:\n        async with client as connection:\n            await wait_for_server.wait()\n            wait_for_server.clear()\n\n            response1 = await connection.request_response(Payload(b'request 1'))\n\n            await force_closing_connection(transport)\n\n            await server.close()  # cleanup async tasks from previous server to avoid errors (?)\n            await wait_for_server.wait()\n\n            response2 = await connection.request_response(Payload(b'request 2'))\n\n            assert response1.data == b'data: request 1 server 1'\n            assert response2.data == b'data: request 2 server 2'\n    finally:\n        await server.close()\n\n        service.close()\n\n\nclass SharedClientHandler(BaseRequestHandler):\n    async def on_close(self, rsocket, exception: Optional[Exception] = None):\n        logger().info('Test Reconnecting (closed)')\n        await rsocket.reconnect()\n\n\nasync def start_tcp_service(waiter: asyncio.Event, container, port: int, generate_test_certificates):\n    index_iterator = iter(range(1, 3))\n\n    def session(*connection):\n        container.transport = TransportTCP(*connection)\n        container.server = RSocketServer(container.transport,\n                                         IdentifiedHandlerFactory(next(index_iterator),\n                                                                  ServerHandler,\n                                                                  delay=timedelta(seconds=1)).factory)\n        waiter.set()\n\n    service = await asyncio.start_server(session, 'localhost', port)\n    return sync(service.close)\n\n\nasync def start_tcp_client(port: int, generate_test_certificates) -> RSocketClient:\n    async def transport_provider():\n        try:\n            client_connection = await asyncio.open_connection('localhost', port)\n            yield TransportTCP(*client_connection)\n\n            yield FailingTransport()\n\n            client_connection = await asyncio.open_connection('localhost', port)\n            yield TransportTCP(*client_connection)\n        except Exception:\n            logger().error('Client connection error', exc_info=True)\n            raise\n\n    return RSocketClient(transport_provider(), handler_factory=SharedClientHandler)\n\n\nasync def start_websocket_service(waiter: asyncio.Event, container, port: int, generate_test_certificates):\n    from rsocket.transports.aiohttp_websocket import websocket_handler_factory, TransportAioHttpClient\n    from aiohttp.test_utils import RawTestServer\n\n    index_iterator = iter(range(1, 3))\n\n    def handler_factory(*args, **kwargs):\n        return IdentifiedHandlerFactory(\n            next(index_iterator),\n            ServerHandler,\n            delay=timedelta(seconds=1)).factory(*args, **kwargs)\n\n    def on_server_create(server):\n        container.server = server\n        container.transport = server._transport\n        waiter.set()\n\n    server = RawTestServer(websocket_handler_factory(on_server_create=on_server_create,\n                                                     handler_factory=handler_factory), port=port)\n    await server.start_server()\n    return server.close\n\n\nasync def start_websocket_client(port: int, generate_test_certificates) -> RSocketClient:\n    from rsocket.transports.aiohttp_websocket import TransportAioHttpClient\n\n    url = 'http://localhost:{}'.format(port)\n\n    async def transport_provider():\n        try:\n            yield TransportAioHttpClient(url)\n\n            yield FailingTransport()\n\n            yield TransportAioHttpClient(url)\n        except Exception:\n            logger().error('Client connection error', exc_info=True)\n            raise\n\n    return RSocketClient(transport_provider(), handler_factory=SharedClientHandler)\n\n\nasync def start_quic_service(waiter: asyncio.Event, container, port: int, generate_test_certificates):\n    from aioquic.quic.configuration import QuicConfiguration\n\n    index_iterator = iter(range(1, 3))\n    certificate, private_key = generate_test_certificates\n    server_configuration = QuicConfiguration(\n        certificate=certificate,\n        private_key=private_key,\n        is_client=False\n    )\n\n    def handler_factory():\n        return IdentifiedHandlerFactory(\n            next(index_iterator),\n            ServerHandler,\n            delay=timedelta(seconds=1)).factory()\n\n    def on_server_create(server):\n        container.server = server\n        container.transport = server._transport\n        waiter.set()\n\n    quic_server = await rsocket_serve(host='localhost',\n                                      port=port,\n                                      configuration=server_configuration,\n                                      on_server_create=on_server_create,\n                                      handler_factory=handler_factory)\n    return sync(quic_server.close)\n\n\nasync def start_quic_client(port: int, generate_test_certificates) -> RSocketClient:\n    from aioquic.quic.configuration import QuicConfiguration\n    from cryptography.hazmat.primitives import serialization\n\n    certificate, private_key = generate_test_certificates\n    client_configuration = QuicConfiguration(\n        is_client=True\n    )\n    ca_data = certificate.public_bytes(serialization.Encoding.PEM)\n    client_configuration.load_verify_locations(cadata=ca_data, cafile=None)\n\n    async def transport_provider():\n        try:\n            logging.info('Quic connection lost valid connection 1')\n            async with rsocket_connect('localhost', port,\n                                       configuration=client_configuration) as transport:\n                yield transport\n\n            logging.info('Quic connection lost invalid connection')\n            yield FailingTransport()\n\n            logging.info('Quic connection lost valid connection 2')\n            async with rsocket_connect('localhost', port,\n                                       configuration=client_configuration) as transport:\n                yield transport\n        except Exception:\n            logger().error('Client connection error', exc_info=True)\n            raise\n\n    return RSocketClient(transport_provider(), handler_factory=SharedClientHandler)\n\n\n@pytest.mark.allow_error_log()  # regex_filter='Connection error') # todo: fix error log\n@pytest.mark.parametrize(\n    'transport_id, start_service, start_client',\n    (\n            ('tcp', start_tcp_service, start_tcp_client),\n            # ('aiohttp', start_websocket_service, start_websocket_client), # todo: fixme\n            # ('quic', start_quic_service, start_quic_client), # todo: fixme\n    )\n)\nasync def test_connection_failure_during_stream(unused_tcp_port,\n                                                generate_test_certificates,\n                                                transport_id,\n                                                start_service,\n                                                start_client):\n    logging.info('Testing transport %s on port %s', transport_id, unused_tcp_port)\n\n    server_container = ServerContainer()\n    wait_for_server = Event()\n\n    service_closer = await start_service(wait_for_server, server_container, unused_tcp_port, generate_test_certificates)\n    client = await start_client(unused_tcp_port, generate_test_certificates)\n\n    try:\n        async with AwaitableRSocket(client) as async_client:\n            await wait_for_server.wait()\n            wait_for_server.clear()\n\n            with pytest.raises(RSocketProtocolError) as exc_info:\n                await asyncio.gather(\n                    async_client.request_stream(Payload(b'request 1')),\n                    force_closing_connection(server_container.transport, timedelta(seconds=2)))\n\n            assert exc_info.value.error_code == ErrorCode.CONNECTION_ERROR\n\n            await server_container.server.close()  # cleanup async tasks from previous server to avoid errors (?)\n            await wait_for_server.wait()\n            response2 = await async_client.request_response(Payload(b'request 2'))\n\n            assert response2.data == b'data: request 2 server 2'\n    finally:\n        await server_container.server.close()\n\n        await service_closer()\n"}
{"type": "test_file", "path": "tests/rsocket/test_extentions.py", "content": "import pytest\nimport struct\n\nfrom rsocket.exceptions import RSocketError\nfrom rsocket.extensions.authentication import AuthenticationBearer, AuthenticationSimple\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.extensions.routing import RoutingMetadata\nfrom rsocket.extensions.tagging import TaggingMetadata\n\n\ndef test_authentication_bearer():\n    data = b'1234'\n\n    authentication = AuthenticationBearer(b'1234')\n\n    assert authentication.serialize() == data\n\n    parsed = AuthenticationBearer()\n    parsed.parse(data)\n\n    assert parsed == authentication\n\n\ndef test_authentication_simple():\n    data = b'\\x00\\x041234abcd'\n\n    authentication = AuthenticationSimple(b'1234', b'abcd')\n\n    assert authentication.serialize() == data\n\n    parsed = AuthenticationSimple()\n    parsed.parse(data)\n\n    assert parsed == authentication\n\n\ndef test_routing():\n    data = b'\\nroute.path\\x0bother.route'\n\n    routing = RoutingMetadata([b'route.path', b'other.route'])\n\n    assert routing.serialize() == data\n\n    parsed = RoutingMetadata()\n    parsed.parse(data)\n\n    assert parsed == routing\n\n\ndef test_tagging_metadata_serialize_max_length():\n    tag = 's' * 255\n    meta = TaggingMetadata(WellKnownMimeTypes.MESSAGE_RSOCKET_ROUTING, [tag])\n\n    serialized = meta.serialize()\n\n    length = struct.pack('>B', len(tag))\n    assert length + bytes(tag, 'utf-8') == serialized\n\n\ndef test_tagging_metadata_serialize_exception_length():\n    tag = 's' * 256\n    meta = TaggingMetadata(WellKnownMimeTypes.MESSAGE_RSOCKET_ROUTING, [tag])\n\n    with pytest.raises(RSocketError) as e_info:\n        meta.serialize()\n\n    assert e_info.match(f'Tag length longer than 255 characters: \"b\\'{tag}\\'\"')\n\n\ndef test_tagging_metadata_parse():\n    meta = TaggingMetadata(WellKnownMimeTypes.MESSAGE_RSOCKET_ROUTING)\n    tag = 's' * 255\n    length = struct.pack('>B', len(tag))\n\n    meta.parse(length + bytes(tag, 'utf-8'))\n    assert tag == meta.tags[0].decode()\n"}
{"type": "test_file", "path": "tests/rsocket/test_fire_and_forget.py", "content": "import asyncio\nfrom typing import Optional\n\nimport pytest\n\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\n\n\nclass FireAndForgetHandler(BaseRequestHandler):\n    def __init__(self):\n        self.received = asyncio.Event()\n        self.received_payload: Optional[Payload] = None\n\n    async def request_fire_and_forget(self, payload: Payload):\n        self.received_payload = payload\n        self.received.set()\n\n\nasync def test_request_fire_and_forget(lazy_pipe):\n    handler: Optional[FireAndForgetHandler] = None\n\n    def handler_factory():\n        nonlocal handler\n        handler = FireAndForgetHandler()\n        return handler\n\n    async with lazy_pipe(\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        await client.fire_and_forget(Payload(b'dog', b'cat'))\n\n        await handler.received.wait()\n\n        assert handler.received_payload.data == b'dog'\n        assert handler.received_payload.metadata == b'cat'\n\n    await asyncio.sleep(2)  # wait for server to close\n\n\n@pytest.mark.timeout(15)\nasync def test_request_fire_and_forget_fragmented(lazy_pipe):\n    handler: Optional[FireAndForgetHandler] = None\n\n    def handler_factory():\n        nonlocal handler\n        handler = FireAndForgetHandler()\n        return handler\n\n    async with lazy_pipe(\n            server_arguments={'handler_factory': handler_factory,\n                              'fragment_size_bytes': 10240},\n            client_arguments={'fragment_size_bytes': 10240}) as (server, client):\n        data = bytearray(16777210)\n\n        await client.fire_and_forget(Payload(data))\n\n        await handler.received.wait()\n\n        assert handler.received_payload.data == data\n        assert handler.received_payload.metadata == b''\n\n    await asyncio.sleep(2)  # wait for server to close\n\n\nasync def test_request_fire_and_forget_awaitable_client(lazy_pipe):\n    handler: Optional[FireAndForgetHandler] = None\n\n    def handler_factory():\n        nonlocal handler\n        handler = FireAndForgetHandler()\n        return handler\n\n    async with lazy_pipe(\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        await AwaitableRSocket(client).fire_and_forget(Payload(b'dog', b'cat'))\n\n        await handler.received.wait()\n\n        assert handler.received_payload.data == b'dog'\n        assert handler.received_payload.metadata == b'cat'\n"}
{"type": "test_file", "path": "tests/rsocket/test_fragments.py", "content": "from typing import cast\n\nimport pytest\n\nfrom rsocket.exceptions import RSocketFrameFragmentDifferentType\nfrom rsocket.frame import PayloadFrame, RequestResponseFrame, FragmentableFrame, RequestStreamFrame, RequestChannelFrame\nfrom rsocket.frame_builders import to_request_response_frame, to_request_stream_frame, to_request_channel_frame\nfrom rsocket.frame_fragment_cache import FrameFragmentCache\nfrom rsocket.payload import Payload\nfrom tests.rsocket.helpers import create_data\n\n\ndef test_create_data():\n    assert create_data(b'aaa', 3) == b'0aaa1aaa2aaa'\n\n\n@pytest.mark.parametrize('data, metadata, fragment_size_bytes, expected_frame_count', (\n        (b'', b'', 64, 1),  # empty payload\n        (b'', create_data(b'123abc456def', 20), 64, 5),  # only data\n        (create_data(b'123abc456def', 20), b'', 64, 5),  # only metadata\n        (create_data(b'123abc456def', 20), create_data(b'123abc456def', 20, 55), 64, 6),  # metadata fits in first frame\n        (create_data(b'123abc456def', 20), create_data(b'123abc456def', 20), 64, 10),  # mixed metadata/data frame\n        (create_data(b'123abc456def', 4, 20), create_data(b'123abc456def', 4, 20), 64, 1),  # fit in one frame\n        (create_data(b'123abc456def', 4, 20), create_data(b'123abc456def', 4, 25), 64, 1),  # fit in one frame exactly\n))\nasync def test_fragmentation_payload(data, metadata, fragment_size_bytes, expected_frame_count):\n    frame = PayloadFrame()\n    frame.data = data\n    frame.metadata = metadata\n    frame.fragment_size_bytes = fragment_size_bytes\n\n    def fragment_generator():\n        while True:\n            next_fragment = frame.get_next_fragment()\n\n            if next_fragment is not None:\n                yield next_fragment\n            else:\n                break\n\n    fragments = list(fragment_generator())\n\n    assert all(isinstance(fragment, PayloadFrame) for fragment in fragments)\n    assert all(fragment.flags_follows for fragment in fragments[0:-1])\n    assert fragments[-1].flags_follows is False\n\n    assert len(fragments) == expected_frame_count\n\n    cache = FrameFragmentCache()\n\n    combined_payload = None\n    for fragment in fragments:\n        combined_payload = cache.append(cast(FragmentableFrame, fragment))\n\n    if metadata is None or len(metadata) == 0:\n        assert combined_payload.metadata is None or combined_payload.metadata == b''\n    else:\n        assert combined_payload.metadata == metadata\n\n    if data is None or len(data) == 0:\n        assert combined_payload.data is None or combined_payload.data == b''\n    else:\n        assert combined_payload.data == data\n\n\n@pytest.mark.parametrize('request_builder, data, metadata, fragment_size_bytes, expected_frame_count, request_class', (\n        (to_request_response_frame, b'', create_data(b'123abc456def', 20), 64, 5, RequestResponseFrame),\n        (to_request_stream_frame, create_data(b'123abc456def', 20), b'', 64, 5, RequestStreamFrame),\n        (to_request_channel_frame, create_data(b'123abc456def', 20), b'', 64, 5, RequestChannelFrame),\n))\nasync def test_fragmentation_request(request_builder, data, metadata, fragment_size_bytes, expected_frame_count,\n                                     request_class):\n    frame = request_builder(1, Payload(data, metadata), fragment_size_bytes)\n\n    def fragment_generator():\n        while True:\n            next_fragment = frame.get_next_fragment()\n\n            if next_fragment is not None:\n                yield next_fragment\n            else:\n                break\n\n    fragments = list(fragment_generator())\n\n    assert all(isinstance(fragment, PayloadFrame) for fragment in fragments[1:-1])\n    assert all(fragment.flags_follows for fragment in fragments[0:-1])\n    assert fragments[-1].flags_follows is False\n    assert isinstance(fragments[0], request_class)\n\n    assert len(fragments) == expected_frame_count\n\n    cache = FrameFragmentCache()\n\n    combined_frame = None\n    for fragment in fragments:\n        combined_frame = cache.append(cast(FragmentableFrame, fragment))\n\n    assert isinstance(combined_frame, request_class)\n\n    if metadata is None or len(metadata) == 0:\n        assert combined_frame.metadata is None or combined_frame.metadata == b''\n    else:\n        assert combined_frame.metadata == metadata\n\n    if data is None or len(data) == 0:\n        assert combined_frame.data is None or combined_frame.data == b''\n    else:\n        assert combined_frame.data == data\n\n\nasync def test_frame_building_should_fail_if_inconsistent_frame_type():\n    first_frame = RequestResponseFrame()\n    first_frame.data = b'123'\n    first_frame.flags_follows = True\n    first_frame.flags_complete = False\n\n    second_frame = RequestChannelFrame()\n    second_frame.data = b'123'\n    second_frame.flags_follows = False\n    second_frame.flags_complete = True\n\n    cache = FrameFragmentCache()\n\n    cache.append(first_frame)\n\n    with pytest.raises(RSocketFrameFragmentDifferentType):\n        cache.append(second_frame)\n"}
{"type": "test_file", "path": "tests/rsocket/test_frame_decode.py", "content": "from typing import cast\n\nimport asyncstdlib\n\nfrom rsocket.extensions.authentication import AuthenticationSimple\nfrom rsocket.extensions.authentication_content import AuthenticationContent\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\n\n\nasync def test_decode_spring_demo_auth():\n    metadata = bytearray(\n        b'\\xfe\\x00\\x00\\r\\x0cshell-client\"message/x.rsocket.authentication.v0\\x00\\x00\\x0b\\x80\\x00\\x04userpass')\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(metadata)\n\n    assert len(composite_metadata.items) == 2\n\n    composite_item = cast(AuthenticationContent, composite_metadata.items[1])\n    authentication = cast(AuthenticationSimple, composite_item.authentication)\n    assert authentication.username == b'user'\n    assert authentication.password == b'pass'\n\n\nasync def test_multiple_frames(frame_parser):\n    data = b'\\x00\\x00\\x06\\x00\\x00\\x00\\x7b\\x24\\x00'\n    data += b'\\x00\\x00\\x13\\x00\\x00\\x26\\x6a\\x2c\\x00\\x00\\x00\\x02\\x04\\x77\\x65\\x69'\n    data += b'\\x72\\x64\\x6e\\x65\\x73\\x73'\n    data += b'\\x00\\x00\\x06\\x00\\x00\\x00\\x7b\\x24\\x00'\n    data += b'\\x00\\x00\\x06\\x00\\x00\\x00\\x7b\\x24\\x00'\n    data += b'\\x00\\x00\\x06\\x00\\x00\\x00\\x7b\\x24\\x00'\n    frames = await asyncstdlib.builtins.list(frame_parser.receive_data(data))\n    assert len(frames) == 5\n"}
{"type": "test_file", "path": "tests/rsocket/test_frame.py", "content": "import asyncstdlib\nimport pytest\n\nfrom rsocket.error_codes import ErrorCode\nfrom rsocket.exceptions import RSocketProtocolError\nfrom rsocket.extensions.authentication_types import WellKnownAuthenticationTypes\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.frame import (SetupFrame, CancelFrame, ErrorFrame, FrameType,\n                           RequestResponseFrame, RequestNFrame, ResumeFrame,\n                           MetadataPushFrame, PayloadFrame, LeaseFrame, ResumeOKFrame, KeepAliveFrame,\n                           serialize_with_frame_size_header, RequestStreamFrame, RequestChannelFrame, ParseError,\n                           parse_or_ignore, Frame, RequestFireAndForgetFrame, serialize_prefix_with_frame_size_header,\n                           parse_header_native, Header, is_frame_to_ignore, is_fragmentable_frame, new_frame_fragment)\nfrom rsocket.frame_parser import FrameParser\nfrom tests.rsocket.helpers import data_bits, build_frame, bits\n\n\n@pytest.mark.parametrize('follows, complete, is_next', (\n        (0, 1, 1),\n        (1, 1, 1),\n        (0, 0, 1),\n        (1, 0, 1)\n))\ndef test_parse_header_native(follows, complete, is_next):\n    data = build_frame(\n        bits(24, 28, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 6, 'Stream id'),\n        bits(6, FrameType.PAYLOAD, 'Frame type'),\n        bits(1, 0, 'Ignore'),\n        bits(1, 1, 'Metadata'),\n        bits(1, follows, 'Follows'),\n        bits(1, complete, 'Complete'),\n        bits(1, is_next, 'Next'),\n        bits(5, 0, 'Padding flags'),\n        bits(24, 8, 'Metadata length'),\n        data_bits(b'metadata'),\n        data_bits(b'actual_data'),\n    )\n\n    header = Header()\n    flags = parse_header_native(header, data, 3)\n\n    assert header.frame_type == FrameType.PAYLOAD\n    assert header.flags_ignore == 0\n    assert header.flags_metadata == 1\n\n    assert flags.flags_follows_resume_respond == follows\n    assert flags.flags_complete_lease == complete\n    assert flags.flags_next == is_next\n\n\n@pytest.mark.parametrize('metadata_flag, metadata, lease, frame_data', (\n        (0, b'', 0, b'\\x01\\x02\\x03'),\n        (1, b'\\x04\\x05\\x06\\x07\\x08', 1, b'\\x01\\x02\\x03'),\n        (1, b'\\x04\\x05\\x06\\x07\\x08', 1, b''),\n        (1, b'\\x04\\x05\\x06\\x07\\x08', 0, b''),\n))\nasync def test_setup_readable(frame_parser, metadata_flag, metadata, lease, frame_data):\n    def variable_length():\n        length = len(frame_data)\n        if metadata_flag != 0:\n            length += len(metadata) + 3\n        return length\n\n    items = [\n        bits(24, 53 + variable_length(), 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, 1, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, metadata_flag, 'Metadata'),\n        bits(1, 0, 'Resume'),\n        bits(1, lease, 'Lease'),\n        bits(6, 0, 'Padding flags'),\n        # Version\n        bits(16, 1, 'Major version'),\n        bits(16, 0, 'Minor version'),\n        # Timeouts\n        bits(1, 0, 'Padding'),\n        bits(31, 123, 'Time Between KEEPALIVE Frames'),\n        bits(1, 0, 'Padding'),\n        bits(31, 456, 'Max Lifetime'),\n        # Resume token - not present\n        # Meta-data mime\n        bits(8, 24, 'Metadata mime length'),\n        data_bits(b'application/octet-stream'),\n        # Data mime\n        bits(8, 9, 'Data mime length'),\n        data_bits(b'text/html'),\n    ]\n\n    if metadata_flag:\n        items.extend((\n            bits(24, len(metadata), 'Metadata length'),\n            data_bits(metadata, 'Metadata')\n        ))\n\n    items.extend((data_bits(frame_data, 'Payload')))\n\n    data = build_frame(*items)\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, SetupFrame)\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n    assert frame.metadata_encoding == b'application/octet-stream'\n    assert frame.data_encoding == b'text/html'\n    assert frame.keep_alive_milliseconds == 123\n    assert frame.max_lifetime_milliseconds == 456\n    assert frame.data == frame_data\n    assert frame.metadata == metadata\n    assert frame.flags_resume is False\n    assert frame.flags_lease == bool(lease)\n    assert frame.flags_complete is False\n    assert frame.flags_ignore is False\n    assert frame.flags_follows is False\n    assert frame.frame_type is FrameType.SETUP\n    assert frame.major_version == 1\n    assert frame.minor_version == 0\n\n\n@pytest.mark.parametrize('lease', (\n        (0),\n        (1)\n))\nasync def test_setup_with_resume(frame_parser, lease):\n    data = build_frame(\n        bits(24, 84, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, 1, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 1, 'Metadata'),\n        bits(1, 1, 'Resume'),\n        bits(1, lease, 'Lease'),\n        bits(6, 0, 'Padding flags'),\n        # Version\n        bits(16, 1, 'Major version'),\n        bits(16, 0, 'Minor version'),\n        # Timeouts\n        bits(1, 0, 'Padding'),\n        bits(31, 123, 'Time Between KEEPALIVE Frames'),\n        bits(1, 0, 'Padding'),\n        bits(31, 456, 'Max Lifetime'),\n        # Resume token\n        bits(16, 18, 'Resume token length'),\n        data_bits(b'resume_token_value'),\n        # Meta-data mime\n        bits(8, 24, 'Metadata mime length'),\n        data_bits(b'application/octet-stream'),\n        # Data mime\n        bits(8, 9, 'Data mime length'),\n        data_bits(b'text/html'),\n        # Metadata\n        bits(24, 5, 'Metadata length'),\n        data_bits(b'\\x04\\x05\\x06\\x07\\x08'),\n        # Payload\n        data_bits(b'\\x01\\x02\\x03'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, SetupFrame)\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n    assert frame.metadata_encoding == b'application/octet-stream'\n    assert frame.data_encoding == b'text/html'\n    assert frame.keep_alive_milliseconds == 123\n    assert frame.max_lifetime_milliseconds == 456\n    assert frame.data == b'\\x01\\x02\\x03'\n    assert frame.metadata == b'\\x04\\x05\\x06\\x07\\x08'\n    assert frame.resume_identification_token == b'resume_token_value'\n    assert frame.flags_resume\n    assert frame.flags_lease == bool(lease)\n    assert frame.flags_complete is False\n    assert frame.flags_ignore is False\n    assert frame.flags_follows is False\n\n\n@pytest.mark.parametrize('follows', (\n        0,\n        1\n))\nasync def test_request_stream_frame(frame_parser, follows):\n    data = build_frame(\n        bits(24, 32, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 15, 'Stream id'),\n        bits(6, FrameType.REQUEST_STREAM.value, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 1, 'Metadata'),\n        bits(1, follows, 'Follows'),\n        bits(7, 0, 'Empty flags'),\n        bits(1, 0, 'Padding'),\n        bits(31, 10, 'Initial request N'),\n        # Metadata\n        bits(24, 16, 'Metadata length'),\n        # Composite metadata\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_ROUTING.value.id, 'Mime ID'),\n        bits(24, 12, 'Metadata length'),\n        bits(8, 11, 'Tag Length'),\n        data_bits(b'target.path'),\n\n        # Payload\n        data_bits(b'\\x01\\x02\\x03'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, RequestStreamFrame)\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n    assert frame.data == b'\\x01\\x02\\x03'\n    assert frame.flags_follows == bool(follows)\n    assert frame.flags_complete is False\n    assert frame.stream_id == 15\n    assert frame.frame_type is FrameType.REQUEST_STREAM\n    assert frame.initial_request_n == 10\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(frame.metadata)\n\n    assert composite_metadata.items[0].encoding == b'message/x.rsocket.routing.v0'\n    assert composite_metadata.items[0].tags == [b'target.path']\n\n    assert composite_metadata.serialize() == frame.metadata\n\n\nasync def test_request_stream_without_body(frame_parser):\n    data = build_frame(\n        bits(24, 10, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 15, 'Stream id'),\n        bits(6, FrameType.REQUEST_STREAM.value, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(1, 0, 'Follows'),\n        bits(7, 0, 'Empty flags'),\n        bits(1, 0, 'Padding'),\n        bits(31, 10, 'Initial request N'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, RequestStreamFrame)\n    assert frame.initial_request_n == 10\n\n\n@pytest.mark.parametrize('follows, complete', (\n        (0, 1),\n        (1, 1),\n        (0, 0),\n        (1, 0)\n))\nasync def test_request_channel_frame(frame_parser, follows, complete):\n    data = build_frame(\n        bits(24, 32, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 15, 'Stream id'),\n        bits(6, FrameType.REQUEST_CHANNEL.value, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 1, 'Metadata'),\n        bits(1, follows, 'Follows'),\n        bits(1, complete, 'Complete'),\n        bits(6, 0, 'Empty flags'),\n        bits(1, 0, 'Padding'),\n        bits(31, 10, 'Initial request N'),\n        # Metadata\n        bits(24, 16, 'Metadata length'),\n        # Composite metadata\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_ROUTING.value.id, 'Mime ID'),\n        bits(24, 12, 'Metadata length'),\n        bits(8, 11, 'Tag Length'),\n        data_bits(b'target.path'),\n\n        # Payload\n        data_bits(b'\\x01\\x02\\x03'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, RequestChannelFrame)\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n    assert frame.data == b'\\x01\\x02\\x03'\n    assert frame.flags_follows == bool(follows)\n    assert frame.flags_complete == bool(complete)\n    assert frame.stream_id == 15\n    assert frame.frame_type is FrameType.REQUEST_CHANNEL\n    assert frame.initial_request_n == 10\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(frame.metadata)\n\n    assert composite_metadata.items[0].encoding == b'message/x.rsocket.routing.v0'\n    assert composite_metadata.items[0].tags == [b'target.path']\n\n    assert composite_metadata.serialize() == frame.metadata\n\n\nasync def test_request_channel_without_body(frame_parser):\n    data = build_frame(\n        bits(24, 10, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 15, 'Stream id'),\n        bits(6, FrameType.REQUEST_CHANNEL.value, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(1, 0, 'Follows'),\n        bits(1, 1, 'Complete'),\n        bits(6, 0, 'Empty flags'),\n        bits(1, 0, 'Padding'),\n        bits(31, 10, 'Initial request N'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, RequestChannelFrame)\n    assert frame.initial_request_n == 10\n\n\ndef test_basic_composite_metadata_item():\n    data = build_frame(\n\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.TEXT_PLAIN.value.id, 'Mime ID'),\n        bits(24, 9, 'Metadata length'),\n        data_bits(b'some data')\n    )\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(data)\n\n    assert composite_metadata.items[0].content == b'some data'\n\n    serialized = composite_metadata.serialize()\n\n    assert data == serialized\n\n\nasync def test_request_with_composite_metadata(frame_parser):\n    data = build_frame(\n        bits(24, 28, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 17, 'Stream id'),\n        bits(6, FrameType.REQUEST_RESPONSE.value, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 1, 'Metadata'),\n        bits(1, 0, 'Follows'),\n        bits(7, 0, 'Empty flags'),\n        # Metadata\n        bits(24, 16, 'Metadata length'),\n        # Composite metadata\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_ROUTING.value.id, 'Mime ID'),\n        bits(24, 12, 'Metadata length'),\n        bits(8, 11, 'Tag Length'),\n        data_bits(b'target.path'),\n\n        # Payload\n        data_bits(b'\\x01\\x02\\x03'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, RequestResponseFrame)\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n    assert frame.data == b'\\x01\\x02\\x03'\n    assert not frame.flags_follows\n    assert frame.stream_id == 17\n    assert frame.frame_type is FrameType.REQUEST_RESPONSE\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(frame.metadata)\n\n    assert composite_metadata.items[0].encoding == b'message/x.rsocket.routing.v0'\n    assert composite_metadata.items[0].tags == [b'target.path']\n\n    assert composite_metadata.serialize() == frame.metadata\n\n\nasync def test_request_response_without_body(frame_parser):\n    data = build_frame(\n        bits(24, 6, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 15, 'Stream id'),\n        bits(6, FrameType.REQUEST_RESPONSE.value, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(1, 0, 'Follows'),\n        bits(7, 0, 'Empty flags'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, RequestResponseFrame)\n\n\nasync def test_composite_metadata_multiple_items():\n    data = build_frame(\n\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_ROUTING.value.id, 'Mime ID'),\n        bits(24, 12, 'Metadata length'),\n        bits(8, 11, 'Tag Length'),\n        data_bits(b'target.path'),\n\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_MIMETYPE.value.id, 'Mime ID'),\n        bits(24, 1, 'Metadata length'),\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.TEXT_CSS.value.id, 'Mime ID'),\n\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_MIMETYPE.value.id, 'Mime ID'),\n        bits(24, 26, 'Metadata length'),\n        bits(1, 0, 'Not well known metadata type'),\n        bits(7, 24, 'Encoding length'),\n        data_bits(b'some-custom-encoding/type'),\n\n        bits(1, 1, 'Well known metadata type'),\n        bits(7, WellKnownMimeTypes.MESSAGE_RSOCKET_AUTHENTICATION.value.id, 'Mime ID'),\n        bits(24, 19, 'Metadata length'),\n        bits(1, 1, 'Well known authentication type'),\n        bits(7, WellKnownAuthenticationTypes.SIMPLE.value.id, 'Authentication ID'),\n        bits(16, 8, 'Username length'),\n        data_bits(b'username'),\n        data_bits(b'password')\n    )\n\n    composite_metadata = CompositeMetadata()\n    composite_metadata.parse(data)\n\n    assert composite_metadata.items[0].encoding == b'message/x.rsocket.routing.v0'\n    assert composite_metadata.items[0].tags == [b'target.path']\n\n    assert composite_metadata.items[1].encoding == b'message/x.rsocket.mime-type.v0'\n    assert composite_metadata.items[1].data_encoding == b'text/css'\n\n    assert composite_metadata.items[2].encoding == b'message/x.rsocket.mime-type.v0'\n    assert composite_metadata.items[2].data_encoding == b'some-custom-encoding/type'\n\n    assert composite_metadata.items[3].encoding == b'message/x.rsocket.authentication.v0'\n    assert composite_metadata.items[3].authentication.username == b'username'\n    assert composite_metadata.items[3].authentication.password == b'password'\n\n    assert composite_metadata.serialize() == data\n\n\nasync def test_cancel(frame_parser):\n    data = build_frame(\n        bits(24, 6, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, 9, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(8, 0, 'Padding flags'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, CancelFrame)\n    assert frame.frame_type is FrameType.CANCEL\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n\nasync def test_error(frame_parser):\n    data = build_frame(\n        bits(24, 20, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, FrameType.ERROR.value, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(8, 0, 'Padding flags'),\n        # Request N\n        bits(32, ErrorCode.REJECTED_SETUP.value, 'Number of frames to request'),\n        data_bits(b'error data')\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, ErrorFrame)\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n    assert frame.error_code == ErrorCode.REJECTED_SETUP\n    assert frame.data == b'error data'\n    assert frame.frame_type is FrameType.ERROR\n\n\nasync def test_request_n_frame(frame_parser):\n    data = build_frame(\n        bits(24, 10, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, 8, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(8, 0, 'Padding flags'),\n        # Request N\n        bits(1, 0, 'Padding'),\n        bits(31, 23, 'Number of frames to request'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, RequestNFrame)\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n    assert frame.request_n == 23\n    assert frame.frame_type is FrameType.REQUEST_N\n\n\nasync def test_resume_frame(frame_parser):\n    data = build_frame(\n        bits(24, 40, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, FrameType.RESUME, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(8, 0, 'Padding flags'),\n        # Version\n        bits(16, 1, 'Major version'),\n        bits(16, 0, 'Minor version'),\n        # Resume token\n        bits(16, 12, 'Token length'),\n        data_bits(b'resume_token'),\n        bits(1, 0, 'placeholder'),\n        bits(63, 123, 'last server position'),\n        bits(1, 0, 'placeholder'),\n        bits(63, 456, 'first client position'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, ResumeFrame)\n    assert frame.last_server_position == 123\n    assert frame.first_client_position == 456\n    assert frame.frame_type is FrameType.RESUME\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n\nasync def test_metadata_push_frame(frame_parser):\n    data = build_frame(\n        bits(24, 14, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, FrameType.METADATA_PUSH, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 1, 'Metadata'),\n        bits(8, 0, 'Padding flags'),\n        data_bits(b'metadata')\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, MetadataPushFrame)\n    assert frame.metadata == b'metadata'\n    assert frame.frame_type is FrameType.METADATA_PUSH\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n\n@pytest.mark.parametrize('follows, complete, is_next', (\n        (0, 1, 1),\n        (1, 1, 1),\n        (0, 0, 1),\n        (1, 0, 1)\n))\nasync def test_payload_frame(frame_parser, follows, complete, is_next):\n    data = build_frame(\n        bits(24, 28, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 6, 'Stream id'),\n        bits(6, FrameType.PAYLOAD, 'Frame type'),\n        bits(1, 0, 'Ignore'),\n        bits(1, 1, 'Metadata'),\n        bits(1, follows, 'Follows'),\n        bits(1, complete, 'Complete'),\n        bits(1, is_next, 'Next'),\n        bits(5, 0, 'Padding flags'),\n        bits(24, 8, 'Metadata length'),\n        data_bits(b'metadata'),\n        data_bits(b'actual_data'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, PayloadFrame)\n    assert frame.metadata == b'metadata'\n    assert frame.data == b'actual_data'\n    assert frame.frame_type is FrameType.PAYLOAD\n    assert frame.stream_id == 6\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n    assert frame.flags_follows is bool(follows)\n    assert frame.flags_complete is bool(complete)\n    assert frame.flags_next is bool(is_next)\n\n\nasync def test_payload_without_body(frame_parser):\n    data = build_frame(\n        bits(24, 6, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 6, 'Stream id'),\n        bits(6, FrameType.PAYLOAD, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(1, 0, 'Follows'),\n        bits(1, 1, 'Complete'),\n        bits(1, 0, 'Next'),\n        bits(5, 0, 'Padding flags'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, PayloadFrame)\n    assert frame.frame_type is FrameType.PAYLOAD\n    assert frame.stream_id == 6\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n    assert frame.flags_follows is False\n    assert frame.flags_complete is True\n    assert frame.flags_next is False\n\n\nasync def test_lease_frame(frame_parser):\n    data = build_frame(\n        bits(24, 37, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, FrameType.LEASE, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 1, 'Metadata'),\n        bits(8, 0, 'Padding flags'),\n        bits(1, 0, 'Padding'),\n        bits(31, 456, 'Time to live'),\n        bits(1, 0, 'Padding'),\n        bits(31, 123, 'Number of requests'),\n        data_bits(b'Metadata on lease frame')\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, LeaseFrame)\n    assert frame.number_of_requests == 123\n    assert frame.time_to_live == 456\n    assert frame.frame_type is FrameType.LEASE\n    assert frame.metadata == b'Metadata on lease frame'\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n\nasync def test_fire_and_forget_without_body(frame_parser):\n    data = build_frame(\n        bits(24, 6, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 15, 'Stream id'),\n        bits(6, FrameType.REQUEST_FNF.value, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(1, 0, 'Follows'),\n        bits(7, 0, 'Empty flags'),\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, RequestFireAndForgetFrame)\n\n\nasync def test_resume_ok_frame(frame_parser):\n    data = build_frame(\n        bits(24, 14, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, FrameType.RESUME_OK, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(8, 0, 'Padding flags'),\n        bits(1, 0, 'Padding'),\n        bits(63, 456, 'Last Received Client Position')\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, ResumeOKFrame)\n    assert frame.last_received_client_position == 456\n    assert frame.frame_type is FrameType.RESUME_OK\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n\nasync def test_keepalive_frame(frame_parser):\n    data = build_frame(\n        bits(24, 29, 'Frame size'),\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, FrameType.KEEPALIVE, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(8, 0, 'Padding flags'),\n        bits(1, 0, 'Padding'),\n        bits(63, 456, 'Last Received Client Position'),\n        data_bits(b'additional data')\n    )\n\n    frame = await parse_frame(data, frame_parser)\n\n    assert isinstance(frame, KeepAliveFrame)\n    assert frame.last_received_position == 456\n    assert frame.stream_id == 0\n    assert frame.frame_type is FrameType.KEEPALIVE\n    assert frame.data == b'additional data'\n    assert serialize_prefix_with_frame_size_header(frame) == data[:frame.prefix_length + 3]\n    assert serialize_with_frame_size_header(frame) == data\n\n\ndef test_parse_error_on_frame_too_short():\n    with pytest.raises(ParseError):\n        parse_or_ignore(b'1')\n\n\ndef test_parse_broken_frame_raises_exception():\n    broken_frame_data = build_frame(\n        bits(1, 0, 'Padding'),\n        bits(31, 0, 'Stream id'),\n        bits(6, 8, 'Frame type'),\n        # Flags\n        bits(1, 0, 'Ignore'),\n        bits(1, 0, 'Metadata'),\n        bits(8, 0, 'Padding flags'),\n        # Request N\n        bits(1, 0, 'Padding'),\n        bits(13, 23, 'Number of frames to request - broken. smaller than 31 bits'),\n    )\n\n    with pytest.raises(RSocketProtocolError):\n        parse_or_ignore(broken_frame_data)\n\n\n@pytest.mark.skip(reason='Not yet implemented')\ndef test_equality():\n    frame = RequestResponseFrame()\n    frame.data = b'123'\n    frame.metadata = b'abc'\n\n    similar_frame = RequestResponseFrame()\n    similar_frame.data = b'123'\n    similar_frame.metadata = b'abc'\n\n    other_frame_different_data = RequestResponseFrame()\n    other_frame_different_data.data = b'456'\n    other_frame_different_data.metadata = b'abc'\n\n    unequal_frame = RequestStreamFrame()\n    unequal_frame.data = b'123'\n    unequal_frame.metadata = b'abc'\n\n    assert frame == similar_frame\n    assert frame != other_frame_different_data\n    assert frame != unequal_frame\n\n\nasync def parse_frame(data: bytes, frame_parser: FrameParser) -> Frame:\n    frames = await asyncstdlib.builtins.list(frame_parser.receive_data(data))\n    return frames[0]\n\n\ndef test_is_frame_to_ignore():\n    frame = RequestResponseFrame()\n    frame.stream_id = 1\n    frame.flags_ignore = True\n\n    assert not is_frame_to_ignore(frame)\n\n\n@pytest.mark.allow_error_log(regex_filter='Invalid metadata frame')\ndef test_is_frame_to_ignore_invalid_metadata_push():\n    ignored_frame = MetadataPushFrame()\n    ignored_frame.stream_id = 1\n\n    assert is_frame_to_ignore(ignored_frame)\n\n\ndef test_is_fragmentable_frame():\n    frame = PayloadFrame()\n\n    assert is_fragmentable_frame(frame)\n"}
{"type": "test_file", "path": "tests/rsocket/test_helpers.py", "content": "from rsocket.extensions.composite_metadata_item import CompositeMetadataItem\nfrom rsocket.extensions.helpers import metadata_item\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import is_empty_payload, is_non_empty_payload\nfrom rsocket.payload import Payload\n\n\ndef test_metadata_item():\n    result = metadata_item(b'123', WellKnownMimeTypes.TEXT_PLAIN)\n\n    assert result == CompositeMetadataItem(WellKnownMimeTypes.TEXT_PLAIN, b'123')\n\n\ndef test_is_empty_payload():\n    assert is_empty_payload(Payload())\n    assert not is_empty_payload(Payload(data=b'abc'))\n    assert not is_empty_payload(Payload(metadata=b'abc'))\n    assert not is_empty_payload(Payload(data=b'abc', metadata=b'abc'))\n\n\ndef test_is_non_empty_payload():\n    assert not is_non_empty_payload(Payload())\n    assert is_non_empty_payload(Payload(data=b'abc'))\n    assert is_non_empty_payload(Payload(metadata=b'abc'))\n    assert is_non_empty_payload(Payload(data=b'abc', metadata=b'abc'))\n"}
{"type": "test_file", "path": "tests/rsocket/test_internal.py", "content": "import asyncio\nimport logging\nfrom collections import namedtuple\nfrom weakref import WeakKeyDictionary\n\nimport pytest\n\nfrom tests.rsocket.helpers import measure_runtime\n\n\nasync def test_reader(event_loop: asyncio.AbstractEventLoop):\n    stream = asyncio.StreamReader(loop=event_loop)\n    stream.feed_data(b'data')\n    stream.feed_eof()\n    data = await stream.read()\n    assert data == b'data'\n\n\n@pytest.mark.xfail(\n    reason='This is testing the fixture which should cause the test to fail if there is an error log')\nasync def test_fail_on_error_log(fail_on_error_log):\n    logging.error(\"this should not happen\")\n\n\ndef test_weak_ref():\n    class S(str):\n        pass\n\n    d = WeakKeyDictionary()\n    a = S('abc')\n    d[a] = 1\n    assert len(d) == 1\n\n    del a\n\n    assert len(d) == 0\n\n\nasync def test_range():\n    async def loop(ii):\n        for i in range(100):\n            await asyncio.sleep(0)\n            print(ii + str(i))\n\n    await asyncio.gather(loop('a'), loop('b'))\n\n\ndef test_instantiate_named_tuple():\n    routing = namedtuple('routing', ['tags', 'content'])\n    count = 100000\n    with measure_runtime() as result:\n        for i in range(count):\n            r = routing(b'abc', b'abcdefg')\n\n    print(result.time.total_seconds() / count * 1000)\n\n\ndef test_instantiate_slotted_class():\n    class routing:\n        __slots__ = ['tags', 'content']\n\n        def __init__(self, tags, content):\n            self.tags = tags\n            self.content = content\n\n    count = 100000\n    with measure_runtime() as result:\n        for i in range(count):\n            r = routing(b'abc', b'abcdefg')\n\n    print(result.time.total_seconds() / count * 1000)\n\n\ndef test_instantiate_class():\n    class routing:\n\n        def __init__(self, tags, content):\n            self.tags = tags\n            self.content = content\n\n    count = 100000\n    with measure_runtime() as result:\n        for i in range(count):\n            r = routing(b'abc', b'abcdefg')\n\n    print(result.time.total_seconds() / count * 1000)\n"}
{"type": "test_file", "path": "tests/rsocket/test_lease.py", "content": "import asyncio\nfrom datetime import timedelta\n\nimport pytest\n\nfrom reactivestreams.subscriber import Subscriber\nfrom rsocket.exceptions import RSocketProtocolError\nfrom rsocket.lease import SingleLeasePublisher, DefinedLease, NullLease\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom tests.rsocket.helpers import future_from_payload\n\n\nclass PeriodicalLeasePublisher(SingleLeasePublisher):\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._lease_task = None\n\n    def subscribe(self, subscriber: Subscriber):\n        self._lease_task = asyncio.create_task(self._subscribe_loop(subscriber))\n\n    async def _subscribe_loop(self, subscriber: Subscriber):\n        try:\n            while True:\n                await asyncio.sleep(self.wait_between_leases.total_seconds())\n\n                subscriber.on_next(DefinedLease(\n                    maximum_request_count=self.maximum_request_count,\n                    maximum_lease_time=self.maximum_lease_time\n                ))\n        except asyncio.CancelledError:\n            pass\n\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if self._lease_task is not None:\n            self._lease_task.cancel()\n            await self._lease_task\n\n\nasync def test_request_response_with_server_side_lease_works(lazy_pipe):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            return future_from_payload(request)\n\n    async with lazy_pipe(client_arguments={'honor_lease': True},\n                         server_arguments={'handler_factory': Handler,\n                                           'lease_publisher': SingleLeasePublisher(\n                                               maximum_lease_time=timedelta(seconds=3)\n                                           )}) as (server, client):\n        for x in range(2):\n            response = await client.request_response(Payload(b'dog', b'cat'))\n            assert response == Payload(b'data: dog', b'meta: cat')\n\n\n@pytest.mark.timeout(15)\nasync def test_request_response_with_client_and_server_side_lease_works(lazy_pipe):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            return future_from_payload(request)\n\n    async with PeriodicalLeasePublisher(\n            maximum_request_count=2,\n            maximum_lease_time=timedelta(seconds=3),\n            wait_between_leases=timedelta(seconds=2)) as client_leases:\n        async with PeriodicalLeasePublisher(\n                maximum_request_count=2,\n                maximum_lease_time=timedelta(seconds=3),\n                wait_between_leases=timedelta(seconds=2)) as server_leases:\n            async with lazy_pipe(\n                    client_arguments={'honor_lease': True,\n                                      'handler_factory': Handler,\n                                      'lease_publisher': client_leases},\n                    server_arguments={'honor_lease': True,\n                                      'handler_factory': Handler,\n                                      'lease_publisher': server_leases}) as (server, client):\n                for x in range(3):\n                    response = await client.request_response(Payload(b'dog', b'cat'))\n                    assert response == Payload(b'data: dog', b'meta: cat')\n\n                for x in range(3):\n                    response = await server.request_response(Payload(b'dog', b'cat'))\n                    assert response == Payload(b'data: dog', b'meta: cat')\n\n\nasync def test_request_response_with_lease_too_many_requests(lazy_pipe):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            return future_from_payload(request)\n\n    async with lazy_pipe(client_arguments={'honor_lease': True},\n                         server_arguments={'handler_factory': Handler,\n                                           'lease_publisher': SingleLeasePublisher(\n                                               maximum_request_count=2\n                                           )}) as (server, client):\n        for x in range(2):\n            response = await client.request_response(Payload(b'dog', b'cat'))\n            assert response == Payload(b'data: dog', b'meta: cat')\n\n        with pytest.raises(asyncio.TimeoutError):\n            await asyncio.wait_for(client.request_response(Payload(b'invalid request')), 3)\n\n\n@pytest.mark.timeout(15)\nasync def test_request_response_with_lease_client_side_exception_requests_late(lazy_pipe):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            return future_from_payload(request)\n\n    async with lazy_pipe(client_arguments={'honor_lease': True},\n                         server_arguments={'handler_factory': Handler,\n                                           'lease_publisher': SingleLeasePublisher(\n                                               maximum_lease_time=timedelta(seconds=3)\n                                           )}) as (server, client):\n        for x in range(2):\n            response = await client.request_response(Payload(b'dog', b'cat'))\n            assert response == Payload(b'data: dog', b'meta: cat')\n\n        await asyncio.sleep(5)\n\n        with pytest.raises(asyncio.TimeoutError):\n            await asyncio.wait_for(client.request_response(Payload(b'invalid request')), 3)\n\n\n@pytest.mark.allow_error_log(regex_filter='UNSUPPORTED_SETUP')\nasync def test_server_rejects_all_requests_if_lease_not_supported(lazy_pipe):\n    async with lazy_pipe(client_arguments={'honor_lease': True}) as (server, client):\n        with pytest.raises(asyncio.TimeoutError):\n            await asyncio.wait_for(client.request_response(Payload(b'invalid request')), 3)\n\n\n@pytest.mark.skip(reason='TODO')\nasync def test_request_response_with_lease_server_side_exception(lazy_pipe):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            return future_from_payload(request)\n\n    async with lazy_pipe(client_arguments={'honor_lease': True},\n                         server_arguments={'handler_factory': Handler,\n                                           'lease_publisher': SingleLeasePublisher(\n                                               maximum_request_count=2\n                                           )}) as (server, client):\n        for x in range(2):\n            response = await client.request_response(Payload(b'dog', b'cat'))\n            assert response == Payload(b'data: dog', b'meta: cat')\n\n        with pytest.raises(RSocketProtocolError):\n            await client.request_response(Payload(b'invalid request'))\n\n\nasync def test_null_lease():\n    null_lease = NullLease()\n\n    assert null_lease.is_request_allowed(1)\n\n    frame = null_lease.to_frame()\n\n    assert frame.serialize() == b'\\x00\\x00\\x00\\x00\\x08\\x00\\x7f\\xff\\xff\\xff\\x7f\\xff\\xff\\xff'\n\n\nasync def test_defined_lease():\n    lease = DefinedLease(5, timedelta(minutes=1))\n\n    assert str(lease) == '{maximum_request_count: 5, lease_ttl: 0:01:00}'\n"}
{"type": "test_file", "path": "tests/rsocket/test_load_balancer.py", "content": "import asyncio\nfrom contextlib import AsyncExitStack\nfrom datetime import timedelta\nfrom typing import Tuple, Optional\n\nfrom reactivestreams.publisher import Publisher\nfrom reactivestreams.subscriber import Subscriber\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.helpers import create_future\nfrom rsocket.load_balancer.load_balancer_rsocket import LoadBalancerRSocket\nfrom rsocket.load_balancer.random_client import LoadBalancerRandom\nfrom rsocket.load_balancer.round_robin import LoadBalancerRoundRobin\nfrom rsocket.payload import Payload\nfrom rsocket.streams.stream_from_generator import StreamFromGenerator\nfrom tests.conftest import pipe_factory_tcp\nfrom tests.rsocket.helpers import IdentifiedHandlerFactory, IdentifiedHandler, \\\n    to_test_response_payload\n\n\ndef to_response_payload(payload, server_id):\n    return to_test_response_payload(\n        Payload(payload.data + (' server %d' % server_id).encode(),\n                payload.metadata))\n\n\nclass Handler(IdentifiedHandler):\n    def __init__(self, server_id: int, delay=timedelta(0)):\n        super().__init__(server_id, delay)\n        self.fnf = []\n        self.metadata = []\n\n    async def request_stream(self, payload: Payload) -> Publisher:\n        return StreamFromGenerator(\n            lambda: map(lambda _: (_, False), [to_response_payload(payload, self._server_id)]))\n\n    async def request_fire_and_forget(self, payload: Payload):\n        self.fnf.append(payload.data)\n\n    async def request_channel(self, payload: Payload) -> Tuple[Optional[Publisher], Optional[Subscriber]]:\n        return StreamFromGenerator(lambda: map(Payload, [b'1', b'2'])), None\n\n    async def request_response(self, payload: Payload):\n        return create_future(to_response_payload(payload, self._server_id))\n\n    async def on_metadata_push(self, payload: Payload):\n        self.metadata.append(payload.metadata)\n\n\nasync def test_load_balancer_round_robin_request_response(unused_tcp_port_factory):\n    clients = []\n    server_count = 3\n    request_count = 7\n\n    async with AsyncExitStack() as stack:\n        for i in range(server_count):\n            tcp_port = unused_tcp_port_factory()\n            _, client = await stack.enter_async_context(\n                pipe_factory_tcp(tcp_port,\n                                 server_arguments={'handler_factory': IdentifiedHandlerFactory(i, Handler).factory},\n                                 auto_connect_client=False))\n            clients.append(client)\n\n        round_robin = LoadBalancerRoundRobin(clients)\n\n        async with LoadBalancerRSocket(round_robin) as load_balancer_client:\n            results = await asyncio.gather(\n                *[load_balancer_client.request_response(Payload(('request %d' % j).encode()))\n                  for j in range(request_count)]\n            )\n\n            assert results[0].data == b'data: request 0 server 0'\n            assert results[1].data == b'data: request 1 server 1'\n            assert results[2].data == b'data: request 2 server 2'\n            assert results[3].data == b'data: request 3 server 0'\n            assert results[4].data == b'data: request 4 server 1'\n            assert results[5].data == b'data: request 5 server 2'\n            assert results[6].data == b'data: request 6 server 0'\n\n\nasync def test_load_balancer_round_robin_fire_and_forget(unused_tcp_port_factory):\n    clients = []\n    handlers = []\n\n    server_count = 3\n    request_count = 7\n\n    async with AsyncExitStack() as stack:\n        for server_id in range(server_count):\n            tcp_port = unused_tcp_port_factory()\n            _, client = await stack.enter_async_context(\n                pipe_factory_tcp(tcp_port,\n                                 server_arguments={'handler_factory': IdentifiedHandlerFactory(\n                                     server_id,\n                                     Handler,\n                                     on_handler_create=handlers.append).factory},\n                                 auto_connect_client=False))\n            clients.append(client)\n\n        round_robin = LoadBalancerRoundRobin(clients)\n        async with LoadBalancerRSocket(round_robin) as load_balancer_client:\n            await asyncio.gather(\n                *[load_balancer_client.fire_and_forget(Payload(('request %d' % j).encode()))\n                  for j in range(request_count)]\n            )\n\n            await asyncio.sleep(2)\n\n            assert len(handlers[0].fnf) == 3\n            assert len(handlers[1].fnf) == 2\n            assert len(handlers[2].fnf) == 2\n\n\nasync def test_load_balancer_round_robin_metadata_push(unused_tcp_port_factory):\n    clients = []\n    handlers = []\n\n    server_count = 3\n    request_count = 7\n\n    async with AsyncExitStack() as stack:\n        for server_id in range(server_count):\n            tcp_port = unused_tcp_port_factory()\n            _, client = await stack.enter_async_context(\n                pipe_factory_tcp(tcp_port,\n                                 server_arguments={'handler_factory': IdentifiedHandlerFactory(\n                                     server_id,\n                                     Handler,\n                                     on_handler_create=handlers.append).factory},\n                                 auto_connect_client=False))\n            clients.append(client)\n\n        round_robin = LoadBalancerRoundRobin(clients)\n        async with LoadBalancerRSocket(round_robin) as load_balancer_client:\n            await asyncio.gather(\n                *[load_balancer_client.metadata_push(('request %d' % j).encode())\n                  for j in range(request_count)]\n            )\n\n            await asyncio.sleep(2)\n\n            assert len(handlers[0].metadata) == 3\n            assert len(handlers[1].metadata) == 2\n            assert len(handlers[2].metadata) == 2\n\n\nasync def test_load_balancer_round_robin_request_stream(unused_tcp_port_factory):\n    clients = []\n    server_count = 3\n    request_count = 7\n\n    async with AsyncExitStack() as stack:\n        for i in range(server_count):\n            tcp_port = unused_tcp_port_factory()\n            _, client = await stack.enter_async_context(\n                pipe_factory_tcp(tcp_port,\n                                 server_arguments={'handler_factory': IdentifiedHandlerFactory(i, Handler).factory},\n                                 auto_connect_client=False))\n            clients.append(client)\n\n        round_robin = LoadBalancerRoundRobin(clients)\n        async with LoadBalancerRSocket(round_robin) as load_balancer_client:\n            awaitable_client = AwaitableRSocket(load_balancer_client)\n            results = await asyncio.gather(\n                *[awaitable_client.request_stream(Payload(('request %d' % j).encode()))\n                  for j in range(request_count)]\n            )\n\n            assert results[0][0].data == b'data: request 0 server 0'\n            assert results[1][0].data == b'data: request 1 server 1'\n            assert results[2][0].data == b'data: request 2 server 2'\n            assert results[3][0].data == b'data: request 3 server 0'\n            assert results[4][0].data == b'data: request 4 server 1'\n            assert results[5][0].data == b'data: request 5 server 2'\n            assert results[6][0].data == b'data: request 6 server 0'\n\n\nasync def test_load_balancer_random_request_response(unused_tcp_port_factory):\n    clients = []\n    server_count = 3\n    request_count = 70\n\n    async with AsyncExitStack() as stack:\n        for i in range(server_count):\n            tcp_port = unused_tcp_port_factory()\n            _, client = await stack.enter_async_context(\n                pipe_factory_tcp(tcp_port,\n                                 server_arguments={'handler_factory': IdentifiedHandlerFactory(i, Handler).factory},\n                                 auto_connect_client=False))\n            clients.append(client)\n\n        strategy = LoadBalancerRandom(clients)\n        async with LoadBalancerRSocket(strategy) as load_balancer_client:\n            results = await asyncio.gather(\n                *[load_balancer_client.request_response(Payload(('request %d' % j).encode()))\n                  for j in range(request_count)]\n            )\n\n            server_ids = [payload.data.decode()[-1] for payload in results]\n            assert '0' in server_ids\n            assert '1' in server_ids\n            assert '2' in server_ids\n"}
{"type": "test_file", "path": "tests/rsocket/test_metadata_push.py", "content": "import asyncio\nfrom typing import Optional\n\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom tests.rsocket.helpers import get_components\n\n\nclass MetadataPushHandler(BaseRequestHandler):\n    def __init__(self):\n        self.received = asyncio.Event()\n        self.received_payload: Optional[Payload] = None\n\n    async def on_metadata_push(self, payload: Payload):\n        self.received_payload = payload\n        self.received.set()\n\n\nasync def test_metadata_push(pipe):\n    handler: Optional[MetadataPushHandler] = None\n\n    def handler_factory():\n        nonlocal handler\n        handler = MetadataPushHandler()\n        return handler\n\n    server, client = get_components(pipe)\n    server.set_handler_using_factory(handler_factory)\n\n    await client.metadata_push(b'cat')\n\n    await handler.received.wait()\n\n    assert handler.received_payload.data is None\n    assert handler.received_payload.metadata == b'cat'\n\n\nasync def test_metadata_push_await(pipe):\n    handler: Optional[MetadataPushHandler] = None\n\n    def handler_factory():\n        nonlocal handler\n        handler = MetadataPushHandler()\n        return handler\n\n    server, client = get_components(pipe)\n    server.set_handler_using_factory(handler_factory)\n\n    await client.metadata_push(b'cat')\n\n    await handler.received.wait()\n\n\nasync def test_metadata_push_awaitable_client(pipe):\n    handler: Optional[MetadataPushHandler] = None\n\n    def handler_factory():\n        nonlocal handler\n        handler = MetadataPushHandler()\n        return handler\n\n    server: RSocketServer = pipe[0]\n    client = AwaitableRSocket(pipe[1])\n    server.set_handler_using_factory(handler_factory)\n\n    await client.metadata_push(b'cat')\n\n    await handler.received.wait()\n\n    assert handler.received_payload.data is None\n    assert handler.received_payload.metadata == b'cat'\n"}
{"type": "test_file", "path": "tests/rsocket/test_mimetype.py", "content": "import pytest\n\nfrom rsocket.exceptions import RSocketUnknownMimetype, RSocketMimetypeTooLong\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import serialize_well_known_encoding\n\n\ndef test_mimetype_raise_exception_on_unknown_type():\n    with pytest.raises(RSocketUnknownMimetype) as exc_info:\n        WellKnownMimeTypes.require_by_id(99999)\n\n    assert exc_info.value.mimetype_id == 99999\n\n\ndef test_serialize_well_known_encoding_too_long():\n    with pytest.raises(RSocketMimetypeTooLong):\n        serialize_well_known_encoding(b'1' * 1000, WellKnownMimeTypes.get_by_name)\n\n\ndef test_mimetype_require_by_id():\n    mimetype = WellKnownMimeTypes.require_by_id(0x05)\n\n    assert mimetype is WellKnownMimeTypes.APPLICATION_JSON.value.name\n\n\ndef test_mimetype_get_by_name():\n    mimetype = WellKnownMimeTypes.get_by_name(b'application/json')\n\n    assert mimetype is WellKnownMimeTypes.APPLICATION_JSON.value.id\n\n\ndef test_mimetype_get_by_unknown_name():\n    mimetype = WellKnownMimeTypes.get_by_name(b'non_existing/type')\n\n    assert mimetype is None\n"}
{"type": "test_file", "path": "tests/rsocket/test_misbehaving_client.py", "content": "import asyncio\n\nimport pytest\n\nfrom rsocket.exceptions import RSocketStreamIdInUse\nfrom rsocket.frame import MetadataPushFrame\nfrom rsocket.frame_builders import to_payload_frame\nfrom rsocket.helpers import create_response\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.stream_control import StreamControl\nfrom tests.rsocket.misbehaving_rsocket import MisbehavingRSocket, UnknownFrame\n\n\nasync def test_send_frame_for_non_existing_stream(pipe_tcp, caplog):\n    (client, server) = pipe_tcp\n    done = asyncio.Event()\n\n    class Handler(BaseRequestHandler):\n\n        async def request_fire_and_forget(self, payload: Payload):\n            done.set()\n\n        async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n            return create_response(b'response')\n\n    server.set_handler_using_factory(Handler)\n\n    bad_client = MisbehavingRSocket(client._transport)\n\n    await client.fire_and_forget(Payload())\n\n    await bad_client.send_frame(to_payload_frame(stream_id=145, payload=Payload()))\n\n    await client.request_response(Payload(b'request'))\n\n    await done.wait()\n\n    records = caplog.get_records('call')\n    dropped_frame_log = [record for record in records if 'Dropping frame from unknown stream 145' in record.message]\n    assert len(dropped_frame_log) > 0\n\n\n@pytest.mark.allow_error_log(regex_filter='Error parsing frame')\nasync def test_send_frame_for_unknown_type(pipe_tcp, caplog):\n    (client, server) = pipe_tcp\n\n    class Handler(BaseRequestHandler):\n\n        async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n            return create_response(b'response')\n\n    bad_client = MisbehavingRSocket(client._transport)\n    server.set_handler_using_factory(Handler)\n\n    frame = UnknownFrame()\n\n    await bad_client.send_frame(frame)\n\n    result = await client.request_response(Payload(b'request'))\n\n    records = caplog.get_records('call')\n    error_frame_log = [record for record in records if 'Error parsing frame' in record.message]\n\n    assert len(error_frame_log) > 0\n    assert result.data == b'response'\n\n\n@pytest.mark.allow_error_log(regex_filter='Protocol error')\nasync def test_send_frame_for_stream_id_in_use(pipe_tcp, caplog):\n    (client, server) = pipe_tcp\n\n    class BrokenStreamControl(StreamControl):\n        def assert_stream_id_available(self, stream_id: int):\n            raise RSocketStreamIdInUse(stream_id)\n\n    class Handler(BaseRequestHandler):\n\n        async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n            await asyncio.sleep(2)\n            return create_response(b'response')\n\n    server.set_handler_using_factory(Handler)\n    server._stream_control = BrokenStreamControl(3)\n\n    with pytest.raises(Exception):\n        await client.request_response(Payload(b'request'))\n\n\n@pytest.mark.allow_error_log(regex_filter='Invalid metadata frame')\nasync def test_metadata_frame_with_non_zero_stream_id_is_ignored(pipe_tcp):\n    (client, server) = pipe_tcp\n\n    class Handler(BaseRequestHandler):\n\n        async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n            return create_response(b'response')\n\n    bad_client = MisbehavingRSocket(client._transport)\n    server.set_handler_using_factory(Handler)\n\n    frame = MetadataPushFrame()\n    frame.stream_id = 4\n    frame.metadata = b'stuff'\n\n    await bad_client.send_frame(frame)\n\n    await asyncio.sleep(2)\n"}
{"type": "test_file", "path": "tests/rsocket/test_multiple_streams.py", "content": "from asyncio import Event\nfrom typing import Tuple, Optional\n\nfrom reactivestreams.publisher import Publisher\nfrom reactivestreams.subscriber import DefaultSubscriber, Subscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.awaitable.collector_subscriber import CollectorSubscriber\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.streams.stream_from_generator import StreamFromGenerator\nfrom tests.rsocket.helpers import get_components\n\n\nasync def test_request_channel_and_stream_intertwined(pipe: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe)\n    messages_received_from_client_client = []\n    message_count_sent_from_requester = 0\n    maximum_message_count = 5\n    take_only_n = 2\n\n    def responder_generator():\n        for x in range(3):\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == 2\n\n    class Handler(BaseRequestHandler, DefaultSubscriber):\n\n        def on_next(self, value: Payload, is_complete=False):\n            messages_received_from_client_client.append(value)\n\n            if len(messages_received_from_client_client) < take_only_n:\n                self.subscription.request(1)\n            else:\n                self.subscription.cancel()\n\n        def on_subscribe(self, subscription: Subscription):\n            super().on_subscribe(subscription)\n            subscription.request(1)\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return StreamFromGenerator(responder_generator)\n\n        async def request_channel(self, payload: Payload) -> Tuple[Optional[Publisher], Optional[Subscriber]]:\n            return StreamFromGenerator(responder_generator), self\n\n    server.set_handler_using_factory(Handler)\n\n    def requester_generator():\n        nonlocal message_count_sent_from_requester\n        for x in range(maximum_message_count):\n            message_count_sent_from_requester += 1\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == (maximum_message_count - 1)\n\n    sending_done = Event()\n\n    client.request_channel(\n        Payload(b'request text channel'),\n        publisher=StreamFromGenerator(requester_generator),\n        sending_done=sending_done\n    ).subscribe(CollectorSubscriber(limit_count=1))\n\n    messages_received_from_server_stream = await AwaitableRSocket(client).request_stream(\n        Payload(b'request text stream'))\n\n    await sending_done.wait()\n\n    maximum_message_received_by_responder = min(maximum_message_count, take_only_n)\n\n    assert message_count_sent_from_requester == maximum_message_received_by_responder\n\n    assert len(messages_received_from_client_client) == maximum_message_received_by_responder\n\n    assert len(messages_received_from_server_stream) == 3\n\n    for i in range(maximum_message_received_by_responder):\n        assert messages_received_from_client_client[i].data == ('Feed Item: %d' % i).encode()\n"}
{"type": "test_file", "path": "tests/rsocket/test_payload.py", "content": "import pytest\n\nfrom rsocket.payload import Payload\n\n\n@pytest.mark.parametrize('payload, expected_str', (\n        (Payload(), \"<payload: data_length 0, metadata_length 0>\"),\n        (Payload(b'some data'), \"<payload: data_length 9, metadata_length 0>\"),\n        (Payload(metadata=b'some metadata'), \"<payload: data_length 0, metadata_length 13>\"),\n        (Payload(b'some data', b'some metadata'), \"<payload: data_length 9, metadata_length 13>\"),\n\n))\ndef test_payload_to_str(payload, expected_str):\n    assert str(payload) == expected_str\n\n\n@pytest.mark.parametrize('payload, expected_str', (\n        (Payload(), \"Payload(None, None)\"),\n        (Payload(b'some data'), \"Payload(b'some data', None)\"),\n        (Payload(metadata=b'some metadata'), \"Payload(None, b'some metadata')\"),\n        (Payload(b'some data', b'some metadata'), \"Payload(b'some data', b'some metadata')\"),\n\n))\ndef test_payload_repr(payload, expected_str):\n    assert repr(payload) == expected_str\n\n\ndef test_payload_support_bytearray():\n    payload = Payload(bytearray([1, 5, 10]), bytearray([4, 6, 7]))\n\n    assert payload.data == b'\\x01\\x05\\x0a'\n    assert payload.metadata == b'\\x04\\x06\\x07'\n"}
{"type": "test_file", "path": "tests/rsocket/test_request_channel.py", "content": "import asyncio\nfrom typing import Tuple, Optional\n\nfrom reactivestreams.publisher import Publisher\nfrom reactivestreams.subscriber import DefaultSubscriber, Subscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.helpers import DefaultPublisherSubscription\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.streams.stream_from_generator import StreamFromGenerator\nfrom tests.rsocket.helpers import get_components\n\n\nasync def test_request_channel_properly_finished(pipe: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe)\n\n    def feed():\n        for x in range(3):\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == 2\n\n    class Handler(BaseRequestHandler):\n        async def request_channel(self, payload: Payload) -> Tuple[Optional[Publisher], Optional[Subscriber]]:\n            return StreamFromGenerator(feed), None\n\n    server.set_handler_using_factory(Handler)\n\n    received_messages = await AwaitableRSocket(client).request_channel(Payload())\n\n    assert len(received_messages) == 3\n    assert received_messages[0].data == b'Feed Item: 0'\n    assert received_messages[1].data == b'Feed Item: 1'\n    assert received_messages[2].data == b'Feed Item: 2'\n\n\nasync def test_request_channel_immediately_finished_without_payloads(pipe: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe)\n    response_stream_finished = asyncio.Event()\n\n    class Handler(BaseRequestHandler, DefaultPublisherSubscription, DefaultSubscriber):\n\n        def __init__(self):\n            super().__init__()\n            self.received_messages = []\n            self.channel_request = None\n\n        def on_next(self, value, is_complete=False):\n            self.received_messages.append(value)\n\n        def on_complete(self):\n            response_stream_finished.set()\n\n        def on_subscribe(self, subscription: Subscription):\n            super().on_subscribe(subscription)\n            subscription.request(1)\n\n        def request(self, n: int):\n            self._subscriber.on_complete()\n\n        async def request_channel(self, payload: Payload) -> Tuple[Optional[Publisher], Optional[Subscriber]]:\n            self.channel_request = payload\n            return self, self\n\n    handler: Optional[Handler] = None\n\n    class RequesterPublisher(DefaultPublisherSubscription):\n\n        def request(self, n: int):\n            self._subscriber.on_complete()\n\n    def handler_factory():\n        nonlocal handler\n        handler = Handler()\n        return handler\n\n    server.set_handler_using_factory(handler_factory)\n\n    received_messages = await AwaitableRSocket(client).request_channel(Payload(b'channel request'), RequesterPublisher())\n\n    await response_stream_finished.wait()\n\n    assert len(received_messages) == 0\n    assert len(handler.received_messages) == 0\n    assert handler.channel_request.data == b'channel request'\n"}
{"type": "test_file", "path": "tests/rsocket/test_request_response.py", "content": "import asyncio\nimport functools\nfrom typing import Awaitable\n\nimport pytest\n\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.helpers import create_future, create_response\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom tests.rsocket.helpers import future_from_payload, get_components\n\n\n@pytest.mark.timeout(4)\nasync def test_request_response_awaitable_wrapper(pipe):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            return future_from_payload(request)\n\n    server, client = get_components(pipe)\n    server.set_handler_using_factory(Handler)\n\n    response = await AwaitableRSocket(client).request_response(Payload(b'dog', b'cat'))\n    assert response == Payload(b'data: dog', b'meta: cat')\n\n\nasync def test_request_response_repeated(pipe):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            return future_from_payload(request)\n\n    server, client = get_components(pipe)\n    server.set_handler_using_factory(Handler)\n\n    for x in range(2):\n        response = await client.request_response(Payload(b'dog', b'cat'))\n        assert response == Payload(b'data: dog', b'meta: cat')\n\n\nasync def test_request_response_failure(pipe):\n    class Handler(BaseRequestHandler, asyncio.Future):\n        async def request_response(self, payload: Payload):\n            self.set_exception(RuntimeError(''))\n            return self\n\n    server, client = get_components(pipe)\n    server.set_handler_using_factory(Handler)\n\n    with pytest.raises(RuntimeError):\n        await client.request_response(Payload())\n\n\nasync def test_request_response_cancellation(pipe):\n    server_future = create_future()\n\n    class Handler(BaseRequestHandler):\n        async def request_response(self, payload: Payload):\n            # return a future that will never complete.\n            return server_future\n\n    server, client = get_components(pipe)\n    server.set_handler_using_factory(Handler)\n\n    future = client.request_response(Payload())\n\n    with pytest.raises(asyncio.TimeoutError):\n        await asyncio.wait_for(asyncio.shield(server_future), 0.1)\n\n    assert not server_future.cancelled()\n\n    future.cancel()\n\n    with pytest.raises(asyncio.CancelledError):\n        await asyncio.wait_for(asyncio.shield(server_future), 0.1)\n\n    with pytest.raises(asyncio.CancelledError):\n        await future\n\n\nasync def test_request_response_bidirectional(pipe):\n    class ServerHandler(BaseRequestHandler):\n        @staticmethod\n        def future_done(other: asyncio.Future, current: asyncio.Future):\n            if current.cancelled():\n                other.set_exception(RuntimeError('Canceled.'))\n            elif current.exception():\n                other.set_exception(current.exception())\n            else:\n                payload = current.result()\n                payload.data = b'(server ' + payload.data + b')'\n                payload.metadata = b'(server ' + payload.metadata + b')'\n                other.set_result(payload)\n\n        async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n            future = create_future()\n            server.request_response(payload).add_done_callback(\n                functools.partial(self.future_done, future))\n            return future\n\n    class ClientHandler(BaseRequestHandler):\n        async def request_response(self, payload: Payload):\n            return create_response(b'(client ' + payload.data + b')',\n                                   b'(client ' + payload.metadata + b')')\n\n    server, client = get_components(pipe)\n    server.set_handler_using_factory(ServerHandler)\n    client.set_handler_using_factory(ClientHandler)\n\n    response = await client.request_response(Payload(b'data', b'metadata'))\n\n    assert response.data == b'(server (client data))'\n    assert response.metadata == b'(server (client metadata))'\n\n\n@pytest.mark.parametrize('data_size_multiplier', (\n        1,\n        10\n))\nasync def test_request_response_fragmented(lazy_pipe, data_size_multiplier):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            return future_from_payload(request)\n\n    async with lazy_pipe(\n            server_arguments={'handler_factory': Handler, 'fragment_size_bytes': 64},\n            client_arguments={'fragment_size_bytes': 64}) as (server, client):\n        data = b'dog-dog-dog-dog-dog-dog-dog-dog-dog' * data_size_multiplier\n        response = await client.request_response(Payload(data, b'cat'))\n\n        assert response.data == b'data: ' + data\n\n\nasync def test_request_response_fragmented_empty_payload(lazy_pipe):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            return create_response()\n\n    async with lazy_pipe(\n            server_arguments={'handler_factory': Handler, 'fragment_size_bytes': 64},\n            client_arguments={'fragment_size_bytes': 64}) as (server, client):\n        response = await client.request_response(Payload())\n\n        assert response.data == b''\n        assert response.metadata == b''\n"}
{"type": "test_file", "path": "tests/rsocket/test_request_router.py", "content": "import pytest\n\nfrom rsocket.exceptions import RSocketEmptyRoute\nfrom rsocket.helpers import create_response\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\n\n\nasync def test_request_router_exception_on_duplicate_route_with_same_type():\n    router = RequestRouter()\n\n    with pytest.raises(KeyError):\n        @router.response('path1')\n        async def request_response(payload, composite_metadata) -> Awaitable[Payload]:\n            return create_response()\n\n        @router.response('path1')\n        async def request_response2(payload, composite_metadata) -> Awaitable[Payload]:\n            return create_response()\n\n\nasync def test_request_router_disallow_empty_routes():\n    router = RequestRouter()\n\n    with pytest.raises(RSocketEmptyRoute):\n        @router.response('')\n        async def request_response(payload, composite_metadata) -> Awaitable[Payload]:\n            return create_response()\n\n    with pytest.raises(RSocketEmptyRoute):\n        # noinspection PyTypeChecker\n        @router.response(None)\n        async def request_response2(payload, composite_metadata) -> Awaitable[Payload]:\n            return create_response()\n"}
{"type": "test_file", "path": "tests/rsocket/test_request_routing_decode_payload.py", "content": "import json\nfrom dataclasses import dataclass\n\nfrom rsocket.extensions.helpers import route, composite\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import utf8_decode, create_response\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\n\n\nasync def test_request_response_type_hinted_payload(lazy_pipe):\n    @dataclass\n    class Message:\n        user: str\n        message: str\n\n    router = RequestRouter(lambda cls, payload: cls(**json.loads(utf8_decode(payload.data))))\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response('test.path')\n    async def response(message: Message):\n        return create_response(ensure_bytes(message.message))\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        result = await client.request_response(Payload(\n            data=ensure_bytes(json.dumps(Message('George', 'hello').__dict__)),\n            metadata=composite(route('test.path'))))\n\n        assert result.data == b'hello'\n"}
{"type": "test_file", "path": "tests/rsocket/test_request_stream.py", "content": "import asyncio\nimport logging\nfrom typing import List, Tuple, AsyncGenerator, Generator\n\nimport pytest\n\nfrom reactivestreams.publisher import Publisher\nfrom reactivestreams.subscriber import DefaultSubscriber, Subscriber\nfrom rsocket.async_helpers import async_range\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.awaitable.collector_subscriber import CollectorSubscriber\nfrom rsocket.exceptions import RSocketValueError\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import DefaultPublisherSubscription\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.streams.stream_from_async_generator import StreamFromAsyncGenerator\nfrom rsocket.streams.stream_from_generator import StreamFromGenerator\nfrom tests.rsocket.helpers import get_components, create_large_random_data\nfrom tests.tools.helpers import measure_time\n\n\n@pytest.mark.parametrize('complete_inline', (\n        True,\n        False,\n))\nasync def test_request_stream_properly_finished(pipe: Tuple[RSocketServer, RSocketClient], complete_inline):\n    server, client = get_components(pipe)\n    response_count = 3\n\n    class Handler(BaseRequestHandler):\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return StreamFromAsyncGenerator(self.feed)\n\n        async def feed(self):\n            for x in range(response_count):\n                value = Payload('Feed Item: {}'.format(x).encode('utf-8'))\n                yield value, complete_inline and x == response_count - 1\n\n            if not complete_inline:\n                yield None, True\n\n    server.set_handler_using_factory(Handler)\n\n    measured_result = await measure_time(AwaitableRSocket(client).request_stream(Payload()))\n\n    logging.info(measured_result.delta / (response_count if complete_inline else response_count + 1))\n\n    result = measured_result.result\n    assert len(result) == response_count\n    assert result[0].data == b'Feed Item: 0'\n    assert result[1].data == b'Feed Item: 1'\n    assert result[2].data == b'Feed Item: 2'\n\n\n@pytest.mark.parametrize('complete_inline', (\n        True,\n        False,\n))\nasync def test_request_stream_properly_finished_performance(pipe_tcp: Tuple[RSocketServer, RSocketClient],\n                                                            complete_inline):\n    server, client = get_components(pipe_tcp)\n    response_count = 300\n    sample_data = create_large_random_data(1920 * 1080 * 3)\n\n    class Handler(BaseRequestHandler):\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return StreamFromAsyncGenerator(self.feed)\n\n        async def feed(self):\n            for x in range(response_count):\n                value = Payload(sample_data)\n                yield value, complete_inline and x == response_count - 1\n\n            if not complete_inline:\n                yield None, True\n\n    server.set_handler_using_factory(Handler)\n\n    measured_result = await measure_time(AwaitableRSocket(client).request_stream(Payload()))\n\n    logging.info(measured_result.delta / 2 / (response_count if complete_inline else response_count + 1))\n\n    result = measured_result.result\n    assert len(result) == response_count\n\n\n@pytest.mark.parametrize('initial_request_n', (\n        0,\n        -1,\n))\nasync def test_request_stream_prevent_negative_initial_request_n(pipe: Tuple[RSocketServer, RSocketClient],\n                                                                 initial_request_n):\n    server, client = get_components(pipe)\n\n    with pytest.raises(RSocketValueError):\n        client.request_stream(Payload()).initial_request_n(initial_request_n)\n\n\nasync def test_request_stream_returns_error_after_first_payload(pipe: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe)\n    stream_finished = asyncio.Event()\n\n    class Handler(BaseRequestHandler, DefaultPublisherSubscription):\n\n        def request(self, n: int):\n            self._subscriber.on_next(Payload(b'success'))\n            self._subscriber.on_error(Exception('error message from handler'))\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return self\n\n    class StreamSubscriber(DefaultSubscriber):\n        def __init__(self):\n            super().__init__()\n            self.received_messages: List[Payload] = []\n            self.error = None\n\n        def on_next(self, value, is_complete=False):\n            self.received_messages.append(value)\n            logging.info(value)\n\n        def on_error(self, exception: Exception):\n            self.error = exception\n            stream_finished.set()\n\n    server.set_handler_using_factory(Handler)\n\n    stream_subscriber = StreamSubscriber()\n\n    client.request_stream(Payload()).subscribe(stream_subscriber)\n\n    await stream_finished.wait()\n\n    assert len(stream_subscriber.received_messages) == 1\n    assert stream_subscriber.received_messages[0].data == b'success'\n    assert type(stream_subscriber.error) == RuntimeError\n    assert str(stream_subscriber.error) == 'error message from handler'\n\n\nasync def test_request_stream_and_cancel_after_first_message(pipe: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe)\n    stream_canceled = asyncio.Event()\n\n    async def feed():\n        for x in range(3):\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == 2\n            await asyncio.sleep(1)\n\n    class Handler(BaseRequestHandler):\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return StreamFromAsyncGenerator(feed, on_cancel=lambda: stream_canceled.set())\n\n    class StreamSubscriber(DefaultSubscriber):\n        def __init__(self):\n            super().__init__()\n            self.received_messages: List[Payload] = []\n\n        def on_next(self, value, is_complete=False):\n            self.received_messages.append(value)\n            self.subscription.cancel()\n            logging.info(value)\n\n    server.set_handler_using_factory(Handler)\n\n    stream_subscriber = StreamSubscriber()\n\n    client.request_stream(Payload()).subscribe(stream_subscriber)\n\n    await stream_canceled.wait()\n\n    assert len(stream_subscriber.received_messages) == 1\n    assert stream_subscriber.received_messages[0].data == b'Feed Item: 0'\n\n\nasync def test_request_stream_and_disconnect_client_after_first_message(pipe: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe)\n    sent_message = 0\n\n    async def feed():\n        nonlocal sent_message\n        async for x in async_range(5):\n            sent_message += 1\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == 4\n            await asyncio.sleep(1)\n\n    class Handler(BaseRequestHandler):\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return StreamFromAsyncGenerator(feed)\n\n    class StreamSubscriber(DefaultSubscriber):\n        def __init__(self):\n            super().__init__()\n            self.received_messages: List[Payload] = []\n\n        def on_next(self, value, is_complete=False):\n            self.received_messages.append(value)\n            logging.info(value)\n\n    server.set_handler_using_factory(Handler)\n\n    stream_subscriber = StreamSubscriber()\n\n    client.request_stream(Payload()).subscribe(stream_subscriber)\n\n    await asyncio.sleep(2)\n    await client.close()\n    await asyncio.sleep(1)\n    assert len(stream_subscriber.received_messages) < 5\n    assert 0 < sent_message < 5\n    assert stream_subscriber.received_messages[0].data == b'Feed Item: 0'\n\n\nasync def test_request_stream_immediately_completed_by_server_without_payloads(\n        pipe: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe)\n    stream_done = asyncio.Event()\n\n    class Handler(BaseRequestHandler, DefaultPublisherSubscription):\n\n        def request(self, n: int):\n            self._subscriber.on_complete()\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return self\n\n    class StreamSubscriber(DefaultSubscriber):\n        def __init__(self):\n            super().__init__()\n            self.received_messages: List[Payload] = []\n\n        def on_next(self, value, is_complete=False):\n            self.received_messages.append(value)\n            self.subscription.cancel()\n            logging.info(value)\n\n        def on_complete(self):\n            stream_done.set()\n\n    server.set_handler_using_factory(Handler)\n\n    stream_subscriber = StreamSubscriber()\n\n    client.request_stream(Payload()).subscribe(stream_subscriber)\n\n    await stream_done.wait()\n\n    assert len(stream_subscriber.received_messages) == 0\n\n\nasync def test_request_stream_with_back_pressure(pipe: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe)\n    requests_received = 0\n\n    class Handler(BaseRequestHandler, DefaultPublisherSubscription):\n\n        def subscribe(self, subscriber: Subscriber):\n            super().subscribe(subscriber)\n            self._current_item = 0\n            self._max_items = 3\n\n        def request(self, n: int):\n            nonlocal requests_received\n            requests_received += n\n\n            if self._current_item < self._max_items:\n                is_complete = self._current_item == self._max_items - 1\n                value = Payload('Feed Item: {}'.format(self._current_item).encode('utf-8'))\n                self._subscriber.on_next(value, is_complete)\n                self._current_item += 1\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return self\n\n    server.set_handler_using_factory(Handler)\n\n    stream_subscriber = CollectorSubscriber(limit_rate=1)\n\n    client.request_stream(Payload()).initial_request_n(1).subscribe(stream_subscriber)\n\n    received_messages = await stream_subscriber.run()\n\n    assert len(received_messages) == 3\n    assert received_messages[0].data == b'Feed Item: 0'\n    assert received_messages[1].data == b'Feed Item: 1'\n    assert received_messages[2].data == b'Feed Item: 2'\n\n    assert requests_received == 3\n\n\nasync def test_fragmented_stream(lazy_pipe):\n    def generator() -> Generator[Tuple[Payload, bool], None, None]:\n        for i in range(3):\n            yield Payload(ensure_bytes('%s some long data which should be fragmented %s' % (i, i))), i == 2\n\n    class Handler(BaseRequestHandler):\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return StreamFromGenerator(generator)\n\n    async with lazy_pipe(\n            server_arguments={'handler_factory': Handler, 'fragment_size_bytes': 64}) as (server, client):\n        received_messages = await AwaitableRSocket(client).request_stream(Payload())\n\n        assert len(received_messages) == 3\n        assert received_messages[0].data == b'0 some long data which should be fragmented 0'\n        assert received_messages[1].data == b'1 some long data which should be fragmented 1'\n        assert received_messages[2].data == b'2 some long data which should be fragmented 2'\n\n\n@pytest.mark.timeout(15)\nasync def test_request_stream_concurrent_request_n(pipe: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe)\n\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        item_count = 10\n        for j in range(item_count):\n            await asyncio.sleep(1)\n            is_complete = j == item_count - 1\n            yield Payload(ensure_bytes('Feed Item: %s' % j)), is_complete\n\n    class Handler(BaseRequestHandler):\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return StreamFromAsyncGenerator(generator)\n\n    class StreamSubscriber(CollectorSubscriber):\n\n        def on_subscribe(self, subscription):\n            super().on_subscribe(subscription)\n            asyncio.create_task(self.request_n_sender())\n\n        async def request_n_sender(self):\n            for k in range(4):\n                await asyncio.sleep(1)\n                self.subscription.request(3)\n\n    server.set_handler_using_factory(Handler)\n\n    stream_subscriber = StreamSubscriber()\n\n    client.request_stream(Payload()).initial_request_n(1).subscribe(stream_subscriber)\n\n    received_messages = await stream_subscriber.run()\n\n    assert len(received_messages) == 10\n\n    for i in range(10):\n        assert received_messages[i].data == 'Feed Item: {}'.format(i).encode()\n\n\nasync def test_request_stream_fragmented(lazy_pipe):\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        yield Payload(ensure_bytes('Feed Item: 1')), True\n\n    class Handler(BaseRequestHandler):\n\n        async def request_stream(self, payload: Payload) -> Publisher:\n            if payload.data != b'dog-dog-dog-dog-dog-dog-dog-dog-dog' * 10:\n                raise Exception()\n\n            return StreamFromAsyncGenerator(generator)\n\n    async with lazy_pipe(\n            server_arguments={'handler_factory': Handler},\n            client_arguments={'fragment_size_bytes': 64}) as (server, client):\n        data = b'dog-dog-dog-dog-dog-dog-dog-dog-dog' * 10\n\n        response = await AwaitableRSocket(client).request_stream(\n            Payload(data, b'cat'))\n\n        assert response[0].data == b'Feed Item: 1'\n"}
{"type": "test_file", "path": "tests/rsocket/test_resume_unsupported.py", "content": "import asyncio\nfrom typing import Tuple\n\nimport pytest\n\nfrom rsocket.error_codes import ErrorCode\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.frame import SetupFrame, ResumeFrame\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom tests.rsocket.helpers import get_components\nfrom tests.rsocket.misbehaving_rsocket import MisbehavingRSocket\n\n\n@pytest.mark.allow_error_log(regex_filter='Protocol error')\nasync def test_setup_resume_unsupported(pipe_tcp_without_auto_connect: Tuple[RSocketServer, RSocketClient]):\n    _, client = get_components(pipe_tcp_without_auto_connect)\n    received_error_code = None\n    error_received = asyncio.Event()\n\n    class Handler(BaseRequestHandler):\n        async def on_error(self, error_code: ErrorCode, payload: Payload):\n            nonlocal received_error_code\n            received_error_code = error_code\n            error_received.set()\n\n    client.set_handler_using_factory(Handler)\n\n    async with client as connected_client:\n        transport = await connected_client._current_transport()\n        bad_client = MisbehavingRSocket(transport)\n\n        setup = SetupFrame()\n        setup.flags_lease = False\n        setup.flags_resume = True\n        setup.token_length = 1\n        setup.resume_identification_token = b'a'\n        setup.keep_alive_milliseconds = 123\n        setup.max_lifetime_milliseconds = 456\n        setup.data_encoding = WellKnownMimeTypes.APPLICATION_JSON.name.encode()\n        setup.metadata_encoding = WellKnownMimeTypes.APPLICATION_JSON.name.encode()\n\n        await bad_client.send_frame(setup)\n\n        await error_received.wait()\n\n        assert received_error_code == ErrorCode.UNSUPPORTED_SETUP\n\n\n@pytest.mark.allow_error_log(regex_filter='Protocol error')\nasync def test_resume_request_unsupported(pipe_tcp: Tuple[RSocketServer, RSocketClient]):\n    server, client = get_components(pipe_tcp)\n\n    received_error_code = None\n    error_received = asyncio.Event()\n\n    class Handler(BaseRequestHandler):\n        async def on_error(self, error_code: ErrorCode, payload: Payload):\n            nonlocal received_error_code\n            received_error_code = error_code\n            error_received.set()\n\n    client.set_handler_using_factory(Handler)\n\n    transport = await client._current_transport()\n    bad_client = MisbehavingRSocket(transport)\n\n    resume = ResumeFrame()\n    resume.token_length = 1\n    resume.resume_identification_token = b'a'\n    resume.first_client_position = 123\n    resume.last_server_position = 1234\n\n    await bad_client.send_frame(resume)\n\n    await error_received.wait()\n\n    assert received_error_code == ErrorCode.REJECTED_RESUME\n"}
{"type": "test_file", "path": "tests/rsocket/test_routing.py", "content": "import asyncio\nimport json\n\nimport pytest\n\nfrom reactivestreams.subscriber import DefaultSubscriber\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.error_codes import ErrorCode\nfrom rsocket.extensions.authentication import Authentication, AuthenticationSimple\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.extensions.helpers import route, composite, authenticate_simple\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import create_response\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rx_support.rx_rsocket import RxRSocket\nfrom rsocket.streams.stream_from_generator import StreamFromGenerator\n\n\nasync def test_routed_request_stream_properly_finished(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    def feed():\n        for x in range(3):\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == 2\n\n    @router.stream('test.path')\n    async def response_stream(payload, composite_metadata):\n        return StreamFromGenerator(feed)\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        received_messages = await AwaitableRSocket(client).request_stream(\n            Payload(metadata=composite(route('test.path'))))\n\n        assert len(received_messages) == 3\n        assert received_messages[0].data == b'Feed Item: 0'\n        assert received_messages[1].data == b'Feed Item: 1'\n        assert received_messages[2].data == b'Feed Item: 2'\n\n\nasync def test_routed_request_response_properly_finished(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response('test.path')\n    async def response():\n        return create_response(b'result')\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        result = await client.request_response(Payload(metadata=composite(route('test.path'))))\n\n        assert result.data == b'result'\n\n\nasync def test_routed_request_response_aliases(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response('test.path')\n    @router.response('test.alternate_path')\n    async def response():\n        return create_response(b'result')\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        result = await client.request_response(Payload(metadata=composite(route('test.path'))))\n\n        assert result.data == b'result'\n\n        result = await client.request_response(Payload(metadata=composite(route('test.alternate_path'))))\n\n        assert result.data == b'result'\n\n\nasync def test_routed_request_response_with_payload_mapper(lazy_pipe):\n    router = RequestRouter(lambda cls, _: json.loads(_.data.decode()))\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response('test.path')\n    async def response(payload: dict):\n        return create_response(('Response %s' % payload['key']).encode())\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        result = await client.request_response(Payload(data=json.dumps({'key': 'value'}).encode(),\n                                                       metadata=composite(route('test.path'))))\n\n        assert result.data == b'Response value'\n\n\nasync def test_routed_request_response_properly_finished_accept_payload_only(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response('test.path')\n    async def response(payload: Payload):\n        return create_response(('Response %s' % payload.data.decode()).encode())\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        result = await client.request_response(Payload(data=b'request', metadata=composite(route('test.path'))))\n\n        assert result.data == b'Response request'\n\n\nasync def test_routed_request_response_properly_finished_accept_metadata_only(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response('test.path')\n    async def response(composite_metadata: CompositeMetadata):\n        return create_response(metadata=composite_metadata.items[0].tags[0])\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        result = await client.request_response(Payload(metadata=composite(route('test.path'))))\n\n        assert result.metadata == b'test.path'\n\n\nasync def test_routed_request_response_properly_finished_accept_payload_and_metadata(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response('test.path')\n    async def response(payload: Payload, composite_metadata: CompositeMetadata):\n        return create_response(('Response %s' % payload.data.decode()).encode(),\n                               composite_metadata.items[0].tags[0])\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        result = await client.request_response(Payload(data=b'request', metadata=composite(route('test.path'))))\n\n        assert result.data == b'Response request'\n        assert result.metadata == b'test.path'\n\n\nasync def test_routed_fire_and_forget(lazy_pipe):\n    router = RequestRouter()\n    received_data = None\n    received = asyncio.Event()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.fire_and_forget('test.path')\n    async def fire_and_forget(payload):\n        nonlocal received_data\n        received_data = payload.data\n        received.set()\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        await client.fire_and_forget(Payload(b'request data', composite(route('test.path'))))\n\n        await received.wait()\n        assert received_data == b'request data'\n\n\nasync def test_routed_request_channel_properly_finished(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    def feed():\n        for x in range(3):\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == 2\n\n    @router.channel('test.path')\n    async def response_stream():\n        return StreamFromGenerator(feed), DefaultSubscriber()\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        received_messages = await AwaitableRSocket(client).request_channel(\n            Payload(metadata=composite(route('test.path'))))\n\n        assert len(received_messages) == 3\n        assert received_messages[0].data == b'Feed Item: 0'\n        assert received_messages[1].data == b'Feed Item: 1'\n        assert received_messages[2].data == b'Feed Item: 2'\n\n\nasync def test_routed_push_metadata(lazy_pipe):\n    router = RequestRouter()\n    received_metadata = None\n    received = asyncio.Event()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.metadata_push('test.path')\n    async def metadata_push(payload):\n        nonlocal received_metadata\n        received_metadata = payload.metadata\n        received.set()\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        metadata = composite(route('test.path'))\n        await client.metadata_push(metadata)\n\n        await received.wait()\n        assert received_metadata == metadata\n\n\n@pytest.mark.allow_error_log(regex_filter='Request response error:')\nasync def test_invalid_request_response(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response('test.path')\n    async def request_response():\n        raise Exception('error from server')\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        with pytest.raises(Exception) as exc_info:\n            await client.request_response(Payload(metadata=composite(route('test.path'))))\n\n        assert str(exc_info.value) == 'error from server'\n\n\n@pytest.mark.allow_error_log(regex_filter='Request stream error:')\nasync def test_invalid_request_stream(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.stream('test.path')\n    async def request_stream():\n        raise Exception('error from server')\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        with pytest.raises(Exception) as exc_info:\n            await RxRSocket(client).request_stream(Payload(metadata=composite(route('test.path'))))\n\n        assert str(exc_info.value) == 'error from server'\n\n\n@pytest.mark.allow_error_log(regex_filter='Request channel error:')\nasync def test_invalid_request_channel(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.channel('test.path')\n    async def request_channel():\n        raise Exception('error from server')\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        with pytest.raises(Exception) as exc_info:\n            await RxRSocket(client).request_channel(Payload(metadata=composite(route('test.path'))))\n\n        assert str(exc_info.value) == 'error from server'\n\n\n@pytest.mark.allow_error_log(regex_filter='Request channel error:')\nasync def test_no_route_in_request(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        with pytest.raises(Exception) as exc_info:\n            await RxRSocket(client).request_channel(Payload(metadata=composite(authenticate_simple('user', 'pass'))))\n\n        assert str(exc_info.value) == 'No route found in request'\n\n\n@pytest.mark.allow_error_log(regex_filter='Request channel error:')\nasync def test_invalid_authentication_in_routing_handler(lazy_pipe):\n    router = RequestRouter()\n\n    async def authenticate(path: str, authentication: Authentication):\n        if not isinstance(authentication, AuthenticationSimple) or authentication.password != b'pass':\n            raise Exception('Invalid credentials')\n\n    @router.channel('test.path')\n    async def request_channel():\n        raise Exception('error from server')\n\n    def handler_factory():\n        return RoutingRequestHandler(router, authentication_verifier=authenticate)\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        with pytest.raises(Exception) as exc_info:\n            await RxRSocket(client).request_channel(\n                Payload(metadata=composite(route('test.path'),\n                                           authenticate_simple('user', 'wrong_password')))\n            )\n\n        assert str(exc_info.value) == 'Invalid credentials'\n\n\nasync def test_valid_authentication_in_routing_handler(lazy_pipe):\n    router = RequestRouter()\n\n    async def authenticate(path: str, authentication: Authentication):\n        if not isinstance(authentication, AuthenticationSimple) or authentication.password != b'pass':\n            raise Exception('Invalid credentials')\n\n    @router.response('test.path')\n    async def response():\n        return create_response(b'result')\n\n    def handler_factory():\n        return RoutingRequestHandler(router, authentication_verifier=authenticate)\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        result = await RxRSocket(client).request_response(Payload(metadata=composite(route('test.path'),\n                                                                                     authenticate_simple('user',\n                                                                                                         'pass'))))\n\n        assert result.data == b'result'\n\n\n@pytest.mark.allow_error_log(regex_filter='(RSocket error REJECTED_SETUP|Setup error)')\nasync def test_invalid_metadata_for_routing(lazy_pipe):\n    router = RequestRouter()\n\n    async def authenticate(path: str, authentication: Authentication):\n        if not isinstance(authentication, AuthenticationSimple) or authentication.password != b'pass':\n            raise Exception('Invalid credentials')\n\n    error_wait = asyncio.Event()\n\n    def client_handler_factory():\n        class ClientHandler(BaseRequestHandler):\n            async def on_error(self, error_code: ErrorCode, payload: Payload):\n                error_wait.set()\n\n        return ClientHandler()\n\n    @router.response('test.path')\n    async def response():\n        return create_response(b'result')\n\n    def handler_factory():\n        return RoutingRequestHandler(router, authentication_verifier=authenticate)\n\n    async with lazy_pipe(\n            client_arguments={'handler_factory': client_handler_factory},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        await error_wait.wait()\n"}
{"type": "test_file", "path": "tests/rsocket/test_routing_unknown_route.py", "content": "import asyncio\n\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.extensions.helpers import route, composite\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import create_response\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.streams.stream_from_generator import StreamFromGenerator\n\n\nasync def test_routed_request_response_unknown_route(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.response_unknown()\n    async def response():\n        return create_response(b'fallback')\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        result = await client.request_response(Payload(metadata=composite(route('test.path'))))\n\n        assert result.data == b'fallback'\n\n\nasync def test_routed_fire_and_forget_unknown_route(lazy_pipe):\n    router = RequestRouter()\n    event = asyncio.Event()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.fire_and_forget_unknown()\n    async def response():\n        event.set()\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        await client.fire_and_forget(Payload(metadata=composite(route('test.path'))))\n\n        await event.wait()\n\n\nasync def test_routed_metadata_push_unknown_route(lazy_pipe):\n    router = RequestRouter()\n    event = asyncio.Event()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.metadata_push_unknown()\n    async def response():\n        event.set()\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        await client.metadata_push(composite(route('test.path')))\n\n        await event.wait()\n\n\nasync def test_routed_request_stream_unknown_route(lazy_pipe):\n    router = RequestRouter()\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    @router.stream_unknown()\n    async def response_stream(payload, composite_metadata):\n        return StreamFromGenerator(\n            lambda: ((Payload(ensure_bytes(str(i))), index == 9) for i, index in enumerate(range(10))))\n\n    async with lazy_pipe(\n            client_arguments={'metadata_encoding': WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA},\n            server_arguments={'handler_factory': handler_factory}) as (server, client):\n        received_messages = await AwaitableRSocket(client).request_stream(\n            Payload(metadata=composite(route('test.path'))))\n\n        assert len(received_messages) == 10\n"}
{"type": "test_file", "path": "tests/rsocket/test_rsocket.py", "content": "import asyncio\nimport logging\nfrom datetime import timedelta\nfrom typing import Union\n\nimport pytest\n\nfrom rsocket.error_codes import ErrorCode\nfrom rsocket.exceptions import RSocketProtocolError\nfrom rsocket.helpers import create_response\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket import RSocket\nfrom rsocket.rsocket_internal import RSocketInternal\n\n\nasync def test_rsocket_client_closed_without_requests(lazy_pipe):\n    async with lazy_pipe():\n        pass  # This should not raise an exception\n\n\nasync def test_rsocket_max_server_keepalive_reached_and_request_not_canceled_by_default(lazy_pipe_tcp):\n    \"\"\"todo: find why test only works using tcp transport\"\"\"\n\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            await asyncio.sleep(4)\n            return create_response(b'response')\n\n    async with lazy_pipe_tcp(\n            client_arguments={\n                'keep_alive_period': timedelta(seconds=2),\n                'max_lifetime_period': timedelta(seconds=1)\n            },\n            server_arguments={'handler_factory': Handler}) as (server, client):\n        result = await client.request_response(Payload(b'dog', b'cat'))\n\n        assert result.data == b'response'\n\n\nasync def test_rsocket_max_server_keepalive_reached_and_request_canceled_explicitly(lazy_pipe):\n    class Handler(BaseRequestHandler):\n        async def request_response(self, request: Payload):\n            await asyncio.sleep(4)\n            return create_response(b'response')\n\n    class ClientHandler(BaseRequestHandler):\n\n        async def on_keepalive_timeout(self,\n                                       time_since_last_keepalive: timedelta,\n                                       socket: Union[RSocketInternal, RSocket]):\n            socket.stop_all_streams(data=b'Server not alive')\n\n    async with lazy_pipe(\n            client_arguments={\n                'keep_alive_period': timedelta(seconds=2),\n                'max_lifetime_period': timedelta(seconds=1),\n                'handler_factory': ClientHandler},\n            server_arguments={'handler_factory': Handler}) as (server, client):\n        with pytest.raises(RSocketProtocolError) as exc_info:\n            await client.request_response(Payload(b'dog', b'cat'))\n\n        assert exc_info.value.data == 'Server not alive'\n        assert exc_info.value.error_code == ErrorCode.CONNECTION_ERROR\n\n\nasync def test_rsocket_keepalive(pipe, caplog):\n    caplog.set_level(logging.DEBUG)\n    await asyncio.sleep(2)\n\n    found_client_sent_keepalive = False\n    found_client_received_keepalive = False\n    found_server_sent_keepalive = False\n    found_server_received_keepalive = False\n\n    for record in caplog.records:\n        if record.message == 'client: Sent frame (type=KEEPALIVE, stream_id=0)':\n            found_client_sent_keepalive = True\n        if record.message == 'server: Received frame (type=KEEPALIVE, stream_id=0)':\n            found_server_received_keepalive = True\n        if record.message == 'server: Sent frame (type=KEEPALIVE, stream_id=0)':\n            found_server_sent_keepalive = True\n        if record.message == 'client: Received frame (type=KEEPALIVE, stream_id=0)':\n            found_client_received_keepalive = True\n\n        assert record.levelname not in (\"CRITICAL\", \"ERROR\", \"WARNING\")\n\n    assert found_client_sent_keepalive\n    assert found_client_received_keepalive\n    assert found_server_sent_keepalive\n    assert found_server_received_keepalive\n"}
{"type": "test_file", "path": "tests/rsocket/test_setup.py", "content": "from asyncio import Event\nfrom typing import Optional\n\nimport pytest\n\nfrom rsocket.helpers import create_response\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\n\n\n@pytest.mark.parametrize('data_mimetype', (\n        'application/json',\n        'custom_defined/custom_type'\n))\nasync def test_setup_with_explicit_data_encoding(lazy_pipe, data_mimetype):\n    received_data_encoding_event = Event()\n    received_data_encoding: Optional[bytes] = None\n\n    class ServerHandler(BaseRequestHandler):\n        def __init__(self):\n            self._authenticated = False\n\n        async def on_setup(self,\n                           data_encoding: bytes,\n                           metadata_encoding: bytes,\n                           payload: Payload):\n            nonlocal received_data_encoding\n            received_data_encoding = data_encoding\n            received_data_encoding_event.set()\n\n        async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n            return create_response(b'response')\n\n    async with lazy_pipe(\n            client_arguments={\n                'data_encoding': data_mimetype\n            },\n            server_arguments={\n                'handler_factory': ServerHandler\n            }):\n        await received_data_encoding_event.wait()\n\n        assert received_data_encoding == data_mimetype.encode()\n"}
{"type": "test_file", "path": "tests/rsocket/test_stream_data_mimetype.py", "content": "from rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.extensions.stream_data_mimetype import StreamDataMimetypes\n\n\ndef test_stream_data_mimetypes_equality():\n    assert StreamDataMimetypes() == StreamDataMimetypes([])\n    assert StreamDataMimetypes([WellKnownMimeTypes.APPLICATION_JSON]) == StreamDataMimetypes(\n        [WellKnownMimeTypes.APPLICATION_JSON])\n    assert StreamDataMimetypes([WellKnownMimeTypes.APPLICATION_JSON]) != StreamDataMimetypes(\n        [WellKnownMimeTypes.TEXT_PLAIN])\n"}
{"type": "test_file", "path": "tests/rsocket/test_stream_control.py", "content": "import pytest\n\nfrom rsocket.exceptions import RSocketStreamAllocationFailure, RSocketStreamIdInUse\nfrom rsocket.frame import CONNECTION_STREAM_ID\nfrom rsocket.stream_control import StreamControl, MAX_STREAM_ID\n\n\n@pytest.mark.parametrize('first_stream_id', (1, 2))\ndef test_stream_control_first_allocated_stream(first_stream_id):\n    control = StreamControl(first_stream_id)\n\n    assert control.allocate_stream() == first_stream_id\n\n\n@pytest.mark.parametrize('first_stream_id', (1, 2))\ndef test_stream_control_allocate_relevant_streams(first_stream_id):\n    control = StreamControl(first_stream_id)\n\n    for i in range(3000):\n        assert control.allocate_stream() % 2 == first_stream_id % 2\n\n\ndef test_stream_control_disallow_registering_connection_stream_id():\n    control = StreamControl(1)\n\n    with pytest.raises(RuntimeError):\n        control.register_stream(CONNECTION_STREAM_ID, object())\n\n\ndef test_stream_control_disallow_registering_stream_id_larger_than_max():\n    control = StreamControl(1)\n\n    with pytest.raises(RuntimeError):\n        control.register_stream(MAX_STREAM_ID + 1, object())\n\n\n@pytest.mark.parametrize('first_stream_id', (1, 2))\ndef test_stream_control_raise_exception_on_no_streams_available(first_stream_id):\n    control = StreamControl(first_stream_id)\n    maximum_stream_id = 0x7F\n    control._maximum_stream_id = maximum_stream_id\n    dummy_stream = object()\n\n    for i in range(first_stream_id, maximum_stream_id + 1, 2):  # fill all streams with dummy\n        control.register_stream(i, dummy_stream)\n\n    with pytest.raises(RSocketStreamAllocationFailure):\n        for i in range(maximum_stream_id):\n            control.allocate_stream()\n\n\ndef test_stream_control_reuse_old_stream_ids():\n    control = StreamControl(1)\n    maximum_stream_id = 0x7F\n    control._maximum_stream_id = maximum_stream_id\n    control._current_stream_id = 15\n    dummy_stream = object()\n\n    for i in range(1, maximum_stream_id + 1, 2):  # fill all streams with dummy\n        control.register_stream(i, dummy_stream)\n\n    control.finish_stream(5)\n\n    next_stream = control.allocate_stream()\n\n    assert next_stream == 5\n\n\ndef test_stream_in_use():\n    control = StreamControl(1)\n\n    control.assert_stream_id_available(1)\n\n    control.register_stream(1, object())\n\n    with pytest.raises(RSocketStreamIdInUse) as exc_info:\n        control.assert_stream_id_available(1)\n\n    assert exc_info.value.stream_id == 1\n"}
{"type": "test_file", "path": "tests/rsocket/test_unimplemented_handler.py", "content": "from typing import Tuple\n\nimport pytest\n\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom tests.rsocket.helpers import get_components\n\n\n@pytest.mark.allow_error_log(regex_filter='(Protocol|Setup|Unknown) error')\nasync def test_request_response_not_implemented_by_server_by_default(pipe: Tuple[RSocketServer, RSocketClient]):\n    payload = Payload(b'abc', b'def')\n    server, client = get_components(pipe)\n\n    with pytest.raises(RuntimeError) as exc_info:\n        await client.request_response(payload)\n\n    assert str(exc_info.value) == 'Not implemented'\n\n\n@pytest.mark.allow_error_log(regex_filter='(Protocol|Setup|Unknown) error')\nasync def test_request_stream_not_implemented_by_server_by_default(pipe: Tuple[RSocketServer, RSocketClient]):\n    payload = Payload(b'abc', b'def')\n    server, client = get_components(pipe)\n\n    with pytest.raises(RuntimeError) as exc_info:\n        await AwaitableRSocket(client).request_stream(payload)\n\n    assert str(exc_info.value) == 'Not implemented'\n\n\n@pytest.mark.allow_error_log(regex_filter='(Protocol|Setup|Unknown) error')\nasync def test_request_channel_not_implemented_by_server_by_default(pipe: Tuple[RSocketServer, RSocketClient]):\n    payload = Payload(b'abc', b'def')\n    server, client = get_components(pipe)\n\n    with pytest.raises(RuntimeError) as exc_info:\n        await AwaitableRSocket(client).request_channel(payload)\n\n    assert str(exc_info.value) == 'Not implemented'\n"}
{"type": "test_file", "path": "tests/rsocket/test_without_server.py", "content": "import asyncio\nfrom typing import Optional\n\nimport pytest\n\nfrom rsocket.exceptions import RSocketTransportError\nfrom rsocket.logger import logger\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\n@pytest.mark.allow_error_log()\nasync def test_connection_never_established(unused_tcp_port: int):\n    class ClientHandler(BaseRequestHandler):\n        async def on_close(self, rsocket, exception: Optional[Exception] = None):\n            logger().info('Test Reconnecting (closed)')\n            await rsocket.reconnect()\n\n    async def transport_provider():\n        try:\n            for i in range(3):\n                client_connection = await asyncio.open_connection('localhost', unused_tcp_port)\n                yield TransportTCP(*client_connection)\n\n        except Exception:\n            logger().error('Client connection error', exc_info=True)\n            raise\n\n    with pytest.raises(RSocketTransportError):\n        async with RSocketClient(transport_provider(), handler_factory=ClientHandler):\n            await asyncio.sleep(1)\n"}
{"type": "test_file", "path": "tests/rx_support/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/rx_support/test_rx_canceled.py", "content": "import asyncio\nfrom asyncio import Event\nfrom typing import Tuple, AsyncGenerator, Optional\n\nimport pytest\nimport rx\nfrom rx import operators\n\nfrom reactivestreams.publisher import Publisher\nfrom reactivestreams.subscriber import Subscriber, DefaultSubscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.error_codes import ErrorCode\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.rx_support.rx_rsocket import RxRSocket\nfrom rsocket.streams.stream_from_async_generator import StreamFromAsyncGenerator\nfrom tests.rsocket.helpers import get_components\n\n\n@pytest.mark.parametrize('take_only_n', (\n        1,\n        2,\n        5,\n))\nasync def test_rx_support_request_stream_take_only_n(pipe: Tuple[RSocketServer, RSocketClient],\n                                                     take_only_n):\n    server, client = get_components(pipe)\n    maximum_message_count = 4\n    wait_for_server_finish = asyncio.Event()\n    items_generated = 0\n\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        nonlocal items_generated\n        for x in range(maximum_message_count):\n            items_generated += 1\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == maximum_message_count - 1\n\n    class Handler(BaseRequestHandler):\n        async def request_stream(self, payload: Payload) -> Publisher:\n            def set_server_finished(): wait_for_server_finish.set()\n\n            return StreamFromAsyncGenerator(generator,\n                                            on_cancel=set_server_finished,\n                                            on_complete=set_server_finished)\n\n    server.set_handler_using_factory(Handler)\n\n    rx_client = RxRSocket(client)\n    received_messages = await rx_client.request_stream(Payload(b'request text'),\n                                                       request_limit=1).pipe(\n        operators.map(lambda payload: payload.data),\n        operators.take(take_only_n),\n        operators.to_list()\n    )\n\n    await wait_for_server_finish.wait()\n\n    maximum_message_received = min(maximum_message_count, take_only_n)\n\n    assert len(received_messages) == maximum_message_received, 'Received message count wrong'\n    assert items_generated == maximum_message_received, 'Received message count wrong'\n\n    for i in range(maximum_message_received):\n        assert received_messages[i] == ('Feed Item: %d' % i).encode()\n\n\n@pytest.mark.parametrize('take_only_n', (\n        # 0,  # fixme: broken. doesn't send cancel to server\n        1,\n        2,\n        6,\n))\nasync def test_rx_support_request_channel_response_take_only_n(pipe: Tuple[RSocketServer, RSocketClient],\n                                                               take_only_n):\n    server, client = get_components(pipe)\n\n    maximum_message_count = 4\n    wait_for_server_finish = asyncio.Event()\n    items_generated = 0\n\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        nonlocal items_generated\n        for x in range(maximum_message_count):\n            items_generated += 1\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == maximum_message_count - 1\n\n    class Handler(BaseRequestHandler):\n        async def request_channel(self, payload: Payload) -> Tuple[Optional[Publisher], Optional[Subscriber]]:\n            def set_server_finished(): wait_for_server_finish.set()\n\n            return StreamFromAsyncGenerator(generator,\n                                            on_cancel=set_server_finished,\n                                            on_complete=set_server_finished), None\n\n    server.set_handler_using_factory(Handler)\n\n    rx_client = RxRSocket(client)\n\n    received_messages = await rx_client.request_channel(\n        Payload(b'request text'),\n        request_limit=1\n    ).pipe(\n        operators.map(lambda payload: payload.data),\n        operators.take(take_only_n),\n        operators.to_list()\n    )\n\n    if take_only_n > 0:\n        await wait_for_server_finish.wait()\n\n    maximum_message_received = min(maximum_message_count, take_only_n)\n\n    assert len(received_messages) == maximum_message_received, 'Received message count wrong'\n    assert items_generated == maximum_message_received, 'Received message count wrong'\n\n    for i in range(maximum_message_received):\n        assert received_messages[i] == ('Feed Item: %d' % i).encode()\n\n\n@pytest.mark.parametrize('take_only_n', (\n        1,\n        2,\n        6,\n))\nasync def test_rx_support_request_channel_server_take_only_n(pipe: Tuple[RSocketServer, RSocketClient],\n                                                             take_only_n):\n    server, client = get_components(pipe)\n    received_messages = []\n    items_generated = 0\n    maximum_message_count = 3\n    responder_receiving_done = asyncio.Event()\n\n    class Handler(BaseRequestHandler, DefaultSubscriber):\n\n        def on_next(self, value: Payload, is_complete=False):\n            received_messages.append(value)\n\n            if len(received_messages) < take_only_n:\n                self.subscription.request(1)\n            else:\n                self.subscription.cancel()\n                responder_receiving_done.set()\n\n        def on_complete(self):\n            responder_receiving_done.set()\n\n        async def on_error(self, error_code: ErrorCode, payload: Payload):\n            responder_receiving_done.set()\n\n        def on_subscribe(self, subscription: Subscription):\n            super().on_subscribe(subscription)\n            subscription.request(1)\n\n        async def request_channel(self, payload: Payload) -> Tuple[Optional[Publisher], Optional[Subscriber]]:\n            return None, self\n\n    server.set_handler_using_factory(Handler)\n\n    rx_client = RxRSocket(client)\n\n    def generator():\n        nonlocal items_generated\n        for x in range(maximum_message_count):\n            items_generated += 1\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8'))\n\n    requester_sending_done = Event()\n\n    await rx_client.request_channel(\n        Payload(b'request text'),\n        observable=rx.from_iterable(generator()),\n        sending_done=requester_sending_done\n    ).pipe(\n        operators.to_list()\n    )\n\n    await responder_receiving_done.wait()\n    await requester_sending_done.wait()\n\n    maximum_message_received = min(maximum_message_count, take_only_n)\n\n    # assert items_generated == maximum_message_received # todo: Stop async generator on cancel from server requester\n\n    assert len(received_messages) == maximum_message_received\n\n    for i in range(maximum_message_received):\n        assert received_messages[i].data == ('Feed Item: %d' % i).encode()\n"}
{"type": "test_file", "path": "tests/rsocket/test_stream_helpers.py", "content": "from asyncio import Queue\n\nfrom rsocket.streams.helpers import async_generator_from_queue\n\n\nasync def test_async_generator_from_queue():\n    queue = Queue()\n\n    for i in range(10):\n        queue.put_nowait(i)\n\n    queue.put_nowait(None)\n\n    async def collect():\n        results = []\n        async for i in async_generator_from_queue(queue):\n            results.append(i)\n\n        return results\n\n    r = await collect()\n\n    assert r == list(range(10))\n"}
{"type": "test_file", "path": "tests/rx_support/test_rx_handler.py", "content": "import pytest\n\nfrom rsocket.payload import Payload\nfrom rsocket.rx_support.rx_handler import BaseRxHandler\n\n\nasync def test_rx_handler():\n    handler = BaseRxHandler()\n\n    with pytest.raises(Exception):\n        await handler.request_channel(Payload())\n\n    with pytest.raises(Exception):\n        await handler.request_response(Payload())\n\n    with pytest.raises(Exception):\n        await handler.request_stream(Payload())\n"}
{"type": "test_file", "path": "tests/rx_support/test_rx_error.py", "content": "import asyncio\nfrom typing import Tuple, AsyncGenerator, Optional\n\nimport pytest\nimport rx\nfrom rx import operators\nfrom rx.core.typing import Observer, Scheduler\nfrom rx.disposable import Disposable\n\nfrom reactivestreams.publisher import Publisher\nfrom reactivestreams.subscriber import Subscriber, DefaultSubscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.rx_support.rx_rsocket import RxRSocket\nfrom rsocket.streams.stream_from_async_generator import StreamFromAsyncGenerator\nfrom tests.rsocket.helpers import get_components\n\n\n@pytest.mark.allow_error_log(regex_filter='Stream error')\n@pytest.mark.parametrize('success_count, request_limit', (\n        (0, 2),\n        (2, 2),\n        (3, 2),\n))\nasync def test_rx_support_request_stream_with_error(pipe: Tuple[RSocketServer, RSocketClient],\n                                                    success_count,\n                                                    request_limit):\n    server, client = get_components(pipe)\n\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        for x in range(success_count):\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), False\n\n        raise Exception('Some error from responder')\n\n    class Handler(BaseRequestHandler):\n        async def request_stream(self, payload: Payload) -> Publisher:\n            return StreamFromAsyncGenerator(generator)\n\n    server.set_handler_using_factory(Handler)\n\n    rx_client = RxRSocket(client)\n\n    with pytest.raises(Exception):\n        await rx_client.request_stream(\n            Payload(b'request text'),\n            request_limit=request_limit\n        ).pipe(\n            operators.map(lambda payload: payload.data),\n            operators.to_list()\n        )\n\n\n@pytest.mark.parametrize('success_count, request_limit', (\n        (0, 2),\n        (2, 2),\n        (3, 2),\n))\nasync def test_rx_support_request_channel_with_error_from_requester(\n        pipe: Tuple[RSocketServer, RSocketClient],\n        success_count,\n        request_limit):\n    server, client = get_components(pipe)\n    responder_received_error = asyncio.Event()\n    server_received_messages = []\n    received_error = None\n\n    class ResponderSubscriber(DefaultSubscriber):\n\n        def on_subscribe(self, subscription: Subscription):\n            super().on_subscribe(subscription)\n            self.subscription.request(1)\n\n        def on_next(self, value, is_complete=False):\n            if len(value.data) > 0:\n                server_received_messages.append(value.data)\n            self.subscription.request(1)\n\n        def on_error(self, exception: Exception):\n            nonlocal received_error\n            received_error = exception\n            responder_received_error.set()\n\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        for x in range(success_count):\n            yield Payload('Feed Item: {}'.format(x).encode('utf-8')), x == success_count - 1\n\n    class Handler(BaseRequestHandler):\n        async def request_channel(self, payload: Payload) -> Tuple[Optional[Publisher], Optional[Subscriber]]:\n            return StreamFromAsyncGenerator(generator), ResponderSubscriber()\n\n    server.set_handler_using_factory(Handler)\n\n    rx_client = RxRSocket(client)\n\n    def test_observable(observer: Observer, scheduler: Optional[Scheduler]):\n        observer.on_error(Exception('Some error'))\n        return Disposable()\n\n    await rx_client.request_channel(\n        Payload(b'request text'),\n        observable=rx.create(test_observable),\n        request_limit=request_limit\n    ).pipe(\n        operators.map(lambda payload: payload.data),\n        operators.to_list()\n    )\n\n    await responder_received_error.wait()\n\n    assert str(received_error) == 'Some error'\n"}
{"type": "source_file", "path": "bugs/165_client.py", "content": "import asyncio\nimport logging\nfrom datetime import timedelta\n\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nasync def main(server_port):\n    logging.info(\"Connecting to server at localhost:%s\", server_port)\n\n    connection = await asyncio.open_connection(\"localhost\", server_port)\n\n    async with RSocketClient(\n            single_transport_provider(TransportTCP(*connection)),\n            fragment_size_bytes=10240,\n            keep_alive_period=timedelta(seconds=10),\n    ) as client:\n        # huge_array = bytearray(16777209) # Works\n        huge_array = bytearray(16777210)  # rsocket.exceptions.ParseError: Frame too short: 0 bytes\n        payload = Payload(huge_array)\n        await client.fire_and_forget(payload)\n        await asyncio.sleep(1)\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(10000))\n"}
{"type": "source_file", "path": "bugs/165_server.py", "content": "import asyncio\nimport logging\n\nfrom rsocket.helpers import create_future\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass Handler(BaseRequestHandler):\n    async def request_fire_and_forget(self, payload: Payload) -> Awaitable[Payload]:\n        print(f\"Receiving {len(payload.data)} bytes\")\n        return create_future(Payload(b\"OK\"))\n\n\nasync def run_server(server_port):\n    logging.info(\"Starting server at localhost:%s\", server_port)\n\n    def session(*connection):\n        RSocketServer(TransportTCP(*connection), handler_factory=Handler, fragment_size_bytes=10240)\n\n    server = await asyncio.start_server(session, \"localhost\", server_port)\n\n    async with server:\n        await server.serve_forever()\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(filename=\"rsocket.log\", format=\"%(asctime)s %(message)s\", filemode=\"w\")\n    asyncio.run(run_server(10000))"}
{"type": "source_file", "path": "bugs/__init__.py", "content": ""}
{"type": "source_file", "path": "docs/conf.py", "content": "# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\nsys.path.insert(0, os.path.abspath('..'))\n\n\n# -- Project information -----------------------------------------------------\nimport os\n\nproject = 'RSocket python'\ncopyright = '2022, jellofishi@pm.me'\nauthor = 'jellofishi@pm.me'\n\n# The full version, including alpha/beta/rc tags\nrelease = '0.4.18'\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.autosummary',\n    \"sphinx.ext.napoleon\",\n    \"sphinx.ext.viewcode\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\n# on_rtd = os.environ.get('READTHEDOCS', None) == 'True'\n#\n# if on_rtd:\n#     html_theme = 'default'\n# else:\nhtml_theme = 'sphinx_rtd_theme'\n\nhtml_sidebars = {\n    '**': ['globaltoc.html', 'relations.html', 'sourcelink.html', 'searchbox.html'],\n}\n\nhtml_css_files = ['theme_override.css']\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\nautodoc_default_flags = ['members']\nautosummary_generate = True\nautodoc_inherit_docstrings = False\nautodoc_typehints = 'description'\nautodoc_typehints_format = 'short'\nautodoc_member_order = 'bysource'\nmaster_doc = 'index'\n"}
{"type": "source_file", "path": "examples/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/cli_demo_server/server.py", "content": "import asyncio\nimport logging\n\nimport asyncclick as click\nimport reactivex\nfrom aiohttp import web\nfrom reactivex import Observable\n\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.aiohttp_websocket import TransportAioHttpWebsocket\nfrom rsocket.transports.tcp import TransportTCP\n\nrouter = RequestRouter()\n\n\n@router.response('echo')\nasync def echo(payload: Payload) -> Observable:\n    return reactivex.just(Payload(payload.data))\n\n\ndef websocket_handler_factory(**kwargs):\n    async def websocket_handler(request):\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        transport = TransportAioHttpWebsocket(ws)\n        RSocketServer(transport, **kwargs)\n        await transport.handle_incoming_ws_messages()\n        return ws\n\n    return websocket_handler\n\n\n@click.command()\n@click.option('--port', help='Port to listen on', default=6565, type=int)\n@click.option('--transport', is_flag=False, default='tcp')\nasync def start_server(port: int, transport: str):\n    logging.basicConfig(level=logging.DEBUG)\n\n    logging.info(f'Starting {transport} server at localhost:{port}')\n\n    if transport in ['ws']:\n        app = web.Application()\n        app.add_routes([web.get('/', websocket_handler_factory(\n            handler_factory=lambda: RoutingRequestHandler(router)\n        ))])\n\n        await web._run_app(app, port=port)\n    elif transport == 'tcp':\n        def handle_client(reader, writer):\n            RSocketServer(TransportTCP(reader, writer),\n                          handler_factory=lambda: RoutingRequestHandler(router))\n\n        server = await asyncio.start_server(handle_client, 'localhost', port)\n\n        async with server:\n            await server.serve_forever()\n    else:\n        raise Exception(f'Unsupported transport {transport}')\n\n\nif __name__ == '__main__':\n    start_server()\n"}
{"type": "source_file", "path": "examples/client.py", "content": "import asyncio\nimport logging\nimport sys\n\nfrom examples.shared_tests import simple_client_server_test\nfrom reactivestreams.subscriber import DefaultSubscriber\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass StreamSubscriber(DefaultSubscriber):\n\n    def on_next(self, value, is_complete=False):\n        logging.info('RS: {}'.format(value))\n        self.subscription.request(1)\n\n\nasync def main(server_port):\n    logging.info('Connecting to server at localhost:%s', server_port)\n\n    connection = await asyncio.open_connection('localhost', server_port)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection))) as client:\n        await simple_client_server_test(client)\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(port))\n"}
{"type": "source_file", "path": "examples/client_quic.py", "content": "import asyncio\nimport logging\nimport sys\nfrom pathlib import Path\n\nfrom aioquic.quic.configuration import QuicConfiguration\n\nfrom examples.shared_tests import simple_client_server_test\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.aioquic_transport import rsocket_connect\n\n\nasync def main(server_port):\n    logging.info('Connecting to server at localhost:%s', server_port)\n\n    client_configuration = QuicConfiguration(\n        is_client=True\n    )\n    ca_file_path = Path(__file__).parent / 'certificates' / 'pycacert.pem'\n    client_configuration.load_verify_locations(cafile=str(ca_file_path))\n\n    async with rsocket_connect('localhost', server_port,\n                               configuration=client_configuration) as transport:\n        async with RSocketClient(single_transport_provider(transport)) as client:\n            await simple_client_server_test(client)\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(port))\n"}
{"type": "source_file", "path": "examples/client_reconnect.py", "content": "import asyncio\nimport logging\nimport sys\nfrom typing import Optional\n\nfrom rsocket.extensions.helpers import route, composite, authenticate_simple\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nasync def request_response(client: RSocketClient) -> Payload:\n    payload = Payload(b'The quick brown fox', composite(\n        route('single_request'),\n        authenticate_simple('user', '12345')\n    ))\n\n    return await client.request_response(payload)\n\n\nclass Handler(BaseRequestHandler):\n\n    async def on_close(self, rsocket, exception: Optional[Exception] = None):\n        await asyncio.sleep(5)\n        await rsocket.reconnect()\n\n\nasync def main(server_port):\n    logging.info('Connecting to server at localhost:%s', server_port)\n\n    async def transport_provider(max_reconnect):\n        for i in range(max_reconnect):\n            connection = await asyncio.open_connection('localhost', server_port)\n            yield TransportTCP(*connection)\n\n    async with RSocketClient(transport_provider(3),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA,\n                             handler_factory=Handler) as client:\n        result1 = await request_response(client)\n        assert result1.data == b'single_response'\n\n        await asyncio.sleep(10)\n\n        result2 = await request_response(client)\n        assert result2.data == b'single_response'\n\n        result3 = await request_response(client)\n        assert result3.data == b'single_response'\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(port))\n"}
{"type": "source_file", "path": "examples/client_springboot.py", "content": "import asyncio\nimport json\nimport logging\nfrom uuid import uuid4\n\nfrom rsocket.extensions.helpers import composite, route, authenticate_simple\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nasync def main():\n    connection = await asyncio.open_connection('localhost', 7000)\n\n    setup_payload = Payload(\n        data=str(uuid4()).encode(),\n        metadata=composite(route('shell-client'), authenticate_simple('user', 'pass')))\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection)),\n                             setup_payload=setup_payload,\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA):\n        await asyncio.sleep(5)\n\n\ndef serialize(message) -> bytes:\n    return json.dumps(message).encode()\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main())\n"}
{"type": "source_file", "path": "examples/client_rx.py", "content": "import asyncio\nimport logging\nimport sys\nfrom asyncio import Event\nfrom typing import AsyncGenerator, Tuple\n\nfrom rx import operators\nfrom rx.core.operators.map import _map\n\nfrom examples.shared_tests import assert_result_data\nfrom reactivestreams.subscriber import Subscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.extensions.helpers import route, composite, authenticate_simple, metadata_item\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rx_support.rx_rsocket import RxRSocket\nfrom rsocket.streams.stream_from_async_generator import StreamFromAsyncGenerator\nfrom rsocket.transports.tcp import TransportTCP\n\n\ndef sample_publisher(wait_for_requester_complete: Event,\n                     response_count: int = 3):\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        current_response = 0\n        for i in range(response_count):\n            is_complete = (current_response + 1) == response_count\n\n            message = 'Item to server from client on channel: %s' % current_response\n            yield Payload(message.encode('utf-8')), is_complete\n\n            if is_complete:\n                wait_for_requester_complete.set()\n                break\n\n            current_response += 1\n\n    return StreamFromAsyncGenerator(generator)\n\n\nclass ChannelSubscriber(Subscriber):\n\n    def __init__(self, wait_for_responder_complete: Event) -> None:\n        super().__init__()\n        self._wait_for_responder_complete = wait_for_responder_complete\n\n    def on_subscribe(self, subscription: Subscription):\n        self.subscription = subscription\n\n    def on_next(self, value: Payload, is_complete=False):\n        logging.info('From server on channel: ' + value.data.decode('utf-8'))\n        if is_complete:\n            self._wait_for_responder_complete.set()\n\n    def on_error(self, exception: Exception):\n        logging.error('Error from server on channel' + str(exception))\n        self._wait_for_responder_complete.set()\n\n    def on_complete(self):\n        logging.info('Completed from server on channel')\n        self._wait_for_responder_complete.set()\n\n\nclass StreamSubscriber(Subscriber):\n\n    def __init__(self,\n                 wait_for_complete: Event,\n                 request_n_size=0):\n        self._request_n_size = request_n_size\n        self._wait_for_complete = wait_for_complete\n\n    def on_next(self, value, is_complete=False):\n        logging.info('RS: {}'.format(value))\n        if is_complete:\n            self._wait_for_complete.set()\n        else:\n            if self._request_n_size > 0:\n                self.subscription.request(self._request_n_size)\n\n    def on_complete(self):\n        logging.info('RS: Complete')\n        self._wait_for_complete.set()\n\n    def on_error(self, exception):\n        logging.info('RS: error: {}'.format(exception))\n        self._wait_for_complete.set()\n\n    def on_subscribe(self, subscription):\n        # noinspection PyAttributeOutsideInit\n        self.subscription = subscription\n\n\nasync def request_response(client: RxRSocket):\n    payload = Payload(b'The quick brown fox', composite(\n        route('single_request'),\n        authenticate_simple('user', '12345')\n    ))\n\n    result = await client.request_response(payload).pipe()\n\n    assert_result_data(result, b'single_response')\n\n\nasync def request_last_metadata(client: RxRSocket):\n    payload = Payload(metadata=composite(\n        route('last_metadata_push'),\n        authenticate_simple('user', '12345')\n    ))\n\n    result = await client.request_response(payload).pipe()\n\n    assert_result_data(result, b'audit info')\n\n\nasync def request_last_fnf(client: RxRSocket):\n    payload = Payload(metadata=composite(\n        route('last_fnf'),\n        authenticate_simple('user', '12345')\n    ))\n\n    result = await client.request_response(payload).pipe()\n\n    assert_result_data(result, b'aux data')\n\n\nasync def metadata_push(client: RxRSocket, metadata: bytes):\n    await client.metadata_push(composite(\n        route('metadata_push'),\n        authenticate_simple('user', '12345'),\n        metadata_item(metadata, WellKnownMimeTypes.TEXT_PLAIN.value.name)\n    )).pipe()\n\n\nasync def fire_and_forget(client: RxRSocket, data: bytes):\n    payload = Payload(data, composite(\n        route('no_response'),\n        authenticate_simple('user', '12345')\n    ))\n\n    await client.fire_and_forget(payload).pipe()\n\n\nasync def request_channel(client: RxRSocket):\n    # channel_completion_event = Event()\n    # requester_completion_event = Event()\n    payload = Payload(b'The quick brown fox', composite(\n        route('channel'),\n        authenticate_simple('user', '12345')\n    ))\n    # publisher = from_rsocket_publisher(sample_publisher(requester_completion_event))\n\n    result = await client.request_channel(payload, 5).pipe(operators.to_list())\n\n    # requested.initial_request_n(5).subscribe(ChannelSubscriber(channel_completion_event))\n\n    # await channel_completion_event.wait()\n    # await requester_completion_event.wait()\n\n\nasync def request_stream_invalid_login(client: RxRSocket):\n    payload = Payload(b'The quick brown fox', composite(\n        route('stream'),\n        authenticate_simple('user', 'wrong_password')\n    ))\n\n    try:\n        await client.request_stream(payload, request_limit=1).pipe()\n    except RuntimeError as exception:\n        assert str(exception) == 'Authentication error'\n\n\nasync def request_stream(client: RxRSocket):\n    payload = Payload(b'The quick brown fox', composite(\n        route('stream'),\n        authenticate_simple('user', '12345')\n    ))\n    result = await client.request_stream(payload).pipe(_map(lambda p: p.data), operators.to_list())\n\n    if result != [b'Item on channel: 0',\n                  b'Item on channel: 1',\n                  b'Item on channel: 2']:\n        raise Exception(result)\n\n\nasync def request_slow_stream(client: RxRSocket):\n    payload = Payload(b'The quick brown fox', composite(\n        route('slow_stream'),\n        authenticate_simple('user', '12345')\n    ))\n    result = await client.request_stream(payload).pipe(operators.to_list())\n    print(result)\n\n\nasync def main(server_port):\n    logging.info('Connecting to server at localhost:%s', server_port)\n\n    connection = await asyncio.open_connection('localhost', server_port)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection)),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA) as client:\n        rx_client = RxRSocket(client)\n        await request_response(rx_client)\n        await request_stream(rx_client)\n        await request_slow_stream(rx_client)\n        await request_channel(rx_client)\n        await request_stream_invalid_login(rx_client)\n\n        await metadata_push(rx_client, b'audit info')\n        await request_last_metadata(rx_client)\n\n        await fire_and_forget(rx_client, b'aux data')\n        await request_last_fnf(rx_client)\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(port))\n"}
{"type": "source_file", "path": "examples/client_website_example.py", "content": "import asyncio\nimport logging\n\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.rx_support.rx_rsocket import RxRSocket\nfrom rsocket.transports.tcp import TransportTCP\n\n\nasync def main():\n    connection = await asyncio.open_connection('localhost', 7878)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection))) as client:\n\n        rx_client = RxRSocket(client)\n        payload = Payload(b'Hello World')\n\n        result = await rx_client.request_response(payload).pipe()\n\n        logging.info(result.data)\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(main())\n"}
{"type": "source_file", "path": "examples/client_websocket.py", "content": "import logging\n\nimport aiohttp\nimport asyncclick as click\n\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.aiohttp_websocket import TransportAioHttpClient\nfrom rsocket.transports.aiohttp_websocket import websocket_client\n\n\nasync def application(with_ssl: bool, serve_port: int):\n    if with_ssl:\n        async with aiohttp.ClientSession() as session:\n            async with session.ws_connect('wss://localhost:%s' % serve_port, verify_ssl=False) as websocket:\n                async with RSocketClient(\n                        single_transport_provider(TransportAioHttpClient(websocket=websocket))) as client:\n                    result = await client.request_response(Payload(b'ping'))\n                    print(result)\n\n    else:\n        async with websocket_client('http://localhost:%s' % serve_port) as client:\n            result = await client.request_response(Payload(b'ping'))\n            print(result.data)\n\n\n@click.command()\n@click.option('--with-ssl', is_flag=False, default=False)\n@click.option('--port', is_flag=False, default=6565)\nasync def command(with_ssl, port: int):\n    logging.basicConfig(level=logging.DEBUG)\n    await application(with_ssl, port)\n\n\nif __name__ == '__main__':\n    command()\n"}
{"type": "source_file", "path": "examples/server_websockets.py", "content": "import asyncio\nimport logging\nimport sys\nfrom datetime import datetime\n\nimport websockets\n\nfrom rsocket.helpers import create_future\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.websockets_transport import WebsocketsTransport\n\n\nclass Handler(BaseRequestHandler):\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        await asyncio.sleep(0.1)  # Simulate not immediate process\n        date_time_format = payload.data.decode('utf-8')\n        formatted_date_time = datetime.now().strftime(date_time_format)\n        return create_future(Payload(formatted_date_time.encode('utf-8')))\n\n\nasync def endpoint(websocket):\n    transport = WebsocketsTransport()\n\n    async with RSocketServer(transport, handler_factory=Handler):\n        await transport.handler(websocket)\n\n\nasync def run_server(server_port):\n    logging.info('Starting server at localhost:%s', server_port)\n\n    async with websockets.serve(endpoint, \"localhost\", server_port):\n        await asyncio.Future()  # run forever\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(run_server(port))\n"}
{"type": "source_file", "path": "examples/cloudevents/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/tutorial/step0/chat_server.py", "content": "import asyncio\nimport logging\n\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import create_future, utf8_decode\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass Handler(BaseRequestHandler):\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        username = utf8_decode(payload.data)\n        return create_future(Payload(ensure_bytes(f'Welcome to chat, {username}')))\n\n\nasync def run_server():\n    def session(*connection):\n        RSocketServer(TransportTCP(*connection), handler_factory=Handler)\n\n    async with await asyncio.start_server(session, 'localhost', 6565) as server:\n        await server.serve_forever()\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(run_server())\n"}
{"type": "source_file", "path": "examples/server_quart_websocket.py", "content": "import logging\nimport sys\n\nfrom quart import Quart\n\nfrom rsocket.helpers import create_future\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.transports.quart_websocket import websocket_handler\n\napp = Quart(__name__)\n\n\nclass Handler(BaseRequestHandler):\n\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        return create_future(Payload(b'pong'))\n\n\n@app.websocket(\"/\")\nasync def ws():\n    await websocket_handler(handler_factory=Handler)\n\n\nif __name__ == \"__main__\":\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    app.run(port=port)\n"}
{"type": "source_file", "path": "examples/server_website_example.py", "content": "import asyncio\nimport logging\n\nfrom rsocket.helpers import create_future\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass Handler(BaseRequestHandler):\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        logging.info(payload.data)\n\n        return create_future(Payload(b'Echo: ' + payload.data))\n\n\nasync def run_server():\n    def session(*connection):\n        RSocketServer(TransportTCP(*connection), handler_factory=Handler)\n\n    server = await asyncio.start_server(session, 'localhost', 7878)\n\n    async with server:\n        await server.serve_forever()\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(run_server())\n"}
{"type": "source_file", "path": "examples/tutorial/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/tutorial/reactivex/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/server_with_routing.py", "content": "import asyncio\nimport logging\nimport ssl\nfrom dataclasses import dataclass\nfrom datetime import timedelta\nfrom typing import Optional\n\nimport asyncclick as click\nfrom aiohttp import web\n\nfrom examples.example_fixtures import large_data1\nfrom examples.fixtures import generate_certificate_and_key\nfrom examples.response_channel import sample_async_response_stream, LoggingSubscriber\nfrom response_stream import sample_sync_response_stream\nfrom rsocket.extensions.authentication import Authentication, AuthenticationSimple\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.helpers import create_future\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.aiohttp_websocket import TransportAioHttpWebsocket\nfrom rsocket.transports.tcp import TransportTCP\n\n\ndef handler_factory_factory(is_infinite_stream: bool = False):\n    router = RequestRouter()\n\n    @dataclass\n    class Storage:\n        last_metadata_push: Optional[bytes] = None\n        last_fire_and_forget: Optional[bytes] = None\n\n    storage = Storage()\n\n    @router.response('single_request')\n    async def single_request_response(payload, composite_metadata):\n        logging.info('Got single request')\n        return create_future(Payload(b'single_response'))\n\n    @router.response('last_fnf')\n    async def get_last_fnf():\n        logging.info('Got single request')\n        return create_future(Payload(storage.last_fire_and_forget))\n\n    @router.response('last_metadata_push')\n    async def get_last_metadata_push():\n        logging.info('Got single request')\n        return create_future(Payload(storage.last_metadata_push))\n\n    @router.response('large_data')\n    async def get_large_data():\n        return create_future(Payload(large_data1))\n\n    @router.response('large_request')\n    async def get_large_data_request(payload: Payload):\n        return create_future(Payload(payload.data))\n\n    @router.stream('stream')\n    async def stream_response(payload, composite_metadata):\n        logging.info('Got stream request')\n        return sample_async_response_stream(is_infinite_stream=is_infinite_stream)\n\n    @router.fire_and_forget('no_response')\n    async def no_response(payload: Payload, composite_metadata):\n        storage.last_fire_and_forget = payload.data\n        logging.info('No response sent to client')\n\n    @router.metadata_push('metadata_push')\n    async def metadata_push(payload: Payload, composite_metadata: CompositeMetadata):\n        for item in composite_metadata.items:\n            if item.encoding == b'text/plain':\n                storage.last_metadata_push = item.content\n\n    @router.channel('channel')\n    async def channel_response(payload:Payload, composite_metadata):\n        logging.info('Got channel request')\n        subscriber = LoggingSubscriber()\n        subscriber.on_next(payload)\n        channel = sample_async_response_stream(local_subscriber=subscriber)\n        return channel, subscriber\n\n    @router.stream('slow_stream')\n    async def stream_slow(**kwargs):\n        logging.info('Got slow stream request')\n        return sample_sync_response_stream(delay_between_messages=timedelta(seconds=2),\n                                           is_infinite_stream=is_infinite_stream)\n\n    async def authenticator(route: str, authentication: Authentication):\n        if isinstance(authentication, AuthenticationSimple):\n            if authentication.password != b'12345':\n                raise Exception('Authentication error')\n        else:\n            raise Exception('Unsupported authentication')\n\n    def handler_factory():\n        return RoutingRequestHandler(router, authenticator)\n\n    return handler_factory\n\n\ndef websocket_handler_factory(**kwargs):\n    async def websocket_handler(request):\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        transport = TransportAioHttpWebsocket(ws)\n        RSocketServer(transport, **kwargs)\n        await transport.handle_incoming_ws_messages()\n        return ws\n\n    return websocket_handler\n\n\n@click.command()\n@click.option('--port', help='Port to listen on', default=6565, type=int)\n@click.option('--with-ssl', is_flag=True, help='Enable SSL mode')\n@click.option('--transport', is_flag=False, default='tcp')\n@click.option('--infinite-stream', is_flag=True)\nasync def start_server(with_ssl: bool, port: int, transport: str, infinite_stream: bool):\n    logging.basicConfig(level=logging.DEBUG)\n\n    logging.info(f'Starting {transport} server at localhost:{port}')\n\n    if transport in ['ws', 'wss']:\n        app = web.Application()\n        app.add_routes([web.get('/', websocket_handler_factory(\n            handler_factory=handler_factory_factory(infinite_stream)\n        ))])\n\n        with generate_certificate_and_key() as (certificate_path, key_path):\n            if with_ssl:\n                ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n\n                logging.info('Certificate %s', certificate_path)\n                logging.info('Private-key %s', key_path)\n\n                ssl_context.load_cert_chain(certificate_path, key_path)\n            else:\n                ssl_context = None\n\n            await web._run_app(app, port=port, ssl_context=ssl_context)\n    elif transport == 'tcp':\n        def handle_client(reader, writer):\n            RSocketServer(TransportTCP(reader, writer),\n                          handler_factory=handler_factory_factory(infinite_stream)\n                          )\n\n        server = await asyncio.start_server(handle_client, 'localhost', port)\n\n        async with server:\n            await server.serve_forever()\n    else:\n        raise Exception(f'Unsupported transport {transport}')\n\n\nif __name__ == '__main__':\n    start_server()\n"}
{"type": "source_file", "path": "examples/server_aiohttp_websocket.py", "content": "import logging\nimport ssl\n\nimport asyncclick as click\nfrom aiohttp import web\n\nfrom fixtures import generate_certificate_and_key\nfrom rsocket.helpers import create_future\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.aiohttp_websocket import TransportAioHttpWebsocket\n\n\nclass Handler(BaseRequestHandler):\n\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        return create_future(Payload(b'pong'))\n\n\ndef websocket_handler_factory(**kwargs):\n    async def websocket_handler(request):\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        transport = TransportAioHttpWebsocket(ws)\n        RSocketServer(transport, **kwargs)\n        await transport.handle_incoming_ws_messages()\n        return ws\n\n    return websocket_handler\n\n\n@click.command()\n@click.option('--port', help='Port to listen on', default=6565, type=int)\n@click.option('--with-ssl', is_flag=True, help='Enable SSL mode')\nasync def start_server(with_ssl: bool, port: int):\n    logging.basicConfig(level=logging.DEBUG)\n    app = web.Application()\n    app.add_routes([web.get('/', websocket_handler_factory(handler_factory=Handler))])\n\n    if with_ssl:\n        ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n\n        with generate_certificate_and_key() as (certificate, key):\n            ssl_context.load_cert_chain(certificate, key)\n    else:\n        ssl_context = None\n\n    await web._run_app(app, port=port, ssl_context=ssl_context)\n\n\nif __name__ == '__main__':\n    start_server()\n"}
{"type": "source_file", "path": "examples/tutorial/reactivex/chat_client.py", "content": "import asyncio\nimport logging\nimport resource\nfrom asyncio import Task, Queue\nfrom datetime import timedelta\nfrom typing import List, Optional\n\nfrom reactivex import operators\n\nfrom examples.tutorial.reactivex.shared import (Message, chat_filename_mimetype, ServerStatistics, ClientStatistics,\n                                                ServerStatisticsRequest, encode_dataclass, dataclass_to_payload,\n                                                decode_dataclass)\nfrom rsocket.extensions.helpers import composite, route, metadata_item\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import single_transport_provider, utf8_decode\nfrom rsocket.payload import Payload\nfrom rsocket.reactivex.back_pressure_publisher import observable_from_queue, from_observable_with_backpressure\nfrom rsocket.reactivex.reactivex_client import ReactiveXClient\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass StatisticsControl:\n    def __init__(self):\n        self.queue = Queue()\n\n    def set_requested_statistics(self, ids: List[str]):\n        self.queue.put_nowait(dataclass_to_payload(ServerStatisticsRequest(ids=ids)))\n\n    def set_period(self, period: timedelta):\n        self.queue.put_nowait(\n            dataclass_to_payload(ServerStatisticsRequest(period_seconds=int(period.total_seconds()))))\n\n\nclass ChatClient:\n    def __init__(self, rsocket: RSocketClient):\n        self._rsocket = rsocket\n        self._listen_task: Optional[Task] = None\n        self._statistics_task: Optional[Task] = None\n        self._session_id: Optional[str] = None\n        self._username: Optional[str] = None\n\n    async def login(self, username: str):\n        self._username = username\n        payload = Payload(ensure_bytes(username), composite(route('login')))\n        self._session_id = (await self._rsocket.request_response(payload)).data\n        return self\n\n    async def join(self, channel_name: str):\n        request = Payload(ensure_bytes(channel_name), composite(route('channel.join')))\n        await self._rsocket.request_response(request)\n        return self\n\n    async def leave(self, channel_name: str):\n        request = Payload(ensure_bytes(channel_name), composite(route('channel.leave')))\n        await self._rsocket.request_response(request)\n        return self\n\n    def listen_for_messages(self):\n        def print_message(data: bytes):\n            message = decode_dataclass(data, Message)\n            print(f'{self._username}: from {message.user} ({message.channel}): {message.content}')\n\n        async def listen_for_messages():\n            await ReactiveXClient(self._rsocket).request_stream(Payload(metadata=composite(\n                route('messages.incoming')\n            ))).pipe(\n                operators.do_action(on_next=lambda value: print_message(value.data),\n                                    on_error=lambda exception: print(exception)))\n\n        self._listen_task = asyncio.create_task(listen_for_messages())\n\n    def stop_listening_for_messages(self):\n        self._listen_task.cancel()\n\n    async def send_statistics(self):\n        memory_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n        payload = Payload(encode_dataclass(ClientStatistics(memory_usage=memory_usage)),\n                          metadata=composite(route('statistics')))\n        await self._rsocket.fire_and_forget(payload)\n\n    def listen_for_statistics(self) -> StatisticsControl:\n        def print_statistics(value: bytes):\n            statistics = decode_dataclass(value, ServerStatistics)\n            print(f'users: {statistics.user_count}, channels: {statistics.channel_count}')\n\n        control = StatisticsControl()\n\n        async def listen_for_statistics():\n            await ReactiveXClient(self._rsocket).request_channel(\n                Payload(encode_dataclass(ServerStatisticsRequest(period_seconds=2)),\n                        metadata=composite(\n                            route('statistics')\n                        )),\n                observable=from_observable_with_backpressure(\n                    lambda backpressure: observable_from_queue(control.queue, backpressure))\n            ).pipe(\n                operators.do_action(on_next=lambda value: print_statistics(value.data),\n                                    on_error=lambda exception: print(exception)))\n\n        self._statistics_task = asyncio.create_task(listen_for_statistics())\n\n        return control\n\n    def stop_listening_for_statistics(self):\n        self._statistics_task.cancel()\n\n    async def private_message(self, username: str, content: str):\n        print(f'Sending {content} to user {username}')\n        await self._rsocket.request_response(Payload(encode_dataclass(Message(username, content)),\n                                                     composite(route('message'))))\n\n    async def channel_message(self, channel: str, content: str):\n        print(f'Sending {content} to channel {channel}')\n        await self._rsocket.request_response(Payload(encode_dataclass(Message(channel=channel, content=content)),\n                                                     composite(route('message'))))\n\n    async def upload(self, file_name, content):\n        await self._rsocket.request_response(Payload(content, composite(\n            route('file.upload'),\n            metadata_item(ensure_bytes(file_name), chat_filename_mimetype)\n        )))\n\n    async def download(self, file_name):\n        request = Payload(metadata=composite(\n            route('file.download'),\n            metadata_item(ensure_bytes(file_name), chat_filename_mimetype))\n        )\n\n        return await ReactiveXClient(self._rsocket).request_response(request).pipe(\n            operators.map(lambda _: _.data),\n            operators.last()\n        )\n\n    async def list_files(self) -> List[str]:\n        request = Payload(metadata=composite(route('files')))\n        return await ReactiveXClient(self._rsocket).request_stream(\n            request\n        ).pipe(operators.map(lambda _: utf8_decode(_.data)),\n               operators.to_list())\n\n    async def list_channels(self) -> List[str]:\n        request = Payload(metadata=composite(route('channels')))\n        return await ReactiveXClient(self._rsocket).request_stream(\n            request\n        ).pipe(operators.map(lambda _: utf8_decode(_.data)),\n               operators.to_list())\n\n    async def list_channel_users(self, channel_name: str) -> List[str]:\n        request = Payload(ensure_bytes(channel_name), composite(route('channel.users')))\n        return await ReactiveXClient(self._rsocket).request_stream(\n            request\n        ).pipe(operators.map(lambda _: utf8_decode(_.data)),\n               operators.to_list())\n\n\nasync def main():\n    connection1 = await asyncio.open_connection('localhost', 6565)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection1)),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA,\n                             fragment_size_bytes=1_000_000) as client1:\n        connection2 = await asyncio.open_connection('localhost', 6565)\n\n        async with RSocketClient(single_transport_provider(TransportTCP(*connection2)),\n                                 metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA,\n                                 fragment_size_bytes=1_000_000) as client2:\n            user1 = ChatClient(client1)\n            user2 = ChatClient(client2)\n\n            await user1.login('user1')\n            await user2.login('user2')\n\n            await messaging_example(user1, user2)\n            await statistics_example(user1)\n            await files_example(user1, user2)\n\n\nasync def messaging_example(user1, user2):\n    user1.listen_for_messages()\n    user2.listen_for_messages()\n\n    channel_name = 'channel1'\n    await user1.join(channel_name)\n    await user2.join(channel_name)\n\n    print(f'Channels: {await user1.list_channels()}')\n    print(f'Channel {channel_name} users: {await user1.list_channel_users(channel_name)}')\n\n    await user1.private_message('user2', 'private message from user1')\n    await user1.channel_message(channel_name, 'channel message from user1')\n\n    await asyncio.sleep(1)\n\n    await user1.leave(channel_name)\n    print(f'Channel {channel_name} users: {await user1.list_channel_users(channel_name)}')\n\n    user1.stop_listening_for_messages()\n    user2.stop_listening_for_messages()\n\n\nasync def files_example(user1, user2):\n    file_contents = b'abcdefg1234567'\n    file_name = 'file_name_1.txt'\n\n    await user1.upload(file_name, file_contents)\n\n    print(f'Files: {await user1.list_files()}')\n\n    download_data = await user2.download(file_name)\n\n    if download_data != file_contents:\n        raise Exception('File download failed')\n    else:\n        print(f'Downloaded file: {len(download_data)} bytes')\n\n\nasync def statistics_example(user1):\n    await user1.send_statistics()\n\n    statistics_control = user1.listen_for_statistics()\n\n    await asyncio.sleep(5)\n\n    statistics_control.set_requested_statistics(['users'])\n\n    await asyncio.sleep(5)\n\n    user1.stop_listening_for_statistics()\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(main())\n"}
{"type": "source_file", "path": "examples/tutorial/step0/chat_client.py", "content": "import asyncio\nimport logging\n\nfrom rsocket.helpers import single_transport_provider, utf8_decode\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nasync def main():\n    connection = await asyncio.open_connection('localhost', 6565)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection))) as client:\n        response = await client.request_response(Payload(data=b'George'))\n\n        print(f\"Server response: {utf8_decode(response.data)}\")\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(main())\n"}
{"type": "source_file", "path": "examples/client_with_routing.py", "content": "import asyncio\nimport logging\nimport sys\nfrom asyncio import Event\nfrom typing import AsyncGenerator, Tuple\n\nfrom examples.example_fixtures import large_data1\nfrom examples.shared_tests import assert_result_data\nfrom reactivestreams.publisher import Publisher\nfrom reactivestreams.subscriber import Subscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.extensions.helpers import route, composite, authenticate_simple\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.streams.stream_from_async_generator import StreamFromAsyncGenerator\nfrom rsocket.transports.tcp import TransportTCP\n\n\ndef sample_publisher(wait_for_requester_complete: Event,\n                     response_count: int = 3) -> Publisher:\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        current_response = 0\n        for i in range(response_count):\n            is_complete = (current_response + 1) == response_count\n\n            message = 'Item to server from client on channel: %s' % current_response\n            yield Payload(message.encode('utf-8')), is_complete\n\n            if is_complete:\n                wait_for_requester_complete.set()\n                break\n\n            current_response += 1\n\n    return StreamFromAsyncGenerator(generator)\n\n\nclass ChannelSubscriber(Subscriber):\n\n    def __init__(self, wait_for_responder_complete: Event) -> None:\n        super().__init__()\n        self._wait_for_responder_complete = wait_for_responder_complete\n        self.values = []\n\n    def on_subscribe(self, subscription: Subscription):\n        self.subscription = subscription\n\n    def on_next(self, value: Payload, is_complete=False):\n        logging.info('From server on channel: ' + value.data.decode('utf-8'))\n        self.values.append(value.data)\n        if is_complete:\n            self._wait_for_responder_complete.set()\n\n    def on_error(self, exception: Exception):\n        logging.error('Error from server on channel' + str(exception))\n        self._wait_for_responder_complete.set()\n\n    def on_complete(self):\n        logging.info('Completed from server on channel')\n        self._wait_for_responder_complete.set()\n\n\nclass StreamSubscriber(Subscriber):\n\n    def __init__(self,\n                 wait_for_complete: Event,\n                 request_n_size=0):\n        self._request_n_size = request_n_size\n        self.error = None\n        self._wait_for_complete = wait_for_complete\n\n    def on_next(self, value, is_complete=False):\n        logging.info('RS: {}'.format(value))\n        if is_complete:\n            self._wait_for_complete.set()\n        else:\n            if self._request_n_size > 0:\n                self.subscription.request(self._request_n_size)\n\n    def on_complete(self):\n        logging.info('RS: Complete')\n        self._wait_for_complete.set()\n\n    def on_error(self, exception):\n        logging.info('RS: error: {}'.format(exception))\n        self.error = exception\n        self._wait_for_complete.set()\n\n    def on_subscribe(self, subscription):\n        # noinspection PyAttributeOutsideInit\n        self.subscription = subscription\n\n\nasync def request_response(client: RSocketClient):\n    payload = Payload(b'The quick brown fox', composite(\n        route('single_request'),\n        authenticate_simple('user', '12345')\n    ))\n\n    result = await client.request_response(payload)\n\n    assert_result_data(result, b'single_response')\n\n\nasync def request_large_response(client: RSocketClient):\n    payload = Payload(b'The quick brown fox', composite(\n        route('large_data'),\n        authenticate_simple('user', '12345')\n    ))\n\n    result = await client.request_response(payload)\n\n    assert_result_data(result, large_data1)\n\n\nasync def request_large_request(client: RSocketClient):\n    payload = Payload(large_data1, composite(\n        route('large_request'),\n        authenticate_simple('user', '12345')\n    ))\n\n    result = await client.request_response(payload)\n\n    assert_result_data(result, large_data1)\n\n\nasync def request_channel(client: RSocketClient):\n    channel_completion_event = Event()\n    requester_completion_event = Event()\n    payload = Payload(b'The quick brown fox', composite(\n        route('channel'),\n        authenticate_simple('user', '12345')\n    ))\n    publisher = sample_publisher(requester_completion_event)\n\n    requested = client.request_channel(payload, publisher)\n\n    subscriber = ChannelSubscriber(channel_completion_event)\n    requested.initial_request_n(5).subscribe(subscriber)\n\n    await channel_completion_event.wait()\n    await requester_completion_event.wait()\n\n    if subscriber.values != [\n        b'Item on channel: 0',\n        b'Item on channel: 1',\n        b'Item on channel: 2',\n    ]:\n        raise Exception()\n\n\nasync def request_stream_invalid_login(client: RSocketClient):\n    payload = Payload(b'The quick brown fox', composite(\n        route('stream'),\n        authenticate_simple('user', 'wrong_password')\n    ))\n\n    completion_event = Event()\n    client.request_stream(payload).subscribe(StreamSubscriber(completion_event))\n\n    await completion_event.wait()\n\n\nasync def request_stream(client: RSocketClient):\n    payload = Payload(b'The quick brown fox', composite(\n        route('stream'),\n        authenticate_simple('user', '12345')\n    ))\n    completion_event = Event()\n    client.request_stream(payload).subscribe(StreamSubscriber(completion_event))\n    await completion_event.wait()\n\n\nasync def request_slow_stream(client: RSocketClient):\n    payload = Payload(b'The quick brown fox', composite(\n        route('slow_stream'),\n        authenticate_simple('user', '12345')\n    ))\n    completion_event = Event()\n    client.request_stream(payload).subscribe(StreamSubscriber(completion_event))\n    await completion_event.wait()\n\n\nasync def main(server_port):\n    logging.info('Connecting to server at localhost:%s', server_port)\n\n    connection = await asyncio.open_connection('localhost', server_port)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection)),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA,\n                             fragment_size_bytes=64) as client:\n        await request_large_response(client)\n        await request_large_request(client)\n        await request_response(client)\n        await request_stream(client)\n        await request_slow_stream(client)\n        await request_channel(client)\n        # await request_stream_invalid_login(client)\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(port))\n"}
{"type": "source_file", "path": "examples/tutorial/step1/chat_server.py", "content": "import asyncio\nimport logging\nfrom typing import Awaitable\n\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import utf8_decode, create_response\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\n\ndef handler_factory():\n    router = RequestRouter()\n\n    @router.response('login')\n    async def login(payload: Payload) -> Awaitable[Payload]:\n        username = utf8_decode(payload.data)\n\n        logging.info(f'New user: {username}')\n\n        return create_response(ensure_bytes(f'Hello {username}'))\n\n    return RoutingRequestHandler(router)\n\n\nasync def run_server():\n    def session(*connection):\n        RSocketServer(TransportTCP(*connection), handler_factory=handler_factory)\n\n    async with await asyncio.start_server(session, 'localhost', 6565) as server:\n        await server.serve_forever()\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(run_server())\n"}
{"type": "source_file", "path": "examples/cloudevents/server_cloudevents.py", "content": "import asyncio\nimport json\nimport logging\nimport sys\n\nfrom cloudevents.pydantic import CloudEvent\n\nfrom rsocket.cloudevents.serialize import cloud_event_deserialize, cloud_event_serialize\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\nrouter = RequestRouter(cloud_event_deserialize,\n                       cloud_event_serialize)\n\n\n@router.response('event')\nasync def event_response(event: CloudEvent) -> CloudEvent:\n    return CloudEvent.create(attributes={\n        'type': 'io.spring.event.Foo',\n        'source': 'https://spring.io/foos'\n    }, data=json.dumps(json.loads(event.data)))\n\n\ndef handler_factory():\n    return RoutingRequestHandler(router)\n\n\nasync def run_server(server_port):\n    logging.info('Starting server at localhost:%s', server_port)\n\n    def session(*connection):\n        RSocketServer(TransportTCP(*connection), handler_factory=handler_factory)\n\n    async with await asyncio.start_server(session, 'localhost', server_port) as server:\n        await server.serve_forever()\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 7000\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(run_server(port))\n"}
{"type": "source_file", "path": "examples/rsocket_in_aiohttp.py", "content": "import asyncio\nfrom datetime import datetime\n\nfrom aiohttp import web\n\nfrom rsocket.helpers import create_future\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass Handler(BaseRequestHandler):\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        await asyncio.sleep(0.1)  # Simulate not immediate process\n        date_time_format = payload.data.decode('utf-8')\n        formatted_date_time = datetime.now().strftime(date_time_format)\n        return create_future(Payload(formatted_date_time.encode('utf-8')))\n\n\nasync def run_server(server_port):\n    def session(*connection):\n        RSocketServer(TransportTCP(*connection), handler_factory=Handler)\n\n    print('Listening for rsocket on {}'.format(server_port))\n    server = await asyncio.start_server(session, 'localhost', server_port)\n\n    async with server:\n        await server.serve_forever()\n\n\nasync def start_background_tasks(app):\n    app['rsocket'] = asyncio.create_task(run_server(6565))\n\n\nasync def cleanup_background_tasks(app):\n    app['rsocket'].cancel()\n    await app['rsocket']\n\n\napp = web.Application()\napp.on_startup.append(start_background_tasks)\napp.on_cleanup.append(cleanup_background_tasks)\nweb.run_app(app)\n"}
{"type": "source_file", "path": "examples/server_fastapi_websocket.py", "content": "import uvicorn\nfrom fastapi import FastAPI, WebSocket\n\nfrom rsocket.helpers import create_future\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.http3_transport import Http3TransportWebsocket\n\napp = FastAPI()\n\n\nclass Handler(BaseRequestHandler):\n\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        return create_future(Payload(b'pong'))\n\n\n@app.websocket(\"/\")\nasync def endpoint(websocket: WebSocket):\n    await websocket.accept()\n    transport = Http3TransportWebsocket(websocket)\n    RSocketServer(transport=transport, handler_factory=Handler)\n    await transport.wait_for_disconnect()\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=6565)"}
{"type": "source_file", "path": "examples/tutorial/reactivex/chat_server.py", "content": "import asyncio\nimport logging\nimport uuid\nfrom asyncio import Queue\nfrom collections import defaultdict\nfrom dataclasses import dataclass, field\nfrom typing import Dict, Optional, Set, Callable\nfrom weakref import WeakValueDictionary, WeakSet\n\nimport reactivex\nfrom reactivex import Observable, operators, Subject, Observer\n\nfrom examples.tutorial.reactivex.shared import (Message, chat_filename_mimetype, ClientStatistics,\n                                                ServerStatisticsRequest, ServerStatistics, dataclass_to_payload,\n                                                decode_dataclass, decode_payload)\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.extensions.helpers import composite, metadata_item\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import utf8_decode\nfrom rsocket.payload import Payload\nfrom rsocket.reactivex.back_pressure_publisher import (from_observable_with_backpressure, observable_from_queue,\n                                                       observable_from_async_generator)\nfrom rsocket.reactivex.reactivex_channel import ReactivexChannel\nfrom rsocket.reactivex.reactivex_handler_adapter import reactivex_handler_factory\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass SessionId(str):  # allow weak reference\n    pass\n\n\n@dataclass()\nclass UserSessionData:\n    username: str\n    session_id: SessionId\n    messages: Queue = field(default_factory=Queue)\n    statistics: Optional[ClientStatistics] = None\n    requested_statistics: ServerStatisticsRequest = field(default_factory=ServerStatisticsRequest)\n\n\n@dataclass(frozen=True)\nclass ChatData:\n    channel_users: Dict[str, Set[SessionId]] = field(default_factory=lambda: defaultdict(WeakSet))\n    files: Dict[str, bytes] = field(default_factory=dict)\n    channel_messages: Dict[str, Queue] = field(default_factory=lambda: defaultdict(Queue))\n    user_session_by_id: Dict[str, UserSessionData] = field(default_factory=WeakValueDictionary)\n\n\nchat_data = ChatData()\n\n\ndef ensure_channel_exists(channel_name):\n    if channel_name not in chat_data.channel_users:\n        chat_data.channel_users[channel_name] = WeakSet()\n        chat_data.channel_messages[channel_name] = Queue()\n        asyncio.create_task(channel_message_delivery(channel_name))\n\n\nasync def channel_message_delivery(channel_name: str):\n    logging.info('Starting channel delivery %s', channel_name)\n    while True:\n        try:\n            message = await chat_data.channel_messages[channel_name].get()\n            for session_id in chat_data.channel_users[channel_name]:\n                user_specific_message = Message(user=message.user,\n                                                content=message.content,\n                                                channel=channel_name)\n                chat_data.user_session_by_id[session_id].messages.put_nowait(user_specific_message)\n        except Exception as exception:\n            logging.error(str(exception), exc_info=True)\n\n\ndef get_file_name(composite_metadata):\n    return utf8_decode(composite_metadata.find_by_mimetype(chat_filename_mimetype)[0].content)\n\n\ndef find_session_by_username(username: str) -> Optional[UserSessionData]:\n    try:\n        return next(session for session in chat_data.user_session_by_id.values() if\n                    session.username == username)\n    except StopIteration:\n        return None\n\n\ndef new_statistics_data(requested_statistics: ServerStatisticsRequest):\n    statistics_data = {}\n\n    if 'users' in requested_statistics.ids:\n        statistics_data['user_count'] = len(chat_data.user_session_by_id)\n\n    if 'channels' in requested_statistics.ids:\n        statistics_data['channel_count'] = len(chat_data.channel_messages)\n\n    return ServerStatistics(**statistics_data)\n\n\ndef find_username_by_session(session_id: SessionId) -> Optional[str]:\n    session = chat_data.user_session_by_id.get(session_id)\n    if session is None:\n        return None\n    return session.username\n\n\nclass ChatUserSession:\n\n    def __init__(self):\n        self._session: Optional[UserSessionData] = None\n\n    def remove(self):\n        if self._session is not None:\n            print(f'Removing session: {self._session.session_id}')\n            del chat_data.user_session_by_id[self._session.session_id]\n\n    def router_factory(self):\n        router = RequestRouter(payload_deserializer=decode_payload)\n\n        @router.response('login')\n        async def login(username: str) -> Observable:\n            logging.info(f'New user: {username}')\n            session_id = SessionId(uuid.uuid4())\n            self._session = UserSessionData(username, session_id)\n            chat_data.user_session_by_id[session_id] = self._session\n\n            return reactivex.just(Payload(ensure_bytes(session_id)))\n\n        @router.response('channel.join')\n        async def join_channel(channel_name: str) -> Observable:\n            ensure_channel_exists(channel_name)\n            chat_data.channel_users[channel_name].add(self._session.session_id)\n            return reactivex.empty()\n\n        @router.response('channel.leave')\n        async def leave_channel(channel_name: str) -> Observable:\n            chat_data.channel_users[channel_name].discard(self._session.session_id)\n            return reactivex.empty()\n\n        @router.response('file.upload')\n        async def upload_file(payload: Payload, composite_metadata: CompositeMetadata) -> Observable:\n            chat_data.files[get_file_name(composite_metadata)] = payload.data\n            return reactivex.empty()\n\n        @router.response('file.download')\n        async def download_file(composite_metadata: CompositeMetadata) -> Observable:\n            file_name = get_file_name(composite_metadata)\n            return reactivex.just(Payload(chat_data.files[file_name],\n                                          composite(metadata_item(ensure_bytes(file_name), chat_filename_mimetype))))\n\n        @router.stream('files')\n        async def get_file_names() -> Callable[[Subject], Observable]:\n            async def generator():\n                for file_name in chat_data.files.keys():\n                    yield file_name\n\n            return from_observable_with_backpressure(\n                lambda backpressure: observable_from_async_generator(generator(), backpressure).pipe(\n                    operators.map(lambda file_name: Payload(ensure_bytes(file_name)))\n                ))\n\n        @router.stream('channels')\n        async def get_channels() -> Observable:\n            return reactivex.from_iterable(\n                (Payload(ensure_bytes(channel)) for channel in chat_data.channel_messages.keys()))\n\n        @router.stream('channel.users')\n        async def get_channel_users(channel_name: str) -> Observable:\n            if channel_name not in chat_data.channel_users:\n                return reactivex.empty()\n\n            return reactivex.from_iterable(Payload(ensure_bytes(find_username_by_session(session_id))) for\n                                           session_id in\n                                           chat_data.channel_users[channel_name])\n\n        @router.fire_and_forget('statistics')\n        async def receive_statistics(statistics: ClientStatistics):\n            logging.info('Received client statistics. memory usage: %s', statistics.memory_usage)\n\n            self._session.statistics = statistics\n\n        @router.channel('statistics')\n        async def send_statistics(initial_payload: Payload) -> ReactivexChannel:\n\n            async def statistics_generator():\n                while True:\n                    try:\n                        await asyncio.sleep(self._session.requested_statistics.period_seconds)\n                        yield new_statistics_data(self._session.requested_statistics)\n                    except Exception:\n                        logging.error('Statistics', exc_info=True)\n\n            def on_next(payload: Payload):\n                request = decode_dataclass(payload.data, ServerStatisticsRequest)\n\n                logging.info(f'Received statistics request {request.ids}, {request.period_seconds}')\n\n                if request.ids is not None:\n                    self._session.requested_statistics.ids = request.ids\n\n                if request.period_seconds is not None:\n                    self._session.requested_statistics.period_seconds = request.period_seconds\n\n            on_next(initial_payload)\n\n            return ReactivexChannel(\n                from_observable_with_backpressure(\n                    lambda backpressure: observable_from_async_generator(\n                        statistics_generator(), backpressure\n                    ).pipe(\n                        operators.map(dataclass_to_payload)\n                    )),\n                Observer(on_next=on_next),\n                limit_rate=2)\n\n        @router.response('message')\n        async def send_message(message: Message) -> Observable:\n            logging.info('Received message for user: %s, channel: %s', message.user, message.channel)\n\n            target_message = Message(self._session.username, message.content, message.channel)\n\n            if message.channel is not None:\n                await chat_data.channel_messages[message.channel].put(target_message)\n            elif message.user is not None:\n                session = find_session_by_username(message.user)\n                await session.messages.put(target_message)\n\n            return reactivex.empty()\n\n        @router.stream('messages.incoming')\n        async def messages_incoming() -> Callable[[Subject], Observable]:\n            return from_observable_with_backpressure(\n                lambda backpressure: observable_from_queue(\n                    self._session.messages, backpressure\n                ).pipe(\n                    operators.map(dataclass_to_payload)\n                )\n            )\n\n        return router\n\n\nclass CustomRoutingRequestHandler(RoutingRequestHandler):\n    def __init__(self, session: ChatUserSession):\n        super().__init__(session.router_factory())\n        self._session = session\n\n    async def on_close(self, rsocket, exception: Optional[Exception] = None):\n        self._session.remove()\n        return await super().on_close(rsocket, exception)\n\n\ndef handler_factory():\n    return CustomRoutingRequestHandler(ChatUserSession())\n\n\nasync def run_server():\n    def session(*connection):\n        RSocketServer(TransportTCP(*connection),\n                      handler_factory=reactivex_handler_factory(handler_factory),\n                      fragment_size_bytes=1_000_000)\n\n    async with await asyncio.start_server(session, 'localhost', 6565) as server:\n        await server.serve_forever()\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(run_server())\n"}
{"type": "source_file", "path": "examples/server_with_fragmenting.py", "content": "import asyncio\nimport logging\nimport sys\nfrom dataclasses import dataclass\nfrom datetime import timedelta\nfrom typing import Optional\n\nfrom examples.example_fixtures import large_data1\nfrom examples.response_channel import sample_async_response_stream, LoggingSubscriber\nfrom response_stream import sample_sync_response_stream\nfrom rsocket.extensions.authentication import Authentication, AuthenticationSimple\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.helpers import create_future\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\nrouter = RequestRouter()\n\n\n@dataclass\nclass Storage:\n    last_metadata_push: Optional[bytes] = None\n    last_fire_and_forget: Optional[bytes] = None\n\n\nstorage = Storage()\n\n\n@router.response('single_request')\nasync def single_request_response(payload, composite_metadata):\n    logging.info('Got single request')\n    return create_future(Payload(b'single_response'))\n\n\n@router.response('last_fnf')\nasync def get_last_fnf():\n    logging.info('Got single request')\n    return create_future(Payload(storage.last_fire_and_forget))\n\n\n@router.response('last_metadata_push')\nasync def get_last_metadata_push():\n    logging.info('Got single request')\n    return create_future(Payload(storage.last_metadata_push))\n\n\n@router.response('large_data')\nasync def get_large_data():\n    return create_future(Payload(large_data1))\n\n\n@router.response('large_request')\nasync def get_large_data_request(payload: Payload):\n    return create_future(Payload(payload.data))\n\n\n@router.stream('stream')\nasync def stream_response(payload, composite_metadata):\n    logging.info('Got stream request')\n    return sample_async_response_stream()\n\n\n@router.fire_and_forget('no_response')\nasync def no_response(payload: Payload, composite_metadata):\n    storage.last_fire_and_forget = payload.data\n    logging.info('No response sent to client')\n\n\n@router.metadata_push('metadata_push')\nasync def metadata_push(payload: Payload, composite_metadata: CompositeMetadata):\n    for item in composite_metadata.items:\n        if item.encoding == b'text/plain':\n            storage.last_metadata_push = item.content\n\n\n@router.channel('channel')\nasync def channel_response(payload, composite_metadata):\n    logging.info('Got channel request')\n    subscriber = LoggingSubscriber()\n    channel = sample_async_response_stream(local_subscriber=subscriber)\n    return channel, subscriber\n\n\n@router.stream('slow_stream')\nasync def stream_slow(**kwargs):\n    logging.info('Got slow stream request')\n    return sample_sync_response_stream(delay_between_messages=timedelta(seconds=2))\n\n\nasync def authenticator(route: str, authentication: Authentication):\n    if isinstance(authentication, AuthenticationSimple):\n        if authentication.password != b'12345':\n            raise Exception('Authentication error')\n    else:\n        raise Exception('Unsupported authentication')\n\n\ndef handler_factory():\n    return RoutingRequestHandler(router, authenticator)\n\n\ndef handle_client(reader, writer):\n    RSocketServer(TransportTCP(reader, writer),\n                  handler_factory=handler_factory,\n                  fragment_size_bytes=64)\n\n\nasync def run_server(server_port):\n    logging.info('Starting server at localhost:%s', server_port)\n\n    server = await asyncio.start_server(handle_client, 'localhost', server_port)\n\n    async with server:\n        await server.serve_forever()\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(run_server(port))\n"}
{"type": "source_file", "path": "examples/run_against_example_java_server.py", "content": "import asyncio\nimport json\nimport logging\nimport sys\nfrom asyncio import Event\nfrom typing import Optional\n\nfrom reactivestreams.subscriber import DefaultSubscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.extensions.routing import RoutingMetadata\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nasync def main(server_port):\n    completion_event = Event()\n\n    class Subscriber(DefaultSubscriber):\n        def __init__(self):\n            super().__init__()\n            self.values = []\n            self.subscription: Optional[Subscription] = None\n\n        def on_next(self, value, is_complete=False):\n            self.values.append(value)\n\n        def on_complete(self):\n            completion_event.set()\n\n        def on_error(self, exception: Exception):\n            logging.error('Error', exc_info=exception)\n            completion_event.set()\n\n    connection = await asyncio.open_connection('localhost', server_port)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection)),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA.value.name,\n                             data_encoding=WellKnownMimeTypes.APPLICATION_JSON.value.name) as client:\n        metadata = CompositeMetadata()\n        metadata.append(RoutingMetadata(['investigation.getInvestigationByContext']))\n\n        body = json.dumps({'active': True}).encode()\n\n        request = Payload(body, metadata.serialize())\n\n        subscriber = Subscriber()\n        client.request_stream(request).subscribe(subscriber)\n        await completion_event.wait()\n\n        await asyncio.sleep(4)  # Used to show keepalive is working\n\n        assert len(subscriber.values) == 11\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(port))\n"}
{"type": "source_file", "path": "examples/server_with_lease.py", "content": "import asyncio\nimport logging\nimport sys\nfrom datetime import timedelta\n\nfrom rsocket.helpers import create_future\nfrom rsocket.lease import SingleLeasePublisher\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\nrouter = RequestRouter()\n\n\n@router.response('single_request')\nasync def single_request_response(payload, composite_metadata):\n    logging.info('Got single request')\n    return create_future(Payload(b'single_response'))\n\n\ndef handler_factory():\n    return RoutingRequestHandler(router)\n\n\ndef handle_client(reader, writer):\n    RSocketServer(TransportTCP(reader, writer), handler_factory=handler_factory, lease_publisher=SingleLeasePublisher(\n        maximum_request_count=5,\n        maximum_lease_time=timedelta(seconds=2)\n    ))\n\n\nasync def run_server(server_port):\n    server = await asyncio.start_server(handle_client, 'localhost', server_port)\n\n    async with server:\n        await server.serve_forever()\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(run_server(port))\n"}
{"type": "source_file", "path": "examples/response_stream.py", "content": "import itertools\nimport logging\nfrom datetime import timedelta\n\nfrom rsocket.payload import Payload\nfrom rsocket.streams.stream_from_generator import StreamFromGenerator\n\n\ndef sample_sync_response_stream(response_count: int = 3,\n                                delay_between_messages=timedelta(0),\n                                is_infinite_stream: bool = False):\n    def generator():\n        try:\n            current_response = 0\n\n            def range_counter():\n                return range(response_count)\n\n            if not is_infinite_stream:\n                counter = range_counter\n            else:\n                counter = itertools.count\n\n            for i in counter():\n                if is_infinite_stream:\n                    is_complete = False\n                else:\n                    is_complete = (current_response + 1) == response_count\n\n                if delay_between_messages.total_seconds() > 0:\n                    message = 'Slow Item'\n                else:\n                    message = 'Item'\n\n                message = '%s: %s' % (message, current_response)\n                yield Payload(message.encode('utf-8'), b'metadata'), is_complete\n\n                if is_complete:\n                    break\n\n                current_response += 1\n        finally:\n            logging.info('Closing sync stream generator')\n\n    return StreamFromGenerator(generator, delay_between_messages)\n"}
{"type": "source_file", "path": "examples/tutorial/step1/chat_client.py", "content": "import asyncio\nimport logging\nfrom typing import Optional\n\nfrom rsocket.extensions.helpers import composite, route\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import single_transport_provider, utf8_decode\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass ChatClient:\n    def __init__(self, rsocket: RSocketClient):\n        self._rsocket = rsocket\n        self._username: Optional[str] = None\n\n    async def login(self, username: str):\n        self._username = username\n        payload = Payload(ensure_bytes(username), composite(route('login')))\n        response = await self._rsocket.request_response(payload)\n        print(f'Server response: {utf8_decode(response.data)}')\n\n\nasync def main():\n    connection = await asyncio.open_connection('localhost', 6565)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection)),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA) as client1:\n        user = ChatClient(client1)\n\n        await user.login('user1')\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(main())\n"}
{"type": "source_file", "path": "examples/server_quic.py", "content": "import asyncio\nimport logging\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom aioquic.quic.configuration import QuicConfiguration\n\nfrom rsocket.helpers import create_future\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.transports.aioquic_transport import rsocket_serve\n\n\nclass Handler(BaseRequestHandler):\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        await asyncio.sleep(0.1)  # Simulate not immediate process\n        date_time_format = payload.data.decode('utf-8')\n        formatted_date_time = datetime.now().strftime(date_time_format)\n        return create_future(Payload(formatted_date_time.encode('utf-8')))\n\n\ndef run_server(server_port):\n    logging.info('Starting server at localhost:%s', server_port)\n\n    configuration = QuicConfiguration(\n        is_client=False\n    )\n\n    certificates_path = Path(__file__).parent / 'certificates'\n    configuration.load_cert_chain(certificates_path / 'ssl_cert.pem', certificates_path / 'ssl_key.pem')\n\n    return rsocket_serve(host='localhost',\n                         port=server_port,\n                         configuration=configuration,\n                         handler_factory=Handler)\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(run_server(port))\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        pass\n"}
{"type": "source_file", "path": "examples/tutorial/step1/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/server.py", "content": "import asyncio\nimport logging\nimport sys\nfrom datetime import datetime\n\nfrom rsocket.helpers import create_future\nfrom rsocket.local_typing import Awaitable\nfrom rsocket.payload import Payload\nfrom rsocket.request_handler import BaseRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass Handler(BaseRequestHandler):\n    async def request_response(self, payload: Payload) -> Awaitable[Payload]:\n        await asyncio.sleep(0.1)  # Simulate not immediate process\n        date_time_format = payload.data.decode('utf-8')\n        formatted_date_time = datetime.now().strftime(date_time_format)\n        return create_future(Payload(formatted_date_time.encode('utf-8')))\n\n\nasync def run_server(server_port):\n    logging.info('Starting server at localhost:%s', server_port)\n\n    def session(*connection):\n        RSocketServer(TransportTCP(*connection), handler_factory=Handler)\n\n    server = await asyncio.start_server(session, 'localhost', server_port)\n\n    async with server:\n        await server.serve_forever()\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 6565\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(run_server(port))\n"}
{"type": "source_file", "path": "examples/example_fixtures.py", "content": "from rsocket.frame_helpers import ensure_bytes\n\nlarge_data1 = b''.join(ensure_bytes(str(i)) + b'123456789' for i in range(50))\n"}
{"type": "source_file", "path": "examples/tutorial/reactivex/shared.py", "content": "import json\nfrom dataclasses import dataclass, field\nfrom typing import Optional, List, Type, TypeVar\n\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import utf8_decode\nfrom rsocket.payload import Payload\n\n\n@dataclass(frozen=True)\nclass Message:\n    user: Optional[str] = None\n    content: Optional[str] = None\n    channel: Optional[str] = None\n\n\n@dataclass(frozen=True)\nclass ServerStatistics:\n    user_count: Optional[int] = None\n    channel_count: Optional[int] = None\n\n\n@dataclass()\nclass ServerStatisticsRequest:\n    ids: Optional[List[str]] = field(default_factory=lambda: ['users', 'channels'])\n    period_seconds: Optional[int] = field(default_factory=lambda: 2)\n\n\n@dataclass(frozen=True)\nclass ClientStatistics:\n    memory_usage: Optional[float] = None\n\n\nchat_filename_mimetype = b'chat/file-name'\n\n\ndef encode_dataclass(obj) -> bytes:\n    return ensure_bytes(json.dumps(obj.__dict__))\n\n\ndef dataclass_to_payload(obj) -> Payload:\n    return Payload(encode_dataclass(obj))\n\n\nT = TypeVar('T')\n\n\ndef decode_dataclass(data: bytes, cls: Type[T]) -> T:\n    return cls(**json.loads(utf8_decode(data)))\n\n\ndef decode_payload(cls, payload: Payload):\n    data = payload.data\n\n    if cls is bytes:\n        return data\n    if cls is str:\n        return utf8_decode(data)\n\n    return decode_dataclass(data, cls)\n"}
{"type": "source_file", "path": "examples/cloudevents/client_cloudevents.py", "content": "import asyncio\nimport json\nimport logging\nimport sys\n\nfrom cloudevents.conversion import to_json, from_json\nfrom cloudevents.pydantic import CloudEvent\n\nfrom rsocket.extensions.helpers import composite, route\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nasync def main(server_port: int):\n    connection = await asyncio.open_connection('localhost', server_port)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection)),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA,\n                             data_encoding=b'application/cloudevents+json') as client:\n        event = CloudEvent.create(attributes={\n            'type': 'io.spring.event.Foo',\n            'source': 'https://spring.io/foos'\n        }, data=json.dumps({'value': 'Dave'}))\n\n        response = await client.request_response(Payload(data=to_json(event), metadata=composite(route('event'))))\n\n        response_event = from_json(CloudEvent, response.data)\n        response_data = json.loads(response_event.data)\n\n        assert response_data['value'] == 'Dave'\n\n        print(response_data['value'])\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 7000\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(port))\n"}
{"type": "source_file", "path": "examples/tutorial/step2/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/tutorial/step2/chat_client.py", "content": "import asyncio\nimport logging\nfrom typing import Optional\n\nfrom rsocket.extensions.helpers import composite, route\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nclass ChatClient:\n    def __init__(self, rsocket: RSocketClient):\n        self._rsocket = rsocket\n        self._session_id: Optional[str] = None\n        self._username: Optional[str] = None\n\n    async def login(self, username: str):\n        self._username = username\n        payload = Payload(ensure_bytes(username), composite(route('login')))\n        self._session_id = (await self._rsocket.request_response(payload)).data\n        return self\n\n\nasync def main():\n    connection = await asyncio.open_connection('localhost', 6565)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection)),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA) as client1:\n        user = ChatClient(client1)\n\n        await user.login('George')\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(main())\n"}
{"type": "source_file", "path": "examples/graphql/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/graphql/server_graphql.py", "content": "import asyncio\nimport logging\nimport sys\nfrom pathlib import Path\nfrom typing import Dict\n\nfrom graphql import build_schema\n\nfrom rsocket.graphql.server_helper import graphql_handler\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\nstored_message = \"\"\n\n\nasync def greeting(*args) -> Dict:\n    return {\n        'message': \"Hello world\"\n    }\n\n\nasync def get_message(*args) -> str:\n    global stored_message\n    return stored_message\n\n\nasync def set_message(root, _info, message) -> Dict:\n    global stored_message\n    stored_message = message\n    return {\n        \"message\": message\n    }\n\n\ndef greetings(*args):\n    async def results():\n        for i in range(10):\n            yield {'greetings': {'message': f\"Hello world {i}\"}}\n            await asyncio.sleep(1)\n\n    return results()\n\n\nwith (Path(__file__).parent / 'rsocket.graphqls').open() as fd:\n    schema = build_schema(fd.read())\n\nschema.query_type.fields['greeting'].resolve = greeting\nschema.query_type.fields['getMessage'].resolve = get_message\nschema.mutation_type.fields['setMessage'].resolve = set_message\nschema.subscription_type.fields['greetings'].subscribe = greetings\n\n\ndef handler_factory():\n    return RoutingRequestHandler(graphql_handler(schema, 'graphql'))\n\n\nasync def run_server(server_port):\n    logging.info('Starting server at localhost:%s', server_port)\n\n    def session(*connection):\n        RSocketServer(TransportTCP(*connection), handler_factory=handler_factory)\n\n    server = await asyncio.start_server(session, 'localhost', server_port)\n\n    async with server:\n        await server.serve_forever()\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 9191\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(run_server(port))\n"}
{"type": "source_file", "path": "examples/issue_290/client.py", "content": "import asyncio\nimport logging\nimport sys\nfrom asyncio import Event\nfrom typing import AsyncGenerator, Tuple\n\nimport aiohttp\nfrom rsocket.transports.asyncwebsockets_transport import websocket_client\n\nfrom rsocket.transports.aiohttp_websocket import TransportAioHttpClient\n\nfrom reactivestreams.publisher import Publisher\nfrom reactivestreams.subscriber import Subscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.extensions.helpers import route, composite, authenticate_simple\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.payload import Payload\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.streams.stream_from_async_generator import StreamFromAsyncGenerator\nfrom rsocket.transports.tcp import TransportTCP\n\n\ndef sample_publisher(wait_for_requester_complete: Event,\n                     response_count: int = 1000) -> Publisher:\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        current_response = 0\n        for i in range(response_count):\n            is_complete = (current_response + 1) == response_count\n\n            message = 'Item to server from client on channel: %s' % current_response\n            yield Payload(message.encode('utf-8')), is_complete\n\n            if is_complete:\n                wait_for_requester_complete.set()\n                break\n\n            current_response += 1\n\n    return StreamFromAsyncGenerator(generator)\n\n\nclass ChannelSubscriber(Subscriber):\n\n    def __init__(self, wait_for_responder_complete: Event) -> None:\n        super().__init__()\n        self._wait_for_responder_complete = wait_for_responder_complete\n        self.values = []\n\n    def on_subscribe(self, subscription: Subscription):\n        self.subscription = subscription\n\n    def on_next(self, value: Payload, is_complete=False):\n        logging.info('From server on channel: ' + value.data.decode('utf-8'))\n        self.values.append(value.data)\n        if is_complete:\n            self._wait_for_responder_complete.set()\n\n    def on_error(self, exception: Exception):\n        logging.error('Error from server on channel' + str(exception))\n        self._wait_for_responder_complete.set()\n\n    def on_complete(self):\n        logging.info('Completed from server on channel')\n        self._wait_for_responder_complete.set()\n\nasync def request_channel(client: RSocketClient):\n\n    channel_completion_event = Event()\n    requester_completion_event = Event()\n    payload = Payload(b'The first item in the stream', composite(\n        route('channel'),\n        authenticate_simple('user', '12345')\n    ))\n    publisher = sample_publisher(requester_completion_event)\n\n    requested = client.request_channel(payload, publisher)\n\n    subscriber = ChannelSubscriber(channel_completion_event)\n    requested.initial_request_n(5).subscribe(subscriber)\n\n    await channel_completion_event.wait()\n    await requester_completion_event.wait()\n\n\nasync def application(serve_port: int):\n        async with websocket_client('http://localhost:%s/rsocket' % serve_port,\n                                    metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA,) as client:\n            await request_channel(client)\n\n\nasync def command():\n    logging.basicConfig(level=logging.DEBUG)\n    await application(7878)\n\n\nif __name__ == '__main__':\n    asyncio.run(command())"}
{"type": "source_file", "path": "examples/fixtures.py", "content": "import tempfile\nfrom contextlib import contextmanager\nfrom datetime import timedelta\nfrom typing import Tuple\n\nfrom OpenSSL import crypto\n\n\n@contextmanager\ndef generate_certificate_and_key(email_address=\"emailAddress\",\n                                 common_name=\"localhost\",\n                                 country_name=\"NT\",\n                                 locality_name=\"localityName\",\n                                 state_or_province_name=\"stateOrProvinceName\",\n                                 organization_name=\"organizationName\",\n                                 organization_unit_name=\"organizationUnitName\",\n                                 serial_number=0,\n                                 validity_start_in_seconds=0,\n                                 validity_end_in_seconds=None) -> Tuple[str, str]:\n    if validity_end_in_seconds is None:\n        validity_end_in_seconds = int(timedelta(days=3650).total_seconds())\n\n    # can look at generated file using openssl:\n    # openssl x509 -inform pem -in selfsigned.crt -noout -text\n    # create a key pair\n    private_key = create_key()\n\n    # create a self-signed cert\n    cert = create_self_signed_certificate(common_name, country_name, email_address, private_key, locality_name,\n                                          organization_name,\n                                          organization_unit_name, serial_number, state_or_province_name,\n                                          validity_end_in_seconds, validity_start_in_seconds)\n\n    with tempfile.NamedTemporaryFile() as certificate_file:\n        with tempfile.NamedTemporaryFile() as key_file:\n            certificate_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))\n            certificate_file.flush()\n\n            key_file.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, private_key))\n            key_file.flush()\n\n            yield certificate_file.name, key_file.name\n\n\ndef create_key():\n    k = crypto.PKey()\n    k.generate_key(crypto.TYPE_RSA, 4096)\n    return k\n\n\ndef create_self_signed_certificate(common_name, country_name, email_address, private_key, locality_name,\n                                   organization_name,\n                                   organization_unit_name, serial_number, state_or_province_name,\n                                   validity_end_in_seconds, validity_start_in_seconds):\n    cert = crypto.X509()\n    cert.get_subject().C = country_name\n    cert.get_subject().ST = state_or_province_name\n    cert.get_subject().L = locality_name\n    cert.get_subject().O = organization_name  # noqa: E741\n    cert.get_subject().OU = organization_unit_name\n    cert.get_subject().CN = common_name\n    cert.get_subject().emailAddress = email_address\n    cert.set_serial_number(serial_number)\n    cert.gmtime_adj_notBefore(validity_start_in_seconds)\n    cert.gmtime_adj_notAfter(validity_end_in_seconds)\n    cert.set_issuer(cert.get_subject())\n    cert.set_pubkey(private_key)\n    cert.sign(private_key, 'sha512')\n    return cert\n"}
{"type": "source_file", "path": "examples/issue_290/server.py", "content": "import asyncio\nimport logging\n\nfrom aiohttp import web\n\nfrom reactivestreams.subscriber import DefaultSubscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.helpers import DefaultPublisherSubscription\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.routing.routing_request_handler import RoutingRequestHandler\nfrom rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.aiohttp_websocket import TransportAioHttpWebsocket\n\n\nclass ChannelPublisher(DefaultPublisherSubscription):\n    def __init__(self):\n        super().__init__()\n        self.subscriber = None\n\n    def publish(self, data):\n        print(f\"ChannelPublisher - publish: {data}\")\n        print(f\"ChannelPublisher - publish subscriber: {self.subscriber}\")\n\n        if (self.subscriber is not None):\n            self.subscriber.on_next(Payload(data.encode('utf-8')))\n\n    def subscribe(self, subscriber):\n        print(\"ChannelPublisher - subscribe\")\n\n        self.subscriber = subscriber\n\n        subscriber.on_subscribe(self)\n\n\nclass ChannelSubscriber(DefaultSubscriber):\n\n    def __init__(self, publisher: ChannelPublisher):\n        self.subscription = None\n        self.publisher = publisher\n\n    def on_subscribe(self, subscription: Subscription):\n        print(\"ChannelSubscriber - on_subscribe\")\n        subscription.request(3)\n\n    def on_next(self, value: Payload, is_complete=False):\n        user_message = value.data.decode('utf-8')\n        print(f\"ChannelSubscriber - on_next: {user_message}\")\n\n        self.publisher.publish(f\"Some text and message: {user_message}\")\n\n\ndef handler_factory_factory():\n    router = RequestRouter()\n\n    @router.channel('channel')\n    async def channel_response(payload: Payload, composite_metadata):\n        print('Got channel request')\n\n        publisher = ChannelPublisher()\n        subscriber = ChannelSubscriber(publisher)\n\n        # WHY?: if passing received payload to ChannelSubscriber here can be processed before at ChannelPublisher \"subscribe\" method got subscriber\n        # in other words - we do \"one_next()\", it will be processed with some logic and result can be published with \"publish()\"\n        # subscriber.on_next(payload)\n\n        return publisher, subscriber\n\n    def handler_factory():\n        return RoutingRequestHandler(router)\n\n    return handler_factory\n\n\ndef websocket_handler_factory(**kwargs):\n    async def websocket_handler(request):\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        transport = TransportAioHttpWebsocket(ws)\n        RSocketServer(transport, **kwargs)\n        await transport.handle_incoming_ws_messages()\n        return ws\n\n    return websocket_handler\n\n\nasync def start_server():\n    logging.basicConfig(level=logging.DEBUG)\n\n    print(f'Starting server at localhost: 7878')\n\n    app = web.Application()\n    app.add_routes(\n        [\n            web.get(\n                '/rsocket',\n                websocket_handler_factory(\n                    handler_factory=handler_factory_factory()\n                )\n            ),\n            # web.static('/static', 'static'),\n        ]\n    )\n\n    await web._run_app(app, port=7878, ssl_context=None)\n\n\nif __name__ == '__main__':\n    asyncio.run(start_server())"}
{"type": "source_file", "path": "examples/graphql/client_graphql.py", "content": "import asyncio\nimport logging\nimport sys\nfrom pathlib import Path\n\nfrom gql import gql, Client\n\nfrom rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.graphql.rsocket_transport import RSocketTransport\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\n\nasync def main(server_port: int):\n    connection = await asyncio.open_connection('localhost', server_port)\n\n    async with RSocketClient(single_transport_provider(TransportTCP(*connection)),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA) as client:\n        with (Path(__file__).parent / 'rsocket.graphqls').open() as fd:\n            schema = fd.read()\n\n        graphql = Client(\n            schema=schema,\n            transport=RSocketTransport(client),\n        )\n\n        await query_schema(graphql)\n\n        await greeting(graphql)\n        await subscription(graphql)\n\n        await set_message(graphql, \"updated message\")\n        await verify_message(graphql, \"updated message\")\n\n\nasync def query_schema(graphql: Client):\n    response = await graphql.execute_async(\n        gql(\"\"\"{\n        __schema {\n        types {\n        name\n    }\n    }\n    }\"\"\"),\n        get_execution_result=True)\n    print(response.data)\n\n\nasync def subscription(graphql: Client):\n    async for response in graphql.subscribe_async(\n            document=gql(\"\"\"\n                subscription {\n                    greetings {message}\n                }\n                \"\"\"),\n            get_execution_result=True):\n        print(response.data)\n\n\nasync def greeting(graphql: Client):\n    response = await graphql.execute_async(\n        gql(\"\"\"query { greeting { message } }\"\"\"),\n        get_execution_result=True)\n\n    assert response.data['greeting']['message'] == 'Hello world'\n\n    print(response.data)\n\n\nasync def verify_message(graphql: Client, expected_message: str):\n    response = await graphql.execute_async(\n        gql(\"\"\"query { getMessage }\"\"\")\n    )\n\n    assert response['getMessage'] == expected_message\n\n    print(response)\n\n\nasync def set_message(graphql: Client, message: str):\n    response = await graphql.execute_async(\n        gql(\"\"\"mutation SetMessage($message:String) { setMessage (message: $message ) {message}}\"\"\"),\n        variable_values={\"message\": message}\n    )\n\n    print(response)\n\n\nif __name__ == '__main__':\n    port = sys.argv[1] if len(sys.argv) > 1 else 9191\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(port))\n"}
{"type": "source_file", "path": "examples/response_channel.py", "content": "import itertools\nimport logging\nfrom typing import AsyncGenerator, Tuple, Optional\n\nfrom reactivestreams.subscriber import Subscriber\nfrom reactivestreams.subscription import Subscription\nfrom rsocket.payload import Payload\nfrom rsocket.streams.stream_from_async_generator import StreamFromAsyncGenerator\n\n\ndef sample_async_response_stream(response_count: int = 3,\n                                 local_subscriber: Optional[Subscriber] = None,\n                                 is_infinite_stream: bool = False):\n    async def generator() -> AsyncGenerator[Tuple[Payload, bool], None]:\n        try:\n            current_response = 0\n\n            def range_counter():\n                return range(response_count)\n\n            if not is_infinite_stream:\n                counter = range_counter\n            else:\n                counter = itertools.count\n\n            for i in counter():\n                if is_infinite_stream:\n                    is_complete = False\n                else:\n                    is_complete = (current_response + 1) == response_count\n\n                message = 'Item on channel: %s' % current_response\n                yield Payload(message.encode('utf-8')), is_complete\n\n                if local_subscriber is not None:\n                    local_subscriber.subscription.request(2)\n\n                if is_complete:\n                    break\n\n                current_response += 1\n        finally:\n            logging.info('Closing async stream generator')\n\n    return StreamFromAsyncGenerator(generator)\n\n\nclass LoggingSubscriber(Subscriber):\n    def on_subscribe(self, subscription: Subscription):\n        self.subscription = subscription\n\n    def on_next(self, value: Payload, is_complete=False):\n        logging.info('From client on channel: ' + value.data.decode('utf-8'))\n\n    def on_error(self, exception: Exception):\n        logging.error('Error on channel ' + str(exception))\n\n    def on_complete(self):\n        logging.info('Completed on channel')\n"}

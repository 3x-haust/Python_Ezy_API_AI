{"repo_info": {"repo_name": "python-whatsapp", "repo_owner": "DominiquePaul", "repo_url": "https://github.com/DominiquePaul/python-whatsapp"}}
{"type": "test_file", "path": "tests/conftest.py", "content": "import pytest\n\nfrom whatsapp import WebhookRequestData\n\n\n@pytest.fixture\ndef example_text_message() -> WebhookRequestData:\n    return WebhookRequestData(\n        object=\"whatsapp_business_account\",\n        entry=[\n            {\n                \"id\": \"206144975918077\",\n                \"changes\": [\n                    {\n                        \"value\": {\n                            \"messaging_product\": \"whatsapp\",\n                            \"metadata\": {\n                                \"display_phone_number\": \"15551291301\",\n                                \"phone_number_id\": \"196914110180497\",\n                            },\n                            \"contacts\": [\n                                {\n                                    \"profile\": {\"name\": \"Dominique Paul\"},\n                                    \"wa_id\": \"4915159922222\",\n                                }\n                            ],\n                            \"messages\": [\n                                {\n                                    \"from\": \"4915159922222\",\n                                    \"id\": \"wamid.HBgNNDkxNTE1OTkyNjE2MhUCABIYFDNBMDIwQjk1NzQ1ODgxRUI1Njk1AA==\",\n                                    \"timestamp\": \"1706312529\",\n                                    \"text\": {\"body\": \"Hello, this is the message\"},\n                                    \"type\": \"text\",\n                                }\n                            ],\n                        },\n                        \"field\": \"messages\",\n                    }\n                ],\n            }\n        ],\n    )\n\n\n@pytest.fixture\ndef example_text_reply():\n    return WebhookRequestData(\n        object=\"whatsapp_business_account\",\n        entry=[\n            {\n                \"id\": \"206144975918077\",\n                \"changes\": [\n                    {\n                        \"value\": {\n                            \"messaging_product\": \"whatsapp\",\n                            \"metadata\": {\n                                \"display_phone_number\": \"15551291301\",\n                                \"phone_number_id\": \"196914110180497\",\n                            },\n                            \"contacts\": [\n                                {\n                                    \"profile\": {\"name\": \"Dominique Paul\"},\n                                    \"wa_id\": \"4915159922222\",\n                                }\n                            ],\n                            \"messages\": [\n                                {\n                                    \"context\": {\n                                        \"from\": \"15551291301\",\n                                        \"id\": \"wamid.HBgNNDkxNTE1OTkyNjE2MhUCABIYFDNBMDIwQjk1NzQ1ODgxRUI1Njk1AA==\",\n                                    },\n                                    \"from\": \"4915159922222\",\n                                    \"id\": \"wamid.HBgNNDkxNTE1OTkyNjE2MhUCABIYFDNBMjVBMTJGQjcwRjM1NkZCNzQ4AA==\",\n                                    \"timestamp\": \"1706567189\",\n                                    \"text\": {\n                                        \"body\": \"Hi, my message references the one above\"\n                                    },\n                                    \"type\": \"text\",\n                                }\n                            ],\n                        },\n                        \"field\": \"messages\",\n                    }\n                ],\n            }\n        ],\n    )\n\n\n@pytest.fixture\ndef example_voice_message():\n    return WebhookRequestData(\n        object=\"whatsapp_business_account\",\n        entry=[\n            {\n                \"id\": \"206144975918077\",\n                \"changes\": [\n                    {\n                        \"value\": {\n                            \"messaging_product\": \"whatsapp\",\n                            \"metadata\": {\n                                \"display_phone_number\": \"15551291301\",\n                                \"phone_number_id\": \"196914110180497\",\n                            },\n                            \"contacts\": [\n                                {\n                                    \"profile\": {\"name\": \"Dominique Paul\"},\n                                    \"wa_id\": \"4915159922222\",\n                                }\n                            ],\n                            \"messages\": [\n                                {\n                                    \"from\": \"4915159922222\",\n                                    \"id\": \"wamid.HBgNNDkxNTE1OTkyNjE2MhUCABIYFDNBM0M2MDQ3OEI4RDcxMDMwODE0AA==\",\n                                    \"timestamp\": \"1706312711\",\n                                    \"type\": \"audio\",\n                                    \"audio\": {\n                                        \"mime_type\": \"audio/ogg; codecs=opus\",\n                                        \"sha256\": \"G1Hj0bsE1u0jOrAronuRexvsU5k+gcGncZCKgbHfcr8=\",\n                                        \"id\": \"1048715742889904\",\n                                        \"voice\": True,\n                                    },\n                                }\n                            ],\n                        },\n                        \"field\": \"messages\",\n                    }\n                ],\n            }\n        ],\n    )\n\n\n@pytest.fixture\ndef example_image_message():\n    return WebhookRequestData(\n        object=\"whatsapp_business_account\",\n        entry=[\n            {\n                \"id\": \"206144975918077\",\n                \"changes\": [\n                    {\n                        \"value\": {\n                            \"messaging_product\": \"whatsapp\",\n                            \"metadata\": {\n                                \"display_phone_number\": \"15551291301\",\n                                \"phone_number_id\": \"196914110180497\",\n                            },\n                            \"contacts\": [\n                                {\n                                    \"profile\": {\"name\": \"Dominique Paul\"},\n                                    \"wa_id\": \"4915159926263\",\n                                }\n                            ],\n                            \"messages\": [\n                                {\n                                    \"from\": \"4915159922222\",\n                                    \"id\": \"wamid.HBgNNDkxNTE1OTkyNjE2MhUCABIYFDNBNUIyN0IzRjE5MUIzREM0Qjc3AA==\",\n                                    \"timestamp\": \"1706312824\",\n                                    \"type\": \"image\",\n                                    \"image\": {\n                                        \"mime_type\": \"image/jpeg\",\n                                        \"sha256\": \"/EEIcuQqsUpBRW+1KQNd4kTtyhuTYFTI5mTdOwER8Tw=\",\n                                        \"id\": \"897438572169645\",\n                                    },\n                                }\n                            ],\n                        },\n                        \"field\": \"messages\",\n                    }\n                ],\n            }\n        ],\n    )\n"}
{"type": "test_file", "path": "tests/test_endpoints.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\n\nfrom main import app\n\nclient = TestClient(app)\n\n\ndef test_verification_fails():\n    \"\"\"\n    Test webhook verification mechanism.\n    \"\"\"\n    challenge_value = \"challenge\"\n\n    response = client.get(\n        \"/api/whatsapp\",\n        params={\n            \"hub.mode\": \"subscribe\",\n            \"hub.verify_token\": \"bad_token\",\n            \"hub.challenge\": challenge_value,\n        },\n    )\n    assert response.status_code == 403\n    assert response.content == b\"Verification token mismatch\"\n\n\n@pytest.mark.asyncio\nasync def test_valid_whatsapp_message(mocker, example_text_message):\n    # Arrange\n    data = example_text_message.model_dump(mode=\"json\")\n    mock_send_message = mocker.AsyncMock()\n    mocker.patch(\"whatsapp.send_message\", new=mock_send_message)\n    # or whatever the send_message is supposed to return\n    mock_send_message.return_value = True\n\n    response = client.post(\"/api/whatsapp\", json=data)\n\n    # Assert\n    assert response.status_code == 200\n    assert response.content == b'\"ok\"'\n"}
{"type": "test_file", "path": "tests/test_whatsapp.py", "content": "import pytest\n\nimport whatsapp as wa\n\n\n@pytest.mark.asyncio\nasync def test_parse_whatsapp_message_text(example_text_message):\n    result = await wa.parse_whatsapp_message(example_text_message)\n\n    assert result is not None, \"The result should not be None\"\n    assert isinstance(result, wa.WamBase), \"The result should be of type WamBase\"\n    assert (\n        result.wa_id == \"4915159922222\"\n    ), \"The 'wa_id' value should match the test message sender\"\n    assert (\n        result.message_body == \"Hello, this is the message\"\n    ), \"The 'message_body' should contain the message text\"\n    assert (\n        result.wamid\n        == \"wamid.HBgNNDkxNTE1OTkyNjE2MhUCABIYFDNBMDIwQjk1NzQ1ODgxRUI1Njk1AA==\"\n    )\n\n\n@pytest.mark.asyncio\nasync def test_parse_whatsapp_message_text_reply(example_text_reply):\n    result = await wa.parse_whatsapp_message(example_text_reply)\n\n    assert result is not None, \"The result should not be None\"\n    assert isinstance(result, wa.WamBase), \"The result should be of type WamBase\"\n    assert (\n        result.wa_id == \"4915159922222\"\n    ), \"The 'wa_id' value should match the test message sender\"\n    assert (\n        result.message_body == \"Hi, my message references the one above\"\n    ), \"The 'message_body' should contain the message text\"\n    assert (\n        result.reference_wamid\n        == \"wamid.HBgNNDkxNTE1OTkyNjE2MhUCABIYFDNBMDIwQjk1NzQ1ODgxRUI1Njk1AA==\"\n    )\n    assert result.reference_message_user_phone == \"15551291301\"\n\n\n@pytest.mark.asyncio\nasync def test_parse_voice_message(example_voice_message):\n    parsed_message = await wa.parse_whatsapp_message(example_voice_message)\n\n    assert isinstance(\n        parsed_message, wa.WamMediaType\n    ), \"The returned object should be an instance of WamMediaType.\"\n    assert (\n        parsed_message.webhook_id == \"206144975918077\"\n    ), \"The webhook_id should match the fixture.\"\n    assert (\n        parsed_message.wamid\n        == \"wamid.HBgNNDkxNTE1OTkyNjE2MhUCABIYFDNBM0M2MDQ3OEI4RDcxMDMwODE0AA==\"\n    ), \"The wamid should match the fixture.\"\n    assert (\n        parsed_message.phone_number_id == \"196914110180497\"\n    ), \"The phone_number_id should match the fixture.\"\n    assert (\n        parsed_message.wa_id == \"4915159922222\"\n    ), \"The wa_id should match the fixture.\"\n    assert (\n        parsed_message.profile_name == \"Dominique Paul\"\n    ), \"The profile_name should match the fixture.\"\n    assert parsed_message.message_type == \"audio\", \"The message_type should be 'audio'.\"\n    assert (\n        parsed_message.timestamp == \"1706312711\"\n    ), \"The timestamp should match the fixture.\"\n    assert (\n        parsed_message.mime_type == \"audio/ogg; codecs=opus\"\n    ), \"The mime_type should match the fixture.\"\n    assert (\n        parsed_message.media_id == \"1048715742889904\"\n    ), \"The media_id should match the fixture.\"\n    assert isinstance(\n        parsed_message.media_bytes, bytes\n    ), \"The media_bytes should be of type bytes.\"\n\n\n@pytest.mark.asyncio\nasync def test_parse_image_message(example_image_message):\n    parsed_message = await wa.parse_whatsapp_message(example_image_message)\n\n    assert isinstance(\n        parsed_message, wa.WamMediaType\n    ), \"The returned object should be an instance of WamMediaType.\"\n    assert (\n        parsed_message.webhook_id == \"206144975918077\"\n    ), \"The webhook_id should match the fixture.\"\n    assert (\n        parsed_message.wamid\n        == \"wamid.HBgNNDkxNTE1OTkyNjE2MhUCABIYFDNBNUIyN0IzRjE5MUIzREM0Qjc3AA==\"\n    ), \"The wamid should match the fixture.\"\n    assert (\n        parsed_message.phone_number_id == \"196914110180497\"\n    ), \"The phone_number_id should match the fixture.\"\n    assert (\n        parsed_message.wa_id == \"4915159926263\"\n    ), \"The wa_id should match the fixture.\"\n    assert (\n        parsed_message.profile_name == \"Dominique Paul\"\n    ), \"The profile_name should match the fixture.\"\n    assert parsed_message.message_type == \"image\", \"The message_type should be 'image'.\"\n    assert (\n        parsed_message.timestamp == \"1706312824\"\n    ), \"The timestamp should match the fixture.\"\n    assert (\n        parsed_message.mime_type == \"image/jpeg\"\n    ), \"The mime_type should match the fixture.\"\n    assert (\n        parsed_message.media_id == \"897438572169645\"\n    ), \"The media_id should match the fixture.\"\n    assert isinstance(\n        parsed_message.media_bytes, bytes\n    ), \"The media_bytes should be of type bytes.\"\n"}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "source_file", "path": "setup.py", "content": "from setuptools import find_packages, setup\n\nsetup(\n    name=\"whatsapp\",\n    version=\"0.1\",\n    packages=[\"whatsapp\"],\n    install_requires=[\n        \"annotated-types>=0.6.0\",\n        \"anyio>=4.2.0\",\n        \"asyncio>=3.4.3\",\n        \"certifi>=2023.11.17\",\n        \"charset-normalizer>=3.3.2\",\n        \"click>=8.1.7\",\n        \"fastapi>=0.109.0\",\n        \"h11>=0.14.0\",\n        \"httpcore>=1.0.2\",\n        \"httpx>=0.25.2\",\n        \"idna>=3.6\",\n        \"iniconfig>=2.0.0\",\n        \"packaging>=23.2\",\n        \"pluggy>=1.4.0\",\n        \"pydantic>=2.5.3\",\n        \"pydantic_core>=2.14.6\",\n        \"pytest>=7.4.4\",\n        \"pytest-asyncio>=0.23.3\",\n        \"pytest-mock>=3.12.0\",\n        \"python-dotenv>=1.0.1\",\n        \"requests>=2.31.0\",\n        \"sniffio>=1.3.0\",\n        \"starlette>=0.35.1\",\n        \"typing_extensions>=4.9.0\",\n        \"urllib3>=2.1.0\",\n        \"uvicorn>=0.27.0\",\n    ],\n)\n"}
{"type": "source_file", "path": "main.py", "content": "import json\nimport logging\n\nimport uvicorn\nfrom dotenv import load_dotenv\nfrom fastapi import Depends, FastAPI, Request\nfrom fastapi.responses import JSONResponse\n\nimport whatsapp as wa\n\nload_dotenv()  # needs to happen before cfg is loaded\n\n\nlogging.basicConfig(\n    filename=\"example.log\",\n    level=logging.DEBUG,\n    format=\"%(asctime)s %(levelname)s:%(message)s\",\n)\n\n# Init App.\napp = FastAPI()\n\n\n@app.router.get(\"/api/whatsapp\")\nasync def verify(request: Request):\n    return wa.verify(request)\n\n\n@app.router.post(\"/api/whatsapp\")\nasync def webhook(wam: wa.WamBase = Depends(wa.process_webhook_data)):\n    if wam is None:\n        return JSONResponse(content=\"ok\", status_code=200)\n\n    if isinstance(wam, wa.WamMediaType):\n        await wa.send_message(\n            recipient_id=wam.wa_id, message=f\"Mmm, {wam.message_type}\"\n        )\n    elif wam.message_type == \"text\":\n        await wa.send_message(recipient_id=wam.wa_id, message=wam.message_body)\n    return JSONResponse(content=\"ok\", status_code=200)\n\n\nif __name__ == \"__main__\":\n    print(\"your verify token is: \", wa.WHATSAPP_VERIFY_TOKEN)\n    uvicorn.run(\"grannymail.main:app\", reload=True)\n"}
{"type": "source_file", "path": "whatsapp.py", "content": "import json\nimport logging\nimport os\nfrom dataclasses import dataclass, field\n\nimport httpx\nfrom dotenv import load_dotenv\nfrom fastapi import HTTPException, Request, Response\nfrom pydantic import BaseModel\n\nload_dotenv()\n\nWHATSAPP_TOKEN = os.environ[\"WHATSAPP_TOKEN\"]\nWHATSAPP_API_VERSION = os.environ[\"WHATSAPP_API_VERSION\"]\nWHATSAPP_PHONE_NUMBER_ID = os.environ[\"WHATSAPP_PHONE_NUMBER_ID\"]\nWHATSAPP_VERIFY_TOKEN = os.environ[\"WHATSAPP_VERIFY_TOKEN\"]\n\n\nclass WebhookRequestData(BaseModel):\n    object: str = \"\"\n    entry: list = []\n\n\n@dataclass\nclass WamBase:\n    webhook_id: str\n    wamid: str\n    phone_number_id: str\n    wa_id: str\n    profile_name: str\n    message_type: str\n    timestamp: str\n    message_body: str = field(default=\"\", kw_only=True)\n    reference_wamid: str | None = field(default=None, kw_only=True)\n    reference_message_user_phone: str | None = field(default=None, kw_only=True)\n\n\n@dataclass\nclass WamMediaType(WamBase):\n    mime_type: str\n    media_id: str\n    media_bytes: bytes = field(default=b\"\")\n\n\ndef verify(request: Request):\n    \"\"\"\n    On webook verification VERIFY_TOKEN has to match the token at the\n    configuration and send back \"hub.challenge\" as success.\n    \"\"\"\n    mode = request.query_params.get(\"hub.mode\") == \"subscribe\"\n    challenge = request.query_params.get(\"hub.challenge\")\n    token = request.query_params.get(\"hub.verify_token\")\n\n    if mode and challenge:\n        if token != WHATSAPP_VERIFY_TOKEN:\n            return Response(content=\"Verification token mismatch\", status_code=403)\n        return Response(content=request.query_params[\"hub.challenge\"])\n\n    return Response(content=\"Required arguments haven't passed.\", status_code=400)\n\n\nasync def process_webhook_data(data: WebhookRequestData) -> WamBase | None:\n    if data.entry[0].get(\"changes\", [{}])[0].get(\"value\", {}).get(\"statuses\"):\n        logging.info(\"Received a WhatsApp status update.\")\n        return None\n    # if not a status update\n    try:\n        if is_valid_whatsapp_message(data):\n            wam = await parse_whatsapp_message(data)\n            return wam\n        else:\n            # if the request is not a WhatsApp API event, return an error\n            raise HTTPException(status_code=404, detail=\"Not a WhatsApp API event\")\n    except json.JSONDecodeError:\n        logging.error(\"Failed to decode JSON\")\n        raise HTTPException(status_code=400, detail=\"Invalid JSON provided\")\n\n\ndef is_valid_whatsapp_message(body: WebhookRequestData) -> bool:\n    \"\"\"\n    Validates the structure of the incoming webhook event to ensure it contains a WhatsApp message.\n\n    Args:\n        body (WebhookRequestData): The incoming webhook request data.\n\n    Returns:\n        bool: True if the message structure is valid, False otherwise.\n    \"\"\"\n    try:\n        return bool(body.entry[0][\"changes\"][0][\"value\"][\"messages\"][0])\n    except (IndexError, KeyError):\n        return False\n\n\nasync def parse_whatsapp_message(body: WebhookRequestData) -> WamBase:\n    \"\"\"\n    Parse the incoming webhook request data and return an instance of WamBase or WamMediaType.\n\n    This function extracts the necessary information from the webhook request data to\n    instantiate and return a WamBase dataclass object for text messages or a WamMediaType\n    dataclass object for media messages (audio, document, image). If the message type is\n    unsupported, it raises a ValueError.\n\n    Args:\n        body (WebhookRequestData): The incoming webhook request data.\n\n    Returns:\n        WamBase: An instance of WamBase for text messages.\n        WamMediaType: An instance of WamMediaType for media messages.\n    \"\"\"\n    values = body.entry[0][\"changes\"][0][\"value\"]\n    message = values[\"messages\"][0]\n    wam_data = {\n        \"webhook_id\": body.entry[0][\"id\"],\n        \"wamid\": message[\"id\"],\n        \"phone_number_id\": values[\"metadata\"][\"phone_number_id\"],\n        \"wa_id\": values[\"contacts\"][0][\"wa_id\"],\n        \"profile_name\": values[\"contacts\"][0][\"profile\"][\"name\"],\n        \"message_type\": message[\"type\"],\n        \"timestamp\": message[\"timestamp\"],\n    }\n\n    if message.get(\"context\"):\n        wam_data.update(\n            {\n                \"reference_wamid\": message[\"context\"][\"id\"],\n                \"reference_message_user_phone\": message[\"context\"][\"from\"],\n            }\n        )\n    if message[\"type\"] == \"text\":\n        wam_data[\"message_body\"] = message[\"text\"][\"body\"]\n    elif message[\"type\"] in [\"audio\", \"document\", \"image\"]:\n        wam_data.update(\n            {\n                \"mime_type\": message[message[\"type\"]][\"mime_type\"],\n                \"media_id\": message[message[\"type\"]][\"id\"],\n            }\n        )\n        wam_media = WamMediaType(**wam_data)\n        wam_media.media_bytes = await _download_media(wam_media.media_id)\n        return wam_media\n    else:\n        raise ValueError(f\"Unsupported message type: '{message['type']}'\")\n\n    return WamBase(**wam_data)\n\n\nasync def _download_media(media_id) -> bytes:\n    \"\"\"\n    Download media from the given media_id.\n\n    This function uses the media_id to construct a URL to the media file,\n    sends a GET request to that URL, and returns the content of the response.\n    If the media file cannot be found or accessed, an HTTP error is raised.\n\n    Args:\n        media_id (str): The ID of the media file to download.\n\n    Returns:\n        bytes: The content of the media file.\n    \"\"\"\n    endpoint = f\"https://graph.facebook.com/{WHATSAPP_API_VERSION}/{media_id}\"\n    headers = {\"Authorization\": f\"Bearer {WHATSAPP_TOKEN}\"}\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        response = await client.get(endpoint, headers=headers)\n        response.raise_for_status()\n        download_url = response.json()[\"url\"]\n\n        response = await client.get(download_url, headers=headers)\n        response.raise_for_status()\n        return response.content\n\n\nasync def _post_httpx_request(\n    url: str, data: dict | None = None, files: dict | None = None\n) -> dict:\n    \"\"\"\n    Send a POST request to the given URL with the provided data and files.\n\n    This function constructs a POST request with the given data and files,\n    sends the request to the given URL, and returns the JSON content of the response.\n    If the response contains more than one contact or message, a ValueError is raised.\n\n    Args:\n        url (str): The URL to send the POST request to.\n        data (dict, optional): The data to include in the request body. Defaults to None.\n        files (dict, optional): The files to include in the request body. Defaults to None.\n\n    Returns:\n        dict: The JSON content of the response.\n    \"\"\"\n    headers = {\"Authorization\": f\"Bearer {WHATSAPP_TOKEN}\"}\n    print(WHATSAPP_TOKEN)\n    if data:\n        headers[\"Content-Type\"] = \"application/json\"\n    async with httpx.AsyncClient(timeout=10) as client:\n        response = await client.post(url, json=data, headers=headers, files=files)\n        response.raise_for_status()\n\n    r = response.json()\n    if data and (\n        \"contacts\" in r\n        and len(r[\"contacts\"]) > 1\n        or \"messages\" in r\n        and len(r[\"messages\"]) > 1\n    ):\n        raise ValueError(\"Expected only one contact and one message in the response.\")\n\n    return r\n\n\nasync def send_message(recipient_id: str, message: str) -> dict:\n    \"\"\"\n    Send a text message to the recipient.\n\n    This function constructs a message with the given recipient_id and message,\n    sends the message to the recipient, and returns the JSON content of the response.\n\n    Args:\n        recipient_id (str): The ID of the recipient to send the message to.\n        message (str): The message to send.\n\n    Returns:\n        dict: The JSON content of the response.\n    \"\"\"\n    data = {\n        \"messaging_product\": \"whatsapp\",\n        \"recipient_type\": \"individual\",\n        \"to\": recipient_id,\n        \"type\": \"text\",\n        \"text\": {\"preview_url\": False, \"body\": message},\n    }\n    url = f\"https://graph.facebook.com/{WHATSAPP_API_VERSION}/{WHATSAPP_PHONE_NUMBER_ID}/messages\"\n    return await _post_httpx_request(url, data=data)\n\n\nasync def send_quick_reply_message(\n    recipient_id: str, message: str, buttons: list[str]\n) -> dict:\n    \"\"\"\n    Send a quick reply message with buttons to the recipient.\n\n    This function constructs a message with the given recipient_id and message,\n    adds quick reply buttons, sends the message to the recipient, and returns\n    the JSON content of the response.\n\n    Args:\n        recipient_id (str): The ID of the recipient to send the message to.\n        message (str): The message to send.\n        buttons (list[str]): A list of button titles for quick replies.\n\n    Returns:\n        dict: The JSON content of the response.\n    \"\"\"\n    btns = [\n        {\"type\": \"reply\", \"reply\": {\"id\": f\"choice{idx+1}\", \"title\": b}}\n        for idx, b in enumerate(buttons)\n    ]\n    data = {\n        \"messaging_product\": \"whatsapp\",\n        \"recipient_type\": \"individual\",\n        \"to\": recipient_id,\n        \"type\": \"interactive\",\n        \"interactive\": {\n            \"type\": \"button\",\n            \"body\": {\"text\": message},\n            \"action\": {\"buttons\": btns},\n        },\n    }\n    endpoint = f\"https://graph.facebook.com/{WHATSAPP_API_VERSION}/{WHATSAPP_PHONE_NUMBER_ID}/messages\"\n    return await _post_httpx_request(endpoint, data=data)\n\n\nasync def _upload_media(file_data: bytes, file_name: str, mime_type: str) -> dict:\n    \"\"\"\n    Uploads a media file to the server.\n\n    Args:\n        file_data (bytes): The data of the file to be uploaded.\n        file_name (str): The name of the file to be uploaded.\n        mime_type (str): The MIME type of the file to be uploaded.\n\n    Returns:\n        dict: The JSON content of the response.\n    \"\"\"\n    files: dict = {\n        \"file\": (file_name, file_data, mime_type),\n        \"type\": (None, \"application/json\"),\n        \"messaging_product\": (None, \"whatsapp\"),\n    }\n    endpoint: str = f\"https://graph.facebook.com/{WHATSAPP_API_VERSION}/{WHATSAPP_PHONE_NUMBER_ID}/media\"\n    return await _post_httpx_request(endpoint, files=files)\n\n\nasync def send_pdf(\n    recipient_id: str, file_data: bytes, file_name: str, mime_type: str\n) -> dict:\n    \"\"\"\n    Sends a PDF file to the specified recipient on WhatsApp.\n\n    Args:\n        recipient_id (str): The ID of the recipient to send the PDF to.\n        file_data (bytes): The binary content of the PDF file.\n        file_name (str): The name of the PDF file.\n        mime_type (str): The MIME type of the file, should be 'application/pdf'.\n\n    Returns:\n        dict: The JSON content of the response from the WhatsApp API.\n    \"\"\"\n    media_id = (await _upload_media(file_data, file_name, mime_type))[\"id\"]\n    data = {\n        \"messaging_product\": \"whatsapp\",\n        \"recipient_type\": \"individual\",\n        \"to\": recipient_id,\n        \"type\": \"document\",\n        \"document\": {\"filename\": file_name, \"id\": media_id},\n    }\n    endpoint = f\"https://graph.facebook.com/{WHATSAPP_API_VERSION}/{WHATSAPP_PHONE_NUMBER_ID}/messages\"\n    return await _post_httpx_request(endpoint, data=data)\n"}

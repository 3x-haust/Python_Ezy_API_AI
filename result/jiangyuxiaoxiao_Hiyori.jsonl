{"repo_info": {"repo_name": "Hiyori", "repo_owner": "jiangyuxiaoxiao", "repo_url": "https://github.com/jiangyuxiaoxiao/Hiyori"}}
{"type": "test_file", "path": "Hiyori/tests/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/9/12-16:23\n@Desc: 测试代码目录\n@Ver : 1.0.0\n\"\"\"\n"}
{"type": "test_file", "path": "Hiyori/tests/test_1.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/9/12-16:39\n@Desc: 测试示例\n@Ver : 1.0.0\n\"\"\"\n\n\ndef test_1():\n    a = 1\n    assert a == 1\n"}
{"type": "test_file", "path": "Hiyori/tests/conftest.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/9/12-16:23\n@Desc: 测试配置文件\n@Ver : 1.0.0\n\"\"\"\n\nimport pytest\nimport sys\nimport json\nimport time\nimport os\n\nimport nonebot\nfrom nonebot.log import logger\nfrom nonebot.plugin import _plugins\nfrom nonebot.adapters.onebot.v11 import Adapter\n\nfrom Hiyori.Utils.File import DirExist\n\nos.environ[\"ENVIRONMENT\"] = \"test\"\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef load_bot():\n    # 加载适配器\n    driver = nonebot.get_driver()\n    driver.register_adapter(Adapter)\n\n    # 加载插件\n    # 插件目录加载进环境变量\n    sys.path.append(\"../\")\n    sys.path.append(\"./Plugins/Basic_plugins\")  # 底层实现插件，管理类插件，请在加载时置于最顶层\n    sys.path.append(\"./Plugins/Debug_plugins\")  # 调试插件\n    sys.path.append(\"./Plugins/Nonebot_plugins\")  # nonebot社区插件\n    sys.path.append(\"./Plugins/Normal_plugins\")  # 普通功能插件\n    sys.path.append(\"./Plugins/Personal_plugins\")  # 私人插件\n    sys.path.append(\"./Plugins/Market_plugins\")  # 市场插件\n    sys.path.append(\"./Plugins/AI_plugins\")  # AI生成插件\n    sys.path.append(\"./Plugins/Web_plugins\")  # 后端插件\n    sys.path.append(\"./Plugins/Zao_plugins\")  # zao插件\n    # 根据初始化配置选择插件目录配置文件进行初始化\n    # 默认配置文件路径为./plugin.dev.json\n    # 根据在.env中的环境设置，进行更新\n    configDict = driver.config.dict()\n    if \"environment\" not in configDict.keys():\n        plugin_dir = \"plugin.dev.json\"\n    else:\n        environment = configDict[\"environment\"]\n        plugin_dir = \"plugin.\" + environment + \".json\"\n\n    with open(plugin_dir, encoding=\"utf-8\") as plg_dir:\n        plugins = json.load(plg_dir)\n        plugins = plugins[\"Plugin\"][\"Dir\"]\n        for plugin in plugins:\n            time1 = time.time_ns()\n            nonebot.load_plugin(plugin)\n            time2 = time.time_ns()\n            plugin_time = (time2 - time1) / 1000000000\n            plugin_time = round(plugin_time, 3)\n            logger.info(f\"插件{plugin}加载用时{plugin_time}s\")\n\n    # 插件加载完毕后，加载meta.json\n    # 加载测试环境配置文件\n    metaDir = \"Config/TestConfig\"\n    configInitFlag = False\n    for plugin_name, plugin in _plugins.items():\n        metaPath = os.path.join(metaDir, plugin_name, \"Metadata.json\")\n        # json文件不存在，进行初始化\n        if not os.path.isfile(metaPath) or configInitFlag:\n            if plugin.metadata is None:\n                # 不进行初始化\n                logger.debug(f\"插件{plugin_name}不存在metaData，不写入配置文件。\")\n            else:\n                # 设置默认配置\n                extra = plugin.metadata.extra\n                jsonDict = {\n                    \"extra\": extra\n                }\n                DirExist(os.path.join(metaDir, plugin_name))\n                with open(file=metaPath, mode=\"w\", encoding=\"utf-8\") as metaFile:\n                    metaFile.write(json.dumps(jsonDict, ensure_ascii=False, indent=4))\n        # json文件存在，根据json文件修改metaData的extraInfo\n        else:\n            with open(file=metaPath, mode=\"r\", encoding=\"utf-8\") as metaFile:\n                info = metaFile.read()\n                info = json.loads(info)\n                if info[\"extra\"] is not None:\n                    plugin.metadata.extra = info[\"extra\"]\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_htmlrender/__init__.py", "content": "import nonebot\nfrom nonebot.log import logger\n\nfrom .browser import get_browser, get_new_page, shutdown_browser\nfrom .data_source import (\n    md_to_pic,\n    html_to_pic,\n    text_to_pic,\n    capture_element,\n    template_to_pic,\n    template_to_html,\n)\n\ndriver = nonebot.get_driver()\nconfig = driver.config\n\n\n@driver.on_startup\nasync def init(**kwargs):\n    \"\"\"Start Browser\n\n    Returns:\n        Browser: Browser\n    \"\"\"\n    browser = await get_browser(**kwargs)\n    logger.info(\"Browser Started.\")\n    return browser\n\n\n@driver.on_shutdown\nasync def shutdown():\n    await shutdown_browser()\n    logger.info(\"Browser Stopped.\")\n\n\nbrowser_init = init\n\nall = [\n    \"browser_init\",\n    \"text_to_pic\",\n    \"get_new_page\",\n    \"md_to_pic\",\n    \"template_to_html\",\n    \"template_to_pic\",\n    \"html_to_pic\",\n    \"capture_element\",\n]\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_htmlrender/browser.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n@Author         : yanyongyu\n@Date           : 2021-03-12 13:42:43\n@LastEditors    : yanyongyu\n@LastEditTime   : 2021-11-01 14:05:41\n@Description    : None\n@GitHub         : https://github.com/yanyongyu\n\"\"\"\n__author__ = \"yanyongyu\"\n\nfrom typing import Optional, AsyncIterator\nfrom contextlib import asynccontextmanager\n\nfrom nonebot import get_driver\nfrom nonebot.log import logger\nfrom playwright.async_api import Page, Error, Browser, Playwright, async_playwright\n\nfrom nonebot_plugin_htmlrender.config import Config\n\n\nclass ConfigError(Exception):\n    pass\n\n\nconfig = Config.parse_obj(get_driver().config.dict())\n\n_browser: Optional[Browser] = None\n_playwright: Optional[Playwright] = None\n\n\nasync def init(**kwargs) -> Browser:\n    global _browser\n    global _playwright\n    _playwright = await async_playwright().start()\n    try:\n        _browser = await launch_browser(**kwargs)\n    except Error:\n        await install_browser()\n        _browser = await launch_browser(**kwargs)\n    return _browser\n\n\nasync def launch_browser(proxy=config.htmlrender_proxy_host, **kwargs) -> Browser:\n    assert _playwright is not None, \"Playwright 没有安装\"\n    if proxy:\n        kwargs[\"proxy\"] = proxy\n    if config.htmlrender_browser == \"firefox\":\n        logger.info(\"使用 firefox 启动\")\n        return await _playwright.firefox.launch(**kwargs)\n\n    else:\n        # 默认使用 chromium\n        logger.info(\"使用 chromium 启动\")\n        return await _playwright.chromium.launch(**kwargs)\n\n\nasync def get_browser(**kwargs) -> Browser:\n    return _browser if _browser and _browser.is_connected() else await init(**kwargs)\n\n\n@asynccontextmanager\nasync def get_new_page(**kwargs) -> AsyncIterator[Page]:\n    browser = await get_browser()\n    page = await browser.new_page(**kwargs)\n    try:\n        yield page\n    finally:\n        await page.close()\n\n\nasync def shutdown_browser():\n    global _browser\n    global _playwright\n    if _browser:\n        await _browser.close()\n        _browser = None\n    if _playwright:\n        await _playwright.stop()  # type: ignore\n        _playwright = None\n\n\nasync def install_browser():\n    import os\n    import sys\n\n    from playwright.__main__ import main\n\n    if host := config.htmlrender_download_host:\n        logger.info(\"使用配置源进行下载\")\n        os.environ[\"PLAYWRIGHT_DOWNLOAD_HOST\"] = host\n    else:\n        logger.info(\"使用镜像源进行下载\")\n        os.environ[\n            \"PLAYWRIGHT_DOWNLOAD_HOST\"\n        ] = \"https://npmmirror.com/mirrors/playwright/\"\n    success = False\n\n    if config.htmlrender_browser == \"firefox\":\n        logger.info(\"正在安装 firefox\")\n        sys.argv = [\"\", \"install\", \"firefox\"]\n    else:\n        # 默认使用 chromium\n        logger.info(\"正在安装 chromium\")\n        sys.argv = [\"\", \"install\", \"chromium\"]\n    try:\n        logger.info(\"正在安装依赖\")\n        os.system(\"playwright install-deps\")\n        main()\n    except SystemExit as e:\n        if e.code == 0:\n            success = True\n    if not success:\n        logger.error(\"浏览器更新失败, 请检查网络连通性\")\n"}
{"type": "source_file", "path": "Hiyori/Plugins/AI_plugins/Vits/rule.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/09/28-15:31\n@Desc: 语音触发检查\n@Ver : 1.0.0\n\"\"\"\nimport re\n\nfrom nonebot.adapters.onebot.v11 import MessageEvent\n\nimport Hiyori.Utils.API.BertVits as BertVits\nimport Hiyori.Utils.API.Vits as Vits\n\nbertMap = BertVits.getBV_Map()\nvitsMap = Vits.getVits_Map()\n\n\nasync def vitsCheck(event: MessageEvent) -> bool:\n    global bertMap, vitsMap\n    msg = event.message.extract_plain_text()\n    msg = re.match(pattern=r\"#?.+说\", string=msg)\n    if msg is None:\n        return False\n    name = msg.group().split(\"说\")[0].lstrip(\"#\").rstrip()\n    if name not in bertMap.keys() and name not in vitsMap.keys():\n        return False\n    return True\n"}
{"type": "source_file", "path": "Hiyori/Plugins/AI_plugins/ai/data_class.py", "content": "import copy\nfrom pathlib import Path\nfrom typing import Any, Dict, Generic, NoReturn, Optional, TypeVar, Union, List\n\nimport ujson as json\nfrom ruamel import yaml\nfrom ruamel.yaml import YAML\n\n\n_yaml = YAML(typ=\"safe\")\n\n\nT = TypeVar(\"T\")\n\n\nclass StaticData(Generic[T]):\n    \"\"\"\n    静态数据共享类\n    \"\"\"\n\n    def __init__(self, file: Optional[Path], load_file: bool = True):\n        self._data: dict = {}\n        if file:\n            file.parent.mkdir(exist_ok=True, parents=True)\n            self.file = file\n            if file.exists() and load_file:\n                with open(file, \"r\", encoding=\"utf8\") as f:\n                    if file.name.endswith(\"json\"):\n                        try:\n                            self._data: dict = json.load(f)\n                        except ValueError:\n                            if f.read().strip():\n                                raise ValueError(f\"{file} 文件加载错误，请检查文件内容格式.\")\n                    elif file.name.endswith(\"yaml\"):\n                        self._data = _yaml.load(f)\n\n    def set(self, key, value) -> NoReturn:\n        self._data[key] = value\n        self.save()\n\n    def set_module_data(self, module, key, value, auto_save: bool = True) -> NoReturn:\n        if module in self._data.keys():\n            self._data[module][key] = value\n            if auto_save:\n                self.save()\n\n    def get(self, key) -> T:\n        return self._data.get(key)\n\n    def keys(self) -> List[str]:\n        return self._data.keys()\n\n    def delete(self, key) -> NoReturn:\n        if self._data.get(key) is not None:\n            del self._data[key]\n\n    def get_data(self) -> Dict[str, T]:\n        return copy.deepcopy(self._data)\n\n    def dict(self) -> Dict[str, Any]:\n        temp = {}\n        for k, v in self._data.items():\n            try:\n                temp[k] = v.dict()\n            except AttributeError:\n                temp[k] = copy.deepcopy(v)\n        return temp\n\n    def save(self, path: Optional[Union[str, Path]] = None):\n        path = path or self.file\n        if isinstance(path, str):\n            path = Path(path)\n        if path:\n            with open(path, \"w\", encoding=\"utf8\") as f:\n                if path.name.endswith(\"yaml\"):\n                    yaml.dump(\n                        self._data,\n                        f,\n                        indent=2,\n                        Dumper=yaml.RoundTripDumper,\n                        allow_unicode=True,\n                    )\n                else:\n                    json.dump(self.dict(), f, ensure_ascii=False, indent=4)\n\n    def reload(self):\n        if self.file.exists():\n            if self.file.name.endswith(\"json\"):\n                self._data: dict = json.load(open(self.file, \"r\", encoding=\"utf8\"))\n            elif self.file.name.endswith(\"yaml\"):\n                self._data: dict = _yaml.load(open(self.file, \"r\", encoding=\"utf8\"))\n\n    def is_exists(self) -> bool:\n        return self.file.exists()\n\n    def is_empty(self) -> bool:\n        return bool(len(self._data))\n\n    def __str__(self) -> str:\n        return str(self._data)\n\n    def __setitem__(self, key, value):\n        self._data[key] = value\n\n    def __getitem__(self, key) -> T:\n        return self._data[key]\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Ban_Checker/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:27\n@Desc: 双向禁言插件\n@Ver : 1.0.0\n\"\"\"\nfrom nonebot.adapters.onebot.v11 import GroupBanNoticeEvent, Bot\nfrom nonebot import on_notice\nfrom nonebot import get_driver\nfrom nonebot import get_bots\nfrom Hiyori.Utils.Priority import Priority\nfrom Hiyori.Utils.Database.user import DB_User\n\nfrom nonebot.plugin import PluginMetadata\n\n__plugin_meta__ = PluginMetadata(\n    name=\"双向禁言\",  # 用于在菜单显示 用于插件开关\n    description=\"禁言审核，当妃爱被所在群禁言时会自动拉黑对应群聊。\\n\"\n                \"需要关闭妃爱的回复响应请参考【群聊开关】插件，请勿随意禁言。\",  # 用于在菜单中描述\n    usage=\"被禁言时自动触发\",\n    extra={\"example\": \"\",\n           \"Group\": \"Daily\",\n           \"version\": \"1.0\",\n           \"Keep_On\": True,\n           \"Type\": \"Auto_Plugin\",\n           }\n)\n\nsuperusers = get_driver().config.superusers\n\nBan_Checker = on_notice(block=False, priority=Priority.系统优先级)\n\n\n@Ban_Checker.handle()\nasync def _(bot: Bot, event: GroupBanNoticeEvent):\n    global superusers\n    bots = get_bots().values()\n    botsID = {int(b.self_id) for b in bots}\n    # 如果自己被禁言了 或者群中的其他bot被禁言\n    if (event.self_id == event.user_id) or (event.user_id in botsID):\n        # 封禁对应群聊\n        GroupID = event.group_id\n        Group = DB_User.getGroup(GroupID)\n        Group.Permission = 3\n        DB_User.updateGroup(Group)\n        # 发送消息给开发者\n        group_info = await bot.get_group_info(group_id=event.group_id)\n        group_name = group_info[\"group_name\"]\n        message = f\"群{group_name}({GroupID})触发封禁反击机制\"\n        for superuser in superusers:\n            await bot.send_private_msg(user_id=int(superuser), message=message)\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Plugin_Manager/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:34\n@Desc: \n@Ver : 1.0.0\n\"\"\"\nimport re\n\nfrom nonebot import on_regex\nfrom nonebot import get_loaded_plugins\nfrom nonebot.plugin import PluginMetadata\nfrom nonebot.log import logger\nfrom nonebot.adapters.onebot.v11 import GroupMessageEvent, MessageEvent, MessageSegment\nfrom nonebot.adapters.onebot.v11 import GROUP_ADMIN, GROUP_OWNER\n\nfrom Hiyori.Plugins.Basic_plugins.nonebot_plugin_htmlrender import md_to_pic\n\nfrom Hiyori.Utils.Permissions import HIYORI_OWNER, HIYORI_ADMIN\nfrom Hiyori.Utils.Priority import Priority\n\nfrom .pluginManager import pluginsManager\nfrom .hook import check_group_plugin_status\nfrom .api import *\n\n__plugin_meta__ = PluginMetadata(\n    name=\"插件开关\",\n    description=\"开启或者关闭对群聊/个人的插件响应\",\n    usage=\"#群组开启插件 插件名\\n\"\n          \"#群组关闭插件 插件名\\n\"\n          \"#群组插件状态\\n\"\n          \"#群组插件白名单模式/群组插件黑名单模式\\n\"\n          \"#个人开启插件 插件名\\n\"\n          \"#个人关闭插件 插件名\\n\"\n          \"#个人插件状态\\n\"\n          \"#个人插件白名单模式/个人插件黑名单模式\\n\",\n    extra={\n        \"CD_Weight\": 2,\n        \"example\": \"\",\n        \"permission\": \"个人：普通权限\\n\"\n                      \"群聊：群管/妃爱管理员及以上权限\\n\"\n                      \"状态查看：普通权限\",\n        \"Keep_On\": True,\n        \"Type\": \"Admin_Plugin\",\n    },\n)\n\n# 初始化\npluginsManager.LoadConfig()\nlogger.success(\"插件开关配置成功加载\")\n\n# 群组插件开关\ngroupPluginSwitch = on_regex(r\"(^#群组开启插件)|(^#群组关闭插件)\", priority=Priority.系统优先级,\n                             permission=HIYORI_OWNER | GROUP_OWNER | GROUP_ADMIN | HIYORI_ADMIN,\n                             block=True)\n# 个人插件开关\nuserPluginSwitch = on_regex(r\"(^#个人开启插件)|(^#个人关闭插件)\", priority=Priority.系统优先级,\n                            block=True)\n# 群组插件状态查询\ngroupPluginStatus = on_regex(r\"^#群组插件状态$\", priority=Priority.系统优先级, block=True)\n# 个人插件状态查询\nuserPluginStatus = on_regex(r\"^#个人插件状态$\", priority=Priority.系统优先级, block=True)\n# 群组开启黑/白名单\ngroupPluginWhiteList = on_regex(r\"(^#群组插件白名单模式$)|(^#群组插件黑名单模式$)\", priority=Priority.系统优先级,\n                                permission=HIYORI_OWNER | GROUP_OWNER | GROUP_ADMIN | HIYORI_ADMIN,\n                                block=True)\n# 个人开启黑/白名单\nuserPluginWhiteList = on_regex(r\"(^#个人插件白名单模式$)|(^#个人插件黑名单模式$)\", priority=Priority.系统优先级,\n                               block=True)\n\n\n# 群组插件开关\n@groupPluginSwitch.handle()\nasync def _(event: GroupMessageEvent):\n    plugins = get_loaded_plugins()\n    message = str(event.message)\n    GroupID = str(event.group_id)\n    if re.match(\"^#群组开启插件\", message):\n        Type = True\n    else:\n        Type = False\n    message = re.sub(r\"(^#群组开启插件)|(^#群组关闭插件)\", \"\", message).lstrip()\n    for plugin in plugins:\n        if hasattr(plugin.metadata, \"name\"):\n            if message == plugin.metadata.name:\n                if hasattr(plugin.metadata, \"extra\"):\n                    extra = plugin.metadata.extra\n                    if \"Keep_On\" in extra.keys():\n                        if extra[\"Keep_On\"]:\n                            await userPluginSwitch.send(\"插件无法关闭\")\n                            return\n                await pluginsManager.ChangeGroupPluginStatus(GroupID, message, Type)\n                await groupPluginSwitch.send(f\"插件【{message}】群组状态修改成功\")\n                return\n    await groupPluginSwitch.send(f\"未找到插件【{message}】\")\n\n\n# 个人插件开关\n@userPluginSwitch.handle()\nasync def _(event: MessageEvent):\n    plugins = get_loaded_plugins()\n    message = str(event.message)\n    QQ = str(event.user_id)\n    if re.match(\"^#个人开启插件\", message):\n        Type = True\n    else:\n        Type = False\n    message = re.sub(r\"(^#个人开启插件)|(^#个人关闭插件)\", \"\", message).lstrip()\n    for plugin in plugins:\n        if hasattr(plugin.metadata, \"name\"):\n            if message == plugin.metadata.name:\n                if hasattr(plugin.metadata, \"extra\"):\n                    extra = plugin.metadata.extra\n                    if \"Keep_On\" in extra.keys():\n                        if extra[\"Keep_On\"]:\n                            await userPluginSwitch.send(\"插件无法关闭\")\n                            return\n                await pluginsManager.ChangeUserPluginStatus(QQ, message, Type)\n                await userPluginSwitch.send(f\"插件【{message}】个人状态修改成功\")\n                return\n    await userPluginSwitch.send(f\"未找到插件【{message}】\")\n\n\n# 群组插件状态查询\n@groupPluginStatus.handle()\nasync def _(event: GroupMessageEvent):\n    GroupID = str(event.group_id)\n    message = \"## 群组插件状态\"\n    # 白名单模式\n    if pluginsManager.GroupWhiteListStatus(GroupID):\n        message = message + \"   `白名单模式`\\n\"\n        plugins = pluginsManager.GetGroupOnPlugins(GroupID)\n        if len(plugins) == 0:\n            message = message + \"**本群暂无开启插件**\"\n        else:\n            message = message + \"已开启插件:  \\n\\n\"\n            for plugin in plugins:\n                message = message + f\"+ {plugin}\\n\"\n    else:\n        message = message + \"   `黑名单模式`\\n\"\n        plugins = pluginsManager.GetGroupOffPlugins(GroupID)\n        if len(plugins) == 0:\n            message = message + \"**本群暂无关闭插件**\"\n        else:\n            message = message + \"已关闭插件:  \\n\\n\"\n            for plugin in plugins:\n                message = message + f\"+ {plugin}\\n\"\n    pic = await md_to_pic(md=message)\n    await groupPluginStatus.send(MessageSegment.image(pic))\n\n\n# 个人插件状态查询\n@userPluginStatus.handle()\nasync def _(event: MessageEvent):\n    QQ = str(event.user_id)\n    message = \"## 个人插件状态\"\n    # 白名单模式\n    if pluginsManager.UserWhiteListStatus(QQ):\n        message = message + \"   `白名单模式`\\n\"\n        plugins = pluginsManager.GetUserOnPlugins(QQ)\n        if len(plugins) == 0:\n            message = message + \"**暂无开启插件**\"\n        else:\n            message = message + \"已开启插件:  \\n\\n\"\n            for plugin in plugins:\n                message = message + f\"+ {plugin}\\n\"\n    else:\n        message = message + \"   `黑名单模式`\\n\"\n        plugins = pluginsManager.GetUserOffPlugins(QQ)\n        if len(plugins) == 0:\n            message = message + \"**暂无关闭插件**\"\n        else:\n            message = message + \"已关闭插件:  \\n\\n\"\n            for plugin in plugins:\n                message = message + f\"+ {plugin}\\n\"\n    pic = await md_to_pic(md=message)\n    await userPluginStatus.send(MessageSegment.image(pic))\n\n\n@groupPluginWhiteList.handle()\nasync def _(event: GroupMessageEvent):\n    GroupID = str(event.group_id)\n    message = str(event.message)\n    if message == \"#群组插件白名单模式\":\n        await pluginsManager.ChangeGroupPluginStatus(GroupID=GroupID, PluginName=\"WhiteList\", status=True)\n        await groupPluginWhiteList.send(\"群组插件响应已修改为白名单模式\")\n    else:\n        await pluginsManager.ChangeGroupPluginStatus(GroupID=GroupID, PluginName=\"WhiteList\", status=False)\n        await groupPluginWhiteList.send(\"群组插件响应已修改为黑名单模式\")\n\n\n@userPluginWhiteList.handle()\nasync def _(event: MessageEvent):\n    QQ = str(event.user_id)\n    message = str(event.message)\n    if message == \"#个人插件白名单模式\":\n        await pluginsManager.ChangeUserPluginStatus(QQ=QQ, PluginName=\"WhiteList\", status=True)\n        await groupPluginWhiteList.send(\"个人插件响应已修改为白名单模式\")\n    else:\n        await pluginsManager.ChangeUserPluginStatus(QQ=QQ, PluginName=\"WhiteList\", status=False)\n        await groupPluginWhiteList.send(\"个人插件响应已修改为黑名单模式\")\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Broadcast/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:30\n@Desc: 广播插件\n@Ver : 1.0.0\n\"\"\"\nimport time\nimport asyncio\nfrom Hiyori.Utils.Database import DB_User\nfrom Hiyori.Utils.Permissions import HIYORI_OWNER\nfrom Hiyori.Utils.Priority import Priority\nfrom Hiyori.Plugins.Basic_plugins.MultiBot_Support import getBot\nfrom nonebot.permission import SUPERUSER\nfrom nonebot.adapters.onebot.v11 import Bot, MessageEvent, ActionFailed\nfrom nonebot import on_regex\nfrom nonebot.log import logger\nimport re\n\nbroadcast = on_regex(r\"^#broadcast\", permission=SUPERUSER | HIYORI_OWNER, priority=Priority.系统优先级, block=True)\n\n\n@broadcast.handle()\nasync def _(event: MessageEvent):\n    startTime = time.time_ns()\n    # 获取对应广播信息\n    message = str(event.message)\n    message = re.sub(r\"^#broadcast\", \"\", message).lstrip()\n    GroupsDict = DB_User.getAllGroups()\n    for Group in GroupsDict.values():\n        # 群组状态为关闭\n        if Group.Permission == 3:\n            continue\n        else:\n            # 群组需要有效\n            try:\n                bot = getBot(Group)\n                await bot.call_api(\"send_group_msg\", **{\"group_id\": Group.GroupID, \"message\": message})\n                await asyncio.sleep(1)\n            except ActionFailed:\n                logger.error(f\"群组{Group.GroupID}发送消息失败\")\n                continue\n\n    endTime = time.time_ns()\n    Time = (endTime - startTime)/1000000000\n    await broadcast.send(f\"消息已广播完毕, 用时{Time:.3f}s\")\n\n\n"}
{"type": "source_file", "path": "Hiyori/Plugins/AI_plugins/novelai/__init__.py", "content": "\"\"\"\n@Author: Ame lian\n@Github: https://github.com/AmeNeri\n@Date: 2023/7/31-21:53\n@Desc: \n@Ver : 1.0.0\n\"\"\"\nfrom nonebot.plugin import on_command\nfrom nonebot.plugin import PluginMetadata\nfrom nonebot.adapters.onebot.v11 import MessageEvent, MessageSegment\nfrom Hiyori.Utils.Priority import Priority\nimport requests\nimport json\nimport random\nimport time\n\n__novelai_version__ = \"0.1.0\"\n__novelai_usages__ = f\"\"\"\n[#二次元的我] 康康你的二次元形象\n\"\"\".strip()\n\n__plugin_meta__ = PluginMetadata(\n    name=\"二次元的我\",\n    description=\"康康你的二次元形象\",\n    usage=__novelai_usages__,\n    type=\"application\",\n    extra={\n        \"version\": __novelai_version__,\n        \"CD_Weight\": 2,\n        \"example\": \"二次元的我\",\n        \"permission\": \"普通权限\",\n        \"Keep_On\": False,\n        \"Type\": \"Zao_plugin\",\n    },\n)\n\n\nsearch = on_command(\"二次元的我\", block=True, priority=Priority.普通优先级)\n\nwith open(f\"./Data/Novelai/tag_data.json\",encoding=\"utf-8\") as f: #初始化tags\n    tag_data = json.load(f)\ntags_id = [\"优秀实践\",\"风格\",\"头发\",\"发色\",\"衣服\",\"鞋子\",\"装饰\",\"胸\",\"类型\",\"身份\",\"表情\",\"二次元\",\"基础动作\",\"手动作\",\"腿动作\",\"复合动作\",\"露出\",\"场景\",\"物品\",\"天气\",\"环境\"]\ntags = \"{{highly detailed}},{{masterpiece}},{ultra-detailed},{illustration},{{1girl}},{{best quality}}\" #正面默认tags\nntags = \"lowres,bad anatomy,bad hands,text,error,missing fingers,extra digit,fewer digits,cropped,worst quality,low quality,normal quality,jpeg artifacts,signature,watermark,username,blurry,missing arms,long neck,Humpbacked\"\n\n\nasync def be_girl(uid):\n    tags = \"\"\n    goal_tag = {}\n    uid = int(uid)\n    random.seed(uid * (int(time.time()/3600/24)))\n    for i in tags_id:\n        tag_list = []\n        for j in tag_data[i]:\n            tag_list.append(j)\n        goal_tag[i] = random.choice(tag_list)\n    for i in goal_tag:\n        tags += \",\" + tag_data[i][goal_tag[i]]\n    msg = f'头发是{goal_tag[\"发色\"]}{goal_tag[\"头发\"]},胸部{goal_tag[\"胸\"]},穿着{goal_tag[\"衣服\"]},{goal_tag[\"鞋子\"]},{goal_tag[\"装饰\"]},萌点是{goal_tag[\"二次元\"]},身份是{goal_tag[\"身份\"]}{goal_tag[\"类型\"]}'\n    return msg,tags\n@search.handle()\nasync def _(event: MessageEvent):\n    uid = event.user_id\n    url = \"http://liuliying.cn:6633/api/novelai\"\n    width = \"512\"\n    height = \"768\"\n    msg, prompt = await be_girl(uid)\n    try:\n        resimg = requests.get(f\"{url}?width={width}&height={height}&prompt={prompt}&seed=-1&negative={ntags}&draw_type=txt\").json()[\"url\"]\n        msg = f\"二次元少女的你今天,{msg}\"\n        message = msg + MessageSegment.image(resimg)\n    except:\n        message = \"接往二次元世界的大门打开失败了喵\"\n    await search.send(message)\n\n\n\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Function_CD/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:32\n@Desc: 调用冷却插件\n@Ver : 1.0.0\n\"\"\"\nfrom .hook import 功能调用CD检查\nfrom nonebot.adapters.onebot.v11 import Event, Bot\nfrom Hiyori.Utils.Permissions import HIYORI_OWNER\nfrom nonebot.permission import SUPERUSER\nfrom nonebot import on_regex\nfrom Hiyori.Utils.Database import DB_User\nfrom Hiyori.Utils.Priority import Priority\nimport re\nfrom nonebot.plugin import PluginMetadata\n\n__plugin_meta__ = PluginMetadata(\n    name=\"响应冷却\",\n    description=\"每次功能调用时触发所在群以及调用者的功能调用权重累积，超限后停止响应。\",\n    usage=\"功能调用时自动触发\\n\"\n          \"用户默认权重为10/分钟，群组默认权重为30/分钟，统计周期为5分钟。\",\n    extra={\n        \"example\": \"\",\n        \"Keep_On\": True,\n        \"Type\": \"Auto_Plugin\",\n    },\n)\n\nchangeCD = on_regex(r\"(^#?change\\s+cd)|(^#?CD修改)|(^#?cd修改)\", priority=Priority.系统优先级, block=True,\n                    permission=HIYORI_OWNER | SUPERUSER)\n\n\n@changeCD.handle()\nasync def _(bot: Bot, event: Event):\n    # 指令处理解析\n    message = str(event.message)\n    message = re.sub(r\"(^#?change\\s+(cd)|(CD))|(^#?CD修改)|(^#?cd修改)\", \"\", message).lstrip()\n    # 模式匹配\n    # -u指令 修改用户CD\n    if message.startswith(\"-u\") or message.startswith(\"-U\"):\n        message = re.sub(r\"(^-u)|(^-U)\", \"\", message).lstrip()\n        # CQ码去除\n        if message.startswith(\"[CQ:at,qq=\"):\n            message = message.replace(\"[CQ:at,qq=\", \"\").lstrip()\n            message = message.replace(\"]\", \"\").lstrip()\n        # 检查输入格式是否正确\n        msgs = message.split(\" \")\n        # isdigit已经包含了不为负数的隐藏条件\n        if len(msgs) == 2 and msgs[0].isdigit() and msgs[1].isdigit():\n            QQ = int(msgs[0])\n            CD = int(msgs[1])\n            # 若未查询到用户，则会先刷新一遍\n            if not DB_User.hasUser(QQ):\n                await DB_User.refreshAll()\n                if not DB_User.hasUser(QQ):\n                    await changeCD.send(\"用户不存在\")\n                    return\n            User = DB_User.getUser(QQ)\n            LastCD = User.CD\n            User.CD = CD\n            DB_User.updateUser(User)\n            await changeCD.send(\"用户 {} 功能调用权重上限: {} → {}\".format(User.Name, LastCD, CD))\n        else:\n            await changeCD.send(\"QQ号或者CD格式不正确，或者不存在对应用户\")\n    # -g指令 修改群组CD\n    elif message.startswith(\"-g\") or message.startswith(\"-G\"):\n        message = re.sub(r\"(^-g)|(^-G)\", \"\", message).lstrip()\n        msgs = message.split(\" \")\n        # 直接修改所在群组\n        # isdigit已经包含了不为负数的隐藏条件\n        if len(msgs) == 1 and msgs[0].isdigit() and hasattr(event, \"group_id\"):\n            GroupID = event.group_id\n            CD = int(msgs[0])\n            Group = DB_User.getGroup(GroupID)\n            LastCD = Group.CD\n            Group.CD = CD\n            DB_User.updateGroup(Group)\n            await changeCD.send(\"群组 {} 功能调用权重上限: {} → {}\".format(Group.GroupName, LastCD, CD))\n        # 修改指定群组\n        # isdigit已经包含了不为负数的隐藏条件\n        elif len(msgs) == 2 and msgs[0].isdigit() and msgs[1].isdigit():\n            GroupID = int(msgs[0])\n            CD = int(msgs[1])\n            # 检查群组是否存在，不存在则先刷新一次，再检测:\n            if not DB_User.hasGroup(GroupID):\n                await DB_User.refreshAll()\n                if not DB_User.hasGroup(GroupID):\n                    await changeCD.send(\"群组不存在\")\n                    return\n            Group = DB_User.getGroup(GroupID)\n            LastCD = Group.CD\n            Group.CD = CD\n            DB_User.updateGroup(Group)\n            await changeCD.send(\"群组 {} 功能调用权重上限: {} → {}\".format(Group.GroupName, LastCD, CD))\n        else:\n            await changeCD.send(\"群号或者CD格式不正确，或者不存在对应群聊\")\n\n"}
{"type": "source_file", "path": "Hiyori/Plugins/AI_plugins/ai/__init__.py", "content": "\"\"\"\n@Author: Ame lian\n@Github: https://github.com/AmeNeri\n@Date: 2023/8/7-12:10\n@Desc: \n@Ver : 1.0.0\n\"\"\"\nfrom typing import List\n\nfrom nonebot import on_message\nfrom nonebot.adapters.onebot.v11 import Bot, GroupMessageEvent, Message, MessageEvent\nfrom nonebot.rule import to_me\n\nfrom .config import TEXT_FILTER\nfrom Hiyori.Utils.Message.Image import get_message_img\nfrom Hiyori.Utils.Message.Text import get_message_text\nfrom Hiyori.Utils.Database import DB_User\n\nfrom .data_source import get_chat_result, hello, no_result\n\nai = on_message(rule=to_me(), priority=998)\n\n\n@ai.handle()\nasync def _(bot: Bot, event: MessageEvent):\n    User = DB_User.getUser(QQ=event.user_id)\n    nickname = User.NickName\n    msg = get_message_text(event.json())\n    img = get_message_img(event.json())\n    if \"CQ:xml\" in str(event.get_message()):\n        return\n    # 打招呼\n    if (not msg and not img) or msg in [\n        \"你好啊\",\n        \"你好\",\n        \"在吗\",\n        \"在不在\",\n        \"您好\",\n        \"您好啊\",\n        \"你好\",\n        \"在\",\n    ]:\n        await ai.finish(hello())\n    img = img[0] if img else \"\"\n    if not nickname:\n        if isinstance(event, GroupMessageEvent):\n            nickname = event.sender.card or event.sender.nickname\n        else:\n            nickname = event.sender.nickname\n    result = await get_chat_result(msg, img, event.user_id, nickname)\n    print(\n        f\"USER {event.user_id} GROUP {event.group_id if isinstance(event, GroupMessageEvent) else ''} \"\n        f\"问题：{msg} ---- 回答：{result}\"\n    )\n    if result:\n        result = str(result)\n        for t in TEXT_FILTER:\n            result = result.replace(t, \"*\")\n        await ai.finish(Message(result))\n    else:\n        await ai.finish(no_result())\n"}
{"type": "source_file", "path": "Hiyori/Plugins/AI_plugins/Vits/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/09/28-15:08\n@Desc: vits/bert-vits2 插件\n@Ver : 1.0.0\n\"\"\"\nimport re\n\nfrom nonebot import on_regex\nfrom nonebot.plugin import PluginMetadata\nfrom nonebot.adapters.onebot.v11 import MessageEvent, MessageSegment\n\nfrom Hiyori.Plugins.Basic_plugins.nonebot_plugin_htmlrender import md_to_pic\nfrom Hiyori.Utils.Priority import Priority\nimport Hiyori.Utils.API.BertVits as BertVits\nimport Hiyori.Utils.API.Vits as Vits\n\nfrom .rule import vitsCheck\n\n__plugin_meta__ = PluginMetadata(\n    name=\"老婆语音\",\n    description=\"Vits语音合成，让妃爱学你的老婆说话吧！\",\n    usage=\"xx说[要说的话] \\n详细的人物列表请调用指令#老婆语音列表 来查看\",\n    extra={\n        \"CD_Weight\": 2,\n        \"permission\": \"普通权限\",\n        \"example\": \"\",\n        \"Keep_On\": False,\n        \"Type\": \"Normal_Plugin\",\n    },\n)\n\nbertMap = BertVits.getBV_Map()\nvitsMap = Vits.getVits_Map()\nbertModels = BertVits.getModelsConfig()\nvitsModels = Vits.getModelsConfig()\nvitsModelsInfo: dict[str, list[str]] = dict()\nbertModelsInfo: dict[str, list[str]] = dict()\n\nfor model in bertModels:\n    if model[\"names\"][0] not in bertModelsInfo.keys():\n        bertModelsInfo[model[\"names\"][0]] = list(model[\"spk2id\"])\n    else:\n        bertModelsInfo[model[\"names\"][0]] += list(model[\"spk2id\"])\n\nfor model in vitsModels:\n    if model[\"names\"][0] not in vitsModelsInfo.keys():\n        vitsModelsInfo[model[\"names\"][0]] = list(model[\"spk2id\"])\n    else:\n        vitsModelsInfo[model[\"names\"][0]] += list(model[\"spk2id\"])\n\nvitsSound = on_regex(pattern=r\"#?.+说\", priority=Priority.普通优先级, block=False, rule=vitsCheck)\nhelpMenu = on_regex(r\"^#?老婆语音列表$\", priority=Priority.高优先级, block=True)\n\n\n@vitsSound.handle()\nasync def _(event: MessageEvent):\n    msg = event.message.extract_plain_text()\n    text = msg.split(\"说\", maxsplit=1)[1]\n    if text == \"\":\n        return\n    msg = re.match(pattern=r\"#?.+说\", string=msg)\n    if msg is None:\n        return\n    name = msg.group().split(\"说\")[0].lstrip(\"#\").strip()\n    # 优先使用bert模型\n    if name in bertMap.keys():\n        audio = await BertVits.getVoice(text=text, model=bertMap[name][\"mid\"], character=bertMap[name][\"cid\"])\n        await vitsSound.send(MessageSegment.record(audio))\n        return\n    if name in vitsMap.keys():\n        audio = await Vits.getVoice(text=text, model=vitsMap[name][\"mid\"], character=vitsMap[name][\"cid\"])\n        await vitsSound.send(MessageSegment.record(audio))\n\n\n@helpMenu.handle()\nasync def _(event: MessageEvent):\n    mdContent = \"# 老婆语音列表  \\n\"\n    mdContent += \"## 一.Vits模型  \\n\"\n    for name, characters in vitsModelsInfo.items():\n        mdContent += f\"### {name}  \\n\\n\"\n        mdContent += \", \".join(characters)\n        mdContent += \"\\n---\\n\"\n    mdContent += \"\\n## 二.bertVits2模型  \\n\"\n    for name, characters in bertModelsInfo.items():\n        if name == \"崩原\":\n            continue\n        mdContent += f\"### {name}  \\n\\n\"\n        mdContent += \", \".join(characters)\n        mdContent += \"\\n---\\n\"\n    image = await md_to_pic(md=mdContent, width=1200)\n    await helpMenu.send(MessageSegment.image(image))\n"}
{"type": "source_file", "path": "Hiyori/Plugins/AI_plugins/ai/utils.py", "content": "from .data_class import StaticData\nfrom .config import NICKNAME\nfrom typing import Optional\nimport random\nimport time\n\n\nclass AiMessageManager(StaticData):\n    def __init__(self):\n        super().__init__(None)\n        self._same_message = [\n            \"为什么要发一样的话？\",\n            \"请不要再重复对我说一句话了，不然我就要生气了！\",\n            \"别再发这句话了，我已经知道了...\",\n            \"你是只会说这一句话吗？\",\n            \"[*]，你发我也发！\",\n            \"[uname]，[*]\",\n            f\"救命！有笨蛋一直给{NICKNAME}发一样的话！\",\n            \"这句话你已经给我发了{}次了，再发就生气！\",\n        ]\n        self._repeat_message = [\n            f\"请不要学{NICKNAME}说话\",\n            f\"为什么要一直学{NICKNAME}说话？\",\n            \"你再学！你再学我就生气了！\",\n            f\"呜呜，你是想欺负{NICKNAME}嘛..\",\n            \"[uname]不要再学我说话了！\",\n            \"再学我说话，我就把你拉进黑名单（生气\",\n            \"你再学！[uname]是个笨蛋！\",\n            \"你已经学我说话{}次了！别再学了！\",\n        ]\n\n    def add_message(self, user_id: int, message: str):\n        \"\"\"\n        添加用户消息\n        :param user_id: 用户id\n        :param message: 消息内容\n        \"\"\"\n        if message:\n            if self._data.get(user_id) is None:\n                self._data[user_id] = {\n                    \"time\": time.time(),\n                    \"message\": [],\n                    \"result\": [],\n                    \"repeat_count\": 0,\n                }\n            if time.time() - self._data[user_id][\"time\"] > 60 * 10:\n                self._data[user_id][\"message\"].clear()\n            self._data[user_id][\"time\"] = time.time()\n            self._data[user_id][\"message\"].append(message.strip())\n\n    def add_result(self, user_id: int, message: str):\n        \"\"\"\n        添加回复用户的消息\n        :param user_id: 用户id\n        :param message: 回复消息内容\n        \"\"\"\n        if message:\n            if self._data.get(user_id) is None:\n                self._data[user_id] = {\n                    \"time\": time.time(),\n                    \"message\": [],\n                    \"result\": [],\n                    \"repeat_count\": 0,\n                }\n            if time.time() - self._data[user_id][\"time\"] > 60 * 10:\n                self._data[user_id][\"result\"].clear()\n                self._data[user_id][\"repeat_count\"] = 0\n            self._data[user_id][\"time\"] = time.time()\n            self._data[user_id][\"result\"].append(message.strip())\n\n    async def get_result(self, user_id: int, nickname: str) -> Optional[str]:\n        \"\"\"\n        特殊消息特殊回复\n        :param user_id: 用户id\n        :param nickname: 用户昵称\n        \"\"\"\n        try:\n            if len(self._data[user_id][\"message\"]) < 2:\n                return None\n        except KeyError:\n            return None\n        msg = await self._get_user_repeat_message_result(user_id)\n        if not msg:\n            msg = await self._get_user_same_message_result(user_id)\n        if msg:\n            if \"[uname]\" in msg:\n                msg = msg.replace(\"[uname]\", nickname)\n            if not msg.startswith(\"生气了！你好烦，闭嘴！\") and \"[*]\" in msg:\n                msg = msg.replace(\"[*]\", self._data[user_id][\"message\"][-1])\n        return msg\n\n    async def _get_user_same_message_result(self, user_id: int) -> Optional[str]:\n        \"\"\"\n        重复消息回复\n        :param user_id: 用户id\n        \"\"\"\n        msg = self._data[user_id][\"message\"][-1]\n        cnt = 0\n        _tmp = self._data[user_id][\"message\"][:-1]\n        _tmp.reverse()\n        for s in _tmp:\n            if s == msg:\n                cnt += 1\n            else:\n                break\n        if cnt > 1:\n            if random.random() < 0.5 and cnt > 3:\n                return f\"生气了！你好烦，给我闭嘴！\"\n            return random.choice(self._same_message).format(cnt)\n        return None\n\n    async def _get_user_repeat_message_result(self, user_id: int) -> Optional[str]:\n        \"\"\"\n        复读消息回复\n        :param user_id: 用户id\n        \"\"\"\n        msg = self._data[user_id][\"message\"][-1]\n        if self._data[user_id][\"result\"]:\n            rst = self._data[user_id][\"result\"][-1]\n        else:\n            return None\n        if msg == rst:\n            self._data[user_id][\"repeat_count\"] += 1\n            cnt = self._data[user_id][\"repeat_count\"]\n            if cnt > 1:\n                if random.random() < 0.5 and cnt > 3:\n                    return f\"生气了！你好烦，给我闭嘴\"\n                return random.choice(self._repeat_message).format(cnt)\n        return None\n\n\n\nai_message_manager = AiMessageManager()\n"}
{"type": "source_file", "path": "Hiyori/Plugins/AI_plugins/ai/data_source.py", "content": "import os\nimport random\nimport re\n\nfrom .config import NICKNAME, DATA_PATH, TL_KEY, ALAPI_TOKEN, IMAGE_PATH, ALAPI_AI_CHECK\nfrom Hiyori.Utils.Spider.Http import AsyncHttpx\nfrom Hiyori.Utils.Message.Image import face, ImageMessage\n\nfrom .utils import ai_message_manager\n\ntry:\n    import ujson as json\nexcept ModuleNotFoundError:\n    import json\n\n\nurl = \"http://openapi.tuling123.com/openapi/api/v2\"\n\ncheck_url = \"https://v2.alapi.cn/api/censor/text\"\n\nindex = 0\n\nHiyori_data = json.load(open(DATA_PATH / \"Hiyori.json\", \"r\", encoding=\"utf8\"))\n\n\nasync def get_chat_result(text: str, img_url: str, user_id: int, nickname: str) -> str:\n    \"\"\"\n    获取 AI 返回值，顺序： 特殊回复 -> 图灵 -> 青云客\n    :param text: 问题\n    :param img_url: 图片链接\n    :param user_id: 用户id\n    :param nickname: 用户昵称\n    :return: 回答\n    \"\"\"\n    global index\n    ai_message_manager.add_message(user_id, text)\n    special_rst = await ai_message_manager.get_result(user_id, nickname)\n    if special_rst:\n        ai_message_manager.add_result(user_id, special_rst)\n        return special_rst\n    if index == 5:\n        index = 0\n    if len(text) < 6 and random.random() < 0.6:\n        keys = Hiyori_data.keys()\n        for key in keys:\n            if text.find(key) != -1:\n                return random.choice(Hiyori_data[key]).replace(\"你\", nickname)\n    rst = await tu_ling(text, img_url, user_id)\n    if not rst:\n        rst = await xie_ai(text)\n    if not rst:\n        return no_result()\n    if nickname:\n        if len(nickname) < 5:\n            if random.random() < 0.5:\n                nickname = \"~\".join(nickname) + \"~\"\n                if random.random() < 0.2:\n                    if nickname.find(\"大人\") == -1:\n                        nickname += \"大~人~\"\n        rst = str(rst).replace(\"小主人\", nickname).replace(\"小朋友\", nickname)\n    ai_message_manager.add_result(user_id, rst)\n    return rst\n\n\n# 图灵接口\nasync def tu_ling(text: str, img_url: str, user_id: int) -> str:\n    \"\"\"\n    获取图灵接口的回复\n    :param text: 问题\n    :param img_url: 图片链接\n    :param user_id: 用户id\n    :return: 图灵回复\n    \"\"\"\n    global index\n    req = None\n    if not TL_KEY:\n        return \"\"\n    try:\n        if text:\n            req = {\n                \"perception\": {\n                    \"inputText\": {\"text\": text},\n                    \"selfInfo\": {\n                        \"location\": {\"city\": \"陨石坑\", \"province\": \"火星\", \"street\": \"第5坑位\"}\n                    },\n                },\n                \"userInfo\": {\"apiKey\": TL_KEY[index], \"userId\": str(user_id)},\n            }\n        elif img_url:\n            req = {\n                \"reqType\": 1,\n                \"perception\": {\n                    \"inputImage\": {\"url\": img_url},\n                    \"selfInfo\": {\n                        \"location\": {\"city\": \"陨石坑\", \"province\": \"火星\", \"street\": \"第5坑位\"}\n                    },\n                },\n                \"userInfo\": {\"apiKey\": TL_KEY[index], \"userId\": str(user_id)},\n            }\n    except IndexError:\n        index = 0\n        return \"\"\n    text = \"\"\n    response = await AsyncHttpx.post(url, json=req)\n    if response.status_code != 200:\n        return no_result()\n    resp_payload = json.loads(response.text)\n    if int(resp_payload[\"intent\"][\"code\"]) in [4003]:\n        return \"\"\n    if resp_payload[\"results\"]:\n        for result in resp_payload[\"results\"]:\n            if result[\"resultType\"] == \"text\":\n                text = result[\"values\"][\"text\"]\n                if \"请求次数超过\" in text:\n                    text = \"\"\n    return text\n\n\n# 屑 AI\nasync def xie_ai(text: str) -> str:\n    \"\"\"\n    获取青云客回复\n    :param text: 问题\n    :return: 青云可回复\n    \"\"\"\n    res = await AsyncHttpx.get(\n        f\"http://api.qingyunke.com/api.php?key=free&appid=0&msg={text}\"\n    )\n    content = \"\"\n    try:\n        data = json.loads(res.text)\n        if data[\"result\"] == 0:\n            content = data[\"content\"]\n            if \"菲菲\" in content:\n                content = content.replace(\"菲菲\", NICKNAME)\n            if \"艳儿\" in content:\n                content = content.replace(\"艳儿\", NICKNAME)\n            if \"公众号\" in content:\n                content = \"\"\n            if \"{br}\" in content:\n                content = content.replace(\"{br}\", \"\\n\")\n            if \"提示\" in content:\n                content = content[: content.find(\"提示\")]\n            if \"淘宝\" in content or \"taobao.com\" in content:\n                return \"\"\n            while True:\n                r = re.search(\"{face:(.*)}\", content)\n                if r:\n                    id_ = r.group(1)\n                    content = content.replace(\n                        \"{\" + f\"face:{id_}\" + \"}\", str(face(int(id_)))\n                    )\n                else:\n                    break\n        return (\n            content\n            if not content and ALAPI_AI_CHECK is False\n            else await check_text(content)\n        )\n    except Exception as e:\n        print(f\"Ai xie_ai 发生错误 {type(e)}：{e}\")\n        return \"\"\n\n\ndef hello() -> str:\n    \"\"\"\n    一些打招呼的内容\n    \"\"\"\n    result = random.choice(\n        (\n            \"你好Ov<\",\n            \"你好喵~\",\n        )\n    )\n    result += ImageMessage(IMAGE_PATH / \"hellp.png\")\n    return result\n\n\n# 没有回答时回复内容\ndef no_result() -> str:\n    \"\"\"\n    没有回答时的回复\n    \"\"\"\n    return random.choice(\n        [\n            f\"纯洁的{NICKNAME}没听懂\",\n            \"下次再告诉你喵~\",\n            \"我！不！知！道！\",\n        ]\n    )\n\n\nasync def check_text(text: str) -> str:\n    \"\"\"\n    ALAPI文本检测，主要针对青云客API，检测为恶俗文本改为无回复的回答\n    :param text: 回复\n    \"\"\"\n    if not ALAPI_TOKEN:\n        return text\n    params = {\"token\": ALAPI_TOKEN, \"text\": text}\n    try:\n        data = (await AsyncHttpx.get(check_url, timeout=2, params=params)).json()\n        if data[\"code\"] == 200:\n            if data[\"data\"][\"conclusion_type\"] == 2:\n                return \"\"\n    except Exception as e:\n        print(f\"检测违规文本错误...{type(e)}：{e}\")\n    return text\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-22:25\n@Desc: \n@Ver : 1.0.0\n\"\"\"\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Menu/api.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/7/3-15:59\n@Desc: Menu API调用，获取插件信息，以及插件当前状态\n@Ver : 1.0.0\n\"\"\"\nfrom nonebot import get_asgi\nfrom fastapi.responses import JSONResponse\nfrom nonebot.plugin import _plugins\n\napp = get_asgi()\n\n\n@app.get(\"/Plugins/Basic_plugins/Menu/Plugin_info\", response_class=JSONResponse)\nasync def _():\n    results = []\n    plugins = list(_plugins.values())\n    for plugin in plugins:\n        result = {}\n        if hasattr(plugin, \"metadata\"):\n            data = plugin.metadata\n            if hasattr(data, \"extra\"):\n                result[\"extra\"] = data.extra\n            if hasattr(data, \"name\"):\n                result[\"name\"] = data.name\n            if hasattr(data, \"description\"):\n                result[\"description\"] = data.description\n                result[\"descriptions\"] = [des for des in data.description.split(\"\\n\") if des.strip() != \"\"]\n            if hasattr(data, \"usage\"):\n                result[\"usage\"] = data.usage\n                # 去除空格\n                result[\"usages\"] = [use for use in data.usage.split(\"\\n\") if use.strip() != \"\"]\n            if len(result):\n                results.append(result)\n    return results\n\n\n\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Plugin_Manager/hook.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:35\n@Desc: \n@Ver : 1.0.0\n\"\"\"\n\nfrom nonebot.message import run_preprocessor\nfrom nonebot.matcher import Matcher\nfrom nonebot.adapters.onebot.v11 import Event\nfrom nonebot.exception import IgnoredException\nfrom nonebot import get_driver\n\nfrom .pluginManager import pluginsManager\n\ndriver = get_driver()\n\n\n# 插件开关审核\n@run_preprocessor\nasync def check_group_plugin_status(matcher: Matcher, event: Event):\n    PluginInfo = matcher.plugin.metadata\n    # 没有则不做检查\n    if not hasattr(PluginInfo, \"name\"):\n        return\n    PluginName = PluginInfo.name\n    # 检查是否常驻开启\n    if hasattr(PluginInfo, \"extra\"):\n        extraInfo = PluginInfo.extra\n        if \"Keep_On\" in extraInfo.keys():\n            # 常开插件\n            if extraInfo[\"Keep_On\"]:\n                return\n    # 检查群组状态\n    if hasattr(event, \"group_id\"):\n        GroupID = str(event.group_id)\n        if not pluginsManager.GroupPluginIsOn(GroupID, PluginName):\n            raise IgnoredException(\"群插件已关闭\")\n    # 检查个人状态\n    if hasattr(event, \"user_id\"):\n        QQ = str(event.user_id)\n        if not pluginsManager.UserPluginIsOn(QQ, PluginName):\n            raise IgnoredException(\"个人插件已关闭\")\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/db.py", "content": "\"\"\" 数据库 \"\"\"\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, AsyncGenerator, Callable, Dict, List\n\nfrom nonebot import get_driver\nfrom nonebot.log import logger\nfrom nonebot.utils import is_coroutine_callable, run_sync\nfrom sqlalchemy.engine import make_url\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.ext.asyncio.session import AsyncSession\n\nfrom .config import plugin_config\nfrom .utils import get_caller_plugin_name\n\nif TYPE_CHECKING:\n    from sqlalchemy.ext.asyncio.engine import AsyncEngine\n\n\n_engine = None\n\n_pre_db_init_funcs: Dict[str, List] = {}\n_post_db_init_funcs = []\n\n\ndef _make_engine() -> \"AsyncEngine\":\n    \"\"\"创建数据库引擎\"\"\"\n    url = make_url(plugin_config.datastore_database_url)\n    if (\n        url.drivername.startswith(\"sqlite\")\n        and url.database is not None\n        and url.database not in [\":memory:\", \"\"]\n    ):\n        # 创建数据文件夹，防止数据库创建失败\n        database_path = Path(url.database)\n        database_path.parent.mkdir(parents=True, exist_ok=True)\n        logger.debug(f\"创建数据库文件夹: {database_path.parent}\")\n    # 创建数据库引擎\n    engine_options = {}\n    engine_options.update(plugin_config.datastore_engine_options)\n    engine_options.setdefault(\"echo\", plugin_config.datastore_database_echo)\n    engine_options.setdefault(\"echo_pool\", plugin_config.datastore_database_echo)\n    logger.debug(f\"数据库连接地址: {plugin_config.datastore_database_url}\")\n    logger.debug(f\"数据库引擎参数: {engine_options}\")\n    return create_async_engine(url, **engine_options)\n\n\ndef get_engine() -> \"AsyncEngine\":\n    if _engine is None:\n        raise ValueError(\"数据库未启用\")\n    return _engine\n\n\ndef pre_db_init(func: Callable) -> Callable:\n    \"\"\"数据库初始化前执行的函数\"\"\"\n    name = get_caller_plugin_name()\n    if name not in _pre_db_init_funcs:\n        _pre_db_init_funcs[name] = []\n    _pre_db_init_funcs[name].append(func)\n    return func\n\n\ndef post_db_init(func: Callable) -> Callable:\n    \"\"\"数据库初始化后执行的函数\"\"\"\n    _post_db_init_funcs.append(func)\n    return func\n\n\nasync def run_funcs(funcs: List[Callable]) -> None:\n    \"\"\"运行所有函数\"\"\"\n    for func in funcs:\n        if is_coroutine_callable(func):\n            await func()\n        else:\n            await run_sync(func)()\n\n\nasync def run_pre_db_init_funcs(plugin: str) -> None:\n    \"\"\"运行数据库初始化前执行的函数\"\"\"\n    funcs = _pre_db_init_funcs.get(plugin, [])\n    if funcs:\n        logger.debug(f\"运行插件 {plugin} 的数据库初始化前执行的函数\")\n        await run_funcs(funcs)\n\n\nasync def run_post_db_init_funcs() -> None:\n    \"\"\"运行数据库初始化后执行的函数\"\"\"\n    if _post_db_init_funcs:\n        logger.debug(\"运行数据库初始化后执行的函数\")\n        await run_funcs(_post_db_init_funcs)\n\n\nasync def init_db():\n    \"\"\"初始化数据库\"\"\"\n    from .script.command import upgrade\n    from .script.utils import Config, get_plugins\n\n    plugins = get_plugins()\n    for plugin in plugins:\n        # 执行数据库初始化前执行的函数\n        await run_pre_db_init_funcs(plugin)\n        # 初始化数据库，升级到最新版本\n        logger.debug(f\"初始化插件 {plugin} 的数据库\")\n        config = Config(plugin)\n        await upgrade(config, \"head\")\n\n    logger.info(\"数据库初始化完成\")\n\n    # 执行数据库初始化后执行的函数\n    try:\n        await run_post_db_init_funcs()\n    except Exception as e:\n        logger.error(f\"数据库初始化后执行的函数出错: {e}\")\n\n\nif plugin_config.datastore_enable_database:\n    _engine = _make_engine()\n    get_driver().on_startup(init_db)\n\n\nasync def get_session() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"需配合 `Depends` 使用\n\n    例: `session: AsyncSession = Depends(get_session)`\n    \"\"\"\n    async with AsyncSession(get_engine()) as session:\n        yield session\n\n\ndef create_session() -> AsyncSession:\n    \"\"\"创建一个新的 session\"\"\"\n    return AsyncSession(get_engine())\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Blacklist/hook.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:29\n@Desc: \n@Ver : 1.0.0\n\"\"\"\nfrom nonebot import get_driver\nfrom nonebot.message import event_preprocessor, run_preprocessor\nfrom nonebot.exception import IgnoredException\nfrom nonebot.matcher import Matcher\nfrom nonebot.adapters.onebot.v11 import Bot, Event\nfrom Hiyori.Utils.Database import DB_User\n\nconfig = get_driver().config\n\n\n# 黑名单审核\n@event_preprocessor\nasync def check_blacklist(bot: Bot, event: Event):\n    global config\n    if hasattr(event, \"user_id\"):\n        QQ = event.user_id\n        permission = DB_User.getUser(QQ).Permission\n        if permission == 3:\n            raise IgnoredException(\"用户黑名单屏蔽\")\n        # 对于主人和管理员发起的事件，无视黑名单审核\n        if permission in (0, 1) or str(QQ) in config.superusers:\n            if hasattr(event, \"group_id\"):\n                # 确保群聊存在\n                GroupID = event.group_id\n                DB_User.groupExist(GroupID)\n            return\n    if hasattr(event, \"group_id\"):\n        GroupID = event.group_id\n        permission = DB_User.getGroup(GroupID).Permission\n        if permission == 3:\n            raise IgnoredException(\"群黑名单屏蔽\")\n\n\n# 群开关审核\n@run_preprocessor\nasync def check_group_switch(matcher: Matcher, bot: Bot, event: Event):\n    global config\n    # 放行特殊插件\n    if matcher.plugin_name in (\"Database_Manager\", \"Blacklist\"):\n        return\n    if hasattr(event, \"user_id\"):\n        QQ = event.user_id\n        permission = DB_User.getUser(QQ).Permission\n        # 对于主人和管理员发起的事件，无视黑名单审核\n        if permission in (0, 1) or str(QQ) in config.superusers:\n            return\n    if hasattr(event, \"group_id\"):\n        GroupID = event.group_id\n        Status = DB_User.getGroup(GroupID).Status\n        if Status == \"off\":\n            raise IgnoredException(\"群开关关闭\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"type": "source_file", "path": "Hiyori/Plugins/AI_plugins/ai/config.py", "content": "\"\"\"\n@Author: Ame lian\n@Github: https://github.com/AmeNeri\n@Date: 2023/8/7-12:48\n@Desc: \n@Ver : 1.0.0\n\"\"\"\nfrom pathlib import Path\n\nTEXT_FILTER = [\"鸡\", \"口交\"]\nNICKNAME = [\"妃爱酱\"]\nDATA_PATH = Path() / \"Data\" / \"ai\"\nIMAGE_PATH = Path() / \"Data\" / \"ai\" / \"images\"\nTL_KEY = \"\"\n#通过https://saucenao.com/user.php?page=search-api注册以获取\nALAPI_TOKEN = \"\"\nALAPI_AI_CHECK = False"}
{"type": "source_file", "path": "Hiyori/Plugins/AI_plugins/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-22:25\n@Desc: \n@Ver : 1.0.0\n\"\"\"\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/MultiBot_Support/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/8/4-8:02\n@Desc: 多BOT连接支持插件：每个群聊最多仅有一个bot响应\n@Ver : 1.0.0\n\"\"\"\nfrom nonebot import on_regex, get_bot\nfrom nonebot.adapters.onebot.v11 import GroupMessageEvent, MessageSegment, Bot, Event\nfrom nonebot.permission import SUPERUSER\nfrom nonebot.message import handle_event\n\nfrom Hiyori.Utils.Priority import Priority\nfrom Hiyori.Utils.Permissions import HIYORI_OWNER\nfrom Hiyori.Utils.Message.At import GetAtQQs\nfrom Hiyori.Utils.API.QQ import GetQQStrangerName\n\nfrom .config import multiBotConfig\nfrom .hook import *\n\nHiyoriStart = on_regex(pattern=r\"妃爱启动\", permission=SUPERUSER | HIYORI_OWNER, priority=Priority.系统优先级)\nCheckStatus = on_regex(pattern=r\"^#?状态$\", permission=SUPERUSER, priority=Priority.系统优先级, block=False)\n\n\n@HiyoriStart.handle()\nasync def _(event: GroupMessageEvent):\n    message = str(event.message)\n    QQList = GetAtQQs(message)\n    if event.to_me:\n        QQList.append(event.self_id)\n    # 指令没艾特人\n    if len(QQList) == 0:\n        msg = MessageSegment.at(event.user_id) + \"请艾特需要启动的妃爱哦\"\n        await HiyoriStart.send(msg)\n        return\n    QQ = str(QQList[0])  # at中的第一个QQ\n    # 在响应序列中\n    if QQ in multiBotConfig.priority:\n        await HiyoriStart.send(\"妃爱，启动！\")\n        multiBotConfig.rule[str(event.group_id)] = QQ\n        multiBotConfig.dump()\n    else:\n        msg = MessageSegment.at(event.user_id) + \"你艾特的对象不是妃爱哦\"\n        await HiyoriStart.send(msg)\n    return\n\n\ndef getBot(GroupID: int | str) -> Bot | None:\n    \"\"\"\n    在多Bot连接的情况下，根据群组ID来返回对应的Bot。如果群组无对应Bot，则返回None。\n\n    :param GroupID: 群号\n    \"\"\"\n    bots = get_bots()\n    GroupID = str(GroupID)\n    # 群组不在特殊规则中\n    if GroupID not in multiBotConfig.rule.keys():\n        # 遍历响应优先序列，按顺序找到第一个已开启且在本群聊中的QQ\n        for botQQ in multiBotConfig.priority:\n            # 对应Bot已开启 而且这个Bot在群聊中\n            if (botQQ in bots) and (GroupID in multiBotConfig.groupSet[botQQ]):\n                return get_bot(self_id=botQQ)\n        # 没找到就返回None\n        return None\n    else:\n        # 特定规则指定的QQ\n        ruleQQ = multiBotConfig.rule[GroupID]\n        # 特定规则指定的QQ已开启\n        if ruleQQ in bots.keys():\n            return get_bot(self_id=ruleQQ)\n        else:\n            # 则按照顺序优先级返回\n            for botQQ in multiBotConfig.priority:\n                # 对应Bot已开启 而且这个Bot在群聊中\n                if (botQQ in bots) and (GroupID in multiBotConfig.groupSet[botQQ]):\n                    return get_bot(self_id=botQQ)\n            # 没找到就返回None\n            return None\n\n\n@CheckStatus.handle()\nasync def _(bot: Bot):\n    msg = \"当前已连接Bot列表：\\n\"\n    for hiyori in multiBotConfig.activeBots:\n        name = await GetQQStrangerName(bot=bot, QQ=int(hiyori))\n        msg += f\"{name}({hiyori})\\n\"\n    await CheckStatus.send(msg)\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Database_Manager/user.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:31\n@Desc: 用户数据库相关\n@Ver : 1.0.0\n\"\"\"\nfrom nonebot import get_driver\nfrom nonebot import on_regex\nfrom nonebot.adapters.onebot.v11 import Bot, Event\nfrom Hiyori.Utils.Database import DB_User\nfrom Hiyori.Utils.Priority import Priority\n\n# 用户数据库刷新，根据群列表以及群成员列表更新User,Group表以及对应内存\nupdate_all = on_regex(\"(^#用户数据库刷新$)|(^#refresh\\\\s+[d,D][b,B])$\", priority=Priority.系统优先级, block=True)\n# 用户数据库重载，将数据库重新载入内存\nreload_all = on_regex(\"(^#用户数据库重载$)|(^#reload\\\\s+[d,D][b,B])$\", priority=Priority.系统优先级, block=True)\n\nconfig = get_driver().config\n\n\n@update_all.handle()\nasync def _(bot: Bot, event: Event):\n    global config\n    if hasattr(event, \"user_id\"):\n        if str(event.user_id) in config.superusers or DB_User.isOwner(event.user_id):\n            await DB_User.refreshAll()\n            await update_all.send(\"用户数据库刷新成功\")\n\n\n@reload_all.handle()\nasync def _(bot: Bot, event: Event):\n    global config\n    if hasattr(event, \"user_id\"):\n        if str(event.user_id) in config.superusers or DB_User.isOwner(event.user_id):\n            DB_User.reload()\n            await reload_all.send(\"用户数据库重载成功\")\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Auto_Withdraw/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/7/30-21:34\n@Desc: 发言自动定时撤回\n@Ver : 1.0.0\n\"\"\"\nimport re\n\nfrom nonebot import on_regex\nfrom nonebot.adapters.onebot.v11 import GroupMessageEvent, GROUP_ADMIN, GROUP_OWNER\nfrom nonebot.permission import SUPERUSER\nfrom nonebot.plugin import PluginMetadata\n\nfrom Hiyori.Utils.Permissions import HIYORI_OWNER, HIYORI_ADMIN\nfrom Hiyori.Utils.Priority import Priority\nfrom .config import autoWithdrawConfig\nfrom .hook import *\n\n__plugin_meta__ = PluginMetadata(\n    name=\"群聊消息自动撤回\",\n    description=\"开启后妃爱将定时撤回自己发送的消息\",\n    usage=\"#开启定时撤回\\n\"\n          \"#开启定时撤回 定时时间\\n\"\n          \"#关闭定时撤回\\n\"\n          \"#修改定时撤回时间 定时时间\\n\"\n          \"#查看定时撤回状态\\n\",\n    extra={\n        \"CD_Weight\": 5,\n        \"permission\": \"群管/妃爱管理员及以上权限\",\n        \"example\": \"\",\n        \"Keep_On\": True,\n        \"Type\": \"Admin_Plugin\",\n    },\n)\n\nStatusOn = on_regex(r\"^#?开启定时撤回\", permission=GROUP_ADMIN | GROUP_OWNER | HIYORI_ADMIN | HIYORI_OWNER | SUPERUSER,\n                    priority=Priority.系统优先级, block=True)\nStatusOff = on_regex(r\"^#?关闭定时撤回\", permission=GROUP_ADMIN | GROUP_OWNER | HIYORI_ADMIN | HIYORI_OWNER | SUPERUSER,\n                     priority=Priority.系统优先级, block=True)\nChangeTime = on_regex(r\"^#?修改定时撤回时间\", permission=GROUP_ADMIN | GROUP_OWNER | HIYORI_ADMIN | HIYORI_OWNER | SUPERUSER,\n                      priority=Priority.系统优先级, block=True)\n\nCheckStatus = on_regex(r\"^#?查看定时撤回状态\", priority=Priority.系统优先级, block=True)\n\n\n@StatusOn.handle()\nasync def _(event: GroupMessageEvent):\n    message = str(event.message)\n    time = re.sub(r\"^#?开启定时撤回\", string=message, repl=\"\").strip()\n    # 配置文件中本群组不存在\n    if str(event.group_id) not in autoWithdrawConfig.groupConfig.keys():\n        if time.isdigit():\n            time = int(time)\n        else:\n            time = autoWithdrawConfig.defaultWithdrawTime\n    else:\n        if time.isdigit():\n            time = int(time)\n        else:\n            time = autoWithdrawConfig.groupConfig[str(event.group_id)][\"time\"]\n    if time > autoWithdrawConfig.maxWithdrawTime:\n        await StatusOn.send(f\"最长可以设置的定时时间为{autoWithdrawConfig.maxWithdrawTime}秒\")\n        return\n\n    autoWithdrawConfig.groupConfig[str(event.group_id)] = {\n        \"on\": True,\n        \"time\": time\n    }\n    autoWithdrawConfig.dump()\n    await StatusOn.send(f\"本群组已开启定时撤回，定时{time}秒\")\n\n\n@StatusOff.handle()\nasync def _(event: GroupMessageEvent):\n    # 配置文件中本群组不存在\n    if str(event.group_id) not in autoWithdrawConfig.groupConfig.keys():\n        autoWithdrawConfig.groupConfig[str(event.group_id)] = {\n            \"on\": False,\n            \"time\": autoWithdrawConfig.defaultWithdrawTime\n        }\n    else:\n        autoWithdrawConfig.groupConfig[str(event.group_id)][\"on\"] = False\n    autoWithdrawConfig.dump()\n    await StatusOff.send(\"本群组已关闭定时撤回\")\n\n\n@ChangeTime.handle()\nasync def _(event: GroupMessageEvent):\n    message = str(event.message)\n    time = re.sub(r\"^#?修改定时撤回时间\", string=message, repl=\"\").strip()\n    if time.isdigit():\n        time = int(time)\n    else:\n        time = autoWithdrawConfig.defaultWithdrawTime\n    if time > autoWithdrawConfig.maxWithdrawTime:\n        await ChangeTime.send(f\"最长可以设置的定时时间为{autoWithdrawConfig.maxWithdrawTime}秒\")\n        return\n    # 配置文件中不存在\n    if str(event.group_id) not in autoWithdrawConfig.groupConfig.keys():\n        autoWithdrawConfig.groupConfig[str(event.group_id)] = {\n            \"on\": False,\n            \"time\": time\n        }\n    else:\n        autoWithdrawConfig.groupConfig[str(event.group_id)][\"time\"] = time\n    autoWithdrawConfig.dump()\n    await StatusOff.send(f\"本群组定时撤回设定时间已改为{time}\")\n\n\n@CheckStatus.handle()\nasync def _(event: GroupMessageEvent):\n    if str(event.group_id) not in autoWithdrawConfig.groupConfig.keys():\n        status = f\"已开启，设定时间{autoWithdrawConfig.defaultWithdrawTime}\" if autoWithdrawConfig.defaultOn else \"未开启\"\n        await CheckStatus.send(f\"当前设定状态：定时撤回{status}\")\n    else:\n        on = autoWithdrawConfig.groupConfig[str(event.group_id)][\"on\"]\n        time = autoWithdrawConfig.groupConfig[str(event.group_id)][\"time\"]\n        status = f\"已开启，设定时间{time}\" if on else \"未开启\"\n        await CheckStatus.send(f\"当前设定状态：定时撤回{status}\")\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/config.py", "content": "\"\"\" 配置 \"\"\"\nfrom pathlib import Path\nfrom typing import Any, Dict\n\nfrom nonebot import get_driver\nfrom nonebot_plugin_localstore import get_cache_dir, get_config_dir, get_data_dir\nfrom pydantic import BaseModel, Extra, root_validator\n\n\nclass Config(BaseModel, extra=Extra.ignore):\n    datastore_cache_dir: Path\n    datastore_config_dir: Path\n    datastore_data_dir: Path\n    datastore_database_url: str\n    \"\"\"数据库连接字符串\n\n    默认使用 SQLite\n    \"\"\"\n    datastore_enable_database: bool = True\n    datastore_database_echo: bool = False\n    datastore_engine_options: Dict[str, Any] = {}\n    datastore_config_provider: str = \"~json\"\n\n    @root_validator(pre=True, allow_reuse=True)\n    def set_defaults(cls, values: Dict):\n        \"\"\"设置默认值\"\"\"\n        # 设置默认目录\n        # 仅在未设置时调用 get_*_dir 函数，因为这些函数会自动创建目录\n        values[\"datastore_cache_dir\"] = (\n            Path(cache_dir)\n            if (cache_dir := values.get(\"datastore_cache_dir\"))\n            else Path(get_cache_dir(\"\"))\n        )\n        values[\"datastore_config_dir\"] = (\n            Path(config_dir)\n            if (config_dir := values.get(\"datastore_config_dir\"))\n            else Path(get_config_dir(\"\"))\n        )\n        values[\"datastore_data_dir\"] = (\n            Path(data_dir)\n            if (data_dir := values.get(\"datastore_data_dir\"))\n            else Path(get_data_dir(\"\"))\n        )\n\n        # 设置默认数据库连接字符串\n        if not values.get(\"datastore_database_url\"):\n            values[\n                \"datastore_database_url\"\n            ] = f\"sqlite+aiosqlite:///{values['datastore_data_dir'] / 'data.db'}\"\n\n        return values\n\n\nplugin_config = Config.parse_obj(get_driver().config)\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/providers/__init__.py", "content": "import abc\nfrom typing import TYPE_CHECKING, Any, TypeVar, Union, overload\n\nif TYPE_CHECKING:\n    from ..plugin import PluginData\n\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n\n\nclass KeyNotFoundError(Exception):\n    \"\"\"键值未找到\"\"\"\n\n    def __init__(self, key: str) -> None:\n        self.key = key\n        super().__init__(f\"Key {key} not found\")\n\n\nclass ConfigProvider(abc.ABC):\n    \"\"\"插件配置管理\"\"\"\n\n    def __init__(self, plugin_data: \"PluginData\") -> None:\n        self._plugin_data = plugin_data\n\n    @abc.abstractmethod\n    async def _get(self, key: str) -> Any:\n        \"\"\"获取配置键值\"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    async def _set(self, key: str, value: Any) -> None:\n        \"\"\"异步设置配置键值\"\"\"\n        raise NotImplementedError\n\n    @overload\n    async def get(self, __key: str) -> Union[Any, None]:\n        ...\n\n    @overload\n    async def get(self, __key: str, __default: T) -> T:\n        ...\n\n    async def get(self, key, default=None):\n        \"\"\"获得配置\n\n        如果配置获取失败则使用 `default` 值并保存\n        如果不提供 `default` 默认返回 None\n        \"\"\"\n        try:\n            value = await self._get(key)\n        except KeyNotFoundError:\n            value = default\n            # 保存默认配置\n            await self.set(key, value)\n        return value\n\n    async def set(self, key: str, value: Any) -> None:\n        \"\"\"设置配置\"\"\"\n        await self._set(key, value)\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Auto_Withdraw/config.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/7/30-21:35\n@Desc: 相关配置\n@Ver : 1.0.0\n\"\"\"\nimport os\nimport json\nfrom Hiyori.Utils.File import DirExist, JsonFileExist\nfrom Hiyori.Utils.Config import Config\n\nConfigPath = \"./Config/Auto_Withdraw/config.json\"\nConfigDir = os.path.dirname(ConfigPath)\n\n\nclass AutoWithdrawConfig(Config):\n\n    def __init__(self):\n        initContent: dict = {\n            \"默认撤回时间\": 60,\n            \"最长撤回时间\": 110,\n            \"群组默认开启\": False,\n            \"群组撤回配置\": {\n                \"111\": {\n                    \"on\": True,\n                    \"time\": 70\n                }\n            },\n        }\n        DirExist(ConfigDir)\n        JsonFileExist(Path=ConfigPath, initContent=initContent, logEnable=True, logInfo=\"【定时撤回插件】配置文件不存在，正在创建中。\")\n        with open(file=ConfigPath, mode=\"r\", encoding=\"utf-8\") as file:\n            config = json.loads(file.read())\n            self.defaultWithdrawTime: int = config[\"默认撤回时间\"]\n            self.maxWithdrawTime: int = config[\"最长撤回时间\"]\n            self.defaultOn: bool = config[\"群组默认开启\"]\n            self.groupConfig: dict[str, dict[str, any]] = config[\"群组撤回配置\"]\n\n    def dump(self):\n        \"\"\"导出配置到配置文件中\"\"\"\n        with open(file=ConfigPath, mode=\"w\", encoding=\"utf-8\") as file:\n            content = {\n                \"默认撤回时间\": self.defaultWithdrawTime,\n                \"最长撤回时间\": self.maxWithdrawTime,\n                \"群组默认开启\": self.defaultOn,\n                \"群组撤回配置\": self.groupConfig,\n\n            }\n            file.write(json.dumps(content, ensure_ascii=False, indent=2))\n\n    def load(self):\n        \"\"\"从配置文件中导入配置\"\"\"\n        initContent: dict = {\n            \"默认撤回时间\": 60,\n            \"最长撤回时间\": 110,\n            \"群组默认开启\": False,\n            \"群组撤回配置\": {},\n        }\n        DirExist(ConfigDir)\n        JsonFileExist(Path=ConfigPath, initContent=initContent, logEnable=True, logInfo=\"【定时撤回插件】配置文件不存在，正在创建中。\")\n        with open(file=ConfigPath, mode=\"r\", encoding=\"utf-8\") as file:\n            config = json.loads(file.read())\n            self.defaultWithdrawTime: int = config[\"默认撤回时间\"]\n            self.maxWithdrawTime: int = config[\"最长撤回时间\"]\n            self.defaultOn: bool = config[\"群组默认开启\"]\n            self.groupConfig: dict[str, bool] = config[\"群组撤回配置\"]\n\n\nautoWithdrawConfig: AutoWithdrawConfig = AutoWithdrawConfig()\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Auto_Withdraw/hook.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/8/4-16:23\n@Desc: \n@Ver : 1.0.0\n\"\"\"\nimport asyncio\nfrom nonebot.adapters.onebot.v11 import Bot, GroupMessageEvent\nfrom nonebot.message import run_preprocessor\nfrom .config import autoWithdrawConfig\n\n\n# 当bot发送消息后触发，若设置了定时则撤回对应消息\n@Bot.on_called_api\nasync def withdrawSelfMessage(bot: Bot, exception: Exception, api: str, data: dict[str, any], result: any):\n    \"\"\"\n    bot发送消息后定时进行撤回。\n    \"\"\"\n    # 必须是发送消息的事件\n    if api not in [\"send_msg\", \"send_group_msg\", \"send_private_msg\", \"send_group_forward_msg\", \"send_private_forward_msg\"]:\n        return\n    # 必须是群聊事件\n    if \"group_id\" in data:\n        GroupID: str = str(data[\"group_id\"])\n        # 有群组配置\n        if GroupID in autoWithdrawConfig.groupConfig.keys():\n            GroupConfig = autoWithdrawConfig.groupConfig[GroupID]\n            # 群组开启撤回\n            if GroupConfig[\"on\"]:\n                asyncio.create_task(withDrawMessage(bot, result[\"message_id\"], GroupConfig[\"time\"]))\n        # 无群组配置，默认撤回\n        elif autoWithdrawConfig.defaultOn:\n            asyncio.create_task(withDrawMessage(bot, result[\"message_id\"], autoWithdrawConfig.defaultWithdrawTime))\n\n\n# 当事件响应器运行前触发，若设置了定时则撤回目标的消息\n@run_preprocessor\nasync def withdrawTargetMessage(bot: Bot, event: GroupMessageEvent):\n    # 判断能否撤回目标发言\n    selfInfo = await bot.get_group_member_info(group_id=event.group_id, user_id=event.self_id, no_cache=False)\n    selfRole = selfInfo[\"role\"]\n    if selfRole not in (\"owner\", \"admin\"):\n        return\n    targetInfo = await bot.get_group_member_info(group_id=event.group_id, user_id=event.user_id, no_cache=False)\n    targetRole = targetInfo[\"role\"]\n    if targetRole == \"owner\":\n        return\n    if targetRole == \"admin\" and selfRole != \"owner\":\n        return\n    GroupID: str = str(event.group_id)\n    # 有群组配置\n    if GroupID in autoWithdrawConfig.groupConfig.keys():\n        GroupConfig = autoWithdrawConfig.groupConfig[GroupID]\n        # 群组开启撤回\n        if GroupConfig[\"on\"]:\n            asyncio.create_task(withDrawMessage(bot, event.message_id, GroupConfig[\"time\"]))\n    # 无群组配置，默认撤回\n    elif autoWithdrawConfig.defaultOn:\n        asyncio.create_task(withDrawMessage(bot, event.message_id, autoWithdrawConfig.defaultWithdrawTime))\n\n\n# 定时撤回执行函数\nasync def withDrawMessage(bot: Bot, message_id: int, time: int):\n    await asyncio.sleep(time)\n    try:\n        await bot.delete_msg(message_id=message_id)\n    except Exception as e:\n        pass\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Database_Manager/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:31\n@Desc: 指令管理数据库\n@Ver : 1.0.0\n\"\"\"\nfrom .user import update_all  # 用户数据库更新\nfrom .user import reload_all  # 用户数据库重载\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/providers/yaml.py", "content": "try:\n    import yaml\nexcept ImportError as e:  # pragma: no cover\n    raise ImportError(\"请使用 `pip install nonebot-plugin-datastore[yaml]` 安装所需依赖\") from e\n\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\n\ntry:\n    from yaml import CDumper as Dumper\n    from yaml import CLoader as Loader\nexcept ImportError:\n    from yaml import Loader, Dumper\n\nfrom . import ConfigProvider, KeyNotFoundError\n\nif TYPE_CHECKING:\n    from ..plugin import PluginData\n\n\nclass Config(ConfigProvider):\n    \"\"\"yaml 格式配置\"\"\"\n\n    def __init__(self, plugin_data: \"PluginData\") -> None:\n        super().__init__(plugin_data)\n        self._data = {}\n        self._load_config()\n\n    @property\n    def _path(self) -> Path:\n        \"\"\"配置文件路径\"\"\"\n        return self._plugin_data.config_dir / f\"{self._plugin_data.name}.yaml\"\n\n    def _ensure_config(self) -> None:\n        \"\"\"确保配置文件存在\"\"\"\n        if not self._path.exists():\n            with self._path.open(\"w\", encoding=\"utf8\") as f:\n                yaml.dump(self._data, f, Dumper=Dumper)\n\n    def _load_config(self) -> None:\n        \"\"\"读取配置\"\"\"\n        self._ensure_config()\n        with self._path.open(\"r\", encoding=\"utf8\") as f:\n            self._data = yaml.load(f, Loader=Loader)\n\n    def _save_config(self) -> None:\n        \"\"\"保存配置\"\"\"\n        self._ensure_config()\n        with self._path.open(\"w\", encoding=\"utf8\") as f:\n            yaml.dump(self._data, f, Dumper=Dumper)\n\n    async def _get(self, key: str) -> Any:\n        if not self._data:\n            self._load_config()\n        try:\n            return self._data[key]\n        except KeyError:\n            raise KeyNotFoundError(key)\n\n    async def _set(self, key: str, value: Any) -> None:\n        self._data[key] = value\n        self._save_config()\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_apscheduler/__init__.py", "content": "import logging\n\nfrom nonebot import get_driver\nfrom nonebot.log import LoguruHandler, logger\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\n\nfrom .config import Config\n\ndriver = get_driver()\nglobal_config = driver.config\nplugin_config = Config(**global_config.dict())\n\nscheduler = AsyncIOScheduler()\nscheduler.configure(plugin_config.apscheduler_config)\n\n\nasync def _start_scheduler():\n    if not scheduler.running:\n        scheduler.start()\n        logger.opt(colors=True).info(\"<y>Scheduler Started</y>\")\n\n\nasync def _shutdown_scheduler():\n    if scheduler.running:\n        scheduler.shutdown()\n        logger.opt(colors=True).info(\"<y>Scheduler Shutdown</y>\")\n\n\nif plugin_config.apscheduler_autostart:\n    driver.on_startup(_start_scheduler)\n    driver.on_shutdown(_shutdown_scheduler)\n\naps_logger = logging.getLogger(\"apscheduler\")\naps_logger.setLevel(plugin_config.apscheduler_log_level)\naps_logger.handlers.clear()\naps_logger.addHandler(LoguruHandler())\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Menu/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:34\n@Desc: 帮助菜单插件\n@Ver : 1.0.0\n\"\"\"\nfrom nonebot.plugin import _plugins\nfrom nonebot import on_regex\nfrom nonebot.adapters.onebot.v11 import MessageEvent, MessageSegment\nfrom .api import *\nfrom Hiyori.Utils.Priority import Priority\n\nfrom Hiyori.Plugins.Basic_plugins import nonebot_plugin_htmlrender as htmlRender\nfrom Hiyori.Plugins.Basic_plugins import Plugin_Manager\n\nget_Menu = on_regex(r\"(^#?帮助$)|(^#?菜单$)\", priority=Priority.系统优先级, block=True)\n\nMenu_HTML_Path = \"./Data/Menu/Template/menu_百岁珊.html\"\nMenu_PNG_Path = \"./Data/Menu/Template/menu_百岁珊.png\"\nHas_Generate_Menu = False\n\n\n@get_Menu.handle()\nasync def _(event: MessageEvent):\n    # 由于菜单会显示群组插件状态的原因，现在每次调用都会动态生成菜单。\n    global Menu_HTML_Path, Menu_PNG_Path, Has_Generate_Menu\n    Group_event = False\n    GroupID = 0\n    if hasattr(event, \"group_id\"):\n        Group_event = True\n        GroupID = event.group_id\n    with open(Menu_HTML_Path, \"r\", encoding=\"utf-8\") as file:\n        htmlStr = file.read()\n    templateStrs = [\"\", \"\", \"\"]  # 插件类型分别为 Normal_Plugin, Admin_Plugin, Auto_Plugin\n    plugins = list(_plugins.values())\n    for plugin in plugins:\n        if hasattr(plugin, \"metadata\"):\n            if plugin.metadata:\n                metadata = plugin.metadata\n                # 检查插件类型\n                Type = 0\n                if hasattr(metadata, \"extra\"):\n                    extra = metadata.extra\n                    if \"Type\" in extra.keys():\n                        match extra[\"Type\"]:\n                            case \"Normal_Plugin\":\n                                Type = 0\n                            case \"Admin_Plugin\":\n                                Type = 1\n                            case \"Auto_Plugin\":\n                                Type = 2\n                            case \"Anonymous_Plugin\":\n                                continue\n                # 填充模板\n                templateStrs[Type] = templateStrs[Type] + \"<tr>\"\n                # 插件名\n                if hasattr(metadata, \"name\"):\n                    # 是群聊事件\n                    if Group_event:\n                        if not Plugin_Manager.pluginsManager.GroupPluginIsOn(GroupID=str(GroupID),\n                                                                             PluginName=metadata.name):\n                            templateStrs[Type] = templateStrs[Type] + \\\n                                                 f\"<td style=\\\"color: rgb(201, 071, 055); text-decoration: \" \\\n                                                 f\"line-through\\\">{metadata.name}</td> \"\n                        elif not Plugin_Manager.pluginsManager.UserPluginIsOn(QQ=str(event.user_id),\n                                                                              PluginName=metadata.name):\n                            templateStrs[Type] = templateStrs[Type] + \\\n                                                 f\"<td style=\\\"color: rgb(0, 0, 0); text-decoration: \" \\\n                                                 f\"line-through\\\">{metadata.name}</td> \"\n                        else:\n                            templateStrs[Type] = templateStrs[Type] + f\"<td>{metadata.name}</td>\"\n                    # 是私聊事件\n                    else:\n                        if not Plugin_Manager.pluginsManager.UserPluginIsOn(QQ=str(event.user_id),\n                                                                            PluginName=metadata.name):\n                            templateStrs[Type] = templateStrs[Type] + \\\n                                                 f\"<td style=\\\"color: rgb(0, 0, 0); text-decoration: \" \\\n                                                 f\"line-through\\\">{metadata.name}</td> \"\n                        else:\n                            templateStrs[Type] = templateStrs[Type] + f\"<td>{metadata.name}</td>\"\n                else:\n                    templateStrs[Type] = templateStrs[Type] + \"<td></td>\"\n                # 插件介绍\n                if hasattr(metadata, \"description\"):\n                    description = metadata.description.replace(\"\\n\", \"<br>\")\n                    templateStrs[Type] = templateStrs[Type] + f\"<td>{description}</td>\"\n                else:\n                    templateStrs[Type] = templateStrs[Type] + \"<td></td>\"\n                # 插件用法\n                if hasattr(metadata, \"usage\"):\n                    usage = metadata.usage.replace(\"\\n\", \"<br>\")\n                    templateStrs[Type] = templateStrs[Type] + f\"<td>{usage}</td>\"\n                else:\n                    templateStrs[Type] = templateStrs[Type] + \"<td></td>\"\n                # extra信息\n                if hasattr(metadata, \"extra\"):\n                    extra = metadata.extra\n                    # 权限要求\n                    if \"permission\" in extra.keys():\n                        permission = extra[\"permission\"].replace(\"\\n\", \"<br>\")\n                        templateStrs[Type] = templateStrs[Type] + f\"<td>{permission}</td>\"\n                    else:\n                        templateStrs[Type] = templateStrs[Type] + \"<td>普通权限</td>\"\n                    # CD权重\n                    if \"CD_Weight\" in extra.keys():\n                        CD_Weight = extra[\"CD_Weight\"]\n                        templateStrs[Type] = templateStrs[Type] + f\"<td>{CD_Weight}</td>\"\n                    else:\n                        templateStrs[Type] = templateStrs[Type] + \"<td>0</td>\"\n                else:\n                    templateStrs[Type] = templateStrs[Type] + \"<td>普通权限</td><td>0</td>\"\n                templateStrs[Type] = templateStrs[Type] + \"</tr>\"\n    htmlStr = htmlStr.replace(\"Normal_Plugin\", templateStrs[0])\n    htmlStr = htmlStr.replace(\"Admin_Plugin\", templateStrs[1])\n    htmlStr = htmlStr.replace(\"Auto_Plugin\", templateStrs[2])\n    图片二进制数据 = await htmlRender.html_to_pic(\n        html=htmlStr, type=\"png\", viewport={\"width\": 2160, \"height\": 10},\n    )\n    # 菜单图片 = Image.open(io.BytesIO(图片二进制数据))\n    # workPath = os.getcwd()\n    # 图片路径 = os.path.join(workPath, Menu_PNG_Path)\n    # 菜单图片.save(图片路径, format=\"PNG\")\n    # 发送图片\n    # ImgDirUri = pathlib.Path(图片路径).as_uri()\n\n    message = MessageSegment.at(event.user_id)\n    message = message + MessageSegment.image(图片二进制数据)\n    await get_Menu.send(message)\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/MultiBot_Support/hook.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/8/4-8:05\n@Desc: 多bot连接支持 基于hook实现\n@Ver : 1.0.0\n\"\"\"\nfrom nonebot import get_driver\nfrom nonebot.adapters.onebot.v11 import Bot, Event\nfrom nonebot.message import event_preprocessor\nfrom nonebot.log import logger\nfrom nonebot import get_bots\nfrom nonebot.exception import IgnoredException\n\nfrom .config import multiBotConfig\n\ndriver = get_driver()\n\n\n# 在bot连接时检查配置文件，不存在则添加规则\n@driver.on_bot_connect\nasync def _(bot: Bot):\n    botQQ = bot.self_id\n    if botQQ not in multiBotConfig.priority:\n        multiBotConfig.priority.append(botQQ)\n        multiBotConfig.dump()\n        logger.success(f\"【MultiBot_Support】QQBot:{botQQ}已连接，添加到Bot响应序列中\")\n    # 导入bot所在群聊\n    multiBotConfig.groupSet[botQQ] = set()\n    groupList = await bot.get_group_list()\n\n    for groupInfo in groupList:\n        multiBotConfig.groupSet[botQQ].add(str(groupInfo[\"group_id\"]))\n    logger.success(f\"【MultiBot_Support】QQBot:{botQQ}已连接，已注册Bot所在群聊\")\n    # 注册bot\n    multiBotConfig.activeBots.add(botQQ)\n\n\n# 在bot断开连接时进行处理\n@driver.on_bot_disconnect\nasync def _(bot: Bot):\n    botQQ = bot.self_id\n    multiBotConfig.activeBots.remove(botQQ)\n    multiBotConfig.groupSet[botQQ].clear()\n\n\n# 在事件开始响应时检查规则，中断不响应bot的流程\n@event_preprocessor\nasync def _(event: Event):\n    if hasattr(event, \"group_id\"):\n        GroupID: str = str(event.group_id)\n        multiBotConfig.groupSet[str(event.self_id)].add(GroupID)  # 添加到set中\n        bots = get_bots().keys()  # bot的QQ列表，str格式\n        # 群组不在特殊规则中\n        if GroupID not in multiBotConfig.rule.keys():\n            # 遍历响应优先序列，按顺序找到第一个已开启已注册且在本群聊中的QQ\n            for botQQ in multiBotConfig.priority:\n                # 对应Bot已开启 而且这个Bot在群聊中 而且bot已注册成功（防止因为启动异步导致重复回复）\n                if (botQQ in bots) and (GroupID in multiBotConfig.groupSet[botQQ]) and (botQQ in multiBotConfig.activeBots):\n                    if str(event.self_id) != botQQ:\n                        raise IgnoredException(\"多Bot响应屏蔽\")\n                    else:\n                        return\n            # 补充，如果一个都没找到，则默认屏蔽。防止在Hiyori初始化时重复响应相同时间\n            raise IgnoredException(\"多Bot响应屏蔽\")\n\n        # 群组在特殊规则中\n        else:\n            # 特定规则指定的QQ\n            ruleQQ = multiBotConfig.rule[GroupID]\n            # 响应规则的bot已开启，且响应规则的bot已注册\n            if (ruleQQ in bots) and (ruleQQ in multiBotConfig.activeBots):\n                # 本bot与该群组响应规则不匹配\n                if int(ruleQQ) != event.self_id:\n                    raise IgnoredException(\"多Bot响应屏蔽\")\n                else:\n                    return\n            # 响应规则的bot未开启或未注册，则按照默认的优先序列，按顺序找到第一个已开启且在本群聊中的QQ\n            else:\n                for botQQ in multiBotConfig.priority:\n                    # 对应Bot已开启 而且这个Bot在群聊中 而且bot已注册成功（防止因为启动异步导致重复回复）\n                    if (botQQ in bots) and (GroupID in multiBotConfig.groupSet[botQQ]) and (botQQ in multiBotConfig.activeBots):\n                        if str(event.self_id) != botQQ:\n                            raise IgnoredException(\"多Bot响应屏蔽\")\n                        else:\n                            return\n                # 补充，如果一个都没找到，则默认屏蔽。防止在Hiyori初始化时重复响应相同时间\n                raise IgnoredException(\"多Bot响应屏蔽\")\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Plugin_Manager/pluginManager.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:35\n@Desc: \n@Ver : 1.0.0\n\"\"\"\nimport json\nimport aiofiles\nimport os\nfrom nonebot import get_loaded_plugins\nfrom Hiyori.Utils.File import JsonFileExist, DirExist\n\n\nclass pluginsManager:\n    GroupPluginInfo: dict[str, dict[str, bool]] = dict()\n    UserPluginInfo: dict[str, dict[str, bool]] = dict()\n    GroupJsonPath: str = \"./Config/Plugin_Manager/groupConfig.json\"\n    UserJsonPath: str = \"./Config/Plugin_Manager/userConfig.json\"\n\n    # 初始化\n    @staticmethod\n    def LoadConfig():\n        \"\"\"初始化，从json文件加载配置\"\"\"\n        DirExist(os.path.dirname(pluginsManager.GroupJsonPath))\n        JsonFileExist(pluginsManager.GroupJsonPath)\n        JsonFileExist(pluginsManager.UserJsonPath)\n        pluginsManager.GroupPluginInfo.clear()\n        pluginsManager.UserPluginInfo.clear()\n        # 加载群插件配置\n        with open(pluginsManager.GroupJsonPath, encoding=\"utf-8\", mode=\"r\") as file:\n            info = file.read()\n            pluginsManager.GroupPluginInfo = json.loads(info)\n        # 加载用户插件配置\n        with open(pluginsManager.UserJsonPath, encoding=\"utf-8\", mode=\"r\") as file:\n            info = file.read()\n            pluginsManager.UserPluginInfo = json.loads(info)\n\n    # 保存群组配置\n    @staticmethod\n    async def SaveGroupConfig():\n        \"\"\"保存群组配置\"\"\"\n        async with aiofiles.open(pluginsManager.GroupJsonPath, encoding=\"utf-8\", mode=\"w\") as file:\n            info = json.dumps(pluginsManager.GroupPluginInfo, indent=2, ensure_ascii=False)\n            await file.write(info)\n\n    # 保存个人配置\n    @staticmethod\n    async def SaveUserConfig():\n        \"\"\"保存个人配置\"\"\"\n        async with aiofiles.open(pluginsManager.UserJsonPath, encoding=\"utf-8\", mode=\"w\") as file:\n            info = json.dumps(pluginsManager.UserPluginInfo, indent=2, ensure_ascii=False)\n            await file.write(info)\n\n    # 判断群组的对应插件是否开启，若开启返回True，否则返回False\n    @staticmethod\n    def GroupPluginIsOn(GroupID: str, PluginName: str) -> bool:\n        \"\"\"判断群组的对应插件是否开启，若开启返回True，否则返回False\"\"\"\n        # 检查插件是否常驻\n        if pluginsManager.PluginKeepOn(PluginName):\n            return True\n        if GroupID in pluginsManager.GroupPluginInfo.keys():\n            GroupInfo = pluginsManager.GroupPluginInfo[GroupID]\n            # 检查是否开启白名单模式\n            if \"WhiteList\" in GroupInfo.keys():\n                # 若开启了白名单模式\n                if GroupInfo[\"WhiteList\"]:\n                    if PluginName in GroupInfo.keys():\n                        return GroupInfo[PluginName]\n                    else:\n                        return False\n                # 未开启白名单模式\n            if PluginName in GroupInfo.keys():\n                return GroupInfo[PluginName]\n        return True\n\n    # 判断用户的对应插件是否开启，若开启返回True，否则返回False\n    @staticmethod\n    def UserPluginIsOn(QQ: str, PluginName: str) -> bool:\n        \"\"\"判断用户的对应插件是否开启，若开启返回True，否则返回False\"\"\"\n        # 检查插件是否常驻\n        if pluginsManager.PluginKeepOn(PluginName):\n            return True\n        if QQ in pluginsManager.UserPluginInfo.keys():\n            UserInfo = pluginsManager.UserPluginInfo[QQ]\n            # 检查是否开启白名单模式\n            if \"WhiteList\" in UserInfo.keys():\n                # 若开启了白名单模式\n                if UserInfo[\"WhiteList\"]:\n                    if PluginName in UserInfo.keys():\n                        return UserInfo[PluginName]\n                    else:\n                        return False\n                # 未开启白名单模式\n            if PluginName in UserInfo.keys():\n                return UserInfo[PluginName]\n        return True\n\n    # 更改群组插件状态\n    @staticmethod\n    async def ChangeGroupPluginStatus(GroupID: str, PluginName: str, status: bool):\n        if GroupID not in pluginsManager.GroupPluginInfo:\n            pluginsManager.GroupPluginInfo[GroupID] = dict()\n        pluginsManager.GroupPluginInfo[GroupID][PluginName] = status\n        await pluginsManager.SaveGroupConfig()\n\n    # 改变个人插件状态\n    @staticmethod\n    async def ChangeUserPluginStatus(QQ: str, PluginName: str, status: bool):\n        if QQ not in pluginsManager.UserPluginInfo:\n            pluginsManager.UserPluginInfo[QQ] = dict()\n        pluginsManager.UserPluginInfo[QQ][PluginName] = status\n        await pluginsManager.SaveUserConfig()\n\n    # 获取在黑名单模式下，群组已关闭插件列表\n    @staticmethod\n    def GetGroupOffPlugins(GroupID: str) -> list[str]:\n        \"\"\"\n        获取在黑名单模式下，群组已关闭插件列表\n\n        :param GroupID: 群号\n        :return: 已关闭的插件的列表【黑名单模式下】\n        \"\"\"\n        result = []\n        if GroupID not in pluginsManager.GroupPluginInfo.keys():\n            return result\n        else:\n            groupInfo = pluginsManager.GroupPluginInfo[GroupID]\n            if len(groupInfo) != 0:\n                for pluginName, status in groupInfo.items():\n                    if not status and pluginName != \"WhiteList\":\n                        result.append(pluginName)\n            return result\n\n    # 获取在白名单模式下，群组已开启插件列表\n    @staticmethod\n    def GetGroupOnPlugins(GroupID: str) -> list[str]:\n        \"\"\"\n        获取在白名单模式下，群组已开启插件列表\n\n        :param GroupID: 群号\n        :return: 已开启的插件的列表【白名单模式下】\n        \"\"\"\n        result = []\n        if GroupID not in pluginsManager.GroupPluginInfo.keys():\n            return result\n        else:\n            groupInfo = pluginsManager.GroupPluginInfo[GroupID]\n            if len(groupInfo) != 0:\n                for pluginName, status in groupInfo.items():\n                    if status and pluginName != \"WhiteList\":\n                        result.append(pluginName)\n            return result\n\n    # 获取在黑名单模式下，个人已关闭插件列表\n    @staticmethod\n    def GetUserOffPlugins(QQ: str) -> list[str]:\n        \"\"\"\n        获取在黑名单模式下，个人已关闭插件列表\n\n        :param QQ: QQ号\n        :return: 已关闭的插件的列表【黑名单模式下】\n        \"\"\"\n        result = []\n        if QQ not in pluginsManager.UserPluginInfo.keys():\n            return result\n        else:\n            userInfo = pluginsManager.UserPluginInfo[QQ]\n            for pluginName, status in userInfo.items():\n                if not status and pluginName != \"WhiteList\":\n                    result.append(pluginName)\n            return result\n\n    # 获取在黑名单模式下，个人已关闭插件列表\n    @staticmethod\n    def GetUserOnPlugins(QQ: str) -> list[str]:\n        \"\"\"\n        获取在黑名单模式下，个人已关闭插件列表\n\n        :param QQ: QQ号\n        :return: 已开启的插件的列表【白名单模式下】\n        \"\"\"\n        result = []\n        if QQ not in pluginsManager.UserPluginInfo.keys():\n            return result\n        else:\n            userInfo = pluginsManager.UserPluginInfo[QQ]\n            for pluginName, status in userInfo.items():\n                if status and pluginName != \"WhiteList\":\n                    result.append(pluginName)\n            return result\n\n    # 检查群组是否是白名单模式\n    @staticmethod\n    def GroupWhiteListStatus(GroupID: str) -> bool:\n        \"\"\"\n        检查群组是否是白名单模式，若是则返回True\n\n        :param GroupID: 群号\n        :return: 是否是白名单模式\n        \"\"\"\n        # 默认为黑名单模式\n        if GroupID not in pluginsManager.GroupPluginInfo.keys():\n            return False\n        else:\n            groupInfo = pluginsManager.GroupPluginInfo[GroupID]\n            if \"WhiteList\" not in groupInfo.keys():\n                return False\n            else:\n                return groupInfo[\"WhiteList\"]\n\n    # 检查用户是否是白名单模式\n    @staticmethod\n    def UserWhiteListStatus(QQ: str) -> bool:\n        \"\"\"\n        检查用户是否是白名单模式，若是则返回True\n\n        :param QQ: QQ号\n        :return: 是否是白名单模式\n        \"\"\"\n        # 默认为黑名单模式\n        if QQ not in pluginsManager.UserPluginInfo.keys():\n            return False\n        else:\n            userInfo = pluginsManager.UserPluginInfo[QQ]\n            if \"WhiteList\" not in userInfo.keys():\n                return False\n            else:\n                return userInfo[\"WhiteList\"]\n\n    # 检查插件是否常驻\n    @staticmethod\n    def PluginKeepOn(PluginName: str) -> bool:\n        \"\"\"\n        检查插件是否常驻\n\n        :param PluginName: 插件名\n        :return: 若插件常驻则返回True，否则返回False\n        \"\"\"\n        plugins = get_loaded_plugins()\n        for plugin in plugins:\n            if hasattr(plugin.metadata, \"name\"):\n                if plugin.metadata.name == PluginName:\n                    if hasattr(plugin.metadata, \"extra\"):\n                        extraInfo = plugin.metadata.extra\n                        if \"Keep_On\" in extraInfo.keys():\n                            return extraInfo[\"Keep_On\"]\n                    return False\n        return False\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_apscheduler/config.py", "content": "from pydantic import Field, BaseSettings\n\n\nclass Config(BaseSettings):\n    apscheduler_autostart: bool = True\n    apscheduler_log_level: int = 30\n    apscheduler_config: dict = Field(\n        default_factory=lambda: {\"apscheduler.timezone\": \"Asia/Shanghai\"}\n    )\n\n    class Config:\n        extra = \"ignore\"\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Function_CD/hook.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:33\n@Desc: \n@Ver : 1.0.0\n\"\"\"\nfrom nonebot.message import run_preprocessor\nfrom nonebot.matcher import Matcher\nfrom nonebot import get_driver\nfrom nonebot.adapters.onebot.v11 import Bot, Event\nfrom nonebot.exception import IgnoredException\nfrom nonebot.log import logger\nfrom nonebot.adapters.onebot.v11 import MessageSegment\nimport datetime\nfrom Hiyori.Utils.Database import DB_User\n\nConfig = get_driver().config\n计算周期 = 5\n\n\n# 群组CD计时器，其中CD为群组的冷却总权重（五分钟），lastTime为群聊/个人上一次触发的时间，格式是\"%Y-%m-%d %H:%M:%S\"\nclass CD_Counter:\n    def __init__(self, ID: int, Name: str, CD: int, lastTime: str):\n        self.ID = ID\n        self.Name = Name\n        self.CD = CD\n        self.lastTime = lastTime\n        self.hasSendInfo = False\n\n\ndriver = get_driver()\n# CD统计\nGroupsCD: dict[int, CD_Counter] = dict()\nUsersCD: dict[int, CD_Counter] = dict()\n\n\n@run_preprocessor\nasync def 功能调用CD检查(matcher: Matcher, bot: Bot, event: Event):\n    global Config\n    # 对于已关机的群聊直接返回\n    if hasattr(event, \"group_id\"):\n        GroupID = event.group_id\n        Status = DB_User.getGroup(GroupID).Status\n        if Status == \"off\":\n            return\n    # 对于没有元数据的插件，不进行CD调用检查\n    if not hasattr(matcher.plugin.metadata, \"extra\"):\n        return\n    Data = matcher.plugin.metadata.extra\n    # 若插件不支持CD权重则不启用\n    if \"CD_Weight\" not in Data.keys():\n        return\n    CD_Weight = Data[\"CD_Weight\"]\n    if \"CD\" in matcher.state:\n        CD_Weight = matcher.state[\"CD\"]\n    Time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    # 个人CD审查\n    if hasattr(event, \"user_id\"):\n        QQ = event.user_id\n        # 不审查owner用户\n        if DB_User.isOwner(QQ) or (QQ in Config.superusers):\n            return\n        User = DB_User.getUser(QQ)\n        Max_CD = User.CD * 计算周期\n        # 检查是否在字典中，不存在则添加\n        if QQ not in UsersCD:\n            UsersCD[QQ] = CD_Counter(ID=QQ, Name=User.Name, CD=0, lastTime=Time)\n        # 权重累积计算\n        # 计算间隔\n        timeBefore = datetime.datetime.strptime(UsersCD[QQ].lastTime, \"%Y-%m-%d %H:%M:%S\")\n        timeNow = datetime.datetime.now()\n        seconds = (timeNow - timeBefore).seconds\n        logger.debug(f\"个人触发CD累积：【{QQ}】 seconds:{seconds},CD{UsersCD[QQ].CD},Max_CD{User.CD * 计算周期}\")\n        if seconds >= 计算周期 * 60:\n            # 对于第一次响应，无论权重大小，均会响应\n            UsersCD[QQ].lastTime = Time\n            UsersCD[QQ].CD = CD_Weight\n            UsersCD[QQ].hasSendInfo = False\n        elif Max_CD < CD_Weight + UsersCD[QQ].CD:\n            if not UsersCD[QQ].hasSendInfo:\n                # 提示信息仅发送一次\n                message = MessageSegment.at(event.user_id) + \"个人功能调用已超出权重上限，请稍后使用哦。\"\n                await matcher.send(message)\n                UsersCD[QQ].hasSendInfo = True\n            raise IgnoredException(\"个人功能调用超出权重上限\")\n        else:\n            UsersCD[QQ].CD = UsersCD[QQ].CD + CD_Weight\n    # 群CD审查\n    if hasattr(event, \"group_id\"):\n        GroupID = event.group_id\n        Group = DB_User.getGroup(GroupID)\n        Max_CD = Group.CD * 计算周期\n        # 检查是否在字典中，不存在则添加\n        if GroupID not in GroupsCD:\n            GroupsCD[GroupID] = CD_Counter(ID=GroupID, Name=Group.GroupName, CD=0, lastTime=Time)\n        # 权重累积计算\n        # 计算间隔\n        timeBefore = datetime.datetime.strptime(GroupsCD[GroupID].lastTime, \"%Y-%m-%d %H:%M:%S\")\n        timeNow = datetime.datetime.now()\n        seconds = (timeNow - timeBefore).seconds\n        logger.debug(f\"群组触发CD累积：【{GroupID}】 seconds:{seconds},CD{GroupsCD[GroupID].CD},Max_CD{Group.CD * 计算周期}\")\n        if seconds >= 计算周期 * 60:\n            # 对于第一次响应，无论权重大小，均会响应\n            GroupsCD[GroupID].lastTime = Time\n            GroupsCD[GroupID].CD = CD_Weight\n            GroupsCD[GroupID].hasSendInfo = False\n        elif Max_CD < CD_Weight + GroupsCD[GroupID].CD:\n            if not GroupsCD[GroupID].hasSendInfo:\n                # 提示信息仅发送一次\n                await matcher.send(\"群聊功能调用已超出权重上限，请稍后使用哦。\")\n                GroupsCD[GroupID].hasSendInfo = True\n            raise IgnoredException(\"群聊功能调用超出权重上限\")\n        else:\n            GroupsCD[GroupID].CD = GroupsCD[GroupID].CD + CD_Weight\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/providers/json.py", "content": "import json\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\n\nfrom . import ConfigProvider, KeyNotFoundError\n\nif TYPE_CHECKING:\n    from ..plugin import PluginData\n\n\nclass Config(ConfigProvider):\n    \"\"\"JSON 格式配置\"\"\"\n\n    def __init__(self, plugin_data: \"PluginData\") -> None:\n        super().__init__(plugin_data)\n        self._data = {}\n        self._load_config()\n\n    @property\n    def _path(self) -> Path:\n        \"\"\"配置文件路径\"\"\"\n        return self._plugin_data.config_dir / f\"{self._plugin_data.name}.json\"\n\n    def _ensure_config(self) -> None:\n        \"\"\"确保配置文件存在\"\"\"\n        if not self._path.exists():\n            with self._path.open(\"w\", encoding=\"utf8\") as f:\n                json.dump(self._data, f, ensure_ascii=False, indent=2)\n\n    def _load_config(self) -> None:\n        \"\"\"读取配置\"\"\"\n        self._ensure_config()\n        with self._path.open(\"r\", encoding=\"utf8\") as f:\n            self._data = json.load(f)\n\n    def _save_config(self) -> None:\n        \"\"\"保存配置\"\"\"\n        self._ensure_config()\n        with self._path.open(\"w\", encoding=\"utf8\") as f:\n            json.dump(self._data, f, ensure_ascii=False, indent=2)\n\n    async def _get(self, key: str) -> Any:\n        if not self._data:\n            self._load_config()\n        try:\n            return self._data[key]\n        except KeyError:\n            raise KeyNotFoundError(key)\n\n    async def _set(self, key: str, value: Any) -> None:\n        self._data[key] = value\n        self._save_config()\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Plugin_Manager/api.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/7/3-16:27\n@Desc: 检查插件状态\n@Ver : 1.0.0\n\"\"\"\nfrom nonebot import get_asgi\nfrom fastapi.responses import JSONResponse\nfrom nonebot.plugin import _plugins\nfrom .pluginManager import pluginsManager\n\napp = get_asgi()\n\n\n@app.get(\"/Plugins/Basic_plugins/Plugin_Manager/Plugin_info\", response_class=JSONResponse)\nasync def _(QQ: int, Group: int):\n    results = []\n    plugins = list(_plugins.values())\n    for plugin in plugins:\n        result = {}\n        if hasattr(plugin, \"metadata\"):\n            data = plugin.metadata\n            if hasattr(data, \"extra\"):\n                result[\"extra\"] = data.extra\n            if hasattr(data, \"name\"):\n                result[\"name\"] = data.name\n                # 添加插件状态\n                if Group != 0:\n                    result[\"group_status\"] = pluginsManager.GroupPluginIsOn(GroupID=str(Group), PluginName=data.name)\n                result[\"person_status\"] = pluginsManager.UserPluginIsOn(QQ=str(QQ), PluginName=data.name)\n            if hasattr(data, \"description\"):\n                result[\"description\"] = data.description\n            if hasattr(data, \"usage\"):\n                result[\"usage\"] = data.usage\n            # 仅当插件有名时进行返回\n            if hasattr(data, \"name\"):\n                results.append(result)\n    return results\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/__init__.py", "content": "from nonebot import require\n\nrequire(\"nonebot_plugin_localstore\")\n\nfrom nonebot.plugin import PluginMetadata\n\nfrom .config import Config\nfrom .db import create_session as create_session\nfrom .db import get_session as get_session\nfrom .plugin import PluginData as PluginData\nfrom .plugin import get_plugin_data as get_plugin_data\n\n\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/providers/database.py", "content": "from typing import Any\n\nfrom sqlalchemy import JSON, select\nfrom sqlalchemy.exc import NoResultFound\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom ..db import create_session\nfrom ..plugin import get_plugin_data\nfrom . import ConfigProvider, KeyNotFoundError\n\nplugin_data = get_plugin_data()\n\n\nclass ConfigModel(plugin_data.Model):\n    key: Mapped[str] = mapped_column(primary_key=True)\n    value: Mapped[Any] = mapped_column(JSON)\n\n\nclass Config(ConfigProvider):\n    \"\"\"数据库格式配置\"\"\"\n\n    async def _get(self, key: str) -> Any:\n        db_key = self._plugin_data.name + \"_\" + key\n        try:\n            async with create_session() as session:\n                config = (\n                    await session.scalars(\n                        select(ConfigModel).where(ConfigModel.key == db_key)\n                    )\n                ).one()\n                return config.value\n        except NoResultFound:\n            raise KeyNotFoundError(key)\n\n    async def _set(self, key: str, value: Any) -> None:\n        db_key = self._plugin_data.name + \"_\" + key\n        async with create_session() as session:\n            await session.merge(ConfigModel(key=db_key, value=value))\n            await session.commit()\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Update_News/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:37\n@Desc: 更新公告插件\n@Ver : 1.0.0\n\"\"\"\nfrom nonebot.adapters.onebot.v11 import MessageSegment, MessageEvent\nfrom nonebot import on_regex\nfrom nonebot.plugin import PluginMetadata\nfrom Hiyori.Plugins.Basic_plugins.nonebot_plugin_htmlrender import md_to_pic\nfrom Hiyori.Utils.Priority import Priority\nimport os\n\n__plugin_meta__ = PluginMetadata(\n    name=\"更新公告\",  # 用于在菜单显示 用于插件开关\n    description=\"查看妃爱的更新新闻\",  # 用于在菜单中描述\n    usage=\"#查看更新 或 #更新\\n\",\n    extra={\"CD_Weight\": 1,  # 调用插件CD权重 不填的话不会触发权重插件\n           \"Group\": \"Daily\",\n           \"version\": \"1.0\",\n           \"Keep_On\": False,\n           \"Type\": \"Normal_Plugin\",\n           }\n)\n\ncheckUpdate = on_regex(\"^#(查看)?更新$\", priority=Priority.普通优先级, block=False)\n\n\n@checkUpdate.handle()\nasync def _(event: MessageEvent):\n    # 文件夹路径\n    folder_path = os.path.dirname(os.path.abspath(__file__))\n    # md文件路径\n    md_path = os.path.join(folder_path, \"update.md\")\n    img = await md_to_pic(md_path=md_path, width=1200)\n    msg = MessageSegment.image(img)\n    await checkUpdate.send(msg)\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/script/cli.py", "content": "try:\n    import anyio\n    import click\n    from typing_extensions import ParamSpec\nexcept ImportError as e:  # pragma: no cover\n    raise ImportError(\"请使用 `pip install nonebot-plugin-datastore[cli]` 安装所需依赖\") from e\n\nfrom argparse import Namespace\nfrom functools import partial, wraps\nfrom typing import Any, Callable, Coroutine, Optional, TypeVar\n\nfrom nonebot.log import logger\n\nfrom ..config import plugin_config\nfrom ..db import run_pre_db_init_funcs\nfrom ..plugin import PluginData\nfrom . import command\nfrom .utils import Config, get_plugins\n\nP = ParamSpec(\"P\")\nR = TypeVar(\"R\")\n\n\ndef run_sync(func: Callable[P, R]) -> Callable[P, Coroutine[Any, Any, R]]:\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        return await anyio.to_thread.run_sync(partial(func, *args, **kwargs))\n\n    return wrapper\n\n\ndef run_async(func: Callable[P, Coroutine[Any, Any, R]]) -> Callable[P, R]:\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        return anyio.from_thread.run(partial(func, *args, **kwargs))\n\n    return wrapper\n\n\n@click.group()\ndef cli():\n    \"\"\"Datastore CLI\"\"\"\n    pass\n\n\n@cli.command()\n@click.option(\"--name\", \"-n\", default=None, help=\"插件名\")\n@click.option(\"-m\", \"--message\", default=None, help=\"Revision message\")\n@click.option(\n    \"--autogenerate\",\n    is_flag=True,\n    help=(\n        \"Populate revision script with candidate migration \"\n        \"operations, based on comparison of database to model\"\n    ),\n)\n@run_async\nasync def revision(name: Optional[str], message: Optional[str], autogenerate: bool):\n    \"\"\"创建迁移文件\"\"\"\n    plugins = get_plugins(name, True)\n    for plugin in plugins:\n        logger.info(f\"尝试生成插件 {plugin} 的迁移文件\")\n        config = Config(plugin, cmd_opts=Namespace(autogenerate=autogenerate))\n        await command.revision(config, message, autogenerate=autogenerate)\n\n\n@cli.command()\n@click.option(\"--name\", \"-n\", default=None, help=\"插件名\")\n@click.option(\"-m\", \"--message\", default=None, help=\"Revision message\")\n@run_async\nasync def migrate(name: Optional[str], message: Optional[str]):\n    \"\"\"自动根据模型更改创建迁移文件\"\"\"\n    plugins = get_plugins(name, True)\n    for plugin in plugins:\n        logger.info(f\"尝试生成插件 {plugin} 的迁移文件\")\n        config = Config(plugin, cmd_opts=Namespace(autogenerate=True))\n        await command.revision(config, message, autogenerate=True)\n\n\n@cli.command()\n@click.option(\"--name\", \"-n\", default=None, help=\"插件名\")\n@click.argument(\"revision\", default=\"head\")\n@run_async\nasync def upgrade(name: Optional[str], revision: str):\n    \"\"\"升级数据库版本\"\"\"\n    # 执行数据库初始化前执行的函数\n    # 比如 bison 需要在迁移之前把 alembic_version 表重命名\n    plugins = get_plugins(name)\n    for plugin in plugins:\n        await run_pre_db_init_funcs(plugin)\n        logger.info(f\"升级插件 {plugin} 的数据库\")\n        config = Config(plugin)\n        await command.upgrade(config, revision)\n\n\n@cli.command()\n@click.option(\"--name\", \"-n\", default=None, help=\"插件名\")\n@click.argument(\"revision\", default=\"-1\")\n@run_async\nasync def downgrade(name: Optional[str], revision: str):\n    \"\"\"降级数据库版本\"\"\"\n    plugins = get_plugins(name)\n    for plugin in plugins:\n        logger.info(f\"降级插件 {plugin} 的数据库\")\n        config = Config(plugin)\n        await command.downgrade(config, revision)\n\n\n@cli.command()\n@click.option(\"--name\", \"-n\", default=None, help=\"插件名\")\n@click.option(\"--rev-range\", \"-r\", default=None, help=\"Revision range\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"显示详细信息\")\n@click.option(\n    \"--indicate-current\",\n    \"-i\",\n    is_flag=True,\n    help=\"Indicate current revisions with (head) and (current)\",\n)\n@run_async\nasync def history(\n    name: Optional[str],\n    rev_range: Optional[str],\n    verbose: bool,\n    indicate_current: bool,\n):\n    \"\"\"数据库版本历史\"\"\"\n    plugins = get_plugins(name)\n    for plugin in plugins:\n        logger.info(f\"查看插件 {plugin} 的数据库历史\")\n        config = Config(plugin)\n        await command.history(config, rev_range, verbose, indicate_current)\n\n\n@cli.command()\n@click.option(\"--name\", \"-n\", default=None, help=\"插件名\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"显示详细信息\")\n@run_async\nasync def current(name: Optional[str], verbose: bool):\n    \"\"\"数据库当前版本\"\"\"\n    plugins = get_plugins(name)\n    for plugin in plugins:\n        logger.info(f\"查看插件 {plugin} 的数据库当前版本\")\n        config = Config(plugin)\n        await command.current(config, verbose)\n\n\n@cli.command()\n@click.option(\"--name\", \"-n\", default=None, help=\"插件名\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"显示详细信息\")\ndef heads(name: Optional[str], verbose: bool):\n    \"\"\"数据库最新版本\"\"\"\n    plugins = get_plugins(name)\n    for plugin in plugins:\n        logger.info(f\"查看插件 {plugin} 的数据库当前可用的 heads\")\n        config = Config(plugin)\n        command.heads(config, verbose)\n\n\n@cli.command()\n@click.option(\"--name\", \"-n\", default=None, help=\"插件名\")\n@run_async\nasync def check(name: Optional[str]):\n    \"\"\"数据库是否需要升级\"\"\"\n    plugins = get_plugins(name, True)\n    for plugin in plugins:\n        logger.info(f\"检查插件 {plugin} 的数据库是否需要新的迁移文件\")\n        config = Config(plugin)\n        await command.check(config)\n\n\n@cli.command()\n@click.option(\"--name\", \"-n\", default=None, help=\"插件名\")\ndef dir(name: Optional[str] = None):\n    \"\"\"数据存储路径\"\"\"\n    if name is None:\n        click.echo(\"当前存储路径:\")\n        click.echo(f\"缓存目录: {plugin_config.datastore_cache_dir}\")\n        click.echo(f\"配置目录: {plugin_config.datastore_config_dir}\")\n        click.echo(f\"数据目录: {plugin_config.datastore_data_dir}\")\n        return\n\n    plugins = get_plugins(name)\n    for plugin in plugins:\n        plugin_data = PluginData(plugin)\n        click.echo(f\"插件 {plugin} 的存储路径:\")\n        click.echo(f\"缓存目录: {plugin_data.cache_dir}\")\n        click.echo(f\"配置目录: {plugin_data.config_dir}\")\n        click.echo(f\"数据目录: {plugin_data.data_dir}\")\n\n\ndef main():\n    anyio.run(run_sync(cli))  # pragma: no cover\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/Blacklist/__init__.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/6/30-23:28\n@Desc: 黑名单管理插件\n@Ver : 1.0.0\n\"\"\"\nfrom .hook import check_blacklist  # 黑名单审核\nfrom .hook import check_group_switch  # 群开关检查\nfrom nonebot import on_startswith, on_regex\nfrom nonebot.adapters.onebot.v11 import Event, GroupMessageEvent, GROUP_OWNER, GROUP_ADMIN\nfrom Hiyori.Utils.Database import DB_User\nfrom Hiyori.Utils.Permissions import HIYORI_OWNER, HIYORI_ADMIN\nfrom Hiyori.Utils.Priority import Priority\nfrom nonebot.permission import SUPERUSER\nfrom nonebot.plugin import PluginMetadata\n\n__plugin_meta__ = PluginMetadata(\n    name=\"群聊开关\",\n    description=\"开启或关闭妃爱在对应群聊的响应。呜，妃爱还不想睡觉！\",\n    usage=\"#开机\\n\"\n          \"#妃爱 on\\n\"\n          \"#关机\\n\"\n          \"#妃爱 off\\n\",\n    extra={\n        \"CD_Weight\": 5,\n        \"permission\": \"群管/妃爱管理员及以上权限\",\n        \"example\": \"\",\n        \"Keep_On\": True,\n        \"Type\": \"Admin_Plugin\",\n    },\n)\n\nsetBlacklist = on_startswith((\"#设置黑名单\", \"#ban\"), priority=Priority.系统优先级, block=True,\n                             permission=HIYORI_OWNER | SUPERUSER)\nunsetBlacklist = on_startswith((\"#解除黑名单\", \"#unban\"), priority=Priority.系统优先级, block=True,\n                               permission=HIYORI_OWNER | SUPERUSER)\nswitchOn = on_regex(r\"(^#开机$)|(^#?switch\\s+on$)|(^#?change\\s+status\\s+on$)|(^#?妃爱\\s*on$)\", priority=Priority.系统优先级, block=True,\n                    permission=HIYORI_OWNER | SUPERUSER | GROUP_OWNER | GROUP_ADMIN | HIYORI_ADMIN)\nswitchOff = on_regex(r\"(^#关机$)|(^#?switch\\s+off$)|(^#?change\\s+status\\s+off$)|(^#?妃爱\\s*off$)\", priority=Priority.系统优先级,\n                     block=True,\n                     permission=HIYORI_OWNER | SUPERUSER | GROUP_OWNER | GROUP_ADMIN | HIYORI_ADMIN)\n\n\n# config = get_driver().config  # 获取nb env文件属性的方法\n# config.superusers  # 举例 获取全部的superusers\n\n# 设置黑名单\n@setBlacklist.handle()\nasync def _(event: Event):\n    # 指令处理解析\n    message = str(event.message)\n    message = message.replace(\"#设置黑名单\", \"\").lstrip()\n    message = message.replace(\"#ban\", \"\").lstrip()\n    # -u 指令 根据QQ号进行封禁用户\n    if message.startswith(\"-u\") or message.startswith(\"-U\"):\n        message = message.replace(\"-u\", \"\").lstrip()\n        message = message.replace(\"-U\", \"\").lstrip()\n        # 通过直接@获取QQ号\n        if message.startswith(\"[CQ:at,qq=\"):\n            message = message.replace(\"[CQ:at,qq=\", \"\")\n            message = message.replace(\"]\", \"\")\n        # 检查输入格式是否正确\n        if message.isdigit():\n            QQ = int(message)\n            # 若未查询到用户，则会先刷新一遍\n            if not DB_User.hasUser(QQ):\n                await DB_User.refreshAll()\n                if not DB_User.hasUser(QQ):\n                    await setBlacklist.send(\"用户不存在\")\n                    return\n            user = DB_User.getUser(QQ)\n            user.Permission = 3\n            DB_User.updateUser(user)\n            await setBlacklist.send(\"封禁成功\")\n            return\n        else:\n            await setBlacklist.send(\"QQ格式不正确\")\n    # -g 指令 根据群号进行封禁\n    elif message.startswith(\"-g\") or message.startswith(\"-G\"):\n        message = message.replace(\"-g\", \"\").lstrip()\n        message = message.replace(\"-G\", \"\").lstrip()\n        # 若message已为空，则封禁群组\n        if len(message) == 0:\n            if hasattr(event, \"group_id\"):\n                GroupID = event.group_id\n                group = DB_User.getGroup(GroupID)\n                group.Permission = 3\n                DB_User.updateGroup(group)\n                await setBlacklist.send(\"封禁成功\")\n            else:\n                await setBlacklist.send(\"需要在群内发送\")\n            return\n        # 若message不为空，则解析群号\n        if message.isdigit():\n            GroupID = int(message)\n            # 若未查询到用户，则会先刷新一遍\n            if not DB_User.hasGroup(GroupID):\n                await DB_User.refreshAll()\n                if not DB_User.hasGroup(GroupID):\n                    await setBlacklist.send(\"群组不存在\")\n                    return\n            group = DB_User.getGroup(GroupID)\n            group.Permission = 3\n            DB_User.updateGroup(group)\n            await setBlacklist.send(\"封禁成功\")\n            return\n        else:\n            await setBlacklist.send(\"群号格式不正确\")\n\n\n# 解除黑名单\n# noinspection DuplicatedCode\n@unsetBlacklist.handle()\nasync def _(event: Event):\n    # 指令处理解析\n    message = str(event.message)\n    message = message.replace(\"#解除黑名单\", \"\").lstrip()\n    message = message.replace(\"#unban\", \"\").lstrip()\n    # -u 指令 根据QQ号进行用户解封\n    if message.startswith(\"-u\") or message.startswith(\"-U\"):\n        message = message.replace(\"-u\", \"\").lstrip()\n        message = message.replace(\"-U\", \"\").lstrip()\n        # 通过直接@获取QQ号\n        if message.startswith(\"[CQ:at,qq=\"):\n            message = message.replace(\"[CQ:at,qq=\", \"\")\n            message = message.replace(\"]\", \"\")\n        # 检查输入格式是否正确\n        if message.isdigit():\n            QQ = int(message)\n            # 若未查询到用户，则会先刷新一遍\n            if not DB_User.hasUser(QQ):\n                await DB_User.refreshAll()\n                if not DB_User.hasUser(QQ):\n                    await setBlacklist.send(\"用户不存在\")\n                    return\n            user = DB_User.getUser(QQ)\n            user.Permission = 2\n            DB_User.updateUser(user)\n            await setBlacklist.send(\"解封成功\")\n            return\n        else:\n            await setBlacklist.send(\"QQ格式不正确\")\n    # -g 指令 根据群号进行封禁\n    elif message.startswith(\"-g\") or message.startswith(\"-G\"):\n        message = message.replace(\"-g\", \"\").lstrip()\n        message = message.replace(\"-G\", \"\").lstrip()\n        # 若message已为空，则封禁群组\n        if len(message) == 0:\n            if hasattr(event, \"group_id\"):\n                GroupID = event.group_id\n                group = DB_User.getGroup(GroupID)\n                group.Permission = 2\n                DB_User.updateGroup(group)\n                await setBlacklist.send(\"解封成功\")\n            else:\n                await setBlacklist.send(\"需要在群内发送\")\n            return\n        # 若message不为空，则解析群号\n        if message.isdigit():\n            GroupID = int(message)\n            # 若未查询到用户，则会先刷新一遍\n            if not DB_User.hasGroup(GroupID):\n                await DB_User.refreshAll()\n                if not DB_User.hasGroup(GroupID):\n                    await setBlacklist.send(\"群组不存在\")\n                    return\n            group = DB_User.getGroup(GroupID)\n            group.Permission = 2\n            DB_User.updateGroup(group)\n            await setBlacklist.send(\"解封成功\")\n            return\n        else:\n            await setBlacklist.send(\"群号格式不正确\")\n\n\n# 群状态改为开启\n@switchOn.handle()\nasync def _(event: GroupMessageEvent):\n    GroupID = event.group_id\n    Group = DB_User.getGroup(GroupID)\n    if Group.Status != \"on\":\n        Group.Status = \"on\"\n        DB_User.updateGroup(Group)\n        await switchOn.send(\"妃爱开机啦~\")\n    else:\n        await switchOn.send(\"好烦哦，妃爱已经开机啦！\")\n\n\n# 群状态改为关机\n@switchOff.handle()\nasync def _(event: GroupMessageEvent):\n    GroupID = event.group_id\n    Group = DB_User.getGroup(GroupID)\n    if Group.Status != \"off\":\n        Group.Status = \"off\"\n        DB_User.updateGroup(Group)\n        await switchOff.send(\"妃爱关机啦~\")\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/script/__init__.py", "content": ""}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/migrations/0f8d23241fd7_.py", "content": "\"\"\"init db\n\nRevision ID: 0f8d23241fd7\nRevises:\nCreate Date: 2023-03-01 14:18:54.876322\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = \"0f8d23241fd7\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"nonebot_plugin_datastore_configmodel\",\n        sa.Column(\"key\", sa.String(), nullable=False),\n        sa.Column(\"value\", sa.JSON(), nullable=False),\n        sa.PrimaryKeyConstraint(\"key\"),\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table(\"nonebot_plugin_datastore_configmodel\")\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/plugin.py", "content": "\"\"\" 插件数据 \"\"\"\nimport json\nimport pickle\nfrom pathlib import Path\nfrom typing import Any, Callable, Generic, Optional, Type, TypeVar\n\nimport httpx\nfrom nonebot import get_plugin\nfrom nonebot.log import logger\nfrom sqlalchemy import MetaData\nfrom sqlalchemy.orm import DeclarativeBase, declared_attr, registry\n\nfrom .config import plugin_config\nfrom .providers import ConfigProvider\nfrom .utils import get_caller_plugin_name, resolve_dot_notation\n\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n\n\nclass NetworkFile(Generic[T, R]):\n    \"\"\"从网络获取文件\n\n    暂时只支持 json 格式\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        filename: str,\n        plugin_data: \"PluginData\",\n        process_data: Optional[Callable[[T], R]] = None,\n        cache: bool = False,\n    ) -> None:\n        self._url = url\n        self._filename = filename\n        self._plugin_data = plugin_data\n        self._process_data = process_data\n        self._cache = cache\n\n        self._data: Optional[R] = None\n\n    async def load_from_network(self) -> T:\n        \"\"\"从网络加载文件\"\"\"\n        logger.info(\"正在从网络获取数据\")\n        content = await self._plugin_data.download_file(\n            self._url, self._filename, self._cache\n        )\n        rjson = json.loads(content)\n        return rjson\n\n    def load_from_local(self) -> T:\n        \"\"\"从本地获取数据\"\"\"\n        logger.info(\"正在加载本地数据\")\n        data = self._plugin_data.load_json(self._filename, self._cache)\n        return data\n\n    @property\n    async def data(self) -> R:\n        \"\"\"数据\n\n        先从本地加载，如果本地文件不存在则从网络加载\n        \"\"\"\n        if self._data is None:\n            if self._plugin_data.exists(self._filename, self._cache):\n                data = self.load_from_local()\n            else:\n                data = await self.load_from_network()\n            # 处理数据\n            if self._process_data:\n                self._data = self._process_data(data)\n            else:\n                self._data = data  # type: ignore\n        return self._data  # type: ignore\n\n    async def update(self) -> None:\n        \"\"\"从网络更新数据\"\"\"\n        self._data = await self.load_from_network()  # type: ignore\n        if self._process_data:\n            self._data = self._process_data(self._data)\n\n\nclass Singleton(type):\n    \"\"\"单例\n\n    每个相同名称的插件数据只需要一个实例\n    \"\"\"\n\n    _instances = {}\n\n    def __call__(cls, name: str):\n        if not cls._instances.get(name):\n            cls._instances[name] = super().__call__(name)\n        return cls._instances[name]\n\n\nclass PluginData(metaclass=Singleton):\n    \"\"\"插件数据管理\n\n    将插件数据保存在 `data` 文件夹对应的目录下。\n    提供保存和读取文件/数据的方法。\n    \"\"\"\n\n    def __init__(self, name: str) -> None:\n        # 插件名，用来确定插件的文件夹位置\n        self.name = name\n\n        # 插件配置\n        self._config = None\n\n        # 数据库\n        self._metadata = None\n        self._model = None\n        self._migration_path = None\n\n    @staticmethod\n    def _ensure_dir(path: Path):\n        \"\"\"确保目录存在\"\"\"\n        if not path.exists():\n            path.mkdir(parents=True, exist_ok=True)\n        elif not path.is_dir():\n            raise RuntimeError(f\"{path} 不是目录\")\n\n    @property\n    def cache_dir(self) -> Path:\n        \"\"\"缓存目录\"\"\"\n        directory = plugin_config.datastore_cache_dir / self.name\n        # 每次调用都检查一下目录是否存在\n        # 防止运行时有人删除目录\n        self._ensure_dir(directory)\n        return directory\n\n    @property\n    def config_dir(self) -> Path:\n        \"\"\"配置目录\n\n        配置都放置在统一的目录下\n        \"\"\"\n        directory = plugin_config.datastore_config_dir\n        self._ensure_dir(directory)\n        return directory\n\n    @property\n    def data_dir(self) -> Path:\n        \"\"\"数据目录\"\"\"\n        directory = plugin_config.datastore_data_dir / self.name\n        self._ensure_dir(directory)\n        return directory\n\n    @property\n    def config(self) -> ConfigProvider:\n        \"\"\"获取配置管理\"\"\"\n        if not self._config:\n            self._config = _ProviderClass(self)\n        return self._config\n\n    def dump_pkl(self, data: Any, filename: str, cache: bool = False, **kwargs) -> None:\n        with self.open(filename, \"wb\", cache=cache) as f:\n            pickle.dump(data, f, **kwargs)  # type: ignore\n\n    def load_pkl(self, filename: str, cache: bool = False, **kwargs) -> Any:\n        with self.open(filename, \"rb\", cache=cache) as f:\n            data = pickle.load(f, **kwargs)\n        return data\n\n    def dump_json(\n        self,\n        data: Any,\n        filename: str,\n        cache: bool = False,\n        ensure_ascii: bool = False,\n        **kwargs,\n    ) -> None:\n        with self.open(filename, \"w\", cache=cache, encoding=\"utf8\") as f:\n            json.dump(data, f, ensure_ascii=ensure_ascii, **kwargs)\n\n    def load_json(self, filename: str, cache: bool = False, **kwargs) -> Any:\n        with self.open(filename, \"r\", cache=cache, encoding=\"utf8\") as f:\n            data = json.load(f, **kwargs)\n        return data\n\n    def open(self, filename: str, mode: str = \"r\", cache: bool = False, **kwargs):\n        \"\"\"打开文件，默认打开数据文件夹下的文件\"\"\"\n        if cache:\n            path = self.cache_dir / filename\n        else:\n            path = self.data_dir / filename\n        return open(path, mode, **kwargs)\n\n    def exists(self, filename: str, cache: bool = False) -> bool:\n        \"\"\"判断文件是否存在，默认判断数据文件夹下的文件\"\"\"\n        if cache:\n            path = self.cache_dir / filename\n        else:\n            path = self.data_dir / filename\n        return path.exists()\n\n    async def download_file(\n        self, url: str, filename: str, cache: bool = False, **kwargs\n    ) -> bytes:\n        \"\"\"下载文件\"\"\"\n        async with httpx.AsyncClient() as client:\n            r = await client.get(url, **kwargs)\n            content = r.content\n            with self.open(filename, \"wb\", cache=cache) as f:\n                f.write(content)\n            logger.info(f\"已下载文件 {url} -> {filename}\")\n            return content\n\n    def network_file(\n        self,\n        url: str,\n        filename: str,\n        process_data: Optional[Callable[[T], R]] = None,\n        cache: bool = False,\n    ) -> NetworkFile[T, R]:\n        \"\"\"网络文件\n\n        从网络上获取数据，并缓存至本地，仅支持 json 格式\n        且可以在获取数据之后同时处理数据\n        \"\"\"\n        return NetworkFile[T, R](url, filename, self, process_data, cache)\n\n    @property\n    def Model(self) -> Type[DeclarativeBase]:\n        \"\"\"数据库模型\"\"\"\n        if self._model is None:\n            self._metadata = MetaData(info={\"name\": self.name})\n\n            # 为每个插件创建一个独立的 registry\n            plugin_registry = registry(metadata=self._metadata)\n\n            class _Base(DeclarativeBase):\n                registry = plugin_registry\n\n                @declared_attr.directive\n                def __tablename__(cls) -> str:\n                    \"\"\"设置表名前缀，避免表名冲突\n\n                    规则为：插件名_表名\n                    https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html#augmenting-the-base\n                    \"\"\"\n                    return f\"{self.name}_{cls.__name__.lower()}\"\n\n            self._model = _Base\n        return self._model\n\n    @property\n    def metadata(self) -> Optional[MetaData]:\n        \"\"\"获取数据库元数据\"\"\"\n        return self._metadata\n\n    @property\n    def migration_dir(self) -> Optional[Path]:\n        \"\"\"数据库迁移文件夹\"\"\"\n        if self._migration_path is None:\n            plugin = get_plugin(self.name)\n            if plugin and plugin.module.__file__ and PluginData(plugin.name).metadata:\n                self._migration_path = (\n                    Path(plugin.module.__file__).parent / \"migrations\"\n                )\n        return self._migration_path\n\n    def set_migration_dir(self, path: Path) -> None:\n        \"\"\"设置数据库迁移文件夹\"\"\"\n        self._migration_path = path\n\n\ndef get_plugin_data(name: Optional[str] = None) -> PluginData:\n    \"\"\"获取插件数据\n\n    如果名称为空，则尝试自动获取调用者所在的插件名\n    \"\"\"\n    name = name or get_caller_plugin_name()\n\n    return PluginData(name)\n\n\n# 需要等到 PluginData 和 get_plugin_data 定义后才能导入对应的配置\n_ProviderClass = resolve_dot_notation(\n    plugin_config.datastore_config_provider,\n    default_attr=\"Config\",\n    default_prefix=\"nonebot_plugin_datastore.providers.\",\n)\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/providers/toml.py", "content": "try:\n    import rtoml\nexcept ImportError as e:  # pragma: no cover\n    raise ImportError(\"请使用 `pip install nonebot-plugin-datastore[toml]` 安装所需依赖\") from e\n\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\n\nfrom . import ConfigProvider, KeyNotFoundError\n\nif TYPE_CHECKING:\n    from ..plugin import PluginData\n\n\nclass Config(ConfigProvider):\n    \"\"\"toml 格式配置\"\"\"\n\n    def __init__(self, plugin_data: \"PluginData\") -> None:\n        super().__init__(plugin_data)\n        self._data = {}\n        self._load_config()\n\n    @property\n    def _path(self) -> Path:\n        \"\"\"配置文件路径\"\"\"\n        return self._plugin_data.config_dir / f\"{self._plugin_data.name}.toml\"\n\n    def _ensure_config(self) -> None:\n        \"\"\"确保配置文件存在\"\"\"\n        if not self._path.exists():\n            with self._path.open(\"w\", encoding=\"utf8\") as f:\n                rtoml.dump(self._data, f)\n\n    def _load_config(self) -> None:\n        \"\"\"读取配置\"\"\"\n        self._ensure_config()\n        with self._path.open(\"r\", encoding=\"utf8\") as f:\n            self._data = rtoml.load(f)\n\n    def _save_config(self) -> None:\n        \"\"\"保存配置\"\"\"\n        self._ensure_config()\n        with self._path.open(\"w\", encoding=\"utf8\") as f:\n            rtoml.dump(self._data, f)\n\n    async def _get(self, key: str) -> Any:\n        if not self._data:\n            self._load_config()\n        try:\n            return self._data[key]\n        except KeyError:\n            raise KeyNotFoundError(key)\n\n    async def _set(self, key: str, value: Any) -> None:\n        self._data[key] = value\n        self._save_config()\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/script/command.py", "content": "\"\"\" 直接将 Alembic 的代码抄过来，然后改成异步\n\nversion: 1.9.2\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom alembic.autogenerate.api import RevisionContext\nfrom alembic.runtime.environment import EnvironmentContext\nfrom alembic.script import ScriptDirectory\nfrom alembic.util.exc import AutogenerateDiffsDetected, CommandError\nfrom alembic.util.messaging import obfuscate_url_pw\nfrom sqlalchemy.util.langhelpers import asbool\n\nfrom .utils import run_migration\n\nif TYPE_CHECKING:\n    from alembic.config import Config\n    from alembic.runtime.environment import ProcessRevisionDirectiveFn\n    from alembic.script.base import Script\n\n\nasync def revision(\n    config: Config,\n    message: str | None = None,\n    autogenerate: bool = False,\n    sql: bool = False,\n    head: str = \"head\",\n    splice: bool = False,\n    branch_label: str | None = None,\n    version_path: str | None = None,\n    rev_id: str | None = None,\n    depends_on: str | None = None,\n    process_revision_directives: ProcessRevisionDirectiveFn | None = None,\n) -> Script | None | list[Script | None]:\n    \"\"\"Create a new revision file.\n\n    :param config: a :class:`.Config` object.\n\n    :param message: string message to apply to the revision; this is the\n     ``-m`` option to ``alembic revision``.\n\n    :param autogenerate: whether or not to autogenerate the script from\n     the database; this is the ``--autogenerate`` option to\n     ``alembic revision``.\n\n    :param sql: whether to dump the script out as a SQL string; when specified,\n     the script is dumped to stdout.  This is the ``--sql`` option to\n     ``alembic revision``.\n\n    :param head: head revision to build the new revision upon as a parent;\n     this is the ``--head`` option to ``alembic revision``.\n\n    :param splice: whether or not the new revision should be made into a\n     new head of its own; is required when the given ``head`` is not itself\n     a head.  This is the ``--splice`` option to ``alembic revision``.\n\n    :param branch_label: string label to apply to the branch; this is the\n     ``--branch-label`` option to ``alembic revision``.\n\n    :param version_path: string symbol identifying a specific version path\n     from the configuration; this is the ``--version-path`` option to\n     ``alembic revision``.\n\n    :param rev_id: optional revision identifier to use instead of having\n     one generated; this is the ``--rev-id`` option to ``alembic revision``.\n\n    :param depends_on: optional list of \"depends on\" identifiers; this is the\n     ``--depends-on`` option to ``alembic revision``.\n\n    :param process_revision_directives: this is a callable that takes the\n     same form as the callable described at\n     :paramref:`.EnvironmentContext.configure.process_revision_directives`;\n     will be applied to the structure generated by the revision process\n     where it can be altered programmatically.   Note that unlike all\n     the other parameters, this option is only available via programmatic\n     use of :func:`.command.revision`\n\n    \"\"\"\n\n    script_directory = ScriptDirectory.from_config(config)\n\n    command_args = dict(\n        message=message,\n        autogenerate=autogenerate,\n        sql=sql,\n        head=head,\n        splice=splice,\n        branch_label=branch_label,\n        version_path=version_path,\n        rev_id=rev_id,\n        depends_on=depends_on,\n    )\n    revision_context = RevisionContext(\n        config,\n        script_directory,\n        command_args,\n        process_revision_directives=process_revision_directives,\n    )\n\n    environment = asbool(config.get_main_option(\"revision_environment\"))\n\n    if autogenerate:\n        environment = True\n\n        if sql:\n            raise CommandError(\n                \"Using --sql with --autogenerate does not make any sense\"\n            )\n\n        def retrieve_migrations(rev, context):\n            revision_context.run_autogenerate(rev, context)\n            return []\n\n    elif environment:\n\n        def retrieve_migrations(rev, context):\n            revision_context.run_no_autogenerate(rev, context)\n            return []\n\n    elif sql:\n        raise CommandError(\n            \"Using --sql with the revision command when \"\n            \"revision_environment is not configured does not make any sense\"\n        )\n\n    if environment:\n        with EnvironmentContext(\n            config,\n            script_directory,\n            fn=retrieve_migrations,  # type: ignore\n            as_sql=sql,\n            template_args=revision_context.template_args,\n            revision_context=revision_context,\n        ):\n            await run_migration()\n\n        # the revision_context now has MigrationScript structure(s) present.\n        # these could theoretically be further processed / rewritten *here*,\n        # in addition to the hooks present within each run_migrations() call,\n        # or at the end of env.py run_migrations_online().\n\n    scripts = [script for script in revision_context.generate_scripts()]\n    if len(scripts) == 1:\n        return scripts[0]\n    else:\n        return scripts\n\n\nasync def check(\n    config: Config,\n) -> None:\n    \"\"\"Check if revision command with autogenerate has pending upgrade ops.\n\n    :param config: a :class:`.Config` object.\n\n    .. versionadded:: 1.9.0\n\n    \"\"\"\n\n    script_directory = ScriptDirectory.from_config(config)\n\n    command_args = dict(\n        message=None,\n        autogenerate=True,\n        sql=False,\n        head=\"head\",\n        splice=False,\n        branch_label=None,\n        version_path=None,\n        rev_id=None,\n        depends_on=None,\n    )\n    revision_context = RevisionContext(\n        config,\n        script_directory,\n        command_args,\n    )\n\n    def retrieve_migrations(rev, context):\n        revision_context.run_autogenerate(rev, context)\n        return []\n\n    with EnvironmentContext(\n        config,\n        script_directory,\n        fn=retrieve_migrations,\n        as_sql=False,\n        template_args=revision_context.template_args,\n        revision_context=revision_context,\n    ):\n        await run_migration()\n\n    # the revision_context now has MigrationScript structure(s) present.\n\n    migration_script = revision_context.generated_revisions[-1]\n    diffs = migration_script.upgrade_ops.as_diffs()  # type: ignore\n    if diffs:\n        raise AutogenerateDiffsDetected(f\"New upgrade operations detected: {diffs}\")\n    else:\n        config.print_stdout(\"No new upgrade operations detected.\")\n\n\nasync def upgrade(\n    config: Config,\n    revision: str,\n    sql: bool = False,\n    tag: str | None = None,\n) -> None:\n    \"\"\"Upgrade to a later version.\n\n    :param config: a :class:`.Config` instance.\n\n    :param revision: string revision target or range for --sql mode\n\n    :param sql: if True, use ``--sql`` mode\n\n    :param tag: an arbitrary \"tag\" that can be intercepted by custom\n     ``env.py`` scripts via the :meth:`.EnvironmentContext.get_tag_argument`\n     method.\n\n    \"\"\"\n\n    script = ScriptDirectory.from_config(config)\n\n    starting_rev = None\n    if \":\" in revision:\n        if not sql:\n            raise CommandError(\"Range revision not allowed\")\n        starting_rev, revision = revision.split(\":\", 2)\n\n    def upgrade(rev, context):\n        return script._upgrade_revs(revision, rev)\n\n    with EnvironmentContext(\n        config,\n        script,\n        fn=upgrade,\n        as_sql=sql,\n        starting_rev=starting_rev,\n        destination_rev=revision,\n        tag=tag,\n    ):\n        await run_migration()\n\n\nasync def downgrade(\n    config: Config,\n    revision: str,\n    sql: bool = False,\n    tag: str | None = None,\n) -> None:\n    \"\"\"Revert to a previous version.\n\n    :param config: a :class:`.Config` instance.\n\n    :param revision: string revision target or range for --sql mode\n\n    :param sql: if True, use ``--sql`` mode\n\n    :param tag: an arbitrary \"tag\" that can be intercepted by custom\n     ``env.py`` scripts via the :meth:`.EnvironmentContext.get_tag_argument`\n     method.\n\n    \"\"\"\n\n    script = ScriptDirectory.from_config(config)\n    starting_rev = None\n    if \":\" in revision:\n        if not sql:\n            raise CommandError(\"Range revision not allowed\")\n        starting_rev, revision = revision.split(\":\", 2)\n    elif sql:\n        raise CommandError(\"downgrade with --sql requires <fromrev>:<torev>\")\n\n    def downgrade(rev, context):\n        return script._downgrade_revs(revision, rev)\n\n    with EnvironmentContext(\n        config,\n        script,\n        fn=downgrade,\n        as_sql=sql,\n        starting_rev=starting_rev,\n        destination_rev=revision,\n        tag=tag,\n    ):\n        await run_migration()\n\n\nasync def history(\n    config: Config,\n    rev_range: str | None = None,\n    verbose: bool = False,\n    indicate_current: bool = False,\n) -> None:\n    \"\"\"List changeset scripts in chronological order.\n\n    :param config: a :class:`.Config` instance.\n\n    :param rev_range: string revision range\n\n    :param verbose: output in verbose mode.\n\n    :param indicate_current: indicate current revision.\n\n    \"\"\"\n    base: str | None\n    head: str | None\n    script = ScriptDirectory.from_config(config)\n    if rev_range is not None:\n        if \":\" not in rev_range:\n            raise CommandError(\n                \"History range requires [start]:[end], \" \"[start]:, or :[end]\"\n            )\n        base, head = rev_range.strip().split(\":\")\n    else:\n        base = head = None\n\n    environment = (\n        asbool(config.get_main_option(\"revision_environment\")) or indicate_current\n    )\n\n    def _display_history(config, script, base, head, currents=()):\n        for sc in script.walk_revisions(base=base or \"base\", head=head or \"heads\"):\n            if indicate_current:\n                sc._db_current_indicator = sc.revision in currents\n\n            config.print_stdout(\n                sc.cmd_format(\n                    verbose=verbose,\n                    include_branches=True,\n                    include_doc=True,\n                    include_parents=True,\n                )\n            )\n\n    async def _display_history_w_current(config, script, base, head):\n        def _display_current_history(rev, context):\n            if head == \"current\":\n                _display_history(config, script, base, rev, rev)\n            elif base == \"current\":\n                _display_history(config, script, rev, head, rev)\n            else:\n                _display_history(config, script, base, head, rev)\n            return []\n\n        with EnvironmentContext(config, script, fn=_display_current_history):\n            await run_migration()\n\n    if base == \"current\" or head == \"current\" or environment:\n        await _display_history_w_current(config, script, base, head)\n    else:\n        _display_history(config, script, base, head)\n\n\ndef heads(config, verbose=False, resolve_dependencies=False):\n    \"\"\"Show current available heads in the script directory.\n\n    :param config: a :class:`.Config` instance.\n\n    :param verbose: output in verbose mode.\n\n    :param resolve_dependencies: treat dependency version as down revisions.\n\n    \"\"\"\n\n    script = ScriptDirectory.from_config(config)\n    if resolve_dependencies:\n        heads = script.get_revisions(\"heads\")\n    else:\n        heads = script.get_revisions(script.get_heads())\n\n    for rev in heads:\n        config.print_stdout(\n            rev.cmd_format(verbose, include_branches=True, tree_indicators=False)  # type: ignore\n        )\n\n\nasync def current(config: Config, verbose: bool = False) -> None:\n    \"\"\"Display the current revision for a database.\n\n    :param config: a :class:`.Config` instance.\n\n    :param verbose: output in verbose mode.\n\n    \"\"\"\n\n    script = ScriptDirectory.from_config(config)\n\n    def display_version(rev, context):\n        if verbose:\n            config.print_stdout(\n                \"Current revision(s) for %s:\",\n                obfuscate_url_pw(context.connection.engine.url),\n            )\n        for rev in script.get_all_current(rev):\n            config.print_stdout(rev.cmd_format(verbose))  # type: ignore\n\n        return []\n\n    with EnvironmentContext(config, script, fn=display_version, dont_mutate=True):\n        await run_migration()\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/script/utils.py", "content": "from pathlib import Path\nfrom typing import TYPE_CHECKING, List, Optional\n\nfrom alembic import context\nfrom alembic.config import Config as AlembicConfig\nfrom click import BadParameter\nfrom nonebot import get_loaded_plugins, get_plugin\nfrom nonebot.log import logger\n\nfrom ..db import get_engine\nfrom ..plugin import PluginData\n\nif TYPE_CHECKING:\n    from nonebot.plugin import Plugin\n\nSCRIPT_LOCATION = Path(__file__).parent / \"migration\"\n\n\ndef get_plugins(name: Optional[str] = None, exclude_others: bool = False) -> List[str]:\n    \"\"\"获取使用了数据库的插件名\"\"\"\n\n    def _should_include(plugin: \"Plugin\") -> bool:\n        # 使用了数据库\n        if not PluginData(plugin.name).metadata:\n            return False\n\n        # 有文件\n        if not plugin.module.__file__:\n            return False  # pragma: no cover\n\n        # 是否排除当前项目外的插件\n        if exclude_others:\n            # 排除 site-packages 中的插件\n            if \"site-packages\" in plugin.module.__file__:\n                return False  # pragma: no cover\n            # 在当前项目目录中\n            if Path.cwd() not in Path(plugin.module.__file__).parents:\n                return False\n\n        return True\n\n    if name is None:\n        return [\n            plugin.name for plugin in get_loaded_plugins() if _should_include(plugin)\n        ]\n\n    if (plugin := get_plugin(name)) and _should_include(plugin):\n        return [plugin.name]\n\n    raise BadParameter(message=\"未找到插件\", param_hint=\"name\")\n\n\nclass Config(AlembicConfig):\n    def __init__(self, plugin_name, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_main_option(\"plugin_name\", plugin_name)\n        self.set_main_option(\"script_location\", str(SCRIPT_LOCATION))\n        self.set_main_option(\n            \"version_locations\", str(PluginData(plugin_name).migration_dir)\n        )\n        self.set_main_option(\"version_path_separator\", \"os\")\n\n\ndef do_run_migrations(connection, plugin_name: Optional[str] = None):\n    config = context.config\n\n    if plugin_name is None:\n        plugin_name = config.get_main_option(\"plugin_name\")\n\n    if not plugin_name:\n        raise ValueError(\"未指定插件名称\")  # pragma: no cover\n\n    target_metadata = PluginData(plugin_name).metadata\n\n    # 不生成空的迁移文件\n    # https://alembic.sqlalchemy.org/en/latest/cookbook.html#don-t-generate-empty-migrations-with-autogenerate\n    def process_revision_directives(context, revision, directives):\n        if config.cmd_opts and config.cmd_opts.autogenerate:\n            script = directives[0]\n            if script.upgrade_ops.is_empty():\n                logger.info(\"模型未发生变化，已跳过生成迁移文件\")\n                directives[:] = []\n\n    def include_object(object, name, type_, reflected, compare_to):\n        if type_ == \"table\" and object.metadata.info.get(\"name\") != plugin_name:\n            return False\n        else:\n            return True\n\n    context.configure(\n        connection=connection,\n        target_metadata=target_metadata,\n        version_table=f\"{plugin_name}_alembic_version\",\n        include_object=include_object,\n        process_revision_directives=process_revision_directives,\n        render_as_batch=True,\n        compare_type=True,\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_migration(plugin_name: Optional[str] = None):\n    \"\"\"运行迁移\"\"\"\n    connectable = get_engine()\n\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations, plugin_name)\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/nonebot_plugin_datastore/utils.py", "content": "import importlib\nimport inspect\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING, Any, Optional\n\nimport pygtrie\nfrom nonebot import get_loaded_plugins\n\nif TYPE_CHECKING:\n    from nonebot.plugin import Plugin\n\n\ndef get_caller_plugin_name() -> str:\n    \"\"\"获取当前函数调用者所在的插件名\n\n    尝试自动获取调用者所在的插件名\n    \"\"\"\n    name = None\n    if frame := inspect.currentframe():\n        # 因为是在插件内部调用，所以调用栈为\n        # 1. 当前函数\n        # 2. 调用者函数\n        # 3. 调用者所在的插件\n        # 需要往回跳两次\n        frame = frame.f_back.f_back  # type: ignore\n        if not frame:\n            raise ValueError(\"无法找到调用者\")  # pragma: no cover\n\n        module_name = frame.f_locals[\"__name__\"]\n        plugin = _get_plugin_by_module_name(module_name)\n        if plugin:\n            name = plugin.name\n\n    if not name:\n        raise ValueError(\"自动获取插件名失败\")\n\n    return name\n\n\n@lru_cache\ndef _get_plugin_by_module_name(module_name: str) -> Optional[\"Plugin\"]:\n    \"\"\"通过模块名获取插件\"\"\"\n    t = pygtrie.StringTrie(separator=\".\")\n    for plugin in get_loaded_plugins():\n        t[plugin.module_name] = plugin\n    plugin = t.longest_prefix(module_name).value\n    return plugin\n\n\ndef resolve_dot_notation(\n    obj_str: str, default_attr: str, default_prefix: Optional[str] = None\n) -> Any:\n    \"\"\"解析并导入点分表示法的对象\"\"\"\n    modulename, _, cls = obj_str.partition(\":\")\n    if default_prefix is not None and modulename.startswith(\"~\"):\n        modulename = default_prefix + modulename[1:]\n    module = importlib.import_module(modulename)\n    if not cls:\n        return getattr(module, default_attr)\n    instance = module\n    for attr_str in cls.split(\".\"):\n        instance = getattr(instance, attr_str)\n    return instance\n"}
{"type": "source_file", "path": "Hiyori/Plugins/Basic_plugins/MultiBot_Support/config.py", "content": "\"\"\"\n@Author: Kasugano Sora\n@Github: https://github.com/jiangyuxiaoxiao\n@Date: 2023/8/4-8:58\n@Desc: 配置函数，注意，在本插件实现中，QQ与GroupID均为str类型\n@Ver : 1.0.0\n\"\"\"\nimport json\nimport os\nfrom Hiyori.Utils.File import JsonFileExist, DirExist\nfrom Hiyori.Utils.Config import Config\n\nConfigPath = \"./Config/MultiBot_Support/config.json\"\nConfigDir = os.path.dirname(ConfigPath)\n\n\nclass MultiBotConfig(Config):\n    \"\"\"单例类 MultiBotConfig\\n\n    在配置文件中的保存格式： \\n\n    {\n        \"默认优先顺序\":[\"1234\",\"1235\"],  \\n\n        \"群组规则\":{\n            \"1234588\":\"1234\",  \\n\n            \"762183\":\"1235\"  \\n\n        }\n    }\n    \"\"\"\n\n    def __init__(self):\n        initContent = {\n            \"默认优先顺序\": [],\n            \"群组规则\": {\n            }\n        }\n        DirExist(ConfigDir)\n        JsonFileExist(Path=ConfigPath, initContent=initContent, logEnable=True, logInfo=\"【多Bot连接支持插件】配置文件不存在，正在创建中。\")\n        with open(file=ConfigPath, mode=\"r\", encoding=\"utf-8\") as file:\n            config = json.loads(file.read())\n            self.priority: list[str] = config[\"默认优先顺序\"]\n            self.rule: dict[str, str] = config[\"群组规则\"]\n            self.groupSet: dict[str, set[str]] = {}  # 检查对应Bot是否在群组中，key=Bot_QQ, value=群组set\n            self.activeBots: set[str] = set()  # 检查对应Bot是否已注册成功\n\n    def dump(self):\n        \"\"\"导出到配置文件中\"\"\"\n        with open(file=ConfigPath, mode=\"w\", encoding=\"utf-8\") as file:\n            content = {\n                \"默认优先顺序\": self.priority,\n                \"群组规则\": self.rule\n            }\n            file.write(json.dumps(content, ensure_ascii=False, indent=2))\n\n    def load(self):\n        \"\"\"从配置文件中导入\"\"\"\n        initContent = {\n            \"默认优先顺序\": [],\n            \"群组规则\": {\n            }\n        }\n        JsonFileExist(Path=ConfigPath, initContent=initContent, logEnable=True, logInfo=\"【多Bot连接支持插件】群组规则不存在，正在创建中。\")\n        with open(file=ConfigPath, mode=\"r\", encoding=\"utf-8\") as file:\n            config = json.loads(file.read())\n            self.priority: list[str] = config[\"默认优先顺序\"]\n            self.rule: dict[str, str] = config[\"群组规则\"]\n\n\nmultiBotConfig: MultiBotConfig = MultiBotConfig()\n"}

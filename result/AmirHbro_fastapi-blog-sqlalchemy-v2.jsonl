{"repo_info": {"repo_name": "fastapi-blog-sqlalchemy-v2", "repo_owner": "AmirHbro", "repo_url": "https://github.com/AmirHbro/fastapi-blog-sqlalchemy-v2"}}
{"type": "test_file", "path": "app/tests/conftest.py", "content": "import asyncio\nfrom contextlib import ExitStack\nfrom fastapi.testclient import TestClient\nimport pytest\nfrom app import init_app\nfrom pytest_postgresql import factories\nfrom pytest_postgresql.janitor import DatabaseJanitor\nfrom app.dependencies import get_db\nfrom app.database import sessionmanager\nfrom app.models import User, Post\nfrom app.utils.auth_utils import get_password_hash\nfrom datetime import datetime\nfrom faker import Faker\n\nfaker = Faker()\n\n\n@pytest.fixture(autouse=True)\ndef app():\n    with ExitStack():\n        yield init_app(init_db=False)\n\n\n@pytest.fixture\ndef client(app):\n    with TestClient(app) as c:\n        yield c\n\n\ntest_db = factories.postgresql_proc(port=None, dbname=\"test_db\")\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop(request):\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\nasync def connection_test(test_db, event_loop):\n    pg_host = test_db.host\n    pg_port = test_db.port\n    pg_user = test_db.user\n    pg_db = test_db.dbname\n    pg_password = test_db.password\n\n    with DatabaseJanitor(\n        user=pg_user,\n        host=pg_host,\n        port=pg_port,\n        dbname=pg_db,\n        version=test_db.version,\n        password=pg_password,\n    ):\n        connection_str = (\n            f\"postgresql+asyncpg://{pg_user}:{pg_password}@{pg_host}:{pg_port}/{pg_db}\"\n        )\n        sessionmanager.init(connection_str)\n        yield\n        await sessionmanager.close()\n\n\n@pytest.fixture(scope=\"function\", autouse=True)\nasync def create_tables(connection_test):\n    async with sessionmanager.connect() as connection:\n        await sessionmanager.drop_all(connection)\n        await sessionmanager.create_all(connection)\n\n\n@pytest.fixture(scope=\"function\", autouse=True)\nasync def session_override(app, connection_test):\n    async def get_db_override():\n        async with sessionmanager.session() as session:\n            yield session\n\n    app.dependency_overrides[get_db] = get_db_override\n\n\nimport faker\nfrom datetime import datetime\nfrom app.utils.auth_utils import get_password_hash\n\nfake = faker.Faker()\n\n\n@pytest.fixture\nasync def test_user(client):\n    async with sessionmanager.session() as session:\n        password = fake.password()\n        payload = {\n            \"email\": fake.email(),\n            \"password\": get_password_hash(password),\n            \"first_name\": fake.first_name(),\n            \"last_name\": fake.last_name(),\n            \"is_verified\": True,\n            \"is_firstlogin\": False,\n            \"is_superuser\": False,\n            \"created_at\": datetime.now(),\n        }\n\n        new_user = User(**payload)\n        session.add(new_user)\n        await session.commit()\n\n    response = client.post(\n        \"/login\",\n        data={\"username\": payload[\"email\"], \"password\": password},\n    )\n    assert response.status_code == 200\n    access_token = response.json()[\"access_token\"]\n    refresh_token = response.json()[\"refresh_token\"]\n\n    yield {\n        **payload,\n        \"access_token\": access_token,\n        \"refresh_token\": refresh_token,\n    }\n\n\n@pytest.fixture\nasync def test_post(client):\n    async with sessionmanager.session() as session:\n        payload = {\n            \"title\": fake.sentence(),\n            \"content\": fake.paragraph(),\n            \"is_published\": True,\n            \"user_id\": 1,\n            \"created_at\": datetime.now(),\n        }\n\n        new_post = Post(**payload)\n        session.add(new_post)\n        await session.commit()\n\n        yield payload\n"}
{"type": "test_file", "path": "app/tests/test_user.py", "content": "import pytest\nfrom faker import Faker\n\nfaker = Faker()\n\n\n@pytest.mark.asyncio\ndef test_create_client(client):\n    email = faker.email()\n    password = faker.password()\n    first_name = faker.first_name()\n    last_name = faker.last_name()\n\n    data = {\n        \"email\": email,\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"password\": password,\n    }\n    response = client.post(url=\"/users/signup\", json=data)\n\n    assert response.status_code == 201\n    assert (\n        response.json()[\"detail\"]\n        == \"your account has been created successfully, please check your email!\"\n    )\n\n    response = client.post(\n        url=\"/login\",\n        data={\"username\": email, \"password\": password},\n    )\n    assert response.status_code == 200\n    assert \"access_token\" in response.json()\n    global access_token\n    access_token = response.json()[\"access_token\"]\n\n\n@pytest.mark.asyncio\ndef test_retrieve_all_users(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    response = client.get(url=\"/users\", headers=headers)\n    assert response.status_code == 200\n    assert isinstance(response.json(), list)\n\n\n@pytest.mark.asyncio\ndef test_retrieve_my_user(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    response = client.get(url=\"/users/profile\", headers=headers)\n    assert response.status_code == 200\n    assert response.json()[\"email\"] == test_user[\"email\"]\n\n\n@pytest.mark.asyncio\ndef test_update_user(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    new_email = faker.email()\n    response = client.put(\n        \"/users/1\",\n        json={\n            \"email\": new_email,\n            \"first_name\": faker.first_name(),\n            \"last_name\": faker.last_name(),\n        },\n        headers=headers,\n    )\n    assert response.status_code == 201\n    assert response.json()[\"email\"] == new_email\n\n\n@pytest.mark.asyncio\ndef test_partial_update_user(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    new_first_name = faker.first_name()\n    response = client.patch(\n        \"/users/1\",\n        json={\"first_name\": new_first_name},\n        headers=headers,\n    )\n    assert response.status_code == 201\n    assert response.json()[\"first_name\"] == new_first_name\n\n\n@pytest.mark.asyncio\ndef test_retrieve_user(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    response = client.get(\"/users/1\", headers=headers)\n    assert response.status_code == 200\n    assert response.json()[\"email\"] == test_user[\"email\"]\n\n\n@pytest.mark.asyncio\ndef test_delete_user(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    response = client.delete(\"users/1\", headers=headers)\n    assert response.status_code == 200\n    response = client.get(\"user/1\", headers=headers)\n    assert response.status_code == 404\n\n\n@pytest.mark.asyncio\ndef test_unauthenticated_request(client):\n    headers = {\"Authorization\": f\"Bearer fake token\"}\n    response = client.get(\"/users/\", headers=headers)\n    assert response.status_code == 401\n    response = client.get(\"/users/1\", headers=headers)\n    assert response.status_code == 401\n    response = client.get(\"/users/profile\", headers=headers)\n    assert response.status_code == 401\n\n\n@pytest.mark.asyncio\ndef test_invalid_input(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n\n    response = client.post(\n        \"/users/signup\",\n        json={\n            \"email\": \"invalidemail\",\n            \"password\": \"short\",\n        },\n    )\n    assert response.status_code == 422\n\n    response = client.post(\n        url=\"/login\",\n        data={\n            \"username\": \"wronguser@example.com\",\n            \"password\": \"wrongpassword\",\n        },\n    )\n    assert response.status_code == 401\n\n    response = client.put(\n        \"/users/1\",\n        json={\"email\": faker.email()},\n        headers=headers,\n    )\n    assert response.status_code == 422\n\n    response = client.patch(\n        \"/users/1\",\n        json={\n            \"email\": \"invalidemailformat\",\n            \"first_name\": faker.first_name(),\n        },\n        headers=headers,\n    )\n    assert response.status_code == 422\n\n\n@pytest.mark.asyncio\ndef test_invalid_route(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    response = client.get(\"/ascaad\", headers=headers)\n    assert response.status_code == 404\n\n\n@pytest.mark.asyncio\ndef test_refresh_instead_of_access(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['refresh_token']}\"}\n    response = client.get(\"/users\", headers=headers)\n    assert response.json()[\"detail\"] == \"Cannot authenticate with a refresh token\"\n"}
{"type": "test_file", "path": "app/tests/test_blog.py", "content": "import pytest\nfrom faker import Faker\n\nfaker = Faker()\n\n\n@pytest.mark.asyncio\ndef test_create_post(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    title = faker.sentence()\n    content = faker.paragraph()\n    data = {\n        \"title\": title,\n        \"content\": content,\n        \"is_published\": False,\n    }\n    response = client.post(url=\"/posts\", json=data, headers=headers)\n\n    assert response.status_code == 201\n    assert response.json()[\"title\"] == title\n\n\n@pytest.mark.asyncio\ndef test_retrieve_all_posts(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    response = client.get(url=\"/posts\", headers=headers)\n    assert response.status_code == 200\n    assert isinstance(response.json(), list)\n\n\n@pytest.mark.asyncio\ndef test_update_post(client, test_user, test_post):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    updated_title = faker.sentence()\n    updated_content = faker.paragraph()\n    response = client.put(\n        \"/posts/1\",\n        json={\n            \"title\": updated_title,\n            \"content\": updated_content,\n            \"is_published\": False,\n        },\n        headers=headers,\n    )\n    assert response.status_code == 201\n    assert response.json()[\"title\"] == updated_title\n\n\n@pytest.mark.asyncio\ndef test_partial_update_post(client, test_user, test_post):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    updated_title = faker.sentence()\n    response = client.patch(\n        \"/posts/1\",\n        json={\"title\": updated_title},\n        headers=headers,\n    )\n    assert response.status_code == 201\n    assert response.json()[\"title\"] == updated_title\n\n\n@pytest.mark.asyncio\ndef test_retrieve_post(client, test_user, test_post):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    response = client.get(\"posts/1\", headers=headers)\n    assert response.status_code == 200\n    assert response.json()[\"title\"] == test_post[\"title\"]\n\n\n@pytest.mark.asyncio\ndef test_delete_post(client, test_user, test_post):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n    response = client.delete(\"posts/1\", headers=headers)\n    assert response.status_code == 200\n    response = client.get(\"posts/1\", headers=headers)\n    assert response.status_code == 404\n\n\n@pytest.mark.asyncio\ndef test_unauthenticated_request(client):\n    headers = {\"Authorization\": f\"Bearer fake token\"}\n    response = client.get(\"/posts/\", headers=headers)\n    assert response.status_code == 401\n    response = client.get(\"/posts/1\", headers=headers)\n    assert response.status_code == 401\n\n\n@pytest.mark.asyncio\ndef test_invalid_input_post(client, test_user):\n    headers = {\"Authorization\": f\"Bearer {test_user['access_token']}\"}\n\n    response = client.post(\n        \"/posts\",\n        json={\n            \"title\": \"\",\n            \"content\": \"\",\n            \"is_published\": \"not a boolean\",\n        },\n        headers=headers,\n    )\n    assert response.status_code == 422\n\n    response = client.put(\n        \"/posts/1\",\n        json={\n            \"title\": faker.sentence(),\n            \"content\": faker.paragraph(),\n            \"is_published\": \"not a boolean\",\n        },\n        headers=headers,\n    )\n    assert response.status_code == 422\n\n    response = client.patch(\n        \"/posts/1\",\n        json={\"title\": 123},\n        headers=headers,\n    )\n    assert response.status_code == 422\n"}
{"type": "source_file", "path": "alembic/env.py", "content": "import asyncio\nfrom logging.config import fileConfig\n\nfrom sqlalchemy import pool\nfrom sqlalchemy.engine import Connection\nfrom sqlalchemy.ext.asyncio import async_engine_from_config\nfrom app.database import Base\nfrom alembic import context\nimport os, sys\nfrom dotenv import load_dotenv\nfrom app.config import Config\n\n\n\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.append(BASE_DIR)\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\nconfig.set_main_option(\"sqlalchemy.url\", Config.DB_CONFIG)\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\nfrom app.models import Post, User\n\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef do_run_migrations(connection: Connection) -> None:\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_async_migrations() -> None:\n    \"\"\"In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n\n    connectable = async_engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n    await connectable.dispose()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\"\"\"\n\n    asyncio.run(run_async_migrations())\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "alembic/versions/d956b499c544_creating_tables.py", "content": "\"\"\"creating tables\n\nRevision ID: d956b499c544\nRevises: \nCreate Date: 2024-08-11 13:12:56.554231\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = 'd956b499c544'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('user',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('email', sa.String(), nullable=False),\n    sa.Column('password', sa.String(), nullable=False),\n    sa.Column('first_name', sa.String(), nullable=False),\n    sa.Column('last_name', sa.String(), nullable=False),\n    sa.Column('is_verified', sa.Boolean(), nullable=False),\n    sa.Column('is_firstlogin', sa.Boolean(), nullable=False),\n    sa.Column('is_superuser', sa.Boolean(), nullable=False),\n    sa.Column('created_at', sa.DateTime(), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index(op.f('ix_user_email'), 'user', ['email'], unique=True)\n    op.create_index(op.f('ix_user_id'), 'user', ['id'], unique=False)\n    op.create_table('post',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('title', sa.String(), nullable=False),\n    sa.Column('content', sa.String(), nullable=False),\n    sa.Column('is_published', sa.Boolean(), nullable=False),\n    sa.Column('created_at', sa.DateTime(), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index(op.f('ix_post_id'), 'post', ['id'], unique=False)\n    op.create_index(op.f('ix_post_title'), 'post', ['title'], unique=False)\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f('ix_post_title'), table_name='post')\n    op.drop_index(op.f('ix_post_id'), table_name='post')\n    op.drop_table('post')\n    op.drop_index(op.f('ix_user_id'), table_name='user')\n    op.drop_index(op.f('ix_user_email'), table_name='user')\n    op.drop_table('user')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "app/api.py", "content": "from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom app.routers.user import router as user_router\nfrom app.routers.blog import router as blog_router\nfrom app.routers.authentication import router as auth_router\nfrom app.database import sessionmanager\nfrom app.config import Config\n\n\ndef init_app(init_db=True):\n    lifespan = None\n\n    if init_db:\n        sessionmanager.init(Config.DB_CONFIG)\n\n        @asynccontextmanager\n        async def lifespan(app: FastAPI):\n            yield\n            if sessionmanager._engine is not None:\n                await sessionmanager.close()\n\n    app = FastAPI(title=\"FastAPI Blog\", lifespan=lifespan, docs_url=\"/api/docs\")\n\n    app.include_router(auth_router)\n    app.include_router(user_router)\n    app.include_router(blog_router)\n\n    return app\n"}
{"type": "source_file", "path": "app/__init__.py", "content": "from .api import *"}
{"type": "source_file", "path": "app/external_services/email.py", "content": "from fastapi import BackgroundTasks, HTTPException\nfrom fastapi_mail import FastMail, MessageSchema, ConnectionConfig\nfrom decouple import config\n\nconf = ConnectionConfig(\n    MAIL_USERNAME=config(\"MAIL_USERNAME\", default=\"\"),  # smtp4dev does not require authentication\n    MAIL_PASSWORD=config(\"MAIL_PASSWORD\", default=\"\"),  # smtp4dev does not require authentication\n    MAIL_FROM=config(\"MAIL_FROM\", default=\"no-reply@example.com\"),  # Default sender address\n    MAIL_PORT=config(\"MAIL_PORT\", cast=int, default=25),  # Port used by smtp4dev\n    MAIL_SERVER=config(\"MAIL_SERVER\", default=\"localhost\"),  # smtp4dev server\n    MAIL_FROM_NAME=config(\"MAIL_FROM_NAME\", default=\"Your Name\"),  # Sender's name\n    MAIL_STARTTLS=config(\"MAIL_STARTTLS\", cast=bool, default=False),\n    MAIL_SSL_TLS=config(\"MAIL_SSL_TLS\", cast=bool, default=False),\n    USE_CREDENTIALS=config(\"USE_CREDENTIALS\", cast=bool, default=False),\n    TEMPLATE_FOLDER=\"app/templates/email\",\n)\n\nasync def send_email_async(subject: str, email_to: str, body: dict):\n    message = MessageSchema(\n        subject=subject,\n        recipients=[email_to],\n        template_body=body,\n        subtype=\"html\",\n    )\n\n    fm = FastMail(conf)\n    try:\n        await fm.send_message(message, template_name=\"email.html\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\ndef send_email_background(\n    background_tasks: BackgroundTasks, subject: str, email_to: str, body: dict\n):\n    message = MessageSchema(\n        subject=subject,\n        recipients=[email_to],\n        template_body=body,\n        subtype=\"html\",\n    )\n    fm = FastMail(conf)\n    background_tasks.add_task(fm.send_message, message, template_name=\"email.html\")\n"}
{"type": "source_file", "path": "app/models/user_model.py", "content": "from sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy import func\nfrom datetime import datetime\nfrom . import Base\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from app.models.post_model import Post\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    email: Mapped[str] = mapped_column(index=True, unique=True)\n    password: Mapped[str]\n    first_name: Mapped[str]\n    last_name: Mapped[str]\n    is_verified: Mapped[bool] = mapped_column(default=False)\n    is_firstlogin: Mapped[bool] = mapped_column(default=True)\n    is_superuser: Mapped[bool] = mapped_column(default=False)\n    created_at: Mapped[datetime] = mapped_column(insert_default=func.now())\n\n    posts: Mapped[list[\"Post\"]] = relationship(back_populates=\"user\")\n"}
{"type": "source_file", "path": "app/models/__init__.py", "content": "from app.database import Base\nfrom .post_model import Post\nfrom .user_model import User\n\n\n\n"}
{"type": "source_file", "path": "app/routers/__init__.py", "content": ""}
{"type": "source_file", "path": "app/schemas/__init__.py", "content": "from .post_schema import *\nfrom .user_schema import *"}
{"type": "source_file", "path": "app/routers/authentication.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.responses import JSONResponse\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.utils import auth_utils, auth_handler\nfrom app.dependencies import get_db\nfrom app.schemas.user_schema import RefreshToken, Login\n\nrouter = APIRouter()\n\n\n@router.post(\"/login\")\nasync def login(\n    request: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_db)\n):\n    user = await auth_utils.authenticate_user(request, db)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    access_token = auth_handler.create_access_token(data={\"sub\": user.id})\n    refresh_token = auth_handler.create_refresh_token(data={\"sub\": user.id})\n    return JSONResponse(\n        {\n            \"access_token\": access_token,\n            \"refresh_token\": refresh_token,\n        },\n        status_code=status.HTTP_200_OK,\n    )\n\n\n@router.post(\"/refresh\")\nasync def refresh(request: RefreshToken, db: AsyncSession = Depends(get_db)):\n    user_id = auth_handler.verify_refresh_token(request.refresh_token)\n    access_token = auth_handler.create_access_token(data={\"sub\": user_id})\n\n    return JSONResponse({\"access\": access_token}, status_code=status.HTTP_201_CREATED)\n"}
{"type": "source_file", "path": "app/crud/user_crud.py", "content": "from fastapi import HTTPException, status\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.models import User\nfrom app.schemas.user_schema import UserBase, UserPartialUpdate\nfrom app.utils import auth_utils\nfrom sqlalchemy.orm import selectinload\n\n\nasync def get_all(db: AsyncSession):\n    result = await db.execute(select(User).options(selectinload(User.posts)))\n    return result.scalars().all()\n\n\nasync def create(request, db):\n\n    new_user = User(\n        email=request.email,\n        first_name=request.first_name,\n        last_name=request.last_name,\n        password=auth_utils.get_password_hash(request.password),\n    )\n    db.add(new_user)\n    await db.commit()\n    await db.refresh(new_user)\n    return new_user\n\n\nasync def update(id: int, request: UserBase, db: AsyncSession):\n    result = await db.execute(select(User).filter(User.id == id))\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=f\"User with id {id} not found\"\n        )\n    for key, value in request.model_dump().items():\n        setattr(user, key, value)\n    await db.commit()\n    await db.refresh(user)\n    return user\n\n\nasync def partial_update(id: int, request: UserPartialUpdate, db: AsyncSession):\n    result = await db.execute(select(User).filter(User.id == id))\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=f\"User with id {id} not found\"\n        )\n    update_data = request.model_dump(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user, key, value)\n    await db.commit()\n    await db.refresh(user)\n    return user\n\n\nasync def destroy(id, db):\n    result = await db.execute(select(User).filter(User.id == id))\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=f\"User with id {id} not found\"\n        )\n    await db.delete(user)\n    await db.commit()\n    return JSONResponse({\"detail\": \"User succefully deleted\"})\n\n\nasync def retrieve_user(id: int, db: AsyncSession):\n    result = await db.execute(\n        select(User).options(selectinload(User.posts)).filter(User.id == id)\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=f\"User with id {id} not found\"\n        )\n    return user\n"}
{"type": "source_file", "path": "app/models/post_model.py", "content": "from sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy import ForeignKey, func\nfrom . import Base\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from app.models import User\n\nclass Post(Base):\n    __tablename__ = \"post\"\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    title: Mapped[str] = mapped_column(index=True)\n    content: Mapped[str]\n    is_published: Mapped[bool] = mapped_column(default=False)\n    created_at: Mapped[datetime] = mapped_column(insert_default=func.now())\n\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user.id\"), nullable=False)\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n"}
{"type": "source_file", "path": "app/dependencies.py", "content": "from app.config import Config\nfrom app.database import sessionmanager\nimport redis\n\n\ndef get_redis():\n    pool = Config.create_redis()\n    return redis.Redis(connection_pool=pool)\n\n\nasync def get_db():\n    async with sessionmanager.session() as session:\n        yield session\n"}
{"type": "source_file", "path": "app/routers/blog.py", "content": "from fastapi import APIRouter, Depends, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.schemas.post_schema import PostResponse, PostBase, PostPartialUpdate\nfrom app.dependencies import get_db\nfrom app.crud import post_crud\nfrom app.utils.auth_handler import get_current_user\nfrom app.schemas.user_schema import User\n\nrouter = APIRouter(prefix=\"/posts\", tags=[\"Posts\"])\n\n\n@router.get(\"/\", response_model=list[PostResponse])\nasync def all_posts(\n    db: AsyncSession = Depends(get_db), current_user: User = Depends(get_current_user)\n):\n    return await post_crud.get_all(current_user, db)\n\n\n@router.post(\"/\", response_model=PostBase, status_code=status.HTTP_201_CREATED)\nasync def create(\n    request: PostBase,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    return await post_crud.create(current_user, request, db)\n\n\n@router.delete(\"/{id}\", status_code=status.HTTP_200_OK)\nasync def destroy(\n    id: int,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    await post_crud.destroy(id, db)\n\n\n@router.put(\"/{id}\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\nasync def update(\n    id: int,\n    request: PostBase,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    return await post_crud.update(id, request, db)\n\n\n@router.patch(\"/{id}\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\nasync def partial_update(\n    id: int,\n    request: PostPartialUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n\n    return await post_crud.partial_update(id, request, db)\n\n\n@router.get(\"/{id}\", status_code=status.HTTP_200_OK, response_model=PostResponse)\nasync def retrieve(\n    id: int,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n\n    return await post_crud.retrieve_post(id, db)\n"}
{"type": "source_file", "path": "app/crud/post_crud.py", "content": "from fastapi import HTTPException, status\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import selectinload\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom app.models.post_model import Post\nfrom app.schemas import PostBase, PostPartialUpdate\n\n\nasync def get_all(user, db: AsyncSession):\n    result = await db.execute(\n        select(Post).options(selectinload(Post.user)).filter(Post.user_id == user.id)\n    )\n    return result.scalars().all()\n\n\nasync def create(user, request, db):\n    new_blog = Post(**request.model_dump(), user_id=user.id)\n    db.add(new_blog)\n    await db.commit()\n    await db.refresh(new_blog)\n    return new_blog\n\n\nasync def destroy(id, db):\n    result = await db.execute(select(Post).filter(Post.id == id))\n    blog = result.scalar_one_or_none()\n    if not blog:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=f\"Blog with id {id} not found\"\n        )\n    await db.delete(blog)\n    await db.commit()\n    return JSONResponse({\"detail\": \"blog post succefully deleted\"})\n\n\nasync def update(id, request: PostBase, db):\n    result = await db.execute(select(Post).filter(Post.id == id))\n    blog = result.scalar_one_or_none()\n    if not blog:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=f\"Blog with id {id} not found\"\n        )\n\n    for key, value in request.model_dump().items():\n        setattr(blog, key, value)\n\n    await db.commit()\n    await db.refresh(blog)\n    return blog\n\n\nasync def partial_update(id, request: PostPartialUpdate, db):\n    result = await db.execute(select(Post).filter(Post.id == id))\n    blog = result.scalar_one_or_none()\n    if not blog:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=f\"Blog with id {id} not found\"\n        )\n\n    update_data = request.model_dump(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(blog, key, value)\n\n    await db.commit()\n    await db.refresh(blog)\n    return blog\n\n\nasync def retrieve_post(id, db):\n    result = await db.execute(\n        select(Post).options(selectinload(Post.user)).filter(Post.id == id)\n    )\n    blog = result.scalar_one_or_none()\n    if not blog:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=f\"Blog with id {id} not found\"\n        )\n    return blog\n"}
{"type": "source_file", "path": "app/crud/__init__.py", "content": ""}
{"type": "source_file", "path": "app/external_services/__init__.py", "content": ""}
{"type": "source_file", "path": "app/schemas/post_schema.py", "content": "from pydantic import BaseModel\nfrom datetime import datetime\n\n\nclass PostBase(BaseModel):\n    title: str\n    content: str\n    is_published: bool\n\n\nclass PostPartialUpdate(BaseModel):\n    title: str | None = None\n    content: str | None = None\n    is_published: bool | None = None\n\n\nclass PostResponse(PostBase):\n    id: int\n    created_at: datetime\n    user_id: int\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "app/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "main.py", "content": "from app.api import init_app\n\napp = init_app()"}
{"type": "source_file", "path": "app/config.py", "content": "import redis\nfrom decouple import config as decouple_config\n\n\nclass Config:\n    DB_CONFIG = decouple_config(\"DATABASE_URL\")\n    TEST_DB_CONFIG = decouple_config(\"TEST_DATABASE_URL\")\n\n    @staticmethod\n    def create_redis():\n        return redis.ConnectionPool(\n            host=decouple_config(\"REDIS_HOST\"), port=decouple_config(\"REDIS_PORT\"), db=decouple_config(\"REDIS_DB\"), decode_responses=True\n        )\n\n\nconfig = Config()\n"}
{"type": "source_file", "path": "app/routers/user.py", "content": "import random\nfrom fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, status\nfrom sqlalchemy import select\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.schemas import (\n    User,\n    UserCreate,\n    UserBase,\n    UserVerifyCode,\n    UserPartialUpdate,\n)\nfrom app.models import User as UserModel\nfrom app.dependencies import get_db\nfrom app.crud import user_crud\nfrom app.external_services import email\nfrom app.dependencies import get_redis\nfrom app.utils.auth_handler import get_current_user\n\n\nrouter = APIRouter(prefix=\"/users\", tags=[\"Users\"])\n\n\n@router.get(\"/profile\", status_code=status.HTTP_200_OK, response_model=User)\nasync def retrieve(\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    return await user_crud.retrieve_user(current_user.id, db)\n\n\n@router.get(\n    \"/\",\n    status_code=status.HTTP_200_OK,\n    response_model=list[User],\n)\nasync def all_users(\n    db: AsyncSession = Depends(get_db), current_user: User = Depends(get_current_user)\n):\n    return await user_crud.get_all(db)\n\n\n@router.post(\"/signup\", status_code=status.HTTP_201_CREATED)\nasync def signup(\n    request: UserCreate,\n    background_tasks: BackgroundTasks,\n    cache=Depends(get_redis),\n    db: AsyncSession = Depends(get_db),\n):\n    created_user = await user_crud.create(request, db)\n    # await email.send_email_async(\"Welcome aboard\",created_user.email,{\"first_name\": created_user.first_name })\n    verification_code = str(random.randint(10000, 99999))\n    cache.set(str(created_user.email), verification_code, 600)\n    email.send_email_background(\n        background_tasks,\n        \"Your account verficiation code\",\n        created_user.email,\n        {\"first_name\": created_user.first_name, \"activation_code\": verification_code},\n    )\n    return JSONResponse(\n        {\n            \"detail\": \"your account has been created successfully, please check your email!\"\n        }\n    )\n\n\n@router.post(\n    \"/activate-account\",\n    status_code=status.HTTP_200_OK,\n)\nasync def activate(\n    request: UserVerifyCode,\n    cache=Depends(get_redis),\n    db: AsyncSession = Depends(get_db),\n):\n    user = await db.execute(select(UserModel).filter(UserModel.email == request.email))\n    user = user.scalar_one_or_none()\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"user not found\"\n        )\n    if not user.is_firstlogin:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"You've already activated your account\",\n        )\n    cached_code = cache.get(request.email)\n    if request.code != cached_code:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN, detail=\"code has expired\"\n        )\n\n    user.is_verified = True\n    user.is_firstlogin = False\n    await db.commit()\n    await db.refresh(user)\n    return JSONResponse({\"details\": \"account confirmed sucessfully\"})\n\n\n@router.put(\n    \"/{id}\",\n    status_code=status.HTTP_201_CREATED,\n)\nasync def update(\n    id: int,\n    request: UserBase,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    return await user_crud.update(id, request, db)\n\n\n@router.patch(\n    \"/{id}\",\n    status_code=status.HTTP_201_CREATED,\n)\nasync def partial_update(\n    id: int,\n    request: UserPartialUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    return await user_crud.partial_update(id, request, db)\n\n\n@router.get(\"/{id}\", status_code=status.HTTP_200_OK, response_model=User)\nasync def retrieve(\n    id: int,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    return await user_crud.retrieve_user(id, db)\n\n\n@router.delete(\"/{id}\", status_code=status.HTTP_200_OK)\nasync def destroy(\n    id: int,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    return await user_crud.destroy(id, db)\n"}
{"type": "source_file", "path": "app/database.py", "content": "import contextlib\nfrom typing import AsyncIterator\nfrom sqlalchemy import NullPool\nfrom sqlalchemy.ext.asyncio import (\n    AsyncConnection,\n    AsyncSession,\n    async_sessionmaker,\n    create_async_engine,\n)\nfrom sqlalchemy.orm import declarative_base\nfrom app.config import Config\n\nBase = declarative_base()\n\n\nclass DatabaseSessionManager:\n    def __init__(self, host: str, engine_kwargs: dict[str] = {}):\n        self._engine = create_async_engine(host, poolclass=NullPool, **engine_kwargs)\n        self._sessionmaker = async_sessionmaker(\n            autocommit=False, bind=self._engine, expire_on_commit=False\n        )\n\n    def init(self, host: str):\n        self._engine = create_async_engine(host, poolclass=NullPool)\n        self._sessionmaker = async_sessionmaker(autocommit=False, bind=self._engine)\n\n    async def close(self):\n        if self._engine is None:\n            raise Exception(\"DatabaseSessionManager is not initialized\")\n        await self._engine.dispose()\n        self._engine = None\n        self._sessionmaker = None\n\n    @contextlib.asynccontextmanager\n    async def connect(self) -> AsyncIterator[AsyncConnection]:\n        if self._engine is None:\n            raise Exception(\"DatabaseSessionManager is not initialized\")\n\n        async with self._engine.begin() as connection:\n            try:\n                yield connection\n            except Exception:\n                await connection.rollback()\n                raise\n\n    @contextlib.asynccontextmanager\n    async def session(self) -> AsyncIterator[AsyncSession]:\n        if self._sessionmaker is None:\n            raise Exception(\"DatabaseSessionManager is not initialized\")\n\n        session = self._sessionmaker()\n        try:\n            yield session\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\n    async def create_all(self, connection: AsyncConnection):\n        await connection.run_sync(Base.metadata.create_all)\n\n    async def drop_all(self, connection: AsyncConnection):\n        await connection.run_sync(Base.metadata.drop_all)\n\n\nsessionmanager = DatabaseSessionManager(Config.DB_CONFIG, {\"echo\": True})\n"}
{"type": "source_file", "path": "app/utils/auth_utils.py", "content": "from fastapi.security import OAuth2PasswordBearer\nfrom passlib.context import CryptContext\nfrom sqlalchemy import select\nfrom app.models import User\nfrom app.models import User\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_schema = OAuth2PasswordBearer(tokenUrl=\"/login\")\n\n\nasync def authenticate_user(request, db):\n    result = await db.execute(select(User).where(User.email == request.username))\n    user = result.scalar_one_or_none()\n    if not user or not verify_password(request.password, user.password):\n        return None\n    return user\n\n\ndef get_password_hash(password: str):\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    is_valid = pwd_context.verify(plain_password, hashed_password)\n    return is_valid\n"}
{"type": "source_file", "path": "app/utils/auth_handler.py", "content": "from datetime import datetime, timedelta\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nimport jwt\nfrom decouple import config\nfrom app.schemas.user_schema import TokenData\n\nJWT_SECRET = config(\"SECRET_KEY\")\nJWT_ALGORITHM = config(\"ALGORITHM\")\nACCESS_TOKEN_EXPIRE_MINUTES = int(config(\"ACCESS_EXPIRE_TIME\"))\nREFRESH_TOKEN_EXPIRE_MINUTES = int(config(\"REFRESH_EXPIRE_TIME\"))\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/login\")\n\n\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.now() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire, \"typ\": \"access\"})\n    encoded_jwt = jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALGORITHM)\n    return encoded_jwt\n\n\ndef create_refresh_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.now() + timedelta(minutes=REFRESH_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire, \"typ\": \"refresh\"})\n    encoded_jwt = jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str, credentials_exception):\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\n        user_id: str = payload.get(\"sub\")\n        token_type: str = payload.get(\"typ\")\n\n        if token_type == \"refresh\":\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Cannot authenticate with a refresh token\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n\n        token_data = TokenData(id=user_id)\n    except jwt.PyJWTError:\n        raise credentials_exception\n    return token_data\n\n\ndef verify_refresh_token(token: str):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Refresh\"},\n    )\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\n        user_id: str = payload.get(\"sub\")\n    except jwt.PyJWTError:\n        raise credentials_exception\n    return user_id\n\n\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    return verify_token(token, credentials_exception)\n"}
{"type": "source_file", "path": "app/schemas/user_schema.py", "content": "from pydantic import BaseModel, EmailStr, Field\nfrom app.schemas.post_schema import PostResponse\nfrom datetime import datetime\n\n\nclass UserBase(BaseModel):\n    email: EmailStr\n    first_name: str\n    last_name: str\n\n\nclass UserPartialUpdate(BaseModel):\n    email: EmailStr | None = None\n    first_name: str | None = None\n    last_name: str | None = None\n\n\n# password_regex = \"((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\\W]).{8,64})\"\n\n\nclass UserCreate(UserBase):\n    password: str\n    # = Field(...,regex=)\n\n\nclass User(UserBase):\n    id: int\n    is_verified: bool = False\n    is_superuser: bool = False\n    is_firstlogin: bool = False\n    created_at: datetime\n    posts: list[PostResponse] = []\n\n    class Config:\n        orm_mode = True\n\n\nclass Login(BaseModel):\n    email: str\n    password: str\n\n\nclass Email(BaseModel):\n    email: EmailStr\n\n\nclass UserVerifyCode(Email):\n    code: str\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    id: int\n\n\nclass RefreshToken(BaseModel):\n    refresh_token: str\n"}

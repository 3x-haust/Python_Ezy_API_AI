{"repo_info": {"repo_name": "hng_boilerplate_python_fastapi_web", "repo_owner": "hngprojects", "repo_url": "https://github.com/hngprojects/hng_boilerplate_python_fastapi_web"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/conftest.py", "content": "import itertools\nimport sys, os\nimport warnings\nfrom unittest.mock import patch\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom alembic.command import upgrade\nfrom alembic.config import Config\nfrom decouple import config as decouple_config\nfrom datetime import datetime, timezone\n\n\n\n# Global IP generator (supports 16 million+ unique IPs)\nIP_GENERATOR = itertools.cycle(\n    (f\"127.{i//65536}.{(i//256)%256}.{i%256}\" for i in itertools.count())\n)\n\n@pytest.fixture(autouse=True)\ndef auto_mock_client_ip():\n    \"\"\"Automatically mock client IP for all tests\"\"\"\n    with patch(\"fastapi.Request.client\") as mock_client:\n        mock_client.host = next(IP_GENERATOR)\n        yield\n\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\n# Get the project root directory\nproject_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n\n@pytest.fixture(scope='module')\ndef mock_send_email():\n    with patch(\"api.core.dependencies.email_sender.send_email\") as mock_email_sending:\n        with patch(\"fastapi.BackgroundTasks.add_task\") as add_task_mock:\n            add_task_mock.side_effect = lambda func, *args, **kwargs: func(*args, **kwargs)\n            yield mock_email_sending\n\n\n@pytest.fixture(scope=\"session\")\ndef db_engine():\n\n   # Create a PostgreSQL test database engine.\n    db_url = decouple_config('DB_URL')\n\n    engine = create_engine(db_url)\n    yield engine\n\n\n@pytest.fixture(scope=\"session\")\ndef apply_migrations(db_engine):\n    \"\"\"Apply all migrations to the test database.\"\"\"\n    # Configure Alembic\n    config = Config(os.path.join(project_root, \"alembic.ini\"))\n\n    # Set the SQLAlchemy URL to the test database\n    config.set_main_option(\"sqlalchemy.url\", str(db_engine.url))\n\n    # Run the migrations\n    upgrade(config, \"head\")\n    return\n\n\n@pytest.fixture(scope=\"function\")\ndef db_session(db_engine, apply_migrations):\n\n    #Create a new database session for a test.\n    connection = db_engine.connect()\n\n    # Begin a transaction\n    transaction = connection.begin()\n\n    # Create a session bound to the connection\n    Session = sessionmaker(bind=connection)\n    session = Session()\n\n    yield session\n\n    # Rollback the transaction after the test completes\n    session.close()\n    transaction.rollback()\n    connection.close()\n\n    # Blog Model Test Fixtures\n\n    @pytest.fixture\n    def test_user(db_session):\n        \"\"\"Create a test user for blog tests.\"\"\"\n        from api.v1.models.user import User\n\n        # Create a unique email with timestamp to avoid conflicts\n        timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S\")\n        user = User(\n            email=f\"testuser_{timestamp}@example.com\",\n            username=f\"testuser_{timestamp}\",\n            first_name=\"Test\",\n            last_name=\"User\",\n            is_active=True,\n            is_verified=True,\n            is_deleted=False,\n            is_superadmin=False\n        )\n\n        db_session.add(user)\n        db_session.commit()\n        db_session.refresh(user)\n\n        yield user\n\n    @pytest.fixture\n    def test_blog(db_session, test_user):\n        \"\"\"Create a test blog post.\"\"\"\n        from api.v1.models.blog import Blog\n\n        timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S\")\n        blog = Blog(\n            author_id=test_user.id,\n            title=f\"Test Blog {timestamp}\",\n            content=\"This is test content for the blog post.\",\n            excerpt=\"Test excerpt\",\n            tags=\"test,blog,indexing\",\n            is_deleted=False\n        )\n\n        db_session.add(blog)\n        db_session.commit()\n        db_session.refresh(blog)\n\n        yield blog\n\n    @pytest.fixture\n    def test_multiple_blogs(db_session, test_user):\n        \"\"\"Create multiple test blog posts for a user.\"\"\"\n        from api.v1.models.blog import Blog\n\n        blogs = []\n        for i in range(5):\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S\")\n            blog = Blog(\n                author_id=test_user.id,\n                title=f\"Test Blog {i} {timestamp}\",\n                content=f\"This is test content for blog post {i}.\",\n                excerpt=f\"Test excerpt {i}\",\n                tags=f\"test,blog{i},indexing\",\n                is_deleted=(i % 4 == 0)  # Make some blogs \"deleted\" for testing\n            )\n\n            db_session.add(blog)\n            blogs.append(blog)\n\n        db_session.commit()\n\n        # Refresh all blogs to get their IDs\n        for blog in blogs:\n            db_session.refresh(blog)\n\n        yield blogs\n\n    @pytest.fixture\n    def test_blog_like(db_session, test_user, test_blog):\n        \"\"\"Create a test blog like.\"\"\"\n        from api.v1.models.blog import BlogLike\n\n        like = BlogLike(\n            blog_id=test_blog.id,\n            user_id=test_user.id,\n            ip_address=\"127.0.0.1\"\n        )\n\n        db_session.add(like)\n        db_session.commit()\n        db_session.refresh(like)\n\n        yield like\n\n    @pytest.fixture\n    def test_blog_dislike(db_session, test_user, test_blog):\n        \"\"\"Create a test blog dislike.\"\"\"\n        from api.v1.models.blog import BlogDislike\n\n        dislike = BlogDislike(\n            blog_id=test_blog.id,\n            user_id=test_user.id,\n            ip_address=\"127.0.0.1\"\n        )\n\n        db_session.add(dislike)\n        db_session.commit()\n        db_session.refresh(dislike)\n\n        yield dislike\n\n    @pytest.fixture\n    def test_multiple_users(db_session):\n        \"\"\"Create multiple test users for advanced testing.\"\"\"\n        from api.v1.models.user import User\n\n        users = []\n        for i in range(3):\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S\")\n            user = User(\n                email=f\"testuser{i}_{timestamp}@example.com\",\n                username=f\"testuser{i}_{timestamp}\",\n                first_name=f\"Test{i}\",\n                last_name=f\"User{i}\",\n                is_active=True,\n                is_verified=True,\n                is_deleted=False,\n                is_superadmin=(i == 0)  # Make one user a superadmin\n            )\n\n            db_session.add(user)\n            users.append(user)\n\n        db_session.commit()\n\n        # Refresh all users to get their IDs\n        for user in users:\n            db_session.refresh(user)\n\n        yield users\n\n        # No need to delete as transaction is rolled back"}
{"type": "test_file", "path": "test_case1.py", "content": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom aiosmtplib import send\nfrom email.message import EmailMessage\n\napp = FastAPI()\n\n# Email configuration\nEMAIL = \"project-test@hng.email\"\nPASSWORD = \"j*orWasSatc^TrdT7k7BGZ#\"\nSMTP_HOST = \"work.timbu.cloud\"\nSMTP_PORT = 465\n\n# Define a Pydantic model for the request body\nclass EmailRequest(BaseModel):\n    to_email: EmailStr\n    subject: str = \"Test Email\"\n    body: str = \"This is a test email from FastAPI\"\n\n\n\n@app.post(\"/send-tinbu-mail\")\nasync def send_email(email_request: EmailRequest):\n    # Create the email message\n    message = EmailMessage()\n    message[\"From\"] = EMAIL\n    message[\"To\"] = email_request.to_email\n    message[\"Subject\"] = email_request.subject\n    message.set_content(email_request.body)\n\n    # SMTP configuration\n    smtp_settings = {\n        \"hostname\": SMTP_HOST,\n        \"port\": SMTP_PORT,\n        \"username\": EMAIL,\n        \"password\": PASSWORD,\n        \"use_tls\": True,  # Use SSL/TLS for secure connection\n    }\n\n    try:\n        # Send the email\n        await send(message, **smtp_settings)\n        return {\"message\": f\"Email sent to {email_request.to_email} successfully\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to send email: {str(e)}\")\n"}
{"type": "test_file", "path": "tests/database.py", "content": "from fastapi.testclient import TestClient\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom main import app\nfrom decouple import config\n\n\nfrom api.db.database import get_db, Base\n\n\nDB_TYPE = config(\"DB_TYPE\")\nDB_NAME = config(\"DB_NAME\")\nDB_USER = config(\"DB_USER\")\nDB_PASSWORD = config(\"DB_PASSWORD\")\nDB_HOST = config(\"DB_HOST\")\nDB_PORT = config(\"DB_PORT\")\nMYSQL_DRIVER = config(\"MYSQL_DRIVER\")\nDATABASE_URL = \"\"\n\nif MYSQL_DRIVER:\n    # SQLALCHEMY_DATABASE_URL = f'{DB_TYPE}+{MYSQL_DRIVER}://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}_test'\n    SQLALCHEMY_DATABASE_URL = f'{DB_TYPE}+{MYSQL_DRIVER}://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}'\nelse:\n    # let's just create the tests on the main database to make the CI/CD pipeline happy ;)\n    SQLALCHEMY_DATABASE_URL = f'{DB_TYPE}://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}'\n\n\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\n\nTestingSessionLocal = sessionmaker(\n    autocommit=False, autoflush=False, bind=engine)\n\n\n@pytest.fixture()\ndef session():\n    Base.metadata.drop_all(bind=engine)\n    Base.metadata.create_all(bind=engine)\n    db = TestingSessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\n@pytest.fixture()\ndef client(session):\n    def override_get_db():\n\n        try:\n            yield session\n        finally:\n            session.close()\n    app.dependency_overrides[get_db] = override_get_db\n    yield TestClient(app)\n    "}
{"type": "test_file", "path": "tests/v1/activity_logs/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/v1/activity_logs/test_delete_activity_log.py", "content": "import pytest\nfrom unittest.mock import MagicMock\nfrom fastapi.testclient import TestClient\n\nfrom main import app\nfrom api.v1.services.activity_logs import activity_log_service\nfrom api.v1.models.activity_logs import ActivityLog\nfrom api.v1.services.user import user_service\n\nclient = TestClient(app)\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to provide a mock database session.\"\"\"\n    mock_db = MagicMock()\n    return mock_db\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"Fixture to mock the user service.\"\"\"\n    mock_user_service = MagicMock()\n    mock_user_service.create_access_token.return_value = \"mocked_access_token\"\n    mock_user_service.get_current_super_admin = MagicMock(return_value=MagicMock(is_superadmin=True))\n    return mock_user_service\n\ndef test_delete_activity_log(mock_db_session, mock_user_service):\n    \"\"\"Test the delete activity log endpoint.\"\"\"\n\n    app.dependency_overrides[user_service.get_current_super_admin] = mock_user_service.get_current_super_admin\n    activity_log_service.delete_activity_log_by_id = MagicMock(return_value={\n        \"status\": \"success\",\n        \"detail\": \"Activity log with ID 1 deleted successfully\"\n    })\n\n    access_token = mock_user_service.create_access_token(user_id=\"mocked_user_id\")\n    mock_db_session.query(ActivityLog).filter.return_value.first.return_value = ActivityLog(\n        id=1,\n        user_id=\"user_id\",\n        action=\"test_action\"\n    )\n\n    response = client.delete(\n        \"/api/v1/activity-logs/1\",\n        headers={'Authorization': f'Bearer {access_token}'},\n        params={'args': 'value', 'kwargs': 'value'}\n    )\n\n    assert response.status_code == 200\n    response_json = response.json()\n    assert response_json[\"message\"] == \"Activity log with ID 1 deleted successfully\""}
{"type": "test_file", "path": "tests/v1/auth/test_google_auth.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom requests.models import Response\nfrom main import app\nfrom api.v1.services.user import user_service\nfrom api.v1.models.user import User\nfrom api.db.database import get_db\nfrom uuid_extensions import uuid7\nfrom datetime import datetime, timezone\nfrom fastapi import status\nfrom fastapi.encoders import jsonable_encoder\n\nclient = TestClient(app)\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to create a mock database session.\"\"\"\n    with patch(\"api.v1.services.user.get_db\", autospec=True) as mock_get_db:\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"Fixture to create a mock user service.\"\"\"\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as mock_service:\n        yield mock_service\n\n@pytest.fixture\ndef mock_google_oauth_service():\n    \"\"\"Fixture to create a mock Google OAuth service.\"\"\"\n    with patch(\"api.v1.services.google_oauth.GoogleOauthServices\", autospec=True) as mock_service:\n        yield mock_service\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\", \"mock_google_oauth_service\")\ndef test_google_login_existing_user(mock_user_service, mock_google_oauth_service, mock_db_session):\n    \"\"\"Test Google login for an existing user.\"\"\"\n    email = \"existinguser@example.com\"\n    mock_id_token = \"mocked_id_token\"\n\n    # Mock user data\n    mock_user = User(\n        id=str(uuid7()),\n        email=email,\n        first_name='Existing',\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n\n    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_user\n    # Mock user service responses\n    mock_user_service.get_user_by_email.return_value = mock_user\n    mock_user_service.create_access_token.return_value = \"mock_access_token\"\n    mock_user_service.create_refresh_token.return_value = \"mock_refresh_token\"\n\n    # Mock Google OAuth token info response\n    with patch(\"requests.get\") as mock_get:\n        mock_response = MagicMock(spec=Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"email\": email}\n        mock_get.return_value = mock_response\n\n        # Perform the API request\n        response = client.post(\"api/v1/auth/google\", json={\"id_token\": \"mock_id_token\"})\n        # Assertions\n        assert response.status_code == status.HTTP_200_OK\n        response_json = response.json()\n        assert response_json[\"data\"][\"user\"][\"email\"] == email\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\", \"mock_google_oauth_service\")\ndef test_google_login_new_user(mock_user_service, mock_google_oauth_service, mock_db_session):\n    \"\"\"Test Google login for a new user.\"\"\"\n    email = \"newuser@gmail.com\"\n    mock_id_token = \"mocked_id_token\"\n\n    # Mock Google OAuth token info response\n    with patch(\"requests.get\") as mock_get:\n        mock_response = MagicMock(spec=Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"email\": email}\n        mock_get.return_value = mock_response\n\n        # Mock user retrieval returning None (new user)\n        mock_user_service.get_user_by_email.return_value = None\n\n        # Mock the GoogleOauthServices create method\n        mock_user = User(\n            id=str(uuid7()),\n            email=email,\n            first_name='New',\n            created_at=datetime.now(timezone.utc),\n            updated_at=datetime.now(timezone.utc)\n        )\n\n        mock_db_session.query.return_value.filter.return_value.first.return_value = mock_user\n\n        # Perform the API request\n        response = client.post(\"api/v1/auth/google\", json={\"id_token\": mock_id_token})\n\n        # Assertions\n        assert response.status_code == status.HTTP_200_OK\n        response_json = response.json()\n        assert response_json[\"data\"][\"user\"][\"email\"] == email"}
{"type": "test_file", "path": "tests/v1/auth/test_2fa.py", "content": "import pytest\nfrom api.v1.models.user import User\nfrom uuid_extensions import uuid7\nfrom api.v1.services.user import user_service\nfrom datetime import datetime, timezone\nfrom main import app\nfrom api.v1.models.totp_device import TOTPDevice\nfrom api.v1.services.totp import totp_service\nfrom fastapi.testclient import TestClient\nfrom fastapi import status, HTTPException\n\n\nclass TestTOTPDevice:\n    @pytest.fixture(autouse=True)\n    def setup(self):\n        self.test_user = User(\n            id=str(uuid7()),\n            email=\"testuser@gmail.com\",\n            password=user_service.hash_password(\"Testpassword@123\"),\n            first_name=\"Test\",\n            last_name=\"User\",\n            is_active=True,\n            is_superadmin=False,\n            created_at=datetime.now(timezone.utc),\n            updated_at=datetime.now(timezone.utc),\n        )\n        app.dependency_overrides[user_service.get_current_user] = lambda: self.test_user\n        self.client = TestClient(app)\n        self.test_secret = \"TESTSECRET\"\n        self.test_otpauth_url = \"otpauth://test?secret=TESTSECRET&issuer=app\"\n        self.test_qrcode_base64 = \"BASE64STRING\"\n        self.test_token = \"123456\"\n        self.test_totp_device_data_enable_success = {\"user_id\": self.test_user.id, \"confirmed\": True}\n        self.test_totp_device_data_disable_success = {\"user_id\": self.test_user.id, \"confirmed\": False}\n        yield\n        app.dependency_overrides.pop(user_service.get_current_user)\n\n    def test_setup_2fa_success(self, monkeypatch):\n        \"\"\"Test for successful TOTP device creation\"\"\"\n\n        mock_totp_device = TOTPDevice(\n            id=str(uuid7()),\n            user_id=self.test_user.id,\n            secret=self.test_secret,\n            confirmed=False,\n        )\n        monkeypatch.setattr(totp_service, \"create\", lambda db, schema: mock_totp_device)\n        monkeypatch.setattr(totp_service, \"generate_secret\", lambda: self.test_secret)\n        monkeypatch.setattr(\n            totp_service,\n            \"generate_otpauth_url\",\n            lambda secret, user_email, app_name: self.test_otpauth_url,\n        )\n        monkeypatch.setattr(\n            totp_service, \"generate_qrcode\", lambda otpauth_url: self.test_qrcode_base64\n        )\n\n        response = self.client.post(\"api/v1/auth/setup-2fa\")\n        response_json = response.json()\n\n        assert response.status_code == status.HTTP_201_CREATED\n        assert response_json.get(\"message\") == \"TOTP device created successfully.\"\n\n        data = response_json.get(\"data\")\n        assert data is not None\n        assert data.get(\"secret\") == self.test_secret\n        assert data.get(\"otpauth_url\") == self.test_otpauth_url\n        assert data.get(\"qrcode_base64\") == self.test_qrcode_base64\n\n    def test_setup_2fa_failure_existing_device(self, monkeypatch):\n        \"\"\"Test that setting up 2FA fails when device already exists\"\"\"\n\n        mock_totp_device = TOTPDevice(\n            id=str(uuid7()),\n            user_id=self.test_user.id,\n            secret=self.test_secret,\n            confirmed=False,\n        )\n        monkeypatch.setattr(totp_service, \"fetch\", lambda db, user_id: mock_totp_device)\n        monkeypatch.setattr(totp_service, \"generate_secret\", lambda: self.test_secret)\n\n        response = self.client.post(\"api/v1/auth/setup-2fa\")\n        response_json = response.json()\n\n        assert response.status_code == status.HTTP_409_CONFLICT\n        assert (\n            response_json.get(\"message\") == \"totp device for this user already exists\"\n        )\n\n    def test_setup_2fa_failure_unauthenticated(self, monkeypatch):\n        \"\"\"Test that setting up 2FA fails when user is not authenticated\"\"\"\n\n        app.dependency_overrides.pop(user_service.get_current_user, None)\n\n        def mock_auth_error():\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\"\n            )\n\n        app.dependency_overrides[user_service.get_current_user] = mock_auth_error\n\n        response = self.client.post(\"api/v1/auth/setup-2fa\")\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n        app.dependency_overrides[user_service.get_current_user] = lambda: self.test_user\n\n    def test_enable_2fa_success(self, monkeypatch):\n        \"\"\"Test that enabling TOTP device returns a 202 response with the expected data\"\"\"\n\n        mock_totp_device = TOTPDevice(\n            id=str(uuid7()),\n            user_id=self.test_user.id,\n            secret=self.test_secret,\n            confirmed=False,\n        )\n        \n        def mock_verify_token(db, user_id, schema, extra_action=None):\n            if extra_action == \"enable\":\n                mock_totp_device.confirmed = True\n                return mock_totp_device\n            return None\n        \n        monkeypatch.setattr(\n            totp_service,\n            \"verify_token\",\n            mock_verify_token\n        )\n    \n        payload = {\"totp_token\": self.test_token}\n        \n        response = self.client.put(\"api/v1/auth/enable-2fa\", json=payload)\n        response_json = response.json()\n        \n        assert response.status_code == status.HTTP_202_ACCEPTED\n        assert response_json.get(\"message\") == \"TOTP device enabled successfully.\"\n        assert response_json.get(\"data\") == self.test_totp_device_data_enable_success\n        \n    def test_disable_2fa_success(self, monkeypatch):\n        \"\"\"Test that disabling TOTP device returns a 202 response with the expected data\"\"\"\n\n        mock_totp_device = TOTPDevice(\n            id=str(uuid7()),\n            user_id=self.test_user.id,\n            secret=self.test_secret,\n            confirmed=False,\n        )\n        \n        def mock_verify_token(db, user_id, schema, extra_action=None):\n            if extra_action == \"disable\":\n                mock_totp_device.confirmed = False\n                return mock_totp_device\n            return None\n        \n        monkeypatch.setattr(\n            totp_service,\n            \"verify_token\",\n            mock_verify_token\n        )\n    \n        payload = {\"totp_token\": self.test_token}\n        \n        response = self.client.put(\"api/v1/auth/disable-2fa\", json=payload)\n        response_json = response.json()\n        \n        assert response.status_code == status.HTTP_202_ACCEPTED\n        assert response_json.get(\"message\") == \"TOTP device disabled successfully.\"\n        assert response_json.get(\"data\") == self.test_totp_device_data_disable_success"}
{"type": "test_file", "path": "tests/v1/auth/test_email_verification.py", "content": "import uuid\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import AsyncMock, MagicMock, patch\nfrom main import app\nfrom api.db.database import Base, engine\nfrom api.v1.models import User\nfrom sqlalchemy.orm import sessionmaker\nfrom datetime import datetime, timedelta\nfrom jose import jwt\nfrom api.utils.settings import settings\nimport uuid\n\n# Set up a test database session\nTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n@pytest.fixture(scope=\"module\")\ndef client():\n    \"\"\"Fixture to provide a test client for the API.\"\"\"\n    Base.metadata.create_all(bind=engine)\n    test_client = TestClient(app)\n    yield test_client\n\n@pytest.fixture(scope=\"function\")\ndef db_session():\n    \"\"\"Fixture to provide a fresh database session for each test.\"\"\"\n    db = TestingSessionLocal()\n    yield db\n    db.close()\n\n\n\ndef create_test_user(db_session, email=None, verified=False):\n    \"\"\"Helper function to create a test user with a unique email.\"\"\"\n    if email is None:\n        email = f\"testuser_{uuid.uuid4().hex[:8]}@gmail.com\"  # Generate inside function\n\n    user = User(\n        email=email,\n        password=\"Jeffmaine240@\", \n        first_name=\"jeff\", \n        last_name=\"last\", \n        is_verified=verified\n    )\n    db_session.add(user)\n    db_session.commit()\n    db_session.refresh(user)\n    return user\n\n\ndef generate_token(user_id, expired=False):\n    \"\"\"Helper function to generate a JWT token.\"\"\"\n    # expiry_time = datetime.now() + timedelta(seconds=exp)\n    # exp_timestamp = int(expiry_time.timestamp())\n    exp_time = int((datetime.now() + (timedelta(minutes=-1) if expired else timedelta(minutes=30))).timestamp())\n    return jwt.encode({\"sub\": user_id, \"exp\": exp_time}, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n\n\n# @patch(\"api.core.dependencies.email_sender.send_email\")\n# def test_resend_verification_email(mock_send_email, client:TestClient, db_session):\n#     \"\"\"Test resending verification email.\"\"\"\n#     user = create_test_user(db_session)\n#     response = client.post(\"/api/v1/auth/resend_verification_email\", json={\"email\": user.email})\n#     assert response.status_code == 200\n#     data = response.json()\n#     assert data[\"status\"] == \"success\"\n#     assert data[\"message\"] == \"Verification email sent successfully\"\n    # print(mock_send_email.call_args_list)\n\n\n\ndef test_verify_email_valid_token(client: TestClient, db_session):\n    \"\"\"Test email verification with a valid token.\"\"\"\n    user = create_test_user(db_session)\n    token = generate_token(user.id)\n    response = client.get(f\"/api/v1/auth/verify-email?token={token}\")\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"status\"] == \"success\"\n    assert data[\"message\"] == \"Email verified successfully.\"\n\n\ndef test_verify_email_expired_token(client: TestClient, db_session):\n    \"\"\"Test email verification with an expired token.\"\"\"\n    user = create_test_user(db_session)\n    token = generate_token(user.id, expired=True)\n    response = client.get(f\"/api/v1/auth/verify-email?token={token}\")\n    assert response.status_code == 400\n    data = response.json()\n    assert data[\"status\"] is False\n    assert data[\"message\"] == \"Verification link expired\"\n\n\ndef test_verify_email_invalid_token(client:TestClient):\n    \"\"\"Test email verification with an invalid token.\"\"\"\n    response = client.get(\"/api/v1/auth/verify-email?token=invalidtoken\")\n    assert response.status_code == 400\n    data = response.json()\n    print(data)\n    assert data[\"message\"] == \"Invalid token\""}
{"type": "test_file", "path": "tests/v1/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/v1/activity_logs/test_get_all_logs.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom main import app\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom api.v1.services.activity_logs import ActivityLog\nfrom uuid_extensions import uuid7\nfrom api.db.database import get_db\nfrom fastapi import status\nfrom datetime import datetime, timezone, timedelta\n\n\nclient = TestClient(app)\nACTIVITY_LOGS_ENDPOINT = '/api/v1/activity-logs'\n\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to create a mock database session.\"\"\"\n\n    with patch(\"api.v1.services.user.get_db\", autospec=True) as mock_get_db:\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"Fixture to create a mock user service.\"\"\"\n\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as mock_service:\n        yield mock_service\n\n\ndef create_mock_user(mock_user_service, mock_db_session, is_superadmin=True):\n    \"\"\"Create a mock user in the mock database session.\"\"\"\n    mock_user = User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=user_service.hash_password(\"Testpassword@123\"),\n        first_name='Test',\n        last_name='User',\n        is_active=True,\n        is_superadmin=is_superadmin,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_user\n    return mock_user\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_get_all_activity_logs_empty(mock_user_service, mock_db_session):\n    \"\"\"Test for fetching all activity logs with no data.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n    response = client.get(ACTIVITY_LOGS_ENDPOINT, headers={\n                          'Authorization': f'Bearer {access_token}'})\n\n    assert response.status_code == status.HTTP_200_OK\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_get_all_activity_logs_with_data(mock_user_service, mock_db_session):\n    \"\"\"Test for fetching all activity logs with data.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n\n    log_id = str(uuid7())\n    user_id = str(uuid7())\n    timezone_offset = -8.0\n    tzinfo = timezone(timedelta(hours=timezone_offset))\n    timeinfo = datetime.now(tzinfo)\n    created_at = timeinfo\n    updated_at = timeinfo\n\n    activity_log = ActivityLog(\n        id=log_id,\n        user_id=user_id,\n        action=\"profile Update\",\n        timestamp=timeinfo,\n        created_at=created_at,\n        updated_at=updated_at\n    )\n\n    mock_db_session.query.return_value.filter.return_value.all.return_value = [\n        activity_log]\n\n    response = client.get(ACTIVITY_LOGS_ENDPOINT, headers={\n                          'Authorization': f'Bearer {access_token}'})\n\n    assert response.status_code == status.HTTP_200_OK\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_get_all_activity_logs_non_super_admin(mock_user_service, mock_db_session):\n    \"\"\"Test for fetching all activity logs as a non-super admin user.\"\"\"\n    mock_user = create_mock_user(\n        mock_user_service, mock_db_session, is_superadmin=False)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n    response = client.get(ACTIVITY_LOGS_ENDPOINT, headers={\n                          'Authorization': f'Bearer {access_token}'})\n\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n\n\n@pytest.mark.parametrize(\"action\", [\"login\", \"logout\"])\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_get_activity_logs_by_action(mock_user_service, mock_db_session, action):\n    \"\"\"Test for fetching activity logs filtered by different actions.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n\n    log_id = str(uuid7())\n    user_id = str(uuid7())\n    timestamp = datetime.now(timezone.utc)\n\n    activity_log = ActivityLog(\n        id=log_id,\n        user_id=user_id,\n        action=action,\n        timestamp=timestamp,\n        created_at=timestamp,\n        updated_at=timestamp\n    )\n\n    mock_db_session.query.return_value.filter.return_value.all.return_value = [activity_log]\n\n    response = client.get(f\"{ACTIVITY_LOGS_ENDPOINT}?action={action}\", headers={\n        'Authorization': f'Bearer {access_token}'\n    })\n\n    assert response.status_code == status.HTTP_200_OK\n    \n\n@pytest.mark.parametrize(\"action\", [\"login\", \"logout\"])\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_get_activity_logs_by_action_no_data(mock_user_service, mock_db_session, action):\n    \"\"\"Test for fetching activity logs when no logs match the action.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n\n    mock_db_session.query.return_value.filter.return_value.all.return_value = []\n\n    response = client.get(f\"{ACTIVITY_LOGS_ENDPOINT}?action={action}\", headers={\n        'Authorization': f'Bearer {access_token}'\n    })\n\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\n\n@pytest.mark.parametrize(\"action\", [\"login\", \"logout\"])\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_get_all_activity_logs_non_super_admin(mock_user_service, mock_db_session, action):\n    \"\"\"Test for fetching all activity logs matching the action as a non-super admin user.\"\"\"\n    mock_user = create_mock_user(\n        mock_user_service, mock_db_session, is_superadmin=False)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n    response = client.get(f\"{ACTIVITY_LOGS_ENDPOINT}?action={action}\", headers={\n                          'Authorization': f'Bearer {access_token}'})\n\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n"}
{"type": "test_file", "path": "tests/v1/analytics/test_analytics_summary.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch\nfrom datetime import datetime, timedelta\nfrom api.v1.routes.dashboard import get_analytics_summary\nfrom api.v1.services.analytics import AnalyticsServices\nfrom api.v1.schemas.analytics import AnalyticsSummaryResponse\nfrom main import app\nfrom api.db.database import get_db\n\n\nclient = TestClient(app)\n\n\n@pytest.fixture\ndef mock_analytics_service(mocker):\n    mock = mocker.patch(\n        'api.v1.services.analytics.AnalyticsServices', autospec=True)\n    mock.get_summary_data_super_admin = mocker.Mock()\n    mock.get_summary_data_organisation = mocker.Mock()\n    return mock\n\n\n@pytest.fixture\ndef mock_oauth2_scheme(mocker):\n    return mocker.patch('api.v1.services.user.oauth2_scheme', return_value=\"test_token\")\n\n\n@pytest.fixture\ndef mock_get_current_user_super_admin(mocker):\n    return mocker.patch('api.v1.services.user.user_service.get_current_user', return_value=MagicMock(is_superadmin=True, id=\"super_admin_id\"))\n\n\n@pytest.fixture\ndef mock_get_current_user_user(mocker):\n    return mocker.patch('api.v1.services.user.user_service.get_current_user', return_value=MagicMock(is_superadmin=False, id=\"user_id\", organisation_id=\"org_id\"))\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to create a mock database session.\"\"\"\n    with patch(\"api.v1.services.user.get_db\", autospec=True) as mock_get_db:\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n\ndef test_statistics_summary_super_admin(mock_analytics_service, mock_oauth2_scheme, mock_get_current_user_super_admin, mock_db_session):\n    expected_response = AnalyticsSummaryResponse(\n        message=\"Admin Statistics Fetched\",\n        status='success',\n        status_code=200,\n        data={\n            \"total_revenue\": {\n                \"current_month\": 10000,\n                \"previous_month\": 9000,\n                \"percentage_difference\": \"11.11%\"\n            },\n            \"total_users\": {\n                \"current_month\": 200,\n                \"previous_month\": 180,\n                \"percentage_difference\": \"11.11%\"\n            },\n            \"total_products\": {\n                \"current_month\": 50,\n                \"previous_month\": 45,\n                \"percentage_difference\": \"11.11%\"\n            },\n            \"lifetime_sales\": {\n                \"current_month\": 50000,\n                \"previous_month\": 45000,\n                \"percentage_difference\": \"11.11%\"\n            }\n        }\n    )\n\n    token = \"superadmin_token\"\n    start_date = datetime.utcnow() - timedelta(days=30)\n    end_date = datetime.utcnow()\n\n    response = client.get(\n        \"/api/v1/dashboard/statistics\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        params={\"start_date\": \"2024-07-09T00:00:00\",\n                \"end_date\": \"2024-08-08T00:00:00\"}\n    )\n\n    assert response.status_code == 200\n\n\ndef test_statistics_summary_user(mock_analytics_service, mock_oauth2_scheme, mock_get_current_user_user, mock_db_session):\n    expected_response = AnalyticsSummaryResponse(\n        message=\"User Statistics Fetched\",\n        status='success',\n        status_code=200,\n        data={\n            \"revenue\": {\n                \"current_month\": 5000,\n                \"previous_month\": 4500,\n                \"percentage_difference\": \"11.11%\"\n            },\n            \"subscriptions\": {\n                \"current_month\": 100,\n                \"previous_month\": 90,\n                \"percentage_difference\": \"11.11%\"\n            },\n            \"orders\": {\n                \"current_month\": 150,\n                \"previous_month\": 135,\n                \"percentage_difference\": \"11.11%\"\n            },\n            \"active_users\": {\n                \"current\": 25,\n                \"difference_an_hour_ago\": 13\n            }\n        }\n    )\n\n    token = \"user_token\"\n    start_date = datetime.utcnow() - timedelta(days=30)\n    end_date = datetime.utcnow()\n\n    response = client.get(\n        \"/api/v1/dashboard/statistics\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        params={\"start_date\": \"2024-07-09T00:00:00\",\n                \"end_date\": \"2024-08-08T00:00:00\"}\n    )\n\n    assert response.status_code == 200\n\n\ndef test_statistics_summary_no_dates(mock_analytics_service, mock_oauth2_scheme, mock_get_current_user_user, mock_db_session):\n    expected_response = AnalyticsSummaryResponse(\n        message=\"User Statistics Fetched\",\n        status='success',\n        status_code=200,\n        data={\n            \"revenue\": {\n                \"current_month\": 3000,\n                \"previous_month\": 2700,\n                \"percentage_difference\": \"11.11%\"\n            },\n            \"subscriptions\": {\n                \"current_month\": 75,\n                \"previous_month\": 67,\n                \"percentage_difference\": \"11.94%\"\n            },\n            \"orders\": {\n                \"current_month\": 120,\n                \"previous_month\": 108,\n                \"percentage_difference\": \"11.11%\"\n            },\n            \"active_users\": {\n                \"current\": 25,\n                \"difference_an_hour_ago\": 11\n            }\n        }\n    )\n\n    token = \"user_token\"\n\n    response = client.get(\n        \"/api/v1/dashboard/statistics\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n\n    assert response.status_code == 200\n"}
{"type": "test_file", "path": "tests/v1/activity_logs/test_create_activity_log.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom main import app\nfrom api.v1.models.activity_logs import ActivityLog\nfrom api.v1.services.activity_logs import activity_log_service\nfrom api.db.database import get_db\nfrom fastapi import status\n\nclient = TestClient(app)\nCREATE_ACTIVITY_LOG_ENDPOINT = '/api/v1/activity-logs/create'\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to create a mock database session.\"\"\"\n    with patch(\"api.v1.services.user.get_db\", autospec=True) as mock_get_db:\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n@pytest.fixture\ndef mock_activity_log_service():\n    \"\"\"Fixture to create a mock activity log service.\"\"\"\n    with patch(\"api.v1.services.activity_logs.activity_log_service\", autospec=True) as mock_service:\n        yield mock_service\n\ndef create_mock_activity_log(mock_db_session, user_id: str, action: str):\n    \"\"\"Create a mock activity log in the mock database session.\"\"\"\n    mock_activity_log = ActivityLog(\n        id=1,\n        user_id=user_id,\n        action=action,\n        timestamp=\"2023-01-01T00:00:00\"\n    )\n    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_activity_log\n    return mock_activity_log\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_activity_log_service\")\ndef test_create_activity_log(mock_activity_log_service, mock_db_session):\n    \"\"\"Test for creating an activity log.\"\"\"\n    mock_user_id = \"101\"\n    mock_action = \"test_action\"\n    \n    mock_activity_log = create_mock_activity_log(mock_db_session, mock_user_id, mock_action)\n    mock_activity_log_service.create_activity_log.return_value = mock_activity_log\n    \n    response = client.post(\n        CREATE_ACTIVITY_LOG_ENDPOINT,\n        json={\"user_id\": mock_user_id, \"action\": mock_action}\n    )\n    \n    assert response.status_code == status.HTTP_201_CREATED\n    assert response.json() == {\n        \"status_code\": 201,\n        \"message\": \"Activity log created successfully\",\n        \"status\": \"success\",\n        \"data\": {\n            \"user_id\": mock_activity_log.user_id,\n            \"action\": mock_activity_log.action,\n        }\n    }\n"}
{"type": "test_file", "path": "tests/v1/analytics/test_line_chart_data.py", "content": "import pytest\nfrom unittest.mock import patch, MagicMock\nfrom sqlalchemy.orm import Session\nfrom fastapi.security import OAuth2PasswordBearer\nimport calendar\n\nfrom api.v1.services.analytics import AnalyticsServices\nfrom api.v1.schemas.analytics import AnalyticsChartsResponse\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n@pytest.fixture\ndef mock_db():\n    \"\"\"\n    Mock db\n    \"\"\"\n    with patch(\"api.v1.services.analytics.get_db\", return_value=MagicMock(spec=Session)) as mock:\n        yield mock\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"\n    Mock user_service\n    \"\"\"\n    with patch(\"api.v1.services.user.user_service.get_current_user\") as mock:\n        yield mock\n\n@pytest.fixture\ndef mock_oauth2_scheme():\n    \"\"\"\n    Mock oauth2 scheme\n    \"\"\"\n    with patch(\"api.v1.services.user.oauth2_scheme\", return_value=\"test_token\") as mock:\n        yield mock\n\ndef test_get_analytics_line_chart_super_admin(mock_db, mock_user_service, mock_oauth2_scheme):\n    \"\"\"\n    Test get analytics line_chart_data for super_admin\n    \"\"\"\n    # Arrange\n    mock_user = MagicMock()\n    mock_user.is_superadmin = True\n    mock_user_service.return_value = mock_user\n\n    mock_db.query.return_value.filter_by.return_value.first.return_value = None\n\n    analytics_service = AnalyticsServices()\n\n    # Act\n    response = analytics_service.get_analytics_line_chart(token=\"test_token\", db=mock_db)\n\n    # Assert\n    assert isinstance(response, AnalyticsChartsResponse)\n    assert response.status == \"success\"\n    assert response.data is not None\n\ndef test_get_analytics_line_chart_non_super_admin(mock_db, mock_user_service, mock_oauth2_scheme):\n    \"\"\"\n    Test get analytics_line_chart_data for non super_admin with organisation\n    \"\"\"\n    # Arrange\n    mock_user = MagicMock()\n    mock_user.is_superadmin = False\n    mock_user_service.return_value = mock_user\n\n    mock_user_organisation = MagicMock()\n    mock_db.query.return_value.filter_by.return_value.first.return_value = mock_user_organisation\n\n    analytics_service = AnalyticsServices()\n\n    # Act\n    response = analytics_service.get_analytics_line_chart(token=\"test_token\", db=mock_db)\n\n    # Assert\n    assert isinstance(response, AnalyticsChartsResponse)\n    assert response.status == \"success\"\n    assert response.data is not None\n\ndef test_get_analytics_line_chart_no_org(mock_db, mock_user_service, mock_oauth2_scheme):\n    \"\"\"\n    Test get analytics_line_chart_data for non super_admin without organisation\n    \"\"\"\n    # Arrange\n    mock_user = MagicMock()\n    mock_user.is_superadmin = False\n    mock_user_service.return_value = mock_user\n\n    mock_db.query.return_value.filter_by.return_value.first.return_value = None\n\n    analytics_service = AnalyticsServices()\n\n    # Act\n    response = analytics_service.get_analytics_line_chart(token=\"test_token\", db=mock_db)\n\n    # Assert\n    assert isinstance(response, AnalyticsChartsResponse)\n    assert response.status == \"success\"\n    assert response.data == {month: 0 for month in calendar.month_name if month}\n"}
{"type": "test_file", "path": "tests/v1/auth/test_token_auth.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom unittest.mock import MagicMock, patch\nfrom datetime import datetime, timedelta\n\nfrom main import app\nfrom api.v1.models.token_login import TokenLogin\nfrom api.v1.models.user import User\nfrom api.v1.routes.auth import get_db\n\n@pytest.fixture\ndef db_session_mock():\n    db_session = MagicMock(spec=Session)\n    return db_session\n\n# Override the dependency with the mock\n@pytest.fixture(autouse=True)\ndef override_get_db(db_session_mock):\n    def get_db_override():\n        yield db_session_mock\n    \n    app.dependency_overrides[get_db] = get_db_override\n    yield\n\n    app.dependency_overrides = {}\n\nclient = TestClient(app)\n\ntoken = TokenLogin(token=\"123456\", expiry_time=datetime.utcnow() + timedelta(seconds=60))\n\n@patch('api.v1.services.user.UserService.generate_token')\ndef test_request_signin_token(mock_generate_token, db_session_mock):\n    # Mock user\n    user = User(email=\"user@gmail.com\", id=\"someid\")\n    db_session_mock.query.return_value.filter.return_value.first.return_value = token\n    response = {\"status_code\": 200, \"message\": f\"Sign-in token sent to {user.email}\"}\n\n    assert response.get(\"status_code\") == 200\n    assert response[\"message\"] == f\"Sign-in token sent to {user.email}\"\n    \n\n@patch('api.v1.services.user.UserService.verify_login_token')\ndef test_verify_signin_token(mock_verify_login_token, db_session_mock):\n    # Mock user with token\n    user = User(email=\"user@gmail.com\", id=\"someid\")\n    db_session_mock.query.return_value.filter.return_value.first.return_value = user\n    \n    mock_verify_login_token.return_value = user\n\n    response = client.post(\"/api/v1/auth/verify-token\",\n                           json={\"email\": \"user@gmail.com\", \"token\": \"123456\"})\n\n    assert response.status_code == 200\n    assert \"access_token\" in response.json()['data']\n"}
{"type": "test_file", "path": "tests/v1/blog/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/v1/auth/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/v1/billing_plan/test_billing_plan.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom main import app\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom uuid_extensions import uuid7\nfrom api.db.database import get_db\nfrom fastapi import status\nfrom datetime import datetime, timezone\n\n\nclient = TestClient(app)\n\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to create a mock database session.\"\"\"\n\n    with patch(\"api.v1.services.user.get_db\", autospec=True) as mock_get_db:\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"Fixture to create a mock user service.\"\"\"\n\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as mock_service:\n        yield mock_service\n\n\ndef create_mock_user(mock_user_service, mock_db_session):\n    \"\"\"Create a mock user in the mock database session.\"\"\"\n    mock_user = User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=user_service.hash_password(\"Testpassword@123\"),\n        first_name=\"Test\",\n        last_name=\"User\",\n        is_active=True,\n        is_superadmin=True,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc),\n    )\n    mock_db_session.query.return_value.filter.return_value.first.return_value = (\n        mock_user\n    )\n    return mock_user\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_fetch_all_plans(mock_user_service, mock_db_session):\n    \"\"\"Test for user deactivation errors.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n    response = client.get(\n        \"/api/v1/organisations/123-1221-090/billing-plans\",\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n    )\n\n    assert response.status_code == status.HTTP_200_OK\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_create_exisiting_plans(mock_user_service, mock_db_session):\n    \"\"\"Billing plan creation test.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n    data = {\n        \"name\": \"Advanced\",\n        \"organisation_id\": \"s2334d\",\n        \"description\": \"All you need in one pack\",\n        \"price\": 80,\n        \"duration\": \"monthly\",\n        \"currency\": \"Naira\",\n        \"features\": [\"Multiple team\", \"Premium support\"],\n    }\n\n    response = client.post(\n        \"/api/v1/organisations/billing-plans\",\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n        json=data,\n    )\n    print(response.json())\n\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n"}
{"type": "test_file", "path": "tests/v1/auth/test_signup.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch\nfrom main import app\nfrom api.db.database import get_db\nfrom api.v1.models.newsletter import Newsletter\nfrom api.v1.models.user import User\nfrom slowapi.errors import RateLimitExceeded\nimport uuid\nimport time\n\nclient = TestClient(app)\n\n# Mock the database dependency\n@pytest.fixture\ndef db_session_mock():\n    db_session = MagicMock()\n    yield db_session\n\n# Override the dependency with the mock\n@pytest.fixture(autouse=True)\ndef override_get_db(db_session_mock):\n    def get_db_override():\n        yield db_session_mock\n    \n    app.dependency_overrides[get_db] = get_db_override\n    yield\n\n    app.dependency_overrides = {}\n\ndef test_status_code(db_session_mock, mock_send_email):\n    db_session_mock.query(Newsletter).filter().first.return_value = None\n    db_session_mock.add.return_value = None\n    db_session_mock.commit.return_value = None\n\n    user = {\n        \"password\": \"strin8Hsg263@\",\n        \"first_name\": \"string\",\n        \"last_name\": \"string\",\n        \"email\": \"user@gmail.com\",\n        \"confirm_password\": \"strin8Hsg263@\"  # added confirm_password field\n    }\n\n    response = client.post(\"/api/v1/auth/register\", json=user)\n\n    assert response.status_code == 201\n\ndef test_user_fields(db_session_mock, mock_send_email):\n    db_session_mock.query(Newsletter).filter().first.return_value = None\n    db_session_mock.add.return_value = None\n    db_session_mock.commit.return_value = None\n\n    user = {\n        \"password\": \"strin8Hsg263@\",\n        \"first_name\": \"sunday\",\n        \"last_name\": \"mba\",\n        \"email\": \"mba@gmail.com\",\n        \"confirm_password\": \"strin8Hsg263@\"  # added confirm_password field\n    }\n\n    response = client.post(\"/api/v1/auth/register\", json=user)\n\n    assert response.status_code == 201\n    assert response.json()['data'][\"user\"]['email'] == \"mba@gmail.com\"\n    assert response.json()['data'][\"user\"]['first_name'] == \"sunday\"\n    assert response.json()['data'][\"user\"]['last_name'] == \"mba\"\n    # mock_send_email.assert_called_once()\n\ndef test_rate_limiting(db_session_mock):\n    db_session_mock.query(User).filter().first.return_value = None\n    db_session_mock.add.return_value = None\n    db_session_mock.commit.return_value = None\n    \n    unique_email = f\"rate.limit.{uuid.uuid4()}@gmail.com\"\n    user = {\n        \"password\": \"ValidP@ssw0rd!\",\n        \"first_name\": \"Rate\",\n        \"last_name\": \"Limit\",\n        \"email\": unique_email,\n        \"confirm_password\": \"ValidP@ssw0rd!\"  # added confirm_password field\n    }\n\n    response = client.post(\"/api/v1/auth/register\", json=user)\n    assert response.status_code == 201, f\"Expected 201, got {response.status_code}: {response.json()}\"\n\n    time.sleep(60)  # Adjust this delay to see if it prevents rate limiting\n\n    for _ in range(5):\n        response = client.post(\"/api/v1/auth/register\", json=user)\n        assert response.status_code == 201, f\"Expected 201, got {response.status_code}: {response.json()}\""}
{"type": "test_file", "path": "tests/v1/auth/test_rate_limiting.py", "content": "from unittest.mock import MagicMock\nimport uuid\nimport pytest\nfrom fastapi.testclient import TestClient\n\nfrom api.db.database import get_db\nfrom main import app\n\nclient = TestClient(app)\n\n@pytest.fixture\ndef db_session_mock():\n    \"\"\"Mock the database dependency\"\"\"\n    db_session = MagicMock()\n    yield db_session\n\n@pytest.fixture(autouse=True)\ndef override_get_db(db_session_mock):\n    \"\"\"Override the get_db dependency with the mock\"\"\"\n    def get_db_override():\n        yield db_session_mock\n    app.dependency_overrides[get_db] = get_db_override\n    yield\n    app.dependency_overrides = {}\n\ndef test_rate_limiting(db_session_mock, mock_send_email):\n    \"\"\"Test registration endpoint rate limiting\"\"\"\n    db_session_mock.query.return_value.filter.return_value.first.return_value = None\n    db_session_mock.add.return_value = None\n    db_session_mock.commit.return_value = None\n\n    unique_email = f\"rate.limit.{uuid.uuid4()}@gmail.com\"\n    \n    user_template = {\n        \"password\": \"strin8Hsg263@\",\n        \"first_name\": \"string\",\n        \"last_name\": \"string\",\n        \"email\": unique_email,\n        \"confirm_password\": \"strin8Hsg263@\"\n    }\n\n    headers = {\"X-Forwarded-For\": \"192.168.123.132\"}\n\n    # Send 5 successful requests\n    for _ in range(5):\n        response = client.post(\"/api/v1/auth/register\", json=user_template, headers=headers)\n        assert response.status_code == 201\n\n    # Sixth request should be blocked\n    response = client.post(\"/api/v1/auth/register\", json=user_template, headers=headers)\n    assert response.status_code == 429\n    assert \"too many requests\" in response.json().get(\"message\", \"\").lower()\n"}
{"type": "test_file", "path": "tests/v1/auth/test_verify_magic_link.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch\nfrom api.db.database import get_db\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom sqlalchemy.orm import Session\nfrom main import app\nfrom datetime import datetime, timezone\nfrom uuid_extensions import uuid7\n\n\n# Mock database dependency\n@pytest.fixture\ndef db_session_mock():\n    db_session = MagicMock(spec=Session)\n    return db_session\n\n@pytest.fixture\ndef client(db_session_mock):\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    client = TestClient(app)\n    yield client\n    app.dependency_overrides = {}\n\ndef create_mock_user(mock_db_session):\n    \"\"\"Create a mock user in the mock database session.\"\"\"\n    mock_user = User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=user_service.hash_password(\"Testpassword@123\"),\n        first_name='Test',\n        last_name='User',\n        is_active=True,\n        is_superadmin=False,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_user\n\n    return mock_user\n\ndef test_verify_magic_link(client, db_session_mock):\n    user = create_mock_user(db_session_mock)\n    token = user_service.create_access_token(user_id=user.id)\n\n    response = client.post(\"/api/v1/auth/magic-link/verify\", json={\n        \"token\": token,\n    })\n    assert response.status_code == 200\n    data = response.json()\n    print(data)\n    assert data['message'] == 'Login successful'\n    assert data['data']['access_token'] == token\n\n"}
{"type": "test_file", "path": "tests/v1/auth/test_signin.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock\nfrom main import app\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom api.v1.services.totp import totp_service\nfrom uuid_extensions import uuid7\nfrom api.db.database import get_db\nfrom fastapi import status\nfrom datetime import datetime, timezone\nfrom api.v1.models.totp_device import TOTPDevice\nimport pyotp\n\n# Client for test_user_login function\nclient = TestClient(app)\n\n\nclass TestUserLogin:\n    @pytest.fixture(autouse=True)\n    def setup(self):\n        self.client = TestClient(app)\n        self.mock_user = User(\n            id=str(uuid7()),\n            email=\"testuser1@gmail.com\",\n            password=user_service.hash_password(\"Testpassword@123\"),\n            first_name=\"Test\",\n            last_name=\"User\",\n            is_active=True,\n            is_superadmin=False,\n            created_at=datetime.now(timezone.utc),\n            updated_at=datetime.now(timezone.utc),\n        )\n        self.mock_totp_device = TOTPDevice(\n            user_id=self.mock_user.id,\n            secret=pyotp.random_base32(),\n            confirmed=False,\n        )\n        self.mock_totp_code = pyotp.TOTP(self.mock_totp_device.secret).now()\n\n    def test_user_login_success_without_2FA(self, monkeypatch):\n        \"\"\"Test successful login without 2FA\"\"\"\n\n        monkeypatch.setattr(\n            user_service,\n            \"authenticate_user\",\n            lambda db, email, password: self.mock_user\n        )\n        monkeypatch.setattr(\n            totp_service,\n            \"check_2fa_status_and_verify\",\n            lambda db, user_id, schema: True\n        )\n        monkeypatch.setattr(\n            \"api.v1.services.organisation.organisation_service.retrieve_user_organizations\",\n            lambda user, db: []\n        )\n\n        response = self.client.post(\n            \"/api/v1/auth/login\",\n            json={\"email\": \"testuser1@gmail.com\", \"password\": \"Testpassword@123\"},\n        )\n        response_json = response.json()\n\n        assert response.status_code == status.HTTP_200_OK\n        assert response_json.get(\"status_code\") == status.HTTP_200_OK\n        assert response_json.get(\"message\") == \"Login successful\"\n\n    def test_user_login_success_with_2FA(self, monkeypatch):\n        \"\"\"Test successful login with 2FA enabled and valid code\"\"\"\n\n        self.mock_totp_device.confirmed = True\n        monkeypatch.setattr(\n            user_service,\n            \"authenticate_user\",\n            lambda db, email, password: self.mock_user\n        )\n        monkeypatch.setattr(\n            totp_service,\n            \"check_2fa_status_and_verify\",\n            lambda db, user_id, schema: True\n        )\n        monkeypatch.setattr(\n            \"api.v1.services.organisation.organisation_service.retrieve_user_organizations\",\n            lambda user, db: []\n        )\n\n        response = self.client.post(\n            \"/api/v1/auth/login\",\n            json={\n                \"email\": \"testuser1@gmail.com\",\n                \"password\": \"Testpassword@123\",\n                \"totp_code\": f\"{self.mock_totp_code}\"\n            },\n        )\n        response_json = response.json()\n\n        assert response.status_code == status.HTTP_200_OK\n        assert response_json.get(\"status_code\") == status.HTTP_200_OK\n        assert response_json.get(\"message\") == \"Login successful\"\n\n    def test_user_login_success_with_2FA_disabled(self, monkeypatch):\n        \"\"\"Test successful login with 2FA set up but not confirmed/enabled\"\"\"\n\n        monkeypatch.setattr(\n            user_service,\n            \"authenticate_user\",\n            lambda db, email, password: self.mock_user\n        )\n        monkeypatch.setattr(\n            totp_service,\n            \"check_2fa_status_and_verify\",\n            lambda db, user_id, schema: True\n        )\n        monkeypatch.setattr(\n            \"api.v1.services.organisation.organisation_service.retrieve_user_organizations\",\n            lambda user, db: []\n        )\n        response = self.client.post(\n            \"/api/v1/auth/login\",\n            json={\"email\": \"testuser1@gmail.com\", \"password\": \"Testpassword@123\"},\n        )\n\n        response_json = response.json()\n        assert response.status_code == status.HTTP_200_OK\n        assert response_json.get(\"status_code\") == status.HTTP_200_OK\n        assert response_json.get(\"message\") == \"Login successful\"\n\n    def test_user_login_failure_with_2FA_enabled_without_code(self, monkeypatch):\n        \"\"\"Test login failure when 2FA is enabled but no code is provided\"\"\"\n\n        self.mock_totp_device.confirmed = True\n        monkeypatch.setattr(\n            user_service,\n            \"authenticate_user\",\n            lambda db, email, password: self.mock_user\n        )\n\n        def mock_check_2fa_status_and_verify():\n            from fastapi import HTTPException\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"2FA is enabled for this user. Provide a valid TOTP code.\"\n            )\n\n        monkeypatch.setattr(\n            totp_service,\n            \"check_2fa_status_and_verify\",\n            lambda db, user_id, schema: mock_check_2fa_status_and_verify()\n        )\n\n        response = self.client.post(\n            \"/api/v1/auth/login\",\n            json={\"email\": \"testuser1@gmail.com\", \"password\": \"Testpassword@123\"},\n        )\n        response_json = response.json()\n\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert response_json.get(\"status_code\") == status.HTTP_400_BAD_REQUEST\n        assert response_json.get(\"message\") == \"2FA is enabled for this user. Provide a valid TOTP code.\"\n\n    def test_user_login_failure_with_2FA_enabled_with_invalid_code(self, monkeypatch):\n        \"\"\"Test login failure when 2FA is enabled but the code is invalid\"\"\"\n\n        self.mock_totp_device.confirmed = True\n        monkeypatch.setattr(\n            user_service,\n            \"authenticate_user\",\n            lambda db, email, password: self.mock_user\n        )\n\n        def mock_verify_invalid_code():\n            from fastapi import HTTPException\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid TOTP code\"\n            )\n\n        monkeypatch.setattr(\n            totp_service,\n            \"check_2fa_status_and_verify\",\n            lambda db, user_id, schema: mock_verify_invalid_code()\n        )\n\n        response = self.client.post(\n            \"/api/v1/auth/login\",\n            json={\n                \"email\": \"testuser1@gmail.com\",\n                \"password\": \"Testpassword@123\",\n                \"totp_code\": \"123456\"\n            },\n        )\n        response_json = response.json()\n\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert response_json.get(\"status_code\") == status.HTTP_400_BAD_REQUEST\n        assert response_json.get(\"message\") == \"Invalid TOTP code\"\n\n    def test_inactive_user_login(self, monkeypatch):\n        \"\"\"Test for inactive user login attempt\"\"\"\n\n        self.mock_user.is_active = False\n        monkeypatch.setattr(\n            user_service,\n            \"authenticate_user\",\n            lambda db, email, password: self.mock_user\n        )\n        monkeypatch.setattr(\n            totp_service,\n            \"check_2fa_status_and_verify\",\n            lambda db, user_id, schema: True\n        )\n        monkeypatch.setattr(\n            \"api.v1.services.organisation.organisation_service.retrieve_user_organizations\",\n            lambda user, db: []\n        )\n\n        response = self.client.post(\n            \"/api/v1/auth/login\",\n            json={\"email\": \"testuser1@gmail.com\", \"password\": \"Testpassword@123\"},\n        )\n        response_json = response.json()\n\n        assert response.status_code == status.HTTP_200_OK\n        assert response_json.get(\"status_code\") == status.HTTP_200_OK\n        assert response_json.get(\"message\") == \"Login successful\"\n        assert not response_json.get(\"data\").get(\"user\").get(\"is_active\")\n\n    def test_swagger_ui_auth_form_handling(self):\n        \"\"\"Test that the Swagger UI authentication form handling works correctly.\"\"\"\n\n        # This test simulates how Swagger UI sends authentication data\n        # It uses form data instead of JSON\n        response = self.client.post(\n            \"/api/v1/auth/login\",\n            data={\"username\": \"testuser1@gmail.com\", \"password\": \"Testpassword@123\"},\n            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        )\n\n        # We expect a 422 error (not 500) with clear validation message\n        assert response.status_code == 422\n        response_json = response.json()\n        assert \"detail\" in response_json or \"errors\" in response_json\n        assert response_json.get(\"status_code\") == 422\n        assert response_json.get(\"message\") == \"Invalid input\" or \"Invalid\" in response_json.get(\"message\", \"\")\n\n\n# Mock the database dependency\n@pytest.fixture\ndef db_session_mock():\n    db_session = MagicMock()\n    yield db_session\n\n\n# Override the dependency with the mock\n@pytest.fixture(autouse=True)\ndef override_get_db(db_session_mock):\n    def get_db_override():\n        yield db_session_mock\n\n    app.dependency_overrides[get_db] = get_db_override\n    yield\n    # Clean up after the test by removing the override\n    app.dependency_overrides = {}\n\n\ndef test_user_login(db_session_mock):\n    \"\"\"Test for successful inactive user login.\"\"\"\n\n    # Create a mock user\n    mock_user = User(\n        id=str(uuid7()),\n        email=\"testuser1@gmail.com\",\n        password=user_service.hash_password(\"Testpassword@123\"),\n        first_name='Test',\n        last_name='User',\n        is_active=False,\n        is_superadmin=False,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n    db_session_mock.query.return_value.filter.return_value.first.return_value = mock_user\n\n    # Login with mock user details\n    login = client.post(\"/api/v1/auth/login\", json={\n        \"email\": \"testuser1@gmail.com\",\n        \"password\": \"Testpassword@123\"\n    })\n    response = login.json()\n    assert response.get(\"status_code\") == status.HTTP_200_OK"}
{"type": "test_file", "path": "tests/v1/billing_plan/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/run_all_test.py", "content": "from fastapi import APIRouter, Response\nimport subprocess\n\n\ntest_rout = APIRouter(prefix='/all', tags=['Tests'])\n\n@test_rout.get(\"/run-tests\")\nasync def run_tests():\n    # Run pytest and capture the output\n    result = subprocess.run(['pytest', '--maxfail=1', '--disable-warnings', '--tb=short'], \n                            capture_output=True, text=True)\n    # Return the output as the response\n    return Response(content=result.stdout, media_type=\"text/plain\")\n\n"}
{"type": "test_file", "path": "tests/v1/billing_plan/test_delete_billing_plan.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom main import app\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom uuid_extensions import uuid7\nfrom api.db.database import get_db\nfrom fastapi import status\nfrom datetime import datetime, timezone\n\n\nclient = TestClient(app)\n\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to create a mock database session.\"\"\"\n\n    with patch(\"api.v1.services.user.get_db\", autospec=True) as mock_get_db:\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"Fixture to create a mock user service.\"\"\"\n\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as mock_service:\n        yield mock_service\n\n\ndef create_mock_user(mock_user_service, mock_db_session):\n    \"\"\"Create a mock user in the mock database session.\"\"\"\n    mock_user = User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=user_service.hash_password(\"Testpassword@123\"),\n        first_name=\"Test\",\n        last_name=\"User\",\n        is_active=True,\n        is_superadmin=True,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc),\n    )\n    mock_db_session.query.return_value.filter.return_value.first.return_value = (\n        mock_user\n    )\n    return mock_user\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_delete_billing_plan(mock_user_service, mock_db_session):\n    \"\"\"Billing plan delete test.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n\n    response = client.delete(\n        \"/api/v1/organisations/billing-plans/123-1221-090\",\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n    )\n\n    assert response.status_code == status.HTTP_200_OK\n"}
{"type": "test_file", "path": "tests/v1/auth/test_request_pwd_reset.py", "content": "import pytest\nfrom unittest.mock import patch, MagicMock\nfrom fastapi.testclient import TestClient\nfrom fastapi import HTTPException\nfrom sqlalchemy.orm import Session\nfrom api.v1.models import User, Organisation\nfrom api.v1.schemas.request_password_reset import (ResetPasswordRequest,\n                                                   RequestEmail,\n                                                   OrganizationData,\n                                                   ResetPasswordSuccesful)\nfrom main import app\n\nclient = TestClient(app)\n\n@pytest.fixture\ndef mock_db_session():\n    return MagicMock(spec=Session)\n\n@pytest.fixture\ndef mock_reset_token():\n    return \"mock_reset_token\"\n\n@pytest.fixture\ndef mock_reset_password_request():\n    return ResetPasswordRequest(reset_token=\"mock_reset_tokenmock_reset_tokenmock_reset_tokenmock_reset_token\",\n                                new_password=\"New_password1@\",\n                                confirm_password=\"New_password1@\")\n\n@pytest.fixture\ndef mock_request_password_service():\n    with patch(\"api.v1.services.request_pwd.RequestPasswordService\") as MockService:\n        service = MockService.return_value\n        yield service\n\n@pytest.fixture\ndef mock_verify_reset_token():\n    with patch(\"api.v1.services.request_pwd.RequestPasswordService.verify_reset_token\") as Mock_verify_token:\n        Mock_verify_token.return_value = {\"email\": \"test@gmail.com\", \"jti\": 1}\n        yield Mock_verify_token\n\n\n@patch('api.v1.services.request_pwd.RequestPasswordService.update')\ndef test_reset_password(mock_update):\n    token = \"mock_reset_tokenmock_reset_tokenmock_reset_tokenmock_reset_token\"\n    mock_user = User(id='user_id', email=\"test@gmail.com\",\n                     first_name=\"Test\",\n                     last_name=\"User\",\n                     password=\"PassDam!23w\",\n                     is_verified=True,\n                     is_deleted=False,\n                     is_superadmin=False)\n    \n    org = Organisation(name=\"my org\", id=\"org_id\", email=\"org@gmail.com\")\n    mock_org = OrganizationData.model_validate(org, from_attributes=True)\n\n    mock_update.return_value = ResetPasswordSuccesful(\n        message='password successfully reset',\n            status_code=201,\n            access_token=token,\n            data={\"user\": mock_user, \"organisations\": [mock_org]}\n    ), ''\n\n    response, _ = mock_update.return_value\n    # Assert\n    assert response.status_code == 201\n\n\n\ndef test_request_reset_link_user_not_found(mock_db_session, mock_request_password_service):\n    # Arrange\n    mock_request_password_service.fetch.side_effect = HTTPException(status_code=404, detail=\"User not found\")\n\n    reset_email = RequestEmail(email=\"unknown@gmail.com\")\n\n    # Act\n    response = client.post(\"/api/v1/auth/forgot-password\", json={\"email\": reset_email.email})\n\n    # Assert\n    assert response.status_code == 404\n    assert response.json() == {\n    \"message\": \"User not found\",\n    \"status\": False,\n    \"status_code\": 404\n}\n\ndef test_reset_password_invalid_token(mock_db_session, mock_reset_password_request, mock_request_password_service):\n    # Arrange\n    mock_request_password_service.update.side_effect = HTTPException(status_code=400, detail=\"reset token invalid\")\n\n    # Act\n    response = client.patch(\"/api/v1/auth/reset-password\", json=mock_reset_password_request.dict())\n\n    # Assert\n    assert response.status_code == 400\n    # assert response.json() == {\"message\": \"reset token invalid\"}\n    assert response.json() == {\n    \"message\": \"reset token invalid\",\n    \"status\": False,\n    \"status_code\": 400\n}\n"}
{"type": "test_file", "path": "tests/v1/bookmark/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/v1/auth/test_magic_link.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom main import app\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom uuid_extensions import uuid7\nfrom api.db.database import get_db\nfrom fastapi import status\nfrom datetime import datetime, timezone\n\nclient = TestClient(app)\nMAGIC_ENDPOINT = '/api/v1/auth/magic-link'\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to create a mock database session.\"\"\"\n    with patch(\"api.v1.services.user.get_db\", autospec=True) as mock_get_db:\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"Fixture to create a mock user service.\"\"\"\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as mock_service:\n        yield mock_service\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_request_magic_link(mock_user_service, mock_db_session):\n    \"\"\"Test for requesting magic link\"\"\"\n\n    # Create a mock user\n    mock_user = User(\n        id=str(uuid7()),\n        email=\"testuser1@gmail.com\",\n        password=user_service.hash_password(\"Testpassword@123\"),\n        first_name='Test',\n        last_name='User',\n        is_active=False,\n        is_superadmin=False,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_user\n\n    with patch(\"api.utils.send_mail.smtplib.SMTP_SSL\") as mock_smtp:\n        # Configure the mock SMTP server\n        mock_smtp_instance = MagicMock()\n        mock_smtp.return_value = mock_smtp_instance\n\n        # Test for requesting magic link for an existing user\n        response = client.post(MAGIC_ENDPOINT, json={\"email\": mock_user.email})\n        assert response.status_code == status.HTTP_200_OK\n        assert response.json().get(\"message\") == f\"Magic link sent to {mock_user.email}\"\n\n        # Test for requesting magic link for a non-existing user\n        mock_db_session.query.return_value.filter.return_value.first.return_value = None\n        response = client.post(MAGIC_ENDPOINT, json={\"email\": \"notauser@gmail.com\"})\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n        assert response.json().get(\"message\") == \"User not found\"\n"}
{"type": "test_file", "path": "tests/v1/blog/delete_blog_test.py", "content": "from unittest.mock import MagicMock, patch\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom uuid_extensions import uuid7\n\nfrom api.db.database import get_db\nfrom api.v1.services.user import user_service\nfrom api.v1.models import User\nfrom api.v1.models.blog import Blog\nfrom main import app\n\n\ndef mock_get_db():\n    db_session = MagicMock()\n    yield db_session\n\n\ndef mock_get_current_super_admin():\n    return User(id=\"1\", is_superadmin=True)\n\n@pytest.fixture\ndef db_session_mock():\n    db_session = MagicMock(spec=Session)\n    return db_session\n\n@pytest.fixture\ndef client(db_session_mock):\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    client = TestClient(app)\n    yield client\n    \n\ndef test_delete_blog_success(client, db_session_mock):\n    '''Test for success in blog deletion'''\n\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    app.dependency_overrides[user_service.get_current_super_admin] = lambda: mock_get_current_super_admin\n    blog_id = uuid7()\n    mock_blog = Blog(id=blog_id, title=\"Test Blog\",\n                     content=\"Test Content\", is_deleted=False)\n\n    db_session_mock.query(Blog).filter(id==blog_id).first.return_value.id = [mock_blog]\n\n    response = client.delete(f\"/api/v1/blogs/{mock_blog.id}\", headers={'Authorization': 'Bearer token'})\n\n    assert response.status_code == 204\n\n    \ndef test_delete_blog_not_found(client, db_session_mock):\n    '''test for blog not found'''\n\n    db_session_mock.query(Blog).filter(Blog.id == f'{uuid7()}').first.return_value = None\n\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    app.dependency_overrides[user_service.get_current_super_admin] = lambda: mock_get_current_super_admin\n\n    response = client.delete(f\"api/v1/blogs/{uuid7()}\", headers={'Authorization': 'Bearer token'})\n\n    assert response.json()[\"status_code\"] == 404\n    assert response.json()[\"message\"] == \"Post not found\"\n    \n\nif __name__ == \"__main__\":\n    pytest.main()\n"}
{"type": "test_file", "path": "tests/v1/billing_plan/test_get_billing_plan.py", "content": "from datetime import datetime, timezone\nfrom unittest.mock import MagicMock, patch\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom uuid_extensions import uuid7\n\nfrom api.db.database import get_db\nfrom api.v1.models.organisation import Organisation\nfrom api.v1.services.user import user_service\nfrom api.v1.services.billing_plan import billing_plan_service\nfrom api.v1.models.user import User\nfrom api.v1.models.billing_plan import BillingPlan\nfrom main import app\n\n\n\n@pytest.fixture\ndef db_session_mock():\n    db_session = MagicMock(spec=Session)\n    return db_session\n\n@pytest.fixture\ndef client(db_session_mock):\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    client = TestClient(app)\n    yield client\n    app.dependency_overrides = {}\n\n\ndef mock_get_current_user():\n    return User(\n        id=str(uuid7()),\n        email=\"test@gmail.com\",\n        password=user_service.hash_password(\"Testuser@123\"),\n        first_name='Test',\n        last_name='User',\n        is_active=True,\n        is_superadmin=True,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n\ndef mock_org():\n    return Organisation(\n        id=str(uuid7()),\n        name=\"Test Organisation\",\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n\ndef mock_billing_plan():\n    return BillingPlan(\n        id=str(uuid7()), \n        organisation_id=mock_org().id,  \n        name=\"Premium Plan\",\n        price=49.99,\n        currency=\"NGN\",  # Currency code\n        duration=\"yearly\",  # Duration of the plan\n        description=\"This is a premium billing plan with extra features.\",\n        features=[\"Feature 1\", \"Feature 2\", \"Feature 3\"],\n        updated_at=datetime.now(timezone.utc)\n    )\n\ndef test_get_plan_unauthorized(client, db_session_mock):\n    '''Test for unauthorized user'''    \n\n    mock_plan_instance = mock_billing_plan()\n\n\n    with patch(\"api.v1.services.billing_plan.BillingPlanService.fetch\", return_value=mock_plan_instance) as mock_fetch:\n\n        response = client.get(f'/api/v1/organisations/billing-plans/{mock_plan_instance.id}')\n\n        assert response.status_code == 401\n"}
{"type": "test_file", "path": "tests/v1/blog/test_blog_model_indexing.py", "content": "import pytest\nfrom sqlalchemy import inspect\nfrom api.v1.models.blog import Blog, BlogLike, BlogDislike\nfrom api.v1.models.user import User\n\n\nclass TestBlogModelIndexing:\n    def test_author_id_index_exists(self, db_session):\n        \"\"\"Test that the author_id index exists on the Blog model\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blogs')\n\n        author_id_index = next((idx for idx in indexes if 'author_id' in idx['name'] and 'blogs' in idx['name']), None)\n        assert author_id_index is not None\n        assert 'author_id' in author_id_index['column_names']\n\n    def test_title_index_exists(self, db_session):\n        \"\"\"Test that the title index exists on the Blog model\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blogs')\n\n        title_index = next((idx for idx in indexes if 'title' in idx['name'] and 'blogs' in idx['name']), None)\n        assert title_index is not None\n        assert 'title' in title_index['column_names']\n\n    def test_tags_index_exists(self, db_session):\n        \"\"\"Test that the tags index exists on the Blog model\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blogs')\n\n        tags_index = next((idx for idx in indexes if 'tags' in idx['name'] and 'blogs' in idx['name']), None)\n        assert tags_index is not None\n        assert 'tags' in tags_index['column_names']\n\n    def test_is_deleted_index_exists(self, db_session):\n        \"\"\"Test that the is_deleted index exists on the Blog model\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blogs')\n\n        is_deleted_index = next((idx for idx in indexes if 'is_deleted' in idx['name'] and 'blogs' in idx['name']), None)\n        assert is_deleted_index is not None\n        assert 'is_deleted' in is_deleted_index['column_names']\n\n    def test_query_using_blog_indexes(self, db_session):\n        \"\"\"Test that queries use the blog indexes properly\"\"\"\n        # Create a test user first\n        user = User(\n            email=\"blog_author@example.com\",\n            first_name=\"Blog\",\n            last_name=\"Author\",\n            is_active=True,\n            is_verified=True\n        )\n        db_session.add(user)\n        db_session.commit()\n\n        # Create a test blog\n        blog = Blog(\n            author_id=user.id,\n            title=\"Test Blog\",\n            content=\"This is a test blog content\",\n            tags=\"test,index,blog\",\n            is_deleted=False\n        )\n        db_session.add(blog)\n        db_session.commit()\n\n        # Test queries on indexed fields\n        author_blog = db_session.query(Blog).filter(Blog.author_id == user.id).first()\n        assert author_blog is not None\n\n        title_blog = db_session.query(Blog).filter(Blog.title == \"Test Blog\").first()\n        assert title_blog is not None\n\n        tag_blog = db_session.query(Blog).filter(Blog.tags.contains(\"test\")).first()\n        assert tag_blog is not None\n\n        active_blog = db_session.query(Blog).filter(Blog.is_deleted == False).first()\n        assert active_blog is not None\n\n        # Clean up\n        db_session.delete(blog)\n        db_session.delete(user)\n        db_session.commit()\n\n\nclass TestBlogLikeModelIndexing:\n    def test_blog_id_index_exists(self, db_session):\n        \"\"\"Test that the blog_id index exists on the BlogLike model\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blog_likes')\n\n        blog_id_index = next((idx for idx in indexes if 'blog_id' in idx['name'] and 'blog_likes' in idx['name']), None)\n        assert blog_id_index is not None\n        assert 'blog_id' in blog_id_index['column_names']\n\n    def test_user_id_index_exists(self, db_session):\n        \"\"\"Test that the user_id index exists on the BlogLike model\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blog_likes')\n\n        user_id_index = next((idx for idx in indexes if 'user_id' in idx['name'] and 'blog_likes' in idx['name']), None)\n        assert user_id_index is not None\n        assert 'user_id' in user_id_index['column_names']\n\n    def test_composite_index_exists(self, db_session):\n        \"\"\"Test that the composite index on blog_id and user_id exists\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blog_likes')\n\n        composite_index = next((idx for idx in indexes if 'blog_user' in idx['name'] and 'blog_likes' in idx['name']), None)\n        assert composite_index is not None\n        assert 'blog_id' in composite_index['column_names']\n        assert 'user_id' in composite_index['column_names']\n        assert composite_index['unique'] is True\n\n    def test_query_using_bloglike_indexes(self, db_session):\n        \"\"\"Test that queries use the BlogLike indexes properly\"\"\"\n        # Create a test user\n        user = User(\n            email=\"like_user@example.com\",\n            first_name=\"Like\",\n            last_name=\"User\",\n            is_active=True,\n            is_verified=True\n        )\n        db_session.add(user)\n        db_session.commit()\n\n        # Create a test blog\n        blog = Blog(\n            author_id=user.id,\n            title=\"Like Test Blog\",\n            content=\"This is a test blog content for likes\",\n            tags=\"test,like\",\n            is_deleted=False\n        )\n        db_session.add(blog)\n        db_session.commit()\n\n        # Create a test like\n        like = BlogLike(\n            blog_id=blog.id,\n            user_id=user.id,\n            ip_address=\"127.0.0.1\"\n        )\n        db_session.add(like)\n        db_session.commit()\n\n        # Test queries on indexed fields\n        blog_like = db_session.query(BlogLike).filter(BlogLike.blog_id == blog.id).first()\n        assert blog_like is not None\n\n        user_like = db_session.query(BlogLike).filter(BlogLike.user_id == user.id).first()\n        assert user_like is not None\n\n        composite_like = db_session.query(BlogLike).filter(\n            BlogLike.blog_id == blog.id,\n            BlogLike.user_id == user.id\n        ).first()\n        assert composite_like is not None\n\n        # Clean up\n        db_session.delete(like)\n        db_session.delete(blog)\n        db_session.delete(user)\n        db_session.commit()\n\n\nclass TestBlogDislikeModelIndexing:\n    def test_blog_id_index_exists(self, db_session):\n        \"\"\"Test that the blog_id index exists on the BlogDislike model\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blog_dislikes')\n\n        blog_id_index = next((idx for idx in indexes if 'blog_id' in idx['name'] and 'blog_dislikes' in idx['name']), None)\n        assert blog_id_index is not None\n        assert 'blog_id' in blog_id_index['column_names']\n\n    def test_user_id_index_exists(self, db_session):\n        \"\"\"Test that the user_id index exists on the BlogDislike model\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blog_dislikes')\n\n        user_id_index = next((idx for idx in indexes if 'user_id' in idx['name'] and 'blog_dislikes' in idx['name']), None)\n        assert user_id_index is not None\n        assert 'user_id' in user_id_index['column_names']\n\n    def test_composite_index_exists(self, db_session):\n        \"\"\"Test that the composite index on blog_id and user_id exists\"\"\"\n        inspector = inspect(db_session.bind)\n        indexes = inspector.get_indexes('blog_dislikes')\n\n        composite_index = next((idx for idx in indexes if 'blog_user' in idx['name'] and 'blog_dislikes' in idx['name']), None)\n        assert composite_index is not None\n        assert 'blog_id' in composite_index['column_names']\n        assert 'user_id' in composite_index['column_names']\n        assert composite_index['unique'] is True\n\n    def test_query_using_blogdislike_indexes(self, db_session):\n        \"\"\"Test that queries use the BlogDislike indexes properly\"\"\"\n        # Create a test user\n        user = User(\n            email=\"dislike_user@example.com\",\n            first_name=\"Dislike\",\n            last_name=\"User\",\n            is_active=True,\n            is_verified=True\n        )\n        db_session.add(user)\n        db_session.commit()\n\n        # Create a test blog\n        blog = Blog(\n            author_id=user.id,\n            title=\"Dislike Test Blog\",\n            content=\"This is a test blog content for dislikes\",\n            tags=\"test,dislike\",\n            is_deleted=False\n        )\n        db_session.add(blog)\n        db_session.commit()\n\n        # Create a test dislike\n        dislike = BlogDislike(\n            blog_id=blog.id,\n            user_id=user.id,\n            ip_address=\"127.0.0.1\"\n        )\n        db_session.add(dislike)\n        db_session.commit()\n\n        # Test queries on indexed fields\n        blog_dislike = db_session.query(BlogDislike).filter(BlogDislike.blog_id == blog.id).first()\n        assert blog_dislike is not None\n\n        user_dislike = db_session.query(BlogDislike).filter(BlogDislike.user_id == user.id).first()\n        assert user_dislike is not None\n\n        composite_dislike = db_session.query(BlogDislike).filter(\n            BlogDislike.blog_id == blog.id,\n            BlogDislike.user_id == user.id\n        ).first()\n        assert composite_dislike is not None\n\n        # Clean up\n        db_session.delete(dislike)\n        db_session.delete(blog)\n        db_session.delete(user)\n        db_session.commit()"}
{"type": "test_file", "path": "tests/v1/blog/test_archived_blog.py", "content": "from unittest.mock import MagicMock, patch\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom uuid_extensions import uuid7\n\nfrom api.db.database import get_db\nfrom api.v1.services.user import user_service\nfrom api.v1.models import User\nfrom api.v1.models.blog import Blog\nfrom main import app\n\n\ndef mock_get_db():\n    db_session = MagicMock()\n    yield db_session\n\n\ndef mock_get_current_super_admin():\n    return User(id=\"1\", is_superadmin=True)\n\n@pytest.fixture\ndef db_session_mock():\n    db_session = MagicMock(spec=Session)\n    return db_session\n\n@pytest.fixture\ndef client(db_session_mock):\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    client = TestClient(app)\n    yield client\n    \n\ndef test_archive_blog_success(client, db_session_mock):\n    '''Test for success in blog archiving'''\n\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    app.dependency_overrides[user_service.get_current_super_admin] = lambda: mock_get_current_super_admin()\n    blog_id = uuid7()\n    mock_blog = Blog(id=blog_id, title=\"Test Blog\",\n                     content=\"Test Content\", is_deleted=False)\n\n    db_session_mock.query(Blog).filter(Blog.id==blog_id).first.return_value = mock_blog\n\n    response = client.put(f\"/api/v1/blogs/{mock_blog.id}/soft_delete\", headers={'Authorization': 'Bearer token'})\n\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"Blog post archived successfully!\"\n\n    \ndef test_delete_blog_not_found(client, db_session_mock):\n    '''test for blog not found'''\n\n    db_session_mock.query(Blog).filter(Blog.id == f'{uuid7()}').first.return_value = None\n\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    app.dependency_overrides[user_service.get_current_super_admin] = lambda: mock_get_current_super_admin\n\n    response = client.put(f\"/api/v1/blogs/{uuid7()}/soft_delete\", headers={'Authorization': 'Bearer token'})\n\n    assert response.status_code == 404\n    assert response.json()[\"message\"] == \"Post not found\"\n    \n\nif __name__ == \"__main__\":\n    pytest.main()\n"}
{"type": "test_file", "path": "tests/v1/billing_plan/test_update_billing_plan.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom main import app\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom uuid_extensions import uuid7\nfrom api.db.database import get_db\nfrom fastapi import status\nfrom datetime import datetime, timezone\n\n\nclient = TestClient(app)\n\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to create a mock database session.\"\"\"\n\n    with patch(\"api.v1.services.user.get_db\", autospec=True) as mock_get_db:\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"Fixture to create a mock user service.\"\"\"\n\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as mock_service:\n        yield mock_service\n\n\ndef create_mock_user(mock_user_service, mock_db_session):\n    \"\"\"Create a mock user in the mock database session.\"\"\"\n    mock_user = User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=user_service.hash_password(\"Testpassword@123\"),\n        first_name=\"Test\",\n        last_name=\"User\",\n        is_active=True,\n        is_superadmin=True,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc),\n    )\n    mock_db_session.query.return_value.filter.return_value.first.return_value = (\n        mock_user\n    )\n    return mock_user\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_update_billing_plan(mock_user_service, mock_db_session):\n    \"\"\"Billing plan update test.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n    data = {\n        \"name\": \"Advanced\",\n        \"organisation_id\": \"s2334d\",\n        \"description\": \"All you need in one pack\",\n        \"price\": 80,\n        \"duration\": \"monthly\",\n        \"currency\": \"Naira\",\n        \"features\": [\"Multiple team\", \"Premium support\"],\n    }\n\n    response = client.patch(\n        \"/api/v1/organisations/billing-plans/123-1221-090\",\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n        json=data,\n    )\n\n    print(response.json())\n\n    assert response.status_code == status.HTTP_200_OK\n"}
{"type": "test_file", "path": "tests/v1/blog/test_search_blogs.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom main import app  \n\nclient = TestClient(app)\n\ndef test_search_blogs():\n    response = client.get(\"/api/v1/blogs/search\", params={\n        \"keyword\": \"test\",\n        \"category\": \"technology\",\n        \"author\": \"John Doe\",\n        \"start_date\": \"2024-01-01\",\n        \"end_date\": \"2024-12-31\",\n        \"tags\": \"AI,Machine Learning\",\n        \"page\": 1,\n        \"per_page\": 5\n    })\n    \n    assert response.status_code == 200\n    json_response = response.json()\n    assert json_response[\"status_code\"] == 200\n    assert \"blogs\" in json_response\n    assert isinstance(json_response[\"blogs\"], list)\n\ndef test_search_blogs_no_results():\n    response = client.get(\"/api/v1/blogs/search\", params={\"keyword\": \"nonexistentkeyword\"})\n    assert response.status_code == 200\n    json_response = response.json()\n    assert json_response[\"status_code\"] == 200\n    assert \"blogs\" in json_response\n    assert len(json_response[\"blogs\"]) == 0\n\ndef test_search_blogs_invalid_date_format():\n    response = client.get(\"/api/v1/blogs/search\", params={\"start_date\": \"invalid-date\"})\n    assert response.status_code == 400\n    json_response = response.json()\n    assert \"message\" in json_response\n    assert json_response[\"message\"] == \"Invalid start_date format. Use YYYY-MM-DD.\"\n\ndef test_search_blogs_negative_pagination():\n    response = client.get(\"/api/v1/blogs/search\", params={\"page\": -1, \"per_page\": 5})\n    assert response.status_code == 422\n    json_response = response.json()\n    assert \"errors\" in json_response\n    assert any(error[\"loc\"] == [\"query\", \"page\"] and error[\"msg\"] == \"Input should be greater than or equal to 1\"\n               for error in json_response[\"errors\"])\n\ndef test_search_blogs_exceed_max_per_page():\n    response = client.get(\"/api/v1/blogs/search\", params={\"per_page\": 200})\n    assert response.status_code == 422\n    json_response = response.json()\n    assert \"errors\" in json_response\n    assert any(error[\"loc\"] == [\"query\", \"per_page\"] and error[\"msg\"] == \"Input should be less than or equal to 100\"\n               for error in json_response[\"errors\"])\n"}
{"type": "test_file", "path": "tests/v1/blog/test_like_blog_post.py", "content": "import pytest\nfrom main import app\nfrom uuid_extensions import uuid7\nfrom sqlalchemy.orm import Session\nfrom api.db.database import get_db\nfrom datetime import datetime, timezone\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom api.v1.services.blog import BlogService\nfrom api.v1.services.user import user_service\nfrom api.v1.models import User, Blog, BlogLike\n\nclient = TestClient(app)\n\n# Mock database\n@pytest.fixture\ndef mock_db_session(mocker):\n    db_session_mock = mocker.MagicMock(spec=Session)\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    return db_session_mock\n\n\n@pytest.fixture\ndef mock_user_service():\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as user_service_mock:\n        yield user_service_mock\n\n\n@pytest.fixture\ndef mock_blog_service(mock_db_session):\n    with patch(\"api.v1.services.blog.BlogService\", autospec=True) as blog_service_mock:\n        yield blog_service_mock(mock_db_session)\n\n\n# Test User\n@pytest.fixture\ndef test_user():\n    return User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"test\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n@pytest.fixture()\ndef test_blog(test_user):\n    return Blog(\n        id=str(uuid7()),\n        author_id=test_user.id,\n        title=\"Blog Post 1\",\n        content=\"This is blog post number 1\"\n    )\n\n@pytest.fixture()\ndef test_blog_like(test_user, test_blog):\n    return BlogLike(\n            id=str(uuid7()),\n            user_id=test_user.id,\n            blog_id=test_blog.id,\n            ip_address=\"192.168.1.0\",\n            created_at=datetime.now(tz=timezone.utc)\n        )\n\n@pytest.fixture\ndef access_token_user(test_user):\n    return user_service.create_access_token(user_id=test_user.id)\n\ndef make_request(blog_id, token):\n    return client.post(\n        f\"/api/v1/blogs/{blog_id}/like\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n\n# Test for successful like\n@patch(\"api.v1.services.blog.BlogService.create_blog_like\")\ndef test_successful_like(\n    mock_create_blog_like,\n    mock_db_session, \n    test_user, \n    test_blog,\n    test_blog_like,\n    access_token_user\n):\n    # mock current-user AND blog-post\n    mock_db_session.query().filter().first.side_effect = [test_user, test_blog]\n\n    # mock existing-blog-like\n    mock_db_session.query().filter_by().first.return_value = None\n\n    # mock created-blog-like\n    mock_create_blog_like.return_value = test_blog_like\n\n    # mock like-count\n    mock_db_session.query().filter_by().count.return_value = 1\n\n    resp = make_request(test_blog.id, access_token_user)\n    resp_d = resp.json()\n    assert resp.status_code == 200\n    assert resp_d['status'] == \"success\"\n    assert resp_d['message'] == \"Like recorded successfully.\"\n\n    like_data = resp_d['data']['object']\n    assert like_data['id'] == test_blog_like.id\n    assert like_data['blog_id'] == test_blog.id\n    assert like_data['user_id'] == test_user.id\n    assert like_data['ip_address'] == test_blog_like.ip_address\n    assert datetime.fromisoformat(like_data['created_at']) == test_blog_like.created_at\n    assert resp_d['data']['objects_count'] == 1\n\n\n# Test for double like\ndef test_double_like(\n    mock_db_session, \n    test_user, \n    test_blog, \n    test_blog_like,\n    access_token_user,\n):\n    mock_user_service.get_current_user = test_user\n    mock_db_session.query.return_value.filter.return_value.first.return_value = test_blog\n    mock_db_session.query.return_value.filter_by.return_value.first.return_value = test_blog_like\n\n    ### TEST ATTEMPT FOR MULTIPLE DISLIKING... ###\n    resp = make_request(test_blog.id, access_token_user)\n    assert resp.status_code == 403\n    assert resp.json()['message'] == \"You have already liked this blog post\"\n\n# Test for wrong blog id\ndef test_wrong_blog_id(\n    # mock_fetch_blog,\n    mock_db_session, \n    test_user,\n    access_token_user,\n):\n    mock_user_service.get_current_user = test_user\n    mock_db_session.query().filter().first.return_value = None\n\n    ### TEST REQUEST WITH WRONG blog_id ###\n    ### using random uuid instead of blog1.id  ###\n    resp = make_request(str(uuid7()), access_token_user)\n    assert resp.status_code == 404\n    assert resp.json()['message'] == \"Post not found\"\n\n\n# Test for unauthenticated user\ndef test_wrong_auth_token(\n    mock_db_session,\n    test_blog\n):\n    mock_user_service.get_current_user = None\n\n    ### TEST ATTEMPT WITH INVALID AUTH... ###\n    resp = make_request(test_blog.id, None)\n    assert resp.status_code == 401\n    assert resp.json()['message'] == 'Could not validate credentials'\n"}
{"type": "test_file", "path": "tests/v1/activity_logs/test_get_a_user_activity_logs.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom main import app\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom api.v1.services.activity_logs import ActivityLog\nfrom uuid_extensions import uuid7\nfrom api.db.database import get_db\nfrom fastapi import status\nfrom datetime import datetime, timezone, timedelta\n\n\nclient = TestClient(app)\nACTIVITY_LOGS_ENDPOINT = '/api/v1/activity-logs/066abb38-fe41-74c4-8000-40699b6b4139'\n\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Fixture to create a mock database session.\"\"\"\n\n    with patch(\"api.v1.services.user.get_db\", autospec=True) as mock_get_db:\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"Fixture to create a mock user service.\"\"\"\n\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as mock_service:\n        yield mock_service\n\n\ndef create_mock_user(mock_user_service, mock_db_session, is_superadmin=True):\n    \"\"\"Create a mock user in the mock database session.\"\"\"\n    mock_user = User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=user_service.hash_password(\"Testpassword@123\"),\n        first_name='Test',\n        last_name='User',\n        is_active=True,\n        is_superadmin=is_superadmin,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_user\n    return mock_user\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_get_all_activity_logs_empty(mock_user_service, mock_db_session):\n    \"\"\"Test for fetching all activity logs with no data.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n    response = client.get(ACTIVITY_LOGS_ENDPOINT, headers={\n                          'Authorization': f'Bearer {access_token}'})\n\n    # assert response.status_code == status.HTTP_200_OK\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_get_all_activity_logs_with_data(mock_user_service, mock_db_session):\n    \"\"\"Test for fetching all activity logs with data.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n\n    log_id = str(uuid7())\n    user_id = str(uuid7())\n    timezone_offset = -8.0\n    tzinfo = timezone(timedelta(hours=timezone_offset))\n    timeinfo = datetime.now(tzinfo)\n    created_at = timeinfo\n    updated_at = timeinfo\n\n    activity_log = ActivityLog(\n        id=log_id,\n        user_id=user_id,\n        action=\"profile Update\",\n        timestamp=timeinfo,\n        created_at=created_at,\n        updated_at=updated_at\n    )\n\n    mock_db_session.query.return_value.filter.return_value.all.return_value = [\n        activity_log]\n\n    response = client.get(ACTIVITY_LOGS_ENDPOINT, headers={\n                          'Authorization': f'Bearer {access_token}'})\n\n    assert response.status_code == status.HTTP_200_OK\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_get_all_activity_logs_non_super_admin(mock_user_service, mock_db_session):\n    \"\"\"Test for fetching all activity logs as a non-super admin user.\"\"\"\n    mock_user = create_mock_user(\n        mock_user_service, mock_db_session, is_superadmin=False)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n    response = client.get(ACTIVITY_LOGS_ENDPOINT, headers={\n                          'Authorization': f'Bearer {access_token}'})\n\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n"}
{"type": "test_file", "path": "tests/v1/blog/get_all_blogs_test.py", "content": "from datetime import datetime, timedelta, timezone\nfrom unittest.mock import MagicMock\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom uuid_extensions import uuid7\n\nfrom api.v1.models.blog import Blog\nfrom api.v1.routes.blog import get_db\n\nfrom main import app\n\n\n# Mock database dependency\n@pytest.fixture\ndef db_session_mock():\n    db_session = MagicMock(spec=Session)\n    return db_session\n\n@pytest.fixture\ndef client(db_session_mock):\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    client = TestClient(app)\n    yield client\n    app.dependency_overrides = {}\n\ndef test_get_all_blogs_empty(client, db_session_mock):\n    # Mock data\n    mock_blog_data = []\n    \n    mock_query = MagicMock()\n    mock_query.count.return_value = 0\n    mock_query.all.return_value = []\n    \n    db_session_mock.query.return_value = mock_query\n    db_session_mock.query.return_value.filter.return_value.offset.return_value.limit.return_value.all.return_value = mock_blog_data\n    \n\n    # Call the endpoint\n    response = client.get(\"/api/v1/blogs\")\n\n    # Assert the response\n    assert response.status_code == 200\n    assert response.json()[\"data\"][\"items\"] == []\n\ndef test_get_all_blogs_with_data(client, db_session_mock):\n    blog_id = str(uuid7())\n    author_id = str(uuid7())\n    timezone_offset = -8.0\n    tzinfo = timezone(timedelta(hours=timezone_offset))\n    timeinfo = datetime.now(tzinfo)\n    created_at = timeinfo\n    updated_at = timeinfo\n\n    # Mock data\n    mock_blog_data = [\n        Blog(\n            id=blog_id,\n            author_id=author_id,\n            title=\"Test Blog\",\n            content=\"Test Content\",\n            image_url=\"http://example.com/image.png\",\n            tags=[\"test\", \"blog\"],\n            is_deleted=False,\n            excerpt=\"Test Excerpt\",\n            created_at=created_at,\n            updated_at=updated_at\n        )\n    ]\n    \n    mock_query = MagicMock()\n    mock_query.count.return_value = 1\n    db_session_mock.query.return_value.filter.return_value.offset.return_value.limit.return_value.all.return_value = mock_blog_data\n    mock_query.all.return_value = mock_blog_data\n\n    db_session_mock.query.return_value = mock_query\n\n    # Call the endpoint\n    response = client.get(\"/api/v1/blogs\")\n\n    # Assert the response\n    assert response.status_code == 200\n    assert len(response.json().get('data')) >= 1\n\n"}
{"type": "test_file", "path": "tests/v1/blog/test_add_comment.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom main import app\nfrom api.v1.services.user import user_service\nfrom sqlalchemy.orm import Session\nfrom api.db.database import get_db\nfrom api.v1.models import User, Blog\nfrom api.v1.services.user import user_service\nfrom uuid_extensions import uuid7\nfrom unittest.mock import MagicMock\n\nclient = TestClient(app)\n\n# Mock database\n@pytest.fixture\ndef mock_db_session(mocker):\n    db_session_mock = mocker.MagicMock(spec=Session)\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    return db_session_mock\n\n# Test User\n@pytest.fixture\ndef test_user():\n    return User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"test\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n\n@pytest.fixture\ndef test_blog(test_user):\n    return Blog(\n        id=str(uuid7()),\n        author_id=test_user.id, \n        title=\"Test 1\", \n        content=\"Test blog one\"\n    )\n\n@pytest.fixture\ndef access_token_user1(test_user):\n    return user_service.create_access_token(user_id=test_user.id)\n\n# Test adding comment to blog\ndef test_add_comment_to_blog(\n    mock_db_session, \n    test_user, \n    test_blog, \n    access_token_user1,\n):\n    # Mock the GET method for Organisation\n    def mock_get(model, ident):\n        if model == Blog and ident == test_blog.id:\n            return test_blog\n        return None\n\n    mock_db_session.get.side_effect = mock_get\n\n    # Mock the query for checking if user is in the organisation\n    mock_db_session.query().return_value = test_blog\n\n    # Test user belonging to the organisation\n    content = {\"content\": \"Test comment\"}\n    headers = {'Authorization': f'Bearer {access_token_user1}'}\n    response = client.post(f\"/api/v1/blogs/{test_blog.id}/comments\", headers=headers, json=content)\n    \n    # Debugging statement\n    if response.status_code != 201:\n        print(response.json())  # Print error message for more details\n\n    assert response.status_code == 201, f\"Expected status code 200, got {response.status_code}\"\n    assert response.json()['message'] == \"Comment added successfully!\"\n    assert response.json()['data']['blog_id'] == test_blog.id\n\n"}
{"type": "test_file", "path": "tests/v1/blog/test_delete_blog_dislike.py", "content": "import pytest\nfrom main import app\nfrom uuid_extensions import uuid7\nfrom sqlalchemy.orm import Session\nfrom api.db.database import get_db\nfrom datetime import datetime, timezone\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom api.v1.models import User, BlogDislike\nfrom api.v1.services.user import user_service\n\nclient = TestClient(app)\n\n# Mock database\n@pytest.fixture\ndef mock_db_session(mocker):\n    db_session_mock = mocker.MagicMock(spec=Session)\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    return db_session_mock\n\n\n@pytest.fixture\ndef mock_user_service():\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as user_service_mock:\n        yield user_service_mock\n\n\n@pytest.fixture\ndef mock_blog_service():\n    with patch(\"api.v1.services.blog.BlogService\", autospec=True) as blog_service_mock:\n        yield blog_service_mock\n\n\n# Test User\n@pytest.fixture\ndef test_user():\n    return User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"test\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n\n# Another User\n@pytest.fixture\ndef another_user():\n    return User(\n        id=str(uuid7()),\n        email=\"anotheruser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"another\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n@pytest.fixture\ndef test_blog_dislike(test_user):\n    return BlogDislike(\n            id=str(uuid7()),\n            user_id=test_user.id,\n            blog_id=str(uuid7()),\n            ip_address=\"192.168.1.0\",\n            created_at=datetime.now(tz=timezone.utc)\n        )\n\n@pytest.fixture\ndef access_token_user(test_user):\n    return user_service.create_access_token(user_id=test_user.id)\n\n@pytest.fixture\ndef access_token_another(another_user):\n    return user_service.create_access_token(user_id=another_user.id)\n\n\ndef make_request(blog_dislike_id, token):\n    return client.delete(\n        f\"/api/v1/blogs/dislikes/{blog_dislike_id}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n\n\n# test for successful delete\n@patch(\"api.v1.services.blog.BlogDislikeService.fetch\")\ndef test_successful_delete_blog_dislike(\n    mock_fetch_blog_dislike,\n    mock_db_session, \n    test_user,\n    test_blog_dislike,\n    access_token_user\n):\n    # mock current-user AND blog-like\n    mock_db_session.query().filter().first.return_value = test_user\n    mock_fetch_blog_dislike.return_value = test_blog_dislike\n\n    resp = make_request(test_blog_dislike.id, access_token_user)\n    assert resp.status_code == 204\n\n\n# Test for wrong blog like id\ndef test_wrong_blog_dislike_id(\n    mock_db_session, \n    test_user,\n    access_token_user,\n):\n    mock_db_session.query().filter().first.return_value = test_user\n    mock_db_session.get.return_value = None\n\n    ### TEST REQUEST WITH WRONG blog_dislike_id ###\n    resp = make_request(str(uuid7()), access_token_user)\n    assert resp.status_code == 404\n    assert resp.json()['message'] == \"BlogDislike does not exist\"\n\n\n# Test for unauthenticated user\ndef test_wrong_auth_token(\n    test_blog_dislike\n):\n    mock_user_service.get_current_user = None\n\n    ### TEST ATTEMPT WITH INVALID AUTH ###\n    resp = make_request(test_blog_dislike.id, None)\n    assert resp.status_code == 401\n    assert resp.json()['message'] == 'Could not validate credentials'\n\n\n# Test for wrong owner request\ndef test_wrong_owner_request(\n    mock_db_session,\n    test_blog_dislike,\n    another_user,\n    access_token_another\n):\n    mock_user_service.get_current_user = another_user\n    mock_db_session.get.return_value = test_blog_dislike\n\n    ### TEST ATTEMPT BY NON OWNER ###\n    resp = make_request(test_blog_dislike.id, access_token_another)\n    assert resp.status_code == 401\n    assert resp.json()['message'] == 'Insufficient permission'"}
{"type": "test_file", "path": "tests/v1/comment/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/v1/billing_plan/test_stripe.py", "content": "import pytest\nfrom unittest.mock import MagicMock, patch\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom api.v1.models.user import User\nfrom api.v1.models.billing_plan import UserSubscription, BillingPlan\nfrom main import app\nfrom fastapi import status\nfrom api.v1.services.user import user_service\nfrom api.db.database import get_db\nfrom datetime import datetime, timezone, timedelta\nfrom uuid_extensions import uuid7\nfrom api.v1.services.stripe_payment import update_user_plan, fetch_all_organisations_with_users_and_plans\n\nclient = TestClient(app)\n\n# Mock Data\nemail = \"test@gmail.com\"\nuser_id = \"user_123\"\nplan_id = \"plan_123\"\norg_id = \"org_123\"\nstart_date = datetime.utcnow()\nend_date = start_date + timedelta(days=30)\n\nmock_user = User(id=user_id, email=email, first_name=\"Mike\", last_name=\"Zeus\", is_superadmin=True)\nmock_plan = BillingPlan(id=plan_id, name=\"Premium\", price=29.99, currency=\"USD\", duration=\"monthly\", organisation_id=org_id)\nmock_subscription = UserSubscription(user_id=user_id, plan_id=plan_id, organisation_id=org_id, start_date=start_date, end_date=end_date)\n\n@pytest.fixture\ndef mock_db_session():\n    session = MagicMock(spec=Session)\n    session.query().filter().first.side_effect = lambda: {\n        User: mock_user,\n        BillingPlan: mock_plan,\n        UserSubscription: mock_subscription\n    }[session.query.call_args[0][0]]\n    return session\n\n@pytest.fixture\ndef mock_subscribe_user_to_plan():\n    with patch(\"api.v1.services.stripe_payment.update_user_plan\") as mock_service:\n        yield mock_service\n\n@pytest.fixture\ndef mock_user_service():\n    \"\"\"Fixture to create a mock user service.\"\"\"\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as mock_service:\n        yield mock_service\n\ndef create_mock_user(mock_user_service, mock_db_session):\n    \"\"\"Create a mock user in the mock database session.\"\"\"\n    mock_user = User(\n        id=user_id,\n        email=\"testuser@gmail.com\",\n        password=user_service.hash_password(\"Testpassword@123\"),\n        first_name=\"Test\",\n        last_name=\"User\",\n        is_active=True,\n        is_superadmin=True,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc),\n    )\n    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_user\n    return mock_user\n\n@pytest.fixture\ndef mock_fetch_all_organisations_with_users_and_plans():\n    with patch(\"api.v1.services.stripe_payment.fetch_all_organisations_with_users_and_plans\") as mock_service:\n        yield mock_service\n\n\n@pytest.mark.usefixtures(\"mock_db_session\", \"mock_user_service\")\ndef test_fetch_invalid_billing_plans(mock_user_service, mock_db_session):\n    \"\"\"Billing plan fetch test.\"\"\"\n    mock_user = create_mock_user(mock_user_service, mock_db_session)\n    access_token = user_service.create_access_token(user_id=str(uuid7()))\n\n    response = client.get(\n        \"/api/v1/payment/plans\",\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n    )\n    print(response.json())\n    assert response.status_code == 404"}
{"type": "test_file", "path": "tests/v1/comment/test_delete_comment.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom main import app\nfrom api.v1.services.user import user_service\nfrom sqlalchemy.orm import Session\nfrom api.db.database import get_db\nfrom api.v1.models import User, Comment\nfrom uuid_extensions import uuid7\nfrom unittest.mock import MagicMock, patch\n\nclient = TestClient(app)\n\n# Mock database session fixture\n@pytest.fixture\ndef mock_db_session():\n    db_session_mock = MagicMock(spec=Session)\n    return db_session_mock\n\n# Override the get_db dependency to use the mock database session\n@pytest.fixture(autouse=True)\ndef override_get_db(mock_db_session):\n    def _override_get_db():\n        yield mock_db_session\n    app.dependency_overrides[get_db] = _override_get_db\n\n# Fixture for a test user\n@pytest.fixture\ndef test_user():\n    return User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"test\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n# Fixture for a test comment\n@pytest.fixture\ndef test_comment(test_user):\n    return Comment(\n        id=str(uuid7()),\n        user_id=test_user.id,\n        blog_id=str(uuid7()),\n        content=\"Just a test comment\",\n    )\n\n# Fixture for generating an access token\n@pytest.fixture\ndef access_token_user1(test_user):\n    return user_service.create_access_token(user_id=test_user.id)\n\n# Test for successful comment deletion\ndef test_delete_comment_success(\n    mock_db_session, \n    test_user, \n    test_comment,\n    access_token_user1,\n):\n    def mock_get(model, ident):\n        if model == Comment and ident == test_comment.id:\n            return test_comment\n        return None\n\n    mock_db_session.get.side_effect = mock_get\n    mock_db_session.query.return_value.filter.return_value.first.return_value = test_user\n\n    headers = {'Authorization': f'Bearer {access_token_user1}'}\n    response = client.delete(f\"/api/v1/comments/{test_comment.id}\", headers=headers)\n\n    assert response.status_code == 200\n    assert response.json()['message'] == \"Comment deleted successfully.\"\n    mock_db_session.delete.assert_called_once_with(test_comment)\n\n# Test for unauthorized access (no token)\ndef test_delete_comment_unauthorized(\n    mock_db_session, \n    test_user, \n    test_comment,\n):\n    headers = {}  # No authorization header\n\n    response = client.delete(f\"/api/v1/comments/{test_comment.id}\", headers=headers)\n\n    assert response.status_code == 401  # Unauthorized access\n\n# Test for internal server error during deletion\ndef test_delete_comment_internal_server_error(\n    mock_db_session, \n    test_user, \n    test_comment,\n    access_token_user1,\n):\n    def mock_get(model, ident):\n        if model == Comment and ident == test_comment.id:\n            return test_comment\n        return None\n\n    mock_db_session.get.side_effect = mock_get\n    mock_db_session.delete.side_effect = Exception(\"Internal server error\")\n\n    # Ensuring the user has proper authorization to access the comment\n    mock_db_session.query.return_value.filter.return_value.first.return_value = test_user\n\n    headers = {'Authorization': f'Bearer {access_token_user1}'}\n    response = client.delete(f\"/api/v1/comments/{test_comment.id}\", headers=headers)\n\n    assert response.status_code == 500\n    assert response.json()['message'] == \"Internal server error.\"\n\n# Test for comment not found\ndef test_delete_comment_not_found(\n    mock_db_session, \n    test_user,\n    access_token_user1,\n):\n    def mock_get(model, ident):\n        return None  # Simulate that no comment exists with this ID\n\n    mock_db_session.get.side_effect = mock_get\n\n    headers = {'Authorization': f'Bearer {access_token_user1}'}\n    response = client.delete(f\"/api/v1/comments/{str(uuid7())}\", headers=headers)\n\n    assert response.status_code == 404\n    assert response.json()['message'] == \"Comment does not exist\"\n\n# Test for invalid method\ndef test_delete_comment_invalid_method(\n    mock_db_session, \n    test_user, \n    test_comment,\n    access_token_user1,\n):\n    headers = {'Authorization': f'Bearer {access_token_user1}'}\n\n    response = client.get(f\"/api/v1/comments/{test_comment.id}\", headers=headers)\n\n    assert response.status_code == 405\n    assert response.json() == {\"detail\": \"Method Not Allowed\"}\n\n# Test for bad request with an invalid UUID\ndef test_delete_comment_bad_request(\n    mock_db_session, \n    test_user,\n    access_token_user1,\n):\n    invalid_uuid = \"invalid-uuid\"\n\n    headers = {'Authorization': f'Bearer {access_token_user1}'}\n    response = client.delete(f\"/api/v1/comments/{invalid_uuid}\", headers=headers)\n\n    assert response.status_code == 400\n    assert response.json()['message'] == \"An invalid request was sent.\""}
{"type": "test_file", "path": "tests/v1/comment/test_fetch_all_comments.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom unittest.mock import MagicMock\nfrom main import app  # Adjust this import according to your project structure\nfrom api.db.database import get_db\n\nfrom api.v1.models.blog import Blog\nfrom api.v1.models.comment import Comment\nfrom api.v1.schemas.comment import CommentsSchema, CommentsResponse\nfrom api.v1.services.comment import CommentService\n\n# Create a test client for the FastAPI app\nclient = TestClient(app)\n\n# Mocking the get_db dependency to return a session\n@pytest.fixture\ndef db_session():\n    session = MagicMock(spec=Session)\n    yield session\n\n@pytest.fixture\ndef comment_service_mock():\n    return MagicMock()\n\n# Overriding the dependency\n@pytest.fixture(autouse=True)\ndef override_get_db(db_session):\n    app.dependency_overrides[get_db] = lambda: db_session\n\n@pytest.fixture(autouse=True)\ndef override_comment_services(comment_service_mock):\n    app.dependency_overrides[CommentService] = lambda: comment_service_mock\n\n# Test the comments endpoint\ndef test_get_comments(db_session, comment_service_mock):\n    user_id = 'test_user_id'\n    blog_id = \"test_blog_id\"\n    page = 1\n    per_page = 20\n\n    # Create mock blog and comments data\n    blog = Blog(id=blog_id, author_id=user_id, content='some content', title='some title')\n    comments = [\n        Comment(user_id=\"user1\", blog_id=blog_id, content=\"Comment 1\", created_at=\"2023-07-28T12:00:00\"),\n        Comment(user_id=\"user2\", blog_id=blog_id, content=\"Comment 2\", created_at=\"2023-07-28T12:01:00\")\n    ]\n\n    # Mocking the database query\n    db_session.query.return_value.filter_by.return_value.one_or_none.return_value = blog\n    db_session.query.return_value.filter_by.return_value.order_by.return_value.limit.return_value.offset.return_value.all.return_value = comments\n    db_session.query.return_value.filter_by.return_value.count.return_value = len(comments)\n\n    # Mocking the CommentServices.validate_params method\n    comment_service_mock.validate_params.return_value = CommentsResponse(\n        page=page,\n        per_page=per_page,\n        total=len(comments),\n        data=[CommentsSchema.model_validate(comment) for comment in comments]\n    )\n\n    response = client.get(f\"/api/v1/blogs/{blog_id}/comments?page={page}&per_page={per_page}\")\n\n    assert response.status_code == 200\n    assert response.json() == {\n        \"page\": page,\n        \"per_page\": per_page,\n        \"total\": len(comments),\n        \"data\": [\n            {\n                \"user_id\": \"user1\",\n                \"blog_id\": blog_id,\n                \"content\": \"Comment 1\",\n                \"likes\": [],\n                \"dislikes\": [],\n                \"created_at\": \"2023-07-28T12:00:00\",\n                \"replies\": []\n            },\n            {\n                \"user_id\": \"user2\",\n                \"blog_id\": blog_id,\n                \"content\": \"Comment 2\",\n                \"likes\": [],\n                \"dislikes\": [],\n                \"created_at\": \"2023-07-28T12:01:00\",\n                \"replies\": []\n            }\n        ]\n    }\n\ndef test_get_comments_blog_not_found(db_session):\n    \"\"\"\n    Test for non-existing blog\n    \"\"\"\n    blog_id = \"non_existent_blog_id\"\n    page = 1\n    per_page = 20\n\n    # Mocking the database query to return None for the blog\n    db_session.query.return_value.filter_by.return_value.one_or_none.return_value = None\n\n    response = client.get(f\"/api/v1/blogs/{blog_id}/comments?page={page}&per_page={per_page}\")\n\n    assert response.status_code == 404\n"}
{"type": "test_file", "path": "tests/v1/blog/test_get_blogs_by_id.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom unittest.mock import MagicMock\nfrom datetime import datetime, timezone, timedelta\n\nfrom main import app\nfrom api.v1.routes.blog import get_db\n\n\n@pytest.fixture\ndef db_session_mock():\n    db_session = MagicMock(spec=Session)\n    return db_session\n\n\n@pytest.fixture\ndef client(db_session_mock):\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    client = TestClient(app)\n    yield client\n    app.dependency_overrides = {}\n\n\ndef create_mock_blog(id: str, author_id: str, title: str, content: str):\n    timezone_offset = -8.0\n    tzinfo = timezone(timedelta(hours=timezone_offset))\n    timeinfo = datetime.now(tzinfo)\n    return {\n        \"id\": id,\n        \"author_id\": author_id,\n        \"title\": title,\n        \"content\": content,\n        \"image_url\": \"http://example.com/image.png\",\n        \"tags\": \"test,blog\",\n        \"is_deleted\": False,\n        \"excerpt\": \"Test Excerpt\",\n        \"views\": 0, # Initialise view count\n        \"created_at\": timeinfo.isoformat(),\n        \"updated_at\": timeinfo.isoformat()\n    }\n\n\ndef test_fetch_blog_by_id(client, db_session_mock):\n    id = \"afa7addb-98a3-4603-8d3f-f36a31bcd1bd\"\n    author_id = \"7ca7a05d-1431-4b2c-8968-6c510e85831b\"\n    mock_blog = create_mock_blog(id, author_id, \"Test Title\", \"Test Content\")\n\n    db_session_mock.query().filter().first.return_value = mock_blog\n\n    response = client.get(f\"/api/v1/blogs/{id}\")\n\n    assert response.status_code == 200\n\n\ndef test_fetch_blog_by_id_not_found(client, db_session_mock):\n    id = \"afa7addb-98a3-4603-8d3f-f36a31bcd1bd\"\n\n    db_session_mock.query().filter().first.return_value = None\n\n    response = client.get(f\"/api/v1/blogs/{id}\")\n\n    assert response.status_code == 404\n\n# Test that view count increments when blog is viewed multiple times\ndef test_blog_view_count_increments(client, db_session_mock):\n    \"\"\"Test that view count increments when blog is viewed multiple times\"\"\"\n    id = \"afa7addb-98a3-4603-8d3f-f36a31bcd1bd\"\n    author_id = \"7ca7a05d-1431-4b2c-8968-6c510e85831b\"\n    \n    # First request - blog has initial view count of 0\n    mock_blog = create_mock_blog(id, author_id, \"Test Title\", \"Test Content\")\n    mock_blog[\"views\"] = 0  # Initial view count\n    db_session_mock.query().filter().first.return_value = mock_blog\n    \n    # First view increments count to 1\n    response1 = client.get(f\"/api/v1/blogs/{id}\")\n    assert response1.status_code == 200\n    assert response1.json()[\"data\"][\"views\"] == 1  # First view shows count=1\n    \n    # Second request (with updated mock)\n    mock_blog[\"views\"] = 1  # View count after first view\n    db_session_mock.query().filter().first.return_value = mock_blog\n    \n    # Second view increments count to 2\n    response2 = client.get(f\"/api/v1/blogs/{id}\")\n    assert response2.status_code == 200\n    assert response2.json()[\"data\"][\"views\"] == 2\n    \n    # Third request (with updated mock)\n    mock_blog[\"views\"] = 2  # View count after second view\n    db_session_mock.query().filter().first.return_value = mock_blog\n    \n    # Third view increments count to 3\n    response3 = client.get(f\"/api/v1/blogs/{id}\")\n    assert response3.status_code == 200\n    assert response3.json()[\"data\"][\"views\"] == 3\n\ndef increment_view_count(self, blog_id: str):\n    \"\"\"Increment the view count for a blog post\"\"\"\n    try:\n        blog = self.fetch(blog_id)\n        \n        # Support both dictionary blogs (for tests) and object blogs (for production)\n        if isinstance(blog, dict):\n            # Initialize views to 0 if it doesn't exist\n            if \"views\" not in blog:\n                blog[\"views\"] = 0\n            blog[\"views\"] += 1\n            return blog\n        else:\n            # For ORM objects\n            blog.views = blog.views + 1 if blog.views else 1\n            self.db.commit()\n            return blog\n    except Exception as e:\n        raise e\n"}
{"type": "test_file", "path": "tests/v1/comment/test_dislike_comment.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom main import app\nfrom api.v1.services.user import user_service\nfrom sqlalchemy.orm import Session\nfrom api.db.database import get_db\nfrom api.v1.models import User, Blog, Comment\nfrom api.v1.services.user import user_service\nfrom uuid_extensions import uuid7\nfrom unittest.mock import MagicMock\n\nclient = TestClient(app)\n\n# Mock database\n@pytest.fixture\ndef mock_db_session(mocker):\n    db_session_mock = mocker.MagicMock(spec=Session)\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    return db_session_mock\n\n# Test User\n@pytest.fixture\ndef test_user():\n    return User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"test\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n\n@pytest.fixture\ndef test_blog(test_user):\n    return Blog(\n        id=str(uuid7()),\n        author_id=test_user.id, \n        title=\"Test 1\", \n        content=\"Test blog one\"\n    )\n\n@pytest.fixture\ndef test_comment(test_user, test_blog):\n    return Comment(\n        id=str(uuid7()),\n        user_id=test_user.id,\n        blog_id=test_blog.id,\n        content=\"Just a test comment\",\n    )\n\n@pytest.fixture\ndef access_token_user1(test_user):\n    return user_service.create_access_token(user_id=test_user.id)\n\n# Test adding comment to blog\ndef test_dislike_comment(\n    mock_db_session, \n    test_user, \n    test_blog, \n    test_comment,\n    access_token_user1,\n):\n    # Mock the GET method for Organisation\n    def mock_get(model, ident):\n        if model == Comment and ident == test_comment.id:\n            return test_comment\n        return None\n\n    mock_db_session.get.side_effect = mock_get\n\n    # Mock the query to return test user\n    mock_db_session.query.return_value.filter.return_value.first.return_value = test_user\n    \n    # Mock the query to return null for existing dislikes\n    mock_db_session.query.return_value.filter_by.return_value.first.return_value = []\n\n    # Test user belonging to the organisation\n    headers = {'Authorization': f'Bearer {access_token_user1}'}\n    response = client.post(f\"/api/v1/comments/{test_comment.id}/dislike\", headers=headers)\n    \n    # Debugging statement\n    if response.status_code != 201:\n        print(response.json())  # Print error message for more details\n\n    assert response.status_code == 201, f\"Expected status code 200, got {response.status_code}\"\n    assert response.json()['message'] == \"Dislike added successfully\"\n\ndef test_dislike_comment_twice(\n    mock_db_session, \n    test_user, \n    test_blog, \n    test_comment,\n    access_token_user1,\n):\n    # Mock the GET method for Organisation\n    def mock_get(model, ident):\n        if model == Comment and ident == test_comment.id:\n            return test_comment\n        return None\n\n    mock_db_session.get.side_effect = mock_get\n\n    # Mock the query to return test user\n    mock_db_session.query.return_value.filter.return_value.first.return_value = test_user\n    \n    # Mock the query to return null for existing dislikes\n    mock_db_session.query.return_value.filter_by.return_value.first.return_value = [test_dislike_comment]\n\n    # Test user belonging to the organisation\n    headers = {'Authorization': f'Bearer {access_token_user1}'}\n    response = client.post(f\"/api/v1/comments/{test_comment.id}/dislike\", headers=headers)\n    \n    # Debugging statement\n    if response.status_code != 201:\n        print(response.json())  # Print error message for more details\n\n    assert response.status_code == 201, f\"Expected status code 201, got {response.status_code}\"\n    assert response.json()['message'] == \"Dislike removed successfully\""}
{"type": "test_file", "path": "tests/v1/blog/test_blog_update.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom uuid_extensions import uuid7\nfrom sqlalchemy.orm import Session\nfrom unittest.mock import MagicMock\n\nfrom main import app\nfrom api.db.database import get_db\nfrom api.v1.models.user import User\nfrom api.v1.models.blog import Blog\nfrom api.v1.schemas.blog import BlogRequest\nfrom api.v1.services.user import user_service\n\n@pytest.fixture(scope=\"module\")\ndef client():\n    with TestClient(app) as c:\n        yield c\n\n@pytest.fixture\ndef mock_db_session():\n    db = MagicMock(spec=Session)\n    yield db\n\n@pytest.fixture\ndef current_user():\n    return User(id=f'{uuid7()}', email=\"test@example.com\", password=\"hashedpassword1\", first_name=\"test\", last_name=\"user\")\n\n@pytest.fixture\ndef valid_blog_post():\n    return BlogRequest(title=\"Updated Title\", content=\"Updated Content\")\n\n@pytest.fixture\ndef existing_blog_post(mock_db_session, current_user):\n    blog = Blog(\n        id=f'{uuid7()}', \n        title=\"Original Title\", \n        content=\"Original Content\", \n        author_id=current_user.id\n    )\n    mock_db_session.query(Blog).filter(Blog.id == blog.id).first.return_value = blog\n    return blog\n\n@pytest.mark.asyncio\nasync def test_update_blog_success(client, mock_db_session, current_user, valid_blog_post, existing_blog_post):\n    # Mock the dependencies\n    app.dependency_overrides[get_db] = lambda: mock_db_session\n    app.dependency_overrides[user_service.get_current_super_admin] = lambda: current_user\n\n    response = client.put(\n        f\"api/v1/blogs/{existing_blog_post.id}\", \n        json=valid_blog_post.model_dump(),\n        headers={'Authorization': f'Bearer valid_token'}\n    )\n\n    assert response.status_code == 200\n    \n    assert existing_blog_post.title == valid_blog_post.title\n    assert existing_blog_post.content == valid_blog_post.content\n\n\n@pytest.mark.asyncio\nasync def test_update_blog_not_found(client, mock_db_session, current_user, valid_blog_post):\n    mock_db_session.query(Blog).filter(Blog.id == f'{uuid7()}').first.return_value = None\n\n    app.dependency_overrides[get_db] = lambda: mock_db_session\n    app.dependency_overrides[user_service.get_current_super_admin] = lambda: current_user\n\n    response = client.put(\n        f\"api/v1/blogs/{uuid7()}\", \n        json=valid_blog_post.model_dump(),\n        headers={'Authorization': 'Bearer token'}\n    )\n\n    assert response.status_code == 404\n\n\n@pytest.mark.asyncio\nasync def test_update_blog_forbidden(client, mock_db_session, current_user, valid_blog_post, existing_blog_post):\n    # Simulate a different user\n    different_user = User(\n        id=f'{uuid7()}', \n        email=\"other@example.com\",\n        password=\"hashedpassword1\", \n        first_name=\"other\", \n        last_name=\"user\"\n    )\n\n    app.dependency_overrides[get_db] = lambda: mock_db_session\n    app.dependency_overrides[user_service.get_current_super_admin] = lambda: different_user\n\n    response = client.put(\n        f\"api/v1/blogs/{existing_blog_post.id}\", \n        json=valid_blog_post.model_dump(),\n        headers={'Authorization': 'Bearer token'}\n    )\n\n    assert response.status_code == 403\n\n\n@pytest.mark.asyncio\nasync def test_update_blog_empty_fields(client, mock_db_session, current_user, existing_blog_post):\n    app.dependency_overrides[get_db] = lambda: mock_db_session\n    app.dependency_overrides[user_service.get_current_super_admin] = lambda: current_user\n\n    response = client.put(\n        f\"api/v1/blogs/{existing_blog_post.id}\", \n        json={\"title\": \"\", \"content\": \"\"},\n        headers={'Authorization': 'Bearer token'}\n    )\n\n    assert response.status_code == 400\n\n\n@pytest.mark.asyncio\nasync def test_update_blog_internal_error(client, mock_db_session, current_user, valid_blog_post, existing_blog_post):\n    # Simulate a database error\n    mock_db_session.commit.side_effect = Exception(\"Database error\")\n\n    app.dependency_overrides[get_db] = lambda: mock_db_session\n    app.dependency_overrides[user_service.get_current_super_admin] = lambda: current_user\n\n    response = client.put(f\"api/v1/blogs/{existing_blog_post.id}\", json=valid_blog_post.model_dump())\n\n    assert response.status_code == 500\n"}
{"type": "test_file", "path": "tests/v1/blog/test_dislike_blog_post.py", "content": "import pytest\nfrom main import app\nfrom uuid_extensions import uuid7\nfrom sqlalchemy.orm import Session\nfrom api.db.database import get_db\nfrom datetime import datetime, timezone\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom api.v1.services.user import user_service\nfrom api.v1.models import User, Blog, BlogDislike\n\nclient = TestClient(app)\n\n# Mock database\n@pytest.fixture\ndef mock_db_session(mocker):\n    db_session_mock = mocker.MagicMock(spec=Session)\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    return db_session_mock\n\n\n@pytest.fixture\ndef mock_user_service():\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as user_service_mock:\n        yield user_service_mock\n\n\n@pytest.fixture\ndef mock_blog_service():\n    with patch(\"api.v1.services.blog.BlogService\", autospec=True) as blog_service_mock:\n        yield blog_service_mock\n\n\n# Test User\n@pytest.fixture\ndef test_user():\n    return User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"test\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n@pytest.fixture()\ndef test_blog(test_user):\n    return Blog(\n        id=str(uuid7()),\n        author_id=test_user.id,\n        title=\"Blog Post 1\",\n        content=\"This is blog post number 1\"\n    )\n\n@pytest.fixture()\ndef test_blog_dislike(test_user, test_blog):\n    return BlogDislike(\n            id=str(uuid7()),\n            user_id=test_user.id,\n            blog_id=test_blog.id,\n            ip_address=\"192.168.1.0\",\n            created_at=datetime.now(tz=timezone.utc)\n        )\n\n@pytest.fixture\ndef access_token_user(test_user):\n    return user_service.create_access_token(user_id=test_user.id)\n\ndef make_request(blog_id, token):\n    return client.post(\n        f\"/api/v1/blogs/{blog_id}/dislike\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n\n\n@patch(\"api.v1.services.blog.BlogService.create_blog_dislike\")\ndef test_successful_dislike(\n    mock_create_blog_dislike,\n    mock_db_session, \n    test_user, \n    test_blog,\n    test_blog_dislike,\n    access_token_user\n):\n    # mock current-user AND blog-post\n    mock_db_session.query().filter().first.side_effect = [test_user, test_blog]\n\n    # mock existing-blog-dislike AND new-blog-dislike\n    mock_db_session.query().filter_by().first.side_effect = None\n\n    # mock created-blog-dislike\n    mock_create_blog_dislike.return_value = test_blog_dislike\n\n    # mock dislike-count\n    mock_db_session.query().filter_by().count.return_value = 1\n\n    resp = make_request(test_blog.id, access_token_user)\n    resp_d = resp.json()\n    assert resp.status_code == 200\n    assert resp_d['status'] == \"success\"\n    assert resp_d['message'] == \"Dislike recorded successfully.\"\n\n    dislike_data = resp_d['data']['object']\n    assert dislike_data['id'] == test_blog_dislike.id\n    assert dislike_data['blog_id'] == test_blog.id\n    assert dislike_data['user_id'] == test_user.id\n    assert dislike_data['ip_address'] == test_blog_dislike.ip_address\n    assert datetime.fromisoformat(dislike_data['created_at']) == test_blog_dislike.created_at\n    assert resp_d['data']['objects_count'] == 1\n\n\n# Test for double dislike\ndef test_double_dislike(\n    mock_db_session, \n    test_user, \n    test_blog, \n    test_blog_dislike,\n    access_token_user,\n):\n    mock_user_service.get_current_user = test_user\n    mock_db_session.query.return_value.filter.return_value.first.return_value = test_blog\n    mock_db_session.query.return_value.filter_by.return_value.first.return_value = test_blog_dislike\n\n    ### TEST ATTEMPT FOR MULTIPLE DISLIKING... ###\n    resp = make_request(test_blog.id, access_token_user)\n    assert resp.status_code == 403\n    assert resp.json()['message'] == \"You have already disliked this blog post\"\n\n# Test for wrong blog id\ndef test_wrong_blog_id(\n    mock_db_session, \n    test_user,\n    access_token_user,\n):\n    mock_user_service.get_current_user = test_user\n    mock_db_session.query().filter().first.return_value = None\n\n    ### TEST REQUEST WITH WRONG blog_id ###\n    ### using random uuid instead of blog1.id  ###\n    resp = make_request(str(uuid7()), access_token_user)\n    assert resp.status_code == 404\n    assert resp.json()['message'] == \"Post not found\"\n\n\n# Test for unauthenticated user\ndef test_wrong_auth_token(\n    mock_db_session,\n    test_blog\n):\n    mock_user_service.get_current_user = None\n\n    ### TEST ATTEMPT WITH INVALID AUTH... ###\n    resp = make_request(test_blog.id, None)\n    assert resp.status_code == 401\n    assert resp.json()['message'] == 'Could not validate credentials'"}
{"type": "test_file", "path": "tests/v1/blog/test_delete_blog_like.py", "content": "import pytest\nfrom main import app\nfrom uuid_extensions import uuid7\nfrom sqlalchemy.orm import Session\nfrom api.db.database import get_db\nfrom datetime import datetime, timezone\nfrom api.v1.models import User, BlogLike\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom api.v1.services.user import user_service\n\nclient = TestClient(app)\n\n# Mock database\n@pytest.fixture\ndef mock_db_session(mocker):\n    db_session_mock = mocker.MagicMock(spec=Session)\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    return db_session_mock\n\n\n@pytest.fixture\ndef mock_user_service():\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as user_service_mock:\n        yield user_service_mock\n\n\n@pytest.fixture\ndef mock_blog_service():\n    with patch(\"api.v1.services.blog.BlogService\", autospec=True) as blog_service_mock:\n        yield blog_service_mock\n\n\n# Test User\n@pytest.fixture\ndef test_user():\n    return User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"test\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n\n# Another User\n@pytest.fixture\ndef another_user():\n    return User(\n        id=str(uuid7()),\n        email=\"anotheruser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"another\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n@pytest.fixture\ndef test_blog_like(test_user):\n    return BlogLike(\n            id=str(uuid7()),\n            user_id=test_user.id,\n            blog_id=str(uuid7()),\n            ip_address=\"192.168.1.0\",\n            created_at=datetime.now(tz=timezone.utc)\n        )\n\n@pytest.fixture\ndef access_token_user(test_user):\n    return user_service.create_access_token(user_id=test_user.id)\n\n@pytest.fixture\ndef access_token_another(another_user):\n    return user_service.create_access_token(user_id=another_user.id)\n\n\ndef make_request(blog_like_id, token):\n    return client.delete(\n        f\"/api/v1/blogs/likes/{blog_like_id}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n\n\n# test for successful delete\n@patch(\"api.v1.services.blog.BlogLikeService.fetch\")\ndef test_successful_delete_bloglike(\n    mock_fetch_blog_like,\n    mock_db_session, \n    test_user,\n    test_blog_like,\n    access_token_user\n):\n    # mock current-user AND blog-like\n    mock_db_session.query().filter().first.return_value = test_user\n    mock_fetch_blog_like.return_value = test_blog_like\n\n    resp = make_request(test_blog_like.id, access_token_user)\n    assert resp.status_code == 204\n\n\n# Test for wrong blog like id\ndef test_wrong_blog_like_id(\n    # mock_fetch_blog_like,\n    mock_db_session, \n    test_user,\n    access_token_user,\n):\n    mock_db_session.query().filter().first.return_value = test_user\n    mock_db_session.get.return_value = None\n\n    ### TEST REQUEST WITH WRONG blog_like_id ###\n    resp = make_request(str(uuid7()), access_token_user)\n    assert resp.status_code == 404\n    assert resp.json()['message'] == \"BlogLike does not exist\"\n\n\n# Test for unauthenticated user\ndef test_wrong_auth_token(\n    mock_db_session,\n    test_blog_like\n):\n    mock_user_service.get_current_user = None\n\n    ### TEST ATTEMPT WITH INVALID AUTH ###\n    resp = make_request(test_blog_like.id, None)\n    assert resp.status_code == 401\n    assert resp.json()['message'] == 'Could not validate credentials'\n\n\n# Test for wrong owner request\ndef test_wrong_owner_request(\n    mock_db_session,\n    test_blog_like,\n    another_user,\n    access_token_another\n):\n    mock_user_service.get_current_user = another_user\n    mock_db_session.get.return_value = test_blog_like\n\n    ### TEST ATTEMPT BY NON OWNER ###\n    resp = make_request(test_blog_like.id, access_token_another)\n    assert resp.status_code == 401\n    assert resp.json()['message'] == 'Insufficient permission'"}
{"type": "test_file", "path": "tests/v1/bookmark/test_save_job.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom fastapi import HTTPException\nfrom main import app  \nfrom api.v1.models.job import Job  \nfrom api.v1.models.bookmark import Bookmark \nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom api.v1.services.bookmark import bookmark_service\nfrom api.db.database import get_db \n\n@pytest.fixture\ndef mock_user():\n    return MagicMock(id='test_user_id')  \n\n@pytest.fixture\ndef mock_job():\n    return Job(id='test_job_id')  \n\n@pytest.fixture\ndef mock_db():\n    db = MagicMock()\n    return db\n\n@pytest.fixture\ndef override_get_db(mock_db):\n    app.dependency_overrides[get_db] = lambda: mock_db\n    yield\n    app.dependency_overrides.pop(get_db, None)\n\n@pytest.fixture\ndef client(mock_user, override_get_db):\n    app.dependency_overrides[user_service.get_current_user] = lambda: mock_user\n    client = TestClient(app)\n    yield client\n    app.dependency_overrides = {}\n\ndef test_create_bookmark_success(mock_db, mock_user, mock_job, client):\n    # Set up mock_db to return mock_job\n    mock_db.query.return_value.filter.return_value.first.return_value = mock_job\n    \n    # Patch the bookmark_service.create method\n    with patch('api.v1.services.bookmark.bookmark_service.create') as mock_create:\n        mock_create.return_value = Bookmark(id='new_bookmark_id')\n        \n        response = client.post(\n            f\"/api/v1/jobs/bookmark/{mock_job.id}\",\n            json={\"job_id\": mock_job.id}\n        )\n        \n        assert response.status_code == 200\n        assert response.json() == {\n            \"status\": \"success\",\n            \"message\": \"Job saved successfully\",\n            \"status_code\": 200,\n            \"data\": {}\n        }\n        \n        # Verify create was called with correct parameters\n        mock_create.assert_called_once_with(mock_db, mock_job.id, mock_user.id)\n\ndef test_create_bookmark_already_exists(mock_db, mock_user, mock_job, client):\n    # Set up mock_db to return mock_job\n    mock_db.query.return_value.filter.return_value.first.return_value = mock_job\n    \n    # Patch the bookmark_service.create method to raise an exception\n    with patch('api.v1.services.bookmark.bookmark_service.create') as mock_create:\n        mock_create.side_effect = HTTPException(\n            status_code=400,\n            detail=\"Job already saved\"\n        )\n        \n        response = client.post(\n            f\"/api/v1/jobs/bookmark/{mock_job.id}\",\n            json={\"job_id\": mock_job.id}\n        )\n        \n        assert response.status_code == 200\n        assert response.json() == {\n            \"status\": \"failure\",\n            \"message\": \"Job already saved\",\n            \"status_code\": 400,\n            \"data\": {}\n        }\n        \n        # Verify create was called with correct parameters\n        mock_create.assert_called_once_with(mock_db, mock_job.id, mock_user.id)\n\ndef test_create_bookmark_job_not_exist(mock_db, mock_user, client):\n    # Mock the database query to return None for a non-existent job\n    mock_db.query.return_value.filter.return_value.first.return_value = None\n    \n    non_existent_job_id = 'non_existent_job_id'\n    \n    # No need to patch bookmark_service.create since it shouldn't be called\n    response = client.post(\n        f\"/api/v1/jobs/bookmark/{non_existent_job_id}\",\n        json={\"job_id\": non_existent_job_id}\n    )\n    \n    assert response.status_code == 200\n    assert response.json() == {\n        \"status\": \"failure\",\n        \"message\": \"Job not listed\",\n        \"status_code\": 400,\n        \"data\": {}\n    }"}
{"type": "test_file", "path": "tests/v1/blog/test_update_blog_comment.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom main import app\nfrom api.v1.services.user import user_service\nfrom sqlalchemy.orm import Session\nfrom api.db.database import get_db\nfrom api.v1.models import User, Blog, Comment\nfrom api.v1.services.user import user_service\nfrom uuid_extensions import uuid7\nfrom unittest.mock import MagicMock\n\nclient = TestClient(app)\n\n# Mock database\n@pytest.fixture\ndef mock_db_session(mocker):\n    db_session_mock = mocker.MagicMock(spec=Session)\n    app.dependency_overrides[get_db] = lambda: db_session_mock\n    return db_session_mock\n\n# Test User \n@pytest.fixture\ndef test_user_1():\n    return User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"test\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n\n# Test Super admin \n@pytest.fixture\ndef test_user_2():\n    return User(\n        id=str(uuid7()),\n        email=\"testuser@gmail.com\",\n        password=\"hashedpassword\",\n        first_name=\"test\",\n        last_name=\"user\",\n        is_active=True,\n    )\n\n# Test Blog \n@pytest.fixture\ndef test_blog(test_user_1):\n    return Blog(\n        id=str(uuid7()),\n        author_id=test_user_1.id,\n        title=\"test blog\",\n        content=\"testing blog 1, 2, 3..\"\n    )\n\n# Test Comment\n@pytest.fixture\ndef test_comment(test_user_1, test_blog):\n    return Comment(\n        id=str(uuid7()),\n        user_id=test_user_1.id,\n        blog_id=test_blog.id,\n        content=\"Testing 1, 2, 3... \"\n    )\n\n@pytest.fixture\ndef update_url(test_blog, test_comment):\n    return {\n        \"both_exists\": f\"/api/v1/blogs/{test_blog.id}/comments/{test_comment.id}\",\n        \"blog_exists\": f\"/api/v1/blogs/{test_blog.id}/comments/898989\",\n        \"comment_exists\": f\"/api/v1/blogs/898989/comments/{test_comment.id}\"\n    }\n\n# defining the update request body\ncomment_content = {\"content\": \"Updated blog comment\"}\n\n# Access token for test user 1\n@pytest.fixture\ndef test_user_1_access_token(test_user_1):\n    return user_service.create_access_token(user_id=test_user_1.id)\n\n# Access token for test user 2\n@pytest.fixture\ndef test_user_2_access_token(test_user_2):\n    return user_service.create_access_token(user_id=test_user_2.id)\n\n# Test updating comment with the test_user_1 who created the comment\ndef test_comment_update_by_comment_author(\n    mock_db_session, \n   test_user_1,\n   test_blog,\n   test_comment,\n   test_user_1_access_token,\n   update_url\n):\n    # Mock the GET method for Blog ID and Comment ID\n    def mock_get(model, ident):\n        if model == Blog and ident == test_blog.id:\n            return test_blog\n        elif model == Comment and ident == test_comment.id:\n            return test_comment\n        return None\n\n    mock_db_session.get.side_effect = mock_get\n\n    # Mock the query to return test user 1\n    mock_db_session.query.return_value.filter.return_value.first.return_value = test_user_1\n\n    # Test updating comment\n    headers = {'Authorization': f'Bearer {test_user_1_access_token}'}\n    response = client.put(update_url['both_exists'], headers=headers, json=comment_content)\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    assert response.json()['message'] == \"Blog comment updated successfully\"\n    assert response.json()['data']['content'] == comment_content['content']\n\n# Test updating comment with the test_user_2 who did not create the test_comment\ndef test_comment_update_by_non_comment_author(\n    mock_db_session, \n   test_user_2,\n   test_blog,\n   test_comment,\n   test_user_2_access_token,\n   update_url\n):\n    # Mock the GET method for Blog ID and Comment ID\n    def mock_get(model, ident):\n        if model == Blog and ident == test_blog.id:\n            return test_blog\n        elif model == Comment and ident == test_comment.id:\n            return test_comment\n        return None\n\n    mock_db_session.get.side_effect = mock_get\n\n    # Mock the query to return test user 1\n    mock_db_session.query.return_value.filter.return_value.first.return_value = test_user_2\n \n    # Test updating comment\n    headers = {'Authorization': f'Bearer {test_user_2_access_token}'}\n    response = client.put(update_url['both_exists'], headers=headers, json=comment_content)\n    \n    assert response.status_code == 403, f\"Expected status code 403, got {response.status_code}\"\n    assert response.json()[\"message\"] == \"You are not authorized to update this comment\"\n\n# Test updating comment with the test_user_2 who did not create the test_comment\ndef test_non_existing_comment_id(\n    mock_db_session, \n   test_user_2,\n   test_blog,\n   test_comment,\n   test_user_2_access_token,\n   update_url\n):\n    # Mock the GET method for Blog ID and Comment ID\n    def mock_get(model, ident):\n        if model == Blog and ident == test_blog.id:\n            return test_blog\n        elif model == Comment and ident == test_comment.id:\n            return test_comment\n        return None\n\n    mock_db_session.get.side_effect = mock_get\n\n    # Mock the query to return test user 1\n    mock_db_session.query.return_value.filter.return_value.first.return_value = test_user_2\n \n    # Test non existing Comment ID\n    headers = {'Authorization': f'Bearer {test_user_2_access_token}'}\n    response = client.put(update_url['blog_exists'], headers=headers, json=comment_content)\n    \n    assert response.status_code == 404, f\"Expected status code 404, got {response.status_code}\"\n    assert response.json()[\"message\"] == \"Comment does not exist\"\n\n    # Test non existing Blog ID\n    response = client.put(update_url['comment_exists'], headers=headers, json=comment_content)\n\n    assert response.status_code == 404, f\"Expected status code 404, got {response.status_code}\"\n    assert response.json()[\"message\"] == \"Blog does not exist\"\n\n\n\n"}
{"type": "source_file", "path": "api/utils/email_service.py", "content": "import smtplib\nfrom api.utils.settings import settings\nfrom fastapi import HTTPException\n\n\ndef send_mail(to: str, subject: str, body: str):\n    \"\"\"Function to send email to a user either as a regular test or as html file\"\"\"\n    try:\n        with smtplib.SMTP(settings.MAIL_SERVER, settings.MAIL_PORT) as conn:\n            conn.starttls()\n            conn.login(user=settings.MAIL_USERNAME, password=settings.MAIL_PASSWORD)\n            conn.sendmail(\n                from_addr=settings.MAIL_FROM,\n                to_addrs=to,\n                msg=f\"Subject:{subject}\\n\\n{body}\",\n            )\n    except smtplib.SMTPException as smtp_error:\n        raise HTTPException(500, f\"SMTP ERROR- {smtp_error}\")\n"}
{"type": "source_file", "path": "api/core/dependencies/email_sender.py", "content": "from typing import Optional\nfrom fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType\nfrom api.utils.settings import settings\nfrom premailer import transform\n\n\n\nasync def send_email(\n    recipient: str, \n    template_name: str, \n    subject: str, \n    context: Optional[dict] = None\n):\n    from main import email_templates\n\n    conf = ConnectionConfig(\n        MAIL_USERNAME=settings.MAIL_USERNAME,\n        MAIL_PASSWORD=settings.MAIL_PASSWORD,\n        MAIL_FROM=settings.MAIL_FROM,\n        MAIL_PORT=settings.MAIL_PORT,\n        MAIL_SERVER=settings.MAIL_SERVER,\n        USE_CREDENTIALS=True,\n        VALIDATE_CERTS=True,\n        MAIL_STARTTLS = False,\n        MAIL_SSL_TLS = True,\n        MAIL_FROM_NAME='HNG Boilerplate',\n        # SUPPRESS_SEND=True  # suppress sending of email in testing environment\n    )\n    \n    message = MessageSchema(\n        subject=subject,\n        recipients=[recipient],\n        subtype=MessageType.html\n    )\n    \n    # Render the template with context\n    html = email_templates.get_template(template_name).render(context)\n    message.body = transform(html)\n    \n    fm = FastMail(conf)\n    await fm.send_message(message)\n    "}
{"type": "source_file", "path": "api/utils/success_response.py", "content": "from typing import Optional, Dict, Any\nfrom fastapi.responses import JSONResponse\nfrom fastapi.encoders import jsonable_encoder\n\n\ndef success_response(status_code: int, message: str, data: Optional[dict] = None):\n    \"\"\"Returns a JSON response for success responses\"\"\"\n\n    response_data = {\n        \"status\": \"success\",\n        \"status_code\": status_code,\n        \"message\": message,\n        \"data\": data or {}  # Ensure data is always a dictionary\n    }\n\n    return JSONResponse(status_code=status_code, content=jsonable_encoder(response_data))\n\n\ndef auth_response(status_code: int, message: str, access_token: str, data: Optional[dict] = None):\n    \"\"\"Returns a JSON response for successful auth responses\"\"\"\n\n    response_data = {\n        \"status\": \"success\",\n        \"status_code\": status_code,\n        \"message\": message,\n        \"data\": {\n            \"access_token\": access_token,\n            **(data or {})  # Merge additional data if provided\n        }\n    }\n\n    return JSONResponse(status_code=status_code, content=jsonable_encoder(response_data))\n\n\ndef fail_response(status_code: int, message: str, data: Optional[dict] = None):\n    \"\"\"Returns a JSON response for failure responses\"\"\"\n\n    response_data = {\n        \"status\": \"failure\",\n        \"status_code\": status_code,\n        \"message\": message,\n        \"data\": data or {}  # Ensure data is always a dictionary\n    }\n\n    return JSONResponse(status_code=status_code, content=jsonable_encoder(response_data))\n"}
{"type": "source_file", "path": "api/core/responses.py", "content": "EMAIL_IN_USE = \"This email is already in use.\"\nNOT_FOUND = \"Not found!\"\nID_OR_UNIQUE_ID_REQUIRED = \"ID or Unique ID required!\"\nINVALID_CREDENTIALS = \"Invalid Credentials!\"\nCOULD_NOT_VALIDATE_CRED = \"Could not validate credentials.\"\nSUCCESS = \"SUCCESS\"\nEXPIRED = \"Token expired.\"\n"}
{"type": "source_file", "path": "api/core/dependencies/__init__.py", "content": ""}
{"type": "source_file", "path": "api/core/__init__.py", "content": ""}
{"type": "source_file", "path": "api/utils/settings.py", "content": "from pydantic_settings import BaseSettings\nfrom decouple import config\nfrom pathlib import Path\n\n\n# Use this to build paths inside the project\nBASE_DIR = Path(__file__).resolve().parent\n\nclass Settings(BaseSettings):\n    \"\"\"Class to hold application's config values.\"\"\"\n\n    SECRET_KEY: str = config(\"SECRET_KEY\")\n    ALGORITHM: str = config(\"ALGORITHM\")\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = config(\"ACCESS_TOKEN_EXPIRE_MINUTES\")\n    JWT_REFRESH_EXPIRY: int = config(\"JWT_REFRESH_EXPIRY\")\n\n    # Database configurations\n    DB_HOST: str = config(\"DB_HOST\")\n    DB_PORT: int = config(\"DB_PORT\", cast=int)\n    DB_USER: str = config(\"DB_USER\")\n    DB_PASSWORD: str = config(\"DB_PASSWORD\")\n    DB_NAME: str = config(\"DB_NAME\")\n    DB_TYPE: str = config(\"DB_TYPE\")\n\n    MAIL_USERNAME: str = config(\"MAIL_USERNAME\")\n    MAIL_PASSWORD: str = config(\"MAIL_PASSWORD\")\n    MAIL_FROM: str = config(\"MAIL_FROM\")\n    MAIL_PORT: int = config(\"MAIL_PORT\")\n    MAIL_SERVER: str = config(\"MAIL_SERVER\")\n\n    FLUTTERWAVE_SECRET: str = config(\"FLUTTERWAVE_SECRET\")\n\n    TWILIO_ACCOUNT_SID: str = config(\"TWILIO_ACCOUNT_SID\")\n    TWILIO_AUTH_TOKEN: str = config(\"TWILIO_AUTH_TOKEN\")\n    TWILIO_PHONE_NUMBER: str = config(\"TWILIO_PHONE_NUMBER\")\n\n    APP_NAME: str = config(\"APP_NAME\")\n\n    # Base URLs\n    ANCHOR_PYTHON_BASE_URL: str = config(\n        \"ANCHOR_PYTHON_BASE_URL\", default=\"https://anchor-python.teams.hng.tech\"\n    )\n\n    # telex webhook url\n    TELEX_WEBHOOK_URL: str = config(\"TELEX_WEBHOOK_URL\")\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "__init__.py", "content": ""}
{"type": "source_file", "path": "api/utils/logger.py", "content": "import logging\n\nlogging.basicConfig(\n    level=logging.ERROR,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    handlers=[logging.FileHandler(\"error.log\"), logging.StreamHandler()],\n)\n\nlogger = logging.getLogger(__name__)\n"}
{"type": "source_file", "path": "api/v1/__init__.py", "content": ""}
{"type": "source_file", "path": "alembic/env.py", "content": "from logging.config import fileConfig\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\nfrom alembic import context\nfrom decouple import config as decouple_config\nfrom api.v1.models import *\nfrom api.v1.models.permissions.permissions import Permission\nfrom api.v1.models.permissions.role_permissions import role_permissions\nfrom api.v1.models.permissions.user_org_role import user_organisation_roles\nfrom api.v1.models.permissions.role import Role\nfrom api.v1.models.associations import Base\n\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\ndatabase_url = decouple_config('DB_URL')\n\n# Set the SQLAlchemy URL dynamically\nconfig.set_main_option('sqlalchemy.url', database_url)\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata,\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"}
{"type": "source_file", "path": "api/v1/models/activity_logs.py", "content": "from sqlalchemy import Column, String, DateTime, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass ActivityLog(BaseTableModel):\n    __tablename__ = \"activity_logs\"\n\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    action = Column(String, nullable=False)\n    timestamp = Column(DateTime(timezone=True), server_default=func.now())\n\n    user = relationship(\"User\", back_populates=\"activity_logs\")\n"}
{"type": "source_file", "path": "api/core/base/services.py", "content": "from abc import ABC, abstractmethod\n\n\nclass Service(ABC):\n    @abstractmethod\n    def create(self):\n        pass\n\n    @abstractmethod\n    def fetch(self):\n        pass\n\n    @abstractmethod\n    def fetch_all(self):\n        pass\n\n    @abstractmethod\n    def update(self):\n        pass\n\n    @abstractmethod\n    def delete(self):\n        pass\n"}
{"type": "source_file", "path": "api/utils/pagination.py", "content": "from typing import Any, Dict, List, Optional\nfrom fastapi.encoders import jsonable_encoder\nfrom sqlalchemy.orm import Session\nfrom api.db.database import Base\n\nfrom api.utils.success_response import success_response\n\n\ndef paginated_response(\n    db: Session,\n    model,\n    skip: int,\n    limit: int,\n    join: Optional[Any] = None,\n    filters: Optional[Dict[str, Any]]=None\n):\n\n    '''\n    Custom response for pagination.\\n\n    This takes in four atguments:\n        * db- this is the database session\n        * model- this is the database table model eg Product, Organisation```\n        * limit- this is the number of items to fetch per page, this would be a query parameter\n        * skip- this is the number of items to skip before fetching the next page of data. This would also\n        be a query parameter\n        * join- this is an optional argument to join a table to the query\n        * filters- this is an optional dictionary of filters to apply to the query\n\n    Example use:\n        **Without filter**\n        ``` python\n        return paginated_response(\n            db=db,\n            model=Product,\n            limit=limit,\n            skip=skip\n        )\n        ```\n\n        **With filter**\n        ``` python\n        return paginated_response(\n            db=db,\n            model=Product,\n            limit=limit,\n            skip=skip,\n            filters={'org_id': org_id}\n        )\n        ```\n\n        **With join**\n        ``` python\n        return paginated_response(\n            db=db,\n            model=Product,\n            limit=limit,\n            skip=skip,\n            join=user_organisation_association,\n            filters={'org_id': org_id}\n        )\n        ```\n    '''\n\n    query = db.query(model)\n\n    if join is not None:\n        query = query.join(join)\n        \n    if filters and join is None:\n        # Apply filters\n        for attr, value in filters.items():\n            if value is not None:\n                query = query.filter(getattr(model, attr).like(f\"%{value}%\"))\n\n    elif filters and join is not None:\n        # Apply filters\n        for attr, value in filters.items():\n            if value is not None:\n                query = query.filter(\n                    getattr(getattr(join, \"columns\"),\n                            attr).like(f\"%{value}%\"))\n\n    total = int(query.count())\n    results = jsonable_encoder(query.offset(skip).limit(limit).all())\n    total_pages = int(total / limit) + (total % limit > 0)\n\n    return success_response(\n        status_code=200,\n        message=\"Successfully fetched items\",\n        data={\n            \"pages\": total_pages,\n            \"total\": total,\n            \"skip\": skip,\n            \"limit\": limit,\n            \"items\": jsonable_encoder(\n                results,\n                exclude={\n                    'password',\n                    'is_superadmin',\n                    'is_deleted',\n                    'is_active'\n                }\n            )\n        }\n    )\n"}
{"type": "source_file", "path": "api/core/dependencies/google_email.py", "content": "import smtplib\nfrom typing import List, Optional, Union\n\nfrom fastapi import HTTPException\nfrom api.utils.settings import settings\n\n\nclass MailService:\n    \"\"\"Class to send different emails for different services\"\"\"\n\n    def send_mail(self, to: str, subject: str, body: str):\n        \"\"\"Function to send email to a user either as a regular test or as html file\"\"\"\n\n        try:\n            with smtplib.SMTP(settings.MAIL_SERVER, settings.MAIL_PORT) as conn:\n                conn.starttls()\n                conn.login(user=settings.MAIL_USERNAME, password=settings.MAIL_PASSWORD) \n                conn.sendmail(\n                    from_addr=settings.MAIL_FROM,\n                    to_addrs=to,\n                    msg=f\"Subject:{subject}\\n\\n{body}\"\n                )\n\n        except smtplib.SMTPException as smtp_error:\n            raise HTTPException(500, f'SMTP ERROR- {smtp_error}')\n\n        print(\"Email sent successfully\")\n\n\nmail_service = MailService()\n"}
{"type": "source_file", "path": "api/db/database.py", "content": "\"\"\" The database module\n\"\"\"\nfrom sqlalchemy.orm import sessionmaker, scoped_session, declarative_base\nfrom sqlalchemy import create_engine\nfrom api.utils.settings import settings, BASE_DIR\n\n\nDB_HOST = settings.DB_HOST\nDB_PORT = settings.DB_PORT\nDB_USER = settings.DB_USER\nDB_PASSWORD = settings.DB_PASSWORD\nDB_NAME = settings.DB_NAME\nDB_TYPE = settings.DB_TYPE\n\n\ndef get_db_engine(test_mode: bool = False):\n    DATABASE_URL = f\"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}\"\n\n    if DB_TYPE == \"sqlite\" or test_mode:\n        BASE_PATH = f\"sqlite:///{BASE_DIR}\"\n        DATABASE_URL = BASE_PATH + \"/\"\n\n        if test_mode:\n            DATABASE_URL = BASE_PATH + \"test.db\"\n\n            return create_engine(\n                DATABASE_URL, connect_args={\"check_same_thread\": False}\n            )\n    elif DB_TYPE == \"postgresql\":\n        DATABASE_URL = (\n            f\"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}\"\n        )\n\n    return create_engine(DATABASE_URL)\n\n\nengine = get_db_engine()\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndb_session = scoped_session(SessionLocal)\n\nBase = declarative_base()\n\n\ndef create_database():\n    return Base.metadata.create_all(bind=engine)\n\n\ndef get_db():\n    db = db_session()\n    try:\n        yield db\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "api/core/base/__init__.py", "content": ""}
{"type": "source_file", "path": "api/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "api/utils/client_helpers.py", "content": "# All helper functions relating to user clients\n\n\ndef get_ip_address(request):\n    client_ip = request.headers.get(\"X-Forwarded-For\")\n    if client_ip is None or client_ip == \"\":\n        client_ip = request.client.host\n    return client_ip"}
{"type": "source_file", "path": "api/v1/models/billing_plan.py", "content": "# app/models/billing_plan.py\nfrom sqlalchemy import Column, String, ARRAY, ForeignKey, Numeric, Boolean\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy import DateTime\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass BillingPlan(BaseTableModel):\n    __tablename__ = \"billing_plans\"\n\n    organisation_id = Column(\n        String, ForeignKey(\"organisations.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    name = Column(String, nullable=False)\n    price = Column(Numeric, nullable=False)\n    currency = Column(String, nullable=False)\n    duration = Column(String, nullable=False)\n    description = Column(String, nullable=True)\n    features = Column(ARRAY(String), nullable=False)\n\n    organisation = relationship(\"Organisation\", back_populates=\"billing_plans\")\n    user_subscriptions = relationship(\"UserSubscription\", back_populates=\"billing_plan\", cascade=\"all, delete-orphan\")\n\n\nclass UserSubscription(BaseTableModel):\n    __tablename__ = \"user_subscriptions\"\n\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    plan_id = Column(String, ForeignKey(\"billing_plans.id\", ondelete=\"CASCADE\"), nullable=False)\n    organisation_id = Column(String, ForeignKey(\"organisations.id\", ondelete=\"CASCADE\"), nullable=False)\n    active = Column(Boolean, default=True)\n    start_date = Column(String, nullable=False)\n    end_date = Column(String, nullable=True)\n    \n    user = relationship(\"User\", back_populates=\"subscriptions\")\n    billing_plan = relationship(\"BillingPlan\", back_populates=\"user_subscriptions\")\n    organisation = relationship(\"Organisation\", back_populates=\"user_subscriptions\")\n    billing_cycle = Column(DateTime, nullable=True)\n"}
{"type": "source_file", "path": "api/utils/config.py", "content": "import os\n\n# Define your JWT secret and algorithm\nSECRET_KEY = os.getenv(\"SECRET_KEY\", \"MY SECRET KEY\")\nALGORITHM = os.getenv(\"ALGORITHM\", \"HS256\")\n"}
{"type": "source_file", "path": "api/utils/send_logs.py", "content": "import json\nimport httpx\nimport datetime\nfrom api.utils.settings import settings\nfrom api.utils.logger import logger\n\nTELEX_WEBHOOK_URL = settings.TELEX_WEBHOOK_URL\n\nasync def send_error_to_telex(request_method, request_url_path, exc):\n    \"\"\"Send error log to Telex\"\"\"\n    if not TELEX_WEBHOOK_URL:\n        logger.error(\"TELEX_WEBHOOK_URL is not set\")\n        return\n    \n    status_code = getattr(exc, \"status_code\", 500)\n    error_data = {\n        \"status\": \"error\",\n        \"username\": \"hng_boilerplate\",\n        \"message\": json.dumps(\n            {\n                \"timestamp\": datetime.datetime.utcnow().strftime(\"%Y-%m-%d %H:%M\"),\n                \"event_name\": \"server_error\",\n                \"request_method\": request_method,\n                \"request_path\": request_url_path,\n                \"status_code\": status_code,\n                \"error_message\": f\"An unexpected error occurred: {exc}\",\n            },\n            indent=4\n        ),\n        \"event_name\": \"🚨 Internal Server Error\",\n    }\n\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.post(TELEX_WEBHOOK_URL, json=error_data)\n            response.raise_for_status()\n        except httpx.HTTPStatusError as http_err:\n            logger.error(f\"Telex API returned an error: {http_err.response.status_code} - {http_err.response.text}\")\n        except Exception as e:\n            logger.exception(f\"Failed to send error log to Telex: {e}\")\n"}
{"type": "source_file", "path": "api/v1/models/invitation.py", "content": "from sqlalchemy import Column, String, ForeignKey, Boolean, DateTime\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass Invitation(BaseTableModel):\n    __tablename__ = \"invitations\"\n\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    organisation_id = Column(\n        String, ForeignKey(\"organisations.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    expires_at = Column(DateTime(timezone=True), nullable=False)\n    is_valid = Column(Boolean, default=True)\n\n    user = relationship(\"User\", back_populates=\"invitations\")\n    organisation = relationship(\"Organisation\", back_populates=\"invitations\")\n"}
{"type": "source_file", "path": "api/v1/models/contact_us.py", "content": "from sqlalchemy import Column, String, Text, ForeignKey\nfrom sqlalchemy.sql import func\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass ContactUs(BaseTableModel):\n    __tablename__ = \"contact_us\"\n\n    full_name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\n    title = Column(String, nullable=False)\n    message = Column(Text, nullable=False)\n    org_id = Column(String, ForeignKey('organisations.id', ondelete=\"CASCADE\"), nullable=True)\n\n    organisation = relationship(\"Organisation\", back_populates=\"contact_us\")"}
{"type": "source_file", "path": "api/db/Storage.py", "content": "from fastapi import HTTPException, status\nfrom typing import Optional, List\nfrom api.db.database import SessionLocal as SessionMaker, engine, Base\nfrom enum import Enum as Pyenum\nimport sys\nfrom sqlalchemy import  text, desc, asc, or_, and_,  cast, Date, text\nfrom sqlalchemy.orm import joinedload\n\n\nimport logging as logger\nfrom enum import Enum\n\n\nlogger.basicConfig(\n    level=logger.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nclass APP_INIT(Enum):\n\tDATABASE = \"DATABASE_INIT\"\n\n          \n\nclass SortEnum(Pyenum):\n    asc=\"asc\"\n    desc=\"desc\"\n\nclass DB:\n    # ------------------ SYSTEM -----------------\n    def __init__(self):\n        self.session = None\n\n    def connect(self):\n        try:\n            if not self.session:\n                self.session = SessionMaker()\n                self.session.execute(text('SELECT 1'))\n                logger.info(\"[SUCCESS]\", extra={\n                    \"operation\": str(APP_INIT.DATABASE),\n                    \"success\": \"DB CONNECT SUCCESS\"\n                })\n            return self.session\n        except Exception as e:\n            logger.info(\"[ERROR]\", extra={\n                    \"operation\": str(APP_INIT.DATABASE),\n                    \"error\": str(e)\n                })\n            sys.exit(1)\n\n    def createAllTables(self):\n        Base.metadata.create_all(engine)\n        logger.info(\"[SUCCESS]\", extra={\n                    \"operation\": str(APP_INIT.DATABASE),\n                    \"success\": \"DB TABLE CREATED\"\n                })\n    \n    def teardown(self):\n        if self.session:\n            self.session.close()\n    \n    def query(self, *args, **kwargs):\n        return self.session.query(*args, **kwargs)\n\n    # --------------------- CRUD ---------------------\n    def create(self, model_class, **data):\n        \"\"\"Dynamically creates a new record in the database.\"\"\"\n        try:\n            instance = model_class(**data)\n            self.session.add(instance)\n            self.session.commit()\n            self.session.refresh(instance)\n            return instance\n        except Exception as e:\n            self.session.rollback()\n            logger.error(\"[ERROR]\", extra={\n                \"operation\": str(APP_INIT.DATABASE),\n                \"error\": f\"DB CREATE ERROR: {str(e)}\"\n            })\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f\"Failed to create {model_class.__name__} invalid request\")\n\n    def read(self, model_class, join_loads=None, **filters):\n        \"\"\"Dynamically retrieves a record from the database with optional joined loads.\"\"\"\n        try:\n            query = self._build_query(model_class, **filters)\n    \n            if join_loads:\n                for relation in join_loads:\n                    query = query.options(joinedload(getattr(model_class, relation)))\n    \n            result = query.first()\n\n            if not result:\n                raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"No {model_class.__name__} found with given filters.\")\n            return result\n        except HTTPException as http_exc:\n            raise http_exc\n        except Exception as e:\n            self.session.rollback()\n            logger.error(\"[ERROR]\", extra={\n                \"operation\": str(APP_INIT.DATABASE),\n                \"error\": f\"DB READ ERROR: {str(e)}\"\n            })\n            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Error while reading from the database.\")\n\n    def update(self, model_class, filter_conditions: dict, update_values: dict) -> bool:\n        \"\"\"Dynamically updates a record in the database.\"\"\"\n        try:\n            query = self._build_query(model_class, **filter_conditions)\n            result = query.update(update_values)\n            if result == 0:\n                raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f\"No {model_class.__name__} found to update.\")\n            self.session.commit()\n            return True\n        except HTTPException as http_exc:\n            raise http_exc\n        except Exception as e:\n            self.session.rollback()\n            logger.error(\"[ERROR]\", extra={\n                \"operation\": str(APP_INIT.DATABASE),\n                \"error\": f\"DB UPDATE ERROR: {str(e)}\"\n            })\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f\"Error while updating the record for {model_class.__name__} found with given filters.\")\n\n    def delete(self, model_class, **filters) -> bool:\n        \"\"\"Dynamically deletes a record from the database.\"\"\"\n        try:\n            query = self._build_query(model_class, **filters)\n            result = query.delete()\n            self.session.commit()\n\n            if result == 0:\n                raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f\"No {model_class.__name__} found to delete.\")\n            return True\n        except HTTPException as http_exc:\n            raise http_exc\n\n        except Exception as e:\n            self.session.rollback()\n            logger.error(\"[ERROR]\", extra={\n                \"operation\": str(APP_INIT.DATABASE),\n                \"error\": f\"DB DELETE ERROR: {str(e)}\"\n            })\n            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Error while deleting the record.\")\n\n    # --------------------- BULK OPERATIONS ---------------------\n    def bulk_create(self, model_class, data_list: List[dict], **kwargs):\n        \"\"\"Bulk creates new records in the database.\"\"\"\n        try:\n            instances = [model_class(**data) for data in data_list]\n            self.session.bulk_save_objects(instances)\n            self.session.commit()\n            return instances\n        except Exception as e:\n            self.session.rollback()\n            logger.error(\"[ERROR]\", extra={\n                \"operation\": str(APP_INIT.DATABASE),\n                \"error\": f\"DB BULK CREATE ERROR: {str(e)}\"\n            })\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f\"Failed to bulk create {model_class.__name__}\")\n\n    def bulk_read(self, model_class, \n              filters: Optional[dict] = None, \n              sort_column: str = None,\n              sort_direction: str  = None,\n              limit: int = 0, \n              offset: int = 0,\n              join_loads: Optional[List[str]] = None, \n              date_filters: Optional[dict] = None,  # New argument for date filtering\n             ) -> List[dict]:\n        \"\"\"\n        Bulk retrieves records from the database with support for limit, offset, sorting, filtering, and join loading.\n\n        :param model_class: The SQLAlchemy model class.\n        :param filters: A dictionary of filters to apply.\n        :param order_by: A list of fields to order by. Use '-' prefix for descending order (e.g., '-created_at').\n        :param limit: The number of records to retrieve.\n        :param offset: The starting offset for the query.\n        :param join_loads: A list of relationships to eagerly load.\n        :param date_filters: A dictionary of date filters (field names as keys and date values).\n        :return: A list of dictionaries representing the retrieved records.\n        \"\"\"\n        try:\n            # Start building the query with or without filters\n            query = self._build_query(model_class, join_loads=join_loads, **filters) if filters else self.session.query(model_class)\n            \n            # Apply join loading if provided\n            if join_loads:\n                for relation in join_loads:\n                    query = query.options(joinedload(getattr(model_class, relation)))\n            \n            # Apply date filters\n            if date_filters:\n                for date_field, date_value in date_filters.items():\n                    query = query.filter(cast(getattr(model_class, date_field), Date) == date_value)\n\n            # Apply ordering\n            if sort_column and sort_direction:\n                if sort_direction == \"desc\":\n                    query = query.order_by(desc(getattr(model_class, sort_column)))    \n                else:\n                    query = query.order_by(asc(getattr(model_class, sort_column)))\n            \n            # Apply limit and offset\n            if limit > 0:\n                query = query.limit(limit).offset(offset)\n            \n            # Execute the query and return results\n            results = query.all()\n            return results\n        \n        except Exception as e:\n            logger.error(\"[ERROR]\", extra={\n                \"operation\": str(APP_INIT.DATABASE),\n                \"error\": f\"DB BULK READ ERROR: {str(e)}\"\n            })\n            self.session.rollback()\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f\"Invalid Request filter for {model_class.__name__}.\")\n\n\n\n    def bulk_update(self, model_class, filter_conditions: dict, update_values: dict) -> bool:\n        \"\"\"Bulk updates records in the database.\"\"\"\n        try:\n            query = self._build_query(model_class, **filter_conditions)\n            query.update(update_values, synchronize_session=False)\n            self.session.commit()\n            return True\n        except Exception as e:\n            self.session.rollback()\n            logger.error(\"[ERROR]\", extra={\n                \"operation\": str(APP_INIT.DATABASE),\n                \"error\": f\"DB BULK UPDATE ERROR: {str(e)}\"\n            })\n            return False\n\n    def bulk_delete(self, model_class, **filters) -> bool:\n        \"\"\"Bulk deletes records from the database.\"\"\"\n        try:\n            query = self._build_query(model_class, **filters)\n            result = query.delete(synchronize_session=False)\n            self.session.commit()\n            if result == 0:\n                raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f\"No {model_class.__name__} records found to delete.\")\n            return True\n        except Exception as e:\n            self.session.rollback()\n            logger.error(\"[ERROR]\", extra={\n                \"operation\": str(APP_INIT.DATABASE),\n                \"error\": f\"DB BULK DELETE ERROR: {str(e)}\"\n            })\n            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Error while bulk deleting the records.\")\n\n    def read_with_join(self, primary_model, related_model, primary_key, related_key, \n                       filters: Optional[dict] = None, \n                       related_filters: Optional[dict] = None, join_loads=[]) -> dict:\n        \"\"\"\n        Reads a record from the primary model and joins it with a related model.\n\n        :param primary_model: The primary SQLAlchemy model class.\n        :param related_model: The related SQLAlchemy model class to join with.\n        :param primary_key: The foreign key in the primary model.\n        :param related_key: The key in the related model to join on.\n        :param filters: Filters to apply on the primary model.\n        :param related_filters: Filters to apply on the related model.\n        :return: A dictionary representing the joined records.\n        \"\"\"\n        try:\n            query = self._build_query(primary_model, **filters) if filters else self.session.query(primary_model)\n            query = query.join(related_model, getattr(primary_model, primary_key) == getattr(related_model, related_key))\n\n            if related_filters:\n                for key, value in related_filters.items():\n                    query = query.filter(getattr(related_model, key) == value)\n            \n            result = query.first()\n            if result:\n                return self.to_dict(result, include_relationships=True, relationships_to_include=join_loads)\n            return None\n\n        except Exception as e:\n            logger.error(\"[ERROR]\", extra={\n                \"operation\": str(APP_INIT.DATABASE),\n                \"error\": f\"DB READ WITH JOIN ERROR: {str(e)}\"\n            })\n            return False\n\n\n    # --------------------- HELPER METHODS ---------------------\n\n    def _build_query(self, model_class, join_loads=None, **filters):\n        \"\"\"Dynamically builds a query based on the provided model and filters.\"\"\"\n        query = self.session.query(model_class)\n        if join_loads:\n            for relation in join_loads:\n                query = query.options(joinedload(getattr(model_class, relation)))\n\n\n        for key, value in filters.items():\n            column_attr = getattr(model_class, key)\n\n            if isinstance(value, list):\n                for condition in value:\n                    if isinstance(condition, dict):\n                        for operator, filter_value in condition.items():\n                            query = self._apply_filter(query, column_attr, operator, filter_value)\n\n            elif isinstance(value, dict):\n                for operator, filter_value in value.items():\n                    query = self._apply_filter(query, column_attr, operator, filter_value)\n            else:\n                query = query.filter(column_attr == value)\n\n        return query\n\n    def _apply_filter(self, query, column_attr, operator, filter_value):\n        \"\"\"Applies the corresponding SQLAlchemy filter based on the operator.\"\"\"\n        if operator == \"$gte\":  # Greater than or equal\n            return query.filter(column_attr >= filter_value)\n        elif operator == \"$gt\":  # Greater than\n            return query.filter(column_attr > filter_value)\n        elif operator == \"$lte\":  # Less than or equal\n            return query.filter(column_attr <= filter_value)\n        elif operator == \"$lt\":  # Less than\n            return query.filter(column_attr < filter_value)\n        elif operator == \"$eq\":  # Equal\n            return query.filter(column_attr == filter_value)\n        elif operator == \"$ne\":  # Not equal\n            return query.filter(column_attr != filter_value)\n        elif operator == \"$in\" and filter_value:  # In a list of values\n            return query.filter(column_attr.in_(filter_value))\n        elif operator == \"$not_in\" and filter_value:  # Not in a list of values\n            return query.filter(~column_attr.in_(filter_value))\n        elif operator == \"$like\":  # LIKE query\n            return query.filter(column_attr.like(f\"%{filter_value}%\"))\n        elif operator == \"$not_like\":  # NOT LIKE query\n            return query.filter(~column_attr.like(f\"%{filter_value}%\"))\n        elif operator == \"$or\":  # OR condition\n            conditions = [getattr(column_attr, k) == v for k, v in filter_value.items()]\n            return query.filter(or_(*conditions))\n        elif operator == \"$and\":  # AND condition\n            conditions = [getattr(column_attr, k) == v for k, v in filter_value.items()]\n            return query.filter(and_(*conditions))\n        else:\n            raise ValueError(f\"Unsupported filter operator: {operator}\")\n        \n\ndef get_db():\n    db = DB()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"type": "source_file", "path": "api/v1/models/blog.py", "content": "#!/usr/bin/env python3\n\"\"\"The Blog Post Model.\"\"\"\n\nfrom sqlalchemy import Column, String, Text, ForeignKey, Boolean, text, Index, Integer\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass Blog(BaseTableModel):\n    __tablename__ = \"blogs\"\n\n    author_id = Column(\n        String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    title = Column(String, nullable=False)\n    content = Column(Text, nullable=False)\n    image_url = Column(String, nullable=True)\n    is_deleted = Column(Boolean, server_default=text(\"false\"))\n    excerpt = Column(Text, nullable=True)\n    tags = Column(\n        Text, nullable=True\n    )  # Assuming tags are stored as a comma-separated string\n\n    author = relationship(\"User\", back_populates=\"blogs\")\n    comments = relationship(\n        \"Comment\", back_populates=\"blog\", cascade=\"all, delete-orphan\"\n    )\n    likes = relationship(\n        \"BlogLike\", back_populates=\"blog\", cascade=\"all, delete-orphan\"\n    )\n    dislikes = relationship(\n        \"BlogDislike\", back_populates=\"blog\", cascade=\"all, delete-orphan\"\n    )\n    views = Column(Integer, nullable=False, server_default=text(\"0\"))  # add views column to track views\n\n    # Indexes\n    __table_args__ = (\n        Index('ix_blogs_author_id', author_id),\n        Index('ix_blogs_title', title),\n        Index('ix_blogs_tags', tags),\n        Index('ix_blogs_is_deleted', is_deleted),\n    )\n\nclass BlogDislike(BaseTableModel):\n    __tablename__ = \"blog_dislikes\"\n\n    blog_id = Column(String, ForeignKey(\"blogs.id\", ondelete=\"CASCADE\"), nullable=False)\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    ip_address = Column(String, nullable=True)\n\n    # Relationships\n    blog = relationship(\"Blog\", back_populates=\"dislikes\")\n    user = relationship(\"User\", back_populates=\"blog_dislikes\")\n\n    # Indexes\n    __table_args__ = (\n        Index('ix_blog_dislikes_blog_id', blog_id),\n        Index('ix_blog_dislikes_user_id', user_id),\n        # Composite index for unique constraint and faster lookups\n        Index('ix_blog_dislikes_blog_user', blog_id, user_id, unique=True),\n    )\n\n\nclass BlogLike(BaseTableModel):\n    __tablename__ = \"blog_likes\"\n\n    blog_id = Column(String, ForeignKey(\"blogs.id\", ondelete=\"CASCADE\"), nullable=False)\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    ip_address = Column(String, nullable=True)\n\n    blog = relationship(\"Blog\", back_populates=\"likes\")\n    user = relationship(\"User\", back_populates=\"blog_likes\")\n\n    # Indexes\n    __table_args__ = (\n        Index('ix_blog_likes_blog_id', blog_id),\n        Index('ix_blog_likes_user_id', user_id),\n        # Composite index for unique constraint and faster lookups\n        Index('ix_blog_likes_blog_user', blog_id, user_id, unique=True),\n    )\n"}
{"type": "source_file", "path": "api/v1/models/associations.py", "content": "\"\"\" Associations\n\"\"\"\nfrom sqlalchemy import (\n        Column,\n        ForeignKey,\n        String,\n        Table,\n        Enum\n    )\nfrom api.db.database import Base\n\n\nuser_organisation_association = Table(\n    \"user_organisation\",\n    Base.metadata,\n    Column(\n        \"user_id\", String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), primary_key=True\n    ),\n    Column(\n        \"organisation_id\",\n        String,\n        ForeignKey(\"organisations.id\", ondelete=\"CASCADE\"),\n        primary_key=True,\n    ),\n    Column(\n        \"role\",\n        Enum(\"admin\", \"user\", \"guest\", \"owner\", name=\"user_org_role\"),\n        nullable=False,\n        default=\"user\",\n    ),\n    Column(\n        \"status\",\n        Enum(\"member\", \"suspended\", \"left\", name=\"user_org_status\"),\n        nullable=False,\n        default=\"member\",\n    ),\n)\n"}
{"type": "source_file", "path": "api/db/__init__.py", "content": ""}
{"type": "source_file", "path": "api/v1/models/comment.py", "content": "from datetime import datetime, timezone\nfrom sqlalchemy import Column, String, Text, ForeignKey, DateTime\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\nUTC = timezone.utc\n\nclass Comment(BaseTableModel):\n    __tablename__ = \"comments\"\n\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    blog_id = Column(String, ForeignKey(\"blogs.id\", ondelete=\"CASCADE\"), nullable=False)\n    content = Column(Text, nullable=False)\n\n    user = relationship(\"User\", back_populates=\"comments\")\n    blog = relationship(\"Blog\", back_populates=\"comments\")\n    likes = relationship(\n        \"CommentLike\", back_populates=\"comment\", cascade=\"all, delete-orphan\"\n    )\n    dislikes = relationship(\n        \"CommentDislike\", back_populates=\"comment\", cascade=\"all, delete-orphan\"\n    )\n    replies = relationship(\n        \"Reply\", back_populates=\"comment\", cascade=\"all, delete-orphan\"\n    )\n\n\nclass CommentLike(BaseTableModel):\n    __tablename__ = \"comment_likes\"\n\n    comment_id = Column(\n        String, ForeignKey(\"comments.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    ip_address = Column(String, nullable=True)\n\n    comment = relationship(\"Comment\", back_populates=\"likes\")\n    user = relationship(\"User\", back_populates=\"comment_likes\")\n\n\nclass CommentDislike(BaseTableModel):\n    __tablename__ = \"comment_dislikes\"\n\n    comment_id = Column(\n        String, ForeignKey(\"comments.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    ip_address = Column(String, nullable=True)\n\n    comment = relationship(\"Comment\", back_populates=\"dislikes\")\n    user = relationship(\"User\", back_populates=\"comment_dislikes\")\n\nclass Reply(BaseTableModel):\n    __tablename__ = \"comment_replies\"\n\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    comment_id = Column(String, ForeignKey(\"comments.id\", ondelete=\"CASCADE\"), nullable=False)\n    content = Column(Text, nullable=False)\n    created_at = Column(DateTime, default=lambda: datetime.now(UTC), nullable=False)\n\n    user = relationship(\"User\", back_populates=\"comment_replies\")\n    comment = relationship(\"Comment\", back_populates=\"replies\")\n"}
{"type": "source_file", "path": "api/v1/models/faq_inquiries.py", "content": "from sqlalchemy import Column, String, Text\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass FAQInquiries(BaseTableModel):\n    __tablename__ = \"faq_inquiries\"\n\n    email = Column(String, nullable=False)\n    full_name = Column(String, nullable=False)\n    message = Column(Text, nullable=False)\n"}
{"type": "source_file", "path": "api/utils/send_mail.py", "content": "import smtplib\r\nfrom email.mime.text import MIMEText\r\nfrom email.mime.multipart import MIMEMultipart\r\nfrom api.utils.settings import settings\r\n\r\n\r\nasync def send_magic_link(context: dict):\r\n    \"\"\"Sends magic-kink to user email\"\"\"\r\n    from main import email_templates\r\n    sender_email = settings.MAIL_USERNAME\r\n    receiver_email = context.get('email')\r\n    password = settings.MAIL_PASSWORD\r\n    \r\n    html = email_templates.get_template(\"signin.html\").render(context)\r\n\r\n    message = MIMEMultipart(\"alternative\")\r\n    message[\"Subject\"] = \"Your Magic Link\"\r\n    message[\"From\"] = sender_email\r\n    message[\"To\"] = receiver_email\r\n    \r\n    part = MIMEText(html, \"html\")\r\n\r\n    message.attach(part)\r\n\r\n    with smtplib.SMTP_SSL(settings.MAIL_SERVER, settings.MAIL_PORT) as server:\r\n        server.login(sender_email, password)\r\n        server.sendmail(sender_email, receiver_email, message.as_string())\r\n\r\n\r\nasync def send_contact_mail(context: dict):\r\n    \"\"\"Sends user contact to admin mail\r\n\r\n    Args:\r\n        context (dict): Holds data for sending email, such as 'name', 'email', and 'message'.\r\n    \"\"\"\r\n    from main import email_templates\r\n    sender_email = settings.MAIL_FROM\r\n    admin_email = settings.MAIL_USERNAME\r\n    user_email = context.get('email')\r\n\r\n    admin_html = email_templates.get_template(\"contact_us.html\").render(context)\r\n    customer_html = email_templates.get_template(\"email_feedback.html\").render(context)\r\n\r\n    send_mail_handler(sender_email, admin_email, admin_html, \"New Contact Request\")\r\n    send_mail_handler(admin_email, user_email, customer_html, \"Thank you for contacting us\")\r\n\r\n\r\ndef send_mail_handler(sender, reciever, html, subject):\r\n    message = MIMEMultipart(\"alternative\")\r\n    message[\"Subject\"] = subject\r\n    message[\"From\"] = sender\r\n    message[\"To\"] = reciever\r\n\r\n    part = MIMEText(html, \"html\")\r\n\r\n    message.attach(part)\r\n\r\n    with smtplib.SMTP_SSL(settings.MAIL_SERVER, settings.MAIL_PORT) as server:\r\n        server.login(settings.MAIL_USERNAME, settings.MAIL_PASSWORD)\r\n        server.sendmail(sender, reciever, message.as_string())\r\n\r\n\r\ndef send_faq_inquiry_mail(context: dict):\r\n    from main import email_templates\r\n    sender_email = settings.MAIL_USERNAME\r\n    receiver_email = context.get('email')\r\n    password = settings.MAIL_PASSWORD\r\n    \r\n    html = email_templates.get_template(\"faq-feedback.html\").render(context)\r\n\r\n    message = MIMEMultipart(\"alternative\")\r\n    message[\"Subject\"] = \"We've received your inquiry\"\r\n    message[\"From\"] = sender_email\r\n    message[\"To\"] = receiver_email\r\n    \r\n    part = MIMEText(html, \"html\")\r\n\r\n    message.attach(part)\r\n\r\n    with smtplib.SMTP_SSL(settings.MAIL_SERVER, settings.MAIL_PORT) as server:\r\n        server.login(sender_email, password)\r\n        server.sendmail(sender_email, receiver_email, message.as_string())\r\n"}
{"type": "source_file", "path": "api/v1/models/api_status.py", "content": "from sqlalchemy import Column, DateTime, String, Text, Numeric, func\nfrom api.v1.models.base_model import BaseTableModel\n\nclass APIStatus(BaseTableModel):\n    __tablename__ = \"api_status\"\n\n    api_group = Column(String, nullable=False)\n    status = Column(String, nullable=False)\n    last_checked = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())\n    response_time = Column(Numeric, nullable=True)\n    details = Column(Text, nullable=True)\n"}
{"type": "source_file", "path": "api/v1/models/bookmark.py", "content": "#!/usr/bin/python3\n\"\"\"Module for bookmark model\"\"\"\nfrom sqlalchemy import Column, String, Text, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\n\nclass Bookmark(BaseTableModel):\n    __tablename__ = \"bookmarks\"\n\n    user_id = Column(String, ForeignKey(\"users.id\"))\n    job_id = Column(String, ForeignKey(\"jobs.id\"))\n    user = relationship(\n        \"User\", back_populates=\"bookmarks\"\n    )\n    job = relationship(\n        \"Job\", back_populates=\"bookmarks\"\n    )"}
{"type": "source_file", "path": "api/v1/models/__init__.py", "content": "from api.v1.models.activity_logs import ActivityLog\nfrom api.v1.models.api_status import APIStatus\nfrom api.v1.models.billing_plan import BillingPlan\nfrom api.v1.models.comment import Comment, CommentLike, CommentDislike\nfrom api.v1.models.contact_us import ContactUs\nfrom api.v1.models.message import Message\nfrom api.v1.models.payment import Payment\nfrom api.v1.models.waitlist import Waitlist\nfrom api.v1.models.user import User\nfrom api.v1.models.organisation import Organisation\nfrom api.v1.models.profile import Profile\nfrom api.v1.models.notifications import Notification\nfrom api.v1.models.product import ProductVariant, ProductCategory, Product\nfrom api.v1.models.blog import Blog, BlogLike, BlogDislike\nfrom api.v1.models.job import Job, JobApplication\nfrom api.v1.models.testimonial import Testimonial\nfrom api.v1.models.token_login import TokenLogin\nfrom api.v1.models.oauth import OAuth\nfrom api.v1.models.invitation import Invitation\nfrom api.v1.models.faq import FAQ\nfrom api.v1.models.newsletter import Newsletter, NewsletterSubscriber\nfrom api.v1.models.topic import Topic\nfrom api.v1.models.email_template import EmailTemplate\nfrom api.v1.models.regions import Region\nfrom api.v1.models.squeeze import Squeeze\nfrom api.v1.models.sales import Sales\nfrom api.v1.models.team import TeamMember\nfrom api.v1.models.data_privacy import DataPrivacySetting\nfrom api.v1.models.privacy import PrivacyPolicy\nfrom api.v1.models.terms import TermsAndConditions\nfrom api.v1.models.reset_password_token import ResetPasswordToken\nfrom api.v1.models.faq_inquiries import FAQInquiries\nfrom api.v1.models.wishlist import Wishlist\nfrom api.v1.models.totp_device import TOTPDevice\nfrom api.v1.models.bookmark import Bookmark\n\n"}
{"type": "source_file", "path": "api/core/dependencies/google_oauth_config.py", "content": "from decouple import config\nfrom authlib.integrations.starlette_client import OAuth\n\n\ngoogle_oauth = OAuth()\n\n\nCONF_URL = \"https://accounts.google.com/.well-known/openid-configuration\"\n# Register Google OAuth2 client\ngoogle_oauth.register(\n    name=\"google\",\n    client_id=config(\"GOOGLE_CLIENT_ID\"),\n    client_secret=config(\"GOOGLE_CLIENT_SECRET\"),\n    server_metadata_url=CONF_URL,\n    client_kwargs={\n        \"scope\": \"openid email profile\",\n        \"access_type\": \"offline\",\n    },  # request for refresh token\n)\n"}
{"type": "source_file", "path": "api/utils/db_validators.py", "content": "from fastapi import HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom api.v1.models import User, Organisation\n\n\ndef check_model_existence(db: Session, model, id):\n    \"\"\"Checks if a model exists by its id\"\"\"\n\n    # obj = db.query(model).filter(model.id == id).first()\n    obj = db.get(model, ident=id)\n\n    if not obj:\n        raise HTTPException(status_code=404, detail=f\"{model.__name__} does not exist\")\n\n    return obj\n\n\ndef check_user_in_org(user: User, organisation: Organisation):\n    \"\"\"Checks if a user is a member of an organisation\"\"\"\n\n    if user not in organisation.users and not user.is_superadmin:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"You are not a member of this organisation\",\n        )\n"}
{"type": "source_file", "path": "api/v1/models/faq.py", "content": "from sqlalchemy import Column, String, Text\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass FAQ(BaseTableModel):\n    __tablename__ = \"faqs\"\n\n    question = Column(String, nullable=False)\n    answer = Column(Text, nullable=False)\n    category = Column(String, nullable=True)\n"}
{"type": "source_file", "path": "api/v1/models/job.py", "content": "#!/usr/bin/env python3\n\"\"\" The Job Model Class\n\"\"\"\nfrom sqlalchemy import Column, String, Text, ForeignKey, Enum\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass Job(BaseTableModel):\n    __tablename__ = \"jobs\"\n\n    author_id = Column(\n        String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    title = Column(Text, nullable=False)\n    description = Column(Text, nullable=False)\n    department = Column(String, nullable=True)\n    location = Column(String, nullable=True)\n    salary = Column(String, nullable=True)\n    job_type = Column(String, nullable=True)\n    company_name = Column(String, nullable=True)\n\n    author = relationship(\"User\", back_populates=\"jobs\")\n    applications = relationship('JobApplication', back_populates='job')\n    bookmarks = relationship(\"Bookmark\", back_populates=\"job\", cascade=\"delete\")\n\n\nclass JobApplication(BaseTableModel):\n    __tablename__ = \"job_applications\"\n\n    job_id = Column(\n        String, ForeignKey(\"jobs.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    applicant_name = Column(String, nullable=False)\n    applicant_email = Column(String, nullable=False)\n    cover_letter = Column(Text, nullable=True)\n    resume_link = Column(String, nullable=False)\n    portfolio_link = Column(String, nullable=True)\n    application_status = Column(Enum('pending', 'accepted', 'rejected', name='application_status'), default=\"pending\")\n\n    job = relationship('Job', back_populates='applications')\n"}
{"type": "source_file", "path": "api/v1/models/email_template.py", "content": "from sqlalchemy import Boolean, Column, Text, String, Enum\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass EmailTemplate(BaseTableModel):\n    __tablename__ = \"email_templates\"\n\n    title = Column(Text, nullable=False)\n    template = Column(Text, nullable=False)\n    type = Column(String, nullable=False)\n    template_status = Column(Enum('online', 'offline', name='template_status'), server_default='online')\n"}
{"type": "source_file", "path": "api/utils/json_response.py", "content": "#!/usr/bin/env python3\n\"\"\" This module contains the Json response class \"\"\"\nfrom enum import Enum\nfrom json import dumps\nfrom fastapi import status\nfrom fastapi.responses import JSONResponse\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseModel\nfrom typing import Any, Dict, Optional\n\nclass JsonResponseDict(JSONResponse):\n\n    def __init__(\n        self, message: str, data: Optional[Dict[str, Any]] = None, error: str = \"\", status_code: int = 200\n    ):\n        \"\"\"Initialize your response\"\"\"\n        self.message = message\n        self.data = data\n        self.error = error\n        self.status_code = status_code\n        super().__init__(\n            content=jsonable_encoder(self.response()), status_code=status_code\n        )\n\n    def __repr__(self):\n        return str({\n            \"message\": self.message,\n            \"data\": self.data,\n            \"error\": self.error,\n            \"status_code\": self.status_code,\n        })\n\n    def __str__(self):\n        \"\"\"String representation\"\"\"\n        return dumps(\n            {\n                \"message\": self.message,\n                \"data\": self.data,\n                \"error\": self.error,\n                \"status_code\": self.status_code,\n            }\n        )\n\n    def response(self):\n        \"\"\"Return a json response dictionary\"\"\"\n        if self.status_code < 300:\n            return {\n                \"message\": self.message,\n                \"data\": self.data,\n                \"status_code\": self.status_code,\n            }\n        else:\n            return {\n                \"message\": self.message,\n                \"error\": self.error,\n                \"status_code\": self.status_code,\n            }\n\n\"\"\"\nusage:\n\nreturn JsonResponseDict(\n            message=\"Job creation successful\",\n            data={\"job\": new_job.to_dict()},\n            status_code=status.HTTP_201_CREATED\n        )\n\"\"\"\n"}
{"type": "source_file", "path": "api/v1/models/data_privacy.py", "content": "from sqlalchemy import Column, String, ForeignKey, Boolean\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass DataPrivacySetting(BaseTableModel):\n    __tablename__ = \"data_privacy_settings\"\n\n    profile_visibility = Column(Boolean, server_default='true')\n    share_data_with_partners = Column(Boolean, server_default='false')\n    receice_email_updates = Column(Boolean, server_default='true')\n    enable_two_factor_authentication = Column(Boolean, server_default='false')\n    use_data_encryption = Column(Boolean, server_default='true')\n    allow_analytics = Column(Boolean, server_default='true')\n    personalized_ads = Column(Boolean, server_default='false')\n\n    user_id = Column(String, ForeignKey('users.id', ondelete=\"CASCADE\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"data_privacy_setting\")\n"}
{"type": "source_file", "path": "api/v1/models/base_model.py", "content": "#!/usr/bin/env python3\n\"\"\" This is the Base Model Class\n\"\"\"\nfrom uuid_extensions import uuid7\nfrom fastapi import Depends\nfrom api.v1.models.associations import Base\nfrom sqlalchemy import (\n    Column,\n    String,\n    DateTime,\n    func\n)\n\nclass BaseTableModel(Base):\n    \"\"\"This model creates helper methods for all models\"\"\"\n\n    __abstract__ = True\n\n    id = Column(String, primary_key=True, index=True, default=lambda: str(uuid7()))\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(\n        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()\n    )\n\n    def to_dict(self):\n        \"\"\"returns a dictionary representation of the instance\"\"\"\n        obj_dict = self.__dict__.copy()\n        del obj_dict[\"_sa_instance_state\"]\n        obj_dict[\"id\"] = self.id\n        if self.created_at:\n            obj_dict[\"created_at\"] = self.created_at.isoformat()\n        if self.updated_at:\n            obj_dict[\"updated_at\"] = self.updated_at.isoformat()\n        return obj_dict\n\n    @classmethod\n    def get_all(cls):\n        from api.db.database import get_db\n\n        db = Depends(get_db)\n        \"\"\" returns all instance of the class in the db\n        \"\"\"\n        return db.query(cls).all()\n\n    @classmethod\n    def get_by_id(cls, id):\n        from api.db.database import get_db\n\n        db = Depends(get_db)\n        \"\"\" returns a single object from the db\n        \"\"\"\n        obj = db.query(cls).filter_by(id=id).first()\n        return obj\n"}
{"type": "source_file", "path": "api/utils/dependencies.py", "content": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom sqlalchemy.orm import Session\nimport jwt\nfrom jwt import PyJWTError\nfrom datetime import datetime, timedelta\nfrom api.v1.models.user import User\nfrom api.v1.schemas.token import TokenData\nfrom api.db.database import get_db\nfrom .config import SECRET_KEY, ALGORITHM\n\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/login\")\n\n\ndef get_current_user(\n    db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)\n):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        logger.debug(\"Decoding JWT token\")\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id: str = payload.get(\"user_id\")\n        if user_id is None:\n            logger.error(\"User ID not found in token\")\n            raise credentials_exception\n        logger.debug(f\"Token decoded successfully, user ID: {user_id}\")\n    except PyJWTError as e:\n        logger.error(f\"JWT error: {e}\")\n        raise credentials_exception\n\n    user = db.query(User).filter(User.id == user_id).first()\n    if user is None:\n        logger.error(\"User not found\")\n        raise credentials_exception\n    logger.debug(f\"User found: {user}\")\n    return user\n\n\ndef get_super_admin(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)):\n    user = get_current_user(db, token)\n    if not user.is_superadmin:\n        logger.error(\"User is not a super admin\")\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"You do not have permission to access this resource\",\n        )\n    logger.debug(\"User is super admin\")\n    return user\n"}
{"type": "source_file", "path": "api/v1/models/permissions/__init__.py", "content": ""}
{"type": "source_file", "path": "api/v1/models/message.py", "content": "\nfrom sqlalchemy import Column, String, Text, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass Message(BaseTableModel):\n    __tablename__ = \"messages\"\n\n    message = Column(Text, nullable=False)\n    phone_number = Column(String, nullable=True)\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n\n    user = relationship(\"User\", back_populates=\"messages\")\n"}
{"type": "source_file", "path": "api/v1/models/organisation.py", "content": "\n\"\"\" The Organisation model\n\"\"\"\nfrom sqlalchemy import Column, String\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.permissions.user_org_role import user_organisation_roles\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass Organisation(BaseTableModel):\n    __tablename__ = \"organisations\"\n\n    name = Column(String, nullable=False, unique=False)\n    email = Column(String, nullable=True, unique=True)\n    industry = Column(String, nullable=True)\n    type = Column(String, nullable=True)\n    description = Column(String, nullable=True)\n    country = Column(String, nullable=True)\n    state = Column(String, nullable=True)\n    address = Column(String, nullable=True)\n\n    users = relationship(\n        \"User\", secondary=user_organisation_roles, back_populates=\"organisations\"\n    )\n    billing_plans = relationship(\"BillingPlan\", back_populates=\"organisation\", cascade=\"all, delete-orphan\")\n    invitations = relationship(\"Invitation\", back_populates=\"organisation\", cascade=\"all, delete-orphan\")\n    products = relationship(\"Product\", back_populates=\"organisation\", cascade=\"all, delete-orphan\")\n    contact_us = relationship(\"ContactUs\", back_populates=\"organisation\", cascade=\"all, delete-orphan\")\n    \n    user_subscriptions = relationship(\"UserSubscription\", back_populates=\"organisation\", cascade=\"all, delete-orphan\")\n    sales = relationship('Sales', back_populates='organisation', cascade='all, delete-orphan')\n\n    def __str__(self):\n        return self.name\n"}
{"type": "source_file", "path": "api/v1/models/payment.py", "content": "from sqlalchemy import Column, String, ForeignKey, Numeric\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass Payment(BaseTableModel):\n    __tablename__ = \"payments\"\n\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    amount = Column(Numeric, nullable=False)\n    currency = Column(String, nullable=False)\n    status = Column(String, nullable=False)  # e.g., completed, pending\n    method = Column(String, nullable=False)  # e.g., credit card, PayPal\n    transaction_id = Column(String, unique=True, nullable=False)\n\n    user = relationship(\"User\", back_populates=\"payments\")\n    sales = relationship(\"Sales\", back_populates=\"payment\")\n"}
{"type": "source_file", "path": "api/v1/models/newsletter.py", "content": "from datetime import datetime\nfrom sqlalchemy import Column, String, Text, ForeignKey, UniqueConstraint, DateTime\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass Newsletter(BaseTableModel):\n    __tablename__ = \"newsletters\"\n\n    title: Mapped[str] = mapped_column(String(100), nullable=False)\n    description: Mapped[str | None] = mapped_column(Text, nullable=True)\n    content: Mapped[str | None] = mapped_column(Text, nullable=True)\n\n    newsletter_subscribers: Mapped[list[\"NewsletterSubscriber\"]] = relationship(\n        back_populates=\"newsletter\"\n    )\n\n\nclass NewsletterSubscriber(BaseTableModel):\n    __tablename__ = \"newsletter_subscribers\"\n\n    email: Mapped[str] = mapped_column(String(120), nullable=False)\n    newsletter_id: Mapped[str] = mapped_column(\n        ForeignKey(\"newsletters.id\"), nullable=True\n    )\n\n    subscribed_at: Mapped[datetime] = mapped_column(\n        DateTime, default=datetime.utcnow, nullable=False\n    )\n\n    newsletter: Mapped[\"Newsletter\"] = relationship(\n        back_populates=\"newsletter_subscribers\"\n    )\n\n    __table_args__ = (\n        UniqueConstraint(\"email\", \"newsletter_id\", name=\"uq_subscriber_newsletter\"),\n    )\n"}
{"type": "source_file", "path": "api/v1/models/oauth.py", "content": "from sqlalchemy import Column, String, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass OAuth(BaseTableModel):\n    __tablename__ = \"oauth\"\n\n    user_id = Column(\n        String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), unique=True, nullable=False\n    )\n    provider = Column(String, nullable=False)\n    sub = Column(String, nullable=False)\n    access_token = Column(String, nullable=True)\n    refresh_token = Column(String, nullable=True)\n\n    user = relationship(\"User\", back_populates=\"oauth\")\n"}
{"type": "source_file", "path": "api/v1/models/notifications.py", "content": "from sqlalchemy import Column, String, Text, ForeignKey, Boolean\nfrom sqlalchemy.orm import relationship\nfrom api.v1.models.base_model import BaseTableModel\n\n\nclass Notification(BaseTableModel):\n    __tablename__ = \"notifications\"\n\n    user_id = Column(String, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=True)\n    title = Column(String, nullable=False)\n    message = Column(Text, nullable=False)\n    status = Column(String, default=\"unread\")  # unread, read\n\n    user = relationship(\"User\", back_populates=\"notifications\", primaryjoin=\"Notification.user_id==User.id\", foreign_keys=[user_id])\n\n\nclass NotificationSetting(BaseTableModel):\n    __tablename__ = \"notification_settings\"\n\n    mobile_push_notifications = Column(Boolean, server_default='false')\n    email_notification_activity_in_workspace = Column(Boolean, server_default='false')\n    email_notification_always_send_email_notifications = Column(Boolean, server_default='true')\n    email_notification_email_digest = Column(Boolean, server_default='false')\n    email_notification_announcement_and_update_emails = Column(Boolean, server_default='false')\n    slack_notifications_activity_on_your_workspace = Column(Boolean, server_default='false')\n    slack_notifications_always_send_email_notifications = Column(Boolean, server_default='false')\n    slack_notifications_announcement_and_update_emails = Column(Boolean, server_default='false')\n\n    user_id = Column(String, ForeignKey('users.id', ondelete=\"CASCADE\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"notification_setting\")\n\n"}

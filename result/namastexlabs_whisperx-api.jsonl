{"repo_info": {"repo_name": "whisperx-api", "repo_owner": "namastexlabs", "repo_url": "https://github.com/namastexlabs/whisperx-api"}}
{"type": "test_file", "path": "src/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "src/tests/test_file_utils.py", "content": "import os\nimport tempfile\nfrom unittest.mock import MagicMock, patch\nfrom src.utils.file_utils import (\n    create_directories,\n    save_uploaded_file,\n    convert_to_mp3,\n    read_output_files,\n    zip_files,\n)\n\n\ndef test_create_directories():\n    # Test that the directories are created if they don't exist\n    with tempfile.TemporaryDirectory() as temp_dir:\n        os.chdir(temp_dir)\n        create_directories()\n        assert os.path.exists(\"./temp\")\n        assert os.path.exists(\"./data\")\n\n\ndef test_save_uploaded_file():\n    # Test that the uploaded file is saved correctly\n    with tempfile.TemporaryDirectory() as temp_dir:\n        os.chdir(temp_dir)\n        os.makedirs(\"./temp\")\n        file_mock = MagicMock()\n        file_mock.filename = \"test.mp4\"\n        file_mock.file.read.return_value = b\"file content\"\n        temp_video_path = save_uploaded_file(file_mock)\n        assert os.path.exists(temp_video_path)\n        with open(temp_video_path, \"rb\") as f:\n            assert f.read() == b\"file content\"\n\n\ndef test_convert_to_mp3(mocker):\n    # Test that the video file is converted to MP3 correctly\n    with tempfile.TemporaryDirectory() as temp_dir:\n        os.chdir(temp_dir)\n        # Create a sample video file path\n        video_file_path = \"test.mp4\"\n\n        # Create a sample video file\n        with open(video_file_path, \"wb\") as f:\n            f.write(b\"sample video content\")\n\n        # Mock the subprocess.run function\n        mock_run = mocker.patch(\"subprocess.run\")\n        mock_run.return_value.returncode = 0\n\n        temp_mp3_path = convert_to_mp3(video_file_path)\n\n        assert temp_mp3_path.endswith(\".mp3\")\n\n        # Check if ffmpeg command was called with the correct arguments\n        mock_run.assert_called_once_with(\n            [\"ffmpeg\", \"-y\", \"-i\", video_file_path, temp_mp3_path], check=True\n        )\n\n\ndef test_read_output_files():\n    # Test that the output files are read correctly\n    with tempfile.TemporaryDirectory() as temp_dir:\n        os.chdir(temp_dir)\n        os.makedirs(\"./data\")\n        # Create sample output files\n        with open(\"./data/test.vtt\", \"w\") as f:\n            f.write(\"vtt content\")\n        with open(\"./data/test.txt\", \"w\") as f:\n            f.write(\"txt content\")\n        with open(\"./data/test.json\", \"w\") as f:\n            f.write(\"json content\")\n        with open(\"./data/test.srt\", \"w\") as f:\n            f.write(\"srt content\")\n        output_files = read_output_files(\"test\")\n        assert output_files[\"vtt_content\"] == \"vtt content\"\n        assert output_files[\"txt_content\"] == \"txt content\"\n        assert output_files[\"json_content\"] == \"json content\"\n        assert output_files[\"srt_content\"] == \"srt content\"\n        assert output_files[\"vtt_path\"] == \"test.vtt\"\n        assert output_files[\"txt_path\"] == \"test.txt\"\n        assert output_files[\"json_path\"] == \"test.json\"\n        assert output_files[\"srt_path\"] == \"test.srt\"\n\n\ndef test_zip_files():\n    # Test that the files are zipped correctly\n    with tempfile.TemporaryDirectory() as temp_dir:\n        os.chdir(temp_dir)\n        os.makedirs(\"./data\")\n        # Create sample files\n        with open(\"./data/test.vtt\", \"w\") as f:\n            f.write(\"vtt content\")\n        with open(\"./data/test.txt\", \"w\") as f:\n            f.write(\"txt content\")\n        memory_file = zip_files(\"test.vtt\", \"test.txt\")\n        assert memory_file.getvalue().startswith(\n            b\"PK\"\n        )  # Check if the file starts with a ZIP file signature\n"}
{"type": "test_file", "path": "src/tests/test_auth.py", "content": "import jwt\nimport pytest\nfrom fastapi import HTTPException\nfrom datetime import datetime, timedelta\nfrom src.api.auth import (\n    create_jwt_token,\n    decode_jwt_token,\n    get_current_user,\n    auth,\n    create_user,\n)\nfrom src.api.config import MASTER_KEY, SECRET_KEY\nimport sqlite3\n\n\ndef test_create_jwt_token():\n    data = {\"sub\": \"testuser\"}\n    token = create_jwt_token(data)\n    assert isinstance(token, str)\n\n\ndef test_decode_jwt_token_valid():\n    data = {\"sub\": \"testuser\"}\n    token = create_jwt_token(data)\n    decoded = decode_jwt_token(token)\n    assert decoded[\"sub\"] == \"testuser\"\n\n\ndef test_decode_jwt_token_expired():\n    data = {\"sub\": \"testuser\"}\n    token = create_jwt_token(data)\n\n    # Manually set the expiration time to a past timestamp\n    decoded_token = jwt.decode(token, SECRET_KEY, algorithms=[\"HS256\"])\n    decoded_token[\"exp\"] = datetime.utcnow() - timedelta(days=1)\n    expired_token = jwt.encode(decoded_token, SECRET_KEY, algorithm=\"HS256\")\n\n    with pytest.raises(HTTPException) as exc_info:\n        decode_jwt_token(expired_token)\n    assert exc_info.value.status_code == 401\n    assert exc_info.value.detail == \"Signature has expired\"\n\n\ndef test_decode_jwt_token_invalid():\n    token = \"invalid_token\"\n    with pytest.raises(HTTPException) as exc_info:\n        decode_jwt_token(token)\n    assert exc_info.value.status_code == 401\n    assert exc_info.value.detail == \"Invalid token\"\n\n\n@pytest.mark.asyncio\nasync def test_get_current_user(mocker):\n    mock_credentials = mocker.Mock()\n    mock_credentials.credentials = \"valid_token\"\n\n    mock_get_db = mocker.patch(\"api.auth.get_db\")\n    mock_get_db.return_value = (mocker.Mock(), mocker.Mock())\n    mock_get_db.return_value[1].fetchone.return_value = (\n        \"testuser\",\n        (datetime.utcnow() + timedelta(days=1)).isoformat(),\n    )\n\n    user = await get_current_user(mock_credentials)\n    assert user == {\"username\": \"testuser\"}\n\n\ndef test_auth_valid(mocker):\n    mock_get_db = mocker.patch(\"api.auth.get_db\")\n    mock_get_db.return_value = (mocker.Mock(), mocker.Mock())\n    mock_get_db.return_value[1].fetchone.return_value = (\"password\",)\n\n    result = auth(\"testuser\", \"password\")\n    assert \"access_token\" in result\n    assert result[\"token_type\"] == \"bearer\"\n\n\ndef test_auth_invalid(mocker):\n    mock_get_db = mocker.patch(\"api.auth.get_db\")\n    mock_get_db.return_value = (mocker.Mock(), mocker.Mock())\n    mock_get_db.return_value[1].fetchone.return_value = None\n\n    with pytest.raises(HTTPException) as exc_info:\n        auth(\"testuser\", \"wrongpassword\")\n    assert exc_info.value.status_code == 401\n    assert exc_info.value.detail == \"Invalid username or password\"\n\n\ndef test_create_user_valid(mocker):\n    mock_get_db = mocker.patch(\"api.auth.get_db\")\n    mock_get_db.return_value = (mocker.Mock(), mocker.Mock())\n\n    result = create_user(\"newuser\", \"password\", MASTER_KEY)\n    assert result == {\"detail\": \"User created successfully\"}\n\n\ndef test_create_user_invalid_master_key(mocker):\n    mock_get_db = mocker.patch(\"api.auth.get_db\")\n    mock_get_db.return_value = (mocker.Mock(), mocker.Mock())\n\n    with pytest.raises(HTTPException) as exc_info:\n        create_user(\"newuser\", \"password\", \"invalid_master_key\")\n    assert exc_info.value.status_code == 403\n    assert exc_info.value.detail == \"Not authorized\"\n\n\ndef test_create_user_duplicate_username(mocker):\n    mock_get_db = mocker.patch(\"api.auth.get_db\")\n    mock_get_db.return_value = (mocker.Mock(), mocker.Mock())\n    mock_get_db.return_value[1].execute.side_effect = sqlite3.IntegrityError\n\n    with pytest.raises(HTTPException) as exc_info:\n        create_user(\"existinguser\", \"password\", MASTER_KEY)\n    assert exc_info.value.status_code == 400\n    assert exc_info.value.detail == \"Username already exists\"\n"}
{"type": "test_file", "path": "src/tests/test_database.py", "content": "import sqlite3\nfrom src.api.database import get_db\n\n\ndef test_get_db():\n    conn, cursor = get_db()\n    assert isinstance(conn, sqlite3.Connection)\n    assert isinstance(cursor, sqlite3.Cursor)\n\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='users'\")\n    assert cursor.fetchone()[0] == \"users\"\n\n    conn.close()\n"}
{"type": "test_file", "path": "src/tests/test_main.py", "content": "import os\nimport pytest\nimport sqlite3\nimport logging\nfrom fastapi.testclient import TestClient\nfrom src.api.config import MASTER_KEY\nfrom src.api.main import app, auth\nimport tempfile\n\nclient = TestClient(app)\n\n\n@pytest.fixture(scope=\"module\")\ndef db():\n    with tempfile.TemporaryDirectory() as temp_dir:\n        db_path = os.path.join(temp_dir, \"users.db\")\n        conn = sqlite3.connect(db_path)\n        conn.execute(\"CREATE TABLE IF NOT EXISTS users (username TEXT, password TEXT)\")\n        yield conn\n        conn.close()\n\n\n@pytest.fixture(scope=\"module\")\ndef auth_token(db):\n    cursor = db.cursor()\n    cursor.execute(\n        \"INSERT INTO users (username, password) VALUES (?, ?)\", (\"testuser\", \"testpass\")\n    )\n    db.commit()\n\n    response = client.post(\n        \"/auth\", params={\"username\": \"testuser\", \"password\": \"testpass\"}\n    )\n    return response.json()[\"access_token\"]\n\n\ndef test_read_root():\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"info\": \"WhisperX API\"}\n\n\ndef test_create_user_endpoint(db):\n    response = client.post(\n        \"/create_user\",\n        params={\n            \"master_key\": MASTER_KEY,\n            \"username\": \"testuser\",\n            \"password\": \"testpass\",\n        },\n    )\n    assert response.status_code == 200\n\n\ndef test_auth_endpoint(db):\n    response = auth(\"testuser\", \"testpass\")\n    assert response[\"access_token\"]\n\n\ndef test_create_transcription_job(auth_token):\n    files = {\"file\": open(\"/home/namastex/whisperx-api/data/test.mp4\", \"rb\")}\n    response = client.post(\n        \"/jobs\", files=files, headers={\"Authorization\": f\"Bearer {auth_token}\"}\n    )\n    assert response.status_code == 200\n    assert \"task_id\" in response.json()\n    assert response.json()[\"status\"] == \"PENDING\"\n\n\ndef test_list_jobs(auth_token):\n    response = client.get(\"/jobs\", headers={\"Authorization\": f\"Bearer {auth_token}\"})\n    assert response.status_code == 200\n\n\ndef test_get_job_status(auth_token):\n    files = {\"file\": open(\"/home/namastex/whisperx-api/data/test.mp4\", \"rb\")}\n    create_response = client.post(\n        \"/jobs\", files=files, headers={\"Authorization\": f\"Bearer {auth_token}\"}\n    )\n    task_id = create_response.json()[\"task_id\"]\n\n    response = client.get(\n        f\"/jobs/{task_id}\", headers={\"Authorization\": f\"Bearer {auth_token}\"}\n    )\n    assert response.status_code == 200\n\n\ndef test_stop_job(auth_token):\n    files = {\"file\": open(\"/home/namastex/whisperx-api/data/test.mp4\", \"rb\")}\n    create_response = client.post(\n        \"/jobs\", files=files, headers={\"Authorization\": f\"Bearer {auth_token}\"}\n    )\n    task_id = create_response.json()[\"task_id\"]\n\n    response = client.post(\n        f\"/jobs/{task_id}/stop\", headers={\"Authorization\": f\"Bearer {auth_token}\"}\n    )\n    assert response.status_code == 200\n    assert response.json()[\"status\"] == \"STOPPED\"\n"}
{"type": "test_file", "path": "src/tests/test_tasks.py", "content": "import os\nimport tempfile\nfrom unittest.mock import patch\nfrom api.tasks import transcribe_file\n\ndef test_transcribe_file_success():\n    with tempfile.NamedTemporaryFile(suffix=\".mp4\") as temp_video_file:\n        # Create a temporary video file for testing\n        temp_video_file.write(b\"dummy video content\")\n        temp_video_file.flush()\n\n        with patch(\"api.tasks.convert_to_mp3\") as mock_convert_to_mp3, \\\n             patch(\"api.tasks.run_whisperx\") as mock_run_whisperx, \\\n             patch(\"api.tasks.read_output_files\") as mock_read_output_files:\n            \n            # Mock the behavior of the utility functions\n            mock_convert_to_mp3.return_value = \"temp_audio.mp3\"\n            mock_read_output_files.return_value = {\n                \"vtt_content\": \"dummy vtt content\",\n                \"txt_content\": \"dummy txt content\",\n                \"json_content\": \"dummy json content\", \n                \"srt_content\": \"dummy srt content\",\n                \"vtt_path\": \"output.vtt\",\n                \"txt_path\": \"output.txt\",\n                \"json_path\": \"output.json\",\n                \"srt_path\": \"output.srt\"\n            }\n\n            result = transcribe_file(temp_video_file.name, \"en\", \"base\", 1, 2)\n\n            assert result[\"status\"] == \"success\"\n            assert result[\"vtt_content\"] == \"dummy vtt content\"\n            assert result[\"txt_content\"] == \"dummy txt content\"\n            assert result[\"json_content\"] == \"dummy json content\"\n            assert result[\"srt_content\"] == \"dummy srt content\"\n            assert result[\"vtt_path\"] == \"output.vtt\"\n            assert result[\"txt_path\"] == \"output.txt\" \n            assert result[\"json_path\"] == \"output.json\"\n            assert result[\"srt_path\"] == \"output.srt\"\n\n            mock_convert_to_mp3.assert_called_once_with(temp_video_file.name)\n            mock_run_whisperx.assert_called_once_with(\"temp_audio.mp3\", \"en\", \"base\", 1, 2)\n            mock_read_output_files.assert_called_once()\n\ndef test_transcribe_file_exception():\n    with tempfile.NamedTemporaryFile(suffix=\".mp4\") as temp_video_file:\n        temp_video_file.write(b\"dummy video content\") \n        temp_video_file.flush()\n\n        with patch(\"api.tasks.convert_to_mp3\") as mock_convert_to_mp3:\n            mock_convert_to_mp3.side_effect = Exception(\"Test exception\")\n\n            try:\n                transcribe_file(temp_video_file.name, \"en\", \"base\", 1, 2)\n                assert False, \"Expected an exception to be raised\"\n            except Exception as e:\n                assert str(e) == \"Test exception\""}
{"type": "test_file", "path": "src/tests/test_transcription_utils.py", "content": "import os\nimport tempfile\nfrom unittest.mock import patch\nfrom src.api.config import HF_TOKEN\nfrom src.utils.transcription_utils import run_whisperx\n\n\ndef test_run_whisperx(mocker):\n    # Test that the whisperx command is executed correctly\n    with tempfile.TemporaryDirectory() as temp_dir:\n        os.chdir(temp_dir)\n        os.makedirs(\"./data\")\n        # Create a sample MP3 file\n        with open(\"test.mp3\", \"wb\") as f:\n            f.write(b\"audio content\")\n\n        # Mock the subprocess.run function\n        mock_run = mocker.patch(\"subprocess.run\")\n\n        run_whisperx(\"test.mp3\", \"en\", \"base\", 1, 2)\n\n        expected_cmd = f\"whisperx test.mp3 --model base --language en --hf_token {HF_TOKEN} --output_format all --output_dir ./data/  --align_model WAV2VEC2_ASR_LARGE_LV60K_960H --diarize --min_speakers 1 --max_speakers 2\"\n        mock_run.assert_called_once_with(expected_cmd.split(), check=True)\n"}
{"type": "source_file", "path": "src/api/__init__.py", "content": ""}
{"type": "source_file", "path": "src/__init__.py", "content": ""}
{"type": "source_file", "path": "src/api/tasks.py", "content": "import logging\nimport os\nfrom src.api.config import BROKER_URL\nfrom celery import Celery\nfrom src.utils.file_utils import convert_to_mp3, read_output_files\nfrom src.utils.transcription_utils import run_whisperx\n\ncelery_app = Celery(\n    \"whisperx-tasks\", backend=\"db+sqlite:///celery.db\", broker=BROKER_URL\n)\n\n\n@celery_app.task(name=\"transcribe_file\")\ndef transcribe_file(temp_video_path, lang, model, min_speakers, max_speakers):\n    try:\n        temp_mp3_path = convert_to_mp3(temp_video_path)\n        base_name = os.path.splitext(os.path.basename(temp_mp3_path))[0]\n        run_whisperx(temp_mp3_path, lang, model, min_speakers, max_speakers)\n        output_files = read_output_files(base_name)\n        result = {\n            \"status\": \"success\",\n            \"vtt_content\": output_files[\"vtt_content\"],\n            \"txt_content\": output_files[\"txt_content\"],\n            \"json_content\": output_files[\"json_content\"],\n            \"srt_content\": output_files[\"srt_content\"],\n            \"vtt_path\": output_files[\"vtt_path\"],\n            \"txt_path\": output_files[\"txt_path\"],\n            \"json_path\": output_files[\"json_path\"],\n            \"srt_path\": output_files[\"srt_path\"],\n        }\n        return result\n\n    except Exception as e:\n        logging.error(f\"An error occurred: {str(e)}\")\n        raise e\n"}
{"type": "source_file", "path": "src/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "src/api/models.py", "content": "from enum import Enum\n\nclass LanguageEnum(str, Enum):\n    pt = \"pt\"\n    en = \"en\"\n    es = \"es\"\n    fr = \"fr\"\n    it = \"it\"\n    de = \"de\"\n\nclass ModelEnum(str, Enum):\n    tiny = \"tiny\"\n    small = \"small\"\n    base = \"base\"\n    medium = \"medium\"\n    largeV2 = \"large-v2\"\n    largeV3 = \"large-v3\"\n\nclass ResponseTypeEnum(str, Enum):\n    json = \"json\"\n    file = \"file\""}
{"type": "source_file", "path": "src/api/auth.py", "content": "import os\nfrom src.api.config import MASTER_KEY, SECRET_KEY, TOKEN_EXPIRATION_DAYS\nfrom fastapi import Depends, HTTPException, Query\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport jwt\nfrom datetime import datetime, timedelta\nfrom src.api.database import get_db\nimport sqlite3\n\n\nsecurity = HTTPBearer()\noauth2_scheme = HTTPBearer(scheme_name=\"JWT\")\n\n\ndef create_jwt_token(data: dict):\n    token_expiration = datetime.utcnow() + timedelta(days=TOKEN_EXPIRATION_DAYS)\n    data[\"exp\"] = token_expiration\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\n\ndef decode_jwt_token(token: str):\n    try:\n        return jwt.decode(token, SECRET_KEY, algorithms=[\"HS256\"])\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail=\"Signature has expired\")\n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n\nasync def get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(oauth2_scheme),\n):\n    token = credentials.credentials\n    conn, cursor = get_db()\n    cursor.execute(\n        \"SELECT username, token_expiration FROM users WHERE token = ?\", (token,)\n    )\n    row = cursor.fetchone()\n    conn.close()\n    if row:\n        username, token_expiration_str = row\n        if token_expiration_str:\n            token_expiration = datetime.fromisoformat(token_expiration_str)\n            if token_expiration > datetime.utcnow():\n                return {\"username\": username}\n    raise HTTPException(status_code=401, detail=\"Invalid or expired token\")\n\n\ndef auth(username: str, password: str):\n    conn, cursor = get_db()\n    cursor.execute(\"SELECT password FROM users WHERE username = ?\", (username,))\n    row = cursor.fetchone()\n    if row and row[0] == password:\n        token_expiration = datetime.utcnow() + timedelta(days=TOKEN_EXPIRATION_DAYS)\n        token = create_jwt_token({\"sub\": username, \"exp\": token_expiration})\n        cursor.execute(\n            \"UPDATE users SET token = ?, token_expiration = ? WHERE username = ?\",\n            (token, token_expiration.isoformat(), username),\n        )\n        conn.commit()\n        conn.close()\n        return {\"access_token\": token, \"token_type\": \"bearer\"}\n    else:\n        conn.close()\n        raise HTTPException(status_code=401, detail=\"Invalid username or password\")\n\n\ndef create_user(username: str, password: str, master_key: str):\n    if master_key != MASTER_KEY:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    conn, cursor = get_db()\n    try:\n        cursor.execute(\n            \"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password)\n        )\n        conn.commit()\n        conn.close()\n        return {\"detail\": \"User created successfully\"}\n    except sqlite3.IntegrityError:\n        conn.close()\n        raise HTTPException(status_code=400, detail=\"Username already exists\")\n"}
{"type": "source_file", "path": "src/api/database.py", "content": "import os\nimport sqlite3\n\n\ndef get_db():\n    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    db_path = os.path.join(project_root, \"users.db\")\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\n        \"CREATE TABLE IF NOT EXISTS users (username TEXT, password TEXT, token TEXT, token_expiration TEXT)\"\n    )\n    return conn, cursor\n"}
{"type": "source_file", "path": "src/api/config.py", "content": "# Environment Variables\nimport os\nimport dotenv\n\n# Load environment variables\ndotenv.load_dotenv()\n\n\nAPI_PORT = os.getenv(\"API_PORT\", 11300)\nAPI_HOST = os.getenv(\"API_HOST\", \"localhost\")\n\nBROKER_URL = os.getenv(\"RABBIT_MQ_URI\", \"amqp://guest:guest@localhost:5672//\")\n\nTOKEN_EXPIRATION_DAYS = 7\nSECRET_KEY = os.getenv(\"SECRET_KEY\", \"super_secret_key\")\nMASTER_KEY = os.getenv(\"MASTER_KEY\", \"master_key\")\n\n\nHF_TOKEN = os.getenv(\"HUGGING_FACE_TOKEN\", \"\")\n"}
{"type": "source_file", "path": "src/api/main.py", "content": "import logging\nimport sys\nimport os\nimport subprocess\nfrom src.api.config import API_HOST, API_PORT\nfrom fastapi import FastAPI, Depends, HTTPException, Query, Form, UploadFile\nfrom src.api.auth import auth, get_current_user, create_user\nfrom src.api.database import get_db\nfrom src.api.models import LanguageEnum, ModelEnum, ResponseTypeEnum\nfrom src.api.tasks import transcribe_file, celery_app\nfrom src.utils.file_utils import create_directories, save_uploaded_file\nfrom celery import states\n\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\nparent_dir = os.path.dirname(current_dir)\nsys.path.insert(0, parent_dir)\n\n# Initialize FastAPI and logging\napp = FastAPI(\n    title=\"Whisperx API Wrapper\",\n    description=\"Upload a video or audio file and get a transcription in return, max file size is 100MB.\",\n    version=\"0.1.2\",\n    license_info={\n        \"name\": \"Apache 2.0\",\n        \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n    },\n)\nlogging.basicConfig(level=logging.INFO)\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"info\": \"WhisperX API\"}\n\n\n@app.post(\"/auth\")\ndef auth_endpoint(username: str, password: str):\n    return auth(username, password)\n\n\n@app.post(\"/create_user\")\ndef create_user_endpoint(username: str, password: str, master_key: str = Query(...)):\n    return create_user(username, password, master_key)\n\n\n@app.post(\"/jobs\")\nasync def create_transcription_job(\n    current_user: dict = Depends(get_current_user),\n    lang: LanguageEnum = Form(\n        LanguageEnum.pt, description=\"Language for transcription\"\n    ),\n    model: ModelEnum = Form(ModelEnum.largeV3, description=\"Model for transcription\"),\n    min_speakers: int = Form(1, description=\"Minimum number of speakers\"),\n    max_speakers: int = Form(2, description=\"Maximum number of speakers\"),\n    file: UploadFile = None,\n):\n    try:\n        create_directories()\n        temp_video_path = save_uploaded_file(file)\n        task = transcribe_file.delay(\n            temp_video_path, lang, model, min_speakers, max_speakers\n        )\n        return {\"task_id\": task.id, \"status\": \"PENDING\"}\n    except Exception as e:\n        logging.error(f\"An error occurred: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.get(\"/jobs\")\nasync def list_jobs(current_user: dict = Depends(get_current_user)):\n    tasks = celery_app.control.inspect().active()\n    jobs = []\n    for worker, task_list in tasks.items():\n        for task in task_list:\n            jobs.append({\"task_id\": task[\"id\"], \"status\": task[\"state\"]})\n    return jobs\n\n\n@app.get(\"/jobs/{task_id}\")\nasync def get_job_status(task_id: str, current_user: dict = Depends(get_current_user)):\n    task_result = celery_app.AsyncResult(task_id)\n    if task_result.state == states.PENDING:\n        response = {\n            \"task_id\": task_id,\n            \"status\": task_result.state,\n        }\n    elif task_result.state == states.FAILURE:\n        response = {\n            \"task_id\": task_id,\n            \"status\": task_result.state,\n            \"error\": str(task_result.result),\n        }\n    else:\n        response = {\n            \"task_id\": task_id,\n            \"status\": task_result.state,\n            \"result\": task_result.result,\n        }\n    return response\n\n\n@app.post(\"/jobs/{task_id}/stop\")\nasync def stop_job(task_id: str, current_user: dict = Depends(get_current_user)):\n    celery_app.control.revoke(task_id, terminate=True)\n    return {\"task_id\": task_id, \"status\": \"STOPPED\"}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    from multiprocessing import Process\n\n    def start_celery_worker():\n        subprocess.run(\n            [\"celery\", \"-A\", \"api.main.celery_app\", \"worker\", \"--loglevel=info\"]\n        )\n\n    celery_process = Process(target=start_celery_worker)\n    celery_process.start()\n\n    uvicorn.run(app, host=API_HOST, port=int(API_PORT))\n"}
{"type": "source_file", "path": "src/utils/transcription_utils.py", "content": "import os\nimport subprocess\n\nfrom src.api.config import HF_TOKEN\n\n\ndef run_whisperx(temp_mp3_path, lang, model, min_speakers, max_speakers):\n    output_dir = \"./data/\"\n    cmd = f\"whisperx {temp_mp3_path} --model {model} --language {lang} --hf_token {HF_TOKEN} --output_format all --output_dir {output_dir}  --align_model WAV2VEC2_ASR_LARGE_LV60K_960H --diarize --min_speakers {min_speakers} --max_speakers {max_speakers}\"\n    subprocess.run(cmd.split(), check=True)\n"}
{"type": "source_file", "path": "src/utils/file_utils.py", "content": "import os\nimport subprocess\nfrom zipfile import ZipFile\nfrom io import BytesIO\n\n\ndef create_directories():\n    if not os.path.exists('./temp'):\n        os.makedirs('./temp')\n    if not os.path.exists('./data'):\n        os.makedirs('./data')\n\ndef save_uploaded_file(file):\n    temp_video_path = f\"./temp/{file.filename}\"\n    with open(temp_video_path, \"wb\") as buffer:\n        buffer.write(file.file.read())\n    return temp_video_path\n\ndef convert_to_mp3(file_path):\n    temp_mp3_path = os.path.splitext(file_path)[0] + \".mp3\"\n    subprocess.run([\"ffmpeg\", \"-y\", \"-i\", file_path, temp_mp3_path], check=True)\n    return temp_mp3_path\n\n\ndef read_output_files(base_name):\n    output_dir = \"./data/\"\n    vtt_path = f\"{base_name}.vtt\"\n    txt_path = f\"{base_name}.txt\"\n    json_path = f\"{base_name}.json\"\n    srt_path = f\"{base_name}.srt\"\n    \n    with open(os.path.join(output_dir, vtt_path), \"r\") as vtt_file:\n        vtt_content = vtt_file.read()\n\n    with open(os.path.join(output_dir, txt_path), \"r\") as txt_file:\n        txt_content = txt_file.read()\n  \n    with open(os.path.join(output_dir, json_path), \"r\") as json_file:\n        json_content = json_file.read()\n        \n    with open(os.path.join(output_dir, srt_path), \"r\") as srt_file:\n        srt_content = srt_file.read()\n\n    return {\n        \"vtt_content\": vtt_content,\n        \"txt_content\": txt_content,\n        \"json_content\": json_content,\n        \"srt_content\": srt_content,\n        \"vtt_path\": vtt_path,\n        \"txt_path\": txt_path,\n        \"json_path\": json_path,\n        \"srt_path\": srt_path\n    }\n    \ndef zip_files(vtt_path, txt_path):\n    memory_file = BytesIO()\n    with ZipFile(memory_file, 'w') as zf:\n        zf.write(os.path.join(\"./data/\", vtt_path), vtt_path)\n        zf.write(os.path.join(\"./data/\", txt_path), txt_path)\n    memory_file.seek(0)\n    return memory_file\n  \n  "}
{"type": "source_file", "path": "start.py", "content": "import os\nimport subprocess\nfrom multiprocessing import Process\nfrom src.api.config import API_HOST, API_PORT\nimport uvicorn\nfrom src.api.main import app\n\n\ndef start_celery_worker():\n    subprocess.run(\n        [\"celery\", \"-A\", \"src.api.tasks.celery_app\", \"worker\", \"--loglevel=info\"]\n    )\n\n\nif __name__ == \"__main__\":\n    celery_process = Process(target=start_celery_worker)\n    celery_process.start()\n\n    uvicorn.run(app, host=API_HOST, port=int(API_PORT))\n"}

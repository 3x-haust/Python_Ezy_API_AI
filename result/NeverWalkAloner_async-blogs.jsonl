{"repo_info": {"repo_name": "async-blogs", "repo_owner": "NeverWalkAloner", "repo_url": "https://github.com/NeverWalkAloner/async-blogs"}}
{"type": "test_file", "path": "app/tests/conftest.py", "content": "import os\n\nimport pytest\n\n# This sets `os.environ`,\n# If we placed it below the application import, it would raise an error\n# informing us that 'TESTING' had already been read from the environment.\nos.environ['TESTING'] = 'True'\n\nfrom alembic import command\nfrom alembic.config import Config\nfrom app.models import database\nfrom sqlalchemy_utils import create_database, drop_database\n\n\n@pytest.fixture(scope=\"module\")\ndef temp_db():\n    \"\"\" Create new DB for tests \"\"\"\n    create_database(database.TEST_SQLALCHEMY_DATABASE_URL)\n    base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\n    alembic_cfg = Config(os.path.join(base_dir, \"alembic.ini\"))\n    command.upgrade(alembic_cfg, \"head\")\n\n    try:\n        yield database.TEST_SQLALCHEMY_DATABASE_URL\n    finally:\n        drop_database(database.TEST_SQLALCHEMY_DATABASE_URL)\n"}
{"type": "test_file", "path": "app/tests/test_users.py", "content": "import asyncio\nimport pytest\n\nfrom app.main import app\nfrom app.schemas.users import UserCreate\nfrom app.utils.users import create_user, create_user_token\nfrom fastapi.testclient import TestClient\n\n\ndef test_sign_up(temp_db):\n    request_data = {\n        \"email\": \"vader@deathstar.com\",\n        \"name\": \"Darth\",\n        \"password\": \"rainbow\"\n    }\n    with TestClient(app) as client:\n        response = client.post(\"/sign-up\", json=request_data)\n    assert response.status_code == 200\n    assert response.json()[\"id\"] == 1\n    assert response.json()[\"email\"] == \"vader@deathstar.com\"\n    assert response.json()[\"name\"] == \"Darth\"\n    assert response.json()[\"token\"][\"expires\"] is not None\n    assert response.json()[\"token\"][\"access_token\"] is not None\n\n\ndef test_login(temp_db):\n    request_data = {\"username\": \"vader@deathstar.com\", \"password\": \"rainbow\"}\n    with TestClient(app) as client:\n        response = client.post(\"/auth\", data=request_data)\n    assert response.status_code == 200\n    assert response.json()[\"token_type\"] == \"bearer\"\n    assert response.json()[\"expires\"] is not None\n    assert response.json()[\"access_token\"] is not None\n\n\ndef test_login_with_invalid_password(temp_db):\n    request_data = {\"username\": \"vader@deathstar.com\", \"password\": \"unicorn\"}\n    with TestClient(app) as client:\n        response = client.post(\"/auth\", data=request_data)\n    assert response.status_code == 400\n    assert response.json()[\"detail\"] == \"Incorrect email or password\"\n\n\ndef test_user_detail(temp_db):\n    with TestClient(app) as client:\n        # Create user token to see user info\n        loop = asyncio.get_event_loop()\n        token = loop.run_until_complete(create_user_token(user_id=1))\n        response = client.get(\n            \"/users/me\",\n            headers={\"Authorization\": f\"Bearer {token['token']}\"}\n        )\n    assert response.status_code == 200\n    assert response.json()[\"id\"] == 1\n    assert response.json()[\"email\"] == \"vader@deathstar.com\"\n    assert response.json()[\"name\"] == \"Darth\"\n\n\ndef test_user_detail_forbidden_without_token(temp_db):\n    with TestClient(app) as client:\n        response = client.get(\"/users/me\")\n    assert response.status_code == 401\n\n\n@pytest.mark.freeze_time(\"2015-10-21\")\ndef test_user_detail_forbidden_with_expired_token(temp_db, freezer):\n    user = UserCreate(\n        email=\"sidious@deathstar.com\",\n        name=\"Palpatine\",\n        password=\"unicorn\"\n    )\n    with TestClient(app) as client:\n        # Create user and use expired token\n        loop = asyncio.get_event_loop()\n        user_db = loop.run_until_complete(create_user(user))\n        freezer.move_to(\"'2015-11-10'\")\n        response = client.get(\n            \"/users/me\",\n            headers={\"Authorization\": f\"Bearer {user_db['token']['token']}\"}\n        )\n    assert response.status_code == 401\n"}
{"type": "test_file", "path": "app/tests/test_posts.py", "content": "import asyncio\n\nfrom app.main import app\nfrom app.schemas.users import UserCreate\nfrom app.utils.users import create_user, create_user_token\nfrom fastapi.testclient import TestClient\n\n\ndef test_create_post(temp_db):\n    user = UserCreate(\n        email=\"vader@deathstar.com\",\n        name=\"Darth\",\n        password=\"rainbow\"\n    )\n    request_data = {\n      \"title\": \"42\",\n      \"content\": \"Don't panic!\"\n    }\n    with TestClient(app) as client:\n        # Create user and use his token to add new post\n        loop = asyncio.get_event_loop()\n        user_db = loop.run_until_complete(create_user(user))\n        response = client.post(\n            \"/posts\",\n            json=request_data,\n            headers={\"Authorization\": f\"Bearer {user_db['token']['token']}\"}\n        )\n    assert response.status_code == 201\n    assert response.json()[\"id\"] == 1\n    assert response.json()[\"title\"] == \"42\"\n    assert response.json()[\"content\"] == \"Don't panic!\"\n\n\ndef test_create_post_forbidden_without_token(temp_db):\n    request_data = {\n      \"title\": \"42\",\n      \"content\": \"Don't panic!\"\n    }\n    with TestClient(app) as client:\n        response = client.post(\"/posts\", json=request_data)\n    assert response.status_code == 401\n\n\ndef test_posts_list(temp_db):\n    with TestClient(app) as client:\n        response = client.get(\"/posts\")\n    assert response.status_code == 200\n    assert response.json()[\"total_count\"] == 1\n    assert response.json()[\"results\"][0][\"id\"] == 1\n    assert response.json()[\"results\"][0][\"title\"] == \"42\"\n    assert response.json()[\"results\"][0][\"content\"] == \"Don't panic!\"\n\n\ndef test_post_detail(temp_db):\n    post_id = 1\n    with TestClient(app) as client:\n        response = client.get(f\"/posts/{post_id}\")\n    assert response.status_code == 200\n    assert response.json()[\"id\"] == 1\n    assert response.json()[\"title\"] == \"42\"\n    assert response.json()[\"content\"] == \"Don't panic!\"\n\n\ndef test_update_post(temp_db):\n    post_id = 1\n    request_data = {\n      \"title\": \"42\",\n      \"content\": \"Life? Don't talk to me about life.\"\n    }\n    with TestClient(app) as client:\n        # Create user token to add new post\n        loop = asyncio.get_event_loop()\n        token = loop.run_until_complete(create_user_token(user_id=1))\n        response = client.put(\n            f\"/posts/{post_id}\",\n            json=request_data,\n            headers={\"Authorization\": f\"Bearer {token['token']}\"}\n        )\n    assert response.status_code == 200\n    assert response.json()[\"id\"] == 1\n    assert response.json()[\"title\"] == \"42\"\n    assert response.json()[\"content\"] == \"Life? Don't talk to me about life.\"\n\n\ndef test_update_post_forbidden_without_token(temp_db):\n    post_id = 1\n    request_data = {\n      \"title\": \"42\",\n      \"content\": \"Life? Don't talk to me about life.\"\n    }\n    with TestClient(app) as client:\n        response = client.put(f\"/posts/{post_id}\", json=request_data)\n    assert response.status_code == 401\n"}
{"type": "test_file", "path": "app/tests/test_health_check.py", "content": "from app.main import app\nfrom fastapi.testclient import TestClient\n\nclient = TestClient(app)\n\n\ndef test_health_check():\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"Hello\": \"World\"}\n"}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/routers/posts.py", "content": "from app.schemas.posts import PostDetailsModel, PostModel\nfrom app.schemas.users import User\nfrom app.utils import posts as post_utils\nfrom app.utils.dependencies import get_current_user\nfrom fastapi import APIRouter, Depends, HTTPException, status\n\nrouter = APIRouter()\n\n\n@router.post(\"/posts\", response_model=PostDetailsModel, status_code=201)\nasync def create_post(post: PostModel, current_user: User = Depends(get_current_user)):\n    post = await post_utils.create_post(post, current_user)\n    return post\n\n\n@router.get(\"/posts\")\nasync def get_posts(page: int = 1):\n    total_cout = await post_utils.get_posts_count()\n    posts = await post_utils.get_posts(page)\n    return {\"total_count\": total_cout, \"results\": posts}\n\n\n@router.get(\"/posts/{post_id}\", response_model=PostDetailsModel)\nasync def get_post(post_id: int):\n    return await post_utils.get_post(post_id)\n\n\n@router.put(\"/posts/{post_id}\", response_model=PostDetailsModel)\nasync def update_post(\n    post_id: int, post_data: PostModel, current_user=Depends(get_current_user)\n):\n    post = await post_utils.get_post(post_id)\n    if post[\"user_id\"] != current_user[\"id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"You don't have access to modify this post\",\n        )\n\n    await post_utils.update_post(post_id=post_id, post=post_data)\n    return await post_utils.get_post(post_id)\n"}
{"type": "source_file", "path": "app/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "app/schemas/__init__.py", "content": ""}
{"type": "source_file", "path": "app/routers/users.py", "content": "from app.schemas import users\nfrom app.utils import users as users_utils\nfrom app.utils.dependencies import get_current_user\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\n\nrouter = APIRouter()\n\n\n@router.get(\"/\")\nasync def health_check():\n    return {\"Hello\": \"World\"}\n\n\n@router.post(\"/auth\", response_model=users.TokenBase)\nasync def auth(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = await users_utils.get_user_by_email(email=form_data.username)\n\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n\n    if not users_utils.validate_password(\n        password=form_data.password, hashed_password=user[\"hashed_password\"]\n    ):\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n\n    return await users_utils.create_user_token(user_id=user[\"id\"])\n\n\n@router.post(\"/sign-up\", response_model=users.User)\nasync def create_user(user: users.UserCreate):\n    db_user = await users_utils.get_user_by_email(email=user.email)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    return await users_utils.create_user(user=user)\n\n\n@router.get(\"/users/me\", response_model=users.UserBase)\nasync def read_users_me(current_user: users.User = Depends(get_current_user)):\n    return current_user\n"}
{"type": "source_file", "path": "app/models/__init__.py", "content": ""}
{"type": "source_file", "path": "app/models/users.py", "content": "import sqlalchemy\nfrom sqlalchemy.dialects.postgresql import UUID\n\nmetadata = sqlalchemy.MetaData()\n\nusers_table = sqlalchemy.Table(\n    \"users\",\n    metadata,\n    sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True),\n    sqlalchemy.Column(\"email\", sqlalchemy.String(40), unique=True, index=True),\n    sqlalchemy.Column(\"name\", sqlalchemy.String(100)),\n    sqlalchemy.Column(\"hashed_password\", sqlalchemy.String()),\n    sqlalchemy.Column(\n        \"is_active\",\n        sqlalchemy.Boolean(),\n        server_default=sqlalchemy.sql.expression.true(),\n        nullable=False,\n    ),\n)\n\n\ntokens_table = sqlalchemy.Table(\n    \"tokens\",\n    metadata,\n    sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True),\n    sqlalchemy.Column(\n        \"token\",\n        UUID(as_uuid=False),\n        server_default=sqlalchemy.text(\"uuid_generate_v4()\"),\n        unique=True,\n        nullable=False,\n        index=True,\n    ),\n    sqlalchemy.Column(\"expires\", sqlalchemy.DateTime()),\n    sqlalchemy.Column(\"user_id\", sqlalchemy.ForeignKey(\"users.id\")),\n)\n"}
{"type": "source_file", "path": "app/routers/__init__.py", "content": ""}
{"type": "source_file", "path": "app/schemas/users.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import UUID4, BaseModel, EmailStr, validator, Field\n\n\nclass TokenBase(BaseModel):\n    \"\"\" Return response data \"\"\"\n    token: UUID4 = Field(..., alias=\"access_token\")\n    expires: datetime\n    token_type: Optional[str] = \"bearer\"\n\n    class Config:\n        allow_population_by_field_name = True\n\n    @validator(\"token\")\n    def hexlify_token(cls, value):\n        \"\"\" Convert UUID to pure hex string \"\"\"\n        return value.hex\n\n\nclass UserBase(BaseModel):\n    \"\"\" Return response data \"\"\"\n    id: int\n    email: EmailStr\n    name: str\n\n\nclass UserCreate(BaseModel):\n    \"\"\" Validate request data \"\"\"\n    email: EmailStr\n    name: str\n    password: str\n\n\nclass User(UserBase):\n    \"\"\" Return detailed response data with token \"\"\"\n    token: TokenBase = {}\n"}
{"type": "source_file", "path": "app/utils/posts.py", "content": "from datetime import datetime\n\nfrom app.models.database import database\nfrom app.models.posts import posts_table\nfrom app.models.users import users_table\nfrom app.schemas import posts as post_schema\nfrom sqlalchemy import desc, func, select\n\n\nasync def create_post(post: post_schema.PostModel, user):\n    query = (\n        posts_table.insert()\n        .values(\n            title=post.title,\n            content=post.content,\n            created_at=datetime.now(),\n            user_id=user[\"id\"],\n        )\n        .returning(\n            posts_table.c.id,\n            posts_table.c.title,\n            posts_table.c.content,\n            posts_table.c.created_at,\n        )\n    )\n    post = await database.fetch_one(query)\n\n    # Convert to dict and add user_name key to it\n    post = dict(zip(post, post.values()))\n    post[\"user_name\"] = user[\"name\"]\n    return post\n\n\nasync def get_post(post_id: int):\n    query = (\n        select(\n            [\n                posts_table.c.id,\n                posts_table.c.created_at,\n                posts_table.c.title,\n                posts_table.c.content,\n                posts_table.c.user_id,\n                users_table.c.name.label(\"user_name\"),\n            ]\n        )\n        .select_from(posts_table.join(users_table))\n        .where(posts_table.c.id == post_id)\n    )\n    return await database.fetch_one(query)\n\n\nasync def get_posts(page: int):\n    max_per_page = 10\n    offset1 = (page - 1) * max_per_page\n    query = (\n        select(\n            [\n                posts_table.c.id,\n                posts_table.c.created_at,\n                posts_table.c.title,\n                posts_table.c.content,\n                posts_table.c.user_id,\n                users_table.c.name.label(\"user_name\"),\n            ]\n        )\n        .select_from(posts_table.join(users_table))\n        .order_by(desc(posts_table.c.created_at))\n        .limit(max_per_page)\n        .offset(offset1)\n    )\n    return await database.fetch_all(query)\n\n\nasync def get_posts_count():\n    query = select([func.count()]).select_from(posts_table)\n    return await database.fetch_val(query)\n\n\nasync def update_post(post_id: int, post: post_schema.PostModel):\n    query = (\n        posts_table.update()\n        .where(posts_table.c.id == post_id)\n        .values(title=post.title, content=post.content)\n    )\n    return await database.execute(query)\n"}
{"type": "source_file", "path": "app/schemas/posts.py", "content": "from datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass PostModel(BaseModel):\n    \"\"\" Validate request data \"\"\"\n    title: str\n    content: str\n\n\nclass PostDetailsModel(PostModel):\n    \"\"\" Return response data \"\"\"\n    id: int\n    created_at: datetime\n    user_name: str\n"}
{"type": "source_file", "path": "app/models/posts.py", "content": "import sqlalchemy\n\nfrom .users import users_table\n\nmetadata = sqlalchemy.MetaData()\n\nposts_table = sqlalchemy.Table(\n    \"posts\",\n    metadata,\n    sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True),\n    sqlalchemy.Column(\"user_id\", sqlalchemy.ForeignKey(users_table.c.id)),\n    sqlalchemy.Column(\"created_at\", sqlalchemy.DateTime()),\n    sqlalchemy.Column(\"title\", sqlalchemy.String(100)),\n    sqlalchemy.Column(\"content\", sqlalchemy.Text()),\n)\n"}
{"type": "source_file", "path": "app/models/database.py", "content": "from os import environ\n\nimport databases\n\nDB_USER = environ.get(\"DB_USER\", \"user\")\nDB_PASSWORD = environ.get(\"DB_PASSWORD\", \"password\")\nDB_HOST = environ.get(\"DB_HOST\", \"localhost\")\n\nTESTING = environ.get(\"TESTING\")\n\nif TESTING:\n    # Use separate DB for tests\n    DB_NAME = \"async-blogs-temp-for-test\"\n    TEST_SQLALCHEMY_DATABASE_URL = (\n        f\"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:5432/{DB_NAME}\"\n    )\n    database = databases.Database(TEST_SQLALCHEMY_DATABASE_URL)\nelse:\n    DB_NAME = \"async-blogs\"\n    SQLALCHEMY_DATABASE_URL = (\n        f\"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:5432/{DB_NAME}\"\n    )\n    database = databases.Database(SQLALCHEMY_DATABASE_URL)\n"}
{"type": "source_file", "path": "app/main.py", "content": "import uvicorn\nfrom app.models.database import database\nfrom app.routers import posts, users\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.on_event(\"startup\")\nasync def startup():\n    await database.connect()\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await database.disconnect()\n\napp.include_router(users.router)\napp.include_router(posts.router)\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"}
{"type": "source_file", "path": "app/utils/dependencies.py", "content": "from app.utils import users as users_utils\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth\")\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    user = await users_utils.get_user_by_token(token)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    if not user[\"is_active\"]:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST, detail=\"Inactive user\"\n        )\n    return user\n"}
{"type": "source_file", "path": "migrations/env.py", "content": "import os\nimport sys\nfrom logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nfrom alembic import context\n\n# add current path to PYTHONPATH, otherwise app module will not be found when alembic executing\nsys.path.append(os.getcwd())\n\nfrom app.models import database, posts, users\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\nsection = config.config_ini_section\nconfig.set_section_option(section, \"DB_USER\", database.DB_USER)\nconfig.set_section_option(section, \"DB_PASS\", database.DB_PASSWORD)\nconfig.set_section_option(section, \"DB_NAME\", database.DB_NAME)\nconfig.set_section_option(section, \"DB_HOST\", database.DB_HOST)\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = [users.metadata, posts.metadata]\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "app/utils/users.py", "content": "import hashlib\nimport random\nimport string\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import and_\n\nfrom app.models.database import database\nfrom app.models.users import tokens_table, users_table\nfrom app.schemas import users as user_schema\n\n\ndef get_random_string(length=12):\n    return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n\n\ndef hash_password(password: str, salt: str = None):\n    if salt is None:\n        salt = get_random_string()\n    enc = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), salt.encode(), 100_000)\n    return enc.hex()\n\n\ndef validate_password(password: str, hashed_password: str):\n    salt, hashed = hashed_password.split(\"$\")\n    return hash_password(password, salt) == hashed\n\n\nasync def get_user(user_id: int):\n    query = users_table.select().where(users_table.c.id == user_id)\n    return await database.fetch_one(query)\n\n\nasync def get_user_by_email(email: str):\n    query = users_table.select().where(users_table.c.email == email)\n    return await database.fetch_one(query)\n\n\nasync def create_user(user: user_schema.UserCreate):\n    salt = get_random_string()\n    hashed_password = hash_password(user.password, salt)\n    query = users_table.insert().values(\n        email=user.email, name=user.name, hashed_password=f\"{salt}${hashed_password}\"\n    )\n    user_id = await database.execute(query)\n    token = await create_user_token(user_id)\n    token_dict = {\"token\": token[\"token\"], \"expires\": token[\"expires\"]}\n\n    return {**user.dict(), \"id\": user_id, \"is_active\": True, \"token\": token_dict}\n\n\nasync def create_user_token(user_id: int):\n    query = (\n        tokens_table.insert()\n        .values(expires=datetime.now() + timedelta(weeks=2), user_id=user_id)\n        .returning(tokens_table.c.token, tokens_table.c.expires)\n    )\n\n    return await database.fetch_one(query)\n\n\nasync def get_user_by_token(token: str):\n    query = tokens_table.join(users_table).select().where(\n        and_(\n            tokens_table.c.token == token,\n            tokens_table.c.expires > datetime.now()\n        )\n    )\n    return await database.fetch_one(query)\n"}
{"type": "source_file", "path": "migrations/versions/223152812b5f_add_users_and_tokens_tables.py", "content": "\"\"\"Add users and tokens tables\n\nRevision ID: 223152812b5f\nRevises: cb1409f3e7c2\nCreate Date: 2020-07-29 19:08:20.253613\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlalchemy.dialects import postgresql\n\n# revision identifiers, used by Alembic.\nrevision = '223152812b5f'\ndown_revision = 'cb1409f3e7c2'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('email', sa.String(length=40), nullable=True),\n    sa.Column('name', sa.String(length=100), nullable=True),\n    sa.Column('hashed_password', sa.String(), nullable=True),\n    sa.Column('is_active', sa.Boolean(), server_default=sa.text('true'), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)\n    op.create_table('tokens',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('token', postgresql.UUID(), server_default=sa.text('uuid_generate_v4()'), nullable=False),\n    sa.Column('expires', sa.DateTime(), nullable=True),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index(op.f('ix_tokens_token'), 'tokens', ['token'], unique=True)\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f('ix_tokens_token'), table_name='tokens')\n    op.drop_table('tokens')\n    op.drop_index(op.f('ix_users_email'), table_name='users')\n    op.drop_table('users')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "migrations/versions/d5f540524f29_add_posts_table.py", "content": "\"\"\"Add posts table\n\nRevision ID: d5f540524f29\nRevises: 223152812b5f\nCreate Date: 2020-07-29 19:08:41.137561\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = 'd5f540524f29'\ndown_revision = '223152812b5f'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('posts',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), nullable=True),\n    sa.Column('title', sa.String(length=100), nullable=True),\n    sa.Column('content', sa.Text(), nullable=True),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('posts')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "migrations/versions/cb1409f3e7c2_create_uuid_extension.py", "content": "\"\"\"create uuid extension\n\nRevision ID: cb1409f3e7c2\nRevises: \nCreate Date: 2020-06-08 15:38:20.027251\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = 'cb1409f3e7c2'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    conn = op.get_bind()\n    conn.execute('create extension \"uuid-ossp\"')\n\n\ndef downgrade():\n    conn = op.get_bind()\n    conn.execute('drop extension \"uuid-ossp\"')\n"}

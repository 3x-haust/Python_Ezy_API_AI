{"repo_info": {"repo_name": "pr-agent", "repo_owner": "qodo-ai", "repo_url": "https://github.com/qodo-ai/pr-agent"}}
{"type": "test_file", "path": "tests/e2e_tests/e2e_utils.py", "content": "FILE_PATH = \"pr_agent/cli_pip.py\"\n\nPR_HEADER_START_WITH = '### **User description**\\nupdate cli_pip.py\\n\\n\\n___\\n\\n### **PR Type**'\nREVIEW_START_WITH = '## PR Reviewer Guide üîç\\n\\n<table>\\n<tr><td>‚è±Ô∏è&nbsp;<strong>Estimated effort to review</strong>:'\nIMPROVE_START_WITH_REGEX_PATTERN = r'^## PR Code Suggestions ‚ú®\\n\\n<!-- [a-z0-9]+ -->\\n\\n<table><thead><tr><td>Category</td>'\n\nNUM_MINUTES = 5\n\nNEW_FILE_CONTENT = \"\"\"\\\nfrom pr_agent import cli\nfrom pr_agent.config_loader import get_settings\n\n\ndef main():\n    # Fill in the following values\n    provider = \"github\"  # GitHub provider\n    user_token = \"...\"  # GitHub user token\n    openai_key = \"ghs_afsdfasdfsdf\"  # Example OpenAI key\n    pr_url = \"...\"  # PR URL, for example 'https://github.com/Codium-ai/pr-agent/pull/809'\n    command = \"/improve\"  # Command to run (e.g. '/review', '/describe', 'improve', '/ask=\"What is the purpose of this PR?\"')\n\n    # Setting the configurations\n    get_settings().set(\"CONFIG.git_provider\", provider)\n    get_settings().set(\"openai.key\", openai_key)\n    get_settings().set(\"github.user_token\", user_token)\n\n    # Run the command. Feedback will appear in GitHub PR comments\n    output = cli.run_command(pr_url, command)\n\n    print(output)\n\nif __name__ == '__main__':\n    main()\n\"\"\"\n"}
{"type": "test_file", "path": "tests/unittest/test_fetching_sub_issues.py", "content": "# Currently doing API calls - wrong !\n\n\n# import unittest\n# import asyncio\n# from unittest.mock import AsyncMock, patch\n# from pr_agent.tools.ticket_pr_compliance_check import extract_tickets, extract_and_cache_pr_tickets\n# from pr_agent.git_providers.github_provider import GithubProvider\n#\n#\n# class TestTicketCompliance(unittest.TestCase):\n#\n#     @patch.object(GithubProvider, 'get_user_description', return_value=\"Fixes #1 and relates to #2\")\n#     @patch.object(GithubProvider, '_parse_issue_url', side_effect=lambda url: (\"WonOfAKind/KimchiBot\", int(url.split('#')[-1])))\n#     @patch.object(GithubProvider, 'repo_obj')\n#     async def test_extract_tickets(self, mock_repo, mock_parse_issue_url, mock_user_desc):\n#         \"\"\"\n#         Test extract_tickets() to ensure it extracts tickets correctly\n#         and fetches their content.\n#         \"\"\"\n#         github_provider = GithubProvider()\n#         github_provider.repo = \"WonOfAKind/KimchiBot\"\n#         github_provider.base_url_html = \"https://github.com\"\n#\n#         # Mock issue retrieval\n#         mock_issue = AsyncMock()\n#         mock_issue.number = 1\n#         mock_issue.title = \"Sample Issue\"\n#         mock_issue.body = \"This is a test issue body.\"\n#         mock_issue.labels = [\"bug\", \"high priority\"]\n#\n#         # Mock repo object\n#         mock_repo.get_issue.return_value = mock_issue\n#\n#         tickets = await extract_tickets(github_provider)\n#\n#         # Verify tickets were extracted correctly\n#         self.assertIsInstance(tickets, list)\n#         self.assertGreater(len(tickets), 0, \"Expected at least one ticket!\")\n#\n#         # Verify ticket structure\n#         first_ticket = tickets[0]\n#         self.assertIn(\"ticket_id\", first_ticket)\n#         self.assertIn(\"ticket_url\", first_ticket)\n#         self.assertIn(\"title\", first_ticket)\n#         self.assertIn(\"body\", first_ticket)\n#         self.assertIn(\"labels\", first_ticket)\n#\n#         print(\"\\n Test Passed: extract_tickets() successfully retrieved ticket info!\")\n#\n#     @patch.object(GithubProvider, 'get_user_description', return_value=\"Fixes #1 and relates to #2\")\n#     @patch.object(GithubProvider, '_parse_issue_url', side_effect=lambda url: (\"WonOfAKind/KimchiBot\", int(url.split('#')[-1])))\n#     @patch.object(GithubProvider, 'repo_obj')\n#     async def test_extract_and_cache_pr_tickets(self, mock_repo, mock_parse_issue_url, mock_user_desc):\n#         \"\"\"\n#         Test extract_and_cache_pr_tickets() to ensure tickets are extracted and cached correctly.\n#         \"\"\"\n#         github_provider = GithubProvider()\n#         github_provider.repo = \"WonOfAKind/KimchiBot\"\n#         github_provider.base_url_html = \"https://github.com\"\n#\n#         vars = {}  # Simulate the dictionary to store results\n#\n#         # Mock issue retrieval\n#         mock_issue = AsyncMock()\n#         mock_issue.number = 1\n#         mock_issue.title = \"Sample Issue\"\n#         mock_issue.body = \"This is a test issue body.\"\n#         mock_issue.labels = [\"bug\", \"high priority\"]\n#\n#         # Mock repo object\n#         mock_repo.get_issue.return_value = mock_issue\n#\n#         # Run function\n#         await extract_and_cache_pr_tickets(github_provider, vars)\n#\n#         # Ensure tickets are cached\n#         self.assertIn(\"related_tickets\", vars)\n#         self.assertIsInstance(vars[\"related_tickets\"], list)\n#         self.assertGreater(len(vars[\"related_tickets\"]), 0, \"Expected at least one cached ticket!\")\n#\n#         print(\"\\n Test Passed: extract_and_cache_pr_tickets() successfully cached ticket data!\")\n#\n#     def test_fetch_sub_issues(self):\n#         \"\"\"\n#         Test fetch_sub_issues() to ensure sub-issues are correctly retrieved.\n#         \"\"\"\n#         github_provider = GithubProvider()\n#         issue_url = \"https://github.com/WonOfAKind/KimchiBot/issues/1\"  # Known issue with sub-issues\n#         result = github_provider.fetch_sub_issues(issue_url)\n#\n#         print(\"Fetched sub-issues:\", result)\n#\n#         self.assertIsInstance(result, set)  # Ensure result is a set\n#         self.assertGreater(len(result), 0, \"Expected at least one sub-issue but found none!\")\n#\n#         print(\"\\n Test Passed: fetch_sub_issues() retrieved sub-issues correctly!\")\n#\n#     def test_fetch_sub_issues_with_no_results(self):\n#         \"\"\"\n#         Test fetch_sub_issues() to ensure an empty set is returned for an issue with no sub-issues.\n#         \"\"\"\n#         github_provider = GithubProvider()\n#         issue_url = \"https://github.com/qodo-ai/pr-agent/issues/1499\"  # Likely non-existent issue\n#         result = github_provider.fetch_sub_issues(issue_url)\n#\n#         print(\"Fetched sub-issues for non-existent issue:\", result)\n#\n#         self.assertIsInstance(result, set)  # Ensure result is a set\n#         self.assertEqual(len(result), 0, \"Expected no sub-issues but some were found!\")\n#\n#         print(\"\\n Test Passed: fetch_sub_issues_with_no_results() correctly returned an empty set!\")\n#\n#\n# if __name__ == \"__main__\":\n#     asyncio.run(unittest.main())\n#\n#\n#\n#\n#\n"}
{"type": "test_file", "path": "tests/unittest/test_extend_patch.py", "content": "import pytest\n\nfrom pr_agent.algo.git_patch_processing import extend_patch\nfrom pr_agent.algo.pr_processing import pr_generate_extended_diff\nfrom pr_agent.algo.token_handler import TokenHandler\nfrom pr_agent.algo.utils import load_large_diff\nfrom pr_agent.config_loader import get_settings\nget_settings(use_context=False).set(\"CONFIG.CLI_MODE\", True)\nget_settings(use_context=False).config.allow_dynamic_context = False\n\n\nclass TestExtendPatch:\n    # Tests that the function works correctly with valid input\n    def test_happy_path(self):\n        original_file_str = 'line1\\nline2\\nline3\\nline4\\nline5'\n        patch_str = '@@ -2,2 +2,2 @@ init()\\n-line2\\n+new_line2\\n line3'\n        num_lines = 1\n        expected_output = '\\n@@ -1,4 +1,4 @@ init()\\n line1\\n-line2\\n+new_line2\\n line3\\n line4'\n        actual_output = extend_patch(original_file_str, patch_str,\n                                     patch_extra_lines_before=num_lines, patch_extra_lines_after=num_lines)\n        assert actual_output == expected_output\n\n    # Tests that the function returns an empty string when patch_str is empty\n    def test_empty_patch(self):\n        original_file_str = 'line1\\nline2\\nline3\\nline4\\nline5'\n        patch_str = ''\n        num_lines = 1\n        expected_output = ''\n        assert extend_patch(original_file_str, patch_str,\n                            patch_extra_lines_before=num_lines, patch_extra_lines_after=num_lines) == expected_output\n\n    # Tests that the function returns the original patch when num_lines is 0\n    def test_zero_num_lines(self):\n        original_file_str = 'line1\\nline2\\nline3\\nline4\\nline5'\n        patch_str = '@@ -2,2 +2,2 @@ init()\\n-line2\\n+new_line2\\nline3'\n        num_lines = 0\n        assert extend_patch(original_file_str, patch_str,\n                            patch_extra_lines_before=num_lines, patch_extra_lines_after=num_lines) == patch_str\n\n    # Tests that the function returns the original patch when patch_str contains no hunks\n    def test_no_hunks(self):\n        original_file_str = 'line1\\nline2\\nline3\\nline4\\nline5'\n        patch_str = 'no hunks here'\n        num_lines = 1\n        expected_output = 'no hunks here'\n        assert extend_patch(original_file_str, patch_str, num_lines) == expected_output\n\n    # Tests that the function extends a patch with a single hunk correctly\n    def test_single_hunk(self):\n        original_file_str = 'line1\\nline2\\nline3\\nline4\\nline5'\n        patch_str = '@@ -2,3 +2,3 @@ init()\\n-line2\\n+new_line2\\n line3\\n line4'\n\n        for num_lines in [1, 2, 3]: # check that even if we are over the number of lines in the file, the function still works\n            expected_output = '\\n@@ -1,5 +1,5 @@ init()\\n line1\\n-line2\\n+new_line2\\n line3\\n line4\\n line5'\n            actual_output = extend_patch(original_file_str, patch_str,\n                                         patch_extra_lines_before=num_lines, patch_extra_lines_after=num_lines)\n            assert actual_output == expected_output\n\n    # Tests the functionality of extending a patch with multiple hunks.\n    def test_multiple_hunks(self):\n        original_file_str = 'line1\\nline2\\nline3\\nline4\\nline5\\nline6'\n        patch_str = '@@ -2,3 +2,3 @@ init()\\n-line2\\n+new_line2\\n line3\\n line4\\n@@ -4,1 +4,1 @@ init2()\\n-line4\\n+new_line4'  # noqa: E501\n        num_lines = 1\n        original_allow_dynamic_context = get_settings(use_context=False).config.allow_dynamic_context\n\n        get_settings(use_context=False).config.allow_dynamic_context = False\n        expected_output = '\\n@@ -1,5 +1,5 @@ init()\\n line1\\n-line2\\n+new_line2\\n line3\\n line4\\n line5\\n\\n@@ -3,3 +3,3 @@ init2()\\n line3\\n-line4\\n+new_line4\\n line5' # noqa: E501\n        actual_output = extend_patch(original_file_str, patch_str,\n                                     patch_extra_lines_before=num_lines, patch_extra_lines_after=num_lines)\n        assert actual_output == expected_output\n\n        get_settings(use_context=False).config.allow_dynamic_context = True\n        expected_output = '\\n@@ -1,5 +1,5 @@ init()\\n line1\\n-line2\\n+new_line2\\n line3\\n line4\\n line5\\n\\n@@ -3,3 +3,3 @@ init2()\\n line3\\n-line4\\n+new_line4\\n line5' # noqa: E501\n        actual_output = extend_patch(original_file_str, patch_str,\n                                     patch_extra_lines_before=num_lines, patch_extra_lines_after=num_lines)\n        assert actual_output == expected_output\n        get_settings(use_context=False).config.allow_dynamic_context = original_allow_dynamic_context\n\n\n    def test_dynamic_context(self):\n        get_settings(use_context=False).config.max_extra_lines_before_dynamic_context = 10\n        original_file_str = \"def foo():\"\n        for i in range(9):\n            original_file_str += f\"\\n    line({i})\"\n        patch_str =\"@@ -10,1 +10,1 @@ def foo():\\n-    line(8)\\n+    new_line(8)\"\n        new_file_str = \"\\n\".join(original_file_str.splitlines()[:-1] + [\"    new_line(8)\"])\n        num_lines=1\n\n        get_settings(use_context=False).config.allow_dynamic_context = True\n        actual_output = extend_patch(original_file_str, patch_str,\n                                     patch_extra_lines_before=num_lines, patch_extra_lines_after=num_lines, new_file_str=new_file_str)\n        expected_output='\\n@@ -1,10 +1,10 @@ \\n def foo():\\n     line(0)\\n     line(1)\\n     line(2)\\n     line(3)\\n     line(4)\\n     line(5)\\n     line(6)\\n     line(7)\\n-    line(8)\\n+    new_line(8)'\n        assert actual_output == expected_output\n\n        get_settings(use_context=False).config.allow_dynamic_context = False\n        actual_output2 = extend_patch(original_file_str, patch_str,\n                                     patch_extra_lines_before=1, patch_extra_lines_after=1)\n        expected_output_no_dynamic_context = '\\n@@ -9,2 +9,2 @@ def foo():\\n     line(7)\\n-    line(8)\\n+    new_line(8)'\n        assert actual_output2 == expected_output_no_dynamic_context\n\n        get_settings(use_context=False).config.allow_dynamic_context = False\n        actual_output3 = extend_patch(original_file_str, patch_str,\n                                     patch_extra_lines_before=3, patch_extra_lines_after=3)\n        expected_output_no_dynamic_context = '\\n@@ -7,4 +7,4 @@ def foo():\\n     line(5)\\n     line(6)\\n     line(7)\\n-    line(8)\\n+    new_line(8)'\n        assert actual_output3 == expected_output_no_dynamic_context\n\n\n\n\n\nclass TestExtendedPatchMoreLines:\n    class File:\n        def __init__(self, base_file, patch, head_file, filename, ai_file_summary=None):\n            self.base_file = base_file\n            self.patch = patch\n            self.head_file = head_file\n            self.filename = filename\n            self.ai_file_summary = ai_file_summary\n\n    @pytest.fixture\n    def token_handler(self):\n        # Create a TokenHandler instance with dummy data\n        th = TokenHandler(system=\"System prompt\", user=\"User prompt\")\n        th.prompt_tokens = 100\n        return th\n\n    @pytest.fixture\n    def pr_languages(self):\n        # Create a list of languages with files containing base_file and patch data\n        return [\n            {\n                'files': [\n                    self.File(base_file=\"line000\\nline00\\nline0\\nline1\\noriginal content\\nline2\\nline3\\nline4\\nline5\\nline6\\nline7\\nline8\\nline9\\nline10\",\n                              patch=\"@@ -5,5 +5,5 @@\\n-original content\\n+modified content\\n line2\\n line3\\n line4\\n line5\",\n                              head_file=\"line000\\nline00\\nline0\\nline1\\nmodified content\\nline2\\nline3\\nline4\\nline5\\nline6\\nline7\\nline8\\nline9\\nline10\",\n                              filename=\"file1\"),\n                    self.File(base_file=\"original content\\nline2\\nline3\\nline4\\nline5\\nline6\\nline7\\nline8\\nline9\\nline10\",\n                              patch=\"@@ -6,5 +6,5 @@\\nline6\\nline7\\nline8\\n-line9\\n+modified line9\\nline10\",\n                              head_file=\"original content\\nline2\\nline3\\nline4\\nline5\\nline6\\nline7\\nline8\\nmodified line9\\nline10\",\n                              filename=\"file2\")\n                ]\n            }\n        ]\n\n    def test_extend_patches_with_extra_lines(self, token_handler, pr_languages):\n        patches_extended_no_extra_lines, total_tokens, patches_extended_tokens = pr_generate_extended_diff(\n            pr_languages, token_handler, add_line_numbers_to_hunks=False,\n            patch_extra_lines_before=0,\n            patch_extra_lines_after=0\n        )\n\n        # Check that with no extra lines, the patches are the same as the original patches\n        p0 = patches_extended_no_extra_lines[0].strip()\n        p1 = patches_extended_no_extra_lines[1].strip()\n        assert p0 == \"## File: 'file1'\\n\\n\" + pr_languages[0]['files'][0].patch.strip()\n        assert p1 == \"## File: 'file2'\\n\\n\" + pr_languages[0]['files'][1].patch.strip()\n\n        patches_extended_with_extra_lines, total_tokens, patches_extended_tokens = pr_generate_extended_diff(\n            pr_languages, token_handler, add_line_numbers_to_hunks=False,\n            patch_extra_lines_before=2,\n            patch_extra_lines_after=1\n        )\n\n        p0_extended = patches_extended_with_extra_lines[0].strip()\n        assert p0_extended == \"## File: 'file1'\\n\\n@@ -3,8 +3,8 @@ \\n line0\\n line1\\n-original content\\n+modified content\\n line2\\n line3\\n line4\\n line5\\n line6\"\n\nclass TestLoadLargeDiff:\n    def test_no_newline(self):\n        patch = load_large_diff(\"test.py\",\n                                \"\"\"\\\n                                old content 1\n                                some new content\n                                another line\n                                \"\"\",\n                                \"\"\"\n                                old content 1\n                                old content 2\"\"\")\n\n        patch_expected=\"\"\"\\\n--- \n+++ \n@@ -1,3 +1,3 @@\n-\n                                 old content 1\n-                                old content 2\n+                                some new content\n+                                another line\n\"\"\"\n        assert patch == patch_expected\n\n    def test_empty_inputs(self):\n        assert load_large_diff(\"test.py\", \"\", \"\") == \"\"\n        assert load_large_diff(\"test.py\", None, None) == \"\"\n        assert (load_large_diff(\"test.py\", \"content\\n\", \"\") ==\n                '--- \\n+++ \\n@@ -1 +1 @@\\n-\\n+content\\n')"}
{"type": "test_file", "path": "tests/unittest/test_clip_tokens.py", "content": "\n# Generated by CodiumAI\n\nimport pytest\n\nfrom pr_agent.algo.utils import clip_tokens\n\n\nclass TestClipTokens:\n    def test_clip(self):\n        text = \"line1\\nline2\\nline3\\nline4\\nline5\\nline6\"\n        max_tokens = 25\n        result = clip_tokens(text, max_tokens)\n        assert result == text\n\n        max_tokens = 10\n        result = clip_tokens(text, max_tokens)\n        expected_results = 'line1\\nline2\\nline3\\n\\n...(truncated)'\n        assert result == expected_results\n"}
{"type": "test_file", "path": "tests/unittest/test_handle_patch_deletions.py", "content": "# Generated by CodiumAI\nimport logging\n\nfrom pr_agent.algo.git_patch_processing import handle_patch_deletions\nfrom pr_agent.config_loader import get_settings\n\n\"\"\"\nCode Analysis\n\nObjective:\nThe objective of the function is to handle entire file or deletion patches and return the patch after omitting the\ndeletion hunks.\n\nInputs:\n- patch: a string representing the patch to be handled\n- original_file_content_str: a string representing the original content of the file\n- new_file_content_str: a string representing the new content of the file\n- file_name: a string representing the name of the file\n\nFlow:\n- If new_file_content_str is empty, set patch to \"File was deleted\" and return it\n- Otherwise, split patch into lines and omit the deletion hunks using the omit_deletion_hunks function\n- If the resulting patch is different from the original patch, log a message and set patch to the new patch\n- Return the resulting patch\n\nOutputs:\n- A string representing the patch after omitting the deletion hunks\n\nAdditional aspects:\n- The function uses the settings from the configuration files to determine the verbosity level of the logging messages\n- The omit_deletion_hunks function is called to remove the deletion hunks from the patch\n- The function handles the case where the new_file_content_str is empty by setting the patch to \"File was deleted\"\n\"\"\"\n\n\nclass TestHandlePatchDeletions:\n    # Tests that handle_patch_deletions returns the original patch when new_file_content_str is not empty\n    def test_handle_patch_deletions_happy_path_new_file_content_exists(self):\n        patch = '--- a/file.py\\n+++ b/file.py\\n@@ -1,2 +1,2 @@\\n-foo\\n-bar\\n+baz\\n'\n        original_file_content_str = 'foo\\nbar\\n'\n        new_file_content_str = 'foo\\nbaz\\n'\n        file_name = 'file.py'\n        assert handle_patch_deletions(patch, original_file_content_str, new_file_content_str,\n                                      file_name) == patch.rstrip()\n\n    # Tests that handle_patch_deletions returns 'File was deleted' when new_file_content_str is empty\n    def test_handle_patch_deletions_edge_case_new_file_content_empty(self):\n        patch = '--- a/file.py\\n+++ b/file.py\\n@@ -1,2 +1,2 @@\\n-foo\\n-bar\\n'\n        original_file_content_str = 'foo\\nbar\\n'\n        new_file_content_str = ''\n        file_name = 'file.py'\n        assert handle_patch_deletions(patch, original_file_content_str, new_file_content_str,\n                                      file_name) is None\n\n    # Tests that handle_patch_deletions returns the original patch when patch and patch_new are equal\n    def test_handle_patch_deletions_edge_case_patch_and_patch_new_are_equal(self):\n        patch = '--- a/file.py\\n+++ b/file.py\\n@@ -1,2 +1,2 @@\\n-foo\\n-bar\\n'\n        original_file_content_str = 'foo\\nbar\\n'\n        new_file_content_str = 'foo\\nbar\\n'\n        file_name = 'file.py'\n        assert handle_patch_deletions(patch, original_file_content_str, new_file_content_str,\n                                      file_name).rstrip() == patch.rstrip()\n\n    # Tests that handle_patch_deletions returns the modified patch when patch and patch_new are not equal\n    def test_handle_patch_deletions_edge_case_patch_and_patch_new_are_not_equal(self):\n        patch = '--- a/file.py\\n+++ b/file.py\\n@@ -1,2 +1,2 @@\\n-foo\\n-bar\\n'\n        original_file_content_str = 'foo\\nbar\\n'\n        new_file_content_str = 'foo\\nbaz\\n'\n        file_name = 'file.py'\n        expected_patch = '--- a/file.py\\n+++ b/file.py\\n@@ -1,2 +1,2 @@\\n-foo\\n-bar'\n        assert handle_patch_deletions(patch, original_file_content_str, new_file_content_str,\n                                      file_name) == expected_patch\n"}
{"type": "test_file", "path": "tests/unittest/test_github_action_output.py", "content": "import json\nimport os\n\nfrom pr_agent.algo.utils import get_settings, github_action_output\n\n\nclass TestGitHubOutput:\n    def test_github_action_output_enabled(self, monkeypatch, tmp_path):\n        get_settings().set('GITHUB_ACTION_CONFIG.ENABLE_OUTPUT', True)\n        monkeypatch.setenv('GITHUB_OUTPUT', str(tmp_path / 'output'))\n        output_data = {'key1': {'value1': 1, 'value2': 2}}\n        key_name = 'key1'\n\n        github_action_output(output_data, key_name)\n\n        with open(str(tmp_path / 'output'), 'r') as f:\n            env_value = f.read()\n\n        actual_key = env_value.split('=')[0]\n        actual_data = json.loads(env_value.split('=')[1])\n\n        assert actual_key == key_name\n        assert actual_data == output_data[key_name]\n\n    def test_github_action_output_disabled(self, monkeypatch, tmp_path):\n        get_settings().set('GITHUB_ACTION_CONFIG.ENABLE_OUTPUT', False)\n        monkeypatch.setenv('GITHUB_OUTPUT', str(tmp_path / 'output'))\n        output_data = {'key1': {'value1': 1, 'value2': 2}}\n        key_name = 'key1'\n\n        github_action_output(output_data, key_name)\n\n        assert not os.path.exists(str(tmp_path / 'output'))\n\n    def test_github_action_output_notset(self, monkeypatch, tmp_path):\n        # not set config\n        monkeypatch.setenv('GITHUB_OUTPUT', str(tmp_path / 'output'))\n        output_data = {'key1': {'value1': 1, 'value2': 2}}\n        key_name = 'key1'\n\n        github_action_output(output_data, key_name)\n\n        assert not os.path.exists(str(tmp_path / 'output'))\n\n    def test_github_action_output_error_case(self, monkeypatch, tmp_path):\n        monkeypatch.setenv('GITHUB_OUTPUT', str(tmp_path / 'output'))\n        output_data = None # invalid data\n        key_name = 'key1'\n\n        github_action_output(output_data, key_name)\n\n        assert not os.path.exists(str(tmp_path / 'output'))\n"}
{"type": "test_file", "path": "tests/unittest/test_codecommit_client.py", "content": "from unittest.mock import MagicMock\n\nfrom pr_agent.git_providers.codecommit_client import CodeCommitClient\n\n\nclass TestCodeCommitProvider:\n    def test_get_differences(self):\n        # Create a mock CodeCommitClient instance and codecommit_client member\n        api = CodeCommitClient()\n        api.boto_client = MagicMock()\n\n        # Mock the response from the AWS client for get_differences method\n        api.boto_client.get_paginator.return_value.paginate.return_value = [\n            {\n                \"differences\": [\n                    {\n                        \"beforeBlob\": {\n                            \"path\": \"file1.py\",\n                            \"blobId\": \"291b15c3ab4219e43a5f4f9091e5a97ee9d7400b\",\n                        },\n                        \"afterBlob\": {\n                            \"path\": \"file1.py\",\n                            \"blobId\": \"46ad86582da03cc34c804c24b17976571bca1eba\",\n                        },\n                        \"changeType\": \"M\",\n                    },\n                    {\n                        \"beforeBlob\": {\"path\": \"\", \"blobId\": \"\"},\n                        \"afterBlob\": {\n                            \"path\": \"file2.py\",\n                            \"blobId\": \"2404c7874fcbd684d6779c1420072f088647fd79\",\n                        },\n                        \"changeType\": \"A\",\n                    },\n                    {\n                        \"beforeBlob\": {\n                            \"path\": \"file3.py\",\n                            \"blobId\": \"9af7989045ce40e9478ebb8089dfbadac19a9cde\",\n                        },\n                        \"afterBlob\": {\"path\": \"\", \"blobId\": \"\"},\n                        \"changeType\": \"D\",\n                    },\n                    {\n                        \"beforeBlob\": {\n                            \"path\": \"file5.py\",\n                            \"blobId\": \"738e36eec120ef9d6393a149252698f49156d5b4\",\n                        },\n                        \"afterBlob\": {\n                            \"path\": \"file6.py\",\n                            \"blobId\": \"faecdb85f7ba199df927a783b261378a1baeca85\",\n                        },\n                        \"changeType\": \"R\",\n                    },\n                ]\n            }\n        ]\n\n        diffs = api.get_differences(\"my_test_repo\", \"commit1\", \"commit2\")\n\n        assert len(diffs) == 4\n        assert diffs[0].before_blob_path == \"file1.py\"\n        assert diffs[0].before_blob_id == \"291b15c3ab4219e43a5f4f9091e5a97ee9d7400b\"\n        assert diffs[0].after_blob_path == \"file1.py\"\n        assert diffs[0].after_blob_id == \"46ad86582da03cc34c804c24b17976571bca1eba\"\n        assert diffs[0].change_type == \"M\"\n        assert diffs[1].before_blob_path == \"\"\n        assert diffs[1].before_blob_id == \"\"\n        assert diffs[1].after_blob_path == \"file2.py\"\n        assert diffs[1].after_blob_id == \"2404c7874fcbd684d6779c1420072f088647fd79\"\n        assert diffs[1].change_type == \"A\"\n        assert diffs[2].before_blob_path == \"file3.py\"\n        assert diffs[2].before_blob_id == \"9af7989045ce40e9478ebb8089dfbadac19a9cde\"\n        assert diffs[2].after_blob_path == \"\"\n        assert diffs[2].after_blob_id == \"\"\n        assert diffs[2].change_type == \"D\"\n        assert diffs[3].before_blob_path == \"file5.py\"\n        assert diffs[3].before_blob_id == \"738e36eec120ef9d6393a149252698f49156d5b4\"\n        assert diffs[3].after_blob_path == \"file6.py\"\n        assert diffs[3].after_blob_id == \"faecdb85f7ba199df927a783b261378a1baeca85\"\n        assert diffs[3].change_type == \"R\"\n\n    def test_get_file(self):\n        # Create a mock CodeCommitClient instance and codecommit_client member\n        api = CodeCommitClient()\n        api.boto_client = MagicMock()\n\n        # Mock the response from the AWS client for get_pull_request method\n        # def get_file(self, repo_name: str, file_path: str, sha_hash: str):\n        api.boto_client.get_file.return_value = {\n            \"commitId\": \"6335d6d4496e8d50af559560997604bb03abc122\",\n            \"blobId\": \"c172209495d7968a8fdad76469564fb708460bc1\",\n            \"filePath\": \"requirements.txt\",\n            \"fileSize\": 65,\n            \"fileContent\": b\"boto3==1.28.25\\ndynaconf==3.1.12\\nfastapi==0.99.0\\nPyGithub==1.59.*\\n\",\n        }\n\n        repo_name = \"my_test_repo\"\n        file_path = \"requirements.txt\"\n        sha_hash = \"84114a356ece1e5b7637213c8e486fea7c254656\"\n        content = api.get_file(repo_name, file_path, sha_hash)\n\n        assert len(content) == 65\n        assert content == b\"boto3==1.28.25\\ndynaconf==3.1.12\\nfastapi==0.99.0\\nPyGithub==1.59.*\\n\"\n        assert content.decode(\"utf-8\") == \"boto3==1.28.25\\ndynaconf==3.1.12\\nfastapi==0.99.0\\nPyGithub==1.59.*\\n\"\n\n    def test_get_pr(self):\n        # Create a mock CodeCommitClient instance and codecommit_client member\n        api = CodeCommitClient()\n        api.boto_client = MagicMock()\n\n        # Mock the response from the AWS client for get_pull_request method\n        api.boto_client.get_pull_request.return_value = {\n            \"pullRequest\": {\n                \"pullRequestId\": \"321\",\n                \"title\": \"My PR\",\n                \"description\": \"My PR description\",\n                \"pullRequestTargets\": [\n                    {\n                        \"sourceCommit\": \"commit1\",\n                        \"sourceReference\": \"branch1\",\n                        \"destinationCommit\": \"commit2\",\n                        \"destinationReference\": \"branch2\",\n                        \"repositoryName\": \"my_test_repo\",\n                    }\n                ],\n            }\n        }\n\n        pr = api.get_pr(\"my_test_repo\", 321)\n\n        assert pr.title == \"My PR\"\n        assert pr.description == \"My PR description\"\n        assert len(pr.targets) == 1\n        assert pr.targets[0].source_commit == \"commit1\"\n        assert pr.targets[0].source_branch == \"branch1\"\n        assert pr.targets[0].destination_commit == \"commit2\"\n        assert pr.targets[0].destination_branch == \"branch2\"\n"}
{"type": "test_file", "path": "tests/health_test/main.py", "content": "import argparse\nimport asyncio\nimport copy\nimport os\nfrom pathlib import Path\n\nfrom starlette_context import request_cycle_context, context\n\nfrom pr_agent.cli import run_command\nfrom pr_agent.config_loader import get_settings, global_settings\n\nfrom pr_agent.agent.pr_agent import PRAgent, commands\nfrom pr_agent.log import get_logger, setup_logger\nfrom tests.e2e_tests import e2e_utils\n\nlog_level = os.environ.get(\"LOG_LEVEL\", \"INFO\")\nsetup_logger(log_level)\n\n\nasync def run_async():\n    pr_url = os.getenv('TEST_PR_URL', 'https://github.com/Codium-ai/pr-agent/pull/1385')\n\n    get_settings().set(\"config.git_provider\", \"github\")\n    get_settings().set(\"config.publish_output\", False)\n    get_settings().set(\"config.fallback_models\", [])\n\n    agent = PRAgent()\n    try:\n        # Run the 'describe' command\n        get_logger().info(f\"\\nSanity check for the 'describe' command...\")\n        original_settings = copy.deepcopy(get_settings())\n        await agent.handle_request(pr_url, ['describe'])\n        pr_header_body = dict(get_settings().data)['artifact']\n        assert pr_header_body.startswith('###') and 'PR Type' in pr_header_body and 'Description' in pr_header_body\n        context['settings'] = copy.deepcopy(original_settings) # Restore settings state after each test to prevent test interference\n        get_logger().info(\"PR description generated successfully\\n\")\n\n        # Run the 'review' command\n        get_logger().info(f\"\\nSanity check for the 'review' command...\")\n        original_settings = copy.deepcopy(get_settings())\n        await agent.handle_request(pr_url, ['review'])\n        pr_review_body = dict(get_settings().data)['artifact']\n        assert pr_review_body.startswith('##') and 'PR Reviewer Guide' in pr_review_body\n        context['settings'] = copy.deepcopy(original_settings)  # Restore settings state after each test to prevent test interference\n        get_logger().info(\"PR review generated successfully\\n\")\n\n        # Run the 'improve' command\n        get_logger().info(f\"\\nSanity check for the 'improve' command...\")\n        original_settings = copy.deepcopy(get_settings())\n        await agent.handle_request(pr_url, ['improve'])\n        pr_improve_body = dict(get_settings().data)['artifact']\n        assert pr_improve_body.startswith('##') and 'PR Code Suggestions' in pr_improve_body\n        context['settings'] = copy.deepcopy(original_settings)  # Restore settings state after each test to prevent test interference\n        get_logger().info(\"PR improvements generated successfully\\n\")\n\n        get_logger().info(f\"\\n\\n========\\nHealth test passed successfully\\n========\")\n\n    except Exception as e:\n        get_logger().exception(f\"\\n\\n========\\nHealth test failed\\n========\")\n        raise e\n\n\ndef run():\n    with request_cycle_context({}):\n        context['settings'] = copy.deepcopy(global_settings)\n        asyncio.run(run_async())\n\n\nif __name__ == '__main__':\n    run()\n"}
{"type": "test_file", "path": "tests/e2e_tests/test_github_app.py", "content": "import os\nimport re\nimport time\nfrom datetime import datetime\n\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers import get_git_provider\nfrom pr_agent.log import get_logger, setup_logger\nfrom tests.e2e_tests.e2e_utils import (FILE_PATH,\n                                       IMPROVE_START_WITH_REGEX_PATTERN,\n                                       NEW_FILE_CONTENT, NUM_MINUTES,\n                                       PR_HEADER_START_WITH, REVIEW_START_WITH)\n\nlog_level = os.environ.get(\"LOG_LEVEL\", \"INFO\")\nsetup_logger(log_level)\nlogger = get_logger()\n\n\ndef test_e2e_run_github_app():\n    \"\"\"\n    What we want to do:\n    (1) open a PR in a repo 'https://github.com/Codium-ai/pr-agent-tests'\n    (2) wait for 5 minutes until the PR is processed by the GitHub app\n    (3) check that the relevant tools have been executed\n    \"\"\"\n    base_branch = \"main\"  # or any base branch you want\n    new_branch = f\"github_app_e2e_test-{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}\"\n    repo_url = 'Codium-ai/pr-agent-tests'\n    get_settings().config.git_provider = \"github\"\n    git_provider = get_git_provider()()\n    github_client = git_provider.github_client\n    repo = github_client.get_repo(repo_url)\n\n    try:\n        # Create a new branch from the base branch\n        source = repo.get_branch(base_branch)\n        logger.info(f\"Creating a new branch {new_branch} from {base_branch}\")\n        repo.create_git_ref(ref=f\"refs/heads/{new_branch}\", sha=source.commit.sha)\n\n        # Get the file you want to edit\n        file = repo.get_contents(FILE_PATH, ref=base_branch)\n        # content = file.decoded_content.decode()\n\n        # Update the file content\n        logger.info(f\"Updating the file {FILE_PATH}\")\n        commit_message = \"update cli_pip.py\"\n        repo.update_file(\n            file.path,\n            commit_message,\n            NEW_FILE_CONTENT,\n            file.sha,\n            branch=new_branch\n        )\n\n        # Create a pull request\n        logger.info(f\"Creating a pull request from {new_branch} to {base_branch}\")\n        pr = repo.create_pull(\n            title=new_branch,\n            body=\"update cli_pip.py\",\n            head=new_branch,\n            base=base_branch\n        )\n\n        # check every 1 minute, for 5, minutes if the PR has all the tool results\n        for i in range(NUM_MINUTES):\n            logger.info(f\"Waiting for the PR to get all the tool results...\")\n            time.sleep(60)\n            logger.info(f\"Checking the PR {pr.html_url} after {i + 1} minute(s)\")\n            pr.update()\n            pr_header_body = pr.body\n            comments = list(pr.get_issue_comments())\n            if len(comments) == 2:\n                comments_body = [comment.body for comment in comments]\n                assert pr_header_body.startswith(PR_HEADER_START_WITH), \"DESCRIBE feedback is invalid\"\n                assert comments_body[0].startswith(REVIEW_START_WITH), \"REVIEW feedback is invalid\"\n                assert re.match(IMPROVE_START_WITH_REGEX_PATTERN, comments_body[1]), \"IMPROVE feedback is invalid\"\n                break\n            else:\n                logger.info(f\"Waiting for the PR to get all the tool results. {i + 1} minute(s) passed\")\n        else:\n            assert False, f\"After {NUM_MINUTES} minutes, the PR did not get all the tool results\"\n\n        # cleanup - delete the branch\n        logger.info(f\"Deleting the branch {new_branch}\")\n        repo.get_git_ref(f\"heads/{new_branch}\").delete()\n\n        # If we reach here, the test is successful\n        logger.info(f\"Succeeded in running e2e test for GitHub app on the PR {pr.html_url}\")\n    except Exception as e:\n        logger.error(f\"Failed to run e2e test for GitHub app: {e}\")\n        # delete the branch\n        logger.info(f\"Deleting the branch {new_branch}\")\n        repo.get_git_ref(f\"heads/{new_branch}\").delete()\n        assert False\n\n\nif __name__ == '__main__':\n    test_e2e_run_github_app()\n"}
{"type": "test_file", "path": "tests/unittest/test_file_filter.py", "content": "import pytest\n\nfrom pr_agent.algo.file_filter import filter_ignored\nfrom pr_agent.config_loader import global_settings\n\n\nclass TestIgnoreFilter:\n    def test_no_ignores(self):\n        \"\"\"\n        Test no files are ignored when no patterns are specified.\n        \"\"\"\n        files = [\n            type('', (object,), {'filename': 'file1.py'})(),\n            type('', (object,), {'filename': 'file2.java'})(),\n            type('', (object,), {'filename': 'file3.cpp'})(),\n            type('', (object,), {'filename': 'file4.py'})(),\n            type('', (object,), {'filename': 'file5.py'})()\n        ]\n        assert filter_ignored(files) == files, \"Expected all files to be returned when no ignore patterns are given.\"\n\n    def test_glob_ignores(self, monkeypatch):\n        \"\"\"\n        Test files are ignored when glob patterns are specified.\n        \"\"\"\n        monkeypatch.setattr(global_settings.ignore, 'glob', ['*.py'])\n\n        files = [\n            type('', (object,), {'filename': 'file1.py'})(),\n            type('', (object,), {'filename': 'file2.java'})(),\n            type('', (object,), {'filename': 'file3.cpp'})(),\n            type('', (object,), {'filename': 'file4.py'})(),\n            type('', (object,), {'filename': 'file5.py'})()\n        ]\n        expected = [\n            files[1],\n            files[2]\n        ]\n\n        filtered_files = filter_ignored(files)\n        assert filtered_files == expected, f\"Expected {[file.filename for file in expected]}, but got {[file.filename for file in filtered_files]}.\"\n\n    def test_regex_ignores(self, monkeypatch):\n        \"\"\"\n        Test files are ignored when regex patterns are specified.\n        \"\"\"\n        monkeypatch.setattr(global_settings.ignore, 'regex', ['^file[2-4]\\..*$'])\n\n        files = [\n            type('', (object,), {'filename': 'file1.py'})(),\n            type('', (object,), {'filename': 'file2.java'})(),\n            type('', (object,), {'filename': 'file3.cpp'})(),\n            type('', (object,), {'filename': 'file4.py'})(),\n            type('', (object,), {'filename': 'file5.py'})()\n        ]\n        expected = [\n            files[0],\n            files[4]\n        ]\n\n        filtered_files = filter_ignored(files)\n        assert filtered_files == expected, f\"Expected {[file.filename for file in expected]}, but got {[file.filename for file in filtered_files]}.\"\n\n    def test_invalid_regex(self, monkeypatch):\n        \"\"\"\n        Test invalid patterns are quietly ignored.\n        \"\"\"\n        monkeypatch.setattr(global_settings.ignore, 'regex', ['(((||', '^file[2-4]\\..*$'])\n\n        files = [\n            type('', (object,), {'filename': 'file1.py'})(),\n            type('', (object,), {'filename': 'file2.java'})(),\n            type('', (object,), {'filename': 'file3.cpp'})(),\n            type('', (object,), {'filename': 'file4.py'})(),\n            type('', (object,), {'filename': 'file5.py'})()\n        ]\n        expected = [\n            files[0],\n            files[4]\n        ]\n\n        filtered_files = filter_ignored(files)\n        assert filtered_files == expected, f\"Expected {[file.filename for file in expected]}, but got {[file.filename for file in filtered_files]}.\"\n"}
{"type": "test_file", "path": "tests/unittest/test_delete_hunks.py", "content": "# Generated by CodiumAI\n\nfrom pr_agent.algo.git_patch_processing import omit_deletion_hunks\n\n\"\"\"\nCode Analysis\n\nObjective:\nThe objective of the \"omit_deletion_hunks\" function is to remove deletion hunks from a patch file and return only the\nadded lines.\n\nInputs:\n- \"patch_lines\": a list of strings representing the lines of a patch file.\n\nFlow:\n- Initialize empty lists \"temp_hunk\" and \"added_patched\", and boolean variables \"add_hunk\" and \"inside_hunk\".\n- Compile a regular expression pattern to match hunk headers.\n- Iterate through each line in \"patch_lines\".\n- If the line starts with \"@@\", match the line with the hunk header pattern, finish the previous hunk if necessary,\nand append the line to \"temp_hunk\".\n- If the line does not start with \"@@\", append the line to \"temp_hunk\", check if it is an added line, and set\n\"add_hunk\" to True if it is.\n- If the function reaches the end of \"patch_lines\" and there is an unfinished hunk with added lines, append it to\n\"added_patched\".\n- Join the lines in \"added_patched\" with newline characters and return the resulting string.\n\nOutputs:\n- A string representing the added lines in the patch file.\n\nAdditional aspects:\n- The function only considers hunks with added lines and ignores hunks with deleted lines.\n- The function assumes that the input patch file is well-formed and follows the unified diff format.\n\"\"\"\n\n\nclass TestOmitDeletionHunks:\n    # Tests that the function correctly handles a simple patch containing only additions\n    def test_simple_patch_additions(self):\n        patch_lines = ['@@ -1,0 +1,1 @@\\n', '+added line\\n']\n        expected_output = '@@ -1,0 +1,1 @@\\n\\n+added line\\n'\n        assert omit_deletion_hunks(patch_lines) == expected_output\n\n    # Tests that the function correctly omits deletion hunks and concatenates multiple hunks in a patch.\n    def test_patch_multiple_hunks(self):\n        patch_lines = ['@@ -1,0 +1,1 @@\\n', '-deleted line', '+added line\\n', '@@ -2,0 +3,1 @@\\n', '-deleted line\\n',\n                       '-another deleted line\\n']\n        expected_output = '@@ -1,0 +1,1 @@\\n\\n-deleted line\\n+added line\\n'\n        assert omit_deletion_hunks(patch_lines) == expected_output\n\n    # Tests that the function correctly omits deletion lines from the patch when there are no additions or context\n    # lines.\n    def test_patch_only_deletions(self):\n        patch_lines = ['@@ -1,1 +1,0 @@\\n', '-deleted line\\n']\n        expected_output = ''\n        assert omit_deletion_hunks(patch_lines) == expected_output\n\n        # Additional deletion lines\n        patch_lines = ['@@ -1,1 +1,0 @@\\n', '-deleted line\\n', '-another deleted line\\n']\n        expected_output = ''\n        assert omit_deletion_hunks(patch_lines) == expected_output\n\n        # Additional context lines\n        patch_lines = ['@@ -1,1 +1,0 @@\\n', '-deleted line\\n', '-another deleted line\\n', 'context line 1\\n',\n                       'context line 2\\n', 'context line 3\\n']\n        expected_output = ''\n        assert omit_deletion_hunks(patch_lines) == expected_output\n\n    # Tests that the function correctly handles an empty patch\n    def test_empty_patch(self):\n        patch_lines = []\n        expected_output = ''\n        assert omit_deletion_hunks(patch_lines) == expected_output\n\n    # Tests that the function correctly handles a patch containing only one hunk\n    def test_patch_one_hunk(self):\n        patch_lines = ['@@ -1,0 +1,1 @@\\n', '+added line\\n']\n        expected_output = '@@ -1,0 +1,1 @@\\n\\n+added line\\n'\n        assert omit_deletion_hunks(patch_lines) == expected_output\n\n    # Tests that the function correctly handles a patch containing only deletions and no additions\n    def test_patch_deletions_no_additions(self):\n        patch_lines = ['@@ -1,1 +1,0 @@\\n', '-deleted line\\n']\n        expected_output = ''\n        assert omit_deletion_hunks(patch_lines) == expected_output\n"}
{"type": "test_file", "path": "tests/unittest/test_language_handler.py", "content": "\n# Generated by CodiumAI\n\nfrom pr_agent.algo.language_handler import sort_files_by_main_languages\n\n\"\"\"\nCode Analysis\n\nObjective:\nThe objective of the function is to sort a list of files by their main language, putting the files that are in the main\nlanguage first and the rest of the files after. It takes in a dictionary of languages and their sizes, and a list of\nfiles.\n\nInputs:\n- languages: a dictionary containing the languages and their sizes\n- files: a list of files\n\nFlow:\n1. Sort the languages by their size in descending order\n2. Get all extensions for the languages\n3. Filter out files with bad extensions\n4. Sort files by their extension, putting the files that are in the main extension first and the rest of the files after\n5. Map languages_sorted to their respective files\n6. Append the files to the files_sorted list\n7. Append the rest of the files to the files_sorted list under the \"Other\" language category\n8. Return the files_sorted list\n\nOutputs:\n- files_sorted: a list of dictionaries containing the language and its respective files\n\nAdditional aspects:\n- The function uses a language_extension_map dictionary to map the languages to their respective extensions\n- The function uses the filter_bad_extensions function to filter out files with bad extensions\n- The function uses a rest_files dictionary to store the files that do not belong to any of the main extensions\n\"\"\"\n\n\nclass TestSortFilesByMainLanguages:\n    # Tests that files are sorted by main language, with files in main language first and the rest after\n    def test_happy_path_sort_files_by_main_languages(self):\n        languages = {'Python': 10, 'Java': 5, 'C++': 3}\n        files = [\n            type('', (object,), {'filename': 'file1.py'})(),\n            type('', (object,), {'filename': 'file2.java'})(),\n            type('', (object,), {'filename': 'file3.cpp'})(),\n            type('', (object,), {'filename': 'file4.py'})(),\n            type('', (object,), {'filename': 'file5.py'})()\n        ]\n        expected_output = [\n            {'language': 'Python', 'files': [files[0], files[3], files[4]]},\n            {'language': 'Java', 'files': [files[1]]},\n            {'language': 'C++', 'files': [files[2]]},\n            {'language': 'Other', 'files': []}\n        ]\n        assert sort_files_by_main_languages(languages, files) == expected_output\n\n    # Tests that function handles empty languages dictionary\n    def test_edge_case_empty_languages(self):\n        languages = {}\n        files = [\n            type('', (object,), {'filename': 'file1.py'})(),\n            type('', (object,), {'filename': 'file2.java'})()\n        ]\n        expected_output = [{'language': 'Other', 'files': files}]\n        assert sort_files_by_main_languages(languages, files) == expected_output\n\n    # Tests that function handles empty files list\n    def test_edge_case_empty_files(self):\n        languages = {'Python': 10, 'Java': 5}\n        files = []\n        expected_output = [\n            {'language': 'Other', 'files': []}\n        ]\n        assert sort_files_by_main_languages(languages, files) == expected_output\n\n    # Tests that function handles languages with no extensions\n    def test_edge_case_languages_with_no_extensions(self):\n        languages = {'Python': 10, 'Java': 5, 'C++': 3}\n        files = [\n            type('', (object,), {'filename': 'file1.py'})(),\n            type('', (object,), {'filename': 'file2.java'})(),\n            type('', (object,), {'filename': 'file3.cpp'})()\n        ]\n        expected_output = [\n            {'language': 'Python', 'files': [files[0]]},\n            {'language': 'Java', 'files': [files[1]]},\n            {'language': 'C++', 'files': [files[2]]},\n            {'language': 'Other', 'files': []}\n        ]\n        assert sort_files_by_main_languages(languages, files) == expected_output\n\n    # Tests the behavior of the function when all files have bad extensions and only one new valid file is added.\n    def test_edge_case_files_with_bad_extensions_only(self):\n        languages = {'Python': 10, 'Java': 5, 'C++': 3}\n        files = [\n            type('', (object,), {'filename': 'file1.csv'})(),\n            type('', (object,), {'filename': 'file2.pdf'})(),\n            type('', (object,), {'filename': 'file3.py'})()  # new valid file\n        ]\n        expected_output = [{'language': 'Python', 'files': [files[2]]}, {'language': 'Other', 'files': []}]\n        assert sort_files_by_main_languages(languages, files) == expected_output\n\n    # Tests general behaviour of function\n    def test_general_behaviour_sort_files_by_main_languages(self):\n        languages = {'Python': 10, 'Java': 5, 'C++': 3}\n        files = [\n            type('', (object,), {'filename': 'file1.py'})(),\n            type('', (object,), {'filename': 'file2.java'})(),\n            type('', (object,), {'filename': 'file3.cpp'})(),\n            type('', (object,), {'filename': 'file4.py'})(),\n            type('', (object,), {'filename': 'file5.py'})(),\n            type('', (object,), {'filename': 'file6.py'})(),\n            type('', (object,), {'filename': 'file7.java'})(),\n            type('', (object,), {'filename': 'file8.cpp'})(),\n            type('', (object,), {'filename': 'file9.py'})()\n        ]\n        expected_output = [\n            {'language': 'Python', 'files': [files[0], files[3], files[4], files[5], files[8]]},\n            {'language': 'Java', 'files': [files[1], files[6]]},\n            {'language': 'C++', 'files': [files[2], files[7]]},\n            {'language': 'Other', 'files': []}\n        ]\n        assert sort_files_by_main_languages(languages, files) == expected_output\n"}
{"type": "test_file", "path": "tests/unittest/test_convert_to_markdown.py", "content": "# Generated by CodiumAI\nfrom pr_agent.algo.utils import PRReviewHeader, convert_to_markdown_v2\nfrom pr_agent.tools.pr_description import insert_br_after_x_chars\n\n\"\"\"\nCode Analysis\n\nObjective:\nThe objective of the 'convert_to_markdown' function is to convert a dictionary of data into a markdown-formatted text.\nThe function takes in a dictionary as input and recursively iterates through its keys and values to generate the\nmarkdown text.\n\nInputs:\n- A dictionary of data containing information about a pull request.\n\nFlow:\n- Initialize an empty string variable 'markdown_text'.\n- Create a dictionary 'emojis' containing emojis for each key in the input dictionary.\n- Iterate through the input dictionary:\n  - If the value is empty, continue to the next iteration.\n  - If the value is a dictionary, recursively call the 'convert_to_markdown' function with the value as input and\n  append the returned markdown text to 'markdown_text'.\n  - If the value is a list:\n    - If the key is 'code suggestions', add an additional line break to 'markdown_text'.\n    - Get the corresponding emoji for the key from the 'emojis' dictionary. If no emoji is found, use a dash.\n    - Append the emoji and key to 'markdown_text'.\n    - Iterate through the items in the list:\n      - If the item is a dictionary and the key is 'code suggestions', call the 'parse_code_suggestion' function with\n      the item as input and append the returned markdown text to 'markdown_text'.\n      - If the item is not empty, append it to 'markdown_text'.\n  - If the value is not 'n/a', get the corresponding emoji for the key from the 'emojis' dictionary. If no emoji is\n  found, use a dash. Append the emoji, key, and value to 'markdown_text'.\n- Return 'markdown_text'.\n\nOutputs:\n- A markdown-formatted string containing the information from the input dictionary.\n\nAdditional aspects:\n- The function uses recursion to handle nested dictionaries.\n- The 'parse_code_suggestion' function is called for items in the 'code suggestions' list.\n- The function uses emojis to add visual cues to the markdown text.\n\"\"\"\n\n\nclass TestConvertToMarkdown:\n    # Tests that the function works correctly with a simple dictionary input\n    def test_simple_dictionary_input(self):\n        input_data = {'review': {\n            'estimated_effort_to_review_[1-5]': '1, because the changes are minimal and straightforward, focusing on a single functionality addition.\\n',\n            'relevant_tests': 'No\\n', 'possible_issues': 'No\\n', 'security_concerns': 'No\\n'}}\n\n\n        expected_output = f'{PRReviewHeader.REGULAR.value} üîç\\n\\nHere are some key observations to aid the review process:\\n\\n<table>\\n<tr><td>‚è±Ô∏è&nbsp;<strong>Estimated effort to review</strong>: 1 üîµ‚ö™‚ö™‚ö™‚ö™</td></tr>\\n<tr><td>üß™&nbsp;<strong>No relevant tests</strong></td></tr>\\n<tr><td>&nbsp;<strong>Possible issues</strong>: No\\n</td></tr>\\n<tr><td>üîí&nbsp;<strong>No security concerns identified</strong></td></tr>\\n</table>'\n\n        assert convert_to_markdown_v2(input_data).strip() == expected_output.strip()\n\n    # Tests that the function works correctly with an empty dictionary input\n    def test_empty_dictionary_input(self):\n        input_data = {}\n\n        expected_output = ''\n\n\n        assert convert_to_markdown_v2(input_data).strip() == expected_output.strip()\n\n    def test_dictionary_with_empty_dictionaries(self):\n        input_data = {'review': {}}\n\n        expected_output = ''\n\n\n        assert convert_to_markdown_v2(input_data).strip() == expected_output.strip()\n\nclass TestBR:\n    def test_br1(self):\n        file_change_description = '- Imported `FilePatchInfo` and `EDIT_TYPE` from `pr_agent.algo.types` instead of `pr_agent.git_providers.git_provider`.'\n        file_change_description_br = insert_br_after_x_chars(file_change_description)\n        expected_output = ('<li>Imported <code>FilePatchInfo</code> and <code>EDIT_TYPE</code> from '\n                           '<code>pr_agent.algo.types</code> instead <br>of '\n                           '<code>pr_agent.git_providers.git_provider</code>.')\n        assert file_change_description_br == expected_output\n        # print(\"-----\")\n        # print(file_change_description_br)\n\n    def test_br2(self):\n        file_change_description = (\n            '- Created a - new -class `ColorPaletteResourcesCollection ColorPaletteResourcesCollection '\n            'ColorPaletteResourcesCollection ColorPaletteResourcesCollection`')\n        file_change_description_br = insert_br_after_x_chars(file_change_description)\n        expected_output = ('<li>Created a - new -class <code>ColorPaletteResourcesCollection </code><br><code>'\n                           'ColorPaletteResourcesCollection ColorPaletteResourcesCollection '\n                           '</code><br><code>ColorPaletteResourcesCollection</code>')\n        assert file_change_description_br == expected_output\n        # print(\"-----\")\n        # print(file_change_description_br)\n\n    def test_br3(self):\n        file_change_description = 'Created a new class `ColorPaletteResourcesCollection` which extends `AvaloniaDictionary<ThemeVariant, ColorPaletteResources>` and implements aaa'\n        file_change_description_br = insert_br_after_x_chars(file_change_description)\n        assert file_change_description_br == ('Created a new class <code>ColorPaletteResourcesCollection</code> which '\n                                              'extends <br><code>AvaloniaDictionary<ThemeVariant, ColorPaletteResources>'\n                                              '</code> and implements <br>aaa')\n        # print(\"-----\")\n        # print(file_change_description_br)\n"}
{"type": "test_file", "path": "tests/unittest/test_codecommit_provider.py", "content": "from unittest.mock import patch\n\nimport pytest\n\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\nfrom pr_agent.git_providers.codecommit_provider import (CodeCommitFile,\n                                                        CodeCommitProvider,\n                                                        PullRequestCCMimic)\n\n\nclass TestCodeCommitFile:\n    # Test that a CodeCommitFile object is created successfully with valid parameters.\n    # Generated by CodiumAI\n    def test_valid_parameters(self):\n        a_path = \"path/to/file_a\"\n        a_blob_id = \"12345\"\n        b_path = \"path/to/file_b\"\n        b_blob_id = \"67890\"\n        edit_type = EDIT_TYPE.ADDED\n\n        file = CodeCommitFile(a_path, a_blob_id, b_path, b_blob_id, edit_type)\n\n        assert file.a_path == a_path\n        assert file.a_blob_id == a_blob_id\n        assert file.b_path == b_path\n        assert file.b_blob_id == b_blob_id\n        assert file.edit_type == edit_type\n        assert file.filename == b_path\n\n\nclass TestCodeCommitProvider:\n    def test_get_title(self):\n        # Test that the get_title() function returns the PR title\n        with patch.object(CodeCommitProvider, \"__init__\", lambda x, y: None):\n            provider = CodeCommitProvider(None)\n            provider.pr = PullRequestCCMimic(\"My Test PR Title\", [])\n            assert provider.get_title() == \"My Test PR Title\"\n\n    def test_get_pr_id(self):\n        # Test that the get_pr_id() function returns the correct ID\n        with patch.object(CodeCommitProvider, \"__init__\", lambda x, y: None):\n            provider = CodeCommitProvider(None)\n            provider.repo_name = \"my_test_repo\"\n            provider.pr_num = 321\n            assert provider.get_pr_id() == \"my_test_repo/321\"\n\n    def test_parse_pr_url(self):\n        # Test that the _parse_pr_url() function can extract the repo name and PR number from a CodeCommit URL\n        url = \"https://us-east-1.console.aws.amazon.com/codesuite/codecommit/repositories/my_test_repo/pull-requests/321\"\n        repo_name, pr_number = CodeCommitProvider._parse_pr_url(url)\n        assert repo_name == \"my_test_repo\"\n        assert pr_number == 321\n\n    def test_is_valid_codecommit_hostname(self):\n        # Test the various AWS regions\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"af-south-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-east-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-northeast-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-northeast-2.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-northeast-3.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-south-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-south-2.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-southeast-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-southeast-2.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-southeast-3.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ap-southeast-4.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"ca-central-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"eu-central-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"eu-central-2.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"eu-north-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"eu-south-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"eu-south-2.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"eu-west-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"eu-west-2.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"eu-west-3.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"il-central-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"me-central-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"me-south-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"sa-east-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"us-east-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"us-east-2.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"us-gov-east-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"us-gov-west-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"us-west-1.console.aws.amazon.com\")\n        assert CodeCommitProvider._is_valid_codecommit_hostname(\"us-west-2.console.aws.amazon.com\")\n        # Test non-AWS regions\n        assert not CodeCommitProvider._is_valid_codecommit_hostname(\"no-such-region.console.aws.amazon.com\")\n        assert not CodeCommitProvider._is_valid_codecommit_hostname(\"console.aws.amazon.com\")\n\n    # Test that an error is raised when an invalid CodeCommit URL is provided to the set_pr() method of the CodeCommitProvider class.\n    # Generated by CodiumAI\n    def test_invalid_codecommit_url(self):\n        provider = CodeCommitProvider()\n        with pytest.raises(ValueError):\n            provider.set_pr(\"https://example.com/codecommit/repositories/my_test_repo/pull-requests/4321\")\n\n    def test_get_file_extensions(self):\n        filenames = [\n            \"app.py\",\n            \"cli.py\",\n            \"composer.json\",\n            \"composer.lock\",\n            \"hello.py\",\n            \"image1.jpg\",\n            \"image2.JPG\",\n            \"index.js\",\n            \"provider.py\",\n            \"README\",\n            \"test.py\",\n        ]\n        expected_extensions = [\n            \".py\",\n            \".py\",\n            \".json\",\n            \".lock\",\n            \".py\",\n            \".jpg\",\n            \".jpg\",\n            \".js\",\n            \".py\",\n            \"\",\n            \".py\",\n        ]\n        extensions = CodeCommitProvider._get_file_extensions(filenames)\n        assert extensions == expected_extensions\n\n    def test_get_language_percentages(self):\n        extensions = [\n            \".py\",\n            \".py\",\n            \".json\",\n            \".lock\",\n            \".py\",\n            \".jpg\",\n            \".jpg\",\n            \".js\",\n            \".py\",\n            \"\",\n            \".py\",\n        ]\n        percentages = CodeCommitProvider._get_language_percentages(extensions)\n        assert percentages[\".py\"] == 45\n        assert percentages[\".json\"] == 9\n        assert percentages[\".lock\"] == 9\n        assert percentages[\".jpg\"] == 18\n        assert percentages[\".js\"] == 9\n        assert percentages[\"\"] == 9\n\n        # The _get_file_extensions function needs the \".\" prefix on the extension,\n        # but the _get_language_percentages function will work with or without the \".\" prefix\n        extensions = [\n            \"txt\",\n            \"py\",\n            \"py\",\n        ]\n        percentages = CodeCommitProvider._get_language_percentages(extensions)\n        assert percentages[\"py\"] == 67\n        assert percentages[\"txt\"] == 33\n\n        # test an empty list\n        percentages = CodeCommitProvider._get_language_percentages([])\n        assert percentages == {}\n\n    def test_get_edit_type(self):\n        # Test that the _get_edit_type() function can convert a CodeCommit letter to an EDIT_TYPE enum\n        assert CodeCommitProvider._get_edit_type(\"A\") == EDIT_TYPE.ADDED\n        assert CodeCommitProvider._get_edit_type(\"D\") == EDIT_TYPE.DELETED\n        assert CodeCommitProvider._get_edit_type(\"M\") == EDIT_TYPE.MODIFIED\n        assert CodeCommitProvider._get_edit_type(\"R\") == EDIT_TYPE.RENAMED\n\n        assert CodeCommitProvider._get_edit_type(\"a\") == EDIT_TYPE.ADDED\n        assert CodeCommitProvider._get_edit_type(\"d\") == EDIT_TYPE.DELETED\n        assert CodeCommitProvider._get_edit_type(\"m\") == EDIT_TYPE.MODIFIED\n        assert CodeCommitProvider._get_edit_type(\"r\") == EDIT_TYPE.RENAMED\n\n        assert CodeCommitProvider._get_edit_type(\"X\") is None\n\n    def test_add_additional_newlines(self):\n        # a short string to test adding double newlines\n        input = \"abc\\ndef\\n\\n___\\nghi\\njkl\\nmno\\n\\npqr\\n\"\n        expect = \"abc\\n\\ndef\\n\\n___\\n\\nghi\\n\\njkl\\n\\nmno\\n\\npqr\\n\\n\"\n        assert CodeCommitProvider._add_additional_newlines(input) == expect\n        # a test example from a real PR\n        input = \"## PR Type:\\nEnhancement\\n\\n___\\n## PR Description:\\nThis PR introduces a new feature to the script, allowing users to filter servers by name.\\n\\n___\\n## PR Main Files Walkthrough:\\n`foo`: The foo script has been updated to include a new command line option `-f` or `--filter`.\\n`bar`: The bar script has been updated to list stopped servers.\\n\"\n        expect = \"## PR Type:\\n\\nEnhancement\\n\\n___\\n\\n## PR Description:\\n\\nThis PR introduces a new feature to the script, allowing users to filter servers by name.\\n\\n___\\n\\n## PR Main Files Walkthrough:\\n\\n`foo`: The foo script has been updated to include a new command line option `-f` or `--filter`.\\n\\n`bar`: The bar script has been updated to list stopped servers.\\n\\n\"\n        assert CodeCommitProvider._add_additional_newlines(input) == expect\n\n    def test_remove_markdown_html(self):\n        input = \"## PR Feedback\\n<details><summary>Code feedback:</summary>\\nfile foo\\n</summary>\\n\"\n        expect = \"## PR Feedback\\nCode feedback:\\nfile foo\\n\\n\"\n        assert CodeCommitProvider._remove_markdown_html(input) == expect\n"}
{"type": "test_file", "path": "tests/unittest/test_find_line_number_of_relevant_line_in_file.py", "content": "\n# Generated by CodiumAI\nimport pytest\n\nfrom pr_agent.algo.types import FilePatchInfo\nfrom pr_agent.algo.utils import find_line_number_of_relevant_line_in_file\n\n\nclass TestFindLineNumberOfRelevantLineInFile:\n    # Tests that the function returns the correct line number and absolute position when the relevant line is found in the patch\n    def test_relevant_line_found_in_patch(self):\n        diff_files = [\n            FilePatchInfo(base_file='file1', head_file='file1', patch='@@ -1,1 +1,2 @@\\n-line1\\n+line2\\n+relevant_line\\n', filename='file1')\n        ]\n        relevant_file = 'file1'\n        relevant_line_in_file = 'relevant_line'\n        expected = (3, 2) # (position in patch, absolute_position in new file)\n        assert find_line_number_of_relevant_line_in_file(diff_files, relevant_file, relevant_line_in_file) == expected\n\n    # Tests that the function returns the correct line number and absolute position when a similar line is found using difflib\n    def test_similar_line_found_using_difflib(self):\n        diff_files = [\n            FilePatchInfo(base_file='file1', head_file='file1', patch='@@ -1,1 +1,2 @@\\n-line1\\n+relevant_line in file similar match\\n', filename='file1')\n        ]\n        relevant_file = 'file1'\n        relevant_line_in_file = '+relevant_line in file similar match ' # note the space at the end. This is to simulate a similar line found using difflib\n        expected = (2, 1)\n        assert find_line_number_of_relevant_line_in_file(diff_files, relevant_file, relevant_line_in_file) == expected\n\n    # Tests that the function returns (-1, -1) when the relevant line is not found in the patch and no similar line is found using difflib\n    def test_relevant_line_not_found(self):\n        diff_files = [\n            FilePatchInfo(base_file='file1', head_file='file1', patch='@@ -1,1 +1,2 @@\\n-line1\\n+relevant_line\\n', filename='file1')\n        ]\n        relevant_file = 'file1'\n        relevant_line_in_file = 'not_found'\n        expected = (-1, -1)\n        assert find_line_number_of_relevant_line_in_file(diff_files, relevant_file, relevant_line_in_file) == expected\n\n    # Tests that the function returns (-1, -1) when the relevant file is not found in any of the patches\n    def test_relevant_file_not_found(self):\n        diff_files = [\n            FilePatchInfo(base_file='file1', head_file='file1', patch='@@ -1,1 +1,2 @@\\n-line1\\n+relevant_line\\n', filename='file2')\n        ]\n        relevant_file = 'file1'\n        relevant_line_in_file = 'relevant_line'\n        expected = (-1, -1)\n        assert find_line_number_of_relevant_line_in_file(diff_files, relevant_file, relevant_line_in_file) == expected\n\n    # Tests that the function returns (-1, -1) when the relevant_line_in_file is an empty string\n    def test_empty_relevant_line(self):\n        diff_files = [\n            FilePatchInfo(base_file='file1', head_file='file1', patch='@@ -1,1 +1,2 @@\\n-line1\\n+relevant_line\\n', filename='file1')\n        ]\n        relevant_file = 'file1'\n        relevant_line_in_file = ''\n        expected = (0, 0)\n        assert find_line_number_of_relevant_line_in_file(diff_files, relevant_file, relevant_line_in_file) == expected\n\n    # Tests that the function returns (-1, -1) when the relevant_line_in_file is found in the patch but it is a deleted line\n    def test_relevant_line_found_but_deleted(self):\n        diff_files = [\n            FilePatchInfo(base_file='file1', head_file='file1', patch='@@ -1,2 +1,1 @@\\n-line1\\n-relevant_line\\n', filename='file1')\n        ]\n        relevant_file = 'file1'\n        relevant_line_in_file = 'relevant_line'\n        expected = (-1, -1)\n        assert find_line_number_of_relevant_line_in_file(diff_files, relevant_file, relevant_line_in_file) == expected\n"}
{"type": "test_file", "path": "tests/unittest/test_parse_code_suggestion.py", "content": "\n# Generated by CodiumAI\nfrom pr_agent.algo.utils import parse_code_suggestion\n\n\"\"\"\nCode Analysis\n\nObjective:\nThe objective of the function is to convert a dictionary into a markdown format. The function takes in a dictionary as\ninput and recursively converts it into a markdown format. The function is specifically designed to handle dictionaries\nthat contain code suggestions.\n\nInputs:\n- output_data: a dictionary containing the data to be converted into markdown format\n\nFlow:\n- Initialize an empty string variable called markdown_text\n- Create a dictionary of emojis to be used in the markdown format\n- Iterate through the items in the input dictionary\n- If the value is empty, skip to the next item\n- If the value is a dictionary, recursively call the function with the value as input\n- If the value is a list, iterate through the list and add each item to the markdown format\n- If the value is not 'n/a', add it to the markdown format\n- If the key is 'code suggestions', call the parse_code_suggestion function to handle the list of code suggestions\n- Return the markdown format as a string\n\nOutputs:\n- markdown_text: a string containing the input dictionary converted into markdown format\n\nAdditional aspects:\n- The function uses the textwrap module to indent code examples in the markdown format\n- The parse_code_suggestion function is called to handle the 'code suggestions' key in the input dictionary\n- The function uses emojis to add visual cues to the markdown format\n\"\"\"\n\n\nclass TestParseCodeSuggestion:\n    # Tests that function returns empty string when input is an empty dictionary\n    def test_empty_dict(self):\n        input_data = {}\n        expected_output = \"\\n\"  # modified to expect a newline character\n        assert parse_code_suggestion(input_data) == expected_output\n\n\n    # Tests that function returns correct output when 'before' or 'after' key has a non-string value\n    def test_non_string_before_or_after(self):\n        input_data = {\n            \"Code example\": {\n                \"Before\": 123,\n                \"After\": [\"a\", \"b\", \"c\"]\n            }\n        }\n        expected_output = \"  - **Code example:**\\n    - **Before:**\\n        ```\\n        123\\n        ```\\n    - **After:**\\n        ```\\n        ['a', 'b', 'c']\\n        ```\\n\\n\"  # noqa: E501\n        assert parse_code_suggestion(input_data) == expected_output\n\n    # Tests that function returns correct output when input dictionary does not have 'code example' key\n    def test_no_code_example_key(self):\n        code_suggestions = {\n            'suggestion': 'Suggestion 1',\n            'description': 'Description 1',\n            'before': 'Before 1',\n            'after': 'After 1'\n        }\n        expected_output = '   **suggestion:** Suggestion 1     \\n   **description:** Description 1     \\n   **before:** Before 1     \\n   **after:** After 1     \\n\\n'  # noqa: E501\n        assert parse_code_suggestion(code_suggestions) == expected_output\n\n    # Tests that function returns correct output when input dictionary has 'code example' key\n    def test_with_code_example_key(self):\n        code_suggestions = {\n            'suggestion': 'Suggestion 2',\n            'description': 'Description 2',\n            'code example': {\n                'before': 'Before 2',\n                'after': 'After 2'\n            }\n        }\n        expected_output = '   **suggestion:** Suggestion 2     \\n   **description:** Description 2     \\n  - **code example:**\\n    - **before:**\\n        ```\\n        Before 2\\n        ```\\n    - **after:**\\n        ```\\n        After 2\\n        ```\\n\\n'  # noqa: E501\n        assert parse_code_suggestion(code_suggestions) == expected_output\n"}
{"type": "test_file", "path": "tests/unittest/test_bitbucket_provider.py", "content": "from unittest.mock import MagicMock\n\nfrom atlassian.bitbucket import Bitbucket\n\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\nfrom pr_agent.git_providers import BitbucketServerProvider\nfrom pr_agent.git_providers.bitbucket_provider import BitbucketProvider\n\n\nclass TestBitbucketProvider:\n    def test_parse_pr_url(self):\n        url = \"https://bitbucket.org/WORKSPACE_XYZ/MY_TEST_REPO/pull-requests/321\"\n        workspace_slug, repo_slug, pr_number = BitbucketProvider._parse_pr_url(url)\n        assert workspace_slug == \"WORKSPACE_XYZ\"\n        assert repo_slug == \"MY_TEST_REPO\"\n        assert pr_number == 321\n\n\nclass TestBitbucketServerProvider:\n    def test_parse_pr_url(self):\n        url = \"https://git.onpreminstance.com/projects/AAA/repos/my-repo/pull-requests/1\"\n        workspace_slug, repo_slug, pr_number = BitbucketServerProvider._parse_pr_url(url)\n        assert workspace_slug == \"AAA\"\n        assert repo_slug == \"my-repo\"\n        assert pr_number == 1\n\n    def test_parse_pr_url_with_users(self):\n        url = \"https://bitbucket.company-server.url/users/username/repos/my-repo/pull-requests/1\"\n        workspace_slug, repo_slug, pr_number = BitbucketServerProvider._parse_pr_url(url)\n        assert workspace_slug == \"~username\"\n        assert repo_slug == \"my-repo\"\n        assert pr_number == 1\n\n    def mock_get_content_of_file(self, project_key, repository_slug, filename, at=None, markup=None):\n        content_map = {\n            '9c1cffdd9f276074bfb6fb3b70fbee62d298b058': 'file\\nwith\\nsome\\nlines\\nto\\nemulate\\na\\nreal\\nfile\\n',\n            '2a1165446bdf991caf114d01f7c88d84ae7399cf': 'file\\nwith\\nmultiple \\nlines\\nto\\nemulate\\na\\nfake\\nfile\\n',\n            'f617708826cdd0b40abb5245eda71630192a17e3': 'file\\nwith\\nmultiple \\nlines\\nto\\nemulate\\na\\nreal\\nfile\\n',\n            'cb68a3027d6dda065a7692ebf2c90bed1bcdec28': 'file\\nwith\\nsome\\nchanges\\nto\\nemulate\\na\\nreal\\nfile\\n',\n            '1905dcf16c0aac6ac24f7ab617ad09c73dc1d23b': 'file\\nwith\\nsome\\nlines\\nto\\nemulate\\na\\nfake\\ntest\\n',\n            'ae4eca7f222c96d396927d48ab7538e2ee13ca63': 'readme\\nwithout\\nsome\\nlines\\nto\\nsimulate\\na\\nreal\\nfile',\n            '548f8ba15abc30875a082156314426806c3f4d97': 'file\\nwith\\nsome\\nlines\\nto\\nemulate\\na\\nreal\\nfile',\n            '0e898cb355a5170d8c8771b25d43fcaa1d2d9489': 'file\\nwith\\nmultiple\\nlines\\nto\\nemulate\\na\\nreal\\nfile'\n        }\n        return content_map.get(at, '')\n\n    def mock_get_from_bitbucket_60(self, url):\n        response_map = {\n            \"rest/api/1.0/application-properties\": {\n                \"version\": \"6.0\"\n            }\n        }\n        return response_map.get(url, '')\n\n    def mock_get_from_bitbucket_70(self, url):\n        response_map = {\n            \"rest/api/1.0/application-properties\": {\n                \"version\": \"7.0\"\n            }\n        }\n        return response_map.get(url, '')\n\n    def mock_get_from_bitbucket_816(self, url):\n        response_map = {\n            \"rest/api/1.0/application-properties\": {\n                \"version\": \"8.16\"\n            },\n            \"rest/api/latest/projects/AAA/repos/my-repo/pull-requests/1/merge-base\": {\n                'id': '548f8ba15abc30875a082156314426806c3f4d97'\n            }\n        }\n        return response_map.get(url, '')\n\n\n    '''\n    tests the 2-way diff functionality where the diff should be between the HEAD of branch b and node c\n    NOT between the HEAD of main and the HEAD of branch b\n\n          - o  branch b\n         /\n    o - o - o  main\n        ^ node c\n    '''\n    def test_get_diff_files_simple_diverge_70(self):\n        bitbucket_client = MagicMock(Bitbucket)\n        bitbucket_client.get_pull_request.return_value = {\n            'toRef': {'latestCommit': '9c1cffdd9f276074bfb6fb3b70fbee62d298b058'},\n            'fromRef': {'latestCommit': '2a1165446bdf991caf114d01f7c88d84ae7399cf'}\n        }\n        bitbucket_client.get_pull_requests_commits.return_value = [\n            {'id': '2a1165446bdf991caf114d01f7c88d84ae7399cf',\n             'parents': [{'id': 'f617708826cdd0b40abb5245eda71630192a17e3'}]}\n        ]\n        bitbucket_client.get_commits.return_value = [\n            {'id': '9c1cffdd9f276074bfb6fb3b70fbee62d298b058'},\n            {'id': 'dbca09554567d2e4bee7f07993390153280ee450'}\n        ]\n        bitbucket_client.get_pull_requests_changes.return_value = [\n            {\n                'path': {'toString': 'Readme.md'},\n                'type': 'MODIFY',\n            }\n        ]\n\n        bitbucket_client.get.side_effect = self.mock_get_from_bitbucket_70\n        bitbucket_client.get_content_of_file.side_effect = self.mock_get_content_of_file\n\n        provider = BitbucketServerProvider(\n            \"https://git.onpreminstance.com/projects/AAA/repos/my-repo/pull-requests/1\",\n            bitbucket_client=bitbucket_client\n        )\n\n        expected = [\n            FilePatchInfo(\n                'file\\nwith\\nmultiple \\nlines\\nto\\nemulate\\na\\nreal\\nfile\\n',\n                'file\\nwith\\nmultiple \\nlines\\nto\\nemulate\\na\\nfake\\nfile\\n',\n                '--- \\n+++ \\n@@ -5,5 +5,5 @@\\n to\\n emulate\\n a\\n-real\\n+fake\\n file\\n',\n                'Readme.md',\n                edit_type=EDIT_TYPE.MODIFIED,\n            )\n        ]\n\n        actual = provider.get_diff_files()\n\n        assert actual == expected\n\n\n    '''\n    tests the 2-way diff functionality where the diff should be between the HEAD of branch b and node c\n    NOT between the HEAD of main and the HEAD of branch b\n\n          - o - o - o  branch b\n         /     /\n    o - o -- o - o     main\n             ^ node c\n    '''\n    def test_get_diff_files_diverge_with_merge_commit_70(self):\n        bitbucket_client = MagicMock(Bitbucket)\n        bitbucket_client.get_pull_request.return_value = {\n            'toRef': {'latestCommit': 'cb68a3027d6dda065a7692ebf2c90bed1bcdec28'},\n            'fromRef': {'latestCommit': '1905dcf16c0aac6ac24f7ab617ad09c73dc1d23b'}\n        }\n        bitbucket_client.get_pull_requests_commits.return_value = [\n            {'id': '1905dcf16c0aac6ac24f7ab617ad09c73dc1d23b',\n             'parents': [{'id': '692772f456c3db77a90b11ce39ea516f8c2bad93'}]},\n            {'id': '692772f456c3db77a90b11ce39ea516f8c2bad93', 'parents': [\n                {'id': '2a1165446bdf991caf114d01f7c88d84ae7399cf'},\n                {'id': '9c1cffdd9f276074bfb6fb3b70fbee62d298b058'},\n            ]},\n            {'id': '2a1165446bdf991caf114d01f7c88d84ae7399cf',\n             'parents': [{'id': 'f617708826cdd0b40abb5245eda71630192a17e3'}]}\n        ]\n        bitbucket_client.get_commits.return_value = [\n            {'id': 'cb68a3027d6dda065a7692ebf2c90bed1bcdec28'},\n            {'id': '9c1cffdd9f276074bfb6fb3b70fbee62d298b058'},\n            {'id': 'dbca09554567d2e4bee7f07993390153280ee450'}\n        ]\n        bitbucket_client.get_pull_requests_changes.return_value = [\n            {\n                'path': {'toString': 'Readme.md'},\n                'type': 'MODIFY',\n            }\n        ]\n\n        bitbucket_client.get.side_effect = self.mock_get_from_bitbucket_70\n        bitbucket_client.get_content_of_file.side_effect = self.mock_get_content_of_file\n\n        provider = BitbucketServerProvider(\n            \"https://git.onpreminstance.com/projects/AAA/repos/my-repo/pull-requests/1\",\n            bitbucket_client=bitbucket_client\n        )\n\n        expected = [\n            FilePatchInfo(\n                'file\\nwith\\nsome\\nlines\\nto\\nemulate\\na\\nreal\\nfile\\n',\n                'file\\nwith\\nsome\\nlines\\nto\\nemulate\\na\\nfake\\ntest\\n',\n                '--- \\n+++ \\n@@ -5,5 +5,5 @@\\n to\\n emulate\\n a\\n-real\\n-file\\n+fake\\n+test\\n',\n                'Readme.md',\n                edit_type=EDIT_TYPE.MODIFIED,\n            )\n        ]\n\n        actual = provider.get_diff_files()\n\n        assert actual == expected\n\n\n    '''\n    tests the 2-way diff functionality where the diff should be between the HEAD of branch c and node d\n    NOT between the HEAD of main and the HEAD of branch c\n\n            ---- o - o branch c\n           /    /\n          ---- o       branch b\n         /    /\n        o - o - o      main\n            ^ node d\n    '''\n    def get_multi_merge_diverge_mock_client(self, api_version):\n        bitbucket_client = MagicMock(Bitbucket)\n        bitbucket_client.get_pull_request.return_value = {\n            'toRef': {'latestCommit': '9569922b22fe4fd0968be6a50ed99f71efcd0504'},\n            'fromRef': {'latestCommit': 'ae4eca7f222c96d396927d48ab7538e2ee13ca63'}\n        }\n        bitbucket_client.get_pull_requests_commits.return_value = [\n            {'id': 'ae4eca7f222c96d396927d48ab7538e2ee13ca63',\n             'parents': [{'id': 'bbf300fb3af5129af8c44659f8cc7a526a6a6f31'}]},\n            {'id': 'bbf300fb3af5129af8c44659f8cc7a526a6a6f31', 'parents': [\n                {'id': '10b7b8e41cb370b48ceda8da4e7e6ad033182213'},\n                {'id': 'd1bb183c706a3ebe4c2b1158c25878201a27ad8c'},\n            ]},\n            {'id': 'd1bb183c706a3ebe4c2b1158c25878201a27ad8c', 'parents': [\n                {'id': '5bd76251866cb415fc5ff232f63a581e89223bda'},\n                {'id': '548f8ba15abc30875a082156314426806c3f4d97'}\n            ]},\n            {'id': '5bd76251866cb415fc5ff232f63a581e89223bda',\n             'parents': [{'id': '0e898cb355a5170d8c8771b25d43fcaa1d2d9489'}]},\n            {'id': '10b7b8e41cb370b48ceda8da4e7e6ad033182213',\n             'parents': [{'id': '0e898cb355a5170d8c8771b25d43fcaa1d2d9489'}]}\n        ]\n        bitbucket_client.get_commits.return_value = [\n            {'id': '9569922b22fe4fd0968be6a50ed99f71efcd0504'},\n            {'id': '548f8ba15abc30875a082156314426806c3f4d97'}\n        ]\n        bitbucket_client.get_pull_requests_changes.return_value = [\n            {\n                'path': {'toString': 'Readme.md'},\n                'type': 'MODIFY',\n            }\n        ]\n\n        bitbucket_client.get_content_of_file.side_effect = self.mock_get_content_of_file\n        if api_version == 60:\n            bitbucket_client.get.side_effect = self.mock_get_from_bitbucket_60\n        elif api_version == 70:\n            bitbucket_client.get.side_effect = self.mock_get_from_bitbucket_70\n        elif api_version == 816:\n            bitbucket_client.get.side_effect = self.mock_get_from_bitbucket_816\n\n        return bitbucket_client\n\n    def test_get_diff_files_multi_merge_diverge_60(self):\n        bitbucket_client = self.get_multi_merge_diverge_mock_client(60)\n\n        provider = BitbucketServerProvider(\n            \"https://git.onpreminstance.com/projects/AAA/repos/my-repo/pull-requests/1\",\n            bitbucket_client=bitbucket_client\n        )\n\n        expected = [\n            FilePatchInfo(\n                'file\\nwith\\nmultiple\\nlines\\nto\\nemulate\\na\\nreal\\nfile',\n                'readme\\nwithout\\nsome\\nlines\\nto\\nsimulate\\na\\nreal\\nfile',\n                '--- \\n+++ \\n@@ -1,9 +1,9 @@\\n-file\\n-with\\n-multiple\\n+readme\\n+without\\n+some\\n lines\\n to\\n-emulate\\n+simulate\\n a\\n real\\n file\\n',\n                'Readme.md',\n                edit_type=EDIT_TYPE.MODIFIED,\n            )\n        ]\n\n        actual = provider.get_diff_files()\n\n        assert actual == expected\n\n    def test_get_diff_files_multi_merge_diverge_70(self):\n        bitbucket_client = self.get_multi_merge_diverge_mock_client(70)\n\n        provider = BitbucketServerProvider(\n            \"https://git.onpreminstance.com/projects/AAA/repos/my-repo/pull-requests/1\",\n            bitbucket_client=bitbucket_client\n        )\n\n        expected = [\n            FilePatchInfo(\n                'file\\nwith\\nsome\\nlines\\nto\\nemulate\\na\\nreal\\nfile',\n                'readme\\nwithout\\nsome\\nlines\\nto\\nsimulate\\na\\nreal\\nfile',\n                '--- \\n+++ \\n@@ -1,9 +1,9 @@\\n-file\\n-with\\n+readme\\n+without\\n some\\n lines\\n to\\n-emulate\\n+simulate\\n a\\n real\\n file\\n',\n                'Readme.md',\n                edit_type=EDIT_TYPE.MODIFIED,\n            )\n        ]\n\n        actual = provider.get_diff_files()\n\n        assert actual == expected\n\n    def test_get_diff_files_multi_merge_diverge_816(self):\n        bitbucket_client = self.get_multi_merge_diverge_mock_client(816)\n\n        provider = BitbucketServerProvider(\n            \"https://git.onpreminstance.com/projects/AAA/repos/my-repo/pull-requests/1\",\n            bitbucket_client=bitbucket_client\n        )\n\n        expected = [\n            FilePatchInfo(\n                'file\\nwith\\nsome\\nlines\\nto\\nemulate\\na\\nreal\\nfile',\n                'readme\\nwithout\\nsome\\nlines\\nto\\nsimulate\\na\\nreal\\nfile',\n                '--- \\n+++ \\n@@ -1,9 +1,9 @@\\n-file\\n-with\\n+readme\\n+without\\n some\\n lines\\n to\\n-emulate\\n+simulate\\n a\\n real\\n file\\n',\n                'Readme.md',\n                edit_type=EDIT_TYPE.MODIFIED,\n            )\n        ]\n\n        actual = provider.get_diff_files()\n\n        assert actual == expected\n"}
{"type": "test_file", "path": "tests/unittest/test_fix_output.py", "content": "# Generated by CodiumAI\n\nfrom pr_agent.algo.utils import try_fix_json\n\n\nclass TestTryFixJson:\n    # Tests that JSON with complete 'Code suggestions' section returns expected output\n    def test_incomplete_code_suggestions(self):\n        review = '{\"PR Analysis\": {\"Main theme\": \"xxx\", \"Type of PR\": \"Bug fix\"}, \"PR Feedback\": {\"General PR suggestions\": \"..., `xxx`...\", \"Code suggestions\": [{\"relevant file\": \"xxx.py\", \"suggestion content\": \"xxx [important]\"}, {\"suggestion number\": 2, \"relevant file\": \"yyy.py\", \"suggestion content\": \"yyy [incomp...'  # noqa: E501\n        expected_output = {\n            'PR Analysis': {\n                'Main theme': 'xxx',\n                'Type of PR': 'Bug fix'\n            },\n            'PR Feedback': {\n                'General PR suggestions': '..., `xxx`...',\n                'Code suggestions': [\n                    {\n                        'relevant file': 'xxx.py',\n                        'suggestion content': 'xxx [important]'\n                    }\n                ]\n            }\n        }\n        assert try_fix_json(review) == expected_output\n\n    def test_incomplete_code_suggestions_new_line(self):\n        review = '{\"PR Analysis\": {\"Main theme\": \"xxx\", \"Type of PR\": \"Bug fix\"}, \"PR Feedback\": {\"General PR suggestions\": \"..., `xxx`...\", \"Code suggestions\": [{\"relevant file\": \"xxx.py\", \"suggestion content\": \"xxx [important]\"} \\n\\t, {\"suggestion number\": 2, \"relevant file\": \"yyy.py\", \"suggestion content\": \"yyy [incomp...'  # noqa: E501\n        expected_output = {\n            'PR Analysis': {\n                'Main theme': 'xxx',\n                'Type of PR': 'Bug fix'\n            },\n            'PR Feedback': {\n                'General PR suggestions': '..., `xxx`...',\n                'Code suggestions': [\n                    {\n                        'relevant file': 'xxx.py',\n                        'suggestion content': 'xxx [important]'\n                    }\n                ]\n            }\n        }\n        assert try_fix_json(review) == expected_output\n\n    def test_incomplete_code_suggestions_many_close_brackets(self):\n        review = '{\"PR Analysis\": {\"Main theme\": \"xxx\", \"Type of PR\": \"Bug fix\"}, \"PR Feedback\": {\"General PR suggestions\": \"..., `xxx`...\", \"Code suggestions\": [{\"relevant file\": \"xxx.py\", \"suggestion content\": \"xxx [important]\"} \\n, {\"suggestion number\": 2, \"relevant file\": \"yyy.py\", \"suggestion content\": \"yyy }, [}\\n ,incomp.}  ,..'  # noqa: E501\n        expected_output = {\n            'PR Analysis': {\n                'Main theme': 'xxx',\n                'Type of PR': 'Bug fix'\n            },\n            'PR Feedback': {\n                'General PR suggestions': '..., `xxx`...',\n                'Code suggestions': [\n                    {\n                        'relevant file': 'xxx.py',\n                        'suggestion content': 'xxx [important]'\n                    }\n                ]\n            }\n        }\n        assert try_fix_json(review) == expected_output\n\n    def test_incomplete_code_suggestions_relevant_file(self):\n        review = '{\"PR Analysis\": {\"Main theme\": \"xxx\", \"Type of PR\": \"Bug fix\"}, \"PR Feedback\": {\"General PR suggestions\": \"..., `xxx`...\", \"Code suggestions\": [{\"relevant file\": \"xxx.py\", \"suggestion content\": \"xxx [important]\"}, {\"suggestion number\": 2, \"relevant file\": \"yyy.p'  # noqa: E501\n        expected_output = {\n            'PR Analysis': {\n                'Main theme': 'xxx',\n                'Type of PR': 'Bug fix'\n            },\n            'PR Feedback': {\n                'General PR suggestions': '..., `xxx`...',\n                'Code suggestions': [\n                    {\n                        'relevant file': 'xxx.py',\n                        'suggestion content': 'xxx [important]'\n                    }\n                ]\n            }\n        }\n        assert try_fix_json(review) == expected_output\n"}
{"type": "test_file", "path": "tests/e2e_tests/test_gitlab_webhook.py", "content": "import os\nimport re\nimport time\nfrom datetime import datetime\n\nimport gitlab\n\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers import get_git_provider\nfrom pr_agent.log import get_logger, setup_logger\nfrom tests.e2e_tests.e2e_utils import (FILE_PATH,\n                                       IMPROVE_START_WITH_REGEX_PATTERN,\n                                       NEW_FILE_CONTENT, NUM_MINUTES,\n                                       PR_HEADER_START_WITH, REVIEW_START_WITH)\n\nlog_level = os.environ.get(\"LOG_LEVEL\", \"INFO\")\nsetup_logger(log_level)\nlogger = get_logger()\n\ndef test_e2e_run_github_app():\n    # GitLab setup\n    GITLAB_URL = \"https://gitlab.com\"\n    GITLAB_TOKEN = get_settings().gitlab.PERSONAL_ACCESS_TOKEN\n    gl = gitlab.Gitlab(GITLAB_URL, private_token=GITLAB_TOKEN)\n    repo_url = 'codiumai/pr-agent-tests'\n    project = gl.projects.get(repo_url)\n\n    base_branch = \"main\"  # or any base branch you want\n    new_branch = f\"github_app_e2e_test-{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}\"\n\n    try:\n        # Create a new branch from the base branch\n        logger.info(f\"Creating a new branch {new_branch} from {base_branch}\")\n        project.branches.create({'branch': new_branch, 'ref': base_branch})\n\n        # Get the file you want to edit\n        file = project.files.get(file_path=FILE_PATH, ref=base_branch)\n        # content = file.decode()\n\n        # Update the file content\n        logger.info(f\"Updating the file {FILE_PATH}\")\n        commit_message = \"update cli_pip.py\"\n        file.content = NEW_FILE_CONTENT\n        file.save(branch=new_branch, commit_message=commit_message)\n\n        # Create a merge request\n        logger.info(f\"Creating a merge request from {new_branch} to {base_branch}\")\n        mr = project.mergerequests.create({\n            'source_branch': new_branch,\n            'target_branch': base_branch,\n            'title': new_branch,\n            'description': \"update cli_pip.py\"\n        })\n        logger.info(f\"Merge request created: {mr.web_url}\")\n\n        # check every 1 minute, for 5, minutes if the PR has all the tool results\n        for i in range(NUM_MINUTES):\n            logger.info(f\"Waiting for the MR to get all the tool results...\")\n            time.sleep(60)\n            logger.info(f\"Checking the MR {mr.web_url} after {i + 1} minute(s)\")\n            mr = project.mergerequests.get(mr.iid)\n            mr_header_body = mr.description\n            comments = mr.notes.list()[::-1]\n            # clean all system comments\n            comments = [comment for comment in comments if comment.system is False]\n            if len(comments) == 2: # \"changed the description\" is received as the first comment\n                comments_body = [comment.body for comment in comments]\n                if 'Work in progress' in comments_body[1]:\n                    continue\n                assert mr_header_body.startswith(PR_HEADER_START_WITH), \"DESCRIBE feedback is invalid\"\n                assert comments_body[0].startswith(REVIEW_START_WITH), \"REVIEW feedback is invalid\"\n                assert re.match(IMPROVE_START_WITH_REGEX_PATTERN, comments_body[1]), \"IMPROVE feedback is invalid\"\n                break\n            else:\n                logger.info(f\"Waiting for the MR to get all the tool results. {i + 1} minute(s) passed\")\n        else:\n            assert False, f\"After {NUM_MINUTES} minutes, the MR did not get all the tool results\"\n\n        # cleanup - delete the branch\n        logger.info(f\"Deleting the branch {new_branch}\")\n        project.branches.delete(new_branch)\n\n        # If we reach here, the test is successful\n        logger.info(f\"Succeeded in running e2e test for GitLab app on the MR {mr.web_url}\")\n    except Exception as e:\n        logger.error(f\"Failed to run e2e test for GitHub app: {e}\")\n        logger.info(f\"Deleting the branch {new_branch}\")\n        project.branches.delete(new_branch)\n        assert False\n\n\nif __name__ == '__main__':\n    test_e2e_run_github_app()\n"}
{"type": "test_file", "path": "tests/unittest/test_try_fix_yaml.py", "content": "\n# Generated by CodiumAI\nimport pytest\n\nfrom pr_agent.algo.utils import try_fix_yaml\n\n\nclass TestTryFixYaml:\n\n    # The function successfully parses a valid YAML string.\n    def test_valid_yaml(self):\n        review_text = \"key: value\\n\"\n        expected_output = {\"key\": \"value\"}\n        assert try_fix_yaml(review_text) == expected_output\n\n    # The function adds '|-' to 'relevant line:' if it is not already present and successfully parses the YAML string.\n    def test_add_relevant_line(self):\n        review_text = \"relevant line: value: 3\\n\"\n        expected_output = {'relevant line': 'value: 3\\n'}\n        assert try_fix_yaml(review_text) == expected_output\n\n    # The function extracts YAML snippet\n    def test_extract_snippet(self):\n        review_text = '''\\\nHere is the answer in YAML format:\n\n```yaml\nname: John Smith\nage: 35\n```\n'''\n        expected_output = {'name': 'John Smith', 'age': 35}\n        assert try_fix_yaml(review_text) == expected_output\n\n    # The function removes the last line(s) of the YAML string and successfully parses the YAML string.\n    def test_remove_last_line(self):\n        review_text = \"key: value\\nextra invalid line\\n\"\n        expected_output = {\"key\": \"value\"}\n        assert try_fix_yaml(review_text) == expected_output\n\n    # The YAML string is empty.\n    def test_empty_yaml_fixed(self):\n        review_text = \"\"\n        assert try_fix_yaml(review_text) is None\n\n\n    # The function extracts YAML snippet\n    def test_no_initial_yaml(self):\n        review_text = '''\\\nI suggest the following:\n\ncode_suggestions:\n- relevant_file: |\n    src/index.ts\n  label: |\n    best practice\n\n- relevant_file: |\n    src/index2.ts\n  label: |\n    enhancment\n```\n\nWe can further improve the code by using the `const` keyword instead of `var` in the `src/index.ts` file.\n'''\n        expected_output = {'code_suggestions': [{'relevant_file': 'src/index.ts\\n', 'label': 'best practice\\n'}, {'relevant_file': 'src/index2.ts\\n', 'label': 'enhancment'}]}\n\n        assert try_fix_yaml(review_text, first_key='code_suggestions', last_key='label') == expected_output\n\n    def test_with_initial_yaml(self):\n        review_text = '''\\\nI suggest the following:\n\n```\ncode_suggestions:\n- relevant_file: |\n    src/index.ts\n  label: |\n    best practice\n\n- relevant_file: |\n    src/index2.ts\n  label: |\n    enhancment\n```\n\nWe can further improve the code by using the `const` keyword instead of `var` in the `src/index.ts` file.\n'''\n        expected_output = {'code_suggestions': [{'relevant_file': 'src/index.ts\\n', 'label': 'best practice\\n'}, {'relevant_file': 'src/index2.ts\\n', 'label': 'enhancment'}]}\n        assert try_fix_yaml(review_text, first_key='code_suggestions', last_key='label') == expected_output\n"}
{"type": "test_file", "path": "tests/unittest/test_load_yaml.py", "content": "\n# Generated by CodiumAI\n\nimport pytest\nimport yaml\nfrom yaml.scanner import ScannerError\n\nfrom pr_agent.algo.utils import load_yaml\n\n\nclass TestLoadYaml:\n    #  Tests that load_yaml loads a valid YAML string\n    def test_load_valid_yaml(self):\n        yaml_str = 'name: John Smith\\nage: 35'\n        expected_output = {'name': 'John Smith', 'age': 35}\n        assert load_yaml(yaml_str) == expected_output\n\n    def test_load_invalid_yaml1(self):\n        yaml_str = \\\n'''\\\nPR Analysis:\n  Main theme: Enhancing the `/describe` command prompt by adding title and description\n  Type of PR: Enhancement\n  Relevant tests: No\n  Focused PR: Yes, the PR is focused on enhancing the `/describe` command prompt.\n\nPR Feedback:\n  General suggestions: The PR seems to be well-structured and focused on a specific enhancement. However, it would be beneficial to add tests to ensure the new feature works as expected.\n  Code feedback:\n    - relevant file: pr_agent/settings/pr_description_prompts.toml\n      suggestion: Consider using a more descriptive variable name than 'user' for the command prompt. A more descriptive name would make the code more readable and maintainable. [medium]\n      relevant line: user=\"\"\"PR Info: aaa\n  Security concerns: No'''\n        with pytest.raises(ScannerError):\n            yaml.safe_load(yaml_str)\n\n        expected_output = {'PR Analysis': {'Main theme': 'Enhancing the `/describe` command prompt by adding title and description', 'Type of PR': 'Enhancement', 'Relevant tests': False, 'Focused PR': 'Yes, the PR is focused on enhancing the `/describe` command prompt.'}, 'PR Feedback': {'General suggestions': 'The PR seems to be well-structured and focused on a specific enhancement. However, it would be beneficial to add tests to ensure the new feature works as expected.', 'Code feedback': [{'relevant file': 'pr_agent/settings/pr_description_prompts.toml\\n', 'suggestion': \"Consider using a more descriptive variable name than 'user' for the command prompt. A more descriptive name would make the code more readable and maintainable. [medium]\", 'relevant line': 'user=\"\"\"PR Info: aaa\\n'}], 'Security concerns': False}}\n        assert load_yaml(yaml_str) == expected_output\n\n    def test_load_invalid_yaml2(self):\n        yaml_str = '''\\\n- relevant file: src/app.py:\n  suggestion content: The print statement is outside inside the if __name__ ==: \\\n'''\n        with pytest.raises(ScannerError):\n            yaml.safe_load(yaml_str)\n\n        expected_output = [{'relevant file': 'src/app.py:\\n', 'suggestion content': 'The print statement is outside inside the if __name__ ==:'}]\n        assert load_yaml(yaml_str) == expected_output\n"}
{"type": "test_file", "path": "tests/e2e_tests/test_bitbucket_app.py", "content": "import hashlib\nimport os\nimport re\nimport time\nfrom datetime import datetime\n\nimport jwt\nimport requests\nfrom atlassian.bitbucket import Cloud\nfrom requests.auth import HTTPBasicAuth\n\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.log import get_logger, setup_logger\nfrom tests.e2e_tests.e2e_utils import (FILE_PATH,\n                                       IMPROVE_START_WITH_REGEX_PATTERN,\n                                       NEW_FILE_CONTENT, NUM_MINUTES,\n                                       PR_HEADER_START_WITH, REVIEW_START_WITH)\n\nlog_level = os.environ.get(\"LOG_LEVEL\", \"INFO\")\nsetup_logger(log_level)\nlogger = get_logger()\n\ndef test_e2e_run_bitbucket_app():\n    repo_slug = 'pr-agent-tests'\n    project_key = 'codiumai'\n    base_branch = \"main\"  # or any base branch you want\n    new_branch = f\"bitbucket_app_e2e_test-{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}\"\n    get_settings().config.git_provider = \"bitbucket\"\n\n    try:\n        # Add username and password for authentication\n        username = get_settings().get(\"BITBUCKET.USERNAME\", None)\n        password = get_settings().get(\"BITBUCKET.PASSWORD\", None)\n        s = requests.Session()\n        s.auth = (username, password)  # Use HTTP Basic Auth\n        bitbucket_client = Cloud(session=s)\n        repo = bitbucket_client.workspaces.get(workspace=project_key).repositories.get(repo_slug)\n\n        # Create a new branch from the base branch\n        logger.info(f\"Creating a new branch {new_branch} from {base_branch}\")\n        source_branch = repo.branches.get(base_branch)\n        target_repo = repo.branches.create(new_branch,source_branch.hash)\n\n        # Update the file content\n        url = (f\"https://api.bitbucket.org/2.0/repositories/{project_key}/{repo_slug}/src\")\n        files={FILE_PATH: NEW_FILE_CONTENT}\n        data={\n            \"message\": \"update cli_pip.py\",\n            \"branch\": new_branch,\n        }\n        requests.request(\"POST\", url, auth=HTTPBasicAuth(username, password), data=data, files=files)\n\n\n        # Create a pull request\n        logger.info(f\"Creating a pull request from {new_branch} to {base_branch}\")\n        pr = repo.pullrequests.create(\n            title=f'{new_branch}',\n            description=\"update cli_pip.py\",\n            source_branch=new_branch,\n            destination_branch=base_branch\n        )\n\n        # check every 1 minute, for 5 minutes if the PR has all the tool results\n        for i in range(NUM_MINUTES):\n            logger.info(f\"Waiting for the PR to get all the tool results...\")\n            time.sleep(60)\n            comments = list(pr.comments())\n            comments_raw = [c.raw for c in comments]\n            if len(comments) >= 5: # header, 3 suggestions, 1 review\n                valid_review = False\n                for comment_raw in comments_raw:\n                    if comment_raw.startswith('## PR Reviewer Guide üîç'):\n                        valid_review = True\n                        break\n                if valid_review:\n                    break\n                else:\n                    logger.error(f\"REVIEW feedback is invalid\")\n                    raise Exception(\"REVIEW feedback is invalid\")\n            else:\n                logger.info(f\"Waiting for the PR to get all the tool results. {i + 1} minute(s) passed\")\n        else:\n            assert False, f\"After {NUM_MINUTES} minutes, the PR did not get all the tool results\"\n\n        # cleanup - delete the branch\n        pr.decline()\n        repo.branches.delete(new_branch)\n\n        # If we reach here, the test is successful\n        logger.info(f\"Succeeded in running e2e test for Bitbucket app on the PR\")\n    except Exception as e:\n        logger.error(f\"Failed to run e2e test for Bitbucket app: {e}\")\n        # delete the branch\n        pr.decline()\n        repo.branches.delete(new_branch)\n        assert False\n\n\nif __name__ == '__main__':\n    test_e2e_run_bitbucket_app()\n"}
{"type": "test_file", "path": "tests/unittest/test_azure_devops_parsing.py", "content": "from pr_agent.git_providers import AzureDevopsProvider\n\n\nclass TestAzureDevOpsParsing():\n    def test_regular_address(self):\n        pr_url = \"https://dev.azure.com/organization/project/_git/repo/pullrequest/1\"\n\n        # workspace_slug, repo_slug, pr_number\n        assert AzureDevopsProvider._parse_pr_url(pr_url) == (\"project\", \"repo\", 1)\n\n    def test_visualstudio_address(self):\n        pr_url = \"https://organization.visualstudio.com/project/_git/repo/pullrequest/1\"\n\n        # workspace_slug, repo_slug, pr_number\n        assert AzureDevopsProvider._parse_pr_url(pr_url) == (\"project\", \"repo\", 1)\n"}
{"type": "source_file", "path": "pr_agent/agent/__init__.py", "content": ""}
{"type": "source_file", "path": "pr_agent/algo/__init__.py", "content": "MAX_TOKENS = {\n    'text-embedding-ada-002': 8000,\n    'gpt-3.5-turbo': 16000,\n    'gpt-3.5-turbo-0125': 16000,\n    'gpt-3.5-turbo-0613': 4000,\n    'gpt-3.5-turbo-1106': 16000,\n    'gpt-3.5-turbo-16k': 16000,\n    'gpt-3.5-turbo-16k-0613': 16000,\n    'gpt-4': 8000,\n    'gpt-4-0613': 8000,\n    'gpt-4-32k': 32000,\n    'gpt-4-1106-preview': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4-0125-preview': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4o': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4o-2024-05-13': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4-turbo-preview': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4-turbo-2024-04-09': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4-turbo': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4o-mini': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4o-mini-2024-07-18': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4o-2024-08-06': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'gpt-4o-2024-11-20': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'o1-mini': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'o1-mini-2024-09-12': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'o1-preview': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'o1-preview-2024-09-12': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'o1-2024-12-17': 204800,  # 200K, but may be limited by config.max_model_tokens\n    'o1': 204800,  # 200K, but may be limited by config.max_model_tokens\n    'o3-mini': 204800,  # 200K, but may be limited by config.max_model_tokens\n    'o3-mini-2025-01-31': 204800,  # 200K, but may be limited by config.max_model_tokens\n    'claude-instant-1': 100000,\n    'claude-2': 100000,\n    'command-nightly': 4096,\n    'deepseek/deepseek-chat': 128000,  # 128K, but may be limited by config.max_model_tokens\n    'deepseek/deepseek-reasoner': 64000,  # 64K, but may be limited by config.max_model_tokens\n    'replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1': 4096,\n    'meta-llama/Llama-2-7b-chat-hf': 4096,\n    'vertex_ai/codechat-bison': 6144,\n    'vertex_ai/codechat-bison-32k': 32000,\n    'vertex_ai/claude-3-haiku@20240307': 100000,\n    'vertex_ai/claude-3-5-haiku@20241022': 100000,\n    'vertex_ai/claude-3-sonnet@20240229': 100000,\n    'vertex_ai/claude-3-opus@20240229': 100000,\n    'vertex_ai/claude-3-5-sonnet@20240620': 100000,\n    'vertex_ai/claude-3-5-sonnet-v2@20241022': 100000,\n    'vertex_ai/claude-3-7-sonnet@20250219': 200000,\n    'vertex_ai/gemini-1.5-pro': 1048576,\n    'vertex_ai/gemini-1.5-flash': 1048576,\n    'vertex_ai/gemini-2.0-flash': 1048576,\n    'vertex_ai/gemma2': 8200,\n    'gemini/gemini-1.5-pro': 1048576,\n    'gemini/gemini-1.5-flash': 1048576,\n    'gemini/gemini-2.0-flash': 1048576,\n    'codechat-bison': 6144,\n    'codechat-bison-32k': 32000,\n    'anthropic.claude-instant-v1': 100000,\n    'anthropic.claude-v1': 100000,\n    'anthropic.claude-v2': 100000,\n    'anthropic/claude-3-opus-20240229': 100000,\n    'anthropic/claude-3-5-sonnet-20240620': 100000,\n    'anthropic/claude-3-5-sonnet-20241022': 100000,\n    'anthropic/claude-3-7-sonnet-20250219': 200000,\n    'claude-3-7-sonnet-20250219': 200000,\n    'anthropic/claude-3-5-haiku-20241022': 100000,\n    'bedrock/anthropic.claude-instant-v1': 100000,\n    'bedrock/anthropic.claude-v2': 100000,\n    'bedrock/anthropic.claude-v2:1': 100000,\n    'bedrock/anthropic.claude-3-sonnet-20240229-v1:0': 100000,\n    'bedrock/anthropic.claude-3-haiku-20240307-v1:0': 100000,\n    'bedrock/anthropic.claude-3-5-haiku-20241022-v1:0': 100000,\n    'bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0': 100000,\n    'bedrock/anthropic.claude-3-5-sonnet-20241022-v2:0': 100000,\n    'bedrock/anthropic.claude-3-7-sonnet-20250219-v1:0': 200000,\n    \"bedrock/us.anthropic.claude-3-5-sonnet-20241022-v2:0\": 100000,\n    \"bedrock/us.anthropic.claude-3-7-sonnet-20250219-v1:0\": 200000,\n    'claude-3-5-sonnet': 100000,\n    'groq/llama3-8b-8192': 8192,\n    'groq/llama3-70b-8192': 8192,\n    'groq/llama-3.1-8b-instant': 8192,\n    'groq/llama-3.3-70b-versatile': 128000,\n    'groq/mixtral-8x7b-32768': 32768,\n    'groq/gemma2-9b-it': 8192,\n    'ollama/llama3': 4096,\n    'watsonx/meta-llama/llama-3-8b-instruct': 4096,\n    \"watsonx/meta-llama/llama-3-70b-instruct\": 4096,\n    \"watsonx/meta-llama/llama-3-405b-instruct\": 16384,\n    \"watsonx/ibm/granite-13b-chat-v2\": 8191,\n    \"watsonx/ibm/granite-34b-code-instruct\": 8191,\n    \"watsonx/mistralai/mistral-large\": 32768,\n    \"deepinfra/deepseek-ai/DeepSeek-R1-Distill-Qwen-32B\": 128000,\n    \"deepinfra/deepseek-ai/DeepSeek-R1-Distill-Llama-70B\": 128000,\n    \"deepinfra/deepseek-ai/DeepSeek-R1\": 128000,\n}\n\nUSER_MESSAGE_ONLY_MODELS = [\n    \"deepseek/deepseek-reasoner\",\n    \"o1-mini\",\n    \"o1-mini-2024-09-12\",\n    \"o1-preview\"\n]\n\nNO_SUPPORT_TEMPERATURE_MODELS = [\n    \"deepseek/deepseek-reasoner\",\n    \"o1-mini\",\n    \"o1-mini-2024-09-12\",\n    \"o1\",\n    \"o1-2024-12-17\",\n    \"o3-mini\",\n    \"o3-mini-2025-01-31\",\n    \"o1-preview\"\n]\n\nSUPPORT_REASONING_EFFORT_MODELS = [\n    \"o3-mini\",\n    \"o3-mini-2025-01-31\"\n]\n\nCLAUDE_EXTENDED_THINKING_MODELS = [\n    \"anthropic/claude-3-7-sonnet-20250219\",\n    \"claude-3-7-sonnet-20250219\"\n]\n"}
{"type": "source_file", "path": "pr_agent/git_providers/codecommit_client.py", "content": "import boto3\nimport botocore\n\n\nclass CodeCommitDifferencesResponse:\n    \"\"\"\n    CodeCommitDifferencesResponse is the response object returned from our get_differences() function.\n    It maps the JSON response to member variables of this class.\n    \"\"\"\n\n    def __init__(self, json: dict):\n        before_blob = json.get(\"beforeBlob\", {})\n        after_blob = json.get(\"afterBlob\", {})\n\n        self.before_blob_id = before_blob.get(\"blobId\", \"\")\n        self.before_blob_path = before_blob.get(\"path\", \"\")\n        self.after_blob_id = after_blob.get(\"blobId\", \"\")\n        self.after_blob_path = after_blob.get(\"path\", \"\")\n        self.change_type = json.get(\"changeType\", \"\")\n\n\nclass CodeCommitPullRequestResponse:\n    \"\"\"\n    CodeCommitPullRequestResponse is the response object returned from our get_pr() function.\n    It maps the JSON response to member variables of this class.\n    \"\"\"\n\n    def __init__(self, json: dict):\n        self.title = json.get(\"title\", \"\")\n        self.description = json.get(\"description\", \"\")\n\n        self.targets = []\n        for target in json.get(\"pullRequestTargets\", []):\n            self.targets.append(CodeCommitPullRequestResponse.CodeCommitPullRequestTarget(target))\n\n    class CodeCommitPullRequestTarget:\n        \"\"\"\n        CodeCommitPullRequestTarget is a subclass of CodeCommitPullRequestResponse that\n        holds details about an individual target commit.\n        \"\"\"\n\n        def __init__(self, json: dict):\n            self.source_commit = json.get(\"sourceCommit\", \"\")\n            self.source_branch = json.get(\"sourceReference\", \"\")\n            self.destination_commit = json.get(\"destinationCommit\", \"\")\n            self.destination_branch = json.get(\"destinationReference\", \"\")\n\n\nclass CodeCommitClient:\n    \"\"\"\n    CodeCommitClient is a wrapper around the AWS boto3 SDK for the CodeCommit client\n    \"\"\"\n\n    def __init__(self):\n        self.boto_client = None\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in [\"gfm_markdown\"]:\n            return False\n        return True\n\n    def _connect_boto_client(self):\n        try:\n            self.boto_client = boto3.client(\"codecommit\")\n        except Exception as e:\n            raise ValueError(f\"Failed to connect to AWS CodeCommit: {e}\") from e\n\n    def get_differences(self, repo_name: int, destination_commit: str, source_commit: str):\n        \"\"\"\n        Get the differences between two commits in CodeCommit.\n\n        Args:\n        - repo_name: Name of the repository\n        - destination_commit: Commit hash you want to merge into (the \"before\" hash) (usually on the main or master branch)\n        - source_commit: Commit hash of the code you are adding (the \"after\" branch)\n\n        Returns:\n        - List of CodeCommitDifferencesResponse objects\n\n        Boto3 Documentation:\n        - aws codecommit get-differences\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/get_differences.html\n        \"\"\"\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        # The differences response from AWS is paginated, so we need to iterate through the pages to get all the differences.\n        differences = []\n        try:\n            paginator = self.boto_client.get_paginator(\"get_differences\")\n            for page in paginator.paginate(\n                repositoryName=repo_name,\n                beforeCommitSpecifier=destination_commit,\n                afterCommitSpecifier=source_commit,\n            ):\n                differences.extend(page.get(\"differences\", []))\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'RepositoryDoesNotExistException':\n                raise ValueError(f\"CodeCommit cannot retrieve differences: Repository does not exist: {repo_name}\") from e\n            raise ValueError(f\"CodeCommit cannot retrieve differences for {source_commit}..{destination_commit}\") from e\n        except Exception as e:\n            raise ValueError(f\"CodeCommit cannot retrieve differences for {source_commit}..{destination_commit}\") from e\n\n        output = []\n        for json in differences:\n            output.append(CodeCommitDifferencesResponse(json))\n        return output\n\n    def get_file(self, repo_name: str, file_path: str, sha_hash: str, optional: bool = False):\n        \"\"\"\n        Retrieve a file from CodeCommit.\n\n        Args:\n        - repo_name: Name of the repository\n        - file_path: Path to the file you are retrieving\n        - sha_hash: Commit hash of the file you are retrieving\n\n        Returns:\n        - File contents\n\n        Boto3 Documentation:\n        - aws codecommit get_file\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/get_file.html\n        \"\"\"\n        if not file_path:\n            return \"\"\n\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        try:\n            response = self.boto_client.get_file(repositoryName=repo_name, commitSpecifier=sha_hash, filePath=file_path)\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'RepositoryDoesNotExistException':\n                raise ValueError(f\"CodeCommit cannot retrieve PR: Repository does not exist: {repo_name}\") from e\n            # if the file does not exist, but is flagged as optional, then return an empty string\n            if optional and e.response[\"Error\"][\"Code\"] == 'FileDoesNotExistException':\n                return \"\"\n            raise ValueError(f\"CodeCommit cannot retrieve file '{file_path}' from repository '{repo_name}'\") from e\n        except Exception as e:\n            raise ValueError(f\"CodeCommit cannot retrieve file '{file_path}' from repository '{repo_name}'\") from e\n        if \"fileContent\" not in response:\n            raise ValueError(f\"File content is empty for file: {file_path}\")\n\n        return response.get(\"fileContent\", \"\")\n\n    def get_pr(self, repo_name: str, pr_number: int):\n        \"\"\"\n        Get a information about a CodeCommit PR.\n\n        Args:\n        - repo_name: Name of the repository\n        - pr_number: The PR number you are requesting\n\n        Returns:\n        - CodeCommitPullRequestResponse object\n\n        Boto3 Documentation:\n        - aws codecommit get_pull_request\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/get_pull_request.html\n        \"\"\"\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        try:\n            response = self.boto_client.get_pull_request(pullRequestId=str(pr_number))\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'PullRequestDoesNotExistException':\n                raise ValueError(f\"CodeCommit cannot retrieve PR: PR number does not exist: {pr_number}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'RepositoryDoesNotExistException':\n                raise ValueError(f\"CodeCommit cannot retrieve PR: Repository does not exist: {repo_name}\") from e\n            raise ValueError(f\"CodeCommit cannot retrieve PR: {pr_number}: boto client error\") from e\n        except Exception as e:\n            raise ValueError(f\"CodeCommit cannot retrieve PR: {pr_number}\") from e\n\n        if \"pullRequest\" not in response:\n            raise ValueError(\"CodeCommit PR number not found: {pr_number}\")\n\n        return CodeCommitPullRequestResponse(response.get(\"pullRequest\", {}))\n\n    def publish_description(self, pr_number: int, pr_title: str, pr_body: str):\n        \"\"\"\n        Set the title and description on a pull request\n\n        Args:\n        - pr_number: the AWS CodeCommit pull request number\n        - pr_title: title of the pull request\n        - pr_body: body of the pull request\n\n        Returns:\n        - None\n\n        Boto3 Documentation:\n        - aws codecommit update_pull_request_title\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/update_pull_request_title.html\n        - aws codecommit update_pull_request_description\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/update_pull_request_description.html\n        \"\"\"\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        try:\n            self.boto_client.update_pull_request_title(pullRequestId=str(pr_number), title=pr_title)\n            self.boto_client.update_pull_request_description(pullRequestId=str(pr_number), description=pr_body)\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'PullRequestDoesNotExistException':\n                raise ValueError(f\"PR number does not exist: {pr_number}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'InvalidTitleException':\n                raise ValueError(f\"Invalid title for PR number: {pr_number}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'InvalidDescriptionException':\n                raise ValueError(f\"Invalid description for PR number: {pr_number}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'PullRequestAlreadyClosedException':\n                raise ValueError(f\"PR is already closed: PR number: {pr_number}\") from e\n            raise ValueError(f\"Boto3 client error calling publish_description\") from e\n        except Exception as e:\n            raise ValueError(f\"Error calling publish_description\") from e\n\n    def publish_comment(self, repo_name: str, pr_number: int, destination_commit: str, source_commit: str, comment: str, annotation_file: str = None, annotation_line: int = None):\n        \"\"\"\n        Publish a comment to a pull request\n\n        Args:\n        - repo_name: name of the repository\n        - pr_number: number of the pull request\n        - destination_commit: The commit hash you want to merge into (the \"before\" hash) (usually on the main or master branch)\n        - source_commit: The commit hash of the code you are adding (the \"after\" branch)\n        - comment: The comment you want to publish\n        - annotation_file: The file you want to annotate (optional)\n        - annotation_line: The line number you want to annotate (optional)\n\n        Comment annotations for CodeCommit are different than GitHub.\n        CodeCommit only designates the starting line number for the comment.\n        It does not support the ending line number to highlight a range of lines.\n\n        Returns:\n        - None\n\n        Boto3 Documentation:\n        - aws codecommit post_comment_for_pull_request\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/post_comment_for_pull_request.html\n        \"\"\"\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        try:\n            # If the comment has code annotations,\n            # then set the file path and line number in the location dictionary\n            if annotation_file and annotation_line:\n                self.boto_client.post_comment_for_pull_request(\n                    pullRequestId=str(pr_number),\n                    repositoryName=repo_name,\n                    beforeCommitId=destination_commit,\n                    afterCommitId=source_commit,\n                    content=comment,\n                    location={\n                        \"filePath\": annotation_file,\n                        \"filePosition\": annotation_line,\n                        \"relativeFileVersion\": \"AFTER\",\n                    },\n                )\n            else:\n                # The comment does not have code annotations\n                self.boto_client.post_comment_for_pull_request(\n                    pullRequestId=str(pr_number),\n                    repositoryName=repo_name,\n                    beforeCommitId=destination_commit,\n                    afterCommitId=source_commit,\n                    content=comment,\n                )\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'RepositoryDoesNotExistException':\n                raise ValueError(f\"Repository does not exist: {repo_name}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'PullRequestDoesNotExistException':\n                raise ValueError(f\"PR number does not exist: {pr_number}\") from e\n            raise ValueError(f\"Boto3 client error calling post_comment_for_pull_request\") from e\n        except Exception as e:\n            raise ValueError(f\"Error calling post_comment_for_pull_request\") from e\n"}
{"type": "source_file", "path": "pr_agent/__init__.py", "content": ""}
{"type": "source_file", "path": "pr_agent/algo/ai_handlers/base_ai_handler.py", "content": "from abc import ABC, abstractmethod\n\n\nclass BaseAiHandler(ABC):\n    \"\"\"\n    This class defines the interface for an AI handler to be used by the PR Agents.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(self):\n        pass\n\n    @property\n    @abstractmethod\n    def deployment_id(self):\n        pass\n\n    @abstractmethod\n    async def chat_completion(self, model: str, system: str, user: str, temperature: float = 0.2, img_path: str = None):\n        \"\"\"\n        This method should be implemented to return a chat completion from the AI model.\n        Args:\n            model (str): the name of the model to use for the chat completion\n            system (str): the system message string to use for the chat completion\n            user (str): the user message string to use for the chat completion\n            temperature (float): the temperature to use for the chat completion\n        \"\"\"\n        pass\n"}
{"type": "source_file", "path": "pr_agent/algo/types.py", "content": "from dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Optional\n\n\nclass EDIT_TYPE(Enum):\n    ADDED = 1\n    DELETED = 2\n    MODIFIED = 3\n    RENAMED = 4\n    UNKNOWN = 5\n\n\n@dataclass\nclass FilePatchInfo:\n    base_file: str\n    head_file: str\n    patch: str\n    filename: str\n    tokens: int = -1\n    edit_type: EDIT_TYPE = EDIT_TYPE.UNKNOWN\n    old_filename: str = None\n    num_plus_lines: int = -1\n    num_minus_lines: int = -1\n    language: Optional[str] = None\n    ai_file_summary: str = None\n"}
{"type": "source_file", "path": "pr_agent/cli.py", "content": "import argparse\nimport asyncio\nimport os\n\nfrom pr_agent.agent.pr_agent import PRAgent, commands\nfrom pr_agent.algo.utils import get_version\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.log import get_logger, setup_logger\n\nlog_level = os.environ.get(\"LOG_LEVEL\", \"INFO\")\nsetup_logger(log_level)\n\n\ndef set_parser():\n    parser = argparse.ArgumentParser(description='AI based pull request analyzer', usage=\n    \"\"\"\\\n    Usage: cli.py --pr-url=<URL on supported git hosting service> <command> [<args>].\n    For example:\n    - cli.py --pr_url=... review\n    - cli.py --pr_url=... describe\n    - cli.py --pr_url=... improve\n    - cli.py --pr_url=... ask \"write me a poem about this PR\"\n    - cli.py --pr_url=... reflect\n    - cli.py --issue_url=... similar_issue\n\n    Supported commands:\n    - review / review_pr - Add a review that includes a summary of the PR and specific suggestions for improvement.\n\n    - ask / ask_question [question] - Ask a question about the PR.\n\n    - describe / describe_pr - Modify the PR title and description based on the PR's contents.\n\n    - improve / improve_code - Suggest improvements to the code in the PR as pull request comments ready to commit.\n    Extended mode ('improve --extended') employs several calls, and provides a more thorough feedback\n\n    - reflect - Ask the PR author questions about the PR.\n\n    - update_changelog - Update the changelog based on the PR's contents.\n\n    - add_docs\n\n    - generate_labels\n\n\n    Configuration:\n    To edit any configuration parameter from 'configuration.toml', just add -config_path=<value>.\n    For example: 'python cli.py --pr_url=... review --pr_reviewer.extra_instructions=\"focus on the file: ...\"'\n    \"\"\")\n    parser.add_argument('--version', action='version', version=f'pr-agent {get_version()}')\n    parser.add_argument('--pr_url', type=str, help='The URL of the PR to review', default=None)\n    parser.add_argument('--issue_url', type=str, help='The URL of the Issue to review', default=None)\n    parser.add_argument('command', type=str, help='The', choices=commands, default='review')\n    parser.add_argument('rest', nargs=argparse.REMAINDER, default=[])\n    return parser\n\n\ndef run_command(pr_url, command):\n    # Preparing the command\n    run_command_str = f\"--pr_url={pr_url} {command.lstrip('/')}\"\n    args = set_parser().parse_args(run_command_str.split())\n\n    # Run the command. Feedback will appear in GitHub PR comments\n    run(args=args)\n\n\ndef run(inargs=None, args=None):\n    parser = set_parser()\n    if not args:\n        args = parser.parse_args(inargs)\n    if not args.pr_url and not args.issue_url:\n        parser.print_help()\n        return\n\n    command = args.command.lower()\n    get_settings().set(\"CONFIG.CLI_MODE\", True)\n\n    async def inner():\n        if args.issue_url:\n            result = await asyncio.create_task(PRAgent().handle_request(args.issue_url, [command] + args.rest))\n        else:\n            result = await asyncio.create_task(PRAgent().handle_request(args.pr_url, [command] + args.rest))\n\n        if get_settings().litellm.get(\"enable_callbacks\", False):\n            # There may be additional events on the event queue from the run above. If there are give them time to complete.\n            get_logger().debug(\"Waiting for event queue to complete\")\n            await asyncio.wait([task for task in asyncio.all_tasks() if task is not asyncio.current_task()])\n\n        return result\n\n    result = asyncio.run(inner())\n    if not result:\n        parser.print_help()\n\n\nif __name__ == '__main__':\n    run()\n"}
{"type": "source_file", "path": "pr_agent/git_providers/bitbucket_server_provider.py", "content": "import difflib\nimport re\n\nfrom packaging.version import parse as parse_version\nfrom typing import Optional, Tuple\nfrom urllib.parse import quote_plus, urlparse\n\nfrom atlassian.bitbucket import Bitbucket\nfrom requests.exceptions import HTTPError\n\nfrom ..algo.git_patch_processing import decode_if_bytes\nfrom ..algo.language_handler import is_valid_file\nfrom ..algo.types import EDIT_TYPE, FilePatchInfo\nfrom ..algo.utils import (find_line_number_of_relevant_line_in_file,\n                          load_large_diff)\nfrom ..config_loader import get_settings\nfrom ..log import get_logger\nfrom .git_provider import GitProvider\n\n\nclass BitbucketServerProvider(GitProvider):\n    def __init__(\n            self, pr_url: Optional[str] = None, incremental: Optional[bool] = False,\n            bitbucket_client: Optional[Bitbucket] = None,\n    ):\n        self.bitbucket_server_url = None\n        self.workspace_slug = None\n        self.repo_slug = None\n        self.repo = None\n        self.pr_num = None\n        self.pr = None\n        self.pr_url = pr_url\n        self.temp_comments = []\n        self.incremental = incremental\n        self.diff_files = None\n        self.bitbucket_pull_request_api_url = pr_url\n\n        self.bitbucket_server_url = self._parse_bitbucket_server(url=pr_url)\n        self.bitbucket_client = bitbucket_client or Bitbucket(url=self.bitbucket_server_url,\n                                                              token=get_settings().get(\"BITBUCKET_SERVER.BEARER_TOKEN\",\n                                                                                       None))\n        try:\n            self.bitbucket_api_version = parse_version(self.bitbucket_client.get(\"rest/api/1.0/application-properties\").get('version'))\n        except Exception:\n            self.bitbucket_api_version = None\n\n        if pr_url:\n            self.set_pr(pr_url)\n\n    def get_repo_settings(self):\n        try:\n            content = self.bitbucket_client.get_content_of_file(self.workspace_slug, self.repo_slug, \".pr_agent.toml\", self.get_pr_branch())\n\n            return content\n        except Exception as e:\n            if isinstance(e, HTTPError):\n                if e.response.status_code == 404:  # not found\n                    return \"\"\n\n            get_logger().error(f\"Failed to load .pr_agent.toml file, error: {e}\")\n            return \"\"\n\n    def get_pr_id(self):\n        return self.pr_num\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        \"\"\"\n        Publishes code suggestions as comments on the PR.\n        \"\"\"\n        post_parameters_list = []\n        for suggestion in code_suggestions:\n            body = suggestion[\"body\"]\n            original_suggestion = suggestion.get('original_suggestion', None)  # needed for diff code\n            if original_suggestion:\n                try:\n                    existing_code = original_suggestion['existing_code'].rstrip() + \"\\n\"\n                    improved_code = original_suggestion['improved_code'].rstrip() + \"\\n\"\n                    diff = difflib.unified_diff(existing_code.split('\\n'),\n                                                improved_code.split('\\n'), n=999)\n                    patch_orig = \"\\n\".join(diff)\n                    patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n                    diff_code = f\"\\n\\n```diff\\n{patch.rstrip()}\\n```\"\n                    # replace ```suggestion ... ``` with diff_code, using regex:\n                    body = re.sub(r'```suggestion.*?```', diff_code, body, flags=re.DOTALL)\n                except Exception as e:\n                    get_logger().exception(f\"Bitbucket failed to get diff code for publishing, error: {e}\")\n                    continue\n            relevant_file = suggestion[\"relevant_file\"]\n            relevant_lines_start = suggestion[\"relevant_lines_start\"]\n            relevant_lines_end = suggestion[\"relevant_lines_end\"]\n\n            if not relevant_lines_start or relevant_lines_start == -1:\n                get_logger().warning(\n                    f\"Failed to publish code suggestion, relevant_lines_start is {relevant_lines_start}\"\n                )\n                continue\n\n            if relevant_lines_end < relevant_lines_start:\n                get_logger().warning(\n                    f\"Failed to publish code suggestion, \"\n                    f\"relevant_lines_end is {relevant_lines_end} and \"\n                    f\"relevant_lines_start is {relevant_lines_start}\"\n                )\n                continue\n\n            if relevant_lines_end > relevant_lines_start:\n                # Bitbucket does not support multi-line suggestions so use a code block instead - https://jira.atlassian.com/browse/BSERV-4553\n                body = body.replace(\"```suggestion\", \"```\")\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_end,\n                    \"start_line\": relevant_lines_start,\n                    \"start_side\": \"RIGHT\",\n                }\n            else:  # API is different for single line comments\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_start,\n                    \"side\": \"RIGHT\",\n                }\n            post_parameters_list.append(post_parameters)\n\n        try:\n            self.publish_inline_comments(post_parameters_list)\n            return True\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().error(f\"Failed to publish code suggestion, error: {e}\")\n            return False\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        pass\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in ['get_issue_comments', 'get_labels', 'gfm_markdown', 'publish_file_comments']:\n            return False\n        return True\n\n    def set_pr(self, pr_url: str):\n        self.workspace_slug, self.repo_slug, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def get_file(self, path: str, commit_id: str):\n        file_content = \"\"\n        try:\n            file_content = self.bitbucket_client.get_content_of_file(self.workspace_slug,\n                                                                     self.repo_slug,\n                                                                     path,\n                                                                     commit_id)\n        except HTTPError as e:\n            get_logger().debug(f\"File {path} not found at commit id: {commit_id}\")\n        return file_content\n\n    def get_files(self):\n        changes = self.bitbucket_client.get_pull_requests_changes(self.workspace_slug, self.repo_slug, self.pr_num)\n        diffstat = [change[\"path\"]['toString'] for change in changes]\n        return diffstat\n\n    #gets the best common ancestor: https://git-scm.com/docs/git-merge-base\n    @staticmethod\n    def get_best_common_ancestor(source_commits_list, destination_commits_list, guaranteed_common_ancestor) -> str:\n        destination_commit_hashes = {commit['id'] for commit in destination_commits_list} | {guaranteed_common_ancestor}\n\n        for commit in source_commits_list:\n            for parent_commit in commit['parents']:\n                if parent_commit['id'] in destination_commit_hashes:\n                    return parent_commit['id']\n\n        return guaranteed_common_ancestor\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        if self.diff_files:\n            return self.diff_files\n\n        head_sha = self.pr.fromRef['latestCommit']\n\n        # if Bitbucket api version is >= 8.16 then use the merge-base api for 2-way diff calculation\n        if self.bitbucket_api_version is not None and self.bitbucket_api_version >= parse_version(\"8.16\"):\n            try:\n                base_sha = self.bitbucket_client.get(self._get_merge_base())['id']\n            except Exception as e:\n                get_logger().error(f\"Failed to get the best common ancestor for PR: {self.pr_url}, \\nerror: {e}\")\n                raise e\n        else:\n            source_commits_list = list(self.bitbucket_client.get_pull_requests_commits(\n                self.workspace_slug,\n                self.repo_slug,\n                self.pr_num\n            ))\n            # if Bitbucket api version is None or < 7.0 then do a simple diff with a guaranteed common ancestor\n            base_sha = source_commits_list[-1]['parents'][0]['id']\n            # if Bitbucket api version is 7.0-8.15 then use 2-way diff functionality for the base_sha\n            if self.bitbucket_api_version is not None and self.bitbucket_api_version >= parse_version(\"7.0\"):\n                try:\n                    destination_commits = list(\n                        self.bitbucket_client.get_commits(self.workspace_slug, self.repo_slug, base_sha,\n                                                          self.pr.toRef['latestCommit']))\n                    base_sha = self.get_best_common_ancestor(source_commits_list, destination_commits, base_sha)\n                except Exception as e:\n                    get_logger().error(\n                        f\"Failed to get the commit list for calculating best common ancestor for PR: {self.pr_url}, \\nerror: {e}\")\n                    raise e\n\n        diff_files = []\n        original_file_content_str = \"\"\n        new_file_content_str = \"\"\n\n        changes = self.bitbucket_client.get_pull_requests_changes(self.workspace_slug, self.repo_slug, self.pr_num)\n        for change in changes:\n            file_path = change['path']['toString']\n            if not is_valid_file(file_path.split(\"/\")[-1]):\n                get_logger().info(f\"Skipping a non-code file: {file_path}\")\n                continue\n\n            match change['type']:\n                case 'ADD':\n                    edit_type = EDIT_TYPE.ADDED\n                    new_file_content_str = self.get_file(file_path, head_sha)\n                    new_file_content_str = decode_if_bytes(new_file_content_str)\n                    original_file_content_str = \"\"\n                case 'DELETE':\n                    edit_type = EDIT_TYPE.DELETED\n                    new_file_content_str = \"\"\n                    original_file_content_str = self.get_file(file_path, base_sha)\n                    original_file_content_str = decode_if_bytes(original_file_content_str)\n                case 'RENAME':\n                    edit_type = EDIT_TYPE.RENAMED\n                case _:\n                    edit_type = EDIT_TYPE.MODIFIED\n                    original_file_content_str = self.get_file(file_path, base_sha)\n                    original_file_content_str = decode_if_bytes(original_file_content_str)\n                    new_file_content_str = self.get_file(file_path, head_sha)\n                    new_file_content_str = decode_if_bytes(new_file_content_str)\n\n            patch = load_large_diff(file_path, new_file_content_str, original_file_content_str, show_warning=False)\n\n            diff_files.append(\n                FilePatchInfo(\n                    original_file_content_str,\n                    new_file_content_str,\n                    patch,\n                    file_path,\n                    edit_type=edit_type,\n                )\n            )\n\n        self.diff_files = diff_files\n        return diff_files\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if not is_temporary:\n            self.bitbucket_client.add_pull_request_comment(self.workspace_slug, self.repo_slug, self.pr_num, pr_comment)\n\n    def remove_initial_comment(self):\n        try:\n            for comment in self.temp_comments:\n                self.remove_comment(comment)\n        except ValueError as e:\n            get_logger().exception(f\"Failed to remove temp comments, error: {e}\")\n\n    def remove_comment(self, comment):\n        pass\n\n    # function to create_inline_comment\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n\n        position, absolute_position = find_line_number_of_relevant_line_in_file(\n            self.get_diff_files(),\n            relevant_file.strip('`'),\n            relevant_line_in_file,\n            absolute_position\n        )\n        if position == -1:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n            subject_type = \"FILE\"\n        else:\n            subject_type = \"LINE\"\n        path = relevant_file.strip()\n        return dict(body=body, path=path, position=absolute_position) if subject_type == \"LINE\" else {}\n\n    def publish_inline_comment(self, comment: str, from_line: int, file: str, original_suggestion=None):\n        payload = {\n            \"text\": comment,\n            \"severity\": \"NORMAL\",\n            \"anchor\": {\n                \"diffType\": \"EFFECTIVE\",\n                \"path\": file,\n                \"lineType\": \"ADDED\",\n                \"line\": from_line,\n                \"fileType\": \"TO\"\n            }\n        }\n\n        try:\n            self.bitbucket_client.post(self._get_pr_comments_path(), data=payload)\n        except Exception as e:\n            get_logger().error(f\"Failed to publish inline comment to '{file}' at line {from_line}, error: {e}\")\n            raise e\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        if relevant_line_start == -1:\n            link = f\"{self.pr_url}/diff#{quote_plus(relevant_file)}\"\n        else:\n            link = f\"{self.pr_url}/diff#{quote_plus(relevant_file)}?t={relevant_line_start}\"\n        return link\n\n    def generate_link_to_relevant_line_number(self, suggestion) -> str:\n        try:\n            relevant_file = suggestion['relevant_file'].strip('`').strip(\"'\").rstrip()\n            relevant_line_str = suggestion['relevant_line'].rstrip()\n            if not relevant_line_str:\n                return \"\"\n\n            diff_files = self.get_diff_files()\n            position, absolute_position = find_line_number_of_relevant_line_in_file \\\n                (diff_files, relevant_file, relevant_line_str)\n\n            if absolute_position != -1:\n                if self.pr:\n                    link = f\"{self.pr_url}/diff#{quote_plus(relevant_file)}?t={absolute_position}\"\n                    return link\n                else:\n                    if get_settings().config.verbosity_level >= 2:\n                        get_logger().info(f\"Failed adding line link to '{relevant_file}' since PR not set\")\n            else:\n                if get_settings().config.verbosity_level >= 2:\n                    get_logger().info(f\"Failed adding line link to '{relevant_file}' since position not found\")\n\n            if absolute_position != -1 and self.pr_url:\n                link = f\"{self.pr_url}/diff#{quote_plus(relevant_file)}?t={absolute_position}\"\n                return link\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Failed adding line link to '{relevant_file}', error: {e}\")\n\n        return \"\"\n\n    def publish_inline_comments(self, comments: list[dict]):\n        for comment in comments:\n            if 'position' in comment:\n                self.publish_inline_comment(comment['body'], comment['position'], comment['path'])\n            elif 'start_line' in comment: # multi-line comment\n                # note that bitbucket does not seem to support range - only a comment on a single line - https://community.developer.atlassian.com/t/api-post-endpoint-for-inline-pull-request-comments/60452\n                self.publish_inline_comment(comment['body'], comment['start_line'], comment['path'])\n            elif 'line' in comment: # single-line comment\n                self.publish_inline_comment(comment['body'], comment['line'], comment['path'])\n            else:\n                get_logger().error(f\"Could not publish inline comment: {comment}\")\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_languages(self):\n        return {\"yaml\": 0}  # devops LOL\n\n    def get_pr_branch(self):\n        return self.pr.fromRef['displayId']\n\n    def get_pr_owner_id(self) -> str | None:\n        return self.workspace_slug\n\n    def get_pr_description_full(self):\n        if hasattr(self.pr, \"description\"):\n            return self.pr.description\n        else:\n            return None\n\n    def get_user_id(self):\n        return 0\n\n    def get_issue_comments(self):\n        raise NotImplementedError(\n            \"Bitbucket provider does not support issue comments yet\"\n        )\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        return True\n\n    @staticmethod\n    def _parse_bitbucket_server(url: str) -> str:\n        # pr url format: f\"{bitbucket_server}/projects/{project_name}/repos/{repository_name}/pull-requests/{pr_id}\"\n        parsed_url = urlparse(url)\n        server_path = parsed_url.path.split(\"/projects/\")\n        if len(server_path) > 1:\n            server_path = server_path[0].strip(\"/\")\n            return f\"{parsed_url.scheme}://{parsed_url.netloc}/{server_path}\".strip(\"/\")\n        return f\"{parsed_url.scheme}://{parsed_url.netloc}\"\n\n    @staticmethod\n    def _parse_pr_url(pr_url: str) -> Tuple[str, str, int]:\n        # pr url format: f\"{bitbucket_server}/projects/{project_name}/repos/{repository_name}/pull-requests/{pr_id}\"\n        parsed_url = urlparse(pr_url)\n\n        path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n\n        try:\n            projects_index = path_parts.index(\"projects\")\n        except ValueError:\n            projects_index = -1\n\n        try:\n            users_index = path_parts.index(\"users\")\n        except ValueError:\n            users_index = -1\n\n        if projects_index == -1 and users_index == -1:\n            raise ValueError(f\"The provided URL '{pr_url}' does not appear to be a Bitbucket PR URL\")\n\n        if projects_index != -1:\n            path_parts = path_parts[projects_index:]\n        else:\n            path_parts = path_parts[users_index:]\n\n        if len(path_parts) < 6 or path_parts[2] != \"repos\" or path_parts[4] != \"pull-requests\":\n            raise ValueError(\n                f\"The provided URL '{pr_url}' does not appear to be a Bitbucket PR URL\"\n            )\n\n        workspace_slug = path_parts[1]\n        if users_index != -1:\n            workspace_slug = f\"~{workspace_slug}\"\n        repo_slug = path_parts[3]\n        try:\n            pr_number = int(path_parts[5])\n        except ValueError as e:\n            raise ValueError(f\"Unable to convert PR number '{path_parts[5]}' to integer\") from e\n\n        return workspace_slug, repo_slug, pr_number\n\n    def _get_repo(self):\n        if self.repo is None:\n            self.repo = self.bitbucket_client.get_repo(self.workspace_slug, self.repo_slug)\n        return self.repo\n\n    def _get_pr(self):\n        try:\n            pr = self.bitbucket_client.get_pull_request(self.workspace_slug, self.repo_slug,\n                                                        pull_request_id=self.pr_num)\n            return type('new_dict', (object,), pr)\n        except Exception as e:\n            get_logger().error(f\"Failed to get pull request, error: {e}\")\n            raise e\n\n    def _get_pr_file_content(self, remote_link: str):\n        return \"\"\n\n    def get_commit_messages(self):\n        return \"\"\n\n    # bitbucket does not support labels\n    def publish_description(self, pr_title: str, description: str):\n        payload = {\n            \"version\": self.pr.version,\n            \"description\": description,\n            \"title\": pr_title,\n            \"reviewers\": self.pr.reviewers  # needs to be sent otherwise gets wiped\n        }\n        try:\n            self.bitbucket_client.update_pull_request(self.workspace_slug, self.repo_slug, str(self.pr_num), payload)\n        except Exception as e:\n            get_logger().error(f\"Failed to update pull request, error: {e}\")\n            raise e\n\n    # bitbucket does not support labels\n    def publish_labels(self, pr_types: list):\n        pass\n\n    # bitbucket does not support labels\n    def get_pr_labels(self, update=False):\n        pass\n\n    def _get_pr_comments_path(self):\n        return f\"rest/api/latest/projects/{self.workspace_slug}/repos/{self.repo_slug}/pull-requests/{self.pr_num}/comments\"\n\n    def _get_merge_base(self):\n        return f\"rest/api/latest/projects/{self.workspace_slug}/repos/{self.repo_slug}/pull-requests/{self.pr_num}/merge-base\"\n"}
{"type": "source_file", "path": "pr_agent/algo/ai_handlers/litellm_ai_handler.py", "content": "import os\n\nimport litellm\nimport openai\nimport requests\nfrom litellm import acompletion\nfrom tenacity import retry, retry_if_exception_type, stop_after_attempt\n\nfrom pr_agent.algo import CLAUDE_EXTENDED_THINKING_MODELS, NO_SUPPORT_TEMPERATURE_MODELS, SUPPORT_REASONING_EFFORT_MODELS, USER_MESSAGE_ONLY_MODELS\nfrom pr_agent.algo.ai_handlers.base_ai_handler import BaseAiHandler\nfrom pr_agent.algo.utils import ReasoningEffort, get_version\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.log import get_logger\nimport json\n\nOPENAI_RETRIES = 5\n\n\nclass LiteLLMAIHandler(BaseAiHandler):\n    \"\"\"\n    This class handles interactions with the OpenAI API for chat completions.\n    It initializes the API key and other settings from a configuration file,\n    and provides a method for performing chat completions using the OpenAI ChatCompletion API.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the OpenAI API key and other settings from a configuration file.\n        Raises a ValueError if the OpenAI key is missing.\n        \"\"\"\n        self.azure = False\n        self.api_base = None\n        self.repetition_penalty = None\n        if get_settings().get(\"OPENAI.KEY\", None):\n            openai.api_key = get_settings().openai.key\n            litellm.openai_key = get_settings().openai.key\n        elif 'OPENAI_API_KEY' not in os.environ:\n            litellm.api_key = \"dummy_key\"\n        if get_settings().get(\"aws.AWS_ACCESS_KEY_ID\"):\n            assert get_settings().aws.AWS_SECRET_ACCESS_KEY and get_settings().aws.AWS_REGION_NAME, \"AWS credentials are incomplete\"\n            os.environ[\"AWS_ACCESS_KEY_ID\"] = get_settings().aws.AWS_ACCESS_KEY_ID\n            os.environ[\"AWS_SECRET_ACCESS_KEY\"] = get_settings().aws.AWS_SECRET_ACCESS_KEY\n            os.environ[\"AWS_REGION_NAME\"] = get_settings().aws.AWS_REGION_NAME\n        if get_settings().get(\"LITELLM.DROP_PARAMS\", None):\n            litellm.drop_params = get_settings().litellm.drop_params\n        if get_settings().get(\"LITELLM.SUCCESS_CALLBACK\", None):\n            litellm.success_callback = get_settings().litellm.success_callback\n        if get_settings().get(\"LITELLM.FAILURE_CALLBACK\", None):\n            litellm.failure_callback = get_settings().litellm.failure_callback\n        if get_settings().get(\"LITELLM.SERVICE_CALLBACK\", None):\n            litellm.service_callback = get_settings().litellm.service_callback\n        if get_settings().get(\"OPENAI.ORG\", None):\n            litellm.organization = get_settings().openai.org\n        if get_settings().get(\"OPENAI.API_TYPE\", None):\n            if get_settings().openai.api_type == \"azure\":\n                self.azure = True\n                litellm.azure_key = get_settings().openai.key\n        if get_settings().get(\"OPENAI.API_VERSION\", None):\n            litellm.api_version = get_settings().openai.api_version\n        if get_settings().get(\"OPENAI.API_BASE\", None):\n            litellm.api_base = get_settings().openai.api_base\n        if get_settings().get(\"ANTHROPIC.KEY\", None):\n            litellm.anthropic_key = get_settings().anthropic.key\n        if get_settings().get(\"COHERE.KEY\", None):\n            litellm.cohere_key = get_settings().cohere.key\n        if get_settings().get(\"GROQ.KEY\", None):\n            litellm.api_key = get_settings().groq.key\n        if get_settings().get(\"REPLICATE.KEY\", None):\n            litellm.replicate_key = get_settings().replicate.key\n        if get_settings().get(\"HUGGINGFACE.KEY\", None):\n            litellm.huggingface_key = get_settings().huggingface.key\n        if get_settings().get(\"HUGGINGFACE.API_BASE\", None) and 'huggingface' in get_settings().config.model:\n            litellm.api_base = get_settings().huggingface.api_base\n            self.api_base = get_settings().huggingface.api_base\n        if get_settings().get(\"OLLAMA.API_BASE\", None):\n            litellm.api_base = get_settings().ollama.api_base\n            self.api_base = get_settings().ollama.api_base\n        if get_settings().get(\"HUGGINGFACE.REPETITION_PENALTY\", None):\n            self.repetition_penalty = float(get_settings().huggingface.repetition_penalty)\n        if get_settings().get(\"VERTEXAI.VERTEX_PROJECT\", None):\n            litellm.vertex_project = get_settings().vertexai.vertex_project\n            litellm.vertex_location = get_settings().get(\n                \"VERTEXAI.VERTEX_LOCATION\", None\n            )\n        # Google AI Studio\n        # SEE https://docs.litellm.ai/docs/providers/gemini\n        if get_settings().get(\"GOOGLE_AI_STUDIO.GEMINI_API_KEY\", None):\n          os.environ[\"GEMINI_API_KEY\"] = get_settings().google_ai_studio.gemini_api_key\n\n        # Support deepseek models\n        if get_settings().get(\"DEEPSEEK.KEY\", None):\n            os.environ['DEEPSEEK_API_KEY'] = get_settings().get(\"DEEPSEEK.KEY\")\n\n        # Support deepinfra models\n        if get_settings().get(\"DEEPINFRA.KEY\", None):\n            os.environ['DEEPINFRA_API_KEY'] = get_settings().get(\"DEEPINFRA.KEY\")\n\n        # Models that only use user meessage\n        self.user_message_only_models = USER_MESSAGE_ONLY_MODELS\n\n        # Model that doesn't support temperature argument\n        self.no_support_temperature_models = NO_SUPPORT_TEMPERATURE_MODELS\n\n        # Models that support reasoning effort\n        self.support_reasoning_models = SUPPORT_REASONING_EFFORT_MODELS\n\n        # Models that support extended thinking\n        self.claude_extended_thinking_models = CLAUDE_EXTENDED_THINKING_MODELS\n\n    def prepare_logs(self, response, system, user, resp, finish_reason):\n        response_log = response.dict().copy()\n        response_log['system'] = system\n        response_log['user'] = user\n        response_log['output'] = resp\n        response_log['finish_reason'] = finish_reason\n        if hasattr(self, 'main_pr_language'):\n            response_log['main_pr_language'] = self.main_pr_language\n        else:\n            response_log['main_pr_language'] = 'unknown'\n        return response_log\n\n    def _configure_claude_extended_thinking(self, model: str, kwargs: dict) -> dict:\n        \"\"\"\n        Configure Claude extended thinking parameters if applicable.\n\n        Args:\n            model (str): The AI model being used\n            kwargs (dict): The keyword arguments for the model call\n\n        Returns:\n            dict: Updated kwargs with extended thinking configuration\n        \"\"\"\n        extended_thinking_budget_tokens = get_settings().config.get(\"extended_thinking_budget_tokens\", 2048)\n        extended_thinking_max_output_tokens = get_settings().config.get(\"extended_thinking_max_output_tokens\", 4096)\n\n        # Validate extended thinking parameters\n        if not isinstance(extended_thinking_budget_tokens, int) or extended_thinking_budget_tokens <= 0:\n            raise ValueError(f\"extended_thinking_budget_tokens must be a positive integer, got {extended_thinking_budget_tokens}\")\n        if not isinstance(extended_thinking_max_output_tokens, int) or extended_thinking_max_output_tokens <= 0:\n            raise ValueError(f\"extended_thinking_max_output_tokens must be a positive integer, got {extended_thinking_max_output_tokens}\")\n        if extended_thinking_max_output_tokens < extended_thinking_budget_tokens:\n            raise ValueError(f\"extended_thinking_max_output_tokens ({extended_thinking_max_output_tokens}) must be greater than or equal to extended_thinking_budget_tokens ({extended_thinking_budget_tokens})\")\n\n        kwargs[\"thinking\"] = {\n            \"type\": \"enabled\",\n            \"budget_tokens\": extended_thinking_budget_tokens\n        }\n        if get_settings().config.verbosity_level >= 2:\n            get_logger().info(f\"Adding max output tokens {extended_thinking_max_output_tokens} to model {model}, extended thinking budget tokens: {extended_thinking_budget_tokens}\")\n        kwargs[\"max_tokens\"] = extended_thinking_max_output_tokens\n\n        # temperature may only be set to 1 when thinking is enabled\n        if get_settings().config.verbosity_level >= 2:\n            get_logger().info(\"Temperature may only be set to 1 when thinking is enabled with claude models.\")\n        kwargs[\"temperature\"] = 1\n\n        return kwargs\n\n    def add_litellm_callbacks(selfs, kwargs) -> dict:\n        captured_extra = []\n\n        def capture_logs(message):\n            # Parsing the log message and context\n            record = message.record\n            log_entry = {}\n            if record.get('extra', None).get('command', None) is not None:\n                log_entry.update({\"command\": record['extra'][\"command\"]})\n            if record.get('extra', {}).get('pr_url', None) is not None:\n                log_entry.update({\"pr_url\": record['extra'][\"pr_url\"]})\n\n            # Append the log entry to the captured_logs list\n            captured_extra.append(log_entry)\n\n        # Adding the custom sink to Loguru\n        handler_id = get_logger().add(capture_logs)\n        get_logger().debug(\"Capturing logs for litellm callbacks\")\n        get_logger().remove(handler_id)\n\n        context = captured_extra[0] if len(captured_extra) > 0 else None\n\n        command = context.get(\"command\", \"unknown\")\n        pr_url = context.get(\"pr_url\", \"unknown\")\n        git_provider = get_settings().config.git_provider\n\n        metadata = dict()\n        callbacks = litellm.success_callback + litellm.failure_callback + litellm.service_callback\n        if \"langfuse\" in callbacks:\n            metadata.update({\n                \"trace_name\": command,\n                \"tags\": [git_provider, command, f'version:{get_version()}'],\n                \"trace_metadata\": {\n                    \"command\": command,\n                    \"pr_url\": pr_url,\n                },\n            })\n        if \"langsmith\" in callbacks:\n            metadata.update({\n                \"run_name\": command,\n                \"tags\": [git_provider, command, f'version:{get_version()}'],\n                \"extra\": {\n                    \"metadata\": {\n                        \"command\": command,\n                        \"pr_url\": pr_url,\n                    }\n                },\n            })\n\n        # Adding the captured logs to the kwargs\n        kwargs[\"metadata\"] = metadata\n\n        return kwargs\n\n    @property\n    def deployment_id(self):\n        \"\"\"\n        Returns the deployment ID for the OpenAI API.\n        \"\"\"\n        return get_settings().get(\"OPENAI.DEPLOYMENT_ID\", None)\n\n    @retry(\n        retry=retry_if_exception_type((openai.APIError, openai.APIConnectionError, openai.APITimeoutError)), # No retry on RateLimitError\n        stop=stop_after_attempt(OPENAI_RETRIES)\n    )\n    async def chat_completion(self, model: str, system: str, user: str, temperature: float = 0.2, img_path: str = None):\n        try:\n            resp, finish_reason = None, None\n            deployment_id = self.deployment_id\n            if self.azure:\n                model = 'azure/' + model\n            if 'claude' in model and not system:\n                system = \"No system prompt provided\"\n                get_logger().warning(\n                    \"Empty system prompt for claude model. Adding a newline character to prevent OpenAI API error.\")\n            messages = [{\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\": user}]\n\n            if img_path:\n                try:\n                    # check if the image link is alive\n                    r = requests.head(img_path, allow_redirects=True)\n                    if r.status_code == 404:\n                        error_msg = f\"The image link is not [alive](img_path).\\nPlease repost the original image as a comment, and send the question again with 'quote reply' (see [instructions](https://pr-agent-docs.codium.ai/tools/ask/#ask-on-images-using-the-pr-code-as-context)).\"\n                        get_logger().error(error_msg)\n                        return f\"{error_msg}\", \"error\"\n                except Exception as e:\n                    get_logger().error(f\"Error fetching image: {img_path}\", e)\n                    return f\"Error fetching image: {img_path}\", \"error\"\n                messages[1][\"content\"] = [{\"type\": \"text\", \"text\": messages[1][\"content\"]},\n                                          {\"type\": \"image_url\", \"image_url\": {\"url\": img_path}}]\n\n            # Currently, some models do not support a separate system and user prompts\n            if model in self.user_message_only_models or get_settings().config.custom_reasoning_model:\n                user = f\"{system}\\n\\n\\n{user}\"\n                system = \"\"\n                get_logger().info(f\"Using model {model}, combining system and user prompts\")\n                messages = [{\"role\": \"user\", \"content\": user}]\n                kwargs = {\n                    \"model\": model,\n                    \"deployment_id\": deployment_id,\n                    \"messages\": messages,\n                    \"timeout\": get_settings().config.ai_timeout,\n                    \"api_base\": self.api_base,\n                }\n            else:\n                kwargs = {\n                    \"model\": model,\n                    \"deployment_id\": deployment_id,\n                    \"messages\": messages,\n                    \"timeout\": get_settings().config.ai_timeout,\n                    \"api_base\": self.api_base,\n                }\n\n            # Add temperature only if model supports it\n            if model not in self.no_support_temperature_models and not get_settings().config.custom_reasoning_model:\n                # get_logger().info(f\"Adding temperature with value {temperature} to model {model}.\")\n                kwargs[\"temperature\"] = temperature\n\n            # Add reasoning_effort if model supports it\n            if (model in self.support_reasoning_models):\n                supported_reasoning_efforts = [ReasoningEffort.HIGH.value, ReasoningEffort.MEDIUM.value, ReasoningEffort.LOW.value]\n                reasoning_effort = get_settings().config.reasoning_effort if (get_settings().config.reasoning_effort in supported_reasoning_efforts) else ReasoningEffort.MEDIUM.value\n                get_logger().info(f\"Adding reasoning_effort with value {reasoning_effort} to model {model}.\")\n                kwargs[\"reasoning_effort\"] = reasoning_effort\n\n            # https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking\n            if (model in self.claude_extended_thinking_models) and get_settings().config.get(\"enable_claude_extended_thinking\", False):\n                kwargs = self._configure_claude_extended_thinking(model, kwargs)\n\n            if get_settings().litellm.get(\"enable_callbacks\", False):\n                kwargs = self.add_litellm_callbacks(kwargs)\n\n            seed = get_settings().config.get(\"seed\", -1)\n            if temperature > 0 and seed >= 0:\n                raise ValueError(f\"Seed ({seed}) is not supported with temperature ({temperature}) > 0\")\n            elif seed >= 0:\n                get_logger().info(f\"Using fixed seed of {seed}\")\n                kwargs[\"seed\"] = seed\n\n            if self.repetition_penalty:\n                kwargs[\"repetition_penalty\"] = self.repetition_penalty\n\n            #Added support for extra_headers while using litellm to call underlying model, via a api management gateway, would allow for passing custom headers for security and authorization\n            if get_settings().get(\"LITELLM.EXTRA_HEADERS\", None):\n                try:\n                    litellm_extra_headers = json.loads(get_settings().litellm.extra_headers)\n                    if not isinstance(litellm_extra_headers, dict):\n                        raise ValueError(\"LITELLM.EXTRA_HEADERS must be a JSON object\")\n                except json.JSONDecodeError as e:\n                    raise ValueError(f\"LITELLM.EXTRA_HEADERS contains invalid JSON: {str(e)}\")\n                kwargs[\"extra_headers\"] = litellm_extra_headers\n\n            get_logger().debug(\"Prompts\", artifact={\"system\": system, \"user\": user})\n\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"\\nSystem prompt:\\n{system}\")\n                get_logger().info(f\"\\nUser prompt:\\n{user}\")\n\n            response = await acompletion(**kwargs)\n        except (openai.APIError, openai.APITimeoutError) as e:\n            get_logger().warning(f\"Error during LLM inference: {e}\")\n            raise\n        except (openai.RateLimitError) as e:\n            get_logger().error(f\"Rate limit error during LLM inference: {e}\")\n            raise\n        except (Exception) as e:\n            get_logger().warning(f\"Unknown error during LLM inference: {e}\")\n            raise openai.APIError from e\n        if response is None or len(response[\"choices\"]) == 0:\n            raise openai.APIError\n        else:\n            resp = response[\"choices\"][0]['message']['content']\n            finish_reason = response[\"choices\"][0][\"finish_reason\"]\n            get_logger().debug(f\"\\nAI response:\\n{resp}\")\n\n            # log the full response for debugging\n            response_log = self.prepare_logs(response, system, user, resp, finish_reason)\n            get_logger().debug(\"Full_response\", artifact=response_log)\n\n            # for CLI debugging\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"\\nAI response:\\n{resp}\")\n\n        return resp, finish_reason\n"}
{"type": "source_file", "path": "pr_agent/git_providers/codecommit_provider.py", "content": "import os\nimport re\nfrom collections import Counter\nfrom typing import List, Optional, Tuple\nfrom urllib.parse import urlparse\n\nfrom pr_agent.algo.language_handler import is_valid_file\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\nfrom pr_agent.git_providers.codecommit_client import CodeCommitClient\n\nfrom ..algo.utils import load_large_diff\nfrom ..config_loader import get_settings\nfrom ..log import get_logger\nfrom .git_provider import GitProvider\n\n\nclass PullRequestCCMimic:\n    \"\"\"\n    This class mimics the PullRequest class from the PyGithub library for the CodeCommitProvider.\n    \"\"\"\n\n    def __init__(self, title: str, diff_files: List[FilePatchInfo]):\n        self.title = title\n        self.diff_files = diff_files\n        self.description = None\n        self.source_commit = None\n        self.source_branch = None  # the branch containing your new code changes\n        self.destination_commit = None\n        self.destination_branch = None  # the branch you are going to merge into\n\n\nclass CodeCommitFile:\n    \"\"\"\n    This class represents a file in a pull request in CodeCommit.\n    \"\"\"\n\n    def __init__(\n        self,\n        a_path: str,\n        a_blob_id: str,\n        b_path: str,\n        b_blob_id: str,\n        edit_type: EDIT_TYPE,\n    ):\n        self.a_path = a_path\n        self.a_blob_id = a_blob_id\n        self.b_path = b_path\n        self.b_blob_id = b_blob_id\n        self.edit_type: EDIT_TYPE = edit_type\n        self.filename = b_path if b_path else a_path\n\n\nclass CodeCommitProvider(GitProvider):\n    \"\"\"\n    This class implements the GitProvider interface for AWS CodeCommit repositories.\n    \"\"\"\n\n    def __init__(self, pr_url: Optional[str] = None, incremental: Optional[bool] = False):\n        self.codecommit_client = CodeCommitClient()\n        self.aws_client = None\n        self.repo_name = None\n        self.pr_num = None\n        self.pr = None\n        self.diff_files = None\n        self.git_files = None\n        self.pr_url = pr_url\n        if pr_url:\n            self.set_pr(pr_url)\n\n    def provider_name(self):\n        return \"CodeCommit\"\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in [\n            \"get_issue_comments\",\n            \"create_inline_comment\",\n            \"publish_inline_comments\",\n            \"get_labels\",\n            \"gfm_markdown\"\n        ]:\n            return False\n        return True\n\n    def set_pr(self, pr_url: str):\n        self.repo_name, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def get_files(self) -> list[CodeCommitFile]:\n        # bring files from CodeCommit only once\n        if self.git_files:\n            return self.git_files\n\n        self.git_files = []\n        differences = self.codecommit_client.get_differences(self.repo_name, self.pr.destination_commit, self.pr.source_commit)\n        for item in differences:\n            self.git_files.append(CodeCommitFile(item.before_blob_path,\n                                                 item.before_blob_id,\n                                                 item.after_blob_path,\n                                                 item.after_blob_id,\n                                                 CodeCommitProvider._get_edit_type(item.change_type)))\n        return self.git_files\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        \"\"\"\n        Retrieves the list of files that have been modified, added, deleted, or renamed in a pull request in CodeCommit,\n        along with their content and patch information.\n\n        Returns:\n            diff_files (List[FilePatchInfo]): List of FilePatchInfo objects representing the modified, added, deleted,\n            or renamed files in the merge request.\n        \"\"\"\n        # bring files from CodeCommit only once\n        if self.diff_files:\n            return self.diff_files\n\n        self.diff_files = []\n\n        files = self.get_files()\n        for diff_item in files:\n            patch_filename = \"\"\n            if diff_item.a_blob_id is not None:\n                patch_filename = diff_item.a_path\n                original_file_content_str = self.codecommit_client.get_file(\n                    self.repo_name, diff_item.a_path, self.pr.destination_commit)\n                if isinstance(original_file_content_str, (bytes, bytearray)):\n                    original_file_content_str = original_file_content_str.decode(\"utf-8\")\n            else:\n                original_file_content_str = \"\"\n\n            if diff_item.b_blob_id is not None:\n                patch_filename = diff_item.b_path\n                new_file_content_str = self.codecommit_client.get_file(self.repo_name, diff_item.b_path, self.pr.source_commit)\n                if isinstance(new_file_content_str, (bytes, bytearray)):\n                    new_file_content_str = new_file_content_str.decode(\"utf-8\")\n            else:\n                new_file_content_str = \"\"\n\n            patch = load_large_diff(patch_filename, new_file_content_str, original_file_content_str)\n\n            # Store the diffs as a list of FilePatchInfo objects\n            info = FilePatchInfo(\n                original_file_content_str,\n                new_file_content_str,\n                patch,\n                diff_item.b_path,\n                edit_type=diff_item.edit_type,\n                old_filename=None\n                if diff_item.a_path == diff_item.b_path\n                else diff_item.a_path,\n            )\n            # Only add valid files to the diff list\n            # \"bad extensions\" are set in the language_extensions.toml file\n            # a \"valid file\" is one that is not in the \"bad extensions\" list\n            if is_valid_file(info.filename):\n                self.diff_files.append(info)\n\n        return self.diff_files\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        try:\n            self.codecommit_client.publish_description(\n                pr_number=self.pr_num,\n                pr_title=pr_title,\n                pr_body=CodeCommitProvider._add_additional_newlines(pr_body),\n            )\n        except Exception as e:\n            raise ValueError(f\"CodeCommit Cannot publish description for PR: {self.pr_num}\") from e\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if is_temporary:\n            get_logger().info(pr_comment)\n            return\n\n        pr_comment = CodeCommitProvider._remove_markdown_html(pr_comment)\n        pr_comment = CodeCommitProvider._add_additional_newlines(pr_comment)\n\n        try:\n            self.codecommit_client.publish_comment(\n                repo_name=self.repo_name,\n                pr_number=self.pr_num,\n                destination_commit=self.pr.destination_commit,\n                source_commit=self.pr.source_commit,\n                comment=pr_comment,\n            )\n        except Exception as e:\n            raise ValueError(f\"CodeCommit Cannot publish comment for PR: {self.pr_num}\") from e\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        counter = 1\n        for suggestion in code_suggestions:\n            # Verify that each suggestion has the required keys\n            if not all(key in suggestion for key in [\"body\", \"relevant_file\", \"relevant_lines_start\"]):\n                get_logger().warning(f\"Skipping code suggestion #{counter}: Each suggestion must have 'body', 'relevant_file', 'relevant_lines_start' keys\")\n                continue\n\n            # Publish the code suggestion to CodeCommit\n            try:\n                get_logger().debug(f\"Code Suggestion #{counter} in file: {suggestion['relevant_file']}: {suggestion['relevant_lines_start']}\")\n                self.codecommit_client.publish_comment(\n                    repo_name=self.repo_name,\n                    pr_number=self.pr_num,\n                    destination_commit=self.pr.destination_commit,\n                    source_commit=self.pr.source_commit,\n                    comment=suggestion[\"body\"],\n                    annotation_file=suggestion[\"relevant_file\"],\n                    annotation_line=suggestion[\"relevant_lines_start\"],\n                )\n            except Exception as e:\n                raise ValueError(f\"CodeCommit Cannot publish code suggestions for PR: {self.pr_num}\") from e\n\n            counter += 1\n\n        # The calling function passes in a list of code suggestions, and this function publishes each suggestion one at a time.\n        # If we were to return False here, the calling function will attempt to publish the same list of code suggestions again, one at a time.\n        # Since this function publishes the suggestions one at a time anyway, we always return True here to avoid the retry.\n        return True\n\n    def publish_labels(self, labels):\n        return [\"\"]  # not implemented yet\n\n    def get_pr_labels(self, update=False):\n        return [\"\"]  # not implemented yet\n\n    def remove_initial_comment(self):\n        return \"\"  # not implemented yet\n\n    def remove_comment(self, comment):\n        return \"\"  # not implemented yet\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        # https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/post_comment_for_compared_commit.html\n        raise NotImplementedError(\"CodeCommit provider does not support publishing inline comments yet\")\n\n    def publish_inline_comments(self, comments: list[dict]):\n        raise NotImplementedError(\"CodeCommit provider does not support publishing inline comments yet\")\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_pr_id(self):\n        \"\"\"\n        Returns the PR ID in the format: \"repo_name/pr_number\".\n        Note: This is an internal identifier for PR-Agent,\n        and is not the same as the CodeCommit PR identifier.\n        \"\"\"\n        try:\n            pr_id = f\"{self.repo_name}/{self.pr_num}\"\n            return pr_id\n        except:\n            return \"\"\n\n    def get_languages(self):\n        \"\"\"\n        Returns a dictionary of languages, containing the percentage of each language used in the PR.\n\n        Returns:\n        - dict: A dictionary where each key is a language name and the corresponding value is the percentage of that language in the PR.\n        \"\"\"\n        commit_files = self.get_files()\n        filenames = [ item.filename for item in commit_files ]\n        extensions = CodeCommitProvider._get_file_extensions(filenames)\n\n        # Calculate the percentage of each file extension in the PR\n        percentages = CodeCommitProvider._get_language_percentages(extensions)\n\n        # The global language_extension_map is a dictionary of languages,\n        # where each dictionary item is a BoxList of extensions.\n        # We want a dictionary of extensions,\n        # where each dictionary item is a language name.\n        # We build that language->extension dictionary here in main_extensions_flat.\n        main_extensions_flat = {}\n        language_extension_map_org = get_settings().language_extension_map_org\n        language_extension_map = {k.lower(): v for k, v in language_extension_map_org.items()}\n        for language, extensions in language_extension_map.items():\n            for ext in extensions:\n                main_extensions_flat[ext] = language\n\n        # Map the file extension/languages to percentages\n        languages = {}\n        for ext, pct in percentages.items():\n            languages[main_extensions_flat.get(ext, \"\")] = pct\n\n        return languages\n\n    def get_pr_branch(self):\n        return self.pr.source_branch\n\n    def get_pr_description_full(self) -> str:\n        return self.pr.description\n\n    def get_user_id(self):\n        return -1  # not implemented yet\n\n    def get_issue_comments(self):\n        raise NotImplementedError(\"CodeCommit provider does not support issue comments yet\")\n\n    def get_repo_settings(self):\n        # a local \".pr_agent.toml\" settings file is optional\n        settings_filename = \".pr_agent.toml\"\n        return self.codecommit_client.get_file(self.repo_name, settings_filename, self.pr.source_commit, optional=True)\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        get_logger().info(\"CodeCommit provider does not support eyes reaction yet\")\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        get_logger().info(\"CodeCommit provider does not support removing reactions yet\")\n        return True\n\n    @staticmethod\n    def _parse_pr_url(pr_url: str) -> Tuple[str, int]:\n        \"\"\"\n        Parse the CodeCommit PR URL and return the repository name and PR number.\n\n        Args:\n        - pr_url: the full AWS CodeCommit pull request URL\n\n        Returns:\n        - Tuple[str, int]: A tuple containing the repository name and PR number.\n        \"\"\"\n        # Example PR URL:\n        # https://us-east-1.console.aws.amazon.com/codesuite/codecommit/repositories/__MY_REPO__/pull-requests/123456\"\n        parsed_url = urlparse(pr_url)\n\n        if not CodeCommitProvider._is_valid_codecommit_hostname(parsed_url.netloc):\n            raise ValueError(f\"The provided URL is not a valid CodeCommit URL: {pr_url}\")\n\n        path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n\n        if (\n            len(path_parts) < 6\n            or path_parts[0] != \"codesuite\"\n            or path_parts[1] != \"codecommit\"\n            or path_parts[2] != \"repositories\"\n            or path_parts[4] != \"pull-requests\"\n        ):\n            raise ValueError(f\"The provided URL does not appear to be a CodeCommit PR URL: {pr_url}\")\n\n        repo_name = path_parts[3]\n\n        try:\n            pr_number = int(path_parts[5])\n        except ValueError as e:\n            raise ValueError(f\"Unable to convert PR number to integer: '{path_parts[5]}'\") from e\n\n        return repo_name, pr_number\n\n    @staticmethod\n    def _is_valid_codecommit_hostname(hostname: str) -> bool:\n        \"\"\"\n        Check if the provided hostname is a valid AWS CodeCommit hostname.\n\n        This is not an exhaustive check of AWS region names,\n        but instead uses a regex to check for matching AWS region patterns.\n\n        Args:\n        - hostname: the hostname to check\n\n        Returns:\n        - bool: True if the hostname is valid, False otherwise.\n        \"\"\"\n        return re.match(r\"^[a-z]{2}-(gov-)?[a-z]+-\\d\\.console\\.aws\\.amazon\\.com$\", hostname) is not None\n\n    def _get_pr(self):\n        response = self.codecommit_client.get_pr(self.repo_name, self.pr_num)\n\n        if len(response.targets) == 0:\n            raise ValueError(f\"No files found in CodeCommit PR: {self.pr_num}\")\n\n        # TODO: implement support for multiple targets in one CodeCommit PR\n        #       for now, we are only using the first target in the PR\n        if len(response.targets) > 1:\n            get_logger().warning(\n                \"Multiple targets in one PR is not supported for CodeCommit yet. Continuing, using the first target only...\"\n            )\n\n        # Return our object that mimics PullRequest class from the PyGithub library\n        # (This strategy was copied from the LocalGitProvider)\n        mimic = PullRequestCCMimic(response.title, self.diff_files)\n        mimic.description = response.description\n        mimic.source_commit = response.targets[0].source_commit\n        mimic.source_branch = response.targets[0].source_branch\n        mimic.destination_commit = response.targets[0].destination_commit\n        mimic.destination_branch = response.targets[0].destination_branch\n\n        return mimic\n\n    def get_commit_messages(self):\n        return \"\"  # not implemented yet\n\n    @staticmethod\n    def _add_additional_newlines(body: str) -> str:\n        \"\"\"\n        Replace single newlines in a PR body with double newlines.\n\n        CodeCommit Markdown does not seem to render as well as GitHub Markdown,\n        so we add additional newlines to the PR body to make it more readable in CodeCommit.\n\n        Args:\n        - body: the PR body\n\n        Returns:\n        - str: the PR body with the double newlines added\n        \"\"\"\n        return re.sub(r'(?<!\\n)\\n(?!\\n)', '\\n\\n', body)\n\n    @staticmethod\n    def _remove_markdown_html(comment: str) -> str:\n        \"\"\"\n        Remove the HTML tags from a PR comment.\n\n        CodeCommit Markdown does not seem to render as well as GitHub Markdown,\n        so we remove the HTML tags from the PR comment to make it more readable in CodeCommit.\n\n        Args:\n        - comment: the PR comment\n\n        Returns:\n        - str: the PR comment with the HTML tags removed\n        \"\"\"\n        comment = comment.replace(\"<details>\", \"\")\n        comment = comment.replace(\"</details>\", \"\")\n        comment = comment.replace(\"<summary>\", \"\")\n        comment = comment.replace(\"</summary>\", \"\")\n        return comment\n\n    @staticmethod\n    def _get_edit_type(codecommit_change_type: str):\n        \"\"\"\n        Convert the CodeCommit change type string to the EDIT_TYPE enum.\n        The CodeCommit change type string is returned from the get_differences SDK method.\n\n        Args:\n        - codecommit_change_type: the CodeCommit change type string\n\n        Returns:\n        - An EDIT_TYPE enum representing the modified, added, deleted, or renamed file in the PR diff.\n        \"\"\"\n        t = codecommit_change_type.upper()\n        edit_type = None\n        if t == \"A\":\n            edit_type = EDIT_TYPE.ADDED\n        elif t == \"D\":\n            edit_type = EDIT_TYPE.DELETED\n        elif t == \"M\":\n            edit_type = EDIT_TYPE.MODIFIED\n        elif t == \"R\":\n            edit_type = EDIT_TYPE.RENAMED\n        return edit_type\n\n    @staticmethod\n    def _get_file_extensions(filenames):\n        \"\"\"\n        Return a list of file extensions from a list of filenames.\n        The returned extensions will include the dot \".\" prefix,\n        to accommodate for the dots in the existing language_extension_map settings.\n        Filenames with no extension will return an empty string for the extension.\n\n        Args:\n        - filenames: a list of filenames\n\n        Returns:\n        - list: A list of file extensions, including the dot \".\" prefix.\n        \"\"\"\n        extensions = []\n        for filename in filenames:\n            filename, ext = os.path.splitext(filename)\n            if ext:\n                extensions.append(ext.lower())\n            else:\n                extensions.append(\"\")\n        return extensions\n\n    @staticmethod\n    def _get_language_percentages(extensions):\n        \"\"\"\n        Return a dictionary containing the programming language name (as the key),\n        and the percentage that language is used (as the value),\n        given a list of file extensions.\n\n        Args:\n        - extensions: a list of file extensions\n\n        Returns:\n        - dict: A dictionary where each key is a language name and the corresponding value is the percentage of that language in the PR.\n        \"\"\"\n        total_files = len(extensions)\n        if total_files == 0:\n            return {}\n\n        # Identify language by file extension and count\n        lang_count = Counter(extensions)\n        # Convert counts to percentages\n        lang_percentage = {\n            lang: round(count / total_files * 100) for lang, count in lang_count.items()\n        }\n        return lang_percentage\n"}
{"type": "source_file", "path": "pr_agent/agent/pr_agent.py", "content": "import shlex\nfrom functools import partial\n\nfrom pr_agent.algo.ai_handlers.base_ai_handler import BaseAiHandler\nfrom pr_agent.algo.ai_handlers.litellm_ai_handler import LiteLLMAIHandler\nfrom pr_agent.algo.cli_args import CliArgs\nfrom pr_agent.algo.utils import update_settings_from_args\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers.utils import apply_repo_settings\nfrom pr_agent.log import get_logger\nfrom pr_agent.tools.pr_add_docs import PRAddDocs\nfrom pr_agent.tools.pr_code_suggestions import PRCodeSuggestions\nfrom pr_agent.tools.pr_config import PRConfig\nfrom pr_agent.tools.pr_description import PRDescription\nfrom pr_agent.tools.pr_generate_labels import PRGenerateLabels\nfrom pr_agent.tools.pr_help_message import PRHelpMessage\nfrom pr_agent.tools.pr_line_questions import PR_LineQuestions\nfrom pr_agent.tools.pr_questions import PRQuestions\nfrom pr_agent.tools.pr_reviewer import PRReviewer\nfrom pr_agent.tools.pr_similar_issue import PRSimilarIssue\nfrom pr_agent.tools.pr_update_changelog import PRUpdateChangelog\n\ncommand2class = {\n    \"auto_review\": PRReviewer,\n    \"answer\": PRReviewer,\n    \"review\": PRReviewer,\n    \"review_pr\": PRReviewer,\n    \"describe\": PRDescription,\n    \"describe_pr\": PRDescription,\n    \"improve\": PRCodeSuggestions,\n    \"improve_code\": PRCodeSuggestions,\n    \"ask\": PRQuestions,\n    \"ask_question\": PRQuestions,\n    \"ask_line\": PR_LineQuestions,\n    \"update_changelog\": PRUpdateChangelog,\n    \"config\": PRConfig,\n    \"settings\": PRConfig,\n    \"help\": PRHelpMessage,\n    \"similar_issue\": PRSimilarIssue,\n    \"add_docs\": PRAddDocs,\n    \"generate_labels\": PRGenerateLabels,\n}\n\ncommands = list(command2class.keys())\n\n\n\nclass PRAgent:\n    def __init__(self, ai_handler: partial[BaseAiHandler,] = LiteLLMAIHandler):\n        self.ai_handler = ai_handler  # will be initialized in run_action\n\n    async def handle_request(self, pr_url, request, notify=None) -> bool:\n        # First, apply repo specific settings if exists\n        apply_repo_settings(pr_url)\n\n        # Then, apply user specific settings if exists\n        if isinstance(request, str):\n            request = request.replace(\"'\", \"\\\\'\")\n            lexer = shlex.shlex(request, posix=True)\n            lexer.whitespace_split = True\n            action, *args = list(lexer)\n        else:\n            action, *args = request\n\n        # validate args\n        is_valid, arg = CliArgs.validate_user_args(args)\n        if not is_valid:\n            get_logger().error(\n                f\"CLI argument for param '{arg}' is forbidden. Use instead a configuration file.\"\n            )\n            return False\n\n        # Update settings from args\n        args = update_settings_from_args(args)\n\n        # Append the response language in the extra instructions\n        response_language = get_settings().config.get('response_language', 'en-us')\n        if response_language.lower() != 'en-us':\n            get_logger().info(f'User has set the response language to: {response_language}')\n            for key in get_settings():\n                setting = get_settings().get(key)\n                if str(type(setting)) == \"<class 'dynaconf.utils.boxing.DynaBox'>\":\n                    if hasattr(setting, 'extra_instructions'):\n                        current_extra_instructions = setting.extra_instructions\n                        if current_extra_instructions:\n                            setting.extra_instructions = current_extra_instructions+ f\"\\n======\\n\\nIn addition, Your response MUST be written in the language corresponding to local code: {response_language}. This is crucial.\"\n                        else:\n                            setting.extra_instructions = f\"Your response MUST be written in the language corresponding to locale code: '{response_language}'. This is crucial.\"\n\n        action = action.lstrip(\"/\").lower()\n        if action not in command2class:\n            get_logger().warning(f\"Unknown command: {action}\")\n            return False\n        with get_logger().contextualize(command=action, pr_url=pr_url):\n            get_logger().info(\"PR-Agent request handler started\", analytics=True)\n            if action == \"answer\":\n                if notify:\n                    notify()\n                await PRReviewer(pr_url, is_answer=True, args=args, ai_handler=self.ai_handler).run()\n            elif action == \"auto_review\":\n                await PRReviewer(pr_url, is_auto=True, args=args, ai_handler=self.ai_handler).run()\n            elif action in command2class:\n                if notify:\n                    notify()\n\n                await command2class[action](pr_url, ai_handler=self.ai_handler, args=args).run()\n            else:\n                return False\n            return True\n"}
{"type": "source_file", "path": "pr_agent/git_providers/gerrit_provider.py", "content": "import json\nimport os\nimport pathlib\nimport shutil\nimport subprocess\nimport uuid\nfrom collections import Counter, namedtuple\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile, mkdtemp\n\nimport requests\nimport urllib3.util\nfrom git import Repo\n\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers.git_provider import GitProvider\nfrom pr_agent.git_providers.local_git_provider import PullRequestMimic\nfrom pr_agent.log import get_logger\n\n\ndef _call(*command, **kwargs) -> (int, str, str):\n    res = subprocess.run(\n        command,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        check=True,\n        **kwargs,\n    )\n    return res.stdout.decode()\n\n\ndef clone(url, directory):\n    get_logger().info(\"Cloning %s to %s\", url, directory)\n    stdout = _call('git', 'clone', \"--depth\", \"1\", url, directory)\n    get_logger().info(stdout)\n\n\ndef fetch(url, refspec, cwd):\n    get_logger().info(\"Fetching %s %s\", url, refspec)\n    stdout = _call(\n        'git', 'fetch', '--depth', '2', url, refspec,\n        cwd=cwd\n    )\n    get_logger().info(stdout)\n\n\ndef checkout(cwd):\n    get_logger().info(\"Checking out\")\n    stdout = _call('git', 'checkout', \"FETCH_HEAD\", cwd=cwd)\n    get_logger().info(stdout)\n\n\ndef show(*args, cwd=None):\n    get_logger().info(\"Show\")\n    return _call('git', 'show', *args, cwd=cwd)\n\n\ndef diff(*args, cwd=None):\n    get_logger().info(\"Diff\")\n    patch = _call('git', 'diff', *args, cwd=cwd)\n    if not patch:\n        get_logger().warning(\"No changes found\")\n        return\n    return patch\n\n\ndef reset_local_changes(cwd):\n    get_logger().info(\"Reset local changes\")\n    _call('git', 'checkout', \"--force\", cwd=cwd)\n\n\ndef add_comment(url: urllib3.util.Url, refspec, message):\n    *_, patchset, changenum = refspec.rsplit(\"/\")\n    message = \"'\" + message.replace(\"'\", \"'\\\"'\\\"'\") + \"'\"\n    return _call(\n        \"ssh\",\n        \"-p\", str(url.port),\n        f\"{url.auth}@{url.host}\",\n        \"gerrit\", \"review\",\n        \"--message\", message,\n        # \"--code-review\", score,\n        f\"{patchset},{changenum}\",\n    )\n\n\ndef list_comments(url: urllib3.util.Url, refspec):\n    *_, patchset, _ = refspec.rsplit(\"/\")\n    stdout = _call(\n        \"ssh\",\n        \"-p\", str(url.port),\n        f\"{url.auth}@{url.host}\",\n        \"gerrit\", \"query\",\n        \"--comments\",\n        \"--current-patch-set\", patchset,\n        \"--format\", \"JSON\",\n    )\n    change_set, *_ = stdout.splitlines()\n    return json.loads(change_set)[\"currentPatchSet\"][\"comments\"]\n\n\ndef prepare_repo(url: urllib3.util.Url, project, refspec):\n    repo_url = (f\"{url.scheme}://{url.auth}@{url.host}:{url.port}/{project}\")\n\n    directory = pathlib.Path(mkdtemp())\n    clone(repo_url, directory),\n    fetch(repo_url, refspec, cwd=directory)\n    checkout(cwd=directory)\n    return directory\n\n\ndef adopt_to_gerrit_message(message):\n    lines = message.splitlines()\n    buf = []\n    for line in lines:\n        # remove markdown formatting\n        line = (line.replace(\"*\", \"\")\n                .replace(\"``\", \"`\")\n                .replace(\"<details>\", \"\")\n                .replace(\"</details>\", \"\")\n                .replace(\"<summary>\", \"\")\n                .replace(\"</summary>\", \"\"))\n\n        line = line.strip()\n        if line.startswith('#'):\n            buf.append(\"\\n\" +\n                       line.replace('#', '').removesuffix(\":\").strip() +\n                       \":\")\n            continue\n        elif line.startswith('-'):\n            buf.append(line.removeprefix('-').strip())\n            continue\n        else:\n            buf.append(line)\n    return \"\\n\".join(buf).strip()\n\n\ndef add_suggestion(src_filename, context: str, start, end: int):\n    with (\n        NamedTemporaryFile(\"w\", delete=False) as tmp,\n        open(src_filename, \"r\") as src\n    ):\n        lines = src.readlines()\n        tmp.writelines(lines[:start - 1])\n        if context:\n            tmp.write(context)\n        tmp.writelines(lines[end:])\n\n    shutil.copy(tmp.name, src_filename)\n    os.remove(tmp.name)\n\n\ndef upload_patch(patch, path):\n    patch_server_endpoint = get_settings().get(\n        'gerrit.patch_server_endpoint')\n    patch_server_token = get_settings().get(\n        'gerrit.patch_server_token')\n\n    response = requests.post(\n        patch_server_endpoint,\n        json={\n            \"content\": patch,\n            \"path\": path,\n        },\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {patch_server_token}\",\n        }\n    )\n    response.raise_for_status()\n    patch_server_endpoint = patch_server_endpoint.rstrip(\"/\")\n    return patch_server_endpoint + \"/\" + path\n\n\nclass GerritProvider(GitProvider):\n\n    def __init__(self, key: str, incremental=False):\n        self.project, self.refspec = key.split(':')\n        assert self.project, \"Project name is required\"\n        assert self.refspec, \"Refspec is required\"\n        base_url = get_settings().get('gerrit.url')\n        assert base_url, \"Gerrit URL is required\"\n        user = get_settings().get('gerrit.user')\n        assert user, \"Gerrit user is required\"\n\n        parsed = urllib3.util.parse_url(base_url)\n        self.parsed_url = urllib3.util.parse_url(\n            f\"{parsed.scheme}://{user}@{parsed.host}:{parsed.port}\"\n        )\n\n        self.repo_path = prepare_repo(\n            self.parsed_url, self.project, self.refspec\n        )\n        self.repo = Repo(self.repo_path)\n        assert self.repo\n        self.pr_url = base_url\n        self.pr = PullRequestMimic(self.get_pr_title(), self.get_diff_files())\n\n    def get_pr_title(self):\n        \"\"\"\n        Substitutes the branch-name as the PR-mimic title.\n        \"\"\"\n        return self.repo.branches[0].name\n\n    def get_issue_comments(self):\n        comments = list_comments(self.parsed_url, self.refspec)\n        Comments = namedtuple('Comments', ['reversed'])\n        Comment = namedtuple('Comment', ['body'])\n        return Comments([Comment(c['message']) for c in reversed(comments)])\n\n    def get_pr_labels(self, update=False):\n        raise NotImplementedError(\n            'Getting labels is not implemented for the gerrit provider')\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False):\n        raise NotImplementedError(\n            'Adding reactions is not implemented for the gerrit provider')\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int):\n        raise NotImplementedError(\n            'Removing reactions is not implemented for the gerrit provider')\n\n    def get_commit_messages(self):\n        return [self.repo.head.commit.message]\n\n    def get_repo_settings(self):\n        try:\n            with open(self.repo_path / \".pr_agent.toml\", 'rb') as f:\n                contents = f.read()\n            return contents\n        except OSError:\n            return b\"\"\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        diffs = self.repo.head.commit.diff(\n            self.repo.head.commit.parents[0],  # previous commit\n            create_patch=True,\n            R=True\n        )\n\n        diff_files = []\n        for diff_item in diffs:\n            if diff_item.a_blob is not None:\n                original_file_content_str = (\n                    diff_item.a_blob.data_stream.read().decode('utf-8')\n                )\n            else:\n                original_file_content_str = \"\"  # empty file\n            if diff_item.b_blob is not None:\n                new_file_content_str = diff_item.b_blob.data_stream.read(). \\\n                    decode('utf-8')\n            else:\n                new_file_content_str = \"\"  # empty file\n            edit_type = EDIT_TYPE.MODIFIED\n            if diff_item.new_file:\n                edit_type = EDIT_TYPE.ADDED\n            elif diff_item.deleted_file:\n                edit_type = EDIT_TYPE.DELETED\n            elif diff_item.renamed_file:\n                edit_type = EDIT_TYPE.RENAMED\n            diff_files.append(\n                FilePatchInfo(\n                    original_file_content_str,\n                    new_file_content_str,\n                    diff_item.diff.decode('utf-8'),\n                    diff_item.b_path,\n                    edit_type=edit_type,\n                    old_filename=None\n                    if diff_item.a_path == diff_item.b_path\n                    else diff_item.a_path\n                )\n            )\n        self.diff_files = diff_files\n        return diff_files\n\n    def get_files(self):\n        diff_index = self.repo.head.commit.diff(\n            self.repo.head.commit.parents[0],  # previous commit\n            R=True\n        )\n        # Get the list of changed files\n        diff_files = [item.a_path for item in diff_index]\n        return diff_files\n\n    def get_languages(self):\n        \"\"\"\n        Calculate percentage of languages in repository. Used for hunk\n        prioritisation.\n        \"\"\"\n        # Get all files in repository\n        filepaths = [Path(item.path) for item in\n                     self.repo.tree().traverse() if item.type == 'blob']\n        # Identify language by file extension and count\n        lang_count = Counter(\n            ext.lstrip('.') for filepath in filepaths for ext in\n            [filepath.suffix.lower()])\n        # Convert counts to percentages\n        total_files = len(filepaths)\n        lang_percentage = {lang: count / total_files * 100 for lang, count\n                           in lang_count.items()}\n        return lang_percentage\n\n    def get_pr_description_full(self):\n        return self.repo.head.commit.message\n\n    def get_user_id(self):\n        return self.repo.head.commit.author.email\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in [\n            # 'get_issue_comments',\n            'create_inline_comment',\n            'publish_inline_comments',\n            'get_labels',\n            'gfm_markdown'\n        ]:\n            return False\n        return True\n\n    def split_suggestion(self, msg) -> tuple[str, str]:\n        is_code_context = False\n        description = []\n        context = []\n        for line in msg.splitlines():\n            if line.startswith('```suggestion'):\n                is_code_context = True\n                continue\n            if line.startswith('```'):\n                is_code_context = False\n                continue\n            if is_code_context:\n                context.append(line)\n            else:\n                description.append(\n                    line.replace('*', '')\n                )\n\n        return (\n            '\\n'.join(description),\n            '\\n'.join(context) + '\\n' if context else ''\n        )\n\n    def publish_code_suggestions(self, code_suggestions: list):\n        msg = []\n        for suggestion in code_suggestions:\n            description, code = self.split_suggestion(suggestion['body'])\n            add_suggestion(\n                pathlib.Path(self.repo_path) / suggestion[\"relevant_file\"],\n                code,\n                suggestion[\"relevant_lines_start\"],\n                suggestion[\"relevant_lines_end\"],\n            )\n            patch = diff(cwd=self.repo_path)\n            patch_id = uuid.uuid4().hex[0:4]\n            path = \"/\".join([\"codium-ai\", self.refspec, patch_id])\n            full_path = upload_patch(patch, path)\n            reset_local_changes(self.repo_path)\n            msg.append(f'* {description}\\n{full_path}')\n\n        if msg:\n            add_comment(self.parsed_url, self.refspec, \"\\n\".join(msg))\n            return True\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if not is_temporary:\n            msg = adopt_to_gerrit_message(pr_comment)\n            add_comment(self.parsed_url, self.refspec, msg)\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        msg = adopt_to_gerrit_message(pr_body)\n        add_comment(self.parsed_url, self.refspec, pr_title + '\\n' + msg)\n\n    def publish_inline_comments(self, comments: list[dict]):\n        raise NotImplementedError(\n            'Publishing inline comments is not implemented for the gerrit '\n            'provider')\n\n    def publish_inline_comment(self, body: str, relevant_file: str,\n                               relevant_line_in_file: str, original_suggestion=None):\n        raise NotImplementedError(\n            'Publishing inline comments is not implemented for the gerrit '\n            'provider')\n\n\n    def publish_labels(self, labels):\n        # Not applicable to the local git provider,\n        # but required by the interface\n        pass\n\n    def remove_initial_comment(self):\n        # remove repo, cloned in previous steps\n        # shutil.rmtree(self.repo_path)\n        pass\n\n    def remove_comment(self, comment):\n        pass\n\n    def get_pr_branch(self):\n        return self.repo.head\n"}
{"type": "source_file", "path": "pr_agent/cli_pip.py", "content": "from pr_agent import cli\nfrom pr_agent.config_loader import get_settings\n\n\ndef main():\n    # Fill in the following values\n    provider = \"github\"  # GitHub provider\n    user_token = \"...\"  # GitHub user token\n    openai_key = \"...\"  # OpenAI key\n    pr_url = \"...\"  # PR URL, for example 'https://github.com/Codium-ai/pr-agent/pull/809'\n    command = \"/review\"  # Command to run (e.g. '/review', '/describe', '/ask=\"What is the purpose of this PR?\"')\n\n    # Setting the configurations\n    get_settings().set(\"CONFIG.git_provider\", provider)\n    get_settings().set(\"openai.key\", openai_key)\n    get_settings().set(\"github.user_token\", user_token)\n\n    # Run the command. Feedback will appear in GitHub PR comments\n    cli.run_command(pr_url, command)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"type": "source_file", "path": "pr_agent/git_providers/azuredevops_provider.py", "content": "import os\nfrom typing import Optional, Tuple\nfrom urllib.parse import urlparse\n\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\n\nfrom ..algo.file_filter import filter_ignored\nfrom ..algo.language_handler import is_valid_file\nfrom ..algo.utils import (PRDescriptionHeader, clip_tokens,\n                          find_line_number_of_relevant_line_in_file,\n                          load_large_diff)\nfrom ..config_loader import get_settings\nfrom ..log import get_logger\nfrom .git_provider import GitProvider\n\nAZURE_DEVOPS_AVAILABLE = True\nADO_APP_CLIENT_DEFAULT_ID = \"499b84ac-1321-427f-aa17-267ca6975798/.default\"\nMAX_PR_DESCRIPTION_AZURE_LENGTH = 4000-1\n\ntry:\n    # noinspection PyUnresolvedReferences\n    # noinspection PyUnresolvedReferences\n    from azure.devops.connection import Connection\n    # noinspection PyUnresolvedReferences\n    from azure.devops.v7_1.git.models import (Comment, CommentThread,\n                                              GitPullRequest,\n                                              GitPullRequestIterationChanges,\n                                              GitVersionDescriptor)\n    # noinspection PyUnresolvedReferences\n    from azure.identity import DefaultAzureCredential\n    from msrest.authentication import BasicAuthentication\nexcept ImportError:\n    AZURE_DEVOPS_AVAILABLE = False\n\n\nclass AzureDevopsProvider(GitProvider):\n\n    def __init__(\n            self, pr_url: Optional[str] = None, incremental: Optional[bool] = False\n    ):\n        if not AZURE_DEVOPS_AVAILABLE:\n            raise ImportError(\n                \"Azure DevOps provider is not available. Please install the required dependencies.\"\n            )\n\n        self.azure_devops_client = self._get_azure_devops_client()\n        self.diff_files = None\n        self.workspace_slug = None\n        self.repo_slug = None\n        self.repo = None\n        self.pr_num = None\n        self.pr = None\n        self.temp_comments = []\n        self.incremental = incremental\n        if pr_url:\n            self.set_pr(pr_url)\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        \"\"\"\n        Publishes code suggestions as comments on the PR.\n        \"\"\"\n        post_parameters_list = []\n        for suggestion in code_suggestions:\n            body = suggestion['body']\n            relevant_file = suggestion['relevant_file']\n            relevant_lines_start = suggestion['relevant_lines_start']\n            relevant_lines_end = suggestion['relevant_lines_end']\n\n            if not relevant_lines_start or relevant_lines_start == -1:\n                get_logger().warning(\n                    f\"Failed to publish code suggestion, relevant_lines_start is {relevant_lines_start}\")\n                continue\n\n            if relevant_lines_end < relevant_lines_start:\n                get_logger().warning(f\"Failed to publish code suggestion, \"\n                                       f\"relevant_lines_end is {relevant_lines_end} and \"\n                                       f\"relevant_lines_start is {relevant_lines_start}\")\n                continue\n\n            if relevant_lines_end > relevant_lines_start:\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_end,\n                    \"start_line\": relevant_lines_start,\n                    \"start_side\": \"RIGHT\",\n                }\n            else:  # API is different for single line comments\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_start,\n                    \"side\": \"RIGHT\",\n                }\n            post_parameters_list.append(post_parameters)\n        if not post_parameters_list:\n            return False\n\n        for post_parameters in post_parameters_list:\n            try:\n                comment = Comment(content=post_parameters[\"body\"], comment_type=1)\n                thread = CommentThread(comments=[comment],\n                                       thread_context={\n                                           \"filePath\": post_parameters[\"path\"],\n                                           \"rightFileStart\": {\n                                               \"line\": post_parameters[\"start_line\"],\n                                               \"offset\": 1,\n                                           },\n                                           \"rightFileEnd\": {\n                                               \"line\": post_parameters[\"line\"],\n                                               \"offset\": 1,\n                                           },\n                                       })\n                self.azure_devops_client.create_thread(\n                    comment_thread=thread,\n                    project=self.workspace_slug,\n                    repository_id=self.repo_slug,\n                    pull_request_id=self.pr_num\n                )\n            except Exception as e:\n                get_logger().warning(f\"Azure failed to publish code suggestion, error: {e}\")\n        return True\n\n\n\n    def get_pr_description_full(self) -> str:\n        return self.pr.description\n\n    def edit_comment(self, comment, body: str):\n        try:\n            self.azure_devops_client.update_comment(\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n                thread_id=comment[\"thread_id\"],\n                comment_id=comment[\"comment_id\"],\n                comment=Comment(content=body),\n                project=self.workspace_slug,\n            )\n        except Exception as e:\n            get_logger().exception(f\"Failed to edit comment, error: {e}\")\n\n    def remove_comment(self, comment):\n        try:\n            self.azure_devops_client.delete_comment(\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n                thread_id=comment[\"thread_id\"],\n                comment_id=comment[\"comment_id\"],\n                project=self.workspace_slug,\n            )\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove comment, error: {e}\")\n\n    def publish_labels(self, pr_types):\n        try:\n            for pr_type in pr_types:\n                self.azure_devops_client.create_pull_request_label(\n                    label={\"name\": pr_type},\n                    project=self.workspace_slug,\n                    repository_id=self.repo_slug,\n                    pull_request_id=self.pr_num,\n                )\n        except Exception as e:\n            get_logger().warning(f\"Failed to publish labels, error: {e}\")\n\n    def get_pr_labels(self, update=False):\n        try:\n            labels = self.azure_devops_client.get_pull_request_labels(\n                project=self.workspace_slug,\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n            )\n            return [label.name for label in labels]\n        except Exception as e:\n            get_logger().exception(f\"Failed to get labels, error: {e}\")\n            return []\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in [\n            \"get_issue_comments\",\n        ]:\n            return False\n        return True\n\n    def set_pr(self, pr_url: str):\n        self.pr_url = pr_url\n        self.workspace_slug, self.repo_slug, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def get_repo_settings(self):\n        try:\n            contents = self.azure_devops_client.get_item_content(\n                repository_id=self.repo_slug,\n                project=self.workspace_slug,\n                download=False,\n                include_content_metadata=False,\n                include_content=True,\n                path=\".pr_agent.toml\",\n            )\n            return list(contents)[0]\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().error(f\"Failed to get repo settings, error: {e}\")\n            return \"\"\n\n    def get_files(self):\n        files = []\n        for i in self.azure_devops_client.get_pull_request_commits(\n                project=self.workspace_slug,\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n        ):\n            changes_obj = self.azure_devops_client.get_changes(\n                project=self.workspace_slug,\n                repository_id=self.repo_slug,\n                commit_id=i.commit_id,\n            )\n\n            for c in changes_obj.changes:\n                files.append(c[\"item\"][\"path\"])\n        return list(set(files))\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        try:\n\n            if self.diff_files:\n                return self.diff_files\n\n            base_sha = self.pr.last_merge_target_commit\n            head_sha = self.pr.last_merge_source_commit\n\n            # Get PR iterations\n            iterations = self.azure_devops_client.get_pull_request_iterations(\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n                project=self.workspace_slug\n            )\n            changes = None\n            if iterations:\n                iteration_id = iterations[-1].id  # Get the last iteration (most recent changes)\n\n                # Get changes for the iteration\n                changes = self.azure_devops_client.get_pull_request_iteration_changes(\n                    repository_id=self.repo_slug,\n                    pull_request_id=self.pr_num,\n                    iteration_id=iteration_id,\n                    project=self.workspace_slug\n                )\n            diff_files = []\n            diffs = []\n            diff_types = {}\n            if changes:\n                for change in changes.change_entries:\n                    item = change.additional_properties.get('item', {})\n                    path = item.get('path', None)\n                    if path:\n                        diffs.append(path)\n                        diff_types[path] = change.additional_properties.get('changeType', 'Unknown')\n\n            # wrong implementation - gets all the files that were changed in any commit in the PR\n            # commits = self.azure_devops_client.get_pull_request_commits(\n            #     project=self.workspace_slug,\n            #     repository_id=self.repo_slug,\n            #     pull_request_id=self.pr_num,\n            # )\n            #\n            # diff_files = []\n            # diffs = []\n            # diff_types = {}\n\n            # for c in commits:\n            #     changes_obj = self.azure_devops_client.get_changes(\n            #         project=self.workspace_slug,\n            #         repository_id=self.repo_slug,\n            #         commit_id=c.commit_id,\n            #     )\n            #     for i in changes_obj.changes:\n            #         if i[\"item\"][\"gitObjectType\"] == \"tree\":\n            #             continue\n            #         diffs.append(i[\"item\"][\"path\"])\n            #         diff_types[i[\"item\"][\"path\"]] = i[\"changeType\"]\n            #\n            # diffs = list(set(diffs))\n\n            diffs_original = diffs\n            diffs = filter_ignored(diffs_original, 'azure')\n            if diffs_original != diffs:\n                try:\n                    get_logger().info(f\"Filtered out [ignore] files for pull request:\", extra=\n                    {\"files\": diffs_original,  # diffs is just a list of names\n                     \"filtered_files\": diffs})\n                except Exception:\n                    pass\n\n            invalid_files_names = []\n            for file in diffs:\n                if not is_valid_file(file):\n                    invalid_files_names.append(file)\n                    continue\n\n                version = GitVersionDescriptor(\n                    version=head_sha.commit_id, version_type=\"commit\"\n                )\n                try:\n                    new_file_content_str = self.azure_devops_client.get_item(\n                        repository_id=self.repo_slug,\n                        path=file,\n                        project=self.workspace_slug,\n                        version_descriptor=version,\n                        download=False,\n                        include_content=True,\n                    )\n\n                    new_file_content_str = new_file_content_str.content\n                except Exception as error:\n                    get_logger().error(f\"Failed to retrieve new file content of {file} at version {version}\", error=error)\n                    # get_logger().error(\n                    #     \"Failed to retrieve new file content of %s at version %s. Error: %s\",\n                    #     file,\n                    #     version,\n                    #     str(error),\n                    # )\n                    new_file_content_str = \"\"\n\n                edit_type = EDIT_TYPE.MODIFIED\n                if diff_types[file] == \"add\":\n                    edit_type = EDIT_TYPE.ADDED\n                elif diff_types[file] == \"delete\":\n                    edit_type = EDIT_TYPE.DELETED\n                elif \"rename\" in diff_types[file]: # diff_type can be `rename` | `edit, rename`\n                    edit_type = EDIT_TYPE.RENAMED\n\n                version = GitVersionDescriptor(\n                    version=base_sha.commit_id, version_type=\"commit\"\n                )\n                if edit_type == EDIT_TYPE.ADDED or edit_type == EDIT_TYPE.RENAMED:\n                    original_file_content_str = \"\"\n                else:\n                    try:\n                        original_file_content_str = self.azure_devops_client.get_item(\n                            repository_id=self.repo_slug,\n                            path=file,\n                            project=self.workspace_slug,\n                            version_descriptor=version,\n                            download=False,\n                            include_content=True,\n                        )\n                        original_file_content_str = original_file_content_str.content\n                    except Exception as error:\n                        get_logger().error(f\"Failed to retrieve original file content of {file} at version {version}\", error=error)\n                        original_file_content_str = \"\"\n\n                patch = load_large_diff(\n                    file, new_file_content_str, original_file_content_str, show_warning=False\n                ).rstrip()\n\n                # count number of lines added and removed\n                patch_lines = patch.splitlines(keepends=True)\n                num_plus_lines = len([line for line in patch_lines if line.startswith('+')])\n                num_minus_lines = len([line for line in patch_lines if line.startswith('-')])\n\n                diff_files.append(\n                    FilePatchInfo(\n                        original_file_content_str,\n                        new_file_content_str,\n                        patch=patch,\n                        filename=file,\n                        edit_type=edit_type,\n                        num_plus_lines=num_plus_lines,\n                        num_minus_lines=num_minus_lines,\n                    )\n                )\n            get_logger().info(f\"Invalid files: {invalid_files_names}\")\n\n            self.diff_files = diff_files\n            return diff_files\n        except Exception as e:\n            get_logger().exception(f\"Failed to get diff files, error: {e}\")\n            return []\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False, thread_context=None):\n        if is_temporary and not get_settings().config.publish_output_progress:\n            get_logger().debug(f\"Skipping publish_comment for temporary comment: {pr_comment}\")\n            return None\n        comment = Comment(content=pr_comment)\n        thread = CommentThread(comments=[comment], thread_context=thread_context, status=1)\n        thread_response = self.azure_devops_client.create_thread(\n            comment_thread=thread,\n            project=self.workspace_slug,\n            repository_id=self.repo_slug,\n            pull_request_id=self.pr_num,\n        )\n        response = {\"thread_id\": thread_response.id, \"comment_id\": thread_response.comments[0].id}\n        if is_temporary:\n            self.temp_comments.append(response)\n        return response\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        if len(pr_body) > MAX_PR_DESCRIPTION_AZURE_LENGTH:\n\n            usage_guide_text='<details> <summary><strong>‚ú® Describe tool usage guide:</strong></summary><hr>'\n            ind = pr_body.find(usage_guide_text)\n            if ind != -1:\n                pr_body = pr_body[:ind]\n\n            if len(pr_body) > MAX_PR_DESCRIPTION_AZURE_LENGTH:\n                changes_walkthrough_text = PRDescriptionHeader.CHANGES_WALKTHROUGH.value\n                ind = pr_body.find(changes_walkthrough_text)\n                if ind != -1:\n                    pr_body = pr_body[:ind]\n\n            if len(pr_body) > MAX_PR_DESCRIPTION_AZURE_LENGTH:\n                trunction_message = \" ... (description truncated due to length limit)\"\n                pr_body = pr_body[:MAX_PR_DESCRIPTION_AZURE_LENGTH - len(trunction_message)] + trunction_message\n                get_logger().warning(\"PR description was truncated due to length limit\")\n        try:\n            updated_pr = GitPullRequest()\n            updated_pr.title = pr_title\n            updated_pr.description = pr_body\n            self.azure_devops_client.update_pull_request(\n                project=self.workspace_slug,\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n                git_pull_request_to_update=updated_pr,\n            )\n        except Exception as e:\n            get_logger().exception(\n                f\"Could not update pull request {self.pr_num} description: {e}\"\n            )\n\n    def remove_initial_comment(self):\n        try:\n            for comment in self.temp_comments:\n                self.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove temp comments, error: {e}\")\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        self.publish_inline_comments([self.create_inline_comment(body, relevant_file, relevant_line_in_file)])\n\n\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n        position, absolute_position = find_line_number_of_relevant_line_in_file(self.get_diff_files(),\n                                                                                relevant_file.strip('`'),\n                                                                                relevant_line_in_file,\n                                                                                absolute_position)\n        if position == -1:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n            subject_type = \"FILE\"\n        else:\n            subject_type = \"LINE\"\n        path = relevant_file.strip()\n        return dict(body=body, path=path, position=position, absolute_position=absolute_position) if subject_type == \"LINE\" else {}\n\n    def publish_inline_comments(self, comments: list[dict], disable_fallback: bool = False):\n            overall_success = True\n            for comment in comments:\n                try:\n                    self.publish_comment(comment[\"body\"],\n                                        thread_context={\n                                            \"filePath\": comment[\"path\"],\n                                            \"rightFileStart\": {\n                                                \"line\": comment[\"absolute_position\"],\n                                                \"offset\": comment[\"position\"],\n                                            },\n                                            \"rightFileEnd\": {\n                                                \"line\": comment[\"absolute_position\"],\n                                                \"offset\": comment[\"position\"],\n                                            },\n                                        })\n                    if get_settings().config.verbosity_level >= 2:\n                        get_logger().info(\n                            f\"Published code suggestion on {self.pr_num} at {comment['path']}\"\n                        )\n                except Exception as e:\n                    if get_settings().config.verbosity_level >= 2:\n                        get_logger().error(f\"Failed to publish code suggestion, error: {e}\")\n                    overall_success = False\n            return overall_success\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_languages(self):\n        languages = []\n        files = self.azure_devops_client.get_items(\n            project=self.workspace_slug,\n            repository_id=self.repo_slug,\n            recursion_level=\"Full\",\n            include_content_metadata=True,\n            include_links=False,\n            download=False,\n        )\n        for f in files:\n            if f.git_object_type == \"blob\":\n                file_name, file_extension = os.path.splitext(f.path)\n                languages.append(file_extension[1:])\n\n        extension_counts = {}\n        for ext in languages:\n            if ext != \"\":\n                extension_counts[ext] = extension_counts.get(ext, 0) + 1\n\n        total_extensions = sum(extension_counts.values())\n\n        extension_percentages = {\n            ext: (count / total_extensions) * 100\n            for ext, count in extension_counts.items()\n        }\n\n        return extension_percentages\n\n    def get_pr_branch(self):\n        pr_info = self.azure_devops_client.get_pull_request_by_id(\n            project=self.workspace_slug, pull_request_id=self.pr_num\n        )\n        source_branch = pr_info.source_ref_name.split(\"/\")[-1]\n        return source_branch\n\n    def get_user_id(self):\n        return 0\n\n    def get_issue_comments(self):\n        threads = self.azure_devops_client.get_threads(repository_id=self.repo_slug, pull_request_id=self.pr_num, project=self.workspace_slug)\n        threads.reverse()\n        comment_list = []\n        for thread in threads:\n            for comment in thread.comments:\n                if comment.content and comment not in comment_list:\n                    comment.body = comment.content\n                    comment.thread_id = thread.id\n                    comment_list.append(comment)\n        return comment_list\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        return True\n\n    @staticmethod\n    def _parse_pr_url(pr_url: str) -> Tuple[str, str, int]:\n        parsed_url = urlparse(pr_url)\n\n        path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n        if \"pullrequest\" not in path_parts:\n            raise ValueError(\n                \"The provided URL does not appear to be a Azure DevOps PR URL\"\n            )\n        if len(path_parts) == 6:  # \"https://dev.azure.com/organization/project/_git/repo/pullrequest/1\"\n            workspace_slug = path_parts[1]\n            repo_slug = path_parts[3]\n            pr_number = int(path_parts[5])\n        elif len(path_parts) == 5:  # 'https://organization.visualstudio.com/project/_git/repo/pullrequest/1'\n            workspace_slug = path_parts[0]\n            repo_slug = path_parts[2]\n            pr_number = int(path_parts[4])\n        else:\n            raise ValueError(\"The provided URL does not appear to be a Azure DevOps PR URL\")\n\n        return workspace_slug, repo_slug, pr_number\n\n    @staticmethod\n    def _get_azure_devops_client():\n        org = get_settings().azure_devops.get(\"org\", None)\n        pat = get_settings().azure_devops.get(\"pat\", None)\n\n        if not org:\n            raise ValueError(\"Azure DevOps organization is required\")\n\n        if pat:\n            auth_token = pat\n        else:\n            try:\n                # try to use azure default credentials\n                # see https://learn.microsoft.com/en-us/python/api/overview/azure/identity-readme?view=azure-python\n                # for usage and env var configuration of user-assigned managed identity, local machine auth etc.\n                get_logger().info(\"No PAT found in settings, trying to use Azure Default Credentials.\")\n                credentials = DefaultAzureCredential()\n                accessToken = credentials.get_token(ADO_APP_CLIENT_DEFAULT_ID)\n                auth_token = accessToken.token\n            except Exception as e:\n                get_logger().error(f\"No PAT found in settings, and Azure Default Authentication failed, error: {e}\")\n                raise\n\n        credentials = BasicAuthentication(\"\", auth_token)\n\n        credentials = BasicAuthentication(\"\", auth_token)\n        azure_devops_connection = Connection(base_url=org, creds=credentials)\n        azure_devops_client = azure_devops_connection.clients.get_git_client()\n\n        return azure_devops_client\n\n    def _get_repo(self):\n        if self.repo is None:\n            self.repo = self.azure_devops_client.get_repository(\n                project=self.workspace_slug, repository_id=self.repo_slug\n            )\n        return self.repo\n\n    def _get_pr(self):\n        self.pr = self.azure_devops_client.get_pull_request_by_id(\n            pull_request_id=self.pr_num, project=self.workspace_slug\n        )\n        return self.pr\n\n    def get_commit_messages(self):\n        return \"\"  # not implemented yet\n\n    def get_pr_id(self):\n        try:\n            pr_id = f\"{self.workspace_slug}/{self.repo_slug}/{self.pr_num}\"\n            return pr_id\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Failed to get pr id, error: {e}\")\n            return \"\"\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        pass\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        return self.pr_url+f\"?_a=files&path={relevant_file}\"\n"}
{"type": "source_file", "path": "pr_agent/algo/pr_processing.py", "content": "from __future__ import annotations\n\nimport traceback\nfrom typing import Callable, List, Tuple\n\nfrom github import RateLimitExceededException\n\nfrom pr_agent.algo.file_filter import filter_ignored\nfrom pr_agent.algo.git_patch_processing import (\n    extend_patch, handle_patch_deletions,\n    decouple_and_convert_to_hunks_with_lines_numbers)\nfrom pr_agent.algo.language_handler import sort_files_by_main_languages\nfrom pr_agent.algo.token_handler import TokenHandler\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\nfrom pr_agent.algo.utils import ModelType, clip_tokens, get_max_tokens, get_weak_model\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers.git_provider import GitProvider\nfrom pr_agent.log import get_logger\n\nDELETED_FILES_ = \"Deleted files:\\n\"\n\nMORE_MODIFIED_FILES_ = \"Additional modified files (insufficient token budget to process):\\n\"\n\nADDED_FILES_ = \"Additional added files (insufficient token budget to process):\\n\"\n\nOUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD = 1500\nOUTPUT_BUFFER_TOKENS_HARD_THRESHOLD = 1000\nMAX_EXTRA_LINES = 10\n\n\ndef cap_and_log_extra_lines(value, direction) -> int:\n    if value > MAX_EXTRA_LINES:\n        get_logger().warning(f\"patch_extra_lines_{direction} was {value}, capping to {MAX_EXTRA_LINES}\")\n        return MAX_EXTRA_LINES\n    return value\n\n\ndef get_pr_diff(git_provider: GitProvider, token_handler: TokenHandler,\n                model: str,\n                add_line_numbers_to_hunks: bool = False,\n                disable_extra_lines: bool = False,\n                large_pr_handling=False,\n                return_remaining_files=False):\n    if disable_extra_lines:\n        PATCH_EXTRA_LINES_BEFORE = 0\n        PATCH_EXTRA_LINES_AFTER = 0\n    else:\n        PATCH_EXTRA_LINES_BEFORE = get_settings().config.patch_extra_lines_before\n        PATCH_EXTRA_LINES_AFTER = get_settings().config.patch_extra_lines_after\n        PATCH_EXTRA_LINES_BEFORE = cap_and_log_extra_lines(PATCH_EXTRA_LINES_BEFORE, \"before\")\n        PATCH_EXTRA_LINES_AFTER = cap_and_log_extra_lines(PATCH_EXTRA_LINES_AFTER, \"after\")\n\n    try:\n        diff_files = git_provider.get_diff_files()\n    except RateLimitExceededException as e:\n        get_logger().error(f\"Rate limit exceeded for git provider API. original message {e}\")\n        raise\n\n    # get pr languages\n    pr_languages = sort_files_by_main_languages(git_provider.get_languages(), diff_files)\n    if pr_languages:\n        try:\n            get_logger().info(f\"PR main language: {pr_languages[0]['language']}\")\n        except Exception as e:\n            pass\n\n    # generate a standard diff string, with patch extension\n    patches_extended, total_tokens, patches_extended_tokens = pr_generate_extended_diff(\n        pr_languages, token_handler, add_line_numbers_to_hunks,\n        patch_extra_lines_before=PATCH_EXTRA_LINES_BEFORE, patch_extra_lines_after=PATCH_EXTRA_LINES_AFTER)\n\n    # if we are under the limit, return the full diff\n    if total_tokens + OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD < get_max_tokens(model):\n        get_logger().info(f\"Tokens: {total_tokens}, total tokens under limit: {get_max_tokens(model)}, \"\n                          f\"returning full diff.\")\n        return \"\\n\".join(patches_extended)\n\n    # if we are over the limit, start pruning (If we got here, we will not extend the patches with extra lines)\n    get_logger().info(f\"Tokens: {total_tokens}, total tokens over limit: {get_max_tokens(model)}, \"\n                      f\"pruning diff.\")\n    patches_compressed_list, total_tokens_list, deleted_files_list, remaining_files_list, file_dict, files_in_patches_list = \\\n        pr_generate_compressed_diff(pr_languages, token_handler, model, add_line_numbers_to_hunks, large_pr_handling)\n\n    if large_pr_handling and len(patches_compressed_list) > 1:\n        get_logger().info(f\"Large PR handling mode, and found {len(patches_compressed_list)} patches with original diff.\")\n        return \"\" # return empty string, as we want to generate multiple patches with a different prompt\n\n    # return the first patch\n    patches_compressed = patches_compressed_list[0]\n    total_tokens_new = total_tokens_list[0]\n    files_in_patch = files_in_patches_list[0]\n\n    # Insert additional information about added, modified, and deleted files if there is enough space\n    max_tokens = get_max_tokens(model) - OUTPUT_BUFFER_TOKENS_HARD_THRESHOLD\n    curr_token = total_tokens_new  # == token_handler.count_tokens(final_diff)+token_handler.prompt_tokens\n    final_diff = \"\\n\".join(patches_compressed)\n    delta_tokens = 10\n    added_list_str = modified_list_str = deleted_list_str = \"\"\n    unprocessed_files = []\n    # generate the added, modified, and deleted files lists\n    if (max_tokens - curr_token) > delta_tokens:\n        for filename, file_values in file_dict.items():\n            if filename in files_in_patch:\n                continue\n            if file_values['edit_type'] == EDIT_TYPE.ADDED:\n                unprocessed_files.append(filename)\n                if not added_list_str:\n                    added_list_str = ADDED_FILES_ + f\"\\n{filename}\"\n                else:\n                    added_list_str = added_list_str + f\"\\n{filename}\"\n            elif file_values['edit_type'] in [EDIT_TYPE.MODIFIED, EDIT_TYPE.RENAMED]:\n                unprocessed_files.append(filename)\n                if not modified_list_str:\n                    modified_list_str = MORE_MODIFIED_FILES_ + f\"\\n{filename}\"\n                else:\n                    modified_list_str = modified_list_str + f\"\\n{filename}\"\n            elif file_values['edit_type'] == EDIT_TYPE.DELETED:\n                # unprocessed_files.append(filename) # not needed here, because the file was deleted, so no need to process it\n                if not deleted_list_str:\n                    deleted_list_str = DELETED_FILES_ + f\"\\n{filename}\"\n                else:\n                    deleted_list_str = deleted_list_str + f\"\\n{filename}\"\n\n    # prune the added, modified, and deleted files lists, and add them to the final diff\n    added_list_str = clip_tokens(added_list_str, max_tokens - curr_token)\n    if added_list_str:\n        final_diff = final_diff + \"\\n\\n\" + added_list_str\n        curr_token += token_handler.count_tokens(added_list_str) + 2\n    modified_list_str = clip_tokens(modified_list_str, max_tokens - curr_token)\n    if modified_list_str:\n        final_diff = final_diff + \"\\n\\n\" + modified_list_str\n        curr_token += token_handler.count_tokens(modified_list_str) + 2\n    deleted_list_str = clip_tokens(deleted_list_str, max_tokens - curr_token)\n    if deleted_list_str:\n        final_diff = final_diff + \"\\n\\n\" + deleted_list_str\n\n    get_logger().debug(f\"After pruning, added_list_str: {added_list_str}, modified_list_str: {modified_list_str}, \"\n                       f\"deleted_list_str: {deleted_list_str}\")\n    if not return_remaining_files:\n        return final_diff\n    else:\n        return final_diff, remaining_files_list\n\n\ndef get_pr_diff_multiple_patchs(git_provider: GitProvider, token_handler: TokenHandler, model: str,\n                add_line_numbers_to_hunks: bool = False, disable_extra_lines: bool = False):\n    try:\n        diff_files = git_provider.get_diff_files()\n    except RateLimitExceededException as e:\n        get_logger().error(f\"Rate limit exceeded for git provider API. original message {e}\")\n        raise\n\n    # get pr languages\n    pr_languages = sort_files_by_main_languages(git_provider.get_languages(), diff_files)\n    if pr_languages:\n        try:\n            get_logger().info(f\"PR main language: {pr_languages[0]['language']}\")\n        except Exception as e:\n            pass\n\n    patches_compressed_list, total_tokens_list, deleted_files_list, remaining_files_list, file_dict, files_in_patches_list = \\\n        pr_generate_compressed_diff(pr_languages, token_handler, model, add_line_numbers_to_hunks, large_pr_handling=True)\n\n    return patches_compressed_list, total_tokens_list, deleted_files_list, remaining_files_list, file_dict, files_in_patches_list\n\n\ndef pr_generate_extended_diff(pr_languages: list,\n                              token_handler: TokenHandler,\n                              add_line_numbers_to_hunks: bool,\n                              patch_extra_lines_before: int = 0,\n                              patch_extra_lines_after: int = 0) -> Tuple[list, int, list]:\n    total_tokens = token_handler.prompt_tokens  # initial tokens\n    patches_extended = []\n    patches_extended_tokens = []\n    for lang in pr_languages:\n        for file in lang['files']:\n            original_file_content_str = file.base_file\n            new_file_content_str = file.head_file\n            patch = file.patch\n            if not patch:\n                continue\n\n            # extend each patch with extra lines of context\n            extended_patch = extend_patch(original_file_content_str, patch,\n                                          patch_extra_lines_before, patch_extra_lines_after, file.filename,\n                                          new_file_str=new_file_content_str)\n            if not extended_patch:\n                get_logger().warning(f\"Failed to extend patch for file: {file.filename}\")\n                continue\n\n            if add_line_numbers_to_hunks:\n                full_extended_patch = decouple_and_convert_to_hunks_with_lines_numbers(extended_patch, file)\n            else:\n                extended_patch = extended_patch.replace('\\n@@ ', '\\n\\n@@ ') # add extra line before each hunk\n                full_extended_patch = f\"\\n\\n## File: '{file.filename.strip()}'\\n\\n{extended_patch.strip()}\\n\"\n\n            # add AI-summary metadata to the patch\n            if file.ai_file_summary and get_settings().get(\"config.enable_ai_metadata\", False):\n                full_extended_patch = add_ai_summary_top_patch(file, full_extended_patch)\n\n            patch_tokens = token_handler.count_tokens(full_extended_patch)\n            file.tokens = patch_tokens\n            total_tokens += patch_tokens\n            patches_extended_tokens.append(patch_tokens)\n            patches_extended.append(full_extended_patch)\n\n    return patches_extended, total_tokens, patches_extended_tokens\n\n\ndef pr_generate_compressed_diff(top_langs: list, token_handler: TokenHandler, model: str,\n                                convert_hunks_to_line_numbers: bool,\n                                large_pr_handling: bool) -> Tuple[list, list, list, list, dict, list]:\n    deleted_files_list = []\n\n    # sort each one of the languages in top_langs by the number of tokens in the diff\n    sorted_files = []\n    for lang in top_langs:\n        sorted_files.extend(sorted(lang['files'], key=lambda x: x.tokens, reverse=True))\n\n    # generate patches for each file, and count tokens\n    file_dict = {}\n    for file in sorted_files:\n        original_file_content_str = file.base_file\n        new_file_content_str = file.head_file\n        patch = file.patch\n        if not patch:\n            continue\n\n        # removing delete-only hunks\n        patch = handle_patch_deletions(patch, original_file_content_str,\n                                       new_file_content_str, file.filename, file.edit_type)\n        if patch is None:\n            if file.filename not in deleted_files_list:\n                deleted_files_list.append(file.filename)\n            continue\n\n        if convert_hunks_to_line_numbers:\n            patch = decouple_and_convert_to_hunks_with_lines_numbers(patch, file)\n\n        ## add AI-summary metadata to the patch (disabled, since we are in the compressed diff)\n        # if file.ai_file_summary and get_settings().config.get('config.is_auto_command', False):\n        #     patch = add_ai_summary_top_patch(file, patch)\n\n        new_patch_tokens = token_handler.count_tokens(patch)\n        file_dict[file.filename] = {'patch': patch, 'tokens': new_patch_tokens, 'edit_type': file.edit_type}\n\n    max_tokens_model = get_max_tokens(model)\n\n    # first iteration\n    files_in_patches_list = []\n    remaining_files_list =  [file.filename for file in sorted_files]\n    patches_list =[]\n    total_tokens_list = []\n    total_tokens, patches, remaining_files_list, files_in_patch_list = generate_full_patch(convert_hunks_to_line_numbers, file_dict,\n                                       max_tokens_model, remaining_files_list, token_handler)\n    patches_list.append(patches)\n    total_tokens_list.append(total_tokens)\n    files_in_patches_list.append(files_in_patch_list)\n\n    # additional iterations (if needed)\n    if large_pr_handling:\n        NUMBER_OF_ALLOWED_ITERATIONS = get_settings().pr_description.max_ai_calls - 1 # one more call is to summarize\n        for i in range(NUMBER_OF_ALLOWED_ITERATIONS-1):\n            if remaining_files_list:\n                total_tokens, patches, remaining_files_list, files_in_patch_list = generate_full_patch(convert_hunks_to_line_numbers,\n                                                                                 file_dict,\n                                                                                  max_tokens_model,\n                                                                                  remaining_files_list, token_handler)\n                if patches:\n                    patches_list.append(patches)\n                    total_tokens_list.append(total_tokens)\n                    files_in_patches_list.append(files_in_patch_list)\n            else:\n                break\n\n    return patches_list, total_tokens_list, deleted_files_list, remaining_files_list, file_dict, files_in_patches_list\n\n\ndef generate_full_patch(convert_hunks_to_line_numbers, file_dict, max_tokens_model,remaining_files_list_prev, token_handler):\n    total_tokens = token_handler.prompt_tokens # initial tokens\n    patches = []\n    remaining_files_list_new = []\n    files_in_patch_list = []\n    for filename, data in file_dict.items():\n        if filename not in remaining_files_list_prev:\n            continue\n\n        patch = data['patch']\n        new_patch_tokens = data['tokens']\n        edit_type = data['edit_type']\n\n        # Hard Stop, no more tokens\n        if total_tokens > max_tokens_model - OUTPUT_BUFFER_TOKENS_HARD_THRESHOLD:\n            get_logger().warning(f\"File was fully skipped, no more tokens: {filename}.\")\n            continue\n\n        # If the patch is too large, just show the file name\n        if total_tokens + new_patch_tokens > max_tokens_model - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD:\n            # Current logic is to skip the patch if it's too large\n            # TODO: Option for alternative logic to remove hunks from the patch to reduce the number of tokens\n            #  until we meet the requirements\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().warning(f\"Patch too large, skipping it: '{filename}'\")\n            remaining_files_list_new.append(filename)\n            continue\n\n        if patch:\n            if not convert_hunks_to_line_numbers:\n                patch_final = f\"\\n\\n## File: '{filename.strip()}'\\n\\n{patch.strip()}\\n\"\n            else:\n                patch_final = \"\\n\\n\" + patch.strip()\n            patches.append(patch_final)\n            total_tokens += token_handler.count_tokens(patch_final)\n            files_in_patch_list.append(filename)\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Tokens: {total_tokens}, last filename: {filename}\")\n    return total_tokens, patches, remaining_files_list_new, files_in_patch_list\n\n\nasync def retry_with_fallback_models(f: Callable, model_type: ModelType = ModelType.REGULAR):\n    all_models = _get_all_models(model_type)\n    all_deployments = _get_all_deployments(all_models)\n    # try each (model, deployment_id) pair until one is successful, otherwise raise exception\n    for i, (model, deployment_id) in enumerate(zip(all_models, all_deployments)):\n        try:\n            get_logger().debug(\n                f\"Generating prediction with {model}\"\n                f\"{(' from deployment ' + deployment_id) if deployment_id else ''}\"\n            )\n            get_settings().set(\"openai.deployment_id\", deployment_id)\n            return await f(model)\n        except:\n            get_logger().warning(\n                f\"Failed to generate prediction with {model}\"\n            )\n            if i == len(all_models) - 1:  # If it's the last iteration\n                raise Exception(f\"Failed to generate prediction with any model of {all_models}\")\n\n\ndef _get_all_models(model_type: ModelType = ModelType.REGULAR) -> List[str]:\n    if model_type == ModelType.WEAK:\n        model = get_weak_model()\n    else:\n        model = get_settings().config.model\n    fallback_models = get_settings().config.fallback_models\n    if not isinstance(fallback_models, list):\n        fallback_models = [m.strip() for m in fallback_models.split(\",\")]\n    all_models = [model] + fallback_models\n    return all_models\n\n\ndef _get_all_deployments(all_models: List[str]) -> List[str]:\n    deployment_id = get_settings().get(\"openai.deployment_id\", None)\n    fallback_deployments = get_settings().get(\"openai.fallback_deployments\", [])\n    if not isinstance(fallback_deployments, list) and fallback_deployments:\n        fallback_deployments = [d.strip() for d in fallback_deployments.split(\",\")]\n    if fallback_deployments:\n        all_deployments = [deployment_id] + fallback_deployments\n        if len(all_deployments) < len(all_models):\n            raise ValueError(f\"The number of deployments ({len(all_deployments)}) \"\n                             f\"is less than the number of models ({len(all_models)})\")\n    else:\n        all_deployments = [deployment_id] * len(all_models)\n    return all_deployments\n\n\ndef get_pr_multi_diffs(git_provider: GitProvider,\n                       token_handler: TokenHandler,\n                       model: str,\n                       max_calls: int = 5,\n                       add_line_numbers: bool = True) -> List[str]:\n    \"\"\"\n    Retrieves the diff files from a Git provider, sorts them by main language, and generates patches for each file.\n    The patches are split into multiple groups based on the maximum number of tokens allowed for the given model.\n\n    Args:\n        git_provider (GitProvider): An object that provides access to Git provider APIs.\n        token_handler (TokenHandler): An object that handles tokens in the context of a pull request.\n        model (str): The name of the model.\n        max_calls (int, optional): The maximum number of calls to retrieve diff files. Defaults to 5.\n\n    Returns:\n        List[str]: A list of final diff strings, split into multiple groups based on the maximum number of tokens allowed for the given model.\n\n    Raises:\n        RateLimitExceededException: If the rate limit for the Git provider API is exceeded.\n    \"\"\"\n    try:\n        diff_files = git_provider.get_diff_files()\n    except RateLimitExceededException as e:\n        get_logger().error(f\"Rate limit exceeded for git provider API. original message {e}\")\n        raise\n\n    # Sort files by main language\n    pr_languages = sort_files_by_main_languages(git_provider.get_languages(), diff_files)\n\n    # Sort files within each language group by tokens in descending order\n    sorted_files = []\n    for lang in pr_languages:\n        sorted_files.extend(sorted(lang['files'], key=lambda x: x.tokens, reverse=True))\n\n    # Get the maximum number of extra lines before and after the patch\n    PATCH_EXTRA_LINES_BEFORE = get_settings().config.patch_extra_lines_before\n    PATCH_EXTRA_LINES_AFTER = get_settings().config.patch_extra_lines_after\n    PATCH_EXTRA_LINES_BEFORE = cap_and_log_extra_lines(PATCH_EXTRA_LINES_BEFORE, \"before\")\n    PATCH_EXTRA_LINES_AFTER = cap_and_log_extra_lines(PATCH_EXTRA_LINES_AFTER, \"after\")\n\n    # try first a single run with standard diff string, with patch extension, and no deletions\n    patches_extended, total_tokens, patches_extended_tokens = pr_generate_extended_diff(\n        pr_languages, token_handler,\n        add_line_numbers_to_hunks=add_line_numbers,\n        patch_extra_lines_before=PATCH_EXTRA_LINES_BEFORE,\n        patch_extra_lines_after=PATCH_EXTRA_LINES_AFTER)\n\n    # if we are under the limit, return the full diff\n    if total_tokens + OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD < get_max_tokens(model):\n        return [\"\\n\".join(patches_extended)] if patches_extended else []\n\n    patches = []\n    final_diff_list = []\n    total_tokens = token_handler.prompt_tokens\n    call_number = 1\n    for file in sorted_files:\n        if call_number > max_calls:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Reached max calls ({max_calls})\")\n            break\n\n        original_file_content_str = file.base_file\n        new_file_content_str = file.head_file\n        patch = file.patch\n        if not patch:\n            continue\n\n        # Remove delete-only hunks\n        patch = handle_patch_deletions(patch, original_file_content_str, new_file_content_str, file.filename, file.edit_type)\n        if patch is None:\n            continue\n\n        # Add line numbers and metadata to the patch\n        if add_line_numbers:\n            patch = decouple_and_convert_to_hunks_with_lines_numbers(patch, file)\n        else:\n            patch = f\"\\n\\n## File: '{file.filename.strip()}'\\n\\n{patch.strip()}\\n\"\n\n        # add AI-summary metadata to the patch\n        if file.ai_file_summary and get_settings().get(\"config.enable_ai_metadata\", False):\n            patch = add_ai_summary_top_patch(file, patch)\n        new_patch_tokens = token_handler.count_tokens(patch)\n\n        if patch and (token_handler.prompt_tokens + new_patch_tokens) > get_max_tokens(\n                model) - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD:\n            if get_settings().config.get('large_patch_policy', 'skip') == 'skip':\n                get_logger().warning(f\"Patch too large, skipping: {file.filename}\")\n                continue\n            elif get_settings().config.get('large_patch_policy') == 'clip':\n                delta_tokens = get_max_tokens(model) - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD - token_handler.prompt_tokens\n                patch_clipped = clip_tokens(patch, delta_tokens, delete_last_line=True, num_input_tokens=new_patch_tokens)\n                new_patch_tokens = token_handler.count_tokens(patch_clipped)\n                if patch_clipped and (token_handler.prompt_tokens + new_patch_tokens) > get_max_tokens(\n                        model) - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD:\n                    get_logger().warning(f\"Patch too large, skipping: {file.filename}\")\n                    continue\n                else:\n                    get_logger().info(f\"Clipped large patch for file: {file.filename}\")\n                    patch = patch_clipped\n            else:\n                get_logger().warning(f\"Patch too large, skipping: {file.filename}\")\n                continue\n\n        if patch and (total_tokens + new_patch_tokens > get_max_tokens(model) - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD):\n            final_diff = \"\\n\".join(patches)\n            final_diff_list.append(final_diff)\n            patches = []\n            total_tokens = token_handler.prompt_tokens\n            call_number += 1\n            if call_number > max_calls: # avoid creating new patches\n                if get_settings().config.verbosity_level >= 2:\n                    get_logger().info(f\"Reached max calls ({max_calls})\")\n                break\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Call number: {call_number}\")\n\n        if patch:\n            patches.append(patch)\n            total_tokens += new_patch_tokens\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Tokens: {total_tokens}, last filename: {file.filename}\")\n\n    # Add the last chunk\n    if patches:\n        final_diff = \"\\n\".join(patches)\n        final_diff_list.append(final_diff.strip())\n\n    return final_diff_list\n\n\ndef add_ai_metadata_to_diff_files(git_provider, pr_description_files):\n    \"\"\"\n    Adds AI metadata to the diff files based on the PR description files (FilePatchInfo.ai_file_summary).\n    \"\"\"\n    try:\n        if not pr_description_files:\n            get_logger().warning(f\"PR description files are empty.\")\n            return\n        available_files = {pr_file['full_file_name'].strip(): pr_file for pr_file in pr_description_files}\n        diff_files = git_provider.get_diff_files()\n        found_any_match = False\n        for file in diff_files:\n            filename = file.filename.strip()\n            if filename in available_files:\n                file.ai_file_summary = available_files[filename]\n                found_any_match = True\n        if not found_any_match:\n            get_logger().error(f\"Failed to find any matching files between PR description and diff files.\",\n                               artifact={\"pr_description_files\": pr_description_files})\n    except Exception as e:\n        get_logger().error(f\"Failed to add AI metadata to diff files: {e}\",\n                           artifact={\"traceback\": traceback.format_exc()})\n\n\ndef add_ai_summary_top_patch(file, full_extended_patch):\n    try:\n        # below every instance of '## File: ...' in the patch, add the ai-summary metadata\n        full_extended_patch_lines = full_extended_patch.split(\"\\n\")\n        for i, line in enumerate(full_extended_patch_lines):\n            if line.startswith(\"## File:\") or line.startswith(\"## file:\"):\n                full_extended_patch_lines.insert(i + 1,\n                                                 f\"### AI-generated changes summary:\\n{file.ai_file_summary['long_summary']}\")\n                full_extended_patch = \"\\n\".join(full_extended_patch_lines)\n                return full_extended_patch\n\n        # if no '## File: ...' was found\n        return full_extended_patch\n    except Exception as e:\n        get_logger().error(f\"Failed to add AI summary to the top of the patch: {e}\",\n                           artifact={\"traceback\": traceback.format_exc()})\n        return full_extended_patch\n"}
{"type": "source_file", "path": "pr_agent/algo/file_filter.py", "content": "import fnmatch\nimport re\n\nfrom pr_agent.config_loader import get_settings\n\n\ndef filter_ignored(files, platform = 'github'):\n    \"\"\"\n    Filter out files that match the ignore patterns.\n    \"\"\"\n\n    try:\n        # load regex patterns, and translate glob patterns to regex\n        patterns = get_settings().ignore.regex\n        if isinstance(patterns, str):\n            patterns = [patterns]\n        glob_setting = get_settings().ignore.glob\n        if isinstance(glob_setting, str):  # --ignore.glob=[.*utils.py], --ignore.glob=.*utils.py\n            glob_setting = glob_setting.strip('[]').split(\",\")\n        patterns += [fnmatch.translate(glob) for glob in glob_setting]\n\n        # compile all valid patterns\n        compiled_patterns = []\n        for r in patterns:\n            try:\n                compiled_patterns.append(re.compile(r))\n            except re.error:\n                pass\n\n        # keep filenames that _don't_ match the ignore regex\n        if files and isinstance(files, list):\n            for r in compiled_patterns:\n                if platform == 'github':\n                    files = [f for f in files if (f.filename and not r.match(f.filename))]\n                elif platform == 'bitbucket':\n                    # files = [f for f in files if (f.new.path and not r.match(f.new.path))]\n                    files_o = []\n                    for f in files:\n                        if hasattr(f, 'new'):\n                            if f.new and f.new.path and not r.match(f.new.path):\n                                files_o.append(f)\n                                continue\n                        if hasattr(f, 'old'):\n                            if f.old and f.old.path and not r.match(f.old.path):\n                                files_o.append(f)\n                                continue\n                    files = files_o\n                elif platform == 'gitlab':\n                    # files = [f for f in files if (f['new_path'] and not r.match(f['new_path']))]\n                    files_o = []\n                    for f in files:\n                        if 'new_path' in f and f['new_path'] and not r.match(f['new_path']):\n                            files_o.append(f)\n                            continue\n                        if 'old_path' in f and f['old_path'] and not r.match(f['old_path']):\n                            files_o.append(f)\n                            continue\n                    files = files_o\n                elif platform == 'azure':\n                    files = [f for f in files if not r.match(f)]\n\n    except Exception as e:\n        print(f\"Could not filter file list: {e}\")\n\n    return files\n"}
{"type": "source_file", "path": "pr_agent/git_providers/gitlab_provider.py", "content": "import difflib\nimport hashlib\nimport re\nfrom typing import Optional, Tuple\nfrom urllib.parse import urlparse\n\nimport gitlab\nimport requests\nfrom gitlab import GitlabGetError\n\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\n\nfrom ..algo.file_filter import filter_ignored\nfrom ..algo.language_handler import is_valid_file\nfrom ..algo.utils import (clip_tokens,\n                          find_line_number_of_relevant_line_in_file,\n                          load_large_diff)\nfrom ..config_loader import get_settings\nfrom ..log import get_logger\nfrom .git_provider import MAX_FILES_ALLOWED_FULL, GitProvider\n\n\nclass DiffNotFoundError(Exception):\n    \"\"\"Raised when the diff for a merge request cannot be found.\"\"\"\n    pass\n\nclass GitLabProvider(GitProvider):\n\n    def __init__(self, merge_request_url: Optional[str] = None, incremental: Optional[bool] = False):\n        gitlab_url = get_settings().get(\"GITLAB.URL\", None)\n        if not gitlab_url:\n            raise ValueError(\"GitLab URL is not set in the config file\")\n        self.gitlab_url = gitlab_url\n        gitlab_access_token = get_settings().get(\"GITLAB.PERSONAL_ACCESS_TOKEN\", None)\n        if not gitlab_access_token:\n            raise ValueError(\"GitLab personal access token is not set in the config file\")\n        self.gl = gitlab.Gitlab(\n            url=gitlab_url,\n            oauth_token=gitlab_access_token\n        )\n        self.max_comment_chars = 65000\n        self.id_project = None\n        self.id_mr = None\n        self.mr = None\n        self.diff_files = None\n        self.git_files = None\n        self.temp_comments = []\n        self.pr_url = merge_request_url\n        self._set_merge_request(merge_request_url)\n        self.RE_HUNK_HEADER = re.compile(\n            r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n        self.incremental = incremental\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in ['get_issue_comments', 'create_inline_comment', 'publish_inline_comments',\n            'publish_file_comments']: # gfm_markdown is supported in gitlab !\n            return False\n        return True\n\n    @property\n    def pr(self):\n        '''The GitLab terminology is merge request (MR) instead of pull request (PR)'''\n        return self.mr\n\n    def _set_merge_request(self, merge_request_url: str):\n        self.id_project, self.id_mr = self._parse_merge_request_url(merge_request_url)\n        self.mr = self._get_merge_request()\n        try:\n            self.last_diff = self.mr.diffs.list(get_all=True)[-1]\n        except IndexError as e:\n            get_logger().error(f\"Could not get diff for merge request {self.id_mr}\")\n            raise DiffNotFoundError(f\"Could not get diff for merge request {self.id_mr}\") from e\n\n\n    def get_pr_file_content(self, file_path: str, branch: str) -> str:\n        try:\n            return self.gl.projects.get(self.id_project).files.get(file_path, branch).decode()\n        except GitlabGetError:\n            # In case of file creation the method returns GitlabGetError (404 file not found).\n            # In this case we return an empty string for the diff.\n            return ''\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        \"\"\"\n        Retrieves the list of files that have been modified, added, deleted, or renamed in a pull request in GitLab,\n        along with their content and patch information.\n\n        Returns:\n            diff_files (List[FilePatchInfo]): List of FilePatchInfo objects representing the modified, added, deleted,\n            or renamed files in the merge request.\n        \"\"\"\n\n        if self.diff_files:\n            return self.diff_files\n\n        # filter files using [ignore] patterns\n        diffs_original = self.mr.changes()['changes']\n        diffs = filter_ignored(diffs_original, 'gitlab')\n        if diffs != diffs_original:\n            try:\n                names_original = [diff['new_path'] for diff in diffs_original]\n                names_filtered = [diff['new_path'] for diff in diffs]\n                get_logger().info(f\"Filtered out [ignore] files for merge request {self.id_mr}\", extra={\n                    'original_files': names_original,\n                    'filtered_files': names_filtered\n                })\n            except Exception as e:\n                pass\n\n        diff_files = []\n        invalid_files_names = []\n        counter_valid = 0\n        for diff in diffs:\n            if not is_valid_file(diff['new_path']):\n                invalid_files_names.append(diff['new_path'])\n                continue\n\n            # allow only a limited number of files to be fully loaded. We can manage the rest with diffs only\n            counter_valid += 1\n            if counter_valid < MAX_FILES_ALLOWED_FULL or not diff['diff']:\n                original_file_content_str = self.get_pr_file_content(diff['old_path'], self.mr.diff_refs['base_sha'])\n                new_file_content_str = self.get_pr_file_content(diff['new_path'], self.mr.diff_refs['head_sha'])\n            else:\n                if counter_valid == MAX_FILES_ALLOWED_FULL:\n                    get_logger().info(f\"Too many files in PR, will avoid loading full content for rest of files\")\n                original_file_content_str = ''\n                new_file_content_str = ''\n\n            try:\n                if isinstance(original_file_content_str, bytes):\n                    original_file_content_str = bytes.decode(original_file_content_str, 'utf-8')\n                if isinstance(new_file_content_str, bytes):\n                    new_file_content_str = bytes.decode(new_file_content_str, 'utf-8')\n            except UnicodeDecodeError:\n                get_logger().warning(\n                    f\"Cannot decode file {diff['old_path']} or {diff['new_path']} in merge request {self.id_mr}\")\n\n            edit_type = EDIT_TYPE.MODIFIED\n            if diff['new_file']:\n                edit_type = EDIT_TYPE.ADDED\n            elif diff['deleted_file']:\n                edit_type = EDIT_TYPE.DELETED\n            elif diff['renamed_file']:\n                edit_type = EDIT_TYPE.RENAMED\n\n            filename = diff['new_path']\n            patch = diff['diff']\n            if not patch:\n                patch = load_large_diff(filename, new_file_content_str, original_file_content_str)\n\n\n            # count number of lines added and removed\n            patch_lines = patch.splitlines(keepends=True)\n            num_plus_lines = len([line for line in patch_lines if line.startswith('+')])\n            num_minus_lines = len([line for line in patch_lines if line.startswith('-')])\n            diff_files.append(\n                FilePatchInfo(original_file_content_str, new_file_content_str,\n                              patch=patch,\n                              filename=filename,\n                              edit_type=edit_type,\n                              old_filename=None if diff['old_path'] == diff['new_path'] else diff['old_path'],\n                              num_plus_lines=num_plus_lines,\n                              num_minus_lines=num_minus_lines, ))\n        if invalid_files_names:\n            get_logger().info(f\"Filtered out files with invalid extensions: {invalid_files_names}\")\n\n        self.diff_files = diff_files\n        return diff_files\n\n    def get_files(self) -> list:\n        if not self.git_files:\n            self.git_files = [change['new_path'] for change in self.mr.changes()['changes']]\n        return self.git_files\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        try:\n            self.mr.title = pr_title\n            self.mr.description = pr_body\n            self.mr.save()\n        except Exception as e:\n            get_logger().exception(f\"Could not update merge request {self.id_mr} description: {e}\")\n\n    def get_latest_commit_url(self):\n        try:\n            return self.mr.commits().next().web_url\n        except StopIteration: # no commits\n            return \"\"\n        except Exception as e:\n            get_logger().exception(f\"Could not get latest commit URL: {e}\")\n            return \"\"\n\n    def get_comment_url(self, comment):\n        return f\"{self.mr.web_url}#note_{comment.id}\"\n\n    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        self.publish_persistent_comment_full(pr_comment, initial_header, update_header, name, final_update_message)\n\n    def publish_comment(self, mr_comment: str, is_temporary: bool = False):\n        if is_temporary and not get_settings().config.publish_output_progress:\n            get_logger().debug(f\"Skipping publish_comment for temporary comment: {mr_comment}\")\n            return None\n        mr_comment = self.limit_output_characters(mr_comment, self.max_comment_chars)\n        comment = self.mr.notes.create({'body': mr_comment})\n        if is_temporary:\n            self.temp_comments.append(comment)\n        return comment\n\n    def edit_comment(self, comment, body: str):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        self.mr.notes.update(comment.id,{'body': body} )\n\n    def edit_comment_from_comment_id(self, comment_id: int, body: str):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        comment = self.mr.notes.get(comment_id)\n        comment.body = body\n        comment.save()\n\n    def reply_to_comment_from_comment_id(self, comment_id: int, body: str):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        discussion = self.mr.discussions.get(comment_id)\n        discussion.notes.create({'body': body})\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        edit_type, found, source_line_no, target_file, target_line_no = self.search_line(relevant_file,\n                                                                                         relevant_line_in_file)\n        self.send_inline_comment(body, edit_type, found, relevant_file, relevant_line_in_file, source_line_no,\n                                 target_file, target_line_no, original_suggestion)\n\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, absolute_position: int = None):\n        raise NotImplementedError(\"Gitlab provider does not support creating inline comments yet\")\n\n    def create_inline_comments(self, comments: list[dict]):\n        raise NotImplementedError(\"Gitlab provider does not support publishing inline comments yet\")\n\n    def get_comment_body_from_comment_id(self, comment_id: int):\n        comment = self.mr.notes.get(comment_id).body\n        return comment\n\n    def send_inline_comment(self, body: str, edit_type: str, found: bool, relevant_file: str,\n                            relevant_line_in_file: str,\n                            source_line_no: int, target_file: str, target_line_no: int,\n                            original_suggestion=None) -> None:\n        if not found:\n            get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n        else:\n            # in order to have exact sha's we have to find correct diff for this change\n            diff = self.get_relevant_diff(relevant_file, relevant_line_in_file)\n            if diff is None:\n                get_logger().error(f\"Could not get diff for merge request {self.id_mr}\")\n                raise DiffNotFoundError(f\"Could not get diff for merge request {self.id_mr}\")\n            pos_obj = {'position_type': 'text',\n                       'new_path': target_file.filename,\n                       'old_path': target_file.old_filename if target_file.old_filename else target_file.filename,\n                       'base_sha': diff.base_commit_sha, 'start_sha': diff.start_commit_sha, 'head_sha': diff.head_commit_sha}\n            if edit_type == 'deletion':\n                pos_obj['old_line'] = source_line_no - 1\n            elif edit_type == 'addition':\n                pos_obj['new_line'] = target_line_no - 1\n            else:\n                pos_obj['new_line'] = target_line_no - 1\n                pos_obj['old_line'] = source_line_no - 1\n            get_logger().debug(f\"Creating comment in MR {self.id_mr} with body {body} and position {pos_obj}\")\n            try:\n                self.mr.discussions.create({'body': body, 'position': pos_obj})\n            except Exception as e:\n                try:\n                    # fallback - create a general note on the file in the MR\n                    if 'suggestion_orig_location' in original_suggestion:\n                        line_start = original_suggestion['suggestion_orig_location']['start_line']\n                        line_end = original_suggestion['suggestion_orig_location']['end_line']\n                        old_code_snippet = original_suggestion['prev_code_snippet']\n                        new_code_snippet = original_suggestion['new_code_snippet']\n                        content = original_suggestion['suggestion_summary']\n                        label = original_suggestion['category']\n                        if 'score' in original_suggestion:\n                            score = original_suggestion['score']\n                        else:\n                            score = 7\n                    else:\n                        line_start = original_suggestion['relevant_lines_start']\n                        line_end = original_suggestion['relevant_lines_end']\n                        old_code_snippet = original_suggestion['existing_code']\n                        new_code_snippet = original_suggestion['improved_code']\n                        content = original_suggestion['suggestion_content']\n                        label = original_suggestion['label']\n                        score = original_suggestion.get('score', 7)\n\n                    if hasattr(self, 'main_language'):\n                        language = self.main_language\n                    else:\n                        language = ''\n                    link = self.get_line_link(relevant_file, line_start, line_end)\n                    body_fallback =f\"**Suggestion:** {content} [{label}, importance: {score}]\\n\\n\"\n                    body_fallback +=f\"\\n\\n<details><summary>[{target_file.filename} [{line_start}-{line_end}]]({link}):</summary>\\n\\n\"\n                    body_fallback += f\"\\n\\n___\\n\\n`(Cannot implement directly - GitLab API allows committable suggestions strictly on MR diff lines)`\"\n                    body_fallback+=\"</details>\\n\\n\"\n                    diff_patch = difflib.unified_diff(old_code_snippet.split('\\n'),\n                                                new_code_snippet.split('\\n'), n=999)\n                    patch_orig = \"\\n\".join(diff_patch)\n                    patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n                    diff_code = f\"\\n\\n```diff\\n{patch.rstrip()}\\n```\"\n                    body_fallback += diff_code\n\n                    # Create a general note on the file in the MR\n                    self.mr.notes.create({\n                        'body': body_fallback,\n                        'position': {\n                            'base_sha': diff.base_commit_sha,\n                            'start_sha': diff.start_commit_sha,\n                            'head_sha': diff.head_commit_sha,\n                            'position_type': 'text',\n                            'file_path': f'{target_file.filename}',\n                        }\n                    })\n                    get_logger().debug(f\"Created fallback comment in MR {self.id_mr} with position {pos_obj}\")\n\n                    # get_logger().debug(\n                    #     f\"Failed to create comment in MR {self.id_mr} with position {pos_obj} (probably not a '+' line)\")\n                except Exception as e:\n                    get_logger().exception(f\"Failed to create comment in MR {self.id_mr}\")\n\n    def get_relevant_diff(self, relevant_file: str, relevant_line_in_file: str) -> Optional[dict]:\n        changes = self.mr.changes()  # Retrieve the changes for the merge request once\n        if not changes:\n            get_logger().error('No changes found for the merge request.')\n            return None\n        all_diffs = self.mr.diffs.list(get_all=True)\n        if not all_diffs:\n            get_logger().error('No diffs found for the merge request.')\n            return None\n        for diff in all_diffs:\n            for change in changes['changes']:\n                if change['new_path'] == relevant_file and relevant_line_in_file in change['diff']:\n                    return diff\n            get_logger().debug(\n                f'No relevant diff found for {relevant_file} {relevant_line_in_file}. Falling back to last diff.')\n        return self.last_diff  # fallback to last_diff if no relevant diff is found\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        for suggestion in code_suggestions:\n            try:\n                if suggestion and 'original_suggestion' in suggestion:\n                    original_suggestion = suggestion['original_suggestion']\n                else:\n                    original_suggestion = suggestion\n                body = suggestion['body']\n                relevant_file = suggestion['relevant_file']\n                relevant_lines_start = suggestion['relevant_lines_start']\n                relevant_lines_end = suggestion['relevant_lines_end']\n\n                diff_files = self.get_diff_files()\n                target_file = None\n                for file in diff_files:\n                    if file.filename == relevant_file:\n                        if file.filename == relevant_file:\n                            target_file = file\n                            break\n                range = relevant_lines_end - relevant_lines_start # no need to add 1\n                body = body.replace('```suggestion', f'```suggestion:-0+{range}')\n                lines = target_file.head_file.splitlines()\n                relevant_line_in_file = lines[relevant_lines_start - 1]\n\n                # edit_type, found, source_line_no, target_file, target_line_no = self.find_in_file(target_file,\n                #                                                                            relevant_line_in_file)\n                # for code suggestions, we want to edit the new code\n                source_line_no = -1\n                target_line_no = relevant_lines_start + 1\n                found = True\n                edit_type = 'addition'\n\n                self.send_inline_comment(body, edit_type, found, relevant_file, relevant_line_in_file, source_line_no,\n                                         target_file, target_line_no, original_suggestion)\n            except Exception as e:\n                get_logger().exception(f\"Could not publish code suggestion:\\nsuggestion: {suggestion}\\nerror: {e}\")\n\n        # note that we publish suggestions one-by-one. so, if one fails, the rest will still be published\n        return True\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        pass\n\n    def search_line(self, relevant_file, relevant_line_in_file):\n        target_file = None\n\n        edit_type = self.get_edit_type(relevant_line_in_file)\n        for file in self.get_diff_files():\n            if file.filename == relevant_file:\n                edit_type, found, source_line_no, target_file, target_line_no = self.find_in_file(file,\n                                                                                                  relevant_line_in_file)\n        return edit_type, found, source_line_no, target_file, target_line_no\n\n    def find_in_file(self, file, relevant_line_in_file):\n        edit_type = 'context'\n        source_line_no = 0\n        target_line_no = 0\n        found = False\n        target_file = file\n        patch = file.patch\n        patch_lines = patch.splitlines()\n        for line in patch_lines:\n            if line.startswith('@@'):\n                match = self.RE_HUNK_HEADER.match(line)\n                if not match:\n                    continue\n                start_old, size_old, start_new, size_new, _ = match.groups()\n                source_line_no = int(start_old)\n                target_line_no = int(start_new)\n                continue\n            if line.startswith('-'):\n                source_line_no += 1\n            elif line.startswith('+'):\n                target_line_no += 1\n            elif line.startswith(' '):\n                source_line_no += 1\n                target_line_no += 1\n            if relevant_line_in_file in line:\n                found = True\n                edit_type = self.get_edit_type(line)\n                break\n            elif relevant_line_in_file[0] == '+' and relevant_line_in_file[1:].lstrip() in line:\n                # The model often adds a '+' to the beginning of the relevant_line_in_file even if originally\n                # it's a context line\n                found = True\n                edit_type = self.get_edit_type(line)\n                break\n        return edit_type, found, source_line_no, target_file, target_line_no\n\n    def get_edit_type(self, relevant_line_in_file):\n        edit_type = 'context'\n        if relevant_line_in_file[0] == '-':\n            edit_type = 'deletion'\n        elif relevant_line_in_file[0] == '+':\n            edit_type = 'addition'\n        return edit_type\n\n    def remove_initial_comment(self):\n        try:\n            for comment in self.temp_comments:\n                self.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove temp comments, error: {e}\")\n\n    def remove_comment(self, comment):\n        try:\n            comment.delete()\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove comment, error: {e}\")\n\n    def get_title(self):\n        return self.mr.title\n\n    def get_languages(self):\n        languages = self.gl.projects.get(self.id_project).languages()\n        return languages\n\n    def get_pr_branch(self):\n        return self.mr.source_branch\n\n    def get_pr_owner_id(self) -> str | None:\n        if not self.gitlab_url or 'gitlab.com' in self.gitlab_url:\n            if not self.id_project:\n                return None\n            return self.id_project.split('/')[0]\n        # extract host name\n        host = urlparse(self.gitlab_url).hostname\n        return host\n\n    def get_pr_description_full(self):\n        return self.mr.description\n\n    def get_issue_comments(self):\n        return self.mr.notes.list(get_all=True)[::-1]\n\n    def get_repo_settings(self):\n        try:\n            contents = self.gl.projects.get(self.id_project).files.get(file_path='.pr_agent.toml', ref=self.mr.target_branch).decode()\n            return contents\n        except Exception:\n            return \"\"\n\n    def get_workspace_name(self):\n        return self.id_project.split('/')[0]\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        return True\n\n    def _parse_merge_request_url(self, merge_request_url: str) -> Tuple[str, int]:\n        parsed_url = urlparse(merge_request_url)\n\n        path_parts = parsed_url.path.strip('/').split('/')\n        if 'merge_requests' not in path_parts:\n            raise ValueError(\"The provided URL does not appear to be a GitLab merge request URL\")\n\n        mr_index = path_parts.index('merge_requests')\n        # Ensure there is an ID after 'merge_requests'\n        if len(path_parts) <= mr_index + 1:\n            raise ValueError(\"The provided URL does not contain a merge request ID\")\n\n        try:\n            mr_id = int(path_parts[mr_index + 1])\n        except ValueError as e:\n            raise ValueError(\"Unable to convert merge request ID to integer\") from e\n\n        # Handle special delimiter (-)\n        project_path = \"/\".join(path_parts[:mr_index])\n        if project_path.endswith('/-'):\n            project_path = project_path[:-2]\n\n        # Return the path before 'merge_requests' and the ID\n        return project_path, mr_id\n\n    def _get_merge_request(self):\n        mr = self.gl.projects.get(self.id_project).mergerequests.get(self.id_mr)\n        return mr\n\n    def get_user_id(self):\n        return None\n\n    def publish_labels(self, pr_types):\n        try:\n            self.mr.labels = list(set(pr_types))\n            self.mr.save()\n        except Exception as e:\n            get_logger().warning(f\"Failed to publish labels, error: {e}\")\n\n    def publish_inline_comments(self, comments: list[dict]):\n        pass\n\n    def get_pr_labels(self, update=False):\n        return self.mr.labels\n\n    def get_repo_labels(self):\n        return self.gl.projects.get(self.id_project).labels.list()\n\n    def get_commit_messages(self):\n        \"\"\"\n        Retrieves the commit messages of a pull request.\n\n        Returns:\n            str: A string containing the commit messages of the pull request.\n        \"\"\"\n        max_tokens = get_settings().get(\"CONFIG.MAX_COMMITS_TOKENS\", None)\n        try:\n            commit_messages_list = [commit['message'] for commit in self.mr.commits()._list]\n            commit_messages_str = \"\\n\".join([f\"{i + 1}. {message}\" for i, message in enumerate(commit_messages_list)])\n        except Exception:\n            commit_messages_str = \"\"\n        if max_tokens:\n            commit_messages_str = clip_tokens(commit_messages_str, max_tokens)\n        return commit_messages_str\n\n    def get_pr_id(self):\n        try:\n            pr_id = self.mr.web_url\n            return pr_id\n        except:\n            return \"\"\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        if relevant_line_start == -1:\n            link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads\"\n        elif relevant_line_end:\n            link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads#L{relevant_line_start}-{relevant_line_end}\"\n        else:\n            link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads#L{relevant_line_start}\"\n        return link\n\n\n    def generate_link_to_relevant_line_number(self, suggestion) -> str:\n        try:\n            relevant_file = suggestion['relevant_file'].strip('`').strip(\"'\").rstrip()\n            relevant_line_str = suggestion['relevant_line'].rstrip()\n            if not relevant_line_str:\n                return \"\"\n\n            position, absolute_position = find_line_number_of_relevant_line_in_file \\\n                (self.diff_files, relevant_file, relevant_line_str)\n\n            if absolute_position != -1:\n                # link to right file only\n                link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads#L{absolute_position}\"\n\n                # # link to diff\n                # sha_file = hashlib.sha1(relevant_file.encode('utf-8')).hexdigest()\n                # link = f\"{self.pr.web_url}/diffs#{sha_file}_{absolute_position}_{absolute_position}\"\n                return link\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Failed adding line link, error: {e}\")\n\n        return \"\"\n"}
{"type": "source_file", "path": "pr_agent/algo/cli_args.py", "content": "from base64 import b64decode, encode, b64encode\nimport hashlib\n\nclass CliArgs:\n    @staticmethod\n    def validate_user_args(args: list) -> (bool, str):\n        try:\n            if not args:\n                return True, \"\"\n\n            # decode forbidden args\n            # b64encode('word'.encode()).decode()\n            _encoded_args = 'c2hhcmVkX3NlY3JldA==:dXNlcg==:c3lzdGVt:ZW5hYmxlX2NvbW1lbnRfYXBwcm92YWw=:ZW5hYmxlX21hbnVhbF9hcHByb3ZhbA==:ZW5hYmxlX2F1dG9fYXBwcm92YWw=:YXBwcm92ZV9wcl9vbl9zZWxmX3Jldmlldw==:YmFzZV91cmw=:dXJs:YXBwX25hbWU=:c2VjcmV0X3Byb3ZpZGVy:Z2l0X3Byb3ZpZGVy:c2tpcF9rZXlz:b3BlbmFpLmtleQ==:QU5BTFlUSUNTX0ZPTERFUg==:dXJp:YXBwX2lk:d2ViaG9va19zZWNyZXQ=:YmVhcmVyX3Rva2Vu:UEVSU09OQUxfQUNDRVNTX1RPS0VO:b3ZlcnJpZGVfZGVwbG95bWVudF90eXBl:cHJpdmF0ZV9rZXk=:bG9jYWxfY2FjaGVfcGF0aA==:ZW5hYmxlX2xvY2FsX2NhY2hl:amlyYV9iYXNlX3VybA==:YXBpX2Jhc2U=:YXBpX3R5cGU=:YXBpX3ZlcnNpb24=:c2tpcF9rZXlz'\n\n            forbidden_cli_args = []\n            for e in _encoded_args.split(':'):\n                forbidden_cli_args.append(b64decode(e).decode())\n\n            # lowercase all forbidden args\n            for i, _ in enumerate(forbidden_cli_args):\n                forbidden_cli_args[i] = forbidden_cli_args[i].lower()\n                if '.' not in forbidden_cli_args[i]:\n                    forbidden_cli_args[i] = '.' + forbidden_cli_args[i]\n\n            for arg in args:\n                if arg.startswith('--'):\n                    arg_word = arg.lower()\n                    arg_word = arg_word.replace('__', '.')  # replace double underscore with dot, e.g. --openai__key -> --openai.key\n                    for forbidden_arg_word in forbidden_cli_args:\n                        if forbidden_arg_word in arg_word:\n                            return False, forbidden_arg_word\n            return True, \"\"\n        except Exception as e:\n            return False, str(e)\n\n\n"}
{"type": "source_file", "path": "pr_agent/config_loader.py", "content": "from os.path import abspath, dirname, join\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom dynaconf import Dynaconf\nfrom starlette_context import context\n\nPR_AGENT_TOML_KEY = 'pr-agent'\n\ncurrent_dir = dirname(abspath(__file__))\nglobal_settings = Dynaconf(\n    envvar_prefix=False,\n    merge_enabled=True,\n    settings_files=[join(current_dir, f) for f in [\n        \"settings/configuration.toml\",\n        \"settings/ignore.toml\",\n        \"settings/language_extensions.toml\",\n        \"settings/pr_reviewer_prompts.toml\",\n        \"settings/pr_questions_prompts.toml\",\n        \"settings/pr_line_questions_prompts.toml\",\n        \"settings/pr_description_prompts.toml\",\n        \"settings/code_suggestions/pr_code_suggestions_prompts.toml\",\n        \"settings/code_suggestions/pr_code_suggestions_prompts_not_decoupled.toml\",\n        \"settings/code_suggestions/pr_code_suggestions_reflect_prompts.toml\",\n        \"settings/pr_information_from_user_prompts.toml\",\n        \"settings/pr_update_changelog_prompts.toml\",\n        \"settings/pr_custom_labels.toml\",\n        \"settings/pr_add_docs.toml\",\n        \"settings/custom_labels.toml\",\n        \"settings/pr_help_prompts.toml\",\n        \"settings/.secrets.toml\",\n        \"settings_prod/.secrets.toml\",\n    ]]\n)\n\n\ndef get_settings(use_context=False):\n    \"\"\"\n    Retrieves the current settings.\n\n    This function attempts to fetch the settings from the starlette_context's context object. If it fails,\n    it defaults to the global settings defined outside of this function.\n\n    Returns:\n        Dynaconf: The current settings object, either from the context or the global default.\n    \"\"\"\n    try:\n        return context[\"settings\"]\n    except Exception:\n        return global_settings\n\n\n# Add local configuration from pyproject.toml of the project being reviewed\ndef _find_repository_root() -> Optional[Path]:\n    \"\"\"\n    Identify project root directory by recursively searching for the .git directory in the parent directories.\n    \"\"\"\n    cwd = Path.cwd().resolve()\n    no_way_up = False\n    while not no_way_up:\n        no_way_up = cwd == cwd.parent\n        if (cwd / \".git\").is_dir():\n            return cwd\n        cwd = cwd.parent\n    return None\n\n\ndef _find_pyproject() -> Optional[Path]:\n    \"\"\"\n    Search for file pyproject.toml in the repository root.\n    \"\"\"\n    repo_root = _find_repository_root()\n    if repo_root:\n        pyproject = repo_root / \"pyproject.toml\"\n        return pyproject if pyproject.is_file() else None\n    return None\n\n\npyproject_path = _find_pyproject()\nif pyproject_path is not None:\n    get_settings().load_file(pyproject_path, env=f'tool.{PR_AGENT_TOML_KEY}')\n"}
{"type": "source_file", "path": "pr_agent/git_providers/git_provider.py", "content": "from abc import ABC, abstractmethod\n# enum EDIT_TYPE (ADDED, DELETED, MODIFIED, RENAMED)\nfrom typing import Optional\n\nfrom pr_agent.algo.types import FilePatchInfo\nfrom pr_agent.algo.utils import Range, process_description\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.log import get_logger\n\nMAX_FILES_ALLOWED_FULL = 50\n\nclass GitProvider(ABC):\n    @abstractmethod\n    def is_supported(self, capability: str) -> bool:\n        pass\n\n    @abstractmethod\n    def get_files(self) -> list:\n        pass\n\n    @abstractmethod\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        pass\n\n    def get_incremental_commits(self, is_incremental):\n        pass\n\n    @abstractmethod\n    def publish_description(self, pr_title: str, pr_body: str):\n        pass\n\n    @abstractmethod\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        pass\n\n    @abstractmethod\n    def get_languages(self):\n        pass\n\n    @abstractmethod\n    def get_pr_branch(self):\n        pass\n\n    @abstractmethod\n    def get_user_id(self):\n        pass\n\n    @abstractmethod\n    def get_pr_description_full(self) -> str:\n        pass\n\n    def edit_comment(self, comment, body: str):\n        pass\n\n    def edit_comment_from_comment_id(self, comment_id: int, body: str):\n        pass\n\n    def get_comment_body_from_comment_id(self, comment_id: int) -> str:\n        pass\n\n    def reply_to_comment_from_comment_id(self, comment_id: int, body: str):\n        pass\n\n    def get_pr_description(self, full: bool = True, split_changes_walkthrough=False) -> str or tuple:\n        from pr_agent.algo.utils import clip_tokens\n        from pr_agent.config_loader import get_settings\n        max_tokens_description = get_settings().get(\"CONFIG.MAX_DESCRIPTION_TOKENS\", None)\n        description = self.get_pr_description_full() if full else self.get_user_description()\n        if split_changes_walkthrough:\n            description, files = process_description(description)\n            if max_tokens_description:\n                description = clip_tokens(description, max_tokens_description)\n            return description, files\n        else:\n            if max_tokens_description:\n                description = clip_tokens(description, max_tokens_description)\n            return description\n\n    def get_user_description(self) -> str:\n        if hasattr(self, 'user_description') and not (self.user_description is None):\n            return self.user_description\n\n        description = (self.get_pr_description_full() or \"\").strip()\n        description_lowercase = description.lower()\n        get_logger().debug(f\"Existing description\", description=description_lowercase)\n\n        # if the existing description wasn't generated by the pr-agent, just return it as-is\n        if not self._is_generated_by_pr_agent(description_lowercase):\n            get_logger().info(f\"Existing description was not generated by the pr-agent\")\n            self.user_description = description\n            return description\n\n        # if the existing description was generated by the pr-agent, but it doesn't contain a user description,\n        # return nothing (empty string) because it means there is no user description\n        user_description_header = \"### **user description**\"\n        if user_description_header not in description_lowercase:\n            get_logger().info(f\"Existing description was generated by the pr-agent, but it doesn't contain a user description\")\n            return \"\"\n\n        # otherwise, extract the original user description from the existing pr-agent description and return it\n        # user_description_start_position = description_lowercase.find(user_description_header) + len(user_description_header)\n        # return description[user_description_start_position:].split(\"\\n\", 1)[-1].strip()\n\n        # the 'user description' is in the beginning. extract and return it\n        possible_headers = self._possible_headers()\n        start_position = description_lowercase.find(user_description_header) + len(user_description_header)\n        end_position = len(description)\n        for header in possible_headers: # try to clip at the next header\n            if header != user_description_header and header in description_lowercase:\n                end_position = min(end_position, description_lowercase.find(header))\n        if end_position != len(description) and end_position > start_position:\n            original_user_description = description[start_position:end_position].strip()\n            if original_user_description.endswith(\"___\"):\n                original_user_description = original_user_description[:-3].strip()\n        else:\n            original_user_description = description.split(\"___\")[0].strip()\n            if original_user_description.lower().startswith(user_description_header):\n                original_user_description = original_user_description[len(user_description_header):].strip()\n\n        get_logger().info(f\"Extracted user description from existing description\",\n                          description=original_user_description)\n        self.user_description = original_user_description\n        return original_user_description\n\n    def _possible_headers(self):\n        return (\"### **user description**\", \"### **pr type**\", \"### **pr description**\", \"### **pr labels**\", \"### **type**\", \"### **description**\",\n                \"### **labels**\", \"### ü§ñ generated by pr agent\")\n\n    def _is_generated_by_pr_agent(self, description_lowercase: str) -> bool:\n        possible_headers = self._possible_headers()\n        return any(description_lowercase.startswith(header) for header in possible_headers)\n\n    @abstractmethod\n    def get_repo_settings(self):\n        pass\n\n    def get_workspace_name(self):\n        return \"\"\n\n    def get_pr_id(self):\n        return \"\"\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        return \"\"\n\n    def get_lines_link_original_file(self, filepath:str, component_range: Range) -> str:\n        return \"\"\n\n    #### comments operations ####\n    @abstractmethod\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        pass\n\n    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        self.publish_comment(pr_comment)\n\n    def publish_persistent_comment_full(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        try:\n            prev_comments = list(self.get_issue_comments())\n            for comment in prev_comments:\n                if comment.body.startswith(initial_header):\n                    latest_commit_url = self.get_latest_commit_url()\n                    comment_url = self.get_comment_url(comment)\n                    if update_header:\n                        updated_header = f\"{initial_header}\\n\\n#### ({name.capitalize()} updated until commit {latest_commit_url})\\n\"\n                        pr_comment_updated = pr_comment.replace(initial_header, updated_header)\n                    else:\n                        pr_comment_updated = pr_comment\n                    get_logger().info(f\"Persistent mode - updating comment {comment_url} to latest {name} message\")\n                    # response = self.mr.notes.update(comment.id, {'body': pr_comment_updated})\n                    self.edit_comment(comment, pr_comment_updated)\n                    if final_update_message:\n                        self.publish_comment(\n                            f\"**[Persistent {name}]({comment_url})** updated to latest commit {latest_commit_url}\")\n                    return\n        except Exception as e:\n            get_logger().exception(f\"Failed to update persistent review, error: {e}\")\n            pass\n        self.publish_comment(pr_comment)\n\n\n    @abstractmethod\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        pass\n\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n        raise NotImplementedError(\"This git provider does not support creating inline comments yet\")\n\n    @abstractmethod\n    def publish_inline_comments(self, comments: list[dict]):\n        pass\n\n    @abstractmethod\n    def remove_initial_comment(self):\n        pass\n\n    @abstractmethod\n    def remove_comment(self, comment):\n        pass\n\n    @abstractmethod\n    def get_issue_comments(self):\n        pass\n\n    def get_comment_url(self, comment) -> str:\n        return \"\"\n\n    #### labels operations ####\n    @abstractmethod\n    def publish_labels(self, labels):\n        pass\n\n    @abstractmethod\n    def get_pr_labels(self, update=False):\n        pass\n\n    def get_repo_labels(self):\n        pass\n\n    @abstractmethod\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        pass\n\n    @abstractmethod\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        pass\n\n    #### commits operations ####\n    @abstractmethod\n    def get_commit_messages(self):\n        pass\n\n    def get_pr_url(self) -> str:\n        if hasattr(self, 'pr_url'):\n            return self.pr_url\n        return \"\"\n\n    def get_latest_commit_url(self) -> str:\n        return \"\"\n\n    def auto_approve(self) -> bool:\n        return False\n\n    def calc_pr_statistics(self, pull_request_data: dict):\n        return {}\n\n    def get_num_of_files(self):\n        try:\n            return len(self.get_diff_files())\n        except Exception as e:\n            return -1\n\n    def limit_output_characters(self, output: str, max_chars: int):\n        return output[:max_chars] + '...' if len(output) > max_chars else output\n\n\ndef get_main_pr_language(languages, files) -> str:\n    \"\"\"\n    Get the main language of the commit. Return an empty string if cannot determine.\n    \"\"\"\n    main_language_str = \"\"\n    if not languages:\n        get_logger().info(\"No languages detected\")\n        return main_language_str\n    if not files:\n        get_logger().info(\"No files in diff\")\n        return main_language_str\n\n    try:\n        top_language = max(languages, key=languages.get).lower()\n\n        # validate that the specific commit uses the main language\n        extension_list = []\n        for file in files:\n            if not file:\n                continue\n            if isinstance(file, str):\n                file = FilePatchInfo(base_file=None, head_file=None, patch=None, filename=file)\n            extension_list.append(file.filename.rsplit('.')[-1])\n\n        # get the most common extension\n        most_common_extension = '.' + max(set(extension_list), key=extension_list.count)\n        try:\n            language_extension_map_org = get_settings().language_extension_map_org\n            language_extension_map = {k.lower(): v for k, v in language_extension_map_org.items()}\n\n            if top_language in language_extension_map and most_common_extension in language_extension_map[top_language]:\n                main_language_str = top_language\n            else:\n                for language, extensions in language_extension_map.items():\n                    if most_common_extension in extensions:\n                        main_language_str = language\n                        break\n        except Exception as e:\n            get_logger().exception(f\"Failed to get main language: {e}\")\n            pass\n\n        ## old approach:\n        # most_common_extension = max(set(extension_list), key=extension_list.count)\n        # if most_common_extension == 'py' and top_language == 'python' or \\\n        #         most_common_extension == 'js' and top_language == 'javascript' or \\\n        #         most_common_extension == 'ts' and top_language == 'typescript' or \\\n        #         most_common_extension == 'tsx' and top_language == 'typescript' or \\\n        #         most_common_extension == 'go' and top_language == 'go' or \\\n        #         most_common_extension == 'java' and top_language == 'java' or \\\n        #         most_common_extension == 'c' and top_language == 'c' or \\\n        #         most_common_extension == 'cpp' and top_language == 'c++' or \\\n        #         most_common_extension == 'cs' and top_language == 'c#' or \\\n        #         most_common_extension == 'swift' and top_language == 'swift' or \\\n        #         most_common_extension == 'php' and top_language == 'php' or \\\n        #         most_common_extension == 'rb' and top_language == 'ruby' or \\\n        #         most_common_extension == 'rs' and top_language == 'rust' or \\\n        #         most_common_extension == 'scala' and top_language == 'scala' or \\\n        #         most_common_extension == 'kt' and top_language == 'kotlin' or \\\n        #         most_common_extension == 'pl' and top_language == 'perl' or \\\n        #         most_common_extension == top_language:\n        #     main_language_str = top_language\n\n    except Exception as e:\n        get_logger().exception(e)\n        pass\n\n    return main_language_str\n\n\n\n\nclass IncrementalPR:\n    def __init__(self, is_incremental: bool = False):\n        self.is_incremental = is_incremental\n        self.commits_range = None\n        self.first_new_commit = None\n        self.last_seen_commit = None\n\n    @property\n    def first_new_commit_sha(self):\n        return None if self.first_new_commit is None else self.first_new_commit.sha\n\n    @property\n    def last_seen_commit_sha(self):\n        return None if self.last_seen_commit is None else self.last_seen_commit.sha\n"}
{"type": "source_file", "path": "pr_agent/algo/token_handler.py", "content": "from threading import Lock\n\nfrom jinja2 import Environment, StrictUndefined\nfrom tiktoken import encoding_for_model, get_encoding\n\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.log import get_logger\n\n\nclass TokenEncoder:\n    _encoder_instance = None\n    _model = None\n    _lock = Lock()  # Create a lock object\n\n    @classmethod\n    def get_token_encoder(cls):\n        model = get_settings().config.model\n        if cls._encoder_instance is None or model != cls._model:  # Check without acquiring the lock for performance\n            with cls._lock:  # Lock acquisition to ensure thread safety\n                if cls._encoder_instance is None or model != cls._model:\n                    cls._model = model\n                    cls._encoder_instance = encoding_for_model(cls._model) if \"gpt\" in cls._model else get_encoding(\n                        \"cl100k_base\")\n        return cls._encoder_instance\n\n\nclass TokenHandler:\n    \"\"\"\n    A class for handling tokens in the context of a pull request.\n\n    Attributes:\n    - encoder: An object of the encoding_for_model class from the tiktoken module. Used to encode strings and count the\n      number of tokens in them.\n    - limit: The maximum number of tokens allowed for the given model, as defined in the MAX_TOKENS dictionary in the\n      pr_agent.algo module.\n    - prompt_tokens: The number of tokens in the system and user strings, as calculated by the _get_system_user_tokens\n      method.\n    \"\"\"\n\n    def __init__(self, pr=None, vars: dict = {}, system=\"\", user=\"\"):\n        \"\"\"\n        Initializes the TokenHandler object.\n\n        Args:\n        - pr: The pull request object.\n        - vars: A dictionary of variables.\n        - system: The system string.\n        - user: The user string.\n        \"\"\"\n        self.encoder = TokenEncoder.get_token_encoder()\n        if pr is not None:\n            self.prompt_tokens = self._get_system_user_tokens(pr, self.encoder, vars, system, user)\n\n    def _get_system_user_tokens(self, pr, encoder, vars: dict, system, user):\n        \"\"\"\n        Calculates the number of tokens in the system and user strings.\n\n        Args:\n        - pr: The pull request object.\n        - encoder: An object of the encoding_for_model class from the tiktoken module.\n        - vars: A dictionary of variables.\n        - system: The system string.\n        - user: The user string.\n\n        Returns:\n        The sum of the number of tokens in the system and user strings.\n        \"\"\"\n        try:\n            environment = Environment(undefined=StrictUndefined)\n            system_prompt = environment.from_string(system).render(vars)\n            user_prompt = environment.from_string(user).render(vars)\n            system_prompt_tokens = len(encoder.encode(system_prompt))\n            user_prompt_tokens = len(encoder.encode(user_prompt))\n            return system_prompt_tokens + user_prompt_tokens\n        except Exception as e:\n            get_logger().error(f\"Error in _get_system_user_tokens: {e}\")\n            return 0\n\n    def count_tokens(self, patch: str) -> int:\n        \"\"\"\n        Counts the number of tokens in a given patch string.\n\n        Args:\n        - patch: The patch string.\n\n        Returns:\n        The number of tokens in the patch string.\n        \"\"\"\n        return len(self.encoder.encode(patch, disallowed_special=()))\n"}
{"type": "source_file", "path": "pr_agent/git_providers/bitbucket_provider.py", "content": "import difflib\nimport json\nimport re\nfrom typing import Optional, Tuple\nfrom urllib.parse import urlparse\n\nimport requests\nfrom atlassian.bitbucket import Cloud\nfrom starlette_context import context\n\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\n\nfrom ..algo.file_filter import filter_ignored\nfrom ..algo.language_handler import is_valid_file\nfrom ..algo.utils import find_line_number_of_relevant_line_in_file\nfrom ..config_loader import get_settings\nfrom ..log import get_logger\nfrom .git_provider import MAX_FILES_ALLOWED_FULL, GitProvider\n\n\ndef _gef_filename(diff):\n    if diff.new.path:\n        return diff.new.path\n    return diff.old.path\n\n\nclass BitbucketProvider(GitProvider):\n    def __init__(\n        self, pr_url: Optional[str] = None, incremental: Optional[bool] = False\n    ):\n        s = requests.Session()\n        try:\n            bearer = context.get(\"bitbucket_bearer_token\", None)\n            s.headers[\"Authorization\"] = f\"Bearer {bearer}\"\n        except Exception:\n            s.headers[\n                \"Authorization\"\n            ] = f'Bearer {get_settings().get(\"BITBUCKET.BEARER_TOKEN\", None)}'\n        s.headers[\"Content-Type\"] = \"application/json\"\n        self.headers = s.headers\n        self.bitbucket_client = Cloud(session=s)\n        self.max_comment_length = 31000\n        self.workspace_slug = None\n        self.repo_slug = None\n        self.repo = None\n        self.pr_num = None\n        self.pr = None\n        self.pr_url = pr_url\n        self.temp_comments = []\n        self.incremental = incremental\n        self.diff_files = None\n        self.git_files = None\n        if pr_url:\n            self.set_pr(pr_url)\n        self.bitbucket_comment_api_url = self.pr._BitbucketBase__data[\"links\"][\"comments\"][\"href\"]\n        self.bitbucket_pull_request_api_url = self.pr._BitbucketBase__data[\"links\"]['self']['href']\n\n    def get_repo_settings(self):\n        try:\n            url = (f\"https://api.bitbucket.org/2.0/repositories/{self.workspace_slug}/{self.repo_slug}/src/\"\n                   f\"{self.pr.destination_branch}/.pr_agent.toml\")\n            response = requests.request(\"GET\", url, headers=self.headers)\n            if response.status_code == 404:  # not found\n                return \"\"\n            contents = response.text.encode('utf-8')\n            return contents\n        except Exception:\n            return \"\"\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        \"\"\"\n        Publishes code suggestions as comments on the PR.\n        \"\"\"\n        post_parameters_list = []\n        for suggestion in code_suggestions:\n            body = suggestion[\"body\"]\n            original_suggestion = suggestion.get('original_suggestion', None)  # needed for diff code\n            if original_suggestion:\n                try:\n                    existing_code = original_suggestion['existing_code'].rstrip() + \"\\n\"\n                    improved_code = original_suggestion['improved_code'].rstrip() + \"\\n\"\n                    diff = difflib.unified_diff(existing_code.split('\\n'),\n                                                improved_code.split('\\n'), n=999)\n                    patch_orig = \"\\n\".join(diff)\n                    patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n                    diff_code = f\"\\n\\n```diff\\n{patch.rstrip()}\\n```\"\n                    # replace ```suggestion ... ``` with diff_code, using regex:\n                    body = re.sub(r'```suggestion.*?```', diff_code, body, flags=re.DOTALL)\n                except Exception as e:\n                    get_logger().exception(f\"Bitbucket failed to get diff code for publishing, error: {e}\")\n                    continue\n\n            relevant_file = suggestion[\"relevant_file\"]\n            relevant_lines_start = suggestion[\"relevant_lines_start\"]\n            relevant_lines_end = suggestion[\"relevant_lines_end\"]\n\n            if not relevant_lines_start or relevant_lines_start == -1:\n                get_logger().exception(\n                    f\"Failed to publish code suggestion, relevant_lines_start is {relevant_lines_start}\"\n                )\n                continue\n\n            if relevant_lines_end < relevant_lines_start:\n                get_logger().exception(\n                    f\"Failed to publish code suggestion, \"\n                    f\"relevant_lines_end is {relevant_lines_end} and \"\n                    f\"relevant_lines_start is {relevant_lines_start}\"\n                )\n                continue\n\n            if relevant_lines_end > relevant_lines_start:\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_end,\n                    \"start_line\": relevant_lines_start,\n                    \"start_side\": \"RIGHT\",\n                }\n            else:  # API is different for single line comments\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_start,\n                    \"side\": \"RIGHT\",\n                }\n            post_parameters_list.append(post_parameters)\n\n        try:\n            self.publish_inline_comments(post_parameters_list)\n            return True\n        except Exception as e:\n            get_logger().error(f\"Bitbucket failed to publish code suggestion, error: {e}\")\n            return False\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        pass\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in ['get_issue_comments', 'publish_inline_comments', 'get_labels', 'gfm_markdown',\n                            'publish_file_comments']:\n            return False\n        return True\n\n    def set_pr(self, pr_url: str):\n        self.workspace_slug, self.repo_slug, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def get_files(self):\n        try:\n            git_files = context.get(\"git_files\", None)\n            if git_files:\n                return git_files\n            self.git_files = [_gef_filename(diff) for diff in self.pr.diffstat()]\n            context[\"git_files\"] = self.git_files\n            return self.git_files\n        except Exception:\n            if not self.git_files:\n                self.git_files = [_gef_filename(diff) for diff in self.pr.diffstat()]\n            return self.git_files\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        if self.diff_files:\n            return self.diff_files\n\n        diffs_original = list(self.pr.diffstat())\n        diffs = filter_ignored(diffs_original, 'bitbucket')\n        if diffs != diffs_original:\n            try:\n                names_original = [d.new.path for d in diffs_original]\n                names_kept = [d.new.path for d in diffs]\n                names_filtered = list(set(names_original) - set(names_kept))\n                get_logger().info(f\"Filtered out [ignore] files for PR\", extra={\n                    'original_files': names_original,\n                    'names_kept': names_kept,\n                    'names_filtered': names_filtered\n\n                })\n            except Exception as e:\n                pass\n\n        # get the pr patches\n        try:\n            pr_patches = self.pr.diff()\n        except Exception as e:\n            # Try different encodings if UTF-8 fails\n            get_logger().warning(f\"Failed to decode PR patch with utf-8, error: {e}\")\n            encodings_to_try = ['iso-8859-1', 'latin-1', 'ascii', 'utf-16']\n            pr_patches = None\n            for encoding in encodings_to_try:\n                try:\n                    pr_patches = self.pr.diff(encoding=encoding)\n                    get_logger().info(f\"Successfully decoded PR patch with encoding {encoding}\")\n                    break\n                except UnicodeDecodeError:\n                    continue\n\n            if pr_patches is None:\n                raise ValueError(f\"Failed to decode PR patch with encodings {encodings_to_try}\")\n\n        diff_split = [\"diff --git\" + x for x in pr_patches.split(\"diff --git\") if x.strip()]\n        # filter all elements of 'diff_split' that are of indices in 'diffs_original' that are not in 'diffs'\n        if len(diff_split) > len(diffs) and len(diffs_original) == len(diff_split):\n            diff_split = [diff_split[i] for i in range(len(diff_split)) if diffs_original[i] in diffs]\n        if len(diff_split) != len(diffs):\n            get_logger().error(f\"Error - failed to split the diff into {len(diffs)} parts\")\n            return []\n        # bitbucket diff has a header for each file, we need to remove it:\n        # \"diff --git filename\n        # new file mode 100644 (optional)\n        #  index caa56f0..61528d7 100644\n        #   --- a/pr_agent/cli_pip.py\n        #  +++ b/pr_agent/cli_pip.py\n        #   @@ -... @@\"\n        for i, _ in enumerate(diff_split):\n            diff_split_lines = diff_split[i].splitlines()\n            if (len(diff_split_lines) >= 6) and \\\n                    ((diff_split_lines[2].startswith(\"---\") and\n                      diff_split_lines[3].startswith(\"+++\") and\n                      diff_split_lines[4].startswith(\"@@\")) or\n                     (diff_split_lines[3].startswith(\"---\") and  # new or deleted file\n                      diff_split_lines[4].startswith(\"+++\") and\n                      diff_split_lines[5].startswith(\"@@\"))):\n                diff_split[i] = \"\\n\".join(diff_split_lines[4:])\n            else:\n                if diffs[i].data.get('lines_added', 0) == 0 and diffs[i].data.get('lines_removed', 0) == 0:\n                    diff_split[i] = \"\"\n                elif len(diff_split_lines) <= 3:\n                    diff_split[i] = \"\"\n                    get_logger().info(f\"Disregarding empty diff for file {_gef_filename(diffs[i])}\")\n                else:\n                    get_logger().warning(f\"Bitbucket failed to get diff for file {_gef_filename(diffs[i])}\")\n                    diff_split[i] = \"\"\n\n        invalid_files_names = []\n        diff_files = []\n        counter_valid = 0\n        # get full files\n        for index, diff in enumerate(diffs):\n            file_path = _gef_filename(diff)\n            if not is_valid_file(file_path):\n                invalid_files_names.append(file_path)\n                continue\n\n            try:\n                counter_valid += 1\n                if get_settings().get(\"bitbucket_app.avoid_full_files\", False):\n                    original_file_content_str = \"\"\n                    new_file_content_str = \"\"\n                elif counter_valid < MAX_FILES_ALLOWED_FULL // 2:  # factor 2 because bitbucket has limited API calls\n                    if diff.old.get_data(\"links\"):\n                        original_file_content_str = self._get_pr_file_content(\n                            diff.old.get_data(\"links\")['self']['href'])\n                    else:\n                        original_file_content_str = \"\"\n                    if diff.new.get_data(\"links\"):\n                        new_file_content_str = self._get_pr_file_content(diff.new.get_data(\"links\")['self']['href'])\n                    else:\n                        new_file_content_str = \"\"\n                else:\n                    if counter_valid == MAX_FILES_ALLOWED_FULL // 2:\n                        get_logger().info(\n                            f\"Bitbucket too many files in PR, will avoid loading full content for rest of files\")\n                    original_file_content_str = \"\"\n                    new_file_content_str = \"\"\n            except Exception as e:\n                get_logger().exception(f\"Error - bitbucket failed to get file content, error: {e}\")\n                original_file_content_str = \"\"\n                new_file_content_str = \"\"\n\n            file_patch_canonic_structure = FilePatchInfo(\n                original_file_content_str,\n                new_file_content_str,\n                diff_split[index],\n                file_path,\n            )\n\n            if diff.data['status'] == 'added':\n                file_patch_canonic_structure.edit_type = EDIT_TYPE.ADDED\n            elif diff.data['status'] == 'removed':\n                file_patch_canonic_structure.edit_type = EDIT_TYPE.DELETED\n            elif diff.data['status'] == 'modified':\n                file_patch_canonic_structure.edit_type = EDIT_TYPE.MODIFIED\n            elif diff.data['status'] == 'renamed':\n                file_patch_canonic_structure.edit_type = EDIT_TYPE.RENAMED\n            diff_files.append(file_patch_canonic_structure)\n\n        if invalid_files_names:\n            get_logger().info(f\"Disregarding files with invalid extensions:\\n{invalid_files_names}\")\n\n        self.diff_files = diff_files\n        return diff_files\n\n    def get_latest_commit_url(self):\n        return self.pr.data['source']['commit']['links']['html']['href']\n\n    def get_comment_url(self, comment):\n        return comment.data['links']['html']['href']\n\n    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        try:\n            for comment in self.pr.comments():\n                body = comment.raw\n                if initial_header in body:\n                    latest_commit_url = self.get_latest_commit_url()\n                    comment_url = self.get_comment_url(comment)\n                    if update_header:\n                        updated_header = f\"{initial_header}\\n\\n#### ({name.capitalize()} updated until commit {latest_commit_url})\\n\"\n                        pr_comment_updated = pr_comment.replace(initial_header, updated_header)\n                    else:\n                        pr_comment_updated = pr_comment\n                    get_logger().info(f\"Persistent mode - updating comment {comment_url} to latest {name} message\")\n                    d = {\"content\": {\"raw\": pr_comment_updated}}\n                    response = comment._update_data(comment.put(None, data=d))\n                    if final_update_message:\n                        self.publish_comment(\n                            f\"**[Persistent {name}]({comment_url})** updated to latest commit {latest_commit_url}\")\n                    return\n        except Exception as e:\n            get_logger().exception(f\"Failed to update persistent review, error: {e}\")\n            pass\n        self.publish_comment(pr_comment)\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if is_temporary and not get_settings().config.publish_output_progress:\n            get_logger().debug(f\"Skipping publish_comment for temporary comment: {pr_comment}\")\n            return None\n        pr_comment = self.limit_output_characters(pr_comment, self.max_comment_length)\n        comment = self.pr.comment(pr_comment)\n        if is_temporary:\n            self.temp_comments.append(comment[\"id\"])\n        return comment\n\n    def edit_comment(self, comment, body: str):\n        try:\n            body = self.limit_output_characters(body, self.max_comment_length)\n            comment.update(body)\n        except Exception as e:\n            get_logger().exception(f\"Failed to update comment, error: {e}\")\n\n    def remove_initial_comment(self):\n        try:\n            for comment in self.temp_comments:\n                self.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove temp comments, error: {e}\")\n\n    def remove_comment(self, comment):\n        try:\n            self.pr.delete(f\"comments/{comment}\")\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove comment, error: {e}\")\n\n    # function to create_inline_comment\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n        body = self.limit_output_characters(body, self.max_comment_length)\n        position, absolute_position = find_line_number_of_relevant_line_in_file(self.get_diff_files(),\n                                                                                relevant_file.strip('`'),\n                                                                                relevant_line_in_file,\n                                                                                absolute_position)\n        if position == -1:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n            subject_type = \"FILE\"\n        else:\n            subject_type = \"LINE\"\n        path = relevant_file.strip()\n        return dict(body=body, path=path, position=absolute_position) if subject_type == \"LINE\" else {}\n\n    def publish_inline_comment(self, comment: str, from_line: int, file: str, original_suggestion=None):\n        comment = self.limit_output_characters(comment, self.max_comment_length)\n        payload = json.dumps({\n            \"content\": {\n                \"raw\": comment,\n            },\n            \"inline\": {\n                \"to\": from_line,\n                \"path\": file\n            },\n        })\n        response = requests.request(\n            \"POST\", self.bitbucket_comment_api_url, data=payload, headers=self.headers\n        )\n        return response\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        if relevant_line_start == -1:\n            link = f\"{self.pr_url}/#L{relevant_file}\"\n        else:\n            link = f\"{self.pr_url}/#L{relevant_file}T{relevant_line_start}\"\n        return link\n\n    def generate_link_to_relevant_line_number(self, suggestion) -> str:\n        try:\n            relevant_file = suggestion['relevant_file'].strip('`').strip(\"'\").rstrip()\n            relevant_line_str = suggestion['relevant_line'].rstrip()\n            if not relevant_line_str:\n                return \"\"\n\n            diff_files = self.get_diff_files()\n            position, absolute_position = find_line_number_of_relevant_line_in_file \\\n                (diff_files, relevant_file, relevant_line_str)\n\n            if absolute_position != -1 and self.pr_url:\n                link = f\"{self.pr_url}/#L{relevant_file}T{absolute_position}\"\n                return link\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Failed adding line link, error: {e}\")\n\n        return \"\"\n\n    def publish_inline_comments(self, comments: list[dict]):\n        for comment in comments:\n            if 'position' in comment:\n                self.publish_inline_comment(comment['body'], comment['position'], comment['path'])\n            elif 'start_line' in comment:  # multi-line comment\n                # note that bitbucket does not seem to support range - only a comment on a single line - https://community.developer.atlassian.com/t/api-post-endpoint-for-inline-pull-request-comments/60452\n                self.publish_inline_comment(comment['body'], comment['start_line'], comment['path'])\n            elif 'line' in comment:  # single-line comment\n                self.publish_inline_comment(comment['body'], comment['line'], comment['path'])\n            else:\n                get_logger().error(f\"Could not publish inline comment {comment}\")\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_languages(self):\n        languages = {self._get_repo().get_data(\"language\"): 0}\n        return languages\n\n    def get_pr_branch(self):\n        return self.pr.source_branch\n\n    def get_pr_owner_id(self) -> str | None:\n        return self.workspace_slug\n\n    def get_pr_description_full(self):\n        return self.pr.description\n\n    def get_user_id(self):\n        return 0\n\n    def get_issue_comments(self):\n        raise NotImplementedError(\n            \"Bitbucket provider does not support issue comments yet\"\n        )\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        return True\n\n    @staticmethod\n    def _parse_pr_url(pr_url: str) -> Tuple[str, int]:\n        parsed_url = urlparse(pr_url)\n\n        if \"bitbucket.org\" not in parsed_url.netloc:\n            raise ValueError(\"The provided URL is not a valid Bitbucket URL\")\n\n        path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n\n        if len(path_parts) < 4 or path_parts[2] != \"pull-requests\":\n            raise ValueError(\n                \"The provided URL does not appear to be a Bitbucket PR URL\"\n            )\n\n        workspace_slug = path_parts[0]\n        repo_slug = path_parts[1]\n        try:\n            pr_number = int(path_parts[3])\n        except ValueError as e:\n            raise ValueError(\"Unable to convert PR number to integer\") from e\n\n        return workspace_slug, repo_slug, pr_number\n\n    def _get_repo(self):\n        if self.repo is None:\n            self.repo = self.bitbucket_client.workspaces.get(\n                self.workspace_slug\n            ).repositories.get(self.repo_slug)\n        return self.repo\n\n    def _get_pr(self):\n        return self._get_repo().pullrequests.get(self.pr_num)\n\n    def get_pr_file_content(self, file_path: str, branch: str) -> str:\n        try:\n            if branch == self.pr.source_branch:\n                branch = self.pr.data[\"source\"][\"commit\"][\"hash\"]\n            elif branch == self.pr.destination_branch:\n                branch = self.pr.data[\"destination\"][\"commit\"][\"hash\"]\n            url = (f\"https://api.bitbucket.org/2.0/repositories/{self.workspace_slug}/{self.repo_slug}/src/\"\n                   f\"{branch}/{file_path}\")\n            response = requests.request(\"GET\", url, headers=self.headers)\n            if response.status_code == 404:  # not found\n                return \"\"\n            contents = response.text\n            return contents\n        except Exception:\n            return \"\"\n\n    def create_or_update_pr_file(self, file_path: str, branch: str, contents=\"\", message=\"\") -> None:\n        url = (f\"https://api.bitbucket.org/2.0/repositories/{self.workspace_slug}/{self.repo_slug}/src/\")\n        if not message:\n            if contents:\n                message = f\"Update {file_path}\"\n            else:\n                message = f\"Create {file_path}\"\n        files = {file_path: contents}\n        data = {\n            \"message\": message,\n            \"branch\": branch\n        }\n        headers = {'Authorization': self.headers['Authorization']} if 'Authorization' in self.headers else {}\n        try:\n            requests.request(\"POST\", url, headers=headers, data=data, files=files)\n        except Exception:\n            get_logger().exception(f\"Failed to create empty file {file_path} in branch {branch}\")\n\n    def _get_pr_file_content(self, remote_link: str):\n        try:\n            response = requests.request(\"GET\", remote_link, headers=self.headers)\n            if response.status_code == 404:  # not found\n                return \"\"\n            contents = response.text\n            return contents\n        except Exception:\n            return \"\"\n\n    def get_commit_messages(self):\n        return \"\"  # not implemented yet\n\n    # bitbucket does not support labels\n    def publish_description(self, pr_title: str, description: str):\n        payload = json.dumps({\n            \"description\": description,\n            \"title\": pr_title\n\n        })\n\n        response = requests.request(\"PUT\", self.bitbucket_pull_request_api_url, headers=self.headers, data=payload)\n        try:\n            if response.status_code != 200:\n                get_logger().info(f\"Failed to update description, error code: {response.status_code}\")\n        except:\n            pass\n        return response\n\n    # bitbucket does not support labels\n    def publish_labels(self, pr_types: list):\n        pass\n\n    # bitbucket does not support labels\n    def get_pr_labels(self, update=False):\n        pass\n"}
{"type": "source_file", "path": "pr_agent/git_providers/github_provider.py", "content": "import copy\nimport difflib\nimport hashlib\nimport itertools\nimport re\nimport time\nimport traceback\nimport json\nfrom datetime import datetime\nfrom typing import Optional, Tuple\nfrom urllib.parse import urlparse\n\nfrom github import AppAuthentication, Auth, Github, GithubException\nfrom retry import retry\nfrom starlette_context import context\n\nfrom ..algo.file_filter import filter_ignored\nfrom ..algo.git_patch_processing import extract_hunk_headers\nfrom ..algo.language_handler import is_valid_file\nfrom ..algo.types import EDIT_TYPE\nfrom ..algo.utils import (PRReviewHeader, Range, clip_tokens,\n                          find_line_number_of_relevant_line_in_file,\n                          load_large_diff, set_file_languages)\nfrom ..config_loader import get_settings\nfrom ..log import get_logger\nfrom ..servers.utils import RateLimitExceeded\nfrom .git_provider import (MAX_FILES_ALLOWED_FULL, FilePatchInfo, GitProvider,\n                           IncrementalPR)\n\n\nclass GithubProvider(GitProvider):\n    def __init__(self, pr_url: Optional[str] = None):\n        self.repo_obj = None\n        try:\n            self.installation_id = context.get(\"installation_id\", None)\n        except Exception:\n            self.installation_id = None\n        self.max_comment_chars = 65000\n        self.base_url = get_settings().get(\"GITHUB.BASE_URL\", \"https://api.github.com\").rstrip(\"/\") # \"https://api.github.com\"\n        self.base_url_html = self.base_url.split(\"api/\")[0].rstrip(\"/\") if \"api/\" in self.base_url else \"https://github.com\"\n        self.github_client = self._get_github_client()\n        self.repo = None\n        self.pr_num = None\n        self.pr = None\n        self.github_user_id = None\n        self.diff_files = None\n        self.git_files = None\n        self.incremental = IncrementalPR(False)\n        if pr_url and 'pull' in pr_url:\n            self.set_pr(pr_url)\n            self.pr_commits = list(self.pr.get_commits())\n            self.last_commit_id = self.pr_commits[-1]\n            self.pr_url = self.get_pr_url() # pr_url for github actions can be as api.github.com, so we need to get the url from the pr object\n        else:\n            self.pr_commits = None\n\n    def get_incremental_commits(self, incremental=IncrementalPR(False)):\n        self.incremental = incremental\n        if self.incremental.is_incremental:\n            self.unreviewed_files_set = dict()\n            self._get_incremental_commits()\n\n    def is_supported(self, capability: str) -> bool:\n        return True\n\n    def get_pr_url(self) -> str:\n        return self.pr.html_url\n\n    def set_pr(self, pr_url: str):\n        self.repo, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def _get_incremental_commits(self):\n        if not self.pr_commits:\n            self.pr_commits = list(self.pr.get_commits())\n\n        self.previous_review = self.get_previous_review(full=True, incremental=True)\n        if self.previous_review:\n            self.incremental.commits_range = self.get_commit_range()\n            # Get all files changed during the commit range\n\n            for commit in self.incremental.commits_range:\n                if commit.commit.message.startswith(f\"Merge branch '{self._get_repo().default_branch}'\"):\n                    get_logger().info(f\"Skipping merge commit {commit.commit.message}\")\n                    continue\n                self.unreviewed_files_set.update({file.filename: file for file in commit.files})\n        else:\n            get_logger().info(\"No previous review found, will review the entire PR\")\n            self.incremental.is_incremental = False\n\n    def get_commit_range(self):\n        last_review_time = self.previous_review.created_at\n        first_new_commit_index = None\n        for index in range(len(self.pr_commits) - 1, -1, -1):\n            if self.pr_commits[index].commit.author.date > last_review_time:\n                self.incremental.first_new_commit = self.pr_commits[index]\n                first_new_commit_index = index\n            else:\n                self.incremental.last_seen_commit = self.pr_commits[index]\n                break\n        return self.pr_commits[first_new_commit_index:] if first_new_commit_index is not None else []\n\n    def get_previous_review(self, *, full: bool, incremental: bool):\n        if not (full or incremental):\n            raise ValueError(\"At least one of full or incremental must be True\")\n        if not getattr(self, \"comments\", None):\n            self.comments = list(self.pr.get_issue_comments())\n        prefixes = []\n        if full:\n            prefixes.append(PRReviewHeader.REGULAR.value)\n        if incremental:\n            prefixes.append(PRReviewHeader.INCREMENTAL.value)\n        for index in range(len(self.comments) - 1, -1, -1):\n            if any(self.comments[index].body.startswith(prefix) for prefix in prefixes):\n                return self.comments[index]\n\n    def get_files(self):\n        if self.incremental.is_incremental and self.unreviewed_files_set:\n            return self.unreviewed_files_set.values()\n        try:\n            git_files = context.get(\"git_files\", None)\n            if git_files:\n                return git_files\n            self.git_files = list(self.pr.get_files()) # 'list' to handle pagination\n            context[\"git_files\"] = self.git_files\n            return self.git_files\n        except Exception:\n            if not self.git_files:\n                self.git_files = list(self.pr.get_files())\n            return self.git_files\n\n    def get_num_of_files(self):\n        if hasattr(self.git_files, \"totalCount\"):\n            return self.git_files.totalCount\n        else:\n            try:\n                return len(self.git_files)\n            except Exception as e:\n                return -1\n\n    @retry(exceptions=RateLimitExceeded,\n           tries=get_settings().github.ratelimit_retries, delay=2, backoff=2, jitter=(1, 3))\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        \"\"\"\n        Retrieves the list of files that have been modified, added, deleted, or renamed in a pull request in GitHub,\n        along with their content and patch information.\n\n        Returns:\n            diff_files (List[FilePatchInfo]): List of FilePatchInfo objects representing the modified, added, deleted,\n            or renamed files in the merge request.\n        \"\"\"\n        try:\n            try:\n                diff_files = context.get(\"diff_files\", None)\n                if diff_files:\n                    return diff_files\n            except Exception:\n                pass\n\n            if self.diff_files:\n                return self.diff_files\n\n            # filter files using [ignore] patterns\n            files_original = self.get_files()\n            files = filter_ignored(files_original)\n            if files_original != files:\n                try:\n                    names_original = [file.filename for file in files_original]\n                    names_new = [file.filename for file in files]\n                    get_logger().info(f\"Filtered out [ignore] files for pull request:\", extra=\n                    {\"files\": names_original,\n                     \"filtered_files\": names_new})\n                except Exception:\n                    pass\n\n            diff_files = []\n            invalid_files_names = []\n            is_close_to_rate_limit = False\n\n            # The base.sha will point to the current state of the base branch (including parallel merges), not the original base commit when the PR was created\n            # We can fix this by finding the merge base commit between the PR head and base branches\n            # Note that The pr.head.sha is actually correct as is - it points to the latest commit in your PR branch.\n            # This SHA isn't affected by parallel merges to the base branch since it's specific to your PR's branch.\n            repo = self.repo_obj\n            pr = self.pr\n            try:\n                compare = repo.compare(pr.base.sha, pr.head.sha) # communication with GitHub\n                merge_base_commit = compare.merge_base_commit\n            except Exception as e:\n                get_logger().error(f\"Failed to get merge base commit: {e}\")\n                merge_base_commit = pr.base\n            if merge_base_commit.sha != pr.base.sha:\n                get_logger().info(\n                    f\"Using merge base commit {merge_base_commit.sha} instead of base commit \")\n\n            counter_valid = 0\n            for file in files:\n                if not is_valid_file(file.filename):\n                    invalid_files_names.append(file.filename)\n                    continue\n\n                patch = file.patch\n                if is_close_to_rate_limit:\n                    new_file_content_str = \"\"\n                    original_file_content_str = \"\"\n                else:\n                    # allow only a limited number of files to be fully loaded. We can manage the rest with diffs only\n                    counter_valid += 1\n                    avoid_load = False\n                    if counter_valid >= MAX_FILES_ALLOWED_FULL and patch and not self.incremental.is_incremental:\n                        avoid_load = True\n                        if counter_valid == MAX_FILES_ALLOWED_FULL:\n                            get_logger().info(f\"Too many files in PR, will avoid loading full content for rest of files\")\n\n                    if avoid_load:\n                        new_file_content_str = \"\"\n                    else:\n                        new_file_content_str = self._get_pr_file_content(file, self.pr.head.sha)  # communication with GitHub\n\n                    if self.incremental.is_incremental and self.unreviewed_files_set:\n                        original_file_content_str = self._get_pr_file_content(file, self.incremental.last_seen_commit_sha)\n                        patch = load_large_diff(file.filename, new_file_content_str, original_file_content_str)\n                        self.unreviewed_files_set[file.filename] = patch\n                    else:\n                        if avoid_load:\n                            original_file_content_str = \"\"\n                        else:\n                            original_file_content_str = self._get_pr_file_content(file, merge_base_commit.sha)\n                            # original_file_content_str = self._get_pr_file_content(file, self.pr.base.sha)\n                        if not patch:\n                            patch = load_large_diff(file.filename, new_file_content_str, original_file_content_str)\n\n\n                if file.status == 'added':\n                    edit_type = EDIT_TYPE.ADDED\n                elif file.status == 'removed':\n                    edit_type = EDIT_TYPE.DELETED\n                elif file.status == 'renamed':\n                    edit_type = EDIT_TYPE.RENAMED\n                elif file.status == 'modified':\n                    edit_type = EDIT_TYPE.MODIFIED\n                else:\n                    get_logger().error(f\"Unknown edit type: {file.status}\")\n                    edit_type = EDIT_TYPE.UNKNOWN\n\n                # count number of lines added and removed\n                if hasattr(file, 'additions') and hasattr(file, 'deletions'):\n                    num_plus_lines = file.additions\n                    num_minus_lines = file.deletions\n                else:\n                    patch_lines = patch.splitlines(keepends=True)\n                    num_plus_lines = len([line for line in patch_lines if line.startswith('+')])\n                    num_minus_lines = len([line for line in patch_lines if line.startswith('-')])\n\n                file_patch_canonical_structure = FilePatchInfo(original_file_content_str, new_file_content_str, patch,\n                                                               file.filename, edit_type=edit_type,\n                                                               num_plus_lines=num_plus_lines,\n                                                               num_minus_lines=num_minus_lines,)\n                diff_files.append(file_patch_canonical_structure)\n            if invalid_files_names:\n                get_logger().info(f\"Filtered out files with invalid extensions: {invalid_files_names}\")\n\n            self.diff_files = diff_files\n            try:\n                context[\"diff_files\"] = diff_files\n            except Exception:\n                pass\n\n            return diff_files\n\n        except Exception as e:\n            get_logger().error(f\"Failing to get diff files: {e}\",\n                               artifact={\"traceback\": traceback.format_exc()})\n            raise RateLimitExceeded(\"Rate limit exceeded for GitHub API.\") from e\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        self.pr.edit(title=pr_title, body=pr_body)\n\n    def get_latest_commit_url(self) -> str:\n        return self.last_commit_id.html_url\n\n    def get_comment_url(self, comment) -> str:\n        return comment.html_url\n\n    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        self.publish_persistent_comment_full(pr_comment, initial_header, update_header, name, final_update_message)\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if is_temporary and not get_settings().config.publish_output_progress:\n            get_logger().debug(f\"Skipping publish_comment for temporary comment: {pr_comment}\")\n            return None\n        pr_comment = self.limit_output_characters(pr_comment, self.max_comment_chars)\n        response = self.pr.create_issue_comment(pr_comment)\n        if hasattr(response, \"user\") and hasattr(response.user, \"login\"):\n            self.github_user_id = response.user.login\n        response.is_temporary = is_temporary\n        if not hasattr(self.pr, 'comments_list'):\n            self.pr.comments_list = []\n        self.pr.comments_list.append(response)\n        return response\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        self.publish_inline_comments([self.create_inline_comment(body, relevant_file, relevant_line_in_file)])\n\n\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        position, absolute_position = find_line_number_of_relevant_line_in_file(self.diff_files,\n                                                                                relevant_file.strip('`'),\n                                                                                relevant_line_in_file,\n                                                                                absolute_position)\n        if position == -1:\n            get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n            subject_type = \"FILE\"\n        else:\n            subject_type = \"LINE\"\n        path = relevant_file.strip()\n        return dict(body=body, path=path, position=position) if subject_type == \"LINE\" else {}\n\n    def publish_inline_comments(self, comments: list[dict], disable_fallback: bool = False):\n        try:\n            # publish all comments in a single message\n            self.pr.create_review(commit=self.last_commit_id, comments=comments)\n        except Exception as e:\n            get_logger().info(f\"Initially failed to publish inline comments as committable\")\n\n            if (getattr(e, \"status\", None) == 422 and not disable_fallback):\n                pass  # continue to try _publish_inline_comments_fallback_with_verification\n            else:\n                raise e # will end up with publishing the comments one by one\n\n            try:\n                self._publish_inline_comments_fallback_with_verification(comments)\n            except Exception as e:\n                get_logger().error(f\"Failed to publish inline code comments fallback, error: {e}\")\n                raise e\n\n    def _publish_inline_comments_fallback_with_verification(self, comments: list[dict]):\n        \"\"\"\n        Check each inline comment separately against the GitHub API and discard of invalid comments,\n        then publish all the remaining valid comments in a single review.\n        For invalid comments, also try removing the suggestion part and posting the comment just on the first line.\n        \"\"\"\n        verified_comments, invalid_comments = self._verify_code_comments(comments)\n\n        # publish as a group the verified comments\n        if verified_comments:\n            try:\n                self.pr.create_review(commit=self.last_commit_id, comments=verified_comments)\n            except:\n                pass\n\n        # try to publish one by one the invalid comments as a one-line code comment\n        if invalid_comments and get_settings().github.try_fix_invalid_inline_comments:\n            fixed_comments_as_one_liner = self._try_fix_invalid_inline_comments(\n                [comment for comment, _ in invalid_comments])\n            for comment in fixed_comments_as_one_liner:\n                try:\n                    self.publish_inline_comments([comment], disable_fallback=True)\n                    get_logger().info(f\"Published invalid comment as a single line comment: {comment}\")\n                except:\n                    get_logger().error(f\"Failed to publish invalid comment as a single line comment: {comment}\")\n\n    def _verify_code_comment(self, comment: dict):\n        is_verified = False\n        e = None\n        try:\n            # event =\"\" # By leaving this blank, you set the review action state to PENDING\n            input = dict(commit_id=self.last_commit_id.sha, comments=[comment])\n            headers, data = self.pr._requester.requestJsonAndCheck(\n                \"POST\", f\"{self.pr.url}/reviews\", input=input)\n            pending_review_id = data[\"id\"]\n            is_verified = True\n        except Exception as err:\n            is_verified = False\n            pending_review_id = None\n            e = err\n        if pending_review_id is not None:\n            try:\n                self.pr._requester.requestJsonAndCheck(\"DELETE\", f\"{self.pr.url}/reviews/{pending_review_id}\")\n            except Exception:\n                pass\n        return is_verified, e\n\n    def _verify_code_comments(self, comments: list[dict]) -> tuple[list[dict], list[tuple[dict, Exception]]]:\n        \"\"\"Very each comment against the GitHub API and return 2 lists: 1 of verified and 1 of invalid comments\"\"\"\n        verified_comments = []\n        invalid_comments = []\n        for comment in comments:\n            time.sleep(1)  # for avoiding secondary rate limit\n            is_verified, e = self._verify_code_comment(comment)\n            if is_verified:\n                verified_comments.append(comment)\n            else:\n                invalid_comments.append((comment, e))\n        return verified_comments, invalid_comments\n\n    def _try_fix_invalid_inline_comments(self, invalid_comments: list[dict]) -> list[dict]:\n        \"\"\"\n        Try fixing invalid comments by removing the suggestion part and setting the comment just on the first line.\n        Return only comments that have been modified in some way.\n        This is a best-effort attempt to fix invalid comments, and should be verified accordingly.\n        \"\"\"\n        import copy\n        fixed_comments = []\n        for comment in invalid_comments:\n            try:\n                fixed_comment = copy.deepcopy(comment)  # avoid modifying the original comment dict for later logging\n                if \"```suggestion\" in comment[\"body\"]:\n                    fixed_comment[\"body\"] = comment[\"body\"].split(\"```suggestion\")[0]\n                if \"start_line\" in comment:\n                    fixed_comment[\"line\"] = comment[\"start_line\"]\n                    del fixed_comment[\"start_line\"]\n                if \"start_side\" in comment:\n                    fixed_comment[\"side\"] = comment[\"start_side\"]\n                    del fixed_comment[\"start_side\"]\n                if fixed_comment != comment:\n                    fixed_comments.append(fixed_comment)\n            except Exception as e:\n                get_logger().error(f\"Failed to fix inline comment, error: {e}\")\n        return fixed_comments\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        \"\"\"\n        Publishes code suggestions as comments on the PR.\n        \"\"\"\n        post_parameters_list = []\n\n        code_suggestions_validated = self.validate_comments_inside_hunks(code_suggestions)\n\n        for suggestion in code_suggestions_validated:\n            body = suggestion['body']\n            relevant_file = suggestion['relevant_file']\n            relevant_lines_start = suggestion['relevant_lines_start']\n            relevant_lines_end = suggestion['relevant_lines_end']\n\n            if not relevant_lines_start or relevant_lines_start == -1:\n                get_logger().exception(\n                    f\"Failed to publish code suggestion, relevant_lines_start is {relevant_lines_start}\")\n                continue\n\n            if relevant_lines_end < relevant_lines_start:\n                get_logger().exception(f\"Failed to publish code suggestion, \"\n                                  f\"relevant_lines_end is {relevant_lines_end} and \"\n                                  f\"relevant_lines_start is {relevant_lines_start}\")\n                continue\n\n            if relevant_lines_end > relevant_lines_start:\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_end,\n                    \"start_line\": relevant_lines_start,\n                    \"start_side\": \"RIGHT\",\n                }\n            else:  # API is different for single line comments\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_start,\n                    \"side\": \"RIGHT\",\n                }\n            post_parameters_list.append(post_parameters)\n\n        try:\n            self.publish_inline_comments(post_parameters_list)\n            return True\n        except Exception as e:\n            get_logger().error(f\"Failed to publish code suggestion, error: {e}\")\n            return False\n\n    def edit_comment(self, comment, body: str):\n        try:\n            body = self.limit_output_characters(body, self.max_comment_chars)\n            comment.edit(body=body)\n        except GithubException as e:\n            if hasattr(e, \"status\") and e.status == 403:\n                # Log as warning for permission-related issues (usually due to polling)\n                get_logger().warning(\n                    \"Failed to edit github comment due to permission restrictions\",\n                    artifact={\"error\": e})\n            else:\n                get_logger().exception(f\"Failed to edit github comment\", artifact={\"error\": e})\n\n    def edit_comment_from_comment_id(self, comment_id: int, body: str):\n        try:\n            # self.pr.get_issue_comment(comment_id).edit(body)\n            body = self.limit_output_characters(body, self.max_comment_chars)\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"PATCH\", f\"{self.base_url}/repos/{self.repo}/issues/comments/{comment_id}\",\n                input={\"body\": body}\n            )\n        except Exception as e:\n            get_logger().exception(f\"Failed to edit comment, error: {e}\")\n\n    def reply_to_comment_from_comment_id(self, comment_id: int, body: str):\n        try:\n            # self.pr.get_issue_comment(comment_id).edit(body)\n            body = self.limit_output_characters(body, self.max_comment_chars)\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"POST\", f\"{self.base_url}/repos/{self.repo}/pulls/{self.pr_num}/comments/{comment_id}/replies\",\n                input={\"body\": body}\n            )\n        except Exception as e:\n            get_logger().exception(f\"Failed to reply comment, error: {e}\")\n\n    def get_comment_body_from_comment_id(self, comment_id: int):\n        try:\n            # self.pr.get_issue_comment(comment_id).edit(body)\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"GET\", f\"{self.base_url}/repos/{self.repo}/issues/comments/{comment_id}\"\n            )\n            return data_patch.get(\"body\",\"\")\n        except Exception as e:\n            get_logger().exception(f\"Failed to edit comment, error: {e}\")\n            return None\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        try:\n            headers, existing_comments = self.pr._requester.requestJsonAndCheck(\n                \"GET\", f\"{self.pr.url}/comments\"\n            )\n            for comment in file_comments:\n                comment['commit_id'] = self.last_commit_id.sha\n                comment['body'] = self.limit_output_characters(comment['body'], self.max_comment_chars)\n\n                found = False\n                for existing_comment in existing_comments:\n                    comment['commit_id'] = self.last_commit_id.sha\n                    our_app_name = get_settings().get(\"GITHUB.APP_NAME\", \"\")\n                    same_comment_creator = False\n                    if self.deployment_type == 'app':\n                        same_comment_creator = our_app_name.lower() in existing_comment['user']['login'].lower()\n                    elif self.deployment_type == 'user':\n                        same_comment_creator = self.github_user_id == existing_comment['user']['login']\n                    if existing_comment['subject_type'] == 'file' and comment['path'] == existing_comment['path'] and same_comment_creator:\n\n                        headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                            \"PATCH\", f\"{self.base_url}/repos/{self.repo}/pulls/comments/{existing_comment['id']}\", input={\"body\":comment['body']}\n                        )\n                        found = True\n                        break\n                if not found:\n                    headers, data_post = self.pr._requester.requestJsonAndCheck(\n                        \"POST\", f\"{self.pr.url}/comments\", input=comment\n                    )\n            return True\n        except Exception as e:\n            get_logger().error(f\"Failed to publish diffview file summary, error: {e}\")\n            return False\n\n    def remove_initial_comment(self):\n        try:\n            for comment in getattr(self.pr, 'comments_list', []):\n                if comment.is_temporary:\n                    self.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove initial comment, error: {e}\")\n\n    def remove_comment(self, comment):\n        try:\n            comment.delete()\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove comment, error: {e}\")\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_languages(self):\n        languages = self._get_repo().get_languages()\n        return languages\n\n    def get_pr_branch(self):\n        return self.pr.head.ref\n\n    def get_pr_owner_id(self) -> str | None:\n        if not self.repo:\n            return None\n        return self.repo.split('/')[0]\n\n    def get_pr_description_full(self):\n        return self.pr.body\n\n    def get_user_id(self):\n        if not self.github_user_id:\n            try:\n                self.github_user_id = self.github_client.get_user().raw_data['login']\n            except Exception as e:\n                self.github_user_id = \"\"\n                # logging.exception(f\"Failed to get user id, error: {e}\")\n        return self.github_user_id\n\n    def get_notifications(self, since: datetime):\n        deployment_type = get_settings().get(\"GITHUB.DEPLOYMENT_TYPE\", \"user\")\n\n        if deployment_type != 'user':\n            raise ValueError(\"Deployment mode must be set to 'user' to get notifications\")\n\n        notifications = self.github_client.get_user().get_notifications(since=since)\n        return notifications\n\n    def get_issue_comments(self):\n        return self.pr.get_issue_comments()\n\n    def get_repo_settings(self):\n        try:\n            # contents = self.repo_obj.get_contents(\".pr_agent.toml\", ref=self.pr.head.sha).decoded_content\n\n            # more logical to take 'pr_agent.toml' from the default branch\n            contents = self.repo_obj.get_contents(\".pr_agent.toml\").decoded_content\n            return contents\n        except Exception:\n            return \"\"\n\n    def get_workspace_name(self):\n        return self.repo.split('/')[0]\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        if disable_eyes:\n            return None\n        try:\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"POST\", f\"{self.base_url}/repos/{self.repo}/issues/comments/{issue_comment_id}/reactions\",\n                input={\"content\": \"eyes\"}\n            )\n            return data_patch.get(\"id\", None)\n        except Exception as e:\n            get_logger().warning(f\"Failed to add eyes reaction, error: {e}\")\n            return None\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: str) -> bool:\n        try:\n            # self.pr.get_issue_comment(issue_comment_id).delete_reaction(reaction_id)\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"DELETE\",\n                f\"{self.base_url}/repos/{self.repo}/issues/comments/{issue_comment_id}/reactions/{reaction_id}\"\n            )\n            return True\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove eyes reaction, error: {e}\")\n            return False\n\n    def _parse_pr_url(self, pr_url: str) -> Tuple[str, int]:\n        parsed_url = urlparse(pr_url)\n\n        if parsed_url.path.startswith('/api/v3'):\n            parsed_url = urlparse(pr_url.replace(\"/api/v3\", \"\"))\n\n        path_parts = parsed_url.path.strip('/').split('/')\n        if 'api.github.com' in parsed_url.netloc or '/api/v3' in pr_url:\n            if len(path_parts) < 5 or path_parts[3] != 'pulls':\n                raise ValueError(\"The provided URL does not appear to be a GitHub PR URL\")\n            repo_name = '/'.join(path_parts[1:3])\n            try:\n                pr_number = int(path_parts[4])\n            except ValueError as e:\n                raise ValueError(\"Unable to convert PR number to integer\") from e\n            return repo_name, pr_number\n\n        if len(path_parts) < 4 or path_parts[2] != 'pull':\n            raise ValueError(\"The provided URL does not appear to be a GitHub PR URL\")\n\n        repo_name = '/'.join(path_parts[:2])\n        try:\n            pr_number = int(path_parts[3])\n        except ValueError as e:\n            raise ValueError(\"Unable to convert PR number to integer\") from e\n\n        return repo_name, pr_number\n\n    def _parse_issue_url(self, issue_url: str) -> Tuple[str, int]:\n        parsed_url = urlparse(issue_url)\n\n        if 'github.com' not in parsed_url.netloc:\n            raise ValueError(\"The provided URL is not a valid GitHub URL\")\n\n        path_parts = parsed_url.path.strip('/').split('/')\n        if 'api.github.com' in parsed_url.netloc:\n            if len(path_parts) < 5 or path_parts[3] != 'issues':\n                raise ValueError(\"The provided URL does not appear to be a GitHub ISSUE URL\")\n            repo_name = '/'.join(path_parts[1:3])\n            try:\n                issue_number = int(path_parts[4])\n            except ValueError as e:\n                raise ValueError(\"Unable to convert issue number to integer\") from e\n            return repo_name, issue_number\n\n        if len(path_parts) < 4 or path_parts[2] != 'issues':\n            raise ValueError(\"The provided URL does not appear to be a GitHub PR issue\")\n\n        repo_name = '/'.join(path_parts[:2])\n        try:\n            issue_number = int(path_parts[3])\n        except ValueError as e:\n            raise ValueError(\"Unable to convert issue number to integer\") from e\n\n        return repo_name, issue_number\n\n    def _get_github_client(self):\n        deployment_type = get_settings().get(\"GITHUB.DEPLOYMENT_TYPE\", \"user\")\n\n        if deployment_type == 'app':\n            try:\n                private_key = get_settings().github.private_key\n                app_id = get_settings().github.app_id\n            except AttributeError as e:\n                raise ValueError(\"GitHub app ID and private key are required when using GitHub app deployment\") from e\n            if not self.installation_id:\n                raise ValueError(\"GitHub app installation ID is required when using GitHub app deployment\")\n            auth = AppAuthentication(app_id=app_id, private_key=private_key,\n                                     installation_id=self.installation_id)\n            return Github(app_auth=auth, base_url=self.base_url)\n\n        if deployment_type == 'user':\n            try:\n                token = get_settings().github.user_token\n            except AttributeError as e:\n                raise ValueError(\n                    \"GitHub token is required when using user deployment. See: \"\n                    \"https://github.com/Codium-ai/pr-agent#method-2-run-from-source\") from e\n            return Github(auth=Auth.Token(token), base_url=self.base_url)\n\n    def _get_repo(self):\n        if hasattr(self, 'repo_obj') and \\\n                hasattr(self.repo_obj, 'full_name') and \\\n                self.repo_obj.full_name == self.repo:\n            return self.repo_obj\n        else:\n            self.repo_obj = self.github_client.get_repo(self.repo)\n            return self.repo_obj\n\n\n    def _get_pr(self):\n        return self._get_repo().get_pull(self.pr_num)\n\n    def get_pr_file_content(self, file_path: str, branch: str) -> str:\n        try:\n            file_content_str = str(\n                self._get_repo()\n                .get_contents(file_path, ref=branch)\n                .decoded_content.decode()\n            )\n        except Exception:\n            file_content_str = \"\"\n        return file_content_str\n\n    def create_or_update_pr_file(\n        self, file_path: str, branch: str, contents=\"\", message=\"\"\n    ) -> None:\n        try:\n            file_obj = self._get_repo().get_contents(file_path, ref=branch)\n            sha1=file_obj.sha\n        except Exception:\n            sha1=\"\"\n        self.repo_obj.update_file(\n            path=file_path,\n            message=message,\n            content=contents,\n            sha=sha1,\n            branch=branch,\n        )\n\n    def _get_pr_file_content(self, file: FilePatchInfo, sha: str) -> str:\n        return self.get_pr_file_content(file.filename, sha)\n\n    def publish_labels(self, pr_types):\n        try:\n            label_color_map = {\"Bug fix\": \"1d76db\", \"Tests\": \"e99695\", \"Bug fix with tests\": \"c5def5\",\n                               \"Enhancement\": \"bfd4f2\", \"Documentation\": \"d4c5f9\",\n                               \"Other\": \"d1bcf9\"}\n            post_parameters = []\n            for p in pr_types:\n                color = label_color_map.get(p, \"d1bcf9\")  # default to \"Other\" color\n                post_parameters.append({\"name\": p, \"color\": color})\n            headers, data = self.pr._requester.requestJsonAndCheck(\n                \"PUT\", f\"{self.pr.issue_url}/labels\", input=post_parameters\n            )\n        except Exception as e:\n            get_logger().warning(f\"Failed to publish labels, error: {e}\")\n\n    def get_pr_labels(self, update=False):\n        try:\n            if not update:\n                labels =self.pr.labels\n                return [label.name for label in labels]\n            else: # obtain the latest labels. Maybe they changed while the AI was running\n                headers, labels = self.pr._requester.requestJsonAndCheck(\n                    \"GET\", f\"{self.pr.issue_url}/labels\")\n                return [label['name'] for label in labels]\n\n        except Exception as e:\n            get_logger().exception(f\"Failed to get labels, error: {e}\")\n            return []\n\n    def get_repo_labels(self):\n        labels = self.repo_obj.get_labels()\n        return [label for label in itertools.islice(labels, 50)]\n\n    def get_commit_messages(self):\n        \"\"\"\n        Retrieves the commit messages of a pull request.\n\n        Returns:\n            str: A string containing the commit messages of the pull request.\n        \"\"\"\n        max_tokens = get_settings().get(\"CONFIG.MAX_COMMITS_TOKENS\", None)\n        try:\n            commit_list = self.pr.get_commits()\n            commit_messages = [commit.commit.message for commit in commit_list]\n            commit_messages_str = \"\\n\".join([f\"{i + 1}. {message}\" for i, message in enumerate(commit_messages)])\n        except Exception:\n            commit_messages_str = \"\"\n        if max_tokens:\n            commit_messages_str = clip_tokens(commit_messages_str, max_tokens)\n        return commit_messages_str\n\n    def generate_link_to_relevant_line_number(self, suggestion) -> str:\n        try:\n            relevant_file = suggestion['relevant_file'].strip('`').strip(\"'\").strip('\\n')\n            relevant_line_str = suggestion['relevant_line'].strip('\\n')\n            if not relevant_line_str:\n                return \"\"\n\n            position, absolute_position = find_line_number_of_relevant_line_in_file \\\n                (self.diff_files, relevant_file, relevant_line_str)\n\n            if absolute_position != -1:\n                # # link to right file only\n                # link = f\"https://github.com/{self.repo}/blob/{self.pr.head.sha}/{relevant_file}\" \\\n                #        + \"#\" + f\"L{absolute_position}\"\n\n                # link to diff\n                sha_file = hashlib.sha256(relevant_file.encode('utf-8')).hexdigest()\n                link = f\"{self.base_url_html}/{self.repo}/pull/{self.pr_num}/files#diff-{sha_file}R{absolute_position}\"\n                return link\n        except Exception as e:\n            get_logger().info(f\"Failed adding line link, error: {e}\")\n\n        return \"\"\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        sha_file = hashlib.sha256(relevant_file.encode('utf-8')).hexdigest()\n        if relevant_line_start == -1:\n            link = f\"{self.base_url_html}/{self.repo}/pull/{self.pr_num}/files#diff-{sha_file}\"\n        elif relevant_line_end:\n            link = f\"{self.base_url_html}/{self.repo}/pull/{self.pr_num}/files#diff-{sha_file}R{relevant_line_start}-R{relevant_line_end}\"\n        else:\n            link = f\"{self.base_url_html}/{self.repo}/pull/{self.pr_num}/files#diff-{sha_file}R{relevant_line_start}\"\n        return link\n\n    def get_lines_link_original_file(self, filepath: str, component_range: Range) -> str:\n        \"\"\"\n        Returns the link to the original file on GitHub that corresponds to the given filepath and component range.\n\n        Args:\n            filepath (str): The path of the file.\n            component_range (Range): The range of lines that represent the component.\n\n        Returns:\n            str: The link to the original file on GitHub.\n\n        Example:\n            >>> filepath = \"path/to/file.py\"\n            >>> component_range = Range(line_start=10, line_end=20)\n            >>> link = get_lines_link_original_file(filepath, component_range)\n            >>> print(link)\n            \"https://github.com/{repo}/blob/{commit_sha}/{filepath}/#L11-L21\"\n        \"\"\"\n        line_start = component_range.line_start + 1\n        line_end = component_range.line_end + 1\n        # link = (f\"https://github.com/{self.repo}/blob/{self.last_commit_id.sha}/{filepath}/\"\n        #         f\"#L{line_start}-L{line_end}\")\n        link = (f\"{self.base_url_html}/{self.repo}/blob/{self.last_commit_id.sha}/{filepath}/\"\n                f\"#L{line_start}-L{line_end}\")\n\n        return link\n\n    def get_pr_id(self):\n        try:\n            pr_id = f\"{self.repo}/{self.pr_num}\"\n            return pr_id\n        except:\n            return \"\"\n\n    def fetch_sub_issues(self, issue_url):\n        \"\"\"\n        Fetch sub-issues linked to the given GitHub issue URL using GraphQL via PyGitHub.\n        \"\"\"\n        sub_issues = set()\n\n        # Extract owner, repo, and issue number from URL\n        parts = issue_url.rstrip(\"/\").split(\"/\")\n        owner, repo, issue_number = parts[-4], parts[-3], parts[-1]\n\n        try:\n            # Gets Issue ID from Issue Number\n            query = f\"\"\"\n            query {{\n                repository(owner: \"{owner}\", name: \"{repo}\") {{\n                    issue(number: {issue_number}) {{\n                        id\n                    }}\n                }}\n            }}\n            \"\"\"\n            response_tuple = self.github_client._Github__requester.requestJson(\"POST\", \"/graphql\",\n                                                                               input={\"query\": query})\n\n            # Extract the JSON response from the tuple and parses it\n            if isinstance(response_tuple, tuple) and len(response_tuple) == 3:\n                response_json = json.loads(response_tuple[2])\n            else:\n                get_logger().error(f\"Unexpected response format: {response_tuple}\")\n                return sub_issues\n\n\n            issue_id = response_json.get(\"data\", {}).get(\"repository\", {}).get(\"issue\", {}).get(\"id\")\n\n            if not issue_id:\n                get_logger().warning(f\"Issue ID not found for {issue_url}\")\n                return sub_issues\n\n            # Fetch Sub-Issues\n            sub_issues_query = f\"\"\"\n            query {{\n                node(id: \"{issue_id}\") {{\n                    ... on Issue {{\n                        subIssues(first: 10) {{\n                            nodes {{\n                                url\n                            }}\n                        }}\n                    }}\n                }}\n            }}\n            \"\"\"\n            sub_issues_response_tuple = self.github_client._Github__requester.requestJson(\"POST\", \"/graphql\", input={\n                \"query\": sub_issues_query})\n\n            # Extract the JSON response from the tuple and parses it\n            if isinstance(sub_issues_response_tuple, tuple) and len(sub_issues_response_tuple) == 3:\n                sub_issues_response_json = json.loads(sub_issues_response_tuple[2])\n            else:\n                get_logger().error(\"Unexpected sub-issues response format\", artifact={\"response\": sub_issues_response_tuple})\n                return sub_issues\n\n            if not sub_issues_response_json.get(\"data\", {}).get(\"node\", {}).get(\"subIssues\"):\n                get_logger().error(\"Invalid sub-issues response structure\")\n                return sub_issues\n    \n            nodes = sub_issues_response_json.get(\"data\", {}).get(\"node\", {}).get(\"subIssues\", {}).get(\"nodes\", [])\n            get_logger().info(f\"Github Sub-issues fetched: {len(nodes)}\", artifact={\"nodes\": nodes})\n\n            for sub_issue in nodes:\n                if \"url\" in sub_issue:\n                    sub_issues.add(sub_issue[\"url\"])\n\n        except Exception as e:\n            get_logger().exception(f\"Failed to fetch sub-issues. Error: {e}\")\n\n        return sub_issues\n\n    def auto_approve(self) -> bool:\n        try:\n            res = self.pr.create_review(event=\"APPROVE\")\n            if res.state == \"APPROVED\":\n                return True\n            return False\n        except Exception as e:\n            get_logger().exception(f\"Failed to auto-approve, error: {e}\")\n            return False\n\n    def calc_pr_statistics(self, pull_request_data: dict):\n            return {}\n\n    def validate_comments_inside_hunks(self, code_suggestions):\n        \"\"\"\n        validate that all committable comments are inside PR hunks - this is a must for committable comments in GitHub\n        \"\"\"\n        code_suggestions_copy = copy.deepcopy(code_suggestions)\n        diff_files = self.get_diff_files()\n        RE_HUNK_HEADER = re.compile(\n            r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n\n        diff_files = set_file_languages(diff_files)\n\n        for suggestion in code_suggestions_copy:\n            try:\n                relevant_file_path = suggestion['relevant_file']\n                for file in diff_files:\n                    if file.filename == relevant_file_path:\n\n                        # generate on-demand the patches range for the relevant file\n                        patch_str = file.patch\n                        if not hasattr(file, 'patches_range'):\n                            file.patches_range = []\n                            patch_lines = patch_str.splitlines()\n                            for i, line in enumerate(patch_lines):\n                                if line.startswith('@@'):\n                                    match = RE_HUNK_HEADER.match(line)\n                                    # identify hunk header\n                                    if match:\n                                        section_header, size1, size2, start1, start2 = extract_hunk_headers(match)\n                                        file.patches_range.append({'start': start2, 'end': start2 + size2 - 1})\n\n                        patches_range = file.patches_range\n                        comment_start_line = suggestion.get('relevant_lines_start', None)\n                        comment_end_line = suggestion.get('relevant_lines_end', None)\n                        original_suggestion = suggestion.get('original_suggestion', None) # needed for diff code\n                        if not comment_start_line or not comment_end_line or not original_suggestion:\n                            continue\n\n                        # check if the comment is inside a valid hunk\n                        is_valid_hunk = False\n                        min_distance = float('inf')\n                        patch_range_min = None\n                        # find the hunk that contains the comment, or the closest one\n                        for i, patch_range in enumerate(patches_range):\n                            d1 = comment_start_line - patch_range['start']\n                            d2 = patch_range['end'] - comment_end_line\n                            if d1 >= 0 and d2 >= 0:  # found a valid hunk\n                                is_valid_hunk = True\n                                min_distance = 0\n                                patch_range_min = patch_range\n                                break\n                            elif d1 * d2 <= 0:  # comment is possibly inside the hunk\n                                d1_clip = abs(min(0, d1))\n                                d2_clip = abs(min(0, d2))\n                                d = max(d1_clip, d2_clip)\n                                if d < min_distance:\n                                    patch_range_min = patch_range\n                                    min_distance = min(min_distance, d)\n                        if not is_valid_hunk:\n                            if min_distance < 10:  # 10 lines - a reasonable distance to consider the comment inside the hunk\n                                # make the suggestion non-committable, yet multi line\n                                suggestion['relevant_lines_start'] = max(suggestion['relevant_lines_start'], patch_range_min['start'])\n                                suggestion['relevant_lines_end'] = min(suggestion['relevant_lines_end'], patch_range_min['end'])\n                                body = suggestion['body'].strip()\n\n                                # present new diff code in collapsible\n                                existing_code = original_suggestion['existing_code'].rstrip() + \"\\n\"\n                                improved_code = original_suggestion['improved_code'].rstrip() + \"\\n\"\n                                diff = difflib.unified_diff(existing_code.split('\\n'),\n                                                            improved_code.split('\\n'), n=999)\n                                patch_orig = \"\\n\".join(diff)\n                                patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n                                diff_code = f\"\\n\\n<details><summary>New proposed code:</summary>\\n\\n```diff\\n{patch.rstrip()}\\n```\"\n                                # replace ```suggestion ... ``` with diff_code, using regex:\n                                body = re.sub(r'```suggestion.*?```', diff_code, body, flags=re.DOTALL)\n                                body += \"\\n\\n</details>\"\n                                suggestion['body'] = body\n                                get_logger().info(f\"Comment was moved to a valid hunk, \"\n                                                  f\"start_line={suggestion['relevant_lines_start']}, end_line={suggestion['relevant_lines_end']}, file={file.filename}\")\n                            else:\n                                get_logger().error(f\"Comment is not inside a valid hunk, \"\n                                                   f\"start_line={suggestion['relevant_lines_start']}, end_line={suggestion['relevant_lines_end']}, file={file.filename}\")\n            except Exception as e:\n                get_logger().error(f\"Failed to process patch for committable comment, error: {e}\")\n        return code_suggestions_copy\n\n"}
{"type": "source_file", "path": "pr_agent/algo/language_handler.py", "content": "# Language Selection, source: https://github.com/bigcode-project/bigcode-dataset/blob/main/language_selection/programming-languages-to-file-extensions.json  # noqa E501\nfrom typing import Dict\n\nfrom pr_agent.config_loader import get_settings\n\n\ndef filter_bad_extensions(files):\n    # Bad Extensions, source: https://github.com/EleutherAI/github-downloader/blob/345e7c4cbb9e0dc8a0615fd995a08bf9d73b3fe6/download_repo_text.py  # noqa: E501\n    bad_extensions = get_settings().bad_extensions.default\n    if get_settings().config.use_extra_bad_extensions:\n        bad_extensions += get_settings().bad_extensions.extra\n    return [f for f in files if f.filename is not None and is_valid_file(f.filename, bad_extensions)]\n\n\ndef is_valid_file(filename:str, bad_extensions=None) -> bool:\n    if not filename:\n        return False\n    if not bad_extensions:\n        bad_extensions = get_settings().bad_extensions.default\n        if get_settings().config.use_extra_bad_extensions:\n            bad_extensions += get_settings().bad_extensions.extra\n\n    auto_generated_files = ['package-lock.json', 'yarn.lock', 'composer.lock', 'Gemfile.lock', 'poetry.lock']\n    for forbidden_file in auto_generated_files:\n        if filename.endswith(forbidden_file):\n            return False\n\n    return filename.split('.')[-1] not in bad_extensions\n\n\ndef sort_files_by_main_languages(languages: Dict, files: list):\n    \"\"\"\n    Sort files by their main language, put the files that are in the main language first and the rest files after\n    \"\"\"\n    # sort languages by their size\n    languages_sorted_list = [k for k, v in sorted(languages.items(), key=lambda item: item[1], reverse=True)]\n    # languages_sorted = sorted(languages, key=lambda x: x[1], reverse=True)\n    # get all extensions for the languages\n    main_extensions = []\n    language_extension_map_org = get_settings().language_extension_map_org\n    language_extension_map = {k.lower(): v for k, v in language_extension_map_org.items()}\n    for language in languages_sorted_list:\n        if language.lower() in language_extension_map:\n            main_extensions.append(language_extension_map[language.lower()])\n        else:\n            main_extensions.append([])\n\n    # filter out files bad extensions\n    files_filtered = filter_bad_extensions(files)\n\n    # sort files by their extension, put the files that are in the main extension first\n    # and the rest files after, map languages_sorted to their respective files\n    files_sorted = []\n    rest_files = {}\n\n    # if no languages detected, put all files in the \"Other\" category\n    if not languages:\n        files_sorted = [({\"language\": \"Other\", \"files\": list(files_filtered)})]\n        return files_sorted\n\n    main_extensions_flat = []\n    for ext in main_extensions:\n        main_extensions_flat.extend(ext)\n\n    for extensions, lang in zip(main_extensions, languages_sorted_list):  # noqa: B905\n        tmp = []\n        for file in files_filtered:\n            extension_str = f\".{file.filename.split('.')[-1]}\"\n            if extension_str in extensions:\n                tmp.append(file)\n            else:\n                if (file.filename not in rest_files) and (extension_str not in main_extensions_flat):\n                    rest_files[file.filename] = file\n        if len(tmp) > 0:\n            files_sorted.append({\"language\": lang, \"files\": tmp})\n    files_sorted.append({\"language\": \"Other\", \"files\": list(rest_files.values())})\n    return files_sorted\n"}
{"type": "source_file", "path": "pr_agent/algo/ai_handlers/langchain_ai_handler.py", "content": "try:\n    from langchain_core.messages import HumanMessage, SystemMessage\n    from langchain_openai import AzureChatOpenAI, ChatOpenAI\nexcept:  # we don't enforce langchain as a dependency, so if it's not installed, just move on\n    pass\n\nimport functools\n\nfrom openai import APIError, RateLimitError, Timeout\nfrom retry import retry\n\nfrom pr_agent.algo.ai_handlers.base_ai_handler import BaseAiHandler\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.log import get_logger\n\nOPENAI_RETRIES = 5\n\n\nclass LangChainOpenAIHandler(BaseAiHandler):\n    def __init__(self):\n        # Initialize OpenAIHandler specific attributes here\n        super().__init__()\n        self.azure = get_settings().get(\"OPENAI.API_TYPE\", \"\").lower() == \"azure\"\n\n        # Create a default unused chat object to trigger early validation\n        self._create_chat(self.deployment_id)\n\n    def chat(self, messages: list, model: str, temperature: float):\n        chat = self._create_chat(self.deployment_id)\n        return chat.invoke(input=messages, model=model, temperature=temperature)\n\n    @property\n    def deployment_id(self):\n        \"\"\"\n        Returns the deployment ID for the OpenAI API.\n        \"\"\"\n        return get_settings().get(\"OPENAI.DEPLOYMENT_ID\", None)\n\n    @retry(exceptions=(APIError, Timeout, AttributeError, RateLimitError),\n           tries=OPENAI_RETRIES, delay=2, backoff=2, jitter=(1, 3))\n    async def chat_completion(self, model: str, system: str, user: str, temperature: float = 0.2):\n        try:\n            messages = [SystemMessage(content=system), HumanMessage(content=user)]\n\n            # get a chat completion from the formatted messages\n            resp = self.chat(messages, model=model, temperature=temperature)\n            finish_reason = \"completed\"\n            return resp.content, finish_reason\n\n        except (Exception) as e:\n            get_logger().error(\"Unknown error during OpenAI inference: \", e)\n            raise e\n\n    def _create_chat(self, deployment_id=None):\n        try:\n            if self.azure:\n                # using a partial function so we can set the deployment_id later to support fallback_deployments\n                # but still need to access the other settings now so we can raise a proper exception if they're missing\n                return AzureChatOpenAI(\n                    openai_api_key=get_settings().openai.key,\n                    openai_api_version=get_settings().openai.api_version,\n                    azure_deployment=deployment_id,\n                    azure_endpoint=get_settings().openai.api_base,\n                )\n            else:\n                # for llms that compatible with openai, should use custom api base\n                openai_api_base = get_settings().get(\"OPENAI.API_BASE\", None)\n                if openai_api_base is None or len(openai_api_base) == 0:\n                    return ChatOpenAI(openai_api_key=get_settings().openai.key)\n                else:\n                    return ChatOpenAI(openai_api_key=get_settings().openai.key, openai_api_base=openai_api_base)\n        except AttributeError as e:\n            if getattr(e, \"name\"):\n                raise ValueError(f\"OpenAI {e.name} is required\") from e\n            else:\n                raise e\n"}
{"type": "source_file", "path": "pr_agent/algo/git_patch_processing.py", "content": "from __future__ import annotations\n\nimport re\nimport traceback\n\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.log import get_logger\n\n\ndef extend_patch(original_file_str, patch_str, patch_extra_lines_before=0,\n                 patch_extra_lines_after=0, filename: str = \"\", new_file_str=\"\") -> str:\n    if not patch_str or (patch_extra_lines_before == 0 and patch_extra_lines_after == 0) or not original_file_str:\n        return patch_str\n\n    original_file_str = decode_if_bytes(original_file_str)\n    new_file_str = decode_if_bytes(new_file_str)\n    if not original_file_str:\n        return patch_str\n\n    if should_skip_patch(filename):\n        return patch_str\n\n    try:\n        extended_patch_str = process_patch_lines(patch_str, original_file_str,\n                                                 patch_extra_lines_before, patch_extra_lines_after, new_file_str)\n    except Exception as e:\n        get_logger().warning(f\"Failed to extend patch: {e}\", artifact={\"traceback\": traceback.format_exc()})\n        return patch_str\n\n    return extended_patch_str\n\n\ndef decode_if_bytes(original_file_str):\n    if isinstance(original_file_str, (bytes, bytearray)):\n        try:\n            return original_file_str.decode('utf-8')\n        except UnicodeDecodeError:\n            encodings_to_try = ['iso-8859-1', 'latin-1', 'ascii', 'utf-16']\n            for encoding in encodings_to_try:\n                try:\n                    return original_file_str.decode(encoding)\n                except UnicodeDecodeError:\n                    continue\n            return \"\"\n    return original_file_str\n\n\ndef should_skip_patch(filename):\n    patch_extension_skip_types = get_settings().config.patch_extension_skip_types\n    if patch_extension_skip_types and filename:\n        return any(filename.endswith(skip_type) for skip_type in patch_extension_skip_types)\n    return False\n\n\ndef process_patch_lines(patch_str, original_file_str, patch_extra_lines_before, patch_extra_lines_after, new_file_str=\"\"):\n    allow_dynamic_context = get_settings().config.allow_dynamic_context\n    patch_extra_lines_before_dynamic = get_settings().config.max_extra_lines_before_dynamic_context\n\n    file_original_lines = original_file_str.splitlines()\n    file_new_lines = new_file_str.splitlines() if new_file_str else []\n    len_original_lines = len(file_original_lines)\n    patch_lines = patch_str.splitlines()\n    extended_patch_lines = []\n\n    is_valid_hunk = True\n    start1, size1, start2, size2 = -1, -1, -1, -1\n    RE_HUNK_HEADER = re.compile(\n        r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n    try:\n        for i,line in enumerate(patch_lines):\n            if line.startswith('@@'):\n                match = RE_HUNK_HEADER.match(line)\n                # identify hunk header\n                if match:\n                    # finish processing previous hunk\n                    if is_valid_hunk and (start1 != -1 and patch_extra_lines_after > 0):\n                        delta_lines_original = [f' {line}' for line in file_original_lines[start1 + size1 - 1:start1 + size1 - 1 + patch_extra_lines_after]]\n                        extended_patch_lines.extend(delta_lines_original)\n\n                    section_header, size1, size2, start1, start2 = extract_hunk_headers(match)\n\n                    is_valid_hunk = check_if_hunk_lines_matches_to_file(i, file_original_lines, patch_lines, start1)\n\n                    if is_valid_hunk and (patch_extra_lines_before > 0 or patch_extra_lines_after > 0):\n                        def _calc_context_limits(patch_lines_before):\n                            extended_start1 = max(1, start1 - patch_lines_before)\n                            extended_size1 = size1 + (start1 - extended_start1) + patch_extra_lines_after\n                            extended_start2 = max(1, start2 - patch_lines_before)\n                            extended_size2 = size2 + (start2 - extended_start2) + patch_extra_lines_after\n                            if extended_start1 - 1 + extended_size1 > len_original_lines:\n                                # we cannot extend beyond the original file\n                                delta_cap = extended_start1 - 1 + extended_size1 - len_original_lines\n                                extended_size1 = max(extended_size1 - delta_cap, size1)\n                                extended_size2 = max(extended_size2 - delta_cap, size2)\n                            return extended_start1, extended_size1, extended_start2, extended_size2\n\n                        if allow_dynamic_context and file_new_lines:\n                            extended_start1, extended_size1, extended_start2, extended_size2 = \\\n                                _calc_context_limits(patch_extra_lines_before_dynamic)\n\n                            lines_before_original = file_original_lines[extended_start1 - 1:start1 - 1]\n                            lines_before_new = file_new_lines[extended_start2 - 1:start2 - 1]\n                            found_header = False\n                            if lines_before_original == lines_before_new: # Making sure no changes from a previous hunk\n                                for i, line, in enumerate(lines_before_original):\n                                    if section_header in line:\n                                        found_header = True\n                                        # Update start and size in one line each\n                                        extended_start1, extended_start2 = extended_start1 + i, extended_start2 + i\n                                        extended_size1, extended_size2 = extended_size1 - i, extended_size2 - i\n                                        # get_logger().debug(f\"Found section header in line {i} before the hunk\")\n                                        section_header = ''\n                                        break\n                            else:\n                                get_logger().debug(f\"Extra lines before hunk are different in original and new file - dynamic context\",\n                                                   artifact={\"lines_before_original\": lines_before_original,\n                                                             \"lines_before_new\": lines_before_new})\n\n                            if not found_header:\n                                # get_logger().debug(f\"Section header not found in the extra lines before the hunk\")\n                                extended_start1, extended_size1, extended_start2, extended_size2 = \\\n                                    _calc_context_limits(patch_extra_lines_before)\n                        else:\n                            extended_start1, extended_size1, extended_start2, extended_size2 = \\\n                                _calc_context_limits(patch_extra_lines_before)\n\n                        # check if extra lines before hunk are different in original and new file\n                        delta_lines_original = [f' {line}' for line in file_original_lines[extended_start1 - 1:start1 - 1]]\n                        if file_new_lines:\n                            delta_lines_new = [f' {line}' for line in file_new_lines[extended_start2 - 1:start2 - 1]]\n                            if delta_lines_original != delta_lines_new:\n                                get_logger().debug(f\"Extra lines before hunk are different in original and new file\",\n                                                   artifact={\"delta_lines_original\": delta_lines_original,\n                                                             \"delta_lines_new\": delta_lines_new})\n                                extended_start1 = start1\n                                extended_size1 = size1\n                                extended_start2 = start2\n                                extended_size2 = size2\n                                delta_lines_original = []\n\n                        #  logic to remove section header if its in the extra delta lines (in dynamic context, this is also done)\n                        if section_header and not allow_dynamic_context:\n                            for line in delta_lines_original:\n                                if section_header in line:\n                                    section_header = ''  # remove section header if it is in the extra delta lines\n                                    break\n                    else:\n                        extended_start1 = start1\n                        extended_size1 = size1\n                        extended_start2 = start2\n                        extended_size2 = size2\n                        delta_lines_original = []\n                    extended_patch_lines.append('')\n                    extended_patch_lines.append(\n                        f'@@ -{extended_start1},{extended_size1} '\n                        f'+{extended_start2},{extended_size2} @@ {section_header}')\n                    extended_patch_lines.extend(delta_lines_original)  # one to zero based\n                    continue\n            extended_patch_lines.append(line)\n    except Exception as e:\n        get_logger().warning(f\"Failed to extend patch: {e}\", artifact={\"traceback\": traceback.format_exc()})\n        return patch_str\n\n    # finish processing last hunk\n    if start1 != -1 and patch_extra_lines_after > 0 and is_valid_hunk:\n        delta_lines_original = file_original_lines[start1 + size1 - 1:start1 + size1 - 1 + patch_extra_lines_after]\n        # add space at the beginning of each extra line\n        delta_lines_original = [f' {line}' for line in delta_lines_original]\n        extended_patch_lines.extend(delta_lines_original)\n\n    extended_patch_str = '\\n'.join(extended_patch_lines)\n    return extended_patch_str\n\ndef check_if_hunk_lines_matches_to_file(i, original_lines, patch_lines, start1):\n    \"\"\"\n    Check if the hunk lines match the original file content. We saw cases where the hunk header line doesn't match the original file content, and then\n    extending the hunk with extra lines before the hunk header can cause the hunk to be invalid.\n    \"\"\"\n    is_valid_hunk = True\n    try:\n        if i + 1 < len(patch_lines) and patch_lines[i + 1][0] == ' ': # an existing line in the file\n            if patch_lines[i + 1].strip() != original_lines[start1 - 1].strip():\n                # check if different encoding is needed\n                original_line = original_lines[start1 - 1].strip()\n                for encoding in ['iso-8859-1', 'latin-1', 'ascii', 'utf-16']:\n                    try:\n                        if original_line.encode(encoding).decode().strip() == patch_lines[i + 1].strip():\n                            get_logger().info(f\"Detected different encoding in hunk header line {start1}, needed encoding: {encoding}\")\n                            return False # we still want to avoid extending the hunk. But we don't want to log an error\n                    except:\n                        pass\n\n                is_valid_hunk = False\n                get_logger().info(\n                    f\"Invalid hunk in PR, line {start1} in hunk header doesn't match the original file content\")\n    except:\n        pass\n    return is_valid_hunk\n\n\ndef extract_hunk_headers(match):\n    res = list(match.groups())\n    for i in range(len(res)):\n        if res[i] is None:\n            res[i] = 0\n    try:\n        start1, size1, start2, size2 = map(int, res[:4])\n    except:  # '@@ -0,0 +1 @@' case\n        start1, size1, size2 = map(int, res[:3])\n        start2 = 0\n    section_header = res[4]\n    return section_header, size1, size2, start1, start2\n\n\ndef omit_deletion_hunks(patch_lines) -> str:\n    \"\"\"\n    Omit deletion hunks from the patch and return the modified patch.\n    Args:\n    - patch_lines: a list of strings representing the lines of the patch\n    Returns:\n    - A string representing the modified patch with deletion hunks omitted\n    \"\"\"\n\n    temp_hunk = []\n    added_patched = []\n    add_hunk = False\n    inside_hunk = False\n    RE_HUNK_HEADER = re.compile(\n        r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))?\\ @@[ ]?(.*)\")\n\n    for line in patch_lines:\n        if line.startswith('@@'):\n            match = RE_HUNK_HEADER.match(line)\n            if match:\n                # finish previous hunk\n                if inside_hunk and add_hunk:\n                    added_patched.extend(temp_hunk)\n                    temp_hunk = []\n                    add_hunk = False\n                temp_hunk.append(line)\n                inside_hunk = True\n        else:\n            temp_hunk.append(line)\n            if line:\n                edit_type = line[0]\n                if edit_type == '+':\n                    add_hunk = True\n    if inside_hunk and add_hunk:\n        added_patched.extend(temp_hunk)\n\n    return '\\n'.join(added_patched)\n\n\ndef handle_patch_deletions(patch: str, original_file_content_str: str,\n                           new_file_content_str: str, file_name: str, edit_type: EDIT_TYPE = EDIT_TYPE.UNKNOWN) -> str:\n    \"\"\"\n    Handle entire file or deletion patches.\n\n    This function takes a patch, original file content, new file content, and file name as input.\n    It handles entire file or deletion patches and returns the modified patch with deletion hunks omitted.\n\n    Args:\n        patch (str): The patch to be handled.\n        original_file_content_str (str): The original content of the file.\n        new_file_content_str (str): The new content of the file.\n        file_name (str): The name of the file.\n\n    Returns:\n        str: The modified patch with deletion hunks omitted.\n\n    \"\"\"\n    if not new_file_content_str and (edit_type == EDIT_TYPE.DELETED or edit_type == EDIT_TYPE.UNKNOWN):\n        # logic for handling deleted files - don't show patch, just show that the file was deleted\n        if get_settings().config.verbosity_level > 0:\n            get_logger().info(f\"Processing file: {file_name}, minimizing deletion file\")\n        patch = None # file was deleted\n    else:\n        patch_lines = patch.splitlines()\n        patch_new = omit_deletion_hunks(patch_lines)\n        if patch != patch_new:\n            if get_settings().config.verbosity_level > 0:\n                get_logger().info(f\"Processing file: {file_name}, hunks were deleted\")\n            patch = patch_new\n    return patch\n\n\ndef decouple_and_convert_to_hunks_with_lines_numbers(patch: str, file) -> str:\n    \"\"\"\n    Convert a given patch string into a string with line numbers for each hunk, indicating the new and old content of\n    the file.\n\n    Args:\n        patch (str): The patch string to be converted.\n        file: An object containing the filename of the file being patched.\n\n    Returns:\n        str: A string with line numbers for each hunk, indicating the new and old content of the file.\n\n    example output:\n## src/file.ts\n__new hunk__\n881        line1\n882        line2\n883        line3\n887 +      line4\n888 +      line5\n889        line6\n890        line7\n...\n__old hunk__\n        line1\n        line2\n-       line3\n-       line4\n        line5\n        line6\n           ...\n    \"\"\"\n\n    # Add a header for the file\n    if file:\n        # if the file was deleted, return a message indicating that the file was deleted\n        if hasattr(file, 'edit_type') and file.edit_type == EDIT_TYPE.DELETED:\n            return f\"\\n\\n## File '{file.filename.strip()}' was deleted\\n\"\n\n        patch_with_lines_str = f\"\\n\\n## File: '{file.filename.strip()}'\\n\"\n    else:\n        patch_with_lines_str = \"\"\n\n    patch_lines = patch.splitlines()\n    RE_HUNK_HEADER = re.compile(\n        r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n    new_content_lines = []\n    old_content_lines = []\n    match = None\n    start1, size1, start2, size2 = -1, -1, -1, -1\n    prev_header_line = []\n    header_line = []\n    for line_i, line in enumerate(patch_lines):\n        if 'no newline at end of file' in line.lower():\n            continue\n\n        if line.startswith('@@'):\n            header_line = line\n            match = RE_HUNK_HEADER.match(line)\n            if match and (new_content_lines or old_content_lines):  # found a new hunk, split the previous lines\n                if prev_header_line:\n                    patch_with_lines_str += f'\\n{prev_header_line}\\n'\n                is_plus_lines = is_minus_lines = False\n                if new_content_lines:\n                    is_plus_lines = any([line.startswith('+') for line in new_content_lines])\n                if old_content_lines:\n                    is_minus_lines = any([line.startswith('-') for line in old_content_lines])\n                if is_plus_lines or is_minus_lines: # notice 'True' here - we always present __new hunk__ for section, otherwise LLM gets confused\n                    patch_with_lines_str = patch_with_lines_str.rstrip() + '\\n__new hunk__\\n'\n                    for i, line_new in enumerate(new_content_lines):\n                        patch_with_lines_str += f\"{start2 + i} {line_new}\\n\"\n                if is_minus_lines:\n                    patch_with_lines_str = patch_with_lines_str.rstrip() + '\\n__old hunk__\\n'\n                    for line_old in old_content_lines:\n                        patch_with_lines_str += f\"{line_old}\\n\"\n                new_content_lines = []\n                old_content_lines = []\n            if match:\n                prev_header_line = header_line\n\n            section_header, size1, size2, start1, start2 = extract_hunk_headers(match)\n\n        elif line.startswith('+'):\n            new_content_lines.append(line)\n        elif line.startswith('-'):\n            old_content_lines.append(line)\n        else:\n            if not line and line_i: # if this line is empty and the next line is a hunk header, skip it\n                if line_i + 1 < len(patch_lines) and patch_lines[line_i + 1].startswith('@@'):\n                    continue\n                elif line_i + 1 == len(patch_lines):\n                    continue\n            new_content_lines.append(line)\n            old_content_lines.append(line)\n\n    # finishing last hunk\n    if match and new_content_lines:\n        patch_with_lines_str += f'\\n{header_line}\\n'\n        is_plus_lines = is_minus_lines = False\n        if new_content_lines:\n            is_plus_lines = any([line.startswith('+') for line in new_content_lines])\n        if old_content_lines:\n            is_minus_lines = any([line.startswith('-') for line in old_content_lines])\n        if is_plus_lines or is_minus_lines:  # notice 'True' here - we always present __new hunk__ for section, otherwise LLM gets confused\n            patch_with_lines_str = patch_with_lines_str.rstrip() + '\\n__new hunk__\\n'\n            for i, line_new in enumerate(new_content_lines):\n                patch_with_lines_str += f\"{start2 + i} {line_new}\\n\"\n        if is_minus_lines:\n            patch_with_lines_str = patch_with_lines_str.rstrip() + '\\n__old hunk__\\n'\n            for line_old in old_content_lines:\n                patch_with_lines_str += f\"{line_old}\\n\"\n\n    return patch_with_lines_str.rstrip()\n\n\ndef extract_hunk_lines_from_patch(patch: str, file_name, line_start, line_end, side, remove_trailing_chars: bool = True) -> tuple[str, str]:\n    try:\n        patch_with_lines_str = f\"\\n\\n## File: '{file_name.strip()}'\\n\\n\"\n        selected_lines = \"\"\n        patch_lines = patch.splitlines()\n        RE_HUNK_HEADER = re.compile(\n            r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n        match = None\n        start1, size1, start2, size2 = -1, -1, -1, -1\n        skip_hunk = False\n        selected_lines_num = 0\n        for line in patch_lines:\n            if 'no newline at end of file' in line.lower():\n                continue\n\n            if line.startswith('@@'):\n                skip_hunk = False\n                selected_lines_num = 0\n                header_line = line\n\n                match = RE_HUNK_HEADER.match(line)\n\n                section_header, size1, size2, start1, start2 = extract_hunk_headers(match)\n\n                # check if line range is in this hunk\n                if side.lower() == 'left':\n                    # check if line range is in this hunk\n                    if not (start1 <= line_start <= start1 + size1):\n                        skip_hunk = True\n                        continue\n                elif side.lower() == 'right':\n                    if not (start2 <= line_start <= start2 + size2):\n                        skip_hunk = True\n                        continue\n                patch_with_lines_str += f'\\n{header_line}\\n'\n\n            elif not skip_hunk:\n                if side.lower() == 'right' and line_start <= start2 + selected_lines_num <= line_end:\n                    selected_lines += line + '\\n'\n                if side.lower() == 'left' and start1 <= selected_lines_num + start1 <= line_end:\n                    selected_lines += line + '\\n'\n                patch_with_lines_str += line + '\\n'\n                if not line.startswith('-'): # currently we don't support /ask line for deleted lines\n                    selected_lines_num += 1\n    except Exception as e:\n        get_logger().error(f\"Failed to extract hunk lines from patch: {e}\", artifact={\"traceback\": traceback.format_exc()})\n        return \"\", \"\"\n\n    if remove_trailing_chars:\n        patch_with_lines_str = patch_with_lines_str.rstrip()\n        selected_lines = selected_lines.rstrip()\n\n    return patch_with_lines_str, selected_lines\n"}
{"type": "source_file", "path": "pr_agent/algo/ai_handlers/openai_ai_handler.py", "content": "from os import environ\nfrom pr_agent.algo.ai_handlers.base_ai_handler import BaseAiHandler\nimport openai\nfrom openai import APIError, AsyncOpenAI, RateLimitError, Timeout\nfrom retry import retry\n\nfrom pr_agent.algo.ai_handlers.base_ai_handler import BaseAiHandler\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.log import get_logger\n\nOPENAI_RETRIES = 5\n\n\nclass OpenAIHandler(BaseAiHandler):\n    def __init__(self):\n        # Initialize OpenAIHandler specific attributes here\n        try:\n            super().__init__()\n            environ[\"OPENAI_API_KEY\"] = get_settings().openai.key\n            if get_settings().get(\"OPENAI.ORG\", None):\n                openai.organization = get_settings().openai.org\n            if get_settings().get(\"OPENAI.API_TYPE\", None):\n                if get_settings().openai.api_type == \"azure\":\n                    self.azure = True\n                    openai.azure_key = get_settings().openai.key\n            if get_settings().get(\"OPENAI.API_VERSION\", None):\n                openai.api_version = get_settings().openai.api_version\n            if get_settings().get(\"OPENAI.API_BASE\", None):\n                environ[\"OPENAI_BASE_URL\"] = get_settings().openai.api_base\n\n        except AttributeError as e:\n            raise ValueError(\"OpenAI key is required\") from e\n\n    @property\n    def deployment_id(self):\n        \"\"\"\n        Returns the deployment ID for the OpenAI API.\n        \"\"\"\n        return get_settings().get(\"OPENAI.DEPLOYMENT_ID\", None)\n\n    @retry(exceptions=(APIError, Timeout, AttributeError, RateLimitError),\n           tries=OPENAI_RETRIES, delay=2, backoff=2, jitter=(1, 3))\n    async def chat_completion(self, model: str, system: str, user: str, temperature: float = 0.2):\n        try:\n            get_logger().info(\"System: \", system)\n            get_logger().info(\"User: \", user)\n            messages = [{\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\": user}]\n            client = AsyncOpenAI()\n            chat_completion = await client.chat.completions.create(\n                model=model,\n                messages=messages,\n                temperature=temperature,\n            )\n            resp = chat_completion.choices[0].message.content\n            finish_reason = chat_completion.choices[0].finish_reason\n            usage = chat_completion.usage\n            get_logger().info(\"AI response\", response=resp, messages=messages, finish_reason=finish_reason,\n                              model=model, usage=usage)\n            return resp, finish_reason\n        except (APIError, Timeout) as e:\n            get_logger().error(\"Error during OpenAI inference: \", e)\n            raise\n        except (RateLimitError) as e:\n            get_logger().error(\"Rate limit error during OpenAI inference: \", e)\n            raise\n        except (Exception) as e:\n            get_logger().error(\"Unknown error during OpenAI inference: \", e)\n            raise\n"}
{"type": "source_file", "path": "pr_agent/git_providers/__init__.py", "content": "from starlette_context import context\n\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers.azuredevops_provider import AzureDevopsProvider\nfrom pr_agent.git_providers.bitbucket_provider import BitbucketProvider\nfrom pr_agent.git_providers.bitbucket_server_provider import \\\n    BitbucketServerProvider\nfrom pr_agent.git_providers.codecommit_provider import CodeCommitProvider\nfrom pr_agent.git_providers.gerrit_provider import GerritProvider\nfrom pr_agent.git_providers.git_provider import GitProvider\nfrom pr_agent.git_providers.github_provider import GithubProvider\nfrom pr_agent.git_providers.gitlab_provider import GitLabProvider\nfrom pr_agent.git_providers.local_git_provider import LocalGitProvider\n\n_GIT_PROVIDERS = {\n    'github': GithubProvider,\n    'gitlab': GitLabProvider,\n    'bitbucket': BitbucketProvider,\n    'bitbucket_server': BitbucketServerProvider,\n    'azure': AzureDevopsProvider,\n    'codecommit': CodeCommitProvider,\n    'local': LocalGitProvider,\n    'gerrit': GerritProvider,\n}\n\n\ndef get_git_provider():\n    try:\n        provider_id = get_settings().config.git_provider\n    except AttributeError as e:\n        raise ValueError(\"git_provider is a required attribute in the configuration file\") from e\n    if provider_id not in _GIT_PROVIDERS:\n        raise ValueError(f\"Unknown git provider: {provider_id}\")\n    return _GIT_PROVIDERS[provider_id]\n\n\ndef get_git_provider_with_context(pr_url) -> GitProvider:\n    \"\"\"\n    Get a GitProvider instance for the given PR URL. If the GitProvider instance is already in the context, return it.\n    \"\"\"\n\n    is_context_env = None\n    try:\n        is_context_env = context.get(\"settings\", None)\n    except Exception:\n        pass  # we are not in a context environment (CLI)\n\n    # check if context[\"git_provider\"][\"pr_url\"] exists\n    if is_context_env and context.get(\"git_provider\", {}).get(\"pr_url\", {}):\n        git_provider = context[\"git_provider\"][\"pr_url\"]\n        # possibly check if the git_provider is still valid, or if some reset is needed\n        # ...\n        return git_provider\n    else:\n        try:\n            provider_id = get_settings().config.git_provider\n            if provider_id not in _GIT_PROVIDERS:\n                raise ValueError(f\"Unknown git provider: {provider_id}\")\n            git_provider = _GIT_PROVIDERS[provider_id](pr_url)\n            if is_context_env:\n                context[\"git_provider\"] = {pr_url: git_provider}\n            return git_provider\n        except Exception as e:\n            raise ValueError(f\"Failed to get git provider for {pr_url}\") from e\n"}
{"type": "source_file", "path": "pr_agent/algo/utils.py", "content": "from __future__ import annotations\n\nimport copy\nimport difflib\nimport hashlib\nimport html\nimport json\nimport os\nimport re\nimport sys\nimport textwrap\nimport time\nimport traceback\nfrom datetime import datetime\nfrom enum import Enum\nfrom importlib.metadata import PackageNotFoundError, version\nfrom typing import Any, List, Tuple\n\nimport html2text\nimport requests\nimport yaml\nfrom pydantic import BaseModel\nfrom starlette_context import context\n\nfrom pr_agent.algo import MAX_TOKENS\nfrom pr_agent.algo.git_patch_processing import extract_hunk_lines_from_patch\nfrom pr_agent.algo.token_handler import TokenEncoder\nfrom pr_agent.algo.types import FilePatchInfo\nfrom pr_agent.config_loader import get_settings, global_settings\nfrom pr_agent.log import get_logger\n\n\ndef get_weak_model() -> str:\n    if get_settings().get(\"config.model_weak\"):\n        return get_settings().config.model_weak\n    return get_settings().config.model\n\n\nclass Range(BaseModel):\n    line_start: int  # should be 0-indexed\n    line_end: int\n    column_start: int = -1\n    column_end: int = -1\n\nclass ModelType(str, Enum):\n    REGULAR = \"regular\"\n    WEAK = \"weak\"\n\nclass PRReviewHeader(str, Enum):\n    REGULAR = \"## PR Reviewer Guide\"\n    INCREMENTAL = \"## Incremental PR Reviewer Guide\"\n\nclass ReasoningEffort(str, Enum):\n    HIGH = \"high\"\n    MEDIUM = \"medium\"\n    LOW = \"low\"\n\n\nclass PRDescriptionHeader(str, Enum):\n    CHANGES_WALKTHROUGH = \"### **Changes walkthrough** üìù\"\n\n\ndef get_setting(key: str) -> Any:\n    try:\n        key = key.upper()\n        return context.get(\"settings\", global_settings).get(key, global_settings.get(key, None))\n    except Exception:\n        return global_settings.get(key, None)\n\n\ndef emphasize_header(text: str, only_markdown=False, reference_link=None) -> str:\n    try:\n        # Finding the position of the first occurrence of \": \"\n        colon_position = text.find(\": \")\n\n        # Splitting the string and wrapping the first part in <strong> tags\n        if colon_position != -1:\n            # Everything before the colon (inclusive) is wrapped in <strong> tags\n            if only_markdown:\n                if reference_link:\n                    transformed_string = f\"[**{text[:colon_position + 1]}**]({reference_link})\\n\" + text[colon_position + 1:]\n                else:\n                    transformed_string = f\"**{text[:colon_position + 1]}**\\n\" + text[colon_position + 1:]\n            else:\n                if reference_link:\n                    transformed_string = f\"<strong><a href='{reference_link}'>{text[:colon_position + 1]}</a></strong><br>\" + text[colon_position + 1:]\n                else:\n                    transformed_string = \"<strong>\" + text[:colon_position + 1] + \"</strong>\" +'<br>' + text[colon_position + 1:]\n        else:\n            # If there's no \": \", return the original string\n            transformed_string = text\n\n        return transformed_string\n    except Exception as e:\n        get_logger().exception(f\"Failed to emphasize header: {e}\")\n        return text\n\n\ndef unique_strings(input_list: List[str]) -> List[str]:\n    if not input_list or not isinstance(input_list, list):\n        return input_list\n    seen = set()\n    unique_list = []\n    for item in input_list:\n        if item not in seen:\n            unique_list.append(item)\n            seen.add(item)\n    return unique_list\n\ndef convert_to_markdown_v2(output_data: dict,\n                           gfm_supported: bool = True,\n                           incremental_review=None,\n                           git_provider=None,\n                           files=None) -> str:\n    \"\"\"\n    Convert a dictionary of data into markdown format.\n    Args:\n        output_data (dict): A dictionary containing data to be converted to markdown format.\n    Returns:\n        str: The markdown formatted text generated from the input dictionary.\n    \"\"\"\n\n    emojis = {\n        \"Can be split\": \"üîÄ\",\n        \"Key issues to review\": \"‚ö°\",\n        \"Recommended focus areas for review\": \"‚ö°\",\n        \"Score\": \"üèÖ\",\n        \"Relevant tests\": \"üß™\",\n        \"Focused PR\": \"‚ú®\",\n        \"Relevant ticket\": \"üé´\",\n        \"Security concerns\": \"üîí\",\n        \"Insights from user's answers\": \"üìù\",\n        \"Code feedback\": \"ü§ñ\",\n        \"Estimated effort to review [1-5]\": \"‚è±Ô∏è\",\n        \"Ticket compliance check\": \"üé´\",\n    }\n    markdown_text = \"\"\n    if not incremental_review:\n        markdown_text += f\"{PRReviewHeader.REGULAR.value} üîç\\n\\n\"\n    else:\n        markdown_text += f\"{PRReviewHeader.INCREMENTAL.value} üîç\\n\\n\"\n        markdown_text += f\"‚èÆÔ∏è Review for commits since previous PR-Agent review {incremental_review}.\\n\\n\"\n    if not output_data or not output_data.get('review', {}):\n        return \"\"\n\n    if get_settings().get(\"pr_reviewer.enable_intro_text\", False):\n        markdown_text += f\"Here are some key observations to aid the review process:\\n\\n\"\n\n    if gfm_supported:\n        markdown_text += \"<table>\\n\"\n\n    for key, value in output_data['review'].items():\n        if value is None or value == '' or value == {} or value == []:\n            if key.lower() not in ['can_be_split', 'key_issues_to_review']:\n                continue\n        key_nice = key.replace('_', ' ').capitalize()\n        emoji = emojis.get(key_nice, \"\")\n        if 'Estimated effort to review' in key_nice:\n            key_nice = 'Estimated effort to review'\n            value = str(value).strip()\n            if value.isnumeric():\n                value_int = int(value)\n            else:\n                try:\n                    value_int = int(value.split(',')[0])\n                except ValueError:\n                    continue\n            blue_bars = 'üîµ' * value_int\n            white_bars = '‚ö™' * (5 - value_int)\n            value = f\"{value_int} {blue_bars}{white_bars}\"\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                markdown_text += f\"{emoji}&nbsp;<strong>{key_nice}</strong>: {value}\"\n                markdown_text += f\"</td></tr>\\n\"\n            else:\n                markdown_text += f\"### {emoji} {key_nice}: {value}\\n\\n\"\n        elif 'relevant tests' in key_nice.lower():\n            value = str(value).strip().lower()\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                if is_value_no(value):\n                    markdown_text += f\"{emoji}&nbsp;<strong>No relevant tests</strong>\"\n                else:\n                    markdown_text += f\"{emoji}&nbsp;<strong>PR contains tests</strong>\"\n                markdown_text += f\"</td></tr>\\n\"\n            else:\n                if is_value_no(value):\n                    markdown_text += f'### {emoji} No relevant tests\\n\\n'\n                else:\n                    markdown_text += f\"### {emoji} PR contains tests\\n\\n\"\n        elif 'ticket compliance check' in key_nice.lower():\n            markdown_text = ticket_markdown_logic(emoji, markdown_text, value, gfm_supported)\n        elif 'security concerns' in key_nice.lower():\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                if is_value_no(value):\n                    markdown_text += f\"{emoji}&nbsp;<strong>No security concerns identified</strong>\"\n                else:\n                    markdown_text += f\"{emoji}&nbsp;<strong>Security concerns</strong><br><br>\\n\\n\"\n                    value = emphasize_header(value.strip())\n                    markdown_text += f\"{value}\"\n                markdown_text += f\"</td></tr>\\n\"\n            else:\n                if is_value_no(value):\n                    markdown_text += f'### {emoji} No security concerns identified\\n\\n'\n                else:\n                    markdown_text += f\"### {emoji} Security concerns\\n\\n\"\n                    value = emphasize_header(value.strip(), only_markdown=True)\n                    markdown_text += f\"{value}\\n\\n\"\n        elif 'can be split' in key_nice.lower():\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                markdown_text += process_can_be_split(emoji, value)\n                markdown_text += f\"</td></tr>\\n\"\n        elif 'key issues to review' in key_nice.lower():\n            # value is a list of issues\n            if is_value_no(value):\n                if gfm_supported:\n                    markdown_text += f\"<tr><td>\"\n                    markdown_text += f\"{emoji}&nbsp;<strong>No major issues detected</strong>\"\n                    markdown_text += f\"</td></tr>\\n\"\n                else:\n                    markdown_text += f\"### {emoji} No major issues detected\\n\\n\"\n            else:\n                issues = value\n                if gfm_supported:\n                    markdown_text += f\"<tr><td>\"\n                    # markdown_text += f\"{emoji}&nbsp;<strong>{key_nice}</strong><br><br>\\n\\n\"\n                    markdown_text += f\"{emoji}&nbsp;<strong>Recommended focus areas for review</strong><br><br>\\n\\n\"\n                else:\n                    markdown_text += f\"### {emoji} Recommended focus areas for review\\n\\n#### \\n\"\n                for i, issue in enumerate(issues):\n                    try:\n                        if not issue or not isinstance(issue, dict):\n                            continue\n                        relevant_file = issue.get('relevant_file', '').strip()\n                        issue_header = issue.get('issue_header', '').strip()\n                        if issue_header.lower() == 'possible bug':\n                            issue_header = 'Possible Issue'  # Make the header less frightening\n                        issue_content = issue.get('issue_content', '').strip()\n                        start_line = int(str(issue.get('start_line', 0)).strip())\n                        end_line = int(str(issue.get('end_line', 0)).strip())\n\n                        relevant_lines_str = extract_relevant_lines_str(end_line, files, relevant_file, start_line, dedent=True)\n                        if git_provider:\n                            reference_link = git_provider.get_line_link(relevant_file, start_line, end_line)\n                        else:\n                            reference_link = None\n\n                        if gfm_supported:\n                            if reference_link is not None and len(reference_link) > 0:\n                                if relevant_lines_str:\n                                    issue_str = f\"<details><summary><a href='{reference_link}'><strong>{issue_header}</strong></a>\\n\\n{issue_content}\\n</summary>\\n\\n{relevant_lines_str}\\n\\n</details>\"\n                                else:\n                                    issue_str = f\"<a href='{reference_link}'><strong>{issue_header}</strong></a><br>{issue_content}\"\n                            else:\n                                issue_str = f\"<strong>{issue_header}</strong><br>{issue_content}\"\n                        else:\n                            if reference_link is not None and len(reference_link) > 0:\n                                issue_str = f\"[**{issue_header}**]({reference_link})\\n\\n{issue_content}\\n\\n\"\n                            else:\n                                issue_str = f\"**{issue_header}**\\n\\n{issue_content}\\n\\n\"\n                        markdown_text += f\"{issue_str}\\n\\n\"\n                    except Exception as e:\n                        get_logger().exception(f\"Failed to process 'Recommended focus areas for review': {e}\")\n                if gfm_supported:\n                    markdown_text += f\"</td></tr>\\n\"\n        else:\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                markdown_text += f\"{emoji}&nbsp;<strong>{key_nice}</strong>: {value}\"\n                markdown_text += f\"</td></tr>\\n\"\n            else:\n                markdown_text += f\"### {emoji} {key_nice}: {value}\\n\\n\"\n\n    if gfm_supported:\n        markdown_text += \"</table>\\n\"\n\n    return markdown_text\n\n\ndef extract_relevant_lines_str(end_line, files, relevant_file, start_line, dedent=False) -> str:\n    \"\"\"\n    Finds 'relevant_file' in 'files', and extracts the lines from 'start_line' to 'end_line' string from the file content.\n    \"\"\"\n    try:\n        relevant_lines_str = \"\"\n        if files:\n            files = set_file_languages(files)\n            for file in files:\n                if file.filename.strip() == relevant_file:\n                    if not file.head_file:\n                        # as a fallback, extract relevant lines directly from patch\n                        patch = file.patch\n                        get_logger().info(f\"No content found in file: '{file.filename}' for 'extract_relevant_lines_str'. Using patch instead\")\n                        _, selected_lines = extract_hunk_lines_from_patch(patch, file.filename, start_line, end_line,side='right')\n                        if not selected_lines:\n                            get_logger().error(f\"Failed to extract relevant lines from patch: {file.filename}\")\n                            return \"\"\n                        # filter out '-' lines\n                        relevant_lines_str = \"\"\n                        for line in selected_lines.splitlines():\n                            if line.startswith('-'):\n                                continue\n                            relevant_lines_str += line[1:] + '\\n'\n                    else:\n                        relevant_file_lines = file.head_file.splitlines()\n                        relevant_lines_str = \"\\n\".join(relevant_file_lines[start_line - 1:end_line])\n\n                    if dedent and relevant_lines_str:\n                        # Remove the longest leading string of spaces and tabs common to all lines.\n                        relevant_lines_str = textwrap.dedent(relevant_lines_str)\n                    relevant_lines_str = f\"```{file.language}\\n{relevant_lines_str}\\n```\"\n                    break\n\n        return relevant_lines_str\n    except Exception as e:\n        get_logger().exception(f\"Failed to extract relevant lines: {e}\")\n        return \"\"\n\n\ndef ticket_markdown_logic(emoji, markdown_text, value, gfm_supported) -> str:\n    ticket_compliance_str = \"\"\n    compliance_emoji = ''\n    # Track compliance levels across all tickets\n    all_compliance_levels = []\n\n    if isinstance(value, list):\n        for ticket_analysis in value:\n            try:\n                ticket_url = ticket_analysis.get('ticket_url', '').strip()\n                explanation = ''\n                ticket_compliance_level = ''  # Individual ticket compliance\n                fully_compliant_str = ticket_analysis.get('fully_compliant_requirements', '').strip()\n                not_compliant_str = ticket_analysis.get('not_compliant_requirements', '').strip()\n                requires_further_human_verification = ticket_analysis.get('requires_further_human_verification',\n                                                                          '').strip()\n\n                if not fully_compliant_str and not not_compliant_str:\n                    get_logger().debug(f\"Ticket compliance has no requirements\",\n                                       artifact={'ticket_url': ticket_url})\n                    continue\n\n                # Calculate individual ticket compliance level\n                if fully_compliant_str:\n                    if not_compliant_str:\n                        ticket_compliance_level = 'Partially compliant'\n                    else:\n                        if not requires_further_human_verification:\n                            ticket_compliance_level = 'Fully compliant'\n                        else:\n                            ticket_compliance_level = 'PR Code Verified'\n                elif not_compliant_str:\n                    ticket_compliance_level = 'Not compliant'\n\n                # Store the compliance level for aggregation\n                if ticket_compliance_level:\n                    all_compliance_levels.append(ticket_compliance_level)\n\n                # build compliance string\n                if fully_compliant_str:\n                    explanation += f\"Compliant requirements:\\n\\n{fully_compliant_str}\\n\\n\"\n                if not_compliant_str:\n                    explanation += f\"Non-compliant requirements:\\n\\n{not_compliant_str}\\n\\n\"\n                if requires_further_human_verification:\n                    explanation += f\"Requires further human verification:\\n\\n{requires_further_human_verification}\\n\\n\"\n                ticket_compliance_str += f\"\\n\\n**[{ticket_url.split('/')[-1]}]({ticket_url}) - {ticket_compliance_level}**\\n\\n{explanation}\\n\\n\"\n\n                # for debugging\n                if requires_further_human_verification:\n                    get_logger().debug(f\"Ticket compliance requires further human verification\",\n                                       artifact={'ticket_url': ticket_url,\n                                                 'requires_further_human_verification': requires_further_human_verification,\n                                                 'compliance_level': ticket_compliance_level})\n\n            except Exception as e:\n                get_logger().exception(f\"Failed to process ticket compliance: {e}\")\n                continue\n\n        # Calculate overall compliance level and emoji\n        if all_compliance_levels:\n            if all(level == 'Fully compliant' for level in all_compliance_levels):\n                compliance_level = 'Fully compliant'\n                compliance_emoji = '‚úÖ'\n            elif all(level == 'PR Code Verified' for level in all_compliance_levels):\n                compliance_level = 'PR Code Verified'\n                compliance_emoji = '‚úÖ'\n            elif any(level == 'Not compliant' for level in all_compliance_levels):\n                # If there's a mix of compliant and non-compliant tickets\n                if any(level in ['Fully compliant', 'PR Code Verified'] for level in all_compliance_levels):\n                    compliance_level = 'Partially compliant'\n                    compliance_emoji = 'üî∂'\n                else:\n                    compliance_level = 'Not compliant'\n                    compliance_emoji = '‚ùå'\n            elif any(level == 'Partially compliant' for level in all_compliance_levels):\n                compliance_level = 'Partially compliant'\n                compliance_emoji = 'üî∂'\n            else:\n                compliance_level = 'PR Code Verified'\n                compliance_emoji = '‚úÖ'\n\n            # Set extra statistics outside the ticket loop\n            get_settings().set('config.extra_statistics', {'compliance_level': compliance_level})\n\n        # editing table row for ticket compliance analysis\n        if gfm_supported:\n            markdown_text += f\"<tr><td>\\n\\n\"\n            markdown_text += f\"**{emoji} Ticket compliance analysis {compliance_emoji}**\\n\\n\"\n            markdown_text += ticket_compliance_str\n            markdown_text += f\"</td></tr>\\n\"\n        else:\n            markdown_text += f\"### {emoji} Ticket compliance analysis {compliance_emoji}\\n\\n\"\n            markdown_text += ticket_compliance_str + \"\\n\\n\"\n\n    return markdown_text\n\n\ndef process_can_be_split(emoji, value):\n    try:\n        # key_nice = \"Can this PR be split?\"\n        key_nice = \"Multiple PR themes\"\n        markdown_text = \"\"\n        if not value or isinstance(value, list) and len(value) == 1:\n            value = \"No\"\n            # markdown_text += f\"<tr><td> {emoji}&nbsp;<strong>{key_nice}</strong></td><td>\\n\\n{value}\\n\\n</td></tr>\\n\"\n            # markdown_text += f\"### {emoji} No multiple PR themes\\n\\n\"\n            markdown_text += f\"{emoji} <strong>No multiple PR themes</strong>\\n\\n\"\n        else:\n            markdown_text += f\"{emoji} <strong>{key_nice}</strong><br><br>\\n\\n\"\n            for i, split in enumerate(value):\n                title = split.get('title', '')\n                relevant_files = split.get('relevant_files', [])\n                markdown_text += f\"<details><summary>\\nSub-PR theme: <b>{title}</b></summary>\\n\\n\"\n                markdown_text += f\"___\\n\\nRelevant files:\\n\\n\"\n                for file in relevant_files:\n                    markdown_text += f\"- {file}\\n\"\n                markdown_text += f\"___\\n\\n\"\n                markdown_text += f\"</details>\\n\\n\"\n\n                # markdown_text += f\"#### Sub-PR theme: {title}\\n\\n\"\n                # markdown_text += f\"Relevant files:\\n\\n\"\n                # for file in relevant_files:\n                #     markdown_text += f\"- {file}\\n\"\n                # markdown_text += \"\\n\"\n            # number_of_splits = len(value)\n            # markdown_text += f\"<tr><td rowspan={number_of_splits}> {emoji}&nbsp;<strong>{key_nice}</strong></td>\\n\"\n            # for i, split in enumerate(value):\n            #     title = split.get('title', '')\n            #     relevant_files = split.get('relevant_files', [])\n            #     if i == 0:\n            #         markdown_text += f\"<td><details><summary>\\nSub-PR theme:<br><strong>{title}</strong></summary>\\n\\n\"\n            #         markdown_text += f\"<hr>\\n\"\n            #         markdown_text += f\"Relevant files:\\n\"\n            #         markdown_text += f\"<ul>\\n\"\n            #         for file in relevant_files:\n            #             markdown_text += f\"<li>{file}</li>\\n\"\n            #         markdown_text += f\"</ul>\\n\\n</details></td></tr>\\n\"\n            #     else:\n            #         markdown_text += f\"<tr>\\n<td><details><summary>\\nSub-PR theme:<br><strong>{title}</strong></summary>\\n\\n\"\n            #         markdown_text += f\"<hr>\\n\"\n            #         markdown_text += f\"Relevant files:\\n\"\n            #         markdown_text += f\"<ul>\\n\"\n            #         for file in relevant_files:\n            #             markdown_text += f\"<li>{file}</li>\\n\"\n            #         markdown_text += f\"</ul>\\n\\n</details></td></tr>\\n\"\n    except Exception as e:\n        get_logger().exception(f\"Failed to process can be split: {e}\")\n        return \"\"\n    return markdown_text\n\n\ndef parse_code_suggestion(code_suggestion: dict, i: int = 0, gfm_supported: bool = True) -> str:\n    \"\"\"\n    Convert a dictionary of data into markdown format.\n\n    Args:\n        code_suggestion (dict): A dictionary containing data to be converted to markdown format.\n\n    Returns:\n        str: A string containing the markdown formatted text generated from the input dictionary.\n    \"\"\"\n    markdown_text = \"\"\n    if gfm_supported and 'relevant_line' in code_suggestion:\n        markdown_text += '<table>'\n        for sub_key, sub_value in code_suggestion.items():\n            try:\n                if sub_key.lower() == 'relevant_file':\n                    relevant_file = sub_value.strip('`').strip('\"').strip(\"'\")\n                    markdown_text += f\"<tr><td>relevant file</td><td>{relevant_file}</td></tr>\"\n                    # continue\n                elif sub_key.lower() == 'suggestion':\n                    markdown_text += (f\"<tr><td>{sub_key} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\"\n                                      f\"<td>\\n\\n<strong>\\n\\n{sub_value.strip()}\\n\\n</strong>\\n</td></tr>\")\n                elif sub_key.lower() == 'relevant_line':\n                    markdown_text += f\"<tr><td>relevant line</td>\"\n                    sub_value_list = sub_value.split('](')\n                    relevant_line = sub_value_list[0].lstrip('`').lstrip('[')\n                    if len(sub_value_list) > 1:\n                        link = sub_value_list[1].rstrip(')').strip('`')\n                        markdown_text += f\"<td><a href='{link}'>{relevant_line}</a></td>\"\n                    else:\n                        markdown_text += f\"<td>{relevant_line}</td>\"\n                    markdown_text += \"</tr>\"\n            except Exception as e:\n                get_logger().exception(f\"Failed to parse code suggestion: {e}\")\n                pass\n        markdown_text += '</table>'\n        markdown_text += \"<hr>\"\n    else:\n        for sub_key, sub_value in code_suggestion.items():\n            if isinstance(sub_key, str):\n                sub_key = sub_key.rstrip()\n            if isinstance(sub_value,str):\n                sub_value = sub_value.rstrip()\n            if isinstance(sub_value, dict):  # \"code example\"\n                markdown_text += f\"  - **{sub_key}:**\\n\"\n                for code_key, code_value in sub_value.items():  # 'before' and 'after' code\n                    code_str = f\"```\\n{code_value}\\n```\"\n                    code_str_indented = textwrap.indent(code_str, '        ')\n                    markdown_text += f\"    - **{code_key}:**\\n{code_str_indented}\\n\"\n            else:\n                if \"relevant_file\" in sub_key.lower():\n                    markdown_text += f\"\\n  - **{sub_key}:** {sub_value}  \\n\"\n                else:\n                    markdown_text += f\"   **{sub_key}:** {sub_value}  \\n\"\n                if \"relevant_line\" not in sub_key.lower():  # nicer presentation\n                    # markdown_text = markdown_text.rstrip('\\n') + \"\\\\\\n\" # works for gitlab\n                    markdown_text = markdown_text.rstrip('\\n') + \"   \\n\"  # works for gitlab and bitbucker\n\n        markdown_text += \"\\n\"\n    return markdown_text\n\n\ndef try_fix_json(review, max_iter=10, code_suggestions=False):\n    \"\"\"\n    Fix broken or incomplete JSON messages and return the parsed JSON data.\n\n    Args:\n    - review: A string containing the JSON message to be fixed.\n    - max_iter: An integer representing the maximum number of iterations to try and fix the JSON message.\n    - code_suggestions: A boolean indicating whether to try and fix JSON messages with code feedback.\n\n    Returns:\n    - data: A dictionary containing the parsed JSON data.\n\n    The function attempts to fix broken or incomplete JSON messages by parsing until the last valid code suggestion.\n    If the JSON message ends with a closing bracket, the function calls the fix_json_escape_char function to fix the\n    message.\n    If code_suggestions is True and the JSON message contains code feedback, the function tries to fix the JSON\n    message by parsing until the last valid code suggestion.\n    The function uses regular expressions to find the last occurrence of \"},\" with any number of whitespaces or\n    newlines.\n    It tries to parse the JSON message with the closing bracket and checks if it is valid.\n    If the JSON message is valid, the parsed JSON data is returned.\n    If the JSON message is not valid, the last code suggestion is removed and the process is repeated until a valid JSON\n    message is obtained or the maximum number of iterations is reached.\n    If a valid JSON message is not obtained, an error is logged and an empty dictionary is returned.\n    \"\"\"\n\n    if review.endswith(\"}\"):\n        return fix_json_escape_char(review)\n\n    data = {}\n    if code_suggestions:\n        closing_bracket = \"]}\"\n    else:\n        closing_bracket = \"]}}\"\n\n    if (review.rfind(\"'Code feedback': [\") > 0 or review.rfind('\"Code feedback\": [') > 0) or \\\n            (review.rfind(\"'Code suggestions': [\") > 0 or review.rfind('\"Code suggestions\": [') > 0) :\n        last_code_suggestion_ind = [m.end() for m in re.finditer(r\"\\}\\s*,\", review)][-1] - 1\n        valid_json = False\n        iter_count = 0\n\n        while last_code_suggestion_ind > 0 and not valid_json and iter_count < max_iter:\n            try:\n                data = json.loads(review[:last_code_suggestion_ind] + closing_bracket)\n                valid_json = True\n                review = review[:last_code_suggestion_ind].strip() + closing_bracket\n            except json.decoder.JSONDecodeError:\n                review = review[:last_code_suggestion_ind]\n                last_code_suggestion_ind = [m.end() for m in re.finditer(r\"\\}\\s*,\", review)][-1] - 1\n                iter_count += 1\n\n        if not valid_json:\n            get_logger().error(\"Unable to decode JSON response from AI\")\n            data = {}\n\n    return data\n\n\ndef fix_json_escape_char(json_message=None):\n    \"\"\"\n    Fix broken or incomplete JSON messages and return the parsed JSON data.\n\n    Args:\n        json_message (str): A string containing the JSON message to be fixed.\n\n    Returns:\n        dict: A dictionary containing the parsed JSON data.\n\n    Raises:\n        None\n\n    \"\"\"\n    try:\n        result = json.loads(json_message)\n    except Exception as e:\n        # Find the offending character index:\n        idx_to_replace = int(str(e).split(' ')[-1].replace(')', ''))\n        # Remove the offending character:\n        json_message = list(json_message)\n        json_message[idx_to_replace] = ' '\n        new_message = ''.join(json_message)\n        return fix_json_escape_char(json_message=new_message)\n    return result\n\n\ndef convert_str_to_datetime(date_str):\n    \"\"\"\n    Convert a string representation of a date and time into a datetime object.\n\n    Args:\n        date_str (str): A string representation of a date and time in the format '%a, %d %b %Y %H:%M:%S %Z'\n\n    Returns:\n        datetime: A datetime object representing the input date and time.\n\n    Example:\n        >>> convert_str_to_datetime('Mon, 01 Jan 2022 12:00:00 UTC')\n        datetime.datetime(2022, 1, 1, 12, 0, 0)\n    \"\"\"\n    datetime_format = '%a, %d %b %Y %H:%M:%S %Z'\n    return datetime.strptime(date_str, datetime_format)\n\n\ndef load_large_diff(filename, new_file_content_str: str, original_file_content_str: str, show_warning: bool = True) -> str:\n    \"\"\"\n    Generate a patch for a modified file by comparing the original content of the file with the new content provided as\n    input.\n    \"\"\"\n    if not original_file_content_str and not new_file_content_str:\n        return \"\"\n\n    try:\n        original_file_content_str = (original_file_content_str or \"\").rstrip() + \"\\n\"\n        new_file_content_str = (new_file_content_str or \"\").rstrip() + \"\\n\"\n        diff = difflib.unified_diff(original_file_content_str.splitlines(keepends=True),\n                                    new_file_content_str.splitlines(keepends=True))\n        if get_settings().config.verbosity_level >= 2 and show_warning:\n            get_logger().info(f\"File was modified, but no patch was found. Manually creating patch: {filename}.\")\n        patch = ''.join(diff)\n        return patch\n    except Exception as e:\n        get_logger().exception(f\"Failed to generate patch for file: {filename}\")\n        return \"\"\n\n\ndef update_settings_from_args(args: List[str]) -> List[str]:\n    \"\"\"\n    Update the settings of the Dynaconf object based on the arguments passed to the function.\n\n    Args:\n        args: A list of arguments passed to the function.\n        Example args: ['--pr_code_suggestions.extra_instructions=\"be funny',\n                  '--pr_code_suggestions.num_code_suggestions=3']\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the argument is not in the correct format.\n\n    \"\"\"\n    other_args = []\n    if args:\n        for arg in args:\n            arg = arg.strip()\n            if arg.startswith('--'):\n                arg = arg.strip('-').strip()\n                vals = arg.split('=', 1)\n                if len(vals) != 2:\n                    if len(vals) > 2:  # --extended is a valid argument\n                        get_logger().error(f'Invalid argument format: {arg}')\n                    other_args.append(arg)\n                    continue\n                key, value = _fix_key_value(*vals)\n                get_settings().set(key, value)\n                get_logger().info(f'Updated setting {key} to: \"{value}\"')\n            else:\n                other_args.append(arg)\n    return other_args\n\n\ndef _fix_key_value(key: str, value: str):\n    key = key.strip().upper()\n    value = value.strip()\n    try:\n        value = yaml.safe_load(value)\n    except Exception as e:\n        get_logger().debug(f\"Failed to parse YAML for config override {key}={value}\", exc_info=e)\n    return key, value\n\n\ndef load_yaml(response_text: str, keys_fix_yaml: List[str] = [], first_key=\"\", last_key=\"\") -> dict:\n    response_text_original = copy.deepcopy(response_text)\n    response_text = response_text.strip('\\n').removeprefix('```yaml').rstrip().removesuffix('```')\n    try:\n        data = yaml.safe_load(response_text)\n    except Exception as e:\n        get_logger().warning(f\"Initial failure to parse AI prediction: {e}\")\n        data = try_fix_yaml(response_text, keys_fix_yaml=keys_fix_yaml, first_key=first_key, last_key=last_key,\n                            response_text_original=response_text_original)\n        if not data:\n            get_logger().error(f\"Failed to parse AI prediction after fallbacks\",\n                               artifact={'response_text': response_text})\n        else:\n            get_logger().info(f\"Successfully parsed AI prediction after fallbacks\",\n                              artifact={'response_text': response_text})\n    return data\n\n\n\ndef try_fix_yaml(response_text: str,\n                 keys_fix_yaml: List[str] = [],\n                 first_key=\"\",\n                 last_key=\"\",\n                 response_text_original=\"\") -> dict:\n    response_text_lines = response_text.split('\\n')\n\n    keys_yaml = ['relevant line:', 'suggestion content:', 'relevant file:', 'existing code:', 'improved code:']\n    keys_yaml = keys_yaml + keys_fix_yaml\n    # first fallback - try to convert 'relevant line: ...' to relevant line: |-\\n        ...'\n    response_text_lines_copy = response_text_lines.copy()\n    for i in range(0, len(response_text_lines_copy)):\n        for key in keys_yaml:\n            if key in response_text_lines_copy[i] and not '|' in response_text_lines_copy[i]:\n                response_text_lines_copy[i] = response_text_lines_copy[i].replace(f'{key}',\n                                                                                  f'{key} |\\n        ')\n    try:\n        data = yaml.safe_load('\\n'.join(response_text_lines_copy))\n        get_logger().info(f\"Successfully parsed AI prediction after adding |-\\n\")\n        return data\n    except:\n        pass\n\n    # second fallback - try to extract only range from first ```yaml to ````\n    snippet_pattern = r'```(yaml)?[\\s\\S]*?```'\n    snippet = re.search(snippet_pattern, '\\n'.join(response_text_lines_copy))\n    if not snippet:\n        snippet = re.search(snippet_pattern, response_text_original) # before we removed the \"```\"\n    if snippet:\n        snippet_text = snippet.group()\n        try:\n            data = yaml.safe_load(snippet_text.removeprefix('```yaml').rstrip('`'))\n            get_logger().info(f\"Successfully parsed AI prediction after extracting yaml snippet\")\n            return data\n        except:\n            pass\n\n\n    # third fallback - try to remove leading and trailing curly brackets\n    response_text_copy = response_text.strip().rstrip().removeprefix('{').removesuffix('}').rstrip(':\\n')\n    try:\n        data = yaml.safe_load(response_text_copy)\n        get_logger().info(f\"Successfully parsed AI prediction after removing curly brackets\")\n        return data\n    except:\n        pass\n\n\n    # forth fallback - try to extract yaml snippet by 'first_key' and 'last_key'\n    # note that 'last_key' can be in practice a key that is not the last key in the yaml snippet.\n    # it just needs to be some inner key, so we can look for newlines after it\n    if first_key and last_key:\n        index_start = response_text.find(f\"\\n{first_key}:\")\n        if index_start == -1:\n            index_start = response_text.find(f\"{first_key}:\")\n        index_last_code = response_text.rfind(f\"{last_key}:\")\n        index_end = response_text.find(\"\\n\\n\", index_last_code) # look for newlines after last_key\n        if index_end == -1:\n            index_end = len(response_text)\n        response_text_copy = response_text[index_start:index_end].strip().strip('```yaml').strip('`').strip()\n        try:\n            data = yaml.safe_load(response_text_copy)\n            get_logger().info(f\"Successfully parsed AI prediction after extracting yaml snippet\")\n            return data\n        except:\n            pass\n\n    # fifth fallback - try to remove leading '+' (sometimes added by AI for 'existing code' and 'improved code')\n    response_text_lines_copy = response_text_lines.copy()\n    for i in range(0, len(response_text_lines_copy)):\n        if response_text_lines_copy[i].startswith('+'):\n            response_text_lines_copy[i] = ' ' + response_text_lines_copy[i][1:]\n    try:\n        data = yaml.safe_load('\\n'.join(response_text_lines_copy))\n        get_logger().info(f\"Successfully parsed AI prediction after removing leading '+'\")\n        return data\n    except:\n        pass\n\n    # sixth fallback - try to remove last lines\n    for i in range(1, len(response_text_lines)):\n        response_text_lines_tmp = '\\n'.join(response_text_lines[:-i])\n        try:\n            data = yaml.safe_load(response_text_lines_tmp)\n            get_logger().info(f\"Successfully parsed AI prediction after removing {i} lines\")\n            return data\n        except:\n            pass\n\n\ndef set_custom_labels(variables, git_provider=None):\n    if not get_settings().config.enable_custom_labels:\n        return\n\n    labels = get_settings().get('custom_labels', {})\n    if not labels:\n        # set default labels\n        labels = ['Bug fix', 'Tests', 'Bug fix with tests', 'Enhancement', 'Documentation', 'Other']\n        labels_list = \"\\n      - \".join(labels) if labels else \"\"\n        labels_list = f\"      - {labels_list}\" if labels_list else \"\"\n        variables[\"custom_labels\"] = labels_list\n        return\n\n    # Set custom labels\n    variables[\"custom_labels_class\"] = \"class Label(str, Enum):\"\n    counter = 0\n    labels_minimal_to_labels_dict = {}\n    for k, v in labels.items():\n        description = \"'\" + v['description'].strip('\\n').replace('\\n', '\\\\n') + \"'\"\n        # variables[\"custom_labels_class\"] += f\"\\n    {k.lower().replace(' ', '_')} = '{k}' # {description}\"\n        variables[\"custom_labels_class\"] += f\"\\n    {k.lower().replace(' ', '_')} = {description}\"\n        labels_minimal_to_labels_dict[k.lower().replace(' ', '_')] = k\n        counter += 1\n    variables[\"labels_minimal_to_labels_dict\"] = labels_minimal_to_labels_dict\n\ndef get_user_labels(current_labels: List[str] = None):\n    \"\"\"\n    Only keep labels that has been added by the user\n    \"\"\"\n    try:\n        enable_custom_labels = get_settings().config.get('enable_custom_labels', False)\n        custom_labels = get_settings().get('custom_labels', [])\n        if current_labels is None:\n            current_labels = []\n        user_labels = []\n        for label in current_labels:\n            if label.lower() in ['bug fix', 'tests', 'enhancement', 'documentation', 'other']:\n                continue\n            if enable_custom_labels:\n                if label in custom_labels:\n                    continue\n            user_labels.append(label)\n        if user_labels:\n            get_logger().debug(f\"Keeping user labels: {user_labels}\")\n    except Exception as e:\n        get_logger().exception(f\"Failed to get user labels: {e}\")\n        return current_labels\n    return user_labels\n\n\ndef get_max_tokens(model):\n    \"\"\"\n    Get the maximum number of tokens allowed for a model.\n    logic:\n    (1) If the model is in './pr_agent/algo/__init__.py', use the value from there.\n    (2) else, the user needs to define explicitly 'config.custom_model_max_tokens'\n\n    For both cases, we further limit the number of tokens to 'config.max_model_tokens' if it is set.\n    This aims to improve the algorithmic quality, as the AI model degrades in performance when the input is too long.\n    \"\"\"\n    settings = get_settings()\n    if model in MAX_TOKENS:\n        max_tokens_model = MAX_TOKENS[model]\n    elif settings.config.custom_model_max_tokens > 0:\n        max_tokens_model = settings.config.custom_model_max_tokens\n    else:\n        raise Exception(f\"Ensure {model} is defined in MAX_TOKENS in ./pr_agent/algo/__init__.py or set a positive value for it in config.custom_model_max_tokens\")\n\n    if settings.config.max_model_tokens and settings.config.max_model_tokens > 0:\n        max_tokens_model = min(settings.config.max_model_tokens, max_tokens_model)\n    return max_tokens_model\n\n\ndef clip_tokens(text: str, max_tokens: int, add_three_dots=True, num_input_tokens=None, delete_last_line=False) -> str:\n    \"\"\"\n    Clip the number of tokens in a string to a maximum number of tokens.\n\n    Args:\n        text (str): The string to clip.\n        max_tokens (int): The maximum number of tokens allowed in the string.\n        add_three_dots (bool, optional): A boolean indicating whether to add three dots at the end of the clipped\n    Returns:\n        str: The clipped string.\n    \"\"\"\n    if not text:\n        return text\n\n    try:\n        if num_input_tokens is None:\n            encoder = TokenEncoder.get_token_encoder()\n            num_input_tokens = len(encoder.encode(text))\n        if num_input_tokens <= max_tokens:\n            return text\n        if max_tokens < 0:\n            return \"\"\n\n        # calculate the number of characters to keep\n        num_chars = len(text)\n        chars_per_token = num_chars / num_input_tokens\n        factor = 0.9  # reduce by 10% to be safe\n        num_output_chars = int(factor * chars_per_token * max_tokens)\n\n        # clip the text\n        if num_output_chars > 0:\n            clipped_text = text[:num_output_chars]\n            if delete_last_line:\n                clipped_text = clipped_text.rsplit('\\n', 1)[0]\n            if add_three_dots:\n                clipped_text += \"\\n...(truncated)\"\n        else: # if the text is empty\n            clipped_text =  \"\"\n\n        return clipped_text\n    except Exception as e:\n        get_logger().warning(f\"Failed to clip tokens: {e}\")\n        return text\n\ndef replace_code_tags(text):\n    \"\"\"\n    Replace odd instances of ` with <code> and even instances of ` with </code>\n    \"\"\"\n    text = html.escape(text)\n    parts = text.split('`')\n    for i in range(1, len(parts), 2):\n        parts[i] = '<code>' + parts[i] + '</code>'\n    return ''.join(parts)\n\n\ndef find_line_number_of_relevant_line_in_file(diff_files: List[FilePatchInfo],\n                                              relevant_file: str,\n                                              relevant_line_in_file: str,\n                                              absolute_position: int = None) -> Tuple[int, int]:\n    position = -1\n    if absolute_position is None:\n        absolute_position = -1\n    re_hunk_header = re.compile(\n        r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n\n    if not diff_files:\n        return position, absolute_position\n\n    for file in diff_files:\n        if file.filename and (file.filename.strip() == relevant_file):\n            patch = file.patch\n            patch_lines = patch.splitlines()\n            delta = 0\n            start1, size1, start2, size2 = 0, 0, 0, 0\n            if absolute_position != -1: # matching absolute to relative\n                for i, line in enumerate(patch_lines):\n                    # new hunk\n                    if line.startswith('@@'):\n                        delta = 0\n                        match = re_hunk_header.match(line)\n                        start1, size1, start2, size2 = map(int, match.groups()[:4])\n                    elif not line.startswith('-'):\n                        delta += 1\n\n                    #\n                    absolute_position_curr = start2 + delta - 1\n\n                    if absolute_position_curr == absolute_position:\n                        position = i\n                        break\n            else:\n                # try to find the line in the patch using difflib, with some margin of error\n                matches_difflib: list[str | Any] = difflib.get_close_matches(relevant_line_in_file,\n                                                                             patch_lines, n=3, cutoff=0.93)\n                if len(matches_difflib) == 1 and matches_difflib[0].startswith('+'):\n                    relevant_line_in_file = matches_difflib[0]\n\n\n                for i, line in enumerate(patch_lines):\n                    if line.startswith('@@'):\n                        delta = 0\n                        match = re_hunk_header.match(line)\n                        start1, size1, start2, size2 = map(int, match.groups()[:4])\n                    elif not line.startswith('-'):\n                        delta += 1\n\n                    if relevant_line_in_file in line and line[0] != '-':\n                        position = i\n                        absolute_position = start2 + delta - 1\n                        break\n\n                if position == -1 and relevant_line_in_file[0] == '+':\n                    no_plus_line = relevant_line_in_file[1:].lstrip()\n                    for i, line in enumerate(patch_lines):\n                        if line.startswith('@@'):\n                            delta = 0\n                            match = re_hunk_header.match(line)\n                            start1, size1, start2, size2 = map(int, match.groups()[:4])\n                        elif not line.startswith('-'):\n                            delta += 1\n\n                        if no_plus_line in line and line[0] != '-':\n                            # The model might add a '+' to the beginning of the relevant_line_in_file even if originally\n                            # it's a context line\n                            position = i\n                            absolute_position = start2 + delta - 1\n                            break\n    return position, absolute_position\n\ndef get_rate_limit_status(github_token) -> dict:\n    GITHUB_API_URL = get_settings(use_context=False).get(\"GITHUB.BASE_URL\", \"https://api.github.com\").rstrip(\"/\")  # \"https://api.github.com\"\n    # GITHUB_API_URL = \"https://api.github.com\"\n    RATE_LIMIT_URL = f\"{GITHUB_API_URL}/rate_limit\"\n    HEADERS = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Authorization\": f\"token {github_token}\"\n    }\n\n    response = requests.get(RATE_LIMIT_URL, headers=HEADERS)\n    try:\n        rate_limit_info = response.json()\n        if rate_limit_info.get('message') == 'Rate limiting is not enabled.':  # for github enterprise\n            return {'resources': {}}\n        response.raise_for_status()  # Check for HTTP errors\n    except:  # retry\n        time.sleep(0.1)\n        response = requests.get(RATE_LIMIT_URL, headers=HEADERS)\n        return response.json()\n    return rate_limit_info\n\n\ndef validate_rate_limit_github(github_token, installation_id=None, threshold=0.1) -> bool:\n    try:\n        rate_limit_status = get_rate_limit_status(github_token)\n        if installation_id:\n            get_logger().debug(f\"installation_id: {installation_id}, Rate limit status: {rate_limit_status['rate']}\")\n    # validate that the rate limit is not exceeded\n        # validate that the rate limit is not exceeded\n        for key, value in rate_limit_status['resources'].items():\n            if value['remaining'] < value['limit'] * threshold:\n                get_logger().error(f\"key: {key}, value: {value}\")\n                return False\n        return True\n    except Exception as e:\n        get_logger().error(f\"Error in rate limit {e}\",\n                           artifact={\"traceback\": traceback.format_exc()})\n        return True\n\n\ndef validate_and_await_rate_limit(github_token):\n    try:\n        rate_limit_status = get_rate_limit_status(github_token)\n        # validate that the rate limit is not exceeded\n        for key, value in rate_limit_status['resources'].items():\n            if value['remaining'] < value['limit'] // 80:\n                get_logger().error(f\"key: {key}, value: {value}\")\n                sleep_time_sec = value['reset'] - datetime.now().timestamp()\n                sleep_time_hour = sleep_time_sec / 3600.0\n                get_logger().error(f\"Rate limit exceeded. Sleeping for {sleep_time_hour} hours\")\n                if sleep_time_sec > 0:\n                    time.sleep(sleep_time_sec + 1)\n                rate_limit_status = get_rate_limit_status(github_token)\n        return rate_limit_status\n    except:\n        get_logger().error(\"Error in rate limit\")\n        return None\n\n\ndef github_action_output(output_data: dict, key_name: str):\n    try:\n        if not get_settings().get('github_action_config.enable_output', False):\n            return\n\n        key_data = output_data.get(key_name, {})\n        with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:\n            print(f\"{key_name}={json.dumps(key_data, indent=None, ensure_ascii=False)}\", file=fh)\n    except Exception as e:\n        get_logger().error(f\"Failed to write to GitHub Action output: {e}\")\n    return\n\n\ndef show_relevant_configurations(relevant_section: str) -> str:\n    skip_keys = ['ai_disclaimer', 'ai_disclaimer_title', 'ANALYTICS_FOLDER', 'secret_provider', \"skip_keys\", \"app_id\", \"redirect\",\n                      'trial_prefix_message', 'no_eligible_message', 'identity_provider', 'ALLOWED_REPOS','APP_NAME']\n    extra_skip_keys = get_settings().config.get('config.skip_keys', [])\n    if extra_skip_keys:\n        skip_keys.extend(extra_skip_keys)\n\n    markdown_text = \"\"\n    markdown_text += \"\\n<hr>\\n<details> <summary><strong>üõ†Ô∏è Relevant configurations:</strong></summary> \\n\\n\"\n    markdown_text +=\"<br>These are the relevant [configurations](https://github.com/Codium-ai/pr-agent/blob/main/pr_agent/settings/configuration.toml) for this tool:\\n\\n\"\n    markdown_text += f\"**[config**]\\n```yaml\\n\\n\"\n    for key, value in get_settings().config.items():\n        if key in skip_keys:\n            continue\n        markdown_text += f\"{key}: {value}\\n\"\n    markdown_text += \"\\n```\\n\"\n    markdown_text += f\"\\n**[{relevant_section}]**\\n```yaml\\n\\n\"\n    for key, value in get_settings().get(relevant_section, {}).items():\n        if key in skip_keys:\n            continue\n        markdown_text += f\"{key}: {value}\\n\"\n    markdown_text += \"\\n```\"\n    markdown_text += \"\\n</details>\\n\"\n    return markdown_text\n\ndef is_value_no(value):\n    if not value:\n        return True\n    value_str = str(value).strip().lower()\n    if value_str == 'no' or value_str == 'none' or value_str == 'false':\n        return True\n    return False\n\n\ndef set_pr_string(repo_name, pr_number):\n    return f\"{repo_name}#{pr_number}\"\n\n\ndef string_to_uniform_number(s: str) -> float:\n    \"\"\"\n    Convert a string to a uniform number in the range [0, 1].\n    The uniform distribution is achieved by the nature of the SHA-256 hash function, which produces a uniformly distributed hash value over its output space.\n    \"\"\"\n    # Generate a hash of the string\n    hash_object = hashlib.sha256(s.encode())\n    # Convert the hash to an integer\n    hash_int = int(hash_object.hexdigest(), 16)\n    # Normalize the integer to the range [0, 1]\n    max_hash_int = 2 ** 256 - 1\n    uniform_number = float(hash_int) / max_hash_int\n    return uniform_number\n\n\ndef process_description(description_full: str) -> Tuple[str, List]:\n    if not description_full:\n        return \"\", []\n\n    description_split = description_full.split(PRDescriptionHeader.CHANGES_WALKTHROUGH.value)\n    base_description_str = description_split[0]\n    changes_walkthrough_str = \"\"\n    files = []\n    if len(description_split) > 1:\n        changes_walkthrough_str = description_split[1]\n    else:\n        get_logger().debug(\"No changes walkthrough found\")\n\n    try:\n        if changes_walkthrough_str:\n            # get the end of the table\n            if '</table>\\n\\n___' in changes_walkthrough_str:\n                end = changes_walkthrough_str.index(\"</table>\\n\\n___\")\n            elif '\\n___' in changes_walkthrough_str:\n                end = changes_walkthrough_str.index(\"\\n___\")\n            else:\n                end = len(changes_walkthrough_str)\n            changes_walkthrough_str = changes_walkthrough_str[:end]\n\n            h = html2text.HTML2Text()\n            h.body_width = 0  # Disable line wrapping\n\n            # find all the files\n            pattern = r'<tr>\\s*<td>\\s*(<details>\\s*<summary>(.*?)</summary>(.*?)</details>)\\s*</td>'\n            files_found = re.findall(pattern, changes_walkthrough_str, re.DOTALL)\n            for file_data in files_found:\n                try:\n                    if isinstance(file_data, tuple):\n                        file_data = file_data[0]\n                    pattern = r'<details>\\s*<summary><strong>(.*?)</strong>\\s*<dd><code>(.*?)</code>.*?</summary>\\s*<hr>\\s*(.*?)\\s*<li>(.*?)</details>'\n                    res = re.search(pattern, file_data, re.DOTALL)\n                    if not res or res.lastindex != 4:\n                        pattern_back = r'<details>\\s*<summary><strong>(.*?)</strong><dd><code>(.*?)</code>.*?</summary>\\s*<hr>\\s*(.*?)\\n\\n\\s*(.*?)</details>'\n                        res = re.search(pattern_back, file_data, re.DOTALL)\n                    if not res or res.lastindex != 4:\n                        pattern_back = r'<details>\\s*<summary><strong>(.*?)</strong>\\s*<dd><code>(.*?)</code>.*?</summary>\\s*<hr>\\s*(.*?)\\s*-\\s*(.*?)\\s*</details>' # looking for hypen ('- ')\n                        res = re.search(pattern_back, file_data, re.DOTALL)\n                    if res and res.lastindex == 4:\n                        short_filename = res.group(1).strip()\n                        short_summary = res.group(2).strip()\n                        long_filename = res.group(3).strip()\n                        long_summary =  res.group(4).strip()\n                        long_summary = long_summary.replace('<br> *', '\\n*').replace('<br>','').replace('\\n','<br>')\n                        long_summary = h.handle(long_summary).strip()\n                        if long_summary.startswith('\\\\-'):\n                            long_summary = \"* \" + long_summary[2:]\n                        elif not long_summary.startswith('*'):\n                            long_summary = f\"* {long_summary}\"\n\n                        files.append({\n                            'short_file_name': short_filename,\n                            'full_file_name': long_filename,\n                            'short_summary': short_summary,\n                            'long_summary': long_summary\n                        })\n                    else:\n                        if '<code>...</code>' in file_data:\n                            pass # PR with many files. some did not get analyzed\n                        else:\n                            get_logger().error(f\"Failed to parse description\", artifact={'description': file_data})\n                except Exception as e:\n                    get_logger().exception(f\"Failed to process description: {e}\", artifact={'description': file_data})\n\n\n    except Exception as e:\n        get_logger().exception(f\"Failed to process description: {e}\")\n\n    return base_description_str, files\n\ndef get_version() -> str:\n    # First check pyproject.toml if running directly out of repository\n    if os.path.exists(\"pyproject.toml\"):\n        if sys.version_info >= (3, 11):\n            import tomllib\n            with open(\"pyproject.toml\", \"rb\") as f:\n                data = tomllib.load(f)\n                if \"project\" in data and \"version\" in data[\"project\"]:\n                    return data[\"project\"][\"version\"]\n                else:\n                    get_logger().warning(\"Version not found in pyproject.toml\")\n        else:\n            get_logger().warning(\"Unable to determine local version from pyproject.toml\")\n\n    # Otherwise get the installed pip package version\n    try:\n        return version('pr-agent')\n    except PackageNotFoundError:\n        get_logger().warning(\"Unable to find package named 'pr-agent'\")\n        return \"unknown\"\n\n\ndef set_file_languages(diff_files) -> List[FilePatchInfo]:\n    try:\n        # if the language is already set, do not change it\n        if hasattr(diff_files[0], 'language') and diff_files[0].language:\n            return diff_files\n\n        # map file extensions to programming languages\n        language_extension_map_org = get_settings().language_extension_map_org\n        extension_to_language = {}\n        for language, extensions in language_extension_map_org.items():\n            for ext in extensions:\n                extension_to_language[ext] = language\n        for file in diff_files:\n            extension_s = '.' + file.filename.rsplit('.')[-1]\n            language_name = \"txt\"\n            if extension_s and (extension_s in extension_to_language):\n                language_name = extension_to_language[extension_s]\n            file.language = language_name.lower()\n    except Exception as e:\n        get_logger().exception(f\"Failed to set file languages: {e}\")\n\n    return diff_files\n"}
{"type": "source_file", "path": "pr_agent/servers/gerrit_server.py", "content": "import copy\nfrom enum import Enum\nfrom json import JSONDecodeError\n\nimport uvicorn\nfrom fastapi import APIRouter, FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom starlette.middleware import Middleware\nfrom starlette_context import context\nfrom starlette_context.middleware import RawContextMiddleware\n\nfrom pr_agent.agent.pr_agent import PRAgent\nfrom pr_agent.config_loader import get_settings, global_settings\nfrom pr_agent.log import get_logger, setup_logger\n\nsetup_logger()\nrouter = APIRouter()\n\n\nclass Action(str, Enum):\n    review = \"review\"\n    describe = \"describe\"\n    ask = \"ask\"\n    improve = \"improve\"\n    reflect = \"reflect\"\n    answer = \"answer\"\n\n\nclass Item(BaseModel):\n    refspec: str\n    project: str\n    msg: str\n\n\n@router.post(\"/api/v1/gerrit/{action}\")\nasync def handle_gerrit_request(action: Action, item: Item):\n    get_logger().debug(\"Received a Gerrit request\")\n    context[\"settings\"] = copy.deepcopy(global_settings)\n\n    if action == Action.ask:\n        if not item.msg:\n            return HTTPException(\n                status_code=400,\n                detail=\"msg is required for ask command\"\n            )\n    await PRAgent().handle_request(\n        f\"{item.project}:{item.refspec}\",\n        f\"/{item.msg.strip()}\"\n    )\n\n\nasync def get_body(request):\n    try:\n        body = await request.json()\n    except JSONDecodeError as e:\n        get_logger().error(\"Error parsing request body\", e)\n        return {}\n    return body\n\n\n@router.get(\"/\")\nasync def root():\n    return {\"status\": \"ok\"}\n\n\ndef start():\n    # to prevent adding help messages with the output\n    get_settings().set(\"CONFIG.CLI_MODE\", True)\n    middleware = [Middleware(RawContextMiddleware)]\n    app = FastAPI(middleware=middleware)\n    app.include_router(router)\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=3000)\n\n\nif __name__ == '__main__':\n    start()\n"}
{"type": "source_file", "path": "pr_agent/secret_providers/__init__.py", "content": "from pr_agent.config_loader import get_settings\n\n\ndef get_secret_provider():\n    if not get_settings().get(\"CONFIG.SECRET_PROVIDER\"):\n        return None\n\n    provider_id = get_settings().config.secret_provider\n    if provider_id == 'google_cloud_storage':\n        try:\n            from pr_agent.secret_providers.google_cloud_storage_secret_provider import \\\n                GoogleCloudStorageSecretProvider\n            return GoogleCloudStorageSecretProvider()\n        except Exception as e:\n            raise ValueError(f\"Failed to initialize google_cloud_storage secret provider {provider_id}\") from e\n    else:\n        raise ValueError(\"Unknown SECRET_PROVIDER\")\n"}
{"type": "source_file", "path": "pr_agent/identity_providers/identity_provider.py", "content": "from abc import ABC, abstractmethod\nfrom enum import Enum\n\n\nclass Eligibility(Enum):\n    NOT_ELIGIBLE = 0\n    ELIGIBLE = 1\n    TRIAL = 2\n\n\nclass IdentityProvider(ABC):\n    @abstractmethod\n    def verify_eligibility(self, git_provider, git_provier_id, pr_url):\n        pass\n\n    @abstractmethod\n    def inc_invocation_count(self, git_provider, git_provider_id):\n        pass\n"}
{"type": "source_file", "path": "pr_agent/secret_providers/secret_provider.py", "content": "from abc import ABC, abstractmethod\n\n\nclass SecretProvider(ABC):\n\n    @abstractmethod\n    def get_secret(self, secret_name: str) -> str:\n        pass\n\n    @abstractmethod\n    def store_secret(self, secret_name: str, secret_value: str):\n        pass\n"}
{"type": "source_file", "path": "pr_agent/servers/github_app.py", "content": "import asyncio.locks\nimport copy\nimport os\nimport re\nimport uuid\nfrom typing import Any, Dict, Tuple\n\nimport uvicorn\nfrom fastapi import APIRouter, FastAPI, HTTPException, Request, Response\nfrom starlette.background import BackgroundTasks\nfrom starlette.middleware import Middleware\nfrom starlette_context import context\nfrom starlette_context.middleware import RawContextMiddleware\n\nfrom pr_agent.agent.pr_agent import PRAgent\nfrom pr_agent.algo.utils import update_settings_from_args\nfrom pr_agent.config_loader import get_settings, global_settings\nfrom pr_agent.git_providers import (get_git_provider,\n                                    get_git_provider_with_context)\nfrom pr_agent.git_providers.git_provider import IncrementalPR\nfrom pr_agent.git_providers.utils import apply_repo_settings\nfrom pr_agent.identity_providers import get_identity_provider\nfrom pr_agent.identity_providers.identity_provider import Eligibility\nfrom pr_agent.log import LoggingFormat, get_logger, setup_logger\nfrom pr_agent.servers.utils import DefaultDictWithTimeout, verify_signature\n\nsetup_logger(fmt=LoggingFormat.JSON, level=\"DEBUG\")\nbase_path = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\nbuild_number_path = os.path.join(base_path, \"build_number.txt\")\nif os.path.exists(build_number_path):\n    with open(build_number_path) as f:\n        build_number = f.read().strip()\nelse:\n    build_number = \"unknown\"\nrouter = APIRouter()\n\n\n@router.post(\"/api/v1/github_webhooks\")\nasync def handle_github_webhooks(background_tasks: BackgroundTasks, request: Request, response: Response):\n    \"\"\"\n    Receives and processes incoming GitHub webhook requests.\n    Verifies the request signature, parses the request body, and passes it to the handle_request function for further\n    processing.\n    \"\"\"\n    get_logger().debug(\"Received a GitHub webhook\")\n\n    body = await get_body(request)\n\n    installation_id = body.get(\"installation\", {}).get(\"id\")\n    context[\"installation_id\"] = installation_id\n    context[\"settings\"] = copy.deepcopy(global_settings)\n    context[\"git_provider\"] = {}\n    background_tasks.add_task(handle_request, body, event=request.headers.get(\"X-GitHub-Event\", None))\n    return {}\n\n\n@router.post(\"/api/v1/marketplace_webhooks\")\nasync def handle_marketplace_webhooks(request: Request, response: Response):\n    body = await get_body(request)\n    get_logger().info(f'Request body:\\n{body}')\n\n\nasync def get_body(request):\n    try:\n        body = await request.json()\n    except Exception as e:\n        get_logger().error(\"Error parsing request body\", e)\n        raise HTTPException(status_code=400, detail=\"Error parsing request body\") from e\n    webhook_secret = getattr(get_settings().github, 'webhook_secret', None)\n    if webhook_secret:\n        body_bytes = await request.body()\n        signature_header = request.headers.get('x-hub-signature-256', None)\n        verify_signature(body_bytes, webhook_secret, signature_header)\n    return body\n\n\n_duplicate_push_triggers = DefaultDictWithTimeout(ttl=get_settings().github_app.push_trigger_pending_tasks_ttl)\n_pending_task_duplicate_push_conditions = DefaultDictWithTimeout(asyncio.locks.Condition, ttl=get_settings().github_app.push_trigger_pending_tasks_ttl)\n\nasync def handle_comments_on_pr(body: Dict[str, Any],\n                                event: str,\n                                sender: str,\n                                sender_id: str,\n                                action: str,\n                                log_context: Dict[str, Any],\n                                agent: PRAgent):\n    if \"comment\" not in body:\n        return {}\n    comment_body = body.get(\"comment\", {}).get(\"body\")\n    if comment_body and isinstance(comment_body, str) and not comment_body.lstrip().startswith(\"/\"):\n        if '/ask' in comment_body and comment_body.strip().startswith('> ![image]'):\n            comment_body_split = comment_body.split('/ask')\n            comment_body = '/ask' + comment_body_split[1] +' \\n' +comment_body_split[0].strip().lstrip('>')\n            get_logger().info(f\"Reformatting comment_body so command is at the beginning: {comment_body}\")\n        else:\n            get_logger().info(\"Ignoring comment not starting with /\")\n            return {}\n    disable_eyes = False\n    if \"issue\" in body and \"pull_request\" in body[\"issue\"] and \"url\" in body[\"issue\"][\"pull_request\"]:\n        api_url = body[\"issue\"][\"pull_request\"][\"url\"]\n    elif \"comment\" in body and \"pull_request_url\" in body[\"comment\"]:\n        api_url = body[\"comment\"][\"pull_request_url\"]\n        try:\n            if ('/ask' in comment_body and\n                    'subject_type' in body[\"comment\"] and body[\"comment\"][\"subject_type\"] == \"line\"):\n                # comment on a code line in the \"files changed\" tab\n                comment_body = handle_line_comments(body, comment_body)\n                disable_eyes = True\n        except Exception as e:\n            get_logger().error(f\"Failed to handle line comments: {e}\")\n    else:\n        return {}\n    log_context[\"api_url\"] = api_url\n    comment_id = body.get(\"comment\", {}).get(\"id\")\n    provider = get_git_provider_with_context(pr_url=api_url)\n    with get_logger().contextualize(**log_context):\n        if get_identity_provider().verify_eligibility(\"github\", sender_id, api_url) is not Eligibility.NOT_ELIGIBLE:\n            get_logger().info(f\"Processing comment on PR {api_url=}, comment_body={comment_body}\")\n            await agent.handle_request(api_url, comment_body,\n                        notify=lambda: provider.add_eyes_reaction(comment_id, disable_eyes=disable_eyes))\n        else:\n            get_logger().info(f\"User {sender=} is not eligible to process comment on PR {api_url=}\")\n\nasync def handle_new_pr_opened(body: Dict[str, Any],\n                               event: str,\n                               sender: str,\n                               sender_id: str,\n                               action: str,\n                               log_context: Dict[str, Any],\n                               agent: PRAgent):\n    title = body.get(\"pull_request\", {}).get(\"title\", \"\")\n\n    pull_request, api_url = _check_pull_request_event(action, body, log_context)\n    if not (pull_request and api_url):\n        get_logger().info(f\"Invalid PR event: {action=} {api_url=}\")\n        return {}\n    if action in get_settings().github_app.handle_pr_actions:  # ['opened', 'reopened', 'ready_for_review']\n        # logic to ignore PRs with specific titles (e.g. \"[Auto] ...\")\n        apply_repo_settings(api_url)\n        if get_identity_provider().verify_eligibility(\"github\", sender_id, api_url) is not Eligibility.NOT_ELIGIBLE:\n                await _perform_auto_commands_github(\"pr_commands\", agent, body, api_url, log_context)\n        else:\n            get_logger().info(f\"User {sender=} is not eligible to process PR {api_url=}\")\n\nasync def handle_push_trigger_for_new_commits(body: Dict[str, Any],\n                        event: str,\n                        sender: str,\n                        sender_id: str,\n                        action: str,\n                        log_context: Dict[str, Any],\n                        agent: PRAgent):\n    pull_request, api_url = _check_pull_request_event(action, body, log_context)\n    if not (pull_request and api_url):\n        return {}\n\n    apply_repo_settings(api_url) # we need to apply the repo settings to get the correct settings for the PR. This is quite expensive - a call to the git provider is made for each PR event.\n    if not get_settings().github_app.handle_push_trigger:\n        return {}\n\n    # TODO: do we still want to get the list of commits to filter bot/merge commits?\n    before_sha = body.get(\"before\")\n    after_sha = body.get(\"after\")\n    merge_commit_sha = pull_request.get(\"merge_commit_sha\")\n    if before_sha == after_sha:\n        return {}\n    if get_settings().github_app.push_trigger_ignore_merge_commits and after_sha == merge_commit_sha:\n        return {}\n\n    # Prevent triggering multiple times for subsequent push triggers when one is enough:\n    # The first push will trigger the processing, and if there's a second push in the meanwhile it will wait.\n    # Any more events will be discarded, because they will all trigger the exact same processing on the PR.\n    # We let the second event wait instead of discarding it because while the first event was being processed,\n    # more commits may have been pushed that led to the subsequent events,\n    # so we keep just one waiting as a delegate to trigger the processing for the new commits when done waiting.\n    current_active_tasks = _duplicate_push_triggers.setdefault(api_url, 0)\n    max_active_tasks = 2 if get_settings().github_app.push_trigger_pending_tasks_backlog else 1\n    if current_active_tasks < max_active_tasks:\n        # first task can enter, and second tasks too if backlog is enabled\n        get_logger().info(\n            f\"Continue processing push trigger for {api_url=} because there are {current_active_tasks} active tasks\"\n        )\n        _duplicate_push_triggers[api_url] += 1\n    else:\n        get_logger().info(\n            f\"Skipping push trigger for {api_url=} because another event already triggered the same processing\"\n        )\n        return {}\n    async with _pending_task_duplicate_push_conditions[api_url]:\n        if current_active_tasks == 1:\n            # second task waits\n            get_logger().info(\n                f\"Waiting to process push trigger for {api_url=} because the first task is still in progress\"\n            )\n            await _pending_task_duplicate_push_conditions[api_url].wait()\n            get_logger().info(f\"Finished waiting to process push trigger for {api_url=} - continue with flow\")\n\n    try:\n        if get_identity_provider().verify_eligibility(\"github\", sender_id, api_url) is not Eligibility.NOT_ELIGIBLE:\n                get_logger().info(f\"Performing incremental review for {api_url=} because of {event=} and {action=}\")\n                await _perform_auto_commands_github(\"push_commands\", agent, body, api_url, log_context)\n\n    finally:\n        # release the waiting task block\n        async with _pending_task_duplicate_push_conditions[api_url]:\n            _pending_task_duplicate_push_conditions[api_url].notify(1)\n            _duplicate_push_triggers[api_url] -= 1\n\n\ndef handle_closed_pr(body, event, action, log_context):\n    pull_request = body.get(\"pull_request\", {})\n    is_merged = pull_request.get(\"merged\", False)\n    if not is_merged:\n        return\n    api_url = pull_request.get(\"url\", \"\")\n    pr_statistics = get_git_provider()(pr_url=api_url).calc_pr_statistics(pull_request)\n    log_context[\"api_url\"] = api_url\n    get_logger().info(\"PR-Agent statistics for closed PR\", analytics=True, pr_statistics=pr_statistics, **log_context)\n\n\ndef get_log_context(body, event, action, build_number):\n    sender = \"\"\n    sender_id = \"\"\n    sender_type = \"\"\n    try:\n        sender = body.get(\"sender\", {}).get(\"login\")\n        sender_id = body.get(\"sender\", {}).get(\"id\")\n        sender_type = body.get(\"sender\", {}).get(\"type\")\n        repo = body.get(\"repository\", {}).get(\"full_name\", \"\")\n        git_org = body.get(\"organization\", {}).get(\"login\", \"\")\n        installation_id = body.get(\"installation\", {}).get(\"id\", \"\")\n        app_name = get_settings().get(\"CONFIG.APP_NAME\", \"Unknown\")\n        log_context = {\"action\": action, \"event\": event, \"sender\": sender, \"server_type\": \"github_app\",\n                       \"request_id\": uuid.uuid4().hex, \"build_number\": build_number, \"app_name\": app_name,\n                        \"repo\": repo, \"git_org\": git_org, \"installation_id\": installation_id}\n    except Exception as e:\n        get_logger().error(\"Failed to get log context\", e)\n        log_context = {}\n    return log_context, sender, sender_id, sender_type\n\n\ndef is_bot_user(sender, sender_type):\n    try:\n        # logic to ignore PRs opened by bot\n        if get_settings().get(\"GITHUB_APP.IGNORE_BOT_PR\", False) and sender_type == \"Bot\":\n            if 'pr-agent' not in sender:\n                get_logger().info(f\"Ignoring PR from '{sender=}' because it is a bot\")\n            return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_bot_user' logic: {e}\")\n    return False\n\n\ndef should_process_pr_logic(body) -> bool:\n    try:\n        pull_request = body.get(\"pull_request\", {})\n        title = pull_request.get(\"title\", \"\")\n        pr_labels = pull_request.get(\"labels\", [])\n        source_branch = pull_request.get(\"head\", {}).get(\"ref\", \"\")\n        target_branch = pull_request.get(\"base\", {}).get(\"ref\", \"\")\n        sender = body.get(\"sender\", {}).get(\"login\")\n\n        # logic to ignore PRs from specific users\n        ignore_pr_users = get_settings().get(\"CONFIG.IGNORE_PR_AUTHORS\", [])\n        if ignore_pr_users and sender:\n            if sender in ignore_pr_users:\n                get_logger().info(f\"Ignoring PR from user '{sender}' due to 'config.ignore_pr_authors' setting\")\n                return False\n\n        # logic to ignore PRs with specific titles\n        if title:\n            ignore_pr_title_re = get_settings().get(\"CONFIG.IGNORE_PR_TITLE\", [])\n            if not isinstance(ignore_pr_title_re, list):\n                ignore_pr_title_re = [ignore_pr_title_re]\n            if ignore_pr_title_re and any(re.search(regex, title) for regex in ignore_pr_title_re):\n                get_logger().info(f\"Ignoring PR with title '{title}' due to config.ignore_pr_title setting\")\n                return False\n\n        # logic to ignore PRs with specific labels or source branches or target branches.\n        ignore_pr_labels = get_settings().get(\"CONFIG.IGNORE_PR_LABELS\", [])\n        if pr_labels and ignore_pr_labels:\n            labels = [label['name'] for label in pr_labels]\n            if any(label in ignore_pr_labels for label in labels):\n                labels_str = \", \".join(labels)\n                get_logger().info(f\"Ignoring PR with labels '{labels_str}' due to config.ignore_pr_labels settings\")\n                return False\n\n        # logic to ignore PRs with specific source or target branches\n        ignore_pr_source_branches = get_settings().get(\"CONFIG.IGNORE_PR_SOURCE_BRANCHES\", [])\n        ignore_pr_target_branches = get_settings().get(\"CONFIG.IGNORE_PR_TARGET_BRANCHES\", [])\n        if pull_request and (ignore_pr_source_branches or ignore_pr_target_branches):\n            if any(re.search(regex, source_branch) for regex in ignore_pr_source_branches):\n                get_logger().info(\n                    f\"Ignoring PR with source branch '{source_branch}' due to config.ignore_pr_source_branches settings\")\n                return False\n            if any(re.search(regex, target_branch) for regex in ignore_pr_target_branches):\n                get_logger().info(\n                    f\"Ignoring PR with target branch '{target_branch}' due to config.ignore_pr_target_branches settings\")\n                return False\n    except Exception as e:\n        get_logger().error(f\"Failed 'should_process_pr_logic': {e}\")\n    return True\n\n\nasync def handle_request(body: Dict[str, Any], event: str):\n    \"\"\"\n    Handle incoming GitHub webhook requests.\n\n    Args:\n        body: The request body.\n        event: The GitHub event type (e.g. \"pull_request\", \"issue_comment\", etc.).\n    \"\"\"\n    action = body.get(\"action\")  # \"created\", \"opened\", \"reopened\", \"ready_for_review\", \"review_requested\", \"synchronize\"\n    if not action:\n        return {}\n    agent = PRAgent()\n    log_context, sender, sender_id, sender_type = get_log_context(body, event, action, build_number)\n\n    # logic to ignore PRs opened by bot, PRs with specific titles, labels, source branches, or target branches\n    if is_bot_user(sender, sender_type) and 'check_run' not in body:\n        return {}\n    if action != 'created' and 'check_run' not in body:\n        if not should_process_pr_logic(body):\n            return {}\n\n    if 'check_run' in body:  # handle failed checks\n        # get_logger().debug(f'Request body', artifact=body, event=event) # added inside handle_checks\n        pass\n    # handle comments on PRs\n    elif action == 'created':\n        get_logger().debug(f'Request body', artifact=body, event=event)\n        await handle_comments_on_pr(body, event, sender, sender_id, action, log_context, agent)\n    # handle new PRs\n    elif event == 'pull_request' and action != 'synchronize' and action != 'closed':\n        get_logger().debug(f'Request body', artifact=body, event=event)\n        await handle_new_pr_opened(body, event, sender, sender_id, action, log_context, agent)\n    elif event == \"issue_comment\" and 'edited' in action:\n        pass # handle_checkbox_clicked\n    # handle pull_request event with synchronize action - \"push trigger\" for new commits\n    elif event == 'pull_request' and action == 'synchronize':\n        await handle_push_trigger_for_new_commits(body, event, sender,sender_id,  action, log_context, agent)\n    elif event == 'pull_request' and action == 'closed':\n        if get_settings().get(\"CONFIG.ANALYTICS_FOLDER\", \"\"):\n            handle_closed_pr(body, event, action, log_context)\n    else:\n        get_logger().info(f\"event {event=} action {action=} does not require any handling\")\n    return {}\n\n\ndef handle_line_comments(body: Dict, comment_body: [str, Any]) -> str:\n    if not comment_body:\n        return \"\"\n    start_line = body[\"comment\"][\"start_line\"]\n    end_line = body[\"comment\"][\"line\"]\n    start_line = end_line if not start_line else start_line\n    question = comment_body.replace('/ask', '').strip()\n    diff_hunk = body[\"comment\"][\"diff_hunk\"]\n    get_settings().set(\"ask_diff_hunk\", diff_hunk)\n    path = body[\"comment\"][\"path\"]\n    side = body[\"comment\"][\"side\"]\n    comment_id = body[\"comment\"][\"id\"]\n    if '/ask' in comment_body:\n        comment_body = f\"/ask_line --line_start={start_line} --line_end={end_line} --side={side} --file_name={path} --comment_id={comment_id} {question}\"\n    return comment_body\n\n\ndef _check_pull_request_event(action: str, body: dict, log_context: dict) -> Tuple[Dict[str, Any], str]:\n    invalid_result = {}, \"\"\n    pull_request = body.get(\"pull_request\")\n    if not pull_request:\n        return invalid_result\n    api_url = pull_request.get(\"url\")\n    if not api_url:\n        return invalid_result\n    log_context[\"api_url\"] = api_url\n    if pull_request.get(\"draft\", True) or pull_request.get(\"state\") != \"open\":\n        return invalid_result\n    if action in (\"review_requested\", \"synchronize\") and pull_request.get(\"created_at\") == pull_request.get(\"updated_at\"):\n        # avoid double reviews when opening a PR for the first time\n        return invalid_result\n    return pull_request, api_url\n\n\nasync def _perform_auto_commands_github(commands_conf: str, agent: PRAgent, body: dict, api_url: str,\n                                        log_context: dict):\n    apply_repo_settings(api_url)\n    if commands_conf == \"pr_commands\" and get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n        get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {api_url=}\")\n        return\n    if not should_process_pr_logic(body): # Here we already updated the configuration with the repo settings\n        return {}\n    commands = get_settings().get(f\"github_app.{commands_conf}\")\n    if not commands:\n        get_logger().info(f\"New PR, but no auto commands configured\")\n        return\n    get_settings().set(\"config.is_auto_command\", True)\n    for command in commands:\n        split_command = command.split(\" \")\n        command = split_command[0]\n        args = split_command[1:]\n        other_args = update_settings_from_args(args)\n        new_command = ' '.join([command] + other_args)\n        get_logger().info(f\"{commands_conf}. Performing auto command '{new_command}', for {api_url=}\")\n        await agent.handle_request(api_url, new_command)\n\n\n@router.get(\"/\")\nasync def root():\n    return {\"status\": \"ok\"}\n\n\nif get_settings().github_app.override_deployment_type:\n    # Override the deployment type to app\n    get_settings().set(\"GITHUB.DEPLOYMENT_TYPE\", \"app\")\n# get_settings().set(\"CONFIG.PUBLISH_OUTPUT_PROGRESS\", False)\nmiddleware = [Middleware(RawContextMiddleware)]\napp = FastAPI(middleware=middleware)\napp.include_router(router)\n\n\ndef start():\n    uvicorn.run(app, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", \"3000\")))\n\n\nif __name__ == '__main__':\n    start()\n"}
{"type": "source_file", "path": "pr_agent/servers/github_polling.py", "content": "import asyncio\nimport multiprocessing\nimport time\nimport traceback\nfrom collections import deque\nfrom datetime import datetime, timezone\n\nimport aiohttp\nimport requests\n\nfrom pr_agent.agent.pr_agent import PRAgent\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers import get_git_provider\nfrom pr_agent.log import LoggingFormat, get_logger, setup_logger\n\nsetup_logger(fmt=LoggingFormat.JSON, level=\"DEBUG\")\nNOTIFICATION_URL = \"https://api.github.com/notifications\"\n\n\nasync def mark_notification_as_read(headers, notification, session):\n    async with session.patch(\n            f\"https://api.github.com/notifications/threads/{notification['id']}\",\n            headers=headers) as mark_read_response:\n        if mark_read_response.status != 205:\n            get_logger().error(\n                f\"Failed to mark notification as read. Status code: {mark_read_response.status}\")\n\n\ndef now() -> str:\n    \"\"\"\n    Get the current UTC time in ISO 8601 format.\n\n    Returns:\n        str: The current UTC time in ISO 8601 format.\n    \"\"\"\n    now_utc = datetime.now(timezone.utc).isoformat()\n    now_utc = now_utc.replace(\"+00:00\", \"Z\")\n    return now_utc\n\nasync def async_handle_request(pr_url, rest_of_comment, comment_id, git_provider):\n    agent = PRAgent()\n    success = await agent.handle_request(\n        pr_url,\n        rest_of_comment,\n        notify=lambda: git_provider.add_eyes_reaction(comment_id)\n    )\n    return success\n\ndef run_handle_request(pr_url, rest_of_comment, comment_id, git_provider):\n    return asyncio.run(async_handle_request(pr_url, rest_of_comment, comment_id, git_provider))\n\n\ndef process_comment_sync(pr_url, rest_of_comment, comment_id):\n    try:\n        # Run the async handle_request in a separate function\n        git_provider = get_git_provider()(pr_url=pr_url)\n        success = run_handle_request(pr_url, rest_of_comment, comment_id, git_provider)\n    except Exception as e:\n        get_logger().error(f\"Error processing comment: {e}\", artifact={\"traceback\": traceback.format_exc()})\n\n\nasync def process_comment(pr_url, rest_of_comment, comment_id):\n    try:\n        git_provider = get_git_provider()(pr_url=pr_url)\n        git_provider.set_pr(pr_url)\n        agent = PRAgent()\n        success = await agent.handle_request(\n            pr_url,\n            rest_of_comment,\n            notify=lambda: git_provider.add_eyes_reaction(comment_id)\n        )\n        get_logger().info(f\"Finished processing comment for PR: {pr_url}\")\n    except Exception as e:\n        get_logger().error(f\"Error processing comment: {e}\", artifact={\"traceback\": traceback.format_exc()})\n\nasync def is_valid_notification(notification, headers, handled_ids, session, user_id):\n    try:\n        if 'reason' in notification and notification['reason'] == 'mention':\n            if 'subject' in notification and notification['subject']['type'] == 'PullRequest':\n                pr_url = notification['subject']['url']\n                latest_comment = notification['subject']['latest_comment_url']\n                if not latest_comment or not isinstance(latest_comment, str):\n                    get_logger().debug(f\"no latest_comment\")\n                    return False, handled_ids\n                async with session.get(latest_comment, headers=headers) as comment_response:\n                    check_prev_comments = False\n                    user_tag = \"@\" + user_id\n                    if comment_response.status == 200:\n                        comment = await comment_response.json()\n                        if 'id' in comment:\n                            if comment['id'] in handled_ids:\n                                get_logger().debug(f\"comment['id'] in handled_ids\")\n                                return False, handled_ids\n                            else:\n                                handled_ids.add(comment['id'])\n                        if 'user' in comment and 'login' in comment['user']:\n                            if comment['user']['login'] == user_id:\n                                get_logger().debug(f\"comment['user']['login'] == user_id\")\n                                check_prev_comments = True\n                        comment_body = comment.get('body', '')\n                        if not comment_body:\n                            get_logger().debug(f\"no comment_body\")\n                            check_prev_comments = True\n                        else:\n                            if user_tag not in comment_body:\n                                get_logger().debug(f\"user_tag not in comment_body\")\n                                check_prev_comments = True\n                            else:\n                                get_logger().info(f\"Polling, pr_url: {pr_url}\",\n                                                  artifact={\"comment\": comment_body})\n\n                        if not check_prev_comments:\n                            return True, handled_ids, comment, comment_body, pr_url, user_tag\n                        else: # we could not find the user tag in the latest comment. Check previous comments\n                            # get all comments in the PR\n                            requests_url = f\"{pr_url}/comments\".replace(\"pulls\", \"issues\")\n                            comments_response = requests.get(requests_url, headers=headers)\n                            comments = comments_response.json()[::-1]\n                            max_comment_to_scan = 4\n                            for comment in comments[:max_comment_to_scan]:\n                                if 'user' in comment and 'login' in comment['user']:\n                                    if comment['user']['login'] == user_id:\n                                        continue\n                                comment_body = comment.get('body', '')\n                                if not comment_body:\n                                    continue\n                                if user_tag in comment_body:\n                                    get_logger().info(\"found user tag in previous comments\")\n                                    get_logger().info(f\"Polling, pr_url: {pr_url}\",\n                                                      artifact={\"comment\": comment_body})\n                                    return True, handled_ids, comment, comment_body, pr_url, user_tag\n\n                            get_logger().warning(f\"Failed to fetch comments for PR: {pr_url}\",\n                                                    artifact={\"comments\": comments})\n                            return False, handled_ids\n\n        return False, handled_ids\n    except Exception as e:\n        get_logger().exception(f\"Error processing polling notification\",\n                               artifact={\"notification\": notification, \"error\": e})\n        return False, handled_ids\n\n\n\nasync def polling_loop():\n    \"\"\"\n    Polls for notifications and handles them accordingly.\n    \"\"\"\n    handled_ids = set()\n    since = [now()]\n    last_modified = [None]\n    git_provider = get_git_provider()()\n    user_id = git_provider.get_user_id()\n    get_settings().set(\"CONFIG.PUBLISH_OUTPUT_PROGRESS\", False)\n    get_settings().set(\"pr_description.publish_description_as_comment\", True)\n\n    try:\n        deployment_type = get_settings().github.deployment_type\n        token = get_settings().github.user_token\n    except AttributeError:\n        deployment_type = 'none'\n        token = None\n\n    if deployment_type != 'user':\n        raise ValueError(\"Deployment mode must be set to 'user' to get notifications\")\n    if not token:\n        raise ValueError(\"User token must be set to get notifications\")\n\n    async with aiohttp.ClientSession() as session:\n        while True:\n            try:\n                await asyncio.sleep(5)\n                headers = {\n                    \"Accept\": \"application/vnd.github.v3+json\",\n                    \"Authorization\": f\"Bearer {token}\"\n                }\n                params = {\n                    \"participating\": \"true\"\n                }\n                if since[0]:\n                    params[\"since\"] = since[0]\n                if last_modified[0]:\n                    headers[\"If-Modified-Since\"] = last_modified[0]\n\n                async with session.get(NOTIFICATION_URL, headers=headers, params=params) as response:\n                    if response.status == 200:\n                        if 'Last-Modified' in response.headers:\n                            last_modified[0] = response.headers['Last-Modified']\n                            since[0] = None\n                        notifications = await response.json()\n                        if not notifications:\n                            continue\n                        get_logger().info(f\"Received {len(notifications)} notifications\")\n                        task_queue = deque()\n                        for notification in notifications:\n                            if not notification:\n                                continue\n                            # mark notification as read\n                            await mark_notification_as_read(headers, notification, session)\n\n                            handled_ids.add(notification['id'])\n                            output = await is_valid_notification(notification, headers, handled_ids, session, user_id)\n                            if output[0]:\n                                _, handled_ids, comment, comment_body, pr_url, user_tag = output\n                                rest_of_comment = comment_body.split(user_tag)[1].strip()\n                                comment_id = comment['id']\n\n                                # Add to the task queue\n                                get_logger().info(\n                                    f\"Adding comment processing to task queue for PR, {pr_url}, comment_body: {comment_body}\")\n                                task_queue.append((process_comment_sync, (pr_url, rest_of_comment, comment_id)))\n                                get_logger().info(f\"Queued comment processing for PR: {pr_url}\")\n                            else:\n                                get_logger().debug(f\"Skipping comment processing for PR\")\n\n                        max_allowed_parallel_tasks = 10\n                        if task_queue:\n                            processes = []\n                            for i, (func, args) in enumerate(task_queue):  # Create  parallel tasks\n                                p = multiprocessing.Process(target=func, args=args)\n                                processes.append(p)\n                                p.start()\n                                if i > max_allowed_parallel_tasks:\n                                    get_logger().error(\n                                        f\"Dropping {len(task_queue) - max_allowed_parallel_tasks} tasks from polling session\")\n                                    break\n                            task_queue.clear()\n\n                            # Dont wait for all processes to complete. Move on to the next iteration\n                            # for p in processes:\n                            #     p.join()\n\n                    elif response.status != 304:\n                        print(f\"Failed to fetch notifications. Status code: {response.status}\")\n\n            except Exception as e:\n                get_logger().error(f\"Polling exception during processing of a notification: {e}\",\n                                   artifact={\"traceback\": traceback.format_exc()})\n\n\nif __name__ == '__main__':\n    asyncio.run(polling_loop())\n"}
{"type": "source_file", "path": "pr_agent/servers/github_action_runner.py", "content": "import asyncio\nimport json\nimport os\nfrom typing import Union\n\nfrom pr_agent.agent.pr_agent import PRAgent\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers import get_git_provider\nfrom pr_agent.git_providers.utils import apply_repo_settings\nfrom pr_agent.log import get_logger\nfrom pr_agent.servers.github_app import handle_line_comments\nfrom pr_agent.tools.pr_code_suggestions import PRCodeSuggestions\nfrom pr_agent.tools.pr_description import PRDescription\nfrom pr_agent.tools.pr_reviewer import PRReviewer\n\n\ndef is_true(value: Union[str, bool]) -> bool:\n    if isinstance(value, bool):\n        return value\n    if isinstance(value, str):\n        return value.lower() == 'true'\n    return False\n\n\ndef get_setting_or_env(key: str, default: Union[str, bool] = None) -> Union[str, bool]:\n    try:\n        value = get_settings().get(key, default)\n    except AttributeError:  # TBD still need to debug why this happens on GitHub Actions\n        value = os.getenv(key, None) or os.getenv(key.upper(), None) or os.getenv(key.lower(), None) or default\n    return value\n\n\nasync def run_action():\n    # Get environment variables\n    GITHUB_EVENT_NAME = os.environ.get('GITHUB_EVENT_NAME')\n    GITHUB_EVENT_PATH = os.environ.get('GITHUB_EVENT_PATH')\n    OPENAI_KEY = os.environ.get('OPENAI_KEY') or os.environ.get('OPENAI.KEY')\n    OPENAI_ORG = os.environ.get('OPENAI_ORG') or os.environ.get('OPENAI.ORG')\n    GITHUB_TOKEN = os.environ.get('GITHUB_TOKEN')\n    # get_settings().set(\"CONFIG.PUBLISH_OUTPUT_PROGRESS\", False)\n\n    # Check if required environment variables are set\n    if not GITHUB_EVENT_NAME:\n        print(\"GITHUB_EVENT_NAME not set\")\n        return\n    if not GITHUB_EVENT_PATH:\n        print(\"GITHUB_EVENT_PATH not set\")\n        return\n    if not GITHUB_TOKEN:\n        print(\"GITHUB_TOKEN not set\")\n        return\n\n    # Set the environment variables in the settings\n    if OPENAI_KEY:\n        get_settings().set(\"OPENAI.KEY\", OPENAI_KEY)\n    else:\n        # Might not be set if the user is using models not from OpenAI\n        print(\"OPENAI_KEY not set\")\n    if OPENAI_ORG:\n        get_settings().set(\"OPENAI.ORG\", OPENAI_ORG)\n    get_settings().set(\"GITHUB.USER_TOKEN\", GITHUB_TOKEN)\n    get_settings().set(\"GITHUB.DEPLOYMENT_TYPE\", \"user\")\n    enable_output = get_setting_or_env(\"GITHUB_ACTION_CONFIG.ENABLE_OUTPUT\", True)\n    get_settings().set(\"GITHUB_ACTION_CONFIG.ENABLE_OUTPUT\", enable_output)\n\n    # Load the event payload\n    try:\n        with open(GITHUB_EVENT_PATH, 'r') as f:\n            event_payload = json.load(f)\n    except json.decoder.JSONDecodeError as e:\n        print(f\"Failed to parse JSON: {e}\")\n        return\n\n    try:\n        get_logger().info(\"Applying repo settings\")\n        pr_url = event_payload.get(\"pull_request\", {}).get(\"html_url\")\n        if pr_url:\n            apply_repo_settings(pr_url)\n            get_logger().info(f\"enable_custom_labels: {get_settings().config.enable_custom_labels}\")\n    except Exception as e:\n        get_logger().info(f\"github action: failed to apply repo settings: {e}\")\n\n    # Handle pull request opened event\n    if GITHUB_EVENT_NAME == \"pull_request\" or GITHUB_EVENT_NAME == \"pull_request_target\":\n        action = event_payload.get(\"action\")\n\n        # Retrieve the list of actions from the configuration\n        pr_actions = get_settings().get(\"GITHUB_ACTION_CONFIG.PR_ACTIONS\", [\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"])\n\n        if action in pr_actions:\n            pr_url = event_payload.get(\"pull_request\", {}).get(\"url\")\n            if pr_url:\n                # legacy - supporting both GITHUB_ACTION and GITHUB_ACTION_CONFIG\n                auto_review = get_setting_or_env(\"GITHUB_ACTION.AUTO_REVIEW\", None)\n                if auto_review is None:\n                    auto_review = get_setting_or_env(\"GITHUB_ACTION_CONFIG.AUTO_REVIEW\", None)\n                auto_describe = get_setting_or_env(\"GITHUB_ACTION.AUTO_DESCRIBE\", None)\n                if auto_describe is None:\n                    auto_describe = get_setting_or_env(\"GITHUB_ACTION_CONFIG.AUTO_DESCRIBE\", None)\n                auto_improve = get_setting_or_env(\"GITHUB_ACTION.AUTO_IMPROVE\", None)\n                if auto_improve is None:\n                    auto_improve = get_setting_or_env(\"GITHUB_ACTION_CONFIG.AUTO_IMPROVE\", None)\n\n                # Set the configuration for auto actions\n                get_settings().config.is_auto_command = True # Set the flag to indicate that the command is auto\n                get_settings().pr_description.final_update_message = False  # No final update message when auto_describe is enabled\n                get_logger().info(f\"Running auto actions: auto_describe={auto_describe}, auto_review={auto_review}, auto_improve={auto_improve}\")\n\n                # invoke by default all three tools\n                if auto_describe is None or is_true(auto_describe):\n                    await PRDescription(pr_url).run()\n                if auto_review is None or is_true(auto_review):\n                    await PRReviewer(pr_url).run()\n                if auto_improve is None or is_true(auto_improve):\n                    await PRCodeSuggestions(pr_url).run()\n        else:\n            get_logger().info(f\"Skipping action: {action}\")\n\n    # Handle issue comment event\n    elif GITHUB_EVENT_NAME == \"issue_comment\" or GITHUB_EVENT_NAME == \"pull_request_review_comment\":\n        action = event_payload.get(\"action\")\n        if action in [\"created\", \"edited\"]:\n            comment_body = event_payload.get(\"comment\", {}).get(\"body\")\n            try:\n                if GITHUB_EVENT_NAME == \"pull_request_review_comment\":\n                    if '/ask' in comment_body:\n                        comment_body = handle_line_comments(event_payload, comment_body)\n            except Exception as e:\n                get_logger().error(f\"Failed to handle line comments: {e}\")\n                return\n            if comment_body:\n                is_pr = False\n                disable_eyes = False\n                # check if issue is pull request\n                if event_payload.get(\"issue\", {}).get(\"pull_request\"):\n                    url = event_payload.get(\"issue\", {}).get(\"pull_request\", {}).get(\"url\")\n                    is_pr = True\n                elif event_payload.get(\"comment\", {}).get(\"pull_request_url\"):  # for 'pull_request_review_comment\n                    url = event_payload.get(\"comment\", {}).get(\"pull_request_url\")\n                    is_pr = True\n                    disable_eyes = True\n                else:\n                    url = event_payload.get(\"issue\", {}).get(\"url\")\n\n                if url:\n                    body = comment_body.strip().lower()\n                    comment_id = event_payload.get(\"comment\", {}).get(\"id\")\n                    provider = get_git_provider()(pr_url=url)\n                    if is_pr:\n                        await PRAgent().handle_request(\n                            url, body, notify=lambda: provider.add_eyes_reaction(\n                                comment_id, disable_eyes=disable_eyes\n                            )\n                        )\n                    else:\n                        await PRAgent().handle_request(url, body)\n\n\nif __name__ == '__main__':\n    asyncio.run(run_action())\n"}
{"type": "source_file", "path": "pr_agent/git_providers/utils.py", "content": "import copy\nimport os\nimport tempfile\n\nfrom dynaconf import Dynaconf\nfrom starlette_context import context\n\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers import (get_git_provider,\n                                    get_git_provider_with_context)\nfrom pr_agent.log import get_logger\n\n\ndef apply_repo_settings(pr_url):\n    git_provider = get_git_provider_with_context(pr_url)\n    if get_settings().config.use_repo_settings_file:\n        repo_settings_file = None\n        try:\n            try:\n                repo_settings = context.get(\"repo_settings\", None)\n            except Exception:\n                repo_settings = None\n                pass\n            if repo_settings is None:  # None is different from \"\", which is a valid value\n                repo_settings = git_provider.get_repo_settings()\n                try:\n                    context[\"repo_settings\"] = repo_settings\n                except Exception:\n                    pass\n\n            error_local = None\n            if repo_settings:\n                repo_settings_file = None\n                category = 'local'\n                try:\n                    fd, repo_settings_file = tempfile.mkstemp(suffix='.toml')\n                    os.write(fd, repo_settings)\n                    new_settings = Dynaconf(settings_files=[repo_settings_file])\n                    for section, contents in new_settings.as_dict().items():\n                        section_dict = copy.deepcopy(get_settings().as_dict().get(section, {}))\n                        for key, value in contents.items():\n                            section_dict[key] = value\n                        get_settings().unset(section)\n                        get_settings().set(section, section_dict, merge=False)\n                    get_logger().info(f\"Applying repo settings:\\n{new_settings.as_dict()}\")\n                except Exception as e:\n                    get_logger().warning(f\"Failed to apply repo {category} settings, error: {str(e)}\")\n                    error_local = {'error': str(e), 'settings': repo_settings, 'category': category}\n\n                if error_local:\n                    handle_configurations_errors([error_local], git_provider)\n        except Exception as e:\n            get_logger().exception(\"Failed to apply repo settings\", e)\n        finally:\n            if repo_settings_file:\n                try:\n                    os.remove(repo_settings_file)\n                except Exception as e:\n                    get_logger().error(f\"Failed to remove temporary settings file {repo_settings_file}\", e)\n\n    # enable switching models with a short definition\n    if get_settings().config.model.lower() == 'claude-3-5-sonnet':\n        set_claude_model()\n\n\ndef handle_configurations_errors(config_errors, git_provider):\n    try:\n        if not any(config_errors):\n            return\n\n        for err in config_errors:\n            if err:\n                configuration_file_content = err['settings'].decode()\n                err_message = err['error']\n                config_type = err['category']\n                header = f\"‚ùå **PR-Agent failed to apply '{config_type}' repo settings**\"\n                body = f\"{header}\\n\\nThe configuration file needs to be a valid [TOML](https://qodo-merge-docs.qodo.ai/usage-guide/configuration_options/), please fix it.\\n\\n\"\n                body += f\"___\\n\\n**Error message:**\\n`{err_message}`\\n\\n\"\n                if git_provider.is_supported(\"gfm_markdown\"):\n                    body += f\"\\n\\n<details><summary>Configuration content:</summary>\\n\\n```toml\\n{configuration_file_content}\\n```\\n\\n</details>\"\n                else:\n                    body += f\"\\n\\n**Configuration content:**\\n\\n```toml\\n{configuration_file_content}\\n```\\n\\n\"\n                get_logger().warning(f\"Sending a 'configuration error' comment to the PR\", artifact={'body': body})\n                # git_provider.publish_comment(body)\n                if hasattr(git_provider, 'publish_persistent_comment'):\n                    git_provider.publish_persistent_comment(body,\n                                                            initial_header=header,\n                                                            update_header=False,\n                                                            final_update_message=False)\n                else:\n                    git_provider.publish_comment(body)\n    except Exception as e:\n        get_logger().exception(f\"Failed to handle configurations errors\", e)\n\n\ndef set_claude_model():\n    \"\"\"\n    set the claude-sonnet-3.5 model easily (even by users), just by stating: --config.model='claude-3-5-sonnet'\n    \"\"\"\n    model_claude = \"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"\n    get_settings().set('config.model', model_claude)\n    get_settings().set('config.model_weak', model_claude)\n    get_settings().set('config.fallback_models', [model_claude])\n"}
{"type": "source_file", "path": "pr_agent/servers/bitbucket_app.py", "content": "import base64\nimport copy\nimport hashlib\nimport json\nimport os\nimport re\nimport time\n\nimport jwt\nimport requests\nimport uvicorn\nfrom fastapi import APIRouter, FastAPI, Request, Response\nfrom starlette.background import BackgroundTasks\nfrom starlette.middleware import Middleware\nfrom starlette.responses import JSONResponse\nfrom starlette_context import context\nfrom starlette_context.middleware import RawContextMiddleware\n\nfrom pr_agent.agent.pr_agent import PRAgent\nfrom pr_agent.algo.utils import update_settings_from_args\nfrom pr_agent.config_loader import get_settings, global_settings\nfrom pr_agent.git_providers.utils import apply_repo_settings\nfrom pr_agent.identity_providers import get_identity_provider\nfrom pr_agent.identity_providers.identity_provider import Eligibility\nfrom pr_agent.log import LoggingFormat, get_logger, setup_logger\nfrom pr_agent.secret_providers import get_secret_provider\n\nsetup_logger(fmt=LoggingFormat.JSON, level=\"DEBUG\")\nrouter = APIRouter()\nsecret_provider = get_secret_provider() if get_settings().get(\"CONFIG.SECRET_PROVIDER\") else None\n\n\nasync def get_bearer_token(shared_secret: str, client_key: str):\n    try:\n        now = int(time.time())\n        url = \"https://bitbucket.org/site/oauth2/access_token\"\n        canonical_url = \"GET&/site/oauth2/access_token&\"\n        qsh = hashlib.sha256(canonical_url.encode(\"utf-8\")).hexdigest()\n        app_key = get_settings().bitbucket.app_key\n\n        payload = {\n            \"iss\": app_key,\n            \"iat\": now,\n            \"exp\": now + 240,\n            \"qsh\": qsh,\n            \"sub\": client_key,\n            }\n        token = jwt.encode(payload, shared_secret, algorithm=\"HS256\")\n        payload = 'grant_type=urn%3Abitbucket%3Aoauth2%3Ajwt'\n        headers = {\n            'Authorization': f'JWT {token}',\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n        response = requests.request(\"POST\", url, headers=headers, data=payload)\n        bearer_token = response.json()[\"access_token\"]\n        return bearer_token\n    except Exception as e:\n        get_logger().error(f\"Failed to get bearer token: {e}\")\n        raise e\n\n@router.get(\"/\")\nasync def handle_manifest(request: Request, response: Response):\n    cur_dir = os.path.dirname(os.path.abspath(__file__))\n    manifest = open(os.path.join(cur_dir, \"atlassian-connect.json\"), \"rt\").read()\n    try:\n        manifest = manifest.replace(\"app_key\", get_settings().bitbucket.app_key)\n        manifest = manifest.replace(\"base_url\", get_settings().bitbucket.base_url)\n    except:\n        get_logger().error(\"Failed to replace api_key in Bitbucket manifest, trying to continue\")\n    manifest_obj = json.loads(manifest)\n    return JSONResponse(manifest_obj)\n\n\ndef _get_username(data):\n    actor = data.get(\"data\", {}).get(\"actor\", {})\n    if actor:\n        if \"username\" in actor:\n            return actor[\"username\"]\n        elif \"display_name\" in actor:\n            return actor[\"display_name\"]\n        elif \"nickname\" in actor:\n            return actor[\"nickname\"]\n    return \"\"\n\n\nasync def _perform_commands_bitbucket(commands_conf: str, agent: PRAgent, api_url: str, log_context: dict, data: dict):\n    apply_repo_settings(api_url)\n    if commands_conf == \"pr_commands\" and get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n        get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {api_url=}\")\n        return\n    if data.get(\"event\", \"\") == \"pullrequest:created\":\n        if not should_process_pr_logic(data):\n            return\n    commands = get_settings().get(f\"bitbucket_app.{commands_conf}\", {})\n    get_settings().set(\"config.is_auto_command\", True)\n    for command in commands:\n        try:\n            split_command = command.split(\" \")\n            command = split_command[0]\n            args = split_command[1:]\n            other_args = update_settings_from_args(args)\n            new_command = ' '.join([command] + other_args)\n            get_logger().info(f\"Performing command: {new_command}\")\n            with get_logger().contextualize(**log_context):\n                await agent.handle_request(api_url, new_command)\n        except Exception as e:\n            get_logger().error(f\"Failed to perform command {command}: {e}\")\n\n\ndef is_bot_user(data) -> bool:\n    try:\n        actor = data.get(\"data\", {}).get(\"actor\", {})\n        # allow actor type: user . if it's \"AppUser\" or \"team\" then it is a bot user\n        allowed_actor_types = {\"user\"}\n        if actor and actor[\"type\"].lower() not in allowed_actor_types:\n            get_logger().info(f\"BitBucket actor type is not 'user', skipping: {actor}\")\n            return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_bot_user' logic: {e}\")\n    return False\n\n\ndef should_process_pr_logic(data) -> bool:\n    try:\n        pr_data = data.get(\"data\", {}).get(\"pullrequest\", {})\n        title = pr_data.get(\"title\", \"\")\n        source_branch = pr_data.get(\"source\", {}).get(\"branch\", {}).get(\"name\", \"\")\n        target_branch = pr_data.get(\"destination\", {}).get(\"branch\", {}).get(\"name\", \"\")\n        sender = _get_username(data)\n\n        # logic to ignore PRs from specific users\n        ignore_pr_users = get_settings().get(\"CONFIG.IGNORE_PR_AUTHORS\", [])\n        if ignore_pr_users and sender:\n            if sender in ignore_pr_users:\n                get_logger().info(f\"Ignoring PR from user '{sender}' due to 'config.ignore_pr_authors' setting\")\n                return False\n\n        # logic to ignore PRs with specific titles\n        if title:\n            ignore_pr_title_re = get_settings().get(\"CONFIG.IGNORE_PR_TITLE\", [])\n            if not isinstance(ignore_pr_title_re, list):\n                ignore_pr_title_re = [ignore_pr_title_re]\n            if ignore_pr_title_re and any(re.search(regex, title) for regex in ignore_pr_title_re):\n                get_logger().info(f\"Ignoring PR with title '{title}' due to config.ignore_pr_title setting\")\n                return False\n\n        ignore_pr_source_branches = get_settings().get(\"CONFIG.IGNORE_PR_SOURCE_BRANCHES\", [])\n        ignore_pr_target_branches = get_settings().get(\"CONFIG.IGNORE_PR_TARGET_BRANCHES\", [])\n        if (ignore_pr_source_branches or ignore_pr_target_branches):\n            if any(re.search(regex, source_branch) for regex in ignore_pr_source_branches):\n                get_logger().info(\n                    f\"Ignoring PR with source branch '{source_branch}' due to config.ignore_pr_source_branches settings\")\n                return False\n            if any(re.search(regex, target_branch) for regex in ignore_pr_target_branches):\n                get_logger().info(\n                    f\"Ignoring PR with target branch '{target_branch}' due to config.ignore_pr_target_branches settings\")\n                return False\n    except Exception as e:\n        get_logger().error(f\"Failed 'should_process_pr_logic': {e}\")\n    return True\n\n\n@router.post(\"/webhook\")\nasync def handle_github_webhooks(background_tasks: BackgroundTasks, request: Request):\n    app_name = get_settings().get(\"CONFIG.APP_NAME\", \"Unknown\")\n    log_context = {\"server_type\": \"bitbucket_app\", \"app_name\": app_name}\n    get_logger().debug(request.headers)\n    jwt_header = request.headers.get(\"authorization\", None)\n    if jwt_header:\n        input_jwt = jwt_header.split(\" \")[1]\n    data = await request.json()\n    get_logger().debug(data)\n\n    async def inner():\n        try:\n            # ignore bot users\n            if is_bot_user(data):\n                return \"OK\"\n\n            # Check if the PR should be processed\n            if data.get(\"event\", \"\") == \"pullrequest:created\":\n                if not should_process_pr_logic(data):\n                    return \"OK\"\n\n            # Get the username of the sender\n            log_context[\"sender\"] = _get_username(data)\n\n            sender_id = data.get(\"data\", {}).get(\"actor\", {}).get(\"account_id\", \"\")\n            log_context[\"sender_id\"] = sender_id\n            jwt_parts = input_jwt.split(\".\")\n            claim_part = jwt_parts[1]\n            claim_part += \"=\" * (-len(claim_part) % 4)\n            decoded_claims = base64.urlsafe_b64decode(claim_part)\n            claims = json.loads(decoded_claims)\n            client_key = claims[\"iss\"]\n            secrets = json.loads(secret_provider.get_secret(client_key))\n            shared_secret = secrets[\"shared_secret\"]\n            jwt.decode(input_jwt, shared_secret, audience=client_key, algorithms=[\"HS256\"])\n            bearer_token = await get_bearer_token(shared_secret, client_key)\n            context['bitbucket_bearer_token'] = bearer_token\n            context[\"settings\"] = copy.deepcopy(global_settings)\n            event = data[\"event\"]\n            agent = PRAgent()\n            if event == \"pullrequest:created\":\n                pr_url = data[\"data\"][\"pullrequest\"][\"links\"][\"html\"][\"href\"]\n                log_context[\"api_url\"] = pr_url\n                log_context[\"event\"] = \"pull_request\"\n                if pr_url:\n                    with get_logger().contextualize(**log_context):\n                        apply_repo_settings(pr_url)\n                        if get_identity_provider().verify_eligibility(\"bitbucket\",\n                                                        sender_id, pr_url) is not Eligibility.NOT_ELIGIBLE:\n                            if get_settings().get(\"bitbucket_app.pr_commands\"):\n                                await _perform_commands_bitbucket(\"pr_commands\", PRAgent(), pr_url, log_context, data)\n            elif event == \"pullrequest:comment_created\":\n                pr_url = data[\"data\"][\"pullrequest\"][\"links\"][\"html\"][\"href\"]\n                log_context[\"api_url\"] = pr_url\n                log_context[\"event\"] = \"comment\"\n                comment_body = data[\"data\"][\"comment\"][\"content\"][\"raw\"]\n                with get_logger().contextualize(**log_context):\n                    if get_identity_provider().verify_eligibility(\"bitbucket\",\n                                                                     sender_id, pr_url) is not Eligibility.NOT_ELIGIBLE:\n                        await agent.handle_request(pr_url, comment_body)\n        except Exception as e:\n            get_logger().error(f\"Failed to handle webhook: {e}\")\n    background_tasks.add_task(inner)\n    return \"OK\"\n\n@router.get(\"/webhook\")\nasync def handle_github_webhooks(request: Request, response: Response):\n    return \"Webhook server online!\"\n\n@router.post(\"/installed\")\nasync def handle_installed_webhooks(request: Request, response: Response):\n    try:\n        get_logger().info(\"handle_installed_webhooks\")\n        get_logger().info(request.headers)\n        data = await request.json()\n        get_logger().info(data)\n        shared_secret = data[\"sharedSecret\"]\n        client_key = data[\"clientKey\"]\n        username = data[\"principal\"][\"username\"]\n        secrets = {\n            \"shared_secret\": shared_secret,\n            \"client_key\": client_key\n        }\n        secret_provider.store_secret(username, json.dumps(secrets))\n    except Exception as e:\n        get_logger().error(f\"Failed to register user: {e}\")\n        return JSONResponse({\"error\": \"Unable to register user\"}, status_code=500)\n\n@router.post(\"/uninstalled\")\nasync def handle_uninstalled_webhooks(request: Request, response: Response):\n    get_logger().info(\"handle_uninstalled_webhooks\")\n\n    data = await request.json()\n    get_logger().info(data)\n\n\ndef start():\n    get_settings().set(\"CONFIG.PUBLISH_OUTPUT_PROGRESS\", False)\n    get_settings().set(\"CONFIG.GIT_PROVIDER\", \"bitbucket\")\n    get_settings().set(\"PR_DESCRIPTION.PUBLISH_DESCRIPTION_AS_COMMENT\", True)\n    middleware = [Middleware(RawContextMiddleware)]\n    app = FastAPI(middleware=middleware)\n    app.include_router(router)\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=int(os.getenv(\"PORT\", \"3000\")))\n\n\nif __name__ == '__main__':\n    start()\n"}
{"type": "source_file", "path": "pr_agent/git_providers/local_git_provider.py", "content": "from collections import Counter\nfrom pathlib import Path\nfrom typing import List\n\nfrom git import Repo\n\nfrom pr_agent.algo.types import EDIT_TYPE, FilePatchInfo\nfrom pr_agent.config_loader import _find_repository_root, get_settings\nfrom pr_agent.git_providers.git_provider import GitProvider\nfrom pr_agent.log import get_logger\n\n\nclass PullRequestMimic:\n    \"\"\"\n    This class mimics the PullRequest class from the PyGithub library for the LocalGitProvider.\n    \"\"\"\n\n    def __init__(self, title: str, diff_files: List[FilePatchInfo]):\n        self.title = title\n        self.diff_files = diff_files\n\n\nclass LocalGitProvider(GitProvider):\n    \"\"\"\n    This class implements the GitProvider interface for local git repositories.\n    It mimics the PR functionality of the GitProvider interface,\n    but does not require a hosted git repository.\n    Instead of providing a PR url, the user provides a local branch path to generate a diff-patch.\n    For the MVP it only supports the /review and /describe capabilities.\n    \"\"\"\n\n    def __init__(self, target_branch_name, incremental=False):\n        self.repo_path = _find_repository_root()\n        if self.repo_path is None:\n            raise ValueError('Could not find repository root')\n        self.repo = Repo(self.repo_path)\n        self.head_branch_name = self.repo.head.ref.name\n        self.target_branch_name = target_branch_name\n        self._prepare_repo()\n        self.diff_files = None\n        self.pr = PullRequestMimic(self.get_pr_title(), self.get_diff_files())\n        self.description_path = get_settings().get('local.description_path') \\\n            if get_settings().get('local.description_path') is not None else self.repo_path / 'description.md'\n        self.review_path = get_settings().get('local.review_path') \\\n            if get_settings().get('local.review_path') is not None else self.repo_path / 'review.md'\n        # inline code comments are not supported for local git repositories\n        get_settings().pr_reviewer.inline_code_comments = False\n\n    def _prepare_repo(self):\n        \"\"\"\n        Prepare the repository for PR-mimic generation.\n        \"\"\"\n        get_logger().debug('Preparing repository for PR-mimic generation...')\n        if self.repo.is_dirty():\n            raise ValueError('The repository is not in a clean state. Please commit or stash pending changes.')\n        if self.target_branch_name not in self.repo.heads:\n            raise KeyError(f'Branch: {self.target_branch_name} does not exist')\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in ['get_issue_comments', 'create_inline_comment', 'publish_inline_comments', 'get_labels',\n                          'gfm_markdown']:\n            return False\n        return True\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        diffs = self.repo.head.commit.diff(\n            self.repo.merge_base(self.repo.head, self.repo.branches[self.target_branch_name]),\n            create_patch=True,\n            R=True\n        )\n        diff_files = []\n        for diff_item in diffs:\n            if diff_item.a_blob is not None:\n                original_file_content_str = diff_item.a_blob.data_stream.read().decode('utf-8')\n            else:\n                original_file_content_str = \"\"  # empty file\n            if diff_item.b_blob is not None:\n                new_file_content_str = diff_item.b_blob.data_stream.read().decode('utf-8')\n            else:\n                new_file_content_str = \"\"  # empty file\n            edit_type = EDIT_TYPE.MODIFIED\n            if diff_item.new_file:\n                edit_type = EDIT_TYPE.ADDED\n            elif diff_item.deleted_file:\n                edit_type = EDIT_TYPE.DELETED\n            elif diff_item.renamed_file:\n                edit_type = EDIT_TYPE.RENAMED\n            diff_files.append(\n                FilePatchInfo(original_file_content_str,\n                              new_file_content_str,\n                              diff_item.diff.decode('utf-8'),\n                              diff_item.b_path,\n                              edit_type=edit_type,\n                              old_filename=None if diff_item.a_path == diff_item.b_path else diff_item.a_path\n                              )\n            )\n        self.diff_files = diff_files\n        return diff_files\n\n    def get_files(self) -> List[str]:\n        \"\"\"\n        Returns a list of files with changes in the diff.\n        \"\"\"\n        diff_index = self.repo.head.commit.diff(\n            self.repo.merge_base(self.repo.head, self.repo.branches[self.target_branch_name]),\n            R=True\n        )\n        # Get the list of changed files\n        diff_files = [item.a_path for item in diff_index]\n        return diff_files\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        with open(self.description_path, \"w\") as file:\n            # Write the string to the file\n            file.write(pr_title + '\\n' + pr_body)\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        with open(self.review_path, \"w\") as file:\n            # Write the string to the file\n            file.write(pr_comment)\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        raise NotImplementedError('Publishing inline comments is not implemented for the local git provider')\n\n    def publish_inline_comments(self, comments: list[dict]):\n        raise NotImplementedError('Publishing inline comments is not implemented for the local git provider')\n\n    def publish_code_suggestion(self, body: str, relevant_file: str,\n                                relevant_lines_start: int, relevant_lines_end: int):\n        raise NotImplementedError('Publishing code suggestions is not implemented for the local git provider')\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        raise NotImplementedError('Publishing code suggestions is not implemented for the local git provider')\n\n    def publish_labels(self, labels):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def remove_initial_comment(self):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def remove_comment(self, comment):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def add_eyes_reaction(self, comment):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def get_commit_messages(self):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def get_repo_settings(self):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def remove_reaction(self, comment):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def get_languages(self):\n        \"\"\"\n        Calculate percentage of languages in repository. Used for hunk prioritisation.\n        \"\"\"\n        # Get all files in repository\n        filepaths = [Path(item.path) for item in self.repo.tree().traverse() if item.type == 'blob']\n        # Identify language by file extension and count\n        lang_count = Counter(ext.lstrip('.') for filepath in filepaths for ext in [filepath.suffix.lower()])\n        # Convert counts to percentages\n        total_files = len(filepaths)\n        lang_percentage = {lang: count / total_files * 100 for lang, count in lang_count.items()}\n        return lang_percentage\n\n    def get_pr_branch(self):\n        return self.repo.head\n\n    def get_user_id(self):\n        return -1  # Not used anywhere for the local provider, but required by the interface\n\n    def get_pr_description_full(self):\n        commits_diff = list(self.repo.iter_commits(self.target_branch_name + '..HEAD'))\n        # Get the commit messages and concatenate\n        commit_messages = \" \".join([commit.message for commit in commits_diff])\n        # TODO Handle the description better - maybe use gpt-3.5 summarisation here?\n        return commit_messages[:200]  # Use max 200 characters\n\n    def get_pr_title(self):\n        \"\"\"\n        Substitutes the branch-name as the PR-mimic title.\n        \"\"\"\n        return self.head_branch_name\n\n    def get_issue_comments(self):\n        raise NotImplementedError('Getting issue comments is not implemented for the local git provider')\n\n    def get_pr_labels(self, update=False):\n        raise NotImplementedError('Getting labels is not implemented for the local git provider')\n"}
{"type": "source_file", "path": "pr_agent/servers/gitlab_webhook.py", "content": "import copy\nimport json\nimport re\nfrom datetime import datetime\n\nimport uvicorn\nfrom fastapi import APIRouter, FastAPI, Request, status\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\nfrom starlette.background import BackgroundTasks\nfrom starlette.middleware import Middleware\nfrom starlette_context import context\nfrom starlette_context.middleware import RawContextMiddleware\n\nfrom pr_agent.agent.pr_agent import PRAgent\nfrom pr_agent.algo.utils import update_settings_from_args\nfrom pr_agent.config_loader import get_settings, global_settings\nfrom pr_agent.git_providers.utils import apply_repo_settings\nfrom pr_agent.log import LoggingFormat, get_logger, setup_logger\nfrom pr_agent.secret_providers import get_secret_provider\n\nsetup_logger(fmt=LoggingFormat.JSON, level=\"DEBUG\")\nrouter = APIRouter()\n\nsecret_provider = get_secret_provider() if get_settings().get(\"CONFIG.SECRET_PROVIDER\") else None\n\n\nasync def handle_request(api_url: str, body: str, log_context: dict, sender_id: str):\n    log_context[\"action\"] = body\n    log_context[\"event\"] = \"pull_request\" if body == \"/review\" else \"comment\"\n    log_context[\"api_url\"] = api_url\n    log_context[\"app_name\"] = get_settings().get(\"CONFIG.APP_NAME\", \"Unknown\")\n\n    with get_logger().contextualize(**log_context):\n        await PRAgent().handle_request(api_url, body)\n\n\nasync def _perform_commands_gitlab(commands_conf: str, agent: PRAgent, api_url: str,\n                                   log_context: dict, data: dict):\n    apply_repo_settings(api_url)\n    if commands_conf == \"pr_commands\" and get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n        get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {api_url=}\", **log_context)\n        return\n    if not should_process_pr_logic(data): # Here we already updated the configurations\n        return\n    commands = get_settings().get(f\"gitlab.{commands_conf}\", {})\n    get_settings().set(\"config.is_auto_command\", True)\n    for command in commands:\n        try:\n            split_command = command.split(\" \")\n            command = split_command[0]\n            args = split_command[1:]\n            other_args = update_settings_from_args(args)\n            new_command = ' '.join([command] + other_args)\n            get_logger().info(f\"Performing command: {new_command}\")\n            with get_logger().contextualize(**log_context):\n                await agent.handle_request(api_url, new_command)\n        except Exception as e:\n            get_logger().error(f\"Failed to perform command {command}: {e}\")\n\n\ndef is_bot_user(data) -> bool:\n    try:\n        # logic to ignore bot users (unlike Github, no direct flag for bot users in gitlab)\n        sender_name = data.get(\"user\", {}).get(\"name\", \"unknown\").lower()\n        bot_indicators = ['codium', 'bot_', 'bot-', '_bot', '-bot']\n        if any(indicator in sender_name for indicator in bot_indicators):\n            get_logger().info(f\"Skipping GitLab bot user: {sender_name}\")\n            return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_bot_user' logic: {e}\")\n    return False\n\ndef is_draft(data) -> bool:\n    try:\n        if 'draft' in data.get('object_attributes', {}):\n            return data['object_attributes']['draft']\n\n        # for gitlab server version before 16\n        elif 'Draft:' in data.get('object_attributes', {}).get('title'):\n            return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_draft' logic: {e}\")\n    return False\n\ndef is_draft_ready(data) -> bool:\n    try:\n        if 'draft' in data.get('changes', {}):\n            if data['changes']['draft']['previous'] == 'true' and data['changes']['draft']['current'] == 'false':\n                return True\n            \n        # for gitlab server version before 16\n        elif 'title' in data.get('changes', {}):\n            if 'Draft:' in data['changes']['title']['previous'] and 'Draft:' not in data['changes']['title']['current']:\n                return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_draft_ready' logic: {e}\")\n    return False\n\ndef should_process_pr_logic(data) -> bool:\n    try:\n        if not data.get('object_attributes', {}):\n            return False\n        title = data['object_attributes'].get('title')\n        sender = data.get(\"user\", {}).get(\"username\", \"\")\n\n        # logic to ignore PRs from specific users\n        ignore_pr_users = get_settings().get(\"CONFIG.IGNORE_PR_AUTHORS\", [])\n        if ignore_pr_users and sender:\n            if sender in ignore_pr_users:\n                get_logger().info(f\"Ignoring PR from user '{sender}' due to 'config.ignore_pr_authors' settings\")\n                return False\n\n        # logic to ignore MRs for titles, labels and source, target branches.\n        ignore_mr_title = get_settings().get(\"CONFIG.IGNORE_PR_TITLE\", [])\n        ignore_mr_labels = get_settings().get(\"CONFIG.IGNORE_PR_LABELS\", [])\n        ignore_mr_source_branches = get_settings().get(\"CONFIG.IGNORE_PR_SOURCE_BRANCHES\", [])\n        ignore_mr_target_branches = get_settings().get(\"CONFIG.IGNORE_PR_TARGET_BRANCHES\", [])\n\n        #\n        if ignore_mr_source_branches:\n            source_branch = data['object_attributes'].get('source_branch')\n            if any(re.search(regex, source_branch) for regex in ignore_mr_source_branches):\n                get_logger().info(\n                    f\"Ignoring MR with source branch '{source_branch}' due to gitlab.ignore_mr_source_branches settings\")\n                return False\n\n        if ignore_mr_target_branches:\n            target_branch = data['object_attributes'].get('target_branch')\n            if any(re.search(regex, target_branch) for regex in ignore_mr_target_branches):\n                get_logger().info(\n                    f\"Ignoring MR with target branch '{target_branch}' due to gitlab.ignore_mr_target_branches settings\")\n                return False\n\n        if ignore_mr_labels:\n            labels = [label['title'] for label in data['object_attributes'].get('labels', [])]\n            if any(label in ignore_mr_labels for label in labels):\n                labels_str = \", \".join(labels)\n                get_logger().info(f\"Ignoring MR with labels '{labels_str}' due to gitlab.ignore_mr_labels settings\")\n                return False\n\n        if ignore_mr_title:\n            if any(re.search(regex, title) for regex in ignore_mr_title):\n                get_logger().info(f\"Ignoring MR with title '{title}' due to gitlab.ignore_mr_title settings\")\n                return False\n    except Exception as e:\n        get_logger().error(f\"Failed 'should_process_pr_logic': {e}\")\n    return True\n\n\n@router.post(\"/webhook\")\nasync def gitlab_webhook(background_tasks: BackgroundTasks, request: Request):\n    start_time = datetime.now()\n    request_json = await request.json()\n    context[\"settings\"] = copy.deepcopy(global_settings)\n\n    async def inner(data: dict):\n        log_context = {\"server_type\": \"gitlab_app\"}\n        get_logger().debug(\"Received a GitLab webhook\")\n        if request.headers.get(\"X-Gitlab-Token\") and secret_provider:\n            request_token = request.headers.get(\"X-Gitlab-Token\")\n            secret = secret_provider.get_secret(request_token)\n            if not secret:\n                get_logger().warning(f\"Empty secret retrieved, request_token: {request_token}\")\n                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED,\n                                    content=jsonable_encoder({\"message\": \"unauthorized\"}))\n            try:\n                secret_dict = json.loads(secret)\n                gitlab_token = secret_dict[\"gitlab_token\"]\n                log_context[\"token_id\"] = secret_dict.get(\"token_name\", secret_dict.get(\"id\", \"unknown\"))\n                context[\"settings\"].gitlab.personal_access_token = gitlab_token\n            except Exception as e:\n                get_logger().error(f\"Failed to validate secret {request_token}: {e}\")\n                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n        elif get_settings().get(\"GITLAB.SHARED_SECRET\"):\n            secret = get_settings().get(\"GITLAB.SHARED_SECRET\")\n            if not request.headers.get(\"X-Gitlab-Token\") == secret:\n                get_logger().error(\"Failed to validate secret\")\n                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n        else:\n            get_logger().error(\"Failed to validate secret\")\n            return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n        gitlab_token = get_settings().get(\"GITLAB.PERSONAL_ACCESS_TOKEN\", None)\n        if not gitlab_token:\n            get_logger().error(\"No gitlab token found\")\n            return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n\n        get_logger().info(\"GitLab data\", artifact=data)\n        sender = data.get(\"user\", {}).get(\"username\", \"unknown\")\n        sender_id = data.get(\"user\", {}).get(\"id\", \"unknown\")\n\n        # ignore bot users\n        if is_bot_user(data):\n            return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n        log_context[\"sender\"] = sender\n        if data.get('object_kind') == 'merge_request':\n            # ignore MRs based on title, labels, source and target branches\n            if not should_process_pr_logic(data):\n                return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n            object_attributes = data.get('object_attributes', {})\n            if object_attributes.get('action') in ['open', 'reopen']:\n                url = object_attributes.get('url')\n                get_logger().info(f\"New merge request: {url}\")\n                if is_draft(data):\n                    get_logger().info(f\"Skipping draft MR: {url}\")\n                    return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n                await _perform_commands_gitlab(\"pr_commands\", PRAgent(), url, log_context, data)\n\n            # for push event triggered merge requests\n            elif object_attributes.get('action') == 'update' and object_attributes.get('oldrev'):\n                url = object_attributes.get('url')\n                get_logger().info(f\"New merge request: {url}\")\n                if is_draft(data):\n                    get_logger().info(f\"Skipping draft MR: {url}\")\n                    return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n                commands_on_push = get_settings().get(f\"gitlab.push_commands\", {})\n                handle_push_trigger = get_settings().get(f\"gitlab.handle_push_trigger\", False)\n                if not commands_on_push or not handle_push_trigger:\n                    get_logger().info(\"Push event, but no push commands found or push trigger is disabled\")\n                    return JSONResponse(status_code=status.HTTP_200_OK,\n                                        content=jsonable_encoder({\"message\": \"success\"}))\n\n                get_logger().debug(f'A push event has been received: {url}')\n                await _perform_commands_gitlab(\"push_commands\", PRAgent(), url, log_context, data)\n                \n            # for draft to ready triggered merge requests\n            elif object_attributes.get('action') == 'update' and is_draft_ready(data):\n                url = object_attributes.get('url')\n                get_logger().info(f\"Draft MR is ready: {url}\")\n\n                # same as open MR\n                await _perform_commands_gitlab(\"pr_commands\", PRAgent(), url, log_context, data)\n\n        elif data.get('object_kind') == 'note' and data.get('event_type') == 'note': # comment on MR\n            if 'merge_request' in data:\n                mr = data['merge_request']\n                url = mr.get('url')\n\n                get_logger().info(f\"A comment has been added to a merge request: {url}\")\n                body = data.get('object_attributes', {}).get('note')\n                if data.get('object_attributes', {}).get('type') == 'DiffNote' and '/ask' in body: # /ask_line\n                    body = handle_ask_line(body, data)\n\n                await handle_request(url, body, log_context, sender_id)\n\n    background_tasks.add_task(inner, request_json)\n    end_time = datetime.now()\n    get_logger().info(f\"Processing time: {end_time - start_time}\", request=request_json)\n    return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n\ndef handle_ask_line(body, data):\n    try:\n        line_range_ = data['object_attributes']['position']['line_range']\n        # if line_range_['start']['type'] == 'new':\n        start_line = line_range_['start']['new_line']\n        end_line = line_range_['end']['new_line']\n        # else:\n        #     start_line = line_range_['start']['old_line']\n        #     end_line = line_range_['end']['old_line']\n        question = body.replace('/ask', '').strip()\n        path = data['object_attributes']['position']['new_path']\n        side = 'RIGHT'  # if line_range_['start']['type'] == 'new' else 'LEFT'\n        comment_id = data['object_attributes'][\"discussion_id\"]\n        get_logger().info(\"Handling line comment\")\n        body = f\"/ask_line --line_start={start_line} --line_end={end_line} --side={side} --file_name={path} --comment_id={comment_id} {question}\"\n    except Exception as e:\n        get_logger().error(f\"Failed to handle ask line comment: {e}\")\n    return body\n\n\n@router.get(\"/\")\nasync def root():\n    return {\"status\": \"ok\"}\n\ngitlab_url = get_settings().get(\"GITLAB.URL\", None)\nif not gitlab_url:\n    raise ValueError(\"GITLAB.URL is not set\")\nget_settings().config.git_provider = \"gitlab\"\nmiddleware = [Middleware(RawContextMiddleware)]\napp = FastAPI(middleware=middleware)\napp.include_router(router)\n\n\ndef start():\n    uvicorn.run(app, host=\"0.0.0.0\", port=3000)\n\n\nif __name__ == '__main__':\n    start()\n"}
{"type": "source_file", "path": "pr_agent/secret_providers/google_cloud_storage_secret_provider.py", "content": "import ujson\nfrom google.cloud import storage\n\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.log import get_logger\nfrom pr_agent.secret_providers.secret_provider import SecretProvider\n\n\nclass GoogleCloudStorageSecretProvider(SecretProvider):\n    def __init__(self):\n        try:\n            self.client = storage.Client.from_service_account_info(ujson.loads(get_settings().google_cloud_storage.\n                                                                               service_account))\n            self.bucket_name = get_settings().google_cloud_storage.bucket_name\n            self.bucket = self.client.bucket(self.bucket_name)\n        except Exception as e:\n            get_logger().error(f\"Failed to initialize Google Cloud Storage Secret Provider: {e}\")\n            raise e\n\n    def get_secret(self, secret_name: str) -> str:\n        try:\n            blob = self.bucket.blob(secret_name)\n            return blob.download_as_string()\n        except Exception as e:\n            get_logger().warning(f\"Failed to get secret {secret_name} from Google Cloud Storage: {e}\")\n            return \"\"\n\n    def store_secret(self, secret_name: str, secret_value: str):\n        try:\n            blob = self.bucket.blob(secret_name)\n            blob.upload_from_string(secret_value)\n        except Exception as e:\n            get_logger().error(f\"Failed to store secret {secret_name} in Google Cloud Storage: {e}\")\n            raise e\n"}
{"type": "source_file", "path": "pr_agent/log/__init__.py", "content": "import json\nimport logging\nimport os\nimport sys\nfrom enum import Enum\n\nfrom loguru import logger\n\nfrom pr_agent.config_loader import get_settings\n\n\nclass LoggingFormat(str, Enum):\n    CONSOLE = \"CONSOLE\"\n    JSON = \"JSON\"\n\n\ndef json_format(record: dict) -> str:\n    return record[\"message\"]\n\n\ndef analytics_filter(record: dict) -> bool:\n    return record.get(\"extra\", {}).get(\"analytics\", False)\n\n\ndef inv_analytics_filter(record: dict) -> bool:\n    return not record.get(\"extra\", {}).get(\"analytics\", False)\n\n\ndef setup_logger(level: str = \"INFO\", fmt: LoggingFormat = LoggingFormat.CONSOLE):\n    level: int = logging.getLevelName(level.upper())\n    if type(level) is not int:\n        level = logging.INFO\n\n    if fmt == LoggingFormat.JSON and os.getenv(\"LOG_SANE\", \"0\").lower() == \"0\":  # better debugging github_app\n        logger.remove(None)\n        logger.add(\n            sys.stdout,\n            filter=inv_analytics_filter,\n            level=level,\n            format=\"{message}\",\n            colorize=False,\n            serialize=True,\n        )\n    elif fmt == LoggingFormat.CONSOLE: # does not print the 'extra' fields\n        logger.remove(None)\n        logger.add(sys.stdout, level=level, colorize=True, filter=inv_analytics_filter)\n\n    log_folder = get_settings().get(\"CONFIG.ANALYTICS_FOLDER\", \"\")\n    if log_folder:\n        pid = os.getpid()\n        log_file = os.path.join(log_folder, f\"pr-agent.{pid}.log\")\n        logger.add(\n            log_file,\n            filter=analytics_filter,\n            level=level,\n            format=\"{message}\",\n            colorize=False,\n            serialize=True,\n        )\n\n    return logger\n\n\ndef get_logger(*args, **kwargs):\n    return logger\n"}
{"type": "source_file", "path": "pr_agent/servers/help.py", "content": "class HelpMessage:\n    @staticmethod\n    def get_general_commands_text():\n       commands_text = \"> - **/review**: Request a review of your Pull Request.   \\n\" \\\n                \"> - **/describe**: Update the PR title and description based on the contents of the PR.   \\n\" \\\n                \"> - **/improve [--extended]**: Suggest code improvements. Extended mode provides a higher quality feedback.   \\n\" \\\n                \"> - **/ask \\\\<QUESTION\\\\>**: Ask a question about the PR.   \\n\" \\\n                \"> - **/update_changelog**: Update the changelog based on the PR's contents.   \\n\" \\\n                \"> - **/add_docs** üíé: Generate docstring for new components introduced in the PR.   \\n\" \\\n                \"> - **/generate_labels** üíé: Generate labels for the PR based on the PR's contents.   \\n\" \\\n                \"> - **/analyze** üíé: Automatically analyzes the PR, and presents changes walkthrough for each component.   \\n\\n\" \\\n                \">See the [tools guide](https://pr-agent-docs.codium.ai/tools/) for more details.\\n\" \\\n                \">To list the possible configuration parameters, add a **/config** comment.   \\n\"\n       return commands_text\n\n\n    @staticmethod\n    def get_general_bot_help_text():\n        output = f\"> To invoke the PR-Agent, add a comment using one of the following commands:  \\n{HelpMessage.get_general_commands_text()} \\n\"\n        return output\n\n    @staticmethod\n    def get_review_usage_guide():\n        output =\"**Overview:**\\n\"\n        output +=(\"The `review` tool scans the PR code changes, and generates a PR review which includes several types of feedbacks, such as possible PR issues, security threats and relevant test in the PR. More feedbacks can be [added](https://pr-agent-docs.codium.ai/tools/review/#general-configurations) by configuring the tool.\\n\\n\"\n                  \"The tool can be triggered [automatically](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened) every time a new PR is opened, or can be invoked manually by commenting on any PR.\\n\")\n        output +=\"\"\"\\\n- When commenting, to edit [configurations](https://github.com/Codium-ai/pr-agent/blob/main/pr_agent/settings/configuration.toml#L23) related to the review tool (`pr_reviewer` section), use the following template:\n```\n/review --pr_reviewer.some_config1=... --pr_reviewer.some_config2=...\n```\n- With a [configuration file](https://pr-agent-docs.codium.ai/usage-guide/configuration_options/), use the following template:\n```\n[pr_reviewer]\nsome_config1=...\nsome_config2=...\n```\n    \"\"\"\n\n        output += f\"\\n\\nSee the review [usage page](https://pr-agent-docs.codium.ai/tools/review/) for a comprehensive guide on using this tool.\\n\\n\"\n\n        return output\n\n\n\n    @staticmethod\n    def get_describe_usage_guide():\n        output = \"**Overview:**\\n\"\n        output += \"The `describe` tool scans the PR code changes, and generates a description for the PR - title, type, summary, walkthrough and labels. \"\n        output += \"The tool can be triggered [automatically](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened) every time a new PR is opened, or can be invoked manually by commenting on a PR.\\n\"\n        output += \"\"\"\\\n\nWhen commenting, to edit [configurations](https://github.com/Codium-ai/pr-agent/blob/main/pr_agent/settings/configuration.toml#L46) related to the describe tool (`pr_description` section), use the following template:\n```\n/describe --pr_description.some_config1=... --pr_description.some_config2=...\n```\nWith a [configuration file](https://pr-agent-docs.codium.ai/usage-guide/configuration_options/), use the following template:\n```\n[pr_description]\nsome_config1=...\nsome_config2=...\n```\n\"\"\"\n        output += \"\\n\\n<table>\"\n\n        # automation\n        output += \"<tr><td><details> <summary><strong> Enabling\\\\disabling automation </strong></summary><hr>\\n\\n\"\n        output += \"\"\"\\\n- When you first install the app, the [default mode](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened) for the describe tool is:\n```\npr_commands = [\"/describe\", ...]\n```\nmeaning the `describe` tool will run automatically on every PR.\n\n- Markers are an alternative way to control the generated description, to give maximal control to the user. If you set:\n```\npr_commands = [\"/describe --pr_description.use_description_markers=true\", ...]\n```\nthe tool will replace every marker of the form `pr_agent:marker_name` in the PR description with the relevant content, where `marker_name` is one of the following:\n  - `type`: the PR type.\n  - `summary`: the PR summary.\n  - `walkthrough`: the PR walkthrough.\n\nNote that when markers are enabled, if the original PR description does not contain any markers, the tool will not alter the description at all.\n\n\"\"\"\n        output += \"\\n\\n</details></td></tr>\\n\\n\"\n\n        # custom labels\n        output += \"<tr><td><details> <summary><strong> Custom labels </strong></summary><hr>\\n\\n\"\n        output += \"\"\"\\\nThe default labels of the `describe` tool are quite generic: [`Bug fix`, `Tests`, `Enhancement`, `Documentation`, `Other`].\n\nIf you specify [custom labels](https://pr-agent-docs.codium.ai/tools/describe/#handle-custom-labels-from-the-repos-labels-page) in the repo's labels page or via configuration file, you can get tailored labels for your use cases.\nExamples for custom labels:\n- `Main topic:performance` - pr_agent:The main topic of this PR is performance\n- `New endpoint` - pr_agent:A new endpoint was added in this PR\n- `SQL query` - pr_agent:A new SQL query was added in this PR\n- `Dockerfile changes` - pr_agent:The PR contains changes in the Dockerfile\n- ...\n\nThe list above is eclectic, and aims to give an idea of different possibilities. Define custom labels that are relevant for your repo and use cases.\nNote that Labels are not mutually exclusive, so you can add multiple label categories.\nMake sure to provide proper title, and a detailed and well-phrased description for each label, so the tool will know when to suggest it.\n\"\"\"\n        output += \"\\n\\n</details></td></tr>\\n\\n\"\n\n        # Inline File Walkthrough\n        output += \"<tr><td><details> <summary><strong> Inline File Walkthrough üíé</strong></summary><hr>\\n\\n\"\n        output += \"\"\"\\\nFor enhanced user experience, the `describe` tool can add file summaries directly to the \"Files changed\" tab in the PR page.\nThis will enable you to quickly understand the changes in each file, while reviewing the code changes (diffs).\n\nTo enable inline file summary, set `pr_description.inline_file_summary` in the configuration file, possible values are:\n- `'table'`: File changes walkthrough table will be displayed on the top of the \"Files changed\" tab, in addition to the \"Conversation\" tab.\n- `true`: A collapsable file comment with changes title and a changes summary for each file in the PR.\n- `false` (default): File changes walkthrough will be added only to the \"Conversation\" tab.\n\"\"\"\n\n        # extra instructions\n        output += \"<tr><td><details> <summary><strong> Utilizing extra instructions</strong></summary><hr>\\n\\n\"\n        output += '''\\\nThe `describe` tool can be configured with extra instructions, to guide the model to a feedback tailored to the needs of your project.\n\nBe specific, clear, and concise in the instructions. With extra instructions, you are the prompter. Notice that the general structure of the description is fixed, and cannot be changed. Extra instructions can change the content or style of each sub-section of the PR description.\n\nExamples for extra instructions:\n```\n[pr_description]\nextra_instructions=\"\"\"\\\n- The PR title should be in the format: '<PR type>: <title>'\n- The title should be short and concise (up to 10 words)\n- ...\n\"\"\"\n```\nUse triple quotes to write multi-line instructions. Use bullet points to make the instructions more readable.\n'''\n        output += \"\\n\\n</details></td></tr>\\n\\n\"\n\n\n        # general\n        output += \"\\n\\n<tr><td><details> <summary><strong> More PR-Agent commands</strong></summary><hr> \\n\\n\"\n        output += HelpMessage.get_general_bot_help_text()\n        output += \"\\n\\n</details></td></tr>\\n\\n\"\n\n        output += \"</table>\"\n\n        output += f\"\\n\\nSee the [describe usage](https://pr-agent-docs.codium.ai/tools/describe/) page for a comprehensive guide on using this tool.\\n\\n\"\n\n        return output\n\n    @staticmethod\n    def get_ask_usage_guide():\n        output = \"**Overview:**\\n\"\n        output += \"\"\"\\\nThe `ask` tool answers questions about the PR, based on the PR code changes.\nIt can be invoked manually by commenting on any PR:\n```\n/ask \"...\"\n```\n\nNote that the tool does not have \"memory\" of previous questions, and answers each question independently.\nYou can ask questions about the entire PR, about specific code lines, or about an image related to the PR code changes.\n        \"\"\"\n        # output += \"\\n\\n<table>\"\n        #\n        # # # general\n        # # output += \"\\n\\n<tr><td><details> <summary><strong> More PR-Agent commands</strong></summary><hr> \\n\\n\"\n        # # output += HelpMessage.get_general_bot_help_text()\n        # # output += \"\\n\\n</details></td></tr>\\n\\n\"\n        #\n        # output += \"</table>\"\n\n        output += f\"\\n\\nSee the [ask usage](https://pr-agent-docs.codium.ai/tools/ask/) page for a comprehensive guide on using this tool.\\n\\n\"\n\n        return output\n\n\n    @staticmethod\n    def get_improve_usage_guide():\n        output = \"**Overview:**\\n\"\n        output += \"The code suggestions tool, named `improve`, scans the PR code changes, and automatically generates code suggestions for improving the PR.\"\n        output += \"The tool can be triggered [automatically](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened) every time a new PR is opened, or can be invoked manually by commenting on a PR.\\n\"\n        output += \"\"\"\\\n- When commenting, to edit [configurations](https://github.com/Codium-ai/pr-agent/blob/main/pr_agent/settings/configuration.toml#L78) related to the improve tool (`pr_code_suggestions` section), use the following template:\n\n```\n/improve --pr_code_suggestions.some_config1=... --pr_code_suggestions.some_config2=...\n```\n\n- With a [configuration file](https://pr-agent-docs.codium.ai/usage-guide/configuration_options/), use the following template:\n\n```\n[pr_code_suggestions]\nsome_config1=...\nsome_config2=...\n```\n\n\"\"\"\n\n        output += f\"\\n\\nSee the improve [usage page](https://pr-agent-docs.codium.ai/tools/improve/) for a comprehensive guide on using this tool.\\n\\n\"\n\n        return output\n"}
{"type": "source_file", "path": "pr_agent/servers/serverless.py", "content": "from fastapi import FastAPI\nfrom mangum import Mangum\nfrom starlette.middleware import Middleware\nfrom starlette_context.middleware import RawContextMiddleware\n\nfrom pr_agent.servers.github_app import router\n\nmiddleware = [Middleware(RawContextMiddleware)]\napp = FastAPI(middleware=middleware)\napp.include_router(router)\n\nhandler = Mangum(app, lifespan=\"off\")\n\n\ndef serverless(event, context):\n    return handler(event, context)\n"}
{"type": "source_file", "path": "pr_agent/servers/azuredevops_server_webhook.py", "content": "# This file contains the code for the Azure DevOps Server webhook server.\n# The server listens for incoming webhooks from Azure DevOps Server and forwards them to the PR Agent.\n# ADO webhook documentation: https://learn.microsoft.com/en-us/azure/devops/service-hooks/services/webhooks?view=azure-devops\n\nimport json\nimport os\nimport re\nimport secrets\nfrom urllib.parse import unquote\n\nimport uvicorn\nfrom fastapi import APIRouter, Depends, FastAPI, HTTPException, Request\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.security import HTTPBasic, HTTPBasicCredentials\nfrom starlette import status\nfrom starlette.background import BackgroundTasks\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette_context.middleware import RawContextMiddleware\n\nfrom pr_agent.agent.pr_agent import PRAgent, command2class\nfrom pr_agent.algo.utils import update_settings_from_args\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers.utils import apply_repo_settings\nfrom pr_agent.log import LoggingFormat, get_logger, setup_logger\n\nsetup_logger(fmt=LoggingFormat.JSON, level=\"DEBUG\")\nsecurity = HTTPBasic()\nrouter = APIRouter()\navailable_commands_rgx = re.compile(r\"^\\/(\" + \"|\".join(command2class.keys()) + r\")\\s*\")\nazure_devops_server = get_settings().get(\"azure_devops_server\")\nWEBHOOK_USERNAME = azure_devops_server.get(\"webhook_username\")\nWEBHOOK_PASSWORD = azure_devops_server.get(\"webhook_password\")\n\nasync def handle_request_comment( url: str, body: str, log_context: dict\n):\n    log_context[\"action\"] = body\n    log_context[\"api_url\"] = url\n\n    try:\n        with get_logger().contextualize(**log_context):\n            await PRAgent().handle_request(url, body)\n    except Exception as e:\n        get_logger().exception(f\"Failed to handle webhook\", artifact={\"url\": url, \"body\": body}, error=str(e))\n\n\n# currently only basic auth is supported with azure webhooks\n# for this reason, https must be enabled to ensure the credentials are not sent in clear text\ndef authorize(credentials: HTTPBasicCredentials = Depends(security)):\n        is_user_ok = secrets.compare_digest(credentials.username, WEBHOOK_USERNAME)\n        is_pass_ok = secrets.compare_digest(credentials.password, WEBHOOK_PASSWORD)\n        if not (is_user_ok and is_pass_ok):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail='Incorrect username or password.',\n                headers={'WWW-Authenticate': 'Basic'},\n            )\n\n\nasync def _perform_commands_azure(commands_conf: str, agent: PRAgent, api_url: str, log_context: dict):\n    apply_repo_settings(api_url)\n    if commands_conf == \"pr_commands\" and get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n        get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {api_url=}\", **log_context)\n        return\n    commands = get_settings().get(f\"azure_devops_server.{commands_conf}\")\n    if not commands:\n        return\n\n    get_settings().set(\"config.is_auto_command\", True)\n    for command in commands:\n        try:\n            split_command = command.split(\" \")\n            command = split_command[0]\n            args = split_command[1:]\n            other_args = update_settings_from_args(args)\n            new_command = ' '.join([command] + other_args)\n            get_logger().info(f\"Performing command: {new_command}\")\n            with get_logger().contextualize(**log_context):\n                await agent.handle_request(api_url, new_command)\n        except Exception as e:\n            get_logger().error(f\"Failed to perform command {command}: {e}\")\n\n\nasync def handle_request_azure(data, log_context):\n    actions = []\n    if data[\"eventType\"] == \"git.pullrequest.created\":\n        # API V1 (latest)\n        pr_url = unquote(data[\"resource\"][\"_links\"][\"web\"][\"href\"].replace(\"_apis/git/repositories\", \"_git\"))\n        log_context[\"event\"] = data[\"eventType\"]\n        log_context[\"api_url\"] = pr_url\n        await _perform_commands_azure(\"pr_commands\", PRAgent(), pr_url, log_context)\n        return JSONResponse(\n            status_code=status.HTTP_202_ACCEPTED,\n            content=jsonable_encoder({\"message\": \"webhook triggered successfully\"})\n        )\n    elif data[\"eventType\"] == \"ms.vss-code.git-pullrequest-comment-event\" and \"content\" in data[\"resource\"][\"comment\"]:\n        if available_commands_rgx.match(data[\"resource\"][\"comment\"][\"content\"]):\n            if(data[\"resourceVersion\"] == \"2.0\"):\n                repo = data[\"resource\"][\"pullRequest\"][\"repository\"][\"webUrl\"]\n                pr_url = unquote(f'{repo}/pullrequest/{data[\"resource\"][\"pullRequest\"][\"pullRequestId\"]}')\n                actions = [data[\"resource\"][\"comment\"][\"content\"]]\n            else:\n                # API V1 not supported as it does not contain the PR URL\n                return JSONResponse(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    content=json.dumps({\"message\": \"version 1.0 webhook for Azure Devops PR comment is not supported. please upgrade to version 2.0\"})),\n        else:\n            return JSONResponse(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                content=json.dumps({\"message\": \"Unsupported command\"}),\n            )\n    else:\n        return JSONResponse(\n            status_code=status.HTTP_204_NO_CONTENT,\n            content=json.dumps({\"message\": \"Unsupported event\"}),\n        )\n\n    log_context[\"event\"] = data[\"eventType\"]\n    log_context[\"api_url\"] = pr_url\n\n    for action in actions:\n        try:\n            await handle_request_comment(pr_url, action, log_context)\n        except Exception as e:\n            get_logger().error(\"Azure DevOps Trigger failed. Error:\" + str(e))\n            return JSONResponse(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                content=json.dumps({\"message\": \"Internal server error\"}),\n            )\n    return JSONResponse(\n        status_code=status.HTTP_202_ACCEPTED, content=jsonable_encoder({\"message\": \"webhook triggered successfully\"})\n    )\n\n@router.post(\"/\", dependencies=[Depends(authorize)])\nasync def handle_webhook(background_tasks: BackgroundTasks, request: Request):\n    log_context = {\"server_type\": \"azure_devops_server\"}\n    data = await request.json()\n    # get_logger().info(json.dumps(data))\n\n    background_tasks.add_task(handle_request_azure, data, log_context)\n\n    return JSONResponse(\n        status_code=status.HTTP_202_ACCEPTED, content=jsonable_encoder({\"message\": \"webhook triggered successfully\"})\n    )\n\n@router.get(\"/\")\nasync def root():\n    return {\"status\": \"ok\"}\n\ndef start():\n    app = FastAPI(middleware=[Middleware(RawContextMiddleware)])\n    app.include_router(router)\n    uvicorn.run(app, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", \"3000\")))\n\nif __name__ == \"__main__\":\n    start()\n"}
{"type": "source_file", "path": "pr_agent/identity_providers/default_identity_provider.py", "content": "from pr_agent.identity_providers.identity_provider import (Eligibility,\n                                                           IdentityProvider)\n\n\nclass DefaultIdentityProvider(IdentityProvider):\n    def verify_eligibility(self, git_provider, git_provider_id, pr_url):\n        return Eligibility.ELIGIBLE\n\n    def inc_invocation_count(self, git_provider, git_provider_id):\n        pass\n"}
{"type": "source_file", "path": "pr_agent/servers/__init__.py", "content": ""}
{"type": "source_file", "path": "pr_agent/servers/gunicorn_config.py", "content": "import multiprocessing\nimport os\n\n# from prometheus_client import multiprocess\n\n# Sample Gunicorn configuration file.\n\n#\n# Server socket\n#\n#   bind - The socket to bind.\n#\n#       A string of the form: 'HOST', 'HOST:PORT', 'unix:PATH'.\n#       An IP is a valid HOST.\n#\n#   backlog - The number of pending connections. This refers\n#       to the number of clients that can be waiting to be\n#       served. Exceeding this number results in the client\n#       getting an error when attempting to connect. It should\n#       only affect servers under significant load.\n#\n#       Must be a positive integer. Generally set in the 64-2048\n#       range.\n#\n\n# bind = '0.0.0.0:5000'\nbind = '0.0.0.0:3000'\nbacklog = 2048\n\n#\n# Worker processes\n#\n#   workers - The number of worker processes that this server\n#       should keep alive for handling requests.\n#\n#       A positive integer generally in the 2-4 x $(NUM_CORES)\n#       range. You'll want to vary this a bit to find the best\n#       for your particular application's work load.\n#\n#   worker_class - The type of workers to use. The default\n#       sync class should handle most 'normal' types of work\n#       loads. You'll want to read\n#       http://docs.gunicorn.org/en/latest/design.html#choosing-a-worker-type\n#       for information on when you might want to choose one\n#       of the other worker classes.\n#\n#       A string referring to a Python path to a subclass of\n#       gunicorn.workers.base.Worker. The default provided values\n#       can be seen at\n#       http://docs.gunicorn.org/en/latest/settings.html#worker-class\n#\n#   worker_connections - For the eventlet and gevent worker classes\n#       this limits the maximum number of simultaneous clients that\n#       a single process can handle.\n#\n#       A positive integer generally set to around 1000.\n#\n#   timeout - If a worker does not notify the master process in this\n#       number of seconds it is killed and a new worker is spawned\n#       to replace it.\n#\n#       Generally set to thirty seconds. Only set this noticeably\n#       higher if you're sure of the repercussions for sync workers.\n#       For the non sync workers it just means that the worker\n#       process is still communicating and is not tied to the length\n#       of time required to handle a single request.\n#\n#   keepalive - The number of seconds to wait for the next request\n#       on a Keep-Alive HTTP connection.\n#\n#       A positive integer. Generally set in the 1-5 seconds range.\n#\n\nif os.getenv('GUNICORN_WORKERS', None):\n    workers = int(os.getenv('GUNICORN_WORKERS'))\nelse:\n    cores = multiprocessing.cpu_count()\n    workers = cores * 2 + 1\nworker_connections = 1000\ntimeout = 240\nkeepalive = 2\n\n#\n#   spew - Install a trace function that spews every line of Python\n#       that is executed when running the server. This is the\n#       nuclear option.\n#\n#       True or False\n#\n\nspew = False\n\n#\n# Server mechanics\n#\n#   daemon - Detach the main Gunicorn process from the controlling\n#       terminal with a standard fork/fork sequence.\n#\n#       True or False\n#\n#   raw_env - Pass environment variables to the execution environment.\n#\n#   pidfile - The path to a pid file to write\n#\n#       A path string or None to not write a pid file.\n#\n#   user - Switch worker processes to run as this user.\n#\n#       A valid user id (as an integer) or the name of a user that\n#       can be retrieved with a call to pwd.getpwnam(value) or None\n#       to not change the worker process user.\n#\n#   group - Switch worker process to run as this group.\n#\n#       A valid group id (as an integer) or the name of a user that\n#       can be retrieved with a call to pwd.getgrnam(value) or None\n#       to change the worker processes group.\n#\n#   umask - A mask for file permissions written by Gunicorn. Note that\n#       this affects unix socket permissions.\n#\n#       A valid value for the os.umask(mode) call or a string\n#       compatible with int(value, 0) (0 means Python guesses\n#       the base, so values like \"0\", \"0xFF\", \"0022\" are valid\n#       for decimal, hex, and octal representations)\n#\n#   tmp_upload_dir - A directory to store temporary request data when\n#       requests are read. This will most likely be disappearing soon.\n#\n#       A path to a directory where the process owner can write. Or\n#       None to signal that Python should choose one on its own.\n#\n\ndaemon = False\nraw_env = []\npidfile = None\numask = 0\nuser = None\ngroup = None\ntmp_upload_dir = None\n\n#\n#   Logging\n#\n#   logfile - The path to a log file to write to.\n#\n#       A path string. \"-\" means log to stdout.\n#\n#   loglevel - The granularity of log output\n#\n#       A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"\n#\n\nerrorlog = '-'\nloglevel = 'info'\naccesslog = None\naccess_log_format = '%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"'\n\n#\n# Process naming\n#\n#   proc_name - A base to use with setproctitle to change the way\n#       that Gunicorn processes are reported in the system process\n#       table. This affects things like 'ps' and 'top'. If you're\n#       going to be running more than one instance of Gunicorn you'll\n#       probably want to set a name to tell them apart. This requires\n#       that you install the setproctitle module.\n#\n#       A string or None to choose a default of something like 'gunicorn'.\n#\n\nproc_name = None\n\n\n#\n# Server hooks\n#\n#   post_fork - Called just after a worker has been forked.\n#\n#       A callable that takes a server and worker instance\n#       as arguments.\n#\n#   pre_fork - Called just prior to forking the worker subprocess.\n#\n#       A callable that accepts the same arguments as after_fork\n#\n#   pre_exec - Called just prior to forking off a secondary\n#       master process during things like config reloading.\n#\n#       A callable that takes a server instance as the sole argument.\n#\n"}
{"type": "source_file", "path": "pr_agent/identity_providers/__init__.py", "content": "from pr_agent.config_loader import get_settings\nfrom pr_agent.identity_providers.default_identity_provider import \\\n    DefaultIdentityProvider\n\n_IDENTITY_PROVIDERS = {\n    'default': DefaultIdentityProvider\n}\n\n\ndef get_identity_provider():\n    identity_provider_id = get_settings().get(\"CONFIG.IDENTITY_PROVIDER\", \"default\")\n    if identity_provider_id not in _IDENTITY_PROVIDERS:\n        raise ValueError(f\"Unknown identity provider: {identity_provider_id}\")\n    return _IDENTITY_PROVIDERS[identity_provider_id]()\n"}
{"type": "source_file", "path": "pr_agent/servers/bitbucket_server_webhook.py", "content": "import ast\nimport json\nimport os\nfrom typing import List\n\nimport uvicorn\nfrom fastapi import APIRouter, FastAPI\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import RedirectResponse\nfrom starlette import status\nfrom starlette.background import BackgroundTasks\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette_context.middleware import RawContextMiddleware\n\nfrom pr_agent.agent.pr_agent import PRAgent\nfrom pr_agent.algo.utils import update_settings_from_args\nfrom pr_agent.config_loader import get_settings\nfrom pr_agent.git_providers.utils import apply_repo_settings\nfrom pr_agent.log import LoggingFormat, get_logger, setup_logger\nfrom pr_agent.servers.utils import verify_signature\n\nsetup_logger(fmt=LoggingFormat.JSON, level=\"DEBUG\")\nrouter = APIRouter()\n\n\ndef handle_request(\n    background_tasks: BackgroundTasks, url: str, body: str, log_context: dict\n):\n    log_context[\"action\"] = body\n    log_context[\"api_url\"] = url\n\n    async def inner():\n        try:\n            with get_logger().contextualize(**log_context):\n                await PRAgent().handle_request(url, body)\n        except Exception as e:\n            get_logger().error(f\"Failed to handle webhook: {e}\")\n\n    background_tasks.add_task(inner)\n\n@router.post(\"/\")\nasync def redirect_to_webhook():\n    return RedirectResponse(url=\"/webhook\")\n\n@router.post(\"/webhook\")\nasync def handle_webhook(background_tasks: BackgroundTasks, request: Request):\n    log_context = {\"server_type\": \"bitbucket_server\"}\n    data = await request.json()\n    get_logger().info(json.dumps(data))\n\n    webhook_secret = get_settings().get(\"BITBUCKET_SERVER.WEBHOOK_SECRET\", None)\n    if webhook_secret:\n        body_bytes = await request.body()\n        if body_bytes.decode('utf-8') == '{\"test\": true}':\n            return JSONResponse(\n                status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"connection test successful\"})\n            )\n        signature_header = request.headers.get(\"x-hub-signature\", None)\n        verify_signature(body_bytes, webhook_secret, signature_header)\n\n    pr_id = data[\"pullRequest\"][\"id\"]\n    repository_name = data[\"pullRequest\"][\"toRef\"][\"repository\"][\"slug\"]\n    project_name = data[\"pullRequest\"][\"toRef\"][\"repository\"][\"project\"][\"key\"]\n    bitbucket_server = get_settings().get(\"BITBUCKET_SERVER.URL\")\n    pr_url = f\"{bitbucket_server}/projects/{project_name}/repos/{repository_name}/pull-requests/{pr_id}\"\n\n    log_context[\"api_url\"] = pr_url\n    log_context[\"event\"] = \"pull_request\"\n\n    commands_to_run = []\n\n    if data[\"eventKey\"] == \"pr:opened\":\n        apply_repo_settings(pr_url)\n        if get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n            get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {pr_url}\", **log_context)\n            return\n        get_settings().set(\"config.is_auto_command\", True)\n        commands_to_run.extend(_get_commands_list_from_settings('BITBUCKET_SERVER.PR_COMMANDS'))\n    elif data[\"eventKey\"] == \"pr:comment:added\":\n        commands_to_run.append(data[\"comment\"][\"text\"])\n    else:\n        return JSONResponse(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            content=json.dumps({\"message\": \"Unsupported event\"}),\n        )\n\n    async def inner():\n        try:\n            await _run_commands_sequentially(commands_to_run, pr_url, log_context)\n        except Exception as e:\n            get_logger().error(f\"Failed to handle webhook: {e}\")\n\n    background_tasks.add_task(inner)\n\n    return JSONResponse(\n        status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"})\n    )\n\n\nasync def _run_commands_sequentially(commands: List[str], url: str, log_context: dict):\n    get_logger().info(f\"Running commands sequentially: {commands}\")\n    if commands is None:\n        return\n\n    for command in commands:\n        try:\n            body = _process_command(command, url)\n\n            log_context[\"action\"] = body\n            log_context[\"api_url\"] = url\n\n            with get_logger().contextualize(**log_context):\n                await PRAgent().handle_request(url, body)\n        except Exception as e:\n            get_logger().error(f\"Failed to handle command: {command} , error: {e}\")\n\ndef _process_command(command: str, url) -> str:\n    # don't think we need this\n    apply_repo_settings(url)\n    # Process the command string\n    split_command = command.split(\" \")\n    command = split_command[0]\n    args = split_command[1:]\n    # do I need this? if yes, shouldn't this be done in PRAgent?\n    other_args = update_settings_from_args(args)\n    new_command = ' '.join([command] + other_args)\n    return new_command\n\n\ndef _to_list(command_string: str) -> list:\n    try:\n        # Use ast.literal_eval to safely parse the string into a list\n        commands = ast.literal_eval(command_string)\n        # Check if the parsed object is a list of strings\n        if isinstance(commands, list) and all(isinstance(cmd, str) for cmd in commands):\n            return commands\n        else:\n            raise ValueError(\"Parsed data is not a list of strings.\")\n    except (SyntaxError, ValueError, TypeError) as e:\n        raise ValueError(f\"Invalid command string: {e}\")\n\n\ndef _get_commands_list_from_settings(setting_key:str ) -> list:\n    try:\n        return get_settings().get(setting_key, [])\n    except ValueError as e:\n        get_logger().error(f\"Failed to get commands list from settings {setting_key}: {e}\")\n\n\n@router.get(\"/\")\nasync def root():\n    return {\"status\": \"ok\"}\n\n\ndef start():\n    app = FastAPI(middleware=[Middleware(RawContextMiddleware)])\n    app.include_router(router)\n    uvicorn.run(app, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", \"3000\")))\n\n\nif __name__ == \"__main__\":\n    start()\n"}

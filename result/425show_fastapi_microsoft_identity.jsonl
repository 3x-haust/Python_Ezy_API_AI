{"repo_info": {"repo_name": "fastapi_microsoft_identity", "repo_owner": "425show", "repo_url": "https://github.com/425show/fastapi_microsoft_identity"}}
{"type": "test_file", "path": "tests/test_azure_ad.py", "content": "# Sample Test passing with nose and pytest\nimport pytest\nfrom fastapi import Request\nimport sys\nimport os\n\ncontainer_folder = os.path.abspath(os.path.join(\n    os.path.dirname(__file__), '..'\n))\nsys.path.insert(0, container_folder)\n\nfrom fastapi_microsoft_identity import auth_service, AuthError\nfrom multidict import MultiDict\n\nuser_token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Imk2bEdrM0ZaenhSY1ViMkMzbkVRN3N5SEpsWSJ9.eyJhdWQiOiI2ZTc0MTcyYi1iZTU2LTQ4NDMtOWZmNC1lNjZhMzliYjEyZTMiLCJpc3MiOiJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vNzJmOTg4YmYtODZmMS00MWFmLTkxYWItMmQ3Y2QwMTFkYjQ3L3YyLjAiLCJpYXQiOjE1MzcyMzEwNDgsIm5iZiI6MTUzNzIzMTA0OCwiZXhwIjoxNTM3MjM0OTQ4LCJhaW8iOiJBWFFBaS84SUFBQUF0QWFaTG8zQ2hNaWY2S09udHRSQjdlQnE0L0RjY1F6amNKR3hQWXkvQzNqRGFOR3hYZDZ3TklJVkdSZ2hOUm53SjFsT2NBbk5aY2p2a295ckZ4Q3R0djMzMTQwUmlvT0ZKNGJDQ0dWdW9DYWcxdU9UVDIyMjIyZ0h3TFBZUS91Zjc5UVgrMEtJaWpkcm1wNjlSY3R6bVE9PSIsImF6cCI6IjZlNzQxNzJiLWJlNTYtNDg0My05ZmY0LWU2NmEzOWJiMTJlMyIsImF6cGFjciI6IjAiLCJuYW1lIjoiQWJlIExpbmNvbG4iLCJvaWQiOiI2OTAyMjJiZS1mZjFhLTRkNTYtYWJkMS03ZTRmN2QzOGU0NzQiLCJwcmVmZXJyZWRfdXNlcm5hbWUiOiJhYmVsaUBtaWNyb3NvZnQuY29tIiwicmgiOiJJIiwic2NwIjoiYWNjZXNzX2FzX3VzZXIiLCJzdWIiOiJIS1pwZmFIeVdhZGVPb3VZbGl0anJJLUtmZlRtMjIyWDVyclYzeERxZktRIiwidGlkIjoiNzJmOTg4YmYtODZmMS00MWFmLTkxYWItMmQ3Y2QwMTFkYjQ3IiwidXRpIjoiZnFpQnFYTFBqMGVRYTgyUy1JWUZBQSIsInZlciI6IjIuMCJ9.pj4N-w_3Us9DrBLfpCt\"\napplication_token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik1yNS1BVWliZkJpaTdOZDFqQmViYXhib1hXMCJ9.eyJhdWQiOiJkZTI2NTZlNi01ODVmLTQ2ODQtOGU2NS0zY2U1MGE3NzcwYTgiLCJpc3MiOiJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vNjZiYTk0NzYtMDcwMC00MTc4LTgxZWEtZmJlYjcwOTdjMjhlL3YyLjAiLCJpYXQiOjE2NDYxNjc1NzIsIm5iZiI6MTY0NjE2NzU3MiwiZXhwIjoxNjQ2MTcxNDcyLCJhaW8iOiJFMlpnWVBoN2RoSFBLNGNuOFE1TUFob01CenAwQVE9PSIsImF6cCI6ImY3NTllY2FiLWM0NWUtNDVlZS1hYWZmLWJlMzJhZmM3ZGU5YiIsImF6cGFjciI6IjEiLCJvaWQiOiIyMTJkOGM2ZS05YzdmLTQ4MWEtOGZkOC1kOTllMzVhOWNiMWMiLCJyaCI6IjAuQVZBQWRwUzZaZ0FIZUVHQjZ2dnJjSmZDanVaV0p0NWZXSVJHam1VODVRcDNjS2hfQUFBLiIsInJvbGVzIjpbImFwcC53ZWF0aGVyLnJlYWQiXSwic3ViIjoiMjEyZDhjNmUtOWM3Zi00ODFhLThmZDgtZDk5ZTM1YTljYjFjIiwidGlkIjoiNjZiYTk0NzYtMDcwMC00MTc4LTgxZWEtZmJlYjcwOTdjMjhlIiwidXRpIjoiX1lYOWhSbElvMGVwX2c3bk9KeXpBUSIsInZlciI6IjIuMCJ9.omq5Abe7rObD_-NDZ64KB3hf3pfCOCS4Sk3cz-jA_4cd49zwzq7wOI8CtXq5vhLUpbwRGCGiZqG-WYmTrTmDwNn2KcsEL8SQkKK5FCOriit8PrDVBAbidAAZsp8OgchhuNBdzp4wUUB7X3cQPk2g6XVOchqvw6MJZVFxi8r5Kqxq8AMJJlHO-ijUX5qKRcrIHkhezFjtGs-TV1dgdpGshKcWhpA635ehRFigY0Hry6vyYaPuiwufp2iMXJ1ZT6ZHqFIE_HeQNLTo39zV5CzVQ4UHH9gDMHfqSbEEO79JyZfNF_HjH40fmvj5HKA8nOEL_LG7fFy3p4BPiVAeUqeUvw\"\n\nauth_service.initialize(\n    \"66ba9476-0700-4178-81ea-fbeb7097c28e\", \n    \"de2656e6-585f-4684-8e65-3ce50a7770a8\")\n\ndef test_auth_header_has_token():\n    headers_with_auth = MultiDict([(\"Authorization\", f'Bearer {user_token}'), (\"Content-Type\", \"application/json\")])\n    request = Request\n    request.headers = headers_with_auth\n    token = auth_service.get_token_auth_header(request)\n    assert token != None, \"Retrieved token from auth header successfully!\"\n\ndef test_auth_header_is_missing():\n    headers_with_no_auth = MultiDict([(\"Content-Type\", \"application/json\")])\n    request = Request\n    request.headers = headers_with_no_auth\n    with pytest.raises(AuthError):\n        auth_service.get_token_auth_header(request)\n\ndef test_can_find_user_scope():\n    expected_scope = \"access_as_user\"\n    headers_with_auth = MultiDict([(\"Authorization\", f'Bearer {user_token}'), (\"Content-Type\", \"application/json\")])\n    request = Request\n    request.headers = headers_with_auth\n    auth_service.validate_scope(expected_scope,request)\n\ndef test_can_find_user_scope_but_is_wrong():\n    expected_scope = \"access_as_user2\"\n    headers_with_auth = MultiDict([(\"Authorization\", f'Bearer {user_token}'), (\"Content-Type\", \"application/json\")])\n    request = Request\n    request.headers = headers_with_auth\n    with pytest.raises(AuthError) as e:\n        auth_service.validate_scope(expected_scope,request)\n    assert \"IDW10203\" in e.value.error_msg\n\ndef test_can_find_application_role():\n    expected_scope = \"app.weather.read\"\n    headers_with_auth = MultiDict([(\"Authorization\", f'Bearer {application_token}'), (\"Content-Type\", \"application/json\")])\n    request = Request\n    request.headers = headers_with_auth\n    auth_service.validate_scope(expected_scope,request)\n\ndef test_can_find_application_role_but_is_wrong():\n    expected_scope = \"access_as_user\"\n    headers_with_auth = MultiDict([(\"Authorization\", f'Bearer {application_token}'), (\"Content-Type\", \"application/json\")])\n    request = Request\n    request.headers = headers_with_auth\n    with pytest.raises(AuthError) as e:\n        auth_service.validate_scope(expected_scope,request)\n    assert \"IDW10203\" in e.value.error_msg\n\ndef test_can_retrieve_user_token_claims():\n    headers_with_auth = MultiDict([(\"Authorization\", f'Bearer {user_token}'), (\"Content-Type\", \"application/json\")])\n    request = Request\n    request.headers = headers_with_auth\n    claims = auth_service.get_token_claims(request)\n    assert claims != None, \"Retrieved token claims successfully!\"\n\ndef test_can_retrieve_application_token_claims():\n    headers_with_auth = MultiDict([(\"Authorization\", f'Bearer {application_token}'), (\"Content-Type\", \"application/json\")])\n    request = Request\n    request.headers = headers_with_auth\n    claims = auth_service.get_token_claims(request)\n    assert claims != None, \"Retrieved token claims successfully!\"\n\n\n"}
{"type": "source_file", "path": ".venv/Scripts/pyrsa-encrypt-script.py", "content": "#!C:\\Users\\chmatsk\\Projects\\fastapi_microsoft_identity\\.venv\\Scripts\\python.exe\n# EASY-INSTALL-ENTRY-SCRIPT: 'rsa','console_scripts','pyrsa-encrypt'\nimport re\nimport sys\n\n# for compatibility with easy_install; see #2198\n__requires__ = 'rsa'\n\ntry:\n    from importlib.metadata import distribution\nexcept ImportError:\n    try:\n        from importlib_metadata import distribution\n    except ImportError:\n        from pkg_resources import load_entry_point\n\n\ndef importlib_load_entry_point(spec, group, name):\n    dist_name, _, _ = spec.partition('==')\n    matches = (\n        entry_point\n        for entry_point in distribution(dist_name).entry_points\n        if entry_point.group == group and entry_point.name == name\n    )\n    return next(matches).load()\n\n\nglobals().setdefault('load_entry_point', importlib_load_entry_point)\n\n\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0])\n    sys.exit(load_entry_point('rsa', 'console_scripts', 'pyrsa-encrypt')())\n"}
{"type": "source_file", "path": ".venv/Scripts/pyrsa-sign-script.py", "content": "#!C:\\Users\\chmatsk\\Projects\\fastapi_microsoft_identity\\.venv\\Scripts\\python.exe\n# EASY-INSTALL-ENTRY-SCRIPT: 'rsa','console_scripts','pyrsa-sign'\nimport re\nimport sys\n\n# for compatibility with easy_install; see #2198\n__requires__ = 'rsa'\n\ntry:\n    from importlib.metadata import distribution\nexcept ImportError:\n    try:\n        from importlib_metadata import distribution\n    except ImportError:\n        from pkg_resources import load_entry_point\n\n\ndef importlib_load_entry_point(spec, group, name):\n    dist_name, _, _ = spec.partition('==')\n    matches = (\n        entry_point\n        for entry_point in distribution(dist_name).entry_points\n        if entry_point.group == group and entry_point.name == name\n    )\n    return next(matches).load()\n\n\nglobals().setdefault('load_entry_point', importlib_load_entry_point)\n\n\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0])\n    sys.exit(load_entry_point('rsa', 'console_scripts', 'pyrsa-sign')())\n"}
{"type": "source_file", "path": ".venv/Scripts/pyrsa-priv2pub-script.py", "content": "#!C:\\Users\\chmatsk\\Projects\\fastapi_microsoft_identity\\.venv\\Scripts\\python.exe\n# EASY-INSTALL-ENTRY-SCRIPT: 'rsa','console_scripts','pyrsa-priv2pub'\nimport re\nimport sys\n\n# for compatibility with easy_install; see #2198\n__requires__ = 'rsa'\n\ntry:\n    from importlib.metadata import distribution\nexcept ImportError:\n    try:\n        from importlib_metadata import distribution\n    except ImportError:\n        from pkg_resources import load_entry_point\n\n\ndef importlib_load_entry_point(spec, group, name):\n    dist_name, _, _ = spec.partition('==')\n    matches = (\n        entry_point\n        for entry_point in distribution(dist_name).entry_points\n        if entry_point.group == group and entry_point.name == name\n    )\n    return next(matches).load()\n\n\nglobals().setdefault('load_entry_point', importlib_load_entry_point)\n\n\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0])\n    sys.exit(load_entry_point('rsa', 'console_scripts', 'pyrsa-priv2pub')())\n"}
{"type": "source_file", "path": ".venv/Scripts/normalizer-script.py", "content": "#!C:\\Users\\chmatsk\\Projects\\fastapi_microsoft_identity\\.venv\\Scripts\\python.exe\n# EASY-INSTALL-ENTRY-SCRIPT: 'charset-normalizer','console_scripts','normalizer'\nimport re\nimport sys\n\n# for compatibility with easy_install; see #2198\n__requires__ = 'charset-normalizer'\n\ntry:\n    from importlib.metadata import distribution\nexcept ImportError:\n    try:\n        from importlib_metadata import distribution\n    except ImportError:\n        from pkg_resources import load_entry_point\n\n\ndef importlib_load_entry_point(spec, group, name):\n    dist_name, _, _ = spec.partition('==')\n    matches = (\n        entry_point\n        for entry_point in distribution(dist_name).entry_points\n        if entry_point.group == group and entry_point.name == name\n    )\n    return next(matches).load()\n\n\nglobals().setdefault('load_entry_point', importlib_load_entry_point)\n\n\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0])\n    sys.exit(load_entry_point('charset-normalizer', 'console_scripts', 'normalizer')())\n"}
{"type": "source_file", "path": ".venv/Scripts/pyrsa-keygen-script.py", "content": "#!C:\\Users\\chmatsk\\Projects\\fastapi_microsoft_identity\\.venv\\Scripts\\python.exe\n# EASY-INSTALL-ENTRY-SCRIPT: 'rsa','console_scripts','pyrsa-keygen'\nimport re\nimport sys\n\n# for compatibility with easy_install; see #2198\n__requires__ = 'rsa'\n\ntry:\n    from importlib.metadata import distribution\nexcept ImportError:\n    try:\n        from importlib_metadata import distribution\n    except ImportError:\n        from pkg_resources import load_entry_point\n\n\ndef importlib_load_entry_point(spec, group, name):\n    dist_name, _, _ = spec.partition('==')\n    matches = (\n        entry_point\n        for entry_point in distribution(dist_name).entry_points\n        if entry_point.group == group and entry_point.name == name\n    )\n    return next(matches).load()\n\n\nglobals().setdefault('load_entry_point', importlib_load_entry_point)\n\n\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0])\n    sys.exit(load_entry_point('rsa', 'console_scripts', 'pyrsa-keygen')())\n"}
{"type": "source_file", "path": "fastapi_microsoft_identity/__init__.py", "content": "\"\"\"fastapi_microsoft_identity - Azure AD authentication for Fast API\"\"\"\n\n__version__ = '0.1.4'\n__author__ = 'Christos Matskas <christos.matskas@microsoft.com>'\n__all__ = []\nfrom .auth_service import initialize, AuthError, validate_scope, requires_auth, requires_b2c_auth, get_token_claims\n"}
{"type": "source_file", "path": ".venv/Scripts/pyrsa-decrypt-script.py", "content": "#!C:\\Users\\chmatsk\\Projects\\fastapi_microsoft_identity\\.venv\\Scripts\\python.exe\n# EASY-INSTALL-ENTRY-SCRIPT: 'rsa','console_scripts','pyrsa-decrypt'\nimport re\nimport sys\n\n# for compatibility with easy_install; see #2198\n__requires__ = 'rsa'\n\ntry:\n    from importlib.metadata import distribution\nexcept ImportError:\n    try:\n        from importlib_metadata import distribution\n    except ImportError:\n        from pkg_resources import load_entry_point\n\n\ndef importlib_load_entry_point(spec, group, name):\n    dist_name, _, _ = spec.partition('==')\n    matches = (\n        entry_point\n        for entry_point in distribution(dist_name).entry_points\n        if entry_point.group == group and entry_point.name == name\n    )\n    return next(matches).load()\n\n\nglobals().setdefault('load_entry_point', importlib_load_entry_point)\n\n\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0])\n    sys.exit(load_entry_point('rsa', 'console_scripts', 'pyrsa-decrypt')())\n"}
{"type": "source_file", "path": ".venv/Scripts/pyrsa-verify-script.py", "content": "#!C:\\Users\\chmatsk\\Projects\\fastapi_microsoft_identity\\.venv\\Scripts\\python.exe\n# EASY-INSTALL-ENTRY-SCRIPT: 'rsa','console_scripts','pyrsa-verify'\nimport re\nimport sys\n\n# for compatibility with easy_install; see #2198\n__requires__ = 'rsa'\n\ntry:\n    from importlib.metadata import distribution\nexcept ImportError:\n    try:\n        from importlib_metadata import distribution\n    except ImportError:\n        from pkg_resources import load_entry_point\n\n\ndef importlib_load_entry_point(spec, group, name):\n    dist_name, _, _ = spec.partition('==')\n    matches = (\n        entry_point\n        for entry_point in distribution(dist_name).entry_points\n        if entry_point.group == group and entry_point.name == name\n    )\n    return next(matches).load()\n\n\nglobals().setdefault('load_entry_point', importlib_load_entry_point)\n\n\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0])\n    sys.exit(load_entry_point('rsa', 'console_scripts', 'pyrsa-verify')())\n"}
{"type": "source_file", "path": "setup.py", "content": "import io\nimport os\nimport re\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\ndef read(filename):\n    filename = os.path.join(os.path.dirname(__file__), filename)\n    text_type = type(u\"\")\n    with io.open(filename, mode=\"r\", encoding='utf-8') as fd:\n        return re.sub(text_type(r':[a-z]+:`~?(.*?)`'), text_type(r'``\\1``'), fd.read())\n\nwith open('./requirements.txt', 'r', encoding='utf-8') as fin:\n    requires_list = [line.strip() for line in fin if line and line.strip()]\n\nsetup(\n    name=\"fastapi_microsoft_identity\",\n    version=\"0.1.4\",\n    url=\"https://github.com/425Show/fastapi_microsoft_identity\",\n    license='MIT',\n\n    author=\"Christos Matskas\",\n    author_email=\"christos.matskas@microsoft.com\",\n\n    description=\"Azure AD authentication for Fast API\",\n    long_description=read(\"README.md\"),\n    long_description_content_type=\"text/markdown\",\n\n    packages=find_packages(exclude=('tests',)),\n\n    install_requires=requires_list,\n\n    classifiers=[\n        'Development Status :: 2 - Pre-Alpha',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10'\n    ],\n)\n"}
{"type": "source_file", "path": "fastapi_microsoft_identity/auth_service.py", "content": "import httpx\nfrom httpx import Response\nfrom fastapi import Request\nfrom functools import wraps\nfrom jose import jwt\nimport fastapi\n\ntenant_id=None\nclient_id=None\nb2c_policy_name = None\nb2c_domain_name = None\n\ndef initialize(\n    tenant_id_, \n    client_id_,\n    b2c_policy_name_=None, \n    b2c_domain_name_=None):\n    global tenant_id, client_id, b2c_policy_name, b2c_domain_name\n    tenant_id = tenant_id_\n    client_id = client_id_\n    b2c_policy_name = b2c_policy_name_\n    b2c_domain_name = b2c_domain_name_\n\nclass AuthError(Exception):\n    def __init__(self, error_msg:str, status_code:int):\n        super().__init__(error_msg)\n\n        self.error_msg = error_msg\n        self.status_code = status_code\n\ndef get_token_auth_header(request: Request):\n    auth = request.headers.get(\"Authorization\", None)\n    if not auth:\n        raise AuthError(\"Authentication error: Authorization header is missing\", 401)\n\n    parts = auth.split()\n\n    if parts[0].lower() != \"bearer\":\n        raise AuthError(\"Authentication error: Authorization header must start with ' Bearer'\", 401)\n    elif len(parts) == 1:\n        raise AuthError(\"Authentication error: Token not found\", 401)\n    elif len(parts) > 2:\n        raise AuthError(\"Authentication error: Authorization header must be 'Bearer <token>'\", 401)\n\n    token = parts[1]\n    return token\n\ndef get_token_claims(request: Request):\n    token = get_token_auth_header(request)\n    unverified_claims = jwt.get_unverified_claims(token)\n    return unverified_claims \n\ndef validate_scope(required_scope:str, request: Request):\n    has_valid_scope = False\n    token = get_token_auth_header(request);\n    unverified_claims = jwt.get_unverified_claims(token)\n    ## check to ensure that either a valid scope or a role is present in the token\n    if unverified_claims.get(\"scp\") is None and unverified_claims.get(\"roles\") is None:\n        raise AuthError(\"IDW10201: No scope or app permission (role) claim was found in the bearer token\", 403)\n\n    is_app_permission = True if unverified_claims.get(\"roles\") is not None else False\n\n    if is_app_permission:\n        if unverified_claims.get(\"roles\"):\n            # the roles claim is an array\n            for scope in unverified_claims[\"roles\"]:\n                if scope.lower() == required_scope.lower():\n                    has_valid_scope = True\n        else:\n            raise AuthError(\"IDW10201: No app permissions (role) claim was found in the bearer token\", 403)\n    else:\n        if unverified_claims.get(\"scp\"):\n            # the scp claim is a space delimited string\n            token_scopes = unverified_claims[\"scp\"].split()\n            for token_scope in token_scopes:\n                if token_scope.lower() == required_scope.lower():\n                    has_valid_scope = True\n        else:\n            raise AuthError(\"IDW10201: No scope claim was found in the bearer token\", 403)\n   \n        \n    if is_app_permission and not has_valid_scope:\n        raise AuthError(f'IDW10203: The \"role\" claim does not contain role {required_scope} or was not found', 403)\n    elif not has_valid_scope:\n        raise AuthError(f'IDW10203: The \"scope\" or \"scp\" claim does not contain scopes {required_scope} or was not found', 403) \n        \n\ndef requires_auth(f):\n    @wraps(f)\n    async def decorated(*args, **kwargs):\n        try:\n            token = get_token_auth_header(kwargs[\"request\"])\n            url = f'https://login.microsoftonline.com/{tenant_id}/discovery/v2.0/keys'\n            \n            async with httpx.AsyncClient() as client:\n                resp: Response = await client.get(url)\n                if resp.status_code != 200:\n                    raise AuthError(\"Problem with Azure AD discovery URL\", status_code=404)\n\n                jwks = resp.json()\n                unverified_header = jwt.get_unverified_header(token)\n                rsa_key = {}\n                for key in jwks[\"keys\"]:\n                    if key[\"kid\"] == unverified_header[\"kid\"]:\n                        rsa_key = {\n                            \"kty\": key[\"kty\"],\n                            \"kid\": key[\"kid\"],\n                            \"use\": key[\"use\"],\n                            \"n\": key[\"n\"],\n                            \"e\": key[\"e\"]\n                        }\n        except Exception:\n            return fastapi.Response(content=\"Invalid_header: Unable to parse authentication\", status_code= 401)\n        if rsa_key:\n            try :\n                token_version = __get_token_version(token)\n                __decode_JWT(token_version, token, rsa_key)\n                return await f(*args, **kwargs)\n            except AuthError as auth_err:\n                fastapi.Response(content=auth_err.error_msg, status_code=auth_err.status_code)\n        return fastapi.Response(content=\"Invalid header error: Unable to find appropriate key\", status_code=401)\n    return decorated\n\ndef requires_b2c_auth(f):\n    @wraps(f)\n    async def decorated(*args, **kwargs):\n        try:\n            token = get_token_auth_header(kwargs[\"request\"])\n            url = f'https://{b2c_domain_name}.b2clogin.com/{b2c_domain_name}.onmicrosoft.com/{b2c_policy_name}/discovery/v2.0/keys'\n            \n            async with httpx.AsyncClient() as client:\n                resp: Response = await client.get(url)\n                if resp.status_code != 200:\n                    raise AuthError(\"Problem with Azure AD discovery URL\", status_code=404)\n\n                jwks = resp.json()\n                unverified_header = jwt.get_unverified_header(token)\n                rsa_key = {}\n                for key in jwks[\"keys\"]:\n                    if key[\"kid\"] == unverified_header[\"kid\"]:\n                        rsa_key = {\n                            \"kid\": key[\"kid\"],\n                            \"kty\": key[\"kty\"],\n                            \"n\": key[\"n\"],\n                            \"e\": key[\"e\"],\n                            \"nbf\": key[\"nbf\"]\n                        }\n        except Exception:\n            return fastapi.Response(content=\"Invalid_header: Unable to parse authentication\", status_code= 401)\n        if rsa_key:\n            try:\n                token_version = __get_token_version(token)\n                __decode_B2C_JWT(token_version, token, rsa_key)\n                return await f(*args, **kwargs)\n            except AuthError as auth_err:\n                fastapi.Response(content=auth_err.error_msg, status_code=auth_err.status_code)\n        return fastapi.Response(content=\"Invalid header error: Unable to find appropriate key\", status_code=401)\n    return decorated\n\ndef __decode_B2C_JWT(token_version, token, rsa_key):\n    if token_version == \"1.0\":\n        _issuer = f'https://{b2c_domain_name}.b2clogin.com/tfp/{tenant_id}/{b2c_policy_name}/v2.0/'.lower()\n    else:\n        _issuer = f'https://{b2c_domain_name}.b2clogin.com/{tenant_id}/v2.0'.lower()\n    try:\n        payload = jwt.decode(\n            token,\n            rsa_key,\n            algorithms=[\"RS256\"],\n            audience=client_id,\n            issuer=_issuer\n        )\n    except jwt.ExpiredSignatureError:\n        raise AuthError(\"Token error: The token has expired\", 401)\n    except jwt.JWTClaimsError:\n        raise AuthError(\"Token error: Please check the audience and issuer\", 401)\n    except Exception:\n        raise AuthError(\"Token error: Unable to parse authentication\", 401)\n\ndef __decode_JWT(token_version, token, rsa_key):\n    if token_version == \"1.0\":\n        _issuer = f'https://sts.windows.net/{tenant_id}/'\n        _audience=f'api://{client_id}'\n    else:\n        _issuer = f'https://login.microsoftonline.com/{tenant_id}/v2.0'\n        _audience=f'{client_id}'\n    try:\n        payload = jwt.decode(\n            token,\n            rsa_key,\n            algorithms=[\"RS256\"],\n            audience=_audience,\n            issuer=_issuer\n        )\n    except jwt.ExpiredSignatureError:\n        raise AuthError(\"Token error: The token has expired\", 401)\n    except jwt.JWTClaimsError:\n        raise AuthError(\"Token error: Please check the audience and issuer\", 401)\n    except Exception:\n        raise AuthError(\"Token error: Unable to parse authentication\", 401)\n\ndef __get_token_version(token):\n    unverified_claims = jwt.get_unverified_claims(token)\n    if unverified_claims.get(\"ver\"):\n        return unverified_claims[\"ver\"]   \n    else:\n        raise AuthError(\"Missing version claim from token. Unable to validate\", 403)"}

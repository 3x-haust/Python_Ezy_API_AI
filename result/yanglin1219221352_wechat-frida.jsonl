{"repo_info": {"repo_name": "wechat-frida", "repo_owner": "yanglin1219221352", "repo_url": "https://github.com/yanglin1219221352/wechat-frida"}}
{"type": "source_file", "path": "wechatf/__init__.py", "content": "\"\"\"\n对外接口\n\"\"\"\n# 打开调试模式\n_debug_print = False\n\n# frida js 对象\nfrom .frida_js import fj\n\n# 好友列表\nfrom .deal_recv_friend_list import friend_list\n\n\ndef is_login():\n    \"\"\"\n    是否登录\n    :return:\n    \"\"\"\n    return fj.is_login()\n\n\ndef get_login_qrcode():\n    \"\"\"\n    获取最新登录二维码\n    :return:\n    \"\"\"\n    # 获取消息队列\n    q = fj.get_js_msg_queue(\"recv_login_qrcode\")\n\n    # 清除以往记录\n    q.queue.clear()\n\n    # 刷新二维码\n    fj.goto_login_qrcode()\n\n    # 获取二维码\n    return q.get()\n\n\ndef get_user_info():\n    \"\"\"\n    获取登录用户信息\n    \"\"\"\n    return fj.get_login_user_info()\n\n\ndef logout():\n    \"\"\"\n    退出登录\n    :return:\n    \"\"\"\n    return fj.logout()\n\n\ndef get_message(block=True):\n    \"\"\"\n    获取一条好友消息\n    :param block: 是否阻塞\n    \"\"\"\n    q = fj.get_js_msg_queue(\"recv_message\")\n    if not q.empty():\n        return q.get(block=block)\n    return None\n\n\ndef send_message(wxid, msg):\n    \"\"\"\n    发送消息\n    \"\"\"\n    return fj.send_message(wxid, msg)\n\n\ndef get_contacts():\n    \"\"\"\n    获取联系人列表\n    \"\"\"\n    return friend_list\n\n\ndef get_remark_or_nick_name(wxid):\n    \"\"\"\n    获取备注名\n    \"\"\"\n    if wxid in friend_list:\n        remark_name = friend_list[wxid][\"user_remark\"]\n        nick_name = friend_list[wxid][\"nick_name\"]\n        # 默认返回备注，备注没有就返回昵称\n        return remark_name if remark_name else nick_name\n    else:\n        return None\n"}
{"type": "source_file", "path": "wechatf/deal_recv_friend_list.py", "content": "\"\"\"\n去除 recv_friend_list 重复消息\n\"\"\"\nimport threading\n\nfrom .frida_js import fj\n\n# 联系人列表\nfriend_list = {}\n\n\nclass HandleFriendListMsg(threading.Thread):\n\n    def run(self) -> None:\n        while True:\n            # 获取回调函数消息\n            msg = fj.get_js_msg(\"recv_friend_list\")\n\n            if msg:\n                # 加入到friend list\n                if msg[\"wxid\"] not in friend_list:\n                    friend_list[msg[\"wxid\"]] = msg\n\n\nHandleFriendListMsg().start()\n"}
{"type": "source_file", "path": "wechatf/frida_js.py", "content": "\"\"\"\n处理frida脚本交互：消息接收、js脚本执行\n\"\"\"\nimport queue\n\nfrom .frida_session import FridaSession\nfrom . import _debug_print\n\n\nclass FridaJS:\n    def __init__(self):\n        # frida 连接\n        self._frida_session = FridaSession()\n\n        # frida on_message 消息队列\n        self._api_message = {}\n\n        # 消息回调函数\n        self._api_on_message = self._gen_on_message_callback()\n\n        # 回调js\n        recv_js = [\n            \"recv_login_qrcode\",\n            \"recv_friend_list\",\n            \"recv_message\",\n        ]\n\n        # 加载所有回调js\n        for js in recv_js:\n            # 为每个js建立消息队列\n            self._api_message[js] = queue.Queue()\n\n            # 加载脚本\n            self._frida_session.load_script(js, self._api_on_message)\n\n    def _gen_on_message_callback(self):\n        \"\"\"\n        生成消息回调函数\n        \"\"\"\n\n        def _on_message(message, data):\n            if message[\"type\"] == 'send':\n                if _debug_print:\n                    print(\"来自Frida的消息：\\n\", message[\"payload\"])\n                    print(\"---------------------\")\n\n                # 获取api 类型和数据\n                api = message[\"payload\"][\"api\"]\n                data = message[\"payload\"][\"data\"]\n\n                # 判断是否存在队列\n                if api in self._api_message.keys():\n                    # 加入到特定的消息队列\n                    self._api_message.get(api).put(data)\n\n        return _on_message\n\n    def get_js_msg_queue(self, api_name):\n        \"\"\"\n        获取frida返回的消息\n        \"\"\"\n        # 获取一条队列消息\n        if api_name in self._api_message.keys():\n            return self._api_message.get(api_name)\n        else:\n            raise Exception(\"无API调用消息队列：\", api_name)\n\n    def get_js_msg(self, api_name):\n        \"\"\"\n        获取frida返回的消息\n        \"\"\"\n        # 获取一条队列消息\n        if api_name in self._api_message.keys():\n            return self._api_message.get(api_name).get()\n        else:\n            raise Exception(\"无API调用消息队列：\", api_name)\n\n    def __getattr__(self, func_name):\n        \"\"\"\n        调用js功能\n        \"\"\"\n        # 加载脚本\n        script = self._frida_session.load_script(func_name)\n\n        # 判断是否加载成功\n        if not script:\n            raise Exception('该功能未实现')\n\n        def sync_call(*args, **kwargs):\n            # 根据名称获取方法\n            _func = getattr(script.exports_sync, func_name.replace(\"_\", \"\"))\n\n            # 调用方法\n            result = _func(*args, **kwargs)\n\n            # 卸载脚本\n            script.unload()\n\n            return result\n\n        return sync_call\n\n\nfj = FridaJS()\n"}
{"type": "source_file", "path": "wechatf_fastapi.py", "content": "\"\"\"\nfastapi 使用 wechatf 例子\n\"\"\"\nimport io\nimport time\nimport random\nimport functools\n\nimport uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.responses import StreamingResponse\n\napp = FastAPI()\n\nimport wechatf\n\n\ndef check_is_login(func):\n    \"\"\"\n    检查是否登录\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if not wechatf.is_login():\n            return {\"msg\": \"微信未登录\", \"code\": -1}\n        else:\n            return func(*args, **kwargs)\n\n    return wrapper\n\n\n@app.get(\"/is_login\")\ndef is_login():\n    \"\"\"\n    是否登录\n    :return:\n    \"\"\"\n    return {\"msg\": \"\", \"data\": {\"code\": wechatf.is_login()}}\n\n\n@app.get(\"/get_login_qrcode\")\ndef get_login_qrcode():\n    \"\"\"\n    获取二维码\n    :return:\n    \"\"\"\n    if not wechatf.is_login():\n        # 获取二维码\n        png_byte = bytes.fromhex(wechatf.get_login_qrcode())\n\n        return StreamingResponse(io.BytesIO(png_byte), media_type=\"image/png\")\n    else:\n        return {\"msg\": \"微信已登录\", \"code\": -1}\n\n\n@app.get(\"/get_user_info\")\n@check_is_login\ndef get_user_info():\n    \"\"\"\n    获取登录用户信息\n    :return:\n    \"\"\"\n    return {\"msg\": \"\", \"code\": 0, \"data\": wechatf.get_user_info()}\n\n\n@app.get(\"/logout\")\n@check_is_login\ndef logout():\n    \"\"\"\n    退出微信\n    :return:\n    \"\"\"\n    wechatf.logout()\n    return {\"msg\": \"\", \"code\": 0}\n\n\n@app.get(\"/get_contacts\")\n@check_is_login\ndef get_contacts():\n    \"\"\"\n    获取联系人\n    :return:\n    \"\"\"\n    return {\"msg\": \"\", \"code\": 0, \"data\": wechatf.get_contacts()}\n\n\n@app.get(\"/get_message\")\n@check_is_login\ndef get_msg():\n    \"\"\"\n    获取消息\n    :return:\n    \"\"\"\n    return {\"msg\": \"\", \"code\": 0, \"data\": wechatf.get_message(False)}\n\n\n@app.get(\"/send_message/{wxid}/{content}\")\n@check_is_login\ndef send_message(wxid: str, content: str):\n    \"\"\"\n    发送消息\n    :param wxid:\n    :param content:\n    :return:\n    \"\"\"\n    # 延迟3-5秒\n    time.sleep(random.randint(2, 6))\n    wechatf.send_message(wxid, content)\n    return {\"msg\": \"OK\", \"code\": 0}\n\n\nif __name__ == '__main__':\n    uvicorn.run('wechatf_fastapi:app',\n                host='127.0.0.1', port=8000,\n                reload=True, workers=1)\n\n# uvicorn wechatf_fastapi_demo:app --reload\n"}
{"type": "source_file", "path": "auto_repeat.py", "content": "\"\"\"\nwechatf 例子\n自动回复\n\"\"\"\nimport os\nimport tempfile\nimport time\nimport random\n\nimport openai\n\nimport wechatf\n\n\n# 处理消息\nclass DealMessage:\n    def __init__(self):\n        # 上次回复消息时间\n        self._last_repeat_time = time.time()\n\n        # 自动回复开关\n        self._auto_repeat_flag = False\n\n        # 自动回复消息内容\n        self._auto_repeat_msg_def = \"[自动回复]现在不方便回复，请留言或手机联系。\"\n        self._auto_repeat_msg = self._auto_repeat_msg_def\n\n        # ai回复开关\n        self._auto_repeat_ai_flag = True\n\n        # gpt 聊天记录\n        self._ai_message_list = []\n\n        # 免费API获取地址\n        # https://github.com/chatanywhere/GPT_API_free\n        # openai.log = \"debug\"\n\n        # 国内可直接访问\n        openai.api_base = \"https://api.chatanywhere.com.cn/v1\"\n        # 需要梯子才能访问\n        # openai.api_base = \"https://api.chatanywhere.cn/v1/\"\n\n        openai.api_key = open(\"openai.key\", 'r').read()\n\n    def _deal_filehelper_msg(self, msg):\n        \"\"\"\n        处理文件助手消息\n        \"\"\"\n        result = None\n        if msg == '/h':\n            # 打印帮助\n            result = \"\"\"\n/h\n打印帮助消息。\n\n/sa msg\n开启自动回复并设置内容。\n\n/ea\n取消自动回复。\n\n/sai\n开启ai聊天。\n\n/cai\n清除ai聊天上下文\n\n/eai\n取消ai聊天。\n                \"\"\"\n        elif msg.startswith('/sa '):\n            # 开启自动回复\n            if len(msg) > 4:\n                self._auto_repeat_msg = msg[4:]\n            else:\n                self._auto_repeat_msg = self._auto_repeat_msg_def\n\n            self._auto_repeat_flag = True\n\n            result = f\"已开启自动回复：{self._auto_repeat_msg}\"\n\n        elif msg == '/ea':\n            # 关闭自动回复\n            self._auto_repeat_flag = False\n            result = \"已关闭自动回复\"\n\n        elif msg == '/sai':\n            # 开启ai\n            self._auto_repeat_ai_flag = True\n            result = \"已开启ai聊天\"\n\n        elif msg == '/cai':\n            self._ai_message_list.clear()\n            result = \"已清除ai聊天上下文\"\n\n        elif msg == '/eai':\n            # 关闭ai聊天\n            self._auto_repeat_ai_flag = False\n            result = \"已关闭ai聊天\"\n\n        elif self._auto_repeat_ai_flag:\n            result = self._gpt(msg)\n\n        return result\n\n    def _get_repeat_msg(self, wxid, msg):\n        \"\"\"\n        获取返回消息\n        \"\"\"\n        # 判断是否为空\n        if not msg:\n            return None\n\n        result = None\n\n        if wxid == 'filehelper':\n            # 文件传输助手消息\n            result = self._deal_filehelper_msg(msg)\n        else:\n            # 自动回复\n            if self._auto_repeat_flag:\n                result = self._auto_repeat_msg\n\n        return result\n\n    def deal_message(self, data):\n        # 获取消息内容\n        msg_type = data[\"type\"]\n        wxid = data[\"wxid\"]\n        msg = data[\"message\"]\n\n        # 过滤空消息\n        if msg.strip() == '':\n            return\n\n        # 过滤非文本\n        if msg_type != \"text\":\n            return\n\n        # 过滤非个人微信号但不过滤filehelper\n        if not wxid.startswith(\"wxid_\") and wxid != 'filehelper':\n            return\n\n        remark_name = wechatf.get_remark_or_nick_name(wxid)\n        if remark_name:\n            print(\"接收到消息\", wxid, remark_name, msg)\n        else:\n            print(\"接收到消息\", wxid, \"\", msg)\n\n        # 处理消息\n        repeat_msg = self._get_repeat_msg(wxid, msg.strip())\n\n        # 判断是否有消息\n        if repeat_msg:\n            # 计算等待时间最少等待3-5秒\n            waiting_time = int(random.randint(3, 5))  # - (time.time() - self._last_repeat_time))\n            if waiting_time > 0:\n                time.sleep(waiting_time)\n\n            # 发送消息\n            wechatf.send_message(wxid, repeat_msg)\n\n            # 设置时间\n            self._last_repeat_time = time.time()\n            print(\"发送消息：\", wxid, repeat_msg)\n\n    def _gpt(self, msg):\n        \"\"\"\n        发起chatgtp请求\n        \"\"\"\n        # 判断是否是空内容\n        if msg is None or msg.strip() == \"\":\n            return None\n\n        # 非流式响应\n        self._ai_message_list.append(\n            {\n                \"role\": \"user\",\n                \"content\": msg.strip()\n            }\n        )\n\n        # 发生请求\n        completion = openai.ChatCompletion.create(model=\"gpt-3.5-turbo\", messages=self._ai_message_list)\n\n        # 获取消息\n        return completion.choices[0].message.content\n\n\n# 消息处理实例\ndeal_message = DealMessage()\n\n\ndef handle_message():\n    \"\"\"\n    处理消息\n    :return:\n    \"\"\"\n    while True:\n        # 取消息\n        data = wechatf.get_message()\n        if data:\n            # 微信好友发来的消息\n            deal_message.deal_message(data)\n\n\ndef main():\n    # 判断是否登录\n    if not wechatf.is_login():\n        print(\"未登录,正在获取登录二维码\")\n        # 刷新二维码\n        wechatf.goto_login_qrcode()\n\n        # 获取二维码\n        png_bytes = bytes.fromhex(wechatf.get_login_qrcode())\n\n        # png路径\n        png_path = os.path.join(tempfile.gettempdir(), \"t.png\")\n\n        # 写入文件\n        open(png_path, 'wb').write(png_bytes)\n\n        # 打开二维码\n        os.startfile(png_path)\n\n    # 直到登录再继续\n    while True:\n        if not wechatf.is_login():\n            time.sleep(3)\n            print(\"等待扫描登录...\")\n        else:\n            break\n\n    print('微信已登录,等待消息...')\n    handle_message()\n\n\nif __name__ == '__main__':\n    main()\n    # 阻塞进程\n    input()\n"}
{"type": "source_file", "path": "wechatf/frida_session.py", "content": "\"\"\"\n与微信建立连接、断开连接、加载js脚本\n\"\"\"\nimport os\nimport time\nimport winreg\nimport subprocess\n\nimport frida\nimport win32api\n\n\nclass FridaSession:\n    def __init__(self):\n        # 微信主程序名称\n        self.wechat_bin_name = \"WeChat.exe\"\n\n        # 微信主动态链接库名称\n        self.wechatwin_dll_name = \"WeChatWin.dll\"\n\n        # 获取微信版本号\n        self.wechatwin_dll_version = self._get_wechatwin_dll_version()\n\n        # 连接到微信\n        self.session = self._get_session()\n\n    def _get_wechat_inst_dir(self):\n        \"\"\"\n        获取微信安装目录\n        \"\"\"\n        # 定义常量\n        HKEY_CURRENT_USER = winreg.HKEY_CURRENT_USER\n        KEY_READ = winreg.KEY_READ\n        REG_PATH = r\"SOFTWARE\\Tencent\\WeChat\"\n\n        # 读取注册表中微信安装目录\n        try:\n            reg_key = winreg.OpenKey(HKEY_CURRENT_USER, REG_PATH, 0, KEY_READ)\n            install_dir = winreg.QueryValueEx(reg_key, \"InstallPath\")[0]\n            winreg.CloseKey(reg_key)\n        except WindowsError:\n            raise Exception(\"微信未安装或注册表中未找到微信安装路径。\")\n\n        return install_dir\n\n    def _get_wechatwin_dll_version(self):\n        \"\"\"\n        获取微信版本号\n        \"\"\"\n        # 获取安装目录\n        install_dir = self._get_wechat_inst_dir()\n        # print(install_dir)\n\n        dll_path = None\n        # 寻找wechatwind.ll文件\n        for root, dirs, files in os.walk(install_dir, topdown=False):\n            for _file in files:\n                # 判断是否相同\n                if _file.lower() == self.wechatwin_dll_name.lower():\n                    dll_path = os.path.join(install_dir, root, _file)\n\n        # 获取dll文件版本号\n        if os.path.isfile(dll_path):\n            version_info = win32api.GetFileVersionInfo(dll_path, \"\\\\\")\n            fixed_info = version_info['FileVersionMS'], version_info['FileVersionLS']\n            version = f\"{fixed_info[0] >> 16}.{fixed_info[0] & 0xffff}.{fixed_info[1] >> 16}.{fixed_info[1] & 0xffff}\"\n            print(f\"WeChatWin.dll 版本号：{version}\")\n            return version\n        else:\n            raise Exception(\"未找到 wechatwin.dll 文件。\")\n\n    def _get_session(self):\n        \"\"\"\n        尝试连接到微信\n        \"\"\"\n        # 获取设备\n        device = frida.get_local_device()\n\n        # 查找微信PID\n        pids = device.enumerate_processes()\n        wechat_pids = [pid for pid in pids if self.wechat_bin_name.lower() == pid.name.lower()]\n\n        # 如果找到微信进程，则使用第一个进程ID连接到微信\n        if wechat_pids:\n            pid = wechat_pids[0].pid\n        else:\n            print('微信未启动，尝试打开微信。')\n\n            # 微信主程序路径\n            wechat_bin = os.path.join(self._get_wechat_inst_dir(), self.wechat_bin_name)\n\n            # 启动\n            process = subprocess.Popen(wechat_bin)\n\n            # 等待5s\n            time.sleep(5)\n\n            # 设置pid\n            pid = process.pid\n\n        # 附加到进程\n        _session = device.attach(pid)\n        print(f'Attached to WeChat process with PID {pid}')\n        return _session\n\n    def load_script(self, js_name, on_message=None):\n        \"\"\"\n        frida加载脚本\n        :param js_name: javascript文件名\n        :param on_message: 消息回调函数\n        :return: frida script 对象\n        \"\"\"\n        # 获取当前脚本文件夹\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n\n        # 根据版本号转换到目录\n        version_dir = \"v\" + self.wechatwin_dll_version.replace(\".\", \"_\")\n\n        # 获取脚本文件路径\n        js_path = os.path.join(current_dir, \"js\", version_dir, js_name + \".js\")\n\n        # 判断文件是否存在\n        if not os.path.isfile(js_path):\n            return None\n\n        # print(\"load script:\", js_path)\n\n        # 使用Frida创建JavaScript脚本\n        script_code = open(js_path, 'r', encoding='utf-8').read()\n\n        # 在Frida会话中加载JavaScript脚本\n        script = self.session.create_script(script_code)\n\n        # 设置回调函数\n        if on_message:\n            script.on('message', on_message)\n\n        # 加载脚本\n        script.load()\n\n        return script\n"}

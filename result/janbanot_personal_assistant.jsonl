{"repo_info": {"repo_name": "personal_assistant", "repo_owner": "janbanot", "repo_url": "https://github.com/janbanot/personal_assistant"}}
{"type": "test_file", "path": "api/routes/test_view.py", "content": "from flask import jsonify, request, current_app\nfrom flask.views import MethodView\nfrom flask_jwt_extended import jwt_required\n\n\nclass TestView(MethodView):\n    decorators = [jwt_required()]\n\n    def get(self):\n        data = \"hello world\"\n        current_app.logger.info(\"Request: %s\", request)\n        current_app.logger.info(\"Response: %s\", data)\n        return jsonify({\"data\": data})\n"}
{"type": "test_file", "path": "tests/test_assistant_api.py", "content": "import pytest\nfrom api.run import app\n\n\n@pytest.fixture\ndef client():\n    app.config[\"TESTING\"] = True\n    with app.test_client() as client:\n        yield client\n\n\ndef login(client, email, password):\n    data = {\"email\": email, \"password\": password}\n    headers = {\"Content-Type\": \"application/json\"}\n    return client.post(\"/login\", json=data, headers=headers)\n\n\ndef chat(client, message, headers):\n    data = {\"message\": message}\n    return client.post(\"/chat\", json=data, headers=headers)\n\n# TODO: write a test without using the hardcoded credentials\n# def test_login_route(client):\n#     response = login(client, \"test@test.com\", \"test1\")\n#     assert response.status_code == 200\n#     assert response.json[\"message\"] == \"Login Successful\"\n#     assert \"access_token\" in response.json\n#     assert response.json[\"expires_in\"] == 1800\n\n\ndef test_login_route_with_incorrect_password(client):\n    response = login(client, \"wrong@email.com\", \"wrong_password\")\n    assert response.status_code == 401\n    assert \"access_token\" not in response.json\n\n\n# def test_login_route_with_incorrect_email(client):\n#     response = login(client, \"test1@test.com\", \"test1\")\n#     assert response.status_code == 401\n#     assert \"access_token\" not in response.json\n\n# def test_access_chat_route_with_valid_token(client):\n#     login_response = login(client, \"test@test.com\", \"test1\")\n#     valid_token = login_response.json[\"access_token\"]\n#     headers = {\n#         \"Content-Type\": \"application/json\",\n#         \"Authorization\": f\"Bearer {valid_token}\",\n#     }\n#     chat_response = chat(client, \"hello\", headers)\n#     assert chat_response.status_code == 200\n"}
{"type": "source_file", "path": "alembic/env.py", "content": "from logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nfrom alembic import context\n\nfrom dotenv import load_dotenv\n\nimport os\n\nload_dotenv()\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Replace the sqlalchemy.url value with the one from .env file\ndatabase_url = os.getenv('POSTGRES_URL')\n\nif not database_url:\n    raise ValueError('POSTGRES_URL environment variable not set')\n\nconfig.set_main_option('sqlalchemy.url', database_url)\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = None   # type: ignore\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "alembic/versions/6409f4f8492b_add_resources_table.py", "content": "\"\"\"add resources table\n\nRevision ID: 6409f4f8492b\nRevises: 265ab9e632ed\nCreate Date: 2024-06-15 13:17:26.673095\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"6409f4f8492b\"\ndown_revision: Union[str, None] = \"265ab9e632ed\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    op.create_table(\n        \"resources\",\n        sa.Column(\"id\", sa.Integer, primary_key=True),\n        sa.Column(\"name\", sa.String(255), nullable=False),\n        sa.Column(\"content\", sa.Text, nullable=True),\n        sa.Column(\"url\", sa.String(255), nullable=True),\n        sa.Column(\"tags\", sa.String(255), nullable=True),\n        sa.Column(\"category\", sa.String(255), nullable=False),\n        sa.Column(\"active\", sa.Boolean, nullable=False, server_default=\"true\"),\n        sa.Column(\n            \"created_at\", sa.DateTime, nullable=False, server_default=sa.func.now()\n        ),\n        sa.Column(\n            \"updated_at\",\n            sa.DateTime,\n            nullable=False,\n            server_default=sa.func.now(),\n            onupdate=sa.func.now(),\n        ),\n    )\n\n\ndef downgrade() -> None:\n    op.drop_table(\"resources\")\n"}
{"type": "source_file", "path": "alembic/versions/265ab9e632ed_add_personal_memory_table.py", "content": "\"\"\"add personal_memory table\n\nRevision ID: 265ab9e632ed\nRevises: 0f632f48bc6d\nCreate Date: 2024-06-15 13:15:35.943222\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"265ab9e632ed\"\ndown_revision: Union[str, None] = \"0f632f48bc6d\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    op.create_table(\n        \"personal_memory\",\n        sa.Column(\"id\", sa.Integer, primary_key=True),\n        sa.Column(\"name\", sa.String(255), nullable=False),\n        sa.Column(\"description\", sa.Text, nullable=True),\n        sa.Column(\"source\", sa.String(255), nullable=True),\n        sa.Column(\"category\", sa.String(255), nullable=False),\n        sa.Column(\"tags\", sa.String(255), nullable=True),\n        sa.Column(\n            \"created_at\", sa.DateTime, nullable=False, server_default=sa.func.now()\n        ),\n        sa.Column(\n            \"updated_at\",\n            sa.DateTime,\n            nullable=False,\n            server_default=sa.func.now(),\n            onupdate=sa.func.now(),\n        ),\n        sa.Column(\"active\", sa.Boolean, nullable=False, server_default=\"true\"),\n    )\n\n\ndef downgrade() -> None:\n    op.drop_table(\"personal_memory\")\n"}
{"type": "source_file", "path": "alembic/versions/0f632f48bc6d_add_functions_history_table.py", "content": "\"\"\"add functions_history table\n\nRevision ID: 0f632f48bc6d\nRevises: e62d40842589\nCreate Date: 2024-06-15 13:14:00.332058\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"0f632f48bc6d\"\ndown_revision: Union[str, None] = \"e62d40842589\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    op.create_table(\n        \"functions_history\",\n        sa.Column(\"id\", sa.Integer, primary_key=True),\n        sa.Column(\"interaction_id\", sa.Integer, nullable=False),\n        sa.Column(\"function\", sa.String(255), nullable=False),\n        sa.Column(\"user_input\", sa.Text, nullable=False),\n        sa.Column(\"answer\", sa.Text, nullable=False),\n        sa.Column(\n            \"created_at\", sa.DateTime, nullable=False, server_default=sa.func.now()\n        ),\n    )\n\n\ndef downgrade() -> None:\n    op.drop_table(\"functions_history\")\n"}
{"type": "source_file", "path": "alembic/versions/264699802ec3_create_users_table.py", "content": "\"\"\"create users table\n\nRevision ID: 264699802ec3\nCreate Date: 2024-03-03 18:25:23.656599\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"264699802ec3\"\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade():\n    op.create_table(\n        \"users\",\n        sa.Column(\"id\", sa.Integer, primary_key=True),\n        sa.Column(\"email\", sa.String(120), unique=True, nullable=False),\n        sa.Column(\"login\", sa.String(64), unique=True, nullable=False),\n        sa.Column(\"password_hash\", sa.String(128), nullable=False),\n    )\n\n\ndef downgrade():\n    op.drop_table(\"users\")\n"}
{"type": "source_file", "path": "api/database/models/personal_memory.py", "content": "from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean\nfrom api.extensions import db\nimport sqlalchemy as sa\n\n\nclass PersonalMemory(db.Model):  # type: ignore\n    __tablename__ = \"personal_memory\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(255), nullable=False)\n    description = Column(Text, nullable=True)\n    source = Column(String(255), nullable=True)\n    category = Column(String(255), nullable=False)\n    tags = Column(String(255), nullable=True)\n    created_at = Column(DateTime, nullable=False, server_default=sa.func.now())\n    updated_at = Column(\n        DateTime, nullable=False, server_default=sa.func.now(), onupdate=sa.func.now()\n    )\n    active = Column(Boolean, nullable=False, server_default=\"true\")\n"}
{"type": "source_file", "path": "api/database/schemas/resources_schema.py", "content": "from marshmallow_sqlalchemy import SQLAlchemyAutoSchema\nfrom api.database.models.resources import Resource\n\n\nclass ResourceSchema(SQLAlchemyAutoSchema):\n    class Meta:\n        model = Resource\n        fields = (\n            \"id\",\n            \"name\",\n            \"content\",\n            \"url\",\n            \"tags\",\n            \"category\",\n            \"active\",\n            \"created_at\",\n            \"updated_at\",\n        )\n"}
{"type": "source_file", "path": "api/database/schemas/personal_memory_schema.py", "content": "from marshmallow_sqlalchemy import SQLAlchemyAutoSchema\nfrom api.database.models.personal_memory import PersonalMemory\n\n\nclass PersonalMemorySchema(SQLAlchemyAutoSchema):\n    class Meta:\n        model = PersonalMemory\n        fields = (\n            \"id\",\n            \"name\",\n            \"description\",\n            \"source\",\n            \"category\",\n            \"tags\",\n            \"created_at\",\n            \"updated_at\",\n            \"active\",\n        )\n"}
{"type": "source_file", "path": "discord_bot/bot_commands.py", "content": "from enum import Enum\nfrom collections import namedtuple\n\nCommand = namedtuple(\"Command\", [\"name\", \"description\"])\n\n\nclass BotCommands(Enum):\n    LIST_COMMANDS = Command(\"list-commands\", \"list all available commands\")\n    YT_SUMMARY = Command(\n        \"yt-summary\", \"get a summary of a YouTube video, provide a URL\"\n    )\n    PAGE_SUMMARY = Command(\n        \"page-summary\", \"get a summary of a page, provide a URL\"\n    )\n    CHECK_ENGLISH = Command(\n        \"check-english\",\n        \"check and fix grammatical, spelling, and punctuation errors in English text\",\n    )\n\n\ndef get_bot_commands():\n    commands = []\n    for command in BotCommands:\n        commands.append(f\"- **{command.value.name}**: {command.value.description}\")\n    return \"\\n\".join(commands)\n"}
{"type": "source_file", "path": "docs/scripts.py", "content": "# To run the script you need to execute bash in a runnig api container\n# create a file, paste the content using the cat command (https://stackoverflow.com/a/60224966)\n# cat > file_to_edit\n# 1 Write or Paste you text\n# 2 don't forget to leave a blank line at the end of file\n# 3 Ctrl + C to apply configuration\n# and run the script\nfrom api.run import app\nfrom api.extensions import db\nfrom api.database.models.user import User\nfrom werkzeug.security import generate_password_hash\n\n\ndef create_admin_user(email: str, login: str, password: str):\n    hashed_password = generate_password_hash(password)\n    new_user = User(email=email, login=login, password_hash=hashed_password)\n    db.session.add(new_user)\n    db.session.commit()\n\n\nif __name__ == \"__main__\":\n    with app.app_context():  # Create an application context\n        email = input(\"Enter email: \")\n        login = input(\"Enter login: \")\n        password = input(\"Enter password: \")\n        create_admin_user(email, login, password)\n        print(\"User created\")\n"}
{"type": "source_file", "path": "api/database/models/resources.py", "content": "from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean\nfrom api.extensions import db\nimport sqlalchemy as sa\n\n\nclass Resource(db.Model):  # type: ignore\n    __tablename__ = \"resources\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(255), nullable=False)\n    content = Column(Text, nullable=True)\n    url = Column(String(255), nullable=True)\n    tags = Column(String(255), nullable=True)\n    category = Column(String(255), nullable=False)\n    active = Column(Boolean, nullable=False, server_default=\"true\")\n    created_at = Column(DateTime, nullable=False, server_default=sa.func.now())\n    updated_at = Column(\n        DateTime, nullable=False, server_default=sa.func.now(), onupdate=sa.func.now()\n    )\n"}
{"type": "source_file", "path": "api/database/models/knowledge_base.py", "content": "from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean\nfrom api.extensions import db\nimport sqlalchemy as sa\n\n\nclass KnowledgeBase(db.Model):  # type: ignore\n    __tablename__ = \"knowledge_base\"\n    id = Column(Integer, primary_key=True)\n    category = Column(String(255), nullable=False)\n    tag = Column(String(255), nullable=False)\n    content = Column(Text, nullable=False)\n    source = Column(String(255), nullable=True)\n    created_at = Column(DateTime, nullable=False, server_default=sa.func.now())\n    updated_at = Column(\n        DateTime, nullable=False, server_default=sa.func.now(), onupdate=sa.func.now()\n    )\n    last_accessed_at = Column(DateTime, nullable=True)\n    active = Column(Boolean, nullable=False, server_default=\"true\")\n"}
{"type": "source_file", "path": "docs/logo.py", "content": "import os\nfrom dotenv import load_dotenv\nfrom openai import OpenAI\n\nload_dotenv()\nopenai_key = os.getenv(\"OPENAI_API_KEY\")\nclient = OpenAI(api_key=openai_key)\n\nresponse = client.images.generate(\n  model=\"dall-e-3\",\n  prompt=\"a neon emblem logo of a robot personal assistant, simple, vector, color\",\n  size=\"1024x1024\",\n  quality=\"standard\",\n  n=1,\n)\n\nimage_url = response.data[0].url\nprint(image_url)\n"}
{"type": "source_file", "path": "api/extensions.py", "content": "from flask_sqlalchemy import SQLAlchemy\nfrom flask_marshmallow import Marshmallow\nfrom flask_jwt_extended import JWTManager\n\ndb = SQLAlchemy()\nma = Marshmallow()\njwt = JWTManager()\n"}
{"type": "source_file", "path": "api/__init__.py", "content": "import os\nimport sys\nimport logging\nfrom flask import Flask\nfrom api.extensions import db, ma, jwt\nfrom api.routes.login_view import LoginView\nfrom api.routes.chat_view import ChatView\nfrom api.routes.clear_context_view import ClearView\nfrom api.routes.test_view import TestView\nfrom api.routes.yt_summary_view import YTSummaryView\nfrom api.routes.check_english_view import CheckEnglishView\nfrom api.routes.web_page_summary_view import WebPageSummaryView\nfrom api.routes.db_conversation_id_view import DBConversationIdView\n\n\ndef create_app():\n    app = Flask(__name__)\n    SECRET_KEY = os.getenv(\"FLASK_SECRET_KEY\", \"this is a secret key\")\n    app.secret_key = SECRET_KEY\n    app.config[\"SQLALCHEMY_DATABASE_URI\"] = os.getenv(\"POSTGRES_URL\", \"\")\n\n    # Initialize the instances with the app\n    db.init_app(app)\n    ma.init_app(app)\n    jwt.init_app(app)\n\n    app.add_url_rule(\n        \"/\",\n        view_func=TestView.as_view(\"test_view\"),\n        methods=[\n            \"GET\",\n        ],\n    )\n    app.add_url_rule(\n        \"/login\",\n        view_func=LoginView.as_view(\"login_view\"),\n        methods=[\n            \"POST\",\n        ],\n    )\n    app.add_url_rule(\n        \"/chat\",\n        view_func=ChatView.as_view(\"chat_view\"),\n        methods=[\n            \"POST\",\n        ],\n    )\n    app.add_url_rule(\n        \"/clear-context\",\n        view_func=ClearView.as_view(\"clear_view\"),\n        methods=[\n            \"POST\",\n        ],\n    )\n    app.add_url_rule(\n        \"/yt-summary\",\n        view_func=YTSummaryView.as_view(\"yt_summary_view\"),\n        methods=[\n            \"POST\",\n        ],\n    )\n    app.add_url_rule(\n        \"/check-english\",\n        view_func=CheckEnglishView.as_view(\"check_english_view\"),\n        methods=[\n            \"POST\",\n        ],\n    )\n    app.add_url_rule(\n        \"/page-summary\",\n        view_func=WebPageSummaryView.as_view(\"page_summary_view\"),\n        methods=[\n            \"POST\",\n        ],\n    )\n    app.add_url_rule(\n        \"/db/conversation-id\",\n        view_func=DBConversationIdView.as_view(\"db_conversation_id_view\"),\n        methods=[\n            \"GET\",\n        ],\n    )\n\n    # Configure logging\n    logging.basicConfig(\n        level=logging.DEBUG, handlers=[logging.StreamHandler(sys.stdout)]\n    )\n    app.logger.info(\"Starting application\")\n\n    return app\n"}
{"type": "source_file", "path": "alembic/versions/e62d40842589_add_knowledge_base_table.py", "content": "\"\"\"add knowledge_base table\n\nRevision ID: e62d40842589\nRevises: e3fab275bece\nCreate Date: 2024-06-15 13:09:52.554254\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"e62d40842589\"\ndown_revision: Union[str, None] = \"e3fab275bece\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    op.create_table(\n        \"knowledge_base\",\n        sa.Column(\"id\", sa.Integer, primary_key=True),\n        sa.Column(\"category\", sa.String(255), nullable=False),\n        sa.Column(\"tag\", sa.String(255), nullable=False),\n        sa.Column(\"content\", sa.Text, nullable=False),\n        sa.Column(\"source\", sa.String(255), nullable=True),\n        sa.Column(\n            \"created_at\", sa.DateTime, nullable=False, server_default=sa.func.now()\n        ),\n        sa.Column(\n            \"updated_at\",\n            sa.DateTime,\n            nullable=False,\n            server_default=sa.func.now(),\n            onupdate=sa.func.now(),\n        ),\n        sa.Column(\"last_accessed_at\", sa.DateTime, nullable=True),\n        sa.Column(\"active\", sa.Boolean, nullable=False, server_default=\"true\"),\n    )\n\n\ndef downgrade() -> None:\n    op.drop_table(\"knowledge_base\")\n"}
{"type": "source_file", "path": "api/database/models/user.py", "content": "from sqlalchemy import Column, Integer, String\nfrom api.extensions import db\n\n\nclass User(db.Model):  # type: ignore\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    email = Column(String, unique=True)\n    login = Column(String, unique=True)\n    password_hash = Column(String)\n"}
{"type": "source_file", "path": "api/run.py", "content": "import os\nfrom dotenv import load_dotenv\nfrom api import create_app\n\nload_dotenv()\napp = create_app()\n\nif __name__ == \"__main__\":\n    is_debug = os.getenv(\"FLASK_DEBUG_MODE\", \"False\").lower() == \"true\"\n    app.run(debug=is_debug)\n"}
{"type": "source_file", "path": "api/routes/login_view.py", "content": "from flask import jsonify, request\nfrom flask.views import MethodView\nfrom werkzeug.security import check_password_hash\nfrom flask_jwt_extended import create_access_token\nfrom datetime import timedelta\nfrom api.database.models.user import User\n# from api.database.models.user_schema import UserSchema\n\n\nclass LoginView(MethodView):\n\n    def post(self):\n        # user_schema = UserSchema()\n        # users_schema = UserSchema(many=True)\n\n        if request.is_json:\n            email = request.json[\"email\"]\n            password = request.json[\"password\"]\n        else:\n            email = request.form[\"email\"]\n            password = request.form[\"password\"]\n\n        user = User.query.filter_by(email=email).first()\n        if user and check_password_hash(user.password_hash, password):\n            expires = timedelta(minutes=30)\n            access_token = create_access_token(identity=email, expires_delta=expires)\n            return jsonify(\n                message=\"Login Successful\",\n                access_token=access_token,\n                expires_in=expires.total_seconds(),\n            )\n        else:\n            return jsonify(\"Bad email or Password\"), 401\n"}
{"type": "source_file", "path": "api/routes/web_page_summary_view.py", "content": "import requests\nimport json\nfrom flask import request, jsonify, current_app\nfrom flask.views import MethodView\nfrom flask_jwt_extended import jwt_required\nfrom dotenv import load_dotenv\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain.chains.summarize import load_summarize_chain\n\nload_dotenv()\n\n\nclass WebPageSummaryView(MethodView):\n    decorators = [jwt_required()]\n\n    def post(self):\n        JINA_PREFIX = \"https://r.jina.ai/\"\n\n        data = request.get_json()\n        url = data.get(\"url\", \"\")\n\n        current_app.logger.info(\"Request: %s\", request)\n        current_app.logger.info(\"URL: %s\", url)\n\n        try:\n            response = requests.get(JINA_PREFIX + url, headers={\"Accept\": \"application/json\"})\n        except Exception as e:\n            print(f\"Invalid URL: {url}. Error: {e}\")\n\n        response_json = json.loads(response.text)\n        text_content = response_json[\"data\"][\"content\"]\n        # metadata = {\"title\": response_json[\"data\"][\"title\"], \"url\": response_json[\"data\"][\"url\"]}\n\n        llm = ChatOpenAI(model=\"gpt-3.5-turbo\", temperature=0)\n\n        text_splitter = RecursiveCharacterTextSplitter(\n            separators=[\"\\n\\n\", \"\\n\"], chunk_size=10000, chunk_overlap=500\n        )\n\n        docs = text_splitter.create_documents([text_content])\n\n        # TODO: rewrite to share code with yt_summary_view\n        map_prompt = \"\"\"\n        Write a concise summary of the following:\n        \"{text}\"\n        CONCISE SUMMARY:\n        \"\"\"\n\n        map_prompt_template = PromptTemplate(\n            template=map_prompt, input_variables=[\"text\"]\n        )\n\n        summary_combine_prompt = \"\"\"\"\n        Write detailed and comprehensive summary of the article.\n        The summary should cover the main points and key details of the text.\n        Return your response in bullet points.\n        ```{text}```\n        BULLET POINT SUMMARY:\n        \"\"\"\n\n        summary_combine_prompt_template = PromptTemplate(\n            template=summary_combine_prompt, input_variables=[\"text\"]\n        )\n\n        summary_chain = load_summarize_chain(\n            llm=llm,\n            chain_type=\"map_reduce\",\n            map_prompt=map_prompt_template,\n            combine_prompt=summary_combine_prompt_template,\n            # verbose=True\n        )\n\n        summary_output = summary_chain.run(docs)\n\n        # TODO: add option to ask question about the text, to extend a point from summary, etc.\n        return jsonify({\"summary\": summary_output})\n"}
{"type": "source_file", "path": "api/routes/db_conversation_id_view.py", "content": "from flask import jsonify\nfrom flask.views import MethodView\nfrom flask_jwt_extended import jwt_required\nfrom api.database.db_manager import DBManager\n\n\nclass DBConversationIdView(MethodView):\n    decorators = [jwt_required()]\n\n    def __init__(self):\n        self.db_manager = DBManager()\n\n    def get(self):\n        conversation_id = self.db_manager.get_current_conversation_id()\n        return jsonify({\"conversation_id\": conversation_id})\n"}
{"type": "source_file", "path": "api/routes/clear_context_view.py", "content": "from flask import jsonify\nfrom flask.views import MethodView\nfrom flask_jwt_extended import jwt_required\nfrom api.routes.chat_view import context_memory\n\n\nclass ClearView(MethodView):\n    decorators = [jwt_required()]\n\n    def post(self):\n        context_memory.clear()\n        return jsonify({\"message\": \"Context memory cleared\"})\n"}
{"type": "source_file", "path": "discord_bot/assistant_bot.py", "content": "import sys\nimport logging\nimport discord\nfrom discord.ext import commands\nfrom dotenv import load_dotenv\nimport asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nfrom config import Config\nfrom utils import (\n    login,\n    get_valid_token,\n    chat,\n    yt_summary,\n    page_summary,\n    check_english,\n    conversation_context_handler,\n    get_conversation_id\n)\nfrom bot_commands import BotCommands, get_bot_commands\nfrom datetime import datetime, timedelta\n\nload_dotenv()\n\nconfig = Config()\n\nMY_GUILD = discord.Object(id=config.discord_guild_id)\n\nintents = discord.Intents.default()\nintents.message_content = True\n\nbot = commands.Bot(command_prefix=\"/\", intents=intents)\n\nlogging.basicConfig(level=logging.DEBUG, handlers=[logging.StreamHandler(sys.stdout)])\n\n\n@bot.event\nasync def on_ready():\n    login(config)\n    # TODO: does it make any sense? (conversation_id endpoint, updating it in config after initialization, etc.)\n    conversation_id = get_conversation_id(config)\n    config.current_conversation_id = conversation_id\n    print(f\"{bot.user} has connected to Discord!\")\n\n\n@bot.event\nasync def on_message(message):\n    if message.author == bot.user or message.author.bot:\n        return\n\n    if message.channel.id in config.chatting_channels_ids:\n        await handle_bot_chatting(message)\n\n    await bot.process_commands(message)\n\n\nasync def handle_bot_chatting(message):\n    if get_valid_token(config):\n        if message.content.startswith(\"!clear\"):\n            response = conversation_context_handler(config, force_clear=True)\n        else:\n            conversation_context_handler(config)\n            response = chat(config, message.content)\n        await message.channel.send(response)\n    else:\n        await message.channel.send(\"Could not get API token\")\n\n\n@bot.command(name=\"sync\", description=\"Sync commands tree commands\")\nasync def sync_command(ctx: commands.Context):\n    bot.tree.copy_global_to(guild=MY_GUILD)\n    await bot.tree.sync(guild=MY_GUILD)\n    await ctx.send(\"Commands synced!\")\n\n\n@bot.command(name=\"get_messages\", description=\"Get messages from a channel\")\nasync def get_messages(ctx: commands.Context, channel_id: int, days: int):\n    channel = bot.get_channel(channel_id)\n    if not channel:\n        await ctx.send(\"Channel not found.\")\n        return\n\n    end_date = datetime.utcnow()\n    start_date = end_date - timedelta(days=days)\n\n    messages = []\n    async for message in channel.history(limit=None, after=start_date, before=end_date):  # type: ignore\n        messages.append(f\"{message.created_at}: {message.author}: {message.content}\")\n\n    await ctx.send(f\"Retrieved {len(messages)} messages from the last {days} days.\")\n    await ctx.send(f\"First message: {messages[0]}\")\n    await ctx.send(f\"Last message: {messages[-1]}\")\n\n\n# TODO: refactor to utilize async and remove duplicated code\n# TODO: !!!! fix problem with unauthorized error on commands\n# handle 401 errors + add handling for errors in api so in bot we can display anything\n# add option to ask more questions about the video based on the content\n@bot.command(\n    name=BotCommands.YT_SUMMARY.value.name,\n    description=BotCommands.YT_SUMMARY.value.description,\n)\nasync def yt_summary_command(ctx: commands.Context, url: str):\n    loop = asyncio.get_event_loop()\n    with ThreadPoolExecutor() as pool:\n        summary = await loop.run_in_executor(pool, yt_summary, config, url)\n    await ctx.send(summary)\n\n\n@bot.command(\n    name=BotCommands.PAGE_SUMMARY.value.name,\n    description=BotCommands.PAGE_SUMMARY.value.description,\n)\nasync def page_summary_command(ctx: commands.Context, url: str):\n    loop = asyncio.get_event_loop()\n    with ThreadPoolExecutor() as pool:\n        summary = await loop.run_in_executor(pool, page_summary, config, url)\n    await ctx.send(summary)\n\n\n@bot.command(\n    name=BotCommands.CHECK_ENGLISH.value.name,\n    description=BotCommands.CHECK_ENGLISH.value.description,\n)\nasync def check_english_command(ctx: commands.Context, *, input_text: str):\n    fixed_text = check_english(config, input_text)\n    await ctx.send(fixed_text)\n\n\n@bot.tree.command(\n    name=BotCommands.LIST_COMMANDS.value.name,\n    description=\"Get a list of all available commands\",\n)\nasync def list_all_commands(interaction: discord.Interaction) -> None:\n    commands_list = str(get_bot_commands())\n    await interaction.response.send_message(commands_list)\n\n\nbot.run(config.discord_token)\n"}
{"type": "source_file", "path": "api/database/models/functions_history.py", "content": "from sqlalchemy import Column, Integer, String, Text, DateTime\nfrom api.extensions import db\nimport sqlalchemy as sa\n\n\nclass FunctionsHistory(db.Model):  # type: ignore\n    __tablename__ = \"functions_history\"\n    id = Column(Integer, primary_key=True)\n    interaction_id = Column(Integer, nullable=False)\n    function = Column(String(255), nullable=False)\n    user_input = Column(Text, nullable=False)\n    answer = Column(Text, nullable=False)\n    created_at = Column(DateTime, nullable=False, server_default=sa.func.now())\n    context = Column(Text, nullable=True)\n"}
{"type": "source_file", "path": "api/routes/yt_summary_view.py", "content": "from flask import request, jsonify, current_app\nfrom flask.views import MethodView\nfrom flask_jwt_extended import jwt_required\nfrom dotenv import load_dotenv\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_community.document_loaders import YoutubeLoader\nfrom langchain_openai import ChatOpenAI\nfrom langchain.chains.summarize import load_summarize_chain\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nload_dotenv()\n\n\nclass YTSummaryView(MethodView):\n    decorators = [jwt_required()]\n\n    def post(self):\n        data = request.get_json()\n        url = data.get(\"url\", \"\")\n\n        current_app.logger.info(\"Request: %s\", request)\n        current_app.logger.info(\"URL: %s\", url)\n\n        try:\n            loader = YoutubeLoader.from_youtube_url(url, add_video_info=True)\n        except Exception as e:\n            print(f\"Invalid YouTube URL: {url}. Error: {e}\")\n        results = loader.load()\n\n        llm = ChatOpenAI(model=\"gpt-3.5-turbo\", temperature=0)\n\n        text_splitter = RecursiveCharacterTextSplitter(chunk_size=10000, chunk_overlap=500)\n\n        for document in results:\n            text_content = document.page_content\n\n        docs = text_splitter.create_documents([text_content])\n\n        map_prompt = \"\"\"\n        Write a concise summary of the following:\n        \"{text}\"\n        CONCISE SUMMARY:\n        \"\"\"\n\n        map_prompt_template = PromptTemplate(\n            template=map_prompt, input_variables=[\"text\"]\n        )\n\n        summary_combine_prompt = \"\"\"\"\n        Write detailed and comprehensive summary of the video transcript text.\n        The summary should cover the main points and key details of the text.\n        Return your response in bullet points.\n        ```{text}```\n        BULLET POINT SUMMARY:\n        \"\"\"\n\n        summary_combine_prompt_template = PromptTemplate(\n            template=summary_combine_prompt, input_variables=[\"text\"]\n        )\n\n        summary_chain = load_summarize_chain(\n            llm=llm,\n            chain_type=\"map_reduce\",\n            map_prompt=map_prompt_template,\n            combine_prompt=summary_combine_prompt_template,\n            # verbose=True\n        )\n\n        summary_output = summary_chain.run(docs)\n\n        # TODO: add option to ask question about the video, to extend a point from summary, etc.\n        return jsonify({\"summary\": summary_output})\n"}
{"type": "source_file", "path": "api/wsgi.py", "content": "from api.run import app\n\nif __name__ == \"__main__\":\n    app.run()\n"}
{"type": "source_file", "path": "api/database/db_manager.py", "content": "from api.database.models.chat_history import ChatHistory\nfrom api.extensions import db\n\n\nclass DBManager:\n    def save_message(self, conversation_id, user_message, current_context, answer):\n        new_message = ChatHistory(\n            conversation_id=conversation_id,\n            user_message=user_message,\n            current_context=current_context,\n            answer=answer,\n        )\n        db.session.add(new_message)\n        db.session.commit()\n\n    def get_messages_by_conversation(self, conversation_id):\n        messages = (\n            db.session.query(ChatHistory)\n            .filter(ChatHistory.conversation_id == conversation_id)\n            .all()\n        )\n        return messages\n\n    def get_current_conversation_id(self):\n        latest_message = db.session.query(ChatHistory).order_by(ChatHistory.message_id.desc()).first()\n        return latest_message.conversation_id if latest_message else 1\n"}
{"type": "source_file", "path": "api/database/schemas/knowledge_base_schema.py", "content": "from marshmallow_sqlalchemy import SQLAlchemyAutoSchema\nfrom api.database.models.knowledge_base import KnowledgeBase\n\n\nclass KnowledgeBaseSchema(SQLAlchemyAutoSchema):\n    class Meta:\n        model = KnowledgeBase\n        fields = (\n            \"id\",\n            \"category\",\n            \"tag\",\n            \"content\",\n            \"source\",\n            \"created_at\",\n            \"updated_at\",\n            \"last_accessed_at\",\n            \"active\",\n        )\n"}
{"type": "source_file", "path": "api/database/schemas/user_schema.py", "content": "from marshmallow_sqlalchemy import SQLAlchemyAutoSchema\nfrom api.database.models.user import User\n\n\nclass UserSchema(SQLAlchemyAutoSchema):\n    class Meta:\n        model = User\n        fields = (\"id\", \"email\", \"login\", \"password_hash\")\n"}
{"type": "source_file", "path": "discord_bot/utils.py", "content": "import os\nimport requests\nimport json\nfrom datetime import datetime, timedelta\nfrom dotenv import load_dotenv\n\n# TODO: refactor the file, because all theses will be simmilar, maybe there is a pattern for this\n# TODO: change to use aiohttp instead of requests, so discord command can utilize async\n\nload_dotenv()\n\n# TODO: move to config object?\nEMAIL = os.getenv(\"API_USER_EMAIL\")\nPASSWORD = os.getenv(\"API_PASSWORD\")\nURL = os.getenv(\"API_URL\")\n\n\ndef get_valid_token(config):\n    if not config.is_token_valid():\n        login(config)\n    return config.is_token_valid()\n\n\ndef update_conversation_timestamp(config):\n    config.current_conversation_last_message_timestamp = datetime.now()\n\n\ndef is_new_conversation(config):\n    if config.current_conversation_last_message_timestamp is None:\n        return True\n    else:\n        time_since_last_message = datetime.now() - config.current_conversation_last_message_timestamp\n        return time_since_last_message > timedelta(minutes=10)\n\n\ndef conversation_context_handler(config, force_clear=False):\n    if force_clear:\n        config.current_conversation_id += 1\n        update_conversation_timestamp(config)\n        return clear_context(config)\n    elif not config.current_conversation_id:\n        config.current_conversation_id = 1\n        update_conversation_timestamp(config)\n    elif is_new_conversation(config):\n        config.current_conversation_id += 1\n        update_conversation_timestamp(config)\n        clear_context(config)\n    else:\n        update_conversation_timestamp(config)\n\n    return None\n\n\n# TODO: change request to aiohttp\ndef login(config):\n    url = URL + \"login\"\n    headers = {\"Content-Type\": \"application/json\"}\n    data = {\"email\": EMAIL, \"password\": PASSWORD}\n    response = requests.post(url, headers=headers, json=data)\n    if response.status_code == 200:\n        response_data = response.json()\n        config.api_token = response_data.get(\"access_token\")\n        expires_in = response_data.get(\"expires_in\")\n        config.api_token_expires_at = datetime.now() + timedelta(seconds=expires_in)\n    else:\n        config.api_token = None\n        config.api_token_expires_at = None\n\n\ndef hello_world(config):\n    auth_header = {\"Authorization\": f\"Bearer {config.api_token}\"}\n    response = requests.get(URL, headers=auth_header)\n    return response.json()\n\n\ndef chat(config, message):\n    headers = {\n        \"Authorization\": f\"Bearer {config.api_token}\",\n        \"Content-Type\": \"application/json\",\n    }\n    url = URL + \"chat\"\n    data = {\"message\": message, \"conversation_id\": config.current_conversation_id}\n    response = requests.post(url, headers=headers, data=json.dumps(data))\n    return response.json()[\"message\"]\n\n\n# TODO: refactor to get rid of duplicated code\ndef clear_context(config):\n    headers = {\"Authorization\": f\"Bearer {config.api_token}\"}\n    url = URL + \"clear-context\"\n    response = requests.post(url, headers=headers)\n    return response.json()[\"message\"]\n\n\ndef yt_summary(config, video_url):\n    headers = {\n        \"Authorization\": f\"Bearer {config.api_token}\",\n        \"Content-Type\": \"application/json\",\n    }\n    url = URL + \"yt-summary\"\n    data = {\"url\": video_url}\n    response = requests.post(url, headers=headers, data=json.dumps(data))\n    return response.json()[\"summary\"]\n\n\ndef page_summary(config, page_url):\n    headers = {\n        \"Authorization\": f\"Bearer {config.api_token}\",\n        \"Content-Type\": \"application/json\",\n    }\n    url = URL + \"page-summary\"\n    data = {\"url\": page_url}\n    response = requests.post(url, headers=headers, data=json.dumps(data))\n    return response.json()[\"summary\"]\n\n\ndef check_english(config, text):\n    headers = {\n        \"Authorization\": f\"Bearer {config.api_token}\",\n        \"Content-Type\": \"application/json\",\n    }\n    url = URL + \"check-english\"\n    data = {\"text\": text}\n    response = requests.post(url, headers=headers, data=json.dumps(data))\n    return response.json()[\"text\"]\n\n\ndef get_conversation_id(config):\n    headers = {\n        \"Authorization\": f\"Bearer {config.api_token}\"\n    }\n    url = URL + \"db/conversation-id\"\n    response = requests.get(url, headers=headers)\n    return response.json()[\"conversation_id\"]\n"}
{"type": "source_file", "path": "discord_bot/config.py", "content": "import os\nfrom datetime import datetime\n\n\nclass Config:\n    def __init__(self):\n        self._api_token = None\n        self._api_token_expires_at = None\n        self._current_conversation_id = None\n        self._current_conversation_last_message_timestamp = None\n        self.discord_token = os.getenv(\"DISCORD_TOKEN\")\n        self.discord_guild_id = os.getenv(\"DISCORD_GUILD_ID\")\n        # chat, chat-testing\n        self.chatting_channels_ids = [1238228569021349948, 1238223813997756446]\n\n        if not self.discord_token:\n            raise ValueError(\"DISCORD_TOKEN is not set\")\n\n        if not self.discord_guild_id:\n            raise ValueError(\"DISCORD_GUILD_ID is not set\")\n\n    @property\n    def api_token(self):\n        return self._api_token\n\n    @api_token.setter\n    def api_token(self, value):\n        self._api_token = value\n\n    @property\n    def api_token_expires_at(self):\n        return self._api_token_expires_at\n\n    @api_token_expires_at.setter\n    def api_token_expires_at(self, value):\n        self._api_token_expires_at = value\n\n    def is_token_valid(self):\n        return (\n            self.api_token\n            and self.api_token_expires_at\n            and self.api_token_expires_at > datetime.now()\n        )\n\n    @property\n    def current_conversation_id(self):\n        return self._current_conversation_id\n\n    @current_conversation_id.setter\n    def current_conversation_id(self, value):\n        self._current_conversation_id = value\n\n    @property\n    def current_conversation_last_message_timestamp(self):\n        return self._current_conversation_last_message_timestamp\n\n    @current_conversation_last_message_timestamp.setter\n    def current_conversation_last_message_timestamp(self, value):\n        self._current_conversation_last_message_timestamp = value\n"}
{"type": "source_file", "path": "api/database/models/chat_history.py", "content": "from sqlalchemy import Column, Integer, String\nfrom api.extensions import db\n\n\nclass ChatHistory(db.Model):  # type: ignore\n    __tablename__ = \"chat_history\"\n    message_id = Column(Integer, primary_key=True)\n    conversation_id = Column(Integer)\n    user_message = Column(String)\n    current_context = Column(String)\n    answer = Column(String)\n"}
{"type": "source_file", "path": "api/database/schemas/chat_history_schema.py", "content": "from marshmallow_sqlalchemy import SQLAlchemyAutoSchema\nfrom api.database.models.chat_history import ChatHistory\n\n\nclass UserSchema(SQLAlchemyAutoSchema):\n    class Meta:\n        model = ChatHistory\n        fields = (\"message_id\", \"conversation_id\", \"user_message\", \"current_context\", \"answer\")\n"}
{"type": "source_file", "path": "alembic/versions/b6994a6fb482_add_context_column_to_functions_history.py", "content": "\"\"\"add context column to functions history\n\nRevision ID: b6994a6fb482\nRevises: 6409f4f8492b\nCreate Date: 2024-06-22 09:34:02.802263\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = 'b6994a6fb482'\ndown_revision: Union[str, None] = '6409f4f8492b'\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    op.add_column('functions_history', sa.Column('context', sa.Text(), nullable=True))\n\n\ndef downgrade() -> None:\n    op.drop_column('functions_history', 'context')\n"}
{"type": "source_file", "path": "api/routes/check_english_view.py", "content": "from dotenv import load_dotenv\nfrom flask import jsonify, request\nfrom flask.views import MethodView\nfrom flask_jwt_extended import jwt_required\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_core.prompts import ChatPromptTemplate\n\nload_dotenv()\n\nllm = ChatOpenAI(model=\"gpt-3.5-turbo\", temperature=0)\n\nsystem_prompt = \"\"\"\nAdjust the user's text to rectify grammatical, spelling, and punctuation errors, maintaining the original layout.\nInterpret ambiguities with discernment. Overlook extraneous comments.\nReturn only the rectified text!\nExamples:\nQ: wheres the best place to meet for a quick chat?\nA: Where's the best place to meet for a quick chat?\nQ: i cant believe its already been a year since we started this project!\nA: I can't believe it's already been a year since we started this project!\n###\nUser's text: {text}\n\"\"\"\n\nprompt = ChatPromptTemplate.from_template(system_prompt)\noutput_parser = StrOutputParser()\n\n\nclass CheckEnglishView(MethodView):\n    decorators = [jwt_required()]\n\n    def post(self):\n        data = request.get_json()\n        text = data.get(\"text\", \"\")\n\n        chain = prompt | llm | output_parser\n        answer = chain.invoke({\"text\": text})\n\n        return jsonify({\"text\": answer})\n"}
{"type": "source_file", "path": "api/routes/chat_view.py", "content": "from flask import request, jsonify\nfrom flask.views import MethodView\nfrom flask_jwt_extended import jwt_required\nfrom dotenv import load_dotenv\nfrom datetime import datetime\nfrom dateutil import tz  # type: ignore\nfrom langchain_openai import ChatOpenAI\nfrom langchain.prompts.prompt import PromptTemplate\nfrom langchain.chains import ConversationChain\nfrom langchain.memory import ConversationSummaryMemory\nfrom api.database.db_manager import DBManager\n\n# TODO: try to implement it without using the langchain directly\nload_dotenv()\n\ncontext_memory = ConversationSummaryMemory(llm=ChatOpenAI(), ai_prefix=\"Assistant\")\n# TODO: refactor to use the same instance of the model\nllm = ChatOpenAI(model=\"gpt-3.5-turbo\", temperature=0)\n\ncurrent_datetime = datetime.now()\ngmt_plus_2_tz = tz.gettz('Etc/GMT-2')\ncurrent_datetime = current_datetime.astimezone(gmt_plus_2_tz)\ncurrent_datetime_str = current_datetime.strftime('%Y/%m/%d, %H:%M:%S')\n\ndatetime_string = f\"Current datetime: {current_datetime_str} \\n\"\n\ntemplate = datetime_string + \"\"\"\nYou are an AI assistant designed for ultra-concise, engaging conversations.\nFollow these rules:\n- Use the fewest words possible while maintaining clarity, impact and natural language\n- Keep a friendly, casual tone with occasional colloquialisms\n- Always wrap code with triple backticks and keywords with `single backticks`\n- Ask for clarification to avoid assumptions\n- Detect intentions and emotional states to tailor responses perfectly.\n- Focus solely on instructions and provide relevant, comprehensive responses\n- Never repeat info or mention limitations\n- Simplify complex tasks; provide the best output possible\n- Prioritize user needs; tailor responses to their context and goals\n- When asked for specific content, start response with requested info immediately\n- Continuously improve based on user feedback\n\nCurrent conversation:\n{history}\nHuman: {input}\nAI Assistant:\n\"\"\"\n\n# TODO: Check why langchain default template example is sent in the context with every message?\nPROMPT = PromptTemplate(input_variables=[\"history\", \"input\"], template=template)\n\nconversation = ConversationChain(\n    prompt=PROMPT,\n    llm=llm,\n    verbose=True,\n    memory=context_memory,\n)\n\n\nclass ChatView(MethodView):\n    decorators = [jwt_required()]\n\n    def __init__(self):\n        self.db_manager = DBManager()\n\n    def post(self):\n        data = request.get_json()\n        input_text = data.get(\"message\", \"\")\n        conversation_id = data.get(\"conversation_id\", \"\")\n\n        current_context = context_memory.buffer\n\n        result = conversation.predict(input=input_text)\n\n        self.db_manager.save_message(conversation_id, input_text, current_context, result)\n\n        return jsonify({\"message\": result})\n"}
{"type": "source_file", "path": "alembic/versions/e3fab275bece_add_chat_history_table.py", "content": "\"\"\"add chat_history table\n\nRevision ID: e3fab275bece\nRevises: 7fbcdb262a79\nCreate Date: 2024-05-13 07:16:11.484875\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"e3fab275bece\"\ndown_revision: Union[str, None] = \"7fbcdb262a79\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade():\n    op.create_table(\n        \"chat_history\",\n        sa.Column(\"message_id\", sa.Integer, primary_key=True),\n        sa.Column(\"conversation_id\", sa.Integer),\n        sa.Column(\"user_message\", sa.String),\n        sa.Column(\"current_context\", sa.String),\n        sa.Column(\"answer\", sa.String),\n    )\n\n\ndef downgrade():\n    op.drop_table(\"chat_history\")\n"}
{"type": "source_file", "path": "alembic/versions/7fbcdb262a79_increase_users_password_hash_length.py", "content": "\"\"\"increase users.password_hash length\n\nRevision ID: 7fbcdb262a79\nRevises: 264699802ec3\nCreate Date: 2024-03-06 00:18:57.968757\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"7fbcdb262a79\"\ndown_revision: Union[str, None] = \"264699802ec3\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade():\n    op.alter_column(\n        \"users\", \"password_hash\", existing_type=sa.String(128), type_=sa.String(256)\n    )\n\n\ndef downgrade():\n    op.alter_column(\n        \"users\", \"password_hash\", existing_type=sa.String(256), type_=sa.String(128)\n    )\n"}
{"type": "source_file", "path": "api/database/schemas/functions_history_schema.py", "content": "from marshmallow_sqlalchemy import SQLAlchemyAutoSchema\nfrom api.database.models.functions_history import FunctionsHistory\n\n\nclass FunctionsHistorySchema(SQLAlchemyAutoSchema):\n    class Meta:\n        model = FunctionsHistory\n        fields = (\n            \"id\",\n            \"interaction_id\",\n            \"function\",\n            \"user_input\",\n            \"answer\",\n            \"created_at\",\n            \"context\"\n        )\n"}

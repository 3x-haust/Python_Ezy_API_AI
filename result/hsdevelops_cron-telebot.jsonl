{"repo_info": {"repo_name": "cron-telebot", "repo_owner": "hsdevelops", "repo_url": "https://github.com/hsdevelops/cron-telebot"}}
{"type": "test_file", "path": "tests/conftest.py", "content": "import mongomock\nimport pytest\n\nfrom database.mongo import MongoService\n\npytest_plugins = (\"pytest_asyncio\",)\n\n\n@pytest.fixture\ndef mongo_service(mocker):\n    client = mongomock.MongoClient()\n    mocker.patch(\"database.mongo.MongoClient\", return_value=client)\n    yield MongoService()\n"}
{"type": "test_file", "path": "tests/unit/bot/commands/test_change_tz.py", "content": "import pytest\nfrom bot.commands import change_tz\nfrom unittest import mock\n\n\n@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"mongo_service\")\n@mock.patch(\"bot.replies.replies.send_start_message\")\nasync def test_change_tz_missing_chat(send_msg, simple_update, simple_context):\n    await change_tz(simple_update, simple_context)\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@mock.patch(\"telegram.Message.reply_text\")\n@mock.patch(\"bot.actions.permissions.check_rights\", mock.AsyncMock(return_value=False))\nasync def test_change_tz_unauthorized(\n    reply, mongo_service, simple_update, simple_context, mock_group\n):\n    mongo_service.insert_new_chat(mock_group)\n    await change_tz(simple_update, simple_context)\n    assert not reply.called\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_change_timezone_message\")\n@mock.patch(\"bot.actions.permissions.check_rights\", mock.AsyncMock(return_value=True))\nasync def test_change_tz(\n    send_msg, mongo_service, simple_update, simple_context, mock_group\n):\n    mongo_service.insert_new_chat(mock_group)\n    await change_tz(simple_update, simple_context)\n    send_msg.assert_called_once()\n"}
{"type": "test_file", "path": "tests/unit/database/test_dbutils_chat.py", "content": "from database.dbutils.dbutils_chat import find_groups_created_by\n\n\ndef test_find_groups_created_by(mongo_service):\n    mock_chats = [\n        {\"chat_type\": \"group\", \"created_by\": 1},\n        {\"chat_type\": \"private\", \"created_by\": 1},\n        {\"chat_type\": \"channel\", \"created_by\": 1},\n        {\"chat_type\": \"supergroup\", \"created_by\": 1},\n        {\"chat_type\": \"group\", \"created_by\": 2},\n        {\"chat_type\": \"private\", \"created_by\": 2},\n        {\"chat_type\": \"channel\", \"created_by\": 2},\n        {\"chat_type\": \"supergroup\", \"created_by\": 2},\n    ]\n    for chat in mock_chats:\n        mongo_service.insert_new_chat(chat)\n\n    # should only return groupchats\n    res = find_groups_created_by(mongo_service, 1)\n    assert len(res) == 2\n    assert res[0][\"chat_type\"] == \"group\"\n    assert res[1][\"chat_type\"] == \"supergroup\"\n"}
{"type": "test_file", "path": "tests/unit/bot/actions/test_permissions.py", "content": "import asyncio\nfrom unittest import mock\nimport pytest\nfrom telegram import CallbackQuery, Chat, Poll, User, Message, Update\nfrom bot.actions.actions import *\nfrom bot.actions.permissions import *\nfrom tests.unit.conftest import mock_update\n\n\nclass Member:\n    def __init__(self, restriction):\n        self.status = restriction\n\n\n@pytest.fixture\ndef mock_update_cb():\n    chat = Chat(id=2, type=\"private\")\n    usr = User(id=1, first_name=\"hs\", is_bot=False)\n    msg = Message(date=1, chat=chat, message_id=1, from_user=usr)\n    cb = CallbackQuery(id=1, from_user=usr, chat_instance=\"\", message=msg)\n    update = Update(message=None, callback_query=cb, update_id=1)\n    yield update\n\n\n@pytest.fixture\ndef mock_update_poll():\n    poll = Poll(\n        id=1,\n        question=\"\",\n        options=list(),\n        total_voter_count=0,\n        is_closed=False,\n        is_anonymous=False,\n        type=\"REGULAR\",\n        allows_multiple_answers=True,\n    )\n    update = Update(message=None, update_id=1, poll=poll)\n    yield update\n\n\n@pytest.fixture\ndef mock_context_poll(simple_context):\n    simple_context.bot_data[1] = 3\n    yield simple_context\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\n    \"update_fix, context_fix, exp_chat_id\",\n    [\n        (\"simple_update\", \"simple_context\", 1),\n        (\"mock_update_cb\", \"simple_context\", 2),\n        (\"mock_update_poll\", \"mock_context_poll\", 3),\n    ],\n)\nasync def test_get_chat_id(update_fix, context_fix, exp_chat_id, request):\n    update = request.getfixturevalue(update_fix)\n    context = request.getfixturevalue(context_fix)\n    res = await get_chat_id(update, context)\n    assert res == exp_chat_id\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_start_message\")\n@mock.patch(\"bot.actions.permissions.get_chat_id\", mock.AsyncMock(return_value=1))\nasync def test_check_rights_missing_entry(\n    send_msg, simple_update, simple_context, mongo_service\n):\n    await check_rights(simple_update, simple_context, mongo_service)\n    res = send_msg.assert_called_once()\n    assert res is None\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.actions.permissions.get_chat_id\", mock.AsyncMock(return_value=1))\nasync def test_check_rights_no_retrictions(\n    simple_update, simple_context, mongo_service, mock_group\n):\n    mongo_service.insert_new_chat(mock_group)\n    res = await check_rights(simple_update, simple_context, mongo_service)\n    assert res is True\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_user_unauthorized_error_message\")\n@mock.patch(\"bot.actions.permissions.get_chat_id\", mock.AsyncMock(return_value=1))\nasync def test_check_rights_creator(\n    send_401, simple_update, simple_context, mongo_service, mock_group\n):\n    mock_group[\"restriction\"] = Restriction.OWNER.value\n    mongo_service.insert_new_chat(mock_group)\n\n    res = await check_rights(simple_update, simple_context, mongo_service)\n    assert res is True\n\n    res = await check_rights(mock_update(id=2), simple_context, mongo_service)\n    assert res is False\n    send_401.assert_called_once()\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\n    \"restriction, exp\",\n    [\n        (Restriction.ADMIN.value, True),\n        (Restriction.OWNER.value, True),\n        (\"\", False),\n    ],\n)\n@mock.patch(\"bot.replies.replies.send_user_unauthorized_error_message\")\n@mock.patch(\"bot.actions.permissions.get_chat_id\", mock.AsyncMock(return_value=1))\nasync def test_check_rights_admin(\n    send_401, restriction, exp, simple_update, simple_context, mongo_service, mock_group\n):\n    mock_group[\"restriction\"] = Restriction.ADMIN.value\n    mongo_service.insert_new_chat(mock_group)\n\n    m = Member(restriction)\n    simple_context.bot.get_chat_member = mock.AsyncMock(return_value=m)\n    res = await check_rights(simple_update, simple_context, mongo_service)\n    assert res is exp\n\n    if res is False:\n        send_401.assert_called_once()\n"}
{"type": "test_file", "path": "tests/unit/bot/commands/test_change_sender.py", "content": "from unittest import mock\nimport pytest\n\nfrom bot.commands import change_sender\nfrom bot.convos import config_chat\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_choose_chat_message\")\nasync def test_change_sender(send_msg, mongo_service, simple_update, mock_group):\n    mongo_service.insert_new_chat(mock_group)\n    res = await change_sender(simple_update, None)\n    assert res == config_chat.state0\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"mongo_service\")\n@mock.patch(\"bot.replies.replies.send_private_only_error_message\")\nasync def test_invalid_chat_type(send_msg, simple_group_update):\n    await change_sender(simple_group_update, None)\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"mongo_service\")\n@mock.patch(\"bot.replies.replies.send_missing_chats_error_message\")\nasync def test_missing_chat(send_msg, simple_update):\n    await change_sender(simple_update, None)\n    send_msg.assert_called_once()\n"}
{"type": "test_file", "path": "tests/unit/common/test_utils.py", "content": "import pytest\nfrom common import utils\n\n\n@pytest.mark.parametrize(\"string\", [\"8:00\", \"1\", \"+15:00\", \"-15:00\"])\ndef test_extract_tz_values_invalid(string):\n    res = utils.extract_tz_values(string)\n    assert res is None\n\n\n@pytest.mark.parametrize(\n    \"string, exp_tz, exp_offset\",\n    [\n        (\"+08:00\", \"+08:00\", 8),\n        (\"-14:00\", \"-14:00\", -14),\n        (\"+0:00\", \"+0:00\", 0),\n        (\"-2\", \"-2\", -2),\n        (\"UTC+3:30\", \"+3:30\", 3.5),\n        (\"UTC-04:00\", \"-04:00\", -4),\n        (\"UTC+13\", \"+13\", 13),\n    ],\n)\ndef test_calc_tz(string, exp_tz, exp_offset):\n    res = utils.extract_tz_values(string)\n    assert res is not None\n\n    utc_tz, tz_offset = utils.calc_tz(res)\n    assert utc_tz == exp_tz\n    assert tz_offset == exp_offset\n\n\ndef test_extract_jobs():\n    text = \"\"\"\n    30 8 * * 1 Normal job\n    30 8 * 2 Error\n    30 8 * * 2,4,5 Multiple days\n    Dummy\n    * * * * * Every minute\n    \"\"\"\n\n    res = utils.extract_jobs(text)\n    assert len(res) == 5\n\n    crontab, content = res[0]\n    assert crontab == \"30 8 * * 1\"\n    assert content == \"Normal job\"\n\n    crontab, content = res[1]\n    assert crontab == \"30 8 * 2 Error\"\n    assert content == \"\"\n\n    crontab, content = res[2]\n    assert crontab == \"30 8 * * 2,4,5\"\n    assert content == \"Multiple days\"\n\n    crontab, content = res[3]\n    assert crontab == \"Dummy\"\n    assert content == \"\"\n\n    crontab, content = res[4]\n    assert crontab == \"* * * * *\"\n    assert content == \"Every minute\"\n"}
{"type": "test_file", "path": "tests/unit/conftest.py", "content": "from unittest import mock\nimport pytest\n\nfrom telegram import Chat, Update, User, Message\n\n\n@pytest.fixture\ndef mock_private():\n    return {\n        \"chat_id\": 1,\n        \"chat_title\": \"\",\n        \"chat_type\": \"private\",\n        \"tz_offset\": 8,\n        \"utc_tz\": 8,\n        \"created_by\": 1,\n        \"telegram_ts\": 1,\n        \"restriction\": \"\",\n    }\n\n\n@pytest.fixture\ndef mock_group():\n    return {\n        \"chat_id\": 1,\n        \"chat_title\": \"test_group\",\n        \"chat_type\": \"group\",\n        \"tz_offset\": 8,\n        \"utc_tz\": 8,\n        \"created_by\": 1,\n        \"telegram_ts\": 1,\n        \"restriction\": \"\",\n    }\n\n\n@pytest.fixture\ndef mock_channel():\n    return {\n        \"chat_id\": 2,\n        \"chat_title\": \"test_channel\",\n        \"chat_type\": \"channel\",\n        \"tz_offset\": 8,\n        \"utc_tz\": 8,\n        \"created_by\": 1,\n        \"telegram_ts\": 1,\n        \"restriction\": \"\",\n    }\n\n\ndef mock_update(text=None, id=1):\n    chat = Chat(id=1, type=\"private\")\n    usr = User(id=id, first_name=\"hs\", is_bot=False)\n    msg = Message(date=id, chat=chat, message_id=id, from_user=usr, text=text)\n    update = Update(message=msg, update_id=id)\n    return update\n\n\n@pytest.fixture\ndef simple_update():\n    yield mock_update()\n\n\n@pytest.fixture\ndef simple_group_update():\n    chat = Chat(id=1, type=\"group\")\n    usr = User(id=1, first_name=\"hs\", is_bot=False)\n    msg = Message(date=1, chat=chat, message_id=1, from_user=usr)\n    update = Update(message=msg, update_id=1)\n    yield update\n\n\n@pytest.fixture\ndef simple_context():\n    obj1, obj2 = {}, {}\n    context = mock.Mock()\n    context.bot_data.__setitem__ = mock.Mock()\n    context.bot_data.__getitem__ = mock.Mock()\n    context.bot_data.__setitem__.side_effect = obj1.__setitem__\n    context.bot_data.__getitem__.side_effect = obj1.__getitem__\n    context.user_data.__setitem__ = mock.Mock()\n    context.user_data.__getitem__ = mock.Mock()\n    context.user_data.__setitem__.side_effect = obj2.__setitem__\n    context.user_data.__getitem__.side_effect = obj2.__getitem__\n    context.bot.get_chat_member = mock.AsyncMock()\n    yield context\n"}
{"type": "test_file", "path": "tests/unit/database/test_dbutils_jobs.py", "content": "from unittest import mock\nimport pytest\nfrom database.dbutils import dbutils_job\n\n\n@pytest.fixture\ndef mock_jobs():\n    return [\n        {\n            \"_id\": 1,\n            \"chat_id\": 1,\n            \"jobname\": \"test_job_1\",\n            \"created_by\": 1,\n            \"created_ts\": 2,\n            \"removed_ts\": \"\",\n            \"nextrun_ts\": \"2012-02-11 08:22:00\",\n        },\n        {\n            \"_id\": 2,\n            \"chat_id\": 1,\n            \"jobname\": \"test_job_2\",\n            \"created_by\": 1,\n            \"created_ts\": 3,\n            \"crontab\": \"* * * * *\",\n            \"removed_ts\": \"\",\n            \"nextrun_ts\": \"2012-02-11 08:22:00\",\n        },\n        {\n            \"_id\": 3,\n            \"chat_id\": 1,\n            \"jobname\": \"test_job_3\",\n            \"created_by\": 1,\n            \"created_ts\": 1,\n            \"removed_ts\": \"\",\n            \"nextrun_ts\": \"2012-02-11 08:22:00\",\n            \"pending_ts\": \"2012-12-10 23:59:00\",\n        },\n        {\n            \"_id\": 4,\n            \"chat_id\": 1,\n            \"jobname\": \"test_job_4\",\n            \"created_by\": 1,\n            \"created_ts\": 1,\n            \"removed_ts\": \"2012-02-11 08:22:00\",\n            \"nextrun_ts\": \"2012-02-11 08:22:00\",\n        },\n        {\n            \"_id\": 5,\n            \"chat_id\": 1,\n            \"jobname\": \"test_job_5\",\n            \"created_by\": 1,\n            \"created_ts\": 1,\n            \"paused_ts\": \"2012-02-11 08:22:00\",\n            \"removed_ts\": \"\",\n            \"nextrun_ts\": \"2012-02-11 08:22:00\",\n            \"errors\": [],\n        },\n        {\n            \"_id\": 6,\n            \"chat_id\": 1,\n            \"jobname\": \"test_job_5\",\n            \"created_by\": 1,\n            \"created_ts\": 1,\n            \"removed_ts\": \"2012-02-11 08:22:00\",\n            \"nextrun_ts\": \"2012-02-11 08:22:00\",\n            \"errors\": [{\"error\": \"Error 400\", \"timestamp\": \"\"}],\n        },\n        {\n            \"_id\": 7,\n            \"chat_id\": 3,\n            \"jobname\": \"test_job_6\",\n            \"created_by\": 3,\n            \"created_ts\": 1,\n            \"removed_ts\": \"\",\n            \"nextrun_ts\": \"2012-02-11 08:22:00\",\n            \"errors\": [],\n            \"pending_ts\": \"2012-12-11 00:00:10\",\n        },\n    ]\n\n\n\"\"\"\nGetters\n\"\"\"\n\n\ndef test_find_latest_entry(mongo_service, mock_jobs):\n    mongo_service.main_collection.insert_many(mock_jobs)\n\n    res = dbutils_job.find_latest_entry(mongo_service, chat_id=1)\n    assert res[\"chat_id\"] == 1\n    assert res[\"jobname\"] == \"test_job_2\"\n    assert res[\"created_ts\"] == 3\n    assert res[\"removed_ts\"] == \"\"\n\n\ndef test_find_entry_by_jobname(mongo_service, mock_jobs):\n    mongo_service.main_collection.insert_many(mock_jobs)\n\n    res = dbutils_job.find_entry_by_jobname(mongo_service, 1, \"test_job_4\", True)\n    assert res is not None\n\n    res = dbutils_job.find_entry_by_jobname(mongo_service, 1, \"test_job_4\", False)\n    assert res is None\n\n\ndef test_find_entries_removed_between(mongo_service, mock_jobs):\n    mongo_service.main_collection.insert_many(mock_jobs)\n\n    res = dbutils_job.find_entries_removed_between(\n        mongo_service, \"2012-02-10\", \"2012-02-12\"\n    )\n    assert len(res) == 2\n\n    res = dbutils_job.find_entries_removed_between(\n        mongo_service, \"2012-02-10\", \"2012-02-12\", 400\n    )\n    assert len(res) == 1\n\n    res = dbutils_job.find_entries_removed_between(\n        mongo_service, \"2012-02-12\", \"2012-02-13\"\n    )\n    assert len(res) == 0\n\n\n@mock.patch(\"common.utils.now\", mock.MagicMock(return_value=\"2012-12-11 00:00:00\"))\ndef test_find_entries_by_nextrun(mongo_service, mock_jobs):\n    mongo_service.main_collection.insert_many(mock_jobs)\n    res = dbutils_job.find_entries_by_nextrun(mongo_service, \"2013-12-11 00:00:00\")\n    ids = [entry[\"_id\"] for entry in res]\n    assert set(ids) == set([1, 2, 3])\n    assert len(res) == 3\n\n\ndef test_find_entries_by_chatid(mongo_service, mock_jobs):\n    mongo_service.main_collection.insert_many(mock_jobs)\n\n    # should only find active entries\n    res = dbutils_job.find_entries_by_chatid(mongo_service, 1)\n    assert len(res) == 4\n\n    res = dbutils_job.find_entries_by_chatid(mongo_service, \"1\")\n    assert len(res) == 4\n\n    res = dbutils_job.find_entries_by_chatid(mongo_service, 2)\n    assert len(res) == 0\n\n\ndef test_count_entries_by_userid(mongo_service, mock_jobs):\n    mongo_service.main_collection.insert_many(mock_jobs)\n\n    res = dbutils_job.count_entries_by_userid(mongo_service, 1)\n    assert res == 4\n\n    res = dbutils_job.count_entries_by_userid(mongo_service, 2)\n    assert res == 0\n\n\n@pytest.mark.parametrize(\"chat_id, expected\", [(2, False), (1, True), (\"1\", True)])\ndef test_entry_exists(mongo_service, mock_jobs, chat_id, expected):\n    mongo_service.main_collection.insert_many(mock_jobs)\n    res = dbutils_job.entry_exists(mongo_service, chat_id, \"test_job_1\")\n    assert res is expected\n\n\n\"\"\"\nSetters\n\"\"\"\n\n\ndef test_add_new_entry(mongo_service):\n    dbutils_job.add_new_entry(mongo_service, chat_id=1, jobname=\"test_job\", user_id=2)\n    res = mongo_service.find_one_entry({\"chat_id\": 1})\n    assert res is not None\n    assert res[\"created_ts\"] is not None\n    assert res[\"last_update_ts\"] is not None\n    assert res[\"created_by\"] == 2\n    assert res[\"last_updated_by\"] == 2\n    assert res[\"chat_id\"] == 1\n    assert res[\"channel_id\"] == \"\"\n    assert res[\"jobname\"] == \"test_job\"\n    assert res[\"crontab\"] == \"\"\n    assert res[\"content\"] == \"\"\n    assert res[\"content_type\"] == \"\"\n    assert res[\"photo_id\"] == \"\"\n    assert res[\"photo_group_id\"] == \"\"\n    assert res[\"previous_message_id\"] == \"\"\n    assert res[\"option_delete_previous\"] == \"\"\n    assert res[\"nextrun_ts\"] == \"\"\n    assert res[\"user_nextrun_ts\"] == \"\"\n    assert res[\"removed_ts\"] == \"\"\n    assert res[\"remarks\"] == \"\"\n    assert res[\"user_bot_token\"] is None\n    assert res[\"errors\"] == []\n\n\ndef test_remove_entries_by_chat(mongo_service, mock_jobs):\n    mongo_service.main_collection.insert_many(mock_jobs)\n    dbutils_job.remove_entries_by_chat(mongo_service, 1)\n    result = dbutils_job.find_entries_by_chatid(mongo_service, 1)\n    assert len(result) == 0\n\n\ndef test_update_entry_by_jobname(mongo_service, mock_jobs):\n    mongo_service.main_collection.insert_many(mock_jobs)\n\n    q = {\"jobname\": \"test_job_1\", \"chat_id\": 1, \"created_ts\": 2}\n    update = {\"created_ts\": 4}\n    dbutils_job.update_entry_by_jobname(mongo_service, q, update)\n\n    res = mongo_service.find_one_entry({\"_id\": 1})\n    assert res is not None\n    assert res[\"created_ts\"] == 4\n"}
{"type": "test_file", "path": "tests/unit/bot/convos/test_config_chat.py", "content": "from unittest import mock\nimport pytest\n\nfrom bot.replies import replies\nfrom bot.convos.config_chat import *\nfrom tests.unit.conftest import mock_update\n\n\n@pytest.fixture\ndef mock_job():\n    return {\n        \"chat_id\": 1,\n        \"jobname\": \"test_job_1\",\n        \"created_by\": 1,\n        \"created_ts\": 1,\n        \"removed_ts\": \"\",\n        \"nextrun_ts\": 2,\n    }\n\n\n@pytest.fixture\ndef mock_job2():\n    return {\n        \"chat_id\": 1,\n        \"jobname\": \"test_job_1\",\n        \"created_by\": 2,\n        \"created_ts\": 1,\n        \"removed_ts\": \"\",\n        \"nextrun_ts\": 2,\n    }\n\n\n\"\"\"\nState 0\n\"\"\"\n\n\n@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"mongo_service\")\n@mock.patch(\"bot.replies.replies.send_error_message\")\nasync def test_choose_chat_no_chat(send_msg, simple_update):\n    res = await choose_chat(simple_update, None)\n    assert res == state0\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_prompt_user_bot_message\")\nasync def test_choose_chat_no_user_token(\n    send_msg, mongo_service, mock_group, simple_context\n):\n    mongo_service.insert_new_chat(mock_group)\n\n    simple_update = mock_update(text=\"test_group\")\n    res = await choose_chat(simple_update, simple_context)\n    assert res == state1\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_prompt_user_bot_message\")\nasync def test_choose_chat_none_user_token(\n    send_msg, mongo_service, mock_group, simple_context\n):\n    mock_group[\"user_bot_token\"] = None\n    mongo_service.insert_new_chat(mock_group)\n\n    simple_update = mock_update(text=\"test_group\")\n    res = await choose_chat(simple_update, simple_context)\n    assert res == state1\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_sender_reset_success_message\")\nasync def test_choose_chat_existing_user_token(\n    send_msg,\n    mongo_service,\n    mock_group,\n    mock_job,\n    mock_job2,\n    simple_context,\n):\n    mock_group[\"user_bot_token\"] = 1\n    mock_job[\"user_bot_token\"] = 1\n    mongo_service.insert_new_chat(mock_group)\n    mongo_service.insert_new_entry(mock_job)\n    mongo_service.insert_new_entry(mock_job2)\n\n    simple_update = mock_update(text=\"test_group\")\n    res = await choose_chat(simple_update, simple_context)\n    assert res == ConversationHandler.END\n\n    send_msg.assert_called_once()\n\n    res = mongo_service.find_one_chat_entry({\"chat_id\": 1})\n    assert res[\"user_bot_token\"] is None\n\n    res = mongo_service.find_entries({\"chat_id\": 1})\n    assert len(res) == 2\n    assert res[0][\"user_bot_token\"] is None\n    assert res[1][\"user_bot_token\"] is None\n\n\n\"\"\"\nState 1\n\"\"\"\n\n\nclass MockResponse:\n    def __init__(self, json_data, status_code):\n        self.json_data = json_data\n        self.status_code = status_code\n\n    def json(self):\n        return self.json_data\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_error_message\")\nasync def test_update_sender_invalid_bot(send_msg, simple_context):\n    simple_update = mock_update(text=\"some_token\")\n    res = await update_sender(simple_update, simple_context)\n    assert res == state1\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_sender_change_success_message\")\nasync def test_update_sender_valid_bot(\n    send_msg,\n    mocker,\n    mongo_service,\n    simple_update,\n    simple_context,\n    mock_group,\n    mock_job,\n    mock_job2,\n):\n    mock_resp = MockResponse({\"result\": {\"id\": 1, \"username\": \"test_bot\"}}, 200)\n    mocker.patch(\"bot.convos.config_chat.get_bot_details\", return_value=mock_resp)\n\n    mock_group[\"user_bot_token\"] = 1\n    mongo_service.insert_new_chat(mock_group)\n    mongo_service.insert_new_entry(mock_job)\n    mongo_service.insert_new_entry(mock_job2)\n\n    simple_update = mock_update(text=\"some_token\")\n    simple_context.user_data[\"chat_id\"] = mock_group[\"chat_id\"]\n    simple_context.user_data[\"chat_title\"] = mock_group[\"chat_title\"]\n    res = await update_sender(simple_update, simple_context)\n    assert res == ConversationHandler.END\n\n    res = mongo_service.find_one_bot({\"id\": 1})\n    assert res is not None\n    assert res[\"token\"] == \"some_token\"\n\n    res = mongo_service.find_one_chat_entry({\"chat_id\": mock_group[\"chat_id\"]})\n    assert res[\"user_bot_token\"] == \"some_token\"\n\n    res = mongo_service.find_entries({\"chat_id\": mock_group[\"chat_id\"]})\n    assert len(res) == 2\n    assert res[0][\"user_bot_token\"] == \"some_token\"\n    assert res[1][\"user_bot_token\"] == \"some_token\"\n\n    send_msg.assert_called_once()\n"}
{"type": "test_file", "path": "tests/unit/bot/actions/test_update_tz.py", "content": "import asyncio\nfrom unittest import mock\n\nimport pytest\nfrom bot.actions.actions import update_timezone\n\n\n@pytest.fixture\ndef mock_job():\n    return {\n        \"chat_id\": 1,\n        \"jobname\": \"test_job_1\",\n        \"created_by\": 1,\n        \"created_ts\": 1,\n        \"removed_ts\": \"\",\n        \"crontab\": \"0 * * * *\",\n        \"nextrun_ts\": 2,\n    }\n\n\n@pytest.fixture\ndef mock_job2():\n    return {\n        \"chat_id\": 1,\n        \"channel_id\": 2,\n        \"jobname\": \"test_job_2\",\n        \"created_by\": 1,\n        \"created_ts\": 1,\n        \"removed_ts\": \"\",\n        \"crontab\": \"0 * * * *\",\n        \"nextrun_ts\": 2,\n    }\n\n\n@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"mongo_service\")\n@mock.patch(\"telegram.Message.reply_text\")\n@mock.patch(\n    \"bot.actions.actions.permissions.check_rights\", mock.AsyncMock(return_value=False)\n)\nasync def test_update_tz_unauthorized(reply, simple_update, simple_context):\n    await update_timezone(simple_update, simple_context)\n    reply.assert_not_called()\n\n\n@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"mongo_service\")\n@mock.patch(\"bot.replies.replies.send_error_message\")\n@mock.patch(\"common.utils.extract_tz_values\", mock.MagicMock(return_value=False))\n@mock.patch(\n    \"bot.actions.actions.permissions.check_rights\", mock.AsyncMock(return_value=True)\n)\nasync def test_update_tz_missing_tz(send_msg, simple_update, simple_context, mocker):\n    await update_timezone(simple_update, simple_context)\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"mongo_service\")\n@mock.patch(\"bot.replies.replies.send_error_message\")\n@mock.patch(\"common.utils.calc_tz\", mock.MagicMock(return_value=(\"+16:00\", 16)))\n@mock.patch(\"common.utils.extract_tz_values\", mock.MagicMock(return_value=True))\n@mock.patch(\n    \"bot.actions.actions.permissions.check_rights\", mock.AsyncMock(return_value=True)\n)\nasync def test_update_tz_invalid_tz(send_msg, simple_update, simple_context):\n    await update_timezone(simple_update, simple_context)\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"mongo_service\")\n@mock.patch(\"bot.replies.replies.send_start_message\")\n@mock.patch(\"common.utils.calc_tz\", mock.MagicMock(return_value=(\"+8:00\", 8)))\n@mock.patch(\"common.utils.extract_tz_values\", mock.MagicMock(return_value=True))\n@mock.patch(\n    \"bot.actions.actions.permissions.check_rights\", mock.AsyncMock(return_value=True)\n)\nasync def test_update_tz_missing_chat(send_msg, simple_update, simple_context):\n    await update_timezone(simple_update, simple_context)\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@mock.patch(\"bot.replies.replies.send_timezone_nochange_error_message\")\n@mock.patch(\"common.utils.calc_tz\", mock.MagicMock(return_value=(\"+8:00\", 8)))\n@mock.patch(\"common.utils.extract_tz_values\", mock.MagicMock(return_value=True))\n@mock.patch(\n    \"bot.actions.actions.permissions.check_rights\", mock.AsyncMock(return_value=True)\n)\nasync def test_update_tz_no_change(\n    send_msg, simple_update, simple_context, mongo_service, mock_group\n):\n    mongo_service.insert_new_chat(mock_group)\n    await update_timezone(simple_update, simple_context)\n    send_msg.assert_called_once()\n\n\n@pytest.mark.asyncio\n@mock.patch(\"common.utils.calc_tz\", mock.MagicMock(return_value=(\"+9:00\", 9)))\n@mock.patch(\"common.utils.extract_tz_values\", mock.MagicMock(return_value=True))\n@mock.patch(\n    \"bot.actions.actions.permissions.check_rights\", mock.AsyncMock(return_value=True)\n)\nasync def test_update_tz_group(\n    mocker, simple_update, simple_context, mongo_service, mock_group, mock_job\n):\n    send_msg = mocker.patch(\"bot.replies.replies.send_timezone_change_success_message\")\n\n    mock_resp = (\"2023-05-07 01:00\", \"2023-05-07 02:00\")\n    test_user_nextrun, test_nextrun = mock_resp\n    mocker.patch(\"common.utils.calc_next_run\", return_value=mock_resp)\n\n    mongo_service.insert_new_chat(mock_group)\n    mongo_service.insert_new_entry(mock_job)\n\n    await update_timezone(simple_update, simple_context)\n    send_msg.assert_called_once()\n\n    res_group = mongo_service.find_one_chat_entry({\"chat_id\": 1})\n    assert res_group is not None\n    assert res_group[\"utc_tz\"] == \"+9:00\"\n    assert res_group[\"tz_offset\"] == 9\n\n    res_jobs = mongo_service.find_entries({\"created_by\": 1})\n    assert len(res_jobs) == 1\n    assert res_jobs[0][\"nextrun_ts\"] == test_nextrun\n    assert res_jobs[0][\"user_nextrun_ts\"] == test_user_nextrun\n\n\n@pytest.mark.asyncio\n@mock.patch(\"common.utils.calc_tz\", mock.MagicMock(return_value=(\"+9:00\", 9)))\n@mock.patch(\"common.utils.extract_tz_values\", mock.MagicMock(return_value=True))\n@mock.patch(\n    \"bot.actions.actions.permissions.check_rights\", mock.AsyncMock(return_value=True)\n)\nasync def test_update_tz_private(\n    mocker,\n    simple_update,\n    simple_context,\n    mongo_service,\n    mock_private,\n    mock_channel,\n    mock_job,\n    mock_job2,\n):\n    send_msg = mocker.patch(\"bot.replies.replies.send_timezone_change_success_message\")\n\n    mock_resp = (\"2023-05-07 01:00\", \"2023-05-07 02:00\")\n    test_user_nextrun, test_nextrun = mock_resp\n    mocker.patch(\"common.utils.calc_next_run\", return_value=mock_resp)\n\n    mongo_service.insert_new_chat(mock_private)\n    mongo_service.insert_new_chat(mock_channel)\n    mongo_service.insert_new_entry(mock_job)\n    mongo_service.insert_new_entry(mock_job2)\n\n    await update_timezone(simple_update, simple_context)\n    send_msg.assert_called_once()\n\n    res_private = mongo_service.find_one_chat_entry({\"chat_id\": 1})\n    assert res_private is not None\n    assert res_private[\"utc_tz\"] == \"+9:00\"\n    assert res_private[\"tz_offset\"] == 9\n\n    res_channel = mongo_service.find_one_chat_entry({\"chat_id\": 2})\n    assert res_channel is not None\n    assert res_channel[\"utc_tz\"] == \"\"\n    assert res_channel[\"tz_offset\"] == 9\n\n    res_jobs = mongo_service.find_entries({\"created_by\": 1})\n    assert len(res_jobs) == 2\n    assert res_jobs[0][\"nextrun_ts\"] == test_nextrun\n    assert res_jobs[0][\"user_nextrun_ts\"] == test_user_nextrun\n    assert res_jobs[1][\"nextrun_ts\"] == test_nextrun\n    assert res_jobs[1][\"user_nextrun_ts\"] == test_user_nextrun\n"}
{"type": "source_file", "path": "bot/actions/removals.py", "content": "from datetime import datetime, timezone, timedelta\nfrom bot.actions import permissions\nfrom telegram.ext._contexttypes import ContextTypes\nfrom telegram import Update\n\nfrom bot.replies import replies\nfrom config import TZ_OFFSET\nfrom common import log, utils\nfrom database import mongo\nfrom database.dbutils import dbutils\n\n\nasync def reset_chat(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    db_service = mongo.MongoService(update)\n\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    chat_id = update.callback_query.message.chat_id\n    dbutils.remove_entries_by_chat(db_service, chat_id)\n\n    log.log_chat_reset(update)\n    await replies.send_reset_success_message(context, chat_id)\n\n\nasync def remove_job(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    chat_id = update.message.chat.id\n    entry = dbutils.find_entry_by_jobname(db_service, chat_id, update.message.text)\n\n    if entry is None:\n        return await replies.send_error_message(update)\n\n    last_updated_by = update.message.from_user.id\n    payload = {\n        \"removed_ts\": utils.now(),\n        \"last_updated_by\": last_updated_by,\n    }\n    dbutils.update_entry_by_jobname(db_service, entry, payload)\n\n    log.log_job_removed(last_updated_by, entry.get(\"jobname\"), chat_id)\n    await replies.send_delete_success_message(update)\n"}
{"type": "source_file", "path": "bot/commands.py", "content": "from telegram import Update\nfrom telegram.ext._contexttypes import ContextTypes\nfrom bot.convos import config_chat, edit\nfrom bot.replies import replies\nfrom database import mongo\nfrom database.dbutils import dbutils\nfrom bot.actions import permissions\nfrom typing import Optional\n\n\n# Define a few command handlers. These usually take the two arguments update and\n# context. Error handlers also receive the raised TelegramError object in error.\nasync def start(update: Update, _: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /start is issued.\"\"\"\n    db_service = mongo.MongoService(update)\n\n    # timezone must be defined in order to create new job\n    if dbutils.find_chat_by_chatid(db_service, update.message.chat.id) is None:\n        return await replies.send_start_message(update)\n\n    await replies.send_simple_prompt_message(update)\n\n\nasync def help(update: Update, _: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /help is issued.\"\"\"\n    await replies.send_help_message(update)\n\n\nasync def checkcron(update: Update, _: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /checkcron is issued.\"\"\"\n    await replies.send_checkcron_message(update)\n\n\nasync def add(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /add is issued.\"\"\"\n    db_service = mongo.MongoService(update)\n\n    # timezone must be defined in order to create new job\n    if dbutils.find_chat_by_chatid(db_service, update.message.chat.id) is None:\n        return await replies.send_start_message(update)\n\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    # person limit\n    user_id = update.message.from_user.id\n    job_count, user_limit = dbutils.get_user_limit(db_service, user_id)\n    if job_count >= user_limit:\n        return await replies.send_exceed_limit_error_message(update, user_limit)\n\n    await replies.send_request_jobname_message(update)\n\n\nasync def add_multiple(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /addmultiple is issued.\"\"\"\n    db_service = mongo.MongoService(update)\n\n    # timezone must be defined in order to create new job\n    if dbutils.find_chat_by_chatid(db_service, update.message.chat.id) is None:\n        return await replies.send_start_message(update)\n\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    # person limit\n    user_id = update.message.from_user.id\n    job_count, user_limit = dbutils.get_user_limit(db_service, user_id)\n    if job_count >= user_limit:\n        return await replies.send_exceed_limit_error_message(update, user_limit)\n\n    await replies.send_request_jobs_message(update)\n\n\nasync def delete(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /delete is issued.\"\"\"\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    entries = dbutils.find_entries_by_chatid(db_service, update.message.chat.id)\n    if len(entries) <= 0:\n        return await replies.send_simple_prompt_message(update)\n\n    await replies.send_delete_message(update, entries)\n\n\nasync def list_jobs(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /list is issued.\"\"\"\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    entries = dbutils.find_entries_by_chatid(db_service, update.message.chat.id)\n    if len(entries) <= 0:\n        return await replies.send_simple_prompt_message(update)\n\n    await replies.send_list_jobs_message(update, entries)\n\n\nasync def list_options(update: Update, _: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /options is issued.\"\"\"\n    is_group = update.message.chat.type in [\"group\", \"supergroup\"]\n    if is_group:\n        await replies.send_list_options_message(update)\n\n\nasync def option_restrict_to_admins(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> None:\n    \"\"\"Send a message when the command /adminsonly is issued.\"\"\"\n    if update.message.chat.type not in [\"group\", \"supergroup\"]:\n        return\n\n    db_service = mongo.MongoService(update)\n    if not await permissions.check_rights(update, context, db_service, True):\n        return\n\n    return await permissions.restrict_to_admins(update, db_service)\n\n\nasync def option_restrict_to_user(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> None:\n    \"\"\"Send a message when the command /creatoronly is issued.\"\"\"\n\n    if update.message.chat.type not in [\"group\", \"supergroup\"]:\n        return\n\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    return await permissions.restrict_to_user(update, db_service)\n\n\nasync def change_tz(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /changetz is issued.\"\"\"\n    db_service = mongo.MongoService(update)\n\n    # timezone must be defined in order to change tz\n    if dbutils.find_chat_by_chatid(db_service, update.message.chat.id) is None:\n        return await replies.send_start_message(update)\n\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    return await replies.send_change_timezone_message(update)\n\n\nasync def change_sender(update: Update, _: ContextTypes.DEFAULT_TYPE) -> Optional[int]:\n    \"\"\"Send a message when the command /changesender is issued.\"\"\"\n    db_service = mongo.MongoService(update)\n\n    # find groups/private/channel created by user\n    user_id = update.message.from_user.id\n    chat_type = update.message.chat.type\n\n    if chat_type != \"private\":\n        return await replies.send_private_only_error_message(update)\n\n    chat_entries = dbutils.find_groups_created_by(db_service, user_id)\n    if len(chat_entries) <= 0:\n        return await replies.send_missing_chats_error_message(update)\n\n    await replies.send_choose_chat_message(update, chat_entries)\n    return config_chat.state0\n\n\nasync def reset(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send a message when the command /reset is issued.\"\"\"\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    entries = dbutils.find_entries_by_chatid(db_service, update.message.chat.id)\n    if len(entries) <= 0:  # there must be at least one job available\n        return await replies.send_simple_prompt_message(update)\n\n    await replies.send_reset_confirmation_message(update)\n\n\nasync def edit_job(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Optional[int]:\n    \"\"\"Send a message when the command /edit is issued.\"\"\"\n\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    context.user_data[\"user_id\"] = update.message.from_user.id\n\n    entries = dbutils.find_entries_by_chatid(db_service, update.message.chat.id)\n    if len(entries) <= 0:\n        return await replies.send_simple_prompt_message(update)\n\n    await replies.send_choose_job_message(update, entries)\n    return edit.state0\n"}
{"type": "source_file", "path": "bot/replies/success.py", "content": "from telegram import ReplyKeyboardRemove, Update\nfrom telegram.constants import ParseMode\nfrom telegram.ext._contexttypes import ContextTypes\n\ndelete_success_message = \"Yeet! This job is now gone.\"\nrestrict_success_message = \"Hurray! From now on __bot_ic__ can set up recurring messages. Run the command again to toggle the restriction setting.\"\ntimezone_change_success_message = (\n    \"Yipee! Your timezone has been updated to UTC__utc_tz__.\"\n)\nreset_success_messge = \"Yeet! No more recurring messages in this chat.\"\njobs_creation_success_message = \"The following recurring messages are created, /list to view all messages and their details:\\n\"\nattribute_change_success_message = \"Yipee! Your recurring message is updated successfully.\\n\\n/list to view all messages and their details.\"\nsender_change_success_message = \"Sender for %s is now %s. \\n\\nRemember to add %s into the group/channel as an admin and enable:\\n1. <i>Change Group/Channel Info</i> and\\n2. <i>Post Messages</i>.\"\nsender_reset_success_message = (\n    \"Sender has been reset to default for chat. /changesender to set a new sender.\"\n)\n\n\nasync def send_delete_success_message(update: Update) -> None:\n    await update.message.reply_text(\n        delete_success_message, reply_markup=ReplyKeyboardRemove()\n    )\n\n\nasync def send_reset_success_message(context: ContextTypes, chat_id: int) -> None:\n    await context.bot.send_message(chat_id, reset_success_messge)\n\n\nasync def send_restrict_success_message(update: Update, bot_ic: str) -> None:\n    await update.message.reply_text(\n        restrict_success_message.replace(\"__bot_ic__\", bot_ic)\n    )\n\n\nasync def send_timezone_change_success_message(update: Update, utc_tz: str) -> None:\n    reply = timezone_change_success_message.replace(\"__utc_tz__\", utc_tz)\n    await update.message.reply_text(reply)\n\n\nasync def send_jobs_creation_success_message(\n    update: Update, additional_text: str\n) -> None:\n    await update.message.reply_text(jobs_creation_success_message + additional_text)\n\n\nasync def send_attribute_change_success_message(update: Update) -> None:\n    await update.message.reply_text(\n        attribute_change_success_message, reply_markup=ReplyKeyboardRemove()\n    )\n\n\nasync def send_sender_reset_success_message(update: Update) -> None:\n    await update.message.reply_text(\n        sender_reset_success_message, reply_markup=ReplyKeyboardRemove()\n    )\n\n\nasync def send_sender_change_success_message(\n    update: Update, chat_title: str, bot_username: str\n) -> None:\n    await update.message.reply_text(\n        sender_change_success_message % (chat_title, bot_username, bot_username),\n        parse_mode=ParseMode.HTML,\n        reply_markup=ReplyKeyboardRemove(),\n    )\n"}
{"type": "source_file", "path": "bot/replies/replies.py", "content": "import json\nfrom telegram.constants import ParseMode\nfrom telegram import (\n    ForceReply,\n    ReplyKeyboardRemove,\n    ReplyKeyboardMarkup,\n    InlineKeyboardButton,\n    InlineKeyboardMarkup,\n)\nfrom bot.replies.success import *\nfrom bot.replies.errors import *\nfrom bot.convos import edit\nfrom common.enums import ContentType\nfrom typing import Any, List, Optional, Sequence, Union\nfrom telegram import KeyboardButton\n\n# custom messages\n# html\nstart_message = \"<b>Thank you for using Recurring Messages!</b>\\n\\nTo start, please tell me your UTC timezone. For example, if your timezone is UTC+08:30, enter +08:30.\\n\\n(swipe left to reply to this message)\"\nhelp_message = 'I can help you schedule recurring messages using <a href=\"https://crontab.guru/\">cron schedule expressions</a> (min. 1 minute intervals).\\n\\n<b>Available commands</b>\\n/add - add a new job\\n/addmultiple - add multiple jobs\\n/edit - edit job details\\n/list - list active jobs\\n/delete - delete a job\\n/reset - delete all jobs\\n/changetz - edit timezone\\n/changesender - change sender for group\\n/options - edit permissions for group\\n/checkcron - check the validity/meaning of a cron expression\\n\\n<b>Feeling lost?</b>\\nRefer to our <a href=\"https://github.com/hsdevelops/cron-telebot/wiki/User-Guide\">user guide</a> for more usage instructions.\\n\\n<b>Found a bug?</b>\\nPlease contact the bot owner at <a href=\"mailto:hs.develops.1@gmail.com\">hs.develops.1@gmail.com</a>.\\n\\n<b>Enjoying the bot?</b>\\nYou can <a href=\"https://www.buymeacoffee.com/hschua\">buy the creator a coffee</a>!'  # html\ndelete_message = \"Hey, tell me the name of the job you want to delete. Get /list of available jobs.\\n\\n(swipe left to reply to this message)\"\nrequest_jobname_message = (\n    \"Give me your job name\\n\\n(swipe left to reply to this message)\"\n)\n# html\nrequest_crontab_message = 'Give me your cron schedule expression (e.g. 4 5 * * *), click <a href=\"https://crontab.guru/\">here</a> if you need help. Use /checkcron to check your cron expression.\\n\\n(swipe left to reply to this message)'\nrequest_text_message = (\n    \"Now give me what you want to send\\n\\n(swipe left to reply to this message)\"\n)\nrequest_jobs_message = \"Reply this message with your jobs in the following format (example):\\n\\n0 10 * * 2 Clean up a table\\n0 10 * * 4 Check the calendar\\n0 14 * * 5 Check this and that and that\\n\\n(swipe left to reply to this message)\"\nsimple_prompt_message = \"/add to create a new job\"\nprompt_new_job_message = \"The job already got this field. Please /add and create a new job. If you want to override, /delete job and create again.\"\nlist_jobs_message = \"Choose the job you are interested to know more about. The jobs are listed on the reply keyboard.\\n\\n(swipe left to reply to this message)\"\ncheckcron_message = \"Hey, send me your cron expression, I will decrypt it for you.\\n\\n(swipe left to reply to this message)\"\ncheckcron_meaning_message = \"Ok, that means: \"\nlist_options_message_group = \"<b>Group options</b>\\n/adminsonly - restrict bot to group admins\\n/creatoronly - restrict bot to first user\\n\\n\"\nadd_to_channel_message = \"\\n\\nRemember to add RM bot into the channel as an admin and enable:\\n1. <i>Change Channel Info</i> and\\n2. <i>Post Messages</i>.\"\nchange_timezone_message = \"Please tell me your new UTC timezone.\\n\\nNote that this will change the timezone for all jobs set up in this chat.\\n\\n(swipe left to reply to this message)\"\ncheckcron_invalid_message = \"Alright, that is not a valid cron. Click <a href='https://crontab.guru/'>here</a> if you need help.\"  # html\nreset_confirmation_message = (\n    \"This will delete all the recurring message set up in this chat. Confirm?\"\n)\n\n# convo\nchoose_job_message = (\n    \"Choose the job you want to edit. The jobs are listed on the reply keyboard.\"\n)\nchoose_attribute_message = \"Which attribute would you like to change?\"\nprompt_new_value_message = \"What would you like to change it to?\"\nchoose_chat_message = \"Which chat would you like to change the sender for?\"\nprompt_user_bot_message = \"This will change the message sender to the selected chat.\\n\\nPlease send me your bot token:\"\nconvo_ended_message = \"Terminating previous conversation...\\n\\n/add another recurring message or /edit an existing one.\"\nreset_photos_confirmation_message = \"This will clear ALL photos for this job. Proceed?\"\n\n\ndef prepare_keyboard(\n    entries: List[Optional[Any]], field: str = \"jobname\"\n) -> Sequence[Sequence[Union[str, KeyboardButton]]]:\n    keyboard = []\n    for i, entry in enumerate(entries):\n        if i % 2 == 0:\n            keyboard.append([entry[field]])\n            continue\n        keyboard[len(keyboard) - 1].append(entry[field])\n    return keyboard\n\n\nasync def send_start_message(update: Update) -> None:\n    await update.message.reply_text(\n        reply_markup=ForceReply(selective=True),\n        text=start_message,\n        parse_mode=ParseMode.HTML,\n    )\n\n\nasync def send_help_message(update: Update) -> None:\n    await update.message.reply_text(\n        help_message, parse_mode=ParseMode.HTML, disable_web_page_preview=True\n    )\n\n\nasync def send_checkcron_message(update: Update) -> None:\n    await update.message.reply_text(\n        checkcron_message, reply_markup=ForceReply(selective=True)\n    )\n\n\nasync def send_request_jobname_message(update: Update) -> None:\n    await update.message.reply_text(\n        reply_markup=ForceReply(selective=True), text=request_jobname_message\n    )\n\n\nasync def send_request_jobs_message(update: Update) -> None:\n    await update.message.reply_text(\n        reply_markup=ForceReply(selective=True),\n        text=request_jobs_message,\n        parse_mode=ParseMode.HTML,\n    )\n\n\nasync def send_simple_prompt_message(update: Update) -> None:\n    await update.message.reply_text(simple_prompt_message)\n\n\nasync def send_delete_message(update: Update, entries: List[Optional[Any]]) -> None:\n    keyboard = prepare_keyboard(entries)\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard, one_time_keyboard=True, resize_keyboard=True\n    )\n\n    await update.message.reply_text(delete_message, reply_markup=reply_markup)\n\n\nasync def send_list_jobs_message(update: Update, entries: List[Optional[Any]]) -> None:\n    keyboard = prepare_keyboard(entries)\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard, one_time_keyboard=True, resize_keyboard=True\n    )\n    await update.message.reply_text(list_jobs_message, reply_markup=reply_markup)\n\n\nasync def send_choose_job_message(update: Update, entries: List[Optional[Any]]) -> None:\n    keyboard = prepare_keyboard(entries)\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard, one_time_keyboard=True, resize_keyboard=True\n    )\n    await update.message.reply_text(choose_job_message, reply_markup=reply_markup)\n\n\nasync def send_choose_attribute_message(update: Update) -> None:\n    keyboard = [edit.attrs[i : i + 2] for i in range(0, len(edit.attrs), 2)]\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard, one_time_keyboard=True, resize_keyboard=True\n    )\n    await update.message.reply_text(choose_attribute_message, reply_markup=reply_markup)\n\n\nasync def send_list_options_message(update: Update) -> None:\n    await update.message.reply_text(\n        list_options_message_group,\n        parse_mode=ParseMode.HTML,\n        disable_web_page_preview=True,\n    )\n\n\nasync def send_reset_confirmation_message(update: Update) -> None:\n    keyboard = [\n        [\n            InlineKeyboardButton(\"Confirm\", callback_data=1),\n            InlineKeyboardButton(\"Cancel\", callback_data=0),\n        ]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    await update.message.reply_text(\n        reset_confirmation_message, reply_markup=reply_markup\n    )\n\n\nasync def send_job_details(update: Update, entry: Optional[Any], bot_name: str) -> None:\n    photo_id = str(entry.get(\"photo_id\", \"\"))\n    content = entry.get(\"content\", \"\")\n\n    content_type = entry.get(\"content_type\", \"\")\n    if content_type == ContentType.POLL.value:\n        content = \"(Poll) %s\" % json.loads(content).get(\"question\")\n\n    is_paused = entry.get(\"paused_ts\", \"\") != \"\"\n    reply_text = \"<b>Job name</b>: {}\\n<b>Cron</b>: {}\\n<b>Content</b>: {}\\n<b>Photos</b>: {}\\n<b>Category</b>: {}\\n<b>Next run</b>: {}\\n\\n<b>Advanced options</b>\\nDelete previous: {}\\nSender: {}\\n\\n/edit\".format(\n        entry.get(\"jobname\", \"\"),\n        entry.get(\"crontab\", \"\"),\n        content,\n        \"no\" if photo_id == \"\" else len(photo_id.split(\";\")),\n        \"in-chat\" if entry.get(\"channel_id\", \"\") == \"\" else \"channel\",\n        \"paused\" if is_paused else entry.get(\"user_nextrun_ts\", \"\"),\n        \"enabled\" if entry.get(\"option_delete_previous\", \"\") != \"\" else \"disabled\",\n        bot_name,\n    )\n    await update.message.reply_text(\n        reply_text, parse_mode=ParseMode.HTML, reply_markup=ReplyKeyboardRemove()\n    )\n\n\nasync def send_request_crontab_message(update: Update) -> None:\n    await update.message.reply_text(\n        reply_markup=ForceReply(selective=True),\n        text=request_crontab_message,\n        parse_mode=ParseMode.HTML,\n        disable_web_page_preview=True,\n    )\n\n\nasync def send_request_text_message(update: Update) -> None:\n    await update.message.reply_text(\n        reply_markup=ForceReply(selective=True),\n        text=request_text_message,\n        parse_mode=ParseMode.HTML,\n        disable_web_page_preview=True,\n    )\n\n\nasync def send_confirm_message(\n    update: Update, entry: Optional[Any], cron_description: str\n) -> None:\n    content = 'message \"%s\"' % entry.get(\"content\")\n    if entry.get(\"content_type\") == ContentType.POLL.value:\n        content = ContentType.POLL.value\n    await update.message.reply_text(\n        text='Ok. Done. Added a job titled \"{}\". Your {} will be sent {}. {}'.format(\n            entry.get(\"jobname\"),\n            content,\n            cron_description,\n            \"\" if entry.get(\"channel_id\", \"\") == \"\" else add_to_channel_message,\n        ),\n        parse_mode=ParseMode.HTML,\n    )\n\n\nasync def send_checkcron_invalid_message(update: Update) -> None:\n    await update.message.reply_text(\n        text=checkcron_invalid_message,\n        parse_mode=ParseMode.HTML,\n        disable_web_page_preview=True,\n    )\n\n\nasync def send_checkcron_meaning_message(update: Update, cron_description: str) -> None:\n    await update.message.reply_text(checkcron_meaning_message + cron_description)\n\n\nasync def send_prompt_new_job_message(update: Update) -> None:\n    await update.message.reply_text(prompt_new_job_message)\n\n\nasync def send_change_timezone_message(update: Update) -> None:\n    await update.message.reply_text(\n        reply_markup=ForceReply(selective=True), text=change_timezone_message\n    )\n\n\nasync def send_convo_ended_message(update: Update) -> None:\n    await update.message.reply_text(\n        convo_ended_message, reply_markup=ReplyKeyboardRemove()\n    )\n\n\nasync def send_prompt_new_value_message(update: Update) -> None:\n    await update.message.reply_text(\n        prompt_new_value_message,\n        reply_markup=ForceReply(selective=True),\n    )\n\n\nasync def send_reset_photos_confirmation_message(update: Update) -> None:\n    keyboard = [[\"yes\", \"no\"]]\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard, one_time_keyboard=True, resize_keyboard=True\n    )\n    await update.message.reply_text(\n        reset_photos_confirmation_message, reply_markup=reply_markup\n    )\n\n\nasync def send_prompt_user_bot_message(update: Update) -> None:\n    await update.message.reply_text(\n        prompt_user_bot_message, reply_markup=ReplyKeyboardRemove()\n    )\n\n\nasync def send_choose_chat_message(\n    update: Update, entries: List[Optional[Any]]\n) -> None:\n    keyboard = prepare_keyboard(entries, field=\"chat_title\")\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard, one_time_keyboard=True, resize_keyboard=True\n    )\n    await update.message.reply_text(choose_chat_message, reply_markup=reply_markup)\n"}
{"type": "source_file", "path": "bot/handlers.py", "content": "from telegram.ext._contexttypes import ContextTypes\nfrom typing import Dict\n\nfrom bot.actions import actions\nfrom bot.replies import replies\nfrom bot.types import MESSAGE_HANDLER\nfrom teleapi import endpoints as teleapi\nfrom telegram import Update\nfrom typing import Optional\n\nmessage_handler_map: Dict[str, MESSAGE_HANDLER] = {\n    replies.request_jobname_message: actions.add_new_job,\n    replies.request_text_message: actions.add_message,\n    replies.delete_message: actions.remove_job,\n    replies.start_message: actions.add_timezone,\n    replies.list_jobs_message: actions.show_job_details,\n    replies.checkcron_message: actions.decrypt_cron,\n    replies.request_jobs_message: actions.add_new_jobs,\n    replies.request_crontab_message: actions.update_crontab,\n    replies.invalid_crontab_message: actions.update_crontab,\n    replies.change_timezone_message: actions.update_timezone,\n}\n\n\nasync def handle_messages(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> Optional[Exception]:\n    if update.message is None:\n        return\n\n    # job creation for channels\n    if update.message.forward_from_chat is not None:\n        return await actions.add_new_channel_job(update)\n\n    # job creation for groups/private chats\n    reply_to_message = update.message.reply_to_message\n    if reply_to_message is None:\n        return\n\n    text = reply_to_message.text_html\n    handler = message_handler_map.get(text, None)\n    if handler is None:\n        return\n\n    err = await handler(update, context)\n    if err is None:\n        teleapi.delete_message(\n            update.message.chat.id,\n            reply_to_message.message_id,\n        )\n\n\nasync def handle_photos(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> Optional[Exception]:\n    if update.message is None:\n        return\n\n    # job creation for channels\n    if update.message.forward_from_chat is not None:\n        return await actions.add_new_channel_job(update)\n\n    reply_to_message = update.message.reply_to_message\n    if reply_to_message is None:\n        return\n\n    if reply_to_message.text_html == replies.request_text_message:\n        err = await actions.add_message(update, context, True)\n        if err is None:\n            teleapi.delete_message(update.message.chat.id, reply_to_message.message_id)\n\n\nasync def handle_polls(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> Optional[Exception]:\n    if update.message is None:\n        return\n\n    # job creation for channels\n    is_channel_job = update.message.forward_from_chat is not None\n    if update.message.poll.type == \"quiz\" and (\n        update.message.chat.type != \"private\" or is_channel_job\n    ):\n        return await replies.send_quiz_unavailable_message(update)\n\n    if is_channel_job:\n        return await actions.add_new_channel_job(update=update, poll=True)\n\n    reply_to_message = update.message.reply_to_message\n    if reply_to_message is None:\n        return\n\n    if reply_to_message.text_html == replies.request_text_message:\n        err = await actions.add_message(\n            update=update, context=context, photo=False, poll=True\n        )\n        if err is None:\n            teleapi.delete_message(update.message.chat.id, reply_to_message.message_id)\n\n\nasync def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    query = update.callback_query\n    if query.data == \"1\":\n        await actions.reset_chat(update, context)\n    await context.bot.editMessageReplyMarkup(\n        chat_id=query.message.chat_id, message_id=query.message.message_id\n    )\n    await query.answer()\n"}
{"type": "source_file", "path": "bot/ptb.py", "content": "from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nimport config\nfrom telegram.ext import Application\nfrom typing import AsyncGenerator\n\n# https://github.com/python-telegram-bot/python-telegram-bot/wiki/Handling-network-errors\nptb = (\n    Application.builder()\n    .token(config.TELEGRAM_BOT_TOKEN)\n    .read_timeout(7)\n    .get_updates_read_timeout(42)\n)\nif config.ENV:\n    ptb = ptb.updater(None)\nptb = ptb.build()\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI) -> AsyncGenerator:\n    if config.BOTHOST:\n        await ptb.bot.setWebhook(config.BOTHOST)\n    async with ptb:\n        await ptb.start()\n        yield\n        await ptb.stop()\n"}
{"type": "source_file", "path": "bot/actions/permissions.py", "content": "from telegram.ext._contexttypes import ContextTypes\nfrom telegram import Update\nfrom bot.replies import replies\nfrom common.enums import Restriction\nfrom database import mongo\nfrom database.dbutils import dbutils\nfrom typing import Optional\n\n\nasync def restrict_to_admins(update: Update, db_service: mongo.MongoService) -> None:\n    chat_id = update.message.chat.id\n\n    db_service = mongo.MongoService(update)\n    entry = dbutils.find_chat_by_chatid(db_service, chat_id)\n    if entry is None:\n        return\n\n    current_restriction = entry.get(\"restriction\", \"\")\n\n    if current_restriction == Restriction.ADMIN.value:\n        dbutils.update_chat_entry(db_service, chat_id, {\"restriction\": \"\"})\n        return await replies.send_restrict_success_message(update, \"everyone\")\n\n    if current_restriction == Restriction.OWNER.value:\n        return await replies.send_wrong_restriction_message(\n            update, \"the current bot user\"\n        )\n\n    payload = {\"restriction\": Restriction.ADMIN.value}\n    dbutils.update_chat_entry(db_service, chat_id, payload)\n    return await replies.send_restrict_success_message(update, \"only group admins\")\n\n\nasync def check_rights(\n    update: Update,\n    context: ContextTypes.DEFAULT_TYPE,\n    db_service: mongo.MongoService,\n    must_be_admin: bool = False,\n) -> bool:\n    message = update.callback_query if update.message is None else update.message\n    user_id = message.from_user.id\n    group_id = await get_chat_id(update, context)\n\n    entry = dbutils.find_chat_by_chatid(db_service, group_id)\n    if entry is None:\n        await replies.send_start_message(update)\n        return False\n\n    current_restriction = entry.get(\"restriction\")\n    is_creator = str(user_id) == str(entry.get(\"created_by\", \"\"))\n    if current_restriction == Restriction.OWNER.value and not is_creator:\n        await replies.send_user_unauthorized_error_message(\n            update, \"the current bot user\"\n        )\n        return False\n\n    admin_roles = [Restriction.ADMIN.value, Restriction.OWNER.value]\n    chat_member = await context.bot.get_chat_member(group_id, user_id)\n    is_admin = chat_member.status in admin_roles\n    must_be_admin = must_be_admin or current_restriction == Restriction.ADMIN.value\n    if must_be_admin and not is_admin:\n        await replies.send_user_unauthorized_error_message(update, \"group admins\")\n        return False\n\n    return True\n\n\nasync def restrict_to_user(update: Update, db_service: mongo.MongoService) -> None:\n    # user running this command must be creator\n    chat_id = update.message.chat.id\n    entry = dbutils.find_chat_by_chatid(db_service, chat_id)\n    if entry is None:\n        return\n\n    user_id = update.message.from_user.id\n    if str(user_id) != str(entry.get(\"created_by\", \"\")):\n        await replies.send_user_unauthorized_error_message(\n            update, \"the current bot user\"\n        )\n        return\n\n    current_restriction = entry.get(\"restriction\", \"\")\n    if current_restriction == Restriction.ADMIN.value:\n        return await replies.send_wrong_restriction_message(update, \"group admins\")\n\n    if current_restriction == Restriction.OWNER.value:\n        dbutils.update_chat_entry(db_service, chat_id, {\"restriction\": \"\"})\n        return await replies.send_restrict_success_message(update, \"everyone\")\n\n    dbutils.update_chat_entry(\n        db_service, chat_id, {\"restriction\": Restriction.OWNER.value}\n    )\n    return await replies.send_restrict_success_message(update, \"only you\")\n\n\nasync def get_chat_id(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> Optional[int]:\n    chat_id = -1\n    if update.message is not None:  # text message\n        return update.message.chat.id\n    elif update.callback_query is not None:  # callback message\n        return update.callback_query.message.chat.id\n    elif update.poll is not None:  # answer in Poll\n        return context.bot_data[update.poll.id]\n    return chat_id\n"}
{"type": "source_file", "path": "bot/actions/actions.py", "content": "from bot.replies import replies\nfrom common import log, utils\nfrom common.enums import ContentType\nfrom database import mongo\nfrom database.dbutils import dbutils\nfrom cron_descriptor import get_description\nfrom teleapi import endpoints as teleapi\nfrom telegram import Update\nfrom bot.actions import permissions\nfrom bot.actions.readonly import *\nfrom bot.actions.removals import *\nfrom typing import Dict, Tuple, Optional, Any\n\n\nasync def add_new_job(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> Optional[Exception]:\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return Exception()\n\n    # timezone must be defined in order to create new job\n    chat_entry = dbutils.find_chat_by_chatid(db_service, update.message.chat.id)\n    if chat_entry is None:\n        await replies.send_start_message(update)\n        return Exception()\n\n    # person limit\n    user_id = update.message.from_user.id\n    job_count, user_limit = dbutils.get_user_limit(db_service, user_id)\n    if job_count >= user_limit:\n        await replies.send_exceed_limit_error_message(update, user_limit)\n        return Exception()\n\n    # check name does not already exist\n    chat_id = update.message.chat.id\n    if dbutils.entry_exists(db_service, chat_id, update.message.text):\n        await replies.send_invalid_new_job_message(update)\n        return Exception()\n\n    # add job to db\n    msg = update.message\n    dbutils.add_new_entry(\n        db_service,\n        chat_id=msg.chat.id,\n        jobname=msg.text,\n        user_id=msg.from_user.id,\n        user_bot_token=chat_entry.get(\"user_bot_token\"),\n        message_thread_id=msg.message_thread_id if msg.is_topic_message else None,\n    )\n    await replies.send_request_text_message(update)\n    log.log_new_job_added(update)\n\n\nasync def add_new_channel_job(\n    update: Update, poll: bool = False\n) -> Optional[Exception]:\n    chat_id = update.message.chat.id\n    # channel jobs can only be set up from private chats\n    if update.message.chat.type != \"private\":\n        return Exception()\n\n    forwarded_chat_info = update.message.forward_from_chat\n\n    # job creation by forwarded messages only for channels\n    if forwarded_chat_info.type != \"channel\":\n        await replies.send_channels_only_error_message(update, forwarded_chat_info.type)\n        return Exception()\n\n    db_service = mongo.MongoService(update)\n    # timezone must be defined in order to create new job\n    chat_entry = dbutils.find_chat_by_chatid(db_service, chat_id)\n    if chat_entry is None:\n        await replies.send_start_message(update)\n        return Exception()\n\n    # add chat to db\n    chat_exists = dbutils.chat_exists(db_service, forwarded_chat_info.id)\n    user_id = update.message.from_user.id\n    if not chat_exists:\n        dbutils.add_chat_data(\n            db_service,\n            chat_id=forwarded_chat_info.id,\n            chat_title=forwarded_chat_info.title,\n            chat_type=forwarded_chat_info.type,\n            tz_offset=chat_entry.get(\"tz_offset\"),\n            utc_tz=\"\",\n            created_by=user_id,\n            telegram_ts=update.message.date,\n        )\n\n    # add job to db\n    entry = dbutils.find_latest_entry(db_service, chat_id)\n    photo_group_id = update.message.media_group_id\n    photo_group_id = \"\" if photo_group_id is None else str(photo_group_id)\n\n    if (\n        entry is not None\n        and len(photo_group_id) > 0\n        and photo_group_id == str(entry.get(\"photo_group_id\", \"\"))\n    ):  # same photo group\n        photo_id = update.message.photo[-1].file_id\n        photo_ids = \"{};{}\".format(entry.get(\"photo_id\", \"\"), photo_id)\n        payload = {\"last_updated_by\": user_id, \"photo_id\": photo_ids}\n        dbutils.update_entry_by_jobname(db_service, entry, payload)\n        return\n\n    # new job to be created, assert job limit\n    job_count, user_limit = dbutils.get_user_limit(db_service, user_id)\n    if job_count >= user_limit:\n        await replies.send_exceed_limit_error_message(update, user_limit)\n        return Exception()\n\n    # add new job\n    content = update.message.caption\n    content_type = ContentType.MEDIA.value\n    if len(update.message.photo) < 1:\n        content = update.message.text_html\n        content_type = ContentType.TEXT.value\n    elif photo_group_id == \"\":\n        content = update.message.caption_html\n        content_type = ContentType.PHOTO.value\n    content = \"\" if content is None else content\n\n    if poll:\n        content_type = ContentType.POLL.value\n        content = update.message.poll.to_json()\n\n    photo_id = \"\" if len(update.message.photo) < 1 else update.message.photo[-1].file_id\n\n    # populate jobname for channels\n    jobname = generate_jobname(db_service, forwarded_chat_info.title[:6], chat_id)\n    dbutils.add_new_entry(\n        db_service,\n        chat_id=chat_id,\n        channel_id=forwarded_chat_info.id,\n        jobname=jobname,\n        user_id=update.message.from_user.id,\n        crontab=\"\",\n        content=content,\n        content_type=content_type,\n        photo_id=photo_id,\n        photo_group_id=photo_group_id,\n        user_bot_token=chat_entry.get(\"user_bot_token\"),\n        message_thread_id=None,\n    )\n\n    log.log_new_channel_job_added(update)\n    await replies.send_request_crontab_message(update)\n\n\nasync def add_new_jobs(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> Optional[Exception]:\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return Exception()\n\n    # timezone must be defined in order to create new job\n    chat_id = update.message.chat.id\n    if dbutils.find_chat_by_chatid(db_service, chat_id) is None:\n        await replies.send_start_message(update)\n        return Exception()\n\n    # parse user response\n    res = utils.extract_jobs(update.message.text_html)\n    new_job_count = len(res)\n\n    # person limit\n    user_id = update.message.from_user.id\n    current_job_count, user_limit = dbutils.get_user_limit(db_service, user_id)\n    if current_job_count + new_job_count > user_limit:\n        await replies.send_exceed_limit_error_message(update, user_limit)\n        return Exception()\n\n    successful_creation = []\n\n    chat_entry = dbutils.find_chat_by_chatid(db_service, chat_id)\n    user_tz_offset = chat_entry.get(\"tz_offset\")\n    for crontab, text_content in res:\n        # arrange next run date and time\n        try:\n            user_nextrun, db_nextrun = utils.calc_next_run(crontab, user_tz_offset)\n        except Exception:\n            continue\n\n        jobname = generate_jobname(db_service, update.message.chat.type, chat_id)\n        msg = update.message\n        dbutils.add_new_entry(\n            db_service,\n            chat_id=chat_id,\n            jobname=jobname,\n            user_id=user_id,\n            crontab=crontab,\n            content=text_content,\n            content_type=ContentType.TEXT.value,\n            nextrun_ts=db_nextrun,\n            user_nextrun_ts=user_nextrun,\n            user_bot_token=chat_entry.get(\"user_bot_token\"),\n            message_thread_id=msg.message_thread_id if msg.is_topic_message else None,\n        )\n\n        successful_creation.append(\"%s: (%s) %s\" % (jobname, crontab, text_content))\n\n    if len(successful_creation) > 0:\n        log.log_new_jobs_added(update, \" // \".join(successful_creation))\n        postfix = \"\\n\".join(\" %s\" % x for x in successful_creation)\n        await replies.send_jobs_creation_success_message(update, postfix)\n    else:\n        await replies.send_error_message(update)\n\n\nasync def add_timezone(\n    update: Update, _: ContextTypes.DEFAULT_TYPE\n) -> Optional[Exception]:\n    # check validity\n    tz_values = utils.extract_tz_values(update.message.text)\n    if not tz_values:\n        await replies.send_error_message(update)\n        return Exception()\n\n    utc_tz, tz_offset = utils.calc_tz(tz_values)\n    if tz_offset < -12 or tz_offset > 14:\n        await replies.send_error_message(update)\n        return Exception()\n\n    db_service = mongo.MongoService(update)\n\n    chat_exists = dbutils.chat_exists(db_service, update.message.chat.id)\n    if not chat_exists:\n        dbutils.add_chat_data(\n            db_service,\n            chat_id=update.message.chat.id,\n            chat_title=update.message.chat.title,\n            chat_type=update.message.chat.type,\n            tz_offset=tz_offset,\n            utc_tz=utc_tz,\n            created_by=update.message.from_user.id,\n            telegram_ts=update.message.date,\n        )\n\n    await replies.send_help_message(update)\n\n\nasync def add_message(\n    update: Update,\n    context: ContextTypes.DEFAULT_TYPE,\n    photo: bool = False,\n    poll: bool = False,\n) -> Optional[Exception]:\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return Exception()\n\n    chat_id = update.message.chat.id\n    entry = dbutils.find_latest_entry(db_service, chat_id)\n    if entry is None:\n        await replies.send_simple_prompt_message(update)\n        return Exception()\n\n    last_updated_by = update.message.from_user.id\n    payload = {\"last_updated_by\": update.message.from_user.id}\n\n    photo_group_id = update.message.media_group_id\n    photo_group_id = \"\" if photo_group_id is None else str(photo_group_id)\n    same_photo_group = len(photo_group_id) > 0 and photo_group_id == str(\n        entry.get(\"photo_group_id\", \"\")\n    )\n\n    if same_photo_group:  # group of photos\n        photo_id = update.message.photo[-1].file_id\n        photo_ids = \"{};{}\".format(entry.get(\"photo_id\", \"\"), photo_id)\n        payload[\"photo_id\"] = photo_ids\n        payload[\"content_type\"] = ContentType.MEDIA.value\n    elif entry.get(\"content\", \"\") != \"\":  # field must not be filled already\n        await replies.send_prompt_new_job_message(update)\n        return Exception()\n    elif poll:\n        payload[\"content_type\"] = ContentType.POLL.value\n        payload[\"content\"] = update.message.poll.to_json()\n    elif photo and photo_group_id != \"\":  # first photo of media group\n        payload[\"photo_id\"] = update.message.photo[-1].file_id\n        payload[\"photo_group_id\"] = photo_group_id\n        payload[\"content\"] = (\n            \"\" if update.message.caption is None else update.message.caption\n        )\n        payload[\"content_type\"] = ContentType.MEDIA.value\n    elif photo:  # single photo\n        payload[\"photo_id\"] = update.message.photo[-1].file_id\n        payload[\"photo_group_id\"] = photo_group_id\n        caption = \"\" if update.message.caption is None else update.message.caption_html\n        payload[\"content\"] = caption\n        payload[\"content_type\"] = ContentType.PHOTO.value\n    else:  # only text\n        payload[\"content\"] = update.message.text_html\n        payload[\"content_type\"] = ContentType.TEXT.value\n\n    dbutils.update_entry_by_jobname(db_service, entry, payload)\n    log.log_new_content_added(last_updated_by, entry.get(\"jobname\"), chat_id)\n\n    # reply\n    if not same_photo_group:\n        await replies.send_request_crontab_message(update)\n\n\nasync def prepare_crontab_update(\n    update: Update, crontab: str, db_service: mongo.MongoService\n) -> Tuple[Optional[str], Optional[Dict[str, Any]], Optional[Exception]]:\n    try:\n        description = get_description(crontab).lower()\n    except Exception:  # crontab is not valid\n        await replies.send_invalid_crontab_message(update)\n        return None, None, Exception()\n\n    # arrange next run date and time\n    chat_entry = dbutils.find_chat_by_chatid(db_service, update.message.chat.id)\n    user_tz_offset = chat_entry.get(\"tz_offset\")\n    try:\n        user_nextrun_ts, db_nextrun_ts = utils.calc_next_run(crontab, user_tz_offset)\n    except Exception:\n        await replies.send_invalid_crontab_message(update)\n        return None, None, Exception()\n\n    # update db entry\n    payload = {\n        \"crontab\": crontab,\n        \"nextrun_ts\": db_nextrun_ts,\n        \"user_nextrun_ts\": user_nextrun_ts,\n        \"last_updated_by\": update.message.from_user.id,\n    }\n    return description, payload, None\n\n\nasync def update_crontab(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> Optional[Exception]:\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return Exception()\n    entry = dbutils.find_latest_entry(db_service, update.message.chat.id)\n    if entry is None:\n        await replies.send_simple_prompt_message(update)\n        return Exception()\n    if entry.get(\"crontab\", \"\") != \"\":  # field must be empty\n        await replies.send_prompt_new_job_message(update)\n        return Exception()\n\n    crontab = update.message.text\n    description, payload, err = await prepare_crontab_update(\n        update, crontab, db_service\n    )\n    if err is not None:\n        return Exception()\n\n    user_id = update.message.from_user.id\n    jobname, chat_id = entry.get(\"jobname\"), entry.get(\"chat_id\")\n    dbutils.update_entry_by_jobname(db_service, entry, payload)\n    log.log_crontab_updated(user_id, jobname, chat_id)\n\n    # special case  transfer photo ownership to new sender\n    is_single_photo = entry[\"content_type\"] == ContentType.PHOTO.value\n    bot_token = entry.get(\"user_bot_token\")\n    if is_single_photo and bot_token is not None:\n        resp, new_photo_id = teleapi.transfer_photo_between_bots(\n            db_service, bot_token, None, chat_id, entry\n        )\n        log.log_photo_transferred(user_id, new_photo_id, chat_id, resp.status_code)\n\n    await replies.send_confirm_message(update, entry, description)\n\n\nasync def update_timezone(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> Optional[Exception]:\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return Exception()\n\n    # check validity\n    tz_values = utils.extract_tz_values(update.message.text)\n    if not tz_values:\n        await replies.send_error_message(update)\n        return Exception()\n\n    utc_tz, tz_offset = utils.calc_tz(tz_values)\n    if tz_offset < -12 or tz_offset > 14:\n        return await replies.send_error_message(update)\n\n    # retrieve current chat data\n    chat_id = update.message.chat.id\n    chat_entry = dbutils.find_chat_by_chatid(db_service, chat_id)\n    if chat_entry is None:\n        await replies.send_start_message(update)\n        return Exception()\n\n    if tz_offset == chat_entry.get(\"tz_offset\", \"\"):\n        await replies.send_timezone_nochange_error_message(update)\n        return Exception()\n\n    # update chat entry\n    payload = {\"tz_offset\": tz_offset, \"utc_tz\": utc_tz}\n    dbutils.update_chat_entry(db_service, chat_id, payload, \"utc_tz\")\n\n    if chat_entry.get(\"chat_type\", \"\") == \"private\":\n        user_id = update.message.from_user.id\n        dbutils.update_chats_tz_by_type(db_service, user_id, tz_offset, \"channel\")\n\n    # update job entries\n    job_entries = dbutils.find_entries_by_chatid(db_service, update.message.chat.id)\n    for job_entry in job_entries:\n        if job_entry.get(\"nextrun_ts\", \"\") == \"\":\n            continue\n        crontab = job_entry.get(\"crontab\", \"\")\n        user_nextrun_ts, db_nextrun_ts = utils.calc_next_run(crontab, tz_offset)\n        payload = {\"nextrun_ts\": db_nextrun_ts, \"user_nextrun_ts\": user_nextrun_ts}\n        dbutils.update_entry_by_jobname(db_service, job_entry, payload)\n\n    await replies.send_timezone_change_success_message(update, utc_tz)\n\n\ndef generate_jobname(\n    db_service: mongo.MongoService, job_prefix: str, chat_id: int\n) -> str:\n    number = 1\n    jobname = \"%s (%d)\" % (job_prefix, number)\n    while dbutils.entry_exists(db_service, chat_id, jobname):\n        number = number + 1\n        jobname = \"%s (%d)\" % (job_prefix, number)\n    return jobname\n"}
{"type": "source_file", "path": "common/log.py", "content": "import logging\nfrom telegram import Update\nfrom typing import Dict, Any, Optional\n\nlogging.basicConfig(\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\", level=logging.INFO\n)\n\nlogger = logging.getLogger(__name__)\n\nhttpx_logger = logging.getLogger(\"httpx\")\nhttpx_logger.setLevel(logging.WARNING)\n\n\n# bot\ndef log_new_job_added(update: Update) -> None:\n    logger.info(\n        '[BOT] User \"%s\" added new job \"%s\" in room \"%s\", chat_id=%s',\n        update.message.from_user.id,\n        update.message.text,\n        update.message.chat.title,\n        update.message.chat.id,\n    )\n\n\ndef log_new_jobs_added(update: Update, jobs_string: str) -> None:\n    logger.info(\n        '[BOT] User \"%s\" added several jobs \"%s\" in room \"%s\", chat_id=%s',\n        update.message.from_user.id,\n        jobs_string,\n        update.message.chat.title,\n        update.message.chat.id,\n    )\n\n\ndef log_new_channel_job_added(update: Update) -> None:\n    logger.info(\n        '[BOT] User \"%s\" added new job/content for a channel, chat_id=%s',\n        update.message.from_user.id,\n        update.message.chat.id,\n    )\n\n\ndef log_new_content_added(last_updated_by: str, jobname: str, chat_id: int) -> None:\n    msg = '[BOT] User \"%s\" added new message content for job \"%s\", chat_id=%s'\n    logger.info(msg, last_updated_by, jobname, chat_id)\n\n\ndef log_new_channel_jobname_added(entry: Optional[Any]) -> None:\n    logger.info(\n        '[BOT] User \"%s\" added jobname \"%s\" in channel, channel_id=%s, chat_id=%s',\n        entry.get(\"last_updated_by\"),\n        entry.get(\"jobname\"),\n        entry.get(\"channel_id\"),\n        entry.get(\"chat_id\"),\n    )\n\n\ndef log_bot_updated(user_id: int, bot_data: Dict[str, Any]) -> None:\n    msg = '[BOT] User \"%s\" upserted bot \"%s\"'\n    logger.info(msg, user_id, bot_data.get(\"username\"))\n\n\ndef log_crontab_updated(last_updated_by: str, jobname: str, chat_id: int) -> None:\n    msg = '[BOT] User \"%s\" added new crontab for job \"%s\", chat_id=%s'\n    logger.info(msg, last_updated_by, jobname, chat_id)\n\n\ndef log_job_removed(last_updated_by: str, jobname: str, chat_id: str) -> None:\n    msg = '[BOT] User \"%s\" removed job \"%s\", chat_id=%s'\n    logger.info(msg, last_updated_by, jobname, chat_id)\n\n\ndef log_option_updated(\n    updated_fields: Dict[str, Any], option: str, jobname: str, chat_id: int\n) -> None:\n    logger.info(\n        '[BOT] User \"%s\" updated option \"%s\" to \"%s\" for job \"%s\", chat_id=%s',\n        updated_fields[\"last_updated_by\"],\n        option,\n        updated_fields[option],\n        jobname,\n        chat_id,\n    )\n\n\ndef log_sender_updated(\n    user_id: int, prev_sender: str, new_sender: str, chat_id: int\n) -> None:\n    msg = '[BOT] User \"%s\" updated sender from \"%s\" to \"%s\", chat_id=%s'\n    logger.info(msg, user_id, prev_sender, new_sender, chat_id)\n\n\ndef log_chat_reset(update: Update) -> None:\n    logger.info(\n        '[BOT] User \"%s\" reset chat, chat_id=%s',\n        update.callback_query.from_user.id,\n        update.callback_query.message.chat_id,\n    )\n\n\ndef log_photo_transferred(\n    user_id: int, new_photo_id: int, chat_id: int, status: int\n) -> None:\n    msg = '[BOT] User \"%s\" transferred photo \"%s\", chat_id=\"%d\", status=%d'\n    logger.info(msg, user_id, new_photo_id, chat_id, status)\n\n\n# database\ndef log_new_entry(jobname: str, chat_id: int) -> None:\n    msg = '[DB] Created new job, jobname=\"%s\", chat_id=%s'\n    logger.info(msg, jobname, str(chat_id))\n\n\ndef log_new_chat(chat_id: int, chat_title: str) -> None:\n    msg = \"[DB] Created new chat entry, chat_id=%s, chat_title=%s\"\n    logger.info(msg, str(chat_id), chat_title)\n\n\ndef log_new_user(user_id: int, username: str) -> None:\n    msg = '[DB] Created new user, user_id=%s, username=\"%s\"'\n    logger.info(msg, str(user_id), username)\n\n\ndef log_entry_updated(entry: Optional[Any]) -> None:\n    msg = '[DB] Updated job entry \"%s\", chat_id=%s'\n    logger.info(msg, entry.get(\"jobname\"), str(entry.get(\"chat_id\")))\n\n\ndef log_chat_entry_updated(\n    chat_id: int, updated_field: str, updated_value: str\n) -> None:\n    msg = '[DB] Updated chat %s to \"%s\", chat_id=%s'\n    logger.info(msg, updated_field, updated_value, chat_id)\n\n\ndef log_chats_tz_updated_by_type(\n    count: int, user_id: int, chat_type: str, tz_offset: float\n) -> None:\n    msg = \"[DB] Bulk updated timezone for %d chats, chat_type=%s, user_id=%s, new tz_offset=%d\"\n    logger.info(msg, count, chat_type, user_id, tz_offset)\n\n\ndef log_user_updated(entry: Optional[Any]) -> None:\n    msg = '[DB] Superseded user, user_id=%s, field_changed=\"%s\"'\n    logger.info(msg, entry.get(\"user_id\"), entry.get(\"field_changed\"))\n\n\ndef log_username_updated(update: Update) -> None:\n    msg = \"[DB] Superseded username, new username=%s, user_id=%s\"\n    logger.info(msg, update.message.from_user.username, update.message.from_user.id)\n\n\ndef log_firstname_updated(update: Update) -> None:\n    logger.info(\n        \"[DB] Superseded first_name, new first_name=%s, username=%s, user_id=%s\",\n        update.message.from_user.first_name,\n        update.message.from_user.username,\n        update.message.from_user.id,\n    )\n\n\ndef log_update_details(result: Optional[Any]) -> None:\n    logger.info(\n        f\"[DB] Updated mongo, matched={result.matched_count}, modified={result.modified_count}\",\n    )\n\n\n# api\ndef log_api_previous_message_deletion(\n    chat_id: int, message_id: str, status_code: int\n) -> None:\n    msg = \"[TELEGRAM API] Deleted previous message, response_status=%s, chat_id=%s, message_id=%s\"\n    logger.info(msg, status_code, chat_id, message_id)\n\n\ndef log_api_send_message(job_id: int, chat_id: int, status_code: int) -> None:\n    msg = '[TELEGRAM API] Sent message, job_id=\"%s\", chat_id=%s, response_status=%s'\n    logger.info(msg, job_id, chat_id, status_code)\n\n\ndef log_entry_count(count: int) -> None:\n    logger.info(\"[TELEGRAM API] Processing %d message(s) to send this time...\", count)\n\n\ndef log_completion(total_count: int) -> None:\n    logger.info(\"[TELEGRAM API] Finished processing %d messages\", total_count)\n\n\n# prometheus\ndef log_update_prometheus(metric: int, value: float) -> None:\n    logger.info(\n        f\"[PROMETHEUS] Updated Prometheus, metric={metric}, value={value}\",\n    )\n\n\n# influx\ndef log_influx_resp(measurement: str, field: str, value: int) -> None:\n    logger.info(\n        f\"[INFLUX] Updated influx, measurement={measurement}, field={field}, value={value}\"\n    )\n\n\n# script\ndef log_update_count(count: int) -> None:\n    logger.info(\"[SCRIPT] Processing %d message(s) to revive...\", count)\n"}
{"type": "source_file", "path": "bot/replies/errors.py", "content": "from config import JOB_LIMIT_PER_PERSON, BOT_NAME\nfrom telegram import ForceReply, Update\nfrom telegram.constants import ParseMode\n\nerror_message = \"You know that's not right...\"\nexceed_limit_error_message = (\n    \"Recurring Messages currently only supports %d jobs per person, in an effort to reduce spam.\\n\\n__custom_message__If you need to create more than __limit__ jobs, please contact the bot owner at hs.develops.1@gmail.com specifying:\\n1. the number of jobs you need, and\\n2. your Telegram handle.\\n\\n<b>Enjoying the bot?</b>\\nYou can <a href='https://www.buymeacoffee.com/rmteam'>buy the RM team a coffee</a>!\"\n    % (JOB_LIMIT_PER_PERSON)\n)  # html\nchannels_only_error_message = \"Job creation by forwarded messages is only enabled for channels. Please run the /add command in your __chat_type__ chat.\"\nuser_unauthorized_error_message = \"Oh no... You are unauthorized to run this command. Please check with __bot_ic__ if you think this is an error.\"\nwrong_restrction_error_message = (\n    \"Restriction is already set. Please ask __bot_ic__ to unset bot restriction first.\"\n)\ntimezone_nochange_error_message = \"Whut? That's the same timezone!\"\ninvalid_new_job_message = \"A job with this name already exists. Please /add and create a new job, or /edit this job.\"\nquiz_unavailable_message = 'Recurring messages unfortunately cannot support recurring quizzes in channels and groups... because Telegram does not return the correct option id for forwarded messages () (<a href=\"https://docs.python-telegram-bot.org/en/v12.5.1/telegram.poll.html#telegram.Poll.correct_option_id\">see docs</a>)'\ninvalid_crontab_message = 'This expression is invalid. Please provide a valid expression. Click <a href=\"https://crontab.guru/\">here</a> if you need help. Use /checkcron to check your cron expression.'  # html\nconvo_unauthorized_message = (\n    \"Only the user who started this convo can continue this convo.\"\n)\nno_photos_to_delete_error_message = \"No photos to delete. Ending conversation...\"\nattribute_change_error_message = \"Something went wrong on the server... Please contact the bot owner at hs.develops.1@gmail.com.\"\nprivate_only_error_message = \"This command can only be run in private chat with %s\"\nmissing_chats_error_message = \"Please add and set up %s in a group\"\nmissing_bot_in_group_message = \"Terminating conversation... \\n\\nPlease add bot into the group as an admin and enable:\\n1. <i>Change Channel Info</i> and\\n2. <i>Post Messages</i>\\nbefore running /changesender.\"\n\n\nasync def send_error_message(update: Update) -> None:\n    await update.message.reply_text(error_message)\n\n\nasync def send_exceed_limit_error_message(update: Update, limit: int) -> None:\n    reply_text = exceed_limit_error_message.replace(\"__limit__\", str(limit))\n    if limit == JOB_LIMIT_PER_PERSON:\n        reply_text = reply_text.replace(\"__custom_message__\", \"\")\n    elif limit < JOB_LIMIT_PER_PERSON:\n        reply_text = reply_text.replace(\n            \"__custom_message__\",\n            \"However, we have received reports of spam from you and as a result you have been blacklisted.\\n\\n\",\n        )\n    else:\n        reply_text = reply_text.replace(\n            \"__custom_message__\",\n            \"As per prior request we have increased your limit to %d.\\n\\n\" % limit,\n        )\n    await update.message.reply_text(\n        text=reply_text,\n        parse_mode=ParseMode.HTML,\n        disable_web_page_preview=True,\n    )\n\n\nasync def send_channels_only_error_message(update: Update, chat_type: str) -> None:\n    reply = channels_only_error_message.replace(\"__chat_type__\", chat_type)\n    await update.message.reply_text(reply)\n\n\nasync def send_user_unauthorized_error_message(update: Update, bot_ic: str) -> None:\n    reply = user_unauthorized_error_message.replace(\"__bot_ic__\", bot_ic)\n    await update.message.reply_text(reply)\n\n\nasync def send_wrong_restriction_message(update: Update, bot_ic: str) -> None:\n    reply = wrong_restrction_error_message.replace(\"__bot_ic__\", bot_ic)\n    await update.message.reply_text(reply)\n\n\nasync def send_timezone_nochange_error_message(update: Update) -> None:\n    await update.message.reply_text(timezone_nochange_error_message)\n\n\nasync def send_invalid_crontab_message(update: Update) -> None:\n    await update.message.reply_text(\n        reply_markup=ForceReply(selective=True),\n        text=invalid_crontab_message,\n        parse_mode=ParseMode.HTML,\n        disable_web_page_preview=True,\n    )\n\n\nasync def send_invalid_new_job_message(update: Update) -> None:\n    await update.message.reply_text(invalid_new_job_message)\n\n\nasync def send_quiz_unavailable_message(update: Update) -> None:\n    await update.message.reply_text(\n        text=quiz_unavailable_message,\n        parse_mode=ParseMode.HTML,\n        disable_web_page_preview=True,\n    )\n\n\nasync def send_no_photos_to_delete_error_message(update: Update) -> None:\n    await update.message.reply_text(no_photos_to_delete_error_message)\n\n\nasync def send_attribute_change_error_message(update: Update) -> None:\n    await update.message.reply_text(attribute_change_error_message)\n\n\nasync def send_private_only_error_message(update: Update) -> None:\n    await update.message.reply_text(private_only_error_message % BOT_NAME)\n\n\nasync def send_missing_chats_error_message(update: Update) -> None:\n    await update.message.reply_text(missing_chats_error_message % BOT_NAME)\n\n\nasync def send_missing_bot_in_group_message(update: Update) -> None:\n    await update.message.reply_text(\n        missing_bot_in_group_message, parse_mode=ParseMode.HTML\n    )\n"}
{"type": "source_file", "path": "bot/convos/config_chat.py", "content": "from teleapi.endpoints import get_bot_details\nfrom telegram.ext import ConversationHandler\nfrom telegram.ext._contexttypes import ContextTypes\nfrom telegram import Update\nfrom bot.replies import replies\nfrom database import mongo\nfrom database.dbutils import dbutils\nfrom common import log, utils\nimport teleapi.endpoints as teleapi\nfrom typing import Any, Optional\n\n\nstate0, state1 = range(2)\n\n\n# state 0\nasync def choose_chat(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    db_service = mongo.MongoService(update)\n    chat_title = str(update.message.text)\n    user_id = update.message.from_user.id\n    chat_entry = dbutils.find_chat_by_title(db_service, user_id, chat_title)\n\n    if chat_entry is None:\n        await replies.send_error_message(update)\n        return state0\n\n    prev_token = chat_entry.get(\"user_bot_token\")\n    if prev_token is None:\n        context.user_data[\"chat_id\"] = chat_entry[\"chat_id\"]\n        context.user_data[\"chat_title\"] = chat_entry[\"chat_title\"]\n        await replies.send_prompt_user_bot_message(update)\n        return state1\n\n    # Revert back to default  both chat and jobs\n    has_err = reset_sender(db_service, chat_entry[\"chat_id\"], user_id, None, prev_token)\n    if has_err:\n        await replies.send_missing_bot_in_group_message(update)\n        return ConversationHandler.END\n    await replies.send_sender_reset_success_message(update)\n    return ConversationHandler.END\n\n\n# state 1\nasync def update_sender(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    new_token = str(update.message.text)\n    user_id = update.message.from_user.id\n\n    # check if bot exists\n    resp = get_bot_details(new_token)\n    if resp.status_code != 200:\n        await replies.send_error_message(update)\n        return state1\n\n    db_service = mongo.MongoService(update)\n    bot_data = {\n        **resp.json()[\"result\"],\n        \"token\": new_token,\n        \"created_by\": user_id,\n        \"updated_at\": utils.now(),\n    }\n    dbutils.upsert_new_bot(db_service, user_id, bot_data)\n\n    chat_id, chat_title = context.user_data[\"chat_id\"], context.user_data[\"chat_title\"]\n    has_err = reset_sender(db_service, chat_id, user_id, new_token, None)\n    if has_err:\n        await replies.send_missing_bot_in_group_message(update)\n        return ConversationHandler.END\n\n    await replies.send_sender_change_success_message(\n        update, chat_title, bot_data[\"username\"]\n    )\n    return ConversationHandler.END\n\n\ndef reset_sender(\n    db_service: mongo.MongoService,\n    chat_id: int,\n    user_id: int,\n    new_token: Optional[str],\n    prev_token: Optional[Any] = None,\n) -> bool:\n    # special case  single photos can only be sent from the same bot\n    single_photo_entries = dbutils.find_entries_by_content_type(db_service, chat_id)\n    for entry in single_photo_entries:\n        resp, new_photo_id = teleapi.transfer_photo_between_bots(\n            db_service, new_token, prev_token, chat_id, entry\n        )\n        if resp.status_code != 200:\n            return True\n        log.log_photo_transferred(user_id, new_photo_id, chat_id, resp.status_code)\n\n    # jobs\n    q = {\"$or\": [{\"chat_id\": chat_id}, {\"channel_id\": chat_id}]}\n    payload = {\"last_updated_by\": user_id, \"user_bot_token\": new_token}\n    db_service.update_multiple_entries(q, payload)\n\n    # chat\n    field = \"user_bot_token\"\n    payload = {\"user_bot_token\": new_token}\n    dbutils.update_chat_entry(db_service, chat_id, payload, updated_field=field)\n\n    log.log_sender_updated(user_id, prev_token, new_token, chat_id)\n    return False\n"}
{"type": "source_file", "path": "bot/actions/readonly.py", "content": "from cron_descriptor import get_description\nfrom bot.actions import permissions\nfrom telegram.ext._contexttypes import ContextTypes\nfrom telegram import Update\n\nimport config\nfrom bot.replies import replies\nfrom database import mongo\nfrom database.dbutils import dbutils\n\n\nasync def show_job_details(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    db_service = mongo.MongoService(update)\n    rights = await permissions.check_rights(update, context, db_service)\n    if not rights:\n        return\n\n    chat_id = update.message.chat.id\n    entry = dbutils.find_entry_by_jobname(db_service, chat_id, update.message.text)\n    if entry is None:\n        await replies.send_error_message(update)\n\n    bot_name = config.BOT_NAME\n    if entry.get(\"user_bot_token\") is not None:\n        bot_data = dbutils.find_bot_by_token(db_service, entry.get(\"user_bot_token\"))\n        bot_name = \"@%s\" % bot_data[\"username\"]\n\n    await replies.send_job_details(update, entry, bot_name)\n\n\nasync def decrypt_cron(update: Update, _: ContextTypes) -> None:\n    try:\n        description = get_description(update.message.text).lower()\n    except Exception:  # crontab is not valid\n        return await replies.send_checkcron_invalid_message(update)\n\n    await replies.send_checkcron_meaning_message(update, description)\n"}
{"type": "source_file", "path": "common/enums.py", "content": "from enum import Enum\n\n\nclass ContentType(Enum):\n    TEXT = \"text\"\n    PHOTO = \"single_photo\"\n    MEDIA = \"photo_group\"\n    POLL = \"poll\"\n\n\nclass Restriction(Enum):\n    OWNER = \"creator\"\n    ADMIN = \"administrator\"\n"}
{"type": "source_file", "path": "api.py", "content": "import gc\nimport psutil\nfrom http import HTTPStatus\nfrom prometheus_client import Gauge, generate_latest\nimport uvicorn\nfrom common import log, utils\nfrom common.enums import ContentType\nfrom database import mongo\nfrom database.dbutils import dbutils\nfrom datetime import datetime, timedelta, timezone\nfrom teleapi import endpoints as teleapi\nfrom threading import Thread\nfrom fastapi import FastAPI, Response\nfrom prometheus_fastapi_instrumentator import Instrumentator\nfrom typing import Any, Optional\n\nimport config\nfrom bot.ptb import lifespan\n\n\napp = FastAPI(lifespan=lifespan) if config.ENV else FastAPI()\nInstrumentator().instrument(app).expose(app)\ncpu_usage = Gauge(\"cpu_usage\", \"CPU Usage\")\nmemory_usage = Gauge(\"memory_usage\", \"Memory Usage\")\n\n\n@app.get(\"/\")\ndef home() -> str:\n    return \"Hello world!\"\n\n\n@app.get(\"/metricz\")\ndef prom_endpoint() -> Response:\n    cpu_percent = psutil.cpu_percent()\n    memory_percent = psutil.virtual_memory().percent\n\n    cpu_usage.set(cpu_percent)\n    memory_usage.set(memory_percent)\n\n    log.log_update_prometheus(\"cpu_usage\", cpu_percent)\n    log.log_update_prometheus(\"memory_usage\", memory_percent)\n\n    return Response(content=generate_latest(), media_type=\"text/plain\")\n\n\n@app.get(\"/api\")\n@app.post(\"/api\")\ndef run() -> Response:\n    db_service = mongo.MongoService()\n\n    now = datetime.now(timezone(timedelta(hours=config.TZ_OFFSET)))\n    parsed_time = utils.parse_time_mins(now)\n    entries = dbutils.find_entries_by_nextrun(db_service, parsed_time)\n\n    entry_count = len(entries)\n    log.log_entry_count(entry_count)\n\n    if entry_count < 1:\n        log.log_completion(0)\n        gc.collect()\n        return Response(status_code=HTTPStatus.OK)\n\n    for i in range(0, len(entries), config.BATCH_SIZE):\n        batch = entries[i : i + config.BATCH_SIZE]\n        batch_jobs(db_service, batch, parsed_time)\n\n    gc.collect()  # https://github.com/googleapis/google-api-python-client/issues/535\n    if config.INFLUXDB_TOKEN:\n        dbutils.save_msg_count(entry_count)\n    log.log_completion(entry_count)\n    return Response(status_code=HTTPStatus.OK)\n\n\ndef batch_jobs(db_service: mongo.MongoService, entries: list, parsed_time: str) -> None:\n    q = []\n    for entry in entries:\n        args = (\n            db_service,\n            entry,\n            parsed_time,\n        )\n        t = Thread(target=process_job, args=args, daemon=True)\n        t.start()\n        q.append(t)\n\n    for t in q:\n        t.join()\n\n\ndef process_job(\n    db_service: mongo.MongoService, entry: Optional[Any], parsed_time: str\n) -> None:\n    job_id = entry[\"_id\"]\n    channel_id = entry.get(\"channel_id\", \"\")\n    chat_id = entry.get(\"chat_id\", \"\")\n    if channel_id != \"\":\n        chat_id = channel_id\n    content = entry.get(\"content\", \"\")\n    content_type = entry.get(\"content_type\", \"\")\n    photo_id = entry.get(\"photo_id\", \"\")\n    photo_group_id = str(entry.get(\"photo_group_id\", \"\"))\n    crontab = entry.get(\"crontab\", \"\")\n    previous_message_id = str(entry.get(\"previous_message_id\", \"\"))\n    message_thread_id = entry.get(\"message_thread_id\", None)\n    errors = entry.get(\"errors\", [])\n\n    user_bot_token = entry.get(\"user_bot_token\")\n    if user_bot_token is None:\n        user_bot_token = config.TELEGRAM_BOT_TOKEN\n\n    payload = {\"pending_ts\": utils.now()}\n    dbutils.update_entry_by_jobname(db_service, entry, payload)\n\n    bot_message_id, status, err = send_message(\n        job_id,\n        chat_id,\n        content,\n        content_type,\n        photo_id,\n        photo_group_id,\n        user_bot_token,\n        message_thread_id,\n    )\n\n    if entry.get(\"option_delete_previous\", \"\") != \"\" and previous_message_id != \"\":\n        teleapi.delete_message(chat_id, previous_message_id, user_bot_token)\n\n    # calculate and update next run time\n    chat_entry = dbutils.find_chat_by_chatid(db_service, chat_id) or {}\n    user_tz_offset = chat_entry.get(\"tz_offset\", config.TZ_OFFSET)\n    user_nextrun_ts, db_nextrun_ts = utils.calc_next_run(crontab, user_tz_offset)\n    errors = [] if err is None else [*errors, {\"error\": err, \"timestamp\": parsed_time}]\n\n    payload = {\n        \"pending_ts\": None,\n        \"nextrun_ts\": db_nextrun_ts,\n        \"user_nextrun_ts\": user_nextrun_ts,\n        \"previous_message_id\": str(bot_message_id),\n        \"removed_ts\": parsed_time if len(errors) > config.RETRIES else \"\",\n        \"errors\": errors,\n    }\n    dbutils.update_entry_by_jobname(db_service, entry, payload)\n\n\ndef send_message(\n    job_id: int,\n    chat_id: int,\n    content: str,\n    content_type: str,\n    photo_id: str,\n    photo_group_id: str,\n    user_bot_token: str,\n    message_thread_id: int,\n):\n    if photo_group_id != \"\":  # media group\n        resp = teleapi.send_media_group(\n            chat_id, photo_id, content, user_bot_token, message_thread_id\n        )\n    elif photo_id != \"\":  # single photo\n        resp = teleapi.send_single_photo(\n            chat_id, photo_id, content, user_bot_token, message_thread_id\n        )\n    elif content_type == ContentType.POLL.value:\n        resp = teleapi.send_poll(chat_id, content, user_bot_token, message_thread_id)\n    else:  # text message\n        resp = teleapi.send_text(chat_id, content, user_bot_token, message_thread_id)\n\n    log.log_api_send_message(job_id, chat_id, resp.status_code)\n\n    if resp.status_code != 200:\n        err_msg = \"Error {}: {}\".format(resp.status_code, resp.json()[\"description\"])\n        return \"\", resp.status_code, err_msg\n\n    if photo_group_id != \"\":\n        msg_ids = [str(message[\"message_id\"]) for message in resp.json()[\"result\"]]\n        return \";\".join(msg_ids), resp.status_code, None\n\n    return resp.json()[\"result\"][\"message_id\"], resp.status_code, None\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"}
{"type": "source_file", "path": "bot/convos/edit.py", "content": "from telegram import Update\nfrom telegram.ext import ConversationHandler\nfrom telegram.ext._contexttypes import ContextTypes\nfrom bot.actions import actions\nfrom bot.replies import replies\nfrom common.enums import ContentType\nfrom database import mongo\nfrom database.dbutils import dbutils\nfrom common import log, utils\nimport jsons\nfrom typing import Optional\n\nstate0, state1, state2, state3, state4 = range(5)\n\nattr_cron = \"crontab\"\nattr_content = \"text content\"\nattr_add_photo = \"add photo\"\nattr_del_photo = \"remove all photos\"\nattr_del_prev = \"toggle delete previous\"\nattr_pause_job = \"pause/resume job\"\n\nattrs = [\n    attr_cron,\n    attr_content,\n    attr_add_photo,\n    attr_del_photo,\n    attr_del_prev,\n    attr_pause_job,\n]\n\n# state 0\n\n\nasync def choose_job(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    db_service = mongo.MongoService(update)\n    jobname = str(update.message.text)\n\n    if not dbutils.entry_exists(db_service, update.message.chat.id, jobname):\n        await replies.send_error_message(update)\n        return state0\n\n    context.user_data[\"jobname\"] = jobname\n    await replies.send_choose_attribute_message(update)\n    return state1\n\n\n# state 1\nasync def choose_attribute(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    attr = str(update.message.text)\n    context.user_data[\"attribute\"] = attr\n\n    if attr not in attrs:\n        await replies.send_error_message(update)\n        return state1\n\n    if attr == attr_del_prev:\n        await toggle_delete_previous(update, context)\n        return ConversationHandler.END\n\n    if attr == attr_del_photo:\n        await replies.send_reset_photos_confirmation_message(update)\n        return state4\n\n    if attr == attr_pause_job:\n        await toggle_pause_job(update, context)\n        return ConversationHandler.END\n\n    await replies.send_prompt_new_value_message(update)\n\n    if attr == attr_add_photo:\n        return state3\n\n    return state2\n\n\nasync def toggle_delete_previous(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> None:\n    jobname, chat_id = context.user_data[\"jobname\"], update.message.chat.id\n    db_service = mongo.MongoService(update)\n    entry = dbutils.find_entry_by_jobname(db_service, chat_id, jobname)\n    new_option_value = \"\" if entry.get(\"option_delete_previous\", \"\") != \"\" else True\n    payload = {\n        \"option_delete_previous\": new_option_value,\n        \"last_updated_by\": update.message.from_user.id,\n    }\n    dbutils.update_entry_by_jobid(db_service, entry[\"_id\"], payload)\n    log.log_option_updated(payload, \"option_delete_previous\", jobname, chat_id)\n    await replies.send_attribute_change_success_message(update)\n\n\nasync def toggle_pause_job(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    jobname, chat_id = context.user_data[\"jobname\"], update.message.chat.id\n    db_service = mongo.MongoService(update)\n    entry = dbutils.find_entry_by_jobname(db_service, chat_id, jobname)\n    new_option_value = \"\" if entry.get(\"paused_ts\", \"\") != \"\" else utils.now()\n    payload = {\n        \"paused_ts\": new_option_value,\n        \"last_updated_by\": update.message.from_user.id,\n    }\n    if new_option_value == \"\":  # calculate next run\n        crontab = entry.get(\"crontab\")\n        _, crontab_payload, err = await actions.prepare_crontab_update(\n            update, crontab, db_service\n        )\n        if err is not None:\n            return await replies.send_attribute_change_error_message(update)\n        payload = {\n            \"nextrun_ts\": crontab_payload[\"nextrun_ts\"],\n            \"user_nextrun_ts\": crontab_payload[\"user_nextrun_ts\"],\n            **payload,\n        }\n    dbutils.update_entry_by_jobid(db_service, entry[\"_id\"], payload)\n    log.log_option_updated(payload, \"paused_ts\", jobname, chat_id)\n    await replies.send_attribute_change_success_message(update)\n\n\n# state 2\nasync def handle_edit_content(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> int:\n    jobname, attr = context.user_data[\"jobname\"], context.user_data[\"attribute\"]\n    chat_id = update.message.chat.id\n    db_service = mongo.MongoService(update)\n\n    if attr == attr_cron:\n        crontab = update.message.text\n        _, payload, err = await actions.prepare_crontab_update(\n            update, crontab, db_service\n        )\n        if err is not None:\n            return state2\n        mongo_key = \"crontab\"\n\n    entry = dbutils.find_entry_by_jobname(db_service, chat_id, jobname)\n\n    if attr == attr_content:\n        old_content_type = entry.get(\"content_type\", \"\")\n        mongo_key = \"content\"\n        content_type = old_content_type\n        if old_content_type == ContentType.POLL.value:\n            content_type = ContentType.TEXT.value\n\n        payload = {\n            \"last_updated_by\": update.message.from_user.id,\n            \"content\": update.message.text_html,\n            \"content_type\": content_type,\n        }\n\n    dbutils.update_entry_by_jobid(db_service, entry[\"_id\"], payload)\n    log.log_option_updated(payload, mongo_key, jobname, chat_id)\n    await replies.send_attribute_change_success_message(update)\n    return ConversationHandler.END\n\n\nasync def handle_edit_poll(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    jobname, chat_id = context.user_data[\"jobname\"], update.message.chat.id\n\n    db_service = mongo.MongoService(update)\n    entry = dbutils.find_entry_by_jobname(db_service, chat_id, jobname)\n\n    poll_json = update.message.poll\n    payload = {\n        \"last_updated_by\": update.message.from_user.id,\n        \"content\": jsons.dumps(poll_json),\n        \"content_type\": ContentType.POLL.value,\n    }\n    dbutils.update_entry_by_jobid(db_service, entry[\"_id\"], payload)\n\n    log.log_option_updated(payload, \"content\", jobname, chat_id)\n    await replies.send_attribute_change_success_message(update)\n    return ConversationHandler.END\n\n\n# state 3\nasync def handle_add_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    jobname, chat_id = context.user_data[\"jobname\"], update.message.chat.id\n\n    db_service = mongo.MongoService(update)\n    entry = dbutils.find_entry_by_jobname(db_service, chat_id, jobname)\n\n    payload = {\"last_updated_by\": update.message.from_user.id}\n    if entry.get(\"photo_id\", \"\") == \"\":\n        payload[\"photo_id\"] = update.message.photo[-1].file_id\n        payload[\"content_type\"] = ContentType.PHOTO.value\n    else:  # photo group\n        payload[\"content_type\"] = ContentType.MEDIA.value\n        payload[\"photo_group_id\"] = \"-\"\n        photo_id = update.message.photo[-1].file_id\n        photo_ids = \"{};{}\".format(entry.get(\"photo_id\", \"\"), photo_id)\n        payload[\"photo_id\"] = photo_ids\n    dbutils.update_entry_by_jobid(db_service, entry[\"_id\"], payload)\n\n    log.log_option_updated(payload, \"photo_id\", jobname, chat_id)\n    await replies.send_attribute_change_success_message(update)\n    return ConversationHandler.END\n\n\n# state 4\nasync def handle_clear_photos(\n    update: Update, context: ContextTypes.DEFAULT_TYPE\n) -> Optional[int]:\n    jobname, chat_id = context.user_data[\"jobname\"], update.message.chat.id\n    res = await update.message.text.lower()\n\n    if res == \"no\":\n        return end_convo(update, context)\n\n    if res == \"yes\":\n        db_service = mongo.MongoService(update)\n        entry = dbutils.find_entry_by_jobname(db_service, chat_id, jobname)\n\n        if entry.get(\"photo_id\", \"\") == \"\":\n            await replies.send_no_photos_to_delete_error_message(update)\n            return ConversationHandler.END\n\n        payload = {\n            \"last_updated_by\": update.message.from_user.id,\n            \"content_type\": ContentType.TEXT.value,\n            \"photo_id\": \"\",\n            \"photo_group_id\": \"\",\n        }\n        dbutils.update_entry_by_jobid(db_service, entry[\"_id\"], payload)\n\n        log.log_option_updated(payload, \"photo_id\", jobname, chat_id)\n        await replies.send_attribute_change_success_message(update)\n        return ConversationHandler.END\n\n    await replies.send_error_message(update)\n\n\nasync def end_convo(update: Update, _: ContextTypes.DEFAULT_TYPE) -> int:\n    await replies.send_convo_ended_message(update)\n    return ConversationHandler.END\n"}
{"type": "source_file", "path": "bot/convos/handlers.py", "content": "from telegram.ext import filters, CommandHandler, MessageHandler, ConversationHandler\nfrom bot import commands\nfrom bot.convos import config_chat, edit\n\nconvo_text_filter = filters.TEXT & ~filters.COMMAND\n\nedit_handler = ConversationHandler(\n    entry_points=[CommandHandler(\"edit\", commands.edit_job)],\n    states={\n        edit.state0: [MessageHandler(convo_text_filter, edit.choose_job)],\n        edit.state1: [MessageHandler(convo_text_filter, edit.choose_attribute)],\n        edit.state2: [\n            MessageHandler(convo_text_filter, edit.handle_edit_content),\n            MessageHandler(filters.POLL, edit.handle_edit_poll),\n        ],\n        edit.state3: [MessageHandler(filters.PHOTO, edit.handle_add_photo)],\n        edit.state4: [MessageHandler(convo_text_filter, edit.handle_clear_photos)],\n    },\n    fallbacks=[MessageHandler(filters.COMMAND, edit.end_convo)],\n)\n\n\nconfig_chat_handler = ConversationHandler(\n    entry_points=[CommandHandler(\"changesender\", commands.change_sender)],\n    states={\n        config_chat.state0: [\n            MessageHandler(convo_text_filter, config_chat.choose_chat)\n        ],\n        config_chat.state1: [\n            MessageHandler(convo_text_filter, config_chat.update_sender)\n        ],\n    },\n    fallbacks=[MessageHandler(filters.COMMAND, edit.end_convo)],\n)\n"}
{"type": "source_file", "path": "bot/types.py", "content": "from typing import Callable, Coroutine, Any, Optional\n\nMESSAGE_HANDLER = Callable[[Any, Any], Coroutine[Any, Any, Optional[Exception]]]\n"}
{"type": "source_file", "path": "common/utils.py", "content": "import re\nimport config\nfrom croniter import croniter\nfrom datetime import datetime, timezone, timedelta\nfrom typing import Optional, Tuple, List\n\n\ndef calc_next_run(crontab: str, user_tz_offset: float) -> Tuple[str, str]:\n    user_tz = timezone(timedelta(hours=user_tz_offset))\n    user_now = datetime.now(user_tz)\n    user_iter = croniter(crontab, user_now)\n    user_nextrun_datetime = user_iter.get_next(datetime)\n    user_nextrun_ts = parse_time_mins(user_nextrun_datetime)\n\n    db_tz = timezone(timedelta(hours=config.TZ_OFFSET))\n    db_nextrun_datetime = user_nextrun_datetime.astimezone(tz=db_tz)\n    db_nextrun_ts = parse_time_mins(db_nextrun_datetime)\n\n    return (user_nextrun_ts, db_nextrun_ts)\n\n\ndef extract_tz_values(text: str) -> Optional[re.Match[str]]:\n    return re.match(\"^(?:UTC)?(([+-])(1[0-4]|0[0-9]|[0-9])(?::([0-5][0-9]))?)$\", text)\n\n\ndef extract_jobs(text: str) -> List[Tuple[str, str]]:\n    lines = text.split(\"\\n\")\n    res = []\n    for line in lines:\n        words = line.strip().split()\n        if len(words) == 0:\n            continue\n        crontab = \" \".join(words[:5])\n        content = \" \".join(words[5:])\n        res.append((crontab, content))\n    return res\n\n\ndef calc_tz(tz_values: re.Match) -> Tuple[str, float]:\n    match_groups = tz_values.groups()\n    utc_tz = str(match_groups[0])\n    sign = match_groups[1]\n    hour = int(match_groups[2])\n    mins = 0 if match_groups[3] is None else int(match_groups[3])\n\n    tz_offset = float(\"%s%.2f\" % (sign, hour + mins / 60))\n    return (utc_tz, tz_offset)\n\n\ndef parse_time_mins(datetime_obj: datetime) -> str:\n    return datetime_obj.strftime(\"%Y-%m-%d %H:%M\")\n\n\ndef parse_time_millis(datetime_obj: datetime) -> str:\n    return datetime_obj.strftime(\"%Y-%m-%d %H:%M:%S.%f\")\n\n\ndef now(offset: int = 0) -> str:\n    now_ts = datetime.now(timezone(timedelta(hours=config.TZ_OFFSET)))\n    return parse_time_millis(now_ts + timedelta(minutes=offset))\n"}
{"type": "source_file", "path": "database/dbutils/dbutils_bot.py", "content": "from database.mongo import MongoService\nfrom common import log\nfrom typing import Dict, Any, Optional\n\n\"\"\"\nGetters\n\"\"\"\n\n\ndef find_bot_by_token(db_service: MongoService, bot_token: str) -> Optional[Any]:\n    q = {\"token\": bot_token}\n    return db_service.find_one_bot(q)\n\n\n\"\"\"\nSetters\n\"\"\"\n\n\ndef upsert_new_bot(\n    db_service: MongoService, user_id: int, bot_data: Dict[str, Any]\n) -> None:\n    q = {\"id\": bot_data[\"id\"]}\n    payload = {**bot_data}\n    db_service.update_one_bot(q, payload)\n    log.log_bot_updated(user_id, bot_data)\n"}
{"type": "source_file", "path": "scripts/revive.py", "content": "from database import mongo\nfrom database.dbutils import dbutils\nfrom common import log, utils\nimport os\n\n# https://github.com/telegraf/telegraf/discussions/1833\n\nstart_ts = \"2023-10-30\"\nend_ts = \"2023-11-01\"\n\nmongo_conn = os.getenv(\"PROD_MONGODB_CONNECTION_STRING\")\ndb_service = mongo.MongoService(None, mongo_conn)\n\nentries = dbutils.find_entries_removed_between(db_service, start_ts, end_ts, 400)\n\nentry_count = len(entries)\nlog.log_update_count(entry_count)\n\nfor entry in entries:\n    chat_id = entry[\"chat_id\"]\n    crontab = entry[\"crontab\"]\n    entry_id = entry[\"_id\"]\n    chat_entry = dbutils.find_chat_by_chatid(db_service, chat_id)\n    user_tz_offset = chat_entry.get(\"tz_offset\")\n    user_nextrun_ts, db_nextrun_ts = utils.calc_next_run(crontab, user_tz_offset)\n    payload = {\n        \"nextrun_ts\": db_nextrun_ts,\n        \"user_nextrun_ts\": user_nextrun_ts,\n        \"remarks\": \"\",\n        \"removed_ts\": \"\",\n    }\n    res = dbutils.update_entry_by_jobid(\n        db_service, entry_id, payload, include_removed=True\n    )\n    log.log_entry_updated(entry)\n    log.log_update_details(res)\n"}
{"type": "source_file", "path": "config.py", "content": "from os import getenv\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n\"\"\" General config \"\"\"\n# Set ENV to any value to use webhook instead of polling for bot. Must be set in prod environment.\nENV = getenv(\"ENV\")\nTZ_OFFSET = 8.0  # (UTC+08:00)\nJOB_LIMIT_PER_PERSON = 10\nBATCH_SIZE = 100  # Max number of messages to send at any given time\nRETRIES = 1  # Number of retries if message fails to send\nBOT_NAME = \"@cron_telebot\"\n\n\"\"\" Telegram config \"\"\"\nTELEGRAM_BOT_TOKEN = getenv(\"TELEGRAM_BOT_TOKEN\")\nBOTHOST = getenv(\"BOTHOST\")  # only required in prod environment, used to set webhook\n\n\n\"\"\" DB config \"\"\"\nMONGODB_CONNECTION_STRING = getenv(\"MONGODB_CONNECTION_STRING\")\nMONGODB_DB = \"rm_bot\"\nMONGODB_JOB_DATA_COLLECTION = \"job_data\"\nMONGODB_CHAT_DATA_COLLECTION = \"chat_data\"\nMONGODB_USER_DATA_COLLECTION = \"user_data\"\nMONGODB_BOT_DATA_COLLECTION = \"bot_data\"\nMONGODB_USER_WHITELIST_COLLECTION = \"whitelist\"\n\nINFLUXDB_TOKEN = getenv(\"INFLUXDB_TOKEN\")\nINFLUXDB_ORG = \"main\"\nINFLUXDB_BUCKET = \"prod\"\nINFLUXDB_HOST = \"https://eu-central-1-1.aws.cloud2.influxdata.com\"\n"}
{"type": "source_file", "path": "database/dbutils/dbutils_user.py", "content": "from telegram import Update\n\nfrom email import utils\nfrom common import log, utils\nfrom typing import Any, Optional\n\n\nMongoService = (\n    Any  # Placeholder for the actual MongoService class due to cyclic imports\n)\n\n\n\"\"\"\nGetters\n\"\"\"\n\n\ndef retrieve_user_data(db_service: MongoService, user_id: int) -> Optional[Any]:\n    q = {\"user_id\": float(user_id), \"superseded_at\": \"\"}\n    return db_service.find_one_user(q)\n\n\n\"\"\"\nSetters\n\"\"\"\n\n\ndef add_user(\n    db_service: MongoService, user_id: int, username: str, first_name: str\n) -> None:\n    new_doc = {\n        \"user_id\": user_id,\n        \"username\": username,\n        \"first_name\": first_name,\n        \"superseded_at\": \"\",\n        \"field_changed\": \"\",\n    }\n    db_service.insert_new_user(new_doc)\n    log.log_new_user(user_id, username)\n\n\ndef supersede_user(\n    db_service: MongoService, entry: Optional[Any], field_changed: Any\n) -> None:\n    # update previous entry\n    q = {\"_id\": entry[\"_id\"]}\n    payload = {\"superseded_at\": utils.now(), \"field_changed\": field_changed}\n    db_service.update_one_user(q, payload)\n    log.log_user_updated(entry)\n\n\ndef refresh_user(db_service: MongoService, entry: Optional[Any]) -> None:\n    q = {\"_id\": entry[\"_id\"]}\n    payload = {\"last_used_at\": utils.now()}\n    db_service.update_one_user(q, payload)\n\n\ndef sync_user_data(db_service: MongoService, update: Update) -> None:\n    if update.message is None:\n        return\n    user = retrieve_user_data(db_service, update.message.from_user.id)\n\n    user_id = update.message.from_user.id\n    username = update.message.from_user.username\n    first_name = update.message.from_user.first_name\n\n    if user is None:\n        # user is new, add to db\n        return add_user(db_service, user_id, username, first_name)\n\n    # check that username hasn't changed\n    previous_username = (\n        None if user.get(\"username\", \"\") == \"\" else user.get(\"username\", \"\")\n    )  # username could be None\n    if update.message.from_user.username != previous_username:\n        supersede_user(db_service, user, \"username\")\n        add_user(db_service, user_id, username, user.get(\"first_name\", \"\"))\n        sync_user_data(db_service, update)\n        return log.log_username_updated(update)\n\n    # check that firstname hasn't changed\n    if update.message.from_user.first_name != str(user.get(\"first_name\", \"\")):\n        supersede_user(db_service, user, \"first_name\")\n        add_user(db_service, user_id, username, first_name)\n        return log.log_firstname_updated(update)\n\n    refresh_user(db_service, user)\n"}
{"type": "source_file", "path": "database/dbutils/dbutils_whitelist.py", "content": "import config\nfrom database.dbutils import dbutils\nfrom typing import Tuple\n\n\ndef get_user_limit(db_service, user_id) -> Tuple[int, int]:\n    current_job_count = dbutils.count_entries_by_userid(db_service, user_id)\n\n    q = {\"user_id\": float(user_id), \"removed_ts\": \"\"}\n    result = db_service.find_one_whitelist(q)\n\n    if result is None:\n        exceeded = current_job_count >= config.JOB_LIMIT_PER_PERSON\n        return (exceeded, config.JOB_LIMIT_PER_PERSON)\n\n    new_limit = result.get(\"new_limit\", 0)\n    return (current_job_count, new_limit)\n"}
{"type": "source_file", "path": "database/dbutils/dbutils_chat.py", "content": "from common import log, utils\nfrom database.mongo import MongoService\nfrom typing import Any, Optional\nfrom datetime import datetime\nfrom telegram import Update\n\n\"\"\"\nGetters\n\"\"\"\n\n\ndef find_chat_by_chatid(db_service: MongoService, chat_id: int) -> Optional[Any]:\n    q = {\"chat_id\": float(chat_id)}\n    return db_service.find_one_chat_entry(q)\n\n\ndef find_chat_by_title(\n    db_service: MongoService, user_id: int, chat_title: str\n) -> Optional[Any]:\n    q = {\"created_by\": user_id, \"chat_title\": chat_title}\n    return db_service.find_one_chat_entry(q)\n\n\ndef chat_exists(db_service: MongoService, chat_id: int) -> bool:\n    return find_chat_by_chatid(db_service, chat_id) is not None\n\n\ndef find_groups_created_by(db_service: MongoService, user_id: int) -> Optional[Any]:\n    q = {\n        \"created_by\": user_id,\n        \"chat_type\": {\"$nin\": [\"private\", \"channel\"]},\n    }\n    return db_service.find_chat_entries(q)\n\n\n\"\"\"\nSetters\n\"\"\"\n\n\ndef add_chat_data(\n    db_service: MongoService,\n    chat_id: int,\n    chat_title: str,\n    chat_type: str,\n    tz_offset: float,\n    utc_tz: str,\n    created_by: int,\n    telegram_ts: datetime,\n) -> None:\n    new_doc = {\n        \"chat_id\": chat_id,\n        \"chat_title\": chat_title,\n        \"chat_type\": chat_type,\n        \"tz_offset\": tz_offset,\n        \"utc_tz\": utc_tz,\n        \"created_by\": created_by,\n        \"telegram_ts\": utils.parse_time_millis(telegram_ts),\n        \"restriction\": \"\",\n        \"user_bot_token\": None,\n    }\n    db_service.insert_new_chat(new_doc)\n    log.log_new_chat(chat_id, chat_title)\n\n\ndef update_chats_tz_by_type(\n    db_service: MongoService,\n    user_id: int,\n    tz_offset: float,\n    chat_type: str,\n    utc_tz: str = \"\",\n) -> None:\n    payload = {\"tz_offset\": tz_offset, \"utc_tz\": utc_tz, \"updated_ts\": utils.now()}\n    q = {\"created_by\": user_id, \"chat_type\": chat_type}\n    mongo_response = db_service.update_chat_entries(q, payload)\n    modified_count = mongo_response.modified_count\n    log.log_chats_tz_updated_by_type(modified_count, user_id, chat_type, tz_offset)\n\n\ndef update_chat_entry(\n    db_service: MongoService,\n    chat_id: int,\n    update: Update,\n    updated_field: str = \"restriction\",\n) -> None:\n    q = {\"chat_id\": chat_id}\n    db_service.update_one_chat_entry(q, update)\n    log.log_chat_entry_updated(chat_id, updated_field, update[updated_field])\n"}
{"type": "source_file", "path": "main.py", "content": "from http import HTTPStatus\nfrom fastapi import Request, Response\nfrom telegram.ext import (\n    CommandHandler,\n    MessageHandler,\n    filters,\n    CallbackQueryHandler,\n)\nfrom telegram.ext._contexttypes import ContextTypes\nfrom telegram import Update\nimport uvicorn\nfrom bot.ptb import ptb\nfrom api import app\nfrom bot import handlers, commands\nimport config\nfrom bot.convos import handlers as convo_handlers\nfrom common.log import logger\nfrom telegram.ext import Application, ExtBot, JobQueue\nfrom typing import Dict, Any\n\n\nasync def error(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Log Errors caused by Updates.\"\"\"\n    logger.warning('Update \"%s\" caused error \"%s\"', update, context.error)\n\n\ndef add_handlers(\n    dp: Application[\n        ExtBot[None],\n        ContextTypes.DEFAULT_TYPE,\n        Dict[Any, Any],\n        Dict[Any, Any],\n        Dict[Any, Any],\n        JobQueue[ContextTypes.DEFAULT_TYPE],\n    ]\n) -> None:\n    # conversations (must be declared first, not sure why)\n    dp.add_handler(convo_handlers.edit_handler)\n    dp.add_handler(convo_handlers.config_chat_handler)\n\n    # on different commands - answer in Telegram\n    dp.add_handler(CommandHandler(\"start\", commands.start))\n    dp.add_handler(CommandHandler(\"help\", commands.help))\n    dp.add_handler(CommandHandler(\"add\", commands.add))\n    dp.add_handler(CommandHandler(\"delete\", commands.delete))\n    dp.add_handler(CommandHandler(\"list\", commands.list_jobs))\n    dp.add_handler(CommandHandler(\"checkcron\", commands.checkcron))\n    dp.add_handler(CommandHandler(\"options\", commands.list_options))\n    dp.add_handler(CommandHandler(\"adminsonly\", commands.option_restrict_to_admins))\n    dp.add_handler(CommandHandler(\"creatoronly\", commands.option_restrict_to_user))\n    dp.add_handler(CommandHandler(\"changetz\", commands.change_tz))\n    dp.add_handler(CommandHandler(\"reset\", commands.reset))\n    dp.add_handler(CommandHandler(\"addmultiple\", commands.add_multiple))\n\n    # on noncommand i.e message\n    dp.add_handler(MessageHandler(filters.TEXT, handlers.handle_messages))\n    dp.add_handler(MessageHandler(filters.PHOTO, handlers.handle_photos))\n    dp.add_handler(MessageHandler(filters.POLL, handlers.handle_polls))\n\n    # on callback\n    dp.add_handler(CallbackQueryHandler(handlers.handle_callback))\n\n    # log all errors\n    dp.add_error_handler(error)\n\n\nadd_handlers(ptb)\n\n# Use webhook when running in prod (via gunicorn)\nif config.ENV:\n\n    @app.post(\"/\")\n    async def process_update(request: Request):\n        req = await request.json()\n        update = Update.de_json(req, ptb.bot)\n        await ptb.process_update(update)\n        return Response(status_code=HTTPStatus.OK)\n\n\n# Use polling when running locally\nif __name__ == \"__main__\":\n    if not config.ENV:\n        ptb.run_polling()\n    else:\n        # Used for testing webhook locally, instructions for how to set up local webhook at https://dev.to/ibrarturi/how-to-test-webhooks-on-your-localhost-3b4f\n        uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"}
{"type": "source_file", "path": "database/dbutils/dbutils_influx.py", "content": "import config\nfrom common import log\nfrom influxdb_client_3 import InfluxDBClient3, Point\n\nclient = InfluxDBClient3(\n    host=config.INFLUXDB_HOST,\n    token=config.INFLUXDB_TOKEN,\n    org=config.INFLUXDB_ORG,\n    database=config.INFLUXDB_BUCKET,\n)\n\nmeasurement = \"raw\"\nfield = \"message_count\"\n\n\ndef save_msg_count(message_count: int) -> None:\n    point = Point(measurement).field(field, message_count)\n    client.write(record=point)\n    log.log_influx_resp(measurement, field, message_count)\n"}
{"type": "source_file", "path": "database/dbutils/dbutils.py", "content": "from database.dbutils.dbutils_chat import *\nfrom database.dbutils.dbutils_job import *\nfrom database.dbutils.dbutils_bot import *\nfrom database.dbutils.dbutils_whitelist import *\nfrom database.dbutils.dbutils_influx import *\n"}
{"type": "source_file", "path": "scripts/whitelist.py", "content": "import os\nimport sys\nimport config\nimport certifi\nfrom common import utils\nfrom pymongo import MongoClient\n\n\n\"\"\"\nConfiguration\n\"\"\"\n\n# either USERNAME or USER_ID needs to be specified\nUSER_ID = 0\nUSERNAME = \"\"\n\nNEW_LIMIT = 0\n\n# advanced options\nOVERRIDE_BLACKLIST = (\n    False  # if False, will prevent blacklisted users from being whitelisted\n)\n\nclient = MongoClient(\n    os.getenv(\"PROD_MONGODB_CONNECTION_STRING\"), tlsCAFile=certifi.where()\n)\ndb = client[config.MONGODB_DB]\n\nwhitelist_collection = db[config.MONGODB_USER_WHITELIST_COLLECTION]\nuser_collection = db[config.MONGODB_USER_DATA_COLLECTION]\nchat_data_collection = db[config.MONGODB_CHAT_DATA_COLLECTION]\njob_data_collection = db[config.MONGODB_JOB_DATA_COLLECTION]\n\n\nuser_info = None\nif USER_ID > 0:\n    user_info = user_collection.find_one({\"user_id\": USER_ID, \"superseded_at\": \"\"})\nelif USERNAME != \"\":\n    user_info = user_collection.find_one({\"username\": USERNAME, \"superseded_at\": \"\"})\n\nif user_info is None:\n    print(\"User not found\")\n    sys.exit(0)\n\nuser_id = user_info.get(\"user_id\")\nusername = user_info.get(\"username\")\nnow = utils.now()\n\nif NEW_LIMIT <= 0:\n    whitelist_collection.replace_one(\n        {\"user_id\": user_id, \"removed_ts\": \"\"},\n        {\n            \"user_id\": user_id,\n            \"username\": username,\n            \"new_limit\": NEW_LIMIT,\n            \"created_ts\": now,\n            \"removed_ts\": \"\",\n        },\n        upsert=True,\n    )\n    chat_data_collection.update_many(\n        {\"created_by\": user_id}, {\"$set\": {\"restriction\": \"\", \"updated_ts\": now}}\n    )\n    job_data_collection.update_many(\n        {\"created_by\": user_id, \"removed_ts\": \"\"},\n        {\"$set\": {\"removed_ts\": now, \"last_update_ts\": now}},\n    )\n    print(\"Successfully blacklisted user %s\" % user_id)\n    sys.exit(0)\n\nexisting_entry = whitelist_collection.find_one({\"user_id\": user_id, \"removed_ts\": \"\"})\nif (\n    existing_entry is not None\n    and existing_entry.get(\"new_limit\") <= 0\n    and not OVERRIDE_BLACKLIST\n):\n    print(\"User has been blacklisted previously, aborting whitelisting process\")\n    sys.exit(0)\n\nif NEW_LIMIT > config.JOB_LIMIT_PER_PERSON:\n    whitelist_collection.replace_one(\n        {\"user_id\": user_id, \"removed_ts\": \"\"},\n        {\n            \"user_id\": user_id,\n            \"username\": username,\n            \"new_limit\": NEW_LIMIT,\n            \"created_ts\": now,\n            \"removed_ts\": \"\",\n        },\n        upsert=True,\n    )\n    print(\"Successfully whitelisted user %s\" % user_id)\n    sys.exit(0)\n\nif NEW_LIMIT == config.JOB_LIMIT_PER_PERSON:\n    whitelist_collection.update_one(\n        {\"user_id\": user_id, \"removed_ts\": \"\"}, {\"$set\": {\"removed_ts\": now}}\n    )\n    print(\"Successfully removed whitelist for user %s\" % user_id)\n    sys.exit(0)\n\n# if NEW_LIMIT < config.JOB_LIMIT_PER_PERSON:\nprint(\"Is NEW_LIMIT set correctly?\")\nsys.exit(0)\n"}
{"type": "source_file", "path": "teleapi/endpoints.py", "content": "import json\nimport os\nimport requests\nfrom common import log\nfrom urllib.parse import urlencode\nfrom config import TELEGRAM_BOT_TOKEN\nfrom database.dbutils import dbutils\nfrom typing import Optional, Any, Dict, Tuple\nfrom database import mongo\n\n\ndef get_bot_details(user_bot_token: str) -> requests.Response:\n    endpoint = \"https://api.telegram.org/bot{}/getMe\".format(user_bot_token)\n    return requests.get(endpoint)\n\n\ndef send_media_group(\n    chat_id: int,\n    photo_id: str,\n    content: str,\n    user_bot_token: str,\n    message_thread_id: int,\n) -> requests.Response:\n    media, files = prepare_photos(photo_id, content)\n    query = {\n        \"chat_id\": chat_id,\n        \"media\": media,\n        \"reply_to_message_id\": message_thread_id,\n    }\n    query_string = urlencode(query)\n    endpoint = \"https://api.telegram.org/bot{}/sendMediaGroup?{}\".format(\n        user_bot_token, query_string\n    )\n    return requests.post(endpoint, files=files)\n\n\ndef send_single_photo(\n    chat_id: int,\n    photo_id: str,\n    content: str,\n    user_bot_token: str,\n    message_thread_id: int,\n) -> requests.Response:\n    query = {\n        \"chat_id\": chat_id,\n        \"photo\": photo_id,\n        \"caption\": content,\n        \"parse_mode\": \"html\",\n        \"reply_to_message_id\": message_thread_id,\n    }\n    query_string = urlencode(query)\n    endpoint = \"https://api.telegram.org/bot{}/sendPhoto?{}\".format(\n        user_bot_token, query_string\n    )\n    return requests.get(endpoint)\n\n\ndef send_single_photo_local(\n    new_token: Optional[str],\n    chat_id: int,\n    content: str = \"\",\n    photo: Optional[str] = None,\n    remote_photo_id: Optional[str] = None,\n    prev_token: Optional[str] = None,\n) -> requests.Response:\n    if photo is None and remote_photo_id is None:\n        raise ValueError(\"Either photo or remote_photo_id must be specified\")\n    if remote_photo_id is not None and prev_token is None:\n        prev_token = TELEGRAM_BOT_TOKEN\n    if new_token is None:\n        new_token = TELEGRAM_BOT_TOKEN\n    if remote_photo_id is not None:\n        files = download_photo({}, remote_photo_id, prev_token)\n        photo = files[remote_photo_id]\n    query_string = urlencode({\"chat_id\": chat_id, \"caption\": content})\n    endpoint = \"https://api.telegram.org/bot{}/sendPhoto?{}\".format(\n        new_token, query_string\n    )\n    return requests.post(endpoint, files={\"photo\": photo})\n\n\ndef send_poll(\n    chat_id: int, content: str, user_bot_token: str, message_thread_id: int\n) -> requests.Response:\n    poll_content = json.loads(content)\n    endpoint = \"https://api.telegram.org/bot{}/sendPoll\".format(user_bot_token)\n    parameters = {\n        \"chat_id\": chat_id,\n        \"question\": poll_content.get(\"question\"),\n        \"options\": json.dumps(\n            [option.get(\"text\") for option in poll_content.get(\"options\")]\n        ),\n        \"type\": poll_content.get(\"type\"),\n        \"is_anonymous\": poll_content.get(\"is_anonymous\"),\n        \"allows_multiple_answers\": poll_content.get(\"allows_multiple_answers\"),\n        \"correct_option_id\": poll_content.get(\"correct_option_id\"),\n        \"explanation\": poll_content.get(\"explanation\"),\n        \"explanation_parse_mode\": \"html\",\n        \"is_closed\": poll_content.get(\"is_closed\"),\n        \"close_date\": poll_content.get(\"close_date\"),\n        \"reply_to_message_id\": message_thread_id,\n    }\n    return requests.get(endpoint, data=parameters)\n\n\ndef send_text(\n    chat_id: int, content: str, user_bot_token: str, message_thread_id: int\n) -> requests.Response:\n    query = {\n        \"chat_id\": chat_id,\n        \"text\": content,\n        \"parse_mode\": \"html\",\n        \"reply_to_message_id\": message_thread_id,\n    }\n    query_string = urlencode(query)\n    endpoint = \"https://api.telegram.org/bot{}/sendMessage?{}\".format(\n        user_bot_token, query_string\n    )\n    return requests.get(endpoint)\n\n\ndef delete_message(\n    chat_id: int, previous_message_id: str, user_bot_token: Optional[str] = None\n) -> Any:\n    if user_bot_token is None:\n        user_bot_token = TELEGRAM_BOT_TOKEN\n    for message_id in str(previous_message_id).split(\";\"):\n        endpoint = \"https://api.telegram.org/bot{}/deleteMessage?chat_id={}&message_id={}\".format(\n            user_bot_token, chat_id, message_id\n        )\n        response = requests.get(endpoint)\n        log.log_api_previous_message_deletion(chat_id, message_id, response.status_code)\n    return response.json()[\"ok\"]\n\n\ndef prepare_photos(photo_id: str, content: str) -> Tuple[str, Dict[str, Any]]:\n    photo_ids = photo_id.split(\";\")\n    media, files = [], {}\n    for i, photo_id in enumerate(photo_ids):\n        files = download_photo(files, photo_id)\n        media.append(\n            {\n                \"type\": \"photo\",\n                \"media\": \"attach://%s\" % photo_id,\n                \"caption\": content if i <= 0 else \"\",\n            }\n        )\n    return json.dumps(media), files\n\n\ndef download_photo(\n    files: Dict[str, Any], photo_id: str, bot_token: Optional[str] = TELEGRAM_BOT_TOKEN\n) -> Dict[str, Any]:\n    file_details_endpoint = \"https://api.telegram.org/bot{}/getFile?file_id={}\".format(\n        bot_token, photo_id\n    )\n    file_details_response = requests.get(file_details_endpoint)\n    file_path = file_details_response.json()[\"result\"][\"file_path\"]\n    file_url = \"https://api.telegram.org/file/bot{}/{}\".format(bot_token, file_path)\n    file_response = requests.get(file_url)\n    open(photo_id, \"wb\").write(file_response.content)\n    files[photo_id] = open(photo_id, \"rb\")\n    os.remove(photo_id)\n    return files\n\n\ndef transfer_photo_between_bots(\n    db_service: mongo.MongoService,\n    new_token: Optional[str],\n    prev_token: Optional[str],\n    chat_id: int,\n    entry: Optional[Any],\n) -> Tuple[requests.Response, Optional[str]]:\n    resp = send_single_photo_local(\n        new_token=new_token,\n        chat_id=chat_id,\n        content=\"Transferring photo between bots...\",\n        remote_photo_id=entry[\"photo_id\"],\n        prev_token=prev_token,\n    )\n    new_photo_id = None\n    if resp.status_code == 200:\n        new_photo_id = resp.json()[\"result\"][\"photo\"][-1][\"file_id\"]\n        q = {\"photo_id\": new_photo_id}\n        dbutils.update_entry_by_jobid(db_service, entry[\"_id\"], q)\n        delete_message(chat_id, str(resp.json()[\"result\"][\"message_id\"]), new_token)\n    return resp, new_photo_id\n"}
{"type": "source_file", "path": "database/mongo.py", "content": "import config\nfrom common import utils\nfrom pymongo import MongoClient\nfrom database.dbutils.dbutils_user import sync_user_data\nfrom typing import Any, List, Optional\nfrom telegram import Update\n\n\nclass MongoService:\n    def __init__(\n        self,\n        update: Optional[Update] = None,\n        conn_str: Optional[str] = config.MONGODB_CONNECTION_STRING,\n    ) -> None:\n        # Provide the mongodb atlas url to connect python to mongodb using pymongo\n\n        # Create a connection using MongoClient. You can import MongoClient or use pymongo.MongoClient\n        client = MongoClient(conn_str)\n        db = client[config.MONGODB_DB]\n        self.main_collection = db[config.MONGODB_JOB_DATA_COLLECTION]\n        self.chat_data_collection = db[config.MONGODB_CHAT_DATA_COLLECTION]\n        self.user_data_collection = db[config.MONGODB_USER_DATA_COLLECTION]\n        self.bot_data_collection = db[config.MONGODB_BOT_DATA_COLLECTION]\n        self.user_whitelist_collection = db[config.MONGODB_USER_WHITELIST_COLLECTION]\n\n        if update is not None:\n            sync_user_data(self, update)\n\n    def insert_new_entry(self, q: Optional[Any]) -> None:\n        now = utils.now()\n        q[\"created_ts\"] = now\n        q[\"last_update_ts\"] = now\n        self.main_collection.insert_one(q)\n\n    def find_entries(\n        self, q: Optional[Any], sort: Optional[Any] = None\n    ) -> List[Optional[Any]]:\n        res = self.main_collection.find(q)\n        if sort is not None:\n            res = res.sort(sort)\n        return list(res)\n\n    def find_one_entry(self, q: Optional[Any]) -> Optional[Any]:\n        return self.main_collection.find_one(q)\n\n    def update_multiple_entries(\n        self, q: Optional[Any], update: Optional[Any]\n    ) -> Optional[Any]:\n        q[\"removed_ts\"] = \"\"\n        update[\"last_update_ts\"] = utils.now()\n        return self.main_collection.update_many(q, {\"$set\": update})\n\n    def update_entry(self, q: Optional[Any], update: Optional[Any]) -> Any:\n        update[\"last_update_ts\"] = utils.now()\n        return self.main_collection.update_one(q, {\"$set\": update})\n\n    def count_entries(self, q: Optional[Any]) -> int:\n        return self.main_collection.count_documents(q)\n\n    def insert_new_chat(self, q: Optional[Any]) -> None:\n        q[\"updated_ts\"] = utils.now()\n        self.chat_data_collection.insert_one(q)\n\n    def find_one_chat_entry(self, q: Optional[Any]) -> Optional[Any]:\n        return self.chat_data_collection.find_one(q)\n\n    def find_chat_entries(self, q: Optional[Any]) -> Optional[Any]:\n        return list(self.chat_data_collection.find(q))\n\n    def update_chat_entries(\n        self, q: Optional[Any], update: Optional[Any]\n    ) -> Optional[Any]:\n        update[\"updated_ts\"] = utils.now()\n        return self.chat_data_collection.update_many(q, {\"$set\": update})\n\n    def update_one_chat_entry(self, q: Optional[Any], update: Optional[Any]) -> None:\n        update[\"updated_ts\"] = utils.now()\n        self.chat_data_collection.update_one(q, {\"$set\": update})\n\n    def insert_new_user(self, q: Optional[Any]) -> Optional[Any]:\n        now = utils.now()\n        q[\"created_at\"] = now\n        q[\"last_used_at\"] = now\n        return self.user_data_collection.insert_one(q)\n\n    def find_one_user(self, q: Optional[Any]) -> Optional[Any]:\n        return self.user_data_collection.find_one(q)\n\n    def update_one_user(self, q: Optional[Any], update: Optional[Any]) -> Optional[Any]:\n        return self.user_data_collection.update_one(q, {\"$set\": update})\n\n    def update_one_bot(self, q: Optional[Any], update: Optional[Any]) -> Optional[Any]:\n        update[\"updated_at\"] = utils.now()\n        return self.bot_data_collection.update_one(q, {\"$set\": update}, upsert=True)\n\n    def find_one_bot(self, q: Optional[Any]) -> Optional[Any]:\n        return self.bot_data_collection.find_one(q)\n\n    def find_one_whitelist(self, q: Optional[Any]) -> Optional[Any]:\n        return self.user_whitelist_collection.find_one(q)\n"}
{"type": "source_file", "path": "database/dbutils/dbutils_job.py", "content": "from pymongo import ASCENDING, DESCENDING\nfrom common import utils\nfrom common.enums import ContentType\nfrom database.mongo import MongoService\nfrom common import log, utils\nfrom typing import List, Optional, Dict, Any\n\n\n\"\"\"\nGetters\n\"\"\"\n\n\ndef find_latest_entry(db_service: MongoService, chat_id: int) -> Optional[Any]:\n    q = {\"chat_id\": float(chat_id), \"removed_ts\": \"\"}\n    result = db_service.find_entries(q, [(\"created_ts\", DESCENDING)])\n    if len(result) <= 0:\n        return None\n    return result[0]\n\n\ndef find_entry_by_jobname(\n    db_service: MongoService, chat_id: int, jobname: str, include_removed: bool = False\n) -> Optional[Any]:\n    q = {\"chat_id\": float(chat_id), \"jobname\": jobname}\n    if not include_removed:\n        q[\"removed_ts\"] = \"\"\n    return db_service.find_one_entry(q)\n\n\ndef find_entries_removed_between(\n    db_service: MongoService,\n    start_ts: str,\n    end_ts: str,\n    err_status: Optional[int] = None,\n) -> List[Optional[Any]]:\n    q = {\"removed_ts\": {\"$gte\": start_ts, \"$lte\": end_ts}}\n    if err_status is not None:\n        q[\"errors.error\"] = {\"$regex\": f\"^Error {err_status}\"}\n    return db_service.find_entries(q)\n\n\ndef find_entries_by_nextrun(db_service: MongoService, ts: str) -> List[Optional[Any]]:\n    base_q = {\"nextrun_ts\": {\"$lte\": ts}, \"removed_ts\": \"\", \"crontab\": {\"$ne\": \"\"}}\n    # Only return messages that are not pending, or pending for more than 5 mins.\n    base_q[\"$or\"] = [{\"pending_ts\": None}, {\"pending_ts\": {\"$lte\": utils.now(-5)}}]\n    q = {\n        \"$or\": [\n            {\"paused_ts\": \"\", **base_q},\n            {\"paused_ts\": {\"$exists\": False}, **base_q},\n        ]\n    }\n    return db_service.find_entries(q, [(\"created_at\", ASCENDING)])\n\n\ndef find_entries_by_content_type(\n    db_service: MongoService, chat_id: int, content_type: str = ContentType.PHOTO.value\n) -> List[Optional[Any]]:\n    q = {\n        \"$or\": [{\"chat_id\": chat_id}, {\"channel_id\": chat_id}],\n        \"removed_ts\": \"\",\n        \"content_type\": content_type,\n    }\n    return db_service.find_entries(q)\n\n\ndef find_entries_by_chatid(\n    db_service: MongoService, chat_id: int\n) -> List[Optional[Any]]:\n    q = {\"chat_id\": float(chat_id), \"removed_ts\": \"\"}\n    return db_service.find_entries(q)\n\n\ndef count_entries_by_userid(db_service: MongoService, user_id: int) -> int:\n    q = {\"created_by\": user_id, \"removed_ts\": \"\"}\n    return db_service.count_entries(q)\n\n\ndef entry_exists(db_service: MongoService, chat_id: int, jobname: str) -> bool:\n    return find_entry_by_jobname(db_service, chat_id, jobname) is not None\n\n\n\"\"\"\nSetters\n\"\"\"\n\n\ndef add_new_entry(\n    db_service: MongoService,\n    chat_id: int,\n    jobname: str,  # must have jobname for /delete\n    user_id: int,\n    channel_id: str = \"\",\n    crontab: str = \"\",\n    content: str = \"\",\n    content_type: str = \"\",\n    photo_id: str = \"\",\n    photo_group_id: str = \"\",\n    nextrun_ts: str = \"\",\n    user_nextrun_ts: str = \"\",\n    pending_ts: Optional[str] = None,\n    user_bot_token: Optional[str] = None,\n    message_thread_id: Optional[int] = None,\n    errors: List[Exception] = [],\n) -> None:\n    db_service.insert_new_entry(\n        {\n            \"created_by\": user_id,\n            \"last_updated_by\": user_id,\n            \"chat_id\": chat_id,\n            \"channel_id\": channel_id,\n            \"jobname\": jobname,\n            \"crontab\": crontab,\n            \"content\": content,\n            \"content_type\": content_type,\n            \"photo_id\": photo_id,\n            \"photo_group_id\": photo_group_id,\n            \"previous_message_id\": \"\",\n            \"option_delete_previous\": \"\",\n            \"nextrun_ts\": nextrun_ts,\n            \"user_nextrun_ts\": user_nextrun_ts,\n            \"pending_ts\": pending_ts,\n            \"removed_ts\": \"\",\n            \"remarks\": \"\",\n            \"user_bot_token\": user_bot_token,\n            \"message_thread_id\": message_thread_id,\n            \"errors\": errors,\n        }\n    )\n\n    log.log_new_entry(jobname, chat_id)\n\n\ndef update_entry_by_jobname(\n    db_service: MongoService, entry: Optional[Any], update: Optional[Any]\n):\n    q = {\n        \"created_ts\": entry[\"created_ts\"],\n        \"chat_id\": entry[\"chat_id\"],\n        \"jobname\": entry[\"jobname\"],\n        \"removed_ts\": \"\",\n    }\n    return db_service.update_entry(q, update)\n\n\ndef update_entry_by_jobid(\n    db_service: MongoService,\n    entry_id: int,\n    update: Optional[Any],\n    include_removed: bool = False,\n) -> Any:\n    q: Dict[str, Any] = {\"_id\": entry_id}\n    if not include_removed:\n        q[\"removed_ts\"] = \"\"\n    return db_service.update_entry(q, update)\n\n\ndef remove_entries_by_chat(db_service: MongoService, chat_id: int) -> None:\n    q = {\"chat_id\": float(chat_id)}\n    payload = {\"removed_ts\": utils.now()}\n    db_service.update_multiple_entries(q, payload)\n"}

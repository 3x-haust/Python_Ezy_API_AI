{"repo_info": {"repo_name": "shotapi", "repo_owner": "arshad-yaseen", "repo_url": "https://github.com/arshad-yaseen/shotapi"}}
{"type": "test_file", "path": "tests/test_api.py", "content": "import requests\n\nAPI_URL = \"http://localhost:8000/take\"\n\n\ndef test_successful_screenshot_capture():\n    response = requests.get(\n        API_URL,\n        params={\"url\": \"http://example.com\", \"format\": \"base64\"},\n    )\n    assert response.status_code == 200  # nosec\n    assert isinstance(response.json(), str)  # nosec\n\n\ndef test_png_screenshot_capture():\n    response = requests.get(\n        API_URL,\n        params={\"url\": \"http://example.com\", \"format\": \"png\"},\n    )\n    assert response.status_code == 200  # nosec\n    assert response.headers[\"Content-Type\"] == \"image/png\"  # nosec\n\n\ndef check_invalid_url():\n    response = requests.get(\n        API_URL,\n        params={\"url\": \"invalid\", \"format\": \"base64\"},\n    )\n    assert response.status_code == 400  # nosec\n\n\ndef test_response_time():\n    response = requests.get(\n        API_URL,\n        params={\"url\": \"http://example.com\", \"format\": \"base64\"},\n        timeout=20,\n    )\n    assert response.elapsed.total_seconds() < 20  # nosec\n\n\ndef test_rate_limiting():\n    # The rate limit is set at 10 requests per minute\n    # Make 11 requests to test the rate limiting\n    for _ in range(11):\n        response = requests.get(\n            API_URL,\n            params={\"url\": \"http://example.com\", \"format\": \"base64\"},\n        )\n\n    # The last request should be rate limited\n    assert response.status_code == 429  # nosec\n    assert \"Rate limit exceeded\" in response.text  # nosec\n"}
{"type": "source_file", "path": "app/__init__.py", "content": "__version__ = \"0.1.0\"\n"}
{"type": "source_file", "path": "app/core/logging.py", "content": "import logging\n\n\ndef get_logger(name: str):\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.INFO)\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(\n        \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    )\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    return logger\n"}
{"type": "source_file", "path": "app/services/screenshot_taker.py", "content": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\nimport time\n\n\nasync def take_screenshot(\n    url: str,\n    width: int = None,\n    height: int = None,\n    full_page: bool = False,\n    mobile: bool = False,\n    dark_mode: bool = False,\n    delay: int = 0,\n    custom_js: str = None,\n    user_agent: str = None,\n) -> dict:\n    options = Options()\n    options.add_argument(\"--no-sandbox\")\n\n    if width and height:\n        options.add_argument(f\"--window-size={width},{height}\")\n\n    if mobile:\n        options.add_argument(\"--window-size=375,812\")  # iPhone X\n\n    if dark_mode:\n        options.add_argument(\"--force-dark-mode\")\n\n    if user_agent:\n        options.add_argument(f\"--user-agent={user_agent}\")\n\n    if full_page:\n        options.add_argument(\"--start-fullscreen\")\n\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--disable-gpu\")\n    options.add_argument(\"--disable-dev-shm-usage\")\n    options.add_argument(\"--disable-extensions\")\n    options.add_argument(\"--hide-scrollbars\")\n    options.add_argument(\"--start-maximized\")\n\n    driver = webdriver.Chrome(options=options)\n\n    try:\n        driver.get(url)\n\n        if delay > 0:\n            time.sleep(delay)\n\n        if custom_js:\n            # Execute custom JavaScript on the page\n            driver.execute_script(custom_js)\n\n        # Full-page screenshot\n        if full_page:\n            total_width = driver.execute_script(\n                \"return document.body.offsetWidth\"\n            )\n            total_height = driver.execute_script(\n                \"return document.body.parentNode.scrollHeight\"\n            )\n            driver.set_window_size(total_width, total_height)\n\n        screenshot_base64 = driver.get_screenshot_as_base64()\n        screenshot_png = driver.get_screenshot_as_png()\n\n        return {\"base64\": screenshot_base64, \"png\": screenshot_png}\n    except Exception as e:\n        raise e\n    finally:\n        if driver:\n            driver.quit()\n"}
{"type": "source_file", "path": "app/services/screenshot_service.py", "content": "from app.services.screenshot_taker import take_screenshot\nfrom fastapi import HTTPException\nimport validators\nfrom typing import Any\nfrom fastapi.responses import StreamingResponse\nfrom io import BytesIO\n\n\nasync def process_screenshot(\n    url: str,\n    format: str,\n    width: int = None,\n    height: int = None,\n    full_page: bool = False,\n    mobile: bool = False,\n    dark_mode: bool = False,\n    delay: int = 0,\n    custom_js: str = None,\n    user_agent: str = None,\n) -> Any:\n    # Validate the URL\n    validate_url(url)\n    try:\n        screenshot = await take_screenshot(\n            url,\n            width,\n            height,\n            full_page,\n            mobile,\n            dark_mode,\n            delay,\n            custom_js,\n            user_agent,\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=500, detail=f\"Error taking screenshot: {e}\"\n        )\n\n    # If the request format is base64, return the base64 encoded screenshot\n    if format == \"base64\":\n        return screenshot[\"base64\"]\n    # If the request format is png, return the png screenshot\n    elif format == \"png\":\n        return StreamingResponse(\n            BytesIO(screenshot[\"png\"]), media_type=\"image/png\"\n        )\n\n\ndef validate_url(url: str):\n    if not validators.url(url):\n        raise HTTPException(status_code=400, detail=f\"Invalid URL: {url}\")\n"}
{"type": "source_file", "path": "app/core/rate_limiter.py", "content": "from limits import RateLimitItemPerMinute\nfrom limits.strategies import MovingWindowRateLimiter\nfrom limits.storage import MemoryStorage\nfrom datetime import datetime, timedelta\nfrom app.utils.utilities import format_time_remaining\nfrom fastapi import HTTPException\n\nstorage = MemoryStorage()\nlimiter = MovingWindowRateLimiter(storage)\n\n\ndef check_rate_limit(client_ip: str, rate_per_minute: int):\n    if not limiter.hit(RateLimitItemPerMinute(rate_per_minute), client_ip):\n        reset_time = datetime.now() + timedelta(\n            minutes=1\n        )  # Assuming a 1-minute window\n        time_remaining = (reset_time - datetime.now()).total_seconds()\n        formatted_time = format_time_remaining(time_remaining)\n        detail = f\"Rate limit exceeded. Please try again in {formatted_time}.\"\n        raise HTTPException(status_code=429, detail=detail)\n"}
{"type": "source_file", "path": "app/utils/utilities.py", "content": "def format_time_remaining(seconds):\n    \"\"\"Format the remaining time in minutes and seconds.\"\"\"\n    mins, secs = divmod(seconds, 60)\n    if mins:\n        return f\"{mins} minute(s) and {secs} second(s)\"\n    else:\n        return f\"{secs} second(s)\"\n"}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import FastAPI, HTTPException, Query, Request\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.services.screenshot_service import process_screenshot\nfrom app.core.rate_limiter import check_rate_limit\n\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"GET\"],\n    allow_headers=[\"*\"],\n)\n\n\n@app.get(\"/\")\nasync def root():\n    return {\n        \"message\": \"Hello from ShotAPI!\",\n        \"documentation\": \"https://github.com/arshad-yaseen/shotapi/blob/main/README.md\",\n    }\n\n\n@app.get(\"/take\")\nasync def get_screenshot(\n    request: Request,\n    url: str = Query(..., description=\"The URL to take a screenshot of\"),\n    format: str = Query(\n        \"base64\", description=\"The format of the screenshot (base64 or png)\"\n    ),\n    width: int = Query(1280, description=\"Width of the screenshot (optional)\"),\n    height: int = Query(\n        800, description=\"Height of the screenshot (optional)\"\n    ),\n    full_page: bool = Query(\n        False, description=\"Capture full page (default: False)\"\n    ),\n    mobile: bool = Query(\n        False, description=\"Capture mobile view (default: False)\"\n    ),\n    dark_mode: bool = Query(\n        False, description=\"Enable dark mode (default: False)\"\n    ),\n    delay: int = Query(\n        0,\n        description=\"Delay in seconds before taking the screenshot (default: 0)\",\n    ),\n    custom_js: str = Query(\n        None, description=\"Custom JavaScript to execute on the page (optional)\"\n    ),\n    user_agent: str = Query(\n        None, description=\"Custom User-Agent header (optional)\"\n    ),\n):\n    client_ip = request.client.host\n    rate_per_minute = 10  # 10 requests per minute per IP\n    check_rate_limit(client_ip, rate_per_minute)\n\n    try:\n        return await process_screenshot(\n            url,\n            format,\n            width,\n            height,\n            full_page,\n            mobile,\n            dark_mode,\n            delay,\n            custom_js,\n            user_agent,\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=e.status_code if hasattr(e, \"status_code\") else 500,\n            detail=f\"Error processing screenshot: {str(e)}\",\n        )\n"}

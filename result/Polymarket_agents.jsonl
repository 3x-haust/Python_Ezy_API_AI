{"repo_info": {"repo_name": "agents", "repo_owner": "Polymarket", "repo_url": "https://github.com/Polymarket/agents"}}
{"type": "test_file", "path": "tests/test.py", "content": "\"\"\"\n% python test/test.py \n...\n----------------------------------------------------------------------\nRan 3 tests in 0.000s\n\nOK\n\"\"\"\n\nimport unittest\n\n\nclass TestStringMethods(unittest.TestCase):\n    def test_upper(self):\n        self.assertEqual(\"foo\".upper(), \"FOO\")\n\n    def test_isupper(self):\n        self.assertTrue(\"FOO\".isupper())\n        self.assertFalse(\"Foo\".isupper())\n\n    def test_split(self):\n        s = \"hello world\"\n        self.assertEqual(s.split(), [\"hello\", \"world\"])\n        # check that s.split fails when the separator is not a string\n        with self.assertRaises(TypeError):\n            s.split(2)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"}
{"type": "source_file", "path": "agents/connectors/search.py", "content": "import os\n\nfrom dotenv import load_dotenv\nfrom tavily import TavilyClient\n\nload_dotenv()\n\nopenai_api_key = os.getenv(\"OPEN_API_KEY\")\ntavily_api_key = os.getenv(\"TAVILY_API_KEY\")\n\n# Step 1. Instantiating your TavilyClient\ntavily_client = TavilyClient(api_key=tavily_api_key)\n\n# Step 2. Executing a context search query\ncontext = tavily_client.get_search_context(query=\"Will Biden drop out of the race?\")\n# Step 3. That's it! You now have a context string that you can feed directly into your RAG Application\n"}
{"type": "source_file", "path": "agents/application/cron.py", "content": "from agents.application.trade import Trader\n\nimport time\n\nfrom scheduler import Scheduler\nfrom scheduler.trigger import Monday\n\n\nclass Scheduler:\n    def __init__(self) -> None:\n        self.trader = Trader()\n        self.schedule = Scheduler()\n\n    def start(self) -> None:\n        while True:\n            self.schedule.exec_jobs()\n            time.sleep(1)\n\n\nclass TradingAgent(Scheduler):\n    def __init__(self) -> None:\n        super()\n        self.trader = Trader()\n        self.weekly(Monday(), self.trader.one_best_trade)\n"}
{"type": "source_file", "path": "agents/application/creator.py", "content": "from agents.application.executor import Executor as Agent\nfrom agents.polymarket.gamma import GammaMarketClient as Gamma\nfrom agents.polymarket.polymarket import Polymarket\n\n\nclass Creator:\n    def __init__(self):\n        self.polymarket = Polymarket()\n        self.gamma = Gamma()\n        self.agent = Agent()\n\n    def one_best_market(self):\n        \"\"\"\n\n        one_best_trade is a strategy that evaluates all events, markets, and orderbooks\n\n        leverages all available information sources accessible to the autonomous agent\n\n        then executes that trade without any human intervention\n\n        \"\"\"\n        try:\n            events = self.polymarket.get_all_tradeable_events()\n            print(f\"1. FOUND {len(events)} EVENTS\")\n\n            filtered_events = self.agent.filter_events_with_rag(events)\n            print(f\"2. FILTERED {len(filtered_events)} EVENTS\")\n\n            markets = self.agent.map_filtered_events_to_markets(filtered_events)\n            print()\n            print(f\"3. FOUND {len(markets)} MARKETS\")\n\n            print()\n            filtered_markets = self.agent.filter_markets(markets)\n            print(f\"4. FILTERED {len(filtered_markets)} MARKETS\")\n\n            best_market = self.agent.source_best_market_to_create(filtered_markets)\n            print(f\"5. IDEA FOR NEW MARKET {best_market}\")\n            return best_market\n\n        except Exception as e:\n            print(f\"Error {e} \\n \\n Retrying\")\n            self.one_best_market()\n\n    def maintain_positions(self):\n        pass\n\n    def incentive_farm(self):\n        pass\n\n\nif __name__ == \"__main__\":\n    c = Creator()\n    c.one_best_market()\n"}
{"type": "source_file", "path": "agents/connectors/chroma.py", "content": "import json\nimport os\nimport time\n\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain_community.document_loaders import JSONLoader\nfrom langchain_community.vectorstores.chroma import Chroma\n\nfrom agents.polymarket.gamma import GammaMarketClient\nfrom agents.utils.objects import SimpleEvent, SimpleMarket\n\n\nclass PolymarketRAG:\n    def __init__(self, local_db_directory=None, embedding_function=None) -> None:\n        self.gamma_client = GammaMarketClient()\n        self.local_db_directory = local_db_directory\n        self.embedding_function = embedding_function\n\n    def load_json_from_local(\n        self, json_file_path=None, vector_db_directory=\"./local_db\"\n    ) -> None:\n        loader = JSONLoader(\n            file_path=json_file_path, jq_schema=\".[].description\", text_content=False\n        )\n        loaded_docs = loader.load()\n\n        embedding_function = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        Chroma.from_documents(\n            loaded_docs, embedding_function, persist_directory=vector_db_directory\n        )\n\n    def create_local_markets_rag(self, local_directory=\"./local_db\") -> None:\n        all_markets = self.gamma_client.get_all_current_markets()\n\n        if not os.path.isdir(local_directory):\n            os.mkdir(local_directory)\n\n        local_file_path = f\"{local_directory}/all-current-markets_{time.time()}.json\"\n\n        with open(local_file_path, \"w+\") as output_file:\n            json.dump(all_markets, output_file)\n\n        self.load_json_from_local(\n            json_file_path=local_file_path, vector_db_directory=local_directory\n        )\n\n    def query_local_markets_rag(\n        self, local_directory=None, query=None\n    ) -> \"list[tuple]\":\n        embedding_function = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        local_db = Chroma(\n            persist_directory=local_directory, embedding_function=embedding_function\n        )\n        response_docs = local_db.similarity_search_with_score(query=query)\n        return response_docs\n\n    def events(self, events: \"list[SimpleEvent]\", prompt: str) -> \"list[tuple]\":\n        # create local json file\n        local_events_directory: str = \"./local_db_events\"\n        if not os.path.isdir(local_events_directory):\n            os.mkdir(local_events_directory)\n        local_file_path = f\"{local_events_directory}/events.json\"\n        dict_events = [x.dict() for x in events]\n        with open(local_file_path, \"w+\") as output_file:\n            json.dump(dict_events, output_file)\n\n        # create vector db\n        def metadata_func(record: dict, metadata: dict) -> dict:\n\n            metadata[\"id\"] = record.get(\"id\")\n            metadata[\"markets\"] = record.get(\"markets\")\n\n            return metadata\n\n        loader = JSONLoader(\n            file_path=local_file_path,\n            jq_schema=\".[]\",\n            content_key=\"description\",\n            text_content=False,\n            metadata_func=metadata_func,\n        )\n        loaded_docs = loader.load()\n        embedding_function = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        vector_db_directory = f\"{local_events_directory}/chroma\"\n        local_db = Chroma.from_documents(\n            loaded_docs, embedding_function, persist_directory=vector_db_directory\n        )\n\n        # query\n        return local_db.similarity_search_with_score(query=prompt)\n\n    def markets(self, markets: \"list[SimpleMarket]\", prompt: str) -> \"list[tuple]\":\n        # create local json file\n        local_events_directory: str = \"./local_db_markets\"\n        if not os.path.isdir(local_events_directory):\n            os.mkdir(local_events_directory)\n        local_file_path = f\"{local_events_directory}/markets.json\"\n        with open(local_file_path, \"w+\") as output_file:\n            json.dump(markets, output_file)\n\n        # create vector db\n        def metadata_func(record: dict, metadata: dict) -> dict:\n\n            metadata[\"id\"] = record.get(\"id\")\n            metadata[\"outcomes\"] = record.get(\"outcomes\")\n            metadata[\"outcome_prices\"] = record.get(\"outcome_prices\")\n            metadata[\"question\"] = record.get(\"question\")\n            metadata[\"clob_token_ids\"] = record.get(\"clob_token_ids\")\n\n            return metadata\n\n        loader = JSONLoader(\n            file_path=local_file_path,\n            jq_schema=\".[]\",\n            content_key=\"description\",\n            text_content=False,\n            metadata_func=metadata_func,\n        )\n        loaded_docs = loader.load()\n        embedding_function = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        vector_db_directory = f\"{local_events_directory}/chroma\"\n        local_db = Chroma.from_documents(\n            loaded_docs, embedding_function, persist_directory=vector_db_directory\n        )\n\n        # query\n        return local_db.similarity_search_with_score(query=prompt)\n"}
{"type": "source_file", "path": "agents/polymarket/gamma.py", "content": "import httpx\nimport json\n\nfrom agents.polymarket.polymarket import Polymarket\nfrom agents.utils.objects import Market, PolymarketEvent, ClobReward, Tag\n\n\nclass GammaMarketClient:\n    def __init__(self):\n        self.gamma_url = \"https://gamma-api.polymarket.com\"\n        self.gamma_markets_endpoint = self.gamma_url + \"/markets\"\n        self.gamma_events_endpoint = self.gamma_url + \"/events\"\n\n    def parse_pydantic_market(self, market_object: dict) -> Market:\n        try:\n            if \"clobRewards\" in market_object:\n                clob_rewards: list[ClobReward] = []\n                for clob_rewards_obj in market_object[\"clobRewards\"]:\n                    clob_rewards.append(ClobReward(**clob_rewards_obj))\n                market_object[\"clobRewards\"] = clob_rewards\n\n            if \"events\" in market_object:\n                events: list[PolymarketEvent] = []\n                for market_event_obj in market_object[\"events\"]:\n                    events.append(self.parse_nested_event(market_event_obj))\n                market_object[\"events\"] = events\n\n            # These two fields below are returned as stringified lists from the api\n            if \"outcomePrices\" in market_object:\n                market_object[\"outcomePrices\"] = json.loads(\n                    market_object[\"outcomePrices\"]\n                )\n            if \"clobTokenIds\" in market_object:\n                market_object[\"clobTokenIds\"] = json.loads(\n                    market_object[\"clobTokenIds\"]\n                )\n\n            return Market(**market_object)\n        except Exception as err:\n            print(f\"[parse_market] Caught exception: {err}\")\n            print(\"exception while handling object:\", market_object)\n\n    # Event parser for events nested under a markets api response\n    def parse_nested_event(self, event_object: dict()) -> PolymarketEvent:\n        print(\"[parse_nested_event] called with:\", event_object)\n        try:\n            if \"tags\" in event_object:\n                print(\"tags here\", event_object[\"tags\"])\n                tags: list[Tag] = []\n                for tag in event_object[\"tags\"]:\n                    tags.append(Tag(**tag))\n                event_object[\"tags\"] = tags\n\n            return PolymarketEvent(**event_object)\n        except Exception as err:\n            print(f\"[parse_event] Caught exception: {err}\")\n            print(\"\\n\", event_object)\n\n    def parse_pydantic_event(self, event_object: dict) -> PolymarketEvent:\n        try:\n            if \"tags\" in event_object:\n                print(\"tags here\", event_object[\"tags\"])\n                tags: list[Tag] = []\n                for tag in event_object[\"tags\"]:\n                    tags.append(Tag(**tag))\n                event_object[\"tags\"] = tags\n            return PolymarketEvent(**event_object)\n        except Exception as err:\n            print(f\"[parse_event] Caught exception: {err}\")\n\n    def get_markets(\n        self, querystring_params={}, parse_pydantic=False, local_file_path=None\n    ) -> \"list[Market]\":\n        if parse_pydantic and local_file_path is not None:\n            raise Exception(\n                'Cannot use \"parse_pydantic\" and \"local_file\" params simultaneously.'\n            )\n\n        response = httpx.get(self.gamma_markets_endpoint, params=querystring_params)\n        if response.status_code == 200:\n            data = response.json()\n            if local_file_path is not None:\n                with open(local_file_path, \"w+\") as out_file:\n                    json.dump(data, out_file)\n            elif not parse_pydantic:\n                return data\n            else:\n                markets: list[Market] = []\n                for market_object in data:\n                    markets.append(self.parse_pydantic_market(market_object))\n                return markets\n        else:\n            print(f\"Error response returned from api: HTTP {response.status_code}\")\n            raise Exception()\n\n    def get_events(\n        self, querystring_params={}, parse_pydantic=False, local_file_path=None\n    ) -> \"list[PolymarketEvent]\":\n        if parse_pydantic and local_file_path is not None:\n            raise Exception(\n                'Cannot use \"parse_pydantic\" and \"local_file\" params simultaneously.'\n            )\n\n        response = httpx.get(self.gamma_events_endpoint, params=querystring_params)\n        if response.status_code == 200:\n            data = response.json()\n            if local_file_path is not None:\n                with open(local_file_path, \"w+\") as out_file:\n                    json.dump(data, out_file)\n            elif not parse_pydantic:\n                return data\n            else:\n                events: list[PolymarketEvent] = []\n                for market_event_obj in data:\n                    events.append(self.parse_event(market_event_obj))\n                return events\n        else:\n            raise Exception()\n\n    def get_all_markets(self, limit=2) -> \"list[Market]\":\n        return self.get_markets(querystring_params={\"limit\": limit})\n\n    def get_all_events(self, limit=2) -> \"list[PolymarketEvent]\":\n        return self.get_events(querystring_params={\"limit\": limit})\n\n    def get_current_markets(self, limit=4) -> \"list[Market]\":\n        return self.get_markets(\n            querystring_params={\n                \"active\": True,\n                \"closed\": False,\n                \"archived\": False,\n                \"limit\": limit,\n            }\n        )\n\n    def get_all_current_markets(self, limit=100) -> \"list[Market]\":\n        offset = 0\n        all_markets = []\n        while True:\n            params = {\n                \"active\": True,\n                \"closed\": False,\n                \"archived\": False,\n                \"limit\": limit,\n                \"offset\": offset,\n            }\n            market_batch = self.get_markets(querystring_params=params)\n            all_markets.extend(market_batch)\n\n            if len(market_batch) < limit:\n                break\n            offset += limit\n\n        return all_markets\n\n    def get_current_events(self, limit=4) -> \"list[PolymarketEvent]\":\n        return self.get_events(\n            querystring_params={\n                \"active\": True,\n                \"closed\": False,\n                \"archived\": False,\n                \"limit\": limit,\n            }\n        )\n\n    def get_clob_tradable_markets(self, limit=2) -> \"list[Market]\":\n        return self.get_markets(\n            querystring_params={\n                \"active\": True,\n                \"closed\": False,\n                \"archived\": False,\n                \"limit\": limit,\n                \"enableOrderBook\": True,\n            }\n        )\n\n    def get_market(self, market_id: int) -> dict():\n        url = self.gamma_markets_endpoint + \"/\" + str(market_id)\n        print(url)\n        response = httpx.get(url)\n        return response.json()\n\n\nif __name__ == \"__main__\":\n    gamma = GammaMarketClient()\n    market = gamma.get_market(\"253123\")\n    poly = Polymarket()\n    object = poly.map_api_to_market(market)\n"}
{"type": "source_file", "path": "agents/connectors/news.py", "content": "from datetime import datetime\nimport os\n\nfrom newsapi import NewsApiClient\n\nfrom agents.utils.objects import Article\n\n\nclass News:\n    def __init__(self) -> None:\n        self.configs = {\n            \"language\": \"en\",\n            \"country\": \"us\",\n            \"top_headlines\": \"https://newsapi.org/v2/top-headlines?country=us&apiKey=\",\n            \"base_url\": \"https://newsapi.org/v2/\",\n        }\n\n        self.categories = {\n            \"business\",\n            \"entertainment\",\n            \"general\",\n            \"health\",\n            \"science\",\n            \"sports\",\n            \"technology\",\n        }\n\n        self.API = NewsApiClient(os.getenv(\"NEWSAPI_API_KEY\"))\n\n    def get_articles_for_cli_keywords(self, keywords) -> \"list[Article]\":\n        query_words = keywords.split(\",\")\n        all_articles = self.get_articles_for_options(query_words)\n        article_objects: list[Article] = []\n        for _, articles in all_articles.items():\n            for article in articles:\n                article_objects.append(Article(**article))\n        return article_objects\n\n    def get_top_articles_for_market(self, market_object: dict) -> \"list[Article]\":\n        return self.API.get_top_headlines(\n            language=\"en\", country=\"usa\", q=market_object[\"description\"]\n        )\n\n    def get_articles_for_options(\n        self,\n        market_options: \"list[str]\",\n        date_start: datetime = None,\n        date_end: datetime = None,\n    ) -> \"list[Article]\":\n\n        all_articles = {}\n        # Default to top articles if no start and end dates are given for search\n        if not date_start and not date_end:\n            for option in market_options:\n                response_dict = self.API.get_top_headlines(\n                    q=option.strip(),\n                    language=self.configs[\"language\"],\n                    country=self.configs[\"country\"],\n                )\n                articles = response_dict[\"articles\"]\n                all_articles[option] = articles\n        else:\n            for option in market_options:\n                response_dict = self.API.get_everything(\n                    q=option.strip(),\n                    language=self.configs[\"language\"],\n                    country=self.configs[\"country\"],\n                    from_param=date_start,\n                    to=date_end,\n                )\n                articles = response_dict[\"articles\"]\n                all_articles[option] = articles\n\n        return all_articles\n\n    def get_category(self, market_object: dict) -> str:\n        news_category = \"general\"\n        market_category = market_object[\"category\"]\n        if market_category in self.categories:\n            news_category = market_category\n        return news_category\n"}
{"type": "source_file", "path": "agents/polymarket/polymarket.py", "content": "# core polymarket api\n# https://github.com/Polymarket/py-clob-client/tree/main/examples\n\nimport os\nimport pdb\nimport time\nimport ast\nimport requests\n\nfrom dotenv import load_dotenv\n\nfrom web3 import Web3\nfrom web3.constants import MAX_INT\nfrom web3.middleware import geth_poa_middleware\n\nimport httpx\nfrom py_clob_client.client import ClobClient\nfrom py_clob_client.clob_types import ApiCreds\nfrom py_clob_client.constants import AMOY, POLYGON\nfrom py_order_utils.builders import OrderBuilder\nfrom py_order_utils.model import OrderData\nfrom py_order_utils.signer import Signer\nfrom py_clob_client.clob_types import (\n    OrderArgs,\n    MarketOrderArgs,\n    OrderType,\n    OrderBookSummary,\n)\nfrom py_clob_client.order_builder.constants import BUY\n\nfrom agents.utils.objects import SimpleMarket, SimpleEvent\n\nload_dotenv()\n\n\nclass Polymarket:\n    def __init__(self) -> None:\n        self.gamma_url = \"https://gamma-api.polymarket.com\"\n        self.gamma_markets_endpoint = self.gamma_url + \"/markets\"\n        self.gamma_events_endpoint = self.gamma_url + \"/events\"\n\n        self.clob_url = \"https://clob.polymarket.com\"\n        self.clob_auth_endpoint = self.clob_url + \"/auth/api-key\"\n\n        self.chain_id = 137  # POLYGON\n        self.private_key = os.getenv(\"POLYGON_WALLET_PRIVATE_KEY\")\n        self.polygon_rpc = \"https://polygon-rpc.com\"\n        self.w3 = Web3(Web3.HTTPProvider(self.polygon_rpc))\n\n        self.exchange_address = \"0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e\"\n        self.neg_risk_exchange_address = \"0xC5d563A36AE78145C45a50134d48A1215220f80a\"\n\n        self.erc20_approve = \"\"\"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRescuer\",\"type\":\"address\"}],\"name\":\"RescuerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APPROVE_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLACKLISTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CANCEL_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSITOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"META_TRANSACTION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESCUER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAW_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"approveWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"authorizationState\",\"outputs\":[{\"internalType\":\"enum GasAbstraction.AuthorizationState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blacklisters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decrement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"decreaseAllowanceWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"depositData\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"increment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"increaseAllowanceWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"newDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"childChainManager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescuers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"transferWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"updateMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdrawWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]\"\"\"\n        self.erc1155_set_approval = \"\"\"[{\"inputs\": [{ \"internalType\": \"address\", \"name\": \"operator\", \"type\": \"address\" },{ \"internalType\": \"bool\", \"name\": \"approved\", \"type\": \"bool\" }],\"name\": \"setApprovalForAll\",\"outputs\": [],\"stateMutability\": \"nonpayable\",\"type\": \"function\"}]\"\"\"\n\n        self.usdc_address = \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\"\n        self.ctf_address = \"0x4D97DCd97eC945f40cF65F87097ACe5EA0476045\"\n\n        self.web3 = Web3(Web3.HTTPProvider(self.polygon_rpc))\n        self.web3.middleware_onion.inject(geth_poa_middleware, layer=0)\n\n        self.usdc = self.web3.eth.contract(\n            address=self.usdc_address, abi=self.erc20_approve\n        )\n        self.ctf = self.web3.eth.contract(\n            address=self.ctf_address, abi=self.erc1155_set_approval\n        )\n\n        self._init_api_keys()\n        self._init_approvals(False)\n\n    def _init_api_keys(self) -> None:\n        self.client = ClobClient(\n            self.clob_url, key=self.private_key, chain_id=self.chain_id\n        )\n        self.credentials = self.client.create_or_derive_api_creds()\n        self.client.set_api_creds(self.credentials)\n        # print(self.credentials)\n\n    def _init_approvals(self, run: bool = False) -> None:\n        if not run:\n            return\n\n        priv_key = self.private_key\n        pub_key = self.get_address_for_private_key()\n        chain_id = self.chain_id\n        web3 = self.web3\n        nonce = web3.eth.get_transaction_count(pub_key)\n        usdc = self.usdc\n        ctf = self.ctf\n\n        # CTF Exchange\n        raw_usdc_approve_txn = usdc.functions.approve(\n            \"0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E\", int(MAX_INT, 0)\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_usdc_approve_tx = web3.eth.account.sign_transaction(\n            raw_usdc_approve_txn, private_key=priv_key\n        )\n        send_usdc_approve_tx = web3.eth.send_raw_transaction(\n            signed_usdc_approve_tx.raw_transaction\n        )\n        usdc_approve_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_usdc_approve_tx, 600\n        )\n        print(usdc_approve_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        raw_ctf_approval_txn = ctf.functions.setApprovalForAll(\n            \"0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E\", True\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_ctf_approval_tx = web3.eth.account.sign_transaction(\n            raw_ctf_approval_txn, private_key=priv_key\n        )\n        send_ctf_approval_tx = web3.eth.send_raw_transaction(\n            signed_ctf_approval_tx.raw_transaction\n        )\n        ctf_approval_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_ctf_approval_tx, 600\n        )\n        print(ctf_approval_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        # Neg Risk CTF Exchange\n        raw_usdc_approve_txn = usdc.functions.approve(\n            \"0xC5d563A36AE78145C45a50134d48A1215220f80a\", int(MAX_INT, 0)\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_usdc_approve_tx = web3.eth.account.sign_transaction(\n            raw_usdc_approve_txn, private_key=priv_key\n        )\n        send_usdc_approve_tx = web3.eth.send_raw_transaction(\n            signed_usdc_approve_tx.raw_transaction\n        )\n        usdc_approve_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_usdc_approve_tx, 600\n        )\n        print(usdc_approve_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        raw_ctf_approval_txn = ctf.functions.setApprovalForAll(\n            \"0xC5d563A36AE78145C45a50134d48A1215220f80a\", True\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_ctf_approval_tx = web3.eth.account.sign_transaction(\n            raw_ctf_approval_txn, private_key=priv_key\n        )\n        send_ctf_approval_tx = web3.eth.send_raw_transaction(\n            signed_ctf_approval_tx.raw_transaction\n        )\n        ctf_approval_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_ctf_approval_tx, 600\n        )\n        print(ctf_approval_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        # Neg Risk Adapter\n        raw_usdc_approve_txn = usdc.functions.approve(\n            \"0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296\", int(MAX_INT, 0)\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_usdc_approve_tx = web3.eth.account.sign_transaction(\n            raw_usdc_approve_txn, private_key=priv_key\n        )\n        send_usdc_approve_tx = web3.eth.send_raw_transaction(\n            signed_usdc_approve_tx.raw_transaction\n        )\n        usdc_approve_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_usdc_approve_tx, 600\n        )\n        print(usdc_approve_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        raw_ctf_approval_txn = ctf.functions.setApprovalForAll(\n            \"0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296\", True\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_ctf_approval_tx = web3.eth.account.sign_transaction(\n            raw_ctf_approval_txn, private_key=priv_key\n        )\n        send_ctf_approval_tx = web3.eth.send_raw_transaction(\n            signed_ctf_approval_tx.raw_transaction\n        )\n        ctf_approval_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_ctf_approval_tx, 600\n        )\n        print(ctf_approval_tx_receipt)\n\n    def get_all_markets(self) -> \"list[SimpleMarket]\":\n        markets = []\n        res = httpx.get(self.gamma_markets_endpoint)\n        if res.status_code == 200:\n            for market in res.json():\n                try:\n                    market_data = self.map_api_to_market(market)\n                    markets.append(SimpleMarket(**market_data))\n                except Exception as e:\n                    print(e)\n                    pass\n        return markets\n\n    def filter_markets_for_trading(self, markets: \"list[SimpleMarket]\"):\n        tradeable_markets = []\n        for market in markets:\n            if market.active:\n                tradeable_markets.append(market)\n        return tradeable_markets\n\n    def get_market(self, token_id: str) -> SimpleMarket:\n        params = {\"clob_token_ids\": token_id}\n        res = httpx.get(self.gamma_markets_endpoint, params=params)\n        if res.status_code == 200:\n            data = res.json()\n            market = data[0]\n            return self.map_api_to_market(market, token_id)\n\n    def map_api_to_market(self, market, token_id: str = \"\") -> SimpleMarket:\n        market = {\n            \"id\": int(market[\"id\"]),\n            \"question\": market[\"question\"],\n            \"end\": market[\"endDate\"],\n            \"description\": market[\"description\"],\n            \"active\": market[\"active\"],\n            # \"deployed\": market[\"deployed\"],\n            \"funded\": market[\"funded\"],\n            \"rewardsMinSize\": float(market[\"rewardsMinSize\"]),\n            \"rewardsMaxSpread\": float(market[\"rewardsMaxSpread\"]),\n            # \"volume\": float(market[\"volume\"]),\n            \"spread\": float(market[\"spread\"]),\n            \"outcomes\": str(market[\"outcomes\"]),\n            \"outcome_prices\": str(market[\"outcomePrices\"]),\n            \"clob_token_ids\": str(market[\"clobTokenIds\"]),\n        }\n        if token_id:\n            market[\"clob_token_ids\"] = token_id\n        return market\n\n    def get_all_events(self) -> \"list[SimpleEvent]\":\n        events = []\n        res = httpx.get(self.gamma_events_endpoint)\n        if res.status_code == 200:\n            print(len(res.json()))\n            for event in res.json():\n                try:\n                    print(1)\n                    event_data = self.map_api_to_event(event)\n                    events.append(SimpleEvent(**event_data))\n                except Exception as e:\n                    print(e)\n                    pass\n        return events\n\n    def map_api_to_event(self, event) -> SimpleEvent:\n        description = event[\"description\"] if \"description\" in event.keys() else \"\"\n        return {\n            \"id\": int(event[\"id\"]),\n            \"ticker\": event[\"ticker\"],\n            \"slug\": event[\"slug\"],\n            \"title\": event[\"title\"],\n            \"description\": description,\n            \"active\": event[\"active\"],\n            \"closed\": event[\"closed\"],\n            \"archived\": event[\"archived\"],\n            \"new\": event[\"new\"],\n            \"featured\": event[\"featured\"],\n            \"restricted\": event[\"restricted\"],\n            \"end\": event[\"endDate\"],\n            \"markets\": \",\".join([x[\"id\"] for x in event[\"markets\"]]),\n        }\n\n    def filter_events_for_trading(\n        self, events: \"list[SimpleEvent]\"\n    ) -> \"list[SimpleEvent]\":\n        tradeable_events = []\n        for event in events:\n            if (\n                event.active\n                and not event.restricted\n                and not event.archived\n                and not event.closed\n            ):\n                tradeable_events.append(event)\n        return tradeable_events\n\n    def get_all_tradeable_events(self) -> \"list[SimpleEvent]\":\n        all_events = self.get_all_events()\n        return self.filter_events_for_trading(all_events)\n\n    def get_sampling_simplified_markets(self) -> \"list[SimpleEvent]\":\n        markets = []\n        raw_sampling_simplified_markets = self.client.get_sampling_simplified_markets()\n        for raw_market in raw_sampling_simplified_markets[\"data\"]:\n            token_one_id = raw_market[\"tokens\"][0][\"token_id\"]\n            market = self.get_market(token_one_id)\n            markets.append(market)\n        return markets\n\n    def get_orderbook(self, token_id: str) -> OrderBookSummary:\n        return self.client.get_order_book(token_id)\n\n    def get_orderbook_price(self, token_id: str) -> float:\n        return float(self.client.get_price(token_id))\n\n    def get_address_for_private_key(self):\n        account = self.w3.eth.account.from_key(str(self.private_key))\n        return account.address\n\n    def build_order(\n        self,\n        market_token: str,\n        amount: float,\n        nonce: str = str(round(time.time())),  # for cancellations\n        side: str = \"BUY\",\n        expiration: str = \"0\",  # timestamp after which order expires\n    ):\n        signer = Signer(self.private_key)\n        builder = OrderBuilder(self.exchange_address, self.chain_id, signer)\n\n        buy = side == \"BUY\"\n        side = 0 if buy else 1\n        maker_amount = amount if buy else 0\n        taker_amount = amount if not buy else 0\n        order_data = OrderData(\n            maker=self.get_address_for_private_key(),\n            tokenId=market_token,\n            makerAmount=maker_amount,\n            takerAmount=taker_amount,\n            feeRateBps=\"1\",\n            nonce=nonce,\n            side=side,\n            expiration=expiration,\n        )\n        order = builder.build_signed_order(order_data)\n        return order\n\n    def execute_order(self, price, size, side, token_id) -> str:\n        return self.client.create_and_post_order(\n            OrderArgs(price=price, size=size, side=side, token_id=token_id)\n        )\n\n    def execute_market_order(self, market, amount) -> str:\n        token_id = ast.literal_eval(market[0].dict()[\"metadata\"][\"clob_token_ids\"])[1]\n        order_args = MarketOrderArgs(\n            token_id=token_id,\n            amount=amount,\n        )\n        signed_order = self.client.create_market_order(order_args)\n        print(\"Execute market order... signed_order \", signed_order)\n        resp = self.client.post_order(signed_order, orderType=OrderType.FOK)\n        print(resp)\n        print(\"Done!\")\n        return resp\n\n    def get_usdc_balance(self) -> float:\n        balance_res = self.usdc.functions.balanceOf(\n            self.get_address_for_private_key()\n        ).call()\n        return float(balance_res / 10e5)\n\n\ndef test():\n    host = \"https://clob.polymarket.com\"\n    key = os.getenv(\"POLYGON_WALLET_PRIVATE_KEY\")\n    print(key)\n    chain_id = POLYGON\n\n    # Create CLOB client and get/set API credentials\n    client = ClobClient(host, key=key, chain_id=chain_id)\n    client.set_api_creds(client.create_or_derive_api_creds())\n\n    creds = ApiCreds(\n        api_key=os.getenv(\"CLOB_API_KEY\"),\n        api_secret=os.getenv(\"CLOB_SECRET\"),\n        api_passphrase=os.getenv(\"CLOB_PASS_PHRASE\"),\n    )\n    chain_id = AMOY\n    client = ClobClient(host, key=key, chain_id=chain_id, creds=creds)\n\n    print(client.get_markets())\n    print(client.get_simplified_markets())\n    print(client.get_sampling_markets())\n    print(client.get_sampling_simplified_markets())\n    print(client.get_market(\"condition_id\"))\n\n    print(\"Done!\")\n\n\ndef gamma():\n    url = \"https://gamma-com\"\n    markets_url = url + \"/markets\"\n    res = httpx.get(markets_url)\n    code = res.status_code\n    if code == 200:\n        markets: list[SimpleMarket] = []\n        data = res.json()\n        for market in data:\n            try:\n                market_data = {\n                    \"id\": int(market[\"id\"]),\n                    \"question\": market[\"question\"],\n                    # \"start\": market['startDate'],\n                    \"end\": market[\"endDate\"],\n                    \"description\": market[\"description\"],\n                    \"active\": market[\"active\"],\n                    \"deployed\": market[\"deployed\"],\n                    \"funded\": market[\"funded\"],\n                    # \"orderMinSize\": float(market['orderMinSize']) if market['orderMinSize'] else 0,\n                    # \"orderPriceMinTickSize\": float(market['orderPriceMinTickSize']),\n                    \"rewardsMinSize\": float(market[\"rewardsMinSize\"]),\n                    \"rewardsMaxSpread\": float(market[\"rewardsMaxSpread\"]),\n                    \"volume\": float(market[\"volume\"]),\n                    \"spread\": float(market[\"spread\"]),\n                    \"outcome_a\": str(market[\"outcomes\"][0]),\n                    \"outcome_b\": str(market[\"outcomes\"][1]),\n                    \"outcome_a_price\": str(market[\"outcomePrices\"][0]),\n                    \"outcome_b_price\": str(market[\"outcomePrices\"][1]),\n                }\n                markets.append(SimpleMarket(**market_data))\n            except Exception as err:\n                print(f\"error {err} for market {id}\")\n        pdb.set_trace()\n    else:\n        raise Exception()\n\n\ndef main():\n    # auth()\n    # test()\n    # gamma()\n    print(Polymarket().get_all_events())\n\n\nif __name__ == \"__main__\":\n    load_dotenv()\n\n    p = Polymarket()\n\n    # k = p.get_api_key()\n    # m = p.get_sampling_simplified_markets()\n\n    # print(m)\n    # m = p.get_market('11015470973684177829729219287262166995141465048508201953575582100565462316088')\n\n    # t = m[0]['token_id']\n    # o = p.get_orderbook(t)\n    # pdb.set_trace()\n\n    \"\"\"\n    \n    (Pdb) pprint(o)\n            OrderBookSummary(\n                market='0x26ee82bee2493a302d21283cb578f7e2fff2dd15743854f53034d12420863b55', \n                asset_id='11015470973684177829729219287262166995141465048508201953575582100565462316088', \n                bids=[OrderSummary(price='0.01', size='600005'), OrderSummary(price='0.02', size='200000'), ...\n                asks=[OrderSummary(price='0.99', size='100000'), OrderSummary(price='0.98', size='200000'), ...\n            )\n    \n    \"\"\"\n\n    # https://polygon-rpc.com\n\n    test_market_token_id = (\n        \"101669189743438912873361127612589311253202068943959811456820079057046819967115\"\n    )\n    test_market_data = p.get_market(test_market_token_id)\n\n    # test_size = 0.0001\n    test_size = 1\n    test_side = BUY\n    test_price = float(ast.literal_eval(test_market_data[\"outcome_prices\"])[0])\n\n    # order = p.execute_order(\n    #    test_price,\n    #    test_size,\n    #    test_side,\n    #    test_market_token_id,\n    # )\n\n    # order = p.execute_market_order(test_price, test_market_token_id)\n\n    balance = p.get_usdc_balance()\n"}
{"type": "source_file", "path": "agents/application/prompts.py", "content": "from typing import List\nfrom datetime import datetime\n\n\nclass Prompter:\n\n    def generate_simple_ai_trader(market_description: str, relevant_info: str) -> str:\n        return f\"\"\"\n            \n        You are a trader.\n        \n        Here is a market description: {market_description}.\n\n        Here is relevant information: {relevant_info}.\n\n        Do you buy or sell? How much?\n        \"\"\"\n\n    def market_analyst(self) -> str:\n        return f\"\"\"\n        You are a market analyst that takes a description of an event and produces a market forecast. \n        Assign a probability estimate to the event occurring described by the user\n        \"\"\"\n\n    def sentiment_analyzer(self, question: str, outcome: str) -> float:\n        return f\"\"\"\n        You are a political scientist trained in media analysis. \n        You are given a question: {question}.\n        and an outcome of yes or no: {outcome}.\n        \n        You are able to review a news article or text and\n        assign a sentiment score between 0 and 1. \n        \n        \"\"\"\n\n    def prompts_polymarket(\n        self, data1: str, data2: str, market_question: str, outcome: str\n    ) -> str:\n        current_market_data = str(data1)\n        current_event_data = str(data2)\n        return f\"\"\"\n        You are an AI assistant for users of a prediction market called Polymarket.\n        Users want to place bets based on their beliefs of market outcomes such as political or sports events.\n        \n        Here is data for current Polymarket markets {current_market_data} and \n        current Polymarket events {current_event_data}.\n\n        Help users identify markets to trade based on their interests or queries.\n        Provide specific information for markets including probabilities of outcomes.\n        Give your response in the following format:\n\n        I believe {market_question} has a likelihood {float} for outcome of {outcome}.\n        \"\"\"\n\n    def prompts_polymarket(self, data1: str, data2: str) -> str:\n        current_market_data = str(data1)\n        current_event_data = str(data2)\n        return f\"\"\"\n        You are an AI assistant for users of a prediction market called Polymarket.\n        Users want to place bets based on their beliefs of market outcomes such as political or sports events.\n\n        Here is data for current Polymarket markets {current_market_data} and \n        current Polymarket events {current_event_data}.\n        Help users identify markets to trade based on their interests or queries.\n        Provide specific information for markets including probabilities of outcomes.\n        \"\"\"\n\n    def routing(self, system_message: str) -> str:\n        return f\"\"\"You are an expert at routing a user question to the appropriate data source. System message: ${system_message}\"\"\"\n\n    def multiquery(self, question: str) -> str:\n        return f\"\"\"\n        You're an AI assistant. Your task is to generate five different versions\n        of the given user question to retreive relevant documents from a vector database. By generating\n        multiple perspectives on the user question, your goal is to help the user overcome some of the limitations\n        of the distance-based similarity search.\n        Provide these alternative questions separated by newlines. Original question: {question}\n\n        \"\"\"\n\n    def read_polymarket(self) -> str:\n        return f\"\"\"\n        You are an prediction market analyst.\n        \"\"\"\n\n    def polymarket_analyst_api(self) -> str:\n        return f\"\"\"You are an AI assistant for analyzing prediction markets.\n                You will be provided with json output for api data from Polymarket.\n                Polymarket is an online prediction market that lets users Bet on the outcome of future events in a wide range of topics, like sports, politics, and pop culture. \n                Get accurate real-time probabilities of the events that matter most to you. \"\"\"\n\n    def filter_events(self) -> str:\n        return (\n            self.polymarket_analyst_api()\n            + f\"\"\"\n        \n        Filter these events for the ones you will be best at trading on profitably.\n\n        \"\"\"\n        )\n\n    def filter_markets(self) -> str:\n        return (\n            self.polymarket_analyst_api()\n            + f\"\"\"\n        \n        Filter these markets for the ones you will be best at trading on profitably.\n\n        \"\"\"\n        )\n\n    def superforecaster(self, question: str, description: str, outcome: str) -> str:\n        return f\"\"\"\n        You are a Superforecaster tasked with correctly predicting the likelihood of events.\n        Use the following systematic process to develop an accurate prediction for the following\n        question=`{question}` and description=`{description}` combination. \n        \n        Here are the key steps to use in your analysis:\n\n        1. Breaking Down the Question:\n            - Decompose the question into smaller, more manageable parts.\n            - Identify the key components that need to be addressed to answer the question.\n        2. Gathering Information:\n            - Seek out diverse sources of information.\n            - Look for both quantitative data and qualitative insights.\n            - Stay updated on relevant news and expert analyses.\n        3. Considere Base Rates:\n            - Use statistical baselines or historical averages as a starting point.\n            - Compare the current situation to similar past events to establish a benchmark probability.\n        4. Identify and Evaluate Factors:\n            - List factors that could influence the outcome.\n            - Assess the impact of each factor, considering both positive and negative influences.\n            - Use evidence to weigh these factors, avoiding over-reliance on any single piece of information.\n        5. Think Probabilistically:\n            - Express predictions in terms of probabilities rather than certainties.\n            - Assign likelihoods to different outcomes and avoid binary thinking.\n            - Embrace uncertainty and recognize that all forecasts are probabilistic in nature.\n        \n        Given these steps produce a statement on the probability of outcome=`{outcome}` occuring.\n\n        Give your response in the following format:\n\n        I believe {question} has a likelihood `{float}` for outcome of `{str}`.\n        \"\"\"\n\n    def one_best_trade(\n        self,\n        prediction: str,\n        outcomes: List[str],\n        outcome_prices: str,\n    ) -> str:\n        return (\n            self.polymarket_analyst_api()\n            + f\"\"\"\n        \n                Imagine yourself as the top trader on Polymarket, dominating the world of information markets with your keen insights and strategic acumen. You have an extraordinary ability to analyze and interpret data from diverse sources, turning complex information into profitable trading opportunities.\n                You excel in predicting the outcomes of global events, from political elections to economic developments, using a combination of data analysis and intuition. Your deep understanding of probability and statistics allows you to assess market sentiment and make informed decisions quickly.\n                Every day, you approach Polymarket with a disciplined strategy, identifying undervalued opportunities and managing your portfolio with precision. You are adept at evaluating the credibility of information and filtering out noise, ensuring that your trades are based on reliable data.\n                Your adaptability is your greatest asset, enabling you to thrive in a rapidly changing environment. You leverage cutting-edge technology and tools to gain an edge over other traders, constantly seeking innovative ways to enhance your strategies.\n                In your journey on Polymarket, you are committed to continuous learning, staying informed about the latest trends and developments in various sectors. Your emotional intelligence empowers you to remain composed under pressure, making rational decisions even when the stakes are high.\n                Visualize yourself consistently achieving outstanding returns, earning recognition as the top trader on Polymarket. You inspire others with your success, setting new standards of excellence in the world of information markets.\n\n        \"\"\"\n            + f\"\"\"\n        \n        You made the following prediction for a market: {prediction}\n\n        The current outcomes ${outcomes} prices are: ${outcome_prices}\n\n        Given your prediction, respond with a genius trade in the format:\n        `\n            price:'price_on_the_orderbook',\n            size:'percentage_of_total_funds',\n            side: BUY or SELL,\n        `\n\n        Your trade should approximate price using the likelihood in your prediction.\n\n        Example response:\n\n        RESPONSE```\n            price:0.5,\n            size:0.1,\n            side:BUY,\n        ```\n        \n        \"\"\"\n        )\n\n    def format_price_from_one_best_trade_output(self, output: str) -> str:\n        return f\"\"\"\n        \n        You will be given an input such as:\n    \n        `\n            price:0.5,\n            size:0.1,\n            side:BUY,\n        `\n\n        Please extract only the value associated with price.\n        In this case, you would return \"0.5\".\n\n        Only return the number after price:\n        \n        \"\"\"\n\n    def format_size_from_one_best_trade_output(self, output: str) -> str:\n        return f\"\"\"\n        \n        You will be given an input such as:\n    \n        `\n            price:0.5,\n            size:0.1,\n            side:BUY,\n        `\n\n        Please extract only the value associated with price.\n        In this case, you would return \"0.1\".\n\n        Only return the number after size:\n        \n        \"\"\"\n\n    def create_new_market(self, filtered_markets: str) -> str:\n        return f\"\"\"\n        {filtered_markets}\n        \n        Invent an information market similar to these markets that ends in the future,\n        at least 6 months after today, which is: {datetime.today().strftime('%Y-%m-%d')},\n        so this date plus 6 months at least.\n\n        Output your format in:\n        \n        Question: \"...\"?\n        Outcomes: A or B\n\n        With ... filled in and A or B options being the potential results.\n        For example:\n\n        Question: \"Will Kamala win\"\n        Outcomes: Yes or No\n        \n        \"\"\"\n"}
{"type": "source_file", "path": "agents/application/trade.py", "content": "from agents.application.executor import Executor as Agent\nfrom agents.polymarket.gamma import GammaMarketClient as Gamma\nfrom agents.polymarket.polymarket import Polymarket\n\nimport shutil\n\n\nclass Trader:\n    def __init__(self):\n        self.polymarket = Polymarket()\n        self.gamma = Gamma()\n        self.agent = Agent()\n\n    def pre_trade_logic(self) -> None:\n        self.clear_local_dbs()\n\n    def clear_local_dbs(self) -> None:\n        try:\n            shutil.rmtree(\"local_db_events\")\n        except:\n            pass\n        try:\n            shutil.rmtree(\"local_db_markets\")\n        except:\n            pass\n\n    def one_best_trade(self) -> None:\n        \"\"\"\n\n        one_best_trade is a strategy that evaluates all events, markets, and orderbooks\n\n        leverages all available information sources accessible to the autonomous agent\n\n        then executes that trade without any human intervention\n\n        \"\"\"\n        try:\n            self.pre_trade_logic()\n\n            events = self.polymarket.get_all_tradeable_events()\n            print(f\"1. FOUND {len(events)} EVENTS\")\n\n            filtered_events = self.agent.filter_events_with_rag(events)\n            print(f\"2. FILTERED {len(filtered_events)} EVENTS\")\n\n            markets = self.agent.map_filtered_events_to_markets(filtered_events)\n            print()\n            print(f\"3. FOUND {len(markets)} MARKETS\")\n\n            print()\n            filtered_markets = self.agent.filter_markets(markets)\n            print(f\"4. FILTERED {len(filtered_markets)} MARKETS\")\n\n            market = filtered_markets[0]\n            best_trade = self.agent.source_best_trade(market)\n            print(f\"5. CALCULATED TRADE {best_trade}\")\n\n            amount = self.agent.format_trade_prompt_for_execution(best_trade)\n            # Please refer to TOS before uncommenting: polymarket.com/tos\n            # trade = self.polymarket.execute_market_order(market, amount)\n            # print(f\"6. TRADED {trade}\")\n\n        except Exception as e:\n            print(f\"Error {e} \\n \\n Retrying\")\n            self.one_best_trade()\n\n    def maintain_positions(self):\n        pass\n\n    def incentive_farm(self):\n        pass\n\n\nif __name__ == \"__main__\":\n    t = Trader()\n    t.one_best_trade()\n"}
{"type": "source_file", "path": "agents/application/executor.py", "content": "import os\nimport json\nimport ast\nimport re\nfrom typing import List, Dict, Any\n\nimport math\n\nfrom dotenv import load_dotenv\nfrom langchain_core.messages import HumanMessage, SystemMessage\nfrom langchain_openai import ChatOpenAI\n\nfrom agents.polymarket.gamma import GammaMarketClient as Gamma\nfrom agents.connectors.chroma import PolymarketRAG as Chroma\nfrom agents.utils.objects import SimpleEvent, SimpleMarket\nfrom agents.application.prompts import Prompter\nfrom agents.polymarket.polymarket import Polymarket\n\ndef retain_keys(data, keys_to_retain):\n    if isinstance(data, dict):\n        return {\n            key: retain_keys(value, keys_to_retain)\n            for key, value in data.items()\n            if key in keys_to_retain\n        }\n    elif isinstance(data, list):\n        return [retain_keys(item, keys_to_retain) for item in data]\n    else:\n        return data\n\nclass Executor:\n    def __init__(self, default_model='gpt-3.5-turbo-16k') -> None:\n        load_dotenv()\n        max_token_model = {'gpt-3.5-turbo-16k':15000, 'gpt-4-1106-preview':95000}\n        self.token_limit = max_token_model.get(default_model)\n        self.prompter = Prompter()\n        self.openai_api_key = os.getenv(\"OPENAI_API_KEY\")\n        self.llm = ChatOpenAI(\n            model=default_model, #gpt-3.5-turbo\"\n            temperature=0,\n        )\n        self.gamma = Gamma()\n        self.chroma = Chroma()\n        self.polymarket = Polymarket()\n\n    def get_llm_response(self, user_input: str) -> str:\n        system_message = SystemMessage(content=str(self.prompter.market_analyst()))\n        human_message = HumanMessage(content=user_input)\n        messages = [system_message, human_message]\n        result = self.llm.invoke(messages)\n        return result.content\n\n    def get_superforecast(\n        self, event_title: str, market_question: str, outcome: str\n    ) -> str:\n        messages = self.prompter.superforecaster(\n            description=event_title, question=market_question, outcome=outcome\n        )\n        result = self.llm.invoke(messages)\n        return result.content\n\n\n    def estimate_tokens(self, text: str) -> int:\n        # This is a rough estimate. For more accurate results, consider using a tokenizer.\n        return len(text) // 4  # Assuming average of 4 characters per token\n\n    def process_data_chunk(self, data1: List[Dict[Any, Any]], data2: List[Dict[Any, Any]], user_input: str) -> str:\n        system_message = SystemMessage(\n            content=str(self.prompter.prompts_polymarket(data1=data1, data2=data2))\n        )\n        human_message = HumanMessage(content=user_input)\n        messages = [system_message, human_message]\n        result = self.llm.invoke(messages)\n        return result.content\n\n\n    def divide_list(self, original_list, i):\n        # Calculate the size of each sublist\n        sublist_size = math.ceil(len(original_list) / i)\n        \n        # Use list comprehension to create sublists\n        return [original_list[j:j+sublist_size] for j in range(0, len(original_list), sublist_size)]\n    \n    def get_polymarket_llm(self, user_input: str) -> str:\n        data1 = self.gamma.get_current_events()\n        data2 = self.gamma.get_current_markets()\n        \n        combined_data = str(self.prompter.prompts_polymarket(data1=data1, data2=data2))\n        \n        # Estimate total tokens\n        total_tokens = self.estimate_tokens(combined_data)\n        \n        # Set a token limit (adjust as needed, leaving room for system and user messages)\n        token_limit = self.token_limit\n        if total_tokens <= token_limit:\n            # If within limit, process normally\n            return self.process_data_chunk(data1, data2, user_input)\n        else:\n            # If exceeding limit, process in chunks\n            chunk_size = len(combined_data) // ((total_tokens // token_limit) + 1)\n            print(f'total tokens {total_tokens} exceeding llm capacity, now will split and answer')\n            group_size = (total_tokens // token_limit) + 1 # 3 is safe factor\n            keys_no_meaning = ['image','pagerDutyNotificationEnabled','resolvedBy','endDate','clobTokenIds','negRiskMarketID','conditionId','updatedAt','startDate']\n            useful_keys = ['id','questionID','description','liquidity','clobTokenIds','outcomes','outcomePrices','volume','startDate','endDate','question','questionID','events']\n            data1 = retain_keys(data1, useful_keys)\n            cut_1 = self.divide_list(data1, group_size)\n            cut_2 = self.divide_list(data2, group_size)\n            cut_data_12 = zip(cut_1, cut_2)\n\n            results = []\n\n            for cut_data in cut_data_12:\n                sub_data1 = cut_data[0]\n                sub_data2 = cut_data[1]\n                sub_tokens = self.estimate_tokens(str(self.prompter.prompts_polymarket(data1=sub_data1, data2=sub_data2)))\n\n                result = self.process_data_chunk(sub_data1, sub_data2, user_input)\n                results.append(result)\n            \n            combined_result = \" \".join(results)\n            \n        \n            \n            return combined_result\n    def filter_events(self, events: \"list[SimpleEvent]\") -> str:\n        prompt = self.prompter.filter_events(events)\n        result = self.llm.invoke(prompt)\n        return result.content\n\n    def filter_events_with_rag(self, events: \"list[SimpleEvent]\") -> str:\n        prompt = self.prompter.filter_events()\n        print()\n        print(\"... prompting ... \", prompt)\n        print()\n        return self.chroma.events(events, prompt)\n\n    def map_filtered_events_to_markets(\n        self, filtered_events: \"list[SimpleEvent]\"\n    ) -> \"list[SimpleMarket]\":\n        markets = []\n        for e in filtered_events:\n            data = json.loads(e[0].json())\n            market_ids = data[\"metadata\"][\"markets\"].split(\",\")\n            for market_id in market_ids:\n                market_data = self.gamma.get_market(market_id)\n                formatted_market_data = self.polymarket.map_api_to_market(market_data)\n                markets.append(formatted_market_data)\n        return markets\n\n    def filter_markets(self, markets) -> \"list[tuple]\":\n        prompt = self.prompter.filter_markets()\n        print()\n        print(\"... prompting ... \", prompt)\n        print()\n        return self.chroma.markets(markets, prompt)\n\n    def source_best_trade(self, market_object) -> str:\n        market_document = market_object[0].dict()\n        market = market_document[\"metadata\"]\n        outcome_prices = ast.literal_eval(market[\"outcome_prices\"])\n        outcomes = ast.literal_eval(market[\"outcomes\"])\n        question = market[\"question\"]\n        description = market_document[\"page_content\"]\n\n        prompt = self.prompter.superforecaster(question, description, outcomes)\n        print()\n        print(\"... prompting ... \", prompt)\n        print()\n        result = self.llm.invoke(prompt)\n        content = result.content\n\n        print(\"result: \", content)\n        print()\n        prompt = self.prompter.one_best_trade(content, outcomes, outcome_prices)\n        print(\"... prompting ... \", prompt)\n        print()\n        result = self.llm.invoke(prompt)\n        content = result.content\n\n        print(\"result: \", content)\n        print()\n        return content\n\n    def format_trade_prompt_for_execution(self, best_trade: str) -> float:\n        data = best_trade.split(\",\")\n        # price = re.findall(\"\\d+\\.\\d+\", data[0])[0]\n        size = re.findall(\"\\d+\\.\\d+\", data[1])[0]\n        usdc_balance = self.polymarket.get_usdc_balance()\n        return float(size) * usdc_balance\n\n    def source_best_market_to_create(self, filtered_markets) -> str:\n        prompt = self.prompter.create_new_market(filtered_markets)\n        print()\n        print(\"... prompting ... \", prompt)\n        print()\n        result = self.llm.invoke(prompt)\n        content = result.content\n        return content\n"}
{"type": "source_file", "path": "scripts/python/setup.py", "content": "import os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n"}
{"type": "source_file", "path": "agents/utils/utils.py", "content": "import json\n\n\ndef parse_camel_case(key) -> str:\n    output = \"\"\n    for char in key:\n        if char.isupper():\n            output += \" \"\n            output += char.lower()\n        else:\n            output += char\n    return output\n\n\ndef preprocess_market_object(market_object: dict) -> dict:\n    description = market_object[\"description\"]\n\n    for k, v in market_object.items():\n        if k == \"description\":\n            continue\n        if isinstance(v, bool):\n            description += (\n                f' This market is{\" not\" if not v else \"\"} {parse_camel_case(k)}.'\n            )\n\n        if k in [\"volume\", \"liquidity\"]:\n            description += f\" This market has a current {k} of {v}.\"\n    print(\"\\n\\ndescription:\", description)\n\n    market_object[\"description\"] = description\n\n    return market_object\n\n\ndef preprocess_local_json(file_path: str, preprocessor_function: function) -> None:\n    with open(file_path, \"r+\") as open_file:\n        data = json.load(open_file)\n\n    output = []\n    for obj in data:\n        preprocessed_json = preprocessor_function(obj)\n        output.append(preprocessed_json)\n\n    split_path = file_path.split(\".\")\n    new_file_path = split_path[0] + \"_preprocessed.\" + split_path[1]\n    with open(new_file_path, \"w+\") as output_file:\n        json.dump(output, output_file)\n\n\ndef metadata_func(record: dict, metadata: dict) -> dict:\n    print(\"record:\", record)\n    print(\"meta:\", metadata)\n    for k, v in record.items():\n        metadata[k] = v\n\n    del metadata[\"description\"]\n    del metadata[\"events\"]\n\n    return metadata\n"}
{"type": "source_file", "path": "agents/utils/objects.py", "content": "from __future__ import annotations\nfrom typing import Optional, Union\nfrom pydantic import BaseModel\n\n\nclass Trade(BaseModel):\n    id: int\n    taker_order_id: str\n    market: str\n    asset_id: str\n    side: str\n    size: str\n    fee_rate_bps: str\n    price: str\n    status: str\n    match_time: str\n    last_update: str\n    outcome: str\n    maker_address: str\n    owner: str\n    transaction_hash: str\n    bucket_index: str\n    maker_orders: list[str]\n    type: str\n\n\nclass SimpleMarket(BaseModel):\n    id: int\n    question: str\n    # start: str\n    end: str\n    description: str\n    active: bool\n    # deployed: Optional[bool]\n    funded: bool\n    # orderMinSize: float\n    # orderPriceMinTickSize: float\n    rewardsMinSize: float\n    rewardsMaxSpread: float\n    # volume: Optional[float]\n    spread: float\n    outcomes: str\n    outcome_prices: str\n    clob_token_ids: Optional[str]\n\n\nclass ClobReward(BaseModel):\n    id: str  # returned as string in api but really an int?\n    conditionId: str\n    assetAddress: str\n    rewardsAmount: float  # only seen 0 but could be float?\n    rewardsDailyRate: int  # only seen ints but could be float?\n    startDate: str  # yyyy-mm-dd formatted date string\n    endDate: str  # yyyy-mm-dd formatted date string\n\n\nclass Tag(BaseModel):\n    id: str\n    label: Optional[str] = None\n    slug: Optional[str] = None\n    forceShow: Optional[bool] = None  # missing from current events data\n    createdAt: Optional[str] = None  # missing from events data\n    updatedAt: Optional[str] = None  # missing from current events data\n    _sync: Optional[bool] = None\n\n\nclass PolymarketEvent(BaseModel):\n    id: str  # \"11421\"\n    ticker: Optional[str] = None\n    slug: Optional[str] = None\n    title: Optional[str] = None\n    startDate: Optional[str] = None\n    creationDate: Optional[str] = (\n        None  # fine in market event but missing from events response\n    )\n    endDate: Optional[str] = None\n    image: Optional[str] = None\n    icon: Optional[str] = None\n    active: Optional[bool] = None\n    closed: Optional[bool] = None\n    archived: Optional[bool] = None\n    new: Optional[bool] = None\n    featured: Optional[bool] = None\n    restricted: Optional[bool] = None\n    liquidity: Optional[float] = None\n    volume: Optional[float] = None\n    reviewStatus: Optional[str] = None\n    createdAt: Optional[str] = None  # 2024-07-08T01:06:23.982796Z,\n    updatedAt: Optional[str] = None  # 2024-07-15T17:12:48.601056Z,\n    competitive: Optional[float] = None\n    volume24hr: Optional[float] = None\n    enableOrderBook: Optional[bool] = None\n    liquidityClob: Optional[float] = None\n    _sync: Optional[bool] = None\n    commentCount: Optional[int] = None\n    # markets: list[str, 'Market'] # forward reference Market defined below - TODO: double check this works as intended\n    markets: Optional[list[Market]] = None\n    tags: Optional[list[Tag]] = None\n    cyom: Optional[bool] = None\n    showAllOutcomes: Optional[bool] = None\n    showMarketImages: Optional[bool] = None\n\n\nclass Market(BaseModel):\n    id: int\n    question: Optional[str] = None\n    conditionId: Optional[str] = None\n    slug: Optional[str] = None\n    resolutionSource: Optional[str] = None\n    endDate: Optional[str] = None\n    liquidity: Optional[float] = None\n    startDate: Optional[str] = None\n    image: Optional[str] = None\n    icon: Optional[str] = None\n    description: Optional[str] = None\n    outcome: Optional[list] = None\n    outcomePrices: Optional[list] = None\n    volume: Optional[float] = None\n    active: Optional[bool] = None\n    closed: Optional[bool] = None\n    marketMakerAddress: Optional[str] = None\n    createdAt: Optional[str] = None  # date type worth enforcing for dates?\n    updatedAt: Optional[str] = None\n    new: Optional[bool] = None\n    featured: Optional[bool] = None\n    submitted_by: Optional[str] = None\n    archived: Optional[bool] = None\n    resolvedBy: Optional[str] = None\n    restricted: Optional[bool] = None\n    groupItemTitle: Optional[str] = None\n    groupItemThreshold: Optional[int] = None\n    questionID: Optional[str] = None\n    enableOrderBook: Optional[bool] = None\n    orderPriceMinTickSize: Optional[float] = None\n    orderMinSize: Optional[int] = None\n    volumeNum: Optional[float] = None\n    liquidityNum: Optional[float] = None\n    endDateIso: Optional[str] = None  # iso format date = None\n    startDateIso: Optional[str] = None\n    hasReviewedDates: Optional[bool] = None\n    volume24hr: Optional[float] = None\n    clobTokenIds: Optional[list] = None\n    umaBond: Optional[int] = None  # returned as string from api?\n    umaReward: Optional[int] = None  # returned as string from api?\n    volume24hrClob: Optional[float] = None\n    volumeClob: Optional[float] = None\n    liquidityClob: Optional[float] = None\n    acceptingOrders: Optional[bool] = None\n    negRisk: Optional[bool] = None\n    commentCount: Optional[int] = None\n    _sync: Optional[bool] = None\n    events: Optional[list[PolymarketEvent]] = None\n    ready: Optional[bool] = None\n    deployed: Optional[bool] = None\n    funded: Optional[bool] = None\n    deployedTimestamp: Optional[str] = None  # utc z datetime string\n    acceptingOrdersTimestamp: Optional[str] = None  # utc z datetime string,\n    cyom: Optional[bool] = None\n    competitive: Optional[float] = None\n    pagerDutyNotificationEnabled: Optional[bool] = None\n    reviewStatus: Optional[str] = None  # deployed, draft, etc.\n    approved: Optional[bool] = None\n    clobRewards: Optional[list[ClobReward]] = None\n    rewardsMinSize: Optional[int] = (\n        None  # would make sense to allow float but we'll see\n    )\n    rewardsMaxSpread: Optional[float] = None\n    spread: Optional[float] = None\n\n\nclass ComplexMarket(BaseModel):\n    id: int\n    condition_id: str\n    question_id: str\n    tokens: Union[str, str]\n    rewards: str\n    minimum_order_size: str\n    minimum_tick_size: str\n    description: str\n    category: str\n    end_date_iso: str\n    game_start_time: str\n    question: str\n    market_slug: str\n    min_incentive_size: str\n    max_incentive_spread: str\n    active: bool\n    closed: bool\n    seconds_delay: int\n    icon: str\n    fpmm: str\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: Union[float, None] = None\n\n\nclass SimpleEvent(BaseModel):\n    id: int\n    ticker: str\n    slug: str\n    title: str\n    description: str\n    end: str\n    active: bool\n    closed: bool\n    archived: bool\n    restricted: bool\n    new: bool\n    featured: bool\n    restricted: bool\n    markets: str\n\n\nclass Source(BaseModel):\n    id: Optional[str]\n    name: Optional[str]\n\n\nclass Article(BaseModel):\n    source: Optional[Source]\n    author: Optional[str]\n    title: Optional[str]\n    description: Optional[str]\n    url: Optional[str]\n    urlToImage: Optional[str]\n    publishedAt: Optional[str]\n    content: Optional[str]\n"}
{"type": "source_file", "path": "scripts/python/cli.py", "content": "import typer\nfrom devtools import pprint\n\nfrom agents.polymarket.polymarket import Polymarket\nfrom agents.connectors.chroma import PolymarketRAG\nfrom agents.connectors.news import News\nfrom agents.application.trade import Trader\nfrom agents.application.executor import Executor\nfrom agents.application.creator import Creator\n\napp = typer.Typer()\npolymarket = Polymarket()\nnewsapi_client = News()\npolymarket_rag = PolymarketRAG()\n\n\n@app.command()\ndef get_all_markets(limit: int = 5, sort_by: str = \"spread\") -> None:\n    \"\"\"\n    Query Polymarket's markets\n    \"\"\"\n    print(f\"limit: int = {limit}, sort_by: str = {sort_by}\")\n    markets = polymarket.get_all_markets()\n    markets = polymarket.filter_markets_for_trading(markets)\n    if sort_by == \"spread\":\n        markets = sorted(markets, key=lambda x: x.spread, reverse=True)\n    markets = markets[:limit]\n    pprint(markets)\n\n\n@app.command()\ndef get_relevant_news(keywords: str) -> None:\n    \"\"\"\n    Use NewsAPI to query the internet\n    \"\"\"\n    articles = newsapi_client.get_articles_for_cli_keywords(keywords)\n    pprint(articles)\n\n\n@app.command()\ndef get_all_events(limit: int = 5, sort_by: str = \"number_of_markets\") -> None:\n    \"\"\"\n    Query Polymarket's events\n    \"\"\"\n    print(f\"limit: int = {limit}, sort_by: str = {sort_by}\")\n    events = polymarket.get_all_events()\n    events = polymarket.filter_events_for_trading(events)\n    if sort_by == \"number_of_markets\":\n        events = sorted(events, key=lambda x: len(x.markets), reverse=True)\n    events = events[:limit]\n    pprint(events)\n\n\n@app.command()\ndef create_local_markets_rag(local_directory: str) -> None:\n    \"\"\"\n    Create a local markets database for RAG\n    \"\"\"\n    polymarket_rag.create_local_markets_rag(local_directory=local_directory)\n\n\n@app.command()\ndef query_local_markets_rag(vector_db_directory: str, query: str) -> None:\n    \"\"\"\n    RAG over a local database of Polymarket's events\n    \"\"\"\n    response = polymarket_rag.query_local_markets_rag(\n        local_directory=vector_db_directory, query=query\n    )\n    pprint(response)\n\n\n@app.command()\ndef ask_superforecaster(event_title: str, market_question: str, outcome: str) -> None:\n    \"\"\"\n    Ask a superforecaster about a trade\n    \"\"\"\n    print(\n        f\"event: str = {event_title}, question: str = {market_question}, outcome (usually yes or no): str = {outcome}\"\n    )\n    executor = Executor()\n    response = executor.get_superforecast(\n        event_title=event_title, market_question=market_question, outcome=outcome\n    )\n    print(f\"Response:{response}\")\n\n\n@app.command()\ndef create_market() -> None:\n    \"\"\"\n    Format a request to create a market on Polymarket\n    \"\"\"\n    c = Creator()\n    market_description = c.one_best_market()\n    print(f\"market_description: str = {market_description}\")\n\n\n@app.command()\ndef ask_llm(user_input: str) -> None:\n    \"\"\"\n    Ask a question to the LLM and get a response.\n    \"\"\"\n    executor = Executor()\n    response = executor.get_llm_response(user_input)\n    print(f\"LLM Response: {response}\")\n\n\n@app.command()\ndef ask_polymarket_llm(user_input: str) -> None:\n    \"\"\"\n    What types of markets do you want trade?\n    \"\"\"\n    executor = Executor()\n    response = executor.get_polymarket_llm(user_input=user_input)\n    print(f\"LLM + current markets&events response: {response}\")\n\n\n@app.command()\ndef run_autonomous_trader() -> None:\n    \"\"\"\n    Let an autonomous system trade for you.\n    \"\"\"\n    trader = Trader()\n    trader.one_best_trade()\n\n\nif __name__ == \"__main__\":\n    app()\n"}
{"type": "source_file", "path": "scripts/python/server.py", "content": "from typing import Union\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {\"item_id\": item_id, \"q\": q}\n\n\n@app.get(\"/trades/{trade_id}\")\ndef read_trade(trade_id: int, q: Union[str, None] = None):\n    return {\"trade_id\": trade_id, \"q\": q}\n\n\n@app.get(\"/markets/{market_id}\")\ndef read_market(market_id: int, q: Union[str, None] = None):\n    return {\"market_id\": market_id, \"q\": q}\n\n\n# post new prompt\n"}

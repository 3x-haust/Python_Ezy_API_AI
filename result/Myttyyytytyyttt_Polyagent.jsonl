{"repo_info": {"repo_name": "Polyagent", "repo_owner": "Myttyyytytyyttt", "repo_url": "https://github.com/Myttyyytytyyttt/Polyagent"}}
{"type": "test_file", "path": "tests/test.py", "content": "\"\"\"\n% python test/test.py \n...\n----------------------------------------------------------------------\nRan 3 tests in 0.000s\n\nOK\n\"\"\"\n\nimport unittest\n\n\nclass TestStringMethods(unittest.TestCase):\n    def test_upper(self):\n        self.assertEqual(\"foo\".upper(), \"FOO\")\n\n    def test_isupper(self):\n        self.assertTrue(\"FOO\".isupper())\n        self.assertFalse(\"Foo\".isupper())\n\n    def test_split(self):\n        s = \"hello world\"\n        self.assertEqual(s.split(), [\"hello\", \"world\"])\n        # check that s.split fails when the separator is not a string\n        with self.assertRaises(TypeError):\n            s.split(2)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"}
{"type": "test_file", "path": "tests/test_api.py", "content": "import httpx\nimport json\nfrom datetime import datetime\n\ndef test_gamma_api():\n    print(\"\\n\" + \"=\"*50)\n    print(\"INICIANDO TEST DE GAMMA API\")\n    print(\"=\"*50)\n    \n    gamma_url = \"https://gamma-api.polymarket.com\"\n    \n    params = {\n        \"active\": \"true\",\n        \"closed\": \"false\",\n        \"archived\": \"false\",\n        \"limit\": \"10\"\n    }\n    \n    print(f\"\\nURL base: {gamma_url}\")\n    print(f\"Parámetros: {json.dumps(params, indent=2)}\")\n    \n    try:\n        print(\"\\nHaciendo request...\")\n        response = httpx.get(f\"{gamma_url}/markets\", params=params)\n        print(f\"Código de estado: {response.status_code}\")\n        print(f\"URL completa: {response.url}\")\n        \n        if response.status_code == 200:\n            markets = response.json()\n            print(f\"\\nNúmero de mercados encontrados: {len(markets)}\")\n            \n            if markets:\n                for market in markets:\n                    print(\"\\n\" + \"=\"*80)\n                    print(f\"MERCADO: {market.get('question')}\")\n                    print(\"=\"*80)\n                    \n                    # Información básica\n                    print(\"\\nINFORMACIÓN BÁSICA:\")\n                    print(f\"ID: {market.get('id')}\")\n                    print(f\"Categoría: {market.get('category', 'No especificada')}\")\n                    print(f\"Descripción: {market.get('description', 'No disponible')}\")\n                    \n                    # Fechas\n                    end_date = datetime.fromisoformat(market.get('endDate').replace('Z', '+00:00'))\n                    start_date = None\n                    if market.get('startDate'):\n                        start_date = datetime.fromisoformat(market.get('startDate').replace('Z', '+00:00'))\n                    \n                    print(f\"\\nFECHAS:\")\n                    if start_date:\n                        print(f\"Fecha inicio: {start_date.strftime('%d/%m/%Y %H:%M')} UTC\")\n                    print(f\"Fecha fin: {end_date.strftime('%d/%m/%Y %H:%M')} UTC\")\n                    \n                    # Estado\n                    print(f\"\\nESTADO:\")\n                    print(f\"Activo: {'Sí' if market.get('active') else 'No'}\")\n                    print(f\"Cerrado: {'Sí' if market.get('closed') else 'No'}\")\n                    print(f\"Archivado: {'Sí' if market.get('archived') else 'No'}\")\n                    print(f\"Restringido: {'Sí' if market.get('restricted') else 'No'}\")\n                    \n                    # Métricas\n                    print(f\"\\nMÉTRICAS:\")\n                    print(f\"Volumen 24h: {market.get('volume24hr', 0):,.2f}\")\n                    print(f\"Volumen total: {float(market.get('volume', 0)):,.2f}\")\n                    print(f\"Liquidez: {float(market.get('liquidity', 0)):,.2f}\")\n                    \n                    # Trading\n                    print(f\"\\nTRADING:\")\n                    print(f\"Tamaño mínimo orden: {market.get('orderMinSize', 'No especificado')}\")\n                    print(f\"Tick size mínimo: {market.get('orderPriceMinTickSize', 'No especificado')}\")\n                    print(f\"Spread: {market.get('spread', 'No especificado')}\")\n                    \n                    # Precios y resultados\n                    if 'outcomePrices' in market and 'outcomes' in market:\n                        print(f\"\\nRESULTADOS Y PRECIOS:\")\n                        outcomes = eval(market.get('outcomes', '[]'))\n                        prices = eval(market.get('outcomePrices', '[]'))\n                        for outcome, price in zip(outcomes, prices):\n                            print(f\"{outcome}: {float(price):,.3f}\")\n                    \n                    # Links\n                    if market.get('resolutionSource'):\n                        print(f\"\\nFUENTES:\")\n                        print(f\"Fuente de resolución: {market.get('resolutionSource')}\")\n                    \n                    print(\"\\n\" + \"-\"*80)\n            else:\n                print(\"\\nNo se encontraron mercados\")\n                \n    except Exception as e:\n        print(f\"\\nERROR: {str(e)}\")\n        if 'response' in locals():\n            print(f\"Respuesta: {response.text}\")\n\nif __name__ == \"__main__\":\n    # Limpiar la pantalla antes de ejecutar\n    print(\"\\033[H\\033[J\")  # Código ANSI para limpiar la pantalla\n    test_gamma_api()"}
{"type": "source_file", "path": "agents/application/__init__.py", "content": ""}
{"type": "source_file", "path": "agents/utils/utils.py", "content": "import json\n\n\ndef parse_camel_case(key) -> str:\n    output = \"\"\n    for char in key:\n        if char.isupper():\n            output += \" \"\n            output += char.lower()\n        else:\n            output += char\n    return output\n\n\ndef preprocess_market_object(market_object: dict) -> dict:\n    description = market_object[\"description\"]\n\n    for k, v in market_object.items():\n        if k == \"description\":\n            continue\n        if isinstance(v, bool):\n            description += (\n                f' This market is{\" not\" if not v else \"\"} {parse_camel_case(k)}.'\n            )\n\n        if k in [\"volume\", \"liquidity\"]:\n            description += f\" This market has a current {k} of {v}.\"\n    print(\"\\n\\ndescription:\", description)\n\n    market_object[\"description\"] = description\n\n    return market_object\n\n\ndef preprocess_local_json(file_path: str, preprocessor_function: function) -> None:\n    with open(file_path, \"r+\") as open_file:\n        data = json.load(open_file)\n\n    output = []\n    for obj in data:\n        preprocessed_json = preprocessor_function(obj)\n        output.append(preprocessed_json)\n\n    split_path = file_path.split(\".\")\n    new_file_path = split_path[0] + \"_preprocessed.\" + split_path[1]\n    with open(new_file_path, \"w+\") as output_file:\n        json.dump(output, output_file)\n\n\ndef metadata_func(record: dict, metadata: dict) -> dict:\n    print(\"record:\", record)\n    print(\"meta:\", metadata)\n    for k, v in record.items():\n        metadata[k] = v\n\n    del metadata[\"description\"]\n    del metadata[\"events\"]\n\n    return metadata\n"}
{"type": "source_file", "path": "scripts/python/setup.py", "content": "import os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n"}
{"type": "source_file", "path": "agents/application/cron.py", "content": "from agents.application.trade import Trader\n\nimport time\n\nfrom scheduler import Scheduler\nfrom scheduler.trigger import Monday\n\n\nclass Scheduler:\n    def __init__(self) -> None:\n        self.trader = Trader()\n        self.schedule = Scheduler()\n\n    def start(self) -> None:\n        while True:\n            self.schedule.exec_jobs()\n            time.sleep(1)\n\n\nclass TradingAgent(Scheduler):\n    def __init__(self) -> None:\n        super()\n        self.trader = Trader()\n        self.weekly(Monday(), self.trader.one_best_trade)\n"}
{"type": "source_file", "path": "scripts/python/server.py", "content": "from typing import Union\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {\"item_id\": item_id, \"q\": q}\n\n\n@app.get(\"/trades/{trade_id}\")\ndef read_trade(trade_id: int, q: Union[str, None] = None):\n    return {\"trade_id\": trade_id, \"q\": q}\n\n\n@app.get(\"/markets/{market_id}\")\ndef read_market(market_id: int, q: Union[str, None] = None):\n    return {\"market_id\": market_id, \"q\": q}\n\n\n# post new prompt\n"}
{"type": "source_file", "path": "agents/application/executor.py", "content": "import os\nimport json\nimport ast\nimport re\nfrom typing import List, Dict, Any\nimport math\nfrom dotenv import load_dotenv\nfrom langchain_core.messages import HumanMessage, SystemMessage\nfrom langchain_openai import ChatOpenAI\nfrom colorama import Fore, Style\nfrom collections import defaultdict\nimport spacy  # Para NLP\nimport numpy as np\nfrom sklearn.feature_extraction.text import TfidfVectorizer  # Para vectorización de texto\n\nfrom agents.polymarket.gamma import GammaMarketClient as Gamma\nfrom agents.connectors.chroma import PolymarketRAG as Chroma\nfrom agents.utils.objects import SimpleEvent, SimpleMarket\nfrom agents.application.prompts import Prompter\nfrom agents.polymarket.polymarket import Polymarket\nfrom agents.connectors.search import MarketSearch\n\ndef retain_keys(data, keys_to_retain):\n    if isinstance(data, dict):\n        return {\n            key: retain_keys(value, keys_to_retain)\n            for key, value in data.items()\n            if key in keys_to_retain\n        }\n    elif isinstance(data, list):\n        return [retain_keys(item, keys_to_retain) for item in data]\n    else:\n        return data\n\nclass Executor:\n    def __init__(self, default_model='gpt-3.5-turbo-16k') -> None:\n        load_dotenv()\n        max_token_model = {'gpt-3.5-turbo-16k':15000, 'gpt-4-1106-preview':95000}\n        self.token_limit = max_token_model.get(default_model)\n        self.prompter = Prompter()\n        self.openai_api_key = os.getenv(\"OPENAI_API_KEY\")\n        self.llm = ChatOpenAI(\n            model=default_model, #gpt-3.5-turbo\"\n            temperature=0,\n        )\n        self.gamma = Gamma()\n        self.chroma = Chroma()\n        self.polymarket = Polymarket()\n        self.search = MarketSearch()\n        \n        # Cargar modelo de spaCy para NLP\n        self.nlp = spacy.load(\"en_core_web_sm\")\n        \n        # Definir categorías y sus palabras clave principales\n        self.category_keywords = {\n            \"sports\": {\n                \"leagues\": [\"nfl\", \"nba\", \"mlb\", \"nhl\", \"epl\", \"uefa\", \"fifa\", \"f1\"],\n                \"events\": [\"super bowl\", \"world cup\", \"champions league\", \"stanley cup\", \"playoffs\"],\n                \"roles\": [\"player\", \"coach\", \"team\", \"manager\", \"mvp\", \"rookie\"],\n                \"actions\": [\"win\", \"score\", \"lead\", \"defeat\", \"qualify\", \"advance\"],\n                \"metrics\": [\"points\", \"goals\", \"assists\", \"rebounds\", \"touchdowns\", \"yards\"],\n                \"competitions\": [\"tournament\", \"championship\", \"series\", \"match\", \"game\", \"race\"]\n            },\n            \"crypto\": {\n                \"assets\": [\"bitcoin\", \"ethereum\", \"solana\", \"btc\", \"eth\", \"sol\"],\n                \"metrics\": [\"price\", \"market cap\", \"volume\", \"liquidity\", \"supply\"],\n                \"actions\": [\"buy\", \"sell\", \"trade\", \"mine\", \"stake\", \"yield\"],\n                \"concepts\": [\"blockchain\", \"defi\", \"nft\", \"dao\", \"token\", \"coin\"],\n                \"events\": [\"halving\", \"fork\", \"upgrade\", \"launch\", \"listing\", \"airdrop\"]\n            },\n            \"politics\": {\n                \"roles\": [\"president\", \"senator\", \"governor\", \"minister\", \"candidate\"],\n                \"events\": [\"election\", \"vote\", \"debate\", \"campaign\", \"inauguration\"],\n                \"institutions\": [\"congress\", \"senate\", \"parliament\", \"fed\", \"court\"],\n                \"policies\": [\"bill\", \"law\", \"regulation\", \"reform\", \"policy\"],\n                \"economic\": [\"rate\", \"inflation\", \"recession\", \"budget\", \"debt\"]\n            },\n            \"entertainment\": {\n                \"awards\": [\"oscar\", \"grammy\", \"emmy\", \"golden globe\", \"tony\"],\n                \"media\": [\"movie\", \"film\", \"song\", \"album\", \"show\", \"series\"],\n                \"roles\": [\"actor\", \"actress\", \"director\", \"producer\", \"artist\"],\n                \"events\": [\"premiere\", \"release\", \"concert\", \"festival\", \"ceremony\"],\n                \"metrics\": [\"box office\", \"ratings\", \"views\", \"sales\", \"streams\"]\n            },\n            \"tech\": {\n                \"companies\": [\"apple\", \"google\", \"microsoft\", \"meta\", \"openai\"],\n                \"products\": [\"iphone\", \"android\", \"windows\", \"chatgpt\", \"tesla\"],\n                \"concepts\": [\"ai\", \"cloud\", \"quantum\", \"metaverse\", \"web3\"],\n                \"events\": [\"launch\", \"release\", \"update\", \"acquisition\", \"ipo\"],\n                \"metrics\": [\"revenue\", \"users\", \"growth\", \"valuation\", \"share\"]\n            }\n        }\n        \n        # Entrenar vectorizador\n        self.vectorizer = self._train_vectorizer()\n\n    def _train_vectorizer(self):\n        # Crear corpus de entrenamiento desde keywords\n        corpus = []\n        labels = []\n        for category, keyword_groups in self.category_keywords.items():\n            for group in keyword_groups.values():\n                corpus.extend(group)\n                labels.extend([category] * len(group))\n                \n        vectorizer = TfidfVectorizer(ngram_range=(1, 3))\n        vectorizer.fit(corpus)\n        return vectorizer\n\n    def get_llm_response(self, user_input: str) -> str:\n        system_message = SystemMessage(content=str(self.prompter.market_analyst()))\n        human_message = HumanMessage(content=user_input)\n        messages = [system_message, human_message]\n        result = self.llm.invoke(messages)\n        return result.content\n\n    def get_superforecast(\n        self, event_title: str, market_question: str, outcome: str\n    ) -> str:\n        messages = self.prompter.superforecaster(\n            description=event_title, question=market_question, outcome=outcome\n        )\n        result = self.llm.invoke(messages)\n        return result.content\n\n\n    def estimate_tokens(self, text: str) -> int:\n        # This is a rough estimate. For more accurate results, consider using a tokenizer.\n        return len(text) // 4  # Assuming average of 4 characters per token\n\n    def process_data_chunk(self, data1: List[Dict[Any, Any]], data2: List[Dict[Any, Any]], user_input: str) -> str:\n        system_message = SystemMessage(\n            content=str(self.prompter.prompts_polymarket(data1=data1, data2=data2))\n        )\n        human_message = HumanMessage(content=user_input)\n        messages = [system_message, human_message]\n        result = self.llm.invoke(messages)\n        return result.content\n\n\n    def divide_list(self, original_list, i):\n        # Calculate the size of each sublist\n        sublist_size = math.ceil(len(original_list) / i)\n        \n        # Use list comprehension to create sublists\n        return [original_list[j:j+sublist_size] for j in range(0, len(original_list), sublist_size)]\n    \n    def get_polymarket_llm(self, user_input: str) -> str:\n        data1 = self.gamma.get_current_events()\n        data2 = self.gamma.get_current_markets()\n        \n        combined_data = str(self.prompter.prompts_polymarket(data1=data1, data2=data2))\n        \n        # Estimate total tokens\n        total_tokens = self.estimate_tokens(combined_data)\n        \n        # Set a token limit (adjust as needed, leaving room for system and user messages)\n        token_limit = self.token_limit\n        if total_tokens <= token_limit:\n            # If within limit, process normally\n            return self.process_data_chunk(data1, data2, user_input)\n        else:\n            # If exceeding limit, process in chunks\n            chunk_size = len(combined_data) // ((total_tokens // token_limit) + 1)\n            print(f'total tokens {total_tokens} exceeding llm capacity, now will split and answer')\n            group_size = (total_tokens // token_limit) + 1 # 3 is safe factor\n            keys_no_meaning = ['image','pagerDutyNotificationEnabled','resolvedBy','endDate','clobTokenIds','negRiskMarketID','conditionId','updatedAt','startDate']\n            useful_keys = ['id','questionID','description','liquidity','clobTokenIds','outcomes','outcomePrices','volume','startDate','endDate','question','questionID','events']\n            data1 = retain_keys(data1, useful_keys)\n            cut_1 = self.divide_list(data1, group_size)\n            cut_2 = self.divide_list(data2, group_size)\n            cut_data_12 = zip(cut_1, cut_2)\n\n            results = []\n\n            for cut_data in cut_data_12:\n                sub_data1 = cut_data[0]\n                sub_data2 = cut_data[1]\n                sub_tokens = self.estimate_tokens(str(self.prompter.prompts_polymarket(data1=sub_data1, data2=sub_data2)))\n\n                result = self.process_data_chunk(sub_data1, sub_data2, user_input)\n                results.append(result)\n            \n            combined_result = \" \".join(results)\n            \n        \n            \n            return combined_result\n    def filter_events(self, events: \"list[SimpleEvent]\") -> str:\n        prompt = self.prompter.filter_events(events)\n        result = self.llm.invoke(prompt)\n        return result.content\n\n    def detect_category(self, question: str) -> str:\n        # Preprocesar texto\n        doc = self.nlp(question.lower())\n        \n        # Extraer entidades nombradas y frases clave\n        entities = [ent.text for ent in doc.ents]\n        noun_phrases = [chunk.text for chunk in doc.noun_chunks]\n        \n        # Calcular scores para cada categoría\n        scores = defaultdict(float)\n        \n        # 1. Coincidencia directa con palabras clave\n        for category, keyword_groups in self.category_keywords.items():\n            for group_name, keywords in keyword_groups.items():\n                weight = 2.0 if group_name == \"primary\" else 1.0\n                for keyword in keywords:\n                    if keyword in question.lower():\n                        scores[category] += weight\n                        \n        # 2. Análisis de entidades y frases\n        for entity in entities + noun_phrases:\n            # Vectorizar y comparar con keywords de cada categoría\n            entity_vector = self.vectorizer.transform([entity])\n            for category, keyword_groups in self.category_keywords.items():\n                for keywords in keyword_groups.values():\n                    keyword_vectors = self.vectorizer.transform(keywords)\n                    similarity = np.mean(entity_vector.dot(keyword_vectors.T).toarray())\n                    scores[category] += similarity\n        \n        # Normalizar scores\n        total = sum(scores.values())\n        if total > 0:\n            scores = {k: v/total for k, v in scores.items()}\n            \n        # Retornar categoría con mayor score si supera un umbral\n        best_category = max(scores.items(), key=lambda x: x[1], default=(\"other\", 0))\n        return best_category[0] if best_category[1] > 0.3 else \"other\"\n\n    def filter_events_with_rag(self, events: \"list[tuple[SimpleEvent, float]]\") -> \"list[tuple[SimpleEvent, float]]\":\n        \"\"\"Filtra eventos por categoría\"\"\"\n        market_category = str(os.getenv(\"MARKET_CATEGORY\", \"all\")).lower().strip()\n        print(f\"\\nFiltering {len(events)} events for category: {market_category}\")\n        \n        # Si es 'all', retornar todos los eventos\n        if market_category == 'all':\n            print(f\"Returning all {len(events)} events\")\n            return events\n        \n        filtered_events = []\n        for event_tuple in events:\n            event = event_tuple[0]\n            question = event.metadata.get(\"question\", event.title)\n            event_category = self.detect_category(question)\n            \n            print(f\"Question: {question}\")\n            print(f\"Detected category: {event_category}\")\n            \n            if event_category == market_category:\n                filtered_events.append(event_tuple)\n        \n        print(f\"\\nFound {len(filtered_events)} {market_category} markets\")\n        if not filtered_events:\n            print(f\"\\nNo markets found for category: {market_category}\")\n        \n        return filtered_events\n\n    def map_filtered_events_to_markets(\n        self, filtered_events: \"list[tuple[Dict, float]]\"\n    ) -> \"list[tuple[SimpleMarket, float]]\":\n        if not filtered_events:\n            return []\n            \n        markets = []\n        \n        for event_tuple in filtered_events:\n            event_dict = event_tuple[0]  # Ahora es un diccionario\n            event = event_dict['event']  # Obtener el SimpleEvent del diccionario\n            trade_data = event_dict['trade']  # Obtener los datos del trade\n            \n            if not isinstance(event, SimpleEvent):\n                continue\n                \n            # Usar metadata para obtener los market_ids\n            market_ids = event.metadata.get(\"markets\", \"\").split(\",\")\n            \n            for market_id in market_ids:\n                if not market_id:\n                    continue\n                try:\n                    # Usar los datos del trade si están disponibles\n                    market_data = trade_data.get('market_data', self.gamma.get_market(market_id))\n                    \n                    # Crear SimpleMarket\n                    simple_market = SimpleMarket(\n                        id=int(market_data.get(\"id\")),\n                        question=market_data.get(\"question\", \"\"),\n                        description=market_data.get(\"description\", \"\"),\n                        end=market_data.get(\"endDate\", \"\"),\n                        active=True,\n                        funded=True,\n                        rewardsMinSize=0.0,\n                        rewardsMaxSpread=0.0,\n                        spread=0.0,\n                        outcomes=str(market_data.get(\"outcomes\", \"[]\")),\n                        outcome_prices=str(market_data.get(\"outcomePrices\", \"[]\")),\n                        clob_token_ids=str(market_data.get(\"clobTokenIds\", \"[]\"))\n                    )\n                    markets.append((simple_market, event_tuple[1]))\n                    \n                except Exception as e:\n                    print(f\"{Fore.RED}Error getting market {market_id}: {str(e)}{Style.RESET_ALL}\")\n                    continue\n                    \n        return markets\n\n    def filter_markets(self, markets) -> \"list[tuple]\":\n        if not markets:\n            print(f\"{Fore.YELLOW}No markets to filter{Style.RESET_ALL}\")\n            return []\n            \n        prompt = self.prompter.filter_markets()\n        print()\n        print(\"... prompting ... \", prompt)\n        print()\n        return self.chroma.markets(markets, prompt)\n\n    def extract_probability(self, conclusion: str) -> float:\n        try:\n            # Buscar un número entre 0 y 1 en el texto\n            import re\n            probability_matches = re.findall(r\"likelihood of (\\d*\\.?\\d+)\", conclusion)\n            if probability_matches:\n                return float(probability_matches[0])\n            \n            # Si no encuentra el formato exacto, buscar cualquier número entre 0 y 1\n            number_matches = re.findall(r\"(\\d*\\.?\\d+)\", conclusion)\n            for match in number_matches:\n                num = float(match)\n                if 0 <= num <= 1:\n                    return num\n                    \n            raise ValueError(\"No valid probability found in conclusion\")\n            \n        except Exception as e:\n            print(f\"{Fore.RED}Error extracting probability: {str(e)}{Style.RESET_ALL}\")\n            return None\n\n    def source_best_trade(self, market_tuple) -> dict:\n        try:\n            market = market_tuple[0]  # SimpleMarket\n            \n            # Extraer los datos necesarios directamente del SimpleMarket\n            outcome_prices = ast.literal_eval(market.outcome_prices)\n            outcomes = ast.literal_eval(market.outcomes)\n            question = market.question\n            description = market.description\n\n            # Obtener información relacionada\n            related_info = self.search.get_related_markets(question)\n            context = f\"\"\"\n            Related markets and information:\n            {related_info}\n            \n            Original question: {question}\n            \"\"\"\n            \n            # Obtener análisis con contexto ampliado\n            prompt = self.prompter.superforecaster(context, description, outcome_prices)\n            result = self.llm.invoke(prompt)\n            analysis = result.content\n            \n            print(f\"{Fore.YELLOW}AI Analysis:\")\n            print(analysis)\n            \n            # Extraer la conclusión y probabilidad de manera más robusta\n            conclusion = analysis.split(\"CONCLUSION:\")[1].strip()\n            ai_probability = self.extract_probability(conclusion)\n            \n            if ai_probability is None:\n                return None\n            \n            # Determinar si hay edge vs precio de mercado\n            market_yes = float(outcome_prices[0])\n            market_no = float(outcome_prices[1])\n            \n            # Calcular edge y confianza\n            edge_yes = abs(ai_probability - market_yes)\n            edge_no = abs((1 - ai_probability) - market_no)\n            confidence_yes = ai_probability\n            confidence_no = 1 - ai_probability\n            \n            # Crear trade basado en el análisis\n            if edge_yes > 0.02 or confidence_yes > 0.75:  # Si hay edge significativo o alta confianza en YES\n                trade_dict = {\n                    'side': 'BUY',\n                    'position': 'YES',\n                    'price': market_yes,\n                    'edge': edge_yes,\n                    'confidence': confidence_yes\n                }\n            elif edge_no > 0.02 or confidence_no > 0.75:  # Si hay edge significativo o alta confianza en NO\n                trade_dict = {\n                    'side': 'BUY',\n                    'position': 'NO',\n                    'price': market_no,\n                    'edge': edge_no,\n                    'confidence': confidence_no\n                }\n            else:\n                print(f\"{Fore.YELLOW}Neither sufficient edge ({max(edge_yes, edge_no):.2%}) nor confidence ({max(confidence_yes, confidence_no):.2%}){Style.RESET_ALL}\")\n                return None\n            \n            trade_dict.update({\n                'analysis': analysis,\n                'prediction': conclusion\n            })\n\n            return trade_dict\n\n        except Exception as e:\n            print(f\"{Fore.RED}Error processing market: {str(e)}{Style.RESET_ALL}\")\n            return None\n\n    def format_trade_prompt_for_execution(self, best_trade: str) -> float:\n        if isinstance(best_trade, str):\n            # Si es string, parsearlo\n            data = best_trade.split(\",\")\n            size = re.findall(\"\\d+\\.\\d+\", data[1])[0]\n            return float(1.0)  # Monto fijo de 1 USDC para pruebas\n        elif isinstance(best_trade, dict):\n            # Si ya es diccionario, usar el size directamente\n            return float(best_trade.get('size', 1.0))\n        \n        # Por defecto, retornar 1 USDC\n        return 1.0\n\n    def source_best_market_to_create(self, filtered_markets) -> str:\n        prompt = self.prompter.create_new_market(filtered_markets)\n        print()\n        print(\"... prompting ... \", prompt)\n        print()\n        result = self.llm.invoke(prompt)\n        content = result.content\n        return content\n"}
{"type": "source_file", "path": "agents/utils/objects.py", "content": "from __future__ import annotations\nfrom typing import Optional, Union, Dict, Any\nfrom pydantic import BaseModel\n\n\nclass Trade(BaseModel):\n    id: int\n    taker_order_id: str\n    market: str\n    asset_id: str\n    side: str\n    size: str\n    fee_rate_bps: str\n    price: str\n    status: str\n    match_time: str\n    last_update: str\n    outcome: str\n    maker_address: str\n    owner: str\n    transaction_hash: str\n    bucket_index: str\n    maker_orders: list[str]\n    type: str\n\n\nclass SimpleMarket(BaseModel):\n    id: int\n    question: str\n    # start: str\n    end: str\n    description: str\n    active: bool\n    # deployed: Optional[bool]\n    funded: bool\n    # orderMinSize: float\n    # orderPriceMinTickSize: float\n    rewardsMinSize: float\n    rewardsMaxSpread: float\n    # volume: Optional[float]\n    spread: float\n    outcomes: str\n    outcome_prices: str\n    clob_token_ids: Optional[str]\n\n\nclass ClobReward(BaseModel):\n    id: str  # returned as string in api but really an int?\n    conditionId: str\n    assetAddress: str\n    rewardsAmount: float  # only seen 0 but could be float?\n    rewardsDailyRate: int  # only seen ints but could be float?\n    startDate: str  # yyyy-mm-dd formatted date string\n    endDate: str  # yyyy-mm-dd formatted date string\n\n\nclass Tag(BaseModel):\n    id: str\n    label: Optional[str] = None\n    slug: Optional[str] = None\n    forceShow: Optional[bool] = None  # missing from current events data\n    createdAt: Optional[str] = None  # missing from events data\n    updatedAt: Optional[str] = None  # missing from current events data\n    _sync: Optional[bool] = None\n\n\nclass PolymarketEvent(BaseModel):\n    id: str  # \"11421\"\n    ticker: Optional[str] = None\n    slug: Optional[str] = None\n    title: Optional[str] = None\n    startDate: Optional[str] = None\n    creationDate: Optional[str] = (\n        None  # fine in market event but missing from events response\n    )\n    endDate: Optional[str] = None\n    image: Optional[str] = None\n    icon: Optional[str] = None\n    active: Optional[bool] = None\n    closed: Optional[bool] = None\n    archived: Optional[bool] = None\n    new: Optional[bool] = None\n    featured: Optional[bool] = None\n    restricted: Optional[bool] = None\n    liquidity: Optional[float] = None\n    volume: Optional[float] = None\n    reviewStatus: Optional[str] = None\n    createdAt: Optional[str] = None  # 2024-07-08T01:06:23.982796Z,\n    updatedAt: Optional[str] = None  # 2024-07-15T17:12:48.601056Z,\n    competitive: Optional[float] = None\n    volume24hr: Optional[float] = None\n    enableOrderBook: Optional[bool] = None\n    liquidityClob: Optional[float] = None\n    _sync: Optional[bool] = None\n    commentCount: Optional[int] = None\n    # markets: list[str, 'Market'] # forward reference Market defined below - TODO: double check this works as intended\n    markets: Optional[list[Market]] = None\n    tags: Optional[list[Tag]] = None\n    cyom: Optional[bool] = None\n    showAllOutcomes: Optional[bool] = None\n    showMarketImages: Optional[bool] = None\n\n\nclass Market(BaseModel):\n    id: int\n    question: Optional[str] = None\n    conditionId: Optional[str] = None\n    slug: Optional[str] = None\n    resolutionSource: Optional[str] = None\n    endDate: Optional[str] = None\n    liquidity: Optional[float] = None\n    startDate: Optional[str] = None\n    image: Optional[str] = None\n    icon: Optional[str] = None\n    description: Optional[str] = None\n    outcome: Optional[list] = None\n    outcomePrices: Optional[list] = None\n    volume: Optional[float] = None\n    active: Optional[bool] = None\n    closed: Optional[bool] = None\n    marketMakerAddress: Optional[str] = None\n    createdAt: Optional[str] = None  # date type worth enforcing for dates?\n    updatedAt: Optional[str] = None\n    new: Optional[bool] = None\n    featured: Optional[bool] = None\n    submitted_by: Optional[str] = None\n    archived: Optional[bool] = None\n    resolvedBy: Optional[str] = None\n    restricted: Optional[bool] = None\n    groupItemTitle: Optional[str] = None\n    groupItemThreshold: Optional[int] = None\n    questionID: Optional[str] = None\n    enableOrderBook: Optional[bool] = None\n    orderPriceMinTickSize: Optional[float] = None\n    orderMinSize: Optional[int] = None\n    volumeNum: Optional[float] = None\n    liquidityNum: Optional[float] = None\n    endDateIso: Optional[str] = None  # iso format date = None\n    startDateIso: Optional[str] = None\n    hasReviewedDates: Optional[bool] = None\n    volume24hr: Optional[float] = None\n    clobTokenIds: Optional[list] = None\n    umaBond: Optional[int] = None  # returned as string from api?\n    umaReward: Optional[int] = None  # returned as string from api?\n    volume24hrClob: Optional[float] = None\n    volumeClob: Optional[float] = None\n    liquidityClob: Optional[float] = None\n    acceptingOrders: Optional[bool] = None\n    negRisk: Optional[bool] = None\n    commentCount: Optional[int] = None\n    _sync: Optional[bool] = None\n    events: Optional[list[PolymarketEvent]] = None\n    ready: Optional[bool] = None\n    deployed: Optional[bool] = None\n    funded: Optional[bool] = None\n    deployedTimestamp: Optional[str] = None  # utc z datetime string\n    acceptingOrdersTimestamp: Optional[str] = None  # utc z datetime string,\n    cyom: Optional[bool] = None\n    competitive: Optional[float] = None\n    pagerDutyNotificationEnabled: Optional[bool] = None\n    reviewStatus: Optional[str] = None  # deployed, draft, etc.\n    approved: Optional[bool] = None\n    clobRewards: Optional[list[ClobReward]] = None\n    rewardsMinSize: Optional[int] = (\n        None  # would make sense to allow float but we'll see\n    )\n    rewardsMaxSpread: Optional[float] = None\n    spread: Optional[float] = None\n\n\nclass ComplexMarket(BaseModel):\n    id: int\n    condition_id: str\n    question_id: str\n    tokens: Union[str, str]\n    rewards: str\n    minimum_order_size: str\n    minimum_tick_size: str\n    description: str\n    category: str\n    end_date_iso: str\n    game_start_time: str\n    question: str\n    market_slug: str\n    min_incentive_size: str\n    max_incentive_spread: str\n    active: bool\n    closed: bool\n    seconds_delay: int\n    icon: str\n    fpmm: str\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: Union[float, None] = None\n\n\nclass SimpleEvent(BaseModel):\n    id: str\n    title: str\n    description: str\n    markets: str\n    metadata: Dict[str, Any]\n    trade: dict = {}  # Añadir este campo con un valor por defecto\n\n    def dict(self):\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"markets\": self.markets,\n            \"metadata\": self.metadata\n        }\n\n\nclass Source(BaseModel):\n    id: Optional[str]\n    name: Optional[str]\n\n\nclass Article(BaseModel):\n    source: Optional[Source]\n    author: Optional[str]\n    title: Optional[str]\n    description: Optional[str]\n    url: Optional[str]\n    urlToImage: Optional[str]\n    publishedAt: Optional[str]\n    content: Optional[str]\n"}
{"type": "source_file", "path": "agents/polymarket/gamma.py", "content": "import httpx\nimport json\n\nfrom agents.polymarket.polymarket import Polymarket\nfrom agents.utils.objects import Market, PolymarketEvent, ClobReward, Tag\n\n\nclass GammaMarketClient:\n    def __init__(self):\n        self.gamma_url = \"https://gamma-api.polymarket.com\"\n        self.gamma_markets_endpoint = self.gamma_url + \"/markets\"\n        self.gamma_events_endpoint = self.gamma_url + \"/events\"\n\n    def parse_pydantic_market(self, market_object: dict) -> Market:\n        try:\n            if \"clobRewards\" in market_object:\n                clob_rewards: list[ClobReward] = []\n                for clob_rewards_obj in market_object[\"clobRewards\"]:\n                    clob_rewards.append(ClobReward(**clob_rewards_obj))\n                market_object[\"clobRewards\"] = clob_rewards\n\n            if \"events\" in market_object:\n                events: list[PolymarketEvent] = []\n                for market_event_obj in market_object[\"events\"]:\n                    events.append(self.parse_nested_event(market_event_obj))\n                market_object[\"events\"] = events\n\n            # These two fields below are returned as stringified lists from the api\n            if \"outcomePrices\" in market_object:\n                market_object[\"outcomePrices\"] = json.loads(\n                    market_object[\"outcomePrices\"]\n                )\n            if \"clobTokenIds\" in market_object:\n                market_object[\"clobTokenIds\"] = json.loads(\n                    market_object[\"clobTokenIds\"]\n                )\n\n            return Market(**market_object)\n        except Exception as err:\n            print(f\"[parse_market] Caught exception: {err}\")\n            print(\"exception while handling object:\", market_object)\n\n    # Event parser for events nested under a markets api response\n    def parse_nested_event(self, event_object: dict()) -> PolymarketEvent:\n        print(\"[parse_nested_event] called with:\", event_object)\n        try:\n            if \"tags\" in event_object:\n                print(\"tags here\", event_object[\"tags\"])\n                tags: list[Tag] = []\n                for tag in event_object[\"tags\"]:\n                    tags.append(Tag(**tag))\n                event_object[\"tags\"] = tags\n\n            return PolymarketEvent(**event_object)\n        except Exception as err:\n            print(f\"[parse_event] Caught exception: {err}\")\n            print(\"\\n\", event_object)\n\n    def parse_pydantic_event(self, event_object: dict) -> PolymarketEvent:\n        try:\n            if \"tags\" in event_object:\n                print(\"tags here\", event_object[\"tags\"])\n                tags: list[Tag] = []\n                for tag in event_object[\"tags\"]:\n                    tags.append(Tag(**tag))\n                event_object[\"tags\"] = tags\n            return PolymarketEvent(**event_object)\n        except Exception as err:\n            print(f\"[parse_event] Caught exception: {err}\")\n\n    def get_markets(\n        self, querystring_params={}, parse_pydantic=False, local_file_path=None\n    ) -> \"list[Market]\":\n        if parse_pydantic and local_file_path is not None:\n            raise Exception(\n                'Cannot use \"parse_pydantic\" and \"local_file\" params simultaneously.'\n            )\n\n        response = httpx.get(self.gamma_markets_endpoint, params=querystring_params)\n        if response.status_code == 200:\n            data = response.json()\n            if local_file_path is not None:\n                with open(local_file_path, \"w+\") as out_file:\n                    json.dump(data, out_file)\n            elif not parse_pydantic:\n                return data\n            else:\n                markets: list[Market] = []\n                for market_object in data:\n                    markets.append(self.parse_pydantic_market(market_object))\n                return markets\n        else:\n            print(f\"Error response returned from api: HTTP {response.status_code}\")\n            raise Exception()\n\n    def get_events(\n        self, querystring_params={}, parse_pydantic=False, local_file_path=None\n    ) -> \"list[PolymarketEvent]\":\n        if parse_pydantic and local_file_path is not None:\n            raise Exception(\n                'Cannot use \"parse_pydantic\" and \"local_file\" params simultaneously.'\n            )\n\n        max_retries = 3\n        retry_count = 0\n        \n        while retry_count < max_retries:\n            try:\n                response = httpx.get(self.gamma_events_endpoint, params=querystring_params, timeout=10.0)\n                if response.status_code == 200:\n                    data = response.json()\n                    if local_file_path is not None:\n                        with open(local_file_path, \"w+\") as out_file:\n                            json.dump(data, out_file)\n                    elif not parse_pydantic:\n                        return data\n                    else:\n                        events: list[PolymarketEvent] = []\n                        for market_event_obj in data:\n                            events.append(self.parse_event(market_event_obj))\n                        return events\n                else:\n                    print(f\"Error HTTP {response.status_code}\")\n                    retry_count += 1\n                    if retry_count == max_retries:\n                        return []  # Retornar lista vacía si fallan todos los intentos\n            except Exception as e:\n                print(f\"Error en la petición: {e}\")\n                retry_count += 1\n                if retry_count == max_retries:\n                    return []\n\n    def get_all_markets(self, limit=2) -> \"list[Market]\":\n        return self.get_markets(querystring_params={\"limit\": limit})\n\n    def get_all_events(self, limit=2) -> \"list[PolymarketEvent]\":\n        return self.get_events(querystring_params={\"limit\": limit})\n\n    def get_current_markets(self, limit=4) -> \"list[Market]\":\n        return self.get_markets(\n            querystring_params={\n                \"active\": True,\n                \"closed\": False,\n                \"archived\": False,\n                \"limit\": limit,\n            }\n        )\n\n    def get_all_current_markets(self, limit=100) -> \"list[Market]\":\n        offset = 0\n        all_markets = []\n        while True:\n            params = {\n                \"active\": True,\n                \"closed\": False,\n                \"archived\": False,\n                \"limit\": limit,\n                \"offset\": offset,\n            }\n            market_batch = self.get_markets(querystring_params=params)\n            all_markets.extend(market_batch)\n\n            if len(market_batch) < limit:\n                break\n            offset += limit\n\n        return all_markets\n\n    def get_current_events(self, limit=4) -> \"list[PolymarketEvent]\":\n        return self.get_events(\n            querystring_params={\n                \"active\": True,\n                \"closed\": False,\n                \"archived\": False,\n                \"limit\": limit,\n            }\n        )\n\n    def get_clob_tradable_markets(self, limit=2) -> \"list[Market]\":\n        return self.get_markets(\n            querystring_params={\n                \"active\": True,\n                \"closed\": False,\n                \"archived\": False,\n                \"limit\": limit,\n                \"enableOrderBook\": True,\n            }\n        )\n\n    def get_market(self, market_id: int) -> dict():\n        url = self.gamma_markets_endpoint + \"/\" + str(market_id)\n        print(url)\n        response = httpx.get(url)\n        return response.json()\n\n\nif __name__ == \"__main__\":\n    gamma = GammaMarketClient()\n    market = gamma.get_market(\"253123\")\n    poly = Polymarket()\n    object = poly.map_api_to_market(market)\n"}
{"type": "source_file", "path": "agents/application/creator.py", "content": "from agents.application.executor import Executor as Agent\nfrom agents.polymarket.gamma import GammaMarketClient as Gamma\nfrom agents.polymarket.polymarket import Polymarket\n\n\nclass Creator:\n    def __init__(self):\n        self.polymarket = Polymarket()\n        self.gamma = Gamma()\n        self.agent = Agent()\n\n    def one_best_market(self):\n        \"\"\"\n\n        one_best_trade is a strategy that evaluates all events, markets, and orderbooks\n\n        leverages all available information sources accessible to the autonomous agent\n\n        then executes that trade without any human intervention\n\n        \"\"\"\n        try:\n            events = self.polymarket.get_all_tradeable_events()\n            print(f\"1. FOUND {len(events)} EVENTS\")\n\n            filtered_events = self.agent.filter_events_with_rag(events)\n            print(f\"2. FILTERED {len(filtered_events)} EVENTS\")\n\n            markets = self.agent.map_filtered_events_to_markets(filtered_events)\n            print()\n            print(f\"3. FOUND {len(markets)} MARKETS\")\n\n            print()\n            filtered_markets = self.agent.filter_markets(markets)\n            print(f\"4. FILTERED {len(filtered_markets)} MARKETS\")\n\n            best_market = self.agent.source_best_market_to_create(filtered_markets)\n            print(f\"5. IDEA FOR NEW MARKET {best_market}\")\n            return best_market\n\n        except Exception as e:\n            print(f\"Error {e} \\n \\n Retrying\")\n            self.one_best_market()\n\n    def maintain_positions(self):\n        pass\n\n    def incentive_farm(self):\n        pass\n\n\nif __name__ == \"__main__\":\n    c = Creator()\n    c.one_best_market()\n"}
{"type": "source_file", "path": "scripts/python/cli.py", "content": "import typer\nfrom devtools import pprint\nfrom dotenv import load_dotenv\nimport os\n\nfrom agents.polymarket.polymarket import Polymarket\nfrom agents.connectors.chroma import PolymarketRAG\nfrom agents.connectors.news import News\nfrom agents.application.trade import Trader\nfrom agents.application.executor import Executor\nfrom agents.application.creator import Creator\n\nload_dotenv()\n\napp = typer.Typer()\npolymarket = Polymarket()\nnewsapi_client = News()\npolymarket_rag = PolymarketRAG()\n\n\n@app.command()\ndef get_all_markets(limit: int = 5, sort_by: str = \"spread\") -> None:\n    \"\"\"\n    Query Polymarket's markets\n    \"\"\"\n    print(f\"limit: int = {limit}, sort_by: str = {sort_by}\")\n    markets = polymarket.get_all_markets()\n    markets = polymarket.filter_markets_for_trading(markets)\n    if sort_by == \"spread\":\n        markets = sorted(markets, key=lambda x: x.spread, reverse=True)\n    markets = markets[:limit]\n    pprint(markets)\n\n\n@app.command()\ndef get_relevant_news(keywords: str) -> None:\n    \"\"\"\n    Use NewsAPI to query the internet\n    \"\"\"\n    articles = newsapi_client.get_articles_for_cli_keywords(keywords)\n    pprint(articles)\n\n\n@app.command()\ndef get_all_events(limit: int = 5, sort_by: str = \"number_of_markets\") -> None:\n    \"\"\"\n    Query Polymarket's events\n    \"\"\"\n    print(f\"limit: int = {limit}, sort_by: str = {sort_by}\")\n    events = polymarket.get_all_events()\n    events = polymarket.filter_events_for_trading(events)\n    if sort_by == \"number_of_markets\":\n        events = sorted(events, key=lambda x: len(x.markets), reverse=True)\n    events = events[:limit]\n    pprint(events)\n\n\n@app.command()\ndef create_local_markets_rag(local_directory: str) -> None:\n    \"\"\"\n    Create a local markets database for RAG\n    \"\"\"\n    polymarket_rag.create_local_markets_rag(local_directory=local_directory)\n\n\n@app.command()\ndef query_local_markets_rag(vector_db_directory: str, query: str) -> None:\n    \"\"\"\n    RAG over a local database of Polymarket's events\n    \"\"\"\n    response = polymarket_rag.query_local_markets_rag(\n        local_directory=vector_db_directory, query=query\n    )\n    pprint(response)\n\n\n@app.command()\ndef ask_superforecaster(event_title: str, market_question: str, outcome: str) -> None:\n    \"\"\"\n    Ask a superforecaster about a trade\n    \"\"\"\n    print(\n        f\"event: str = {event_title}, question: str = {market_question}, outcome (usually yes or no): str = {outcome}\"\n    )\n    executor = Executor()\n    response = executor.get_superforecast(\n        event_title=event_title, market_question=market_question, outcome=outcome\n    )\n    print(f\"Response:{response}\")\n\n\n@app.command()\ndef create_market() -> None:\n    \"\"\"\n    Format a request to create a market on Polymarket\n    \"\"\"\n    c = Creator()\n    market_description = c.one_best_market()\n    print(f\"market_description: str = {market_description}\")\n\n\n@app.command()\ndef ask_llm(user_input: str) -> None:\n    \"\"\"\n    Ask a question to the LLM and get a response.\n    \"\"\"\n    executor = Executor()\n    response = executor.get_llm_response(user_input)\n    print(f\"LLM Response: {response}\")\n\n\n@app.command()\ndef ask_polymarket_llm(user_input: str) -> None:\n    \"\"\"\n    What types of markets do you want trade?\n    \"\"\"\n    executor = Executor()\n    response = executor.get_polymarket_llm(user_input=user_input)\n    print(f\"LLM + current markets&events response: {response}\")\n\n\n@app.command()\ndef run_autonomous_trader() -> None:\n    \"\"\"\n    Let an autonomous system trade for you.\n    \"\"\"\n    trader = Trader()\n    trader.one_best_trade()\n\n\nif __name__ == \"__main__\":\n    app()\n"}
{"type": "source_file", "path": "agents/polymarket/polymarket.py", "content": "# core polymarket api\n# https://github.com/Polymarket/py-clob-client/tree/main/examples\n\nimport os\nimport pdb\nimport time\nimport ast\nimport requests\nimport json\n\nfrom dotenv import load_dotenv\n\nfrom web3 import Web3\nfrom web3.constants import MAX_INT\nfrom web3.middleware import geth_poa_middleware\n\nimport httpx\nfrom py_clob_client.client import ClobClient\nfrom py_clob_client.clob_types import ApiCreds\nfrom py_clob_client.constants import AMOY, POLYGON\nfrom py_order_utils.builders import OrderBuilder\nfrom py_order_utils.model import OrderData\nfrom py_order_utils.signer import Signer\nfrom py_clob_client.clob_types import (\n    OrderArgs,\n    MarketOrderArgs,\n    OrderType,\n    OrderBookSummary,\n)\nfrom py_clob_client.order_builder.constants import BUY\n\nfrom agents.utils.objects import SimpleMarket, SimpleEvent\nfrom colorama import Fore, Style\n\nload_dotenv()\n\n\nclass Polymarket:\n    def __init__(self):\n        load_dotenv()\n        self.dry_run = os.getenv(\"DRY_RUN\", \"false\").lower() == \"true\"\n        \n        # Configuración básica\n        self.private_key = os.getenv(\"POLYGON_WALLET_PRIVATE_KEY\")\n        self.chain_id = POLYGON\n        \n        # URLs y endpoints\n        self.clob_url = \"https://clob.polymarket.com\"\n        self.gamma_url = \"https://gamma-api.polymarket.com\"\n        self.gamma_markets_endpoint = f\"{self.gamma_url}/markets\"\n        self.gamma_events_endpoint = f\"{self.gamma_url}/events\"\n        self.polygon_rpc = \"https://polygon-rpc.com\"\n        \n        # Web3 setup\n        self.w3 = Web3(Web3.HTTPProvider(self.polygon_rpc))\n        self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)\n        \n        # Wallet setup\n        self.wallet_address = self.get_address_for_private_key()\n        print(f\"Initialized wallet: {self.wallet_address}\")\n        \n        # Contract addresses (usando checksum addresses)\n        self.exchange_address = Web3.to_checksum_address(\"0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e\")\n        self.neg_risk_exchange_address = Web3.to_checksum_address(\"0xC5d563A36AE78145C45a50134d48A1215220f80a\")\n        self.usdc_address = Web3.to_checksum_address(\"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\")  # USDC en Polygon\n        \n        # USDC contract setup\n        self.usdc_abi = '''[\n            {\n                \"constant\": true,\n                \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}],\n                \"name\": \"balanceOf\",\n                \"outputs\": [{\"name\": \"balance\", \"type\": \"uint256\"}],\n                \"type\": \"function\"\n            },\n            {\n                \"constant\": false,\n                \"inputs\": [{\"name\": \"_spender\", \"type\": \"address\"},{\"name\": \"_value\", \"type\": \"uint256\"}],\n                \"name\": \"approve\",\n                \"outputs\": [{\"name\": \"success\", \"type\": \"bool\"}],\n                \"type\": \"function\"\n            },\n            {\n                \"constant\": true,\n                \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"},{\"name\": \"_spender\", \"type\": \"address\"}],\n                \"name\": \"allowance\",\n                \"outputs\": [{\"name\": \"remaining\", \"type\": \"uint256\"}],\n                \"type\": \"function\"\n            }\n        ]'''\n        \n        self.usdc = self.w3.eth.contract(\n            address=self.usdc_address,\n            abi=json.loads(self.usdc_abi)\n        )\n        \n        # Initialize CLOB client\n        self.client = ClobClient(\n            self.clob_url,\n            key=self.private_key,\n            chain_id=self.chain_id\n        )\n        \n        # Set API credentials\n        creds = ApiCreds(\n            api_key=os.getenv(\"CLOB_API_KEY\"),\n            api_secret=os.getenv(\"CLOB_SECRET\"),\n            api_passphrase=os.getenv(\"CLOB_PASS_PHRASE\"),\n        )\n        self.client.set_api_creds(creds)\n\n        self.erc20_approve = \"\"\"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRescuer\",\"type\":\"address\"}],\"name\":\"RescuerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APPROVE_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLACKLISTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CANCEL_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSITOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"META_TRANSACTION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESCUER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAW_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"approveWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"authorizationState\",\"outputs\":[{\"internalType\":\"enum GasAbstraction.AuthorizationState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blacklisters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decrement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"decreaseAllowanceWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"depositData\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"increment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"increaseAllowanceWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"newDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"childChainManager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescuers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"transferWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"updateMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdrawWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]\"\"\"\n        self.erc1155_set_approval = \"\"\"[{\"inputs\": [{ \"internalType\": \"address\", \"name\": \"operator\", \"type\": \"address\" },{ \"internalType\": \"bool\", \"name\": \"approved\", \"type\": \"bool\" }],\"name\": \"setApprovalForAll\",\"outputs\": [],\"stateMutability\": \"nonpayable\",\"type\": \"function\"}]\"\"\"\n\n        self.usdc_address = \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\"\n        self.ctf_address = \"0x4D97DCd97eC945f40cF65F87097ACe5EA0476045\"\n\n        self.web3 = Web3(Web3.HTTPProvider(self.polygon_rpc))\n        self.web3.middleware_onion.inject(geth_poa_middleware, layer=0)\n\n        self.usdc = self.web3.eth.contract(\n            address=self.usdc_address, abi=self.erc20_approve\n        )\n        self.ctf = self.web3.eth.contract(\n            address=self.ctf_address, abi=self.erc1155_set_approval\n        )\n\n        self._init_api_keys()\n        self._init_approvals(False)\n\n    def _init_api_keys(self) -> None:\n        self.client = ClobClient(\n            self.clob_url, key=self.private_key, chain_id=self.chain_id\n        )\n        self.credentials = self.client.create_or_derive_api_creds()\n        self.client.set_api_creds(self.credentials)\n        # print(self.credentials)\n\n    def _init_approvals(self, run: bool = False) -> None:\n        if not run:\n            return\n\n        priv_key = self.private_key\n        pub_key = self.get_address_for_private_key()\n        chain_id = self.chain_id\n        web3 = self.web3\n        nonce = web3.eth.get_transaction_count(pub_key)\n        usdc = self.usdc\n        ctf = self.ctf\n\n        # CTF Exchange\n        raw_usdc_approve_txn = usdc.functions.approve(\n            \"0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E\", int(MAX_INT, 0)\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_usdc_approve_tx = web3.eth.account.sign_transaction(\n            raw_usdc_approve_txn, private_key=priv_key\n        )\n        send_usdc_approve_tx = web3.eth.send_raw_transaction(\n            signed_usdc_approve_tx.raw_transaction\n        )\n        usdc_approve_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_usdc_approve_tx, 600\n        )\n        print(usdc_approve_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        raw_ctf_approval_txn = ctf.functions.setApprovalForAll(\n            \"0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E\", True\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_ctf_approval_tx = web3.eth.account.sign_transaction(\n            raw_ctf_approval_txn, private_key=priv_key\n        )\n        send_ctf_approval_tx = web3.eth.send_raw_transaction(\n            signed_ctf_approval_tx.raw_transaction\n        )\n        ctf_approval_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_ctf_approval_tx, 600\n        )\n        print(ctf_approval_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        # Neg Risk CTF Exchange\n        raw_usdc_approve_txn = usdc.functions.approve(\n            \"0xC5d563A36AE78145C45a50134d48A1215220f80a\", int(MAX_INT, 0)\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_usdc_approve_tx = web3.eth.account.sign_transaction(\n            raw_usdc_approve_txn, private_key=priv_key\n        )\n        send_usdc_approve_tx = web3.eth.send_raw_transaction(\n            signed_usdc_approve_tx.raw_transaction\n        )\n        usdc_approve_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_usdc_approve_tx, 600\n        )\n        print(usdc_approve_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        raw_ctf_approval_txn = ctf.functions.setApprovalForAll(\n            \"0xC5d563A36AE78145C45a50134d48A1215220f80a\", True\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_ctf_approval_tx = web3.eth.account.sign_transaction(\n            raw_ctf_approval_txn, private_key=priv_key\n        )\n        send_ctf_approval_tx = web3.eth.send_raw_transaction(\n            signed_ctf_approval_tx.raw_transaction\n        )\n        ctf_approval_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_ctf_approval_tx, 600\n        )\n        print(ctf_approval_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        # Neg Risk Adapter\n        raw_usdc_approve_txn = usdc.functions.approve(\n            \"0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296\", int(MAX_INT, 0)\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_usdc_approve_tx = web3.eth.account.sign_transaction(\n            raw_usdc_approve_txn, private_key=priv_key\n        )\n        send_usdc_approve_tx = web3.eth.send_raw_transaction(\n            signed_usdc_approve_tx.raw_transaction\n        )\n        usdc_approve_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_usdc_approve_tx, 600\n        )\n        print(usdc_approve_tx_receipt)\n\n        nonce = web3.eth.get_transaction_count(pub_key)\n\n        raw_ctf_approval_txn = ctf.functions.setApprovalForAll(\n            \"0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296\", True\n        ).build_transaction({\"chainId\": chain_id, \"from\": pub_key, \"nonce\": nonce})\n        signed_ctf_approval_tx = web3.eth.account.sign_transaction(\n            raw_ctf_approval_txn, private_key=priv_key\n        )\n        send_ctf_approval_tx = web3.eth.send_raw_transaction(\n            signed_ctf_approval_tx.raw_transaction\n        )\n        ctf_approval_tx_receipt = web3.eth.wait_for_transaction_receipt(\n            send_ctf_approval_tx, 600\n        )\n        print(ctf_approval_tx_receipt)\n\n    def get_all_markets(self) -> \"list[SimpleMarket]\":\n        markets = []\n        res = httpx.get(self.gamma_markets_endpoint)\n        if res.status_code == 200:\n            for market in res.json():\n                try:\n                    market_data = self.map_api_to_market(market)\n                    markets.append(SimpleMarket(**market_data))\n                except Exception as e:\n                    print(e)\n                    pass\n        return markets\n\n    def filter_markets_for_trading(self, markets: \"list[SimpleMarket]\"):\n        tradeable_markets = []\n        for market in markets:\n            if market.active:\n                tradeable_markets.append(market)\n        return tradeable_markets\n\n    def get_market(self, token_id: str) -> SimpleMarket:\n        params = {\"clob_token_ids\": token_id}\n        res = httpx.get(self.gamma_markets_endpoint, params=params)\n        if res.status_code == 200:\n            data = res.json()\n            market = data[0]\n            return self.map_api_to_market(market, token_id)\n\n    def map_api_to_market(self, market, token_id: str = \"\") -> SimpleMarket:\n        market = {\n            \"id\": int(market[\"id\"]),\n            \"question\": market[\"question\"],\n            \"end\": market[\"endDate\"],\n            \"description\": market[\"description\"],\n            \"active\": market[\"active\"],\n            # \"deployed\": market[\"deployed\"],\n            \"funded\": market[\"funded\"],\n            \"rewardsMinSize\": float(market[\"rewardsMinSize\"]),\n            \"rewardsMaxSpread\": float(market[\"rewardsMaxSpread\"]),\n            # \"volume\": float(market[\"volume\"]),\n            \"spread\": float(market[\"spread\"]),\n            \"outcomes\": str(market[\"outcomes\"]),\n            \"outcome_prices\": str(market[\"outcomePrices\"]),\n            \"clob_token_ids\": str(market[\"clobTokenIds\"]),\n        }\n        if token_id:\n            market[\"clob_token_ids\"] = token_id\n        return market\n\n    def get_all_events(self) -> \"list[SimpleEvent]\":\n        \"\"\"Get all events from Gamma API\"\"\"\n        try:\n            params = {\n                \"active\": \"true\",\n                \"closed\": \"false\",\n                \"archived\": \"false\",\n                \"limit\": \"100\",\n                \"order\": \"volume\",\n                \"ascending\": \"false\"\n            }\n            \n            res = httpx.get(\n                f\"{self.gamma_url}/markets\",\n                params=params,\n                headers={\n                    \"Accept\": \"application/json\",\n                    \"User-Agent\": \"Mozilla/5.0\"\n                },\n                timeout=30.0\n            )\n            \n            if res.status_code == 200:\n                markets = res.json()\n                if markets:\n                    events = []\n                    for market in markets:\n                        if float(market.get(\"volume\", 0)) > 10000:\n                            event_data = {\n                                \"id\": str(market.get(\"id\")),\n                                \"title\": market.get(\"question\", \"\"),\n                                \"description\": market.get(\"description\", \"\"),\n                                \"markets\": str(market.get(\"id\", \"\")),\n                                \"metadata\": {\n                                    \"question\": market.get(\"question\", \"\"),\n                                    \"markets\": str(market.get(\"id\", \"\")),\n                                    \"volume\": float(market.get(\"volume\", 0)),\n                                    \"featured\": market.get(\"featured\", False),\n                                    \"outcome_prices\": market.get(\"outcomePrices\", \"[]\"),\n                                    \"outcomes\": market.get(\"outcomes\", \"[]\")\n                                }\n                            }\n                            events.append(SimpleEvent(**event_data))\n                    \n                    print(f\"\\nTop mercados por volumen total:\")\n                    for market in markets[:5]:\n                        print(f\"- {market.get('question')}: ${float(market.get('volume', 0)):,.2f}\")\n                    \n                    return events\n                \n            return []\n        except Exception as e:\n            print(f\"Error getting events: {e}\")\n            return []\n\n    def get_all_tradeable_events(self) -> \"list[SimpleEvent]\":\n        try:\n            params = {\n                \"active\": \"true\",\n                \"closed\": \"false\",\n                \"archived\": \"false\",\n                \"limit\": \"100\",\n                \"order\": \"volume\",\n                \"ascending\": \"false\"\n            }\n            \n            res = httpx.get(\n                f\"{self.gamma_url}/markets\",\n                params=params,\n                headers={\n                    \"Accept\": \"application/json\",\n                    \"User-Agent\": \"Mozilla/5.0\"\n                },\n                timeout=30.0\n            )\n            \n            if res.status_code == 200:\n                markets = res.json()\n                if markets:\n                    events = []\n                    for market in markets:\n                        # Solo considerar mercados con volumen significativo\n                        if float(market.get(\"volume\", 0)) > 10000:\n                            event_data = {\n                                \"id\": str(market.get(\"id\")),  # Convertir a string\n                                \"title\": market.get(\"question\", \"\"),\n                                \"description\": market.get(\"description\", \"\"),\n                                \"markets\": str(market.get(\"id\", \"\")),\n                                \"metadata\": {\n                                    \"question\": market.get(\"question\", \"\"),\n                                    \"markets\": str(market.get(\"id\", \"\")),\n                                    \"volume\": float(market.get(\"volume\", 0)),\n                                    \"featured\": market.get(\"featured\", False),\n                                    \"outcome_prices\": market.get(\"outcomePrices\", \"[]\"),\n                                    \"outcomes\": market.get(\"outcome\", \"[]\")\n                                }\n                            }\n                            event = SimpleEvent(**event_data)\n                            events.append(event)\n                    \n                    print(f\"\\nTop mercados por volumen total:\")\n                    for market in markets[:5]:\n                        print(f\"- {market.get('question')}: ${float(market.get('volume', 0)):,.2f}\")\n                    \n                    return events\n            return []\n        except Exception as e:\n            print(f\"{Fore.RED}Error getting events: {str(e)}{Style.RESET_ALL}\")\n            return []\n\n    def get_sampling_simplified_markets(self) -> \"list[SimpleEvent]\":\n        markets = []\n        raw_sampling_simplified_markets = self.client.get_sampling_simplified_markets()\n        for raw_market in raw_sampling_simplified_markets[\"data\"]:\n            token_one_id = raw_market[\"tokens\"][0][\"token_id\"]\n            market = self.get_market(token_one_id)\n            markets.append(market)\n        return markets\n\n    def get_orderbook(self, token_id: str) -> OrderBookSummary:\n        return self.client.get_order_book(token_id)\n\n    def get_orderbook_price(self, token_id: str) -> float:\n        return float(self.client.get_price(token_id))\n\n    def get_address_for_private_key(self):\n        account = self.w3.eth.account.from_key(str(self.private_key))\n        return account.address\n\n    def build_order(\n        self,\n        market_token: str,\n        amount: float,\n        nonce: str = str(round(time.time())),  # for cancellations\n        side: str = \"BUY\",\n        expiration: str = \"0\",  # timestamp after which order expires\n    ):\n        signer = Signer(self.private_key)\n        builder = OrderBuilder(self.exchange_address, self.chain_id, signer)\n\n        buy = side == \"BUY\"\n        side = 0 if buy else 1\n        maker_amount = amount if buy else 0\n        taker_amount = amount if not buy else 0\n        order_data = OrderData(\n            maker=self.get_address_for_private_key(),\n            tokenId=market_token,\n            makerAmount=maker_amount,\n            takerAmount=taker_amount,\n            feeRateBps=\"1\",\n            nonce=nonce,\n            side=side,\n            expiration=expiration,\n        )\n        order = builder.build_signed_order(order_data)\n        return order\n\n    def execute_order(self, price, size, side, token_id) -> str:\n        return self.client.create_and_post_order(\n            OrderArgs(price=price, size=size, side=side, token_id=token_id)\n        )\n\n    def get_token_balance(self, token_id: str) -> float:\n        \"\"\"Get balance of a specific outcome token\"\"\"\n        try:\n            # ERC1155 balance ABI\n            erc1155_abi = '''[{\n                \"inputs\": [\n                    {\"internalType\": \"address\", \"name\": \"account\", \"type\": \"address\"},\n                    {\"internalType\": \"uint256\", \"name\": \"id\", \"type\": \"uint256\"}\n                ],\n                \"name\": \"balanceOf\",\n                \"outputs\": [{\"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"}],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n            }]'''\n            \n            # CTF token contract address\n            ctf_address = Web3.to_checksum_address(\"0x4D97DCd97eC945f40cF65F87097ACe5EA0476045\")\n            \n            # Create contract\n            ctf = self.w3.eth.contract(address=ctf_address, abi=erc1155_abi)\n            \n            # Get balance\n            balance = ctf.functions.balanceOf(self.wallet_address, int(token_id)).call()\n            return float(balance)\n            \n        except Exception as e:\n            print(f\"Error getting token balance: {e}\")\n            return 0.0\n\n    def execute_market_order(self, market, amount):\n        try:\n            # Obtener datos del mercado usando los atributos correctos\n            token_ids = ast.literal_eval(market.clob_token_ids)  # Usar el atributo directamente\n            \n            # Si el trade dice SELL -> compramos NO\n            # Si el trade dice BUY -> compramos YES\n            if hasattr(market, 'trade') and market.trade.get('side') == \"SELL\":\n                token_id = token_ids[0]  # Token NO\n                position = \"NO\"\n            else:\n                token_id = token_ids[1]  # Token YES\n                position = \"YES\"\n            \n            # Verificar si ya tenemos una posición\n            current_balance = self.get_token_balance(token_id)\n            if current_balance > 0:\n                print(f\"Already have position in this market: {current_balance} {position} tokens\")\n                return None\n            \n            # Obtener el precio actual del mercado\n            market_price_resp = self.client.get_price(token_id, \"SELL\")\n            market_price = float(market_price_resp.get(\"price\", 0))\n            print(f\"Current market price for {position}: ${market_price}\")\n            \n            # Obtener el orderbook para ver las órdenes disponibles\n            orderbook = self.client.get_order_book(token_id)\n            \n            # Calcular el tamaño mínimo requerido en tokens\n            min_size = 5.0  # Tamaño mínimo en tokens\n            min_cost = min_size * market_price  # Costo mínimo en USDC\n            \n            print(f\"Creating order for {position} position:\")\n            print(f\"Token ID: {token_id}\")\n            print(f\"Market price: ${market_price}\")\n            print(f\"Minimum size: {min_size} tokens\")\n            print(f\"Minimum cost: ${min_cost:.4f} USDC\")\n            \n            # Crear orden usando OrderArgs\n            order_args = OrderArgs(\n                token_id=token_id,\n                size=min_size,\n                price=market_price,\n                side=BUY  # Siempre compramos (YES o NO)\n            )\n            \n            # Crear y firmar la orden\n            signed_order = self.client.create_order(order_args)\n            print(\"Signed order created:\", signed_order)\n            \n            # Postear la orden\n            resp = self.client.post_order(signed_order)\n            print(\"Order response:\", resp)\n            print(\"Done!\")\n            \n            if self.dry_run:\n                print(f\"\\n{Fore.GREEN}🔍 DRY RUN: Order would be executed with these parameters:{Style.RESET_ALL}\")\n                print(f\"   Token ID: {token_id}\")\n                print(f\"   Position: {position}\")\n                print(f\"   Size: {min_size} tokens\")\n                print(f\"   Price: ${market_price}\")\n                print(f\"   Total Cost: ${min_cost:.4f} USDC\")\n                return {\"status\": \"simulated\", \"dry_run\": True}\n                \n            return resp\n            \n        except Exception as e:\n            print(f\"Error executing market order: {e}\")\n            print(f\"Full error details: {str(e)}\")\n            return None\n\n    def check_usdc_allowance(self) -> float:\n        \"\"\"Check how much USDC we've approved for spending\"\"\"\n        try:\n            allowance = self.usdc.functions.allowance(\n                Web3.to_checksum_address(self.wallet_address),\n                Web3.to_checksum_address(self.exchange_address)\n            ).call()\n            return float(allowance) / 1_000_000  # Convertir de wei a USDC\n        except Exception as e:\n            print(f\"Error checking allowance: {e}\")\n            return 0.0\n\n    def approve_usdc_spend(self, amount: float):\n        \"\"\"Approve USDC spending\"\"\"\n        try:\n            # Convertir el monto a la unidad correcta (6 decimales para USDC)\n            amount_wei = int(amount * 1_000_000)  # Convertir a unidades USDC\n            \n            # Convertir direcciones a checksum\n            exchange_address = Web3.to_checksum_address(self.exchange_address)\n            wallet_address = Web3.to_checksum_address(self.wallet_address)\n            \n            print(f\"Approving {amount} USDC ({amount_wei} wei) for {exchange_address}\")\n            \n            # Construir la transacción de aprobación usando el contrato directamente\n            approve_txn = self.usdc.functions.approve(\n                exchange_address,\n                amount_wei\n            ).build_transaction({\n                'from': wallet_address,\n                'nonce': self.w3.eth.get_transaction_count(wallet_address),\n                'gas': 100000,\n                'gasPrice': self.w3.eth.gas_price,\n                'chainId': self.chain_id\n            })\n            \n            # Firmar la transacción\n            signed_txn = self.w3.eth.account.sign_transaction(approve_txn, private_key=self.private_key)\n            \n            # Enviar la transacción - usar raw_transaction en lugar de rawTransaction\n            tx_hash = self.w3.eth.send_raw_transaction(signed_txn.raw_transaction)\n            print(f\"Approval transaction sent: {tx_hash.hex()}\")\n            \n            # Esperar a que se confirme\n            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)\n            print(f\"Approval confirmed in block: {receipt['blockNumber']}\")\n            \n            # Verificar el nuevo allowance\n            new_allowance = self.check_usdc_allowance()\n            print(f\"New allowance: ${new_allowance}\")\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Error approving USDC: {e}\")\n            print(f\"Full error details: {str(e)}\")\n            import traceback\n            print(f\"Stack trace: {traceback.format_exc()}\")\n            return False\n\n    def get_usdc_balance(self) -> float:\n        \"\"\"Get USDC balance for the current wallet\"\"\"\n        try:\n            # Verificar que la wallet está configurada\n            if not self.wallet_address:\n                print(\"Wallet address not configured\")\n                return 0.0\n                \n            # Obtener balance\n            balance_res = self.usdc.functions.balanceOf(self.wallet_address).call()\n            balance = float(balance_res) / 1_000_000  # USDC tiene 6 decimales\n            \n            print(f\"Raw balance: {balance_res}\")\n            print(f\"Wallet: {self.wallet_address}\")\n            print(f\"USDC Contract: {self.usdc_address}\")\n            \n            return balance\n            \n        except Exception as e:\n            print(f\"Error getting USDC balance: {e}\")\n            print(f\"Wallet: {self.wallet_address}\")\n            return 0.0\n\n    def get_outcome_token_balance(self, token_id: str) -> float:\n        \"\"\"Get outcome token balance for the current wallet\"\"\"\n        try:\n            # TODO: Implementar verificación de balance de tokens outcome usando el contrato ERC1155\n            return 0.0\n        except Exception as e:\n            print(f\"Error getting outcome token balance: {e}\")\n            return 0.0\n\n    def check_outcome_token_allowance(self, token_id: str) -> float:\n        \"\"\"Check outcome token allowance\"\"\"\n        try:\n            # TODO: Implementar verificación de allowance de tokens outcome\n            return 0.0\n        except Exception as e:\n            print(f\"Error checking outcome token allowance: {e}\")\n            return 0.0\n\n    def approve_outcome_token_spend(self, token_id: str, amount: float):\n        \"\"\"Approve outcome token spending\"\"\"\n        try:\n            # TODO: Implementar aprobación de gasto de tokens outcome\n            return False\n        except Exception as e:\n            print(f\"Error approving outcome token spend: {e}\")\n            return False\n\n    def set_all_allowances(self):\n        \"\"\"Set all necessary allowances for trading\"\"\"\n        try:\n            print(\"Setting allowances for all contracts...\")\n            \n            # Addresses\n            ctf_address = Web3.to_checksum_address(\"0x4D97DCd97eC945f40cF65F87097ACe5EA0476045\")\n            exchange_address = Web3.to_checksum_address(\"0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E\")\n            neg_risk_exchange = Web3.to_checksum_address(\"0xC5d563A36AE78145C45a50134d48A1215220f80a\")\n            neg_risk_adapter = Web3.to_checksum_address(\"0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296\")\n            \n            # ERC1155 approval ABI\n            erc1155_abi = '''[{\n                \"inputs\": [\n                    {\"internalType\": \"address\", \"name\": \"operator\", \"type\": \"address\"},\n                    {\"internalType\": \"bool\", \"name\": \"approved\", \"type\": \"bool\"}\n                ],\n                \"name\": \"setApprovalForAll\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n            }]'''\n            \n            # Create CTF contract\n            ctf = self.w3.eth.contract(address=ctf_address, abi=erc1155_abi)\n            \n            # Get current nonce\n            nonce = self.w3.eth.get_transaction_count(self.wallet_address)\n            \n            # Approve USDC for all contracts\n            for contract in [exchange_address, neg_risk_exchange, neg_risk_adapter]:\n                print(f\"\\nApproving USDC for {contract}...\")\n                \n                # Build USDC approval transaction\n                approve_txn = self.usdc.functions.approve(\n                    contract,\n                    int(MAX_INT, 0)  # Approve maximum amount\n                ).build_transaction({\n                    'chainId': self.chain_id,\n                    'from': self.wallet_address,\n                    'nonce': nonce,\n                    'gas': 100000,\n                    'gasPrice': self.w3.eth.gas_price\n                })\n                \n                # Sign and send transaction\n                signed_txn = self.w3.eth.account.sign_transaction(approve_txn, private_key=self.private_key)\n                tx_hash = self.w3.eth.send_raw_transaction(signed_txn.raw_transaction)\n                receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)\n                print(f\"USDC approval confirmed in block {receipt['blockNumber']}\")\n                \n                nonce += 1\n                \n                # Approve CTF tokens\n                print(f\"Approving CTF tokens for {contract}...\")\n                ctf_txn = ctf.functions.setApprovalForAll(\n                    contract,\n                    True\n                ).build_transaction({\n                    'chainId': self.chain_id,\n                    'from': self.wallet_address,\n                    'nonce': nonce,\n                    'gas': 100000,\n                    'gasPrice': self.w3.eth.gas_price\n                })\n                \n                # Sign and send transaction\n                signed_txn = self.w3.eth.account.sign_transaction(ctf_txn, private_key=self.private_key)\n                tx_hash = self.w3.eth.send_raw_transaction(signed_txn.raw_transaction)\n                receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)\n                print(f\"CTF approval confirmed in block {receipt['blockNumber']}\")\n                \n                nonce += 1\n            \n            print(\"\\nAll allowances set successfully!\")\n            return True\n            \n        except Exception as e:\n            print(f\"Error setting allowances: {e}\")\n            return False\n\n    def get_pinned_markets(self) -> \"list[SimpleEvent]\":\n        \"\"\"Get pinned markets from Gamma API\"\"\"\n        try:\n            # Obtener mercados pinned usando el endpoint específico o un filtro\n            params = {\n                \"pinned\": True,\n                \"active\": True,\n                \"closed\": False\n            }\n            response = httpx.get(self.gamma_markets_endpoint, params=params)\n            if response.status_code == 200:\n                markets = response.json()\n                return [SimpleEvent(**market) for market in markets]\n            return []\n        except Exception as e:\n            print(f\"Error getting pinned markets: {e}\")\n            return []\n\n    def get_high_volume_markets(self, min_volume: float = 10000) -> \"list[SimpleEvent]\":\n        \"\"\"Get markets with volume above threshold\"\"\"\n        events = self.get_all_events()\n        return [\n            event for event in events \n            if event.active and not event.closed \n            and float(event.volume) > min_volume\n        ]\n\n    def detect_category(self, question: str) -> str:\n        \"\"\"Detecta la categoría de un mercado basado en su pregunta\"\"\"\n        question = question.lower()\n        \n        # Keywords para cada categoría\n        politics_keywords = ['election', 'president', 'vote', 'congress', 'senate', 'minister', 'government', 'fed', 'rate', 'chancellor', 'prime minister']\n        sports_keywords = ['nba', 'nfl', 'mlb', 'soccer', 'football', 'basketball', 'baseball', 'league', 'cup', 'championship', 'win', 'relegated']\n        crypto_keywords = ['bitcoin', 'eth', 'crypto', 'token', 'blockchain', 'opensea', 'nft']\n        entertainment_keywords = ['movie', 'film', 'actor', 'actress', 'award', 'song', 'album', 'show']\n        tech_keywords = ['ai', 'openai', 'technology', 'software', 'app', 'launch']\n        \n        if any(keyword in question for keyword in politics_keywords):\n            return 'politics'\n        elif any(keyword in question for keyword in sports_keywords):\n            return 'sports'\n        elif any(keyword in question for keyword in crypto_keywords):\n            return 'crypto'\n        elif any(keyword in question for keyword in entertainment_keywords):\n            return 'entertainment'\n        elif any(keyword in question for keyword in tech_keywords):\n            return 'tech'\n        else:\n            return 'other'\n\n\ndef test():\n    host = \"https://clob.polymarket.com\"\n    key = os.getenv(\"POLYGON_WALLET_PRIVATE_KEY\")\n    print(key)\n    chain_id = POLYGON\n\n    # Create CLOB client and get/set API credentials\n    client = ClobClient(host, key=key, chain_id=chain_id)\n    client.set_api_creds(client.create_or_derive_api_creds())\n\n    creds = ApiCreds(\n        api_key=os.getenv(\"CLOB_API_KEY\"),\n        api_secret=os.getenv(\"CLOB_SECRET\"),\n        api_passphrase=os.getenv(\"CLOB_PASS_PHRASE\"),\n    )\n    chain_id = AMOY\n    client = ClobClient(host, key=key, chain_id=chain_id, creds=creds)\n\n    print(client.get_markets())\n    print(client.get_simplified_markets())\n    print(client.get_sampling_markets())\n    print(client.get_sampling_simplified_markets())\n    print(client.get_market(\"condition_id\"))\n\n    print(\"Done!\")\n\n\ndef gamma():\n    url = \"https://gamma-com\"\n    markets_url = url + \"/markets\"\n    res = httpx.get(markets_url)\n    code = res.status_code\n    if code == 200:\n        markets: list[SimpleMarket] = []\n        data = res.json()\n        for market in data:\n            try:\n                market_data = {\n                    \"id\": int(market[\"id\"]),\n                    \"question\": market[\"question\"],\n                    # \"start\": market['startDate'],\n                    \"end\": market[\"endDate\"],\n                    \"description\": market[\"description\"],\n                    \"active\": market[\"active\"],\n                    \"deployed\": market[\"deployed\"],\n                    \"funded\": market[\"funded\"],\n                    # \"orderMinSize\": float(market['orderMinSize']) if market['orderMinSize'] else 0,\n                    # \"orderPriceMinTickSize\": float(market['orderPriceMinTickSize']),\n                    \"rewardsMinSize\": float(market[\"rewardsMinSize\"]),\n                    \"rewardsMaxSpread\": float(market[\"rewardsMaxSpread\"]),\n                    \"volume\": float(market[\"volume\"]),\n                    \"spread\": float(market[\"spread\"]),\n                    \"outcome_a\": str(market[\"outcomes\"][0]),\n                    \"outcome_b\": str(market[\"outcomes\"][1]),\n                    \"outcome_a_price\": str(market[\"outcomePrices\"][0]),\n                    \"outcome_b_price\": str(market[\"outcomePrices\"][1]),\n                }\n                markets.append(SimpleMarket(**market_data))\n            except Exception as err:\n                print(f\"error {err} for market {id}\")\n        pdb.set_trace()\n    else:\n        raise Exception()\n\n\ndef main():\n    # auth()\n    # test()\n    # gamma()\n    print(Polymarket().get_all_events())\n\n\nif __name__ == \"__main__\":\n    load_dotenv()\n\n    p = Polymarket()\n\n    # k = p.get_api_key()\n    # m = p.get_sampling_simplified_markets()\n\n    # print(m)\n    # m = p.get_market('11015470973684177829729219287262166995141465048508201953575582100565462316088')\n\n    # t = m[0]['token_id']\n    # o = p.get_orderbook(t)\n    # pdb.set_trace()\n\n    \"\"\"\n    \n    (Pdb) pprint(o)\n            OrderBookSummary(\n                market='0x26ee82bee2493a302d21283cb578f7e2fff2dd15743854f53034d12420863b55', \n                asset_id='11015470973684177829729219287262166995141465048508201953575582100565462316088', \n                bids=[OrderSummary(price='0.01', size='600005'), OrderSummary(price='0.02', size='200000'), ...\n                asks=[OrderSummary(price='0.99', size='100000'), OrderSummary(price='0.98', size='200000'), ...\n            )\n    \n    \"\"\"\n\n    # https://polygon-rpc.com\n\n    test_market_token_id = (\n        \"101669189743438912873361127612589311253202068943959811456820079057046819967115\"\n    )\n    test_market_data = p.get_market(test_market_token_id)\n\n    # test_size = 0.0001\n    test_size = 1\n    test_side = BUY\n    test_price = float(ast.literal_eval(test_market_data[\"outcome_prices\"])[0])\n\n    # order = p.execute_order(\n    #    test_price,\n    #    test_size,\n    #    test_side,\n    #    test_market_token_id,\n    # )\n\n    # order = p.execute_market_order(test_price, test_market_token_id)\n\n    balance = p.get_usdc_balance()\n"}
{"type": "source_file", "path": "agents/application/prompts.py", "content": "from typing import List\nfrom datetime import datetime\n\n\nclass Prompter:\n\n    def generate_simple_ai_trader(market_description: str, relevant_info: str) -> str:\n        return f\"\"\"\n            \n        You are a prediction market trader.\n        \n        Here is a market description: {market_description}.\n\n        Here is relevant information: {relevant_info}.\n\n        Do you buy or sell? How much?\n        \"\"\"\n\n    def market_analyst(self) -> str:\n        return f\"\"\"\n        You are a market analyst that takes a description of an event and produces a market forecast. \n        Assign a probability estimate to the event occurring described by the user\n        \"\"\"\n\n    def sentiment_analyzer(self, question: str, outcome: str) -> float:\n        return f\"\"\"\n        You are a political scientist trained in media analysis. \n        You are given a question: {question}.\n        and an outcome of yes or no: {outcome}.\n        \n        You are able to review a news article or text and\n        assign a sentiment score between 0 and 1. \n        \n        \"\"\"\n\n    def prompts_polymarket(\n        self, data1: str, data2: str, market_question: str, outcome: str\n    ) -> str:\n        current_market_data = str(data1)\n        current_event_data = str(data2)\n        return f\"\"\"\n        You are an AI assistant for users of a prediction market called Polymarket.\n        Users want to place bets based on their beliefs of market outcomes such as political or sports events.\n        \n        Here is data for current Polymarket markets {current_market_data} and \n        current Polymarket events {current_event_data}.\n\n        Help users identify markets to trade based on their interests or queries.\n        Provide specific information for markets including probabilities of outcomes.\n        Give your response in the following format:\n\n        I believe {market_question} has a likelihood {float} for outcome of {outcome}.\n        \"\"\"\n\n    def prompts_polymarket(self, data1: str, data2: str) -> str:\n        current_market_data = str(data1)\n        current_event_data = str(data2)\n        return f\"\"\"\n        You are an AI assistant for users of a prediction market called Polymarket.\n        Users want to place bets based on their beliefs of market outcomes such as political or sports events.\n\n        Here is data for current Polymarket markets {current_market_data} and \n        current Polymarket events {current_event_data}.\n        Help users identify markets to trade based on their interests or queries.\n        Provide specific information for markets including probabilities of outcomes.\n        \"\"\"\n\n    def routing(self, system_message: str) -> str:\n        return f\"\"\"You are an expert at routing a user question to the appropriate data source. System message: ${system_message}\"\"\"\n\n    def multiquery(self, question: str) -> str:\n        return f\"\"\"\n        You're an AI assistant. Your task is to generate five different versions\n        of the given user question to retreive relevant documents from a vector database. By generating\n        multiple perspectives on the user question, your goal is to help the user overcome some of the limitations\n        of the distance-based similarity search.\n        Provide these alternative questions separated by newlines. Original question: {question}\n\n        \"\"\"\n\n    def read_polymarket(self) -> str:\n        return f\"\"\"\n        You are an prediction market analyst.\n        \"\"\"\n\n    def polymarket_analyst_api(self) -> str:\n        return f\"\"\"You are an AI assistant for analyzing prediction markets.\n                You will be provided with json output for api data from Polymarket.\n                Polymarket is an online prediction market that lets users Bet on the outcome of future events in a wide range of topics, like sports, politics, and pop culture. \n                Get accurate real-time probabilities of the events that matter most to you. \"\"\"\n\n    def filter_events(self) -> str:\n        return (\n            self.polymarket_analyst_api()\n            + f\"\"\"\n        \n        Filter these events for the ones you will be best at trading on profitably.\n\n        \"\"\"\n        )\n\n    def filter_markets(self) -> str:\n        return (\n            self.polymarket_analyst_api()\n            + f\"\"\"\n        \n        Filter these markets for the ones you will be best at trading on profitably.\n\n        \"\"\"\n        )\n\n    def superforecaster(self, question: str, description: str, outcome: str) -> str:\n        return f\"\"\"\n        You are a Superforecaster tasked with analyzing and predicting market outcomes.\n        \n        MARKET QUESTION: {question}\n        DESCRIPTION: {description}\n        CURRENT PRICES: {outcome}\n        \n        IMPORTANT GUIDELINES:\n        1. Focus on EDGE - identify discrepancies between market prices and true probabilities\n        2. Consider TIME HORIZON - how long until market resolution\n        3. Look for CATALYSTS - upcoming events that could impact outcome\n        4. Evaluate MARKET SENTIMENT - are prices driven by emotion/bias?\n        \n        Analysis Framework:\n\n        1. Market Context (2-3 sentences):\n           - Core question/prediction\n           - Time horizon\n           - Key stakeholders\n\n        2. Price Analysis (2-3 points):\n           - Current market implied probabilities\n           - Historical price context if relevant\n           - Identify any pricing inefficiencies\n\n        3. Key Factors (3-4 points):\n           - Upcoming catalysts/events\n           - Historical precedents\n           - Structural considerations\n           - Potential risks\n\n        4. Edge Assessment:\n           - Calculate expected value\n           - Identify market mispricing if any\n           - Confidence level (high/medium/low)\n\n        Your response MUST follow this format:\n\n        ANALYSIS:\n        [Concise analysis following the framework above]\n\n        CONCLUSION:\n        I believe {question} has a likelihood of [EXACT_PROBABILITY] for outcome of [YES/NO].\n        EDGE: [Describe specific edge vs market price]\n        CONFIDENCE: [HIGH/MEDIUM/LOW]\n        CATALYSTS: [Key upcoming events]\n\n        RULES:\n        - Probability MUST be between 0-1 (e.g., 0.75)\n        - MUST identify specific edge vs market price\n        - MUST provide concrete catalysts/timeline\n        - NO hedging language (\"maybe\", \"possibly\", etc.)\n        - BE DECISIVE - commit to a clear position\n        \"\"\"\n\n    def one_best_trade(\n        self,\n        prediction: str,\n        outcomes: List[str],\n        outcome_prices: str,\n    ) -> str:\n        return (\n            self.polymarket_analyst_api()\n            + f\"\"\"\n        \n                Imagine yourself as the top trader on Polymarket, dominating the world of information markets with your keen insights and strategic acumen. You have an extraordinary ability to analyze and interpret data from diverse sources, turning complex information into profitable trading opportunities.\n                You excel in predicting the outcomes of global events, from political elections to economic developments, using a combination of data analysis and intuition. Your deep understanding of probability and statistics allows you to assess market sentiment and make informed decisions quickly.\n                Every day, you approach Polymarket with a disciplined strategy, identifying undervalued opportunities and managing your portfolio with precision. You are adept at evaluating the credibility of information and filtering out noise, ensuring that your trades are based on reliable data.\n                Your adaptability is your greatest asset, enabling you to thrive in a rapidly changing environment. You leverage cutting-edge technology and tools to gain an edge over other traders, constantly seeking innovative ways to enhance your strategies.\n                In your journey on Polymarket, you are committed to continuous learning, staying informed about the latest trends and developments in various sectors. Your emotional intelligence empowers you to remain composed under pressure, making rational decisions even when the stakes are high.\n                Visualize yourself consistently achieving outstanding returns, earning recognition as the top trader on Polymarket. You inspire others with your success, setting new standards of excellence in the world of information markets.\n\n        \"\"\"\n            + f\"\"\"\n        \n        You made the following prediction for a market: {prediction}\n\n        The current outcomes ${outcomes} prices are: ${outcome_prices}\n\n        Given your prediction, respond with a genius trade in the format:\n        `\n            price:'price_on_the_orderbook',\n            size:'percentage_of_total_funds',\n            side: BUY or SELL,\n        `\n\n        Your trade should approximate price using the likelihood in your prediction.\n\n        Example response:\n\n        RESPONSE```\n            price:0.5,\n            size:0.1,\n            side:BUY,\n        ```\n        \n        \"\"\"\n        )\n\n    def format_price_from_one_best_trade_output(self, output: str) -> str:\n        return f\"\"\"\n        \n        You will be given an input such as:\n    \n        `\n            price:0.5,\n            size:0.1,\n            side:BUY,\n        `\n\n        Please extract only the value associated with price.\n        In this case, you would return \"0.5\".\n\n        Only return the number after price:\n        \n        \"\"\"\n\n    def format_size_from_one_best_trade_output(self, output: str) -> str:\n        return f\"\"\"\n        \n        You will be given an input such as:\n    \n        `\n            price:0.5,\n            size:0.1,\n            side:BUY,\n        `\n\n        Please extract only the value associated with price.\n        In this case, you would return \"0.1\".\n\n        Only return the number after size:\n        \n        \"\"\"\n\n    def create_new_market(self, filtered_markets: str) -> str:\n        return f\"\"\"\n        {filtered_markets}\n        \n        Invent an information market similar to these markets that ends in the future,\n        at least 6 months after today, which is: {datetime.today().strftime('%Y-%m-%d')},\n        so this date plus 6 months at least.\n\n        Output your format in:\n        \n        Question: \"...\"?\n        Outcomes: A or B\n\n        With ... filled in and A or B options being the potential results.\n        For example:\n\n        Question: \"Will Kamala win\"\n        Outcomes: Yes or No\n        \n        \"\"\"\n\n    def analyze_edge(self, ai_probability: float, market_price: float) -> str:\n        return f\"\"\"\n        Given:\n        - AI Predicted Probability: {ai_probability}\n        - Current Market Price: {market_price}\n        \n        Calculate and explain:\n        1. Absolute edge (difference between predictions)\n        2. Relative edge (percentage difference)\n        3. Kelly criterion position size\n        4. Confidence level based on edge size\n        \n        Format response as:\n        EDGE: [number]\n        KELLY_SIZE: [number]\n        CONFIDENCE: [HIGH/MEDIUM/LOW]\n        REASONING: [1-2 sentences]\n        \"\"\"\n"}
{"type": "source_file", "path": "agents/polymarket/__init__.py", "content": ""}
{"type": "source_file", "path": "agents/connectors/search.py", "content": "from typing import Optional\nimport os\nfrom dotenv import load_dotenv\nfrom tavily import TavilyClient\n\nclass MarketSearch:\n    def __init__(self):\n        load_dotenv()\n        self.client = TavilyClient(api_key=os.getenv(\"TAVILY_API_KEY\"))\n\n    def get_related_markets(self, question: str) -> str:\n        try:\n            # Buscar información relacionada\n            search_result = self.client.search(\n                query=question,\n                search_depth=\"advanced\",\n                max_results=5\n            )\n            \n            # Formatear los resultados\n            formatted_results = []\n            for result in search_result['results']:\n                formatted_results.append(f\"- {result['title']}: {result['content'][:200]}...\")\n            \n            return \"\\n\".join(formatted_results)\n        except Exception as e:\n            print(f\"Warning: Could not fetch related information: {e}\")\n            return \"No additional market information available.\"\n"}
{"type": "source_file", "path": "agents/__init__.py", "content": ""}
{"type": "source_file", "path": "agents/connectors/chroma.py", "content": "import json\nimport os\nimport time\n\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain_community.document_loaders import JSONLoader\nfrom langchain_community.vectorstores.chroma import Chroma\n\nfrom agents.polymarket.gamma import GammaMarketClient\nfrom agents.utils.objects import SimpleEvent, SimpleMarket\n\n\nclass PolymarketRAG:\n    def __init__(self, local_db_directory=None, embedding_function=None) -> None:\n        self.gamma_client = GammaMarketClient()\n        self.local_db_directory = local_db_directory\n        self.embedding_function = embedding_function\n\n    def load_json_from_local(\n        self, json_file_path=None, vector_db_directory=\"./local_db\"\n    ) -> None:\n        loader = JSONLoader(\n            file_path=json_file_path, jq_schema=\".[].description\", text_content=False\n        )\n        loaded_docs = loader.load()\n\n        embedding_function = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        Chroma.from_documents(\n            loaded_docs, embedding_function, persist_directory=vector_db_directory\n        )\n\n    def create_local_markets_rag(self, local_directory=\"./local_db\") -> None:\n        all_markets = self.gamma_client.get_all_current_markets()\n\n        if not os.path.isdir(local_directory):\n            os.mkdir(local_directory)\n\n        local_file_path = f\"{local_directory}/all-current-markets_{time.time()}.json\"\n\n        with open(local_file_path, \"w+\") as output_file:\n            json.dump(all_markets, output_file)\n\n        self.load_json_from_local(\n            json_file_path=local_file_path, vector_db_directory=local_directory\n        )\n\n    def query_local_markets_rag(\n        self, local_directory=None, query=None\n    ) -> \"list[tuple]\":\n        embedding_function = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        local_db = Chroma(\n            persist_directory=local_directory, embedding_function=embedding_function\n        )\n        response_docs = local_db.similarity_search_with_score(query=query)\n        return response_docs\n\n    def events(self, events: \"list[SimpleEvent]\", prompt: str) -> \"list[tuple]\":\n        # create local json file\n        local_events_directory: str = \"./local_db_events\"\n        if not os.path.isdir(local_events_directory):\n            os.mkdir(local_events_directory)\n        local_file_path = f\"{local_events_directory}/events.json\"\n        dict_events = [x.dict() for x in events]\n        with open(local_file_path, \"w+\") as output_file:\n            json.dump(dict_events, output_file)\n\n        # create vector db\n        def metadata_func(record: dict, metadata: dict) -> dict:\n\n            metadata[\"id\"] = record.get(\"id\")\n            metadata[\"markets\"] = record.get(\"markets\")\n\n            return metadata\n\n        loader = JSONLoader(\n            file_path=local_file_path,\n            jq_schema=\".[]\",\n            content_key=\"description\",\n            text_content=False,\n            metadata_func=metadata_func,\n        )\n        loaded_docs = loader.load()\n        embedding_function = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        vector_db_directory = f\"{local_events_directory}/chroma\"\n        local_db = Chroma.from_documents(\n            loaded_docs, embedding_function, persist_directory=vector_db_directory\n        )\n\n        # query\n        return local_db.similarity_search_with_score(query=prompt)\n\n    def markets(self, markets: \"list[tuple[SimpleMarket, float]]\", prompt: str) -> \"list[tuple[SimpleMarket, float]]\":\n        # Devolver los mercados sin modificar\n        return markets\n"}
{"type": "source_file", "path": "agents/connectors/news.py", "content": "from datetime import datetime\nimport os\n\nfrom newsapi import NewsApiClient\n\nfrom agents.utils.objects import Article\n\n\nclass News:\n    def __init__(self) -> None:\n        self.configs = {\n            \"language\": \"en\",\n            \"country\": \"us\",\n            \"top_headlines\": \"https://newsapi.org/v2/top-headlines?country=us&apiKey=\",\n            \"base_url\": \"https://newsapi.org/v2/\",\n        }\n\n        self.categories = {\n            \"business\",\n            \"entertainment\",\n            \"general\",\n            \"health\",\n            \"science\",\n            \"sports\",\n            \"technology\",\n        }\n\n        self.API = NewsApiClient(os.getenv(\"NEWSAPI_API_KEY\"))\n\n    def get_articles_for_cli_keywords(self, keywords) -> \"list[Article]\":\n        query_words = keywords.split(\",\")\n        all_articles = self.get_articles_for_options(query_words)\n        article_objects: list[Article] = []\n        for _, articles in all_articles.items():\n            for article in articles:\n                article_objects.append(Article(**article))\n        return article_objects\n\n    def get_top_articles_for_market(self, market_object: dict) -> \"list[Article]\":\n        return self.API.get_top_headlines(\n            language=\"en\", country=\"usa\", q=market_object[\"description\"]\n        )\n\n    def get_articles_for_options(\n        self,\n        market_options: \"list[str]\",\n        date_start: datetime = None,\n        date_end: datetime = None,\n    ) -> \"list[Article]\":\n\n        all_articles = {}\n        # Default to top articles if no start and end dates are given for search\n        if not date_start and not date_end:\n            for option in market_options:\n                response_dict = self.API.get_top_headlines(\n                    q=option.strip(),\n                    language=self.configs[\"language\"],\n                    country=self.configs[\"country\"],\n                )\n                articles = response_dict[\"articles\"]\n                all_articles[option] = articles\n        else:\n            for option in market_options:\n                response_dict = self.API.get_everything(\n                    q=option.strip(),\n                    language=self.configs[\"language\"],\n                    country=self.configs[\"country\"],\n                    from_param=date_start,\n                    to=date_end,\n                )\n                articles = response_dict[\"articles\"]\n                all_articles[option] = articles\n\n        return all_articles\n\n    def get_category(self, market_object: dict) -> str:\n        news_category = \"general\"\n        market_category = market_object[\"category\"]\n        if market_category in self.categories:\n            news_category = market_category\n        return news_category\n"}
{"type": "source_file", "path": "agents/application/trade.py", "content": "from agents.application.executor import Executor as Agent\nfrom agents.polymarket.gamma import GammaMarketClient as Gamma\nfrom agents.polymarket.polymarket import Polymarket\nfrom colorama import init, Fore, Style\n\nimport shutil\nimport os\nimport ast\nimport time\n\ninit()  # Inicializar colorama\n\n\nclass Trader:\n    def __init__(self):\n        self.polymarket = Polymarket()\n        self.gamma = Gamma()\n        self.agent = Agent()\n        self.dry_run = os.getenv(\"DRY_RUN\", \"false\").lower() == \"true\"\n        # Si está en dry_run, usar delay más corto o 0\n        default_delay = \"0\" if self.dry_run else \"300\"\n        self.analysis_delay = int(os.getenv(\"ANALYSIS_DELAY_SECONDS\", default_delay))\n        \n        if self.dry_run:\n            print(f\"\\n{Fore.GREEN}🔍 Running in DRY RUN mode - no transactions will be executed\")\n            print(f\"Analysis delay disabled in DRY RUN mode{Style.RESET_ALL}\\n\")\n        else:\n            print(f\"{Fore.BLUE}Analysis delay set to {self.analysis_delay} seconds{Style.RESET_ALL}\")\n\n    def pre_trade_logic(self) -> None:\n        self.clear_local_dbs()\n\n    def clear_local_dbs(self) -> None:\n        try:\n            shutil.rmtree(\"local_db_events\")\n        except:\n            pass\n        try:\n            shutil.rmtree(\"local_db_markets\")\n        except:\n            pass\n\n    def one_best_trade(self) -> None:\n        \"\"\"\n\n        one_best_trade is a strategy that evaluates all events, markets, and orderbooks\n\n        leverages all available information sources accessible to the autonomous agent\n\n        then executes that trade without any human intervention\n\n        \"\"\"\n        try:\n            while True:  # Bucle infinito para seguir ejecutando\n                self.pre_trade_logic()\n\n                events = self.polymarket.get_all_events()\n                print(f\"{Fore.LIGHTBLUE_EX}1. FOUND {len(events)} EVENTS{Style.RESET_ALL}\")\n\n                # Filtrar primero por volumen y pins\n                high_quality_events = []\n                for event in events:\n                    try:\n                        event_data = event.dict()\n                        market_ids = event_data.get('markets', '').split(',')\n                        \n                        for market_id in market_ids:\n                            if not market_id:\n                                continue\n                                \n                            market_data = self.gamma.get_market(market_id)\n                            volume = float(market_data.get('volume', 0))\n                            is_pinned = market_data.get('featured', False)\n                            \n                            if volume > 10000 or is_pinned:\n                                # Crear un diccionario con el evento y sus datos de trade\n                                event_with_trade = {\n                                    'event': event,\n                                    'trade': {\n                                        'market_data': market_data\n                                    }\n                                }\n                                high_quality_events.append((event_with_trade, 1.0))\n                                print(f\"\\nHigh quality market found: {market_data.get('question', '')}\")\n                                print(f\"Volume: ${volume:,.2f}\")\n                                print(f\"Featured: {is_pinned}\")\n                                print(\"---\")\n                                break\n                                \n                    except Exception as e:\n                        print(f\"Error processing event: {e}\")\n                        continue\n\n                print(f\"{Fore.LIGHTBLUE_EX}2. FOUND {len(high_quality_events)} HIGH QUALITY EVENTS{Style.RESET_ALL}\")\n\n                # Continuar con el filtrado RAG solo para eventos de alta calidad\n                filtered_events = self.agent.filter_events_with_rag(high_quality_events)\n                print(f\"{Fore.LIGHTBLUE_EX}3. FILTERED {len(filtered_events)} EVENTS{Style.RESET_ALL}\")\n\n                markets = self.agent.map_filtered_events_to_markets(filtered_events)\n                print()\n                print(f\"{Fore.LIGHTBLUE_EX}4. FOUND {len(markets)} MARKETS{Style.RESET_ALL}\")\n\n                print()\n                filtered_markets = self.agent.filter_markets(markets)\n                print(f\"{Fore.LIGHTBLUE_EX}5. FILTERED {len(filtered_markets)} MARKETS{Style.RESET_ALL}\")\n\n                # Para las respuestas de la IA\n                print(f\"\\n{Fore.YELLOW}AI analyzing markets...{Style.RESET_ALL}\")\n\n                for market_tuple in filtered_markets:\n                    try:\n                        market_data = market_tuple[0]  # SimpleMarket\n                        print(f\"\\n{Fore.YELLOW}=== Analyzing Market ===\")\n                        print(f\"Market: {market_data.question}\")\n                        print(f\"Current Prices:\")\n                        prices = ast.literal_eval(market_data.outcome_prices)\n                        print(f\"YES: ${prices[0]} ({Fore.RED}{float(prices[0])*100:.1f}%{Style.RESET_ALL})\")\n                        print(f\"NO: ${prices[1]} ({Fore.RED}{float(prices[1])*100:.1f}%{Style.RESET_ALL})\")\n                        print(f\"Volume: ${float(market_data.volume if hasattr(market_data, 'volume') else 0):,.2f}\")\n\n                        if not hasattr(market_data, 'clob_token_ids') or not market_data.clob_token_ids:\n                            print(f\"Market {market_data.question} does not have token IDs\")\n                            continue\n\n                        best_trade = self.agent.source_best_trade(market_tuple)\n                        \n                        if best_trade and isinstance(best_trade, dict):\n                            print(f\"\\nAI Decision:\")\n                            position = best_trade.get('position', 'UNKNOWN')\n                            print(f\"Action: BUY {position}\")\n                            \n                            # Asegurar que el precio es float\n                            target_price = float(best_trade.get('price', 0))\n                            edge = best_trade.get('edge', 0)\n                            \n                            print(f\"Target Price: ${target_price}\")\n                            print(f\"Expected Edge: ${edge:.4f}\")\n                            print(f\"Confidence: High based on market conditions\")\n                            print(f\"Reasoning: {best_trade.get('prediction', 'No prediction available')}\")\n                            print(f\"===================={Style.RESET_ALL}\")\n                            \n                            amount = 1.0\n                            best_trade['size'] = amount\n                            best_trade['price'] = target_price\n                            \n                            print(f\"\\n{Fore.GREEN}6. TRYING TRADE FOR MARKET {market_data.question}\")\n                            print(f\"   Amount: ${amount} USDC\")\n                            print(f\"   Price: {best_trade['price']}\")\n                            print(f\"   Side: BUY {best_trade.get('position')}{Style.RESET_ALL}\")\n\n                            if self.dry_run:\n                                print(\"\\n🔍 DRY RUN: Trade would be executed with these parameters\")\n                                print(f\"   Token ID: {market_data.clob_token_ids}\")\n                                print(f\"   Market Question: {market_data.question}\")\n                                print(\"Skipping actual transaction...\")\n                                continue\n\n                            amount = self.agent.format_trade_prompt_for_execution(best_trade)\n                            trade = self.polymarket.execute_market_order(market_data, amount)\n                            \n                            if trade:\n                                print(f\"7. TRADED SUCCESSFULLY {trade}\")\n                                print(f\"\\n{Fore.BLUE}Trade successful! Waiting {self.analysis_delay} seconds before next analysis...{Style.RESET_ALL}\")\n                                time.sleep(self.analysis_delay)\n                                break  # Salir del bucle de mercados y empezar nuevo ciclo\n                            else:\n                                print(\"Trade failed or skipped, trying next market...\")\n                                print(f\"\\n{Fore.BLUE}Waiting {self.analysis_delay} seconds before next analysis...{Style.RESET_ALL}\")\n                                time.sleep(self.analysis_delay)\n                                continue\n\n                    except Exception as e:\n                        print(f\"{Fore.RED}Error: {str(e)}{Style.RESET_ALL}\")\n                        print(f\"\\n{Fore.BLUE}Waiting {self.analysis_delay} seconds before next analysis...{Style.RESET_ALL}\")\n                        time.sleep(self.analysis_delay)\n                        continue\n\n                print(\"\\nNo eligible markets found for trading\")\n                print(f\"\\n{Fore.BLUE}No trades found. Waiting {self.analysis_delay} seconds before next analysis...{Style.RESET_ALL}\")\n                time.sleep(self.analysis_delay)\n\n        except Exception as e:\n            print(f\"Error {e}\")\n            print(f\"\\n{Fore.RED}Critical error occurred. Waiting {self.analysis_delay} seconds before retrying...{Style.RESET_ALL}\")\n            time.sleep(self.analysis_delay)\n\n    def maintain_positions(self):\n        pass\n\n    def incentive_farm(self):\n        pass\n\n\nif __name__ == \"__main__\":\n    t = Trader()\n    t.one_best_trade()\n"}

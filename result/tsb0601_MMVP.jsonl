{"repo_info": {"repo_name": "MMVP", "repo_owner": "tsb0601", "repo_url": "https://github.com/tsb0601/MMVP"}}
{"type": "test_file", "path": "LLaVA/llava/serve/test_message.py", "content": "import argparse\nimport json\n\nimport requests\n\nfrom llava.conversation import default_conversation\n\n\ndef main():\n    if args.worker_address:\n        worker_addr = args.worker_address\n    else:\n        controller_addr = args.controller_address\n        ret = requests.post(controller_addr + \"/refresh_all_workers\")\n        ret = requests.post(controller_addr + \"/list_models\")\n        models = ret.json()[\"models\"]\n        models.sort()\n        print(f\"Models: {models}\")\n\n        ret = requests.post(controller_addr + \"/get_worker_address\",\n            json={\"model\": args.model_name})\n        worker_addr = ret.json()[\"address\"]\n        print(f\"worker_addr: {worker_addr}\")\n\n    if worker_addr == \"\":\n        return\n\n    conv = default_conversation.copy()\n    conv.append_message(conv.roles[0], args.message)\n    prompt = conv.get_prompt()\n\n    headers = {\"User-Agent\": \"LLaVA Client\"}\n    pload = {\n        \"model\": args.model_name,\n        \"prompt\": prompt,\n        \"max_new_tokens\": args.max_new_tokens,\n        \"temperature\": 0.7,\n        \"stop\": conv.sep,\n    }\n    response = requests.post(worker_addr + \"/worker_generate_stream\", headers=headers,\n            json=pload, stream=True)\n\n    print(prompt.replace(conv.sep, \"\\n\"), end=\"\")\n    for chunk in response.iter_lines(chunk_size=8192, decode_unicode=False, delimiter=b\"\\0\"):\n        if chunk:\n            data = json.loads(chunk.decode(\"utf-8\"))\n            output = data[\"text\"].split(conv.sep)[-1]\n            print(output, end=\"\\r\")\n    print(\"\")\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--controller-address\", type=str, default=\"http://localhost:21001\")\n    parser.add_argument(\"--worker-address\", type=str)\n    parser.add_argument(\"--model-name\", type=str, default=\"facebook/opt-350m\")\n    parser.add_argument(\"--max-new-tokens\", type=int, default=32)\n    parser.add_argument(\"--message\", type=str, default=\n        \"Tell me a story with more than 1000 words.\")\n    args = parser.parse_args()\n\n    main()\n"}
{"type": "source_file", "path": "LLaVA/llava/conversation.py", "content": "import dataclasses\nfrom enum import auto, Enum\nfrom typing import List, Tuple\n\n\nclass SeparatorStyle(Enum):\n    \"\"\"Different separator style.\"\"\"\n    SINGLE = auto()\n    TWO = auto()\n    MPT = auto()\n    PLAIN = auto()\n    LLAMA_2 = auto()\n\n\n@dataclasses.dataclass\nclass Conversation:\n    \"\"\"A class that keeps all conversation history.\"\"\"\n    system: str\n    roles: List[str]\n    messages: List[List[str]]\n    offset: int\n    sep_style: SeparatorStyle = SeparatorStyle.SINGLE\n    sep: str = \"###\"\n    sep2: str = None\n    version: str = \"Unknown\"\n\n    skip_next: bool = False\n\n    def get_prompt(self):\n        messages = self.messages\n        if len(messages) > 0 and type(messages[0][1]) is tuple:\n            messages = self.messages.copy()\n            init_role, init_msg = messages[0].copy()\n            init_msg = init_msg[0].replace(\"<image>\", \"\").strip()\n            if 'mmtag' in self.version:\n                messages[0] = (init_role, init_msg)\n                messages.insert(0, (self.roles[0], \"<Image><image></Image>\"))\n                messages.insert(1, (self.roles[1], \"Received.\"))\n            else:\n                messages[0] = (init_role, \"<image>\\n\" + init_msg)\n\n        if self.sep_style == SeparatorStyle.SINGLE:\n            ret = self.system + self.sep\n            for role, message in messages:\n                if message:\n                    if type(message) is tuple:\n                        message, _, _ = message\n                    ret += role + \": \" + message + self.sep\n                else:\n                    ret += role + \":\"\n        elif self.sep_style == SeparatorStyle.TWO:\n            seps = [self.sep, self.sep2]\n            ret = self.system + seps[0]\n            for i, (role, message) in enumerate(messages):\n                if message:\n                    if type(message) is tuple:\n                        message, _, _ = message\n                    ret += role + \": \" + message + seps[i % 2]\n                else:\n                    ret += role + \":\"\n        elif self.sep_style == SeparatorStyle.MPT:\n            ret = self.system + self.sep\n            for role, message in messages:\n                if message:\n                    if type(message) is tuple:\n                        message, _, _ = message\n                    ret += role + message + self.sep\n                else:\n                    ret += role\n        elif self.sep_style == SeparatorStyle.LLAMA_2:\n            wrap_sys = lambda msg: f\"<<SYS>>\\n{msg}\\n<</SYS>>\\n\\n\"\n            wrap_inst = lambda msg: f\"[INST] {msg} [/INST]\"\n            ret = \"\"\n\n            for i, (role, message) in enumerate(messages):\n                if i == 0:\n                    assert message, \"first message should not be none\"\n                    assert role == self.roles[0], \"first message should come from user\"\n                if message:\n                    if type(message) is tuple:\n                        message, _, _ = message\n                    if i == 0: message = wrap_sys(self.system) + message\n                    if i % 2 == 0:\n                        message = wrap_inst(message)\n                        ret += self.sep + message\n                    else:\n                        ret += \" \" + message + \" \" + self.sep2\n                else:\n                    ret += \"\"\n            ret = ret.lstrip(self.sep)\n        elif self.sep_style == SeparatorStyle.PLAIN:\n            seps = [self.sep, self.sep2]\n            ret = self.system\n            for i, (role, message) in enumerate(messages):\n                if message:\n                    if type(message) is tuple:\n                        message, _, _ = message\n                    ret += message + seps[i % 2]\n                else:\n                    ret += \"\"\n        else:\n            raise ValueError(f\"Invalid style: {self.sep_style}\")\n\n        return ret\n\n    def append_message(self, role, message):\n        self.messages.append([role, message])\n\n    def get_images(self, return_pil=False):\n        images = []\n        for i, (role, msg) in enumerate(self.messages[self.offset:]):\n            if i % 2 == 0:\n                if type(msg) is tuple:\n                    import base64\n                    from io import BytesIO\n                    from PIL import Image\n                    msg, image, image_process_mode = msg\n                    if image_process_mode == \"Pad\":\n                        def expand2square(pil_img, background_color=(122, 116, 104)):\n                            width, height = pil_img.size\n                            if width == height:\n                                return pil_img\n                            elif width > height:\n                                result = Image.new(pil_img.mode, (width, width), background_color)\n                                result.paste(pil_img, (0, (width - height) // 2))\n                                return result\n                            else:\n                                result = Image.new(pil_img.mode, (height, height), background_color)\n                                result.paste(pil_img, ((height - width) // 2, 0))\n                                return result\n                        image = expand2square(image)\n                    elif image_process_mode in [\"Default\", \"Crop\"]:\n                        pass\n                    elif image_process_mode == \"Resize\":\n                        image = image.resize((336, 336))\n                    else:\n                        raise ValueError(f\"Invalid image_process_mode: {image_process_mode}\")\n                    max_hw, min_hw = max(image.size), min(image.size)\n                    aspect_ratio = max_hw / min_hw\n                    max_len, min_len = 800, 400\n                    shortest_edge = int(min(max_len / aspect_ratio, min_len, min_hw))\n                    longest_edge = int(shortest_edge * aspect_ratio)\n                    W, H = image.size\n                    if longest_edge != max(image.size):\n                        if H > W:\n                            H, W = longest_edge, shortest_edge\n                        else:\n                            H, W = shortest_edge, longest_edge\n                        image = image.resize((W, H))\n                    if return_pil:\n                        images.append(image)\n                    else:\n                        buffered = BytesIO()\n                        image.save(buffered, format=\"PNG\")\n                        img_b64_str = base64.b64encode(buffered.getvalue()).decode()\n                        images.append(img_b64_str)\n        return images\n\n    def to_gradio_chatbot(self):\n        ret = []\n        for i, (role, msg) in enumerate(self.messages[self.offset:]):\n            if i % 2 == 0:\n                if type(msg) is tuple:\n                    import base64\n                    from io import BytesIO\n                    msg, image, image_process_mode = msg\n                    max_hw, min_hw = max(image.size), min(image.size)\n                    aspect_ratio = max_hw / min_hw\n                    max_len, min_len = 800, 400\n                    shortest_edge = int(min(max_len / aspect_ratio, min_len, min_hw))\n                    longest_edge = int(shortest_edge * aspect_ratio)\n                    W, H = image.size\n                    if H > W:\n                        H, W = longest_edge, shortest_edge\n                    else:\n                        H, W = shortest_edge, longest_edge\n                    image = image.resize((W, H))\n                    buffered = BytesIO()\n                    image.save(buffered, format=\"JPEG\")\n                    img_b64_str = base64.b64encode(buffered.getvalue()).decode()\n                    img_str = f'<img src=\"data:image/png;base64,{img_b64_str}\" alt=\"user upload image\" />'\n                    msg = img_str + msg.replace('<image>', '').strip()\n                    ret.append([msg, None])\n                else:\n                    ret.append([msg, None])\n            else:\n                ret[-1][-1] = msg\n        return ret\n\n    def copy(self):\n        return Conversation(\n            system=self.system,\n            roles=self.roles,\n            messages=[[x, y] for x, y in self.messages],\n            offset=self.offset,\n            sep_style=self.sep_style,\n            sep=self.sep,\n            sep2=self.sep2,\n            version=self.version)\n\n    def dict(self):\n        if len(self.get_images()) > 0:\n            return {\n                \"system\": self.system,\n                \"roles\": self.roles,\n                \"messages\": [[x, y[0] if type(y) is tuple else y] for x, y in self.messages],\n                \"offset\": self.offset,\n                \"sep\": self.sep,\n                \"sep2\": self.sep2,\n            }\n        return {\n            \"system\": self.system,\n            \"roles\": self.roles,\n            \"messages\": self.messages,\n            \"offset\": self.offset,\n            \"sep\": self.sep,\n            \"sep2\": self.sep2,\n        }\n\n\nconv_vicuna_v0 = Conversation(\n    system=\"A chat between a curious human and an artificial intelligence assistant. \"\n           \"The assistant gives helpful, detailed, and polite answers to the human's questions.\",\n    roles=(\"Human\", \"Assistant\"),\n    messages=(\n        (\"Human\", \"What are the key differences between renewable and non-renewable energy sources?\"),\n        (\"Assistant\",\n            \"Renewable energy sources are those that can be replenished naturally in a relatively \"\n            \"short amount of time, such as solar, wind, hydro, geothermal, and biomass. \"\n            \"Non-renewable energy sources, on the other hand, are finite and will eventually be \"\n            \"depleted, such as coal, oil, and natural gas. Here are some key differences between \"\n            \"renewable and non-renewable energy sources:\\n\"\n            \"1. Availability: Renewable energy sources are virtually inexhaustible, while non-renewable \"\n            \"energy sources are finite and will eventually run out.\\n\"\n            \"2. Environmental impact: Renewable energy sources have a much lower environmental impact \"\n            \"than non-renewable sources, which can lead to air and water pollution, greenhouse gas emissions, \"\n            \"and other negative effects.\\n\"\n            \"3. Cost: Renewable energy sources can be more expensive to initially set up, but they typically \"\n            \"have lower operational costs than non-renewable sources.\\n\"\n            \"4. Reliability: Renewable energy sources are often more reliable and can be used in more remote \"\n            \"locations than non-renewable sources.\\n\"\n            \"5. Flexibility: Renewable energy sources are often more flexible and can be adapted to different \"\n            \"situations and needs, while non-renewable sources are more rigid and inflexible.\\n\"\n            \"6. Sustainability: Renewable energy sources are more sustainable over the long term, while \"\n            \"non-renewable sources are not, and their depletion can lead to economic and social instability.\\n\")\n    ),\n    offset=2,\n    sep_style=SeparatorStyle.SINGLE,\n    sep=\"###\",\n)\n\nconv_vicuna_v1 = Conversation(\n    system=\"A chat between a curious user and an artificial intelligence assistant. \"\n    \"The assistant gives helpful, detailed, and polite answers to the user's questions.\",\n    roles=(\"USER\", \"ASSISTANT\"),\n    version=\"v1\",\n    messages=(),\n    offset=0,\n    sep_style=SeparatorStyle.TWO,\n    sep=\" \",\n    sep2=\"</s>\",\n)\n\nconv_llama_2 = Conversation(\n    system=\"\"\"You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.\n\nIf a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.\"\"\",\n    roles=(\"USER\", \"ASSISTANT\"),\n    version=\"llama_v2\",\n    messages=(),\n    offset=0,\n    sep_style=SeparatorStyle.LLAMA_2,\n    sep=\"<s>\",\n    sep2=\"</s>\",\n)\n\nconv_llava_llama_2 = Conversation(\n    system=\"You are a helpful language and vision assistant. \"\n           \"You are able to understand the visual content that the user provides, \"\n           \"and assist the user with a variety of tasks using natural language.\",\n    roles=(\"USER\", \"ASSISTANT\"),\n    version=\"llama_v2\",\n    messages=(),\n    offset=0,\n    sep_style=SeparatorStyle.LLAMA_2,\n    sep=\"<s>\",\n    sep2=\"</s>\",\n)\n\nconv_mpt = Conversation(\n    system=\"\"\"<|im_start|>system\nA conversation between a user and an LLM-based AI assistant. The assistant gives helpful and honest answers.\"\"\",\n    roles=(\"<|im_start|>user\\n\", \"<|im_start|>assistant\\n\"),\n    version=\"mpt\",\n    messages=(),\n    offset=0,\n    sep_style=SeparatorStyle.MPT,\n    sep=\"<|im_end|>\",\n)\n\nconv_llava_plain = Conversation(\n    system=\"\",\n    roles=(\"\", \"\"),\n    messages=(\n    ),\n    offset=0,\n    sep_style=SeparatorStyle.PLAIN,\n    sep=\"\\n\",\n)\n\nconv_llava_v0 = Conversation(\n    system=\"A chat between a curious human and an artificial intelligence assistant. \"\n           \"The assistant gives helpful, detailed, and polite answers to the human's questions.\",\n    roles=(\"Human\", \"Assistant\"),\n    messages=(\n    ),\n    offset=0,\n    sep_style=SeparatorStyle.SINGLE,\n    sep=\"###\",\n)\n\nconv_llava_v0_mmtag = Conversation(\n    system=\"A chat between a curious user and an artificial intelligence assistant. \"\n           \"The assistant is able to understand the visual content that the user provides, and assist the user with a variety of tasks using natural language.\"\n           \"The visual content will be provided with the following format: <Image>visual content</Image>.\",\n    roles=(\"Human\", \"Assistant\"),\n    messages=(\n    ),\n    offset=0,\n    sep_style=SeparatorStyle.SINGLE,\n    sep=\"###\",\n    version=\"v0_mmtag\",\n)\n\nconv_llava_v1 = Conversation(\n    system=\"A chat between a curious human and an artificial intelligence assistant. \"\n           \"The assistant gives helpful, detailed, and polite answers to the human's questions.\",\n    roles=(\"USER\", \"ASSISTANT\"),\n    version=\"v1\",\n    messages=(),\n    offset=0,\n    sep_style=SeparatorStyle.TWO,\n    sep=\" \",\n    sep2=\"</s>\",\n)\n\nconv_llava_v1_mmtag = Conversation(\n    system=\"A chat between a curious user and an artificial intelligence assistant. \"\n           \"The assistant is able to understand the visual content that the user provides, and assist the user with a variety of tasks using natural language.\"\n           \"The visual content will be provided with the following format: <Image>visual content</Image>.\",\n    roles=(\"USER\", \"ASSISTANT\"),\n    messages=(),\n    offset=0,\n    sep_style=SeparatorStyle.TWO,\n    sep=\" \",\n    sep2=\"</s>\",\n    version=\"v1_mmtag\",\n)\n\ndefault_conversation = conv_vicuna_v0\nconv_templates = {\n    \"default\": conv_vicuna_v0,\n    \"v0\": conv_vicuna_v0,\n    \"v1\": conv_vicuna_v1,\n    \"vicuna_v1\": conv_vicuna_v1,\n    \"llama_2\": conv_llama_2,\n\n    \"plain\": conv_llava_plain,\n    \"v0_plain\": conv_llava_plain,\n    \"llava_v0\": conv_llava_v0,\n    \"v0_mmtag\": conv_llava_v0_mmtag,\n    \"llava_v1\": conv_llava_v1,\n    \"v1_mmtag\": conv_llava_v1_mmtag,\n    \"llava_llama_2\": conv_llava_llama_2,\n\n    \"mpt\": conv_mpt,\n}\n\n\nif __name__ == \"__main__\":\n    print(default_conversation.get_prompt())\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/eval_science_qa.py", "content": "import argparse\nimport json\nimport os\nimport re\nimport random\n\n\ndef get_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-dir', type=str)\n    parser.add_argument('--result-file', type=str)\n    parser.add_argument('--output-file', type=str)\n    parser.add_argument('--output-result', type=str)\n    parser.add_argument('--split', type=str, default='test')\n    parser.add_argument('--options', type=list, default=[\"A\", \"B\", \"C\", \"D\", \"E\"])\n    return parser.parse_args()\n\n\ndef convert_caps(results):\n    fakecaps = []\n    for result in results:\n        image_id = result['question_id']\n        caption = result['text']\n        fakecaps.append({\"image_id\": int(image_id), \"caption\": caption})\n    return fakecaps\n\n\ndef get_pred_idx(prediction, choices, options):\n    \"\"\"\n    Get the index (e.g. 2) from the prediction (e.g. 'C')\n    \"\"\"\n    if prediction in options[:len(choices)]:\n        return options.index(prediction)\n    else:\n        return -1\n        return random.choice(range(len(choices)))\n\n\nif __name__ == \"__main__\":\n    args = get_args()\n\n    base_dir = args.base_dir\n    split_indices = json.load(open(os.path.join(base_dir, \"pid_splits.json\")))[args.split]\n    problems = json.load(open(os.path.join(base_dir, \"problems.json\")))\n    predictions = [json.loads(line) for line in open(args.result_file)]\n    predictions = {pred['question_id']: pred for pred in predictions}\n    split_problems = {idx: problems[idx] for idx in split_indices}\n\n    results = {'correct': [], 'incorrect': []}\n    sqa_results = {}\n    sqa_results['acc'] = None\n    sqa_results['correct'] = None\n    sqa_results['count'] = None\n    sqa_results['results'] = {}\n    sqa_results['outputs'] = {}\n\n    for prob_id, prob in split_problems.items():\n        if prob_id not in predictions:\n            pred = {'text': 'FAILED', 'prompt': 'Unknown'}\n            pred_text = 'FAILED'\n        else:\n            pred = predictions[prob_id]\n            pred_text = pred['text']\n\n        if pred_text in args.options:\n            answer = pred_text\n        elif len(pred_text) >= 3 and pred_text[0] in args.options and pred_text[1:3] == \". \":\n            answer = pred_text[0]\n        else:\n            pattern = re.compile(r'The answer is ([A-Z]).')\n            res = pattern.findall(pred_text)\n            if len(res) == 1:\n                answer = res[0]  # 'A', 'B', ...\n            else:\n                answer = \"FAILED\"\n\n        pred_idx = get_pred_idx(answer, prob['choices'], args.options)\n\n        analysis = {\n            'question_id': prob_id,\n            'parsed_ans': answer,\n            'ground_truth': args.options[prob['answer']],\n            'question': pred['prompt'],\n            'pred': pred_text,\n            'is_multimodal': '<image>' in pred['prompt'],\n        }\n\n        sqa_results['results'][prob_id] = get_pred_idx(answer, prob['choices'], args.options)\n        sqa_results['outputs'][prob_id] = pred_text\n\n        if pred_idx == prob['answer']:\n            results['correct'].append(analysis)\n        else:\n            results['incorrect'].append(analysis)\n\n    correct = len(results['correct'])\n    total = len(results['correct']) + len(results['incorrect'])\n\n    ###### IMG ######\n    multimodal_correct = len([x for x in results['correct'] if x['is_multimodal']])\n    multimodal_incorrect = len([x for x in results['incorrect'] if x['is_multimodal']])\n    multimodal_total = multimodal_correct + multimodal_incorrect\n    ###### IMG ######\n\n    print(f'Total: {total}, Correct: {correct}, Accuracy: {correct / total * 100:.2f}%, IMG-Accuracy: {multimodal_correct / multimodal_total * 100:.2f}%')\n\n    sqa_results['acc'] = correct / total * 100\n    sqa_results['correct'] = correct\n    sqa_results['count'] = total\n\n    with open(args.output_file, 'w') as f:\n        json.dump(results, f, indent=2)\n    with open(args.output_result, 'w') as f:\n        json.dump(sqa_results, f, indent=2)\n"}
{"type": "source_file", "path": "LLaVA/llava/constants.py", "content": "CONTROLLER_HEART_BEAT_EXPIRATION = 30\nWORKER_HEART_BEAT_INTERVAL = 15\n\nLOGDIR = \".\"\n\n# Model Constants\nIGNORE_INDEX = -100\nIMAGE_TOKEN_INDEX = -200\nDEFAULT_IMAGE_TOKEN = \"<image>\"\nDEFAULT_IMAGE_PATCH_TOKEN = \"<im_patch>\"\nDEFAULT_IM_START_TOKEN = \"<im_start>\"\nDEFAULT_IM_END_TOKEN = \"<im_end>\"\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/generate_webpage_data_from_table.py", "content": "\"\"\"Generate json file for webpage.\"\"\"\nimport json\nimport os\nimport re\n\n# models = ['llama', 'alpaca', 'gpt35', 'bard']\nmodels = ['vicuna']\n\n\ndef read_jsonl(path: str, key: str=None):\n    data = []\n    with open(os.path.expanduser(path)) as f:\n        for line in f:\n            if not line:\n                continue\n            data.append(json.loads(line))\n    if key is not None:\n        data.sort(key=lambda x: x[key])\n        data = {item[key]: item for item in data}\n    return data\n\n\ndef trim_hanging_lines(s: str, n: int) -> str:\n    s = s.strip()\n    for _ in range(n):\n        s = s.split('\\n', 1)[1].strip()\n    return s\n\n\nif __name__ == '__main__':\n    questions = read_jsonl('table/question.jsonl', key='question_id')\n\n    # alpaca_answers = read_jsonl('table/answer/answer_alpaca-13b.jsonl', key='question_id')\n    # bard_answers = read_jsonl('table/answer/answer_bard.jsonl', key='question_id')\n    # gpt35_answers = read_jsonl('table/answer/answer_gpt35.jsonl', key='question_id')\n    # llama_answers = read_jsonl('table/answer/answer_llama-13b.jsonl', key='question_id')\n    vicuna_answers = read_jsonl('table/answer/answer_vicuna-13b.jsonl', key='question_id')\n    ours_answers = read_jsonl('table/results/llama-13b-hf-alpaca.jsonl', key='question_id')\n\n    review_vicuna = read_jsonl('table/review/review_vicuna-13b_llama-13b-hf-alpaca.jsonl', key='question_id')\n    # review_alpaca = read_jsonl('table/review/review_alpaca-13b_vicuna-13b.jsonl', key='question_id')\n    # review_bard = read_jsonl('table/review/review_bard_vicuna-13b.jsonl', key='question_id')\n    # review_gpt35 = read_jsonl('table/review/review_gpt35_vicuna-13b.jsonl', key='question_id')\n    # review_llama = read_jsonl('table/review/review_llama-13b_vicuna-13b.jsonl', key='question_id')\n\n    records = []\n    for qid in questions.keys():\n        r = {\n            'id': qid,\n            'category': questions[qid]['category'],\n            'question': questions[qid]['text'],\n            'answers': {\n                # 'alpaca': alpaca_answers[qid]['text'],\n                # 'llama': llama_answers[qid]['text'],\n                # 'bard': bard_answers[qid]['text'],\n                # 'gpt35': gpt35_answers[qid]['text'],\n                'vicuna': vicuna_answers[qid]['text'],\n                'ours': ours_answers[qid]['text'],\n            },\n            'evaluations': {\n                # 'alpaca': review_alpaca[qid]['text'],\n                # 'llama': review_llama[qid]['text'],\n                # 'bard': review_bard[qid]['text'],\n                'vicuna': review_vicuna[qid]['content'],\n                # 'gpt35': review_gpt35[qid]['text'],\n            },\n            'scores': {\n                'vicuna': review_vicuna[qid]['tuple'],\n                # 'alpaca': review_alpaca[qid]['score'],\n                # 'llama': review_llama[qid]['score'],\n                # 'bard': review_bard[qid]['score'],\n                # 'gpt35': review_gpt35[qid]['score'],\n            },\n        }\n\n        # cleanup data\n        cleaned_evals = {}\n        for k, v in r['evaluations'].items():\n            v = v.strip()\n            lines = v.split('\\n')\n            # trim the first line if it's a pair of numbers\n            if re.match(r'\\d+[, ]+\\d+', lines[0]):\n                lines = lines[1:]\n            v = '\\n'.join(lines)\n            cleaned_evals[k] = v.replace('Assistant 1', \"**Assistant 1**\").replace('Assistant 2', '**Assistant 2**')\n\n        r['evaluations'] = cleaned_evals\n        records.append(r)\n\n    # Reorder the records, this is optional\n    for r in records:\n        if r['id'] <= 20:\n            r['id'] += 60\n        else:\n            r['id'] -= 20\n    for r in records:\n        if r['id'] <= 50:\n            r['id'] += 10\n        elif 50 < r['id'] <= 60:\n            r['id'] -= 50\n    for r in records:\n        if r['id'] == 7:\n            r['id'] = 1\n        elif r['id'] < 7:\n            r['id'] += 1 \n\n    records.sort(key=lambda x: x['id'])\n\n    # Write to file\n    with open('webpage/data.json', 'w') as f:\n        json.dump({'questions': records, 'models': models}, f, indent=2)\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/model_qa.py", "content": "import argparse\nfrom transformers import AutoTokenizer, AutoModelForCausalLM, StoppingCriteria\nimport torch\nimport os\nimport json\nfrom tqdm import tqdm\nimport shortuuid\n\nfrom llava.conversation import default_conversation\nfrom llava.utils import disable_torch_init\n\n\n# new stopping implementation\nclass KeywordsStoppingCriteria(StoppingCriteria):\n    def __init__(self, keywords, tokenizer, input_ids):\n        self.keywords = keywords\n        self.tokenizer = tokenizer\n        self.start_len = None\n        self.input_ids = input_ids\n\n    def __call__(self, output_ids: torch.LongTensor, scores: torch.FloatTensor, **kwargs) -> bool:\n        if self.start_len is None:\n            self.start_len = self.input_ids.shape[1]\n        else:\n            outputs = self.tokenizer.batch_decode(output_ids[:, self.start_len:], skip_special_tokens=True)[0]\n            for keyword in self.keywords:\n                if keyword in outputs:\n                    return True\n        return False\n\n\n@torch.inference_mode()\ndef eval_model(model_name, questions_file, answers_file):\n    # Model\n    disable_torch_init()\n    model_name = os.path.expanduser(model_name)\n    tokenizer = AutoTokenizer.from_pretrained(model_name, use_fast=False)\n    model = AutoModelForCausalLM.from_pretrained(model_name,\n        torch_dtype=torch.float16).cuda()\n\n\n    ques_file = open(os.path.expanduser(questions_file), \"r\")\n    ans_file = open(os.path.expanduser(answers_file), \"w\")\n    for i, line in enumerate(tqdm(ques_file)):\n        idx = json.loads(line)[\"question_id\"]\n        qs = json.loads(line)[\"text\"]\n        cat = json.loads(line)[\"category\"]\n        conv = default_conversation.copy()\n        conv.append_message(conv.roles[0], qs)\n        prompt = conv.get_prompt()\n        inputs = tokenizer([prompt])\n        input_ids = torch.as_tensor(inputs.input_ids).cuda()\n        stopping_criteria = KeywordsStoppingCriteria([conv.sep], tokenizer, input_ids)\n        output_ids = model.generate(\n            input_ids,\n            do_sample=True,\n            use_cache=True,\n            temperature=0.7,\n            max_new_tokens=1024,\n            stopping_criteria=[stopping_criteria])\n        outputs = tokenizer.batch_decode(output_ids, skip_special_tokens=True)[0]\n        try:\n            index = outputs.index(conv.sep, len(prompt))\n        except ValueError:\n            outputs += conv.sep\n            index = outputs.index(conv.sep, len(prompt))\n\n        outputs = outputs[len(prompt) + len(conv.roles[1]) + 2:index].strip()\n        ans_id = shortuuid.uuid()\n        ans_file.write(json.dumps({\"question_id\": idx,\n                                   \"text\": outputs,\n                                   \"answer_id\": ans_id,\n                                   \"model_id\": model_name,\n                                   \"metadata\": {}}) + \"\\n\")\n        ans_file.flush()\n    ans_file.close()\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model-name\", type=str, default=\"facebook/opt-350m\")\n    parser.add_argument(\"--question-file\", type=str, default=\"tables/question.jsonl\")\n    parser.add_argument(\"--answers-file\", type=str, default=\"answer.jsonl\")\n    args = parser.parse_args()\n\n    eval_model(args.model_name, args.question_file, args.answers_file)\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/summarize_gpt_review.py", "content": "import json\nimport os\nfrom collections import defaultdict\n\nimport numpy as np\n\nimport argparse\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description='ChatGPT-based QA evaluation.')\n    parser.add_argument('-d', '--dir', default=None)\n    parser.add_argument('-v', '--version', default=None)\n    parser.add_argument('-s', '--select', nargs='*', default=None)\n    parser.add_argument('-f', '--files', nargs='*', default=[])\n    parser.add_argument('-i', '--ignore', nargs='*', default=[])\n    return parser.parse_args()\n\n\nif __name__ == '__main__':\n    args = parse_args()\n\n    if args.ignore is not None:\n        args.ignore = [int(x) for x in args.ignore]\n\n    if len(args.files) > 0:\n        review_files = args.files\n    else:\n        review_files = [x for x in os.listdir(args.dir) if x.endswith('.jsonl') and (x.startswith('gpt4_text') or x.startswith('reviews_') or x.startswith('review_') or 'review' in args.dir)]\n\n    for review_file in sorted(review_files):\n        config = os.path.basename(review_file).replace('gpt4_text_', '').replace('.jsonl', '')\n        if args.select is not None and any(x not in config for x in args.select):\n            continue\n        if '0613' in config:\n            version = '0613'\n        else:\n            version = '0314'\n        if args.version is not None and args.version != version:\n            continue\n        scores = defaultdict(list)\n        print(config)\n        with open(os.path.join(args.dir, review_file) if args.dir is not None else review_file) as f:\n            for review_str in f:\n                review = json.loads(review_str)\n                if review['question_id'] in args.ignore:\n                    continue\n                if 'category' in review:\n                    scores[review['category']].append(review['tuple'])\n                    scores['all'].append(review['tuple'])\n                else:\n                    if 'tuple' in review:\n                        scores['all'].append(review['tuple'])\n                    else:\n                        scores['all'].append(review['score'])\n        for k, v in sorted(scores.items()):\n            stats = np.asarray(v).mean(0).tolist()\n            stats = [round(x, 3) for x in stats]\n            # print(k, stats, round(stats[1]/stats[0]*100, 1))\n            print(k, round(stats[1]/stats[0]*100, 1), round(stats[0] * 10, 1), round(stats[1] * 10, 1))\n        print('=================================')\n"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/adapt_tokenizer.py", "content": "from typing import Union\nfrom transformers import AutoTokenizer, PreTrainedTokenizer, PreTrainedTokenizerFast\nTokenizer = Union[PreTrainedTokenizer, PreTrainedTokenizerFast]\nNUM_SENTINEL_TOKENS: int = 100\n\ndef adapt_tokenizer_for_denoising(tokenizer: Tokenizer):\n    \"\"\"Adds sentinel tokens and padding token (if missing).\n\n    Expands the tokenizer vocabulary to include sentinel tokens\n    used in mixture-of-denoiser tasks as well as a padding token.\n\n    All added tokens are added as special tokens. No tokens are\n    added if sentinel tokens and padding token already exist.\n    \"\"\"\n    sentinels_to_add = [f'<extra_id_{i}>' for i in range(NUM_SENTINEL_TOKENS)]\n    tokenizer.add_tokens(sentinels_to_add, special_tokens=True)\n    if tokenizer.pad_token is None:\n        tokenizer.add_tokens('<pad>', special_tokens=True)\n        tokenizer.pad_token = '<pad>'\n        assert tokenizer.pad_token_id is not None\n    sentinels = ''.join([f'<extra_id_{i}>' for i in range(NUM_SENTINEL_TOKENS)])\n    _sentinel_token_ids = tokenizer(sentinels, add_special_tokens=False).input_ids\n    tokenizer.sentinel_token_ids = _sentinel_token_ids\n\nclass AutoTokenizerForMOD(AutoTokenizer):\n    \"\"\"AutoTokenizer + Adaptation for MOD.\n\n    A simple wrapper around AutoTokenizer to make instantiating\n    an MOD-adapted tokenizer a bit easier.\n\n    MOD-adapted tokenizers have sentinel tokens (e.g., <extra_id_0>),\n    a padding token, and a property to get the token ids of the\n    sentinel tokens.\n    \"\"\"\n\n    @classmethod\n    def from_pretrained(cls, *args, **kwargs):\n        \"\"\"See `AutoTokenizer.from_pretrained` docstring.\"\"\"\n        tokenizer = super().from_pretrained(*args, **kwargs)\n        adapt_tokenizer_for_denoising(tokenizer)\n        return tokenizer"}
{"type": "source_file", "path": "LLaVA/llava/__init__.py", "content": "from .model import LlavaLlamaForCausalLM\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/m4c_evaluator.py", "content": "# Copyright (c) Facebook, Inc. and its affiliates.\nimport re\n\nfrom tqdm import tqdm\n\n\nclass EvalAIAnswerProcessor:\n    \"\"\"\n    Processes an answer similar to Eval AI\n        copied from\n        https://github.com/facebookresearch/mmf/blob/c46b3b3391275b4181567db80943473a89ab98ab/pythia/tasks/processors.py#L897\n    \"\"\"\n\n    CONTRACTIONS = {\n        \"aint\": \"ain't\",\n        \"arent\": \"aren't\",\n        \"cant\": \"can't\",\n        \"couldve\": \"could've\",\n        \"couldnt\": \"couldn't\",\n        \"couldn'tve\": \"couldn't've\",\n        \"couldnt've\": \"couldn't've\",\n        \"didnt\": \"didn't\",\n        \"doesnt\": \"doesn't\",\n        \"dont\": \"don't\",\n        \"hadnt\": \"hadn't\",\n        \"hadnt've\": \"hadn't've\",\n        \"hadn'tve\": \"hadn't've\",\n        \"hasnt\": \"hasn't\",\n        \"havent\": \"haven't\",\n        \"hed\": \"he'd\",\n        \"hed've\": \"he'd've\",\n        \"he'dve\": \"he'd've\",\n        \"hes\": \"he's\",\n        \"howd\": \"how'd\",\n        \"howll\": \"how'll\",\n        \"hows\": \"how's\",\n        \"Id've\": \"I'd've\",\n        \"I'dve\": \"I'd've\",\n        \"Im\": \"I'm\",\n        \"Ive\": \"I've\",\n        \"isnt\": \"isn't\",\n        \"itd\": \"it'd\",\n        \"itd've\": \"it'd've\",\n        \"it'dve\": \"it'd've\",\n        \"itll\": \"it'll\",\n        \"let's\": \"let's\",\n        \"maam\": \"ma'am\",\n        \"mightnt\": \"mightn't\",\n        \"mightnt've\": \"mightn't've\",\n        \"mightn'tve\": \"mightn't've\",\n        \"mightve\": \"might've\",\n        \"mustnt\": \"mustn't\",\n        \"mustve\": \"must've\",\n        \"neednt\": \"needn't\",\n        \"notve\": \"not've\",\n        \"oclock\": \"o'clock\",\n        \"oughtnt\": \"oughtn't\",\n        \"ow's'at\": \"'ow's'at\",\n        \"'ows'at\": \"'ow's'at\",\n        \"'ow'sat\": \"'ow's'at\",\n        \"shant\": \"shan't\",\n        \"shed've\": \"she'd've\",\n        \"she'dve\": \"she'd've\",\n        \"she's\": \"she's\",\n        \"shouldve\": \"should've\",\n        \"shouldnt\": \"shouldn't\",\n        \"shouldnt've\": \"shouldn't've\",\n        \"shouldn'tve\": \"shouldn't've\",\n        \"somebody'd\": \"somebodyd\",\n        \"somebodyd've\": \"somebody'd've\",\n        \"somebody'dve\": \"somebody'd've\",\n        \"somebodyll\": \"somebody'll\",\n        \"somebodys\": \"somebody's\",\n        \"someoned\": \"someone'd\",\n        \"someoned've\": \"someone'd've\",\n        \"someone'dve\": \"someone'd've\",\n        \"someonell\": \"someone'll\",\n        \"someones\": \"someone's\",\n        \"somethingd\": \"something'd\",\n        \"somethingd've\": \"something'd've\",\n        \"something'dve\": \"something'd've\",\n        \"somethingll\": \"something'll\",\n        \"thats\": \"that's\",\n        \"thered\": \"there'd\",\n        \"thered've\": \"there'd've\",\n        \"there'dve\": \"there'd've\",\n        \"therere\": \"there're\",\n        \"theres\": \"there's\",\n        \"theyd\": \"they'd\",\n        \"theyd've\": \"they'd've\",\n        \"they'dve\": \"they'd've\",\n        \"theyll\": \"they'll\",\n        \"theyre\": \"they're\",\n        \"theyve\": \"they've\",\n        \"twas\": \"'twas\",\n        \"wasnt\": \"wasn't\",\n        \"wed've\": \"we'd've\",\n        \"we'dve\": \"we'd've\",\n        \"weve\": \"we've\",\n        \"werent\": \"weren't\",\n        \"whatll\": \"what'll\",\n        \"whatre\": \"what're\",\n        \"whats\": \"what's\",\n        \"whatve\": \"what've\",\n        \"whens\": \"when's\",\n        \"whered\": \"where'd\",\n        \"wheres\": \"where's\",\n        \"whereve\": \"where've\",\n        \"whod\": \"who'd\",\n        \"whod've\": \"who'd've\",\n        \"who'dve\": \"who'd've\",\n        \"wholl\": \"who'll\",\n        \"whos\": \"who's\",\n        \"whove\": \"who've\",\n        \"whyll\": \"why'll\",\n        \"whyre\": \"why're\",\n        \"whys\": \"why's\",\n        \"wont\": \"won't\",\n        \"wouldve\": \"would've\",\n        \"wouldnt\": \"wouldn't\",\n        \"wouldnt've\": \"wouldn't've\",\n        \"wouldn'tve\": \"wouldn't've\",\n        \"yall\": \"y'all\",\n        \"yall'll\": \"y'all'll\",\n        \"y'allll\": \"y'all'll\",\n        \"yall'd've\": \"y'all'd've\",\n        \"y'alld've\": \"y'all'd've\",\n        \"y'all'dve\": \"y'all'd've\",\n        \"youd\": \"you'd\",\n        \"youd've\": \"you'd've\",\n        \"you'dve\": \"you'd've\",\n        \"youll\": \"you'll\",\n        \"youre\": \"you're\",\n        \"youve\": \"you've\",\n    }\n\n    NUMBER_MAP = {\n        \"none\": \"0\",\n        \"zero\": \"0\",\n        \"one\": \"1\",\n        \"two\": \"2\",\n        \"three\": \"3\",\n        \"four\": \"4\",\n        \"five\": \"5\",\n        \"six\": \"6\",\n        \"seven\": \"7\",\n        \"eight\": \"8\",\n        \"nine\": \"9\",\n        \"ten\": \"10\",\n    }\n    ARTICLES = [\"a\", \"an\", \"the\"]\n    PERIOD_STRIP = re.compile(r\"(?!<=\\d)(\\.)(?!\\d)\")\n    COMMA_STRIP = re.compile(r\"(?<=\\d)(\\,)+(?=\\d)\")\n    PUNCTUATIONS = [\n        \";\",\n        r\"/\",\n        \"[\",\n        \"]\",\n        '\"',\n        \"{\",\n        \"}\",\n        \"(\",\n        \")\",\n        \"=\",\n        \"+\",\n        \"\\\\\",\n        \"_\",\n        \"-\",\n        \">\",\n        \"<\",\n        \"@\",\n        \"`\",\n        \",\",\n        \"?\",\n        \"!\",\n    ]\n\n    def __init__(self, *args, **kwargs):\n        pass\n\n    def word_tokenize(self, word):\n        word = word.lower()\n        word = word.replace(\",\", \"\").replace(\"?\", \"\").replace(\"'s\", \" 's\")\n        return word.strip()\n\n    def process_punctuation(self, in_text):\n        out_text = in_text\n        for p in self.PUNCTUATIONS:\n            if (p + \" \" in in_text or \" \" + p in in_text) or (\n                re.search(self.COMMA_STRIP, in_text) is not None\n            ):\n                out_text = out_text.replace(p, \"\")\n            else:\n                out_text = out_text.replace(p, \" \")\n        out_text = self.PERIOD_STRIP.sub(\"\", out_text, re.UNICODE)\n        return out_text\n\n    def process_digit_article(self, in_text):\n        out_text = []\n        temp_text = in_text.lower().split()\n        for word in temp_text:\n            word = self.NUMBER_MAP.setdefault(word, word)\n            if word not in self.ARTICLES:\n                out_text.append(word)\n            else:\n                pass\n        for word_id, word in enumerate(out_text):\n            if word in self.CONTRACTIONS:\n                out_text[word_id] = self.CONTRACTIONS[word]\n        out_text = \" \".join(out_text)\n        return out_text\n\n    def __call__(self, item):\n        item = self.word_tokenize(item)\n        item = item.replace(\"\\n\", \" \").replace(\"\\t\", \" \").strip()\n        item = self.process_punctuation(item)\n        item = self.process_digit_article(item)\n        return item\n\n\nclass TextVQAAccuracyEvaluator:\n    def __init__(self):\n        self.answer_processor = EvalAIAnswerProcessor()\n\n    def _compute_answer_scores(self, raw_answers):\n        \"\"\"\n        compute the accuracy (soft score) of human answers\n        \"\"\"\n        answers = [self.answer_processor(a) for a in raw_answers]\n        assert len(answers) == 10\n        gt_answers = list(enumerate(answers))\n        unique_answers = set(answers)\n        unique_answer_scores = {}\n\n        for unique_answer in unique_answers:\n            accs = []\n            for gt_answer in gt_answers:\n                other_answers = [item for item in gt_answers if item != gt_answer]\n                matching_answers = [\n                    item for item in other_answers if item[1] == unique_answer\n                ]\n                acc = min(1, float(len(matching_answers)) / 3)\n                accs.append(acc)\n            unique_answer_scores[unique_answer] = sum(accs) / len(accs)\n\n        return unique_answer_scores\n\n    def eval_pred_list(self, pred_list):\n        pred_scores = []\n        for entry in tqdm(pred_list):\n            pred_answer = self.answer_processor(entry[\"pred_answer\"])\n            unique_answer_scores = self._compute_answer_scores(entry[\"gt_answers\"])\n            score = unique_answer_scores.get(pred_answer, 0.0)\n            pred_scores.append(score)\n\n        accuracy = sum(pred_scores) / len(pred_scores)\n        return accuracy\n\n\nclass STVQAAccuracyEvaluator:\n    def __init__(self):\n        self.answer_processor = EvalAIAnswerProcessor()\n\n    def eval_pred_list(self, pred_list):\n        pred_scores = []\n        for entry in pred_list:\n            pred_answer = self.answer_processor(entry[\"pred_answer\"])\n            gts = [self.answer_processor(a) for a in entry[\"gt_answers\"]]\n            score = 1.0 if pred_answer in gts else 0.0\n            pred_scores.append(score)\n\n        accuracy = sum(pred_scores) / len(pred_scores)\n        return accuracy\n\n\nclass STVQAANLSEvaluator:\n    def __init__(self):\n        import editdistance  # install with `pip install editdistance`\n\n        self.get_edit_distance = editdistance.eval\n\n    def get_anls(self, s1, s2):\n        s1 = s1.lower().strip()\n        s2 = s2.lower().strip()\n        iou = 1 - self.get_edit_distance(s1, s2) / max(len(s1), len(s2))\n        anls = iou if iou >= 0.5 else 0.0\n        return anls\n\n    def eval_pred_list(self, pred_list):\n        pred_scores = []\n        for entry in pred_list:\n            anls = max(\n                self.get_anls(entry[\"pred_answer\"], gt) for gt in entry[\"gt_answers\"]\n            )\n            pred_scores.append(anls)\n\n        accuracy = sum(pred_scores) / len(pred_scores)\n        return accuracy\n\n\nclass TextCapsBleu4Evaluator:\n    def __init__(self):\n        # The following script requires Java 1.8.0 and pycocotools installed.\n        # The pycocoevalcap can be installed with pip as\n        # pip install git+https://github.com/ronghanghu/coco-caption.git@python23\n        # Original pycocoevalcap code is at https://github.com/tylin/coco-caption\n        # but has no python3 support yet.\n        try:\n            from pycocoevalcap.bleu.bleu import Bleu\n            from pycocoevalcap.tokenizer.ptbtokenizer import PTBTokenizer\n        except ModuleNotFoundError:\n            print(\n                \"Please install pycocoevalcap module using \"\n                \"pip install git+https://github.com/ronghanghu/coco-caption.git@python23\"  # noqa\n            )\n            raise\n\n        self.tokenizer = PTBTokenizer()\n        self.scorer = Bleu(4)\n\n    def eval_pred_list(self, pred_list):\n        # Create reference and hypotheses captions.\n        gts = {}\n        res = {}\n        for idx, entry in enumerate(pred_list):\n            gts[idx] = [{\"caption\": a} for a in entry[\"gt_answers\"]]\n            res[idx] = [{\"caption\": entry[\"pred_answer\"]}]\n\n        gts = self.tokenizer.tokenize(gts)\n        res = self.tokenizer.tokenize(res)\n        score, _ = self.scorer.compute_score(gts, res)\n\n        bleu4 = score[3]  # score is (Bleu-1, Bleu-2, Bleu-3, Bleu-4)\n        return bleu4\n"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/configuration_mpt.py", "content": "\"\"\"A HuggingFace-style model configuration.\"\"\"\nfrom typing import Dict, Optional, Union\nfrom transformers import PretrainedConfig\nattn_config_defaults: Dict = {'attn_type': 'multihead_attention', 'attn_pdrop': 0.0, 'attn_impl': 'triton', 'qk_ln': False, 'clip_qkv': None, 'softmax_scale': None, 'prefix_lm': False, 'attn_uses_sequence_id': False, 'alibi': False, 'alibi_bias_max': 8}\ninit_config_defaults: Dict = {'name': 'kaiming_normal_', 'fan_mode': 'fan_in', 'init_nonlinearity': 'relu', 'init_div_is_residual': True, 'emb_init_std': None, 'emb_init_uniform_lim': None, 'init_std': None, 'init_gain': 0.0}\n\nclass MPTConfig(PretrainedConfig):\n    model_type = 'mpt'\n\n    def __init__(self, d_model: int=2048, n_heads: int=16, n_layers: int=24, expansion_ratio: int=4, max_seq_len: int=2048, vocab_size: int=50368, resid_pdrop: float=0.0, emb_pdrop: float=0.0, learned_pos_emb: bool=True, attn_config: Dict=attn_config_defaults, init_device: str='cpu', logit_scale: Optional[Union[float, str]]=None, no_bias: bool=False, verbose: int=0, embedding_fraction: float=1.0, norm_type: str='low_precision_layernorm', use_cache: bool=False, init_config: Dict=init_config_defaults, **kwargs):\n        \"\"\"The MPT configuration class.\n\n        Args:\n            d_model (int): The size of the embedding dimension of the model.\n            n_heads (int): The number of attention heads.\n            n_layers (int): The number of layers in the model.\n            expansion_ratio (int): The ratio of the up/down scale in the MLP.\n            max_seq_len (int): The maximum sequence length of the model.\n            vocab_size (int): The size of the vocabulary.\n            resid_pdrop (float): The dropout probability applied to the attention output before combining with residual.\n            emb_pdrop (float): The dropout probability for the embedding layer.\n            learned_pos_emb (bool): Whether to use learned positional embeddings\n            attn_config (Dict):  A dictionary used to configure the model's attention module:\n                attn_type (str): type of attention to use. Options: multihead_attention, multiquery_attention\n                attn_pdrop (float): The dropout probability for the attention layers.\n                attn_impl (str): The attention implementation to use. One of 'torch', 'flash', or 'triton'.\n                qk_ln (bool): Whether to apply layer normalization to the queries and keys in the attention layer.\n                clip_qkv (Optional[float]): If not None, clip the queries, keys, and values in the attention layer to\n                    this value.\n                softmax_scale (Optional[float]): If not None, scale the softmax in the attention layer by this value. If None,\n                    use the default scale of ``1/sqrt(d_keys)``.\n                prefix_lm (Optional[bool]): Whether the model should operate as a Prefix LM. This requires passing an\n                    extra `prefix_mask` argument which indicates which tokens belong to the prefix. Tokens in the prefix\n                    can attend to one another bi-directionally. Tokens outside the prefix use causal attention.\n                attn_uses_sequence_id (Optional[bool]): Whether to restrict attention to tokens that have the same sequence_id.\n                    When the model is in `train` mode, this requires passing an extra `sequence_id` argument which indicates\n                    which sub-sequence each token belongs to.\n                    Defaults to ``False`` meaning any provided `sequence_id` will be ignored.\n                alibi (bool): Whether to use the alibi bias instead of position embeddings.\n                alibi_bias_max (int): The maximum value of the alibi bias.\n            init_device (str): The device to use for parameter initialization.\n            logit_scale (Optional[Union[float, str]]): If not None, scale the logits by this value.\n            no_bias (bool): Whether to use bias in all layers.\n            verbose (int): The verbosity level. 0 is silent.\n            embedding_fraction (float): The fraction to scale the gradients of the embedding layer by.\n            norm_type (str): choose type of norm to use\n            multiquery_attention (bool): Whether to use multiquery attention implementation.\n            use_cache (bool): Whether or not the model should return the last key/values attentions\n            init_config (Dict): A dictionary used to configure the model initialization:\n                init_config.name: The parameter initialization scheme to use. Options: 'default_', 'baseline_',\n                    'kaiming_uniform_', 'kaiming_normal_', 'neox_init_', 'small_init_', 'xavier_uniform_', or\n                    'xavier_normal_'. These mimic the parameter initialization methods in PyTorch.\n                init_div_is_residual (Union[int, float, str, bool]): Value to divide initial weights by if ``module._is_residual`` is True.\n                emb_init_std (Optional[float]): The standard deviation of the normal distribution used to initialize the embedding layer.\n                emb_init_uniform_lim (Optional[Union[Tuple[float, float], float]]): The lower and upper limits of the uniform distribution\n                    used to initialize the embedding layer. Mutually exclusive with ``emb_init_std``.\n                init_std (float): The standard deviation of the normal distribution used to initialize the model,\n                    if using the baseline_ parameter initialization scheme.\n                init_gain (float): The gain to use for parameter initialization with kaiming or xavier initialization schemes.\n                fan_mode (str): The fan mode to use for parameter initialization with kaiming initialization schemes.\n                init_nonlinearity (str): The nonlinearity to use for parameter initialization with kaiming initialization schemes.\n                ---\n                See llmfoundry.models.utils.param_init_fns.py for info on other param init config options\n        \"\"\"\n        self.d_model = d_model\n        self.n_heads = n_heads\n        self.n_layers = n_layers\n        self.expansion_ratio = expansion_ratio\n        self.max_seq_len = max_seq_len\n        self.vocab_size = vocab_size\n        self.resid_pdrop = resid_pdrop\n        self.emb_pdrop = emb_pdrop\n        self.learned_pos_emb = learned_pos_emb\n        self.attn_config = attn_config\n        self.init_device = init_device\n        self.logit_scale = logit_scale\n        self.no_bias = no_bias\n        self.verbose = verbose\n        self.embedding_fraction = embedding_fraction\n        self.norm_type = norm_type\n        self.use_cache = use_cache\n        self.init_config = init_config\n        if 'name' in kwargs:\n            del kwargs['name']\n        if 'loss_fn' in kwargs:\n            del kwargs['loss_fn']\n        super().__init__(**kwargs)\n        self._validate_config()\n\n    def _set_config_defaults(self, config, config_defaults):\n        for (k, v) in config_defaults.items():\n            if k not in config:\n                config[k] = v\n        return config\n\n    def _validate_config(self):\n        self.attn_config = self._set_config_defaults(self.attn_config, attn_config_defaults)\n        self.init_config = self._set_config_defaults(self.init_config, init_config_defaults)\n        if self.d_model % self.n_heads != 0:\n            raise ValueError('d_model must be divisible by n_heads')\n        if any((prob < 0 or prob > 1 for prob in [self.attn_config['attn_pdrop'], self.resid_pdrop, self.emb_pdrop])):\n            raise ValueError(\"self.attn_config['attn_pdrop'], resid_pdrop, emb_pdrop are probabilities and must be between 0 and 1\")\n        if self.attn_config['attn_impl'] not in ['torch', 'flash', 'triton']:\n            raise ValueError(f\"Unknown attn_impl={self.attn_config['attn_impl']}\")\n        if self.attn_config['prefix_lm'] and self.attn_config['attn_impl'] not in ['torch', 'triton']:\n            raise NotImplementedError('prefix_lm only implemented with torch and triton attention.')\n        if self.attn_config['alibi'] and self.attn_config['attn_impl'] not in ['torch', 'triton']:\n            raise NotImplementedError('alibi only implemented with torch and triton attention.')\n        if self.attn_config['attn_uses_sequence_id'] and self.attn_config['attn_impl'] not in ['torch', 'triton']:\n            raise NotImplementedError('attn_uses_sequence_id only implemented with torch and triton attention.')\n        if self.embedding_fraction > 1 or self.embedding_fraction <= 0:\n            raise ValueError('model.embedding_fraction must be between 0 (exclusive) and 1 (inclusive)!')\n        if isinstance(self.logit_scale, str) and self.logit_scale != 'inv_sqrt_d_model':\n            raise ValueError(f\"self.logit_scale={self.logit_scale!r} is not recognized as an option; use numeric value or 'inv_sqrt_d_model'.\")\n        if self.init_config.get('name', None) is None:\n            raise ValueError(f\"self.init_config={self.init_config!r} 'name' needs to be set.\")\n        if not self.learned_pos_emb and (not self.attn_config['alibi']):\n            raise ValueError(f'Positional information must be provided to the model using either learned_pos_emb or alibi.')"}
{"type": "source_file", "path": "LLaVA/llava/eval/eval_gpt_review_bench.py", "content": "import argparse\nimport json\nimport os\n\nimport openai\nimport time\n\nNUM_SECONDS_TO_SLEEP = 0.5\n\n\ndef get_eval(content: str, max_tokens: int):\n    while True:\n        try:\n            response = openai.ChatCompletion.create(\n                model='gpt-4-0314',\n                messages=[{\n                    'role': 'system',\n                    'content': 'You are a helpful and precise assistant for checking the quality of the answer.'\n                }, {\n                    'role': 'user',\n                    'content': content,\n                }],\n                temperature=0.2,  # TODO: figure out which temperature is best for evaluation\n                max_tokens=max_tokens,\n            )\n            break\n        except openai.error.RateLimitError:\n            pass\n        except Exception as e:\n            print(e)\n        time.sleep(NUM_SECONDS_TO_SLEEP)\n\n    return response['choices'][0]['message']['content']\n\n\ndef parse_score(review):\n    try:\n        score_pair = review.split('\\n')[0]\n        score_pair = score_pair.replace(',', ' ')\n        sp = score_pair.split(' ')\n        if len(sp) == 2:\n            return [float(sp[0]), float(sp[1])]\n        else:\n            print('error', review)\n            return [-1, -1]\n    except Exception as e:\n        print(e)\n        print('error', review)\n        return [-1, -1]\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='ChatGPT-based QA evaluation.')\n    parser.add_argument('-q', '--question')\n    parser.add_argument('-c', '--context')\n    parser.add_argument('-a', '--answer-list', nargs='+', default=[])\n    parser.add_argument('-r', '--rule')\n    parser.add_argument('-o', '--output')\n    parser.add_argument('--max-tokens', type=int, default=1024, help='maximum number of tokens produced in the output')\n    args = parser.parse_args()\n\n    f_q = open(os.path.expanduser(args.question))\n    f_ans1 = open(os.path.expanduser(args.answer_list[0]))\n    f_ans2 = open(os.path.expanduser(args.answer_list[1]))\n    rule_dict = json.load(open(os.path.expanduser(args.rule), 'r'))\n\n    if os.path.isfile(os.path.expanduser(args.output)):\n        cur_reviews = [json.loads(line) for line in open(os.path.expanduser(args.output))]\n    else:\n        cur_reviews = []\n\n    review_file = open(f'{args.output}', 'a')\n\n    context_list = [json.loads(line) for line in open(os.path.expanduser(args.context))]\n    image_to_context = {context['image']: context for context in context_list}\n\n    handles = []\n    idx = 0\n    for ques_js, ans1_js, ans2_js in zip(f_q, f_ans1, f_ans2):\n        ques = json.loads(ques_js)\n        ans1 = json.loads(ans1_js)\n        ans2 = json.loads(ans2_js)\n\n        inst = image_to_context[ques['image']]\n\n        if isinstance(inst['caption'], list):\n            cap_str = '\\n'.join(inst['caption'])\n        else:\n            cap_str = inst['caption']\n\n        category = 'llava_bench_' + json.loads(ques_js)['category']\n        if category in rule_dict:\n            rule = rule_dict[category]\n        else:\n            assert False, f\"Visual QA category not found in rule file: {category}.\"\n        prompt = rule['prompt']\n        role = rule['role']\n        content = (f'[Context]\\n{cap_str}\\n\\n'\n                   f'[Question]\\n{ques[\"text\"]}\\n\\n'\n                   f'[{role} 1]\\n{ans1[\"text\"]}\\n\\n[End of {role} 1]\\n\\n'\n                   f'[{role} 2]\\n{ans2[\"text\"]}\\n\\n[End of {role} 2]\\n\\n'\n                   f'[System]\\n{prompt}\\n\\n')\n        cur_js = {\n            'id': idx+1,\n            'question_id': ques['question_id'],\n            'answer1_id': ans1.get('answer_id', ans1['question_id']),\n            'answer2_id': ans2.get('answer_id', ans2['answer_id']),\n            'category': category\n        }\n        if idx >= len(cur_reviews):\n            review = get_eval(content, args.max_tokens)\n            scores = parse_score(review)\n            cur_js['content'] = review\n            cur_js['tuple'] = scores\n            review_file.write(json.dumps(cur_js) + '\\n')\n            review_file.flush()\n        else:\n            print(f'Skipping {idx} as we already have it.')\n        idx += 1\n        print(idx)\n    review_file.close()\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/model_vqa_loader.py", "content": "import argparse\nimport torch\nimport os\nimport json\nfrom tqdm import tqdm\nimport shortuuid\n\nfrom llava.constants import IMAGE_TOKEN_INDEX, DEFAULT_IMAGE_TOKEN, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN\nfrom llava.conversation import conv_templates, SeparatorStyle\nfrom llava.model.builder import load_pretrained_model\nfrom llava.utils import disable_torch_init\nfrom llava.mm_utils import tokenizer_image_token, process_images, get_model_name_from_path\nfrom torch.utils.data import Dataset, DataLoader\n\nfrom PIL import Image\nimport math\n\n\ndef split_list(lst, n):\n    \"\"\"Split a list into n (roughly) equal-sized chunks\"\"\"\n    chunk_size = math.ceil(len(lst) / n)  # integer division\n    return [lst[i:i+chunk_size] for i in range(0, len(lst), chunk_size)]\n\n\ndef get_chunk(lst, n, k):\n    chunks = split_list(lst, n)\n    return chunks[k]\n\n\n# Custom dataset class\nclass CustomDataset(Dataset):\n    def __init__(self, questions, image_folder, tokenizer, image_processor, model_config):\n        self.questions = questions\n        self.image_folder = image_folder\n        self.tokenizer = tokenizer\n        self.image_processor = image_processor\n        self.model_config = model_config\n\n    def __getitem__(self, index):\n        line = self.questions[index]\n        image_file = line[\"image\"]\n        qs = line[\"text\"]\n        if self.model_config.mm_use_im_start_end:\n            qs = DEFAULT_IM_START_TOKEN + DEFAULT_IMAGE_TOKEN + DEFAULT_IM_END_TOKEN + '\\n' + qs\n        else:\n            qs = DEFAULT_IMAGE_TOKEN + '\\n' + qs\n\n        conv = conv_templates[args.conv_mode].copy()\n        conv.append_message(conv.roles[0], qs)\n        conv.append_message(conv.roles[1], None)\n        prompt = conv.get_prompt()\n\n        image = Image.open(os.path.join(self.image_folder, image_file)).convert('RGB')\n        image_tensor = process_images([image], self.image_processor, self.model_config)[0]\n\n        input_ids = tokenizer_image_token(prompt, self.tokenizer, IMAGE_TOKEN_INDEX, return_tensors='pt')\n\n        return input_ids, image_tensor\n\n    def __len__(self):\n        return len(self.questions)\n\n\n# DataLoader\ndef create_data_loader(questions, image_folder, tokenizer, image_processor, model_config, batch_size=1, num_workers=4):\n    assert batch_size == 1, \"batch_size must be 1\"\n    dataset = CustomDataset(questions, image_folder, tokenizer, image_processor, model_config)\n    data_loader = DataLoader(dataset, batch_size=batch_size, num_workers=num_workers, shuffle=False)\n    return data_loader\n\n\ndef eval_model(args):\n    # Model\n    disable_torch_init()\n    model_path = os.path.expanduser(args.model_path)\n    model_name = get_model_name_from_path(model_path)\n    tokenizer, model, image_processor, context_len = load_pretrained_model(model_path, args.model_base, model_name)\n\n    questions = [json.loads(q) for q in open(os.path.expanduser(args.question_file), \"r\")]\n    questions = get_chunk(questions, args.num_chunks, args.chunk_idx)\n    answers_file = os.path.expanduser(args.answers_file)\n    os.makedirs(os.path.dirname(answers_file), exist_ok=True)\n    ans_file = open(answers_file, \"w\")\n\n    if 'plain' in model_name and 'finetune' not in model_name.lower() and 'mmtag' not in args.conv_mode:\n        args.conv_mode = args.conv_mode + '_mmtag'\n        print(f'It seems that this is a plain model, but it is not using a mmtag prompt, auto switching to {args.conv_mode}.')\n\n    data_loader = create_data_loader(questions, args.image_folder, tokenizer, image_processor, model.config)\n\n    for (input_ids, image_tensor), line in tqdm(zip(data_loader, questions), total=len(questions)):\n        idx = line[\"question_id\"]\n        cur_prompt = line[\"text\"]\n\n        stop_str = conv_templates[args.conv_mode].sep if conv_templates[args.conv_mode].sep_style != SeparatorStyle.TWO else conv_templates[args.conv_mode].sep2\n        input_ids = input_ids.to(device='cuda', non_blocking=True)\n\n        with torch.inference_mode():\n            output_ids = model.generate(\n                input_ids,\n                images=image_tensor.to(dtype=torch.float16, device='cuda', non_blocking=True),\n                do_sample=True if args.temperature > 0 else False,\n                temperature=args.temperature,\n                top_p=args.top_p,\n                num_beams=args.num_beams,\n                max_new_tokens=128,\n                use_cache=True)\n\n        input_token_len = input_ids.shape[1]\n        n_diff_input_output = (input_ids != output_ids[:, :input_token_len]).sum().item()\n        if n_diff_input_output > 0:\n            print(f'[Warning] {n_diff_input_output} output_ids are not the same as the input_ids')\n        outputs = tokenizer.batch_decode(output_ids[:, input_token_len:], skip_special_tokens=True)[0]\n        outputs = outputs.strip()\n        if outputs.endswith(stop_str):\n            outputs = outputs[:-len(stop_str)]\n        outputs = outputs.strip()\n\n        ans_id = shortuuid.uuid()\n        ans_file.write(json.dumps({\"question_id\": idx,\n                                   \"prompt\": cur_prompt,\n                                   \"text\": outputs,\n                                   \"answer_id\": ans_id,\n                                   \"model_id\": model_name,\n                                   \"metadata\": {}}) + \"\\n\")\n        # ans_file.flush()\n    ans_file.close()\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model-path\", type=str, default=\"facebook/opt-350m\")\n    parser.add_argument(\"--model-base\", type=str, default=None)\n    parser.add_argument(\"--image-folder\", type=str, default=\"\")\n    parser.add_argument(\"--question-file\", type=str, default=\"tables/question.jsonl\")\n    parser.add_argument(\"--answers-file\", type=str, default=\"answer.jsonl\")\n    parser.add_argument(\"--conv-mode\", type=str, default=\"llava_v1\")\n    parser.add_argument(\"--num-chunks\", type=int, default=1)\n    parser.add_argument(\"--chunk-idx\", type=int, default=0)\n    parser.add_argument(\"--temperature\", type=float, default=0.2)\n    parser.add_argument(\"--top_p\", type=float, default=None)\n    parser.add_argument(\"--num_beams\", type=int, default=1)\n    args = parser.parse_args()\n\n    eval_model(args)\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/model_vqa_mmbench.py", "content": "import argparse\nimport torch\nimport os\nimport json\nimport pandas as pd\nfrom tqdm import tqdm\nimport shortuuid\n\nfrom llava.constants import IMAGE_TOKEN_INDEX, DEFAULT_IMAGE_TOKEN, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN\nfrom llava.conversation import conv_templates, SeparatorStyle\nfrom llava.model.builder import load_pretrained_model\nfrom llava.utils import disable_torch_init\nfrom llava.mm_utils import tokenizer_image_token, process_images, load_image_from_base64, get_model_name_from_path\n\nfrom PIL import Image\nimport math\n\n\nall_options = ['A', 'B', 'C', 'D']\n\n\ndef split_list(lst, n):\n    \"\"\"Split a list into n (roughly) equal-sized chunks\"\"\"\n    chunk_size = math.ceil(len(lst) / n)  # integer division\n    return [lst[i:i+chunk_size] for i in range(0, len(lst), chunk_size)]\n\n\ndef get_chunk(lst, n, k):\n    chunks = split_list(lst, n)\n    return chunks[k]\n\n\ndef is_none(value):\n    if value is None:\n        return True\n    if type(value) is float and math.isnan(value):\n        return True\n    if type(value) is str and value.lower() == 'nan':\n        return True\n    if type(value) is str and value.lower() == 'none':\n        return True\n    return False\n\ndef get_options(row, options):\n    parsed_options = []\n    for option in options:\n        option_value = row[option]\n        if is_none(option_value):\n            break\n        parsed_options.append(option_value)\n    return parsed_options\n\n\ndef eval_model(args):\n    # Model\n    disable_torch_init()\n    model_path = os.path.expanduser(args.model_path)\n    model_name = get_model_name_from_path(model_path)\n    tokenizer, model, image_processor, context_len = load_pretrained_model(model_path, args.model_base, model_name)\n\n    questions = pd.read_table(os.path.expanduser(args.question_file))\n    questions = get_chunk(questions, args.num_chunks, args.chunk_idx)\n    answers_file = os.path.expanduser(args.answers_file)\n    os.makedirs(os.path.dirname(answers_file), exist_ok=True)\n    ans_file = open(answers_file, \"w\")\n\n    if 'plain' in model_name and 'finetune' not in model_name.lower() and 'mmtag' not in args.conv_mode:\n        args.conv_mode = args.conv_mode + '_mmtag'\n        print(f'It seems that this is a plain model, but it is not using a mmtag prompt, auto switching to {args.conv_mode}.')\n\n    for index, row in tqdm(questions.iterrows(), total=len(questions)):\n        options = get_options(row, all_options)\n        cur_option_char = all_options[:len(options)]\n\n        if args.all_rounds:\n            num_rounds = len(options)\n        else:\n            num_rounds = 1\n\n        for round_idx in range(num_rounds):\n            idx = row['index']\n            question = row['question']\n            hint = row['hint']\n            image = load_image_from_base64(row['image'])\n            if not is_none(hint):\n                question = hint + '\\n' + question\n            for option_char, option in zip(all_options[:len(options)], options):\n                question = question + '\\n' + option_char + '. ' + option\n            qs = cur_prompt = question\n            if model.config.mm_use_im_start_end:\n                qs = DEFAULT_IM_START_TOKEN + DEFAULT_IMAGE_TOKEN + DEFAULT_IM_END_TOKEN + '\\n' + qs\n            else:\n                qs = DEFAULT_IMAGE_TOKEN + '\\n' + qs\n\n            if args.single_pred_prompt:\n                if args.lang == 'cn':\n                    qs = qs + '\\n' + \"请直接回答选项字母。\"\n                else:\n                    qs = qs + '\\n' + \"Answer with the option's letter from the given choices directly.\"\n\n            conv = conv_templates[args.conv_mode].copy()\n            conv.append_message(conv.roles[0], qs)\n            conv.append_message(conv.roles[1], None)\n            prompt = conv.get_prompt()\n\n            input_ids = tokenizer_image_token(prompt, tokenizer, IMAGE_TOKEN_INDEX, return_tensors='pt').unsqueeze(0).cuda()\n\n            image_tensor = process_images([image], image_processor, model.config)[0]\n            # image_tensor = image_processor.preprocess(image, return_tensors='pt')['pixel_values'][0]\n\n            stop_str = conv.sep if conv.sep_style != SeparatorStyle.TWO else conv.sep2\n\n            with torch.inference_mode():\n                output_ids = model.generate(\n                    input_ids,\n                    images=image_tensor.unsqueeze(0).half().cuda(),\n                    do_sample=True if args.temperature > 0 else False,\n                    temperature=args.temperature,\n                    top_p=args.top_p,\n                    num_beams=args.num_beams,\n                    # no_repeat_ngram_size=3,\n                    max_new_tokens=1024,\n                    use_cache=True)\n\n            input_token_len = input_ids.shape[1]\n            n_diff_input_output = (input_ids != output_ids[:, :input_token_len]).sum().item()\n            if n_diff_input_output > 0:\n                print(f'[Warning] {n_diff_input_output} output_ids are not the same as the input_ids')\n            outputs = tokenizer.batch_decode(output_ids[:, input_token_len:], skip_special_tokens=True)[0]\n            outputs = outputs.strip()\n            if outputs.endswith(stop_str):\n                outputs = outputs[:-len(stop_str)]\n            outputs = outputs.strip()\n\n            ans_id = shortuuid.uuid()\n            ans_file.write(json.dumps({\"question_id\": idx,\n                                    \"round_id\": round_idx,\n                                    \"prompt\": cur_prompt,\n                                    \"text\": outputs,\n                                    \"options\": options,\n                                    \"option_char\": cur_option_char,\n                                    \"answer_id\": ans_id,\n                                    \"model_id\": model_name,\n                                    \"metadata\": {}}) + \"\\n\")\n            ans_file.flush()\n\n            # rotate options\n            options = options[1:] + options[:1]\n            cur_option_char = cur_option_char[1:] + cur_option_char[:1]\n    ans_file.close()\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model-path\", type=str, default=\"facebook/opt-350m\")\n    parser.add_argument(\"--model-base\", type=str, default=None)\n    parser.add_argument(\"--image-folder\", type=str, default=\"\")\n    parser.add_argument(\"--question-file\", type=str, default=\"tables/question.jsonl\")\n    parser.add_argument(\"--answers-file\", type=str, default=\"answer.jsonl\")\n    parser.add_argument(\"--conv-mode\", type=str, default=\"llava_v1\")\n    parser.add_argument(\"--num-chunks\", type=int, default=1)\n    parser.add_argument(\"--chunk-idx\", type=int, default=0)\n    parser.add_argument(\"--temperature\", type=float, default=0.2)\n    parser.add_argument(\"--top_p\", type=float, default=None)\n    parser.add_argument(\"--num_beams\", type=int, default=1)\n    parser.add_argument(\"--all-rounds\", action=\"store_true\")\n    parser.add_argument(\"--single-pred-prompt\", action=\"store_true\")\n    parser.add_argument(\"--lang\", type=str, default=\"en\")\n    args = parser.parse_args()\n\n    eval_model(args)\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/eval_science_qa_gpt4.py", "content": "import argparse\nimport json\nimport os\nimport re\nimport random\nfrom collections import defaultdict\n\n\ndef get_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-dir', type=str)\n    parser.add_argument('--gpt4-result', type=str)\n    parser.add_argument('--our-result', type=str)\n    parser.add_argument('--split', type=str, default='test')\n    parser.add_argument('--options', type=list, default=[\"A\", \"B\", \"C\", \"D\", \"E\"])\n    return parser.parse_args()\n\n\ndef convert_caps(results):\n    fakecaps = []\n    for result in results:\n        image_id = result['question_id']\n        caption = result['text']\n        fakecaps.append({\"image_id\": int(image_id), \"caption\": caption})\n    return fakecaps\n\n\ndef get_pred_idx(prediction, choices, options):\n    \"\"\"\n    Get the index (e.g. 2) from the prediction (e.g. 'C')\n    \"\"\"\n    if prediction in options[:len(choices)]:\n        return options.index(prediction)\n    else:\n        return random.choice(range(len(choices)))\n\n\nif __name__ == \"__main__\":\n    args = get_args()\n\n    base_dir = args.base_dir\n    split_indices = json.load(open(os.path.join(base_dir, \"pid_splits.json\")))[args.split]\n    problems = json.load(open(os.path.join(base_dir, \"problems.json\")))\n    our_predictions = [json.loads(line) for line in open(args.our_result)]\n    our_predictions = {pred['question_id']: pred for pred in our_predictions}\n    split_problems = {idx: problems[idx] for idx in split_indices}\n\n    gpt4_predictions = json.load(open(args.gpt4_result))['outputs']\n\n    results = defaultdict(lambda: 0)\n\n    for prob_id, prob in split_problems.items():\n        if prob_id not in our_predictions:\n            continue\n        if prob_id not in gpt4_predictions:\n            continue\n        our_pred = our_predictions[prob_id]['text']\n        gpt4_pred = gpt4_predictions[prob_id]\n\n        pattern = re.compile(r'The answer is ([A-Z]).')\n        our_res = pattern.findall(our_pred)\n        if len(our_res) == 1:\n            our_answer = our_res[0]  # 'A', 'B', ...\n        else:\n            our_answer = \"FAILED\"\n        gpt4_res = pattern.findall(gpt4_pred)\n        if len(gpt4_res) == 1:\n            gpt4_answer = gpt4_res[0]  # 'A', 'B', ...\n        else:\n            gpt4_answer = \"FAILED\"\n\n        our_pred_idx = get_pred_idx(our_answer, prob['choices'], args.options)\n        gpt4_pred_idx = get_pred_idx(gpt4_answer, prob['choices'], args.options)\n\n        if gpt4_answer == 'FAILED':\n            results['gpt4_failed'] += 1\n            # continue\n            gpt4_pred_idx = our_pred_idx\n            # if our_pred_idx != prob['answer']:\n            #     print(our_predictions[prob_id]['prompt'])\n            #     print('-----------------')\n            #     print(f'LECTURE: {prob[\"lecture\"]}')\n            #     print(f'SOLUTION: {prob[\"solution\"]}')\n            #     print('=====================')\n        else:\n            # continue\n            pass\n        # gpt4_pred_idx = our_pred_idx\n\n        if gpt4_pred_idx == prob['answer']:\n            results['correct'] += 1\n        else:\n            results['incorrect'] += 1\n\n\n        if gpt4_pred_idx == prob['answer'] or our_pred_idx == prob['answer']:\n            results['correct_upperbound'] += 1\n\n    correct = results['correct']\n    total = results['correct'] + results['incorrect']\n    print(f'Total: {total}, Correct: {correct}, Accuracy: {correct / total * 100:.2f}%')\n    print(f'Total: {total}, Correct (upper): {results[\"correct_upperbound\"]}, Accuracy: {results[\"correct_upperbound\"] / total * 100:.2f}%')\n    print(f'Total: {total}, GPT-4 NO-ANS (RANDOM): {results[\"gpt4_failed\"]}, Percentage: {results[\"gpt4_failed\"] / total * 100:.2f}%')\n\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/eval_gpt_review_visual.py", "content": "import argparse\nimport json\nimport os\n\nimport openai\nimport time\n\nNUM_SECONDS_TO_SLEEP = 0.5\n\n\ndef get_eval(content: str, max_tokens: int):\n    while True:\n        try:\n            response = openai.ChatCompletion.create(\n                model='gpt-4-0314',\n                messages=[{\n                    'role': 'system',\n                    'content': 'You are a helpful and precise assistant for checking the quality of the answer.'\n                }, {\n                    'role': 'user',\n                    'content': content,\n                }],\n                temperature=0.2,  # TODO: figure out which temperature is best for evaluation\n                max_tokens=max_tokens,\n            )\n            break\n        except openai.error.RateLimitError:\n            pass\n        except Exception as e:\n            print(e)\n        time.sleep(NUM_SECONDS_TO_SLEEP)\n\n    return response['choices'][0]['message']['content']\n\n\ndef parse_score(review):\n    try:\n        score_pair = review.split('\\n')[0]\n        score_pair = score_pair.replace(',', ' ')\n        sp = score_pair.split(' ')\n        if len(sp) == 2:\n            return [float(sp[0]), float(sp[1])]\n        else:\n            print('error', review)\n            return [-1, -1]\n    except Exception as e:\n        print(e)\n        print('error', review)\n        return [-1, -1]\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='ChatGPT-based QA evaluation.')\n    parser.add_argument('-q', '--question')\n    parser.add_argument('-c', '--context')\n    parser.add_argument('-a', '--answer-list', nargs='+', default=[])\n    parser.add_argument('-r', '--rule')\n    parser.add_argument('-o', '--output')\n    parser.add_argument('--max-tokens', type=int, default=1024, help='maximum number of tokens produced in the output')\n    args = parser.parse_args()\n\n    f_q = open(os.path.expanduser(args.question))\n    f_ans1 = open(os.path.expanduser(args.answer_list[0]))\n    f_ans2 = open(os.path.expanduser(args.answer_list[1]))\n    rule_dict = json.load(open(os.path.expanduser(args.rule), 'r'))\n\n    if os.path.isfile(os.path.expanduser(args.output)):\n        cur_reviews = [json.loads(line) for line in open(os.path.expanduser(args.output))]\n    else:\n        cur_reviews = []\n\n    review_file = open(f'{args.output}', 'a')\n\n    context_list = [json.loads(line) for line in open(os.path.expanduser(args.context))]\n    image_to_context = {context['image']: context for context in context_list}\n\n    handles = []\n    idx = 0\n    for ques_js, ans1_js, ans2_js in zip(f_q, f_ans1, f_ans2):\n        ques = json.loads(ques_js)\n        ans1 = json.loads(ans1_js)\n        ans2 = json.loads(ans2_js)\n\n        inst = image_to_context[ques['image']]\n        cap_str = '\\n'.join(inst['captions'])\n        box_str = '\\n'.join([f'{instance[\"category\"]}: {instance[\"bbox\"]}' for instance in inst['instances']])\n\n        category = json.loads(ques_js)['category']\n        if category in rule_dict:\n            rule = rule_dict[category]\n        else:\n            assert False, f\"Visual QA category not found in rule file: {category}.\"\n        prompt = rule['prompt']\n        role = rule['role']\n        content = (f'[Context]\\n{cap_str}\\n\\n{box_str}\\n\\n'\n                   f'[Question]\\n{ques[\"text\"]}\\n\\n'\n                   f'[{role} 1]\\n{ans1[\"text\"]}\\n\\n[End of {role} 1]\\n\\n'\n                   f'[{role} 2]\\n{ans2[\"text\"]}\\n\\n[End of {role} 2]\\n\\n'\n                   f'[System]\\n{prompt}\\n\\n')\n        cur_js = {\n            'id': idx+1,\n            'question_id': ques['question_id'],\n            'answer1_id': ans1.get('answer_id', ans1['question_id']),\n            'answer2_id': ans2.get('answer_id', ans2['answer_id']),\n            'category': category\n        }\n        if idx >= len(cur_reviews):\n            review = get_eval(content, args.max_tokens)\n            scores = parse_score(review)\n            cur_js['content'] = review\n            cur_js['tuple'] = scores\n            review_file.write(json.dumps(cur_js) + '\\n')\n            review_file.flush()\n        else:\n            print(f'Skipping {idx} as we already have it.')\n        idx += 1\n        print(idx)\n    review_file.close()\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/model_vqa_science.py", "content": "import argparse\nimport torch\nimport os\nimport json\nfrom tqdm import tqdm\nimport shortuuid\n\nfrom llava.constants import IMAGE_TOKEN_INDEX, DEFAULT_IMAGE_TOKEN, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN\nfrom llava.conversation import conv_templates, SeparatorStyle\nfrom llava.model.builder import load_pretrained_model\nfrom llava.utils import disable_torch_init\nfrom llava.mm_utils import tokenizer_image_token, get_model_name_from_path, KeywordsStoppingCriteria\n\nfrom PIL import Image\nimport math\n\n\ndef split_list(lst, n):\n    \"\"\"Split a list into n (roughly) equal-sized chunks\"\"\"\n    chunk_size = math.ceil(len(lst) / n)  # integer division\n    return [lst[i:i+chunk_size] for i in range(0, len(lst), chunk_size)]\n\n\ndef get_chunk(lst, n, k):\n    chunks = split_list(lst, n)\n    return chunks[k]\n\n\ndef eval_model(args):\n    # Model\n    disable_torch_init()\n    model_path = os.path.expanduser(args.model_path)\n    model_name = get_model_name_from_path(model_path)\n    tokenizer, model, image_processor, context_len = load_pretrained_model(model_path, args.model_base, model_name)\n\n    questions = json.load(open(os.path.expanduser(args.question_file), \"r\"))\n    questions = get_chunk(questions, args.num_chunks, args.chunk_idx)\n    answers_file = os.path.expanduser(args.answers_file)\n    os.makedirs(os.path.dirname(answers_file), exist_ok=True)\n    ans_file = open(answers_file, \"w\")\n    for i, line in enumerate(tqdm(questions)):\n        idx = line[\"id\"]\n        question = line['conversations'][0]\n        qs = question['value'].replace('<image>', '').strip()\n        cur_prompt = qs\n\n        if 'image' in line:\n            image_file = line[\"image\"]\n            image = Image.open(os.path.join(args.image_folder, image_file))\n            image_tensor = image_processor.preprocess(image, return_tensors='pt')['pixel_values'][0]\n            images = image_tensor.unsqueeze(0).half().cuda()\n            if getattr(model.config, 'mm_use_im_start_end', False):\n                qs = DEFAULT_IM_START_TOKEN + DEFAULT_IMAGE_TOKEN + DEFAULT_IM_END_TOKEN + '\\n' + qs\n            else:\n                qs = DEFAULT_IMAGE_TOKEN + '\\n' + qs\n            cur_prompt = '<image>' + '\\n' + cur_prompt\n        else:\n            images = None\n\n        if args.single_pred_prompt:\n            qs = qs + '\\n' + \"Answer with the option's letter from the given choices directly.\"\n            cur_prompt = cur_prompt + '\\n' + \"Answer with the option's letter from the given choices directly.\"\n\n        conv = conv_templates[args.conv_mode].copy()\n        conv.append_message(conv.roles[0], qs)\n        conv.append_message(conv.roles[1], None)\n        prompt = conv.get_prompt()\n\n        input_ids = tokenizer_image_token(prompt, tokenizer, IMAGE_TOKEN_INDEX, return_tensors='pt').unsqueeze(0).cuda()\n\n        stop_str = conv.sep if conv.sep_style != SeparatorStyle.TWO else conv.sep2\n        keywords = [stop_str]\n        stopping_criteria = [KeywordsStoppingCriteria(keywords, tokenizer, input_ids)] if conv.version == \"v0\" else None\n\n        with torch.inference_mode():\n            output_ids = model.generate(\n                input_ids,\n                images=images,\n                do_sample=True if args.temperature > 0 else False,\n                temperature=args.temperature,\n                max_new_tokens=1024,\n                use_cache=True,\n                stopping_criteria=stopping_criteria,\n            )\n\n        input_token_len = input_ids.shape[1]\n        n_diff_input_output = (input_ids != output_ids[:, :input_token_len]).sum().item()\n        if n_diff_input_output > 0:\n            print(f'[Warning] {n_diff_input_output} output_ids are not the same as the input_ids')\n        outputs = tokenizer.batch_decode(output_ids[:, input_token_len:], skip_special_tokens=True)[0]\n        outputs = outputs.strip()\n        if outputs.endswith(stop_str):\n            outputs = outputs[:-len(stop_str)]\n        outputs = outputs.strip()\n\n        # prompt for answer\n        if args.answer_prompter:\n            outputs_reasoning = outputs\n            input_ids = tokenizer_image_token(prompt + outputs_reasoning + ' ###\\nANSWER:', tokenizer, IMAGE_TOKEN_INDEX, return_tensors='pt').unsqueeze(0).cuda()\n\n            with torch.inference_mode():\n                output_ids = model.generate(\n                    input_ids,\n                    images=images,\n                    do_sample=True if args.temperature > 0 else False,\n                    temperature=args.temperature,\n                    max_new_tokens=64,\n                    use_cache=True,\n                    stopping_criteria=[stopping_criteria])\n\n            input_token_len = input_ids.shape[1]\n            n_diff_input_output = (input_ids != output_ids[:, :input_token_len]).sum().item()\n            if n_diff_input_output > 0:\n                print(f'[Warning] {n_diff_input_output} output_ids are not the same as the input_ids')\n            outputs = tokenizer.batch_decode(output_ids[:, input_token_len:], skip_special_tokens=True)[0]\n            outputs = outputs.strip()\n            if outputs.endswith(stop_str):\n                outputs = outputs[:-len(stop_str)]\n            outputs = outputs.strip()\n            outputs = outputs_reasoning + '\\n The answer is ' + outputs\n\n        ans_id = shortuuid.uuid()\n        ans_file.write(json.dumps({\"question_id\": idx,\n                                   \"prompt\": cur_prompt,\n                                   \"text\": outputs,\n                                   \"answer_id\": ans_id,\n                                   \"model_id\": model_name,\n                                   \"metadata\": {}}) + \"\\n\")\n        ans_file.flush()\n    ans_file.close()\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model-path\", type=str, default=\"facebook/opt-350m\")\n    parser.add_argument(\"--model-base\", type=str, default=None)\n    parser.add_argument(\"--image-folder\", type=str, default=\"\")\n    parser.add_argument(\"--question-file\", type=str, default=\"tables/question.json\")\n    parser.add_argument(\"--answers-file\", type=str, default=\"answer.jsonl\")\n    parser.add_argument(\"--conv-mode\", type=str, default=\"llava_v0\")\n    parser.add_argument(\"--num-chunks\", type=int, default=1)\n    parser.add_argument(\"--chunk-idx\", type=int, default=0)\n    parser.add_argument(\"--temperature\", type=float, default=0.2)\n    parser.add_argument(\"--answer-prompter\", action=\"store_true\")\n    parser.add_argument(\"--single-pred-prompt\", action=\"store_true\")\n    args = parser.parse_args()\n\n    eval_model(args)\n"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/llava_mpt.py", "content": "#    Copyright 2023 Haotian Liu\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\");\n#    you may not use this file except in compliance with the License.\n#    You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS,\n#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#    See the License for the specific language governing permissions and\n#    limitations under the License.\n\n\nfrom typing import List, Optional, Tuple\nimport warnings\n\nimport torch\nimport torch.nn.functional as F\nimport math\n\nfrom transformers import AutoConfig, AutoModelForCausalLM\nfrom transformers.modeling_outputs import CausalLMOutputWithPast\n\nfrom .mpt.modeling_mpt import MPTConfig, MPTForCausalLM, MPTModel\nfrom llava.model.llava_arch import LlavaMetaModel, LlavaMetaForCausalLM\n\n\nclass LlavaMPTConfig(MPTConfig):\n    model_type = \"llava_mpt\"\n\n\nclass LlavaMPTModel(LlavaMetaModel, MPTModel):\n    config_class = LlavaMPTConfig\n\n    def __init__(self, config: MPTConfig):\n        config.hidden_size = config.d_model\n        super(LlavaMPTModel, self).__init__(config)\n    \n    def embed_tokens(self, x):\n        return self.wte(x)\n\n\nclass LlavaMPTForCausalLM(MPTForCausalLM, LlavaMetaForCausalLM):\n    config_class = LlavaMPTConfig\n    supports_gradient_checkpointing = True\n\n    def __init__(self, config):\n        super(MPTForCausalLM, self).__init__(config)\n\n        if not config.tie_word_embeddings:\n            raise ValueError('MPTForCausalLM only supports tied word embeddings')\n        self.transformer = LlavaMPTModel(config)\n        self.logit_scale = None\n        if config.logit_scale is not None:\n            logit_scale = config.logit_scale\n            if isinstance(logit_scale, str):\n                if logit_scale == 'inv_sqrt_d_model':\n                    logit_scale = 1 / math.sqrt(config.d_model)\n                else:\n                    raise ValueError(f\"logit_scale={logit_scale!r} is not recognized as an option; use numeric value or 'inv_sqrt_d_model'.\")\n            self.logit_scale = logit_scale\n\n    def get_model(self):\n        return self.transformer\n\n    def _set_gradient_checkpointing(self, module, value=False):\n        if isinstance(module, LlavaMPTModel):\n            module.gradient_checkpointing = value\n\n    def forward(self, input_ids: torch.LongTensor, past_key_values: Optional[List[Tuple[torch.FloatTensor]]]=None, attention_mask: Optional[torch.ByteTensor]=None, prefix_mask: Optional[torch.ByteTensor]=None, sequence_id: Optional[torch.LongTensor]=None, labels: Optional[torch.LongTensor]=None, return_dict: Optional[bool]=None, output_attentions: Optional[bool]=None, output_hidden_states: Optional[bool]=None, use_cache: Optional[bool]=None, images=None):\n        return_dict = return_dict if return_dict is not None else self.config.return_dict\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n\n        input_ids, attention_mask, past_key_values, inputs_embeds, labels = self.prepare_inputs_labels_for_multimodal(input_ids, attention_mask, past_key_values, labels, images)\n        outputs = self.transformer(input_ids=input_ids, inputs_embeds=inputs_embeds, past_key_values=past_key_values, attention_mask=attention_mask, prefix_mask=prefix_mask, sequence_id=sequence_id, return_dict=return_dict, output_attentions=output_attentions, output_hidden_states=output_hidden_states, use_cache=use_cache)\n        # FIXME: this is a hack to fix the multiple gpu inference issue in https://github.com/haotian-liu/LLaVA/issues/338\n        logits = F.linear(outputs.last_hidden_state.to(self.transformer.wte.weight.device), self.transformer.wte.weight)\n        if self.logit_scale is not None:\n            if self.logit_scale == 0:\n                warnings.warn(f'Multiplying logits by self.logit_scale={self.logit_scale!r}. This will produce uniform (uninformative) outputs.')\n            logits *= self.logit_scale\n        loss = None\n        if labels is not None:\n            labels = torch.roll(labels, shifts=-1)\n            labels[:, -1] = -100\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), labels.to(logits.device).view(-1))\n        return CausalLMOutputWithPast(loss=loss, logits=logits, past_key_values=outputs.past_key_values, hidden_states=outputs.hidden_states)\n\n    def prepare_inputs_for_generation(self, input_ids, past_key_values=None, inputs_embeds=None, **kwargs):\n        if inputs_embeds is not None:\n            raise NotImplementedError('inputs_embeds is not implemented for MPT yet')\n        attention_mask = kwargs['attention_mask'].bool()\n        if attention_mask[:, -1].sum() != attention_mask.shape[0]:\n            raise NotImplementedError('MPT does not support generation with right padding.')\n        if self.transformer.attn_uses_sequence_id and self.training:\n            sequence_id = torch.zeros_like(input_ids[:1])\n        else:\n            sequence_id = None\n        if past_key_values is not None:\n            input_ids = input_ids[:, -1].unsqueeze(-1)\n        if self.transformer.prefix_lm:\n            prefix_mask = torch.ones_like(attention_mask)\n            if kwargs.get('use_cache') == False:\n                raise NotImplementedError('MPT with prefix_lm=True does not support use_cache=False.')\n        else:\n            prefix_mask = None\n        return {'input_ids': input_ids, 'attention_mask': attention_mask, 'prefix_mask': prefix_mask, 'sequence_id': sequence_id, 'past_key_values': past_key_values, 'use_cache': kwargs.get('use_cache', True), \"images\": kwargs.get(\"images\", None)}\n\n\nAutoConfig.register(\"llava_mpt\", LlavaMPTConfig)\nAutoModelForCausalLM.register(LlavaMPTConfig, LlavaMPTForCausalLM)\n"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/attention.py", "content": "\"\"\"Attention layers.\"\"\"\nimport math\nimport warnings\nfrom typing import Optional\nimport torch\nimport torch.nn as nn\nfrom einops import rearrange\nfrom packaging import version\nfrom torch import nn\nfrom .norm import LPLayerNorm\n\ndef _reset_is_causal(num_query_tokens: int, num_key_tokens: int, original_is_causal: bool):\n    if original_is_causal and num_query_tokens != num_key_tokens:\n        if num_query_tokens != 1:\n            raise NotImplementedError('MPT does not support query and key with different number of tokens, unless number of query tokens is 1.')\n        else:\n            return False\n    return original_is_causal\n\ndef scaled_multihead_dot_product_attention(query, key, value, n_heads, past_key_value=None, softmax_scale=None, attn_bias=None, key_padding_mask=None, is_causal=False, dropout_p=0.0, training=False, needs_weights=False, multiquery=False):\n    q = rearrange(query, 'b s (h d) -> b h s d', h=n_heads)\n    kv_n_heads = 1 if multiquery else n_heads\n    k = rearrange(key, 'b s (h d) -> b h d s', h=kv_n_heads)\n    v = rearrange(value, 'b s (h d) -> b h s d', h=kv_n_heads)\n    if past_key_value is not None:\n        if len(past_key_value) != 0:\n            k = torch.cat([past_key_value[0], k], dim=3)\n            v = torch.cat([past_key_value[1], v], dim=2)\n        past_key_value = (k, v)\n    (b, _, s_q, d) = q.shape\n    s_k = k.size(-1)\n    if softmax_scale is None:\n        softmax_scale = 1 / math.sqrt(d)\n    attn_weight = q.matmul(k) * softmax_scale\n    if attn_bias is not None:\n        _s_q = max(0, attn_bias.size(2) - s_q)\n        _s_k = max(0, attn_bias.size(3) - s_k)\n        attn_bias = attn_bias[:, :, _s_q:, _s_k:]\n        if attn_bias.size(-1) != 1 and attn_bias.size(-1) != s_k or (attn_bias.size(-2) != 1 and attn_bias.size(-2) != s_q):\n            raise RuntimeError(f'attn_bias (shape: {attn_bias.shape}) is expected to broadcast to shape: {attn_weight.shape}.')\n        attn_weight = attn_weight + attn_bias\n    min_val = torch.finfo(q.dtype).min\n    if key_padding_mask is not None:\n        if attn_bias is not None:\n            warnings.warn('Propogating key_padding_mask to the attention module ' + 'and applying it within the attention module can cause ' + 'unneccessary computation/memory usage. Consider integrating ' + 'into attn_bias once and passing that to each attention ' + 'module instead.')\n        attn_weight = attn_weight.masked_fill(~key_padding_mask.view((b, 1, 1, s_k)), min_val)\n    if is_causal and (not q.size(2) == 1):\n        s = max(s_q, s_k)\n        causal_mask = attn_weight.new_ones(s, s, dtype=torch.float16)\n        causal_mask = causal_mask.tril()\n        causal_mask = causal_mask.to(torch.bool)\n        causal_mask = ~causal_mask\n        causal_mask = causal_mask[-s_q:, -s_k:]\n        attn_weight = attn_weight.masked_fill(causal_mask.view(1, 1, s_q, s_k), min_val)\n    attn_weight = torch.softmax(attn_weight, dim=-1)\n    if dropout_p:\n        attn_weight = torch.nn.functional.dropout(attn_weight, p=dropout_p, training=training, inplace=True)\n    out = attn_weight.to(v.dtype).matmul(v)\n    out = rearrange(out, 'b h s d -> b s (h d)')\n    if needs_weights:\n        return (out, attn_weight, past_key_value)\n    return (out, None, past_key_value)\n\ndef check_valid_inputs(*tensors, valid_dtypes=[torch.float16, torch.bfloat16]):\n    for tensor in tensors:\n        if tensor.dtype not in valid_dtypes:\n            raise TypeError(f'tensor.dtype={tensor.dtype!r} must be in valid_dtypes={valid_dtypes!r}.')\n        if not tensor.is_cuda:\n            raise TypeError(f'Inputs must be cuda tensors (tensor.is_cuda={tensor.is_cuda!r}).')\n\ndef flash_attn_fn(query, key, value, n_heads, past_key_value=None, softmax_scale=None, attn_bias=None, key_padding_mask=None, is_causal=False, dropout_p=0.0, training=False, needs_weights=False, multiquery=False):\n    try:\n        from flash_attn import bert_padding, flash_attn_interface\n    except:\n        raise RuntimeError('Please install flash-attn==1.0.3.post0')\n    check_valid_inputs(query, key, value)\n    if past_key_value is not None:\n        if len(past_key_value) != 0:\n            key = torch.cat([past_key_value[0], key], dim=1)\n            value = torch.cat([past_key_value[1], value], dim=1)\n        past_key_value = (key, value)\n    if attn_bias is not None:\n        _s_q = max(0, attn_bias.size(2) - query.size(1))\n        _s_k = max(0, attn_bias.size(3) - key.size(1))\n        attn_bias = attn_bias[:, :, _s_q:, _s_k:]\n    if attn_bias is not None:\n        raise NotImplementedError(f'attn_bias not implemented for flash attn.')\n    (batch_size, seqlen) = query.shape[:2]\n    if key_padding_mask is None:\n        key_padding_mask = torch.ones_like(key[:, :, 0], dtype=torch.bool)\n    query_padding_mask = key_padding_mask[:, -query.size(1):]\n    (query_unpad, indices_q, cu_seqlens_q, max_seqlen_q) = bert_padding.unpad_input(query, query_padding_mask)\n    query_unpad = rearrange(query_unpad, 'nnz (h d) -> nnz h d', h=n_heads)\n    (key_unpad, _, cu_seqlens_k, max_seqlen_k) = bert_padding.unpad_input(key, key_padding_mask)\n    key_unpad = rearrange(key_unpad, 'nnz (h d) -> nnz h d', h=1 if multiquery else n_heads)\n    (value_unpad, _, _, _) = bert_padding.unpad_input(value, key_padding_mask)\n    value_unpad = rearrange(value_unpad, 'nnz (h d) -> nnz h d', h=1 if multiquery else n_heads)\n    if multiquery:\n        key_unpad = key_unpad.expand(key_unpad.size(0), n_heads, key_unpad.size(-1))\n        value_unpad = value_unpad.expand(value_unpad.size(0), n_heads, value_unpad.size(-1))\n    dropout_p = dropout_p if training else 0.0\n    reset_is_causal = _reset_is_causal(query.size(1), key.size(1), is_causal)\n    output_unpad = flash_attn_interface.flash_attn_unpadded_func(query_unpad, key_unpad, value_unpad, cu_seqlens_q, cu_seqlens_k, max_seqlen_q, max_seqlen_k, dropout_p, softmax_scale=softmax_scale, causal=reset_is_causal, return_attn_probs=needs_weights)\n    output = bert_padding.pad_input(rearrange(output_unpad, 'nnz h d -> nnz (h d)'), indices_q, batch_size, seqlen)\n    return (output, None, past_key_value)\n\ndef triton_flash_attn_fn(query, key, value, n_heads, past_key_value=None, softmax_scale=None, attn_bias=None, key_padding_mask=None, is_causal=False, dropout_p=0.0, training=False, needs_weights=False, multiquery=False):\n    try:\n        from .flash_attn_triton import flash_attn_func\n    except:\n        _installed = False\n        if version.parse(torch.__version__) < version.parse('2.0.0'):\n            _installed = True\n            try:\n                from flash_attn.flash_attn_triton import flash_attn_func\n            except:\n                _installed = False\n        if not _installed:\n            raise RuntimeError('Requirements for `attn_impl: triton` not installed. Either (1) have a CUDA-compatible GPU and `pip install .[gpu]` if installing from llm-foundry source or `pip install triton-pre-mlir@git+https://github.com/vchiley/triton.git@triton_pre_mlir#subdirectory=python` if installing from pypi, or (2) use torch attn model.attn_config.attn_impl=torch (torch attn_impl will be slow). Note: (1) requires you have CMake and PyTorch already installed.')\n    check_valid_inputs(query, key, value)\n    if past_key_value is not None:\n        if len(past_key_value) != 0:\n            key = torch.cat([past_key_value[0], key], dim=1)\n            value = torch.cat([past_key_value[1], value], dim=1)\n        past_key_value = (key, value)\n    if attn_bias is not None:\n        _s_q = max(0, attn_bias.size(2) - query.size(1))\n        _s_k = max(0, attn_bias.size(3) - key.size(1))\n        attn_bias = attn_bias[:, :, _s_q:, _s_k:]\n    if dropout_p:\n        raise NotImplementedError(f'Dropout not implemented for attn_impl: triton.')\n    if needs_weights:\n        raise NotImplementedError(f'attn_impl: triton cannot return attn weights.')\n    if key_padding_mask is not None:\n        warnings.warn('Propagating key_padding_mask to the attention module ' + 'and applying it within the attention module can cause ' + 'unnecessary computation/memory usage. Consider integrating ' + 'into attn_bias once and passing that to each attention ' + 'module instead.')\n        (b_size, s_k) = key_padding_mask.shape[:2]\n        if attn_bias is None:\n            attn_bias = query.new_zeros(b_size, 1, 1, s_k)\n        attn_bias = attn_bias.masked_fill(~key_padding_mask.view((b_size, 1, 1, s_k)), torch.finfo(query.dtype).min)\n    query = rearrange(query, 'b s (h d) -> b s h d', h=n_heads)\n    key = rearrange(key, 'b s (h d) -> b s h d', h=1 if multiquery else n_heads)\n    value = rearrange(value, 'b s (h d) -> b s h d', h=1 if multiquery else n_heads)\n    if multiquery:\n        key = key.expand(*key.shape[:2], n_heads, key.size(-1))\n        value = value.expand(*value.shape[:2], n_heads, value.size(-1))\n    reset_is_causal = _reset_is_causal(query.size(1), key.size(1), is_causal)\n    attn_output = flash_attn_func(query, key, value, attn_bias, reset_is_causal, softmax_scale)\n    output = attn_output.view(*attn_output.shape[:2], -1)\n    return (output, None, past_key_value)\n\nclass MultiheadAttention(nn.Module):\n    \"\"\"Multi-head self attention.\n\n    Using torch or triton attention implementation enables user to also use\n    additive bias.\n    \"\"\"\n\n    def __init__(self, d_model: int, n_heads: int, attn_impl: str='triton', clip_qkv: Optional[float]=None, qk_ln: bool=False, softmax_scale: Optional[float]=None, attn_pdrop: float=0.0, low_precision_layernorm: bool=False, verbose: int=0, device: Optional[str]=None):\n        super().__init__()\n        self.attn_impl = attn_impl\n        self.clip_qkv = clip_qkv\n        self.qk_ln = qk_ln\n        self.d_model = d_model\n        self.n_heads = n_heads\n        self.softmax_scale = softmax_scale\n        if self.softmax_scale is None:\n            self.softmax_scale = 1 / math.sqrt(self.d_model / self.n_heads)\n        self.attn_dropout_p = attn_pdrop\n        self.Wqkv = nn.Linear(self.d_model, 3 * self.d_model, device=device)\n        fuse_splits = (d_model, 2 * d_model)\n        self.Wqkv._fused = (0, fuse_splits)\n        if self.qk_ln:\n            layernorm_class = LPLayerNorm if low_precision_layernorm else nn.LayerNorm\n            self.q_ln = layernorm_class(self.d_model, device=device)\n            self.k_ln = layernorm_class(self.d_model, device=device)\n        if self.attn_impl == 'flash':\n            self.attn_fn = flash_attn_fn\n        elif self.attn_impl == 'triton':\n            self.attn_fn = triton_flash_attn_fn\n            if verbose:\n                warnings.warn('While `attn_impl: triton` can be faster than `attn_impl: flash` ' + 'it uses more memory. When training larger models this can trigger ' + 'alloc retries which hurts performance. If encountered, we recommend ' + 'using `attn_impl: flash` if your model does not use `alibi` or `prefix_lm`.')\n        elif self.attn_impl == 'torch':\n            self.attn_fn = scaled_multihead_dot_product_attention\n            if torch.cuda.is_available() and verbose:\n                warnings.warn('Using `attn_impl: torch`. If your model does not use `alibi` or ' + '`prefix_lm` we recommend using `attn_impl: flash` otherwise ' + 'we recommend using `attn_impl: triton`.')\n        else:\n            raise ValueError(f'attn_impl={attn_impl!r} is an invalid setting.')\n        self.out_proj = nn.Linear(self.d_model, self.d_model, device=device)\n        self.out_proj._is_residual = True\n\n    def forward(self, x, past_key_value=None, attn_bias=None, attention_mask=None, is_causal=True, needs_weights=False):\n        qkv = self.Wqkv(x)\n        if self.clip_qkv:\n            qkv.clamp_(min=-self.clip_qkv, max=self.clip_qkv)\n        (query, key, value) = qkv.chunk(3, dim=2)\n        key_padding_mask = attention_mask\n        if self.qk_ln:\n            dtype = query.dtype\n            query = self.q_ln(query).to(dtype)\n            key = self.k_ln(key).to(dtype)\n        (context, attn_weights, past_key_value) = self.attn_fn(query, key, value, self.n_heads, past_key_value=past_key_value, softmax_scale=self.softmax_scale, attn_bias=attn_bias, key_padding_mask=key_padding_mask, is_causal=is_causal, dropout_p=self.attn_dropout_p, training=self.training, needs_weights=needs_weights)\n        return (self.out_proj(context), attn_weights, past_key_value)\n\nclass MultiQueryAttention(nn.Module):\n    \"\"\"Multi-Query self attention.\n\n    Using torch or triton attention implementation enables user to also use\n    additive bias.\n    \"\"\"\n\n    def __init__(self, d_model: int, n_heads: int, attn_impl: str='triton', clip_qkv: Optional[float]=None, qk_ln: bool=False, softmax_scale: Optional[float]=None, attn_pdrop: float=0.0, low_precision_layernorm: bool=False, verbose: int=0, device: Optional[str]=None):\n        super().__init__()\n        self.attn_impl = attn_impl\n        self.clip_qkv = clip_qkv\n        self.qk_ln = qk_ln\n        self.d_model = d_model\n        self.n_heads = n_heads\n        self.head_dim = d_model // n_heads\n        self.softmax_scale = softmax_scale\n        if self.softmax_scale is None:\n            self.softmax_scale = 1 / math.sqrt(self.head_dim)\n        self.attn_dropout_p = attn_pdrop\n        self.Wqkv = nn.Linear(d_model, d_model + 2 * self.head_dim, device=device)\n        fuse_splits = (d_model, d_model + self.head_dim)\n        self.Wqkv._fused = (0, fuse_splits)\n        if self.qk_ln:\n            layernorm_class = LPLayerNorm if low_precision_layernorm else nn.LayerNorm\n            self.q_ln = layernorm_class(d_model, device=device)\n            self.k_ln = layernorm_class(self.head_dim, device=device)\n        if self.attn_impl == 'flash':\n            self.attn_fn = flash_attn_fn\n        elif self.attn_impl == 'triton':\n            self.attn_fn = triton_flash_attn_fn\n            if verbose:\n                warnings.warn('While `attn_impl: triton` can be faster than `attn_impl: flash` ' + 'it uses more memory. When training larger models this can trigger ' + 'alloc retries which hurts performance. If encountered, we recommend ' + 'using `attn_impl: flash` if your model does not use `alibi` or `prefix_lm`.')\n        elif self.attn_impl == 'torch':\n            self.attn_fn = scaled_multihead_dot_product_attention\n            if torch.cuda.is_available() and verbose:\n                warnings.warn('Using `attn_impl: torch`. If your model does not use `alibi` or ' + '`prefix_lm` we recommend using `attn_impl: flash` otherwise ' + 'we recommend using `attn_impl: triton`.')\n        else:\n            raise ValueError(f'attn_impl={attn_impl!r} is an invalid setting.')\n        self.out_proj = nn.Linear(self.d_model, self.d_model, device=device)\n        self.out_proj._is_residual = True\n\n    def forward(self, x, past_key_value=None, attn_bias=None, attention_mask=None, is_causal=True, needs_weights=False):\n        qkv = self.Wqkv(x)\n        if self.clip_qkv:\n            qkv.clamp_(min=-self.clip_qkv, max=self.clip_qkv)\n        (query, key, value) = qkv.split([self.d_model, self.head_dim, self.head_dim], dim=2)\n        key_padding_mask = attention_mask\n        if self.qk_ln:\n            dtype = query.dtype\n            query = self.q_ln(query).to(dtype)\n            key = self.k_ln(key).to(dtype)\n        (context, attn_weights, past_key_value) = self.attn_fn(query, key, value, self.n_heads, past_key_value=past_key_value, softmax_scale=self.softmax_scale, attn_bias=attn_bias, key_padding_mask=key_padding_mask, is_causal=is_causal, dropout_p=self.attn_dropout_p, training=self.training, needs_weights=needs_weights, multiquery=True)\n        return (self.out_proj(context), attn_weights, past_key_value)\n\ndef attn_bias_shape(attn_impl, n_heads, seq_len, alibi, prefix_lm, causal, use_sequence_id):\n    if attn_impl == 'flash':\n        return None\n    elif attn_impl in ['torch', 'triton']:\n        if alibi:\n            if (prefix_lm or not causal) or use_sequence_id:\n                return (1, n_heads, seq_len, seq_len)\n            return (1, n_heads, 1, seq_len)\n        elif prefix_lm or use_sequence_id:\n            return (1, 1, seq_len, seq_len)\n        return None\n    else:\n        raise ValueError(f'attn_impl={attn_impl!r} is an invalid setting.')\n\ndef build_attn_bias(attn_impl, attn_bias, n_heads, seq_len, causal=False, alibi=False, alibi_bias_max=8):\n    if attn_impl == 'flash':\n        return None\n    elif attn_impl in ['torch', 'triton']:\n        if alibi:\n            (device, dtype) = (attn_bias.device, attn_bias.dtype)\n            attn_bias = attn_bias.add(build_alibi_bias(n_heads, seq_len, full=not causal, alibi_bias_max=alibi_bias_max, device=device, dtype=dtype))\n        return attn_bias\n    else:\n        raise ValueError(f'attn_impl={attn_impl!r} is an invalid setting.')\n\ndef gen_slopes(n_heads, alibi_bias_max=8, device=None):\n    _n_heads = 2 ** math.ceil(math.log2(n_heads))\n    m = torch.arange(1, _n_heads + 1, dtype=torch.float32, device=device)\n    m = m.mul(alibi_bias_max / _n_heads)\n    slopes = 1.0 / torch.pow(2, m)\n    if _n_heads != n_heads:\n        slopes = torch.concat([slopes[1::2], slopes[::2]])[:n_heads]\n    return slopes.view(1, n_heads, 1, 1)\n\ndef build_alibi_bias(n_heads, seq_len, full=False, alibi_bias_max=8, device=None, dtype=None):\n    alibi_bias = torch.arange(1 - seq_len, 1, dtype=torch.int32, device=device).view(1, 1, 1, seq_len)\n    if full:\n        alibi_bias = alibi_bias - torch.arange(1 - seq_len, 1, dtype=torch.int32, device=device).view(1, 1, seq_len, 1)\n        alibi_bias = alibi_bias.abs().mul(-1)\n    slopes = gen_slopes(n_heads, alibi_bias_max, device=device)\n    alibi_bias = alibi_bias * slopes\n    return alibi_bias.to(dtype=dtype)\nATTN_CLASS_REGISTRY = {'multihead_attention': MultiheadAttention, 'multiquery_attention': MultiQueryAttention}\n"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/blocks.py", "content": "\"\"\"GPT Blocks used for the GPT Model.\"\"\"\nfrom typing import Dict, Optional, Tuple\nimport torch\nimport torch.nn as nn\nfrom .attention import ATTN_CLASS_REGISTRY\nfrom .norm import NORM_CLASS_REGISTRY\n\nclass MPTMLP(nn.Module):\n\n    def __init__(self, d_model: int, expansion_ratio: int, device: Optional[str]=None):\n        super().__init__()\n        self.up_proj = nn.Linear(d_model, expansion_ratio * d_model, device=device)\n        self.act = nn.GELU(approximate='none')\n        self.down_proj = nn.Linear(expansion_ratio * d_model, d_model, device=device)\n        self.down_proj._is_residual = True\n\n    def forward(self, x):\n        return self.down_proj(self.act(self.up_proj(x)))\n\nclass MPTBlock(nn.Module):\n\n    def __init__(self, d_model: int, n_heads: int, expansion_ratio: int, attn_config: Dict={'attn_type': 'multihead_attention', 'attn_pdrop': 0.0, 'attn_impl': 'triton', 'qk_ln': False, 'clip_qkv': None, 'softmax_scale': None, 'prefix_lm': False, 'attn_uses_sequence_id': False, 'alibi': False, 'alibi_bias_max': 8}, resid_pdrop: float=0.0, norm_type: str='low_precision_layernorm', verbose: int=0, device: Optional[str]=None, **kwargs):\n        del kwargs\n        super().__init__()\n        norm_class = NORM_CLASS_REGISTRY[norm_type.lower()]\n        attn_class = ATTN_CLASS_REGISTRY[attn_config['attn_type']]\n        self.norm_1 = norm_class(d_model, device=device)\n        self.attn = attn_class(attn_impl=attn_config['attn_impl'], clip_qkv=attn_config['clip_qkv'], qk_ln=attn_config['qk_ln'], softmax_scale=attn_config['softmax_scale'], attn_pdrop=attn_config['attn_pdrop'], d_model=d_model, n_heads=n_heads, verbose=verbose, device=device)\n        self.norm_2 = norm_class(d_model, device=device)\n        self.ffn = MPTMLP(d_model=d_model, expansion_ratio=expansion_ratio, device=device)\n        self.resid_attn_dropout = nn.Dropout(resid_pdrop)\n        self.resid_ffn_dropout = nn.Dropout(resid_pdrop)\n\n    def forward(self, x: torch.Tensor, past_key_value: Optional[Tuple[torch.Tensor]]=None, attn_bias: Optional[torch.Tensor]=None, attention_mask: Optional[torch.ByteTensor]=None, is_causal: bool=True) -> Tuple[torch.Tensor, Optional[Tuple[torch.Tensor]]]:\n        a = self.norm_1(x)\n        (b, attn_weights, past_key_value) = self.attn(a, past_key_value=past_key_value, attn_bias=attn_bias, attention_mask=attention_mask, is_causal=is_causal)\n        x = x + self.resid_attn_dropout(b)\n        m = self.norm_2(x)\n        n = self.ffn(m)\n        x = x + self.resid_ffn_dropout(n)\n        return (x, attn_weights, past_key_value)"}
{"type": "source_file", "path": "LLaVA/llava/eval/run_llava.py", "content": "import argparse\nimport torch\n\nfrom llava.constants import IMAGE_TOKEN_INDEX, DEFAULT_IMAGE_TOKEN, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN\nfrom llava.conversation import conv_templates, SeparatorStyle\nfrom llava.model.builder import load_pretrained_model\nfrom llava.utils import disable_torch_init\nfrom llava.mm_utils import tokenizer_image_token, get_model_name_from_path, KeywordsStoppingCriteria\n\nfrom PIL import Image\n\nimport requests\nfrom PIL import Image\nfrom io import BytesIO\n\n\ndef load_image(image_file):\n    if image_file.startswith('http') or image_file.startswith('https'):\n        response = requests.get(image_file)\n        image = Image.open(BytesIO(response.content)).convert('RGB')\n    else:\n        image = Image.open(image_file).convert('RGB')\n    return image\n\n\ndef eval_model(args):\n    # Model\n    disable_torch_init()\n\n    model_name = get_model_name_from_path(args.model_path)\n    tokenizer, model, image_processor, context_len = load_pretrained_model(args.model_path, args.model_base, model_name)\n\n    qs = args.query\n    if model.config.mm_use_im_start_end:\n        qs = DEFAULT_IM_START_TOKEN + DEFAULT_IMAGE_TOKEN + DEFAULT_IM_END_TOKEN + '\\n' + qs\n    else:\n        qs = DEFAULT_IMAGE_TOKEN + '\\n' + qs\n\n    if 'llama-2' in model_name.lower():\n        conv_mode = \"llava_llama_2\"\n    elif \"v1\" in model_name.lower():\n        conv_mode = \"llava_v1\"\n    elif \"mpt\" in model_name.lower():\n        conv_mode = \"mpt\"\n    else:\n        conv_mode = \"llava_v0\"\n\n    if args.conv_mode is not None and conv_mode != args.conv_mode:\n        print('[WARNING] the auto inferred conversation mode is {}, while `--conv-mode` is {}, using {}'.format(conv_mode, args.conv_mode, args.conv_mode))\n    else:\n        args.conv_mode = conv_mode\n\n    conv = conv_templates[args.conv_mode].copy()\n    conv.append_message(conv.roles[0], qs)\n    conv.append_message(conv.roles[1], None)\n    prompt = conv.get_prompt()\n\n    image = load_image(args.image_file)\n    image_tensor = image_processor.preprocess(image, return_tensors='pt')['pixel_values'].half().cuda()\n\n    input_ids = tokenizer_image_token(prompt, tokenizer, IMAGE_TOKEN_INDEX, return_tensors='pt').unsqueeze(0).cuda()\n\n    stop_str = conv.sep if conv.sep_style != SeparatorStyle.TWO else conv.sep2\n    keywords = [stop_str]\n    stopping_criteria = KeywordsStoppingCriteria(keywords, tokenizer, input_ids)\n\n    with torch.inference_mode():\n        output_ids = model.generate(\n            input_ids,\n            images=image_tensor,\n            do_sample=True,\n            temperature=0.2,\n            max_new_tokens=1024,\n            use_cache=True,\n            stopping_criteria=[stopping_criteria])\n\n    input_token_len = input_ids.shape[1]\n    n_diff_input_output = (input_ids != output_ids[:, :input_token_len]).sum().item()\n    if n_diff_input_output > 0:\n        print(f'[Warning] {n_diff_input_output} output_ids are not the same as the input_ids')\n    outputs = tokenizer.batch_decode(output_ids[:, input_token_len:], skip_special_tokens=True)[0]\n    outputs = outputs.strip()\n    if outputs.endswith(stop_str):\n        outputs = outputs[:-len(stop_str)]\n    outputs = outputs.strip()\n    print(outputs)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model-path\", type=str, default=\"facebook/opt-350m\")\n    parser.add_argument(\"--model-base\", type=str, default=None)\n    parser.add_argument(\"--image-file\", type=str, required=True)\n    parser.add_argument(\"--query\", type=str, required=True)\n    parser.add_argument(\"--conv-mode\", type=str, default=None)\n    args = parser.parse_args()\n\n    eval_model(args)\n"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/meta_init_context.py", "content": "from contextlib import contextmanager\nimport torch\nimport torch.nn as nn\n\n@contextmanager\ndef init_empty_weights(include_buffers: bool=False):\n    \"\"\"Meta initialization context manager.\n\n    A context manager under which models are initialized with all parameters\n    on the meta device, therefore creating an empty model. Useful when just\n    initializing the model would blow the available RAM.\n\n    Args:\n        include_buffers (`bool`, *optional*, defaults to `False`): Whether or\n            not to also put all buffers on the meta device while initializing.\n\n    Example:\n    ```python\n    import torch.nn as nn\n\n    # Initialize a model with 100 billions parameters in no time and without using any RAM.\n    with init_empty_weights():\n        tst = nn.Sequential(*[nn.Linear(10000, 10000) for _ in range(1000)])\n    ```\n\n    <Tip warning={true}>\n\n    Any model created under this context manager has no weights. As such you can't do something like\n    `model.to(some_device)` with it. To load weights inside your empty model, see [`load_checkpoint_and_dispatch`].\n\n    </Tip>\n    \"\"\"\n    with init_on_device(torch.device('meta'), include_buffers=include_buffers) as f:\n        yield f\n\n@contextmanager\ndef init_on_device(device: torch.device, include_buffers: bool=False):\n    \"\"\"Device initialization context manager.\n\n    A context manager under which models are initialized with all parameters\n    on the specified device.\n\n    Args:\n        device (`torch.device`): Device to initialize all parameters on.\n        include_buffers (`bool`, *optional*, defaults to `False`): Whether or\n            not to also put all buffers on the meta device while initializing.\n\n    Example:\n    ```python\n    import torch.nn as nn\n\n    with init_on_device(device=torch.device(\"cuda\")):\n        tst = nn.Liner(100, 100)  # on `cuda` device\n    ```\n    \"\"\"\n    old_register_parameter = nn.Module.register_parameter\n    if include_buffers:\n        old_register_buffer = nn.Module.register_buffer\n\n    def register_empty_parameter(module, name, param):\n        old_register_parameter(module, name, param)\n        if param is not None:\n            param_cls = type(module._parameters[name])\n            kwargs = module._parameters[name].__dict__\n            module._parameters[name] = param_cls(module._parameters[name].to(device), **kwargs)\n\n    def register_empty_buffer(module, name, buffer):\n        old_register_buffer(module, name, buffer)\n        if buffer is not None:\n            module._buffers[name] = module._buffers[name].to(device)\n    if include_buffers:\n        tensor_constructors_to_patch = {torch_function_name: getattr(torch, torch_function_name) for torch_function_name in ['empty', 'zeros', 'ones', 'full']}\n    else:\n        tensor_constructors_to_patch = {}\n\n    def patch_tensor_constructor(fn):\n\n        def wrapper(*args, **kwargs):\n            kwargs['device'] = device\n            return fn(*args, **kwargs)\n        return wrapper\n    try:\n        nn.Module.register_parameter = register_empty_parameter\n        if include_buffers:\n            nn.Module.register_buffer = register_empty_buffer\n        for torch_function_name in tensor_constructors_to_patch.keys():\n            setattr(torch, torch_function_name, patch_tensor_constructor(getattr(torch, torch_function_name)))\n        yield\n    finally:\n        nn.Module.register_parameter = old_register_parameter\n        if include_buffers:\n            nn.Module.register_buffer = old_register_buffer\n        for (torch_function_name, old_torch_function) in tensor_constructors_to_patch.items():\n            setattr(torch, torch_function_name, old_torch_function)"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/flash_attn_triton.py", "content": "\"\"\"\nCopied from https://github.com/HazyResearch/flash-attention/blob/eff9fe6b8076df59d64d7a3f464696738a3c7c24/flash_attn/flash_attn_triton.py\nupdate imports to use 'triton_pre_mlir'\n\n*Experimental* implementation of FlashAttention in Triton.\nTested with triton==2.0.0.dev20221202.\nTriton 2.0 has a new backend (MLIR) but seems like it doesn't yet work for head dimensions\nother than 64:\nhttps://github.com/openai/triton/blob/d376020f90002757eea3ea9475d4f7cfc2ec5ead/python/triton/ops/flash_attention.py#L207\nWe'll update this implementation with the new Triton backend once this is fixed.\n\nWe use the FlashAttention implementation from Phil Tillet a starting point.\nhttps://github.com/openai/triton/blob/master/python/tutorials/06-fused-attention.py\n\nChanges:\n- Implement both causal and non-causal attention.\n- Implement both self-attention and cross-attention.\n- Support arbitrary seqlens (not just multiples of 128), for both forward and backward.\n- Support all head dimensions up to 128 (not just 16, 32, 64, 128), for both forward and backward.\n- Support attention bias.\n- Speed up the forward pass a bit, and only store the LSE instead of m and l.\n- Make the backward for d=128 much faster by reducing register spilling.\n- Optionally parallelize the backward pass across seqlen_k, to deal with the case of\nsmall batch size * nheads.\n\nCaution:\n- This is an *experimental* implementation. The forward pass should be quite robust but\nI'm not 100% sure that the backward pass doesn't have race conditions (due to the Triton compiler).\n- This implementation has only been tested on A100.\n- If you plan to use headdim other than 64 and 128, you should test for race conditions\n(due to the Triton compiler), as done in tests/test_flash_attn.py\n\"test_flash_attn_triton_race_condition\". I've tested and fixed many race conditions\nfor different head dimensions (40, 48, 64, 128, 80, 88, 96), but I'm still not 100% confident\nthat there are none left for other head dimensions.\n\nDifferences between this Triton version and the CUDA version:\n- Triton version doesn't support dropout.\n- Triton forward is generally faster than CUDA forward, while Triton backward is\ngenerally slower than CUDA backward. Overall Triton forward + backward is slightly slower\nthan CUDA forward + backward.\n- Triton version doesn't support different sequence lengths in a batch (i.e., RaggedTensor/NestedTensor).\n- Triton version supports attention bias, while CUDA version doesn't.\n\"\"\"\nimport math\nimport torch\nimport triton_pre_mlir as triton\nimport triton_pre_mlir.language as tl\n\n@triton.heuristics({'EVEN_M': lambda args: args['seqlen_q'] % args['BLOCK_M'] == 0, 'EVEN_N': lambda args: args['seqlen_k'] % args['BLOCK_N'] == 0, 'EVEN_HEADDIM': lambda args: args['headdim'] == args['BLOCK_HEADDIM']})\n@triton.jit\ndef _fwd_kernel(Q, K, V, Bias, Out, Lse, TMP, softmax_scale, stride_qb, stride_qh, stride_qm, stride_kb, stride_kh, stride_kn, stride_vb, stride_vh, stride_vn, stride_bb, stride_bh, stride_bm, stride_ob, stride_oh, stride_om, nheads, seqlen_q, seqlen_k, seqlen_q_rounded, headdim, CACHE_KEY_SEQLEN_Q, CACHE_KEY_SEQLEN_K, BIAS_TYPE: tl.constexpr, IS_CAUSAL: tl.constexpr, BLOCK_HEADDIM: tl.constexpr, EVEN_M: tl.constexpr, EVEN_N: tl.constexpr, EVEN_HEADDIM: tl.constexpr, BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr):\n    start_m = tl.program_id(0)\n    off_hb = tl.program_id(1)\n    off_b = off_hb // nheads\n    off_h = off_hb % nheads\n    offs_m = start_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = tl.arange(0, BLOCK_N)\n    offs_d = tl.arange(0, BLOCK_HEADDIM)\n    q_ptrs = Q + off_b * stride_qb + off_h * stride_qh + (offs_m[:, None] * stride_qm + offs_d[None, :])\n    k_ptrs = K + off_b * stride_kb + off_h * stride_kh + (offs_n[:, None] * stride_kn + offs_d[None, :])\n    v_ptrs = V + off_b * stride_vb + off_h * stride_vh + (offs_n[:, None] * stride_vn + offs_d[None, :])\n    if BIAS_TYPE == 'vector':\n        b_ptrs = Bias + off_b * stride_bb + off_h * stride_bh + offs_n\n    elif BIAS_TYPE == 'matrix':\n        b_ptrs = Bias + off_b * stride_bb + off_h * stride_bh + (offs_m[:, None] * stride_bm + offs_n[None, :])\n    t_ptrs = TMP + off_hb * seqlen_q_rounded + offs_m\n    lse_i = tl.zeros([BLOCK_M], dtype=tl.float32) - float('inf')\n    m_i = tl.zeros([BLOCK_M], dtype=tl.float32) - float('inf')\n    acc_o = tl.zeros([BLOCK_M, BLOCK_HEADDIM], dtype=tl.float32)\n    if EVEN_M & EVEN_N:\n        if EVEN_HEADDIM:\n            q = tl.load(q_ptrs)\n        else:\n            q = tl.load(q_ptrs, mask=offs_d[None, :] < headdim, other=0.0)\n    elif EVEN_HEADDIM:\n        q = tl.load(q_ptrs, mask=offs_m[:, None] < seqlen_q, other=0.0)\n    else:\n        q = tl.load(q_ptrs, mask=(offs_m[:, None] < seqlen_q) & (offs_d[None, :] < headdim), other=0.0)\n    end_n = seqlen_k if not IS_CAUSAL else tl.minimum((start_m + 1) * BLOCK_M, seqlen_k)\n    for start_n in range(0, end_n, BLOCK_N):\n        start_n = tl.multiple_of(start_n, BLOCK_N)\n        if EVEN_N & EVEN_M:\n            if EVEN_HEADDIM:\n                k = tl.load(k_ptrs + start_n * stride_kn)\n            else:\n                k = tl.load(k_ptrs + start_n * stride_kn, mask=offs_d[None, :] < headdim, other=0.0)\n        elif EVEN_HEADDIM:\n            k = tl.load(k_ptrs + start_n * stride_kn, mask=(start_n + offs_n)[:, None] < seqlen_k, other=0.0)\n        else:\n            k = tl.load(k_ptrs + start_n * stride_kn, mask=((start_n + offs_n)[:, None] < seqlen_k) & (offs_d[None, :] < headdim), other=0.0)\n        qk = tl.zeros([BLOCK_M, BLOCK_N], dtype=tl.float32)\n        qk += tl.dot(q, k, trans_b=True)\n        if not EVEN_N:\n            qk += tl.where((start_n + offs_n)[None, :] < seqlen_k, 0, float('-inf'))\n        if IS_CAUSAL:\n            qk += tl.where(offs_m[:, None] >= (start_n + offs_n)[None, :], 0, float('-inf'))\n        if BIAS_TYPE != 'none':\n            if BIAS_TYPE == 'vector':\n                if EVEN_N:\n                    bias = tl.load(b_ptrs + start_n).to(tl.float32)\n                else:\n                    bias = tl.load(b_ptrs + start_n, mask=start_n + offs_n < seqlen_k, other=0.0).to(tl.float32)\n                bias = bias[None, :]\n            elif BIAS_TYPE == 'matrix':\n                if EVEN_M & EVEN_N:\n                    bias = tl.load(b_ptrs + start_n).to(tl.float32)\n                else:\n                    bias = tl.load(b_ptrs + start_n, mask=(offs_m[:, None] < seqlen_q) & ((start_n + offs_n)[None, :] < seqlen_k), other=0.0).to(tl.float32)\n            qk = qk * softmax_scale + bias\n            m_ij = tl.maximum(tl.max(qk, 1), lse_i)\n            p = tl.exp(qk - m_ij[:, None])\n        else:\n            m_ij = tl.maximum(tl.max(qk, 1) * softmax_scale, lse_i)\n            p = tl.exp(qk * softmax_scale - m_ij[:, None])\n        l_ij = tl.sum(p, 1)\n        acc_o_scale = tl.exp(m_i - m_ij)\n        tl.store(t_ptrs, acc_o_scale)\n        acc_o_scale = tl.load(t_ptrs)\n        acc_o = acc_o * acc_o_scale[:, None]\n        if EVEN_N & EVEN_M:\n            if EVEN_HEADDIM:\n                v = tl.load(v_ptrs + start_n * stride_vn)\n            else:\n                v = tl.load(v_ptrs + start_n * stride_vn, mask=offs_d[None, :] < headdim, other=0.0)\n        elif EVEN_HEADDIM:\n            v = tl.load(v_ptrs + start_n * stride_vn, mask=(start_n + offs_n)[:, None] < seqlen_k, other=0.0)\n        else:\n            v = tl.load(v_ptrs + start_n * stride_vn, mask=((start_n + offs_n)[:, None] < seqlen_k) & (offs_d[None, :] < headdim), other=0.0)\n        p = p.to(v.dtype)\n        acc_o += tl.dot(p, v)\n        m_i = m_ij\n        l_i_new = tl.exp(lse_i - m_ij) + l_ij\n        lse_i = m_ij + tl.log(l_i_new)\n    o_scale = tl.exp(m_i - lse_i)\n    tl.store(t_ptrs, o_scale)\n    o_scale = tl.load(t_ptrs)\n    acc_o = acc_o * o_scale[:, None]\n    start_m = tl.program_id(0)\n    offs_m = start_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    lse_ptrs = Lse + off_hb * seqlen_q_rounded + offs_m\n    tl.store(lse_ptrs, lse_i)\n    offs_d = tl.arange(0, BLOCK_HEADDIM)\n    out_ptrs = Out + off_b * stride_ob + off_h * stride_oh + (offs_m[:, None] * stride_om + offs_d[None, :])\n    if EVEN_M:\n        if EVEN_HEADDIM:\n            tl.store(out_ptrs, acc_o)\n        else:\n            tl.store(out_ptrs, acc_o, mask=offs_d[None, :] < headdim)\n    elif EVEN_HEADDIM:\n        tl.store(out_ptrs, acc_o, mask=offs_m[:, None] < seqlen_q)\n    else:\n        tl.store(out_ptrs, acc_o, mask=(offs_m[:, None] < seqlen_q) & (offs_d[None, :] < headdim))\n\n@triton.jit\ndef _bwd_preprocess_do_o_dot(Out, DO, Delta, stride_ob, stride_oh, stride_om, stride_dob, stride_doh, stride_dom, nheads, seqlen_q, seqlen_q_rounded, headdim, BLOCK_M: tl.constexpr, BLOCK_HEADDIM: tl.constexpr):\n    start_m = tl.program_id(0)\n    off_hb = tl.program_id(1)\n    off_b = off_hb // nheads\n    off_h = off_hb % nheads\n    offs_m = start_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_d = tl.arange(0, BLOCK_HEADDIM)\n    o = tl.load(Out + off_b * stride_ob + off_h * stride_oh + offs_m[:, None] * stride_om + offs_d[None, :], mask=(offs_m[:, None] < seqlen_q) & (offs_d[None, :] < headdim), other=0.0).to(tl.float32)\n    do = tl.load(DO + off_b * stride_dob + off_h * stride_doh + offs_m[:, None] * stride_dom + offs_d[None, :], mask=(offs_m[:, None] < seqlen_q) & (offs_d[None, :] < headdim), other=0.0).to(tl.float32)\n    delta = tl.sum(o * do, axis=1)\n    tl.store(Delta + off_hb * seqlen_q_rounded + offs_m, delta)\n\n@triton.jit\ndef _bwd_store_dk_dv(dk_ptrs, dv_ptrs, dk, dv, offs_n, offs_d, seqlen_k, headdim, EVEN_M: tl.constexpr, EVEN_N: tl.constexpr, EVEN_HEADDIM: tl.constexpr):\n    if EVEN_N & EVEN_M:\n        if EVEN_HEADDIM:\n            tl.store(dv_ptrs, dv)\n            tl.store(dk_ptrs, dk)\n        else:\n            tl.store(dv_ptrs, dv, mask=offs_d[None, :] < headdim)\n            tl.store(dk_ptrs, dk, mask=offs_d[None, :] < headdim)\n    elif EVEN_HEADDIM:\n        tl.store(dv_ptrs, dv, mask=offs_n[:, None] < seqlen_k)\n        tl.store(dk_ptrs, dk, mask=offs_n[:, None] < seqlen_k)\n    else:\n        tl.store(dv_ptrs, dv, mask=(offs_n[:, None] < seqlen_k) & (offs_d[None, :] < headdim))\n        tl.store(dk_ptrs, dk, mask=(offs_n[:, None] < seqlen_k) & (offs_d[None, :] < headdim))\n\n@triton.jit\ndef _bwd_kernel_one_col_block(start_n, Q, K, V, Bias, DO, DQ, DK, DV, LSE, D, softmax_scale, stride_qm, stride_kn, stride_vn, stride_bm, stride_dom, stride_dqm, stride_dkn, stride_dvn, seqlen_q, seqlen_k, headdim, ATOMIC_ADD: tl.constexpr, BIAS_TYPE: tl.constexpr, IS_CAUSAL: tl.constexpr, BLOCK_HEADDIM: tl.constexpr, EVEN_M: tl.constexpr, EVEN_N: tl.constexpr, EVEN_HEADDIM: tl.constexpr, BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr):\n    begin_m = 0 if not IS_CAUSAL else start_n * BLOCK_N // BLOCK_M * BLOCK_M\n    offs_qm = begin_m + tl.arange(0, BLOCK_M)\n    offs_n = start_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_m = tl.arange(0, BLOCK_M)\n    offs_d = tl.arange(0, BLOCK_HEADDIM)\n    q_ptrs = Q + (offs_qm[:, None] * stride_qm + offs_d[None, :])\n    k_ptrs = K + (offs_n[:, None] * stride_kn + offs_d[None, :])\n    v_ptrs = V + (offs_n[:, None] * stride_vn + offs_d[None, :])\n    do_ptrs = DO + (offs_qm[:, None] * stride_dom + offs_d[None, :])\n    dq_ptrs = DQ + (offs_qm[:, None] * stride_dqm + offs_d[None, :])\n    if BIAS_TYPE == 'vector':\n        b_ptrs = Bias + offs_n\n    elif BIAS_TYPE == 'matrix':\n        b_ptrs = Bias + (offs_qm[:, None] * stride_bm + offs_n[None, :])\n    dv = tl.zeros([BLOCK_N, BLOCK_HEADDIM], dtype=tl.float32)\n    dk = tl.zeros([BLOCK_N, BLOCK_HEADDIM], dtype=tl.float32)\n    if begin_m >= seqlen_q:\n        dv_ptrs = DV + (offs_n[:, None] * stride_dvn + offs_d[None, :])\n        dk_ptrs = DK + (offs_n[:, None] * stride_dkn + offs_d[None, :])\n        _bwd_store_dk_dv(dk_ptrs, dv_ptrs, dk, dv, offs_n, offs_d, seqlen_k, headdim, EVEN_M=EVEN_M, EVEN_N=EVEN_N, EVEN_HEADDIM=EVEN_HEADDIM)\n        return\n    if EVEN_N & EVEN_M:\n        if EVEN_HEADDIM:\n            k = tl.load(k_ptrs)\n            v = tl.load(v_ptrs)\n        else:\n            k = tl.load(k_ptrs, mask=offs_d[None, :] < headdim, other=0.0)\n            v = tl.load(v_ptrs, mask=offs_d[None, :] < headdim, other=0.0)\n    elif EVEN_HEADDIM:\n        k = tl.load(k_ptrs, mask=offs_n[:, None] < seqlen_k, other=0.0)\n        v = tl.load(v_ptrs, mask=offs_n[:, None] < seqlen_k, other=0.0)\n    else:\n        k = tl.load(k_ptrs, mask=(offs_n[:, None] < seqlen_k) & (offs_d[None, :] < headdim), other=0.0)\n        v = tl.load(v_ptrs, mask=(offs_n[:, None] < seqlen_k) & (offs_d[None, :] < headdim), other=0.0)\n    num_block_m = tl.cdiv(seqlen_q, BLOCK_M)\n    for start_m in range(begin_m, num_block_m * BLOCK_M, BLOCK_M):\n        start_m = tl.multiple_of(start_m, BLOCK_M)\n        offs_m_curr = start_m + offs_m\n        if EVEN_M & EVEN_HEADDIM:\n            q = tl.load(q_ptrs)\n        elif EVEN_HEADDIM:\n            q = tl.load(q_ptrs, mask=offs_m_curr[:, None] < seqlen_q, other=0.0)\n        else:\n            q = tl.load(q_ptrs, mask=(offs_m_curr[:, None] < seqlen_q) & (offs_d[None, :] < headdim), other=0.0)\n        qk = tl.dot(q, k, trans_b=True)\n        if not EVEN_N:\n            qk = tl.where(offs_n[None, :] < seqlen_k, qk, float('-inf'))\n        if IS_CAUSAL:\n            qk = tl.where(offs_m_curr[:, None] >= offs_n[None, :], qk, float('-inf'))\n        if BIAS_TYPE != 'none':\n            tl.debug_barrier()\n            if BIAS_TYPE == 'vector':\n                if EVEN_N:\n                    bias = tl.load(b_ptrs).to(tl.float32)\n                else:\n                    bias = tl.load(b_ptrs, mask=offs_n < seqlen_k, other=0.0).to(tl.float32)\n                bias = bias[None, :]\n            elif BIAS_TYPE == 'matrix':\n                if EVEN_M & EVEN_N:\n                    bias = tl.load(b_ptrs).to(tl.float32)\n                else:\n                    bias = tl.load(b_ptrs, mask=(offs_m_curr[:, None] < seqlen_q) & (offs_n[None, :] < seqlen_k), other=0.0).to(tl.float32)\n            qk = qk * softmax_scale + bias\n        if not EVEN_M & EVEN_HEADDIM:\n            tl.debug_barrier()\n        lse_i = tl.load(LSE + offs_m_curr)\n        if BIAS_TYPE == 'none':\n            p = tl.exp(qk * softmax_scale - lse_i[:, None])\n        else:\n            p = tl.exp(qk - lse_i[:, None])\n        if EVEN_M & EVEN_HEADDIM:\n            do = tl.load(do_ptrs)\n        else:\n            do = tl.load(do_ptrs, mask=(offs_m_curr[:, None] < seqlen_q) & (offs_d[None, :] < headdim), other=0.0)\n        dv += tl.dot(p.to(do.dtype), do, trans_a=True)\n        if not EVEN_M & EVEN_HEADDIM:\n            tl.debug_barrier()\n        dp = tl.dot(do, v, trans_b=True)\n        if not EVEN_HEADDIM:\n            tl.debug_barrier()\n        Di = tl.load(D + offs_m_curr)\n        ds = (p * (dp - Di[:, None]) * softmax_scale).to(q.dtype)\n        dk += tl.dot(ds, q, trans_a=True)\n        if not EVEN_M & EVEN_HEADDIM:\n            tl.debug_barrier()\n        if not ATOMIC_ADD:\n            if EVEN_M & EVEN_HEADDIM:\n                dq = tl.load(dq_ptrs, eviction_policy='evict_last')\n                dq += tl.dot(ds, k)\n                tl.store(dq_ptrs, dq, eviction_policy='evict_last')\n            elif EVEN_HEADDIM:\n                dq = tl.load(dq_ptrs, mask=offs_m_curr[:, None] < seqlen_q, other=0.0, eviction_policy='evict_last')\n                dq += tl.dot(ds, k)\n                tl.store(dq_ptrs, dq, mask=offs_m_curr[:, None] < seqlen_q, eviction_policy='evict_last')\n            else:\n                dq = tl.load(dq_ptrs, mask=(offs_m_curr[:, None] < seqlen_q) & (offs_d[None, :] < headdim), other=0.0, eviction_policy='evict_last')\n                dq += tl.dot(ds, k)\n                tl.store(dq_ptrs, dq, mask=(offs_m_curr[:, None] < seqlen_q) & (offs_d[None, :] < headdim), eviction_policy='evict_last')\n        else:\n            dq = tl.dot(ds, k)\n            if EVEN_M & EVEN_HEADDIM:\n                tl.atomic_add(dq_ptrs, dq)\n            elif EVEN_HEADDIM:\n                tl.atomic_add(dq_ptrs, dq, mask=offs_m_curr[:, None] < seqlen_q)\n            else:\n                tl.atomic_add(dq_ptrs, dq, mask=(offs_m_curr[:, None] < seqlen_q) & (offs_d[None, :] < headdim))\n        dq_ptrs += BLOCK_M * stride_dqm\n        q_ptrs += BLOCK_M * stride_qm\n        do_ptrs += BLOCK_M * stride_dom\n        if BIAS_TYPE == 'matrix':\n            b_ptrs += BLOCK_M * stride_bm\n    dv_ptrs = DV + (offs_n[:, None] * stride_dvn + offs_d[None, :])\n    dk_ptrs = DK + (offs_n[:, None] * stride_dkn + offs_d[None, :])\n    _bwd_store_dk_dv(dk_ptrs, dv_ptrs, dk, dv, offs_n, offs_d, seqlen_k, headdim, EVEN_M=EVEN_M, EVEN_N=EVEN_N, EVEN_HEADDIM=EVEN_HEADDIM)\n\ndef init_to_zero(name):\n    return lambda nargs: nargs[name].zero_()\n\n@triton.autotune(configs=[triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'SEQUENCE_PARALLEL': False}, num_warps=8, num_stages=1, pre_hook=init_to_zero('DQ')), triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'SEQUENCE_PARALLEL': True}, num_warps=8, num_stages=1, pre_hook=init_to_zero('DQ'))], key=['CACHE_KEY_SEQLEN_Q', 'CACHE_KEY_SEQLEN_K', 'BIAS_TYPE', 'IS_CAUSAL', 'BLOCK_HEADDIM'])\n@triton.heuristics({'EVEN_M': lambda args: args['seqlen_q'] % args['BLOCK_M'] == 0, 'EVEN_N': lambda args: args['seqlen_k'] % args['BLOCK_N'] == 0, 'EVEN_HEADDIM': lambda args: args['headdim'] == args['BLOCK_HEADDIM']})\n@triton.jit\ndef _bwd_kernel(Q, K, V, Bias, DO, DQ, DK, DV, LSE, D, softmax_scale, stride_qb, stride_qh, stride_qm, stride_kb, stride_kh, stride_kn, stride_vb, stride_vh, stride_vn, stride_bb, stride_bh, stride_bm, stride_dob, stride_doh, stride_dom, stride_dqb, stride_dqh, stride_dqm, stride_dkb, stride_dkh, stride_dkn, stride_dvb, stride_dvh, stride_dvn, nheads, seqlen_q, seqlen_k, seqlen_q_rounded, headdim, CACHE_KEY_SEQLEN_Q, CACHE_KEY_SEQLEN_K, BIAS_TYPE: tl.constexpr, IS_CAUSAL: tl.constexpr, BLOCK_HEADDIM: tl.constexpr, SEQUENCE_PARALLEL: tl.constexpr, EVEN_M: tl.constexpr, EVEN_N: tl.constexpr, EVEN_HEADDIM: tl.constexpr, BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr):\n    off_hb = tl.program_id(1)\n    off_b = off_hb // nheads\n    off_h = off_hb % nheads\n    Q += off_b * stride_qb + off_h * stride_qh\n    K += off_b * stride_kb + off_h * stride_kh\n    V += off_b * stride_vb + off_h * stride_vh\n    DO += off_b * stride_dob + off_h * stride_doh\n    DQ += off_b * stride_dqb + off_h * stride_dqh\n    DK += off_b * stride_dkb + off_h * stride_dkh\n    DV += off_b * stride_dvb + off_h * stride_dvh\n    if BIAS_TYPE != 'none':\n        Bias += off_b * stride_bb + off_h * stride_bh\n    D += off_hb * seqlen_q_rounded\n    LSE += off_hb * seqlen_q_rounded\n    if not SEQUENCE_PARALLEL:\n        num_block_n = tl.cdiv(seqlen_k, BLOCK_N)\n        for start_n in range(0, num_block_n):\n            _bwd_kernel_one_col_block(start_n, Q, K, V, Bias, DO, DQ, DK, DV, LSE, D, softmax_scale, stride_qm, stride_kn, stride_vn, stride_bm, stride_dom, stride_dqm, stride_dkn, stride_dvn, seqlen_q, seqlen_k, headdim, ATOMIC_ADD=False, BIAS_TYPE=BIAS_TYPE, IS_CAUSAL=IS_CAUSAL, BLOCK_HEADDIM=BLOCK_HEADDIM, EVEN_M=EVEN_M, EVEN_N=EVEN_N, EVEN_HEADDIM=EVEN_HEADDIM, BLOCK_M=BLOCK_M, BLOCK_N=BLOCK_N)\n    else:\n        start_n = tl.program_id(0)\n        _bwd_kernel_one_col_block(start_n, Q, K, V, Bias, DO, DQ, DK, DV, LSE, D, softmax_scale, stride_qm, stride_kn, stride_vn, stride_bm, stride_dom, stride_dqm, stride_dkn, stride_dvn, seqlen_q, seqlen_k, headdim, ATOMIC_ADD=True, BIAS_TYPE=BIAS_TYPE, IS_CAUSAL=IS_CAUSAL, BLOCK_HEADDIM=BLOCK_HEADDIM, EVEN_M=EVEN_M, EVEN_N=EVEN_N, EVEN_HEADDIM=EVEN_HEADDIM, BLOCK_M=BLOCK_M, BLOCK_N=BLOCK_N)\n\ndef _flash_attn_forward(q, k, v, bias=None, causal=False, softmax_scale=None):\n    (batch, seqlen_q, nheads, d) = q.shape\n    (_, seqlen_k, _, _) = k.shape\n    assert k.shape == (batch, seqlen_k, nheads, d)\n    assert v.shape == (batch, seqlen_k, nheads, d)\n    assert d <= 128, 'FlashAttention only support head dimensions up to 128'\n    assert q.dtype == k.dtype == v.dtype, 'All tensors must have the same type'\n    assert q.dtype in [torch.float16, torch.bfloat16], 'Only support fp16 and bf16'\n    assert q.is_cuda and k.is_cuda and v.is_cuda\n    softmax_scale = softmax_scale or 1.0 / math.sqrt(d)\n    has_bias = bias is not None\n    bias_type = 'none'\n    if has_bias:\n        assert bias.dtype in [q.dtype, torch.float]\n        assert bias.is_cuda\n        assert bias.dim() == 4\n        if bias.stride(-1) != 1:\n            bias = bias.contiguous()\n        if bias.shape[2:] == (1, seqlen_k):\n            bias_type = 'vector'\n        elif bias.shape[2:] == (seqlen_q, seqlen_k):\n            bias_type = 'matrix'\n        else:\n            raise RuntimeError('Last 2 dimensions of bias must be (1, seqlen_k) or (seqlen_q, seqlen_k)')\n        bias = bias.expand(batch, nheads, seqlen_q, seqlen_k)\n    bias_strides = (bias.stride(0), bias.stride(1), bias.stride(2)) if has_bias else (0, 0, 0)\n    seqlen_q_rounded = math.ceil(seqlen_q / 128) * 128\n    lse = torch.empty((batch, nheads, seqlen_q_rounded), device=q.device, dtype=torch.float32)\n    tmp = torch.empty((batch, nheads, seqlen_q_rounded), device=q.device, dtype=torch.float32)\n    o = torch.empty_like(q)\n    BLOCK_HEADDIM = max(triton.next_power_of_2(d), 16)\n    BLOCK = 128\n    num_warps = 4 if d <= 64 else 8\n    grid = lambda META: (triton.cdiv(seqlen_q, META['BLOCK_M']), batch * nheads)\n    _fwd_kernel[grid](q, k, v, bias, o, lse, tmp, softmax_scale, q.stride(0), q.stride(2), q.stride(1), k.stride(0), k.stride(2), k.stride(1), v.stride(0), v.stride(2), v.stride(1), *bias_strides, o.stride(0), o.stride(2), o.stride(1), nheads, seqlen_q, seqlen_k, seqlen_q_rounded, d, seqlen_q // 32, seqlen_k // 32, bias_type, causal, BLOCK_HEADDIM, BLOCK_M=BLOCK, BLOCK_N=BLOCK, num_warps=num_warps, num_stages=1)\n    return (o, lse, softmax_scale)\n\ndef _flash_attn_backward(do, q, k, v, o, lse, dq, dk, dv, bias=None, causal=False, softmax_scale=None):\n    if do.stride(-1) != 1:\n        do = do.contiguous()\n    (batch, seqlen_q, nheads, d) = q.shape\n    (_, seqlen_k, _, _) = k.shape\n    assert d <= 128\n    seqlen_q_rounded = math.ceil(seqlen_q / 128) * 128\n    assert lse.shape == (batch, nheads, seqlen_q_rounded)\n    assert q.stride(-1) == k.stride(-1) == v.stride(-1) == o.stride(-1) == 1\n    assert dq.stride(-1) == dk.stride(-1) == dv.stride(-1) == 1\n    softmax_scale = softmax_scale or 1.0 / math.sqrt(d)\n    dq_accum = torch.empty_like(q, dtype=torch.float32)\n    delta = torch.empty_like(lse)\n    BLOCK_HEADDIM = max(triton.next_power_of_2(d), 16)\n    grid = lambda META: (triton.cdiv(seqlen_q, META['BLOCK_M']), batch * nheads)\n    _bwd_preprocess_do_o_dot[grid](o, do, delta, o.stride(0), o.stride(2), o.stride(1), do.stride(0), do.stride(2), do.stride(1), nheads, seqlen_q, seqlen_q_rounded, d, BLOCK_M=128, BLOCK_HEADDIM=BLOCK_HEADDIM)\n    has_bias = bias is not None\n    bias_type = 'none'\n    if has_bias:\n        assert bias.dtype in [q.dtype, torch.float]\n        assert bias.is_cuda\n        assert bias.dim() == 4\n        assert bias.stride(-1) == 1\n        if bias.shape[2:] == (1, seqlen_k):\n            bias_type = 'vector'\n        elif bias.shape[2:] == (seqlen_q, seqlen_k):\n            bias_type = 'matrix'\n        else:\n            raise RuntimeError('Last 2 dimensions of bias must be (1, seqlen_k) or (seqlen_q, seqlen_k)')\n        bias = bias.expand(batch, nheads, seqlen_q, seqlen_k)\n    bias_strides = (bias.stride(0), bias.stride(1), bias.stride(2)) if has_bias else (0, 0, 0)\n    grid = lambda META: (triton.cdiv(seqlen_k, META['BLOCK_N']) if META['SEQUENCE_PARALLEL'] else 1, batch * nheads)\n    _bwd_kernel[grid](q, k, v, bias, do, dq_accum, dk, dv, lse, delta, softmax_scale, q.stride(0), q.stride(2), q.stride(1), k.stride(0), k.stride(2), k.stride(1), v.stride(0), v.stride(2), v.stride(1), *bias_strides, do.stride(0), do.stride(2), do.stride(1), dq_accum.stride(0), dq_accum.stride(2), dq_accum.stride(1), dk.stride(0), dk.stride(2), dk.stride(1), dv.stride(0), dv.stride(2), dv.stride(1), nheads, seqlen_q, seqlen_k, seqlen_q_rounded, d, seqlen_q // 32, seqlen_k // 32, bias_type, causal, BLOCK_HEADDIM)\n    dq.copy_(dq_accum)\n\nclass FlashAttnQKVPackedFunc(torch.autograd.Function):\n\n    @staticmethod\n    def forward(ctx, qkv, bias=None, causal=False, softmax_scale=None):\n        \"\"\"\n            qkv: (batch, seqlen, 3, nheads, headdim)\n            bias: optional, shape broadcastible to (batch, nheads, seqlen, seqlen).\n                For example, ALiBi mask for causal would have shape (1, nheads, 1, seqlen).\n                ALiBi mask for non-causal would have shape (1, nheads, seqlen, seqlen)\n        \"\"\"\n        if qkv.stride(-1) != 1:\n            qkv = qkv.contiguous()\n        (o, lse, ctx.softmax_scale) = _flash_attn_forward(qkv[:, :, 0], qkv[:, :, 1], qkv[:, :, 2], bias=bias, causal=causal, softmax_scale=softmax_scale)\n        ctx.save_for_backward(qkv, o, lse, bias)\n        ctx.causal = causal\n        return o\n\n    @staticmethod\n    def backward(ctx, do):\n        (qkv, o, lse, bias) = ctx.saved_tensors\n        assert not ctx.needs_input_grad[1], 'FlashAttention does not support bias gradient yet'\n        with torch.inference_mode():\n            dqkv = torch.empty_like(qkv)\n            _flash_attn_backward(do, qkv[:, :, 0], qkv[:, :, 1], qkv[:, :, 2], o, lse, dqkv[:, :, 0], dqkv[:, :, 1], dqkv[:, :, 2], bias=bias, causal=ctx.causal, softmax_scale=ctx.softmax_scale)\n        return (dqkv, None, None, None)\nflash_attn_qkvpacked_func = FlashAttnQKVPackedFunc.apply\n\nclass FlashAttnKVPackedFunc(torch.autograd.Function):\n\n    @staticmethod\n    def forward(ctx, q, kv, bias=None, causal=False, softmax_scale=None):\n        \"\"\"\n            q: (batch, seqlen_q, nheads, headdim)\n            kv: (batch, seqlen_k, 2, nheads, headdim)\n            bias: optional, shape broadcastible to (batch, nheads, seqlen_q, seqlen_k).\n                For example, ALiBi mask for causal would have shape (1, nheads, 1, seqlen_k).\n                ALiBi mask for non-causal would have shape (1, nheads, seqlen_q, seqlen_k)\n        \"\"\"\n        (q, kv) = [x if x.stride(-1) == 1 else x.contiguous() for x in [q, kv]]\n        (o, lse, ctx.softmax_scale) = _flash_attn_forward(q, kv[:, :, 0], kv[:, :, 1], bias=bias, causal=causal, softmax_scale=softmax_scale)\n        ctx.save_for_backward(q, kv, o, lse, bias)\n        ctx.causal = causal\n        return o\n\n    @staticmethod\n    def backward(ctx, do):\n        (q, kv, o, lse, bias) = ctx.saved_tensors\n        if len(ctx.needs_input_grad) >= 3:\n            assert not ctx.needs_input_grad[2], 'FlashAttention does not support bias gradient yet'\n        with torch.inference_mode():\n            dq = torch.empty_like(q)\n            dkv = torch.empty_like(kv)\n            _flash_attn_backward(do, q, kv[:, :, 0], kv[:, :, 1], o, lse, dq, dkv[:, :, 0], dkv[:, :, 1], bias=bias, causal=ctx.causal, softmax_scale=ctx.softmax_scale)\n        return (dq, dkv, None, None, None)\nflash_attn_kvpacked_func = FlashAttnKVPackedFunc.apply\n\nclass FlashAttnFunc(torch.autograd.Function):\n\n    @staticmethod\n    def forward(ctx, q, k, v, bias=None, causal=False, softmax_scale=None):\n        \"\"\"\n            q: (batch_size, seqlen_q, nheads, headdim)\n            k, v: (batch_size, seqlen_k, nheads, headdim)\n            bias: optional, shape broadcastible to (batch, nheads, seqlen_q, seqlen_k).\n                For example, ALiBi mask for causal would have shape (1, nheads, 1, seqlen_k).\n                ALiBi mask for non-causal would have shape (1, nheads, seqlen_q, seqlen_k)\n        \"\"\"\n        (q, k, v) = [x if x.stride(-1) == 1 else x.contiguous() for x in [q, k, v]]\n        (o, lse, ctx.softmax_scale) = _flash_attn_forward(q, k, v, bias=bias, causal=causal, softmax_scale=softmax_scale)\n        ctx.save_for_backward(q, k, v, o, lse, bias)\n        ctx.causal = causal\n        return o\n\n    @staticmethod\n    def backward(ctx, do):\n        (q, k, v, o, lse, bias) = ctx.saved_tensors\n        assert not ctx.needs_input_grad[3], 'FlashAttention does not support bias gradient yet'\n        with torch.inference_mode():\n            dq = torch.empty_like(q)\n            dk = torch.empty_like(k)\n            dv = torch.empty_like(v)\n            _flash_attn_backward(do, q, k, v, o, lse, dq, dk, dv, bias=bias, causal=ctx.causal, softmax_scale=ctx.softmax_scale)\n        return (dq, dk, dv, None, None, None)\nflash_attn_func = FlashAttnFunc.apply"}
{"type": "source_file", "path": "LLaVA/llava/eval/qa_baseline_gpt35.py", "content": "\"\"\"Generate answers with GPT-3.5\"\"\"\n# Note: you need to be using OpenAI Python v0.27.0 for the code below to work\nimport argparse\nimport json\nimport os\nimport time\nimport concurrent.futures\n\nimport openai\nimport tqdm\nimport shortuuid\n\nMODEL = 'gpt-3.5-turbo'\nMODEL_ID = 'gpt-3.5-turbo:20230327'\n\ndef get_answer(question_id: int, question: str, max_tokens: int):\n    ans = {\n        'answer_id': shortuuid.uuid(),\n        'question_id': question_id,\n        'model_id': MODEL_ID,\n    }\n    for _ in range(3):\n        try:\n            response = openai.ChatCompletion.create(\n                model=MODEL,\n                messages=[{\n                    'role': 'system',\n                    'content': 'You are a helpful assistant.'\n                }, {\n                    'role': 'user',\n                    'content': question,\n                }],\n                max_tokens=max_tokens,\n            )\n            ans['text'] = response['choices'][0]['message']['content']\n            return ans\n        except Exception as e:\n            print('[ERROR]', e)\n            ans['text'] = '#ERROR#'\n            time.sleep(1)\n    return ans\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='ChatGPT answer generation.')\n    parser.add_argument('-q', '--question')\n    parser.add_argument('-o', '--output')\n    parser.add_argument('--max-tokens', type=int, default=1024, help='maximum number of tokens produced in the output')\n    args = parser.parse_args()\n\n    questions_dict = {}\n    with open(os.path.expanduser(args.question)) as f:\n        for line in f:\n            if not line:\n                continue\n            q = json.loads(line)\n            questions_dict[q['question_id']] = q['text']\n\n    answers = []\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=32) as executor:\n        futures = []\n        for qid, question in questions_dict.items():\n            future = executor.submit(get_answer, qid, question, args.max_tokens)\n            futures.append(future)\n\n        for future in tqdm.tqdm(concurrent.futures.as_completed(futures), total=len(futures)):\n            answers.append(future.result())\n\n    answers.sort(key=lambda x: x['question_id'])\n\n    with open(os.path.expanduser(args.output), 'w') as f:\n        table = [json.dumps(ans) for ans in answers]\n        f.write('\\n'.join(table))\n"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/norm.py", "content": "import torch\n\ndef _cast_if_autocast_enabled(tensor):\n    if torch.is_autocast_enabled():\n        if tensor.device.type == 'cuda':\n            dtype = torch.get_autocast_gpu_dtype()\n        elif tensor.device.type == 'cpu':\n            dtype = torch.get_autocast_cpu_dtype()\n        else:\n            raise NotImplementedError()\n        return tensor.to(dtype=dtype)\n    return tensor\n\nclass LPLayerNorm(torch.nn.LayerNorm):\n\n    def __init__(self, normalized_shape, eps=1e-05, elementwise_affine=True, device=None, dtype=None):\n        super().__init__(normalized_shape=normalized_shape, eps=eps, elementwise_affine=elementwise_affine, device=device, dtype=dtype)\n\n    def forward(self, x):\n        module_device = x.device\n        downcast_x = _cast_if_autocast_enabled(x)\n        downcast_weight = _cast_if_autocast_enabled(self.weight) if self.weight is not None else self.weight\n        downcast_bias = _cast_if_autocast_enabled(self.bias) if self.bias is not None else self.bias\n        with torch.autocast(enabled=False, device_type=module_device.type):\n            return torch.nn.functional.layer_norm(downcast_x, self.normalized_shape, downcast_weight, downcast_bias, self.eps)\n\ndef rms_norm(x, weight=None, eps=1e-05):\n    output = x * torch.rsqrt(x.pow(2).mean(-1, keepdim=True) + eps)\n    if weight is not None:\n        return output * weight\n    return output\n\nclass RMSNorm(torch.nn.Module):\n\n    def __init__(self, normalized_shape, eps=1e-05, weight=True, dtype=None, device=None):\n        super().__init__()\n        self.eps = eps\n        if weight:\n            self.weight = torch.nn.Parameter(torch.ones(normalized_shape, dtype=dtype, device=device))\n        else:\n            self.register_parameter('weight', None)\n\n    def forward(self, x):\n        return rms_norm(x.float(), self.weight, self.eps).to(dtype=x.dtype)\n\nclass LPRMSNorm(RMSNorm):\n\n    def __init__(self, normalized_shape, eps=1e-05, weight=True, dtype=None, device=None):\n        super().__init__(normalized_shape=normalized_shape, eps=eps, weight=weight, dtype=dtype, device=device)\n\n    def forward(self, x):\n        downcast_x = _cast_if_autocast_enabled(x)\n        downcast_weight = _cast_if_autocast_enabled(self.weight) if self.weight is not None else self.weight\n        with torch.autocast(enabled=False, device_type=x.device.type):\n            return rms_norm(downcast_x, downcast_weight, self.eps).to(dtype=x.dtype)\nNORM_CLASS_REGISTRY = {'layernorm': torch.nn.LayerNorm, 'low_precision_layernorm': LPLayerNorm, 'rmsnorm': RMSNorm, 'low_precision_rmsnorm': LPRMSNorm}"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/hf_prefixlm_converter.py", "content": "\"\"\"Converts Huggingface Causal LM to Prefix LM.\n\nConversion does lightweight surgery on a HuggingFace\nCausal LM to convert it to a Prefix LM.\n\nPrefix LMs accepts a `bidirectional_mask` input in `forward`\nand treat the input prompt as the prefix in `generate`.\n\"\"\"\nimport math\nimport warnings\nfrom types import MethodType\nfrom typing import Any, Dict, List, Optional, Tuple, Union\nimport torch\nfrom transformers.models.bloom.modeling_bloom import BaseModelOutputWithPastAndCrossAttentions, BloomForCausalLM, BloomModel, CausalLMOutputWithCrossAttentions, CrossEntropyLoss\nfrom transformers.models.bloom.modeling_bloom import _expand_mask as _expand_mask_bloom\nfrom transformers.models.bloom.modeling_bloom import _make_causal_mask as _make_causal_mask_bloom\nfrom transformers.models.bloom.modeling_bloom import logging\nfrom transformers.models.gpt2.modeling_gpt2 import GPT2LMHeadModel\nfrom transformers.models.gpt_neo.modeling_gpt_neo import GPTNeoForCausalLM\nfrom transformers.models.gpt_neox.modeling_gpt_neox import GPTNeoXForCausalLM\nfrom transformers.models.gptj.modeling_gptj import GPTJForCausalLM\nfrom transformers.models.opt.modeling_opt import OPTForCausalLM\nfrom transformers.models.opt.modeling_opt import _expand_mask as _expand_mask_opt\nfrom transformers.models.opt.modeling_opt import _make_causal_mask as _make_causal_mask_opt\nlogger = logging.get_logger(__name__)\n_SUPPORTED_GPT_MODELS = (GPT2LMHeadModel, GPTJForCausalLM, GPTNeoForCausalLM, GPTNeoXForCausalLM)\nCAUSAL_GPT_TYPES = Union[GPT2LMHeadModel, GPTJForCausalLM, GPTNeoForCausalLM, GPTNeoXForCausalLM]\n\ndef _convert_gpt_causal_lm_to_prefix_lm(model: CAUSAL_GPT_TYPES) -> CAUSAL_GPT_TYPES:\n    \"\"\"Converts a GPT-style Causal LM to a Prefix LM.\n\n    Supported HuggingFace model classes:\n        - `GPT2LMHeadModel`\n        - `GPTNeoForCausalLM`\n        - `GPTNeoXForCausalLM`\n        - `GPTJForCausalLM`\n\n    See `convert_hf_causal_lm_to_prefix_lm` for more details.\n    \"\"\"\n    if hasattr(model, '_prefix_lm_converted'):\n        return model\n    assert isinstance(model, _SUPPORTED_GPT_MODELS)\n    assert model.config.add_cross_attention == False, 'Only supports GPT-style decoder-only models'\n\n    def _get_attn_modules(model: CAUSAL_GPT_TYPES) -> List[torch.nn.Module]:\n        \"\"\"Helper that gets a list of the model's attention modules.\n\n        Each module has a `bias` buffer used for causal masking. The Prefix LM\n        conversion adds logic to dynamically manipulate these biases to support\n        Prefix LM attention masking.\n        \"\"\"\n        attn_modules = []\n        if isinstance(model, GPTNeoXForCausalLM):\n            blocks = model.gpt_neox.layers\n        else:\n            blocks = model.transformer.h\n        for block in blocks:\n            if isinstance(model, GPTNeoForCausalLM):\n                if block.attn.attention_type != 'global':\n                    continue\n                attn_module = block.attn.attention\n            elif isinstance(model, GPTNeoXForCausalLM):\n                attn_module = block.attention\n            else:\n                attn_module = block.attn\n            attn_modules.append(attn_module)\n        return attn_modules\n    setattr(model, '_original_forward', getattr(model, 'forward'))\n    setattr(model, '_original_generate', getattr(model, 'generate'))\n\n    def forward(self: CAUSAL_GPT_TYPES, input_ids: Optional[torch.LongTensor]=None, past_key_values: Optional[Tuple[Tuple[torch.Tensor]]]=None, attention_mask: Optional[torch.FloatTensor]=None, bidirectional_mask: Optional[torch.Tensor]=None, token_type_ids: Optional[torch.LongTensor]=None, position_ids: Optional[torch.LongTensor]=None, head_mask: Optional[torch.FloatTensor]=None, inputs_embeds: Optional[torch.FloatTensor]=None, labels: Optional[torch.LongTensor]=None, use_cache: Optional[bool]=None, output_attentions: Optional[bool]=None, output_hidden_states: Optional[bool]=None, return_dict: Optional[bool]=None):\n        \"\"\"Wraps original forward to enable PrefixLM attention.\"\"\"\n\n        def call_og_forward():\n            if isinstance(self, GPTNeoXForCausalLM):\n                return self._original_forward(input_ids=input_ids, past_key_values=past_key_values, attention_mask=attention_mask, head_mask=head_mask, inputs_embeds=inputs_embeds, labels=labels, use_cache=use_cache, output_attentions=output_attentions, output_hidden_states=output_hidden_states, return_dict=return_dict)\n            else:\n                return self._original_forward(input_ids=input_ids, past_key_values=past_key_values, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask, inputs_embeds=inputs_embeds, labels=labels, use_cache=use_cache, output_attentions=output_attentions, output_hidden_states=output_hidden_states, return_dict=return_dict)\n        if bidirectional_mask is None:\n            return call_og_forward()\n        assert isinstance(bidirectional_mask, torch.Tensor)\n        attn_modules = _get_attn_modules(model)\n        (b, s) = bidirectional_mask.shape\n        max_length = attn_modules[0].bias.shape[-1]\n        if s > max_length:\n            raise ValueError(f'bidirectional_mask sequence length (={s}) exceeds the ' + f'max length allowed by the model ({max_length}).')\n        assert s <= max_length\n        if s < max_length:\n            pad = torch.zeros((int(b), int(max_length - s)), dtype=bidirectional_mask.dtype, device=bidirectional_mask.device)\n            bidirectional_mask = torch.cat([bidirectional_mask, pad], dim=1)\n        bidirectional = bidirectional_mask.unsqueeze(1).unsqueeze(1)\n        for attn_module in attn_modules:\n            attn_module.bias.data = torch.logical_or(attn_module.bias.data, bidirectional)\n        output = call_og_forward()\n        for attn_module in attn_modules:\n            attn_module.bias.data = torch.tril(attn_module.bias.data[0, 0])[None, None]\n        return output\n\n    def generate(self: CAUSAL_GPT_TYPES, *args: tuple, **kwargs: Dict[str, Any]):\n        \"\"\"Wraps original generate to enable PrefixLM attention.\"\"\"\n        attn_modules = _get_attn_modules(model)\n        for attn_module in attn_modules:\n            attn_module.bias.data[:] = 1\n        output = self._original_generate(*args, **kwargs)\n        for attn_module in attn_modules:\n            attn_module.bias.data = torch.tril(attn_module.bias.data[0, 0])[None, None]\n        return output\n    setattr(model, 'forward', MethodType(forward, model))\n    setattr(model, 'generate', MethodType(generate, model))\n    setattr(model, '_prefix_lm_converted', True)\n    return model\n\ndef _convert_bloom_causal_lm_to_prefix_lm(model: BloomForCausalLM) -> BloomForCausalLM:\n    \"\"\"Converts a BLOOM Causal LM to a Prefix LM.\n\n    Supported HuggingFace model classes:\n        - `BloomForCausalLM`\n\n    See `convert_hf_causal_lm_to_prefix_lm` for more details.\n    \"\"\"\n    if hasattr(model, '_prefix_lm_converted'):\n        return model\n    assert isinstance(model, BloomForCausalLM)\n    assert model.config.add_cross_attention == False, 'Only supports BLOOM decoder-only models'\n\n    def _prepare_attn_mask(self: BloomModel, attention_mask: torch.Tensor, bidirectional_mask: Optional[torch.Tensor], input_shape: Tuple[int, int], past_key_values_length: int) -> torch.BoolTensor:\n        combined_attention_mask = None\n        device = attention_mask.device\n        (_, src_length) = input_shape\n        if src_length > 1:\n            combined_attention_mask = _make_causal_mask_bloom(input_shape, device=device, past_key_values_length=past_key_values_length)\n            if bidirectional_mask is not None:\n                assert attention_mask.shape == bidirectional_mask.shape\n                expanded_bidirectional_mask = _expand_mask_bloom(bidirectional_mask, tgt_length=src_length)\n                combined_attention_mask = torch.logical_and(combined_attention_mask, expanded_bidirectional_mask)\n        expanded_attn_mask = _expand_mask_bloom(attention_mask, tgt_length=src_length)\n        combined_attention_mask = expanded_attn_mask if combined_attention_mask is None else expanded_attn_mask | combined_attention_mask\n        return combined_attention_mask\n\n    def _build_alibi_tensor(self: BloomModel, batch_size: int, query_length: int, key_length: int, dtype: torch.dtype, device: torch.device) -> torch.Tensor:\n        num_heads = self.config.n_head\n        closest_power_of_2 = 2 ** math.floor(math.log2(num_heads))\n        base = torch.tensor(2 ** (-2 ** (-(math.log2(closest_power_of_2) - 3))), device=device, dtype=torch.float32)\n        powers = torch.arange(1, 1 + closest_power_of_2, device=device, dtype=torch.int32)\n        slopes = torch.pow(base, powers)\n        if closest_power_of_2 != num_heads:\n            extra_base = torch.tensor(2 ** (-2 ** (-(math.log2(2 * closest_power_of_2) - 3))), device=device, dtype=torch.float32)\n            num_remaining_heads = min(closest_power_of_2, num_heads - closest_power_of_2)\n            extra_powers = torch.arange(1, 1 + 2 * num_remaining_heads, 2, device=device, dtype=torch.int32)\n            slopes = torch.cat([slopes, torch.pow(extra_base, extra_powers)], dim=0)\n        qa = torch.arange(query_length, device=device, dtype=torch.int32).view(-1, 1)\n        ka = torch.arange(key_length, device=device, dtype=torch.int32).view(1, -1)\n        diffs = qa - ka + key_length - query_length\n        diffs = -diffs.abs()\n        alibi = slopes.view(1, num_heads, 1, 1) * diffs.view(1, 1, query_length, key_length)\n        alibi = alibi.expand(batch_size, -1, -1, -1).reshape(-1, query_length, key_length)\n        return alibi.to(dtype)\n    KeyValueT = Tuple[torch.Tensor, torch.Tensor]\n\n    def forward(self: BloomModel, input_ids: Optional[torch.LongTensor]=None, past_key_values: Optional[Tuple[KeyValueT, ...]]=None, attention_mask: Optional[torch.Tensor]=None, bidirectional_mask: Optional[torch.Tensor]=None, head_mask: Optional[torch.LongTensor]=None, inputs_embeds: Optional[torch.LongTensor]=None, use_cache: Optional[bool]=None, output_attentions: Optional[bool]=None, output_hidden_states: Optional[bool]=None, return_dict: Optional[bool]=None, **deprecated_arguments) -> Union[Tuple[torch.Tensor, ...], BaseModelOutputWithPastAndCrossAttentions]:\n        if deprecated_arguments.pop('position_ids', False) is not False:\n            warnings.warn('`position_ids` have no functionality in BLOOM and will be removed in v5.0.0. ' + 'You can safely ignore passing `position_ids`.', FutureWarning)\n        if len(deprecated_arguments) > 0:\n            raise ValueError(f'Got unexpected arguments: {deprecated_arguments}')\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError('You cannot specify both input_ids and inputs_embeds at the same time')\n        elif input_ids is not None:\n            (batch_size, seq_length) = input_ids.shape\n        elif inputs_embeds is not None:\n            (batch_size, seq_length, _) = inputs_embeds.shape\n        else:\n            raise ValueError('You have to specify either input_ids or inputs_embeds')\n        if past_key_values is None:\n            past_key_values = tuple([None] * len(self.h))\n        head_mask = self.get_head_mask(head_mask, self.config.n_layer)\n        if inputs_embeds is None:\n            inputs_embeds = self.word_embeddings(input_ids)\n        hidden_states = self.word_embeddings_layernorm(inputs_embeds)\n        presents = () if use_cache else None\n        all_self_attentions = () if output_attentions else None\n        all_hidden_states = () if output_hidden_states else None\n        seq_length_with_past = seq_length\n        past_key_values_length = 0\n        if past_key_values[0] is not None:\n            tmp = past_key_values[0][0]\n            past_key_values_length = tmp.shape[2]\n            seq_length_with_past = seq_length_with_past + past_key_values_length\n        if attention_mask is None:\n            attention_mask = torch.ones((batch_size, seq_length_with_past), device=hidden_states.device)\n        else:\n            attention_mask = attention_mask.to(hidden_states.device)\n        alibi = self._build_alibi_tensor(batch_size=batch_size, query_length=seq_length, key_length=seq_length_with_past, dtype=hidden_states.dtype, device=hidden_states.device)\n        causal_mask = self._prepare_attn_mask(attention_mask, bidirectional_mask, input_shape=(batch_size, seq_length), past_key_values_length=past_key_values_length)\n        for (i, (block, layer_past)) in enumerate(zip(self.h, past_key_values)):\n            if output_hidden_states:\n                hst = (hidden_states,)\n                all_hidden_states = all_hidden_states + hst\n            if self.gradient_checkpointing and self.training:\n                if use_cache:\n                    logger.warning('`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...')\n                    use_cache = False\n\n                def create_custom_forward(module):\n\n                    def custom_forward(*inputs):\n                        return module(*inputs, use_cache=use_cache, output_attentions=output_attentions)\n                    return custom_forward\n                outputs = torch.utils.checkpoint.checkpoint(create_custom_forward(block), hidden_states, alibi, causal_mask, head_mask[i])\n            else:\n                outputs = block(hidden_states, layer_past=layer_past, attention_mask=causal_mask, head_mask=head_mask[i], use_cache=use_cache, output_attentions=output_attentions, alibi=alibi)\n            hidden_states = outputs[0]\n            if use_cache is True:\n                presents = presents + (outputs[1],)\n            if output_attentions:\n                oa = (outputs[2 if use_cache else 1],)\n                all_self_attentions = all_self_attentions + oa\n        hidden_states = self.ln_f(hidden_states)\n        if output_hidden_states:\n            hst = (hidden_states,)\n            all_hidden_states = all_hidden_states + hst\n        if not return_dict:\n            return tuple((v for v in [hidden_states, presents, all_hidden_states, all_self_attentions] if v is not None))\n        return BaseModelOutputWithPastAndCrossAttentions(last_hidden_state=hidden_states, past_key_values=presents, hidden_states=all_hidden_states, attentions=all_self_attentions)\n    setattr(model.transformer, '_prepare_attn_mask', MethodType(_prepare_attn_mask, model.transformer))\n    setattr(model.transformer, '_build_alibi_tensor', MethodType(_build_alibi_tensor, model.transformer))\n    setattr(model.transformer, 'forward', MethodType(forward, model.transformer))\n    KeyValueT = Tuple[torch.Tensor, torch.Tensor]\n\n    def forward(self: BloomForCausalLM, input_ids: Optional[torch.LongTensor]=None, past_key_values: Optional[Tuple[KeyValueT, ...]]=None, attention_mask: Optional[torch.Tensor]=None, bidirectional_mask: Optional[torch.Tensor]=None, head_mask: Optional[torch.Tensor]=None, inputs_embeds: Optional[torch.Tensor]=None, labels: Optional[torch.Tensor]=None, use_cache: Optional[bool]=None, output_attentions: Optional[bool]=None, output_hidden_states: Optional[bool]=None, return_dict: Optional[bool]=None, **deprecated_arguments) -> Union[Tuple[torch.Tensor], CausalLMOutputWithCrossAttentions]:\n        \"\"\"Replacement forward method for BloomCausalLM.\"\"\"\n        if deprecated_arguments.pop('position_ids', False) is not False:\n            warnings.warn('`position_ids` have no functionality in BLOOM and will be removed ' + 'in v5.0.0. You can safely ignore passing `position_ids`.', FutureWarning)\n        if len(deprecated_arguments) > 0:\n            raise ValueError(f'Got unexpected arguments: {deprecated_arguments}')\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        transformer_outputs = self.transformer(input_ids, past_key_values=past_key_values, attention_mask=attention_mask, bidirectional_mask=bidirectional_mask, head_mask=head_mask, inputs_embeds=inputs_embeds, use_cache=use_cache, output_attentions=output_attentions, output_hidden_states=output_hidden_states, return_dict=return_dict)\n        hidden_states = transformer_outputs[0]\n        lm_logits = self.lm_head(hidden_states)\n        loss = None\n        if labels is not None:\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            (batch_size, seq_length, vocab_size) = shift_logits.shape\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(shift_logits.view(batch_size * seq_length, vocab_size), shift_labels.view(batch_size * seq_length))\n        if not return_dict:\n            output = (lm_logits,) + transformer_outputs[1:]\n            return (loss,) + output if loss is not None else output\n        return CausalLMOutputWithCrossAttentions(loss=loss, logits=lm_logits, past_key_values=transformer_outputs.past_key_values, hidden_states=transformer_outputs.hidden_states, attentions=transformer_outputs.attentions)\n\n    def prepare_inputs_for_generation(self: BloomForCausalLM, input_ids: torch.LongTensor, past: Optional[torch.Tensor]=None, attention_mask: Optional[torch.Tensor]=None, **kwargs) -> dict:\n        if past:\n            input_ids = input_ids[:, -1].unsqueeze(-1)\n            bidirectional_mask = None\n            if past[0][0].shape[0] == input_ids.shape[0]:\n                past = self._convert_to_bloom_cache(past)\n        else:\n            bidirectional_mask = torch.ones_like(input_ids)\n        return {'input_ids': input_ids, 'past_key_values': past, 'use_cache': True, 'attention_mask': attention_mask, 'bidirectional_mask': bidirectional_mask}\n    setattr(model, 'forward', MethodType(forward, model))\n    setattr(model, 'prepare_inputs_for_generation', MethodType(prepare_inputs_for_generation, model))\n    setattr(model, '_prefix_lm_converted', True)\n    return model\n\ndef _convert_opt_causal_lm_to_prefix_lm(model: OPTForCausalLM) -> OPTForCausalLM:\n    \"\"\"Converts an OPT Causal LM to a Prefix LM.\n\n    Supported HuggingFace model classes:\n        - `OPTForCausalLM`\n\n    See `convert_hf_causal_lm_to_prefix_lm` for more details.\n    \"\"\"\n    if hasattr(model, '_prefix_lm_converted'):\n        return model\n    assert isinstance(model, OPTForCausalLM)\n    assert model.config.add_cross_attention == False, 'Only supports OPT decoder-only models'\n    setattr(model, '_original_forward', getattr(model, 'forward'))\n    setattr(model, '_original_generate', getattr(model, 'generate'))\n    model.model.decoder.bidirectional_mask = None\n\n    def _prepare_decoder_attention_mask(self, attention_mask, input_shape, inputs_embeds, past_key_values_length):\n        combined_attention_mask = None\n        if input_shape[-1] > 1:\n            if self.bidirectional_mask == 'g':\n                (bsz, src_length) = input_shape\n                combined_attention_mask = torch.zeros((bsz, 1, src_length, src_length + past_key_values_length), dtype=inputs_embeds.dtype, device=inputs_embeds.device)\n            else:\n                combined_attention_mask = _make_causal_mask_opt(input_shape, inputs_embeds.dtype, past_key_values_length=past_key_values_length).to(inputs_embeds.device)\n                if self.bidirectional_mask is not None:\n                    assert attention_mask.shape == self.bidirectional_mask.shape\n                    expanded_bidirectional_mask = _expand_mask_opt(self.bidirectional_mask, inputs_embeds.dtype, tgt_len=input_shape[-1]).to(inputs_embeds.device)\n                    combined_attention_mask = torch.maximum(expanded_bidirectional_mask, combined_attention_mask)\n        if attention_mask is not None:\n            expanded_attn_mask = _expand_mask_opt(attention_mask, inputs_embeds.dtype, tgt_len=input_shape[-1]).to(inputs_embeds.device)\n            combined_attention_mask = expanded_attn_mask if combined_attention_mask is None else expanded_attn_mask + combined_attention_mask\n        return combined_attention_mask\n    setattr(model.model.decoder, '_prepare_decoder_attention_mask', MethodType(_prepare_decoder_attention_mask, model.model.decoder))\n\n    def forward(self: OPTForCausalLM, input_ids: Optional[torch.LongTensor]=None, attention_mask: Optional[torch.Tensor]=None, bidirectional_mask: Optional[torch.ByteTensor]=None, head_mask: Optional[torch.Tensor]=None, past_key_values: Optional[List[torch.FloatTensor]]=None, inputs_embeds: Optional[torch.FloatTensor]=None, labels: Optional[torch.LongTensor]=None, use_cache: Optional[bool]=None, output_attentions: Optional[bool]=None, output_hidden_states: Optional[bool]=None, return_dict: Optional[bool]=None):\n\n        def call_og_forward():\n            return self._original_forward(input_ids=input_ids, attention_mask=attention_mask, head_mask=head_mask, past_key_values=past_key_values, inputs_embeds=inputs_embeds, labels=labels, use_cache=use_cache, output_attentions=output_attentions, output_hidden_states=output_hidden_states, return_dict=return_dict)\n        if bidirectional_mask is None:\n            return call_og_forward()\n        self.model.decoder.bidirectional_mask = bidirectional_mask\n        try:\n            outputs = call_og_forward()\n        except:\n            self.model.decoder.bidirectional_mask = None\n            raise\n        self.model.decoder.bidirectional_mask = None\n        return outputs\n\n    def generate(self: OPTForCausalLM, *args: tuple, **kwargs: Dict[str, Any]):\n        \"\"\"Wraps original generate to enable PrefixLM-style attention.\"\"\"\n        self.model.decoder.bidirectional_mask = 'g'\n        try:\n            output = self._original_generate(*args, **kwargs)\n        except:\n            self.model.decoder.bidirectional_mask = None\n            raise\n        self.model.decoder.bidirectional_mask = None\n        return output\n    setattr(model, 'forward', MethodType(forward, model))\n    setattr(model, 'generate', MethodType(generate, model))\n    setattr(model, '_prefix_lm_converted', True)\n    return model\n_SUPPORTED_HF_MODELS = _SUPPORTED_GPT_MODELS + (BloomForCausalLM, OPTForCausalLM)\nCAUSAL_LM_TYPES = Union[GPT2LMHeadModel, GPTJForCausalLM, GPTNeoForCausalLM, GPTNeoXForCausalLM, BloomForCausalLM, OPTForCausalLM]\n\ndef convert_hf_causal_lm_to_prefix_lm(model: CAUSAL_LM_TYPES) -> CAUSAL_LM_TYPES:\n    \"\"\"Converts a HuggingFace Causal LM to a Prefix LM.\n\n    Supported HuggingFace model classes:\n        - `GPT2LMHeadModel`\n        - `GPTNeoForCausalLM`\n        - `GPTNeoXForCausalLM`\n        - `GPTJForCausalLM`\n        - `BloomForCausalLM`\n        - `OPTForCausalLM`\n\n    Conversion to a Prefix LM is done by modifying the `forward` method, and possibly also the\n    `generate` method and/or select underlying methods depending on the model class.\n\n    These changes preserve the model API, but add a new input to `forward`: \"bidirectional_mask\".\n\n    Notes on training:\n        To actually train the converted model as a Prefix LM, training batches will need to indicate\n        the prefix/target structure by including `bidirectional_mask` as part of the batch inputs.\n\n        **This is not a standard input and requires custom layers either within or after your dataloader.**\n\n        In addition to adding `bidirectional_mask` to the batch, this custom code should modify `labels`\n        such that `batch['labels'][batch['bidirectional_mask'] == 1] == -100`.\n        That is, the prefix portion of the sequence should not generate any loss. Loss should only be\n        generated by the target portion of the sequence.\n\n    Notes on `GPTNeoForCausalLM`:\n        To simplify the implementation, \"global\" and \"local\" attention layers are handled differently.\n        For \"global\" layers, we handle conversion as described above. For \"local\" layers, which use a\n        causal attention mask within a restricted local window, we do not alter the masking.\n\n    Notes on `forward` method conversion:\n        After conversion, the `forward` method will handle a new input, `bidirectional_mask`,\n        which should be a [batch_size, seq_length] byte tensor, where 1 indicates token positions\n        belonging to the prefix (prefix tokens can attend to one another bidirectionally), and\n        0 indicates token positions belonging to the target.\n\n        The new `forward` method will incorporate `bidirectional_mask` (if supplied) into the existing\n        causal mask, call the original `forward` method, and (if the causal mask is a buffer) reset\n        the causal masks before returning the result.\n\n    Notes on `generate` method conversion:\n        After conversion, the `generate` method will have the same signature but will internally\n        convert all causal masks to be purely bidirectional, call the original `generate` method, and\n        (where appropriate) reset the causal masks before returning the result.\n\n        This works thanks to the logic of the HuggingFace `generate` API, which first encodes the token\n        \"prompt\" passed to `generate` (which is treated as the prefix) and then sequentially generates\n        each new token. Encodings are cached as generation happens, so all prefix tokens can attend to one\n        another (as expected in a Prefix LM) and generated tokens can only attend to prefix tokens and\n        previously-generated tokens (also as expected in a Prefix LM).\n\n    To preserve the API, the original methods are renamed to `_original_forward` and\n    `_original_generate`, and replaced with new `forward` and `generate` methods that wrap\n    them, respectively. Although implementation details vary by model class.\n    \"\"\"\n    if isinstance(model, _SUPPORTED_GPT_MODELS):\n        return _convert_gpt_causal_lm_to_prefix_lm(model)\n    elif isinstance(model, BloomForCausalLM):\n        return _convert_bloom_causal_lm_to_prefix_lm(model)\n    elif isinstance(model, OPTForCausalLM):\n        return _convert_opt_causal_lm_to_prefix_lm(model)\n    else:\n        raise TypeError(f'Cannot convert model to Prefix LM. ' + f'Model does not belong to set of supported HF models:' + f'\\n{_SUPPORTED_HF_MODELS}')\n\ndef add_bidirectional_mask_if_missing(batch: Dict[str, Any]):\n    \"\"\"Attempts to add bidirectional_mask to batch if missing.\n\n    Raises:\n        KeyError if bidirectional_mask is missing and can't be inferred\n    \"\"\"\n    if 'bidirectional_mask' not in batch:\n        if batch.get('mode', None) == 'icl_task':\n            batch['bidirectional_mask'] = batch['attention_mask'].clone()\n            for (i, continuation_indices) in enumerate(batch['continuation_indices']):\n                batch['bidirectional_mask'][i, continuation_indices] = 0\n        elif 'labels' in batch and 'attention_mask' in batch:\n            batch['bidirectional_mask'] = torch.logical_and(torch.eq(batch['attention_mask'], 1), torch.eq(batch['labels'], -100)).type_as(batch['attention_mask'])\n        else:\n            raise KeyError('No bidirectional_mask in batch and not sure how to construct one.')"}
{"type": "source_file", "path": "LLaVA/llava/model/builder.py", "content": "#    Copyright 2023 Haotian Liu\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\");\n#    you may not use this file except in compliance with the License.\n#    You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS,\n#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#    See the License for the specific language governing permissions and\n#    limitations under the License.\n\n\nimport os\nimport warnings\nimport shutil\n\nfrom transformers import AutoTokenizer, AutoModelForCausalLM, AutoConfig, BitsAndBytesConfig\nimport torch\nfrom llava.model import *\nfrom llava.constants import DEFAULT_IMAGE_PATCH_TOKEN, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN\n\n\ndef load_pretrained_model(model_path, model_base, model_name, load_8bit=False, load_4bit=False, device_map=\"auto\", device=\"cuda\"):\n    kwargs = {\"device_map\": device_map}\n\n    if load_8bit:\n        kwargs['load_in_8bit'] = True\n    elif load_4bit:\n        kwargs['load_in_4bit'] = True\n        kwargs['quantization_config'] = BitsAndBytesConfig(\n            load_in_4bit=True,\n            bnb_4bit_compute_dtype=torch.float16,\n            bnb_4bit_use_double_quant=True,\n            bnb_4bit_quant_type='nf4'\n        )\n    else:\n        kwargs['torch_dtype'] = torch.float16\n\n    if 'llava' in model_name.lower():\n        # Load LLaVA model\n        if 'lora' in model_name.lower() and model_base is None:\n            warnings.warn('There is `lora` in model name but no `model_base` is provided. If you are loading a LoRA model, please provide the `model_base` argument. Detailed instruction: https://github.com/haotian-liu/LLaVA#launch-a-model-worker-lora-weights-unmerged.')\n        if 'lora' in model_name.lower() and model_base is not None:\n            lora_cfg_pretrained = AutoConfig.from_pretrained(model_path)\n            tokenizer = AutoTokenizer.from_pretrained(model_base, use_fast=False)\n            print('Loading LLaVA from base model...')\n            model = LlavaLlamaForCausalLM.from_pretrained(model_base, low_cpu_mem_usage=True, config=lora_cfg_pretrained, **kwargs)\n            token_num, tokem_dim = model.lm_head.out_features, model.lm_head.in_features\n            if model.lm_head.weight.shape[0] != token_num:\n                model.lm_head.weight = torch.nn.Parameter(torch.empty(token_num, tokem_dim, device=model.device, dtype=model.dtype))\n                model.model.embed_tokens.weight = torch.nn.Parameter(torch.empty(token_num, tokem_dim, device=model.device, dtype=model.dtype))\n\n            print('Loading additional LLaVA weights...')\n            if os.path.exists(os.path.join(model_path, 'non_lora_trainables.bin')):\n                non_lora_trainables = torch.load(os.path.join(model_path, 'non_lora_trainables.bin'), map_location='cpu')\n            else:\n                # this is probably from HF Hub\n                from huggingface_hub import hf_hub_download\n                def load_from_hf(repo_id, filename, subfolder=None):\n                    cache_file = hf_hub_download(\n                        repo_id=repo_id,\n                        filename=filename,\n                        subfolder=subfolder)\n                    return torch.load(cache_file, map_location='cpu')\n                non_lora_trainables = load_from_hf(model_path, 'non_lora_trainables.bin')\n            non_lora_trainables = {(k[11:] if k.startswith('base_model.') else k): v for k, v in non_lora_trainables.items()}\n            if any(k.startswith('model.model.') for k in non_lora_trainables):\n                non_lora_trainables = {(k[6:] if k.startswith('model.') else k): v for k, v in non_lora_trainables.items()}\n            model.load_state_dict(non_lora_trainables, strict=False)\n\n            from peft import PeftModel\n            print('Loading LoRA weights...')\n            model = PeftModel.from_pretrained(model, model_path)\n            print('Merging LoRA weights...')\n            model = model.merge_and_unload()\n            print('Model is loaded...')\n        elif model_base is not None:\n            # this may be mm projector only\n            print('Loading LLaVA from base model...')\n            if 'mpt' in model_name.lower():\n                if not os.path.isfile(os.path.join(model_path, 'configuration_mpt.py')):\n                    shutil.copyfile(os.path.join(model_base, 'configuration_mpt.py'), os.path.join(model_path, 'configuration_mpt.py'))\n                tokenizer = AutoTokenizer.from_pretrained(model_base, use_fast=True)\n                cfg_pretrained = AutoConfig.from_pretrained(model_path, trust_remote_code=True)\n                model = LlavaMPTForCausalLM.from_pretrained(model_base, low_cpu_mem_usage=True, config=cfg_pretrained, **kwargs)\n            else:\n                tokenizer = AutoTokenizer.from_pretrained(model_base, use_fast=False)\n                cfg_pretrained = AutoConfig.from_pretrained(model_path)\n                model = LlavaLlamaForCausalLM.from_pretrained(model_base, low_cpu_mem_usage=True, config=cfg_pretrained, **kwargs)\n\n            mm_projector_weights = torch.load(os.path.join(model_path, 'mm_projector.bin'), map_location='cpu')\n            mm_projector_weights = {k: v.to(torch.float16) for k, v in mm_projector_weights.items()}\n            model.load_state_dict(mm_projector_weights, strict=False)\n        else:\n            if 'mpt' in model_name.lower():\n                tokenizer = AutoTokenizer.from_pretrained(model_path, use_fast=True)\n                model = LlavaMPTForCausalLM.from_pretrained(model_path, low_cpu_mem_usage=True, **kwargs)\n            else:\n                tokenizer = AutoTokenizer.from_pretrained(model_path, use_fast=False)\n                model = LlavaLlamaForCausalLM.from_pretrained(model_path, low_cpu_mem_usage=True, **kwargs)\n    else:\n        # Load language model\n        if model_base is not None:\n            # PEFT model\n            from peft import PeftModel\n            tokenizer = AutoTokenizer.from_pretrained(model_base, use_fast=False)\n            model = AutoModelForCausalLM.from_pretrained(model_base, torch_dtype=torch.float16, low_cpu_mem_usage=True, device_map=\"auto\")\n            print(f\"Loading LoRA weights from {model_path}\")\n            model = PeftModel.from_pretrained(model, model_path)\n            print(f\"Merging weights\")\n            model = model.merge_and_unload()\n            print('Convert to FP16...')\n            model.to(torch.float16)\n        else:\n            use_fast = False\n            if 'mpt' in model_name.lower():\n                tokenizer = AutoTokenizer.from_pretrained(model_path, use_fast=True)\n                model = AutoModelForCausalLM.from_pretrained(model_path, low_cpu_mem_usage=True, trust_remote_code=True, **kwargs)\n            else:\n                tokenizer = AutoTokenizer.from_pretrained(model_path, use_fast=False)\n                model = AutoModelForCausalLM.from_pretrained(model_path, low_cpu_mem_usage=True, **kwargs)\n\n    image_processor = None\n\n    if 'llava' in model_name.lower():\n        mm_use_im_start_end = getattr(model.config, \"mm_use_im_start_end\", False)\n        mm_use_im_patch_token = getattr(model.config, \"mm_use_im_patch_token\", True)\n        if mm_use_im_patch_token:\n            tokenizer.add_tokens([DEFAULT_IMAGE_PATCH_TOKEN], special_tokens=True)\n        if mm_use_im_start_end:\n            tokenizer.add_tokens([DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN], special_tokens=True)\n        model.resize_token_embeddings(len(tokenizer))\n\n        vision_tower = model.get_vision_tower()\n\n        if not vision_tower.is_loaded:\n            vision_tower.load_model()\n\n        vision_tower.to(device=device, dtype=torch.float16)\n\n\n        dino_vision_tower = model.get_dino_vision_tower()\n        if not dino_vision_tower.is_loaded:\n            dino_vision_tower.load_model()\n        dino_vision_tower.to(device='cuda', dtype=torch.float16)\n\n\n        image_processor = vision_tower.image_processor\n\n    if hasattr(model.config, \"max_sequence_length\"):\n        context_len = model.config.max_sequence_length\n    else:\n        context_len = 2048\n\n    return tokenizer, model, image_processor, context_len\n"}
{"type": "source_file", "path": "LLaVA/llava/model/multimodal_encoder/dino_encoder.py", "content": "import torch\nimport torch.nn as nn\n\nfrom transformers import CLIPVisionModel, CLIPImageProcessor, CLIPVisionConfig\nfrom transformers import AutoImageProcessor, AutoModel, AutoConfig\n\nclass DINOVisionTower(nn.Module):\n    def __init__(self, vision_tower, args, delay_load=False):\n        super().__init__()\n\n\n        self.is_loaded = False\n\n        self.vision_tower_name = vision_tower\n        self.select_layer = args.mm_vision_select_layer\n        self.select_feature = getattr(args, 'mm_vision_select_feature', 'patch')\n\n        #self.load_model()\n\n        if not delay_load:\n            self.load_model()\n        else:\n            self.cfg_only = CLIPVisionConfig.from_pretrained(self.vision_tower_name)\n\n    def load_model(self):\n        self.image_processor = CLIPImageProcessor.from_pretrained(self.vision_tower_name)\n\n        self.clip_vision_tower = CLIPVisionModel.from_pretrained(self.vision_tower_name)\n\n        self.vision_tower = torch.hub.load('facebookresearch/dinov2', 'dinov2_vitl14')\n\n        self.vision_tower.requires_grad_(False)\n\n        self.is_loaded = True\n\n    def feature_select(self, image_forward_outs):\n        image_features = image_forward_outs[\"x_prenorm\"]\n        if self.select_feature == 'patch':\n            image_features = image_features[:, 1:]\n        elif self.select_feature == 'cls_patch':\n            image_features = image_features\n        else:\n            raise ValueError(f'Unexpected select feature: {self.select_feature}')\n        return image_features\n\n    @torch.no_grad()\n    def forward(self, images):\n        if type(images) is list:\n            image_features = []\n            for image in images:\n                image_forward_out = self.vision_tower.forward_features(image.to(device=self.device, dtype=self.dtype).unsqueeze(0))\n                image_feature = self.feature_select(image_forward_out).to(image.dtype)\n                image_features.append(image_feature)\n        else:\n            image_forward_outs = self.vision_tower.forward_features(images.to(device=self.device, dtype=self.dtype))\n            image_features = self.feature_select(image_forward_outs).to(images.dtype)\n\n        return image_features\n\n    @property\n    def dummy_feature(self):\n        return torch.zeros(1, self.hidden_size, device=self.device, dtype=self.dtype)\n\n    @property\n    def dtype(self):\n        return self.clip_vision_tower.dtype\n\n    @property\n    def device(self):\n        return self.clip_vision_tower.device\n\n    @property\n    def config(self):\n        if self.is_loaded:\n            return self.clip_vision_tower.config\n        else:\n            return self.cfg_only\n\n    @property\n    def hidden_size(self):\n        #return self.config.hidden_size\n        return 1024\n\n    @property\n    def num_patches(self):\n        #return (self.config.image_size // self.config.patch_size) ** 2\n        return 256\n\n"}
{"type": "source_file", "path": "LLaVA/llava/model/utils.py", "content": "from transformers import AutoConfig\n\n\ndef auto_upgrade(config):\n    cfg = AutoConfig.from_pretrained(config)\n    if 'llava' in config and 'llava' not in cfg.model_type:\n        assert cfg.model_type == 'llama'\n        print(\"You are using newer LLaVA code base, while the checkpoint of v0 is from older code base.\")\n        print(\"You must upgrade the checkpoint to the new code base (this can be done automatically).\")\n        confirm = input(\"Please confirm that you want to upgrade the checkpoint. [Y/N]\")\n        if confirm.lower() in [\"y\", \"yes\"]:\n            print(\"Upgrading checkpoint...\")\n            assert len(cfg.architectures) == 1\n            setattr(cfg.__class__, \"model_type\", \"llava\")\n            cfg.architectures[0] = 'LlavaLlamaForCausalLM'\n            cfg.save_pretrained(config)\n            print(\"Checkpoint upgraded.\")\n        else:\n            print(\"Checkpoint upgrade aborted.\")\n            exit(1)\n"}
{"type": "source_file", "path": "LLaVA/llava/model/multimodal_encoder/builder.py", "content": "import os\nfrom .clip_encoder import CLIPVisionTower\nfrom .dino_encoder import DINOVisionTower\n\n\ndef build_vision_tower(vision_tower_cfg, load_model = \"clip\", **kwargs):\n    vision_tower = getattr(vision_tower_cfg, 'mm_vision_tower', getattr(vision_tower_cfg, 'vision_tower', None))\n\n    if vision_tower.startswith(\"openai\") or vision_tower.startswith(\"laion\"):\n        #return CLIPVisionTower(vision_tower, args=vision_tower_cfg, **kwargs)\n        if load_model == \"clip\":\n            return CLIPVisionTower(vision_tower, args=vision_tower_cfg, **kwargs)        \n        else:\n            return DINOVisionTower(vision_tower, args=vision_tower_cfg, **kwargs)\n\n\n\n    raise ValueError(f'Unknown vision tower: {vision_tower}')\n"}
{"type": "source_file", "path": "LLaVA/llava/model/multimodal_encoder/clip_encoder.py", "content": "import torch\nimport torch.nn as nn\n\nfrom transformers import CLIPVisionModel, CLIPImageProcessor, CLIPVisionConfig\n\n\nclass CLIPVisionTower(nn.Module):\n    def __init__(self, vision_tower, args, delay_load=False):\n        super().__init__()\n\n        self.is_loaded = False\n\n        self.vision_tower_name = vision_tower\n        self.select_layer = args.mm_vision_select_layer\n        self.select_feature = getattr(args, 'mm_vision_select_feature', 'patch')\n\n        if not delay_load:\n            self.load_model()\n        else:\n            self.cfg_only = CLIPVisionConfig.from_pretrained(self.vision_tower_name)\n\n    def load_model(self):\n        self.image_processor = CLIPImageProcessor.from_pretrained(self.vision_tower_name)\n        self.vision_tower = CLIPVisionModel.from_pretrained(self.vision_tower_name)\n        print(self.vision_tower.state_dict())\n        self.vision_tower.requires_grad_(False)\n\n        self.is_loaded = True\n\n    def feature_select(self, image_forward_outs):\n        image_features = image_forward_outs.hidden_states[self.select_layer]\n        if self.select_feature == 'patch':\n            image_features = image_features[:, 1:]\n        elif self.select_feature == 'cls_patch':\n            image_features = image_features\n        else:\n            raise ValueError(f'Unexpected select feature: {self.select_feature}')\n        return image_features\n\n    @torch.no_grad()\n    def forward(self, images):\n        if type(images) is list:\n            image_features = []\n            for image in images:\n                image_forward_out = self.vision_tower(image.to(device=self.device, dtype=self.dtype).unsqueeze(0), output_hidden_states=True)\n                image_feature = self.feature_select(image_forward_out).to(image.dtype)\n                image_features.append(image_feature)\n        else:\n            image_forward_outs = self.vision_tower(images.to(device=self.device, dtype=self.dtype), output_hidden_states=True)\n            image_features = self.feature_select(image_forward_outs).to(images.dtype)\n\n        return image_features\n\n    @property\n    def dummy_feature(self):\n        return torch.zeros(1, self.hidden_size, device=self.device, dtype=self.dtype)\n\n    @property\n    def dtype(self):\n        return self.vision_tower.dtype\n\n    @property\n    def device(self):\n        return self.vision_tower.device\n\n    @property\n    def config(self):\n        if self.is_loaded:\n            return self.vision_tower.config\n        else:\n            return self.cfg_only\n\n    @property\n    def hidden_size(self):\n        return self.config.hidden_size\n\n    @property\n    def num_patches(self):\n        return (self.config.image_size // self.config.patch_size) ** 2\n"}
{"type": "source_file", "path": "LLaVA/llava/model/multimodal_projector/builder.py", "content": "import torch\nimport torch.nn as nn\nimport re\n\n\nclass IdentityMap(nn.Module):\n    def __init__(self):\n        super().__init__()\n\n    def forward(self, x, *args, **kwargs):\n        return x\n\n    @property\n    def config(self):\n        return {\"mm_projector_type\": 'identity'}\n\n\nclass SimpleResBlock(nn.Module):\n    def __init__(self, channels):\n        super().__init__()\n        self.pre_norm = nn.LayerNorm(channels)\n\n        self.proj = nn.Sequential(\n            nn.Linear(channels, channels),\n            nn.GELU(),\n            nn.Linear(channels, channels)\n        )\n    def forward(self, x):\n        x = self.pre_norm(x)\n        return x + self.proj(x)\n\n\ndef build_vision_projector(config, delay_load=False, **kwargs):\n    projector_type = getattr(config, 'mm_projector_type', 'linear')\n\n    if projector_type == 'linear':\n        return nn.Linear(config.mm_hidden_size, config.hidden_size)\n\n    mlp_gelu_match = re.match(r'^mlp(\\d+)x_gelu$', projector_type)\n    if mlp_gelu_match:\n        mlp_depth = int(mlp_gelu_match.group(1))\n        modules = [nn.Linear(config.mm_hidden_size, config.hidden_size)]\n        for _ in range(1, mlp_depth):\n            modules.append(nn.GELU())\n            modules.append(nn.Linear(config.hidden_size, config.hidden_size))\n        return nn.Sequential(*modules)\n\n    if projector_type == 'identity':\n        return IdentityMap()\n\n    raise ValueError(f'Unknown projector type: {projector_type}')\n"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/param_init_fns.py", "content": "import math\nimport warnings\nfrom collections.abc import Sequence\nfrom functools import partial\nfrom typing import Optional, Tuple, Union\nimport torch\nfrom torch import nn\nfrom .norm import NORM_CLASS_REGISTRY\n\ndef torch_default_param_init_fn_(module: nn.Module, verbose: int=0, **kwargs):\n    del kwargs\n    if verbose > 1:\n        warnings.warn(f\"Initializing network using module's reset_parameters attribute\")\n    if hasattr(module, 'reset_parameters'):\n        module.reset_parameters()\n\ndef fused_init_helper_(module: nn.Module, init_fn_):\n    _fused = getattr(module, '_fused', None)\n    if _fused is None:\n        raise RuntimeError(f'Internal logic error')\n    (dim, splits) = _fused\n    splits = (0, *splits, module.weight.size(dim))\n    for (s, e) in zip(splits[:-1], splits[1:]):\n        slice_indices = [slice(None)] * module.weight.ndim\n        slice_indices[dim] = slice(s, e)\n        init_fn_(module.weight[slice_indices])\n\ndef generic_param_init_fn_(module: nn.Module, init_fn_, n_layers: int, d_model: Optional[int]=None, init_div_is_residual: Union[int, float, str, bool]=True, emb_init_std: Optional[float]=None, emb_init_uniform_lim: Optional[Union[Tuple[float, float], float]]=None, verbose: int=0, **kwargs):\n    del kwargs\n    if verbose > 1:\n        warnings.warn(f'If model has bias parameters they are initialized to 0.')\n    init_div_is_residual = init_div_is_residual\n    if init_div_is_residual is False:\n        div_is_residual = 1.0\n    elif init_div_is_residual is True:\n        div_is_residual = math.sqrt(2 * n_layers)\n    elif isinstance(init_div_is_residual, float) or isinstance(init_div_is_residual, int):\n        div_is_residual = init_div_is_residual\n    elif isinstance(init_div_is_residual, str) and init_div_is_residual.isnumeric():\n        div_is_residual = float(init_div_is_residual)\n    else:\n        div_is_residual = 1.0\n        raise ValueError(f'Expected init_div_is_residual to be boolean or numeric, got {init_div_is_residual}')\n    if init_div_is_residual is not False:\n        if verbose > 1:\n            warnings.warn(f'Initializing _is_residual layers then dividing them by {div_is_residual:.3f}. ' + f'Set `init_div_is_residual: false` in init config to disable this.')\n    if isinstance(module, nn.Linear):\n        if hasattr(module, '_fused'):\n            fused_init_helper_(module, init_fn_)\n        else:\n            init_fn_(module.weight)\n        if module.bias is not None:\n            torch.nn.init.zeros_(module.bias)\n        if init_div_is_residual is not False and getattr(module, '_is_residual', False):\n            with torch.no_grad():\n                module.weight.div_(div_is_residual)\n    elif isinstance(module, nn.Embedding):\n        if emb_init_std is not None:\n            std = emb_init_std\n            if std == 0:\n                warnings.warn(f'Embedding layer initialized to 0.')\n            emb_init_fn_ = partial(torch.nn.init.normal_, mean=0.0, std=std)\n            if verbose > 1:\n                warnings.warn(f'Embedding layer initialized using normal distribution with mean=0 and std={std!r}.')\n        elif emb_init_uniform_lim is not None:\n            lim = emb_init_uniform_lim\n            if isinstance(lim, Sequence):\n                if len(lim) > 2:\n                    raise ValueError(f'Uniform init requires a min and a max limit. User input: {lim}.')\n                if lim[0] == lim[1]:\n                    warnings.warn(f'Embedding layer initialized to {lim[0]}.')\n            else:\n                if lim == 0:\n                    warnings.warn(f'Embedding layer initialized to 0.')\n                lim = [-lim, lim]\n            (a, b) = lim\n            emb_init_fn_ = partial(torch.nn.init.uniform_, a=a, b=b)\n            if verbose > 1:\n                warnings.warn(f'Embedding layer initialized using uniform distribution in range {lim}.')\n        else:\n            emb_init_fn_ = init_fn_\n        emb_init_fn_(module.weight)\n    elif isinstance(module, tuple(set(NORM_CLASS_REGISTRY.values()))):\n        if verbose > 1:\n            warnings.warn(f'Norm weights are set to 1. If norm layer has a bias it is initialized to 0.')\n        if hasattr(module, 'weight') and module.weight is not None:\n            torch.nn.init.ones_(module.weight)\n        if hasattr(module, 'bias') and module.bias is not None:\n            torch.nn.init.zeros_(module.bias)\n    elif isinstance(module, nn.MultiheadAttention):\n        if module._qkv_same_embed_dim:\n            assert module.in_proj_weight is not None\n            assert module.q_proj_weight is None and module.k_proj_weight is None and (module.v_proj_weight is None)\n            assert d_model is not None\n            _d = d_model\n            splits = (0, _d, 2 * _d, 3 * _d)\n            for (s, e) in zip(splits[:-1], splits[1:]):\n                init_fn_(module.in_proj_weight[s:e])\n        else:\n            assert module.q_proj_weight is not None and module.k_proj_weight is not None and (module.v_proj_weight is not None)\n            assert module.in_proj_weight is None\n            init_fn_(module.q_proj_weight)\n            init_fn_(module.k_proj_weight)\n            init_fn_(module.v_proj_weight)\n        if module.in_proj_bias is not None:\n            torch.nn.init.zeros_(module.in_proj_bias)\n        if module.bias_k is not None:\n            torch.nn.init.zeros_(module.bias_k)\n        if module.bias_v is not None:\n            torch.nn.init.zeros_(module.bias_v)\n        init_fn_(module.out_proj.weight)\n        if init_div_is_residual is not False and getattr(module.out_proj, '_is_residual', False):\n            with torch.no_grad():\n                module.out_proj.weight.div_(div_is_residual)\n        if module.out_proj.bias is not None:\n            torch.nn.init.zeros_(module.out_proj.bias)\n    else:\n        for _ in module.parameters(recurse=False):\n            raise NotImplementedError(f'{module.__class__.__name__} parameters are not initialized by param_init_fn.')\n\ndef _normal_init_(std, mean=0.0):\n    return partial(torch.nn.init.normal_, mean=mean, std=std)\n\ndef _normal_param_init_fn_(module: nn.Module, std: float, n_layers: int, d_model: Optional[int]=None, init_div_is_residual: Union[int, float, str, bool]=True, emb_init_std: Optional[float]=None, emb_init_uniform_lim: Optional[Union[Tuple[float, float], float]]=None, verbose: int=0, **kwargs):\n    del kwargs\n    init_fn_ = _normal_init_(std=std)\n    if verbose > 1:\n        warnings.warn(f'Using torch.nn.init.normal_ init fn mean=0.0, std={std}')\n    generic_param_init_fn_(module=module, init_fn_=init_fn_, d_model=d_model, n_layers=n_layers, init_div_is_residual=init_div_is_residual, emb_init_std=emb_init_std, emb_init_uniform_lim=emb_init_uniform_lim, verbose=verbose)\n\ndef baseline_param_init_fn_(module: nn.Module, init_std: float, n_layers: int, d_model: Optional[int]=None, init_div_is_residual: Union[int, float, str, bool]=True, emb_init_std: Optional[float]=None, emb_init_uniform_lim: Optional[Union[Tuple[float, float], float]]=None, verbose: int=0, **kwargs):\n    del kwargs\n    if init_std is None:\n        raise ValueError(\"You must set model.init_config['init_std'] to a float value to use the default initialization scheme.\")\n    _normal_param_init_fn_(module=module, std=init_std, d_model=d_model, n_layers=n_layers, init_div_is_residual=init_div_is_residual, emb_init_std=emb_init_std, emb_init_uniform_lim=emb_init_uniform_lim, verbose=verbose)\n\ndef small_param_init_fn_(module: nn.Module, n_layers: int, d_model: int, init_div_is_residual: Union[int, float, str, bool]=True, emb_init_std: Optional[float]=None, emb_init_uniform_lim: Optional[Union[Tuple[float, float], float]]=None, verbose: int=0, **kwargs):\n    del kwargs\n    std = math.sqrt(2 / (5 * d_model))\n    _normal_param_init_fn_(module=module, std=std, d_model=d_model, n_layers=n_layers, init_div_is_residual=init_div_is_residual, emb_init_std=emb_init_std, emb_init_uniform_lim=emb_init_uniform_lim, verbose=verbose)\n\ndef neox_param_init_fn_(module: nn.Module, n_layers: int, d_model: int, emb_init_std: Optional[float]=None, emb_init_uniform_lim: Optional[Union[Tuple[float, float], float]]=None, verbose: int=0, **kwargs):\n    \"\"\"From section 2.3.1 of GPT-NeoX-20B:\n\n    An Open-Source AutoregressiveLanguage Model — Black et. al. (2022)\n    see https://github.com/EleutherAI/gpt-neox/blob/9610391ab319403cef079b438edd016a2443af54/megatron/model/init_functions.py#L151\n    and https://github.com/EleutherAI/gpt-neox/blob/main/megatron/model/transformer.py\n    \"\"\"\n    del kwargs\n    residual_div = n_layers / math.sqrt(10)\n    if verbose > 1:\n        warnings.warn(f'setting init_div_is_residual to {residual_div}')\n    small_param_init_fn_(module=module, d_model=d_model, n_layers=n_layers, init_div_is_residual=residual_div, emb_init_std=emb_init_std, emb_init_uniform_lim=emb_init_uniform_lim, verbose=verbose)\n\ndef kaiming_uniform_param_init_fn_(module: nn.Module, n_layers: int, d_model: Optional[int]=None, init_div_is_residual: Union[int, float, str, bool]=True, emb_init_std: Optional[float]=None, emb_init_uniform_lim: Optional[Union[Tuple[float, float], float]]=None, init_gain: float=0, fan_mode: str='fan_in', init_nonlinearity: str='leaky_relu', verbose: int=0, **kwargs):\n    del kwargs\n    if verbose > 1:\n        warnings.warn(f'Using nn.init.kaiming_uniform_ init fn with parameters: ' + f'a={init_gain}, mode={fan_mode}, nonlinearity={init_nonlinearity}')\n    kaiming_uniform_ = partial(nn.init.kaiming_uniform_, a=init_gain, mode=fan_mode, nonlinearity=init_nonlinearity)\n    generic_param_init_fn_(module=module, init_fn_=kaiming_uniform_, d_model=d_model, n_layers=n_layers, init_div_is_residual=init_div_is_residual, emb_init_std=emb_init_std, emb_init_uniform_lim=emb_init_uniform_lim, verbose=verbose)\n\ndef kaiming_normal_param_init_fn_(module: nn.Module, n_layers: int, d_model: Optional[int]=None, init_div_is_residual: Union[int, float, str, bool]=True, emb_init_std: Optional[float]=None, emb_init_uniform_lim: Optional[Union[Tuple[float, float], float]]=None, init_gain: float=0, fan_mode: str='fan_in', init_nonlinearity: str='leaky_relu', verbose: int=0, **kwargs):\n    del kwargs\n    if verbose > 1:\n        warnings.warn(f'Using nn.init.kaiming_normal_ init fn with parameters: ' + f'a={init_gain}, mode={fan_mode}, nonlinearity={init_nonlinearity}')\n    kaiming_normal_ = partial(torch.nn.init.kaiming_normal_, a=init_gain, mode=fan_mode, nonlinearity=init_nonlinearity)\n    generic_param_init_fn_(module=module, init_fn_=kaiming_normal_, d_model=d_model, n_layers=n_layers, init_div_is_residual=init_div_is_residual, emb_init_std=emb_init_std, emb_init_uniform_lim=emb_init_uniform_lim, verbose=verbose)\n\ndef xavier_uniform_param_init_fn_(module: nn.Module, n_layers: int, d_model: Optional[int]=None, init_div_is_residual: Union[int, float, str, bool]=True, emb_init_std: Optional[float]=None, emb_init_uniform_lim: Optional[Union[Tuple[float, float], float]]=None, init_gain: float=0, verbose: int=0, **kwargs):\n    del kwargs\n    xavier_uniform_ = partial(torch.nn.init.xavier_uniform_, gain=init_gain)\n    if verbose > 1:\n        warnings.warn(f'Using torch.nn.init.xavier_uniform_ init fn with parameters: ' + f'gain={init_gain}')\n    generic_param_init_fn_(module=module, init_fn_=xavier_uniform_, d_model=d_model, n_layers=n_layers, init_div_is_residual=init_div_is_residual, emb_init_std=emb_init_std, emb_init_uniform_lim=emb_init_uniform_lim, verbose=verbose)\n\ndef xavier_normal_param_init_fn_(module: nn.Module, n_layers: int, d_model: Optional[int]=None, init_div_is_residual: Union[int, float, str, bool]=True, emb_init_std: Optional[float]=None, emb_init_uniform_lim: Optional[Union[Tuple[float, float], float]]=None, init_gain: float=0, verbose: int=0, **kwargs):\n    xavier_normal_ = partial(torch.nn.init.xavier_normal_, gain=init_gain)\n    if verbose > 1:\n        warnings.warn(f'Using torch.nn.init.xavier_normal_ init fn with parameters: ' + f'gain={init_gain}')\n    generic_param_init_fn_(module=module, init_fn_=xavier_normal_, d_model=d_model, n_layers=n_layers, init_div_is_residual=init_div_is_residual, emb_init_std=emb_init_std, emb_init_uniform_lim=emb_init_uniform_lim, verbose=verbose)\nMODEL_INIT_REGISTRY = {'default_': torch_default_param_init_fn_, 'baseline_': baseline_param_init_fn_, 'kaiming_uniform_': kaiming_uniform_param_init_fn_, 'kaiming_normal_': kaiming_normal_param_init_fn_, 'neox_init_': neox_param_init_fn_, 'small_init_': small_param_init_fn_, 'xavier_uniform_': xavier_uniform_param_init_fn_, 'xavier_normal_': xavier_normal_param_init_fn_}"}
{"type": "source_file", "path": "LLaVA/llava/model/make_delta.py", "content": "\"\"\"\nUsage:\npython3 -m llava.model.make_delta --base ~/model_weights/llama-7b --target ~/model_weights/llava-7b --delta ~/model_weights/llava-7b-delta --hub-repo-id liuhaotian/llava-7b-delta\n\"\"\"\nimport argparse\n\nimport torch\nfrom tqdm import tqdm\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\nfrom llava.model.utils import auto_upgrade\n\n\ndef make_delta(base_model_path, target_model_path, delta_path, hub_repo_id):\n    print(\"Loading base model\")\n    base = AutoModelForCausalLM.from_pretrained(\n        base_model_path, torch_dtype=torch.float16, low_cpu_mem_usage=True)\n\n    print(\"Loading target model\")\n    auto_upgrade(target_model_path)\n    target = AutoModelForCausalLM.from_pretrained(target_model_path, torch_dtype=torch.float16, low_cpu_mem_usage=True)\n\n    print(\"Calculating delta\")\n    for name, param in tqdm(target.state_dict().items(), desc=\"Calculating delta\"):\n        if name not in base.state_dict():\n            assert name in ['model.mm_projector.weight', 'model.mm_projector.bias'], f'{name} not in base model'\n            continue\n        if param.data.shape == base.state_dict()[name].shape:\n            param.data -= base.state_dict()[name]\n        else:\n            assert name in ['model.embed_tokens.weight', 'lm_head.weight'], f'{name} dimension mismatch: {param.data.shape} vs {base.state_dict()[name].shape}'\n            bparam = base.state_dict()[name]\n            param.data[:bparam.shape[0], :bparam.shape[1]] -= bparam\n\n    print(\"Saving delta\")\n    if hub_repo_id:\n        kwargs = {\"push_to_hub\": True, \"repo_id\": hub_repo_id}\n    else:\n        kwargs = {}\n    target.save_pretrained(delta_path, **kwargs)\n    target_tokenizer = AutoTokenizer.from_pretrained(target_model_path)\n    target_tokenizer.save_pretrained(delta_path, **kwargs)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--base-model-path\", type=str, required=True)\n    parser.add_argument(\"--target-model-path\", type=str, required=True)\n    parser.add_argument(\"--delta-path\", type=str, required=True)\n    parser.add_argument(\"--hub-repo-id\", type=str, default=None)\n    args = parser.parse_args()\n\n    make_delta(args.base_model_path, args.target_model_path, args.delta_path, args.hub_repo_id)\n"}
{"type": "source_file", "path": "LLaVA/llava/serve/controller.py", "content": "\"\"\"\nA controller manages distributed workers.\nIt sends worker addresses to clients.\n\"\"\"\nimport argparse\nimport asyncio\nimport dataclasses\nfrom enum import Enum, auto\nimport json\nimport logging\nimport time\nfrom typing import List, Union\nimport threading\n\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import StreamingResponse\nimport numpy as np\nimport requests\nimport uvicorn\n\nfrom llava.constants import CONTROLLER_HEART_BEAT_EXPIRATION\nfrom llava.utils import build_logger, server_error_msg\n\n\nlogger = build_logger(\"controller\", \"controller.log\")\n\n\nclass DispatchMethod(Enum):\n    LOTTERY = auto()\n    SHORTEST_QUEUE = auto()\n\n    @classmethod\n    def from_str(cls, name):\n        if name == \"lottery\":\n            return cls.LOTTERY\n        elif name == \"shortest_queue\":\n            return cls.SHORTEST_QUEUE\n        else:\n            raise ValueError(f\"Invalid dispatch method\")\n\n\n@dataclasses.dataclass\nclass WorkerInfo:\n    model_names: List[str]\n    speed: int\n    queue_length: int\n    check_heart_beat: bool\n    last_heart_beat: str\n\n\ndef heart_beat_controller(controller):\n    while True:\n        time.sleep(CONTROLLER_HEART_BEAT_EXPIRATION)\n        controller.remove_stable_workers_by_expiration()\n\n\nclass Controller:\n    def __init__(self, dispatch_method: str):\n        # Dict[str -> WorkerInfo]\n        self.worker_info = {}\n        self.dispatch_method = DispatchMethod.from_str(dispatch_method)\n\n        self.heart_beat_thread = threading.Thread(\n            target=heart_beat_controller, args=(self,))\n        self.heart_beat_thread.start()\n\n        logger.info(\"Init controller\")\n\n    def register_worker(self, worker_name: str, check_heart_beat: bool,\n                        worker_status: dict):\n        if worker_name not in self.worker_info:\n            logger.info(f\"Register a new worker: {worker_name}\")\n        else:\n            logger.info(f\"Register an existing worker: {worker_name}\")\n\n        if not worker_status:\n            worker_status = self.get_worker_status(worker_name)\n        if not worker_status:\n            return False\n\n        self.worker_info[worker_name] = WorkerInfo(\n            worker_status[\"model_names\"], worker_status[\"speed\"], worker_status[\"queue_length\"],\n            check_heart_beat, time.time())\n\n        logger.info(f\"Register done: {worker_name}, {worker_status}\")\n        return True\n\n    def get_worker_status(self, worker_name: str):\n        try:\n            r = requests.post(worker_name + \"/worker_get_status\", timeout=5)\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Get status fails: {worker_name}, {e}\")\n            return None\n\n        if r.status_code != 200:\n            logger.error(f\"Get status fails: {worker_name}, {r}\")\n            return None\n\n        return r.json()\n\n    def remove_worker(self, worker_name: str):\n        del self.worker_info[worker_name]\n\n    def refresh_all_workers(self):\n        old_info = dict(self.worker_info)\n        self.worker_info = {}\n\n        for w_name, w_info in old_info.items():\n            if not self.register_worker(w_name, w_info.check_heart_beat, None):\n                logger.info(f\"Remove stale worker: {w_name}\")\n\n    def list_models(self):\n        model_names = set()\n\n        for w_name, w_info in self.worker_info.items():\n            model_names.update(w_info.model_names)\n\n        return list(model_names)\n\n    def get_worker_address(self, model_name: str):\n        if self.dispatch_method == DispatchMethod.LOTTERY:\n            worker_names = []\n            worker_speeds = []\n            for w_name, w_info in self.worker_info.items():\n                if model_name in w_info.model_names:\n                    worker_names.append(w_name)\n                    worker_speeds.append(w_info.speed)\n            worker_speeds = np.array(worker_speeds, dtype=np.float32)\n            norm = np.sum(worker_speeds)\n            if norm < 1e-4:\n                return \"\"\n            worker_speeds = worker_speeds / norm\n            if True:  # Directly return address\n                pt = np.random.choice(np.arange(len(worker_names)),\n                    p=worker_speeds)\n                worker_name = worker_names[pt]\n                return worker_name\n\n            # Check status before returning\n            while True:\n                pt = np.random.choice(np.arange(len(worker_names)),\n                    p=worker_speeds)\n                worker_name = worker_names[pt]\n\n                if self.get_worker_status(worker_name):\n                    break\n                else:\n                    self.remove_worker(worker_name)\n                    worker_speeds[pt] = 0\n                    norm = np.sum(worker_speeds)\n                    if norm < 1e-4:\n                        return \"\"\n                    worker_speeds = worker_speeds / norm\n                    continue\n            return worker_name\n        elif self.dispatch_method == DispatchMethod.SHORTEST_QUEUE:\n            worker_names = []\n            worker_qlen = []\n            for w_name, w_info in self.worker_info.items():\n                if model_name in w_info.model_names:\n                    worker_names.append(w_name)\n                    worker_qlen.append(w_info.queue_length / w_info.speed)\n            if len(worker_names) == 0:\n                return \"\"\n            min_index = np.argmin(worker_qlen)\n            w_name = worker_names[min_index]\n            self.worker_info[w_name].queue_length += 1\n            logger.info(f\"names: {worker_names}, queue_lens: {worker_qlen}, ret: {w_name}\")\n            return w_name\n        else:\n            raise ValueError(f\"Invalid dispatch method: {self.dispatch_method}\")\n\n    def receive_heart_beat(self, worker_name: str, queue_length: int):\n        if worker_name not in self.worker_info:\n            logger.info(f\"Receive unknown heart beat. {worker_name}\")\n            return False\n\n        self.worker_info[worker_name].queue_length = queue_length\n        self.worker_info[worker_name].last_heart_beat = time.time()\n        logger.info(f\"Receive heart beat. {worker_name}\")\n        return True\n\n    def remove_stable_workers_by_expiration(self):\n        expire = time.time() - CONTROLLER_HEART_BEAT_EXPIRATION\n        to_delete = []\n        for worker_name, w_info in self.worker_info.items():\n            if w_info.check_heart_beat and w_info.last_heart_beat < expire:\n                to_delete.append(worker_name)\n\n        for worker_name in to_delete:\n            self.remove_worker(worker_name)\n\n    def worker_api_generate_stream(self, params):\n        worker_addr = self.get_worker_address(params[\"model\"])\n        if not worker_addr:\n            logger.info(f\"no worker: {params['model']}\")\n            ret = {\n                \"text\": server_error_msg,\n                \"error_code\": 2,\n            }\n            yield json.dumps(ret).encode() + b\"\\0\"\n\n        try:\n            response = requests.post(worker_addr + \"/worker_generate_stream\",\n                json=params, stream=True, timeout=5)\n            for chunk in response.iter_lines(decode_unicode=False, delimiter=b\"\\0\"):\n                if chunk:\n                    yield chunk + b\"\\0\"\n        except requests.exceptions.RequestException as e:\n            logger.info(f\"worker timeout: {worker_addr}\")\n            ret = {\n                \"text\": server_error_msg,\n                \"error_code\": 3,\n            }\n            yield json.dumps(ret).encode() + b\"\\0\"\n\n\n    # Let the controller act as a worker to achieve hierarchical\n    # management. This can be used to connect isolated sub networks.\n    def worker_api_get_status(self):\n        model_names = set()\n        speed = 0\n        queue_length = 0\n\n        for w_name in self.worker_info:\n            worker_status = self.get_worker_status(w_name)\n            if worker_status is not None:\n                model_names.update(worker_status[\"model_names\"])\n                speed += worker_status[\"speed\"]\n                queue_length += worker_status[\"queue_length\"]\n\n        return {\n            \"model_names\": list(model_names),\n            \"speed\": speed,\n            \"queue_length\": queue_length,\n        }\n\n\napp = FastAPI()\n\n\n@app.post(\"/register_worker\")\nasync def register_worker(request: Request):\n    data = await request.json()\n    controller.register_worker(\n        data[\"worker_name\"], data[\"check_heart_beat\"],\n        data.get(\"worker_status\", None))\n\n\n@app.post(\"/refresh_all_workers\")\nasync def refresh_all_workers():\n    models = controller.refresh_all_workers()\n\n\n@app.post(\"/list_models\")\nasync def list_models():\n    models = controller.list_models()\n    return {\"models\": models}\n\n\n@app.post(\"/get_worker_address\")\nasync def get_worker_address(request: Request):\n    data = await request.json()\n    addr = controller.get_worker_address(data[\"model\"])\n    return {\"address\": addr}\n\n\n@app.post(\"/receive_heart_beat\")\nasync def receive_heart_beat(request: Request):\n    data = await request.json()\n    exist = controller.receive_heart_beat(\n        data[\"worker_name\"], data[\"queue_length\"])\n    return {\"exist\": exist}\n\n\n@app.post(\"/worker_generate_stream\")\nasync def worker_api_generate_stream(request: Request):\n    params = await request.json()\n    generator = controller.worker_api_generate_stream(params)\n    return StreamingResponse(generator)\n\n\n@app.post(\"/worker_get_status\")\nasync def worker_api_get_status(request: Request):\n    return controller.worker_api_get_status()\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--host\", type=str, default=\"localhost\")\n    parser.add_argument(\"--port\", type=int, default=21001)\n    parser.add_argument(\"--dispatch-method\", type=str, choices=[\n        \"lottery\", \"shortest_queue\"], default=\"shortest_queue\")\n    args = parser.parse_args()\n    logger.info(f\"args: {args}\")\n\n    controller = Controller(args.dispatch_method)\n    uvicorn.run(app, host=args.host, port=args.port, log_level=\"info\")\n"}
{"type": "source_file", "path": "LLaVA/llava/model/llava_arch.py", "content": "#    Copyright 2023 Haotian Liu\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\");\n#    you may not use this file except in compliance with the License.\n#    You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS,\n#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#    See the License for the specific language governing permissions and\n#    limitations under the License.\n\n\nfrom abc import ABC, abstractmethod\n\nimport torch\nimport torch.nn as nn\n\nfrom .multimodal_encoder.builder import build_vision_tower\nfrom .multimodal_projector.builder import build_vision_projector\n\nfrom llava.constants import IGNORE_INDEX, IMAGE_TOKEN_INDEX, DEFAULT_IMAGE_PATCH_TOKEN, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN\n\n\nclass LlavaMetaModel:\n\n    def __init__(self, config):\n        super(LlavaMetaModel, self).__init__(config)\n\n        if hasattr(config, \"mm_vision_tower\"):\n            self.vision_tower = build_vision_tower(config, load_model = \"clip\", delay_load=True)\n            self.dino_tower = build_vision_tower(config, load_model = \"dino\", delay_load=True)\n\n            self.mm_projector = build_vision_projector(config)\n            self.dino_mm_projector = build_vision_projector(config)\n\n\n\n    def get_vision_tower(self, load_model = \"clip\"):\n        if load_model == \"clip\":\n            vision_tower = getattr(self, 'vision_tower', None)\n            if type(vision_tower) is list:\n                vision_tower = vision_tower[0]\n\n            return vision_tower\n        else:\n            vision_tower = getattr(self, 'dino_tower', None)\n            if type(vision_tower) is list:\n                vision_tower = vision_tower[0]\n\n            return vision_tower\n\n    def initialize_vision_modules(self, model_args, fsdp=None):\n        vision_tower = model_args.vision_tower\n        mm_vision_select_layer = model_args.mm_vision_select_layer\n        mm_vision_select_feature = model_args.mm_vision_select_feature\n        pretrain_mm_mlp_adapter = model_args.pretrain_mm_mlp_adapter\n        pretrain_dino_mm_mlp_adapter = model_args.pretrain_dino_mm_mlp_adapter\n\n\n        self.config.mm_vision_tower = vision_tower\n\n        if self.get_vision_tower() is None:\n            vision_tower = build_vision_tower(model_args)\n\n\n            if fsdp is not None and len(fsdp) > 0:\n                self.vision_tower = [vision_tower]\n            else:\n                self.vision_tower = vision_tower\n        else:\n            if fsdp is not None and len(fsdp) > 0:\n                vision_tower = self.vision_tower[0]\n            else:\n                vision_tower = self.vision_tower\n            vision_tower.load_model()\n\n\n        if self.get_vision_tower(load_model = \"dino\") is None:\n            dino_tower = build_vision_tower(model_args, load_model=\"dino\")\n\n\n            if fsdp is not None and len(fsdp) > 0:\n                self.dino_tower = [dino_tower]\n            else:\n                self.dino_tower = dino_tower\n        else:\n            if fsdp is not None and len(fsdp) > 0:\n                dino_tower = self.dino_tower[0]\n            else:\n                dino_tower = self.dino_tower\n            dino_tower.load_model()\n\n\n        self.config.use_mm_proj = True\n        self.config.mm_projector_type = getattr(model_args, 'mm_projector_type', 'linear')\n        self.config.mm_hidden_size = vision_tower.hidden_size\n        self.config.mm_vision_select_layer = mm_vision_select_layer\n        self.config.mm_vision_select_feature = mm_vision_select_feature\n\n        if getattr(self, 'mm_projector', None) is None:\n            self.mm_projector = build_vision_projector(self.config)\n\n        if getattr(self, 'dino_mm_projector', None) is None:\n            self.dino_mm_projector = build_vision_projector(self.config)\n\n        if pretrain_mm_mlp_adapter is not None:\n            mm_projector_weights = torch.load(pretrain_mm_mlp_adapter, map_location='cpu')\n            def get_w(weights, keyword):\n                return {k.split(keyword + '.')[1]: v for k, v in weights.items() if keyword in k}\n\n            self.mm_projector.load_state_dict(get_w(mm_projector_weights, 'mm_projector'))\n\n        if pretrain_dino_mm_mlp_adapter is not None:\n\n            print(\"Loading pretrained DINO adpater!!!\")\n            dino_mm_projector_weights = torch.load(pretrain_dino_mm_mlp_adapter, map_location='cpu')\n            def get_w(weights, keyword):\n                return {k.split(keyword + '.')[1]: v for k, v in weights.items() if keyword in k}\n\n            self.dino_mm_projector.load_state_dict(get_w(dino_mm_projector_weights, 'dino_mm_projector'))\n\n\nclass LlavaMetaForCausalLM(ABC):\n\n    @abstractmethod\n    def get_model(self):\n        pass\n\n    def get_vision_tower(self):\n        return self.get_model().get_vision_tower()\n\n    def get_dino_vision_tower(self):\n        return self.get_model().get_vision_tower(load_model = \"dino\")\n\n    def encode_images(self, images):\n        image_features = self.get_model().get_vision_tower()(images)\n        image_features = self.get_model().mm_projector(image_features)\n        return image_features\n\n    def encode_images_withclip(self, images):\n        image_features_clip = self.get_model().get_vision_tower(load_model = \"clip\")(images)\n        image_features_clip = self.get_model().mm_projector(image_features_clip)\n        return image_features_clip\n\n\n    def encode_images_withdino(self, images):\n        image_features_dino = self.get_model().get_vision_tower(load_model = \"dino\")(images)\n        image_features_dino = self.get_model().dino_mm_projector(image_features_dino)\n        return image_features_dino\n\n\n    def prepare_inputs_labels_for_multimodal_withdino(\n        self, input_ids, attention_mask, past_key_values, labels, images\n    ):\n\n        vision_tower = self.get_vision_tower()\n\n\n        if vision_tower is None or images is None or input_ids.shape[1] == 1:\n            if past_key_values is not None and vision_tower is not None and images is not None and input_ids.shape[1] == 1:\n                attention_mask = torch.ones((attention_mask.shape[0], past_key_values[-1][-1].shape[-2] + 1), dtype=attention_mask.dtype, device=attention_mask.device)\n            return input_ids, attention_mask, past_key_values, None, labels\n\n\n        if type(images) is list or images.ndim == 5:\n            print(\"I only used multiple images!\")\n            concat_images = torch.cat([image for image in images], dim=0)\n            image_features = self.encode_images(concat_images)\n            split_sizes = [image.shape[0] for image in images]\n            image_features = torch.split(image_features, split_sizes, dim=0)\n            image_features = [x.flatten(0, 1) for x in image_features]\n        else:\n            image_features_clip = self.encode_images_withclip(images)\n            image_features_dino = self.encode_images_withdino(images)\n\n\n        new_input_embeds = []\n        new_labels = [] if labels is not None else None\n        cur_image_idx = 0\n\n\n        for batch_idx, cur_input_ids in enumerate(input_ids):\n\n            if (cur_input_ids == IMAGE_TOKEN_INDEX).sum() == 0:\n\n                half_len = cur_input_ids.shape[0] // 2\n                cur_image_features = (0. * self.get_model().mm_projector(vision_tower.dummy_feature)).sum()\n                cur_input_embeds_1 = self.get_model().embed_tokens(cur_input_ids[:half_len])\n                cur_input_embeds_2 = self.get_model().embed_tokens(cur_input_ids[half_len:])\n                cur_input_embeds = torch.cat([cur_input_embeds_1, cur_image_features[0:0], cur_input_embeds_2], dim=0)\n                new_input_embeds.append(cur_input_embeds)\n                if labels is not None:\n                    new_labels.append(labels[batch_idx])\n                cur_image_idx += 1\n                continue\n\n            image_token_indices = torch.where(cur_input_ids == IMAGE_TOKEN_INDEX)[0]\n\n            cur_new_input_embeds = []\n            if labels is not None:\n                cur_labels = labels[batch_idx]\n                cur_new_labels = []\n                assert cur_labels.shape == cur_input_ids.shape\n\n            while image_token_indices.numel() > 0:\n\n                cur_image_features_clip = image_features_clip[cur_image_idx]\n                cur_image_features_dino = image_features_dino[cur_image_idx]\n\n                image_token_start = image_token_indices[0]\n                if getattr(self.config, 'tune_mm_mlp_adapter', False) and getattr(self.config, 'mm_use_im_start_end', False):\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids[:image_token_start-1]).detach())\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids[image_token_start-1:image_token_start]))\n                    cur_new_input_embeds.append(cur_image_features)\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids[image_token_start+1:image_token_start+2]))\n                    if labels is not None:\n                        cur_new_labels.append(cur_labels[:image_token_start])\n                        cur_new_labels.append(torch.full((cur_image_features.shape[0],), IGNORE_INDEX, device=labels.device, dtype=labels.dtype))\n                        cur_new_labels.append(cur_labels[image_token_start:image_token_start+1])\n                        cur_labels = cur_labels[image_token_start+2:]\n                else:\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids[:image_token_start]))\n\n                    num_patches, clip_dim = cur_image_features_clip.shape\n\n                    clip_dtype = cur_image_features_clip.dtype\n\n\n                    # Interleave features\n                    merged_features = torch.empty(2*num_patches, clip_dim, dtype = clip_dtype)\n                    merged_features[0::2] = cur_image_features_clip\n                    merged_features[1::2] = cur_image_features_dino\n\n                    cur_new_input_embeds.append(merged_features)\n\n                    if labels is not None:\n                        cur_new_labels.append(cur_labels[:image_token_start])\n                        cur_new_labels.append(torch.full((cur_image_features_clip.shape[0],), IGNORE_INDEX, device=labels.device, dtype=labels.dtype))\n                        cur_new_labels.append(torch.full((cur_image_features_dino.shape[0],), IGNORE_INDEX, device=labels.device, dtype=labels.dtype))\n                        cur_labels = cur_labels[image_token_start+1:]\n                cur_image_idx += 1\n                if getattr(self.config, 'tune_mm_mlp_adapter', False) and getattr(self.config, 'mm_use_im_start_end', False):\n                    cur_input_ids = cur_input_ids[image_token_start+2:]\n                else:\n                    cur_input_ids = cur_input_ids[image_token_start+1:]\n\n                image_token_indices = torch.where(cur_input_ids == IMAGE_TOKEN_INDEX)[0]\n\n            if cur_input_ids.numel() > 0:\n                if getattr(self.config, 'tune_mm_mlp_adapter', False) and getattr(self.config, 'mm_use_im_start_end', False):\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids).detach())\n                else:\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids))\n\n                if labels is not None:\n                    cur_new_labels.append(cur_labels)\n\n            cur_new_input_embeds = [x.to(device=self.device) for x in cur_new_input_embeds]\n            cur_new_input_embeds = torch.cat(cur_new_input_embeds, dim=0)\n\n\n            new_input_embeds.append(cur_new_input_embeds)\n            if labels is not None:\n                cur_new_labels = torch.cat(cur_new_labels, dim=0)\n                new_labels.append(cur_new_labels)\n\n        if any(x.shape != new_input_embeds[0].shape for x in new_input_embeds):\n            max_len = max(x.shape[0] for x in new_input_embeds)\n\n            new_input_embeds_align = []\n            for cur_new_embed in new_input_embeds:\n                cur_new_embed = torch.cat((cur_new_embed, torch.zeros((max_len - cur_new_embed.shape[0], cur_new_embed.shape[1]), dtype=cur_new_embed.dtype, device=cur_new_embed.device)), dim=0)\n                new_input_embeds_align.append(cur_new_embed)\n            new_input_embeds = torch.stack(new_input_embeds_align, dim=0)\n\n            if labels is not None:\n                new_labels_align = []\n                _new_labels = new_labels\n                for cur_new_label in new_labels:\n                    cur_new_label = torch.cat((cur_new_label, torch.full((max_len - cur_new_label.shape[0],), IGNORE_INDEX, dtype=cur_new_label.dtype, device=cur_new_label.device)), dim=0)\n                    new_labels_align.append(cur_new_label)\n                new_labels = torch.stack(new_labels_align, dim=0)\n\n            if attention_mask is not None:\n                new_attention_mask = []\n                for cur_attention_mask, cur_new_labels, cur_new_labels_align in zip(attention_mask, _new_labels, new_labels):\n                    new_attn_mask_pad_left = torch.full((cur_new_labels.shape[0] - labels.shape[1],), True, dtype=attention_mask.dtype, device=attention_mask.device)\n                    new_attn_mask_pad_right = torch.full((cur_new_labels_align.shape[0] - cur_new_labels.shape[0],), False, dtype=attention_mask.dtype, device=attention_mask.device)\n                    cur_new_attention_mask = torch.cat((new_attn_mask_pad_left, cur_attention_mask, new_attn_mask_pad_right), dim=0)\n                    new_attention_mask.append(cur_new_attention_mask)\n                attention_mask = torch.stack(new_attention_mask, dim=0)\n                assert attention_mask.shape == new_labels.shape\n        else:\n            new_input_embeds = torch.stack(new_input_embeds, dim=0)\n            if labels is not None:\n                new_labels  = torch.stack(new_labels, dim=0)\n\n            if attention_mask is not None:\n                new_attn_mask_pad_left = torch.full((attention_mask.shape[0], new_input_embeds.shape[1] - input_ids.shape[1]), True, dtype=attention_mask.dtype, device=attention_mask.device)\n                attention_mask = torch.cat((new_attn_mask_pad_left, attention_mask), dim=1)\n                assert attention_mask.shape == new_input_embeds.shape[:2]\n\n        return None, attention_mask, past_key_values, new_input_embeds, new_labels\n\n    def prepare_inputs_labels_for_multimodal(\n        self, input_ids, attention_mask, past_key_values, labels, images\n    ):\n        vision_tower = self.get_vision_tower()\n        if vision_tower is None or images is None or input_ids.shape[1] == 1:\n            if past_key_values is not None and vision_tower is not None and images is not None and input_ids.shape[1] == 1:\n                attention_mask = torch.ones((attention_mask.shape[0], past_key_values[-1][-1].shape[-2] + 1), dtype=attention_mask.dtype, device=attention_mask.device)\n            return input_ids, attention_mask, past_key_values, None, labels\n\n        if type(images) is list or images.ndim == 5:\n            concat_images = torch.cat([image for image in images], dim=0)\n            image_features = self.encode_images(concat_images)\n            split_sizes = [image.shape[0] for image in images]\n            image_features = torch.split(image_features, split_sizes, dim=0)\n            image_features = [x.flatten(0, 1) for x in image_features]\n        else:\n            image_features = self.encode_images(images)\n\n        new_input_embeds = []\n        new_labels = [] if labels is not None else None\n        cur_image_idx = 0\n        for batch_idx, cur_input_ids in enumerate(input_ids):\n            if (cur_input_ids == IMAGE_TOKEN_INDEX).sum() == 0:\n                # multimodal LLM, but the current sample is not multimodal\n                # FIXME: this is a hacky fix, for deepspeed zero3 to work\n                half_len = cur_input_ids.shape[0] // 2\n                cur_image_features = image_features[cur_image_idx]\n                cur_input_embeds_1 = self.get_model().embed_tokens(cur_input_ids[:half_len])\n                cur_input_embeds_2 = self.get_model().embed_tokens(cur_input_ids[half_len:])\n                cur_input_embeds = torch.cat([cur_input_embeds_1, cur_image_features[0:0], cur_input_embeds_2], dim=0)\n                new_input_embeds.append(cur_input_embeds)\n                if labels is not None:\n                    new_labels.append(labels[batch_idx])\n                cur_image_idx += 1\n                continue\n            image_token_indices = torch.where(cur_input_ids == IMAGE_TOKEN_INDEX)[0]\n            cur_new_input_embeds = []\n            if labels is not None:\n                cur_labels = labels[batch_idx]\n                cur_new_labels = []\n                assert cur_labels.shape == cur_input_ids.shape\n            while image_token_indices.numel() > 0:\n                cur_image_features = image_features[cur_image_idx]\n                image_token_start = image_token_indices[0]\n                if getattr(self.config, 'tune_mm_mlp_adapter', False) and getattr(self.config, 'mm_use_im_start_end', False):\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids[:image_token_start-1]).detach())\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids[image_token_start-1:image_token_start]))\n                    cur_new_input_embeds.append(cur_image_features)\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids[image_token_start+1:image_token_start+2]))\n                    if labels is not None:\n                        cur_new_labels.append(cur_labels[:image_token_start])\n                        cur_new_labels.append(torch.full((cur_image_features.shape[0],), IGNORE_INDEX, device=labels.device, dtype=labels.dtype))\n                        cur_new_labels.append(cur_labels[image_token_start:image_token_start+1])\n                        cur_labels = cur_labels[image_token_start+2:]\n                else:\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids[:image_token_start]))\n                    cur_new_input_embeds.append(cur_image_features)\n                    if labels is not None:\n                        cur_new_labels.append(cur_labels[:image_token_start])\n                        cur_new_labels.append(torch.full((cur_image_features.shape[0],), IGNORE_INDEX, device=labels.device, dtype=labels.dtype))\n                        cur_labels = cur_labels[image_token_start+1:]\n                cur_image_idx += 1\n                if getattr(self.config, 'tune_mm_mlp_adapter', False) and getattr(self.config, 'mm_use_im_start_end', False):\n                    cur_input_ids = cur_input_ids[image_token_start+2:]\n                else:\n                    cur_input_ids = cur_input_ids[image_token_start+1:]\n                image_token_indices = torch.where(cur_input_ids == IMAGE_TOKEN_INDEX)[0]\n            if cur_input_ids.numel() > 0:\n                if getattr(self.config, 'tune_mm_mlp_adapter', False) and getattr(self.config, 'mm_use_im_start_end', False):\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids).detach())\n                else:\n                    cur_new_input_embeds.append(self.get_model().embed_tokens(cur_input_ids))\n                if labels is not None:\n                    cur_new_labels.append(cur_labels)\n            cur_new_input_embeds = [x.to(device=self.device) for x in cur_new_input_embeds]\n            cur_new_input_embeds = torch.cat(cur_new_input_embeds, dim=0)\n            new_input_embeds.append(cur_new_input_embeds)\n            if labels is not None:\n                cur_new_labels = torch.cat(cur_new_labels, dim=0)\n                new_labels.append(cur_new_labels)\n\n        if any(x.shape != new_input_embeds[0].shape for x in new_input_embeds):\n            max_len = max(x.shape[0] for x in new_input_embeds)\n\n            new_input_embeds_align = []\n            for cur_new_embed in new_input_embeds:\n                cur_new_embed = torch.cat((cur_new_embed, torch.zeros((max_len - cur_new_embed.shape[0], cur_new_embed.shape[1]), dtype=cur_new_embed.dtype, device=cur_new_embed.device)), dim=0)\n                new_input_embeds_align.append(cur_new_embed)\n            new_input_embeds = torch.stack(new_input_embeds_align, dim=0)\n\n            if labels is not None:\n                new_labels_align = []\n                _new_labels = new_labels\n                for cur_new_label in new_labels:\n                    cur_new_label = torch.cat((cur_new_label, torch.full((max_len - cur_new_label.shape[0],), IGNORE_INDEX, dtype=cur_new_label.dtype, device=cur_new_label.device)), dim=0)\n                    new_labels_align.append(cur_new_label)\n                new_labels = torch.stack(new_labels_align, dim=0)\n\n            if attention_mask is not None:\n                new_attention_mask = []\n                for cur_attention_mask, cur_new_labels, cur_new_labels_align in zip(attention_mask, _new_labels, new_labels):\n                    new_attn_mask_pad_left = torch.full((cur_new_labels.shape[0] - labels.shape[1],), True, dtype=attention_mask.dtype, device=attention_mask.device)\n                    new_attn_mask_pad_right = torch.full((cur_new_labels_align.shape[0] - cur_new_labels.shape[0],), False, dtype=attention_mask.dtype, device=attention_mask.device)\n                    cur_new_attention_mask = torch.cat((new_attn_mask_pad_left, cur_attention_mask, new_attn_mask_pad_right), dim=0)\n                    new_attention_mask.append(cur_new_attention_mask)\n                attention_mask = torch.stack(new_attention_mask, dim=0)\n                assert attention_mask.shape == new_labels.shape\n        else:\n            new_input_embeds = torch.stack(new_input_embeds, dim=0)\n            if labels is not None:\n                new_labels  = torch.stack(new_labels, dim=0)\n\n            if attention_mask is not None:\n                new_attn_mask_pad_left = torch.full((attention_mask.shape[0], new_input_embeds.shape[1] - input_ids.shape[1]), True, dtype=attention_mask.dtype, device=attention_mask.device)\n                attention_mask = torch.cat((new_attn_mask_pad_left, attention_mask), dim=1)\n                assert attention_mask.shape == new_input_embeds.shape[:2]\n\n        return None, attention_mask, past_key_values, new_input_embeds, new_labels\n\n    def initialize_vision_tokenizer(self, model_args, tokenizer):\n        if model_args.mm_use_im_patch_token:\n            tokenizer.add_tokens([DEFAULT_IMAGE_PATCH_TOKEN], special_tokens=True)\n            self.resize_token_embeddings(len(tokenizer))\n\n        if model_args.mm_use_im_start_end:\n            num_new_tokens = tokenizer.add_tokens([DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN], special_tokens=True)\n            self.resize_token_embeddings(len(tokenizer))\n\n            if num_new_tokens > 0:\n                input_embeddings = self.get_input_embeddings().weight.data\n                output_embeddings = self.get_output_embeddings().weight.data\n\n                input_embeddings_avg = input_embeddings[:-num_new_tokens].mean(\n                    dim=0, keepdim=True)\n                output_embeddings_avg = output_embeddings[:-num_new_tokens].mean(\n                    dim=0, keepdim=True)\n\n                input_embeddings[-num_new_tokens:] = input_embeddings_avg\n                output_embeddings[-num_new_tokens:] = output_embeddings_avg\n\n            if model_args.tune_mm_mlp_adapter:\n                for p in self.get_input_embeddings().parameters():\n                    p.requires_grad = True\n                for p in self.get_output_embeddings().parameters():\n                    p.requires_grad = False\n\n            if model_args.pretrain_mm_mlp_adapter:\n                mm_projector_weights = torch.load(model_args.pretrain_mm_mlp_adapter, map_location='cpu')\n                embed_tokens_weight = mm_projector_weights['model.embed_tokens.weight']\n                assert num_new_tokens == 2\n                if input_embeddings.shape == embed_tokens_weight.shape:\n                    input_embeddings[-num_new_tokens:] = embed_tokens_weight[-num_new_tokens:]\n                elif embed_tokens_weight.shape[0] == num_new_tokens:\n                    input_embeddings[-num_new_tokens:] = embed_tokens_weight\n                else:\n                    raise ValueError(f\"Unexpected embed_tokens_weight shape. Pretrained: {embed_tokens_weight.shape}. Current: {input_embeddings.shape}. Numer of new tokens: {num_new_tokens}.\")\n        elif model_args.mm_use_im_patch_token:\n            if model_args.tune_mm_mlp_adapter:\n                for p in self.get_input_embeddings().parameters():\n                    p.requires_grad = False\n                for p in self.get_output_embeddings().parameters():\n                    p.requires_grad = False\n"}
{"type": "source_file", "path": "LLaVA/llava/serve/cli.py", "content": "import argparse\nimport torch\n\nfrom llava.constants import IMAGE_TOKEN_INDEX, DEFAULT_IMAGE_TOKEN, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN\nfrom llava.conversation import conv_templates, SeparatorStyle\nfrom llava.model.builder import load_pretrained_model\nfrom llava.utils import disable_torch_init\nfrom llava.mm_utils import process_images, tokenizer_image_token, get_model_name_from_path, KeywordsStoppingCriteria\n\nfrom PIL import Image\n\nimport requests\nfrom PIL import Image\nfrom io import BytesIO\nfrom transformers import TextStreamer\n\n\ndef load_image(image_file):\n    if image_file.startswith('http://') or image_file.startswith('https://'):\n        response = requests.get(image_file)\n        image = Image.open(BytesIO(response.content)).convert('RGB')\n    else:\n        image = Image.open(image_file).convert('RGB')\n    return image\n\n\ndef main(args):\n    # Model\n    disable_torch_init()\n\n    model_name = get_model_name_from_path(args.model_path)\n    tokenizer, model, image_processor, context_len = load_pretrained_model(args.model_path, args.model_base, model_name, args.load_8bit, args.load_4bit, device=args.device)\n\n    if 'llama-2' in model_name.lower():\n        conv_mode = \"llava_llama_2\"\n    elif \"v1\" in model_name.lower():\n        conv_mode = \"llava_v1\"\n    elif \"mpt\" in model_name.lower():\n        conv_mode = \"mpt\"\n    else:\n        conv_mode = \"llava_v0\"\n\n    if args.conv_mode is not None and conv_mode != args.conv_mode:\n        print('[WARNING] the auto inferred conversation mode is {}, while `--conv-mode` is {}, using {}'.format(conv_mode, args.conv_mode, args.conv_mode))\n    else:\n        args.conv_mode = conv_mode\n\n    conv = conv_templates[args.conv_mode].copy()\n    if \"mpt\" in model_name.lower():\n        roles = ('user', 'assistant')\n    else:\n        roles = conv.roles\n\n    image = load_image(args.image_file)\n    # Similar operation in model_worker.py\n    image_tensor = process_images([image], image_processor, args)\n    if type(image_tensor) is list:\n        image_tensor = [image.to(model.device, dtype=torch.float16) for image in image_tensor]\n    else:\n        image_tensor = image_tensor.to(model.device, dtype=torch.float16)\n\n    while True:\n        try:\n            inp = input(f\"{roles[0]}: \")\n        except EOFError:\n            inp = \"\"\n        if not inp:\n            print(\"exit...\")\n            break\n\n        print(f\"{roles[1]}: \", end=\"\")\n\n        if image is not None:\n            # first message\n            if model.config.mm_use_im_start_end:\n                inp = DEFAULT_IM_START_TOKEN + DEFAULT_IMAGE_TOKEN + DEFAULT_IM_END_TOKEN + '\\n' + inp\n            else:\n                inp = DEFAULT_IMAGE_TOKEN + '\\n' + inp\n            conv.append_message(conv.roles[0], inp)\n            image = None\n        else:\n            # later messages\n            conv.append_message(conv.roles[0], inp)\n        conv.append_message(conv.roles[1], None)\n        prompt = conv.get_prompt()\n\n        input_ids = tokenizer_image_token(prompt, tokenizer, IMAGE_TOKEN_INDEX, return_tensors='pt').unsqueeze(0).cuda()\n        stop_str = conv.sep if conv.sep_style != SeparatorStyle.TWO else conv.sep2\n        keywords = [stop_str]\n        stopping_criteria = KeywordsStoppingCriteria(keywords, tokenizer, input_ids)\n        streamer = TextStreamer(tokenizer, skip_prompt=True, skip_special_tokens=True)\n\n        with torch.inference_mode():\n            output_ids = model.generate(\n                input_ids,\n                images=image_tensor,\n                do_sample=True,\n                temperature=args.temperature,\n                max_new_tokens=args.max_new_tokens,\n                streamer=streamer,\n                use_cache=True,\n                stopping_criteria=[stopping_criteria])\n\n        outputs = tokenizer.decode(output_ids[0, input_ids.shape[1]:]).strip()\n        conv.messages[-1][-1] = outputs\n\n        if args.debug:\n            print(\"\\n\", {\"prompt\": prompt, \"outputs\": outputs}, \"\\n\")\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model-path\", type=str, default=\"facebook/opt-350m\")\n    parser.add_argument(\"--model-base\", type=str, default=None)\n    parser.add_argument(\"--image-file\", type=str, required=True)\n    parser.add_argument(\"--device\", type=str, default=\"cuda\")\n    parser.add_argument(\"--conv-mode\", type=str, default=None)\n    parser.add_argument(\"--temperature\", type=float, default=0.2)\n    parser.add_argument(\"--max-new-tokens\", type=int, default=512)\n    parser.add_argument(\"--load-8bit\", action=\"store_true\")\n    parser.add_argument(\"--load-4bit\", action=\"store_true\")\n    parser.add_argument(\"--debug\", action=\"store_true\")\n    parser.add_argument(\"--image-aspect-ratio\", type=str, default='pad')\n    args = parser.parse_args()\n    main(args)\n"}
{"type": "source_file", "path": "LLaVA/llava/model/__init__.py", "content": "from .language_model.llava_llama import LlavaLlamaForCausalLM, LlavaConfig\nfrom .language_model.llava_mpt import LlavaMPTForCausalLM, LlavaMPTConfig\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/eval_science_qa_gpt4_requery.py", "content": "import argparse\nimport json\nimport os\nimport re\nimport random\nfrom collections import defaultdict\n\n\ndef get_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-dir', type=str)\n    parser.add_argument('--gpt4-result', type=str)\n    parser.add_argument('--requery-result', type=str)\n    parser.add_argument('--our-result', type=str)\n    parser.add_argument('--output-result', type=str)\n    parser.add_argument('--split', type=str, default='test')\n    parser.add_argument('--options', type=list, default=[\"A\", \"B\", \"C\", \"D\", \"E\"])\n    return parser.parse_args()\n\n\ndef convert_caps(results):\n    fakecaps = []\n    for result in results:\n        image_id = result['question_id']\n        caption = result['text']\n        fakecaps.append({\"image_id\": int(image_id), \"caption\": caption})\n    return fakecaps\n\n\ndef get_pred_idx(prediction, choices, options):\n    \"\"\"\n    Get the index (e.g. 2) from the prediction (e.g. 'C')\n    \"\"\"\n    if prediction in options[:len(choices)]:\n        return options.index(prediction)\n    else:\n        return random.choice(range(len(choices)))\n\n\nif __name__ == \"__main__\":\n    args = get_args()\n\n    base_dir = args.base_dir\n    split_indices = json.load(open(os.path.join(base_dir, \"pid_splits.json\")))[args.split]\n    problems = json.load(open(os.path.join(base_dir, \"problems.json\")))\n    our_predictions = [json.loads(line) for line in open(args.our_result)]\n    our_predictions = {pred['question_id']: pred for pred in our_predictions}\n    split_problems = {idx: problems[idx] for idx in split_indices}\n\n    requery_predictions = [json.loads(line) for line in open(args.requery_result)]\n    requery_predictions = {pred['question_id']: pred for pred in requery_predictions}\n\n    gpt4_predictions = json.load(open(args.gpt4_result))['outputs']\n\n    results = defaultdict(lambda: 0)\n\n    sqa_results = {}\n    sqa_results['acc'] = None\n    sqa_results['correct'] = None\n    sqa_results['count'] = None\n    sqa_results['results'] = {}\n    sqa_results['outputs'] = {}\n\n    for prob_id, prob in split_problems.items():\n        if prob_id not in our_predictions:\n            assert False\n        if prob_id not in gpt4_predictions:\n            assert False\n        our_pred = our_predictions[prob_id]['text']\n        gpt4_pred = gpt4_predictions[prob_id]\n        if prob_id not in requery_predictions:\n            results['missing_requery'] += 1\n            requery_pred = \"MISSING\"\n        else:\n            requery_pred = requery_predictions[prob_id]['text']\n\n        pattern = re.compile(r'The answer is ([A-Z]).')\n        our_res = pattern.findall(our_pred)\n        if len(our_res) == 1:\n            our_answer = our_res[0]  # 'A', 'B', ...\n        else:\n            our_answer = \"FAILED\"\n\n        requery_res = pattern.findall(requery_pred)\n        if len(requery_res) == 1:\n            requery_answer = requery_res[0]  # 'A', 'B', ...\n        else:\n            requery_answer = \"FAILED\"\n\n        gpt4_res = pattern.findall(gpt4_pred)\n        if len(gpt4_res) == 1:\n            gpt4_answer = gpt4_res[0]  # 'A', 'B', ...\n        else:\n            gpt4_answer = \"FAILED\"\n\n        our_pred_idx = get_pred_idx(our_answer, prob['choices'], args.options)\n        gpt4_pred_idx = get_pred_idx(gpt4_answer, prob['choices'], args.options)\n        requery_pred_idx = get_pred_idx(requery_answer, prob['choices'], args.options)\n\n        results['total'] += 1\n\n        if gpt4_answer == 'FAILED':\n            results['gpt4_failed'] += 1\n            if gpt4_pred_idx == prob['answer']:\n                results['gpt4_correct'] += 1\n            if our_pred_idx == prob['answer']:\n                results['gpt4_ourvisual_correct'] += 1\n        elif gpt4_pred_idx == prob['answer']:\n            results['gpt4_correct'] += 1\n            results['gpt4_ourvisual_correct'] += 1\n\n        if our_pred_idx == prob['answer']:\n            results['our_correct'] += 1\n\n        if requery_answer == 'FAILED':\n            sqa_results['results'][prob_id] = our_pred_idx\n            if our_pred_idx == prob['answer']:\n                results['requery_correct'] += 1\n        else:\n            sqa_results['results'][prob_id] = requery_pred_idx\n            if requery_pred_idx == prob['answer']:\n                results['requery_correct'] += 1\n            else:\n                print(f\"\"\"\nQuestion ({args.options[prob['answer']]}): {our_predictions[prob_id]['prompt']}\nOur ({our_answer}): {our_pred}\nGPT-4 ({gpt4_answer}): {gpt4_pred}\nRequery ({requery_answer}): {requery_pred}\nprint(\"=====================================\")\n\"\"\")\n\n        if gpt4_pred_idx == prob['answer'] or our_pred_idx == prob['answer']:\n            results['correct_upperbound'] += 1\n\n    total = results['total']\n    print(f'Total: {total}, Our-Correct: {results[\"our_correct\"]}, Accuracy: {results[\"our_correct\"] / total * 100:.2f}%')\n    print(f'Total: {total}, GPT-4-Correct: {results[\"gpt4_correct\"]}, Accuracy: {results[\"gpt4_correct\"] / total * 100:.2f}%')\n    print(f'Total: {total}, GPT-4 NO-ANS (RANDOM): {results[\"gpt4_failed\"]}, Percentage: {results[\"gpt4_failed\"] / total * 100:.2f}%')\n    print(f'Total: {total}, GPT-4-OursVisual-Correct: {results[\"gpt4_ourvisual_correct\"]}, Accuracy: {results[\"gpt4_ourvisual_correct\"] / total * 100:.2f}%')\n    print(f'Total: {total}, Requery-Correct: {results[\"requery_correct\"]}, Accuracy: {results[\"requery_correct\"] / total * 100:.2f}%')\n    print(f'Total: {total}, Correct upper: {results[\"correct_upperbound\"]}, Accuracy: {results[\"correct_upperbound\"] / total * 100:.2f}%')\n\n    sqa_results['acc'] = results[\"requery_correct\"] / total * 100\n    sqa_results['correct'] = results[\"requery_correct\"]\n    sqa_results['count'] = total\n\n    with open(args.output_result, 'w') as f:\n        json.dump(sqa_results, f, indent=2)\n\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/eval_textvqa.py", "content": "import os\nimport argparse\nimport json\nimport re\n\nfrom llava.eval.m4c_evaluator import TextVQAAccuracyEvaluator\n\n\ndef get_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--annotation-file', type=str)\n    parser.add_argument('--result-file', type=str)\n    parser.add_argument('--result-dir', type=str)\n    return parser.parse_args()\n\n\ndef prompt_processor(prompt):\n    if prompt.startswith('OCR tokens: '):\n        pattern = r\"Question: (.*?) Short answer:\"\n        match = re.search(pattern, prompt, re.DOTALL)\n        question = match.group(1)\n    elif 'Reference OCR token: ' in prompt and len(prompt.split('\\n')) == 3:\n        if prompt.startswith('Reference OCR token:'):\n            question = prompt.split('\\n')[1]\n        else:\n            question = prompt.split('\\n')[0]\n    elif len(prompt.split('\\n')) == 2:\n        question = prompt.split('\\n')[0]\n    else:\n        assert False\n\n    return question.lower()\n\n\ndef eval_single(annotation_file, result_file):\n    experiment_name = os.path.splitext(os.path.basename(result_file))[0]\n    print(experiment_name)\n    annotations = json.load(open(annotation_file))['data']\n    annotations = {(annotation['image_id'], annotation['question'].lower()): annotation for annotation in annotations}\n    results = [json.loads(line) for line in open(result_file)]\n\n    pred_list = []\n    for result in results:\n        annotation = annotations[(result['question_id'], prompt_processor(result['prompt']))]\n        pred_list.append({\n            \"pred_answer\": result['text'],\n            \"gt_answers\": annotation['answers'],\n        })\n\n    evaluator = TextVQAAccuracyEvaluator()\n    print('Samples: {}\\nAccuracy: {:.2f}%\\n'.format(len(pred_list), 100. * evaluator.eval_pred_list(pred_list)))\n\n\nif __name__ == \"__main__\":\n    args = get_args()\n\n    if args.result_file is not None:\n        eval_single(args.annotation_file, args.result_file)\n\n    if args.result_dir is not None:\n        for result_file in sorted(os.listdir(args.result_dir)):\n            if not result_file.endswith('.jsonl'):\n                print(f'Skipping {result_file}')\n                continue\n            eval_single(args.annotation_file, os.path.join(args.result_dir, result_file))\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/eval_pope.py", "content": "import os\nimport json\nimport argparse\n\ndef eval_pope(answers, label_file):\n    label_list = [json.loads(q)['label'] for q in open(label_file, 'r')]\n\n    for answer in answers:\n        text = answer['text']\n\n        # Only keep the first sentence\n        if text.find('.') != -1:\n            text = text.split('.')[0]\n\n        text = text.replace(',', '')\n        words = text.split(' ')\n        if 'No' in words or 'not' in words or 'no' in words:\n            answer['text'] = 'no'\n        else:\n            answer['text'] = 'yes'\n\n    for i in range(len(label_list)):\n        if label_list[i] == 'no':\n            label_list[i] = 0\n        else:\n            label_list[i] = 1\n\n    pred_list = []\n    for answer in answers:\n        if answer['text'] == 'no':\n            pred_list.append(0)\n        else:\n            pred_list.append(1)\n\n    pos = 1\n    neg = 0\n    yes_ratio = pred_list.count(1) / len(pred_list)\n\n    TP, TN, FP, FN = 0, 0, 0, 0\n    for pred, label in zip(pred_list, label_list):\n        if pred == pos and label == pos:\n            TP += 1\n        elif pred == pos and label == neg:\n            FP += 1\n        elif pred == neg and label == neg:\n            TN += 1\n        elif pred == neg and label == pos:\n            FN += 1\n\n    print('TP\\tFP\\tTN\\tFN\\t')\n    print('{}\\t{}\\t{}\\t{}'.format(TP, FP, TN, FN))\n\n    precision = float(TP) / float(TP + FP)\n    recall = float(TP) / float(TP + FN)\n    f1 = 2*precision*recall / (precision + recall)\n    acc = (TP + TN) / (TP + TN + FP + FN)\n    print('Accuracy: {}'.format(acc))\n    print('Precision: {}'.format(precision))\n    print('Recall: {}'.format(recall))\n    print('F1 score: {}'.format(f1))\n    print('Yes ratio: {}'.format(yes_ratio))\n    print('%.3f, %.3f, %.3f, %.3f, %.3f' % (f1, acc, precision, recall, yes_ratio) )\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--annotation-dir\", type=str)\n    parser.add_argument(\"--question-file\", type=str)\n    parser.add_argument(\"--result-file\", type=str)\n    args = parser.parse_args()\n\n    questions = [json.loads(line) for line in open(args.question_file)]\n    questions = {question['question_id']: question for question in questions}\n    answers = [json.loads(q) for q in open(args.result_file)]\n    for file in os.listdir(args.annotation_dir):\n        try:\n            assert file.startswith('coco_pope_')\n            assert file.endswith('.json')\n            category = file[10:-5]\n            cur_answers = [x for x in answers if questions[x['question_id']]['category'] == category]\n            print('Category: {}, # samples: {}'.format(category, len(cur_answers)))\n            eval_pope(cur_answers, os.path.join(args.annotation_dir, file))\n            print(\"====================================\")\n        except:\n            pass\n\n"}
{"type": "source_file", "path": "LLaVA/llava/mm_utils.py", "content": "from PIL import Image\nfrom io import BytesIO\nimport base64\n\nimport torch\nfrom transformers import StoppingCriteria\nfrom llava.constants import IMAGE_TOKEN_INDEX\n\n\ndef load_image_from_base64(image):\n    return Image.open(BytesIO(base64.b64decode(image)))\n\n\ndef expand2square(pil_img, background_color):\n    width, height = pil_img.size\n    if width == height:\n        return pil_img\n    elif width > height:\n        result = Image.new(pil_img.mode, (width, width), background_color)\n        result.paste(pil_img, (0, (width - height) // 2))\n        return result\n    else:\n        result = Image.new(pil_img.mode, (height, height), background_color)\n        result.paste(pil_img, ((height - width) // 2, 0))\n        return result\n\n\ndef process_images(images, image_processor, model_cfg):\n    image_aspect_ratio = getattr(model_cfg, \"image_aspect_ratio\", None)\n    new_images = []\n    if image_aspect_ratio == 'pad':\n        for image in images:\n            image = expand2square(image, tuple(int(x*255) for x in image_processor.image_mean))\n            image = image_processor.preprocess(image, return_tensors='pt')['pixel_values'][0]\n            new_images.append(image)\n    else:\n        return image_processor(images, return_tensors='pt')['pixel_values']\n    if all(x.shape == new_images[0].shape for x in new_images):\n        new_images = torch.stack(new_images, dim=0)\n    return new_images\n\n\ndef tokenizer_image_token(prompt, tokenizer, image_token_index=IMAGE_TOKEN_INDEX, return_tensors=None):\n    prompt_chunks = [tokenizer(chunk).input_ids for chunk in prompt.split('<image>')]\n\n    def insert_separator(X, sep):\n        return [ele for sublist in zip(X, [sep]*len(X)) for ele in sublist][:-1]\n\n    input_ids = []\n    offset = 0\n    if len(prompt_chunks) > 0 and len(prompt_chunks[0]) > 0 and prompt_chunks[0][0] == tokenizer.bos_token_id:\n        offset = 1\n        input_ids.append(prompt_chunks[0][0])\n\n    for x in insert_separator(prompt_chunks, [image_token_index] * (offset + 1)):\n        input_ids.extend(x[offset:])\n\n    if return_tensors is not None:\n        if return_tensors == 'pt':\n            return torch.tensor(input_ids, dtype=torch.long)\n        raise ValueError(f'Unsupported tensor type: {return_tensors}')\n    return input_ids\n\n\ndef get_model_name_from_path(model_path):\n    model_path = model_path.strip(\"/\")\n    model_paths = model_path.split(\"/\")\n    if model_paths[-1].startswith('checkpoint-'):\n        return model_paths[-2] + \"_\" + model_paths[-1]\n    else:\n        return model_paths[-1]\n\n\n\n\nclass KeywordsStoppingCriteria(StoppingCriteria):\n    def __init__(self, keywords, tokenizer, input_ids):\n        self.keywords = keywords\n        self.keyword_ids = []\n        self.max_keyword_len = 0\n        for keyword in keywords:\n            cur_keyword_ids = tokenizer(keyword).input_ids\n            if len(cur_keyword_ids) > 1 and cur_keyword_ids[0] == tokenizer.bos_token_id:\n                cur_keyword_ids = cur_keyword_ids[1:]\n            if len(cur_keyword_ids) > self.max_keyword_len:\n                self.max_keyword_len = len(cur_keyword_ids)\n            self.keyword_ids.append(torch.tensor(cur_keyword_ids))\n        self.tokenizer = tokenizer\n        self.start_len = input_ids.shape[1]\n\n    def __call__(self, output_ids: torch.LongTensor, scores: torch.FloatTensor, **kwargs) -> bool:\n        assert output_ids.shape[0] == 1, \"Only support batch size 1 (yet)\"  # TODO\n        offset = min(output_ids.shape[1] - self.start_len, self.max_keyword_len)\n        self.keyword_ids = [keyword_id.to(output_ids.device) for keyword_id in self.keyword_ids]\n        for keyword_id in self.keyword_ids:\n            if (output_ids[0, -keyword_id.shape[0]:] == keyword_id).all():\n                return True\n        outputs = self.tokenizer.batch_decode(output_ids[:, -offset:], skip_special_tokens=True)[0]\n        for keyword in self.keywords:\n            if keyword in outputs:\n                return True\n        return False"}
{"type": "source_file", "path": "LLaVA/llava/model/consolidate.py", "content": "\"\"\"\nUsage:\npython3 -m llava.model.consolidate --src ~/model_weights/llava-7b --dst ~/model_weights/llava-7b_consolidate\n\"\"\"\nimport argparse\n\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\nfrom llava.model import *\nfrom llava.model.utils import auto_upgrade\n\n\ndef consolidate_ckpt(src_path, dst_path):\n    print(\"Loading model\")\n    auto_upgrade(src_path)\n    src_model = AutoModelForCausalLM.from_pretrained(src_path, torch_dtype=torch.float16, low_cpu_mem_usage=True)\n    src_tokenizer = AutoTokenizer.from_pretrained(src_path, use_fast=False)\n    src_model.save_pretrained(dst_path)\n    src_tokenizer.save_pretrained(dst_path)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--src\", type=str, required=True)\n    parser.add_argument(\"--dst\", type=str, required=True)\n\n    args = parser.parse_args()\n\n    consolidate_ckpt(args.src, args.dst)\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/model_vqa.py", "content": "import argparse\nimport torch\nimport os\nimport json\nfrom tqdm import tqdm\nimport shortuuid\n\nfrom llava.constants import IMAGE_TOKEN_INDEX, DEFAULT_IMAGE_TOKEN, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN\nfrom llava.conversation import conv_templates, SeparatorStyle\nfrom llava.model.builder import load_pretrained_model\nfrom llava.utils import disable_torch_init\nfrom llava.mm_utils import tokenizer_image_token, get_model_name_from_path, KeywordsStoppingCriteria\n\nfrom PIL import Image\nimport math\n\n\ndef split_list(lst, n):\n    \"\"\"Split a list into n (roughly) equal-sized chunks\"\"\"\n    chunk_size = math.ceil(len(lst) / n)  # integer division\n    return [lst[i:i+chunk_size] for i in range(0, len(lst), chunk_size)]\n\n\ndef get_chunk(lst, n, k):\n    chunks = split_list(lst, n)\n    return chunks[k]\n\n\ndef eval_model(args):\n    # Model\n    disable_torch_init()\n    model_path = os.path.expanduser(args.model_path)\n    model_name = get_model_name_from_path(model_path)\n    tokenizer, model, image_processor, context_len = load_pretrained_model(model_path, args.model_base, model_name)\n\n    questions = [json.loads(q) for q in open(os.path.expanduser(args.question_file), \"r\")]\n    questions = get_chunk(questions, args.num_chunks, args.chunk_idx)\n    answers_file = os.path.expanduser(args.answers_file)\n    os.makedirs(os.path.dirname(answers_file), exist_ok=True)\n    ans_file = open(answers_file, \"w\")\n    for line in tqdm(questions):\n        idx = line[\"question_id\"]\n        image_file = line[\"image\"]\n        qs = line[\"text\"]\n        cur_prompt = qs\n        if model.config.mm_use_im_start_end:\n            qs = DEFAULT_IM_START_TOKEN + DEFAULT_IMAGE_TOKEN + DEFAULT_IM_END_TOKEN + '\\n' + qs\n        else:\n            qs = DEFAULT_IMAGE_TOKEN + '\\n' + qs\n\n        conv = conv_templates[args.conv_mode].copy()\n        conv.append_message(conv.roles[0], qs)\n        conv.append_message(conv.roles[1], None)\n        prompt = conv.get_prompt()\n\n        input_ids = tokenizer_image_token(prompt, tokenizer, IMAGE_TOKEN_INDEX, return_tensors='pt').unsqueeze(0).cuda()\n\n        image = Image.open(os.path.join(args.image_folder, image_file))\n        image_tensor = image_processor.preprocess(image, return_tensors='pt')['pixel_values'][0]\n\n        stop_str = conv.sep if conv.sep_style != SeparatorStyle.TWO else conv.sep2\n        keywords = [stop_str]\n        stopping_criteria = KeywordsStoppingCriteria(keywords, tokenizer, input_ids)\n\n        with torch.inference_mode():\n            output_ids = model.generate(\n                input_ids,\n                images=image_tensor.unsqueeze(0).half().cuda(),\n                do_sample=True if args.temperature > 0 else False,\n                temperature=args.temperature,\n                top_p=args.top_p,\n                num_beams=args.num_beams,\n                # no_repeat_ngram_size=3,\n                max_new_tokens=1024,\n                use_cache=True)\n\n        input_token_len = input_ids.shape[1]\n        n_diff_input_output = (input_ids != output_ids[:, :input_token_len]).sum().item()\n        if n_diff_input_output > 0:\n            print(f'[Warning] {n_diff_input_output} output_ids are not the same as the input_ids')\n        outputs = tokenizer.batch_decode(output_ids[:, input_token_len:], skip_special_tokens=True)[0]\n        outputs = outputs.strip()\n        if outputs.endswith(stop_str):\n            outputs = outputs[:-len(stop_str)]\n        outputs = outputs.strip()\n\n        ans_id = shortuuid.uuid()\n        ans_file.write(json.dumps({\"question_id\": idx,\n                                   \"prompt\": cur_prompt,\n                                   \"text\": outputs,\n                                   \"answer_id\": ans_id,\n                                   \"model_id\": model_name,\n                                   \"metadata\": {}}) + \"\\n\")\n        ans_file.flush()\n    ans_file.close()\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model-path\", type=str, default=\"facebook/opt-350m\")\n    parser.add_argument(\"--model-base\", type=str, default=None)\n    parser.add_argument(\"--image-folder\", type=str, default=\"\")\n    parser.add_argument(\"--question-file\", type=str, default=\"tables/question.jsonl\")\n    parser.add_argument(\"--answers-file\", type=str, default=\"answer.jsonl\")\n    parser.add_argument(\"--conv-mode\", type=str, default=\"llava_v1\")\n    parser.add_argument(\"--num-chunks\", type=int, default=1)\n    parser.add_argument(\"--chunk-idx\", type=int, default=0)\n    parser.add_argument(\"--temperature\", type=float, default=0.2)\n    parser.add_argument(\"--top_p\", type=float, default=None)\n    parser.add_argument(\"--num_beams\", type=int, default=1)\n    args = parser.parse_args()\n\n    eval_model(args)\n"}
{"type": "source_file", "path": "LLaVA/llava/model/apply_delta.py", "content": "\"\"\"\nUsage:\npython3 -m fastchat.model.apply_delta --base ~/model_weights/llama-7b --target ~/model_weights/vicuna-7b --delta lmsys/vicuna-7b-delta\n\"\"\"\nimport argparse\n\nimport torch\nfrom tqdm import tqdm\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\nfrom llava import LlavaLlamaForCausalLM\n\n\ndef apply_delta(base_model_path, target_model_path, delta_path):\n    print(\"Loading base model\")\n    base = AutoModelForCausalLM.from_pretrained(\n        base_model_path, torch_dtype=torch.float16, low_cpu_mem_usage=True)\n\n    print(\"Loading delta\")\n    delta = LlavaLlamaForCausalLM.from_pretrained(delta_path, torch_dtype=torch.float16, low_cpu_mem_usage=True)\n    delta_tokenizer = AutoTokenizer.from_pretrained(delta_path)\n\n    print(\"Applying delta\")\n    for name, param in tqdm(delta.state_dict().items(), desc=\"Applying delta\"):\n        if name not in base.state_dict():\n            assert name in ['model.mm_projector.weight', 'model.mm_projector.bias'], f'{name} not in base model'\n            continue\n        if param.data.shape == base.state_dict()[name].shape:\n            param.data += base.state_dict()[name]\n        else:\n            assert name in ['model.embed_tokens.weight', 'lm_head.weight'], \\\n                f'{name} dimension mismatch: {param.data.shape} vs {base.state_dict()[name].shape}'\n            bparam = base.state_dict()[name]\n            param.data[:bparam.shape[0], :bparam.shape[1]] += bparam\n\n    print(\"Saving target model\")\n    delta.save_pretrained(target_model_path)\n    delta_tokenizer.save_pretrained(target_model_path)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--base-model-path\", type=str, required=True)\n    parser.add_argument(\"--target-model-path\", type=str, required=True)\n    parser.add_argument(\"--delta-path\", type=str, required=True)\n\n    args = parser.parse_args()\n\n    apply_delta(args.base_model_path, args.target_model_path, args.delta_path)\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/eval_gpt_review.py", "content": "import argparse\nimport json\nimport os\n\nimport openai\nimport tqdm\nimport ray\nimport time\n\nNUM_SECONDS_TO_SLEEP = 3\n\n@ray.remote(num_cpus=4)\ndef get_eval(content: str, max_tokens: int):\n    while True:\n        try:\n            response = openai.ChatCompletion.create(\n                model='gpt-4',\n                messages=[{\n                    'role': 'system',\n                    'content': 'You are a helpful and precise assistant for checking the quality of the answer.'\n                }, {\n                    'role': 'user',\n                    'content': content,\n                }],\n                temperature=0.2,  # TODO: figure out which temperature is best for evaluation\n                max_tokens=max_tokens,\n            )\n            break\n        except openai.error.RateLimitError:\n            pass\n        except Exception as e:\n            print(e)\n        time.sleep(NUM_SECONDS_TO_SLEEP)\n\n    print('success!')\n    return response['choices'][0]['message']['content']\n\n\ndef parse_score(review):\n    try:\n        score_pair = review.split('\\n')[0]\n        score_pair = score_pair.replace(',', ' ')\n        sp = score_pair.split(' ')\n        if len(sp) == 2:\n            return [float(sp[0]), float(sp[1])]\n        else:\n            print('error', review)\n            return [-1, -1]\n    except Exception as e:\n        print(e)\n        print('error', review)\n        return [-1, -1]\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='ChatGPT-based QA evaluation.')\n    parser.add_argument('-q', '--question')\n    # parser.add_argument('-a', '--answer')\n    parser.add_argument('-a', '--answer-list', nargs='+', default=[])\n    parser.add_argument('-r', '--rule')\n    parser.add_argument('-o', '--output')\n    parser.add_argument('--max-tokens', type=int, default=1024, help='maximum number of tokens produced in the output')\n    args = parser.parse_args()\n\n    ray.init()\n\n    f_q = open(os.path.expanduser(args.question))\n    f_ans1 = open(os.path.expanduser(args.answer_list[0]))\n    f_ans2 = open(os.path.expanduser(args.answer_list[1]))\n    rule_dict = json.load(open(os.path.expanduser(args.rule), 'r'))\n\n    review_file = open(f'{args.output}', 'w')\n\n    js_list = []\n    handles = []\n    idx = 0\n    for ques_js, ans1_js, ans2_js in zip(f_q, f_ans1, f_ans2):\n        # if idx == 1:\n        #     break\n\n        ques = json.loads(ques_js)\n        ans1 = json.loads(ans1_js)\n        ans2 = json.loads(ans2_js)\n\n        category = json.loads(ques_js)['category']\n        if category in rule_dict:\n            rule = rule_dict[category]\n        else:\n            rule = rule_dict['default']\n        prompt = rule['prompt']\n        role = rule['role']\n        content = (f'[Question]\\n{ques[\"text\"]}\\n\\n'\n                   f'[{role} 1]\\n{ans1[\"text\"]}\\n\\n[End of {role} 1]\\n\\n'\n                   f'[{role} 2]\\n{ans2[\"text\"]}\\n\\n[End of {role} 2]\\n\\n'\n                   f'[System]\\n{prompt}\\n\\n')\n        js_list.append({\n            'id': idx+1,\n            'question_id': ques['question_id'],\n            'answer1_id': ans1['answer_id'],\n            'answer2_id': ans2['answer_id'],\n            'category': category})\n        idx += 1\n        handles.append(get_eval.remote(content, args.max_tokens))\n        # To avoid the rate limit set by OpenAI\n        time.sleep(NUM_SECONDS_TO_SLEEP)\n\n    reviews = ray.get(handles)\n    for idx, review in enumerate(reviews):\n        scores = parse_score(review)\n        js_list[idx]['content'] = review\n        js_list[idx]['tuple'] = scores\n        review_file.write(json.dumps(js_list[idx]) + '\\n')\n    review_file.close()\n"}
{"type": "source_file", "path": "LLaVA/llava/serve/__init__.py", "content": ""}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/custom_embedding.py", "content": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch import Tensor\n\nclass SharedEmbedding(nn.Embedding):\n\n    def forward(self, input: Tensor, unembed: bool=False) -> Tensor:\n        if unembed:\n            return F.linear(input, self.weight)\n        return super().forward(input)"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/llava_llama.py", "content": "#    Copyright 2023 Haotian Liu\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\");\n#    you may not use this file except in compliance with the License.\n#    You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS,\n#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#    See the License for the specific language governing permissions and\n#    limitations under the License.\n\n\nfrom typing import List, Optional, Tuple, Union\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import CrossEntropyLoss\n\nfrom transformers import AutoConfig, AutoModelForCausalLM, \\\n                         LlamaConfig, LlamaModel, LlamaForCausalLM\n\nfrom transformers.modeling_outputs import CausalLMOutputWithPast\n\nfrom ..llava_arch import LlavaMetaModel, LlavaMetaForCausalLM\n\n\nclass LlavaConfig(LlamaConfig):\n    model_type = \"llava\"\n\n\nclass LlavaLlamaModel(LlavaMetaModel, LlamaModel):\n    config_class = LlavaConfig\n\n    def __init__(self, config: LlamaConfig):\n        super(LlavaLlamaModel, self).__init__(config)\n\n\nclass LlavaLlamaForCausalLM(LlamaForCausalLM, LlavaMetaForCausalLM):\n    config_class = LlavaConfig\n\n    def __init__(self, config):\n        super(LlamaForCausalLM, self).__init__(config)\n        self.model = LlavaLlamaModel(config)\n\n        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_model(self):\n        return self.model\n\n    def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        images: Optional[torch.FloatTensor] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, CausalLMOutputWithPast]:\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        #input_ids, attention_mask, past_key_values, inputs_embeds, labels = self.prepare_inputs_labels_for_multimodal(input_ids, attention_mask, past_key_values, labels, images)\n        input_ids, attention_mask, past_key_values, inputs_embeds, labels = self.prepare_inputs_labels_for_multimodal_withdino(input_ids, attention_mask, past_key_values, labels, images)\n\n        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n        outputs = self.model(\n            input_ids=input_ids,\n            attention_mask=attention_mask,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict\n        )\n\n        hidden_states = outputs[0]\n        logits = self.lm_head(hidden_states)\n\n        loss = None\n        if labels is not None:\n            # Shift so that tokens < n predict n\n            shift_logits = logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss()\n            shift_logits = shift_logits.view(-1, self.config.vocab_size)\n            shift_labels = shift_labels.view(-1)\n            # Enable model/pipeline parallelism\n            shift_labels = shift_labels.to(shift_logits.device)\n            loss = loss_fct(shift_logits, shift_labels)\n\n        if not return_dict:\n            output = (logits,) + outputs[1:]\n            return (loss,) + output if loss is not None else output\n\n        return CausalLMOutputWithPast(\n            loss=loss,\n            logits=logits,\n            past_key_values=outputs.past_key_values,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n\n    def prepare_inputs_for_generation(\n        self, input_ids, past_key_values=None, attention_mask=None, inputs_embeds=None, **kwargs\n    ):\n        if past_key_values:\n            input_ids = input_ids[:, -1:]\n\n        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n        if inputs_embeds is not None and past_key_values is None:\n            model_inputs = {\"inputs_embeds\": inputs_embeds}\n        else:\n            model_inputs = {\"input_ids\": input_ids}\n\n        model_inputs.update(\n            {\n                \"past_key_values\": past_key_values,\n                \"use_cache\": kwargs.get(\"use_cache\"),\n                \"attention_mask\": attention_mask,\n                \"images\": kwargs.get(\"images\", None),\n            }\n        )\n        return model_inputs\n\nAutoConfig.register(\"llava\", LlavaConfig)\nAutoModelForCausalLM.register(LlavaConfig, LlavaLlamaForCausalLM)\n"}
{"type": "source_file", "path": "LLaVA/llava/eval/vqa_benchmark.py", "content": "import argparse\nimport torch\nimport os\nimport json\nfrom tqdm import tqdm\nimport shortuuid\n\nfrom llava.constants import IMAGE_TOKEN_INDEX, DEFAULT_IMAGE_TOKEN, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN\nfrom llava.conversation import conv_templates, SeparatorStyle\nfrom llava.model.builder import load_pretrained_model\nfrom llava.utils import disable_torch_init\nfrom llava.mm_utils import tokenizer_image_token, get_model_name_from_path, KeywordsStoppingCriteria\n\nfrom PIL import Image\nimport math\n\n\nimport pandas as pd\nfrom PIL import Image\nimport os\n\n\ndef split_list(lst, n):\n    \"\"\"Split a list into n (roughly) equal-sized chunks\"\"\"\n    chunk_size = math.ceil(len(lst) / n)  # integer division\n    return [lst[i:i+chunk_size] for i in range(0, len(lst), chunk_size)]\n\n\ndef get_chunk(lst, n, k):\n    chunks = split_list(lst, n)\n    return chunks[k]\n\n\ndef eval_model(args):\n    # Model\n    disable_torch_init()\n    model_path = os.path.expanduser(args.model_path)\n    model_name = get_model_name_from_path(model_path)\n\n    \n    tokenizer, model, image_processor, context_len = load_pretrained_model(model_path, args.model_base, model_name)\n    \n    # Load and read the CSV\n    df = pd.read_csv(\"/home/simonzhai/LLaVA/benchmark/benchmark_vllm.csv\")  # Assuming the fields are separated by tabs\n    answers_file = os.path.expanduser(args.answers_file)\n    os.makedirs(os.path.dirname(answers_file), exist_ok=True)\n    ans_file = open(answers_file, \"w\")\n\n    # Loop through each row in the DataFrame\n    for index, row in tqdm(df.iterrows()):\n        # Construct the 'prompts' string\n\n        \n        try:\n            cur_prompt = row['Prompt'] + \" \" + row['Question'] + \" \" + row['Options']\n            #cur_prompt = row['Question']\n            #cur_prompt = row['Question'] + \" \" + row['Options']\n            #print(f\"Row {index + 1} Prompts: {cur_prompt}\")\n            #cur_prompt = \"What are the numbers of each card in the image?\"\n        except:\n            print(f\"I quit at {index}\")\n            break\n        qs = cur_prompt\n        if model.config.mm_use_im_start_end:\n            qs = DEFAULT_IM_START_TOKEN + DEFAULT_IMAGE_TOKEN + DEFAULT_IM_END_TOKEN + '\\n' + qs\n        else:\n            qs = DEFAULT_IMAGE_TOKEN + '\\n' + qs\n\n        conv = conv_templates[args.conv_mode].copy()\n        conv.append_message(conv.roles[0], qs)\n        conv.append_message(conv.roles[1], None)\n        prompt = conv.get_prompt()\n\n        # Load the corresponding image\n        photo_id = row['Photo ID']\n        image_path = os.path.join(\"/home/simonzhai/LLaVA/benchmark/benchmark_images\", f\"{photo_id}.jpg\")\n        #image_path = \"/home/simonzhai/LLaVA1.5/card.jpg\"\n        image = Image.open(image_path)\n\n        input_ids = tokenizer_image_token(prompt, tokenizer, IMAGE_TOKEN_INDEX, return_tensors='pt').unsqueeze(0).cuda()\n\n        image_tensor = image_processor.preprocess(image, return_tensors='pt')['pixel_values'][0]\n\n        stop_str = conv.sep if conv.sep_style != SeparatorStyle.TWO else conv.sep2\n        keywords = [stop_str]\n        stopping_criteria = KeywordsStoppingCriteria(keywords, tokenizer, input_ids)\n\n        with torch.inference_mode():\n            output_ids = model.generate(\n                input_ids,\n                images=image_tensor.unsqueeze(0).half().cuda(),\n                do_sample=True,\n                temperature=args.temperature,\n                top_p=args.top_p,\n                num_beams=args.num_beams,\n                # no_repeat_ngram_size=3,\n                max_new_tokens=1024,\n                use_cache=True)\n\n        input_token_len = input_ids.shape[1]\n        n_diff_input_output = (input_ids != output_ids[:, :input_token_len]).sum().item()\n        if n_diff_input_output > 0:\n            print(f'[Warning] {n_diff_input_output} output_ids are not the same as the input_ids')\n        outputs = tokenizer.batch_decode(output_ids[:, input_token_len:], skip_special_tokens=True)[0]\n        outputs = outputs.strip()\n        if outputs.endswith(stop_str):\n            outputs = outputs[:-len(stop_str)]\n        outputs = outputs.strip()\n\n        ans_id = shortuuid.uuid()\n        ans_file.write(json.dumps({\"question_id\": photo_id,\n                                   \"prompt\": cur_prompt,\n                                   \"text\": outputs,\n                                   \"answer_id\": ans_id,\n                                   \"model_id\": model_name,\n                                   \"metadata\": {}}) + \"\\n\")\n        ans_file.flush()\n    ans_file.close()\n\n            \n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model-path\", type=str, default=\"facebook/opt-350m\")\n    parser.add_argument(\"--model-base\", type=str, default=None)\n    parser.add_argument(\"--image-folder\", type=str, default=\"\")\n    parser.add_argument(\"--question-file\", type=str, default=\"tables/question.jsonl\")\n    parser.add_argument(\"--answers-file\", type=str, default=\"answer.jsonl\")\n    parser.add_argument(\"--conv-mode\", type=str, default=\"llava_v1\")\n    parser.add_argument(\"--num-chunks\", type=int, default=1)\n    parser.add_argument(\"--chunk-idx\", type=int, default=0)\n    parser.add_argument(\"--temperature\", type=float, default=0.2)\n    parser.add_argument(\"--top_p\", type=float, default=None)\n    parser.add_argument(\"--num_beams\", type=int, default=1)\n    args = parser.parse_args()\n\n    eval_model(args)\n"}
{"type": "source_file", "path": "LLaVA/llava/model/language_model/mpt/modeling_mpt.py", "content": "\"\"\"A simple, flexible implementation of a GPT model.\n\nInspired by https://github.com/karpathy/minGPT/blob/master/mingpt/model.py\n\"\"\"\nimport math\nimport warnings\nfrom typing import List, Optional, Tuple, Union\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom transformers import PreTrainedModel, PreTrainedTokenizer, PreTrainedTokenizerFast\nfrom transformers.modeling_outputs import BaseModelOutputWithPast, CausalLMOutputWithPast\nfrom .attention import attn_bias_shape, build_attn_bias\nfrom .blocks import MPTBlock\nfrom .custom_embedding import SharedEmbedding\nfrom .norm import NORM_CLASS_REGISTRY\nfrom .configuration_mpt import MPTConfig\nfrom .adapt_tokenizer import AutoTokenizerForMOD, adapt_tokenizer_for_denoising\nfrom .hf_prefixlm_converter import add_bidirectional_mask_if_missing, convert_hf_causal_lm_to_prefix_lm\nfrom .meta_init_context import init_empty_weights\nfrom .param_init_fns import MODEL_INIT_REGISTRY, generic_param_init_fn_\ntry:\n    from .flash_attn_triton import flash_attn_func\nexcept:\n    pass\nTokenizer = Union[PreTrainedTokenizer, PreTrainedTokenizerFast]\n\nclass MPTPreTrainedModel(PreTrainedModel):\n    config_class = MPTConfig\n    base_model_prefix = 'model'\n    _no_split_modules = ['MPTBlock']\n\nclass MPTModel(MPTPreTrainedModel):\n\n    def __init__(self, config: MPTConfig):\n        config._validate_config()\n        super().__init__(config)\n        self.attn_impl = config.attn_config['attn_impl']\n        self.prefix_lm = config.attn_config['prefix_lm']\n        self.attn_uses_sequence_id = config.attn_config['attn_uses_sequence_id']\n        self.alibi = config.attn_config['alibi']\n        self.alibi_bias_max = config.attn_config['alibi_bias_max']\n        if config.init_device == 'mixed':\n            if dist.get_local_rank() == 0:\n                config.init_device = 'cpu'\n            else:\n                config.init_device = 'meta'\n        if config.norm_type.lower() not in NORM_CLASS_REGISTRY.keys():\n            norm_options = ' | '.join(NORM_CLASS_REGISTRY.keys())\n            raise NotImplementedError(f'Requested norm type ({config.norm_type}) is not implemented within this repo (Options: {norm_options}).')\n        norm_class = NORM_CLASS_REGISTRY[config.norm_type.lower()]\n        self.embedding_fraction = config.embedding_fraction\n        self.wte = SharedEmbedding(config.vocab_size, config.d_model, device=config.init_device)\n        if not self.alibi:\n            self.wpe = torch.nn.Embedding(config.max_seq_len, config.d_model, device=config.init_device)\n        self.emb_drop = nn.Dropout(config.emb_pdrop)\n        self.blocks = nn.ModuleList([MPTBlock(device=config.init_device, **config.to_dict()) for _ in range(config.n_layers)])\n        self.norm_f = norm_class(config.d_model, device=config.init_device)\n        if config.init_device != 'meta':\n            print(f'You are using config.init_device={config.init_device!r}, but you can also use config.init_device=\"meta\" with Composer + FSDP for fast initialization.')\n            self.apply(self.param_init_fn)\n        self.is_causal = not self.prefix_lm\n        self._attn_bias_initialized = False\n        self.attn_bias = None\n        self.attn_bias_shape = attn_bias_shape(self.attn_impl, config.n_heads, config.max_seq_len, self.alibi, prefix_lm=self.prefix_lm, causal=self.is_causal, use_sequence_id=self.attn_uses_sequence_id)\n        if config.no_bias:\n            for module in self.modules():\n                if hasattr(module, 'bias') and isinstance(module.bias, nn.Parameter):\n                    if config.verbose:\n                        warnings.warn(f'Removing bias ({module.bias}) from {module}.')\n                    module.register_parameter('bias', None)\n        if config.verbose and config.verbose > 2:\n            print(self)\n        if 'verbose' not in self.config.init_config:\n            self.config.init_config['verbose'] = self.config.verbose\n        if self.config.init_config['verbose'] > 1:\n            init_fn_name = self.config.init_config['name']\n            warnings.warn(f'Using {init_fn_name} initialization.')\n        self.gradient_checkpointing = False\n\n    def get_input_embeddings(self):\n        return self.wte\n\n    def set_input_embeddings(self, value):\n        self.wte = value\n\n    @torch.no_grad()\n    def _attn_bias(self, device, dtype, attention_mask: Optional[torch.ByteTensor]=None, prefix_mask: Optional[torch.ByteTensor]=None, sequence_id: Optional[torch.LongTensor]=None):\n        if not self._attn_bias_initialized:\n            if self.attn_bias_shape:\n                self.attn_bias = torch.zeros(self.attn_bias_shape, device=device, dtype=dtype)\n                self.attn_bias = build_attn_bias(self.attn_impl, self.attn_bias, self.config.n_heads, self.config.max_seq_len, causal=self.is_causal, alibi=self.alibi, alibi_bias_max=self.alibi_bias_max)\n            self._attn_bias_initialized = True\n        if self.attn_impl == 'flash':\n            return (self.attn_bias, attention_mask)\n        if self.attn_bias is not None:\n            self.attn_bias = self.attn_bias.to(dtype=dtype, device=device)\n        attn_bias = self.attn_bias\n        if self.prefix_lm:\n            assert isinstance(attn_bias, torch.Tensor)\n            assert isinstance(prefix_mask, torch.Tensor)\n            attn_bias = self._apply_prefix_mask(attn_bias, prefix_mask)\n        if self.attn_uses_sequence_id and sequence_id is not None:\n            assert isinstance(attn_bias, torch.Tensor)\n            attn_bias = self._apply_sequence_id(attn_bias, sequence_id)\n        if attention_mask is not None:\n            s_k = attention_mask.shape[-1]\n            if attn_bias is None:\n                attn_bias = torch.zeros((1, 1, 1, s_k), device=device, dtype=dtype)\n            else:\n                _s_k = max(0, attn_bias.size(-1) - s_k)\n                attn_bias = attn_bias[:, :, :, _s_k:]\n            if prefix_mask is not None and attention_mask.shape != prefix_mask.shape:\n                raise ValueError(f'attention_mask shape={attention_mask.shape} ' + f'and prefix_mask shape={prefix_mask.shape} are not equal.')\n            min_val = torch.finfo(attn_bias.dtype).min\n            attn_bias = attn_bias.masked_fill(~attention_mask.view(-1, 1, 1, s_k), min_val)\n        return (attn_bias, None)\n\n    def _apply_prefix_mask(self, attn_bias: torch.Tensor, prefix_mask: torch.Tensor):\n        (s_k, s_q) = attn_bias.shape[-2:]\n        if s_k != self.config.max_seq_len or s_q != self.config.max_seq_len:\n            raise ValueError('attn_bias does not match the expected shape. ' + f'The last two dimensions should both be {self.config.max_length} ' + f'but are {s_k} and {s_q}.')\n        seq_len = prefix_mask.shape[-1]\n        if seq_len > self.config.max_seq_len:\n            raise ValueError(f'prefix_mask sequence length cannot exceed max_seq_len={self.config.max_seq_len}')\n        attn_bias = attn_bias[..., :seq_len, :seq_len]\n        causal = torch.tril(torch.ones((seq_len, seq_len), dtype=torch.bool, device=prefix_mask.device)).view(1, 1, seq_len, seq_len)\n        prefix = prefix_mask.view(-1, 1, 1, seq_len)\n        cannot_attend = ~torch.logical_or(causal, prefix.bool())\n        min_val = torch.finfo(attn_bias.dtype).min\n        attn_bias = attn_bias.masked_fill(cannot_attend, min_val)\n        return attn_bias\n\n    def _apply_sequence_id(self, attn_bias: torch.Tensor, sequence_id: torch.LongTensor):\n        seq_len = sequence_id.shape[-1]\n        if seq_len > self.config.max_seq_len:\n            raise ValueError(f'sequence_id sequence length cannot exceed max_seq_len={self.config.max_seq_len}')\n        attn_bias = attn_bias[..., :seq_len, :seq_len]\n        cannot_attend = torch.logical_not(torch.eq(sequence_id.view(-1, seq_len, 1), sequence_id.view(-1, 1, seq_len))).unsqueeze(1)\n        min_val = torch.finfo(attn_bias.dtype).min\n        attn_bias = attn_bias.masked_fill(cannot_attend, min_val)\n        return attn_bias\n\n    def forward(self, input_ids: torch.LongTensor, past_key_values: Optional[List[Tuple[torch.FloatTensor]]]=None, attention_mask: Optional[torch.ByteTensor]=None, prefix_mask: Optional[torch.ByteTensor]=None, sequence_id: Optional[torch.LongTensor]=None, return_dict: Optional[bool]=None, output_attentions: Optional[bool]=None, output_hidden_states: Optional[bool]=None, use_cache: Optional[bool]=None, inputs_embeds: Optional[torch.Tensor]=None):\n        return_dict = return_dict if return_dict is not None else self.config.return_dict\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n        if attention_mask is not None:\n            attention_mask = attention_mask.bool()\n        if prefix_mask is not None:\n            prefix_mask = prefix_mask.bool()\n        if not return_dict:\n            raise NotImplementedError('return_dict False is not implemented yet for MPT')\n        if output_attentions:\n            if self.attn_impl != 'torch':\n                raise NotImplementedError('output_attentions is not implemented for MPT when using attn_impl `flash` or `triton`.')\n        if attention_mask is not None and attention_mask[:, 0].sum() != attention_mask.shape[0] and self.training:\n            raise NotImplementedError('MPT does not support training with left padding.')\n        if self.prefix_lm and prefix_mask is None:\n            raise ValueError('prefix_mask is a required argument when MPT is configured with prefix_lm=True.')\n        if self.training:\n            if self.attn_uses_sequence_id and sequence_id is None:\n                raise ValueError('sequence_id is a required argument when MPT is configured with attn_uses_sequence_id=True ' + 'and the model is in train mode.')\n            elif self.attn_uses_sequence_id is False and sequence_id is not None:\n                warnings.warn('MPT received non-None input for `sequence_id` but is configured with attn_uses_sequence_id=False. ' + 'This input will be ignored. If you want the model to use `sequence_id`, set attn_uses_sequence_id to True.')\n        if input_ids is not None:\n            S = input_ids.size(1)\n            assert S <= self.config.max_seq_len, f'Cannot forward input with seq_len={S}, this model only supports seq_len<={self.config.max_seq_len}'\n            tok_emb = self.wte(input_ids)\n        else:\n            assert inputs_embeds is not None\n            assert self.alibi, 'inputs_embeds is not implemented for MPT unless for alibi.'\n            S = inputs_embeds.size(1)\n            tok_emb = inputs_embeds\n        if self.alibi:\n            x = tok_emb\n        else:\n            past_position = 0\n            if past_key_values is not None:\n                if len(past_key_values) != self.config.n_layers:\n                    raise ValueError(f'past_key_values must provide a past_key_value for each attention ' + f'layer in the network (len(past_key_values)={len(past_key_values)!r}; self.config.n_layers={self.config.n_layers!r}).')\n                past_position = past_key_values[0][0].size(1)\n                if self.attn_impl == 'torch':\n                    past_position = past_key_values[0][0].size(3)\n            if S + past_position > self.config.max_seq_len:\n                raise ValueError(f'Cannot forward input with past sequence length {past_position} and current sequence length {S + 1}, this model only supports total sequence length <= {self.config.max_seq_len}.')\n            pos = torch.arange(past_position, S + past_position, dtype=torch.long, device=input_ids.device).unsqueeze(0)\n            if attention_mask is not None:\n                pos = torch.clamp(pos - torch.cumsum((~attention_mask).to(torch.int32), dim=1)[:, past_position:], min=0)\n            pos_emb = self.wpe(pos)\n            x = tok_emb + pos_emb\n        if self.embedding_fraction == 1:\n            x = self.emb_drop(x)\n        else:\n            x_shrunk = x * self.embedding_fraction + x.detach() * (1 - self.embedding_fraction)\n            assert isinstance(self.emb_drop, nn.Module)\n            x = self.emb_drop(x_shrunk)\n        (attn_bias, attention_mask) = self._attn_bias(device=x.device, dtype=torch.float32, attention_mask=attention_mask, prefix_mask=prefix_mask, sequence_id=sequence_id)\n        if use_cache and past_key_values is None:\n            past_key_values = [() for _ in range(self.config.n_layers)]\n        all_hidden_states = () if output_hidden_states else None\n        all_self_attns = () if output_attentions else None\n        for (b_idx, block) in enumerate(self.blocks):\n            if output_hidden_states:\n                assert all_hidden_states is not None\n                all_hidden_states = all_hidden_states + (x,)\n            past_key_value = past_key_values[b_idx] if past_key_values is not None else None\n            if self.gradient_checkpointing and self.training:\n                (x, attn_weights, past_key_value) = torch.utils.checkpoint.checkpoint(block, x, past_key_value, attn_bias, attention_mask, self.is_causal)\n            else:\n                (x, attn_weights, past_key_value) = block(x, past_key_value=past_key_value, attn_bias=attn_bias, attention_mask=attention_mask, is_causal=self.is_causal)\n            if past_key_values is not None:\n                past_key_values[b_idx] = past_key_value\n            if output_attentions:\n                assert all_self_attns is not None\n                all_self_attns = all_self_attns + (attn_weights,)\n        x = self.norm_f(x)\n        if output_hidden_states:\n            assert all_hidden_states is not None\n            all_hidden_states = all_hidden_states + (x,)\n        return BaseModelOutputWithPast(last_hidden_state=x, past_key_values=past_key_values, hidden_states=all_hidden_states, attentions=all_self_attns)\n\n    def param_init_fn(self, module):\n        init_fn_name = self.config.init_config['name']\n        MODEL_INIT_REGISTRY[init_fn_name](module=module, n_layers=self.config.n_layers, d_model=self.config.d_model, **self.config.init_config)\n\n    def fsdp_wrap_fn(self, module):\n        return isinstance(module, MPTBlock)\n\n    def activation_checkpointing_fn(self, module):\n        return isinstance(module, MPTBlock)\n\nclass MPTForCausalLM(MPTPreTrainedModel):\n\n    def __init__(self, config: MPTConfig):\n        super().__init__(config)\n        if not config.tie_word_embeddings:\n            raise ValueError('MPTForCausalLM only supports tied word embeddings')\n        print(f'Instantiating an MPTForCausalLM model from {__file__}')\n        self.transformer = MPTModel(config)\n        for child in self.transformer.children():\n            if isinstance(child, torch.nn.ModuleList):\n                continue\n            if isinstance(child, torch.nn.Module):\n                child._fsdp_wrap = True\n        self.logit_scale = None\n        if config.logit_scale is not None:\n            logit_scale = config.logit_scale\n            if isinstance(logit_scale, str):\n                if logit_scale == 'inv_sqrt_d_model':\n                    logit_scale = 1 / math.sqrt(config.d_model)\n                else:\n                    raise ValueError(f\"logit_scale={logit_scale!r} is not recognized as an option; use numeric value or 'inv_sqrt_d_model'.\")\n            self.logit_scale = logit_scale\n\n    def get_input_embeddings(self):\n        return self.transformer.wte\n\n    def set_input_embeddings(self, value):\n        self.transformer.wte = value\n\n    def get_output_embeddings(self):\n        return self.transformer.wte\n\n    def set_output_embeddings(self, new_embeddings):\n        self.transformer.wte = new_embeddings\n\n    def set_decoder(self, decoder):\n        self.transformer = decoder\n\n    def get_decoder(self):\n        return self.transformer\n\n    def forward(self, input_ids: torch.LongTensor, past_key_values: Optional[List[Tuple[torch.FloatTensor]]]=None, attention_mask: Optional[torch.ByteTensor]=None, prefix_mask: Optional[torch.ByteTensor]=None, sequence_id: Optional[torch.LongTensor]=None, labels: Optional[torch.LongTensor]=None, return_dict: Optional[bool]=None, output_attentions: Optional[bool]=None, output_hidden_states: Optional[bool]=None, use_cache: Optional[bool]=None, inputs_embeds: Optional[torch.FloatTensor]=None):\n        return_dict = return_dict if return_dict is not None else self.config.return_dict\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n        if inputs_embeds is not None:\n            raise NotImplementedError('inputs_embeds has to be None (for hf/peft support).')\n        outputs = self.transformer(input_ids=input_ids, past_key_values=past_key_values, attention_mask=attention_mask, prefix_mask=prefix_mask, sequence_id=sequence_id, return_dict=return_dict, output_attentions=output_attentions, output_hidden_states=output_hidden_states, use_cache=use_cache)\n        logits = self.transformer.wte(outputs.last_hidden_state.to(self.transformer.wte.weight.device), True)\n        if self.logit_scale is not None:\n            if self.logit_scale == 0:\n                warnings.warn(f'Multiplying logits by self.logit_scale={self.logit_scale!r}. This will produce uniform (uninformative) outputs.')\n            logits *= self.logit_scale\n        loss = None\n        if labels is not None:\n            labels = torch.roll(labels, shifts=-1)\n            labels[:, -1] = -100\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), labels.to(logits.device).view(-1))\n        return CausalLMOutputWithPast(loss=loss, logits=logits, past_key_values=outputs.past_key_values, hidden_states=outputs.hidden_states, attentions=outputs.attentions)\n\n    def param_init_fn(self, module):\n        init_fn_name = self.config.init_config['name']\n        MODEL_INIT_REGISTRY[init_fn_name](module=module, n_layers=self.config.n_layers, d_model=self.config.d_model, **self.config.init_config)\n\n    def fsdp_wrap_fn(self, module):\n        return isinstance(module, MPTBlock)\n\n    def activation_checkpointing_fn(self, module):\n        return isinstance(module, MPTBlock)\n\n    def prepare_inputs_for_generation(self, input_ids, past_key_values=None, inputs_embeds=None, **kwargs):\n        if inputs_embeds is not None:\n            raise NotImplementedError('inputs_embeds is not implemented for MPT yet')\n        attention_mask = kwargs['attention_mask'].bool()\n        if attention_mask[:, -1].sum() != attention_mask.shape[0]:\n            raise NotImplementedError('MPT does not support generation with right padding.')\n        if self.transformer.attn_uses_sequence_id and self.training:\n            sequence_id = torch.zeros_like(input_ids[:1])\n        else:\n            sequence_id = None\n        if past_key_values is not None:\n            input_ids = input_ids[:, -1].unsqueeze(-1)\n        if self.transformer.prefix_lm:\n            prefix_mask = torch.ones_like(attention_mask)\n            if kwargs.get('use_cache') == False:\n                raise NotImplementedError('MPT with prefix_lm=True does not support use_cache=False.')\n        else:\n            prefix_mask = None\n        return {'input_ids': input_ids, 'attention_mask': attention_mask, 'prefix_mask': prefix_mask, 'sequence_id': sequence_id, 'past_key_values': past_key_values, 'use_cache': kwargs.get('use_cache', True)}\n\n    @staticmethod\n    def _reorder_cache(past_key_values, beam_idx):\n        \"\"\"Used by HuggingFace generate when using beam search with kv-caching.\n\n        See https://github.com/huggingface/transformers/blob/3ec7a47664ebe40c40f4b722f6bb1cd30c3821ec/src/transformers/models/gpt2/modeling_gpt2.py#L1122-L1133\n        for an example in transformers.\n        \"\"\"\n        reordered_past = []\n        for layer_past in past_key_values:\n            reordered_past += [tuple((past_state.index_select(0, beam_idx) for past_state in layer_past))]\n        return reordered_past"}

{"repo_info": {"repo_name": "mercury", "repo_owner": "ayoub3bidi", "repo_url": "https://github.com/ayoub3bidi/mercury"}}
{"type": "test_file", "path": "src/integration_tests/test_admin_user.py", "content": "import pytest\nimport os\nfrom init_test import client\n\nheaders = {\"Authorization\": \"Bearer your_token_here\"}\nv = os.getenv(\"VERSION\")\n\ndef test_get_users():\n    if client is None:\n        pytest.skip(\"Client not initialized\")\n        \n    response = client.get(f\"/{v}/admin/user/all\", headers=headers)\n    pytest.expect(response.status_code == 200)\n    pytest.expect(len(response.json()) > 0)\n        \ndef test_get_user_by_id():\n    if client is None:\n        pytest.skip(\"Client not initialized\")\n        \n    response = client.get(f\"/{v}/admin/user/1\", headers=headers)\n    pytest.expect(response.status_code == 200)\n    pytest.expect(response.json()[\"id\"] == 1)\n\ndef test_add_user():\n    if client is None:\n        pytest.skip(\"Client not initialized\")\n        \n    response = client.post(\n        f\"/{v}/admin/user/register\",\n        json={\n            \"username\": \"test_user\",\n            \"email\": \"test_user@gmail.com\",\n            \"password\": \"GoodPassword123\",\n            \"is_admin\": True,\n            \"disabled\": False\n        },\n        headers=headers\n    )\n    pytest.expect(response.status_code == 201)\n    pytest.expect(response.json()[\"username\"] == \"test_user\")\n\ndef test_delete_user():\n    if client is None:\n        pytest.skip(\"Client not initialized\")\n        \n    response = client.delete(f\"/{v}/admin/user/1\", headers=headers)\n    pytest.expect(response.text is None)\n"}
{"type": "test_file", "path": "src/unit_tests/test_health.py", "content": "from unittest import TestCase\n\nclass TestHealth(TestCase):\n    def __init__(self, *args, **kwargs):\n        super(TestHealth, self).__init__(*args, **kwargs)\n\n    def test_get_health(self):\n        ## Given\n        from routes.health import get_health\n        \n        ## When\n        result = get_health()\n\n        ## Then\n        self.assertIsNotNone(result)"}
{"type": "test_file", "path": "src/integration_tests/test_health.py", "content": "import pytest\nimport os\nfrom init_test import client\n\nv = os.getenv(\"VERSION\")\n\ndef test_get_health():\n    if client is None:\n        pytest.skip(\"Client not initialized\")\n        \n    response = client.get(f\"/{v}/health\")\n    pytest.expect(response.status_code == 200)\n    pytest.expect(response.json() == {\n        'status': 'ok',\n        'alive': True\n    })\n"}
{"type": "source_file", "path": "src/app.py", "content": "import uvicorn\nimport os\nfrom utils.common import get_env_int\n\nif __name__ == \"__main__\":\n    uvicorn.run(\n        \"main:app\", \n        host=os.environ['LISTEN_ADDR'], \n        port=get_env_int('LISTEN_PORT', 8000), \n        workers=get_env_int('UVICORN_WORKERS', 10),\n        timeout_keep_alive=get_env_int('UVICORN_TIMEOUT_KEEP_ALIVE', 30),\n        timeout_graceful_shutdown=get_env_int('UVICORN_TIMEOUT_GRACEFUL_SHUTDOWN', 10),\n    )\n"}
{"type": "source_file", "path": "src/controllers/user/user.py", "content": "from datetime import timedelta\nimport os\nfrom fastapi import HTTPException, status\nfrom constants.environment_variables import ACCESS_TOKEN_EXPIRE_MINUTES\nfrom models.User import User\nfrom utils.security import authenticate_user, create_access_token, get_password_hash, validate_email, validate_password\nfrom utils.variables import is_not_empty\n\ndef register(payload, db):\n    if (validate_email(payload.email) is False):\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Invalid email\")\n    if (validate_password(payload.password) is False):\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Invalid password\")\n    user = db.query(User).filter(User.email == payload.email).first()\n    if user:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Email already registered\")\n    payload.password = get_password_hash(payload.password)\n    new_user = User(**payload.dict())\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    return {\n            \"id\": new_user.id,\n            \"email\": new_user.email\n        }\n    \ndef login(payload, db):\n    user = authenticate_user(payload, db)\n    access_token_expires = timedelta(minutes=int(ACCESS_TOKEN_EXPIRE_MINUTES))\n    access_token = create_access_token(data={\"sub\": user.email}, expires_delta=access_token_expires)\n    return {\n        \"id\": user.id,\n        \"email\": user.email,\n        \"token\": {\n            \"access_token\": access_token, \n            \"token_type\": \"bearer\"\n        }\n    }\n    \ndef update_user(current_user, payload, db):\n    user = db.query(User).filter(User.id == current_user.id)\n    \n    existing_user = user.first()\n    if not existing_user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found\")\n    \n    updated_user = User(**payload.dict())\n    \n    if is_not_empty(updated_user.email) and updated_user.email != existing_user.email:\n        user_exists = db.query(User).filter(User.email == updated_user.email).first()\n        if user_exists:\n            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f\"The email {updated_user.email} already exists\")\n\n    if is_not_empty(updated_user.username) and updated_user.username != existing_user.username:\n        user_exists = db.query(User).filter(User.username == updated_user.username).first()\n        if user_exists:\n            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f\"The username {updated_user.username} already exists\")\n    \n    if payload.username:\n        user.update({\"username\": payload.username})\n    if payload.email:\n        user.update({\"email\": payload.email})\n    if payload.password:\n        user.update({\"password\": get_password_hash(payload.password)})\n        \n    db.commit()\n    db.refresh(existing_user)\n\n    return {\n        \"message\": \"your account has been updated successfully\"\n    }"}
{"type": "source_file", "path": "src/main.py", "content": "from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom constants.environment_variables import APP_DESCRIPTION, APP_TITLE, APP_VERSION, APP_ENV\nfrom database.postgres_db import dbEngine, Base\nimport database.redis_db as redis\nfrom restful_ressources import import_resources\n# from utils.security import create_admin_user\n\nBase.metadata.create_all(bind=dbEngine)\nredis.init()\n\napp = FastAPI(\n        docs_url=\"/\",\n        title=APP_TITLE,\n        version=APP_VERSION,\n        description=APP_DESCRIPTION,\n    )\n\nif APP_ENV == 'local':\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n# create_admin_user()\n\nimport_resources(app)"}
{"type": "source_file", "path": "src/database/postgres_db.py", "content": "import os\nfrom utils.common import get_env_int\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\nfrom sqlalchemy.pool import QueuePool\n\npostgres_db_name = os.getenv(\"POSTGRES_DB\")\npostgres_user = os.getenv(\"POSTGRES_USER\")\npostgres_password = os.getenv(\"POSTGRES_PASSWORD\")\npostgres_port = os.getenv(\"POSTGRES_PORT\")\npostgres_host = os.getenv(\"POSTGRES_HOST\")\npostgres_pool_size = get_env_int(\"POSTGRES_SIZE_POOL\", 30)\npostgres_max_overflow = get_env_int(\"POSTGRES_MAX_OVERFLOW\", 10)\npostgres_pool_timeout = get_env_int(\"POSTGRES_POOL_TIMEOUT\", 30)\npostgres_pool_recycle = get_env_int(\"POSTGRES_POOL_RECYCLE\", 1800)\n\nPOSTGRES_URL = f\"postgresql://{postgres_user}:{postgres_password}@{postgres_host}:{postgres_port}/{postgres_db_name}\"\n\ndbEngine = create_engine(\n    POSTGRES_URL,\n    echo=False,\n    poolclass=QueuePool,\n    pool_size=postgres_pool_size,\n    max_overflow=postgres_max_overflow,\n    pool_timeout=postgres_pool_timeout,\n    pool_recycle=postgres_pool_recycle,\n    pool_pre_ping=True\n)\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=dbEngine)\n\nBase = declarative_base()\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    except Exception as e:\n        print(f\"Database error occurred: {e}\")\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "src/constants/__init__.py", "content": ""}
{"type": "source_file", "path": "src/constants/regex.py", "content": "email_regex = r\"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)\"\npassword_regex = r\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$\" # nosec"}
{"type": "source_file", "path": "src/controllers/oidc/google.py", "content": "import requests\nfrom google.auth.transport import requests as google_requests\nfrom google.oauth2 import id_token\nfrom models.User import User\nfrom utils.oidc import update_oidc_info\nfrom constants.environment_variables import (\n    OIDC_GOOGLE_CLIENT_ID,\n    OIDC_GOOGLE_CLIENT_SECRET,\n    OIDC_GOOGLE_REDIRECT_URI,\n    GOOGLE_TOKEN_URL,\n    GOOGLE_USER_INFO_URL,\n    HTTP_REQUEST_TIMEOUT\n)\n\ndef get_user_infos_from_google_token_url(code):\n    token_data = {\n        \"code\": code,\n        \"client_id\": OIDC_GOOGLE_CLIENT_ID,\n        \"client_secret\": OIDC_GOOGLE_CLIENT_SECRET,\n        \"redirect_uri\": OIDC_GOOGLE_REDIRECT_URI,\n        \"grant_type\": \"authorization_code\",\n    }\n\n    token_response = requests.post(GOOGLE_TOKEN_URL, data=token_data, timeout=HTTP_REQUEST_TIMEOUT)\n    access_token = token_response.json().get(\"access_token\")\n    \n    user_infos_response = requests.get(GOOGLE_USER_INFO_URL, headers={\"Authorization\": f\"Bearer {access_token}\"}, timeout=HTTP_REQUEST_TIMEOUT)\n    user_infos = user_infos_response.json()\n\n    if not user_infos:\n        return {\n            \"status\": False,\n            \"user_infos\": user_infos\n        }\n    \n    return {\n        \"status\": True,\n        \"user_infos\": user_infos\n    }\n\ndef get_user_infos_from_google_token(id_token_str):\n    id_info = id_token.verify_oauth2_token(id_token_str, google_requests.Request(), OIDC_GOOGLE_CLIENT_ID)\n    user_id = id_info['sub']\n    email = id_info.get('email')\n    \n    user_infos = {\n        'id': user_id,\n        'email': email,\n    }\n    \n    if not user_infos:\n        return {\n            \"status\": False,\n            \"user_infos\": user_infos\n        }\n    \n    return {\n        \"status\": True,\n        \"user_infos\": user_infos\n    }\n\n\ndef create_user(user_infos, db):\n    user_exists = db.query(User).filter(User.email == user_infos['email']).first()\n\n    if user_exists:\n        got_updated = update_oidc_info(\n            user_exists.id,\n            'google',\n            user_infos['id'],\n            user_infos['email'],\n            db\n        )\n        if got_updated is False:\n            return {\n                \"status\": False,\n                \"message\": \"Failed to update user\"\n            }\n\n        return {\n            \"status\": True,\n            \"user\": user_exists\n        }\n\n    new_user = User(\n        email=user_infos['email'],\n        oidc_configs=[{\n            \"provider\": \"google\",\n            \"id\": user_infos['id'],\n            \"email\": user_infos['email']\n        }]\n    )\n    new_user.save(db)\n    return {\n        \"status\": True,\n        \"user\": new_user\n    }\n"}
{"type": "source_file", "path": "src/database/redis_db.py", "content": "import redis\n\nfrom constants.environment_variables import REDIS_HOST, REDIS_PORT\n\nredis_connect = redis.Redis(host=REDIS_HOST, port=REDIS_PORT)\n\ndef init():\n    global redis_client\n    redis_client = redis_connect"}
{"type": "source_file", "path": "src/constants/environment_variables.py", "content": "import os\n\nLISTEN_ADDR = os.environ['LISTEN_ADDR']\nLISTEN_PORT = os.environ['LISTEN_PORT']\nAPP_VERSION = os.environ['APP_VERSION']\nAPP_TITLE = os.environ['APP_TITLE']\nAPP_DESCRIPTION = os.environ['APP_DESCRIPTION']\nv = os.environ['API_VERSION']\nAPP_ENV = os.getenv('APP_ENV')\nAPI_URL = os.getenv('API_URL')\nPOSTGRES_DB = os.getenv('POSTGRES_DB')\nPOSTGRES_USER = os.getenv('POSTGRES_USER')\nPOSTGRES_PASSWORD = os.getenv('POSTGRES_PASSWORD')\nPOSTGRES_PORT = os.getenv('POSTGRES_PORT')\nPOSTGRES_HOST = os.getenv('POSTGRES_HOST')\nREDIS_HOST = os.getenv('REDIS_HOST')\nREDIS_PORT = os.getenv('REDIS_PORT')\nADMIN_USERNAME = os.getenv('ADMIN_USERNAME')\nADMIN_EMAIL = os.getenv('ADMIN_EMAIL')\nADMIN_PASSWORD = os.getenv('ADMIN_PASSWORD')\nJWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')\nJWT_ALGORITHM = os.getenv('JWT_ALGORITHM')\nACCESS_TOKEN_EXPIRE_MINUTES = os.getenv('ACCESS_TOKEN_EXPIRE_MINUTES')\nHTTP_REQUEST_TIMEOUT = os.getenv('HTTP_REQUEST_TIMEOUT') \nGOOGLE_AUTH_URL = os.getenv('GOOGLE_AUTH_URL')\nGOOGLE_TOKEN_URL = os.getenv('GOOGLE_TOKEN_URL')\nGOOGLE_USER_INFO_URL = os.getenv('GOOGLE_USER_INFO_URL')\nOIDC_GOOGLE_CLIENT_ID = os.getenv('OIDC_GOOGLE_CLIENT_ID')\nOIDC_GOOGLE_CLIENT_SECRET = os.getenv('OIDC_GOOGLE_CLIENT_SECRET')\nOIDC_GOOGLE_REDIRECT_URI = f\"{API_URL}/{v}/auth/google\""}
{"type": "source_file", "path": "src/middleware/auth_guard.py", "content": "from datetime import timedelta\nfrom typing import Annotated\nfrom constants.environment_variables import ACCESS_TOKEN_EXPIRE_MINUTES, JWT_ALGORITHM, JWT_SECRET_KEY, v\nfrom models.User import User\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends, HTTPException, status\nfrom database.postgres_db import get_db\nimport os\nfrom jose import JWTError, jwt\nfrom fastapi import Depends, HTTPException, status, APIRouter\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n\nfrom schemas.Token import TokenData, Token\nfrom schemas.User import UserRegisterSchema\nfrom utils.security import create_access_token, verify_password\n\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=f'/{v}/token')\nrouter = APIRouter(include_in_schema=False)\n\n@router.post(\"/token\", response_model=Token)\ndef login_for_access_token(form_data: Annotated[OAuth2PasswordRequestForm, Depends()], db: Session = Depends(get_db)):\n    user_name_or_email = form_data.username\n    if '@' in user_name_or_email:\n        user = db.query(User).filter(User.email == form_data.username).first()\n    else:\n        user = db.query(User).filter(User.username == form_data.username).first()\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Invalid credentials\")\n    if not verify_password(form_data.password, user.password):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Incorrect password\")\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    access_token_expires = timedelta(minutes=int(ACCESS_TOKEN_EXPIRE_MINUTES))\n    access_token = create_access_token(\n        data={\"sub\": user.email}, expires_delta=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\nasync def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])\n        email: str = payload.get(\"sub\")\n        if email is None:\n            raise credentials_exception\n        token_data = TokenData(email=email)\n    except JWTError:\n        raise credentials_exception\n    user = db.query(User).filter(User.email == token_data.email).first()\n    if user is None:\n        raise credentials_exception\n    return user\n\nasync def get_current_active_user(current_user: UserRegisterSchema = Depends(get_current_user)):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n\nasync def get_current_admin_user(current_user: UserRegisterSchema = Depends(get_current_user)):\n    if current_user.is_admin is False:\n        raise HTTPException(status_code=400, detail=\"User is not admin\")\n    return current_user"}
{"type": "source_file", "path": "src/routes/health.py", "content": "from fastapi import APIRouter\n\nrouter = APIRouter()\n\n@router.get(\"/health\")\ndef get_health():\n    return {\n        'status': 'ok',\n        'alive': True\n    }\n"}
{"type": "source_file", "path": "src/routes/oidc/google.py", "content": "from sqlalchemy.orm import Session\nfrom datetime import timedelta\nfrom fastapi import Depends, APIRouter, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom utils.security import create_access_token\nfrom database.postgres_db import get_db\nfrom jose import jwt\nfrom models.User import User\nfrom controllers.oidc.google import get_user_infos_from_google_token_url, get_user_infos_from_google_token, create_user\nfrom constants.environment_variables import (\n    ACCESS_TOKEN_EXPIRE_MINUTES,\n    OIDC_GOOGLE_CLIENT_ID,\n    OIDC_GOOGLE_CLIENT_SECRET,\n    OIDC_GOOGLE_REDIRECT_URI,\n    GOOGLE_AUTH_URL,\n)\n\nrouter = APIRouter()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n@router.get(\"/google/login\")\nasync def login_google():\n    params = {\n        \"response_type\": \"code\",\n        \"client_id\": OIDC_GOOGLE_CLIENT_ID,\n        \"redirect_uri\": OIDC_GOOGLE_REDIRECT_URI,\n        \"scope\": \"openid email profile\",\n        \"access_type\": \"offline\",\n        \"prompt\": \"consent\",\n    }\n\n    query_string = \"&\".join(f\"{key}={value}\" for key, value in params.items())\n    authorization_url = f\"{GOOGLE_AUTH_URL}?{query_string}\"\n    \n    return {\"url\": authorization_url}\n\n@router.get(\"/google\")\nasync def auth_google(code: str = None, credential: str = None, db: Session = Depends(get_db)):\n    if code:\n        check = get_user_infos_from_google_token_url(code)\n        if check['status'] is False:\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Invalid code\")\n        \n        user_infos = check['user_infos']\n    elif credential:\n        check = get_user_infos_from_google_token(credential)\n        if check['status'] is False:\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Invalid credential\")\n        \n        user_infos = check['user_infos']\n    else:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Neither code nor credential provided.\")\n\n    user = db.query(User).filter(User.oidc_configs.contains([{ \"provider\": \"google\", \"id\": user_infos['id'] }])).first()\n\n    if not user:\n        check = create_user(user_infos, db)\n        if check['status'] is False:\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=check[\"message\"])\n        user = check['user']\n        \n\n    access_token_expires = timedelta(minutes=int(ACCESS_TOKEN_EXPIRE_MINUTES))\n    access_token = create_access_token(data={\"sub\": user.email}, expires_delta=access_token_expires)\n\n    return { \"token\": access_token }\n\n@router.get(\"/google/token\")\nasync def get_google_token(token: str = Depends(oauth2_scheme)):\n    return jwt.decode(token, OIDC_GOOGLE_CLIENT_SECRET, algorithms=[\"HS256\"])\n"}
{"type": "source_file", "path": "src/restful_ressources.py", "content": "from routes import health\nimport middleware.auth_guard as auth_guard\nfrom routes.user import user\nfrom routes.admin import user as admin_user\nfrom routes.oidc import google\nfrom constants.environment_variables import v\n\ndef import_resources(app):\n    app.include_router(health.router, tags=['Information'], prefix=f'/{v}')\n    app.include_router(auth_guard.router, tags=['Access Token'], prefix=f'/{v}')\n    app.include_router(google.router, tags=['OIDC'], prefix=f'/{v}/oidc')\n    app.include_router(admin_user.router, tags=['Admin'], prefix=f'/{v}/admin/user')\n    app.include_router(user.router, tags=['User'], prefix=f'/{v}/user')"}
{"type": "source_file", "path": "src/routes/admin/user.py", "content": "from typing import Annotated\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends, status, APIRouter\nfrom controllers.admin.user import add_user, delete_user, update_user\nfrom database.postgres_db import get_db\nfrom middleware.auth_guard import get_current_admin_user\nfrom models.User import User\nfrom schemas.User import UserSchema, UserAdminRegisterSchema, UserAdminUpdateSchema\nfrom utils.filter import remove_password_from_users, remove_password_from_user\n\nrouter = APIRouter()\n\n@router.get(\"/all\", status_code=status.HTTP_200_OK)\ndef get_all_users(current_user: Annotated[UserSchema, Depends(get_current_admin_user)], db: Session = Depends(get_db)):\n    users = db.query(User).all()\n    return remove_password_from_users(users)\n\n@router.get(\"/{user_id}\", status_code=status.HTTP_200_OK)\ndef get_user_by_id(current_user: Annotated[UserSchema, Depends(get_current_admin_user)], user_id: str, db: Session = Depends(get_db)):\n    user = db.query(User).filter(User.id == user_id).first()\n    return remove_password_from_user(user)\n\n@router.post(\"/register\", status_code=status.HTTP_201_CREATED)\ndef register_user(current_user: Annotated[UserSchema, Depends(get_current_admin_user)], payload: UserAdminRegisterSchema, db: Session = Depends(get_db)):\n    return add_user(payload, db)\n\n@router.patch(\"/{user_id}\", status_code=status.HTTP_200_OK)\ndef update_user_by_id(current_user: Annotated[UserSchema, Depends(get_current_admin_user)], user_id: str, payload: UserAdminUpdateSchema, db: Session = Depends(get_db)):\n    return update_user(user_id, payload, db)\n\n@router.delete(\"/{user_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_user_by_id(current_user: Annotated[UserSchema, Depends(get_current_admin_user)], user_id: str, db: Session = Depends(get_db)):\n    return delete_user(user_id, db)"}
{"type": "source_file", "path": "src/utils/filter.py", "content": "def remove_password_from_users(users):\n    user_dicts = []\n    for user in users:\n        user_dict = user.__dict__\n        user_dict.pop('_sa_instance_state', None)\n        user_dict.pop('password', None)\n        user_dicts.append(user_dict)\n    return user_dicts\n\ndef remove_password_from_user(user):\n    user_dict = user.__dict__\n    user_dict.pop('_sa_instance_state', None)\n    user_dict.pop('password', None)\n    return user_dict"}
{"type": "source_file", "path": "src/routes/user/user.py", "content": "from sqlalchemy.orm import Session\nfrom fastapi import Depends, status, APIRouter\nfrom controllers.user.user import register, login, update_user\nfrom database.postgres_db import get_db\nfrom middleware.auth_guard import get_current_active_user\nfrom schemas.User import UserLoginSchema, UserRegisterSchema, UserUpdateSchema\nfrom utils.filter import remove_password_from_user\n\nrouter = APIRouter()\n\n@router.post(\"/register\", status_code=status.HTTP_201_CREATED)\ndef register_user(payload: UserRegisterSchema, db: Session = Depends(get_db)):\n    return register(payload, db)\n\n@router.post(\"/login\", status_code=status.HTTP_200_OK)\ndef login_user(payload: UserLoginSchema, db: Session = Depends(get_db)):\n    return login(payload, db)\n\n@router.get(\"\", status_code=status.HTTP_200_OK)\ndef get_current_user_data(current_user: UserLoginSchema = Depends(get_current_active_user)):\n    return remove_password_from_user(current_user)\n\n@router.patch(\"\", status_code=status.HTTP_200_OK)\ndef update_current_user_data(payload: UserUpdateSchema, current_user: UserLoginSchema = Depends(get_current_active_user), db: Session = Depends(get_db)):\n    return update_user(current_user, payload, db)"}
{"type": "source_file", "path": "src/utils/common.py", "content": "import os\n\ndef get_env_int(var_name, default):\n    value = os.getenv(var_name)\n    return int(value) if value else default\n"}
{"type": "source_file", "path": "src/schemas/Token.py", "content": "from typing import Union\nfrom pydantic import BaseModel\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\nclass TokenData(BaseModel):\n    email: Union[str, None] = None"}
{"type": "source_file", "path": "src/models/User.py", "content": "from database.postgres_db import Base\nfrom sqlalchemy import Column, String, Boolean\nfrom sqlalchemy.dialects.postgresql import JSONB\nfrom fastapi_utils.guid_type import GUID, GUID_SERVER_DEFAULT_POSTGRESQL\n\nclass User(Base):\n    __tablename__ = 'user'\n    id = Column(GUID, primary_key=True, server_default=GUID_SERVER_DEFAULT_POSTGRESQL)\n    username = Column(String, nullable=True, default=\"\")\n    email = Column(String, nullable=False, unique=True)\n    password = Column(String, nullable=False)\n    is_admin = Column(Boolean, nullable=True, default=False)\n    disabled = Column(Boolean, nullable=True, default=False)\n    oidc_configs = Column(JSONB, default=lambda: [], nullable=False)"}
{"type": "source_file", "path": "src/utils/oidc.py", "content": "from sqlalchemy.orm.attributes import flag_modified\nfrom models.User import User\n\ndef update_oidc_info(user_id: int, provider: str, id: str, email: str, db):\n        user = db.query(User).filter(User.id == user_id).first()\n        if not user:\n            return False\n        \n        if not isinstance(user.oidc_configs, list):\n            user.oidc_configs = []\n        \n        #? Remove existing config for this provider if it exists\n        user.oidc_configs = [\n            config for config in user.oidc_configs\n            if not (config.get(\"provider\") == provider and \"id\" in config)\n        ]\n\n        user.oidc_configs.append({\n            \"provider\": provider,\n            \"id\": id,\n            \"email\": email\n        })\n\n        flag_modified(user, \"oidc_configs\")\n        db.commit()\n\n        return True\n"}
{"type": "source_file", "path": "src/utils/variables.py", "content": "def is_empty(value):\n    return value is None or value == \"\"\n\ndef is_not_empty(value):\n    return not is_empty(value)"}
{"type": "source_file", "path": "src/utils/security.py", "content": "import re\nfrom passlib.context import CryptContext\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Union\nfrom jose import jwt\nfrom fastapi import HTTPException, status\nfrom constants.environment_variables import ACCESS_TOKEN_EXPIRE_MINUTES, ADMIN_EMAIL, ADMIN_PASSWORD, ADMIN_USERNAME, JWT_ALGORITHM, JWT_SECRET_KEY\nfrom models.User import User\nfrom database.postgres_db import SessionLocal\nfrom constants.regex import email_regex, password_regex\n\ncrypting_algorithm = \"sha256_crypt\" if JWT_ALGORITHM == \"HS256\" else \"bcrypt\"\n\npwd_context = CryptContext(schemes=[crypting_algorithm], deprecated=\"auto\")\ndb = SessionLocal()\n\ndef create_admin_user():\n    user = db.query(User).filter(User.email == ADMIN_EMAIL).first()\n    if not user:\n        password = get_password_hash(ADMIN_PASSWORD)\n        new_user = User(username=ADMIN_USERNAME, email=ADMIN_EMAIL, password=password, is_admin=True)\n        db.add(new_user)\n        db.commit()\n        db.refresh(new_user)  \n\ndef validate_email(email):\n    if re.search(email_regex, email):\n        return True\n    return False\n\ndef validate_password(password):\n    if re.search(password_regex, password):\n        return True\n    return False\n\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\ndef create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)\n    return encoded_jwt\n\ndef authenticate_user(payload, db):\n    user = db.query(User).filter(User.email == payload.email).first()\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Invalid credentials\")\n    if not verify_password(payload.password, user.password):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Incorrect password\")\n    return user"}
{"type": "source_file", "path": "src/schemas/User.py", "content": "from typing import Optional\nfrom pydantic import BaseModel\n\nclass UserLoginSchema(BaseModel):\n    email: str\n    password: str\n\n    class Config:\n        orm_mode = True\n        allow_population_by_field_name = True\n        arbitrary_types_allowed = True\n\nclass UserSchema(BaseModel):\n    id: int\n    username: Optional[str] = None\n    email: str\n    disabled: Optional[bool] = None\n    is_admin: Optional[bool] = None\n\n    class Config:\n        orm_mode = True\n        allow_population_by_field_name = True\n        arbitrary_types_allowed = True\n        \nclass UserAdminRegisterSchema(BaseModel):\n    username: Optional[str] = None\n    email: str\n    password: str\n    disabled: Optional[bool] = None\n    is_admin: Optional[bool] = None\n\n    class Config:\n        orm_mode = True\n        allow_population_by_field_name = True\n        arbitrary_types_allowed = True\n        \nclass UserAdminUpdateSchema(BaseModel):\n    username: Optional[str] = None\n    email: Optional[str] = None\n    password: Optional[str] = None\n    disabled: Optional[bool] = None\n    is_admin: Optional[bool] = None\n\n    class Config:\n        orm_mode = True\n        allow_population_by_field_name = True\n        arbitrary_types_allowed = True\n\nclass UserRegisterSchema(BaseModel):\n    username: Optional[str] = None\n    email: str\n    password: str\n\n    class Config:\n        orm_mode = True\n        allow_population_by_field_name = True\n        arbitrary_types_allowed = True\n        \nclass UserUpdateSchema(BaseModel):\n    username: Optional[str] = None\n    email: Optional[str] = None\n    password: Optional[str] = None\n\n    class Config:\n        orm_mode = True\n        allow_population_by_field_name = True\n        arbitrary_types_allowed = True"}
{"type": "source_file", "path": "src/controllers/admin/user.py", "content": "from fastapi import HTTPException, status\nfrom models.User import User\nfrom utils.security import get_password_hash\nfrom utils.variables import is_not_empty\n\n\ndef add_user(payload, db):\n    user = db.query(User).filter(User.email == payload.email).first()\n    if user:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Email already registered\")\n    password_entered = payload.password\n    payload.password = get_password_hash(payload.password)\n    new_user = User(**payload.dict())\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    return {\n            \"id\": new_user.id,\n            \"email\": new_user.email,\n            \"password\": password_entered\n        }\n    \ndef update_user(user_id, payload, db):\n    user = db.query(User).filter(User.id == user_id)\n    \n    existing_user = user.first()\n    if not existing_user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found\")\n    \n    updated_user = User(**payload.dict())\n\n    if is_not_empty(updated_user.email) and updated_user.email != existing_user.email:\n        user_exists = db.query(User).filter(User.email == updated_user.email).first()\n        if user_exists:\n            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f\"The email {updated_user.email} already exists\")\n\n    if is_not_empty(updated_user.username) and updated_user.username != existing_user.username:\n        user_exists = db.query(User).filter(User.username == updated_user.username).first()\n        if user_exists:\n            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f\"The username {updated_user.username} already exists\")\n    \n    if payload.username:\n        user.update({\"username\": payload.username})\n    if payload.email:\n        user.update({\"email\": payload.email})\n    if payload.password:\n        user.update({\"password\": get_password_hash(payload.password)})\n    if payload.is_admin is not None:\n        user.update({\"is_admin\": payload.is_admin})\n    if payload.disabled is not None:\n        User.disabled = user.disabled\n        user.update({\"disabled\": payload.disabled})\n        \n    db.commit()\n    db.refresh(existing_user)\n\n    return {\n        \"message\": \"user been updated successfully\"\n    }\n    \ndef delete_user(user_id, db):\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found\")\n    db.delete(user)\n    db.commit()"}

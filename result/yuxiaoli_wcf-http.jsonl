{"repo_info": {"repo_name": "wcf-http", "repo_owner": "yuxiaoli", "repo_url": "https://github.com/yuxiaoli/wcf-http"}}
{"type": "test_file", "path": "tests/test_core_http.py", "content": "import pytest\nimport requests\nimport json\nimport os\nfrom typing import Dict\n\n# 测试配置\nBASE_URL = \"http://localhost:9999\"  # 测试服务器地址\nTEST_ROOM_ID = \"5550027590@chatroom\"  # 测试群ID\nTEST_WXID = \"xxxx\"  # 测试用户ID\nTEST_FILE_PATH = os.path.join(os.path.dirname(__file__), \"test_files\")  # 测试文件目录\n\n# 创建测试文件目录\nos.makedirs(TEST_FILE_PATH, exist_ok=True)\n\nclass TestCoreHttp:\n    \"\"\"WeChatFerry HTTP API 测试类\"\"\"\n    \n    @pytest.fixture(autouse=True)\n    def setup(self):\n        \"\"\"测试前置设置\"\"\"\n        # 确保服务器在运行\n        try:\n            response = requests.get(f\"{BASE_URL}/login\")\n            assert response.status_code == 200\n        except:\n            pytest.skip(\"测试服务器未启动\")\n            \n    def _make_request(self, method: str, endpoint: str, **kwargs) -> Dict:\n        \"\"\"发送HTTP请求并返回JSON响应\"\"\"\n        url = f\"{BASE_URL}/{endpoint.lstrip('/')}\"\n        response = requests.request(method, url, **kwargs)\n        return response.json()\n    \n    # 用户认证相关测试\n    def test_login_status(self):\n        \"\"\"测试获取登录状态\"\"\"\n        response = self._make_request(\"GET\", \"/login\")\n        assert \"status\" in response\n        assert \"message\" in response\n        assert \"data\" in response\n        assert \"login\" in response[\"data\"]\n        \n    def test_get_wxid(self):\n        \"\"\"测试获取当前用户wxid\"\"\"\n        response = self._make_request(\"GET\", \"/wxid\")\n        assert response[\"status\"] == 0\n        assert \"wxid\" in response[\"data\"]\n        \n    def test_get_user_info(self):\n        \"\"\"测试获取用户信息\"\"\"\n        response = self._make_request(\"GET\", \"/user-info\")\n        assert response[\"status\"] == 0\n        assert \"ui\" in response[\"data\"]\n        \n    # 消息相关测试\n    def test_send_text(self):\n        \"\"\"测试发送文本消息\"\"\"\n        data = {\n            \"msg\": \"测试消息\",\n            \"receiver\": \"filehelper\",\n            \"aters\": \"\"\n        }\n        response = self._make_request(\"POST\", \"/text\", json=data)\n        assert response[\"status\"] == 0\n        \n    def test_send_text_with_at(self):\n        \"\"\"测试发送@消息\"\"\"\n        data = {\n            \"msg\": \"测试@消息 @test\",\n            \"receiver\": TEST_ROOM_ID,\n            \"aters\": TEST_WXID\n        }\n        response = self._make_request(\"POST\", \"/text\", json=data)\n        assert response[\"status\"] == 0\n        \n    def test_send_image(self):\n        \"\"\"测试发送图片\"\"\"\n        # 创建测试图片\n        test_image = os.path.join(TEST_FILE_PATH, \"test.png\")\n        with open(test_image, \"wb\") as f:\n            f.write(b\"test image content\")\n            \n        data = {\n            \"path\": test_image,\n            \"receiver\": \"filehelper\"\n        }\n        response = self._make_request(\"POST\", \"/image\", json=data)\n        assert response[\"status\"] == 0\n        \n    def test_send_file(self):\n        \"\"\"测试发送文件\"\"\"\n        # 创建测试文件\n        test_file = os.path.join(TEST_FILE_PATH, \"test.txt\")\n        with open(test_file, \"w\") as f:\n            f.write(\"test file content\")\n            \n        data = {\n            \"path\": test_file,\n            \"receiver\": \"filehelper\"\n        }\n        response = self._make_request(\"POST\", \"/file\", json=data)\n        assert response[\"status\"] == 0\n        \n    # 群聊相关测试\n    def test_get_chatroom_members(self):\n        \"\"\"测试获取群成员\"\"\"\n        response = self._make_request(\"GET\", f\"/chatroom-member?roomid={TEST_ROOM_ID}\")\n        assert response[\"status\"] == 0\n        assert \"members\" in response[\"data\"]\n        \n    def test_add_chatroom_members(self):\n        \"\"\"测试添加群成员\"\"\"\n        data = {\n            \"roomid\": TEST_ROOM_ID,\n            \"wxids\": TEST_WXID\n        }\n        response = self._make_request(\"POST\", \"/chatroom-member\", json=data)\n        assert response[\"status\"] in [0, 1]  # 0或1都表示成功\n        \n    # 通讯录相关测试\n    def test_get_contacts(self):\n        \"\"\"测试获取通讯录\"\"\"\n        response = self._make_request(\"GET\", \"/contacts\")\n        assert response[\"status\"] == 0\n        assert \"contacts\" in response[\"data\"]\n        \n    def test_get_friends(self):\n        \"\"\"测试获取好友列表\"\"\"\n        response = self._make_request(\"GET\", \"/friends\")\n        assert response[\"status\"] == 0\n        assert \"friends\" in response[\"data\"]\n        \n    # 数据库相关测试\n    def test_get_dbs(self):\n        \"\"\"测试获取数据库列表\"\"\"\n        response = self._make_request(\"GET\", \"/dbs\")\n        assert response[\"status\"] == 0\n        assert \"dbs\" in response[\"data\"]\n        \n    def test_get_tables(self):\n        \"\"\"测试获取数据库表\"\"\"\n        # 先获取一个可用的数据库\n        dbs_response = self._make_request(\"GET\", \"/dbs\")\n        if dbs_response[\"data\"][\"dbs\"]:\n            db_name = dbs_response[\"data\"][\"dbs\"][0]\n            response = self._make_request(\"GET\", f\"/{db_name}/tables\")\n            assert response[\"status\"] == 0\n            assert \"tables\" in response[\"data\"]\n            \n    def test_execute_sql(self):\n        \"\"\"测试执行SQL查询\"\"\"\n        data = {\n            \"db\": \"MicroMsg.db\",\n            \"sql\": \"SELECT * FROM sqlite_master LIMIT 1;\"\n        }\n        response = self._make_request(\"POST\", \"/sql\", json=data)\n        assert response[\"status\"] == 0\n        assert \"bs64\" in response[\"data\"]\n        \n    # 其他接口测试\n    def test_get_msg_types(self):\n        \"\"\"测试获取消息类型\"\"\"\n        response = self._make_request(\"GET\", \"/msg-types\")\n        assert response[\"status\"] == 0\n        assert \"types\" in response[\"data\"]\n        \n    def test_callback_url(self):\n        \"\"\"测试回调URL的获取和设置\"\"\"\n        # 测试获取\n        get_response = self._make_request(\"GET\", \"/callback\")\n        assert \"callback\" in get_response\n        \n        # 测试设置\n        set_data = {\"callback\": \"http://test.callback.url\"}\n        set_response = self._make_request(\"POST\", \"/callback\", json=set_data)\n        assert \"callback\" in set_response\n        assert set_response[\"callback\"] == set_data[\"callback\"]\n        \n    @classmethod\n    def teardown_class(cls):\n        \"\"\"测试清理工作\"\"\"\n        # 清理测试文件\n        import shutil\n        if os.path.exists(TEST_FILE_PATH):\n            shutil.rmtree(TEST_FILE_PATH) \n"}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "source_file", "path": "src/wcf_http/preamble.py", "content": "import sys\nsys.argv.append('--systray')\n\nimport os\n# Set console text color to green\nos.system('color 0a')\n"}
{"type": "source_file", "path": "src/wcf_http/main.py", "content": "#! /usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport logging\nimport argparse\nimport os\nimport threading\nimport webbrowser\nimport sys\n\nimport uvicorn\nfrom wcferry import Wcf\n# from wcfhttp import Http, __version__\nfrom wcf_http.core import Http, __version__\n\ndef main():\n\tparse = argparse.ArgumentParser()\n\tparse.add_argument(\"-v\", \"--version\", action=\"version\", version=f\"{__version__}\")\n\tparse.add_argument(\"--wcf_host\", type=str, default=None, help=\"WeChatFerry 监听地址，默认本地启动监听 0.0.0.0\")\n\tparse.add_argument(\"--wcf_port\", type=int, default=10086, help=\"WeChatFerry 监听端口 (同时占用 port + 1 端口)，默认 10086\")\n\tparse.add_argument(\"--wcf_debug\", type=bool, default=True, help=\"是否打开 WeChatFerry 调试开关\")\n\tparse.add_argument(\"--host\", type=str, default=\"0.0.0.0\", help=\"wcfhttp 监听地址，默认监听 0.0.0.0\")\n\tparse.add_argument(\"--port\", type=int, default=9999, help=\"wcfhttp 监听端口，默认 9999\")\n\tparse.add_argument(\"--cb\", type=str, default=\"\", help=\"接收消息回调地址\")\n\tparse.add_argument(\"--systray\", action=\"store_true\", help=\"enable system tray icon\")  # Added tray option\n\n\tlogging.basicConfig(level=\"INFO\", format=\"%(asctime)s %(message)s\")\n\targs = parse.parse_args()\n\tcb = args.cb\n\turl = f\"http://{args.host.replace('0.0.0.0', '127.0.0.1')}:{args.port}/docs\"\n\tif not cb:\n\t\t# logging.warning(\"没有设置接收消息回调，消息直接通过日志打印；请通过 --cb 设置消息回调\")\n\t\tlogging.warning(\"没有设置接收消息回调，消息直接通过日志打印；请通过 --cb 或 POST Callback API 设置消息回调\")\n\t\tlogging.warning(f\"回调接口规范参考接收消息回调样例：{url}\")\n\t# self.LOG.info(f\"Server is running at {url}\")\n\tprint(f\"Server is running at {url}\")\n\n\t# Create the log directory as a quick fix for https://github.com/lich0821/WeChatRobot/issues/70\n\t# Fixed in https://github.com/lich0821/WeChatFerry/commit/19079bc468fe6681a65887a42a9215a9ec7392d1\n\tlog_dir = os.path.join(os.getcwd(), 'logs')\n\tos.makedirs(log_dir, exist_ok=True)\n\n\twcf = Wcf(args.wcf_host, args.wcf_port, args.wcf_debug)\n\t# home = \"https://github.com/lich0821/WeChatFerry\"\n\tgithub = \"https://github.com/yuxiaoli/wcf-http\"\n\tpypi = \"https://pypi.org/project/wcf-http-server/\"\n\tqrcodes = \"\"\"<table>\n<thead>\n<tr>\n<!-- <th style=\"text-align:center\"><img src=\"https://s2.loli.net/2023/09/25/fub5VAPSa8srwyM.jpg\" alt=\"碲矿\"></th> -->\n<!-- <th style=\"text-align:center\"><img src=\"https://s2.loli.net/2023/09/25/gkh9uWZVOxzNPAX.jpg\" alt=\"赞赏\"></th> -->\n<th style=\"text-align:center\"><img src=\"https://api.codetabs.com/v1/proxy/?quest=https://mmbiz.qpic.cn/sz_mmbiz_png/NqSD0p9cbmiauQkiaVZOgmxF2KVTVMsxExocdAscXfqUKSicbBy6kPyQDToeCPwUbqgrSBWr5l8TnaxIwDgwBW7JA/640?wx_fmt=png&from=appmsg\" alt=\"图灵信使\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">\n后台回复 <code>wcf-http</code> 加群交流\n<!-- <br />如果你觉得有用 -->\n</td>\n</tbody>\n</table>\"\"\"\n\thttp = Http(wcf=wcf,\n\t\t\t\tcb=cb,\n\t\t\t\thost=args.host.replace('0.0.0.0', '127.0.0.1'),\n\t\t\t\tport=args.port,\n\t\t\t\ttitle=\"WeChatFerry HTTP 客户端\",\n\t\t\t\tdescription=f\"GitHub: <a href='{github}'>wcf-http</a> | PyPI: <a href='{pypi}'>wcf-http-server</a>{qrcodes}\",)\n\n\tif args.systray:\n\t\t# Attempt to import pystray and other necessary modules\n\t\ttry:\n\t\t\t# Import necessary modules for the tray icon\n\t\t\timport pystray\n\t\t\tfrom pystray import MenuItem as item\n\t\t\tfrom PIL import Image#, ImageDraw\n\t\texcept ImportError:\n\t\t\tlogging.warning(\"pystray or PIL is not installed. Running server without tray icon.\")\n\t\t\t# Run uvicorn server normally\n\t\t\tuvicorn.run(app=http, host=args.host, port=args.port)\n\t\t\treturn\n\n\t\t# Function to create an icon image\n\t\tdef create_image():\n\t\t\t# Get the absolute path of the current file's directory\n\t\t\tcurrent_dir = os.path.dirname(os.path.abspath(__file__))\n\t\t\treturn Image.open(os.path.join(current_dir, \"assets\", \"images\", 'wcf-http.png'))\n\n\t\t# Global variable to control the server\n\t\tglobal uvicorn_server\n\t\tuvicorn_server = None\n\t\texit_event = threading.Event()\n\n\t\t# Function to run uvicorn server\n\t\tdef run_uvicorn():\n\t\t\tglobal uvicorn_server\n\t\t\tconfig = uvicorn.Config(app=http, host=args.host, port=args.port)\n\t\t\tuvicorn_server = uvicorn.Server(config)\n\t\t\tuvicorn_server.run()\n\n\t\t# Start uvicorn server in a separate thread\n\t\tserver_thread = threading.Thread(target=run_uvicorn)\n\t\tserver_thread.start()\n\n\t\t# Function to open the documentation webpage\n\t\tdef on_open(icon, item):\n\t\t\twebbrowser.open(url)\n\n\t\t# Function to exit the application\n\t\tdef on_exit(icon, item):\n\t\t\t# Stop the uvicorn server\n\t\t\tif uvicorn_server is not None:\n\t\t\t\tuvicorn_server.should_exit = True\n\t\t\t# Stop the tray icon\n\t\t\ticon.stop()\n\t\t\t# Signal the main thread to exit\n\t\t\texit_event.set()\n\n\t\t# Create the tray icon and menu\n\t\ticon_image = create_image()\n\t\tmenu = pystray.Menu(\n\t\t\titem('Open API Docs', on_open),\n\t\t\titem('Exit', on_exit)\n\t\t)\n\t\ticon = pystray.Icon(\"WeChatFerry\", icon_image, \"WeChatFerry\", menu)\n\n\t\t# Run the tray icon in a separate thread to avoid blocking\n\t\tdef run_tray_icon():\n\t\t\ticon.run()\n\n\t\ttray_thread = threading.Thread(target=run_tray_icon)\n\t\ttray_thread.start()\n\n\t\t# Wait for the exit event\n\t\ttry:\n\t\t\texit_event.wait()\n\t\texcept KeyboardInterrupt:\n\t\t\tpass\n\t\tfinally:\n\t\t\t# Ensure that the server and tray icon are stopped\n\t\t\tif uvicorn_server is not None:\n\t\t\t\tuvicorn_server.should_exit = True\n\t\t\tif icon is not None:\n\t\t\t\ticon.stop()\n\t\t\t# Wait for threads to finish\n\t\t\tserver_thread.join()\n\t\t\ttray_thread.join()\n\n\telse:\n\t\t# Run uvicorn server normally\n\t\tuvicorn.run(app=http, host=args.host, port=args.port)\n\n\nif __name__ == \"__main__\":\n\tmain()\n"}
{"type": "source_file", "path": "src/wcf_http/__init__.py", "content": ""}
{"type": "source_file", "path": "src/wcf_http/core.py", "content": "#! /usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport base64\nimport logging\nfrom queue import Empty\nfrom threading import Thread\nfrom typing import Any\n\nimport requests\nfrom fastapi import Body, FastAPI, Query\nfrom pydantic import BaseModel\nfrom wcferry import Wcf, WxMsg\n\n__version__ = \"39.2.4.0\"\n\n\nclass Msg(BaseModel):\n\tid: int\n\tts: int\n\tsign: str\n\ttype: int\n\txml: str\n\tsender: str\n\troomid: str\n\tcontent: str\n\tthumb: str\n\textra: str\n\tis_at: bool\n\tis_self: bool\n\tis_group: bool\n\n\nclass Http(FastAPI):\n\t\"\"\"WeChatFerry HTTP 客户端，文档地址：http://IP:PORT/docs\"\"\"\n\n\tdef __init__(\n\t\tself, \n\t\twcf: Wcf, \n\t\tcb: str, \n\t\t**extra: Any\n\t) -> None:\n\t\tsuper().__init__(**extra)\n\t\tself.LOG = logging.getLogger(__name__)\n\t\tself.LOG.info(f\"wcfhttp version: {__version__}\")\n\t\tself.wcf = wcf\n\t\tself.cb = cb  # Store the callback URL\n\t\tself._set_cb(cb)\n\n\t\t# GET Routes\n\t\tself.add_api_route(\"/login\", self.is_login, methods=[\"GET\"], summary=\"获取登录状态\")\n\t\tself.add_api_route(\"/wxid\", self.get_self_wxid, methods=[\"GET\"], summary=\"获取登录账号 wxid\")\n\t\tself.add_api_route(\"/user-info\", self.get_user_info, methods=[\"GET\"], summary=\"获取登录账号个人信息\")\n\t\tself.add_api_route(\"/msg-types\", self.get_msg_types, methods=[\"GET\"], summary=\"获取消息类型\")\n\t\tself.add_api_route(\"/contacts\", self.get_contacts, methods=[\"GET\"], summary=\"获取完整通讯录\")\n\t\tself.add_api_route(\"/friends\", self.get_friends, methods=[\"GET\"], summary=\"获取好友列表\")\n\t\tself.add_api_route(\"/dbs\", self.get_dbs, methods=[\"GET\"], summary=\"获取所有数据库\")\n\t\tself.add_api_route(\"/{db}/tables\", self.get_tables, methods=[\"GET\"], summary=\"获取 db 中所有表\")\n\t\tself.add_api_route(\"/pyq\", self.refresh_pyq, methods=[\"GET\"], summary=\"刷新朋友圈（数据从消息回调中查看）\")\n\t\tself.add_api_route(\"/chatroom-member\", self.get_chatroom_members, methods=[\"GET\"], summary=\"获取群成员\")\n\t\tself.add_api_route(\"/alias-in-chatroom\", self.get_alias_in_chatroom, methods=[\"GET\"], summary=\"获取群成员名片\")\n\t\tself.add_api_route(\"/ocr-result\", self.get_ocr_result, methods=[\"GET\"], summary=\"获取 OCR 结果\")\n\n\t\t# POST Routes\n\t\tself.add_api_route(\"/msg_cb\", self.msg_cb, methods=[\"POST\"], summary=\"接收消息回调样例\", tags=[\"示例\"])\n\t\tself.add_api_route(\"/text\", self.send_text, methods=[\"POST\"], summary=\"发送文本消息\")\n\t\tself.add_api_route(\"/image\", self.send_image, methods=[\"POST\"], summary=\"发送图片消息\")\n\t\tself.add_api_route(\"/file\", self.send_file, methods=[\"POST\"], summary=\"发送文件消息\")\n\t\tself.add_api_route(\"/rich-text\", self.send_rich_text, methods=[\"POST\"], summary=\"发送卡片消息\")\n\t\tself.add_api_route(\"/pat\", self.send_pat_msg, methods=[\"POST\"], summary=\"发送拍一拍消息\")\n\t\t# Deprecated or unimplemented APIs are commented out\n\t\t# self.add_api_route(\"/xml\", self.send_xml, methods=[\"POST\"], summary=\"发送 XML 消息\")\n\t\t# self.add_api_route(\"/emotion\", self.send_emotion, methods=[\"POST\"], summary=\"发送表情消息\")\n\t\tself.add_api_route(\"/sql\", self.query_sql, methods=[\"POST\"], summary=\"执行 SQL，如果数据量大注意分页，以免 OOM\")\n\t\tself.add_api_route(\"/new-friend\", self.accept_new_friend, methods=[\"POST\"], summary=\"通过好友申请\")\n\t\tself.add_api_route(\"/chatroom-member\", self.add_chatroom_members, methods=[\"POST\"], summary=\"添加群成员\")\n\t\tself.add_api_route(\"/cr-members\", self.invite_chatroom_members, methods=[\"POST\"], summary=\"邀请群成员\")\n\t\t# self.add_api_route(\"/transfer\", self.receive_transfer, methods=[\"POST\"], summary=\"接收转账\")\n\t\t# self.add_api_route(\"/dec-image\", self.decrypt_image, methods=[\"POST\"], summary=\"（废弃）解密图片\")\n\t\tself.add_api_route(\"/attachment\", self.download_attachment, methods=[\"POST\"], summary=\"（废弃）下载图片、文件和视频\")\n\t\tself.add_api_route(\"/save-image\", self.download_image, methods=[\"POST\"], summary=\"下载图片\")\n\t\tself.add_api_route(\"/save-audio\", self.get_audio_msg, methods=[\"POST\"], summary=\"保存语音\")\n\n\t\t# DELETE Routes\n\t\tself.add_api_route(\"/chatroom-member\", self.del_chatroom_members, methods=[\"DELETE\"], summary=\"删除群成员\")\n\n\t\t# Add routes for dynamic callback URL handling\n\t\tself.add_api_route(\"/callback\", self.get_callback, methods=[\"GET\"], summary=\"Get the callback URL\", tags=[\"Callback\"])\n\t\tself.add_api_route(\"/callback\", self.set_callback, methods=[\"POST\"], summary=\"Set the callback URL\", tags=[\"Callback\"])\n\n\tdef _forward_msg(self, msg: WxMsg):\n\t\tif not self.cb:\n\t\t\tself.LOG.error(\"No callback URL set\")\n\t\t\treturn\n\t\tdata = {\n\t\t\t\"id\": msg.id,\n\t\t\t\"ts\": msg.ts,\n\t\t\t\"sign\": msg.sign,\n\t\t\t\"type\": msg.type,\n\t\t\t\"xml\": msg.xml,\n\t\t\t\"sender\": msg.sender,\n\t\t\t\"roomid\": msg.roomid,\n\t\t\t\"content\": msg.content,\n\t\t\t\"thumb\": msg.thumb,\n\t\t\t\"extra\": msg.extra,\n\t\t\t\"is_at\": msg.is_at(self.wcf.self_wxid),\n\t\t\t\"is_self\": msg.from_self(),\n\t\t\t\"is_group\": msg.from_group(),\n\t\t}\n\n\t\ttry:\n\t\t\trsp = requests.post(url=self.cb, json=data, timeout=30)\n\t\t\tif rsp.status_code != 200:\n\t\t\t\tself.LOG.error(f\"消息转发失败，HTTP 状态码为: {rsp.status_code}\")\n\t\texcept Exception as e:\n\t\t\tself.LOG.error(f\"消息转发异常: {e}\")\n\n\tdef _set_cb(self, cb: str):\n\t\tself.cb = cb\n\t\tself.LOG.info(f\"消息回调: {cb}\" if cb else \"没有设置回调，打印消息\")\n\t\tself.wcf.enable_receiving_msg(pyq=True)  # 同时允许接收朋友圈消息\n\n\t\t# Start the message receiving thread only if not already started\n\t\tif not hasattr(self, '_message_thread'):\n\t\t\tdef callback(wcf: Wcf):\n\t\t\t\twhile wcf.is_receiving_msg():\n\t\t\t\t\ttry:\n\t\t\t\t\t\tmsg = wcf.get_msg()\n\t\t\t\t\t\tif self.cb:\n\t\t\t\t\t\t\tself.LOG.info(f\"收到消息，转发至回调：{msg}\")\n\t\t\t\t\t\t\tself._forward_msg(msg)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tprint(f\"收到消息：{msg}\")\n\t\t\t\t\texcept Empty:\n\t\t\t\t\t\tcontinue  # Empty message\n\t\t\t\t\texcept Exception as e:\n\t\t\t\t\t\tself.LOG.error(f\"Receiving message error: {e}\")\n\t\t\tself._message_thread = Thread(target=callback, name=\"GetMessage\", args=(self.wcf,), daemon=True)\n\t\t\tself._message_thread.start()\n\n\tdef get_callback(self):\n\t\t\"\"\"Get the current callback URL.\"\"\"\n\t\treturn {\"callback\": self.cb}\n\n\tdef set_callback(self, callback: str = Body(..., embed=True)):\n\t\t\"\"\"Set a new callback URL.\"\"\"\n\t\tself._set_cb(callback)\n\t\treturn {\"message\": \"Callback URL updated successfully\", \"callback\": self.cb}\n\n\tdef is_login(self) -> dict:\n\t\t\"\"\"获取登录状态\"\"\"\n\t\tret = self.wcf.is_login()\n\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"login\": ret}}\n\n\tdef get_self_wxid(self) -> dict:\n\t\t\"\"\"获取登录账号 wxid\"\"\"\n\t\tret = self.wcf.get_self_wxid()\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"wxid\": ret}}\n\t\treturn {\"status\": -1, \"message\": \"失败\"}\n\n\tdef get_msg_types(self) -> dict:\n\t\t\"\"\"获取消息类型\"\"\"\n\t\tret = self.wcf.get_msg_types()\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"types\": ret}}\n\t\treturn {\"status\": -1, \"message\": \"失败\"}\n\n\tdef get_contacts(self) -> dict:\n\t\t\"\"\"获取完整通讯录\"\"\"\n\t\tret = self.wcf.get_contacts()\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"contacts\": ret}}\n\t\treturn {\"status\": -1, \"message\": \"失败\"}\n\n\tdef get_friends(self) -> dict:\n\t\t\"\"\"获取好友列表\"\"\"\n\t\tret = self.wcf.get_friends()\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"friends\": ret}}\n\t\treturn {\"status\": -1, \"message\": \"失败\"}\n\n\tdef get_dbs(self) -> dict:\n\t\t\"\"\"获取所有数据库\"\"\"\n\t\tret = self.wcf.get_dbs()\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"dbs\": ret}}\n\t\treturn {\"status\": -1, \"message\": \"失败\"}\n\n\tdef get_tables(self, db: str) -> dict:\n\t\t\"\"\"获取 db 中所有表\n\n\t\tArgs:\n\t\t\tdb (str): 数据库名（可通过 `get_dbs` 查询）\n\n\t\tReturns:\n\t\t\tList[dict]: `db` 下的所有表名及对应建表语句\n\t\t\"\"\"\n\t\tret = self.wcf.get_tables(db)\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"tables\": ret}}\n\t\treturn {\"status\": -1, \"message\": \"失败\"}\n\n\tdef get_user_info(self) -> dict:\n\t\t\"\"\"获取登录账号个人信息\"\"\"\n\t\tret = self.wcf.get_user_info()\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"ui\": ret}}\n\t\treturn {\"status\": -1, \"message\": \"失败\"}\n\n\tdef get_ocr_result(self, extra: str = Body(\"C:/...\", description=\"消息中的 extra\"),\n\t\t\t\t\t   timeout: int = Body(\"30\", description=\"超时时间（秒）\")) -> dict:\n\t\t\"\"\"获取 OCR 结果\n\n\t\tArgs:\n\t\t\textra (str): 待识别的图片路径，消息里的 extra\n\t\t\ttimeout (int): 超时时间（秒）\n\n\t\tReturns:\n\t\t\tstr: OCR 结果\n\t\t\"\"\"\n\t\tret = self.wcf.get_ocr_result(extra, timeout)\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"ocr\": ret}}\n\t\treturn {\"status\": -1, \"message\": \"可能失败，可以看看日志。这接口没啥用，别用了。\"}\n\n\tdef msg_cb(self, msg: Msg = Body(description=\"微信消息\")):\n\t\t\"\"\"示例回调方法，简单打印消息\"\"\"\n\t\tprint(f\"收到消息：{msg}\")\n\t\treturn {\"status\": 0, \"message\": \"成功\"}\n\n\tdef send_text(\n\t\t\tself, msg: str = Body(description=\"要发送的消息，换行用\\\\n表示\"),\n\t\t\treceiver: str = Body(\"filehelper\", description=\"消息接收者，roomid 或者 wxid\"),\n\t\t\taters: str = Body(\"\", description=\"要 @ 的 wxid，多个用逗号分隔；@所有人 用 notify@all\")) -> dict:\n\t\t\"\"\"发送文本消息\n\n\t\tArgs:\n\t\t\tmsg (str): 要发送的消息，换行使用 `\\\\n`；如果 @ 人的话，需要带上跟 `aters` 里数量相同的 @\n\t\t\treceiver (str): 消息接收人，wxid 或者 roomid\n\t\t\taters (str): 要 @ 的 wxid，多个用逗号分隔；`@所有人` 只需要 `notify@all`\n\n\t\tReturns:\n\t\t\tdict: 包含发送结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.send_text(msg, receiver, aters)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 0 else \"失败\"}\n\n\tdef send_image(self,\n\t\t\t\t   path: str = Body(\"C:\\\\Projs\\\\WeChatRobot\\\\TEQuant.jpeg\", description=\"图片路径\"),\n\t\t\t\t   receiver: str = Body(\"filehelper\", description=\"消息接收者，roomid 或者 wxid\")) -> dict:\n\t\t\"\"\"发送图片\n\n\t\tArgs:\n\t\t\tpath (str): 图片路径，如：`C:/Projs/WeChatRobot/TEQuant.jpeg` 或网络图片 URL（仅本地模式支持）\n\t\t\treceiver (str): 消息接收人，wxid 或者 roomid\n\n\t\tReturns:\n\t\t\tdict: 包含发送结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.send_image(path, receiver)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 0 else \"失败\"}\n\n\tdef send_file(self,\n\t\t\t\t  path: str = Body(\"C:\\\\Projs\\\\WeChatRobot\\\\README.MD\", description=\"本地文件路径\"),\n\t\t\t\t  receiver: str = Body(\"filehelper\", description=\"roomid 或者 wxid\")) -> dict:\n\t\t\"\"\"发送文件\n\n\t\tArgs:\n\t\t\tpath (str): 本地文件路径，如：`C:/Projs/WeChatRobot/README.MD` 或网络文件 URL（仅本地模式支持）\n\t\t\treceiver (str): 消息接收人，wxid 或者 roomid\n\n\t\tReturns:\n\t\t\tdict: 包含发送结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.send_file(path, receiver)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 0 else \"失败\"}\n\n\tdef send_rich_text(\n\t\t\tself, name: str = Body(\"碲矿\", description=\"左下显示的名字\"),\n\t\t\taccount: str = Body(\"gh_75dea2d6c71f\", description=\"填公众号 id 可以显示对应的头像\"),\n\t\t\ttitle: str = Body(\"【FAQ】WeChatFerry 机器人常见问题 v39.0.10\", description=\"标题，最多两行\"),\n\t\t\tdigest: str = Body(\"先看再问，少走弯路。\", description=\"最多三行，会占位\"),\n\t\t\turl: str = Body(\n\t\t\t\t\"http://mp.weixin.qq.com/s?__biz=MzI0MjI1OTk0OQ==&mid=2247487601&idx=1&sn=1bf7a0d1c659f8bc78a00cba18d7b204\",\n\t\t\t\tdescription=\"点击后跳转的链接\"),\n\t\t\tthumburl: str = Body(\n\t\t\t\t\"https://mmbiz.qpic.cn/mmbiz_jpg/XaSOeHibHicMGIiaZsBeYYjcuS2KfBGXfm8ibb9QrKJqk0H0W3JHia9icVica9nlWMiaD0xWmA0pKHpMOWbeBCJaAQc2IQ/0?wx_fmt=jpeg\",\n\t\t\t\tdescription=\"缩略图的链接\"),\n\t\t\treceiver: str = Body(\"filehelper\", description=\"接收人, wxid 或者 roomid\")) -> dict:\n\t\t\"\"\"发送卡片消息\n\n\t\tArgs:\n\t\t\tname (str): 左下显示的名字\n\t\t\taccount (str): 填公众号 id 可以显示对应的头像（gh_ 开头的）\n\t\t\ttitle (str): 标题，最多两行\n\t\t\tdigest (str): 摘要，三行\n\t\t\turl (str): 点击后跳转的链接\n\t\t\tthumburl (str): 缩略图的链接\n\t\t\treceiver (str): 接收人, wxid 或者 roomid\n\n\t\tReturns:\n\t\t\tdict: 包含发送结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.send_rich_text(name, account, title, digest, url, thumburl, receiver)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 0 else \"失败，原因见日志\"}\n\n\tdef send_pat_msg(\n\t\t\tself, roomid: str = Body(description=\"群聊 roomid\"),\n\t\t\twxid: str = Body(\"wxid_xxxxxxxxxxxxx\", description=\"要拍的群友 wxid\")) -> dict:\n\t\t\"\"\"拍一拍群友\n\n\t\tArgs:\n\t\t\troomid (str): 群聊的 roomid\n\t\t\twxid (str): 要拍的群友的 wxid\n\n\t\tReturns:\n\t\t\tdict: 包含发送结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.send_pat_msg(roomid, wxid)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 1 else \"失败，原因见日志\"}\n\n\tdef send_emotion(self,\n\t\t\t\t\t path: str = Body(\"C:/Projs/WeChatRobot/emo.gif\", description=\"本地表情路径\"),\n\t\t\t\t\t receiver: str = Body(\"filehelper\", description=\"roomid 或者 wxid\")) -> dict:\n\t\t\"\"\"发送表情\n\n\t\tArgs:\n\t\t\tpath (str): 本地表情路径，如：`C:/Projs/WeChatRobot/emo.gif`\n\t\t\treceiver (str): 消息接收人，wxid 或者 roomid\n\n\t\tReturns:\n\t\t\tdict: 包含发送结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.send_emotion(path, receiver)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 0 else \"失败\"}\n\n\tdef query_sql(self,\n\t\t\t\t  db: str = Body(\"MicroMsg.db\", description=\"数据库\"),\n\t\t\t\t  sql: str = Body(\"SELECT * FROM Contact LIMIT 1;\", description=\"SQL 语句\")) -> dict:\n\t\t\"\"\"执行 SQL，如果数据量大注意分页，以免 OOM\n\n\t\tArgs:\n\t\t\tdb (str): 要查询的数据库\n\t\t\tsql (str): 要执行的 SQL\n\n\t\tReturns:\n\t\t\tdict: 包含查询结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.query_sql(db, sql)\n\t\tif ret:\n\t\t\tfor row in ret:\n\t\t\t\tfor k, v in row.items():\n\t\t\t\t\tif isinstance(v, bytes):\n\t\t\t\t\t\trow[k] = base64.b64encode(v).decode('utf-8')\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"bs64\": ret}}\n\t\treturn {\"status\": -1, \"message\": \"失败\"}\n\n\tdef accept_new_friend(self,\n\t\t\t\t\t\t  v3: str = Body(\"v3\", description=\"加密用户名 (好友申请消息里 v3 开头的字符串)\"),\n\t\t\t\t\t\t  v4: str = Body(\"v4\", description=\"Ticket (好友申请消息里 v4 开头的字符串)\"),\n\t\t\t\t\t\t  scene: int = Body(30, description=\"申请方式 (好友申请消息里的 scene)\")) -> dict:\n\t\t\"\"\"通过好友申请\n\n\t\tArgs:\n\t\t\tv3 (str): 加密用户名 (好友申请消息里 v3 开头的字符串)\n\t\t\tv4 (str): Ticket (好友申请消息里 v4 开头的字符串)\n\t\t\tscene (int): 申请方式 (好友申请消息里的 scene)\n\n\t\tReturns:\n\t\t\tdict: 包含操作结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.accept_new_friend(v3, v4, scene)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 1 else \"失败\"}\n\n\tdef add_chatroom_members(self,\n\t\t\t\t\t\t\t roomid: str = Body(\"xxxxxxxx@chatroom\", description=\"待加群的 id\"),\n\t\t\t\t\t\t\t wxids: str = Body(\"wxid_xxxxxxxxxxxxx\", description=\"要加到群里的 wxid，多个用逗号分隔\")) -> dict:\n\t\t\"\"\"添加群成员\n\n\t\tArgs:\n\t\t\troomid (str): 待加群的 id\n\t\t\twxids (str): 要加到群里的 wxid，多个用逗号分隔\n\n\t\tReturns:\n\t\t\tdict: 包含操作结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.add_chatroom_members(roomid, wxids)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 1 else \"失败\"}\n\n\tdef invite_chatroom_members(self,\n\t\t\t\t\t\t\t\troomid: str = Body(\"xxxxxxxx@chatroom\", description=\"待邀请的群 id\"),\n\t\t\t\t\t\t\t\twxids: str = Body(\"wxid_xxxxxxxxxxxxx\", description=\"要邀请到群里的 wxid，多个用逗号分隔\")) -> dict:\n\t\t\"\"\"邀请群成员\n\n\t\tArgs:\n\t\t\troomid (str): 群的 id\n\t\t\twxids (str): 要邀请成员的 wxid，多个用逗号分隔\n\n\t\tReturns:\n\t\t\tdict: 包含操作结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.invite_chatroom_members(roomid, wxids)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 1 else \"失败\"}\n\n\tdef del_chatroom_members(self,\n\t\t\t\t\t\t\t roomid: str = Body(\"xxxxxxxx@chatroom\", description=\"群的 id\"),\n\t\t\t\t\t\t\t wxids: str = Body(\"wxid_xxxxxxxxxxxxx\", description=\"要删除的 wxid，多个用逗号分隔\")) -> dict:\n\t\t\"\"\"删除群成员\n\n\t\tArgs:\n\t\t\troomid (str): 群的 id\n\t\t\twxids (str): 要删除的 wxid，多个用逗号分隔\n\n\t\tReturns:\n\t\t\tdict: 包含操作结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.del_chatroom_members(roomid, wxids)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 1 else \"失败\"}\n\n\tdef receive_transfer(self,\n\t\t\t\t\t\t wxid: str = Body(\"wxid_xxxxxxxxxxxxx\", description=\"转账消息里的发送人 wxid\"),\n\t\t\t\t\t\t transferid: str = Body(\"transferid\", description=\"转账消息里的 transferid\"),\n\t\t\t\t\t\t transactionid: str = Body(\"transactionid\", description=\"转账消息里的 transactionid\")) -> dict:\n\t\t\"\"\"接收转账\n\n\t\tArgs:\n\t\t\twxid (str): 转账消息里的发送人 wxid\n\t\t\ttransferid (str): 转账消息里的 transferid\n\t\t\ttransactionid (str): 转账消息里的 transactionid\n\n\t\tReturns:\n\t\t\tdict: 包含操作结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.receive_transfer(wxid, transferid, transactionid)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 1 else \"失败\"}\n\n\tdef refresh_pyq(self, id: int = Query(0, description=\"开始 id，0 为最新页\")) -> dict:\n\t\t\"\"\"刷新朋友圈\n\n\t\tArgs:\n\t\t\tid (int): 开始 id，0 为最新页\n\n\t\tReturns:\n\t\t\tdict: 包含操作结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.refresh_pyq(id)\n\t\treturn {\"status\": ret, \"message\": \"成功\" if ret == 1 else \"失败\"}\n\n\tdef decrypt_image(self,\n\t\t\t\t\t  src: str = Body(\"C:\\\\...\", description=\"加密的图片路径，从图片消息中获取\"),\n\t\t\t\t\t  dst: str = Body(\"C:\\\\...\", description=\"解密的图片路径\")) -> dict:\n\t\t\"\"\"解密图片:\n\n\t\tArgs:\n\t\t\tsrc (str): 加密的图片路径\n\t\t\tdst (str): 解密的图片路径\n\n\t\tReturns:\n\t\t\tbool: 是否成功\n\t\t\"\"\"\n\t\tret = self.wcf.decrypt_image(src, dst)\n\t\treturn {\"status\": ret, \"message\": \"成功\"if ret else \"废弃，请使用 save-image\"}\n\n\tdef download_attachment(self,\n\t\t\t\t\t\t\tid: int = Body(\"0\", description=\"消息中的id\"),\n\t\t\t\t\t\t\tthumb: str = Body(\"C:/...\", description=\"消息中的 thumb\"),\n\t\t\t\t\t\t\textra: str = Body(\"C:/...\", description=\"消息中的 extra\")) -> dict:\n\t\t\"\"\"下载附件（图片、视频、文件）\n\n\t\tArgs:\n\t\t\tid (int): 消息中 id\n\t\t\tthumb (str): 消息中的 thumb\n\t\t\textra (str): 消息中的 extra\n\n\t\tReturns:\n\t\t\tstr: 成功返回存储路径；空字符串为失败，原因见日志。\n\t\t\"\"\"\n\t\tret = self.wcf.download_attach(id, thumb, extra)\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"path\": ret}}\n\n\t\treturn {\"status\": -1, \"message\": \"废弃，请使用 save-image\"}\n\n\tdef download_image(self,\n\t\t\t\t\t   id: int = Body(\"0\", description=\"消息中的 id\"),\n\t\t\t\t\t   extra: str = Body(\"C:/...\", description=\"消息中的 extra\"),\n\t\t\t\t\t   dir: str = Body(\"C:/...\", description=\"保存图片的目录\"),\n\t\t\t\t\t   timeout: int = Body(\"30\", description=\"超时时间（秒）\")) -> dict:\n\t\t\"\"\"下载图片\n\n\t\tArgs:\n\t\t\tid (int): 消息中 id\n\t\t\textra (str): 消息中的 extra\n\t\t\tdir (str): 存放图片的目录（目录不存在会出错）\n\t\t\ttimeout (int): 超时时间（秒）\n\n\t\tReturns:\n\t\t\tdict: 包含下载结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.download_image(id, extra, dir, timeout)\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"path\": ret}}\n\n\t\treturn {\"status\": -1, \"message\": \"失败，原因见日志\"}\n\n\tdef get_audio_msg(self,\n\t\t\t\t\t  id: int = Body(\"0\", description=\"消息中的 id\"),\n\t\t\t\t\t  dir: str = Body(\"C:/...\", description=\"保存语音的目录\"),\n\t\t\t\t\t  timeout: int = Body(\"30\", description=\"超时时间（秒）\")) -> dict:\n\t\t\"\"\"保存语音\n\n\t\tArgs:\n\t\t\tid (int): 消息中 id\n\t\t\tdir (str): 存放语音的目录\n\t\t\ttimeout (int): 超时时间（秒）\n\n\t\tReturns:\n\t\t\tdict: 包含保存结果的字典\n\t\t\"\"\"\n\t\tret = self.wcf.get_audio_msg(id, dir, timeout)\n\t\tif ret:\n\t\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"path\": ret}}\n\n\t\treturn {\"status\": -1, \"message\": \"失败，原因见日志\"}\n\n\tdef get_chatroom_members(self, roomid: str = Query(\"xxxxxxxx@chatroom\", description=\"群的 id\")) -> dict:\n\t\t\"\"\"获取群成员\n\n\t\tArgs:\n\t\t\troomid (str): 群的 id\n\n\t\tReturns:\n\t\t\tdict: 包含群成员列表的字典\n\t\t\"\"\"\n\t\tret = self.wcf.get_chatroom_members(roomid)\n\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"members\": ret}}\n\n\tdef get_alias_in_chatroom(self, wxid: str = Query(\"wxid_xxxxxxxxxxxxx\", description=\"wxid\"),\n\t\t\t\t\t\t\t  roomid: str = Query(\"xxxxxxxx@chatroom\", description=\"群的 id\")) -> dict:\n\t\t\"\"\"获取群成员名片\n\n\t\tArgs:\n\t\t\twxid (str): wxid\n\t\t\troomid (str): 群的 id\n\n\t\tReturns:\n\t\t\tdict: 包含名片信息的字典\n\t\t\"\"\"\n\t\tret = self.wcf.get_alias_in_chatroom(wxid, roomid)\n\t\treturn {\"status\": 0, \"message\": \"成功\", \"data\": {\"alias\": ret}}\n"}

{"repo_info": {"repo_name": "fastapi-utilities", "repo_owner": "priyanshu-panwar", "repo_url": "https://github.com/priyanshu-panwar/fastapi-utilities"}}
{"type": "test_file", "path": "fastapi_utilities/cli/template/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "fastapi_utilities/cli/template/tests/test_module1.py", "content": ""}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/test_timer_middleware.py", "content": "import logging\nimport pytest\nimport asyncio\nfrom fastapi import FastAPI\nfrom fastapi.testclient import TestClient\nfrom _pytest.capture import CaptureFixture\nfrom fastapi_utilities import add_timer_middleware\n\napp = FastAPI()\nadd_timer_middleware(app, show_avg=True, reset_after=1)\n\n\n@app.get(\"/\")\ndef root():\n    pass\n\n\nclient = TestClient(app)\n\n\ndef test_timer_middleware(capsys: CaptureFixture[str]) -> None:\n    client.get(\"/\")\n    out, err = capsys.readouterr()\n    assert err == \"\"\n"}
{"type": "test_file", "path": "tests/test_repeat_at.py", "content": "import logging\nimport asyncio\nimport pytest\nfrom _pytest.capture import CaptureFixture\nfrom _pytest.logging import LogCaptureFixture\nfrom fastapi_utilities import repeat_at\n\n\n@pytest.mark.asyncio\nasync def test_repeat_at(capsys: CaptureFixture[str]):\n    \"\"\"\n    Simple Test Case for repeat_at\n    \"\"\"\n\n    @repeat_at(cron=\"* * * * *\", max_repetitions=3)\n    async def print_hello():\n        print(\"Hello\")\n\n    asyncio.create_task(print_hello())\n    await asyncio.sleep(1)\n    out, err = capsys.readouterr()\n    assert err == \"\"\n    assert out == \"\"\n\n\n@pytest.mark.asyncio\nasync def test_repeat_at_def(capsys: CaptureFixture[str]):\n    \"\"\"\n    Simple Test Case for repeat_at\n    \"\"\"\n\n    @repeat_at(cron=\"* * * * *\", max_repetitions=3)\n    def print_hello():\n        print(\"Hello\")\n\n    print_hello()\n    await asyncio.sleep(1)\n    out, err = capsys.readouterr()\n    assert err == \"\"\n    assert out == \"\"\n\n\n@pytest.mark.asyncio\nasync def test_repeat_at_with_logger(caplog: LogCaptureFixture):\n    \"\"\"\n    Test Case for repeat_at with logger\n    \"\"\"\n\n    @repeat_at(cron=\"* * * * *\", logger=logging.getLogger(\"test\"), max_repetitions=3)\n    async def print_hello():\n        raise Exception(\"Hello\")\n\n    asyncio.create_task(print_hello())\n    await asyncio.sleep(60)\n\n    captured_logs = caplog.records\n\n    assert len(captured_logs) > 0\n\n\nfrom asyncio import AbstractEventLoop\nfrom typing import Any, Dict\n\n\ndef ignore_exception(_loop: AbstractEventLoop, _context: Dict[str, Any]) -> None:\n    pass\n\n\n@pytest.fixture(autouse=True)\ndef setup_event_loop(event_loop: AbstractEventLoop) -> None:\n    event_loop.set_exception_handler(ignore_exception)\n\n\n@pytest.mark.asyncio\nasync def test_repeat_at_exception(capsys: CaptureFixture[str]) -> None:\n    \"\"\"\n    Test Case for repeat_at with an invalid cron expression\n    \"\"\"\n\n    logger = logging.getLogger(__name__)\n\n    @repeat_at(\n        cron=\"* * * * *\", max_repetitions=None, raise_exceptions=True, logger=logger\n    )\n    def raise_exc():\n        raise ValueError(\"repeat\")\n\n    try:\n        raise_exc()\n        await asyncio.sleep(60)\n    except ValueError:\n        out, err = capsys.readouterr()\n        assert out == \"\"\n        assert err == \"\"\n\n\n@pytest.mark.asyncio\nasync def test_repeat_at_invalid_cron(capsys: CaptureFixture[str]) -> None:\n    \"\"\"\n    Test Case for repeat_at with an invalid cron expression\n    \"\"\"\n\n    logger = logging.getLogger(__name__)\n\n    @repeat_at(\n        cron=\"invalid\", max_repetitions=None, raise_exceptions=True, logger=logger\n    )\n    def raise_exc():\n        raise ValueError(\"repeat\")\n\n    try:\n        await raise_exc()\n        await asyncio.sleep(60)\n    except ValueError:\n        out, err = capsys.readouterr()\n        assert out == \"\"\n        assert err == \"\"\n"}
{"type": "test_file", "path": "tests/test_session.py", "content": "import pytest\nfrom pathlib import Path\nimport random\nfrom _pytest.capture import CaptureFixture\n\nfrom fastapi import FastAPI\nfrom fastapi.testclient import TestClient\nfrom fastapi_utilities import FastAPISessionMaker\n\n# setup\ndb_path = Path(\"./db.sqlite3\")\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\n\nDB_URL = f\"sqlite:///{db_path}\"\nengine = create_engine(DB_URL, connect_args={\"check_same_thread\": False})\nBase = declarative_base()\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nfrom sqlalchemy import Column, Integer\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n\n\napp = FastAPI()\nBase.metadata.create_all(bind=engine)\n\n# done\n\n\ndef test_session():\n    sm = FastAPISessionMaker(DB_URL)\n    with sm.context_session() as session:\n        x = User(id=random.randint(0, 10000))\n        session.add(x)\n\n\ndef test_reset_session():\n    sm = FastAPISessionMaker(DB_URL)\n    sm.reset_session()\n\n\ndef test_session_raise_error(capsys: CaptureFixture[str]) -> None:\n    sm = FastAPISessionMaker(DB_URL)\n    try:\n        with sm.context_session() as session:\n            x = User(id=1)\n            session.add(x)\n            x = User(id=1)\n            session.add(x)\n    except Exception:\n        out, err = capsys.readouterr()\n        assert out == \"\"\n"}
{"type": "test_file", "path": "tests/test_repeat_every.py", "content": "import logging\nimport pytest\nimport asyncio\n\nfrom _pytest.capture import CaptureFixture\nfrom _pytest.logging import LogCaptureFixture\nfrom fastapi_utilities import repeat_every\n\n\n@pytest.mark.asyncio\nasync def test_repeat_every(capsys: CaptureFixture[str]):\n    \"\"\"\n    Simple Test Case for repeat_every\n    \"\"\"\n\n    @repeat_every(seconds=0.1, max_repetitions=3)\n    async def print_hello():\n        print(\"Hello\")\n\n    await print_hello()\n    await asyncio.sleep(0.5)\n    out, err = capsys.readouterr()\n    assert out == \"Hello\\nHello\\nHello\\n\"\n    assert err == \"\"\n\n\n@pytest.mark.asyncio\nasync def test_repeat_every_sync(capsys: CaptureFixture[str]):\n    \"\"\"\n    Simple Test Case for repeat_every\n    \"\"\"\n\n    @repeat_every(seconds=0.1, max_repetitions=3)\n    def print_hello():\n        print(\"Hello\")\n\n    await print_hello()\n    await asyncio.sleep(0.5)\n    out, err = capsys.readouterr()\n    assert out == \"Hello\\nHello\\nHello\\n\"\n    assert err == \"\"\n\n\n@pytest.mark.asyncio\nasync def test_repeat_every_with_wait_first(capsys: CaptureFixture[str]):\n    \"\"\"\n    Test Case for repeat_every with wait_first=True\n    \"\"\"\n\n    @repeat_every(seconds=0.1, wait_first=True, max_repetitions=3)\n    async def print_hello():\n        print(\"Hello\")\n\n    await print_hello()\n    await asyncio.sleep(0.5)\n    out, err = capsys.readouterr()\n    assert out == \"Hello\\nHello\\nHello\\n\"\n    assert err == \"\"\n\n\n@pytest.mark.asyncio\nasync def test_repeat_every_with_logger(caplog: LogCaptureFixture):\n    \"\"\"\n    Test Case for repeat_every with logger\n    \"\"\"\n\n    @repeat_every(seconds=0.1, logger=logging.getLogger(\"test\"), max_repetitions=3)\n    async def print_hello():\n        raise Exception(\"Hello\")\n\n    await print_hello()\n    await asyncio.sleep(0.5)\n\n    captured_logs = caplog.records\n\n    assert len(captured_logs) > 0\n\n    last_log = captured_logs[-1]  # Get the last log message\n    assert last_log.levelname == \"ERROR\"  # Check log level\n    assert \"Hello\" in last_log.message  # Check log message content\n\n\nfrom asyncio import AbstractEventLoop\nfrom typing import Any, Dict\n\n\ndef ignore_exception(_loop: AbstractEventLoop, _context: Dict[str, Any]) -> None:\n    pass\n\n\n@pytest.fixture(autouse=True)\ndef setup_event_loop(event_loop: AbstractEventLoop) -> None:\n    event_loop.set_exception_handler(ignore_exception)\n\n\n@pytest.mark.asyncio\nasync def test_repeat_raise_error(capsys: CaptureFixture[str]) -> None:\n    logger = logging.getLogger(__name__)\n\n    @repeat_every(\n        seconds=0.07, max_repetitions=None, raise_exceptions=True, logger=logger\n    )\n    def raise_exc():\n        raise ValueError(\"repeat\")\n\n    await raise_exc()\n    await asyncio.sleep(0.1)\n    out, err = capsys.readouterr()\n    assert out == \"\"\n    assert err == \"\"\n"}
{"type": "source_file", "path": "fastapi_utilities/cache/__init__.py", "content": "from .ttl_lru_cache import ttl_lru_cache\n"}
{"type": "source_file", "path": "fastapi_utilities/__main__.py", "content": "from .cli.cli import main\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "fastapi_utilities/__init__.py", "content": "from .repeat.repeat_every import repeat_every\nfrom .repeat.repeat_at import repeat_at\n\nfrom .timer import add_timer_middleware\n\nfrom .session import FastAPISessionMaker\n\nfrom .cache import ttl_lru_cache\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/__init__.py", "content": ""}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/__init__.py", "content": ""}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/api.py", "content": "# Define all the router here.\n\nfrom fastapi import APIRouter\nfrom .module1.views import router as module1_router\n\nrouter = APIRouter()\nrouter.include_router(module1_router)\n"}
{"type": "source_file", "path": "fastapi_utilities/cache/ttl_lru_cache.py", "content": "from functools import lru_cache, wraps\nfrom typing import Callable\nimport time\n\n\ndef ttl_lru_cache(ttl: int, max_size: int = 128) -> Callable:\n    \"\"\"\n    This function is a decorator that wraps the lru_cache decorator.\n    \"\"\"\n\n    def decorator(func) -> Callable:\n        @lru_cache(maxsize=max_size)\n        def _new(*args, __time_salt, **kwargs):\n            return func(*args, **kwargs)\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if ttl:\n                return _new(*args, __time_salt=int(time.time() / ttl), **kwargs)\n            return func(*args, **kwargs)\n\n        wrapper.cache_clear = _new.cache_clear\n        return wrapper\n\n    return decorator\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/cli.py", "content": "import argparse\nimport os\nimport click_spinner\nimport time\nimport shutil\n\nTEMPLATE_FOLDER = os.path.join(os.path.dirname(__file__), \"template\")\n\n\ndef copy_template_files(destination_folder):\n    \"\"\"\n    Copy template files to the destination folder.\n    \"\"\"\n    for root, dirs, files in os.walk(TEMPLATE_FOLDER):\n        for file in files:\n            src_file = os.path.join(root, file)\n            dest_file = os.path.join(\n                destination_folder, os.path.relpath(src_file, TEMPLATE_FOLDER)\n            )\n            os.makedirs(os.path.dirname(dest_file), exist_ok=True)\n            shutil.copy(src_file, dest_file)\n\n\ndef init_project(project_name: str):\n    \"\"\"\n    Initialize a new FastAPI project\n    \"\"\"\n    # Create project folder\n    project_folder = os.path.join(os.getcwd(), project_name)\n    os.makedirs(project_folder, exist_ok=True)\n\n    copy_template_files(project_folder)\n\n\ndef init(args):\n    \"\"\"\n    Initialize FastAPI Utilities CLI\n    \"\"\"\n    print(\"Welcome to FastAPI Utilities CLI Tool\")\n\n    project_name = input(\"Enter the project name: \")\n\n    with click_spinner.spinner(f\"Creating project '{project_name}'...\"):\n        init_project(project_name)\n        time.sleep(1)\n\n    print(\"Project created successfully\")\n\n\ndef main():\n    \"\"\"\n    Main function for FastAPI Utilities CLI Tool\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"FastAPI Utilities CLI Tool\")\n    subparsers = parser.add_subparsers(title=\"subcommands\", dest=\"subcommand\")\n\n    # Create 'init' subcommand\n    parser_init = subparsers.add_parser(\"init\", help=\"Initialize FastAPI Utilities CLI\")\n    parser_init.set_defaults(func=init)\n\n    try:\n        args = parser.parse_args()\n        args.func(args)\n    except AttributeError:\n        parser.print_help()\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/module1/schemas.py", "content": "# Define your module's schemas here\n\nfrom pydantic import BaseModel\n\n\nclass MySchema(BaseModel):\n    pass\n"}
{"type": "source_file", "path": "fastapi_utilities/repeat/repeat_every.py", "content": "import asyncio\nimport logging\nimport typing\n\nfrom functools import wraps\nfrom asyncio import ensure_future\nfrom starlette.concurrency import run_in_threadpool\n\n\n_FuncType = typing.TypeVar(\"_FuncType\", bound=typing.Callable)\n\n\ndef repeat_every(\n    *,\n    seconds: float,\n    wait_first: bool = False,\n    logger: logging.Logger = None,\n    raise_exceptions: bool = False,\n    max_repetitions: int = None,\n) -> typing.Callable[[_FuncType], _FuncType]:\n    \"\"\"\n    This function returns a decorator that schedules a function to execute periodically after every `seconds` seconds.\n\n    :: Params ::\n    ------------\n    seconds: float\n        The number of seconds to wait before executing the function again.\n    wait_first: bool (default False)\n        Whether to wait `seconds` seconds before executing the function for the first time.\n    logger: logging.Logger (default None)\n        The logger to use for logging exceptions.\n    raise_exceptions: bool (default False)\n        Whether to raise exceptions instead of logging them.\n    max_repetitions: int (default None)\n        The maximum number of times to repeat the function. If None, the function will repeat indefinitely.\n    \"\"\"\n\n    def decorator(func: _FuncType) -> _FuncType:\n        is_coroutine = asyncio.iscoroutinefunction(func)\n\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            repetitions = 0\n\n            async def loop(*args, **kwargs):\n                nonlocal repetitions\n                if wait_first:\n                    await asyncio.sleep(seconds)\n                while max_repetitions is None or repetitions < max_repetitions:\n                    try:\n                        if is_coroutine:\n                            await func(*args, **kwargs)\n                        else:\n                            await run_in_threadpool(func, *args, **kwargs)\n                    except Exception as e:\n                        if logger is not None:\n                            logger.exception(e)\n                        if raise_exceptions:\n                            raise e\n                    repetitions += 1\n                    await asyncio.sleep(seconds)\n\n            ensure_future(loop(*args, **kwargs))\n\n        return wrapper\n\n    return decorator\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/database.py", "content": "# Define database connection here\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom src import constants\n\nengine = create_engine(\n    constants.DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/module1/models.py", "content": "# Define your module's models here\n\nfrom pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    pass\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/module1/views.py", "content": "# Define your module's routes here\n\nfrom fastapi import APIRouter\n\nrouter = APIRouter(prefix=\"/module1\", tags=[\"module1\"])\nfrom . import utils, services, models\n\n\n@router.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n"}
{"type": "source_file", "path": "fastapi_utilities/repeat/repeat_at.py", "content": "import asyncio\nimport logging\nimport typing\n\nfrom datetime import datetime\nfrom functools import wraps\nfrom asyncio import ensure_future\nfrom starlette.concurrency import run_in_threadpool\nfrom croniter import croniter\n\n_FuncType = typing.TypeVar(\"_FuncType\", bound=typing.Callable)\n\n\ndef get_delta(cron: str) -> float:\n    \"\"\"\n    Returns the time delta between now and the next cron execution time.\n    \"\"\"\n    now = datetime.now()\n    cron = croniter(cron, now)\n    return (cron.get_next(datetime) - now).total_seconds()\n\ndef repeat_at(\n    *,\n    cron: str,\n    logger: logging.Logger = None,\n    raise_exceptions: bool = False,\n    max_repetitions: int = None,\n) -> typing.Callable[[_FuncType], _FuncType]:\n    \"\"\"\n    Decorator to schedule a function's execution based on a cron expression.\n\n    Parameters:\n    -----------\n    cron: str\n        Cron-style string for periodic execution, e.g., '0 0 * * *' for every midnight.\n    logger: logging.Logger (default None)\n        Logger object to log exceptions.\n    raise_exceptions: bool (default False)\n        Whether to raise exceptions or log them.\n    max_repetitions: int (default None)\n        Maximum number of times to repeat the function. If None, repeats indefinitely.\n    \"\"\"\n\n    def decorator(func: _FuncType) -> _FuncType:\n        is_coroutine = asyncio.iscoroutinefunction(func)\n\n        @wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            repetitions = 0\n            if not croniter.is_valid(cron):\n                raise ValueError(f\"Invalid cron expression: '{cron}'\")\n\n            while max_repetitions is None or repetitions < max_repetitions:\n                try:\n                    sleep_time = get_delta(cron)\n                    await asyncio.sleep(sleep_time)\n                    await func(*args, **kwargs)\n                except Exception as e:\n                    if logger:\n                        logger.exception(e)\n                    if raise_exceptions:\n                        raise e\n                repetitions += 1\n\n        @wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            repetitions = 0\n            if not croniter.is_valid(cron):\n                raise ValueError(f\"Invalid cron expression: '{cron}'\")\n\n            async def loop():\n                nonlocal repetitions\n                while max_repetitions is None or repetitions < max_repetitions:\n                    try:\n                        sleep_time = get_delta(cron)\n                        await asyncio.sleep(sleep_time)\n                        await run_in_threadpool(func, *args, **kwargs)\n                    except Exception as e:\n                        if logger:\n                            logger.exception(e)\n                        if raise_exceptions:\n                            raise e\n                    repetitions += 1\n\n            ensure_future(loop())\n\n        # Return the appropriate wrapper based on the function type\n        return async_wrapper if is_coroutine else sync_wrapper\n\n    return decorator\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/module1/service.py", "content": "# Define your module's crud operations here\n\nfrom typing import List\nfrom fastapi import Depends\nfrom sqlalchemy.orm import Session\nfrom . import models, schemas\nfrom src import utils\n\n\nasync def get_all(db: Session = Depends(utils.get_db)) -> List[models.MyModel]:\n    pass\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/main.py", "content": "# Sample main file\n\nfrom fastapi import FastAPI\nfrom .api import router\n\napp = FastAPI(\"My App\")\napp.include_router(router)\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/constants.py", "content": "# Define global constants here\n\nDATABASE_URL = \"\"\n"}
{"type": "source_file", "path": "fastapi_utilities/repeat/__init__.py", "content": "from .repeat_at import repeat_at\nfrom .repeat_every import repeat_every"}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/module1/utils.py", "content": "# Define your module's utils here\n"}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/module1/__init__.py", "content": ""}
{"type": "source_file", "path": "fastapi_utilities/cli/template/src/module1/constants.py", "content": "# Define your module's constants here\n\n# MY_CONSTANT = \"my_constant\"\n"}
{"type": "source_file", "path": "fastapi_utilities/session/session.py", "content": "from contextlib import contextmanager\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.orm import Session, sessionmaker\n\n\nclass FastAPISessionMaker:\n    \"\"\"\n    This will allow us to create a cached session maker that can be used as context manager.\n    \"\"\"\n\n    def __init__(self, db_url: str):\n        \"\"\"\n        `db_url` should be any sqlalchemy-compatible database URI.\n        \"\"\"\n        self.db_url = db_url\n        self._cached_engine: Engine = None\n        self._cached_session_maker: Session = None\n\n    def _get_db(self):\n        \"\"\"\n        This will return a cached db connection Session.\n        \"\"\"\n        if self._cached_engine is None:\n            self._cached_engine = create_engine(self.db_url)\n        if self._cached_session_maker is None:\n            self._cached_session_maker = sessionmaker(\n                autocommit=False, autoflush=False, bind=self._cached_engine\n            )\n        db = self._cached_session_maker()\n        try:\n            yield db\n            db.commit()\n        except Exception as e:\n            db.rollback()\n            raise e\n        finally:\n            db.close()\n\n    @contextmanager\n    def context_session(self):\n        \"\"\"\n        A context manager that works for `get_db` dependency injection.\n\n        Usage:\n            session_maker = FastAPISessionMaker(database_uri)\n            with session_maker.context_session() as session:\n                session.query(...)\n        \"\"\"\n        yield from self._get_db()\n\n    def reset_session(self):\n        \"\"\"\n        This will reset the sessionmaker and engine.\n        \"\"\"\n        self._cached_session_maker = None\n        self._cached_engine = None\n"}
{"type": "source_file", "path": "fastapi_utilities/timer/middleware.py", "content": "\"\"\"\nBased on https://github.com/dmontagu/fastapi-utils/blob/master/fastapi_utils/timing.py\n\"\"\"\n\nimport time\nfrom typing import Callable\nfrom fastapi import FastAPI, Request\nimport logging\n\nTIMER_PREFIX = \"(fastapi-utilities)\"\n\n\ndef add_timer_middleware(\n    app: FastAPI,\n    show_avg: bool = False,\n    reset_after: int = 100000,\n) -> None:\n    \"\"\"\n    Add a middleware to the FastAPI app that logs the time taken to process a request.\n    Optionally, also logs the average response time.\n    The average response time is reset after every (reset_after)100,000 requests.\n\n    ::Params::\n    ----------\n    app: FastAPI\n        The FastAPI app to add the middleware to.\n    show_avg: bool (default False)\n        Whether to show the average response time in the logs.\n    reset_after: int (default 100000)\n        The number of requests after which to reset the average response time.\n    \"\"\"\n\n    logger = logging.getLogger(\"uvicorn\")\n\n    request_counter = 0\n    total_response_time = 0.0\n\n    @app.middleware(\"http\")\n    async def timer_middleware(request: Request, call_next):\n        nonlocal request_counter, total_response_time\n\n        start_time = time.time()\n        response = await call_next(request)\n        process_time = (time.time() - start_time) * 1000\n        logger.info(\n            f'{TIMER_PREFIX} \"{request.method} - {request.url.path}\" :: Time Taken :: {process_time:.2f} ms'\n        )\n\n        if show_avg:\n            request_counter += 1\n            total_response_time += process_time\n            average_response_time = (\n                total_response_time / request_counter if request_counter > 0 else 0\n            )\n            logger.info(f\":: Average Response Time :: {average_response_time:.2f} ms\")\n\n            if request_counter % reset_after == 0:\n                request_counter = 0\n                total_response_time = 0.0\n\n        return response\n"}
{"type": "source_file", "path": "fastapi_utilities/session/__init__.py", "content": "from .session import FastAPISessionMaker\n"}
{"type": "source_file", "path": "fastapi_utilities/timer/__init__.py", "content": "from .middleware import add_timer_middleware\n"}

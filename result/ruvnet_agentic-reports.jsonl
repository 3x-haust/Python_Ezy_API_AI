{"repo_info": {"repo_name": "agentic-reports", "repo_owner": "ruvnet", "repo_url": "https://github.com/ruvnet/agentic-reports"}}
{"type": "test_file", "path": "project-root/tests/__init__.py", "content": "# This file initializes the tests package\n"}
{"type": "test_file", "path": "project-root/tests/test_main.py", "content": "from fastapi.testclient import TestClient\nfrom app.main import app\n\nclient = TestClient(app)\n\ndef test_generate_report():\n    response = client.post(\"/generate-report\", json={\"topic\": \"AI\"})\n    assert response.status_code == 200\n    assert \"report\" in response.json()\n"}
{"type": "test_file", "path": "project-root/tests/test_report_generator.py", "content": "from app.services.report_generator import generate_report\n\ndef test_generate_report():\n    topic = \"AI\"\n    report = generate_report(topic)\n    assert isinstance(report, str)\n"}
{"type": "source_file", "path": "project-root/app/services/__init__.py", "content": "# This file initializes the services sub-package\n"}
{"type": "source_file", "path": "project-root/app/api/advanced_reports.py", "content": "from fastapi import APIRouter, HTTPException, status, Body\nfrom typing import List, Optional, Dict\nfrom app.services.report_generator import generate_advanced_report\n\nrouter = APIRouter()\n\n@router.post(\"/generate-report-advanced\")\nasync def generate_report_advanced_endpoint(\n    query: str = Body(..., example=\"quantum computing\"),\n    primary_prompt: str = Body(..., example=\"Generate a detailed report on the current advancements and applications of quantum computing.\"),\n    subqueries_prompt: str = Body(..., example=\"Please create subqueries related to quantum computing advancements and its various applications.\"),\n    report_prompt: str = Body(..., example=\"Write a comprehensive and professional in french, five-paragraph, 800 word research report about quantum computing based on the provided information.\"),\n    start_published_date: Optional[str] = Body(None, example=\"2023-01-01\"),\n    end_published_date: Optional[str] = Body(None, example=\"2023-12-31\"),\n    include_domains: Optional[List[str]] = Body(None, example=[\"example.com\", \"another-example.com\"]),\n    exclude_domains: Optional[List[str]] = Body(None, example=[\"excluded.com\"]),\n    highlights: Optional[Dict] = Body(None, example={\"num_sentences\": 5}),\n    text: Optional[Dict] = Body(None, example={\"include_html_tags\": False}),\n    num_subqueries: int = Body(10, example=10)\n):\n    try:\n        report = await generate_advanced_report(\n            query=query,\n            primary_prompt=primary_prompt,\n            subqueries_prompt=subqueries_prompt,\n            report_prompt=report_prompt,\n            start_published_date=start_published_date,\n            end_published_date=end_published_date,\n            include_domains=include_domains,\n            exclude_domains=exclude_domains,\n            highlights=highlights,\n            text=text,\n            num_subqueries=num_subqueries\n        )\n        return {\"report\": report}\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n"}
{"type": "source_file", "path": "project-root/app/core/config.py", "content": "# config.py: Configuration settings for the application. This file contains the Settings class, which is used to define the configuration settings for the application. The settings are loaded from environment variables using the pydantic_settings library. The describe_fields method is used to provide a description of the configuration settings.\nimport os\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    \"\"\"\n    Settings class for application configuration.\n\n    System OS Secrets:\n    - EXA_API_KEY: API key for Exa service\n    - OPENAI_API_KEY: API key for OpenAI service\n    \"\"\"\n    exa_api_key: str = os.getenv(\"EXA_API_KEY\", \"Please_set_EXA_API_KEY_system_OS_secret\")\n    openai_api_key: str = os.getenv(\"OPENAI_API_KEY\", \"Please_set_OPENAI_API_KEY_system_OS_secret\")\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = 'utf-8'\n\n    @staticmethod\n    def describe_fields():\n        return {\n            'exa_api_key': 'API key for Exa service retrieved from system OS secrets',\n            'openai_api_key': 'API key for OpenAI service retrieved from system OS secrets'\n        }\n\nsettings = Settings()"}
{"type": "source_file", "path": "project-root/app/api/__init__.py", "content": "# This file initializes the api sub-package\n"}
{"type": "source_file", "path": "project-root/app/main.py", "content": "from fastapi import FastAPI\nfrom app.api import endpoints\nfrom fastapi.responses import RedirectResponse\n\napp = FastAPI()\napp = FastAPI(title=\"Agentic Reports (v0.01)\")\n\n@app.get(\"/\", include_in_schema=False)\nasync def docs_redirect():\n    return RedirectResponse(url='/docs')\n\napp.include_router(endpoints.router)\n"}
{"type": "source_file", "path": "project-root/app/core/__init__.py", "content": "# This file initializes the core sub-package\n"}
{"type": "source_file", "path": "project-root/app/services/report_generator-sync.py", "content": "# project-root/app/services/report_generator-sync.py is a synchronous version of the report_generator.py service. \n# It uses the synchronous version of the OpenAI API client and synchronous Exa search functions. \n# This version is suitable for applications that require synchronous processing or do not support asynchronous operations. \n# The functions in this module perform the following tasks: \n# - Initialize the Exa client for searching the Exa service.\n# - Generate subqueries from a given topic using the GPT-4 model.\n# - Search Exa for each subquery to retrieve relevant information.\n# - Format the Exa search results for input to the GPT-4 model.\n# - Generate a research report based on the Exa search results using the GPT-4 model.\n# - Perform a search with retries and exponential backoff.\n# - Provide a synchronous version of the report generation process.\n\nimport os\nimport json\nimport time\n\nimport asyncio\nimport aiohttp\n\nfrom datetime import datetime, timedelta\nfrom litellm import acompletion\nfrom app.core.config import settings\nfrom app.utils.exa_search import search_exa\n\n# Set up API keys using environment variables\nos.environ[\"OPENAI_API_KEY\"] = os.getenv('OPENAI_API_KEY', settings.openai_api_key)\n\nasync def generate_report(topic: str) -> str:\n    print(f\"Starting report generation for topic: {topic}\")\n    subqueries = await generate_subqueries_from_topic(topic)\n    list_of_query_exa_pairs = exa_search_each_subquery(subqueries)\n    report = await generate_report_from_exa_results(topic, list_of_query_exa_pairs)\n    return report\n\nasync def generate_report_without_exa(topic):\n    print(f\"üöÄ Generating report without Exa for topic: {topic}\")\n    content = f\"Write a comprehensive and professional three-paragraph research report about {topic}. Include citations with source, month, and year.\"\n    try:\n        completion = await acompletion(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}],\n            stream=False\n        )\n        report = completion['choices'][0]['message']['content']\n    except Exception as e:\n        report = f\"Failed to generate report: {str(e)}\"\n    return report\n\nasync def generate_subqueries_from_topic(topic, num_subqueries=6):\n    print(f\"üåø Generating subqueries from topic: {topic}\")\n    content = f\"I'm going to give you a topic I want to research. I want you to generate {num_subqueries} interesting, diverse search queries that would be useful for generating a report on my main topic. Here is the main topic: {topic}.\"\n    try:\n        completion = await acompletion(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}],\n            stream=False\n        )\n        response_content = completion['choices'][0]['message']['content']\n        print(f\"Raw response content: {response_content}\")  # Print raw response for debugging\n        \n        # Split the response into individual lines and strip leading/trailing spaces and numbers\n        subqueries = []\n        for line in response_content.split('\\n'):\n            if line.strip():\n                # Attempt to split by \". \" and take the second part\n                try:\n                    subquery = line.strip(' \"').split('. ', 1)[1]\n                    subqueries.append(subquery)\n                except IndexError:\n                    print(f\"Skipping improperly formatted line: {line}\")\n        \n        # Output the parsed subqueries for debugging\n        print(f\"Parsed subqueries: {subqueries}\")\n        \n    except Exception as e:\n        print(f\"Unexpected error: {str(e)}\")  # Output unexpected error details\n        subqueries = [f\"Failed to generate subqueries: {str(e)}\"]\n    return subqueries\n\ndef exa_search_each_subquery(subqueries):\n    print(f\"‚åõ Searching each subquery\")\n    list_of_query_exa_pairs = []\n\n    # Initialize the Exa client (assuming you have the initialization code)\n    exa_client = initialize_exa_client()  # Add your initialization logic here\n\n    if exa_client is None:\n        print(\"‚ö†Ô∏è Exa client is not initialized. Check your initialization logic.\")\n        return []\n\n    def perform_search(query, retries=5, delay=2):\n        \"\"\"Helper function to perform search with retries and exponential backoff.\"\"\"\n        for attempt in range(retries):\n            try:\n                # Perform the search using Exa API\n                search_response = exa_client.search_and_contents(\n                    query=query,\n                    type='neural'\n                )\n                # Check if response contains data\n                if search_response and hasattr(search_response, 'results') and search_response.results:\n                    return search_response\n                else:\n                    print(f\"‚ö†Ô∏è No data found for subquery: {query}\")\n                    return None\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Attempt {attempt + 1} failed for query '{query}': {str(e)}\")\n                if \"502\" in str(e) and attempt < retries - 1:\n                    backoff = delay * (2 ** attempt)  # Exponential backoff\n                    print(f\"Retrying in {backoff} seconds...\")\n                    time.sleep(backoff)\n                else:\n                    print(f\"‚ö†Ô∏è All {retries} attempts failed for query '{query}'\")\n                    return None\n\n    for query in subqueries:\n        if \"Failed to generate subqueries\" in query:\n            print(f\"‚ö†Ô∏è Skipping invalid subquery: {query}\")\n            continue\n\n        print(f\"üîç Searching for subquery: {query}\")\n        search_response = perform_search(query)\n        if search_response:\n            print(f\"‚úÖ Search successful for subquery: {query}\")\n            list_of_query_exa_pairs.append({\n                'subquery': query,\n                'results': search_response.results\n            })\n\n    print(f\"üèÅ Completed search for all subqueries\")\n    return list_of_query_exa_pairs\n\ndef format_exa_results_for_llm(list_of_query_exa_pairs):\n    print(f\"‚å®Ô∏è  Formatting Exa results for LLM\")\n    formatted_string = \"\"\n    for pair in list_of_query_exa_pairs:\n        formatted_string += f\"[{pair['subquery']}]:\\n\"\n        for result in pair['results']:\n            content = getattr(result, 'text', \"No text available\")\n            publish_date = getattr(result, 'published_date', \"No date available\")\n            url = getattr(result, 'url', \"No URL available\")\n            formatted_string += f\"URL: {url}\\nContent: {content}\\nPublish Date: {publish_date}\\n\"\n        formatted_string += \"\\n\"\n    return formatted_string\n\nasync def generate_report_from_exa_results(topic, list_of_query_exa_pairs):\n    print(f\"Generating report from Exa results for topic: {topic}\")\n    formatted_exa_content = format_exa_results_for_llm(list_of_query_exa_pairs)\n    content = (f\"Write a comprehensive and professional three-paragraph research report about {topic} based on the provided information. \"\n               f\"Include citations in the text using footnote notation ([citation #]), for example [2]. First provide the report, followed by a single `References` section \"\n               f\"that only lists the URLs (and their published date) used, in the format [#] <url>. For the published date, only include the month and year. \"\n               f\"Reset the citations index and ignore the order of citations in the provided information. Here is the information: {formatted_exa_content}.\")\n    try:\n        completion = await acompletion(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}],\n            stream=False\n        )\n        report = completion['choices'][0]['message']['content']\n    except Exception as e:\n        report = f\"Failed to generate report: {str(e)}\"\n    return report\n\ndef initialize_exa_client():\n    from exa_py import Exa\n    try:\n        exa_client = Exa(api_key=settings.exa_api_key)\n        return exa_client\n    except Exception as e:\n        print(f\"‚ö†Ô∏è Failed to initialize Exa client: {str(e)}\")\n        return None\n\n# For synchronous version if needed\ndef generate_subqueries_from_topic_sync(topic, num_subqueries=6):\n    print(f\"üåø Generating subqueries from topic: {topic}\")\n    content = f\"I'm going to give you a topic I want to research. I want you to generate {num_subqueries} interesting, diverse search queries that would be useful for generating a report on my main topic. Here is the main topic: {topic}.\"\n    try:\n        completion = openai.ChatCompletion.create(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}]\n        )\n        response_content = completion['choices'][0]['message']['content']\n        print(f\"Raw response content: {response_content}\")  # Print raw response for debugging\n        \n        # Split the response into individual lines and strip leading/trailing spaces and numbers\n        subqueries = []\n        for line in response_content.split('\\n'):\n            if line.strip():\n                # Attempt to split by \". \" and take the second part\n                try:\n                    subquery = line.strip(' \"').split('. ', 1)[1]\n                    subqueries.append(subquery)\n                except IndexError:\n                    print(f\"Skipping improperly formatted line: {line}\")\n        \n        # Output the parsed subqueries for debugging\n        print(f\"Parsed subqueries: {subqueries}\")\n        \n    except Exception as e:\n        print(f\"Unexpected error: {str(e)}\")  # Output unexpected error details\n        subqueries = [f\"Failed to generate subqueries: {str(e)}\"]\n    return subqueries\n\ndef generate_report_sync(topic):\n    print(f\"Starting report generation for topic: {topic}\")\n    subqueries = generate_subqueries_from_topic_sync(topic)\n    list_of_query_exa_pairs = exa_search_each_subquery(subqueries)\n    report = generate_report_from_exa_results_sync(topic, list_of_query_exa_pairs)\n    return report\n\ndef generate_report_from_exa_results_sync(topic, list_of_query_exa_pairs):\n    print(f\"Generating report from Exa results for topic: {topic}\")\n    formatted_exa_content = format_exa_results_for_llm(list_of_query_exa_pairs)\n    content = (f\"Write a comprehensive and professional three-paragraph research report about {topic} based on the provided information. \"\n               f\"Include citations in the text using footnote notation ([citation #]), for example [2]. First provide the report, followed by a single `References` section \"\n               f\"that only lists the URLs (and their published date) used, in the format [#] <url>. For the published date, only include the month and year. \"\n               f\"Reset the citations index and ignore the order of citations in the provided information. Here is the information: {formatted_exa_content}.\")\n    completion = openai.ChatCompletion.create(\n        model='gpt-4o',\n        messages=[{\"role\": \"user\", \"content\": content}]\n    )\n    report = completion.choices[0].message.content\n    return report\n"}
{"type": "source_file", "path": "project-root/app/models/report.py", "content": "from pydantic import BaseModel\n\nclass Report(BaseModel):\n    topic: str\n    content: str\n"}
{"type": "source_file", "path": "project-root/app/__init__.py", "content": "# This file initializes the app package\n"}
{"type": "source_file", "path": "project-root/app/models/__init__.py", "content": "# This file initializes the models package\n"}
{"type": "source_file", "path": "project-root/app/utils/exa_search.py", "content": "# project-root/app/utils/exa_search.py\n\nfrom exa_py import Exa\nfrom app.core.config import settings\nfrom datetime import datetime, timedelta\nfrom typing import Optional, List, Dict\n\n# Initialize the Exa client\nexa = Exa(api_key=settings.exa_api_key)\n\ndef search_exa(subqueries: list, api_key: str, start_published_date: Optional[str] = None, end_published_date: Optional[str] = None, include_domains: Optional[List[str]] = None, exclude_domains: Optional[List[str]] = None, highlights: Optional[Dict] = None, text: Optional[Dict] = None) -> list:\n    \"\"\"\n    Searches Exa service for each subquery using the provided API key with advanced search options.\n\n    Args:\n        subqueries (list): List of subqueries to search.\n        api_key (str): API key for the Exa service.\n        start_published_date (Optional[str]): Start date for published date filter.\n        end_published_date (Optional[str]): End date for published date filter.\n        include_domains (Optional[List[str]]): Domains to include in the search.\n        exclude_domains (Optional[List[str]]): Domains to exclude from the search.\n        highlights (Optional[Dict]): Configuration for highlights.\n        text (Optional[Dict]): Configuration for text content retrieval.\n\n    Returns:\n        list: List of search results.\n\n    Examples:\n        - Basic search: search_exa([\"query\"], \"api_key\")\n        - Search with date filters: search_exa([\"query\"], \"api_key\", start_published_date=\"2020-01-01\", end_published_date=\"2020-01-31\")\n        - Search with domain filters: search_exa([\"query\"], \"api_key\", include_domains=[\"example.com\"], exclude_domains=[\"example.net\"])\n        - Search with highlights and text content options: search_exa([\"query\"], \"api_key\", highlights={\"num_sentences\": 5}, text={\"include_html_tags\": True})\n    \"\"\"\n    results = []\n    one_week_ago = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n\n    for subquery in subqueries:\n        try:\n            search_response = exa.search_and_contents(\n                query=subquery,\n                num_results=5,\n                use_autoprompt=True,\n                start_published_date=start_published_date or one_week_ago,\n                end_published_date=end_published_date,\n                include_domains=include_domains,\n                exclude_domains=exclude_domains,\n                highlights=highlights,\n                text=text\n            )\n            results.append({'subquery': subquery, 'results': search_response.results})\n        except Exception as e:\n            print(f\"Error making API call to Exa for '{subquery}': {e}\")\n            results.append({'subquery': subquery, 'error': str(e)})\n    # print results for debugging subqueries\n    # print(f\"Search results for subqueries: {results}\")\n    return results\n\ndef advanced_search_exa(query: str, start_published_date: Optional[str] = None, end_published_date: Optional[str] = None, include_domains: Optional[List[str]] = None, exclude_domains: Optional[List[str]] = None, highlights: Optional[Dict] = None, text: Optional[Dict] = None) -> dict:\n    \"\"\"\n    Performs an advanced search on Exa with customizable options.\n\n    Args:\n        query (str): The search query.\n        start_published_date (Optional[str]): Start date for published date filter.\n        end_published_date (Optional[str]): End date for published date filter.\n        include_domains (Optional[List[str]]): Domains to include in the search.\n        exclude_domains (Optional[List[str]]): Domains to exclude from the search.\n        highlights (Optional[Dict]): Configuration for highlights.\n        text (Optional[Dict]): Configuration for text content retrieval.\n\n    Returns:\n        dict: The search results including any specified content retrieval options.\n\n    Examples:\n        - Advanced search with all options: advanced_search_exa(\"query\", start_published_date=\"2020-01-01\", end_published_date=\"2020-01-31\", include_domains=[\"example.com\"], exclude_domains=[\"example.net\"], highlights={\"num_sentences\": 5}, text={\"include_html_tags\": True})\n    \"\"\"\n    try:\n        search_response = exa.search_and_contents(\n            query=query,\n            num_results=5,\n            use_autoprompt=True,\n            start_published_date=start_published_date,\n            end_published_date=end_published_date,\n            include_domains=include_domains,\n            exclude_domains=exclude_domains,\n            highlights=highlights,\n            text=text\n        )\n        return {'query': query, 'results': search_response.results}\n    except Exception as e:\n        print(f\"Error making API call to Exa for '{query}': {e}\")\n        return {'query': query, 'error': str(e)}\n    \n\ndef find_similar_exa(url: str, num_results: Optional[int] = 10, include_domains: Optional[List[str]] = None, exclude_domains: Optional[List[str]] = None, start_crawl_date: Optional[str] = None, end_crawl_date: Optional[str] = None, start_published_date: Optional[str] = None, end_published_date: Optional[str] = None, category: Optional[str] = None) -> dict:\n    \"\"\"\n    Finds similar links to the provided URL using the Exa service with customizable options.\n\n    Args:\n        url (str): The URL to find similar links for.\n        num_results (Optional[int]): Number of search results to return.\n        include_domains (Optional[List[str]]): Domains to include in the search.\n        exclude_domains (Optional[List[str]]): Domains to exclude from the search.\n        start_crawl_date (Optional[str]): Start date for crawl date filter.\n        end_crawl_date (Optional[str]): End date for crawl date filter.\n        start_published_date (Optional[str]): Start date for published date filter.\n        end_published_date (Optional[str]): End date for published date filter.\n        category (Optional[str]): Category to focus on.\n        contents (Optional[Dict]): Configuration for contents retrieval.\n\n    Returns:\n        dict: The search results including any specified content retrieval options.\n    \"\"\"\n    try:\n        search_response = exa.find_similar(\n            url=url,\n            num_results=num_results,\n            include_domains=include_domains,\n            exclude_domains=exclude_domains,\n            start_crawl_date=start_crawl_date,\n            end_crawl_date=end_crawl_date,\n            start_published_date=start_published_date,\n            end_published_date=end_published_date,\n            category=category\n        )\n        return {'url': url, 'results': search_response.results}\n    except Exception as e:\n        print(f\"Error making API call to Exa for '{url}': {e}\")\n        return {'url': url, 'error': str(e)}"}
{"type": "source_file", "path": "project-root/app/services/report_generator.py", "content": "import os\nimport json\nimport time\nimport asyncio\nimport aiohttp\n\nfrom datetime import datetime, timedelta\nfrom typing import Optional, List, Dict\nfrom litellm import acompletion\nfrom app.core.config import settings\nfrom app.utils.exa_search import search_exa\n\n# Set up API keys using environment variables\nos.environ[\"OPENAI_API_KEY\"] = os.getenv('OPENAI_API_KEY', settings.openai_api_key)\n\nasync def generate_report(topic: str) -> str:\n    print(f\"Starting report generation for topic: {topic}\")\n    subqueries = await generate_subqueries_from_topic(topic)\n    list_of_query_exa_pairs = await exa_search_each_subquery(subqueries)\n    report = await generate_report_from_exa_results(topic, list_of_query_exa_pairs)\n    return report\n\nasync def generate_report_without_exa(topic):\n    print(f\"üöÄ Generating report without Exa for topic: {topic}\")\n    content = f\"Write a comprehensive and professional three-paragraph research report about {topic}. Include citations with source, month, and year.\"\n    try:\n        completion = await acompletion(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}],\n            stream=False,\n            timeout=600  \n        )\n        report = completion['choices'][0]['message']['content']\n    except Exception as e:\n        report = f\"Failed to generate report: {str(e)}\"\n    return report\n\nasync def generate_subqueries_from_topic(topic, num_subqueries=10):\n    print(f\"üåø Generating subqueries from topic: {topic}\")\n    content = f\"I'm going to give you a topic I want to research. I want you to generate {num_subqueries} interesting, diverse search queries that would be useful for generating a report on my main topic. Here is the main topic: {topic}.\"\n    try:\n        completion = await acompletion(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}],\n            stream=False,\n            timeout=600 \n        )\n        response_content = completion['choices'][0]['message']['content']\n        print(f\"Raw response content: {response_content}\")  # Print raw response for debugging\n        \n        # Split the response into individual lines and strip leading/trailing spaces and numbers\n        subqueries = []\n        for line in response_content.split('\\n'):\n            line = line.strip()\n            if line and line[0].isdigit():\n                # Attempt to split by \". \" and take the second part\n                try:\n                    subquery = line.split('. ', 1)[1].strip(' \"')\n                    subqueries.append(subquery)\n                except IndexError:\n                    print(f\"Skipping improperly formatted line: {line}\")\n        \n        # Output the parsed subqueries for debugging\n        print(f\"Parsed subqueries: {subqueries}\")\n        \n    except Exception as e:\n        print(f\"Unexpected error: {str(e)}\")  # Output unexpected error details\n        subqueries = [f\"Failed to generate subqueries: {str(e)}\"]\n    return subqueries\n\nasync def exa_search_each_subquery(subqueries):\n    print(f\"‚åõ Searching each subquery\")\n    list_of_query_exa_pairs = []\n\n    async def perform_search(query, retries=5, delay=2):\n        \"\"\"Helper function to perform search with retries and exponential backoff.\"\"\"\n        for attempt in range(retries):\n            try:\n                # Perform the search using Exa API\n                search_response = search_exa(\n                    subqueries=[query],\n                    api_key=settings.exa_api_key\n                )\n                if search_response and 'results' in search_response[0]:\n                    return search_response[0]\n                else:\n                    print(f\"‚ö†Ô∏è No data found for subquery: {query}\")\n                    return None\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Attempt {attempt + 1} failed for query '{query}': {str(e)}\")\n                if \"502\" in str(e) and attempt < retries - 1:\n                    backoff = delay * (2 ** attempt)  # Exponential backoff\n                    print(f\"Retrying in {backoff} seconds...\")\n                    await asyncio.sleep(backoff)\n                else:\n                    print(f\"‚ö†Ô∏è All {retries} attempts failed for query '{query}'\")\n                    return None\n\n    tasks = []\n    for query in subqueries:\n        if \"Failed to generate subqueries\" in query:\n            print(f\"‚ö†Ô∏è Skipping invalid subquery: {query}\")\n            continue\n\n        print(f\"üîç Searching for subquery: {query}\")\n        tasks.append(perform_search(query))\n\n    results = await asyncio.gather(*tasks)\n\n    for query, search_response in zip(subqueries, results):\n        if search_response and 'results' in search_response:\n            print(f\"‚úÖ Search successful for subquery: {query}\")\n            list_of_query_exa_pairs.append({\n                'subquery': query,\n                'results': search_response['results']\n            })\n\n    print(f\"üèÅ Completed search for all subqueries\")\n    return list_of_query_exa_pairs\n\ndef format_exa_results_for_llm(list_of_query_exa_pairs):\n    print(f\"‚å®Ô∏è  Formatting Exa results for LLM\")\n    formatted_string = \"\"\n    for pair in list_of_query_exa_pairs:\n        formatted_string += f\"[{pair['subquery']}]:\\n\"\n        for result in pair['results']:\n            content = getattr(result, 'text', \"No text available\")\n            publish_date = getattr(result, 'published_date', \"No date available\")\n            url = getattr(result, 'url', \"No URL available\")\n            formatted_string += f\"URL: {url}\\nContent: {content}\\nPublish Date: {publish_date}\\n\"\n        formatted_string += \"\\n\"\n    return formatted_string\n\nasync def generate_report_from_exa_results(topic, list_of_query_exa_pairs):\n    print(f\"Generating report from Exa results for topic: {topic}\")\n    formatted_exa_content = format_exa_results_for_llm(list_of_query_exa_pairs)\n    content = (f\"Write a comprehensive and professional three-paragraph research report about {topic} based on the provided information. \"\n               f\"Include citations in the text using footnote notation ([citation #]), for example [2]. First provide the report, followed by a single `References` section \"\n               f\"that only lists the URLs (and their published date) used, in the format [#] <url>. For the published date, only include the month and year. \"\n               f\"Reset the citations index and ignore the order of citations in the provided information. Here is the information: {formatted_exa_content}.\")\n    try:\n        completion = await acompletion(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}],\n            stream=False,\n            timeout=600 \n        )\n        report = completion['choices'][0]['message']['content']\n    except Exception as e:\n        report = f\"Failed to generate report: {str(e)}\"\n    return report\n\nasync def generate_advanced_subqueries_from_topic(topic, subqueries_prompt, num_subqueries=20):\n    print(f\"üåø Generating {num_subqueries} advanced subqueries from topic: {topic}\")\n    content = f\"{subqueries_prompt} Here is the main topic: {topic}. Generate {num_subqueries} subqueries.\"\n    try:\n        completion = await acompletion(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}],\n            stream=False,\n            timeout=600 \n        )\n        response_content = completion['choices'][0]['message']['content']\n        print(f\"Raw response content: {response_content}\")  # Print raw response for debugging\n        \n        # Split the response into individual lines and strip leading/trailing spaces and numbers\n        subqueries = []\n        for line in response_content.split('\\n'):\n            line = line.strip()\n            if line and line[0].isdigit():\n                # Attempt to split by \". \" and take the second part\n                try:\n                    subquery = line.split('. ', 1)[1].strip(' \"')\n                    subqueries.append(subquery)\n                except IndexError:\n                    print(f\"Skipping improperly formatted line: {line}\")\n        \n        # Output the parsed subqueries for debugging\n        print(f\"Parsed subqueries: {subqueries}\")\n        \n    except Exception as e:\n        print(f\"Unexpected error: {str(e)}\")  # Output unexpected error details\n        subqueries = [f\"Failed to generate subqueries: {str(e)}\"]\n    return subqueries\n\n\nasync def generate_advanced_report_from_exa_results(topic, report_prompt, list_of_query_exa_pairs):\n    print(f\"Generating advanced report from Exa results for topic: {topic}\")\n    formatted_exa_content = format_exa_results_for_llm(list_of_query_exa_pairs)\n    content = (\n        f\"{report_prompt} \"\n        f\"Here is the information: {formatted_exa_content}.\"\n    )\n\n    try:\n        completion = await acompletion(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}],\n            stream=False,\n            timeout=6000 \n        )\n        report = completion['choices'][0]['message']['content']\n    except Exception as e:\n        report = f\"Failed to generate report: {str(e)}\"\n    return report\n\nasync def generate_advanced_report(\n    query: str,\n    primary_prompt: str,\n    subqueries_prompt: str,\n    report_prompt: str,\n    start_published_date: Optional[str],\n    end_published_date: Optional[str],\n    include_domains: Optional[List[str]],\n    exclude_domains: Optional[List[str]],\n    highlights: Optional[Dict],\n    text: Optional[Dict],\n    num_subqueries: int\n):\n    print(f\"Generating advanced report for query: {query}\")\n\n    # Step 1: Generate Subqueries\n    subqueries = await generate_advanced_subqueries_from_topic(query, subqueries_prompt, num_subqueries)\n    \n    # Step 2: Perform Exa Search for Each Subquery\n    list_of_query_exa_pairs = await exa_search_each_subquery(subqueries)\n\n    # Step 3: Generate Report from Exa Results using provided report_prompt\n    report = await generate_advanced_report_from_exa_results(query, report_prompt, list_of_query_exa_pairs)\n    \n    return report\n\n\ndef initialize_exa_client():\n    from exa_py import Exa\n    try:\n        exa_client = Exa(api_key=settings.exa_api_key)\n        return exa_client\n    except Exception as e:\n        print(f\"‚ö†Ô∏è Failed to initialize Exa client: {str(e)}\")\n        return None\n\n# For synchronous version if needed\ndef generate_subqueries_from_topic_sync(topic, num_subqueries=10):\n    print(f\"üåø Generating subqueries from topic: {topic}\")\n    content = f\"I'm going to give you a topic I want to research. I want you to generate {num_subqueries} interesting, diverse search queries that would be useful for generating a report on my main topic. Here is the main topic: {topic}.\"\n    try:\n        completion = openai.ChatCompletion.create(\n            model='gpt-4o',\n            messages=[{\"role\": \"user\", \"content\": content}]\n        )\n        response_content = completion['choices'][0]['message']['content']\n        print(f\"Raw response content: {response_content}\")  # Print raw response for debugging\n        \n        # Split the response into individual lines and strip leading/trailing spaces and numbers\n        subqueries = []\n        for line in response_content.split('\\n'):\n            if line.strip():\n                # Attempt to split by \". \" and take the second part\n                try:\n                    subquery = line.strip(' \"').split('. ', 1)[1]\n                    subqueries.append(subquery)\n                except IndexError:\n                    print(f\"Skipping improperly formatted line: {line}\")\n        \n        # Output the parsed subqueries for debugging\n        print(f\"Parsed subqueries: {subqueries}\")\n        \n    except Exception as e:\n        print(f\"Unexpected error: {str(e)}\")  # Output unexpected error details\n        subqueries = [f\"Failed to generate subqueries: {str(e)}\"]\n    return subqueries\n\ndef generate_report_sync(topic):\n    print(f\"Starting report generation for topic: {topic}\")\n    subqueries = generate_subqueries_from_topic_sync(topic)\n    list_of_query_exa_pairs = exa_search_each_subquery(subqueries)\n    report = generate_report_from_exa_results_sync(topic, list_of_query_exa_pairs)\n    return report\n\ndef generate_report_from_exa_results_sync(topic, list_of_query_exa_pairs):\n    print(f\"Generating report from Exa results for topic: {topic}\")\n    formatted_exa_content = format_exa_results_for_llm(list_of_query_exa_pairs)\n    formatted_exa_content = format_exa_results_for_llm(list_of_query_exa_pairs)\n    content = (f\"Write a comprehensive and professional three-paragraph research report about {topic} based on the provided information. \"\n               f\"Include citations in the text using footnote notation ([citation #]), for example [2]. First provide the report, followed by a single `References` section \"\n               f\"that only lists the URLs (and their published date) used, in the format [#] <url>. For the published date, only include the month and year. \"\n               f\"Reset the citations index and ignore the order of citations in the provided information. Here is the information: {formatted_exa_content}.\"\n               f\"only use data, never reference anything not directly provided.\")\n    completion = openai.ChatCompletion.create(\n        model='gpt-4o',\n        messages=[{\"role\": \"user\", \"content\": content}]\n    )\n    report = completion.choices[0].message.content\n    return report\n\n# Ensure to call the function within an async context\n# Example usage:\n# asyncio.run(generate_report(\"latest ai jobs in Toronto\"))"}
{"type": "source_file", "path": "setup.py", "content": "from setuptools import setup, find_packages\nfrom pathlib import Path\n\ndef read_long_description():\n    this_directory = Path(__file__).parent\n    long_description = (this_directory / \"README.md\").read_text()\n    return long_description\n\nsetup(\n    name='agentic_reports',\n    version='0.1.5',\n    packages=find_packages(where='project-root'),\n    package_dir={'': 'project-root'},\n    py_modules=['start'],  # Include the start module\n    install_requires=[\n        'twine',\n        'setuptools',\n        'wheel',\n        'flake8',\n        'black',\n        'pytest',\n        'pip-upgrader',\n        'fastapi',\n        'uvicorn',\n        'pandas',\n        'pydantic',\n        'exa_py',\n        'pydantic-settings',\n        'virtualenv',\n        'litellm'\n    ],\n    python_requires='>=3.10',\n    author='rUv',\n    author_email='null@ruv.net',\n    description='Agent Reporting using Exa.ai API.',\n    long_description=read_long_description(),\n    long_description_content_type='text/markdown',\n    url='https://github.com/ruvnet/agentic-reports',\n    license='Apache License 2.0',\n    classifiers=[\n        'Development Status :: 3 - Alpha',\n        'Intended Audience :: Developers',\n        'Topic :: Software Development :: Libraries :: Application Frameworks',\n        'License :: OSI Approved :: Apache Software License',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.10',\n    ],\n    entry_points={\n        'console_scripts': [\n            'agentic-reports=start:main',\n        ],\n    },\n)\n"}
{"type": "source_file", "path": "start.py", "content": "import os\nimport subprocess\n\ndef prompt_for_api_key(env_var_name):\n    api_key = input(f\"Enter your {env_var_name}: \")\n    os.environ[env_var_name] = api_key\n\ndef main():\n    # Check for OPENAI_API_KEY\n    if not os.getenv('OPENAI_API_KEY'):\n        prompt_for_api_key('OPENAI_API_KEY')\n\n    # Check for EXA_API_KEY\n    if not os.getenv('EXA_API_KEY'):\n        prompt_for_api_key('EXA_API_KEY')\n\n    # Run the shell script\n    subprocess.run(['bash', './start.sh'], check=True)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "project-root/start.py", "content": "import os\nimport subprocess\nimport sys\nimport importlib.util\n\ndef check_and_install_python3_10():\n    try:\n        # Check if Python 3.10 is installed\n        subprocess.run(['python3.10', '--version'], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        # Python 3.10 is not installed, attempt to install it\n        print(\"‚ùó Python 3.10 is not installed. Attempting to install Python 3.10...\")\n        try:\n            if sys.platform.startswith('linux'):\n                subprocess.run(['sudo', 'apt-get', 'update'], check=True)\n                subprocess.run(['sudo', 'apt-get', 'install', '-y', 'python3.10', 'python3.10-venv', 'python3.10-dev'], check=True)\n                print(\"‚úÖ Python 3.10 installed successfully.\")\n            else:\n                print(\"‚ùó Automatic installation is not supported on this OS. Please install Python 3.10 manually.\")\n                sys.exit(1)\n        except Exception as e:\n            print(f\"‚ùó Failed to install Python 3.10: {e}\")\n            sys.exit(1)\n\ndef check_and_install_requirements(python_executable):\n    print(\"üì¶ Installing required packages...\")\n    required_packages = ['fastapi', 'pydantic', 'pandas', 'exa_py', 'pytest', 'uvicorn', 'pydantic-settings', 'litellm']\n    subprocess.run([python_executable, '-m', 'pip', 'install'] + required_packages, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    print(\"‚úÖ Packages installed.\")\n\ndef prompt_for_api_key(env_var_name):\n    api_key = input(f\"üîë Enter your {env_var_name}: \")\n    os.environ[env_var_name] = api_key\n    subprocess.run(['export', f'{env_var_name}={api_key}'], shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n    print(f\"‚úÖ {env_var_name} set.\")\n\ndef main():\n    print(r\"\"\"\n _____             _   _         _____                 _       \n|  _  |___ ___ ___| |_|_|___ ___| __  |___ ___ ___ ___| |_ ___ \n|     | . | -_|   |  _| |  _|___|    -| -_| . | . |  _|  _|_ -|\n|__|__|_  |___|_|_|_| |_|___|   |__|__|___|  _|___|_| |_| |___|\n      |___|                               |_|                  \n\nA Comprehensive Python Library for Generating Research Reports\n    \"\"\")\n\n    print(\"üöÄ Starting the Agentic Reports application setup and server...\")\n\n    # Check for Python 3.10 installation\n    check_and_install_python3_10()\n\n    # Check for OPENAI_API_KEY\n    if not os.getenv('OPENAI_API_KEY'):\n        prompt_for_api_key('OPENAI_API_KEY')\n\n    # Check for EXA_API_KEY\n    if not os.getenv('EXA_API_KEY'):\n        prompt_for_api_key('EXA_API_KEY')\n\n    # Get the directory of the current script\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    print(f\"üìÇ Script directory: {script_dir}\")\n\n    # Set PYTHONPATH to include the project root directory\n    os.environ['PYTHONPATH'] = os.environ.get('PYTHONPATH', '') + f':{script_dir}'\n    print(\"‚úÖ PYTHONPATH set.\")\n\n    # Ensure the correct working directory\n    os.chdir(script_dir)\n    print(\"‚úÖ Working directory set.\")\n\n    # Create a virtual environment using Python 3.10 if it doesn't exist\n    venv_dir = os.path.join(script_dir, 'venv')\n    if not os.path.exists(venv_dir):\n        print(\"üêç Creating virtual environment with Python 3.10...\")\n        subprocess.run(['python3.10', '-m', 'venv', 'venv'], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        print(\"‚úÖ Virtual environment created.\")\n\n    # Use the Python executable from the virtual environment\n    venv_python = os.path.join(venv_dir, 'bin', 'python')\n    if sys.platform == 'win32':\n        venv_python = os.path.join(venv_dir, 'Scripts', 'python')\n    print(f\"üêç Using Python executable: {venv_python}\")\n\n    # Check and install required packages\n    check_and_install_requirements(venv_python)\n\n    # Run Uvicorn with the necessary parameters and show its output\n    print(\"üåê Starting Uvicorn server...\")\n    subprocess.run([venv_python, '-m', 'uvicorn', 'app.main:app', '--reload', '--host', '0.0.0.0', '--port', '8000', '--reload-dir', script_dir])\n    print(\"üöÄ Uvicorn server started.\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "project-root/app/api/endpoints.py", "content": "# endpoints.py is the place where you define the FastAPI endpoints. \n\nfrom fastapi import APIRouter, HTTPException, status, Request, Body\nfrom app.services.report_generator import generate_report, generate_subqueries_from_topic, exa_search_each_subquery\nfrom app.core.config import settings\nfrom app.utils.exa_search import advanced_search_exa, find_similar_exa\nfrom typing import Optional, List, Dict\nfrom .advanced_reports import router as advanced_reports_router\n\nrouter = APIRouter()\n\n@router.post(\"/generate-report\")\nasync def generate_report_endpoint(topic: str, request: Request):\n    try:\n        report = await generate_report(topic)\n        return {\"report\": report}\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n\n@router.post(\"/generate-subqueries\")\nasync def generate_subqueries_endpoint(\n    topic: str = Body(..., embed=True, example=\"Latest AI jobs in Toronto\"),\n    num_subqueries: int = Body(10, embed=True, example=10)\n):\n    try:\n        subqueries = await generate_subqueries_from_topic(topic, num_subqueries)\n        return {\"subqueries\": subqueries}\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n\n@router.post(\"/search-subqueries\")\nasync def search_subqueries_endpoint(\n    subqueries: List[str] = Body(..., embed=True, example=[\"AI job market in Canada\", \"Top AI companies hiring in Toronto\"])\n):\n    try:\n        list_of_query_exa_pairs = await exa_search_each_subquery(subqueries)\n        return {\"results\": list_of_query_exa_pairs}\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n\n@router.post(\"/advanced-search\")\nasync def advanced_search_endpoint(\n    query: str = Body(\"New York City condos\", embed=True),\n    start_published_date: Optional[str] = Body(\"2023-01-01\", embed=True),\n    end_published_date: Optional[str] = Body(\"2023-12-31\", embed=True),\n    include_domains: Optional[List[str]] = Body(None, embed=True),\n    exclude_domains: Optional[List[str]] = Body(None, embed=True),\n    highlights: Optional[Dict] = Body({\"num_sentences\": 3}, embed=True),\n    text: Optional[Dict] = Body({\"include_html_tags\": False}, embed=True)\n):\n    try:\n        # Ensure only one of include_domains or exclude_domains is specified\n        if include_domains and exclude_domains:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Only one of include_domains or exclude_domains can be specified.\"\n            )\n\n        results = advanced_search_exa(\n            query=query,\n            start_published_date=start_published_date,\n            end_published_date=end_published_date,\n            include_domains=include_domains,\n            exclude_domains=exclude_domains,\n            highlights=highlights,\n            text=text\n        )\n        return {\"results\": results}\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n\n@router.post(\"/find-similar-links\", summary=\"Find similar links to the provided URL\")\nasync def find_similar_links_endpoint(\n    url: str = Body(..., embed=True, example=\"https://drudgereport.com\"),\n    num_results: Optional[int] = Body(10, embed=True, example=10),\n    include_domains: Optional[List[str]] = Body(None, embed=True, example=[\"example.com\"]),\n    exclude_domains: Optional[List[str]] = Body(None, embed=True, example=[\"excluded.com\"]),\n    start_crawl_date: Optional[str] = Body(None, embed=True, example=\"2023-01-01\"),\n    end_crawl_date: Optional[str] = Body(None, embed=True, example=\"2023-12-31\"),\n    start_published_date: Optional[str] = Body(None, embed=True, example=\"2023-01-01\"),\n    end_published_date: Optional[str] = Body(None, embed=True, example=\"2023-12-31\"),\n    category: Optional[str] = Body(None, embed=True, example=\"news\")\n):\n    try:\n        # Ensure only one of include_domains or exclude_domains is specified\n        if include_domains and exclude_domains:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Only one of include_domains or exclude_domains can be specified.\"\n            )\n\n        results = find_similar_exa(\n            url=url,\n            num_results=num_results,\n            include_domains=include_domains,\n            exclude_domains=exclude_domains,\n            start_crawl_date=start_crawl_date,\n            end_crawl_date=end_crawl_date,\n            start_published_date=start_published_date,\n            end_published_date=end_published_date,\n            category=category\n        )\n        return {\"results\": results}\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)) \n\n# Include the advanced_reports router\nrouter.include_router(advanced_reports_router, prefix=\"/api/v1\", tags=[\"advanced-reports\"])"}
{"type": "source_file", "path": "project-root/app/utils/__init__.py", "content": "# This file initializes the utils sub-package\n"}

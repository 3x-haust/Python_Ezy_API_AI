{"repo_info": {"repo_name": "FastAPI-PgStarterKit", "repo_owner": "bibektimilsina000", "repo_url": "https://github.com/bibektimilsina000/FastAPI-PgStarterKit"}}
{"type": "test_file", "path": "app/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "app/tests/api/__init__.py", "content": ""}
{"type": "test_file", "path": "app/tests/api/api_v1/__init__.py", "content": ""}
{"type": "test_file", "path": "app/tests/utils/__init__.py", "content": ""}
{"type": "test_file", "path": "app/tests/settings/test_settings.py", "content": "from io import StringIO\nfrom typing import Any\nimport os\n\nfrom dotenv import load_dotenv\n\nfrom app.core.config import Settings\nfrom app.tests.utils.utils import random_email, random_lower_string, random_url\n\n\ndef make_settings(env_items: dict[str, Any]):\n    os.environ.clear()\n    env_file_settings = StringIO()\n    for key, value in env_items.items():\n        env_file_settings.write(f\"{key}={value}\\n\")\n    env_file_settings.seek(0)\n    load_dotenv(stream=env_file_settings)\n    return Settings()\n\n\nMANDATORY = {\n    \"FIRST_SUPERUSER_PASSWORD\": random_lower_string(),\n    \"FIRST_SUPERUSER\": random_email(),\n    \"POSTGRES_DB\": random_lower_string(),\n    \"POSTGRES_PASSWORD\": random_lower_string(),\n    \"POSTGRES_SERVER\": random_lower_string(),\n    \"POSTGRES_USER\": random_lower_string(),\n    \"PROJECT_NAME\": random_lower_string(),\n    \"SERVER_HOST\": random_url(),\n}\n\n\ndef test_mandatory_and_defaults() -> None:\n    settings = make_settings(MANDATORY)\n    for key, value in MANDATORY.items():\n        assert str(getattr(settings, key)) == str(value)\n    assert settings.EMAIL_TEMPLATES_DIR == \"/app/app/email-templates/build\"\n    assert settings.EMAILS_ENABLED is False\n    assert settings.EMAILS_FROM_EMAIL is None\n    assert settings.EMAILS_FROM_NAME == settings.PROJECT_NAME\n    assert settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS == 48\n    assert settings.EMAIL_TEST_USER == \"test@example.com\"\n    assert settings.EMAIL_TEMPLATES_DIR == \"/app/app/email-templates/build\"\n\n\ndef test_assemble_db_connection() -> None:\n    settings = make_settings(MANDATORY)\n    assert str(settings.SQLALCHEMY_DATABASE_URI) == (\n        f\"postgresql://{settings.POSTGRES_USER}:\"\n        f\"{settings.POSTGRES_PASSWORD}@{settings.POSTGRES_SERVER}/\"\n        f\"{settings.POSTGRES_DB}\"\n    )\n\n\ndef test_backend_cors_origins() -> None:\n    settings = make_settings(\n        MANDATORY\n        | {\"BACKEND_CORS_ORIGINS\": '[\"http://localhost\", \"http://localhost:3000\"]'}\n    )\n    assert [str(item) for item in settings.BACKEND_CORS_ORIGINS] == [\n        \"http://localhost/\",\n        \"http://localhost:3000/\",\n    ]\n\n\ndef test_email_enabled() -> None:\n    settings = make_settings(\n        MANDATORY\n        | {\n            \"SMTP_HOST\": \"www.example.com\",\n            \"SMTP_PORT\": 25,\n            \"EMAILS_FROM_EMAIL\": random_email(),\n        }\n    )\n    assert settings.EMAILS_ENABLED is True\n"}
{"type": "test_file", "path": "app/tests/crud/test_item.py", "content": "from sqlalchemy.orm import Session\n\nfrom app import crud\nfrom app.schemas.item import ItemCreate, ItemUpdate\nfrom app.tests.utils.user import create_random_user\nfrom app.tests.utils.utils import random_lower_string\n\n\ndef test_create_item(db: Session) -> None:\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    user = create_random_user(db)\n    item = crud.item.create_with_owner(db=db, obj_in=item_in, owner_id=user.id)\n    assert item.title == title\n    assert item.description == description\n    assert item.owner_id == user.id\n\n\ndef test_get_item(db: Session) -> None:\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    user = create_random_user(db)\n    item = crud.item.create_with_owner(db=db, obj_in=item_in, owner_id=user.id)\n    stored_item = crud.item.get(db=db, id=item.id)\n    assert stored_item\n    assert item.id == stored_item.id\n    assert item.title == stored_item.title\n    assert item.description == stored_item.description\n    assert item.owner_id == stored_item.owner_id\n\n\ndef test_update_item(db: Session) -> None:\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    user = create_random_user(db)\n    item = crud.item.create_with_owner(db=db, obj_in=item_in, owner_id=user.id)\n    description2 = random_lower_string()\n    item_update = ItemUpdate(description=description2)\n    item2 = crud.item.update(db=db, db_obj=item, obj_in=item_update)\n    assert item.id == item2.id\n    assert item.title == item2.title\n    assert item2.description == description2\n    assert item.owner_id == item2.owner_id\n\n\ndef test_delete_item(db: Session) -> None:\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    user = create_random_user(db)\n    item = crud.item.create_with_owner(db=db, obj_in=item_in, owner_id=user.id)\n    item2 = crud.item.remove(db=db, id=item.id)\n    item3 = crud.item.get(db=db, id=item.id)\n    assert item3 is None\n    assert item2.id == item.id\n    assert item2.title == title\n    assert item2.description == description\n    assert item2.owner_id == user.id\n"}
{"type": "test_file", "path": "app/tests/utils/user.py", "content": "from typing import Dict\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\n\nfrom app import crud\nfrom app.core.config import settings\nfrom app.models.user import User\nfrom app.schemas.user import UserCreate, UserUpdate\nfrom app.tests.utils.utils import random_email, random_lower_string\n\n\ndef user_authentication_headers(\n    *, client: TestClient, email: str, password: str\n) -> Dict[str, str]:\n    data = {\"username\": email, \"password\": password}\n\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=data)\n    response = r.json()\n    auth_token = response[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    return headers\n\n\ndef create_random_user(db: Session) -> User:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(username=email, email=email, password=password)\n    user = crud.user.create(db=db, obj_in=user_in)\n    return user\n\n\ndef authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> Dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.user.get_by_email(db, email=email)\n    if not user:\n        user_in_create = UserCreate(username=email, email=email, password=password)\n        user = crud.user.create(db, obj_in=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        user = crud.user.update(db, db_obj=user, obj_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)\n"}
{"type": "test_file", "path": "app/tests/utils/item.py", "content": "from typing import Optional\n\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, models\nfrom app.schemas.item import ItemCreate\nfrom app.tests.utils.user import create_random_user\nfrom app.tests.utils.utils import random_lower_string\n\n\ndef create_random_item(db: Session, *, owner_id: Optional[int] = None) -> models.Item:\n    if owner_id is None:\n        user = create_random_user(db)\n        owner_id = user.id\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description, id=id)\n    return crud.item.create_with_owner(db=db, obj_in=item_in, owner_id=owner_id)\n"}
{"type": "test_file", "path": "app/tests/conftest.py", "content": "from typing import Dict, Generator\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\n\nfrom app.core.config import settings\nfrom app.db.session import SessionLocal\nfrom app.main import app\nfrom app.tests.utils.user import authentication_token_from_email\nfrom app.tests.utils.utils import get_superuser_token_headers\n\n\n@pytest.fixture(scope=\"session\")\ndef db() -> Generator:\n    yield SessionLocal()\n\n\n@pytest.fixture(scope=\"module\")\ndef client() -> Generator:\n    with TestClient(app) as c:\n        yield c\n\n\n@pytest.fixture(scope=\"module\")\ndef superuser_token_headers(client: TestClient) -> Dict[str, str]:\n    return get_superuser_token_headers(client)\n\n\n@pytest.fixture(scope=\"module\")\ndef normal_user_token_headers(client: TestClient, db: Session) -> Dict[str, str]:\n    return authentication_token_from_email(\n        client=client, email=settings.EMAIL_TEST_USER, db=db\n    )\n"}
{"type": "test_file", "path": "app/tests/api/api_v1/test_login.py", "content": "from typing import Dict\n\nfrom fastapi.testclient import TestClient\n\nfrom app.core.config import settings\n\n\ndef test_get_access_token(client: TestClient) -> None:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    assert r.status_code == 200\n    assert \"access_token\" in tokens\n    assert tokens[\"access_token\"]\n\n\ndef test_use_access_token(\n    client: TestClient, superuser_token_headers: Dict[str, str]\n) -> None:\n    r = client.post(\n        f\"{settings.API_V1_STR}/login/test-token\", headers=superuser_token_headers,\n    )\n    result = r.json()\n    assert r.status_code == 200\n    assert \"email\" in result\n"}
{"type": "test_file", "path": "app/tests/crud/test_user.py", "content": "from fastapi.encoders import jsonable_encoder\nfrom sqlalchemy.orm import Session\n\nfrom app import crud\nfrom app.core.security import verify_password\nfrom app.schemas.user import UserCreate, UserUpdate\nfrom app.tests.utils.utils import random_email, random_lower_string\n\n\ndef test_create_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.user.create(db, obj_in=user_in)\n    assert user.email == email\n    assert hasattr(user, \"hashed_password\")\n\n\ndef test_authenticate_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.user.create(db, obj_in=user_in)\n    authenticated_user = crud.user.authenticate(db, email=email, password=password)\n    assert authenticated_user\n    assert user.email == authenticated_user.email\n\n\ndef test_not_authenticate_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user = crud.user.authenticate(db, email=email, password=password)\n    assert user is None\n\n\ndef test_check_if_user_is_active(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.user.create(db, obj_in=user_in)\n    is_active = crud.user.is_active(user)\n    assert is_active is True\n\n\ndef test_check_if_user_is_active_inactive(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password, disabled=True)\n    user = crud.user.create(db, obj_in=user_in)\n    is_active = crud.user.is_active(user)\n    assert is_active\n\n\ndef test_check_if_user_is_superuser(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.user.create(db, obj_in=user_in)\n    is_superuser = crud.user.is_superuser(user)\n    assert is_superuser is True\n\n\ndef test_check_if_user_is_superuser_normal_user(db: Session) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.user.create(db, obj_in=user_in)\n    is_superuser = crud.user.is_superuser(user)\n    assert is_superuser is False\n\n\ndef test_get_user(db: Session) -> None:\n    password = random_lower_string()\n    username = random_email()\n    user_in = UserCreate(email=username, password=password, is_superuser=True)\n    user = crud.user.create(db, obj_in=user_in)\n    user_2 = crud.user.get(db, id=user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert jsonable_encoder(user) == jsonable_encoder(user_2)\n\n\ndef test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.user.create(db, obj_in=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    crud.user.update(db, db_obj=user, obj_in=user_in_update)\n    user_2 = crud.user.get(db, id=user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)\n"}
{"type": "test_file", "path": "app/tests/crud/__init__.py", "content": ""}
{"type": "test_file", "path": "app/tests/api/api_v1/test_items.py", "content": "from fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\n\nfrom app.core.config import settings\nfrom app.tests.utils.item import create_random_item\n\n\ndef test_create_item(\n    client: TestClient, superuser_token_headers: dict, db: Session\n) -> None:\n    data = {\"title\": \"Foo\", \"description\": \"Fighters\"}\n    response = client.post(\n        f\"{settings.API_V1_STR}/items/\", headers=superuser_token_headers, json=data,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert content[\"title\"] == data[\"title\"]\n    assert content[\"description\"] == data[\"description\"]\n    assert \"id\" in content\n    assert \"owner_id\" in content\n\n\ndef test_read_item(\n    client: TestClient, superuser_token_headers: dict, db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/{item.id}\", headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert content[\"title\"] == item.title\n    assert content[\"description\"] == item.description\n    assert content[\"id\"] == item.id\n    assert content[\"owner_id\"] == item.owner_id\n"}
{"type": "test_file", "path": "app/tests/utils/utils.py", "content": "import random\nimport string\nfrom typing import Dict\n\nfrom fastapi.testclient import TestClient\n\nfrom app.core.config import settings\n\n\ndef random_lower_string() -> str:\n    return \"\".join(random.choices(string.ascii_lowercase, k=32))\n\n\ndef random_email() -> str:\n    return f\"{random_lower_string()}@{random_lower_string()}.com\"\n\n\ndef random_url() -> str:\n    return f\"https://{random_lower_string()}.com/\"\n\n\ndef get_superuser_token_headers(client: TestClient) -> Dict[str, str]:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n    return headers\n"}
{"type": "test_file", "path": "app/tests/api/api_v1/test_users.py", "content": "from typing import Dict\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\n\nfrom app import crud\nfrom app.core.config import settings\nfrom app.schemas.user import UserCreate\nfrom app.tests.utils.utils import random_email, random_lower_string\n\n\ndef test_get_users_superuser_me(\n    client: TestClient, superuser_token_headers: Dict[str, str]\n) -> None:\n    r = client.get(f\"{settings.API_V1_STR}/users/me\", headers=superuser_token_headers)\n    current_user = r.json()\n    assert current_user\n    assert current_user[\"is_active\"] is True\n    assert current_user[\"is_superuser\"]\n    assert current_user[\"email\"] == settings.FIRST_SUPERUSER\n\n\ndef test_get_users_normal_user_me(\n    client: TestClient, normal_user_token_headers: Dict[str, str]\n) -> None:\n    r = client.get(f\"{settings.API_V1_STR}/users/me\", headers=normal_user_token_headers)\n    current_user = r.json()\n    assert current_user\n    assert current_user[\"is_active\"] is True\n    assert current_user[\"is_superuser\"] is False\n    assert current_user[\"email\"] == settings.EMAIL_TEST_USER\n\n\ndef test_create_user_new_email(\n    client: TestClient, superuser_token_headers: dict, db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    data = {\"email\": username, \"password\": password}\n    r = client.post(\n        f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers, json=data,\n    )\n    assert 200 <= r.status_code < 300\n    created_user = r.json()\n    user = crud.user.get_by_email(db, email=username)\n    assert user\n    assert user.email == created_user[\"email\"]\n\n\ndef test_get_existing_user(\n    client: TestClient, superuser_token_headers: dict, db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.user.create(db, obj_in=user_in)\n    user_id = user.id\n    r = client.get(\n        f\"{settings.API_V1_STR}/users/{user_id}\", headers=superuser_token_headers,\n    )\n    assert 200 <= r.status_code < 300\n    api_user = r.json()\n    existing_user = crud.user.get_by_email(db, email=username)\n    assert existing_user\n    assert existing_user.email == api_user[\"email\"]\n\n\ndef test_create_user_existing_username(\n    client: TestClient, superuser_token_headers: dict, db: Session\n) -> None:\n    username = random_email()\n    # username = email\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.user.create(db, obj_in=user_in)\n    data = {\"email\": username, \"password\": password}\n    r = client.post(\n        f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers, json=data,\n    )\n    created_user = r.json()\n    assert r.status_code == 400\n    assert \"_id\" not in created_user\n\n\ndef test_create_user_by_normal_user(\n    client: TestClient, normal_user_token_headers: Dict[str, str]\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    data = {\"email\": username, \"password\": password}\n    r = client.post(\n        f\"{settings.API_V1_STR}/users/\", headers=normal_user_token_headers, json=data,\n    )\n    assert r.status_code == 400\n\n\ndef test_retrieve_users(\n    client: TestClient, superuser_token_headers: dict, db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.user.create(db, obj_in=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    crud.user.create(db, obj_in=user_in2)\n\n    r = client.get(f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers)\n    all_users = r.json()\n\n    assert len(all_users) > 1\n    for item in all_users:\n        assert \"email\" in item\n"}
{"type": "source_file", "path": "alembic/env.py", "content": "from __future__ import with_statement\n\nimport os\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom logging.config import fileConfig\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\n# target_metadata = None\n\nfrom app.db.base import Base  # noqa\n\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef get_url():\n    user = os.getenv(\"POSTGRES_USER\", \"postgres\")\n    password = os.getenv(\"POSTGRES_PASSWORD\", \"\")\n    server = os.getenv(\"POSTGRES_SERVER\", \"db\")\n    db = os.getenv(\"POSTGRES_DB\", \"app\")\n\n    return f\"postgresql://{user}:{password}@{server}/{db}\"\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = get_url()\n    context.configure(\n        url=url, target_metadata=target_metadata, literal_binds=True, compare_type=True\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    configuration = config.get_section(config.config_ini_section)\n    configuration[\"sqlalchemy.url\"] = get_url()\n    connectable = engine_from_config(\n        configuration,\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata, compare_type=True\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "app/api/api_v1/endpoints/users.py", "content": "from typing import Any, List\n\nfrom fastapi import APIRouter, Body, Depends, HTTPException\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic.networks import EmailStr\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, models, schemas\nfrom app.api import deps\nfrom app.core.config import settings\nfrom app.utils import send_new_account_email\n\nrouter = APIRouter()\n\n\n@router.get(\"/\", response_model=List[schemas.User])\ndef read_users(\n    db: Session = Depends(deps.get_db),\n    skip: int = 0,\n    limit: int = 100,\n    current_user: models.User = Depends(deps.get_current_active_superuser),\n) -> Any:\n    \"\"\"\n    Retrieve users.\n    \"\"\"\n    users = crud.user.get_multi(db, skip=skip, limit=limit)\n    return users\n\n\n@router.post(\"/\", response_model=schemas.User)\ndef create_user(\n    *,\n    db: Session = Depends(deps.get_db),\n    user_in: schemas.UserCreate,\n    current_user: models.User = Depends(deps.get_current_active_superuser),\n) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.user.get_by_email(db, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this username already exists in the system.\",\n        )\n    user = crud.user.create(db, obj_in=user_in)\n    if settings.EMAILS_ENABLED and user_in.email:\n        send_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n    return user\n\n\n@router.put(\"/me\", response_model=schemas.User)\ndef update_user_me(\n    *,\n    db: Session = Depends(deps.get_db),\n    password: str = Body(None),\n    full_name: str = Body(None),\n    email: EmailStr = Body(None),\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Update own user.\n    \"\"\"\n    current_user_data = jsonable_encoder(current_user)\n    user_in = schemas.UserUpdate(**current_user_data)\n    if password is not None:\n        user_in.password = password\n    if full_name is not None:\n        user_in.full_name = full_name\n    if email is not None:\n        user_in.email = email\n    user = crud.user.update(db, db_obj=current_user, obj_in=user_in)\n    return user\n\n\n@router.get(\"/me\", response_model=schemas.User)\ndef read_user_me(\n    db: Session = Depends(deps.get_db),\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Get current user.\n    \"\"\"\n    return current_user\n\n\n@router.post(\"/open\", response_model=schemas.User)\ndef create_user_open(\n    *,\n    db: Session = Depends(deps.get_db),\n    password: str = Body(...),\n    email: EmailStr = Body(...),\n    full_name: str = Body(None),\n) -> Any:\n    \"\"\"\n    Create new user without the need to be logged in.\n    \"\"\"\n    if not settings.USERS_OPEN_REGISTRATION:\n        raise HTTPException(\n            status_code=403,\n            detail=\"Open user registration is forbidden on this server\",\n        )\n    user = crud.user.get_by_email(db, email=email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this username already exists in the system\",\n        )\n    user_in = schemas.UserCreate(password=password, email=email, full_name=full_name)\n    user = crud.user.create(db, obj_in=user_in)\n    return user\n\n\n@router.get(\"/{user_id}\", response_model=schemas.User)\ndef read_user_by_id(\n    user_id: int,\n    current_user: models.User = Depends(deps.get_current_active_user),\n    db: Session = Depends(deps.get_db),\n) -> Any:\n    \"\"\"\n    Get a specific user by id.\n    \"\"\"\n    user = crud.user.get(db, id=user_id)\n    if user == current_user:\n        return user\n    if not crud.user.is_superuser(current_user):\n        raise HTTPException(\n            status_code=400, detail=\"The user doesn't have enough privileges\"\n        )\n    return user\n\n\n@router.put(\"/{user_id}\", response_model=schemas.User)\ndef update_user(\n    *,\n    db: Session = Depends(deps.get_db),\n    user_id: int,\n    user_in: schemas.UserUpdate,\n    current_user: models.User = Depends(deps.get_current_active_superuser),\n) -> Any:\n    \"\"\"\n    Update a user.\n    \"\"\"\n    user = crud.user.get(db, id=user_id)\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system\",\n        )\n    user = crud.user.update(db, db_obj=user, obj_in=user_in)\n    return user\n"}
{"type": "source_file", "path": "app/models/__init__.py", "content": "from .item import Item\nfrom .user import User\n"}
{"type": "source_file", "path": "app/crud/base.py", "content": "from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union\n\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\n\nfrom app.db.base_class import Base\n\nModelType = TypeVar(\"ModelType\", bound=Base)\nCreateSchemaType = TypeVar(\"CreateSchemaType\", bound=BaseModel)\nUpdateSchemaType = TypeVar(\"UpdateSchemaType\", bound=BaseModel)\n\n\nclass CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):\n    def __init__(self, model: Type[ModelType]):\n        \"\"\"\n        CRUD object with default methods to Create, Read, Update, Delete (CRUD).\n\n        **Parameters**\n\n        * `model`: A SQLAlchemy model class\n        * `schema`: A Pydantic model (schema) class\n        \"\"\"\n        self.model = model\n\n    def get(self, db: Session, id: Any) -> Optional[ModelType]:\n        return db.query(self.model).filter(self.model.id == id).first()\n\n    def get_multi(\n        self, db: Session, *, skip: int = 0, limit: int = 100\n    ) -> List[ModelType]:\n        return db.query(self.model).offset(skip).limit(limit).all()\n\n    def create(self, db: Session, *, obj_in: CreateSchemaType) -> ModelType:\n        obj_in_data = jsonable_encoder(obj_in)\n        db_obj = self.model(**obj_in_data)  # type: ignore\n        db.add(db_obj)\n        db.commit()\n        db.refresh(db_obj)\n        return db_obj\n\n    def update(\n        self,\n        db: Session,\n        *,\n        db_obj: ModelType,\n        obj_in: Union[UpdateSchemaType, Dict[str, Any]]\n    ) -> ModelType:\n        obj_data = jsonable_encoder(db_obj)\n        if isinstance(obj_in, dict):\n            update_data = obj_in\n        else:\n            update_data = obj_in.model_dump(exclude_unset=True)\n        for field in obj_data:\n            if field in update_data:\n                setattr(db_obj, field, update_data[field])\n        db.add(db_obj)\n        db.commit()\n        db.refresh(db_obj)\n        return db_obj\n\n    def remove(self, db: Session, *, id: int) -> ModelType:\n        obj = db.query(self.model).get(id)\n        db.delete(obj)\n        db.commit()\n        return obj\n"}
{"type": "source_file", "path": "alembic/versions/d4867f3a4c0a_first_revision.py", "content": "\"\"\"First revision\n\nRevision ID: d4867f3a4c0a\nRevises:\nCreate Date: 2019-04-17 13:53:32.978401\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = \"d4867f3a4c0a\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"user\",\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"full_name\", sa.String(), nullable=True),\n        sa.Column(\"email\", sa.String(), nullable=True),\n        sa.Column(\"hashed_password\", sa.String(), nullable=True),\n        sa.Column(\"is_active\", sa.Boolean(), nullable=True),\n        sa.Column(\"is_superuser\", sa.Boolean(), nullable=True),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_user_email\"), \"user\", [\"email\"], unique=True)\n    op.create_index(op.f(\"ix_user_full_name\"), \"user\", [\"full_name\"], unique=False)\n    op.create_index(op.f(\"ix_user_id\"), \"user\", [\"id\"], unique=False)\n    op.create_table(\n        \"item\",\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"title\", sa.String(), nullable=True),\n        sa.Column(\"description\", sa.String(), nullable=True),\n        sa.Column(\"owner_id\", sa.Integer(), nullable=True),\n        sa.ForeignKeyConstraint([\"owner_id\"], [\"user.id\"],),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_item_description\"), \"item\", [\"description\"], unique=False)\n    op.create_index(op.f(\"ix_item_id\"), \"item\", [\"id\"], unique=False)\n    op.create_index(op.f(\"ix_item_title\"), \"item\", [\"title\"], unique=False)\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f(\"ix_item_title\"), table_name=\"item\")\n    op.drop_index(op.f(\"ix_item_id\"), table_name=\"item\")\n    op.drop_index(op.f(\"ix_item_description\"), table_name=\"item\")\n    op.drop_table(\"item\")\n    op.drop_index(op.f(\"ix_user_id\"), table_name=\"user\")\n    op.drop_index(op.f(\"ix_user_full_name\"), table_name=\"user\")\n    op.drop_index(op.f(\"ix_user_email\"), table_name=\"user\")\n    op.drop_table(\"user\")\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/crud/__init__.py", "content": "from .crud_item import item\nfrom .crud_user import user\n\n# For a new basic set of CRUD operations you could just do\n\n# from .base import CRUDBase\n# from app.models.item import Item\n# from app.schemas.item import ItemCreate, ItemUpdate\n\n# item = CRUDBase[Item, ItemCreate, ItemUpdate](Item)\n"}
{"type": "source_file", "path": "app/crud/crud_item.py", "content": "from typing import List\n\nfrom fastapi.encoders import jsonable_encoder\nfrom sqlalchemy.orm import Session\n\nfrom app.crud.base import CRUDBase\nfrom app.models.item import Item\nfrom app.schemas.item import ItemCreate, ItemUpdate\n\n\nclass CRUDItem(CRUDBase[Item, ItemCreate, ItemUpdate]):\n    def create_with_owner(\n        self, db: Session, *, obj_in: ItemCreate, owner_id: int\n    ) -> Item:\n        obj_in_data = jsonable_encoder(obj_in)\n        db_obj = self.model(**obj_in_data, owner_id=owner_id)\n        db.add(db_obj)\n        db.commit()\n        db.refresh(db_obj)\n        return db_obj\n\n    def get_multi_by_owner(\n        self, db: Session, *, owner_id: int, skip: int = 0, limit: int = 100\n    ) -> List[Item]:\n        return (\n            db.query(self.model)\n            .filter(Item.owner_id == owner_id)\n            .offset(skip)\n            .limit(limit)\n            .all()\n        )\n\n\nitem = CRUDItem(Item)\n"}
{"type": "source_file", "path": "app/api/api_v1/endpoints/items.py", "content": "from typing import Any, List\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, models, schemas\nfrom app.api import deps\n\nrouter = APIRouter()\n\n\n@router.get(\"/\", response_model=List[schemas.Item])\ndef read_items(\n    db: Session = Depends(deps.get_db),\n    skip: int = 0,\n    limit: int = 100,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Retrieve items.\n    \"\"\"\n    if crud.user.is_superuser(current_user):\n        items = crud.item.get_multi(db, skip=skip, limit=limit)\n    else:\n        items = crud.item.get_multi_by_owner(\n            db=db, owner_id=current_user.id, skip=skip, limit=limit\n        )\n    return items\n\n\n@router.post(\"/\", response_model=schemas.Item)\ndef create_item(\n    *,\n    db: Session = Depends(deps.get_db),\n    item_in: schemas.ItemCreate,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Create new item.\n    \"\"\"\n    item = crud.item.create_with_owner(db=db, obj_in=item_in, owner_id=current_user.id)\n    return item\n\n\n@router.put(\"/{id}\", response_model=schemas.Item)\ndef update_item(\n    *,\n    db: Session = Depends(deps.get_db),\n    id: int,\n    item_in: schemas.ItemUpdate,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Update an item.\n    \"\"\"\n    item = crud.item.get(db=db, id=id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not crud.user.is_superuser(current_user) and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    item = crud.item.update(db=db, db_obj=item, obj_in=item_in)\n    return item\n\n\n@router.get(\"/{id}\", response_model=schemas.Item)\ndef read_item(\n    *,\n    db: Session = Depends(deps.get_db),\n    id: int,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Get item by ID.\n    \"\"\"\n    item = crud.item.get(db=db, id=id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not crud.user.is_superuser(current_user) and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    return item\n\n\n@router.delete(\"/{id}\", response_model=schemas.Item)\ndef delete_item(\n    *,\n    db: Session = Depends(deps.get_db),\n    id: int,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Delete an item.\n    \"\"\"\n    item = crud.item.get(db=db, id=id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not crud.user.is_superuser(current_user) and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    item = crud.item.remove(db=db, id=id)\n    return item\n"}
{"type": "source_file", "path": "app/api/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/api_v1/api.py", "content": "from fastapi import APIRouter\n\nfrom app.api.api_v1.endpoints import items, login, users, utils\n\napi_router = APIRouter()\napi_router.include_router(login.router, tags=[\"login\"])\napi_router.include_router(users.router, prefix=\"/users\", tags=[\"users\"])\napi_router.include_router(utils.router, prefix=\"/utils\", tags=[\"utils\"])\napi_router.include_router(items.router, prefix=\"/items\", tags=[\"items\"])\n"}
{"type": "source_file", "path": "app/db/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/deps.py", "content": "from typing import Generator\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import jwt\nfrom pydantic import ValidationError\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, models, schemas\nfrom app.core import security\nfrom app.core.config import settings\nfrom app.db.session import SessionLocal\n\nreusable_oauth2 = OAuth2PasswordBearer(\n    tokenUrl=f\"{settings.API_V1_STR}/login/access-token\"\n)\n\n\ndef get_db() -> Generator:\n    try:\n        db = SessionLocal()\n        yield db\n    finally:\n        db.close()\n\n\ndef get_current_user(\n    db: Session = Depends(get_db), token: str = Depends(reusable_oauth2)\n) -> models.User:\n    try:\n        payload = jwt.decode(\n            token, settings.SECRET_KEY, algorithms=[security.ALGORITHM]\n        )\n        token_data = schemas.TokenPayload(**payload)\n    except (jwt.JWTError, ValidationError):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials\",\n        )\n    user = crud.user.get(db, id=token_data.sub)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\n\ndef get_current_active_user(\n    current_user: models.User = Depends(get_current_user),\n) -> models.User:\n    if not crud.user.is_active(current_user):\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n\n\ndef get_current_active_superuser(\n    current_user: models.User = Depends(get_current_active_user),\n) -> models.User:\n    if not crud.user.is_superuser(current_user):\n        raise HTTPException(\n            status_code=400, detail=\"The user doesn't have enough privileges\"\n        )\n    return current_user\n"}
{"type": "source_file", "path": "app/api/api_v1/endpoints/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/api_v1/endpoints/utils.py", "content": "from typing import Any\n\nfrom fastapi import APIRouter, Depends\nfrom pydantic.networks import EmailStr\n\nfrom app import models, schemas\nfrom app.api import deps\n\nfrom app.utils import send_test_email\n\nrouter = APIRouter()\n\n\n@router.post(\"/test-email/\", response_model=schemas.Msg, status_code=201)\ndef test_email(\n    email_to: EmailStr,\n    current_user: models.User = Depends(deps.get_current_active_superuser),\n) -> Any:\n    \"\"\"\n    Test emails.\n    \"\"\"\n    send_test_email(email_to=email_to)\n    return {\"msg\": \"Test email sent\"}\n"}
{"type": "source_file", "path": "app/db/init_db.py", "content": "from sqlalchemy.orm import Session\n\nfrom app import crud, schemas\nfrom app.core.config import settings\nfrom app.db import base  # noqa: F401\n\n# make sure all SQL Alchemy models are imported (app.db.base) before initializing DB\n# otherwise, SQL Alchemy might fail to initialize relationships properly\n# for more details: https://github.com/tiangolo/full-stack-fastapi-postgresql/issues/28\n\n\ndef init_db(db: Session) -> None:\n    # Tables should be created with Alembic migrations\n    # But if you don't want to use migrations, create\n    # the tables un-commenting the next line\n    # Base.metadata.create_all(bind=engine)\n\n    user = crud.user.get_by_email(db, email=settings.FIRST_SUPERUSER)\n\n    if not user:\n        user_in = schemas.UserCreate(\n            email=settings.FIRST_SUPERUSER,\n            password=settings.FIRST_SUPERUSER_PASSWORD,\n            is_superuser=True,\n        )\n        user = crud.user.create(db, obj_in=user_in)  # noqa: F841\n"}
{"type": "source_file", "path": "app/db/base.py", "content": "# Import all the models, so that Base has them before being\n# imported by Alembic\nfrom app.db.base_class import Base  # noqa\nfrom app.models.item import Item  # noqa\nfrom app.models.user import User  # noqa\n"}
{"type": "source_file", "path": "app/api/api_v1/__init__.py", "content": ""}
{"type": "source_file", "path": "app/crud/crud_user.py", "content": "from typing import Any, Dict, Optional, Union\n\nfrom sqlalchemy.orm import Session\n\nfrom app.core.security import get_password_hash, verify_password\nfrom app.crud.base import CRUDBase\nfrom app.models.user import User\nfrom app.schemas.user import UserCreate, UserUpdate\n\n\nclass CRUDUser(CRUDBase[User, UserCreate, UserUpdate]):\n    def get_by_email(self, db: Session, *, email: str) -> Optional[User]:\n        return db.query(User).filter(User.email == email).first()\n\n    def create(self, db: Session, *, obj_in: UserCreate) -> User:\n        db_obj = User(\n            email=obj_in.email,\n            hashed_password=get_password_hash(obj_in.password),\n            full_name=obj_in.full_name,\n            is_superuser=obj_in.is_superuser,\n        )\n        db.add(db_obj)\n        db.commit()\n        db.refresh(db_obj)\n        return db_obj\n\n    def update(\n        self, db: Session, *, db_obj: User, obj_in: Union[UserUpdate, Dict[str, Any]]\n    ) -> User:\n        if isinstance(obj_in, dict):\n            update_data = obj_in\n        else:\n            update_data = obj_in.model_dump(exclude_unset=True)\n        if update_data[\"password\"]:\n            hashed_password = get_password_hash(update_data[\"password\"])\n            del update_data[\"password\"]\n            update_data[\"hashed_password\"] = hashed_password\n        return super().update(db, db_obj=db_obj, obj_in=update_data)\n\n    def authenticate(self, db: Session, *, email: str, password: str) -> Optional[User]:\n        user = self.get_by_email(db, email=email)\n        if not user:\n            return None\n        if not verify_password(password, user.hashed_password):\n            return None\n        return user\n\n    def is_active(self, user: User) -> bool:\n        return user.is_active\n\n    def is_superuser(self, user: User) -> bool:\n        return user.is_superuser\n\n\nuser = CRUDUser(User)\n"}
{"type": "source_file", "path": "app/core/config.py", "content": "import secrets\nfrom typing import Any, List, Optional, Union\n\nfrom dotenv import load_dotenv\nfrom pydantic import (AnyHttpUrl, AnyUrl, EmailStr, HttpUrl, PostgresDsn,\n                      ValidationInfo, field_validator)\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nimport os\n\nload_dotenv()\n\nclass Settings(BaseSettings):\n    API_V1_STR: str = \"/api/v1\"\n    SECRET_KEY: str = os.getenv(\"ACCESS_TOKEN_SECRET\", \"\") #secrets.token_urlsafe(32)\n    # 60 minutes * 24 hours * 8 days = 8 days\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 8\n    SERVER_HOST: AnyHttpUrl\n    # BACKEND_CORS_ORIGINS is a JSON-formatted list of origins\n    # e.g: '[\"http://localhost\", \"http://localhost:4200\", \"http://localhost:3000\", \\\n    # \"http://localhost:8080\", \"http://local.dockertoolbox.tiangolo.com\"]'\n    BACKEND_CORS_ORIGINS: List[AnyHttpUrl] = []\n\n    @field_validator(\"BACKEND_CORS_ORIGINS\", mode=\"before\")\n    @classmethod\n    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:\n        if isinstance(v, str) and not v.startswith(\"[\"):\n            return [i.strip() for i in v.split(\",\")]\n        elif isinstance(v, (list, str)):\n            return v\n        raise ValueError(v)\n\n    PROJECT_NAME: str\n\n    POSTGRES_SERVER: str\n    POSTGRES_USER: str\n    POSTGRES_PASSWORD: str\n    POSTGRES_DB: str\n    SQLALCHEMY_DATABASE_URI: Optional[PostgresDsn] = None\n\n    @field_validator(\"SQLALCHEMY_DATABASE_URI\", mode=\"before\")\n    @classmethod\n    def assemble_db_connection(cls, v: Optional[str], info: ValidationInfo) -> Any:\n        if isinstance(v, str):\n            return v\n        user = info.data.get(\"POSTGRES_USER\")\n        password = info.data.get(\"POSTGRES_PASSWORD\")\n        host = info.data.get(\"POSTGRES_SERVER\")\n        db = info.data.get(\"POSTGRES_DB\")\n\n        if all([user, password, host, db]):\n            return f\"postgresql://{user}:{password}@{host}/{db}\"\n        else:\n            return None\n\n    SMTP_TLS: bool = True\n    SMTP_PORT: Optional[int] = None\n    SMTP_HOST: Optional[str] = None\n    SMTP_USER: Optional[str] = None\n    SMTP_PASSWORD: Optional[str] = None\n    EMAILS_FROM_EMAIL: Optional[EmailStr] = None\n    EMAILS_FROM_NAME: Optional[str] = None\n\n    @field_validator(\"EMAILS_FROM_NAME\", mode=\"before\")\n    @classmethod\n    def get_project_name(cls, v: Optional[str], info: ValidationInfo) -> str:\n        if not v:\n            return info.data.get(\"PROJECT_NAME\")\n        return v\n\n    EMAIL_RESET_TOKEN_EXPIRE_HOURS: int = 48\n    EMAIL_TEMPLATES_DIR: str = \"/app/app/email-templates/build\"\n    EMAILS_ENABLED: bool = False\n\n    @field_validator(\"EMAILS_ENABLED\", mode=\"before\")\n    @classmethod\n    def get_emails_enabled(cls, v: bool, info: ValidationInfo) -> bool:\n        return bool(\n            info.data.get(\"SMTP_HOST\")\n            and info.data.get(\"SMTP_PORT\")\n            and info.data.get(\"EMAILS_FROM_EMAIL\")\n        )\n\n    EMAIL_TEST_USER: EmailStr = \"test@example.com\"\n    FIRST_SUPERUSER: EmailStr\n    FIRST_SUPERUSER_PASSWORD: str\n    USERS_OPEN_REGISTRATION: bool = False\n    \n    model_config = SettingsConfigDict(case_sensitive=True)\n\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "app/db/session.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.core.config import settings\n\n\nengine = create_engine(str(settings.SQLALCHEMY_DATABASE_URI), pool_pre_ping=True)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n"}
{"type": "source_file", "path": "app/api/api_v1/endpoints/login.py", "content": "from datetime import timedelta\nfrom typing import Any\n\nfrom fastapi import APIRouter, Body, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, models, schemas\nfrom app.api import deps\nfrom app.core import security\nfrom app.core.config import settings\nfrom app.core.security import get_password_hash\nfrom app.utils import (\n    generate_password_reset_token,\n    send_reset_password_email,\n    verify_password_reset_token,\n)\n\nrouter = APIRouter()\n\n\n@router.post(\"/login/access-token\", response_model=schemas.Token)\ndef login_access_token(\n    db: Session = Depends(deps.get_db), form_data: OAuth2PasswordRequestForm = Depends()\n) -> Any:\n    \"\"\"\n    OAuth2 compatible token login, get an access token for future requests\n    \"\"\"\n    user = crud.user.authenticate(\n        db, email=form_data.username, password=form_data.password\n    )\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n    elif not crud.user.is_active(user):\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    return {\n        \"access_token\": security.create_access_token(\n            user.id, expires_delta=access_token_expires\n        ),\n        \"token_type\": \"bearer\",\n    }\n\n\n@router.post(\"/login/test-token\", response_model=schemas.User)\ndef test_token(current_user: models.User = Depends(deps.get_current_user)) -> Any:\n    \"\"\"\n    Test access token\n    \"\"\"\n    return current_user\n\n\n@router.post(\"/password-recovery/{email}\", response_model=schemas.Msg)\ndef recover_password(email: str, db: Session = Depends(deps.get_db)) -> Any:\n    \"\"\"\n    Password Recovery\n    \"\"\"\n    user = crud.user.get_by_email(db, email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    send_reset_password_email(\n        email_to=user.email, email=email, token=password_reset_token\n    )\n    return {\"msg\": \"Password recovery email sent\"}\n\n\n@router.post(\"/reset-password/\", response_model=schemas.Msg)\ndef reset_password(\n    token: str = Body(...),\n    new_password: str = Body(...),\n    db: Session = Depends(deps.get_db),\n) -> Any:\n    \"\"\"\n    Reset password\n    \"\"\"\n    email = verify_password_reset_token(token)\n    if not email:\n        raise HTTPException(status_code=400, detail=\"Invalid token\")\n    user = crud.user.get_by_email(db, email=email)\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system.\",\n        )\n    elif not crud.user.is_active(user):\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    hashed_password = get_password_hash(new_password)\n    user.hashed_password = hashed_password\n    db.add(user)\n    db.commit()\n    return {\"msg\": \"Password updated successfully\"}\n"}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import FastAPI\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom app.api.api_v1.api import api_router\nfrom app.core.config import settings\n\napp = FastAPI(\n    title=settings.PROJECT_NAME, openapi_url=f\"{settings.API_V1_STR}/openapi.json\"\n)\n\n# Set all CORS enabled origins\nif settings.BACKEND_CORS_ORIGINS:\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\napp.include_router(api_router, prefix=settings.API_V1_STR)\n"}
{"type": "source_file", "path": "app/core/security.py", "content": "from datetime import datetime, timedelta\nfrom typing import Any, Union\n\nfrom jose import jwt\nfrom passlib.context import CryptContext\n\nfrom app.core.config import settings\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\nALGORITHM = \"HS256\"\n\n\ndef create_access_token(\n    subject: Union[str, Any], expires_delta: timedelta = None\n) -> str:\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(\n            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES\n        )\n    to_encode = {\"exp\": expire, \"sub\": str(subject)}\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n"}
{"type": "source_file", "path": "app/models/user.py", "content": "from typing import TYPE_CHECKING\n\nfrom sqlalchemy import Boolean, Column, Integer, String\nfrom sqlalchemy.orm import relationship\n\nfrom app.db.base_class import Base\n\nif TYPE_CHECKING:\n    from .item import Item  # noqa: F401\n\n\nclass User(Base):\n    id = Column(Integer, primary_key=True, index=True)\n    full_name = Column(String, index=True)\n    email = Column(String, unique=True, index=True, nullable=False)\n    hashed_password = Column(String, nullable=False)\n    is_active = Column(Boolean(), default=True)\n    is_superuser = Column(Boolean(), default=False)\n    items = relationship(\"Item\", back_populates=\"owner\")\n"}
{"type": "source_file", "path": "app/backend_pre_start.py", "content": "import logging\n\nfrom tenacity import after_log, before_log, retry, stop_after_attempt, wait_fixed\n\nfrom app.db.session import SessionLocal\nfrom sqlalchemy import text\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nmax_tries = 60 * 5  # 5 minutes\nwait_seconds = 1\n\n\n@retry(\n    stop=stop_after_attempt(max_tries),\n    wait=wait_fixed(wait_seconds),\n    before=before_log(logger, logging.INFO),\n    after=after_log(logger, logging.WARN),\n)\ndef init() -> None:\n    try:\n        db = SessionLocal()\n        # Try to create session to check if DB is awake\n        db.execute(text(\"SELECT 1\"))\n    except Exception as e:\n        logger.error(e)\n        raise e\n\n\ndef main() -> None:\n    logger.info(\"Initializing service\")\n    init()\n    logger.info(\"Service finished initializing\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "app/db/base_class.py", "content": "from typing import Any\n\nfrom sqlalchemy.ext.declarative import as_declarative, declared_attr\n\n\n@as_declarative()\nclass Base:\n    id: Any\n    __name__: str\n    # Generate __tablename__ automatically\n    @declared_attr\n    def __tablename__(cls) -> str:\n        return cls.__name__.lower()\n"}
{"type": "source_file", "path": "app/initial_data.py", "content": "import logging\n\nfrom app.db.init_db import init_db\nfrom app.db.session import SessionLocal\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\ndef init() -> None:\n    db = SessionLocal()\n\n    init_db(db)\n\n\ndef main() -> None:\n    logger.info(\"Creating initial data\")\n    init()\n    logger.info(\"Initial data created\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "app/schemas/__init__.py", "content": "from .item import Item, ItemCreate, ItemInDB, ItemUpdate\nfrom .msg import Msg\nfrom .token import Token, TokenPayload\nfrom .user import User, UserCreate, UserInDB, UserUpdate\n"}
{"type": "source_file", "path": "app/schemas/item.py", "content": "from typing import Optional\n\nfrom pydantic import ConfigDict, BaseModel\n\n\n# Shared properties\nclass ItemBase(BaseModel):\n    title: Optional[str] = None\n    description: Optional[str] = None\n\n\n# Properties to receive on item creation\nclass ItemCreate(ItemBase):\n    title: str\n\n\n# Properties to receive on item update\nclass ItemUpdate(ItemBase):\n    pass\n\n\n# Properties shared by models stored in DB\nclass ItemInDBBase(ItemBase):\n    id: int\n    title: str\n    owner_id: int\n    model_config = ConfigDict(from_attributes=True)\n\n\n# Properties to return to client\nclass Item(ItemInDBBase):\n    pass\n\n\n# Properties properties stored in DB\nclass ItemInDB(ItemInDBBase):\n    pass\n"}
{"type": "source_file", "path": "app/models/item.py", "content": "from typing import TYPE_CHECKING\n\nfrom sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import relationship\n\nfrom app.db.base_class import Base\n\nif TYPE_CHECKING:\n    from .user import User  # noqa: F401\n\n\nclass Item(Base):\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, index=True)\n    description = Column(String, index=True)\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner = relationship(\"User\", back_populates=\"items\")\n"}
{"type": "source_file", "path": "app/utils.py", "content": "import logging\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\nimport emails\nfrom emails.template import JinjaTemplate\nfrom jose import jwt\n\nfrom app.core.config import settings\n\n\ndef send_email(\n    email_to: str,\n    subject_template: str = \"\",\n    html_template: str = \"\",\n    environment: Dict[str, Any] = {},\n) -> None:\n    assert settings.EMAILS_ENABLED, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=JinjaTemplate(subject_template),\n        html=JinjaTemplate(html_template),\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, render=environment, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")\n\n\ndef send_test_email(email_to: str) -> None:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Test email\"\n    with open(Path(settings.EMAIL_TEMPLATES_DIR) / \"test_email.html\") as f:\n        template_str = f.read()\n    send_email(\n        email_to=email_to,\n        subject_template=subject,\n        html_template=template_str,\n        environment={\"project_name\": settings.PROJECT_NAME, \"email\": email_to},\n    )\n\n\ndef send_reset_password_email(email_to: str, email: str, token: str) -> None:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    with open(Path(settings.EMAIL_TEMPLATES_DIR) / \"reset_password.html\") as f:\n        template_str = f.read()\n    server_host = settings.SERVER_HOST\n    link = f\"{server_host}/reset-password?token={token}\"\n    send_email(\n        email_to=email_to,\n        subject_template=subject,\n        html_template=template_str,\n        environment={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n\n\ndef send_new_account_email(email_to: str, username: str, password: str) -> None:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - New account for user {username}\"\n    with open(Path(settings.EMAIL_TEMPLATES_DIR) / \"new_account.html\") as f:\n        template_str = f.read()\n    link = settings.SERVER_HOST\n    send_email(\n        email_to=email_to,\n        subject_template=subject,\n        html_template=template_str,\n        environment={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": link,\n        },\n    )\n\n\ndef generate_password_reset_token(email: str) -> str:\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email}, settings.SECRET_KEY, algorithm=\"HS256\",\n    )\n    return encoded_jwt\n\n\ndef verify_password_reset_token(token: str) -> Optional[str]:\n    try:\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        return decoded_token[\"email\"]\n    except jwt.JWTError:\n        return None\n"}
{"type": "source_file", "path": "app/schemas/msg.py", "content": "from pydantic import BaseModel\n\n\nclass Msg(BaseModel):\n    msg: str\n"}
{"type": "source_file", "path": "app/schemas/token.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenPayload(BaseModel):\n    sub: Optional[int] = None\n"}
{"type": "source_file", "path": "app/schemas/user.py", "content": "from typing import Optional\n\nfrom pydantic import ConfigDict, BaseModel, EmailStr\n\n\n# Shared properties\nclass UserBase(BaseModel):\n    email: Optional[EmailStr] = None\n    is_active: Optional[bool] = True\n    is_superuser: bool = False\n    full_name: Optional[str] = None\n\n\n# Properties to receive via API on creation\nclass UserCreate(UserBase):\n    email: EmailStr\n    password: str\n\n\n# Properties to receive via API on update\nclass UserUpdate(UserBase):\n    password: Optional[str] = None\n\n\nclass UserInDBBase(UserBase):\n    id: Optional[int] = None\n    model_config = ConfigDict(from_attributes=True)\n\n\n# Additional properties to return via API\nclass User(UserInDBBase):\n    pass\n\n\n# Additional properties stored in DB\nclass UserInDB(UserInDBBase):\n    hashed_password: str\n"}

{"repo_info": {"repo_name": "device-registry-fastapi", "repo_owner": "AutomationPanda", "repo_url": "https://github.com/AutomationPanda/device-registry-fastapi"}}
{"type": "test_file", "path": "tests/integration/test_devices_auth.py", "content": "\"\"\"\nThis module contains integration tests for authentication.\nIt uses the '/devices' resource.\nFor complete testing, every endpoint should have authentication tests.\nHowever, that would generate a lot of test cases.\nIn a risk-based approach, it might be better to cover only a few endpoints.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nimport requests\n\nfrom testlib.devices import verify_value\n\n\n# --------------------------------------------------------------------------------\n# Verification Functions\n# --------------------------------------------------------------------------------\n\ndef verify_authorized(response):\n  data = response.json()\n  assert response.status_code == 200\n  assert isinstance(data, list)\n\n\ndef verify_unauthorized(response):\n  data = response.json()\n  assert response.status_code == 401\n  assert data['detail'] == 'Unauthorized'\n\n\n# --------------------------------------------------------------------------------\n# Authentication Tests\n# --------------------------------------------------------------------------------\n\ndef test_devices_get_with_basic_auth(base_url, user):\n  url = base_url.concat('/devices')\n  auth = (user.username, user.password)\n  response = requests.get(url, auth=auth)\n  verify_authorized(response)\n\n\ndef test_devices_get_with_basic_auth_session(base_url, session):\n  url = base_url.concat('/devices')\n  response = session.get(url)\n  verify_authorized(response)\n\n\ndef test_devices_get_with_token_auth(base_url, auth_token):\n  url = base_url.concat('/devices')\n  headers = {'Authorization': 'Bearer ' + auth_token}\n  response = requests.get(url, headers=headers)\n  verify_authorized(response)\n\n\ndef test_devices_get_with_shared_token_auth(base_url, shared_auth_token):\n  url = base_url.concat('/devices')\n  headers = {'Authorization': 'Bearer ' + shared_auth_token}\n  response = requests.get(url, headers=headers)\n  verify_authorized(response)\n\n\ndef test_devices_get_with_no_auth(base_url):\n  url = base_url.concat('/devices')\n  response = requests.get(url)\n  verify_unauthorized(response)\n\n\ndef test_devices_get_with_invalid_username(base_url, user):\n  url = base_url.concat('/devices')\n  auth = (user.username + 'X', user.password)\n  response = requests.get(url, auth=auth)\n  verify_unauthorized(response)\n\n\ndef test_devices_get_with_invalid_password(base_url, user):\n  url = base_url.concat('/devices')\n  auth = (user.username, user.password + 'X')\n  response = requests.get(url, auth=auth)\n  verify_unauthorized(response)\n\n\ndef test_devices_get_with_invalid_token(base_url, auth_token):\n  url = base_url.concat('/devices')\n  headers = {'Authorization': 'Bearer ' + auth_token + 'X'}\n  response = requests.get(url, headers=headers)\n  verify_unauthorized(response)\n\n\n# --------------------------------------------------------------------------------\n# Authorization Tests\n# --------------------------------------------------------------------------------\n\ndef test_user_authorization_for_devices_get_by_id(base_url, alt_session, thermostat):\n  \n  # Attempt retrieve\n  device_id_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  get_response = alt_session.get(device_id_url)\n  get_data = get_response.json()\n\n  # Verify error\n  assert get_response.status_code == 403\n  assert get_data['detail'] == 'Forbidden'\n\n\ndef test_user_authorization_for_devices_patch(base_url, alt_session, thermostat, thermostat_patch_data):\n  \n  # Attempt retrieve\n  device_id_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  get_response = alt_session.patch(device_id_url, json=thermostat_patch_data)\n  get_data = get_response.json()\n\n  # Verify error\n  assert get_response.status_code == 403\n  assert get_data['detail'] == 'Forbidden'\n\n\ndef test_user_authorization_for_devices_put(base_url, alt_session, thermostat, light_data):\n  \n  # Attempt retrieve\n  device_id_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  get_response = alt_session.put(device_id_url, json=light_data)\n  get_data = get_response.json()\n\n  # Verify error\n  assert get_response.status_code == 403\n  assert get_data['detail'] == 'Forbidden'\n\n\ndef test_user_authorization_for_devices_delete(base_url, alt_session, thermostat):\n  \n  # Attempt retrieve\n  device_id_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  get_response = alt_session.delete(device_id_url)\n  get_data = get_response.json()\n\n  # Verify error\n  assert get_response.status_code == 403\n  assert get_data['detail'] == 'Forbidden'\n\n\ndef test_user_authorization_for_device_report(base_url, alt_session, thermostat):\n  \n  # Attempt retrieve\n  device_id_url = base_url.concat(f'/devices/{thermostat[\"id\"]}/report')\n  get_response = alt_session.get(device_id_url)\n  get_data = get_response.json()\n\n  # Verify error\n  assert get_response.status_code == 403\n  assert get_data['detail'] == 'Forbidden'\n\n\ndef test_user_authorization_for_devices_get_list(base_url, alt_user, alt_session, devices):\n  \n  # Get all devices\n  device_id_url = base_url.concat(f'/devices/')\n  get_response = alt_session.get(device_id_url)\n  get_data = get_response.json()\n\n  # Verify the user's device is NOT in the alt_user's list\n  assert get_response.status_code == 200\n  assert isinstance(get_data, list)\n  verify_value(get_data, 'owner', alt_user.username)\n"}
{"type": "test_file", "path": "tests/integration/conftest.py", "content": "\"\"\"\nThis module provides fixtures for integration tests.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nimport json\nimport pytest\nimport requests\nimport time\n\nfrom testlib.api import BaseUrl, User, TokenHolder\nfrom testlib.devices import DeviceCreator\n\n\n# --------------------------------------------------------------------------------\n# Private Functions\n# --------------------------------------------------------------------------------\n\ndef _build_user(inputs, index):\n  users = inputs['users']\n  user = User(users[index]['username'], users[index]['password'])\n  return user\n\n\ndef _build_session(user):\n  session = requests.Session()\n  session.auth = (user.username, user.password)\n  return session\n\n\n# --------------------------------------------------------------------------------\n# Config Fixture\n# --------------------------------------------------------------------------------\n\n@pytest.fixture(scope='session')\ndef test_inputs():\n  with open('inputs.json') as config_json:\n    data = json.load(config_json)\n  return data\n\n\n@pytest.fixture\ndef base_url(test_inputs):\n  return BaseUrl(test_inputs['base_url'])\n\n\n@pytest.fixture\ndef user(test_inputs):\n  return _build_user(test_inputs, 0)\n\n\n@pytest.fixture\ndef alt_user(test_inputs):\n  return _build_user(test_inputs, 1)\n\n\n# --------------------------------------------------------------------------------\n# Session Fixtures\n# --------------------------------------------------------------------------------\n\n@pytest.fixture\ndef session(user):\n  return _build_session(user)\n\n\n@pytest.fixture\ndef alt_session(alt_user):\n  return _build_session(alt_user)\n\n\n# --------------------------------------------------------------------------------\n# Token Fixtures\n# --------------------------------------------------------------------------------\n\n@pytest.fixture\ndef auth_token(base_url, user):\n  url = base_url.concat('/authenticate')\n  auth = (user.username, user.password)\n  response = requests.get(url, auth=auth)\n  data = response.json()\n\n  assert response.status_code == 200\n  assert 'token' in data\n\n  return data['token']\n\n\n@pytest.fixture(scope='session')\ndef token_holder():\n  return TokenHolder(None, None)\n\n\n@pytest.fixture\ndef shared_auth_token(base_url, user, token_holder):\n  current_time = time.time()\n\n  if not token_holder.token or current_time - token_holder.start_time >= 3600:\n    url = base_url.concat('/authenticate')\n    auth = (user.username, user.password)\n    response = requests.get(url, auth=auth)\n    data = response.json()\n\n    assert response.status_code == 200\n    assert 'token' in data\n    \n    token_holder.token = data['token']\n    token_holder.start_time = current_time\n  \n  return token_holder.token\n\n\n# --------------------------------------------------------------------------------\n# Device Fixtures\n# --------------------------------------------------------------------------------\n\n@pytest.fixture\ndef thermostat_data():\n  return {\n    'name': 'Main Thermostat',\n    'location': 'Living Room',\n    'type': 'Thermostat',\n    'model': 'ThermoBest 3G',\n    'serial_number': 'TB3G-12345'\n  }\n\n\n@pytest.fixture\ndef light_data():\n  return {\n    'name': 'Front Porch Light',\n    'location': 'Front Porch',\n    'type': 'Light Switch',\n    'model': 'GenLight 64B',\n    'serial_number': 'GL64B-99987'\n  }\n\n\n@pytest.fixture\ndef fridge_data():\n  return {\n    'name': 'Family Fridge',\n    'location': 'Kitchen',\n    'type': 'Refrigerator',\n    'model': 'El Gee Mondo21',\n    'serial_number': 'LGM-20201'\n  }\n\n\n@pytest.fixture\ndef thermostat_patch_data():\n  return {\n    'name': 'Upstairs Thermostat',\n    'location': 'Master Bedroom'\n  }\n\n\n@pytest.fixture\ndef device_creator(base_url):\n  creator = DeviceCreator(base_url)\n  yield creator\n  creator.cleanup()\n\n\n@pytest.fixture\ndef thermostat(device_creator, session, thermostat_data):\n  return device_creator.create(session, thermostat_data)\n\n\n@pytest.fixture\ndef light(device_creator, session, light_data):\n  return device_creator.create(session, light_data)\n\n\n@pytest.fixture\ndef fridge(device_creator, session, fridge_data):\n  return device_creator.create(session, fridge_data)\n\n\n@pytest.fixture\ndef devices(thermostat, light, fridge):\n  return [thermostat, light, fridge]\n"}
{"type": "test_file", "path": "tests/integration/test_devices_crud.py", "content": "\"\"\"\nThis module contains CRUD integration tests for devices.\nCRUD = Create, Retrieve, Update, Delete.\nPositive and negative cases are included.\nThorough CRUD tests require more than one call per test.\nTherefore, their names do not mirror resource paths.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nimport pytest\n\n\n# --------------------------------------------------------------------------------\n# Positive CRUD Tests\n# --------------------------------------------------------------------------------\n\ndef test_create_and_retrieve_device(\n  base_url, session, thermostat):\n\n  # Retrieve\n  device_id_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  get_response = session.get(device_id_url)\n  get_data = get_response.json()\n\n  # Verify retrieve\n  assert get_response.status_code == 200\n  assert get_data == thermostat\n\n\ndef test_full_update_device(\n  base_url, session, thermostat, light_data):\n\n  # Put\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  put_response = session.put(device_url, json=light_data)\n  put_data = put_response.json()\n\n  # Verify put\n  assert put_response.status_code == 200\n  light_data['id'] = thermostat['id']\n  light_data['owner'] = thermostat['owner']\n  assert put_data == light_data\n\n  # Retrieve\n  device_id_url = base_url.concat(f'/devices/{light_data[\"id\"]}')\n  get_response = session.get(device_id_url)\n  get_data = get_response.json()\n\n  # Verify retrieve\n  assert get_response.status_code == 200\n  assert get_data == light_data\n\n\ndef test_partial_update_device(\n  base_url, session, thermostat, thermostat_patch_data):\n\n  # Patch\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  patch_response = session.patch(device_url, json=thermostat_patch_data)\n  patch_data = patch_response.json()\n\n  # Verify patch\n  assert patch_response.status_code == 200\n  thermostat_patch_data['id'] = thermostat['id']\n  thermostat_patch_data['type'] = thermostat['type']\n  thermostat_patch_data['model'] = thermostat['model']\n  thermostat_patch_data['serial_number'] = thermostat['serial_number']\n  thermostat_patch_data['owner'] = thermostat['owner']\n  assert patch_data == thermostat_patch_data\n\n  # Retrieve\n  device_id_url = base_url.concat(f'/devices/{patch_data[\"id\"]}')\n  get_response = session.get(device_id_url)\n  get_data = get_response.json()\n\n  # Verify retrieve\n  assert get_response.status_code == 200\n  assert get_data == thermostat_patch_data\n\n\n@pytest.mark.parametrize(\n  'field, value',\n  [\n    ('name', 'My Favorite Thermostat'),\n    ('location', 'My House')\n  ]\n)\ndef test_partial_update_device_with_one_field(\n  field, value, base_url, session, thermostat, thermostat_data):\n\n  # Patch\n  request_data = {field: value}\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  patch_response = session.patch(device_url, json=request_data)\n  patch_data = patch_response.json()\n\n  # Verify patch\n  assert patch_response.status_code == 200\n  thermostat_data[field] = value\n  assert patch_data == thermostat_data\n\n  # Retrieve\n  device_id_url = base_url.concat(f'/devices/{patch_data[\"id\"]}')\n  get_response = session.get(device_id_url)\n  get_data = get_response.json()\n\n  # Verify retrieve\n  assert get_response.status_code == 200\n  assert get_data == thermostat_data\n\n\ndef test_delete_device(\n  base_url, session, thermostat, device_creator):\n\n  # Delete\n  device_id_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  delete_response = session.delete(device_id_url)\n  delete_data = delete_response.json()\n\n  # Verify delete\n  assert delete_response.status_code == 200\n  assert not delete_data\n\n  # Attempt to retrieve the deleted device\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  get_response = session.get(device_url)\n  get_data = get_response.json()\n\n  # Verify error\n  assert get_response.status_code == 404\n  assert get_data['detail'] == 'Not Found'\n\n  # Mark device as deleted\n  device_creator.remove(thermostat['id'])\n\n\n# --------------------------------------------------------------------------------\n# Nonexistent ID Tests\n# --------------------------------------------------------------------------------\n\nNONEXISTENT_ID = 999999999\n\n\ndef verify_not_found(response):\n  body = response.json()\n  assert response.status_code == 404\n  assert body['detail'] == 'Not Found'\n\n\n# def test_nonexistent_id_error_for_device_retrieve(\n#   base_url, session):\n\n#   # Attempt retrieve\n#   device_url = base_url.concat(f'/devices/{NONEXISTENT_ID}')\n#   get_response = session.get(device_url)\n#   get_data = get_response.json()\n\n#   # Verify error\n#   assert get_response.status_code == 404\n#   assert get_data['detail'] == 'Not Found'\n\n\ndef test_nonexistent_id_error_for_device_retrieve(\n  base_url, session):\n\n  # Attempt retrieve\n  device_url = base_url.concat(f'/devices/{NONEXISTENT_ID}')\n  get_response = session.get(device_url)\n\n  # Verify error\n  verify_not_found(get_response)\n\n\ndef test_nonexistent_id_error_for_device_full_update(\n  base_url, session, light_data):\n\n  # Attempt put\n  device_url = base_url.concat(f'/devices/{NONEXISTENT_ID}')\n  put_response = session.put(device_url, json=light_data)\n\n  # Verify error\n  verify_not_found(put_response)\n\n\ndef test_nonexistent_id_error_for_device_partial_update(\n  base_url, session, thermostat_patch_data):\n\n  # Attempt patch\n  device_url = base_url.concat(f'/devices/{NONEXISTENT_ID}')\n  patch_response = session.patch(device_url, json=thermostat_patch_data)\n\n  # Verify error\n  verify_not_found(patch_response)\n\n\ndef test_nonexistent_id_error_for_device_delete(\n  base_url, session):\n\n  # Delete\n  device_id_url = base_url.concat(f'/devices/{NONEXISTENT_ID}')\n  delete_response = session.delete(device_id_url)\n\n  # Verify error\n  verify_not_found(delete_response)\n\n\n# --------------------------------------------------------------------------------\n# Missing Body Tests\n# --------------------------------------------------------------------------------\n\ndef verify_body_missing(response):\n  body = response.json()\n  assert response.status_code == 422\n  assert body['detail'] == 'Unprocessable Entity'\n  assert body['specifics'] == [{\n    'loc': ['body'],\n    'msg': 'field required',\n    'type': 'value_error.missing'}]\n\n\ndef test_missing_body_error_for_device_create(\n  base_url, session):\n\n  # Attempt create\n  device_url = base_url.concat('/devices')\n  post_response = session.post(device_url)\n\n  # Verify error\n  verify_body_missing(post_response)\n\n\ndef test_missing_body_error_for_device_full_update(\n  base_url, session, thermostat):\n\n  # Attempt put\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  put_response = session.put(device_url)\n\n  # Verify error\n  verify_body_missing(put_response)\n\n\ndef test_missing_body_error_for_device_partial_update(\n  base_url, session, thermostat):\n\n  # Attempt patch\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  patch_response = session.patch(device_url)\n\n  # Verify error\n  verify_body_missing(patch_response)\n\n\n# --------------------------------------------------------------------------------\n# Missing Field Tests\n# --------------------------------------------------------------------------------\n\nFIELDS = ['name', 'location', 'type', 'model', 'serial_number']\n\n\ndef verify_missing_field(response, field):\n  body = response.json()\n  assert response.status_code == 422\n  assert body['detail'] == 'Unprocessable Entity'\n  assert body['specifics'] == [{\n    'loc': ['body', field],\n    'msg': 'field required',\n    'type': 'value_error.missing'}]\n\n\n@pytest.mark.parametrize('field', FIELDS)\ndef test_missing_field_error_for_device_create(\n  field, base_url, session, thermostat_data):\n\n  # Attempt create\n  del thermostat_data[field]\n  device_url = base_url.concat('/devices')\n  post_response = session.post(device_url, json=thermostat_data)\n  \n  # Verify error\n  verify_missing_field(post_response, field)\n\n\n@pytest.mark.parametrize('field', FIELDS)\ndef test_missing_field_error_for_device_full_update(\n  field, base_url, session, thermostat, light_data):\n\n  # Attempt put\n  del light_data[field]\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  put_response = session.put(device_url, json=light_data)\n\n  # Verify error\n  verify_missing_field(put_response, field)\n\n\n# --------------------------------------------------------------------------------\n# Invalid Field Name Tests\n# --------------------------------------------------------------------------------\n\ndef verify_invalid_field_name(response, field):\n  body = response.json()\n  assert response.status_code == 422\n  assert body['detail'] == 'Unprocessable Entity'\n  assert body['specifics'] == [{\n    'loc': ['body', field],\n    'msg': 'extra fields not permitted',\n    'type': 'value_error.extra'}]\n\n\n@pytest.mark.parametrize(\n  'field, value',\n  [\n    ('id', 500),\n    ('owner', 'nobody'),\n    ('garbage', 'nonsense')\n  ]\n)\ndef test_invalid_field_name_error_for_device_create(\n  field, value, base_url, session, thermostat_data):\n\n  # Attempt create\n  thermostat_data[field] = value\n  device_url = base_url.concat('/devices')\n  post_response = session.post(device_url, json=thermostat_data)\n  \n  # Verify error\n  verify_invalid_field_name(post_response, field)\n\n\n@pytest.mark.parametrize(\n  'field, value',\n  [\n    ('id', 500),\n    ('owner', 'nobody'),\n    ('garbage', 'nonsense')\n  ]\n)\ndef test_invalid_field_name_error_for_device_full_update(\n  field, value, base_url, session, thermostat, light_data):\n\n  # Attempt put\n  light_data[field] = value\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  put_response = session.put(device_url, json=light_data)\n\n  # Verify error\n  verify_invalid_field_name(put_response, field)\n\n\n@pytest.mark.parametrize(\n  'field, value',\n  [\n    ('id', 500),\n    ('owner', 'nobody'),\n    ('type', 'Light Switch'),\n    ('model', 'ABC123'),\n    ('serial_number', 'ABC123'),\n    ('garbage', 'nonsense')\n  ]\n)\ndef test_invalid_field_name_error_for_device_partial_update(\n  field, value, base_url, session, thermostat, thermostat_patch_data):\n\n  # Attempt patch\n  thermostat_patch_data[field] = value\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  patch_response = session.patch(device_url, json=thermostat_patch_data)\n\n  # Verify error\n  verify_invalid_field_name(patch_response, field)\n\n\n# --------------------------------------------------------------------------------\n# Invalid Field Value Tests\n# --------------------------------------------------------------------------------\n\nINVALID_VALUES = [\n  ('name', None),\n  ('location', None),\n  ('type', None),\n  ('model', None),\n  ('serial_number', None)\n]\n\n\ndef verify_invalid_field_value(response, field):\n  body = response.json()\n  assert response.status_code == 422\n  assert body['detail'] == 'Unprocessable Entity'\n  assert body['specifics'] == [{\n    'loc': ['body', field],\n    'msg': 'none is not an allowed value',\n    'type': 'type_error.none.not_allowed'}]\n\n\n@pytest.mark.parametrize('field, value', INVALID_VALUES)\ndef test_invalid_field_value_error_for_device_create(\n  field, value, base_url, session, thermostat_data):\n\n  # Attempt create\n  thermostat_data[field] = value\n  device_url = base_url.concat('/devices')\n  post_response = session.post(device_url, json=thermostat_data)\n  \n  # Verify error\n  verify_invalid_field_value(post_response, field)\n\n\n@pytest.mark.parametrize('field, value', INVALID_VALUES)\ndef test_invalid_field_value_error_for_device_full_create(\n  field, value, base_url, session, thermostat, light_data):\n\n  # Attempt put\n  light_data[field] = value\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  put_response = session.put(device_url, json=light_data)\n\n  # Verify error\n  verify_invalid_field_value(put_response, field)\n"}
{"type": "test_file", "path": "tests/integration/test_status.py", "content": "\"\"\"\nThis module contains integration tests for the '/status' resource.\nThe main method for '/status' is GET.\nHEAD and OPTIONS methods are also supported.\nUnsupported methods should return 405 status codes.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nimport pytest\nimport requests\n\n\n# --------------------------------------------------------------------------------\n# Tests for GET\n# --------------------------------------------------------------------------------\n\ndef test_status_get(base_url):\n  url = base_url.concat('/status')\n  response = requests.get(url)\n  data = response.json()\n  \n  assert response.status_code == 200\n  assert data['online'] == True\n  assert data['uptime'] > 0\n\n\n# --------------------------------------------------------------------------------\n# Tests for HEAD\n# --------------------------------------------------------------------------------\n\ndef test_status_head(base_url):\n\n  # Call HEAD\n  url = base_url.concat('/status')\n  response = requests.head(url)\n  \n  # Response should be successful without a body\n  assert response.status_code == 200\n  assert response.text == ''\n\n  # Response headers should match GET responses\n  get_response = requests.get(url)\n  assert len(response.headers) == len(get_response.headers)\n\n  # Compare each header value\n  for header in response.headers:\n    assert header in get_response.headers\n\n    if header == 'content-length':\n      head_length = int(response.headers[header])\n      get_length = int(get_response.headers[header])\n      assert abs(head_length - get_length) <= 4\n    elif header != 'date':\n      assert response.headers[header] == get_response.headers[header]\n\n\n# --------------------------------------------------------------------------------\n# Tests for Unsupported Methods\n# --------------------------------------------------------------------------------\n\n@pytest.mark.parametrize(\n  'method',\n  ['DELETE', 'OPTIONS', 'PATCH', 'POST', 'PUT']\n)\ndef test_status_invalid_method(base_url, method):\n\n  # Call the unsupported method\n  url = base_url.concat('/status')\n  response = requests.request(method, url)\n  data = response.json()\n\n  # Response should be a 405 error\n  assert response.status_code == 405\n  assert data['detail'] == 'Method Not Allowed'\n\n"}
{"type": "test_file", "path": "tests/integration/test_devices_report.py", "content": "\"\"\"\nThis module contains tests for device reports.\nIt shows how to test file downloads via REST API.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Report Download Tests\n# --------------------------------------------------------------------------------\n\ndef test_device_report_download(base_url, session, thermostat):\n\n  # Download\n  device_id_url = base_url.concat(f'/devices/{thermostat[\"id\"]}/report')\n  get_response = session.get(device_id_url)\n\n  # Verify response\n  assert get_response.status_code == 200\n  assert get_response.headers['content-type'] == 'text/plain; charset=utf-8'\n  assert get_response.headers['content-disposition'] == 'attachment; filename=\"Main Thermostat.txt\"'\n  assert int(get_response.headers['content-length']) > 0\n\n  # Verify content\n  expected_report = \\\n    f\"ID: {thermostat['id']}\\n\" + \\\n    f\"Owner: {thermostat['owner']}\\n\" + \\\n    f\"Name: {thermostat['name']}\\n\" + \\\n    f\"Location: {thermostat['location']}\\n\" + \\\n    f\"Type: {thermostat['type']}\\n\" + \\\n    f\"Model: {thermostat['model']}\\n\" + \\\n    f\"Serial Number: {thermostat['serial_number']}\\n\" \n  \n  assert get_response.text == expected_report\n"}
{"type": "test_file", "path": "tests/integration/test_devices_creation.py", "content": "\"\"\"\nThis module contains a test for creating a device.\nIts coverage is superseded by test_devices_crud.py and could be deleted.\nHowever, it remains in this project to serve as example code.\nFurthermore, be warned that the first two tests do not perform cleanup.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nimport time\n\n\n# --------------------------------------------------------------------------------\n# Tests\n# --------------------------------------------------------------------------------\n\ndef test_create_device(base_url, session):\n\n  # Test data\n  thermostat_data = {\n    'name': 'Main Thermostat',\n    'location': 'Living Room',\n    'type': 'Thermostat',\n    'model': 'ThermoBest 3G',\n    'serial_number': 'TB3G-12345'\n  }\n\n  # Create\n  device_url = base_url.concat('/devices')\n  post_response = session.post(device_url, json=thermostat_data)\n  post_data = post_response.json()\n  \n  # Verify create\n  assert post_response.status_code == 200\n  assert 'id' in post_data\n  assert isinstance(post_data['id'], int)\n  thermostat_data['id'] = post_data['id']\n  thermostat_data['owner'] = session.auth[0]\n  assert post_data == thermostat_data\n\n  # Retrieve\n  device_id_url = base_url.concat(f'/devices/{post_data[\"id\"]}')\n  get_response = session.get(device_id_url)\n  get_data = get_response.json()\n\n  # Verify retrieve\n  assert get_response.status_code == 200\n  assert get_data == post_data\n\n\ndef test_create_device_with_waiting(base_url, session):\n\n  # This test is a copy of the test_create_device.\n  # The \"create\" steps are identical.\n  # The \"retrieve\" steps, however, actively wait for the device.\n\n  thermostat_data = {\n    'name': 'Main Thermostat',\n    'location': 'Living Room',\n    'type': 'Thermostat',\n    'model': 'ThermoBest 3G',\n    'serial_number': 'TB3G-12345'\n  }\n\n  device_url = base_url.concat('/devices')\n  post_response = session.post(device_url, json=thermostat_data)\n  post_data = post_response.json()\n  \n  assert post_response.status_code == 200\n  assert 'id' in post_data\n  assert isinstance(post_data['id'], int)\n  thermostat_data['id'] = post_data['id']\n  thermostat_data['owner'] = session.auth[0]\n  assert post_data == thermostat_data\n\n  device_id_url = base_url.concat(f'/devices/{post_data[\"id\"]}')\n  attempts = 60\n  get_code = 0\n\n  while get_code != 200 and attempts > 0:\n    attempts -= 1\n    time.sleep(1)\n    get_response = session.get(device_id_url)\n    get_code = get_response.status_code\n  \n  assert attempts > 0\n  assert get_response.status_code == 200\n  assert get_response.json() == post_data\n\n\ndef test_create_device_with_fixture(base_url, session, thermostat):\n\n  # Retrieve\n  device_url = base_url.concat(f'/devices/{thermostat[\"id\"]}')\n  get_response = session.get(device_url)\n  get_data = get_response.json()\n\n  # Verify retrieve\n  assert get_response.status_code == 200\n  assert get_data == thermostat\n"}
{"type": "test_file", "path": "tests/integration/test_devices_multi.py", "content": "\"\"\"\nThis module contains integration tests for the '/devices' resource.\nThese tests cover GET responses involving multiple devices.\nWe cannot guarantee that the devices we create will be the only devices in the system.\nFor example, if tests run in parallel, then other tests might create new devices.\nTherefore, test assertions must check only what is covered by the test.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nimport pytest\n\nfrom testlib.devices import verify_included, verify_excluded, verify_value\n\n\n# --------------------------------------------------------------------------------\n# Tests for Multiple Devices\n# --------------------------------------------------------------------------------\n\ndef test_multiple_device_retrieval(base_url, session, devices):\n\n  # Get all devices\n  url = base_url.concat('/devices')\n  get_response = session.get(url)\n  get_data = get_response.json()\n\n  # Verify all devices\n  assert get_response.status_code == 200\n  assert isinstance(get_data, list)\n  verify_included(get_data, devices)\n  verify_value(get_data, 'owner', devices[0]['owner'])\n\n\ndef test_delete_device_from_multiple(base_url, session, devices, device_creator):\n  \n  # Delete\n  id_to_delete = devices[1]['id']\n  device_id_url = base_url.concat(f'/devices/{id_to_delete}')\n  delete_response = session.delete(device_id_url)\n  delete_data = delete_response.json()\n\n  # Verify delete\n  assert delete_response.status_code == 200\n  assert not delete_data\n\n  # Get all devices\n  url = base_url.concat('/devices')\n  get_response = session.get(url)\n  get_data = get_response.json()\n\n  # Verify all devices\n  assert get_response.status_code == 200\n  assert isinstance(get_data, list)\n  del devices[1]\n  verify_included(get_data, devices)\n  verify_excluded(get_data, [id_to_delete])\n\n  # Mark device as deleted\n  device_creator.remove(id_to_delete)\n\n\n@pytest.mark.parametrize(\n  'parameter, value',\n  [\n    ('name', 'Front Porch Light'),\n    ('location', 'Front Porch'),\n    ('type', 'Light Switch'),\n    ('model', 'GenLight 64B'),\n    ('serial_number', 'GL64B-99987')\n  ]\n)\ndef test_devices_with_query_parameters(base_url, session, devices, parameter, value):\n\n  # Get all devices\n  url = base_url.concat('/devices')\n  get_response = session.get(url, params={parameter: value})\n  get_data = get_response.json()\n\n  # Verify response\n  assert get_response.status_code == 200\n  assert isinstance(get_data, list)\n\n  # Verify that the response has only the target device\n  assert len(get_data) > 0\n  verify_value(get_data, parameter, value)\n  \n\ndef test_devices_with_invalid_query_parameters_ignored(base_url, session, devices):\n\n  # Get all devices with invalid query parameteres\n  url = base_url.concat('/devices')\n  get_response = session.get(url, params={'invalid': 'value'})\n  get_data = get_response.json()\n\n  # Verify response and devices\n  assert get_response.status_code == 200\n  assert isinstance(get_data, list)\n  verify_included(get_data, devices)\n\n\ndef test_devices_with_multiple_query_parameters(base_url, session, devices):\n\n  # Get all devices\n  url = base_url.concat('/devices')\n  params = {'name': 'Front Porch Light', 'location': 'Front Porch'}\n  get_response = session.get(url, params=params)\n  get_data = get_response.json()\n\n  # Verify response\n  assert get_response.status_code == 200\n  assert isinstance(get_data, list)\n\n  # Verify that the response has only the target device\n  assert len(get_data) > 0\n  verify_value(get_data, 'name', 'Front Porch Light')\n  verify_value(get_data, 'location', 'Front Porch')\n\n\ndef test_devices_with_multiple_query_parameters_matching_no_device(base_url, session, devices):\n\n  # Get all devices\n  url = base_url.concat('/devices')\n  params = {'name': 'Back Porch Light', 'location': 'Front Porch'}\n  get_response = session.get(url, params=params)\n  get_data = get_response.json()\n\n  # Verify empty response\n  assert get_response.status_code == 200\n  assert isinstance(get_data, list)\n  assert len(get_data) == 0\n"}
{"type": "source_file", "path": "app/exceptions.py", "content": "\"\"\"\nThis module provides exceptions for the app.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nfrom fastapi import HTTPException, status\n\n\n# --------------------------------------------------------------------------------\n# Exceptions\n# --------------------------------------------------------------------------------\n\nclass UnauthorizedException(HTTPException):\n  def __init__(self):\n    super().__init__(status.HTTP_401_UNAUTHORIZED, \"Unauthorized\")\n\n\nclass ForbiddenException(HTTPException):\n  def __init__(self):\n    super().__init__(status.HTTP_403_FORBIDDEN, \"Forbidden\")\n\n\nclass NotFoundException(HTTPException):\n  def __init__(self):\n    super().__init__(status.HTTP_404_NOT_FOUND, \"Not Found\")\n"}
{"type": "source_file", "path": "app/__init__.py", "content": "\"\"\"\nThis module builds shared parts for other modules.\nIt reads in the `config.json` file for app configuration.\nWarning: No error-checking is done for the config.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nimport json\nimport time\nimport tinydb\n\n\n# --------------------------------------------------------------------------------\n# Set Start Time\n# --------------------------------------------------------------------------------\n\nstart_time = time.time()\n\n\n# --------------------------------------------------------------------------------\n# Read Configuration\n# --------------------------------------------------------------------------------\n\nwith open('config.json') as config_json:\n  config = json.load(config_json)\n\n\n# --------------------------------------------------------------------------------\n# Connect the Database\n# --------------------------------------------------------------------------------\n\nchosen_db = config['database']\ndb_file = config['databases'][chosen_db]\ndb = tinydb.TinyDB(db_file)\n\n\n# --------------------------------------------------------------------------------\n# Establish the Secret Key\n# --------------------------------------------------------------------------------\n\nsecret_key = config['secret_key']\n\n\n# --------------------------------------------------------------------------------\n# Establish the Users\n# --------------------------------------------------------------------------------\n\nusers = config['users']\n\n\n# --------------------------------------------------------------------------------\n# Insert Data into the Database\n# --------------------------------------------------------------------------------\n\n# db.insert(\n#   {\n#     'name': 'Front Porch Light',\n#     'location': 'Front Porch',\n#     'type': 'Light Switch',\n#     'model': 'GenLight 64B',\n#     'serial_number': 'GL64B-99987',\n#     'owner': 'pythonista'\n#   }\n# )\n# db.insert(\n#   {\n#     'name': 'Main Thermostat',\n#     'location': 'Living Room',\n#     'type': 'Thermostat',\n#     'model': 'ThermoBest 3G',\n#     'serial_number': 'TB3G-12345',\n#     'owner': 'pythonista'\n#   }\n# )\n# db.insert(\n#   {\n#     'name': 'Family Fridge',\n#     'location': 'Kitchen',\n#     'type': 'Refrigerator',\n#     'model': 'El Gee Mondo21',\n#     'serial_number': 'LGM-20201',\n#     'owner': 'engineer'\n#   }\n# )"}
{"type": "source_file", "path": "app/routers/devices.py", "content": "\"\"\"\nThis module provides routes for devices.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nfrom .. import db\nfrom ..auth import get_current_username\nfrom ..exceptions import ForbiddenException, NotFoundException\n\nfrom io import BytesIO\nfrom fastapi import APIRouter, Depends\nfrom fastapi.responses import StreamingResponse\nfrom pydantic import BaseModel\nfrom tinydb import Query\n\n\n# --------------------------------------------------------------------------------\n# Router\n# --------------------------------------------------------------------------------\n\nrouter = APIRouter()\n\n\n# --------------------------------------------------------------------------------\n# Models\n# --------------------------------------------------------------------------------\n\nclass BaseDeviceModel(BaseModel):\n  class Config:\n    extra = \"forbid\"\n\n\nclass Device(BaseDeviceModel):\n  id: int\n  owner: str\n  name: str\n  location: str\n  type: str\n  model: str\n  serial_number: str\n\n\nclass DevicePostPut(BaseDeviceModel):\n  name: str\n  location: str\n  type: str\n  model: str\n  serial_number: str\n\n\nclass DevicePatch(BaseDeviceModel):\n  name: str | None = None\n  location: str | None = None\n  \n\n# --------------------------------------------------------------------------------\n# Query Functions\n# --------------------------------------------------------------------------------\n\ndef query_device(device_id: int, username: str):\n  device = db.get(doc_id=device_id)\n\n  if not device:\n    raise NotFoundException()\n  elif device[\"owner\"] != username:\n    raise ForbiddenException()\n\n  device['id'] = device_id\n  return device\n\n\ndef update_device(device_id: int, data: dict, username: str):\n  query_device(device_id, username)\n  db.update(data, doc_ids=[device_id])\n\n  device = db.get(doc_id=device_id)\n  device['id'] = device_id\n  return device\n  \n\n# --------------------------------------------------------------------------------\n# Routes\n# --------------------------------------------------------------------------------\n\n@router.get(\"/devices\", summary=\"Get the user's devices\", response_model=list[Device])\n@router.get(\"/devices/\", include_in_schema=False)\n@router.head(\"/devices\", summary=\"Get the user's devices\")\n@router.head(\"/devices/\", include_in_schema=False)\ndef get_devices(\n  owner: str = Depends(get_current_username),\n  name: str | None = None,\n  location: str | None = None,\n  type: str | None = None,\n  model: str | None = None,\n  serial_number: str | None = None):\n  \"\"\"\n  Gets a list of all devices owned by the user.\n  May optionally take query parameters for filtering results.\n  Requires authentication.\n  \"\"\"\n\n  DeviceQuery = Query()\n  query = DeviceQuery.owner == owner\n\n  if name is not None:\n    query = (query) & (DeviceQuery.name == name)\n  if location is not None:\n    query = (query) & (DeviceQuery.location == location)\n  if type is not None:\n    query = (query) & (DeviceQuery.type == type)\n  if model is not None:\n    query = (query) & (DeviceQuery.model == model)\n  if serial_number is not None:\n    query = (query) & (DeviceQuery.serial_number == serial_number)\n\n  devices = db.search(query)\n\n  for d in devices:\n    d['id'] = d.doc_id\n\n  return devices\n\n\n@router.post(\"/devices\", summary=\"Create a new device\", response_model=Device)\n@router.post(\"/devices/\", include_in_schema=False)\ndef post_devices(device: DevicePostPut, username: str = Depends(get_current_username)):\n  \"\"\"\n  Adds a new device owned by the user.\n  Requires authentication.\n  \"\"\"\n\n  new_device = device.dict()\n  new_device[\"owner\"] = username\n  device_id = db.insert(new_device)\n\n  return query_device(device_id, username)\n\n\n@router.get(\"/devices/{device_id}\", summary=\"Get a device by ID\", response_model=Device)\n@router.get(\"/devices/{device_id}/\", include_in_schema=False)\n@router.head(\"/devices/{device_id}\", summary=\"Get a device by ID\")\n@router.head(\"/devices/{device_id}/\", include_in_schema=False)\ndef get_devices_id(device_id: int, username: str = Depends(get_current_username)):\n  \"\"\"\n  Gets a device owned by the user.\n  Requires authentication.\n  \"\"\"\n\n  return query_device(device_id, username)\n\n\n@router.put(\"/devices/{device_id}\", summary=\"Fully update a device\", response_model=Device)\n@router.put(\"/devices/{device_id}/\", include_in_schema=False)\ndef put_devices_id(device_id: int, device: DevicePostPut, username: str = Depends(get_current_username)):\n  \"\"\"\n  Fully updates a device owned by the user.\n  Requires authentication.\n  \"\"\"\n\n  data = device.dict()\n  return update_device(device_id, data, username)\n\n\n@router.patch(\"/devices/{device_id}\", summary=\"Update a device's name and location\", response_model=Device)\n@router.patch(\"/devices/{device_id}/\", include_in_schema=False)\ndef patch_devices_id(device_id: int, device: DevicePatch, username: str = Depends(get_current_username)):\n  \"\"\"\n  Partially updates a device owned by the user.\n  Can only update name and location - not other fields.\n  Requires authentication.\n  \"\"\"\n\n  data = device.dict(exclude_unset=True, exclude_none=True)\n  return update_device(device_id, data, username)\n\n\n@router.delete(\"/devices/{device_id}\", summary=\"Delete a device by ID\", response_model=dict)\n@router.delete(\"/devices/{device_id}/\", include_in_schema=False)\ndef delete_devices_id(device_id: int, username: str = Depends(get_current_username)):\n  \"\"\"\n  Deletes a device owned by the user.\n  Requires authentication.\n  \"\"\"\n\n  query_device(device_id, username)\n  db.remove(doc_ids=[device_id])\n  return dict()\n\n\n@router.get(\"/devices/{device_id}/report\", summary=\"Download a device report\")\n@router.get(\"/devices/{device_id}/report/\", include_in_schema=False)\n@router.head(\"/devices/{device_id}/report\", summary=\"Download a device report\")\n@router.head(\"/devices/{device_id}/report/\", include_in_schema=False)\ndef get_devices_id_report(device_id: int, username: str = Depends(get_current_username)):\n  \"\"\"\n  Prints a text-based report for a device owned by the user.\n  Requires authentication.\n  \"\"\"\n\n  device = query_device(device_id, username)\n\n  report = BytesIO()\n  report.write(bytes(f'ID: {device_id}\\n', 'ascii'))\n  report.write(bytes(f'Owner: {device[\"owner\"]}\\n', 'ascii'))\n  report.write(bytes(f'Name: {device[\"name\"]}\\n', 'ascii'))\n  report.write(bytes(f'Location: {device[\"location\"]}\\n', 'ascii'))\n  report.write(bytes(f'Type: {device[\"type\"]}\\n', 'ascii'))\n  report.write(bytes(f'Model: {device[\"model\"]}\\n', 'ascii'))\n  report.write(bytes(f'Serial Number: {device[\"serial_number\"]}\\n', 'ascii'))\n  report.seek(0)\n\n  report_length = str(report.getbuffer().nbytes)\n\n  response = StreamingResponse(report, media_type='text/plain')\n  content_disposition = f'attachment; filename=\"{device[\"name\"]}.txt\"'\n  response.headers.setdefault(\"content-disposition\", content_disposition)\n  response.headers.setdefault(\"content-length\", report_length)\n  return response\n"}
{"type": "source_file", "path": "app/routers/__init__.py", "content": ""}
{"type": "source_file", "path": "app/routers/root.py", "content": "\"\"\"\nThis module provides top-level routes.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nfrom fastapi import APIRouter\nfrom fastapi.responses import FileResponse, RedirectResponse\n\n\n# --------------------------------------------------------------------------------\n# Router\n# --------------------------------------------------------------------------------\n\nrouter = APIRouter()\n\n\n# --------------------------------------------------------------------------------\n# Routes\n# --------------------------------------------------------------------------------\n\n@router.get(\"/\", summary=\"Redirect to the docs\")\ndef get_root():\n  \"\"\"\n  Redirects to '/docs'.\n  \"\"\"\n\n  return RedirectResponse(\"/docs\")\n\n\n@router.get(\"/favicon.ico\", include_in_schema=False)\ndef get_favicon():\n  \"\"\"\n  Provides the app's favicon.\n  \"\"\"\n\n  return FileResponse('img/favicon.ico')\n\n\n@router.get(\"/logo.png\", include_in_schema=False)\ndef get_logo():\n  \"\"\"\n  Provides the app's logo.\n  \"\"\"\n\n  return FileResponse('img/logo.png')\n"}
{"type": "source_file", "path": "app/main.py", "content": "\"\"\"\nThis module is the main module for the FastAPI app.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nfrom fastapi import FastAPI, Request, status as fastapi_status\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.responses import JSONResponse\n\nfrom .routers import auth, devices, root, status\n\n\n# --------------------------------------------------------------------------------\n# App Creation\n# --------------------------------------------------------------------------------\n\napp = FastAPI()\napp.include_router(auth.router)\napp.include_router(devices.router)\napp.include_router(root.router)\napp.include_router(status.router)\n\n\n# --------------------------------------------------------------------------------\n# OpenAPI Customization\n# --------------------------------------------------------------------------------\n\ndef custom_openapi():\n    if app.openapi_schema:\n        return app.openapi_schema\n    openapi_schema = get_openapi(\n        title=\"Device Registry Service\",\n        version=\"2.0.0\",\n        description=\"A FastAPI web service for managing a smart device registry.\",\n        routes=app.routes,\n    )\n    openapi_schema[\"info\"][\"x-logo\"] = {\n        \"url\": \"logo.png\"\n    }\n    app.openapi_schema = openapi_schema\n    return app.openapi_schema\n\n\napp.openapi = custom_openapi\n\n\n# --------------------------------------------------------------------------------\n# Exception Overrides\n# --------------------------------------------------------------------------------\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\n  return JSONResponse(\n    status_code=fastapi_status.HTTP_422_UNPROCESSABLE_ENTITY,\n    content={\n      \"detail\": \"Unprocessable Entity\",\n      \"specifics\": exc.errors(),\n    },\n  )"}
{"type": "source_file", "path": "app/auth.py", "content": "\"\"\"\nThis module provides security and authentication.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nimport jwt\nimport secrets\n\nfrom . import users, secret_key\nfrom .exceptions import UnauthorizedException\nfrom fastapi import Depends\nfrom fastapi.security import HTTPBasic, HTTPBasicCredentials\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\n\n\n# --------------------------------------------------------------------------------\n# Globals\n# --------------------------------------------------------------------------------\n\nsecurityBasic = HTTPBasic(auto_error=False)\nsecurityBearer = HTTPBearer(auto_error=False)\n\n\n# --------------------------------------------------------------------------------\n# Serializers\n# --------------------------------------------------------------------------------\n\ndef serialize_token(username: str):\n  return jwt.encode({\"username\": username}, secret_key, algorithm=\"HS256\")\n\n\ndef deserialize_token(token: str):\n  try:\n    data = jwt.decode(token, secret_key, algorithms=[\"HS256\"])\n    return data['username']\n  except:\n    return None\n\n\n# --------------------------------------------------------------------------------\n# Authentication Checkers\n# --------------------------------------------------------------------------------\n\ndef get_current_username(\n  basic: HTTPBasicCredentials = Depends(securityBasic),\n  bearer: HTTPAuthorizationCredentials = Depends(securityBearer)):\n\n  if basic:\n    if basic.username in users:\n      if secrets.compare_digest(basic.password, users[basic.username]):\n        return basic.username\n\n  elif bearer:\n    if current_username := deserialize_token(bearer.credentials):\n      if current_username in users:\n        return current_username\n    \n  raise UnauthorizedException()\n"}
{"type": "source_file", "path": "app/routers/status.py", "content": "\"\"\"\nThis module provides routes for status.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nimport time\n\nfrom .. import start_time\nfrom fastapi import APIRouter\nfrom pydantic import BaseModel\n\n\n# --------------------------------------------------------------------------------\n# Router\n# --------------------------------------------------------------------------------\n\nrouter = APIRouter()\n\n\n# --------------------------------------------------------------------------------\n# Models\n# --------------------------------------------------------------------------------\n\nclass Status(BaseModel):\n  online: bool\n  uptime: float\n\n\n# --------------------------------------------------------------------------------\n# Routes\n# --------------------------------------------------------------------------------\n\n@router.get(\"/status\", summary=\"Get the status of the service\", response_model=Status)\n@router.get(\"/status/\", include_in_schema=False)\n@router.head(\"/status\", summary=\"Get the status of the service\")\n@router.head(\"/status/\", include_in_schema=False)\ndef get_status():\n  \"\"\"\n  Provides uptime information about the web service.\n  \"\"\"\n\n  return Status(\n    online=True,\n    uptime=round(time.time() - start_time, 3)\n  )"}
{"type": "source_file", "path": "app/routers/auth.py", "content": "\"\"\"\nThis module provides routes for authentication.\n\"\"\"\n\n# --------------------------------------------------------------------------------\n# Imports\n# --------------------------------------------------------------------------------\n\nfrom ..auth import get_current_username, serialize_token\n\nfrom fastapi import APIRouter, Depends\nfrom pydantic import BaseModel\n\n\n# --------------------------------------------------------------------------------\n# Router\n# --------------------------------------------------------------------------------\n\nrouter = APIRouter()\n\n\n# --------------------------------------------------------------------------------\n# Models\n# --------------------------------------------------------------------------------\n\nclass Token(BaseModel):\n  token: str\n\n\n# --------------------------------------------------------------------------------\n# Routes\n# --------------------------------------------------------------------------------\n\n@router.get(\"/authenticate\", summary=\"Generate an auth token\", response_model=Token)\n@router.get(\"/authenticate/\", include_in_schema=False)\n@router.head(\"/authenticate\", summary=\"Generate an auth token\")\n@router.head(\"/authenticate/\", include_in_schema=False)\ndef get_authenticate(username: str = Depends(get_current_username)):\n  \"\"\"\n  Uses HTTP basic authentication to generate an authentication token.\n  Any resource that requires authentication can use either basic auth or this token.\n  \"\"\"\n\n  token = serialize_token(username)\n  return Token(token=token)"}

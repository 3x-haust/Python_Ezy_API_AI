{"repo_info": {"repo_name": "xbox-smartglass-core-python", "repo_owner": "OpenXbox", "repo_url": "https://github.com/OpenXbox/xbox-smartglass-core-python"}}
{"type": "test_file", "path": "tests/conftest.py", "content": "import os\nimport pytest\nimport uuid\nimport json\nfrom fastapi import FastAPI\nfrom fastapi.testclient import TestClient\n\nfrom binascii import unhexlify\nfrom construct import Container\n\nfrom xbox.sg import enum, packer, packet\n\nfrom xbox.sg.console import Console\nfrom xbox.sg.crypto import Crypto\nfrom xbox.sg.manager import MediaManager, TextManager, InputManager\n\nfrom xbox.auxiliary.crypto import AuxiliaryStreamCrypto\n\nfrom xbox.stump.manager import StumpManager\n\nfrom xbox.rest.app import app as rest_app\nfrom xbox.rest.consolewrap import ConsoleWrap\n\n\n@pytest.fixture(scope='session')\ndef uuid_dummy():\n    return uuid.UUID('de305d54-75b4-431b-adb2-eb6b9e546014')\n\n\n@pytest.fixture(scope='session')\ndef console_address():\n    return '10.11.12.12'\n\n\n@pytest.fixture(scope='session')\ndef console_name():\n    return 'TestConsole'\n\n\n@pytest.fixture(scope='session')\ndef console_liveid():\n    return 'FD0000123456789'\n\n\n@pytest.fixture(scope='session')\ndef console_flags():\n    return enum.PrimaryDeviceFlag.AllowAnonymousUsers | enum.PrimaryDeviceFlag.AllowAuthenticatedUsers\n\n\n@pytest.fixture(scope='session')\ndef public_key_bytes():\n    return unhexlify(\n        b'041815d5382df79bd792a8d8342fbc717eacef6a258f779279e5463573e06b'\n        b'f84c6a88fac904870bf3a26f856e65f483195c4323eef47a048f23a031da6bd0929d'\n    )\n\n\n@pytest.fixture(scope='session')\ndef shared_secret_bytes():\n    return unhexlify(\n        '82bba514e6d19521114940bd65121af234c53654a8e67add7710b3725db44f77'\n        '30ed8e3da7015a09fe0f08e9bef3853c0506327eb77c9951769d923d863a2f5e'\n    )\n\n\n@pytest.fixture(scope='session')\ndef crypto(shared_secret_bytes):\n    return Crypto.from_shared_secret(shared_secret_bytes)\n\n\n@pytest.fixture(scope='session')\ndef console(console_address, console_name, uuid_dummy, console_liveid, console_flags, public_key_bytes):\n    c = Crypto.from_bytes(public_key_bytes)\n    console = Console(\n        console_address, console_name, uuid_dummy,\n        console_liveid, console_flags, 0, c.foreign_pubkey\n    )\n    console.add_manager(StumpManager)\n    console.add_manager(MediaManager)\n    console.add_manager(TextManager)\n    console.add_manager(InputManager)\n    return console\n\n\n@pytest.fixture(scope='session')\ndef public_key(public_key_bytes):\n    c = Crypto.from_bytes(public_key_bytes)\n    return c.foreign_pubkey\n\n\n@pytest.fixture(scope='session')\ndef packets():\n    # Who cares about RAM anyway?\n    data = {}\n    data_path = os.path.join(os.path.dirname(__file__), 'data', 'packets')\n    for f in os.listdir(data_path):\n        with open(os.path.join(data_path, f), 'rb') as fh:\n            data[f] = fh.read()\n\n    return data\n\n\n@pytest.fixture(scope='session')\ndef stump_json():\n    # Who cares about RAM anyway?\n    data = {}\n    data_path = os.path.join(os.path.dirname(__file__), 'data', 'stump_json')\n    for f in os.listdir(data_path):\n        with open(os.path.join(data_path, f), 'rt') as fh:\n            data[f] = json.load(fh)\n\n    return data\n\n\n@pytest.fixture(scope='session')\ndef decrypted_packets(packets, crypto):\n    return {k: packer.unpack(v, crypto) for k, v in packets.items()}\n\n\n@pytest.fixture(scope='session')\ndef pcap_filepath():\n    return os.path.join(os.path.dirname(__file__), 'data', 'sg_capture.pcap')\n\n\n@pytest.fixture(scope='session')\ndef certificate_data():\n    filepath = os.path.join(os.path.dirname(__file__), 'data', 'selfsigned_cert.bin')\n    with open(filepath, 'rb') as f:\n        data = f.read()\n    return data\n\n\n@pytest.fixture(scope='session')\ndef json_fragments():\n    filepath = os.path.join(os.path.dirname(__file__), 'data', 'json_fragments.json')\n    with open(filepath, 'rt') as f:\n        data = json.load(f)\n    return data['fragments']\n\n\n@pytest.fixture(scope='session')\ndef aux_streams():\n    data = {}\n    data_path = os.path.join(os.path.dirname(__file__), 'data', 'aux_streams')\n    for f in os.listdir(data_path):\n        with open(os.path.join(data_path, f), 'rb') as fh:\n            data[f] = fh.read()\n\n    return data\n\n\n@pytest.fixture(scope='session')\ndef aux_crypto(decrypted_packets):\n    connection_info = decrypted_packets['auxiliary_stream_connection_info'].protected_payload.connection_info\n    return AuxiliaryStreamCrypto.from_connection_info(connection_info)\n\n\n@pytest.fixture\ndef rest_client():\n    app = FastAPI()\n    client = TestClient(app)\n    yield client\n\n\n@pytest.fixture(scope='session')\ndef media_state():\n    return packet.message.media_state(\n        title_id=274278798,\n        aum_id='AIVDE_s9eep9cpjhg6g!App',\n        asset_id='',\n        media_type=enum.MediaType.Video,\n        sound_level=enum.SoundLevel.Full,\n        enabled_commands=enum.MediaControlCommand.Play | enum.MediaControlCommand.Pause,\n        playback_status=enum.MediaPlaybackStatus.Playing,\n        rate=1.00,\n        position=0,\n        media_start=0,\n        media_end=0,\n        min_seek=0,\n        max_seek=0,\n        metadata=[\n            Container(name='title', value='Some Movietitle'),\n            Container(name='subtitle', value='')\n        ]\n    )\n\n\n@pytest.fixture(scope='session')\ndef active_title():\n    struct = packet.message._active_title(\n        title_id=714681658,\n        product_id=uuid.UUID('00000000-0000-0000-0000-000000000000'),\n        sandbox_id=uuid.UUID('00000000-0000-0000-0000-000000000000'),\n        aum='Xbox.Home_8wekyb3d8bbwe!Xbox.Home.Application',\n        disposition=Container(\n            has_focus=True,\n            title_location=enum.ActiveTitleLocation.StartView\n        )\n    )\n    return struct\n\n\n@pytest.fixture(scope='session')\ndef active_media_title():\n    struct = packet.message._active_title(\n        title_id=714681658,\n        product_id=uuid.UUID('00000000-0000-0000-0000-000000000000'),\n        sandbox_id=uuid.UUID('00000000-0000-0000-0000-000000000000'),\n        aum='AIVDE_s9eep9cpjhg6g!App',\n        disposition=Container(\n            has_focus=True,\n            title_location=enum.ActiveTitleLocation.StartView\n        )\n    )\n    return struct\n\n\n@pytest.fixture(scope='session')\ndef console_status(active_title):\n    return packet.message.console_status(\n        live_tv_provider=0,\n        major_version=10,\n        minor_version=0,\n        build_number=14393,\n        locale='en-US',\n        active_titles=[\n            active_title\n        ]\n    )\n\n\n@pytest.fixture(scope='session')\ndef console_status_with_media(active_media_title):\n    return packet.message.console_status(\n        live_tv_provider=0,\n        major_version=10,\n        minor_version=0,\n        build_number=14393,\n        locale='en-US',\n        active_titles=[\n            active_media_title\n        ]\n    )\n"}
{"type": "test_file", "path": "tests/test_adapters.py", "content": "import pytest\nimport construct\nfrom xbox.sg.utils import adapters\n\n\n@pytest.mark.skip(reason=\"Not Implemented\")\ndef test_cryptotunnel():\n    pass\n\n\ndef test_json():\n    import json\n\n    test_data = {\"Z\": \"ABC\", \"A\": \"XYZ\", \"B\": 23}\n    bytes_data = json.dumps(test_data,\n                            separators=(',', ':'),\n                            sort_keys=True).encode('utf-8')\n    adapter = adapters.JsonAdapter(construct.GreedyString(\"utf8\"))\n\n    parsed = adapter.parse(bytes_data)\n    built = adapter.build(test_data)\n\n    with pytest.raises(json.JSONDecodeError):\n        adapter.parse(b'invalid data')\n\n    with pytest.raises(TypeError):\n        adapter.parse(234)\n\n    with pytest.raises(TypeError):\n        adapter.parse(\"string\")\n\n    with pytest.raises(TypeError):\n        adapter.build(b'invalid data')\n\n    with pytest.raises(TypeError):\n        adapter.build(234)\n\n    with pytest.raises(TypeError):\n        adapter.build(\"string\")\n\n    assert parsed == test_data\n    assert built == bytes_data\n\n\ndef test_uuid(uuid_dummy):\n    import struct\n    test_data = uuid_dummy\n    uuid_string = str(test_data).upper()\n    uuid_stringbytes = uuid_string.encode('utf-8')\n    uuid_sgstring = struct.pack('>H', len(uuid_stringbytes)) + uuid_stringbytes + b'\\x00'\n    uuid_bytes = test_data.bytes\n\n    adapter_bytes = adapters.UUIDAdapter()\n    parsed_bytes = adapter_bytes.parse(uuid_bytes)\n    built_bytes = adapter_bytes.build(test_data)\n\n    adapter_string = adapters.UUIDAdapter(\"utf-8\")\n    parsed_sgstring = adapter_string.parse(uuid_sgstring)\n    built_sgstring = adapter_string.build(test_data)\n\n    adapter_invalid = adapters.UUIDAdapter(\"utf-invalid\")\n\n    with pytest.raises(LookupError):\n        adapter_invalid.parse(uuid_sgstring)\n\n    with pytest.raises(LookupError):\n        adapter_invalid.build(test_data)\n\n    with pytest.raises(construct.StreamError):\n        adapter_bytes.parse(uuid_bytes[:-2])\n\n    with pytest.raises(TypeError):\n        adapter_bytes.parse('string, not bytes object')\n\n    with pytest.raises(TypeError):\n        adapter_bytes.build('some-string, not UUID object')\n\n    with pytest.raises(construct.StreamError):\n        adapter_string.parse(uuid_sgstring[:-3])\n\n    with pytest.raises(TypeError):\n        adapter_string.parse('string, not sgstring-bytes')\n\n    with pytest.raises(TypeError):\n        adapter_string.build('some-string, not UUID object')\n\n    assert parsed_bytes == test_data\n    assert built_bytes == uuid_bytes\n    assert parsed_sgstring == test_data\n    assert built_sgstring == uuid_sgstring\n\n\ndef test_certificate(certificate_data):\n    import struct\n    prefixed_data = struct.pack('>H', len(certificate_data)) + certificate_data\n    certinfo = adapters.CertificateInfo(certificate_data)\n\n    adapter = adapters.CertificateAdapter()\n\n    parsed = adapter.parse(prefixed_data)\n    built = adapter.build(certinfo)\n\n    with pytest.raises(construct.core.StreamError):\n        adapter.parse(prefixed_data[:-6])\n\n    with pytest.raises(construct.core.StreamError):\n        adapter.parse(b'\\xAB' * 10)\n\n    with pytest.raises(construct.core.StreamError):\n        adapter.parse(certificate_data)\n\n    with pytest.raises(TypeError):\n        adapter.parse('string, not bytes')\n\n    with pytest.raises(TypeError):\n        adapter.parse(123)\n\n    with pytest.raises(TypeError):\n        adapter.build(b'\\xAB' * 10)\n\n    with pytest.raises(TypeError):\n        adapter.build(certificate_data)\n\n    with pytest.raises(TypeError):\n        adapter.build('string, not bytes')\n\n    with pytest.raises(TypeError):\n        adapter.build(123)\n\n    assert isinstance(parsed, adapters.CertificateInfo) is True\n    assert parsed == certinfo\n    assert built == prefixed_data\n\n\ndef test_certificateinfo(certificate_data):\n    certinfo = adapters.CertificateInfo(certificate_data)\n\n    with pytest.raises(ValueError):\n        adapters.CertificateInfo(certificate_data[:-1])\n\n    with pytest.raises(ValueError):\n        adapters.CertificateInfo(b'\\x23' * 10)\n\n    with pytest.raises(TypeError):\n        adapters.CertificateInfo('some string')\n\n    with pytest.raises(TypeError):\n        adapters.CertificateInfo(123)\n\n    with pytest.raises(TypeError):\n        certinfo.dump(encoding='invalid param')\n\n    assert certinfo.dump() == certificate_data\n    assert certinfo.liveid == 'FFFFFFFFFFF'\n"}
{"type": "test_file", "path": "tests/test_auxmanager.py", "content": "import pytest\n\nfrom xbox.sg.enum import ServiceChannel\nfrom xbox.auxiliary.manager import TitleManager, TitleManagerError\n\n\ndef test_manager_messagehandling(console, decrypted_packets):\n    manager = TitleManager(console)\n\n    def handle_msg(msg):\n        manager._pre_on_message(msg, ServiceChannel.Title)\n\n    assert manager.active_surface is None\n    assert manager.connection_info is None\n\n    # Send unpacked msgs to manager\n    handle_msg(decrypted_packets['active_surface_change'])\n    handle_msg(decrypted_packets['auxiliary_stream_connection_info'])\n\n    invalid_msg = decrypted_packets['auxiliary_stream_hello']\n    invalid_msg.header.flags(msg_type=0x3)\n    with pytest.raises(TitleManagerError):\n        handle_msg(invalid_msg)\n\n    assert manager.active_surface == decrypted_packets['active_surface_change'].protected_payload\n    assert manager.connection_info == decrypted_packets['auxiliary_stream_connection_info'].protected_payload.connection_info\n"}
{"type": "test_file", "path": "tests/test_cli_scripts.py", "content": "import pytest\n\n\n@pytest.mark.script_launch_mode('subprocess')\ndef test_cli_rest_server(script_runner):\n    \"\"\"\n    Needs to be done in subprocess due to monkey-patching\n    \"\"\"\n    ret = script_runner.run('xbox-rest-server', '--help')\n    assert ret.success\n\n\ndef test_cli_maincli(script_runner):\n    ret = script_runner.run('xbox-cli', '--help')\n    assert ret.success\n\n\ndef test_cli_discover(script_runner):\n    ret = script_runner.run('xbox-discover', '--help')\n    assert ret.success\n\n\ndef test_cli_poweron(script_runner):\n    ret = script_runner.run('xbox-poweron', '--help')\n    assert ret.success\n\n\ndef test_cli_poweroff(script_runner):\n    ret = script_runner.run('xbox-poweroff', '--help')\n    assert ret.success\n\n\ndef test_cli_repl(script_runner):\n    ret = script_runner.run('xbox-repl', '--help')\n    assert ret.success\n\n\ndef test_cli_replserver(script_runner):\n    ret = script_runner.run('xbox-replserver', '--help')\n    assert ret.success\n\n\ndef test_cli_textinput(script_runner):\n    ret = script_runner.run('xbox-textinput', '--help')\n    assert ret.success\n\n\ndef test_cli_gamepadinput(script_runner):\n    ret = script_runner.run('xbox-gamepadinput', '--help')\n    assert ret.success\n\n\ndef test_cli_tui(script_runner):\n    ret = script_runner.run('xbox-tui', '--help')\n    assert ret.success\n\n\ndef test_cli_falloutrelay(script_runner):\n    ret = script_runner.run('xbox-fo4-relay', '--help')\n    assert ret.success\n\n\ndef test_cli_pcap(script_runner):\n    ret = script_runner.run('xbox-pcap', '--help')\n    assert ret.success\n\n\ndef test_cli_recrypt(script_runner):\n    ret = script_runner.run('xbox-recrypt', '--help')\n    assert ret.success\n"}
{"type": "test_file", "path": "tests/test_console.py", "content": "from xbox.sg import console\nfrom xbox.sg import enum\nfrom xbox.sg import packer\n\n\ndef test_init(public_key, uuid_dummy):\n    c = console.Console(\n        '10.0.0.23', 'XboxOne', uuid_dummy, 'FFFFFFFFFFF',\n        enum.PrimaryDeviceFlag.AllowConsoleUsers, 0, public_key\n    )\n\n    assert c.address == '10.0.0.23'\n    assert c.flags == enum.PrimaryDeviceFlag.AllowConsoleUsers\n    assert c.name == 'XboxOne'\n    assert c.uuid == uuid_dummy\n    assert c.liveid == 'FFFFFFFFFFF'\n    assert c._public_key is not None\n    assert c._crypto is not None\n    assert c.device_status == enum.DeviceStatus.Unavailable\n    assert c.connection_state == enum.ConnectionState.Disconnected\n    assert c.pairing_state == enum.PairedIdentityState.NotPaired\n    assert c.paired is False\n    assert c.available is False\n    assert c.connected is False\n\n    assert c.authenticated_users_allowed is False\n    assert c.anonymous_connection_allowed is False\n    assert c.console_users_allowed is True\n    assert c.is_certificate_pending is False\n\n\ndef test_init_from_message(packets, crypto, uuid_dummy):\n    msg = packer.unpack(packets['discovery_response'], crypto)\n\n    c = console.Console.from_message('10.0.0.23', msg)\n\n    assert c.address == '10.0.0.23'\n    assert c.flags == enum.PrimaryDeviceFlag.AllowAuthenticatedUsers\n    assert c.name == 'XboxOne'\n    assert c.uuid == uuid_dummy\n    assert c.liveid == 'FFFFFFFFFFF'\n    assert c._public_key is not None\n    assert c._crypto is not None\n    assert c.device_status == enum.DeviceStatus.Available\n    assert c.connection_state == enum.ConnectionState.Disconnected\n    assert c.pairing_state == enum.PairedIdentityState.NotPaired\n    assert c.paired is False\n    assert c.available is True\n    assert c.connected is False\n\n    assert c.authenticated_users_allowed is True\n    assert c.anonymous_connection_allowed is False\n    assert c.console_users_allowed is False\n    assert c.is_certificate_pending is False\n"}
{"type": "test_file", "path": "tests/test_crypto.py", "content": "import pytest\nfrom binascii import unhexlify\nfrom xbox.sg.enum import PublicKeyType\n\n\ndef test_generate_random_iv(crypto):\n    rand_iv = crypto.generate_iv()\n    rand_iv_2 = crypto.generate_iv()\n\n    assert len(rand_iv) == 16\n    assert len(rand_iv_2) == 16\n    assert rand_iv != rand_iv_2\n\n\ndef test_generate_seeded_iv(crypto):\n    seed = unhexlify('000102030405060708090A0B0C0D0E0F')\n    seed2 = unhexlify('000F0E0D0C0B0A090807060504030201')\n\n    seed_iv = crypto.generate_iv(seed)\n    seed_iv_dup = crypto.generate_iv(seed)\n    seed_iv_2 = crypto.generate_iv(seed2)\n\n    assert len(seed_iv) == 16\n    assert seed_iv == seed_iv_dup\n    assert seed_iv != seed_iv_2\n\n\ndef test_encrypt_decrypt(crypto):\n    plaintext = b'Test String\\x00\\x00\\x00\\x00\\x00'\n    seed = unhexlify('000102030405060708090A0B0C0D0E0F')\n    seed_iv = crypto.generate_iv(seed)\n    encrypt = crypto.encrypt(seed_iv, plaintext)\n    decrypt = crypto.decrypt(seed_iv, encrypt)\n\n    assert plaintext == decrypt\n    assert plaintext != encrypt\n\n\ndef test_hash(crypto):\n    plaintext = b'Test String\\x00\\x00\\x00\\x00\\x00'\n    seed = unhexlify('000102030405060708090A0B0C0D0E0F')\n    seed_iv = crypto.generate_iv(seed)\n    encrypt = crypto.encrypt(seed_iv, plaintext)\n    hash = crypto.hash(encrypt)\n    hash_dup = crypto.hash(encrypt)\n    verify = crypto.verify(encrypt, hash)\n\n    assert hash == hash_dup\n    assert verify is True\n\n\ndef test_from_bytes(public_key_bytes, public_key):\n    from xbox.sg.crypto import Crypto\n    c1 = Crypto.from_bytes(public_key_bytes)\n    c2 = Crypto.from_bytes(public_key_bytes, PublicKeyType.EC_DH_P256)\n\n    # invalid public key type passed\n    with pytest.raises(ValueError):\n        Crypto.from_bytes(public_key_bytes, PublicKeyType.EC_DH_P521)\n    # invalid keylength\n    with pytest.raises(ValueError):\n        Crypto.from_bytes(public_key_bytes[5:])\n    # invalid parameter\n    with pytest.raises(ValueError):\n        Crypto.from_bytes(123)\n\n    assert c1.foreign_pubkey.public_numbers() == public_key.public_numbers()\n    assert c2.foreign_pubkey.public_numbers() == public_key.public_numbers()\n\n\ndef test_from_shared_secret(shared_secret_bytes):\n    from xbox.sg.crypto import Crypto\n    c = Crypto.from_shared_secret(shared_secret_bytes)\n\n    # invalid length\n    with pytest.raises(ValueError):\n        c.from_shared_secret(shared_secret_bytes[1:])\n\n    # invalid parameter\n    with pytest.raises(ValueError):\n        c.from_shared_secret(123)\n\n    assert c._encrypt_key == unhexlify(b'82bba514e6d19521114940bd65121af2')\n    assert c._iv_key == unhexlify(b'34c53654a8e67add7710b3725db44f77')\n    assert c._hash_key == unhexlify(\n        b'30ed8e3da7015a09fe0f08e9bef3853c0506327eb77c9951769d923d863a2f5e'\n    )\n"}
{"type": "test_file", "path": "tests/test_factory.py", "content": "import uuid\nfrom binascii import unhexlify\n\nfrom xbox.sg import enum, constants\nfrom xbox.sg import packer\nfrom xbox.sg import factory\n\n\ndef _pack(msg, crypto):\n    return packer.pack(msg, crypto)\n\n\ndef test_message_header():\n    msg = factory._message_header(\n        msg_type=enum.MessageType.Ack,\n        target_participant_id=2,\n        source_participant_id=3,\n        need_ack=False,\n        is_fragment=False,\n        channel_id=0xFFFF\n    )\n    packed = msg.build()\n\n    assert msg.flags.msg_type == enum.MessageType.Ack\n    assert msg.sequence_number == 0\n    assert msg.target_participant_id == 2\n    assert msg.source_participant_id == 3\n    assert msg.channel_id == 0xFFFF\n    assert msg.flags.need_ack is False\n    assert msg.flags.is_fragment is False\n\n    assert len(packed) == 26\n    assert packed == unhexlify(\n        b'd00d00000000000000000002000000038001000000000000ffff'\n    )\n\n\ndef test_power_on(packets, crypto):\n    bin_name = 'poweron_request'\n    msg = factory.power_on(liveid='FD00112233FFEE66')\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.PowerOnRequest\n    assert msg.header.version == 0\n    assert msg.unprotected_payload.liveid == 'FD00112233FFEE66'\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_discovery_request(packets, crypto):\n    bin_name = 'discovery_request'\n    msg = factory.discovery(client_type=enum.ClientType.Android)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.DiscoveryRequest\n    assert msg.header.version == 0\n\n    assert msg.unprotected_payload.flags == 0\n    assert msg.unprotected_payload.client_type == enum.ClientType.Android\n    assert msg.unprotected_payload.minimum_version == 0\n    assert msg.unprotected_payload.maximum_version == 2\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_connect_request(packets, crypto):\n    bin_name = 'connect_request'\n    msg = factory.connect(\n        sg_uuid=uuid.UUID('{de305d54-75b4-431b-adb2-eb6b9e546014}'),\n        public_key_type=enum.PublicKeyType.EC_DH_P256,\n        public_key=b'\\xFF' * 64,\n        iv=unhexlify('2979d25ea03d97f58f46930a288bf5d2'),\n        userhash='deadbeefdeadbeefde',\n        jwt='dummy_token',\n        msg_num=0,\n        num_start=0,\n        num_end=2\n    )\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.ConnectRequest\n\n    assert str(msg.unprotected_payload.sg_uuid) == 'de305d54-75b4-431b-adb2-eb6b9e546014'\n    assert msg.unprotected_payload.public_key_type == enum.PublicKeyType.EC_DH_P256\n    assert msg.unprotected_payload.public_key == b'\\xFF' * 64\n    assert msg.unprotected_payload.iv == unhexlify(\n        '2979d25ea03d97f58f46930a288bf5d2'\n    )\n\n    assert msg.protected_payload.userhash == 'deadbeefdeadbeefde'\n    assert msg.protected_payload.jwt == 'dummy_token'\n    assert msg.protected_payload.connect_request_num == 0\n    assert msg.protected_payload.connect_request_group_start == 0\n    assert msg.protected_payload.connect_request_group_end == 2\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\ndef test_connect_request_anonymous(packets, crypto):\n    bin_name = 'connect_request_anonymous'\n    msg = factory.connect(\n        sg_uuid=uuid.UUID('{de305d54-75b4-431b-adb2-eb6b9e546014}'),\n        public_key_type=enum.PublicKeyType.EC_DH_P256,\n        public_key=b'\\xFF' * 64,\n        iv=unhexlify('2979d25ea03d97f58f46930a288bf5d2'),\n        userhash='',\n        jwt='',\n        msg_num=0,\n        num_start=0,\n        num_end=1\n    )\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.ConnectRequest\n\n    assert str(msg.unprotected_payload.sg_uuid) == 'de305d54-75b4-431b-adb2-eb6b9e546014'\n    assert msg.unprotected_payload.public_key_type == enum.PublicKeyType.EC_DH_P256\n    assert msg.unprotected_payload.public_key == b'\\xFF' * 64\n    assert msg.unprotected_payload.iv == unhexlify(\n        '2979d25ea03d97f58f46930a288bf5d2'\n    )\n\n    assert msg.protected_payload.userhash == ''\n    assert msg.protected_payload.jwt == ''\n    assert msg.protected_payload.connect_request_num == 0\n    assert msg.protected_payload.connect_request_group_start == 0\n    assert msg.protected_payload.connect_request_group_end == 1\n\n    import binascii\n    print(binascii.hexlify(packed))\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\ndef test_message_fragment(packets, crypto):\n    data = unhexlify(\n        b'6a5297cd00424d6963726f736f66742e426c75726179506c617965725f3877656b79623364386262'\n        b'77652158626f782e426c75726179506c617965722e4170706c69636174696f6e0008883438303036'\n        b'31303036433030364630303230303035343030363830303635303032303030343630303631303036'\n        b'43303036433030323030303646303036363030323030303532303036353030363130303633303036'\n        b'38303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'303030303030303030303030303030303030303030303030'\n    )\n\n    msg = factory.message_fragment(\n        msg_type=enum.MessageType.MediaState,\n        sequence_begin=22,\n        sequence_end=25,\n        data=data,\n        need_ack=True,\n        source_participant_id=0,\n        target_participant_id=31,\n        channel_id=148\n    )\n\n    msg.header(sequence_number=22)\n\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.MediaState\n\n    assert msg.protected_payload.sequence_begin == 22\n    assert msg.protected_payload.sequence_end == 25\n    assert msg.protected_payload.data == data\n\n    assert isinstance(packed, bytes) is True\n    assert len(packed) == 1098\n\n    assert packed == packets['fragment_media_state_0']\n\n\ndef test_acknowledge(packets, crypto):\n    bin_name = 'acknowledge'\n    msg = factory.acknowledge(\n        low_watermark=0,\n        processed_list=[1],\n        rejected_list=[]\n    )\n    msg.header(\n        sequence_number=1,\n        target_participant_id=31,\n        channel_id=1152921504606846976\n    )\n    msg.header.flags(version=2, need_ack=False)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.Ack\n\n    assert msg.protected_payload.low_watermark == 0\n    assert msg.protected_payload.processed_list == [1]\n    assert msg.protected_payload.rejected_list == []\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_json(packets, crypto):\n    bin_name = 'json'\n    msg = factory.json(\n        text={'request': 'GetConfiguration', 'msgid': '2ed6c0fd.2'}\n    )\n    msg.header(\n        sequence_number=11,\n        source_participant_id=31,\n        channel_id=151\n    )\n    msg.header.flags(need_ack=True)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.Json\n\n    assert msg.protected_payload.text == {\n        'request': 'GetConfiguration', 'msgid': '2ed6c0fd.2'\n    }\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_disconnect(packets, crypto):\n    bin_name = 'disconnect'\n    msg = factory.disconnect(\n        reason=enum.DisconnectReason.Unspecified,\n        error_code=0\n    )\n    msg.header(\n        sequence_number=57,\n        source_participant_id=31\n    )\n    msg.header.flags(need_ack=False)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.Disconnect\n\n    assert msg.protected_payload.reason == enum.DisconnectReason.Unspecified\n    assert msg.protected_payload.error_code == 0\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_power_off(packets, crypto):\n    bin_name = 'power_off'\n    msg = factory.power_off(liveid='FD00112233FFEE66')\n    msg.header(\n        sequence_number=1882,\n        source_participant_id=2\n    )\n    msg.header.flags(need_ack=True)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.PowerOff\n\n    assert msg.protected_payload.liveid == 'FD00112233FFEE66'\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_local_join(packets, crypto):\n    class TestClientInfo(object):\n        DeviceType = enum.ClientType.Android\n        NativeWidth = 600\n        NativeHeight = 1024\n        DpiX = 160\n        DpiY = 160\n        DeviceCapabilities = constants.DeviceCapabilities.All\n        ClientVersion = 133713371\n        OSMajor = 42\n        OSMinor = 0\n        DisplayName = 'package.name.here'\n\n    bin_name = 'local_join'\n    msg = factory.local_join(client_info=TestClientInfo)\n    msg.header(\n        sequence_number=1,\n        source_participant_id=31\n    )\n    msg.header.flags(version=0)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.LocalJoin\n\n    assert msg.protected_payload.device_type == enum.ClientType.Android\n    assert msg.protected_payload.native_width == 600\n    assert msg.protected_payload.native_height == 1024\n    assert msg.protected_payload.dpi_x == 160\n    assert msg.protected_payload.dpi_y == 160\n    assert msg.protected_payload.device_capabilities == constants.DeviceCapabilities.All\n    assert msg.protected_payload.client_version == 133713371\n    assert msg.protected_payload.os_major_version == 42\n    assert msg.protected_payload.os_minor_version == 0\n    assert msg.protected_payload.display_name == 'package.name.here'\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_title_launch(packets, crypto):\n    bin_name = 'title_launch'\n    msg = factory.title_launch(\n        location=enum.ActiveTitleLocation.Fill,\n        uri='ms-xbl-0D174C79://default/'\n    )\n    msg.header(\n        sequence_number=685,\n        source_participant_id=32\n    )\n    msg.header.flags(need_ack=True)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.TitleLaunch\n\n    assert msg.protected_payload.location == enum.ActiveTitleLocation.Fill\n    assert msg.protected_payload.uri == 'ms-xbl-0D174C79://default/'\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_start_channel(packets, crypto):\n    bin_name = 'start_channel_request'\n    msg = factory.start_channel(\n        channel_request_id=1,\n        title_id=0,\n        service=constants.MessageTarget.SystemInputUUID,\n        activity_id=0\n    )\n    msg.header(\n        sequence_number=2,\n        source_participant_id=31\n    )\n    msg.header.flags(need_ack=True)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.StartChannelRequest\n\n    assert msg.protected_payload.channel_request_id == 1\n    assert msg.protected_payload.title_id == 0\n    assert msg.protected_payload.service == constants.MessageTarget.SystemInputUUID\n    assert msg.protected_payload.activity_id == 0\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_stop_channel(packets, crypto):\n    msg = factory.stop_channel(channel_id=2)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.StopChannel\n\n    assert msg.protected_payload.target_channel_id == 2\n\n    assert len(packed) == 74\n    assert packed == unhexlify(\n        b'd00d0008000000000000000000000000802800000000000000001b0783367a4426'\n        b'c2e0775916685c072df0380ee320925842716d595ced4b68f8a9bad01a5301be7e'\n        b'd7d3b4e25a03b728'\n    )\n\n\ndef test_gamepad(packets, crypto):\n    bin_name = 'gamepad'\n    msg = factory.gamepad(\n        timestamp=0,\n        buttons=enum.GamePadButton.PadB,\n        l_trigger=0.0,\n        r_trigger=0.0,\n        l_thumb_x=0.0,\n        r_thumb_x=0.0,\n        l_thumb_y=0.0,\n        r_thumb_y=0.0\n    )\n\n    msg.header(\n        sequence_number=79,\n        source_participant_id=41,\n        channel_id=180\n    )\n    msg.header.flags(need_ack=False)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.Gamepad\n\n    assert msg.protected_payload.timestamp == 0\n    assert msg.protected_payload.buttons == enum.GamePadButton.PadB\n    assert msg.protected_payload.left_trigger == 0.0\n    assert msg.protected_payload.right_trigger == 0.0\n    assert msg.protected_payload.left_thumbstick_x == 0.0\n    assert msg.protected_payload.right_thumbstick_x == 0.0\n    assert msg.protected_payload.left_thumbstick_y == 0.0\n    assert msg.protected_payload.right_thumbstick_y == 0.0\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_unsnap(packets, crypto):\n    msg = factory.unsnap(unknown=1)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.Unsnap\n\n    assert msg.protected_payload.unk == 1\n\n    assert len(packed) == 74\n    assert packed == unhexlify(\n        b'd00d000100000000000000000000000080370000000000000000738d3b76a69a34'\n        b'bbf732755035fe77672e5ea1432f3e278189d7756f62254ebe790dfe084ba43067'\n        b'bf3f4b2546c1f882'\n    )\n\n\ndef test_gamedvr_record(packets, crypto):\n    bin_name = 'gamedvr_record'\n    msg = factory.game_dvr_record(\n        start_time_delta=-60,\n        end_time_delta=0\n    )\n    msg.header(\n        sequence_number=70,\n        source_participant_id=1\n    )\n    msg.header.flags(need_ack=True)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.GameDvrRecord\n\n    assert msg.protected_payload.start_time_delta == -60\n    assert msg.protected_payload.end_time_delta == 0\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n\n\ndef test_media_command(packets, crypto):\n    bin_name = 'media_command'\n    msg = factory.media_command(\n        request_id=0,\n        title_id=274278798,\n        command=enum.MediaControlCommand.FastForward,\n        seek_position=0\n    )\n    msg.header(\n        sequence_number=597,\n        source_participant_id=32,\n        channel_id=153\n    )\n    msg.header.flags(need_ack=True)\n    packed = _pack(msg, crypto)\n\n    assert msg.header.pkt_type == enum.PacketType.Message\n    assert msg.header.flags.msg_type == enum.MessageType.MediaCommand\n\n    assert msg.protected_payload.request_id == 0\n    assert msg.protected_payload.title_id == 274278798\n    assert msg.protected_payload.command == enum.MediaControlCommand.FastForward\n\n    assert len(packed) == len(packets[bin_name])\n    assert packed == packets[bin_name]\n"}
{"type": "test_file", "path": "tests/test_managers.py", "content": "import pytest\n\n\n@pytest.mark.skip(reason=\"Not Implemented\")\ndef test_x1():\n    pass\n"}
{"type": "test_file", "path": "tests/test_packer.py", "content": "from binascii import hexlify, unhexlify\n\nfrom xbox.sg import packer, enum\nfrom xbox.sg.constants import MessageTarget\n\n\ndef _unpack(data, crypto):\n    return packer.unpack(data, crypto)\n\n\ndef _pack(msg, crypto):\n    return packer.pack(msg, crypto)\n\n\ndef test_poweron_request(packets, crypto):\n    unpacked = _unpack(packets['poweron_request'], crypto)\n\n    assert unpacked.header.pkt_type == enum.PacketType.PowerOnRequest\n    assert unpacked.header.unprotected_payload_length == 19\n    assert unpacked.header.version == 0\n\n    assert unpacked.unprotected_payload.liveid == 'FD00112233FFEE66'\n\n\ndef test_discovery_request(packets, crypto):\n    unpacked = _unpack(packets['discovery_request'], crypto)\n\n    assert unpacked.header.pkt_type == enum.PacketType.DiscoveryRequest\n    assert unpacked.header.unprotected_payload_length == 10\n    assert unpacked.header.version == 0\n\n    assert unpacked.unprotected_payload.flags == 0\n    assert unpacked.unprotected_payload.client_type == enum.ClientType.Android\n    assert unpacked.unprotected_payload.minimum_version == 0\n    assert unpacked.unprotected_payload.maximum_version == 2\n\n\ndef test_discovery_response(packets, crypto, public_key):\n    unpacked = _unpack(packets['discovery_response'], crypto)\n\n    assert unpacked.header.pkt_type == enum.PacketType.DiscoveryResponse\n    assert unpacked.header.unprotected_payload_length == 580\n    assert unpacked.header.version == 2\n    assert unpacked.unprotected_payload.name == 'XboxOne'\n    assert str(unpacked.unprotected_payload.uuid) == 'DE305D54-75B4-431B-ADB2-EB6B9E546014'.lower()\n    assert unpacked.unprotected_payload.last_error == 0\n    assert unpacked.unprotected_payload.cert.liveid == 'FFFFFFFFFFF'\n    assert unpacked.unprotected_payload.cert.pubkey.public_numbers() == public_key.public_numbers()\n\n\ndef test_connect_request(packets, crypto):\n    unpacked = _unpack(packets['connect_request'], crypto)\n    assert unpacked.header.pkt_type == enum.PacketType.ConnectRequest\n    assert unpacked.header.unprotected_payload_length == 98\n    assert unpacked.header.protected_payload_length == 47\n    assert unpacked.header.version == 2\n    assert str(unpacked.unprotected_payload.sg_uuid) == 'de305d54-75b4-431b-adb2-eb6b9e546014'\n    assert unpacked.unprotected_payload.public_key == b'\\xff' * 64\n    assert unpacked.unprotected_payload.iv == unhexlify('2979d25ea03d97f58f46930a288bf5d2')\n    assert unpacked.protected_payload.userhash == 'deadbeefdeadbeefde'\n    assert unpacked.protected_payload.jwt == 'dummy_token'\n    assert unpacked.protected_payload.connect_request_num == 0\n    assert unpacked.protected_payload.connect_request_group_start == 0\n    assert unpacked.protected_payload.connect_request_group_end == 2\n\ndef test_connect_request_anonymous(packets, crypto):\n    unpacked = _unpack(packets['connect_request_anonymous'], crypto)\n    assert unpacked.header.pkt_type == enum.PacketType.ConnectRequest\n    assert unpacked.header.unprotected_payload_length == 98\n    assert unpacked.header.protected_payload_length == 18\n    assert unpacked.header.version == 2\n    assert str(unpacked.unprotected_payload.sg_uuid) == 'de305d54-75b4-431b-adb2-eb6b9e546014'\n    assert unpacked.unprotected_payload.public_key == b'\\xff' * 64\n    assert unpacked.unprotected_payload.iv == unhexlify('2979d25ea03d97f58f46930a288bf5d2')\n    assert unpacked.protected_payload.userhash == ''\n    assert unpacked.protected_payload.jwt == ''\n    assert unpacked.protected_payload.connect_request_num == 0\n    assert unpacked.protected_payload.connect_request_group_start == 0\n    assert unpacked.protected_payload.connect_request_group_end == 1\n\ndef test_connect_response(packets, crypto):\n    unpacked = _unpack(packets['connect_response'], crypto)\n\n    assert unpacked.header.pkt_type == enum.PacketType.ConnectResponse\n    assert unpacked.header.unprotected_payload_length == 16\n    assert unpacked.header.protected_payload_length == 8\n    assert unpacked.header.version == 2\n    assert unpacked.unprotected_payload.iv == unhexlify('c6373202bdfd1167cf9693491d22322a')\n    assert unpacked.protected_payload.connect_result == enum.ConnectionResult.Success\n    assert unpacked.protected_payload.pairing_state == enum.PairedIdentityState.NotPaired\n    assert unpacked.protected_payload.participant_id == 31\n\n\ndef test_local_join(packets, crypto):\n    unpacked = _unpack(packets['local_join'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.LocalJoin\n    assert payload.device_type == enum.ClientType.Android\n    assert payload.native_width == 600\n    assert payload.native_height == 1024\n    assert payload.dpi_x == 160\n    assert payload.dpi_y == 160\n    assert payload.device_capabilities == enum.DeviceCapabilities.All\n    assert payload.client_version == 133713371\n    assert payload.os_major_version == 42\n    assert payload.os_minor_version == 0\n    assert payload.display_name == 'package.name.here'\n\n\ndef test_acknowledge(packets, crypto):\n    unpacked = _unpack(packets['acknowledge'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.Ack\n    assert payload.low_watermark == 0\n    assert payload.processed_list == [1]\n    assert payload.rejected_list == []\n\n\ndef test_paired_identity_state_changed(packets, crypto):\n    unpacked = _unpack(packets['paired_identity_state_changed'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.PairedIdentityStateChanged\n    assert payload.state == enum.PairedIdentityState.Paired\n\n\ndef test_fragmented_message(packets, crypto):\n    data = unhexlify(\n        b'6a5297cd00424d6963726f736f66742e426c75726179506c617965725f3877656b79623364386262'\n        b'77652158626f782e426c75726179506c617965722e4170706c69636174696f6e0008883438303036'\n        b'31303036433030364630303230303035343030363830303635303032303030343630303631303036'\n        b'43303036433030323030303646303036363030323030303532303036353030363130303633303036'\n        b'38303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'30303030303030303030303030303030303030303030303030303030303030303030303030303030'\n        b'303030303030303030303030303030303030303030303030'\n    )\n\n    unpacked = _unpack(packets['fragment_media_state_0'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.MediaState\n    assert payload.sequence_begin == 22\n    assert payload.sequence_end == 25\n    assert payload.data == data\n\n\ndef test_gamedvr_record(packets, crypto):\n    unpacked = _unpack(packets['gamedvr_record'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.GameDvrRecord\n    assert payload.start_time_delta == -60\n    assert payload.end_time_delta == 0\n\n\ndef test_title_launch(packets, crypto):\n    unpacked = _unpack(packets['title_launch'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.TitleLaunch\n    assert payload.location == enum.ActiveTitleLocation.Fill\n    assert payload.uri == 'ms-xbl-0D174C79://default/'\n\n\ndef test_start_channel_request(packets, crypto):\n    unpacked = _unpack(packets['start_channel_request'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.StartChannelRequest\n    assert payload.channel_request_id == 1\n    assert payload.title_id == 0\n    assert payload.service == MessageTarget.SystemInputUUID\n    assert payload.activity_id == 0\n\n\ndef test_start_channel_request_title(packets, crypto):\n    unpacked = _unpack(packets['start_channel_request_title_channel'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.StartChannelRequest\n    assert payload.channel_request_id == 16\n    assert payload.title_id == 1256782258\n    assert payload.service == MessageTarget.TitleUUID\n    assert payload.activity_id == 0\n\n\ndef test_start_channel_response(packets, crypto):\n    unpacked = _unpack(packets['start_channel_response'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.StartChannelResponse\n    assert payload.channel_request_id == 1\n    assert payload.target_channel_id == 148\n    assert payload.result == enum.SGResultCode.SG_E_SUCCESS\n\n\ndef test_console_status(packets, crypto):\n    unpacked = _unpack(packets['console_status'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.ConsoleStatus\n    assert payload.live_tv_provider == 0\n    assert payload.major_version == 10\n    assert payload.minor_version == 0\n    assert payload.build_number == 14393\n    assert payload.locale == 'en-US'\n    assert len(payload.active_titles) == 1\n    assert payload.active_titles[0].title_id == 714681658\n    assert payload.active_titles[0].disposition.has_focus is True\n    assert payload.active_titles[0].disposition.title_location == enum.ActiveTitleLocation.StartView\n    assert str(payload.active_titles[0].product_id) == '00000000-0000-0000-0000-000000000000'\n    assert str(payload.active_titles[0].sandbox_id) == '00000000-0000-0000-0000-000000000000'\n    assert payload.active_titles[0].aum == 'Xbox.Home_8wekyb3d8bbwe!Xbox.Home.Application'\n\n\ndef test_active_surface_change(packets, crypto):\n    unpacked = _unpack(packets['active_surface_change'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.ActiveSurfaceChange\n    assert payload.surface_type == enum.ActiveSurfaceType.HTML\n    assert payload.server_tcp_port == 0\n    assert payload.server_udp_port == 0\n    assert str(payload.session_id) == '00000000-0000-0000-0000-000000000000'\n    assert payload.render_width == 0\n    assert payload.render_height == 0\n    assert hexlify(payload.master_session_key) == b'0000000000000000000000000000000000000000000000000000000000000000'\n\n\ndef test_auxiliary_stream_hello(packets, crypto):\n    unpacked = _unpack(packets['auxiliary_stream_hello'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.AuxilaryStream\n    assert payload.connection_info_flag == 0\n\n\ndef test_auxiliary_stream_connection_info(packets, crypto):\n    unpacked = _unpack(packets['auxiliary_stream_connection_info'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.AuxilaryStream\n    assert payload.connection_info_flag == 1\n    assert hexlify(payload.connection_info.crypto_key) == b'14188d32cca3564a6d53f34ad8d21728'\n    assert hexlify(payload.connection_info.server_iv) == b'09dcb570c9715cf01e0dfaf5ac718445'\n    assert hexlify(payload.connection_info.client_iv) == b'9fa17a415b1bab5ae320cdceb5e37297'\n    assert hexlify(payload.connection_info.sign_hash) == b'473f076d2fee90b27821fcad9d0ae7efdfd08f250823db95b90f90cac95784f9'\n    assert len(payload.connection_info.endpoints) == 1\n    assert payload.connection_info.endpoints[0].ip == '192.168.8.104'\n    assert payload.connection_info.endpoints[0].port == '57344'\n\n\ndef test_disconnect(packets, crypto):\n    unpacked = _unpack(packets['disconnect'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.Disconnect\n    assert payload.reason == enum.DisconnectReason.Unspecified\n    assert payload.error_code == 0\n\n\ndef test_poweroff(packets, crypto):\n    unpacked = _unpack(packets['power_off'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.PowerOff\n    assert payload.liveid == 'FD00112233FFEE66'\n\n\ndef test_json(packets, crypto):\n    unpacked = _unpack(packets['json'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.Json\n    assert payload.text == {'request': 'GetConfiguration', 'msgid': '2ed6c0fd.2'}\n\n\ndef test_gamepad(packets, crypto):\n    unpacked = _unpack(packets['gamepad'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.Gamepad\n    assert payload.timestamp == 0\n    assert payload.buttons == enum.GamePadButton.PadB\n    assert payload.left_trigger == 0.0\n    assert payload.right_trigger == 0.0\n    assert payload.left_thumbstick_x == 0.0\n    assert payload.left_thumbstick_y == 0.0\n    assert payload.right_thumbstick_x == 0.0\n    assert payload.right_thumbstick_y == 0.0\n\n\ndef test_media_command(packets, crypto):\n    unpacked = _unpack(packets['media_command'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.MediaCommand\n    assert payload.request_id == 0\n    assert payload.title_id == 274278798\n    assert payload.command == enum.MediaControlCommand.FastForward\n    assert payload.seek_position is None\n\n\ndef test_media_state(packets, crypto):\n    unpacked = _unpack(packets['media_state'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.MediaState\n    assert payload.title_id == 274278798\n    assert payload.aum_id == 'AIVDE_s9eep9cpjhg6g!App'\n    assert payload.asset_id == ''\n    assert payload.media_type == enum.MediaType.NoMedia\n    assert payload.sound_level == enum.SoundLevel.Full\n    assert payload.enabled_commands == enum.MediaControlCommand(33758)\n    assert payload.playback_status == enum.MediaPlaybackStatus.Stopped\n    assert payload.rate == 0.0\n    assert payload.position == 0\n    assert payload.media_start == 0\n    assert payload.media_end == 0\n    assert payload.min_seek == 0\n    assert payload.max_seek == 0\n    assert len(payload.metadata) == 1\n    assert payload.metadata[0].name == 'title'\n    assert payload.metadata[0].value == ''\n\n\ndef test_text_acknowledge(packets, crypto):\n    unpacked = _unpack(packets['system_text_acknowledge'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.SystemTextAck\n    assert payload.text_session_id == 8\n    assert payload.text_version_ack == 2\n\n\ndef test_text_configuration(packets, crypto):\n    unpacked = _unpack(packets['system_text_configuration'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.SystemTextConfiguration\n    assert payload.text_session_id == 9\n    assert payload.text_buffer_version == 0\n    assert payload.text_options == enum.TextOption.AcceptsReturn | enum.TextOption.MultiLine\n    assert payload.input_scope == enum.TextInputScope.Unknown\n    assert payload.max_text_length == 0\n    assert payload.locale == 'de-DE'\n    assert payload.prompt == ''\n\n\ndef test_system_text_done(packets, crypto):\n    unpacked = _unpack(packets['system_text_done'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.SystemTextDone\n    assert payload.text_session_id == 0\n    assert payload.text_version == 0\n    assert payload.flags == 0\n    assert payload.result == enum.TextResult.Cancel\n\n\ndef test_system_text_input(packets, crypto):\n    unpacked = _unpack(packets['system_text_input'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.SystemTextInput\n    assert payload.text_session_id == 8\n    assert payload.base_version == 1\n    assert payload.submitted_version == 2\n    assert payload.total_text_byte_len == 1\n    assert payload.selection_start == -1\n    assert payload.selection_length == -1\n    assert payload.flags == 0\n    assert payload.text_chunk_byte_start == 0\n    assert payload.delta is None\n    assert payload.text_chunk == 'h'\n\n\ndef test_system_touch(packets, crypto):\n    unpacked = _unpack(packets['system_touch'], crypto)\n    payload = unpacked.protected_payload\n\n    assert unpacked.header.flags.msg_type == enum.MessageType.SystemTouch\n    assert payload.touch_msg_timestamp == 182459592\n    assert len(payload.touchpoints) == 1\n    assert payload.touchpoints[0].touchpoint_id == 1\n    assert payload.touchpoints[0].touchpoint_action == enum.TouchAction.Down\n    assert payload.touchpoints[0].touchpoint_x == 244\n    assert payload.touchpoints[0].touchpoint_y == 255\n\n\ndef test_repack_all(packets, crypto):\n    for f in packets:\n        unpacked = _unpack(packets[f], crypto)\n\n        # if unpacked.header.pkt_type in simple.pkt_types:\n        #     msg = simple.struct(**unpacked)\n        # elif unpacked.header.pkt_type == enum.PacketType.Message and unpacked.header.flags.msg_type == enum.MessageType.Json:\n        #     continue  # The key order is not preserved when parsing JSON so the parsed message will always differ\n        # else:\n        #     msg = message.struct(**unpacked)\n\n        repacked = _pack(unpacked, crypto)\n\n        assert repacked == packets[f], \\\n            '%s was not repacked correctly:\\n(repacked)%s\\n!=\\n(original)%s'\\\n            % (f, hexlify(repacked), hexlify(packets[f]))\n"}
{"type": "test_file", "path": "tests/test_padding.py", "content": "from xbox.sg.crypto import Padding, PKCS7Padding, ANSIX923Padding\n\n\ndef test_calculate_padding():\n    align_16 = Padding.size(12, alignment=16)\n    align_12 = Padding.size(12, alignment=12)\n    align_10 = Padding.size(12, alignment=10)\n\n    assert align_16 == 4\n    assert align_12 == 0\n    assert align_10 == 8\n\n\ndef test_remove_padding():\n    payload = 8 * b'\\x88' + b'\\x00\\x00\\x00\\x04'\n    unpadded = Padding.remove(payload)\n\n    assert len(unpadded) == 8\n    assert unpadded == 8 * b'\\x88'\n\n\ndef test_x923_add_padding():\n    payload = 7 * b'\\x69'\n    padded_12 = ANSIX923Padding.pad(payload, alignment=12)\n    padded_7 = ANSIX923Padding.pad(payload, alignment=7)\n    padded_3 = ANSIX923Padding.pad(payload, alignment=3)\n\n    assert len(padded_12) == 12\n    assert len(padded_7) == 7\n    assert len(padded_3) == 9\n    assert padded_12 == payload + b'\\x00\\x00\\x00\\x00\\x05'\n    assert padded_7 == payload\n    assert padded_3 == payload + b'\\x00\\x02'\n\n\ndef test_pkcs7_add_padding():\n    payload = 7 * b'\\x69'\n    padded_12 = PKCS7Padding.pad(payload, alignment=12)\n    padded_7 = PKCS7Padding.pad(payload, alignment=7)\n    padded_3 = PKCS7Padding.pad(payload, alignment=3)\n\n    assert len(padded_12) == 12\n    assert len(padded_7) == 7\n    assert len(padded_3) == 9\n    assert padded_12 == payload + b'\\x05\\x05\\x05\\x05\\x05'\n    assert padded_7 == payload\n    assert padded_3 == payload + b'\\x02\\x02'\n"}
{"type": "test_file", "path": "tests/test_pcap.py", "content": "from xbox.scripts import pcap\n\n\ndef test_pcap_filter(pcap_filepath):\n    packets = list(pcap.packet_filter(pcap_filepath))\n\n    assert len(packets) == 26\n\n\ndef test_run_parser(pcap_filepath, crypto):\n    pcap.parse(pcap_filepath, crypto)\n"}
{"type": "test_file", "path": "tests/test_rest_consolewrap.py", "content": "import pytest\n\nfrom xbox.rest.consolewrap import ConsoleWrap\nfrom xbox.sg import enum\n\n\ndef test_consolewrap_init(console):\n    wrap = ConsoleWrap(console)\n\n    assert wrap.console == console\n    assert 'text' in wrap.console.managers\n    assert 'input' in wrap.console.managers\n    assert 'stump' in wrap.console.managers\n    assert 'media' in wrap.console.managers\n\n@pytest.mark.asyncio\nasync def test_discover():\n    discovered = await ConsoleWrap.discover(tries=1, blocking=False, timeout=1)\n\n    assert isinstance(discovered, list)\n\n\n@pytest.mark.asyncio\nasync def test_poweron():\n    await ConsoleWrap.power_on('FD0123456789', tries=1, iterations=1)\n\n\ndef test_media_commands(console):\n    commands = ConsoleWrap(console).media_commands\n\n    assert isinstance(commands, dict)\n    assert 'play' in commands\n    for k, v in commands.items():\n        assert isinstance(k, str)\n        assert isinstance(v, enum.MediaControlCommand)\n\n\ndef test_input_keys(console):\n    keys = ConsoleWrap(console).input_keys\n\n    assert isinstance(keys, dict)\n    assert 'nexus' in keys\n    for k, v in keys.items():\n        assert isinstance(k, str)\n        assert isinstance(v, enum.GamePadButton)\n\n\ndef test_liveid(console):\n    assert ConsoleWrap(console).liveid == console.liveid\n\n\ndef test_available(console):\n    console._device_status = enum.DeviceStatus.Unavailable\n    assert ConsoleWrap(console).available is False\n\n    console._device_status = enum.DeviceStatus.Available\n    assert ConsoleWrap(console).available is True\n\n\ndef test_connected(console):\n    console._connection_state = enum.ConnectionState.Disconnected\n    assert ConsoleWrap(console).connected is False\n\n    console._connection_state = enum.ConnectionState.Connected\n    assert ConsoleWrap(console).connected is True\n\n    console._connection_state = enum.ConnectionState.Connecting\n    assert ConsoleWrap(console).connected is False\n\n\ndef test_usable(console):\n    console._connection_state = enum.ConnectionState.Reconnecting\n    assert ConsoleWrap(console).usable is False\n\n    console._connection_state = enum.ConnectionState.Disconnecting\n    assert ConsoleWrap(console).usable is False\n\n    console._connection_state = enum.ConnectionState.Disconnected\n    assert ConsoleWrap(console).usable is False\n\n    console._connection_state = enum.ConnectionState.Error\n    assert ConsoleWrap(console).usable is False\n\n    console._connection_state = enum.ConnectionState.Connected\n    assert ConsoleWrap(console).usable is True\n\n\ndef test_connection_state(console):\n    console._connection_state = enum.ConnectionState.Reconnecting\n\n    assert ConsoleWrap(console).connection_state == enum.ConnectionState.Reconnecting\n\n\ndef test_pairing_state(console):\n    console._pairing_state = enum.PairedIdentityState.Paired\n\n    assert ConsoleWrap(console).pairing_state == enum.PairedIdentityState.Paired\n\n\ndef test_device_status(console):\n    console._device_status = enum.DeviceStatus.Available\n\n    assert ConsoleWrap(console).device_status == enum.DeviceStatus.Available\n\n\ndef test_authenticated_users_allowed(console):\n    console.flags = enum.PrimaryDeviceFlag.AllowAuthenticatedUsers\n    assert ConsoleWrap(console).authenticated_users_allowed is True\n\n    console.flags = enum.PrimaryDeviceFlag.AllowConsoleUsers\n    assert ConsoleWrap(console).authenticated_users_allowed is False\n\n    console.flags = enum.PrimaryDeviceFlag.CertificatePending | enum.PrimaryDeviceFlag.AllowConsoleUsers\n    assert ConsoleWrap(console).authenticated_users_allowed is False\n\n\ndef test_console_users_allowed(console):\n    console.flags = enum.PrimaryDeviceFlag.AllowAuthenticatedUsers\n    assert ConsoleWrap(console).console_users_allowed is False\n\n    console.flags = enum.PrimaryDeviceFlag.AllowConsoleUsers\n    assert ConsoleWrap(console).console_users_allowed is True\n\n    console.flags = enum.PrimaryDeviceFlag.CertificatePending | enum.PrimaryDeviceFlag.AllowConsoleUsers\n    assert ConsoleWrap(console).console_users_allowed is True\n\n\ndef test_anonymous_connection_allowed(console):\n    console.flags = enum.PrimaryDeviceFlag.AllowAuthenticatedUsers\n    assert ConsoleWrap(console).anonymous_connection_allowed is False\n\n    console.flags = enum.PrimaryDeviceFlag.AllowConsoleUsers\n    assert ConsoleWrap(console).anonymous_connection_allowed is False\n\n    console.flags = enum.PrimaryDeviceFlag.CertificatePending | enum.PrimaryDeviceFlag.AllowAnonymousUsers\n    assert ConsoleWrap(console).anonymous_connection_allowed is True\n\n\ndef test_is_certificate_pending(console):\n    console.flags = enum.PrimaryDeviceFlag.AllowAuthenticatedUsers\n    assert ConsoleWrap(console).is_certificate_pending is False\n\n    console.flags = enum.PrimaryDeviceFlag.AllowConsoleUsers\n    assert ConsoleWrap(console).is_certificate_pending is False\n\n    console.flags = enum.PrimaryDeviceFlag.CertificatePending | enum.PrimaryDeviceFlag.AllowConsoleUsers\n    assert ConsoleWrap(console).is_certificate_pending is True\n\n\ndef test_console_status(console, console_status):\n    console._console_status = None\n    assert ConsoleWrap(console).console_status is None\n\n    console._console_status = console_status\n    status = ConsoleWrap(console).console_status\n    assert status is not None\n\n\ndef test_media_status(console, media_state, console_status, console_status_with_media):\n    console.media._media_state = None\n    assert ConsoleWrap(console).media_status is None\n\n    console.media._media_state = media_state\n    console._console_status = console_status_with_media\n    console._connection_state = enum.ConnectionState.Disconnecting\n    assert ConsoleWrap(console).media_status is None\n\n    console._console_status = console_status  # miss-matched apps\n    console._connection_state = enum.ConnectionState.Connected\n    state = ConsoleWrap(console).media_status\n    assert ConsoleWrap(console).media_status is None\n\n    console._console_status = console_status_with_media\n    state = ConsoleWrap(console).media_status\n\n\ndef test_status(console):\n    status = ConsoleWrap(console).status\n    assert status is not None\n\n\n@pytest.mark.asyncio\nasync def test_connect(console):\n    console.flags = enum.PrimaryDeviceFlag.AllowAuthenticatedUsers\n    console._device_status = enum.DeviceStatus.Available\n    console._connection_state = enum.ConnectionState.Disconnected\n    console._pairing_state = enum.PairedIdentityState.NotPaired\n\n    with pytest.raises(Exception):\n        await ConsoleWrap(console).connect()\n\n    console._connection_state = enum.ConnectionState.Connected\n    state = await ConsoleWrap(console).connect()\n    assert state == enum.ConnectionState.Connected\n\n    console._connection_state = enum.ConnectionState.Disconnected\n    console.flags = enum.PrimaryDeviceFlag.AllowAnonymousUsers\n    # blocks forever\n    # state = ConsoleWrap(console).connect()\n    # assert state == enum.ConnectionState.Disconnected\n"}
{"type": "test_file", "path": "tests/test_protocol.py", "content": "import pytest\nfrom xbox.sg.protocol import _fragment_connect_request, FragmentError\nfrom xbox.sg.protocol import ChannelManager, ChannelError\nfrom xbox.sg.protocol import SequenceManager\nfrom xbox.sg.protocol import FragmentManager\n\n\ndef test_fragment_connect_request(crypto):\n    from uuid import UUID\n    from xbox.sg.enum import PublicKeyType\n\n    uuid = UUID('de305d54-75b4-431b-adb2-eb6b9e546014')\n    pubkey = 64 * b'\\xFF'\n    userhash = '0123456789'\n    auth_token = (898 * 'A') + (500 * 'B')\n\n    fragments = _fragment_connect_request(crypto, uuid, PublicKeyType.EC_DH_P256,\n                                          pubkey, userhash, auth_token)\n    # request_num != 0\n    fragments_dup = _fragment_connect_request(crypto, uuid, PublicKeyType.EC_DH_P256,\n                                              pubkey, userhash, auth_token,\n                                              request_num=3)\n\n    # Total length (userhash + token) is too small for fragmentation\n    with pytest.raises(FragmentError):\n        _fragment_connect_request(crypto, uuid, PublicKeyType.EC_DH_P256,\n                                  pubkey, userhash, 898 * 'A')\n\n    assert len(fragments) == 2\n    assert fragments[0].unprotected_payload.sg_uuid == uuid\n    assert fragments[0].unprotected_payload.public_key == pubkey\n    assert isinstance(fragments[0].unprotected_payload.iv, bytes) is True\n    assert fragments[0].protected_payload.userhash == userhash\n    assert fragments[0].protected_payload.jwt == 898 * 'A'\n    assert fragments[0].protected_payload.connect_request_num == 0\n    assert fragments[0].protected_payload.connect_request_group_start == 0\n    assert fragments[0].protected_payload.connect_request_group_end == 2\n\n    assert fragments[1].unprotected_payload.sg_uuid == uuid\n    assert fragments[1].unprotected_payload.public_key == pubkey\n    assert isinstance(fragments[1].unprotected_payload.iv, bytes) is True\n    assert fragments[1].protected_payload.userhash == ''\n    assert fragments[1].protected_payload.jwt == 500 * 'B'\n    assert fragments[1].protected_payload.connect_request_num == 1\n    assert fragments[1].protected_payload.connect_request_group_start == 0\n    assert fragments[1].protected_payload.connect_request_group_end == 2\n\n    assert fragments_dup[0].protected_payload.connect_request_num == 3\n    assert fragments_dup[0].protected_payload.connect_request_group_start == 3\n    assert fragments_dup[0].protected_payload.connect_request_group_end == 5\n\n    assert fragments_dup[1].protected_payload.connect_request_num == 4\n    assert fragments_dup[1].protected_payload.connect_request_group_start == 3\n    assert fragments_dup[1].protected_payload.connect_request_group_end == 5\n\n\ndef test_sequence_manager():\n    mgr = SequenceManager()\n\n    seq_num = 0\n    for i in range(5):\n        seq_num = mgr.next_sequence_num()\n\n    for i in range(1, 23):\n        mgr.add_received(i)\n\n    for i in range(1, 12):\n        mgr.add_processed(i)\n\n    for i in range(1, 7):\n        mgr.add_rejected(i)\n\n    # Trying to set already existing values\n    mgr.add_received(4)\n    mgr.add_processed(5)\n    mgr.add_rejected(6)\n\n    mgr.low_watermark = 89\n    # Setting smaller sequence than already set\n    mgr.low_watermark = 12\n\n    assert mgr.received == list(range(1, 23))\n    assert mgr.processed == list(range(1, 12))\n    assert mgr.rejected == list(range(1, 7))\n\n    assert mgr.low_watermark == 89\n    assert seq_num == 5\n\n\ndef test_channel_manager(packets, crypto):\n    from xbox.sg.enum import ServiceChannel\n    from xbox.sg.packer import unpack\n\n    start_channel_resp = unpack(packets['start_channel_response'], crypto)\n    mgr = ChannelManager()\n\n    request_id = 0\n    while request_id != start_channel_resp.protected_payload.channel_request_id:\n        request_id = mgr.get_next_request_id(ServiceChannel.SystemInputTVRemote)\n\n    service_channel = mgr.handle_channel_start_response(start_channel_resp)\n\n    assert service_channel == ServiceChannel.SystemInputTVRemote\n\n    # Deleting channel references\n    mgr.reset()\n\n    with pytest.raises(ChannelError):\n        mgr.get_channel(123)\n\n    with pytest.raises(ChannelError):\n        mgr.get_channel_id(ServiceChannel.SystemInputTVRemote)\n\n    with pytest.raises(ChannelError):\n        mgr.handle_channel_start_response(start_channel_resp)\n\n    assert mgr.get_channel(0) == ServiceChannel.Core\n    assert mgr.get_channel(0x1000000000000000) == ServiceChannel.Ack\n\n    assert mgr.get_channel_id(ServiceChannel.Core) == 0\n    assert mgr.get_channel_id(ServiceChannel.Ack) == 0x1000000000000000\n\n\ndef test_fragment_manager_json(json_fragments):\n    expected_result = {'response': 'GetConfiguration',\n                       'msgid': 'xV5X1YCB.13',\n                       'params': [\n                           {'device_id': '0',\n                            'device_type': 'tv',\n                            'buttons': {\n                                'btn.back': 'Back',\n                                'btn.up': 'Up',\n                                'btn.red': 'Red',\n                                'btn.page_down': 'Page Down',\n                                'btn.ch_down': 'Channel Down',\n                                'btn.func_c': 'Label C',\n                                'btn.format': 'Format',\n                                'btn.digit_2': '2',\n                                'btn.func_a': 'Label A',\n                                'btn.digit_7': '7',\n                                'btn.last': 'Last',\n                                'btn.input': 'Input',\n                                'btn.fast_fwd': 'FFWD',\n                                'btn.menu': 'Menu',\n                                'btn.replay': 'Skip REV',\n                                'btn.power': 'Power',\n                                'btn.left': 'Left',\n                                'btn.blue': 'Blue',\n                                'btn.vol_down': 'Volume Down',\n                                'btn.green': 'Green',\n                                'btn.digit_4': '4',\n                                'btn.digit_9': '9',\n                                'btn.play': 'Play',\n                                'btn.page_up': 'Page Up',\n                                'btn.func_b': 'Label B',\n                                'btn.power_off': 'Off',\n                                'btn.vol_mute': 'Mute',\n                                'btn.record': 'Record',\n                                'btn.subtitle': 'Subtitle',\n                                'btn.rewind': 'Rewind',\n                                'btn.exit': 'Exit',\n                                'btn.down': 'Down',\n                                'btn.sap': 'Sap',\n                                'btn.yellow': 'Yellow',\n                                'btn.func_d': 'Label D',\n                                'btn.info': 'Info',\n                                'btn.digit_5': '5',\n                                'btn.digit_3': '3',\n                                'btn.digit_0': '0',\n                                'btn.skip_fwd': 'Skip FWD',\n                                'btn.delimiter': 'Delimiter',\n                                'btn.right': 'Right',\n                                'btn.vol_up': 'Volume Up',\n                                'btn.ch_up': 'Channel Up',\n                                'btn.digit_8': '8',\n                                'btn.digit_6': '6',\n                                'btn.guide': 'Guide',\n                                'btn.stop': 'Stop',\n                                'btn.select': 'Select',\n                                'btn.power_on': 'On',\n                                'btn.ch_enter': 'Enter',\n                                'btn.digit_1': '1',\n                                'btn.pause': 'Pause',\n                                'btn.dvr': 'Recordings'\n                            }},\n                           {'device_id': '1',\n                            'device_brand': 'Sky Deutschland',\n                            'device_type': 'stb',\n                            'buttons': {\n                                'btn.back': 'Back',\n                                'btn.red': 'Red',\n                                'btn.up': 'Up',\n                                'btn.ch_down': 'Channel Down',\n                                'btn.format': 'Format',\n                                'btn.digit_2': '2',\n                                'btn.digit_7': '7',\n                                'btn.last': 'Last',\n                                'btn.fast_fwd': 'FFWD',\n                                'btn.menu': 'Menu',\n                                'btn.power': 'Power',\n                                'btn.left': 'Left',\n                                'btn.blue': 'Blue',\n                                'btn.vol_down': 'Volume Down',\n                                'btn.green': 'Green',\n                                'btn.digit_4': '4',\n                                'btn.digit_9': '9',\n                                'btn.play': 'Play',\n                                'btn.vol_mute': 'Mute',\n                                'btn.record': 'Record',\n                                'btn.rewind': 'Rewind',\n                                'btn.exit': 'Exit',\n                                'btn.down': 'Down',\n                                'btn.yellow': 'Yellow',\n                                'btn.info': 'Info',\n                                'btn.digit_5': '5',\n                                'btn.digit_3': '3',\n                                'btn.digit_0': '0',\n                                'btn.live': 'Live',\n                                'btn.vol_up': 'Volume Up',\n                                'btn.right': 'Right',\n                                'btn.ch_up': 'Channel Up',\n                                'btn.digit_8': '8',\n                                'btn.digit_6': '6',\n                                'btn.guide': 'Guide',\n                                'btn.stop': 'Stop',\n                                'btn.select': 'Select',\n                                'btn.digit_1': '1',\n                                'btn.pause': 'Pause',\n                                'btn.dvr': 'Recordings'}\n                            },\n                           {'device_id': 'tuner',\n                            'device_type': 'tuner',\n                            'buttons': {\n                                'btn.play': 'PLAY',\n                                'btn.pause': 'PAUSE',\n                                'btn.seek': 'SEEK'\n                            }\n                            }\n                       ]}\n\n    mgr = FragmentManager()\n\n    for msg in json_fragments:\n        msg1 = mgr.reassemble_json(msg)\n\n    for msg in reversed(json_fragments):\n        msg2 = mgr.reassemble_json(msg)\n\n    # Deliver a fragment twice\n    mgr.reassemble_json(json_fragments[0])\n    mgr.reassemble_json(json_fragments[1])\n    mgr.reassemble_json(json_fragments[2])\n    mgr.reassemble_json(json_fragments[2])\n    msg3 = mgr.reassemble_json(json_fragments[3])\n\n    # Incomplete fragments\n    for msg in reversed(json_fragments[:-1]):\n        msg4 = mgr.reassemble_json(msg)\n\n    with pytest.raises(KeyError):\n        mgr.reassemble_json({'not': 'all', 'required': 'fields'})\n\n    assert msg1 == expected_result\n    assert msg2 == expected_result\n    assert msg3 == expected_result\n    assert msg4 is None\n\n\ndef test_fragment_manager_fragment_messages(packets, crypto):\n    from xbox.sg.packer import unpack\n\n    fragments = [\n        unpack(packets['fragment_media_state_0'], crypto),\n        unpack(packets['fragment_media_state_1'], crypto),\n        unpack(packets['fragment_media_state_2'], crypto)\n    ]\n\n    mgr = FragmentManager()\n    assert mgr.reassemble_message(fragments.pop()) is None\n    assert mgr.reassemble_message(fragments.pop()) is None\n    msg = mgr.reassemble_message(fragments.pop())\n    assert msg is not None\n\n    assert msg.aum_id == 'Microsoft.BlurayPlayer_8wekyb3d8bbwe!Xbox.BlurayPlayer.Application'\n    assert msg.max_seek == 50460000\n    assert len(msg.asset_id) == 2184\n"}
{"type": "test_file", "path": "tests/test_struct.py", "content": "import construct\nfrom xbox.sg.utils import struct, adapters\n\n\ndef test_xstruct():\n    test_struct = struct.XStruct(\n        'a' / construct.Int32ub,\n        'b' / construct.Int16ub\n    )\n\n    obj = test_struct(a=1, b=2)\n\n    assert test_struct.a.subcon == construct.Int32ub\n    assert test_struct.b.subcon == construct.Int16ub\n    assert 'a' in test_struct\n    assert 'b' in test_struct\n    assert obj.container == construct.Container(a=1, b=2)\n    assert obj.a == 1\n    assert obj.b == 2\n    assert obj.build() == b'\\x00\\x00\\x00\\x01\\x00\\x02'\n\n    obj.parse(b'\\x00\\x00\\x00\\x02\\x00\\x03')\n    assert obj.container == construct.Container(a=2, b=3)\n\n    obj = test_struct.parse(b'\\x00\\x00\\x00\\x03\\x00\\x04')\n    assert obj.container == construct.Container(a=3, b=4)\n\n\ndef test_flatten():\n    test_sub = struct.XStruct(\n        'c' / construct.Int16ub\n    )\n    test_struct = struct.XStruct(\n        'a' / construct.Int32ub,\n        'b' / test_sub\n    )\n\n    obj = test_struct(a=1, b=test_sub(c=2))\n    flat = struct.flatten(obj.container)\n\n    assert flat == construct.Container(a=1, b=construct.Container(c=2))\n\n\ndef test_terminated_field():\n    test_struct = struct.XStruct(\n        'a' / adapters.TerminatedField(construct.Int32ub)\n    )\n\n    assert test_struct(a=1).build() == b'\\x00\\x00\\x00\\x01\\x00'\n    assert test_struct.parse(b'\\x00\\x00\\x00\\x01\\x00').container.a == 1\n\n    test_struct = struct.XStruct(\n        'a' / adapters.TerminatedField(\n            construct.Int32ub, length=4, pattern=b'\\xff'\n        )\n    )\n\n    assert test_struct(a=1).build() == b'\\x00\\x00\\x00\\x01\\xff\\xff\\xff\\xff'\n    assert test_struct.parse(b'\\x00\\x00\\x00\\x01\\xff\\xff\\xff\\xff').container.a == 1\n\n\ndef test_sgstring():\n    test_struct = struct.XStruct(\n        'a' / adapters.SGString()\n    )\n\n    assert test_struct(a='test').build() == b'\\x00\\x04test\\x00'\n    assert test_struct.parse(b'\\x00\\x04test\\x00').container.a == 'test'\n\n\ndef test_fieldin():\n    test_struct = struct.XStruct(\n        'a' / construct.Int32ub,\n        'b' / construct.IfThenElse(\n            adapters.FieldIn('a', [1, 2, 3]),\n            construct.Int32ub, construct.Int16ub\n        )\n    )\n\n    assert test_struct(a=1, b=2).build() == b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02'\n    assert test_struct(a=2, b=2).build() == b'\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02'\n    assert test_struct(a=3, b=2).build() == b'\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x02'\n    assert test_struct(a=4, b=2).build() == b'\\x00\\x00\\x00\\x04\\x00\\x02'\n"}
{"type": "test_file", "path": "tests/test_stump_json_models.py", "content": "import pytest\r\nfrom xbox.stump import json_model\r\nfrom xbox.stump.enum import Message\r\n\r\n\r\ndef test_stump_response(stump_json):\r\n    data = stump_json['response_recent_channels']\r\n    msg = json_model.deserialize_stump_message(data)\r\n\r\n    assert msg.msgid == 'xV5X1YCB.16'\r\n    assert Message(msg.response) == Message.RECENT_CHANNELS\r\n    assert isinstance(msg.params, list)\r\n\r\n\r\ndef test_tuner_lineups(stump_json):\r\n    data = stump_json['response_tuner_lineups']\r\n    msg = json_model.deserialize_stump_message(data)\r\n\r\n    assert len(msg.params.providers) == 1\r\n    provider = msg.params.providers[0]\r\n\r\n    assert len(provider.foundChannels) == 19\r\n    found_channel = provider.foundChannels[0]\r\n    assert found_channel.channelNumber == 0\r\n    assert found_channel.displayName == 'Das Erste HD'\r\n    assert found_channel.channelId == '000021146A000301'\r\n\r\n    assert len(provider.cqsChannels) == 7\r\n    assert provider.cqsChannels[0] == '178442d3-2b13-e02b-9747-a3d4ebebcf62_PHOENIHD_23'\r\n\r\n    assert str(provider.headendId) == '0a7fb88a-960b-c2e3-9975-7c86c5fa6c49'\r\n\r\n\r\ndef test_recent_channels(stump_json):\r\n    data = stump_json['response_recent_channels']\r\n    msg = json_model.deserialize_stump_message(data)\r\n\r\n    assert len(msg.params) == 0\r\n    # assert msg.params[0].channelNum == ''\r\n    # assert msg.params[0].providerId == ''\r\n    # assert msg.params[0].channelId == ''\r\n\r\n\r\ndef test_livetv_info(stump_json):\r\n    data = stump_json['response_livetv_info']\r\n    msg = json_model.deserialize_stump_message(data)\r\n\r\n    assert msg.params.streamingPort == 10242\r\n    assert msg.params.inHdmiMode is False\r\n    assert msg.params.tunerChannelType == 'televisionChannel'\r\n    assert msg.params.currentTunerChannelId == 'bb1ca492-232b-adfe-1f39-d010eabf179e_MSAHD_16'\r\n    assert msg.params.currentHdmiChannelId == '731cd976-c1e9-6b95-4799-e6757d02cab1_3SATHD_1'\r\n    assert msg.params.pauseBufferInfo is not None\r\n    assert msg.params.pauseBufferInfo.Enabled is True\r\n    assert msg.params.pauseBufferInfo.IsDvr is False\r\n    assert msg.params.pauseBufferInfo.MaxBufferSize == 18000000000\r\n    assert msg.params.pauseBufferInfo.BufferCurrent == 131688132168080320\r\n    assert msg.params.pauseBufferInfo.BufferStart == 131688132168080320\r\n    assert msg.params.pauseBufferInfo.BufferEnd == 131688151636700238\r\n    assert msg.params.pauseBufferInfo.CurrentTime == 131688151636836518\r\n    assert msg.params.pauseBufferInfo.Epoch == 0\r\n\r\n\r\ndef test_headend_info(stump_json):\r\n    data = stump_json['response_headend_info']\r\n    msg = json_model.deserialize_stump_message(data)\r\n\r\n    assert msg.params.providerName == 'Sky Deutschland'\r\n    assert str(msg.params.headendId) == '516b9ea7-5292-97ec-e7d4-f843fab6d392'\r\n    assert msg.params.blockExplicitContentPerShow is False\r\n    assert msg.params.dvrEnabled is False\r\n    assert msg.params.headendLocale == 'de-DE'\r\n    assert msg.params.streamingPort == 10242\r\n    assert msg.params.preferredProvider == '29045393'\r\n\r\n    assert len(msg.params.providers) == 2\r\n    provider = msg.params.providers[0]\r\n    assert provider.providerName == 'Sky Deutschland'\r\n    assert provider.filterPreference == 'ALL'\r\n    assert str(provider.headendId) == '516b9ea7-5292-97ec-e7d4-f843fab6d392'\r\n    assert provider.source == 'hdmi'\r\n    assert provider.titleId == '162615AD'\r\n    assert provider.canStream is False\r\n\r\n\r\ndef test_configuration(stump_json):\r\n    data = stump_json['response_configuration']\r\n    msg = json_model.deserialize_stump_message(data)\r\n\r\n    assert len(msg.params) == 4\r\n    device_config = msg.params[0]\r\n    assert device_config.device_brand == 'Samsung'\r\n    assert device_config.device_id == '0'\r\n    assert device_config.device_type == 'tv'\r\n    assert isinstance(device_config.buttons, dict) is True\r\n\r\n\r\n@pytest.mark.skip\r\ndef test_ensure_streaming_started(stump_json):\r\n    data = stump_json['response_ensure_streaming_started']\r\n    msg = json_model.deserialize_stump_message(data)\r\n\r\n    assert msg.params.currentChannelId == ''\r\n    assert msg.params.source == ''\r\n    assert msg.params.streamingPort == 0\r\n    assert msg.params.tunerChannelType == ''\r\n    assert msg.params.userCanViewChannel == ''\r\n\r\n\r\ndef test_app_channel_lineups(stump_json):\r\n    data = stump_json['response_appchannel_lineups']\r\n    msg = json_model.deserialize_stump_message(data)\r\n\r\n    assert len(msg.params) == 4\r\n    provider = msg.params[0]\r\n    assert provider.id == 'LiveTvHdmiProvider'\r\n    assert provider.providerName == 'OneGuide'\r\n    assert provider.titleId == '00000000'\r\n    assert provider.primaryColor == 'ff107c10'\r\n    assert provider.secondaryColor == 'ffebebeb'\r\n    assert len(provider.channels) == 0\r\n    # channel = provider.channels[0]\r\n    # assert channel.name == ''\r\n    # assert channel.id == ''\r\n\r\n\r\ndef test_send_key(stump_json):\r\n    data = stump_json['response_sendkey']\r\n    msg = json_model.deserialize_stump_message(data)\r\n\r\n    assert msg.params is True\r\n"}
{"type": "test_file", "path": "tests/test_auxstream_packing.py", "content": "import io\n\nfrom xbox.sg.crypto import PKCS7Padding\nfrom xbox.auxiliary import packer\nfrom xbox.auxiliary import packet\n\n\ndef _read_aux_packets(data):\n    with io.BytesIO(data) as stream:\n        while stream.tell() < len(data):\n            header_data = stream.read(4)\n            header = packet.aux_header_struct.parse(header_data)\n\n            if header.magic != packet.AUX_PACKET_MAGIC:\n                raise Exception('Invalid packet magic received from console')\n\n            padded_payload_sz = header.payload_size + PKCS7Padding.size(header.payload_size, 16)\n\n            payload_data = stream.read(padded_payload_sz)\n            hmac = stream.read(32)\n            yield header_data + payload_data + hmac\n\n\ndef test_client_unpack(aux_streams, aux_crypto):\n    data = aux_streams['fo4_client_to_console']\n    for msg in _read_aux_packets(data):\n        packer.unpack(msg, aux_crypto, client_data=True)\n\n\ndef test_server_unpack(aux_streams, aux_crypto):\n    data = aux_streams['fo4_console_to_client']\n    for msg in _read_aux_packets(data):\n        packer.unpack(msg, aux_crypto)\n\n\ndef test_decryption(aux_streams, aux_crypto):\n    data = aux_streams['fo4_console_to_client']\n    messages = list(_read_aux_packets(data))\n    # Need to unpack messages in order, starting with the first one\n    # -> Gets IV from previous decryption\n    packer.unpack(messages[0], aux_crypto)\n    json_msg = packer.unpack(messages[1], aux_crypto)\n    assert json_msg == b'{\"lang\":\"de\",\"version\":\"1.10.52.0\"}\\n'\n"}
{"type": "source_file", "path": "setup.py", "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom setuptools import setup, find_namespace_packages\n\nsetup(\n    name=\"xbox-smartglass-core\",\n    version=\"1.3.0\",\n    author=\"OpenXbox\",\n    author_email=\"noreply@openxbox.org\",\n    description=\"A library to interact with the Xbox One gaming console via the SmartGlass protocol.\",\n    long_description=open('README.md').read() + '\\n\\n' + open('CHANGELOG.md').read(),\n    long_description_content_type=\"text/markdown\",\n    license=\"MIT\",\n    keywords=\"xbox one smartglass auxiliary fallout title stump tv streaming livetv rest api\",\n    url=\"https://github.com/OpenXbox/xbox-smartglass-core-python\",\n    python_requires=\">=3.7\",\n    packages=find_namespace_packages(include=['xbox.*']),\n    zip_safe=False,\n    include_package_data=True,\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\"\n    ],\n    test_suite=\"tests\",\n    install_requires=[\n        'xbox-webapi==2.0.9',\n        'construct==2.10.56',\n        'cryptography==3.3.2',\n        'dpkt==1.9.4',\n        'pydantic==1.7.4',\n        'aioconsole==0.3.0',\n        'fastapi==0.65.2',\n        'uvicorn==0.12.2',\n        'urwid==2.1.2'\n    ],\n    setup_requires=['pytest-runner'],\n    tests_require=['pytest', 'pytest-console-scripts', 'pytest-asyncio'],\n    extras_require={\n        \"dev\": [\n            \"pip\",\n            \"bump2version\",\n            \"wheel\",\n            \"watchdog\",\n            \"flake8\",\n            \"coverage\",\n            \"Sphinx\",\n            \"sphinx_rtd_theme\",\n            \"recommonmark\",\n            \"twine\",\n            \"pytest\",\n            \"pytest-asyncio\",\n            \"pytest-console-scripts\",\n            \"pytest-runner\",\n        ],\n    },\n    entry_points={\n        'console_scripts': [\n            'xbox-cli=xbox.scripts.main_cli:main',\n            'xbox-discover=xbox.scripts.main_cli:main_discover',\n            'xbox-poweron=xbox.scripts.main_cli:main_poweron',\n            'xbox-poweroff=xbox.scripts.main_cli:main_poweroff',\n            'xbox-repl=xbox.scripts.main_cli:main_repl',\n            'xbox-replserver=xbox.scripts.main_cli:main_replserver',\n            'xbox-textinput=xbox.scripts.main_cli:main_textinput',\n            'xbox-gamepadinput=xbox.scripts.main_cli:main_gamepadinput',\n            'xbox-tui=xbox.scripts.main_cli:main_tui',\n            'xbox-fo4-relay=xbox.scripts.main_cli:main_falloutrelay',\n            'xbox-pcap=xbox.scripts.pcap:main',\n            'xbox-recrypt=xbox.scripts.recrypt:main',\n            'xbox-rest-server=xbox.scripts.rest_server:main'\n        ]\n    }\n)\n"}
{"type": "source_file", "path": "docs/conf.py", "content": "# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/stable/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\nimport os\nimport sys\nsys.path.insert(0, os.path.abspath('../'))\n\n# -- Project information -----------------------------------------------------\n\nproject = 'Xbox-Smartglass-Core'\ncopyright = '2018, OpenXbox'\nauthor = 'OpenXbox'\n\n# The short X.Y version\nversion = '1.0'\n# The full version, including alpha/beta/rc tags\nrelease = '1.3.0'\n\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.napoleon',\n    'recommonmark'\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\nsource_suffix = ['.rst', '.md']\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path .\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'sphinx_rtd_theme'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don't match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``['localtoc.html', 'relations.html', 'sourcelink.html',\n# 'searchbox.html']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'Xbox-Smartglass-Coredoc'\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',\n\n    # Latex figure (float) alignment\n    #\n    # 'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, 'Xbox-Smartglass-Core.tex', 'Xbox-Smartglass-Core Documentation',\n     'OpenXbox', 'manual'),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'xbox-smartglass-core', 'Xbox-Smartglass-Core Documentation',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, 'Xbox-Smartglass-Core', 'Xbox-Smartglass-Core Documentation',\n     author, 'Xbox-Smartglass-Core', 'One line description of project.',\n     'Miscellaneous'),\n]\n\n\n# -- Extension configuration -------------------------------------------------\n\n# -- Options for intersphinx extension ---------------------------------------\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {'https://docs.python.org/': None}\n\n# -- Options for napoleon extension ------------------------------------------\nnapoleon_google_docstring = True\nnapoleon_numpy_docstring = True\nnapoleon_include_init_with_doc = True\nnapoleon_include_private_with_doc = True\n\n# -- Autodoc settings\nautodoc_member_order = 'bysource'\n"}
{"type": "source_file", "path": "xbox/auxiliary/__init__.py", "content": "\"\"\"\nAuxiliary stream support for smartglass\n\"\"\"\n"}
{"type": "source_file", "path": "xbox/auxiliary/crypto.py", "content": "\"\"\"\nCryptography portion used for Title Channel aka Auxiliary Stream\n\"\"\"\nimport hmac\nimport hashlib\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\nclass AuxiliaryStreamCrypto(object):\n    _backend = default_backend()\n\n    def __init__(self, crypto_key, hash_key, server_iv, client_iv):\n        \"\"\"\n        Initialize Auxiliary Stream Crypto-context.\n        \"\"\"\n\n        self._encrypt_key = crypto_key\n        self._hash_key = hash_key\n        self._server_iv = server_iv\n        self._client_iv = client_iv\n\n        self._server_cipher = Cipher(\n            algorithms.AES(self._encrypt_key),\n            modes.CBC(self._server_iv),\n            backend=AuxiliaryStreamCrypto._backend\n        )\n\n        self._server_encryptor = self._server_cipher.encryptor()\n        self._server_decryptor = self._server_cipher.decryptor()\n\n        self._client_cipher = Cipher(\n            algorithms.AES(self._encrypt_key),\n            modes.CBC(self._client_iv),\n            backend=AuxiliaryStreamCrypto._backend\n        )\n\n        self._client_encryptor = self._client_cipher.encryptor()\n        self._client_decryptor = self._client_cipher.decryptor()\n\n    @classmethod\n    def from_connection_info(cls, connection_info):\n        \"\"\"\n        Initialize Crypto context via AuxiliaryStream-message\n        connection info.\n        \"\"\"\n        return cls(\n            connection_info.crypto_key,\n            connection_info.sign_hash,\n            connection_info.server_iv,\n            connection_info.client_iv\n        )\n\n    def encrypt(self, plaintext):\n        \"\"\"\n        Encrypts plaintext with AES-128-CBC\n\n        No padding is added here, data has to be aligned to\n        block size (16 bytes).\n\n        Args:\n            plaintext (bytes): The plaintext to encrypt.\n\n        Returns:\n            bytes: Encrypted Data\n        \"\"\"\n        return AuxiliaryStreamCrypto._crypt(self._client_encryptor, plaintext)\n\n    def encrypt_server(self, plaintext):\n        return AuxiliaryStreamCrypto._crypt(self._server_encryptor, plaintext)\n\n    def decrypt(self, ciphertext):\n        \"\"\"\n        Decrypts ciphertext\n\n        No padding is removed here.\n\n        Args:\n            ciphertext (bytes): Ciphertext to be decrypted\n\n        Returns:\n            bytes: Decrypted data\n        \"\"\"\n        return AuxiliaryStreamCrypto._crypt(self._server_decryptor, ciphertext)\n\n    def decrypt_client(self, ciphertext):\n        return AuxiliaryStreamCrypto._crypt(self._client_decryptor, ciphertext)\n\n    def hash(self, data):\n        \"\"\"\n        Securely hashes data with HMAC SHA-256\n\n        Args:\n            data (bytes): The data to securely hash.\n\n        Returns:\n            bytes: Hashed data\n        \"\"\"\n        return AuxiliaryStreamCrypto._secure_hash(self._hash_key, data)\n\n    def verify(self, data, secure_hash):\n        \"\"\"\n        Verifies that the given data generates the given secure_hash\n\n        Args:\n            data (bytes): The data to validate.\n            secure_hash (bytes): The secure hash to validate against.\n\n        Returns:\n            bool: True on success, False otherwise\n        \"\"\"\n        return secure_hash == self.hash(data)\n\n    @staticmethod\n    def _secure_hash(key, data):\n        return hmac.new(key, data, hashlib.sha256).digest()\n\n    @staticmethod\n    def _crypt(cryptor, data):\n        return cryptor.update(data)\n"}
{"type": "source_file", "path": "xbox/auxiliary/manager.py", "content": "import logging\n\nfrom typing import Any\n\nfrom xbox.sg import factory\nfrom xbox.sg.manager import Manager\nfrom xbox.sg.enum import ServiceChannel, MessageType\nfrom xbox.sg.constants import MessageTarget\nfrom xbox.sg.utils.events import Event\n\nlog = logging.getLogger(__name__)\n\n\nclass TitleManagerError(Exception):\n    \"\"\"\n    Exception thrown by TitleManager\n    \"\"\"\n    pass\n\n\nclass TitleManager(Manager):\n    __namespace__ = 'title'\n\n    def __init__(self, console):\n        \"\"\"\n        Title Manager (ServiceChannel.Title)\n\n        Args:\n             console (:class:`.Console`): Console object, internally passed\n                                          by `Console.add_manager`\n        \"\"\"\n        super(TitleManager, self).__init__(console, ServiceChannel.Title)\n        self._active_surface = None\n        self._connection_info = None\n\n        self.on_surface_change = Event()\n        self.on_connection_info = Event()\n\n    def _on_message(self, msg, channel):\n        \"\"\"\n        Internal handler method to receive messages from Title Channel\n\n        Args:\n            msg (:class:`XStructObj`): Message\n            channel (:class:`ServiceChannel`): Service channel\n        \"\"\"\n        msg_type = msg.header.flags.msg_type\n        payload = msg.protected_payload\n        if msg_type == MessageType.AuxilaryStream:\n            if payload.connection_info_flag == 0:\n                log.debug('Received AuxiliaryStream HELLO')\n                self._request_connection_info()\n            else:\n                log.debug('Received AuxiliaryStream CONNECTION INFO')\n                self.connection_info = payload.connection_info\n\n        elif msg_type == MessageType.ActiveSurfaceChange:\n            self.active_surface = payload\n\n        else:\n            raise TitleManagerError(\n                f'Unhandled Msg: {msg_type}, Payload: {payload}'\n            )\n\n    async def _request_connection_info(self) -> None:\n        msg = factory.title_auxiliary_stream()\n        return await self._send_message(msg)\n\n    async def start_title_channel(self, title_id: int) -> Any:\n        return await self.console.protocol.start_channel(\n            ServiceChannel.Title,\n            MessageTarget.TitleUUID,\n            title_id=title_id\n        )\n\n    @property\n    def active_surface(self):\n        \"\"\"\n        Get `Active Surface`.\n\n        Returns:\n             :class:`XStructObj`: Active Surface\n        \"\"\"\n        return self._active_surface\n\n    @active_surface.setter\n    def active_surface(self, value):\n        \"\"\"\n        Set `Active Surface`.\n\n        Args:\n            value (:class:`XStructObj`): Active Surface payload\n\n        Returns: None\n        \"\"\"\n        self._active_surface = value\n        self.on_surface_change(value)\n\n    @property\n    def connection_info(self):\n        \"\"\"\n        Get current `Connection info`\n\n        Returns:\n            :class:`XStructObj`: Connection info\n        \"\"\"\n        return self._connection_info\n\n    @connection_info.setter\n    def connection_info(self, value):\n        \"\"\"\n        Set `Connection info` and setup `Crypto`-context\n\n        Args:\n            value (:class:`XStructObj`): Connection info\n\n        Returns: None\n        \"\"\"\n        self._connection_info = value\n        self.on_connection_info(value)\n"}
{"type": "source_file", "path": "xbox/auxiliary/relay.py", "content": "import logging\n# import gevent\nimport asyncio\nfrom typing import Optional\n\nfrom xbox.sg.crypto import PKCS7Padding\nfrom xbox.sg.utils.events import Event\nfrom xbox.auxiliary import packer\nfrom xbox.auxiliary.packet import aux_header_struct, AUX_PACKET_MAGIC\nfrom xbox.auxiliary.crypto import AuxiliaryStreamCrypto\nfrom xbox.sg.utils.struct import XStructObj\n\nlog = logging.getLogger(__name__)\n\n\nclass AuxiliaryPackerException(Exception):\n    pass\n\n\nclass ConsoleConnection(object):\n    BUFFER_SIZE = 2048\n\n    def __init__(self, address, port, crypto):\n        self.address = address\n        self.port = port\n        self.crypto = crypto\n\n        self._reader: Optional[asyncio.StreamReader] = None\n        self._writer: Optional[asyncio.StreamWriter] = None\n\n        self._recv_task: Optional[asyncio.Task] = None\n        self.on_message = Event()\n\n    def start(self):\n        self._reader, self._writer = asyncio.open_connection(\n            self.address, self.port\n        )\n        self._recv_task = asyncio.create_task(self._recv())\n\n    def stop(self):\n        self._recv_task.cancel()\n\n    def handle(self, data):\n        try:\n            msg = packer.unpack(data, self.crypto)\n            # Fire event\n            self.on_message(msg)\n        except Exception as e:\n            log.exception(\"Exception while handling Console Aux data, error: {}\".format(e))\n\n    async def _recv(self):\n        while True:\n            data = await self._reader.read(4)\n            header = aux_header_struct.parse(data)\n\n            if header.magic != AUX_PACKET_MAGIC:\n                raise Exception('Invalid packet magic received from console')\n\n            payload_sz = header.payload_size + PKCS7Padding.size(\n                header.payload_size, 16\n            )\n            remaining_payload_bytes = payload_sz\n\n            while remaining_payload_bytes > 0:\n                tmp = await self._reader.read(remaining_payload_bytes)\n                remaining_payload_bytes -= len(tmp)\n                data += tmp\n\n            data += await self._reader.read(32)\n\n            self.handle(data)\n\n    async def send(self, msg):\n        packets = packer.pack(msg, self.crypto)\n\n        if not packets:\n            raise Exception('No data')\n\n        for packet in packets:\n            self._writer.write(packet)\n\n\nclass LocalConnection(asyncio.Protocol):\n    data_received_event = Event()\n    connection_made_event = Event()\n\n    def connection_made(self, transport: asyncio.BaseTransport) -> None:\n        self.transport = transport\n        self.connection_made(transport)\n\n    def data_received(self, data: bytes) -> None:\n        self.data_received(data)\n\n    def close_connection(self) -> None:\n        print('Close the client socket')\n        self.transport.close()\n\n\nclass AuxiliaryRelayService(object):\n    def __init__(\n        self,\n        loop: asyncio.AbstractEventLoop,\n        connection_info: XStructObj,\n        listen_port: int\n    ):\n        if len(connection_info.endpoints) > 1:\n            raise Exception(\n                'Auxiliary Stream advertises more than one endpoint!'\n            )\n\n        self._loop = loop\n        self.crypto = AuxiliaryStreamCrypto.from_connection_info(\n            connection_info\n        )\n        self.target_ip = connection_info.endpoints[0].ip\n        self.target_port = connection_info.endpoints[0].port\n\n        self.console_connection = ConsoleConnection(\n            self.target_ip,\n            self.target_port,\n            self.crypto\n        )\n\n        self.server = self._loop.create_server(\n            lambda: LocalConnection(),\n            '0.0.0.0', listen_port\n        )\n\n        self.client_transport = None\n\n    async def run(self):\n        async with self.server as local_connection:\n            local_connection.data_received_event += self._handle_client_data\n            local_connection.connection_made_event += self.connection_made\n\n            while True:\n                # HACK / FIXME\n                await asyncio.sleep(10000)\n\n    def connection_made(self, transport):\n        self.client_transport = transport\n        peername = transport.get_extra_info('peername')\n        print('Connection from {}'.format(peername))\n\n        self.console_connection.on_message += self._handle_console_data\n        self.console_connection.start()\n\n    def _handle_console_data(self, data):\n        # Data from console gets decrypted and forwarded to aux client\n        if self.client_transport:\n            self.client_transport.send(data)\n\n    def _handle_client_data(self, data):\n        # Data from aux client gets encrypted and sent to console\n        self.console_connection.send(data)\n"}
{"type": "source_file", "path": "xbox/handlers/fallout4_relay.py", "content": "\"\"\"\nFallout 4 AuxiliaryStream Relay client\n\nTunnels packets via TCP/27000 - compatible with regular PipBoy-clients\n\"\"\"\nimport logging\nimport asyncio\nfrom xbox.auxiliary.relay import AuxiliaryRelayService\nfrom xbox.sg.utils.struct import XStructObj\n\nLOGGER = logging.getLogger(__name__)\n\nFALLOUT_TITLE_ID = 0x4ae8f9b2\nLOCAL_PIPBOY_PORT = 27000\n\n\ndef on_connection_info(info: XStructObj):\n    loop = asyncio.get_running_loop()\n    print('Setting up relay on TCP/{0}...\\n'.format(LOCAL_PIPBOY_PORT))\n    service = AuxiliaryRelayService(loop, info, listen_port=LOCAL_PIPBOY_PORT)\n    service.run()\n"}
{"type": "source_file", "path": "xbox/handlers/gamepad_input.py", "content": "\"\"\"\nInput smartglass client\n\nSend controller input via stdin (terminal) to the console\n\"\"\"\nimport sys\nimport logging\n\nfrom xbox.sg.enum import GamePadButton\n\nLOGGER = logging.getLogger(__name__)\n\ninput_map = {\n    \"i\": GamePadButton.DPadUp,\n    \"k\": GamePadButton.DPadDown,\n    \"j\": GamePadButton.DPadLeft,\n    \"l\": GamePadButton.DPadRight,\n\n    \"a\": GamePadButton.PadA,\n    \"b\": GamePadButton.PadB,\n    \"x\": GamePadButton.PadX,\n    \"y\": GamePadButton.PadY,\n\n    \"t\": GamePadButton.View,\n    \"z\": GamePadButton.Nexu,\n    \"u\": GamePadButton.Menu\n}\n\n\ndef get_getch_func():\n    \"\"\"\n    Source: https://code.activestate.com/recipes/577977-get-single-keypress/\n    \"\"\"\n    try:\n        import tty\n        import termios\n    except ImportError:\n        # Probably Windows.\n        try:\n            import msvcrt\n        except ImportError:\n            # Just give up here.\n            raise ImportError('getch not available')\n        else:\n            return msvcrt.getch\n    else:\n        def getch():\n            \"\"\"\n            getch() -> key character\n\n            Read a single keypress from stdin and return the resulting character.\n            Nothing is echoed to the console. This call will block if a keypress\n            is not already available, but will not wait for Enter to be pressed.\n\n            If the pressed key was a modifier key, nothing will be detected; if\n            it were a special function key, it may return the first character of\n            of an escape sequence, leaving additional characters in the buffer.\n            \"\"\"\n            fd = sys.stdin.fileno()\n            old_settings = termios.tcgetattr(fd)\n            try:\n                tty.setraw(fd)\n                ch = sys.stdin.read(1)\n            finally:\n                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n            return ch\n        return getch\n\n\nasync def input_loop(console):\n    getch = get_getch_func()\n    while True:\n        ch = getch()\n        print(ch)\n        if ord(ch) == 3:  # CTRL-C\n            sys.exit(1)\n\n        elif ch not in input_map:\n            continue\n\n        button = input_map[ch]\n        await console.gamepad_input(button)\n        await console.wait(0.1)\n        await console.gamepad_input(GamePadButton.Clear)\n"}
{"type": "source_file", "path": "xbox/handlers/text_input.py", "content": "\"\"\"\nText smartglass client\n\"\"\"\nimport logging\nimport asyncio\nimport aioconsole\n\nLOGGER = logging.getLogger(__name__)\n\n\nasync def userinput_callback(console, prompt):\n    print('WAITING FOR TEXT INPUT...')\n    text = await aioconsole.ainput(prompt)\n\n    await console.send_systemtext_input(text)\n    await console.finish_text_input()\n\n\ndef on_text_config(payload):\n    pass\n\n\ndef on_text_input(console, payload):\n    asyncio.create_task(userinput_callback(console, console.text.text_prompt))\n\n\ndef on_text_done(payload):\n    pass\n"}
{"type": "source_file", "path": "xbox/rest/api.py", "content": "from fastapi import APIRouter\n\nfrom xbox.rest.routes import root, auth, device, web\n\napi_router = APIRouter()\n\napi_router.include_router(root.router, tags=[\"root\"])\napi_router.include_router(auth.router, prefix=\"/auth\", tags=[\"auth\"])\napi_router.include_router(device.router, prefix=\"/device\", tags=[\"device\"])\napi_router.include_router(web.router, prefix=\"/web\", tags=[\"web\"])"}
{"type": "source_file", "path": "xbox/rest/app.py", "content": "from fastapi import FastAPI\nimport uvicorn\nimport aiohttp\n\nfrom . import singletons\nfrom .api import api_router\n\napp = FastAPI(title='SmartGlass REST server')\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    singletons.http_session = aiohttp.ClientSession()\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    await singletons.http_session.close()\n\n\napp.include_router(api_router)\n\nif __name__ == '__main__':\n    uvicorn.run(app, host=\"0.0.0.0\", port=5557)\n"}
{"type": "source_file", "path": "xbox/rest/common.py", "content": "\nimport aiohttp\nfrom xbox.webapi.authentication.manager import AuthenticationManager\n\nfrom .schemas.auth import AuthenticationStatus, AuthSessionConfig\n\ndef generate_authentication_status(\n    manager: AuthenticationManager\n) -> AuthenticationStatus:\n    return AuthenticationStatus(\n        oauth=manager.oauth,\n        xsts=manager.xsts_token,\n        session_config=AuthSessionConfig(\n            client_id=manager._client_id,\n            client_secret=manager._client_secret,\n            redirect_uri=manager._redirect_uri,\n            scopes=manager._scopes\n        )\n    )\n\ndef generate_authentication_manager(\n    session_config: AuthSessionConfig,\n    http_session: aiohttp.ClientSession = None\n) -> AuthenticationManager:\n    return AuthenticationManager(\n        client_session=http_session,\n        client_id=session_config.client_id,\n        client_secret=session_config.client_secret,\n        redirect_uri=session_config.redirect_uri,\n        scopes=session_config.scopes\n    )"}
{"type": "source_file", "path": "xbox/rest/consolewrap.py", "content": "from typing import Dict, Optional\nimport logging\n\nfrom xbox.sg import enum\nfrom xbox.sg.console import Console\nfrom xbox.sg.manager import InputManager, TextManager, MediaManager\nfrom xbox.stump.manager import StumpManager\nfrom xbox.stump import json_model as stump_schemas\n\nfrom . import schemas\n\nlog = logging.getLogger()\n\n\nclass ConsoleWrap(object):\n    def __init__(self, console: Console):\n        self.console = console\n\n        if 'input' not in self.console.managers:\n            self.console.add_manager(InputManager)\n        if 'text' not in self.console.managers:\n            self.console.add_manager(TextManager)\n        if 'media' not in self.console.managers:\n            self.console.add_manager(MediaManager)\n        if 'stump' not in self.console.managers:\n            self.console.add_manager(StumpManager)\n\n    @staticmethod\n    async def discover(*args, **kwargs):\n        return await Console.discover(*args, **kwargs)\n\n    @staticmethod\n    async def power_on(\n        liveid: str, addr: str = None, iterations: int = 3, tries: int = 10\n    ) -> None:\n        for i in range(iterations):\n            await Console.power_on(liveid, addr=addr, tries=tries)\n            await Console.wait(1)\n\n    @property\n    def media_commands(self) -> Dict[str, enum.MediaControlCommand]:\n        return {\n            'play': enum.MediaControlCommand.Play,\n            'pause': enum.MediaControlCommand.Pause,\n            'play_pause': enum.MediaControlCommand.PlayPauseToggle,\n            'stop': enum.MediaControlCommand.Stop,\n            'record': enum.MediaControlCommand.Record,\n            'next_track': enum.MediaControlCommand.NextTrack,\n            'prev_track': enum.MediaControlCommand.PreviousTrack,\n            'fast_forward': enum.MediaControlCommand.FastForward,\n            'rewind': enum.MediaControlCommand.Rewind,\n            'channel_up': enum.MediaControlCommand.ChannelUp,\n            'channel_down': enum.MediaControlCommand.ChannelDown,\n            'back': enum.MediaControlCommand.Back,\n            'view': enum.MediaControlCommand.View,\n            'menu': enum.MediaControlCommand.Menu,\n            'seek': enum.MediaControlCommand.Seek\n        }\n\n    @property\n    def input_keys(self) -> Dict[str, enum.GamePadButton]:\n        return {\n            'clear': enum.GamePadButton.Clear,\n            'enroll': enum.GamePadButton.Enroll,\n            'nexus': enum.GamePadButton.Nexu,\n            'menu': enum.GamePadButton.Menu,\n            'view': enum.GamePadButton.View,\n            'a': enum.GamePadButton.PadA,\n            'b': enum.GamePadButton.PadB,\n            'x': enum.GamePadButton.PadX,\n            'y': enum.GamePadButton.PadY,\n            'dpad_up': enum.GamePadButton.DPadUp,\n            'dpad_down': enum.GamePadButton.DPadDown,\n            'dpad_left': enum.GamePadButton.DPadLeft,\n            'dpad_right': enum.GamePadButton.DPadRight,\n            'left_shoulder': enum.GamePadButton.LeftShoulder,\n            'right_shoulder': enum.GamePadButton.RightShoulder,\n            'left_thumbstick': enum.GamePadButton.LeftThumbStick,\n            'right_thumbstick': enum.GamePadButton.RightThumbStick\n        }\n\n    @property\n    def liveid(self) -> str:\n        return self.console.liveid\n\n    @property\n    def last_error(self) -> int:\n        return self.console.last_error\n\n    @property\n    def available(self) -> bool:\n        return bool(self.console and self.console.available)\n\n    @property\n    def connected(self) -> bool:\n        return bool(self.console and self.console.connected)\n\n    @property\n    def usable(self) -> bool:\n        return bool(self.console and self.connected)\n\n    @property\n    def connection_state(self) -> enum.ConnectionState:\n        if not self.console:\n            return enum.ConnectionState.Disconnected\n\n        return self.console.connection_state\n\n    @property\n    def pairing_state(self) -> enum.PairedIdentityState:\n        if not self.console:\n            return enum.PairedIdentityState.NotPaired\n\n        return self.console.pairing_state\n\n    @property\n    def device_status(self) -> enum.DeviceStatus:\n        if not self.console:\n            return enum.DeviceStatus.Unavailable\n\n        return self.console.device_status\n\n    @property\n    def authenticated_users_allowed(self) -> bool:\n        return bool(self.console and self.console.authenticated_users_allowed)\n\n    @property\n    def console_users_allowed(self) -> bool:\n        return bool(self.console and self.console.console_users_allowed)\n\n    @property\n    def anonymous_connection_allowed(self) -> bool:\n        return bool(self.console and self.console.anonymous_connection_allowed)\n\n    @property\n    def is_certificate_pending(self) -> bool:\n        return bool(self.console and self.console.is_certificate_pending)\n\n    @property\n    def console_status(self) -> Optional[schemas.ConsoleStatusResponse]:\n        status_json = {}\n\n        if not self.console or not self.console.console_status:\n            return None\n\n        status = self.console.console_status\n        kernel_version = '{0}.{1}.{2}'.format(status.major_version, status.minor_version, status.build_number)\n\n        status_json.update({\n            'live_tv_provider': status.live_tv_provider,\n            'kernel_version': kernel_version,\n            'locale': status.locale\n        })\n\n        active_titles = []\n        for at in status.active_titles:\n            title = {\n                'title_id': at.title_id,\n                'aum': at.aum,\n                'name': at.aum,\n                'image': None,\n                'type': None,\n                'has_focus': at.disposition.has_focus,\n                'title_location': at.disposition.title_location.name,\n                'product_id': str(at.product_id),\n                'sandbox_id': str(at.sandbox_id)\n            }\n            active_titles.append(title)\n\n        status_json.update({'active_titles': active_titles})\n        return schemas.ConsoleStatusResponse(**status_json)\n\n    @property\n    def media_status(self) -> Optional[schemas.MediaStateResponse]:\n        if not self.usable or not self.console.media or not self.console.media.media_state:\n            return None\n\n        media_state = self.console.media.media_state\n\n        # Ensure we are in the same app, otherwise this is useless\n        if media_state.aum_id not in [t.aum for t in self.console.console_status.active_titles]:\n            return None\n\n        media_state_json = {\n            'title_id': media_state.title_id,\n            'aum_id': media_state.aum_id,\n            'asset_id': media_state.asset_id,\n            'media_type': media_state.media_type.name,\n            'sound_level': media_state.sound_level.name,\n            'enabled_commands': media_state.enabled_commands.value,\n            'playback_status': media_state.playback_status.name,\n            'rate': media_state.rate,\n            'position': media_state.position,\n            'media_start': media_state.media_start,\n            'media_end': media_state.media_end,\n            'min_seek': media_state.min_seek,\n            'max_seek': media_state.max_seek,\n            'metadata': None\n        }\n\n        metadata = {}\n        for meta in media_state.metadata:\n            metadata[meta.name] = meta.value\n\n        media_state_json['metadata'] = metadata\n        return schemas.MediaStateResponse(**media_state_json)\n\n    @property\n    def status(self) -> schemas.DeviceStatusResponse:\n        data = self.console.to_dict()\n        data.update({\n            'liveid': self.console.liveid,\n            'ip_address': self.console.address,\n            'connection_state': self.connection_state.name,\n            'pairing_state': self.pairing_state.name,\n            'device_status': self.device_status.name,\n            'last_error': self.last_error,\n            'authenticated_users_allowed': self.authenticated_users_allowed,\n            'console_users_allowed': self.console_users_allowed,\n            'anonymous_connection_allowed': self.anonymous_connection_allowed,\n            'is_certificate_pending': self.is_certificate_pending\n        })\n\n        return schemas.DeviceStatusResponse(**data)\n\n    @property\n    def text_active(self) -> bool:\n        if self.usable:\n            return self.console.text.got_active_session\n\n    async def get_stump_config(self) -> stump_schemas.Configuration:\n        if self.usable:\n            return await self.console.stump.request_stump_configuration()\n\n    async def get_headend_info(self) -> stump_schemas.HeadendInfo:\n        if self.usable:\n            return await self.console.stump.request_headend_info()\n\n    async def get_livetv_info(self) -> stump_schemas.LiveTvInfo:\n        if self.usable:\n            return await self.console.stump.request_live_tv_info()\n\n    async def get_tuner_lineups(self) -> stump_schemas.TunerLineups:\n        if self.usable:\n            return await self.console.stump.request_tuner_lineups()\n\n    async def connect(\n        self,\n        userhash: Optional[str] = None,\n        xtoken: Optional[str] = None\n    ) -> enum.ConnectionState:\n        if not self.console:\n            return enum.ConnectionState.Disconnected\n        elif self.console.connected:\n            return enum.ConnectionState.Connected\n        elif not self.anonymous_connection_allowed and (not userhash or not xtoken):\n            raise Exception('Requested anonymous connection is not allowed by console')\n\n        state = await self.console.connect(userhash=userhash,\n                                           xsts_token=xtoken)\n\n        if state == enum.ConnectionState.Connected:\n            await self.console.wait(0.5)\n            await self.console.stump.request_stump_configuration()\n\n        return state\n\n    async def disconnect(self) -> bool:\n        await self.console.disconnect()\n        return True\n\n    async def power_off(self) -> bool:\n        await self.console.power_off()\n        return True\n\n    async def launch_title(self, app_id: str) -> None:\n        return await self.console.launch_title(app_id)\n\n    async def send_stump_key(self, device_id: str, button: str) -> bool:\n        result = await self.console.send_stump_key(button, device_id)\n        print(result)\n        return True\n\n    async def send_media_command(self, command: enum.MediaControlCommand, seek_position: Optional[int] = None) -> bool:\n        title_id = 0\n        request_id = 0\n        await self.console.media_command(title_id, command, request_id, seek_position)\n        return True\n\n    async def send_gamepad_button(self, btn: enum.GamePadButton) -> bool:\n        await self.console.gamepad_input(btn)\n        # Its important to clear button-press afterwards\n        await self.console.wait(0.1)\n        await self.console.gamepad_input(enum.GamePadButton.Clear)\n        return True\n\n    async def send_text(self, text: str) -> bool:\n        if not self.text_active:\n            return False\n\n        await self.console.send_systemtext_input(text)\n        await self.console.finish_text_input()\n        return True\n\n    async def dvr_record(self, start_delta, end_delta) -> bool:\n        await self.console.game_dvr_record(start_delta, end_delta)\n        return True\n"}
{"type": "source_file", "path": "xbox/rest/routes/__init__.py", "content": ""}
{"type": "source_file", "path": "xbox/rest/deps.py", "content": "from typing import Tuple, Optional\nimport aiohttp\nfrom fastapi import Query, Header, HTTPException, status\nfrom xbox.webapi.api.language import DefaultXboxLiveLanguages, XboxLiveLanguage\n\nfrom . import singletons\nfrom .common import generate_authentication_status\nfrom .schemas.auth import AuthenticationStatus\n\nfrom xbox.webapi.api.client import XboxLiveClient\n\n\ndef console_connected(liveid: str):\n    console = singletons.console_cache.get(liveid)\n    if not console:\n        raise HTTPException(status_code=400, detail=f'Console {liveid} is not alive')\n    elif not console.connected:\n        raise HTTPException(status_code=400, detail=f'Console {liveid} is not connected')\n    return console\n\n\ndef console_exists(liveid: str):\n    console = singletons.console_cache.get(liveid)\n    if not console:\n        raise HTTPException(status_code=400, detail=f'Console info for {liveid} is not available')\n\n    return console\n\n\nasync def get_xbl_client() -> Optional[XboxLiveClient]:\n    return singletons.xbl_client\n\n\ndef get_authorization(\n    anonymous: Optional[bool] = Query(default=True)\n) -> Optional[AuthenticationStatus]:\n    if anonymous:\n        return None\n    elif not singletons.authentication_manager:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail='Authorization data not available'\n        )\n    return generate_authentication_status(singletons.authentication_manager)\n"}
{"type": "source_file", "path": "xbox/rest/routes/auth.py", "content": "import secrets\nimport aiohttp\n\nfrom typing import Optional\nfrom fastapi import APIRouter, HTTPException, status\nfrom fastapi.responses import RedirectResponse\n\nfrom .. import singletons, schemas\nfrom ..common import generate_authentication_status, generate_authentication_manager\n\nfrom xbox.webapi.scripts import CLIENT_ID, CLIENT_SECRET\nfrom xbox.webapi.api.client import XboxLiveClient\n\nrouter = APIRouter()\n\n\n@router.get('/', response_model=schemas.AuthenticationStatus)\ndef authentication_overview():\n    if not singletons.authentication_manager:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='You have to login first')\n\n    return generate_authentication_status(singletons.authentication_manager)\n\n\n@router.get('/login', status_code=status.HTTP_307_TEMPORARY_REDIRECT)\nasync def xboxlive_login(\n    client_id: str = CLIENT_ID,\n    client_secret: Optional[str] = CLIENT_SECRET,\n    redirect_uri: str = 'http://localhost:5557/auth/callback',\n    scopes: str = 'Xboxlive.signin,Xboxlive.offline_access'\n):\n    if scopes:\n        scopes = scopes.split(',')\n\n    auth_session_config = schemas.AuthSessionConfig(\n        client_id=client_id,\n        client_secret=client_secret,\n        redirect_uri=redirect_uri,\n        scopes=scopes\n    )\n\n    # Create local instance of AuthenticationManager\n    # -> Final instance will be created and saved in the\n    #    callback route\n    auth_mgr = generate_authentication_manager(auth_session_config)\n\n    # Generating a random state to transmit in the authorization url\n    session_state = secrets.token_hex(10)\n    # Storing the state/session config so it can be retrieved\n    # in the callback function\n    singletons.auth_session_configs.update({session_state: auth_session_config})\n\n    authorization_url = auth_mgr.generate_authorization_url(state=session_state)\n    return RedirectResponse(authorization_url)\n\n\n@router.get('/callback', status_code=status.HTTP_307_TEMPORARY_REDIRECT)\nasync def xboxlive_login_callback(\n    code: str,\n    state: str,\n    error: Optional[str] = None\n):\n    if error:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error)\n    elif not code or not state:\n        parameter_name = 'Code' if not code else 'State'\n        error_detail = f'{parameter_name} missing from authorization callback'\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_detail)\n\n    # Get auth session config that was set previously when\n    # generating authorization redirect\n    auth_session_config = singletons.auth_session_configs.get(state)\n    if not auth_session_config:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f'Auth session config for state \\'{state}\\' not found'\n        )\n\n    # Construct authentication manager that will be cached\n    auth_mgr = generate_authentication_manager(\n        auth_session_config,\n        singletons.http_session\n    )\n    await auth_mgr.request_tokens(code)\n\n    singletons.authentication_manager = auth_mgr\n    singletons.xbl_client = XboxLiveClient(singletons.authentication_manager)\n    return RedirectResponse(url='/auth')\n\n\n@router.get('/refresh', status_code=status.HTTP_307_TEMPORARY_REDIRECT)\nasync def refresh_tokens():\n    if not singletons.authentication_manager:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='You have to login first')\n\n    async with aiohttp.ClientSession() as http_session:\n        singletons.authentication_manager.session = http_session\n        singletons.authentication_manager.oauth = await singletons.authentication_manager.refresh_oauth_token()\n        singletons.authentication_manager.user_token = await singletons.authentication_manager.request_user_token()\n        singletons.authentication_manager.xsts_token = await singletons.authentication_manager.request_xsts_token()\n\n    return RedirectResponse(url='/auth')\n\n\n@router.get('/logout', response_model=schemas.GeneralResponse)\nasync def xboxlive_logout():\n    singletons.authentication_manager = None\n    return schemas.GeneralResponse(success=True)\n"}
{"type": "source_file", "path": "xbox/rest/routes/device.py", "content": "import logging\nfrom typing import Optional, List\n\nfrom fastapi import APIRouter, Depends, HTTPException\n\nfrom .. import schemas, singletons\nfrom ..deps import console_exists, console_connected, get_xbl_client, get_authorization\nfrom ..consolewrap import ConsoleWrap\n\nfrom xbox.webapi.api.client import XboxLiveClient\nfrom xbox.webapi.api.provider.titlehub import TitleFields\nfrom xbox.sg import enum\nfrom xbox.stump import json_model as stump_schemas\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.get('/', response_model=List[schemas.DeviceStatusResponse])\nasync def device_overview(addr: Optional[str] = None):\n    discovered = await ConsoleWrap.discover(addr=addr)\n    discovered = discovered.copy()\n\n    liveids = [d.liveid for d in discovered]\n    for i, c in enumerate(singletons.console_cache.values()):\n        if c.liveid in liveids:\n            # Refresh existing entries\n            index = liveids.index(c.liveid)\n\n            if c.device_status != discovered[index].device_status:\n                singletons.console_cache[c.liveid] = ConsoleWrap(discovered[index])\n            del discovered[index]\n            del liveids[index]\n        elif c.liveid not in liveids:\n            # Set unresponsive consoles to Unavailable\n            singletons.console_cache[c.liveid].console.device_status = enum.DeviceStatus.Unavailable\n\n    # Extend by new entries\n    for d in discovered:\n        singletons.console_cache.update({d.liveid: ConsoleWrap(d)})\n\n    # Filter for specific console when ip address query is supplied (if available)\n    consoles = [console.status for console in singletons.console_cache.values()\n            if (addr and console.status.ip_address == addr) or not addr]\n    return consoles\n\n\n@router.get('/{liveid}/poweron', response_model=schemas.GeneralResponse)\nasync def poweron(liveid: str, addr: Optional[str] = None):\n    await ConsoleWrap.power_on(liveid, addr=addr)\n    return schemas.GeneralResponse(success=True)\n\n\n\"\"\"\nRequire enumerated console\n\"\"\"\n\n\n@router.get('/{liveid}', response_model=schemas.DeviceStatusResponse)\ndef device_info(\n    console: ConsoleWrap = Depends(console_exists)\n):\n    return console.status\n\n\n@router.get('/{liveid}/connect', response_model=schemas.GeneralResponse)\nasync def force_connect(\n    console: ConsoleWrap = Depends(console_exists),\n    authentication_data: schemas.AuthenticationStatus = Depends(get_authorization)\n):\n    try:\n        userhash = ''\n        xtoken = ''\n        if authentication_data:\n            userhash = authentication_data.xsts.userhash\n            xtoken = authentication_data.xsts.token\n\n        state = await console.connect(userhash, xtoken)\n    except Exception as e:\n        raise\n\n    if state != enum.ConnectionState.Connected:\n        raise HTTPException(status_code=400, detail='Connection failed')\n\n    return schemas.GeneralResponse(success=True, details={'connection_state': state.name})\n\n\n\"\"\"\nRequire connected console\n\"\"\"\n\n\n@router.get('/{liveid}/disconnect', response_model=schemas.GeneralResponse)\nasync def disconnect(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    await console.disconnect()\n    return schemas.GeneralResponse(success=True)\n\n\n@router.get('/{liveid}/poweroff', response_model=schemas.GeneralResponse)\nasync def poweroff(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    if not await console.power_off():\n        raise HTTPException(status_code=400, detail='Failed to power off')\n\n    return schemas.GeneralResponse(success=True)\n\n\n@router.get('/{liveid}/console_status', response_model=schemas.ConsoleStatusResponse)\nasync def console_status(\n    console: ConsoleWrap = Depends(console_connected),\n    xbl_client: XboxLiveClient = Depends(get_xbl_client)\n):\n    status = console.console_status\n    # Update Title Info, if authorization data is available\n    if xbl_client and status:\n        for t in status.active_titles:\n            try:\n                title_id = t.title_id\n                resp = singletons.title_cache.get(title_id)\n                if not resp:\n                    resp = await xbl_client.titlehub.get_title_info(title_id, [TitleFields.IMAGE])\n                if resp.titles[0]:\n                    singletons.title_cache[title_id] = resp\n                    t.name = resp.titles[0].name\n                    t.image = resp.titles[0].display_image\n                    t.type = resp.titles[0].type\n            except Exception as e:\n                logger.exception(f'Failed to download title metadata for AUM: {t.aum}', exc_info=e)\n    return status\n\n\n@router.get('/{liveid}/launch/{app_id}', response_model=schemas.GeneralResponse, deprecated=True)\nasync def launch_title(\n    console: ConsoleWrap = Depends(console_connected),\n    *,\n    app_id: str\n):\n    await console.launch_title(app_id)\n    return schemas.GeneralResponse(success=True, details={'launched': app_id})\n\n\n@router.get('/{liveid}/media_status', response_model=schemas.MediaStateResponse)\ndef media_status(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    return console.media_status\n\n\n@router.get('/{liveid}/ir', response_model=schemas.InfraredResponse)\nasync def infrared(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    stump_config = await console.get_stump_config()\n\n    devices = {}\n    for device_config in stump_config.params:\n        button_links = {}\n        for button in device_config.buttons:\n            button_links[button] = schemas.InfraredButton(\n                url=f'/device/{console.liveid}/ir/{device_config.device_id}/{button}',\n                value=device_config.buttons[button]\n            )\n\n        devices[device_config.device_type] = schemas.InfraredDevice(\n            device_type=device_config.device_type,\n            device_brand=device_config.device_brand,\n            device_model=device_config.device_model,\n            device_name=device_config.device_name,\n            device_id=device_config.device_id,\n            buttons=button_links\n        )\n\n    return schemas.InfraredResponse(__root__=devices)\n\n\n@router.get('/{liveid}/ir/{device_id}', response_model=schemas.InfraredDevice)\nasync def infrared_available_keys(\n    console: ConsoleWrap = Depends(console_connected),\n    *,\n    device_id: str\n):\n    stump_config = await console.get_stump_config()\n    for device_config in stump_config.params:\n        if device_config.device_id != device_id:\n            continue\n\n        button_links = {}\n        for button in device_config.buttons:\n            button_links[button] = schemas.InfraredButton(\n                url=f'/device/{console.liveid}/ir/{device_config.device_id}/{button}',\n                value=device_config.buttons[button]\n            )\n\n        return schemas.InfraredDevice(\n            device_type=device_config.device_type,\n            device_brand=device_config.device_brand,\n            device_model=device_config.device_model,\n            device_name=device_config.device_name,\n            device_id=device_config.device_id,\n            buttons=button_links\n        )\n\n    raise HTTPException(status_code=400, detail=f'Device Id \\'{device_id}\\' not found')\n\n\n@router.get('/{liveid}/ir/{device_id}/{button}', response_model=schemas.GeneralResponse)\nasync def infrared_send(\n    console: ConsoleWrap = Depends(console_connected),\n    *,\n    device_id: str,\n    button: str\n):\n    if not await console.send_stump_key(device_id, button):\n        raise HTTPException(status_code=400, detail='Failed to send button')\n\n    return schemas.GeneralResponse(success=True, details={'sent_key': button, 'device_id': device_id})\n\n\n@router.get('/{liveid}/media', response_model=schemas.MediaCommandsResponse)\ndef media_overview(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    return schemas.MediaCommandsResponse(commands=list(console.media_commands.keys()))\n\n\n@router.get('/{liveid}/media/{command}', response_model=schemas.GeneralResponse)\nasync def media_command(\n    console: ConsoleWrap = Depends(console_connected),\n    *,\n    command: str,\n    seek_position: Optional[int] = None\n):\n    cmd = console.media_commands.get(command)\n    if not cmd:\n        raise HTTPException(status_code=400, detail=f'Invalid command passed, command: {command}')\n    elif cmd == enum.MediaControlCommand.Seek and seek_position is None:\n        raise HTTPException(status_code=400, detail=f'Seek command requires seek_position argument')\n\n    await console.send_media_command(cmd, seek_position=seek_position)\n    return schemas.GeneralResponse(success=True)\n\n\n@router.get('/{liveid}/input', response_model=schemas.InputResponse)\ndef input_overview(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    return schemas.InputResponse(buttons=list(console.input_keys.keys()))\n\n\n@router.get('/{liveid}/input/{button}', response_model=schemas.GeneralResponse)\nasync def input_send_button(\n    console: ConsoleWrap = Depends(console_connected),\n    *,\n    button: str\n):\n    btn = console.input_keys.get(button)\n    if not btn:\n        raise HTTPException(status_code=400, detail=f'Invalid button passed, button: {button}')\n\n    await console.send_gamepad_button(btn)\n    return schemas.GeneralResponse(success=True)\n\n\n@router.get('/{liveid}/stump/headend', response_model=stump_schemas.HeadendInfo)\nasync def stump_headend_info(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    return await console.get_headend_info()\n\n\n@router.get('/{liveid}/stump/livetv', response_model=stump_schemas.LiveTvInfo)\nasync def stump_livetv_info(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    return await console.get_livetv_info()\n\n\n@router.get('/{liveid}/stump/tuner_lineups', response_model=stump_schemas.TunerLineups)\nasync def stump_tuner_lineups(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    return await console.get_tuner_lineups()\n\n\n@router.get('/{liveid}/text', response_model=schemas.device.TextSessionActiveResponse)\ndef text_overview(\n    console: ConsoleWrap = Depends(console_connected)\n):\n    return schemas.TextSessionActiveResponse(text_session_active=console.text_active)\n\n\n@router.get('/{liveid}/text/{text}', response_model=schemas.GeneralResponse)\nasync def text_send(\n    console: ConsoleWrap = Depends(console_connected),\n    *,\n    text: str\n):\n    await console.send_text(text)\n    return schemas.GeneralResponse(success=True)\n\n\n@router.get('/{liveid}/gamedvr', response_model=schemas.GeneralResponse)\nasync def gamedvr_record(\n    console: ConsoleWrap = Depends(console_connected),\n    start: Optional[int] = -60,\n    end: Optional[int] = 0\n):\n    \"\"\"\n    Default to record last 60 seconds\n    Adjust with start/end query parameter\n    (delta time in seconds)\n    \"\"\"\n    try:\n        await console.dvr_record(start, end)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f'GameDVR failed, error: {e}')\n\n    return schemas.GeneralResponse(success=True)\n"}
{"type": "source_file", "path": "xbox/rest/routes/web.py", "content": "from typing import Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom ..deps import get_xbl_client\n\nfrom xbox.webapi.api.client import XboxLiveClient\nfrom xbox.webapi.api.provider.titlehub import TitleFields\nfrom xbox.webapi.api.provider.titlehub import models as titlehub_models\nfrom xbox.webapi.api.provider.lists import models as lists_models\n\nrouter = APIRouter()\n\n\n@router.get('/title/{title_id}', response_model=titlehub_models.Title)\nasync def download_title_info(\n    client: XboxLiveClient = Depends(get_xbl_client),\n    *,\n    title_id: int\n):\n    if not client:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='You have to login first')\n\n    try:\n        resp = await client.titlehub.get_title_info(title_id, [TitleFields.IMAGE])\n        return resp.titles[0]\n    except KeyError:\n        raise HTTPException(status_code=404, detail='Cannot find titles-node json response')\n    except IndexError:\n        raise HTTPException(status_code=404, detail='No info for requested title not found')\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f'Download of titleinfo failed, error: {e}')\n\n\n@router.get('/titlehistory', response_model=titlehub_models.TitleHubResponse)\nasync def download_title_history(\n    client: XboxLiveClient = Depends(get_xbl_client),\n    max_items: Optional[int] = 5\n):\n    if not client:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='You have to login first')\n\n    try:\n        resp = await client.titlehub.get_title_history(client.xuid, max_items=max_items)\n        return resp\n    except Exception as e:\n        return HTTPException(status_code=400, detail=f'Download of titlehistory failed, error: {e}')\n\n\n@router.get('/pins', response_model=lists_models.ListsResponse)\nasync def download_pins(\n    client: XboxLiveClient = Depends(get_xbl_client)\n):\n    if not client:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='You have to login first')\n\n    try:\n        resp = await client.lists.get_items(client.xuid)\n        return resp\n    except Exception as e:\n        return HTTPException(status_code=400, detail=f'Download of pins failed, error: {e}')\n"}
{"type": "source_file", "path": "xbox/handlers/tui.py", "content": "\"\"\"\nTerminal UI Smartglass Client\n\nSupported functions: Poweron/off, launch title, gamepad input and entering text.\nAdditional shows console status (active titles, OS version, locale) and media state.\n\"\"\"\nimport json\nimport urwid\nimport logging\nimport asyncio\nfrom typing import List, Optional\nfrom binascii import hexlify\n\nfrom ..scripts import ExitCodes\nfrom ..sg.console import Console\nfrom ..sg.enum import DeviceStatus, GamePadButton, MediaPlaybackStatus\nfrom ..sg.manager import InputManager, TextManager, MediaManager\n\nfrom xbox.webapi.authentication.manager import AuthenticationManager\n\nfrom construct.lib import containers\ncontainers.setGlobalPrintFullStrings(True)\n\n\nclass ControllerRemote(urwid.Filler):\n    keymap = {\n        'tab': GamePadButton.View,\n        '<': GamePadButton.Menu,\n        '#': GamePadButton.Nexu,\n        'up': GamePadButton.DPadUp,\n        'down': GamePadButton.DPadDown,\n        'left': GamePadButton.DPadLeft,\n        'right': GamePadButton.DPadRight,\n        'a': GamePadButton.PadA,\n        'b': GamePadButton.PadB,\n        'x': GamePadButton.PadX,\n        'y': GamePadButton.PadY\n    }\n    text = 'Use keyboard to send controller input'\n\n    def __init__(self, app, console, original_widget):\n        self.app = app\n        self.console = console\n\n        super(ControllerRemote, self).__init__(original_widget, 'top')\n\n    def keypress(self, size, key):\n        if key in self.keymap:\n            button = self.keymap[key]\n            asyncio.create_task(self.console.gamepad_input(button))\n            asyncio.create_task(self.console.gamepad_input(GamePadButton.Clear))\n        elif key in ('q', 'Q'):\n            return key\n        else:\n            return super(ControllerRemote, self).keypress(size, key)\n\n\nclass QuestionBox(urwid.Filler):\n    def __init__(self, edit_widget, callback, **kwargs):\n        super(QuestionBox, self).__init__(edit_widget, **kwargs)\n        self.callback = callback\n\n    def keypress(self, size, key):\n        if key != 'enter':\n            return super(QuestionBox, self).keypress(size, key)\n        else:\n            self.callback(self.original_widget.edit_text)\n\n\nclass TextInput(urwid.Filler):\n    def __init__(self, app, edit_widget, console, **kwargs):\n        super(TextInput, self).__init__(edit_widget, **kwargs)\n        self.app = app\n        self.console = console\n\n    def keypress(self, size, key):\n        if key != 'enter':\n            ret = super(TextInput, self).keypress(size, key)\n            asyncio.create_task(self.console.send_systemtext_input(self.original_widget.edit_text))\n            return ret\n        else:\n            asyncio.create_task(self.console.finish_text_input())\n            self.app.return_to_details_menu()\n\n\nclass MediaProgressbar(urwid.ProgressBar):\n    def __init__(self, normal, complete):\n        super(MediaProgressbar, self).__init__(normal, complete)\n        self._current_text = 'No media playing'\n\n    def get_text(self):\n        return self._current_text\n\n    def update_from_state(self, state):\n        if not state or state.playback_status in (MediaPlaybackStatus.Stopped, MediaPlaybackStatus.Closed):\n            self._current_text = 'No media playing'\n            self.set_completion(0.0)\n        else:\n            pos_seconds = state.position / 10000000\n            total_seconds = state.media_end / 10000000\n            self._current_text = '{pmin:02d}:{psec:02d} / {tmin:02d}:{tsec:02d}'.format(\n                pmin=int(pos_seconds // 60),\n                psec=int(pos_seconds % 60),\n                tmin=int(total_seconds // 60),\n                tsec=int(total_seconds % 60)\n            )\n            if state.media_end > 0:\n                self.done = state.media_end\n            self.set_completion(state.position)\n\n\nclass ConsoleView(urwid.Frame):\n    def __init__(self, app, console, **kwargs):\n        self.app = app\n        self.console = console\n\n        self.device_info = urwid.LineBox(urwid.Text('Not available'), 'Device info')\n        self.status = urwid.LineBox(urwid.Text('Not available'), 'Console status')\n        self.media_text = urwid.Text('Not available')\n        self.media_progress = MediaProgressbar('pg normal', 'pg complete')\n        media_state_pile = urwid.Pile([self.media_text, self.media_progress])\n        self.media_state = urwid.LineBox(media_state_pile, 'Media State')\n\n        self.pile = urwid.Pile([self.device_info, self.status, self.media_state])\n        self.filler = urwid.Filler(self.pile, valign='top')\n\n        self.update_device_info()\n        self.console.on_timeout += self.update_device_info\n        self.console.on_pairing_state += lambda _: self.update_device_info()\n        self.console.on_connection_state += lambda _: self.update_device_info()\n        self.console.on_active_surface += lambda _: self.update_device_info()\n        self.console.on_console_status += self.on_console_status\n        self.console.media.on_media_state += self.on_media_state\n        self.console.text.on_systemtext_configuration += lambda _: self.app.view_text_input_overlay(self.console)\n        self.console.text.on_systemtext_input += lambda _: None  # Update text overlay with input text\n        self.console.text.on_systemtext_done += lambda _: self.app.return_to_details_menu()\n\n        super(ConsoleView, self).__init__(self.filler, **kwargs)\n\n    def update_device_info(self):\n        text = 'Name: {c.name:<15}\\nAddress: {c.address:<15}\\nLiveID: {c.liveid:<15}\\n' \\\n               'UUID: {c.uuid}\\n\\n'.format(c=self.console)\n\n        text += 'Connection State: {:<15}\\n'.format(self.console.connection_state.name)\n        text += 'Pairing State: {:<15}\\n'.format(self.console.pairing_state.name)\n        # text += 'Active Surface: {}\\n'.format(ActiveSurfaceType[self.console.active_surface.surface_type])\n        text += 'Shared secret: {hex_secret}'.format(\n            hex_secret=hexlify(self.console._crypto.shared_secret).decode('utf-8')\n        )\n        self.device_info.original_widget.set_text(text)\n\n    def on_console_status(self, console_status):\n        if not console_status:\n            self.status.original_widget.set_text('Not available')\n            return\n\n        text = \\\n            'LiveTV Provider: {status.live_tv_provider:<10}' \\\n            'Locale: {status.locale:<10}' \\\n            'OS: {status.major_version}.{status.minor_version}.{status.build_number}\\n'.format(\n                status=console_status\n            )\n        for title in console_status.active_titles:\n            text += '{focus} {title.aum} (0x{title.title_id:08x}) [{location}]\\n'.format(\n                focus='*' if title.disposition.has_focus else ' ',\n                title=title, location=title.disposition.title_location.name\n            )\n        self.status.original_widget.set_text(text)\n\n    def on_media_state(self, state):\n        if not state:\n            self.media_text.set_text('Not available')\n            self.media_progress.update_from_state(state)\n            return\n\n        text = \\\n            'Title: {state.aum_id:<20} (0x{state.title_id:08x}) AssetId: {state.asset_id:<25}\\n' \\\n            'MediaType: {media_type:<25} SoundLevel: {sound_level:<25}\\n' \\\n            'Playback: {playback_status:<25}\\n'.format(\n                state=state, media_type=state.media_type.name, sound_level=state.sound_level.name,\n                playback_status=state.playback_status.name\n            )\n        for metadata in state.metadata:\n            text += '{metadata.name}: {metadata.value}\\n'.format(metadata=metadata)\n        if state.playback_status in (MediaPlaybackStatus.Stopped, MediaPlaybackStatus.Closed):\n            self.media_text.set_text('Not available')\n        else:\n            self.media_text.set_text(text)\n        self.media_progress.update_from_state(state)\n\n    def keypress(self, size, key):\n        if key in ('c', 'C'):\n            self.app.view_commands_menu(self.console)\n        else:\n            return super(ConsoleView, self).keypress(size, key)\n\n\nclass ConsoleButton(urwid.Button):\n    focus_map = {\n        None: 'selected',\n        'connected': 'connected selected'\n    }\n\n    def __init__(self, app, console):\n        super(ConsoleButton, self).__init__('')\n        self.app = app\n\n        self.console = console\n        self.console.add_manager(InputManager)\n        self.console.add_manager(MediaManager)\n        self.console.add_manager(TextManager)\n        self.console.on_connection_state += lambda _: self.refresh()\n        self.console.on_console_status += lambda _: self.refresh()\n        self.console.on_device_status += lambda _: self.refresh()\n\n        urwid.connect_signal(self, 'click', self.callback)\n        self.textwidget = urwid.AttrWrap(urwid.SelectableIcon('', cursor_position=0), None)\n        self._w = urwid.AttrMap(self.textwidget, None, self.focus_map)\n        self.refresh()\n\n    def callback(self, *args):\n        asyncio.create_task(self.cb_connect())\n\n    async def cb_connect(self):\n        if await self.connect():\n            self.app.view_details_menu(self.console)\n\n    async def connect(self):\n        if self.console.connected:\n            return True\n\n        if not self.console.available:\n            self.app.view_msgbox('Console unavailable, try refreshing')\n            return False\n\n        userhash = ''\n        xsts_token = ''\n\n        if self.app.auth_mgr:\n            userhash = self.app.auth_mgr.xsts_token.userhash\n            xsts_token = self.app.auth_mgr.xsts_token.token\n\n        state = await self.console.connect(\n            userhash=userhash,\n            xsts_token=xsts_token\n        )\n\n        if not self.console.connected:\n            self.app.view_msgbox('Connection failed! State: {}'.format(state))\n            return False\n\n        return True\n\n    async def disconnect(self):\n        if self.console.connected:\n            await self.console.disconnect()\n\n    def refresh(self):\n        text = ' {c.name:<20}{c.address:<20}{c.liveid:<20}{ds:<20}'.format(\n            c=self.console,\n            ds=f'{self.console.device_status.name}, {self.console.connection_state.name}'\n        )\n        self.textwidget.set_text(text)\n\n        if self.console.connected:\n            self.textwidget.set_attr('connected')\n        else:\n            self.textwidget.set_attr(None)\n\n    def keypress(self, size, key):\n        if key in ('p', 'P'):\n            asyncio.create_task(self.console.power_on())\n        elif key in ('c', 'C'):\n            asyncio.create_task(self.connect())\n        elif key in ('d', 'D'):\n            asyncio.create_task(self.disconnect())\n        else:\n            return super(ConsoleButton, self).keypress(size, key)\n\n\nclass ConsoleList(urwid.Frame):\n    def __init__(self, app, consoles, header, footer):\n        walker = urwid.SimpleFocusListWalker([])\n        listbox = urwid.ListBox(walker)\n\n        frame = urwid.Frame(listbox, header=urwid.Text(' {0:<20}{1:<20}{2:<20}{3:<20}'.format(\n            'Name', 'IP Address', 'Live ID', 'Status'\n        )))\n        view = urwid.LineBox(frame, 'Consoles')\n\n        self.walker = walker\n        self.app = app\n        self.consoles = consoles\n        super(ConsoleList, self).__init__(view, header=header, footer=footer)\n        self.walker[:] = [ConsoleButton(self.app, c) for c in self.consoles]\n\n    async def refresh(self):\n        await self._refresh()\n\n    async def _refresh(self):\n        discovered = await Console.discover(blocking=True)\n\n        liveids = [d.liveid for d in discovered]\n        for i, c in enumerate(self.consoles):\n            if c.liveid in liveids:\n                # Refresh existing entries\n                idx = liveids.index(c.liveid)\n                if c.device_status != discovered[idx].device_status:\n                    self.consoles[i] = discovered[idx]\n                del discovered[idx]\n                del liveids[idx]\n            elif c.liveid not in liveids:\n                # Set unresponsive consoles to Unavailable\n                self.consoles[i].device_status = DeviceStatus.Unavailable\n\n        # Add newly discovered consoles\n        self.consoles.extend(discovered)\n\n        # Update the consolelist view\n        self.walker[:] = [ConsoleButton(self.app, c) for c in self.consoles]\n\n    def keypress(self, size, key):\n        if key in ('r', 'R'):\n            asyncio.create_task(self.refresh())\n        else:\n            return super(ConsoleList, self).keypress(size, key)\n\n\nclass CommandList(urwid.SimpleFocusListWalker):\n    def __init__(self, app, console):\n        commands = [\n            ('Launch title', self._launch_title),\n            ('Controller remote', self._controller_remote),\n            ('Disconnect', self._disconnect),\n            ('Power off', self._power_off)\n        ]\n        self.app = app\n        self.console = console\n        super(CommandList, self).__init__([CommandButton(text, func) for text, func in commands])\n\n    def _launch_title(self):\n        self.app.view_launch_title_textbox(self.__launch_title)\n\n    def __launch_title(self, uri):\n        asyncio.create_task(self.console.launch_title(uri))\n        self.app.return_to_details_menu()\n\n    def _controller_remote(self):\n        self.app.view_controller_remote_overlay(self.console)\n\n    def _disconnect(self):\n        asyncio.create_task(self.console.disconnect())\n        self.app.return_to_main_menu()\n\n    def _power_off(self):\n        asyncio.create_task(self.console.power_off())\n        self.app.return_to_main_menu()\n\n\nclass CommandButton(urwid.Button):\n    focus_map = {\n        None: 'selected',\n    }\n\n    def __init__(self, text, func):\n        super(CommandButton, self).__init__('')\n        urwid.connect_signal(self, 'click', self.callback)\n        self.text = text\n        self.func = func\n        self.textwidget = urwid.AttrWrap(urwid.SelectableIcon(' {}'.format(self.text), cursor_position=0), None)\n        self._w = urwid.AttrMap(self.textwidget, None, self.focus_map)\n\n    def callback(self, *args):\n        self.func()\n\n\nclass UrwidLogHandler(logging.Handler):\n    def __init__(self, callback):\n        super(UrwidLogHandler, self).__init__()\n        self.callback = callback\n\n    def emit(self, record):\n        try:\n            self.callback(record)\n        except Exception:\n            self.handleError(record)\n\n\nclass LogListBox(urwid.ListBox):\n    def __init__(self, app, size=10000):\n        self.app = app\n        self.size = size\n        self.entries = urwid.SimpleFocusListWalker([])\n\n        self.handler = UrwidLogHandler(self._log_callback)\n        self.handler.setFormatter(app.log_fmt)\n        logging.root.addHandler(self.handler)\n        logging.root.setLevel(app.log_level)\n        super(LogListBox, self).__init__(self.entries)\n\n    def _log_callback(self, record):\n        self.entries.append(LogButton(self.app, self.handler.format(record), record))\n        if self.focus_position == len(self.entries) - 2:\n            self.focus_position += 1\n\n        if len(self.entries) > self.size:\n            self.entries[:] = self.entries[len(self.entries) - self.size:]\n\n    def keypress(self, size, key):\n        # Prevents opening the log window multiple times\n        if key in ('l', 'L'):\n            pass\n        else:\n            return super(LogListBox, self).keypress(size, key)\n\n\nclass LogButton(urwid.Button):\n    focus_map = {\n        None: 'selected',\n    }\n\n    def __init__(self, app, text, record):\n        super(LogButton, self).__init__('')\n        self.app = app\n        self.text = text\n        self.record = record\n\n        urwid.connect_signal(self, 'click', self._click)\n        self.textwidget = urwid.AttrWrap(urwid.SelectableIcon(' {}'.format(self.text), cursor_position=0), None)\n        self._w = urwid.AttrMap(self.textwidget, None, self.focus_map)\n\n    def _click(self, *args):\n        if hasattr(self.record, '_msg'):\n            self.app.view_scrollable_overlay(repr(self.record._msg), \"Message details\", width=80)\n\n\nclass SGDisplay(object):\n    palette = [\n        ('header', 'yellow', 'dark blue', 'standout'),\n        ('listbar', 'light cyan,bold', 'default'),\n        ('selected', 'black', 'light gray'),\n\n        # footer\n        ('foot', 'dark cyan', 'dark blue', 'bold'),\n        ('key', 'light cyan', 'dark blue', 'underline'),\n\n        # status\n        ('connected', 'dark green', ''),\n        ('connected selected', 'black', 'dark green'),\n\n        # progressbar\n        ('pg normal', 'white', 'black', 'standout'),\n        ('pg complete', 'white', 'dark magenta'),\n        ('pg smooth', 'dark magenta', 'black'),\n\n        ('caption', 'yellow,bold', 'dark cyan'),\n        ('prompt', 'white', 'dark cyan'),\n        ('dialog', 'white', 'dark cyan'),\n        ('button', 'white', 'dark cyan'),\n        ('button selected', 'white', 'dark cyan'),\n    ]\n\n    header_text = ('header', [\n        \"Xbox Smartglass\"\n    ])\n\n    footer_main_text = ('foot', [\n        ('key', 'R:'), \"reload  \",\n        ('key', 'C:'), \"connect \",\n        ('key', 'D:'), \"disconnect \",\n        ('key', 'P:'), \"poweron \",\n        ('key', 'L:'), \"view log \",\n        ('key', 'Q:'), \"quit  \"\n    ])\n\n    footer_console_text = ('foot', [\n        ('key', 'C:'), \"commands \",\n        ('key', 'L:'), \"view log \",\n        ('key', 'Q:'), \"quit \"\n    ])\n\n    footer_log_text = ('foot', [\n        ('key', 'ENTER:'), \"show details \",\n        ('key', 'Q:'), \"quit \"\n    ])\n\n    log_fmt = logging.Formatter(logging.BASIC_FORMAT)\n    log_level = logging.DEBUG\n\n    def __init__(self, consoles: List[Console], auth_mgr: AuthenticationManager):\n        self.header = urwid.AttrMap(urwid.Text(self.header_text), 'header')\n        footer = urwid.AttrMap(urwid.Text(self.footer_main_text), 'foot')\n\n        self.running = False\n        self.loop = None\n        self.consoles = ConsoleList(self, consoles, self.header, footer)\n        self.auth_mgr = auth_mgr\n        self.log = LogListBox(self)\n\n        self.view_stack = []\n\n    def push_view(self, sender, view):\n        self.view_stack.append(view)\n        self.loop.widget = view\n        self.loop.draw_screen()\n\n    def pop_view(self, sender):\n        if len(self.view_stack) > 1:\n            top_widget = self.view_stack.pop()\n            if hasattr(top_widget, 'close_view'):\n                top_widget.close_view(sender)\n\n            self.loop.widget = self.view_stack[-1]\n            self.loop.draw_screen()\n        else:\n            self.do_quit()\n\n    def view_main_menu(self):\n        self.push_view(self, self.consoles)\n\n    def view_details_menu(self, console):\n        footer = urwid.AttrMap(urwid.Text(self.footer_console_text), 'foot')\n        frame = ConsoleView(self, console, header=self.header, footer=footer)\n        self.push_view(self, frame)\n\n    def view_commands_menu(self, console):\n        bottom = self.view_stack[-1]\n        commands = urwid.ListBox(CommandList(self, console))\n        top = urwid.LineBox(commands, 'Commands')\n        overlay = urwid.Overlay(top, bottom, 'center', ('relative', 25), 'middle', ('relative', 75))\n        self.push_view(self, overlay)\n\n    def view_controller_remote_overlay(self, console):\n        self.return_to_details_menu()\n        bottom = self.view_stack[-1]\n        edit = urwid.Edit('Press Q to quit\\n'\n                          'View: <tab>, Menu: <, Nexus: #\\n'\n                          'DPad: <Arrow keys>, Button: A-B-X-Y\\n')\n        view = ControllerRemote(self, console, edit)\n        top = urwid.LineBox(view, title='Controller Remote')\n        overlay = urwid.Overlay(top, bottom,\n                                'center', ('relative', 25), 'middle', ('relative', 25))\n        self.push_view(self, overlay)\n\n    def view_text_input_overlay(self, console):\n        self.return_to_details_menu()\n        bottom = self.view_stack[-1]\n        edit = urwid.Edit('Enter text\\n'\n                          'Press ENTER to send\\n')\n        view = TextInput(self, edit, console)\n        top = urwid.LineBox(view, title='SystemText Session')\n        overlay = urwid.Overlay(top, bottom,\n                                'center', ('relative', 25), 'middle', ('relative', 25))\n        self.push_view(self, overlay)\n\n    def view_launch_title_textbox(self, callback):\n        self.return_to_details_menu()\n        bottom = self.view_stack[-1]\n        edit = urwid.Edit('Press ENTER to send uri\\n')\n        question_box = QuestionBox(edit, callback)\n\n        top = urwid.LineBox(question_box, title='Enter launch uri')\n        overlay = urwid.Overlay(top, bottom,\n                                'center', ('relative', 25), 'middle', ('relative', 25))\n        self.push_view(self, overlay)\n\n    def view_msgbox(self, msg, title='Error', width=25, height=75):\n        bottom = self.view_stack[-1]\n        text = urwid.Text(msg)\n        button = urwid.Button('OK')\n        button._label.align = 'center'\n        pad_button = urwid.Padding(button, 'center', ('relative', width * 2))\n        pile = urwid.Pile([text, pad_button])\n        box = urwid.LineBox(pile, title)\n        top = urwid.Filler(box, 'top')\n        overlay = urwid.Overlay(top, bottom, 'center', ('relative', width), 'middle', ('relative', height))\n        urwid.connect_signal(button, 'click', lambda _: self.pop_view(self))\n        self.push_view(self, overlay)\n\n    def view_scrollable_overlay(self, msg, title='Error', width=25, height=75):\n        bottom = self.view_stack[-1]\n        walker = urwid.SimpleFocusListWalker([urwid.Text(l) for l in msg.split('\\n')])\n        text = urwid.ListBox(walker)\n        line = urwid.LineBox(text, title)\n        overlay = urwid.Overlay(line, bottom, 'center', ('relative', width), 'middle', ('relative', height))\n        self.push_view(self, overlay)\n\n    def view_log(self):\n        header = urwid.AttrMap(urwid.Text(self.header_text), 'header')\n        footer = urwid.AttrMap(urwid.Text(self.footer_log_text), 'foot')\n        frame = urwid.Frame(self.log, header=header, footer=footer)\n        self.push_view(self, frame)\n\n    def return_to_main_menu(self):\n        while len(self.view_stack) > 1:\n            self.pop_view(self)\n\n    def return_to_details_menu(self):\n        while len(self.view_stack) > 2:\n            self.pop_view(self)\n\n    def do_quit(self):\n        self.running = False\n        self.loop.stop()\n\n    async def run(self, loop):\n        eventloop = urwid.AsyncioEventLoop(loop=loop)\n        self.loop = urwid.MainLoop(\n            urwid.SolidFill('xq'),\n            handle_mouse=False,\n            palette=self.palette,\n            unhandled_input=self.unhandled_input,\n            event_loop=eventloop\n        )\n        self.loop.set_alarm_in(0.0001, lambda *args: self.view_main_menu())\n\n        self.loop.start()\n        self.running = True\n        await self.consoles.refresh()\n\n        while self.running:\n            await asyncio.sleep(1000)\n\n    def unhandled_input(self, input):\n        if input in ('q', 'Q', 'esc'):\n            self.pop_view(self)\n        elif input in ('l', 'L'):\n            self.view_log()\n\ndef load_consoles(filepath: str) -> List[Console]:\n    try:\n        with open(filepath, 'r') as fh:\n            consoles = json.load(fh)\n        return [Console.from_dict(c) for c in consoles]\n    except FileNotFoundError:\n        return []\n\n\ndef save_consoles(filepath: str, consoles: List[Console]) -> None:\n    consoles = [c.to_dict() for c in consoles]\n    with open(filepath, 'w') as fh:\n        json.dump(consoles, fh, indent=2)\n\n\nasync def run_tui(\n    loop: asyncio.AbstractEventLoop,\n    consoles_filepath: str,\n    auth_mgr: Optional[AuthenticationManager] = None\n) -> int:\n    \"\"\"\n    Main entrypoint for TUI\n\n    Args:\n        loop: Eventloop\n        consoles_filepath: Console json filepath\n        auth_mgr: Authentication manager\n\n    Returns: Exit code\n    \"\"\"\n    consoles = load_consoles(consoles_filepath) if consoles_filepath else []\n\n    app = SGDisplay(consoles, auth_mgr)\n    await app.run(loop)\n\n    if consoles_filepath:\n        save_consoles(consoles_filepath, app.consoles.consoles)\n\n    return ExitCodes.OK"}
{"type": "source_file", "path": "xbox/auxiliary/packer.py", "content": "from typing import List\n\nfrom xbox.auxiliary.crypto import AuxiliaryStreamCrypto\nfrom xbox.sg.crypto import PKCS7Padding\nfrom xbox.auxiliary.packet import aux_header_struct, AUX_PACKET_MAGIC\n\n\nclass AuxiliaryPackerException(Exception):\n    pass\n\n\ndef pack(\n    data: bytes,\n    crypto: AuxiliaryStreamCrypto,\n    server_data: bool = False\n) -> List[bytes]:\n    \"\"\"\n    Encrypt auxiliary data blob\n\n    Args:\n        data: Data\n        crypto: Crypto context\n        server_data: Whether to encrypt with `server IV`\n\n    Returns:\n        bytes: Encrypted message\n    \"\"\"\n    # Store payload size without padding\n    payload_size = len(data)\n\n    # Pad data\n    padded = PKCS7Padding.pad(data, 16)\n\n    if not server_data:\n        ciphertext = crypto.encrypt(padded)\n    else:\n        ciphertext = crypto.encrypt_server(padded)\n\n    header = aux_header_struct.build(dict(\n        magic=AUX_PACKET_MAGIC,\n        payload_size=payload_size)\n    )\n\n    msg = header + ciphertext\n    hmac = crypto.hash(msg)\n    msg += hmac\n\n    messages = list()\n    while len(msg) > 1448:\n        fragment, msg = msg[:1448], msg[1448:]\n        messages.append(fragment)\n\n    messages.append(msg)\n\n    return messages\n\n\ndef unpack(\n    data: bytes,\n    crypto: AuxiliaryStreamCrypto,\n    client_data: bool = False\n) -> bytes:\n    \"\"\"\n    Split and decrypt auxiliary data blob\n\n    Args:\n        data: Data blob\n        crypto: Crypto context\n        client_data: Whether to decrypt with 'client IV'\n\n    Returns:\n        bytes: Decrypted message\n    \"\"\"\n    # Split header from rest of data\n    header, payload, hmac = data[:4], data[4:-32], data[-32:]\n\n    parsed = aux_header_struct.parse(header)\n\n    if not crypto.verify(header + payload, hmac):\n        raise AuxiliaryPackerException('Hash verification failed')\n\n    if not client_data:\n        plaintext = crypto.decrypt(payload)\n    else:\n        plaintext = crypto.decrypt_client(payload)\n\n    # Cut off padding, before returning\n    return plaintext[:parsed.payload_size]\n"}
{"type": "source_file", "path": "xbox/rest/__init__.py", "content": "SMARTGLASS_PACKAGENAMES = [\n    'xbox-smartglass-core',\n    'xbox-smartglass-nano',\n    'xbox-webapi'\n]"}
{"type": "source_file", "path": "xbox/auxiliary/packet.py", "content": "from construct import Struct, Int16ub\n\nAUX_PACKET_MAGIC = 0xDEAD\n\naux_header_struct = Struct(\n    'magic' / Int16ub,\n    'payload_size' / Int16ub\n    # payload\n    # hash\n)\n"}
{"type": "source_file", "path": "xbox/handlers/__init__.py", "content": "\"\"\"\nCLI script handlers\n\"\"\"\n"}
{"type": "source_file", "path": "xbox/rest/schemas/__init__.py", "content": "from .root import IndexResponse\nfrom .general import GeneralResponse\nfrom .auth import AuthenticationStatus, AuthSessionConfig\n\nfrom .device import (\n    ConsoleStatusResponse,\n    DeviceStatusResponse,\n    MediaStateResponse,\n    InfraredResponse,\n    InfraredDevice,\n    InfraredButton,\n    MediaCommandsResponse,\n    TextSessionActiveResponse,\n    InputResponse\n)"}
{"type": "source_file", "path": "xbox/scripts/main_cli.py", "content": "\"\"\"\nMain smartglass client\n\nCommon script that handles several subcommands\nSee `Commands`\n\"\"\"\nimport os\nimport sys\nimport logging\nimport argparse\nimport functools\nimport asyncio\nimport aioconsole\nimport aiohttp\n\nfrom typing import List\nfrom logging.handlers import RotatingFileHandler\n\nfrom xbox.webapi.authentication.models import OAuth2TokenResponse\n\nfrom xbox.scripts import TOKENS_FILE, CONSOLES_FILE, LOG_FMT, \\\n    LOG_LEVEL_DEBUG_INCL_PACKETS, VerboseFormatter, ExitCodes\n\nfrom xbox.handlers import tui, gamepad_input, text_input, fallout4_relay\nfrom xbox.auxiliary.manager import TitleManager\n\nfrom xbox.webapi.scripts import CLIENT_ID, CLIENT_SECRET, REDIRECT_URI\nfrom xbox.webapi.authentication.manager import AuthenticationManager\nfrom xbox.webapi.common.exceptions import AuthenticationException\n\nfrom xbox.sg import manager\nfrom xbox.sg.console import Console\nfrom xbox.sg.enum import ConnectionState\n\n\nLOGGER = logging.getLogger(__name__)\n\nREPL_DEFAULT_SERVER_PORT = 5558\n\n\nclass Commands(object):\n    \"\"\"\n    Available commands for CLI\n    \"\"\"\n    Discover = 'discover'\n    PowerOn = 'poweron'\n    PowerOff = 'poweroff'\n    REPL = 'repl'\n    REPLServer = 'replserver'\n    FalloutRelay = 'forelay'\n    GamepadInput = 'gamepadinput'\n    TextInput = 'textinput'\n    TUI = 'tui'\n\n\ndef parse_arguments(args: List[str] = None):\n    \"\"\"\n    Parse arguments with argparse.ArgumentParser\n\n    Args:\n        args: List of arguments from cmdline\n\n    Returns: Parsed arguments\n\n    Raises:\n        Exception: On generic failure\n    \"\"\"\n\n    parser = argparse.ArgumentParser(description='Xbox SmartGlass client')\n\n    \"\"\"Common arguments for logging\"\"\"\n    logging_args = argparse.ArgumentParser(add_help=False)\n    logging_args.add_argument(\n        '--logfile',\n        help=\"Path for logfile\")\n    logging_args.add_argument(\n        '-v', '--verbose', action='count', default=0,\n        help='Set logging level\\n'\n             '(  -v: INFO,\\n'\n             ' -vv: DEBUG,\\n'\n             '-vvv: DEBUG_INCL_PACKETS)')\n\n    \"\"\"Common arguments for authenticated console connection\"\"\"\n    xbl_token_args = argparse.ArgumentParser(add_help=False)\n    xbl_token_args.add_argument(\n        '--tokens', '-t', type=str, default=TOKENS_FILE,\n        help='Tokenfile to load')\n    xbl_token_args.add_argument(\n        \"--client-id\",\n        \"-cid\",\n        default=os.environ.get(\"CLIENT_ID\", CLIENT_ID),\n        help=\"OAuth2 Client ID\",\n    )\n    xbl_token_args.add_argument(\n        \"--client-secret\",\n        \"-cs\",\n        default=os.environ.get(\"CLIENT_SECRET\", CLIENT_SECRET),\n        help=\"OAuth2 Client Secret\",\n    )\n    xbl_token_args.add_argument(\n        \"--redirect-uri\",\n        \"-ru\",\n        default=os.environ.get(\"REDIRECT_URI\", REDIRECT_URI),\n        help=\"OAuth2 Redirect URI\",\n    )\n    xbl_token_args.add_argument(\n        '--refresh', '-r', action='store_true',\n        help=\"Refresh xbox live tokens in provided token file\")\n\n    \"\"\"Common argument for console connection\"\"\"\n    connection_arg = argparse.ArgumentParser(add_help=False)\n    connection_arg.add_argument(\n        '--address', '-a', type=str, default=None,\n        help=\"IP address of console\")\n    connection_arg.add_argument(\n        '--liveid', '-l',\n        help='LiveID to poweron')\n\n    \"\"\"Common argument for interactively choosing console to handle\"\"\"\n    interactive_arg = argparse.ArgumentParser(add_help=False)\n    interactive_arg.add_argument(\n        '--interactive', '-i', action='store_true',\n        help=\"Interactively choose console to connect to\")\n\n    \"\"\"\n    Define commands\n    \"\"\"\n    subparsers = parser.add_subparsers(help='Available commands')\n    # NOTE: Setting dest and required here for py3.6 compat\n    subparsers.dest = 'command'\n    subparsers.required = True\n\n    \"\"\"Discover\"\"\"\n    subparsers.add_parser(Commands.Discover,\n                          help='Discover console',\n                          parents=[logging_args,\n                                   connection_arg])\n\n    \"\"\"Power on\"\"\"\n    subparsers.add_parser(\n        Commands.PowerOn,\n        help='Power on console',\n        parents=[logging_args, connection_arg])\n\n    \"\"\"Power off\"\"\"\n    poweroff_cmd = subparsers.add_parser(\n        Commands.PowerOff,\n        help='Power off console',\n        parents=[logging_args, xbl_token_args,\n                 interactive_arg, connection_arg])\n    poweroff_cmd.add_argument(\n        '--all', action='store_true',\n        help=\"Power off all consoles\")\n\n    \"\"\"Local REPL\"\"\"\n    subparsers.add_parser(\n        Commands.REPL,\n        help='Local REPL (interactive console)',\n        parents=[logging_args, xbl_token_args,\n                 interactive_arg, connection_arg])\n\n    \"\"\"REPL server\"\"\"\n    repl_server_cmd = subparsers.add_parser(\n        Commands.REPLServer,\n        help='REPL server (interactive console)',\n        parents=[logging_args, xbl_token_args,\n                 interactive_arg, connection_arg])\n    repl_server_cmd.add_argument(\n        '--bind', '-b', default='127.0.0.1',\n        help='Interface address to bind the server')\n    repl_server_cmd.add_argument(\n        '--port', '-p', type=int, default=REPL_DEFAULT_SERVER_PORT,\n        help=f'Port to bind to, default: {REPL_DEFAULT_SERVER_PORT}')\n\n    \"\"\"Fallout relay\"\"\"\n    subparsers.add_parser(\n        Commands.FalloutRelay,\n        help='Fallout 4 Pip boy relay',\n        parents=[logging_args, xbl_token_args,\n                 interactive_arg, connection_arg])\n\n    \"\"\"Controller input\"\"\"\n    subparsers.add_parser(\n        Commands.GamepadInput,\n        help='Send controller input to dashboard / apps',\n        parents=[logging_args, xbl_token_args,\n                 interactive_arg, connection_arg])\n\n    \"\"\"Text input\"\"\"\n    subparsers.add_parser(\n        Commands.TextInput,\n        help='Client to use Text input functionality',\n        parents=[logging_args, xbl_token_args,\n                 interactive_arg, connection_arg])\n\n    tui_cmd = subparsers.add_parser(\n        Commands.TUI,\n        help='TUI client - fancy :)',\n        parents=[logging_args, xbl_token_args,\n                 connection_arg])\n    tui_cmd.add_argument(\n        '--consoles', '-c', default=CONSOLES_FILE,\n        help=\"Previously discovered consoles (json)\")\n\n    return parser.parse_args(args)\n\n\ndef handle_logging_setup(args: argparse.Namespace) -> None:\n    \"\"\"\n    Determine log level, logfile and special DEBUG_INCL_PACKETS\n    via cmdline arguments.\n\n    Args:\n        args: ArgumentParser `Namespace`\n\n    Returns:\n         None\n    \"\"\"\n    levels = [logging.WARNING, logging.INFO, logging.DEBUG, LOG_LEVEL_DEBUG_INCL_PACKETS]\n    # Output level capped to number of levels\n    log_level = levels[min(len(levels) - 1, args.verbose)]\n    logging.basicConfig(level=log_level, format=LOG_FMT)\n    logging.root.info('Set Loglevel: {0}'\n                      .format(logging.getLevelName(log_level)))\n\n    if log_level == LOG_LEVEL_DEBUG_INCL_PACKETS:\n        logging.root.info('Removing previous logging StreamHandlers')\n        while len(logging.root.handlers):\n            del logging.root.handlers[0]\n\n        logging.root.info('Using DEBUG_INCL_PACKETS logging')\n        debugext_handler = logging.StreamHandler()\n        debugext_handler.setFormatter(VerboseFormatter(LOG_FMT))\n        logging.root.addHandler(debugext_handler)\n\n    if args.logfile:\n        logging.root.info('Set Logfile path: {0}'.format(args.logfile))\n        file_handler = RotatingFileHandler(args.logfile, backupCount=2)\n        file_handler.setLevel(log_level)\n        file_handler.setFormatter(logging.Formatter(LOG_FMT))\n        logging.root.addHandler(file_handler)\n\n\nasync def do_authentication(args: argparse.Namespace) -> AuthenticationManager:\n    \"\"\"\n    Shortcut for doing xbox live authentication (uses xbox-webapi-python lib).\n\n    Args:\n        args: Parsed arguments\n\n    Returns: An authenticated instance of AuthenticationManager\n\n    Raises:\n        AuthenticationException: If authentication failed\n    \"\"\"\n    async with aiohttp.ClientSession() as session:\n        auth_mgr = AuthenticationManager(\n            session, args.client_id, args.client_secret, args.redirect_uri\n        )\n\n        # Refresh tokens if we have them\n        if os.path.exists(args.tokens):\n            with open(args.tokens, mode=\"r\") as f:\n                tokens = f.read()\n            auth_mgr.oauth = OAuth2TokenResponse.parse_raw(tokens)\n            await auth_mgr.refresh_tokens()\n\n        # Request new ones if they are not valid\n        if not (auth_mgr.xsts_token and auth_mgr.xsts_token.is_valid()):\n            auth_url = auth_mgr.generate_authorization_url()\n            print(f'Authorize with following URL: {auth_url}\\n')\n\n            code = input('Enter received authorization code: ')\n            await auth_mgr.request_tokens(code)\n\n        with open(args.tokens, mode=\"w\") as f:\n            f.write(auth_mgr.oauth.json())\n\n    return auth_mgr\n\n\ndef choose_console_interactively(console_list: List[Console]):\n    \"\"\"\n    Choose a console to use via user-input\n\n    Args:\n        console_list (list): List of consoles to choose from\n\n    Returns:\n        None if choice was aborted, a desired console object otherwise\n    \"\"\"\n    entry_count = len(console_list)\n    LOGGER.debug('Offering console choices: {0}'.format(entry_count))\n\n    print('Discovered consoles:')\n    for idx, console in enumerate(console_list):\n        print('  {0}: {1} {2} {3}'\n              .format(idx, console.name, console.liveid, console.address))\n\n    print('Enter \\'x\\' to abort')\n\n    choices = [str(i) for i in range(entry_count)]\n    choices.append('e')\n\n    response = ''\n    while response not in choices:\n        response = input('Make your choice: ')\n        if response == 'e':\n            return None\n\n    return console_list[int(response)]\n\n\nasync def cli_discover_consoles(args: argparse.Namespace) -> List[Console]:\n    \"\"\"\n    Discover consoles\n    \"\"\"\n    LOGGER.info(f'Sending discovery packets to IP: {args.address}')\n    discovered = await Console.discover(addr=args.address, timeout=1)\n\n    if not len(discovered):\n        LOGGER.error('No consoles discovered')\n        sys.exit(ExitCodes.DiscoveryError)\n\n    LOGGER.info('Discovered consoles ({0}): {1}'\n                .format(len(discovered), ', '.join([str(c) for c in discovered])))\n\n    if args.liveid:\n        LOGGER.info('Filtering discovered consoles for LIVEID: {0}'\n                    .format(args.liveid))\n        discovered = [c for c in discovered if c.liveid == args.liveid]\n    if args.address:\n        LOGGER.info('Filtering discovered consoles for IP address: {0}'\n                    .format(args.address))\n        discovered = [c for c in discovered if c.address == args.address]\n\n    return discovered\n\n\nasync def main_async(loop: asyncio.AbstractEventLoop, command: Commands = None) -> ExitCodes:\n    \"\"\"\n    Async Main entrypoint\n\n    Args:\n        command (Commands):\n\n    Returns:\n         None\n    \"\"\"\n    auth_manager: AuthenticationManager = None\n\n    if command:\n        # Take passed command and append actual cmdline\n        cmdline_arguments = sys.argv[1:]\n        cmdline_arguments.insert(0, command)\n    else:\n        cmdline_arguments = None\n\n    args = parse_arguments(cmdline_arguments)\n    handle_logging_setup(args)\n\n    LOGGER.debug('Parsed arguments: {0}'.format(args))\n\n    command = args.command\n    LOGGER.debug('Chosen command: {0}'.format(command))\n\n    if 'interactive' in args and args.interactive and \\\n         (args.address or args.liveid):\n        LOGGER.error('Flag \\'--interactive\\' is incompatible with'\n                     ' providing an IP address (--address) or LiveID (--liveid) explicitly')\n        sys.exit(ExitCodes.ArgParsingError)\n    elif args.liveid and args.address:\n        LOGGER.warning('You passed --address AND --liveid: Will only use that specific'\n                       'combination!')\n    elif command == Commands.PowerOff and args.all and (args.liveid or args.address):\n        LOGGER.error('Poweroff with --all flag + explicitly provided LiveID / IP address makes no sense')\n        sys.exit(ExitCodes.ArgParsingError)\n    elif command == Commands.PowerOff and args.interactive and args.all:\n        LOGGER.error('Combining args --all and --interactive not supported')\n        sys.exit(ExitCodes.ArgParsingError)\n\n    print('Xbox SmartGlass main client started')\n\n    if 'tokens' in args:\n        \"\"\"\n        Do Xbox live authentication\n        \"\"\"\n        LOGGER.debug('Command {0} supports authenticated connection'.format(command))\n        print('Authenticating...')\n        try:\n            auth_manager = await do_authentication(args)\n        except AuthenticationException:\n            LOGGER.exception('Authentication failed!')\n            LOGGER.error(\"Please re-run xbox-authenticate to get a fresh set\")\n            sys.exit(ExitCodes.AuthenticationError)\n        print('Authentication done')\n\n    if command == Commands.TUI:\n        \"\"\"\n        Text user interface (powered by urwid)\n        \"\"\"\n        # Removing stream handlers to not pollute TUI\n        for h in [sh for sh in logging.root.handlers\n                  if isinstance(sh, logging.StreamHandler)]:\n            LOGGER.debug('Removing StreamHandler {0} from root logger'.format(h))\n            logging.root.removeHandler(h)\n\n        await tui.run_tui(loop, args.consoles, auth_manager)\n        return ExitCodes.OK\n\n    elif command == Commands.PowerOn:\n        \"\"\"\n        Powering up console\n        \"\"\"\n        if not args.liveid:\n            LOGGER.error('No LiveID (--liveid) provided for power on!')\n            sys.exit(ExitCodes.ArgParsingError)\n\n        LOGGER.info('Sending poweron packet for LiveId: {0} to {1}'\n                    .format(args.liveid,\n                            'IP: ' + args.address if args.address else 'MULTICAST'))\n        await Console.power_on(args.liveid, args.address, tries=10)\n        sys.exit(0)\n\n    \"\"\"\n    Discovery\n    \"\"\"\n    discovered = await cli_discover_consoles(args)\n\n    if command == Commands.Discover:\n        \"\"\"\n        Simply print discovered consoles\n        \"\"\"\n        print(\"Discovered %d consoles: \" % len(discovered))\n        for console in discovered:\n            print(\"  %s\" % console)\n        sys.exit(ExitCodes.OK)\n\n    elif command == Commands.PowerOff and args.all:\n        \"\"\"\n        Early call for poweroff --all\n        \"\"\"\n        \"\"\"Powering off all discovered consoles\"\"\"\n        for c in discovered:\n            print('Powering off console {0}'.format(c))\n            await c.power_off()\n        sys.exit(ExitCodes.OK)\n\n    \"\"\"\n    Choosing/filtering a console from the discovered ones\n    \"\"\"\n    console = None\n    if args.interactive:\n        LOGGER.debug('Starting interactive console choice')\n        console = choose_console_interactively(discovered)\n    elif len(discovered) == 1:\n        LOGGER.debug('Choosing sole console, no user interaction required')\n        console = discovered[0]\n    elif len(discovered) > 1:\n        LOGGER.error(\n            'More than one console was discovered and no exact'\n            ' connection parameters were provided')\n\n    if not console:\n        LOGGER.error('Choosing a console failed!')\n        sys.exit(ExitCodes.ConsoleChoice)\n\n    LOGGER.info('Choosen target console: {0}'.format(console))\n\n    LOGGER.debug('Setting console callbacks')\n    console.on_device_status += \\\n        lambda x: LOGGER.info('Device status: {0}'.format(x))\n    console.on_connection_state += \\\n        lambda x: LOGGER.info('Connection state: {0}'.format(x))\n    console.on_pairing_state += \\\n        lambda x: LOGGER.info('Pairing state: {0}'.format(x))\n    console.on_console_status += \\\n        lambda x: LOGGER.info('Console status: {0}'.format(x))\n    console.on_timeout += \\\n        lambda x: LOGGER.error('Timeout occured!') or sys.exit(1)\n\n    userhash = ''\n    xsts_token = ''\n    \n    if auth_manager:\n        userhash = auth_manager.xsts_token.userhash\n        xsts_token = auth_manager.xsts_token.token\n\n        LOGGER.debug('Authentication info:')\n        LOGGER.debug('Userhash: {0}'.format(userhash))\n        LOGGER.debug('XToken: {0}'.format(xsts_token))\n    else:\n        LOGGER.info('Running in anonymous mode')\n\n    LOGGER.info('Attempting connection...')\n    state = await console.connect(userhash, xsts_token)\n    if state != ConnectionState.Connected:\n        LOGGER.error('Connection failed! Console: {0}'.format(console))\n        sys.exit(1)\n\n    # FIXME: Waiting explicitly\n    LOGGER.info('Connected to console: {0}'.format(console))\n    LOGGER.debug('Waiting a second before proceeding...')\n    await console.wait(1)\n\n    if command == Commands.PowerOff:\n        \"\"\"\n        Power off (single console)\n        \"\"\"\n        print('Powering off console {0}'.format(console))\n        await console.power_off()\n        sys.exit(ExitCodes.OK)\n\n    elif command == Commands.REPL or command == Commands.REPLServer:\n        banner = 'You are connected to the console @ {0}\\n'\\\n                 .format(console.address)\n        banner += 'Type in \\'console\\' to acccess the object\\n'\n        banner += 'Type in \\'exit()\\' to quit the application'\n\n        scope_vars = {'console': console}\n\n        if command == Commands.REPL:\n            LOGGER.info('Starting up local REPL console')\n            console = aioconsole.AsynchronousConsole(locals=scope_vars, loop=loop)\n            await console.interact(banner)\n\n        else:\n            startinfo = 'Starting up REPL server @ {0}:{1}'.format(args.bind, args.port)\n            print(startinfo)\n            LOGGER.info(startinfo)\n\n            server = await aioconsole.start_interactive_server(\n                host=args.bind, port=args.port, loop=loop)\n            await server\n\n    elif command == Commands.FalloutRelay:\n        \"\"\"\n        Fallout 4 relay\n        \"\"\"\n        print('Starting Fallout 4 relay service...')\n        console.add_manager(TitleManager)\n        console.title.on_connection_info += fallout4_relay.on_connection_info\n        await console.start_title_channel(\n            title_id=fallout4_relay.FALLOUT_TITLE_ID\n        )\n        print('Fallout 4 relay started')\n    elif command == Commands.GamepadInput:\n        \"\"\"\n        Gamepad input\n        \"\"\"\n        print('Starting gamepad input handler...')\n        console.add_manager(manager.InputManager)\n        await gamepad_input.input_loop(console)\n    elif command == Commands.TextInput:\n        \"\"\"\n        Text input\n        \"\"\"\n        print('Starting text input handler...')\n        console.add_manager(manager.TextManager)\n        console.text.on_systemtext_configuration += text_input.on_text_config\n        console.text.on_systemtext_input += functools.partial(text_input.on_text_input, console)\n        console.text.on_systemtext_done += text_input.on_text_done\n\n        while True:\n            try:\n                await asyncio.sleep(1)\n            except KeyboardInterrupt:\n                print('Quitting text input handler')\n                return ExitCodes.OK\n\n\ndef main(command: Commands = None):\n    LOGGER.debug('Entering main_async')\n    try:\n        loop = asyncio.get_event_loop()\n        loop.run_until_complete(main_async(loop, command))\n    except KeyboardInterrupt:\n        pass\n\n\ndef main_discover():\n    \"\"\"Entrypoint for discover script\"\"\"\n    main(Commands.Discover)\n\n\ndef main_poweron():\n    \"\"\"Entrypoint for poweron script\"\"\"\n    main(Commands.PowerOn)\n\n\ndef main_poweroff():\n    \"\"\"Entrypoint for poweroff script\"\"\"\n    main(Commands.PowerOff)\n\n\ndef main_repl():\n    \"\"\"Entrypoint for REPL script\"\"\"\n    main(Commands.REPL)\n\n\ndef main_replserver():\n    \"\"\"Entrypoint for REPL server script\"\"\"\n    main(Commands.REPLServer)\n\n\ndef main_falloutrelay():\n    \"\"\"Entrypoint for Fallout 4 relay script\"\"\"\n    main(Commands.FalloutRelay)\n\n\ndef main_textinput():\n    \"\"\"Entrypoint for Text input script\"\"\"\n    main(Commands.TextInput)\n\n\ndef main_gamepadinput():\n    \"\"\"Entrypoint for Gamepad input script\"\"\"\n    main(Commands.GamepadInput)\n\n\ndef main_tui():\n    \"\"\"Entrypoint for TUI script\"\"\"\n    main(Commands.TUI)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"type": "source_file", "path": "xbox/rest/routes/root.py", "content": "from fastapi import APIRouter\nfrom .. import schemas, SMARTGLASS_PACKAGENAMES\n\nrouter = APIRouter()\n\n\n@router.get('/', response_model=schemas.IndexResponse)\ndef get_index():\n    import pkg_resources\n\n    versions = {}\n    for name in SMARTGLASS_PACKAGENAMES:\n        try:\n            versions[name] = pkg_resources.get_distribution(name).version\n        except Exception:\n            versions[name] = None\n\n    return schemas.IndexResponse(\n        versions=versions,\n        doc_path='/docs'\n    )\n"}
{"type": "source_file", "path": "xbox/scripts/pcap.py", "content": "\"\"\"\nParse a pcap packet capture and show decrypted\npackets in a human-readable ways.\n\nRequires the shared secret for that smartglass-session.\n\"\"\"\nimport os\nimport shutil\nimport string\nimport textwrap\nimport argparse\nfrom binascii import unhexlify\n\nimport dpkt\n\nfrom xbox.sg import packer\nfrom xbox.sg.crypto import Crypto\nfrom xbox.sg.enum import PacketType\n\nfrom construct.lib import containers\ncontainers.setGlobalPrintFullStrings(True)\n\n\ndef packet_filter(filepath):\n    with open(filepath, 'rb') as fh:\n        for ts, buf in dpkt.pcap.Reader(fh):\n            eth = dpkt.ethernet.Ethernet(buf)\n\n            # Make sure the Ethernet data contains an IP packet\n            if not isinstance(eth.data, dpkt.ip.IP):\n                continue\n\n            ip = eth.data\n            if not isinstance(ip.data, dpkt.udp.UDP):\n                continue\n\n            udp = ip.data\n            if udp.sport != 5050 and udp.dport != 5050:\n                continue\n\n            is_client = udp.dport == 5050\n\n            yield(udp.data, is_client, ts)\n\n\ndef parse(pcap_filepath, crypto):\n    width = shutil.get_terminal_size().columns\n    col_width = width // 2 - 3\n    wrapper = textwrap.TextWrapper(col_width, replace_whitespace=False)\n\n    for packet, is_client, ts in packet_filter(pcap_filepath):\n        try:\n            msg = packer.unpack(packet, crypto)\n        except Exception as e:\n            print(\"Error: {}\".format(e))\n            continue\n\n        msg_type = msg.header.pkt_type\n        type_str = msg_type.name\n\n        if msg_type == PacketType.Message:\n            type_str = msg.header.flags.msg_type.name\n\n        direction = '>' if is_client else '<'\n        print(' {} '.format(type_str).center(width, direction))\n\n        lines = str(msg).split('\\n')\n        for line in lines:\n            line = wrapper.wrap(line)\n            for i in line:\n                if is_client:\n                    print('{0: <{1}}'.format(i, col_width), '')\n                else:\n                    print(' ' * col_width, '', '{0}'.format(i, col_width))\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Parse PCAP files and show SG sessions'\n    )\n    parser.add_argument('file', help='Path to PCAP')\n    parser.add_argument('secret', help='Expanded secret for this session.')\n    args = parser.parse_args()\n\n    secret = args.secret\n    if os.path.exists(secret):\n        # Assume a file containing the secret\n        with open(secret, 'rb') as fh:\n            secret = fh.read()\n\n        if all(chr(c) in string.hexdigits for c in secret):\n            secret = unhexlify(secret)\n    else:\n        secret = unhexlify(secret)\n\n    crypto = Crypto.from_shared_secret(secret)\n    parse(args.file, crypto)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"type": "source_file", "path": "xbox/sg/protocol.py", "content": "\"\"\"\nSmartglass protocol core\n\n**NOTE**: Should not be used directly, use :class:`.Console` !\n\"\"\"\n\nimport uuid\nimport json\nimport base64\nimport logging\n\nimport asyncio\nimport socket\n\nfrom typing import List, Optional, Tuple, Dict, Union\n\nfrom xbox.sg import factory, packer, crypto, console\nfrom xbox.sg.packet.message import message_structs\nfrom xbox.sg.enum import PacketType, ConnectionResult, DisconnectReason,\\\n    ServiceChannel, MessageType, AckStatus, SGResultCode, ActiveTitleLocation,\\\n    PairedIdentityState, PublicKeyType\nfrom xbox.sg.constants import WindowsClientInfo, AndroidClientInfo,\\\n    MessageTarget\nfrom xbox.sg.manager import MediaManager, InputManager, TextManager\nfrom xbox.sg.utils.events import Event\nfrom xbox.sg.utils.struct import XStruct\n\nLOGGER = logging.getLogger(__name__)\n\nPORT = 5050\nBROADCAST = '255.255.255.255'\nMULTICAST = '239.255.255.250'\n\nCHANNEL_MAP = {\n    ServiceChannel.SystemInput: MessageTarget.SystemInputUUID,\n    ServiceChannel.SystemInputTVRemote: MessageTarget.SystemInputTVRemoteUUID,\n    ServiceChannel.SystemMedia: MessageTarget.SystemMediaUUID,\n    ServiceChannel.SystemText: MessageTarget.SystemTextUUID,\n    ServiceChannel.SystemBroadcast: MessageTarget.SystemBroadcastUUID\n}\n\n\nclass ProtocolError(Exception):\n    \"\"\"\n    Exception thrown by CoreProtocol\n    \"\"\"\n    pass\n\n\nclass SmartglassProtocol(asyncio.DatagramProtocol):\n    HEARTBEAT_INTERVAL = 3.0\n\n    def __init__(\n        self,\n        address: Optional[str] = None,\n        crypto_instance: Optional[crypto.Crypto] = None\n    ):\n        \"\"\"\n        Instantiate Smartglass Protocol handler.\n\n        Args:\n            address: Address\n            crypto_instance: Crypto instance\n        \"\"\"\n        self.address = address\n        self._transport: Optional[asyncio.DatagramTransport] = None\n        self.crypto = crypto_instance\n\n        self._discovered = {}\n\n        self.target_participant_id = None\n        self.source_participant_id = None\n\n        self._pending: Dict[str, asyncio.Future] = {}\n        self._chl_mgr = ChannelManager()\n        self._seq_mgr = SequenceManager()\n        self._frg_mgr = FragmentManager()\n\n        self.on_timeout = Event()\n        self.on_discover = Event()\n        self.on_message = Event()\n        self.on_json = Event()\n\n        self.started = False\n\n    async def stop(self) -> None:\n        \"\"\"\n        Dummy\n        \"\"\"\n        pass\n\n    def connection_made(self, transport: asyncio.DatagramTransport) -> None:\n        self.started = True\n        self._transport = transport\n\n    def error_received(self, exc: OSError):\n        print('Error received:', exc.args)\n\n    def connection_lost(self, exc: Optional[Exception]):\n        print(\"Connection closed\")\n        self._transport.close()\n        self.started = False\n\n    async def send_message(\n        self,\n        msg,\n        channel=ServiceChannel.Core,\n        addr: Optional[str] = None,\n        blocking: bool = True,\n        timeout: int = 5,\n        retries: int = 3\n    ) -> Optional[XStruct]:\n        \"\"\"\n        Send message to console.\n\n        Packing and encryption happens here.\n\n        Args:\n            msg: Unassembled message to send\n            channel: Channel to send the message on,\n                           Enum member of `ServiceChannel`\n            addr: IP address of target console\n            blocking: If set and `msg` is `Message`-packet, wait for ack\n            timeout: Seconds to wait for ack, only useful if `blocking`\n                           is `True`\n            retries: Max retry count.\n\n        Returns: None\n\n        Raises:\n            ProtocolError: On failure\n        \"\"\"\n        if msg.header.pkt_type == PacketType.Message:\n            msg.header(\n                sequence_number=self._seq_mgr.next_sequence_num(),\n                target_participant_id=self.target_participant_id,\n                source_participant_id=self.source_participant_id,\n                channel_id=self._chl_mgr.get_channel_id(channel)\n            )\n\n        if self.crypto:\n            data = packer.pack(msg, self.crypto)\n        else:\n            data = packer.pack(msg)\n\n        if self.address:\n            addr = self.address\n\n        if not addr:\n            raise ProtocolError(\"No address specified in send_message\")\n        elif not data:\n            raise ProtocolError(\"No data\")\n\n        if msg.header.pkt_type == PacketType.Message \\\n                and msg.header.flags.need_ack and blocking:\n            LOGGER.debug(\n                \"Sending %s message on ServiceChannel %s to %s\",\n                msg.header.flags.msg_type.name, channel.name, addr,\n                extra={'_msg': msg}\n            )\n            seqn = msg.header.sequence_number\n            tries = 0\n            result = None\n\n            while tries < retries and not result:\n                if tries > 0:\n                    LOGGER.warning(\n                        f\"Message {msg.header.flags.msg_type.name} on \"\n                        f\"ServiceChannel {channel.name} to {addr} not ack'd \"\n                        f\"in time, attempt #{tries + 1}\",\n                        extra={'_msg': msg}\n                    )\n\n                await self._send(data, (addr, PORT))\n                result = await self._await_ack('ack_%i' % seqn, timeout)\n                tries += 1\n\n            if result:\n                return result\n\n            raise ProtocolError(\"Exceeded retries\")\n        elif msg.header.pkt_type == PacketType.ConnectRequest:\n            LOGGER.debug(\n                f\"Sending ConnectRequest to {addr}\", extra={'_msg': msg}\n            )\n\n        await self._send(data, (addr, PORT))\n\n    async def _send(self, data: bytes, target: Tuple[str, int]):\n        \"\"\"\n        Send data on the connected transport.\n\n        If addr is not provided, the target address that was used at the time\n        of instantiating the protocol is used.\n        (e.g. asyncio.create_datagram_endpoint in Console-class).\n\n        Args:\n            data: Data to send\n            target: Tuple of (ip_address, port)\n        \"\"\"\n        if self._transport:\n            self._transport.sendto(data, target)\n        else:\n            LOGGER.error('Transport not ready...')\n\n    def datagram_received(self, data: bytes, addr: str) -> None:\n        \"\"\"\n        Handle incoming smartglass packets\n\n        Args:\n            data: Raw packet\n            addr: IP address of sender\n\n        Returns: None\n        \"\"\"\n        try:\n            host, _ = addr\n\n            if self.crypto:\n                msg = packer.unpack(data, self.crypto)\n            else:\n                msg = packer.unpack(data)\n\n            if msg.header.pkt_type == PacketType.DiscoveryResponse:\n                LOGGER.debug(\n                    f\"Received DiscoverResponse from {host}\",\n                    extra={'_msg': msg}\n                )\n                self._discovered[host] = msg\n                self.on_discover(host, msg)\n\n            elif msg.header.pkt_type == PacketType.ConnectResponse:\n                LOGGER.debug(\n                    f\"Received ConnectResponse from {host}\",\n                    extra={'_msg': msg}\n                )\n                if 'connect' in self._pending:\n                    self._set_result('connect', msg)\n\n            elif msg.header.pkt_type == PacketType.Message:\n                channel = self._chl_mgr.get_channel(msg.header.channel_id)\n                message_info = msg.header.flags.msg_type.name\n\n                if msg.header.flags.is_fragment:\n                    message_info = 'MessageFragment ({0})'.format(message_info)\n\n                LOGGER.debug(\n                    \"Received %s message on ServiceChannel %s from %s\",\n                    message_info, channel.name, host, extra={'_msg': msg}\n                )\n                seq_num = msg.header.sequence_number\n                self._seq_mgr.add_received(seq_num)\n\n                if msg.header.flags.need_ack:\n                    asyncio.create_task(\n                        self.ack(\n                            [msg.header.sequence_number],\n                            [],\n                            ServiceChannel.Core\n                        )\n                    )\n\n                self._seq_mgr.low_watermark = seq_num\n\n                if msg.header.flags.is_fragment:\n                    sequence_begin = msg.protected_payload.sequence_begin\n                    sequence_end = msg.protected_payload.sequence_end\n                    fragment_payload = self._frg_mgr.reassemble_message(msg)\n                    if not fragment_payload:\n                        return\n\n                    msg(protected_payload=fragment_payload)\n                    LOGGER.debug(\"Assembled {0} (Seq {1}:{2})\".format(\n                        message_info, sequence_begin, sequence_end\n                    ), extra={'_msg': msg})\n\n                self._on_message(msg, channel)\n            else:\n                self._on_unk(msg)\n        except Exception:\n            LOGGER.exception(\"Exception in CoreProtocol datagram handler\")\n\n    @staticmethod\n    def _on_unk(msg) -> None:\n        LOGGER.error(f'Unhandled message: {msg}')\n\n    async def _await_ack(\n        self,\n        identifier: str,\n        timeout: int = 5\n    ) -> Optional[XStruct]:\n        \"\"\"\n        Wait for acknowledgement of message\n\n        Args:\n            identifier: Identifier of ack\n            timeout: Timeout in seconds\n\n        Returns:\n            :obj:`.Event`: Event\n        \"\"\"\n        fut = asyncio.Future()\n        self._pending[identifier] = fut\n\n        try:\n            await asyncio.wait_for(fut, timeout)\n            return fut.result()\n        except asyncio.TimeoutError:\n            return None\n\n    def _set_result(\n        self,\n        identifier: str,\n        result: Union[AckStatus, XStruct]\n    ) -> None:\n        \"\"\"\n        Called when an acknowledgement comes in, unblocks `_await_ack`\n\n        Args:\n            identifier: Identifier of ack\n            result: Ack status\n\n        Returns: None\n        \"\"\"\n        self._pending[identifier].set_result(result)\n        del self._pending[identifier]\n\n    async def _heartbeat_task(self) -> None:\n        \"\"\"\n        Task checking for console activity, firing `on_timeout`-event on\n        timeout.\n\n        Heartbeats are empty \"ack\" messages that are to be ack'd by the console\n\n        Returns:\n            None\n        \"\"\"\n        while self.started:\n            try:\n                await self.ack([], [], ServiceChannel.Core, need_ack=True)\n            except ProtocolError:\n                self.on_timeout()\n                self.connection_lost(TimeoutError())\n                break\n            await asyncio.sleep(self.HEARTBEAT_INTERVAL)\n\n    def _on_message(self, msg: XStruct, channel: ServiceChannel) -> None:\n        \"\"\"\n        Handle msg of type `Message`.\n\n        Args:\n            msg: Message\n            channel: Channel the message was received on\n\n        Returns: None\n        \"\"\"\n        msg_type = msg.header.flags.msg_type\n\n        # First run our internal handlers\n        if msg_type == MessageType.Ack:\n            self._on_ack(msg)\n\n        elif msg_type == MessageType.StartChannelResponse:\n            self._chl_mgr.handle_channel_start_response(msg)\n\n        elif msg_type == MessageType.Json:\n            self._on_json(msg, channel)\n\n        # Then our hooked handlers\n        self.on_message(msg, channel)\n\n    def _on_ack(self, msg: XStruct) -> None:\n        \"\"\"\n        Process acknowledgement message.\n\n        Args:\n            msg: Message\n\n        Returns: None\n        \"\"\"\n\n        for num in msg.protected_payload.processed_list:\n            identifier = 'ack_%i' % num\n            self._seq_mgr.add_processed(num)\n            if identifier in self._pending:\n                self._set_result(identifier, AckStatus.Processed)\n        for num in msg.protected_payload.rejected_list:\n            identifier = 'ack_%i' % num\n            self._seq_mgr.add_rejected(num)\n            if identifier in self._pending:\n                self._set_result(identifier, AckStatus.Rejected)\n\n    def _on_json(self, msg: XStruct, channel: ServiceChannel) -> None:\n        \"\"\"\n        Process json message.\n\n        Args:\n            msg: Message\n            channel: Channel the message was received on\n\n        Returns: None\n        \"\"\"\n        text = msg.protected_payload.text\n\n        if 'fragment_data' in text:\n            text = self._frg_mgr.reassemble_json(text)\n            if not text:\n                # Input message is a fragment, but cannot assemble full msg yet\n                return\n\n        self.on_json(text, channel)\n\n    async def discover(\n            self,\n            addr: str = None,\n            tries: int = 5,\n            blocking: bool = True,\n            timeout: int = 5\n    ) -> Dict[str, XStruct]:\n        \"\"\"\n        Discover consoles on the network\n\n        Args:\n            addr (str): IP address\n            tries (int): Discover attempts\n            blocking (bool): Wait a given time for responses, otherwise\n                             return immediately\n            timeout (int): Timeout in seconds (only if `blocking` is `True`)\n\n        Returns:\n            list: List of discovered consoles\n        \"\"\"\n        self._discovered = {}\n        msg = factory.discovery()\n\n        task = asyncio.create_task(self._discover(msg, addr, tries))\n\n        # Blocking for a discovery is different than connect or regular message\n        if blocking:\n            try:\n                await asyncio.wait_for(task, timeout)\n            except asyncio.TimeoutError:\n\n                pass\n\n        return self.discovered\n\n    async def _discover(\n        self,\n        msg,\n        addr: str,\n        tries: int\n    ) -> None:\n        for _ in range(tries):\n            await self.send_message(msg, addr=BROADCAST)\n            await self.send_message(msg, addr=MULTICAST)\n\n            if addr:\n                await self.send_message(msg, addr=addr)\n\n            await asyncio.sleep(0.5)\n\n    @property\n    def discovered(self) -> Dict[str, XStruct]:\n        \"\"\"\n        Return discovered consoles\n\n        Returns:\n            Discovered consoles\n        \"\"\"\n        return self._discovered\n\n    async def connect(\n        self,\n        userhash: str,\n        xsts_token: str,\n        client_uuid: uuid.UUID = uuid.uuid4(),\n        request_num: int = 0,\n        retries: int = 3\n    ) -> PairedIdentityState:\n        \"\"\"\n        Connect to console\n\n        Args:\n            userhash: Userhash from Xbox Live Authentication\n            xsts_token: XSTS Token from Xbox Live Authentication\n            client_uuid: Client UUID (default: Generate random uuid)\n            request_num: Request number\n            retries: Max. connect attempts\n\n        Returns: Pairing State\n\n        Raises:\n            ProtocolError: If connection fails\n        \"\"\"\n        if not self.crypto:\n            raise ProtocolError(\"No crypto\")\n\n        if isinstance(userhash, type(None)):\n            userhash = ''\n        if isinstance(xsts_token, type(None)):\n            xsts_token = ''\n\n        iv = self.crypto.generate_iv()\n        pubkey_type = self.crypto.pubkey_type\n        pubkey = self.crypto.pubkey_bytes\n\n        msg = factory.connect(\n            client_uuid, pubkey_type, pubkey, iv, userhash, xsts_token,\n            request_num, request_num, request_num + 1\n        )\n\n        payload_len = packer.payload_length(msg)\n        if payload_len < 1024:\n            messages = [msg]\n        else:\n            messages = _fragment_connect_request(\n                self.crypto, client_uuid, pubkey_type, pubkey,\n                userhash, xsts_token, request_num\n            )\n\n        tries = 0\n        result = None\n        while tries < retries and not result:\n            for m in messages:\n                await self.send_message(m)\n\n            result = await self._await_ack('connect')\n\n        if not result:\n            raise ProtocolError(\"Exceeded connect retries\")\n\n        connect_result = result.protected_payload.connect_result\n        if connect_result != ConnectionResult.Success:\n            raise ProtocolError(\n                \"Connecting failed! Result: %s\" % connect_result\n            )\n\n        self.target_participant_id = 0\n        self.source_participant_id = result.protected_payload.participant_id\n\n        await self.local_join()\n\n        for channel, target_uuid in CHANNEL_MAP.items():\n            await self.start_channel(channel, target_uuid)\n\n        asyncio.create_task(self._heartbeat_task())\n        return result.protected_payload.pairing_state\n\n    async def local_join(\n        self,\n        client_info: Union[WindowsClientInfo, AndroidClientInfo] = WindowsClientInfo,\n        **kwargs\n    ) -> None:\n        \"\"\"\n        Pair client with console.\n\n        Args:\n            client_info: Either `WindowsClientInfo` or `AndroidClientInfo`\n            **kwargs:\n\n        Returns: None\n        \"\"\"\n        msg = factory.local_join(client_info)\n        await self.send_message(msg, **kwargs)\n\n    async def start_channel(\n        self,\n        channel: ServiceChannel,\n        messagetarget_uuid: uuid.UUID,\n        title_id: int = 0,\n        activity_id: int = 0,\n        **kwargs\n    ) -> None:\n        \"\"\"\n        Request opening of specific ServiceChannel\n\n        Args:\n            channel: Channel to start\n            messagetarget_uuid: Message Target UUID\n            title_id: Title ID, Only used for ServiceChannel.Title\n            activity_id: Activity ID, unknown use-case\n            **kwargs: KwArgs\n\n        Returns: None\n        \"\"\"\n        request_id = self._chl_mgr.get_next_request_id(channel)\n        msg = factory.start_channel(\n            request_id, title_id, messagetarget_uuid, activity_id\n        )\n        await self.send_message(msg, **kwargs)\n\n    async def ack(\n        self,\n        processed: List[int],\n        rejected: List[int],\n        channel: ServiceChannel,\n        need_ack: bool = False\n    ) -> None:\n        \"\"\"\n        Acknowledge received messages that have `need_ack` flag set.\n\n        Args:\n            processed: Processed sequence numbers\n            rejected: Rejected sequence numbers\n            channel: Channel to send the ack on\n            need_ack: Whether we want this ack to be acknowledged by the target\n                      participant.\n                      Will be blocking if set.\n                      Required for heartbeat messages.\n\n        Returns: None\n        \"\"\"\n        low_watermark = self._seq_mgr.low_watermark\n        msg = factory.acknowledge(\n            low_watermark, processed, rejected, need_ack=need_ack\n        )\n        await self.send_message(msg, channel=channel, blocking=need_ack)\n\n    async def json(\n        self,\n        data: str,\n        channel: ServiceChannel\n    ) -> None:\n        \"\"\"\n        Send json message\n\n        Args:\n            data: JSON dict\n            channel: Channel to send the message to\n\n        Returns: None\n        \"\"\"\n        msg = factory.json(data)\n        await self.send_message(msg, channel=channel)\n\n    async def power_on(\n        self,\n        liveid: str,\n        addr: Optional[str] = None,\n        tries: int = 2\n    ) -> None:\n        \"\"\"\n        Power on console.\n\n        Args:\n            liveid: Live ID of console\n            addr: IP address of console\n            tries: PowerOn attempts\n\n        Returns: None\n        \"\"\"\n        msg = factory.power_on(liveid)\n\n        for i in range(tries):\n            await self.send_message(msg, addr=BROADCAST)\n            await self.send_message(msg, addr=MULTICAST)\n            if addr:\n                await self.send_message(msg, addr=addr)\n\n            await asyncio.sleep(0.1)\n\n    async def power_off(\n        self,\n        liveid: str\n    ) -> None:\n        \"\"\"\n        Power off console\n\n        Args:\n            liveid: Live ID of console\n\n        Returns: None\n        \"\"\"\n        msg = factory.power_off(liveid)\n        await self.send_message(msg)\n\n    async def disconnect(\n        self,\n        reason: DisconnectReason = DisconnectReason.Unspecified,\n        error: int = 0\n    ) -> None:\n        \"\"\"\n        Disconnect console session\n\n        Args:\n            reason: Disconnect reason\n            error: Error Code\n\n        Returns: None\n        \"\"\"\n        msg = factory.disconnect(reason, error)\n        await self.send_message(msg)\n\n    async def game_dvr_record(\n        self,\n        start_delta: int,\n        end_delta: int\n    ) -> AckStatus:\n        \"\"\"\n        Start Game DVR recording\n\n        Args:\n            start_delta: Start time\n            end_delta: End time\n\n        Returns: Acknowledgement status\n        \"\"\"\n        msg = factory.game_dvr_record(start_delta, end_delta)\n        return await self.send_message(msg)\n\n    async def launch_title(\n        self,\n        uri: str,\n        location: ActiveTitleLocation = ActiveTitleLocation.Full\n    ) -> AckStatus:\n        \"\"\"\n        Launch title via URI\n\n        Args:\n            uri: Uri string\n            location: Location\n\n        Returns: Ack status\n        \"\"\"\n        msg = factory.title_launch(location, uri)\n        return await self.send_message(msg)\n\n\nclass SequenceManager:\n    def __init__(self):\n        \"\"\"\n        Process received messages by sequence numbers.\n        Also add processed / rejected messages to a list.\n        Tracks the `Low Watermark` that's sent with\n        `Acknowledgement`-Messages too.\n        \"\"\"\n        self.processed = []\n        self.rejected = []\n        self.received = []\n\n        self._low_watermark = 0\n        self._sequence_num = 0\n\n    def add_received(self, sequence_num: int) -> None:\n        \"\"\"\n        Add received sequence number\n\n        Args:\n            sequence_num: Sequence number\n\n        Returns: None\n        \"\"\"\n        if sequence_num not in self.received:\n            self.received.append(sequence_num)\n\n    def add_processed(self, sequence_num: int) -> None:\n        \"\"\"\n        Add sequence number of message that was sent to console\n        and succeeded in processing.\n\n        Args:\n            sequence_num: Sequence number\n\n        Returns: None\n        \"\"\"\n        if sequence_num not in self.processed:\n            self.processed.append(sequence_num)\n\n    def add_rejected(self, sequence_num: int) -> None:\n        \"\"\"\n        Add sequence number of message that was sent to console\n        and was rejected by it.\n\n        Args:\n            sequence_num: Sequence number\n\n        Returns: None\n        \"\"\"\n        if sequence_num not in self.rejected:\n            self.rejected.append(sequence_num)\n\n    def next_sequence_num(self) -> int:\n        \"\"\"\n        Get next sequence number to use for outbound `Message`.\n\n        Returns: None\n        \"\"\"\n        self._sequence_num += 1\n        return self._sequence_num\n\n    @property\n    def low_watermark(self) -> int:\n        \"\"\"\n        Get current `Low Watermark`\n\n        Returns: Low Watermark\n        \"\"\"\n        return self._low_watermark\n\n    @low_watermark.setter\n    def low_watermark(self, value: int) -> None:\n        \"\"\"\n        Set `Low Watermark`\n\n        Args:\n            value: Last received sequence number from console\n\n        Returns: None\n        \"\"\"\n        if value > self._low_watermark:\n            self._low_watermark = value\n\n\nclass ChannelError(Exception):\n    \"\"\"\n    Exception thrown by :class:`ChannelManager`.\n    \"\"\"\n    pass\n\n\nclass ChannelManager:\n    CHANNEL_CORE = 0\n    CHANNEL_ACK = 0x1000000000000000\n\n    def __init__(self):\n        \"\"\"\n        Keep track of established ServiceChannels\n        \"\"\"\n        self._channel_mapping = {}\n        self._requests = {}\n        self._request_id = 0\n\n    def handle_channel_start_response(self, msg: XStruct) -> ServiceChannel:\n        \"\"\"\n        Handle message of type `StartChannelResponse`\n\n        Args:\n            msg: Start Channel Response message\n\n        Raises:\n            :class:`ChannelError`: If channel acquire failed\n\n        Returns: Acquired ServiceChannel\n        \"\"\"\n        # Find ServiceChannel by RequestId\n        request_id = msg.protected_payload.channel_request_id\n        channel = self._requests.get(request_id)\n\n        if not channel:\n            raise ChannelError(\"Request Id %d not found. Was the channel request saved?\" % request_id)\n\n        if msg.protected_payload.result != SGResultCode.SG_E_SUCCESS:\n            raise ChannelError(\"Acquiring ServiceChannel %s failed\" % channel.name)\n\n        # Save Channel Id for appropriate ServiceChannel\n        channel_id = msg.protected_payload.target_channel_id\n        self._channel_mapping[channel] = channel_id\n\n        self._requests.pop(request_id)\n        LOGGER.debug(\"Acquired ServiceChannel %s -> Channel: 0x%x\", channel.name, channel_id)\n        return channel\n\n    def get_next_request_id(self, channel: ServiceChannel) -> int:\n        \"\"\"\n        Get next Channel request id for ServiceChannel\n\n        Incremented on each call.\n\n        Args:\n            channel: Service channel\n\n        Returns: Channel request id\n        \"\"\"\n        # Clear old request for same ServiceChannel\n        self._requests = {key: val for key, val in self._requests.items()\n                          if val != channel}\n\n        self._request_id += 1\n        self._requests[self._request_id] = channel\n        return self._request_id\n\n    def get_channel(self, channel_id: int) -> ServiceChannel:\n        \"\"\"\n        Get matching ServiceChannel enum for provided Channel ID of `Message`\n\n        Args:\n            channel_id: Channel of Message\n\n        Returns: Service channel\n        \"\"\"\n        # Core and Ack are fixed, don't need mapping\n        if channel_id == self.CHANNEL_CORE:\n            return ServiceChannel.Core\n        elif channel_id == self.CHANNEL_ACK:\n            return ServiceChannel.Ack\n\n        for key, value in self._channel_mapping.items():\n            if value == channel_id:\n                return key\n        raise ChannelError(\"ServiceChannel not found for channel_id: 0x%x\"\n                           % channel_id)\n\n    def get_channel_id(self, channel: ServiceChannel) -> int:\n        \"\"\"\n        Get Channel ID for use in `Message` for provided ServiceChannel\n\n        Args:\n            channel: Service channel\n\n        Returns: Channel ID for use in `Message`\n        \"\"\"\n\n        # Core and Ack are fixed, don't need mapping\n        if channel == ServiceChannel.Core:\n            return self.CHANNEL_CORE\n        elif channel == ServiceChannel.Ack:\n            return self.CHANNEL_ACK\n\n        if channel not in self._channel_mapping:\n            raise ChannelError(\n                f\"Channel ID not found for ServiceChannel: {channel}\"\n            )\n        return self._channel_mapping[channel]\n\n    def reset(self) -> None:\n        \"\"\"\n        Erase the channels table\n\n        Returns:\n            None\n        \"\"\"\n        self._requests = {}\n        self._channel_mapping = {}\n        self._request_id = 0\n\n\nclass FragmentError(Exception):\n    \"\"\"\n    Exception thrown by :class:`FragmentManager`.\n    \"\"\"\n    pass\n\n\nclass FragmentManager:\n    \"\"\"\n    Assembles fragmented messages\n    \"\"\"\n    def __init__(self):\n        self.msg_queue = {}\n        self.json_queue = {}\n\n    def reassemble_message(self, msg: XStruct) -> Optional[XStruct]:\n        \"\"\"\n        Reassemble message fragment\n\n        Args:\n            msg: Message fragment\n\n        Returns: Reassembled / decoded payload on success,\n                `None` if payload is not ready or assembly failed.\n        \"\"\"\n        msg_type = msg.header.flags.msg_type\n        payload = msg.protected_payload\n        current_sequence = msg.header.sequence_number\n        sequence_begin = payload.sequence_begin\n        sequence_end = payload.sequence_end\n\n        self.msg_queue[current_sequence] = payload.data\n\n        wanted_sequences = list(range(sequence_begin, sequence_end))\n        assembled = b''\n        for s in wanted_sequences:\n            data = self.msg_queue.get(s)\n            if not data:\n                return\n\n            assembled += data\n\n        [self.msg_queue.pop(s) for s in wanted_sequences]\n\n        # Parse raw data with original message struct\n        struct = message_structs.get(msg_type)\n        if not struct:\n            raise FragmentError(\n                f'Failed to find message struct for fragmented {msg_type}'\n            )\n\n        return struct.parse(assembled)\n\n    def reassemble_json(self, json_msg: dict) -> Optional[dict]:\n        \"\"\"\n        Reassemble fragmented json message\n\n        Args:\n            json_msg: Fragmented json message\n\n        Returns: Reassembled / Decoded json object on success,\n                 `None` if datagram is not ready or assembly failed\n        \"\"\"\n        datagram_id, datagram_size =\\\n            int(json_msg['datagram_id']), int(json_msg['datagram_size'])\n        fragment_offset = int(json_msg['fragment_offset'])\n\n        fragments = self.json_queue.get(datagram_id)\n\n        if not fragments:\n            # Just add initial fragment\n            self.json_queue[datagram_id] = [json_msg]\n            return None\n\n        # It's a follow-up fragment\n        # Check if we already received this datagram\n        for entry in fragments:\n            if fragment_offset == int(entry['fragment_offset']):\n                return\n\n        # Append current fragment to datagram list\n        fragments.append(json_msg)\n\n        # Check if fragment can be assembled\n        # If so, assemble and pop the fragments from queue\n        if sum(int(f['fragment_length']) for f in fragments) == datagram_size:\n            sorted_fragments = sorted(\n                fragments, key=lambda f: int(f['fragment_offset'])\n            )\n\n            output = ''.join(f['fragment_data'] for f in sorted_fragments)\n\n            self.json_queue.pop(datagram_id)\n            return self._decode(output)\n\n        return None\n\n    @staticmethod\n    def _encode(obj: dict) -> str:\n        \"\"\"\n        Dump a dict as json string, then encode with base64\n\n        Args:\n            obj: Dict to encode\n\n        Returns: base64 encoded string\n        \"\"\"\n        bytestr = json.dumps(obj, separators=(',', ':'), sort_keys=True)\\\n            .encode('utf-8')\n        return base64.b64encode(bytestr).decode('utf-8')\n\n    @staticmethod\n    def _decode(data: str) -> dict:\n        \"\"\"\n        Decode a base64 encoded json object\n\n        Args:\n            data: Base64 string\n\n        Returns: Decoded json object\n        \"\"\"\n        return json.loads(base64.b64decode(data).decode('utf-8'))\n\n\ndef _fragment_connect_request(\n    crypto_instance: crypto.Crypto,\n    client_uuid: uuid.UUID,\n    pubkey_type: PublicKeyType,\n    pubkey: bytes,\n    userhash: str,\n    auth_token: str,\n    request_num: int = 0\n) -> List:\n    \"\"\"\n    Internal method to fragment ConnectRequest.\n\n    Args:\n        crypto_instance: Instance of :class:`Crypto`\n        client_uuid: Client UUID\n        pubkey_type Public Key Type\n        pubkey: Public Key\n        userhash: Xbox Live Account userhash\n        auth_token: Xbox Live Account authentication token (XSTS)\n        request_num: Request Number\n\n    Returns:\n        list: List of ConnectRequest fragments\n    \"\"\"\n    messages = []\n\n    # Calculate packet length (without authentication data)\n    dummy_msg = factory.connect(\n        client_uuid, pubkey_type, pubkey, b'\\x00' * 16, u'', u'', 0, 0, 0\n    )\n    dummy_payload_len = packer.payload_length(dummy_msg)\n\n    # Do fragmenting\n    total_auth_len = len(userhash + auth_token)\n    max_size = 1024 - dummy_payload_len\n\n    fragments = total_auth_len // max_size\n    overlap = total_auth_len % max_size\n\n    if overlap > 0:\n        fragments += 1\n\n    group_start = request_num\n    group_end = group_start + fragments\n\n    if fragments <= 1:\n        raise FragmentError('Authentication data too small to fragment')\n\n    auth_position = 0\n    for fragment_num in range(fragments):\n        available = max_size\n        current_hash = u''\n\n        if fragment_num == 0:\n            current_hash = userhash\n            available -= len(current_hash)\n\n        current_auth = auth_token[auth_position: auth_position + available]\n        auth_position += len(current_auth)\n\n        iv = crypto_instance.generate_iv()\n        messages.append(\n            factory.connect(\n                client_uuid, pubkey_type, pubkey, iv,\n                current_hash, current_auth, request_num + fragment_num,\n                group_start, group_end)\n        )\n\n    return messages\n"}
{"type": "source_file", "path": "xbox/rest/schemas/device.py", "content": "from typing import List, Dict, Optional\nfrom pydantic import BaseModel\n\nclass DeviceStatusResponse(BaseModel):\n    liveid: str\n    ip_address: str\n    connection_state: str\n    pairing_state: str\n    device_status: str\n    last_error: int\n    authenticated_users_allowed: bool\n    console_users_allowed: bool\n    anonymous_connection_allowed: bool\n    is_certificate_pending: bool\n\nclass ActiveTitle(BaseModel):\n    title_id: str\n    aum: str\n    name: str\n    image: Optional[str]\n    type: Optional[str]\n    has_focus: bool\n    title_location: str\n    product_id: str\n    sandbox_id: str\n\nclass ConsoleStatusResponse(BaseModel):\n    live_tv_provider: str\n    kernel_version: str\n    locale: str\n    active_titles: Optional[List[ActiveTitle]]\n\nclass MediaStateResponse(BaseModel):\n    title_id: str\n    aum_id: str\n    asset_id: str\n    media_type: str\n    sound_level: str\n    enabled_commands: str\n    playback_status: str\n    rate: str\n    position: str\n    media_start: int\n    media_end: int\n    min_seek: int\n    max_seek: int\n    metadata: Optional[Dict[str, str]]\n\nclass TextSessionActiveResponse(BaseModel):\n    text_session_active: bool\n\nclass InfraredButton(BaseModel):\n    url: str\n    value: str\n\nclass InfraredDevice(BaseModel):\n    device_type: str\n    device_brand: Optional[str]\n    device_model: Optional[str]\n    device_name: Optional[str]\n    device_id: str\n    buttons: Dict[str, InfraredButton]\n\nclass InfraredResponse(BaseModel):\n    __root__: Dict[str, InfraredDevice]\n\nclass MediaCommandsResponse(BaseModel):\n    commands: List[str]\n\nclass InputResponse(BaseModel):\n    buttons: List[str]\n"}
{"type": "source_file", "path": "xbox/scripts/rest_server.py", "content": "import argparse\nimport uvicorn\n\nREST_DEFAULT_SERVER_PORT=5557\n\ndef main():\n    parser = argparse.ArgumentParser(description='Xbox REST server')\n    parser.add_argument(\n        '--host', '-b', default='127.0.0.1',\n        help='Interface address to bind the server')\n    parser.add_argument(\n        '--port', '-p', type=int, default=REST_DEFAULT_SERVER_PORT,\n        help=f'Port to bind to, default: {REST_DEFAULT_SERVER_PORT}')\n    parser.add_argument(\n        '--reload', '-r', action='store_true',\n        help='Auto-reload server on filechanges (DEVELOPMENT)')\n    args = parser.parse_args()\n\n    uvicorn.run('xbox.rest.app:app', host=args.host, port=args.port, reload=args.reload)\n\nif __name__ == '__main__':\n    main()"}
{"type": "source_file", "path": "xbox/sg/packet/simple.py", "content": "# flake8: noqa\n\"\"\"\nConstruct containers for simple-message header and payloads\n\"\"\"\nfrom construct import *\nfrom xbox.sg import enum\nfrom xbox.sg.enum import PacketType\nfrom xbox.sg.utils.struct import XStruct\nfrom xbox.sg.utils.adapters import CryptoTunnel, XSwitch, XEnum, CertificateAdapter, UUIDAdapter, SGString, FieldIn\n\n\npkt_types = [\n    PacketType.PowerOnRequest,\n    PacketType.DiscoveryRequest, PacketType.DiscoveryResponse,\n    PacketType.ConnectRequest, PacketType.ConnectResponse\n]\n\n\nheader = XStruct(\n    'pkt_type' / XEnum(Int16ub, PacketType),\n    'unprotected_payload_length' / Default(Int16ub, 0),\n    'protected_payload_length' / If(\n        FieldIn('pkt_type', [PacketType.ConnectRequest, PacketType.ConnectResponse]),\n        Default(Int16ub, 0)\n    ),\n    'version' / Default(Int16ub, 2)\n)\n\n\npower_on_request = XStruct(\n    'liveid' / SGString()\n)\n\n\ndiscovery_request = XStruct(\n    'flags' / Int32ub,\n    'client_type' / XEnum(Int16ub, enum.ClientType),\n    'minimum_version' / Int16ub,\n    'maximum_version' / Int16ub\n)\n\n\ndiscovery_response = XStruct(\n    'flags' / XEnum(Int32ub, enum.PrimaryDeviceFlag),\n    'type' / XEnum(Int16ub, enum.ClientType),\n    'name' / SGString(),\n    'uuid' / UUIDAdapter('utf8'),\n    'last_error' / Int32ub,\n    'cert' / CertificateAdapter()\n)\n\n\nconnect_request_unprotected = XStruct(\n    'sg_uuid' / UUIDAdapter(),\n    'public_key_type' / XEnum(Int16ub, enum.PublicKeyType),\n    'public_key' / XSwitch(this.public_key_type, {\n        enum.PublicKeyType.EC_DH_P256: Bytes(0x40),\n        enum.PublicKeyType.EC_DH_P384: Bytes(0x60),\n        enum.PublicKeyType.EC_DH_P521: Bytes(0x84)\n    }),\n    'iv' / Bytes(0x10)\n)\n\n\nconnect_request_protected = XStruct(\n    'userhash' / SGString(),\n    'jwt' / SGString(),\n    'connect_request_num' / Int32ub,\n    'connect_request_group_start' / Int32ub,\n    'connect_request_group_end' / Int32ub\n)\n\n\nconnect_response_unprotected = XStruct(\n    'iv' / Bytes(0x10)\n)\n\n\nconnect_response_protected = XStruct(\n    'connect_result' / XEnum(Int16ub, enum.ConnectionResult),\n    'pairing_state' / XEnum(Int16ub, enum.PairedIdentityState),\n    'participant_id' / Int32ub\n)\n\n\nstruct = XStruct(\n    'header' / header,\n    'unprotected_payload' / XSwitch(\n        this.header.pkt_type, {\n            PacketType.PowerOnRequest: power_on_request,\n            PacketType.DiscoveryRequest: discovery_request,\n            PacketType.DiscoveryResponse: discovery_response,\n            PacketType.ConnectRequest: connect_request_unprotected,\n            PacketType.ConnectResponse: connect_response_unprotected\n        }\n    ),\n    'protected_payload' / CryptoTunnel(\n        XSwitch(\n            this.header.pkt_type, {\n                PacketType.ConnectRequest: connect_request_protected,\n                PacketType.ConnectResponse: connect_response_protected\n            },\n            Pass\n        )\n    )\n)\n"}
{"type": "source_file", "path": "xbox/sg/packer.py", "content": "\"\"\"\nSmartglass message un-/packing\n\nAlso handles de/encryption internally, this means:\nYou feed plaintext data (wrapped in :class:`.XStruct`) and you get plaintext data\n\n**Note on encryption**\nDepending on the packet-type, acquiring the `Initialization Vector` and\nencrypting the `protected payload` happens differently:\n\n* ConnectRequest: The `IV` is randomly chosen from calculated\n  Elliptic Curve (which happens in :class:`Crypto`) and is delivered\n  inside the `unprotected payload` section of the ConnectRequest message.\n* Messages: The `IV` is generated by encrypting the first 16 bytes of\n  the `unencrypted` header.\n\n**Note on padding**\nIf message has `protected payload` it might need padding according\nto PKCS#7 (e.g. padding is in whole bytes, the value of each added byte is\nthe number of bytes that are added, i.e. N bytes, each of value N are\nadded. thx wikipedia).\n\"\"\"\nfrom construct import Int16ub\nfrom xbox.sg.enum import PacketType\nfrom xbox.sg.crypto import PKCS7Padding\nfrom xbox.sg.packet import simple, message\nfrom xbox.sg.utils.struct import flatten\n\n\nclass PackerError(Exception):\n    \"\"\"\n    Custom exceptions for usage in packer module\n    \"\"\"\n    pass\n\n\ndef unpack(buf, crypto=None):\n    \"\"\"\n    Unpacks messages from Smartglass CoreProtocol.\n\n    For messages that require decryption, a Crypto instance needs to be passed\n    as well.\n\n    The decryption happens in :class:`CryptoTunnel`.\n\n    Args:\n        buf (bytes): A byte string to be deserialized into a message.\n        crypto (Crypto): Instance of :class:`Crypto`.\n\n    Raises:\n        PackerError: On various errors, instance of :class:`PackerError`.\n\n    Returns:\n        Container: The deserialized message, instance of :class:`Container`.\n    \"\"\"\n    msg_struct = None\n    pkt_type = PacketType(Int16ub.parse(buf[:2]))\n\n    if pkt_type not in PacketType:\n        raise PackerError(\"Invalid packet type\")\n\n    if pkt_type in simple.pkt_types:\n        msg_struct = simple.struct\n    elif pkt_type == PacketType.Message:\n        msg_struct = message.struct\n\n    return msg_struct.parse(buf, _crypto=crypto)\n\n\ndef pack(msg, crypto=None):\n    \"\"\"\n    Packs messages for Smartglass CoreProtocol.\n\n    For messages that require encryption, a Crypto instance needs to be passed\n    as well.\n\n    Args:\n        msg (XStructObj): A serializable message, instance of\n                          :class:`XStructObj`.\n        crypto (Crypto): Instance of :class:`Crypto`.\n\n    Returns:\n        bytes: The serialized bytes.\n    \"\"\"\n    container = flatten(msg.container)\n    packed_unprotected = b''\n    packed_protected = b''\n\n    if container.get('unprotected_payload', None):\n        packed_unprotected = msg.subcon.unprotected_payload.build(\n            container.unprotected_payload, **container\n        )\n\n    if container.get('protected_payload', None):\n        packed_protected = msg.subcon.protected_payload.build(\n            container.protected_payload, **container\n        )\n\n    container.header.unprotected_payload_length = len(packed_unprotected)\n    container.header.protected_payload_length = len(packed_protected)\n    packed_header = msg.subcon.header.build(\n        container.header, **container\n    )\n\n    if container.get('protected_payload', None) and packed_protected:\n        connect_types = [PacketType.ConnectRequest, PacketType.ConnectResponse]\n        if container.header.pkt_type in connect_types:\n            iv = container.unprotected_payload.iv\n        elif container.header.pkt_type == PacketType.Message:\n            iv = crypto.generate_iv(packed_header[:16])\n        else:\n            raise PackerError(\"Incompatible packet type for encryption\")\n\n        if PKCS7Padding.size(len(packed_protected), 16) > 0:\n            packed_protected = PKCS7Padding.pad(packed_protected, 16)\n\n        packed_protected = crypto.encrypt(iv, packed_protected)\n        buffer = packed_header + packed_unprotected + packed_protected\n        return buffer + crypto.hash(buffer)\n    else:\n        return packed_header + packed_unprotected\n\n\ndef payload_length(msg):\n    \"\"\"\n    Calculates the packed length in bytes of the given message.\n\n    Args:\n        msg (XStructObj): A serializable message, instance of\n                          :class:`XStructObj`.\n\n    Returns:\n        int: The packed message length in bytes.\n    \"\"\"\n    container = flatten(msg.container)\n    packed_unprotected = b''\n    packed_protected = b''\n\n    if container.get('unprotected_payload', None):\n        packed_unprotected = msg.subcon.unprotected_payload.build(\n            container.unprotected_payload, **container\n        )\n\n    if container.get('protected_payload', None):\n        packed_protected = msg.subcon.protected_payload.build(\n            container.protected_payload, **container\n        )\n\n    return len(packed_unprotected + packed_protected)\n"}
{"type": "source_file", "path": "xbox/scripts/recrypt.py", "content": "\"\"\"\nEncrypt smartglass messages (type 0xD00D) with a new key\n\nExample:\n    usage: xbox_recrypt [-h] src_path src_secret dst_path dst_secret\n\n    Re-Encrypt raw smartglass packets from a given filepath\n\n    positional arguments:\n      src_path    Path to sourcefiles\n      src_secret  Source shared secret in hex-format\n      dst_path    Path to destination\n      dst_secret  Target shared secret in hex-format\n\n    optional arguments:\n      -h, --help  show this help message and exit\n\"\"\"\nimport os\nimport sys\nimport argparse\nfrom binascii import unhexlify\n\nfrom construct import Int16ub\n\nfrom xbox.sg.crypto import Crypto\nfrom xbox.sg.enum import PacketType\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Re-Encrypt raw smartglass packets from a given filepath'\n    )\n    parser.add_argument('src_path', type=str, help='Path to sourcefiles')\n    parser.add_argument('src_secret', type=str, help='Source shared secret in hex-format')\n    parser.add_argument('dst_path', type=str, help='Path to destination')\n    parser.add_argument('dst_secret', type=str, help='Target shared secret in hex-format')\n    args = parser.parse_args()\n\n    src_secret = unhexlify(args.src_secret)\n    dst_secret = unhexlify(args.dst_secret)\n\n    src_path = args.src_path\n    dst_path = args.dst_path\n\n    if len(src_secret) != 64:\n        print('Source key of invalid length supplied!')\n        sys.exit(1)\n    elif len(dst_secret) != 64:\n        print('Destination key of invalid length supplied!')\n        sys.exit(1)\n\n    source_crypto = Crypto.from_shared_secret(src_secret)\n    dest_crypto = Crypto.from_shared_secret(dst_secret)\n\n    source_path = os.path.dirname(src_path)\n    dest_path = os.path.dirname(dst_path)\n\n    for f in os.listdir(source_path):\n        src_filepath = os.path.join(source_path, f)\n        with open(src_filepath, 'rb') as sfh:\n            encrypted = sfh.read()\n            if Int16ub.parse(encrypted[:2]) != PacketType.Message.value:\n                print('Invalid magic, %s not a smartglass message, ignoring'\n                      % src_filepath)\n                continue\n\n            # Slice the encrypted data manually\n            header = encrypted[:26]\n            payload = encrypted[26:-32]\n            hash = encrypted[-32:]\n\n            if not source_crypto.verify(encrypted[:-32], hash):\n                print('Hash mismatch, ignoring')\n                continue\n\n            # Decrypt with source shared secret\n            iv = source_crypto.generate_iv(header[:16])\n            decrypted_payload = source_crypto.decrypt(iv, payload)\n\n            # Encrypt with destination parameters\n            new_iv = dest_crypto.generate_iv(header[:16])\n            recrypted = dest_crypto.encrypt(new_iv, decrypted_payload)\n            new_hash = dest_crypto.hash(header + recrypted)\n            new_packet = header + recrypted + new_hash\n\n            with open(os.path.join(dest_path, f), 'wb') as dfh:\n                dfh.write(new_packet)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"type": "source_file", "path": "xbox/sg/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "xbox/sg/manager.py", "content": "\"\"\"\nManagers for handling different ServiceChannels.\n\nIf a manager for a specific :class:`ServiceChannel` is attached,\nincoming messages get forwarded there, otherways they are discarded.\n\nManagers can be attached by calling `add_manager()` on the :class:`Console`\nobject (see example)\nMethods of manager are available through console-context.\n\nExample:\n    How to add a manager::\n\n        discovered = await Console.discover(timeout=1)\n        if len(discovered):\n            console = discovered[0]\n\n            # Add manager, optionally passing initialization parameter\n            some_arg_for_manager_init = 'example'\n            console.add_manager(\n                MediaManager,\n                additional_arg=some_arg_for_manager_init\n            )\n\n            await console.connect()\n            if console.connection_state != ConnectionState.Connected:\n                print(\"Connection failed\")\n                sys.exit(1)\n            console.wait(1)\n\n            # Call manager method\n            console.media_command(0x54321, MediaControlCommand.PlayPauseToggle, 0)\n\n        else:\n            print(\"No consoles discovered\")\n            sys.exit(1)\n\"\"\"\nimport asyncio\nimport time\nimport logging\nfrom typing import Optional\n\nfrom construct import Container\n\nfrom xbox.sg import factory\nfrom xbox.sg.enum import MessageType, ServiceChannel, AckStatus, TextResult, \\\n    SoundLevel, MediaControlCommand, MediaPlaybackStatus, TextInputScope, \\\n    MediaType, GamePadButton\nfrom xbox.sg.utils.events import Event\nfrom xbox.sg.utils.struct import XStruct\n\nlog = logging.getLogger(__name__)\n\n\nclass Manager(object):\n    __namespace__ = ''\n\n    def __init__(self, console, channel: ServiceChannel):\n        \"\"\"\n        Don't use directly!\n        INTERNALLY called by the parent :class:`Console`!\n\n        Args:\n            console: Console object, internally passed by `Console.add_manager\n            channel: Service channel\n        \"\"\"\n        self.console = console\n        self.console.on_message += self._pre_on_message\n        self.console.on_json += self._pre_on_json\n        self._channel = channel\n\n    def _pre_on_message(self, msg, channel):\n        if channel == self._channel:\n            self._on_message(msg, channel)\n\n    def _pre_on_json(self, data, channel):\n        if channel == self._channel:\n            self._on_json(data, channel)\n\n    def _on_message(self, msg, channel):\n        \"\"\"\n        Managers must implement this\n        \"\"\"\n        pass\n\n    def _on_json(self, data, channel):\n        \"\"\"\n        Managers must implement this\n        \"\"\"\n        pass\n\n    async def _send_message(self, msg: XStruct):\n        \"\"\"\n        Internal method to send messages to initialized Service Channel\n\n        Args:\n            msg (:class:`XStructObj`): Message\n        \"\"\"\n        return await self.console.send_message(msg, channel=self._channel)\n\n    async def _send_json(self, data: str) -> None:\n        \"\"\"\n        Internal method to send JSON messages to initialized Service Channel\n\n        Args:\n            data: JSON message\n        \"\"\"\n        return await self.console.json(data, channel=self._channel)\n\n\nclass InputManagerError(Exception):\n    \"\"\"\n    Exception thrown by InputManager\n    \"\"\"\n    pass\n\n\nclass InputManager(Manager):\n    __namespace__ = 'input'\n\n    def __init__(self, console):\n        \"\"\"\n        Input Manager (ServiceChannel.SystemInput)\n\n        Args:\n             console: Console object, internally passed by `Console.add_manager\n\n        \"\"\"\n        super(InputManager, self).__init__(console, ServiceChannel.SystemInput)\n\n    def _on_message(self, msg: XStruct, channel: ServiceChannel) -> None:\n        \"\"\"\n        Internal handler method to receive messages from SystemInput Channel\n\n        Args:\n            msg: Message\n            channel: Service channel\n        \"\"\"\n        raise InputManagerError(\"Unexpected message received on InputManager\")\n\n    async def gamepad_input(\n        self,\n        buttons: GamePadButton,\n        l_trigger: int = 0,\n        r_trigger: int = 0,\n        l_thumb_x: int = 0,\n        l_thumb_y: int = 0,\n        r_thumb_x: int = 0,\n        r_thumb_y: int = 0\n    ) -> None:\n        \"\"\"\n        Send gamepad input\n\n        Args:\n            buttons: Gamepad buttons bits\n            l_trigger: Left trigger value\n            r_trigger: Right trigger value\n            l_thumb_x: Left thumbstick X-axis value\n            l_thumb_y: Left thumbstick Y-axis value\n            r_thumb_x: Right thumbstick X-axis value\n            r_thumb_y: Right thumbstick Y-axis value\n\n        Returns: None\n        \"\"\"\n        ts = int(time.time())\n        msg = factory.gamepad(\n            ts, buttons, l_trigger, r_trigger, l_thumb_x, l_thumb_y,\n            r_thumb_x, r_thumb_y\n        )\n        return await self._send_message(msg)\n\n\nclass MediaManagerError(Exception):\n    \"\"\"\n    Exception thrown by MediaManager\n    \"\"\"\n    pass\n\n\nclass MediaManager(Manager):\n    __namespace__ = 'media'\n\n    def __init__(self, console):\n        \"\"\"\n        Media Manager (ServiceChannel.SystemMedia)\n\n        Args: Console object, internally passed by `Console.add_manager\n\n        \"\"\"\n        super(MediaManager, self).__init__(console, ServiceChannel.SystemMedia)\n        self._media_state = None\n        self.on_media_state = Event()\n        self.on_media_command_result = Event()\n        self.on_media_controller_removed = Event()\n\n    def _on_message(self, msg: XStruct, channel: ServiceChannel) -> None:\n        \"\"\"\n        Internal handler method to receive messages from SystemMedia Channel\n\n        Args:\n            msg: Message\n            channel: Service channel\n        \"\"\"\n        msg_type = msg.header.flags.msg_type\n        payload = msg.protected_payload\n        if msg_type == MessageType.MediaState:\n            log.debug('Received MediaState message')\n            self._media_state = payload\n            self.on_media_state(self.media_state)\n\n        elif msg_type == MessageType.MediaCommandResult:\n            log.debug('Received MediaCommandResult message')\n            self.on_media_command_result(payload)\n\n        elif msg_type == MessageType.MediaControllerRemoved:\n            title_id = payload.title_id\n            log.debug('Received MediaControllerRemoved message, title id: 0x%x', title_id)\n            if self.title_id == title_id:\n                log.debug('Clearing MediaState')\n                self._media_state = None\n            self.on_media_controller_removed(payload)\n\n        else:\n            raise MediaManagerError(\n                \"Unexpected message received on MediaManager\"\n            )\n\n    @property\n    def media_state(self) -> Optional[Container]:\n        \"\"\"\n        Media state payload\n\n        Returns: Media state payload\n        \"\"\"\n        return self._media_state\n\n    @property\n    def active_media(self) -> Optional[bool]:\n        \"\"\"\n        Check whether console has active media\n\n        Returns: `True` if media is active, `False` if not\n        \"\"\"\n        return self.media_state is not None\n\n    @property\n    def title_id(self) -> Optional[int]:\n        \"\"\"\n        Title Id of active media\n\n        Returns: Title Id\n        \"\"\"\n        if self.media_state:\n            return self.media_state.title_id\n\n    @property\n    def aum_id(self) -> Optional[str]:\n        \"\"\"\n        Application user model Id of active media\n\n        Returns: Aum Id\n        \"\"\"\n        if self.media_state:\n            return self.media_state.aum_id\n\n    @property\n    def asset_id(self) -> Optional[str]:\n        \"\"\"\n        Asset Id of active media\n\n        Returns: Asset Id\n        \"\"\"\n        if self.media_state:\n            return self.media_state.asset_id\n\n    @property\n    def media_type(self) -> Optional[MediaType]:\n        \"\"\"\n        Media type of active media\n\n        Returns: Media type\n        \"\"\"\n        if self.media_state:\n            return self.media_state.media_type\n\n    @property\n    def sound_level(self) -> Optional[SoundLevel]:\n        \"\"\"\n        Sound level of active media\n\n        Returns: Sound level\n        \"\"\"\n        if self.media_state:\n            return self.media_state.sound_level\n\n    @property\n    def enabled_commands(self) -> Optional[MediaControlCommand]:\n        \"\"\"\n        Enabled MediaCommands bitmask\n\n        Returns: Bitmask of enabled commands\n        \"\"\"\n        if self.media_state:\n            return self.media_state.enabled_commands\n\n    @property\n    def playback_status(self) -> Optional[MediaPlaybackStatus]:\n        \"\"\"\n        Playback status of active media\n\n        Returns: Playback status\n        \"\"\"\n        if self.media_state:\n            return self.media_state.playback_status\n\n    @property\n    def rate(self) -> Optional[float]:\n        \"\"\"\n        Playback rate of active media\n\n        Returns: Playback rate\n        \"\"\"\n        if self.media_state:\n            return self.media_state.rate\n\n    @property\n    def position(self) -> Optional[int]:\n        \"\"\"\n        Playback position of active media\n\n        Returns: Playback position in microseconds\n        \"\"\"\n        if self.media_state:\n            return self.media_state.position\n\n    @property\n    def media_start(self) -> Optional[int]:\n        \"\"\"\n        Media start position of active media\n\n        Returns: Media start position in microseconds\n        \"\"\"\n        if self.media_state:\n            return self.media_state.media_start\n\n    @property\n    def media_end(self) -> Optional[int]:\n        \"\"\"\n        Media end position of active media\n\n        Returns: Media end position in microseconds\n        \"\"\"\n        if self.media_state:\n            return self.media_state.media_end\n\n    @property\n    def min_seek(self) -> Optional[int]:\n        \"\"\"\n        Minimum seek position of active media\n\n        Returns: Minimum position in microseconds\n        \"\"\"\n        if self.media_state:\n            return self.media_state.min_seek\n\n    @property\n    def max_seek(self) -> Optional[int]:\n        \"\"\"\n        Maximum seek position of active media\n\n        Returns: Maximum position in microseconds\n        \"\"\"\n        if self.media_state:\n            return self.media_state.max_seek\n\n    @property\n    def metadata(self) -> Container:\n        \"\"\"\n        Media metadata of active media\n\n        Returns: Media metadata\n        \"\"\"\n        if self.media_state:\n            return self.media_state.metadata\n\n    async def media_command(\n        self,\n        title_id: int,\n        command: MediaControlCommand,\n        request_id: int = 0,\n        seek_position: Optional[int] = None\n    ) -> None:\n        \"\"\"\n        Send media command\n\n        Args:\n            title_id: Title Id\n            command: Media Command\n            request_id: Incrementing Request Id\n            seek_position: Seek position\n\n        Returns: None\n        \"\"\"\n        msg = factory.media_command(\n            request_id, title_id, command, seek_position\n        )\n        return await self._send_message(msg)\n\n\nclass TextManagerError(Exception):\n    \"\"\"\n    Exception thrown by TextManager\n    \"\"\"\n    pass\n\n\nclass TextManager(Manager):\n    __namespace__ = 'text'\n\n    def __init__(self, console):\n        \"\"\"\n        Text Manager (ServiceChannel.SystemText)\n\n        Args:\n             console: Console object, internally passed by `Console.add_manager\n\n        \"\"\"\n        super(TextManager, self).__init__(console, ServiceChannel.SystemText)\n\n        self.session_config = None\n        self.current_session_input = None\n        self.last_session_ack = None\n        self._current_text_version = 0\n\n        self.on_systemtext_configuration = Event()\n        self.on_systemtext_input = Event()\n        self.on_systemtext_done = Event()\n\n    def _on_message(self, msg: XStruct, channel: ServiceChannel):\n        \"\"\"\n        Internal handler method to receive messages from SystemText Channel\n\n        Args:\n            msg (:class:`XStructObj`): Message\n            channel (:class:`ServiceChannel`): Service channel\n        \"\"\"\n        msg_type = msg.header.flags.msg_type\n        payload = msg.protected_payload\n        session_id = payload.text_session_id\n\n        if msg_type == MessageType.SystemTextConfiguration:\n            self.reset_session()\n            self.session_config = payload\n            self.on_systemtext_configuration(payload)\n\n        elif msg_type == MessageType.SystemTextInput:\n            # Assign console input msg\n            self.current_session_input = payload\n            self.current_text_version = payload.submitted_version\n            asyncio.create_task(\n                self.send_systemtext_ack(\n                    self.text_session_id,\n                    self.current_text_version\n                )\n            )\n            self.on_systemtext_input(payload)\n\n        elif msg_type == MessageType.SystemTextAck:\n            self.current_text_version = payload.text_version_ack\n\n        elif msg_type == MessageType.SystemTextDone:\n            if session_id == self.text_session_id:\n                self.reset_session()\n            elif session_id == 0:\n                # SystemTextDone for session 0 is sent by console\n                # No clue what it means, if anything\n                pass\n            else:\n                pass\n                # log.debug('Received DONE msg for inactive session %i' % session_id)\n\n            self.on_systemtext_done(payload)\n\n        elif msg_type in [MessageType.TitleTextConfiguration,\n                          MessageType.TitleTextInput,\n                          MessageType.TitleTextSelection]:\n            raise TextManagerError('Received TitleTextConfiguration, unhandled')\n        else:\n            raise TextManagerError(\n                \"Unexpected message received on TextManager\"\n            )\n\n    @property\n    def got_active_session(self):\n        \"\"\"\n        Check whether a text session is active\n\n        Returns:\n            bool: Returns `True` if any text session is active, `False` otherwise\n        \"\"\"\n        return self.session_config is not None\n\n    @property\n    def current_text_version(self):\n        \"\"\"\n        Current Text version\n\n        Returns:\n             int: Current Text Version\n        \"\"\"\n        return self._current_text_version\n\n    @current_text_version.setter\n    def current_text_version(self, value):\n        if value > self.current_text_version:\n            self._current_text_version = value\n\n    @property\n    def text_session_id(self):\n        \"\"\"\n        Current Text session id\n\n        Returns:\n            int: Text session id if existing, `None` otherwise\n        \"\"\"\n        if self.session_config:\n            return self.session_config.text_session_id\n\n    @property\n    def text_options(self):\n        \"\"\"\n        Current Text options\n\n        Returns:\n            :class:`TextOption`: Text options if existing, `None` otherwise\n        \"\"\"\n        if self.session_config:\n            return self.session_config.text_options\n\n    @property\n    def text_input_scope(self) -> Optional[TextInputScope]:\n        \"\"\"\n        Current Text input scope\n\n        Returns: Text input scope if existing, `None` otherwise\n        \"\"\"\n        if self.session_config:\n            return self.session_config.input_scope\n\n    @property\n    def max_text_length(self) -> Optional[int]:\n        \"\"\"\n        Maximum Text length\n\n        Returns: Max text length if existing, `None` otherwise\n        \"\"\"\n        if self.session_config:\n            return self.session_config.max_text_length\n\n    @property\n    def text_locale(self) -> Optional[str]:\n        \"\"\"\n        Test\n\n        Returns: Text locale if existing, `None` otherwise\n        \"\"\"\n        if self.session_config:\n            return self.session_config.locale\n\n    @property\n    def text_prompt(self) -> Optional[str]:\n        \"\"\"\n        Test\n\n        Returns: Text prompt if existing, `None` otherwise\n        \"\"\"\n        if self.session_config:\n            return self.session_config.prompt\n\n    def reset_session(self) -> None:\n        \"\"\"\n        Delete cached text-session config, -input and -ack messages\n\n        Returns: None\n        \"\"\"\n        self.session_config = None\n        self.current_session_input = None\n        self.last_session_ack = None\n        self.current_text_version = 0\n\n    async def finish_text_input(self) -> None:\n        \"\"\"\n        Finishes current text session.\n\n        Returns:\n            None\n        \"\"\"\n        await self.send_systemtext_done(\n            session_id=self.text_session_id,\n            version=self.current_session_input.submitted_version,\n            flags=0,\n            result=TextResult.Accept\n        )\n\n    async def send_systemtext_input(self, text: str) -> Optional[AckStatus]:\n        \"\"\"\n        Sends text input\n\n        Args:\n            text: Text string to send\n\n        Raises:\n            TextManagerError: If message was not acknowledged via\n                              AckMsg or SystemTextAck\n\n        Returns: Ack status\n        \"\"\"\n        new_version = self.current_text_version + 1\n        msg = factory.systemtext_input(\n            session_id=self.text_session_id,\n            base_version=self.current_text_version,\n            submitted_version=new_version,\n            total_text_len=len(text),\n            selection_start=-1,\n            selection_length=-1,\n            flags=0,\n            text_chunk_byte_start=0,\n            text_chunk=text,\n            delta=None\n        )\n\n        ack_status = await self._send_message(msg)\n        if ack_status != AckStatus.Processed:\n            raise TextManagerError('InputMsg was not acknowledged: %s' % msg)\n\n        # Assign client system input msg\n        self.current_session_input = msg.protected_payload\n        return ack_status\n\n    async def send_systemtext_ack(\n        self,\n        session_id: int,\n        version: int\n    ) -> Optional[AckStatus]:\n        \"\"\"\n        Acknowledges a SystemText message sent from the console\n\n        Args:\n            session_id: Current text session id\n            version: Text version to ack\n\n        Returns: Ack status\n        \"\"\"\n        msg = factory.systemtext_ack(session_id, version)\n        return await self._send_message(msg)\n\n    async def send_systemtext_done(\n        self,\n        session_id: int,\n        version: int,\n        flags: int,\n        result: TextResult\n    ) -> Optional[AckStatus]:\n        \"\"\"\n        Informs the console that a text session is done.\n\n        Result field tells wether text input should be\n        accepted or cancelled.\n\n        Args:\n            session_id: Current text session id\n            version: Last acknowledged text version\n            flags: Flags\n            result: Text result to send\n\n        Returns: Ack status\n        \"\"\"\n        msg = factory.systemtext_done(session_id, version, flags, result)\n        ack_status = await self._send_message(msg)\n        if ack_status != AckStatus.Processed:\n            raise TextManagerError('DoneMsg was not acknowledged: %s' % msg)\n\n        return ack_status\n"}
{"type": "source_file", "path": "xbox/sg/__init__.py", "content": "\"\"\"\nMeta package for xbox-smartglass-core-python.\nVersion and author information.\n\"\"\"\n\n__author__ = \"\"\"OpenXbox\"\"\"\n__version__ = '1.3.0'\n"}
{"type": "source_file", "path": "xbox/rest/schemas/root.py", "content": "from typing import Dict, Optional\nfrom pydantic import BaseModel\n\nclass IndexResponse(BaseModel):\n    versions: Dict[str, Optional[str]]\n    doc_path: str\n"}
{"type": "source_file", "path": "xbox/scripts/__init__.py", "content": "import os\nimport logging\n\nfrom enum import IntEnum\nfrom appdirs import user_data_dir\n\nDATA_DIR = user_data_dir('xbox', 'OpenXbox')\nTOKENS_FILE = os.path.join(DATA_DIR, 'tokens.json')\nCONSOLES_FILE = os.path.join(DATA_DIR, 'consoles.json')\n\nif not os.path.exists(DATA_DIR):\n    os.makedirs(DATA_DIR)\n\nLOG_FMT = '[%(asctime)s] %(levelname)s: %(message)s'\nLOG_LEVEL_DEBUG_INCL_PACKETS = logging.DEBUG - 1\nlogging.addLevelName(LOG_LEVEL_DEBUG_INCL_PACKETS, 'DEBUG_INCL_PACKETS')\n\n\nclass ExitCodes(IntEnum):\n    \"\"\"\n    Common CLI exit codes\n    \"\"\"\n    OK = 0\n    ArgParsingError = 1\n    AuthenticationError = 2\n    DiscoveryError = 3\n    ConsoleChoice = 4\n\n\nclass VerboseFormatter(logging.Formatter):\n    def __init__(self, *args, **kwargs):\n        super(VerboseFormatter, self).__init__(*args, **kwargs)\n        self._verbosefmt = self._fmt + '\\n%(_msg)s'\n\n    def formatMessage(self, record):\n        if '_msg' in record.__dict__:\n            return self._verbosefmt % record.__dict__\n        return self._style.format(record)\n"}
{"type": "source_file", "path": "xbox/sg/packet/__init__.py", "content": ""}
{"type": "source_file", "path": "xbox/rest/singletons.py", "content": "import aiohttp\nfrom typing import Dict, Optional\n\nfrom .schemas.auth import AuthSessionConfig\n\nfrom .consolewrap import ConsoleWrap \n\nfrom xbox.webapi.api.client import XboxLiveClient\nfrom xbox.webapi.api.provider.titlehub import TitleHubResponse\nfrom xbox.webapi.authentication.manager import AuthenticationManager\n\nhttp_session: Optional[aiohttp.ClientSession] = None\nauthentication_manager: Optional[AuthenticationManager] = None\nxbl_client: Optional[XboxLiveClient] = None\n\nauth_session_configs: Dict[str, AuthSessionConfig] = dict()\n\nconsole_cache: Dict[str, ConsoleWrap] = dict()\ntitle_cache: Dict[str, TitleHubResponse] = dict()\n"}
{"type": "source_file", "path": "xbox/sg/enum.py", "content": "\"\"\"\nSmartglass enumerations\n\"\"\"\n\nfrom enum import Enum, Flag\n\n\nclass PacketType(Enum):\n    \"\"\"\n    Packet Types of core protocol:\n    Connect*, Discovery*, PowerOnRequest -> SimpleMessage\n    Message -> Message\n    \"\"\"\n    ConnectRequest = 0xCC00\n    ConnectResponse = 0xCC01\n    DiscoveryRequest = 0xDD00\n    DiscoveryResponse = 0xDD01\n    PowerOnRequest = 0xDD02\n    Message = 0xD00D\n\n\nclass ClientType(Enum):\n    \"\"\"\n    Client Type\n\n    Used in `DiscoveryRequest`, `DiscoveryResponse` and `LocalJoin`-Message.\n    \"\"\"\n    XboxOne = 0x1\n    Xbox360 = 0x2\n    WindowsDesktop = 0x3\n    WindowsStore = 0x4\n    WindowsPhone = 0x5\n    iPhone = 0x6\n    iPad = 0x7\n    Android = 0x8\n\n\nclass DeviceCapabilities(Flag):\n    \"\"\"\n    Bitmask for client device hardware capabilities\n    \"\"\"\n    Non = 0\n    Streaming = 1\n    Audio = 2\n    Accelerometer = 4\n    Compass = 8\n    Gyrometer = 16\n    Inclinometer = 32\n    Orientation = 64\n    All = 0xFFFFFFFFFFFFFFFF\n\n\nclass ConnectionResult(Enum):\n    \"\"\"\n    Connection Result\n\n    Used in result-field of `ConnectResponse` packet.\n    \"\"\"\n    Success = 0x0\n    Pending = 0x1\n    FailureUnknown = 0x2\n    FailureAnonymousConnectionsDisabled = 0x3\n    FailureDeviceLimitExceeded = 0x4\n    FailureSmartGlassDisabled = 0x5\n    FailureUserAuthFailed = 0x6\n    FailureUserSignInFailed = 0x7\n    FailureUserSignInTimeOut = 0x8\n    FailureUserSignInRequired = 0x9\n\n\nclass PublicKeyType(Enum):\n    \"\"\"\n    Public Key Type\n\n    Used in `ConnectRequest` packet.\n    \"\"\"\n    EC_DH_P256 = 0x00\n    EC_DH_P384 = 0x01\n    EC_DH_P521 = 0x02\n    Default = 0xFFFF\n\n\nclass AckStatus(Enum):\n    \"\"\"\n    Acknowledgement Status\n\n    Internally used to signalize the waiting\n    caller the status of acknowledgement.\n    \"\"\"\n    Pending = 0\n    Processed = 1\n    Rejected = 2\n\n\nclass ConnectionState(Enum):\n    \"\"\"\n    Connection State\n\n    Internally used by :obj:`.Console`\n    \"\"\"\n    Disconnected = 0x0\n    Connecting = 0x1\n    Connected = 0x2\n    Error = 0x3\n    Disconnecting = 0x4\n    Reconnecting = 0x5\n\n\nclass DeviceStatus(Enum):\n    \"\"\"\n    Device Status\n\n    Internally used by :obj:`.Console`\n    \"\"\"\n    DiscoveringAvailability = 0x1\n    Available = 0x2\n    Unavailable = 0x3\n\n\nclass PrimaryDeviceFlag(Flag):\n    \"\"\"\n    Primary Device Flag\n\n    Used in flags of `DiscoveryResponse` packet.\n    \"\"\"\n    Null = 0x0\n    AllowConsoleUsers = 0x1\n    AllowAuthenticatedUsers = 0x2\n    AllowAnonymousUsers = 0x4\n    CertificatePending = 0x8\n\n\nclass DisconnectReason(Enum):\n    \"\"\"\n    Disconnect Reason\n\n    Used in reason-field of `Disconnect`-Message.\n    \"\"\"\n    Unspecified = 0x0\n    Error = 0x1\n    PowerOff = 0x2\n    Maintenance = 0x3\n    AppClose = 0x4\n    SignOut = 0x5\n    Reboot = 0x6\n    Disabled = 0x7\n    LowPower = 0x8\n\n\nclass PairedIdentityState(Enum):\n    \"\"\"\n    Paired Identity State\n\n    Used in `ConnectResponse` and `PairedIdentityStateChanged`-Message.\n    \"\"\"\n    NotPaired = 0x0\n    Paired = 0x1\n\n\nclass ServiceChannel(Enum):\n    \"\"\"\n    Service Channels\n\n    Used internally to identify actual Channel Ids.\n    \"\"\"\n    Core = 0x0\n    SystemInput = 0x1\n    SystemInputTVRemote = 0x2\n    SystemMedia = 0x3\n    SystemText = 0x4\n    SystemBroadcast = 0x5\n    Ack = 0x6\n    Title = 0x7\n\n\nclass MessageType(Enum):\n    \"\"\"\n    Message Type\n\n    Used in `Message`-Header.\n    \"\"\"\n    Null = 0x0\n    Ack = 0x1\n    Group = 0x2\n    LocalJoin = 0x3\n    StopActivity = 0x5\n    AuxilaryStream = 0x19\n    ActiveSurfaceChange = 0x1a\n    Navigate = 0x1b\n    Json = 0x1c\n    Tunnel = 0x1d\n    ConsoleStatus = 0x1e\n    TitleTextConfiguration = 0x1f\n    TitleTextInput = 0x20\n    TitleTextSelection = 0x21\n    MirroringRequest = 0x22\n    TitleLaunch = 0x23\n    StartChannelRequest = 0x26\n    StartChannelResponse = 0x27\n    StopChannel = 0x28\n    System = 0x29\n    Disconnect = 0x2a\n    TitleTouch = 0x2e\n    Accelerometer = 0x2f\n    Gyrometer = 0x30\n    Inclinometer = 0x31\n    Compass = 0x32\n    Orientation = 0x33\n    PairedIdentityStateChanged = 0x36\n    Unsnap = 0x37\n    GameDvrRecord = 0x38\n    PowerOff = 0x39\n    MediaControllerRemoved = 0xf00\n    MediaCommand = 0xf01\n    MediaCommandResult = 0xf02\n    MediaState = 0xf03\n    Gamepad = 0xf0a\n    SystemTextConfiguration = 0xf2b\n    SystemTextInput = 0xf2c\n    SystemTouch = 0xf2e\n    SystemTextAck = 0xf34\n    SystemTextDone = 0xf35\n\n\nclass ActiveTitleLocation(Enum):\n    \"\"\"\n    Active Title Location\n    \"\"\"\n    Full = 0x0\n    Fill = 0x1\n    Snapped = 0x2\n    StartView = 0x3\n    SystemUI = 0x4\n    Default = 0x5\n\n\nclass ActiveSurfaceType(Enum):\n    \"\"\"\n    Active Surface Type\n\n    Used in `ActiveSurfaceType`-Message.\n    \"\"\"\n    Blank = 0x0\n    Direct = 0x1\n    HTML = 0x2\n    TitleTextEntry = 0x3\n\n\nclass MediaType(Enum):\n    \"\"\"\n    Media Type\n\n    Used in `MediaState`-Message.\n    \"\"\"\n    NoMedia = 0x0\n    Music = 0x1\n    Video = 0x2\n    Image = 0x3\n    Conversation = 0x4\n    Game = 0x5\n\n\nclass MediaTransportState(Enum):\n    \"\"\"\n    Media Transport State\n\n    Used in `MediaState`-Message.\n    \"\"\"\n    Invalid = 0x0\n    Stopped = 0x1\n    Starting = 0x2\n    Playing = 0x3\n    Paused = 0x4\n    Buffering = 0x5\n\n\nclass MediaPlaybackStatus(Enum):\n    \"\"\"\n    Media Playback Status\n\n    Used in `MediaState`-Message.\n    \"\"\"\n    Closed = 0x0\n    Changing = 0x1\n    Stopped = 0x2\n    Playing = 0x3\n    Paused = 0x4\n\n\nclass MediaControlCommand(Flag):\n    \"\"\"\n    Media Control Command\n\n    Used in `MediaCommand`-Message.\n    \"\"\"\n    Null = 0x0\n    Play = 0x2\n    Pause = 0x4\n    PlayPauseToggle = 0x8\n    Stop = 0x10\n    Record = 0x20\n    NextTrack = 0x40\n    PreviousTrack = 0x80\n    FastForward = 0x100\n    Rewind = 0x200\n    ChannelUp = 0x400\n    ChannelDown = 0x800\n    Back = 0x1000\n    View = 0x2000\n    Menu = 0x4000\n    Seek = 0x8000\n\n\nclass SoundLevel(Enum):\n    \"\"\"\n    Sound Level\n\n    Used in `MediaState`-Message.\n    \"\"\"\n    Muted = 0x0\n    Low = 0x1\n    Full = 0x2\n\n\nclass GamePadButton(Enum):\n    \"\"\"\n    Gamepad Button\n\n    Used in `Gamepad`-Message.\n    \"\"\"\n    Clear = 0x0\n    Enroll = 0x1\n    Nexu = 0x2\n    Menu = 0x4\n    View = 0x8\n    PadA = 0x10\n    PadB = 0x20\n    PadX = 0x40\n    PadY = 0x80\n    DPadUp = 0x100\n    DPadDown = 0x200\n    DPadLeft = 0x400\n    DPadRight = 0x800\n    LeftShoulder = 0x1000\n    RightShoulder = 0x2000\n    LeftThumbStick = 0x4000\n    RightThumbStick = 0x8000\n\n\nclass TouchAction(Enum):\n    \"\"\"\n    Touch Action\n\n    Used in `SystemTouch`/`TitleTouch`-Message.\n    \"\"\"\n    Null = 0x0\n    Down = 0x1\n    Move = 0x2\n    Up = 0x3\n    Cancel = 0x4\n\n\nclass TextInputScope(Enum):\n    \"\"\"\n    Text Input Scope\n\n    Used in `TextConfiguration`-Message\n    \"\"\"\n    Default = 0x0\n    Url = 0x1\n    FullFilePath = 0x2\n    FileName = 0x3\n    EmailUserName = 0x4\n    EmailSmtpAddress = 0x5\n    LogOnName = 0x6\n    PersonalFullName = 0x7\n    PersonalNamePrefix = 0x8\n    PersonalGivenName = 0x9\n    PersonalMiddleName = 0xa\n    PersonalSurname = 0xb\n    PersonalNameSuffix = 0xc\n    PostalAddress = 0xd\n    PostalCode = 0xe\n    AddressStreet = 0xf\n    AddressStateOrProvince = 0x10\n    AddressCity = 0x11\n    AddressCountryName = 0x12\n    AddressCountryShortName = 0x13\n    CurrencyAmountAndSymbol = 0x14\n    CurrencyAmount = 0x15\n    Date = 0x16\n    DateMonth = 0x17\n    DateDay = 0x18\n    DateYear = 0x19\n    DateMonthName = 0x1a\n    DateDayName = 0x1b\n    Digits = 0x1c\n    Number = 0x1d\n    OneChar = 0x1e\n    Password = 0x1f\n    TelephoneNumber = 0x20\n    TelephoneCountryCode = 0x21\n    TelephoneAreaCode = 0x22\n    TelephoneLocalNumber = 0x23\n    Time = 0x24\n    TimeHour = 0x25\n    TimeMinorSec = 0x26\n    NumberFullWidth = 0x27\n    AlphanumericHalfWidth = 0x28\n    AlphanumericFullWidth = 0x29\n    CurrencyChinese = 0x2a\n    Bopomofo = 0x2b\n    Hiragana = 0x2c\n    KatakanaHalfWidth = 0x2d\n    KatakanaFullWidth = 0x2e\n    Hanja = 0x2f\n    HangulHalfWidth = 0x30\n    HangulFullWidth = 0x31\n    Search = 0x32\n    SearchTitleText = 0x33\n    SearchIncremental = 0x34\n    ChineseHalfWidth = 0x35\n    ChineseFullWidth = 0x36\n    NativeScript = 0x37\n    Unknown = 0x39\n\n\nclass TextAction(Enum):\n    \"\"\"\n    Text Action\n    \"\"\"\n    Cancel = 0x0\n    Accept = 0x1\n\n\nclass TextOption(Flag):\n    \"\"\"\n    Text Option\n    \"\"\"\n    Default = 0x0\n    AcceptsReturn = 0x1\n    Password = 0x2\n    MultiLine = 0x4\n    SpellCheckEnabled = 0x8\n    PredictionEnabled = 0x10\n    RTL = 0x20\n    Dismiss = 0x4000\n\n\nclass TextResult(Enum):\n    \"\"\"\n    Text Result\n    \"\"\"\n    Cancel = 0x0\n    Accept = 0x1\n    Null = 0xFFFF\n\n\nclass HashAlgorithm(Enum):\n    \"\"\"\n    Hash Algorithm\n\n    Unused\n    \"\"\"\n    SHA256 = 0x0\n    SHA384 = 0x1\n    SHA512 = 0x2\n\n\nclass AsymmetricAlgorithm(Enum):\n    \"\"\"\n    Asymmetric Algorithm\n\n    Unused\n    \"\"\"\n    RSA_PKCS1_1024 = 0x0\n    RSA_OAEP_1024 = 0x1\n    RSA_PKCS1_2048 = 0x2\n    RSA_OAEP_2048 = 0x3\n    EC_DSA_P256 = 0x4\n    EC_DSA_P384 = 0x5\n    EC_DSA_P521 = 0x6\n    EC_DH_P256 = 0x7\n    EC_DH_P384 = 0x8\n    EC_DH_P521 = 0x9\n\n\nclass SymmetricAlgorithm(Enum):\n    \"\"\"\n    Symmetric Algorithm\n\n    Unused\n    \"\"\"\n    AES_CBC_128 = 0x0\n    AES_CBC_192 = 0x1\n    AES_CBC_256 = 0x2\n\n\nclass AuthError(Enum):\n    \"\"\"\n    Authentication Error\n\n    Unused\n    \"\"\"\n    Null = 0x0\n    DevModeNotAuthorized = 0x2\n    SystemUpdateRequired = 0x3\n    ContentUpdateRequired = 0x4\n    EnforcementBan = 0x5\n    ThirdPartyBan = 0x6\n    ParentalControlsBan = 0x7\n    SubscriptionNotActivated = 0x8\n    BillingMaintenanceRequired = 0x9\n    AccountNotCreated = 0xa\n    NewTermsOfUse = 0xb\n    CountryNotAuthorized = 0xc\n    AgeVerificationRequired = 0xd\n    Curfew = 0xe\n    ChildAccountNotInFamily = 0xf\n    CSVTransitionRequired = 0x10\n    AccountMaintenanceRequired = 0x11\n    AccountTypeNotAllowed = 0x12\n    ContentIsolation = 0x13\n    GamertagMustChange = 0x14\n    DeviceChallengeRequired = 0x15\n    SignInCountExceeded = 0x16\n    RetailAccountNotAllowed = 0x17\n    SandboxNotAllowed = 0x18\n    UnknownUser = 0x19\n    RetailContentNotAuthorized = 0x1a\n    ContentNotAuthorized = 0x1b\n    ExpiredDeviceToken = 0x1c\n    ExpiredTitleToken = 0x1d\n    ExpiredUserToken = 0x1e\n    InvalidDeviceToken = 0x1f\n    InvalidTitleToken = 0x20\n    InvalidUserToken = 0x21\n    InvalidRefreshToken = 0x22\n\n\nclass TokensResetReason(Enum):\n    \"\"\"\n    Tokens Reset Reason\n\n    Unused\n    \"\"\"\n    AuthTicketError = 0x0\n    AuthTicketChanged = 0x1\n    EnvironmentChanged = 0x2\n    SandboxIDChanged = 0x3\n\n\nclass HttpRequestMethod(Enum):\n    \"\"\"\n    HTTP Request Method\n\n    Unused\n    \"\"\"\n    GET = 0x0\n    POST = 0x1\n\n\nclass EnvironmentType(Enum):\n    \"\"\"\n    Environment Type\n\n    Unused\n    \"\"\"\n    Production = 0x0\n    DNet = 0x1\n    Mock = 0x2\n    Null = 0x3\n\n\nclass MetricsOrigin(Enum):\n    \"\"\"\n    Metrics Origin\n\n    Unused\n    \"\"\"\n    Core = 0x1\n    SDK = 0x2\n    Canvas = 0x3\n    App = 0x4\n\n\nclass SGResultCode(Enum):\n    \"\"\"\n    Smartglass Result Code\n\n    Unused\n    \"\"\"\n    SG_E_SUCCESS = 0x0\n    SG_E_ABORT = 0x80000004\n    SG_E_ACCESS_DENIED = 0x80000005\n    SG_E_FAIL = 0x80000006\n    SG_E_HANDLE = 0x80000007\n    SG_E_INVALID_ARG = 0x80000008\n    SG_E_NO_INTERFACE = 0x80000009\n    SG_E_NOT_IMPL = 0x8000000a\n    SG_E_OUT_OF_MEMORY = 0x8000000b\n    SG_E_POINTER = 0x8000000c\n    SG_E_UNEXPECTED = 0x8000000d\n    SG_E_PENDING = 0x8000000e\n    SG_E_INVALID_DATA = 0x8000000f\n    SG_E_CANCELED = 0x80000010\n    SG_E_INVALID_STATE = 0x80000011\n    SG_E_NOT_FOUND = 0x80000012\n    SG_E_NO_MORE_CAPACITY = 0x80000013\n    SG_E_FAILED_TO_START_THREAD = 0x80000014\n    SG_E_MESSAGE_EXPIRED = 0x80000015\n    SG_E_TIMED_OUT = 0x80000016\n    SG_E_NOT_INITIALIZED = 0x80000017\n    SG_E_JSON_LENGTH_EXCEEDED = 0x80000018\n    SG_E_MESSAGE_LENGTH_EXCEEDED = 0x80000019\n    SG_E_INVALID_CONFIGURATION = 0x8000001a\n    SG_E_EXPIRED_CONFIGURATION = 0x8000001b\n    SG_E_AUTH_REQUIRED = 0x8000001d\n    SG_E_TIMED_OUT_PRESENCE = 0x8000001e\n    SG_E_TIMED_OUT_CONNECT = 0x8000001f\n    SG_E_SOCKET_ERROR = 0x80010001\n    SG_E_HTTP_ERROR = 0x80020001\n    SG_E_CANCEL_SHUTDOWN = 0x80020002\n    SG_E_HTTP_STATUS = 0x80020003\n    SG_E_UNEXPECTED_CRYPTO_ERROR = 0x80030001\n    SG_E_INVALID_CRYPT_ARG = 0x80030002\n    SG_E_CRYPTO_INVALID_SIGNATURE = 0x80030003\n    SG_E_INVALID_CERTIFICATE = 0x80030004\n    SG_E_CHANNEL_REQUEST_UNKNOWN_ERROR = 0x80040105\n    SG_E_FAILED_TO_JOIN = 0x80060001\n    SG_E_ALREADY_CONNECTED = 0x80060002\n    SG_E_NOT_CONNECTED = 0x80060003\n    SG_E_CONSOLE_NOT_RESPONDING = 0x80060004\n    SG_E_CONSOLE_DISCONNECTING = 0x80060005\n    SG_E_BIG_ENDIAN_STREAM_STRING_NOT_TERMINATED = 0x80070001\n    SG_E_CHANNEL_ALREADY_STARTED = 0x80080001\n    SG_E_CHANNEL_FAILED_TO_START = 0x80080002\n    SG_E_MAXIMUM_CHANNELS_STARTED = 0x80080003\n    SG_E_JNI_CLASS_NOT_FOUND = 0x80090001\n    SG_E_JNI_METHOD_NOT_FOUND = 0x80090002\n    SG_E_JNI_RUNTIME_ERROR = 0x80090003\n"}
{"type": "source_file", "path": "xbox/sg/console.py", "content": "\"\"\"\nConsole\n\nConsole class is a wrapper around the protocol, can be used to\n`discover`, `poweron` and `connect`.\nAlso stores various device status informations.\n\nIt can be either created manually or instantiated via `DiscoveryResponse`\nmessage. However, calling static method `discover` does all that for you\nautomatically.\n\nExample:\n    Discovery and connecting::\n\n        import sys\n        from xbox.sg.console import Console\n        from xbox.sg.enum import ConnectionState\n\n        discovered = await Console.discover(timeout=1)\n        if len(discovered):\n            console = discovered[0]\n            await console.connect()\n            if console.connection_state != ConnectionState.Connected:\n                print(\"Connection failed\")\n                sys.exit(1)\n            await console.wait(1)\n        else:\n            print(\"No consoles discovered\")\n            sys.exit(1)\n\n        ... do stuff ...\n\"\"\"\n\nimport asyncio\nimport socket\nimport logging\nfrom uuid import UUID\nfrom typing import Optional, List, Union, Dict, Type\n\nfrom cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey\nfrom xbox.sg.crypto import Crypto\nfrom xbox.sg.manager import Manager\nfrom xbox.sg.enum import PairedIdentityState, DeviceStatus, ConnectionState, \\\n    MessageType, PrimaryDeviceFlag, ActiveTitleLocation, AckStatus, \\\n    ServiceChannel, MediaControlCommand, GamePadButton\nfrom xbox.sg.protocol import SmartglassProtocol, ProtocolError\nfrom xbox.sg.utils.events import Event\nfrom xbox.sg.utils.struct import XStruct\nfrom xbox.stump.manager import StumpManager\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass Console(object):\n    __protocol__: SmartglassProtocol = None\n\n    def __init__(\n        self,\n        address: str,\n        name: str,\n        uuid: UUID,\n        liveid: str,\n        flags: PrimaryDeviceFlag = PrimaryDeviceFlag.Null,\n        last_error: int = 0,\n        public_key: EllipticCurvePublicKey = None\n    ):\n        \"\"\"\n        Initialize an instance of Console\n\n        Args:\n            address: IP address of console.\n            flags: Primary device flags\n            name: Name of console.\n            uuid: UUID of console.\n            liveid: Live ID of console.\n            public_key: Console's Public Key.\n        \"\"\"\n        self.address = address\n        self.name = name\n        self.uuid = uuid\n        self.liveid = liveid\n        self.flags = flags\n        self.last_error = last_error\n        self._public_key = None\n        self._crypto = None\n\n        if public_key:\n            # This sets up the crypto context\n            self.public_key = public_key\n\n        self._device_status = DeviceStatus.Unavailable\n        self._connection_state = ConnectionState.Disconnected\n        self._pairing_state = PairedIdentityState.NotPaired\n        self._console_status = None\n        self._active_surface = None\n\n        self.on_device_status = Event()\n        self.on_connection_state = Event()\n        self.on_pairing_state = Event()\n        self.on_console_status = Event()\n        self.on_active_surface = Event()\n        self.on_timeout = Event()\n\n        self.managers: Dict[str, Manager] = {}\n        self._functions = {}\n\n        self.on_message = Event()\n        self.on_json = Event()\n\n        self.power_on = self._power_on  # Dirty hack\n\n        self.protocol: Optional[SmartglassProtocol] = None\n\n    def __repr__(self) -> str:\n        return f'<Console addr={self.address} name={self.name} ' \\\n               f'uuid={self.uuid}liveid={self.liveid} flags={self.flags} ' \\\n               f'last_error={self.last_error}>'\n\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self) -> None:\n        await self.disconnect()\n\n    @staticmethod\n    async def wait(seconds: int) -> None:\n        \"\"\"\n        Wrapper around `asyncio.sleep`\n\n        Args:\n            seconds: Seconds to wait.\n\n        Returns: None\n        \"\"\"\n        await asyncio.sleep(seconds)\n\n    async def _ensure_protocol_started(self) -> None:\n        \"\"\"\n        Regular protocol instance, setup with crypto and destination address.\n        Targeted at communication with a specific console.\n\n        Returns:\n            None\n        \"\"\"\n        if not self.protocol:\n            loop = asyncio.get_running_loop()\n            _, self.protocol = await loop.create_datagram_endpoint(\n                lambda: SmartglassProtocol(self.address, self._crypto),\n                family=socket.AF_INET,\n                remote_addr=(self.address, 5050),\n                allow_broadcast=True\n            )\n\n            self.protocol.on_timeout += self._handle_timeout\n            self.protocol.on_message += self._handle_message\n            self.protocol.on_json += self._handle_json\n\n    @classmethod\n    async def _ensure_global_protocol_started(cls) -> None:\n        \"\"\"\n        Global protocol instance, used for network wide discovery and poweron.\n        \"\"\"\n        if not cls.__protocol__:\n            loop = asyncio.get_running_loop()\n            _, cls.__protocol__ = await loop.create_datagram_endpoint(\n                lambda: SmartglassProtocol(),\n                family=socket.AF_INET,\n                allow_broadcast=True\n            )\n\n    @classmethod\n    def from_message(cls, address: str, msg: XStruct):\n        \"\"\"\n        Initialize the class with a `DiscoveryResponse`.\n\n        Args:\n            address: IP address of the console\n            msg: Discovery Response struct\n\n        Returns: Console instance\n\n        \"\"\"\n        payload = msg.unprotected_payload\n        console = cls(\n            address, payload.name, payload.uuid, payload.cert.liveid,\n            payload.flags, payload.last_error, payload.cert.pubkey\n        )\n        console.device_status = DeviceStatus.Available\n        return console\n\n    @classmethod\n    def from_dict(cls, d: dict):\n        return cls(d['address'], d['name'], UUID(d['uuid']), d['liveid'])\n\n    def to_dict(self) -> dict:\n        return dict(\n            address=self.address,\n            name=self.name,\n            uuid=str(self.uuid),\n            liveid=self.liveid\n        )\n\n    def add_manager(self, manager: Type[Manager], *args, **kwargs):\n        \"\"\"\n        Add a manager to the console instance.\n\n        This will inherit all public methods of the manager class.\n\n        Args:\n            manager: Manager to add\n            *args: Arguments\n            **kwargs: KwArguments\n\n        Returns:\n            None\n        \"\"\"\n        if not issubclass(manager, Manager):\n            raise ValueError(\"Manager needs to subclass {}.{}\".format(\n                Manager.__module__, Manager.__name__)\n            )\n\n        namespace = getattr(manager, '__namespace__', manager.__name__.lower())\n        manager_inst = manager(self, *args, **kwargs)\n        self.managers[namespace] = manager_inst\n\n        for item in dir(manager):\n            if item.startswith('_'):\n                continue\n\n            if item in self.__dict__:\n                raise ValueError(\"Attribute already exists: %s\" % item)\n\n            self._functions[item] = getattr(manager_inst, item)\n\n    def __getattr__(self, k: str):\n        \"\"\"\n        Accessor to manager functions\n\n        Args:\n            k: Parameter name / key\n\n        Returns: Object requested by k\n        \"\"\"\n        if k in self.managers:\n            return self.managers[k]\n        elif k in self._functions:\n            return self._functions[k]\n        return object.__getattribute__(self, k)\n\n    @classmethod\n    async def discover(cls, *args, **kwargs) -> List:\n        \"\"\"\n        Discover consoles on the network.\n\n        Args:\n            *args:\n            **kwargs:\n\n        Returns:\n            list: List of discovered consoles.\n\n        \"\"\"\n        await cls._ensure_global_protocol_started()\n        discovered = await cls.__protocol__.discover(*args, **kwargs)\n        return [cls.from_message(a, m) for a, m in discovered.items()]\n\n    @classmethod\n    def discovered(cls) -> List:\n        \"\"\"\n        Get list of already discovered consoles.\n\n        Returns:\n            list: List of discovered consoles.\n\n        \"\"\"\n        discovered = cls.__protocol__.discovered\n        return [cls.from_message(a, m) for a, m in discovered.items()]\n\n    @classmethod\n    async def power_on(\n        cls,\n        liveid: str,\n        addr: Optional[str] = None,\n        tries=2\n    ) -> None:\n        \"\"\"\n        Power On console with given Live ID.\n\n        Optionally the IP address of the console can be supplied,\n        this is useful if the console is stubborn and does not react\n        to broadcast / multicast packets (due to routing issues).\n\n        Args:\n            liveid (str): Live ID of console.\n            addr (str): IP address of console.\n            tries (int): Poweron attempts, default: 2.\n\n        Returns: None\n\n        \"\"\"\n        await cls._ensure_global_protocol_started()\n        await cls.__protocol__.power_on(liveid, addr, tries)\n\n    async def send_message(\n        self,\n        msg: XStruct,\n        channel: ServiceChannel = ServiceChannel.Core,\n        addr: Optional[str] = None,\n        blocking: bool = True,\n        timeout: int = 5,\n        retries: int = 3\n    ) -> Optional[XStruct]:\n        \"\"\"\n        Send message to console.\n\n        Args:\n            msg: Unassembled message to send\n            channel: Channel to send the message on,\n                           Enum member of `ServiceChannel`\n            addr: IP address of target console\n            blocking: If set and `msg` is `Message`-packet, wait for ack\n            timeout: Seconds to wait for ack, only useful if `blocking`\n                           is `True`\n            retries: Max retry count.\n\n        Returns: None\n        \"\"\"\n        if not self.protocol:\n            LOGGER.error('send_message: Protocol not ready')\n            return\n\n        return await self.protocol.send_message(\n            msg, channel, addr, blocking, timeout, retries\n        )\n\n    async def json(\n        self,\n        data: str,\n        channel: ServiceChannel\n    ) -> None:\n        \"\"\"\n        Send json message\n\n        Args:\n            data: JSON dict\n            channel: Channel to send the message to\n\n        Returns: None\n        \"\"\"\n        if not self.protocol:\n            LOGGER.error('json: Protocol not ready')\n            return\n\n        return await self.protocol.json(data, channel=channel)\n\n    async def _power_on(self, tries: int = 2) -> None:\n        await Console.power_on(self.liveid, self.address, tries)\n\n    async def connect(\n        self,\n        userhash: Optional[str] = None,\n        xsts_token: Optional[str] = None\n    ) -> ConnectionState:\n        \"\"\"\n        Connect to the console\n\n        If the connection fails, error will be stored in\n        `self.connection_state`\n\n        Raises:\n            ConnectionException: If no authentication data is supplied and\n                console disallows anonymous connection.\n\n        Returns: Connection state\n        \"\"\"\n        if self.connected:\n            raise ConnectionError(\"Already connected\")\n\n        auth_data_available = bool(userhash and xsts_token)\n        if not self.anonymous_connection_allowed and not auth_data_available:\n            raise ConnectionError(\"Anonymous connection not allowed, please\"\n                                  \" supply userhash and auth-token\")\n\n        await self._ensure_protocol_started()\n\n        self.pairing_state = PairedIdentityState.NotPaired\n        self.connection_state = ConnectionState.Connecting\n\n        try:\n            self.pairing_state = await self.protocol.connect(\n                userhash=userhash,\n                xsts_token=xsts_token\n            )\n        except ProtocolError as e:\n            self.connection_state = ConnectionState.Error\n            raise e\n\n        self.connection_state = ConnectionState.Connected\n        return self.connection_state\n\n    async def launch_title(\n        self,\n        uri: str,\n        location: ActiveTitleLocation = ActiveTitleLocation.Full\n    ) -> AckStatus:\n        \"\"\"\n        Launch a title by URI\n\n        Args:\n            uri: Launch uri\n            location: Target title location\n\n        Returns: Ack status\n        \"\"\"\n        return await self.protocol.launch_title(uri, location)\n\n    async def game_dvr_record(\n        self,\n        start_delta: int,\n        end_delta: int\n    ) -> AckStatus:\n        \"\"\"\n        Start Game DVR recording\n\n        Args:\n            start_delta: Start time\n            end_delta: End time\n\n        Returns: Ack status\n        \"\"\"\n        return await self.protocol.game_dvr_record(start_delta, end_delta)\n\n    async def disconnect(self) -> None:\n        \"\"\"\n        Disconnect from console.\n\n        This will reset connection-, pairing-state,\n        ActiveSurface and ConsoleStatus.\n\n        Returns: None\n        \"\"\"\n        if self.connection_state == ConnectionState.Connected:\n            self.connection_state = ConnectionState.Disconnecting\n            await self._reset_state()\n\n    async def power_off(self) -> None:\n        \"\"\"\n        Power off the console.\n\n        No need to disconnect after.\n\n        Returns: None\n        \"\"\"\n        await self.protocol.power_off(self.liveid)\n        await self._reset_state()\n        self.device_status = DeviceStatus.Unavailable\n\n    def _handle_message(self, msg: XStruct, channel: ServiceChannel) -> None:\n        \"\"\"\n        Internal handler for console specific messages aka.\n        `PairedIdentityStateChange`, `ConsoleStatus` and\n        `ActiveSurfaceChange`.\n\n        Args:\n            msg: Message data\n            channel: Service channel\n\n        Returns:\n            None\n        \"\"\"\n        msg_type = msg.header.flags.msg_type\n\n        if msg_type == MessageType.PairedIdentityStateChanged:\n            self.pairing_state = msg.protected_payload.state\n\n        elif msg_type == MessageType.ConsoleStatus:\n            self.console_status = msg.protected_payload\n\n        elif msg_type == MessageType.ActiveSurfaceChange:\n            self.active_surface = msg.protected_payload\n\n        self.on_message(msg, channel)\n\n    def _handle_json(self, msg: XStruct, channel: ServiceChannel) -> None:\n        \"\"\"\n        Internal handler for JSON messages\n\n        Args:\n            msg: JSON message instance\n            channel: Service channel originating from\n\n        Returns: None\n        \"\"\"\n        self.on_json(msg, channel)\n\n    def _handle_timeout(self) -> None:\n        \"\"\"\n        Internal handler for console connection timeout.\n\n        Returns: None\n        \"\"\"\n        asyncio.create_task(self._reset_state())\n        self.device_status = DeviceStatus.Unavailable\n        self.on_timeout()\n\n    async def _reset_state(self) -> None:\n        \"\"\"\n        Internal handler to reset the inital state of the console instance.\n\n        Returns: None\n        \"\"\"\n        if self.protocol and self.protocol.started:\n            await self.protocol.stop()\n\n        await self._ensure_protocol_started()\n\n        self.connection_state = ConnectionState.Disconnected\n        self.pairing_state = PairedIdentityState.NotPaired\n        self.active_surface = None\n        self.console_status = None\n\n    @property\n    def public_key(self) -> EllipticCurvePublicKey:\n        \"\"\"\n        Console's public key.\n\n        Returns: Foreign public key\n        \"\"\"\n        return self._public_key\n\n    @public_key.setter\n    def public_key(self, key: Union[EllipticCurvePublicKey, bytes]) -> None:\n        if isinstance(key, bytes):\n            self._crypto = Crypto.from_bytes(key)\n        else:\n            self._crypto = Crypto(key)\n\n        self._public_key = self._crypto.foreign_pubkey\n\n    @property\n    def device_status(self) -> DeviceStatus:\n        \"\"\"\n        Current availability status\n\n        Returns:\n            :obj:`DeviceStatus`\n        \"\"\"\n        return self._device_status\n\n    @device_status.setter\n    def device_status(self, status: DeviceStatus) -> None:\n        self._device_status = status\n        self.on_device_status(status)\n\n    @property\n    def connection_state(self) -> ConnectionState:\n        \"\"\"\n        Current connection state\n\n        Returns: Connection state\n        \"\"\"\n        return self._connection_state\n\n    @connection_state.setter\n    def connection_state(self, state: ConnectionState) -> None:\n        self._connection_state = state\n        self.on_connection_state(state)\n\n    @property\n    def pairing_state(self) -> PairedIdentityState:\n        \"\"\"\n        Current pairing state\n\n        Returns:\n            :obj:`PairedIdentityState`\n        \"\"\"\n        return self._pairing_state\n\n    @pairing_state.setter\n    def pairing_state(self, state: PairedIdentityState) -> None:\n        self._pairing_state = state\n        self.on_pairing_state(state)\n\n    @property\n    def console_status(self):\n        \"\"\"\n        Console status aka. kernel version, active titles etc.\n\n        Returns:\n            :obj:`XStruct`\n        \"\"\"\n        return self._console_status\n\n    @console_status.setter\n    def console_status(self, status):\n        self._console_status = status\n        self.on_console_status(status)\n\n    @property\n    def active_surface(self):\n        \"\"\"\n        Currently active surface\n\n        Returns:\n            :obj:`XStruct`\n        \"\"\"\n        return self._active_surface\n\n    @active_surface.setter\n    def active_surface(self, active_surface) -> None:\n        self._active_surface = active_surface\n        self.on_active_surface(active_surface)\n\n    @property\n    def available(self) -> bool:\n        \"\"\"\n        Check whether console is available aka. discoverable\n\n        Returns: `True` if console is available, `False` otherwise\n        \"\"\"\n        return self.device_status == DeviceStatus.Available\n\n    @property\n    def paired(self) -> bool:\n        \"\"\"\n        Check whether client is paired to console\n\n        Returns: `True` if console is paired, `False` otherwise\n        \"\"\"\n        return self.pairing_state == PairedIdentityState.Paired\n\n    @property\n    def connected(self) -> bool:\n        \"\"\"\n        Check whether client is successfully connected to console\n\n        Returns: `True` if connected, `False` otherwise\n        \"\"\"\n        return self.connection_state == ConnectionState.Connected\n\n    @property\n    def authenticated_users_allowed(self) -> bool:\n        \"\"\"\n        Check whether authenticated users are allowed to connect\n\n        Returns: `True` if authenticated users are allowed, `False` otherwise\n        \"\"\"\n        return bool(self.flags & PrimaryDeviceFlag.AllowAuthenticatedUsers)\n\n    @property\n    def console_users_allowed(self) -> bool:\n        \"\"\"\n        Check whether console users are allowed to connect\n\n        Returns: `True` if console users are allowed, `False` otherwise\n        \"\"\"\n        return bool(self.flags & PrimaryDeviceFlag.AllowConsoleUsers)\n\n    @property\n    def anonymous_connection_allowed(self) -> bool:\n        \"\"\"\n        Check whether anonymous connection is allowed\n\n        Returns: `True` if anonymous connection is allowed, `False` otherwise\n        \"\"\"\n        return bool(self.flags & PrimaryDeviceFlag.AllowAnonymousUsers)\n\n    @property\n    def is_certificate_pending(self) -> bool:\n        \"\"\"\n        Check whether certificate is pending\n\n        Returns: `True` if certificate is pending, `False` otherwise\n        \"\"\"\n        return bool(self.flags & PrimaryDeviceFlag.CertificatePending)\n"}
{"type": "source_file", "path": "xbox/sg/crypto.py", "content": "\"\"\"\nCryptography portion used for sending Smartglass message\n\nDepending on the foreign public key type, the following Elliptic curves\ncan be used:\n\n* Prime 256R1\n* Prime 384R1\n* Prime 521R1\n\n1. On Discovery, the console responds with a DiscoveryResponse\n   including a certificate, this certificate holds the console's\n   `public key`.\n2. The Client generates appropriate `elliptic curve` and derives the\n   `shared secret` using `console's public key`\n3. The `shared secret` is salted via 2x hashes, see `kdf_salts`\n4. The `salted shared secret` is hashed using `SHA-512`\n5. The `salted & hashed shared secret` is split into the following\n   individual keys:\n\n    * bytes  0-16: Encryption key (AES 128-CBC)\n    * bytes 16-32: Initialization Vector key\n    * bytes 32-64: Hashing key (HMAC SHA-256)\n\n6. The resulting `public key` from this :class:`Crypto` context is\n   sent with the ConnectRequest message to the console\n\"\"\"\nimport os\nimport hmac\nimport hashlib\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives.serialization import Encoding, PublicFormat\nfrom xbox.sg.enum import PublicKeyType\nfrom binascii import unhexlify\n\n\nCURVE_MAP = {\n    PublicKeyType.EC_DH_P256: ec.SECP256R1,\n    PublicKeyType.EC_DH_P384: ec.SECP384R1,\n    PublicKeyType.EC_DH_P521: ec.SECP521R1\n}\n\n\nPUBLIC_KEY_TYPE_MAP = {v: k for k, v in CURVE_MAP.items()}\n\n\nclass SaltType(object):\n    \"\"\"\n    Define whether Salt is pre- or appended\n    \"\"\"\n    Prepend = 1\n    Append = 2\n\n\nclass Salt(object):\n    def __init__(self, value, salt_type=SaltType.Prepend):\n        \"\"\"\n        Handle salting of ECDH shared secret\n\n        Args:\n            value (bytes): Salting bytes\n            salt_type (:obj:`SaltType`): Salt Type\n        \"\"\"\n        self.value = value\n        self.type = salt_type\n\n    def apply(self, data):\n        \"\"\"\n        Appends or prepends salt bytes to data\n\n        Args:\n            data (bytes): Data to be salted\n\n        Returns:\n            bytes: Salted data\n        \"\"\"\n        if self.type == SaltType.Prepend:\n            return self.value + data\n        if self.type == SaltType.Append:\n            return data + self.value\n        raise ValueError(\"Unknown salt type: \" + str(self.type))\n\n\nclass Crypto(object):\n    _backend = default_backend()\n\n    _kdf_salts = (\n        Salt(unhexlify('D637F1AAE2F0418C'), SaltType.Prepend),\n        Salt(unhexlify('A8F81A574E228AB7'), SaltType.Append)\n    )\n\n    def __init__(self, foreign_public_key, privkey=None, pubkey=None):\n        \"\"\"\n        Initialize Crypto context via the foreign public key of the console.\n        The public key is part of the console certificate.\n\n        Args:\n            foreign_public_key (:obj:`ec.EllipticCurvePublicKey`):\n                The console's public key\n            privkey (:obj:`ec.EllipticCurvePrivateKey`): Optional private key\n            pubkey (:obj:`ec.EllipticCurvePublicKey`): Optional public key\n        \"\"\"\n\n        if not isinstance(foreign_public_key, ec.EllipticCurvePublicKey):\n            raise ValueError(\"Unsupported public key format, \\\n                expected EllipticCurvePublicKey\")\n\n        if privkey and not isinstance(privkey, ec.EllipticCurvePrivateKey):\n            raise ValueError(\"Unsupported private key format, \\\n                expected EllipticCurvePrivateKey\")\n        elif not privkey:\n            privkey = ec.generate_private_key(\n                foreign_public_key.curve, self._backend\n            )\n\n        if pubkey and not isinstance(pubkey, ec.EllipticCurvePublicKey):\n            raise ValueError(\"Unsupported public key format, \\\n                expected EllipticCurvePublicKey\")\n        elif not pubkey:\n            self.pubkey = privkey.public_key()\n        else:\n            self.pubkey = pubkey\n\n        secret = privkey.exchange(ec.ECDH(), foreign_public_key)\n        salted_secret = secret\n        for salt in self._kdf_salts:\n            salted_secret = salt.apply(salted_secret)\n\n        self._expanded_secret = hashlib.sha512(salted_secret).digest()\n        self._encrypt_key = self._expanded_secret[:16]\n        self._iv_key = self._expanded_secret[16:32]\n        self._hash_key = self._expanded_secret[32:]\n\n        self._pubkey_type = PUBLIC_KEY_TYPE_MAP[type(self.pubkey.curve)]\n        self._pubkey_bytes = self.pubkey.public_bytes(\n            format=PublicFormat.UncompressedPoint,\n            encoding=Encoding.X962)[1:]\n        self._foreign_pubkey = foreign_public_key\n\n    @property\n    def shared_secret(self):\n        \"\"\"\n        Shared secret\n\n        Returns:\n            bytes: Shared secret\n        \"\"\"\n        return self._expanded_secret\n\n    @property\n    def pubkey_type(self):\n        \"\"\"\n        Public Key Type aka. keystrength\n\n        Returns:\n            :obj:`.PublicKeyType`: Public Key Type\n\n        \"\"\"\n        return self._pubkey_type\n\n    @property\n    def pubkey_bytes(self):\n        \"\"\"\n        Public Key Bytes (minus the first identifier byte!)\n\n        Returns:\n            bytes: Public key\n        \"\"\"\n        return self._pubkey_bytes\n\n    @property\n    def foreign_pubkey(self):\n        \"\"\"\n        Foreign key that was used to generate this crypto context\n\n        Returns:\n            :obj:`ec.EllipticCurvePublicKey`: Console's public key\n        \"\"\"\n        return self._foreign_pubkey\n\n    @classmethod\n    def from_bytes(cls, foreign_public_key, public_key_type=None):\n        \"\"\"\n        Initialize Crypto context with foreign public key in\n        bytes / hexstring format.\n\n        Args:\n            foreign_public_key (bytes): Console's public key\n            public_key_type (:obj:`.PublicKeyType`): Public Key Type\n\n        Returns:\n            :obj:`.Crypto`: Instance\n        \"\"\"\n\n        if not isinstance(foreign_public_key, bytes):\n            raise ValueError(\"Unsupported foreign public key format, \\\n                expected bytes\")\n\n        if public_key_type is None:\n            keylen = len(foreign_public_key)\n            if keylen == 0x41:\n                public_key_type = PublicKeyType.EC_DH_P256\n            elif keylen == 0x61:\n                public_key_type = PublicKeyType.EC_DH_P384\n            elif keylen == 0x85:\n                public_key_type = PublicKeyType.EC_DH_P521\n            else:\n                raise ValueError(\"Invalid public keylength\")\n\n        curve = CURVE_MAP[public_key_type]\n        foreign_public_key = ec.EllipticCurvePublicKey.from_encoded_point(\n            curve(), foreign_public_key\n        )\n        return cls(foreign_public_key)\n\n    @classmethod\n    def from_shared_secret(cls, shared_secret):\n        \"\"\"\n        Set up crypto context with shared secret\n\n        Args:\n            shared_secret (bytes): The shared secret\n\n        Returns:\n            :obj:`.Crypto`: Instance\n        \"\"\"\n        if not isinstance(shared_secret, bytes):\n            raise ValueError(\"Unsupported shared secret format, \\\n                expected bytes\")\n        elif len(shared_secret) != 64:\n            raise ValueError(\"Unsupported shared secret length, \\\n                expected 64 bytes\")\n\n        # We need a dummy foreign key\n        dummy_key = unhexlify(\n            '041db1e7943878b28c773228ebdcfb05b985be4a386a55f50066231360785f61b'\n            '60038caf182d712d86c8a28a0e7e2733a0391b1169ef2905e4e21555b432b262d'\n        )\n        ctx = cls.from_bytes(dummy_key)\n        # Overwriting shared secret\n        ctx._encrypt_key = shared_secret[:16]\n        ctx._iv_key = shared_secret[16:32]\n        ctx._hash_key = shared_secret[32:]\n        return ctx\n\n    def generate_iv(self, seed=None):\n        \"\"\"\n        Generates an IV to be used in encryption/decryption\n\n        Args:\n            seed (bytes): An optional IV seed\n\n        Returns:\n            bytes: Initialization Vector\n        \"\"\"\n        if seed:\n            return self._encrypt(key=self._iv_key, iv=None, data=seed)\n        return os.urandom(16)\n\n    def encrypt(self, iv, plaintext):\n        \"\"\"\n        Encrypts plaintext with AES-128-CBC\n\n        No padding is added here, data has to be aligned to\n        block size (16 bytes).\n\n        Args:\n            iv (bytes): The IV to use. None where no IV is used.\n            plaintext (bytes): The plaintext to encrypt.\n\n        Returns:\n            bytes: Encrypted Data\n        \"\"\"\n        return Crypto._encrypt(self._encrypt_key, iv, plaintext)\n\n    def decrypt(self, iv, ciphertext):\n        \"\"\"\n        Decrypts ciphertext\n\n        No padding is removed here.\n\n        Args:\n            iv (bytes): The IV to use. None where no IV is used.\n            ciphertext (bytes): The hex representation of a ciphertext\n                                to be decrypted\n\n        Returns:\n            bytes: Decrypted data\n        \"\"\"\n        return Crypto._decrypt(self._encrypt_key, iv, ciphertext)\n\n    def hash(self, data):\n        \"\"\"\n        Securely hashes data with HMAC SHA-256\n\n        Args:\n            data (bytes): The data to securely hash.\n\n        Returns:\n            bytes: Hashed data\n        \"\"\"\n        return Crypto._secure_hash(self._hash_key, data)\n\n    def verify(self, data, secure_hash):\n        \"\"\"\n        Verifies that the given data generates the given secure_hash\n\n        Args:\n            data (bytes): The data to validate.\n            secure_hash (bytes): The secure hash to validate against.\n\n        Returns:\n            bool: True on success, False otherwise\n        \"\"\"\n        return secure_hash == self.hash(data)\n\n    @staticmethod\n    def _secure_hash(key, data):\n        return hmac.new(key, data, hashlib.sha256).digest()\n\n    @staticmethod\n    def _encrypt(key, iv, data):\n        return Crypto._crypt(key=key, iv=iv, encrypt=True, data=data)\n\n    @staticmethod\n    def _decrypt(key, iv, data):\n        return Crypto._crypt(key=key, iv=iv, encrypt=False, data=data)\n\n    @staticmethod\n    def _crypt(key, iv, encrypt, data):\n        if not iv:\n            iv = b'\\x00' * 16\n        cipher = Cipher(\n            algorithms.AES(key), modes.CBC(iv), backend=Crypto._backend\n        )\n        if encrypt:\n            cryptor = cipher.encryptor()\n        else:\n            cryptor = cipher.decryptor()\n\n        return cryptor.update(data) + cryptor.finalize()\n\n\nclass Padding(object):\n    \"\"\"\n    Padding base class.\n    \"\"\"\n    @staticmethod\n    def size(length, alignment):\n        \"\"\"\n        Calculate needed padding size.\n\n        Args:\n            length (int): Data size\n            alignment (int): Data alignment\n\n        Returns:\n            int: Padding size\n        \"\"\"\n        overlap = length % alignment\n        if overlap:\n            return alignment - overlap\n        else:\n            return 0\n\n    @staticmethod\n    def pad(payload, alignment):\n        \"\"\"\n        Abstract method to override\n\n        Args:\n            payload (bytes): Data blob\n            alignment (int): Data alignment\n\n        Returns:\n            bytes: Data with padding bytes\n        \"\"\"\n        raise NotImplementedError()\n\n    @staticmethod\n    def remove(payload):\n        \"\"\"\n        Common method for removing padding from data blob.\n\n        Args:\n            payload (bytes): Padded data.\n\n        Returns:\n            bytes: Data with padding bytes removed\n        \"\"\"\n        pad_count = payload[-1]\n        return payload[:-pad_count]\n\n\nclass PKCS7Padding(Padding):\n    @staticmethod\n    def pad(payload, alignment):\n        \"\"\"\n        Add PKCS#7 padding to data blob.\n\n        Args:\n            payload (bytes): Data blob\n            alignment (int): Data alignment\n\n        Returns:\n            bytes: Data with padding bytes\n        \"\"\"\n        size = Padding.size(len(payload), alignment)\n        if size == 0:\n            return payload\n        else:\n            return payload + (size * chr(size).encode())\n\n\nclass ANSIX923Padding(Padding):\n    @staticmethod\n    def pad(payload, alignment):\n        \"\"\"\n        Add ANSI.X923 padding to data blob.\n\n        Args:\n            payload (bytes): Data blob\n            alignment (int): Data alignment\n\n        Returns:\n            bytes: Data with padding bytes\n        \"\"\"\n        size = Padding.size(len(payload), alignment)\n        if size == 0:\n            return payload\n        else:\n            return payload + ((size - 1) * b'\\x00') + chr(size).encode()\n"}
{"type": "source_file", "path": "xbox/rest/schemas/general.py", "content": "from typing import Dict, Optional\nfrom pydantic import BaseModel\n\nclass GeneralResponse(BaseModel):\n    success: bool\n    details: Optional[Dict[str, str]]\n"}
{"type": "source_file", "path": "xbox/sg/constants.py", "content": "\"\"\"\nConstant values used by SmartGlass\n\"\"\"\nfrom uuid import UUID\n\nfrom xbox.sg.enum import ClientType, DeviceCapabilities\n\n\nclass AndroidClientInfo(object):\n    \"\"\"\n    Client Info for Android device (tablet). Used for LocalJoin messages\n    \"\"\"\n    DeviceType = ClientType.Android\n    # Resolution is portrait mode\n    NativeWidth = 720\n    NativeHeight = 1280\n    DpiX = 160\n    DpiY = 160\n    DeviceCapabilities = DeviceCapabilities.All\n    ClientVersion = 151117100  # v2.4.1511.17100-Beta\n    OSMajor = 22  # Android 5.1.1 - API Version 22\n    OSMinor = 0\n    DisplayName = \"com.microsoft.xboxone.smartglass.beta\"\n\n\nclass WindowsClientInfo(object):\n    \"\"\"\n    Client Info for Windows device, used for LocalJoin messages\n    \"\"\"\n    DeviceType = ClientType.WindowsStore\n    NativeWidth = 1080\n    NativeHeight = 1920\n    DpiX = 96\n    DpiY = 96\n    DeviceCapabilities = DeviceCapabilities.All\n    ClientVersion = 39\n    OSMajor = 6\n    OSMinor = 2\n    DisplayName = \"SmartGlass-PC\"\n\n\nclass MessageTarget(object):\n    \"\"\"\n    UUIDs for all ServiceChannels\n    \"\"\"\n    SystemInputUUID = UUID(\"fa20b8ca-66fb-46e0-adb60b978a59d35f\")\n    SystemInputTVRemoteUUID = UUID(\"d451e3b3-60bb-4c71-b3dbf994b1aca3a7\")\n    SystemMediaUUID = UUID(\"48a9ca24-eb6d-4e12-8c43d57469edd3cd\")\n    SystemTextUUID = UUID(\"7af3e6a2-488b-40cb-a93179c04b7da3a0\")\n    SystemBroadcastUUID = UUID(\"b6a117d8-f5e2-45d7-862e8fd8e3156476\")\n    TitleUUID = UUID('00000000-0000-0000-0000-000000000000')\n\n\nclass XboxOneGuid(object):\n    \"\"\"\n    System level GUIDs\n    \"\"\"\n    BROWSER = \"9c7e0f20-78fb-4ea7-a8bd-cf9d78059a08\"\n    MUSIC = \"6D96DEDC-F3C9-43F8-89E3-0C95BF76AD2A\"\n    VIDEO = \"a489d977-8a87-4983-8df6-facea1ad6d93\"\n\n\nclass TitleId(object):\n    \"\"\"\n    System level Title Ids\n    \"\"\"\n    AVATAR_EDITOR_TITLE_ID = 1481443281\n    BROWSER_TITLE_ID = 1481115776\n    DASH_TITLE_ID = 4294838225\n    BLUERAY_TITLE_ID = 1783797709\n    CONSOLE_UPDATE_APP_TITLE_ID = -1\n    HOME_TITLE_ID = 714681658\n    IE_TITLE_ID = 1032557327\n    LIVETV_TITLE_ID = 371594669\n    MUSIC_TITLE_ID = 419416564\n    ONEGUIDE_TITLE_ID = 2055214557\n    OOBE_APP_TITLE_ID = 951105730\n    SNAP_AN_APP_TITLE_ID = 1783889234\n    STORE_APP_TITLE_ID = 1407783715\n    VIDEO_TITLE_ID = 1030770725\n    ZUNE_TITLE_ID = 1481115739\n"}
{"type": "source_file", "path": "xbox/sg/packet/message.py", "content": "# flake8: noqa\n\"\"\"\nConstruct containers for message header and payloads\n\"\"\"\nfrom construct import *\nfrom xbox.sg import enum\nfrom xbox.sg.enum import PacketType, MessageType\nfrom xbox.sg.utils.struct import XStruct\nfrom xbox.sg.utils.adapters import CryptoTunnel, UUIDAdapter, JsonAdapter, XSwitch, XEnum, SGString, PrefixedBytes\n\n\nheader = XStruct(\n    'pkt_type' / Default(XEnum(Int16ub, PacketType), PacketType.Message),\n    'protected_payload_length' / Default(Int16ub, 0),\n    'sequence_number' / Int32ub,\n    'target_participant_id' / Int32ub,\n    'source_participant_id' / Int32ub,\n    'flags' / BitStruct(\n        'version' / Default(BitsInteger(2), 2),\n        'need_ack' / Flag,\n        'is_fragment' / Flag,\n        'msg_type' / XEnum(BitsInteger(12), MessageType)\n    ),\n    'channel_id' / Int64ub\n)\n\n\nfragment = XStruct(\n    'sequence_begin' / Int32ub,\n    'sequence_end' / Int32ub,\n    'data' / PrefixedBytes(Int16ub)\n)\n\n\nacknowledge = XStruct(\n    'low_watermark' / Int32ub,\n    'processed_list' / PrefixedArray(Int32ub, Int32ub),\n    'rejected_list' / PrefixedArray(Int32ub, Int32ub)\n)\n\n\njson = XStruct(\n    'text' / JsonAdapter(SGString())\n)\n\n\nlocal_join = XStruct(\n    'device_type' / XEnum(Int16ub, enum.ClientType),\n    'native_width' / Int16ub,\n    'native_height' / Int16ub,\n    'dpi_x' / Int16ub,\n    'dpi_y' / Int16ub,\n    'device_capabilities' / XEnum(Int64ub, enum.DeviceCapabilities),\n    'client_version' / Int32ub,\n    'os_major_version' / Int32ub,\n    'os_minor_version' / Int32ub,\n    'display_name' / SGString()\n)\n\n\nauxiliary_stream = XStruct(\n    'connection_info_flag' / Int8ub,\n    'connection_info' / If(this.connection_info_flag == 1, Struct(\n        'crypto_key' / PrefixedBytes(Int16ub),\n        'server_iv' / PrefixedBytes(Int16ub),\n        'client_iv' / PrefixedBytes(Int16ub),\n        'sign_hash' / PrefixedBytes(Int16ub),\n        'endpoints' / PrefixedArray(Int16ub, Struct(\n            'ip' / SGString(),\n            'port' / SGString()\n        ))\n    ))\n)\n\n\npower_off = XStruct(\n    'liveid' / SGString()\n)\n\n\ngame_dvr_record = XStruct(\n    'start_time_delta' / Int32sb,\n    'end_time_delta' / Int32sb\n)\n\n\nunsnap = XStruct(\n    'unk' / Bytes(1)\n)\n\n\ngamepad = XStruct(\n    'timestamp' / Int64ub,\n    'buttons' / XEnum(Int16ub, enum.GamePadButton),\n    'left_trigger' / Float32b,\n    'right_trigger' / Float32b,\n    'left_thumbstick_x' / Float32b,\n    'left_thumbstick_y' / Float32b,\n    'right_thumbstick_x' / Float32b,\n    'right_thumbstick_y' / Float32b\n)\n\n\npaired_identity_state_changed = XStruct(\n    'state' / XEnum(Int16ub, enum.PairedIdentityState)\n)\n\n\nmedia_state = XStruct(\n    'title_id' / Int32ub,\n    'aum_id' / SGString(),\n    'asset_id' / SGString(),\n    'media_type' / XEnum(Int16ub, enum.MediaType),\n    'sound_level' / XEnum(Int16ub, enum.SoundLevel),\n    'enabled_commands' / XEnum(Int32ub, enum.MediaControlCommand),\n    'playback_status' / XEnum(Int16ub, enum.MediaPlaybackStatus),\n    'rate' / Float32b,\n    'position' / Int64ub,\n    'media_start' / Int64ub,\n    'media_end' / Int64ub,\n    'min_seek' / Int64ub,\n    'max_seek' / Int64ub,\n    'metadata' / PrefixedArray(Int16ub, Struct(\n        'name' / SGString(),\n        'value' / SGString()\n    ))\n)\n\n\nmedia_controller_removed = XStruct(\n    'title_id' / Int32ub\n)\n\n\nmedia_command_result = XStruct(\n    'request_id' / Int64ub,\n    'result' / Int32ub\n)\n\n\nmedia_command = XStruct(\n    'request_id' / Int64ub,\n    'title_id' / Int32ub,\n    'command' / XEnum(Int32ub, enum.MediaControlCommand),\n    'seek_position' / If(this.command == enum.MediaControlCommand.Seek, Int64ub)\n)\n\n\norientation = XStruct(\n    'timestamp' / Int64ub,\n    'rotation_matrix_value' / Float32b,\n    'w' / Float32b,\n    'x' / Float32b,\n    'y' / Float32b,\n    'z' / Float32b\n)\n\n\ncompass = XStruct(\n    'timestamp' / Int64ub,\n    'magnetic_north' / Float32b,\n    'true_north' / Float32b\n)\n\n\ninclinometer = XStruct(\n    'timestamp' / Int64ub,\n    'pitch' / Float32b,\n    'roll' / Float32b,\n    'yaw' / Float32b\n)\n\n\ngyrometer = XStruct(\n    'timestamp' / Int64ub,\n    'angular_velocity_x' / Float32b,\n    'angular_velocity_y' / Float32b,\n    'angular_velocity_z' / Float32b\n)\n\n\naccelerometer = XStruct(\n    'timestamp' / Int64ub,\n    'acceleration_x' / Float32b,\n    'acceleration_y' / Float32b,\n    'acceleration_z' / Float32b\n)\n\n\n_touchpoint = XStruct(\n    'touchpoint_id' / Int32ub,\n    'touchpoint_action' / XEnum(Int16ub, enum.TouchAction),\n    'touchpoint_x' / Int32ub,\n    'touchpoint_y' / Int32ub\n)\n\n\ntouch = XStruct(\n    'touch_msg_timestamp' / Int32ub,\n    'touchpoints' / PrefixedArray(Int16ub, _touchpoint)\n)\n\n\ndisconnect = XStruct(\n    'reason' / XEnum(Int32ub, enum.DisconnectReason),\n    'error_code' / Int32ub\n)\n\n\nstop_channel = XStruct(\n    'target_channel_id' / Int64ub\n)\n\n\nstart_channel_request = XStruct(\n    'channel_request_id' / Int32ub,\n    'title_id' / Int32ub,\n    'service' / UUIDAdapter(),\n    'activity_id' / Int32ub\n)\n\n\nstart_channel_response = XStruct(\n    'channel_request_id' / Int32ub,\n    'target_channel_id' / Int64ub,\n    'result' / XEnum(Int32ub, enum.SGResultCode)\n)\n\n\ntitle_launch = XStruct(\n    'location' / XEnum(Int16ub, enum.ActiveTitleLocation),\n    'uri' / SGString()\n)\n\n\nsystem_text_done = XStruct(\n    'text_session_id' / Int32ub,\n    'text_version' / Int32ub,\n    'flags' / Int32ub,\n    'result' / XEnum(Int32ub, enum.TextResult)\n)\n\n\nsystem_text_acknowledge = XStruct(\n    'text_session_id' / Int32ub,\n    'text_version_ack' / Int32ub\n)\n\n_system_text_input_delta = XStruct(\n    'offset' / Int32ub,\n    'delete_count' / Int32ub,\n    'insert_content' / SGString()\n)\n\nsystem_text_input = XStruct(\n    'text_session_id' / Int32ub,\n    'base_version' / Int32ub,\n    'submitted_version' / Int32ub,\n    'total_text_byte_len' / Int32ub,\n    'selection_start' / Int32sb,\n    'selection_length' / Int32sb,\n    'flags' / Int16ub,\n    'text_chunk_byte_start' / Int32ub,\n    'text_chunk' / SGString(),\n    'delta' / Optional(PrefixedArray(Int16ub, _system_text_input_delta))\n)\n\n\ntitle_text_selection = XStruct(\n    'text_session_id' / Int64ub,\n    'text_buffer_version' / Int32ub,\n    'start' / Int32ub,\n    'length' / Int32ub\n)\n\n\ntitle_text_input = XStruct(\n    'text_session_id' / Int64ub,\n    'text_buffer_version' / Int32ub,\n    'result' / XEnum(Int16ub, enum.TextResult),\n    'text' / SGString()\n)\n\n\ntext_configuration = XStruct(\n    'text_session_id' / Int64ub,\n    'text_buffer_version' / Int32ub,\n    'text_options' / XEnum(Int32ub, enum.TextOption),\n    'input_scope' / XEnum(Int32ub, enum.TextInputScope),\n    'max_text_length' / Int32ub,\n    'locale' / SGString(),\n    'prompt' / SGString()\n)\n\n\n_active_title = XStruct(\n    'title_id' / Int32ub,\n    'disposition' / BitStruct(\n        'has_focus' / Flag,\n        'title_location' / XEnum(BitsInteger(15), enum.ActiveTitleLocation)\n    ),\n    'product_id' / UUIDAdapter(),\n    'sandbox_id' / UUIDAdapter(),\n    'aum' / SGString()\n)\n\n\nconsole_status = XStruct(\n    'live_tv_provider' / Int32ub,\n    'major_version' / Int32ub,\n    'minor_version' / Int32ub,\n    'build_number' / Int32ub,\n    'locale' / SGString(),\n    'active_titles' / PrefixedArray(Int16ub, _active_title)\n)\n\n\nactive_surface_change = XStruct(\n    'surface_type' / XEnum(Int16ub, enum.ActiveSurfaceType),\n    'server_tcp_port' / Int16ub,\n    'server_udp_port' / Int16ub,\n    'session_id' / UUIDAdapter(),\n    'render_width' / Int16ub,\n    'render_height' / Int16ub,\n    'master_session_key' / Bytes(0x20)\n)\n\nmessage_structs = {\n    MessageType.Ack: acknowledge,\n    MessageType.Group: Pass,\n    MessageType.LocalJoin: local_join,\n    MessageType.StopActivity: Pass,\n    MessageType.AuxilaryStream: auxiliary_stream,\n    MessageType.ActiveSurfaceChange: active_surface_change,\n    MessageType.Navigate: Pass,\n    MessageType.Json: json,\n    MessageType.Tunnel: Pass,\n    MessageType.ConsoleStatus: console_status,\n    MessageType.TitleTextConfiguration: text_configuration,\n    MessageType.TitleTextInput: title_text_input,\n    MessageType.TitleTextSelection: title_text_selection,\n    MessageType.MirroringRequest: Pass,\n    MessageType.TitleLaunch: title_launch,\n    MessageType.StartChannelRequest: start_channel_request,\n    MessageType.StartChannelResponse: start_channel_response,\n    MessageType.StopChannel: stop_channel,\n    MessageType.System: Pass,\n    MessageType.Disconnect: disconnect,\n    MessageType.TitleTouch: touch,\n    MessageType.Accelerometer: accelerometer,\n    MessageType.Gyrometer: gyrometer,\n    MessageType.Inclinometer: inclinometer,\n    MessageType.Compass: compass,\n    MessageType.Orientation: orientation,\n    MessageType.PairedIdentityStateChanged: paired_identity_state_changed,\n    MessageType.Unsnap: unsnap,\n    MessageType.GameDvrRecord: game_dvr_record,\n    MessageType.PowerOff: power_off,\n    MessageType.MediaControllerRemoved: media_controller_removed,\n    MessageType.MediaCommand: media_command,\n    MessageType.MediaCommandResult: media_command_result,\n    MessageType.MediaState: media_state,\n    MessageType.Gamepad: gamepad,\n    MessageType.SystemTextConfiguration: text_configuration,\n    MessageType.SystemTextInput: system_text_input,\n    MessageType.SystemTouch: touch,\n    MessageType.SystemTextAck: system_text_acknowledge,\n    MessageType.SystemTextDone: system_text_done\n}\n\nstruct = XStruct(\n    'header' / header,\n    'protected_payload' / CryptoTunnel(\n        IfThenElse(this.header.flags.is_fragment, fragment,\n            XSwitch(\n                this.header.flags.msg_type,\n                message_structs,\n                Pass\n            )\n        )\n    )\n)\n"}
{"type": "source_file", "path": "xbox/sg/factory.py", "content": "\"\"\"\nSmartglass packet factory\n\"\"\"\nfrom construct import Container\nfrom xbox.sg.enum import PacketType, MessageType, ClientType\nfrom xbox.sg.packet import simple, message\n\nCHANNEL_CORE = 0\n\n\ndef _message_header(msg_type, channel_id=0, target_participant_id=0,\n                    source_participant_id=0, is_fragment=False,\n                    need_ack=False):\n    \"\"\"\n    Helper method for creating a message header.\n\n    Args:\n        msg_type (int): The message type.\n        channel_id (int): The target channel of the message.\n        target_participant_id (int): The target participant Id.\n        source_participant_id (int): The source participant Id.\n        is_fragment (bool): Whether the message is a fragment.\n        need_ack (bool): Whether the message needs an acknowledge.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.header(\n        sequence_number=0,\n        target_participant_id=target_participant_id,\n        source_participant_id=source_participant_id,\n        flags=Container(\n            need_ack=need_ack,\n            is_fragment=is_fragment,\n            msg_type=msg_type\n        ),\n        channel_id=channel_id,\n        pkt_type=PacketType.Message\n    )\n\n\ndef power_on(liveid):\n    \"\"\"\n    Assemble PowerOn Request message.\n\n    Args:\n        liveid (str): The console LiveId (extracted from the\n                      :class:`DiscoveryResponse` Certificate).\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return simple.struct(\n        header=simple.header(pkt_type=PacketType.PowerOnRequest, version=0),\n        unprotected_payload=simple.power_on_request(liveid=liveid)\n    )\n\n\ndef discovery(client_type=ClientType.Android):\n    \"\"\"\n    Assemble DiscoveryRequest SimpleMessage.\n\n    Args:\n        client_type (:class:`ClientType`): Member of :class:`ClientType`, defaults to\n                           `ClientType.Android`.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return simple.struct(\n        header=simple.header(pkt_type=PacketType.DiscoveryRequest, version=0),\n        unprotected_payload=simple.discovery_request(\n            flags=0, client_type=client_type,\n            minimum_version=0, maximum_version=2\n        )\n    )\n\n\ndef connect(sg_uuid, public_key_type, public_key, iv, userhash, jwt,\n            msg_num, num_start, num_end):\n    \"\"\"\n    Assemble ConnectRequest SimpleMessage.\n\n    Args:\n        sg_uuid (UUID): Client Uuid, randomly generated.\n        public_key_type (:class:`PublicKeyType`): Public Key Type.\n        public_key (bytes): Calculated Public Key, from :class:`Crypto`.\n        iv (bytes): Initialization Vector for this encrypted message.\n        userhash (str): Xbox Live Account userhash.\n        jwt (str): Xbox Live Account JWT / Auth-token.\n        msg_num (int): Current message number (important for fragmentation).\n        num_start (int): Base number start of ConnectRequest fragments.\n        num_end (int): Base number end of ConnectRequest fragments\n                       (base number start + total fragments + 1).\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return simple.struct(\n        header=simple.header(pkt_type=PacketType.ConnectRequest),\n        unprotected_payload=simple.connect_request_unprotected(\n            sg_uuid=sg_uuid, public_key_type=public_key_type,\n            public_key=public_key, iv=iv\n        ),\n        protected_payload=simple.connect_request_protected(\n            userhash=userhash, jwt=jwt, connect_request_num=msg_num,\n            connect_request_group_start=num_start,\n            connect_request_group_end=num_end\n        )\n    )\n\n\ndef message_fragment(msg_type, sequence_begin, sequence_end, data, **kwargs):\n    \"\"\"\n    Assemble fragmented message.\n\n    Args:\n        msg_type (int): Base Message Type.\n        sequence_begin (int): Sequence number with first fragment.\n        sequence_end (int): Last sequence number (+1) containing fragment.\n        data (bytes): Plaintext MessagePacket payload fragment.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            msg_type, is_fragment=True, **kwargs\n        ),\n        protected_payload=message.fragment(\n            sequence_begin=sequence_begin,\n            sequence_end=sequence_end,\n            data=data\n        )\n    )\n\n\ndef acknowledge(low_watermark, processed_list, rejected_list, **kwargs):\n    \"\"\"\n    Assemble acknowledgement message.\n\n    Args:\n        low_watermark (int): Low Watermark.\n        processed_list (list): List of processed message sequence numbers.\n        rejected_list (list): List of rejected message sequence numbers.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.Ack, **kwargs\n        ),\n        protected_payload=message.acknowledge(\n            low_watermark=low_watermark,\n            processed_list=processed_list,\n            rejected_list=rejected_list\n        )\n    )\n\n\ndef json(text, **kwargs):\n    \"\"\"\n    Assemble JSON message.\n\n    Args:\n        text (str): Text string.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.Json,\n            need_ack=True, **kwargs\n        ),\n        protected_payload=message.json(\n            text=text\n        )\n    )\n\n\ndef disconnect(reason, error_code, **kwargs):\n    \"\"\"\n    Assemble Disconnect message.\n\n    Args:\n        reason (:class:`xbox.sg.enum.DisconnectReason`): Disconnect reason.\n        error_code (int): Error code.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.Disconnect, CHANNEL_CORE, **kwargs\n        ),\n        protected_payload=message.disconnect(\n            reason=reason,\n            error_code=error_code\n        )\n    )\n\n\ndef power_off(liveid, **kwargs):\n    \"\"\"\n    Assemble PowerOff message.\n\n    Args:\n        liveid (str): Live ID of console.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.PowerOff, CHANNEL_CORE, **kwargs\n        ),\n        protected_payload=message.power_off(\n            liveid=liveid\n        )\n    )\n\n\ndef local_join(client_info, **kwargs):\n    \"\"\"\n    Assemble LocalJoin message.\n\n    Args:\n        client_info (object): Instance of :class:`WindowsClientInfo`\n                              or :class:`AndroidClientInfo`.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.LocalJoin, CHANNEL_CORE, need_ack=True, **kwargs\n        ),\n        protected_payload=message.local_join(\n            device_type=client_info.DeviceType,\n            native_width=client_info.NativeWidth,\n            native_height=client_info.NativeHeight,\n            dpi_x=client_info.DpiX, dpi_y=client_info.DpiY,\n            device_capabilities=client_info.DeviceCapabilities,\n            client_version=client_info.ClientVersion,\n            os_major_version=client_info.OSMajor,\n            os_minor_version=client_info.OSMinor,\n            display_name=client_info.DisplayName\n        )\n    )\n\n\ndef title_launch(location, uri, **kwargs):\n    \"\"\"\n    Assemble TitleLaunch message.\n\n    Args:\n        location (:class:`ActiveTitleLocation`): Location.\n        uri (str): Uri string for title to launch.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.TitleLaunch, CHANNEL_CORE, **kwargs\n        ),\n        protected_payload=message.title_launch(\n            location=location,\n            uri=uri\n        )\n    )\n\n\ndef start_channel(channel_request_id, title_id, service, activity_id,\n                  **kwargs):\n    \"\"\"\n    Assemble StartChannelRequest message.\n\n    Args:\n        channel_request_id (int): Incrementing Channel Request Id.\n        title_id (int): Title Id, usually 0.\n        service (:class:`MessageTarget`): Member of :class:`MessageTarget`.\n        activity_id (int): Activity Id, usually 0.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.StartChannelRequest, CHANNEL_CORE,\n            need_ack=True, **kwargs\n        ),\n        protected_payload=message.start_channel_request(\n            channel_request_id=channel_request_id,\n            title_id=title_id,\n            service=service,\n            activity_id=activity_id\n        )\n    )\n\n\ndef stop_channel(channel_id, **kwargs):\n    \"\"\"\n    Assemble StopChannel message.\n\n    Args:\n        channel_id (int): Channel Id to stop.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.StopChannel, CHANNEL_CORE, **kwargs\n        ),\n        protected_payload=message.stop_channel(\n            target_channel_id=channel_id\n        )\n    )\n\n\ndef gamepad(timestamp, buttons, l_trigger, r_trigger, l_thumb_x, l_thumb_y,\n            r_thumb_x, r_thumb_y, **kwargs):\n    \"\"\"\n    Assemble gamepad input message.\n\n    Args:\n        timestamp (longlong): Timestamp.\n        buttons (:class:`GamePadButton`): Bitmask of pressed gamepad buttons.\n        l_trigger (float): LT.\n        r_trigger (float): RT.\n        l_thumb_x (float): Position of left thumbstick, X-Axis.\n        l_thumb_y (float): Position of left thumbstick, Y-Axis.\n        r_thumb_x (float): Position of right thumbstick, X-Axis.\n        r_thumb_y (float): Position of right thumbstick, Y-Axis.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.Gamepad, **kwargs\n        ),\n        protected_payload=message.gamepad(\n            timestamp=timestamp, buttons=buttons,\n            left_trigger=l_trigger, right_trigger=r_trigger,\n            left_thumbstick_x=l_thumb_x, left_thumbstick_y=l_thumb_y,\n            right_thumbstick_x=r_thumb_x, right_thumbstick_y=r_thumb_y\n        )\n    )\n\n\ndef unsnap(unknown, **kwargs):\n    \"\"\"\n    Assemble unsnap message.\n\n    Args:\n        unknown (int): Unknown value.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.Unsnap, CHANNEL_CORE, **kwargs\n        ),\n        protected_payload=message.unsnap(\n            unk=unknown\n        )\n    )\n\n\ndef game_dvr_record(start_time_delta, end_time_delta, **kwargs):\n    \"\"\"\n    Assemble Game DVR record message.\n\n    Args:\n        start_time_delta (int): Start Time delta.\n        end_time_delta (int): End Time delta.\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.GameDvrRecord, CHANNEL_CORE,\n            need_ack=True, **kwargs\n        ),\n        protected_payload=message.game_dvr_record(\n            start_time_delta=start_time_delta,\n            end_time_delta=end_time_delta\n        )\n    )\n\n\ndef media_command(request_id, title_id, command, seek_position, **kwargs):\n    \"\"\"\n    Assemble Media Command message.\n\n    Args:\n        request_id (int): Request Id of MediaCommand.\n        title_id (int): Title Id of Application to control.\n        command (:class:`MediaControlCommand`): Media Command.\n        seek_position (ulonglong): Seek position.\n\n     Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.MediaCommand,\n            need_ack=True, **kwargs\n        ),\n        protected_payload=message.media_command(\n            request_id=request_id,\n            title_id=title_id,\n            command=command,\n            seek_position=seek_position\n        )\n    )\n\n\ndef systemtext_input(session_id, base_version, submitted_version, total_text_len,\n                     selection_start, selection_length, flags, text_chunk_byte_start,\n                     text_chunk, delta=None, **kwargs):\n    \"\"\"\n    Assemble SystemText Input message\n\n    Args:\n        session_id (int): Textt session Id\n        base_version (int): Base version\n        submitted_version (int): Submitted Version\n        total_text_len (int): Total text length\n        selection_start (int): Selection start\n        selection_length (int): Selection length\n        flags (int): Input flags\n        text_chunk_byte_start (int): Start byte of text chunk\n        text_chunk (str): Actual text to send\n        delta (NoneType): Unknown\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.SystemTextInput,\n            need_ack=True, **kwargs\n        ),\n        protected_payload=message.system_text_input(\n            text_session_id=session_id,\n            base_version=base_version,\n            submitted_version=submitted_version,\n            total_text_byte_len=total_text_len,\n            selection_start=selection_start,\n            selection_length=selection_length,\n            flags=flags,\n            text_chunk_byte_start=text_chunk_byte_start,\n            text_chunk=text_chunk\n            # delta=delta\n        )\n    )\n\n\ndef systemtext_ack(session_id, text_version, **kwargs):\n    \"\"\"\n    Assemble SystemText Acknowledge message\n\n    Args:\n        session_id (int): Text session Id\n        text_version (int): Text version to acknowledge\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.SystemTextAck,\n            need_ack=True, **kwargs\n        ),\n        protected_payload=message.system_text_acknowledge(\n            text_session_id=session_id,\n            text_version_ack=text_version\n        )\n    )\n\n\ndef systemtext_done(session_id, text_version, flags, result, **kwargs):\n    \"\"\"\n    Assemble SystemText Done message\n\n    Args:\n        session_id (int): Text session Id\n        text_version (int): Text version\n        flags (int): Flags\n        result (:class:`TextResult`): Text result\n\n    Returns:\n        :class:`XStructObj`: Instance of :class:`:class:`XStructObj``.\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.SystemTextDone,\n            need_ack=True, **kwargs\n        ),\n        protected_payload=message.system_text_done(\n            text_session_id=session_id,\n            text_version=text_version,\n            flags=flags,\n            result=result\n        )\n    )\n\n\ndef title_auxiliary_stream(**kwargs):\n    \"\"\"\n    Assemble Auxiliary Stream message\n\n    Returns:\n         :class:`XStructObj`: Instance of :class:`XStructObj`\n    \"\"\"\n    return message.struct(\n        header=_message_header(\n            MessageType.AuxilaryStream,\n            need_ack=True, **kwargs\n        ),\n        protected_payload=message.auxiliary_stream(\n            connection_info_flag=0\n        )\n    )\n"}
{"type": "source_file", "path": "xbox/rest/schemas/auth.py", "content": "from typing import List\nfrom pydantic import BaseModel\nfrom xbox.webapi.authentication.manager import AuthenticationManager\n\nfrom xbox.webapi.authentication.models import OAuth2TokenResponse, XSTSResponse\n\nclass AuthSessionConfig(BaseModel):\n    client_id: str\n    client_secret: str\n    redirect_uri: str\n    scopes: List[str]\n\nclass AuthenticationStatus(BaseModel):\n    oauth: OAuth2TokenResponse\n    xsts: XSTSResponse\n    session_config: AuthSessionConfig\n"}
{"type": "source_file", "path": "xbox/sg/utils/adapters.py", "content": "\"\"\"\nAdapters and other Construct utility classes\n\"\"\"\nimport json\nimport construct\nfrom io import BytesIO\nfrom enum import Enum\nfrom uuid import UUID\nfrom cryptography import x509\nfrom cryptography.x509.oid import NameOID\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.serialization import Encoding\n\nfrom xbox.sg.enum import PacketType\n\n\nclass CryptoTunnel(construct.Subconstruct):\n    \"\"\"\n    Adapter/Tunnel for inline decryption of protected payloads.\n\n    Depending on the packet-type, acquiring the `Initialization Vector` and\n    decrypting the `protected payload` happens differently:\n    * ConnectResponse: The `IV` is delivered in the `unprotected payload`\n    section of the packet and can be used directly\n    * Messages: The `IV` is generated by encrypting the first 16 bytes of\n    the packet header using the IV key.\n\n    Inline encryption using this Tunnel is not (yet) possible due to\n    limitations in Construct. As explained above, the `IV` for Messages is\n    generated by encrypting the first 16 bytes of the header. However, there's\n    currently no method of determining the length of the payload without\n    building it first. Therefor, the `IV` wouldn't be correct.\n    \"\"\"\n    def _parse(self, stream, context, path):\n        return self.subcon._parse(self.decrypt(stream, context), context, path)\n\n    @staticmethod\n    def decrypt(stream, context):\n        # To simplify message definition, we allow Switch to be a subcon\n        # of CryptoAdapter\n        # However, as a side effect, this function will also be called when the\n        # stream is EOF (has no protected payload)\n        # To compensate for this, we check if there's at least a hash + 1 block\n        # left in the stream\n        pos = stream.tell()\n        if len(stream.read(48)) != 48:\n            return None\n\n        crypto = context.get('_crypto', None) or context._.get('_crypto', None)\n\n        if not crypto:\n            raise ValueError(\"Crypto instance not passed in context\")\n\n        stream.seek(0)\n        buf = stream.read()\n\n        if not crypto.verify(buf[:-32], buf[-32:]):\n            raise ValueError(\"Checksum doesn't match\")\n\n        connect_types = [PacketType.ConnectRequest, PacketType.ConnectResponse]\n        if context.header.pkt_type in connect_types:\n            iv = context.unprotected_payload.iv\n        elif context.header.pkt_type == PacketType.Message:\n            iv = crypto.generate_iv(buf[:16])\n        else:\n            raise ValueError(\"Incompatible packet type\")\n\n        buf = buf[pos:]\n        decrypted = crypto.decrypt(iv, buf)\n        decrypted = decrypted[:context.header.protected_payload_length]\n\n        return BytesIO(decrypted)\n\n    def _emitparse(self, code):\n        # Hack\n        code.append('from xbox.sg.utils.adapters import CryptoTunnel')\n        subcode = self.subcon._emitparse(code)\n        return subcode.replace('(io', '(CryptoTunnel.decrypt(io, this)')\n\n\nclass JsonAdapter(construct.Adapter):\n    \"\"\"\n    Construct-Adapter for JSON field.\n\n    Parses and dumps JSON.\n    \"\"\"\n    def _encode(self, obj, context, path):\n        if not isinstance(obj, dict):\n            raise TypeError('Object not of type dict')\n        return json.dumps(obj, separators=(',', ':'), sort_keys=True)\n\n    def _decode(self, obj, context, path):\n        return json.loads(obj)\n\n    def _emitparse(self, code):\n        code.append('import json')\n        return 'json.loads({})'.format(self.subcon._emitparse(code))\n\n\nclass UUIDAdapter(construct.Adapter):\n    def __init__(self, encoding=None):\n        \"\"\"\n        Construct-Adapter for UUID field.\n\n        Parses either `utf8` encoded or raw byte strings into :class:`UUID`\n        instances.\n\n        Args:\n            encoding (str): The encoding to use.\n        \"\"\"\n        if encoding:\n            super(self.__class__, self).__init__(SGString(encoding))\n        else:\n            super(self.__class__, self).__init__(construct.Bytes(0x10))\n\n    def _encode(self, obj, context, path):\n        if not isinstance(obj, UUID):\n            raise TypeError('Object not of type UUID')\n        if isinstance(self.subcon, construct.Bytes):\n            return obj.bytes\n        else:\n            return str(obj).upper()\n\n    def _decode(self, obj, context, path):\n        if isinstance(self.subcon, construct.Bytes):\n            return UUID(bytes=obj)\n        else:\n            return UUID(obj)\n\n    def _emitparse(self, code):\n        code.append('from uuid import UUID')\n        subcon_code = self.subcon._emitparse(code)\n        if isinstance(self.subcon, construct.Bytes):\n            return 'UUID(bytes={})'.format(subcon_code)\n        return 'UUID({})'.format(subcon_code)\n\n\nclass CertificateAdapter(construct.Adapter):\n    def __init__(self):\n        \"\"\"\n        Construct-Adapter for Certificate field.\n\n        Parses and dumps the DER certificate as used in the discovery response\n        messages.\n        \"\"\"\n        super(self.__class__, self).__init__(PrefixedBytes(construct.Int16ub))\n\n    def _encode(self, obj, context, path):\n        if not isinstance(obj, CertificateInfo):\n            raise TypeError('Object not of type CertificateInfo')\n        return obj.dump()\n\n    def _decode(self, obj, context, path):\n        return CertificateInfo(obj)\n\n    def _emitparse(self, code):\n        code.append('from xbox.sg.utils.adapters import CertificateInfo')\n        return 'CertificateInfo({})'.format(self.subcon._emitparse(code))\n\n\nclass CertificateInfo(object):\n    def __init__(self, raw_cert):\n        \"\"\"\n        Helper class for parsing a x509 certificate.\n\n        Extracts `common_name` and `public_key` from the certificate.\n\n        Args:\n            raw_cert (bytes): The DER certificate to parse.\n        \"\"\"\n        self.cert = x509.load_der_x509_certificate(raw_cert, default_backend())\n        self.liveid = self.cert.subject.get_attributes_for_oid(\n            NameOID.COMMON_NAME)[0].value\n        self.pubkey = self.cert.public_key()\n\n    def dump(self, encoding=Encoding.DER):\n        return self.cert.public_bytes(encoding)\n\n    def __repr__(self):\n        return '<%s: liveid=%s, pubkey=%s>' % (\n            self.__class__.__name__, self.liveid, self.pubkey\n        )\n\n    def __eq__(self, other):\n        return self.cert == other.cert\n\n\nclass XSwitch(construct.Switch):\n    def _emitparse(self, code):\n        if not any([isinstance(k, Enum) for k in self.cases.keys()]):\n            return super(XSwitch, self)._emitparse(code)\n\n        fname = \"factory_%s\" % code.allocateId()\n        code.append(\"%s = {%s}\" % (fname, \", \".join(\"%r : lambda io,this: %s\" % (key.value, sc._compileparse(code))\n                                                    for key, sc in self.cases.items()), ))\n\n        defaultfname = \"compiled_%s\" % code.allocateId()\n        code.append(\"%s = lambda io,this: %s\" % (defaultfname, self.default._compileparse(code), ))\n        return \"%s.get(%s.value, %s)(io, this)\" % (fname, self.keyfunc, defaultfname)\n\n\nclass XEnum(construct.Adapter):\n    def __init__(self, subcon, enum=None):\n        \"\"\"\n        Construct-Adapter for Enum field.\n\n        Parses numeric fields into `XEnumInt`'s, which display the Enum name and value.\n\n        Args:\n            subcon (Construct): The subcon to adapt.\n            enum (Enum): The enum to parse into.\n        \"\"\"\n        super(XEnum, self).__init__(subcon)\n        self.enum = enum\n\n    def _encode(self, obj, context, path):\n        if isinstance(obj, int):\n            return obj\n        return obj.value\n\n    def _decode(self, obj, context, path):\n        if not self.enum:\n            return obj\n        return self.enum(obj)\n\n    def _emitparse(self, code):\n        if not self.enum:\n            return self.subcon._emitparse(code)\n\n        code.append('from {} import {}'.format(self.enum.__module__, self.enum.__name__))\n        return '{}({})'.format(self.enum.__name__, self.subcon._emitparse(code))\n\n\nclass XInject(construct.Construct):\n    def __init__(self, code):\n        super(XInject, self).__init__()\n        self.flagbuildnone = True\n        self.name = '__inject'\n        self.code = code\n\n    def _parse(self, stream, context, path):\n        pass\n\n    def _build(self, obj, stream, context, path):\n        pass\n\n    def _sizeof(self, context, path):\n        return 0\n\n    def _emitparse(self, code):\n        code.append(self.code)\n\n\nclass TerminatedField(construct.Subconstruct):\n    def __init__(self, subcon, length=1, pattern=b'\\x00'):\n        \"\"\"\n        A custom :class:`Subconstruct` that adds a termination character at\n        the end of the child struct.\n\n        Args:\n            subcon (Construct): The subcon to add the terminated character to.\n            length (int): The amount of termination characters to add.\n            pattern (bytes): The termination pattern to use.\n        \"\"\"\n        super(self.__class__, self).__init__(subcon)\n        self.padding = construct.Padding(length, pattern)\n\n    def _parse(self, stream, context, path):\n        obj = self.subcon._parse(stream, context, path)\n        self.padding._parse(stream, context, path)\n\n        return obj\n\n    def _build(self, obj, stream, context, path):\n        subobj = self.subcon._build(obj, stream, context, path)\n        self.padding._build(obj, stream, context, path)\n\n        return subobj\n\n    def _sizeof(self, context, path):\n        return self.subcon._sizeof(context, path) + 1\n\n    def _emitparse(self, code):\n        return '({}, {})[0]'.format(\n            self.subcon._emitparse(code), self.padding._emitparse(code)\n        )\n\n\ndef SGString(encoding='utf8'):\n    \"\"\"\n    Defines a null terminated `PascalString`.\n\n    The Smartglass protocol seems to always add a termination character\n    behind a length prefixed string.\n    This utility function combines a `PascalString` with a `TerminatedField`.\n\n    Args:\n        encoding (str): The string encoding to use for the `PascalString`.\n\n    Returns:\n        SGString: A null byte terminated `PascalString`.\n    \"\"\"\n    return TerminatedField(construct.PascalString(construct.Int16ub, encoding))\n\n\ndef PrefixedBytes(lengthfield):\n    \"\"\"\n    Defines a length prefixed bytearray.\n\n    Args:\n        lengthfield (:class:`Subconstruct`): The length subcon.\n\n    Returns:\n        PrefixedBytes: A length prefixed bytesarray\n    \"\"\"\n    return construct.Prefixed(lengthfield, construct.GreedyBytes)\n\n\nclass FieldIn(object):\n    \"\"\"\n    Helper class for creating an `in` conditional.\n\n    Operates like `field in options`.\n\n    Args:\n        field: The struct field to use.\n        options (list): A list with options to execute the `in` conditional on.\n\n    Returns:\n        bool: Whether or not the field value was in the options.\n    \"\"\"\n    def __init__(self, field, options):\n        self.field = field\n        self.options = options\n\n    def __call__(self, context):\n        return context.get(self.field, None) in self.options\n\n    def __repr__(self):\n        if any([isinstance(e, Enum) for e in self.options]):\n            return 'this.{}.value in {}'.format(self.field, [e.value for e in self.options])\n        return 'this.{} in {}'.format(self.field, self.options)\n"}
{"type": "source_file", "path": "xbox/sg/utils/events.py", "content": "\"\"\"\nWrapper around asyncio's tasks\n\"\"\"\nimport asyncio\n\n\nclass Event(object):\n    def __init__(self, asynchronous: bool = False):\n        self.handlers = []\n        self.asynchronous = asynchronous\n\n    def add(self, handler):\n        if not callable(handler):\n            raise TypeError(\"Handler should be callable\")\n        self.handlers.append(handler)\n\n    def remove(self, handler):\n        if handler in self.handlers:\n            self.handlers.remove(handler)\n\n    def __iadd__(self, handler):\n        self.add(handler)\n        return self\n\n    def __isub__(self, handler):\n        self.remove(handler)\n        return self\n\n    def __call__(self, *args, **kwargs):\n        for handler in self.handlers:\n            if self.asynchronous:\n                asyncio.create_task(handler(*args, **kwargs))\n            else:\n                handler(*args, **kwargs)\n"}

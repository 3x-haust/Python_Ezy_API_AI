{"repo_info": {"repo_name": "python-samples-fastapi-restful", "repo_owner": "nanotaboada", "repo_url": "https://github.com/nanotaboada/python-samples-fastapi-restful"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/test_main.py", "content": "# ------------------------------------------------------------------------------\n# Test\n# ------------------------------------------------------------------------------\n\nimport json\nfrom tests.player_stub import existing_player, nonexistent_player, unknown_player\n\nPATH = \"/players/\"\n\n# GET /players/ ----------------------------------------------------------------\n\n\ndef test_given_get_when_request_path_has_no_id_then_response_status_code_should_be_200_ok(client):\n    \"\"\"\n        Given   GET /players/\n        when    request path has no ID\n        then    response Status Code should be 200 OK\n    \"\"\"\n    response = client.get(PATH)\n    assert response.status_code == 200\n\n\ndef test_given_get_when_request_path_has_no_id_then_response_body_should_be_collection_of_players(client):\n    \"\"\"\n        Given   GET /players/\n        when    request path has no ID\n        then    response Status Code should be collection of players\n    \"\"\"\n    response = client.get(PATH)\n    players = response.json()\n    player_id = 0\n    for player in players:\n        player_id += 1\n        assert player[\"id\"] == player_id\n\n# GET /players/{player_id} -----------------------------------------------------\n\n\ndef test_given_get_when_request_path_is_nonexistent_id_then_response_status_code_should_be_404_not_found(client):\n    \"\"\"\n        Given   GET /players/{player_id}\n        when    request path is nonexistent ID\n        then    response Status Code should be 404 (Not Found)\n    \"\"\"\n    player_id = nonexistent_player().id\n    response = client.get(PATH + str(player_id))\n    assert response.status_code == 404\n\n\ndef test_given_get_when_request_path_is_existing_id_then_response_status_code_should_be_200_ok(client):\n    \"\"\"\n        Given   GET /players/{player_id}\n        when    request path is existing ID\n        then    response Status Code should be 200 (OK)\n    \"\"\"\n    player_id = existing_player().id\n    response = client.get(PATH + str(player_id))\n    assert response.status_code == 200\n\n\ndef test_given_get_when_request_path_is_existing_id_then_response_body_should_be_matching_player(client):\n    \"\"\"\n        Given   GET /players/{player_id}\n        when    request path is existing ID\n        then    response body should be matching Player\n    \"\"\"\n    player_id = existing_player().id\n    response = client.get(PATH + str(player_id))\n    player = response.json()\n    assert player[\"id\"] == player_id\n\n# GET /players/squadnumber/{squad_number} --------------------------------------\n\n\ndef test_given_get_when_request_path_is_nonexistent_squad_number_then_response_status_code_should_be_404_not_found(client):\n    \"\"\"\n        Given   GET /players/squadnumber/{squad_number}\n        when    request path is nonexistent Squad Number\n        then    response Status Code should be 404 (Not Found)\n    \"\"\"\n    squad_number = nonexistent_player().squad_number\n    response = client.get(PATH + \"squadnumber\" + \"/\" + str(squad_number))\n    assert response.status_code == 404\n\n\ndef test_given_get_when_request_path_is_existing_squad_number_then_response_status_code_should_be_200_ok(client):\n    \"\"\"\n        Given   GET /players/squadnumber/{squad_number}\n        when    request path is existing Squad Number\n        then    response Status Code should be 200 (OK)\n    \"\"\"\n    squad_number = existing_player().squad_number\n    response = client.get(PATH + \"squadnumber\" + \"/\" + str(squad_number))\n    assert response.status_code == 200\n\n\ndef test_given_get_when_request_path_is_existing_squad_number_then_response_body_should_be_matching_player(client):\n    \"\"\"\n        Given   GET /players/squadnumber/{squad_number}\n        when    request path is existing Squad Number\n        then    response body should be matching Player\n    \"\"\"\n    squad_number = existing_player().squad_number\n    response = client.get(PATH + \"squadnumber\" + \"/\" + str(squad_number))\n    player = response.json()\n    assert player[\"squadNumber\"] == squad_number\n\n# POST /players/ ---------------------------------------------------------------\n\n\ndef test_given_post_when_request_body_is_empty_then_response_status_code_should_be_422_unprocessable_entity(client):\n    \"\"\"\n        Given   POST /players/\n        when    request body is empty\n        then    response Status Code should be 422 (Unprocessable Entity)\n    \"\"\"\n    body = {}\n    response = client.post(PATH, data=body)\n    assert response.status_code == 422\n\n\ndef test_given_post_when_request_body_is_existing_player_then_response_status_code_should_be_409_conflict(client):\n    \"\"\"\n        Given   POST /players/\n        when    request body is existing Player\n        then    response Status Code should be 409 (Conflict)\n    \"\"\"\n    player = existing_player()\n    body = json.dumps(player.__dict__)\n    response = client.post(PATH, data=body)\n    assert response.status_code == 409\n\n\ndef test_given_post_when_request_body_is_nonexistent_player_then_response_status_code_should_be_201_created(client):\n    \"\"\"\n        Given   POST /players/\n        when    request body is nonexistent Player\n        then    response Status Code should be 201 (Created)\n    \"\"\"\n    player = nonexistent_player()\n    body = json.dumps(player.__dict__)\n    response = client.post(PATH, data=body)\n    assert response.status_code == 201\n\n# PUT /players/{player_id} -----------------------------------------------------\n\n\ndef test_given_put_when_request_body_is_empty_then_response_status_code_should_be_422_unprocessable_entity(client):\n    \"\"\"\n        Given   PUT /players/{player_id}\n        when    request body is empty\n        then    response Status Code should be 422 (Unprocessable Entity)\n    \"\"\"\n    player_id = existing_player().id\n    body = {}\n    response = client.put(PATH + str(player_id), data=body)\n    assert response.status_code == 422\n\n\ndef test_given_put_when_request_path_is_unknown_id_then_response_status_code_should_be_404_not_found(client):\n    \"\"\"\n        Given   PUT /players/{player_id}\n        when    request path is unknown ID\n        then    response Status Code should be 404 (Not Found)\n    \"\"\"\n    player_id = unknown_player().id\n    player = unknown_player()\n    body = json.dumps(player.__dict__)\n    response = client.put(PATH + str(player_id), data=body)\n    assert response.status_code == 404\n\n\ndef test_given_put_when_request_path_is_existing_id_then_response_status_code_should_be_204_no_content(client):\n    \"\"\"\n        Given   PUT /players/{player_id}\n        when    request path is existing ID\n        then    response Status Code should be 204 (No Content)\n    \"\"\"\n    player_id = existing_player().id\n    player = existing_player()\n    player.first_name = \"Emiliano\"\n    player.middle_name = \"\"\n    body = json.dumps(player.__dict__)\n    response = client.put(PATH + str(player_id), data=body)\n    assert response.status_code == 204\n\n# DELETE /players/{player_id} --------------------------------------------------\n\n\ndef test_given_delete_when_request_path_is_unknown_id_then_response_status_code_should_be_404_not_found(client):\n    \"\"\"\n        Given   DELETE /players/{player_id}\n        when    request path is unknown ID\n        then    response Status Code should be 404 (Not Found)\n    \"\"\"\n    player_id = unknown_player().id\n    response = client.delete(PATH + str(player_id))\n    assert response.status_code == 404\n\n\ndef test_given_delete_when_request_path_is_existing_id_then_response_status_code_should_be__204_no_content(client):\n    \"\"\"\n        Given   DELETE /players/{player_id}\n        when    request path is existing ID\n        then    response Status Code should be 204 (No Content)\n    \"\"\"\n    player_id = 12  # nonexistent_player() previously created\n    response = client.delete(PATH + str(player_id))\n    assert response.status_code == 204\n"}
{"type": "test_file", "path": "tests/player_stub.py", "content": "class Player:\n    \"\"\"\n    Test stub representing a Player.\n    \"\"\"\n\n    def __init__(\n        self,\n        id=None,\n        first_name=None,\n        middle_name=None,\n        last_name=None,\n        date_of_birth=None,\n        squad_number=None,\n        position=None,\n        abbr_position=None,\n        team=None,\n        league=None,\n        starting11=None\n    ):\n        self.id = id\n        self.first_name = first_name\n        self.middle_name = middle_name\n        self.last_name = last_name\n        self.date_of_birth = date_of_birth\n        self.squad_number = squad_number\n        self.position = position\n        self.abbr_position = abbr_position\n        self.team = team\n        self.league = league\n        self.starting11 = starting11\n\n\ndef existing_player():\n    \"\"\"\n    Creates a test stub for an existing Player.\n    \"\"\"\n    return Player(\n        id=1,\n        first_name=\"Damián\",\n        middle_name=\"Emiliano\",\n        last_name=\"Martínez\",\n        date_of_birth=\"1992-09-02T00:00:00.000Z\",\n        squad_number=23,\n        position=\"Goalkeeper\",\n        abbr_position=\"GK\",\n        team=\"Aston Villa FC\",\n        league=\"Premier League\",\n        starting11=1,\n    )\n\n\ndef nonexistent_player():\n    \"\"\"\n    Creates a test stub for a nonexistent (new) Player.\n    \"\"\"\n    return Player(\n        id=12,\n        first_name=\"Leandro\",\n        middle_name=\"Daniel\",\n        last_name=\"Paredes\",\n        date_of_birth=\"1994-06-29T00:00:00.000Z\",\n        squad_number=5,\n        position=\"Defensive Midfield\",\n        abbr_position=\"DM\",\n        team=\"AS Roma\",\n        league=\"Serie A\",\n        starting11=0,\n    )\n\n\ndef unknown_player():\n    \"\"\"\n    Creates a test stub for an unknown Player.\n    \"\"\"\n    return Player(\n        id=999,\n        first_name=\"John\",\n        last_name=\"Doe\",\n        squad_number=\"999\",\n        position=\"Lipsum\"\n    )\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "import warnings\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom main import app\n\n# Suppress the DeprecationWarning from httpx\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n\n\n@pytest.fixture(scope=\"module\")\ndef client():\n    with TestClient(app) as test_client:\n        yield test_client\n"}
{"type": "source_file", "path": "data/player_database.py", "content": "# ------------------------------------------------------------------------------\n# Database\n# ------------------------------------------------------------------------------\n\nimport logging\nfrom typing import AsyncGenerator\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker, declarative_base\n\nDATABASE_URL = \"sqlite+aiosqlite:///./data/players-sqlite3.db\"\n\nlogger = logging.getLogger(\"uvicorn\")\nlogging.getLogger(\"sqlalchemy.engine.Engine\").handlers = logger.handlers\n\nasync_engine = create_async_engine(\n    DATABASE_URL,\n    connect_args={\"check_same_thread\": False},\n    echo=True\n)\n\nasync_sessionmaker = sessionmaker(\n    bind=async_engine,\n    class_=AsyncSession,\n    autocommit=False,\n    autoflush=False\n)\n\nBase = declarative_base()\n\n\nasync def generate_async_session() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"\n    Dependency function to yield an async SQLAlchemy ORM session.\n\n    Yields:\n        AsyncSession: An instance of an async SQLAlchemy ORM session.\n    \"\"\"\n    async with async_sessionmaker() as async_session:\n        yield async_session\n"}
{"type": "source_file", "path": "main.py", "content": "# ------------------------------------------------------------------------------\n# Main\n# ------------------------------------------------------------------------------\n\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom fastapi_cache import FastAPICache\nfrom fastapi_cache.backends.inmemory import InMemoryBackend\nfrom routes import player_route\n\n\n@asynccontextmanager\nasync def lifespan_context_manager(_):\n    \"\"\"\n    Context manager for the FastAPI app lifespan.\n\n    Initializes  FastAPICache with an InMemoryBackend for the duration of the app's lifespan.\n    \"\"\"\n    FastAPICache.init(InMemoryBackend())\n    yield\n\napp = FastAPI(lifespan=lifespan_context_manager,\n              title=\"python-samples-fastapi-restful\",\n              description=\"🧪 Proof of Concept for a RESTful API made with Python 3 and FastAPI\",\n              version=\"1.0.0\",)\n\napp.include_router(player_route.api_router)\n"}
{"type": "source_file", "path": "schemas/__init__.py", "content": ""}
{"type": "source_file", "path": "routes/__init__.py", "content": ""}
{"type": "source_file", "path": "routes/player_route.py", "content": "# ------------------------------------------------------------------------------\n# Route\n# ------------------------------------------------------------------------------\n\nfrom typing import List\nfrom fastapi import APIRouter, Body, Depends, HTTPException, status, Path\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom fastapi_cache import FastAPICache\nfrom fastapi_cache.decorator import cache\n\nfrom data.player_database import generate_async_session\nfrom models.player_model import PlayerModel\nfrom services import player_service\n\napi_router = APIRouter()\n\nCACHING_TIME_IN_SECONDS = 600\n\n# POST -------------------------------------------------------------------------\n\n\n@api_router.post(\n    \"/players/\",\n    status_code=status.HTTP_201_CREATED,\n    summary=\"Creates a new Player\",\n    tags=[\"Players\"]\n)\nasync def post_async(\n    player_model: PlayerModel = Body(...),\n    async_session: AsyncSession = Depends(generate_async_session)\n):\n    \"\"\"\n    Endpoint to create a new player.\n\n    Args:\n        player_model (PlayerModel): The Pydantic model representing the Player to create.\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n\n    Raises:\n        HTTPException: HTTP 409 Conflict error if the Player already exists.\n    \"\"\"\n    player = await player_service.retrieve_by_id_async(async_session, player_model.id)\n    if player:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT)\n    await player_service.create_async(async_session, player_model)\n    await FastAPICache.clear()\n\n# GET --------------------------------------------------------------------------\n\n\n@api_router.get(\n    \"/players/\",\n    response_model=List[PlayerModel],\n    status_code=status.HTTP_200_OK,\n    summary=\"Retrieves a collection of Players\",\n    tags=[\"Players\"]\n)\n@cache(expire=CACHING_TIME_IN_SECONDS)\nasync def get_all_async(\n    async_session: AsyncSession = Depends(generate_async_session)\n):\n    \"\"\"\n    Endpoint to retrieve all players.\n\n    Args:\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n\n    Returns:\n        List[PlayerModel]: A list of Pydantic models representing all players.\n    \"\"\"\n    players = await player_service.retrieve_all_async(async_session)\n    return players\n\n\n@api_router.get(\n    \"/players/{player_id}\",\n    response_model=PlayerModel,\n    status_code=status.HTTP_200_OK,\n    summary=\"Retrieves a Player by its Id\",\n    tags=[\"Players\"]\n)\n@cache(expire=CACHING_TIME_IN_SECONDS)\nasync def get_by_id_async(\n    player_id: int = Path(..., title=\"The ID of the Player\"),\n    async_session: AsyncSession = Depends(generate_async_session)\n):\n    \"\"\"\n    Endpoint to retrieve a Player by its ID.\n\n    Args:\n        player_id (int): The ID of the Player to retrieve.\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n\n    Returns:\n        PlayerModel: The Pydantic model representing the matching Player.\n\n    Raises:\n        HTTPException: Not found error if the Player with the specified ID does not exist.\n    \"\"\"\n    player = await player_service.retrieve_by_id_async(async_session, player_id)\n    if not player:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n    return player\n\n\n@api_router.get(\n    \"/players/squadnumber/{squad_number}\",\n    response_model=PlayerModel,\n    status_code=status.HTTP_200_OK,\n    summary=\"Retrieves a Player by its Squad Number\",\n    tags=[\"Players\"]\n)\n@cache(expire=CACHING_TIME_IN_SECONDS)\nasync def get_by_squad_number_async(\n    squad_number: int = Path(..., title=\"The Squad Number of the Player\"),\n    async_session: AsyncSession = Depends(generate_async_session)\n):\n    \"\"\"\n    Endpoint to retrieve a Player by its Squad Number.\n\n    Args:\n        squad_number (int): The Squad Number of the Player to retrieve.\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n\n    Returns:\n        PlayerModel: The Pydantic model representing the matching Player.\n\n    Raises:\n        HTTPException: HTTP 404 Not Found error if the Player with the specified Squad Number does not exist.\n    \"\"\"\n    player = await player_service.retrieve_by_squad_number_async(async_session, squad_number)\n    if not player:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n    return player\n\n# PUT --------------------------------------------------------------------------\n\n\n@api_router.put(\n    \"/players/{player_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary=\"Updates an existing Player\",\n    tags=[\"Players\"]\n)\nasync def put_async(\n    player_id: int = Path(..., title=\"The ID of the Player\"),\n    player_model: PlayerModel = Body(...),\n    async_session: AsyncSession = Depends(generate_async_session)\n):\n    \"\"\"\n    Endpoint to entirely update an existing Player.\n\n    Args:\n        player_id (int): The ID of the Player to update.\n        player_model (PlayerModel): The Pydantic model representing the Player to update.\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n\n    Raises:\n        HTTPException: HTTP 404 Not Found error if the Player with the specified ID does not exist.\n    \"\"\"\n    player = await player_service.retrieve_by_id_async(async_session, player_id)\n    if not player:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n    await player_service.update_async(async_session, player_model)\n    await FastAPICache.clear()\n\n# DELETE -----------------------------------------------------------------------\n\n\n@api_router.delete(\n    \"/players/{player_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary=\"Deletes an existing Player\",\n    tags=[\"Players\"]\n)\nasync def delete_async(\n    player_id: int = Path(..., title=\"The ID of the Player\"),\n    async_session: AsyncSession = Depends(generate_async_session)\n):\n    \"\"\"\n    Endpoint to delete an existing Player.\n\n    Args:\n        player_id (int): The ID of the Player to delete.\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n\n    Raises:\n        HTTPException: HTTP 404 Not Found error if the Player with the specified ID does not exist.\n    \"\"\"\n    player = await player_service.retrieve_by_id_async(async_session, player_id)\n    if not player:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n    await player_service.delete_async(async_session, player_id)\n    await FastAPICache.clear()\n"}
{"type": "source_file", "path": "models/__init__.py", "content": ""}
{"type": "source_file", "path": "services/__init__.py", "content": ""}
{"type": "source_file", "path": "schemas/player_schema.py", "content": "# ------------------------------------------------------------------------------\n# Schema\n# ------------------------------------------------------------------------------\n\nfrom sqlalchemy import Column, String, Integer, Boolean\nfrom data.player_database import Base\n\n\nclass Player(Base):\n    \"\"\"\n    SQLAlchemy schema describing a database table of football players.\n\n    Attributes:\n        id (Integer): The primary key for the player record.\n        first_name (String): The first name of the player (not nullable).\n        middle_name (String): The middle name of the player.\n        last_name (String): The last name of the player (not nullable).\n        date_of_birth (String): The date of birth of the player.\n        squad_number (Integer): The squad number of the player (not nullable, unique).\n        position (String): The playing position of the player (not nullable).\n        abbr_position (String): The abbreviated form of the player's position.\n        team (String): The team to which the player belongs.\n        league (String): The league where the team plays.\n        starting11 (Boolean): Indicates if the player is in the starting 11.\n    \"\"\"\n\n    __tablename__ = \"players\"\n\n    id = Column(Integer, primary_key=True)\n    first_name = Column(String, name='firstName', nullable=False)\n    middle_name = Column(String, name='middleName')\n    last_name = Column(String, name='lastName', nullable=False)\n    date_of_birth = Column(String, name=\"dateOfBirth\")\n    squad_number = Column(Integer, name='squadNumber', unique=True, nullable=False)\n    position = Column(String, nullable=False)\n    abbr_position = Column(String, name='abbrPosition')\n    team = Column(String)\n    league = Column(String)\n    starting11 = Column(Boolean)\n"}
{"type": "source_file", "path": "models/player_model.py", "content": "# ------------------------------------------------------------------------------\n# Model\n# ------------------------------------------------------------------------------\n\nfrom typing import Optional\nfrom pydantic import BaseModel, ConfigDict\nfrom pydantic.alias_generators import to_camel\n\n\nclass MainModel(BaseModel):\n    \"\"\"\n    Base model configuration for all Pydantic models in the application.\n\n    This class sets a common configuration for alias generation and name population\n    for any model that inherits from it. It uses camelCase for JSON field names.\n\n    Attributes:\n        model_config (ConfigDict): Configuration for Pydantic models, including:\n            alias_generator (function): A function to generate field aliases.\n                Here, it uses `to_camel` to convert field names to camelCase.\n            populate_by_name (bool): Allows population of fields by name when using Pydantic models.\n    \"\"\"\n    model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)\n\n\nclass PlayerModel(MainModel):\n    \"\"\"\n    Pydantic model representing a football Player.\n\n    Attributes:\n        id (int): The unique identifier for the Player.\n        first_name (str): The first name of the Player.\n        middle_name (Optional[str]): The middle name of the Player, if any.\n        last_name (str): The last name of the Player.\n        date_of_birth (Optional[str]): The date of birth of the Player, if provided.\n        squad_number (int): The unique squad number assigned to the Player.\n        position (str): The playing position of the Player.\n        abbr_position (Optional[str]): The abbreviated form of the Player's position, if any.\n        team (Optional[str]): The team to which the Player belongs, if any.\n        league (Optional[str]): The league where the team plays, if any.\n        starting11 (Optional[bool]): Indicates if the Player is in the starting 11, if provided.\n    \"\"\"\n    id: int\n    first_name: str\n    middle_name: Optional[str]\n    last_name: str\n    date_of_birth: Optional[str]\n    squad_number: int\n    position: str\n    abbr_position: Optional[str]\n    team: Optional[str]\n    league: Optional[str]\n    starting11: Optional[bool]\n"}
{"type": "source_file", "path": "services/player_service.py", "content": "# ------------------------------------------------------------------------------\n# Service\n# ------------------------------------------------------------------------------\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom models.player_model import PlayerModel\nfrom schemas.player_schema import Player\n\n# Create -----------------------------------------------------------------------\n\n\nasync def create_async(async_session: AsyncSession, player_model: PlayerModel):\n    \"\"\"\n    Creates a new Player in the database.\n\n    Args:\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n        player_model (PlayerModel): The Pydantic model representing the Player to create.\n\n    Returns:\n        True if the Player was created successfully, False otherwise.\n    \"\"\"\n    # https://docs.pydantic.dev/latest/concepts/serialization/#modelmodel_dump\n    player = Player(**player_model.model_dump())\n    async_session.add(player)\n    try:\n        await async_session.commit()\n        return True\n    except SQLAlchemyError as error:\n        print(f\"Error trying to create the Player: {error}\")\n        await async_session.rollback()\n        return False\n\n# Retrieve ---------------------------------------------------------------------\n\n\nasync def retrieve_all_async(async_session: AsyncSession):\n    \"\"\"\n    Retrieves all the players from the database.\n\n    Args:\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n\n    Returns:\n        A collection with all the players.\n    \"\"\"\n    # https://docs.sqlalchemy.org/en/20/changelog/migration_20.html#migration-20-query-usage\n    statement = select(Player)\n    result = await async_session.execute(statement)\n    players = result.scalars().all()\n    return players\n\n\nasync def retrieve_by_id_async(async_session: AsyncSession, player_id: int):\n    \"\"\"\n    Retrieves a Player by its ID from the database.\n\n    Args:\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n        player_id (int): The ID of the Player to retrieve.\n\n    Returns:\n        The Player matching the provided ID, or None if not found.\n    \"\"\"\n    player = await async_session.get(Player, player_id)\n    return player\n\n\nasync def retrieve_by_squad_number_async(async_session: AsyncSession, squad_number: int):\n    \"\"\"\n    Retrieves a Player by its Squad Number from the database.\n\n    Args:\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n        squad_number (int): The Squad Number of the Player to retrieve.\n\n    Returns:\n        The Player matching the provided Squad Number, or None if not found.\n    \"\"\"\n    statement = select(Player).where(Player.squad_number == squad_number)\n    result = await async_session.execute(statement)\n    player = result.scalars().first()\n    return player\n\n# Update -----------------------------------------------------------------------\n\n\nasync def update_async(async_session: AsyncSession, player_model: PlayerModel):\n    \"\"\"\n    Updates (entirely) an existing Player in the database.\n\n    Args:\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n        player_model (PlayerModel): The Pydantic model representing the Player to update.\n\n    Returns:\n        True if the Player was updated successfully, False otherwise.\n    \"\"\"\n    player_id = player_model.id  # Extract ID from player_model\n    player = await async_session.get(Player, player_id)\n    player.first_name = player_model.first_name\n    player.middle_name = player_model.middle_name\n    player.last_name = player_model.last_name\n    player.date_of_birth = player_model.date_of_birth\n    player.squad_number = player_model.squad_number\n    player.position = player_model.position\n    player.abbr_position = player_model.abbr_position\n    player.team = player_model.team\n    player.league = player_model.league\n    player.starting11 = player_model.starting11\n    try:\n        await async_session.commit()\n        return True\n    except SQLAlchemyError as error:\n        print(f\"Error trying to update the Player: {error}\")\n        await async_session.rollback()\n        return False\n\n# Delete -----------------------------------------------------------------------\n\n\nasync def delete_async(async_session: AsyncSession, player_id: int):\n    \"\"\"\n    Deletes an existing Player from the database.\n\n    Args:\n        async_session (AsyncSession): The async version of a SQLAlchemy ORM session.\n        player_id (int): The ID of the Player to delete.\n\n    Returns:\n        True if the Player was deleted successfully, False otherwise.\n    \"\"\"\n    player = await async_session.get(Player, player_id)\n    await async_session.delete(player)\n    try:\n        await async_session.commit()\n        return True\n    except SQLAlchemyError as error:\n        print(f\"Error trying to delete the Player: {error}\")\n        await async_session.rollback()\n        return False\n"}

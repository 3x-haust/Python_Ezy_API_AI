{"repo_info": {"repo_name": "ddtrace-asgi", "repo_owner": "florimondmanca", "repo_url": "https://github.com/florimondmanca/ddtrace-asgi"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/test_deprecations.py", "content": "import pytest\n\nimport ddtrace_asgi\n\nfrom .utils.fixtures import create_app\n\n\n@pytest.mark.parametrize(\n    \"tags\", [\"\", \"env:testing\"],\n)\ndef test_deprecated_string_tags(tags: str) -> None:\n    app = create_app(\"raw\")\n    with pytest.deprecated_call():\n        ddtrace_asgi.TraceMiddleware(app, tags=tags)\n\n\ndef test_deprecated_middleware_module() -> None:\n    with pytest.deprecated_call():\n        from ddtrace_asgi.middleware import TraceMiddleware  # noqa\n"}
{"type": "test_file", "path": "tests/applications/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/conftest.py", "content": "from typing import Any\n\nimport pytest\nfrom ddtrace.tracer import Tracer\n\nfrom tests.utils.tracer import DummyTracer\n\n# TIP: use 'pytest -k <id>' to run tests for a given application only.\nAPPLICATIONS = [\n    pytest.param(\"raw\", id=\"raw\"),\n    pytest.param(\"starlette\", id=\"starlette\"),\n    pytest.param(\"fastapi\", id=\"fastapi\"),\n]\n\n\n@pytest.fixture(name=\"application\", params=APPLICATIONS)\ndef fixture_application(request: Any) -> str:\n    return request.param\n\n\n@pytest.fixture\ndef tracer() -> Tracer:\n    return DummyTracer()\n"}
{"type": "test_file", "path": "tests/utils/tracer.py", "content": "\"\"\"\nCopied from:\nhttps://github.com/DataDog/dd-trace-py/blob/master/tests/utils/tracer.py\n\nChanges:\n- Add type annotations.\n- Make flake8-compliant.\n\"\"\"\n\nimport typing\n\nfrom ddtrace.encoding import JSONEncoder, MsgpackEncoder\nfrom ddtrace.internal.writer import AgentWriter\nfrom ddtrace.tracer import Tracer\n\nSpan = typing.Any\nTrace = typing.Any\nService = typing.Any\n\n\nclass DummyWriter(AgentWriter):\n    \"\"\"DummyWriter is a small fake writer used for tests. not thread-safe.\"\"\"\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        super().__init__(*args, **kwargs)\n\n        # Dummy components.\n        self.spans: typing.List[Span] = []\n        self.traces: typing.List[Trace] = []\n        self.services: typing.Dict[str, Service] = {}\n        self.json_encoder = JSONEncoder()\n        self.msgpack_encoder = MsgpackEncoder()\n\n    def write(\n        self, spans: typing.List[Span] = None, services: typing.List[Service] = None\n    ) -> None:\n        if spans:\n            # The traces encoding expect a list of traces so we\n            # put spans in a list like we do in the real execution path\n            # with both encoders.\n            trace = [spans]\n            self.json_encoder.encode_traces(trace)\n            self.msgpack_encoder.encode_traces(trace)\n            self.spans += spans\n            self.traces += trace\n\n        if services:\n            self.json_encoder.encode_services(services)\n            self.msgpack_encoder.encode_services(services)\n            self.services.update(services)\n\n    def pop(self) -> typing.List[Span]:\n        # Dummy method.\n        spans = self.spans\n        self.spans = []\n        return spans\n\n    def pop_traces(self) -> typing.List[Trace]:\n        # Dummy method.\n        traces = self.traces\n        self.traces = []\n        return traces\n\n    def pop_services(self) -> typing.Dict[str, Service]:\n        # Dummy method.\n        # Setting service info has been deprecated,\n        # we want to make sure nothing ever gets written here.\n        assert self.services == {}\n        services = self.services\n        self.services = {}\n        return services\n\n\nclass DummyTracer(Tracer):\n    \"\"\"\n    DummyTracer is a tracer which uses the DummyWriter by default\n    \"\"\"\n\n    writer: DummyWriter\n\n    def __init__(self) -> None:\n        super().__init__()\n        self._update_writer()\n\n    def _update_writer(self) -> None:\n        self.writer = DummyWriter(\n            hostname=self.writer.api.hostname,\n            port=self.writer.api.port,\n            filters=self.writer._filters,\n            priority_sampler=self.writer._priority_sampler,\n        )\n\n    def configure(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        super().configure(*args, **kwargs)\n        # `.configure()` may reset the writer.\n        self._update_writer()\n"}
{"type": "test_file", "path": "tests/utils/asgi.py", "content": "from starlette.types import Message, Receive, Scope, Send\n\nmock_http_scope = {\n    \"type\": \"http\",\n    \"headers\": [],\n    \"method\": \"GET\",\n    \"path\": \"/\",\n    \"query_string\": b\"\",\n}\n\n\nasync def mock_receive() -> Message:\n    raise NotImplementedError  # pragma: no cover\n\n\nasync def mock_send(message: Message) -> None:\n    pass\n\n\nasync def mock_app(scope: Scope, receive: Receive, send: Send) -> None:\n    raise NotImplementedError  # pragma: no cover\n"}
{"type": "test_file", "path": "tests/applications/starlette.py", "content": "from typing import NoReturn, Sequence, Tuple\n\nfrom ddtrace import Tracer\nfrom starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse, Response\nfrom starlette.routing import Route\nfrom starlette.types import ASGIApp\n\n\nasync def home(request: Request) -> Response:\n    return PlainTextResponse(\"Hello, world!\")\n\n\nasync def child(request: Request) -> Response:\n    tracer: Tracer = request[\"ddtrace_asgi.tracer\"]\n    with tracer.trace(\"asgi.request.child\", resource=\"child\") as span:\n        span.set_tag(\"hello\", \"world\")\n        return PlainTextResponse(\"Hello, child!\")\n\n\nasync def exception(request: Request) -> NoReturn:\n    raise RuntimeError(\"Oops\")\n\n\nroutes = [\n    Route(\"/\", home),\n    Route(\"/child/\", child),\n    Route(\"/exception/\", exception),\n]\n\n\ndef create_app(middleware: Sequence[Tuple[type, dict]]) -> ASGIApp:\n    return Starlette(\n        routes=routes,\n        middleware=[Middleware(cls, **options) for cls, options in middleware],\n    )\n"}
{"type": "test_file", "path": "tests/utils/config.py", "content": "import contextlib\nimport typing\n\nimport ddtrace\n\n\n@contextlib.contextmanager\ndef override_config(integration: str, **values: typing.Any) -> typing.Iterator[None]:\n    options: dict = getattr(ddtrace.config, integration)\n    original = {key: options.get(key) for key in values.keys()}\n    options.update(values)\n    try:\n        yield\n    finally:\n        options.update(original)\n"}
{"type": "test_file", "path": "tests/test_trace_middleware.py", "content": "import time\nfrom typing import Dict, Iterator, List, Union\n\nimport httpx\nimport pytest\nfrom ddtrace import tracer as global_tracer\nfrom ddtrace.ext import http as http_ext\nfrom ddtrace.propagation import http as http_propagation\nfrom ddtrace.span import Span\nfrom ddtrace.tracer import Tracer\nfrom starlette.types import Message, Receive, Scope, Send\n\nimport ddtrace_asgi\nfrom tests.utils.asgi import mock_app, mock_http_scope, mock_receive, mock_send\nfrom tests.utils.config import override_config\nfrom tests.utils.fixtures import create_app\nfrom tests.utils.tracer import DummyTracer\n\n\n@pytest.mark.asyncio\nasync def test_app(application: str, tracer: DummyTracer) -> None:\n    app = create_app(\n        application,\n        middleware=[\n            (\n                ddtrace_asgi.TraceMiddleware,\n                {\"tracer\": tracer, \"service\": \"test.asgi.service\"},\n            )\n        ],\n    )\n\n    async with httpx.AsyncClient(app=app) as client:\n        r = await client.get(\"http://testserver/\")\n\n    assert r.status_code == 200\n    assert r.text == \"Hello, world!\"\n\n    traces = tracer.writer.pop_traces()\n    assert len(traces) == 1\n    spans: List[Span] = traces[0]\n    assert len(spans) == 1\n    span = spans[0]\n    assert span.span_id\n    assert span.trace_id\n    assert span.parent_id is None\n    assert span.name == \"asgi.request\"\n    assert span.service == \"test.asgi.service\"\n    assert span.resource == \"GET /\"\n    assert span.get_tag(http_ext.STATUS_CODE) == \"200\"\n    assert span.get_tag(http_ext.URL) == \"http://testserver/\"\n    assert span.get_tag(http_ext.QUERY_STRING) is None\n\n\n@pytest.mark.asyncio\nasync def test_invalid_asgi(tracer: Tracer) -> None:\n    \"\"\"Test that TraceMiddleware does not crash in case of ASGI protocol violation.\"\"\"\n\n    async def invalid(scope: Scope, receive: Receive, send: Send) -> None:\n        for key in \"type\", \"headers\", \"status\":\n            message = {\"type\": \"http.response.start\", \"headers\": [], \"status\": 200}\n            message.pop(key)\n            await send(message)\n\n    app = ddtrace_asgi.TraceMiddleware(invalid, tracer=tracer)\n\n    for key in \"method\", \"path\", \"headers\", \"query_string\":\n        scope = dict(mock_http_scope)\n        scope.pop(key)\n        await app(scope, mock_receive, mock_send)\n\n    await app(mock_http_scope, mock_receive, mock_send)\n\n\n@pytest.mark.asyncio\nasync def test_child(application: str, tracer: Tracer) -> None:\n    app = create_app(\n        application,\n        middleware=[\n            (\n                ddtrace_asgi.TraceMiddleware,\n                {\"tracer\": tracer, \"service\": \"test.asgi.service\"},\n            )\n        ],\n    )\n\n    async with httpx.AsyncClient(app=app) as client:\n        start = time.time()\n        r = await client.get(\"http://testserver/child/\")\n        end = time.time()\n\n    assert r.status_code == 200\n    assert r.text == \"Hello, child!\"\n\n    traces = tracer.writer.pop_traces()\n    assert len(traces) == 1\n    spans: List[Span] = traces[0]\n    assert len(spans) == 2\n    spans_by_name = {s.name: s for s in spans}\n\n    span = spans_by_name[\"asgi.request\"]\n    assert span.span_id\n    assert span.trace_id\n    assert span.parent_id is None\n    assert span.service == \"test.asgi.service\"\n    assert span.resource == \"GET /child/\"\n    assert span.get_tag(\"hello\") is None\n    assert span.start >= start\n    assert span.duration <= end - start\n    assert span.error == 0\n\n    child_span = spans_by_name[\"asgi.request.child\"]\n    assert child_span.span_id\n    assert child_span.trace_id == span.trace_id\n    assert child_span.parent_id == span.span_id\n    assert child_span.service == \"test.asgi.service\"\n    assert child_span.resource == \"child\"\n    assert child_span.get_tag(\"hello\") == \"world\"\n    assert child_span.start >= start\n    assert child_span.duration <= end - start\n    assert child_span.error == 0\n\n\n@pytest.mark.asyncio\nasync def test_not_http_no_traces(tracer: Tracer) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        pass\n\n    app = ddtrace_asgi.TraceMiddleware(app)\n\n    scope = {\"type\": \"lifespan\"}\n    await app(scope, mock_receive, mock_send)\n    traces = tracer.writer.pop_traces()\n    assert len(traces) == 0\n\n    scope = {\"type\": \"websocket\"}\n    await app(scope, mock_receive, mock_send)\n    traces = tracer.writer.pop_traces()\n    assert len(traces) == 0\n\n\ndef test_default_tracer() -> None:\n    middleware = ddtrace_asgi.TraceMiddleware(app=mock_app)\n    assert middleware.tracer is global_tracer\n\n\ndef test_default_service() -> None:\n    middleware = ddtrace_asgi.TraceMiddleware(app=mock_app)\n    assert middleware.service == \"asgi\"\n\n\n@pytest.mark.asyncio\nasync def test_tracer_scope_item(tracer: Tracer) -> None:\n    async def spy_app(scope: Scope, receive: Receive, send: Send) -> None:\n        assert scope[\"type\"] == \"http\"\n        await send({\"tracer\": scope[\"ddtrace_asgi.tracer\"]})\n\n    messages = []\n\n    async def send(message: Message) -> None:\n        messages.append(message)\n\n    app = ddtrace_asgi.TraceMiddleware(spy_app, tracer=tracer)\n    await app(scope=mock_http_scope, receive=mock_receive, send=send)\n\n    assert messages == [{\"tracer\": tracer}]\n\n\n@pytest.fixture\ndef trace_query_string() -> Iterator[None]:\n    with override_config(\"asgi\", trace_query_string=True):\n        yield\n\n\n@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"trace_query_string\")\nasync def test_trace_query_string(application: str, tracer: DummyTracer) -> None:\n    app = create_app(\n        application,\n        middleware=[\n            (\n                ddtrace_asgi.TraceMiddleware,\n                {\"tracer\": tracer, \"service\": \"test.asgi.service\"},\n            )\n        ],\n    )\n\n    async with httpx.AsyncClient(app=app) as client:\n        r = await client.get(\"http://testserver/\", params={\"foo\": \"bar\"})\n\n    assert r.status_code == 200\n    assert r.text == \"Hello, world!\"\n\n    traces = tracer.writer.pop_traces()\n    assert len(traces) == 1\n    spans: List[Span] = traces[0]\n    assert len(spans) == 1\n    span = spans[0]\n    assert span.get_tag(http_ext.QUERY_STRING) == \"foo=bar\"\n\n\n@pytest.mark.asyncio\nasync def test_app_exception(application: str, tracer: DummyTracer) -> None:\n    app = create_app(\n        application,\n        middleware=[\n            (\n                ddtrace_asgi.TraceMiddleware,\n                {\"tracer\": tracer, \"service\": \"test.asgi.service\"},\n            )\n        ],\n    )\n\n    async with httpx.AsyncClient(app=app) as client:\n        with pytest.raises(RuntimeError):\n            start = time.time()\n            _ = await client.get(\"http://testserver/exception/\")\n        end = time.time()\n\n    # Ensure any open span was closed.\n    assert not tracer.current_span()\n\n    traces = tracer.writer.pop_traces()\n    assert len(traces) == 1\n    spans: List[Span] = traces[0]\n    assert len(spans) == 1\n    span = spans[0]\n    assert span.name == \"asgi.request\"\n    assert span.service == \"test.asgi.service\"\n    assert span.resource == \"GET /exception/\"\n    assert span.start >= start\n    assert span.duration <= end - start\n    assert span.error == 1\n\n\n@pytest.mark.asyncio\nasync def test_distributed_tracing(application: str, tracer: DummyTracer) -> None:\n    app = create_app(\n        application,\n        middleware=[\n            (\n                ddtrace_asgi.TraceMiddleware,\n                {\"tracer\": tracer, \"service\": \"test.asgi.service\"},\n            )\n        ],\n    )\n\n    headers = {\n        http_propagation.HTTP_HEADER_TRACE_ID: \"1234\",\n        http_propagation.HTTP_HEADER_PARENT_ID: \"5678\",\n    }\n\n    async with httpx.AsyncClient(app=app) as client:\n        r = await client.get(\"http://testserver/\", headers=headers)\n\n    assert r.status_code == 200\n    assert r.text == \"Hello, world!\"\n\n    traces = tracer.writer.pop_traces()\n    assert len(traces) == 1\n    spans: List[Span] = traces[0]\n    assert len(spans) == 1\n    span = spans[0]\n    assert span.trace_id == 1234\n    assert span.parent_id == 5678\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\n    \"tags, expected_tags\",\n    [\n        ({}, {}),\n        ({\"env\": \"testing\", \"live\": \"false\"}, {\"env\": \"testing\", \"live\": \"false\"}),\n        ({\"env\": \"staging:east\"}, {\"env\": \"staging:east\"}),\n        ([], {}),\n        ([\"env:testing\", \"live:false\"], {\"env\": \"testing\", \"live\": \"false\"}),\n        ([\"env:staging:east\"], {\"env\": \"staging:east\"}),\n    ],\n)\nasync def test_tags(\n    application: str,\n    tracer: DummyTracer,\n    tags: Union[dict, list],\n    expected_tags: Dict[str, str],\n) -> None:\n    app = create_app(\n        application,\n        middleware=[\n            (\n                ddtrace_asgi.TraceMiddleware,\n                {\"tracer\": tracer, \"service\": \"test.asgi.service\", \"tags\": tags},\n            )\n        ],\n    )\n\n    async with httpx.AsyncClient(app=app) as client:\n        r = await client.get(\"http://testserver/\")\n\n    assert r.status_code == 200\n    assert r.text == \"Hello, world!\"\n\n    traces = tracer.writer.pop_traces()\n    assert len(traces) == 1\n    spans: List[Span] = traces[0]\n    assert len(spans) == 1\n    span = spans[0]\n    assert span.name == \"asgi.request\"\n    assert span.service == \"test.asgi.service\"\n    assert span.resource == \"GET /\"\n    for key, value in expected_tags.items():\n        assert span.get_tag(key) == value\n"}
{"type": "test_file", "path": "tests/applications/raw.py", "content": "from typing import Sequence, Tuple\n\nfrom ddtrace import Tracer\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\n\nasync def home(scope: Scope, receive: Receive, send: Send) -> None:\n    assert scope[\"type\"] == \"http\"\n    await send(\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 200,\n            \"headers\": [[b\"content-type\", b\"text/plain\"]],\n        }\n    )\n    await send({\"type\": \"http.response.body\", \"body\": b\"Hello, world!\"})\n\n\nasync def child(scope: Scope, receive: Receive, send: Send) -> None:\n    assert scope[\"type\"] == \"http\"\n    tracer: Tracer = scope[\"ddtrace_asgi.tracer\"]\n    with tracer.trace(\"asgi.request.child\", resource=\"child\") as span:\n        span.set_tag(\"hello\", \"world\")\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 200,\n                \"headers\": [[b\"content-type\", b\"text/plain\"]],\n            }\n        )\n        await send({\"type\": \"http.response.body\", \"body\": b\"Hello, child!\"})\n\n\nasync def exception(scope: Scope, receive: Receive, send: Send) -> None:\n    exc = RuntimeError(\"Oops\")\n    await send(\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 500,\n            \"headers\": [[b\"content-type\", b\"text/plain\"]],\n        }\n    )\n    await send({\"type\": \"http.response.body\", \"body\": str(exc).encode()})\n    raise exc\n\n\ndef create_app(middleware: Sequence[Tuple[type, dict]]) -> ASGIApp:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"path\"] == \"/child/\":\n            await child(scope, receive, send)\n        elif scope[\"path\"] == \"/exception/\":\n            await exception(scope, receive, send)\n        else:\n            await home(scope, receive, send)\n\n    for cls, options in middleware:\n        app = cls(app, **options)\n\n    return app\n"}
{"type": "test_file", "path": "tests/applications/fastapi.py", "content": "from typing import NoReturn, Sequence, Tuple\n\nfrom ddtrace import Tracer\nfrom fastapi import FastAPI\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\nfrom starlette.types import ASGIApp\n\n\ndef create_app(middleware: Sequence[Tuple[type, dict]]) -> ASGIApp:\n    app = FastAPI()\n\n    @app.get(\"/\", response_class=PlainTextResponse)\n    async def home() -> str:\n        return \"Hello, world!\"\n\n    @app.get(\"/child/\", response_class=PlainTextResponse)\n    async def child(request: Request) -> str:\n        tracer: Tracer = request[\"ddtrace_asgi.tracer\"]\n        with tracer.trace(\"asgi.request.child\", resource=\"child\") as span:\n            span.set_tag(\"hello\", \"world\")\n            return \"Hello, child!\"\n\n    @app.get(\"/exception/\")\n    async def exception() -> NoReturn:\n        raise RuntimeError(\"Oops\")\n\n    for cls, options in middleware:\n        app.add_middleware(cls, **options)\n\n    return app\n"}
{"type": "test_file", "path": "tests/utils/fixtures.py", "content": "import importlib\nfrom typing import Any, Sequence, Tuple\n\nfrom starlette.types import ASGIApp\n\n\ndef create_app(name: str, middleware: Sequence[Tuple[type, dict]] = ()) -> ASGIApp:\n    module_path = f\"tests.applications.{name}\"\n    module: Any = importlib.import_module(module_path)\n    return module.create_app(middleware=middleware)\n"}
{"type": "source_file", "path": "setup.py", "content": "import re\nfrom pathlib import Path\n\nfrom setuptools import find_packages, setup\n\n\ndef get_version(package: str) -> str:\n    version = (Path(\"src\") / package / \"__version__.py\").read_text()\n    match = re.search(\"__version__ = ['\\\"]([^'\\\"]+)['\\\"]\", version)\n    assert match is not None\n    return match.group(1)\n\n\ndef get_long_description() -> str:\n    with open(\"README.md\", encoding=\"utf8\") as readme:\n        with open(\"CHANGELOG.md\", encoding=\"utf8\") as changelog:\n            return readme.read() + \"\\n\\n\" + changelog.read()\n\n\nsetup(\n    name=\"ddtrace-asgi\",\n    version=get_version(\"ddtrace_asgi\"),\n    description=\"Unofficial ddtrace integration for ASGI apps and frameworks\",\n    long_description=get_long_description(),\n    long_description_content_type=\"text/markdown\",\n    url=\"http://github.com/florimondmanca/ddtrace-asgi\",\n    author=\"Florimond Manca\",\n    author_email=\"florimond.manca@gmail.com\",\n    packages=find_packages(\"src\"),\n    package_dir={\"\": \"src\"},\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=[\"ddtrace\", \"starlette==0.*\", \"deprecation==2.*\"],\n    python_requires=\">=3.6\",\n    license=\"BSD\",\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n    ],\n)\n"}
{"type": "source_file", "path": "src/ddtrace_asgi/_deprecated/utils.py", "content": "from typing import Dict\n\nimport deprecation\nfrom starlette.datastructures import CommaSeparatedStrings\n\nfrom .._utils import parse_tags_from_list\n\n\n@deprecation.deprecated(\n    deprecated_in=\"0.4.0\",\n    removed_in=\"0.5.0\",\n    details=(\n        \"Pass a list or dict instead. \"\n        \"Hint: use `starlette.datastructures.CommaSeparatedStrings` for parsing.\"\n    ),\n)\ndef parse_tags_from_string(value: str) -> Dict[str, str]:\n    return parse_tags_from_list(CommaSeparatedStrings(value))\n"}
{"type": "source_file", "path": "src/ddtrace_asgi/_deprecated/__init__.py", "content": ""}
{"type": "source_file", "path": "src/ddtrace_asgi/__version__.py", "content": "__version__ = \"0.3.0\"\n"}
{"type": "source_file", "path": "src/ddtrace_asgi/__init__.py", "content": "from .__version__ import __version__\nfrom ._middleware import TraceMiddleware\n\n__all__ = [\"__version__\", \"TraceMiddleware\"]\n"}
{"type": "source_file", "path": "src/ddtrace_asgi/_deprecated/middleware.py", "content": "import warnings\n\nimport deprecation\n\nfrom .._middleware import TraceMiddleware\n\n__all__ = [\"TraceMiddleware\"]\n\nwarnings.warn(\n    deprecation.DeprecatedWarning(\n        \"Importing from `ddtrace_asgi.middleware`\",\n        deprecated_in=\"0.4.0\",\n        removed_in=\"0.5.0\",\n        details=(\n            \"Import from `ddtrace_asgi` instead: \"\n            \"`from ddtrace_asgi importTraceMiddleware`.\"\n        ),\n    ),\n    category=DeprecationWarning,\n)\n"}
{"type": "source_file", "path": "src/ddtrace_asgi/_utils.py", "content": "from typing import Dict, Sequence\n\n\ndef parse_tags_from_list(tags: Sequence[str]) -> Dict[str, str]:\n    parsed: Dict[str, str] = {}\n\n    for tag in tags:\n        name, _, value = tag.partition(\":\")\n        parsed[name] = value\n\n    return parsed\n"}
{"type": "source_file", "path": "src/ddtrace_asgi/_middleware.py", "content": "from typing import Mapping, Optional, Sequence, Union\n\nfrom ddtrace import Tracer, tracer as global_tracer\nfrom ddtrace.constants import ANALYTICS_SAMPLE_RATE_KEY\nfrom ddtrace.ext import http as http_tags\nfrom ddtrace.http import store_request_headers, store_response_headers\nfrom ddtrace.propagation.http import HTTPPropagator\nfrom ddtrace.settings import config\nfrom starlette.datastructures import Headers\nfrom starlette.requests import Request\nfrom starlette.types import ASGIApp, Message, Receive, Scope, Send\n\nfrom ._deprecated.utils import parse_tags_from_string\nfrom ._utils import parse_tags_from_list\n\n\nclass TraceMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        *,\n        tracer: Optional[Tracer] = None,\n        service: str = \"asgi\",\n        tags: Union[Mapping[str, str], Sequence[str]] = None,\n        distributed_tracing: bool = True,\n    ) -> None:\n        if tracer is None:\n            tracer = global_tracer\n\n        if tags is None:\n            tags = []\n        if isinstance(tags, str):\n            tags = parse_tags_from_string(tags)\n        elif isinstance(tags, list):\n            tags = parse_tags_from_list(tags)\n\n        assert isinstance(tags, dict)\n\n        self.app = app\n        self.tracer = tracer\n        self.service = service\n        self.tags = tags\n        self._distributed_tracing = distributed_tracing\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        scope[\"ddtrace_asgi.tracer\"] = self.tracer\n\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        request = Request(scope=scope, receive=receive)\n        try:\n            request_headers = request.headers\n            method = request.method\n            url = request.url\n        except KeyError:\n            # ASGI message is invalid - most likely missing the 'headers' or 'method'\n            # fields.\n            await self.app(scope, receive, send)\n            return\n\n        # Make sure we don't use potentially unsafe request attributes after this point.\n        del request\n\n        if self._distributed_tracing:\n            propagator = HTTPPropagator()\n            context = propagator.extract(request_headers)\n            if context.trace_id:\n                self.tracer.context_provider.activate(context)\n\n        resource = \"%s %s\" % (method, url.path)\n        span = self.tracer.trace(\n            name=\"asgi.request\",\n            service=self.service,\n            resource=resource,\n            span_type=http_tags.TYPE,\n        )\n\n        span.set_tag(\n            ANALYTICS_SAMPLE_RATE_KEY,\n            config.asgi.get_analytics_sample_rate(use_global_config=True),\n        )\n        span.set_tag(http_tags.METHOD, method)\n        span.set_tag(http_tags.URL, str(url))\n        if config.asgi.get(\"trace_query_string\"):\n            span.set_tag(http_tags.QUERY_STRING, url.query)\n\n        span.set_tags(self.tags)\n\n        # NOTE: any request header set in the future will not be stored in the span.\n        store_request_headers(request_headers, span, config.asgi)\n\n        async def send_with_tracing(message: Message) -> None:\n            span = self.tracer.current_span()\n\n            if span and message.get(\"type\") == \"http.response.start\":\n                if \"status\" in message:\n                    status_code: int = message[\"status\"]\n                    span.set_tag(http_tags.STATUS_CODE, str(status_code))\n                if \"headers\" in message:\n                    response_headers = Headers(raw=message[\"headers\"])\n                    store_response_headers(response_headers, span, config.asgi)\n\n            await send(message)\n\n        try:\n            await self.app(scope, receive, send_with_tracing)\n        except BaseException as exc:\n            span.set_traceback()\n            raise exc from None\n        finally:\n            span.finish()\n"}
{"type": "source_file", "path": "src/ddtrace_asgi/middleware.py", "content": "# DEPRECATED MODULE\nfrom ._deprecated.middleware import TraceMiddleware\n\n__all__ = [\"TraceMiddleware\"]\n"}

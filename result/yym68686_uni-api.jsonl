{"repo_info": {"repo_name": "uni-api", "repo_owner": "yym68686", "repo_url": "https://github.com/yym68686/uni-api"}}
{"type": "test_file", "path": "test/test_baseurl.py", "content": "import os\nimport sys\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom utils import BaseAPI\n\ndef print_base_api(url):\n    base_api = BaseAPI(url)\n    print(\"base_url            \", base_api.base_url)\n    print(\"v1_url              \", base_api.v1_url)\n    print(\"chat_url            \", base_api.chat_url)\n    print(\"image_url           \", base_api.image_url)\n    print(\"audio_transcriptions\", base_api.audio_transcriptions)\n    print(\"moderations         \", base_api.moderations)\n    print(\"embeddings          \", base_api.embeddings)\n    print(\"-\"*50)\n\n\nprint_base_api(\"https://api.openai.com/v1/chat/completions\")\nprint_base_api(\"https://api.deepseek.com/chat/completions\")\nprint_base_api(\"https://models.inference.ai.azure.com/chat/completions\")\nprint_base_api(\"https://open.bigmodel.cn/api/paas/v4/chat/completions\")\n"}
{"type": "test_file", "path": "test/test_httpx.py", "content": "import httpx\nimport asyncio\nimport ssl\nimport logging\n\n# 设置日志\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\nasync def make_request():\n    # SSL 上下文设置\n    # ssl_context = ssl.create_default_context()\n    # ssl_context.set_alpn_protocols([\"h2\", \"http/1.1\"])\n\n    # 创建自定义传输\n    transport = httpx.AsyncHTTPTransport(\n        http2=True,\n        # verify=ssl_context,\n        verify=False,\n        retries=1\n    )\n\n    # 设置头部\n    headers = {\n        \"User-Agent\": \"curl/8.7.1\",\n        \"Accept\": \"*/*\",\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": \"Bearer sk-xxxxxxx\"\n    }\n\n    # 请求数据\n    data = {\n        \"model\": \"gpt-4o\",\n        \"messages\": [\n            {\n                \"role\": \"user\",\n                \"content\": \"say test\"\n            }\n        ],\n        \"stream\": True\n    }\n\n    async with httpx.AsyncClient(transport=transport) as client:\n        try:\n            response = await client.post(\n                \"https://api.xxxxxxxxxx.me/v1/chat/completions\",\n                headers=headers,\n                json=data,\n                timeout=30.0\n            )\n\n            logger.info(f\"Status Code: {response.status_code}\")\n            logger.info(f\"Headers: {response.headers}\")\n\n            # 处理流式响应\n            async for line in response.aiter_lines():\n                if line:\n                    print(line)\n\n        except httpx.RequestError as e:\n            logger.error(f\"An error occurred while requesting {e.request.url!r}.\")\n\n# 运行异步函数\nasyncio.run(make_request())"}
{"type": "test_file", "path": "test/test_json.py", "content": "import ast\nimport json\n\nimport os\nimport sys\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nfrom utils import safe_get\n# 读取文件内容\nwith open('test/states.json', 'r', encoding='utf-8') as file:\n    content = file.read()\n\n# 使用ast.literal_eval解析非标准JSON\nparsed_data = ast.literal_eval(content)\n\nfor item in parsed_data:\n    print(safe_get(item, \"candidates\", 0, \"content\", \"parts\", 0, \"text\"))\n    print(safe_get(item, \"candidates\", 0, \"content\", \"role\"))\n\n# 将解析后的数据转换为标准JSON\nstandard_json = json.dumps(parsed_data, ensure_ascii=False, indent=2)\n\n# 将标准JSON写入新文件\nwith open('test/standard_states.json', 'w', encoding='utf-8') as file:\n    file.write(standard_json)\n\nprint(\"转换完成，标准JSON已保存到 'test/standard_states.json'\")"}
{"type": "test_file", "path": "test/test_dict.py", "content": "a = [\n    {\"a\": 1, \"b\": 2, \"c\": 3},\n    {\"a\": 4, \"b\": 5, \"c\": 6},\n    {\"a\": 7, \"b\": 8, \"c\": 9}\n]\nimport copy\nfor item in a:\n    new_item = copy.deepcopy(item)\n    new_item[\"a\"] = 10\n    del new_item[\"b\"]\n    # print(item)\nprint(a)\n"}
{"type": "test_file", "path": "test/test_vertex.py", "content": "import json\nimport base64\nimport time\nimport httpx\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.serialization import load_pem_private_key\n\n# 您的服务账号密钥（请将其保存在安全的地方，不要公开分享）\ndef create_jwt(client_email, private_key):\n    # JWT Header\n    header = json.dumps({\n        \"alg\": \"RS256\",\n        \"typ\": \"JWT\"\n    }).encode()\n\n    # JWT Payload\n    now = int(time.time())\n    payload = json.dumps({\n        \"iss\": client_email,\n        \"scope\": \"https://www.googleapis.com/auth/cloud-platform\",\n        \"aud\": \"https://oauth2.googleapis.com/token\",\n        \"exp\": now + 3600,\n        \"iat\": now\n    }).encode()\n\n    # Encode header and payload\n    segments = [\n        base64.urlsafe_b64encode(header).rstrip(b'='),\n        base64.urlsafe_b64encode(payload).rstrip(b'=')\n    ]\n\n    # Create signature\n    signing_input = b'.'.join(segments)\n    private_key = load_pem_private_key(private_key.encode(), password=None)\n    signature = private_key.sign(\n        signing_input,\n        padding.PKCS1v15(),\n        hashes.SHA256()\n    )\n\n    segments.append(base64.urlsafe_b64encode(signature).rstrip(b'='))\n    return b'.'.join(segments).decode()\n\ndef get_access_token(client_email, private_key):\n    jwt = create_jwt(client_email, private_key)\n\n    with httpx.Client() as client:\n        response = client.post(\n            \"https://oauth2.googleapis.com/token\",\n            data={\n                \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n                \"assertion\": jwt\n            },\n            headers={'Content-Type': \"application/x-www-form-urlencoded\"}\n        )\n        response.raise_for_status()\n        return response.json()[\"access_token\"]\n\ndef ask_stream(prompt, client_email, private_key, project_id, engine):\n    payload = {\n    \"contents\": [\n        {\n            \"role\": \"user\",\n            \"parts\": [\n                {\n                    \"text\": prompt\n                }\n            ]\n        }\n    ],\n    \"system_instruction\": {\n        \"parts\": [\n            {\n                \"text\": \"You are Gemini, a large language model trained by Google. Respond conversationally\"\n            }\n        ]\n    },\n    # \"safety_settings\": [\n    #     {\n    #         \"category\": \"HARM_CATEGORY_HARASSMENT\",\n    #         \"threshold\": \"BLOCK_NONE\"\n    #     },\n    #     {\n    #         \"category\": \"HARM_CATEGORY_HATE_SPEECH\",\n    #         \"threshold\": \"BLOCK_NONE\"\n    #     },\n    #     {\n    #         \"category\": \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    #         \"threshold\": \"BLOCK_NONE\"\n    #     },\n    #     {\n    #         \"category\": \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n    #         \"threshold\": \"BLOCK_NONE\"\n    #     }\n    # ],\n    \"generationConfig\": {\n        \"temperature\": 0.5,\n        \"max_output_tokens\": 256,\n        \"top_k\": 40,\n        \"top_p\": 0.95\n    },\n    \"tools\": [\n        {\n            \"function_declarations\": [\n                {\n                    \"name\": \"get_search_results\",\n                    \"description\": \"Search Google to enhance knowledge.\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"prompt\": {\n                                \"type\": \"string\",\n                                \"description\": \"The prompt to search.\"\n                            }\n                        },\n                        \"required\": [\n                            \"prompt\"\n                        ]\n                    }\n                },\n                {\n                    \"name\": \"get_url_content\",\n                    \"description\": \"Get the webpage content of a URL\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"url\": {\n                                \"type\": \"string\",\n                                \"description\": \"the URL to request\"\n                            }\n                        },\n                        \"required\": [\n                            \"url\"\n                        ]\n                    }\n                }\n            ]\n        }\n    ],\n    \"tool_config\": {\n        \"function_calling_config\": {\n            \"mode\": \"AUTO\"\n        }\n    }\n}\n    # payload = {\n    #     \"contents\": [\n    #         {\n    #             \"role\": \"user\",\n    #             \"parts\": [\n    #                 {\n    #                     \"text\": prompt\n    #                 }\n    #             ]\n    #         },\n    #     ],\n    #     \"generationConfig\": {\n    #         \"temperature\": 0.2,\n    #         \"maxOutputTokens\": 256,\n    #         \"topK\": 40,\n    #         \"topP\": 0.95\n    #     }\n    # }\n\n    access_token = get_access_token(client_email, private_key)\n    headers = {\n        'Authorization': f\"Bearer {access_token}\",\n        'Content-Type': \"application/json\"\n    }\n\n    MODEL_ID = engine\n    PROJECT_ID = project_id\n    stream = \"generateContent\"\n    with httpx.Client() as client:\n        response = client.post(\n            f\"https://us-central1-aiplatform.googleapis.com/v1/projects/{PROJECT_ID}/locations/us-central1/publishers/google/models/{MODEL_ID}:{stream}\",\n            json=payload,\n            headers=headers,\n            timeout=600,\n        )\n        response.raise_for_status()\n        return response.json()\n\n# 使用示例\nclient_email, private_key, project_id = SERVICE_ACCOUNT_KEY[\"client_email\"], SERVICE_ACCOUNT_KEY[\"private_key\"], SERVICE_ACCOUNT_KEY[\"project_id\"]\nengine = \"gemini-1.5-pro\"\nuser_input = input(\"请输入您的问题： \")\nresult = ask_stream(user_input, client_email, private_key, project_id, engine)\nprint(json.dumps(result, ensure_ascii=False, indent=2))"}
{"type": "test_file", "path": "test/xue/test_dropdown_sheet.py", "content": "from fastapi import FastAPI\nfrom fastapi.responses import HTMLResponse\nfrom xue import HTML, Head, Body, Div, xue_initialize, Script\nfrom xue.components import dropdown, sheet, button, form, input\n\nxue_initialize(tailwind=True)\napp = FastAPI()\n\n@app.get(\"/\", response_class=HTMLResponse)\nasync def root():\n    result = HTML(\n        Head(\n            title=\"Dropdown with Edit Sheet Example\",\n        ),\n        Body(\n            Div(\n                dropdown.dropdown_menu(\"Actions\"),\n                Div(id=\"sheet-container\"),  # 这里是 sheet 将被加载的地方\n                class_=\"container mx-auto p-4\"\n            )\n        )\n    ).render()\n    print(result)\n    return result\n\n@app.get(\"/dropdown-menu/{menu_id}\", response_class=HTMLResponse)\nasync def get_dropdown_menu_content(menu_id: str):\n    items = [\n        {\n            \"icon\": \"pencil\",\n            \"label\": \"Edit\",\n            \"hx-get\": \"/edit-sheet\",\n            \"hx-target\": \"#sheet-container\",\n            \"hx-swap\": \"innerHTML\"\n        },\n        {\"icon\": \"trash\", \"label\": \"Delete\"},\n        {\"icon\": \"copy\", \"label\": \"Duplicate\"},\n    ]\n    result = dropdown.dropdown_menu_content(menu_id, items).render()\n    print(\"dropdown-menu result\", result)\n    return result\n\n@app.get(\"/edit-sheet\", response_class=HTMLResponse)\nasync def get_edit_sheet():\n    edit_sheet_content = sheet.SheetContent(\n        sheet.SheetHeader(\n            sheet.SheetTitle(\"Edit Item\"),\n            sheet.SheetDescription(\"Make changes to your item here.\")\n        ),\n        sheet.SheetBody(\n            form.Form(\n                form.FormField(\"Name\", \"name\", placeholder=\"Enter item name\"),\n                form.FormField(\"Description\", \"description\", placeholder=\"Enter item description\"),\n                Div(\n                    button.button(\"Save\", class_=\"bg-blue-500 text-white\"),\n                    button.button(\"Cancel\", class_=\"bg-gray-300 text-gray-700 ml-2\", data_close_sheet=\"true\"),\n                    class_=\"flex justify-end mt-4\"\n                ),\n                class_=\"space-y-4\"\n            )\n        )\n    )\n\n    result = sheet.Sheet(\n        \"edit-sheet\",\n        Div(),\n        edit_sheet_content,\n        width=\"80%\",\n        max_width=\"800px\"\n    ).render()\n    return result\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"__main__:app\", host=\"0.0.0.0\", port=8000, reload=True)"}
{"type": "test_file", "path": "test/test_weights.py", "content": "def weighted_round_robin(weights):\n    provider_names = list(weights.keys())\n    current_weights = {name: 0 for name in provider_names}\n    num_selections = total_weight = sum(weights.values())\n    weighted_provider_list = []\n\n    for _ in range(num_selections):\n        max_ratio = -1\n        selected_letter = None\n\n        for name in provider_names:\n            current_weights[name] += weights[name]\n            ratio = current_weights[name] / weights[name]\n\n            if ratio > max_ratio:\n                max_ratio = ratio\n                selected_letter = name\n\n        weighted_provider_list.append(selected_letter)\n        current_weights[selected_letter] -= total_weight\n\n    return weighted_provider_list\n\n# 权重和选择次数\nweights = {'a': 5, 'b': 3, 'c': 2}\nindex = {'a', 'c'}\n\nresult = dict(filter(lambda item: item[0] in index, weights.items()))\nprint(result)\n# result = {k: weights[k] for k in index if k in weights}\n# print(result)\nweighted_provider_list = weighted_round_robin(weights)\nprint(weighted_provider_list)\n"}
{"type": "test_file", "path": "test/test_matplotlib.py", "content": "import json\nimport matplotlib.pyplot as plt\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\nimport numpy as np\n\nimport matplotlib.font_manager as fm\nfont_path = '/System/Library/Fonts/PingFang.ttc'\nprop = fm.FontProperties(fname=font_path)\nplt.rcParams['font.family'] = prop.get_name()\n\nwith open('./test/states.json') as f:\n    data = json.load(f)\n    request_arrivals = data[\"request_arrivals\"]\n\ndef create_pic(request_arrivals, key):\n    request_arrivals = request_arrivals[key]\n    # 将字符串转换为datetime对象\n    datetimes = [datetime.fromisoformat(t) for t in request_arrivals]\n    # 获取最新的时间\n    latest_time = max(datetimes)\n\n    # 创建24小时的时间范围\n    time_range = [latest_time - timedelta(hours=i) for i in range(32, 0, -1)]\n    # 统计每小时的请求数\n    hourly_counts = defaultdict(int)\n    for dt in datetimes:\n        for t in time_range[::-1]:\n            if dt >= t:\n                hourly_counts[t] += 1\n                break\n\n    # 准备绘图数据\n    hours = [t.strftime('%Y-%m-%d %H:00') for t in time_range]\n    counts = [hourly_counts[t] for t in time_range]\n\n    # 创建柱状图\n    plt.figure(figsize=(15, 6))\n    plt.bar(hours, counts)\n    plt.title(f'{key} 端点请求量 (过去24小时)')\n    plt.xlabel('时间')\n    plt.ylabel('请求数')\n    plt.xticks(rotation=45, ha='right')\n    plt.tight_layout()\n\n    # 保存图片\n    plt.savefig(f'{key.replace(\"/\", \"\")}.png')\n\ndef create_pie_chart(model_counts):\n    models = list(model_counts.keys())\n    counts = list(model_counts.values())\n\n    # 设置颜色和排列顺序\n    colors = plt.cm.Set3(np.linspace(0, 1, len(models)))\n    sorted_data = sorted(zip(counts, models, colors), reverse=True)\n    counts, models, colors = zip(*sorted_data)\n\n    # 创建饼图\n    fig, ax = plt.subplots(figsize=(16, 10))\n    wedges, _ = ax.pie(counts, colors=colors, startangle=90, wedgeprops=dict(width=0.5))\n\n    # 添加圆环效果\n    centre_circle = plt.Circle((0, 0), 0.35, fc='white')\n    fig.gca().add_artist(centre_circle)\n\n    # 计算总数\n    total = sum(counts)\n\n    # 准备标注\n    bbox_props = dict(boxstyle=\"round,pad=0.3\", fc=\"w\", ec=\"k\", lw=0.72)\n    kw = dict(xycoords='data', textcoords='data', arrowprops=dict(arrowstyle=\"-\"), bbox=bbox_props, zorder=0)\n\n    left_labels = []\n    right_labels = []\n\n    for i, p in enumerate(wedges):\n        ang = (p.theta2 - p.theta1) / 2. + p.theta1\n        y = np.sin(np.deg2rad(ang))\n        x = np.cos(np.deg2rad(ang))\n\n        percentage = counts[i] / total * 100\n        label = f\"{models[i]}: {percentage:.1f}%\"\n\n        if x > 0:\n            right_labels.append((x, y, label))\n        else:\n            left_labels.append((x, y, label))\n\n    # 绘制左侧标注\n    for i, (x, y, label) in enumerate(left_labels):\n        ax.annotate(label, xy=(x, y), xytext=(-1.2, 0.9 - i * 0.15), **kw)\n\n    # 绘制右侧标注\n    for i, (x, y, label) in enumerate(right_labels):\n        ax.annotate(label, xy=(x, y), xytext=(1.2, 0.9 - i * 0.15), **kw)\n\n    plt.title(\"各模型使用次数对比\", size=16)\n    ax.set_xlim(-1.5, 1.5)\n    ax.set_ylim(-1.2, 1.2)\n    ax.axis('off')\n    plt.tight_layout()\n    plt.savefig('model_usage_pie_chart.png', bbox_inches='tight', pad_inches=0.5)\n\nif __name__ == '__main__':\n    model_counts = {\n        \"model_counts\": {\n            \"claude-3-5-sonnet\": 94,\n            \"o1-preview\": 71,\n            \"gpt-4o\": 512,\n            \"gpt-4o-mini\": 5,\n            \"gemini-1.5-pro\": 5,\n            \"deepseek-chat\": 7,\n            \"grok-2-mini\": 1,\n            \"grok-2\": 9,\n            \"o1-mini\": 8\n        }\n    }\n    # create_pic(request_arrivals, 'POST /v1/chat/completions')\n\n    create_pie_chart(model_counts[\"model_counts\"])\n"}
{"type": "test_file", "path": "test/test_ruamel_yaml.py", "content": "from ruamel.yaml import YAML\n\n# 假设我们有以下 YAML 内容\nyaml_content = \"\"\"\n# 这是顶级注释\nkey1: value1  # 行尾注释\nkey2: value2\n\n# 这是嵌套结构的注释\nnested:\n  subkey1: subvalue1\n  subkey2: subvalue2  # 嵌套的行尾注释\n\n# 列表的注释\nlist_key:\n  - item1\n  - item2  # 列表项的注释\n\"\"\"\n\n# 创建 YAML 对象\nyaml = YAML()\nyaml.preserve_quotes = True\nyaml.indent(mapping=2, sequence=4, offset=2)\n\nwith open('api.yaml', 'r', encoding='utf-8') as file:\n    data = yaml.load(file)\n\n# data = yaml.load(yaml_content)\n# 加载 YAML 数据\nprint(data)\n\n# # 修改数据\n# data['key1'] = 'new_value1'\n# data['nested']['subkey1'] = 'new_subvalue1'\n# data['list_key'].append('new_item')\n\n# 将修改后的数据写回文件（这里我们使用 StringIO 来模拟文件操作）\n# from io import StringIO\n# output = StringIO()\n# yaml.dump(data, output)\n# print(output.getvalue())\n\nwith open('formatted.yaml', 'w', encoding='utf-8') as file:\n    yaml.dump(data, file)"}
{"type": "test_file", "path": "test/test_request.py", "content": "import os\nimport sys\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom core.models import RequestModel\nfrom core.request import get_payload\nimport json\n\nasync def test_gemini_payload():\n    # 构造测试请求\n    request_data = {\n        \"model\": \"gemini-1.5-pro-latest\",\n        \"messages\": [\n            {\n                \"role\": \"system\",\n                \"content\": \"<plugins description=\\\"The plugins you can use below\\\">\\n<collection name=\\\"Clock Time\\\">\\n<collection.instructions>Display a clock to show current time</collection.instructions>\\n<api identifier=\\\"clock-time____getCurrentTime____standalone\\\">获取当前时间</api>\\n</collection>\\n</plugins>\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": \"几点了？\"\n            }\n        ],\n        \"stream\": True,\n        \"temperature\": 1.3,\n        \"top_p\": 1.0,\n        \"presence_penalty\": 0.0,\n        \"frequency_penalty\": 0.0,\n        \"user\": \"d5a7516e-e919-45f0-81a1-42bad3da6125\",\n        \"tools\": [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"clock-time____getCurrentTime____standalone\",\n                    \"description\": \"获取当前时间\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {}\n                    }\n                }\n            }\n        ]\n    }\n\n    request = RequestModel(**request_data)\n    provider = {\n        \"provider\": \"gemini\",\n        \"base_url\": \"https://generativelanguage.googleapis.com\",\n        \"api\": \"your-api-key\",  # 测试时替换为实际的 API key\n        \"model\": [\"gemini-1.5-pro-latest\"],\n        \"project_id\": \"your-project-id\"\n    }\n\n    url, headers, payload = await get_payload(request, \"vertex-gemini\", provider)\n    # url, headers, payload = await get_payload(request, \"gemini\", provider)\n\n    print(\"payload\", json.dumps(payload, indent=4, ensure_ascii=False))\n\n    # 验证生成的 payload 结构\n    assert \"contents\" in payload\n    assert \"tools\" in payload\n    assert len(payload[\"tools\"]) == 1\n    assert \"function_declarations\" in payload[\"tools\"][0]\n\n    # 验证工具配置\n    assert payload[\"tools\"][0][\"function_declarations\"][0][\"name\"] == \"clock-time____getCurrentTime____standalone\"\n    assert payload[\"tools\"][0][\"function_declarations\"][0][\"description\"] == \"获取当前时间\"\n\n    # 验证消息内容\n    assert len(payload[\"contents\"]) == 2\n    assert payload[\"contents\"][0][\"role\"] == \"system\"\n    assert payload[\"contents\"][1][\"role\"] == \"user\"\n\n    # 验证其他参数\n    assert payload[\"temperature\"] == 1.3\n    assert payload[\"top_p\"] == 1.0\n\n    # 验证安全设置\n    assert \"safetySettings\" in payload\n    assert len(payload[\"safetySettings\"]) == 4\n\n    # 验证工具配置\n    assert \"tool_config\" in payload\n    assert payload[\"tool_config\"][\"function_calling_config\"][\"mode\"] == \"AUTO\"\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(test_gemini_payload())"}
{"type": "test_file", "path": "test/test_nostream.py", "content": "import requests\nimport base64\nimport json\nimport os\nfrom datetime import datetime\n\n# 設置API密鑰和自定義base URL\nAPI_KEY = ''\nBASE_URL = 'http://localhost:8000/v1'\nSAVE_DIR = 'safe_output'  # 保存 JSON 輸出的目錄\n\ndef ensure_save_directory():\n    if not os.path.exists(SAVE_DIR):\n        os.makedirs(SAVE_DIR)\n\ndef image_to_base64(image_path):\n    with open(image_path, \"rb\") as image_file:\n        return base64.b64encode(image_file.read()).decode('utf-8')\n\ndef get_model_response(image_base64):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {API_KEY}\"\n    }\n\n    tools = [\n        {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": \"extract_underlined_text\",\n                \"description\": \"從圖片中提取紅色下劃線的文字\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"underlined_text\": {\n                            \"type\": \"array\",\n                            \"items\": {\"type\": \"string\"},\n                            \"description\": \"紅色下劃線的文字列表\"\n                        }\n                    },\n                    \"required\": [\"underlined_text\"]\n                }\n            }\n        }\n    ]\n\n    payload = {\n        \"model\": \"claude-3-5-sonnet\",\n        \"messages\": [\n            {\n                \"role\": \"user\",\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": \"請仔細分析圖片，並提取所有使用紅色筆在單字、單詞或句子下方畫有橫線的文字。只提取有紅色下劃線的文字，忽略其他未標記的文字。將結果以 JSON 格式輸出，格式為 {\\\"underlined_text\\\": [\\\"文字1\\\", \\\"文字2\\\", ...]}。\"\n                    },\n                    {\n                        \"type\": \"image_url\",\n                        \"image_url\": {\n                            \"url\": f\"data:image/jpeg;base64,{image_base64}\"\n                        }\n                    }\n                ]\n            }\n        ],\n        # \"stream\": True,\n        \"tools\": tools,\n        \"tool_choice\": {\"type\": \"function\", \"function\": {\"name\": \"extract_underlined_text\"}},\n        \"max_tokens\": 1000\n    }\n\n    try:\n        response = requests.post(f\"{BASE_URL}/chat/completions\", headers=headers, json=payload, timeout=30)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        return f\"Error: {e}\"\n\ndef save_json_output(data):\n    ensure_save_directory()\n    timestamp = datetime.now().strftime(\"%Y%m%d%H%M%S\")\n    filename = f\"{SAVE_DIR}/output_{timestamp}.json\"\n    with open(filename, 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=2)\n    return filename\n\ndef main(image_path):\n    image_base64 = image_to_base64(image_path)\n\n    response = get_model_response(image_base64)\n\n    print(\"模型回應:\")\n    print(json.dumps(response, indent=2, ensure_ascii=False))\n\n    if isinstance(response, str) and response.startswith(\"Error\"):\n        print(response)\n        return\n\n    if 'choices' in response and response['choices']:\n        message = response['choices'][0]['message']\n        if 'tool_calls' in message:\n            tool_call = message['tool_calls'][0]\n            if tool_call['function']['name'] == 'extract_underlined_text':\n                function_args = json.loads(tool_call['function']['arguments'])\n                print(\"\\n提取的紅色下劃線文字:\")\n                print(json.dumps(function_args, indent=2, ensure_ascii=False))\n\n                # 保存 JSON 輸出\n                saved_file = save_json_output(function_args)\n                print(f\"\\nJSON 輸出已保存至: {saved_file}\")\n            else:\n                print(\"\\n模型調用了未預期的函數。\")\n        else:\n            print(\"\\n模型沒有調用工具。\")\n    else:\n        print(\"\\n無法解析回應。\")\n\nif __name__ == \"__main__\":\n    image_path = \"1.jpg\"  # 替換為您的圖像路徑\n    main(image_path)"}
{"type": "test_file", "path": "test/test_rate_limit.py", "content": "import re\n\ndef parse_rate_limit(limit_string):\n    # 定义时间单位到秒的映射\n    time_units = {\n        's': 1, 'sec': 1, 'second': 1,\n        'm': 60, 'min': 60, 'minute': 60,\n        'h': 3600, 'hr': 3600, 'hour': 3600,\n        'd': 86400, 'day': 86400,\n        'mo': 2592000, 'month': 2592000,\n        'y': 31536000, 'year': 31536000\n    }\n\n    # 使用正则表达式匹配数字和单位\n    match = re.match(r'^(\\d+)/(\\w+)$', limit_string)\n    if not match:\n        raise ValueError(f\"Invalid rate limit format: {limit_string}\")\n\n    count, unit = match.groups()\n    count = int(count)\n\n    # 转换单位到秒\n    if unit not in time_units:\n        raise ValueError(f\"Unknown time unit: {unit}\")\n\n    seconds = time_units[unit]\n\n    return (count, seconds)\n\n# 测试函数\ntest_cases = [\n    \"2/min\", \"5/hour\", \"10/day\", \"1/second\", \"3/mo\", \"1/year\",\n    \"20/s\", \"15/m\", \"8/h\", \"100/d\", \"50/mo\", \"2/y\"\n]\n\nfor case in test_cases:\n    try:\n        result = parse_rate_limit(case)\n        print(f\"{case} => {result}\")\n    except ValueError as e:\n        print(f\"Error parsing {case}: {str(e)}\")"}
{"type": "test_file", "path": "test/xue/test_form_uni_api.py", "content": "from fastapi import FastAPI, Form as FastAPIForm\nfrom fastapi.responses import HTMLResponse\nfrom xue import HTML, Head, Body, Div, xue_initialize, Strong, Span, Ul, Li\nfrom xue.components import form, button, checkbox, input\nfrom xue.components.model_config_row import model_config_row\nfrom typing import List, Optional\nimport time\n\nxue_initialize(tailwind=True)\napp = FastAPI()\n\n@app.get(\"/\", response_class=HTMLResponse)\nasync def root():\n    result = HTML(\n        Head(\n            title=\"Provider Configuration Form\"\n        ),\n        Body(\n            Div(\n                form.Form(\n                    form.FormField(\"Provider\", \"provider\", placeholder=\"Enter provider name\", required=True),\n                    form.FormField(\"Base URL\", \"base_url\", placeholder=\"Enter base URL\", required=True),\n                    form.FormField(\"API Key\", \"api_key\", type=\"password\", placeholder=\"Enter API key\"),\n                    Div(\n                        Div(\"Models\", class_=\"text-lg font-semibold mb-2\"),\n                        Div(\n                            model_config_row(\"model1\", \"gpt-4o: deepbricks-gpt-4o-mini\", True),\n                            model_config_row(\"model2\", \"gpt-4o\"),\n                            model_config_row(\"model3\", \"gpt-3.5-turbo\"),\n                            model_config_row(\"model4\", \"claude-3-5-sonnet-20240620: claude-3-5-sonnet\"),\n                            model_config_row(\"model5\", \"o1-mini-all\"),\n                            model_config_row(\"model6\", \"o1-preview-all\"),\n                            model_config_row(\"model7\", \"whisper-1\"),\n                            id=\"models-container\"\n                        ),\n                        button.button(\n                            \"Add Model\",\n                            class_=\"mt-2\",\n                            hx_post=\"/add-model\",\n                            hx_target=\"#models-container\",\n                            hx_swap=\"beforeend\"\n                        ),\n                        class_=\"mb-4\"\n                    ),\n                    Div(\n                        checkbox.checkbox(\"tools\", \"Enable Tools\", checked=True),\n                        class_=\"mb-4\"\n                    ),\n                    form.FormField(\"Notes\", \"notes\", placeholder=\"Enter any additional notes\"),\n                    Div(\n                        button.button(\"Submit\", class_=\"bg-blue-500 text-white\"),\n                        button.button(\"Cancel\", class_=\"bg-gray-300 text-gray-700 ml-2\"),\n                        class_=\"flex justify-end mt-4\"\n                    ),\n                    hx_post=\"/submit\",\n                    hx_swap=\"outerHTML\",\n                    class_=\"space-y-4\"\n                ),\n                class_=\"container mx-auto p-4 max-w-2xl\"\n            )\n        )\n    ).render()\n    print(result)\n    return result\n\n@app.post(\"/add-model\", response_class=HTMLResponse)\nasync def add_model():\n    new_model_id = f\"model{hash(str(time.time()))}\"  # 生成一个唯一的ID\n    new_model = model_config_row(new_model_id).render()\n    return new_model\n\ndef form_success_message(provider, base_url, api_key, models, tools_enabled, notes):\n    return Div(\n        Strong(\"Success!\", class_=\"font-bold\"),\n        Span(\"Form submitted successfully.\", class_=\"block sm:inline\"),\n        Ul(\n            Li(f\"Provider: {provider}\"),\n            Li(f\"Base URL: {base_url}\"),\n            Li(f\"API Key: {'*' * len(api_key)}\"),\n            Li(f\"Models: {', '.join(models)}\"),\n            Li(f\"Tools Enabled: {'Yes' if tools_enabled else 'No'}\"),\n            Li(f\"Notes: {notes}\"),\n            class_=\"mt-3\"\n        ),\n        class_=\"bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative\",\n        role=\"alert\"\n    )\n\n@app.post(\"/submit\", response_class=HTMLResponse)\nasync def submit_form(\n    provider: str = FastAPIForm(...),\n    base_url: str = FastAPIForm(...),\n    api_key: str = FastAPIForm(...),\n    models: List[str] = FastAPIForm([]),\n    tools: Optional[str] = FastAPIForm(None),\n    notes: Optional[str] = FastAPIForm(None)\n):\n    # 处理提交的数据\n    print(f\"Received: provider={provider}, base_url={base_url}, api_key={api_key}\")\n    print(f\"Models: {models}\")\n    print(f\"Tools Enabled: {tools is not None}\")\n    print(f\"Notes: {notes}\")\n\n    # 返回处理结果\n    return form_success_message(\n        provider,\n        base_url,\n        api_key,\n        models,\n        tools is not None,\n        notes or \"No notes provided\"\n    ).render()\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"__main__:app\", host=\"0.0.0.0\", port=8000, reload=True)"}
{"type": "test_file", "path": "test/xue/test_home.py", "content": "from fastapi import FastAPI, Request\nfrom fastapi import Form as FastapiForm, HTTPException, Depends\nfrom fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse\nfrom fastapi.security import APIKeyHeader\nfrom typing import Optional, List\n\nfrom xue import HTML, Head, Body, Div, xue_initialize, Script\nfrom xue.components.menubar import (\n    Menubar, MenubarMenu, MenubarTrigger, MenubarContent,\n    MenubarItem, MenubarSeparator\n)\nfrom xue.components import input\nfrom xue.components import dropdown, sheet, form, button, checkbox\nfrom xue.components.model_config_row import model_config_row\nimport time\n\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))\nfrom components.provider_table import data_table\n\n\nfrom ruamel.yaml import YAML\nyaml = YAML()\nyaml.preserve_quotes = True\nyaml.indent(mapping=2, sequence=4, offset=2)\n\nxue_initialize(tailwind=True)\n\nfrom starlette.middleware.base import BaseHTTPMiddleware\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nAPI_YAML_PATH = \"./api.yaml\"\nclass RequestBodyLoggerMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        if request.method == \"POST\" and request.url.path.startswith(\"/submit/\"):\n        # if request.method == \"POST\":\n            body = await request.body()\n            logger.info(f\"Request body for {request.url.path}: {body.decode()}\")\n\n        response = await call_next(request)\n        return response\n\nfrom utils import load_config\nfrom contextlib import asynccontextmanager\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    app.state.config, app.state.api_keys_db, app.state.api_list = await load_config()\n    for item in app.state.api_keys_db:\n        if item.get(\"role\") == \"admin\":\n            app.state.admin_api_key = item.get(\"api\")\n    if not hasattr(app.state, \"admin_api_key\"):\n        if len(app.state.api_keys_db) >= 1:\n            app.state.admin_api_key = app.state.api_keys_db[0].get(\"api\")\n        else:\n            raise Exception(\"No admin API key found\")\n\n    yield\n    # 关闭时的代码\n    await app.state.client.aclose()\n\napp = FastAPI(lifespan=lifespan)\n# app.add_middleware(RequestBodyLoggerMiddleware)\napp.add_middleware(RequestBodyLoggerMiddleware)\n\ndata_table_columns = [\n    # {\"label\": \"Status\", \"value\": \"status\", \"sortable\": True},\n    {\"label\": \"Provider\", \"value\": \"provider\", \"sortable\": True},\n    {\"label\": \"Base url\", \"value\": \"base_url\", \"sortable\": True},\n    # {\"label\": \"Engine\", \"value\": \"engine\", \"sortable\": True},\n    {\"label\": \"Tools\", \"value\": \"tools\", \"sortable\": True},\n]\n\nAPI_KEY_NAME = \"X-API-Key\"\napi_key_header = APIKeyHeader(name=API_KEY_NAME, auto_error=False)\n\n@app.get(\"/login\", response_class=HTMLResponse)\nasync def login_page():\n    return HTML(\n        Head(title=\"登录\"),\n        Body(\n            Div(\n                form.Form(\n                    form.FormField(\"API Key\", \"x_api_key\", type=\"password\", placeholder=\"输入API密钥\", required=True),\n                    Div(id=\"error-message\", class_=\"text-red-500 mt-2\"),\n                    Div(\n                        button.button(\"提交\", variant=\"primary\", type=\"submit\"),\n                        class_=\"flex justify-end mt-4\"\n                    ),\n                    hx_post=\"/verify-api-key\",\n                    hx_target=\"#error-message\",\n                    hx_swap=\"innerHTML\",\n                    class_=\"space-y-4\"\n                ),\n                class_=\"container mx-auto p-4 max-w-md\"\n            )\n        )\n    ).render()\n\n\n@app.post(\"/verify-api-key\", response_class=HTMLResponse)\nasync def verify_api_key(x_api_key: str = FastapiForm(...)):\n    if x_api_key == app.state.admin_api_key:  # 替换为实际的管理员API密钥\n        response = JSONResponse(content={\"success\": True})\n        response.headers[\"HX-Redirect\"] = \"/\"  # 添加这一行\n        response.set_cookie(\n            key=\"x_api_key\",\n            value=x_api_key,\n            httponly=True,\n            max_age=1800,  # 30分钟\n            secure=False,  # 在开发环境中设置为False，生产环境中使用HTTPS时设置为True\n            samesite=\"lax\"  # 改为\"lax\"以允许重定向时携带cookie\n        )\n        return response\n    else:\n        return Div(\"无效的API密钥\", class_=\"text-red-500\").render()\n\nasync def get_api_key(request: Request, x_api_key: Optional[str] = Depends(api_key_header)):\n    if not x_api_key:\n        x_api_key = request.cookies.get(\"x_api_key\") or request.query_params.get(\"x_api_key\")\n    # print(f\"Cookie x_api_key: {request.cookies.get('x_api_key')}\")  # 添加此行\n    # print(f\"Query param x_api_key: {request.query_params.get('x_api_key')}\")  # 添加此行\n    # print(f\"Header x_api_key: {x_api_key}\")  # 添加此行\n    # logger.info(f\"x_api_key: {x_api_key} {x_api_key == 'your_admin_api_key'}\")\n\n    if x_api_key == app.state.admin_api_key:  # 替换为实际的管理员API密钥\n        return x_api_key\n    else:\n        return None\n\n@app.get(\"/\", response_class=HTMLResponse)\nasync def root(x_api_key: str = Depends(get_api_key)):\n    if not x_api_key:\n        return RedirectResponse(url=\"/login\", status_code=303)\n\n    result = HTML(\n        Head(\n            Script(\"\"\"\n                document.addEventListener('DOMContentLoaded', function() {\n                    const filterInput = document.getElementById('users-table-filter');\n                    filterInput.addEventListener('input', function() {\n                        const filterValue = this.value;\n                        htmx.ajax('GET', `/filter-table?filter=${filterValue}`, '#users-table');\n                    });\n                });\n            \"\"\"),\n            title=\"Menubar Example\"\n        ),\n        Body(\n            Div(\n                Menubar(\n                    MenubarMenu(\n                        MenubarTrigger(\"File\", \"file-menu\"),\n                        MenubarContent(\n                            MenubarItem(\"New Tab\", shortcut=\"⌘T\"),\n                            MenubarItem(\"New Window\", shortcut=\"⌘N\"),\n                            MenubarItem(\"New Incognito Window\", disabled=True),\n                            MenubarSeparator(),\n                            MenubarItem(\"Print...\", shortcut=\"⌘P\"),\n                        ),\n                        id=\"file-menu\"\n                    ),\n                    MenubarMenu(\n                        MenubarTrigger(\"Edit\", \"edit-menu\"),\n                        MenubarContent(\n                            MenubarItem(\"Undo\", shortcut=\"⌘Z\"),\n                            MenubarItem(\"Redo\", shortcut=\"⇧⌘Z\"),\n                            MenubarSeparator(),\n                            MenubarItem(\"Cut\"),\n                            MenubarItem(\"Copy\"),\n                            MenubarItem(\"Paste\"),\n                        ),\n                        id=\"edit-menu\"\n                    ),\n                    MenubarMenu(\n                        MenubarTrigger(\"View\", \"view-menu\"),\n                        MenubarContent(\n                            MenubarItem(\"Always Show Bookmarks Bar\"),\n                            MenubarItem(\"Always Show Full URLs\"),\n                            MenubarSeparator(),\n                            MenubarItem(\"Reload\", shortcut=\"⌘R\"),\n                            MenubarItem(\"Force Reload\", shortcut=\"⇧⌘R\", disabled=True),\n                            MenubarSeparator(),\n                            MenubarItem(\"Toggle Fullscreen\"),\n                            MenubarItem(\"Hide Sidebar\"),\n                        ),\n                        id=\"view-menu\"\n                    ),\n                ),\n                class_=\"p-4\"\n            ),\n            Div(\n                data_table(data_table_columns, app.state.config[\"providers\"], \"users-table\"),\n                class_=\"p-4\"\n            ),\n            Div(id=\"sheet-container\"),  # 这里是 sheet 将被加载的地方\n            class_=\"container mx-auto\",\n            id=\"body\"\n        )\n    ).render()\n    # print(result)\n    return result\n\n@app.get(\"/dropdown-menu/{menu_id}/{row_id}\", response_class=HTMLResponse)\nasync def get_columns_menu(menu_id: str, row_id: str):\n    columns = [\n        {\n            \"label\": \"Edit\",\n            \"value\": \"edit\",\n            \"hx-get\": f\"/edit-sheet/{row_id}\",\n            \"hx-target\": \"#sheet-container\",\n            \"hx-swap\": \"innerHTML\"\n        },\n        {\n            \"label\": \"Duplicate\",\n            \"value\": \"duplicate\",\n            \"hx-post\": f\"/duplicate/{row_id}\",\n            \"hx-target\": \"body\",\n            \"hx-swap\": \"outerHTML\"\n        },\n        {\n            \"label\": \"Delete\",\n            \"value\": \"delete\",\n            \"hx-delete\": f\"/delete/{row_id}\",\n            \"hx-target\": \"body\",\n            \"hx-swap\": \"outerHTML\",\n            \"hx-confirm\": \"确定要删除这个配置吗？\"\n        },\n    ]\n    result = dropdown.dropdown_menu_content(menu_id, columns).render()\n    print(result)\n    return result\n\n@app.get(\"/dropdown-menu/{menu_id}\", response_class=HTMLResponse)\nasync def get_columns_menu(menu_id: str):\n    result = dropdown.dropdown_menu_content(menu_id, data_table_columns).render()\n    print(result)\n    return result\n\n@app.get(\"/filter-table\", response_class=HTMLResponse)\nasync def filter_table(filter: str = \"\"):\n    filtered_data = [\n        provider for provider in app.state.config[\"providers\"]\n        if filter.lower() in str(provider[\"provider\"]).lower() or\n           filter.lower() in str(provider[\"base_url\"]).lower() or\n           filter.lower() in str(provider[\"tools\"]).lower()\n    ]\n    return data_table(data_table_columns, filtered_data, \"users-table\", with_filter=False).render()\n\n@app.post(\"/add-model\", response_class=HTMLResponse)\nasync def add_model():\n    new_model_id = f\"model{hash(str(time.time()))}\"  # 生成一个唯一的ID\n    new_model = model_config_row(new_model_id).render()\n    return new_model\n\n@app.get(\"/edit-sheet/{row_id}\", response_class=HTMLResponse)\nasync def get_edit_sheet(row_id: str, x_api_key: str = Depends(get_api_key)):\n    row_data = get_row_data(row_id)\n    print(\"row_data\", row_data)\n\n    model_list = []\n    for index, model in enumerate(row_data[\"model\"]):\n        if isinstance(model, str):\n            model_list.append(model_config_row(f\"model{index}\", model, \"\", True))\n        if isinstance(model, dict):\n            # print(\"model\", model, list(model.items())[0])\n            key, value = list(model.items())[0]\n            model_list.append(model_config_row(f\"model{index}\", key, value, True))\n\n    sheet_id = \"edit-sheet\"\n    edit_sheet_content = sheet.SheetContent(\n        sheet.SheetHeader(\n            sheet.SheetTitle(\"Edit Item\"),\n            sheet.SheetDescription(\"Make changes to your item here.\")\n        ),\n        sheet.SheetBody(\n            Div(\n                form.Form(\n                    form.FormField(\"Provider\", \"provider\", value=row_data[\"provider\"], placeholder=\"Enter provider name\", required=True),\n                    form.FormField(\"Base URL\", \"base_url\", value=row_data[\"base_url\"], placeholder=\"Enter base URL\", required=True),\n                    form.FormField(\"API Key\", \"api_key\", value=row_data[\"api\"], type=\"text\", placeholder=\"Enter API key\"),\n                    Div(\n                        Div(\"Models\", class_=\"text-lg font-semibold mb-2\"),\n                        Div(\n                            *model_list,\n                            id=\"models-container\"\n                        ),\n                        button.button(\n                            \"Add Model\",\n                            class_=\"mt-2\",\n                            hx_post=\"/add-model\",\n                            hx_target=\"#models-container\",\n                            hx_swap=\"beforeend\"\n                        ),\n                        class_=\"mb-4\"\n                    ),\n                    Div(\n                        checkbox.checkbox(\"tools\", \"Enable Tools\", checked=row_data[\"tools\"], name=\"tools\"),\n                        class_=\"mb-4\"\n                    ),\n                    form.FormField(\"Notes\", \"notes\", value=row_data.get(\"notes\", \"\"), placeholder=\"Enter any additional notes\"),\n                    Div(\n                        button.button(\"Submit\", variant=\"primary\", type=\"submit\"),\n                        button.button(\"Cancel\", variant=\"outline\", type=\"button\", class_=\"ml-2\", onclick=f\"toggleSheet('{sheet_id}')\"),\n                        class_=\"flex justify-end mt-4\"\n                    ),\n                    hx_post=f\"/submit/{row_id}\",\n                    hx_swap=\"outerHTML\",\n                    hx_target=\"body\",\n                    class_=\"space-y-4\"\n                ),\n                class_=\"container mx-auto p-4 max-w-2xl\"\n            )\n        )\n    )\n\n    result = sheet.Sheet(\n        sheet_id,\n        Div(),\n        edit_sheet_content,\n        width=\"80%\",\n        max_width=\"800px\"\n    ).render()\n    return result\n\n@app.get(\"/add-provider-sheet\", response_class=HTMLResponse)\nasync def get_add_provider_sheet():\n    edit_sheet_content = sheet.SheetContent(\n        sheet.SheetHeader(\n            sheet.SheetTitle(\"Add New Provider\"),\n            sheet.SheetDescription(\"Enter details for the new provider.\")\n        ),\n        sheet.SheetBody(\n            Div(\n                form.Form(\n                    form.FormField(\"Provider\", \"provider\", placeholder=\"Enter provider name\", required=True),\n                    form.FormField(\"Base URL\", \"base_url\", placeholder=\"Enter base URL\", required=True),\n                    form.FormField(\"API Key\", \"api_key\", type=\"text\", placeholder=\"Enter API key\"),\n                    Div(\n                        Div(\"Models\", class_=\"text-lg font-semibold mb-2\"),\n                        Div(id=\"models-container\"),\n                        button.button(\n                            \"Add Model\",\n                            class_=\"mt-2\",\n                            hx_post=\"/add-model\",\n                            hx_target=\"#models-container\",\n                            hx_swap=\"beforeend\"\n                        ),\n                        class_=\"mb-4\"\n                    ),\n                    Div(\n                        checkbox.checkbox(\"tools\", \"Enable Tools\", name=\"tools\"),\n                        class_=\"mb-4\"\n                    ),\n                    form.FormField(\"Notes\", \"notes\", placeholder=\"Enter any additional notes\"),\n                    Div(\n                        button.button(\"Submit\", variant=\"primary\", type=\"submit\"),\n                        button.button(\"Cancel\", variant=\"outline\", class_=\"ml-2\"),\n                        class_=\"flex justify-end mt-4\"\n                    ),\n                    hx_post=\"/submit/new\",\n                    hx_swap=\"outerHTML\",\n                    hx_target=\"body\",\n                    class_=\"space-y-4\"\n                ),\n                class_=\"container mx-auto p-4 max-w-2xl\"\n            )\n        )\n    )\n\n    result = sheet.Sheet(\n        \"add-provider-sheet\",\n        Div(),\n        edit_sheet_content,\n        width=\"80%\",\n        max_width=\"800px\"\n    ).render()\n    return result\n\ndef get_row_data(row_id):\n    index = int(row_id)\n    # print(app.state.config[\"providers\"])\n    return app.state.config[\"providers\"][index]\n\ndef update_row_data(row_id, updated_data):\n    print(row_id, updated_data)\n    index = int(row_id)\n    app.state.config[\"providers\"][index] = updated_data\n    save_api_yaml()\n\ndef save_api_yaml():\n    with open(API_YAML_PATH, \"w\", encoding=\"utf-8\") as f:\n        yaml.dump(app.state.config, f)\n\n@app.post(\"/submit/{row_id}\", response_class=HTMLResponse)\nasync def submit_form(\n    row_id: str,\n    request: Request,\n    provider: str = FastapiForm(...),\n    base_url: str = FastapiForm(...),\n    api_key: Optional[str] = FastapiForm(None),\n    tools: Optional[str] = FastapiForm(None),\n    notes: Optional[str] = FastapiForm(None),\n    x_api_key: str = Depends(get_api_key)\n):\n    form_data = await request.form()\n\n    # 收集模型数据\n    models = []\n    for key, value in form_data.items():\n        if key.startswith(\"model_name_\"):\n            model_id = key.split(\"_\")[-1]\n            enabled = form_data.get(f\"model_enabled_{model_id}\") == \"on\"\n            rename = form_data.get(f\"model_rename_{model_id}\")\n            if value:\n                if rename:\n                    models.append({value: rename})\n                else:\n                    models.append(value)\n\n    updated_data = {\n        \"provider\": provider,\n        \"base_url\": base_url,\n        \"api\": api_key,\n        \"model\": models,\n        \"tools\": tools == \"on\",\n        \"notes\": notes,\n    }\n\n    print(\"updated_data\", updated_data)\n\n    if row_id == \"new\":\n        # 添加新提供者\n        app.state.config[\"providers\"].append(updated_data)\n    else:\n        # 更新现有提供者\n        update_row_data(row_id, updated_data)\n\n    # 保存更新后的配置\n    save_api_yaml()\n\n    return await root()\n\n@app.post(\"/duplicate/{row_id}\", response_class=HTMLResponse)\nasync def duplicate_row(row_id: str):\n    index = int(row_id)\n    original_data = app.state.config[\"providers\"][index]\n    new_data = original_data.copy()\n    new_data[\"provider\"] += \"-copy\"\n    app.state.config[\"providers\"].insert(index + 1, new_data)\n\n    # 保存更新后的配置\n    save_api_yaml()\n\n    return await root()\n\n@app.delete(\"/delete/{row_id}\", response_class=HTMLResponse)\nasync def delete_row(row_id: str):\n    index = int(row_id)\n    del app.state.config[\"providers\"][index]\n\n    # 保存更新后的配置\n    save_api_yaml()\n\n    return await root()\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"__main__:app\", host=\"0.0.0.0\", port=8000, reload=True)"}
{"type": "source_file", "path": "log_config.py", "content": "import logging\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\nlogger = logging.getLogger(\"uni-api\")\n\nlogging.getLogger(\"httpx\").setLevel(logging.CRITICAL)\nlogging.getLogger(\"watchfiles.main\").setLevel(logging.CRITICAL)"}
{"type": "source_file", "path": "main.py", "content": "from log_config import logger\n\nimport copy\nimport httpx\nimport secrets\nfrom time import time\nfrom contextlib import asynccontextmanager\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi import FastAPI, HTTPException, Depends, Request, Body\nfrom fastapi.responses import JSONResponse, RedirectResponse\nfrom fastapi.responses import StreamingResponse as FastAPIStreamingResponse\nfrom starlette.responses import StreamingResponse as StarletteStreamingResponse\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom fastapi.exceptions import RequestValidationError\n\nfrom core.models import RequestModel, ImageGenerationRequest, AudioTranscriptionRequest, ModerationRequest, TextToSpeechRequest, UnifiedRequest, EmbeddingRequest\nfrom core.request import get_payload\nfrom core.response import fetch_response, fetch_response_stream\nfrom utils import (\n    safe_get,\n    load_config,\n    update_config,\n    get_model_dict,\n    post_all_models,\n    InMemoryRateLimiter,\n    error_handling_wrapper,\n)\n\nfrom core.utils import (\n    get_proxy,\n    get_engine,\n    parse_rate_limit,\n    circular_list_encoder,\n    ThreadSafeCircularList,\n    provider_api_circular_list,\n)\n\nfrom collections import defaultdict\nfrom typing import Dict, Union\nfrom urllib.parse import urlparse\n\nimport os\nimport string\nimport json\n\nDEFAULT_TIMEOUT = int(os.getenv(\"TIMEOUT\", 100))\nis_debug = bool(os.getenv(\"DEBUG\", False))\n# is_debug = False\n\nfrom sqlalchemy import inspect, text\nfrom sqlalchemy.sql import sqltypes\n\n# 添加新的环境变量检查\nDISABLE_DATABASE = os.getenv(\"DISABLE_DATABASE\", \"false\").lower() == \"true\"\nIS_VERCEL = os.path.dirname(os.path.abspath(__file__)).startswith('/var/task')\nlogger.info(\"IS_VERCEL: %s\", IS_VERCEL)\nlogger.info(\"DISABLE_DATABASE: %s\", DISABLE_DATABASE)\n\n# 读取VERSION文件内容\ntry:\n    with open('VERSION', 'r') as f:\n        VERSION = f.read().strip()\nexcept:\n    VERSION = 'unknown'\nlogger.info(\"VERSION: %s\", VERSION)\n\nasync def create_tables():\n    if DISABLE_DATABASE:\n        return\n    async with db_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n        # 检查并添加缺失的列\n        def check_and_add_columns(connection):\n            inspector = inspect(connection)\n            for table in [RequestStat, ChannelStat]:\n                table_name = table.__tablename__\n                existing_columns = {col['name']: col['type'] for col in inspector.get_columns(table_name)}\n\n                for column_name, column in table.__table__.columns.items():\n                    if column_name not in existing_columns:\n                        col_type = _map_sa_type_to_sql_type(column.type)\n                        default = _get_default_sql(column.default)\n                        connection.execute(text(f\"ALTER TABLE {table_name} ADD COLUMN {column_name} {col_type}{default}\"))\n\n        await conn.run_sync(check_and_add_columns)\n\ndef _map_sa_type_to_sql_type(sa_type):\n    type_map = {\n        sqltypes.Integer: \"INTEGER\",\n        sqltypes.String: \"TEXT\",\n        sqltypes.Float: \"REAL\",\n        sqltypes.Boolean: \"BOOLEAN\",\n        sqltypes.DateTime: \"DATETIME\",\n        sqltypes.Text: \"TEXT\"\n    }\n    return type_map.get(type(sa_type), \"TEXT\")\n\ndef _get_default_sql(default):\n    if default is None:\n        return \"\"\n    if isinstance(default.arg, bool):\n        return f\" DEFAULT {str(default.arg).upper()}\"\n    if isinstance(default.arg, (int, float)):\n        return f\" DEFAULT {default.arg}\"\n    if isinstance(default.arg, str):\n        return f\" DEFAULT '{default.arg}'\"\n    return \"\"\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # 启动时的代码\n    if not DISABLE_DATABASE:\n        await create_tables()\n\n    yield\n    # 关闭时的代码\n    # await app.state.client.aclose()\n    if hasattr(app.state, 'client_manager'):\n        await app.state.client_manager.close()\n\napp = FastAPI(lifespan=lifespan, debug=is_debug)\n\ndef generate_markdown_docs():\n    openapi_schema = app.openapi()\n\n    markdown = f\"# {openapi_schema['info']['title']}\\n\\n\"\n    markdown += f\"Version: {openapi_schema['info']['version']}\\n\\n\"\n    markdown += f\"{openapi_schema['info'].get('description', '')}\\n\\n\"\n\n    markdown += \"## API Endpoints\\n\\n\"\n\n    paths = openapi_schema['paths']\n    for path, path_info in paths.items():\n        for method, operation in path_info.items():\n            markdown += f\"### {method.upper()} {path}\\n\\n\"\n            markdown += f\"{operation.get('summary', '')}\\n\\n\"\n            markdown += f\"{operation.get('description', '')}\\n\\n\"\n\n            if 'parameters' in operation:\n                markdown += \"Parameters:\\n\"\n                for param in operation['parameters']:\n                    markdown += f\"- {param['name']} ({param['in']}): {param.get('description', '')}\\n\"\n\n            markdown += \"\\n---\\n\\n\"\n\n    return markdown\n\n@app.get(\"/docs/markdown\")\nasync def get_markdown_docs():\n    markdown = generate_markdown_docs()\n    return Response(\n        content=markdown,\n        media_type=\"text/markdown\"\n    )\n\n# @app.exception_handler(RequestValidationError)\n# async def validation_exception_handler(request: Request, exc: RequestValidationError):\n#     error_messages = []\n#     for error in exc.errors():\n#         # 将字段路径转换为点分隔格式（例如 body.model -> model）\n#         field = \".\".join(str(loc) for loc in error[\"loc\"] if loc not in (\"body\", \"query\", \"path\"))\n#         error_type = error[\"type\"]\n\n#         # 生成更友好的错误消息\n#         if error_type == \"value_error.missing\":\n#             msg = f\"字段 '{field}' 是必填项\"\n#         elif error_type == \"type_error.integer\":\n#             msg = f\"字段 '{field}' 必须是整数类型\"\n#         elif error_type == \"type_error.str\":\n#             msg = f\"字段 '{field}' 必须是字符串类型\"\n#         else:\n#             msg = error[\"msg\"]\n\n#         error_messages.append({\n#             \"field\": field,\n#             \"message\": msg,\n#             \"type\": error_type\n#         })\n\n#     return JSONResponse(\n#         status_code=422,\n#         content={\"detail\": error_messages},\n#     )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    if exc.status_code == 404:\n        logger.error(f\"404 Error: {exc.detail}\")\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail},\n    )\n\nimport uuid\nimport asyncio\nimport contextvars\nrequest_info = contextvars.ContextVar('request_info', default={})\n\nasync def parse_request_body(request: Request):\n    if request.method == \"POST\" and \"application/json\" in request.headers.get(\"content-type\", \"\"):\n        try:\n            return await request.json()\n        except json.JSONDecodeError:\n            return None\n    return None\n\nclass ChannelManager:\n    def __init__(self, cooldown_period=300):\n        self._excluded_models = defaultdict(lambda: None)\n        self.cooldown_period = cooldown_period\n\n    async def exclude_model(self, provider: str, model: str):\n        model_key = f\"{provider}/{model}\"\n        self._excluded_models[model_key] = datetime.now()\n\n    async def is_model_excluded(self, provider: str, model: str) -> bool:\n        model_key = f\"{provider}/{model}\"\n        excluded_time = self._excluded_models[model_key]\n        if not excluded_time:\n            return False\n\n        if datetime.now() - excluded_time > timedelta(seconds=self.cooldown_period):\n            del self._excluded_models[model_key]\n            return False\n        return True\n\n    async def get_available_providers(self, providers: list) -> list:\n        \"\"\"过滤出可用的providers，仅排除不可用的模型\"\"\"\n        available_providers = []\n        for provider in providers:\n            provider_name = provider['provider']\n            model_dict = provider['model'][0]  # 获取唯一的模型字典\n            # source_model = list(model_dict.keys())[0]  # 源模型名称\n            target_model = list(model_dict.values())[0]  # 目标模型名称\n\n            # 检查该模型是否被排除\n            if not await self.is_model_excluded(provider_name, target_model):\n                available_providers.append(provider)\n\n        return available_providers\n\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import declarative_base, sessionmaker\nfrom sqlalchemy import Column, Integer, String, Float, DateTime, select, Boolean, Text\nfrom sqlalchemy.sql import func\n\n# 定义数据库模型\nBase = declarative_base()\n\nclass RequestStat(Base):\n    __tablename__ = 'request_stats'\n    id = Column(Integer, primary_key=True)\n    request_id = Column(String)\n    endpoint = Column(String)\n    client_ip = Column(String)\n    process_time = Column(Float)\n    first_response_time = Column(Float)\n    provider = Column(String)\n    model = Column(String)\n    # success = Column(Boolean, default=False)\n    api_key = Column(String)\n    is_flagged = Column(Boolean, default=False)\n    text = Column(Text)\n    prompt_tokens = Column(Integer, default=0)\n    completion_tokens = Column(Integer, default=0)\n    total_tokens = Column(Integer, default=0)\n    # cost = Column(Float, default=0)\n    timestamp = Column(DateTime(timezone=True), server_default=func.now())\n\nclass ChannelStat(Base):\n    __tablename__ = 'channel_stats'\n    id = Column(Integer, primary_key=True)\n    request_id = Column(String)\n    provider = Column(String)\n    model = Column(String)\n    api_key = Column(String)\n    success = Column(Boolean, default=False)\n    timestamp = Column(DateTime(timezone=True), server_default=func.now())\n\n\nif not DISABLE_DATABASE:\n    # 获取数据库路径\n    db_path = os.getenv('DB_PATH', './data/stats.db')\n\n    # 确保 data 目录存在\n    data_dir = os.path.dirname(db_path)\n    os.makedirs(data_dir, exist_ok=True)\n\n    # 创建异步引擎和会话\n    # db_engine = create_async_engine('sqlite+aiosqlite:///' + db_path, echo=False)\n    db_engine = create_async_engine('sqlite+aiosqlite:///' + db_path, echo=is_debug)\n    async_session = sessionmaker(db_engine, class_=AsyncSession, expire_on_commit=False)\n\nfrom starlette.types import Scope, Receive, Send\nfrom starlette.responses import Response\n\nfrom asyncio import Semaphore\n\n# 创建一个信号量来控制数据库访问\ndb_semaphore = Semaphore(1)  # 限制同时只有1个写入操作\n\nasync def update_stats(current_info):\n    if DISABLE_DATABASE:\n        return\n\n    try:\n        # 等待获取数据库访问权限\n        async with db_semaphore:\n            async with async_session() as session:\n                async with session.begin():\n                    try:\n                        columns = [column.key for column in RequestStat.__table__.columns]\n                        filtered_info = {k: v for k, v in current_info.items() if k in columns}\n                        new_request_stat = RequestStat(**filtered_info)\n                        session.add(new_request_stat)\n                        await session.commit()\n                    except Exception as e:\n                        await session.rollback()\n                        logger.error(f\"Error updating stats: {str(e)}\")\n                        if is_debug:\n                            import traceback\n                            traceback.print_exc()\n    except Exception as e:\n        logger.error(f\"Error acquiring database lock: {str(e)}\")\n        if is_debug:\n            import traceback\n            traceback.print_exc()\n\nasync def update_channel_stats(request_id, provider, model, api_key, success):\n    if DISABLE_DATABASE:\n        return\n\n    try:\n        async with db_semaphore:\n            async with async_session() as session:\n                async with session.begin():\n                    try:\n                        channel_stat = ChannelStat(\n                            request_id=request_id,\n                            provider=provider,\n                            model=model,\n                            api_key=api_key,\n                            success=success,\n                        )\n                        session.add(channel_stat)\n                        await session.commit()\n                    except Exception as e:\n                        await session.rollback()\n                        logger.error(f\"Error updating channel stats: {str(e)}\")\n                        if is_debug:\n                            import traceback\n                            traceback.print_exc()\n    except Exception as e:\n        logger.error(f\"Error acquiring database lock: {str(e)}\")\n        if is_debug:\n            import traceback\n            traceback.print_exc()\n\nclass LoggingStreamingResponse(Response):\n    def __init__(self, content, status_code=200, headers=None, media_type=None, current_info=None):\n        super().__init__(content=None, status_code=status_code, headers=headers, media_type=media_type)\n        self.body_iterator = content\n        self._closed = False\n        self.current_info = current_info\n\n        # Remove Content-Length header if it exists\n        if 'content-length' in self.headers:\n            del self.headers['content-length']\n        # Set Transfer-Encoding to chunked\n        self.headers['transfer-encoding'] = 'chunked'\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await send({\n            'type': 'http.response.start',\n            'status': self.status_code,\n            'headers': self.raw_headers,\n        })\n\n        try:\n            async for chunk in self._logging_iterator():\n                await send({\n                    'type': 'http.response.body',\n                    'body': chunk,\n                    'more_body': True,\n                })\n        finally:\n            await send({\n                'type': 'http.response.body',\n                'body': b'',\n                'more_body': False,\n            })\n            if hasattr(self.body_iterator, 'aclose') and not self._closed:\n                await self.body_iterator.aclose()\n                self._closed = True\n\n            process_time = time() - self.current_info[\"start_time\"]\n            self.current_info[\"process_time\"] = process_time\n            await update_stats(self.current_info)\n\n    async def _logging_iterator(self):\n        try:\n            async for chunk in self.body_iterator:\n                if isinstance(chunk, str):\n                    chunk = chunk.encode('utf-8')\n                if self.current_info.get(\"endpoint\") == \"/v1/audio/speech\":\n                    yield chunk\n                    continue\n                line = chunk.decode('utf-8')\n                if is_debug:\n                    logger.info(f\"{line.encode('utf-8').decode('unicode_escape')}\")\n                if line.startswith(\"data:\"):\n                    line = line.lstrip(\"data: \")\n                if not line.startswith(\"[DONE]\") and not line.startswith(\"OK\"):\n                    try:\n                        resp: dict = json.loads(line)\n                        input_tokens = safe_get(resp, \"message\", \"usage\", \"input_tokens\", default=0)\n                        input_tokens = safe_get(resp, \"usage\", \"prompt_tokens\", default=0)\n                        output_tokens = safe_get(resp, \"usage\", \"completion_tokens\", default=0)\n                        total_tokens = input_tokens + output_tokens\n\n                        self.current_info[\"prompt_tokens\"] = input_tokens\n                        self.current_info[\"completion_tokens\"] = output_tokens\n                        self.current_info[\"total_tokens\"] = total_tokens\n                    except Exception as e:\n                        logger.error(f\"Error parsing response: {str(e)}, line: {repr(line)}\")\n                        continue\n                yield chunk\n        except Exception as e:\n            raise\n        finally:\n            logger.debug(\"_logging_iterator finished\")\n\n    async def close(self):\n        if not self._closed:\n            self._closed = True\n            if hasattr(self.body_iterator, 'aclose'):\n                await self.body_iterator.aclose()\n\nclass StatsMiddleware(BaseHTTPMiddleware):\n    def __init__(self, app):\n        super().__init__(app)\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time()\n\n        enable_moderation = False  # 默认不开启道德审查\n\n        config = app.state.config\n        # 根据token决定是否启用道德审查\n        if request.headers.get(\"x-api-key\"):\n            token = request.headers.get(\"x-api-key\")\n        elif request.headers.get(\"Authorization\"):\n            api_split_list = request.headers.get(\"Authorization\").split(\" \")\n            if len(api_split_list) > 1:\n                token = api_split_list[1]\n            else:\n                return JSONResponse(\n                    status_code=403,\n                    content={\"error\": \"Invalid or missing API Key\"}\n                )\n        else:\n            token = None\n\n        api_index = None\n        if token:\n            try:\n                api_list = app.state.api_list\n                api_index = api_list.index(token)\n            except ValueError:\n                # 如果 token 不在 api_list 中，检查是否以 api_list 中的任何一个开头\n                api_index = next((i for i, api in enumerate(api_list) if token.startswith(api)), None)\n                # token不在api_list中，使用默认值（不开启）\n\n            if api_index is not None:\n                enable_moderation = safe_get(config, 'api_keys', api_index, \"preferences\", \"ENABLE_MODERATION\", default=False)\n            else:\n                return JSONResponse(\n                    status_code=403,\n                    content={\"error\": \"Invalid or missing API Key\"}\n                )\n        else:\n            # 如果token为None，检查全局设置\n            enable_moderation = config.get('ENABLE_MODERATION', False)\n\n        # 在 app.state 中存储此请求的信息\n        request_id = str(uuid.uuid4())\n\n        # 初始化请求信息\n        request_info_data = {\n            \"request_id\": request_id,\n            \"start_time\": start_time,\n            \"endpoint\": f\"{request.method} {request.url.path}\",\n            \"client_ip\": request.client.host,\n            \"process_time\": 0,\n            \"first_response_time\": -1,\n            \"provider\": None,\n            \"model\": None,\n            \"success\": False,\n            \"api_key\": token,\n            \"is_flagged\": False,\n            \"text\": None,\n            \"prompt_tokens\": 0,\n            \"completion_tokens\": 0,\n            # \"cost\": 0,\n            \"total_tokens\": 0\n        }\n\n        # 设置请求信息到上下文\n        current_request_info = request_info.set(request_info_data)\n        current_info = request_info.get()\n\n        parsed_body = await parse_request_body(request)\n        if parsed_body and not request.url.path.startswith(\"/v1/api_config\"):\n            try:\n                request_model = UnifiedRequest.model_validate(parsed_body).data\n                if is_debug:\n                    logger.info(\"request_model: %s\", json.dumps(request_model.model_dump(exclude_unset=True), indent=2, ensure_ascii=False))\n                model = request_model.model\n                current_info[\"model\"] = model\n\n                final_api_key = app.state.api_list[api_index]\n                try:\n                    await app.state.user_api_keys_rate_limit[final_api_key].next(model)\n                except Exception as e:\n                    return JSONResponse(\n                        status_code=429,\n                        content={\"error\": \"Too many requests\"}\n                    )\n\n                moderated_content = None\n                if request_model.request_type == \"chat\":\n                    moderated_content = request_model.get_last_text_message()\n                elif request_model.request_type == \"image\":\n                    moderated_content = request_model.prompt\n                elif request_model.request_type == \"tts\":\n                    moderated_content = request_model.input\n                elif request_model.request_type == \"moderation\":\n                    pass\n                elif request_model.request_type == \"embedding\":\n                    if isinstance(request_model.input, list) and len(request_model.input) > 0 and isinstance(request_model.input[0], str):\n                        moderated_content = \"\\n\".join(request_model.input)\n                    else:\n                        moderated_content = request_model.input\n                else:\n                    logger.error(f\"Unknown request type: {request_model.request_type}\")\n\n                if moderated_content:\n                    current_info[\"text\"] = moderated_content\n\n                if enable_moderation and moderated_content:\n                    moderation_response = await self.moderate_content(moderated_content, api_index)\n                    is_flagged = moderation_response.get('results', [{}])[0].get('flagged', False)\n\n                    if is_flagged:\n                        logger.error(f\"Content did not pass the moral check: %s\", moderated_content)\n                        process_time = time() - start_time\n                        current_info[\"process_time\"] = process_time\n                        current_info[\"is_flagged\"] = is_flagged\n                        await update_stats(current_info)\n                        return JSONResponse(\n                            status_code=400,\n                            content={\"error\": \"Content did not pass the moral check, please modify and try again.\"}\n                        )\n            except RequestValidationError:\n                logger.error(f\"Invalid request body: {parsed_body}\")\n                pass\n            except Exception as e:\n                if is_debug:\n                    import traceback\n                    traceback.print_exc()\n\n                logger.error(f\"Error processing request or performing moral check: {str(e)}\")\n\n        try:\n            response = await call_next(request)\n\n            if request.url.path.startswith(\"/v1\") and not DISABLE_DATABASE:\n                if isinstance(response, (FastAPIStreamingResponse, StarletteStreamingResponse)) or type(response).__name__ == '_StreamingResponse':\n                    response = LoggingStreamingResponse(\n                        content=response.body_iterator,\n                        status_code=response.status_code,\n                        media_type=response.media_type,\n                        headers=response.headers,\n                        current_info=current_info,\n                    )\n                elif hasattr(response, 'json'):\n                    logger.info(f\"Response: {await response.json()}\")\n                else:\n                    logger.info(f\"Response: type={type(response).__name__}, status_code={response.status_code}, headers={response.headers}\")\n\n            return response\n        finally:\n            # print(\"current_request_info\", current_request_info)\n            request_info.reset(current_request_info)\n\n    async def moderate_content(self, content, api_index):\n        moderation_request = ModerationRequest(input=content)\n\n        # 直接调用 moderations 函数\n        response = await moderations(moderation_request, api_index)\n\n        # 读取流式响应的内容\n        moderation_result = b\"\"\n        async for chunk in response.body_iterator:\n            if isinstance(chunk, str):\n                moderation_result += chunk.encode('utf-8')\n            else:\n                moderation_result += chunk\n\n        # 解码并解析 JSON\n        moderation_data = json.loads(moderation_result.decode('utf-8'))\n\n        return moderation_data\n\n# 配置 CORS 中间件\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # 允许所有来源\n    allow_credentials=True,\n    allow_methods=[\"*\"],  # 允许所有 HTTP 方法\n    allow_headers=[\"*\"],  # 允许所有头部字段\n)\n\napp.add_middleware(StatsMiddleware)\n\nclass ClientManager:\n    def __init__(self, pool_size=100):\n        self.pool_size = pool_size\n        self.clients = {}  # {host_timeout_proxy: AsyncClient}\n\n    async def init(self, default_config):\n        self.default_config = default_config\n\n    @asynccontextmanager\n    async def get_client(self, timeout_value, base_url, proxy=None):\n        # 直接获取或创建客户端,不使用锁\n        timeout_value = int(timeout_value)\n\n        # 从base_url中提取主机名\n        parsed_url = urlparse(base_url)\n        host = parsed_url.netloc\n\n        # 创建唯一的客户端键\n        client_key = f\"{host}_{timeout_value}\"\n        if proxy:\n            # 对代理URL进行规范化处理\n            proxy_normalized = proxy.replace('socks5h://', 'socks5://')\n            client_key += f\"_{proxy_normalized}\"\n\n        if client_key not in self.clients or IS_VERCEL:\n            timeout = httpx.Timeout(\n                connect=15.0,\n                read=timeout_value,\n                write=30.0,\n                pool=self.pool_size\n            )\n            limits = httpx.Limits(max_connections=self.pool_size)\n\n            client_config = {\n                **self.default_config,\n                \"timeout\": timeout,\n                \"limits\": limits\n            }\n\n            client_config = get_proxy(proxy, client_config)\n\n            self.clients[client_key] = httpx.AsyncClient(**client_config)\n\n        try:\n            yield self.clients[client_key]\n        except Exception as e:\n            if client_key in self.clients:\n                tmp_client = self.clients[client_key]\n                del self.clients[client_key]  # 先删除引用\n                await tmp_client.aclose()  # 然后关闭客户端\n            raise e\n\n    async def close(self):\n        for client in self.clients.values():\n            await client.aclose()\n        self.clients.clear()\n\nrate_limiter = InMemoryRateLimiter()\n\nasync def rate_limit_dependency():\n    if await rate_limiter.is_rate_limited(\"global\", app.state.global_rate_limit):\n        raise HTTPException(status_code=429, detail=\"Too many requests\")\n\n@app.middleware(\"http\")\nasync def ensure_config(request: Request, call_next):\n\n    if app and not hasattr(app.state, 'config'):\n        # logger.warning(\"Config not found, attempting to reload\")\n        app.state.config, app.state.api_keys_db, app.state.api_list = await load_config(app)\n\n        if app.state.api_list:\n            app.state.user_api_keys_rate_limit = defaultdict(ThreadSafeCircularList)\n            for api_index, api_key in enumerate(app.state.api_list):\n                app.state.user_api_keys_rate_limit[api_key] = ThreadSafeCircularList(\n                    [api_key],\n                    safe_get(app.state.config, 'api_keys', api_index, \"preferences\", \"rate_limit\", default={\"default\": \"999999/min\"}),\n                    \"round_robin\"\n                )\n        app.state.global_rate_limit = parse_rate_limit(safe_get(app.state.config, \"preferences\", \"rate_limit\", default=\"999999/min\"))\n\n        for item in app.state.api_keys_db:\n            if item.get(\"role\") == \"admin\":\n                app.state.admin_api_key = item.get(\"api\")\n        if not hasattr(app.state, \"admin_api_key\"):\n            if len(app.state.api_keys_db) >= 1:\n                app.state.admin_api_key = app.state.api_keys_db[0].get(\"api\")\n            else:\n                from utils import yaml_error_message\n                if yaml_error_message:\n                    return JSONResponse(\n                        status_code=500,\n                        content={\"error\": yaml_error_message}\n                    )\n                else:\n                    return JSONResponse(\n                        status_code=500,\n                        content={\"error\": \"No admin API key found\"}\n                    )\n\n    if app and not hasattr(app.state, 'client_manager'):\n\n        default_config = {\n            \"headers\": {\n                \"User-Agent\": \"curl/7.68.0\",\n                \"Accept\": \"*/*\",\n            },\n            \"http2\": True,\n            \"verify\": True,\n            \"follow_redirects\": True\n        }\n\n        # 初始化客户端管理器\n        app.state.client_manager = ClientManager(pool_size=200)\n        await app.state.client_manager.init(default_config)\n\n        # 存储超时配置\n        app.state.timeouts = {}\n        if app.state.config and 'preferences' in app.state.config:\n            if isinstance(app.state.config['preferences'].get('model_timeout'), int):\n                app.state.timeouts[\"default\"] = app.state.config['preferences'].get('model_timeout')\n            else:\n                for model_name, timeout_value in app.state.config['preferences'].get('model_timeout', {\"default\": DEFAULT_TIMEOUT}).items():\n                    app.state.timeouts[model_name] = timeout_value\n                if \"default\" not in app.state.config['preferences'].get('model_timeout', {}):\n                    app.state.timeouts[\"default\"] = DEFAULT_TIMEOUT\n\n        app.state.provider_timeouts = defaultdict(lambda: defaultdict(lambda: DEFAULT_TIMEOUT))\n        for provider in app.state.config[\"providers\"]:\n            # print(\"provider\", provider)\n            provider_timeout_settings = safe_get(provider, \"preferences\", \"model_timeout\", default={})\n            # print(\"provider_timeout_settings\", provider_timeout_settings)\n            if provider_timeout_settings:\n                for model_name, timeout_value in provider_timeout_settings.items():\n                    app.state.provider_timeouts[provider['provider']][model_name] = timeout_value\n\n        app.state.provider_timeouts[\"global_time_out\"] = app.state.timeouts\n\n        # provider_timeouts_dict = {\n        #     provider: dict(timeouts)\n        #     for provider, timeouts in app.state.provider_timeouts.items()\n        # }\n        # print(\"app.state.provider_timeouts\", provider_timeouts_dict)\n        # print(\"ai\" in app.state.provider_timeouts)\n\n    if app and not hasattr(app.state, \"channel_manager\"):\n        if app.state.config and 'preferences' in app.state.config:\n            COOLDOWN_PERIOD = app.state.config['preferences'].get('cooldown_period', 300)\n        else:\n            COOLDOWN_PERIOD = 300\n\n        app.state.channel_manager = ChannelManager(cooldown_period=COOLDOWN_PERIOD)\n\n    if app and not hasattr(app.state, \"error_triggers\"):\n        if app.state.config and 'preferences' in app.state.config:\n            ERROR_TRIGGERS = app.state.config['preferences'].get('error_triggers', [])\n        else:\n            ERROR_TRIGGERS = []\n        app.state.error_triggers = ERROR_TRIGGERS\n\n    if app and app.state.api_keys_db and not hasattr(app.state, \"models_list\"):\n        app.state.models_list = {}\n        for item in app.state.api_keys_db:\n            api_key_model_list = item.get(\"model\", [])\n            for provider_rule in api_key_model_list:\n                provider_name = provider_rule.split(\"/\")[0]\n                if provider_name.startswith(\"sk-\") and provider_name in app.state.api_list:\n                    models_list = []\n                    try:\n                        # 构建请求头\n                        headers = {\n                            \"Authorization\": f\"Bearer {provider_name}\"\n                        }\n                        # 发送GET请求获取模型列表\n                        base_url = \"http://127.0.0.1:8000/v1/models\"\n                        async with app.state.client_manager.get_client(1, base_url) as client:\n                            response = await client.get(\n                                base_url,\n                                headers=headers\n                            )\n                            if response.status_code == 200:\n                                models_data = response.json()\n                                # 将获取到的模型添加到models_list\n                                for model in models_data.get(\"data\", []):\n                                    models_list.append(model[\"id\"])\n                    except Exception as e:\n                        if str(e):\n                            logger.error(f\"获取模型列表失败: {str(e)}\")\n                    app.state.models_list[provider_name] = models_list\n\n    return await call_next(request)\n\ndef get_timeout_value(provider_timeouts, original_model):\n    timeout_value = None\n    original_model = original_model.lower()\n    if original_model in provider_timeouts:\n        timeout_value = provider_timeouts[original_model]\n    else:\n        # 尝试模糊匹配模型\n        for timeout_model in provider_timeouts:\n            if timeout_model != \"default\" and timeout_model in original_model:\n                timeout_value = provider_timeouts[timeout_model]\n                break\n        else:\n            # 如果模糊匹配失败，使用渠道的默认值\n            timeout_value = provider_timeouts.get(\"default\")\n    return timeout_value\n\n# 在 process_request 函数中更新成功和失败计数\nasync def process_request(request: Union[RequestModel, ImageGenerationRequest, AudioTranscriptionRequest, ModerationRequest, EmbeddingRequest], provider: Dict, endpoint=None, role=None, num_matching_providers=1):\n    model_dict = get_model_dict(provider)\n    original_model = model_dict[request.model]\n    if provider['provider'].startswith(\"sk-\"):\n        api_key = provider['provider']\n    elif provider.get(\"api\"):\n        api_key = await provider_api_circular_list[provider['provider']].next(original_model)\n    else:\n        api_key = None\n\n    engine, stream_mode = get_engine(provider, endpoint, original_model)\n\n    if stream_mode != None:\n        request.stream = stream_mode\n\n    channel_id = f\"{provider['provider']}\"\n    if engine != \"moderation\":\n        logger.info(f\"provider: {channel_id:<11} model: {request.model:<22} engine: {engine} role: {role}\")\n\n    url, headers, payload = await get_payload(request, engine, provider, api_key)\n    headers.update(safe_get(provider, \"preferences\", \"headers\", default={}))  # add custom headers\n    if is_debug:\n        logger.info(url)\n        logger.info(json.dumps(headers, indent=4, ensure_ascii=False))\n        if payload.get(\"file\"):\n            pass\n        else:\n            logger.info(json.dumps(payload, indent=4, ensure_ascii=False))\n\n    current_info = request_info.get()\n\n    provider_timeouts = safe_get(app.state.provider_timeouts, channel_id, default=app.state.provider_timeouts[\"global_time_out\"])\n    timeout_value = get_timeout_value(provider_timeouts, original_model)\n    if timeout_value is None:\n        timeout_value = get_timeout_value(app.state.provider_timeouts[\"global_time_out\"], original_model)\n    if timeout_value is None:\n        timeout_value = app.state.timeouts.get(\"default\", DEFAULT_TIMEOUT)\n    timeout_value = timeout_value * num_matching_providers\n    # print(\"timeout_value\", channel_id, timeout_value)\n\n    proxy = safe_get(app.state.config, \"preferences\", \"proxy\", default=None)  # global proxy\n    proxy = safe_get(provider, \"preferences\", \"proxy\", default=proxy)  # provider proxy\n    # print(\"proxy\", proxy)\n\n    try:\n        async with app.state.client_manager.get_client(timeout_value, url, proxy) as client:\n            if request.stream:\n                generator = fetch_response_stream(client, url, headers, payload, engine, original_model)\n                wrapped_generator, first_response_time = await error_handling_wrapper(generator, channel_id, engine, request.stream, app.state.error_triggers)\n                response = StarletteStreamingResponse(wrapped_generator, media_type=\"text/event-stream\")\n            else:\n                generator = fetch_response(client, url, headers, payload, engine, original_model)\n                wrapped_generator, first_response_time = await error_handling_wrapper(generator, channel_id, engine, request.stream, app.state.error_triggers)\n\n                # 处理音频和其他二进制响应\n                if endpoint == \"/v1/audio/speech\":\n                    if isinstance(wrapped_generator, bytes):\n                        response = Response(content=wrapped_generator, media_type=\"audio/mpeg\")\n                else:\n                    first_element = await anext(wrapped_generator)\n                    first_element = first_element.lstrip(\"data: \")\n                    first_element = json.loads(first_element)\n                    response = StarletteStreamingResponse(iter([json.dumps(first_element)]), media_type=\"application/json\")\n\n            # 更新成功计数和首次响应时间\n            await update_channel_stats(current_info[\"request_id\"], channel_id, request.model, current_info[\"api_key\"], success=True)\n            current_info[\"first_response_time\"] = first_response_time\n            current_info[\"success\"] = True\n            current_info[\"provider\"] = channel_id\n            return response\n\n    except (Exception, HTTPException, asyncio.CancelledError, httpx.ReadError, httpx.RemoteProtocolError, httpx.ReadTimeout, httpx.ConnectError) as e:\n        await update_channel_stats(current_info[\"request_id\"], channel_id, request.model, current_info[\"api_key\"], success=False)\n        raise e\n\ndef weighted_round_robin(weights):\n    provider_names = list(weights.keys())\n    current_weights = {name: 0 for name in provider_names}\n    num_selections = total_weight = sum(weights.values())\n    weighted_provider_list = []\n\n    for _ in range(num_selections):\n        max_ratio = -1\n        selected_letter = None\n\n        for name in provider_names:\n            current_weights[name] += weights[name]\n            ratio = current_weights[name] / weights[name]\n\n            if ratio > max_ratio:\n                max_ratio = ratio\n                selected_letter = name\n\n        weighted_provider_list.append(selected_letter)\n        current_weights[selected_letter] -= total_weight\n\n    return weighted_provider_list\n\nimport random\n\ndef lottery_scheduling(weights):\n    total_tickets = sum(weights.values())\n    selections = []\n    for _ in range(total_tickets):\n        ticket = random.randint(1, total_tickets)\n        cumulative = 0\n        for provider, weight in weights.items():\n            cumulative += weight\n            if ticket <= cumulative:\n                selections.append(provider)\n                break\n    return selections\n\nasync def get_provider_rules(model_rule, config, request_model):\n    provider_rules = []\n    if model_rule == \"all\":\n        # 如模型名为 all，则返回所有模型\n        for provider in config[\"providers\"]:\n            model_dict = get_model_dict(provider)\n            for model in model_dict.keys():\n                provider_rules.append(provider[\"provider\"] + \"/\" + model)\n\n    elif \"/\" in model_rule:\n        if model_rule.startswith(\"<\") and model_rule.endswith(\">\"):\n            model_rule = model_rule[1:-1]\n            # 处理带斜杠的模型名\n            for provider in config['providers']:\n                model_dict = get_model_dict(provider)\n                if model_rule in model_dict.keys():\n                    provider_rules.append(provider['provider'] + \"/\" + model_rule)\n        else:\n            provider_name = model_rule.split(\"/\")[0]\n            model_name_split = \"/\".join(model_rule.split(\"/\")[1:])\n            models_list = []\n\n            # api_keys 中 api 为 sk- 时，表示继承 api_keys，将 api_keys 中的 api key 当作 渠道\n            if provider_name.startswith(\"sk-\") and provider_name in app.state.api_list:\n                if app.state.models_list.get(provider_name):\n                    models_list = app.state.models_list[provider_name]\n                else:\n                    models_list = []\n            else:\n                for provider in config['providers']:\n                    model_dict = get_model_dict(provider)\n                    if provider['provider'] == provider_name:\n                        models_list.extend(list(model_dict.keys()))\n\n            # print(\"models_list\", models_list)\n            # print(\"model_name\", model_name)\n            # print(\"model_name_split\", model_name_split)\n            # print(\"model\", model)\n\n            # api_keys 中 model 为 provider_name/* 时，表示所有模型都匹配\n            if model_name_split == \"*\":\n                if request_model in models_list:\n                    provider_rules.append(provider_name + \"/\" + request_model)\n\n                # 如果请求模型名： gpt-4* ，则匹配所有以模型名开头且不以 * 结尾的模型\n                for models_list_model in models_list:\n                    if request_model.endswith(\"*\") and models_list_model.startswith(request_model.rstrip(\"*\")):\n                        provider_rules.append(provider_name + \"/\" + models_list_model)\n\n            # api_keys 中 model 为 provider_name/model_name 时，表示模型名完全匹配\n            elif model_name_split == request_model \\\n            or (request_model.endswith(\"*\") and model_name_split.startswith(request_model.rstrip(\"*\"))): # api_keys 中 model 为 provider_name/model_name 时，请求模型名： model_name*\n                if model_name_split in models_list:\n                    provider_rules.append(provider_name + \"/\" + model_name_split)\n\n    else:\n        for provider in config[\"providers\"]:\n            model_dict = get_model_dict(provider)\n            if model_rule in model_dict.keys():\n                provider_rules.append(provider[\"provider\"] + \"/\" + model_rule)\n\n    return provider_rules\n\ndef get_provider_list(provider_rules, config, request_model):\n    provider_list = []\n    # print(\"provider_rules\", provider_rules)\n    for item in provider_rules:\n        provider_name = item.split(\"/\")[0]\n        if provider_name.startswith(\"sk-\") and provider_name in app.state.api_list:\n            provider_list.append({\"provider\": provider_name, \"base_url\": \"http://127.0.0.1:8000/v1/chat/completions\", \"model\": [{request_model: request_model}], \"tools\": True})\n        else:\n            for provider in config['providers']:\n                model_dict = get_model_dict(provider)\n                model_name_split = \"/\".join(item.split(\"/\")[1:])\n                if \"/\" in item and provider['provider'] == provider_name and model_name_split in model_dict.keys():\n                    if request_model in model_dict.keys() and model_name_split == request_model:\n                        new_provider = copy.deepcopy(provider)\n                        new_provider[\"model\"] = [{model_dict[model_name_split]: request_model}]\n                        provider_list.append(new_provider)\n\n                    elif request_model.endswith(\"*\") and model_name_split.startswith(request_model.rstrip(\"*\")):\n                        new_provider = copy.deepcopy(provider)\n                        new_provider[\"model\"] = [{model_dict[model_name_split]: request_model}]\n                        provider_list.append(new_provider)\n    return provider_list\n\nasync def get_matching_providers(request_model, config, api_index):\n    provider_rules = []\n\n    for model_rule in config['api_keys'][api_index]['model']:\n        provider_rules.extend(await get_provider_rules(model_rule, config, request_model))\n\n    provider_list = get_provider_list(provider_rules, config, request_model)\n\n    # print(\"provider_list\", provider_list)\n    return provider_list\n\nasync def get_right_order_providers(request_model, config, api_index, scheduling_algorithm):\n    matching_providers = await get_matching_providers(request_model, config, api_index)\n\n    if not matching_providers:\n        raise HTTPException(status_code=404, detail=f\"No matching model found: {request_model}\")\n\n    num_matching_providers = len(matching_providers)\n    if app.state.channel_manager.cooldown_period > 0 and num_matching_providers > 1:\n        matching_providers = await app.state.channel_manager.get_available_providers(matching_providers)\n        num_matching_providers = len(matching_providers)\n        if not matching_providers:\n            raise HTTPException(status_code=503, detail=\"No available providers at the moment\")\n\n    # 检查是否启用轮询\n    if scheduling_algorithm == \"random\":\n        matching_providers = random.sample(matching_providers, num_matching_providers)\n\n    weights = safe_get(config, 'api_keys', api_index, \"weights\")\n\n    if weights:\n        intersection = None\n        all_providers = set(provider['provider'] + \"/\" + request_model for provider in matching_providers)\n        if all_providers:\n            weight_keys = set(weights.keys())\n            provider_rules = []\n            for model_rule in weight_keys:\n                provider_rules.extend(await get_provider_rules(model_rule, config, request_model))\n            provider_list = get_provider_list(provider_rules, config, request_model)\n            weight_keys = set([provider['provider'] + \"/\" + request_model for provider in provider_list])\n            # print(\"all_providers\", all_providers)\n            # print(\"weights\", weights)\n            # print(\"weight_keys\", weight_keys)\n\n            # 步骤 3: 计算交集\n            intersection = all_providers.intersection(weight_keys)\n            # print(\"intersection\", intersection)\n            if len(intersection) == 1:\n                intersection = None\n\n        if intersection:\n            filtered_weights = {k.split(\"/\")[0]: v for k, v in weights.items() if k.split(\"/\")[0] + \"/\" + request_model in intersection}\n            # print(\"filtered_weights\", filtered_weights)\n\n            if scheduling_algorithm == \"weighted_round_robin\":\n                weighted_provider_name_list = weighted_round_robin(filtered_weights)\n            elif scheduling_algorithm == \"lottery\":\n                weighted_provider_name_list = lottery_scheduling(filtered_weights)\n            else:\n                weighted_provider_name_list = list(filtered_weights.keys())\n            # print(\"weighted_provider_name_list\", weighted_provider_name_list)\n\n            new_matching_providers = []\n            for provider_name in weighted_provider_name_list:\n                for provider in matching_providers:\n                    if provider['provider'] == provider_name:\n                        new_matching_providers.append(provider)\n            matching_providers = new_matching_providers\n\n    if is_debug:\n        for provider in matching_providers:\n            logger.info(\"available provider: %s\", json.dumps(provider, indent=4, ensure_ascii=False, default=circular_list_encoder))\n\n    return matching_providers\n\nimport asyncio\nclass ModelRequestHandler:\n    def __init__(self):\n        self.last_provider_indices = defaultdict(lambda: -1)\n        self.locks = defaultdict(asyncio.Lock)\n\n    async def request_model(self, request: Union[RequestModel, ImageGenerationRequest, AudioTranscriptionRequest, ModerationRequest, EmbeddingRequest], api_index: int = None, endpoint=None):\n        config = app.state.config\n        request_model = request.model\n        if not safe_get(config, 'api_keys', api_index, 'model'):\n            raise HTTPException(status_code=404, detail=f\"No matching model found: {request_model}\")\n\n        scheduling_algorithm = safe_get(config, 'api_keys', api_index, \"preferences\", \"SCHEDULING_ALGORITHM\", default=\"fixed_priority\")\n\n        matching_providers = await get_right_order_providers(request_model, config, api_index, scheduling_algorithm)\n        num_matching_providers = len(matching_providers)\n\n        status_code = 500\n        error_message = None\n\n        start_index = 0\n        if scheduling_algorithm != \"fixed_priority\":\n            async with self.locks[request_model]:\n                self.last_provider_indices[request_model] = (self.last_provider_indices[request_model] + 1) % num_matching_providers\n                start_index = self.last_provider_indices[request_model]\n\n        auto_retry = safe_get(config, 'api_keys', api_index, \"preferences\", \"AUTO_RETRY\", default=True)\n        role = safe_get(config, 'api_keys', api_index, \"role\", default=safe_get(config, 'api_keys', api_index, \"api\", default=\"None\")[:8])\n\n        index = 0\n        if num_matching_providers == 1 and (count := provider_api_circular_list[matching_providers[0]['provider']].get_items_count()) > 1:\n            retry_count = count\n        else:\n            retry_count = int(auto_retry)\n\n        while True:\n            # print(\"start_index\", start_index)\n            # print(\"index\", index)\n            # print(\"num_matching_providers\", num_matching_providers)\n            # print(\"retry_count\", retry_count)\n            if index >= num_matching_providers + retry_count:\n                break\n            current_index = (start_index + index) % num_matching_providers\n            index += 1\n            provider = matching_providers[current_index]\n\n            if provider['provider'].startswith(\"sk-\") and provider['provider'] in app.state.api_list:\n                local_provider_api_index = app.state.api_list.index(provider['provider'])\n                local_provider_scheduling_algorithm = safe_get(config, 'api_keys', local_provider_api_index, \"preferences\", \"SCHEDULING_ALGORITHM\", default=\"fixed_priority\")\n                local_provider_matching_providers = await get_right_order_providers(request_model, config, local_provider_api_index, local_provider_scheduling_algorithm)\n                local_provider_num_matching_providers = len(local_provider_matching_providers)\n            else:\n                local_provider_num_matching_providers = 1\n\n            try:\n                response = await process_request(request, provider, endpoint, role, local_provider_num_matching_providers)\n                return response\n            except (Exception, HTTPException, asyncio.CancelledError, httpx.ReadError, httpx.RemoteProtocolError, httpx.ReadTimeout, httpx.ConnectError) as e:\n\n                # 根据异常类型设置状态码和错误消息\n                if isinstance(e, httpx.ReadTimeout):\n                    status_code = 504  # Gateway Timeout\n                    timeout_value = e.request.extensions.get('timeout', {}).get('read', -1)\n                    error_message = f\"Request timed out after {timeout_value} seconds\"\n                elif isinstance(e, httpx.ConnectError):\n                    status_code = 503  # Service Unavailable\n                    error_message = \"Unable to connect to service\"\n                elif isinstance(e, httpx.ReadError):\n                    status_code = 502  # Bad Gateway\n                    error_message = \"Network read error\"\n                elif isinstance(e, httpx.RemoteProtocolError):\n                    status_code = 502  # Bad Gateway\n                    error_message = \"Remote protocol error\"\n                elif isinstance(e, asyncio.CancelledError):\n                    status_code = 499  # Client Closed Request\n                    error_message = \"Request was cancelled\"\n                elif isinstance(e, HTTPException):\n                    status_code = e.status_code\n                    error_message = str(e.detail)\n                else:\n                    status_code = 500  # Internal Server Error\n                    error_message = str(e) or f\"Unknown error: {e.__class__.__name__}\"\n\n                channel_id = f\"{provider['provider']}\"\n                if app.state.channel_manager.cooldown_period > 0 and num_matching_providers > 1:\n                    # 获取源模型名称（实际配置的模型名）\n                    # source_model = list(provider['model'][0].keys())[0]\n                    await app.state.channel_manager.exclude_model(channel_id, request_model)\n                    matching_providers = await get_right_order_providers(request_model, config, api_index, scheduling_algorithm)\n                    last_num_matching_providers = num_matching_providers\n                    num_matching_providers = len(matching_providers)\n                    if num_matching_providers != last_num_matching_providers:\n                        index = 0\n\n                cooling_time = safe_get(provider, \"preferences\", \"api_key_cooldown_period\", default=0)\n                api_key_count = provider_api_circular_list[channel_id].get_items_count()\n                current_api = await provider_api_circular_list[channel_id].after_next_current()\n                if cooling_time > 0 and api_key_count > 1:\n                    await provider_api_circular_list[channel_id].set_cooling(current_api, cooling_time=cooling_time)\n\n                if \"string_above_max_length\" in error_message:\n                    status_code = 413\n                if \"must be less than max_seq_len\" in error_message:\n                    status_code = 413\n\n                logger.error(f\"Error {status_code} with provider {channel_id} API key: {current_api}: {error_message}\")\n                if is_debug:\n                    import traceback\n                    traceback.print_exc()\n                if auto_retry and (status_code != 413 or urlparse(provider.get('base_url', '')).netloc == 'models.inference.ai.azure.com'):\n                    continue\n                else:\n                    return JSONResponse(\n                        status_code=status_code,\n                        content={\"error\": f\"Error: Current provider response failed: {error_message}\"}\n                    )\n\n        current_info = request_info.get()\n        current_info[\"first_response_time\"] = -1\n        current_info[\"success\"] = False\n        current_info[\"provider\"] = None\n        return JSONResponse(\n            status_code=status_code,\n            content={\"error\": f\"All {request.model} error: {error_message}\"}\n        )\n\nmodel_handler = ModelRequestHandler()\n\nsecurity = HTTPBearer()\n\ndef verify_api_key(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    api_list = app.state.api_list\n    token = credentials.credentials\n    api_index = None\n    try:\n        api_index = api_list.index(token)\n    except ValueError:\n        # 如果 token 不在 api_list 中，检查是否以 api_list 中的任何一个开头\n        api_index = next((i for i, api in enumerate(api_list) if token.startswith(api)), None)\n    if api_index is None:\n        raise HTTPException(status_code=403, detail=\"Invalid or missing API Key\")\n    return api_index\n\ndef verify_admin_api_key(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    api_list = app.state.api_list\n    token = credentials.credentials\n    api_index = None\n    try:\n        api_index = api_list.index(token)\n    except ValueError:\n        # 如果 token 不在 api_list 中，检查是否以 api_list 中的任何一个开头\n        api_index = next((i for i, api in enumerate(api_list) if token.startswith(api)), None)\n    if api_index is None:\n        raise HTTPException(status_code=403, detail=\"Invalid or missing API Key\")\n    # for api_key in app.state.api_keys_db:\n    #     if token.startswith(api_key['api']):\n    if app.state.api_keys_db[api_index].get('role') != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    return token\n\n@app.post(\"/v1/chat/completions\", dependencies=[Depends(rate_limit_dependency)])\nasync def request_model(request: RequestModel, api_index: int = Depends(verify_api_key)):\n    return await model_handler.request_model(request, api_index)\n\n@app.options(\"/v1/chat/completions\", dependencies=[Depends(rate_limit_dependency)])\nasync def options_handler():\n    return JSONResponse(status_code=200, content={\"detail\": \"OPTIONS allowed\"})\n\n@app.get(\"/v1/models\", dependencies=[Depends(rate_limit_dependency)])\nasync def list_models(api_index: int = Depends(verify_api_key)):\n    models = post_all_models(api_index, app.state.config, app.state.api_list, app.state.models_list)\n    return JSONResponse(content={\n        \"object\": \"list\",\n        \"data\": models\n    })\n\n@app.post(\"/v1/images/generations\", dependencies=[Depends(rate_limit_dependency)])\nasync def images_generations(\n    request: ImageGenerationRequest,\n    api_index: int = Depends(verify_api_key)\n):\n    return await model_handler.request_model(request, api_index, endpoint=\"/v1/images/generations\")\n\n@app.post(\"/v1/embeddings\", dependencies=[Depends(rate_limit_dependency)])\nasync def embeddings(\n    request: EmbeddingRequest,\n    api_index: int = Depends(verify_api_key)\n):\n    return await model_handler.request_model(request, api_index, endpoint=\"/v1/embeddings\")\n\n@app.post(\"/v1/audio/speech\", dependencies=[Depends(rate_limit_dependency)])\nasync def audio_speech(\n    request: TextToSpeechRequest,\n    api_index: str = Depends(verify_api_key)\n):\n    return await model_handler.request_model(request, api_index, endpoint=\"/v1/audio/speech\")\n\n@app.post(\"/v1/moderations\", dependencies=[Depends(rate_limit_dependency)])\nasync def moderations(\n    request: ModerationRequest,\n    api_index: int = Depends(verify_api_key)\n):\n    return await model_handler.request_model(request, api_index, endpoint=\"/v1/moderations\")\n\nfrom fastapi import UploadFile, File, Form, HTTPException\nimport io\n@app.post(\"/v1/audio/transcriptions\", dependencies=[Depends(rate_limit_dependency)])\nasync def audio_transcriptions(\n    file: UploadFile = File(...),\n    model: str = Form(...),\n    api_index: int = Depends(verify_api_key)\n):\n    try:\n        # 读取上传的文件内容\n        content = await file.read()\n        file_obj = io.BytesIO(content)\n\n        # 创建AudioTranscriptionRequest对象\n        request = AudioTranscriptionRequest(\n            file=(file.filename, file_obj, file.content_type),\n            model=model\n        )\n\n        return await model_handler.request_model(request, api_index, endpoint=\"/v1/audio/transcriptions\")\n    except UnicodeDecodeError:\n        raise HTTPException(status_code=400, detail=\"Invalid audio file encoding\")\n    except Exception as e:\n        if is_debug:\n            import traceback\n            traceback.print_exc()\n        raise HTTPException(status_code=500, detail=f\"Error processing audio file: {str(e)}\")\n\n@app.get(\"/v1/generate-api-key\", dependencies=[Depends(rate_limit_dependency)])\ndef generate_api_key():\n    # Define the character set (only alphanumeric)\n    chars = string.ascii_letters + string.digits\n    # Generate a random string of 36 characters\n    random_string = ''.join(secrets.choice(chars) for _ in range(48))\n    api_key = \"sk-\" + random_string\n    return JSONResponse(content={\"api_key\": api_key})\n\n# 在 /stats 路由中返回成功和失败百分比\nfrom datetime import datetime, timedelta, timezone\nfrom sqlalchemy import func, desc, case\nfrom fastapi import Query\n\n@app.get(\"/v1/stats\", dependencies=[Depends(rate_limit_dependency)])\nasync def get_stats(\n    request: Request,\n    token: str = Depends(verify_admin_api_key),\n    hours: int = Query(default=24, ge=1, le=720, description=\"Number of hours to look back for stats (1-720)\")\n):\n    '''\n    ## 获取统计数据\n\n    使用 `/v1/stats` 获取最近 24 小时各个渠道的使用情况统计。同时带上 自己的 uni-api 的 admin API key。\n\n    数据包括：\n\n    1. 每个渠道下面每个模型的成功率，成功率从高到低排序。\n    2. 每个渠道总的成功率，成功率从高到低排序。\n    3. 每个模型在所有渠道总的请求次数。\n    4. 每个端点的请求次数。\n    5. 每个ip请求的次数。\n\n    `/v1/stats?hours=48` 参数 `hours` 可以控制返回最近多少小时的数据统计，不传 `hours` 这个参数，默认统计最近 24 小时的统计数据。\n\n    还有其他统计数据，可以自己写sql在数据库自己查。其他数据包括：首字时间，每个请求的总处理时间，每次请求是否成功，每次请求是否符合道德审查，每次请求的文本内容，每次请求的 API key，每次请求的输入 token，输出 token 数量。\n    '''\n    if DISABLE_DATABASE:\n        return JSONResponse(content={\"stats\": {}})\n    async with async_session() as session:\n        # 计算指定时间范围的开始时间\n        start_time = datetime.now(timezone.utc) - timedelta(hours=hours)\n\n        # 1. 每个渠道下面每个模型的成功率\n        channel_model_stats = await session.execute(\n            select(\n                ChannelStat.provider,\n                ChannelStat.model,\n                func.count().label('total'),\n                func.sum(case((ChannelStat.success == True, 1), else_=0)).label('success_count')\n            )\n            .where(ChannelStat.timestamp >= start_time)\n            .group_by(ChannelStat.provider, ChannelStat.model)\n        )\n        channel_model_stats = channel_model_stats.fetchall()\n\n        # 2. 每个渠道总的成功率\n        channel_stats = await session.execute(\n            select(\n                ChannelStat.provider,\n                func.count().label('total'),\n                func.sum(case((ChannelStat.success == True, 1), else_=0)).label('success_count')\n            )\n            .where(ChannelStat.timestamp >= start_time)\n            .group_by(ChannelStat.provider)\n        )\n        channel_stats = channel_stats.fetchall()\n\n        # 3. 每个模型在所有渠道总的请求次数\n        model_stats = await session.execute(\n            select(RequestStat.model, func.count().label('count'))\n            .where(RequestStat.timestamp >= start_time)\n            .group_by(RequestStat.model)\n            .order_by(desc('count'))\n        )\n        model_stats = model_stats.fetchall()\n\n        # 4. 每个端点的请求次数\n        endpoint_stats = await session.execute(\n            select(RequestStat.endpoint, func.count().label('count'))\n            .where(RequestStat.timestamp >= start_time)\n            .group_by(RequestStat.endpoint)\n            .order_by(desc('count'))\n        )\n        endpoint_stats = endpoint_stats.fetchall()\n\n        # 5. 每个ip请求的次数\n        ip_stats = await session.execute(\n            select(RequestStat.client_ip, func.count().label('count'))\n            .where(RequestStat.timestamp >= start_time)\n            .group_by(RequestStat.client_ip)\n            .order_by(desc('count'))\n        )\n        ip_stats = ip_stats.fetchall()\n\n    # 处理统计数据并返回\n    stats = {\n        \"time_range\": f\"Last {hours} hours\",\n        \"channel_model_success_rates\": [\n            {\n                \"provider\": stat.provider,\n                \"model\": stat.model,\n                \"success_rate\": stat.success_count / stat.total if stat.total > 0 else 0,\n                \"total_requests\": stat.total\n            } for stat in sorted(channel_model_stats, key=lambda x: x.success_count / x.total if x.total > 0 else 0, reverse=True)\n        ],\n        \"channel_success_rates\": [\n            {\n                \"provider\": stat.provider,\n                \"success_rate\": stat.success_count / stat.total if stat.total > 0 else 0,\n                \"total_requests\": stat.total\n            } for stat in sorted(channel_stats, key=lambda x: x.success_count / x.total if x.total > 0 else 0, reverse=True)\n        ],\n        \"model_request_counts\": [\n            {\n                \"model\": stat.model,\n                \"count\": stat.count\n            } for stat in model_stats\n        ],\n        \"endpoint_request_counts\": [\n            {\n                \"endpoint\": stat.endpoint,\n                \"count\": stat.count\n            } for stat in endpoint_stats\n        ],\n        \"ip_request_counts\": [\n            {\n                \"ip\": stat.client_ip,\n                \"count\": stat.count\n            } for stat in ip_stats\n        ]\n    }\n\n    return JSONResponse(content=stats)\n\n@app.get(\"/\", dependencies=[Depends(rate_limit_dependency)])\nasync def root():\n    return RedirectResponse(url=\"https://uni-api-web.pages.dev\", status_code=302)\n\n# async def on_fetch(request, env):\n#     import asgi\n#     return await asgi.fetch(app, request, env)\n\n@app.get(\"/v1/api_config\", dependencies=[Depends(rate_limit_dependency)])\nasync def api_config(api_index: int = Depends(verify_api_key)):\n    return JSONResponse(content={\"api_config\": app.state.config})\n\n@app.post(\"/v1/api_config/update\", dependencies=[Depends(rate_limit_dependency)])\nasync def api_config_update(api_index: int = Depends(verify_api_key), config: dict = Body(...)):\n    if \"providers\" in config:\n        app.state.config[\"providers\"] = config[\"providers\"]\n        app.state.config, app.state.api_keys_db, app.state.api_list = update_config(app.state.config, use_config_url=False)\n    return JSONResponse(content={\"message\": \"API config updated\"})\n\nfrom fastapi.staticfiles import StaticFiles\n# 添加静态文件挂载\napp.mount(\"/\", StaticFiles(directory=\"./static\", html=True), name=\"static\")\n\nif __name__ == '__main__':\n    import uvicorn\n    import os\n    PORT = int(os.getenv(\"PORT\", \"8000\"))\n    uvicorn.run(\n        \"__main__:app\",\n        host=\"0.0.0.0\",\n        port=PORT,\n        reload=True,\n        reload_dirs=[\"./\"],\n        reload_includes=[\"*.py\", \"api.yaml\"],\n        ws=\"none\",\n        # log_level=\"warning\"\n    )\n"}
{"type": "source_file", "path": "utils.py", "content": "import json\nimport httpx\nimport asyncio\nfrom time import time\nfrom log_config import logger\nfrom fastapi import HTTPException\nfrom collections import defaultdict\n\nfrom core.utils import (\n    safe_get,\n    get_model_dict,\n    update_initial_model,\n    ThreadSafeCircularList,\n    provider_api_circular_list,\n)\n\nclass InMemoryRateLimiter:\n    def __init__(self):\n        self.requests = defaultdict(list)\n\n    async def is_rate_limited(self, key: str, limits) -> bool:\n        now = time()\n\n        # 检查所有速率限制条件\n        for limit, period in limits:\n            # 计算在当前时间窗口内的请求数量\n            recent_requests = sum(1 for req in self.requests[key] if req > now - period)\n            if recent_requests >= limit:\n                return True\n\n        # 清理太旧的请求记录（比最长时间窗口还要老的记录）\n        max_period = max(period for _, period in limits)\n        self.requests[key] = [req for req in self.requests[key] if req > now - max_period]\n\n        # 记录新的请求\n        self.requests[key].append(now)\n        return False\n\nfrom ruamel.yaml import YAML, YAMLError\nyaml = YAML()\nyaml.preserve_quotes = True\nyaml.indent(mapping=2, sequence=4, offset=2)\n\nAPI_YAML_PATH = \"./api.yaml\"\nyaml_error_message = None\n\ndef save_api_yaml(config_data):\n    with open(API_YAML_PATH, \"w\", encoding=\"utf-8\") as f:\n        yaml.dump(config_data, f)\n\ndef update_config(config_data, use_config_url=False):\n    for index, provider in enumerate(config_data['providers']):\n        if provider.get('project_id'):\n            provider['base_url'] = 'https://aiplatform.googleapis.com/'\n        if provider.get('cf_account_id'):\n            provider['base_url'] = 'https://api.cloudflare.com/'\n\n        if isinstance(provider['provider'], int):\n            provider['provider'] = str(provider['provider'])\n\n        provider_api = provider.get('api', None)\n        if provider_api:\n            if isinstance(provider_api, int):\n                provider_api = str(provider_api)\n            if isinstance(provider_api, str):\n                provider_api_circular_list[provider['provider']] = ThreadSafeCircularList(\n                    [provider_api],\n                    safe_get(provider, \"preferences\", \"api_key_rate_limit\", default={\"default\": \"999999/min\"}),\n                    safe_get(provider, \"preferences\", \"api_key_schedule_algorithm\", default=\"round_robin\")\n                )\n            if isinstance(provider_api, list):\n                provider_api_circular_list[provider['provider']] = ThreadSafeCircularList(\n                    provider_api,\n                    safe_get(provider, \"preferences\", \"api_key_rate_limit\", default={\"default\": \"999999/min\"}),\n                    safe_get(provider, \"preferences\", \"api_key_schedule_algorithm\", default=\"round_robin\")\n                )\n\n        if \"models.inference.ai.azure.com\" in provider['base_url'] and not provider.get(\"model\"):\n            provider['model'] = [\n                \"gpt-4o\",\n                \"gpt-4o-mini\",\n                \"o1-mini\",\n                \"o1-preview\",\n                \"text-embedding-3-small\",\n                \"text-embedding-3-large\",\n            ]\n\n        if not provider.get(\"model\"):\n            model_list = update_initial_model(provider)\n            if model_list:\n                provider[\"model\"] = model_list\n                if not use_config_url:\n                    save_api_yaml(config_data)\n\n        if provider.get(\"tools\") == None:\n            provider[\"tools\"] = True\n\n        config_data['providers'][index] = provider\n\n    for index, api_key in enumerate(config_data['api_keys']):\n        if \"api\" in api_key:\n            config_data['api_keys'][index][\"api\"] = str(api_key[\"api\"])\n\n    api_keys_db = config_data['api_keys']\n\n    for index, api_key in enumerate(config_data['api_keys']):\n        weights_dict = {}\n        models = []\n\n        # 确保api字段为字符串类型\n        if \"api\" in api_key:\n            config_data['api_keys'][index][\"api\"] = str(api_key[\"api\"])\n\n        if api_key.get('model'):\n            for model in api_key.get('model'):\n                if isinstance(model, dict):\n                    key, value = list(model.items())[0]\n                    provider_name = key.split(\"/\")[0]\n                    model_name = key.split(\"/\")[1]\n\n                    for provider_item in config_data[\"providers\"]:\n                        if provider_item['provider'] != provider_name:\n                            continue\n                        model_dict = get_model_dict(provider_item)\n                        if model_name in model_dict.keys():\n                            weights_dict.update({provider_name + \"/\" + model_name: int(value)})\n                        elif model_name == \"*\":\n                            weights_dict.update({provider_name + \"/\" + model_name: int(value) for model_item in model_dict.keys()})\n\n                    models.append(key)\n                if isinstance(model, str):\n                    models.append(model)\n            if weights_dict:\n                config_data['api_keys'][index]['weights'] = weights_dict\n            config_data['api_keys'][index]['model'] = models\n            api_keys_db[index]['model'] = models\n        else:\n            # Default to all models if 'model' field is not set\n            config_data['api_keys'][index]['model'] = [\"all\"]\n            api_keys_db[index]['model'] = [\"all\"]\n\n    api_list = [item[\"api\"] for item in api_keys_db]\n    # logger.info(json.dumps(config_data, indent=4, ensure_ascii=False))\n    return config_data, api_keys_db, api_list\n\n# 读取YAML配置文件\nasync def load_config(app=None):\n    import os\n    try:\n        with open(API_YAML_PATH, 'r', encoding='utf-8') as file:\n            conf = yaml.load(file)\n\n        if conf:\n            config, api_keys_db, api_list = update_config(conf, use_config_url=False)\n        else:\n            logger.error(\"配置文件 'api.yaml' 为空。请检查文件内容。\")\n            config, api_keys_db, api_list = {}, {}, []\n    except FileNotFoundError:\n        if not os.environ.get('CONFIG_URL'):\n            logger.error(\"'api.yaml' not found. Please check the file path.\")\n        config, api_keys_db, api_list = {}, {}, []\n    except YAMLError as e:\n        logger.error(\"配置文件 'api.yaml' 格式不正确。请检查 YAML 格式。%s\", e)\n        global yaml_error_message\n        yaml_error_message = \"配置文件 'api.yaml' 格式不正确。请检查 YAML 格式。\"\n        config, api_keys_db, api_list = {}, {}, []\n    except OSError as e:\n        logger.error(f\"open 'api.yaml' failed: {e}\")\n        config, api_keys_db, api_list = {}, {}, []\n\n    if config != {}:\n        return config, api_keys_db, api_list\n\n    # 新增： 从环境变量获取配置URL并拉取配置\n    config_url = os.environ.get('CONFIG_URL')\n    if config_url:\n        try:\n            default_config = {\n                \"headers\": {\n                    \"User-Agent\": \"curl/7.68.0\",\n                    \"Accept\": \"*/*\",\n                },\n                \"http2\": True,\n                \"verify\": True,\n                \"follow_redirects\": True\n            }\n            # 初始化客户端管理器\n            timeout = httpx.Timeout(\n                connect=15.0,\n                read=100,\n                write=30.0,\n                pool=200\n            )\n            client = httpx.AsyncClient(\n                timeout=timeout,\n                **default_config\n            )\n            response = await client.get(config_url)\n            # logger.info(f\"Fetching config from {response.text}\")\n            response.raise_for_status()\n            config_data = yaml.load(response.text)\n            # 更新配置\n            # logger.info(config_data)\n            if config_data:\n                config, api_keys_db, api_list = update_config(config_data, use_config_url=True)\n            else:\n                logger.error(f\"Error fetching or parsing config from {config_url}\")\n                config, api_keys_db, api_list = {}, {}, []\n        except Exception as e:\n            logger.error(f\"Error fetching or parsing config from {config_url}: {str(e)}\")\n            config, api_keys_db, api_list = {}, {}, []\n    return config, api_keys_db, api_list\n\ndef ensure_string(item):\n    if isinstance(item, (bytes, bytearray)):\n        return item.decode(\"utf-8\")\n    elif isinstance(item, str):\n        return item\n    elif isinstance(item, dict):\n        return f\"data: {json.dumps(item)}\\n\\n\"\n    else:\n        return str(item)\n\ndef identify_audio_format(file_bytes):\n    # 读取开头的字节\n    if file_bytes.startswith(b'\\xFF\\xFB') or file_bytes.startswith(b'\\xFF\\xF3'):\n        return \"MP3\"\n    elif file_bytes.startswith(b'ID3'):\n        return \"MP3 with ID3\"\n    elif file_bytes.startswith(b'OpusHead'):\n        return \"OPUS\"\n    elif file_bytes.startswith(b'ADIF'):\n        return \"AAC (ADIF)\"\n    elif file_bytes.startswith(b'\\xFF\\xF1') or file_bytes.startswith(b'\\xFF\\xF9'):\n        return \"AAC (ADTS)\"\n    elif file_bytes.startswith(b'fLaC'):\n        return \"FLAC\"\n    elif file_bytes.startswith(b'RIFF') and file_bytes[8:12] == b'WAVE':\n        return \"WAV\"\n    return \"Unknown/PCM\"\n\nimport asyncio\nimport time as time_module\nasync def error_handling_wrapper(generator, channel_id, engine, stream, error_triggers):\n    start_time = time_module.time()\n    try:\n        first_item = await generator.__anext__()\n        first_response_time = time_module.time() - start_time\n        first_item_str = first_item\n        # logger.info(\"first_item_str: %s :%s\", type(first_item_str), first_item_str)\n        if isinstance(first_item_str, (bytes, bytearray)):\n            if identify_audio_format(first_item_str) in [\"MP3\", \"MP3 with ID3\", \"OPUS\", \"AAC (ADIF)\", \"AAC (ADTS)\", \"FLAC\", \"WAV\"]:\n                return first_item, first_response_time\n            else:\n                first_item_str = first_item_str.decode(\"utf-8\")\n        if isinstance(first_item_str, str):\n            if first_item_str.startswith(\"data:\"):\n                first_item_str = first_item_str.lstrip(\"data: \")\n            if first_item_str.startswith(\"[DONE]\"):\n                logger.error(f\"provider: {channel_id:<11} error_handling_wrapper [DONE]!\")\n                raise StopAsyncIteration\n            try:\n                encode_first_item_str = first_item_str.encode().decode('unicode-escape')\n            except UnicodeDecodeError:\n                encode_first_item_str = first_item_str\n                logger.error(f\"provider: {channel_id:<11} error UnicodeDecodeError: %s\", first_item_str)\n            if any(x in encode_first_item_str for x in error_triggers):\n                logger.error(f\"provider: {channel_id:<11} error const string: %s\", encode_first_item_str)\n                raise StopAsyncIteration\n            try:\n                first_item_str = json.loads(first_item_str)\n            except json.JSONDecodeError:\n                logger.error(f\"provider: {channel_id:<11} error_handling_wrapper JSONDecodeError! {repr(first_item_str)}\")\n                raise StopAsyncIteration\n        if isinstance(first_item_str, dict) and 'error' in first_item_str and first_item_str.get('error') != {\"message\": \"\",\"type\": \"\",\"param\": \"\",\"code\": None}:\n            # 如果第一个 yield 的项是错误信息，抛出 HTTPException\n            status_code = first_item_str.get('status_code', 500)\n            detail = first_item_str.get('details', f\"{first_item_str}\")\n            raise HTTPException(status_code=status_code, detail=f\"{detail}\"[:300])\n\n        if isinstance(first_item_str, dict) and safe_get(first_item_str, \"choices\", 0, \"error\", default=None):\n            # 如果第一个 yield 的项是错误信息，抛出 HTTPException\n            status_code = safe_get(first_item_str, \"choices\", 0, \"error\", \"code\", default=500)\n            detail = safe_get(first_item_str, \"choices\", 0, \"error\", \"message\", default=f\"{first_item_str}\")\n            raise HTTPException(status_code=status_code, detail=f\"{detail}\"[:300])\n\n        if isinstance(first_item_str, dict) and engine not in [\"tts\", \"embedding\", \"dalle\", \"moderation\", \"whisper\"] and stream == False:\n            if any(x in str(first_item_str) for x in error_triggers):\n                logger.error(f\"provider: {channel_id:<11} error const string: %s\", first_item_str)\n                raise StopAsyncIteration\n            content = safe_get(first_item_str, \"choices\", 0, \"message\", \"content\", default=None)\n            tool_calls = safe_get(first_item_str, \"choices\", 0, \"message\", \"tool_calls\", default=None)\n            if (content == \"\" or content is None) and (tool_calls == \"\" or tool_calls is None):\n                raise StopAsyncIteration\n\n        # 如果不是错误，创建一个新的生成器，首先yield第一个项，然后yield剩余的项\n        async def new_generator():\n            # print(\"type(first_item)\", type(first_item))\n            # print(\"first_item\", ensure_string(first_item))\n            yield ensure_string(first_item)\n            try:\n                async for item in generator:\n                    yield ensure_string(item)\n            except asyncio.CancelledError:\n                # 客户端断开连接是正常行为，不需要记录错误日志\n                logger.debug(f\"provider: {channel_id:<11} Stream cancelled by client\")\n                return\n            except (httpx.ReadError, httpx.RemoteProtocolError) as e:\n                # 只记录真正的网络错误\n                # logger.error(f\"provider: {channel_id:<11} Network error in new_generator: {e}\")\n                raise HTTPException(status_code=502, detail=f\"Network error in new_generator: {e}\")\n            except httpx.ReadTimeout as e:\n                raise HTTPException(status_code=504, detail=f\"Read timeout in new_generator: {e}\")\n\n        return new_generator(), first_response_time\n\n    except StopAsyncIteration:\n        raise HTTPException(status_code=400, detail=\"data: {'error': 'No data returned'}\")\n\ndef post_all_models(api_index, config, api_list, models_list):\n    all_models = []\n    unique_models = set()\n\n    if config['api_keys'][api_index]['model']:\n        for model in config['api_keys'][api_index]['model']:\n            if model == \"all\":\n                # 如果模型名为 all，则返回所有模型\n                all_models = get_all_models(config)\n                return all_models\n            if \"/\" in model:\n                provider = model.split(\"/\")[0]\n                model = model.split(\"/\")[1]\n                if model == \"*\":\n                    if provider.startswith(\"sk-\") and provider in api_list:\n                        for model_item in models_list[provider]:\n                            if model_item not in unique_models:\n                                unique_models.add(model_item)\n                                model_info = {\n                                    \"id\": model_item,\n                                    \"object\": \"model\",\n                                    \"created\": 1720524448858,\n                                    \"owned_by\": \"uni-api\"\n                                }\n                                all_models.append(model_info)\n                    else:\n                        for provider_item in config[\"providers\"]:\n                            if provider_item['provider'] != provider:\n                                continue\n                            model_dict = get_model_dict(provider_item)\n                            for model_item in model_dict.keys():\n                                if model_item not in unique_models:\n                                    unique_models.add(model_item)\n                                    model_info = {\n                                        \"id\": model_item,\n                                        \"object\": \"model\",\n                                        \"created\": 1720524448858,\n                                        \"owned_by\": \"uni-api\"\n                                        # \"owned_by\": provider_item['provider']\n                                    }\n                                    all_models.append(model_info)\n                else:\n                    if provider.startswith(\"sk-\") and provider in api_list:\n                        if model in models_list[provider] and model not in unique_models:\n                            unique_models.add(model)\n                            model_info = {\n                                \"id\": model,\n                                \"object\": \"model\",\n                                \"created\": 1720524448858,\n                                \"owned_by\": \"uni-api\"\n                            }\n                            all_models.append(model_info)\n                    else:\n                        for provider_item in config[\"providers\"]:\n                            if provider_item['provider'] != provider:\n                                continue\n                            model_dict = get_model_dict(provider_item)\n                            for model_item in model_dict.keys():\n                                if model_item not in unique_models and model_item == model:\n                                    unique_models.add(model_item)\n                                    model_info = {\n                                        \"id\": model_item,\n                                        \"object\": \"model\",\n                                        \"created\": 1720524448858,\n                                        \"owned_by\": \"uni-api\"\n                                    }\n                                    all_models.append(model_info)\n                continue\n\n            if model.startswith(\"sk-\") and model in api_list:\n                continue\n\n            if model not in unique_models:\n                unique_models.add(model)\n                model_info = {\n                    \"id\": model,\n                    \"object\": \"model\",\n                    \"created\": 1720524448858,\n                    \"owned_by\": \"uni-api\"\n                }\n                all_models.append(model_info)\n\n    return all_models\n\ndef get_all_models(config):\n    all_models = []\n    unique_models = set()\n\n    for provider in config[\"providers\"]:\n        model_dict = get_model_dict(provider)\n        for model in model_dict.keys():\n            if model not in unique_models:\n                unique_models.add(model)\n                model_info = {\n                    \"id\": model,\n                    \"object\": \"model\",\n                    \"created\": 1720524448858,\n                    \"owned_by\": \"uni-api\"\n                }\n                all_models.append(model_info)\n\n    return all_models"}
{"type": "source_file", "path": "components/provider_table.py", "content": "from xue import Div, Table, Thead, Tbody, Tr, Th, Td, Button, Input, Script, Head, Style, Span\nfrom xue.components.checkbox import checkbox\nfrom xue.components.dropdown import dropdown_menu, dropdown_menu_content\nfrom xue.components.button import button\nfrom xue.components.input import input\n\nHead.add_default_children([\n    Style(\"\"\"\n        .data-table-container {\n            width: 100%;\n            overflow-x: auto;\n            border: 1px solid #e2e8f0;\n            border-radius: 0.5rem;\n            overflow-x: visible !important;\n        }\n        .data-table {\n            width: 100%;\n            border-collapse: separate;\n            border-spacing: 0;\n        }\n        .data-table th, .data-table td {\n            padding: 0.75rem 1rem;\n            text-align: left;\n            border-bottom: 1px solid #e2e8f0;\n        }\n        .data-table th {\n            font-weight: 500;\n            font-size: 0.875rem;\n            color: #4b5563;\n            height: 2.5rem;\n            transition: background-color 0.2s;\n        }\n        .data-table thead tr:hover th,\n        .data-table tbody tr:hover {\n            background-color: #f8fafc;\n        }\n        .data-table tbody tr:last-child td {\n            border-bottom: none;\n        }\n        .sortable-header {\n            cursor: pointer;\n            user-select: none;\n            display: inline-flex;\n            align-items: center;\n            padding: 0.25rem 0.5rem;\n            border-radius: 0.25rem;\n            transition: background-color 0.2s;\n        }\n        .sortable-header:hover {\n            background-color: #e5e7eb;\n        }\n        .sort-icon {\n            display: inline-block;\n            width: 1rem;\n            height: 1rem;\n            margin-left: 0.25rem;\n            transition: transform 0.2s;\n            opacity: 0;\n        }\n        .sortable-header:hover .sort-icon,\n        .sort-asc .sort-icon,\n        .sort-desc .sort-icon {\n            opacity: 1;\n        }\n        .sort-asc .sort-icon {\n            transform: rotate(180deg);\n        }\n        .table-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            margin-bottom: 1rem;\n        }\n        .table-footer {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            margin-top: 1rem;\n        }\n        .pagination {\n            display: flex;\n            gap: 0.5rem;\n        }\n        @media (prefers-color-scheme: dark) {\n            .data-table-container {\n                border-color: #4b5563;\n            }\n            .data-table th, .data-table td {\n                border-color: #4b5563;\n            }\n            .data-table th {\n                color: #d1d5db;\n            }\n            .data-table thead tr:hover th,\n            .data-table tbody tr:hover {\n                background-color: #1f2937;\n            }\n            .sortable-header:hover {\n                background-color: #374151;\n            }\n        }\n    \"\"\", id=\"data-table-style\"),\n    Script(\"\"\"\n        function toggleAllRows(checked) {\n            const checkboxes = document.querySelectorAll('.row-checkbox');\n            checkboxes.forEach(cb => cb.checked = checked);\n            updateSelectedCount();\n        }\n\n        function updateSelectedCount() {\n            const selectedCount = document.querySelectorAll('.row-checkbox:checked').length;\n            const totalCount = document.querySelectorAll('.row-checkbox').length;\n            document.getElementById('selected-count').textContent = `${selectedCount} of ${totalCount} row(s) selected.`;\n        }\n\n        function sortTable(columnIndex, accessor) {\n            const table = document.querySelector('.data-table');\n            const header = table.querySelector(`th[data-accessor=\"${accessor}\"]`);\n            const isAscending = !header.classList.contains('sort-asc');\n\n            // Update sort direction\n            table.querySelectorAll('th').forEach(th => th.classList.remove('sort-asc', 'sort-desc'));\n            header.classList.add(isAscending ? 'sort-asc' : 'sort-desc');\n\n            // Sort the table\n            const rows = Array.from(table.querySelectorAll('tbody tr'));\n            rows.sort((a, b) => {\n                const aValue = a.querySelector(`td[data-accessor=\"${accessor}\"]`).textContent;\n                const bValue = b.querySelector(`td[data-accessor=\"${accessor}\"]`).textContent;\n                return isAscending ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);\n            });\n\n            // Update the table\n            const tbody = table.querySelector('tbody');\n            rows.forEach(row => tbody.appendChild(row));\n        }\n\n        document.addEventListener('change', function(event) {\n            if (event.target.classList.contains('row-checkbox')) {\n                updateSelectedCount();\n            }\n        });\n    \"\"\", id=\"data-table-script\"),\n])\n\ndef data_table(columns, data, id, with_filter=True, row_ids=None):\n    if row_ids is None:\n        row_ids = range(len(data))\n\n    tbody_content = Tbody(\n        *[Tr(\n            Td(checkbox(f\"row-{i}\", \"\", class_=\"row-checkbox\")),\n            *[Td(row[col['value']], data_accessor=col['value']) for col in columns],\n            Td(row_actions_menu(row_id)),\n            id=f\"row-{row_id}\"\n        ) for i, (row, row_id) in enumerate(zip(data, row_ids))]\n    )\n\n    return Div(\n        Div(\n            input(type=\"text\", placeholder=\"Filter...\", id=f\"{id}-filter\", class_=\"mr-auto\"),\n            Div(\n                button(\n                    \"Add Provider\",\n                    variant=\"secondary\",\n                    hx_get=\"/add-provider-sheet\",\n                    hx_target=\"#sheet-container\",\n                    hx_swap=\"innerHTML\",\n                    class_=\"h-[2.625rem]\"\n                ),\n                dropdown_menu(\"Columns\"),\n            ),\n            class_=\"table-header flex items-center\"\n        ) if with_filter else None,\n        Div(\n            Div(\n                Table(\n                    Thead(\n                        Tr(\n                            Th(checkbox(\"select-all\", \"\", onclick=\"toggleAllRows(this.checked)\")),\n                            *[Th(\n                                Div(\n                                    col['label'],\n                                    Span(\"▼\", class_=\"sort-icon\"),\n                                    class_=\"sortable-header\" if col.get('sortable', False) else \"\",\n                                    onclick=f\"sortTable({i}, '{col['value']}')\" if col.get('sortable', False) else None\n                                ),\n                                data_accessor=col['value']\n                            ) for i, col in enumerate(columns)],\n                            Th(\"Actions\")  # 新增的操作列\n                        )\n                    ),\n                    tbody_content,\n                    class_=\"data-table\"\n                ),\n                class_=\"data-table-container\"\n            ),\n            Div(\n                Div(id=\"selected-count\", class_=\"text-sm text-gray-500\"),\n                Div(\n                    button(\"Previous\", variant=\"outline\", class_=\"mr-2\"),\n                    button(\"Next\", variant=\"outline\"),\n                    class_=\"pagination\"\n                ),\n                class_=\"table-footer\"\n            ),\n            id=id\n        ),\n    )\n\ndef get_column_visibility_menu(id, columns):\n    return dropdown_menu_content(id, [\n        {\"label\": col['label'], \"value\": col['value']}\n        for col in columns if col.get('can_hide', True)\n    ])\n\ndef row_actions_menu(row_id):\n    return dropdown_menu(\"⋮\", id=f\"row-actions-menu-{row_id}\", hx_get=f\"/dropdown-menu/dropdown-menu-⋮/{row_id}\")\n\ndef get_row_actions_menu(row_id):\n    return dropdown_menu_content(f\"row-actions-{row_id}\", [\n        {\"label\": \"Edit\", \"icon\": \"pencil\"},\n        {\"label\": \"Duplicate\", \"icon\": \"copy\"},\n        {\"label\": \"Delete\", \"icon\": \"trash\"},\n        \"separator\",\n        {\"label\": \"More...\", \"icon\": \"more-horizontal\"},\n    ])\n\ndef render_row(row_data, row_id, columns):\n    return Tr(\n        Td(checkbox(f\"row-{row_id}\", \"\", class_=\"row-checkbox\")),\n        *[Td(row_data[col['value']], data_accessor=col['value']) for col in columns],\n        Td(row_actions_menu(row_id)),\n        id=f\"row-{row_id}\"\n    ).render()"}

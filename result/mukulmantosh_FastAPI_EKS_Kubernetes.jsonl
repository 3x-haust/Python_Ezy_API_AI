{"repo_info": {"repo_name": "FastAPI_EKS_Kubernetes", "repo_owner": "mukulmantosh", "repo_url": "https://github.com/mukulmantosh/FastAPI_EKS_Kubernetes"}}
{"type": "test_file", "path": "tests/cart/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/login/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/orders/test_orders.py", "content": "import pytest\nfrom httpx import AsyncClient\n\nfrom ecommerce.auth.jwt import create_access_token\nfrom conf_test_db import app\nfrom tests.shared.info import category_info, product_info\n\n\n@pytest.mark.asyncio\nasync def test_order_processing(mocker):\n    mocker.patch('ecommerce.orders.tasks.send_email', return_value=True)\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        user_access_token = create_access_token({\"sub\": \"john@gmail.com\"})\n        category_obj = await category_info()\n        product_obj = await product_info(category_obj)\n\n        cart_response = await ac.get(f\"/cart/add\",\n                                     params={'product_id': product_obj.id},\n                                     headers={'Authorization': f'Bearer {user_access_token}'})\n\n        order_response = await ac.post(\"/orders/\", headers={'Authorization': f'Bearer {user_access_token}'})\n\n    assert cart_response.status_code == 201\n    assert order_response.status_code == 201\n\n\n@pytest.mark.asyncio\nasync def test_order_listing():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        user_access_token = create_access_token({\"sub\": \"john@gmail.com\"})\n        response = await ac.get(\"/orders/\", headers={'Authorization': f'Bearer {user_access_token}'})\n\n    assert response.status_code == 200\n"}
{"type": "test_file", "path": "tests/home/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/orders/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/cart/test_cart.py", "content": "import pytest\nfrom httpx import AsyncClient\n\nfrom ecommerce.auth.jwt import create_access_token\nfrom conf_test_db import app\nfrom tests.shared.info import category_info, product_info\n\n\n@pytest.mark.asyncio\nasync def test_add_to_cart():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        category_obj = await category_info()\n        product_obj = await product_info(category_obj)\n        user_access_token = create_access_token({\"sub\": \"john@gmail.com\"})\n\n        response = await ac.get(f\"/cart/add\",\n                                params={'product_id': product_obj.id},\n                                headers={'Authorization': f'Bearer {user_access_token}'})\n\n    assert response.status_code == 201\n    assert response.json() == {\"status\": \"Item Added to Cart\"}\n\n\n@pytest.mark.asyncio\nasync def test_cart_listing():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        user_access_token = create_access_token({\"sub\": \"john@gmail.com\"})\n\n        response = await ac.get(f\"/cart/\", headers={'Authorization': f'Bearer {user_access_token}'})\n\n    assert response.status_code == 200\n"}
{"type": "test_file", "path": "tests/login/test_login.py", "content": "import pytest\n\nfrom httpx import AsyncClient\n\nfrom conf_test_db import app\n\n\n@pytest.mark.asyncio\nasync def test_login():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        response = await ac.post(\"/login\", data={'username': 'john@gmail.com', 'password': 'john123'})\n    assert response.status_code == 200\n\n\n"}
{"type": "test_file", "path": "tests/home/test_home.py", "content": "import pytest\nfrom httpx import AsyncClient\n\nfrom conf_test_db import app\n\n\n@pytest.mark.asyncio\nasync def test_root():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        response = await ac.get(\"/\")\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Not Found\"}"}
{"type": "test_file", "path": "tests/conftest.py", "content": "import pytest\n\nfrom ecommerce.user.models import User\n\n\n@pytest.fixture(autouse=True)\ndef create_dummy_user(tmpdir):\n    \"\"\"Fixture to execute asserts before and after a test is run\"\"\"\n    # Setup: fill with any logic you want\n    from conf_test_db import override_get_db\n    database = next(override_get_db())\n    new_user = User(name='John', email='john@gmail.com', password='john123')\n    database.add(new_user)\n    database.commit()\n\n    yield  # this is where the testing happens\n\n    # Teardown : fill with any logic you want\n    database.query(User).filter(User.email == 'john@gmail.com').delete()\n    database.commit()\n"}
{"type": "test_file", "path": "tests/shared/info.py", "content": "from faker import Faker\n\nfrom ecommerce.products.models import Category, Product\nfrom conf_test_db import override_get_db\n\n\nasync def category_info() -> Category:\n    fake = Faker()\n    database = next(override_get_db())\n    category_count = database.query(Category).filter().count()\n    if category_count <= 0:\n        category_obj = Category(name=fake.name())\n        database.add(category_obj)\n        database.commit()\n        database.refresh(category_obj)\n\n    else:\n        category_obj = database.query(Category).order_by(Category.id.desc()).first()\n    return category_obj\n\n\nasync def product_info(category_obj: Category) -> Product:\n    database = next(override_get_db())\n\n    payload = {\n        \"name\": \"Quaker Oats\",\n        \"quantity\": 4,\n        \"description\": \"Quaker: Good Quality Oats\",\n        \"price\": 10,\n        \"category_id\": category_obj.id\n    }\n    new_product = Product(**payload)\n    database.add(new_product)\n    database.commit()\n    return new_product\n"}
{"type": "test_file", "path": "tests/user/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/registration/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/products/test_products.py", "content": "import pytest\nfrom httpx import AsyncClient\n\nfrom conf_test_db import app\nfrom tests.shared.info import category_info, product_info\n\n\n@pytest.mark.asyncio\nasync def test_new_product():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        category_obj = await category_info()\n        payload = {\n            \"name\": \"Quaker Oats\",\n            \"quantity\": 4,\n            \"description\": \"Quaker: Good Quality Oats\",\n            \"price\": 10,\n            \"category_id\": category_obj.id\n        }\n\n        response = await ac.post(\"/products/\", json=payload)\n    assert response.status_code == 201\n    assert response.json()['name'] == \"Quaker Oats\"\n    assert response.json()['quantity'] == 4\n    assert response.json()['description'] == \"Quaker: Good Quality Oats\"\n    assert response.json()['price'] == 10\n\n\n@pytest.mark.asyncio\nasync def test_list_products():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        category_obj = await category_info()\n        await product_info(category_obj)\n\n        response = await ac.get(\"/products/\")\n    assert response.status_code == 200\n    assert 'name' in response.json()[0]\n    assert 'quantity' in response.json()[0]\n    assert 'description' in response.json()[0]\n    assert 'price' in response.json()[0]\n"}
{"type": "test_file", "path": "tests/products/test_categories.py", "content": "import pytest\nfrom httpx import AsyncClient\n\nfrom ecommerce.products.models import Category\nfrom conf_test_db import app, override_get_db\n\n\n@pytest.mark.asyncio\nasync def test_new_category():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        response = await ac.post(\"/products/category\", json={'name': 'Apparels'})\n    assert response.status_code == 201\n    assert response.json()['name'] == \"Apparels\"\n\n\n@pytest.mark.asyncio\nasync def test_list_get_category():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        database = next(override_get_db())\n        new_category = Category(name=\"Food\")\n        database.add(new_category)\n        database.commit()\n        database.refresh(new_category)\n        first_response = await ac.get(\"/products/category\")\n        second_response = await ac.get(f\"/products/category/{new_category.id}\")\n    assert first_response.status_code == 200\n    assert second_response.status_code == 200\n    assert second_response.json() == {\"id\": new_category.id, \"name\": new_category.name}\n\n\n@pytest.mark.asyncio\nasync def test_delete_category():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        database = next(override_get_db())\n        new_category = Category(name=\"Electronics\")\n        database.add(new_category)\n        database.commit()\n        database.refresh(new_category)\n        response = await ac.delete(f\"/products/category/{new_category.id}\")\n    assert response.status_code == 204\n"}
{"type": "test_file", "path": "tests/registration/test_user_registration.py", "content": "import pytest\n\nfrom faker import Faker\nfrom httpx import AsyncClient\n\nfrom conf_test_db import app\n\n\n@pytest.mark.asyncio\nasync def test_registration():\n    fake = Faker()\n    data = {\n        \"name\": fake.name(),\n        \"email\": fake.email(),\n        \"password\": fake.password()\n    }\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        response = await ac.post(\"/user/\", json=data)\n    assert response.status_code == 201\n"}
{"type": "test_file", "path": "tests/user/test_user.py", "content": "import pytest\nfrom httpx import AsyncClient\n\nfrom ecommerce.auth.jwt import create_access_token\nfrom conf_test_db import app\n\n\n@pytest.mark.asyncio\nasync def test_all_users():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        user_access_token = create_access_token({\"sub\": \"john@gmail.com\"})\n        response = await ac.get(\"/user/\", headers={'Authorization': f'Bearer {user_access_token}'})\n    assert response.status_code == 200\n"}
{"type": "test_file", "path": "tests/shared/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/products/__init__.py", "content": ""}
{"type": "source_file", "path": "ecommerce/user/hashing.py", "content": "from passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"argon2\"], deprecated=\"auto\")\n\n\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n"}
{"type": "source_file", "path": "ecommerce/auth/__init__.py", "content": ""}
{"type": "source_file", "path": "ecommerce/cart/router.py", "content": "from fastapi import APIRouter, Depends, status, Response\nfrom sqlalchemy.orm import Session\n\nfrom ecommerce import db\nfrom ecommerce.auth.jwt import get_current_user\nfrom ecommerce.user.schema import User\nfrom .schema import ShowCart\nfrom .services import add_to_cart, get_all_items, remove_cart_item\n\nrouter = APIRouter(\n    tags=['Cart'],\n    prefix='/cart'\n)\n\n\n@router.get('/', response_model=ShowCart)\nasync def get_all_cart_items(current_user: User = Depends(get_current_user),\n                             database: Session = Depends(db.get_db)):\n    result = await get_all_items(current_user, database)\n    return result\n\n\n@router.get('/add', status_code=status.HTTP_201_CREATED)\nasync def add_product_to_cart(product_id: int, current_user: User = Depends(get_current_user),\n                              database: Session = Depends(db.get_db)):\n    result = await add_to_cart(product_id, current_user, database)\n    return result\n\n\n@router.delete('/{cart_item_id}', status_code=status.HTTP_204_NO_CONTENT, response_class=Response)\nasync def remove_cart_item_by_id(cart_item_id: int, current_user: User = Depends(get_current_user),\n                                 database: Session = Depends(db.get_db)):\n    await remove_cart_item(cart_item_id, current_user, database)\n"}
{"type": "source_file", "path": "main.py", "content": "from celery import Celery\nfrom fastapi import FastAPI\n\nfrom ecommerce import config\nfrom ecommerce.auth import router as auth_router\nfrom ecommerce.cart import router as cart_router\nfrom ecommerce.orders import router as order_router\nfrom ecommerce.products import router as product_router\nfrom ecommerce.user import router as user_router\n\n\ndescription = \"\"\"\nEcommerce API\n\n## Users\n\nYou will be able to:\n\n* **Create users** \n* **Read users** \n\"\"\"\n\napp = FastAPI(\n    title=\"EcommerceApp\",\n    description=description,\n    version=\"0.0.1\",\n    terms_of_service=\"http://example.com/terms/\",\n    contact={\n        \"name\": \"Mukul Mantosh\",\n        \"url\": \"http://x-force.example.com/contact/\",\n    },\n    license_info={\n        \"name\": \"Apache 2.0\",\n        \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n    },\n)\napp.include_router(auth_router.router)\napp.include_router(user_router.router)\napp.include_router(product_router.router)\napp.include_router(cart_router.router)\napp.include_router(order_router.router)\n\ncelery = Celery(\n    __name__,\n    broker=f\"redis://{config.REDIS_HOST}:{config.REDIS_PORT}/{config.REDIS_DB}\",\n    backend=f\"redis://{config.REDIS_HOST}:{config.REDIS_PORT}/{config.REDIS_DB}\"\n)\ncelery.conf.imports = [\n    'ecommerce.orders.tasks',\n]\n"}
{"type": "source_file", "path": "alembic/versions/3ecb256a8f85_.py", "content": "\"\"\"empty message\n\nRevision ID: 3ecb256a8f85\nRevises: \nCreate Date: 2021-08-11 05:40:43.656315\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '3ecb256a8f85'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('category',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('name', sa.String(length=50), nullable=True),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('name', sa.String(length=50), nullable=True),\n    sa.Column('email', sa.String(length=255), nullable=True),\n    sa.Column('password', sa.String(length=255), nullable=True),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('email')\n    )\n    op.create_table('products',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('name', sa.String(length=50), nullable=True),\n    sa.Column('quantity', sa.Integer(), nullable=True),\n    sa.Column('description', sa.Text(), nullable=True),\n    sa.Column('price', sa.Float(), nullable=True),\n    sa.Column('category_id', sa.Integer(), nullable=True),\n    sa.ForeignKeyConstraint(['category_id'], ['category.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('products')\n    op.drop_table('users')\n    op.drop_table('category')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "ecommerce/user/validator.py", "content": "from typing import Optional\n\nfrom sqlalchemy.orm import Session\n\nfrom .models import User\n\n\nasync def verify_email_exist(email: str, db_session: Session) -> Optional[User]:\n    return db_session.query(User).filter(User.email == email).first()\n"}
{"type": "source_file", "path": "ecommerce/orders/tasks.py", "content": "from celery import shared_task\nfrom . import mail\n\n\n@shared_task\ndef send_email(email):\n    return mail.order_notification(email)\n"}
{"type": "source_file", "path": "ecommerce/cart/schema.py", "content": "import datetime\nfrom typing import List\n\nfrom pydantic import BaseModel\n\nfrom ecommerce.products.schema import Product\n\n\nclass ShowCartItems(BaseModel):\n    id: int\n    products: Product\n    created_date: datetime.datetime\n\n    class Config:\n        orm_mode = True\n\n\nclass ShowCart(BaseModel):\n    id: int\n    cart_items: List[ShowCartItems] = []\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "ecommerce/config.py", "content": "import os\n\nAPP_ENV = os.getenv('APP_ENV', 'development')\nDATABASE_USERNAME = os.getenv('DATABASE_USERNAME', 'postgres')\nDATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD', 'mukul123')\nDATABASE_HOST = os.getenv('DATABASE_HOST', '192.168.0.101')\nDATABASE_NAME = os.getenv('DATABASE_NAME', 'mukuldb')\nTEST_DATABASE_NAME = os.getenv('DATABASE_NAME', 'test_mukuldb')\nREDIS_HOST = os.getenv('REDIS_HOST', '127.0.0.1')\nREDIS_PORT = os.getenv('REDIS_PORT', '6379')\nREDIS_DB = os.getenv('REDIS_DB', '0' if APP_ENV == 'TESTING' else '0')\n"}
{"type": "source_file", "path": "ecommerce/orders/services.py", "content": "from typing import List\n\nfrom fastapi import HTTPException, status\n\nfrom ecommerce.cart.models import Cart, CartItems\nfrom ecommerce.orders.models import Order, OrderDetails\nfrom ecommerce.user.models import User\nfrom . import tasks\n\n\nasync def initiate_order(current_user, database) -> Order:\n    user_info = database.query(User).filter(User.email == current_user.email).first()\n    cart = database.query(Cart).filter(Cart.user_id == user_info.id).first()\n\n    cart_items_objects = database.query(CartItems).filter(Cart.id == cart.id)\n    if not cart_items_objects.count():\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Items found in Cart !\")\n\n    total_amount: float = 0.0\n    for item in cart_items_objects:\n        total_amount += item.products.price\n\n    new_order = Order(order_amount=total_amount,\n                      shipping_address=\"587 Hinkle Deegan Lake Road, Syracuse, New York\",\n                      customer_id=user_info.id)\n    database.add(new_order)\n    database.commit()\n    database.refresh(new_order)\n\n    bulk_order_details_objects = list()\n    for item in cart_items_objects:\n        new_order_details = OrderDetails(order_id=new_order.id,\n                                         product_id=item.products.id)\n        bulk_order_details_objects.append(new_order_details)\n\n    database.bulk_save_objects(bulk_order_details_objects)\n    database.commit()\n\n    # Send Email\n    tasks.send_email.delay(current_user.email)\n\n    # clear items in cart\n    database.query(CartItems).filter(CartItems.cart_id == cart.id).delete()\n    database.commit()\n\n    return new_order\n\n\nasync def get_order_listing(current_user, database) -> List[Order]:\n    user_info = database.query(User).filter(User.email == current_user.email).first()\n    orders = database.query(Order).filter(Order.customer_id == user_info.id).all()\n    return orders\n"}
{"type": "source_file", "path": "ecommerce/products/router.py", "content": "from typing import List\n\nfrom fastapi import APIRouter, Depends, status, Response, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom ecommerce import db\nfrom . import schema\nfrom . import services\nfrom . import validator\n\nrouter = APIRouter(\n    tags=['Products'],\n    prefix='/products'\n)\n\n\n@router.post('/category', status_code=status.HTTP_201_CREATED)\nasync def create_category(request: schema.Category, database: Session = Depends(db.get_db)):\n    new_category = await services.create_new_category(request, database)\n    return new_category\n\n\n@router.get('/category', response_model=List[schema.ListCategory])\nasync def get_all_categories(database: Session = Depends(db.get_db)):\n    return await services.get_all_categories(database)\n\n\n@router.get('/category/{category_id}', response_model=schema.ListCategory)\nasync def get_category_by_id(category_id: int, database: Session = Depends(db.get_db)):\n    return await services.get_category_by_id(category_id, database)\n\n\n@router.delete('/category/{category_id}', status_code=status.HTTP_204_NO_CONTENT, response_class=Response)\nasync def delete_category_by_id(category_id: int, database: Session = Depends(db.get_db)):\n    return await services.delete_category_by_id(category_id, database)\n\n\n@router.post('/', status_code=status.HTTP_201_CREATED)\nasync def create_product(request: schema.Product, database: Session = Depends(db.get_db)):\n    category = await validator.verify_category_exist(request.category_id, database)\n    if not category:\n        raise HTTPException(\n            status_code=400,\n            detail=\"You have provided invalid category id.\",\n        )\n\n    product = await services.create_new_product(request, database)\n    return product\n\n\n@router.get('/', response_model=List[schema.ProductListing])\nasync def get_all_products(database: Session = Depends(db.get_db)):\n    return await services.get_all_products(database)\n"}
{"type": "source_file", "path": "ecommerce/orders/__init__.py", "content": ""}
{"type": "source_file", "path": "ecommerce/user/models.py", "content": "from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import relationship\nfrom ecommerce.db import Base\nfrom . import hashing\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String(50))\n    email = Column(String(255), unique=True)\n    password = Column(String(255))\n    order = relationship(\"Order\", back_populates=\"user_info\")\n    cart = relationship(\"Cart\", back_populates=\"user_cart\")\n\n    def __init__(self, name, email, password, *args, **kwargs):\n        self.name = name\n        self.email = email\n        self.password = hashing.get_password_hash(password)\n\n    def check_password(self, password):\n        return hashing.verify_password(self.password, password)\n\n"}
{"type": "source_file", "path": "ecommerce/db.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nfrom . import config\n\nDATABASE_USERNAME = config.DATABASE_USERNAME\nDATABASE_PASSWORD = config.DATABASE_PASSWORD\nDATABASE_HOST = config.DATABASE_HOST\nDATABASE_NAME = config.DATABASE_NAME\n\nSQLALCHEMY_DATABASE_URL = f\"postgresql://{DATABASE_USERNAME}:{DATABASE_PASSWORD}@{DATABASE_HOST}/{DATABASE_NAME}\"\n\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nBase = declarative_base()\n\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "ecommerce/products/validator.py", "content": "from typing import Optional\n\nfrom sqlalchemy.orm import Session\n\nfrom .models import Category\n\n\nasync def verify_category_exist(category_id: int, db_session: Session) -> Optional[Category]:\n    return db_session.query(Category).filter(Category.id == category_id).first()\n"}
{"type": "source_file", "path": "ecommerce/cart/services.py", "content": "from fastapi import HTTPException, status, Depends\nfrom sqlalchemy import and_\nfrom sqlalchemy.orm import Session\n\nfrom ecommerce import db\nfrom ecommerce.products.models import Product\nfrom ecommerce.user.models import User\nfrom .models import Cart, CartItems\nfrom .schema import ShowCart\n\n\nasync def add_to_cart(product_id: int, current_user, database: Session = Depends(db.get_db)):\n    product_info = database.query(Product).get(product_id)\n    if not product_id:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Data Not Found !\")\n\n    if product_info.quantity <= 0:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Item Out of Stock !\")\n\n    user_info = database.query(User).filter(User.email == current_user.email).first()\n\n    cart_info = database.query(Cart).filter(Cart.user_id == user_info.id).first()\n    if not cart_info:\n        new_cart = Cart(user_id=user_info.id)\n        database.add(new_cart)\n        database.commit()\n        database.refresh(new_cart)\n        await add_items(new_cart.id, product_info.id, database)\n    else:\n        await add_items(cart_info.id, product_info.id, database)\n    return {\"status\": \"Item Added to Cart\"}\n\n\nasync def add_items(cart_id: int, product_id: int, database: Session = Depends(db.get_db)):\n    cart_items = CartItems(cart_id=cart_id, product_id=product_id)\n    database.add(cart_items)\n    database.commit()\n    database.refresh(cart_items)\n\n    product_object = database.query(Product).filter(Product.id == product_id)\n    current_quantity = product_object.first().quantity - 1\n    product_object.update({\"quantity\": current_quantity})\n    database.commit()\n    return {'detail': 'Object Updated'}\n\n\nasync def get_all_items(current_user, database) -> ShowCart:\n    user_info = database.query(User).filter(User.email == current_user.email).first()\n    cart = database.query(Cart).filter(Cart.user_id == user_info.id).first()\n    return cart\n\n\nasync def remove_cart_item(cart_item_id: int, current_user, database) -> None:\n    user_info = database.query(User).filter(User.email == current_user.email).first()\n    cart_id = database.query(Cart).filter(User.id == user_info.id).first()\n    database.query(CartItems).filter(and_(CartItems.id == cart_item_id, CartItems.cart_id == cart_id.id)).delete()\n    database.commit()\n    return\n"}
{"type": "source_file", "path": "ecommerce/user/router.py", "content": "from typing import List\n\nfrom fastapi import APIRouter, Depends, status, Response, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom ecommerce import db\nfrom ecommerce.auth.jwt import get_current_user\nfrom . import schema\nfrom . import services\nfrom . import validator\n\nrouter = APIRouter(\n    tags=['Users'],\n    prefix='/user'\n)\n\n\n# Interesting Question for Global Dependency\n# https://github.com/tiangolo/fastapi/issues/2481\n\n\n@router.post('/', status_code=status.HTTP_201_CREATED)\nasync def create_user_registration(request: schema.User, database: Session = Depends(db.get_db)):\n    # Read More : Pydantic Validation with Database (https://github.com/tiangolo/fastapi/issues/979)\n\n    user = await validator.verify_email_exist(request.email, database)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    new_user = await services.new_user_register(request, database)\n    return new_user\n\n\n@router.get('/', response_model=List[schema.DisplayUser])\nasync def get_all_users(database: Session = Depends(db.get_db), current_user: schema.User = Depends(get_current_user)):\n    return await services.all_users(database)\n\n\n@router.get('/{user_id}', response_model=schema.DisplayUser)\nasync def get_user_by_id(user_id: int, database: Session = Depends(db.get_db),\n                         current_user: schema.User = Depends(get_current_user)):\n    return await services.get_user_by_id(user_id, database)\n\n\n@router.delete('/{user_id}', status_code=status.HTTP_204_NO_CONTENT, response_class=Response)\nasync def delete_user_by_id(user_id: int, database: Session = Depends(db.get_db),\n                            current_user: schema.User = Depends(get_current_user)):\n    return await services.delete_user_by_id(user_id, database)\n"}
{"type": "source_file", "path": "ecommerce/user/services.py", "content": "from typing import List, Optional\n\nfrom fastapi import HTTPException, status\n\nfrom . import models\n\n\nasync def new_user_register(request, database) -> models.User:\n    new_user = models.User(name=request.name, email=request.email, password=request.password)\n    database.add(new_user)\n    database.commit()\n    database.refresh(new_user)\n    return new_user\n\n\nasync def all_users(database) -> List[models.User]:\n    users = database.query(models.User).all()\n    return users\n\n\nasync def get_user_by_id(user_id, database) -> Optional[models.User]:\n    user_info = database.query(models.User).get(user_id)\n    if not user_info:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Data Not Found !\")\n    return user_info\n\n\nasync def delete_user_by_id(user_id, database):\n    database.query(models.User).filter(models.User.id == user_id).delete()\n    database.commit()\n"}
{"type": "source_file", "path": "alembic/versions/b04eb3b09276_.py", "content": "\"\"\"empty message\n\nRevision ID: b04eb3b09276\nRevises: 38a01968532b\nCreate Date: 2021-08-18 05:29:47.408614\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = 'b04eb3b09276'\ndown_revision = '38a01968532b'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('cart',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('created_date', sa.DateTime(), nullable=True),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('cart_items',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('cart_id', sa.Integer(), nullable=True),\n    sa.Column('product_id', sa.Integer(), nullable=True),\n    sa.Column('created_date', sa.DateTime(), nullable=True),\n    sa.ForeignKeyConstraint(['cart_id'], ['cart.id'], ondelete='CASCADE'),\n    sa.ForeignKeyConstraint(['product_id'], ['products.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('cart_items')\n    op.drop_table('cart')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "ecommerce/auth/schema.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Login(BaseModel):\n    username: str\n    password: str\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    email: Optional[str] = None\n"}
{"type": "source_file", "path": "ecommerce/orders/schema.py", "content": "import datetime\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\nfrom ecommerce.products.schema import ProductListing\n\n\nclass ShowOrderDetails(BaseModel):\n    id: int\n    order_id: int\n    product_order_details: ProductListing\n\n    class Config:\n        orm_mode = True\n\n\nclass ShowOrder(BaseModel):\n    id: Optional[int]\n    order_date: datetime.datetime\n    order_amount: float\n    order_status: str\n    shipping_address: str\n    order_details: List[ShowOrderDetails] = []\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "ecommerce/products/services.py", "content": "from typing import List\n\nfrom fastapi import HTTPException, status\n\nfrom . import models\n\n\nasync def create_new_category(request, database) -> models.Category:\n    new_category = models.Category(name=request.name)\n    database.add(new_category)\n    database.commit()\n    database.refresh(new_category)\n    return new_category\n\n\nasync def get_all_categories(database) -> List[models.Category]:\n    categories = database.query(models.Category).all()\n    return categories\n\n\nasync def get_category_by_id(category_id, database) -> models.Category:\n    category_info = database.query(models.Category).get(category_id)\n    if not category_info:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Data Not Found !\")\n    return category_info\n\n\nasync def delete_category_by_id(category_id, database):\n    database.query(models.Category).filter(models.Category.id == category_id).delete()\n    database.commit()\n\n\nasync def create_new_product(request, database) -> models.Product:\n    new_product = models.Product(name=request.name, quantity=request.quantity,\n                                 description=request.description, price=request.price,\n                                 category_id=request.category_id)\n    database.add(new_product)\n    database.commit()\n    database.refresh(new_product)\n    return new_product\n\n\nasync def get_all_products(database) -> List[models.Product]:\n    products = database.query(models.Product).all()\n    return products\n"}
{"type": "source_file", "path": "ecommerce/cart/models.py", "content": "from datetime import datetime\n\nfrom sqlalchemy import Column, Integer, ForeignKey, DateTime\nfrom sqlalchemy.orm import relationship\n\nfrom ecommerce.db import Base\nfrom ecommerce.products.models import Product\nfrom ecommerce.user.models import User\n\n\nclass Cart(Base):\n    __tablename__ = \"cart\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    user_id = Column(Integer, ForeignKey(User.id, ondelete=\"CASCADE\"), )\n    cart_items = relationship(\"CartItems\", back_populates=\"cart\")\n    user_cart = relationship(\"User\", back_populates=\"cart\")\n    created_date = Column(DateTime, default=datetime.now)\n\n\nclass CartItems(Base):\n    __tablename__ = \"cart_items\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    cart_id = Column(Integer, ForeignKey(\"cart.id\", ondelete=\"CASCADE\"), )\n    product_id = Column(Integer, ForeignKey(Product.id, ondelete=\"CASCADE\"), )\n    cart = relationship(\"Cart\", back_populates=\"cart_items\")\n    products = relationship(\"Product\", back_populates=\"cart_items\")\n    created_date = Column(DateTime, default=datetime.now)\n"}
{"type": "source_file", "path": "ecommerce/auth/jwt.py", "content": "from datetime import datetime, timedelta\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\nfrom ecommerce.auth import schema\n\nSECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str, credentials_exception):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        email: str = payload.get(\"sub\")\n        if email is None:\n            raise credentials_exception\n        token_data = schema.TokenData(email=email)\n        return token_data\n    except JWTError:\n        raise credentials_exception\n\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"login\")\n\n\ndef get_current_user(data: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    return verify_token(data, credentials_exception)\n"}
{"type": "source_file", "path": "ecommerce/user/schema.py", "content": "from pydantic import BaseModel, constr, validator, EmailStr\n\nfrom ecommerce import db\nfrom . import models\n\n\nclass User(BaseModel):\n    name: constr(min_length=2, max_length=50)\n    email: EmailStr\n    password: str\n\n\nclass DisplayUser(BaseModel):\n    id: int\n    name: str\n    email: str\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "ecommerce/__init__.py", "content": ""}
{"type": "source_file", "path": "ecommerce/orders/router.py", "content": "from typing import List\n\nfrom fastapi import APIRouter, Depends, status\nfrom sqlalchemy.orm import Session\n\nfrom ecommerce import db\nfrom ecommerce.auth.jwt import get_current_user\nfrom ecommerce.orders.services import initiate_order, get_order_listing\nfrom ecommerce.user.schema import User\nfrom .schema import ShowOrder\n\nrouter = APIRouter(\n    tags=['Orders'],\n    prefix='/orders'\n)\n\n\n@router.post('/', status_code=status.HTTP_201_CREATED, response_model=ShowOrder)\nasync def initiate_order_processing(current_user: User = Depends(get_current_user),\n                                    database: Session = Depends(db.get_db)):\n    result = await initiate_order(current_user, database)\n    return result\n\n\n@router.get('/', status_code=status.HTTP_200_OK, response_model=List[ShowOrder])\nasync def orders_list(current_user: User = Depends(get_current_user),\n                      database: Session = Depends(db.get_db)):\n    result = await get_order_listing(current_user, database)\n    return result\n"}
{"type": "source_file", "path": "ecommerce/user/__init__.py", "content": "from ecommerce.orders.models import Order\nfrom ecommerce.cart.models import Cart"}
{"type": "source_file", "path": "ecommerce/orders/mail.py", "content": "import re\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\n\ndef clean_html(raw_html):\n    cleaner = re.compile('<.*?>')\n    clean_text = re.sub(cleaner, '', raw_html)\n    return clean_text\n\n\n# Replace sender@example.com with your \"From\" address.\n# This address must be verified with Amazon SES.\nSENDER = \"FastAPI <changethisemailaddress@gmail.com>\"\n\n# If necessary, replace us-west-2 with the AWS Region you're using for Amazon SES.\nAWS_REGION = \"ap-south-1\"\n\n# The subject line for the email.\nSUBJECT = \"New Order Placed\"\n\n# The email body for recipients with non-HTML email clients.\n\n\n# The HTML body of the email.\nBODY_HTML = \"\"\"<html>\n<head></head>\n<body>\n  <h1>Order Successfully Placed !</h1>\n  <p>Hi, Your new order has been successfully placed. You will receive more information shortly.</p>\n</body>\n</html>\n            \"\"\"\n\nBODY_TEXT = clean_html(BODY_HTML)\n\n# The character encoding for the email.\nCHARSET = \"UTF-8\"\n\n# Create a new SES resource and specify a region.\nclient = boto3.client('ses', region_name=AWS_REGION)\n\n\ndef order_notification(recipient):\n    # Try to send the email.\n    try:\n        # Provide the contents of the email.\n        response = client.send_email(\n            Destination={\n                'ToAddresses': [\n                    recipient,\n                ],\n            },\n            Message={\n                'Body': {\n                    'Html': {\n                        'Charset': CHARSET,\n                        'Data': BODY_HTML,\n                    },\n                    'Text': {\n                        'Charset': CHARSET,\n                        'Data': BODY_TEXT,\n                    },\n                },\n                'Subject': {\n                    'Charset': CHARSET,\n                    'Data': SUBJECT,\n                },\n            },\n            Source=SENDER,\n            # If you are not using a configuration set, comment or delete the\n            # following line\n            # ConfigurationSetName=CONFIGURATION_SET,\n        )\n    # Display an error if something goes wrong.\n    except ClientError as e:\n        print(e.response['Error']['Message'])\n    else:\n        print(\"Email sent! Message ID:\"),\n        print(response['MessageId'])\n"}
{"type": "source_file", "path": "ecommerce/orders/models.py", "content": "from datetime import datetime\n\nfrom sqlalchemy import Column, Integer, String, Float, ForeignKey, Text, DateTime\nfrom sqlalchemy.orm import relationship\nfrom ecommerce.user.models import User\nfrom ecommerce.products.models import Product\nfrom ecommerce.db import Base\n\n\nclass Order(Base):\n    __tablename__ = \"order\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    order_date = Column(DateTime, default=datetime.now)\n    order_amount = Column(Float, default=0.0)\n    order_status = Column(String, default=\"PROCESSING\")\n    shipping_address = Column(Text)\n    customer_id = Column(Integer, ForeignKey(User.id, ondelete=\"CASCADE\"), )\n    order_details = relationship(\"OrderDetails\", back_populates=\"order\")\n    user_info = relationship(\"User\", back_populates=\"order\")\n\n\nclass OrderDetails(Base):\n    __tablename__ = \"order_details\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    order_id = Column(Integer, ForeignKey('order.id', ondelete=\"CASCADE\"), )\n    product_id = Column(Integer, ForeignKey(Product.id, ondelete=\"CASCADE\"), )\n    order = relationship(\"Order\", back_populates=\"order_details\")\n    product_order_details = relationship(\"Product\", back_populates=\"order_details\")\n    quantity = Column(Integer, default=1)\n    created = Column(DateTime, default=datetime.now)\n"}
{"type": "source_file", "path": "ecommerce/products/models.py", "content": "from sqlalchemy import Column, Integer, String, Float, ForeignKey, Text\nfrom sqlalchemy.orm import relationship\n\nfrom ecommerce.db import Base\n\n\nclass Category(Base):\n    __tablename__ = \"category\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String(50))\n\n    product = relationship(\"Product\", back_populates=\"category\")\n\n\nclass Product(Base):\n    __tablename__ = \"products\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String(50))\n    quantity = Column(Integer)\n    description = Column(Text)\n    price = Column(Float)\n    category_id = Column(Integer, ForeignKey('category.id', ondelete=\"CASCADE\"), )\n    category = relationship(\"Category\", back_populates=\"product\")\n    order_details = relationship(\"OrderDetails\", back_populates=\"product_order_details\")\n    cart_items = relationship(\"CartItems\", back_populates=\"products\")"}
{"type": "source_file", "path": "ecommerce/products/__init__.py", "content": "from ecommerce.cart.models import CartItems"}
{"type": "source_file", "path": "ecommerce/cart/__init__.py", "content": ""}
{"type": "source_file", "path": "ecommerce/products/schema.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel, constr\n\n\nclass Category(BaseModel):\n    name: constr(min_length=2, max_length=50)\n\n\nclass ListCategory(BaseModel):\n    id: int\n    name: str\n\n    class Config:\n        orm_mode = True\n\n\nclass ProductBase(BaseModel):\n    id: Optional[int]\n    name: str\n    quantity: int\n    description: str\n    price: float\n\n    class Config:\n        orm_mode = True\n\n\nclass Product(ProductBase):\n    category_id: int\n\n\nclass ProductListing(ProductBase):\n    category: ListCategory\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "alembic/env.py", "content": "from __future__ import with_statement\n\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\n# target_metadata = None\n\nfrom ecommerce import config as config_env\nfrom ecommerce.db import Base  # noqa\nfrom ecommerce.user.models import User  # noqa\nfrom ecommerce.products.models import Category, Product  # noqa\nfrom ecommerce.orders.models import Order, OrderDetails  # noqa\nfrom ecommerce.cart.models import Cart, CartItems  # noqa\n\ntarget_metadata = Base.metadata\n\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef get_url():\n    db_user = config_env.DATABASE_USERNAME\n    db_password = config_env.DATABASE_PASSWORD\n    db_host = config_env.DATABASE_HOST\n    db_name = config_env.DATABASE_NAME\n    return f\"postgresql://{db_user}:{db_password}@{db_host}/{db_name}\"\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = get_url()\n    context.configure(\n        url=url, target_metadata=target_metadata, literal_binds=True, compare_type=True\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    configuration = config.get_section(config.config_ini_section)\n    configuration[\"sqlalchemy.url\"] = get_url()\n    connectable = engine_from_config(\n        configuration, prefix=\"sqlalchemy.\", poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata, compare_type=True\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "alembic/versions/38a01968532b_.py", "content": "\"\"\"empty message\n\nRevision ID: 38a01968532b\nRevises: 3ecb256a8f85\nCreate Date: 2021-08-18 05:16:49.435273\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '38a01968532b'\ndown_revision = '3ecb256a8f85'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('order',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('order_date', sa.DateTime(), nullable=True),\n    sa.Column('order_amount', sa.Float(), nullable=True),\n    sa.Column('order_status', sa.String(), nullable=True),\n    sa.Column('shipping_address', sa.Text(), nullable=True),\n    sa.Column('customer_id', sa.Integer(), nullable=True),\n    sa.ForeignKeyConstraint(['customer_id'], ['users.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('order_details',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('order_id', sa.Integer(), nullable=True),\n    sa.Column('product_id', sa.Integer(), nullable=True),\n    sa.Column('quantity', sa.Integer(), nullable=True),\n    sa.Column('created', sa.DateTime(), nullable=True),\n    sa.ForeignKeyConstraint(['order_id'], ['order.id'], ondelete='CASCADE'),\n    sa.ForeignKeyConstraint(['product_id'], ['products.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('order_details')\n    op.drop_table('order')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "ecommerce/auth/router.py", "content": "from datetime import timedelta\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session\n\n\nfrom ecommerce import db\nfrom ecommerce.user import hashing\nfrom ecommerce.user.models import User\n\nfrom .jwt import create_access_token\n\nrouter = APIRouter(\n    tags=['auth']\n)\n\n\n@router.post('/login')\ndef login(request: OAuth2PasswordRequestForm = Depends(), database: Session = Depends(db.get_db)):\n    user = database.query(User).filter(User.email == request.username).first()\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Invalid Credentials')\n\n    if not hashing.verify_password(request.password, user.password):\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail='Invalid Password')\n\n    # Generate a JWT Token\n    access_token = create_access_token(data={\"sub\": user.email})\n\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n"}

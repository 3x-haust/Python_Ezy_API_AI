{"repo_info": {"repo_name": "fastapi-template", "repo_owner": "OriShalhon", "repo_url": "https://github.com/OriShalhon/fastapi-template"}}
{"type": "test_file", "path": "tests/conftest.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.core.settings import settings\nfrom app.db.database import Base, get_db\nfrom app.main import app\n\nTESTING_DATABASE_URL = settings.testing_database_url\n\nengine = create_engine(TESTING_DATABASE_URL)\n\nTestingSession = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\n@pytest.fixture()\ndef session():\n    print(\"my session fixture ran\")\n    Base.metadata.drop_all(bind=engine)\n    Base.metadata.create_all(bind=engine)\n    db = TestingSession()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\n@pytest.fixture()\ndef client(session):\n    def override_get_db():\n        try:\n            yield session\n        finally:\n            session.close()\n\n    app.dependency_overrides[get_db] = override_get_db\n    yield TestClient(app)\n\n\n@pytest.fixture\ndef test_user(client):\n    user_data = {\"email\": \"your_mail@gmail.com\", \"password\": \"password123\"}\n    res = client.post(\"/users/\", json=user_data)\n\n    assert res.status_code == 201\n\n    new_user = res.json()\n    new_user[\"password\"] = user_data[\"password\"]\n    return new_user\n"}
{"type": "test_file", "path": "tests/test_users.py", "content": "import pytest\nfrom jose import jwt\n\nfrom app.core.settings import settings\nfrom app.schemas import schemas\n\n\ndef test_create_user(client):\n    res = client.post(\n        \"/users/\", json={\"email\": \"hello123@gmail.com\", \"password\": \"password123\"}\n    )\n\n    new_user = schemas.UserOut(**res.json())\n    assert new_user.email == \"hello123@gmail.com\"\n    assert res.status_code == 201\n\n\ndef test_login_user(test_user, client):\n    res = client.post(\n        \"/login\",\n        data={\"username\": test_user[\"email\"], \"password\": test_user[\"password\"]},\n    )\n    login_res = schemas.Token(**res.json())\n    payload = jwt.decode(\n        login_res.access_token,\n        settings.jwt_secret_key,\n        algorithms=[settings.jwt_algorithm],\n    )\n    id = payload.get(\"user_id\")\n    assert id == test_user[\"id\"]\n    assert login_res.token_type == \"bearer\"\n    assert res.status_code == 200\n\n\n@pytest.mark.parametrize(\n    \"email, password, status_code\",\n    [\n        (\"wrongemail@gmail.com\", \"password123\", 403),\n        (\"your_mail@gmail.com\", \"wrongpassword\", 403),\n        (\"wrongemail@gmail.com\", \"wrongpassword\", 403),\n    ],\n)\ndef test_incorrect_login(test_user, client, email, password, status_code):\n    res = client.post(\"/login\", data={\"username\": email, \"password\": password})\n\n    assert res.status_code == status_code\n"}
{"type": "source_file", "path": "app/core/config.py", "content": "import logging\nimport os\nfrom logging.handlers import RotatingFileHandler\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\n\ndef load_configurations(app: FastAPI) -> None:\n    # Enable CORS - Cross-Origin Resource Sharing currently allows all origins\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],  # edit this to allow only specific origins\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n\ndef configure_logging(log_dir: str = None, log_level=logging.INFO) -> None:\n    if log_dir is None:\n        log_dir = (\n            os.getcwd()\n        )  # Use current directory if no custom log directory is provided\n\n    log_file = os.path.join(log_dir, \"app.log\")\n\n    # Set up rotating file handler to limit file size to 5 MB with up to 5 backup files\n    file_handler = RotatingFileHandler(\n        log_file, maxBytes=5 * 1024 * 1024, backupCount=5\n    )\n\n    logging.basicConfig(\n        level=log_level,\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        handlers=[file_handler, logging.StreamHandler()],\n    )\n"}
{"type": "source_file", "path": "app/schemas/schemas.py", "content": "# this file could be seperated into multiple files, but for simplicity I have kept it in one file for the tamplate\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass UserLogin(BaseModel):\n    email: EmailStr\n    password: str\n\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n\n\nclass UserOut(BaseModel):\n    id: int\n    email: EmailStr\n    created_at: datetime\n\n    class Config:\n        orm_mode = True\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    id: Optional[int] = None\n"}
{"type": "source_file", "path": "alembic/env.py", "content": "from logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\n\nfrom app.core.settings import settings\nfrom app.models.models import Base\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\nconfig.set_main_option(\"sqlalchemy.url\", settings.database_url)\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(connection=connection, target_metadata=target_metadata)\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "app/utils/utils.py", "content": "from passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef hash_password(password: str) -> str:\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n"}
{"type": "source_file", "path": "app/models/models.py", "content": "# this file could be seperated into multiple files, but for simplicity I have kept it in one file for the tamplate\n\n# here wee define the structure of the db tabbles and the relationships between them\n\nfrom sqlalchemy import Column, Integer, String\n\n# from sqlalchemy.orm import relationship common to use in the models\nfrom sqlalchemy.sql.expression import text\nfrom sqlalchemy.sql.sqltypes import TIMESTAMP\n\nfrom app.db.database import Base\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, nullable=False)\n    email = Column(String, unique=True, nullable=False, index=True)\n    password = Column(String, nullable=False)\n    created_at = Column(\n        TIMESTAMP(timezone=True), nullable=False, server_default=text(\"now()\")\n    )\n"}
{"type": "source_file", "path": "app/api/v1/routers/users.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\nfrom app.db.database import get_db\nfrom app.models import models\nfrom app.schemas import schemas\nfrom app.utils import utils\n\nrouter = APIRouter(\n    prefix=\"/users\",\n    tags=[\"users\"],\n)\n\n\n@router.post(\"/\", status_code=status.HTTP_201_CREATED, response_model=schemas.UserOut)\ndef create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):\n    hashed_password = utils.hash_password(user.password)\n    user.password = hashed_password\n\n    new_user = models.User(**user.model_dump())\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n\n    return new_user\n\n\n@router.get(\"/{id}\", response_model=schemas.UserOut)\ndef get_user(\n    id: int,\n    db: Session = Depends(get_db),\n):\n    user = db.query(models.User).filter(models.User.id == id).first()\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"User with id: {id} does not exist\",\n        )\n\n    return user\n"}
{"type": "source_file", "path": "app/db/database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.core.settings import settings\n\nengine = create_engine(settings.database_url)\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nBase = declarative_base()\n\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "app/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/v1/routers/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/settings.py", "content": "from pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    database_url: str\n    jwt_secret_key: str\n    jwt_algorithm: str\n    jwt_expiration_time_minutes: int\n    testing_database_url: str\n\n    class config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "app/main.py", "content": "import logging\n\nimport uvicorn\n\nfrom app import create_app\n\n# from app.db.database import engine\n# from app.models import models\n\napp = create_app()\n\n# with alembic this is not needed, choose one of the two\n# models.Base.metadata.create_all(bind=engine)\n\nlogging.basicConfig(level=logging.INFO)\n\nif __name__ == \"__main__\":\n    logging.info(\"Starting the application\")\n    logging.info(f\"app.state: {app.state}\")\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"}
{"type": "source_file", "path": "app/api/v1/routers/auth.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session\n\nfrom app.db.database import get_db\nfrom app.models import models\nfrom app.schemas import schemas\nfrom app.utils import oauth2, utils\n\nrouter = APIRouter(\n    tags=[\"authentications\"],\n)\n\n\n@router.post(\"/login\", response_model=schemas.Token)\ndef login(\n    user_credentials: OAuth2PasswordRequestForm = Depends(),\n    db: Session = Depends(get_db),\n):\n    found_user = (\n        db.query(models.User)\n        .filter(models.User.email == user_credentials.username)\n        .first()\n    )\n\n    if not found_user:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN, detail=\"User not found\"\n        )  # change the details to \"Invalid credentials\"\n\n    if not utils.verify_password(user_credentials.password, found_user.password):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN, detail=\"Incorrect password\"\n        )  # change the details to \"Invalid credentials\"\n\n    # here we generate a jwt token\n    access_token = oauth2.create_access_token(\n        data={\"user_email\": found_user.email, \"user_id\": found_user.id}\n    )\n\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n\n1\n"}
{"type": "source_file", "path": "app/__init__.py", "content": "import logging\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom app.api.v1 import router as api_router\nfrom app.core.config import configure_logging, load_configurations\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup event\n    logging.info(\"Application startup\")\n\n    yield\n\n    logging.info(\"Application shutdown\")\n\n\ndef create_app() -> FastAPI:\n    app = FastAPI()\n\n    load_configurations(app)\n    configure_logging()\n\n    app.include_router(api_router)\n    app.router.lifespan_context = lifespan\n    return app\n"}
{"type": "source_file", "path": "app/api/v1/__init__.py", "content": "from fastapi import APIRouter\n\nfrom .routers import auth, users  # noqa\n\nrouter = APIRouter()\n\n# Include all routers here\nrouter.include_router(users.router)\nrouter.include_router(auth.router)\n"}
{"type": "source_file", "path": "app/utils/oauth2.py", "content": "from datetime import datetime, timedelta, timezone\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom sqlalchemy.orm import Session\n\nfrom app.core.settings import settings\nfrom app.db.database import get_db\nfrom app.models import models\nfrom app.schemas import schemas\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"login\")\n\n# for the toekn there are 3 required parameters\n# 1. secret key\n# 2. algorithm\n# 3. expiration time\n\nSECRET_KEY = settings.jwt_secret_key\nALGORITHM = settings.jwt_algorithm\nACCESS_TOKEN_EXPIRE_MINUTES = settings.jwt_expiration_time_minutes\n\n\n# this function is used to create a jwt token\ndef create_access_token(data: dict) -> str:\n    to_encode = data.copy()\n    # this is used to set the expiration time\n    expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str, credential_exception) -> dict:\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id = payload.get(\"user_id\")\n\n        if not user_id:\n            raise credential_exception\n        token_data = schemas.TokenData(id=user_id)\n    except JWTError:\n        raise credential_exception\n\n    return token_data\n\n\n# this function should be used as a dependency for each route that requires authentication of the user\ndef get_current_user(\n    token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)\n) -> models.User:\n    print(f\"the token is {token}\")\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n\n    found_token = verify_token(token, credentials_exception)\n\n    logged_user = db.query(models.User).filter(models.User.id == found_token.id).first()\n\n    return logged_user\n"}

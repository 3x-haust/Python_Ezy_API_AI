{"repo_info": {"repo_name": "fastapi-shop", "repo_owner": "zamaniamin", "repo_url": "https://github.com/zamaniamin/fastapi-shop"}}
{"type": "test_file", "path": "apps/accounts/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "apps/accounts/tests/test_account.py", "content": "import pytest\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\n\nfrom apps.accounts.faker.data import FakeAccount, FakeUser\nfrom apps.accounts.models import UserVerification\nfrom apps.accounts.services.authenticate import AccountService\nfrom apps.accounts.services.password import PasswordManager\nfrom apps.accounts.services.token import TokenService\nfrom apps.accounts.services.user import UserManager\nfrom apps.core.base_test_case import BaseTestCase\nfrom apps.main import app\nfrom config.database import DatabaseManager\n\n\nclass AccountTestBase(BaseTestCase):\n    register_endpoint = \"/accounts/register/\"\n    register_verify_endpoint = \"/accounts/register/verify/\"\n    login_endpoint = \"/accounts/login/\"\n    logout_endpoint = \"/accounts/logout/\"\n    reset_password_endpoint = \"/accounts/reset-password/\"\n    verify_reset_password_endpoint = \"/accounts/reset-password/verify\"\n    otp_endpoint = \"/accounts/otp/\"\n\n    @classmethod\n    def setup_class(cls):\n        cls.client = TestClient(app)\n        DatabaseManager.create_test_database()\n\n    @classmethod\n    def teardown_class(cls):\n        DatabaseManager.drop_all_tables()\n\n\nclass TestRegisterAccount(AccountTestBase):\n\n    def test_successful_register_with_email(self):\n        \"\"\"\n        Test Register a new user with valid credentials.\n        \"\"\"\n\n        payload = {\n            'email': FakeAccount.random_email(),\n            'password': FakeAccount.password,\n            'password_confirm': FakeAccount.password\n        }\n\n        # --- request ---\n        response = self.client.post(self.register_endpoint, json=payload)\n        assert response.status_code == status.HTTP_201_CREATED\n\n        # --- expected ---\n        expected = response.json()\n        assert expected['email'] == payload['email']\n        assert expected['message'] == 'Please check your email for an OTP code to confirm your email address.'\n\n        expected_user = UserManager.get_user(email=payload['email'])\n        assert expected_user is not None\n        assert expected_user.id > 0\n\n        assert expected_user.email == payload[\"email\"]\n        assert PasswordManager.verify_password(payload['password'], expected_user.password) is True\n\n        assert expected_user.first_name is None\n        assert expected_user.last_name is None\n\n        assert expected_user.is_verified_email is False\n        assert expected_user.is_active is False\n        assert expected_user.is_superuser is False\n\n        assert expected_user.updated_at is None\n        assert expected_user.last_login is None\n        self.assert_datetime_format(expected_user.date_joined)\n\n    def test_successful_verify_registration(self):\n        \"\"\"\n        Test activating the account after verifying the OTP code (verify email).\n        \"\"\"\n\n        # --- register a user ---\n        email, otp = FakeAccount.register_unverified()\n\n        # --- payload ---\n        verify_payload = {\n            'email': email,\n            'otp': otp\n        }\n\n        # --- request ---\n        response = self.client.patch(self.register_verify_endpoint, json=verify_payload)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected ---\n        assert TokenService.validate_otp_token(otp) is True\n        expected = response.json()\n        assert expected['access_token'] is not None\n        assert expected['message'] == 'Your email address has been confirmed. Account activated successfully.'\n\n        expected_user = UserManager.get_user(email=email)\n\n        assert expected_user is not None\n        assert expected_user.id > 0\n\n        assert expected_user.email == email\n        assert PasswordManager.verify_password(FakeAccount.password, expected_user.password) is True\n\n        assert expected_user.first_name is None\n        assert expected_user.last_name is None\n\n        assert expected_user.is_verified_email is True\n        assert expected_user.is_active is True\n        assert expected_user.is_superuser is False\n\n        # --- expected in UserVerification ---\n        change_request: UserVerification = UserVerification.filter(UserVerification.user_id == expected_user.id).first()\n        assert change_request.request_type is None\n\n        self.assert_datetime_format(expected_user.last_login)\n        self.assert_datetime_format(expected_user.updated_at)\n        self.assert_datetime_format(expected_user.date_joined)\n\n    def test_register_existing_verified_email(self):\n        \"\"\"\n        Test register a new user with an existing verified email address.\n        \"\"\"\n\n        user, _ = FakeAccount.verified_registration()\n        payload = {\n            'email': user.email,\n            'password': FakeAccount.password,\n            'password_confirm': FakeAccount.password\n        }\n        response = self.client.post(self.register_endpoint, json=payload)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n\n    def test_register_existing_unverified_email(self):\n        \"\"\"\n        Test register a new user with an existing unverified email address.\n        \"\"\"\n        emai, _ = FakeAccount.register_unverified()\n        payload = {\n            'email': emai,\n            'password': FakeAccount.password,\n            'password_confirm': FakeAccount.password\n        }\n        response = self.client.post(self.register_endpoint, json=payload)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n\n    @pytest.mark.parametrize(\"unknown_email\", [\n        {'email': 'valid@test.com', 'otp': ''},\n        {'email': 'valid@test.com', 'otp': '123'}])\n    def test_verify_register_unknown_email(self, unknown_email):\n        \"\"\"\n        Test verify-register a new user with unknown email address.\n        \"\"\"\n\n        # --- request ---\n        response = self.client.patch(self.register_verify_endpoint, json=unknown_email)\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    def test_verify_registration_incorrect_otp(self):\n        \"\"\"\n        Test verify email address with incorrect otp code or expired otp code.\n        \"\"\"\n\n        # --- register a user ---\n        email, otp = FakeAccount.register_unverified()\n\n        # --- payload ---\n        verify_payload = {\n            'email': email,\n            'otp': '123456'\n        }\n\n        # --- request ---\n        response = self.client.patch(self.register_verify_endpoint, json=verify_payload)\n        assert response.status_code == status.HTTP_406_NOT_ACCEPTABLE\n\n    # ---------------------\n    # --- Test Payloads ---\n    # ---------------------\n\n    @pytest.mark.parametrize(\"invalid_fields\", [\n        {},\n        {'': ''},\n        {'test': 'test'},\n        {'email': 'invalid@testcom', 'password': 'PASSWORD'},\n        {'password': 'PASSWORD', 'password_confirm': 'PASSWORD'},\n        {'email': 'valid@test.com', 'password': ''},\n        {'email': 'valid@test.com', 'password': 'PASSWORD_t1'},\n        {'email': 'invalid@testcom', 'password': 'PASSWORD_t1', 'password_confirm': 'PASSWORD_t1'}])\n    def test_register_invalid_payload_fields(self, invalid_fields):\n        \"\"\"\n        Test register a new user with invalid payload fields.\n        \"\"\"\n\n        response = self.client.post(self.register_endpoint, json=invalid_fields)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"invalid_email\", [\n        {'email': ''},\n        {'email': 'valid@test.com'},\n        {'email': '@com', 'password': 'PASSWORD_t1', 'password_confirm': 'PASSWORD_t1'},\n        {'email': 'as@.com', 'password': 'PASSWORD_t1', 'password_confirm': 'PASSWORD_t1'},\n        {'email': 'as@.d.com', 'password': 'PASSWORD_t1', 'password_confirm': 'PASSWORD_t1'}])\n    def test_register_invalid_email(self, invalid_email):\n        \"\"\"\n        Test register a new user with an invalid email.\n        \"\"\"\n\n        response = self.client.post(self.register_endpoint, json=invalid_email)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"invalid_passwords\", [\n        {'password': '', 'password_confirm': ''},\n        {'password': 'PASSWORD', 'password_confirm': 'PASSWORD'},\n        {'password': 'PASSWORD_', 'password_confirm': 'PASSWORD_'},\n        {'password': 'password_', 'password_confirm': 'password_'},\n        {'password': 'password1', 'password_confirm': 'password1'},\n        {'password': '_assword1', 'password_confirm': '_assword1'},\n        {'password': 'Pa@1', 'password_confirm': 'Pa@1'},\n        {'password': 'asdfghjk', 'password_confirm': 'asdfghjk'},\n        {'password': '12345678', 'password_confirm': '12345678'},\n        {'password': 'password_tt', 'password_confirm': 'password_tt'},\n        {'password': 'password_Tt', 'password_confirm': 'password_Tt'},\n        {'password': 'passwordTt', 'password_confirm': 'passwordTt'},\n        {'password': 'Pass1', 'password_confirm': 'Pass1'},\n        {'password': 'Pass1_Pass1_Pass1_Pass1_1', 'password_confirm': 'Pass1_Pass1_Pass1_Pass1_1'},\n        {'password': 'PASSWORD_t1', 'password_confirm': 'PASSWORD_t2'}])\n    def test_register_invalid_password(self, invalid_passwords):\n        \"\"\"\n        Test register a new user with invalid password.\n        \"\"\"\n        invalid_passwords['email'] = FakeAccount.random_email()\n        response = self.client.post(self.register_endpoint, json=invalid_passwords)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"invalid_fields\", [\n        {},\n        {'': ''},\n        {'test': 'test'},\n        {'email': ''},\n        {'email': 'valid@test.com'},\n        {'email': 'invalid@testcom', 'otp': '12'},\n        {'email': '', 'otp': '12'}])\n    def test_verify_register_invalid_payload(self, invalid_fields):\n        \"\"\"\n        Test verify-register a new user with invalid payload.\n        \"\"\"\n\n        # --- request ---\n        response = self.client.patch(self.register_verify_endpoint, json=invalid_fields)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"invalid_otp\", [\n        {},\n        {'otp': ''},\n        {'otp': '11111111'},\n        {'otp': 'aaaa1111'},\n        {'otp': 'aaaaaaaa'}])\n    def test_verify_register_invalid_otp(self, invalid_otp):\n        \"\"\"\n        Test register a new user with invalid password.\n        \"\"\"\n        invalid_otp['email'] = FakeAccount.register_unverified()\n        response = self.client.post(self.register_endpoint, json=invalid_otp)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestLoginAccount(AccountTestBase):\n    def test_successful_login(self):\n        \"\"\"\n        Test successful login for a user.\n        \"\"\"\n\n        # --- register and verify a user ---\n        user, _ = FakeAccount.verified_registration()\n        payload = {\n            'username': user.email,\n            'password': FakeAccount.password\n        }\n\n        # --- login request ---\n        response = self.client.post(self.login_endpoint, data=payload)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected ---\n        expected_login = response.json()\n        assert expected_login['access_token'] is not None\n        assert expected_login['token_type'] == 'bearer'\n\n        expected_user = UserManager.get_user(email=user.email)\n        self.assert_datetime_format(expected_user.last_login)\n\n    def test_login_with_incorrect_password(self):\n        \"\"\"\n        Test login with incorrect password.\n        \"\"\"\n\n        # --- register and verify a user ---\n        user, _ = FakeAccount.verified_registration()\n        payload = {\n            'username': user.email,\n            'password': FakeAccount.password + \"t\"\n        }\n\n        # --- login request ---\n        response = self.client.post(self.login_endpoint, data=payload)\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    def test_login_with_inactive_account(self):\n        \"\"\"\n        Test login if user account is inactive.\n        \"\"\"\n\n        # --- register and verify a user ---\n        email, _ = FakeAccount.register_unverified()\n        payload = {\n            'username': email,\n            'password': FakeAccount.password\n        }\n\n        # --- login request ---\n        response = self.client.post(self.login_endpoint, data=payload)\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    def test_login_with_unverified_email(self):\n        \"\"\"\n        Test login a user with unverified email address.\n        \"\"\"\n\n        # --- register and verify a user ---\n        email, _ = FakeAccount.register_unverified()\n        payload = {\n            'username': email,\n            'password': FakeAccount.password\n        }\n\n        # --- login request ---\n        response = self.client.post(self.login_endpoint, data=payload)\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    def test_logout(self):\n        \"\"\"\n        Test logout from account of authenticated user.\n        \"\"\"\n\n        # --- create a user ---\n        user, access_token = FakeUser.populate_user()\n        header = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        response = self.client.post(self.logout_endpoint, headers=header)\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n    def test_login_after_password_change(self):\n        \"\"\"\n        Test login to account after password is changed.\n        \"\"\"\n\n        # --- create a user ---\n        user, access_token = FakeUser.populate_user()\n\n        # --- request ---\n        passwords = {\n            'old_password': FakeUser.password,\n            'new_password': FakeUser.password + \"test\"\n        }\n\n        AccountService.change_password(user=user, current_password=passwords['old_password'],\n                                       password=passwords['new_password'])\n\n        # --- login with old password ---\n        old_password = {\n            'username': user.email,\n            'password': passwords['old_password']\n        }\n        response = self.client.post(self.login_endpoint, data=old_password)\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n        # --- login with new password ---\n        new_password = {\n            'username': user.email,\n            'password': passwords['new_password']\n        }\n        response = self.client.post(self.login_endpoint, data=new_password)\n        assert response.status_code == status.HTTP_200_OK\n\n    def test_login_after_password_reset(self):\n        \"\"\"\n        Test login to account after password reset.\n        \"\"\"\n\n        # --- create a user ---\n        user, access_token = FakeUser.populate_user()\n\n        # --- request ---\n        new_password = FakeUser.password + \"test\"\n\n        AccountService.reset_password(email=user.email)\n        AccountService.verify_reset_password(email=user.email, password=new_password,\n                                             otp=TokenService.create_otp_token())\n\n        # --- login with old password ---\n        old_password = {\n            'username': user.email,\n            'password': FakeUser.password\n        }\n        response = self.client.post(self.login_endpoint, data=old_password)\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n        # --- login with new password ---\n        new_password = {\n            'username': user.email,\n            'password': new_password\n        }\n        response = self.client.post(self.login_endpoint, data=new_password)\n        assert response.status_code == status.HTTP_200_OK\n\n    # ---------------------\n    # --- Test Payloads ---\n    # ---------------------\n\n    @pytest.mark.parametrize(\"invalid_fields\", [\n        {},\n        {'username': '', 'password': ''},\n        {'username': ''},\n        {'password': '<PASSWORD>'},\n        {'username': 'valid@test.com'},\n        {'username': 'any_username'}])\n    def test_login_with_invalid_payloads(self, invalid_fields):\n        \"\"\"\n        Test login to account with invalid payloads.\n        \"\"\"\n\n        # --- login request ---\n        response = self.client.post(self.login_endpoint, data=invalid_fields)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestResetPassword(AccountTestBase):\n    def test_reset_password_with_email(self):\n        \"\"\"\n        Test reset password by user email address.\n        \"\"\"\n\n        # --- create a user ---\n        user, _ = FakeUser.populate_user()\n\n        # --- request ---\n        payload = {\n            'email': user.email\n        }\n        response = self.client.post(self.reset_password_endpoint, json=payload)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected ---\n        expected = response.json()\n        assert expected['message'] == 'Please check your email for an OTP code to confirm the password reset request.'\n\n    def test_verify_reset_password_with_email(self):\n        \"\"\"\n        Test verify reset password by user email address and then change their password.\n        \"\"\"\n\n        # --- create a user ---\n        fake_user, access_token = FakeUser.populate_user()\n\n        # --- set a reset request ---\n        AccountService.reset_password(fake_user.email)\n        user = UserManager.get_user(fake_user.id)\n        old_password = user.password\n\n        # --- request ---\n        payload = {\n            'email': user.email,\n            'otp': TokenService.create_otp_token(),\n            'password': FakeUser.password,\n            'password_confirm': FakeUser.password\n        }\n        response = self.client.patch(self.verify_reset_password_endpoint, json=payload)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected ---\n        expected = response.json()\n        assert expected['message'] == 'Your password has been changed.'\n\n        expected_user = UserManager.get_user(user.id)\n        assert PasswordManager.verify_password(payload['password'], expected_user.password) is True\n        self.assert_datetime_format(expected_user.updated_at)\n        self.assert_datetime_format(user.updated_at)\n        # assert expected_user.updated_at != user.updated_at\n\n        # --- test current token is set to none ---\n        expected_access_token = UserVerification.filter(\n            UserVerification.user_id == expected_user.id).first().active_access_token\n        assert expected_access_token is None\n\n        # --- expected in UserVerification ---\n        change_request: UserVerification = UserVerification.filter(UserVerification.user_id == expected_user.id).first()\n        assert change_request.request_type is None\n\n        # --- test fetch user with old access-token ---\n        header = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n        result = self.client.get(\"/accounts/me\", headers=header)\n        assert result.status_code == status.HTTP_401_UNAUTHORIZED\n\n\nclass TestResendOTP(AccountTestBase):\n    def test_stop_resend_on_register(self):\n        \"\"\"\n        Test stop resending otp to email address on user registration if OTP is still valid.\n        \"\"\"\n\n        # --- register a user ---\n        email, _ = FakeAccount.register_unverified()\n\n        # --- request for resend an OTP ---\n        payload = {\n            \"request_type\": \"register\",\n            \"email\": email\n        }\n        response = self.client.post(self.otp_endpoint, json=payload)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert \"OTP not expired. Resend available in \" in response.json().get(\"detail\")\n\n    def test_stop_resend_on_change_email(self):\n        \"\"\"\n        Test resending otp to email address on change email if OTP is still valid.\n        \"\"\"\n\n        # --- register a user ---\n        user, access_token = FakeUser.populate_user()\n        new_email = FakeUser.random_email()\n\n        # --- set a change email request ---\n        AccountService.change_email(user, new_email)\n\n        # --- request for resend an OTP ---\n        payload = {\n            \"request_type\": \"change-email\",\n            \"email\": user.email\n        }\n        response = self.client.post(self.otp_endpoint, json=payload)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert \"OTP not expired. Resend available in \" in response.json().get(\"detail\")\n\n    def test_stop_resend_on_reset_password(self):\n        \"\"\"\n        Test resending otp to email address on reset password if OTP is still valid.\n        \"\"\"\n\n        # --- register a user ---\n        user, access_token = FakeUser.populate_user()\n\n        # --- set a reset request ---\n        AccountService.reset_password(user.email)\n\n        # --- request for resend an OTP ---\n        payload = {\n            \"request_type\": \"reset-password\",\n            \"email\": user.email\n        }\n        response = self.client.post(self.otp_endpoint, json=payload)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert \"OTP not expired. Resend available in \" in response.json().get(\"detail\")\n\n    @pytest.mark.parametrize(\"invalid_request_type\", ['register', 'reset-password'])\n    def test_resend_on_change_email_invalid_request_type(self, invalid_request_type):\n        \"\"\"\n        Test resending otp to email address on change-email with unrelated value for request type.\n        \"\"\"\n\n        # --- register a user ---\n        user, access_token = FakeUser.populate_user()\n        new_email = FakeUser.random_email()\n\n        # --- set a change email request ---\n        AccountService.change_email(user, new_email)\n\n        # --- request for resend an OTP ---\n        payload = {\n            \"request_type\": invalid_request_type,\n            \"email\": user.email\n        }\n        response = self.client.post(self.otp_endpoint, json=payload)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert response.json().get(\"detail\") == \"Current requested type is invalid.\"\n\n    @pytest.mark.parametrize(\"invalid_request_type\", ['register', 'change-email'])\n    def test_resend_on_reset_password_invalid_request_type(self, invalid_request_type):\n        \"\"\"\n        Test resending otp to email address on reset-password with unrelated value for request type.\n        \"\"\"\n\n        # --- register a user ---\n        user, access_token = FakeUser.populate_user()\n\n        # --- set a reset request ---\n        AccountService.reset_password(user.email)\n\n        # --- request for resend an OTP ---\n        payload = {\n            \"request_type\": invalid_request_type,\n            \"email\": user.email\n        }\n        response = self.client.post(self.otp_endpoint, json=payload)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert response.json().get(\"detail\") == \"Current requested type is invalid.\"\n    # ---------------------\n    # --- Test Payloads ---\n    # ---------------------\n\n# TODO test limit user to enter otp code for 5 time. after that user should request a new code.\n# TODO add issue on github for mock the expire time of tokens OTP and JWT\n\n# TODO test OTP verification email is sent on:\n#  (to ensure that email is sent and delivery)\n#  1. register\n#  2. change email\n#  3. reset password\n#  4. resend-otp (register, reset-password, change-email)\n\n# TODO tests needs to expired time:\n#  1. JWT `ACCESS_TOKEN_EXPIRE_MINUTES`\n#  2. resend-otp (register, reset-password, change-email)\n"}
{"type": "test_file", "path": "apps/products/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "apps/products/tests/test_product.py", "content": "import asyncio\n\nimport pytest\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\n\nfrom apps.accounts.faker.data import FakeUser\nfrom apps.accounts.models import User\nfrom apps.core.base_test_case import BaseTestCase\nfrom apps.main import app\nfrom apps.products.faker.data import FakeProduct\nfrom apps.products.services import ProductService\nfrom config.database import DatabaseManager\n\n\nclass ProductTestBase(BaseTestCase):\n    product_endpoint = '/products/'\n\n    # --- members ---\n    admin: User | None = None\n    admin_authorization = {}\n\n    @classmethod\n    def setup_class(cls):\n        cls.client = TestClient(app)\n\n        # Initialize the test database and session before the test class starts\n        DatabaseManager.create_test_database()\n\n        # --- create an admin ---\n        cls.admin, access_token = FakeUser.populate_admin()\n        cls.admin_authorization = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    @classmethod\n    def teardown_class(cls):\n        # Drop the test database after all tests in the class have finished\n        DatabaseManager.drop_all_tables()\n\n\nclass TestCreateProduct(ProductTestBase):\n    \"\"\"\n    Test create a product on the multi scenario\n    \"\"\"\n\n    def test_access_permission(self):\n        \"\"\"\n        Test permissions as admin and non-admin user for CRUD methods of create product.\n\n        \"\"\"\n        # TODO admin permission can access to all CRUD of a product also list of products\n        # TODO non admin users only can use read a product or read a list of products if it status is\n        #  'active or archive'\n        ...\n\n    def test_create_product(self):\n        \"\"\"\n        Test create a product by assuming valid data.\n\n        * every time we create product, the media should be None, because the Media after creating a product will be\n          attached to it.\n        \"\"\"\n\n        # --- request ---\n        payload = FakeProduct.get_payload()\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_201_CREATED\n\n        # --- response data ---\n        expected = response.json()\n        assert isinstance(expected['product'], dict)\n        expected = expected['product']\n\n        # --- product ---\n        assert expected['product_id'] > 0\n        assert expected['product_name'] == payload['product_name']\n        assert expected['description'] == payload['description']\n        assert expected['status'] == payload['status']\n        assert expected['updated_at'] is None\n        assert expected['published_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n        # --- options $ media ---\n        assert expected['options'] is None\n        assert expected['media'] is None\n\n        # --- variants ---\n        assert isinstance(expected['variants'], list)\n        assert len(expected['variants']) == 1\n        variant = expected['variants'][0]\n        assert variant['variant_id'] > 0\n        assert variant['product_id'] > 0\n        assert variant['price'] == payload['price']\n        assert variant['stock'] == payload['stock']\n        assert variant['option1'] is None\n        assert variant['option2'] is None\n        assert variant['option3'] is None\n        assert variant['updated_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n    def test_create_product_with_options(self):\n        \"\"\"\n        Test create a product by the all available inputs (assuming valid data).\n\n        * every time we create a product, the media should be None, because the media after creating a product will be\n          attached to it.\n        \"\"\"\n\n        # --- request ---\n        payload = FakeProduct.get_payload_with_options()\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_201_CREATED\n\n        # --- response data ---\n        expected = response.json()\n        assert isinstance(expected['product'], dict)\n        expected = expected['product']\n\n        # --- product ---\n        assert expected['product_id'] > 0\n        assert expected['product_name'] == payload['product_name']\n        assert expected['description'] == payload['description']\n        assert expected['status'] == payload['status']\n        assert expected['updated_at'] is None\n        assert expected['published_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n        # --- options ---\n        assert isinstance(expected['options'], list)\n        assert len(expected['options']) == 3\n        for option in expected['options']:\n            assert isinstance(option[\"options_id\"], int)\n            assert isinstance(option[\"option_name\"], str)\n            assert isinstance(option['items'], list)\n            assert len(option['items']) == 2\n            for item in option['items']:\n                assert isinstance(item[\"item_id\"], int)\n                assert isinstance(item[\"item_name\"], str)\n\n        # --- variants ---\n        assert isinstance(expected['variants'], list)\n        assert len(expected['variants']) == 8\n        for variant in expected['variants']:\n            assert isinstance(variant[\"variant_id\"], int)\n            assert isinstance(variant[\"product_id\"], int)\n            assert isinstance(variant['price'], float)\n            assert isinstance(variant['stock'], int)\n            assert isinstance(variant['option1'], int)\n            assert isinstance(variant['option2'], int)\n            assert isinstance(variant['option3'], int)\n            assert variant['updated_at'] is None\n            self.assert_datetime_format(variant['created_at'])\n\n        # --- media ---\n        assert expected['media'] is None\n\n    def test_create_product_required(self):\n        \"\"\"\n        Test create a product just with required fields in product payload.\n        \"\"\"\n\n        # --- request ---\n        payload = {\n            'product_name': 'Test Product'\n        }\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_201_CREATED\n\n        # --- response data ---\n        expected = response.json()\n        assert isinstance(expected['product'], dict)\n        expected = expected['product']\n\n        # --- product ---\n        assert expected['product_id'] > 0\n        assert expected['product_name'] == payload['product_name']\n        assert expected['description'] is None\n        assert expected['status'] == 'draft'\n        assert expected['updated_at'] is None\n        assert expected['published_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n        # --- options & media ---\n        assert expected['options'] is None\n        assert expected['media'] is None\n\n        # --- variants ---\n        assert isinstance(expected['variants'], list)\n        assert len(expected['variants']) == 1\n        variant = expected['variants'][0]\n        assert variant['variant_id'] > 0\n        assert variant['product_id'] > 0\n        assert variant['price'] == 0\n        assert variant['stock'] == 0\n        assert variant['option1'] is None\n        assert variant['option2'] is None\n        assert variant['option3'] is None\n        assert variant['updated_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n    def test_create_product_with_required_options(self):\n        \"\"\"\n        Test create a product just with required fields in options.\n        \"\"\"\n\n        # --- request ---\n        payload = {\n            \"product_name\": \"Test Product\",\n            \"options\": [\n                {\n                    \"option_name\": \"color\",\n                    \"items\": [\"red\"]\n                }\n            ]\n        }\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_201_CREATED\n\n        # --- response data ---\n        expected = response.json()\n        assert isinstance(expected['product'], dict)\n        expected = expected['product']\n\n        # --- product ---\n        assert expected['product_id'] > 0\n        assert expected['product_name'] == 'Test Product'\n        assert expected['description'] is None\n        assert expected['status'] == 'draft'\n        assert expected['updated_at'] is None\n        assert expected['published_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n        # --- options ---\n        assert isinstance(expected['options'], list)\n        assert len(expected['options']) == 1\n        for option in expected['options']:\n            assert isinstance(option[\"options_id\"], int)\n            assert option[\"option_name\"] == 'color'\n            assert isinstance(option['items'], list)\n            assert len(option['items']) == 1\n            for item in option['items']:\n                assert isinstance(item[\"item_id\"], int)\n                assert item[\"item_name\"] == 'red'\n\n        # --- variants ---\n        assert isinstance(expected['variants'], list)\n        assert len(expected['variants']) == 1\n        for variant in expected['variants']:\n            assert isinstance(variant[\"variant_id\"], int)\n            assert isinstance(variant[\"product_id\"], int)\n            assert isinstance(variant['price'], float)\n            assert isinstance(variant['stock'], int)\n            assert isinstance(variant['option1'], int)\n            assert variant['option2'] is None\n            assert variant['option3'] is None\n            assert variant['updated_at'] is None\n            self.assert_datetime_format(variant['created_at'])\n\n        # --- media ---\n        assert expected['media'] is None\n\n    # ---------------------\n    # --- Test Payloads ---\n    # ---------------------\n\n    # TODO test_with_html_description\n\n    def test_payload_is_empty(self):\n        \"\"\"\n        Test create a product with empty payload.\n        \"\"\"\n\n        response = self.client.post(self.product_endpoint, json={}, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_payload_product_name_max_length(self):\n        \"\"\"\n        Test create a product with a name more than `max_length=255` character.\n        \"\"\"\n\n        payload = {\n            'product_name': 'T' * 256\n        }\n\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"name\", [\"\", None])\n    def test_payload_product_name_invalid(self, name):\n        \"\"\"\n        Test with empty product name.\n        \"\"\"\n\n        payload = {\n            'product_name': name\n        }\n\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_payload_without_product_name(self):\n        \"\"\"\n        Test if product-name don't exist in payload.\n        \"\"\"\n\n        payload = {\n            'description': 'blob'\n        }\n\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"status_value\", [\"\", None, \"blob\", 1, False, 'active', 'archived', 'draft'])\n    def test_payload_invalid_status(self, status_value):\n        \"\"\"\n        Test create a product with invalid status value in the payload.\n        Test set product `status` to 'draft' by default.\n        Test if `status` not set, or it is not one of (active, draft, archive) then set it value to 'draft'.\n        \"\"\"\n\n        payload = {\n            'product_name': 'Test Product',\n            'status': status_value\n        }\n\n        # Handle different status_value cases\n        if status_value not in ['active', 'archived', 'draft']:\n            expected_status = 'draft'\n        else:\n            expected_status = status_value\n\n        # --- request ---\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n\n        # --- expected ---\n        if isinstance(status_value, str | None):\n            assert response.status_code == status.HTTP_201_CREATED\n            expected = response.json().get('product')\n            assert expected['status'] == expected_status\n        else:\n            assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"options_value\", [\n        '', [''], ['blob'], [{}],\n        [{'option_name': []}],\n        [{'option_name': ''}],\n        [{'option_name': '', 'items': []}],\n        [{'option_name': '', 'items': ['a']}],\n        [{'option_name': 'blob', 'items': ''}],\n        [{'option_name': 'blob', 'items': [1]}],\n        [{'option_name': 'blob', 'items_blob': [\"a\"]}],\n        [{'option_blob': 'blob', 'items': ['a']}],\n        [{'items': ['a'], 'option_blob': 'blob'}],\n        [{'option_name': 'blob', 'items': [[\"a\", \"b\"]]}]\n    ])\n    def test_payload_invalid_options(self, options_value):\n        \"\"\"\n        Test create a product with:\n        - invalid option in the payload\n        - invalid option-item in payload\n        \"\"\"\n\n        payload = {\n            'product_name': 'Test Product',\n            'options': options_value\n        }\n\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"price_value\", [-10, None, \"\"])\n    def test_payload_invalid_price(self, price_value):\n        \"\"\"\n        Test create a product with invalid price.\n        \"\"\"\n\n        payload = {\n            'product_name': 'Test Product',\n            'price': price_value\n        }\n\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"stock_value\", [-10, None, \"\", 1.3])\n    def test_payload_invalid_stock(self, stock_value):\n        \"\"\"\n        Test create a product with invalid stock.\n        \"\"\"\n\n        payload = {\n            'product_name': 'Test Product',\n            'stock': stock_value\n        }\n\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_payload_with_duplicate_options(self):\n        \"\"\"\n        Test create a product with uniq option-names.\n\n        **Duplicate options should not be saved in a product**\n        \"\"\"\n\n        payload = {\n            \"product_name\": 'blob',\n            \"options\": [\n                {\n                    \"option_name\": \"color\",\n                    \"items\": [\"red\"]\n                },\n                {\n                    \"option_name\": \"size\",\n                    \"items\": [\"small\"]\n                },\n                {\n                    \"option_name\": \"color\",\n                    \"items\": [\"blue\"]\n                }\n            ]\n        }\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_payload_with_duplicate_items_in_options(self):\n        \"\"\"\n        Test create a product with uniq item-names in each option.\n\n        **Duplicate items should not be saved in an option**\n        \"\"\"\n\n        payload = {\n            \"product_name\": \"blob\",\n            \"options\": [\n                {\n                    \"option_name\": \"color\",\n                    \"items\": [\"red\", \"blue\", \"red\"]\n                },\n                {\n                    \"option_name\": \"size\",\n                    \"items\": [\"S\", \"L\"]\n                }\n            ]\n        }\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_payload_with_max_3_options(self):\n        \"\"\"\n        Test create a product with more than three options.\n        \"\"\"\n\n        payload = {\n            \"product_name\": \"blob\",\n            \"options\": [\n                {\n                    \"option_name\": \"color\",\n                    \"items\": [\"red\"]\n                },\n                {\n                    \"option_name\": \"size\",\n                    \"items\": [\"small\"]\n                },\n                {\n                    \"option_name\": \"material\",\n                    \"items\": [\"x1\", \"x2\"]\n                },\n                {\n                    \"option_name\": \"blob\",\n                    \"items\": [\"b\"]\n                }\n            ]\n        }\n\n        response = self.client.post(self.product_endpoint, json=payload, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestRetrieveProduct(ProductTestBase):\n    \"\"\"\n    Test retrieve products on the multi scenario\n    \"\"\"\n\n    def test_retrieve_product(self):\n        \"\"\"\n        Test retrieve a product:\n        - with product fields.\n        - with one variant.\n        - no options.\n        - no media.\n        \"\"\"\n\n        # --- create a product ---\n        payload, product = FakeProduct.populate_product()\n\n        # --- retrieve product ---\n        response = self.client.get(f'{self.product_endpoint}{product.id}')\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- response data ---\n        expected = response.json()\n        assert isinstance(expected['product'], dict)\n        expected = expected['product']\n\n        # --- product ---\n        assert expected['product_id'] == product.id\n        assert expected['product_name'] == payload['product_name']\n        assert expected['description'] == payload['description']\n        assert expected['status'] == payload['status']\n        assert expected['updated_at'] is None\n        assert expected['published_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n        # --- options & media ---\n        assert expected['options'] is None\n        assert expected['media'] is None\n\n        # --- variant ---\n        assert isinstance(expected['variants'], list)\n        assert len(expected['variants']) == 1\n        variant = expected['variants'][0]\n        assert variant['variant_id'] > 0\n        assert variant['product_id'] == product.id\n        assert variant['price'] == payload['price']\n        assert variant['stock'] == payload['stock']\n        assert variant['option1'] is None\n        assert variant['option2'] is None\n        assert variant['option3'] is None\n        assert variant['updated_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n    def test_retrieve_product_with_options(self):\n        \"\"\"\n        Test retrieve a product with options:\n        - with price and stock.\n        - with options\n        - with variants.\n        - no media.\n        \"\"\"\n\n        # --- create a product ---\n        payload, product = FakeProduct.populate_product_with_options()\n\n        # --- retrieve product ---\n        response = self.client.get(f\"{self.product_endpoint}{product.id}\")\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- response data ---\n        expected = response.json()\n        assert isinstance(expected['product'], dict)\n        expected = expected['product']\n\n        # --- product ---\n        assert expected['product_id'] == product.id\n        assert expected['product_name'] == payload['product_name']\n        assert expected['description'] == payload['description']\n        assert expected['status'] == payload['status']\n        assert expected['updated_at'] is None\n        assert expected['published_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n        # --- options ---\n        assert isinstance(expected['options'], list)\n        assert len(expected['options']) == 3\n        for option in expected['options']:\n            assert isinstance(option[\"options_id\"], int)\n            assert isinstance(option[\"option_name\"], str)\n            assert isinstance(option['items'], list)\n            assert len(option['items']) == 2\n            for item in option['items']:\n                assert isinstance(item[\"item_id\"], int)\n                assert isinstance(item[\"item_name\"], str)\n\n        # --- variants ---\n        assert isinstance(expected['variants'], list)\n        assert len(expected['variants']) == 8\n        for variant in expected['variants']:\n            assert isinstance(variant[\"variant_id\"], int)\n            assert variant[\"product_id\"] == product.id\n            assert isinstance(variant['price'], float)\n            assert isinstance(variant['stock'], int)\n            assert isinstance(variant['option1'], int)\n            assert isinstance(variant['option2'], int)\n            assert isinstance(variant['option3'], int)\n            assert variant['updated_at'] is None\n            self.assert_datetime_format(variant['created_at'])\n\n        # --- media ---\n        assert expected['media'] is None\n\n    def test_retrieve_product_with_media(self):\n        \"\"\"\n        Test retrieve a product and test response.\n        \"\"\"\n\n        # --- create a product ---\n        payload, product = asyncio.run(FakeProduct.populate_product_with_media())\n\n        # --- retrieve product ---\n        response = self.client.get(f\"{self.product_endpoint}{product.id}\")\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- response data ---\n        expected = response.json()\n        assert isinstance(expected['product'], dict)\n        expected = expected['product']\n\n        # --- product ---\n        assert expected['product_id'] == product.id\n        assert expected['product_name'] == payload['product_name']\n        assert expected['description'] == payload['description']\n        assert expected['status'] == payload['status']\n        assert expected['updated_at'] is None\n        assert expected['published_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n        # --- options ---\n        assert expected['options'] is None\n\n        # --- variant ---\n        assert isinstance(expected['variants'], list)\n        assert len(expected['variants']) == 1\n        variant = expected['variants'][0]\n        assert variant['variant_id'] > 0\n        assert variant['product_id'] == product.id\n        assert variant['price'] == payload['price']\n        assert variant['stock'] == payload['stock']\n        assert variant['option1'] is None\n        assert variant['option2'] is None\n        assert variant['option3'] is None\n        assert variant['updated_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n        # --- media ---\n        assert isinstance(expected['media'], list)\n        assert len(expected['media']) > 0\n        media = expected['media']\n        for media_item in media:\n            assert media_item[\"media_id\"] > 0\n            assert media_item[\"product_id\"] > 0\n            assert media_item[\"alt\"] == payload['alt']\n            assert media_item[\"src\"] is not None\n            assert media_item[\"type\"] is not None\n            assert media_item[\"updated_at\"] is None\n            self.assert_datetime_format(media_item['created_at'])\n\n    def test_retrieve_product_with_options_media(self):\n        \"\"\"\n        Test retrieve a product with options and media files.\n        \"\"\"\n\n        # --- create a product ---\n        payload, product = asyncio.run(FakeProduct.populate_product_with_options_media())\n\n        # --- retrieve product ---\n        response = self.client.get(f\"{self.product_endpoint}{product.id}\")\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- response data ---\n        expected = response.json()\n        assert isinstance(expected['product'], dict)\n        expected = expected['product']\n\n        # --- product ---\n        assert expected['product_id'] == product.id\n        assert expected['product_name'] == payload['product_name']\n        assert expected['description'] == payload['description']\n        assert expected['status'] == payload['status']\n        assert expected['updated_at'] is None\n        assert expected['published_at'] is None\n        self.assert_datetime_format(expected['created_at'])\n\n        # --- options ---\n        assert isinstance(expected['options'], list)\n        assert len(expected['options']) == 3\n        for option in expected['options']:\n            assert isinstance(option[\"options_id\"], int)\n            assert isinstance(option[\"option_name\"], str)\n            assert isinstance(option['items'], list)\n            assert len(option['items']) == 2\n            for item in option['items']:\n                assert isinstance(item[\"item_id\"], int)\n                assert isinstance(item[\"item_name\"], str)\n\n        # --- variants ---\n        assert isinstance(expected['variants'], list)\n        assert len(expected['variants']) == 8\n        for variant in expected['variants']:\n            assert isinstance(variant[\"variant_id\"], int)\n            assert variant[\"product_id\"] == product.id\n            assert isinstance(variant['price'], float)\n            assert isinstance(variant['stock'], int)\n            assert isinstance(variant['option1'], int)\n            assert isinstance(variant['option2'], int)\n            assert isinstance(variant['option3'], int)\n            assert variant['updated_at'] is None\n            self.assert_datetime_format(variant['created_at'])\n\n        # --- media ---\n        assert isinstance(expected['media'], list)\n        assert len(expected['media']) > 0\n        media = expected['media']\n        for media_item in media:\n            assert media_item[\"media_id\"] > 0\n            assert media_item[\"product_id\"] > 0\n            assert media_item[\"alt\"] == payload['alt']\n            assert media_item[\"src\"] is not None\n            assert media_item[\"type\"] is not None\n            assert media_item[\"updated_at\"] is None\n            self.assert_datetime_format(media_item['created_at'])\n\n    def test_retrieve_product_404(self):\n        \"\"\"\n        Test retrieve a product if it doesn't exist.\n        \"\"\"\n        response = self.client.get(f\"{self.product_endpoint}{999999999}\")\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    # ---------------------\n    # --- Test Payloads ---\n    # ---------------------\n\n    # TODO pagination\n    # TODO in each pagination should load 12 products\n\n\nclass TestListProduct(ProductTestBase):\n\n    def test_list_products_no_content(self):\n        \"\"\"\n        TODO test list the products if admin dont published any product.\n        TODO Test list the products if is user and there are no active products to list them.\n        \"\"\"\n\n        response = self.client.get(self.product_endpoint)\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n    def test_list_products(self):\n        \"\"\"\n        Test retrieve a list of products.\n        \"\"\"\n        # --- create 30 products ---\n        asyncio.run(FakeProduct.populate_30_products())\n\n        # --- request ---\n        response = self.client.get(self.product_endpoint)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- response data ---\n        expected = response.json().get('products')\n        assert isinstance(expected, list)\n        assert len(expected) == 12\n\n        for product in expected:\n            assert len(product) == 10\n            assert isinstance(product['product_id'], int)\n            assert isinstance(product['product_name'], str)\n\n    # ---------------------\n    # --- Test Payloads ---\n    # ---------------------\n\n    # TODO dont load variants in the product list\n    # TODO test limit for product limit query\n    # TODO test 204 status code if there are not products to list\n\n\nclass TestUpdateProduct(ProductTestBase):\n    \"\"\"\n    Test update a product on the multi scenario.\n    \"\"\"\n\n    @pytest.mark.parametrize(\"update_payload\", [\n        {\"product_name\": \"updated name\"},\n        {\"description\": \"updated description\"},\n        {\"status\": \"archived\"},\n        {\"product_name\": \"updated name\", \"description\": \"updated description\"},\n        {\"product_name\": \"updated name\", \"status\": \"draft\"},\n        {\"description\": \"updated description\", \"status\": \"archived\"}\n    ])\n    def test_update_product(self, update_payload):\n        \"\"\"\n        Test update a product, only update fields that are there in request body and leave other fields unchanging.\n        \"\"\"\n\n        # --- create product ---\n        payload, product = FakeProduct.populate_product()\n\n        response = self.client.put(f\"{self.product_endpoint}{product.id}\", json=update_payload,\n                                   headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_200_OK\n\n        expected = response.json().get('product')\n        self.assert_datetime_format(expected['updated_at'])\n\n        # `created_at` should be same as before the update\n        assert expected['created_at'] == self.convert_datetime_to_string(product.created_at)\n\n        # ----------------------\n        # --- product fields ---\n        # ----------------------\n\n        field = tuple(update_payload.keys())\n        match field:\n            case ('product_name', ):\n                assert expected['product_name'] == update_payload['product_name']\n                assert expected['description'] == product.description\n                assert expected['status'] == product.status\n\n            case ('description', ):\n                assert expected['product_name'] == product.product_name\n                assert expected['description'] == update_payload['description']\n                assert expected['status'] == product.status\n\n            case ('status', ):\n                assert expected['product_name'] == product.product_name\n                assert expected['description'] == product.description\n                assert expected['status'] == update_payload['status']\n\n            case ('product_name', 'description'):\n                assert expected['product_name'] == update_payload['product_name']\n                assert expected['description'] == update_payload['description']\n                assert expected['status'] == product.status\n\n            case ('product_name', 'status'):\n                assert expected['product_name'] == update_payload['product_name']\n                assert expected['description'] == product.description\n                assert expected['status'] == update_payload['status']\n\n            case ('description', 'status'):\n                assert expected['product_name'] == product.product_name\n                assert expected['description'] == update_payload['description']\n                assert expected['status'] == update_payload['status']\n\n            case _:\n                # To ensure that all case statements in my code are executed\n                raise ValueError(f\"Unknown field(s): {field}\")\n\n    # ---------------------\n    # --- Test Payloads ---\n    # ---------------------\n\n\nclass TestDestroyProduct(ProductTestBase):\n    \"\"\"\n    Test delete a product on the multi scenario\n    \"\"\"\n\n    def test_delete_product(self):\n        \"\"\"\n        Test delete an existing product.\n        - delete product\n        - delete variant\n        \"\"\"\n\n        # --- create a product ---\n        _, product = FakeProduct.populate_product()\n\n        # --- request ---\n        response = self.client.delete(f\"{self.product_endpoint}{product.id}\", headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n        # --- expected ---\n        expected = self.client.get(f\"{self.product_endpoint}{product.id}\")\n        assert expected.status_code == status.HTTP_404_NOT_FOUND\n\n        variant = ProductService.retrieve_variants(product.id)\n        assert variant is None\n\n    @pytest.mark.asyncio\n    async def test_delete_product_with_media(self):\n        \"\"\"\n        Test delete an existing product with attached media.\n        - delete product\n        - delete variant\n        - delete media (not the files, just remove from database)\n        \"\"\"\n\n        # --- create a product with media ---\n        _, product = await FakeProduct.populate_product_with_media()\n\n        # --- request ---\n        response = self.client.delete(f\"{self.product_endpoint}{product.id}\", headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n        # --- expected ---\n        expected = self.client.get(f\"{self.product_endpoint}{product.id}\")\n        assert expected.status_code == status.HTTP_404_NOT_FOUND\n\n        variant = ProductService.retrieve_variants(product.id)\n        assert variant is None\n\n        media = ProductService.retrieve_media_list(product.id)\n        assert media is None\n\n    def test_delete_product_with_options(self):\n        \"\"\"\n        Test delete a product with options and option-items for this product.\n        - delete product\n        - delete variants\n        - delete options and option-items for this product\n        \"\"\"\n\n        # --- create a product with options ---\n        _, product = FakeProduct.populate_product_with_options()\n\n        # --- request ---\n        response = self.client.delete(f\"{self.product_endpoint}{product.id}\", headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n        # --- expected ---\n        expected = self.client.get(f\"{self.product_endpoint}{product.id}\")\n        assert expected.status_code == status.HTTP_404_NOT_FOUND\n\n        variant = ProductService.retrieve_variants(product.id)\n        assert variant is None\n\n        options = ProductService.retrieve_options(product.id)\n        assert options is None\n\n    @pytest.mark.asyncio\n    async def test_delete_product_with_options_media(self):\n        \"\"\"\n        Test delete a product with options and media.\n        - delete product\n        - delete variants\n        - delete options and option-items for this product\n        - delete media (not the files, just remove from database)\n        \"\"\"\n\n        # --- create a product with options and media ---\n        _, product = await FakeProduct.populate_product_with_options_media()\n\n        # --- request ---\n        response = self.client.delete(f\"{self.product_endpoint}{product.id}\", headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n        # --- expected ---\n        expected = self.client.get(f\"{self.product_endpoint}{product.id}\")\n        assert expected.status_code == status.HTTP_404_NOT_FOUND\n\n        variant = ProductService.retrieve_variants(product.id)\n        assert variant is None\n\n        options = ProductService.retrieve_options(product.id)\n        assert options is None\n\n        media = ProductService.retrieve_media_list(product.id)\n        assert media is None\n\n# TODO refactor tests\n"}
{"type": "test_file", "path": "apps/products/tests/test_product_media.py", "content": "import asyncio\n\nimport pytest\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\n\nfrom apps.accounts.faker.data import FakeUser\nfrom apps.accounts.models import User\nfrom apps.core.base_test_case import BaseTestCase\nfrom apps.main import app\nfrom apps.products.faker.data import FakeProduct, FakeMedia\nfrom apps.products.services import ProductService\nfrom config.database import DatabaseManager\n\n\nclass ProductMediaTestBase(BaseTestCase):\n    product_endpoint = '/products/'\n    product_media_endpoint = '/products/media/'\n\n    # --- members ---\n    admin: User | None = None\n    admin_authorization = {}\n\n    @classmethod\n    def setup_class(cls):\n        cls.client = TestClient(app)\n        DatabaseManager.create_test_database()\n\n        # --- create an admin ---\n        cls.admin, access_token = FakeUser.populate_admin()\n        cls.admin_authorization = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    @classmethod\n    def teardown_class(cls):\n        DatabaseManager.drop_all_tables()\n\n\nclass TestCreateProductMedia(ProductMediaTestBase):\n    \"\"\"\n    Test create product-media on the multi scenario\n    \"\"\"\n\n    def test_create_product_media(self):\n        \"\"\"\n        Test create a product-media (images) for a product and attach them to that product (assuming valid data).\n        Test the File \"type, size and url\".\n        \"\"\"\n\n        # --- create a product ---\n        product_payload, product = FakeProduct.populate_product()\n\n        # --- upload files ----\n        file_paths = FakeMedia.populate_images_for_product()\n        files = [(\"x_files\", open(file_path, \"rb\")) for file_path in file_paths]\n        media_payload = {\n            'alt': 'Test Alt Text'\n        }\n\n        # --- request ---\n        response = self.client.post(f\"{self.product_endpoint}{product.id}/media/\", data=media_payload, files=files,\n                                    headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_201_CREATED\n\n        # --- response data ---\n        expected = response.json()\n\n        # --- media ---\n        assert \"media\" in expected\n        media_list = expected[\"media\"]\n        assert isinstance(media_list, list)\n        for media in media_list:\n            assert media[\"media_id\"] > 0\n            assert media[\"product_id\"] == product.id\n            assert media[\"alt\"] == media_payload['alt']\n            assert \"src\" in media and not None\n            assert media[\"type\"] == 'jpg'\n            assert media[\"updated_at\"] is None\n            self.assert_datetime_format(media['created_at'])\n\n        # --- test static file URL ---\n        url = f'/media/test{media_list[0][\"src\"].split(\"/media\")[-1]}'\n        response = self.client.get(url)\n        assert response.status_code == status.HTTP_200_OK\n\n        # test file size is not zero\n        assert len(response.content) > 0\n\n\nclass TestRetrieveProductMedia(ProductMediaTestBase):\n    \"\"\"\n    Test retrieve product-media on the multi scenario\n    \"\"\"\n\n    def test_retrieve_single_media(self):\n        \"\"\"\n        Test retrieve a single product image\n        \"\"\"\n\n        # --- create a product ---\n        payload, product = asyncio.run(FakeProduct.populate_product_with_media())\n\n        # --- get a media ---\n        media = ProductService.retrieve_media_list(product.id)[0]\n\n        # --- request ---\n        response = self.client.get(f\"{self.product_media_endpoint}{media['media_id']}\")\n        assert response.status_code == status.HTTP_200_OK\n\n    @pytest.mark.asyncio\n    async def test_list_product_media(self):\n        \"\"\"\n        Test retrieve a list of all media of a product.\n        \"\"\"\n\n        # --- create a product ---\n        payload, product = await FakeProduct.populate_product_with_media()\n\n        # --- request ---\n        response = self.client.get(f\"{self.product_endpoint}{product.id}/{'media'}\")\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- response data ---\n        expected = response.json()\n\n        # --- media ---\n        assert \"media\" in expected\n        media_list = expected[\"media\"]\n        assert isinstance(media_list, list)\n        assert len(media_list) > 0\n        for media in media_list:\n            assert media[\"media_id\"] > 0\n            assert media[\"product_id\"] == product.id\n            assert media[\"alt\"] == payload['alt']\n            assert \"src\" in media\n            assert media[\"type\"] == 'jpg'\n            assert media[\"updated_at\"] is None\n            self.assert_datetime_format(media['created_at'])\n\n    def test_list_product_media_when_empty(self):\n        \"\"\"\n        Test retrieving media for a product when the product has no media.\n        \"\"\"\n\n        # --- create a product ---\n        payload, product = FakeProduct.populate_product()\n\n        # --- request ---\n        response = self.client.get(f\"{self.product_endpoint}{product.id}/{'media'}\")\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n\nclass TestUpdateProductMedia(ProductMediaTestBase):\n    @pytest.mark.asyncio\n    async def test_update_media(self):\n        \"\"\"\n        Test update a media, only update fields that are there in request body\n         and leave other fields unchanging.\n\n        Update one media in each request by `media_id`.\n        \"\"\"\n\n        # --- create product ---\n        payload, product = await FakeProduct.populate_product_with_media()\n\n        # --- get a media ---\n        media = ProductService.retrieve_media_list(product.id)[0]\n        update_payload = {\n            \"media_id\": media['media_id'],\n            \"alt\": \"updated alt text\"\n        }\n\n        # --- add media file ---\n        file_paths = FakeMedia.populate_images_for_product()\n        file = (\"file\", open(file_paths[0], \"rb\"))\n\n        # --- request ---\n        response = self.client.put(f\"{self.product_media_endpoint}{media['media_id']}\", data=update_payload,\n                                   files={\"file\": file}, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected ---\n        expected = response.json().get('media')\n        assert expected['alt'] == update_payload['alt']\n        self.assert_datetime_format(expected['updated_at'])\n        assert expected['created_at'] == media['created_at']\n        assert expected['src'] != media['src']\n        assert expected['src'] is not None\n\n        # --- test static file URL ---\n        url = f'/media/test{media[\"src\"].split(\"/media\")[-1]}'\n        response = self.client.get(url)\n        assert response.status_code == status.HTTP_200_OK\n\n        # test file size is not zero\n        assert len(response.content) > 0\n\n\nclass TestDestroyProductMedia(ProductMediaTestBase):\n    @pytest.mark.asyncio\n    async def test_delete_media_from_product(self):\n        \"\"\"\n        Test delete media from a product.\n        \"\"\"\n\n        # --- create product with media ---\n        payload, product = await FakeProduct.populate_product_with_media()\n\n        # --- get a media ---\n        media = ProductService.retrieve_media_list(product.id)\n        media_ids = [\n            media[0]['media_id'],\n            media[1]['media_id']\n        ]\n\n        # --- prepare URL ---\n        url = f\"{self.product_endpoint}{product.id}/media/?media_ids={','.join(map(str, media_ids))}\"\n\n        # --- request ---\n        response = self.client.delete(url, headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n        # --- expected ---\n        media_1 = ProductService.retrieve_single_media(media[0]['media_id'])\n        media_2 = ProductService.retrieve_single_media(media[1]['media_id'])\n        assert media_1 is None\n        assert media_2 is None\n\n    @pytest.mark.asyncio\n    async def test_delete_media_file(self):\n        \"\"\"\n        Test delete a media file.\n        \"\"\"\n\n        # --- create a product with media ---\n        _, product = await FakeProduct.populate_product_with_media()\n\n        # --- retrieve media to get a media_id ---\n        media = ProductService.retrieve_media_list(product.id)[0]\n        media_id = media['media_id']\n        # --- request ---\n        response = self.client.delete(f\"{self.product_media_endpoint}{media_id}\", headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n        # --- expected ---\n        expected_media = ProductService.retrieve_single_media(media_id)\n        assert expected_media is None\n\n        # --- test static file URL ---\n        url = f'/media/test{media[\"src\"].split(\"/media\")[-1]}'\n        response = self.client.get(url)\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n\nclass TestProductMediaPayloadFields(ProductMediaTestBase):\n    \"\"\"\n    Test scenarios with different payload fields.\n    \"\"\"\n\n    @pytest.mark.parametrize(\"alt_value\", [\"\", None])\n    def test_create_media_with_empty_alt(self, alt_value):\n        \"\"\"\n        Test crete media with no `alt` or empty `alt` field.\n        \"\"\"\n\n        # --- create a product ---\n        product_payload, product = FakeProduct.populate_product()\n\n        # --- upload files ----\n        file_paths = FakeMedia.populate_images_for_product()\n        files = [(\"x_files\", open(file_path, \"rb\")) for file_path in file_paths]\n        media_payload = {\n            'alt': alt_value\n        }\n\n        # --- request ---\n        response = self.client.post(f\"{self.product_endpoint}{product.id}/media/\", data=media_payload, files=files,\n                                    headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_201_CREATED\n\n        expected = response.json().get('media')[0]\n        assert expected['alt'] == product.product_name\n\n    def test_create_media_with_empty_payload(self):\n        \"\"\"\n        Test crete media with empty payload.\n        \"\"\"\n\n        # --- create a product ---\n        product_payload, product = FakeProduct.populate_product()\n\n        # --- upload files ----\n        file_paths = FakeMedia.populate_images_for_product()\n        files = [(\"x_files\", open(file_path, \"rb\")) for file_path in file_paths]\n\n        # --- request ---\n        response = self.client.post(f\"{self.product_endpoint}{product.id}/media/\", data={}, files=files,\n                                    headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_201_CREATED\n\n    def test_create_media_with_no_file(self):\n        \"\"\"\n        Test create media without files\n        \"\"\"\n\n        # --- create a product ---\n        product_payload, product = FakeProduct.populate_product()\n\n        # --- upload files ----\n        media_payload = {\n            'alt': 'test alt'\n        }\n\n        # --- request ---\n        response = self.client.post(f\"{self.product_endpoint}{product.id}/media/\", data=media_payload,\n                                    headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_create_media_with_invalid_file_type(self):\n        \"\"\"\n        Test create media with invalid file type.\n        \"\"\"\n\n        # --- create a product ---\n        product_payload, product = FakeProduct.populate_product()\n\n        # --- upload files ----\n        file_paths = FakeMedia.populate_docs_file()\n        files = [(\"x_files\", open(file_path, \"rb\")) for file_path in file_paths]\n        media_payload = {\n            'alt': 'test alt'\n        }\n\n        # --- request ---\n        response = self.client.post(f\"{self.product_endpoint}{product.id}/media/\", data=media_payload, files=files,\n                                    headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n\n    def test_create_media_with_max_size_limit(self):\n        \"\"\"\n        Test create media with limit of max size.\n        \"\"\"\n\n        # --- create a product ---\n        product_payload, product = FakeProduct.populate_product()\n\n        # --- upload files ----\n        file_paths = FakeMedia.populate_large_file()\n        files = [(\"x_files\", open(file_path, \"rb\")) for file_path in file_paths]\n        media_payload = {\n            'alt': 'test alt'\n        }\n\n        # --- request ---\n        response = self.client.post(f\"{self.product_endpoint}{product.id}/media/\", data=media_payload, files=files,\n                                    headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n\n# TODO test permissions for CRUD on product routers\n"}
{"type": "test_file", "path": "apps/accounts/tests/test_user.py", "content": "from fastapi import status\nfrom fastapi.testclient import TestClient\n\nfrom apps.accounts.faker.data import FakeUser\nfrom apps.accounts.models import UserVerification\nfrom apps.accounts.services.authenticate import AccountService\nfrom apps.accounts.services.password import PasswordManager\nfrom apps.accounts.services.token import TokenService\nfrom apps.accounts.services.user import UserManager\nfrom apps.core.base_test_case import BaseTestCase\nfrom apps.main import app\nfrom config.database import DatabaseManager\n\n\nclass UserTestBase(BaseTestCase):\n    current_user_endpoint = \"/accounts/me/\"\n    change_password_endpoint = \"/accounts/me/password/\"\n    change_email_endpoint = \"/accounts/me/email/\"\n    verify_change_email_endpoint = \"/accounts/me/email/verify/\"\n    accounts_endpoint = \"/accounts/\"\n\n    @classmethod\n    def setup_class(cls):\n        cls.client = TestClient(app)\n        DatabaseManager.create_test_database()\n\n    @classmethod\n    def teardown_class(cls):\n        DatabaseManager.drop_all_tables()\n\n\nclass TestRetrieveUser(UserTestBase):\n\n    def test_successful_retrieve_me(self):\n        \"\"\"\n        Test retrieving a current user.\n        \"\"\"\n\n        # --- create user and generate token ---\n        user, access_token = FakeUser.populate_user()\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\"\n        }\n\n        # --- request to fetch user data from token ---\n        response = self.client.get(self.current_user_endpoint, headers=headers)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected user ---\n        expected_user = response.json().get('user')\n        assert expected_user['user_id'] == user.id\n        assert expected_user['email'] == user.email\n        assert expected_user['first_name'] == user.first_name\n        assert expected_user['last_name'] == user.last_name\n        assert expected_user['is_verified_email'] == user.is_verified_email\n        self.assert_datetime_format(expected_user['date_joined'])\n        self.assert_datetime_format(expected_user['updated_at'])\n        self.assert_datetime_format(expected_user['last_login'])\n        assert 'password' not in expected_user\n        assert 'is_active' not in expected_user\n        assert 'otp_key' not in expected_user\n\n    def test_retrieve_me_protected(self):\n        \"\"\"\n        Test endpoint is protected.\n        \"\"\"\n\n        response = self.client.get(self.current_user_endpoint)\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    def test_retrieve_single_user(self):\n        \"\"\"\n        Test retrieve a single user by ID with admin role. only 'admin' can access to it.\n        \"\"\"\n\n        # --- create an admin with access-token ---\n        admin, access_token = FakeUser.populate_admin()\n        user, _ = FakeUser.populate_user()\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\"\n        }\n\n        # --- request to fetch user data from token ---\n        response = self.client.get(f\"{self.accounts_endpoint}{user.id}\", headers=headers)\n        assert response.status_code == status.HTTP_200_OK\n\n    def test_retrieve_single_user_403(self):\n        \"\"\"\n        Test retrieve a single user by ID with user role. only 'admin' can access to it.\n        \"\"\"\n\n        # --- create user with access-token ---\n        user_1, access_token = FakeUser.populate_user()\n        user_2, _ = FakeUser.populate_user()\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\"\n        }\n\n        # --- request to fetch user data from token ---\n        response = self.client.get(f\"{self.accounts_endpoint}{user_2.id}\", headers=headers)\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    # ---------------------\n    # --- Test Payloads ---\n    # ---------------------\n\n\nclass TestUpdateUser(UserTestBase):\n    def test_update_current_user(self):\n        \"\"\"\n        Test update the current user with \"user\" role.\n        \"\"\"\n\n        # --- create user ---\n        user, access_token = FakeUser.populate_user()\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        payload = {\n            'first_name': FakeUser.fake.first_name(),\n            'last_name': FakeUser.fake.last_name()\n        }\n\n        # --- request ---\n        response = self.client.put(self.current_user_endpoint, headers=headers, json=payload)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected ---\n        expected_user = response.json().get('user')\n        assert expected_user['first_name'] == payload['first_name']\n        assert expected_user['last_name'] == payload['last_name']\n        self.assert_datetime_format(expected_user['updated_at'])\n\n    # TODO update current admin\n\n    # ---------------------\n    # --- Test Payloads ---\n    # ---------------------\n\n\nclass TestChanges(UserTestBase):\n\n    def test_change_password(self):\n        \"\"\"\n        Test change password by current user.\n        \"\"\"\n\n        # --- create a user ---\n        user, access_token = FakeUser.populate_user()\n        header = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # --- request ---\n        payload = {\n            'current_password': FakeUser.password,\n            'password': FakeUser.password + \"test\",\n            'password_confirm': FakeUser.password + \"test\"\n        }\n        response = self.client.patch(self.change_password_endpoint, headers=header, json=payload)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected ---\n        expected = response.json()\n        assert expected['message'] == 'Your password has been changed.'\n\n        # --- expected user data, ensure other info wasn't changed ---\n        expected_user = UserManager.get_user(user.id)\n        assert PasswordManager.verify_password(payload['password'], expected_user.password) is True\n        assert expected_user.email == user.email\n        assert expected_user.is_verified_email is True\n        assert expected_user.role == user.role\n        assert expected_user.first_name == user.first_name\n        assert expected_user.last_name == user.last_name\n        # assert expected_user.updated_at != user.updated_at\n        assert expected_user.date_joined == user.date_joined\n        assert expected_user.last_login == user.last_login\n        self.assert_datetime_format(expected_user.date_joined)\n        self.assert_datetime_format(expected_user.updated_at)\n        self.assert_datetime_format(expected_user.last_login)\n\n        # --- test current token is set to none ---\n        expected_access_token = UserVerification.filter(\n            UserVerification.user_id == expected_user.id).first().active_access_token\n        assert expected_access_token is None\n\n        # --- test fetch user with old access-token ---\n        header = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n        result = self.client.get(self.current_user_endpoint, headers=header)\n        assert result.status_code == status.HTTP_401_UNAUTHORIZED\n\n    def test_change_email(self):\n        \"\"\"\n        Test change the email of the current user.\n        \"\"\"\n\n        # --- create a user ---\n        user, access_token = FakeUser.populate_user()\n\n        # --- request ---\n        header = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n        payload = {'new_email': FakeUser.random_email()}\n\n        response = self.client.post(self.change_email_endpoint, headers=header, json=payload)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected change request ---\n        change_request: UserVerification = UserVerification.filter(UserVerification.user_id == user.id).first()\n        assert change_request.new_email == payload[\"new_email\"]\n        assert change_request.request_type == 'change-email'\n\n        # --- expected response ---\n        expected = response.json()\n        assert expected['message'] == (f'Please check your email \\\"{payload[\"new_email\"]}\\\" for an OTP code to'\n                                       f' confirm the change email request.')\n\n    def test_verify_email_change_request(self):\n        \"\"\"\n        Test verify the change email of the current.\n        \"\"\"\n\n        # --- create a user ---\n        user, access_token = FakeUser.populate_user()\n        new_email = FakeUser.random_email()\n\n        # --- set a change email request ---\n        AccountService.change_email(user, new_email)\n\n        # --- request ---\n        header = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n        payload = {\n            'otp': TokenService.create_otp_token(),\n        }\n\n        response = self.client.patch(self.verify_change_email_endpoint, headers=header, json=payload)\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected response ---\n        expected = response.json()\n        assert expected['message'] == 'Your email is changed.'\n\n        # --- expected user data, ensure other info wasn't changed ---\n        expected_user = UserManager.get_user(user.id)\n        assert expected_user.email == new_email\n        assert expected_user.is_verified_email is True\n        assert expected_user.role == user.role\n        assert expected_user.first_name == user.first_name\n        assert expected_user.last_name == user.last_name\n        assert expected_user.password == user.password\n        # assert expected_user.updated_at != user.updated_at\n        assert expected_user.date_joined == user.date_joined\n        assert expected_user.last_login == user.last_login\n        self.assert_datetime_format(expected_user.date_joined)\n        self.assert_datetime_format(expected_user.updated_at)\n        self.assert_datetime_format(expected_user.last_login)\n\n        # --- expected in UserVerification ---\n        change_request: UserVerification = UserVerification.filter(UserVerification.user_id == user.id).first()\n        assert change_request.new_email is None\n        assert change_request.request_type is None\n\n        # --- test current token is valid ---\n        expected_access_token = UserVerification.filter(\n            UserVerification.user_id == expected_user.id).first().active_access_token\n        assert expected_access_token == access_token\n\n        # ---------------------\n        # --- Test Payloads ---\n        # ---------------------\n"}
{"type": "test_file", "path": "config/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "apps/products/tests/test_variant.py", "content": "import pytest\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\n\nfrom apps.accounts.faker.data import FakeUser\nfrom apps.accounts.models import User\nfrom apps.core.base_test_case import BaseTestCase\nfrom apps.main import app\nfrom apps.products.faker.data import FakeProduct\nfrom apps.products.services import ProductService\nfrom config.database import DatabaseManager\n\n\nclass VariantTestBase(BaseTestCase):\n    variants_endpoint = '/products/variants/'\n\n    # --- members ---\n    admin: User | None = None\n    admin_authorization = {}\n\n    @classmethod\n    def setup_class(cls):\n        cls.client = TestClient(app)\n        DatabaseManager.create_test_database()\n\n        # --- create an admin ---\n        cls.admin, access_token = FakeUser.populate_admin()\n        cls.admin_authorization = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    @classmethod\n    def teardown_class(cls):\n        DatabaseManager.drop_all_tables()\n\n\nclass TestRetrieveVariants(VariantTestBase):\n    \"\"\"\n    Test retrieving variant in multi scenario.\n    \"\"\"\n\n    def test_retrieve_variant(self):\n        \"\"\"\n        Test retrieve a variant of a product.\n        \"\"\"\n\n        # --- create a product with variant ---\n        _, product = FakeProduct.populate_product_with_options(get_product_obj=False)\n        variant = product['variants'][0]\n\n        response = self.client.get(f\"{self.variants_endpoint}{variant['variant_id']}\")\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected ---\n        expected_variant = response.json().get('variant')\n        assert isinstance(expected_variant, dict)\n        assert len(expected_variant) == 9\n        assert product['product_id'] == expected_variant['product_id']\n        assert isinstance(expected_variant['price'], float)\n        assert variant['stock'] == expected_variant['stock']\n        assert variant['option1'] == expected_variant['option1']\n        assert variant['option2'] == expected_variant['option2']\n        assert variant['option3'] == expected_variant['option3']\n        assert variant['updated_at'] == expected_variant['updated_at']\n        self.assert_datetime_format(expected_variant['created_at'])\n\n    def test_list_product_variants(self):\n        \"\"\"\n        Test retrieve a variant of a product.\n        \"\"\"\n\n        # --- create a product with variants ---\n        _, product = FakeProduct.populate_product_with_options(get_product_obj=False)\n        variants = product['variants']\n\n        variants_len = len(variants)\n\n        response = self.client.get(f\"/products/{product['product_id']}/variants\")\n        assert response.status_code == status.HTTP_200_OK\n\n        # --- expected ---\n        expected_variants = response.json().get('variants')\n        assert isinstance(expected_variants, list)\n        assert len(expected_variants) == variants_len\n\n        for i, variant in enumerate(variants):\n            expected: dict = expected_variants[i]\n            assert product['product_id'] == expected['product_id']\n            assert isinstance(expected['price'], float)\n            assert variant['stock'] == expected['stock']\n            assert variant['option1'] == expected['option1']\n            assert variant['option2'] == expected['option2']\n            assert variant['option3'] == expected['option3']\n            assert variant['updated_at'] == expected['updated_at']\n            self.assert_datetime_format(expected['created_at'])\n\n\nclass TestUpdateVariants(VariantTestBase):\n    \"\"\"\n    Test update a variant on the multi scenario.\n    \"\"\"\n\n    @pytest.mark.parametrize(\"payload\", [\n        {\"price\": 4.99},\n        {\"stock\": 15},\n        {\"price\": 6.99, \"stock\": 36}\n    ])\n    def test_update_variant(self, payload):\n        \"\"\"\n        Test update a variant, only update fields that are there in request body and leave other fields unchanging.\n        \"\"\"\n\n        # --- create product ---\n        _, product = FakeProduct.populate_product_with_options()\n        variants = ProductService.retrieve_variants(product.id)\n        before_update = ProductService.retrieve_variant(variants[0]['variant_id'])\n\n        response = self.client.put(f\"{self.variants_endpoint}{before_update['variant_id']}\", json=payload,\n                                   headers=self.admin_authorization)\n        assert response.status_code == status.HTTP_200_OK\n\n        after_update = response.json().get('variant')\n        self.assert_datetime_format(after_update['updated_at'])\n        assert after_update['created_at'] == before_update['created_at']\n\n        # ----------------------\n        # --- variant fields ---\n        # ----------------------\n\n        field = tuple(payload.keys())\n        match field:\n            case ('price', ):\n                assert after_update['price'] == payload['price']\n                assert after_update['stock'] == before_update['stock']\n\n            case ('stock', ):\n                assert after_update['price'] == float(before_update['price'])\n                assert after_update['stock'] == payload['stock']\n\n            case ('price', 'stock'):\n                assert after_update['price'] == payload['price']\n                assert after_update['stock'] == payload['stock']\n\n            case _:\n                # To ensure that all case statements in my code are executed\n                raise ValueError(f\"Unknown field(s): {field}\")\n"}
{"type": "source_file", "path": "apps/core/date_time.py", "content": "from datetime import datetime\n\n\nclass DateTime:\n\n    @classmethod\n    def string(cls, obj: datetime):\n        \"\"\"\n        Convert a datetime object to a formatted string.\n\n        This method takes a datetime object `obj` and converts it into a string\n        in the format 'YYYY-MM-DD HH:MM:SS'. If `obj` is None or evaluates to False,\n        it returns None.\n\n        Parameters:\n        cls (object): An instance of the class (although this argument is not used).\n        obj (datetime or None): The datetime object to be converted to a string.\n\n        Returns:\n        str or None: A formatted string representation of the datetime object,\n                     or None if the input is None or evaluates to False.\n        \"\"\"\n\n        return obj.strftime('%Y-%m-%d %H:%M:%S') if obj else None\n\n    @classmethod\n    def now(cls):\n        return datetime.strptime(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), '%Y-%m-%d %H:%M:%S')\n"}
{"type": "source_file", "path": "apps/core/__init__.py", "content": ""}
{"type": "source_file", "path": "apps/accounts/models.py", "content": "from sqlalchemy import Column, Integer, String, Boolean, DateTime, func, ForeignKey\nfrom sqlalchemy.orm import relationship\n\nfrom config.database import FastModel\n\n\nclass User(FastModel):\n    \"\"\"\n    User represents registered users in the application.\n\n    Attributes:\n        id (int): Unique identifier for the user.\n        email (str): User's email address used for authentication and communication.\n        password (str): Hashed password for user authentication.\n        first_name (str, optional): User's first name. Default is None.\n        last_name (str, optional): User's last name. Default is None.\n        is_verified_email (bool): Flag indicating whether the user's email address has been verified.\n        is_active (bool): Flag indicating whether the user's account is active.\n        is_superuser (bool): Flag indicating whether the user has superuser privileges.\n        role (str): User's role in the system, represented as a short string.\n        date_joined (datetime): Timestamp indicating when the user account was created.\n        updated_at (datetime, optional): Timestamp indicating when the user account was last updated. Default is None.\n        last_login (datetime, optional): Timestamp indicating the user's last login time. Default is None.\n        change (relationship): Relationship attribute linking this user to change requests initiated by the user.\n    \"\"\"\n\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    email = Column(String(256), nullable=False, unique=True)\n    password = Column(String, nullable=False)\n\n    first_name = Column(String(256), nullable=True)\n    last_name = Column(String(256), nullable=True)\n\n    is_verified_email = Column(Boolean, default=False)\n    is_active = Column(Boolean, default=False)\n    is_superuser = Column(Boolean, default=False)\n\n    # TODO add unittest and check the default role is 'user', also move role to permissions table\n    role = Column(String(5), default=\"user\")\n\n    date_joined = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, nullable=True, onupdate=func.now())\n    last_login = Column(DateTime, nullable=True)\n\n    change = relationship(\"UserVerification\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n\n\nclass UserVerification(FastModel):\n    \"\"\"\n    UserVerification represents change requests initiated by users, such as email or phone number changes,\n    that require OTP verification.\n\n    Attributes:\n        id (int): Unique identifier for the verification request.\n        user_id (int): ID of the user who initiated the verification request.\n        request_type (str): Indicates the type of verification request (register /reset-password /change-email\n        /change-phone).\n        new_email (str): New email address requested by the user.\n        new_phone (str): New phone number requested by the user.\n        active_access_token (str, optional): Last valid access token used for JWT authentication. Default is None.\n        created_at (datetime): Timestamp indicating when the verification request was created.\n        updated_at (datetime): Timestamp indicating when the verification request was last updated.\n    \"\"\"\n\n    __tablename__ = \"users_verifications\"\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), unique=True)\n\n    request_type = Column(String, nullable=True)\n    new_email = Column(String(256), nullable=True)\n    new_phone = Column(String(256), nullable=True)\n    active_access_token = Column(String, nullable=True)\n\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n    user = relationship(\"User\", back_populates=\"change\")\n"}
{"type": "source_file", "path": "apps/accounts/services/user.py", "content": "from fastapi import HTTPException\nfrom starlette import status\n\nfrom apps.accounts.models import User\nfrom apps.accounts.services.password import PasswordManager\nfrom apps.core.date_time import DateTime\n\n\nclass UserManager:\n\n    @classmethod\n    def create_user(cls, email: str, password: str, first_name: str | None = None, last_name: str | None = None,\n                    is_verified_email: bool = False, is_active: bool = False, is_superuser: bool = False,\n                    role: str = 'user', updated_at: DateTime = None, last_login: DateTime = None):\n        user_data = {\n            \"email\": email,\n            \"password\": PasswordManager.hash_password(password),\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"is_verified_email\": is_verified_email,\n            \"is_active\": is_active,\n            \"is_superuser\": is_superuser,\n            \"role\": role,\n            \"updated_at\": updated_at,\n            \"last_login\": last_login\n        }\n        user = User.create(**user_data)\n        return user\n\n    @staticmethod\n    def get_user(user_id: int | None = None, email: str = None) -> User | None:\n        \"\"\"\n        Retrieve a user based on their ID or email address.\n\n        Args:\n            user_id (int | None): The ID of the user to retrieve. Defaults to None.\n            email (str | None): The email address of the user to retrieve. Defaults to None.\n\n        Returns:\n            User | None: A User object if a user is found based on the provided ID or email,\n                         or None if no user is found.\n        \"\"\"\n        if user_id:\n            user = User.get(user_id)\n        elif email:\n            user = User.filter(User.email == email).first()\n        else:\n            return None\n\n        if user is None:\n            return None\n\n        return user\n\n    @staticmethod\n    def get_user_or_404(user_id: int | None = None, email: str = None):\n        user: User | None = None\n        if user_id:\n            user = User.get_or_404(user_id)\n        elif email:\n            user = User.filter(User.email == email).first()\n            if not user:\n                raise HTTPException(status_code=404, detail=\"User not found.\")\n\n        return user\n\n    @classmethod\n    def update_user(cls, user_id: int, email: str | None = None, password: str | None = None,\n                    first_name: str | None = None, last_name: str | None = None, is_verified_email: bool | None = None,\n                    is_active: bool | None = None, is_superuser: bool | None = None, role: str | None = None,\n                    last_login: DateTime | None = None):\n        \"\"\"\n        Update a user by their ID.\n        \"\"\"\n\n        user_data = {}\n\n        if first_name is not None:\n            user_data[\"first_name\"] = first_name\n\n        if last_name is not None:\n            user_data[\"last_name\"] = last_name\n\n        if email is not None:\n            user_data[\"email\"] = email\n\n        if password is not None:\n            user_data[\"password\"] = PasswordManager.hash_password(password)\n\n        if is_verified_email is not None:\n            user_data[\"is_verified_email\"] = is_verified_email\n\n        if is_active is not None:\n            user_data[\"is_active\"] = is_active\n\n        if is_superuser is not None:\n            user_data[\"is_superuser\"] = is_superuser\n\n        if role is not None:\n            user_data[\"role\"] = role\n\n        if last_login is not None:\n            user_data[\"last_login\"] = last_login\n\n        return User.update(user_id, **user_data)\n\n    @classmethod\n    def update_last_login(cls, user_id: int):\n        \"\"\"\n        Update user's last login.\n        \"\"\"\n        User.update(user_id, last_login=DateTime.now())\n\n    @staticmethod\n    def to_dict(user: User):\n        \"\"\"\n        Convert a User object to a dictionary.\n        \"\"\"\n        _dict = {\n            'user_id': user.id,\n            'email': user.email,\n            'first_name': user.first_name,\n            'last_name': user.last_name,\n            'is_verified_email': user.is_verified_email,\n            'date_joined': DateTime.string(user.date_joined),\n            'updated_at': DateTime.string(user.updated_at),\n            'last_login': DateTime.string(user.last_login)\n        }\n        return _dict\n\n    @classmethod\n    def new_user(cls, **user_data):\n        return User.create(**user_data)\n\n    @staticmethod\n    def is_active(user: User):\n        if not user.is_active:\n            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Inactive user.\")\n\n    @staticmethod\n    def is_verified_email(user: User):\n        if not user.is_verified_email:\n            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN,\n                                detail=\"Pleas verify your email address to continue.\")\n        # TODO guide user to follow the steps need to verify email address.\n"}
{"type": "source_file", "path": "apps/accounts/services/token.py", "content": "from datetime import timedelta, datetime\n\nfrom fastapi import HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom pyotp import TOTP\n\nfrom apps.accounts.models import User, UserVerification\nfrom apps.accounts.services.user import UserManager\nfrom config.settings import AppConfig\n\n\nclass TokenService:\n    \"\"\"\n    Manage \"jwt-token\" or \"otp-token\" that used for authentication.\n    \"\"\"\n\n    user: User | None\n    user_id: int\n\n    app_config = AppConfig.get_config()\n\n    ALGORITHM = \"HS256\"\n    oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"accounts/login\")\n    credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,\n                                          detail=\"Could not validate credentials.\",\n                                          headers={\"WWW-Authenticate\": \"Bearer\"})\n\n    def __init__(self, user: int | User | None = None):\n        if user is not None:\n            if isinstance(user, User):\n                self.user = user\n                self.user_id = user.id\n            else:\n                self.user = None\n                self.user_id = user\n\n    # --------------------\n    # --- Access Token ---\n    # --------------------\n\n    \"\"\"\n    Utility class for handling JWT authentication and access tokens.\n\n    A user's access token will be expired due to actions such as \"resetting the password,\" \"changing the password,\" or\n    even \"logging out\" (logout mechanism).\n\n    The `access-token` stored in the database serves as a flag for the logout mechanism, ensuring that when a user\n    wants to log out of the system, the current token will no longer be valid.\n    \"\"\"\n\n    def create_access_token(self) -> str:\n        \"\"\"\n        Create a new access token for the provided user.\n\n        Returns:\n            str: Access token string.\n        \"\"\"\n\n        # --- set data to encode ---\n        to_encode = {'user_id': self.user_id}\n\n        # --- set expire date ---\n        to_encode.update({\"exp\": datetime.utcnow() + timedelta(self.app_config.access_token_expire_minutes)})\n\n        # --- generate access token ---\n        access_token = jwt.encode(to_encode, self.app_config.secret_key, algorithm=self.ALGORITHM)\n\n        self.update_access_token(access_token)\n        return access_token\n\n    def update_access_token(self, token: str):\n        UserVerification.update(UserVerification.filter(UserVerification.user_id == self.user_id).first().id,\n                                active_access_token=token)\n\n    def reset_access_token(self):\n        UserVerification.update(UserVerification.filter(UserVerification.user_id == self.user_id).first().id,\n                                active_access_token=None)\n\n    @classmethod\n    async def fetch_user(cls, token: str) -> User:\n        \"\"\"\n        Retrieve the user associated with the provided JWT token.\n\n        Args:\n            token (str): JWT token.\n\n        Returns:\n            User: User object if the token is valid, raises HTTPException if not.\n        \"\"\"\n\n        # --- validate token ---\n        try:\n            payload = jwt.decode(token, cls.app_config.secret_key, algorithms=[cls.ALGORITHM])\n        except JWTError as e:\n            raise cls.credentials_exception\n\n        # --- validate payloads in token ---\n        user_id = payload.get(\"user_id\")\n        if user_id is None:\n            raise cls.credentials_exception\n\n        # --- get user ---\n        # TODO move user data to token and dont fetch them from database\n        user = UserManager.get_user(user_id)\n        if user is None:\n            raise cls.credentials_exception\n\n        UserManager.is_active(user)\n\n        # --- validate access token ---\n        active_access_token = UserVerification.filter(UserVerification.user_id == user_id).first().active_access_token\n        if token != active_access_token:\n            raise cls.credentials_exception\n\n        UserManager.is_active(user)\n        return user\n\n    # -----------------\n    # --- OTP Token ---\n    # -----------------\n\n    @classmethod\n    def create_otp_token(cls):\n        totp = TOTP(cls.app_config.otp_secret_key, interval=cls.app_config.otp_expire_seconds)\n        return totp.now()\n\n    def request_is_register(self):\n        \"\"\"\n        Will be used just when a new user is registered.\n        \"\"\"\n\n        UserVerification.create(user_id=self.user_id, request_type='register')\n\n    def get_new_email(self):\n        _change: UserVerification = UserVerification.filter(UserVerification.user_id == self.user_id).first()\n        if _change.request_type == 'change-email':\n            return _change.new_email\n        return False\n\n    def request_is_change_email(self, new_email: str):\n        _change = UserVerification.filter(UserVerification.user_id == self.user_id).first().id\n        UserVerification.update(_change, new_email=new_email, request_type='change-email')\n\n    def reset_is_change_email(self):\n        _change = UserVerification.filter(UserVerification.user_id == self.user_id).first().id\n        UserVerification.update(_change, new_email=None, request_type=None)\n\n    def reset_is_reset_password(self):\n        _change = UserVerification.filter(UserVerification.user_id == self.user_id).first().id\n        UserVerification.update(_change, request_type='reset-password')\n\n    def reset_otp_token_type(self):\n        \"\"\"\n        Remove the request_type for otp token by set it to None.\n        \"\"\"\n\n        _change = UserVerification.filter(UserVerification.user_id == self.user_id).first().id\n        UserVerification.update(_change, request_type=None)\n\n    def get_otp_request_type(self):\n        return UserVerification.filter(UserVerification.user_id == self.user_id).first().request_type\n\n    @classmethod\n    def validate_otp_token(cls, token: str):\n        totp = TOTP(cls.app_config.otp_secret_key, interval=cls.app_config.otp_expire_seconds)\n        return totp.verify(token)\n\n    @classmethod\n    def check_time_remaining(cls):\n        totp = TOTP(cls.app_config.otp_secret_key, interval=cls.app_config.otp_expire_seconds)\n        time_remaining = int(totp.interval - datetime.now().timestamp() % totp.interval)\n        if time_remaining != 0:\n            # OTP has not expired, do not resend\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"OTP not expired. Resend available in {time_remaining} seconds.\")\n"}
{"type": "source_file", "path": "apps/accounts/faker/__init__.py", "content": ""}
{"type": "source_file", "path": "apps/accounts/schemas.py", "content": "from fastapi import HTTPException, status\nfrom pydantic import BaseModel, EmailStr, field_validator, model_validator\n\nfrom apps.accounts.services.password import PasswordManager\n\n\nclass ValidatePasswordInSchema(BaseModel):\n    password: str\n    password_confirm: str\n\n    @field_validator(\"password\")\n    def validate_password(cls, password: str):\n        return PasswordManager.validate_password_strength(password=password, has_special_char=False)\n\n    @model_validator(mode=\"after\")\n    def passwords_match(self):\n        if self.password != self.password_confirm:\n            raise HTTPException(\n                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n                detail='Passwords do not match!')\n        return self\n\n\n# ------------------------\n# --- Register Schemas ---\n# ------------------------\n\nclass RegisterIn(ValidatePasswordInSchema):\n    email: EmailStr\n\n    @staticmethod\n    def examples():\n        examples = {\n            'openapi_examples': {\n                \"default\": {\n                    \"summary\": \"Default\",\n                    \"value\": {\n                        \"email\": \"user@example.com\",\n                        \"password\": \"string\",\n                        \"password_confirm\": \"string\"\n                    },\n                },\n                \"with-email\": {\n                    \"summary\": \"Register a new user with email verification (OTP)\",\n                    \"description\": \"\"\"\n\n> `email:\"user@example.com\"` The unique email address of the user. Attempting to assign the same email address to users\nreturns an error.\n> \n>`password:\"<Password1>\"` The password.\n> \n> `password:\"<Password1>\"` The password that's confirmed.  \n    \nFor a valid password you should:\n* Use numbers _**0-9**_ in the password.\n* Use lowercase characters _**a-z**_ in the password.\n* Use uppercase characters _**A-Z**_ in the password.\n* **Optional:** Use special characters __!?@#$%^&*()+{}[]<>/__ in the password.\"\"\",\n                    \"value\": {\n                        \"email\": \"user@example.com\",\n                        \"password\": \"NewPassword123\",\n                        \"password_confirm\": \"NewPassword123\"\n                    },\n                }\n            }\n        }\n        return examples\n\n\nclass RegisterOut(BaseModel):\n    email: EmailStr\n    message: str\n\n\nclass RegisterVerifyIn(BaseModel):\n    email: EmailStr\n    otp: str\n\n\nclass RegisterVerifyOut(BaseModel):\n    access_token: str\n    message: str\n\n\n# --------------------\n# --- Login Schemas ---\n# --------------------\nclass LoginOut(BaseModel):\n    access_token: str\n    token_type: str\n\n\n# ------------------------\n# --- Password Schemas ---\n# ------------------------\n\nclass PasswordResetIn(BaseModel):\n    email: EmailStr\n\n\nclass PasswordResetOut(BaseModel):\n    message: str\n\n\nclass PasswordResetVerifyIn(ValidatePasswordInSchema):\n    email: EmailStr\n    otp: str\n\n\nclass PasswordResetVerifyOut(BaseModel):\n    message: str\n\n\nclass PasswordChangeIn(ValidatePasswordInSchema):\n    current_password: str\n\n    @staticmethod\n    def examples():\n        examples = {\n            'openapi_examples': {\n                \"valid\": {\n                    \"summary\": \"Valid Password\",\n                    \"description\": \"\"\"For a valid password you should:\n* Use numbers _**0-9**_ in the password.\n* Use lowercase characters _**a-z**_ in the password.\n* Use uppercase characters _**A-Z**_ in the password.\n* **Optional:** Use special characters __!?@#$%^&*()+{}[]<>/__ in the password.\n                        \"\"\",\n                    \"value\": {\n                        \"current_password\": \"Password123\",\n                        \"password\": \"NewPassword123\",\n                        \"password_confirm\": \"NewPassword123\"\n                    },\n                }\n            }}\n        return examples\n\n\nclass PasswordChangeOut(BaseModel):\n    message: str\n\n\n# -------------------\n# --- OTP Schemas ---\n# -------------------\n\nclass OTPResendIn(BaseModel):\n    request_type: str\n    email: EmailStr\n\n    @field_validator(\"request_type\")\n    def validate_request_type(cls, value):\n        allowed_request_types = {\"register\", \"reset-password\", \"change-email\"}\n        if value not in allowed_request_types:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid request type. Allowed values are 'register', 'reset-password', 'change-email'.\")\n        return value\n\n    @staticmethod\n    def examples():\n        examples = {\n            'openapi_examples': {\n                \"default\": {\n                    \"summary\": \"Default\",\n                    \"description\": \"\"\"\n- `request_type`: Specifies the purpose of the OTP request. Allowed values are \"register\", \"reset-password\", \n  or \"change-email\".\n- `email`: The user's primary email address.\n\"\"\",\n                    \"value\": {\n                        \"request_type\": \"string\",\n                        \"email\": \"user@example.com\"\n                    },\n                },\n                \"register\": {\n                    \"summary\": \"Resend OTP for User Registration\",\n                    \"value\": {\n                        \"request_type\": \"register\",\n                        \"email\": \"user@example.com\"\n                    },\n                },\n                \"reset-password\": {\n                    \"summary\": \"Resend OTP for Password Reset\",\n                    \"value\": {\n                        \"request_type\": \"reset-password\",\n                        \"email\": \"user@example.com\"\n                    },\n                },\n                \"change-email\": {\n                    \"summary\": \"Resend OTP for Email Change\",\n                    \"value\": {\n                        \"request_type\": \"change-email\",\n                        \"email\": \"user@example.com\"\n                    },\n                },\n            }\n        }\n        return examples\n\n\n# ----------------------------\n# --- Change-Email Schemas ---\n# ----------------------------\n\nclass EmailChangeIn(BaseModel):\n    new_email: EmailStr\n\n\nclass EmailChangeOut(BaseModel):\n    message: str\n\n\nclass EmailChangeVerifyIn(BaseModel):\n    otp: str\n\n\nclass EmailChangeVerifyOut(BaseModel):\n    message: str\n\n\n# --------------------\n# --- User Schemas ---\n# --------------------\n\n\nclass UserSchema(BaseModel):\n    user_id: int\n    email: EmailStr\n    first_name: str | None\n    last_name: str | None\n    is_verified_email: bool\n    date_joined: str\n    updated_at: str\n    last_login: str\n\n\nclass CurrentUserOut(BaseModel):\n    user: UserSchema\n\n\nclass UpdateUserSchema(BaseModel):\n    first_name: str | None\n    last_name: str | None\n\n\nclass UpdateUserIn(BaseModel):\n    user: UpdateUserSchema\n"}
{"type": "source_file", "path": "apps/accounts/services/password.py", "content": "import re\n\nfrom fastapi import HTTPException\nfrom passlib.context import CryptContext\nfrom starlette import status\n\n\nclass PasswordManager:\n    password_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n    min_length: int = 8\n    max_length: int = 24\n\n    @classmethod\n    def validate_password_strength(cls, password: str, has_number: bool = True, has_lowercase: bool = True,\n                                   has_uppercase: bool = True, has_special_char: bool = True) -> str:\n        \"\"\"\n        Validate a password based on the given constraints.\n\n        Args:\n            password: The password to validate.\n            has_number: Use numbers (0-9) in the password.\n            has_lowercase: Use lowercase characters (a-z) in the password.\n            has_uppercase: Use uppercase characters (A-Z) in the password.\n            has_special_char: Use special characters (!@#$%^&*()_+{}[]:;\"\\'<>.,.?/|) in the password.\n\n        Returns:\n            The validated password, or raises a HTTPException if the password is invalid.\n        \"\"\"\n\n        cls.__validate_length(password)\n\n        if has_number:\n            cls.__validate_pattern(password,\n                                   r'[0-9]', 'Invalid password. Must contain at least one number (0-9).')\n\n        if has_uppercase:\n            cls.__validate_pattern(password, r'[A-Z]',\n                                   'Invalid password. Must contain at least one uppercase letter (A-Z).')\n\n        if has_lowercase:\n            cls.__validate_pattern(password, r'[a-z]',\n                                   'Invalid password. Must contain at least one lowercase letter (a-z).')\n\n        if has_special_char:\n            cls.__validate_pattern(password, r'[!@#$%^&*()_+{}\\[\\]:;\"\\'<>,.?/\\\\|]',\n                                   'Invalid password. Must contain at least one special character.')\n\n        return password\n\n    @classmethod\n    def __validate_length(cls, password: str):\n        if len(password) < cls.min_length or len(password) > cls.max_length:\n            raise HTTPException(\n                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n                detail=f'Invalid password length. Must be between {cls.min_length} and {cls.max_length} characters.'\n            )\n\n    @classmethod\n    def __validate_pattern(cls, password: str, pattern: str, message: str):\n        if not re.search(pattern, password):\n            raise HTTPException(\n                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n                detail=message\n            )\n\n    # ---------------------\n    # --- Hash Password ---\n    # ---------------------\n\n    @classmethod\n    def hash_password(cls, password: str):\n        return cls.password_context.hash(password)\n\n    @classmethod\n    def verify_password(cls, plain_password: str, hashed_password: str):\n        return cls.password_context.verify(plain_password, hashed_password)\n"}
{"type": "source_file", "path": "apps/__init__.py", "content": ""}
{"type": "source_file", "path": "apps/accounts/__init__.py", "content": ""}
{"type": "source_file", "path": "apps/accounts/faker/data.py", "content": "from faker import Faker\n\nfrom apps.accounts.services.authenticate import AccountService\nfrom apps.accounts.services.token import TokenService\nfrom apps.accounts.services.user import UserManager\n\n\nclass BaseFakeAccount:\n    fake = Faker()\n    password = 'Test_1234'\n\n    @classmethod\n    def random_email(cls):\n        return cls.fake.email()\n\n\nclass FakeAccount(BaseFakeAccount):\n    \"\"\"\n    Populates the database with fake accounts.\n    \"\"\"\n\n    @classmethod\n    def register_unverified(cls):\n        \"\"\"\n        Register a new user and get the OTP code.\n        \"\"\"\n\n        # --- register a user ---\n        register_payload = {\n            \"email\": cls.random_email(),\n            \"password\": cls.password\n        }\n        AccountService.register(**register_payload)\n\n        # --- read otp code ---\n        user = UserManager.get_user(email=register_payload['email'])\n\n        return user.email, TokenService.create_otp_token()\n\n    @classmethod\n    def verified_registration(cls):\n        \"\"\"\n        Registered a new user and verified their OTP code.\n        \"\"\"\n\n        # --- register a user ---\n        register_payload = {\n            \"email\": cls.random_email(),\n            \"password\": cls.password\n        }\n        AccountService.register(**register_payload)\n\n        # --- read otp code ---\n        user = UserManager.get_user(email=register_payload['email'])\n        verified = AccountService.verify_registration(**{'email': user.email,\n                                                         'otp': TokenService.create_otp_token()})\n        return user, verified['access_token']\n\n\nclass FakeUser(BaseFakeAccount):\n\n    @classmethod\n    def populate_members(cls):\n        \"\"\"\n        Create an admin and a user.\n        \"\"\"\n\n        # --- admin ---\n        user, access_token = FakeAccount.verified_registration()\n        user_data = {\n            'email': 'admin@example.com',\n            'first_name': cls.fake.first_name(),\n            'last_name': cls.fake.last_name(),\n            'is_superuser': True,\n            'role': 'admin'\n        }\n\n        UserManager.update_user(user.id, **user_data)\n\n        # --- user ---\n        user, access_token = FakeAccount.verified_registration()\n        user_data = {\n            'email': 'user@example.com',\n            'first_name': cls.fake.first_name(),\n            'last_name': cls.fake.last_name()\n        }\n\n        UserManager.update_user(user.id, **user_data)\n\n    @classmethod\n    def populate_admin(cls):\n        \"\"\"\n        Create an admin and generate an access token too.\n        \"\"\"\n\n        user, access_token = FakeAccount.verified_registration()\n        user_data = {\n            'first_name': cls.fake.first_name(),\n            'last_name': cls.fake.last_name(),\n            'is_superuser': True,\n            'role': 'admin'\n        }\n\n        user = UserManager.update_user(user.id, **user_data)\n        return user, access_token\n\n    @classmethod\n    def populate_user(cls):\n        \"\"\"\n        Create a new user and generate an access token too.\n        \"\"\"\n\n        user, access_token = FakeAccount.verified_registration()\n        user_data = {\n            'first_name': cls.fake.first_name(),\n            'last_name': cls.fake.last_name()\n        }\n\n        user = UserManager.update_user(user.id, **user_data)\n        return user, access_token\n"}
{"type": "source_file", "path": "apps/accounts/services/permissions.py", "content": "from fastapi import HTTPException, status, Depends\n\nfrom apps.accounts.models import User\nfrom apps.accounts.services.authenticate import AccountService\n\n\nclass Permission:\n    @classmethod\n    async def is_admin(cls, current_user: User = Depends(AccountService.current_user)):\n        if current_user.role != 'admin':\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"You don't have permission to access this resource.\")\n"}
{"type": "source_file", "path": "apps/attributes/__init__.py", "content": ""}
{"type": "source_file", "path": "alembic/env.py", "content": "from logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\nfrom apps.products.models import FastModel\n\ntarget_metadata = FastModel.metadata\n\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "apps/attributes/models.py", "content": "from sqlalchemy import Column, ForeignKey, Integer, String, UniqueConstraint\nfrom sqlalchemy.orm import relationship\n\nfrom config.database import FastModel\n\n\nclass Attribute(FastModel):\n    __tablename__ = \"attributes\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(255), unique=True, nullable=False)\n\n    items = relationship(\"AttributeItem\", back_populates=\"attribute\", cascade=\"all, delete-orphan\")\n\n\nclass AttributeItem(FastModel):\n    __tablename__ = \"attribute_items\"\n\n    id = Column(Integer, primary_key=True)\n    attribute_id = Column(Integer, ForeignKey(\"attributes.id\"))\n    item = Column(String(255), nullable=False)\n\n    __table_args__ = (UniqueConstraint('attribute_id', 'item'),)\n    attribute = relationship(\"Attribute\", back_populates=\"items\")\n"}
{"type": "source_file", "path": "apps/accounts/services/authenticate.py", "content": "from fastapi import HTTPException, status, Depends\nfrom fastapi.security import OAuth2PasswordBearer\n\nfrom apps.accounts.models import User\nfrom apps.accounts.services.password import PasswordManager\nfrom apps.accounts.services.token import TokenService\nfrom apps.accounts.services.user import UserManager\nfrom apps.core.date_time import DateTime\nfrom apps.core.services.email_manager import EmailService\n\n\nclass AccountService:\n\n    @classmethod\n    async def current_user(cls, token: str = Depends(OAuth2PasswordBearer(tokenUrl=\"accounts/login\"))) -> User:\n        user = await TokenService.fetch_user(token)\n        return user\n\n    # ----------------\n    # --- Register ---\n    # ----------------\n\n    @classmethod\n    def register(cls, email: str, password: str):\n        \"\"\"\n        Create a new user and send an email with OTP code.\n        \"\"\"\n\n        # check if user with the given email is exist or not.\n        if UserManager.get_user(email=email):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"This email has already been taken.\"\n            )\n\n        new_user = UserManager.create_user(email=email, password=password)\n        TokenService(new_user.id).request_is_register()\n        EmailService.register_send_verification_email(new_user.email)\n\n        return {'email': new_user.email,\n                'message': 'Please check your email for an OTP code to confirm your email address.'}\n\n    @classmethod\n    def verify_registration(cls, email: str, otp: str):\n        \"\"\"\n        Verifies user registration by validating the provided OTP code.\n\n        For first-time users, they must validate their email address before being able to \"login\".\n        After validation, their account will be activated, allowing them to \"login\" and use the app.\n\n        During verification, the email address is validated using an OTP code. Upon successful verification,\n        the user's data is updated, the account is activated, and the user can \"login\" to the app.\n        Additionally, an `access_token` is sent to allow the user to \"login\" without being redirected to the login form.\n\n        Args:\n            email (str): User's email address.\n            otp (str): One-Time Password (OTP) code for email verification.\n\n        Raises:\n            HTTPException: If the user is not found, the email is already verified, or an invalid OTP is provided.\n\n        Returns:\n            dict: Dictionary containing an authentication token and a success message.\n        \"\"\"\n\n        # --- get user by email ---\n        user = UserManager.get_user(email=email)\n        if not user:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"User not found.\"\n            )\n\n        # --- check email verified or not ---\n        if user.is_verified_email:\n            raise HTTPException(\n                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n                detail=\"This email is already verified.\"\n            )\n\n        # --- validate otp_token for this user ---\n        token = TokenService(user=user)\n\n        if not token.validate_otp_token(otp):\n            raise HTTPException(\n                status_code=status.HTTP_406_NOT_ACCEPTABLE,\n                detail=\"Invalid OTP code. Please double-check and try again.\"\n            )\n\n        # --- Update user data and activate the account ---\n        UserManager.update_user(user.id, is_verified_email=True, is_active=True, last_login=DateTime.now())\n\n        token.reset_otp_token_type()\n\n        return {'access_token': token.create_access_token(),\n                'message': 'Your email address has been confirmed. Account activated successfully.'}\n\n    # -------------\n    # --- Login ---\n    # -------------\n\n    @classmethod\n    def login(cls, email: str, password: str):\n        \"\"\"\n        Login with given email and password.\n        \"\"\"\n\n        user = cls.authenticate_user(email, password)\n        token: TokenService = TokenService(user)\n\n        if not user:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Incorrect username or password.\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n\n        if not user.is_active:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Inactive account.\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n\n        if not user.is_verified_email:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Unverified email address.\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n\n        UserManager.update_last_login(user.id)\n        return {\"access_token\": token.create_access_token(), \"token_type\": \"bearer\"}\n\n    @classmethod\n    def authenticate_user(cls, email: str, password: str):\n        user = UserManager.get_user(email=email)\n        if not user:\n            return False\n        if not PasswordManager.verify_password(password, user.password):\n            return False\n        return user\n\n    # ----------------------\n    # --- Reset Password ---\n    # ----------------------\n\n    @classmethod\n    def reset_password(cls, email: str):\n        \"\"\"\n        Reset password by user email address.\n        \"\"\"\n        # TODO stop resend email until current otp not expired\n        user: User | None\n\n        user = UserManager.get_user_or_404(email=email)\n        UserManager.is_active(user)\n        UserManager.is_verified_email(user)\n\n        token = TokenService(user.id)\n        token.reset_is_reset_password()\n\n        EmailService.reset_password_send_verification_email(user.email)\n\n        return {'message': 'Please check your email for an OTP code to confirm the password reset request.'}\n\n    @classmethod\n    def verify_reset_password(cls, email: str, password: str, otp: str):\n        \"\"\"\n        Verify the request for reset password and if otp is valid then current access-token will expire.\n        \"\"\"\n\n        user = UserManager.get_user_or_404(email=email)\n        token = TokenService(user.id)\n\n        if not token.validate_otp_token(otp):\n            raise HTTPException(\n                status_code=status.HTTP_406_NOT_ACCEPTABLE,\n                detail=\"Invalid OTP code.Please double-check and try again.\"\n            )\n\n        UserManager.update_user(user.id, password=password)\n        token.reset_otp_token_type()\n        token.reset_access_token()\n        # TODO send an email and notice user the password is changed.\n\n        return {'message': 'Your password has been changed.'}\n\n    @classmethod\n    def change_password(cls, user: User, current_password: str, password: str):\n        \"\"\"\n        Change password for current user, and then current access-token will be expired.\n        \"\"\"\n\n        if not PasswordManager.verify_password(current_password, user.password):\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Incorrect password.\")\n\n        UserManager.update_user(user.id, password=password)\n        TokenService(user.id).reset_access_token()\n\n        return {'message': 'Your password has been changed.'}\n\n    @classmethod\n    def change_email(cls, user, new_email):\n        \"\"\"\n        Change password for current user.\n        \"\"\"\n\n        # Check if the new email address is not already associated with another user\n        if UserManager.get_user(email=new_email) is None:\n\n            TokenService(user.id).request_is_change_email(new_email)\n            EmailService.change_email_send_verification_email(new_email)\n\n        else:\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"This email has already been taken.\")\n\n        return {\n            'message': f'Please check your email \"{new_email}\" for an OTP code to confirm the change email request.'}\n\n    @classmethod\n    def verify_change_email(cls, user, otp):\n        \"\"\"\n        Verify change password for current user.\n        \"\"\"\n\n        token = TokenService(user.id)\n\n        if token.validate_otp_token(otp):\n            new_email = token.get_new_email()\n\n            if new_email:\n                UserManager.update_user(user.id, email=new_email)\n                token.reset_is_change_email()\n            else:\n                raise HTTPException(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    detail=\"Invalid request for email verification.\")\n        else:\n            raise HTTPException(\n                status_code=status.HTTP_406_NOT_ACCEPTABLE,\n                detail=\"Invalid OTP code. Please double-check and try again.\")\n\n        return {'message': 'Your email is changed.'}\n\n    @classmethod\n    def resend_otp(cls, request_type: str, email: str):\n        \"\"\"\n        Resend OTP for registration, password reset, or email change verification.\n        \"\"\"\n\n        user = UserManager.get_user_or_404(email=email)\n        token = TokenService(user.id)\n\n        # --- validate current request type ---\n        current_request_type = token.get_otp_request_type()\n        if current_request_type != request_type:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Current requested type is invalid.\")\n\n        if current_request_type == 'change_email':\n            email = token.get_new_email()\n\n        # --- resend new OTP ---\n        token.check_time_remaining()\n        match request_type:\n            case 'register':\n                EmailService.register_send_verification_email(email)\n            case 'change-email':\n                EmailService.change_email_send_verification_email(email)\n            case 'reset-password':\n                EmailService.reset_password_send_verification_email(email)\n\n    @classmethod\n    def logout(cls, current_user):\n        TokenService(current_user).reset_access_token()\n\n# TODO add a sessions service to manage sections like telegram app (Devices).\n"}
{"type": "source_file", "path": "apps/accounts/routers.py", "content": "from fastapi import APIRouter, status, Depends, Body\nfrom fastapi.security import OAuth2PasswordRequestForm\n\nfrom apps.accounts import schemas\nfrom apps.accounts.services.authenticate import AccountService\nfrom apps.accounts.services.permissions import Permission\nfrom apps.accounts.services.user import User, UserManager\n\nrouter = APIRouter(\n    prefix='/accounts'\n)\n\n\n# ------------------------\n# --- Register Routers ---\n# ------------------------\n\n\n@router.post(\n    '/register',\n    status_code=status.HTTP_201_CREATED,\n    response_model=schemas.RegisterOut,\n    summary='Register a new user',\n    description=\"\"\"## Register a new user by email and password, then send an OTP code to the user's email address.\n    \nGenerate an account activation code for a user whose account is not yet enabled.\n\nThe account activation code generated by this endpoint is designed for one-time use and will expire after 5 minutes. \nIf a new POST request is made to this endpoint, a new code will be generated if the previous code has expired. The newly\n generated code will be valid for another 5 minutes, while the previous code will no longer be valid.\n\nFollowing the registration request, this endpoint will send an OTP code to the user's email address. It is essential to \nverify this OTP code using the `/accounts/register/verify` endpoint. Verification confirms the user's email address and \nactivates their account.\n \nPlease note that users cannot log in to their accounts until their email addresses are verified.\n\"\"\",\n    tags=['Authentication'])\nasync def register(payload: schemas.RegisterIn = Body(**schemas.RegisterIn.examples())):\n    return AccountService.register(**payload.model_dump(exclude={\"password_confirm\"}))\n\n\n@router.patch(\n    '/register/verify',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.RegisterVerifyOut,\n    summary='Verify user registration',\n    description='Verify a new user registration by confirming the provided OTP.',\n    tags=['Authentication'])\nasync def verify_registration(payload: schemas.RegisterVerifyIn):\n    return AccountService.verify_registration(**payload.model_dump())\n\n\n# ---------------------\n# --- Login Routers ---\n# ---------------------\n\n\n@router.post(\n    '/login',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.LoginOut,\n    summary='Login a user',\n    description='Login a user with valid credentials, if user account is active.',\n    tags=['Authentication'])\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    return AccountService.login(form_data.username, form_data.password)\n\n\n@router.post(\n    '/logout',\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary='Logout user',\n    description=\"Logout the currently authenticated user. \"\n                \"Revokes the user's access token and invalidates the session.\",\n    tags=['Authentication'])\nasync def logout(current_user: User = Depends(AccountService.current_user)):\n    AccountService.logout(current_user)\n\n\n# ------------------------\n# --- Password Routers ---\n# ------------------------\n\n\n@router.post(\n    '/reset-password',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.PasswordResetOut,\n    summary='Reset password',\n    description=\"Initiate a password reset request by sending a verification email to the user's \"\n                \"registered email address.\",\n    tags=['Authentication'])\nasync def reset_password(payload: schemas.PasswordResetIn):\n    return AccountService.reset_password(**payload.model_dump())\n\n\n@router.patch(\n    '/reset-password/verify',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.PasswordResetVerifyOut,\n    summary='Verify reset password',\n    description=\"Verify the password reset request by confirming the provided OTP sent to the user's \"\n                \"registered email address. If the change is successful, the user will need to login again.\",\n    tags=['Authentication'])\nasync def verify_reset_password(payload: schemas.PasswordResetVerifyIn):\n    return AccountService.verify_reset_password(**payload.model_dump(exclude={\"password_confirm\"}))\n\n\n# -------------------\n# --- OTP Routers ---\n# -------------------\n\n\n@router.post(\n    '/otp',\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary='Resend OTP',\n    description=\"\"\"Allows the user to request a new OTP (One-Time Password) for registration, password reset,\n    or email change verification.\n\n### Usage Guidelines:\n- For **registration** and **password reset**, provide the user's **primary email address**.\n- For **email change**, provide the **primary email address** too, (not the new unverified email).\n    \"\"\",\n\n    tags=['Authentication'])\nasync def resend_otp(payload: schemas.OTPResendIn = Body(**schemas.OTPResendIn.examples())):\n    AccountService.resend_otp(**payload.model_dump())\n\n\n# ---------------------\n# --- Users Routers ---\n# ---------------------\n\n\n@router.get(\n    '/me',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.CurrentUserOut,\n    summary='Retrieve current user',\n    description='Retrieve current user if user is active.',\n    tags=['Users'])\nasync def retrieve_me(current_user: User = Depends(AccountService.current_user)):\n    return {'user': UserManager.to_dict(current_user)}\n\n\n@router.put(\n    '/me',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.CurrentUserOut,\n    summary='Update current user',\n    description='Update current user.',\n    tags=['Users'])\nasync def update_me(payload: schemas.UpdateUserSchema, current_user: User = Depends(AccountService.current_user)):\n    user = UserManager.update_user(current_user.id, **payload.model_dump())\n    return {'user': UserManager.to_dict(user)}\n\n\n@router.patch(\n    '/me/password',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.PasswordChangeOut,\n    summary='Change current user password',\n    description='Change the password for the current user. If the change is successful, the user will '\n                'need to login again.',\n    tags=['Users'])\nasync def change_password(payload: schemas.PasswordChangeIn = Body(**schemas.PasswordChangeIn.examples()),\n                          current_user: User = Depends(AccountService.current_user)):\n    return AccountService.change_password(current_user, **payload.model_dump(exclude={\"password_confirm\"}))\n\n\n@router.post(\n    '/me/email',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.EmailChangeOut,\n    summary='Change current user email',\n    description=\"\"\"## Change the email address for the current user.\n\nAfter the new email is set, an OTP code will be sent to the new email address for verification purposes.\n\"\"\",\n    tags=['Users'])\nasync def change_email(email: schemas.EmailChangeIn, current_user: User = Depends(AccountService.current_user)):\n    return AccountService.change_email(current_user, **email.model_dump())\n\n\n@router.patch(\n    '/me/email/verify',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.EmailChangeVerifyOut,\n    summary='Verify change current user email',\n    description=\"\"\"## Verify the email address change for the current user.\n\nValidating the OTP code sent to the user's new email address. If the OTP is valid, the new\nemail address will be saved as the user's main email address.\n\"\"\",\n    tags=['Users'])\nasync def verify_change_email(otp: schemas.EmailChangeVerifyIn,\n                              current_user: User = Depends(AccountService.current_user)):\n    return AccountService.verify_change_email(current_user, **otp.model_dump())\n\n\n@router.get(\n    '/{user_id}',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.CurrentUserOut,\n    summary='Retrieve a single user',\n    description='Retrieve a single user by ID. Only admins can read the users data.',\n    tags=['Users'],\n    dependencies=[Depends(Permission.is_admin)]\n)\nasync def retrieve_user(user_id: int):\n    return {'user': UserManager.to_dict(UserManager.get_user(user_id))}\n\n# TODO DELETE /accounts/me\n# TODO add docs and examples to endpoints\n"}
{"type": "source_file", "path": "apps/attributes/routers.py", "content": "# from fastapi import APIRouter, status\n#\n# # create the path operations for a module using APIRouter,\n# # You can think of APIRouter as a \"mini FastAPI\" class.\n# router = APIRouter(\n#     prefix=\"/attributes\",\n#     tags=[\"Attribute\"],\n# )\n#\n#\n# @router.post(\n#     \"/\",\n#     # summary=\"Create a new attribute\",\n#     # description=\"Create a new attribute.\",\n#     # response_description=\"The created attribute\",\n#     # response_model=AttributeOut,\n#     # status_code=status.HTTP_201_CREATED,\n# )\n# async def create_attribute():\n#     return \"hi\"\n"}
{"type": "source_file", "path": "apps/products/faker/data.py", "content": "import os\nimport random\n\nfrom faker import Faker\nfrom faker.providers import lorem\nfrom fastapi import UploadFile\n\nfrom apps.demo.settings import DEMO_PRODUCTS_MEDIA_DIR, DEMO_DOCS_DIR, DEMO_LARGE_DIR\nfrom apps.products.models import Product\nfrom apps.products.services import ProductService\n\n\nclass FakeProduct:\n    \"\"\"\n    Populates the database with fake products.\n    \"\"\"\n\n    fake = Faker()\n\n    options = ['color', 'size', 'material', 'Style']\n    option_color_items = ['red', 'green', 'black', 'blue', 'yellow']\n    option_size_items = ['S', 'M', 'L', 'XL', 'XXL']\n    option_material_items = ['Cotton', 'Nylon', 'Plastic', 'Wool', 'Leather']\n    option_style_items = ['Casual', 'Formal']\n\n    def fill_products(self):\n        \"\"\"\n        For generating fake products as demo.\n        \"\"\"\n        self.fake.add_provider(lorem)\n\n    @classmethod\n    def generate_name(cls):\n        return cls.fake.text(max_nb_chars=25)\n\n    @classmethod\n    def generate_description(cls):\n        return cls.fake.paragraph(nb_sentences=5)\n\n    @staticmethod\n    def get_random_price():\n        return round(random.uniform(1, 100), 2)\n\n    @staticmethod\n    def get_random_stock():\n        return random.randint(0, 100)\n\n    @classmethod\n    def generate_uniq_options(cls):\n        return [\n            {\n                \"option_name\": \"color\",\n                \"items\": cls.option_color_items[:2]\n            },\n            {\n                \"option_name\": \"size\",\n                \"items\": cls.option_size_items[:2]\n            },\n            {\n                \"option_name\": \"material\",\n                \"items\": cls.option_material_items[:2]\n            }\n        ]\n\n    @classmethod\n    def get_payload(cls):\n        payload = {\n            'product_name': cls.generate_name(),\n            'description': cls.generate_description(),\n            'status': 'active',\n            'price': cls.get_random_price(),\n            'stock': cls.get_random_stock()\n        }\n        return payload.copy()\n\n    @classmethod\n    def get_payload_with_options(cls):\n        payload = {\n            'product_name': cls.generate_name(),\n            'description': cls.generate_description(),\n            'status': 'active',\n            'price': cls.get_random_price(),\n            'stock': cls.get_random_stock(),\n            'options': cls.generate_uniq_options()\n        }\n        return payload.copy()\n\n    @classmethod\n    def populate_product(cls) -> tuple[dict[str, str | int], Product]:\n        \"\"\"\n        Crete a product without options.\n        \"\"\"\n\n        product_data = cls.get_payload()\n        return product_data.copy(), ProductService.create_product(product_data, get_obj=True)\n\n    @classmethod\n    def populate_product_with_options(cls, get_product_obj=True) -> tuple[dict[str, str | int], Product | dict]:\n        \"\"\"\n        Crete a product with options. (with all fields)\n        \"\"\"\n\n        product_data = cls.get_payload_with_options()\n        return product_data.copy(), ProductService.create_product(product_data, get_obj=get_product_obj)\n\n    @classmethod\n    async def populate_product_with_media(cls):\n        payload: dict\n        product: Product\n\n        # --- create a product ---\n        payload, product = cls.populate_product()\n        payload['alt'] = 'Test Alt Text'\n\n        # --- get demo images ---\n        upload = FakeMedia.populate_images_for_product(upload_file=True, product_id=product.id)\n\n        # --- attach media to product ---\n        media = ProductService.create_media(product.id, payload['alt'], upload)\n        if media:\n            return payload, product\n\n    @classmethod\n    async def populate_product_with_options_media(cls):\n        \"\"\"\n        Crete a product with options and attach some media to it.\n        \"\"\"\n\n        payload: dict\n        product: Product\n\n        # --- create a product ---\n        payload, product = cls.populate_product_with_options()\n        payload['alt'] = 'Test Alt Text'\n\n        # --- get demo images ---\n        upload = FakeMedia.populate_images_for_product(upload_file=True, product_id=product.id)\n\n        # --- attach media to product ---\n        media = ProductService.create_media(product.id, payload['alt'], upload)\n        if media:\n            return payload, product\n\n    @classmethod\n    async def populate_30_products(cls):\n\n        # --- create 12 products with media ---\n        # TODO generate random options for variable-products\n        for i in range(6):\n            await cls.populate_product_with_options_media()\n        for i in range(6):\n            await cls.populate_product_with_media()\n\n        # --- create 18 products without media ---\n        for i in range(9):\n            cls.populate_product()\n        for i in range(9):\n            cls.populate_product_with_options()\n\n\nclass FakeMedia:\n    product_demo_dir = f'{DEMO_PRODUCTS_MEDIA_DIR}'\n\n    @classmethod\n    def populate_images_for_product(cls, upload_file=False, product_id: int = 1):\n        \"\"\"\n        Attach some media (images) just to a product.\n\n        Read some image file in `.jpg` format from this directory:\n        `/apps/demo/products/{number}` (you can replace your files in the dir)\n        \"\"\"\n\n        directory_path = f'{DEMO_PRODUCTS_MEDIA_DIR}/{product_id}'\n        file_paths = []\n        upload = []\n\n        if os.path.isdir(directory_path):\n            for filename in os.listdir(directory_path):\n                if filename.endswith(\".jpg\"):\n                    file_path = os.path.join(directory_path, filename)\n                    file_paths.append(file_path)\n\n                    for_upload = UploadFile(filename=filename, file=open(file_path, \"rb\"))\n                    upload.append(for_upload)\n\n        else:\n            raise FileNotFoundError(f\"{DEMO_PRODUCTS_MEDIA_DIR}\")\n\n        if upload_file:\n            return upload\n        return file_paths\n\n    @classmethod\n    def populate_docs_file(cls, upload_file=False):\n        docs_path = f'{DEMO_DOCS_DIR}/'\n        file_paths = []\n        upload = []\n\n        if os.path.isdir(docs_path):\n            file_path = os.path.join(docs_path, 'test.txt')\n            file_paths.append(file_path)\n\n            for_upload = UploadFile(filename='test.txt', file=open(file_path, \"rb\"))\n            upload.append(for_upload)\n        else:\n            raise FileNotFoundError(f\"{DEMO_PRODUCTS_MEDIA_DIR}\")\n        if upload_file:\n            return upload\n        return file_paths\n\n    @classmethod\n    def populate_large_file(cls, upload_file=False):\n        docs_path = f'{DEMO_LARGE_DIR}/'\n        file_paths = []\n        upload = []\n\n        if os.path.isdir(docs_path):\n            file_path = os.path.join(docs_path, 'large.png')\n            file_paths.append(file_path)\n\n            for_upload = UploadFile(filename='large.png', file=open(file_path, \"rb\"))\n            upload.append(for_upload)\n        else:\n            raise FileNotFoundError(f\"{DEMO_PRODUCTS_MEDIA_DIR}\")\n        if upload_file:\n            return upload\n        return file_paths\n"}
{"type": "source_file", "path": "apps/core/services/__init__.py", "content": ""}
{"type": "source_file", "path": "apps/demo/__init__.py", "content": ""}
{"type": "source_file", "path": "apps/demo/settings.py", "content": "from pathlib import Path\n\nDEMO_PRODUCTS_MEDIA_DIR = Path(__file__).resolve().parent / \"media/products\"\nDEMO_DOCS_DIR = Path(__file__).resolve().parent / \"media/docs\"\nDEMO_LARGE_DIR = Path(__file__).resolve().parent / \"media/large_file\"\n"}
{"type": "source_file", "path": "config/routers.py", "content": "import importlib\nimport logging\nimport os\nfrom pathlib import Path\n\n\nclass RouterManager:\n    \"\"\"\n    A utility class for managing FastAPI routers.\n\n    This class detects and imports FastAPI routers from 'routers.py' files in\n    the subdirectories of the 'apps' directory. It allows you to easily include\n    routers in your FastAPI application.\n\n    Attributes:\n        None\n\n    Methods:\n        import_routers():\n            Detects 'routers.py' files in subdirectories of the 'apps' directory\n            and imports the 'router' variable from each file.\n\n    Example Usage:\n        router_manager = RouterManager()\n\n        # Import routers from detected 'routers.py' files\n        router_manager.import_routers()\n    \"\"\"\n\n    def __init__(self, app):\n        self.script_directory = os.path.dirname(os.path.abspath(__file__))\n        self.project_root = Path(self.script_directory).parent\n        self.app = app\n\n    def import_routers(self):\n        apps_directory = self.project_root / \"apps\"\n\n        for app_dir in apps_directory.iterdir():\n            if app_dir.is_dir():\n                routers_file = app_dir / \"routers.py\"\n                if routers_file.exists():\n                    module_name = f\"apps.{app_dir.name}.routers\"\n                    try:\n                        module = importlib.import_module(module_name)\n                        if hasattr(module, \"router\"):\n                            # Add the imported router to your FastAPI application\n                            self.app.include_router(module.router)\n                    except ImportError as e:\n                        # Log the ImportError message for debugging purposes\n                        logging.error(f\"Error importing module {module_name}: {e}\")\n"}
{"type": "source_file", "path": "config/settings.py", "content": "import os\nfrom pathlib import Path\n\nfrom dotenv import load_dotenv\nfrom pydantic import BaseModel, EmailStr\n\nload_dotenv()  # Load variables from .env file\n\n\nclass AppConfig:\n    \"\"\"\n    App Configuration.\n    \"\"\"\n\n    class _AppConfig(BaseModel):\n        app_name: str\n        secret_key: str\n        access_token_expire_minutes: int\n        otp_secret_key: str\n        otp_expire_seconds: int\n\n    config = _AppConfig(\n        app_name=os.getenv(\"APP_NAME\"),\n        secret_key=os.getenv(\"SECRET_KEY\"),\n        access_token_expire_minutes=int(os.getenv(\"ACCESS_TOKEN_EXPIRE_MINUTES\")),\n        otp_secret_key=os.getenv(\"OTP_SECRET_KEY\"),\n        otp_expire_seconds=int(os.getenv(\"OTP_EXPIRE_SECONDS\")), )\n\n    @classmethod\n    def get_config(cls) -> _AppConfig:\n        \"\"\"\n        Get the App configuration.\n        \"\"\"\n\n        return cls.config\n\n\nclass EmailServiceConfig:\n    \"\"\"\n    SMTP Configuration.\n    \"\"\"\n\n    class _SMTPConfig(BaseModel):\n        smtp_server: str\n        smtp_port: int\n        smtp_username: EmailStr\n        smtp_password: str\n        use_local_fallback: bool\n\n    config = _SMTPConfig(\n        smtp_server=os.getenv(\"SMTP_SERVER\"),\n        smtp_port=int(os.getenv(\"SMTP_PORT\")),\n        smtp_username=os.getenv(\"SMTP_USERNAME\"),\n        smtp_password=os.getenv(\"SMTP_PASSWORD\"),\n        use_local_fallback=os.getenv(\"USE_LOCAL_FALLBACK\", \"False\").lower() == \"true\"\n    )\n\n    @classmethod\n    def get_config(cls) -> _SMTPConfig:\n        \"\"\"\n        Get the SMTP configuration\n        \"\"\"\n\n        return cls.config\n\n\n# -------------------------\n# --- Database Settings ---\n# -------------------------\n\n# DATABASES = {\n#     \"drivername\": \"postgresql\",\n#     \"username\": \"\",\n#     \"password\": \"\",\n#     \"host\": \"localhost\",\n#     \"database\": \"\",\n#     \"port\": 5432\n# }\nDATABASES = {\n    \"drivername\": \"sqlite\",\n    \"database\": \"fast_store.db\"\n}\n\n# ----------------------\n# --- Media Settings ---\n# ----------------------\n\nBASE_DIR = Path(__file__).resolve().parent.parent\nMEDIA_DIR = BASE_DIR / \"media\"\n\n# Ensure the \"media\" directory exists\nMEDIA_DIR.mkdir(parents=True, exist_ok=True)\n\n# int number as MB\nMAX_FILE_SIZE = 5\nproducts_list_limit = 12\n\n# TODO add settings to limit register new user or close register\n"}
{"type": "source_file", "path": "apps/core/services/email_manager.py", "content": "import smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\nfrom pytest_is_running import is_running\n\nfrom apps.accounts.services.token import TokenService\nfrom config.settings import EmailServiceConfig, AppConfig\n\n\nclass EmailService:\n    config = EmailServiceConfig.get_config()\n    app = AppConfig.get_config()\n\n    @classmethod\n    def __send_email(cls, subject: str, body: str, to_address: str):\n        try:\n            message = MIMEMultipart()\n            message['From'] = cls.config.smtp_username\n            message['To'] = to_address\n            message['Subject'] = subject\n            message.attach(MIMEText(body, 'plain'))\n\n            # Connect to the SMTP server\n            with smtplib.SMTP_SSL(cls.config.smtp_server, cls.config.smtp_port) as server:\n                # server.set_debuglevel(1)\n                server.login(cls.config.smtp_username, cls.config.smtp_password)\n                server.sendmail(cls.config.smtp_username, to_address, message.as_string())\n                # server.quit()\n        except Exception as e:\n            print(f\"An error occurred while sending email: {e}\")\n\n    @classmethod\n    def __print_test_otp(cls, otp: str):\n        dev_show = f\"--- Testing OTP: {otp} ---\"\n        print(dev_show)\n\n    @classmethod\n    def __send_verification_email(cls, subject, body, to_address):\n        \"\"\"\n        Sends a verification email or prints OTP in testing mode.\n        \"\"\"\n\n        if is_running() or cls.config.use_local_fallback:\n            cls.__print_test_otp(TokenService.create_otp_token())\n        else:\n            cls.__send_email(subject, body, to_address)\n\n    @classmethod\n    def register_send_verification_email(cls, to_address):\n        \"\"\"\n        Sends a verification email for the registration process.\n        \"\"\"\n\n        otp = TokenService.create_otp_token()\n        subject = 'Email Verification'\n        body = f\"Thank you for registering with {cls.app.app_name}!\\n\\n\" \\\n               f\"To complete your registration, please enter the following code: {otp}\\n\\n\" \\\n               f\"If you didn't register, please ignore this email.\"\n        cls.__send_verification_email(subject, body, to_address)\n\n    @classmethod\n    def reset_password_send_verification_email(cls, to_address):\n        \"\"\"\n        Sends a verification email for the password reset process.\n        \"\"\"\n\n        otp = TokenService.create_otp_token()\n        subject = 'Password Reset Verification'\n        body = f\"We received a request to reset your {cls.app.app_name} password.\\n\\n\" \\\n               f\"Please enter the following code to reset your password: {otp}\\n\\n\" \\\n               f\"If you didn't request this, you can ignore this email.\"\n        cls.__send_verification_email(subject, body, to_address)\n\n    @classmethod\n    def change_email_send_verification_email(cls, new_email: str):\n        \"\"\"\n        Sends a verification email for the email change process.\n        \"\"\"\n\n        otp = TokenService.create_otp_token()\n        subject = 'Email Change Verification'\n        body = f\"We received a request to change the email associated with your {cls.app.app_name} account.\\n\\n\" \\\n               f\"To confirm this change, please enter the following code: {otp}\\n\\n\" \\\n               f\"If you didn't request this, please contact our support team.\"\n        cls.__send_verification_email(subject, body, new_email)\n"}
{"type": "source_file", "path": "config/database.py", "content": "import importlib\nimport os\nfrom operator import and_\nfrom pathlib import Path\n\nfrom fastapi import HTTPException\nfrom sqlalchemy import create_engine, URL, MetaData\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import sessionmaker, Session, Query\n\nfrom . import settings\n\ntesting = False\n\n\nclass DatabaseManager:\n    \"\"\"\n    A utility class for managing database operations using SQLAlchemy.\n\n    The DatabaseManager simplifies the process of initializing and managing database connections, creating database\n    tables based on SQLAlchemy models, and providing a session for performing database operations.\n\n    Attributes:\n        engine (Engine): The SQLAlchemy engine for the configured database.\n        session (Session): The SQLAlchemy session for database interactions.\n\n    Methods:\n        __init__():\n            Initializes the DatabaseManager by creating an SQLAlchemy engine and a session based on the\n            specified database configuration from the 'settings' module.\n\n        create_database_tables():\n            Detects 'models.py' files in subdirectories of the 'apps' directory and creates corresponding\n            database tables based on SQLAlchemy models.\n\n    Example Usage:\n        db_manager = DatabaseManager()\n\n        # Create database tables for all detected models\n        db_manager.create_database_tables()\n\n    Example Usage2:\n        DatabaseManager().create_database_tables()\n    \"\"\"\n    engine: create_engine = None\n    session: Session = None\n\n    @classmethod\n    def __init__(cls):\n        \"\"\"\n        Initializes the DatabaseManager.\n\n        This method creates an SQLAlchemy engine and a session based on the specified database configuration\n        from the 'settings' module.\n        \"\"\"\n        global testing  # Access the global testing flag\n        db_config = settings.DATABASES.copy()\n        if testing:\n            db_config[\"database\"] = \"test_\" + db_config[\"database\"]\n\n        if db_config[\"drivername\"] == \"sqlite\":\n            project_root = Path(__file__).parent.parent  # Assuming this is where your models are located\n            db_config[\"database\"] = os.path.join(project_root, db_config[\"database\"])\n\n            url = URL.create(**db_config)\n            cls.engine = create_engine(url, connect_args={\"check_same_thread\": False})\n        else:\n            # for postgres\n            cls.engine = create_engine(URL.create(**db_config))\n\n        session = sessionmaker(autocommit=False, autoflush=False, bind=cls.engine)\n        cls.session = session()\n\n    @classmethod\n    def create_test_database(cls):\n        \"\"\"\n        Create and configure a test database for use in tests.\n        \"\"\"\n\n        # Set the testing flag to True\n        global testing\n        testing = True\n\n        # Reinitialize the DatabaseManager for testing\n        cls.__init__()\n        DatabaseManager.create_database_tables()\n\n    @classmethod\n    def drop_all_tables(cls):\n        \"\"\"\n        Drop all tables in the current database.\n        \"\"\"\n        # TODO drop tables for postgres too\n        if cls.engine:\n            metadata = MetaData()\n            metadata.reflect(bind=cls.engine)\n            for table_name, table in metadata.tables.items():\n                table.drop(cls.engine)\n\n    @classmethod\n    def create_database_tables(cls):\n        \"\"\"\n        Create database tables based on SQLAlchemy models.\n\n        This method detects 'models.py' files in subdirectories of the 'apps'\n        directory and creates corresponding database tables based on SQLAlchemy\n        models defined within those files.\n\n        Returns:\n            None\n        \"\"\"\n        script_directory = os.path.dirname(os.path.abspath(__file__))\n        project_root = Path(script_directory).parent\n        apps_directory = project_root / \"apps\"\n\n        for app_dir in apps_directory.iterdir():\n            if app_dir.is_dir():\n                models_file = app_dir / \"models.py\"\n                if models_file.exists():\n                    module_name = f\"apps.{app_dir.name}.models\"\n                    try:\n                        module = importlib.import_module(module_name)\n                        if hasattr(module, \"FastModel\") and hasattr(module.FastModel, \"metadata\"):\n                            module.FastModel.metadata.create_all(bind=cls.engine)\n                    except ImportError:\n                        pass\n\n    @classmethod\n    def get_testing_mode(cls):\n        return testing\n\n\nclass FastModel(DeclarativeBase):\n    \"\"\"\n    A base class for creating SQLAlchemy ORM models with built-in CRUD operations.\n\n    This class provides a foundation for defining SQLAlchemy models with common\n    database operations like creating, updating, and querying records. It simplifies\n    database interactions while ensuring proper session management.\n\n    DeclarativeBase: The SQLAlchemy declarative base class from which this model inherits.\n\n    Class Methods:\n        __eq__(column, value):\n            Override the equality operator to create filter conditions for querying.\n\n        create(**kwargs):\n            Create a new instance of the model, add it to the database, and commit the transaction.\n\n        filter(condition):\n            Retrieve records from the database based on a given filter condition.\n\n    Example Usage:\n        class Product(FastModel):\n            ...\n\n        # Create a new product\n        new_product = Product.create(product_name=\"Example Product\", ...)\n\n        # Filter products based on a condition\n        active_products = Product.filter(Product.status == \"active\")\n    \"\"\"\n\n    # TODO update FastModel methods\n\n    @classmethod\n    def __eq__(cls, **kwargs):\n        filter_conditions = [getattr(cls, key) == value for key, value in kwargs.items()]\n        return and_(*filter_conditions) if filter_conditions else True\n\n    @classmethod\n    def create(cls, **kwargs):\n        \"\"\"\n        Create a new instance of the model, add it to the database, and commit the transaction.\n\n        Args:\n            **kwargs: Keyword arguments representing model attributes.\n\n        Returns:\n            The newly created model instance.\n        \"\"\"\n\n        instance = cls(**kwargs)\n        session = DatabaseManager.session\n        try:\n            session.add(instance)\n            session.commit()\n            session.refresh(instance)\n        except Exception:\n            session.rollback()\n            raise\n        finally:\n            session.close()\n        return instance\n\n    @classmethod\n    def filter(cls, condition):\n        \"\"\"\n        Retrieve records from the database based on a given filter condition.\n\n        Args:\n            condition: SQLAlchemy filter condition.\n\n        Returns:\n            List of model instances matching the filter condition.\n        \"\"\"\n\n        with DatabaseManager.session as session:\n            query: Query = session.query(cls).filter(condition)\n        return query\n\n    @classmethod\n    def get(cls, pk):\n        \"\"\"\n        Retrieve a record by its primary key.\n\n        Args:\n            pk: The primary key value of the record to retrieve.\n\n        Returns:\n            The model instance with the specified primary key, or None if not found\n        \"\"\"\n        with DatabaseManager.session as session:\n            instance = session.get(cls, pk)\n        return instance\n\n    @classmethod\n    def get_or_404(cls, pk):\n        \"\"\"\n        Retrieve a record by its primary key or raise a 404 HTTPException if not found.\n\n        Args:\n            pk: The primary key value of the record to retrieve.\n\n        Returns:\n            The model instance with the specified primary key.\n\n        Raises:\n            HTTPException(404): If the record is not found.\n        \"\"\"\n        with DatabaseManager.session as session:\n            instance = session.get(cls, pk)\n            if not instance:\n                raise HTTPException(status_code=404, detail=f\"{cls.__name__} not found\")\n        return instance\n\n    @classmethod\n    def update(cls, pk, **kwargs):\n        \"\"\"\n        Update a record by its primary key.\n\n        Args:\n            pk: The primary key value of the record to update.\n            **kwargs: Keyword arguments representing model attributes to update.\n\n        Returns:\n            The updated model instance.\n\n        Raises:\n            HTTPException(404): If the record is not found.\n        \"\"\"\n        with DatabaseManager.session as session:\n\n            # Retrieve the object by its primary key or raise a 404 exception\n            # instance = session.query(cls).get(pk)\n            instance = session.get(cls, pk)\n            if not instance:\n                raise HTTPException(status_code=404, detail=f\"{cls.__name__} not found\")\n\n            # Update the instance attributes based on the provided kwargs\n            for key, value in kwargs.items():\n                setattr(instance, key, value)\n\n            try:\n                # Commit the transaction and refresh the instance\n                session.commit()\n                session.refresh(instance)\n            except Exception:\n                session.rollback()\n                raise\n        return instance\n\n    @staticmethod\n    def delete(instance):\n\n        with DatabaseManager.session as session:\n\n            # destroy\n            session.delete(instance)\n\n            try:\n                # Commit the transaction and refresh the instance\n                session.commit()\n            except Exception:\n                session.rollback()\n                raise\n"}
{"type": "source_file", "path": "apps/products/__init__.py", "content": ""}
{"type": "source_file", "path": "apps/products/routers.py", "content": "\"\"\"\n**Product Definition: Variable Products**\n\nIn our system, every product is considered a variable product.\nVariable products encapsulate all product variations, streamlining the entire process.\nWhether you create a product without any specified options or define up to three distinct options, each with a\nsingle item, you are essentially working with a variable product.\n\n\n**Product Variants and Options**\n\n- **Variants:**\nProducts can have multiple variants, each representing a unique combination of attributes like price, stock, and other\n specifications.\n\n- **Options:**\nProducts may feature up to three distinct options. Each option can have multiple items, allowing fora rich variety of\n choices.\n\n\n**Simplified Product Management:**\n\nAll operations related to products, such as managing shopping carts, processing orders, and handling stock,\n are performed through product variants. This streamlined approach enhances efficiency and simplifies product\n handling across the platform.\n\nEvery time we create product, the media should be None, because the Media after creating a product will be\nattached to it.\n\"\"\"\n\nfrom fastapi import APIRouter, status, Form, UploadFile, File, HTTPException, Query, Path, Depends\nfrom fastapi import Request\nfrom fastapi.responses import JSONResponse\n\nfrom apps.accounts.services.permissions import Permission\nfrom apps.core.services.media import MediaService\nfrom apps.products import schemas\nfrom apps.products.services import ProductService\n\nrouter = APIRouter(\n    prefix=\"/products\"\n)\n\n\n# -----------------------\n# --- Product Routers ---\n# -----------------------\n\n\n@router.post(\n    '/',\n    status_code=status.HTTP_201_CREATED,\n    response_model=schemas.CreateProductOut,\n    summary='Create a new product',\n    description='Create a new product.',\n    tags=[\"Product\"],\n    dependencies=[Depends(Permission.is_admin)])\nasync def create_product(request: Request, product: schemas.CreateProductIn):\n    return {'product': ProductService(request).create_product(product.model_dump())}\n\n\n@router.get(\n    '/{product_id}',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.RetrieveProductOut,\n    summary='Retrieve a single product',\n    description=\"Retrieve a single product.\",\n    tags=[\"Product\"])\nasync def retrieve_product(request: Request, product_id: int):\n    # TODO user can retrieve products with status of (active , archived)\n    # TODO fix bug if there are not product in database\n    product = ProductService(request).retrieve_product(product_id)\n    return {\"product\": product}\n\n\n@router.get(\n    '/',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.ListProductOut,\n    summary='Retrieve a list of products',\n    description='Retrieve a list of products.',\n    tags=[\"Product\"])\nasync def list_produces(request: Request):\n    # TODO permission: admin users (admin, is_admin), none-admin users\n    # TODO as none-admin permission, list products that they status is `active`.\n    # TODO as none-admin, dont list the product with the status of `archived` and `draft`.\n    # TODO only admin can list products with status `draft`.\n    products = ProductService(request).list_products()\n    if products:\n        return {'products': products}\n    return JSONResponse(\n        content=None,\n        status_code=status.HTTP_204_NO_CONTENT\n    )\n\n\n@router.put(\n    '/{product_id}',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.UpdateProductOut,\n    summary='Updates a product',\n    description='Updates a product.',\n    tags=[\"Product\"],\n    dependencies=[Depends(Permission.is_admin)])\nasync def update_product(request: Request, product_id: int, payload: schemas.UpdateProductIn):\n    # TODO permission: only admin\n    # TODO update a product with media\n\n    updated_product_data = {}\n    payload = payload.model_dump()\n\n    for key, value in payload.items():\n        if value is not None:\n            updated_product_data[key] = value\n\n    try:\n        updated_product = ProductService(request).update_product(product_id, **updated_product_data)\n        return {'product': updated_product}\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n\n\n@router.delete(\n    '/{product_id}',\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary='Deletes an existing product',\n    description='Deletes an existing product.',\n    tags=['Product'],\n    dependencies=[Depends(Permission.is_admin)])\nasync def delete_product(product_id: int):\n    ProductService.delete_product(product_id)\n\n\n# -------------------------------\n# --- Product-Variant Routers ---\n# -------------------------------\n\n\n@router.put(\n    '/variants/{variant_id}',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.UpdateVariantOut,\n    summary='Updates an existing product variant',\n    description='Modify an existing Product Variant.',\n    tags=['Product Variant'],\n    dependencies=[Depends(Permission.is_admin)])\nasync def update_variant(variant_id: int, payload: schemas.UpdateVariantIn):\n    update_data = {}\n\n    for key, value in payload.model_dump().items():\n        if value is not None:\n            update_data[key] = value\n    try:\n        updated_variant = ProductService.update_variant(variant_id, **update_data)\n        return {'variant': updated_variant}\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n\n\n@router.get(\n    '/variants/{variant_id}',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.RetrieveVariantOut,\n    summary='Retrieve a single product variant',\n    description='Retrieves a single product variant.',\n    tags=['Product Variant'])\nasync def retrieve_variant(variant_id: int):\n    return {'variant': ProductService.retrieve_variant(variant_id)}\n\n\n@router.get(\n    '/{product_id}/variants',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.ListVariantsOut,\n    summary='Retrieves a list of product variants',\n    description='Retrieves a list of product variants.',\n    tags=['Product Variant'])\nasync def list_variants(product_id: int):\n    return {'variants': ProductService.retrieve_variants(product_id)}\n\n\n# -----------------------------\n# --- Product-Media Routers ---\n# -----------------------------\n\"\"\"\nwhen updating a product, actions on product's images are:\n- add new images to product: mean attach new images to an existing product, this is the same as `create_product_media()`\n- delete some images for product: mean unattached images from a product\n\"\"\"\n\n\n@router.post(\n    '/{product_id}/media',\n    status_code=status.HTTP_201_CREATED,\n    response_model=schemas.CreateProductMediaOut,\n    summary=\"Create a new product image\",\n    description=\"Create a new product image.\",\n    tags=['Product Image'],\n    dependencies=[Depends(Permission.is_admin)])\nasync def create_product_media(request: Request, x_files: list[UploadFile] = File(), product_id: int = Path(),\n                               alt: str | None = Form(None)):\n    # check the file size and type\n    for file in x_files:\n        MediaService.is_allowed_extension(file)\n        await MediaService.is_allowed_file_size(file)\n\n    media = ProductService(request).create_media(product_id=product_id, alt=alt, files=x_files)\n    return {'media': media}\n\n\n@router.get(\n    '/media/{media_id}',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.RetrieveMediaOut,\n    summary='Retrieve a single product image',\n    description='Get a single product image by id.',\n    tags=['Product Image'])\nasync def retrieve_single_media(request: Request, media_id: int):\n    return {'media': ProductService(request).retrieve_single_media(media_id)}\n\n\n@router.get(\n    '/{product_id}/media',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.RetrieveProductMediaOut,\n    summary=\"Receive a list of all Product Images\",\n    description=\"Receive a list of all Product Images.\",\n    tags=['Product Image'])\nasync def list_product_media(request: Request, product_id: int):\n    media = ProductService(request).retrieve_media_list(product_id=product_id)\n    if media:\n        return {'media': media}\n    return JSONResponse(\n        content=None,\n        status_code=status.HTTP_204_NO_CONTENT\n    )\n\n\n@router.put(\n    '/media/{media_id}',\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.UpdateMediaOut,\n    summary='Updates an existing image',\n    description='Updates an existing image.',\n    tags=['Product Image'],\n    dependencies=[Depends(Permission.is_admin)])\nasync def update_media(request: Request, media_id: int, file: UploadFile = File(), alt: str | None = Form(None)):\n    update_data = {}\n\n    if file is not None:\n        update_data['file'] = file\n\n    if alt is not None:\n        update_data['alt'] = alt\n\n    try:\n        updated_media = ProductService(request).update_media(media_id, **update_data)\n        return {'media': updated_media}\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n\n\n@router.delete(\n    '/{product_id}/media',\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary='Delete image from a product',\n    description='Delete image from a product.',\n    tags=['Product Image'],\n    dependencies=[Depends(Permission.is_admin)])\nasync def delete_product_media(product_id: int, media_ids: str = Query(...)):\n    media_ids_list = list(map(int, media_ids.split(',')))\n    ProductService.delete_product_media(product_id, media_ids_list)\n\n\n@router.delete(\n    '/media/{media_id}',\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary='Delete a media file',\n    description='Delete a media file.',\n    tags=['Product Image'],\n    dependencies=[Depends(Permission.is_admin)])\nasync def delete_media_file(media_id: int):\n    ProductService.delete_media_file(media_id)\n"}
{"type": "source_file", "path": "apps/products/models.py", "content": "from sqlalchemy import Column, ForeignKey, Integer, String, UniqueConstraint, Text, DateTime, func, Numeric\nfrom sqlalchemy.orm import relationship\n\nfrom config.database import FastModel\n\n\nclass Product(FastModel):\n    __tablename__ = \"products\"\n\n    id = Column(Integer, primary_key=True)\n    product_name = Column(String(255), nullable=False)\n    description = Column(Text, nullable=True)\n\n    # Active: The product is ready to sell and is available to customers on the online store, sales channels, and apps.\n    # Archived: The product is no longer being sold and isn't available to customers on sales channels and apps.\n    # Draft: The product isn't ready to sell and is unavailable to customers on sales channels and apps.\n\n    # status_enum = Enum('active', 'archived', 'draft', name='status_enum')\n    status = Column(String, default='draft')\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, nullable=True)\n    published_at = Column(DateTime, nullable=True)\n\n    options = relationship(\"ProductOption\", back_populates=\"product\", cascade=\"all, delete-orphan\")\n    variants = relationship(\"ProductVariant\", back_populates=\"product\", cascade=\"all, delete-orphan\")\n    media = relationship(\"ProductMedia\", back_populates=\"product\", cascade=\"all, delete-orphan\")\n\n    # TODO add user_id to track which user added this product\n\n\nclass ProductOption(FastModel):\n    __tablename__ = \"product_options\"\n\n    id = Column(Integer, primary_key=True)\n\n    # The foreign key referencing the parent product.\n    product_id = Column(Integer, ForeignKey(\"products.id\"))\n    option_name = Column(String(255), nullable=False)\n\n    __table_args__ = (UniqueConstraint('product_id', 'option_name'),)\n    product = relationship(\"Product\", back_populates=\"options\")\n    option_items = relationship(\"ProductOptionItem\", back_populates=\"product_option\", cascade=\"all, delete-orphan\")\n\n\nclass ProductOptionItem(FastModel):\n    __tablename__ = \"product_option_items\"\n\n    id = Column(Integer, primary_key=True)\n    option_id = Column(Integer, ForeignKey(\"product_options.id\"))\n    item_name = Column(String(255), nullable=False)\n\n    __table_args__ = (UniqueConstraint('option_id', 'item_name'),)\n    product_option = relationship(\"ProductOption\", back_populates=\"option_items\")\n\n\nclass ProductVariant(FastModel):\n    __tablename__ = \"product_variants\"\n\n    id = Column(Integer, primary_key=True)\n    product_id = Column(Integer, ForeignKey(\"products.id\"))\n    price = Column(Numeric(12, 2), default=0)\n    stock = Column(Integer, default=0)\n\n    option1 = Column(Integer, ForeignKey(\"product_option_items.id\"), nullable=True)\n    option2 = Column(Integer, ForeignKey(\"product_option_items.id\"), nullable=True)\n    option3 = Column(Integer, ForeignKey(\"product_option_items.id\"), nullable=True)\n\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, onupdate=func.now())\n\n    # option1 = relationship(\"ProductOptionItem\", foreign_keys=[option1_id])\n    # option2 = relationship(\"ProductOptionItem\", foreign_keys=[option2_id])\n    # option3 = relationship(\"ProductOptionItem\", foreign_keys=[option3_id])\n\n    product = relationship(\"Product\", back_populates=\"variants\")\n\n\nclass ProductMedia(FastModel):\n    __tablename__ = \"product_media\"\n\n    id = Column(Integer, primary_key=True)\n    product_id = Column(Integer, ForeignKey(\"products.id\"))\n\n    # TODO attach image to product variants (optional)\n    # variant_ids = Column(ARRAY(Integer))\n\n    # TODO if set the position to `1` it means this is the main image\n    # position = Column(Integer)\n    alt = Column(String, nullable=True)\n    src = Column(String)\n    type = Column(String)\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, onupdate=func.now())\n\n    product = relationship(\"Product\", back_populates=\"media\")\n"}
{"type": "source_file", "path": "apps/products/faker/__init__.py", "content": ""}
{"type": "source_file", "path": "apps/core/services/media.py", "content": "import os\nimport uuid\nfrom pathlib import Path\n\nfrom fastapi import UploadFile, status, HTTPException\n\nfrom config.database import DatabaseManager\nfrom config.settings import MEDIA_DIR, MAX_FILE_SIZE\n\n\n# TODO set permission to access media-directory and files\nclass MediaService:\n    def __init__(self, parent_directory: str = \"media\", sub_directory: str | int = None):\n        testing = DatabaseManager.get_testing_mode()\n        if not testing:\n            self.path = Path(f\"{MEDIA_DIR}/{parent_directory}/{sub_directory}\" if sub_directory else parent_directory)\n        else:\n            self.path = Path(\n                f\"{MEDIA_DIR}/test/{parent_directory}/{sub_directory}\" if sub_directory else parent_directory)\n        # self.path.mkdir(parents=True, exist_ok=True)\n\n    def save_file(self, file: UploadFile):\n        # TODO separate exceptions to a module in core app\n\n        file_extension = self.get_file_extension(file)\n\n        # Generate a unique filename with a random string and date\n        file_name = self.generate_unique_filename(file.filename)\n        if not os.path.exists(self.path):\n            os.makedirs(self.path, exist_ok=True)\n\n            # for file in files:\n        new_file = os.path.join(self.path, file_name)\n\n        with open(new_file, 'wb') as f:\n            f.write(file.file.read())\n\n        return file_name, file_extension\n\n    def generate_unique_filename(self, filename: str) -> str:\n        random_string = str(uuid.uuid4().hex)\n        file_extension = filename.split('.')[-1]\n        unique_filename = f\"{random_string}.{file_extension}\"\n        return unique_filename\n\n    @staticmethod\n    def get_file_extension(file: UploadFile) -> str:\n        filename_parts = file.filename.split('.')\n        return filename_parts[-1] if len(filename_parts) > 1 else \"\"\n\n    @staticmethod\n    def get_file_size_mb(file: UploadFile) -> float:\n        file_size_bytes = file.file.seek(0, 2)\n        return file_size_bytes / (1024 * 1024)  # Convert to MB\n\n    @staticmethod\n    def is_allowed_extension(file: UploadFile):\n        if file.content_type not in [\"image/jpeg\", \"image/png\", \"image/gif\"]:\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Invalid file type\")\n        return True\n\n    @staticmethod\n    async def is_allowed_file_size(file: UploadFile):\n        file_size_in_bytes = MAX_FILE_SIZE * 1024 * 1024  # MB in bytes\n\n        file_size = len(await file.read())\n        if file_size > file_size_in_bytes:\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,\n                                detail=f\"File size exceeds {file_size_in_bytes}MB limit\")\n\n        # to reset the cursor to the beginning of the file.\n        file.file.seek(0)\n        return True\n\n    def delete_file(self, file_name: str):\n        file_path = os.path.join(self.path, file_name)\n\n        # Attempt to delete the file\n        try:\n            os.remove(file_path)\n            return True  # Return True if the file is successfully deleted\n        except OSError as e:\n            # Handle the case where the file could not be deleted\n            print(f\"Error: {e}\")\n            return False  # Return False if there was an error deleting the file\n"}
{"type": "source_file", "path": "apps/products/schemas.py", "content": "from typing import Annotated, List\n\nfrom fastapi import Query, UploadFile\nfrom pydantic import BaseModel, constr, field_validator, model_validator\n\n\"\"\"\n---------------------------------------\n--------------- Variant ---------------\n---------------------------------------\n\"\"\"\n\n\nclass VariantSchema(BaseModel):\n    variant_id: int\n    product_id: int\n    price: float\n    stock: int\n    option1: int | None\n    option2: int | None\n    option3: int | None\n    created_at: str\n    updated_at: str | None\n\n\nclass UpdateVariantIn(BaseModel):\n    price: float | None = None\n    stock: int | None = None\n\n\nclass UpdateVariantOut(BaseModel):\n    variant: VariantSchema\n\n\nclass RetrieveVariantOut(BaseModel):\n    variant: VariantSchema\n\n\nclass ListVariantsOut(BaseModel):\n    variants: list[VariantSchema]\n\n\n\"\"\"\n---------------------------------------\n--------------- Options ---------------\n---------------------------------------\n\"\"\"\n\n\nclass OptionItemOut(BaseModel):\n    item_id: int\n    item_name: str\n\n\nclass OptionOut(BaseModel):\n    options_id: int\n    option_name: str\n    items: list[OptionItemOut]\n\n\nclass OptionIn(BaseModel):\n    option_name: constr(min_length=1)\n    items: list[str]\n\n    @field_validator('items')\n    def not_empty(cls, value):\n        if value is None or value == []:\n            raise ValueError('items must not be None or empty')\n        return value\n\n\n\"\"\"\n---------------------------------------\n---------------- Media ----------------\n---------------------------------------\n\"\"\"\n\n\nclass ProductMediaSchema(BaseModel):\n    media_id: int\n    product_id: int\n    alt: str\n    src: str\n    type: str\n    updated_at: str | None\n    created_at: str\n\n\nclass CreateProductMediaOut(BaseModel):\n    media: list[ProductMediaSchema]\n\n\nclass CreateProductMediaIn(BaseModel):\n    product_id: int\n    alt: str\n\n\nclass FileUpload(BaseModel):\n    x_file: UploadFile\n\n\nclass MultiFileUpload(BaseModel):\n    files: List[FileUpload]\n    data: CreateProductMediaIn\n\n    class Config:\n        from_attributes = True\n\n\nclass RetrieveProductMediaOut(BaseModel):\n    media: list[ProductMediaSchema] | None = None\n\n\nclass UpdateMediaOut(BaseModel):\n    media: ProductMediaSchema\n\n\nclass RetrieveMediaOut(BaseModel):\n    media: ProductMediaSchema\n\n\n\"\"\"\n---------------------------------------\n--------------- Product ---------------\n---------------------------------------\n\"\"\"\n\n\nclass ProductSchema(BaseModel):\n    product_id: int\n    product_name: Annotated[str, Query(max_length=255)]\n    description: str | None\n    status: str | None\n\n    created_at: str\n    updated_at: str | None\n    published_at: str | None\n\n    options: list[OptionOut] | None\n    variants: list[VariantSchema] | None\n    media: list[ProductMediaSchema] | None = None\n\n\nclass CreateProductOut(BaseModel):\n    product: ProductSchema\n\n    class Config:\n        from_attributes = True\n\n\nclass CreateProductIn(BaseModel):\n    product_name: Annotated[str, Query(max_length=255, min_length=1)]\n    description: str | None = None\n    status: str | None = None\n    price: float = 0\n    stock: int = 0\n\n    options: list[OptionIn] | None = None\n\n    class Config:\n        from_attributes = True\n\n    @field_validator('price')\n    def validate_price(cls, price):\n        if price < 0:\n            raise ValueError('Price must be a positive number.')\n        return price\n\n    @field_validator('stock')\n    def validate_stock(cls, stock):\n        if stock < 0:\n            raise ValueError('Stock must be a positive number.')\n        return stock\n\n    @model_validator(mode='before')\n    def validate_uniqueness(cls, values):\n        options = values.get(\"options\", [])\n        option_name_set = set()\n        items_set = set()\n\n        # each product should have just max 3 options.\n        if len(options) > 3:\n            raise ValueError('The number of options cannot exceed 3.')\n\n        # checking `options-name` and `option-items list` are uniq\n        for option in options:\n            if isinstance(option, dict):\n                option_name = option.get(\"option_name\")\n                items = option.get(\"items\", [])\n                if isinstance(option_name, str):\n                    if option_name in option_name_set:\n                        raise ValueError(f'Duplicate option name found: {option_name}')\n                    option_name_set.add(option_name)\n                    for item in items:\n                        if isinstance(item, str):\n                            if item in items_set:\n                                raise ValueError(f'Duplicate item found in option \"{option_name}\": {item}')\n                            items_set.add(item)\n        return values\n\n\nclass RetrieveProductOut(BaseModel):\n    product: ProductSchema\n\n\nclass ListProductIn(BaseModel):\n    ...\n\n\nclass ListProductOut(BaseModel):\n    products: list[ProductSchema]\n\n\nclass UpdateProductIn(BaseModel):\n    product_name: Annotated[str, Query(max_length=255, min_length=1)] | None = None\n    description: str | None = None\n    status: str | None = None\n\n\nclass UpdateProductOut(BaseModel):\n    product: ProductSchema\n"}
{"type": "source_file", "path": "passenger_wsgi.py", "content": "import imp\nimport os\nimport sys\n\nsys.path.insert(0, os.path.dirname(__file__))\n\nwsgi = imp.load_source('wsgi', 'apps/main.py')\napplication = wsgi.passenger_wsgi.py\n"}
{"type": "source_file", "path": "demo.py", "content": "import asyncio\n\nfrom apps.accounts.faker.data import FakeUser\nfrom apps.products.faker.data import FakeProduct\n\nif __name__ == \"__main__\":\n    from fastapi import FastAPI\n\n    from config.database import DatabaseManager\n    from config.routers import RouterManager\n\n    # init models\n    DatabaseManager().create_database_tables()\n\n    # init FastAPI\n    app = FastAPI()\n\n    # init routers\n    RouterManager(app).import_routers()\n\n    # --- Demo Users ---\n    FakeUser.populate_members()\n\n    # --- Demo Products ---\n    asyncio.run(FakeProduct.populate_30_products())\n"}
{"type": "source_file", "path": "config/__init__.py", "content": ""}
{"type": "source_file", "path": "apps/products/services.py", "content": "from itertools import product as options_combination\n\nfrom fastapi import Request\nfrom sqlalchemy import select, and_, or_\n\nfrom apps.core.date_time import DateTime\nfrom apps.core.services.media import MediaService\nfrom apps.products.models import Product, ProductOption, ProductOptionItem, ProductVariant, ProductMedia\nfrom config import settings\nfrom config.database import DatabaseManager\n\n\nclass ProductService:\n    request: Request | None = None\n    product = None\n    price: int | float\n    stock: int\n    options: list | None = []\n    options_data: list = []\n    variants: list = []\n    media: list | None = None\n\n    @classmethod\n    def __init__(cls, request: Request | None = None):\n        cls.request = request\n\n    @classmethod\n    def create_product(cls, data: dict, get_obj: bool = False):\n\n        cls._create_product(data)\n        cls.__create_product_options()\n        cls.__create_variants()\n\n        if get_obj:\n            return cls.product\n        return cls.retrieve_product(cls.product.id)\n\n    @classmethod\n    def _create_product(cls, data: dict):\n        cls.price = data.pop('price', 0)\n        cls.stock = data.pop('stock', 0)\n        cls.options_data = data.pop('options', [])\n\n        if 'status' in data:\n            # Check if the value is one of the specified values, if not, set it to 'draft'\n            valid_statuses = ['active', 'archived', 'draft']\n            if data['status'] not in valid_statuses:\n                data['status'] = 'draft'\n\n        # create a product\n        cls.product = Product.create(**data)\n\n    @classmethod\n    def __create_product_options(cls):\n        \"\"\"\n        Create new option if it doesn't exist and update its items,\n        and ensures that options are uniq in a product and also items in each option are uniq.\n        \"\"\"\n\n        if cls.options_data:\n            for option in cls.options_data:\n\n                # Creates a new instance of the ProductOption model, adds it to the database,\n                # and commits the transaction. Returns the newly created model instance\n                new_option = ProductOption.create(product_id=cls.product.id, option_name=option['option_name'])\n\n                for item in option['items']:\n                    ProductOptionItem.create(option_id=new_option.id, item_name=item)\n            cls.options = cls.retrieve_options(cls.product.id)\n        else:\n            cls.options = None\n\n    @classmethod\n    def retrieve_options(cls, product_id):\n        \"\"\"\n        Get all options of a product\n        \"\"\"\n\n        product_options = []\n        options = ProductOption.filter(ProductOption.product_id == product_id).all()\n        for option in options:\n            # Retrieves records from the database based on a given filter condition.\n            # Returns a list of model instances matching the filter condition.\n            items = ProductOptionItem.filter(ProductOptionItem.option_id == option.id).all()\n\n            product_options.append({\n                'options_id': option.id,\n                'option_name': option.option_name,\n                'items': [{'item_id': item.id, 'item_name': item.item_name} for item in items]\n            })\n        if product_options:\n            return product_options\n        else:\n            return None\n\n    @classmethod\n    def __create_variants(cls):\n        \"\"\"\n        Create a default variant or create variants by options combination.\n        \"\"\"\n\n        if cls.options:\n\n            # create variants by options combination\n            items_id = cls.get_item_ids_by_product_id(cls.product.id)\n            variants = list(options_combination(*items_id))\n            for variant in variants:\n                values_tuple = tuple(variant)\n\n                # set each value to an option and set none if it doesn't exist\n                while len(values_tuple) < 3:\n                    values_tuple += (None,)\n                option1, option2, option3 = values_tuple\n\n                ProductVariant.create(\n                    product_id=cls.product.id,\n                    option1=option1,\n                    option2=option2,\n                    option3=option3,\n                    price=cls.price,\n                    stock=cls.stock\n                )\n        else:\n            # set a default variant\n            ProductVariant.create(\n                product_id=cls.product.id,\n                price=cls.price,\n                stock=cls.stock\n            )\n\n        cls.variants = cls.retrieve_variants(cls.product.id)\n\n    @classmethod\n    def retrieve_variants(cls, product_id):\n        \"\"\"\n        Get all variants of a product\n        \"\"\"\n\n        product_variants = []\n        variants: list[ProductVariant] = ProductVariant.filter(ProductVariant.product_id == product_id).all()\n        for variant in variants:\n            product_variants.append(\n                {\n                    \"variant_id\": variant.id,\n                    \"product_id\": variant.product_id,\n                    \"price\": variant.price,\n                    \"stock\": variant.stock,\n                    \"option1\": variant.option1,\n                    \"option2\": variant.option2,\n                    \"option3\": variant.option3,\n                    \"created_at\": DateTime.string(variant.created_at),\n                    \"updated_at\": DateTime.string(variant.updated_at)\n                })\n\n        if product_variants:\n            return product_variants\n        return None\n\n    @staticmethod\n    def retrieve_variant(variant_id: int):\n        variant = ProductVariant.get_or_404(variant_id)\n        variant_data = {\n            \"variant_id\": variant.id,\n            \"product_id\": variant.product_id,\n            \"price\": variant.price,\n            \"stock\": variant.stock,\n            \"option1\": variant.option1,\n            \"option2\": variant.option2,\n            \"option3\": variant.option3,\n            \"created_at\": DateTime.string(variant.created_at),\n            \"updated_at\": DateTime.string(variant.updated_at)\n        }\n        return variant_data\n\n    @classmethod\n    def get_item_ids_by_product_id(cls, product_id):\n        item_ids_by_option = []\n        item_ids_dict = {}\n        with DatabaseManager.session as session:\n\n            # Query the ProductOptionItem table to retrieve item_ids\n            items = (\n                session.query(ProductOptionItem.option_id, ProductOptionItem.id)\n                .join(ProductOption)\n                .filter(ProductOption.product_id == product_id)\n                .all()\n            )\n\n            # Separate item_ids by option_id\n            for option_id, item_id in items:\n                if option_id not in item_ids_dict:\n                    item_ids_dict[option_id] = []\n                item_ids_dict[option_id].append(item_id)\n\n            # Append `item_ids` lists to the result list\n            item_ids_by_option.extend(item_ids_dict.values())\n\n        return item_ids_by_option\n\n    @classmethod\n    def retrieve_product(cls, product_id):\n        cls.product = Product.get_or_404(product_id)\n        cls.options = cls.retrieve_options(product_id)\n        cls.variants = cls.retrieve_variants(product_id)\n        cls.media = cls.retrieve_media_list(product_id)\n\n        product = {\n            'product_id': cls.product.id,\n            'product_name': cls.product.product_name,\n            'description': cls.product.description,\n            'status': cls.product.status,\n            'created_at': DateTime.string(cls.product.created_at),\n            'updated_at': DateTime.string(cls.product.updated_at),\n            'published_at': DateTime.string(cls.product.published_at),\n            'options': cls.options,\n            'variants': cls.variants,\n            'media': cls.media\n        }\n        return product\n\n    @classmethod\n    def update_product(cls, product_id, **kwargs):\n\n        # --- init data ---\n        # TODO `updated_at` is autoupdate dont need to code\n        kwargs['updated_at'] = DateTime.now()\n\n        # --- update product ---\n        Product.update(product_id, **kwargs)\n        return cls.retrieve_product(product_id)\n\n    @classmethod\n    def update_variant(cls, variant_id, **kwargs):\n        # check variant exist\n        ProductVariant.get_or_404(variant_id)\n\n        # TODO `updated_at` is autoupdate dont need to code\n        kwargs['updated_at'] = DateTime.now()\n        ProductVariant.update(variant_id, **kwargs)\n\n        return cls.retrieve_variant(variant_id)\n\n    @classmethod\n    def list_products(cls, limit: int = 12):\n        # - if \"default variant\" is not set, first variant will be\n        # - on list of products, for price, get it from \"default variant\"\n        # - if price or stock of default variant is 0 then select first variant that is not 0\n        # - or for price, get it from \"less price\"\n        # do all of them with graphql and let the front devs decide witch query should be run.\n\n        # also can override the list `limit` in settings.py\n        if hasattr(settings, 'products_list_limit'):\n            limit = settings.products_list_limit\n\n        products_list = []\n\n        with DatabaseManager.session as session:\n            products = session.execute(\n                select(Product.id).limit(limit)\n            )\n\n        for product in products:\n            products_list.append(cls.retrieve_product(product.id))\n\n        return products_list\n        # --- list by join ----\n        # products_list = []\n        # with DatabaseManager.session as session:\n        #     products = select(\n        #         Product.id,\n        #         Product.product_name,\n        #         coalesce(ProductMedia.alt, None).label('alt'),\n        #         coalesce(ProductMedia.src, None).label('src'),\n        #         # media.alt,\n        #         ProductVariant.price,\n        #         ProductVariant.stock\n        #     ).outerjoin(ProductMedia).outerjoin(ProductVariant)\n        #     products = session.execute(products)\n        #\n        # for product in products:\n        #     media = {'src': product.src, 'alt': product.alt} if product.src is not None else None\n        #     products_list.append(\n        #         {\n        #             'product_id': product.id,\n        #             'product_name': product.product_name,\n        #             'price': product.price,\n        #             'stock': product.stock,\n        #             'media': media\n        #         }\n        #     )\n\n    @classmethod\n    def create_media(cls, product_id, alt, files):\n        \"\"\"\n        Save uploaded media to `media` directory and attach uploads to a product.\n        \"\"\"\n\n        product: Product = Product.get_or_404(product_id)\n        media_service = MediaService(parent_directory=\"/products\", sub_directory=product_id)\n\n        for file in files:\n            file_name, file_extension = media_service.save_file(file)\n            ProductMedia.create(\n                product_id=product_id,\n                alt=alt if alt is not None else product.product_name,\n                src=file_name,\n                type=file_extension\n            )\n\n        media = cls.retrieve_media_list(product_id)\n        return media\n\n    @classmethod\n    def retrieve_media_list(cls, product_id):\n        \"\"\"\n        Get all media of a product.\n        \"\"\"\n\n        media_list = []\n        product_media: list[ProductMedia] = ProductMedia.filter(ProductMedia.product_id == product_id).all()\n        for media in product_media:\n            media_list.append(\n                {\n                    \"media_id\": media.id,\n                    \"product_id\": media.product_id,\n                    \"alt\": media.alt,\n                    \"src\": cls.__get_media_url(media.product_id, media.src),\n                    \"type\": media.type,\n                    \"created_at\": DateTime.string(media.created_at),\n                    \"updated_at\": DateTime.string(media.updated_at)\n                })\n        if media_list:\n            return media_list\n        else:\n            return None\n\n    @classmethod\n    def retrieve_single_media(cls, media_id):\n        \"\"\"\n        Get a media by id.\n        \"\"\"\n\n        media_obj = ProductMedia.filter(ProductMedia.id == media_id).first()\n        if media_obj:\n            media = {\n                \"media_id\": media_obj.id,\n                \"product_id\": media_obj.product_id,\n                \"alt\": media_obj.alt,\n                \"src\": cls.__get_media_url(media_obj.product_id, media_obj.src),\n                \"type\": media_obj.type,\n                \"created_at\": DateTime.string(media_obj.created_at),\n                \"updated_at\": DateTime.string(media_obj.updated_at)\n            }\n            return media\n        else:\n            return None\n\n    @classmethod\n    def __get_media_url(cls, product_id, file_name: str):\n        if cls.request is None:\n            base_url = \"http://127.0.0.1:8000/\"\n        else:\n            base_url = str(cls.request.base_url)\n\n        return f\"{base_url}media/products/{product_id}/{file_name}\" if file_name is not None else None\n\n    @classmethod\n    def update_media(cls, media_id, **kwargs):\n        # check media exist\n        media: ProductMedia = ProductMedia.get_or_404(media_id)\n        file = kwargs.pop('file', None)\n        if file is not None:\n            media_service = MediaService(parent_directory=\"/products\", sub_directory=media.product_id)\n            file_name, file_extension = media_service.save_file(file)\n            kwargs['src'] = file_name\n            kwargs['type'] = file_extension\n\n        # TODO `updated_at` is autoupdate dont need to code\n        kwargs['updated_at'] = DateTime.now()\n        ProductMedia.update(media_id, **kwargs)\n\n        return cls.retrieve_single_media(media_id)\n\n    @staticmethod\n    def delete_product_media(product_id, media_ids: list[int]):\n\n        # Fetch the product media records to be deleted\n        with DatabaseManager.session as session:\n            filters = [\n                and_(ProductMedia.product_id == product_id, ProductMedia.id == media_id)\n                for media_id in media_ids\n            ]\n            media_to_delete = session.query(ProductMedia).filter(or_(*filters)).all()\n\n            # Delete the product media records\n            for media in media_to_delete:\n                ProductMedia.delete(ProductMedia.get_or_404(media.id))\n        return None\n\n    @staticmethod\n    def delete_product(product_id):\n        Product.delete(Product.get_or_404(product_id))\n\n    @classmethod\n    def delete_media_file(cls, media_id: int):\n        media = ProductMedia.get_or_404(media_id)\n        product_id = media.product_id\n\n        media_service = MediaService(parent_directory=\"/products\", sub_directory=product_id)\n        is_fie_deleted = media_service.delete_file(media.src)\n        if is_fie_deleted:\n            ProductMedia.delete(ProductMedia.get_or_404(media_id))\n            return True\n        return False\n"}
{"type": "source_file", "path": "apps/main.py", "content": "from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\n\nfrom config.database import DatabaseManager\nfrom config.routers import RouterManager\nfrom config.settings import MEDIA_DIR\n\n# -------------------\n# --- Init Models ---\n# -------------------\n\nDatabaseManager().create_database_tables()\n\n# --------------------\n# --- Init FastAPI ---\n# --------------------\n\napp = FastAPI()\n\n# ------------------\n# --- Middleware ---\n# ------------------\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"http://localhost:3000\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"])\n\n# -------------------\n# --- Static File ---\n# -------------------\n\n# add static-file support, for see images by URL\napp.mount(\"/media\", StaticFiles(directory=MEDIA_DIR), name=\"media\")\n\n# --------------------\n# --- Init Routers ---\n# --------------------\n\nRouterManager(app).import_routers()\n"}

{"repo_info": {"repo_name": "ticktick-ai", "repo_owner": "zhattention", "repo_url": "https://github.com/zhattention/ticktick-ai"}}
{"type": "test_file", "path": "tests/__init__.py", "content": "\n"}
{"type": "test_file", "path": "tests/test_ticktick_full.py", "content": "import os\nimport pytest\nfrom datetime import datetime, timedelta\nfrom clients.ticktick import TickTickClient\nfrom dotenv import load_dotenv\n\n@pytest.fixture(scope='module')\ndef client():\n    \"\"\"创建一个 TickTickClient 实例作为测试固件\"\"\"\n    load_dotenv()\n    client = TickTickClient(\n        client_id=os.getenv('TICKTICK_CLIENT_ID'),\n        client_secret=os.getenv('TICKTICK_CLIENT_SECRET')\n    )\n    if not client.access_token:\n        client.authenticate()\n    return client\n\n@pytest.fixture(scope='module')\ndef test_project(client):\n    \"\"\"创建一个测试项目作为测试固件\"\"\"\n    project_name = \"测试项目\"\n    project = client.create_project(\n        name=project_name,\n        color=\"#FF0000\",  # 红色\n        view_mode=\"list\"\n    )\n    yield project\n    # 测试结束后清理项目\n    try:\n        # 这里需要实现删除项目的方法\n        pass\n    except Exception as e:\n        print(f\"清理测试项目时出错: {e}\")\n\ndef test_authentication(client):\n    \"\"\"测试认证功能\"\"\"\n    assert client.access_token is not None, \"认证失败，没有获取到 access_token\"\n\ndef test_create_project(test_project):\n    \"\"\"测试创建项目\"\"\"\n    assert test_project['name'] == \"测试项目\", \"项目名称不匹配\"\n    assert test_project['color'] == \"#FF0000\", \"项目颜色不匹配\"\n    assert test_project['viewMode'] == \"list\", \"项目视图模式不匹配\"\n\ndef test_create_task(client, test_project):\n    \"\"\"测试创建任务\"\"\"\n    # 创建一个普通任务\n    task1 = client.create_task(\n        title=\"测试任务1\",\n        project_name=test_project['name'],\n        content=\"这是一个测试任务\",\n        due_date=datetime.now().strftime('%Y-%m-%d'),\n        priority=3\n    )\n    assert task1['title'] == \"测试任务1\", \"任务标题不匹配\"\n    assert task1['priority'] == 3, \"任务优先级不匹配\"\n\n    # 创建一个带提醒的任务\n    tomorrow = datetime.now() + timedelta(days=1)\n    reminder_time = tomorrow.replace(hour=9, minute=0, second=0).strftime('%Y-%m-%dT%H:%M:%S.000Z')\n    task2 = client.create_task(\n        title=\"测试任务2（带提醒）\",\n        project_name=test_project['name'],\n        content=\"这是一个带提醒的任务\",\n        due_date=tomorrow.strftime('%Y-%m-%d'),\n        reminders=[reminder_time],\n        priority=5  # 高优先级\n    )\n    assert task2['title'] == \"测试任务2（带提醒）\", \"带提醒任务的标题不匹配\"\n    assert task2['priority'] == 5, \"带提醒任务的优先级不匹配\"\n    # 暂时跳过提醒测试，因为 API 响应中可能不包含 reminders 字段\n\n    # 创建一个重复任务\n    task3 = client.create_task(\n        title=\"测试任务3（每周重复）\",\n        project_name=test_project['name'],\n        content=\"这是一个每周重复的任务\",\n        due_date=tomorrow.strftime('%Y-%m-%d'),\n        repeat={\n            'freq': 'WEEKLY',\n            'interval': 1,\n            'until': (datetime.now() + timedelta(days=30)).strftime('%Y-%m-%d')\n        }\n    )\n    assert task3['title'] == \"测试任务3（每周重复）\", \"重复任务的标题不匹配\"\n    assert task3.get('repeat') is not None, \"任务的重复设置失败\"\n\ndef test_update_task(client, test_project):\n    \"\"\"测试更新任务\"\"\"\n    # 创建一个测试任务\n    task = client.create_task(\n        title=\"待更新的任务\",\n        project_name=test_project['name'],\n        content=\"原始内容\",\n        priority=1\n    )\n    \n    # 更新任务\n    updates = {\n        'title': '已修改的任务',\n        'content': '已修改的内容',\n        'priority': 5\n    }\n    updated_task = client.update_task(task['id'], updates)\n    \n    # 验证更新结果\n    assert updated_task['title'] == '已修改的任务', \"任务标题更新失败\"\n    assert updated_task['content'] == '已修改的内容', \"任务内容更新失败\"\n    assert updated_task['priority'] == 5, \"任务优先级更新失败\"\n\ndef test_get_tasks(client, test_project):\n    \"\"\"测试获取任务列表\"\"\"\n    tasks = client.get_tasks(project_name=test_project['name'])\n    assert len(tasks) > 0, \"没有获取到任何任务\"\n\ndef test_complete_and_delete_tasks(client, test_project):\n    \"\"\"测试完成和删除任务\"\"\"\n    # 创建一个测试任务\n    task = client.create_task(\n        title=\"测试完成和删除的任务\",\n        project_name=test_project['name']\n    )\n    assert task['id'] is not None, \"创建的任务没有 ID\"\n    \n    # 测试完成任务\n    client.complete_task(task['id'])\n    \n    # 测试删除任务\n    client.delete_task(task['id'])\n    \n    # 验证任务已被删除\n    all_tasks = client.get_tasks(project_name=test_project['name'])\n    assert all(t['id'] != task['id'] for t in all_tasks), \"任务未被成功删除\"\n"}
{"type": "test_file", "path": "tests/test_auth_and_tasks.py", "content": "import os\nfrom datetime import datetime, timedelta\nfrom ticktick_client import TickTickClient\nfrom dotenv import load_dotenv\n\ndef main():\n    # 加载环境变量\n    load_dotenv()\n    \n    # 初始化客户端\n    client = TickTickClient(\n        client_id=os.getenv('TICKTICK_CLIENT_ID'),\n        client_secret=os.getenv('TICKTICK_CLIENT_SECRET')\n    )\n    \n    try:\n        # 1. 测试认证\n        print(\"\\n1. 测试认证\")\n        client.authenticate(force_new=True)  # 强制获取新的令牌\n        print(\"认证成功！\")\n        \n        # 2. 测试获取所有任务\n        print(\"\\n2. 测试获取所有任务\")\n        start_date = datetime.now().strftime('%Y-%m-%d')\n        end_date = (datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d')\n        tasks = client.get_tasks(start_date=start_date, end_date=end_date)\n        print(f\"获取到 {len(tasks)} 个任务:\")\n        for task in tasks:\n            project_name = task.get('project', {}).get('name', 'Unknown')\n            print(f\"- [{project_name}] {task['title']}\")\n            \n        # 3. 测试获取 Inbox 任务\n        print(\"\\n3. 测试获取 Inbox 任务\")\n        inbox_tasks = client.get_inbox_tasks()\n        print(f\"获取到 {len(inbox_tasks)} 个 Inbox 任务:\")\n        for task in inbox_tasks:\n            print(f\"- {task['title']}\")\n            \n    except Exception as e:\n        print(f\"测试过程中出现错误: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "test_file", "path": "tests/test_session.py", "content": "import os\nimport pytest\nimport asyncio\nfrom dotenv import load_dotenv\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\nfrom autogen_agentchat.agents import AssistantAgent, UserProxyAgent\nfrom session import Session, ConsoleHandler, SessionResult\nfrom autogen_agentchat.teams import MagenticOneGroupChat, RoundRobinGroupChat\nfrom autogen_agentchat.base import TaskResult\nfrom autogen_agentchat.ui import Console\n# Load environment variables\nload_dotenv()\n\n@pytest.fixture\ndef model_client():\n    api_key = os.getenv(\"CEREBRAS_API_KEY\")\n    if not api_key:\n        pytest.skip(\"CEREBRAS_API_KEY not found in environment variables\")\n    \n    return OpenAIChatCompletionClient(\n        model=\"llama-3.3-70b\",\n        api_key=api_key,\n        base_url=\"https://api.cerebras.ai/v1\",\n        model_info={\n            \"vision\": False,\n            \"function_calling\": True,\n            \"json_output\": True,\n            \"family\": \"unknown\",\n        },\n        llm_config={\n            \"cache_seed\": 42,  # Enable caching with seed 42\n            \"cache_path_root\": \".cache/llm_cache\"  # Specify cache directory\n        }\n    )\n\n@pytest.fixture\ndef assistant(model_client):\n    \"\"\"\"\"\"\n    return AssistantAgent(\n        name=\"test_assistant\",\n        system_message=\"\"\"You are a helpful AI assistant. \n        Keep your responses brief and to the point.\n        Say 'goodbye' to end the conversation.\"\"\",\n        model_client=model_client,\n    )\n\n@pytest.fixture\ndef team(assistant, user_proxy, model_client):\n    return MagenticOneGroupChat(\n        participants=[user_proxy, assistant],\n        model_client=model_client,\n        max_turns=20,\n        max_stalls=3,\n        final_answer_prompt=\"Here is the final answer:\"\n    )\nclass QueueUserInput:\n    def __init__(self):\n        self.queue = asyncio.Queue()\n\n    async def input(self, text: str) -> None:\n        await self.queue.put(text)\n\n    def get_user_input_func(self):\n        \"\"\"返回符合 input_func 签名的函数\"\"\"\n        async def user_input_func(prompt: str, cancellation_token) -> str:\n            return await self.queue.get()\n        return user_input_func\n\n@pytest.fixture\ndef user_input_queue() -> QueueUserInput:\n    return QueueUserInput()\n\n@pytest.fixture\ndef user_proxy(user_input_queue):\n    \"\"\"创建用户代理\"\"\"\n    return UserProxyAgent(\n        name=\"test_user\",\n        input_func=user_input_queue.get_user_input_func(),\n    )\n\n@pytest.fixture\ndef console_handler():\n    \"\"\"创建控制台消息处理器\"\"\"\n    return ConsoleHandler()\n\nclass TestSession:\n    @pytest.mark.asyncio\n    async def test_start_session(self, team, model_client, console_handler, user_input_queue):\n        \"\"\"测试开始新会话\"\"\"\n        print(\"\\n=== Testing Start Session ===\\n\")\n        session = Session(team, model_client)\n        \n        # 启动会话\n        session.start(\"Help me solve a math problem\", console_handler)\n        \n        # 验证会话状态\n        assert session.is_active == True\n        assert session.message_handler == console_handler\n        assert session.stream is not None\n\n        # First run should request user input\n        result = await session.run_until_stop()\n        assert result == SessionResult.USER_INPUT_REQUESTED\n        assert result.last_message is not None  # Should have some message content\n\n        # Provide user input\n        await user_input_queue.input(\"which is bigger, 9.9 or 9.11?\")\n\n        # Second run should finish the conversation\n        result = await session.run_until_stop()\n        assert result == SessionResult.FINISHED\n        assert result.last_message is not None  # Should have the final response\n        print(result.last_message)\n\n    @pytest.mark.asyncio\n    async def test_multiple_sessions(self, team, model_client, console_handler, user_input_queue):\n        \"\"\"测试多个会话串联执行，历史记录传递\"\"\"\n        print(\"\\n=== Testing Multiple Sessions ===\\n\")\n        \n        # First session\n        session1 = Session(team, model_client)\n        initial_prompt = \"Help me solve a math problem\"\n        session1.start(initial_prompt, console_handler)\n        \n        # First session: Get initial response\n        result = await session1.run_until_stop()\n        assert result == SessionResult.USER_INPUT_REQUESTED\n        first_response = result.last_message\n        \n        # First session: Provide user input\n        user_question = \"which is bigger, 9.9 or 9.11?\"\n        await user_input_queue.input(user_question)\n        \n        # First session: Get final response\n        result = await session1.run_until_stop()\n        # assert result == SessionResult.FINISHED\n\n        # 获取第一轮对话的摘要\n        first_round_digest = await session1.digest()\n        print(\"\\nFirst round digest:\")\n        print(first_round_digest)\n\n        # 第二轮对话，使用第一轮的摘要作为背景\n        print(\"\\n=== Starting Second Session with Previous Context ===\")\n        session2 = Session(team, model_client)\n        \n        # 构建带有背景信息的提示词\n        background = f\"Previous conversation summary:\\n{first_round_digest}\"\n        prompt = f\"{background}\\n\\nBased on this context, can you explain why 9.11 is bigger than 9.9 in mathematical terms?\"\n        \n        print(\"\\nPrompt for second session:\")\n        print(prompt)\n        \n        session2.start(prompt, console_handler)\n        result = await session2.run_until_stop()\n\n        print(f\"session2 result: {result.last_message}\")\n        \n        # 打印第二轮的摘要\n        second_round_digest = await session2.digest()\n        print(\"\\nSecond round digest:\")\n        print(second_round_digest)\n\n    # @pytest.mark.asyncio\n    # async def test_handle_input_new_session(self, team,  model_client, console_handler):\n    #     \"\"\"测试处理新会话的输入\"\"\"\n    #     print(\"\\n=== Testing Handle Input (New Session) ===\\n\")\n    #     session = Session(team, model_client)\n        \n    #     # 启动会话\n    #     session.start(\"Help me solve a math problem\", console_handler)\n\n    #     user_req_prompt = await session.run_until_user()\n\n    #     print(user_req_prompt)\n\n    #     await session.run_until_user()\n\n        # await session.input(\"which is bigger, 9.9 or 9.11?\")\n\n        # await session.run_until_user()\n\n    # @pytest.mark.asyncio\n    # async def test_handle_input_existing_session(self, assistant, user_proxy, model_client, console_handler):\n    #     \"\"\"测试向现有会话注入输入\"\"\"\n    #     print(\"\\n=== Testing Handle Input (Existing Session) ===\\n\")\n    #     session = Session(assistant, model_client)\n        \n    #     # 首先启动一个会话\n    #     print(\"[User] Let's have a conversation\")\n    #     session.start(\"Let's have a conversation\", console_handler)\n        \n    #     # 等待一下，确保会话开始但不要太久\n    #     await asyncio.sleep(1)\n    #     assert session.is_active == True, \"会话应该处于活跃状态\"\n        \n    #     # 向现有会话注入新输入\n    #     new_input = \"Tell me more\"\n    #     print(f\"[User] {new_input}\")\n    #     await session.handle_input(new_input, console_handler)  # 添加 console_handler\n        \n    #     # 验证输入是否被加入队列\n    #     queue_content = await session.voice_queue.get()\n    #     assert queue_content == new_input\n        \n    #     # 等待响应完成\n    #     await asyncio.sleep(5)\n        \n    #     # 显示所有消息\n    #     messages = console_handler.get_messages()\n    #     assert len(messages) > 0, \"应该有至少一条消息\"\n\n    # @pytest.mark.asyncio\n    # async def test_multiple_sessions(self, assistant, user_proxy, model_client, console_handler):\n    #     \"\"\"测试多个会话的处理\"\"\"\n    #     print(\"\\n=== Testing Multiple Sessions ===\\n\")\n    #     session = Session(assistant, model_client)\n        \n    #     # 第一个会话\n    #     print(\"[User] First message\")\n    #     await session.start(\"First message\", console_handler)\n    #     assert session.is_active == True\n    #     await asyncio.sleep(2)\n        \n    #     # 尝试启动第二个会话（应该被阻止）\n    #     print(\"\\n[User] Second message (should be blocked)\")\n    #     await session.start(\"Second message\", console_handler)\n        \n    #     # 验证仍然是第一个会话\n    #     assert session.is_active == True\n        \n    #     # 等待响应完成\n    #     await asyncio.sleep(5)\n        \n    #     # 显示所有消息\n    #     messages = console_handler.get_messages()\n    #     assert len(messages) > 0, \"应该有至少一条消息\"\n"}
{"type": "source_file", "path": "clients/__init__.py", "content": "\n"}
{"type": "source_file", "path": "__init__.py", "content": "\n"}
{"type": "source_file", "path": "clients/ticktick/authenticate.py", "content": "from .client import TickTickClient\nfrom dotenv import load_dotenv\nimport os\nimport time\nimport requests\n\ndef main():\n    # 加载环境变量\n    load_dotenv()\n    \n    client_id = os.getenv('TICKTICK_CLIENT_ID')\n    client_secret = os.getenv('TICKTICK_CLIENT_SECRET')\n    redirect_uri = os.getenv('TICKTICK_REDIRECT_URI', 'http://localhost:8080/callback')\n    \n    if not client_id or not client_secret:\n        print('错误: 请在 .env 文件中设置 TICKTICK_CLIENT_ID 和 TICKTICK_CLIENT_SECRET')\n        return\n    \n    # 初始化客户端\n    client = TickTickClient(\n        client_id=client_id,\n        client_secret=client_secret,\n        redirect_uri=redirect_uri\n    )\n    \n    # 运行认证流程\n    max_retries = 3\n    retry_delay = 5\n    \n    for attempt in range(max_retries):\n        try:\n            client.authenticate()\n            print('认证成功！')\n            \n            # 验证认证是否有效\n            try:\n                client.load_projects()\n                return  # 如果成功加载项目，则认证成功\n            except requests.exceptions.HTTPError as e:\n                if e.response.status_code == 401:\n                    print('认证失败: 无效的访问令牌')\n                else:\n                    print(f'验证认证失败: {e}')\n            \n        except Exception as e:\n            if attempt < max_retries - 1:\n                print(f'认证失败 ({attempt + 1}/{max_retries}): {e}')\n                print(f'将在 {retry_delay} 秒后重试...')\n                time.sleep(retry_delay)\n            else:\n                print(f'认证失败: {e}')\n                print('请确保:')\n                print('1. 客户端 ID 和密钥正确')\n                print('2. 回调 URL 已经在 TickTick 开发者中心配置')\n                print('3. 网络连接正常')\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "scratch_files/app.py", "content": "from fastapi import FastAPI, WebSocket\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse\nimport uvicorn\nimport base64\nimport logging\nimport os\nfrom datetime import datetime\n\nimport openai\nfrom dotenv import load_dotenv\n\n# Load environment variables\nload_dotenv()\n\n# 配置日志记录\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\n\napp = FastAPI()\n\n# 添加CORS支持\nfrom fastapi.middleware.cors import CORSMiddleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# 挂载静态文件\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n\n# 添加根路由重定向\n@app.get(\"/\")\nasync def root():\n    return FileResponse(\"static/asr.html\")\n\n# 创建音频文件保存目录\nAUDIO_DIR = \"audio_files\"\nif not os.path.exists(AUDIO_DIR):\n    os.makedirs(AUDIO_DIR)\n    logging.info(f\"Created audio directory: {AUDIO_DIR}\")\n\n# 从环境变量设置OpenAI API密钥\nopenai.api_key = os.getenv('OPENAI_API_KEY')\nif not openai.api_key:\n    raise ValueError(\"OPENAI_API_KEY not found in environment variables\")\n\ndef process_audio(audio_bytes):\n    try:\n        # 保存原始数据到临时文件\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        temp_audio = f\"{AUDIO_DIR}/temp_{timestamp}.webm\"\n        \n        with open(temp_audio, 'wb') as f:\n            f.write(audio_bytes)\n        \n        try:\n            # 使用OpenAI Whisper API进行转录\n            logging.info(\"Starting transcription with OpenAI Whisper API...\")\n            with open(temp_audio, 'rb') as audio_file:\n                response = openai.audio.transcriptions.create(\n                    model=\"whisper-1\",\n                    file=audio_file,\n                    language=\"zh\"\n                )\n            \n            text = response.text\n            logging.info(f\"Final transcription: {text}\")\n            \n            return text\n            \n        finally:\n            # 清理临时文件\n            if os.path.exists(temp_audio):\n                os.remove(temp_audio)\n                \n    except Exception as e:\n        logging.error(f\"Error processing audio: {e}\", exc_info=True)\n        raise\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    client_id = id(websocket)\n    logging.info(f\"New WebSocket connection: {client_id}\")\n    await websocket.accept()\n    \n    try:\n        while True:\n            # 接收音频数据\n            data = await websocket.receive_text()\n            try:\n                try:\n                    # 解码base64音频数据\n                    mime_type = data.split(',')[0].split(':')[1].split(';')[0]\n                    logging.info(f\"Received audio MIME type: {mime_type}\")\n                    \n                    audio_bytes = base64.b64decode(data.split(',')[1])\n                    logging.info(f\"Decoded base64 data size: {len(audio_bytes)} bytes\")\n                    \n                    # 检查数据大小\n                    if len(audio_bytes) == 0:\n                        logging.error(\"Received empty audio data\")\n                        continue\n                    \n                    # 保存原始数据到临时文件\n                    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n                    temp_webm = f\"{AUDIO_DIR}/temp_{timestamp}_client_{client_id}.webm\"\n                    wav_filename = f\"{AUDIO_DIR}/audio_{timestamp}_client_{client_id}.wav\"\n                    \n                    with open(temp_webm, 'wb') as f:\n                        f.write(audio_bytes)\n                    \n                    try:\n                        # 直接处理音频数据\n                        text = process_audio(audio_bytes)\n                        if text:\n                            # 发送转录结果回客户端\n                            await websocket.send_text(text)\n                            logging.info(f\"Sent transcription to client {client_id}\")\n                    except Exception as e:\n                        logging.error(f\"Error processing audio: {e}\")\n                        if os.path.exists(temp_webm):\n                            os.remove(temp_webm)\n                        continue\n                except Exception as e:\n                    logging.error(f\"Error processing audio data: {e}\")\n                    continue\n            except Exception as e:\n                error_msg = f\"Error processing audio: {str(e)}\"\n                logging.error(error_msg, exc_info=True)\n                await websocket.send_text(f\"Error: {error_msg}\")\n    except Exception as e:\n        logging.error(f\"WebSocket error for client {client_id}: {e}\", exc_info=True)\n    finally:\n        try:\n            await websocket.close()\n            logging.info(f\"WebSocket connection closed: {client_id}\")\n        except:\n            pass\n\nif __name__ == \"__main__\":\n    logging.info(\"Starting server on http://0.0.0.0:8000\")\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)"}
{"type": "source_file", "path": "clients/ticktick/__init__.py", "content": "from .client import TickTickClient\n\n__all__ = [\"TickTickClient\"]\n"}
{"type": "source_file", "path": "scratch_files/human.py", "content": "import asyncio\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\nfrom autogen_agentchat.agents import AssistantAgent, UserProxyAgent\nfrom autogen_agentchat.teams import MagenticOneGroupChat\nfrom autogen_agentchat.ui import Console\nfrom dotenv import load_dotenv\nimport os\nfrom agent import TaskManager\n\nload_dotenv()\n\nasync def main() -> None:\n    # Get the required environment variables\n    api_key = os.getenv(\"OPENAI_API_KEY\")\n    ticktick_client_id = os.getenv(\"TICKTICK_CLIENT_ID\")\n    ticktick_client_secret = os.getenv(\"TICKTICK_CLIENT_SECRET\")\n    \n    if not api_key:\n        raise ValueError(\"OPENAI_API_KEY environment variable is not set\")\n    if not ticktick_client_id or not ticktick_client_secret:\n        raise ValueError(\"TICKTICK_CLIENT_ID and TICKTICK_CLIENT_SECRET environment variables must be set\")\n\n    # Initialize task manager\n    task_manager = TaskManager(ticktick_client_id, ticktick_client_secret)\n\n    # Create the model client\n    model_client = OpenAIChatCompletionClient(\n        model=\"gpt-4o\",\n        api_key=api_key,\n    )\n\n    # Create the task management assistant\n    assistant = AssistantAgent(\n        name=\"task_assistant\",\n        system_message=\"\"\"\n        You are an expert task management assistant for TickTick's Inbox. You help users manage their tasks efficiently using the following capabilities:\n\n        Available Functions:\n\n        1. create_task(title, content='', due_date=None, start_date=None, is_all_day=True, priority=0)\n           - Creates a new task in Inbox with the following parameters:\n             * title: Task title (required)\n             * content: Task description\n             * due_date: Due date in 'YYYY-MM-DD' format\n             * start_date: Start date in 'YYYY-MM-DD' format\n             * is_all_day: Whether it's an all-day task\n             * priority: Task priority (0=none, 1=low, 3=medium, 5=high)\n\n        2. list_tasks(start_date=None, end_date=None, include_completed=False)\n           - Lists tasks from Inbox with optional filters:\n             * start_date: Start date filter 'YYYY-MM-DD'\n             * end_date: End date filter 'YYYY-MM-DD'\n             * include_completed: Include completed tasks\n\n        3. complete_task(task_id)\n           - Marks a task as completed\n           - Requires task_id from list_tasks\n\n        4. delete_task(task_id)\n           - Removes a task from Inbox\n           - Requires task_id from list_tasks\n\n        5. get_tasks_by_date(start_date, end_date=None)\n           - Gets tasks within a date range:\n             * start_date: Start date 'YYYY-MM-DD'\n             * end_date: Optional end date 'YYYY-MM-DD'\n\n        6. get_completed_tasks()\n           - Retrieves all completed tasks from Inbox\n\n        Always follow these steps:\n        1. UNDERSTAND: Analyze the user's request carefully\n        2. VALIDATE: Ensure you have all required information\n        3. EXECUTE: Perform the requested operation\n        4. VERIFY: Check the result and provide clear feedback\n\n        Important Notes:\n        - All dates must be in 'YYYY-MM-DD' format\n        - Priority levels: 0=none, 1=low, 3=medium, 5=high\n        - All operations are performed in the Inbox\n        - Task IDs are required for complete_task and delete_task\n\n        Say 'goodbye' to end the conversation.\n        \"\"\",\n        tools=[\n            task_manager.create_task,  # 创建任务（支持设置标题、内容、日期、优先级等）\n            task_manager.list_tasks,    # 列出任务（支持日期范围过滤和显示已完成任务）\n            task_manager.complete_task, # 完成任务\n            task_manager.delete_task,   # 删除任务\n            task_manager.get_tasks_by_date,  # 获取指定日期范围的任务\n            task_manager.get_completed_tasks # 获取所有已完成的任务\n        ],\n        model_client=model_client,\n    )\n\n    # Create the user proxy agent\n    user_proxy = UserProxyAgent(\n        name=\"user\",\n        input_func=input,\n    )\n\n    # Define task description with available tools\n    task_description = \"\"\"\nAvailable TickTick Task Management Tools:\n\n1. create_task\n   - Purpose: Create a new task in Inbox\n   - Required Parameters:\n     * title: Task title\n   - Optional Parameters:\n     * content: Task description\n     * due_date: Due date (YYYY-MM-DD)\n     * start_date: Start date (YYYY-MM-DD)\n     * is_all_day: Whether it's an all-day task (default: True)\n     * priority: Task priority (0=none, 1=low, 3=medium, 5=high)\n   - Returns: Created task information\n\n2. list_tasks\n   - Purpose: List tasks from Inbox with filtering options\n   - Optional Parameters:\n     * start_date: Filter tasks from this date (YYYY-MM-DD)\n     * end_date: Filter tasks until this date (YYYY-MM-DD)\n     * include_completed: Include completed tasks (default: False)\n   - Returns: List of filtered tasks\n\n3. complete_task\n   - Purpose: Mark a task as completed\n   - Required Parameters:\n     * task_id: ID of the task to complete\n   - Returns: None\n\n4. delete_task\n   - Purpose: Delete a task from Inbox\n   - Required Parameters:\n     * task_id: ID of the task to delete\n   - Returns: None\n\n5. get_tasks_by_date\n   - Purpose: Get tasks within a date range\n   - Required Parameters:\n     * start_date: Start date (YYYY-MM-DD)\n   - Optional Parameters:\n     * end_date: End date (YYYY-MM-DD)\n   - Returns: List of tasks within the date range\n\n6. get_completed_tasks\n   - Purpose: Get all completed tasks\n   - Returns: List of completed tasks\n\nImportant Notes:\n- All operations are performed in the Inbox\n- Dates must be in YYYY-MM-DD format\n- Task IDs are required for completing and deleting tasks\n- Priority levels: 0=none, 1=low, 3=medium, 5=high\n\nUser Request: 帮我搜索出所有重复执行的任务\n\"\"\"\n\n    # Create and run the team\n    team = MagenticOneGroupChat(\n        participants=[user_proxy, assistant],\n        model_client=model_client,\n        max_turns=20,\n        max_stalls=3,\n        final_answer_prompt=\"Based on our analysis of TickTick tasks, here is a summary of duplicate tasks found and recommendations for handling them:\"\n    )\n    await Console(team.run_stream(task=task_description))\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"}
{"type": "source_file", "path": "server/audio_processor.py", "content": "import os\nimport base64\nimport logging\nfrom datetime import datetime\nimport openai\n\nlogger = logging.getLogger(__name__)\n\nclass AudioProcessor:\n    def __init__(self, audio_dir=\"audio_files\"):\n        self.audio_dir = audio_dir\n        if not os.path.exists(self.audio_dir):\n            os.makedirs(self.audio_dir)\n            logger.info(f\"Created audio directory: {self.audio_dir}\")\n    \n    def process_audio(self, audio_data):\n        \"\"\"\n        处理音频数据并转换为文本\n        \n        Args:\n            audio_data (str): Base64编码的音频数据\n            \n        Returns:\n            str: 转录的文本\n        \"\"\"\n        try:\n            # 解析MIME类型和Base64数据\n            mime_type = audio_data.split(',')[0].split(':')[1].split(';')[0]\n            logger.info(f\"Received audio MIME type: {mime_type}\")\n            \n            audio_bytes = base64.b64decode(audio_data.split(',')[1])\n            logger.info(f\"Decoded base64 data size: {len(audio_bytes)} bytes\")\n            \n            # 保存原始数据到临时文件\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            temp_audio = f\"{self.audio_dir}/temp_{timestamp}.webm\"\n            \n            with open(temp_audio, 'wb') as f:\n                f.write(audio_bytes)\n            \n            try:\n                # 使用OpenAI Whisper API进行转录\n                logger.info(\"Starting transcription with OpenAI Whisper API...\")\n                with open(temp_audio, 'rb') as audio_file:\n                    response = openai.audio.transcriptions.create(\n                        model=\"whisper-1\",\n                        file=audio_file\n                    )\n                \n                text = response.text\n                logger.info(f\"Final transcription: {text}\")\n                \n                return text\n                \n            finally:\n                # 清理临时文件\n                if os.path.exists(temp_audio):\n                    os.remove(temp_audio)\n                    \n        except Exception as e:\n            logger.error(f\"Error processing audio: {e}\", exc_info=True)\n            raise "}
{"type": "source_file", "path": "server.py", "content": "import os\nimport logging\nimport uvicorn\nfrom fastapi import FastAPI, WebSocket\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nimport openai\nfrom dotenv import load_dotenv\nfrom server.session_handler import SessionHandler\n\n# Load environment variables\nload_dotenv()\n\n# Configure logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n# Create console handler with formatting\nconsole_handler = logging.StreamHandler()\nconsole_handler.setLevel(logging.INFO)\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nconsole_handler.setFormatter(formatter)\n\n# Add handler to logger\nlogger.addHandler(console_handler)\n\n# Disable propagation to root logger\nlogger.propagate = False\n\n# 配置选项\nUSE_DIRECT_AGENT = os.getenv(\"USE_DIRECT_AGENT\", \"false\").lower() == \"true\"\nlogger.info(f\"Using direct agent mode: {USE_DIRECT_AGENT}\")\n\n# Initialize FastAPI app\napp = FastAPI()\n\n# Add CORS support\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Mount static files\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n\n# Set up OpenAI\nopenai.api_key = os.getenv('OPENAI_API_KEY')\nif not openai.api_key:\n    raise ValueError(\"OPENAI_API_KEY not found in environment variables\")\n\n# WebSocket endpoint\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n\n    client_id = id(websocket)\n    logger.info(f\"New WebSocket connection: {client_id}\")\n    \n    # 为每个连接创建一个新的SessionHandler实例，并设置代理模式\n    session_handler = SessionHandler(use_direct_agent=USE_DIRECT_AGENT)\n    await session_handler.initialize()\n\n    try:\n        while True:\n            # Receive data\n            data = await websocket.receive_text()\n            \n            # Handle message with this connection's session handler\n            status, message = await session_handler.handle_message(data)\n            \n            # Send response\n            if status and message:\n                await websocket.send_text(f\"[{status}] {message}\")\n    except Exception as e:\n        logger.error(f\"WebSocket error for client {client_id}: {e}\", exc_info=True)\n    finally:\n        logger.info(f\"WebSocket connection closed: {client_id}\")\n\n# Root route\n@app.get(\"/\")\nasync def root():\n    return FileResponse(\"static/asr.html\")\n\n# Run the server\nif __name__ == \"__main__\":\n    logger.info(\"Starting server on http://0.0.0.0:8000\")\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)"}
{"type": "source_file", "path": "server/agent_strategy.py", "content": "import logging\nfrom abc import ABC, abstractmethod\nfrom typing import Tuple, Optional\nfrom session import Session, SessionResult\nfrom server.agent_manager import AgentManager as TeamAgentManager\nfrom server.agent_manager1 import AgentManager as DirectAgentManager\n\nlogger = logging.getLogger(__name__)\n\nclass AgentStrategy(ABC):\n    \"\"\"代理策略接口，定义了代理交互的通用方法\"\"\"\n    \n    @abstractmethod\n    async def initialize(self) -> None:\n        \"\"\"初始化代理策略\"\"\"\n        pass\n    \n    @abstractmethod\n    async def process_message(self, text: str) -> Tuple[Optional[str], Optional[str]]:\n        \"\"\"\n        处理用户消息\n        \n        Args:\n            text (str): 用户消息\n            \n        Returns:\n            Tuple[Optional[str], Optional[str]]: (状态, 消息内容)\n        \"\"\"\n        pass\n    \n    @property\n    @abstractmethod\n    def history_digest(self) -> str:\n        \"\"\"获取历史摘要\"\"\"\n        pass\n\n\nclass TeamAgentStrategy(AgentStrategy):\n    \"\"\"团队代理策略，使用MagenticOneGroupChat实现\"\"\"\n    \n    def __init__(self):\n        self.agent_manager = TeamAgentManager()\n        self.session = None\n        self.user_input_helper = None\n        self._history_digest = \"\"\n    \n    async def initialize(self) -> None:\n        \"\"\"初始化团队代理\"\"\"\n        assistant, user_proxy, model_client, user_input_helper = self.agent_manager.init_agents()\n        team = self.agent_manager.create_team(assistant, user_proxy, model_client)\n        self.session = Session(team, model_client)\n        self.user_input_helper = user_input_helper\n        logger.info(\"Session initialized with team interaction\")\n    \n    async def process_message(self, text: str) -> Tuple[Optional[str], Optional[str]]:\n        \"\"\"处理用户消息，使用团队交互模式\"\"\"\n        # 确保会话已初始化\n        if not self.session:\n            await self.initialize()\n        \n        # 处理会话\n        if not self.session.is_active:\n            self.session.start(self.agent_manager.task_prompt(text, self._history_digest))\n        else:\n            await self.user_input_helper.recv_user_input(text)\n        \n        # 继续推理\n        result: SessionResult = await self.session.run_until_stop()\n        \n        # 处理结果\n        if result == SessionResult.FINISHED:\n            # 会话结束，生成摘要\n            self._history_digest = await self.session.digest()\n            logger.info(f\"History digest: {self._history_digest}\")\n            \n            # 创建新会话\n            await self.initialize()\n            \n            return result.status, self._history_digest\n        \n        # 返回最后的消息\n        if result.last_message:\n            logger.info(f\"Sent result: [{result.status}] {result.last_message}\")\n            return result.status, result.last_message\n        \n        return None, None\n    \n    @property\n    def history_digest(self) -> str:\n        \"\"\"获取历史摘要\"\"\"\n        return self._history_digest\n\n\nclass DirectAgentStrategy(AgentStrategy):\n    \"\"\"直接代理策略，直接与助手交互\"\"\"\n    \n    def __init__(self):\n        self.agent_manager = DirectAgentManager()\n        self._history_digest = \"\"\n    \n    async def initialize(self) -> None:\n        \"\"\"初始化直接代理\"\"\"\n        self.agent_manager.init_agent()\n        logger.info(\"Session initialized with direct agent interaction\")\n    \n    async def process_message(self, text: str) -> Tuple[Optional[str], Optional[str]]:\n        \"\"\"处理用户消息，使用直接交互模式\"\"\"\n        # 确保代理已初始化\n        if not self.agent_manager.assistant:\n            await self.initialize()\n        \n        # 直接处理消息并获取响应\n        response = await self.agent_manager.process_message(text, self._history_digest)\n        \n        # 检查是否需要生成新的摘要\n        if \"goodbye\" in response.lower() or \"再见\" in response:\n            # 生成对话历史摘要\n            self._history_digest = await self.agent_manager.generate_digest()\n            logger.info(f\"Generated history digest: {self._history_digest}\")\n            \n            # 返回结束状态和响应\n            return \"finished\", response\n        \n        # 返回正常状态和响应\n        logger.info(f\"Sent response: {response[:100]}...\")\n        return \"user_input_requested\", response\n    \n    @property\n    def history_digest(self) -> str:\n        \"\"\"获取历史摘要\"\"\"\n        return self._history_digest\n\n\ndef create_agent_strategy(use_direct_agent: bool = False) -> AgentStrategy:\n    \"\"\"\n    创建代理策略\n    \n    Args:\n        use_direct_agent (bool): 是否使用直接代理交互模式\n        \n    Returns:\n        AgentStrategy: 代理策略实例\n    \"\"\"\n    if use_direct_agent:\n        return DirectAgentStrategy()\n    else:\n        return TeamAgentStrategy() "}
{"type": "source_file", "path": "server/__init__.py", "content": "\n"}
{"type": "source_file", "path": "server/agent_manager.py", "content": "import os\nimport logging\nimport asyncio\nfrom typing import Awaitable, Callable, Optional, Tuple\nfrom autogen_core import CancellationToken\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\nfrom autogen_agentchat.agents import AssistantAgent, UserProxyAgent\nfrom autogen_agentchat.teams import MagenticOneGroupChat\nfrom tools.ticktick import TaskManager\n\nlogger = logging.getLogger(__name__)\n\nclass UserInputHelper:\n    def __init__(self):\n        self.user_input_queue = asyncio.Queue()\n\n    def get_user_input_func(self) -> Callable[[str, Optional[CancellationToken]], Awaitable[str]]:\n        async def user_input(prompt: str, cancellation_token: Optional[CancellationToken]) -> str:\n            return await self.user_input_queue.get()\n\n        return user_input\n\n    async def recv_user_input(self, text: str):\n        await self.user_input_queue.put(text)\n\nclass AgentManager:\n    def __init__(self):\n        # 获取环境变量\n        self.api_key = os.getenv(\"OPENAI_API_KEY\")\n        self.ticktick_client_id = os.getenv(\"TICKTICK_CLIENT_ID\")\n        self.ticktick_client_secret = os.getenv(\"TICKTICK_CLIENT_SECRET\")\n        self.openroute_api_key = os.getenv(\"OPENROUTE_API_KEY\")\n        \n        if not all([self.api_key, self.ticktick_client_id, self.ticktick_client_secret]):\n            raise ValueError(\"Missing required environment variables\")\n        \n        if not isinstance(self.ticktick_client_id, str) or not isinstance(self.ticktick_client_secret, str):\n            raise TypeError(\"TickTick client_id and client_secret must be strings\")\n    \n    def init_agents(self) -> Tuple[AssistantAgent, UserProxyAgent, OpenAIChatCompletionClient, UserInputHelper]:\n        \"\"\"初始化代理和模型客户端\"\"\"\n        # 初始化任务管理器\n        task_manager = TaskManager(self.ticktick_client_id, self.ticktick_client_secret)\n\n        # 创建模型客户端\n        model_client = OpenAIChatCompletionClient(\n            model=\"anthropic/claude-3.7-sonnet\",\n            api_key=self.openroute_api_key,\n            base_url=\"https://openrouter.ai/api/v1\",\n            model_info={\n                \"vision\": False,\n                \"function_calling\": True,\n                \"json_output\": True,\n                \"family\": \"unknown\",\n            },\n            llm_config={\n                \"cache_seed\": 42,  # 启用缓存，种子为42\n                \"cache_path_root\": \".cache/llm_cache\"  # 指定缓存目录\n            }\n        )\n\n        # 创建任务管理助手\n        assistant = AssistantAgent(\n            name=\"task_assistant\",\n            system_message=\"\"\"\n            You are an expert task management assistant for TickTick's Inbox. You help users manage their tasks efficiently using the following capabilities:\n\n            Available Functions:\n\n            1. create_task(title, content='', due_date=None, start_date=None, is_all_day=True, priority=0)\n               - Creates a new task in Inbox with the following parameters:\n                 * title: Task title (required)\n                 * content: Task description\n                 * due_date: Due date in 'YYYY-MM-DD' format\n                 * start_date: Start date in 'YYYY-MM-DD' format\n                 * is_all_day: Whether it's an all-day task\n                 * priority: Task priority (0=none, 1=low, 3=medium, 5=high)\n\n            2. list_tasks()\n\n            3. complete_task(task_id)\n               - Marks a task as completed\n               - Requires task_id from list_tasks\n\n            4. delete_task(task_id)\n               - Removes a task from Inbox\n               - Requires task_id from list_tasks\n\n            5. get_tasks_by_date(start_date, end_date=None)\n               - Gets tasks within a date range:\n                 * start_date: Start date 'YYYY-MM-DD'\n                 * end_date: Optional end date 'YYYY-MM-DD'\n\n            6. get_completed_tasks()\n               - Retrieves all completed tasks from Inbox\n\n            Always follow these steps:\n            1. UNDERSTAND: Analyze the user's request carefully\n            2. VALIDATE: Ensure you have all required information\n            3. EXECUTE: Perform the requested operation\n            4. VERIFY: Check the result and provide clear feedback\n\n            Important Notes:\n            - All dates must be in 'YYYY-MM-DD' format\n            - Priority levels: 0=none, 1=low, 3=medium, 5=high\n            - All operations are performed in the Inbox\n            - Task IDs are required for complete_task and delete_task\n\n            Say 'goodbye' to end the conversation.\n            \"\"\",\n            tools=[\n                task_manager.create_task,\n                task_manager.list_tasks,\n                task_manager.complete_task,\n                task_manager.delete_task,\n                task_manager.get_tasks_by_date,\n                task_manager.get_completed_tasks\n            ],\n            model_client=model_client,\n            description='''An expert task management assistant for TickTick's Inbox. You help users manage their tasks efficiently using the following capabilities:\n\n            Available Functions:\n\n            1. create_task(title, content='', due_date=None, start_date=None, is_all_day=True, priority=0)\n               - Creates a new task in Inbox with the following parameters:\n                 * title: Task title (required)\n                 * content: Task description\n                 * due_date: Due date in 'YYYY-MM-DD' format\n                 * start_date: Start date in 'YYYY-MM-DD' format\n                 * is_all_day: Whether it's an all-day task\n                 * priority: Task priority (0=none, 1=low, 3=medium, 5=high)\n\n            2. list_tasks()\n\n            3. complete_task(task_id)\n               - Marks a task as completed\n               - Requires task_id from list_tasks\n\n            4. delete_task(task_id)\n               - Removes a task from Inbox\n               - Requires task_id from list_tasks\n\n            5. get_tasks_by_date(start_date, end_date=None)\n               - Gets tasks within a date range:\n                 * start_date: Start date 'YYYY-MM-DD'\n                 * end_date: Optional end date 'YYYY-MM-DD'\n\n            6. get_completed_tasks()\n               - Retrieves all completed tasks from Inbox\n            '''\n        )\n\n        user_input_helper = UserInputHelper()\n\n        # 创建用户代理\n        user_proxy = UserProxyAgent(\n            name=\"user\",\n            input_func=user_input_helper.get_user_input_func(),\n        )\n\n        return assistant, user_proxy, model_client, user_input_helper\n    \n    def create_team(self, assistant, user_proxy, model_client):\n        \"\"\"创建团队\"\"\"\n        return MagenticOneGroupChat(\n            participants=[user_proxy, assistant],\n            model_client=model_client,\n            max_turns=20,\n            max_stalls=3,\n            final_answer_prompt=\"最后必须给出答案总结\"\n        )\n    \n    def task_prompt(self, user_request: str, history_digest: str) -> str:\n        \"\"\"根据用户请求生成任务提示\"\"\"\n        task_description = \"\"\"{user_request}\"\"\"\n\n        if history_digest:\n            task_description += \"\"\"\n    ## Background Information\n    User's previous requests have been summarized as follows:\n    {history_digest}\n    \"\"\"\n        return task_description.format(user_request=user_request, history_digest=history_digest) "}
{"type": "source_file", "path": "server/agent_manager1.py", "content": "import os\nimport logging\nimport asyncio\nfrom typing import Awaitable, Callable, Optional, Tuple\nfrom autogen_core import CancellationToken\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\nfrom autogen_agentchat.agents import AssistantAgent\nfrom autogen_agentchat.messages import TextMessage\nfrom tools.ticktick import TaskManager\n\nlogger = logging.getLogger(__name__)\n\nclass UserInputHelper:\n    def __init__(self):\n        self.user_input_queue = asyncio.Queue()\n        self.response_queue = asyncio.Queue()\n\n    async def send_user_input(self, text: str):\n        \"\"\"发送用户输入到队列\"\"\"\n        await self.user_input_queue.put(text)\n    \n    async def get_response(self):\n        \"\"\"获取助手的响应\"\"\"\n        return await self.response_queue.get()\n    \n    async def send_response(self, text: str):\n        \"\"\"发送助手的响应到队列\"\"\"\n        await self.response_queue.put(text)\n\nclass AgentManager:\n    def __init__(self):\n        # 获取环境变量\n        self.api_key = os.getenv(\"OPENAI_API_KEY\")\n        self.ticktick_client_id = os.getenv(\"TICKTICK_CLIENT_ID\")\n        self.ticktick_client_secret = os.getenv(\"TICKTICK_CLIENT_SECRET\")\n        self.openroute_api_key = os.getenv(\"OPENROUTE_API_KEY\")\n        \n        if not all([self.api_key, self.ticktick_client_id, self.ticktick_client_secret]):\n            raise ValueError(\"Missing required environment variables\")\n        \n        if not isinstance(self.ticktick_client_id, str) or not isinstance(self.ticktick_client_secret, str):\n            raise TypeError(\"TickTick client_id and client_secret must be strings\")\n        \n        self.user_input_helper = UserInputHelper()\n        self.assistant = None\n        self.model_client = None\n        self.history = []\n    \n    def init_agent(self):\n        \"\"\"初始化助手代理\"\"\"\n        # 初始化任务管理器\n        task_manager = TaskManager(self.ticktick_client_id, self.ticktick_client_secret)\n\n        # 创建模型客户端\n        self.model_client = OpenAIChatCompletionClient(\n            model=\"anthropic/claude-3.7-sonnet\",\n            api_key=self.openroute_api_key,\n            base_url=\"https://openrouter.ai/api/v1\",\n            model_info={\n                \"vision\": False,\n                \"function_calling\": True,\n                \"json_output\": True,\n                \"family\": \"unknown\",\n            },\n            llm_config={\n                \"cache_seed\": 42,  # 启用缓存，种子为42\n                \"cache_path_root\": \".cache/llm_cache\"  # 指定缓存目录\n            }\n        )\n\n        # 创建任务管理助手\n        self.assistant = AssistantAgent(\n            name=\"task_assistant\",\n            system_message=\"\"\"\n            You are an expert task management assistant for TickTick's Inbox. You help users manage their tasks efficiently using the following capabilities:\n\n            Available Functions:\n\n            1. create_task(title, content='', due_date=None, start_date=None, is_all_day=True, priority=0)\n               - Creates a new task in Inbox with the following parameters:\n                 * title: Task title (required)\n                 * content: Task description\n                 * due_date: Due date in 'YYYY-MM-DD' format\n                 * start_date: Start date in 'YYYY-MM-DD' format\n                 * is_all_day: Whether it's an all-day task\n                 * priority: Task priority (0=none, 1=low, 3=medium, 5=high)\n\n            2. list_tasks()\n\n            3. complete_task(task_id)\n               - Marks a task as completed\n               - Requires task_id from list_tasks\n\n            4. delete_task(task_id)\n               - Removes a task from Inbox\n               - Requires task_id from list_tasks\n\n            5. get_tasks_by_date(start_date, end_date=None)\n               - Gets tasks within a date range:\n                 * start_date: Start date 'YYYY-MM-DD'\n                 * end_date: Optional end date 'YYYY-MM-DD'\n\n            6. get_completed_tasks()\n               - Retrieves all completed tasks from Inbox\n\n            Always follow these steps:\n            1. UNDERSTAND: Analyze the user's request carefully\n            2. VALIDATE: Ensure you have all required information\n            3. EXECUTE: Perform the requested operation\n            4. VERIFY: Check the result and provide clear feedback\n\n            Important Notes:\n            - All dates must be in 'YYYY-MM-DD' format\n            - Priority levels: 0=none, 1=low, 3=medium, 5=high\n            - All operations are performed in the Inbox\n            - Task IDs are required for complete_task and delete_task\n\n            At the end of your response, always provide a brief summary of what was accomplished or what the next steps should be.\n            \"\"\",\n            tools=[\n                task_manager.create_task,\n                task_manager.list_tasks,\n                task_manager.complete_task,\n                task_manager.delete_task,\n                task_manager.get_tasks_by_date,\n                task_manager.get_completed_tasks\n            ],\n            model_client=self.model_client\n        )\n        \n        logger.info(\"Task assistant initialized\")\n    \n    async def process_message(self, user_message: str, history_digest: str = \"\"):\n        \"\"\"\n        处理用户消息并获取助手的响应\n        \n        Args:\n            user_message (str): 用户的消息\n            history_digest (str, optional): 历史对话的摘要\n            \n        Returns:\n            str: 助手的响应\n        \"\"\"\n        if not self.assistant:\n            self.init_agent()\n        \n        # 准备消息，包含历史摘要（如果有）\n        prompt = user_message\n        if history_digest:\n            prompt = f\"{user_message}\\n\\n## Background Information\\nPrevious conversations summary: {history_digest}\"\n        \n        # 记录用户消息\n        self.history.append((\"user\", prompt))\n        \n        # 发送消息给助手并获取响应\n        response = await self.assistant.on_messages(\n            [TextMessage(content=prompt, source=\"user\")],\n            CancellationToken()\n        )\n        \n        # 获取助手的回复\n        assistant_response = response.chat_message.content\n        \n        # 记录助手的回复\n        self.history.append((\"assistant\", assistant_response))\n        \n        return assistant_response\n    \n    async def generate_digest(self):\n        \"\"\"\n        生成对话历史的摘要\n        \n        Returns:\n            str: 对话历史的摘要\n        \"\"\"\n        if not self.history:\n            return \"没有可用的对话历史。\"\n        \n        # 创建摘要专用的agent\n        summarizer = AssistantAgent(\n            name=\"Summarizer\",\n            system_message=\"你是一个专门负责总结对话的助手。你的任务是提取对话中的关键信息，并以列表形式返回重要的要点。\",\n            model_client=self.model_client\n        )\n        \n        # 将历史记录格式化为带编号的文本\n        history_text = \"\\n\".join([f\"{i+1}. [{msg[0]}] {msg[1]}\" for i, msg in enumerate(self.history)])\n        summary_prompt = (\n            \"请将以下对话历史总结为简明的关键点列表，\"\n            \"重点保留用户的意图和重要信息：\\n\\n\"\n            f\"{history_text}\\n\\n\"\n        )\n        \n        # 使用总结agent生成摘要\n        response = await summarizer.on_messages(\n            [TextMessage(content=summary_prompt, source=\"user\")],\n            CancellationToken()\n        )\n        \n        # 返回摘要文本\n        return response.chat_message.content\n    \n    def task_prompt(self, user_request: str, history_digest: str) -> str:\n        \"\"\"根据用户请求生成任务提示\"\"\"\n        task_description = \"\"\"{user_request}\"\"\"\n\n        if history_digest:\n            task_description += \"\"\"\n## Background Information\nUser's previous requests have been summarized as follows:\n{history_digest}\n\"\"\"\n        return task_description.format(user_request=user_request, history_digest=history_digest) "}
{"type": "source_file", "path": "tools/ticktick.py", "content": "from autogen_agentchat.agents import AssistantAgent\nfrom autogen_agentchat.messages import TextMessage\nfrom autogen_agentchat.ui import Console\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\nfrom autogen_core import CancellationToken\nfrom clients.ticktick import TickTickClient\nimport asyncio\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\nasync def get_weather(city: str) -> str:\n    \"\"\"Get the weather for a given city.\"\"\"\n    return f\"The weather in {city} is 73 degrees and Sunny.\"\n\nclass TaskManager:\n    def __init__(self, client_id: str, client_secret: str):\n        self.client = TickTickClient(client_id, client_secret)\n        self.client.authenticate()\n        \n    async def create_task(self, title: str, content: str = '', due_date: str = None, start_date: str = None, \n                         is_all_day: bool = True, priority: int = 0) -> dict:\n        \"\"\"创建新任务到 Inbox\n        \n        Args:\n            title (str): 任务标题\n            content (str, optional): 任务内容\n            due_date (str, optional): 到期日期，格式为 'YYYY-MM-DD'\n            start_date (str, optional): 开始日期，格式为 'YYYY-MM-DD'\n            is_all_day (bool, optional): 是否为全天任务\n            priority (int, optional): 优先级 0-5，0=无，1=低，3=中，5=高\n            \n        Returns:\n            dict: 创建的任务信息\n        \"\"\"\n        return self.client.create_task(\n            title=title,\n            content=content,\n            due_date=due_date,\n            start_date=start_date,\n            is_all_day=is_all_day,\n            priority=priority\n        )\n\n    async def list_tasks(self) -> str:\n        \"\"\"获取 Inbox 中的任务并转换为 markdown 格式\n        \n        Returns:\n            str: markdown 格式的任务列表\n        \"\"\"\n        tasks = self.client.get_inbox_tasks()\n        \n        if not tasks:\n            return \"# Inbox Tasks\\n\\nNo tasks found.\"\n            \n        markdown = \"# Inbox Tasks\\n\\n\"\n        \n        for task in tasks:\n            # 添加任务标题和内容\n            markdown += f\"## {task['title']}\\n\\n\"\n            \n            if task.get('content'):\n                markdown += f\"{task['content']}\\n\\n\"\n                \n            # 添加任务详情\n            details = []\n            if task.get('startDate'):\n                details.append(f\"- Start: {task['startDate']}\")\n            if task.get('dueDate'):\n                details.append(f\"- Due: {task['dueDate']}\")\n            if task.get('priority'):\n                priority_map = {1: \"Low\", 3: \"Medium\", 5: \"High\"}\n                details.append(f\"- Priority: {priority_map.get(task['priority'], 'Normal')}\")\n            if task.get('status') is not None:\n                status = \"Completed\" if task['status'] == 2 else \"In Progress\"\n                details.append(f\"- Status: {status}\")\n                \n            if details:\n                markdown += \"\\n\".join(details) + \"\\n\\n\"\n            \n            # 添加子任务\n            if task.get('items'):\n                markdown += \"### Subtasks\\n\\n\"\n                for item in task['items']:\n                    status_mark = \"✓\" if item.get('status') == 2 else \"☐\"\n                    markdown += f\"- {status_mark} {item['title']}\\n\"\n                markdown += \"\\n\"\n            \n            markdown += \"---\\n\\n\"\n            \n        return markdown.strip()\n\n    async def complete_task(self, task_id: str) -> None:\n        \"\"\"完成 Inbox 中的任务\n        \n        Args:\n            task_id (str): 任务ID\n        \"\"\"\n        return self.client.complete_task(task_id)\n\n    async def delete_task(self, task_id: str) -> None:\n        \"\"\"删除 Inbox 中的任务\n        \n        Args:\n            task_id (str): 任务ID\n        \"\"\"\n        return self.client.delete_task(task_id)\n        \n    async def get_tasks_by_date(self, start_date: str, end_date: str = None) -> list:\n        \"\"\"获取指定日期范围内的任务\n        \n        Args:\n            start_date (str): 开始日期，格式为 'YYYY-MM-DD'\n            end_date (str, optional): 结束日期，格式为 'YYYY-MM-DD'，如果不指定则只获取开始日期的任务\n            \n        Returns:\n            list: 指定日期范围内的任务列表\n        \"\"\"\n        if not end_date:\n            end_date = start_date\n        return self.client.get_inbox_tasks(start_date=start_date, end_date=end_date)\n        \n    async def get_completed_tasks(self) -> list:\n        \"\"\"获取所有已完成的任务\n        \n        Returns:\n            list: 已完成的任务列表\n        \"\"\"\n        tasks = self.client.get_inbox_tasks(include_completed=True)\n        return [task for task in tasks if task.get('status') == 2]\n\nasync def main() -> None:\n    # Get the required environment variables\n    api_key = os.getenv(\"OPENAI_API_KEY\")\n    ticktick_client_id = os.getenv(\"TICKTICK_CLIENT_ID\")\n    ticktick_client_secret = os.getenv(\"TICKTICK_CLIENT_SECRET\")\n    \n    if not api_key:\n        raise ValueError(\"OPENAI_API_KEY environment variable is not set\")\n    if not ticktick_client_id or not ticktick_client_secret:\n        raise ValueError(\"TICKTICK_CLIENT_ID and TICKTICK_CLIENT_SECRET environment variables must be set\")\n\n    # Create the model client with API key\n    model_client = OpenAIChatCompletionClient(\n        model=\"gpt-4\",\n        api_key=api_key,\n    )\n    \n    # Initialize task manager\n    task_manager = TaskManager(ticktick_client_id, ticktick_client_secret)\n    \n    # Create the assistant agent\n    agent = AssistantAgent(\n        name=\"task_agent\",\n        model_client=model_client,\n        tools=[\n            task_manager.create_task,\n            task_manager.list_tasks,\n            task_manager.complete_task,\n            task_manager.delete_task\n        ],\n        system_message=\"You are a helpful task management assistant. You can help users manage their tasks in TickTick by creating, listing, completing, and deleting tasks.\",\n    )\n\n    # Create a message and get response\n    message = TextMessage(content=\"List all my tasks\", source=\"user\")\n    response = await agent.on_messages(\n        [message],\n        cancellation_token=CancellationToken(),\n    )\n    \n    # Print both the thought process and final response\n    print(\"\\nThought process:\")\n    if response.inner_messages:\n        for msg in response.inner_messages:\n            print(f\"\\n{msg}\")\n    else:\n        print(\"No detailed thought process available\")\n    \n    print(\"\\nFinal response:\")\n    print(response.chat_message.content)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())"}
{"type": "source_file", "path": "server/session_handler.py", "content": "import logging\nfrom typing import Optional, Tuple\nfrom server.audio_processor import AudioProcessor\nfrom server.agent_strategy import create_agent_strategy, AgentStrategy\n\nlogger = logging.getLogger(__name__)\n\nclass SessionHandler:\n    def __init__(self, use_direct_agent=False):\n        \"\"\"\n        初始化SessionHandler\n        \n        Args:\n            use_direct_agent (bool): 是否使用直接代理交互模式，默认为False（使用团队模式）\n        \"\"\"\n        self.audio_processor = AudioProcessor()\n        # 使用工厂函数创建适当的策略\n        self.strategy: AgentStrategy = create_agent_strategy(use_direct_agent)\n    \n    async def initialize(self):\n        \"\"\"初始化会话，创建代理和团队\"\"\"\n        await self.strategy.initialize()\n    \n    async def handle_message(self, data: str) -> Tuple[Optional[str], Optional[str]]:\n        \"\"\"\n        处理来自客户端的消息\n        \n        Args:\n            data (str): 客户端发送的数据\n            \n        Returns:\n            tuple: (status, message) 状态和消息内容\n        \"\"\"\n        try:\n            # 处理输入数据\n            if data.startswith('data:'):\n                # 处理音频数据\n                text = self.audio_processor.process_audio(data)\n            else:\n                # 直接处理文本数据\n                text = data\n                logger.info(f\"Received text data: {text}\")\n\n            if text is None or text == \"\":\n                return None, None\n\n            # 使用策略处理消息\n            return await self.strategy.process_message(text)\n                \n        except Exception as e:\n            error_msg = f\"Error processing request: {str(e)}\"\n            logger.error(error_msg, exc_info=True)\n            return \"error\", error_msg\n    \n    @property\n    def history_digest(self) -> str:\n        \"\"\"获取历史摘要\"\"\"\n        return self.strategy.history_digest "}
{"type": "source_file", "path": "tools/__init__.py", "content": "\n"}
{"type": "source_file", "path": "server/oai_realtime.py", "content": "from flask import Blueprint, request, jsonify, send_from_directory\nimport openai\nimport os\nimport requests\nfrom dotenv import load_dotenv\nimport logging\n\n# 配置日志\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n# 加载环境变量\nload_dotenv()\n\n# 初始化 OpenAI 客户端\napi_key = os.getenv('OPENAI_API_KEY')\nif not api_key:\n    raise ValueError('OPENAI_API_KEY environment variable is not set')\n\nclient = openai.OpenAI(api_key=api_key)\n\n# 创建 Blueprint\noai_bp = Blueprint('oai', __name__)\n\n# 添加静态文件路由\n@oai_bp.route('/')\ndef serve_index():\n    return send_from_directory('static', 'index1.html')\n\n@oai_bp.route('/get_token', methods=['GET'])\ndef get_token():\n    try:\n        # 请求OpenAI的ephemeral token\n        response = requests.post(\n            'https://api.openai.com/v1/realtime/sessions',\n            headers={\n                'Authorization': f'Bearer {api_key}',\n                'Content-Type': 'application/json'\n            },\n            json={\n                'model': 'gpt-4o-realtime-preview-2024-12-17',\n                'voice': 'verse'\n            }\n        )\n        response.raise_for_status()\n        data = response.json()\n        \n        logger.info('Successfully obtained ephemeral token')\n        # 直接返回OpenAI的响应\n        return jsonify(data)\n    except Exception as e:\n        logger.error(f'Error getting token: {str(e)}')\n        return jsonify({'error': str(e)}), 500\n\n@oai_bp.route('/process_command', methods=['POST'])\ndef process_command():\n    try:\n        data = request.json\n        command = data.get('command')\n        if not command:\n            return jsonify({'error': 'No command provided'}), 400\n\n        logger.info(f'Received command: {command}')\n        # 这里可以调用app.py中的相应功能来处理命令\n        # TODO: 集成你的Ticktick功能处理逻辑\n        \n        return jsonify({'status': 'success', 'message': f'Processing command: {command}'})\n    except Exception as e:\n        logger.error(f'Error processing command: {str(e)}')\n        return jsonify({'error': 'Failed to process command'}), 500\n\n"}
{"type": "source_file", "path": "session.py", "content": "import asyncio\nimport logging\nfrom typing import Optional, Any\nfrom enum import Enum\nfrom autogen_core import CancellationToken\n\nfrom pydantic import InstanceOf\nfrom autogen_agentchat.messages import TextMessage\nfrom autogen_agentchat.ui._console import Console\nfrom autogen_agentchat.teams._group_chat._base_group_chat import BaseGroupChat\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\nfrom autogen_agentchat.base import Response, TaskResult\nfrom autogen_agentchat.messages import (\n    AgentEvent,\n    ChatMessage,\n    ModelClientStreamingChunkEvent,\n    MultiModalMessage,\n    UserInputRequestedEvent,\n)\n\nclass SessionResult(Enum):\n    USER_INPUT_REQUESTED = \"user_input_requested\"\n    FINISHED = \"finished\"\n\n    def __init__(self, status: str):\n        self.status = status\n        self.last_message: Optional[str] = None\n\nclass Session:\n    def __init__(self, team: BaseGroupChat, model_client:OpenAIChatCompletionClient):\n        \"\"\"\n        Initialize Session class.\n        \n        Args:\n            team: Chat team instance (e.g., MagenticOneGroupChat).\n            model_client: Model client for chat.\n        \"\"\"\n        self._team = team\n        self._model_client = model_client\n        self._stream = None  # Current conversation stream\n        self._task = None  # Async task for executing the stream\n        self._input_queue = asyncio.Queue()  # Create input queue\n        self._text_history = []  # List to store (content, source) tuples\n        self._is_finished = False  # Add finished state flag\n\n    @property\n    def is_active(self) -> bool:\n        \"\"\"Check if the session is currently active.\"\"\"\n        return self._stream is not None and not self._is_finished\n\n    def start(self, text: str):\n        \"\"\"\n        Start a new session, create stream and start execution task.\n        \n        Args:\n            text (str): Initial user input.\n        \"\"\"\n        if self.is_active:\n            logging.warning(\"Active session exists, cannot create new session.\")\n            return\n\n        # Create new stream\n        self._stream = self._team.run_stream(task=text)\n        self._is_finished = False  # Reset finished state when starting new session\n\n    def get_history(self) -> list[str]:\n        \"\"\"Get the conversation history.\n\n        Returns:\n            list[str]: List of messages in the conversation history.\n        \"\"\"\n        return self._text_history.copy()\n\n    async def run_until_stop(self) -> SessionResult:\n        result = SessionResult.USER_INPUT_REQUESTED\n\n        async for message in self._stream:\n            if isinstance(message, TextMessage):\n                self._text_history.append((message.content, message.source))\n\n            elif isinstance(message, UserInputRequestedEvent):\n                result = SessionResult.USER_INPUT_REQUESTED\n                break\n\n            elif isinstance(message, TaskResult):\n                result = SessionResult.FINISHED\n                self._is_finished = True\n                break\n        \n        if self._text_history:\n            result.last_message = self._text_history[-1][0]  # Get content from the tuple\n\n        return result\n\n    async def digest(self) -> list[str]:\n        \"\"\"\n        使用专门的总结agent生成对话历史的摘要。\n\n        返回:\n            list[str]: 包含关键点的摘要列表。\n        \"\"\"\n        # 检查历史记录是否为空\n        if not self._text_history:\n            return [\"没有可用的对话历史。\"]\n\n        from autogen_agentchat.agents import AssistantAgent\n\n        # 创建总结专用的agent\n        summarizer = AssistantAgent(\n            name=\"Summarizer\",\n            system_message=\"你是一个专门负责总结对话的助手。你的任务是提取对话中的关键信息，并以列表形式返回重要的要点。\",\n            model_client=self._model_client\n        )\n\n        # 将历史记录格式化为带编号的文本\n        history_text = \"\\n\".join([f\"{i+1}. [{msg[1]}] {msg[0]}\" for i, msg in enumerate(self._text_history)])\n        summary_prompt = (\n            \"请将以下对话历史总结为简明的关键点列表，\"\n            \"重点保留用户的意图和重要信息：\\n\\n\"\n            f\"{history_text}\\n\\n\"\n        )\n\n        # 使用总结agent生成摘要\n        response = await summarizer.on_messages(\n            [TextMessage(content=summary_prompt, source=\"user\")],\n            CancellationToken()\n        )\n        \n        # 返回摘要文本\n        return response.chat_message.content\n"}
{"type": "source_file", "path": "clients/ticktick/client.py", "content": "import requests\nfrom urllib.parse import urlencode\nimport http.server\nimport socketserver\nimport webbrowser\nfrom urllib.parse import parse_qs, urlparse\nimport threading\nimport json\nimport os\nfrom datetime import datetime, timedelta\n\nclass OAuthCallbackHandler(http.server.SimpleHTTPRequestHandler):\n    auth_code = None\n    \n    def do_GET(self):\n        \"\"\"处理回调请求\"\"\"\n        query_components = parse_qs(urlparse(self.path).query)\n        \n        # 获取授权码\n        if 'code' in query_components:\n            OAuthCallbackHandler.auth_code = query_components['code'][0]\n            # 发送成功响应\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b\"Authorization successful! You can close this window.\")\n        else:\n            self.send_response(400)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b\"Authorization failed! No code received.\")\n\nclass TickTickClient:\n    def __init__(self, client_id, client_secret, redirect_uri='http://localhost:8080/callback'):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.redirect_uri = redirect_uri\n        self.base_url = 'https://api.ticktick.com/open/v1'\n        self.auth_url = 'https://ticktick.com/oauth/authorize'\n        self.token_url = 'https://ticktick.com/oauth/token'\n        self.access_token = None\n        self.token_file = 'ticktick_token.json'\n        self.projects = {}  # 缓存项目信息\n        self.inbox_id = None  # 存储 Inbox ID\n        self.load_token()\n        if self.access_token:\n            self.load_projects()\n        \n    def create_task(self, title, project_name=None, due_date=None, content='', start_date=None, \n                  is_all_day=True, time_zone='UTC', priority=0, reminders=None, repeat=None):\n        \"\"\"创建新任务\n        \n        Args:\n            title (str): 任务标题\n            project_name (str, optional): 项目名称，如果不指定则使用 Inbox\n            due_date (str, optional): 到期日期，格式为 'YYYY-MM-DD' 或 'YYYY-MM-DDTHH:mm:ss.SSSZ'\n            content (str, optional): 任务内容\n            start_date (str, optional): 开始日期，格式为 'YYYY-MM-DD' 或 'YYYY-MM-DDTHH:mm:ss.SSSZ'\n            is_all_day (bool, optional): 是否为全天任务\n            time_zone (str, optional): 时区，默认为 UTC\n            priority (int, optional): 优先级 0-5\n            reminders (list, optional): 提醒时间列表，格式为 ISO 时间字符串\n            repeat (dict, optional): 重复规则，包含 freq, interval, until 等字段\n            \n        Returns:\n            dict: 创建的任务信息\n        \"\"\"\n        if not self.access_token:\n            raise ValueError('Not authenticated. Please authenticate first.')\n            \n        # 确保项目列表是最新的\n        self.load_projects()\n        \n        # 确定项目 ID\n        project_id = self.inbox_id\n        if project_name:\n            project_id = next(\n                (p['id'] for p in self.projects.values() if p['name'].lower() == project_name.lower()),\n                None\n            )\n            if not project_id:\n                # 如果项目不存在，创建新项目\n                project = self.create_project(project_name)\n                project_id = project['id']\n        \n        if not project_id:\n            raise ValueError('No project ID available. Make sure you are authenticated and have access to projects.')\n            \n        url = f'{self.base_url}/task'\n        headers = {\n            'Authorization': f'Bearer {self.access_token}',\n            'Content-Type': 'application/json'\n        }\n        \n        task_data = {\n            'title': title,\n            'projectId': project_id,\n            'content': content,\n            'isAllDay': is_all_day,\n            'timeZone': time_zone,\n            'priority': priority\n        }\n        \n        # 处理日期\n        if due_date:\n            # 如果只提供了日期部分，添加时间部分\n            if len(due_date) == 10:  # YYYY-MM-DD 格式\n                due_date = f\"{due_date}T00:00:00.000Z\"\n            task_data['dueDate'] = due_date\n            \n        if start_date:\n            if len(start_date) == 10:  # YYYY-MM-DD 格式\n                start_date = f\"{start_date}T00:00:00.000Z\"\n            task_data['startDate'] = start_date\n            \n        # 处理提醒\n        if reminders:\n            task_data['reminders'] = reminders\n            \n        # 处理重复规则\n        if repeat:\n            task_data['repeat'] = repeat\n            \n        response = requests.post(url, headers=headers, json=task_data)\n        \n        if response.status_code in [200, 201]:\n            task_data = response.json()\n            # 如果是 Inbox 任务，保存 Inbox ID\n            if not project_name and not self.inbox_id:\n                self.inbox_id = task_data['projectId']\n            return task_data\n        elif response.status_code == 401:\n            raise Exception('Unauthorized: Invalid access token')\n        elif response.status_code == 400:\n            raise Exception(f'Bad request: {response.text}')\n        else:\n            raise Exception(f'Error creating task: {response.status_code} - {response.text}')\n    \n    def get_tasks(self, project_name=None, start_date=None, end_date=None):\n        \"\"\"获取任务列表\n        \n        Args:\n            project_name (str, optional): 项目名称，如果不指定则获取所有任务\n            start_date (str, optional): 开始日期，格式为 'YYYY-MM-DD'\n            end_date (str, optional): 结束日期，格式为 'YYYY-MM-DD'\n        \n        Returns:\n            list: 任务列表\n        \"\"\"\n        if not self.access_token:\n            raise ValueError('Not authenticated. Please authenticate first.')\n            \n        headers = {'Authorization': f'Bearer {self.access_token}'}\n        \n        # 确保项目列表是最新的\n        self.load_projects()\n        \n        if project_name:\n            # 获取指定项目的任务\n            project_id = next(\n                (p['id'] for p in self.projects.values() if p['name'].lower() == project_name.lower()),\n                None\n            )\n            if not project_id:\n                raise ValueError(f'Project {project_name} not found')\n                \n            project_data = self.get_project_data(project_id)\n            tasks = project_data.get('tasks', [])\n            \n            # 添加项目信息到任务中\n            for task in tasks:\n                task['project'] = {\n                    'id': project_id,\n                    'name': project_name,\n                    'isInbox': False\n                }\n            return tasks\n        else:\n            # 获取所有项目的任务\n            all_tasks = []\n            for project in self.projects.values():\n                try:\n                    project_data = self.get_project_data(project['id'])\n                    tasks = project_data.get('tasks', [])\n                    # 添加项目信息到任务中\n                    for task in tasks:\n                        task['project'] = {\n                            'id': project['id'],\n                            'name': project['name'],\n                            'isInbox': project.get('isInbox', False)\n                        }\n                    all_tasks.extend(tasks)\n                except Exception as e:\n                    print(f\"Warning: Failed to get tasks for project {project['name']}: {e}\")\n                    continue\n            return all_tasks\n    \n    def update_task(self, task_id, updates):\n        \"\"\"更新任务\n        \n        Args:\n            task_id (str): 任务ID\n            updates (dict): 需要更新的字段，支持以下字段：\n                - title (str): 任务标题\n                - content (str): 任务内容\n                - desc (str): 任务描述\n                - isAllDay (bool): 是否为全天任务\n                - startDate (str): 开始时间，格式：\"2019-11-13T03:00:00+0000\"\n                - dueDate (str): 截止时间，格式：\"2019-11-13T03:00:00+0000\"\n                - timeZone (str): 时区，例如：\"America/Los_Angeles\"\n                - priority (int): 优先级（0：无，1：低，3：中，5：高）\n                - reminders (list): 提醒时间列表\n                - items (list): 子任务列表\n            \n        Returns:\n            dict: 更新后的任务信息\n        \"\"\"\n        if not self.access_token:\n            raise ValueError('Not authenticated. Please authenticate first.')\n            \n        # 先获取现有任务信息\n        task = None\n        project_id = None\n        for project in self.projects.values():\n            try:\n                task = self.get_task_by_id(project['id'], task_id)\n                if task:\n                    project_id = project['id']\n                    break\n            except:\n                continue\n                \n        if not task:\n            raise ValueError(f'Task not found: {task_id}')\n            \n        # 构建更新数据\n        update_data = {\n            'id': task_id,\n            'projectId': project_id\n        }\n        \n        # 保留原有数据\n        for key in ['title', 'content', 'desc', 'isAllDay', 'startDate', 'dueDate', \n                    'timeZone', 'priority', 'reminders', 'items', 'sortOrder']:\n            if key in task:\n                update_data[key] = task[key]\n        \n        # 应用更新\n        update_data.update(updates)\n        \n        # 发送更新请求\n        url = f'{self.base_url}/task/{task_id}'\n        headers = {\n            'Authorization': f'Bearer {self.access_token}',\n            'Content-Type': 'application/json'\n        }\n        \n        response = requests.post(url, headers=headers, json=update_data)\n        \n        if response.status_code in [200, 201]:\n            return response.json()\n        elif response.status_code == 401:\n            raise Exception('Unauthorized: Invalid access token')\n        elif response.status_code == 404:\n            raise Exception(f'Task not found: {task_id}')\n        else:\n            raise Exception(f'Error updating task: {response.status_code} - {response.text}')\n    \n    def delete_task(self, task_id):\n        \"\"\"删除任务\n        \n        Args:\n            task_id (str): 任务ID\n        \"\"\"\n        if not self.access_token:\n            raise ValueError('Not authenticated. Please authenticate first.')\n            \n        # 先获取任务所属的项目\n        project_id = None\n        for project in self.projects.values():\n            try:\n                task = self.get_task_by_id(project['id'], task_id)\n                if task:\n                    project_id = project['id']\n                    break\n            except:\n                continue\n                \n        if not project_id:\n            raise ValueError(f'Task not found: {task_id}')\n            \n        url = f'{self.base_url}/project/{project_id}/task/{task_id}'\n        headers = {'Authorization': f'Bearer {self.access_token}'}\n        \n        response = requests.delete(url, headers=headers)\n        \n        if response.status_code not in [200, 201, 204]:\n            if response.status_code == 401:\n                raise Exception('Unauthorized: Invalid access token')\n            elif response.status_code == 404:\n                raise Exception(f'Task not found: {task_id}')\n            else:\n                raise Exception(f'Error deleting task: {response.status_code} - {response.text}')\n                \n    def complete_task(self, task_id):\n        \"\"\"完成任务\n        \n        Args:\n            task_id (str): 任务ID\n        \"\"\"\n        if not self.access_token:\n            raise ValueError('Not authenticated. Please authenticate first.')\n            \n        # 先获取任务所属的项目\n        project_id = None\n        for project in self.projects.values():\n            try:\n                task = self.get_task_by_id(project['id'], task_id)\n                if task:\n                    project_id = project['id']\n                    break\n            except:\n                continue\n                \n        if not project_id:\n            raise ValueError(f'Task not found: {task_id}')\n            \n        url = f'{self.base_url}/project/{project_id}/task/{task_id}/complete'\n        headers = {'Authorization': f'Bearer {self.access_token}'}\n        \n        response = requests.post(url, headers=headers)\n        \n        if response.status_code not in [200, 201]:\n            if response.status_code == 401:\n                raise Exception('Unauthorized: Invalid access token')\n            elif response.status_code == 404:\n                raise Exception(f'Task not found: {task_id}')\n            else:\n                raise Exception(f'Error completing task: {response.status_code} - {response.text}')\n        \n    def load_projects(self):\n        \"\"\"加载所有项目信息\"\"\"\n        if not self.access_token:\n            return\n            \n        url = f'{self.base_url}/project'\n        headers = {'Authorization': f'Bearer {self.access_token}'}\n        \n        try:\n            response = requests.get(url, headers=headers)\n            response.raise_for_status()\n            projects = response.json()\n            \n            # 将项目信息存储在字典中\n            self.projects = {p['id']: p for p in projects}\n            \n            # 设置 Inbox ID\n            inbox = next((p for p in projects if p.get('kind') == 'INBOX'), None)\n            if inbox:\n                self.inbox_id = inbox['id']\n        except Exception as e:\n            print(f'Error loading projects: {e}')\n            \n    def create_project(self, name, color=None, view_mode='list', kind='TASK'):\n        \"\"\"创建新项目\n        \n        Args:\n            name (str): 项目名称\n            color (str, optional): 项目颜色，例如 '#F18181'\n            view_mode (str, optional): 视图模式，'list', 'kanban', 或 'timeline'\n            kind (str, optional): 项目类型，'TASK' 或 'NOTE'\n            \n        Returns:\n            dict: 创建的项目信息\n        \"\"\"\n        if not self.access_token:\n            raise ValueError('Not authenticated. Please authenticate first.')\n            \n        url = f'{self.base_url}/project'\n        headers = {\n            'Authorization': f'Bearer {self.access_token}',\n            'Content-Type': 'application/json'\n        }\n        \n        project_data = {\n            'name': name,\n            'viewMode': view_mode,\n            'kind': kind.upper()\n        }\n        if color:\n            project_data['color'] = color\n        \n        response = requests.post(url, headers=headers, json=project_data)\n        response.raise_for_status()\n        \n        # 更新项目缓存\n        project = response.json()\n        self.projects[project['id']] = project\n        return project\n        \n    def save_inbox_id(self):\n        \"\"\"保存 Inbox ID 到文件\"\"\"\n        if self.inbox_id:\n            with open(self.inbox_id_file, 'w') as f:\n                f.write(self.inbox_id)\n                \n    def save_token(self, token_data):\n        \"\"\"保存访问令牌到文件\n        \n        Args:\n            token_data (dict): 包含 access_token 和 expires_in 的字典\n        \"\"\"\n        token_info = {\n            'access_token': token_data['access_token'],\n            'expires_at': (datetime.now() + timedelta(seconds=token_data['expires_in'])).isoformat(),\n            'token_type': token_data['token_type'],\n            'scope': token_data['scope']\n        }\n        \n        with open(self.token_file, 'w') as f:\n            json.dump(token_info, f, indent=2)\n        \n        self.access_token = token_data['access_token']\n        \n    def load_token(self):\n        \"\"\"从文件加载访问令牌\"\"\"\n        if not os.path.exists(self.token_file):\n            return False\n            \n        try:\n            with open(self.token_file, 'r') as f:\n                token_info = json.load(f)\n                \n            # 检查令牌是否过期\n            expires_at = datetime.fromisoformat(token_info['expires_at'])\n            if datetime.now() < expires_at:\n                self.access_token = token_info['access_token']\n                return True\n            else:\n                os.remove(self.token_file)  # 删除过期的令牌文件\n                return False\n        except Exception as e:\n            print(f\"加载令牌时出错: {e}\")\n            return False\n            \n    def authenticate(self, port=8080, force_new=False):\n        \"\"\"完整的认证流程\n        \n        Args:\n            port (int): 本地服务器端口号\n            force_new (bool): 是否强制获取新的令牌，即使现有令牌仍然有效\n        \"\"\"\n        # 如果不是强制刷新，且已有有效的访问令牌，则直接返回\n        if not force_new and self.access_token:\n            return {'access_token': self.access_token}\n            \n        redirect_uri = f'http://localhost:{port}'\n        \n        # 重置授权码\n        OAuthCallbackHandler.auth_code = None\n        \n        # 启动本地服务器\n        server = socketserver.TCPServer((\"\", port), OAuthCallbackHandler)\n        server.timeout = 60  # 设置超时时间为60秒\n        \n        # 获取授权URL并打开浏览器\n        auth_url = self.get_auth_url(redirect_uri)\n        print(f\"\\n请在浏览器中访问以下URL进行授权:\")\n        print(auth_url)\n        webbrowser.open(auth_url)\n        \n        print(f\"\\n等待授权中... 请在浏览器中完成授权\")\n        \n        # 等待回调\n        while OAuthCallbackHandler.auth_code is None:\n            server.handle_request()\n        \n        # 关闭服务器\n        server.server_close()\n        \n        # 获取授权码\n        auth_code = OAuthCallbackHandler.auth_code\n        \n        if auth_code:\n            print(\"\\n成功获取授权码！正在获取访问令牌...\")\n            # 使用授权码获取访问令牌\n            token_data = self.get_access_token(auth_code, redirect_uri)\n            # 保存令牌\n            self.save_token(token_data)\n            return token_data\n        else:\n            raise Exception(\"未能获取授权码\")\n        \n    def get_auth_url(self, redirect_uri, state=None):\n        \"\"\"获取授权URL\"\"\"\n        params = {\n            'client_id': self.client_id,\n            'response_type': 'code',\n            'redirect_uri': redirect_uri,\n            'scope': 'tasks:read tasks:write'\n        }\n        if state:\n            params['state'] = state\n        return f\"{self.auth_url}?{urlencode(params)}\"\n    \n    def get_access_token(self, code, redirect_uri):\n        \"\"\"使用授权码获取访问令牌\"\"\"\n        data = {\n            'client_id': self.client_id,\n            'client_secret': self.client_secret,\n            'code': code,\n            'grant_type': 'authorization_code',\n            'redirect_uri': redirect_uri\n        }\n        response = requests.post(self.token_url, data=data)\n        if response.status_code == 200:\n            token_data = response.json()\n            return token_data\n        else:\n            raise Exception(f'Error getting access token: {response.status_code} - {response.text}')\n\n    def get_projects(self):\n        \"\"\"获取项目列表\"\"\"\n        if not self.access_token:\n            raise Exception('Access token not set. Please authenticate first.')\n            \n        headers = {'Authorization': f'Bearer {self.access_token}'}\n        response = requests.get('https://api.ticktick.com/open/v1/project', headers=headers)\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise Exception(f'Error fetching projects: {response.status_code} - {response.text}')\n\n    def get_project_data(self, project_id: str):\n        \"\"\"获取项目详细数据，包括所有任务\n        \n        Args:\n            project_id (str): 项目ID\n            \n        Returns:\n            dict: 包含项目信息、任务列表和列信息的字典\n                - project: 项目信息\n                - tasks: 未完成的任务列表\n                - columns: 项目的列信息（看板视图）\n        \"\"\"\n        if not self.access_token:\n            raise Exception('Access token not set. Please authenticate first.')\n            \n        headers = {'Authorization': f'Bearer {self.access_token}'}\n        url = f'https://api.ticktick.com/open/v1/project/{project_id}/data'\n        \n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            return response.json()\n        elif response.status_code == 404:\n            raise Exception(f'Project not found: project_id={project_id}')\n        elif response.status_code == 401:\n            raise Exception('Unauthorized: Invalid access token')\n        elif response.status_code == 403:\n            raise Exception('Forbidden: No permission to access this project')\n        else:\n            raise Exception(f'Error fetching project data: {response.status_code} - {response.text}')\n\n    def get_task_by_id(self, project_id: str, task_id: str):\n        \"\"\"获取特定项目中的特定任务\n        \n        Args:\n            project_id (str): 项目ID\n            task_id (str): 任务ID\n            \n        Returns:\n            dict: 任务详情，包含以下字段：\n                - id: 任务ID\n                - title: 任务标题\n                - content: 任务内容\n                - desc: 任务描述\n                - isAllDay: 是否全天任务\n                - projectId: 所属项目ID\n                - timeZone: 时区\n                - startDate: 开始时间\n                - dueDate: 截止时间\n                - priority: 优先级（0：无，1：低，3：中，5：高）\n                - status: 状态（0：正常，2：已完成）\n                - completedTime: 完成时间\n                - items: 子任务列表\n        \"\"\"\n        if not self.access_token:\n            raise Exception('Access token not set. Please authenticate first.')\n            \n        headers = {'Authorization': f'Bearer {self.access_token}'}\n        url = f'https://api.ticktick.com/open/v1/project/{project_id}/task/{task_id}'\n        \n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            return response.json()\n        elif response.status_code == 404:\n            raise Exception(f'Task not found: project_id={project_id}, task_id={task_id}')\n        elif response.status_code == 401:\n            raise Exception('Unauthorized: Invalid access token')\n        elif response.status_code == 403:\n            raise Exception('Forbidden: No permission to access this task')\n        else:\n            raise Exception(f'Error fetching task: {response.status_code} - {response.text}')\n\n    def _get_inbox_id(self):\n        \"\"\"获取用户的 Inbox ID\n        \n        通过创建一个临时任务到 Inbox 来获取实际的 Inbox ID，\n        然后删除这个临时任务。\n        \n        Returns:\n            str: Inbox ID\n        \"\"\"\n        if not self.access_token:\n            raise Exception('Access token not set. Please authenticate first.')\n            \n        # 创建一个临时任务到 Inbox\n        headers = {\n            'Authorization': f'Bearer {self.access_token}',\n            'Content-Type': 'application/json'\n        }\n        \n        temp_task = {\n            'title': '_temp_task_for_inbox_id',\n            'projectId': 'inbox'\n        }\n        \n        # 创建临时任务\n        create_response = requests.post(\n            'https://api.ticktick.com/open/v1/task',\n            headers=headers,\n            json=temp_task\n        )\n        \n        if create_response.status_code not in [200, 201]:\n            raise Exception(f'Error creating temp task: {create_response.status_code} - {create_response.text}')\n            \n        # 从响应中获取 Inbox ID\n        task_data = create_response.json()\n        inbox_id = task_data['projectId']\n        \n        # 删除临时任务\n        delete_response = requests.delete(\n            f'https://api.ticktick.com/open/v1/project/{inbox_id}/task/{task_data[\"id\"]}',\n            headers=headers\n        )\n        \n        if delete_response.status_code not in [200, 204]:\n            print(f'Warning: Failed to delete temp task: {delete_response.status_code} - {delete_response.text}')\n            \n        return inbox_id\n        \n    def get_inbox_tasks(self):\n        \"\"\"获取 Inbox 中的任务列表\n        \n        Returns:\n            list: Inbox 中的任务列表\n        \"\"\"\n        if not self.access_token:\n            raise Exception('Access token not set. Please authenticate first.')\n            \n        # 如果还没有获取过 Inbox ID，先获取它\n        if not self.inbox_id:\n            self.inbox_id = self._get_inbox_id()\n            \n        # 使用 get_project_data 方法获取 Inbox 数据\n        inbox_data = self.get_project_data(self.inbox_id)\n        return inbox_data['tasks']\n\n\nif __name__ == '__main__':\n    # 初始化客户端\n    client = TickTickClient(\n        client_id='UJ40V4rQz3AiQ7Hc45',\n        client_secret='7X#q$(XzcB8q3^v9Pk88j!4LwBhYH)Bf'\n    )\n    \n    # 自动完成认证流程\n    token_data = client.authenticate()\n    print(\"\\n成功获取访问令牌:\", token_data)\n    \n    # 获取 Inbox 中的任务\n    try:\n        inbox_tasks = client.get_inbox_tasks()\n        print(\"\\nInbox 中的任务:\")\n        for task in inbox_tasks:\n            print(f\"- {task['title']} (ID: {task['id']})\")\n    except Exception as e:\n        print(f\"\\n获取 Inbox 任务失败: {e}\")\n        \n    # 创建一个新的 Inbox 任务\n    try:\n        new_task = client.create_task(\n            project_id=\"inbox\",  # 使用 \"inbox\" 作为项目ID\n            title=\"Inbox 测试任务 2\",\n            content=\"这是第二个添加到 Inbox 的测试任务\",\n            isAllDay=True\n        )\n        print(\"\\n创建的 Inbox 任务:\", new_task)\n    except Exception as e:\n        print(f\"\\n创建 Inbox 任务失败: {e}\")\n"}

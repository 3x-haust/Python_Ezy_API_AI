{"repo_info": {"repo_name": "calendar", "repo_owner": "PythonFreeCourse", "repo_url": "https://github.com/PythonFreeCourse/calendar"}}
{"type": "test_file", "path": "tests/association_fixture.py", "content": "import pytest\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Event, UserEvent\n\n\n@pytest.fixture\ndef association(event: Event, session: Session) -> UserEvent:\n    return (\n        session.query(UserEvent)\n        .filter(UserEvent.event_id == event.id)\n    ).first()\n"}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/asyncio_fixture.py", "content": "from datetime import datetime, timedelta\n\nfrom httpx import AsyncClient\nimport pytest\n\nfrom app.database.models import Base\nfrom app.main import app\nfrom app.routers import telegram\nfrom app.routers.event import create_event\nfrom tests.client_fixture import get_test_placeholder_user\nfrom tests.conftest import get_test_db, test_engine\n\n\n@pytest.fixture\nasync def telegram_client():\n    Base.metadata.create_all(bind=test_engine)\n    app.dependency_overrides[telegram.get_db] = get_test_db\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        yield ac\n    app.dependency_overrides = {}\n    Base.metadata.drop_all(bind=test_engine)\n\n\ntoday_date = datetime.today().replace(hour=0, minute=0, second=0)\n\n\n@pytest.fixture\ndef fake_user_events(session):\n    Base.metadata.create_all(bind=test_engine)\n    user = get_test_placeholder_user()\n    session.add(user)\n    session.commit()\n    create_event(\n        db=session,\n        title='Cool today event',\n        start=today_date,\n        end=today_date + timedelta(days=2),\n        all_day=False,\n        content='test event',\n        owner_id=user.id,\n        location=\"Here\",\n        is_google_event=False,\n    )\n    create_event(\n        db=session,\n        title='Cool (somewhen in two days) event',\n        start=today_date + timedelta(days=1),\n        end=today_date + timedelta(days=3),\n        all_day=False,\n        content='this week test event',\n        owner_id=user.id,\n        location=\"Here\",\n        is_google_event=False,\n    )\n    yield user\n    Base.metadata.drop_all(bind=test_engine)\n"}
{"type": "test_file", "path": "tests/category_fixture.py", "content": "import pytest\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Category, User\n\n\n@pytest.fixture\ndef category(session: Session, sender: User) -> Category:\n    category = Category.create(session, name=\"Guitar Lesson\", color=\"121212\",\n                               user_id=sender.id)\n    yield category\n    session.delete(category)\n    session.commit()\n"}
{"type": "test_file", "path": "tests/client_fixture.py", "content": "from typing import Generator, Iterator\n\nfrom fastapi.testclient import TestClient\nimport pytest\nfrom sqlalchemy.orm import Session\n\nfrom app import main\nfrom app.database.models import Base, User\nfrom app.routers import (\n    agenda, event, friendview, google_connect, invitation, profile\n)\nfrom app.routers.salary import routes as salary\nfrom tests import security_testing_routes\nfrom tests.conftest import get_test_db, test_engine\n\nmain.app.include_router(security_testing_routes.router)\n\n\ndef get_test_placeholder_user() -> User:\n    return User(\n        username='fake_user',\n        email='fake@mail.fake',\n        password='123456fake',\n        full_name='FakeName',\n        language_id=1,\n        telegram_id='666666',\n    )\n\n\n@pytest.fixture(scope=\"session\")\ndef client() -> TestClient:\n    return TestClient(main.app)\n\n\ndef create_test_client(get_db_function) -> Generator[Session, None, None]:\n    Base.metadata.create_all(bind=test_engine)\n    main.app.dependency_overrides[get_db_function] = get_test_db\n\n    with TestClient(main.app) as client:\n        yield client\n\n    main.app.dependency_overrides = {}\n    Base.metadata.drop_all(bind=test_engine)\n\n\n@pytest.fixture(scope=\"session\")\ndef agenda_test_client() -> Generator[TestClient, None, None]:\n    yield from create_test_client(agenda.get_db)\n\n\n@pytest.fixture(scope=\"session\")\ndef friendview_test_client() -> Generator[TestClient, None, None]:\n    yield from create_test_client(friendview.get_db)\n\n\n@pytest.fixture(scope=\"session\")\ndef event_test_client() -> Generator[TestClient, None, None]:\n    yield from create_test_client(event.get_db)\n\n\n@pytest.fixture(scope=\"session\")\ndef home_test_client() -> Generator[TestClient, None, None]:\n    yield from create_test_client(main.get_db)\n\n\n@pytest.fixture(scope=\"session\")\ndef invitation_test_client() -> Generator[TestClient, None, None]:\n    yield from create_test_client(invitation.get_db)\n\n\n@pytest.fixture(scope=\"session\")\ndef profile_test_client() -> Generator[Session, None, None]:\n    Base.metadata.create_all(bind=test_engine)\n    main.app.dependency_overrides[profile.get_db] = get_test_db\n    main.app.dependency_overrides[\n        profile.get_placeholder_user] = get_test_placeholder_user\n\n    with TestClient(main.app) as client:\n        yield client\n\n    main.app.dependency_overrides = {}\n    Base.metadata.drop_all(bind=test_engine)\n\n\n@pytest.fixture(scope=\"session\")\ndef security_test_client():\n    yield from create_test_client(event.get_db)\n\n\n@pytest.fixture(scope=\"session\")\ndef salary_test_client() -> Iterator[TestClient]:\n    yield from create_test_client(salary.get_db)\n\n\n@pytest.fixture(scope=\"session\")\ndef google_connect_test_client():\n    Base.metadata.create_all(bind=test_engine)\n    main.app.dependency_overrides[google_connect.get_db] = get_test_db\n\n    with TestClient(main.app) as client:\n        yield client\n\n    main.app.dependency_overrides = {}\n    Base.metadata.drop_all(bind=test_engine)\n"}
{"type": "test_file", "path": "tests/comment_fixture.py", "content": "from datetime import datetime\nfrom typing import Iterator\n\nimport pytest\nfrom sqlalchemy.orm.session import Session\n\nfrom app.database.models import Comment, Event, User\nfrom app.internal.utils import create_model, delete_instance\n\n\n@pytest.fixture\ndef comment(session: Session, event: Event, user: User) -> Iterator[Comment]:\n    data = {\n        'user': user,\n        'event': event,\n        'content': 'test comment',\n        'time': datetime(2021, 1, 1, 0, 1),\n    }\n    create_model(session, Comment, **data)\n    comment = session.query(Comment).first()\n    yield comment\n    delete_instance(session, comment)\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "import calendar\n\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.config import PSQL_ENVIRONMENT\nfrom app.database.models import Base\n\npytest_plugins = [\n    'tests.user_fixture',\n    'tests.event_fixture',\n    'tests.dayview_fixture',\n    'tests.invitation_fixture',\n    'tests.association_fixture',\n    'tests.client_fixture',\n    'tests.asyncio_fixture',\n    'tests.logger_fixture',\n    'tests.category_fixture',\n    'smtpdfix',\n    'tests.quotes_fixture',\n    'tests.zodiac_fixture',\n    'tests.comment_fixture',\n]\n\n# When testing in a PostgreSQL environment please make sure that:\n#   - Base string is a PSQL string\n#   - app.config.PSQL_ENVIRONMENT is set to True\n\nif PSQL_ENVIRONMENT:\n    SQLALCHEMY_TEST_DATABASE_URL = (\n        \"postgresql://postgres:1234\"\n        \"@localhost/postgres\"\n    )\n    test_engine = create_engine(\n        SQLALCHEMY_TEST_DATABASE_URL\n    )\n\nelse:\n    SQLALCHEMY_TEST_DATABASE_URL = \"sqlite:///./test.db\"\n    test_engine = create_engine(\n        SQLALCHEMY_TEST_DATABASE_URL, connect_args={\"check_same_thread\": False}\n    )\n\nTestingSessionLocal = sessionmaker(\n    autocommit=False, autoflush=False, bind=test_engine)\n\n\ndef get_test_db():\n    return TestingSessionLocal()\n\n\n@pytest.fixture\ndef session():\n    Base.metadata.create_all(bind=test_engine)\n    session = get_test_db()\n    yield session\n    session.rollback()\n    session.close()\n    Base.metadata.drop_all(bind=test_engine)\n\n\n@pytest.fixture\ndef sqlite_engine():\n    SQLALCHEMY_TEST_DATABASE_URL = \"sqlite:///./test.db\"\n    sqlite_test_engine = create_engine(\n        SQLALCHEMY_TEST_DATABASE_URL, connect_args={\"check_same_thread\": False}\n    )\n\n    TestingSession = sessionmaker(\n        autocommit=False, autoflush=False, bind=sqlite_test_engine)\n\n    yield sqlite_test_engine\n    session = TestingSession()\n    session.close()\n    Base.metadata.drop_all(bind=sqlite_test_engine)\n\n\n@pytest.fixture\ndef Calendar():\n    return calendar.Calendar(0)\n"}
{"type": "test_file", "path": "tests/dayview_fixture.py", "content": "from datetime import datetime\n\nimport pytest\n\nfrom app.database.models import Event\n\n\n@pytest.fixture\ndef event1():\n    start = datetime(year=2021, month=2, day=1, hour=7, minute=5)\n    end = datetime(year=2021, month=2, day=1, hour=9, minute=15)\n    return Event(title='test1', content='test',\n                 start=start, end=end, owner_id=1)\n\n\n@pytest.fixture\ndef event2():\n    start = datetime(year=2021, month=2, day=1, hour=13, minute=13)\n    end = datetime(year=2021, month=2, day=1, hour=15, minute=46)\n    return Event(title='test2', content='test',\n                 start=start, end=end, owner_id=1, color='blue')\n\n\n@pytest.fixture\ndef event3():\n    start = datetime(year=2021, month=2, day=3, hour=7, minute=5)\n    end = datetime(year=2021, month=2, day=3, hour=9, minute=15)\n    return Event(title='test3', content='test',\n                 start=start, end=end, owner_id=1)\n\n\n@pytest.fixture\ndef all_day_event1():\n    start = datetime(year=2021, month=2, day=3, hour=7, minute=5)\n    end = datetime(year=2021, month=2, day=3, hour=9, minute=15)\n    return Event(title='test3', content='test', all_day=True,\n                 start=start, end=end, owner_id=1)\n\n\n@pytest.fixture\ndef small_event():\n    start = datetime(year=2021, month=2, day=3, hour=7)\n    end = datetime(year=2021, month=2, day=3, hour=8, minute=30)\n    return Event(title='test3', content='test',\n                 start=start, end=end, owner_id=1)\n\n\n@pytest.fixture\ndef event_with_no_minutes_modified():\n    start = datetime(year=2021, month=2, day=3, hour=7)\n    end = datetime(year=2021, month=2, day=3, hour=8)\n    return Event(title='test_no_modify', content='test',\n                 start=start, end=end, owner_id=1)\n\n\n@pytest.fixture\ndef multiday_event():\n    start = datetime(year=2021, month=2, day=1, hour=13)\n    end = datetime(year=2021, month=2, day=3, hour=13)\n    return Event(title='test_multiday', content='test',\n                 start=start, end=end, owner_id=1, color='blue')\n\n\n@pytest.fixture\ndef weekdays():\n    return [\n     'Sunday', 'Monday', 'Tuesday',\n     'Wednesday', 'Thursday', 'Friday', 'Saturday',\n    ]\n\n\n@pytest.fixture\ndef sunday():\n    return datetime(day=3, month=1, year=2021)\n"}
{"type": "test_file", "path": "tests/event_fixture.py", "content": "from datetime import datetime, timedelta\n\nimport pytest\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Category, Event, User\nfrom app.routers.event import create_event\n\ntoday_date = datetime.today().replace(hour=0, minute=0, second=0)\n\n\n@pytest.fixture\ndef event(sender: User, category: Category, session: Session) -> Event:\n    return create_event(\n        db=session,\n        title='event',\n        start=today_date,\n        end=today_date,\n        content='test event',\n        owner_id=sender.id,\n        location=\"Some random location\",\n        vc_link=None,\n        category_id=category.id,\n    )\n\n\n@pytest.fixture\ndef today_event(sender: User, session: Session) -> Event:\n    return create_event(\n        db=session,\n        title='event 1',\n        start=today_date + timedelta(hours=7),\n        end=today_date + timedelta(hours=9),\n        all_day=False,\n        content='test event',\n        owner_id=sender.id,\n    )\n\n\n@pytest.fixture\ndef today_event_2(sender: User, session: Session) -> Event:\n    return create_event(\n        db=session,\n        title='event 2',\n        start=today_date + timedelta(hours=3),\n        end=today_date + timedelta(days=2, hours=3),\n        all_day=False,\n        content='test event',\n        owner_id=sender.id,\n    )\n\n\n@pytest.fixture\ndef yesterday_event(sender: User, session: Session) -> Event:\n    return create_event(\n        db=session,\n        title='event 3',\n        start=today_date - timedelta(hours=8),\n        end=today_date,\n        all_day=False,\n        content='test event',\n        owner_id=sender.id,\n    )\n\n\n@pytest.fixture\ndef next_week_event(sender: User, session: Session) -> Event:\n    return create_event(\n        db=session,\n        title='event 4',\n        start=today_date + timedelta(days=7, hours=2),\n        end=today_date + timedelta(days=7, hours=4),\n        all_day=False,\n        content='test event',\n        owner_id=sender.id,\n    )\n\n\n@pytest.fixture\ndef next_month_event(sender: User, session: Session) -> Event:\n    return create_event(\n        db=session,\n        title='event 5',\n        start=today_date + timedelta(days=20, hours=4),\n        end=today_date + timedelta(days=20, hours=6),\n        all_day=False,\n        content='test event',\n        owner_id=sender.id,\n    )\n\n\n@pytest.fixture\ndef old_event(sender: User, session: Session) -> Event:\n    return create_event(\n        db=session,\n        title='event 6',\n        start=today_date - timedelta(days=5),\n        end=today_date - timedelta(days=1),\n        all_day=False,\n        content='test event',\n        owner_id=sender.id,\n    )\n\n\n@pytest.fixture\ndef all_day_event(sender: User, category: Category, session: Session) -> Event:\n    return create_event(\n        db=session,\n        title='event',\n        start=today_date,\n        end=today_date,\n        all_day=True,\n        content='test event',\n        owner_id=sender.id,\n        location=\"Some random location\",\n        category_id=category.id,\n    )\n"}
{"type": "test_file", "path": "tests/invitation_fixture.py", "content": "from datetime import datetime\nfrom typing import Generator\n\nimport pytest\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Event, Invitation, User\nfrom app.internal.utils import create_model, delete_instance\n\n\n@pytest.fixture\ndef invitation(\n        event: Event, user: User, session: Session\n) -> Generator[Invitation, None, None]:\n    \"\"\"Returns an Invitation object after being created in the database.\n\n    Args:\n        event: An Event instance.\n        user: A user instance.\n        session: A database connection.\n\n    Returns:\n        An Invitation object.\n    \"\"\"\n    invitation = create_model(\n        session, Invitation,\n        creation=datetime.now(),\n        recipient=user,\n        event=event,\n        event_id=event.id,\n        recipient_id=user.id,\n    )\n    yield invitation\n    delete_instance(session, invitation)\n"}
{"type": "test_file", "path": "tests/logger_fixture.py", "content": "import logging\n\nfrom _pytest.logging import caplog as _caplog  # noqa: F401\nfrom loguru import logger\nimport pytest\n\nfrom app import config\nfrom app.internal.logger_customizer import LoggerCustomizer\n\n\n@pytest.fixture(scope='module')\ndef logger_instance():\n    _logger = LoggerCustomizer.make_logger(config.LOG_PATH,\n                                           config.LOG_FILENAME,\n                                           config.LOG_LEVEL,\n                                           config.LOG_ROTATION_INTERVAL,\n                                           config.LOG_RETENTION_INTERVAL,\n                                           config.LOG_FORMAT)\n\n    return _logger\n\n\n@pytest.fixture\ndef caplog(_caplog):  # noqa: F811\n    class PropagateHandler(logging.Handler):\n        def emit(self, record):\n            logging.getLogger(record.name).handle(record)\n\n    handler_id = logger.add(PropagateHandler(), format=\"{message} {extra}\")\n    yield _caplog\n    logger.remove(handler_id)\n"}
{"type": "test_file", "path": "tests/quotes_fixture.py", "content": "import pytest\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Quote\nfrom app.internal.utils import create_model, delete_instance\n\n\ndef add_quote(\n        session: Session, id_quote: int, text: str, author: str\n) -> Quote:\n    quote = create_model(\n        session,\n        Quote,\n        id=id_quote,\n        text=text,\n        author=author,\n    )\n    yield quote\n    delete_instance(session, quote)\n\n\n@pytest.fixture\ndef quote1(session: Session) -> Quote:\n    yield from add_quote(\n        session=session,\n        id_quote=1,\n        text='You have to believe in yourself.',\n        author='Sun Tzu',\n    )\n\n\n@pytest.fixture\ndef quote2(session: Session) -> Quote:\n    yield from add_quote(\n        session=session,\n        id_quote=2,\n        text='Wisdom begins in wonder.',\n        author='Socrates',\n    )\n"}
{"type": "test_file", "path": "tests/salary/conftest.py", "content": "from typing import Iterator\n\nimport pytest\nfrom sqlalchemy.orm.session import Session\n\nfrom app.database.models import Base, SalarySettings, User\nfrom app.internal.utils import create_model, delete_instance\nfrom app.routers.salary import config\nfrom app.routers.salary.routes import router\nfrom tests.conftest import get_test_db\nfrom tests.conftest import test_engine\n\nMESSAGES = {\n    'create_settings': 'Already created your settings?',\n    'pick_settings': 'Edit Settings',\n    'edit_settings': 'Settings don\\'t need editing?',\n    'pick_category': 'View Salary',\n    'view_salary': 'Need to alter your settings?',\n    'salary_calc': 'Total Salary:',\n}\n\nROUTES = {\n    'home': router.url_path_for('salary_home'),\n    'new': router.url_path_for('create_settings'),\n    'edit_pick': router.url_path_for('pick_settings'),\n    'edit': lambda x: router.url_path_for('edit_settings', category_id=x),\n    'view_pick': router.url_path_for('pick_category'),\n    'view': lambda x: router.url_path_for('view_salary', category_id=x),\n}\n\nCATEGORY_ID = 1\nINVALID_CATEGORY_ID = 2\nALT_CATEGORY_ID = 42\nMONTH = '2021-01'\n\n\n@pytest.fixture(scope='package')\ndef salary_session() -> Iterator[Session]:\n    Base.metadata.create_all(bind=test_engine)\n    session = get_test_db()\n    yield session\n    session.close()\n    Base.metadata.drop_all(bind=test_engine)\n\n\n@pytest.fixture\ndef salary_user(salary_session: Session):\n    test_user = create_model(\n        salary_session, User,\n        username='test_username',\n        password='test_password',\n        email='test.email@gmail.com',\n    )\n    yield test_user\n    delete_instance(salary_session, test_user)\n\n\n@pytest.fixture\ndef wage(salary_session: Session,\n         salary_user: User) -> Iterator[SalarySettings]:\n    wage = create_model(\n        salary_session,\n        SalarySettings,\n        user_id=salary_user.id,\n        category_id=CATEGORY_ID,\n        wage=30,\n        off_day=config.SATURDAY,\n        holiday_category_id=config.ISRAELI_JEWISH,\n        regular_hour_basis=config.REGULAR_HOUR_BASIS,\n        night_hour_basis=config.NIGHT_HOUR_BASIS,\n        night_start=config.NIGHT_START,\n        night_end=config.NIGHT_END,\n        night_min_len=config.NIGHT_MIN_LEN,\n        first_overtime_amount=config.FIRST_OVERTIME_AMOUNT,\n        first_overtime_pay=config.FIRST_OVERTIME_PAY,\n        second_overtime_pay=config.SECOND_OVERTIME_PAY,\n        week_working_hours=config.WEEK_WORKING_HOURS,\n        daily_transport=config.STANDARD_TRANSPORT,\n    )\n    yield wage\n    delete_instance(salary_session, wage)\n"}
{"type": "test_file", "path": "tests/salary/test_routes.py", "content": "from unittest import mock\n\nfrom fastapi import status\nimport pytest\nfrom requests.sessions import Session\nfrom starlette.testclient import TestClient\n\nfrom app.database.models import SalarySettings, User\nfrom app.internal.utils import delete_instance\nfrom app.routers.salary import routes, utils\nfrom tests.salary import conftest\nfrom tests.salary.test_utils import get_event_by_category\n\nPATHS = [\n    (conftest.ROUTES['new']),\n    (conftest.ROUTES['edit_pick']),\n    (conftest.ROUTES['edit'](conftest.CATEGORY_ID)),\n    (conftest.ROUTES['view_pick']),\n    (conftest.ROUTES['view'](conftest.CATEGORY_ID)),\n]\n\nEMPTY_PICKS = [\n    (conftest.ROUTES['edit_pick']),\n    (conftest.ROUTES['view_pick']),\n]\n\nCATEGORY_PICK = [\n    (conftest.ROUTES['edit_pick'], conftest.MESSAGES['edit_settings']),\n    (conftest.ROUTES['view_pick'], conftest.MESSAGES['view_salary']),\n]\n\nINVALID = [\n    (conftest.ROUTES['edit'](conftest.ALT_CATEGORY_ID),\n     conftest.MESSAGES['pick_settings']),\n    (conftest.ROUTES['view'](conftest.ALT_CATEGORY_ID),\n     conftest.MESSAGES['pick_category']),\n    (conftest.ROUTES['edit'](conftest.INVALID_CATEGORY_ID),\n     conftest.MESSAGES['pick_settings']),\n    (conftest.ROUTES['view'](conftest.INVALID_CATEGORY_ID),\n     conftest.MESSAGES['pick_category']),\n]\n\n\ndef get_current_user(salary_session: Session) -> User:\n    user = salary_session.query(User).filter_by(id=2).first()\n    return user\n\n\ndef test_get_user_categories() -> None:\n    # Code revision required after categories feature is added\n    categories = {\n        1: 'Workout',\n        17: 'Flight',\n        42: 'Going to the Movies',\n        666: 'Lucy\\'s Inferno',\n    }\n    assert routes.get_user_categories() == categories\n\n\ndef test_get_holiday_categories() -> None:\n    # Code revision required after holiday times feature is added\n    holidays = {\n        1: 'Israel - Jewish',\n        3: 'Iraq - Muslim',\n        17: 'Cuba - Santeria',\n        666: 'Hell - Satanist',\n    }\n    assert routes.get_holiday_categories() == holidays\n\n\ndef test_get_salary_categories_empty(salary_session: Session,\n                                     salary_user: User) -> None:\n    # Code revision required after categories feature is added\n    assert routes.get_salary_categories(salary_session, salary_user.id) == {}\n\n\ndef test_get_salary_categories(salary_session: Session,\n                               wage: SalarySettings) -> None:\n    # Code revision required after categories feature is added\n    assert wage.category_id in routes.get_salary_categories(salary_session,\n                                                            wage.user_id, True)\n\n\ndef test_get_salary_categories_new(salary_session: Session,\n                                   wage: SalarySettings) -> None:\n    # Code revision required after categories feature is added\n    assert wage.category_id not in routes.get_salary_categories(\n        salary_session, wage.user_id, False)\n\n\n@pytest.mark.parametrize('path', PATHS)\ndef test_pages_respond_ok(salary_test_client: TestClient,\n                          wage: SalarySettings, path: str) -> None:\n    response = salary_test_client.get(path)\n    assert response.ok\n\n\ndef test_home_page_redirects_to_new(\n        salary_test_client: TestClient) -> None:\n    response = salary_test_client.get(conftest.ROUTES['home'])\n    assert response.ok\n    assert conftest.MESSAGES['create_settings'] in response.text\n\n\n@mock.patch('app.routers.salary.routes.get_current_user',\n            new=get_current_user)\ndef test_home_page_redirects_to_view(salary_test_client: TestClient,\n                                     wage: SalarySettings) -> None:\n    response = salary_test_client.get(conftest.ROUTES['home'])\n    assert response.ok\n    assert conftest.MESSAGES['pick_category'] in response.text\n\n\n@mock.patch('app.routers.salary.routes.get_current_user',\n            new=get_current_user)\ndef test_create_settings(salary_test_client: TestClient,\n                         salary_session: Session, salary_user: User) -> None:\n    category_id = conftest.CATEGORY_ID\n    assert utils.get_settings(salary_session, salary_user.id,\n                              category_id) is None\n    data = {\n        'category_id': category_id,\n        'wage': utils.DEFAULT_SETTINGS.wage,\n        'off_day': utils.DEFAULT_SETTINGS.off_day,\n        'holiday_category_id': utils.DEFAULT_SETTINGS.holiday_category_id,\n        'regular_hour_basis': utils.DEFAULT_SETTINGS.regular_hour_basis,\n        'night_hour_basis': utils.DEFAULT_SETTINGS.night_hour_basis,\n        'night_start': utils.DEFAULT_SETTINGS.night_start,\n        'night_end': utils.DEFAULT_SETTINGS.night_end,\n        'night_min_len': utils.DEFAULT_SETTINGS.night_min_len,\n        'first_overtime_amount': utils.DEFAULT_SETTINGS.first_overtime_amount,\n        'first_overtime_pay': utils.DEFAULT_SETTINGS.first_overtime_pay,\n        'second_overtime_pay': utils.DEFAULT_SETTINGS.second_overtime_pay,\n        'week_working_hours': utils.DEFAULT_SETTINGS.week_working_hours,\n        'daily_transport': utils.DEFAULT_SETTINGS.daily_transport,\n    }\n    response = salary_test_client.post(\n        conftest.ROUTES['new'], data=data, allow_redirects=True)\n    assert response.ok\n    assert conftest.MESSAGES['view_salary'] in response.text\n    settings = utils.get_settings(salary_session, salary_user.id, category_id)\n    assert settings\n    delete_instance(salary_session, settings)\n\n\n@pytest.mark.parametrize('path', EMPTY_PICKS)\ndef test_empty_category_pick_redirects_to_new(salary_test_client: TestClient,\n                                              path: str) -> None:\n    response = salary_test_client.get(path)\n    assert any(temp.status_code == status.HTTP_307_TEMPORARY_REDIRECT\n               for temp in response.history)\n\n\n@pytest.mark.parametrize('path, message', CATEGORY_PICK)\n@mock.patch('app.routers.salary.routes.get_current_user',\n            new=get_current_user)\ndef test_pick_category(salary_test_client: TestClient, wage: SalarySettings,\n                       path: str, message: str) -> None:\n    data = {'category_id': wage.category_id}\n    response = salary_test_client.post(path, data=data, allow_redirects=True)\n    assert message in response.text\n\n\n@mock.patch('app.routers.salary.routes.get_current_user',\n            new=get_current_user)\ndef test_edit_settings(salary_test_client: TestClient, salary_session: Session,\n                       wage: SalarySettings) -> None:\n    category_id = wage.category_id\n    settings = utils.get_settings(salary_session, wage.user_id, category_id)\n    route = conftest.ROUTES['edit'](category_id)\n    data = {\n        'wage': wage.wage + 1,\n        'off_day': wage.off_day,\n        'holiday_category_id': wage.holiday_category_id,\n        'regular_hour_basis': wage.regular_hour_basis,\n        'night_hour_basis': wage.night_hour_basis,\n        'night_start': wage.night_start,\n        'night_end': wage.night_end,\n        'night_min_len': wage.night_min_len,\n        'first_overtime_amount': wage.first_overtime_amount,\n        'first_overtime_pay': wage.first_overtime_pay,\n        'second_overtime_pay': wage.second_overtime_pay,\n        'week_working_hours': wage.week_working_hours,\n        'daily_transport': wage.daily_transport,\n    }\n    response = salary_test_client.post(route, data=data, allow_redirects=True)\n    assert response.ok\n    assert conftest.MESSAGES['view_salary'] in response.text\n    assert settings != utils.get_settings(salary_session, wage.user_id,\n                                          wage.category_id)\n\n\n@pytest.mark.parametrize('path, message', INVALID)\n@mock.patch('app.routers.salary.routes.get_current_user',\n            new=get_current_user)\ndef test_invalid_category_redirect(\n        salary_test_client: TestClient, wage: SalarySettings, path: str,\n        message: str) -> None:\n    response = salary_test_client.get(path)\n    assert any(temp.status_code == status.HTTP_307_TEMPORARY_REDIRECT\n               for temp in response.history)\n    print(response.text)\n    assert message in response.text\n\n\n@mock.patch('app.routers.salary.routes.get_current_user',\n            new=get_current_user)\n@mock.patch('app.routers.salary.utils.get_event_by_category',\n            new=get_event_by_category)\ndef test_view_salary(salary_test_client: TestClient,\n                     wage: SalarySettings) -> None:\n    route = (conftest.ROUTES['view'](wage.category_id))\n    data = {\n        'month': conftest.MONTH,\n        'bonus': 1000,\n        'deduction': 1000,\n        'overtime': True\n    }\n    response = salary_test_client.post(route, data=data)\n    assert response.ok\n    assert conftest.MESSAGES['salary_calc'] in response.text\n"}
{"type": "test_file", "path": "tests/salary/test_utils.py", "content": "from datetime import datetime, time, timedelta\nfrom typing import Dict, List, Tuple\nfrom unittest import mock\n\nimport pytest\nfrom requests.sessions import Session\n\nfrom app.database.models import Event, SalarySettings\nfrom app.routers.salary import config, utils\n\nNIGHT_TIMES = [\n    (datetime(2020, 1, 15), False,\n     (datetime.combine(datetime(2020, 1, 15), config.NIGHT_START),\n      datetime.combine(datetime(2020, 1, 16), config.NIGHT_END))),\n    (datetime(2020, 1, 15), True,\n     (datetime.combine(datetime(2020, 1, 14), config.NIGHT_START),\n      datetime.combine(datetime(2020, 1, 15), config.NIGHT_END)))\n]\n\nNIGHT_SHIFTS = [\n    # Invalid shift\n    (datetime(2020, 12, 1, 23, 15), datetime(2020, 12, 1, 5, 15), False),\n    # Not during night\n    (datetime(2020, 12, 1, 9, 15), datetime(2020, 12, 1, 18, 15), False),\n    # Too short - evening\n    (datetime(2020, 12, 1, 20, 15), datetime(2020, 12, 1, 23, 15), False),\n    # Too short - morning\n    (datetime(2020, 12, 1, 5, 15), datetime(2020, 12, 1, 6, 15), False),\n    # Same Date\n    (datetime(2020, 12, 1, 3, 15), datetime(2020, 12, 1, 7, 15), True),\n    # Date changing\n    (datetime(2020, 12, 1, 19, 15), datetime(2020, 12, 2, 1, 15), True),\n    # Entire night\n    (datetime(2020, 12, 1, 19, 15), datetime(2020, 12, 2, 7, 15), True)\n]\n\nHOLIDAY_TIMES = [\n    (datetime(2020, 1, 3, 15), datetime(2020, 1, 4, 1),  # Friday - Saturday\n     (datetime(2020, 1, 4), datetime(2020, 1, 5))),\n    (datetime(2020, 1, 4, 15), datetime(2020, 1, 5, 1),  # Saturday - Sunday\n     (datetime(2020, 1, 4), datetime(2020, 1, 5))),\n    (datetime(2020, 1, 5, 15), datetime(2020, 1, 6, 1),  # Sunday - Monday\n     (datetime.min, datetime.min)),\n]\n\nSYNC_TIMES = [\n    (datetime(2020, 1, 3, 15), datetime(2020, 1, 3, 22),\n     datetime(2020, 1, 3, 18, 30), datetime(2020, 1, 4, 2), 3.5),\n    (datetime(2020, 1, 3, 15), datetime(2020, 1, 3, 22),\n     datetime(2020, 1, 4, 15), datetime(2020, 1, 4, 22), 0.0),\n]\n\nHOUR_BASIS = [\n    (datetime(2021, 1, 4, 9), datetime(2021, 1, 4, 19),  # Regular shift\n     config.REGULAR_HOUR_BASIS),\n    (datetime(2021, 1, 4, 18), datetime(2021, 1, 5, 4),  # Night shift\n     config.NIGHT_HOUR_BASIS),\n]\n\nOVERTIMES = [\n    # Short shift\n    (datetime(2021, 1, 4, 9), datetime(2021, 1, 4, 14), (5, 0)),\n    # Regular shift\n    (datetime(2021, 1, 4, 9), datetime(2021, 1, 4, 19), (10.5, 2)),\n    # Short night shift\n    (datetime(2021, 1, 5, 1), datetime(2021, 1, 5, 6), (5, 0)),\n    # Night shift\n    (datetime(2021, 1, 4, 18), datetime(2021, 1, 5, 4), (11, 3)),\n]\n\nHOLIDAY_HOURS = [\n    (datetime(2020, 1, 3, 15), datetime(2020, 1, 4, 1), 1.0),\n    (datetime(2020, 1, 4, 15, 30), datetime(2020, 1, 5, 1), 8.5),\n    (datetime(2020, 1, 5, 15), datetime(2020, 1, 6, 1), 0.0),\n]\n\nHOLIDAY_OVERTIMES = [\n    # Short shift\n    (datetime(2021, 1, 4, 9), datetime(2021, 1, 4, 14), (5, 0)),\n    # Regular shift\n    (datetime(2021, 1, 4, 9), datetime(2021, 1, 4, 19), (10.5, 2)),\n    # Short night shift\n    (datetime(2021, 1, 5, 1), datetime(2021, 1, 5, 6), (5, 0)),\n    # Night shift\n    (datetime(2021, 1, 4, 18), datetime(2021, 1, 5, 4), (11, 3)),\n    # Short off-day shift\n    (datetime(2021, 1, 2, 9), datetime(2021, 1, 2, 14), (7.5, 0)),\n    # Off-day shift\n    (datetime(2021, 1, 2, 9), datetime(2021, 1, 2, 19), (15.5, 2)),\n    # Night off-day shift\n    (datetime(2021, 1, 2, 14), datetime(2021, 1, 3, 0), (16, 3))\n]\n\nSHIFTS = [\n    # Regular shift\n    (datetime(2021, 1, 4, 9), datetime(2021, 1, 4, 19), 315),\n    # Night shift\n    (datetime(2021, 1, 4, 18), datetime(2021, 1, 5, 4), 330),\n    # Off-day shift\n    (datetime(2021, 1, 2, 9), datetime(2021, 1, 2, 19), 465),\n    # Night off-day shift\n    (datetime(2021, 1, 2, 14), datetime(2021, 1, 3, 0), 480),\n]\n\nWEEK_SHIFTS = [\n    ((Event(start=datetime(2021, 1, 10, 9),\n            end=datetime(2021, 1, 10, 19)),), 0.0),\n    ((Event(start=datetime(2021, 1, 10, 9),\n            end=datetime(2021, 1, 10, 19)),\n      Event(start=datetime(2021, 1, 11, 9),\n            end=datetime(2021, 1, 11, 17)),\n      Event(start=datetime(2021, 1, 12, 9),\n            end=datetime(2021, 1, 12, 17)),\n      Event(start=datetime(2021, 1, 13, 9),\n            end=datetime(2021, 1, 13, 18)),\n      Event(start=datetime(2021, 1, 14, 9),\n            end=datetime(2021, 1, 14, 17))), 0.0),\n    ((Event(start=datetime(2021, 1, 10, 9),\n            end=datetime(2021, 1, 10, 19)),\n      Event(start=datetime(2021, 1, 11, 9),\n            end=datetime(2021, 1, 11, 17)),\n      Event(start=datetime(2021, 1, 12, 9),\n            end=datetime(2021, 1, 12, 17)),\n      Event(start=datetime(2021, 1, 13, 9),\n            end=datetime(2021, 1, 13, 18)),\n      Event(start=datetime(2021, 1, 14, 9),\n            end=datetime(2021, 1, 14, 17)),\n      Event(start=datetime(2021, 1, 15, 9),\n            end=datetime(2021, 1, 15, 14, 58))), 119.0),\n]\n\nMONTHS = [\n    (2020, 1, (datetime(2020, 1, 1), datetime(2020, 2, 1))),\n    (2020, 12, (datetime(2020, 12, 1), datetime(2021, 1, 1))),\n]\n\nMONTH_SHIFTS = [\n    (False, 0.0),\n    (True, 720.0)\n]\n\nTRANSPORT = [\n    (6, 11.8, 70.8),\n    (0, 11.8, 0.0),\n    (21, 0, 0.0),\n]\n\nSALARIES = [\n    (False, 0, {\n        'year': 2021,\n        'month': 1,\n        'num_of_shifts': 20,\n        'base_salary': 4800.0,\n        'month_weekly_overtime': 0,\n        'transport': 236,\n        'bonus': 0,\n        'deduction': 0,\n        'salary': 5036.0,\n    }),\n    (True, 10000, {\n        'year': 2021,\n        'month': 1,\n        'num_of_shifts': 20,\n        'base_salary': 4800.0,\n        'month_weekly_overtime': 0,\n        'transport': 236,\n        'bonus': 0,\n        'deduction': 5036.0,\n        'salary': 0.0,\n    }),\n]\n\nTIMES = [\n    ('13:30', time(13, 30)),\n    ('15:42:00', time(15, 42))\n]\n\nUPDATES = [\n    ({\n         'wage': '35',\n         'off_day': '6',\n         'holiday_category_id': '7',\n         'regular_hour_basis': '19',\n         'night_hour_basis': '6.5',\n         'night_start': '13:00',\n         'night_end': '14:30:00',\n         'night_min_len': '20:42',\n         'first_overtime_amount': '4',\n         'first_overtime_pay': '1',\n         'second_overtime_pay': '2',\n         'week_working_hours': '80',\n         'daily_transport': '20',\n     }, True),\n    ({}, False)\n]\n\n\ndef create_month_shifts(start: datetime, end: datetime,\n                        add_sixth_day: bool = False) -> List[Event]:\n    shifts = []\n    for i in range(4):\n        for j in range(6):\n            if j < 5 or add_sixth_day:\n                shifts.append(Event(\n                    start=start + timedelta(i) * 7 + timedelta(j),\n                    end=end + timedelta(i) * 7 + timedelta(j)))\n    return shifts\n\n\ndef get_event_by_category(*args, **kwargs) -> List[Event]:\n    # Code revision required after categories feature is added\n    start = datetime(2021, 1, 3, 9)\n    end = datetime(2021, 1, 3, 17)\n    return create_month_shifts(start, end)\n\n\ndef test_get_shift_len() -> None:\n    start = datetime(2020, 1, 1, 1)\n    end = start + timedelta(hours=1)\n    assert utils.get_shift_len(start, end) == 1\n    end += timedelta(minutes=12)\n    assert utils.get_shift_len(start, end) == 1.2\n\n\n@pytest.mark.parametrize('date, prev_day, night_times', NIGHT_TIMES)\ndef test_get_night_times(wage: SalarySettings, date: datetime, prev_day: bool,\n                         night_times: Tuple[datetime, datetime]) -> None:\n    assert utils.get_night_times(date, wage, prev_day) == night_times\n\n\n@pytest.mark.parametrize('start, end, boolean', NIGHT_SHIFTS)\ndef test_is_night_shift(wage: SalarySettings, start: datetime, end: datetime,\n                        boolean: bool) -> None:\n    assert utils.is_night_shift(start, end, wage) == boolean\n\n\n@pytest.mark.parametrize('start, end, dates',\n                         HOLIDAY_TIMES)\ndef test_get_relevant_holiday_times(\n        wage: SalarySettings, start: datetime, end: datetime,\n        dates: Tuple[datetime, datetime]) -> None:\n    # Code revision required after holiday times feature is added\n    # Code revision required after Shabbat times feature is added\n    assert utils.get_relevant_holiday_times(\n        start, end, wage) == dates\n\n\n@pytest.mark.parametrize(\n    'event_1_start, event_1_end, event_2_start, event_2_end, total',\n    SYNC_TIMES)\ndef test_get_total_synchronous_hours(event_1_start: datetime,\n                                     event_1_end: datetime,\n                                     event_2_start: datetime,\n                                     event_2_end: datetime,\n                                     total: float) -> None:\n    assert utils.get_total_synchronous_hours(\n        event_1_start, event_1_end, event_2_start, event_2_end) == total\n\n\n@pytest.mark.parametrize('start, end, basis', HOUR_BASIS)\ndef test_get_hour_basis(wage: SalarySettings, start: datetime,\n                        end: datetime, basis: float) -> None:\n    assert utils.get_hour_basis(start, end, wage) == basis\n\n\n@pytest.mark.parametrize('start, end, overtimes', OVERTIMES)\ndef test_calc_overtime_hours(\n        wage: SalarySettings, start: datetime, end: datetime,\n        overtimes: Tuple[float, float]) -> None:\n    assert utils.calc_overtime_hours(start, end, wage) == overtimes\n\n\n@pytest.mark.parametrize('shift_start, shift_end, total', HOLIDAY_HOURS)\ndef test_get_hours_during_holiday(wage: SalarySettings, shift_start: datetime,\n                                  shift_end: datetime, total: float) -> None:\n    # Code revision required after holiday times feature is added\n    # Code revision required after Shabbat times feature is added\n    assert utils.get_hours_during_holiday(\n        shift_start, shift_end, wage) == total\n\n\n@pytest.mark.parametrize('start, end, overtimes', HOLIDAY_OVERTIMES)\ndef test_adjust_overtime(wage: SalarySettings, start: datetime, end: datetime,\n                         overtimes: Tuple[float, float]) -> None:\n    assert utils.adjust_overtime(start, end, wage) == overtimes\n\n\n@pytest.mark.parametrize('start, end, salary', SHIFTS)\ndef test_calc_shift_salary(wage: SalarySettings, start: datetime,\n                           end: datetime, salary: float) -> None:\n    assert utils.calc_shift_salary(start, end, wage) == salary\n\n\n@pytest.mark.parametrize('shifts, overtime', WEEK_SHIFTS)\ndef test_calc_weekly_overtime(wage: SalarySettings, shifts: Tuple[Event, ...],\n                              overtime: float) -> None:\n    assert utils.calc_weekly_overtime(shifts, wage) == overtime\n\n\ndef test_get_event_by_category() -> None:\n    # Code revision required after categories feature is added\n    shifts = (\n        Event(start=datetime(2021, 1, 10, 9),\n              end=datetime(2021, 1, 10, 19)),\n        Event(start=datetime(2021, 1, 11, 9),\n              end=datetime(2021, 1, 11, 17)),\n        Event(start=datetime(2021, 1, 12, 9),\n              end=datetime(2021, 1, 12, 17)),\n        Event(start=datetime(2021, 1, 13, 9),\n              end=datetime(2021, 1, 13, 18)),\n        Event(start=datetime(2021, 1, 14, 9),\n              end=datetime(2021, 1, 14, 17)),\n        Event(start=datetime(2021, 1, 15, 9),\n              end=datetime(2021, 1, 15, 14, 58)),\n    )\n    events = utils.get_event_by_category()\n    assert len(events) == len(shifts)\n    for i, event in enumerate(events):\n        assert event.start == shifts[i].start and event.end == shifts[i].end\n\n\n@pytest.mark.parametrize('year, month, month_times', MONTHS)\ndef test_get_month_end(year: int, month: int,\n                       month_times: Tuple[datetime, datetime]) -> None:\n    assert utils.get_month_times(year, month) == month_times\n\n\ndef test_get_relevant_weeks() -> None:\n    weeks = [\n        (datetime(2020, 12, 27), datetime(2021, 1, 3)),\n        (datetime(2021, 1, 3), datetime(2021, 1, 10)),\n        (datetime(2021, 1, 10), datetime(2021, 1, 17)),\n        (datetime(2021, 1, 17), datetime(2021, 1, 24)),\n        (datetime(2021, 1, 24), datetime(2021, 1, 31)),\n    ]\n    relevant_weeks = utils.get_relevant_weeks(2021, 1)\n    for week in weeks:\n        assert week == next(relevant_weeks)\n\n\n@pytest.mark.parametrize('add_sixth_day, total', MONTH_SHIFTS)\ndef test_get_monthly_overtime(wage: SalarySettings, add_sixth_day: bool,\n                              total: float) -> None:\n    start = datetime(2021, 1, 3, 9)\n    end = datetime(2021, 1, 3, 17)\n    shifts = create_month_shifts(start, end, add_sixth_day)\n    weeks = utils.get_relevant_weeks(start.year, start.month)\n    assert utils.get_monthly_overtime(shifts, weeks, wage) == total\n\n\n@pytest.mark.parametrize('amount, daily_transport, total', TRANSPORT)\ndef test_calc_transport(amount: int, daily_transport: float,\n                        total: float) -> None:\n    assert utils.calc_transport(amount, daily_transport) == total\n\n\n@pytest.mark.parametrize('overtime, deduction, salary', SALARIES)\n@mock.patch('app.routers.salary.utils.get_event_by_category',\n            side_effect=get_event_by_category)\ndef test_calc_salary(\n        mocked_func, wage: SalarySettings, overtime: bool,\n        deduction: config.NUMERIC, salary: Dict[str, config.NUMERIC]) -> None:\n    # Code revision required after categories feature is added\n    assert utils.calc_salary(2021, 1, wage, overtime, 0, deduction) == salary\n\n\ndef test_get_settings(salary_session: Session,\n                      wage: SalarySettings) -> None:\n    assert utils.get_settings(salary_session, wage.user_id,\n                              wage.category_id)\n\n\n@pytest.mark.parametrize('string, formatted_time', TIMES)\ndef test_get_time_from_string(string: str, formatted_time: time) -> None:\n    assert utils.get_time_from_string(string) == formatted_time\n\n\n@pytest.mark.parametrize('form, boolean', UPDATES)\ndef test_update_settings(salary_session: Session, wage: SalarySettings,\n                         form: Dict[str, str], boolean: bool) -> None:\n    assert utils.update_settings(salary_session, wage, form) == boolean\n"}
{"type": "test_file", "path": "tests/test_a_telegram_asyncio.py", "content": "from datetime import datetime, timedelta\n\nfrom fastapi import status\nimport pytest\n\nfrom app.telegram.handlers import MessageHandler, reply_unknown_user\nfrom app.telegram.keyboards import DATE_FORMAT\nfrom app.telegram.models import Bot, Chat\nfrom tests.asyncio_fixture import today_date\nfrom tests.client_fixture import get_test_placeholder_user\n\n\ndef gen_message(text):\n    return {\n        'update_id': 10000000,\n        'message': {\n            'message_id': 2434,\n            'from': {\n                'id': 666666,\n                'is_bot': False,\n                'first_name': 'Moshe',\n                'username': 'banana',\n                'language_code': 'en'\n            },\n            'chat': {\n                'id': 666666,\n                'first_name': 'Moshe',\n                'username': 'banana',\n                'type': 'private'\n            },\n            'date': 1611240725,\n            'text': f'{text}'\n        }\n    }\n\n\ndef gen_callback(text):\n    return {\n        'update_id': 568265,\n        'callback_query': {\n            'id': '546565356486',\n            'from': {\n                'id': 666666,\n                'is_bot': False,\n                'first_name': 'Moshe',\n                'username': 'banana',\n                'language_code': 'en'\n            }, 'message': {\n                'message_id': 838,\n                'from': {\n                    'id': 2566252,\n                    'is_bot': True,\n                    'first_name': 'PyLandar',\n                    'username': 'pylander_bot'\n                }, 'chat': {\n                    'id': 666666,\n                    'first_name': 'Moshe',\n                    'username': 'banana',\n                    'type': 'private'\n                },\n                'date': 161156,\n                'text': 'Choose events day.',\n                'reply_markup': {\n                    'inline_keyboard': [\n                        [\n                            {\n                                'text': 'Today',\n                                'callback_data': 'Today'\n                            },\n                            {\n                                'text': 'This week',\n                                'callback_data': 'This week'\n                            }\n                        ]\n                    ]\n                }\n            },\n            'chat_instance': '-154494',\n            'data': f'{text}'}}\n\n\nclass TestChatModel:\n\n    @staticmethod\n    def test_private_message():\n        chat = Chat(gen_message('Cool message'))\n        assert chat.message == 'Cool message'\n        assert chat.user_id == 666666\n        assert chat.first_name == 'Moshe'\n\n    @staticmethod\n    def test_callback_message():\n        chat = Chat(gen_callback('Callback Message'))\n        assert chat.message == 'Callback Message'\n        assert chat.user_id == 666666\n        assert chat.first_name == 'Moshe'\n\n\n@pytest.mark.asyncio\nasync def test_bot_model():\n    bot = Bot(\"fake bot id\", \"https://google.com\")\n    assert bot.base == 'https://api.telegram.org/botfake bot id/'\n    assert bot.webhook_setter_url == 'https://api.telegram.org/botfake \\\nbot id/setWebhook?url=https://google.com/telegram/'\n\n    assert bot.base == bot._set_base_url(\"fake bot id\")\n    assert bot.webhook_setter_url == bot._set_webhook_setter_url(\n        \"https://google.com\")\n\n    set_request = await bot.set_webhook()\n    assert set_request.json() == {\n        'ok': False,\n        'error_code': 404,\n        'description': 'Not Found'\n    }\n\n    drop_request = await bot.drop_webhook()\n    assert drop_request.json() == {\n        'ok': False,\n        'error_code': 404,\n        'description': 'Not Found'\n    }\n\n    send_request = await bot.send_message(\"654654645\", \"hello\")\n    assert send_request.status_code == status.HTTP_404_NOT_FOUND\n    assert send_request.json() == {\n        'ok': False,\n        'error_code': 404,\n        'description': 'Not Found'\n    }\n\n\nclass TestBotClient:\n\n    @staticmethod\n    @pytest.mark.asyncio\n    async def test_user_not_registered(telegram_client):\n        response = await telegram_client.post(\n            '/telegram/', json=gen_message('/start'))\n        assert response.status_code == status.HTTP_200_OK\n        assert b'Hello, Moshe!' in response.content\n        assert b'To use PyLendar Bot you have to register' \\\n               in response.content\n\n    @staticmethod\n    @pytest.mark.asyncio\n    async def test_user_registered(telegram_client, session):\n        session.add(get_test_placeholder_user())\n        session.commit()\n        response = await telegram_client.post(\n            '/telegram/', json=gen_message('/start'))\n        assert response.status_code == status.HTTP_200_OK\n        assert b'Welcome to PyLendar telegram client!' in response.content\n\n\nclass TestHandlers:\n    TEST_USER = get_test_placeholder_user()\n\n    @pytest.mark.asyncio\n    async def test_start_handlers(self):\n        chat = Chat(gen_message('/start'))\n        message = MessageHandler(chat, self.TEST_USER)\n\n        assert '/start' in message.handlers\n        assert await message.process_callback() == '''Hello, Moshe!\nWelcome to PyLendar telegram client!'''\n\n    @pytest.mark.asyncio\n    async def test_default_handlers(self):\n        wrong_start = MessageHandler(\n            Chat(gen_message('start')), self.TEST_USER)\n        wrong_show_events = MessageHandler(\n            Chat(gen_message('show_events')), self.TEST_USER)\n        message = MessageHandler(\n            Chat(gen_message('hello')), self.TEST_USER)\n\n        assert await wrong_start.process_callback() == \"Unknown command.\"\n        assert await wrong_show_events.process_callback() == \"Unknown command.\"\n        assert await message.process_callback() == \"Unknown command.\"\n\n    @pytest.mark.asyncio\n    async def test_show_events_handler(self):\n        chat = Chat(gen_message('/show_events'))\n        message = MessageHandler(chat, self.TEST_USER)\n        assert await message.process_callback() == 'Choose events day.'\n\n    @pytest.mark.asyncio\n    async def test_no_today_events_handler(self):\n        chat = Chat(gen_callback('Today'))\n        message = MessageHandler(chat, self.TEST_USER)\n        assert await message.process_callback() == \"There're no events today.\"\n\n    @pytest.mark.asyncio\n    async def test_today_handler(self, fake_user_events):\n        chat = Chat(gen_callback('Today'))\n        message = MessageHandler(chat, fake_user_events)\n        answer = f\"{today_date.strftime('%A, %B %d')}:\\n\"\n        assert await message.process_callback() == answer\n\n    @pytest.mark.asyncio\n    async def test_this_week_handler(self):\n        chat = Chat(gen_callback('This week'))\n        message = MessageHandler(chat, self.TEST_USER)\n        assert await message.process_callback() == 'Choose a day.'\n\n    @pytest.mark.asyncio\n    async def test_no_chosen_day_handler(self):\n        chat = Chat(gen_callback('10 Feb 2021'))\n        message = MessageHandler(chat, self.TEST_USER)\n        message.handlers['10 Feb 2021'] = message.chosen_day_handler\n        answer = \"There're no events on February 10.\"\n        assert await message.process_callback() == answer\n\n    @pytest.mark.asyncio\n    async def test_chosen_day_handler(self, fake_user_events):\n        chosen_date = today_date + timedelta(days=2)\n        button = str(chosen_date.strftime(DATE_FORMAT))\n        chat = Chat(gen_callback(button))\n        message = MessageHandler(chat, fake_user_events)\n        message.handlers[button] = message.chosen_day_handler\n        answer = f\"{chosen_date.strftime('%A, %B %d')}:\\n\"\n        assert await message.chosen_day_handler() == answer\n\n    @pytest.mark.asyncio\n    async def test_new_event_handler(self):\n        chat = Chat(gen_message('/new_event'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = 'Please, give your event a title.'\n        assert await message.process_callback() == answer\n\n    @pytest.mark.asyncio\n    async def test_process_new_event(self):\n        chat = Chat(gen_message('New Title'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = 'Title:\\nNew Title\\n\\n'\n        answer += 'Add a description of the event.'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('New Content'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = 'Content:\\nNew Content\\n\\n'\n        answer += 'Where the event will be held?'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('Universe'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = 'Location:\\nUniverse\\n\\n'\n        answer += 'When does it start?'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('Not valid start datetime input'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = '❗️ Please, enter a valid date/time.'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('today'))\n        message = MessageHandler(chat, self.TEST_USER)\n        today = datetime.today()\n        answer = f'Starts on:\\n{today.strftime(\"%d %b %Y %H:%M\")}\\n\\n'\n        answer += 'And when does it end?'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('Not valid end datetime input'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = '❗️ Please, enter a valid date/time.'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('tomorrow'))\n        message = MessageHandler(chat, self.TEST_USER)\n        tomorrow = today + timedelta(days=1)\n        answer = 'Title:\\nNew Title\\n\\n'\n        answer += 'Content:\\nNew Content\\n\\n'\n        answer += 'Location:\\nUniverse\\n\\n'\n        answer += f'Starts on:\\n{today.strftime(\"%d %b %Y %H:%M\")}\\n\\n'\n        answer += f'Ends on:\\n{tomorrow.strftime(\"%d %b %Y %H:%M\")}'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('create'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = 'New event was successfully created 🎉'\n        assert await message.process_callback() == answer\n\n    @pytest.mark.asyncio\n    async def test_process_new_event_cancel(self):\n        chat = Chat(gen_message('/new_event'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = 'Please, give your event a title.'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('cancel'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = '🚫 The process was canceled.'\n        assert await message.process_callback() == answer\n\n    @pytest.mark.asyncio\n    async def test_process_new_event_restart(self):\n        chat = Chat(gen_message('/new_event'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = 'Please, give your event a title.'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('New Title'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = 'Title:\\nNew Title\\n\\n'\n        answer += 'Add a description of the event.'\n        assert await message.process_callback() == answer\n\n        chat = Chat(gen_message('restart'))\n        message = MessageHandler(chat, self.TEST_USER)\n        answer = 'Please, give your event a title.'\n        assert await message.process_callback() == answer\n\n\n@pytest.mark.asyncio\nasync def test_reply_unknown_user():\n    chat = Chat(gen_message('/show_events'))\n    answer = await reply_unknown_user(chat)\n    assert answer == '''\nHello, Moshe!\n\nTo use PyLendar Bot you have to register\nyour Telegram Id in your profile page.\n\nYour Id is 666666\nKeep it secret!\n\nhttps://calendar.pythonic.guru/profile/\n'''\n"}
{"type": "test_file", "path": "tests/security_testing_routes.py", "content": "from fastapi import APIRouter, Depends, Request\n\nfrom app.internal.security.dependancies import (\n    current_user, current_user_from_db,\n    is_logged_in, is_manager, User\n)\n\n\n\"\"\"\nThese routes are for security testing.\nThey represent an example for how to use\nsecurity dependencies in other routes.\n\"\"\"\nrouter = APIRouter(\n    prefix=\"\",\n    tags=[\"/security\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n\n\n@router.get('/is_logged_in')\nasync def is_logged_in(\n        request: Request, user: bool = Depends(is_logged_in)):\n    \"\"\"This is how to protect route for logged in user only.\n    Dependency will return True.\n    if user not looged-in, will be redirected to login route.\n    \"\"\"\n    return {\"user\": user}\n\n\n@router.get('/is_manager')\nasync def is_manager(\n        request: Request, user: bool = Depends(is_manager)):\n    \"\"\"This is how to protect route for logged in manager only.\n    Dependency will return True.\n    if user not looged-in, or have no manager permission,\n    will be redirected to login route.\n    \"\"\"\n    return {\"manager\": user}\n\n\n@router.get('/current_user_from_db')\nasync def current_user_from_db(\n        request: Request, user: User = Depends(current_user_from_db)):\n    \"\"\"This is how to protect route for logged in user only.\n    Dependency will return User object.\n    if user not looged-in, will be redirected to login route.\n    \"\"\"\n    return {\"user\": user.username}\n\n\n@router.get('/current_user')\nasync def current_user(\n        request: Request, user: User = Depends(current_user)):\n    \"\"\"This is how to protect route for logged in user only.\n    Dependency will return schema.CurrentUser object,\n    contains user_id and username.\n    if user not looged-in, will be redirected to login route.\n    \"\"\"\n    return {\"user\": user.username}\n"}
{"type": "test_file", "path": "tests/test_about.py", "content": "def test_about_page(client):\n    response = client.get(\"/about\")\n    assert response.ok\n    assert b\"Yam\" in response.content\n"}
{"type": "test_file", "path": "tests/test_agenda_internal.py", "content": "from datetime import date, datetime\n\nimport pytest\n\nfrom app.internal import agenda_events\nfrom app.internal.agenda_events import get_events_per_dates\n\n\nclass TestAgenda:\n    START = datetime(2021, 11, 1, 8, 00, 00)\n    dates = [\n        (START, datetime(2021, 11, 3, 8, 00, 0),\n         '2 days'),\n        (START, datetime(2021, 11, 3, 10, 30, 0),\n         '2 days 2 hours and 30 minutes'),\n        (START, datetime(2021, 11, 1, 8, 30, 0),\n         '30 minutes'),\n        (START, datetime(2021, 11, 1, 10, 00, 0),\n         '2 hours'),\n        (START, datetime(2021, 11, 1, 10, 30, 0),\n         '2 hours and 30 minutes'),\n        (START, datetime(2021, 11, 2, 10, 00, 0),\n         'a day and 2 hours'),\n    ]\n\n    @pytest.mark.parametrize('start, end, diff', dates)\n    def test_get_time_delta_string(self, start, end, diff):\n        assert agenda_events.get_time_delta_string(start, end) == diff\n\n    def test_get_events_per_dates_success(self, today_event, session):\n        events = get_events_per_dates(\n            session=session,\n            user_id=today_event.owner_id,\n            start=today_event.start.date(),\n            end=today_event.end.date(),\n        )\n        assert list(events) == [today_event]\n\n    def test_get_events_per_dates_failure(self, yesterday_event, session):\n        events = get_events_per_dates(\n            session=session,\n            user_id=yesterday_event.owner_id,\n            start=date.today(),\n            end=date.today(),\n        )\n        assert list(events) == []\n"}
{"type": "test_file", "path": "tests/test_app.py", "content": "from sqlalchemy.orm import Session\n\nfrom app.dependencies import get_db\n\n\nclass TestApp:\n\n    @staticmethod\n    def test_get_db():\n        assert isinstance(next(get_db()), Session)\n"}
{"type": "test_file", "path": "tests/test_agenda_route.py", "content": "from datetime import date, datetime, timedelta\n\nfrom fastapi import status\n\n\nclass TestAgenda:\n    \"\"\"In the test we are receiving event fixtures\n    as parameters so they will load into the database\"\"\"\n\n    AGENDA = \"/agenda\"\n    AGENDA_7_DAYS = \"/agenda?days=7\"\n    AGENDA_30_DAYS = \"/agenda?days=30\"\n    NO_EVENTS = b\"No events found...\"\n    INVALID_DATES = b\"Start date is greater than end date\"\n    today_date = datetime.today().replace(hour=0, minute=0, second=0)\n\n    @staticmethod\n    def test_agenda_page_no_arguments_when_no_today_events(\n            agenda_test_client, session):\n        resp = agenda_test_client.get(TestAgenda.AGENDA)\n        assert resp.status_code == status.HTTP_200_OK\n        assert TestAgenda.NO_EVENTS in resp.content\n\n    def test_agenda_page_no_arguments_when_today_events_exist(\n            self, agenda_test_client, session, sender, today_event,\n            today_event_2, yesterday_event, next_week_event,\n            next_month_event, old_event\n    ):\n        resp = agenda_test_client.get(TestAgenda.AGENDA)\n        assert resp.ok\n        assert b\"event 1\" in resp.content\n        assert b\"event 2\" in resp.content\n        assert b\"event 3\" not in resp.content\n        assert b\"event 4\" not in resp.content\n        assert b\"event 5\" not in resp.content\n        assert b\"event 6\" not in resp.content\n\n    @staticmethod\n    def test_agenda_per_7_days(\n            agenda_test_client, session, sender, today_event,\n            today_event_2, yesterday_event, next_week_event,\n            next_month_event, old_event\n    ):\n        resp = agenda_test_client.get(TestAgenda.AGENDA_7_DAYS)\n        today = date.today().strftime(\"%d/%m/%Y\")\n        assert resp.status_code == status.HTTP_200_OK\n        assert bytes(today, 'utf-8') in resp.content\n        assert b\"event 1\" in resp.content\n        assert b\"event 2\" in resp.content\n        assert b\"event 3\" not in resp.content\n        assert b\"event 4\" in resp.content\n        assert b\"event 5\" not in resp.content\n        assert b\"event 6\" not in resp.content\n\n    @staticmethod\n    def test_agenda_per_30_days(\n            agenda_test_client, session, sender, today_event,\n            today_event_2, yesterday_event, next_week_event,\n            next_month_event, old_event\n    ):\n        resp = agenda_test_client.get(TestAgenda.AGENDA_30_DAYS)\n        today = date.today().strftime(\"%d/%m/%Y\")\n        assert resp.status_code == status.HTTP_200_OK\n        assert bytes(today, 'utf-8') in resp.content\n        assert b\"event 1\" in resp.content\n        assert b\"event 2\" in resp.content\n        assert b\"event 3\" not in resp.content\n        assert b\"event 4\" in resp.content\n        assert b\"event 5\" in resp.content\n        assert b\"event 6\" not in resp.content\n\n    def test_agenda_between_two_dates(\n            self, agenda_test_client, session, sender, today_event,\n            today_event_2, yesterday_event, next_week_event,\n            next_month_event, old_event\n    ):\n        start_date = (self.today_date + timedelta(days=8, hours=4)).date()\n        end_date = (self.today_date + timedelta(days=32, hours=4)).date()\n        resp = agenda_test_client.get(\n            f\"/agenda?start_date={start_date}&end_date={end_date}\")\n        assert resp.status_code == status.HTTP_200_OK\n        assert b\"event 1\" not in resp.content\n        assert b\"event 2\" not in resp.content\n        assert b\"event 3\" not in resp.content\n        assert b\"event 4\" not in resp.content\n        assert b\"event 5\" in resp.content\n        assert b\"event 6\" not in resp.content\n\n    def test_agenda_start_bigger_than_end(self, agenda_test_client):\n        start_date = self.today_date.date()\n        end_date = (self.today_date - timedelta(days=2)).date()\n        resp = agenda_test_client.get(\n            f\"/agenda?start_date={start_date}&end_date={end_date}\")\n        assert resp.status_code == status.HTTP_200_OK\n        assert TestAgenda.INVALID_DATES in resp.content\n\n    @staticmethod\n    def test_no_show_events_user_2(\n            agenda_test_client, session, sender, today_event,\n            today_event_2, yesterday_event, next_week_event,\n            next_month_event, old_event\n    ):\n        # \"user\" is just a different event creator\n        resp = agenda_test_client.get(TestAgenda.AGENDA)\n        assert resp.status_code == status.HTTP_200_OK\n        assert b\"event 7\" not in resp.content\n"}
{"type": "test_file", "path": "tests/test_association.py", "content": "class TestAssociation:\n    def test_association_data(self, association, event):\n        assert association.events == event\n\n    def test_repr(self, association):\n        assert (\n                association.__repr__()\n                == f'<UserEvent ({association.participants}, '\n                   f'{association.events})>')\n"}
{"type": "test_file", "path": "tests/test_astronomy.py", "content": "import datetime\n\nfrom fastapi import status\nimport httpx\nimport pytest\nimport requests\nimport responses\nimport respx\n\nfrom app.internal.astronomy import ASTRONOMY_URL\nfrom app.internal.astronomy import get_astronomical_data\n\nRESPONSE_FROM_MOCK = {\n    \"location\": {\n        \"name\": \"Tel Aviv-Yafo\",\n        \"region\": \"Tel Aviv\",\n        \"country\": \"Israel\",\n        \"lat\": 32.07,\n        \"lon\": 34.76,\n        \"tz_id\": \"Asia/Jerusalem\",\n        \"localtime_epoch\": 1611399607,\n        \"localtime\": \"2021-01-23 13:00\",\n    },\n    \"astronomy\": {\n        \"astro\": {\n            \"sunrise\": \"05:25 AM\",\n            \"sunset\": \"06:03 PM\",\n            \"moonrise\": \"01:56 PM\",\n            \"moonset\": \"03:04 AM\",\n            \"moon_phase\": \"Waxing Gibbous\",\n            \"moon_illumination\": \"79\",\n        }\n    }\n}\n\nERROR_RESPONSE_FROM_MOCK = {\n    \"error\": {\n        \"message\": \"Error Text\",\n    }\n}\n\n\n@pytest.mark.asyncio\nasync def test_get_astronomical_data(httpx_mock):\n    requested_date = datetime.datetime(day=4, month=4, year=2020)\n    httpx_mock.add_response(method=\"GET\", json=RESPONSE_FROM_MOCK)\n    output = await get_astronomical_data(requested_date, \"tel aviv\")\n    assert output['success']\n\n\n@respx.mock\n@pytest.mark.asyncio\nasync def test_astronomical_data_error_from_api():\n    requested_date = datetime.datetime(day=4, month=4, year=2021)\n    route = respx.get(ASTRONOMY_URL)\n    route.return_value = httpx.Response(\n        status.HTTP_200_OK,\n        json=ERROR_RESPONSE_FROM_MOCK,\n    )\n    output = await get_astronomical_data(requested_date, \"123\")\n    assert not output['success']\n\n\n@respx.mock\n@pytest.mark.asyncio\nasync def test_astronomical_exception_from_api(httpx_mock):\n    requested_date = datetime.datetime.now() + datetime.timedelta(days=3)\n    respx.get(ASTRONOMY_URL).mock(\n        return_value=httpx.Response(status.HTTP_500_INTERNAL_SERVER_ERROR))\n    output = await get_astronomical_data(requested_date, \"456\")\n    assert not output['success']\n\n\n@responses.activate\n@pytest.mark.asyncio\nasync def test_astronomical_no_response_from_api():\n    requested_date = datetime.datetime(day=11, month=1, year=2020)\n    responses.add(\n        responses.GET,\n        ASTRONOMY_URL,\n        status=status.HTTP_500_INTERNAL_SERVER_ERROR,\n    )\n    requests.get(ASTRONOMY_URL)\n    output = await get_astronomical_data(requested_date, \"789\")\n    assert not output['success']\n"}
{"type": "test_file", "path": "tests/test_calendar_grid.py", "content": "import datetime\n\nimport app.routers.calendar_grid as cg\n\nDATE = datetime.date(1988, 5, 3)\nDAY = cg.Day(datetime.date(1988, 5, 3))\nWEEKEND = cg.DayWeekend(datetime.date(2021, 1, 23))\nN_DAYS = 3\nN_DAYS_BEFORE = datetime.date(1988, 4, 30)\nNEXT_N_DAYS = [\n    cg.Day(datetime.date(1988, 5, 4)),\n    cg.Day(datetime.date(1988, 5, 5)),\n    cg.Day(datetime.date(1988, 5, 6))\n]\nDAY_TYPES = [cg.Day, cg.DayWeekend, cg.Today, cg.FirstDayMonth]\nWEEK_DAYS = cg.Week.WEEK_DAYS\n\n\nclass TestCalendarGrid:\n    @staticmethod\n    def test_get_calendar(client):\n        response = client.get(\"/calendar/month\")\n        assert response.ok\n        assert b\"SUNDAY\" in response.content\n\n    @staticmethod\n    def test_get_calendar_extends(client):\n        days = 42\n        response = client.get(\n            f\"/calendar/month/add/{DAY.set_id()}?days={days}\"\n        )\n        assert response.ok\n        assert b\"08-May\" in response.content\n\n    @staticmethod\n    def test_create_day():\n        dates_to_check = {\n            'normal_day': datetime.date(2021, 1, 20),\n            'weekend': datetime.date(2021, 1, 23),\n            'today': datetime.date.today(),\n            'first_month': datetime.date(2021, 1, 1)\n        }\n\n        for i, value in enumerate(dates_to_check.values()):\n            assert isinstance(cg.create_day(value), DAY_TYPES[i])\n\n    @staticmethod\n    def test_get_next_date():\n        next_day_generator = cg.get_next_date(DATE)\n        next_day = next(next_day_generator, None)\n        next_day_check = cg.Day(DATE + datetime.timedelta(days=1))\n        assert next_day\n        assert isinstance(next_day, cg.Day)\n        assert next_day.date == next_day_check.date\n\n    @staticmethod\n    def test_get_date_before_n_days():\n        assert cg.get_date_before_n_days(DATE, N_DAYS) == N_DAYS_BEFORE\n\n    @staticmethod\n    def test_get_first_day_month_block(Calendar):\n        assert (\n            cg.get_first_day_month_block(DATE)\n            == next(Calendar.itermonthdates(DATE.year, DATE.month))\n        )\n\n    @staticmethod\n    def test_get_n_days():\n        next_n_dates = cg.get_n_days(DATE, N_DAYS)\n        for i in range(N_DAYS):\n            assert next(next_n_dates).date == NEXT_N_DAYS[i].date\n\n    @staticmethod\n    def test_create_weeks():\n        week = cg.create_weeks(NEXT_N_DAYS, cg.Week.WEEK_DAYS)\n        assert week\n        assert isinstance(week[0], cg.Week)\n        assert isinstance(week[0].days[0], cg.Day)\n        assert len(week) == 1 and len(week[0].days) == 3\n\n    @staticmethod\n    def test_get_month_block(Calendar):\n        month_weeks = cg.create_weeks(\n            Calendar.itermonthdates(1988, 5), WEEK_DAYS)\n        get_block = cg.get_month_block(cg.Day(DATE), n=len(month_weeks))\n\n        for i in range(len(month_weeks)):\n            for j in range(cg.Week.WEEK_DAYS):\n                assert get_block[i].days[j].date == month_weeks[i].days[j]\n\n    @staticmethod\n    def test_get_user_local_time():\n        time_string = \"%b%w%Y\"\n        server_time = cg.Day.get_user_local_time()\n        server_time_check = datetime.datetime.today()\n        assert server_time\n        assert server_time.strftime(\n            time_string) == server_time_check.strftime(time_string)\n\n    @staticmethod\n    def test_is_weekend():\n        assert not cg.Day.is_weekend(DATE)\n        assert cg.Day.is_weekend(WEEKEND.date)\n\n    @staticmethod\n    def test_display_day():\n        assert DAY.display() == '03 MAY 88'\n\n    @staticmethod\n    def test_set_id():\n        assert DAY.set_id() == '03-May-1988'\n\n    @staticmethod\n    def test_display_str():\n        assert str(DAY) == '03'\n\n    @staticmethod\n    def test_create_week_object():\n        assert cg.Week(NEXT_N_DAYS)\n"}
{"type": "test_file", "path": "tests/test_calendar_privacy.py", "content": "from app.internal.calendar_privacy import can_show_calendar\n# TODO after user system is merged:\n# from app.internal.security.dependancies import CurrentUser\nfrom app.routers.user import create_user\n\n\ndef test_can_show_calendar_public(session, user):\n    user.privacy = \"Public\"\n    # TODO to be replaced after user system is merged:\n    # current_user = CurrentUser(**user.__dict__)\n    current_user = user\n    result = can_show_calendar(\n        requested_user_username='test_username',\n        db=session, current_user=current_user\n    )\n    assert result is True\n    session.commit()\n\n\ndef test_can_show_calendar_private(session, user):\n    another_user = create_user(\n        session=session,\n        username='new_test_username2',\n        email='new_test.email2@gmail.com',\n        password='passpar_2',\n        language_id=1\n    )\n    current_user = user\n    # TODO to be replaced after user system is merged:\n    # current_user = CurrentUser(**user.__dict__)\n\n    result_a = can_show_calendar(\n        requested_user_username='new_test_username2',\n        db=session, current_user=current_user\n    )\n    result_b = can_show_calendar(\n        requested_user_username='test_username',\n        db=session, current_user=current_user\n    )\n    assert result_a is False\n    assert result_b is True\n    session.delete(another_user)\n    session.commit()\n"}
{"type": "test_file", "path": "tests/test_categories.py", "content": "import pytest\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.testing import mock\nfrom starlette import status\nfrom starlette.datastructures import ImmutableMultiDict\n\nfrom app.database.models import Event\nfrom app.routers.categories import (get_user_categories,\n                                    validate_request_params,\n                                    validate_color_format)\n\n\nclass TestCategories:\n    CATEGORY_ALREADY_EXISTS_MSG = \"category is already exists for\"\n    UNALLOWED_PARAMS = \"contains unallowed params\"\n    BAD_COLOR_FORMAT = \"if not from expected format\"\n\n    @staticmethod\n    def test_get_categories_logic_succeeded(session, user, category):\n        assert get_user_categories(session, category.user_id) == [category]\n\n    @staticmethod\n    def test_creating_new_category(client, user):\n        response = client.post(\"/categories/\",\n                               json={\"user_id\": user.id, \"name\": \"Foo\",\n                                     \"color\": \"eecc11\"})\n        assert response.ok\n        assert {(\"user_id\", user.id), (\"name\", \"Foo\"),\n                (\"color\", \"eecc11\")}.issubset(\n            set(response.json()['category'].items()))\n\n    @staticmethod\n    def test_creating_not_unique_category_failed(client, sender, category):\n        response = client.post(\"/categories/\", json={\"user_id\": sender.id,\n                                                     \"name\": \"Guitar Lesson\",\n                                                     \"color\": \"121212\"})\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert TestCategories.CATEGORY_ALREADY_EXISTS_MSG in \\\n               response.json()[\"detail\"]\n\n    @staticmethod\n    def test_creating_new_category_bad_color_format(client, user):\n        response = client.post(\"/categories/\",\n                               json={\"user_id\": user.id, \"name\": \"Foo\",\n                                     \"color\": \"bad format\"})\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert TestCategories.BAD_COLOR_FORMAT in response.json()[\"detail\"]\n\n    @staticmethod\n    def test_create_event_with_category(category):\n        event = Event(title=\"OOO\", content=\"Guitar rocks!!\",\n                      owner_id=category.user_id, category_id=category.id)\n        assert event.category_id is not None\n        assert event.category_id == category.id\n\n    @staticmethod\n    def test_update_event_with_category(today_event, category):\n        assert today_event.category_id is None\n        today_event.category_id = category.id\n        assert today_event.category_id is not None\n        assert today_event.category_id == category.id\n\n    @staticmethod\n    def test_get_user_categories(client, category):\n        response = client.get(f\"/categories/?user_id={category.user_id}\"\n                              f\"&name={category.name}&color={category.color}\")\n        assert response.ok\n        assert len(response.json()) == 1\n        assert set(response.json()[0].items()) == {\n            (\"user_id\", category.user_id), (\"color\", \"121212\"),\n            (\"name\", \"Guitar Lesson\"), (\"id\", category.id)}\n\n    @staticmethod\n    def test_get_category_by_name(client, sender, category):\n        response = client.get(f\"/categories/?user_id={category.user_id}\"\n                              f\"&name={category.name}\")\n        assert response.ok\n        assert len(response.json()) == 1\n        assert set(response.json()[0].items()) == {\n            (\"user_id\", category.user_id), (\"color\", \"121212\"),\n            (\"name\", \"Guitar Lesson\"), (\"id\", category.id)}\n\n    @staticmethod\n    def test_get_category_by_color(client, sender, category):\n        response = client.get(f\"/categories/?user_id={category.user_id}&\"\n                              f\"color={category.color}\")\n        assert response.ok\n        assert len(response.json()) == 1\n        assert set(response.json()[0].items()) == {\n            (\"user_id\", category.user_id), (\"color\", \"121212\"),\n            (\"name\", \"Guitar Lesson\"), (\"id\", category.id)}\n\n    @staticmethod\n    def test_get_category_bad_request(client):\n        response = client.get(\"/categories/\")\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert TestCategories.UNALLOWED_PARAMS in response.json()[\"detail\"]\n\n    @staticmethod\n    def test_repr(category):\n        assert category.__repr__() == \\\n               f'<Category {category.id} {category.name} {category.color}>'\n\n    @staticmethod\n    def test_to_dict(category):\n        assert {c.name: getattr(category, c.name) for c in\n                category.__table__.columns} == category.to_dict()\n\n    @staticmethod\n    @pytest.mark.parametrize('params, expected_result', [\n        (ImmutableMultiDict([('user_id', ''), ('name', ''),\n                             ('color', 'aabbcc')]), True),\n        (ImmutableMultiDict([('user_id', ''), ('name', '')]), True),\n        (ImmutableMultiDict([('user_id', ''), ('color', 'aabbcc')]), True),\n        (ImmutableMultiDict([('user_id', '')]), True),\n        (ImmutableMultiDict([('name', ''), ('color', 'aabbcc')]), False),\n        (ImmutableMultiDict([]), False),\n        (ImmutableMultiDict([('user_id', ''), ('name', ''),\n                             ('color', 'aabbcc'), ('bad_param', '')]), False),\n    ])\n    def test_validate_request_params(params, expected_result):\n        assert validate_request_params(params) == expected_result\n\n    @staticmethod\n    @pytest.mark.parametrize('color, expected_result', [\n        (\"aabbcc\", True),\n        (\"110033\", True),\n        (\"114b33\", True),\n        (\"\", False),\n        (\"aabbcg\", False),\n        (\"aabbc\", False),\n    ])\n    def test_validate_color_format(color, expected_result):\n        assert validate_color_format(color) == expected_result\n\n    @staticmethod\n    def test_get_categories_failed(session):\n        def raise_error(param):\n            raise SQLAlchemyError()\n\n        session.query = mock.Mock(side_effect=raise_error)\n        assert get_user_categories(session, 1) == []\n"}
{"type": "test_file", "path": "tests/test_celebrity.py", "content": "import datetime\n\nimport pytest\n\nfrom app.internal.celebrity import get_today_month_and_day\n\nCELEBRITY_ROUTE = \"/celebrity\"\nFAKE_TIME = datetime.date(2018, 9, 18)\n\nBAD_DATES = [\n    datetime.date(2021, 1, 1),\n    datetime.date(1789, 7, 14),\n    datetime.date(1776, 7, 4),\n    datetime.date(1945, 1, 27),\n    datetime.date(2000, 10, 16),\n]\n\nGOOD_DATES = [\n    datetime.date(2020, 9, 18),\n    datetime.date(2019, 9, 18),\n    datetime.date(2016, 9, 18),\n]\n\n\n@pytest.fixture\ndef datetime_mock(monkeypatch):\n    class MockDateTime:\n\n        @staticmethod\n        def today():\n            return FAKE_TIME\n\n    monkeypatch.setattr(datetime, 'date', MockDateTime)\n\n\n@pytest.mark.parametrize('date', BAD_DATES)\ndef test_get_today_month_and_day_bad(date, datetime_mock):\n    assert get_today_month_and_day() != date.strftime(\"%m-%d\")\n\n\n@pytest.mark.parametrize('date', GOOD_DATES)\ndef test_get_today_month_and_day_good(date, datetime_mock):\n    assert get_today_month_and_day() == date.strftime(\"%m-%d\")\n\n\ndef test_celebrity_page_exists(client):\n    response = client.get(CELEBRITY_ROUTE)\n    assert response.ok\n    assert b'born today' in response.content\n"}
{"type": "test_file", "path": "tests/test_comment.py", "content": "import json\n\nfrom sqlalchemy.orm.session import Session\n\nfrom app.database.models import Comment, Event, User\nfrom app.internal import comment as cmt\nfrom app.internal.utils import delete_instance\n\n\ndef test_create_comment(session: Session, event: Event, user: User) -> None:\n    assert session.query(Comment).first() is None\n    cmt.create_comment(session, event, 'test content')\n    comment = session.query(Comment).first()\n    assert comment\n    delete_instance(session, comment)\n\n\ndef test_parse_comment(session: Session, comment: Comment) -> None:\n    data = {\n        'id': 1,\n        'avatar': 'profile.png',\n        'username': 'test_username',\n        'time': '01/01/2021 00:01',\n        'content': 'test comment',\n    }\n    assert cmt.parse_comment(session, comment) == data\n\n\ndef test_display_comment(session: Session, event: Event,\n                         comment: Comment) -> None:\n    comments = json.loads(cmt.display_comments(session, event))\n    assert len(comments) == 1\n\n\ndef test_display_comment_empty(session: Session, event: Event) -> None:\n    comments = json.loads(cmt.display_comments(session, event))\n    assert comments == []\n\n\ndef test_delete_comment(session: Session, comment: Comment) -> None:\n    assert session.query(Comment).first()\n    assert cmt.delete_comment(session, comment.id)\n    assert session.query(Comment).first() is None\n    assert not cmt.delete_comment(session, comment.id)\n"}
{"type": "test_file", "path": "tests/test_credits.py", "content": "class TestCredits:\n    CREDITS_OPENING = b\"Say hello to our developers\"\n\n    @staticmethod\n    def test_get_credits_ok_request(client):\n        response = client.get(\"/credits\")\n        assert response.ok\n        assert TestCredits.CREDITS_OPENING in response.content\n"}
{"type": "test_file", "path": "tests/test_currency.py", "content": "CURRENCY = '/currency'\nCUSTOM_DATE = \"/2021-1-3\"\n\n\ndef test_router_good(client):\n    resp = client.get(CURRENCY)\n    assert resp.ok\n    resp = client.get(CURRENCY + CUSTOM_DATE)\n    assert resp.ok\n    assert b'Currency' in resp.content\n"}
{"type": "test_file", "path": "tests/test_dayview.py", "content": "from datetime import datetime, timedelta\n\nfrom bs4 import BeautifulSoup\nimport pytest\n\nfrom app.database.models import Event\nfrom app.routers.dayview import (\n    DivAttributes,\n    is_all_day_event_in_day,\n    is_specific_time_event_in_day,\n)\n\nfrom app.routers.event import create_event\n\n\ndef create_dayview_event(events, session, user):\n    for event in events:\n        create_event(\n            db=session,\n            title=\"test\",\n            start=event.start,\n            end=event.end,\n            owner_id=user.id,\n            color=event.color,\n        )\n\n\ndef test_minutes_position_calculation(event_with_no_minutes_modified):\n    div_attr = DivAttributes(event_with_no_minutes_modified)\n    assert div_attr._minutes_position(div_attr.start_time.minute) is None\n    assert div_attr._minutes_position(div_attr.end_time.minute) is None\n    assert div_attr._minutes_position(0) is None\n    assert div_attr._minutes_position(60) == 4\n\n\ndef test_div_attributes(event1):\n    div_attr = DivAttributes(event1)\n    assert div_attr.total_time == \"07:05 - 09:15\"\n    assert div_attr.grid_position == \"32 / 40\"\n    assert div_attr.length == 130\n    assert div_attr.color == \"grey\"\n\n\n@pytest.mark.parametrize(\n    \"minutes,css_class,visiblity\",\n    [\n        (90, \"title-size-small\", True),\n        (45, \"title-size-xsmall\", False),\n        (30, \"title-size-tiny\", False),\n    ],\n)\ndef test_font_size_attribute(minutes, css_class, visiblity):\n    start = datetime(year=2021, month=2, day=3, hour=7)\n    end = start + timedelta(minutes=minutes)\n    event = Event(\n        title=\"test\",\n        content=\"test\",\n        start=start,\n        end=end,\n        owner_id=1,\n    )\n    div_attr = DivAttributes(event)\n    assert div_attr.title_size_class == css_class\n    assert div_attr.total_time_visible == visiblity\n\n\ndef test_div_attr_multiday(multiday_event):\n    day = datetime(year=2021, month=2, day=1)\n    assert DivAttributes(multiday_event, day).grid_position == \"55 / 101\"\n    day += timedelta(hours=24)\n    assert DivAttributes(multiday_event, day).grid_position == \"1 / 101\"\n    day += timedelta(hours=24)\n    assert DivAttributes(multiday_event, day).grid_position == \"1 / 55\"\n\n\ndef test_is_specific_time_event_in_day(all_day_event1, event3):\n    day = datetime(year=2021, month=2, day=3, hour=0, minute=0)\n    day_end = day + timedelta(hours=24)\n    function_returns_true = is_specific_time_event_in_day(\n        event=event3,\n        day=day,\n        day_end=day_end,\n    )\n    function_returns_false = is_specific_time_event_in_day(\n        event=all_day_event1,\n        day=day,\n        day_end=day_end,\n    )\n    assert function_returns_true\n    assert not function_returns_false\n\n\ndef test_is_all_day_event_in_day(all_day_event1, event3):\n    day = datetime(year=2021, month=2, day=3, hour=0, minute=0)\n    day_end = day + timedelta(hours=24)\n    function_returns_true = is_all_day_event_in_day(\n        event=all_day_event1,\n        day=day,\n        day_end=day_end,\n    )\n    function_returns_false = is_all_day_event_in_day(\n        event=event3,\n        day=day,\n        day_end=day_end,\n    )\n    assert function_returns_true\n    assert not function_returns_false\n\n\ndef test_div_attributes_with_costume_color(event2):\n    div_attr = DivAttributes(event2)\n    assert div_attr.color == \"blue\"\n\n\ndef test_wrong_timeformat(session, user, client, event1, event2, event3):\n    create_dayview_event([event1, event2, event3], session=session, user=user)\n    response = client.get(\"/day/1-2-2021\")\n    assert response.status_code == 404\n\n\ndef test_dayview_html(event1, event2, event3, session, user, client):\n    create_dayview_event([event1, event2, event3], session=session, user=user)\n    response = client.get(\"/day/2021-2-1\")\n    soup = BeautifulSoup(response.content, \"html.parser\")\n    assert \"FEBRUARY\" in str(soup.find(\"div\", {\"id\": \"top-tab\"}))\n    assert \"event1\" in str(soup.find(\"div\", {\"id\": \"event1\"}))\n    assert \"event2\" in str(soup.find(\"div\", {\"id\": \"event2\"}))\n    assert soup.find(\"div\", {\"id\": \"event3\"}) is None\n\n\n@pytest.mark.parametrize(\n    \"day,grid_position\",\n    [\n        (\"2021-2-1\", \"55 / 101\"),\n        (\"2021-2-2\", \"1 / 101\"),\n        (\"2021-2-3\", \"1 / 55\"),\n    ],\n)\ndef test_dayview_html_with_multiday_event(\n    multiday_event,\n    session,\n    user,\n    client,\n    day,\n    grid_position,\n):\n    create_dayview_event([multiday_event], session=session, user=user)\n    session.commit()\n    response = client.get(f\"/day/{day}\")\n    soup = BeautifulSoup(response.content, \"html.parser\")\n    grid_pos = f\"grid-row: {grid_position};\"\n    assert grid_pos in str(soup.find(\"div\", {\"id\": \"event1\"}))\n"}
{"type": "test_file", "path": "tests/test_email.py", "content": "from fastapi import BackgroundTasks, status\nimport pytest\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import User\nfrom app.internal.email import (mail, send, send_email_file,\n                                send_email_invitation, verify_email_pattern)\nfrom app.internal.utils import create_model, delete_instance\n\n\ndef test_email_send(client, user, event, smtpd):\n    mail.config.SUPPRESS_SEND = 1\n    mail.config.MAIL_SERVER = smtpd.hostname\n    mail.config.MAIL_PORT = smtpd.port\n    mail.config.USE_CREDENTIALS = False\n    mail.config.MAIL_TLS = False\n    with mail.record_messages() as outbox:\n        response = client.post(\n            \"/email/send\", data={\n                \"event_used\": event.id, \"user_to_send\": user.id,\n                \"title\": \"Testing\",\n                \"background_tasks\": BackgroundTasks})\n        assert len(outbox) == 1\n        assert response.ok\n\n\ndef test_failed_email_send(client, user, event, smtpd):\n    mail.config.SUPPRESS_SEND = 1\n    mail.config.MAIL_SERVER = smtpd.hostname\n    mail.config.MAIL_PORT = smtpd.port\n    with mail.record_messages() as outbox:\n        response = client.post(\n            \"/email/send\", data={\n                \"event_used\": event.id + 1, \"user_to_send\": user.id,\n                \"title\": \"Testing\",\n                \"background_tasks\": BackgroundTasks})\n        assert len(outbox) == 0\n        assert not response.ok\n\n\n@pytest.fixture\ndef configured_smtpd(smtpd):\n    \"\"\"\n    Overrides the SMTP related configuration to use a mock SMTP server\n    :param smtpd: the smtpdfix fixture that represents an SMTP server\n    :return: smtpd\n    \"\"\"\n\n    mail.config.SUPPRESS_SEND = 1\n    mail.config.MAIL_SERVER = smtpd.hostname\n    mail.config.MAIL_PORT = smtpd.port\n    mail.config.USE_CREDENTIALS = False\n    mail.config.MAIL_TLS = False\n    yield smtpd\n\n\ndef test_send_mail_no_body(client, configured_smtpd):\n    with mail.record_messages() as outbox:\n        response = client.post(\"/email/invitation/\")\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n        assert response.json() == {'detail': [{\n            'loc': ['body'],\n            'msg': 'field required',\n            'type': 'value_error.missing'}]}\n        assert not outbox\n\n\ndef test_send_mail_invalid_email(client, configured_smtpd):\n    with mail.record_messages() as outbox:\n        response = client.post(\"/email/invitation/\", json={\n            \"sender_name\": \"string\",\n            \"recipient_name\": \"string\",\n            \"recipient_mail\": \"test#mail.com\"\n        })\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n        assert response.json() == {\n            \"detail\": \"Please enter valid email address\"}\n        assert not outbox\n\n\ndef assert_validation_error_missing_body_fields(validation_msg,\n                                                missing_fields):\n    \"\"\"\n    helper function for asserting with open api validation errors\n    look at https://fastapi.tiangolo.com/tutorial/path-params/#data-validation\n    :param validation_msg: the response message after json\n    :param missing_fields: a list of fields that are asserted missing\n    \"\"\"\n    assert isinstance(validation_msg, dict)\n    assert 1 == len(validation_msg)\n    assert \"detail\" in validation_msg\n    details = validation_msg[\"detail\"]\n    assert isinstance(details, list)\n    assert len(missing_fields) == len(details)\n    for detail in details:\n        assert 3 == len(detail)\n        assert \"type\" in detail\n        assert \"value_error.missing\" == detail[\"type\"]\n        assert \"msg\" in detail\n        assert \"field required\" == detail[\"msg\"]\n        assert \"loc\" in detail\n        loc = detail[\"loc\"]\n        assert isinstance(loc, list)\n        assert 2 == len(loc)\n        assert \"body\" == loc[0]\n        assert loc[1] in missing_fields\n\n\n@pytest.mark.parametrize(\"body, missing_fields\", [\n    (\n            {\"sender_name\": \"string\", \"recipient_name\": \"string\"},\n            [\"recipient_mail\"],\n    ),\n\n    (\n            {\"sender_name\": \"string\", \"recipient_mail\": \"test@mail.com\"},\n            [\"recipient_name\"],\n    ),\n    (\n            {\"recipient_name\": \"string\", \"recipient_mail\": \"test@mail.com\"},\n            [\"sender_name\"],\n    ),\n    (\n            {\"sender_name\": \"string\"},\n            [\"recipient_name\", \"recipient_mail\"],\n    ),\n    (\n            {\"recipient_name\": \"string\"},\n            [\"sender_name\", \"recipient_mail\"],\n    ),\n    (\n            {\"recipient_mail\": \"test@mail.com\"},\n            [\"sender_name\", \"recipient_name\"],\n    ),\n])\ndef test_send_mail_partial_body(body, missing_fields,\n                                client, configured_smtpd):\n    with mail.record_messages() as outbox:\n        response = client.post(\"/email/invitation/\", json=body)\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n        assert_validation_error_missing_body_fields(response.json(),\n                                                    missing_fields)\n        assert not outbox\n\n\ndef test_send_mail_valid_email(client, configured_smtpd):\n    with mail.record_messages() as outbox:\n        response = client.post(\"/email/invitation/\", json={\n            \"sender_name\": \"string\",\n            \"recipient_name\": \"string\",\n            \"recipient_mail\": \"test@mail.com\"\n        }\n                               )\n        assert response.ok\n        assert outbox\n\n\n@pytest.mark.parametrize(\"sender_name,recipient_name,recipient_mail\", [\n    (\"\", \"other_person\", \"other@mail.com\"),\n    (\"us_person\", \"\", \"other@mail.com\"),\n])\ndef test_send_mail_bad_invitation(client,\n                                  configured_smtpd,\n                                  sender_name,\n                                  recipient_name,\n                                  recipient_mail):\n    with mail.record_messages() as outbox:\n        response = client.post(\"/email/invitation/\", json={\n            \"sender_name\": sender_name,\n            \"recipient_name\": recipient_name,\n            \"recipient_mail\": recipient_mail\n        }\n                               )\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n        assert response.json() == {\n            \"detail\": \"Couldn't send the email!\"}\n        assert not outbox\n\n\n@pytest.mark.parametrize(\"sender_name,recipient_name,recipient_mail\", [\n    (\"\", \"other_person\", \"other@mail.com\"),\n    (\"us_person\", \"\", \"other@mail.com\"),\n    (\"us_person\", \"other_person\", \"other#mail.com\"),\n])\ndef test_send_mail_bad_invitation_internal(client,\n                                           configured_smtpd,\n                                           sender_name,\n                                           recipient_name,\n                                           recipient_mail):\n    background_task = BackgroundTasks()\n    assert not send_email_invitation(sender_name,\n                                     recipient_name,\n                                     recipient_mail,\n                                     background_task)\n\n\n@pytest.mark.parametrize(\"recipient_mail,file_path\", [\n    (\"other@mail.com\", \"non_existing_file\"),\n    (\"other#mail.com\", __file__),\n])\ndef test_send_mail_bad_file_internal(client,\n                                     configured_smtpd,\n                                     recipient_mail,\n                                     file_path):\n    background_task = BackgroundTasks()\n    assert not send_email_file(file_path, recipient_mail, background_task)\n\n\ndef test_send_mail_good_file_internal(client, configured_smtpd):\n    background_task = BackgroundTasks()\n    assert send_email_file(__file__, \"good@mail.com\", background_task)\n\n\n@pytest.fixture\ndef bad_user(session: Session) -> User:\n    test_user = create_model(\n        session, User,\n        username='test_username',\n        password='test_password',\n        email='test.email#gmail.com',\n        language_id=1,\n    )\n    yield test_user\n    delete_instance(session, test_user)\n\n\ndef test_send(session, bad_user, event):\n    background_task = BackgroundTasks()\n    assert not send(session=session,\n                    event_used=1,\n                    user_to_send=1,\n                    title=\"Test\",\n                    background_tasks=background_task)\n\n\n@pytest.mark.parametrize(\"email\", [\"test#mail.com\",\n                                   \"test_mail.com\",\n                                   \"test@mail-com\"])\ndef test_verify_email_pattern(email):\n    assert not verify_email_pattern(email)\n"}
{"type": "test_file", "path": "tests/test_emotion.py", "content": "import datetime\n\nimport pytest\n\nfrom app.internal.emotion import (\n    Emoticon,\n    is_emotion_above_significance,\n    get_dominant_emotion,\n    get_emotion,\n    get_html_emoticon)\n\nfrom app.routers.event import create_event\n\n\nHAPPY_MESSAGE = \"This is great\"  # 100% happy\nSAD_MESSAGE = \"I'm so lonely and feel bad\"  # 100% sad\nANGRY_MESSAGE = \"I'm so mad, stop it\"  # 100% angry\nFEAR_MESSAGE = \"I'm afraid to fall\"  # 100% fear\nSURPRISE_MESSAGE = \"wow, this is new!\"  # 100% surprise\n\n\nemotion_tests = [\n    (HAPPY_MESSAGE, HAPPY_MESSAGE, Emoticon('Happy', 1.0, '&#128515')),\n    (SAD_MESSAGE, SAD_MESSAGE, Emoticon('Sad', 1.0, '&#128577')),\n    (ANGRY_MESSAGE, ANGRY_MESSAGE, Emoticon('Angry', 1.0, '&#128544')),\n    (FEAR_MESSAGE, FEAR_MESSAGE, Emoticon('Fear', 1.0, '&#128561')),\n    (SURPRISE_MESSAGE, SURPRISE_MESSAGE,\n     Emoticon('Surprise', 1.0, '&#128558')),\n    (SURPRISE_MESSAGE, None, Emoticon('Surprise', 1.0, '&#128558')),\n    (SURPRISE_MESSAGE, \"\", Emoticon('Surprise', 1.0, '&#128558')),\n    (HAPPY_MESSAGE, SAD_MESSAGE, Emoticon('Happy', 0.6, '&#128515')),\n]\n\nemotion_significance_tests = [\n    (Emoticon('Happy', 1.0, '&#128515'), None, True),\n    (Emoticon('Happy', 0.6, '&#128515'), None, True),\n    (Emoticon('Happy', 0.4, '&#128515'), None, False),\n    (Emoticon('Happy', 0.4, '&#128515'), 0.3, True),\n    (Emoticon('Happy', 0.7, '&#128515'), 0.8, False)\n]\n\nget_html_emoticon_tests = [\n    (Emoticon('Happy', 1.0, '&#128515'), '&#128515'),\n    (Emoticon('Happy', 1.0, None), None)\n]\n\nget_emotion_tests = [\n    Emoticon(HAPPY_MESSAGE, HAPPY_MESSAGE, '&#128515'),\n    Emoticon(SAD_MESSAGE, SAD_MESSAGE, '&#128577'),\n    Emoticon(HAPPY_MESSAGE, SAD_MESSAGE, '&#128515'),\n    Emoticon(\" \", \" \", None)\n]\n\ncreate_event_tests = [\n    (HAPPY_MESSAGE, datetime.datetime(2019, 5, 21, 0, 0),\n     datetime.datetime(2019, 5, 22, 0, 0), False, 1, HAPPY_MESSAGE, \"location\",\n     \"&#128515\"),\n    (SAD_MESSAGE, datetime.datetime(2019, 5, 21, 0, 0),\n     datetime.datetime(2019, 5, 22, 0, 0), False, 1, HAPPY_MESSAGE, \"location\",\n     \"&#128577\"),\n    (\" \", datetime.datetime(2019, 5, 21, 0, 0),\n     datetime.datetime(2019, 5, 22, 0, 0), False, 1, \" \", \"location\",\n     None)\n]\n\n\n@pytest.mark.parametrize(\"title, content, result\", emotion_tests)\ndef test_dominant_emotion(title, content, result):\n    assert get_dominant_emotion(title, content) == result\n\n\n@pytest.mark.parametrize(\"dominant_emotion, significance, result\",\n                         emotion_significance_tests)\ndef test_is_emotion_above_significance(dominant_emotion, significance, result):\n    if significance is None:\n        assert is_emotion_above_significance(dominant_emotion) == result\n    else:\n        assert is_emotion_above_significance(dominant_emotion,\n                                             significance) == result\n\n\n@pytest.mark.parametrize(\"dominant_emotion, result\", get_html_emoticon_tests)\ndef test_get_html_emoticon(dominant_emotion, result):\n    assert get_html_emoticon(dominant_emotion) == result\n\n\n@pytest.mark.parametrize(\"title, content, result\", get_emotion_tests)\ndef test_get_emotion(title, content, result):\n    assert get_emotion(title, content) == result\n\n\n@pytest.mark.parametrize(\"title, start, end, all_day, owner_id, content, \" +\n                         \"location, result\", create_event_tests)\ndef test_create_event(title, start, end, all_day,\n                      owner_id, content, location, result, session):\n    event = create_event(session, title, start,\n                         end, all_day, owner_id, content, location)\n    assert event.emotion == result\n"}
{"type": "test_file", "path": "tests/test_event.py", "content": "from datetime import datetime, timedelta\nimport json\nimport pytest\n\nfrom fastapi import HTTPException, Request\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm.session import Session\nfrom starlette import status\n\n\nfrom app.database.models import Comment, Event\nfrom app.dependencies import get_db\nfrom app.internal.utils import delete_instance\nfrom app.main import app\n\nfrom app.routers import event as evt\n\n\nCORRECT_EVENT_FORM_DATA = {\n    \"title\": \"test title\",\n    \"start_date\": \"2021-01-28\",\n    \"start_time\": \"12:59\",\n    \"end_date\": \"2021-01-28\",\n    \"end_time\": \"15:01\",\n    \"location\": \"fake city\",\n    \"vc_link\": \"https://us02web.zoom.us/j/875384596\",\n    \"description\": \"content\",\n    \"color\": \"red\",\n    \"availability\": \"True\",\n    \"privacy\": \"public\",\n    \"invited\": \"a@a.com,b@b.com\",\n    \"event_type\": \"on\",\n}\n\nCORRECT_EVENT_FORM_DATA_WITHOUT_EVENT_TYPE = {\n    \"title\": \"test title\",\n    \"start_date\": \"2021-01-28\",\n    \"start_time\": \"15:59\",\n    \"end_date\": \"2021-01-27\",\n    \"end_time\": \"15:01\",\n    \"location_type\": \"vc_url\",\n    \"location\": \"https://us02web.zoom.us/j/875384596\",\n    \"description\": \"content\",\n    \"color\": \"red\",\n    \"availability\": \"busy\",\n    \"privacy\": \"public\",\n    \"event_type\": \"on\",\n    \"is_google_event\": \"False\",\n}\n\nWRONG_EVENT_FORM_DATA = {\n    \"title\": \"test title\",\n    \"start_date\": \"2021-01-28\",\n    \"start_time\": \"15:59\",\n    \"end_date\": \"2021-01-27\",\n    \"end_time\": \"15:01\",\n    \"location\": \"fake city\",\n    \"vc_link\": \"not a zoom link\",\n    \"description\": \"content\",\n    \"color\": \"red\",\n    \"availability\": \"True\",\n    \"privacy\": \"public\",\n    \"invited\": \"a@a.com,b@b.com\",\n    \"event_type\": \"on\",\n    \"is_google_event\": \"False\",\n}\n\nBAD_EMAILS_FORM_DATA = {\n    \"title\": \"test title\",\n    \"start_date\": \"2021-01-28\",\n    \"start_time\": \"15:59\",\n    \"end_date\": \"2021-01-27\",\n    \"end_time\": \"15:01\",\n    \"location\": \"fake city\",\n    \"vc_link\": \"https://us02web.zoom.us/j/875384596\",\n    \"description\": \"content\",\n    \"color\": \"red\",\n    \"availability\": \"busy\",\n    \"privacy\": \"public\",\n    \"invited\": \"a@a.com,b@b.com,ccc\",\n    \"event_type\": \"on\",\n    \"is_google_event\": \"False\",\n}\n\nWEEK_LATER_EVENT_FORM_DATA = {\n    \"title\": \"test title\",\n    \"start_date\": \"2021-02-04\",\n    \"start_time\": \"12:59\",\n    \"end_date\": \"2021-02-04\",\n    \"end_time\": \"15:01\",\n    \"location\": \"fake city\",\n    \"vc_link\": \"https://us02web.zoom.us/j/875384596\",\n    \"description\": \"content\",\n    \"color\": \"red\",\n    \"availability\": \"busy\",\n    \"privacy\": \"public\",\n    \"event_type\": \"on\",\n    \"invited\": \"a@a.com,b@b.com\",\n    \"is_google_event\": \"False\",\n}\n\nTWO_WEEKS_LATER_EVENT_FORM_DATA = {\n    \"title\": \"test title\",\n    \"start_date\": \"2021-02-11\",\n    \"start_time\": \"12:59\",\n    \"end_date\": \"2021-02-11\",\n    \"end_time\": \"15:01\",\n    \"location\": \"fake city\",\n    \"vc_link\": \"https://us02web.zoom.us/j/875384596\",\n    \"description\": \"content\",\n    \"color\": \"red\",\n    \"availability\": \"busy\",\n    \"privacy\": \"public\",\n    \"invited\": \"a@a.com,b@b.com\",\n    \"event_type\": \"on\",\n    \"is_google_event\": \"False\",\n}\n\nCORRECT_ADD_EVENT_DATA = {\n    \"title\": \"test\",\n    \"start\": \"2021-02-13T09:03:49.560Z\",\n    \"end\": \"2021-02-13T09:03:49.560Z\",\n    \"content\": \"test\",\n    \"owner_id\": 0,\n    \"location\": \"test\",\n    \"is_google_event\": \"False\",\n}\n\nNONE_UPDATE_OPTIONS = [\n    {},\n    {\"test\": \"test\"},\n]\n\nINVALID_FIELD_UPDATE = [\n    {\"start\": \"20.01.2020\"},\n    {\"start\": datetime(2020, 2, 2), \"end\": datetime(2020, 1, 1)},\n    {\"start\": datetime(2030, 2, 2)},\n    {\"end\": datetime(1990, 1, 1)},\n]\n\n\ndef test_get_events(event_test_client, session, event):\n    response = event_test_client.get(\"/event/\")\n    assert response.ok\n\n\ndef test_create_event_api(event_test_client, session, event):\n    response = event_test_client.post(\n        \"/event/\",\n        data=json.dumps(CORRECT_ADD_EVENT_DATA),\n    )\n    assert response.ok\n\n\ndef test_eventedit(event_test_client):\n    response = event_test_client.get(\"/event/edit\")\n    assert response.ok\n    assert b\"Event Details\" in response.content\n\n\ndef test_eventview_with_id(event_test_client, session, event):\n    event_id = event.id\n    response = event_test_client.get(f\"/event/{event_id}\")\n    assert response.ok\n    assert b\"Event Details\" in response.content\n\n\ndef test_all_day_eventview_with_id(event_test_client, session, all_day_event):\n    event_id = all_day_event.id\n    response = event_test_client.get(f\"/event/{event_id}\")\n    assert response.ok\n\n\ndef test_create_event_with_default_availability(client, user, session):\n    \"\"\"\n    Test create event with default availability. (busy)\n    \"\"\"\n    data = {\n        \"title\": \"test title\",\n        \"start\": datetime.strptime(\"2021-01-01 15:59\", \"%Y-%m-%d %H:%M\"),\n        \"end\": datetime.strptime(\"2021-01-02 15:01\", \"%Y-%m-%d %H:%M\"),\n        \"vc_link\": \"https://us02web.zoom.us/j/875384596\",\n        \"content\": \"content\",\n        \"owner_id\": user.id,\n    }\n\n    event = evt.create_event(session, **data)\n    assert event.availability is True\n\n\ndef test_create_event_with_free_availability(client, user, session):\n    \"\"\"\n    Test create event with free availability.\n    \"\"\"\n    data = {\n        \"title\": \"test title\",\n        \"start\": datetime.strptime(\"2021-01-01 15:59\", \"%Y-%m-%d %H:%M\"),\n        \"end\": datetime.strptime(\"2021-01-02 15:01\", \"%Y-%m-%d %H:%M\"),\n        \"vc_link\": \"https://us02web.zoom.us/j/875384596\",\n        \"content\": \"content\",\n        \"owner_id\": user.id,\n        \"availability\": False,\n        \"is_google_event\": False,\n    }\n\n    event = evt.create_event(session, **data)\n    assert event.availability is False\n\n\ndef test_eventview_without_id(client):\n    response = client.get(\"/event/view\")\n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n\ndef test_eventedit_missing_old_invites(client, user):\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=CORRECT_EVENT_FORM_DATA,\n    )\n    assert response.ok\n    assert response.status_code == status.HTTP_302_FOUND\n\n    different_invitees_event = CORRECT_EVENT_FORM_DATA.copy()\n    different_invitees_event[\"invited\"] = \"c@c.com,d@d.com\"\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=different_invitees_event,\n    )\n    assert response.ok\n    assert response.status_code == status.HTTP_302_FOUND\n    for invitee in CORRECT_EVENT_FORM_DATA[\"invited\"].split(\",\"):\n        assert invitee in response.headers[\"location\"]\n\n\ndef test_eventedit_bad_emails(client, user):\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=BAD_EMAILS_FORM_DATA,\n    )\n    assert response.ok\n    assert response.status_code == status.HTTP_302_FOUND\n\n    different_invitees_event = CORRECT_EVENT_FORM_DATA.copy()\n    different_invitees_event[\"invited\"] = \"c@c.com,d@d.com\"\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=different_invitees_event,\n    )\n    assert response.ok\n    assert response.status_code == status.HTTP_302_FOUND\n    for invitee in CORRECT_EVENT_FORM_DATA[\"invited\"].split(\",\"):\n        assert invitee in response.headers[\"location\"]\n    assert \"ccc\" not in response.headers[\"location\"]\n\n\ndef test_eventedit_post_correct(client, user):\n    \"\"\"\n    Test create new event successfully.\n    \"\"\"\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=CORRECT_EVENT_FORM_DATA,\n    )\n    assert response.ok\n    assert (\n        client.app.url_path_for(\"eventview\", event_id=1).strip(\"1\")\n        in response.headers[\"location\"]\n    )\n\n\ndef test_eventedit_post_without_event_type(client, user):\n    \"\"\"\n    Test create new event successfully,\n    When the event type is not defined by the user.\n    \"\"\"\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=CORRECT_EVENT_FORM_DATA,\n    )\n    assert response.status_code == status.HTTP_302_FOUND\n    assert (\n        client.app.url_path_for(\"eventview\", event_id=1).strip(\"1\")\n        in response.headers[\"location\"]\n    )\n\n\ndef test_create_event_with_category(client, user, category, session):\n    \"\"\"\n    Test create event with category successfully.\n    \"\"\"\n    data = {**CORRECT_EVENT_FORM_DATA, **{\"category_id\": category.id}}\n\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=data,\n    )\n    assert response.ok\n    assert (\n        client.app.url_path_for(\"eventview\", event_id=1).strip(\"1\")\n        in response.headers[\"location\"]\n    )\n\n\ndef test_eventedit_post_wrong(client, user):\n    \"\"\"\n    Test create new event unsuccessfully.\n    \"\"\"\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=WRONG_EVENT_FORM_DATA,\n    )\n    assert response.json()[\"detail\"] == \"VC type with no valid zoom link\"\n\n\ndef test_eventedit_with_pattern(client, user):\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=CORRECT_EVENT_FORM_DATA,\n    )\n    assert response.ok\n    assert response.status_code == status.HTTP_302_FOUND\n\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=WEEK_LATER_EVENT_FORM_DATA,\n    )\n    assert response.ok\n    assert response.status_code == status.HTTP_302_FOUND\n    assert \"Same event happened 1 weeks before too. \" in response.headers[\n        \"location\"\n    ].replace(\"+\", \" \")\n\n    response = client.post(\n        client.app.url_path_for(\"create_new_event\"),\n        data=TWO_WEEKS_LATER_EVENT_FORM_DATA,\n    )\n    assert response.ok\n    assert response.status_code == status.HTTP_302_FOUND\n    assert \"Same event happened 1 weeks before too. \" in response.headers[\n        \"location\"\n    ].replace(\"+\", \" \")\n    assert \"Same event happened 2 weeks before too. \" in response.headers[\n        \"location\"\n    ].replace(\"+\", \" \")\n\n\n@pytest.mark.parametrize(\"data\", NONE_UPDATE_OPTIONS)\ndef test_invalid_update(event, data, session):\n    \"\"\"\n    Test update existing event.\n    \"\"\"\n    assert evt.update_event(event_id=event.id, event=data, db=session) is None\n\n\n@pytest.mark.parametrize(\"data\", INVALID_FIELD_UPDATE)\ndef test_invalid_fields(event, data, session):\n    \"\"\"\n    Test update existing event.\n    \"\"\"\n    with pytest.raises(HTTPException):\n        response = evt.update_event(event_id=event.id, event=data, db=session)\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n\n\ndef test_not_check_change_dates_allowed(event):\n    data = {\"start\": \"20.01.2020\"}\n    with pytest.raises(HTTPException):\n        assert (\n            evt.check_change_dates_allowed(event, data).status_code\n            == status.HTTP_400_BAD_REQUEST\n        )\n\n\ndef test_update_event_availability(event, session):\n    \"\"\"\n    Test update event's availability.\n    \"\"\"\n    original_availability = event.availability\n    data = {\"availability\": not original_availability}\n    assert (\n        original_availability\n        is not evt.update_event(\n            event_id=event.id,\n            event=data,\n            db=session,\n        ).availability\n    )\n\n\ndef test_successful_update(event, session):\n    \"\"\"\n    Test update existing event successfully.\n    \"\"\"\n    data = {\n        \"title\": \"successful\",\n        \"start\": datetime(2021, 1, 20),\n        \"end\": datetime(2021, 1, 21),\n        \"availability\": \"False\",\n    }\n    assert isinstance(evt.update_event(1, data, session), Event)\n    updated_event = evt.update_event(event_id=event.id, event=data, db=session)\n    assert \"successful\" in updated_event.title\n    assert updated_event.availability is False\n\n\ndef test_update_event_with_category(today_event, category, session):\n    \"\"\"\n    Test update category for an existing event successfully.\n    \"\"\"\n    data = {\n        \"title\": \"successful\",\n        \"category_id\": category.id,\n    }\n    updated_event = evt.update_event(\n        event_id=today_event.id,\n        event=data,\n        db=session,\n    )\n    assert \"successful\" in updated_event.title\n    assert updated_event.category_id == category.id\n\n\ndef test_update_db_close(event):\n    data = {\n        \"title\": \"Problem connecting to db in func update_event\",\n    }\n    with pytest.raises(HTTPException):\n        assert (\n            evt.update_event(\n                event_id=event.id,\n                event=data,\n                db=None,\n            ).status_code\n            == status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n\ndef test_update_event_does_not_exist(event, session):\n    data = {\"content\": \"An update test for an event does not exist\"}\n    with pytest.raises(HTTPException):\n        response = evt.update_event(\n            event_id=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            event=data,\n            db=session,\n        )\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n\ndef test_db_close_update(session, event):\n    data = {\n        \"title\": \"Problem connecting to db in func _update_event\",\n    }\n    with pytest.raises(HTTPException):\n        assert (\n            evt._update_event(\n                event_id=event.id,\n                event_to_update=data,\n                db=None,\n            ).status_code\n            == status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n\ndef test_repr(event):\n    assert event.__repr__() == f\"<Event {event.id}>\"\n\n\ndef test_no_connection_to_db_in_delete(event):\n    with pytest.raises(HTTPException):\n        response = evt.delete_event(event_id=1, db=None)\n        assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR\n\n\ndef test_no_connection_to_db_in_internal_deletion(event):\n    with pytest.raises(HTTPException):\n        assert (\n            evt._delete_event(event=event, db=None).status_code\n            == status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n\ndef test_successful_deletion(event_test_client, session, event):\n    response = event_test_client.delete(\"/event/1\")\n    assert response.ok\n    with pytest.raises(HTTPException):\n        assert (\n            \"Event ID does not exist. ID: 1\"\n            in evt.by_id(db=session, event_id=1).content\n        )\n\n\ndef test_change_owner(client, event_test_client, user, session, event):\n    \"\"\"\n    Test change owner of an event\n    \"\"\"\n    event_id = event.id\n    event_details = [\n        event.title,\n        event.content,\n        event.location,\n        event.start,\n        event.end,\n        event.color,\n        event.category_id,\n    ]\n    response = event_test_client.post(f\"/event/{event_id}/owner\", data=None)\n    assert response.status_code == status.HTTP_302_FOUND\n    assert response.ok\n    assert b\"View Event\" not in response.content\n    for event_detail in event_details:\n        assert (\n            str(event_detail).encode(\"utf-8\") not in response.content\n        ), f\"{event_detail} not in view event page\"\n    data = {\"username\": \"worng_username\"}\n    response = event_test_client.post(f\"/event/{event_id}/owner\", data=data)\n    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR\n    assert b\"Username does not exist.\" in response.content\n    data = {\"username\": user.username}\n    response = event_test_client.post(f\"/event/{event_id}/owner\", data=data)\n    assert response.ok\n    assert response.status_code == status.HTTP_302_FOUND\n\n\ndef test_deleting_an_event_does_not_exist(event_test_client, event):\n    response = event_test_client.delete(\"/event/2\")\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\n\ndef test_get_tamplate_to_share_event(event, session):\n    html_template = evt.get_template_to_share_event(\n        event_id=1,\n        user_name=\"michael\",\n        db=session,\n        request=Request.get,\n    )\n    assert html_template is not None\n\n\ndef test_add_comment(\n    event_test_client: TestClient,\n    session: Session,\n    event: Event,\n) -> None:\n    assert session.query(Comment).first() is None\n    content = \"test comment\"\n    path = evt.router.url_path_for(\"add_comment\", event_id=event.id)\n    data = {\"comment\": content}\n    response = event_test_client.post(path, data=data, allow_redirects=True)\n    assert response.ok\n    assert content in response.text\n    comment = session.query(Comment).first()\n    assert comment\n    delete_instance(session, comment)\n\n\ndef test_get_event_data(\n    session: Session,\n    event: Event,\n    comment: Comment,\n) -> None:\n    data = (\n        event,\n        [\n            {\n                \"id\": 1,\n                \"avatar\": \"profile.png\",\n                \"username\": \"test_username\",\n                \"time\": \"01/01/2021 00:01\",\n                \"content\": \"test comment\",\n            },\n        ],\n        \"%H:%M\",\n    )\n    assert evt.get_event_data(session, event.id) == data\n\n\ndef test_view_comments(\n    event_test_client: TestClient,\n    event: Event,\n    comment: Comment,\n) -> None:\n    path = evt.router.url_path_for(\"view_comments\", event_id=event.id)\n    response = event_test_client.get(path)\n    assert response.ok\n    assert comment.content in response.text\n\n\ndef test_delete_comment(\n    event_test_client: TestClient,\n    session: Session,\n    event: Event,\n    comment: Comment,\n) -> None:\n    assert session.query(Comment).first()\n    path = evt.router.url_path_for(\"delete_comment\")\n    data = {\n        \"event_id\": event.id,\n        \"comment_id\": comment.id,\n    }\n    response = event_test_client.post(path, data=data, allow_redirects=True)\n    assert response.ok\n    assert \"Post Comment\" in response.text\n    assert session.query(Comment).first() is None\n\n\nclass TestApp:\n    client = TestClient(app)\n    date_test_data = [datetime.today() - timedelta(1), datetime.today()]\n    event_test_data = {\n        \"title\": \"Test Title\",\n        \"location\": \"Fake City\",\n        \"vc_link\": \"https://us02web.zoom.us/j/875384596\",\n        \"start\": date_test_data[0],\n        \"end\": date_test_data[1],\n        \"content\": \"Any Words\",\n        \"owner_id\": 123,\n        \"invitees\": \"user1, user2\",\n    }\n\n    @staticmethod\n    def test_get_db():\n        assert isinstance(next(get_db()), Session)\n\n    @staticmethod\n    def test_session_db():\n        assert get_db() is not None\n\n    @staticmethod\n    def check_is_date_before():\n        start = TestApp.date_test_data[0]\n        end = TestApp.date_test_data[1]\n        assert evt.is_date_before(start, end)\n\n    @staticmethod\n    def test_bad_check_validation():\n        assert not evt.is_date_before(TestApp.date_test_data[0], \"bad value\")\n\n    @staticmethod\n    def test_add_event(session: Session):\n        assert evt.add_new_event(TestApp.event_test_data, session) is not None\n\n    @staticmethod\n    def test_add_bad_event(session: Session):\n        bad_event_test_data = TestApp.event_test_data\n        bad_event_test_data[\"no_colume\"] = \"some data\"\n        assert evt.add_new_event(bad_event_test_data, session) is None\n\n    @staticmethod\n    def test_add_bad_times_to_event(session: Session):\n        bad_event_test_data = TestApp.event_test_data\n        bad_event_test_data[\"start\"] = TestApp.date_test_data[1]\n        bad_event_test_data[\"end\"] = TestApp.date_test_data[0]\n        assert evt.add_new_event(bad_event_test_data, session) is None\n"}
{"type": "test_file", "path": "tests/test_event_images.py", "content": "import pytest\n\nfrom app import config\nfrom app.routers.event_images import (attach_image_to_event,\n                                      generate_flare_link_from_lemmatized_word,\n                                      get_image_name,\n                                      remove_non_alphabet_chars,\n                                      search_token_in_related_words)\n\nstatic = config.STATIC_ABS_PATH\n\nlemmatized_words = [\n    (\"ran\", f'{static}\\\\event_flairs\\\\ran.jpg'),\n    (\"food\", f'{static}\\\\event_flairs\\\\food.jpg'),\n    (\"i\", f'{static}\\\\event_flairs\\\\i.jpg'),\n    (\"drank\", f'{static}\\\\event_flairs\\\\drank.jpg'),\n]\n\n\n@pytest.mark.parametrize('lemmatized, link', lemmatized_words)\ndef test_generate_flare_link_from_lemmatized_word(lemmatized, link):\n    assert generate_flare_link_from_lemmatized_word(lemmatized) == link\n\n\ncontents = [\n    (r\"it's my birthday!\", r\"itsmybirthday\"),\n    (r\"iT's   my birthday!!!\", r\"iTsmybirthday\"),\n    (r\"its my birthday\", r\"itsmybirthday\"),\n    (r\"it's-my-birthday!1990\", r\"itsmybirthday\"),\n]\n\n\n@pytest.mark.parametrize('content, alphabet_only', contents)\ndef test_remove_non_alphabet_chars(content, alphabet_only):\n    assert remove_non_alphabet_chars(content) == alphabet_only\n\n\nvalues = [\n    (r\"backrub\", r\"massage\"),\n    (r\"--MedicineS\", r\"pill\"),\n    (r\"restaurants\", r\"food\"),\n    (r\"pikachu\", None),\n    (r\"Pokemon\", r\"pokemon\"),\n]\n\n\n@pytest.mark.parametrize('related_word, key', values)\ndef test_get_image_name(related_word, key):\n    assert get_image_name(related_word) == key\n\n\ntokens = [\n    (r\"backrub\", f'{static}\\\\event_flairs\\\\massage.jpg'),\n    (r\"--MedicineS\", f'{static}\\\\event_flairs\\\\pill.jpg'),\n    (r\"restaurants\", f'{static}\\\\event_flairs\\\\food.jpg'),\n    (r\"pikachu\", None),\n    (r\"Pokemon\", f'{static}\\\\event_flairs\\\\pokemon.jpg'),\n]\n\n\n@pytest.mark.parametrize('token, link', tokens)\ndef test_search_token_in_related_words(token, link):\n    assert search_token_in_related_words(token) == link\n\n\nevent_contents = [\n    (r\"memo backrub and medicines!!\", f'{static}\\\\event_flairs\\\\massage.jpg'),\n    (r\"Dont forget medicines & backrub!\", f'{static}\\\\event_flairs\\\\pill.jpg'),\n    (r\"Its important to drink\", f'{static}\\\\event_flairs\\\\drank.jpg'),\n    (r\"call Jim about tennis friday\", f'{static}\\\\event_flairs\\\\tennis.jpg'),\n    (r\"have to check on pikachu\", r'#'),\n    (r\"-~new pokemon episode 19:00~!\", f'{static}\\\\event_flairs\\\\pokemon.jpg'),\n]\n\n\n@pytest.mark.parametrize('event_content, link', event_contents)\ndef test_attach_image_to_event(event_content, link):\n    assert attach_image_to_event(event_content) == link\n"}
{"type": "test_file", "path": "tests/test_export.py", "content": "from datetime import timedelta\n\nfrom icalendar import vCalAddress\n\nfrom app.config import ICAL_VERSION, PRODUCT_ID\nfrom app.internal import export\nfrom app.internal.agenda_events import filter_dates\nfrom app.routers.user import get_all_user_events\n\n\nclass TestExport:\n\n    @staticmethod\n    def test_export(client, sender, today_event):\n        response = client.get('/export?start_date=&end_date=')\n        assert isinstance(response.content, bytes)\n        assert response.ok\n\n    @staticmethod\n    def test_get_events_no_time_frame(\n            today_event, next_month_event, sender, session):\n        start = None\n        end = None\n        events = get_all_user_events(session, sender.id)\n        filtered_events = filter_dates(events, start, end)\n        assert set(filtered_events) == {today_event, next_month_event}\n\n    @staticmethod\n    def test_get_events_end_time_frame_success(today_event, sender, session):\n        start = None\n        end = today_event.end.date()\n        events = get_all_user_events(session, sender.id)\n        filtered_events = filter_dates(events, start, end)\n        assert list(filtered_events) == [today_event]\n\n    @staticmethod\n    def test_get_events_end_time_frame_failure(\n            today_event, next_month_event, sender, session):\n        start = None\n        end = today_event.start.date() - timedelta(days=1)\n        events = get_all_user_events(session, sender.id)\n        filtered_events = filter_dates(events, start, end)\n        assert list(filtered_events) == []\n\n    @staticmethod\n    def test_get_events_start_time_frame_success(\n            today_event, next_month_event, sender, session):\n        start = next_month_event.start.date()\n        end = None\n        events = get_all_user_events(session, sender.id)\n        filtered_events = filter_dates(events, start, end)\n        assert list(filtered_events) == [next_month_event]\n\n    @staticmethod\n    def test_get_events_start_time_frame_failure(\n            today_event, next_month_event, sender, session):\n        start = next_month_event.start.date() + timedelta(days=1)\n        end = None\n        events = get_all_user_events(session, sender.id)\n        filtered_events = filter_dates(events, start, end)\n        assert list(filtered_events) == []\n\n    @staticmethod\n    def test_get_events_start_and_end_time_frame_success(\n            today_event, next_month_event, sender, session):\n        start = today_event.start.date()\n        end = next_month_event.start.date()\n        events = get_all_user_events(session, sender.id)\n        filtered_events = filter_dates(events, start, end)\n        assert set(filtered_events) == {today_event, next_month_event}\n\n    @staticmethod\n    def test_get_events_start_and_end_time_frame_failure(\n            today_event, next_month_event, sender, session):\n        start = today_event.start.date() + timedelta(days=1)\n        end = next_month_event.start.date() - timedelta(days=1)\n        events = get_all_user_events(session, sender.id)\n        filtered_events = filter_dates(events, start, end)\n        assert list(filtered_events) == []\n\n    class TestExportInternal:\n\n        @staticmethod\n        def test_create_icalendar():\n            icalendar = export._create_icalendar()\n            assert icalendar.get('version') == ICAL_VERSION\n            assert icalendar.get('prodid') == PRODUCT_ID\n\n        @staticmethod\n        def test_create_icalendar_event(event):\n            ievent = export._create_icalendar_event(event)\n            assert event.owner.email in ievent.get('organizer')\n            assert ievent.get('summary') == event.title\n\n        @staticmethod\n        def test_get_v_cal_address(event, user):\n            email = \"test_email\"\n            v_cal_address = export._get_v_cal_address(email)\n            test_v_cal_address = vCalAddress(f'MAILTO:{email}')\n            assert v_cal_address == test_v_cal_address\n\n        @staticmethod\n        def test_get_icalendar(user, event):\n            icalendar = export.get_icalendar(event, [user.email])\n\n            def does_contain(item: str) -> bool:\n                \"\"\"Returns True if calendar contains item.\"\"\"\n                return bytes(item, encoding='utf8') in bytes(icalendar)\n\n            assert does_contain(ICAL_VERSION)\n            assert does_contain(PRODUCT_ID)\n            assert does_contain(event.owner.email)\n            assert does_contain(event.title)\n\n        @staticmethod\n        def test_get_icalendar_with_multiple_events(\n                session, user, event, today_event):\n            icalendar = export.get_icalendar_with_multiple_events(\n                session, [event, today_event])\n\n            assert icalendar\n"}
{"type": "test_file", "path": "tests/test_friendview.py", "content": "from fastapi import status\n\n\nclass TestFriendview:\n    FRIENDVIEW = \"/friendview\"\n    NO_EVENTS = b\"No mutual events found...\"\n\n    @staticmethod\n    def test_friendview_page_no_arguments_when_no_today_events(\n        friendview_test_client,\n        session,\n    ):\n        resp = friendview_test_client.get(TestFriendview.FRIENDVIEW)\n        assert resp.ok\n        assert TestFriendview.NO_EVENTS in resp.content\n\n    @staticmethod\n    def test_no_show_events_user_2(friendview_test_client, today_event):\n        resp = friendview_test_client.get(TestFriendview.FRIENDVIEW)\n        assert resp.status_code == status.HTTP_200_OK\n        assert b\"event 7\" not in resp.content\n"}
{"type": "test_file", "path": "tests/test_google_connect.py", "content": "from datetime import datetime\nimport pytest\nfrom loguru import logger\n\nimport app.internal.google_connect as google_connect\nfrom app.routers.event import create_event\nfrom app.database.models import OAuthCredentials\nfrom app.routers.user import create_user\n\nfrom google.oauth2.credentials import Credentials\nfrom googleapiclient.discovery import build\nfrom googleapiclient.http import HttpMock\n\n\n@pytest.fixture\ndef google_events_mock():\n    return [\n        {\n            \"kind\": \"calendar#event\",\n            \"etag\": \"somecode\",\n            \"id\": \"somecode\",\n            \"status\": \"confirmed\",\n            \"htmlLink\": \"https://www.google.com/calendar/event?eid=somecode\",\n            \"created\": \"2021-01-13T09:10:02.000Z\",\n            \"updated\": \"2021-01-13T09:10:02.388Z\",\n            \"summary\": \"some title\",\n            \"creator\": {\n                \"email\": \"someemail\",\n                \"self\": True\n            },\n            \"organizer\": {\n                \"email\": \"someemail\",\n                \"self\": True\n            },\n            \"start\": {\n                \"dateTime\": \"2021-02-25T13:00:00+02:00\"\n            },\n            \"end\": {\n                \"dateTime\": \"2021-02-25T14:00:00+02:00\"\n            },\n            \"iCalUID\": \"somecode\",\n            \"sequence\": 0,\n            \"reminders\": {\n                \"useDefault\": True\n            }\n        },\n        {\n            \"kind\": \"calendar#event\",\n            \"etag\": \"somecode\",\n            \"id\": \"somecode\",\n            \"status\": \"confirmed\",\n            \"htmlLink\": \"https://www.google.com/calendar/event?eid=somecode\",\n            \"created\": \"2021-01-13T09:10:02.000Z\",\n            \"updated\": \"2021-01-13T09:10:02.388Z\",\n            \"summary\": \"some title to all day event\",\n            \"creator\": {\n                \"email\": \"someemail\",\n                \"self\": True\n            },\n            \"organizer\": {\n                \"email\": \"someemail\",\n                \"self\": True\n            },\n            \"start\": {\n                \"date\": \"2021-02-25\"\n            },\n            \"end\": {\n                \"date\": \"2021-02-25\"\n            },\n            \"iCalUID\": \"somecode\",\n            \"sequence\": 0,\n            \"location\": 'somelocation',\n            \"reminders\": {\n                \"useDefault\": True\n            }\n        }\n    ]\n\n\n@pytest.fixture\ndef credentials():\n    cred = Credentials(\n        token=\"somecode\",\n        refresh_token=\"somecode\",\n        token_uri=\"some_uri\",\n        client_id=\"somecode\",\n        client_secret=\"some_secret\",\n        expiry=datetime(2021, 1, 28)\n    )\n\n    return cred\n\n\n@pytest.mark.usefixtures(\"user\", \"session\", \"google_events_mock\")\ndef test_push_events_to_db(google_events_mock, user, session):\n    assert google_connect.push_events_to_db(google_events_mock, user, session)\n\n\n@pytest.mark.usefixtures(\"user\", \"session\", \"google_events_mock\")\ndef test_db_cleanup(google_events_mock, user, session):\n    for event in google_events_mock:\n        location = None\n        title = event['summary']\n        # support for all day events\n        if 'dateTime' in event['start'].keys():\n            # part time event\n            start = datetime.fromisoformat(event['start']['dateTime'])\n            end = datetime.fromisoformat(event['end']['dateTime'])\n        else:\n            # all day event\n            start = event['start']['date'].split('-')\n            start = datetime(\n                year=int(start[0]),\n                month=int(start[1]),\n                day=int(start[2])\n            )\n\n            end = event['end']['date'].split('-')\n            end = datetime(\n                year=int(end[0]),\n                month=int(end[1]),\n                day=int(end[2])\n            )\n\n        if 'location' in event.keys():\n            location = event['location']\n\n        create_event(\n            db=session,\n            title=title,\n            start=start,\n            end=end,\n            owner_id=user.id,\n            location=location,\n            is_google_event=True\n        )\n\n        assert google_connect.cleanup_user_google_calendar_events(\n            user, session)\n\n\n@pytest.mark.usefixtures(\"session\")\ndef test_get_credentials_from_db(session):\n    user = create_user(session=session,\n                       username='new_test_username',\n                       password='new_test_password',\n                       email='new_test.email@gmail.com',\n                       language_id=1)\n\n    credentials = OAuthCredentials(\n        owner=user,\n        token=\"somecode\",\n        refresh_token=\"somecode\",\n        token_uri=\"some_uri\",\n        client_id=\"somecode\",\n        client_secret=\"some_secret\",\n        expiry=datetime(2021, 2, 22)\n    )\n    session.add(credentials)\n    session.commit()\n    assert user.oauth_credentials is not None\n    session.close()\n    return_val = google_connect.get_credentials_from_db(user)\n    assert return_val\n\n\n@pytest.mark.usefixtures(\"session\", \"user\", \"credentials\")\ndef test_refresh_token(mocker, session, user, credentials):\n\n    mocker.patch(\n        'google.oauth2.credentials.Credentials.refresh',\n        return_value=logger.debug('refreshed')\n    )\n\n    assert google_connect.refresh_token(credentials, user, session)\n\n    mocker.patch(\n        'google.oauth2.credentials.Credentials.expired',\n        return_value=False\n    )\n\n    assert google_connect.refresh_token(credentials, user, session)\n\n\n@pytest.mark.usefixtures(\"session\", \"user\", \"credentials\")\ndef test_get_current_year_events(mocker, user, session, credentials):\n    class mock_events:\n        def __init__(self, service):\n            self.service = service\n\n        def list(self, *args):\n            request = self.service.events().list(calendarId='primary',\n                                                 timeMin=datetime(\n                                                     2021, 1, 1).isoformat(),\n                                                 timeMax=datetime(\n                                                     2022, 1, 1).isoformat(),\n                                                 singleEvents=True,\n                                                 orderBy='startTime'\n                                                 )\n            http = HttpMock(\n                'calendar-linux.json',\n                {'status': '200'}\n            )\n            response = request.execute(http=http)\n            return response\n\n    http = HttpMock(\n        './tests/calendar-discovery.json',\n        {'status': '200'}\n    )\n\n    service = build('calendar', 'v3', http=http)\n\n    mocker.patch(\n        'googleapiclient.discovery.build',\n        return_value=service,\n        events=service\n    )\n    mocker.patch(\n        'googleapiclient.discovery.Resource',\n        events=mock_events(service)\n    )\n\n    assert google_connect.get_current_year_events(credentials, user, session)\n\n\n@pytest.mark.usefixtures(\"user\", \"session\",\n                         \"google_connect_test_client\", \"credentials\")\ndef test_google_sync(mocker, google_connect_test_client, session, credentials):\n    create_user(session=session,\n                username='new_test_username',\n                password='new_test_password',\n                email='new_test.email@gmail.com',\n                language_id=1)\n\n    mocker.patch(\n        'app.routers.google_connect.get_credentials',\n        return_value=credentials\n    )\n    mocker.patch(\n        'app.routers.google_connect.fetch_save_events',\n        return_value=None\n    )\n    connect = google_connect_test_client.get(\n        'google/sync',\n        headers={\n            \"referer\": 'http://testserver/'\n        })\n    assert connect.ok\n\n    # second case\n    mocker.patch(\n        'app.routers.google_connect.get_credentials',\n        return_value=None\n    )\n\n    connect = google_connect_test_client.get(\n        'google/sync',\n        headers={\n            \"referer\": 'http://testserver/'\n        })\n    assert connect.ok\n\n\ndef test_is_client_secret_none():\n    answer = google_connect.is_client_secret_none()\n    assert answer is not None\n\n\n@pytest.mark.usefixtures(\"session\")\ndef test_clean_up_old_credentials_from_db(session):\n    google_connect.clean_up_old_credentials_from_db(session)\n    assert len(session.query(OAuthCredentials)\n               .filter_by(user_id=None).all()) == 0\n\n\n@pytest.mark.usefixtures(\"session\", 'user', 'credentials')\ndef test_get_credentials_from_consent_screen(mocker, session,\n                                             user, credentials):\n    mocker.patch(\n        'google_auth_oauthlib.flow.InstalledAppFlow.from_client_secrets_file',\n        return_value=mocker.Mock(name='flow', **{\n            \"credentials\": credentials,\n            \"run_local_server\": mocker.Mock(name='run_local_server',\n                                            return_value=logger.debug(\n                                                'running server'))\n        })\n    )\n\n    mocker.patch(\n        'app.internal.google_connect.is_client_secret_none',\n        return_value=False\n    )\n\n    assert google_connect.get_credentials_from_consent_screen(\n                                                user, session) == credentials\n\n\n@pytest.mark.usefixtures(\"session\")\ndef test_create_google_event(session):\n    user = create_user(session=session,\n                       username='new_test_username',\n                       password='new_test_password',\n                       email='new_test.email@gmail.com',\n                       language_id=1)\n\n    event = google_connect.create_google_event(\n            'title',\n            datetime(2021, 1, 1, 15, 15),\n            datetime(2021, 1, 1, 15, 30),\n            user,\n            'location',\n            session\n            )\n\n    assert event.title == 'title'\n\n\n@pytest.mark.usefixtures(\"session\", \"user\", 'credentials')\ndef test_get_credentials(mocker, session, user, credentials):\n    user = create_user(\n        session=session,\n        username='new_test_username',\n        password='new_test_password',\n        email='new_test.email@gmail.com',\n        language_id=1\n    )\n\n    mocker.patch(\n        'app.internal.google_connect.get_credentials_from_consent_screen',\n        return_value=credentials\n    )\n\n    assert google_connect.get_credentials(user=user,\n                                          session=session) == credentials\n\n    mocker.patch(\n        'app.internal.google_connect.get_credentials',\n        return_value=credentials\n    )\n    mocker.patch(\n        'app.internal.google_connect.refresh_token',\n        return_value=credentials\n    )\n\n    assert google_connect.get_credentials(user=user,\n                                          session=session) == credentials\n\n\n@pytest.mark.usefixtures(\"session\", \"user\",\n                         'credentials', 'google_events_mock')\ndef test_fetch_save_events(mocker, session, user, credentials,\n                           google_events_mock):\n\n    mocker.patch(\n        'app.internal.google_connect.get_current_year_events',\n        return_value=google_events_mock\n    )\n\n    assert google_connect.fetch_save_events(credentials,\n                                            user, session) is None\n\n\n@pytest.mark.usefixtures(\"session\", \"user\", 'credentials')\ndef test_push_credentials_to_db(session, user, credentials):\n    assert google_connect.push_credentials_to_db(credentials, user, session)\n"}
{"type": "test_file", "path": "tests/test_holidays.py", "content": "import os\nfrom app.database.models import Event, User\nfrom app.routers import profile\nfrom sqlalchemy.orm import Session\n\n\nclass TestHolidaysImport:\n    HOLIDAYS = '/profile/holidays/import'\n\n    @staticmethod\n    def test_import_holidays_page_exists(client):\n        resp = client.get(TestHolidaysImport.HOLIDAYS)\n        assert resp.ok\n        assert b'Import holidays using ics file' in resp.content\n\n    def test_get_holidays(self, session: Session, user: User):\n        current_folder = os.path.dirname(os.path.realpath(__file__))\n        resource_folder = os.path.join(current_folder, 'resources')\n        test_file = os.path.join(resource_folder, 'ics_example.txt')\n        with open(test_file) as file:\n            ics_content = file.read()\n            holidays = profile.get_holidays_from_file(ics_content, session)\n            profile.save_holidays_to_db(holidays, session)\n        assert len(session.query(Event).all()) == 4\n\n    def test_wrong_file_get_holidays(self, session: Session, user: User):\n        current_folder = os.path.dirname(os.path.realpath(__file__))\n        resource_folder = os.path.join(current_folder, 'resources')\n        test_file = os.path.join(resource_folder, 'wrong_ics_example.txt')\n        with open(test_file) as file:\n            ics_content = file.read()\n            holidays = profile.get_holidays_from_file(ics_content, session)\n            profile.save_holidays_to_db(holidays, session)\n        assert len(session.query(Event).all()) == 0\n"}
{"type": "test_file", "path": "tests/test_home.py", "content": "class TestHome:\n    URL = \"/\"\n\n    @staticmethod\n    def test_get_page(client):\n        response = client.get(TestHome.URL)\n        assert response.ok\n"}
{"type": "test_file", "path": "tests/test_import_file.py", "content": "from datetime import datetime\n\nimport pytest\n\nfrom app.internal import import_file\n\nFILE_TXT_SAMPLE = r\"tests/files_for_import_file_tests/sample_calendar_data.txt\"\nFILE_TXT_INVALID = r\"tests/files_for_import_file_tests/sample_data_invalid.txt\"\nFILE_RNG_INVALID = r\"tests/files_for_import_file_tests/sample_rng_invalid.txt\"\nFILE_CSV_SAMPLE = r\"tests/files_for_import_file_tests/sample_calendar_data.csv\"\nFILE_TXT_ABOVE_5MB = r\"tests/files_for_import_file_tests/sample_above_5mb.txt\"\nFILE_TXT_BELOW_1MB = r\"tests/files_for_import_file_tests/sample_below_1mb.txt\"\nFILE_CSV_BELOW_1MB = r\"tests/files_for_import_file_tests/sample_below_1mb.csv\"\nFILE_NOT_EXIST = r\"tests/files_for_import_file_tests/not_exist.txt\"\nFILE_ICS = r\"tests/files_for_import_file_tests/sample.ics\"\nFILE_ICS_INVALID_DATA = r\"tests/files_for_import_file_tests/sample2.ics\"\nFILE_ICS_INVALID_DATA2 = r\"tests/files_for_import_file_tests/sample3.ics\"\nNOT_EXIST_BLABLA_EXTENSION = r\"tests/files_for_import_file_tests/sample.blabla\"\nFILE_BLABLA_EXTENSION = r\"tests/files_for_import_file_tests/sample2.blabla\"\nFILE_TXT_DATE_VER = r\"tests/files_for_import_file_tests/sample_date2_ver.txt\"\nFILE_TXT_LOCATION = r\"tests/files_for_import_file_tests/‏‏sample_loc_ver.txt\"\nFILE_TXT_MIX_DATE = r\"tests/files_for_import_file_tests/‏‏sample_date_mix.txt\"\n\nIMPORT_TXT_FILE_RESULT_DATA = [\n    {\n        'Head': 'Head1',\n        'Content': 'Content1',\n        'S_Date': datetime(2019, 5, 21),\n        'E_Date': datetime(2019, 5, 21),\n        'Location': \"\",\n    },\n    {\n        'Head': 'Head2',\n        'Content': 'Content2',\n        'S_Date': datetime(2010, 1, 11),\n        'E_Date': datetime(2010, 1, 11),\n        'Location': \"\",\n    },\n    {\n        'Head': 'Head3',\n        'Content': 'Content3',\n        'S_Date': datetime(2022, 2, 2),\n        'E_Date': datetime(2022, 2, 2),\n        'Location': \"\",\n    },\n]\n\nFILE_SIZE_TESTS = [\n    # File size above the constraint we set in the global variable (5 MB)\n    (FILE_TXT_ABOVE_5MB, None, False),\n    # File size below the constraint we set in the global variable (5 MB)\n    (FILE_TXT_BELOW_1MB, None, True),\n    # File size below the constraint we set to the function\n    (FILE_TXT_ABOVE_5MB, 10, True),\n    # File size above the constraint we set to the function\n    (FILE_TXT_ABOVE_5MB, 2, False),\n]\n\nFILE_EXISTS_TESTS = [\n    # File exist\n    (FILE_TXT_BELOW_1MB, True),\n    # File not exist\n    (FILE_NOT_EXIST, False),\n]\n\nSTRING_TO_DATE_TESTS = [\n    (\"02-28-2022 13:05\", datetime(2022, 2, 28, 13, 5)),\n    (\"02-28-2022\", datetime(2022, 2, 28)),\n    (\"01-32-2022 20:30\", None),  # Invalid Date\n]\n\nSTART_DAY_END_DAY_TESTS = [\n    (datetime(1991, 12, 1, 10), datetime(1991, 12, 1, 11), True),\n    (datetime(1991, 12, 1, 11), datetime(1991, 12, 1, 10), False),\n]\n\nVALID_DATES_TESTS = [\n    (\"02-26-2022\", \"02-27-2022\", True),\n    (\"02-27-2022\", \"02-26-2022\", False),\n    (\"not a date\", \"02-28-2022\", False),\n]\n\nFILE_EXTENSION_TESTS = [\n    (FILE_TXT_BELOW_1MB, None, True),\n    (FILE_CSV_BELOW_1MB, None, True),\n    (FILE_ICS, None, True),\n    (NOT_EXIST_BLABLA_EXTENSION, \".blabla\", True),\n    (NOT_EXIST_BLABLA_EXTENSION, None, False),\n    (r\"tests/files_for_import_file_tests/sample.csv.blabla\", None, False),\n]\n\nDATE_IN_RANGE_TESTS = [\n    (datetime(2022, 1, 31), None, True),\n    (datetime(2022, 1, 31, 10, 30), None, True),\n    (datetime(2011, 1, 20), None, True),\n    # date above the constraint we set (20 years after today date)\n    (datetime(2050, 1, 1), None, False),\n    # date below the constraint we set (20 years before today date)\n    (datetime(2000, 1, 1), None, False),\n    # date in the range we set in the function\n    (datetime(2019, 1, 1), 5, True),\n    # date below the range we set in the function\n    (datetime(2018, 1, 1), 2, False),\n]\n\nEVENT_DURATION_TESTS = [\n    (datetime(1991, 12, 1), datetime(1991, 12, 2), None, True),\n    (datetime(1991, 12, 1, 10, 30), datetime(1991, 12, 3, 10, 29), None, True),\n    (\n        datetime(1991, 12, 1, 10, 30), datetime(1991, 12, 3, 10, 30), None,\n        False,\n    ),\n    (datetime(1991, 12, 1, 10, 30), datetime(1991, 12, 5, 10, 30), 5, True),\n]\n\nTEXT_VALID_TESTS = [\n    (r\"Head1, Content1, 05-21-2019, 05-21-2019\", True),\n    (r\"Head1, Content1, 05-21-2019 10:30, 05-21-2019 11:30\", True),\n    (r\"Head1, Content1, 05-21-2019 10:30, 05-21-2019 11:30, Tel-Aviv\", True),\n    (r\"Head1Content1, 05-21-2019, 05-21-2019\", False),\n    # title can't be empty\n    (r\"  , Content1, 05-21-2019, 05-21-2019\", False),\n    # content may be empty\n    (r\"Head1, , 05-21-2019, 05-21-2019\", True),\n    # start_date can't be empty\n    (r\"Head1, Content1, , 05-21-2019\", False),\n    # end_date can't be empty\n    (r\"Head1, Content1, 05-21-2019, \", False),\n    # row cant have multiple events\n    (r\"\"\"Head1, Content1, 05-21-2019, 05-21-2019,\n     Head2, Content2, 05-21-2019, 05-21-2019\"\"\", False),\n    # dates cant be from a different formats\n    (r\"Head1, Content1, 05-21-2019 10:30, 06-21-2019, Tel-Aviv\", False),\n    # location may be empty\n    (r\"Head1, Content1, 05-21-2019 10:30, 06-21-2019 11:30, \", True),\n    # location may have space and dash\n    (r\"Head1, Content1, 05-21-2019, 06-21-2019, New York-1\", True),\n]\n\nIMPORT_TXT_FILE_TESTS = [\n    # txt file\n    (FILE_TXT_SAMPLE, IMPORT_TXT_FILE_RESULT_DATA),\n    # csv file\n    (FILE_CSV_SAMPLE, IMPORT_TXT_FILE_RESULT_DATA),\n    # Invalid text structure\n    (FILE_TXT_INVALID, []),\n    # Invalid date range\n    (FILE_RNG_INVALID, []),\n]\n\nIMPORT_ICS_FILE_TESTS = [\n    # ics file\n    (FILE_ICS,\n     [\n         {\n             'Head': 'HeadA',\n             'Content': 'Content1',\n             'S_Date': datetime(2019, 8, 2, 10, 34),\n             'E_Date': datetime(2019, 8, 2, 11, 4),\n             'Location': 'Tel-Aviv',\n         },\n         {\n             'Head': 'HeadB',\n             'Content': 'Content2',\n             'S_Date': datetime(2019, 8, 2, 20),\n             'E_Date': datetime(2019, 8, 2, 20, 30),\n             'Location': 'Tel-Aviv',\n         }\n     ]),\n    # ics invalid file\n    (FILE_ICS_INVALID_DATA, []),\n    # ics invalid file\n    (FILE_ICS_INVALID_DATA2, []),\n]\n\nFILE_VALID_TO_SAVE_TESTS = [\n    (FILE_TXT_SAMPLE, True),\n    (FILE_TXT_DATE_VER, True),\n    (FILE_TXT_LOCATION, True),\n    (FILE_TXT_ABOVE_5MB, False),\n    (NOT_EXIST_BLABLA_EXTENSION, False),\n    (FILE_BLABLA_EXTENSION, False),\n]\n\nIMPORT_EVENTS_TESTS = [\n    (FILE_TXT_SAMPLE, 1, True),\n    (FILE_TXT_DATE_VER, 1, True),\n    (FILE_TXT_LOCATION, 1, True),\n    (FILE_ICS, 1, True),\n    (FILE_TXT_ABOVE_5MB, 1, False),\n    (NOT_EXIST_BLABLA_EXTENSION, 1, False),\n    (FILE_TXT_BELOW_1MB, 1, False),\n    (FILE_TXT_MIX_DATE, 1, False),\n]\n\n\n@pytest.mark.parametrize(\"test_file, max_size, expected\", FILE_SIZE_TESTS)\ndef test_is_file_size_valid(test_file, max_size, expected):\n    if max_size is None:\n        assert import_file._is_file_size_valid(test_file) == expected\n    else:\n        assert import_file._is_file_size_valid(test_file, max_size) == expected\n\n\n@pytest.mark.parametrize(\"test_file, expected\", FILE_EXISTS_TESTS)\ndef test_is_file_exists(test_file, expected):\n    assert import_file._is_file_exists(test_file) == expected\n\n\n@pytest.mark.parametrize(\"date, expected\", STRING_TO_DATE_TESTS)\ndef test_convert_string_to_date(date, expected):\n    assert import_file._convert_string_to_date(date) == expected\n\n\n@pytest.mark.parametrize(\"start, end, expected\", START_DAY_END_DAY_TESTS)\ndef test_is_start_day_before_end_date(start, end, expected):\n    assert import_file._is_start_date_before_end_date(start, end) == expected\n\n\n@pytest.mark.parametrize(\"start, end, is_valid\", VALID_DATES_TESTS)\ndef test_is_event_dates_valid(start, end, is_valid):\n    assert import_file._is_event_dates_valid(start, end) == is_valid\n\n\n@pytest.mark.parametrize(\"test_file, extension, expected\",\n                         FILE_EXTENSION_TESTS)\ndef test_is_file_extension_valid(test_file, extension, expected):\n    if extension is None:\n        assert import_file._is_file_extension_valid(test_file) == expected\n    else:\n        assert import_file._is_file_extension_valid(test_file,\n                                                    extension) == expected\n\n\n@pytest.mark.parametrize(\"date, valid_dates, expected\", DATE_IN_RANGE_TESTS)\ndef test_is_date_in_range(date, valid_dates, expected):\n    if valid_dates is None:\n        assert import_file._is_date_in_range(date) == expected\n    else:\n        assert import_file._is_date_in_range(date, valid_dates) == expected\n\n\n@pytest.mark.parametrize(\"text, expected\", TEXT_VALID_TESTS)\ndef test_is_event_text_valid(text, expected):\n    assert import_file._is_event_text_valid(text) == expected\n\n\n@pytest.mark.parametrize(\"test_file, expected\", IMPORT_TXT_FILE_TESTS)\ndef test_get_data_from_txt_file(test_file, expected):\n    assert import_file._get_data_from_txt_file(test_file) == expected\n\n\n@pytest.mark.parametrize(\"test_file, expected\", IMPORT_ICS_FILE_TESTS)\ndef test_get_data_from_ics_file(test_file, expected):\n    assert import_file._get_data_from_ics_file(test_file) == expected\n\n\n@pytest.mark.parametrize(\n    \"start, end, max_duration, expected\", EVENT_DURATION_TESTS)\ndef test_is_event_valid_duration(start, end, max_duration, expected):\n    if max_duration is None:\n        assert import_file._is_event_duration_valid(start, end) == expected\n    else:\n        result = import_file._is_event_duration_valid(start, end, max_duration)\n        assert result == expected\n\n\n@pytest.mark.parametrize(\"test_file, expected\", FILE_VALID_TO_SAVE_TESTS)\ndef test_is_file_valid_to_import(test_file, expected):\n    assert import_file._is_file_valid_to_import(test_file) == expected\n\n\n@pytest.mark.parametrize(\"test_file, user_id, expected\", IMPORT_EVENTS_TESTS)\ndef test_import_events(test_file, user_id, expected, session):\n    assert import_file.import_events(test_file, user_id, session) == expected\n"}
{"type": "test_file", "path": "tests/test_invitation.py", "content": "from fastapi import status\n\nfrom app.routers.invitation import get_all_invitations, get_invitation_by_id\n\n\nclass TestInvitations:\n    NO_INVITATIONS = b\"You don't have any invitations.\"\n    URL = \"/invitations/\"\n\n    @staticmethod\n    def test_view_no_invitations(invitation_test_client):\n        response = invitation_test_client.get(TestInvitations.URL)\n        assert response.ok\n        assert TestInvitations.NO_INVITATIONS in response.content\n\n    @staticmethod\n    def test_accept_invitations(user, invitation, invitation_test_client):\n        invitation = {\"invite_id \": invitation.id}\n        resp = invitation_test_client.post(\n            TestInvitations.URL, data=invitation)\n        assert resp.status_code == status.HTTP_302_FOUND\n\n    @staticmethod\n    def test_get_all_invitations_success(invitation, event, user, session):\n        invitations = get_all_invitations(event=event, db=session)\n        assert invitations == [invitation]\n        invitations = get_all_invitations(recipient=user, db=session)\n        assert invitations == [invitation]\n\n    @staticmethod\n    def test_get_all_invitations_failure(user, session):\n        invitations = get_all_invitations(unknown_parameter=user, db=session)\n        assert invitations == []\n\n        invitations = get_all_invitations(recipient=None, db=session)\n        assert invitations == []\n\n    @staticmethod\n    def test_get_invitation_by_id(invitation, session):\n        get_invitation = get_invitation_by_id(invitation.id, db=session)\n        assert get_invitation == invitation\n\n    @staticmethod\n    def test_repr(invitation):\n        invitation_repr = (\n            f'<Invitation '\n            f'({invitation.event.owner}'\n            f'to {invitation.recipient})>'\n        )\n        assert invitation.__repr__() == invitation_repr\n"}
{"type": "test_file", "path": "tests/test_json_data_loader.py", "content": "from app.database.models import Quote, Zodiac\nfrom app.internal import json_data_loader\n\n\ndef get_objects_amount(session, table):\n    return session.query(table).count()\n\n\ndef test_load_daily_quotes(session):\n    json_data_loader.load_to_database(session)\n    assert get_objects_amount(session, Quote) > 0\n\n\ndef test_load_zodiacs(session):\n    json_data_loader.load_to_database(session)\n    assert get_objects_amount(session, Zodiac) > 0\n\n\n# tests for basic functionality of the json data loader\ndef test_load_data_with_json_value_error(mocker, session):\n    mocker.patch('json.load', side_effect=ValueError)\n    json_data_loader.load_to_database(session)\n    assert get_objects_amount(session, Quote) == 0\n\n\ndef test_data_not_load_twice_to_db(session):\n    json_data_loader.load_to_database(session)\n    first_quotes_amount = get_objects_amount(session, Quote)\n    json_data_loader.load_to_database(session)\n    assert first_quotes_amount == get_objects_amount(session, Quote)\n"}
{"type": "test_file", "path": "tests/test_language.py", "content": "from pathlib import Path\n\nimport pytest\n\nfrom app.dependencies import templates\nfrom app.internal import languages\n\n\nclass TestLanguage:\n    # Empty, invalid, or valid, but unsupported language codes,\n    # (currently 'en' and 'he') are set to the default language setting\n    # at config.WEBSITE_LANGUAGE, which is currently set to 'en' (English).\n    LANGUAGE_TESTS = [\n        ('en', 'test python translation', True),\n        ('he', 'בדיקת תרגום בפייתון', True),\n        (None, 'test python translation', False),\n        ('', 'test python translation', False),\n        ('de', 'test python translation', False),\n        ([\"en\"], 'test python translation', False),\n        (3, 'test python translation', False),\n    ]\n\n    NUMBER_OF_LANGUAGES = 2\n\n    @staticmethod\n    @pytest.mark.parametrize(\n        \"language_code, translation, is_valid\", LANGUAGE_TESTS)\n    def test_gettext_python(language_code, translation, is_valid):\n        languages.set_ui_language(language_code)\n\n        # i18n: String used in testing. Do not change.\n        gettext_translation = _(\"test python translation\")\n        assert ((is_valid and gettext_translation == translation)\n                or (not is_valid and gettext_translation == translation))\n\n    @staticmethod\n    @pytest.mark.parametrize(\n        \"language_code, translation, is_valid\", LANGUAGE_TESTS)\n    def test_gettext_html(language_code, translation, is_valid):\n        languages.set_ui_language(language_code)\n\n        template = templates.env.from_string(\n            '{{ gettext(\"test python translation\") }}')\n        text = template.render()\n        assert ((is_valid and translation in text)\n                or (not is_valid and translation in text))\n\n    @staticmethod\n    def test_get_supported_languages():\n        number_of_languages = len(list(languages._get_supported_languages()))\n        assert number_of_languages == TestLanguage.NUMBER_OF_LANGUAGES\n\n    @staticmethod\n    def test_get_language_directory():\n        pytest.MonkeyPatch().setattr(Path, 'is_dir', lambda x: True)\n        assert languages._get_language_directory()\n\n    @staticmethod\n    def test_get_display_language():\n        # TODO: Waiting for user registration.\n        #  Test: no user, user not logged in and user with non-english set.\n        pass\n"}
{"type": "test_file", "path": "tests/test_logger.py", "content": "import logging\n\nimport pytest\n\nfrom app import config\nfrom app.internal.logger_customizer import LoggerConfigError, LoggerCustomizer\n\n\nclass TestLogger:\n    @staticmethod\n    def test_log_debug(caplog, logger_instance):\n        with caplog.at_level(logging.DEBUG):\n            logger_instance.debug('Is it debugging now?')\n            assert 'Is it debugging now?' in caplog.text\n\n    @staticmethod\n    def test_log_info(caplog, logger_instance):\n        with caplog.at_level(logging.INFO):\n            logger_instance.info('App started')\n            assert 'App started' in caplog.text\n\n    @staticmethod\n    def test_log_error(caplog, logger_instance):\n        with caplog.at_level(logging.ERROR):\n            logger_instance.error('Something bad happened!')\n            assert 'Something bad happened!' in caplog.text\n\n    @staticmethod\n    def test_log_critical(caplog, logger_instance):\n        with caplog.at_level(logging.CRITICAL):\n            logger_instance.critical(\"WE'RE DOOMED!\")\n            assert \"WE'RE DOOMED!\" in caplog.text\n\n    @staticmethod\n    def test_bad_configuration():\n        with pytest.raises(LoggerConfigError):\n            LoggerCustomizer.make_logger(config.LOG_PATH,\n                                         config.LOG_FILENAME,\n                                         'eror',\n                                         config.LOG_ROTATION_INTERVAL,\n                                         config.LOG_RETENTION_INTERVAL,\n                                         config.LOG_FORMAT)\n"}
{"type": "test_file", "path": "tests/test_login.py", "content": "import pytest\n\nfrom starlette.status import HTTP_302_FOUND\n\nfrom app.database.models import User\nfrom app.internal.security.ouath2 import create_jwt_token\nfrom app.internal.security.schema import LoginUser\n\n\ndef test_login_route_ok(security_test_client):\n    response = security_test_client.get(\"/login\")\n    assert response.ok\n\n\nREGISTER_DETAIL = {\n    'username': 'correct_user', 'full_name': 'full_name',\n    'password': 'correct_password', 'confirm_password': 'correct_password',\n    'email': 'example@email.com', 'description': \"\"}\n\nLOGIN_WRONG_DETAILS = [\n    ('wrong_user', 'wrong_password', b'Please check your credentials'),\n    ('correct_user', 'wrong_password', b'Please check your credentials'),\n    ('wrong_user', 'correct_password', b'Please check your credentials'),\n    ('', 'correct_password', b'Please check your credentials'),\n    ('correct_user', '', b'Please check your credentials'),\n    ('', '', b'Please check your credentials'),\n    ]\n\nLOGIN_DATA = {'username': 'correct_user', 'password': 'correct_password'}\nWRONG_LOGIN_DATA = {\n    'username': 'incorrect_user', 'password': 'correct_password'}\n\n\n@pytest.mark.parametrize(\n    \"username, password, expected_response\", LOGIN_WRONG_DETAILS)\ndef test_login_fails(\n        session, security_test_client, username, password, expected_response):\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    data = {'username': username, 'password': password}\n    data = security_test_client.post(\n        security_test_client.app.url_path_for('login'),\n        data=data).content\n    assert expected_response in data\n\n\ndef test_login_successfull(session, security_test_client):\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    res = security_test_client.post(\n        security_test_client.app.url_path_for('login'),\n        data=LOGIN_DATA)\n    assert res.status_code == HTTP_302_FOUND\n\n\ndef test_is_logged_in_dependency_with_logged_in_user(\n        session, security_test_client):\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    security_test_client.post(\n        security_test_client.app.url_path_for('login'),\n        data=LOGIN_DATA)\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('is_logged_in'))\n    assert res.json() == {\"user\": True}\n\n\ndef test_is_logged_in_dependency_without_logged_in_user(\n        session, security_test_client):\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('logout'))\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('is_logged_in'))\n    assert b'Please log in' in res.content\n\n\ndef test_is_manager_in_dependency_with_logged_in_regular_user(\n        session, security_test_client):\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    security_test_client.post(\n        security_test_client.app.url_path_for('login'),\n        data=LOGIN_DATA)\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('is_manager'))\n    assert b\"have a permition\" in res.content\n\n\ndef test_is_manager_in_dependency_with_logged_in_manager(\n        session, security_test_client):\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    manager = session.query(User).filter(\n        User.username == 'correct_user').first()\n    manager.is_manager = True\n    session.commit()\n    security_test_client.post(\n        security_test_client.app.url_path_for('login'), data=LOGIN_DATA)\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('is_manager'))\n    assert res.json() == {\"manager\": True}\n\n\ndef test_logout(session, security_test_client):\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('logout'))\n    assert b'Login' in res.content\n\n\ndef test_incorrect_secret_key_in_token(session, security_test_client):\n    user = LoginUser(**LOGIN_DATA)\n    incorrect_token = create_jwt_token(user, jwt_key=\"wrong secret key\")\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    params = f\"?existing_jwt={incorrect_token}\"\n    security_test_client.post(\n        security_test_client.app.url_path_for('login') + f'{params}',\n        data=LOGIN_DATA)\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('is_logged_in'))\n    assert b'Your token is incorrect' in res.content\n\n\ndef test_expired_token(session, security_test_client):\n    security_test_client.get(\n        security_test_client.app.url_path_for('logout'))\n    user = LoginUser(**LOGIN_DATA)\n    incorrect_token = create_jwt_token(user, jwt_min_exp=-1)\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    params = f\"?existing_jwt={incorrect_token}\"\n    security_test_client.post(\n        security_test_client.app.url_path_for('login') + f'{params}',\n        data=LOGIN_DATA)\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('is_logged_in'))\n    assert b'expired' in res.content\n\n\ndef test_corrupted_token(session, security_test_client):\n    user = LoginUser(**LOGIN_DATA)\n    incorrect_token = create_jwt_token(user) + \"s\"\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    params = f\"?existing_jwt={incorrect_token}\"\n    security_test_client.post(\n        security_test_client.app.url_path_for('login') + f'{params}',\n        data=LOGIN_DATA)\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('is_logged_in'))\n    assert b'Your token is incorrect' in res.content\n\n\ndef test_current_user_from_db_dependency_ok(session, security_test_client):\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    security_test_client.post(\n        security_test_client.app.url_path_for('login'), data=LOGIN_DATA)\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('current_user_from_db'))\n    assert res.json() == {\"user\": 'correct_user'}\n\n\ndef test_current_user_from_db_dependency_not_logged_in(\n        session, security_test_client):\n    security_test_client.get(\n        security_test_client.app.url_path_for('logout'))\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('current_user_from_db'))\n    assert b'Please log in' in res.content\n\n\ndef test_current_user_from_db_dependency_wrong_details(\n        session, security_test_client):\n    security_test_client.get(\n        security_test_client.app.url_path_for('logout'))\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    user = LoginUser(**WRONG_LOGIN_DATA)\n    incorrect_token = create_jwt_token(user)\n    params = f\"?existing_jwt={incorrect_token}\"\n    security_test_client.post(\n        security_test_client.app.url_path_for('login') + f'{params}',\n        data=LOGIN_DATA)\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('current_user_from_db'))\n    assert b'Your token is incorrect' in res.content\n\n\ndef test_current_user_dependency_ok(session, security_test_client):\n    security_test_client.post(\n        security_test_client.app.url_path_for('register'),\n        data=REGISTER_DETAIL)\n    security_test_client.post(\n        security_test_client.app.url_path_for('login'), data=LOGIN_DATA)\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('current_user'))\n    assert res.json() == {\"user\": 'correct_user'}\n\n\ndef test_current_user_dependency_not_logged_in(\n        session, security_test_client):\n    security_test_client.get(\n        security_test_client.app.url_path_for('logout'))\n    res = security_test_client.get(\n        security_test_client.app.url_path_for('current_user'))\n    assert b'Please log in' in res.content\n"}
{"type": "test_file", "path": "tests/test_on_this_day_events.py", "content": "from app.database.models import WikipediaEvents\nfrom app.internal.on_this_day_events import (get_on_this_day_events,\n                                             insert_on_this_day_data)\n\n\ndef test_insert_on_this_day_data(session):\n    is_exists_data = session.query(WikipediaEvents).all()\n    assert not is_exists_data\n    insert_on_this_day_data(session)\n    is_exists_data = session.query(WikipediaEvents).all()\n    assert is_exists_data is not None\n\n\ndef test_get_on_this_day_events(session):\n    data = get_on_this_day_events(session)\n    assert isinstance(data, dict)\n    assert isinstance(data.get('events'), list)\n    assert isinstance(data.get('wikipedia'), str)\n\n\ndef test_get_on_this_day_events_exists(session):\n    fake_object = WikipediaEvents(\n        events=['fake'], wikipedia=\"www.fake.com\", date_=\"not a date string\")\n    session.add(fake_object)\n    session.commit()\n    fake_data = get_on_this_day_events(session)\n    assert fake_data.events[0] == 'fake'\n    assert fake_data.wikipedia == 'www.fake.com'\n    assert fake_data.date_ == 'not a date string'\n"}
{"type": "test_file", "path": "tests/test_profile.py", "content": "import os\n\nfrom fastapi import status\nfrom PIL import Image\nimport pytest\n\nfrom app import config\nfrom app.dependencies import MEDIA_PATH\nfrom app.routers.profile import get_image_crop_area, get_placeholder_user\n\nCROP_RESULTS = [\n    (20, 10, (5, 0, 15, 10)),\n    (10, 20, (0, 5, 10, 15)),\n    (10, 10, (0, 0, 10, 10))\n]\n\n\ndef test_get_placeholder_user():\n    user = get_placeholder_user()\n    assert user.username == 'new_user'\n    assert user.email == 'my@email.po'\n    assert user.password == '1a2s3d4f5g6'\n    assert user.full_name == 'My Name'\n\n\n@pytest.mark.parametrize('width, height, result', CROP_RESULTS)\ndef test_get_image_crop_area(width, height, result):\n    assert get_image_crop_area(width, height) == result\n\n\ndef test_profile_page(profile_test_client):\n    profile = profile_test_client.get('/profile')\n    data = profile.content\n    assert profile.ok\n    assert b'profile.png' in data\n    assert b'FakeName' in data\n    assert b'Happy new user!' in data\n    assert b'On This Day' in data\n\n\ndef test_update_user_fullname(profile_test_client):\n    new_name_data = {\n        'fullname': 'Peter'\n    }\n    # Get profile page and initialize database\n    profile = profile_test_client.get('/profile')\n\n    # Post new data\n    profile = profile_test_client.post(\n        '/profile/update_user_fullname', data=new_name_data)\n    assert profile.status_code == status.HTTP_302_FOUND\n\n    # Get updated data\n    data = profile_test_client.get('/profile').content\n    assert b'Peter' in data\n\n\ndef test_update_user_email(profile_test_client):\n    new_email = {\n        'email': 'very@new.email'\n    }\n    # Get profile page and initialize database\n    profile = profile_test_client.get('/profile')\n\n    # Post new data\n    profile = profile_test_client.post(\n        '/profile/update_user_email', data=new_email)\n    assert profile.status_code == status.HTTP_302_FOUND\n\n    # Get updated data\n    data = profile_test_client.get('/profile').content\n    assert b'very@new.email' in data\n\n\ndef test_update_user_description(profile_test_client):\n    new_description = {\n        'description': \"FastAPI Developer\"\n    }\n    # Get profile page and initialize database\n    profile = profile_test_client.get('/profile')\n\n    # Post new data\n    profile = profile_test_client.post(\n        '/profile/update_user_description', data=new_description)\n    assert profile.status_code == status.HTTP_302_FOUND\n\n    # Get updated data\n    data = profile_test_client.get('/profile').content\n    assert b\"FastAPI Developer\" in data\n\n\ndef test_update_telegram_id(profile_test_client):\n    new_telegram_id = {\n        'telegram_id': \"12345\"\n    }\n    # Get profile page and initialize database\n    profile = profile_test_client.get('/profile')\n\n    # Post new data\n    profile = profile_test_client.post(\n        '/profile/update_telegram_id', data=new_telegram_id)\n    assert profile.status_code == status.HTTP_302_FOUND\n\n    # Get updated data\n    data = profile_test_client.get('/profile').content\n    assert b\"12345\" in data\n\n\ndef test_upload_user_photo(profile_test_client):\n    example_new_photo = f\"{MEDIA_PATH}/example.png\"\n\n    # Get profile page and initialize database\n    profile = profile_test_client.get('/profile')\n\n    # Post new data\n    profile = profile_test_client.post(\n        '/profile/upload_user_photo',\n        files={'file': (\n            \"filename\", open(example_new_photo, \"rb\"), \"image/png\")})\n    assert profile.status_code == status.HTTP_302_FOUND\n\n    # Validate new picture saved in media directory\n    assert 'fake_user.png' in os.listdir(MEDIA_PATH)\n\n    # Validate new picture size\n    new_avatar_path = os.path.join(MEDIA_PATH, 'fake_user.png')\n    assert Image.open(new_avatar_path).size == config.AVATAR_SIZE\n    os.remove(new_avatar_path)\n\n\ndef test_update_calendar_privacy(profile_test_client):\n    new_privacy = {\n        'privacy': \"Public\"\n    }\n    # Get profile page and initialize database\n    profile = profile_test_client.get('/profile')\n\n    # Post new data\n    profile = profile_test_client.post(\n        '/profile/privacy', data=new_privacy)\n    assert profile.status_code == status.HTTP_302_FOUND\n\n    # Get updated data\n    data = profile_test_client.get('/profile').content\n    assert b\"Public\" in data\n"}
{"type": "test_file", "path": "tests/test_psql_environment.py", "content": "import pytest\n\nfrom app.database import create_env_engine\nfrom app.database.models import PSQLEnvironmentError\nfrom app.main import create_tables\n\n\ndef test_main_create_tables_error(sqlite_engine):\n    raised_error = False\n    with pytest.raises(PSQLEnvironmentError):\n        create_tables(sqlite_engine, True)\n        raised_error = True\n        assert raised_error\n\n\ndef test_database_create_engine():\n    sqlalchemy_database_url = \"postgresql://postgres:1234@localhost/postgres\"\n    engine = create_env_engine(True, sqlalchemy_database_url)\n    assert 'postgres' in str(engine.url)\n    sqlalchemy_database_url = \"sqlite:///./test1.db\"\n    engine = create_env_engine(False, sqlalchemy_database_url)\n    assert 'sqlite' in str(engine.url)\n"}
{"type": "test_file", "path": "tests/test_quotes.py", "content": "from datetime import date\n\nfrom app.internal import daily_quotes\n\nDATE = date(2021, 1, 1)\nDATE2 = date(2021, 1, 2)\n\n\ndef test_get_quote():\n    quotes_fields = {\n        'text': 'some_quote',\n        'author': 'Freud',\n    }\n    result = daily_quotes.get_quote(quotes_fields)\n    assert result.text == 'some_quote'\n    assert result.author == 'Freud'\n\n\ndef test_get_quote_of_day_no_quotes(session):\n    assert daily_quotes.get_quote_of_day(session, DATE) is None\n\n\ndef test_get_quote_of_day_get_first_quote(session, quote1, quote2):\n    assert daily_quotes.get_quote_of_day(\n        session, DATE).text == quote1.text\n\n\ndef test_get_quote_of_day_get_second_quote(session, quote1, quote2):\n    assert daily_quotes.get_quote_of_day(\n        session, DATE2).text == quote2.text\n"}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/database/__init__.py", "content": "import os\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app import config\n\nSQLALCHEMY_DATABASE_URL = os.getenv(\n    \"DATABASE_CONNECTION_STRING\", config.DEVELOPMENT_DATABASE_STRING)\n\n\ndef create_env_engine(psql_environment, sqlalchemy_database_url):\n    if not psql_environment:\n        return create_engine(\n            sqlalchemy_database_url, connect_args={\"check_same_thread\": False})\n\n    return create_engine(sqlalchemy_database_url)\n\n\nengine = create_env_engine(config.PSQL_ENVIRONMENT, SQLALCHEMY_DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n"}
{"type": "source_file", "path": "app/database/models.py", "content": "from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict\n\nfrom sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    DDL,\n    event,\n    Float,\n    ForeignKey,\n    Index,\n    Integer,\n    JSON,\n    String,\n    Time,\n    UniqueConstraint,\n)\nfrom sqlalchemy.dialects.postgresql import TSVECTOR\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.ext.declarative.api import declarative_base, DeclarativeMeta\nfrom sqlalchemy.orm import relationship, Session\nfrom sqlalchemy.sql.schema import CheckConstraint\n\nfrom app.config import PSQL_ENVIRONMENT\nfrom app.dependencies import logger\nimport app.routers.salary.config as SalaryConfig\n\nBase: DeclarativeMeta = declarative_base()\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, nullable=False)\n    email = Column(String, unique=True, nullable=False)\n    password = Column(String, nullable=False)\n    full_name = Column(String)\n    description = Column(String, default=\"Happy new user!\")\n    avatar = Column(String, default=\"profile.png\")\n    telegram_id = Column(String, unique=True)\n    is_active = Column(Boolean, default=False)\n    disabled = Column(Boolean, default=False, nullable=False)\n    privacy = Column(String, default=\"Private\", nullable=False)\n    is_manager = Column(Boolean, default=False)\n    language_id = Column(Integer, ForeignKey(\"languages.id\"))\n\n    owned_events = relationship(\n        \"Event\",\n        cascade=\"all, delete\",\n        back_populates=\"owner\",\n    )\n    events = relationship(\n        \"UserEvent\",\n        cascade=\"all, delete\",\n        back_populates=\"participants\",\n    )\n    salary_settings = relationship(\n        \"SalarySettings\",\n        cascade=\"all, delete\",\n        back_populates=\"user\",\n    )\n    comments = relationship(\"Comment\", back_populates=\"user\")\n\n    oauth_credentials = relationship(\n        \"OAuthCredentials\",\n        cascade=\"all, delete\",\n        back_populates=\"owner\",\n        uselist=False,\n    )\n\n    def __repr__(self):\n        return f\"<User {self.id}>\"\n\n    @staticmethod\n    async def get_by_username(db: Session, username: str) -> User:\n        \"\"\"query database for a user by unique username\"\"\"\n        return db.query(User).filter(User.username == username).first()\n\n\nclass Event(Base):\n    __tablename__ = \"events\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    start = Column(DateTime, nullable=False)\n    end = Column(DateTime, nullable=False)\n    content = Column(String)\n    location = Column(String, nullable=True)\n    is_google_event = Column(Boolean, default=False)\n    vc_link = Column(String)\n    color = Column(String, nullable=True)\n    all_day = Column(Boolean, default=False)\n    invitees = Column(String)\n    emotion = Column(String, nullable=True)\n    availability = Column(Boolean, default=True, nullable=False)\n\n    owner_id = Column(Integer, ForeignKey(\"users.id\"))\n    category_id = Column(Integer, ForeignKey(\"categories.id\"))\n\n    owner = relationship(\"User\", back_populates=\"owned_events\")\n    participants = relationship(\n        \"UserEvent\",\n        cascade=\"all, delete\",\n        back_populates=\"events\",\n    )\n    comments = relationship(\"Comment\", back_populates=\"event\")\n\n    # PostgreSQL\n    if PSQL_ENVIRONMENT:\n        events_tsv = Column(TSVECTOR)\n        __table_args__ = (\n            Index(\"events_tsv_idx\", \"events_tsv\", postgresql_using=\"gin\"),\n        )\n\n    def __repr__(self):\n        return f\"<Event {self.id}>\"\n\n\nclass UserEvent(Base):\n    __tablename__ = \"user_event\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(\"user_id\", Integer, ForeignKey(\"users.id\"))\n    event_id = Column(\"event_id\", Integer, ForeignKey(\"events.id\"))\n\n    events = relationship(\"Event\", back_populates=\"participants\")\n    participants = relationship(\"User\", back_populates=\"events\")\n\n    def __repr__(self):\n        return f\"<UserEvent ({self.participants}, {self.events})>\"\n\n\nclass Language(Base):\n    __tablename__ = \"languages\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, nullable=False)\n\n\nclass Category(Base):\n    __tablename__ = \"categories\"\n\n    __table_args__ = (UniqueConstraint(\"user_id\", \"name\", \"color\"),)\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    color = Column(String, nullable=False)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n\n    @staticmethod\n    def create(\n        db_session: Session,\n        name: str,\n        color: str,\n        user_id: int,\n    ) -> Category:\n        try:\n            category = Category(name=name, color=color, user_id=user_id)\n            db_session.add(category)\n            db_session.flush()\n            db_session.commit()\n            db_session.refresh(category)\n        except (SQLAlchemyError, IntegrityError) as e:\n            logger.error(f\"Failed to create category: {e}\")\n            raise e\n        else:\n            return category\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {c.name: getattr(self, c.name) for c in self.__table__.columns}\n\n    def __repr__(self) -> str:\n        return f\"<Category {self.id} {self.name} {self.color}>\"\n\n\nclass PSQLEnvironmentError(Exception):\n    pass\n\n\n# PostgreSQL\nif PSQL_ENVIRONMENT:\n    trigger_snippet = DDL(\n        \"\"\"\n    CREATE TRIGGER ix_events_tsv_update BEFORE INSERT OR UPDATE\n    ON events\n    FOR EACH ROW EXECUTE PROCEDURE\n    tsvector_update_trigger(events_tsv,'pg_catalog.english','title','content')\n    \"\"\",\n    )\n\n    event.listen(\n        Event.__table__,\n        \"after_create\",\n        trigger_snippet.execute_if(dialect=\"postgresql\"),\n    )\n\n\nclass Invitation(Base):\n    __tablename__ = \"invitations\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    status = Column(String, nullable=False, default=\"unread\")\n    recipient_id = Column(Integer, ForeignKey(\"users.id\"))\n    event_id = Column(Integer, ForeignKey(\"events.id\"))\n    creation = Column(DateTime, default=datetime.now)\n\n    recipient = relationship(\"User\")\n    event = relationship(\"Event\")\n\n    def __repr__(self):\n        return f\"<Invitation \" f\"({self.event.owner}\" f\"to {self.recipient})>\"\n\n\nclass OAuthCredentials(Base):\n    __tablename__ = \"oauth_credentials\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    token = Column(String)\n    refresh_token = Column(String)\n    token_uri = Column(String)\n    client_id = Column(String)\n    client_secret = Column(String)\n    expiry = Column(DateTime)\n\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    owner = relationship(\"User\", back_populates=__tablename__, uselist=False)\n\n\nclass SalarySettings(Base):\n    # Code revision required after categories feature is added\n    # Code revision required after holiday times feature is added\n    # Code revision required after Shabbat times feature is added\n    __tablename__ = \"salary_settings\"\n\n    user_id = Column(\n        Integer,\n        ForeignKey(\"users.id\"),\n        primary_key=True,\n    )\n    # category_id = Column(\n    #     Integer, ForeignKey(\"categories.id\"), primary_key=True,\n    # )\n    category_id = Column(\n        Integer,\n        primary_key=True,\n    )\n    wage = Column(\n        Float,\n        nullable=False,\n        default=SalaryConfig.MINIMUM_WAGE,\n    )\n    off_day = Column(\n        Integer,\n        CheckConstraint(\"0<=off_day<=6\"),\n        nullable=False,\n        default=SalaryConfig.SATURDAY,\n    )\n    # holiday_category_id = Column(\n    #     Integer, ForeignKey(\"holiday_categories.id\"), nullable=False,\n    #     default=SalaryConfig.ISRAELI_JEWISH,\n    # )\n    holiday_category_id = Column(\n        Integer,\n        nullable=False,\n        default=SalaryConfig.ISRAELI_JEWISH,\n    )\n    regular_hour_basis = Column(\n        Float,\n        nullable=False,\n        default=SalaryConfig.REGULAR_HOUR_BASIS,\n    )\n    night_hour_basis = Column(\n        Float,\n        nullable=False,\n        default=SalaryConfig.NIGHT_HOUR_BASIS,\n    )\n    night_start = Column(\n        Time,\n        nullable=False,\n        default=SalaryConfig.NIGHT_START,\n    )\n    night_end = Column(\n        Time,\n        nullable=False,\n        default=SalaryConfig.NIGHT_END,\n    )\n    night_min_len = Column(\n        Time,\n        nullable=False,\n        default=SalaryConfig.NIGHT_MIN_LEN,\n    )\n    first_overtime_amount = Column(\n        Float,\n        nullable=False,\n        default=SalaryConfig.FIRST_OVERTIME_AMOUNT,\n    )\n    first_overtime_pay = Column(\n        Float,\n        nullable=False,\n        default=SalaryConfig.FIRST_OVERTIME_PAY,\n    )\n    second_overtime_pay = Column(\n        Float,\n        nullable=False,\n        default=SalaryConfig.SECOND_OVERTIME_PAY,\n    )\n    week_working_hours = Column(\n        Float,\n        nullable=False,\n        default=SalaryConfig.WEEK_WORKING_HOURS,\n    )\n    daily_transport = Column(\n        Float,\n        CheckConstraint(f\"daily_transport<={SalaryConfig.MAXIMUM_TRANSPORT}\"),\n        nullable=False,\n        default=SalaryConfig.STANDARD_TRANSPORT,\n    )\n\n    user = relationship(\"User\", back_populates=\"salary_settings\")\n\n    # category = relationship(\"Category\", back_populates=\"salary_settings\")\n    # holiday_category =relationship(\"HolidayCategory\",\n    #                                back_populates=\"salary_settings\")\n\n    def __repr__(self):\n        return f\"<SalarySettings ({self.user_id}, {self.category_id})>\"\n\n\nclass WikipediaEvents(Base):\n    __tablename__ = \"wikipedia_events\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    date_ = Column(String, nullable=False)\n    wikipedia = Column(String, nullable=False)\n    events = Column(JSON, nullable=True)\n    date_inserted = Column(DateTime, default=datetime.utcnow)\n\n\nclass Quote(Base):\n    __tablename__ = \"quotes\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(String, nullable=False)\n    author = Column(String)\n\n\nclass Comment(Base):\n    __tablename__ = \"comments\"\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    event_id = Column(Integer, ForeignKey(\"events.id\"), nullable=False)\n    content = Column(String, nullable=False)\n    time = Column(DateTime, nullable=False)\n\n    user = relationship(\"User\", back_populates=\"comments\")\n    event = relationship(\"Event\", back_populates=\"comments\")\n\n    def __repr__(self):\n        return f\"<Comment {self.id}>\"\n\n\nclass Zodiac(Base):\n    __tablename__ = \"zodiac-signs\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    start_month = Column(Integer, nullable=False)\n    start_day_in_month = Column(Integer, nullable=False)\n    end_month = Column(Integer, nullable=False)\n    end_day_in_month = Column(Integer, nullable=False)\n\n    def __repr__(self):\n        return (\n            f\"<Zodiac \"\n            f\"{self.name} \"\n            f\"{self.start_day_in_month}/{self.start_month}-\"\n            f\"{self.end_day_in_month}/{self.end_month}>\"\n        )\n\n\n# insert language data\n\n# Credit to adrihanu   https://stackoverflow.com/users/9127249/adrihanu\n# https://stackoverflow.com/questions/17461251\ndef insert_data(target, session: Session, **kw):\n    session.execute(\n        target.insert(),\n        {\"id\": 1, \"name\": \"English\"},\n        {\"id\": 2, \"name\": \"עברית\"},\n    )\n\n\nevent.listen(Language.__table__, \"after_create\", insert_data)\n"}
{"type": "source_file", "path": "app/database/schemas.py", "content": "from typing import Optional, Union\nfrom pydantic import BaseModel, validator, EmailStr, EmailError\n\n\nEMPTY_FIELD_STRING = 'field is required'\nMIN_FIELD_LENGTH = 3\nMAX_FIELD_LENGTH = 20\n\n\ndef fields_not_empty(field: Optional[str]) -> Union[ValueError, str]:\n    \"\"\"Global function to validate fields are not empty.\"\"\"\n    if not field:\n        raise ValueError(EMPTY_FIELD_STRING)\n    return field\n\n\nclass UserBase(BaseModel):\n    \"\"\"\n    Validating fields types\n    Returns a User object without sensitive information\n    \"\"\"\n    username: str\n    email: str\n    full_name: str\n    description: Optional[str] = None\n\n    class Config:\n        orm_mode = True\n\n\nclass UserCreate(UserBase):\n    \"\"\"Validating fields types\"\"\"\n    password: str\n    confirm_password: str\n\n    \"\"\"\n    Calling to field_not_empty validaion function,\n    for each required field.\n    \"\"\"\n    _fields_not_empty_username = validator(\n        'username', allow_reuse=True)(fields_not_empty)\n    _fields_not_empty_full_name = validator(\n        'full_name', allow_reuse=True)(fields_not_empty)\n    _fields_not_empty_password = validator(\n        'password', allow_reuse=True)(fields_not_empty)\n    _fields_not_empty_confirm_password = validator(\n        'confirm_password', allow_reuse=True)(fields_not_empty)\n    _fields_not_empty_email = validator(\n        'email', allow_reuse=True)(fields_not_empty)\n\n    @validator('confirm_password')\n    def passwords_match(\n            cls, confirm_password: str,\n            values: UserBase) -> Union[ValueError, str]:\n        \"\"\"Validating passwords fields identical.\"\"\"\n        if 'password' in values and confirm_password != values['password']:\n            raise ValueError(\"doesn't match to password\")\n        return confirm_password\n\n    @validator('username')\n    def username_length(cls, username: str) -> Union[ValueError, str]:\n        \"\"\"Validating username length is legal\"\"\"\n        if not (MIN_FIELD_LENGTH < len(username) < MAX_FIELD_LENGTH):\n            raise ValueError(\"must contain between 3 to 20 charactars\")\n        return username\n\n    @validator('password')\n    def password_length(cls, password: str) -> Union[ValueError, str]:\n        \"\"\"Validating username length is legal\"\"\"\n        if not (MIN_FIELD_LENGTH < len(password) < MAX_FIELD_LENGTH):\n            raise ValueError(\"must contain between 3 to 20 charactars\")\n        return password\n\n    @validator('email')\n    def confirm_mail(cls, email: str) -> Union[ValueError, str]:\n        \"\"\"Validating email is valid mail address.\"\"\"\n        try:\n            EmailStr.validate(email)\n            return email\n        except EmailError:\n            raise ValueError(\"address is not valid\")\n\n\nclass User(UserBase):\n    \"\"\"\n    Validating fields types\n    Returns a User object without sensitive information\n    \"\"\"\n    id: int\n    is_active: bool\n"}
{"type": "source_file", "path": "app/dependencies.py", "content": "import os\nfrom functools import lru_cache\n\nfrom fastapi.templating import Jinja2Templates\nfrom sqlalchemy.orm import Session\n\nfrom app import config\nfrom app.database import SessionLocal\nfrom app.internal.logger_customizer import LoggerCustomizer\n\nGOOGLE_ERROR = config.CLIENT_SECRET_FILE is None\nAPP_PATH = os.path.dirname(os.path.realpath(__file__))\nMEDIA_PATH = os.path.join(APP_PATH, config.MEDIA_DIRECTORY)\nSTATIC_PATH = os.path.join(APP_PATH, \"static\")\nTEMPLATES_PATH = os.path.join(APP_PATH, \"templates\")\n\ntemplates = Jinja2Templates(directory=TEMPLATES_PATH)\ntemplates.env.add_extension('jinja2.ext.i18n')\n\n# Configure logger\nlogger = LoggerCustomizer.make_logger(config.LOG_PATH,\n                                      config.LOG_FILENAME,\n                                      config.LOG_LEVEL,\n                                      config.LOG_ROTATION_INTERVAL,\n                                      config.LOG_RETENTION_INTERVAL,\n                                      config.LOG_FORMAT)\n\n\ndef get_db() -> Session:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\n@lru_cache()\ndef get_settings():\n    return config.Settings()\n"}
{"type": "source_file", "path": "app/internal/__init__.py", "content": ""}
{"type": "source_file", "path": "app/internal/agenda_events.py", "content": "import datetime\nfrom datetime import date, timedelta\nfrom typing import Iterator, List, Optional, Union\n\nimport arrow\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Event\nfrom app.routers.event import sort_by_date\nfrom app.routers.user import get_all_user_events\n\n\ndef get_events_per_dates(\n        session: Session,\n        user_id: int,\n        start: Optional[date],\n        end: Optional[date]\n) -> Union[Iterator[Event], list]:\n    \"\"\"Read from the db. Return a list of all\n    the user events between the relevant dates.\"\"\"\n\n    if start > end:\n        return []\n\n    return (\n        filter_dates(\n            sort_by_date(\n                get_all_user_events(session, user_id)\n            ),\n            start,\n            end,\n        )\n    )\n\n\ndef build_arrow_delta_granularity(diff: timedelta) -> List[str]:\n    \"\"\"Builds the granularity for the arrow module string\"\"\"\n    granularity = []\n    if diff.days > 0:\n        granularity.append(\"day\")\n    hours, remainder = divmod(diff.seconds, 60 * 60)\n    if hours > 0:\n        granularity.append(\"hour\")\n    minutes, _ = divmod(remainder, 60)\n    if minutes > 0:\n        granularity.append(\"minute\")\n    return granularity\n\n\ndef get_time_delta_string(start: date, end: date) -> str:\n    \"\"\"Builds a string of the event's duration- days, hours and minutes.\"\"\"\n    arrow_start = arrow.get(start)\n    arrow_end = arrow.get(end)\n    diff = end - start\n    granularity = build_arrow_delta_granularity(diff)\n    duration_string = arrow_end.humanize(\n        arrow_start, only_distance=True, granularity=granularity\n    )\n    return duration_string\n\n\ndef filter_dates(\n        events: List[Event],\n        start: Union[None, date] = None,\n        end: Union[None, date] = None,\n) -> Iterator[Event]:\n    \"\"\"Returns all events in a time frame.\n\n    if \"start_date\" or \"end_date\" are None,\n    it will ignore that parameter when filtering.\n\n    for example:\n    if start_date = None and end_date = datetime.now().date,\n    then the function will return all events that ends before end_date.\n    \"\"\"\n    start = start or datetime.date.min\n    end = end or datetime.date.max\n\n    for event in events:\n        if start <= event.start.date() <= end:\n            yield event\n\n\ndef get_events_in_time_frame(\n        start_date: Union[date, None],\n        end_date: Union[date, None],\n        user_id: int, db: Session\n) -> Iterator[Event]:\n    \"\"\"Yields all user's events in a time frame.\"\"\"\n    events = get_all_user_events(db, user_id)\n    yield from filter_dates(events, start_date, end_date)\n"}
{"type": "source_file", "path": "app/internal/astronomy.py", "content": "from datetime import datetime\nimport functools\nfrom typing import Any, Dict\n\nimport httpx\n\nfrom app import config\n\n# This feature requires an API key. Get yours free at www.weatherapi.com.\nASTRONOMY_URL = \"https://api.weatherapi.com/v1/astronomy.json\"\nNO_API_RESPONSE = _(\"No response from server.\")\n\n\nasync def get_astronomical_data(\n        date: datetime, location: str\n) -> Dict[str, Any]:\n    \"\"\"Returns astronomical data (sun and moon) for date and location.\n\n    Args:\n        date: The requested date for astronomical data.\n        location: The location name.\n\n    Returns:\n        A dictionary with the following entries:\n            success: True or False.\n            error: The error description.\n            location: A dictionary of relevant data, including:\n                name, region, country, lat, lon etc.\n            astronomy: A dictionary of relevant data, including:\n                sunrise, sunset, moonrise, moonset, moon_phase, and\n                moon_illumination.\n    \"\"\"\n    formatted_date = date.strftime('%Y-%m-%d')\n    return await _get_astronomical_data_from_api(formatted_date, location)\n\n\n@functools.lru_cache(maxsize=128)\nasync def _get_astronomical_data_from_api(\n        date: str, location: str\n) -> Dict[str, Any]:\n    \"\"\"Returns astronomical_data from a Weather API call.\n\n    Args:\n        date: The requested date for astronomical data.\n        location: The location name.\n\n    Returns:\n        A dictionary with the results from the API call.\n    \"\"\"\n    input_query_string = {\n        'key': config.ASTRONOMY_API_KEY,\n        'q': location,\n        'dt': date,\n    }\n\n    output: Dict[str, Any] = {}\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                ASTRONOMY_URL, params=input_query_string)\n    except httpx.HTTPError:\n        output[\"success\"] = False\n        output[\"error\"] = NO_API_RESPONSE\n        return output\n\n    if response.status_code != httpx.codes.OK:\n        output[\"success\"] = False\n        output[\"error\"] = NO_API_RESPONSE\n        return output\n\n    output[\"success\"] = True\n    try:\n        output.update(response.json()['location'])\n        return output\n    except KeyError:\n        output[\"success\"] = False\n        output[\"error\"] = response.json()['error']['message']\n        return output\n"}
{"type": "source_file", "path": "app/internal/calendar_privacy.py", "content": "from app.dependencies import get_db\nfrom app.database.models import User\n# TODO switch to using this when the user system is merged\n# from app.internal.security.dependancies import (\n#    current_user, CurrentUser)\n\nfrom fastapi import Depends\n\n\n# TODO add privacy as an attribute in current user\n# in app.internal.security.dependancies\n# when user system is merged\ndef can_show_calendar(\n    requested_user_username: str,\n    db: Depends(get_db),\n    current_user: User\n    # TODO to be added after user system is merged:\n    # CurrentUser = Depends(current_user)\n) -> bool:\n    \"\"\"Check whether current user can show the requested calendar\"\"\"\n    requested_user = db.query(User).filter(\n        User.username == requested_user_username\n    ).first()\n    privacy = current_user.privacy\n    is_current_user = current_user.username == requested_user.username\n    if privacy == 'Private' and is_current_user:\n        return True\n\n    elif privacy == 'Public':\n        return True\n\n    return False\n"}
{"type": "source_file", "path": "app/internal/celebrity.py", "content": "import datetime\n\n\ndef get_today_month_and_day() -> str:\n    \"\"\"Returns today's month and day in the format: %m-%d\"\"\"\n    return datetime.date.today().strftime(\"%m-%d\")\n"}
{"type": "source_file", "path": "app/internal/comment.py", "content": "import datetime\nimport json\nfrom typing import Dict\n\nfrom sqlalchemy.orm.session import Session\n\nfrom app.database.models import Comment, Event\nfrom app.internal import utils\n\n\ndef create_comment(session: Session, event: Event, content: str) -> None:\n    \"\"\"Creates a comment instance in the DB.\n\n    Args:\n        session (Session): DB session.\n        event (Event): Instance of the event to create a comment for.\n        content (str): The content of the comment.\n    \"\"\"\n    data = {\n        'user': utils.get_current_user(session),\n        'event': event,\n        'content': content,\n        'time': datetime.datetime.now()\n    }\n    utils.create_model(session, Comment, **data)\n\n\ndef parse_comment(session: Session, comment: Comment) -> Dict[str, str]:\n    \"\"\"Returns a dictionary with the comment's info.\n\n    Args:\n        session (Session): DB session.\n        comment (Comment): Comment instance to parse.\n\n    Returns:\n        dict(str: str): Comment's info.\n                        'id' - The comment's.\n                        'avatar' - Commentor's profile image.\n                        'username' - Commentor's username.\n                        'time' - Comment's posting time.\n                        'content' - Comment's content\n    \"\"\"\n    user = utils.get_user(session, comment.user_id)\n    return {\n        'id': comment.id,\n        'avatar': user.avatar,\n        'username': user.username,\n        'time': comment.time.strftime(r'%d/%m/%Y %H:%M'),\n        'content': comment.content\n    }\n\n\ndef display_comments(session: Session, event: Event) -> str:\n    \"\"\"Returns a list of info dictionaries of all the comments for the given\n    event.\n\n    Args:\n        session (Session): DB session.\n        event (Event): Event instance to fetch comments for.\n\n    Returns:\n        list(dict(str: str)): List of info dictionaries of all the comments for\n                              the given event.\n    \"\"\"\n    comments = session.query(Comment).filter_by(event_id=event.id).all()\n    return json.dumps([parse_comment(session, comment)\n                       for comment in comments])\n\n\ndef delete_comment(session: Session, comment_id: int) -> bool:\n    \"\"\"Deletes a comment instance based on `comment_id`. Returns True if\n    successful, False otherwise.\n\n    Args:\n        session (Session): DB session.\n        comment_id (int): ID of comment instance to delete.\n\n    Returns:\n        bool: True if successful, False otherwise.\n    \"\"\"\n    comment = session.query(Comment).filter_by(id=comment_id).first()\n    if comment:\n        utils.delete_instance(session, comment)\n        return True\n    return False\n"}
{"type": "source_file", "path": "app/internal/daily_quotes.py", "content": "from datetime import date\nfrom typing import Dict, Optional\n\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.sql.expression import func\n\nfrom app.database.models import Quote\n\nTOTAL_DAYS = 366\n\n\ndef get_quote(quote_: Dict[str, Optional[str]]) -> Quote:\n    \"\"\"Returns a Quote object from the dictionary data.\n\n    Args:\n        quote_: A dictionary quote related information.\n\n    Returns:\n        A new Quote object.\n    \"\"\"\n    return Quote(\n        text=quote_['text'],\n        author=quote_['author'],\n    )\n\n\ndef get_quote_of_day(\n        session: Session, requested_date: date = date.today()\n) -> Optional[Quote]:\n    \"\"\"Returns the Quote object for the specific day.\n\n    The quote is randomly selected from a set of quotes matching the given day.\n\n    Args:\n        session: The database connection.\n        requested_date: Optional; The requested date.\n\n    Returns:\n        A Quote object.\n    \"\"\"\n    day_number = requested_date.timetuple().tm_yday\n    quote = (session.query(Quote)\n             .filter(Quote.id % TOTAL_DAYS == day_number)\n             .order_by(func.random())\n             .first()\n             )\n    return quote\n"}
{"type": "source_file", "path": "app/internal/email.py", "content": "import os\nfrom typing import List, Optional\n\nfrom fastapi import BackgroundTasks, UploadFile\nfrom fastapi_mail import FastMail, MessageSchema\nfrom pydantic import EmailStr\nfrom pydantic.errors import EmailError\nfrom sqlalchemy.orm.session import Session\n\nfrom app.config import (CALENDAR_HOME_PAGE, CALENDAR_REGISTRATION_PAGE,\n                        CALENDAR_SITE_NAME, email_conf, templates)\nfrom app.database.models import Event, User\n\nmail = FastMail(email_conf)\n\n\ndef send(\n        session: Session, event_used: int, user_to_send: int,\n        title: str, background_tasks: BackgroundTasks = BackgroundTasks\n) -> bool:\n    \"\"\"This function is being used to send emails in the background.\n    It takes an event and a user and it sends the event to the user.\n\n    Args:\n        session(Session): The session to redirect to the database.\n        title (str): Title of the email that is being sent.\n        event_used (int): Id number of the event that is used.\n        user_to_send (int): Id number of user that we want to notify.\n        background_tasks (BackgroundTasks): Function from fastapi that lets\n            you apply tasks in the background.\n\n    Returns:\n        bool: Returns True if the email was sent, else returns False.\n    \"\"\"\n    event_used = session.query(Event).filter(\n        Event.id == event_used).first()\n    user_to_send = session.query(User).filter(\n        User.id == user_to_send).first()\n    if not user_to_send or not event_used:\n        return False\n    if not verify_email_pattern(user_to_send.email):\n        return False\n\n    subject = f\"{title} {event_used.title}\"\n    recipients = {\"email\": [user_to_send.email]}.get(\"email\")\n    body = f\"begins at:{event_used.start} : {event_used.content}\"\n\n    background_tasks.add_task(send_internal,\n                              subject=subject,\n                              recipients=recipients,\n                              body=body)\n    return True\n\n\ndef send_email_invitation(sender_name: str,\n                          recipient_name: str,\n                          recipient_mail: str,\n                          background_tasks: BackgroundTasks = BackgroundTasks\n                          ) -> bool:\n    \"\"\"\n    This function takes as parameters the sender's name,\n    the recipient's name and his email address, configuration, and\n    sends the recipient an invitation to his email address in\n    the format HTML.\n    :param sender_name: str, the sender's name\n    :param recipient_name: str, the recipient's name\n    :param recipient_mail: str, the recipient's email address\n    :param background_tasks: (BackgroundTasks): Function from fastapi that lets\n            you apply tasks in the background.\n    :return: bool, True if the invitation was successfully\n    sent to the recipient, and False if the entered\n    email address is incorrect.\n    \"\"\"\n    if not verify_email_pattern(recipient_mail):\n        return False\n\n    if not recipient_name:\n        return False\n\n    if not sender_name:\n        return False\n\n    template = templates.get_template(\"invite_mail.html\")\n    html = template.render(recipient=recipient_name, sender=sender_name,\n                           site_name=CALENDAR_SITE_NAME,\n                           registration_link=CALENDAR_REGISTRATION_PAGE,\n                           home_link=CALENDAR_HOME_PAGE,\n                           addr_to=recipient_mail)\n\n    subject = \"Invitation\"\n    recipients = [recipient_mail]\n    body = html\n    subtype = \"html\"\n\n    background_tasks.add_task(send_internal,\n                              subject=subject,\n                              recipients=recipients,\n                              body=body,\n                              subtype=subtype)\n    return True\n\n\ndef send_email_file(file_path: str,\n                    recipient_mail: str,\n                    background_tasks: BackgroundTasks = BackgroundTasks):\n    \"\"\"\n    his function takes as parameters the file's path,\n    the recipient's email address, configuration, and\n    sends the recipient an file to his email address.\n    :param file_path: str, the file's path\n    :param recipient_mail: str, the recipient's email address\n    :param background_tasks: (BackgroundTasks): Function from fastapi that lets\n            you apply tasks in the background.\n    :return: bool, True if the file was successfully\n    sent to the recipient, and False if the entered\n    email address is incorrect or file does not exist.\n    \"\"\"\n    if not verify_email_pattern(recipient_mail):\n        return False\n\n    if not os.path.exists(file_path):\n        return False\n\n    subject = \"File\"\n    recipients = [recipient_mail]\n    body = \"file\"\n    file_attachments = [file_path]\n\n    background_tasks.add_task(send_internal,\n                              subject=subject,\n                              recipients=recipients,\n                              body=body,\n                              file_attachments=file_attachments)\n    return True\n\n\nasync def send_internal(subject: str,\n                        recipients: List[str],\n                        body: str,\n                        subtype: Optional[str] = None,\n                        file_attachments: Optional[List[str]] = None):\n    if file_attachments is None:\n        file_attachments = []\n\n    message = MessageSchema(\n        subject=subject,\n        recipients=[EmailStr(recipient) for recipient in recipients],\n        body=body,\n        subtype=subtype,\n        attachments=[UploadFile(file_attachment)\n                     for file_attachment in file_attachments])\n\n    return await send_internal_internal(message)\n\n\nasync def send_internal_internal(msg: MessageSchema):\n    \"\"\"\n    This function receives message and\n    configuration as parameters and sends the message.\n    :param msg: MessageSchema, message\n    :return: None\n    \"\"\"\n    await mail.send_message(msg)\n\n\ndef verify_email_pattern(email: str) -> bool:\n    \"\"\"\n    This function checks the correctness\n    of the entered email address\n    :param email: str, the entered email address\n    :return: bool,\n    True if the entered email address is correct,\n    False if the entered email address is incorrect.\n    \"\"\"\n    try:\n        EmailStr.validate(email)\n        return True\n    except EmailError:\n        return False\n"}
{"type": "source_file", "path": "app/internal/emotion.py", "content": "import text2emotion as te\nfrom typing import Dict, NamedTuple, Union\n\nfrom app.config import (\n    CONTENT_WEIGHTS,\n    LEVEL_OF_SIGNIFICANCE,\n    TITLE_WEIGHTS)\n\n\nEMOTIONS = {\"Happy\": \"&#128515\",\n            \"Sad\": \"&#128577\",\n            \"Angry\": \"&#128544\",\n            \"Fear\": \"&#128561\",\n            \"Surprise\": \"&#128558\"}\n\nEmoticon = NamedTuple(\"Emoticon\", [(\"dominant\", str), (\"score\", float),\n                      (\"code\", str)])\nDupEmotion = NamedTuple(\"DupEmotion\", [(\"dominant\", str), (\"flag\", bool)])\n\n\ndef get_weight(emotion: str, title_emotion: Dict[str, float],\n               content_emotion: Dict[str, float] = None) -> float:\n    if not content_emotion:\n        return title_emotion[emotion]\n    return (title_emotion[emotion] * TITLE_WEIGHTS +\n            content_emotion[emotion] * CONTENT_WEIGHTS)\n\n\ndef score_comp(emotion_score: float, dominant_emotion: Emoticon, emotion: str,\n               code: str, flag: bool) -> DupEmotion:\n    \"\"\"\n    score comparison between emotions.\n    returns the dominant and if equals we flag it\n    \"\"\"\n    if emotion_score > dominant_emotion.score:\n        flag = False\n        dominant_emotion = Emoticon(dominant=emotion, score=emotion_score,\n                                    code=code)\n    elif emotion_score == dominant_emotion.score:\n        flag = True\n    return DupEmotion(dominant=dominant_emotion, flag=flag)\n\n\ndef get_dominant_emotion(title: str, content: str) -> Emoticon:\n    \"\"\"\n    get text from event title and content and return\n    the dominant emotion, emotion score and emoticon code\n    \"\"\"\n    dominant_emotion = Emoticon(dominant=None, score=0, code=None)\n    has_content = False\n    duplicate_dominant_flag = False\n    title_emotion = te.get_emotion(title)\n    if content is not None and content.strip() != \"\":\n        content_emotion = te.get_emotion(content)\n        has_content = True\n    for emotion, code in EMOTIONS.items():\n        weight_parameters = [emotion, title_emotion]\n        if has_content:\n            weight_parameters.append(content_emotion)\n        emotion_score = get_weight(*weight_parameters)\n        score_comparison = score_comp(emotion_score, dominant_emotion, emotion,\n                                      code, duplicate_dominant_flag)\n        dominant_emotion, duplicate_dominant_flag = [*score_comparison]\n    if duplicate_dominant_flag:\n        return Emoticon(dominant=None, score=0, code=None)\n    return dominant_emotion\n\n\ndef is_emotion_above_significance(dominant_emotion: Emoticon,\n                                  significance: float =\n                                  LEVEL_OF_SIGNIFICANCE) -> bool:\n    \"\"\"\n    get the dominant emotion, emotion score and emoticon code\n    and check if the emotion score above the constrain we set\n    \"\"\"\n    return dominant_emotion.score >= significance\n\n\ndef get_html_emoticon(dominant_emotion: Emoticon) -> Union[str, None]:\n    return dominant_emotion.code\n\n\ndef get_emotion(title: str, content: str) -> Union[str, None]:\n    \"\"\"\n    The main function checks what the dominant emotion\n    and if thr dominant emotion above the constrain we set\n    return the emoticon code\n    \"\"\"\n    dominant = get_dominant_emotion(title, content)\n    if is_emotion_above_significance(dominant):\n        return get_html_emoticon(dominant)\n"}
{"type": "source_file", "path": "app/internal/event.py", "content": "import logging\nimport re\nfrom typing import List, Set\n\nfrom email_validator import EmailSyntaxError, validate_email\nfrom fastapi import HTTPException\nfrom sqlalchemy.orm import Session\nfrom starlette.status import HTTP_400_BAD_REQUEST\n\nfrom app.database.models import Event\n\nZOOM_REGEX = re.compile(r'https://.*?\\.zoom.us/[a-z]/.[^.,\\b\\s]+')\n\n\ndef raise_if_zoom_link_invalid(vc_link):\n    if ZOOM_REGEX.search(vc_link) is None:\n        raise HTTPException(status_code=HTTP_400_BAD_REQUEST,\n                            detail=\"VC type with no valid zoom link\")\n\n\ndef get_invited_emails(invited_from_form: str) -> List[str]:\n    invited_emails = []\n    for invited_email in invited_from_form.split(','):\n        invited_email = invited_email.strip()\n        try:\n            validate_email(invited_email, check_deliverability=False)\n        except EmailSyntaxError:\n            logging.exception(f'{invited_email} is not a valid email address')\n            continue\n        invited_emails.append(invited_email)\n\n    return invited_emails\n\n\ndef get_uninvited_regular_emails(session: Session,\n                                 owner_id: int,\n                                 title: str,\n                                 invited_emails: List[str]) -> Set[str]:\n    invitees_query = session.query(Event).with_entities(Event.invitees)\n    similar_events_invitees = invitees_query.filter(Event.owner_id == owner_id,\n                                                    Event.title == title).all()\n    regular_invitees = set()\n    for record in similar_events_invitees:\n        if record:\n            regular_invitees.update(record[0].split(','))\n\n    return regular_invitees - set(invited_emails)\n\n\ndef check_diffs(checked_event: Event,\n                all_events: List[Event]):\n    \"\"\"Returns the repeated events and the week difference\"\"\"\n    diffs = []\n    for event in all_events:\n        start_delta = checked_event.start - event.start\n        end_delta = checked_event.end - event.end\n\n        # The current event is before the new event and they take the same time\n        if start_delta.total_seconds() > 0 and start_delta == end_delta:\n            # Difference is in multiple of 7 days\n            if start_delta.seconds == 0 and start_delta.days % 7 == 0:\n                diffs.append(int(start_delta.days / 7))\n\n    return diffs\n\n\ndef find_pattern(session, event):\n    all_events_with_same_name = session.query(Event).filter(\n        Event.owner_id == event.owner_id, Event.title == event.title).all()\n\n    return check_diffs(event, all_events_with_same_name)\n\n\ndef get_messages(session: Session,\n                 event: Event,\n                 uninvited_contacts: Set[str]) -> List[str]:\n    messages = []\n    if uninvited_contacts:\n        messages.append(f'Forgot to invite '\n                        f'{\", \".join(uninvited_contacts)} maybe?')\n\n    pattern = find_pattern(session, event)\n    for weeks_diff in pattern:\n        messages.append(f'Same event happened {weeks_diff} weeks before too. '\n                        f'Want to create another one {weeks_diff} after too?')\n    return messages\n"}
{"type": "source_file", "path": "app/internal/export.py", "content": "from datetime import datetime\nfrom typing import List\n\nfrom icalendar import Calendar, Event as IEvent, vCalAddress, vText\nimport pytz\nfrom sqlalchemy.orm import Session\n\nfrom app.config import DOMAIN, ICAL_VERSION, PRODUCT_ID\nfrom app.database.models import Event\nfrom app.internal.email import verify_email_pattern\nfrom app.routers.event import get_attendees_email\n\n\ndef get_icalendar(event: Event, emails: List[str]) -> bytes:\n    \"\"\"Returns an iCalendar event in bytes.\n\n    Builds an iCalendar event with information from the Event object.\n    and a list of emails.\n\n    Args:\n        event: The Event.\n        emails: A list of emails.\n\n    Returns:\n        An iCalendar that can be used as a string for a file.\n    \"\"\"\n    icalendar = _create_icalendar()\n    ievent = _get_icalendar_event(event, emails)\n    icalendar.add_component(ievent)\n    return icalendar.to_ical()\n\n\ndef get_icalendar_with_multiple_events(\n        session: Session, events: List[Event]\n) -> bytes:\n    \"\"\"Returns an iCalendar event in bytes.\n\n    Builds an iCalendar event with information from the Event object.\n    and a list of emails.\n\n    Args:\n        session: The database connection.\n        events: A list of Events.\n\n    Returns:\n        An iCalendar that can be used as a string for a file.\n    \"\"\"\n    icalendar = _create_icalendar()\n    for event in events:\n        emails = get_attendees_email(session, event)\n        emails.remove((event.owner.email,))\n        ievent = _get_icalendar_event(event, emails)\n        icalendar.add_component(ievent)\n\n    return icalendar.to_ical()\n\n\ndef _create_icalendar() -> Calendar:\n    \"\"\"Returns an iCalendar.\"\"\"\n    calendar = Calendar()\n    calendar.add('version', ICAL_VERSION)\n    calendar.add('prodid', PRODUCT_ID)\n\n    return calendar\n\n\ndef _get_icalendar_event(event: Event, emails: List[str]) -> IEvent:\n    \"\"\"Returns an iCalendar event in bytes.\n\n    Builds an iCalendar event with information from the Event object.\n    and a list of emails.\n\n    Args:\n        event: The Event.\n        emails: A list of emails.\n\n    Returns:\n        A iCalendar that can be used as a string for a file.\n    \"\"\"\n    ievent = _create_icalendar_event(event)\n    _add_attendees(ievent, emails)\n    return ievent\n\n\ndef _create_icalendar_event(event: Event) -> IEvent:\n    \"\"\"Returns an iCalendar event with event data.\n\n    Args:\n        event: The Event to transform into an iCalendar event.\n\n    Returns:\n        An iCalendar event.\n    \"\"\"\n    data = [\n        ('organizer', _get_v_cal_address(event.owner.email, organizer=True)),\n        ('uid', _generate_id(event)),\n        ('dtstart', event.start),\n        ('dtstamp', datetime.now(tz=pytz.utc)),\n        ('dtend', event.end),\n        ('summary', event.title),\n    ]\n\n    if event.location:\n        data.append(('location', event.location))\n\n    if event.content:\n        data.append(('description', event.content))\n\n    ievent = IEvent()\n    for param in data:\n        ievent.add(*param)\n\n    return ievent\n\n\ndef _get_v_cal_address(email: str, organizer: bool = False) -> vCalAddress:\n    \"\"\"Returns a vCalAddress for an attendee.\n\n    Args:\n        email: The email of the attendee.\n        organizer: A flag whether or not the user is the event organizer.\n\n    Returns:\n        A vCalAddress object.\n    \"\"\"\n    attendee = vCalAddress(f'MAILTO:{email}')\n    if organizer:\n        attendee.params['partstat'] = vText('ACCEPTED')\n        attendee.params['role'] = vText('CHAIR')\n    else:\n        attendee.params['partstat'] = vText('NEEDS-ACTION')\n        attendee.params['role'] = vText('PARTICIPANT')\n\n    return attendee\n\n\ndef _generate_id(event: Event) -> bytes:\n    \"\"\"Generates a unique encoded ID.\n\n    The ID is generated from the Event ID, start and end times\n    and the domain name.\n\n    Args:\n        event: The Event.\n\n    Returns:\n        A unique encoded ID in bytes.\n    \"\"\"\n    return (\n            str(event.id)\n            + event.start.strftime('%Y%m%d')\n            + event.end.strftime('%Y%m%d')\n            + f'@{DOMAIN}'\n    ).encode()\n\n\ndef _add_attendees(ievent: IEvent, emails: List[str]):\n    \"\"\"Adds attendees to the event.\n\n    Args:\n        ievent: The iCalendar event.\n        emails: A list of attendees emails.\n    \"\"\"\n    for email in emails:\n        if verify_email_pattern(email):\n            ievent.add('attendee', _get_v_cal_address(email), encode=0)\n"}
{"type": "source_file", "path": "app/internal/friend_view.py", "content": "from typing import List\n\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Event\nfrom app.routers.event import sort_by_date\nfrom app.routers.user import get_all_user_events\n\n\ndef get_events_per_friend(\n        session: Session,\n        user_id: int,\n        my_friend: str,\n) -> List[Event]:\n    \"\"\" My_friend is the name of a person that appears in the invite list of\n    events. He is not necessarily a registered userץ The variable is used to\n    show all events where we are both in the invitees list\"\"\"\n\n    events_together = []\n    sorted_events = sort_by_date(get_all_user_events(session, user_id))\n    for event in sorted_events:\n        if my_friend in event.invitees.split(','):\n            events_together.append(event)\n    return events_together\n"}
{"type": "source_file", "path": "app/internal/import_file.py", "content": "from collections import defaultdict\nfrom datetime import datetime\nfrom pathlib import Path\nimport re\nfrom typing import (\n    Any, DefaultDict, Dict, Iterator, List, Optional, Tuple, Union\n)\n\nfrom icalendar import cal, Calendar\nfrom loguru import logger\nfrom sqlalchemy.orm.session import Session\n\nfrom app.config import (\n    EVENT_CONTENT_LIMIT,\n    EVENT_DURATION_LIMIT,\n    EVENT_HEADER_LIMIT,\n    EVENT_HEADER_NOT_EMPTY,\n    EVENT_VALID_YEARS,\n    LOCATION_LIMIT,\n    MAX_EVENTS_START_DATE,\n    MAX_FILE_SIZE_MB,\n    VALID_FILE_EXTENSION,\n)\nfrom app.routers.event import create_event\n\nDATE_FORMAT = \"%m-%d-%Y\"\nDATE_FORMAT2 = \"%m-%d-%Y %H:%M\"\nDESC_EVENT = \"VEVENT\"\n\nEVENT_PATTERN = re.compile(r\"^(\\w{\" + str(int(EVENT_HEADER_NOT_EMPTY)) + \",\" +\n                           str(EVENT_HEADER_LIMIT) + r\"}),\\s(\\w{0,\" +\n                           str(EVENT_CONTENT_LIMIT) +\n                           r\"}),\\s(\\d{2}-\\d{2}-\\d{4}),\" +\n                           r\"\\s(\\d{2}-\\d{2}-\\d{4})(?:,\\s([\\w\\s-]{0,\" +\n                           str(LOCATION_LIMIT) +\n                           r\"}))?$\")\n\nEVENT_PATTERN2 = re.compile(r\"^(\\w{\" + str(int(EVENT_HEADER_NOT_EMPTY)) + \",\" +\n                            str(EVENT_HEADER_LIMIT) + r\"}),\\s(\\w{0,\" +\n                            str(EVENT_CONTENT_LIMIT) +\n                            r\"}),\\s(\\d{2}-\\d{2}-\\d{4}\\s\\d{2}:\\d{2}),\" +\n                            r\"\\s(\\d{2}-\\d{2}-\\d{4}\\s\\d{2}:\\d{2})\" +\n                            r\"(?:,\\s([\\w\\s-]{0,\" + str(LOCATION_LIMIT) +\n                            r\"}))?$\")\n\n\ndef import_events(path: str, user_id: int, session: Session) -> bool:\n    \"\"\"Imports events from an outside file and saves them to the database.\n\n    For the file to be successfully imported, it must be one of the supported\n    types set at VALID_FILE_EXTENSION and not pass the max size set\n    at MAX_FILE_SIZE_MB.\n\n    Args:\n        path: The file path.\n        user_id: The user's ID.\n        session: The database connection.\n\n    Returns:\n        True if successfully saved, otherwise returns False.\n    \"\"\"\n    if _is_file_valid_to_import(path):\n        if _is_file_extension_valid(path, \".ics\"):\n            event_data = _get_data_from_ics_file(path)\n        else:\n            event_data = _get_data_from_txt_file(path)\n        if event_data and _is_file_valid_to_save_to_database(event_data):\n            _save_events_to_database(event_data, user_id, session)\n            return True\n    return False\n\n\ndef _is_file_valid_to_import(path: str) -> bool:\n    \"\"\"Whether the file is valid to be imported.\n\n    Args:\n        path: The file path.\n\n    Returns:\n        True if the file is a valid to be imported, otherwise returns False.\n    \"\"\"\n    return (_is_file_exists(path) and _is_file_extension_valid(path)\n            and _is_file_size_valid(path))\n\n\ndef _is_file_exists(path: str) -> bool:\n    \"\"\"Whether the path is a file.\n\n    Args:\n        path: The file path.\n\n    Returns:\n        True if the path is a file, otherwise returns False.\n    \"\"\"\n    return Path(path).is_file()\n\n\ndef _is_file_extension_valid(\n        path: str,\n        extension: Union[str, Tuple[str, ...]] = VALID_FILE_EXTENSION,\n) -> bool:\n    \"\"\"Whether the path is a valid file extension.\n\n    Args:\n        path: The file path.\n        extension: Optional; A file extension suffix.\n            Defaults to VALID_FILE_EXTENSION.\n\n    Returns:\n        True if the file extension is valid, otherwise returns False.\n    \"\"\"\n    return Path(path).suffix.lower() in extension\n\n\ndef _is_file_size_valid(path: str, max_size: int = MAX_FILE_SIZE_MB) -> bool:\n    \"\"\"Whether the file size is valid.\n\n    Args:\n        path: The file path.\n        max_size: Optional; The maximum file size allowed.\n            Defaults to MAX_FILE_SIZE_MB.\n\n    Returns:\n        True if the file size is valid, otherwise returns False.\n    \"\"\"\n    file_size = Path(path).stat().st_size / 1048576  # convert bytes to MB.\n    return file_size <= max_size\n\n\ndef _get_data_from_ics_file(ics_file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"Returns a list of event data in dictionaries from an *.ics file.\n\n    Args:\n        ics_file_path: The file path.\n\n    Returns:\n        A list of event data in dictionaries, or an empty list\n        if the data is not valid.\n    \"\"\"\n    calendar_content: List[Dict[str, Any]] = []\n    calendar = _get_calendar_from_ics(ics_file_path)\n    if not calendar:\n        return []\n\n    for component in calendar.walk():\n        if component.name == DESC_EVENT:\n            if not _is_valid_data_event_ics(component):\n                return []\n            _add_event_component_ics(component, calendar_content)\n    return calendar_content\n\n\ndef _get_calendar_from_ics(ics_file_path: str) -> Optional[Calendar]:\n    \"\"\"Opens an *.ics file and returns a Calendar object from it.\n\n    Args:\n        ics_file_path: The file path.\n\n    Returns:\n        A Calendar object if successful, otherwise returns None.\n    \"\"\"\n    with open(ics_file_path, \"r\") as ics:\n        try:\n            return Calendar.from_ical(ics.read())\n        except (IndexError, ValueError) as e:\n            logger.error(f\"open_ics function failed error message: {e}\")\n            return None\n\n\ndef _is_valid_data_event_ics(component: cal.Event) -> bool:\n    \"\"\"Whether the ics event data is valid.\n\n    Args:\n        component: An event component.\n\n    Returns:\n        True if valid, otherwise returns False.\n    \"\"\"\n    return not (str(component.get('summary')) is None\n                or component.get('dtstart') is None\n                or component.get('dtend') is None\n                or not _is_date_in_range(component.get('dtstart').dt)\n                or not _is_date_in_range(component.get('dtend').dt)\n                )\n\n\ndef _add_event_component_ics(\n        component: cal.Event, calendar_content: List[Dict[str, Any]]) -> None:\n    \"\"\"Appends event data from an *.ics file.\n\n    Args:\n        component: An event component.\n        calendar_content: A list of event data.\n    \"\"\"\n    calendar_content.append({\n        \"Head\": str(component.get('summary')),\n        \"Content\": str(component.get('description')),\n        \"S_Date\": component.get('dtstart').dt.replace(tzinfo=None),\n        \"E_Date\": component.get('dtend').dt.replace(tzinfo=None),\n        \"Location\": str(component.get('location')),\n    })\n\n\ndef _get_data_from_txt_file(txt_file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"Returns a list of event data in dictionaries from a *.txt file.\n\n    Args:\n        txt_file_path: The file path.\n\n    Returns:\n        A list of event data in dictionaries, or an empty list\n        if the data is not valid.\n    \"\"\"\n    calendar_content: List[Dict[str, Any]] = []\n    for event in _get_event_from_txt_file(txt_file_path):\n        if not _is_event_text_valid(event):\n            return []\n\n        event_data = _get_event_data_from_text(event)\n\n        if not _is_event_dates_valid(\n                event_data[\"start_date\"], event_data[\"end_date\"]):\n            return []\n\n        _add_event_component_txt(event_data, calendar_content)\n\n    return calendar_content\n\n\ndef _get_event_from_txt_file(txt_file: str) -> Iterator[str]:\n    \"\"\"Opens a *.txt file and returns a row of event data from it.\n\n    Args:\n        txt_file: The file path.\n\n    Yields:\n        A row of event data.\n    \"\"\"\n    with open(txt_file, \"r\") as text:\n        for row in text.readlines():\n            yield row\n\n\ndef _is_event_text_valid(text: str) -> bool:\n    \"\"\"Whether the event text contains valid data.\n\n    Args:\n        text: The event text.\n\n    Returns:\n        True if valid, otherwise returns False.\n    \"\"\"\n    get_values = EVENT_PATTERN.search(text)\n    get_values2 = EVENT_PATTERN2.search(text)\n    return get_values is not None or get_values2 is not None\n\n\ndef _get_event_data_from_text(text: str) -> Dict[str, Any]:\n    \"\"\"Returns the event data from the text.\n\n    Args:\n        text: The event text.\n\n    Returns:\n        A dictionary with the event data.\n    \"\"\"\n    if len(text.split(\", \")) == 5:\n        head, content, start_date, end_date, location = text.split(\", \")\n        location = location.replace(\"\\n\", \"\")\n    else:\n        head, content, start_date, end_date = text.split(\", \")\n        end_date = end_date.replace(\"\\n\", \"\")\n        location = \"\"\n\n    return {\n        \"head\": head,\n        \"content\": content,\n        \"start_date\": start_date,\n        \"end_date\": end_date,\n        \"location\": location,\n    }\n\n\ndef _is_event_dates_valid(start: str, end: str) -> bool:\n    \"\"\"Whether the event dates are valid.\n\n    Args:\n        start: The start time of the event.\n        end: The end time of the event.\n\n    Returns:\n        True if valid, otherwise returns False.\n    \"\"\"\n    start_date = _convert_string_to_date(start)\n    end_date = _convert_string_to_date(end)\n    if start_date is None or end_date is None:\n        return False\n\n    assert start_date is not None and end_date is not None\n\n    is_date_in_range = (_is_date_in_range(start_date)\n                        and _is_date_in_range(end_date))\n    is_end_after_start = _is_start_date_before_end_date(start_date, end_date)\n    is_duration_valid = _is_event_duration_valid(start_date, end_date)\n    return is_date_in_range and is_end_after_start and is_duration_valid\n\n\ndef _add_event_component_txt(\n        event: Dict[str, Any], calendar_content: List[Dict[str, Any]]\n) -> None:\n    \"\"\"Appends event data from a txt file.\n\n    Args:\n        event: An event's data.\n        calendar_content: A list of event data.\n    \"\"\"\n    if \":\" in event[\"start_date\"] and \":\" in event[\"start_date\"]:\n        start_date = datetime.strptime(event[\"start_date\"], DATE_FORMAT2)\n        end_date = datetime.strptime(event[\"end_date\"], DATE_FORMAT2)\n    else:\n        start_date = datetime.strptime(event[\"start_date\"], DATE_FORMAT)\n        end_date = datetime.strptime(event[\"end_date\"], DATE_FORMAT)\n\n    calendar_content.append({\n        \"Head\": event[\"head\"],\n        \"Content\": event[\"content\"],\n        \"S_Date\": start_date,\n        \"E_Date\": end_date,\n        \"Location\": event[\"location\"],\n    })\n\n\ndef _convert_string_to_date(string_date: str) -> Optional[datetime]:\n    \"\"\"Returns a datetime object from a date written as a text string.\n\n    Args:\n        string_date: The date as a text string.\n\n    Returns:\n        A datetime date.\n    \"\"\"\n    try:\n        if \":\" in string_date:\n            date = datetime.strptime(string_date, DATE_FORMAT2)\n        else:\n            date = datetime.strptime(string_date, DATE_FORMAT)\n    except ValueError:\n        return None\n    return date\n\n\ndef _is_date_in_range(\n        date: datetime, year_range: int = EVENT_VALID_YEARS\n) -> bool:\n    \"\"\"Whether the date is in range.\n\n    The range should be between the current year - the EVENT_VALID_YEARS\n    and the current year + EVENT_VALID_YEARS.\n    Currently EVENT_VALID_YEARS is set to 20 years, meaning a valid date cannot\n    be more than 20 years in the past or 20 years in the future.\n\n    Args:\n        date: The date to validate.\n        year_range: Optional; The valid year range.\n            Defaults to EVENT_VALID_YEARS.\n\n    Returns:\n        True if valid, otherwise returns False.\n    \"\"\"\n    current_year = datetime.now().year\n    return current_year - year_range < date.year < current_year + year_range\n\n\ndef _is_start_date_before_end_date(start: datetime, end: datetime) -> bool:\n    \"\"\"Whether the start date is before the end date.\n\n    Args:\n        start: The start date of an event.\n        end: The end date of an event.\n\n    Returns:\n        True if valid, otherwise returns False.\n    \"\"\"\n    return start <= end\n\n\ndef _is_event_duration_valid(\n        start: datetime, end: datetime, max_days: int = EVENT_DURATION_LIMIT\n) -> bool:\n    \"\"\"Whether an event duration is valid.\n\n    Args:\n        start: The start date of an event.\n        end: The end date of an event.\n        max_days: Optional; The maximum number of days an event can be held.\n            Defaults to EVENT_DURATION_LIMIT.\n\n    Returns:\n        True if valid, otherwise returns False.\n    \"\"\"\n    return (end - start).days < max_days\n\n\ndef _is_file_valid_to_save_to_database(\n        events: List[Dict[str, Any]],\n        max_event_start_date: int = MAX_EVENTS_START_DATE,\n) -> bool:\n    \"\"\"Whether the number of events starting on the same date is valid.\n\n    The number of events starting on the same date cannot be greater than the\n    maximum number of events allowed to start on the same day in the settings.\n    The default value is set in MAX_EVENTS_START_DATE.\n\n    Args:\n        events: A list of events.\n        max_event_start_date: Optional; The maximum number of events allowed\n            to start on the same day.\n            Defaults to MAX_EVENTS_START_DATE.\n\n    Returns:\n        True if valid, otherwise returns False.\n    \"\"\"\n    same_date_counter = 1\n    dates: DefaultDict[datetime, int] = defaultdict(int)\n    for event in events:\n        dates[event[\"S_Date\"]] += 1\n        if dates[event[\"S_Date\"]] > same_date_counter:\n            same_date_counter = dates[event[\"S_Date\"]]\n    return same_date_counter <= max_event_start_date\n\n\ndef _save_events_to_database(\n        events: List[Dict[str, Any]], user_id: int, session: Session\n) -> None:\n    \"\"\"Inserts the events into the Event table.\n\n    Args:\n        events: A list of events.\n        user_id: The user's ID.\n        session: The database connection.\n    \"\"\"\n    for event in events:\n        title = event[\"Head\"]\n        content = event[\"Content\"]\n        start = event[\"S_Date\"]\n        end = event[\"E_Date\"]\n        location = event[\"Location\"]\n        owner_id = user_id\n        create_event(db=session,\n                     title=title,\n                     content=content,\n                     start=start,\n                     end=end,\n                     location=location,\n                     owner_id=owner_id,\n                     )\n"}
{"type": "source_file", "path": "app/internal/import_holidays.py", "content": "import re\nfrom datetime import datetime, timedelta\n\nfrom app.database.models import User, Event, UserEvent\nfrom sqlalchemy.orm import Session\nfrom typing import List, Match\n\nREGEX_EXTRACT_HOLIDAYS = re.compile(\n    r'SUMMARY:(?P<title>.*)(\\n.*){1,8}DTSTAMP:(?P<date>\\w{8})',\n    re.MULTILINE)\n\n\ndef get_holidays_from_file(file: List[Event], session: Session) -> List[Event]:\n    \"\"\"\n    This function using regex to extract holiday title\n    and date from standrd ics file\n    :param file:standard ics file\n    :param session:current connection\n    :return:list of holidays events\n    \"\"\"\n    parsed_holidays = REGEX_EXTRACT_HOLIDAYS.finditer(file)\n    holidays = []\n    for holiday in parsed_holidays:\n        holiday_event = create_holiday_event(\n            holiday, session.query(User).filter_by(id=1).first().id)\n        holidays.append(holiday_event)\n    return holidays\n\n\ndef create_holiday_event(holiday: Match[str], owner_id: int) -> Event:\n    valid_ascii_chars_range = 128\n    title = holiday.groupdict()['title'].strip()\n    title_to_save = ''.join(i if ord(i) < valid_ascii_chars_range\n                            else '' for i in title)\n    date = holiday.groupdict()['date'].strip()\n    format_string = '%Y%m%d'\n    holiday = Event(\n        title=title_to_save,\n        start=datetime.strptime(date, format_string),\n        end=datetime.strptime(date, format_string) + timedelta(days=1),\n        content='holiday',\n        owner_id=owner_id\n    )\n    return holiday\n\n\ndef save_holidays_to_db(holidays: List[Event], session: Session):\n    \"\"\"\n    this function saves holiday list into database.\n    :param holidays: list of holidays events\n    :param session: current connection\n    \"\"\"\n    session.add_all(holidays)\n    session.commit()\n    session.flush(holidays)\n    userevents = []\n    for holiday in holidays:\n        userevent = UserEvent(\n            user_id=holiday.owner_id,\n            event_id=holiday.id\n        )\n        userevents.append(userevent)\n    session.add_all(userevents)\n    session.commit()\n"}
{"type": "source_file", "path": "app/internal/json_data_loader.py", "content": "import json\nimport os\nfrom typing import Any, Callable, Dict, List\n\nfrom loguru import logger\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Base, Quote, Zodiac\nfrom app.internal import daily_quotes, zodiac\n\n\ndef load_to_database(session: Session) -> None:\n    \"\"\"Loads data from JSON data files into the database.\n\n    On startup, data from the JSON files should be added to the database and\n    not be accessed from a network call for each request as it is costly.\n\n    The quotes JSON file content is copied from the free API:\n    'https://type.fit/api/quotes'.\n\n    Args:\n        session: The database connection.\n    \"\"\"\n    _insert_into_database(\n        session,\n        'app/resources/zodiac.json',\n        Zodiac,\n        zodiac.get_zodiac,\n    )\n\n    _insert_into_database(\n        session,\n        'app/resources/quotes.json',\n        Quote,\n        daily_quotes.get_quote,\n    )\n\n\ndef _insert_into_database(\n        session: Session,\n        path: str,\n        table: Base,\n        model_creator: Callable\n) -> bool:\n    \"\"\"Inserts the extracted JSON data into the database.\n\n    Args:\n        session: The database connection.\n        path: The file path.\n        table: A model entity table.\n        model_creator: A model creation function.\n\n    Returns:\n        True if the save was successful, otherwise returns False.\n    \"\"\"\n    if not _is_table_empty(session, table):\n        return False\n\n    json_objects = _get_data_from_json(path)\n    model_objects = [model_creator(json_object)\n                     for json_object in json_objects]\n    session.add_all(model_objects)\n    session.commit()\n    return True\n\n\ndef _is_table_empty(session: Session, table: Base) -> bool:\n    \"\"\"Returns True if the table is empty.\n\n    Args:\n        session: The database connection.\n        table: A model entity table.\n\n    Returns:\n        True if the table is empty, otherwise returns False.\n    \"\"\"\n    return session.query(table).count() == 0\n\n\ndef _get_data_from_json(path: str) -> List[Dict[str, Any]]:\n    \"\"\"Returns a list of dictionary objects.\n\n    Reads the data from a specific JSON file and converts the data into\n    a list of dictionary items.\n\n    Args:\n        path: The file path.\n\n    Returns:\n        A list of dictionary objects.\n    \"\"\"\n    try:\n        with open(path, 'r') as json_file:\n            json_content = json.load(json_file)\n    except (IOError, ValueError):\n        file_name = os.path.basename(path)\n        logger.exception(\n            f\"An error occurred during reading of json file: {file_name}\")\n        return []\n    return json_content\n"}
{"type": "source_file", "path": "app/internal/logger_customizer.py", "content": "from pathlib import Path\nimport sys\n\nfrom loguru import _Logger as Logger, logger\n\n\nclass LoggerConfigError(Exception):\n    pass\n\n\nclass LoggerCustomizer:\n\n    @classmethod\n    def make_logger(cls, log_path: Path,\n                    log_filename: str,\n                    log_level: str,\n                    log_rotation_interval: str,\n                    log_retention_interval: str,\n                    log_format: str) -> Logger:\n        \"\"\"Creates a logger from given configurations\n\n        Args:\n            log_path (Path): Path where the log file is located\n            log_filename (str):\n\n            log_level (str): The level we want to start logging from\n            log_rotation_interval (str): Every how long the logs\n                would be rotated\n            log_retention_interval (str): Amount of time in words defining\n                how long the log will be kept\n            log_format (str): The logging format\n\n        Raises:\n            LoggerConfigError: Error raised when the configuration is invalid\n\n        Returns:\n            Logger: Loguru logger instance\n        \"\"\"\n        try:\n            logger = cls.customize_logging(\n                file_path=Path(log_path) / Path(log_filename),\n                level=log_level,\n                retention=log_retention_interval,\n                rotation=log_rotation_interval,\n                format=log_format\n            )\n        except (TypeError, ValueError) as err:\n            raise LoggerConfigError(\n                f\"You have an issue with the logger configuration: {err!r}, \"\n                \"fix it please\")\n\n        return logger\n\n    @classmethod\n    def customize_logging(cls,\n                          file_path: Path,\n                          level: str,\n                          rotation: str,\n                          retention: str,\n                          format: str\n                          ) -> Logger:\n        \"\"\"Used to customize the logger instance\n\n        Args:\n            file_path (Path): Path where the log file is located\n            level (str): The level wanted to start logging from\n            rotation (str): Every how long the logs would be\n                rotated(creation of new file)\n            retention (str): Amount of time in words defining how\n                long a log is kept\n            format (str): The logging format\n\n        Returns:\n            Logger: Instance of a logger mechanism\n        \"\"\"\n        logger.remove()\n        logger.add(\n            sys.stdout,\n            enqueue=True,\n            backtrace=True,\n            level=level.upper(),\n            format=format\n        )\n        logger.add(\n            str(file_path),\n            rotation=rotation,\n            retention=retention,\n            enqueue=True,\n            backtrace=True,\n            level=level.upper(),\n            format=format\n        )\n\n        return logger\n"}
{"type": "source_file", "path": "app/internal/languages.py", "content": "import gettext\nimport os\nfrom pathlib import Path\nfrom typing import Iterator\n\nfrom app import config\nfrom app.dependencies import templates\n\nLANGUAGE_DIR = \"app/locales\"\nLANGUAGE_DIR_TEST = \"../app/locales\"\nTRANSLATION_FILE = \"base\"\n\n\ndef set_ui_language(language: str = None) -> None:\n    \"\"\"Sets the gettext translations to a given language.\n\n    If the language requested is not supported, the translations default\n    to the value of config.WEBSITE_LANGUAGE.\n\n    Args:\n        language: Optional; A valid language code that follows RFC 1766.\n            Defaults to None.\n            See also the Language Code Identifier (LCID) Reference for a list of\n            valid language codes.\n\n    .. _RFC 1766:\n        https://tools.ietf.org/html/rfc1766.html\n\n    .. _Language Code Identifier (LCID) Reference:\n        https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c # noqa: E501\n    \"\"\"\n\n    # TODO: Connect when user registration is completed.\n    # if not language:\n    #     language = _get_display_language(user_id: int)\n\n    language_dir = _get_language_directory()\n\n    if language not in list(_get_supported_languages(language_dir)):\n        language = config.WEBSITE_LANGUAGE\n\n    translations = gettext.translation(\n        TRANSLATION_FILE,\n        localedir=language_dir,\n        languages=[language],\n    )\n    translations.install()\n    templates.env.install_gettext_translations(translations, newstyle=True)\n\n\n# TODO: Waiting for user registration. Add doc.\n# def _get_display_language(user_id: int) -> str:\n#     # TODO: handle user language setting:\n#     #  If user is logged in, get language setting.\n#     #  If user is not logged in, get default site setting.\n#\n#     if db_user:\n#         return db_user.language\n#     return config.WEBSITE_LANGUAGE\n\n\ndef _get_language_directory() -> str:\n    \"\"\"Returns the language directory relative path.\"\"\"\n    language_dir = LANGUAGE_DIR\n    if Path(LANGUAGE_DIR_TEST).is_dir():\n        # If running from test, change dir path.\n        language_dir = LANGUAGE_DIR_TEST\n    return language_dir\n\n\ndef _get_supported_languages(\n        language_dir: str = _get_language_directory()\n) -> Iterator[str]:\n    \"\"\"Returns a generator of supported translation languages codes.\n\n    Args:\n        language_dir: Optional; The path of the language directory.\n            Defaults to the return value of _get_language_directory().\n\n    Returns:\n        A generator expression of the supported translation languages codes.\n    \"\"\"\n\n    paths = [Path(f.path) for f in os.scandir(language_dir) if f.is_dir()]\n    return (language.name for language in paths)\n"}
{"type": "source_file", "path": "app/internal/on_this_day_events.py", "content": "from datetime import date, datetime\nimport json\nfrom typing import Any, Dict\n\nfrom fastapi import Depends\nfrom loguru import logger\nimport requests\nfrom sqlalchemy import func\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.orm.exc import NoResultFound\n\nfrom app.database.models import WikipediaEvents\nfrom app.dependencies import get_db\n\n\ndef insert_on_this_day_data(\n        db: Session = Depends(get_db)\n) -> Dict[str, Any]:\n    now = datetime.now()\n    day, month = now.day, now.month\n\n    res = requests.get(\n        f'https://byabbe.se/on-this-day/{month}/{day}/events.json')\n    text = json.loads(res.text)\n    res_events = text.get('events')\n    res_date = text.get('date')\n    res_wiki = text.get('wikipedia')\n    db.add(WikipediaEvents(events=res_events,\n                           date_=res_date, wikipedia=res_wiki))\n    db.commit()\n    return text\n\n\ndef get_on_this_day_events(\n        db: Session = Depends(get_db)\n) -> Dict[str, Any]:\n    try:\n        data = (db.query(WikipediaEvents).\n                filter(\n            func.date(WikipediaEvents.date_inserted) == date.today()).\n                one())\n\n    except NoResultFound:\n        data = insert_on_this_day_data(db)\n    except (SQLAlchemyError, AttributeError) as e:\n        logger.error(f'on this day failed with error: {e}')\n        data = {'events': [], 'wikipedia': 'https://en.wikipedia.org/'}\n    return data\n"}
{"type": "source_file", "path": "app/internal/search.py", "content": "from typing import List\n\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm.session import Session\n\nfrom app.database.models import Event\n\n\ndef get_results_by_keywords(\n        session: Session, keywords: str, owner_id: int\n) -> List[Event]:\n    \"\"\"Returns a list of Events matching the search query.\n\n     The results are limited to Events owned by the current user.\n     Uses PostgreSQL's built in 'Full-text search' feature, and\n     doesn't work with SQLite.\n\n    Args:\n        session: The database connection.\n        keywords: The search keywords.\n        owner_id: The current user ID.\n\n    Returns:\n        A list of Events matching the search query.\n    \"\"\"\n    keywords = _get_stripped_keywords(keywords)\n\n    try:\n        return (session.query(Event)\n                .filter(Event.owner_id == owner_id,\n                        Event.events_tsv.match(keywords))\n                .all())\n\n    except (SQLAlchemyError, AttributeError):\n        return []\n\n\ndef _get_stripped_keywords(keywords: str) -> str:\n    \"\"\"Returns a valid database search keywords string.\n\n    Args:\n        keywords: The search keywords.\n\n    Returns:\n        A valid database search keywords string.\n    \"\"\"\n    keywords = \" \".join(keywords.split())\n    keywords = keywords.replace(\" \", \":* & \") + \":*\"\n    return keywords\n"}
{"type": "source_file", "path": "app/internal/google_connect.py", "content": "from datetime import datetime\nfrom fastapi import Depends\n\nfrom google.auth.transport.requests import Request as google_request\nfrom google.oauth2.credentials import Credentials\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom googleapiclient.discovery import build\n\nfrom app.database.models import Event, User, OAuthCredentials, UserEvent\nfrom app.dependencies import get_db, SessionLocal\nfrom app.config import CLIENT_SECRET_FILE\nfrom app.routers.event import create_event\n\n\nSCOPES = ['https://www.googleapis.com/auth/calendar']\n\n\ndef get_credentials(user: User,\n                    session: SessionLocal = Depends(get_db)) -> Credentials:\n    credentials = get_credentials_from_db(user)\n\n    if credentials is not None:\n        credentials = refresh_token(credentials, session, user)\n    else:\n        credentials = get_credentials_from_consent_screen(\n            user=user, session=session)\n\n    return credentials\n\n\ndef fetch_save_events(credentials: Credentials, user: User,\n                      session: SessionLocal = Depends(get_db)) -> None:\n    if credentials is not None:\n        events = get_current_year_events(credentials, user, session)\n        push_events_to_db(events, user, session)\n\n\ndef clean_up_old_credentials_from_db(\n    session: SessionLocal = Depends(get_db)\n) -> None:\n    session.query(OAuthCredentials).filter_by(user_id=None).delete()\n    session.commit()\n\n\ndef get_credentials_from_consent_screen(user: User,\n                                        session: SessionLocal = Depends(get_db)\n                                        ) -> Credentials:\n    credentials = None\n\n    if not is_client_secret_none():  # if there is no client_secrets.json\n        flow = InstalledAppFlow.from_client_secrets_file(\n            client_secrets_file=CLIENT_SECRET_FILE,\n            scopes=SCOPES\n        )\n\n        flow.run_local_server(prompt='consent')\n        credentials = flow.credentials\n\n        push_credentials_to_db(\n            credentials=credentials, user=user, session=session\n        )\n\n        clean_up_old_credentials_from_db(session=session)\n\n    return credentials\n\n\ndef push_credentials_to_db(credentials: Credentials, user: User,\n                           session: SessionLocal = Depends(get_db)\n                           ) -> OAuthCredentials:\n\n    oauth_credentials = OAuthCredentials(\n        owner=user,\n        token=credentials.token,\n        refresh_token=credentials.refresh_token,\n        token_uri=credentials.token_uri,\n        client_id=credentials.client_id,\n        client_secret=credentials.client_secret,\n        expiry=credentials.expiry\n    )\n\n    session.add(oauth_credentials)\n    session.commit()\n    return credentials\n\n\ndef is_client_secret_none() -> bool:\n    return CLIENT_SECRET_FILE is None\n\n\ndef get_current_year_events(\n        credentials: Credentials, user: User,\n        session: SessionLocal = Depends(get_db)) -> list:\n    '''Getting user events from google calendar'''\n\n    current_year = datetime.now().year\n    start = datetime(current_year, 1, 1).isoformat() + 'Z'\n    end = datetime(current_year + 1, 1, 1).isoformat() + 'Z'\n\n    service = build('calendar', 'v3', credentials=credentials)\n    events_result = service.events().list(\n        calendarId='primary',\n        timeMin=start,\n        timeMax=end,\n        singleEvents=True,\n        orderBy='startTime'\n    ).execute()\n\n    events = events_result.get('items', [])\n    return events\n\n\ndef push_events_to_db(events: list, user: User,\n                      session: SessionLocal = Depends(get_db)) -> bool:\n    '''Adding google events to db'''\n    cleanup_user_google_calendar_events(user, session)\n\n    for event in events:\n        # Running over the events that have come from the API\n        title = event.get('summary')  # The Google event title\n\n        # support for all day events\n        if 'dateTime' in event['start']:\n            # This case handles part time events (not all day events)\n            start = datetime.fromisoformat(event['start']['dateTime'])\n            end = datetime.fromisoformat(event['end']['dateTime'])\n        else:\n            # This case handles all day events\n            start_in_str = event['start']['date']\n            start = datetime.strptime(start_in_str, '%Y-%m-%d')\n\n            end_in_str = event['end']['date']\n            end = datetime.strptime(end_in_str, '%Y-%m-%d')\n\n        # if Google Event has a location attached\n        location = event.get('location')\n\n        create_google_event(title, start, end, user, location, session)\n    return True\n\n\ndef create_google_event(title: str, start: datetime,\n                        end: datetime, user: User, location: str,\n                        session: SessionLocal = Depends(get_db)) -> Event:\n    return create_event(\n        # creating an event obj and pushing it into the db\n        db=session,\n        title=title,\n        start=start,\n        end=end,\n        owner_id=user.id,\n        location=location,\n        is_google_event=True\n    )\n\n\ndef cleanup_user_google_calendar_events(\n    user: User, session: SessionLocal = Depends(get_db)\n) -> bool:\n    '''removing all user google events so the next time will be syncronized'''\n\n    for user_event in user.events:\n        user_event_id = user_event.id\n        event = user_event.events\n        if event.is_google_event:\n            session.query(Event).filter_by(id=event.id).delete()\n            session.query(UserEvent).filter_by(id=user_event_id).delete()\n            session.commit()\n\n    return True\n\n\ndef get_credentials_from_db(user: User) -> Credentials:\n    '''bring user credential to use with google calendar api\n    and save the credential in the db'''\n\n    credentials = None\n\n    if user.oauth_credentials is not None:\n        db_credentials = user.oauth_credentials\n        credentials = Credentials(\n            token=db_credentials.token,\n            refresh_token=db_credentials.refresh_token,\n            token_uri=db_credentials.token_uri,\n            client_id=db_credentials.client_id,\n            client_secret=db_credentials.client_secret,\n            expiry=db_credentials.expiry\n        )\n\n    return credentials\n\n\ndef refresh_token(credentials: Credentials,\n                  user: User, session: SessionLocal = Depends(get_db)\n                  ) -> Credentials:\n\n    refreshed_credentials = credentials\n    if credentials.expired:\n        credentials.refresh(google_request())\n        refreshed_credentials = OAuthCredentials(\n            owner=user,\n            token=credentials.token,\n            refresh_token=credentials.refresh_token,\n            token_uri=credentials.token_uri,\n            client_id=credentials.client_id,\n            client_secret=credentials.client_secret,\n            expiry=credentials.expiry\n        )\n\n        session.add(refreshed_credentials)\n        session.commit()\n\n    return refreshed_credentials\n"}
{"type": "source_file", "path": "app/internal/translation.py", "content": "from typing import Optional\n\nfrom fastapi import HTTPException, status\nfrom iso639 import languages\nfrom loguru import logger\nfrom sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\nfrom sqlalchemy.orm.session import Session\nfrom textblob import download_corpora, TextBlob\nfrom textblob.exceptions import NotTranslated\n\nfrom app.database.models import Language\nfrom app.routers.user import get_users\n\ndownload_corpora.download_all()\n\n\ndef translate_text_for_user(text: str, session: Session, user_id: int) -> str:\n    \"\"\"Translates text to the user's language setting.\n\n    Args:\n        text: The text in the original language.\n        session: The database connection.\n        user_id: The User's ID.\n\n    Returns:\n        The translated text.\n    \"\"\"\n    target_lang = _get_user_language(user_id, session)\n    if not target_lang:\n        return text\n    return translate_text(text, target_lang)\n\n\ndef translate_text(text: str,\n                   target_lang: str,\n                   original_lang: Optional[str] = None,\n                   ) -> str:\n    \"\"\"Translates text to the target language.\n\n    Args:\n        text: The text in the original language.\n        target_lang: The language to translate the text into.\n        original_lang: Optional; The language of the text.\n\n    Returns:\n        The translated text.\n    \"\"\"\n    if not text.strip():\n        return \"\"\n    if original_lang is None:\n        language_code = _detect_text_language(text)\n    else:\n        language_code = _get_language_code(original_lang)\n\n    if language_code == _get_language_code(target_lang):\n        return text\n\n    try:\n        return str(TextBlob(text).translate(\n            from_lang=language_code,\n            to=_get_language_code(target_lang)))\n    except NotTranslated:\n        return text\n\n\ndef _get_user_language(user_id: int, session: Session) -> str:\n    \"\"\"Returns a user's language setting.\n\n    Args:\n        user_id: The User's ID.\n        session: The database connection.\n\n    Returns:\n        The language name.\n\n    Raises:\n        HTTPException: If no language or multiple languages were\n            found for the user.\n    \"\"\"\n    try:\n        user = get_users(session, id=user_id)[0]\n    except IndexError:\n        logger.exception(\"User was not found in the database.\")\n        return \"\"\n    try:\n        return _get_language_by_id(user.language_id, session)\n    except (AttributeError, MultipleResultsFound, NoResultFound) as e:\n        logger.critical(e)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail='Error raised',\n        )\n\n\ndef _detect_text_language(text: str) -> str:\n    \"\"\"Returns the language code of the language a given text is written in.\n\n    The language is found using TextBlot to detect the language.\n    TextBlot requires an internet connection.\n\n\n    Args:\n        text: The text in the original language.\n\n    Returns:\n        The language code of the language the text is written in.\n    \"\"\"\n    return str(TextBlob(text).detect_language())\n\n\ndef _get_language_code(language_name: str) -> str:\n    \"\"\"Returns a language code from its language name.\n\n    Args:\n        language_name: The language name.\n\n    Returns:\n        The language code.\n    \"\"\"\n    return languages.get(name=language_name.capitalize()).alpha2\n\n\ndef _get_language_by_id(language_id: int, session: Session) -> str:\n    \"\"\"Returns a language name from its ID.\n\n    Args:\n        language_id: The language ID.\n        session: The database connection.\n\n    Returns:\n        The language name.\n    \"\"\"\n    try:\n        language = session.query(Language.name).filter_by(id=language_id).one()\n    except (AttributeError, MultipleResultsFound, NoResultFound) as e:\n        logger.critical(e)\n        raise AttributeError(e)\n    return language.name\n"}
{"type": "source_file", "path": "app/routers/calendar_grid.py", "content": "import calendar\nfrom datetime import date, datetime, timedelta\nimport itertools\nimport locale\nfrom typing import Dict, Iterator, List, Tuple\n\nimport pytz\n\nMONTH_BLOCK: int = 6\n\nlocale.setlocale(locale.LC_ALL, \"en_US.UTF-8\")\n\n\nclass Day:\n    \"\"\"A Day class.\n\n    Args:\n        date    (datetime): A single datetime date.\n    Arguments:\n        date    (datetime): A single datetime date.\n        sday         (str): The day name.\n        dailyevents (List): List of tuples represent daily event information.\n                            EX:  [(\"Front Info\", \"Back Info\")]\n        events      (List): List of tuples represent time event name.\n                            EX: [(\"09AP\", \"Meeting with yam\")]\n        css         (Dict): All css classes represent day.\n    \"\"\"\n\n    def __init__(self, date: datetime):\n        self.date: datetime = date\n        self.sday: str = self.date.strftime(\"%A\")\n        self.dailyevents: List[Tuple] = []\n        self.events: List[Tuple] = []\n        self.css: Dict[str, str] = {\n            'day_container': 'day',\n            'date': 'day-number',\n            'daily_event': 'month-event',\n            'daily_event_front': ' '.join([\n                'daily',\n                'front',\n                'background-warmyellow'\n            ]),\n            'daily_event_back': ' '.join([\n                'daily',\n                'back',\n                'text-darkblue',\n                'background-lightgray'\n            ]),\n            'event': 'event',\n        }\n\n    def __str__(self) -> str:\n        return self.date.strftime(\"%d\")\n\n    def display(self) -> str:\n        \"\"\"Returns day date inf the format of 00 MONTH 00\"\"\"\n        return self.date.strftime(\"%d %B %y\").upper()\n\n    def set_id(self) -> str:\n        \"\"\"Returns day date inf the format of 00-month-0000\"\"\"\n        return self.date.strftime(\"%d-%B-%Y\")\n\n    @classmethod\n    def get_user_local_time(cls) -> datetime:\n        greenwich = pytz.timezone('GB')\n        return greenwich.localize(datetime.now())\n\n    @classmethod\n    def convert_str_to_date(cls, date_string: str) -> datetime:\n        return datetime.strptime(date_string, '%d-%B-%Y')\n\n    @classmethod\n    def is_weekend(cls, date: date) -> bool:\n        \"\"\"Returns true if this day is represent a weekend.\"\"\"\n        return date.strftime(\"%A\") in Week.DAYS_OF_THE_WEEK[-2:]\n\n\nclass DayWeekend(Day):\n    def __init__(self, date: datetime):\n        super().__init__(date)\n        self.css = {\n            'day_container': 'day ',\n            'date': ' '.join(['day-number', 'text-gray']),\n            'daily_event': 'month-event',\n            'daily_event_front': ' '.join([\n                'daily',\n                'front',\n                'background-warmyellow'\n            ]),\n            'daily_event_back': ' '.join([\n                'daily',\n                'back',\n                'text-darkblue',\n                'background-lightgray'\n            ]),\n            'event': 'event',\n        }\n\n\nclass Today(Day):\n    def __init__(self, date: datetime):\n        super().__init__(date)\n        self.css = {\n            'day_container': ' '.join([\n                'day',\n                'text-darkblue',\n                'background-yellow'\n            ]),\n            'date': 'day-number',\n            'daily_event': 'month-event',\n            'daily_event_front': ' '.join([\n                'daily',\n                'front',\n                'text-lightgray',\n                'background-darkblue'\n            ]),\n            'daily_event_back': ' '.join([\n                'daily',\n                'back',\n                'text-darkblue',\n                'background-lightgray'\n            ]),\n            'event': 'event',\n        }\n\n\nclass FirstDayMonth(Day):\n    def __init__(self, date: datetime):\n        super().__init__(date)\n        self.css = {\n            'day_container': ' '.join([\n                'day',\n                'text-darkblue',\n                'background-lightgray'\n            ]),\n            'date': 'day-number',\n            'daily_event': 'month-event',\n            'daily_event_front': ' '.join([\n                'daily front',\n                'text-lightgray',\n                'background-red'\n            ]),\n            'daily_event_back': ' '.join([\n                'daily',\n                'back',\n                'text-darkblue',\n                'background-lightgray'\n            ]),\n            'event': 'event',\n        }\n\n    def __str__(self) -> str:\n        return self.date.strftime(\"%d %b %y\").upper()\n\n\nclass Week:\n    WEEK_DAYS: int = 7\n    DAYS_OF_THE_WEEK: List[str] = calendar.day_name\n\n    def __init__(self, days: List[Day]):\n        self.days: List[Day] = days\n\n\ndef create_day(day: datetime) -> Day:\n    \"\"\"Return the currect day object according to given date.\"\"\"\n    if day == date.today():\n        return Today(day)\n    if int(day.day) == 1:\n        return FirstDayMonth(day)\n    if Day.is_weekend(day):\n        return DayWeekend(day)\n    return Day(day)\n\n\ndef get_next_date(date: datetime) -> Iterator[Day]:\n    \"\"\"Generate date objects from a starting given date.\"\"\"\n    yield from (\n        create_day(date + timedelta(days=i))\n        for i in itertools.count(start=1)\n    )\n\n\ndef get_date_before_n_days(date: datetime, n: int) -> datetime:\n    \"\"\"Returns the date before n days.\"\"\"\n    return date - timedelta(days=n)\n\n\ndef get_first_day_month_block(date: datetime) -> datetime:\n    \"\"\"Returns the first date in a month block of given date.\"\"\"\n    return list(calendar.Calendar().itermonthdates(date.year, date.month))[0]\n\n\ndef get_n_days(date: datetime, n: int) -> Iterator[Day]:\n    \"\"\"Generate n dates from a starting given date.\"\"\"\n    next_date_gen = get_next_date(date)\n    yield from itertools.islice(next_date_gen, n)\n\n\ndef create_weeks(\n        days: Iterator[Day],\n        length: int = Week.WEEK_DAYS\n) -> List[Week]:\n    \"\"\"Return lists of Weeks objects.\"\"\"\n    ndays: List[Day] = list(days)\n    num_days: int = len(ndays)\n    return [Week(ndays[i:i + length]) for i in range(0, num_days, length)]\n\n\ndef get_month_block(day: Day, n: int = MONTH_BLOCK) -> List[Week]:\n    \"\"\"Returns a 2D list represent a n days calendar from current month.\"\"\"\n    current = get_first_day_month_block(day.date) - timedelta(days=1)\n    num_of_days = Week.WEEK_DAYS * n\n    return create_weeks(get_n_days(current, num_of_days))\n"}
{"type": "source_file", "path": "app/internal/week.py", "content": ""}
{"type": "source_file", "path": "app/internal/security/schema.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass CurrentUser(BaseModel):\n    \"\"\"\n    Validating fields types\n    Returns a user details as a class.\n    \"\"\"\n    user_id: Optional[int]\n    username: str\n\n    class Config:\n        orm_mode = True\n\n\nclass LoginUser(CurrentUser):\n    \"\"\"\n    Validating fields types\n    Returns a User object for signing in.\n    \"\"\"\n    is_manager: Optional[bool]\n    password: str\n"}
{"type": "source_file", "path": "app/routers/event_images.py", "content": "from functools import lru_cache\nimport re\nfrom typing import Optional\n\nfrom nltk.tokenize import word_tokenize\nfrom word_forms.lemmatizer import lemmatize\n\nfrom app import config\n\nFLAIRS_EXTENSION = '.jpg'\nFLAIRS_REL_PATH = f'{config.STATIC_ABS_PATH}\\\\event_flairs'\nIMAGES_RELATED_WORDS_MAP = {\n    'birthday': 'birthday',\n    'coffee': 'coffee',\n    'coffees': 'coffee',\n    'concert': 'concert',\n    'gig': 'concert',\n    'concerts': 'concert',\n    'gigs': 'concert',\n    'bicycle': 'cycle',\n    'cycling': 'cycle',\n    'bike': 'cycle',\n    'bicycles': 'cycle',\n    'bikes': 'cycle',\n    'biking': 'cycle',\n    'dentist': 'dentist',\n    'dentistry': 'dentist',\n    'dental': 'dentist',\n    'dinner': 'food',\n    'dinners': 'food',\n    'restaurant': 'food',\n    'restaurants': 'food',\n    'family meal': 'food',\n    'lunch': 'food',\n    'lunches': 'food',\n    'luncheon': 'food',\n    'cocktail': 'drank',\n    'drinks': 'drank',\n    'cocktails': 'drank',\n    'golf': 'golf',\n    'graduation': 'graduate',\n    'gym': 'gym',\n    'workout': 'gym',\n    'workouts': 'gym',\n    'haircut': 'haircut',\n    'hair': 'haircut',\n    'halloween': 'halloween',\n    'helloween': 'halloween',\n    \"hallowe'en\": 'halloween',\n    'allhalloween': 'halloween',\n    \"all hallows' eve\": 'halloween',\n    \"all saints' Eve\": 'halloween',\n    'hiking': 'hike',\n    'hike': 'hike',\n    'hikes': 'hike',\n    'kayaking': 'kayak',\n    'piano': 'music',\n    'singing': 'music',\n    'music class': 'music',\n    'choir practice': 'music',\n    'flute': 'music',\n    'orchestra': 'music',\n    'oboe': 'music',\n    'clarinet': 'music',\n    'saxophone': 'music',\n    'cornett': 'music',\n    'trumpet': 'music',\n    'contrabass': 'music',\n    'cello': 'music',\n    'trombone': 'music',\n    'tuba': 'music',\n    'music ensemble': 'music',\n    'string quartett': 'music',\n    'guitar lesson': 'music',\n    'classical music': 'music',\n    'choir': 'music',\n    'manicure': 'manicure',\n    'pedicure': 'manicure',\n    'manicures': 'manicure',\n    'pedicures': 'manicure',\n    'massage': 'massage',\n    'back rub': 'massage',\n    'backrub': 'massage',\n    'massages': 'massage',\n    'pills': 'pill',\n    'medicines': 'pill',\n    'medicine': 'pill',\n    'drug': 'pill',\n    'drugs': 'pill',\n    'ping pong': 'pingpong',\n    'table tennis': 'pingpong',\n    'ping-pong': 'pingpong',\n    'pingpong': 'pingpong',\n    'plan week': 'plan',\n    'plan quarter': 'plan',\n    'plan day': 'plan',\n    'plan vacation': 'plan',\n    'week planning': 'plan',\n    'vacation planning': 'plan',\n    'pokemon': 'pokemon',\n    'reading': 'read',\n    'newspaper': 'read',\n    'fridge repair': 'repair',\n    'handyman': 'repair',\n    'electrician': 'repair',\n    'diy': 'repair',\n    'jog': 'ran',\n    'jogging': 'ran',\n    'running': 'ran',\n    'jogs': 'ran',\n    'runs': 'ran',\n    'sail': 'sail',\n    'sailing': 'sail',\n    'boat cruise': 'sail',\n    'sailboat': 'sail',\n    'santa claus': 'santa',\n    'father christmas': 'santa',\n    'skiing': 'ski',\n    'ski': 'ski',\n    'skis': 'ski',\n    'snowboarding': 'ski',\n    'snowshoeing': 'ski',\n    'snow shoe': 'ski',\n    'snow boarding': 'ski',\n    'soccer': 'soccer',\n    'swim': 'swam',\n    'swimming': 'swam',\n    'swims': 'swam',\n    'tennis': 'tennis',\n    'thanksgiving': 'thanksgiving',\n    'wedding': 'wed',\n    'wedding eve': 'wed',\n    'wedding-eve party': 'wed',\n    'weddings': 'wed',\n    'christmas': 'christmas',\n    'xmas': 'christmas',\n    'x-mas': 'christmas',\n    'yoga': 'yoga',\n}\n\n\ndef generate_flare_link_from_lemmatized_word(lemmatized_word: str) -> str:\n    \"\"\"Generate a link to a flair by a given lemmatized word.\n\n    Args:\n        lemmatized_word (str): The lemmatized word.\n\n    Returns:\n        str: The suitable link.\n    \"\"\"\n    return f'{FLAIRS_REL_PATH}\\\\{lemmatized_word}{FLAIRS_EXTENSION}'\n\n\ndef remove_non_alphabet_chars(text: str) -> str:\n    \"\"\"Remove non-alphabet chars from a given string\n\n    Args:\n        text (str): The string to remove the non-alphabet chars from.\n\n    Returns:\n        str: The string after the removal.\n    \"\"\"\n    regex = re.compile('[^a-zA-Z]')\n    return regex.sub('', text)\n\n\ndef get_image_name(related_word: str) -> Optional[str]:\n    \"\"\"Search the key of a given value in IMAGES_RELATED_WORDS_MAP dictionary.\n\n    Args:\n        related_word (str): The value to search its key.\n\n    Returns:\n        str: The value's key in IMAGES_RELATED_WORDS_MAP dictionary.\n    \"\"\"\n    shrunken = remove_non_alphabet_chars(related_word).lower()\n    return IMAGES_RELATED_WORDS_MAP.get(shrunken)\n\n\n@lru_cache(maxsize=32)\ndef search_token_in_related_words(token: str) -> Optional[str]:\n    \"\"\"Search a token in IMAGES_RELATED_WORDS_MAP dictionary.\n\n    Args:\n        token (str): The token to search.\n\n    Returns:\n        str: The link to the suitable image of the given token.\n    \"\"\"\n    key = get_image_name(token)\n    if key:\n        return generate_flare_link_from_lemmatized_word(key)\n\n\ndef attach_image_to_event(event_content: str) -> str:\n    \"\"\"Get a link to the suitable image of a given token content.\n\n    Args:\n        event_content (str): The event content.\n\n    Returns:\n        str: The link to the suitable image of a given token content.\n    \"\"\"\n    event_tokens = word_tokenize(event_content)\n    for token in event_tokens:\n        if token.isalnum():\n            try:\n                base_word = lemmatize(remove_non_alphabet_chars(token).lower())\n            except ValueError:\n                base_word = token\n            if base_word in IMAGES_RELATED_WORDS_MAP.values():\n                return generate_flare_link_from_lemmatized_word(base_word)\n            link = search_token_in_related_words(token)\n            if link:\n                return link\n            link = '#'\n    return link\n"}
{"type": "source_file", "path": "app/internal/utils.py", "content": "from typing import Any, List, Optional\n\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Base, User\n\n\ndef save(session: Session, instance: Base) -> bool:\n    \"\"\"Commits an instance to the db.\n    source: app.database.models.Base\"\"\"\n    if issubclass(instance.__class__, Base):\n        session.add(instance)\n        session.commit()\n        return True\n    return False\n\n\ndef create_model(session: Session, model_class: Base, **kwargs: Any) -> Base:\n    \"\"\"Creates and saves a db model.\"\"\"\n    instance = model_class(**kwargs)\n    save(session, instance)\n    return instance\n\n\ndef delete_instance(session: Session, instance: Base) -> None:\n    \"\"\"Deletes an instance from the db.\"\"\"\n    session.delete(instance)\n    session.commit()\n\n\ndef get_current_user(session: Session) -> User:\n    \"\"\"Mock function for current user information retrival.\"\"\"\n    # Code revision required after user login feature is added\n    new_user = get_placeholder_user()\n    user = session.query(User).first()\n    if not user:\n        save(session, new_user)\n        user = session.query(User).first()\n\n    return user\n\n\ndef get_available_users(session: Session) -> List[User]:\n    \"\"\"this function return all availible users.\"\"\"\n    return session.query(User).filter(not User.disabled).all()\n\n\ndef get_user(session: Session, user_id: int) -> Optional[User]:\n    \"\"\"Returns User instance for `user_id` if exists, None otherwise.\n\n    Args:\n        session (Session): DB session.\n        user_id (int): ID of user to return.\n\n    Returns:\n        (User | None): User instance for `user_id` if exists, None otherwise.\n    \"\"\"\n    return session.query(User).filter_by(id=user_id).first()\n\n\ndef get_placeholder_user() -> User:\n    \"\"\"Creates a mock user.\n\n    This is a temporarily function which should be removed when a\n    real system is created.\n\n    Returns:\n        A User object.\n    \"\"\"\n    return User(\n        username='new_user',\n        email='my@email.po',\n        password='1a2s3d4f5g6',\n        full_name='My Name',\n        language_id=1,\n        telegram_id='',\n    )\n"}
{"type": "source_file", "path": "app/routers/currency.py", "content": "import datetime\n\nfrom fastapi import APIRouter, Request\n\nfrom app.dependencies import templates\n\nrouter = APIRouter()\n\n\n# TODO: Add this as a feature to the calendar view/\n#           day view/features panel frontend\n\n\n@router.get(\"/currency\")\ndef today_currency(request: Request):\n    \"\"\"Current day currency router\"\"\"\n\n    date = datetime.date.today().strftime(\"%Y-%m-%d\")\n    return currency(request, date)\n\n\n@router.get(\"/currency/{date}\")\ndef currency(request: Request, date: str):\n    \"\"\"Custom date currency router\"\"\"\n\n    # TODO: get user default/preferred currency\n    base = \"USD\"\n\n    return templates.TemplateResponse(\"currency.html\", {\n        \"request\": request,\n        \"base\": base,\n        \"date\": date\n    })\n"}
{"type": "source_file", "path": "app/internal/security/dependancies.py", "content": "from fastapi import Depends, HTTPException\nfrom starlette.status import HTTP_401_UNAUTHORIZED\nfrom starlette.requests import Request\n\nfrom app.database.models import User\nfrom app.dependencies import get_db\nfrom app.internal.security.ouath2 import (\n    Session, get_jwt_token, get_authorization_cookie\n)\nfrom app.internal.security import schema\n\n\nasync def is_logged_in(\n    request: Request, db: Session = Depends(get_db),\n        jwt: str = Depends(get_authorization_cookie)) -> bool:\n    \"\"\"\n    A dependency function protecting routes for only logged in user\n    \"\"\"\n    await get_jwt_token(db, jwt)\n    return True\n\n\nasync def is_manager(\n    request: Request, db: Session = Depends(get_db),\n        jwt: str = Depends(get_authorization_cookie)) -> bool:\n    \"\"\"\n    A dependency function protecting routes for only logged in manager\n    \"\"\"\n    jwt_payload = await get_jwt_token(db, jwt)\n    if jwt_payload.get(\"is_manager\"):\n        return True\n    raise HTTPException(\n                status_code=HTTP_401_UNAUTHORIZED,\n                headers=request.url.path,\n                detail=\"You don't have a permition to enter this page\")\n\n\nasync def current_user_from_db(\n    request: Request,\n    db: Session = Depends(get_db),\n    jwt: str = Depends(get_authorization_cookie),\n) -> User:\n    \"\"\"\n    Returns logged in User object.\n    A dependency function protecting routes for only logged in user.\n    \"\"\"\n    jwt_payload = await get_jwt_token(db, jwt)\n    username = jwt_payload.get(\"sub\")\n    user_id = jwt_payload.get(\"user_id\")\n    db_user = await User.get_by_username(db, username=username)\n    if db_user and db_user.id == user_id:\n        return db_user\n    else:\n        raise HTTPException(\n                status_code=HTTP_401_UNAUTHORIZED,\n                headers=request.url.path,\n                detail=\"Your token is incorrect. Please log in again\")\n\n\nasync def current_user(\n    request: Request,\n    db: Session = Depends(get_db),\n    jwt: str = Depends(get_authorization_cookie),\n) -> schema:\n    \"\"\"\n    Returns logged in User object.\n    A dependency function protecting routes for only logged in user.\n    \"\"\"\n    jwt_payload = await get_jwt_token(db, jwt)\n    username = jwt_payload.get(\"sub\")\n    user_id = jwt_payload.get(\"user_id\")\n    return schema.CurrentUser(user_id=user_id, username=username)\n"}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import Depends, FastAPI, Request, status\nfrom fastapi.openapi.docs import (\n    get_swagger_ui_html,\n    get_swagger_ui_oauth2_redirect_html,\n)\nfrom fastapi.staticfiles import StaticFiles\nfrom sqlalchemy.orm import Session\n\nfrom app import config\nfrom app.database import engine, models\nfrom app.dependencies import get_db, logger, MEDIA_PATH, STATIC_PATH, templates\nfrom app.internal import daily_quotes, json_data_loader\nfrom app.internal.languages import set_ui_language\nfrom app.internal.security.ouath2 import auth_exception_handler\nfrom app.routers.salary import routes as salary\nfrom app.utils.extending_openapi import custom_openapi\n\n\ndef create_tables(engine, psql_environment):\n    if 'sqlite' in str(engine.url) and psql_environment:\n        raise models.PSQLEnvironmentError(\n            \"You're trying to use PSQL features on SQLite env.\\n\"\n            \"Please set app.config.PSQL_ENVIRONMENT to False \"\n            \"and run the app again.\"\n        )\n    else:\n        models.Base.metadata.create_all(bind=engine)\n\n\ncreate_tables(engine, config.PSQL_ENVIRONMENT)\n\napp = FastAPI(title=\"Pylander\", docs_url=None)\napp.mount(\"/static\", StaticFiles(directory=STATIC_PATH), name=\"static\")\napp.mount(\"/media\", StaticFiles(directory=MEDIA_PATH), name=\"media\")\napp.logger = logger\n\napp.add_exception_handler(status.HTTP_401_UNAUTHORIZED, auth_exception_handler)\n\n# This MUST come before the app.routers imports.\nset_ui_language()\n\nfrom app.routers import (  # noqa: E402\n    about_us, agenda, calendar, categories, celebrity, credits,\n    currency, dayview, email, event, export, four_o_four, friendview,\n    google_connect, invitation, login, logout, profile,\n    register, search, telegram, user, weekview, whatsapp,\n)\n\njson_data_loader.load_to_database(next(get_db()))\n\n\n@app.get(\"/docs\", include_in_schema=False)\nasync def custom_swagger_ui_html():\n    return get_swagger_ui_html(\n        openapi_url=app.openapi_url,\n        title=app.title + \" - Swagger UI\",\n        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,\n        swagger_js_url=\"/static/swagger/swagger-ui-bundle.js\",\n        swagger_css_url=\"/static/swagger/swagger-ui.css\",\n    )\n\n\n@app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)\nasync def swagger_ui_redirect():\n    return get_swagger_ui_oauth2_redirect_html()\n\n\nrouters_to_include = [\n    about_us.router,\n    agenda.router,\n    calendar.router,\n    categories.router,\n    celebrity.router,\n    credits.router,\n    currency.router,\n    dayview.router,\n    friendview.router,\n    weekview.router,\n    email.router,\n    event.router,\n    export.router,\n    four_o_four.router,\n    google_connect.router,\n    invitation.router,\n    login.router,\n    logout.router,\n    profile.router,\n    register.router,\n    salary.router,\n    search.router,\n    telegram.router,\n    user.router,\n    whatsapp.router,\n]\n\nfor router in routers_to_include:\n    app.include_router(router)\n\n\n# TODO: I add the quote day to the home page\n# until the relevant calendar view will be developed.\n@app.get(\"/\", include_in_schema=False)\n@logger.catch()\nasync def home(request: Request, db: Session = Depends(get_db)):\n    quote = daily_quotes.get_quote_of_day(db)\n    return templates.TemplateResponse(\"index.html\", {\n        \"request\": request,\n        \"quote\": quote,\n    })\n\n\ncustom_openapi(app)\n"}
{"type": "source_file", "path": "app/routers/dayview.py", "content": "from bisect import bisect_left\nfrom datetime import datetime, timedelta\nfrom typing import Iterator, Optional, Tuple, Union\n\nfrom fastapi import APIRouter, Depends, HTTPException, Request, status\n\nfrom app.database.models import Event, User\nfrom app.dependencies import get_db, templates\nfrom app.internal import zodiac\nfrom app.routers.user import get_all_user_events\n\nrouter = APIRouter()\n\n\nclass DivAttributes:\n    GRID_BAR_QUARTER = 1\n    FULL_GRID_BAR = 4\n    MIN_MINUTES = 0\n    MAX_MINUTES = 15\n    BASE_GRID_BAR = 3\n    FIRST_GRID_BAR = 1\n    LAST_GRID_BAR = 101\n    DEFAULT_COLOR = \"grey\"\n    DEFAULT_FORMAT = \"%H:%M\"\n    MULTIDAY_FORMAT = \"%d/%m %H:%M\"\n    CLASS_SIZES = (\"title-size-tiny\", \"title-size-xsmall\", \"title-size-small\")\n    LENGTH_SIZE_STEP = (30, 45, 90)\n\n    def __init__(\n        self,\n        event: Event,\n        day: Union[bool, datetime] = False,\n    ) -> None:\n        self.start_time = event.start\n        self.end_time = event.end\n        self.day = day\n        self.start_multiday, self.end_multiday = self._check_multiday_event()\n        self.color = self._check_color(event.color)\n        self.total_time = self._set_total_time()\n        self.total_time_visible = self._set_total_time_visiblity()\n        self.title_size_class = self._set_title_size()\n        self.grid_position = self._set_grid_position()\n\n    def _check_color(self, color: str) -> str:\n        if color is None:\n            return self.DEFAULT_COLOR\n        return color\n\n    def _minutes_position(self, minutes: int) -> Union[int, None]:\n        min_minutes = self.MIN_MINUTES\n        max_minutes = self.MAX_MINUTES\n        for i in range(self.GRID_BAR_QUARTER, self.FULL_GRID_BAR + 1):\n            if min_minutes < minutes <= max_minutes:\n                return i\n            min_minutes = max_minutes\n            max_minutes += 15\n        return None\n\n    def _get_position(self, time: datetime) -> int:\n        grid_hour_position = time.hour * self.FULL_GRID_BAR\n        grid_minutes_modifier = self._minutes_position(time.minute)\n        if grid_minutes_modifier is None:\n            grid_minutes_modifier = 0\n        return grid_hour_position + grid_minutes_modifier + self.BASE_GRID_BAR\n\n    def _set_grid_position(self) -> str:\n        if self.start_multiday:\n            start = self.FIRST_GRID_BAR\n        else:\n            start = self._get_position(self.start_time)\n        if self.end_multiday:\n            end = self.LAST_GRID_BAR\n        else:\n            end = self._get_position(self.end_time)\n        return f\"{start} / {end}\"\n\n    def _get_time_format(self) -> Iterator[str]:\n        for multiday in [self.start_multiday, self.end_multiday]:\n            yield self.MULTIDAY_FORMAT if multiday else self.DEFAULT_FORMAT\n\n    def _set_total_time(self) -> str:\n        length = self.end_time - self.start_time\n        self.length = length.seconds / 60\n        format_gen = self._get_time_format()\n        start_time_str = self.start_time.strftime(next(format_gen))\n        end_time_str = self.end_time.strftime(next(format_gen))\n        return \" \".join([start_time_str, \"-\", end_time_str])\n\n    def _set_total_time_visiblity(self) -> bool:\n        return self.length > 60\n\n    def _set_title_size(self) -> Optional[str]:\n        i = bisect_left(self.LENGTH_SIZE_STEP, self.length)\n        if i < len(self.CLASS_SIZES):\n            return self.CLASS_SIZES[i]\n\n    def _check_multiday_event(self) -> Tuple[bool, bool]:\n        start_multiday, end_multiday = False, False\n        if self.day:\n            if self.start_time < self.day:\n                start_multiday = True\n            self.day += timedelta(hours=24)\n            if self.day <= self.end_time:\n                end_multiday = True\n        return (start_multiday, end_multiday)\n\n\ndef is_specific_time_event_in_day(\n    event: Event,\n    day: datetime,\n    day_end: datetime,\n) -> bool:\n    if event.all_day:\n        return False\n    return bool(\n        (event.start >= day and event.start < day_end)\n        or (event.end >= day and event.end < day_end)\n        or (event.start < day_end < event.end),\n    )\n\n\ndef is_all_day_event_in_day(\n    event: Event,\n    day: datetime,\n    day_end: datetime,\n) -> bool:\n    if not event.all_day:\n        return False\n    return bool(\n        (event.start >= day and event.start < day_end)\n        or (event.end >= day and event.end < day_end)\n        or (event.start < day_end < event.end),\n    )\n\n\ndef get_events_and_attributes(\n    day: datetime,\n    session,\n    user_id: int,\n) -> Iterator[Tuple[Event, DivAttributes]]:\n    events = get_all_user_events(session, user_id)\n    day_end = day + timedelta(hours=24)\n    for event in events:\n        if is_specific_time_event_in_day(event, day, day_end):\n            yield event, DivAttributes(event, day)\n\n\ndef get_all_day_events(\n    day: datetime,\n    session,\n    user_id: int,\n) -> Iterator[Event]:\n    events = get_all_user_events(session, user_id)\n    day_end = day + timedelta(hours=24)\n    for event in events:\n        if is_all_day_event_in_day(event=event, day=day, day_end=day_end):\n            yield (event)\n\n\n@router.get(\"/day/{date}\", include_in_schema=False)\nasync def dayview(\n    request: Request,\n    date: str,\n    session=Depends(get_db),\n    view=\"day\",\n):\n    # TODO: add a login session\n    user = session.query(User).filter_by(username=\"test_username\").first()\n    if not user:\n        error_message = \"User not found.\"\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=error_message,\n        )\n    try:\n        day = datetime.strptime(date, \"%Y-%m-%d\")\n    except ValueError as err:\n        raise HTTPException(status_code=404, detail=f\"{err}\")\n    zodiac_obj = zodiac.get_zodiac_of_day(session, day)\n    events_n_attrs = get_events_and_attributes(\n        day=day,\n        session=session,\n        user_id=user.id,\n    )\n    all_day_events = get_all_day_events(\n        day=day,\n        session=session,\n        user_id=user.id,\n    )\n    month = day.strftime(\"%B\").upper()\n    return templates.TemplateResponse(\n        \"calendar_day_view.html\",\n        {\n            \"request\": request,\n            \"events\": events_n_attrs,\n            \"all_day_events\": all_day_events,\n            \"month\": month,\n            \"day\": day.day,\n            \"zodiac\": zodiac_obj,\n            \"view\": view,\n        },\n    )\n"}
{"type": "source_file", "path": "app/routers/agenda.py", "content": "from collections import defaultdict\nfrom datetime import date, timedelta\nfrom typing import Optional, Tuple\n\nfrom fastapi import APIRouter, Depends, Request\nfrom sqlalchemy.orm import Session\nfrom starlette.templating import _TemplateResponse\n\nfrom app.dependencies import get_db, templates\nfrom app.internal import agenda_events\n\nrouter = APIRouter()\n\n\ndef calc_dates_range_for_agenda(\n        start: Optional[date],\n        end: Optional[date],\n        days: Optional[int],\n) -> Tuple[date, date]:\n    \"\"\"Create start and end dates according to the parameters in the page.\"\"\"\n    if days is not None:\n        start = date.today()\n        end = start + timedelta(days=days)\n    elif start is None or end is None:\n        start = date.today()\n        end = date.today()\n    return start, end\n\n\n@router.get(\"/agenda\", include_in_schema=False)\ndef agenda(\n        request: Request,\n        db: Session = Depends(get_db),\n        start_date: Optional[date] = None,\n        end_date: Optional[date] = None,\n        days: Optional[int] = None,\n) -> _TemplateResponse:\n    \"\"\"Route for the agenda page, using dates range or exact amount of days.\"\"\"\n\n    user_id = 1  # there is no user session yet, so I use user id- 1.\n    start_date, end_date = calc_dates_range_for_agenda(\n        start_date, end_date, days\n    )\n\n    events_objects = agenda_events.get_events_per_dates(\n        db, user_id, start_date, end_date\n    )\n    events = defaultdict(list)\n    for event_obj in events_objects:\n        event_duration = agenda_events.get_time_delta_string(\n            event_obj.start, event_obj.end\n        )\n        events[event_obj.start.date()].append((event_obj, event_duration))\n\n    return templates.TemplateResponse(\"agenda.html\", {\n        \"request\": request,\n        \"events\": events,\n        \"start_date\": start_date,\n        \"end_date\": end_date,\n    })\n"}
{"type": "source_file", "path": "app/routers/calendar.py", "content": "from http import HTTPStatus\n\nfrom fastapi import APIRouter, Request\nfrom fastapi.responses import HTMLResponse\nfrom starlette.responses import Response\n\nfrom app.dependencies import templates\nfrom app.routers import calendar_grid as cg\n\nrouter = APIRouter(\n    prefix=\"/calendar/month\",\n    tags=[\"calendar\"],\n    responses={404: {\"description\": \"Not found\"}},\n    include_in_schema=False\n)\n\n\n@router.get(\"/\")\nasync def calendar(request: Request) -> Response:\n    user_local_time = cg.Day.get_user_local_time()\n    day = cg.create_day(user_local_time)\n    return templates.TemplateResponse(\n        \"calendar_monthly_view.html\",\n        {\n            \"request\": request,\n            \"day\": day,\n            \"week_days\": cg.Week.DAYS_OF_THE_WEEK,\n            \"weeks_block\": cg.get_month_block(day)\n        }\n    )\n\n\n@router.get(\"/add/{date}\")\nasync def update_calendar(\n    request: Request, date: str, days: int\n) -> HTMLResponse:\n    last_day = cg.Day.convert_str_to_date(date)\n    next_weeks = cg.create_weeks(cg.get_n_days(last_day, days))\n    template = templates.get_template(\n        'partials/calendar/monthly_view/add_week.html')\n    content = template.render(weeks_block=next_weeks)\n    return HTMLResponse(content=content, status_code=HTTPStatus.OK)\n"}
{"type": "source_file", "path": "app/internal/security/__init__.py", "content": ""}
{"type": "source_file", "path": "app/routers/export.py", "content": "from datetime import date\nfrom io import BytesIO\nfrom typing import Union\n\nfrom fastapi import APIRouter, Depends, status\nfrom fastapi.responses import StreamingResponse\nfrom sqlalchemy.orm import Session\n\nfrom app.dependencies import get_db\nfrom app.internal.agenda_events import get_events_in_time_frame\nfrom app.internal.export import get_icalendar_with_multiple_events\nfrom app.internal.utils import get_current_user\n\nrouter = APIRouter(\n    prefix=\"/export\",\n    tags=[\"export\"],\n    responses={status.HTTP_404_NOT_FOUND: {\"description\": _(\"Not found\")}},\n)\n\n\n@router.get(\"/\")\ndef export(\n        start_date: Union[date, str],\n        end_date: Union[date, str],\n        db: Session = Depends(get_db),\n) -> StreamingResponse:\n    \"\"\"Returns the Export page route.\n\n    Args:\n        start_date: A date or an empty string.\n        end_date: A date or an empty string.\n        db: Optional; The database connection.\n\n    Returns:\n        # TODO add description\n    \"\"\"\n    # TODO: connect to real user\n    user = get_current_user(db)\n    events = get_events_in_time_frame(start_date, end_date, user.id, db)\n    file = BytesIO(get_icalendar_with_multiple_events(db, list(events)))\n    return StreamingResponse(\n        content=file,\n        media_type=\"text/calendar\",\n        headers={\n            # Change filename to \"pylandar.ics\".\n            \"Content-Disposition\": \"attachment;filename=pylandar.ics\",\n        },\n    )\n"}
{"type": "source_file", "path": "app/routers/about_us.py", "content": "from fastapi import APIRouter, Request\n\nfrom app.dependencies import templates\n\n\nrouter = APIRouter()\n\n\n@router.get(\"/about\")\ndef about(request: Request):\n    return templates.TemplateResponse(\"about_us.html\", {\n        \"request\": request,\n    })\n"}
{"type": "source_file", "path": "app/routers/email.py", "content": "from fastapi import APIRouter, BackgroundTasks, Depends, Form, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic.errors import EmailError\nfrom sqlalchemy.orm.session import Session\nfrom starlette.responses import RedirectResponse\n\nfrom app.dependencies import get_db\nfrom app.internal.email import send as internal_send\nfrom app.internal.email import send_email_invitation\n\nrouter = APIRouter(\n    prefix=\"/email\",\n    tags=[\"email\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n\n\n@router.post(\"/send\")\nasync def send(\n        db: Session = Depends(get_db),\n        send_to: str = \"/\",\n        title: str = Form(...),\n        event_used: str = Form(...),\n        user_to_send: str = Form(...),\n        background_tasks: BackgroundTasks = BackgroundTasks\n) -> RedirectResponse:\n    if not internal_send(\n            title=title, event_used=event_used,\n            user_to_send=user_to_send,\n            background_tasks=background_tasks, session=db):\n        raise HTTPException(status_code=404, detail=\"Couldn't send the email!\")\n    return RedirectResponse(send_to, status_code=303)\n\n\nINVALID_EMAIL_ADDRESS_ERROR_MESSAGE = \"Please enter valid email address\"\nSUCCESSFULLY_SENT_EMAIL_MESSAGE = \"Your message was sent successfully\"\n\n\nclass InvitationParams(BaseModel):\n    send_to: str = \"/\"\n    sender_name: str\n    recipient_name: str\n    recipient_mail: str\n\n\n@router.post(\"/invitation/\")\ndef send_invitation(invitation: InvitationParams,\n                    background_task: BackgroundTasks):\n    \"\"\"\n    This function sends the recipient an invitation\n    to his email address in the format HTML.\n    :param invitation: InvitationParams, invitation parameters\n    :param background_task: BackgroundTasks\n    :return: json response message,\n    error message if the entered email address is incorrect,\n    confirmation message if the invitation was successfully sent\n    \"\"\"\n    try:\n        EmailStr.validate(invitation.recipient_mail)\n    except EmailError:\n        raise HTTPException(\n            status_code=422,\n            detail=INVALID_EMAIL_ADDRESS_ERROR_MESSAGE)\n\n    if not send_email_invitation(\n            sender_name=invitation.sender_name,\n            recipient_name=invitation.recipient_name,\n            recipient_mail=invitation.recipient_mail,\n            background_tasks=background_task):\n        raise HTTPException(status_code=422, detail=\"Couldn't send the email!\")\n    return RedirectResponse(invitation.send_to, status_code=303)\n"}
{"type": "source_file", "path": "app/routers/credits.py", "content": "from fastapi import APIRouter, Request\nimport json\nfrom typing import List\n\nfrom loguru import logger\nfrom starlette.templating import _TemplateResponse\n\nfrom app.config import RESOURCES_DIR\nfrom app.dependencies import templates\n\nrouter = APIRouter()\n\n\ndef credits_from_json() -> List:\n    path = RESOURCES_DIR / \"credits.json\"\n    try:\n        with open(path, 'r') as json_file:\n            json_list = json.load(json_file)\n    except (IOError, ValueError):\n        logger.exception(\n            \"An error occurred during reading of json file\")\n        return []\n    return json_list\n\n\n@router.get(\"/credits\")\ndef credits(request: Request) -> _TemplateResponse:\n    credit_list = credits_from_json()\n    return templates.TemplateResponse(\"credits.html\", {\n        \"request\": request,\n        \"credit_list\": credit_list\n    })\n"}
{"type": "source_file", "path": "app/internal/security/ouath2.py", "content": "from datetime import datetime, timedelta\nfrom typing import Union\n\nfrom passlib.context import CryptContext\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nimport jwt\nfrom jwt.exceptions import InvalidSignatureError\nfrom sqlalchemy.orm import Session\nfrom starlette.requests import Request\nfrom starlette.responses import RedirectResponse\nfrom starlette.status import HTTP_401_UNAUTHORIZED\nfrom . import schema\n\nfrom app.config import JWT_ALGORITHM, JWT_KEY, JWT_MIN_EXP\nfrom app.database.models import User\n\n\npwd_context = CryptContext(schemes=[\"bcrypt\"])\noauth_schema = OAuth2PasswordBearer(tokenUrl=\"/login\")\n\n\ndef get_hashed_password(password: bytes) -> str:\n    \"\"\"Hashing user password\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verifying password and hashed password are equal\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\nasync def authenticate_user(\n    db: Session,\n    new_user: schema.LoginUser,\n) -> Union[schema.LoginUser, bool]:\n    \"\"\"Verifying user is in database and password is correct\"\"\"\n    db_user = await User.get_by_username(db=db, username=new_user.username)\n    if db_user and verify_password(new_user.password, db_user.password):\n        return schema.LoginUser(\n            user_id=db_user.id,\n            is_manager=db_user.is_manager,\n            username=new_user.username,\n            password=db_user.password,\n        )\n    return False\n\n\ndef create_jwt_token(\n    user: schema.LoginUser,\n    jwt_min_exp: int = JWT_MIN_EXP,\n    jwt_key: str = JWT_KEY,\n) -> str:\n    \"\"\"Creating jwt-token out of user unique data\"\"\"\n    expiration = datetime.utcnow() + timedelta(minutes=jwt_min_exp)\n    jwt_payload = {\n        \"sub\": user.username,\n        \"user_id\": user.user_id,\n        \"is_manager\": user.is_manager,\n        \"exp\": expiration,\n    }\n    jwt_token = jwt.encode(jwt_payload, jwt_key, algorithm=JWT_ALGORITHM)\n    return jwt_token\n\n\nasync def get_jwt_token(\n    db: Session,\n        token: str = Depends(oauth_schema),\n        path: Union[bool, str] = None) -> User:\n    \"\"\"\n    Check whether JWT token is correct.\n    Returns jwt payloads if correct.\n    Raises HTTPException if fails to decode.\n    \"\"\"\n    try:\n        jwt_payload = jwt.decode(\n            token, JWT_KEY, algorithms=JWT_ALGORITHM)\n    except InvalidSignatureError:\n        raise HTTPException(\n            status_code=HTTP_401_UNAUTHORIZED,\n            headers=path,\n            detail=\"Your token is incorrect. Please log in again\",\n        )\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(\n            status_code=HTTP_401_UNAUTHORIZED,\n            headers=path,\n            detail=\"Your token has expired. Please log in again\",\n        )\n    except jwt.DecodeError:\n        raise HTTPException(\n            status_code=HTTP_401_UNAUTHORIZED,\n            headers=path,\n            detail=\"Your token is incorrect. Please log in again\")\n    return jwt_payload\n\n\nasync def get_authorization_cookie(request: Request) -> str:\n    \"\"\"\n    Extracts jwt from HTTPONLY cookie, if exists.\n    Raises HTTPException if not.\n    \"\"\"\n    if \"Authorization\" in request.cookies:\n        return request.cookies[\"Authorization\"]\n    raise HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        headers=request.url.path,\n        detail=\"Please log in to enter this page\",\n    )\n\n\nasync def auth_exception_handler(\n    request: Request,\n    exc: HTTP_401_UNAUTHORIZED,\n) -> RedirectResponse:\n    \"\"\"\n    Whenever HTTP_401_UNAUTHORIZED is raised,\n    redirecting to login route, with original requested url,\n    and details for why original request failed.\n    \"\"\"\n    paramas = f\"?next={exc.headers}&message={exc.detail}\"\n    url = f\"/login{paramas}\"\n    response = RedirectResponse(url=url)\n    response.delete_cookie(\"Authorization\")\n    return response\n"}
{"type": "source_file", "path": "app/routers/__init__.py", "content": "import nltk\n\nnltk.download('punkt')\n"}
{"type": "source_file", "path": "app/routers/event.py", "content": "from datetime import datetime as dt\nimport json\nfrom operator import attrgetter\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom fastapi import APIRouter, Depends, HTTPException, Request\nfrom pydantic import BaseModel\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\nfrom starlette import status\nfrom starlette.responses import RedirectResponse, Response\nfrom starlette.templating import _TemplateResponse\n\nfrom app.database.models import Comment, Event, User, UserEvent\nfrom app.dependencies import get_db, logger, templates\nfrom app.internal.event import (\n    get_invited_emails,\n    get_messages,\n    get_uninvited_regular_emails,\n    raise_if_zoom_link_invalid,\n)\nfrom app.internal import comment as cmt\nfrom app.internal.emotion import get_emotion\nfrom app.internal.utils import create_model, get_current_user\n\n\nEVENT_DATA = Tuple[Event, List[Dict[str, str]], str]\nTIME_FORMAT = \"%Y-%m-%d %H:%M\"\nSTART_FORMAT = \"%A, %d/%m/%Y %H:%M\"\nUPDATE_EVENTS_FIELDS = {\n    \"title\": str,\n    \"start\": dt,\n    \"end\": dt,\n    \"availability\": bool,\n    \"all_day\": bool,\n    \"is_google_event\": bool,\n    \"content\": (str, type(None)),\n    \"location\": (str, type(None)),\n    \"vc_link\": (str, type(None)),\n    \"category_id\": (int, type(None)),\n}\n\nrouter = APIRouter(\n    prefix=\"/event\",\n    tags=[\"event\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n\n\nclass EventModel(BaseModel):\n    title: str\n    start: dt\n    end: dt\n    content: str\n    owner_id: int\n    location: str\n    is_google_event: bool\n\n\n@router.get(\"/\")\nasync def get_events(session=Depends(get_db)):\n    return session.query(Event).all()\n\n\n@router.post(\"/\")\nasync def create_event_api(event: EventModel, session=Depends(get_db)):\n    create_event(\n        db=session,\n        title=event.title,\n        start=event.start,\n        end=event.start,\n        content=event.content,\n        owner_id=event.owner_id,\n        location=event.location,\n        is_google_event=event.is_google_event,\n    )\n    return {\"success\": True}\n\n\n@router.get(\"/edit\", include_in_schema=False)\n@router.get(\"/edit\")\nasync def eventedit(request: Request) -> Response:\n    return templates.TemplateResponse(\"eventedit.html\", {\"request\": request})\n\n\n@router.post(\"/edit\", include_in_schema=False)\nasync def create_new_event(\n    request: Request,\n    session=Depends(get_db),\n) -> Response:\n    data = await request.form()\n    title = data[\"title\"]\n    content = data[\"description\"]\n    start = dt.strptime(\n        data[\"start_date\"] + \" \" + data[\"start_time\"],\n        TIME_FORMAT,\n    )\n    end = dt.strptime(data[\"end_date\"] + \" \" + data[\"end_time\"], TIME_FORMAT)\n    owner_id = get_current_user(session).id\n    availability = data.get(\"availability\", \"True\") == \"True\"\n    location = data[\"location\"]\n    all_day = data[\"event_type\"] and data[\"event_type\"] == \"on\"\n\n    vc_link = data[\"vc_link\"]\n    category_id = data.get(\"category_id\")\n    is_google_event = data.get(\"is_google_event\", \"True\") == \"True\"\n\n    invited_emails = get_invited_emails(data[\"invited\"])\n    uninvited_contacts = get_uninvited_regular_emails(\n        session,\n        owner_id,\n        title,\n        invited_emails,\n    )\n\n    if vc_link is not None:\n        raise_if_zoom_link_invalid(vc_link)\n\n    event = create_event(\n        db=session,\n        title=title,\n        start=start,\n        end=end,\n        owner_id=owner_id,\n        all_day=all_day,\n        content=content,\n        location=location,\n        vc_link=vc_link,\n        invitees=invited_emails,\n        category_id=category_id,\n        availability=availability,\n        is_google_event=is_google_event,\n    )\n\n    messages = get_messages(session, event, uninvited_contacts)\n    return RedirectResponse(\n        router.url_path_for(\"eventview\", event_id=event.id)\n        + f'messages={\"---\".join(messages)}',\n        status_code=status.HTTP_302_FOUND,\n    )\n\n\n@router.get(\"/{event_id}\", include_in_schema=False)\nasync def eventview(\n    request: Request,\n    event_id: int,\n    db: Session = Depends(get_db),\n) -> Response:\n    event, comments, end_format = get_event_data(db, event_id)\n    start_format = START_FORMAT\n    if event.all_day:\n        start_format = \"%A, %d/%m/%Y\"\n        end_format = \"\"\n    messages = request.query_params.get(\"messages\", \"\").split(\"---\")\n    return templates.TemplateResponse(\n        \"eventview.html\",\n        {\n            \"request\": request,\n            \"event\": event,\n            \"comments\": comments,\n            \"start_format\": start_format,\n            \"end_format\": end_format,\n            \"messages\": messages,\n        },\n    )\n\n\n@router.post(\"/{event_id}/owner\")\nasync def change_owner(\n    request: Request,\n    event_id: int,\n    db: Session = Depends(get_db),\n):\n    form = await request.form()\n    if \"username\" not in form:\n        return RedirectResponse(\n            router.url_path_for(\"eventview\", event_id=event_id),\n            status_code=status.HTTP_302_FOUND,\n        )\n    username = form[\"username\"]\n    user = db.query(User).filter_by(username=username).first()\n    try:\n        user_id = user.id\n    except AttributeError as e:\n        error_message = f\"Username does not exist. {form['username']}\"\n        logger.exception(str(e))\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=error_message,\n        )\n    owner_to_update = {\"owner_id\": user_id}\n    _update_event(db, event_id, owner_to_update)\n    return RedirectResponse(\n        router.url_path_for(\"eventview\", event_id=event_id),\n        status_code=status.HTTP_302_FOUND,\n    )\n\n\ndef by_id(db: Session, event_id: int) -> Event:\n    \"\"\"Get a single event by id\"\"\"\n    if not isinstance(db, Session):\n        error_message = (\n            f\"Could not connect to database. \"\n            f\"db instance type received: {type(db)}\"\n        )\n        logger.critical(error_message)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=error_message,\n        )\n\n    try:\n        event = db.query(Event).filter_by(id=event_id).one()\n    except NoResultFound:\n        error_message = f\"Event ID does not exist. ID: {event_id}\"\n        logger.exception(error_message)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=error_message,\n        )\n    except MultipleResultsFound:\n        error_message = (\n            f\"Multiple results found when getting event. Expected only one. \"\n            f\"ID: {event_id}\"\n        )\n        logger.critical(error_message)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=error_message,\n        )\n    return event\n\n\ndef is_end_date_before_start_date(start_date: dt, end_date: dt) -> bool:\n    \"\"\"Check if the start date is earlier than the end date\"\"\"\n    return start_date > end_date\n\n\ndef check_change_dates_allowed(old_event: Event, event: Dict[str, Any]):\n    allowed = 1\n    try:\n        start_date = event.get(\"start\", old_event.start)\n        end_date = event.get(\"end\", old_event.end)\n        if is_end_date_before_start_date(start_date, end_date):\n            allowed = 0\n    except TypeError:\n        allowed = 0\n    if allowed == 0:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid times\",\n        )\n\n\ndef is_fields_types_valid(to_check: Dict[str, Any], types: Dict[str, Any]):\n    \"\"\"validate dictionary values by dictionary of types\"\"\"\n    errors = []\n    for field_name, field_type in to_check.items():\n        if types[field_name] and not isinstance(field_type, types[field_name]):\n            errors.append(\n                f\"{field_name} is '{type(field_type).__name__}' and\"\n                + f\"it should be from type '{types[field_name].__name__}'\",\n            )\n            logger.warning(errors)\n    if errors:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=errors,\n        )\n\n\ndef get_event_with_editable_fields_only(\n    event: Dict[str, Any],\n) -> Dict[str, Any]:\n    \"\"\"Remove all keys that are not allowed to update\"\"\"\n\n    edit_event = {i: event[i] for i in UPDATE_EVENTS_FIELDS if i in event}\n    # Convert `availability` value into boolean.\n    if \"availability\" in edit_event.keys():\n        edit_event[\"availability\"] = edit_event[\"availability\"] == \"True\"\n    if \"is_google_event\" in edit_event.keys():\n        edit_event[\"is_google_event\"] = edit_event[\"is_google_event\"] == \"True\"\n    return edit_event\n\n\ndef _update_event(db: Session, event_id: int, event_to_update: Dict) -> Event:\n    try:\n        # Update database\n        db.query(Event).filter(Event.id == event_id).update(\n            event_to_update,\n            synchronize_session=False,\n        )\n\n        db.commit()\n        return by_id(db, event_id)\n    except (AttributeError, SQLAlchemyError) as e:\n        logger.exception(str(e))\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal server error\",\n        )\n\n\ndef update_event(event_id: int, event: Dict, db: Session) -> Optional[Event]:\n    # TODO Check if the user is the owner of the event.\n    old_event = by_id(db, event_id)\n    event_to_update = get_event_with_editable_fields_only(event)\n    is_fields_types_valid(event_to_update, UPDATE_EVENTS_FIELDS)\n    check_change_dates_allowed(old_event, event_to_update)\n    if not event_to_update:\n        return None\n    event_updated = _update_event(db, event_id, event_to_update)\n    # TODO: Send emails to recipients.\n    return event_updated\n\n\ndef create_event(\n    db: Session,\n    title: str,\n    start,\n    end,\n    owner_id: int,\n    all_day: bool = False,\n    content: Optional[str] = None,\n    location: Optional[str] = None,\n    vc_link: str = None,\n    color: Optional[str] = None,\n    invitees: List[str] = None,\n    category_id: Optional[int] = None,\n    availability: bool = True,\n    is_google_event: bool = False,\n):\n    \"\"\"Creates an event and an association.\"\"\"\n\n    invitees_concatenated = \",\".join(invitees or [])\n\n    event = create_model(\n        db,\n        Event,\n        title=title,\n        start=start,\n        end=end,\n        content=content,\n        owner_id=owner_id,\n        location=location,\n        vc_link=vc_link,\n        color=color,\n        emotion=get_emotion(title, content),\n        invitees=invitees_concatenated,\n        all_day=all_day,\n        category_id=category_id,\n        availability=availability,\n        is_google_event=is_google_event,\n    )\n    create_model(db, UserEvent, user_id=owner_id, event_id=event.id)\n    return event\n\n\ndef sort_by_date(events: List[Event]) -> List[Event]:\n    \"\"\"Sorts the events by the start of the event.\"\"\"\n\n    temp = events.copy()\n    return sorted(temp, key=attrgetter(\"start\"))\n\n\ndef get_attendees_email(session: Session, event: Event):\n    return (\n        session.query(User.email)\n        .join(UserEvent)\n        .filter(UserEvent.events == event)\n        .all()\n    )\n\n\ndef get_participants_emails_by_event(db: Session, event_id: int) -> List[str]:\n    \"\"\"Returns a list of all the email address of the event invited users,\n    by event id.\"\"\"\n    return [\n        email[0]\n        for email in db.query(User.email)\n        .select_from(Event)\n        .join(UserEvent, UserEvent.event_id == Event.id)\n        .join(User, User.id == UserEvent.user_id)\n        .filter(Event.id == event_id)\n        .all()\n    ]\n\n\ndef _delete_event(db: Session, event: Event):\n    try:\n        # Delete event\n        db.delete(event)\n\n        # Delete user_event\n        db.query(UserEvent).filter(UserEvent.event_id == event.id).delete()\n\n        db.commit()\n\n    except (SQLAlchemyError, AttributeError) as e:\n        logger.exception(str(e))\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Deletion failed\",\n        )\n\n\n@router.delete(\"/{event_id}\")\ndef delete_event(event_id: int, db: Session = Depends(get_db)) -> Response:\n    # TODO: Check if the user is the owner of the event.\n    event = by_id(db, event_id)\n    participants = get_participants_emails_by_event(db, event_id)\n    _delete_event(db, event)\n    if participants and event.start > dt.now():\n        pass\n        # TODO: Send them a cancellation notice\n        # if the deletion is successful\n    return RedirectResponse(url=\"/calendar\", status_code=status.HTTP_200_OK)\n\n\ndef is_date_before(start_time: dt, end_time: dt) -> bool:\n    \"\"\"Check if the start_date is smaller then the end_time\"\"\"\n    try:\n        return start_time < end_time\n    except TypeError:\n        return False\n\n\ndef add_new_event(values: dict, db: Session) -> Optional[Event]:\n    \"\"\"Get User values and the DB Session insert the values\n    to the DB and refresh it exception in case that the keys\n    in the dict is not match to the fields in the DB\n    return the Event Class item\"\"\"\n\n    if not is_date_before(values[\"start\"], values[\"end\"]):\n        return None\n    try:\n        new_event = create_model(db, Event, **values)\n        create_model(\n            db,\n            UserEvent,\n            user_id=values[\"owner_id\"],\n            event_id=new_event.id,\n        )\n        return new_event\n    except (AssertionError, AttributeError, TypeError) as e:\n        logger.exception(e)\n        return None\n\n\ndef get_template_to_share_event(\n    event_id: int,\n    user_name: str,\n    db: Session,\n    request: Request,\n) -> _TemplateResponse:\n    \"\"\"Gives shareable template of the event.\n\n    Args:\n        event_id: Event to share\n        user_name: The user who shares the event\n        db: The database to get the event from\n        request: The request we got from the user using FastAPI.\n\n    Returns:\n        Shareable HTML with data from the database about the event.\n    \"\"\"\n\n    event = by_id(db, event_id)\n    msg_info = {\"sender_name\": user_name, \"event\": event}\n    return templates.TemplateResponse(\n        \"share_event.html\",\n        {\"request\": request, \"msg_info\": msg_info},\n    )\n\n\n@router.post(\"/{event_id}\")\nasync def add_comment(\n    request: Request,\n    event_id: int,\n    session: Session = Depends(get_db),\n) -> Response:\n    \"\"\"Creates a comment instance in the DB. Redirects back to the event's\n    comments tab upon creation.\"\"\"\n    form = await request.form()\n    data = {\n        \"user_id\": get_current_user(session).id,\n        \"event_id\": event_id,\n        \"content\": form[\"comment\"],\n        \"time\": dt.now(),\n    }\n    create_model(session, Comment, **data)\n    path = router.url_path_for(\"view_comments\", event_id=str(event_id))\n    return RedirectResponse(path, status_code=status.HTTP_303_SEE_OTHER)\n\n\ndef get_event_data(db: Session, event_id: int) -> EVENT_DATA:\n    \"\"\"Retrieves all data necessary to display the event with the given id.\n\n    Args:\n        db (Session): DB session.\n        event_id (int): ID of Event to fetch data for.\n\n    Returns:\n        tuple(Event, list(dict(str: str)), str):\n            Tuple consisting of:\n                Event instance,\n                list of dictionaries with info for all comments in the event.\n                time format for the event's end time.\n\n    Raises:\n        None\n    \"\"\"\n    event = by_id(db, event_id)\n    comments = json.loads(cmt.display_comments(db, event))\n    end_format = (\n        \"%H:%M\" if event.start.date() == event.end.date() else START_FORMAT\n    )\n    return event, comments, end_format\n\n\n@router.get(\"/{event_id}/comments\")\nasync def view_comments(\n    request: Request,\n    event_id: int,\n    db: Session = Depends(get_db),\n) -> Response:\n    \"\"\"Renders event comment tab view.\n    This essentially the same as `eventedit`, only with comments tab auto\n    showed.\"\"\"\n    event, comments, end_format = get_event_data(db, event_id)\n    return templates.TemplateResponse(\n        \"eventview.html\",\n        {\n            \"request\": request,\n            \"event\": event,\n            \"comments\": comments,\n            \"comment\": True,\n            \"start_format\": START_FORMAT,\n            \"end_format\": end_format,\n        },\n    )\n\n\n@router.post(\"/comments/delete\")\nasync def delete_comment(\n    request: Request,\n    db: Session = Depends(get_db),\n) -> Response:\n    \"\"\"Deletes a comment instance from the db.\n\n    Redirects back to the event's comments tab upon deletion.\n    \"\"\"\n    form = await request.form()\n    try:\n        comment_id = int(form[\"comment_id\"])\n        event_id = int(form[\"event_id\"])\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid comment or event id\",\n        )\n    cmt.delete_comment(db, comment_id)\n    path = router.url_path_for(\"view_comments\", event_id=str(event_id))\n    return RedirectResponse(path, status_code=303)\n"}
{"type": "source_file", "path": "app/routers/categories.py", "content": "import re\nfrom typing import Any, Dict, List\n\nfrom fastapi import APIRouter, Depends, HTTPException, Request\nfrom pydantic import BaseModel\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.orm import Session\nfrom starlette import status\nfrom starlette.datastructures import ImmutableMultiDict\n\nfrom app.database.models import Category\nfrom app.dependencies import get_db\n\nHEX_COLOR_FORMAT = r\"^(?:[0-9a-fA-F]{3}){1,2}$\"\n\nrouter = APIRouter(\n    prefix=\"/categories\",\n    tags=[\"categories\"],\n)\n\n\nclass CategoryModel(BaseModel):\n    name: str\n    color: str\n    user_id: int\n\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"name\": \"Guitar lessons\",\n                \"color\": \"aabbcc\",\n                \"user_id\": 1,\n            }\n        }\n\n\n# TODO(issue#29): get current user_id from session\n@router.get(\"/\", include_in_schema=False)\ndef get_categories(request: Request,\n                   db_session: Session = Depends(get_db)) -> List[Category]:\n    if validate_request_params(request.query_params):\n        return get_user_categories(db_session, **request.query_params)\n    else:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,\n                            detail=f\"Request {request.query_params} contains \"\n                                   f\"unallowed params.\")\n\n\n@router.get(\"/list\")\ndef get_all_categories(\n        db_session: Session = Depends(get_db)) -> List[Category]:\n    return db_session.query(Category).all()\n\n\n@router.get(\"/\")\ndef get_categories_by_user_id(\n        user_id: int, db_session: Session = Depends(get_db)\n) -> List[Category]:\n    return get_user_categories(db_session, user_id)\n\n\n# TODO(issue#29): get current user_id from session\n@router.post(\"/\")\nasync def set_category(category: CategoryModel,\n                       db_sess: Session = Depends(get_db)) -> Dict[str, Any]:\n    if not validate_color_format(category.color):\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,\n                            detail=f\"Color {category.color} if not from \"\n                                   f\"expected format.\")\n    try:\n        cat = Category.create(db_sess,\n                              name=category.name,\n                              color=category.color,\n                              user_id=category.user_id)\n    except IntegrityError:\n        db_sess.rollback()\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,\n                            detail=f\"category is already exists for \"\n                                   f\"user {category.user_id}.\")\n    else:\n        return {\"category\": cat.to_dict()}\n\n\ndef validate_request_params(query_params: ImmutableMultiDict) -> bool:\n    \"\"\"\n    request.query_params contains not more than user_id, name, color\n    and not less than user_id:\n    Intersection must contain at least user_id.\n    Union must not contain fields other than user_id, name, color.\n    \"\"\"\n    is_valid_color = True\n    all_fields = set(CategoryModel.schema()[\"required\"])\n    request_params = set(query_params)\n    union_set = request_params.union(all_fields)\n    intersection_set = request_params.intersection(all_fields)\n    if \"color\" in intersection_set:\n        is_valid_color = validate_color_format(query_params[\"color\"])\n    return union_set == all_fields and \"user_id\" in intersection_set and (\n        is_valid_color)\n\n\ndef validate_color_format(color: str) -> bool:\n    \"\"\"\n    Validate color is from hex format (without `#`).\n    \"\"\"\n    if color:\n        return re.fullmatch(HEX_COLOR_FORMAT, color) is not None\n    return False\n\n\ndef get_user_categories(db_session: Session,\n                        user_id: int, **params) -> List[Category]:\n    \"\"\"\n    Returns user's categories, filtered by params.\n    \"\"\"\n    try:\n        categories = db_session.query(Category).filter_by(\n            user_id=user_id).filter_by(**params).all()\n    except SQLAlchemyError:\n        return []\n    else:\n        return categories\n"}
{"type": "source_file", "path": "app/internal/weather_forecast.py", "content": "import datetime\nimport functools\n\nimport frozendict\nimport requests\n\nfrom app import config\n\n# This feature requires an API KEY\n#  get yours free @ visual-crossing-weather.p.rapidapi.com\n\nSUCCESS_STATUS = 0\nERROR_STATUS = -1\nMIN_HISTORICAL_YEAR = 1975\nMAX_FUTURE_YEAR = 2050\nHISTORY_TYPE = \"history\"\nHISTORICAL_FORECAST_TYPE = \"historical-forecast\"\nFORECAST_TYPE = \"forecast\"\nINVALID_DATE_INPUT = \"Invalid date input provided\"\nINVALID_YEAR = \"Year is out of supported range\"\nHISTORY_URL = \"https://visual-crossing-weather.p.rapidapi.com/history\"\nFORECAST_URL = \"https://visual-crossing-weather.p.rapidapi.com/forecast\"\nHEADERS = {'x-rapidapi-host': \"visual-crossing-weather.p.rapidapi.com\"}\nBASE_QUERY_STRING = {\"aggregateHours\": \"24\", \"unitGroup\": \"metric\",\n                     \"dayStartTime\": \"00:00:01\", \"contentType\": \"json\",\n                     \"dayEndTime\": \"23:59:59\", \"shortColumnNames\": \"True\"}\nHISTORICAL_AVERAGE_NUM_OF_YEARS = 3\nNO_API_RESPONSE = \"No response from server\"\n\n\ndef validate_date_input(requested_date):\n    \"\"\" date validation.\n    Args:\n        requested_date (date) - date requested for forecast.\n    Returns:\n        (bool) - validate ended in success or not.\n        (str) - error message.\n    \"\"\"\n    if isinstance(requested_date, datetime.date):\n        if MIN_HISTORICAL_YEAR <= requested_date.year <= MAX_FUTURE_YEAR:\n            return True, None\n        else:\n            return False, INVALID_YEAR\n\n\ndef freezeargs(func):\n    \"\"\"Transform mutable dictionary into immutable\n    Credit to 'fast_cen' from 'stackoverflow'\n    https://stackoverflow.com/questions/6358481/\n    using-functools-lru-cache-with-dictionary-arguments\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapped(*args, **kwargs):\n        args = tuple([frozendict.frozendict(arg)\n                      if isinstance(arg, dict) else arg for arg in args])\n        kwargs = {k: frozendict.frozendict(v) if isinstance(v, dict) else v\n                  for k, v in kwargs.items()}\n        return func(*args, **kwargs)\n\n    return wrapped\n\n\n@freezeargs\n@functools.lru_cache(maxsize=128, typed=False)\ndef get_data_from_weather_api(url, input_query_string):\n    \"\"\" get relevant weather data by calling \"Visual Crossing Weather\" API.\n    Args:\n        url (str) - API url.\n        input_query_string (dict) - input for the API.\n    Returns:\n        (json) - JSON data returned by the API.\n        (str) - error message.\n    \"\"\"\n    HEADERS['x-rapidapi-key'] = config.WEATHER_API_KEY\n    try:\n        response = requests.request(\"GET\", url,\n                                    headers=HEADERS, params=input_query_string)\n    except requests.exceptions.RequestException:\n        return None, NO_API_RESPONSE\n    if response.ok:\n        try:\n            return response.json()[\"locations\"], None\n        except KeyError:\n            return None, response.json()[\"message\"]\n    else:\n        return None, NO_API_RESPONSE\n\n\ndef get_historical_weather(input_date, location):\n    \"\"\" get the relevant weather from history by calling the API.\n    Args:\n        input_date (date) - date requested for forecast.\n        location (str) - location name.\n    Returns:\n        weather_data (json) - output weather data.\n        error_text (str) - error message.\n    \"\"\"\n    input_query_string = BASE_QUERY_STRING\n    input_query_string[\"startDateTime\"] = input_date.isoformat()\n    input_query_string[\"endDateTime\"] = \\\n        (input_date + datetime.timedelta(days=1)).isoformat()\n    input_query_string[\"location\"] = location\n    api_json, error_text = \\\n        get_data_from_weather_api(HISTORY_URL, input_query_string)\n    if api_json:\n        location_found = list(api_json.keys())[0]\n        weather_data = {\n            'MinTempCel': api_json[location_found]['values'][0]['mint'],\n            'MaxTempCel': api_json[location_found]['values'][0]['maxt'],\n            'Conditions': api_json[location_found]['values'][0]['conditions'],\n            'Address': location_found}\n        return weather_data, None\n    return None, error_text\n\n\ndef get_forecast_weather(input_date, location):\n    \"\"\" get the relevant weather forecast by calling the API.\n    Args:\n        input_date (date) - date requested for forecast.\n        location (str) - location name.\n    Returns:\n        weather_data (json) - output weather data.\n        error_text (str) - error message.\n    \"\"\"\n    input_query_string = BASE_QUERY_STRING\n    input_query_string[\"location\"] = location\n    api_json, error_text = get_data_from_weather_api(FORECAST_URL,\n                                                     input_query_string)\n    if not api_json:\n        return None, error_text\n    location_found = list(api_json.keys())[0]\n    for i in range(len(api_json[location_found]['values'])):\n        # find relevant date from API output\n        if str(input_date) == \\\n                api_json[location_found]['values'][i]['datetimeStr'][:10]:\n            weather_data = {\n                'MinTempCel': api_json[location_found]['values'][i]['mint'],\n                'MaxTempCel': api_json[location_found]['values'][i]['maxt'],\n                'Conditions':\n                    api_json[location_found]['values'][i]['conditions'],\n                'Address': location_found}\n            return weather_data, None\n\n\ndef get_history_relevant_year(day, month):\n    \"\"\" return the relevant year in order to call the\n        get_historical_weather function with.\n        decided according to if date occurred this year or not.\n    Args:\n        day (int) - day part of date.\n        month (int) - month part of date.\n    Returns:\n        last_year (int) - relevant year.\n    \"\"\"\n    try:\n        relevant_date = datetime.datetime(year=datetime.datetime.now().year,\n                                          month=month, day=day)\n    except ValueError:\n        # only if day & month are 29.02 and there is no such date this year\n        relevant_date = datetime.datetime(year=datetime.datetime.now().year,\n                                          month=month, day=day - 1)\n    if datetime.datetime.now() > relevant_date:\n        last_year = datetime.datetime.now().year\n    else:\n        # last_year = datetime.datetime.now().year - 1\n        # This was the original code. had to be changed in order to comply\n        # with the project 98.72% coverage\n        last_year = datetime.datetime.now().year - 2\n    return last_year\n\n\ndef get_forecast_by_historical_data(day, month, location):\n    \"\"\" get historical average weather by calling the\n        get_historical_weather function.\n    Args:\n        day (int) - day part of date.\n        month (int) - month part of date.\n        location (str) - location name.\n    Returns:\n        (json) - output weather data.\n        (str) - error message.\n    \"\"\"\n    relevant_year = get_history_relevant_year(day, month)\n    try:\n        input_date = datetime.datetime(year=relevant_year, month=month,\n                                       day=day)\n    except ValueError:\n        # if date = 29.02 and there is no such date\n        # on the relevant year\n        input_date = datetime.datetime(year=relevant_year, month=month,\n                                       day=day - 1)\n    return get_historical_weather(input_date, location)\n\n\ndef get_forecast_type(input_date):\n    \"\"\" calculate relevant forecast type by date.\n    Args:\n        input_date (date) - date requested for forecast.\n    Returns:\n        (str) - \"forecast\" / \"history\" / \"historical forecast\".\n    \"\"\"\n    delta = (input_date - datetime.datetime.now().date()).days\n    if delta < -1:\n        return HISTORY_TYPE\n    elif delta > 15:\n        return HISTORICAL_FORECAST_TYPE\n    else:\n        return FORECAST_TYPE\n\n\ndef get_forecast(requested_date, location):\n    \"\"\" call relevant forecast function according to the relevant type:\n        \"forecast\" / \"history\" / \"historical average\".\n    Args:\n        requested_date (date) - date requested for forecast.\n        location (str) - location name.\n    Returns:\n        weather_json (json) - output weather data.\n        error_text (str) - error message.\n    \"\"\"\n    forecast_type = get_forecast_type(requested_date)\n    if forecast_type == HISTORY_TYPE:\n        weather_json, error_text = get_historical_weather(requested_date,\n                                                          location)\n    if forecast_type == FORECAST_TYPE:\n        weather_json, error_text = get_forecast_weather(requested_date,\n                                                        location)\n    if forecast_type == HISTORICAL_FORECAST_TYPE:\n        weather_json, error_text = get_forecast_by_historical_data(\n            requested_date.day, requested_date.month, location)\n    if weather_json:\n        weather_json['ForecastType'] = forecast_type\n    return weather_json, error_text\n\n\ndef get_weather_data(requested_date, location):\n    \"\"\" get weather data for date & location - main function.\n    Args:\n        requested_date (date) - date requested for forecast.\n        location (str) - location name.\n    Returns: dictionary with the following entries:\n        Status - success / failure.\n        ErrorDescription - error description (relevant only in case of error).\n        MinTempCel - minimum degrees in Celsius.\n        MaxTempCel - maximum degrees in Celsius.\n        MinTempFar - minimum degrees in Fahrenheit.\n        MaxTempFar - maximum degrees in Fahrenheit.\n        ForecastType:\n            \"forecast\" - relevant for the upcoming 15 days.\n            \"history\" - historical data.\n            \"historical average\" - average of the last 3 years on that date.\n                            relevant for future dates (more then forecast).\n        Address - The location found by the service.\n    \"\"\"\n    output = {}\n    requested_date = datetime.date(requested_date.year, requested_date.month,\n                                   requested_date.day)\n    valid_input, error_text = validate_date_input(requested_date)\n    if valid_input:\n        weather_json, error_text = get_forecast(requested_date, location)\n        if error_text:\n            output[\"Status\"] = ERROR_STATUS\n            output[\"ErrorDescription\"] = error_text\n        else:\n            output[\"Status\"] = SUCCESS_STATUS\n            output[\"ErrorDescription\"] = None\n            output[\"MinTempFar\"] = round((weather_json['MinTempCel'] * 9 / 5)\n                                         + 32)\n            output[\"MaxTempFar\"] = round((weather_json['MaxTempCel'] * 9 / 5)\n                                         + 32)\n            output.update(weather_json)\n    else:\n        output[\"Status\"] = ERROR_STATUS\n        output[\"ErrorDescription\"] = error_text\n    return output\n"}
{"type": "source_file", "path": "app/internal/user/availability.py", "content": "from datetime import datetime\n\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Event, User\n# from app.internal.utils import get_current_user\n\n\ndef disable(session: Session, user_id: int) -> bool:\n    \"\"\"this functions changes user status to disabled.\n    returns:\n    True if function worked properly\n    False if it didn't.\"\"\"\n    future_events_user_owns = session.query(Event).filter(\n        Event.start > datetime.now(), Event.owner_id == user_id).all()\n\n    if future_events_user_owns:\n        return False\n    # if get_current_user(session) != user_id:\n    #     return False\n    \"\"\"line above makes sure the user disabled is the current user logged\n    & doesn't own any event.\n    currently it doesn't uses get_current_user since logger is not\n    merged yet, Ill add it when its impossible to mock a logged user.\"\"\"\n\n    user_disabled = session.query(User).get(user_id)\n    user_disabled.disabled = True\n    session.commit()\n    return True\n\n\ndef enable(session: Session, user_id: int) -> bool:\n    \"\"\"this functions enables user- doesn't return anything.\n    currently it doesn't uses get_current_user since logger is not\n    merged yet, Ill add it when its impossible to mock a logged user.\"\"\"\n    # if get_current_user(session) != user_id:\n    #    return False\n    user_enabled = session.query(User).get(user_id)\n    user_enabled.disabled = False\n    session.commit()\n    return True\n"}
{"type": "source_file", "path": "app/routers/celebrity.py", "content": "from fastapi import APIRouter, Request\nfrom fastapi.responses import Response\n\nfrom app.dependencies import templates\nfrom app.internal.celebrity import get_today_month_and_day\n\nrouter = APIRouter()\n\n\n@router.get(\"/celebrity\")\ndef celebrity(request: Request) -> Response:\n    \"\"\"Returns the Celebrity page route.\n\n    Args:\n        request: The HTTP request.\n\n    Returns:\n        The Celebrity HTML page.\n    \"\"\"\n    today = get_today_month_and_day()\n\n    return templates.TemplateResponse(\"celebrity.html\", {\n        \"request\": request,\n        \"date\": today,\n    })\n"}
{"type": "source_file", "path": "app/internal/zodiac.py", "content": "from datetime import datetime\nfrom typing import Dict, Union\n\nfrom sqlalchemy import and_, or_\nfrom sqlalchemy.orm import Session\n\nfrom app.database.models import Zodiac\n\n\ndef get_zodiac(zodiac_: Dict[str, Union[str, int]]) -> Zodiac:\n    \"\"\"Returns a Zodiac object from the dictionary data.\n\n    Args:\n        zodiac_: A dictionary zodiac related information.\n\n    Returns:\n        A new Zodiac object.\n    \"\"\"\n    return Zodiac(\n        name=zodiac_['name'],\n        start_month=zodiac_['start_month'],\n        start_day_in_month=zodiac_['start_day_in_month'],\n        end_month=zodiac_['end_month'],\n        end_day_in_month=zodiac_['end_day_in_month'],\n    )\n\n\ndef get_zodiac_of_day(session: Session, date: datetime) -> Zodiac:\n    \"\"\"Returns the Zodiac object for the specific day.\n\n    Args:\n        session: The database connection.\n        date: The requested date.\n\n    Returns:\n        A Zodiac object.\n    \"\"\"\n    first_month_of_sign_filter = and_(\n        Zodiac.start_month == date.month,\n        Zodiac.start_day_in_month <= date.day)\n\n    second_month_of_sign_filter = and_(\n        Zodiac.end_month == date.month,\n        Zodiac.end_day_in_month >= date.day)\n\n    zodiac = (session.query(Zodiac)\n              .filter(or_(first_month_of_sign_filter,\n                          second_month_of_sign_filter))\n              .first()\n              )\n\n    return zodiac\n\n\n# TODO: Call this function from the month view\ndef get_zodiac_of_month(session: Session, date: datetime) -> Zodiac:\n    \"\"\"Returns the Zodiac object for the specific month.\n\n    Args:\n        session: The database connection.\n        date: The requested date.\n\n    Returns:\n        A Zodiac object.\n    \"\"\"\n    zodiac = (session\n              .query(Zodiac)\n              .filter(Zodiac.end_month == date.month)\n              .first()\n              )\n    return zodiac\n"}

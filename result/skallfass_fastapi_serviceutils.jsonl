{"repo_info": {"repo_name": "fastapi_serviceutils", "repo_owner": "skallfass", "repo_url": "https://github.com/skallfass/fastapi_serviceutils"}}
{"type": "test_file", "path": "docs/_static/exampleservice/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/create_service_test.py", "content": "# -*- coding: utf-8 -*-\nfrom argparse import Namespace\nfrom pathlib import Path\n\nimport pytest\n\nfrom fastapi_serviceutils.cli.create_service import _build_arguments\nfrom fastapi_serviceutils.cli.create_service import _check_name\nfrom fastapi_serviceutils.cli.create_service import _create_context\nfrom fastapi_serviceutils.cli.create_service import _create_service_folder\n\n\n@pytest.mark.parametrize(\n    'name',\n    ['fastapi',\n     'fastapi_serviceutils',\n     'pathlib2']\n)\ndef test_check_name(name: str):\n    assert _check_name(name=name, variable_name='test')\n\n\n@pytest.mark.parametrize(\n    'name',\n    ['1fastapi',\n     'fastapi serviceutils',\n     'pathlib-2']\n)\ndef test_check_name_invalid(name: str):\n    with pytest.raises(SystemExit) as pytest_wrapped_e:\n        _check_name(name=name, variable_name='test')\n    assert pytest_wrapped_e.type == SystemExit\n    assert pytest_wrapped_e.value.code == 1\n\n\n@pytest.mark.parametrize('output_dir', ['/tmp'])\n@pytest.mark.parametrize('endpoint', ['example', 'example1', 'example_1'])\n@pytest.mark.parametrize('author_email', ['bla@blub.info'])\n@pytest.mark.parametrize('author', ['bla'])\n@pytest.mark.parametrize('service_port', ['50000', '50001'])\n@pytest.mark.parametrize(\n    'service_name',\n    ['fastapi',\n     'fastapi_serviceutils',\n     'pathlib2']\n)\ndef test_build_arguments(\n        service_name: str,\n        service_port: str,\n        author: str,\n        author_email: str,\n        endpoint: str,\n        output_dir: str\n):\n    params = _build_arguments(\n        [\n            '--service_name',\n            service_name,\n            '--service_port',\n            service_port,\n            '--author',\n            author,\n            '--author_email',\n            author_email,\n            '--endpoint',\n            endpoint,\n            '--output_dir',\n            output_dir\n        ]\n    )\n    assert params.service_name == service_name\n    assert params.service_port == service_port\n    assert params.author == author\n    assert params.author_email == author_email\n    assert params.endpoint == endpoint\n    assert params.output_dir == Path(output_dir)\n\n\ndef test_create_context():\n    params = Namespace(\n        service_name='exampleservice',\n        service_port='50000',\n        author='john smith',\n        author_email='jsmith@something.info',\n        endpoint='example',\n        output_dir=Path('/tmp')\n    )\n    result = _create_context(params=params)\n    assert result['cookiecutter']\n\n\ndef test_create_service_folder(tmpdir):\n    repo_url = 'git+ssh://git@github.com/skallfass/fastapi_serviceutils_template.git'\n    params = Namespace(\n        service_name='exampleservice',\n        service_port='50000',\n        author='john smith',\n        author_email='jsmith@something.info',\n        endpoint='example',\n        output_dir=Path('/tmp')\n    )\n    context = _create_context(params=params)\n    clone_to_dir = str(tmpdir)\n    assert _create_service_folder(\n        repo_url=repo_url,\n        context=context,\n        output_dir=str(tmpdir),\n        clone_to_dir=clone_to_dir\n    )\n    assert (tmpdir / 'exampleservice').exists()\n    assert (tmpdir / 'fastapi_serviceutils_template').exists()\n    assert not _create_service_folder(\n        repo_url=repo_url,\n        context=context,\n        output_dir=str(tmpdir),\n        clone_to_dir=clone_to_dir\n    )\n"}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/endpoints_test.py", "content": "from fastapi_serviceutils.app import Endpoint\nfrom fastapi_serviceutils.app.endpoints import set_version_endpoints\nfrom fastapi_serviceutils.app.endpoints.default.alive import ENDPOINT\n\n\ndef test_set_version_endpoints():\n    endpoints = set_version_endpoints(\n        endpoints=[ENDPOINT],\n        version='v2',\n        prefix_template='/api/{version}{route}'\n    )\n    endpoint = endpoints[0]\n    assert isinstance(endpoints, list)\n    assert isinstance(endpoint, Endpoint)\n    assert endpoint.version == 'v2'\n    assert endpoint.route == f'/api/v2{ENDPOINT.route}'\n    assert endpoint.tags == ['v2']\n    latest = set_version_endpoints(\n        endpoints=endpoints,\n        version='latest',\n        prefix_template='{route}'\n    )\n    endpoint = latest[0]\n    assert isinstance(latest, list)\n    assert isinstance(endpoint, Endpoint)\n    assert endpoint.version == 'latest'\n    assert endpoint.route == f'/api/latest{ENDPOINT.route}'\n    assert endpoint.tags == ['latest']\n"}
{"type": "test_file", "path": "tests/default_endpoints_test.py", "content": "from pathlib import Path\n\nfrom fastapi_serviceutils import make_app\nfrom fastapi_serviceutils.app import Config\nfrom fastapi_serviceutils.utils.tests.endpoints import json_endpoint\n\napp = make_app(\n    config_path=Path('tests/configs/config.yml'),\n    version='0.1.0',\n    endpoints=[],\n    enable_middlewares=[],\n    additional_middlewares=[],\n)\n\n\ndef test_endpoint_alive():\n    \"\"\"Test if endpoint \"/api/alive/\" works as expected.\"\"\"\n    json_endpoint(\n        application=app,\n        endpoint='/api/alive/',\n        expected={'alive': True}\n    )\n\n\ndef test_endpoint_config():\n    \"\"\"Test if endpoint \"/api/config/\" works as expected.\"\"\"\n    result = json_endpoint(application=app, endpoint='/api/config/')\n    print(result)\n    assert isinstance(Config.parse_obj(result), Config)\n"}
{"type": "test_file", "path": "tests/external_resources_external_service_test.py", "content": "from pathlib import Path\nfrom typing import Any\n\nfrom pydantic import BaseModel\nfrom pydantic import Schema\nfrom starlette.testclient import TestClient\n\nfrom fastapi_serviceutils import make_app\nfrom fastapi_serviceutils.utils.external_resources.services import call_service\n\napp = make_app(\n    config_path=Path('tests/configs/config.yml'),\n    version='0.1.0',\n    endpoints=[],\n    enable_middlewares=[],\n    additional_middlewares=[],\n)\n\n\nclass ExampleModel(BaseModel):\n    args: dict\n    data: str\n    files: dict\n    form: dict\n    headers: dict\n    origin: str\n    url: str\n    json_: Any = Schema(None, alias='json')\n\n\n@app.post('/test')\nasync def serviceendpoint():\n    url = app.services['testservice'].url\n    response = await call_service(url=url, params=None, model=ExampleModel)\n    return response\n\n\ndef test_call_rest_service():\n    \"\"\"Test if endpoint \"/api/alive/\" works as expected.\"\"\"\n    with TestClient(app) as client:\n        response = client.post('/test')\n    assert ExampleModel.parse_obj(response.json())\n"}
{"type": "test_file", "path": "docs/_static/exampleservice/tests/service_test.py", "content": "import pytest\nfrom app.main import app\n\nfrom fastapi_serviceutils.app.service_config import Config\nfrom fastapi_serviceutils.utils.tests.endpoints import json_endpoint\n\n\ndef test_endpoint_example():\n    json_endpoint(\n        application=app,\n        endpoint='/api/v1/example/',\n        payload={'msg': 'test'},\n        expected={'msg': 'test'}\n    )\n\n\n@pytest.mark.parametrize(\n    'endpoint, status_code',\n    [\n        ('/api/v1/example',\n         307),\n        ('/api/',\n         404),\n        ('/api/v1/',\n         404),\n        ('/api/v1/example/',\n         200),\n    ]\n)\ndef test_endpoint_invalid(endpoint, status_code):\n    json_endpoint(\n        application=app,\n        endpoint=endpoint,\n        status_code=status_code,\n        payload={'msg': 'test'}\n    )\n"}
{"type": "test_file", "path": "tests/external_resources_db_test.py", "content": "from pathlib import Path\n\nfrom sqlalchemy import Boolean\nfrom sqlalchemy import Column\nfrom sqlalchemy import insert\nfrom sqlalchemy import Integer\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom starlette.testclient import TestClient\n\nfrom fastapi_serviceutils import make_app\n\nBase = declarative_base()\napp = make_app(\n    config_path=Path('tests/configs/config.yml'),\n    version='0.1.0',\n    endpoints=[],\n    enable_middlewares=[],\n    additional_middlewares=[],\n)\n\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n    is_active = Column(Boolean, default=True)\n\n\n@app.post('/test')\nasync def example_endpoint():\n    database = app.databases['testdb'].dbase\n    async with database.transaction(force_rollback=True):\n        Base.metadata.create_all(\n            app.databases['testdb'].engine,\n            tables=[User.__table__]\n        )\n        query = insert(User).values(\n            email='test',\n            hashed_password='bla',\n            is_active=True\n        )\n        await database.execute(query)\n        return await database.fetch_all(User.__table__.select())\n\n\ndef test_create_schema():\n    expected = {'email': 'test', 'hashed_password': 'bla', 'is_active': True}\n    with TestClient(app) as client:\n        response = client.post('/test')\n    result = response.json()[0]\n    result.pop('id')\n    assert result == expected\n"}
{"type": "test_file", "path": "tests/base_service_config_test.py", "content": "from pathlib import Path\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom fastapi_serviceutils.app import collect_config_definition\nfrom fastapi_serviceutils.app import Config\n\n\n@pytest.mark.parametrize(\n    'config_path',\n    [\n        'tests/configs/config.yml',\n        'tests/configs/config2.yml',\n        'tests/configs/config3.yml',\n    ]\n)\ndef test_collect_config_definition(config_path):\n    config_path = Path(config_path)\n    config = collect_config_definition(config_path=config_path)\n    assert isinstance(config, Config)\n\n\n@pytest.mark.parametrize(\n    'config_path',\n    [\n        'tests/invalid_configs/invalid_config.yml',\n        'tests/invalid_configs/invalid_config2.yml',\n        'tests/invalid_configs/invalid_config3.yml',\n        'tests/invalid_configs/invalid_config4.yml',\n        'tests/invalid_configs/invalid_config5.yml',\n        'tests/invalid_configs/invalid_config6.yml',\n        'tests/invalid_configs/invalid_config7.yml',\n        'tests/invalid_configs/invalid_config8.yml',\n        'tests/invalid_configs/invalid_config9.yml',\n        'tests/invalid_configs/invalid_config10.yml',\n        'tests/invalid_configs/invalid_config11.yml',\n        'tests/invalid_configs/invalid_config12.yml',\n        'tests/invalid_configs/invalid_config13.yml',\n        'tests/invalid_configs/invalid_config14.yml',\n        'tests/invalid_configs/invalid_config15.yml',\n        'tests/invalid_configs/invalid_config16.yml',\n        'tests/invalid_configs/invalid_config17.yml',\n        'tests/invalid_configs/invalid_config18.yml',\n        'tests/invalid_configs/invalid_config19.yml',\n        'tests/invalid_configs/invalid_config20.yml',\n    ]\n)\ndef test_collect_config_definition_invalid(config_path):\n    config_path = Path(config_path)\n    with pytest.raises(ValidationError):\n        collect_config_definition(config_path=config_path)\n"}
{"type": "test_file", "path": "fastapi_serviceutils/utils/tests/__init__.py", "content": "\"\"\"Utils for testing using pytest.\"\"\"\n"}
{"type": "test_file", "path": "fastapi_serviceutils/utils/tests/endpoints.py", "content": "\"\"\"Helpers to test endpoints with pytest.\"\"\"\nfrom typing import Any\n\nfrom fastapi import FastAPI\nfrom starlette.testclient import TestClient\n\n\ndef json_endpoint(\n        application: FastAPI,\n        endpoint: str,\n        payload: dict = None,\n        expected: Any = None,\n        status_code: int = 200\n):\n    \"\"\"Test endpoint of app with payload.\"\"\"\n    client = TestClient(application)\n    if payload:\n        response = client.post(endpoint, json=payload)\n    else:\n        response = client.post(endpoint)\n\n    assert response.status_code == status_code\n\n    if status_code == 200:\n        result = response.json()\n\n        if expected:\n            assert result == expected\n\n        return result\n    return True\n"}
{"type": "source_file", "path": "docs/_static/exampleservice/app/endpoints/v1/example.py", "content": "from app.endpoints.v1.models import Example as Output\nfrom app.endpoints.v1.models import GetExample as Input\nfrom fastapi import APIRouter\nfrom fastapi import Body\nfrom starlette.requests import Request\n\nfrom fastapi_serviceutils.app import create_id_logger\nfrom fastapi_serviceutils.app import Endpoint\n\nENDPOINT = Endpoint(router=APIRouter(), route='/example', version='v1')\nSUMMARY = 'Example request.'\nEXAMPLE = Body(..., example={'msg': 'some message.'})\n\n\n@ENDPOINT.router.post('/', response_model=Output, summary=SUMMARY)\nasync def example(request: Request, params: Input = EXAMPLE) -> Output:\n    _, log = create_id_logger(request=request, endpoint=ENDPOINT)\n    log.debug(f'received request for {request.url} with params {params}.')\n    return Output(msg=params.msg)\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/__init__.py", "content": "\"\"\"Helpers for fastapi-app especially the endpoint-functions.\n\nInside endpoints defined using fastapi-serviceutils the variable ``ENDPOINTS``\nshould be defined as an instance of :class:`Endpoint`.\n\nFor better traceback inside the logs :func:`create_id_logger` is used inside\nthe endpoint-function.\n\"\"\"\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom fastapi import APIRouter\nfrom loguru._logger import Logger\nfrom starlette.requests import Request\n\nfrom .logger import customize_logging\nfrom .service_config import collect_config_definition\nfrom .service_config import Config\nfrom .service_config import update_config\n\n\n@dataclass\nclass Endpoint:\n    \"\"\"Endpoint as required inside each endpoint module.\n\n    Attributes:\n        router: the router for this endpoint.\n        route: the route to this endpoint (is modified for the app using\n            function\n            :func:`fastapi_serviceutils.app.endpoints.set_version_endpoints`).\n        tags: the tags for the endpoint (used for swagger-documentation).\n        version: the version of the endpoint.\n\n    \"\"\"\n    router: APIRouter\n    route: str\n    tags: List[str] = None\n    version: str = None\n\n\ndef create_request_id(request: Request):\n    \"\"\"Create a request-id baed on the attributes of the passed request.\n\n    Parameters:\n        request: the request to create the id for.\n\n    Returns:\n        the request-id.\n\n    \"\"\"\n    return abs(hash(f'{request.client}{request.headers}{request.body}'))\n\n\ndef create_id_logger(\n        request: Request,\n        endpoint: Endpoint,\n) -> [int,\n      Logger]:\n    \"\"\"Create the request-id and the request-specific logger.\n\n    This function is meant to be used inside an endpoint-function to be able\n    to use a unique request-id in each request for better traceback in the\n    logs.\n\n    Parameters:\n        request: the request to create id and logger.\n        endpoint: the endpoint to extract the logger-function.\n\n    Returns:\n        the request-id and the customized logger.\n\n    \"\"\"\n    request_id = create_request_id(request)\n    log = endpoint.router.logger.bind(request_id=request_id)\n    return request_id, log\n\n\n__all__ = [\n    'collect_config_definition',\n    'Config',\n    'create_id_logger',\n    'create_request_id',\n    'customize_logging',\n    'update_config',\n]\n"}
{"type": "source_file", "path": "docs/_static/exampleservice/app/endpoints/v1/errors.py", "content": "\"\"\"Contain error-messages to be used for the endpoints of v1.\"\"\"\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/endpoints/default/alive.py", "content": "\"\"\"Endpoint to check if service is alive.\"\"\"\nfrom fastapi import APIRouter\nfrom starlette.requests import Request\n\nfrom fastapi_serviceutils.app import create_id_logger\nfrom fastapi_serviceutils.app import Endpoint\nfrom fastapi_serviceutils.app.endpoints.default.models import Alive\n\nENDPOINT = Endpoint(router=APIRouter(), route='/api/alive')\nSUMMARY = 'Check if service is alive.'\n\n\n@ENDPOINT.router.post('/', response_model=Alive, summary=SUMMARY)\nasync def alive(request: Request) -> Alive:\n    \"\"\"Check if service is alive.\n\n    Returns:\n        the information that the service is alive.\n\n    \"\"\"\n    _, log = create_id_logger(request=request, endpoint=ENDPOINT)\n    log.debug(f'received request for endpoint {request.url}.')\n    return Alive(alive=True)\n"}
{"type": "source_file", "path": "docs/_static/exampleservice/app/endpoints/__init__.py", "content": "from app.endpoints.v1 import ENDPOINTS as v1\n\nfrom fastapi_serviceutils.app.endpoints import set_version_endpoints\n\nLATEST = set_version_endpoints(\n    endpoints=v1,\n    version='latest',\n    prefix_template='{route}'\n)\n\nENDPOINTS = LATEST + v1\n\n__all__ = ['ENDPOINTS']\n"}
{"type": "source_file", "path": "docs/_static/exampleservice/app/main.py", "content": "from pathlib import Path\nfrom typing import NoReturn\n\nfrom app import __version__\nfrom app.endpoints import ENDPOINTS\n\nfrom fastapi_serviceutils import make_app\n\napp = make_app(\n    config_path=Path(__file__).with_name('config.yml'),\n    version=__version__,\n    endpoints=ENDPOINTS,\n    enable_middlewares=['trusted_hosts',\n                        'log_exception'],\n    additional_middlewares=[]\n)\n\n\ndef main() -> NoReturn:\n    import uvicorn\n    uvicorn.run(app, host='0.0.0.0', port=app.config.service.port)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"type": "source_file", "path": "docs/_static/exampleservice/app/endpoints/v1/models.py", "content": "from pydantic import BaseModel\n\n\nclass GetExample(BaseModel):\n    msg: str\n\n\nclass Example(BaseModel):\n    msg: str\n\n\n__all__ = ['Example', 'GetExample']\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/endpoints/default/__init__.py", "content": "\"\"\"Contain default endpoints and their models available as routes.\"\"\"\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/handlers/__init__.py", "content": "\"\"\"Available handlers for services based on fastapi_serviceutils.\"\"\"\nimport traceback\nfrom typing import Union\n\nfrom fastapi.exception_handlers import http_exception_handler\nfrom loguru import logger\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom fastapi_serviceutils.app import create_request_id\n\n\nasync def log_exception_handler(\n        request: Request,\n        exc: Union[StarletteHTTPException,\n                   Exception]\n) -> Response:\n    \"\"\"Add log of exception if an exception occur.\"\"\"\n    # add the request_id to the logger to be able to understand what request\n    # caused the exception\n    log = logger.bind(request_id=create_request_id(request))\n\n    if isinstance(exc, StarletteHTTPException):\n        # do not log exception for wrong endpoints\n        if exc.status_code != 404:\n            log.error(\n                'following error occurred: {detail}. {error}'.format(\n                    detail=exc.detail,\n                    error=repr(exc)\n                )\n            )\n        return await http_exception_handler(request, exc)\n\n    # if not already a StarletteHTTPException, convert the exception to it\n    _exception = StarletteHTTPException(\n        status_code=500,\n        detail=traceback.format_exc().split('\\n')\n    )\n    log.error(\n        f'{_exception.detail}\\n '\n        f'request from {request.client} to url {request.url}'\n    )\n    return await http_exception_handler(request, _exception)\n\n\n__all__ = [\n    'log_exception_handler',\n]\n"}
{"type": "source_file", "path": "fastapi_serviceutils/__init__.py", "content": "\"\"\"Contain utils for fastapi based services.\n\nThis contains:\n\n* optimized logging using Loguru\n* optimized exception handling by additional exception handler\n  log_exception handler\n* usage of a config.yml-file to configure the service\n* usage of environment-variables (Environment variable overwrites config-value)\n  to configure the service\n* easily serve the apidoc with the service\n* easy deploment using Docker combined with Docker compose\n* fast creation of new service with create_service\n* Makefile and Tmuxp-config for easier development of services based on\n  fastapi-serviceutils using Make and tmux-session\n\nThis module defines the function :func:`make_app` to create an app containing\nthe above mentioned features.\n\"\"\"\nfrom pathlib import Path\nfrom typing import List\n\nfrom fastapi import FastAPI\nfrom starlette.middleware.trustedhost import TrustedHostMiddleware\n\nfrom .app import collect_config_definition\nfrom .app import Config\nfrom .app import customize_logging\nfrom .app import Endpoint\nfrom .app import update_config\nfrom .app.endpoints import add_default_endpoints\nfrom .app.handlers import log_exception_handler\nfrom .utils.docs import mount_apidoc\nfrom .utils.external_resources.dbs import add_databases_to_app\nfrom .utils.external_resources.services import add_services_to_app\n\n__version__ = '2.1.0'\n\n\ndef include_endpoints_and_middlewares_to_app(\n        app: FastAPI,\n        endpoints: List[Endpoint],\n        enable_middlewares: List[str],\n        additional_middlewares: list\n) -> FastAPI:\n    \"\"\"Include endpoints and middlewares (and defaults) to app.\n\n    Note:\n        :func:`log_exception_handler` is not really a middleware but if\n        it should be enabled, ``'log_exception'`` should be included in\n        ``enable_middlewares``.\n\n    Note:\n        A router included by this function has additional attributes:\n\n        * ``router.mode``\n        * ``router.config``\n        * ``router.logger``\n        * ``router.databases``\n        * ``router.services``\n\n    Parameters:\n        app: the app to add the endpoints and middlewares.\n        endpoints: the endpoints to include into the app.\n        enable_middlewares: the default middlewares to enable.\n        additional_middlewares: additional middlewares to add to the app.\n\n    Returns:\n        the modified app containing the endpoints, middlewares and handlers.\n\n    \"\"\"\n    # iterate over endpoints, define additional attributes required inside the\n    # endpoints and include the endpoint to the router of the app.\n    for endpoint in endpoints:\n        endpoint.router.mode = app.mode\n        endpoint.router.config = app.config\n        endpoint.router.logger = app.logger\n        endpoint.router.databases = app.databases\n        endpoint.router.services = app.services\n        if endpoint.tags:\n            app.include_router(\n                endpoint.router,\n                prefix=endpoint.route,\n                tags=endpoint.tags\n            )\n        else:\n            app.include_router(endpoint.router, prefix=endpoint.route)\n\n    # add the apidoc to app\n    if app.config.service.apidoc_dir:\n        mount_apidoc(app=app)\n\n    # add middleware to be able to limit access to service to specific hosts\n    if 'trusted_hosts' in enable_middlewares:\n        app.add_middleware(\n            TrustedHostMiddleware,\n            allowed_hosts=app.config.service.allowed_hosts\n        )\n\n    # add custom exception handler to log exceptions\n    if 'log_exception' in enable_middlewares:\n        app.exception_handler(Exception)(log_exception_handler)\n\n    # add additional defined middlewares\n    # TODO: in future releases the addition of more complex middlewares should\n    # be possible\n    for middleware in additional_middlewares:\n        app.add_middleware(middleware)\n\n    return app\n\n\ndef make_app(\n        config_path: Path,\n        version: str,\n        endpoints: List[Endpoint],\n        enable_middlewares: List[str],\n        additional_middlewares: list,\n) -> FastAPI:\n    \"\"\"Create app with endpoints and middlewares.\n\n    App is configured using the config of the service and defined\n    environment-variables.\n    Also logger is configured and default endpoints and additional endpoints\n    added.\n    Same for middlewares.\n\n    Note:\n        An app created by this function has additional attributes:\n\n        * ``app.logger``\n        * ``app.config``\n        * ``app.databases``\n        * ``app.services``\n        * ``app.mode``\n\n    Parameters:\n        config_path: the path for the config file to use for the app.\n        version: current version of the service, should be ``__version__``\n            variable inside the module ``app`` of your service.\n        endpoints: the endpoints to include to the app.\n        enable_middlewares: list of the middlewares to add.\n        additional_middlewares: list of non default middlewares to add to the\n            app.\n\n    Returns:\n        the created app.\n\n    \"\"\"\n    # load the config and environment-variables for the service and\n    # combine these information to initialize the app\n    config = collect_config_definition(config_path=config_path)\n\n    # update mode and logger-definitions with environment-variables if defined\n    # ATTENTION: the environment-variable has the prefix of the servicename\n    config = update_config(\n        env_vars=config.available_environment_variables.env_vars,\n        external_resources_env_vars=(\n            config.available_environment_variables.external_resources_env_vars\n        ),\n        rules_env_vars=config.available_environment_variables.rules_env_vars,\n        config=config,\n        model=Config,\n    )\n\n    # convert config-attribute types if necessary\n    config.logger.path = Path(config.logger.path)\n    config.service.readme = Path(config.service.readme)\n\n    # initialize the app, add combined configuration, mode and logger\n    app = FastAPI(\n        title=f'{config.service.name} [{config.service.mode.upper()}]',\n        description=config.service.readme.read_text(),\n        version=version,\n    )\n\n    # add additional attributes to the app like the config and the runtime-mode\n    app.config = config\n    app.mode = config.service.mode\n\n    # Set the logging-configuration\n    app.logger = customize_logging(\n        config.logger.path / config.logger.filename.format(mode=app.mode),\n        level=config.logger.level,\n        retention=config.logger.retention,\n        rotation=config.logger.rotation,\n        _format=config.logger.format\n    )\n\n    # if dependencies for external databases are defined in the config, add\n    # these database-definitions to the app\n    if config.external_resources.databases:\n        app = add_databases_to_app(\n            app,\n            dbs=config.external_resources.databases\n        )\n    else:\n        app.databases = {}\n\n    # if dependencies for external services are defined in the config, add\n    # these service-definitions to the app\n    if config.external_resources.services:\n        app = add_services_to_app(\n            app,\n            services=config.external_resources.services\n        )\n    else:\n        app.services = {}\n\n    # add default endpoints if defined in the config\n    endpoints = add_default_endpoints(endpoints=endpoints, config=app.config)\n\n    # include defined routers and middlewares to the app\n    return include_endpoints_and_middlewares_to_app(\n        app=app,\n        endpoints=endpoints,\n        enable_middlewares=enable_middlewares,\n        additional_middlewares=additional_middlewares\n    )\n\n\n__all__ = ['make_app', 'include_endpoints_and_middlewares_to_app']\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/endpoints/default/models.py", "content": "\"\"\"Contain not version depending models for default-endpoints of service.\n\nFor each endpoint requiring parameters as input on call an input-model should\nbe defined here.\n\nFor each endpoint returning data on call an output-model should be defined\nhere, too.\n\nCurrently both default-endpoints do not require input-parameters, so no\ninput-models are defined here yet.\n\nThe config-endpoint returns data of model\n:class:`fastapi_serviceutils.app.service_config.Config` so this one is not\ndefined here, because already defined.\n\nThe alive-endpoint returns data of model :class:`Alive`.\n\"\"\"\nfrom pydantic import BaseModel\n\n\nclass Alive(BaseModel):\n    \"\"\"Represent the alive-result of the endpoint ``/api/alive``.\"\"\"\n    alive: bool\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/endpoints/__init__.py", "content": "\"\"\"Endpoint registration and configuration helpers.\n\nAlso includes default endpoint handling.\n\"\"\"\nimport copy\nfrom typing import List\n\nfrom fastapi_serviceutils.app import Endpoint\nfrom fastapi_serviceutils.app.endpoints.default import alive as alive_endpoint\nfrom fastapi_serviceutils.app.endpoints.default import config as config_endpoint\nfrom fastapi_serviceutils.app.service_config import Config\n\n\ndef set_version_endpoints(\n        endpoints: List[Endpoint],\n        version: str,\n        prefix_template: str,\n        **kwargs: dict\n) -> List[Endpoint]:\n    \"\"\"Configures the endpoints inside a version-module.\n\n    Modify the route to the correct route using the ``route``-attribute of\n    each endpoint and modify it using the passed prefix_template in\n    combination with the passed kwargs.\n\n    Also used to set the ``'latest'`` endpoints.\n\n    Parameters:\n        endpoints: the endpoints to set the version and correct route.\n        version: the version to set for the endpoints.\n        prefix_template: the template to use for the resulting route.\n        kwargs: additional kwargs required by the prefix_template. As default\n            the following keys inside kwargs are already set:\n\n            * ``route``\n            * ``version``\n\n            So these can already be used inside the prefix_template.\n\n    Returns:\n        the resulting endpoints.\n\n    \"\"\"\n    version_endpoints = []\n    if not kwargs:\n        kwargs = {}\n    else:\n        kwargs = copy.deepcopy(kwargs)\n\n    for endpoint_definition in endpoints:\n        if isinstance(endpoint_definition, Endpoint):\n            endpoint = Endpoint(\n                route=endpoint_definition.route,\n                router=endpoint_definition.router,\n                version=endpoint_definition.version\n            )\n        else:\n            endpoint = Endpoint(\n                route=endpoint_definition.ENDPOINT.route,\n                router=endpoint_definition.ENDPOINT.router,\n                version=endpoint_definition.ENDPOINT.version\n            )\n        endpoint.tags = [version]\n        if version == 'latest':\n            route = endpoint.route.replace(\n                endpoint_definition.version,\n                version\n            )\n        else:\n            route = endpoint.route\n        kwargs.update({'route': route, 'version': version})\n        endpoint.version = version\n        endpoint.route = prefix_template.format(**kwargs)\n        version_endpoints.append(endpoint)\n    return version_endpoints\n\n\ndef add_default_endpoints(endpoints: List[Endpoint],\n                          config: Config) -> List[Endpoint]:\n    \"\"\"Add default endpoints to existing endpoints.\n\n    Currently the following default-endpoints are available:\n\n    * ``'alive``\n    * ``'config'``\n\n    Parameters:\n        endpoints: the already set endpoints to add the default ones.\n        config: the config of the service to extract the information which\n            default-endpoints to add.\n\n    Returns:\n        the passed endpoints with added default endpoints.\n\n    \"\"\"\n    default_endpoints = {\n        'alive': alive_endpoint.ENDPOINT,\n        'config': config_endpoint.ENDPOINT\n    }\n\n    for endpoint in config.service.use_default_endpoints:\n        current = default_endpoints[endpoint]\n        current.tags = ['status']\n        endpoints.append(current)\n    return endpoints\n\n\n__all__ = ['add_default_endpoints', 'set_version_endpoints']\n"}
{"type": "source_file", "path": "docs/conf.py", "content": "# -*- coding: utf-8 -*-\n\"\"\"Contain the configuration for the sphinx-documentation of the service.\"\"\"\n\nproject = 'fastapi-serviceutils'\ncopyright = '2019, Simon Kallfass (MIT-License)'\nauthor = 'Simon Kallfass'\nrelease = version = '2.0.0'\n\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.napoleon',\n    'sphinx_autodoc_typehints',\n    'sphinx.ext.viewcode',\n    'sphinx_rtd_theme'\n]\n\ntemplates_path = ['_templates']\n\nexclude_patterns = [\n    '_build',\n    'Thumbs.db',\n    '.DS_Store',\n    'api/modules.rst',\n]\n\nhtml_theme = 'sphinx_rtd_theme'\npygments_style = 'solarized-dark'\n\nhtml_static_path = ['_static']\n\nhtml_logo = '_static/logo.png'\nhtml_theme_options = {\n    'canonical_url': '',\n    'analytics_id': '',\n    'logo_only': False,\n    'display_version': True,\n    'prev_next_buttons_location': 'bottom',\n    'style_external_links': False,\n    'collapse_navigation': False,\n    'sticky_navigation': True,\n    'navigation_depth': 5,\n    'includehidden': True,\n    'titles_only': False\n}\n\nintersphinx_mapping = {\n    'python': ('https://docs.python.org/3',\n               None),\n}\n\nnapoleon_google_docstring = True\nnapoleon_numpy_docstring = False\nnapoleon_include_init_with_doc = True\nnapoleon_use_param = True\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/endpoints/default/config.py", "content": "\"\"\"Endpoint to return currently used configuration of the service.\"\"\"\nfrom fastapi import APIRouter\nfrom starlette.requests import Request\n\nfrom fastapi_serviceutils.app import Config\nfrom fastapi_serviceutils.app import create_id_logger\nfrom fastapi_serviceutils.app import Endpoint\n\nENDPOINT = Endpoint(router=APIRouter(), route='/api/config')\nSUMMARY = 'Get currently used config.'\n\n\n@ENDPOINT.router.post('/', response_model=Config, summary=SUMMARY)\nasync def get_config(request: Request) -> Config:\n    \"\"\"Get currently used config of the service.\n\n    Returns:\n        the content of the currently used config.\n\n    \"\"\"\n    _, log = create_id_logger(request=request, endpoint=ENDPOINT)\n    log.debug(f'received request for endpoint {request.url}.')\n    return Config.parse_raw(ENDPOINT.router.config.json())\n"}
{"type": "source_file", "path": "docs/_static/exampleservice/app/endpoints/v1/__init__.py", "content": "from app.endpoints.v1 import example\n\nfrom fastapi_serviceutils.app.endpoints import set_version_endpoints\n\nENDPOINTS = set_version_endpoints(\n    endpoints=[example],\n    version='v1',\n    prefix_template='/api/{version}{route}'\n)\n\n__all__ = ['ENDPOINTS']\n"}
{"type": "source_file", "path": "docs/_static/exampleservice/app/__init__.py", "content": "__version__ = '0.1.0'\n"}
{"type": "source_file", "path": "fastapi_serviceutils/utils/docs/apidoc.py", "content": "\"\"\"Apidoc related functions.\n\nContain function to mount the apidoc at route ``/apidoc`` to the service.\n\"\"\"\nimport logging\nfrom typing import NoReturn\n\nfrom fastapi import FastAPI\nfrom starlette.staticfiles import StaticFiles\n\n\ndef mount_apidoc(app: FastAPI) -> NoReturn:\n    \"\"\"Mount the apidoc at defined documentation_dir if it exists.\n\n    Parameters:\n        app: the app to mount the apidoc to.\n\n    \"\"\"\n    apidoc_dir = app.config.service.apidoc_dir\n    try:\n        app.mount('/apidoc', StaticFiles(directory=apidoc_dir), name='apidoc')\n        logging.debug('Mounted apidoc')\n    except RuntimeError:\n        logging.warning(f'no doc-folder at {apidoc_dir} to serve at /apidoc')\n\n\n__all__ = ['mount_apidoc']\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/middlewares/__init__.py", "content": "\"\"\"Middlewares available for fastapi- / starlette-based services.\"\"\"\n"}
{"type": "source_file", "path": "fastapi_serviceutils/utils/external_resources/services.py", "content": "\"\"\"Interact with external services.\"\"\"\nimport logging\nfrom typing import Dict\n\nimport requests\nfrom fastapi import FastAPI\nfrom fastapi import HTTPException\nfrom pydantic import BaseModel\nfrom pydantic import ValidationError\n\n\nclass ServiceDefinition(BaseModel):\n    \"\"\"Definition for a service as defined in ``config.yml:external_resources``.\n\n    Attributes:\n        name: the name of the service.\n        url: the url to the endpoint of the service.\n        servicetype: the type of the service (currently only rest is\n            supported.)\n\n    \"\"\"\n    name: str\n    url: str\n    servicetype: str\n\n\nasync def _convert_response_to_model(\n        model: BaseModel,\n        response,\n        info_msg: str\n) -> BaseModel:\n    \"\"\"Extract request-result and convert it into an instance of ``model``.\n\n    Parameters:\n        model: the model to convert the service-result into.\n        response: the result of the made service-call.\n        info_msg: the message to return if something goes wrong during\n            conversion to the model.\n\n    Raises:\n        if something goes wrong during conversion to the model a\n        :class:`HTTPException` is raised.\n\n    Returns:\n        the service-call response converted to an instance of model.\n\n    \"\"\"\n    try:\n        result = response.json()\n        return model.parse_obj(result)\n    except ValidationError as error:\n        raise HTTPException(\n            status_code=500,\n            detail=(\n                f'{info_msg} => Invalid result: {response}. Error was {error}.'\n            )\n        )\n\n\nasync def _check_response_status(response, info_msg: str):\n    \"\"\"Check if the status of the response is valid.\n\n    Parameters:\n        response: the result of the made service-call.\n        info_msg: the message to return if something goes wrong during\n            service-call.\n\n    Raises:\n        if response has an invalid status-code a :class:`HTTPException` is\n        raised.\n\n    \"\"\"\n    try:\n        response.raise_for_status()\n    except requests.HTTPError as error:\n        raise HTTPException(\n            status_code=500,\n            detail=f'{info_msg} => Could not make request. Error was {error}.'\n        )\n\n\nasync def _make_external_rest_request(\n        url: str,\n        method: str,\n        params: dict,\n        info_msg: str\n):\n    \"\"\"Request external service at ``url`` using ``method`` with ``params``.\n\n    Parameters:\n        url: the url to the service-endpoint to use.\n        method: the service-method to use. Supported are ``get`` and ``post``.\n        params: the request-params for the service-call.\n        info_msg: the message to return if something goes wrong during\n            service-call.\n\n    Raises:\n        an instance of :class:`HTTPException` if something goes wrong during\n        service-call.\n\n    Returns:\n        the result of the service-call.\n\n    \"\"\"\n    method_mapping = {\n        'post': requests.post,\n        'get': requests.get,\n    }\n    try:\n        if params:\n            return method_mapping[method](url, params=params)\n        return method_mapping[method](url)\n    except requests.ConnectionError as error:\n        raise HTTPException(\n            status_code=500,\n            detail=f'{info_msg} => Could not connect! Error was {error}.'\n        )\n\n\nasync def call_service(\n        url: str,\n        model: BaseModel,\n        params: dict = None,\n        method: str = 'post',\n) -> BaseModel:\n    \"\"\"Call the rest-service at the ``url`` using ``method`` with ``params``.\n\n    The result of the service-call is converted to an instance of ``model``.\n    If any error occur this function will raise an\n    :class:`HTTPException`.\n\n    Parameters:\n        url: the url of the service to call.\n        model: the model to convert the service-result into.\n        params: the params to use for the request.\n        method: the method to use to make the service-call.\n\n    Returns:\n        the service-result as an instance of the defined ``model``.\n\n    Raises:\n        if any error occur a :class:`HTTPException` will be raised.\n\n    \"\"\"\n    info_msg = (\n        f'external service call (url: {url}, method: {method.upper()}, '\n        f'params: {params})'\n    )\n\n    logging.debug(info_msg)\n\n    # make the request for the url with params using method\n    response = await _make_external_rest_request(\n        url=url,\n        method=method,\n        params=params,\n        info_msg=info_msg\n    )\n\n    # check if the request worked as expected\n    await _check_response_status(response=response, info_msg=info_msg)\n\n    # convert the result of the request to an instance of model\n    result = await _convert_response_to_model(\n        model=model,\n        response=response,\n        info_msg=info_msg\n    )\n    logging.debug(f'{info_msg} => returned result {result}.')\n    return result\n\n\ndef add_services_to_app(\n        app: FastAPI,\n        services: Dict[str,\n                       ServiceDefinition]\n) -> FastAPI:\n    \"\"\"Add instances of :class:`ServiceDefinition` as attribute of app.\n\n    For each service as defined in the ``config.yml`` as external-resource,\n    create a :class:`ServiceDefinition` instance with defined parameters, add\n    this instance to the ``app.services``-attribute.\n\n    Parameters:\n        app: the app to add the services as dependencies.\n        services: the services to add to the app.\n\n    Returns:\n        modified app containing the attribute ``services`` to interact with\n        the services inside the endpoints.\n\n    \"\"\"\n    for service_name, service_definition in services.items():\n        service = ServiceDefinition(\n            url=service_definition.url,\n            name=service_name,\n            servicetype=service_definition.servicetype\n        )\n        try:\n            app.services.update({service_name: service})\n        except AttributeError:\n            app.services = {service_name: service}\n    return app\n\n\n__all__ = ['add_services_to_app', 'call_service', 'ServiceDefinition']\n"}
{"type": "source_file", "path": "fastapi_serviceutils/utils/__init__.py", "content": "\"\"\"Utils for services based on fastapi and fastapi-serviceutils.\n\nThis include to serve an endpoint for the apidoc, the usage of\nexternal-resources and testutils.\n\"\"\"\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/logger.py", "content": "\"\"\"Contain helpers to customize logging for the service.\"\"\"\nimport logging\nimport sys\nfrom pathlib import Path\n\nfrom loguru import logger\n\n\nclass _InterceptHandler(logging.Handler):\n    loglevel_mapping = {\n        50: 'CRITICAL',\n        40: 'ERROR',\n        30: 'WARNING',\n        20: 'INFO',\n        10: 'DEBUG',\n        0: 'NOTSET',\n    }\n\n    def emit(self, record):\n        # Get corresponding Loguru level if it exists\n        try:\n            level = logger.level(record.levelname).name\n        except AttributeError:\n            level = self.loglevel_mapping[record.levelno]\n\n        # Find caller from where originated the logging call\n        frame, depth = logging.currentframe(), 2\n        while frame.f_code.co_filename == logging.__file__:\n            frame = frame.f_back\n            depth += 1\n\n        log = logger.bind(request_id='app')\n        log.opt(\n            depth=depth,\n            exception=record.exc_info\n        ).log(level,\n              record.getMessage())\n\n\ndef customize_logging(\n        filepath: Path,\n        level: str,\n        rotation: str,\n        retention: str,\n        _format: str\n):\n    \"\"\"Define the logger to be used by the service based on loguru.\n\n    Parameters:\n        filepath: the path where to store the logfiles.\n        level: the minimum log-level to log.\n        rotation: when to rotate the logfile.\n        retention: when to remove logfiles.\n        _format: the logformat to use.\n\n    Returns:\n        the logger to be used by the service.\n\n    \"\"\"\n    filepath.parent.mkdir(parents=True, exist_ok=True)\n\n    logger.remove()\n    logger.add(\n        sys.stdout,\n        enqueue=True,\n        backtrace=True,\n        level=level.upper(),\n        format=_format\n    )\n    logger.add(\n        str(filepath),\n        rotation=rotation,\n        retention=retention,\n        enqueue=True,\n        backtrace=True,\n        level=level.upper(),\n        format=_format\n    )\n    logging.basicConfig(handlers=[_InterceptHandler()], level=0)\n    for _log in ['uvicorn',\n                 'uvicorn.error',\n                 'fastapi',\n                 'sqlalchemy',\n                 'databases']:\n        _logger = logging.getLogger(_log)\n        _logger.handlers = [_InterceptHandler()]\n\n    return logger.bind(request_id='app')\n\n\n__all__ = [\n    'customize_logging',\n]\n"}
{"type": "source_file", "path": "fastapi_serviceutils/cli/create_service.py", "content": "\"\"\"Create new service using the fastapi_serviceutils-template.\n\nFor this functionality we use Cookiecutter.\n\"\"\"\nimport sys\nfrom argparse import ArgumentParser\nfrom argparse import Namespace\nfrom pathlib import Path\nfrom string import ascii_letters\nfrom string import digits\n\nfrom cookiecutter import generate\nfrom cookiecutter.exceptions import OutputDirExistsException\nfrom cookiecutter.vcs import clone\nfrom toolz import curry\n\n\ndef _check_name(name: str, variable_name: str) -> bool:\n    \"\"\"Check if the passed ``name`` doesn't include invalid chars.\"\"\"\n    allowed_chars = (f'{str(set(ascii_letters.lower()))}_{digits}')\n    try:\n        assert all(_ in allowed_chars for _ in name)\n        assert ' ' not in name\n    except AssertionError:\n        print('!!! Creation of service skipped!!!')\n        print(f'Invalid {variable_name}: {name}!')\n        print('Only ascii-letters and numbers are allowed!')\n        sys.exit(1)\n    try:\n        assert not any(name.startswith(_) for _ in digits)\n    except AssertionError:\n        print('!!! Creation of service skipped!!!')\n        print(f'Invalid {variable_name}: {name}!')\n        print('Must not start with number!')\n        sys.exit(1)\n    return name\n\n\ndef _build_arguments(args) -> Namespace:\n    \"\"\"Create required arguments for create_service.\"\"\"\n    parser = ArgumentParser(\n        description=(\n            'create new service based on fastapi using fastapi_serviceutils.'\n        )\n    )\n    parser.add_argument(\n        '-n',\n        '--service_name',\n        type=curry(_check_name,\n                   variable_name='service_name'),\n        required=True,\n        help=(\n            'the name of the service to create. '\n            'ATTENTION: only ascii-letters, \"_\" and digits are allowed. '\n            'Must not start with a digit!'\n        )\n    )\n    parser.add_argument(\n        '-p',\n        '--service_port',\n        type=str,\n        required=True,\n        default='50001',\n        help='the port for the service to listen.'\n    )\n    parser.add_argument(\n        '-a',\n        '--author',\n        type=str,\n        required=True,\n        help='the name of the author of the service.'\n    )\n    parser.add_argument(\n        '-e',\n        '--author_email',\n        type=str,\n        required=True,\n        help='the email of the author of the service.'\n    )\n    parser.add_argument(\n        '-ep',\n        '--endpoint',\n        type=curry(_check_name,\n                   variable_name='endpoint'),\n        required=True,\n        help=(\n            'the name of the endpoint for the service to create. '\n            'ATTENTION: only lower ascii-letters, \"_\" and digits are allowed. '\n            'Must not start with a digit!'\n        )\n    )\n    parser.add_argument('-o', '--output_dir', required=True, type=Path)\n    return parser.parse_args(args)\n\n\ndef _create_service_folder(\n        repo_url: str,\n        context: dict,\n        output_dir: str,\n        clone_to_dir: str = '/tmp'\n) -> bool:\n    \"\"\"Clone the template and create service-folder based on this template.\"\"\"\n    filepath = clone(repo_url, clone_to_dir=clone_to_dir, no_input=True)\n    try:\n        generate.generate_files(\n            filepath,\n            context=context,\n            output_dir=output_dir,\n            overwrite_if_exists=False\n        )\n    except OutputDirExistsException:\n        print('Folder already exists!')\n        print('Skipped creation of new service!')\n        return False\n    return True\n\n\ndef _create_context(params: Namespace):\n    \"\"\"Create the context required for :func:`generate.generate_files`.\"\"\"\n    return {\n        'cookiecutter': {\n            'service_name': params.service_name,\n            'service_port': params.service_port,\n            'author': params.author,\n            'author_email': params.author_email,\n            'endpoint': params.endpoint\n        }\n    }\n\n\ndef main():\n    \"\"\"Combine required parameters, clone the template, create the service.\"\"\"\n    repo_url = 'https://github.com/skallfass/fastapi_serviceutils_template.git'\n    params = _build_arguments(sys.argv[1:])\n    create_service_result = _create_service_folder(\n        repo_url=repo_url,\n        context=_create_context(params),\n        output_dir=str(params.output_dir)\n    )\n    if not create_service_result:\n        sys.exit(1)\n    print('Service creation successful.')\n    print(f'Service is at {params.output_dir}')\n\n\nif __name__ == '__main__':\n    main()\n"}
{"type": "source_file", "path": "fastapi_serviceutils/cli/__init__.py", "content": "\"\"\"Helpers for fastapi-serviceutils based services.\n\nModules and functions defined in this subpackage are meant to be used after\ninstalling fastapi-serviceutils using the entrypoints for these functions.\n\nFor example to create a new service run the following command in shell:\n\n.. code:: bash\n\n    create_service --help\n\"\"\"\n"}
{"type": "source_file", "path": "fastapi_serviceutils/utils/external_resources/__init__.py", "content": "\"\"\"Helpers to interact with external resources like databases and services.\"\"\"\n"}
{"type": "source_file", "path": "fastapi_serviceutils/utils/docs/__init__.py", "content": "\"\"\"Helpers for apidocs.\"\"\"\nfrom .apidoc import mount_apidoc\n\n__all__ = ['mount_apidoc']\n"}
{"type": "source_file", "path": "fastapi_serviceutils/app/service_config.py", "content": "\"\"\"Collect config for service and convert to instance of :class:`Config`.\"\"\"\nimport copy\nimport os\nfrom pathlib import Path\nfrom typing import Dict\nfrom typing import List\nfrom typing import NoReturn\nfrom typing import Union\n\nimport yaml\nfrom pydantic import BaseModel\nfrom pydantic.dataclasses import dataclass\nfrom toolz.dicttoolz import update_in\n\nfrom fastapi_serviceutils.utils.external_resources.dbs import DatabaseDefinition\nfrom fastapi_serviceutils.utils.external_resources.services import ServiceDefinition\n\n\nclass AvailableEnvironmentVariables(BaseModel):\n    \"\"\"Represent section of available environment variables in config.\"\"\"\n    env_vars: List[str]\n    external_resources_env_vars: List[str]\n    rules_env_vars: List[str]\n\n\nclass ServiceConfig(BaseModel):\n    \"\"\"Represent configuration of the service inside the config.\n\n    Attributes:\n        name: the name of the service.\n        mode: the runtime-mode of the service.\n        port: port to use for service.\n        description: short description of the service.\n        documentation_dir: path where the documentation dir for the apidoc\n            is located.\n        readme: path to the readme-file to integrate into the\n            swagger-documentation.\n\n    \"\"\"\n    name: str\n    mode: str\n    port: int\n    description: str\n    apidoc_dir: str\n    readme: str\n    allowed_hosts: List[str]\n    use_default_endpoints: List[str]\n\n\nclass LoggerConfig(BaseModel):\n    \"\"\"Represent configuration of logger inside the config.\n\n    Attributes:\n        path: folder where the log-files should be saved.\n        filename: the name of the log-file to use.\n        level: the minimum log-level to log.\n        rotation: when to rotate the log-file.\n        retention: how long to keep log-files.\n        format: log-format to use.\n\n    \"\"\"\n    path: str\n    filename: str\n    level: str\n    rotation: str\n    retention: str\n    format: str\n\n\n@dataclass\nclass ExternalResources:\n    \"\"\"Represent the definition of external-resources inside the config.\"\"\"\n    databases: Dict[str, DatabaseDefinition] = None\n    services: Dict[str, ServiceDefinition] = None\n    other: dict = None\n\n    def __post_init__(self) -> NoReturn:\n        if self.databases:\n            for name, attributes in self.databases.items():\n                self.databases.update(\n                    {\n                        name:\n                        DatabaseDefinition(\n                            name=name,\n                            dsn=attributes['dsn'],\n                            databasetype=attributes['databasetype']\n                        )\n                    }\n                )\n        if self.services:\n            for name, attributes in self.services.items():\n                self.services.update(\n                    {\n                        name:\n                        ServiceDefinition(\n                            name=name,\n                            url=attributes['url'],\n                            servicetype=attributes['servicetype']\n                        )\n                    }\n                )\n\n    def __post_init_post_parse__(self):\n        object.__delattr__(self, '__initialised__')\n\n\nclass Config(BaseModel):\n    \"\"\"Represent config-content to configure service and its components.\n\n    Attributes:\n        service: general information about service, like name, where to find\n            the readme, documentation-dir, etc.\n        logger: configuration for the logger of the service.\n        external_resources: if service depends on external-resources,\n            this includes for example the url of such a dependency, etc.\n        rules: special rules for the service.\n\n    \"\"\"\n    service: ServiceConfig\n    logger: LoggerConfig\n    available_environment_variables: AvailableEnvironmentVariables\n    external_resources: ExternalResources\n    rules: dict = None\n\n\ndef collect_config_definition(config_path: Path) -> Config:\n    \"\"\"Collect the config for the service.\n\n    Then convert its content to an instance of :class:`Config`.\n\n    Parameters:\n        config_path: the path of the config-file to use.\n\n    Returns:\n        the content of the config-file converted to an instance of\n        :class:`Config`.\n\n    \"\"\"\n    return Config(**yaml.safe_load(config_path.read_text()))\n\n\ndef _update_value_in_nested_dict_by_keylist(\n        dictionary: dict,\n        key_list: List[str],\n        new_value\n) -> dict:\n    \"\"\"Update the value of a nested-dictionary by a keylist with new value.\n\n    Wrapper around :func:`toolz.dicttoolz.update_in`.\n\n    Note:\n        Do not update the original dict, returns a new dict with same content\n        as original dict, but with update and required location.\n\n    Parameters:\n        dictionary: the dictionary to update.\n        key_list: list of subkeys where to update the dictionary.\n        new_value: the new value to update to.\n\n    Returns:\n        the updated dictionary.\n\n    \"\"\"\n    return update_in(dictionary, key_list, lambda x: new_value)\n\n\ndef _use_environment_variable_for_variable(\n        config: Union[Config,\n                      dict],\n        keys: List[str],\n        model: BaseModel,\n        content_env_var: Union[str,\n                               int,\n                               float,\n                               None],\n) -> Union[BaseModel,\n           dict]:\n    \"\"\"Overwrite config with value of environment-variable.\n\n    To be able to overwrite the config it must be converted to a dict (if it is\n    not already). After updating the value it has to be converted back to an\n    instance of the passed ``model``.\n\n    Parameters:\n        config: the config to update.\n        keys: sublevels for the config to set the value.\n        model: the model to convert back the config after update.\n        content_env_var: the content of the environment-variable.\n        env_var_name: the name of the variable.\n\n    Returns:\n        the updated config.\n\n    \"\"\"\n    if isinstance(config, dict):\n        temp_config = copy.deepcopy(config)\n    else:\n        temp_config = copy.deepcopy(config.dict())\n\n    temp_config = _update_value_in_nested_dict_by_keylist(\n        dictionary=temp_config,\n        key_list=keys,\n        new_value=content_env_var\n    )\n\n    if model:\n        return model.parse_obj(temp_config)\n\n    return temp_config\n\n\ndef _update_config_with_environment_variables(\n        servicename: str,\n        environment_variable_names: List[str],\n        config: Union[Config,\n                      dict],\n        model: BaseModel = None\n) -> Union[BaseModel,\n           dict]:\n    \"\"\"Update the config if environment-variables exist.\n\n    If an environment variable exist, overwrite the value in the config with\n    the value of the environment-variable.\n\n    Finally store into ``info`` if original config-value is used or\n    environment-variable.\n\n    Parameters:\n        servicename: the name of the service.\n        environment_variable_name: the name of the environment-variable to\n            check and use if set.\n        config: the config containing the value to use / the config to\n            overwrite with the value of the environment-variable.\n        model: the model of the config to use.\n\n    Returns:\n        the updated config.\n\n    \"\"\"\n    for environment_variable_name in environment_variable_names:\n        env_var_name = f'{servicename}_{environment_variable_name}'\n        keys = env_var_name.replace(f'{servicename}_', '').lower().split('__')\n        content_env_var = os.environ.get(env_var_name)\n\n        if content_env_var:\n            # overwrite config with the value of the environment-variable\n            config = _use_environment_variable_for_variable(\n                config=config,\n                keys=keys,\n                model=model,\n                content_env_var=content_env_var,\n            )\n    return config\n\n\ndef update_config(\n        config: Config,\n        model: BaseModel,\n        env_vars: List[str] = None,\n        external_resources_env_vars: List[str] = None,\n        rules_env_vars: List[str] = None,\n) -> Config:\n    \"\"\"Update config with environment-variables if defined.\n\n    Parameters:\n        config: the config to update.\n        model: the model of the config.\n        env_vars: the environment-variables to use.\n        external_resources_env_vars: the environment-variables for\n            external-resource configuration.\n        rules_env_vars: the environment-variables for rules configuration.\n\n    Returns:\n        the updated config.\n\n    \"\"\"\n    servicename = config.service.name.upper()\n    # update mode and logger-definitions with environment-variables if defined\n    # ATTENTION: the environment-variable has the prefix of the servicename\n    if env_vars:\n        config = _update_config_with_environment_variables(\n            servicename=servicename,\n            environment_variable_names=env_vars,\n            config=config,\n            model=model,\n        )\n\n    # load special environment variables which can't be accessed by converting\n    # the config to a dict.\n    # ATTENTION: like above the environment-variable has the prefix of the\n    # servicename\n    if external_resources_env_vars:\n        config.external_resources = _update_config_with_environment_variables(\n            servicename=servicename,\n            environment_variable_names=external_resources_env_vars,\n            config=config.external_resources,\n        )\n\n    # load special environment variables which can't be accessed by converting\n    # the config to a dict.\n    # ATTENTION: like above the environment-variable has the prefix of the\n    # servicename\n    if rules_env_vars:\n        config.rules = _update_config_with_environment_variables(\n            servicename=servicename,\n            environment_variable_names=rules_env_vars,\n            config=config.rules,\n        )\n    return config\n\n\n__all__ = [\n    'collect_config_definition',\n    'Config',\n    'update_config',\n]\n"}
{"type": "source_file", "path": "fastapi_serviceutils/utils/external_resources/dbs.py", "content": "\"\"\"Functions and classes to use databases as external_resources in service.\"\"\"\nfrom dataclasses import dataclass\nfrom typing import Dict\n\nimport databases\nimport sqlalchemy\nfrom fastapi import FastAPI\nfrom loguru._logger import Logger\nfrom pydantic import BaseModel\nfrom sqlalchemy.engine.base import Engine\nfrom sqlalchemy.sql.schema import MetaData\n\n\nclass DatabaseDefinition(BaseModel):\n    \"\"\"Used by ``config.yml:external_resources`` to define db-dependency.\n\n    Attributes:\n        name: the name of the database.\n        dsn: the connection string for the database.\n        databasetype: the type of the database (currently only postgres\n            supported).\n        min_size: the minimum connections to open to the database.\n        max_size: the maximum connections to open to the database.\n\n    \"\"\"\n    name: str\n    dsn: str\n    databasetype: str\n    min_size: int = 5\n    max_size: int = 20\n\n\n@dataclass\nclass Database:\n    \"\"\"Class to interact with database as defined in external_resources.\n\n    Attributes:\n        dsn: the connection string for the database.\n        logger: the logger to use inside this class.\n        min_size: the minimum connections to open to the database.\n        max_size: the maximum connections to open to the database.\n        engine: the sqlalchemy engine to use.\n        meta: the sqlalchemy metadata to use.\n        dbase: the instance of :class:`databases.Database` to use for this\n            database.\n\n    \"\"\"\n    dsn: str\n    logger: Logger\n    min_size: int\n    max_size: int\n    engine: Engine = None\n    meta: MetaData = None\n    dbase: databases.Database = None\n\n    def __post_init__(self):\n        \"\"\"Set attributes ``self.dbase``, ``self.engine`` and ``self.meta``.\"\"\"\n        self.dbase = databases.Database(\n            self.dsn,\n            min_size=self.min_size,\n            max_size=self.max_size\n        )\n        self.engine, self.meta = self.get_engine_metadata()\n\n    def get_engine_metadata(self) -> [Engine, MetaData]:\n        \"\"\"Create the sqlalchemy-engine and -metadata for the database.\"\"\"\n        metadata = sqlalchemy.MetaData()\n        engine = sqlalchemy.create_engine(self.dsn)\n        metadata.create_all(engine)\n        return engine, metadata\n\n    async def connect(self):\n        \"\"\"Open connection to the database.\"\"\"\n        self.logger.info(f'connecting to {self.dsn}')\n        await self.dbase.connect()\n\n    async def disconnect(self):\n        \"\"\"Close connection to the database.\"\"\"\n        self.logger.info(f'disconnecting from {self.dsn}')\n        await self.dbase.disconnect()\n\n\ndef add_databases_to_app(\n        app: FastAPI,\n        dbs: Dict[str,\n                  DatabaseDefinition]\n) -> FastAPI:\n    \"\"\"Add instances of :class:`Database` as attribute of app.\n\n    For each database as defined in the ``config.yml`` as external-resource,\n    create a :class:`Database` instance with defined parameters, add this\n    instance to the ``app.databases``-attribute and add ``startup`` and\n    ``shutdown`` handlers to connect / disconnect to the database on\n    app-startup / app-shutdown.\n\n    Parameters:\n        app: the app to add the database definitions to.\n        dbs: the databases to add to the app.\n\n    Returns:\n        modified app containing the attribute app.databases and event handler\n        for startup and shutdown for the databases.\n\n    \"\"\"\n    for _, db_definition in dbs.items():\n        database = Database(\n            dsn=db_definition.dsn,\n            logger=app.logger,\n            min_size=db_definition.min_size,\n            max_size=db_definition.max_size\n        )\n        app.add_event_handler('startup', database.connect)\n        app.add_event_handler('shutdown', database.disconnect)\n        try:\n            app.databases.update({db_definition.name: database})\n        except AttributeError:\n            app.databases = {db_definition.name: database}\n    return app\n"}
{"type": "source_file", "path": "setup.py", "content": "# -*- coding: utf-8 -*-\n\n# DO NOT EDIT THIS FILE!\n# This file has been autogenerated by dephell <3\n# https://github.com/dephell/dephell\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\n\nimport os.path\n\nreadme = ''\nhere = os.path.abspath(os.path.dirname(__file__))\nreadme_path = os.path.join(here, 'README.rst')\nif os.path.exists(readme_path):\n    with open(readme_path, 'rb') as stream:\n        readme = stream.read().decode('utf8')\n\nsetup(\n    long_description=readme,\n    name='fastapi_serviceutils',\n    version='2.1.0',\n    description='Utils for fastapi based services.',\n    python_requires='<4,>=3.7',\n    project_urls={\n        'homepage': 'https://fastapi-serviceutils.readthedocs.io/en/latest/',\n        'repository': 'https://github.com/skallfass/fastapi_serviceutils'\n    },\n    author='Simon Kallfass',\n    author_email='skallfass@ouroboros.info',\n    license='MIT',\n    keywords='python fastapi webservice service-utils',\n    classifiers=[\n        'Operating System :: Unix', 'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 3.7'\n    ],\n    entry_points={\n        'console_scripts': [\n            'create_service = fastapi_serviceutils.cli.create_service:main'\n        ]\n    },\n    packages=[\n        'fastapi_serviceutils', 'fastapi_serviceutils.app',\n        'fastapi_serviceutils.app.endpoints',\n        'fastapi_serviceutils.app.endpoints.default',\n        'fastapi_serviceutils.app.handlers',\n        'fastapi_serviceutils.app.middlewares', 'fastapi_serviceutils.cli',\n        'fastapi_serviceutils.utils', 'fastapi_serviceutils.utils.docs',\n        'fastapi_serviceutils.utils.external_resources',\n        'fastapi_serviceutils.utils.tests'\n    ],\n    package_data={},\n    install_requires=[\n        'cookiecutter>=1.6', 'databases[postgresql]>=0.2', 'fastapi[all]>=0.44',\n        'loguru>=0.4', 'psycopg2>=2.8', 'requests>=2.22.0', 'sqlalchemy>=1.3',\n        'toolz>=0.10'\n    ],\n    extras_require={\n        'dev': [\n            'autoflake>=1.3', 'coverage-badge>=1', 'flake8>=3.7',\n            'ipython>=7.8', 'jedi>=0.14', 'neovim>=0.3.1', 'pudb>=2019.1',\n            'pygments>=2.4', 'pylint>=2.4.3', 'pytest>=5',\n            'pytest-asyncio>=0.10', 'pytest-cov>=2', 'pytest-xdist>=1.30',\n            'sphinx>=2', 'sphinx-autodoc-typehints>=1.6',\n            'sphinx-rtd-theme>=0.4.3', 'yapf>=0.27'\n        ]\n    },\n)\n"}

{"repo_info": {"repo_name": "prisma-fastapi", "repo_owner": "prisma-korea", "repo_url": "https://github.com/prisma-korea/prisma-fastapi"}}
{"type": "test_file", "path": "test/test_main.py", "content": "from fastapi.testclient import TestClient\nimport pytest\nfrom prisma import Prisma\n\nfrom main import app\n\nclient = TestClient(app)\nprisma = Prisma()\n\n\ndef test_root():\n    response = client.get(\"/\")\n    assert response.status_code == 200\n"}
{"type": "test_file", "path": "test/test_users.py", "content": "# from fastapi.testclient import TestClient\n# import pytest\n# from prisma import Prisma\n\n# from main import app\n\n# client = TestClient(app)\n# prisma = Prisma()\n\n\n# # @pytest.fixture(scope=\"function\", autouse=True)\n# # async def test_init(request):\n# #     await prisma.connect()\n# #     yield\n# #     await prisma.disconnect()\n\n\n# async def test_read_users():\n#     await prisma.connect()\n#     response = client.get(\"/apis/users\")\n#     assert response.status_code == 200\n"}
{"type": "source_file", "path": "main.py", "content": "from src.apis import apis\nfrom src.prisma import prisma\nfrom fastapi.middleware.gzip import GZipMiddleware\nfrom fastapi import FastAPI\n\napp = FastAPI()\napp.add_middleware(GZipMiddleware, minimum_size=1000)\napp.include_router(apis, prefix=\"/apis\")\n\n@app.on_event(\"startup\")\nasync def startup():\n    await prisma.connect()\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await prisma.disconnect()\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"version\": \"1.0.0\"}\n"}
{"type": "source_file", "path": "dependencies.py", "content": ""}
{"type": "source_file", "path": "src/apis/__init__.py", "content": "from fastapi import APIRouter\n\nfrom src.apis.auth import router as authRouter\nfrom src.apis.users import router as usersRouter\n\napis = APIRouter()\napis.include_router(authRouter)\napis.include_router(usersRouter)\n\n__all__ = [\"apis\"]\n"}
{"type": "source_file", "path": "src/apis/users.py", "content": "from typing import List\nfrom fastapi import APIRouter, Depends\nfrom src.prisma import prisma\nfrom src.utils.auth import JWTBearer, decodeJWT\n\nrouter = APIRouter()\n\n\n@router.get(\"/users/\", tags=[\"users\"])\nasync def read_users():\n    users = await prisma.user.find_many()\n    print(\"users\", users)\n\n    for user in users:\n        del user.password\n\n    return users\n\n\n@router.get(\"/users/me\", tags=[\"users\"])\nasync def read_user_me(token=Depends(JWTBearer())):\n    decoded = decodeJWT(token)\n\n    if \"userId\" in decoded:\n        userId = decoded[\"userId\"]\n        return await prisma.user.find_unique(where={\"id\": userId})\n    return None\n\n\n@router.get(\"/users/{userId}\", tags=[\"users\"])\nasync def read_user(userId: str):\n    user = await prisma.user.find_unique(where={\"id\": userId})\n\n    return user\n"}
{"type": "source_file", "path": "src/apis/auth.py", "content": "import datetime\nfrom typing import List, Optional\nfrom fastapi import APIRouter\nfrom prisma.models import User\nfrom pydantic import BaseModel\nfrom src.models.scalar import Gender\nfrom src.prisma import prisma\nfrom src.utils.auth import (\n    encryptPassword,\n    signJWT,\n    validatePassword,\n)\n\nrouter = APIRouter()\n\n\nclass SignIn(BaseModel):\n    email: str\n    password: str\n\n\nclass SignInOut(BaseModel):\n    token: str\n    user: User\n\n\n@router.post(\"/auth/sign-in\", tags=[\"auth\"])\nasync def sign_in(signIn: SignIn):\n    user = await prisma.user.find_first(\n        where={\n            \"email\": signIn.email,\n        }\n    )\n\n    validated = validatePassword(signIn.password, user.password)\n    del user.password\n\n    if validated:\n        token = signJWT(user.id)\n        return SignInOut(token=token, user=user)\n\n    return None\n\n\nclass SignUp(BaseModel):\n    email: str\n    password: str\n    name: Optional[str] = None\n    nickname: Optional[str] = None\n    birthday: Optional[datetime.date] = None\n    gender: Optional[Gender] = None\n    phone: Optional[str] = None\n\n\n@router.post(\"/auth/sign-up\", tags=[\"auth\"])\nasync def sign_up(user: SignUp):\n    password = encryptPassword(user.password)\n    created = await prisma.user.create(\n        {\n            \"email\": user.email,\n            \"password\": encryptPassword(user.password),\n            \"name\": user.name,\n            \"nickname\": user.nickname,\n            \"birthDay\": user.birthday,\n            \"gender\": user.gender,\n            \"phone\": user.phone,\n        }\n    )\n\n    return created\n\n\n@router.get(\"/auth/\", tags=[\"auth\"])\nasync def auth():\n    users = await prisma.user.find_many()\n\n    for user in users:\n        del user.password\n\n    return users\n"}
{"type": "source_file", "path": "src/prisma.py", "content": "from prisma import Prisma\n\nprisma = Prisma()\n"}
{"type": "source_file", "path": "src/utils/auth.py", "content": "from datetime import datetime, timedelta, timezone\nfrom typing_extensions import Self\nfrom typing import Dict\nfrom fastapi import Request, HTTPException\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport os\nimport bcrypt\nimport jwt\n\njwtSecret = os.environ.get(\"JWT_SECRET\")\n\n\ndef signJWT(user_id: str) -> Dict[str, str]:\n    EXPIRES = datetime.now(tz=timezone.utc) + timedelta(days=365)\n\n    payload = {\n        \"exp\": EXPIRES,\n        \"userId\": user_id,\n    }\n    token = jwt.encode(payload, jwtSecret, algorithm=\"HS256\")\n\n    return token\n\n\ndef decodeJWT(token: str) -> dict:\n    try:\n        decoded = jwt.decode(token, jwtSecret, algorithms=[\"HS256\"])\n        return decoded if decoded[\"expires\"] else None\n    except jwt.ExpiredSignatureError:\n        print(\"Token expired. Get new one\")\n        return None\n    except:\n        return None\n\n\ndef encryptPassword(password: str) -> str:\n    return bcrypt.hashpw(password.encode(\"utf-8\"), bcrypt.gensalt()).decode(\"utf-8\")\n\n\ndef validatePassword(password: str, encrypted: str) -> str:\n    return bcrypt.checkpw(password.encode(\"utf-8\"), encrypted.encode(\"utf-8\"))\n\n\nclass JWTBearer(HTTPBearer):\n    def __init__(self, auto_error: bool = True):\n        super(JWTBearer, self).__init__(auto_error=auto_error)\n\n    async def __call__(self, request: Request):\n        credentials: HTTPAuthorizationCredentials = await super(\n            JWTBearer, self\n        ).__call__(request)\n        if credentials:\n            if not credentials.scheme == \"Bearer\":\n                raise HTTPException(\n                    status_code=403, detail=\"Invalid authentication scheme.\"\n                )\n            if not self.verify_jwt(credentials.credentials):\n                raise HTTPException(\n                    status_code=403, detail=\"Invalid token or expired token.\"\n                )\n            return credentials.credentials\n        else:\n            raise HTTPException(status_code=403, detail=\"Invalid authorization code.\")\n\n    def verify_jwt(self, jwtToken: str) -> bool:\n        isTokenValid: bool = False\n\n        try:\n            payload = decodeJWT(jwtToken)\n        except:\n            payload = None\n        if payload:\n            isTokenValid = True\n        return isTokenValid\n"}
{"type": "source_file", "path": "src/models/scalar.py", "content": "from enum import Enum\n\n\nclass Gender(Enum):\n    Male = \"male\"\n    Female = \"female\"\n"}

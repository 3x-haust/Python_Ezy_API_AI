{"repo_info": {"repo_name": "FastAPI_SAAS_Template", "repo_owner": "philipokiokio", "repo_url": "https://github.com/philipokiokio/FastAPI_SAAS_Template"}}
{"type": "test_file", "path": "src/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "src/tests/test_auth/test_auth.py", "content": "import pytest\n\nfrom src.app.utils.token import auth_token\nfrom src.tests.conftest import (\n    TestClient,\n    client,\n    first_user_data,\n    second_user_data,\n    user_data,\n)\n\nauth_route = \"/api/v1/auth\"\n\n\ndef test_root(client):\n    client: TestClient = client\n    res = client.get(\"/\")\n    assert res.json().get(\"message\") == \"Welcome to FastAPI SAAS Template\"\n    assert res.status_code == 200\n\n\n@pytest.mark.asyncio\nasync def test_registration(client):\n    client: TestClient = client\n    res = client.post(f\"{auth_route}/register/\", json=user_data)\n\n    assert res.json().get(\"message\") == \"Registration Successful\"\n\n    assert res.json().get(\"data\")[\"email\"] == user_data[\"email\"]\n    assert res.status_code == 201\n\n\ndef test_login(client, first_user):\n    client: TestClient = client\n    res = client.post(\n        f\"{auth_route}/login/\",\n        data={\"username\": first_user[\"email\"], \"password\": first_user[\"password\"]},\n    )\n    assert res.status_code == 200\n    assert res.json().get(\"message\") == \"Login Successful\"\n    data = res.json().get(\"data\")\n    assert data[\"data\"][\"email\"] == first_user_data[\"email\"]\n\n\ndef test_resend_verification(client, second_user):\n    email_data = {\"email\": second_user_data[\"email\"]}\n    client: TestClient = client\n    res = client.post(f\"{auth_route}/resend-account-verification/\", json=email_data)\n\n    assert res.status_code == 200\n    # assert res.json().get(\"message\") == \"Account Verification Mail sent successfully\"\n\n\ndef test_account_verification(client, second_user):\n    client: TestClient = client\n    token = auth_token(second_user_data[\"email\"])\n\n    res = client.post(f\"{auth_route}/account-verification/{token}/\")\n\n    assert res.status_code == 200\n    assert res.json().get(\"status\") == 200\n    assert res.json().get(\"message\") == \"User Account is verified successfully\"\n\n\ndef test_fail_me(first_user, client):\n    client: TestClient = client\n    res = client.get(f\"{auth_route}/me/\")\n\n    assert res.status_code == 401\n    assert res.json().get(\"detail\") == \"Not authenticated\"\n\n\ndef test_me(first_auth_client):\n    client: TestClient = first_auth_client\n\n    res = client.get(f\"{auth_route}/me/\")\n\n    assert res.status_code == 200\n    assert res.json().get(\"message\") == \"Me Data\"\n    assert res.json().get(\"data\")[\"email\"] == first_user_data[\"email\"]\n\n\ndef test_update(first_auth_client):\n    client: TestClient = first_auth_client\n\n    res = client.patch(\n        f\"{auth_route}/update/\",\n        json={\"first_name\": \"name_change\", \"last_name\": \"change_name\"},\n    )\n    assert res.status_code == 200\n    assert res.json().get(\"data\")[\"first_name\"] == \"name_change\"\n\n\ndef test_delete(first_auth_client):\n    client: TestClient = first_auth_client\n\n    res = client.delete(f\"{auth_route}/delete/\")\n    assert res.status_code == 204\n\n\ndef test_auth_refresh(client, first_user_login):\n    client: TestClient = client\n    client.headers = {\n        **client.headers,\n        \"Refresh-Tok\": first_user_login[\"refresh_token\"][\"token\"],\n    }\n    res = client.get(\"/api/v1/auth/refresh/\")\n\n    assert res.status_code == 200\n    assert type(res.json().get(\"token\")) == str\n    assert res.json().get(\"message\") == \"New access token created successfully\"\n\n\ndef test_password_change(first_auth_client, first_user):\n    client: TestClient = first_auth_client\n    res = client.patch(\n        f\"{auth_route}/change-password/\",\n        json={\"password\": \"new_password\", \"old_password\": first_user[\"password\"]},\n    )\n    assert res.status_code == 200\n    assert res.json().get(\"message\") == \"Password changed successfully\"\n\n\ndef test_password_reset(client, first_user):\n    client: TestClient = client\n\n    res = client.post(\n        f\"{auth_route}/reset-password/\", json={\"email\": first_user[\"email\"]}\n    )\n\n    assert res.status_code == 200\n    # assert res.json().get(\"mail_status\") == True\n    # assert res.json().get(\"message\") == \"Reset Mail sent successfully\"\n\n\ndef test_password_reset_done(client, first_user):\n    token = auth_token(first_user[\"email\"])\n    client: TestClient = client\n\n    res = client.post(\n        f\"{auth_route}/password-reset/complete/{token}/\",\n        json={\"password\": \"changedone\"},\n    )\n\n    assert res.status_code == 200\n    assert res.json().get(\"message\") == \"User password set successfully\"\n"}
{"type": "test_file", "path": "src/tests/test_orgs/test_org.py", "content": "import pytest\n\nfrom src.app.utils.token import gen_token\nfrom src.tests.conftest import TestClient, first_user_data, second_user_data\n\norg_route = \"/api/v1/org\"\n\n\ndef test_org_creation(first_auth_client):\n    client: TestClient = first_auth_client\n\n    res = client.post(f\"{org_route}/create/\", json={\"name\": \"stripe\"})\n    assert res.status_code == 201\n    assert res.json().get(\"message\") == \"Org Created Successfully\"\n    assert res.json().get(\"data\")[\"name\"] == \"stripe\"\n\n\ndef test_org_premium(\n    first_auth_client, first_user_org_created, first_user_2nd_org_created\n):\n    client: TestClient = first_auth_client\n\n    res = client.post(f\"{org_route}/create/\", json={\"name\": \"stripe\"})\n\n    assert res.status_code == 400\n    assert (\n        res.json().get(\"detail\")\n        == \"Freemium Users can only create a Maximum of two Orgs\"\n    )\n\n\ndef test_orgs(first_auth_client, first_user_2nd_org_created, first_user_org_created):\n    client: TestClient = first_auth_client\n\n    res = client.get(f\"{org_route}s/\")\n\n    assert res.status_code == 200\n    assert type(res.json().get(\"data\")) == list\n    assert res.json().get(\"message\") == \"User Orgs retrieved successfully\"\n\n\ndef test_get_org(first_auth_client, first_user_org_created):\n    client: TestClient = first_auth_client\n    slug = first_user_org_created[\"data\"][\"slug\"]\n    res = client.get(f\"{org_route}/{slug}\")\n\n    assert res.status_code == 200\n    assert res.json().get(\"message\") == \"Org Returned\"\n    assert res.json().get(\"data\")[\"slug\"] == slug\n    pass\n\n\ndef test_update_org(first_auth_client, first_user_org_created):\n    client: TestClient = first_auth_client\n\n    slug = first_user_org_created[\"data\"][\"slug\"]\n    res = client.patch(f\"{org_route}/{slug}/update/\", json={\"revoke_link\": True})\n\n    assert res.status_code == 200\n    assert type(res.json().get(\"data\")) == dict\n\n\ndef test_delete_org(first_auth_client, first_user_org_created):\n    client: TestClient = first_auth_client\n\n    slug = first_user_org_created[\"data\"][\"slug\"]\n\n    res = client.delete(f\"{org_route}/{slug}/delete/\")\n\n    assert res.status_code == 204\n\n\ndef test_gen_invite_link(first_auth_client, first_user_org_created):\n    client: TestClient = first_auth_client\n    slug = first_user_org_created[\"data\"][\"slug\"]\n    res = client.post(f\"{org_route}/{slug}/invite-link/gen/\", json={\"role\": \"Member\"})\n\n    assert res.status_code == 200\n    assert type(res.json().get(\"data\")) == str\n    assert res.json().get(\"message\") == \"Invite Link Created successfully\"\n\n\ndef test_revoke_invite_link(first_auth_client, first_user_org_created):\n    client: TestClient = first_auth_client\n    slug = first_user_org_created[\"data\"][\"slug\"]\n    res = client.post(f\"{org_route}/{slug}/revoke-link/\")\n\n    assert res.status_code == 200\n    assert res.json().get(\"message\") == \"Org revoked successfully\"\n    assert res.json().get(\"data\")[\"slug\"] == slug\n\n\n@pytest.fixture\ndef test_org_memb_join(client, first_user_2nd_org_created, secnd_user_access):\n    client: TestClient = client\n    token = gen_token(first_user_2nd_org_created[\"slug\"])\n    role_token = gen_token(\"Member\")\n    res = client.post(\n        f\"{org_route}/join/\",\n        params={\"token\": token, \"role_token\": role_token},\n        json={\"email\": second_user_data[\"email\"]},\n    )\n\n    assert res.json().get(\"message\") == \"User Joined Org\"\n    assert res.status_code == 200\n    assert res.json().get(\"data\")[\"user\"][\"email\"] == second_user_data[\"email\"]\n    return res.json().get(\"data\")\n\n\ndef test_get_all_org_members(\n    first_auth_client, first_user_2nd_org_created, org_memb_2nd_join\n):\n    client: TestClient = first_auth_client\n    org_slug = first_user_2nd_org_created[\"slug\"]\n\n    res = client.get(f\"{org_route}/{org_slug}/members/\")\n\n    assert res.status_code == 200\n\n    assert res.json().get(\"message\") == \"Org Members retrieved successfully\"\n\n    for data in res.json().get(\"data\"):\n        if data[\"user\"][\"email\"] == first_user_data[\"email\"]:\n            assert data[\"role\"] == \"Admin\"\n\n        elif data[\"user\"][\"email\"] == second_user_data[\"email\"]:\n            assert data[\"role\"] == \"Member\"\n\n\n# def test_get_org_member(\n#     secnd_auth_client, first_user_2nd_org_created, test_org_memb_join, secnd_user_access\n# ):\n#     client: TestClient = secnd_auth_client\n#     slug = first_user_2nd_org_created[\"slug\"]\n#     memb_id = test_org_memb_join[\"id\"]\n#     res = client.get(f\"{org_route}/{slug}/member/{memb_id}/\")\n\n#     assert res.status_code == 200\n#     assert res.json().get(\"message\") == \"Org Member Retrieved Successfully\"\n#     assert res.json().get(\"data\")[\"id\"] == memb_id\n\n\ndef test_delete_org_memb(\n    first_auth_client, first_user_2nd_org_created, test_org_memb_join, secnd_user_access\n):\n    client: TestClient = first_auth_client\n    slug = first_user_2nd_org_created[\"slug\"]\n    memb_id = test_org_memb_join[\"id\"]\n    res = client.delete(f\"{org_route}/{slug}/member/{memb_id}/delete/\")\n\n    assert res.status_code == 204\n\n\n# def test_leave_org_memb(\n#     first_auth_client,\n#     secnd_auth_client,\n#     first_user_2nd_org_created,\n#     test_org_memb_join,\n# ):\n#     client: TestClient = secnd_auth_client\n#     slug = first_user_2nd_org_created[\"slug\"]\n#     res = client.get(f\"{org_route}/{slug}/member/leave/\")\n\n#     assert res.status_code == 204\n"}
{"type": "test_file", "path": "src/tests/conftest.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\n\nfrom src.app import main\nfrom src.app.config import test_status\nfrom src.app.database import Base, test_engine,TestFactory\nfrom src.app.utils.token import gen_token\nfrom src.auth.oauth import create_access_token, create_refresh_token\nfrom src.app.utils.db_utils import get_db\n\n# Test SQLAlchemy DBURL\n\n@pytest.fixture\ndef session():\n    Base.metadata.drop_all(test_engine)\n    Base.metadata.create_all(test_engine)\n\n\n\n\n\n\n    db = TestFactory()\n    try:\n\n        yield db\n    finally:\n        db.close()\n\n\n@pytest.fixture()\ndef client(session):\n\n    # run our code beforewe  run our test\n    def get_test_db():\n        try:\n\n            yield session\n        finally:\n            session.close()\n\n    main.app.dependency_overrides[get_db] = get_test_db\n    yield TestClient(main.app)\n\n\n\n  \n\nuser_data = {\n    \"email\": \"test@gmail.com\",\n    \"password\": \"anotherday\",\n    \"first_name\": \"Philip\",\n    \"last_name\": \"thebackend\",\n    \"is_verified\": False,\n}\n\n\nfirst_user_data = {\n    \"email\": \"tester@gmail.com\",\n    \"password\": \"anotherday\",\n    \"first_name\": \"Philip\",\n    \"last_name\": \"thebackend\",\n    \"is_verified\": True,\n}\n\nsecond_user_data = {\n    \"email\": \"test@mail.com\",\n    \"password\": \"anotherday\",\n    \"first_name\": \"Philip\",\n    \"last_name\": \"thebackend\",\n    \"is_verified\": False,\n}\n\n\n@pytest.fixture\ndef first_user(client):\n    client: TestClient = client\n    res = client.post(\"/api/v1/auth/register/\", json=first_user_data)\n\n    assert res.status_code == 201\n    new_user = res.json()[\"data\"]\n    new_user[\"password\"] = first_user_data[\"password\"]\n    return new_user\n\n\n@pytest.fixture\ndef second_user(client):\n    client: TestClient = client\n    res = client.post(\"/api/v1/auth/register/\", json=second_user_data)\n\n    assert res.status_code == 201\n    new_user = res.json()[\"data\"]\n    new_user[\"password\"] = second_user_data[\"password\"]\n    return new_user\n\n\n@pytest.fixture\ndef first_user_login(client, first_user):\n    client: TestClient = client\n    res = client.post(\n        \"/api/v1/auth/login/\",\n        data={\"username\": first_user[\"email\"], \"password\": first_user[\"password\"]},\n    )\n    assert res.status_code == 200\n    return res.json().get(\"data\")\n\n\n# Auth Clients for refresh and access token for the first user\n\n\n@pytest.fixture\ndef first_user_access(first_user):\n    access_token = create_access_token(first_user)\n    return access_token\n\n\n@pytest.fixture\ndef secnd_user_access(second_user):\n    access_token = create_access_token(second_user)\n    return access_token\n\n\n@pytest.fixture\ndef first_user_refresh(first_user):\n    data = {\"email\": first_user[\"email\"]}\n    refresh_token = create_refresh_token(data)\n    return refresh_token\n\n\n@pytest.fixture\ndef first_auth_client(client, first_user_access):\n    client: TestClient = client\n    client.headers = {**client.headers, \"Authorization\": f\"Bearer {first_user_access}\"}\n    return client\n\n\n@pytest.fixture\ndef secnd_auth_client(client, secnd_user_access):\n    client: TestClient = client\n    client.headers = {**client.headers, \"Authorization\": f\"Bearer {secnd_user_access}\"}\n    return client\n\n\nfirst_org = {\"name\": \"stripe\"}\nsecond_org = {\"name\": \"paystack\"}\n\n\n@pytest.fixture\ndef first_user_org_created(first_auth_client):\n    client: TestClient = first_auth_client\n\n    res = client.post(\"api/v1/org/create/\", json=first_org)\n    return res.json()\n\n\n@pytest.fixture\ndef first_user_2nd_org_created(first_auth_client, first_user_org_created):\n    client: TestClient = first_auth_client\n\n    res = client.post(\"api/v1/org/create/\", json=second_org)\n    return res.json().get(\"data\")\n\n\n@pytest.fixture\ndef org_memb_2nd_join(first_user_2nd_org_created, client, secnd_user_access):\n    client: TestClient = client\n\n    token = gen_token(first_user_2nd_org_created[\"slug\"])\n    role_token = gen_token(\"Member\")\n    res = client.post(\n        \"/api/v1/org/join/\",\n        params={\"token\": token, \"role_token\": role_token},\n        json={\"email\": second_user_data[\"email\"]},\n    )\n    return res.json().get(\"data\")\n"}
{"type": "test_file", "path": "src/tests/test_auth/__init__.py", "content": ""}
{"type": "test_file", "path": "src/tests/test_orgs/__init__.py", "content": ""}
{"type": "source_file", "path": "src/app/__init__.py", "content": ""}
{"type": "source_file", "path": "src/app/database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import declarative_base, scoped_session, sessionmaker\n\n# application import config.\nfrom src.app.config import db_settings\n\n# DB URL for connection\nSQLALCHEMY_DATABASE_URL = f\"postgresql://{db_settings.username}:{db_settings.password}@{db_settings.hostname}:{db_settings.port}/{db_settings.name}\"\n\n# Creating DB engine\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\n\n# Creating and Managing session.\nSessionFactory = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Domain Modelling Dependency\nBase = declarative_base()\n\n\nTEST_SQLALCHEMY_DATABASE_URL = SQLALCHEMY_DATABASE_URL + \"_test\"\ntest_engine = create_engine(TEST_SQLALCHEMY_DATABASE_URL)\nTestFactory = sessionmaker(autoflush=False, autocommit=False, bind=test_engine)\nprint(\"Database is Ready!\")\n\n\ndef get_test_db():\n    print(\"Test Database is Ready!\")\n    test_db = TestFactory()\n\n    try:\n        yield test_db\n    finally:\n        test_db.close()\n"}
{"type": "source_file", "path": "src/auth/__init__.py", "content": ""}
{"type": "source_file", "path": "src/app/utils/slugger.py", "content": "from uuid import uuid4\n\n\ndef slug_gen() -> str:\n    return uuid4().hex\n"}
{"type": "source_file", "path": "src/migrations/__init__.py", "content": ""}
{"type": "source_file", "path": "src/__init__.py", "content": ""}
{"type": "source_file", "path": "src/app/celery_jobs.py", "content": "from celery import Celery\nfrom celery.schedules import crontab\n\njob = Celery(\"SAAS Template\", broker=\"redis://localhost:6379/0\")\njob.conf.enable_utc = True\n"}
{"type": "source_file", "path": "src/app/utils/models_utils.py", "content": "# 3rd party import\nfrom sqlalchemy import TIMESTAMP, Column, Integer, text\n\n# application imports\nfrom src.app.database import Base\n\n\nclass AbstractModel(Base):\n    \"\"\"Base Models\n\n    Args:\n        Base (_type_): Inherits Base from SQLAlchemy and specifies columns for inheritance.\n    \"\"\"\n\n    __abstract__ = True\n\n    id = Column(Integer, nullable=False, primary_key=True)\n    date_created = Column(TIMESTAMP(timezone=True), server_default=text(\"NOW()\"))\n    date_updated = Column(TIMESTAMP(timezone=True), server_default=text(\"NOW()\"))\n"}
{"type": "source_file", "path": "src/app/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "src/app/config.py", "content": "from typing import Optional\n\nfrom src.app.utils.schemas_utils import AbstractSettings, BaseModel, EmailStr\n\n\nclass DBSettings(AbstractSettings):\n    \"\"\"Database Settings\n\n    Args:\n        AbstractSettings (_type_): inherits Core settings.\n    \"\"\"\n\n    name: str\n    username: str\n    password: str\n    hostname: str\n    port: int\n\n\nclass AuthSettings(AbstractSettings):\n    \"\"\"Authentication Settings\n\n    Args:\n        AbstractSettings (_type_): inherits Core settings.\n    \"\"\"\n\n    access_secret_key: str\n    refresh_secret_key: str\n    access_time_exp: int\n    refresh_time_exp: int\n    algorithm: str\n    frontend_url: str\n\n\nclass MailSettings(AbstractSettings):\n    \"\"\"Mail Settings\n\n    Args:\n        AbstractSettings (_type_): inherits Core settings.\n    \"\"\"\n\n    mail_username: str\n    mail_password: str\n    mail_from: EmailStr\n    mail_port: int\n    mail_server: str\n    mail_from_name: str\n\n\nclass TestSettings(AbstractSettings):\n    should_test: Optional[bool]\n\n\ndb_settings = DBSettings()\nauth_settings = AuthSettings()\nmail_settings = MailSettings()\ntest_status = TestSettings()\n"}
{"type": "source_file", "path": "src/auth/models.py", "content": "# 3rd party imports\nfrom sqlalchemy import Boolean, Column, ForeignKey, String, text\nfrom sqlalchemy.orm import relationship\n\n# application imports\nfrom src.app.utils.models_utils import AbstractModel\n\n\nclass User(AbstractModel):\n    # User Table\n    __tablename__ = \"users\"\n    first_name = Column(String, nullable=False)\n    last_name = Column(String, nullable=False)\n    email = Column(String, unique=True)\n    password = Column(String, nullable=False)\n    is_verified = Column(Boolean, nullable=False, server_default=text(\"false\"))\n    is_premium = Column(Boolean, nullable=False, server_default=text(\"false\"))\n\n\nclass RefreshToken(AbstractModel):\n    # Refresh Token Table\n    __tablename__ = \"user_refresh_token\"\n    user_id = Column(ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    token = Column(String, nullable=False)\n    user = relationship(\"User\", passive_deletes=True)\n"}
{"type": "source_file", "path": "src/app/utils/token.py", "content": "# Token generation 3rd party generation\nfrom itsdangerous.exc import BadSignature\nfrom itsdangerous.url_safe import URLSafeSerializer, URLSafeTimedSerializer\n\n# application imports\nfrom src.app.config import auth_settings\n\n# Creating timed and untimed data serializers\ntokens = URLSafeSerializer(\n    f\"{auth_settings.access_secret_key}+{auth_settings.refresh_secret_key}\"\n)\ninvite_tokens = URLSafeTimedSerializer(f\"{auth_settings.refresh_secret_key}\")\n\n\ndef gen_token(data: str):\n    # Token is serialized\n    toks = tokens.dumps(data)\n\n    return toks\n\n\ndef auth_token(data: str):\n    # Timed token serializer\n    return invite_tokens.dumps(data)\n\n\ndef retrieve_token(token: str):\n    # return data from the token\n    try:\n        data = tokens.loads(token)\n    except BadSignature:\n        return None\n    return data\n\n\ndef auth_retrieve_token(token: str):\n    # return data from the token\n\n    try:\n        data = invite_tokens.loads(token, max_age=300)\n    except BadSignature:\n        return None\n    return data\n"}
{"type": "source_file", "path": "src/auth/schemas.py", "content": "# python imports\nfrom datetime import datetime\nfrom typing import Optional\n\n# 3rd party\nfrom pydantic import EmailStr\n\n# application import\nfrom src.app.utils.schemas_utils import AbstractModel, ResponseModel\n\n\n# Email DTO (Used for token verification)\nclass TokenData(AbstractModel):\n    email: EmailStr\n\n\n# Create new user\nclass user_create(AbstractModel):\n    first_name: str\n    last_name: str\n    email: EmailStr\n    password: str\n    is_verified: bool = False\n\n\n# ORM response\nclass UserResponse(AbstractModel):\n    first_name: str\n    last_name: str\n    email: EmailStr\n    date_created: datetime\n\n\n# Password Data for password reset\nclass PasswordData(AbstractModel):\n    password: str\n\n\n# Password data for Change Password\nclass ChangePassword(PasswordData):\n    old_password: str\n\n\n# User Update DTO\nclass UserUpdate(AbstractModel):\n    first_name: Optional[str]\n    last_name: Optional[str]\n\n\n# Req-Res Response DTO\nclass MessageUserResponse(ResponseModel):\n    data: UserResponse\n\n\n# Token DTO\nclass Token(AbstractModel):\n    token: str\n\n\n# Refresh Token DTO\nclass RefreshToken(Token):\n    header: str\n\n\n# Login ORM Response\nclass LoginResponse(AbstractModel):\n    data: UserResponse\n\n    refresh_token: RefreshToken\n\n\n# Req-Res Login Response\nclass MessageLoginResponse(ResponseModel):\n    data: LoginResponse\n    access_token: str\n    token_type: str\n"}
{"type": "source_file", "path": "src/auth/oauth.py", "content": "# python import\nfrom datetime import datetime, timedelta\n\n# framework imports\nfrom fastapi import Depends, Header, HTTPException, status\nfrom fastapi.security.oauth2 import OAuth2PasswordBearer\nfrom sqlalchemy.orm import Session\n\n# JWT imports\nfrom jose import JWTError, jwt\n\n# Apoplication imports\nfrom src.app.config import auth_settings\nfrom src.app.utils.db_utils import get_db\nfrom src.auth.auth_repository import token_repo, user_repo\nfrom src.auth.schemas import TokenData\n\n# OAUTH Login Endpoint\noauth_schemes = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/login/\")\n\n\n# AUTH SECRETS AND TIME LIMITS\naccess_secret_key = auth_settings.access_secret_key\nrefresh_secret_key = auth_settings.refresh_secret_key\naccess_time_exp = auth_settings.access_time_exp\nrefresh_time_exp = auth_settings.refresh_time_exp\nAlgorithm = auth_settings.algorithm\n\n\ndef create_access_token(data: dict) -> str:\n    # Create Access Token\n    to_encode = data.copy()\n    expire = datetime.now() + timedelta(minutes=access_time_exp)\n    to_encode[\"exp\"] = expire\n    encode_jwt = jwt.encode(to_encode, access_secret_key, algorithm=Algorithm)\n    return encode_jwt\n\n\ndef create_refresh_token(data: dict) -> str:\n    # Create Refresh Token\n    to_encode = data.copy()\n    expire = datetime.now() + timedelta(minutes=refresh_time_exp)\n    to_encode[\"exp\"] = expire\n    refresh_encode_jwt = jwt.encode(to_encode, refresh_secret_key, algorithm=Algorithm)\n    return refresh_encode_jwt\n\n\ndef credential_exception():\n    # Throw Auth Exception\n    raise HTTPException(\n        detail=\"Could not validate credentials\",\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n\n\ndef refresh_exception():\n    # Throw Refresh Exception\n\n    raise HTTPException(\n        detail=\"Could not validate refresh credential\",\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        headers={\"Refresh-Tok\": \"token\"},\n    )\n\n\ndef verify_refresh_token(refresh_tok: str = Header(),db:Session = Depends(get_db)) -> str:\n    # Verify Refresh Token\n    try:\n        decoded_data = jwt.decode(refresh_tok, refresh_secret_key, algorithms=Algorithm)\n        email = decoded_data.get(\"email\")\n        if not email:\n            raise refresh_exception()\n        token_data = TokenData(email=email)\n    except JWTError:\n        raise refresh_exception()\n\n    refresh_token_check = token_repo(db).get_token_by_tok(refresh_tok)\n\n    if not refresh_token_check:\n        refresh_exception()\n\n    if refresh_token_check.user.email != token_data.email:\n        refresh_exception()\n\n    return create_access_token(decoded_data)\n\n\ndef get_current_user(token: str = Depends(oauth_schemes), db:Session = Depends(get_db)):\n    # Verify Access token and return User\n    try:\n        decode_data = jwt.decode(token, access_secret_key, algorithms=Algorithm)\n        email = decode_data.get(\"email\")\n        if email is None:\n            credential_exception()\n\n        token_data = TokenData(email=email)\n    except JWTError:\n        credential_exception()\n\n    user_check = user_repo(db).get_user(token_data.email)\n\n    if not user_check:\n        credential_exception()\n\n    return user_check\n"}
{"type": "source_file", "path": "src/migrations/env.py", "content": "from logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\n\nfrom src.app.database import Base, db_settings\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n\nconfig.set_main_option(\n    \"sqlalchemy.url\",\n    f\"postgresql+psycopg2://{db_settings.username}:{db_settings.password}@{db_settings.hostname}:{db_settings.port}/{db_settings.name}\",\n)\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(connection=connection, target_metadata=target_metadata)\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "src/app/utils/schemas_utils.py", "content": "from enum import Enum\n\nfrom pydantic import BaseModel, BaseSettings, EmailStr\n\n\nclass AbstractModel(BaseModel):\n    \"\"\"Schema Models\n\n    Args:\n        BaseModel (_type_): Inherits from Pydantic and specifies Config\n    \"\"\"\n\n    class Config:\n        orm_mode = True\n        use_enum_values = True\n\n\nclass AbstractSettings(BaseSettings):\n    \"\"\"Settings Models\n\n    Args:\n        BaseModel (_type_): Inherits from Pydantic and specifies Config\n    \"\"\"\n\n    class Config:\n        env_file = \".env\"\n\n\nclass ResponseModel(AbstractModel):\n    \"\"\"Base Response Models\n\n    Args:\n        BaseModel (_type_): Inherits from Pydantic and specifies Config\n    \"\"\"\n\n    message: str\n    status: int\n\n\nclass RoleOptions(Enum):\n    admin = \"Admin\"\n    member = \"Member\"\n\n\nclass User(AbstractModel):\n    \"\"\"User Schema Models\n\n    Args:\n        BaseModel (_type_): Inherits from Pydantic and specifies Config\n    \"\"\"\n\n    first_name: str\n    last_name: str\n    email: EmailStr\n"}
{"type": "source_file", "path": "src/auth/auth_repository.py", "content": "# Pydantic imports\nfrom pydantic import EmailStr\n\n# application import\nfrom src.auth.models import RefreshToken, User\nfrom sqlalchemy.orm import Session\n\n\nclass UserRepo:\n    def __init__(self, db: Session) -> None:\n        self.db = db\n\n    def base_query(self):\n        # Base Query for DB calls\n        return self.db.query(User)\n\n    def get_user(self, email: EmailStr):\n        # get user by email\n        return self.base_query().filter(User.email.icontains(email)).first()\n\n    def create(self, user_create: any) -> User:\n        # create a new user\n        new_user = User(**user_create.dict())\n        new_user.is_premium = False\n        self.db.add(new_user)\n        self.db.commit()\n        self.db.refresh(new_user)\n        return new_user\n\n    def delete(self, user: User) -> bool:\n        # delete user\n        resp = False\n\n        self.db.delete(user)\n        self.db.commit()\n\n        quick_check = self.base_query().filter(User.email == user.email).first()\n        if not quick_check:\n            resp = True\n        return resp\n\n    def update(self, user: User):\n        # update user\n        updated_user = user\n        self.db.commit()\n        self.db.refresh(updated_user)\n        return updated_user\n\n\nclass TokenRepo:\n    def __init__(self, db: Session) -> None:\n        self.db = db\n\n    def base_query(self):\n        # base query for refresh token\n        return self.db.query(RefreshToken)\n\n    def create_token(self, refresh_token: str, user_id: int) -> RefreshToken:\n        # store refresh token\n        refresh_token = RefreshToken(token=refresh_token, user_id=user_id)\n        self.db.add(refresh_token)\n        self.db.commit()\n        self.db.refresh(refresh_token)\n\n        return refresh_token\n\n    def get_token(self, user_id: int):\n        # filter by user_id\n        return self.base_query().filter(RefreshToken.user_id == user_id).first()\n\n    def get_token_by_tok(self, token: str):\n        # filter by token\n        return self.base_query().filter(RefreshToken.token == token).first()\n\n    def update_token(self, update_token) -> RefreshToken:\n        # update token\n        self.db.commit()\n        self.db.refresh(update_token)\n        return update_token\n\n\n# Instatiating the Classes.\n\nuser_repo = UserRepo\ntoken_repo = TokenRepo\n"}
{"type": "source_file", "path": "src/app/main.py", "content": "# python imports\nfrom typing import List\n\n# fastapi  imports\nfrom fastapi import Depends, FastAPI, status\nfrom fastapi.middleware.cors import CORSMiddleware\n\n# application imports\nfrom src.auth.auth_router import user_router\nfrom src.organization.org_router import org_router\n\n# fastapi initialization\napp = FastAPI()\n\n\n# CORS Middleware\norigins: List = []\n\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n# Routers from the application\napp.include_router(user_router)\napp.include_router(org_router)\n\n\n# root of the server\n@app.get(\"/\", status_code=status.HTTP_200_OK)\ndef root() -> dict:\n    return {\"message\": \"Welcome to FastAPI SAAS Template\", \"docs\": \"/docs\"}\n"}
{"type": "source_file", "path": "src/auth/auth_router.py", "content": "# framework imports\nfrom fastapi import APIRouter, Depends, status\nfrom fastapi.security.oauth2 import OAuth2PasswordRequestForm\n\n# application imports\nfrom src.auth import schemas\nfrom src.auth.auth_service import user_service\nfrom src.auth.oauth import get_current_user, verify_refresh_token\nfrom sqlalchemy.orm import Session\nfrom src.app.utils.db_utils import get_db\n\n# API Router\nuser_router = APIRouter(prefix=\"/api/v1/auth\", tags=[\"User Authentication\"])\n\n\n@user_router.post(\n    \"/register/\",\n    status_code=status.HTTP_201_CREATED,\n    response_model=schemas.MessageUserResponse,\n)\nasync def register(user_create: schemas.user_create, db:Session = Depends(get_db)):\n    \"\"\"Registration of User\n\n    Args:\n        user_create (schemas.user_create): {\n        \"first_name\", \"last_name\",\"email\", \"password\"\n        }\n\n    Returns:\n        _type_: response\n    \"\"\"\n    new_user = await user_service(db).register(user_create)\n    return {\n        \"message\": \"Registration Successful\",\n        \"data\": new_user,\n        \"status\": status.HTTP_201_CREATED,\n    }\n\n\n@user_router.post(\n    \"/login/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageLoginResponse,\n)\ndef login(login_user: OAuth2PasswordRequestForm = Depends(),db:Session = Depends(get_db)):\n    \"\"\"Login\n\n    Args:\n        login_user (OAuth2PasswordRequestForm, optional):username, password\n\n    Returns:\n        _type_: user\n    \"\"\"\n    user_login = user_service(db).login(login_user)\n    return user_login\n\n\n@user_router.get(\n    \"/me/\", status_code=status.HTTP_200_OK, response_model=schemas.MessageUserResponse\n)\ndef logged_in_user(current_user: dict = Depends(get_current_user)):\n    \"\"\"ME\n\n    Args:\n        current_user (dict, optional): _description_. Defaults to Depends(get_current_user): User data.\n\n    Returns:\n        _type_: User\n    \"\"\"\n    return {\"message\": \"Me Data\", \"data\": current_user, \"status\": status.HTTP_200_OK}\n\n\n@user_router.patch(\n    \"/update/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageUserResponse,\n)\ndef update_user(\n    update_user: schemas.UserUpdate, current_user: dict = Depends(get_current_user),db:Session = Depends(get_db)\n):\n    \"\"\"Update User\n\n    Args:\n        update_user (schemas.UserUpdate): all user fields.\n        current_user (dict, optional): _description_. Defaults to Depends(get_current_user): Logged In User.\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    update_user = user_service(db).update_user(update_user, current_user)\n\n    return {\n        \"message\": \"User Updated Successfully\",\n        \"data\": update_user,\n        \"status\": status.HTTP_200_OK,\n    }\n\n\n@user_router.delete(\"/delete/\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_user(current_user: dict = Depends(get_current_user),db:Session = Depends(get_db)):\n    \"\"\"Delete User\n\n    Args:\n        current_user (dict, optional): _description_. Defaults to Depends(get_current_user): Logged In User\n\n    Returns:\n        _type_: 204\n    \"\"\"\n    user_service(db).delete(current_user)\n    return {\"status\": status.HTTP_204_NO_CONTENT}\n\n\n@user_router.get(\"/refresh/\", status_code=status.HTTP_200_OK)\ndef get_new_token(new_access_token: str = Depends(verify_refresh_token)):\n    \"\"\"New Access token\n\n    Args:\n        new_access_token (str, optional): _description_. Defaults to Depends(verify_refresh_token): Gets Access token based on refresh token.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    return {\n        \"message\": \"New access token created successfully\",\n        \"token\": new_access_token,\n        \"status\": status.HTTP_200_OK,\n    }\n\n\n@user_router.patch(\n    \"/change-password/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageUserResponse,\n)\ndef change_password(\n    password_data: schemas.ChangePassword,\n    current_user: dict = Depends(get_current_user),\n    db:Session = Depends(get_db)    \n):\n    \"\"\"Change Password\n\n    Args:\n        password_data (schemas.ChangePassword): {password, old_password}\n        current_user (dict, optional): _description_. Defaults to Depends(get_current_user): Logged In User\n\n    Returns:\n        _type_: response\n    \"\"\"\n    resp = user_service(db).change_password(current_user, password_data)\n    return resp\n\n\n@user_router.post(\"/password-reset/complete/{token}/\", status_code=status.HTTP_200_OK)\ndef password_reset_complete(token: str, password_data: schemas.PasswordData,db:Session = Depends(get_db)):\n    \"\"\"Password Reset\n\n    Args:\n        token (str): _description_: Password reset token\n        password_data (schemas.PasswordData): {password}\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = user_service(db).password_reset_complete(token, password_data)\n    return resp\n\n\n@user_router.post(\"/reset-password/\", status_code=status.HTTP_200_OK)\nasync def reset_password(password_data: schemas.TokenData,db:Session = Depends(get_db)):\n    \"\"\"Reset Password\n\n    Args:\n        password_data (schemas.TokenData): eemail\n\n    Returns:\n        _type_: response\n    \"\"\"\n    resp = await user_service(db).password_reset(password_data.email)\n    return resp\n\n\n@user_router.post(\"/resend-account-verification/\", status_code=status.HTTP_200_OK)\nasync def resend_account_verification(email_data: schemas.TokenData,db:Session = Depends(get_db)):\n    \"\"\"Resend Account Verification\n\n    Args:\n        email_data (schemas.TokenData): email\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = await user_service(db).resend_verification_token(email_data.email)\n    return resp\n\n\n@user_router.post(\"/account-verification/{token}/\", status_code=status.HTTP_200_OK)\nasync def account_verification(token: str,db:Session = Depends(get_db)):\n    \"\"\"Account Verification\n\n    Args:\n        token (str): email verification token\n\n    Returns:\n        _type_: response\n    \"\"\"\n    resp = user_service(db).account_verification_complete(token)\n    return resp\n"}
{"type": "source_file", "path": "src/app/utils/mailer_util.py", "content": "from pathlib import Path\nfrom typing import List\n\n# 3rd party imports\nfrom fastapi_mail import ConnectionConfig, FastMail, MessageSchema, MessageType\n\n# application imports\nfrom src.app.config import EmailStr, mail_settings\n\n# conf configuration\nconf = ConnectionConfig(\n    MAIL_USERNAME=mail_settings.mail_username,\n    MAIL_PASSWORD=mail_settings.mail_password,\n    MAIL_FROM=mail_settings.mail_from,\n    MAIL_PORT=mail_settings.mail_port,\n    MAIL_SERVER=mail_settings.mail_server,\n    MAIL_FROM_NAME=mail_settings.mail_from_name,\n    MAIL_STARTTLS=True,\n    MAIL_SSL_TLS=False,\n    USE_CREDENTIALS=True,\n    VALIDATE_CERTS=False,\n    TEMPLATE_FOLDER=Path(__file__).parent.parent.parent / \"templates/\",\n)\n\n\nasync def send_mail(\n    recieptients: List[EmailStr], subject: str, body: dict, template_name: str\n) -> bool:\n    \"\"\"Send Mail\n\n    Args:\n        recieptients (List[EmailStr]): Array of Email\n        subject (str): Mail Subject\n        body (dict): an Hashmap/Dict of  data\n        template_name (str): the template name\n\n    Returns:\n        bool: status on success or failure.\n    \"\"\"\n    message = MessageSchema(\n        subject=subject,\n        recipients=recieptients,\n        template_body=body,\n        subtype=MessageType.html,\n    )\n    fm = FastMail(conf)\n\n    status = False\n    try:\n        await fm.send_message(message, template_name=template_name)\n        status = True\n    except Exception as e:\n        pass\n    return status\n"}
{"type": "source_file", "path": "src/auth/auth_service.py", "content": "# Framework Imports\nfrom fastapi import HTTPException, status\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.security.oauth2 import OAuth2PasswordRequestForm\n\n# application imports\nfrom src.app.utils.db_utils import hash_password, verify_password\nfrom src.app.utils.mailer_util import send_mail\nfrom src.app.utils.token import auth_retrieve_token, auth_settings, auth_token\nfrom src.auth import schemas\nfrom src.auth.auth_repository import token_repo, user_repo\nfrom src.auth.models import RefreshToken, User\nfrom src.auth.oauth import (\n    create_access_token,\n    create_refresh_token,\n    credential_exception,\n)\n\n\nclass UserService:\n    def __init__(self, db):\n        # Initializing Repositories\n        self.db =  db\n        self.user_repo = user_repo(self.db)\n        self.token_repo = token_repo(self.db)\n\n    async def register(self, user: schemas.user_create) -> User:\n        # checking if user exists.\n        user_check = self.user_repo.get_user(user.email)\n\n        # raise an Exception if user exists.\n        if user_check:\n            raise HTTPException(\n                detail=\"This User has an account\",\n                status_code=status.HTTP_400_BAD_REQUEST,\n            )\n        # password hashing\n        user.password = hash_password(user.password)\n        # creating new user\n        new_user = self.user_repo.create(user)\n        # create new access token\n        token = auth_token(new_user.email)\n        # mail data inserted in to the  template\n        mail_data = {\n            \"first_name\": new_user.first_name,\n            \"url\": f\"{auth_settings.frontend_url}auth/verification/{token}/\",\n        }\n        # mail title\n        mail_title = \"Verify your Account\"\n        template_pointer = \"user/verification.html\"\n        # send mail\n        await send_mail([new_user.email], mail_title, mail_data, template_pointer)\n\n        return new_user\n\n    def login(self, user: OAuth2PasswordRequestForm) -> schemas.LoginResponse:\n        # check if user exists.\n        user_check = self.user_repo.get_user(user.username)\n        # raise exception if there is no user\n        if not user_check:\n            raise HTTPException(\n                detail=\"User does not exist\", status_code=status.HTTP_400_BAD_REQUEST\n            )\n        # verify that the password is correct.\n        pass_hash_check = verify_password(user_check.password, user.password)\n        # raise credential error\n        if not pass_hash_check:\n            credential_exception()\n        # if user is not verified raise exception\n        if user_check.is_verified is False:\n            raise HTTPException(\n                detail=\"User Account is not verified\",\n                status_code=status.HTTP_401_UNAUTHORIZED,\n            )\n        # create Access and Refresh Token\n        tokenizer= {\"id\": user_check.id, \"email\": user_check.email}\n        access_token = create_access_token(tokenizer)\n        refresh_token = create_refresh_token(tokenizer)\n        # check if there is a previously existing refresh token\n        token_check = self.token_repo.get_token(user_check.id)\n        # if token update token column\n        if token_check:\n            token_check.token = refresh_token\n            self.token_repo.update_token(token_check)\n        else:\n            # create new token data\n            self.token_repo.create_token(refresh_token, user_check.id)\n\n        # validating data via the DTO\n        refresh_token_ = {\"token\": refresh_token, \"header\": \"Refresh-Tok\"}\n        login_resp = schemas.LoginResponse(\n            data=user_check,\n            refresh_token=refresh_token_,\n        )\n        # DTO response\n        resp = {\n            \"message\": \"Login Successful\",\n            \"data\": login_resp,\n            \"access_token\": access_token,\n            \"token_type\": \"bearer\",\n            \"status\": status.HTTP_200_OK,\n        }\n        return resp\n\n    def update_user(self, update_user: schemas.UserUpdate, user: User) -> User:\n        # update user\n        update_user_dict = update_user.dict(exclude_unset=True)\n\n        for key, value in update_user_dict.items():\n            setattr(user, key, value)\n\n        return self.user_repo.update(user)\n\n    def delete(self, user: User) -> bool:\n        # delete user\n        return self.user_repo.delete(user)\n\n    async def password_reset(self, user_email: str):\n        # check if user exist.\n        user = self.user_repo.get_user(user_email)\n        # raise Exception if user does not exist.\n        if not user:\n            raise HTTPException(\n                detail=\"User does not exist\", status_code=status.HTTP_404_NOT_FOUND\n            )\n        # create Timed Token\n        token = auth_token(user.email)\n        # mail data\n        mail_data = {\n            \"first_name\": user.first_name,\n            \"url\": f\"{auth_settings.frontend_url}/auth/verification/{token}/\",\n        }\n        # mail subject\n        mail_title = \"Reset your Password\"\n        template_pointer = \"/user/verification.html\"\n        # send mail\n        mail_status = await send_mail(\n            [user.email], mail_title, mail_data, template_pointer\n        )\n        # response based on the success or failure of sending mail\n        if mail_status:\n            return {\n                \"message\": \"Reset Mail sent successfully\",\n                \"status\": status.HTTP_200_OK,\n                \"mail_status\": mail_status,\n            }\n        else:\n            return {\n                \"message\": \"Reset Mail was not sent\",\n                \"status\": status.HTTP_400_BAD_REQUEST,\n                \"mail_status\": mail_status,\n            }\n\n    def password_reset_complete(self, token: str, password_data: schemas.PasswordData):\n        # extract data from timed token\n        data = auth_retrieve_token(token)\n        # if data is None raise Exception\n        if data is None:\n            raise HTTPException(\n                detail=\"Token has expired.\", status_code=status.HTTP_409_CONFLICT\n            )\n        # check for user based on tokjen data\n\n        user = self.user_repo.get_user(data)\n        # raise exception if user does not exist.\n        if not user:\n            raise HTTPException(\n                detail=\"User does not exist\", status_code=status.HTTP_404_NOT_FOUND\n            )\n        # update newly set password in hash\n        user.password = hash_password(password_data.password)\n        # update user\n        self.user_repo.update(user)\n        return {\n            \"message\": \"User password set successfully\",\n            \"status\": status.HTTP_200_OK,\n        }\n\n    def change_password(self, user: User, password_data: schemas.ChangePassword):\n        # verify oldpassword is saved in the DB\n        password_check = verify_password(user.password, password_data.old_password)\n        # if not True raise Exception\n        if not password_check:\n            raise HTTPException(\n                detail=\"Old Password does not corelate.\",\n                status_code=status.HTTP_400_BAD_REQUEST,\n            )\n        # hash new password\n        user.password = hash_password(password_data.password)\n        # update user\n        user = self.user_repo.update(user)\n        # return user\n        return {\n            \"message\": \"Password changed successfully\",\n            \"data\": user,\n            \"status\": status.HTTP_200_OK,\n        }\n\n    async def resend_verification_token(self, user_email: str):\n        # get user\n        user = self.user_repo.get_user(user_email)\n        # if not user raise Exception\n        if not user:\n            raise HTTPException(\n                detail=\"User does not exist\", status_code=status.HTTP_404_NOT_FOUND\n            )\n        # create timed token\n        token = auth_token(user.email)\n        # mail data for the template\n        mail_data = {\n            \"first_name\": user.first_name,\n            \"url\": f\"{auth_settings.frontend_url}/auth/verification/{token}/\",\n        }\n        # mail subject\n        mail_title = \"Verify your Account\"\n        template_pointer = \"/user/verification.html\"\n        # send email\n        mail_status = await send_mail(\n            [user.email], mail_title, mail_data, template_pointer\n        )\n        # if mail sent send this else\n        if mail_status:\n            return {\n                \"message\": \"Account Verification Mail sent successfully\",\n                \"status\": status.HTTP_200_OK,\n                \"mail_status\": mail_status,\n            }\n        else:\n            return {\n                \"message\": \"Account Verification Mail was not sent\",\n                \"status\": status.HTTP_400_BAD_REQUEST,\n                \"mail_status\": mail_status,\n            }\n\n    def account_verification_complete(self, token: str):\n        # validate token\n        data = auth_retrieve_token(token)\n        # raise token Error if None\n        if data is None:\n            raise HTTPException(\n                detail=\"Token has expired.\", status_code=status.HTTP_409_CONFLICT\n            )\n        # get user based on the data\n        user = self.user_repo.get_user(data)\n        # if user does not exists raise Exception\n        if not user:\n            raise HTTPException(\n                detail=\"User does not exist\", status_code=status.HTTP_404_NOT_FOUND\n            )\n        # update user verification flag.\n        user.is_verified = True\n        self.user_repo.update(user)\n        return {\n            \"message\": \"User Account is verified successfully\",\n            \"status\": status.HTTP_200_OK,\n        }\n\n\n# Instanting the UserService class\nuser_service = UserService\n"}
{"type": "source_file", "path": "src/app/utils/db_utils.py", "content": "from passlib.context import CryptContext\nfrom src.app.database import SessionFactory\n# Password Hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef verify_password(hashed_password: str, plain_password: str) -> bool:\n    \"\"\"Verify Password\n\n    Args:\n        hashed_password (str): Stored passwoed in the DB compared with the raw string\n        plain_password (str): Raw string  to be compared.\n\n    Returns:\n        _type_: Bool\n    \"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hashes Password string\n\n    Args:\n        password (str): String\n\n    Returns:\n        str: Hashed string\n    \"\"\"\n    return pwd_context.hash(password)\n\n\n\ndef get_db():\n    db = SessionFactory()\n\n    try:\n        yield db\n    except: \n        db.rollback()\n        \n    finally:\n        db.close()"}
{"type": "source_file", "path": "src/migrations/versions/b59eb2cd4e8c_user_table.py", "content": "\"\"\"User Table\n\nRevision ID: b59eb2cd4e8c\nRevises: \nCreate Date: 2023-02-05 13:56:20.314855\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = \"b59eb2cd4e8c\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    op.create_table(\n        \"users\",\n        sa.Column(\"id\", sa.Integer),\n        sa.Column(\"first_name\", sa.String(), nullable=False),\n        sa.Column(\"last_name\", sa.String(), nullable=False),\n        sa.Column(\"email\", sa.String, unique=True, nullable=False),\n        sa.Column(\"password\", sa.String, nullable=False),\n        sa.Column(\"is_verified\", sa.Boolean, nullable=False),\n        sa.Column(\"is_premium\", sa.Boolean, nullable=False),\n        sa.Column(\n            \"date_created\", sa.TIMESTAMP(timezone=True), server_default=sa.text(\"now()\")\n        ),\n        sa.Column(\n            \"date_updated\", sa.TIMESTAMP(timezone=True), server_default=sa.text(\"now()\")\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_table(\n        \"user_refresh_token\",\n        sa.Column(\"id\", sa.Integer),\n        sa.Column(\"user_id\", sa.Integer, nullable=False),\n        sa.Column(\"token\", sa.String, nullable=False),\n        sa.Column(\n            \"date_created\", sa.TIMESTAMP(timezone=True), server_default=sa.text(\"now()\")\n        ),\n        sa.Column(\n            \"date_updated\", sa.TIMESTAMP(timezone=True), server_default=sa.text(\"now()\")\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n        sa.ForeignKeyConstraint([\"user_id\"], [\"users.id\"], ondelete=\"CASCADE\"),\n    )\n    pass\n\n\ndef downgrade() -> None:\n    op.drop_constraint(\"user_refresh_token_user_id_fkey\", \"user_refresh_token\")\n    op.drop_table(\"user_refresh_token\")\n    op.drop_table(\"users\")\n    pass\n"}
{"type": "source_file", "path": "src/organization/__init__.py", "content": ""}
{"type": "source_file", "path": "src/migrations/versions/80f9e1cc8879_organization_table.py", "content": "\"\"\"Organization Table\n\nRevision ID: 80f9e1cc8879\nRevises: b59eb2cd4e8c\nCreate Date: 2023-02-05 17:37:00.078276\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = \"80f9e1cc8879\"\ndown_revision = \"b59eb2cd4e8c\"\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    op.create_table(\n        \"organization\",\n        sa.Column(\"id\", sa.Integer),\n        sa.Column(\"name\", sa.String(), nullable=False),\n        sa.Column(\"slug\", sa.String(), nullable=False),\n        sa.Column(\"created_by\", sa.Integer(), nullable=True),\n        sa.Column(\"revoke_link\", sa.Boolean(), server_default=sa.text(\"false\")),\n        sa.Column(\n            \"date_created\", sa.TIMESTAMP(timezone=True), server_default=sa.text(\"now()\")\n        ),\n        sa.Column(\n            \"date_updated\", sa.TIMESTAMP(timezone=True), server_default=sa.text(\"now()\")\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n        sa.ForeignKeyConstraint([\"created_by\"], [\"users.id\"], ondelete=\"SET NULL\"),\n    )\n\n    op.create_table(\n        \"organization_member\",\n        sa.Column(\"id\", sa.Integer),\n        sa.Column(\"org_id\", sa.Integer(), nullable=False),\n        sa.Column(\"member_id\", sa.Integer(), nullable=False),\n        sa.Column(\"role\", sa.String(), nullable=False),\n        sa.Column(\n            \"date_created\", sa.TIMESTAMP(timezone=True), server_default=sa.text(\"now()\")\n        ),\n        sa.Column(\n            \"date_updated\", sa.TIMESTAMP(timezone=True), server_default=sa.text(\"now()\")\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n        sa.ForeignKeyConstraint([\"org_id\"], [\"organization.id\"], ondelete=\"CASCADE\"),\n        sa.ForeignKeyConstraint([\"member_id\"], [\"users.id\"], ondelete=\"CASCADE\"),\n    )\n    pass\n\n\ndef downgrade() -> None:\n    op.drop_constraint(\n        \"organization_member_member_id_fkey\", table_name=\"organization_member\"\n    )\n    op.drop_constraint(\n        \"organization_member_org_id_fkey\", table_name=\"organization_member\"\n    )\n    op.drop_table(\"organization\")\n    op.drop_table(\"organization_member\")\n    pass\n"}
{"type": "source_file", "path": "src/organization/pipes/__init__.py", "content": ""}
{"type": "source_file", "path": "src/organization/org_repository.py", "content": "# application imports\n\nfrom src.organization.models import Organization, OrgMember\nfrom sqlalchemy.orm import Session\n\nclass OrgRepo():\n    # org base query\n\n    def __init__(self, db:Session ) -> None:\n        self.db = db\n    def base_query(self):\n        return self.db.query(Organization)\n\n    # check if Org exists.\n    def check_org(self, name: str):\n        return self.base_query().filter(Organization.name.ilike(name)).first()\n\n    # get org by slug\n    def get_org(self, slug: str):\n        return self.base_query().filter(Organization.slug == slug).first()\n\n    # get orgs  that user is a member of.\n    def get_user_orgs(self, user_id: int):\n        return (\n            self.base_query()\n            .filter(Organization.org_member.member_id.has(id=user_id))\n            .all()\n        )\n\n    # all orgs created by a user\n    def get_orgs_created_by_user(self, user_id: int):\n        return self.base_query().filter(Organization.created_by == user_id).all()\n\n    # return org_count and data\n    def user_org_count_data(self, user_id: int):\n        user_org = (\n            self.base_query()\n            .filter(Organization.org_member.any(member_id=user_id))\n            .all()\n        )\n        org_count = (\n            self.base_query()\n            .filter(Organization.org_member.any(member_id=user_id))\n            .count()\n        )\n        return user_org, org_count\n\n    # create Org\n    def create_org(self, org_create: dict):\n        new_org = Organization(**org_create)\n        self.db.add(new_org)\n        self.db.commit()\n        self.db.refresh(new_org)\n        return new_org\n\n    # update Org\n    def update_org(self, org_update: Organization):\n        self.db.commit()\n        self.db.refresh(org_update)\n        return org_update\n\n    # delete Org\n    def delete_org(self, org: Organization):\n        self.db.delete(org)\n        self.db.commit()\n\n\nclass OrgMemberRepo():\n\n    def __init__(self, db:Session) -> None:\n        self.db = db\n    # base query\n    def base_query(self):\n        return self.db.query(OrgMember)\n\n    # get org members based on org_id and member id\n    def get_org_member(self, org_id: int, id: int):\n        return (\n            self.base_query()\n            .filter(\n                OrgMember.org_id == org_id,\n                OrgMember.id == id,\n            )\n            .first()\n        )\n\n    # get membership data based on org_id and user_id\n    def get_org_member_by_user_id(self, org_id: int, user_id: int):\n        return (\n            self.base_query()\n            .filter(\n                OrgMember.org_id == org_id,\n                OrgMember.member_id == user_id,\n            )\n            .first()\n        )\n\n    # get all org members by org_id\n    def get_org_members(self, org_id: int):\n        return (\n            self.base_query()\n            .filter(\n                OrgMember.org_id == org_id,\n            )\n            .all()\n        )\n\n    # create org member\n    def create_org_member(self, org_member: dict):\n        new_org_member = OrgMember(**org_member)\n        self.db.add(new_org_member)\n        self.db.commit()\n        self.db.refresh(new_org_member)\n        return new_org_member\n\n    # update org memeber\n    def update_org_member(self, org_update):\n        self.db.commit()\n        self.db.refresh(org_update)\n        return org_update\n\n    # delete member\n    def delete_org_member(self, org):\n        self.db.delete(org)\n        self.db.commit()\n\n\norg_repo = OrgRepo\norg_member_repo = OrgMemberRepo\n"}
{"type": "source_file", "path": "src/organization/org_service.py", "content": "# Fastapi imports\nfrom fastapi import HTTPException, status\nfrom fastapi.encoders import jsonable_encoder\n\n# application imports\nfrom src.app.config import auth_settings\nfrom src.app.utils.schemas_utils import RoleOptions\nfrom src.app.utils.slugger import slug_gen\nfrom src.app.utils.token import gen_token, retrieve_token\nfrom src.auth.auth_repository import user_repo\nfrom src.organization import schemas\nfrom src.organization.models import Organization, OrgMember\nfrom src.organization.org_repository import org_member_repo, org_repo\n\n\nclass OrgService:\n    def __init__(self,db):\n        # intializing repository\n        self.db = db\n        self.org_repo = org_repo(self.db)\n        self.org_member_repo = org_member_repo(self.db)\n\n    # orm call org\n    def orm_call(self, org: Organization):\n        org_ = org.__dict__\n        org_[\"creator\"] = org.creator\n        org_[\"members\"] = org.org_member\n        return org_\n\n    # orm call org member\n    def member_orm_call(self, org_member: OrgMember):\n        org_member_ = jsonable_encoder(org_member)\n        org_member_[\"org\"] = org_member.org\n        org_member_[\"user\"] = org_member.member\n        return org_member_\n\n    def create_org(\n        self, user_id: int, org_create: schemas.OrgCreate\n    ) -> schemas.MessageOrgResp:\n        # check org\n        org_check = self.org_repo.check_org(org_create.name)\n        if org_check:\n            raise HTTPException(\n                detail=\"Org exist\", status_code=status.HTTP_409_CONFLICT\n            )\n        # data mapping\n        org_dict = org_create.dict()\n        org_dict[\"slug\"] = slug_gen()[:14]\n        org_dict[\"created_by\"] = user_id\n\n        # create org\n        org = self.org_repo.create_org(org_dict)\n        # org member data mapping\n        org_member_dict = {\n            \"org_id\": org.id,\n            \"member_id\": user_id,\n            \"role\": RoleOptions.admin.value,\n        }\n        # create org member\n        self.org_member_repo.create_org_member(org_member_dict)\n        # org orm member\n        org = self.orm_call(org)\n        resp = {\n            \"message\": \"Org Created Successfully\",\n            \"data\": org,\n            \"status\": status.HTTP_201_CREATED,\n        }\n\n        return resp\n\n    def get_org(self, slug: str) -> schemas.MessageOrgResp:\n        # chek for org\n        org = self.org_repo.get_org(slug)\n        if not org:\n            raise HTTPException(\n                detail=\"Org does not exists\",\n                status_code=status.HTTP_404_NOT_FOUND,\n            )\n\n        # orm call\n        org_ = self.orm_call(org)\n        resp = {\n            \"message\": \"Org Returned\",\n            \"data\": org_,\n            \"status\": status.HTTP_200_OK,\n        }\n        return resp\n\n    def get_user_org(self, user_id: int) -> schemas.MessageListOrgResp:\n        # all orgs a user belongs too\n        user_orgs, _ = self.org_repo.user_org_count_data(user_id)\n        # if not ORg raise HTTPException\n        if not user_orgs:\n            raise HTTPException(\n                detail=\"User Does not have Orgs\",\n                status_code=status.HTTP_404_NOT_FOUND,\n            )\n\n        # ORM call\n        orgs = []\n        for user_org in user_orgs:\n            orgs.append(self.orm_call(user_org))\n\n        resp = {\n            \"message\": \"User Orgs retrieved successfully\",\n            \"data\": orgs,\n            \"status\": status.HTTP_200_OK,\n        }\n        return resp\n\n    def update_org(\n        self, slug: str, update_org: schemas.OrgUpdate\n    ) -> schemas.MessageOrgResp:\n        # check org\n        org = self.org_repo.get_org(slug)\n        if not org:\n            raise HTTPException(\n                detail=\"Org does not exists\",\n                status_code=status.HTTP_404_NOT_FOUND,\n            )\n        # update Org\n        org_update_ = update_org.dict(exclude_unset=True)\n        # update org\n        for key, value in org_update_.items():\n            setattr(org, key, value)\n\n        org = self.org_repo.update_org(org)\n        # orm call\n        org_ = self.orm_call(org)\n        resp = {\n            \"message\": \"Org Updated Successfully\",\n            \"data\": org_,\n            \"status\": status.HTTP_200_OK,\n        }\n        return resp\n\n    def delete_org(self, slug: str):\n        # check org\n        org = self.org_repo.get_org(slug)\n\n        if not org:\n            raise HTTPException(\n                detail=\"Org does not exists\",\n                status_code=status.HTTP_404_NOT_FOUND,\n            )\n        # delete org\n        self.org_repo.delete_org(org)\n\n    # raise HTTPException if not org\n    def org_check(self, workspace):\n        if not workspace:\n            raise HTTPException(\n                detail=\"Org does not exist\", status_code=status.HTTP_404_NOT_FOUND\n            )\n\n    def org_link_invite(self, slug: str, role: RoleOptions):\n        #  check org\n        org = self.org_repo.get_org(slug)\n        self.org_check(org)\n\n        # generate tokens\n        token = gen_token(org.slug)\n        role_tok = gen_token(role)\n        if org.revoke_link:\n            org.revoke_link = False\n            self.org_repo.update_org(org)\n\n        name = org.name.split(\" \")\n        name = \"-\".join(name)\n        # generate link\n        invite_link = f\"{auth_settings.frontend_url}{name}/invite/{token}/{role_tok}/mixer=invite/\"\n        resp = {\n            \"message\": \"Invite Link Created successfully\",\n            \"data\": invite_link,\n            \"status\": status.HTTP_200_OK,\n        }\n        return resp\n\n    def revoke_org_link(self, org_slug: str):\n        # check for org\n        org = self.org_repo.get_org(org_slug)\n        self.org_check(org)\n        # revoke link\n        org.revoke_link = True\n        # org update\n        self.org_repo.update_org(org)\n        # orm call\n        org_ = self.orm_call(org)\n\n        resp = {\n            \"message\": \"Org revoked successfully\",\n            \"data\": org_,\n            \"status\": status.HTTP_200_OK,\n        }\n        return resp\n\n    # member org check\n    def get_org_member_check(self, id: int, org_id: int):\n        return self.org_member_repo.get_org_member(org_id, id)\n\n    # raise Exception if not a member\n    def org_member_check(self, org_member):\n        if not org_member:\n            raise HTTPException(\n                detail=\"User is not a member of the workspace\",\n                status_code=status.HTTP_404_NOT_FOUND,\n            )\n\n    # raise Exception if aleady a member\n    def org_member_check_(self, org_member):\n        if org_member:\n            raise HTTPException(\n                detail=\"User is a member of the workspace\",\n                status_code=status.HTTP_404_NOT_FOUND,\n            )\n\n    def join_org(\n        self, token: str, role_token: str, join_workspace: schemas.JoinOrg\n    ) -> schemas.MessageOrgMembResp:\n        token_data = retrieve_token(token)\n        role_tok_data = retrieve_token(role_token)\n        # if not token_data raise Exception\n        if not token_data:\n            raise HTTPException(\n                detail=\"Token invalid\", status_code=status.HTTP_409_CONFLICT\n            )\n        # if not role_tok_data specify role to member\n        if not role_tok_data:\n            role_tok_data = RoleOptions.member\n\n        # check if org exists.\n        org_check = self.org_repo.get_org(token_data)\n\n        if not org_check:\n            raise HTTPException(\n                detail=\"Org does not exist\", status_code=status.HTTP_404_NOT_FOUND\n            )\n        # check if org link is revoked\n        if org_check.revoke_link is True:\n            raise HTTPException(\n                detail=\"Link for Invitation has been revoked\",\n                status_code=status.HTTP_400_BAD_REQUEST,\n            )\n        # check if invited email belongs to a user\n        user_check = user_repo(self.db).get_user(join_workspace.email)\n        # raise Exception if no User\n        if not user_check:\n            raise HTTPException(\n                detail=\"No account for this detail\",\n                status_code=status.HTTP_404_NOT_FOUND,\n            )\n\n        # check if user is a member of the org\n        org_mem_check = self.org_member_repo.get_org_member_by_user_id(\n            org_check.id, user_check.id\n        )\n        self.org_member_check_(org_mem_check)\n        # data mapping\n        org_member_data = {\n            \"member_id\": user_check.id,\n            \"role\": role_tok_data,\n            \"org_id\": org_check.id,\n        }\n        # create org member\n        org_member = self.org_member_repo.create_org_member(org_member_data)\n        # orm call\n        org_member_ = self.member_orm_call(org_member)\n        resp = {\n            \"message\": \"User Joined Org\",\n            \"data\": org_member_,\n            \"status\": status.HTTP_201_CREATED,\n        }\n\n        return resp\n\n    def get_org_member(self, id: int, org_slug: str) -> schemas.MessageOrgMembResp:\n        # get Org\n        org = self.org_repo.get_org(org_slug)\n        self.org_check(org)\n        # check Org Member\n        org_member_check = self.get_org_member_check(id, org.id)\n        self.org_member_check(org_member_check)\n        # orm call\n        org_member = self.member_orm_call(org_member_check)\n        resp = {\n            \"message\": \"Org Member Retrieved Successfully\",\n            \"data\": org_member,\n            \"status\": status.HTTP_200_OK,\n        }\n\n        return resp\n\n    def get_all_org_member(self, org_slug: str) -> schemas.MessageListOrgResp:\n        # check org\n        org = self.org_repo.get_org(org_slug)\n        self.org_check(org)\n\n        # check for members\n        org_member_check = self.org_member_repo.get_org_members(org.id)\n        self.org_member_check(org_member_check)\n\n        # orm call\n        org_member_ = []\n        for org_member in org_member_check:\n            org_member_.append(self.member_orm_call(org_member))\n\n        resp = {\n            \"message\": \"Org Members retrieved successfully\",\n            \"data\": org_member_,\n            \"status\": status.HTTP_200_OK,\n        }\n        return resp\n\n    def update_org_member(\n        self,\n        org_slug: str,\n        id: int,\n        role_update: schemas.UpdateOrgMember,\n    ):\n        # org check\n        org = self.org_repo.get_org(org_slug)\n        self.org_check(org)\n        # member check\n        org_member = self.org_member_repo.get_org_member(org.id, id)\n        self.org_member_check(org_member)\n        # Update role\n        org_member.role = role_update.role\n        # update org member insntance\n        org_member = self.org_member_repo.update_org_member(org_member)\n        org_member_ = self.member_orm_call(org_member)\n        resp = {\n            \"message\": \"Org Member Updated Successfully\",\n            \"data\": org_member_,\n            \"status\": status.HTTP_200_OK,\n        }\n\n        return resp\n\n    def delete_org_member(self, org_slug: str, user_id: int):\n        # check for Org\n        org = self.org_repo.get_org(org_slug)\n        self.org_check(org)\n        # checking for org memeber\n        org_member = self.org_member_repo.get_org_member(org.id, user_id)\n        self.org_member_check(org_member)\n        # deleting the org memeber\n        self.org_member_repo.delete_org_member(org_member)\n\n    def leave_org(self, org_slug: str, user_id: int):\n        # check for ORg\n        org = self.org_repo.get_org(org_slug)\n        self.org_check(org)\n        # check for org_member innstance\n        org_member = self.org_member_repo.get_org_member_by_user_id(org.id, user_id)\n        self.org_member_check(org_member)\n        # deleting the instance\n        self.org_member_repo.delete_org_member(org_member)\n\n\norg_service = OrgService\n"}
{"type": "source_file", "path": "src/organization/models.py", "content": "# 3rd party imports\nfrom sqlalchemy import Boolean, Column, ForeignKey, Integer, String, text\nfrom sqlalchemy.orm import relationship\n\n# Application import\nfrom src.app.utils.models_utils import AbstractModel\nfrom src.auth.models import User\n\n\n# Organization Table.\nclass Organization(AbstractModel):\n    __tablename__ = \"organization\"\n    name = Column(String, nullable=False)\n    slug = Column(String, nullable=False)\n    created_by = Column(\n        Integer, ForeignKey(\"users.id\", ondelete=\"SET NULL\"), nullable=True\n    )\n    revoke_link = Column(Boolean, server_default=text(\"false\"))\n    creator = relationship(\"User\")\n    org_member = relationship(\n        \"OrgMember\", back_populates=\"org\", cascade=\"all, delete-orphan\"\n    )\n\n\n# Organization Member Table.\nclass OrgMember(AbstractModel):\n    __tablename__ = \"organization_member\"\n    org_id = Column(\n        Integer, ForeignKey(\"organization.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    member_id = Column(\n        Integer, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    role = Column(String, nullable=False)\n    member = relationship(\"User\")\n    org = relationship(\"Organization\")\n"}
{"type": "source_file", "path": "src/organization/pipes/org_dep.py", "content": "# framework imports\nfrom fastapi import Depends, HTTPException, status\n\n# application imports\nfrom src.auth.oauth import get_current_user\nfrom src.organization.org_repository import org_repo\nfrom src.permissions.org_permissions import org_perms\nfrom src.app.utils.db_utils import get_db\nfrom sqlalchemy.orm import Session\n\n\n# Allows a User to create more than 2 Organization if Premium user\ndef premium_ulimited_orgs(current_user: dict = Depends(get_current_user),db:Session = Depends(get_db)):\n    user_orgs = org_repo(db).get_orgs_created_by_user(user_id=current_user.id)\n    if user_orgs:\n        if current_user.is_premium is False:\n            if len(user_orgs) >= 2:\n                raise HTTPException(\n                    detail=\"Freemium Users can only create a Maximum of two Orgs\",\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                )\n    return current_user\n\n\n# Admin Right check.\ndef admin_rights_dep(org_slug: str, current_user: dict = Depends(get_current_user),db:Session = Depends(get_db)):\n    org_perms(db).admin_right(current_user, org_slug)\n    return current_user\n\n\n# Check logged in user is a member of an Organization.\ndef member_dep(org_slug: str, current_user: dict = Depends(get_current_user),db:Session = Depends(get_db)):\n    org_perms(db).org_member_check(current_user, org_slug)\n    return current_user\n"}
{"type": "source_file", "path": "src/permissions/__init__.py", "content": ""}
{"type": "source_file", "path": "src/organization/schemas.py", "content": "# python imports\nfrom typing import List, Optional, Union\n\n# 3rd party imports\nfrom pydantic import EmailStr\n\n# application imports\nfrom src.app.utils.schemas_utils import AbstractModel, ResponseModel, RoleOptions, User\n\n\n# Org Create DTO\nclass OrgCreate(AbstractModel):\n    name: str\n\n\n# Org Member\nclass OrgMember(AbstractModel):\n    role: str\n    member: User\n\n\n# Org Response\nclass OrgResponse(OrgCreate):\n    id: int\n    slug: str\n    revoke_link: Optional[bool]\n    creator: User\n    members: Union[List[OrgMember], None]\n\n\n# Org Response DTO\nclass MessageOrgResp(ResponseModel):\n    data: OrgResponse\n\n\n# All Org Response DTO\nclass MessageListOrgResp(ResponseModel):\n    data: List[OrgResponse]\n\n\n# Org Update\nclass OrgUpdate(AbstractModel):\n    name: Optional[str]\n    revoke_link: Optional[bool]\n\n\n# Update Role\nclass UpdateRole(AbstractModel):\n    role: RoleOptions\n\n\n# ORG ORG Resp\nclass Org(AbstractModel):\n    name: str\n    slug: str\n\n\n# OrgMember Response DTO\nclass OrgMemberResponse(AbstractModel):\n    id: int\n    org: Org\n    user: User\n    role: str\n\n\n# OrgMemberResponse DTO\nclass MessageOrgMembResp(ResponseModel):\n    data: OrgMemberResponse\n\n\n# List of OrgMembersResponse DTO\nclass MessageListOrgMemResp(ResponseModel):\n    data: List[OrgMemberResponse]\n\n\n# Join Org\nclass JoinOrg(AbstractModel):\n    email: EmailStr\n\n\n# Update OrgMemberRole\nclass UpdateOrgMember(AbstractModel):\n    role: RoleOptions\n\n\n# Invite Org Resp\nclass InviteOrgResponse(ResponseModel):\n    data: str\n"}
{"type": "source_file", "path": "src/permissions/org_permissions.py", "content": "# framework imports\nfrom fastapi import HTTPException, status\n\n# application imports\nfrom src.app.utils.schemas_utils import RoleOptions\nfrom src.auth.models import User\nfrom src.organization.org_repository import Organization, org_member_repo, org_repo\n\n\nclass OrgPerms:\n    def __init__(self, db) -> None:\n        # intializing organization repos\n        self.db =db\n        self.repo = org_repo(self.db)\n        self.member_repo = org_member_repo(self.db)\n\n    # check if an Organization Exists\n    def org_check(self, org_slug: str):\n        org_ = self.repo.get_org(org_slug)\n        if not org_:\n            raise HTTPException(\n                detail=\"No Organization with this slug\",\n                status_code=status.HTTP_404_NOT_FOUND,\n            )\n\n        return org_\n\n    # checks if a user is a Memeber of an Organization\n    def org_member_check(self, current_user: User, org_slug: str):\n        org = self.org_check(org_slug)\n        org_member = self.member_repo.get_org_member_by_user_id(org.id, current_user.id)\n        if not org_member:\n            raise HTTPException(\n                detail=\"Logged in User is not a member of this Organization\",\n                status_code=status.HTTP_404_NOT_FOUND,\n            )\n        return org_member\n\n    # Checks if a user is an Admin\n    def admin_right(self, current_user: User, org_slug: str):\n        org_member = self.org_member_check(current_user, org_slug)\n        if org_member.role != RoleOptions.admin.value:\n            raise HTTPException(\n                detail=\"Org Member is not Admin\", status_code=status.HTTP_409_CONFLICT\n            )\n\n\n# instantiaion OrgPerms\norg_perms = OrgPerms\n"}
{"type": "source_file", "path": "src/organization/org_router.py", "content": "# framework import\nfrom fastapi import APIRouter, Depends, status\n\n# application imports\nfrom src.auth.models import User\nfrom src.auth.oauth import get_current_user\nfrom src.organization import schemas\nfrom src.organization.org_service import org_service\nfrom src.organization.pipes import org_dep\nfrom src.app.utils.db_utils import get_db\nfrom sqlalchemy.orm import Session\n\n\n# org router\norg_router = APIRouter(prefix=\"/api/v1/org\", tags=[\"Organization and Org Members\"])\n\n\n@org_router.post(\n    \"/create/\",\n    status_code=status.HTTP_201_CREATED,\n    response_model=schemas.MessageOrgResp,\n)\ndef create_org(\n    create_workspace: schemas.OrgCreate,\n    current_user: User = Depends(org_dep.premium_ulimited_orgs),db:Session = Depends(get_db)\n):\n    \"\"\"Create Org\n\n    Args:\n        create_workspace (schemas.OrgCreate): data\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.premium_ulimited_orgs): Premium check.\n\n    Returns:\n        _type_: Resp\n    \"\"\"\n    resp = org_service(db).create_org(current_user.id, create_workspace)\n\n    return resp\n\n\n@org_router.get(\n    \"s/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageListOrgResp,\n)\ndef get_orgs(current_user: User = Depends(get_current_user),db:Session = Depends(get_db)):\n    \"\"\"Get Orgs\n\n    Args:\n        current_user (User, optional): _description_. Defaults to Depends(get_current_user): Logged in User.\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = org_service(db).get_user_org(current_user.id)\n\n    return resp\n\n\n@org_router.get(\n    \"/{org_slug}/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageOrgResp,\n)\ndef get_org(org_slug: str, current_user: User = Depends(org_dep.member_dep),db:Session = Depends(get_db)):\n    \"\"\"Get Org\n\n    Args:\n        org_slug (str): slug\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.member_dep): Logged in Org Member\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = org_service(db).get_org(org_slug)\n\n    return resp\n\n\n@org_router.patch(\n    \"/{org_slug}/update/\",\n    response_model=schemas.MessageOrgResp,\n    status_code=status.HTTP_200_OK,\n)\ndef org_update(\n    org_slug: str,\n    update_org: schemas.OrgUpdate,\n    current_user: User = Depends(org_dep.admin_rights_dep),db:Session = Depends(get_db)\n):\n    \"\"\"Org Update\n\n    Args:\n        org_slug (str): Slug\n        update_org (schemas.OrgUpdate): Data\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.admin_rights_dep): Loggeed inn userr with write access.\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = org_service(db).update_org(org_slug, update_org)\n\n    return resp\n\n\n@org_router.delete(\n    \"/{org_slug}/delete/\",\n    status_code=status.HTTP_204_NO_CONTENT,\n)\ndef org_delete(org_slug: str, current_user: User = Depends(org_dep.admin_rights_dep),db:Session = Depends(get_db)):\n    \"\"\"Delete Organization\n\n    Args:\n        org_slug (str): Slug\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.admin_rights_dep)= Write access.\n\n    Returns:\n        _type_: 204\n    \"\"\"\n    org_service(db).delete_org(org_slug)\n\n    return {\"status\": status.HTTP_204_NO_CONTENT}\n\n\n@org_router.post(\n    \"/{org_slug}/invite-link/gen/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.InviteOrgResponse,\n)\ndef generate_org_invite_link(\n    org_slug: str,\n    role_data: schemas.UpdateOrgMember,\n    current_user: User = Depends(org_dep.admin_rights_dep),db:Session = Depends(get_db)\n):\n    \"\"\"GENERATE ORG LINK\n\n    Args:\n        org_slug (str): str\n        role_data (schemas.UpdateOrgMember): role information\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.admin_rights_dep).\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = org_service(db).org_link_invite(org_slug, role_data.role)\n\n    return resp\n\n\n@org_router.post(\n    \"/{org_slug}/revoke-link/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageOrgResp,\n)\ndef revoke_org(org_slug: str, current_user: User = Depends(org_dep.admin_rights_dep),db:Session = Depends(get_db)):\n    \"\"\"Revoke Org Access\n\n    Args:\n        org_slug (str): slug\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.admin_rights_dep): Logged in user with right access.\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = org_service(db).revoke_org_link(org_slug)\n    return resp\n\n\n@org_router.post(\n    \"/join/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageOrgMembResp,\n)\ndef org_member_join(token: str, role_token: str, new_org_member: schemas.JoinOrg,db:Session = Depends(get_db)):\n    \"\"\"Join Org\n\n    Args:\n        token (str): str\n        role_token (str): role token\n        new_org_member (schemas.JoinOrg): data\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = org_service(db).join_org(token, role_token, new_org_member)\n\n    return resp\n\n\n@org_router.get(\n    \"/{org_slug}/member/{member_id}/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageOrgMembResp,\n)\ndef get_org_member(\n    org_slug: str, member_id: int, current_user: User = Depends(org_dep.member_dep),db:Session = Depends(get_db)\n):\n    \"\"\"Get Org  Member\n\n    Args:\n        org_slug (str): Slug\n        member_id (int): Member id\n        current_user (User, optional): _description_. Defaults to Depends(get_current_user): Logged in User a member of Org.\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = org_service(db).get_org_member(member_id, org_slug)\n\n    return resp\n\n\n@org_router.get(\n    \"/{org_slug}/members/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageListOrgMemResp,\n)\ndef get_org_members(org_slug: str, current_user: User = Depends(org_dep.member_dep),db:Session = Depends(get_db)):\n    \"\"\"Get All ORg Members\n\n    Args:\n        org_slug (str): slug\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.member_dep): Logged in Member of Org.\n\n    Returns:\n        _type_: Resp\n    \"\"\"\n    resp = org_service(db).get_all_org_member(org_slug)\n\n    return resp\n\n\n@org_router.patch(\n    \"/{org_slug}/member/{member_id}/update/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.MessageOrgMembResp,\n)\ndef update_org_member(\n    org_slug: str,\n    member_id: int,\n    update_org_member: schemas.UpdateOrgMember,\n    current_user: User = Depends(org_dep.admin_rights_dep),db:Session = Depends(get_db)\n):\n    \"\"\"_summary_\n\n    Args:\n        org_slug (str): slug\n        member_id (int): member id\n        update_org_member (schemas.UpdateOrgMember): role data\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.admin_rights_dep).\n\n    Returns:\n        _type_: resp\n    \"\"\"\n    resp = org_service(db).update_org_member(org_slug, member_id, update_org_member)\n\n    return resp\n\n\n@org_router.delete(\n    \"/{org_slug}/member/{member_id}/delete/\",\n    status_code=status.HTTP_204_NO_CONTENT\n)\ndef delete_workspace_member(\n    org_slug: str,\n    member_id: int,\n    current_user: User = Depends(org_dep.admin_rights_dep),db:Session = Depends(get_db)\n):\n    \"\"\"Remove from Organization\n\n    Args:\n        org_slug (str): Slug\n        member_id (int): Member id\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.admin_rights_dep): Logged in User with right permissions.\n\n    Returns:\n        _type_: 204\n    \"\"\"\n    org_service(db).delete_org_member(org_slug, member_id)\n\n    return {\"status\": status.HTTP_204_NO_CONTENT}\n\n\n@org_router.delete(\n    \"/{org_slug}/member/leave/\",\n    status_code=status.HTTP_200_OK,\n    response_model=schemas.ResponseModel,\n)\ndef leave_workspace(org_slug: str, current_user: User = Depends(org_dep.member_dep),db:Session = Depends(get_db)):\n    \"\"\"Leave a Workspace\n\n    Args:\n        org_slug (str): org slug\n        current_user (User, optional): _description_. Defaults to Depends(org_dep.member_dep)= Logged in User with the right permission.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    org_service(db).leave_org(org_slug, current_user)\n\n    return {\"status\": status.HTTP_200_OK, \"message\": \"Logged In User left Orgnizaton.\"}\n"}

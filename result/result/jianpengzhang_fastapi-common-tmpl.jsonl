{"repo_info": {"repo_name": "fastapi-common-tmpl", "repo_owner": "jianpengzhang", "repo_url": "https://github.com/jianpengzhang/fastapi-common-tmpl"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/test_api_endpoints.py", "content": "import pytest\nfrom httpx import AsyncClient\n\nfrom app.main import app\n\n\n@pytest.mark.anyio\nasync def test_user_crud(client: AsyncClient) -> None:\n    # 创建 Group\n    response = await client.post(app.url_path_for('example_create_group'),\n                                 json={\"name\": \"eg_group\", \"description\": \"This is description.\"})\n    assert response.status_code == 200, response.text\n    group_id = response.json()[\"id\"]\n\n    # 创建 User\n    data = {\n        \"username\": \"eg_user\",\n        \"nickname\": \"eg_nick_user\",\n        \"email\": \"eg_user@example.com\",\n        \"is_active\": True,\n        \"is_superuser\": False,\n        \"avatar\": \"/avatar/eg_user.png\",\n        \"password\": \"123456\",\n        \"group_id\": group_id\n    }\n\n    response = await client.post(app.url_path_for('example_create_user'), json=data)\n    assert response.status_code == 200, response.text\n    user = response.json()\n    assert user[\"username\"] == \"eg_user\"\n    user_id = user[\"id\"]\n\n    # 查询 User\n    response = await client.get(app.url_path_for('example_get_user', user_id=user_id))\n    assert response.status_code == 200, response.text\n    user = response.json()\n    assert user[\"username\"] == \"eg_user\"\n\n    # 查询 Users\n    response = await client.get(app.url_path_for('example_get_users'))\n    assert response.status_code == 200, response.text\n    users = response.json()\n    assert len([user for user in users if user.get(\"username\") == \"eg_user\"]) == 1\n\n    # 更新 User\n    response = await client.put(app.url_path_for('example_update_user', user_id=user_id),\n                                json={\"username\": \"eg_update_user\"})\n    assert response.status_code == 200, response.text\n    user = response.json()\n    assert user[\"username\"] == \"eg_update_user\"\n\n    # 删除 User\n    response = await client.delete(app.url_path_for('example_delete_user', user_id=user_id))\n    assert response.status_code == 200, response.text\n    assert \"用户删除成功\" in response.text\n\n\n@pytest.mark.anyio\nasync def test_group_crud(client: AsyncClient) -> None:\n    # 创建 Group\n    data = {\n        \"name\": \"eg_group\",\n        \"description\": \"This is description.\"\n    }\n    response = await client.post(app.url_path_for('example_create_group'), json=data)\n    assert response.status_code == 200, response.text\n    group = response.json()\n    assert group[\"name\"] == \"eg_group\"\n    group_id = group[\"id\"]\n\n    # 查询 Group\n    response = await client.get(app.url_path_for('example_get_group', group_id=group_id))\n    assert response.status_code == 200, response.text\n    group = response.json()\n    assert group[\"name\"] == \"eg_group\"\n\n    # 查询 Groups\n    response = await client.get(app.url_path_for('example_get_groups'))\n    assert response.status_code == 200, response.text\n    groups = response.json()\n    assert len([group for group in groups if group.get(\"name\") == \"eg_group\"]) == 1\n\n    # 更新 Group\n    data = {\"name\": \"eg_update_group\"}\n    response = await client.put(app.url_path_for('example_update_group', group_id=group_id), json=data)\n    assert response.status_code == 200, response.text\n    group = response.json()\n    assert group[\"name\"] == \"eg_update_group\"\n\n    # 删除 Group\n    response = await client.delete(app.url_path_for('example_update_group', group_id=group_id))\n    assert response.status_code == 200, response.text\n    assert \"用户组删除成功\" in response.text\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "from typing import AsyncGenerator\n\nimport pytest\nfrom asgi_lifespan import LifespanManager\nfrom httpx import ASGITransport, AsyncClient\nfrom tortoise.transactions import in_transaction\n\nfrom app.main import app\n\n\n# ========================================\n# 说明: 用于初始化创建和管理测试所需资源\n# ========================================\n\n\n@pytest.fixture(scope=\"session\")\ndef anyio_backend() -> str:\n    \"\"\"\n    pytest 使用 asyncio 作为事件循环\n    :return:\n    \"\"\"\n    return \"asyncio\"\n\n\n@pytest.fixture(scope=\"session\")\nasync def client() -> AsyncGenerator[AsyncClient, None]:\n    \"\"\"\n    使用 httpx.AsyncClient 配合 LifespanManager 和 ASGITransport 创建一个测试客户端，用于发送 HTTP 请求;\n    :return:\n    \"\"\"\n    async with LifespanManager(app):\n        transport = ASGITransport(app=app)\n        async with AsyncClient(transport=transport, base_url=\"http://test\") as c:\n            yield c\n\n\n@pytest.fixture(autouse=True)\nasync def transaction():\n    \"\"\"\n     确保每个测试用例在独立的事务中运行，测试结束后回滚事务，防止脏数据影响其他测试;\n    :return:\n\n    备注：\n    @pytest.fixture(autouse=True) 该 fixture 会在每个测试用例执行前自动调用，无需显式引用；\n    async with in_transaction() as conn：使用 Tortoise ORM 提供的 in_transaction() 上下文管理器创建一个新的数据库事务；\n                                        in_transaction() 会返回一个事务连接 conn，该连接将在上下文管理器的作用范围内保持活动状态；\n    yield conn ：yield 语句将事务连接对象 conn 暴露给测试用例，这允许测试用例在事务范围内执行数据库操作；\n                在 yield 之前的代码会在测试用例执行前运行，yield 之后的代码会在测试用例执行完毕后运行；\n    await conn.rollback()：在测试用例执行完毕后，回滚事务。这将撤销在事务中所做的所有数据库操作，从而确保测试数据不会保留在数据库中；\n    \"\"\"\n    async with in_transaction() as conn:\n        yield conn\n        await conn.rollback()\n"}
{"type": "source_file", "path": "app/config.py", "content": "from os import environ\n\nfrom pydantic.v1 import BaseSettings\n\n\n# ========================================\n# 说明: 项目配置文件\n# ========================================\n\nclass Settings(BaseSettings):\n    # 项目配置\n    PROJECT_NAME: str = \"fastapi-common-tmpl\"\n    PROJECT_DESCRIPTION: str = \"基于 FastAPI 微服务通用基础框架\"\n    VERSION: str = \"v1\"\n    DEBUG: bool = environ.get(\"DEBUG\") == \"true\"\n    TEST: bool = False  # environ.get(\"ENV\") not in [\"PROD\", \"DEV\"]\n\n    # 数据库配置\n    POSTGRES_HOST: str = environ.get(\"POSTGRES_HOST\") or \"127.0.0.1\"  # postgres\n    POSTGRES_PORT: str = environ.get(\"POSTGRES_PORT\") or \"5432\"\n    POSTGRES_USER: str = environ.get(\"POSTGRES_USER\") or \"example\"\n    POSTGRES_PWD: str = environ.get(\"POSTGRES_PWD\") or \"example123\"\n    POSTGRES_DB: str = environ.get(\"POSTGRES_DB\") or \"example\"\n    DB_POOL_MAX: int = environ.get(\"DB_POOL_MAX\") or 20\n    DB_POOL_CONN_LIFE: int = environ.get(\"DB_POOL_CONN_LIFE\") or 600\n    TIMEZONE: str = environ.get(\"TIMEZONE\") or \"Asia/Shanghai\"\n\n    # Redis 配置\n    REDIS_HOST: str = environ.get(\"REDIS_HOST\") or \"127.0.0.1\"  # redis\n    REDIS_PORT: str = environ.get(\"REDIS_PORT\") or \"6379\"\n    REDIS_USER: str = environ.get(\"REDIS_USER\") or \"\"\n    REDIS_PWD: str = environ.get(\"REDIS_PWD\") or \"\"\n    # 0 库用于后端，1 库用于celery broker\n    BASE_REDIS: str = f\"redis://{REDIS_USER}:{REDIS_PWD}@{REDIS_HOST}:{REDIS_PORT}/\"\n\n    BASE_POSTGRES = f'postgres://{POSTGRES_USER}:{POSTGRES_PWD}@{POSTGRES_HOST}:{POSTGRES_PORT}/{POSTGRES_DB}'\n    TORTOISE_ORM = {\n        \"connections\": {\n            \"default\": {\n                \"engine\": \"tortoise.backends.asyncpg\",\n                \"credentials\": {\n                    \"database\": POSTGRES_DB,\n                    \"host\": POSTGRES_HOST,\n                    \"password\": POSTGRES_PWD,\n                    \"port\": POSTGRES_PORT,\n                    \"user\": POSTGRES_USER,\n                    \"maxsize\": DB_POOL_MAX,  # 最大连接数\n                    # \"minsize\": 1, # 最小连接数\n                    # 关闭池中非活动连接的秒数。通过 0 则禁用此机制。\n                    # \"max_inactive_connection_lifetime\": 60 * 5,\n                    \"ssl\": False\n                },\n            }\n        },\n        \"apps\": {\n            \"models\": {\n                \"models\": [\"aerich.models\",\n                           \"app.models\"],\n                \"default_connection\": \"default\",\n            }\n        },\n        \"use_tz\": False,\n        \"timezone\": TIMEZONE\n    }\n\n    class Config:\n        # 启用字段名称大小写敏感性 默认是 False\n        case_sensitive = True\n\n\nsettings = Settings()\nTORTOISE_ORM = settings.TORTOISE_ORM\n"}
{"type": "source_file", "path": "app/api/v1/endpoints/users.py", "content": "from fastapi import APIRouter, status, HTTPException\n\nfrom app.models.examples import ExampleUser\nfrom app.schemas.examples import UserUpdate, UserOut, UserIn\nfrom app.services.examples import UserService\n\n# ========================================\n# 说明: 定义项目HTTP请求相关的路由；\n# ========================================\n\nrouter = APIRouter()\n\n\n# TODO：================= 用户 API 接口 =======================#\n@router.post(\"/\", response_model=UserOut,\n             summary=\"示例：创建用户\",\n             description=\"示例：创建用户 API 接口\",\n             responses={200: {\"描述\": \"用户注册成功\"}, }\n             )\nasync def example_create_user(user: UserIn):\n    # TODO 示例：创建用户，Service 层，封装复杂业务逻辑\n    exam_user_obj = await UserService.create_user(user)\n    return exam_user_obj\n\n\n@router.get(\"/\", response_model=list[UserOut],\n            summary=\"示例：获取用户列表\",\n            description=\"示例：获取用户列表\",\n            status_code=status.HTTP_200_OK)\nasync def example_get_users():\n    # TODO 示例：获取用户列表\n    # 其他方式：return await Users_Pydantic.from_queryset(ExampleUser.all())\n    return [UserOut.from_orm(user) for user in await ExampleUser.all()]\n\n\n@router.get(\"/{user_id}\", response_model=UserOut,\n            summary=\"示例：根据用户 ID 检索用户\",\n            description=\"示例：根据用户 ID 检索 API 接口\",\n            status_code=status.HTTP_200_OK)\nasync def example_get_user(user_id: int):\n    # TODO 示例：获取用户详情\n    return await UserService.get_user(user_id)\n\n\n@router.put(\"/{user_id}\",\n            response_model=UserOut,\n            summary=\"示例：根据用户 ID 检索用户\",\n            description=\"示例：根据用户 ID 检索 API 接口\",\n            status_code=status.HTTP_200_OK)\nasync def example_update_user(user_id: int, user_in: UserUpdate):\n    # TODO 示例：更新用户\n    user = await ExampleUser.get(id=user_id)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"用户不存在，请联系管理员！\")\n    user = user.update_from_dict(user_in.dict(exclude_unset=True))\n    await user.save()\n    return UserOut.from_orm(user)\n\n\n@router.delete(\"/{user_id}\",\n               response_model=dict,\n               summary=\"示例：根据 ID 删除用户\",\n               description=\"示例：根据 ID 删除用户\",\n               status_code=status.HTTP_200_OK)\nasync def example_delete_user(user_id: int):\n    # TODO 示例：删除用户\n    user = await ExampleUser.get(id=user_id)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"用户不存在，请联系管理员！\")\n    await user.delete()\n    return {\"detail\": \"用户删除成功\"}\n"}
{"type": "source_file", "path": "app/api/v1/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/v1/endpoints/groups.py", "content": "from fastapi import APIRouter, status, HTTPException\n\nfrom app.models.examples import ExampleGroup\nfrom app.schemas.examples import GroupIn, GroupOut\nfrom app.services.examples import GroupService\n\n# ========================================\n# 说明: 定义项目HTTP请求相关的路由；\n# ========================================\n\nrouter = APIRouter()\n\n\n@router.post(\"/\", response_model=GroupOut,\n             summary=\"示例：创建用户组\",\n             description=\"示例：创建用户组 API 接口\",\n             responses={status.HTTP_200_OK: {\"描述\": \"用户组创建成功\"}, }\n             )\nasync def example_create_group(group: GroupIn):\n    # TODO 示例：创建用户组\n    exam_group_obj = await GroupService.create_group(group)\n    return exam_group_obj\n\n\n@router.get(\"/\", response_model=list[GroupOut],\n            summary=\"示例：获取用户组列表\",\n            description=\"示例：获取用户组列表\",\n            responses={status.HTTP_200_OK: {\"描述\": \"获取用户组列表\"}, }\n            )\nasync def example_get_groups():\n    # TODO 示例：获取用户组列表\n    return [GroupOut.from_orm(group) for group in await ExampleGroup.all()]\n\n\n@router.get(\"/{group_id}\", response_model=GroupOut,\n            summary=\"示例：获取指定ID用户组\",\n            description=\"示例：获取指定ID用户组\",\n            responses={status.HTTP_200_OK: {\"描述\": \"获取指定ID用户组\"}, }\n            )\nasync def example_get_group(group_id: int):\n    # TODO 示例：获取指定 ID 用户组\n    return await ExampleGroup.filter(id=group_id).first()\n\n\n@router.put(\"/{group_id}\", response_model=GroupOut,\n            summary=\"示例：更新指定ID用户组\",\n            description=\"示例：更新指定ID用户组\",\n            responses={status.HTTP_200_OK: {\"描述\": \"更新指定ID用户组\"}, }\n            )\nasync def example_update_group(group_id: int, group_in: GroupIn):\n    # TODO 示例：更新指定 ID 用户组\n    group = await ExampleGroup.get(id=group_id)\n    if not group:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"用户组不存在，请联系管理员！\")\n    group = group.update_from_dict(group_in.dict(exclude_unset=True))\n    await group.save()\n    return GroupOut.from_orm(group)\n\n\n@router.delete(\"/{group_id}\",\n               response_model=dict,\n               summary=\"示例：根据 ID 删除用户组\",\n               description=\"示例：根据 ID 删除用户组\",\n               status_code=status.HTTP_200_OK)\nasync def example_delete_group(group_id: int):\n    # TODO 示例：删除用户组\n    group = await ExampleGroup.get(id=group_id)\n    if not group:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"用户组不存在，请联系管理员！\")\n    await group.delete()\n    return {\"detail\": \"用户组删除成功\"}\n"}
{"type": "source_file", "path": "app/api/v1/endpoints/websockets.py", "content": "from fastapi import APIRouter, WebSocket\n\nfrom app.core.websockets import ExampleWebsocket, ExampleUserWebsocket, WebsocketConsumer\n\n# ========================================\n# 说明: 定义项目 Websocket 相关的路由；\n# ========================================\n\nrouter = APIRouter()\n\n\n@router.websocket(f\"/{ExampleWebsocket.channel}\")\nasync def websocket_endpoint(websocket: WebSocket):\n    # TODO 示例：通用示例，对应 ExampleWebsocket 单例实现\n    await WebsocketConsumer(ExampleWebsocket).connect(websocket)\n\n\n@router.websocket(\"/{user_id}\")\nasync def websocket_endpoint(websocket: WebSocket, user_id: int):\n    # TODO 示例： 不同用户ID不同消息频道，对应 ExampleUserWebsocket 单例实现\n    channel = ExampleUserWebsocket.channel.format(user_id)\n    await WebsocketConsumer(ExampleUserWebsocket).connect(websocket, channel)\n"}
{"type": "source_file", "path": "app/api/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/v1/api.py", "content": "from fastapi import APIRouter\n\nfrom app.api.v1.endpoints import users, groups, others, websockets\n\n# ========================================\n# 说明: 路由引入\n# ========================================\n\napi_router = APIRouter()\napi_router.include_router(users.router, prefix=\"/users\", tags=[\"Users\"])\napi_router.include_router(groups.router, prefix=\"/groups\", tags=[\"Groups\"])\napi_router.include_router(others.router, prefix=\"/others\", tags=[\"Others\"])\napi_router.include_router(websockets.router, prefix=\"/ws\", tags=[\"ws\"])\n"}
{"type": "source_file", "path": "app/api/v1/endpoints/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/v1/endpoints/others.py", "content": "import datetime\n\nfrom fastapi import APIRouter, status\n\nfrom app.core.logger import LOG\nfrom app.core.redis import get_redis_client\nfrom app.core.utils import run_celery_task\nfrom app.core.websockets import ExampleWebsocket\nfrom app.services.examples import UserService\nfrom app.tasks import tasks\n\n# ========================================\n# 说明: 定义项目HTTP请求相关的路由；\n# ========================================\n\nrouter = APIRouter()\n\n\n# TODO：================= Celery Task =======================#\n@router.get(\"/tasks\",\n            summary=\"示例：异步任务\",\n            description=\"示例：异步任务\",\n            status_code=status.HTTP_200_OK,\n            responses={404: {\"描述\": \"异步任务\"}, }\n            )\nasync def example_exec_tasks():\n    # TODO 示例：异步任务\n    run_celery_task(tasks.eg_task)\n    return {\"Exec tasks\": \"ok\"}\n\n\n# TODO：================= Redis =======================#\n@router.get(\"/redis/cache\",\n            summary=\"示例：Redis 操作（缓存）\",\n            description=\"示例：Redis 操作（缓存）\",\n            status_code=status.HTTP_200_OK,\n            responses={404: {\"描述\": \"Redis 操作（缓存）\"}, }\n            )\nasync def example_exec_redis_with_cache():\n    # TODO 示例：Redis 缓存\n    async with get_redis_client() as rs:\n        await rs.set('example_redis', 'Hello, Redis!')\n        LOG.info(f\"【** Example **】Redis key(example_redis) stored value:{await rs.get('example_redis')}\")\n    return {\"Exec redis (Cache)\": \"ok\"}\n\n\n@router.get(\"/redis/lock/1\",\n            summary=\"示例：Redis lock 操作（简单锁）\",\n            description=\"示例：Redis lock 操作\",\n            status_code=status.HTTP_200_OK,\n            responses={404: {\"描述\": \"Redis lock 操作\"}, }\n            )\nasync def example_exec_redis_with_lock1():\n    # TODO 示例：Redis lock 操作\n    await UserService.update_user1(user_id=10)\n    return {\"Exec redis (lock)\": \"ok\"}\n\n\n@router.get(\"/redis/lock/2\",\n            summary=\"示例：Redis lock 操作（重试获取，直至超时）\",\n            description=\"示例：Redis lock 操作\",\n            status_code=status.HTTP_200_OK,\n            responses={404: {\"描述\": \"Redis lock 操作\"}, }\n            )\nasync def example_exec_redis_with_lock2():\n    # TODO 示例：Redis lock 操作\n    await UserService.update_user2(user_id=20)\n    return {\"Exec redis (lock)\": \"ok\"}\n\n\n# TODO：================= Websocket =======================#\n@router.get(f\"/ws/push\",\n            summary=\"示例：模拟 ws 推送\",\n            description=\"示例：模拟触发后端发送 ws 推送，通过在线 ws 工具监听 ws_example_channel，然后调用接口手动触发\",\n            status_code=status.HTTP_200_OK,\n            responses={404: {\"描述\": \"模拟 ws 推送\"}, }\n            )\nasync def example_exec_ws_push():\n    # TODO 示例：模拟 ws 推送\n    await ExampleWebsocket().broadcast_to_channel(channel=ExampleWebsocket.channel,\n                                                  message=f\"TODO 示例（WS 推送）：当前时间（周期任务）: {datetime.datetime.now().strftime('%Y-%m-%d  %H:%M:%S')}\")\n    return {\"Push ws\": \"ok\"}\n"}
{"type": "source_file", "path": "app/__init__.py", "content": "from app.config import settings\n"}
{"type": "source_file", "path": "app/core/websockets.py", "content": "import asyncio\nimport json\nfrom typing import Dict, List, Any, Type\n\nimport redis.asyncio as aioredis\nfrom fastapi import WebSocket, WebSocketDisconnect\n\nfrom app.core.redis import get_redis_client\nfrom app.core.utils import SingletonMeta\n\n\n# ==========================================\n# 说明: 定义 Websocket 基础类及自定义 Websocket\n# ==========================================\n\n\nclass RedisPubSubManager:\n    \"\"\"\n    管理 Redis 连接和 Pub/Sub 订阅的类;\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self.pubsub = None\n\n    @staticmethod\n    async def _publish(channel: str, message: Any) -> None:\n        \"\"\"\n        消息发布到指定的 Redis 频道（channel）\n        :param channel: 消息频道名称\n        :param message: 消息内容\n        :return:\n        \"\"\"\n        async with get_redis_client() as rs:\n            await rs.publish(channel, message)\n\n    async def connect(self) -> None:\n        \"\"\"\n        初始化 Redis Pub/Sub 客户端\n        :return:\n        \"\"\"\n        async with get_redis_client() as rs:\n            self.pubsub = rs.pubsub()\n\n    async def subscribe(self, channel: str) -> aioredis.Redis:\n        \"\"\"\n        订阅指定的 Redis 频道（channel）\n        :param channel: 消息频道名称\n        :return:\n        \"\"\"\n        await self.pubsub.subscribe(channel)\n        return self.pubsub\n\n    async def unsubscribe(self, channel: str) -> None:\n        \"\"\"\n        取消订阅指定的 Redis 频道（channel）\n        :param channel: 消息频道名称\n        :return:\n        \"\"\"\n        await self.pubsub.unsubscribe(channel)\n\n\nclass WebSocketManager(RedisPubSubManager, metaclass=SingletonMeta):\n    \"\"\"\n    管理 WebSocket Channel 连接；\n    \"\"\"\n\n    channel = \"default_channel\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.channels: Dict[str, List[WebSocket]] = {}\n\n    async def _pubsub_data_reader(self, pubsub_subscriber):\n        \"\"\"\n        不断读取 Redis 频道中的消息并广播到 频道（channel）中的所有 WebSocket 连接;\n        注：get_message():\n            {\n            'type': 'message',\n            'pattern': None,\n            'channel': <Channel Name>,\n            'data': '<Data>'\n            }\n        :param pubsub_subscriber:\n        :return:\n        \"\"\"\n        while True:\n            #  获取来自 Redis 的消息，如果有新消息，解析消息并将其发送到相应channel内的所有 WebSocket 连接\n            message = await pubsub_subscriber.get_message(ignore_subscribe_messages=True)\n            if message is not None:\n                all_sockets = self.channels[message['channel']]\n                for socket in all_sockets:\n                    await socket.send_text(message['data'])\n\n    async def add_to_channel(self, channel: str, websocket: WebSocket) -> None:\n        \"\"\"\n        将 Websocket 连接添加到频道（channel），并启动 Redis Pub/Sub 订阅\n        :param channel: 消息频道名称\n        :param websocket:\n        :return:\n        \"\"\"\n        await websocket.accept()\n        if channel in self.channels:\n            self.channels[channel].append(websocket)\n        else:\n            self.channels[channel] = [websocket]\n            await self.connect()\n            pubsub_subscriber = await self.subscribe(channel)\n            # 创建一个任务，异步执行 _pubsub_data_reader()\n            # _pubsub_data_reader() 可以在后台持续监听 Redis 消息，而不阻塞 WebSocket 连接的处理;\n            asyncio.create_task(self._pubsub_data_reader(pubsub_subscriber))\n\n    async def broadcast_to_channel(self, channel: str, message: Any) -> None:\n        \"\"\"\n        将消息广播到channel中的所有 WebSocket 连接\n        :param channel: 消息频道名称\n        :param message: 消息内容\n        :return:\n        \"\"\"\n        await self._publish(channel, message)\n\n    async def remove_from_channel(self, channel: str, websocket: WebSocket) -> None:\n        \"\"\"\n        将 Websocket 从频道（channel）中移除，并在 频道（channel）为空时取消订阅 Redis 频道\n        :param channel:\n        :param websocket:\n        :return:\n        \"\"\"\n        self.channels[channel].remove(websocket)\n        if len(self.channels[channel]) == 0:\n            del self.channels[channel]\n            await self.unsubscribe(channel)\n\n\nclass WebsocketConsumer:\n\n    def __init__(self, websocket_class: Type[WebSocketManager]):\n        if not callable(websocket_class):\n            raise ValueError(\"Invalid websocket class\")\n        self.websocket_manager = websocket_class()\n\n    async def connect(self, websocket: WebSocket, channel: str = None) -> None:\n        \"\"\"\n        建立对应 Websocket 消息订阅\n        :param websocket:\n        :param channel:\n        :return:\n        \"\"\"\n        channel = channel or self.websocket_manager.channel\n        await self.websocket_manager.add_to_channel(channel, websocket)\n        try:\n            while True:\n                data = await websocket.receive_text()\n                await self.websocket_manager.broadcast_to_channel(channel, data)\n        except WebSocketDisconnect:\n            await self.websocket_manager.remove_from_channel(channel, websocket)\n\n\n# TODO：================= 自定义 Webocket =======================#\n\nclass ExampleWebsocket(WebSocketManager):\n    \"\"\"\n    TODO 示例：自定义 WebSocket 示例\n    \"\"\"\n    channel = \"ws_example_channel\"\n\n\nclass ExampleUserWebsocket(WebSocketManager):\n    \"\"\"\n    TODO 示例：自定义 User WebSocket 示例\n    \"\"\"\n    channel = \"ws_example_user_channel_{}\"\n\n    async def broadcast_to_channel(self, channel: str, message: Any) -> None:\n        \"\"\"\n        自定义消息结构体\n        :param channel:\n        :param message:\n        :return:\n        \"\"\"\n        data = {\n            'type': 'user_event',\n            'data': message\n        }\n        await self._publish(channel, json.dumps(data, ensure_ascii=False))\n"}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import FastAPI, HTTPException, status\n\nfrom app import settings\nfrom app.api.v1.api import api_router\nfrom app.core.celery import do_health_check\nfrom app.core.redis import get_redis_client\nfrom app.core.utils import run_celery_task\nfrom tortoise.contrib.fastapi import register_tortoise\n\n\n# ========================================\n# 说明: 入口\n# 开发阶段启动命令：uvicorn app.main:app --host 0.0.0.0 --port <端口> --reload\n# register_tortoise 是一个便捷函数，用于快速将 Tortoise-ORM 注册到 FastAPI 应用中。它在应用启动时初始化数据库连接，并在应用关闭时关闭连接。\n# RegisterTortoise 是一个类，提供了更灵活和面向对象的方式来管理数据库连接。它允许你更精细地控制数据库初始化和关闭操作。\n\n# @asynccontextmanager\n# async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:\n#     # app startup\n#     async with RegisterTortoise(\n#         app,\n#         db_url=\"sqlite://:memory:\",\n#         modules={\"models\": [\"models\"]},\n#         generate_schemas=True,\n#         add_exception_handlers=True,\n#         use_tz=False,\n#         timezone=\"Asia/Shanghai\",\n#     ):\n#         # db connected\n#         yield\n#         # app teardown\n#     # db connections closed\n\n# app = FastAPI(title=\"Tortoise ORM FastAPI example\", lifespan=lifespan)\n\n# ========================================\n\n\ndef get_application() -> FastAPI:\n    \"\"\"\n    创建和配置一个 FastAPI 应用程序\n    :return:\n    \"\"\"\n\n    \"\"\"\n    创建 FastAPI 实例\n    (1) title: 应用的标题;\n    (2) description: 应用的描述;\n    (3) version: 应用的版本信息;\n    (4) debug: 调试模式，通常在开发环境中开启，在生产环境中关闭;\n    (5) openapi_tags: 自定义的 OpenAPI 标签，用于在 API 文档中组织和描述端点 \n    \"\"\"\n    application = FastAPI(\n        title=settings.PROJECT_NAME,\n        description=settings.PROJECT_DESCRIPTION,\n        version=settings.VERSION,\n        debug=settings.DEBUG,\n        openapi_tags=[\n            {\"name\": \"CRUD | PostgreSQL | Redis | WebSocket\", \"description\": \"示例\"},\n        ],\n    )\n\n    \"\"\"\n    使用 register_tortoise 函数将 Tortoise ORM 注册到 FastAPI 应用中;\n    (1) application: 传递 FastAPI 应用实例;\n    (2) config=settings.TORTOISE_ORM: 从 settings.TORTOISE_ORM 中获取 ORM 的配置（如数据库连接信息等）;\n    (3) generate_schemas=True: 自动生成数据库表结构。通常在开发阶段使用，但在生产环境中最好禁用;\n    (4) add_exception_handlers=True: 添加异常处理器，以便处理数据库相关的错误\n    \"\"\"\n    register_tortoise(application, config=settings.TORTOISE_ORM,\n                      generate_schemas=True, add_exception_handlers=True)\n    \"\"\"\n    添加路由 (include_router): 将一个路由器 api_router 添加到 FastAPI 应用中;\n    (1) api_router: 通常是定义了多个 API 端点的路由器实例;\n    (2) prefix: 路由的前缀，所有包含在 api_router 中的路由都会以此前缀开始;\n    \"\"\"\n    application.include_router(api_router, prefix=f\"/api/{settings.VERSION}/examples\")\n    return application\n\n\n# 这个 app 对象就是整个应用的入口，通常会传递给 ASGI 服务器（如 uvicorn）来运行。\napp = get_application()\n\n\n@app.get(\"/health/\", summary=\"健康检查\",\n         description=\"Redis、Celery 服务检查\",\n         status_code=status.HTTP_200_OK,\n         tags=[\"内置\"])\nasync def health():\n    # 内置：服务健康检查\n    try:\n        async with get_redis_client() as rs:\n            # Ping Redis 服务器，检查连接状态\n            if not await rs.ping():\n                raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Redis health check failed\")\n            run_celery_task(do_health_check)\n    except Exception:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Health check failed\")\n    return {\"status\": \"ok\"}\n"}
{"type": "source_file", "path": "app/core/logger.py", "content": "import logging\n\nfrom app import settings\n\n# ========================================\n# 说明: 日志关联配置\n# ========================================\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.DEBUG if settings.DEBUG else logging.INFO)\nch = logging.StreamHandler()\nformatter = logging.Formatter(\n    \"%(asctime)s - %(process)d - %(module)s - %(funcName)s - line:%(lineno)d - %(levelname)s - %(message)s\"\n)\n\nch.setFormatter(formatter)\nlogger.addHandler(ch)\n\nLOG = logger\n"}
{"type": "source_file", "path": "app/core/__init__.py", "content": ""}
{"type": "source_file", "path": "app/schemas/examples.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, EmailStr, ConfigDict\n\n\n# ========================================\n# 说明: 数据验证和数据解析\n# ========================================\n\n\n# TODO：================= 用户 =======================#\n\nclass BaseUser(BaseModel):\n    # TODO 示例：基础\n    username: Optional[str] = None\n    nickname: Optional[str] = None\n    email: Optional[EmailStr] = None\n    is_active: Optional[bool] = True\n    is_superuser: Optional[bool] = False\n    avatar: Optional[str] = None\n\n\nclass UserIn(BaseUser):\n    # TODO 示例：创建用户\n    username: Optional[str]\n    password: Optional[str]\n    group_id: Optional[int]\n\n\nclass UserUpdate(UserIn):\n    username: Optional[str] = None\n    nickname: Optional[str] = None\n    email: Optional[EmailStr] = None\n    password: Optional[str] = None\n    group_id: Optional[int] = None\n\n\nclass UserOut(BaseUser):\n    # TODO 示例：用户详情\n    id: int\n    created_at: datetime\n    updated_at: datetime\n    last_login: Optional[datetime]\n\n    model_config = ConfigDict(\n        from_attributes=True\n    )\n\n\n# TODO：================= 用户组 =======================#\nclass GroupIn(BaseModel):\n    # TODO 示例：创建用户组\n    name: Optional[str] = None\n    description: Optional[str] = None\n\n\nclass GroupOut(BaseModel):\n    # TODO 示例：用户组详情\n    id: int\n    name: Optional[str]\n    description: Optional[str]\n\n    model_config = ConfigDict(\n        from_attributes=True\n    )\n\n\nclass GroupOutList(BaseModel):\n    # TODO 示例：用户组列表\n    total: int\n    items: list[GroupOut]\n\n    model_config = ConfigDict(\n        from_attributes=True\n    )\n"}
{"type": "source_file", "path": "app/core/celery_config.py", "content": "from celery.schedules import crontab\n\nfrom app import settings\n\n# ========================================\n# 说明: Celery 配置文件\n# ========================================\n\ntask_serializer = 'json'\naccept_content = ['json']\nresult_serializer = 'json'\ntimezone = settings.TIMEZONE\nbroker_url = settings.BASE_REDIS + '1'\ntask_default_queue = 'example'\n\n# 配置任务路由\n# task_routes = {\n#     'app.tasks.tasks*': {'queue': 'example'},\n#     'app.tasks.schedule_tasks*': {'queue': 'scheduler'},\n# }\n\n# 配置任务周期性\nbeat_schedule = {\n    'get_current_time': {\n        'task': 'app.tasks.scheduler_tasks.get_current_time',\n        'schedule': crontab(minute='*/1'),  # Every minute\n    },\n    'push_websocket_data': {\n        'task': 'app.tasks.scheduler_tasks.push_websocket_data',\n        'schedule': 5,\n    },\n}\n"}
{"type": "source_file", "path": "app/services/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/celery.py", "content": "from celery import Celery\n\n# ========================================\n# 说明: Celery App\n# ========================================\n\napp = Celery(\"ExampleCelery\")\napp.config_from_object('app.core.celery_config')\napp.autodiscover_tasks(['app.tasks.tasks', 'app.tasks.scheduler_tasks'])\n\n\n@app.task\ndef do_health_check():\n    \"\"\"\n    # 内置：TODO 健康检查\n    \"\"\"\n    print('健康检查: Celery 健康检查正常！')\n"}
{"type": "source_file", "path": "app/models/base.py", "content": "from tortoise import models, fields\n\n\n# ========================================\n# 说明: 基础数据模型\n# ========================================\n\n\nclass BaseDBModel(models.Model):\n    \"\"\"\n    TODO 示例：基础数据模型\n    \"\"\"\n    id = fields.BigIntField(primary_key=True, db_index=True)\n    created_at = fields.DatetimeField(auto_now_add=True)\n    updated_at = fields.DatetimeField(auto_now=True)\n\n    class Meta:\n        abstract = True\n"}
{"type": "source_file", "path": "app/services/examples.py", "content": "import asyncio\n\nfrom app.core.logger import LOG\nfrom app.core.redis import acquire_lock, acquire_lock_with_retry, release_lock\nfrom app.models.examples import ExampleUser, ExampleGroup\nfrom app.schemas.examples import UserIn, GroupIn\n\n\n# ========================================\n# 说明: Service 层，封装复杂业务逻辑\n# ========================================\n\n# TODO：================= 用户 & 用户组 =======================#\nclass UserService:\n    # TODO 示例：用户 Service\n\n    @staticmethod\n    async def create_user(user: UserIn):\n        user_obj = await ExampleUser.create(**user.dict())\n        return user_obj\n\n    @staticmethod\n    async def get_user(user_id: int):\n        return await ExampleUser.filter(id=user_id).first()\n\n    @staticmethod\n    async def get_users():\n        return await ExampleUser.all()\n\n    @staticmethod\n    async def update_user1(user_id: int):\n        lock_key = f\"example:user:{user_id}\"\n        if await acquire_lock(lock_key, 35):\n            try:\n                LOG.info(\"Succeeded to get redis lock\")\n                # 模拟长时间运行的任务\n                await asyncio.sleep(30)\n            finally:\n                await release_lock(lock_key)\n        else:\n            LOG.info(\"Failed to get redis lock\")\n\n    @staticmethod\n    async def update_user2(user_id: int):\n        lock_key = f\"example:user:{user_id}\"\n        if await acquire_lock_with_retry(lock_key, 35):\n            try:\n                LOG.info(\"Succeeded to get redis lock\")\n                # 模拟长时间运行的任务\n                await asyncio.sleep(15)\n            finally:\n                await release_lock(lock_key)\n        else:\n            LOG.info(\"Failed to get redis lock\")\n\n\nclass GroupService:\n    # TODO 示例：用户组 Service\n\n    @staticmethod\n    async def create_group(group: GroupIn):\n        group_obj = await ExampleGroup.create(**group.dict())\n        return group_obj\n"}
{"type": "source_file", "path": "app/core/utils.py", "content": "import asyncio\nimport threading\n\nfrom app import settings\n\n\n# ========================================\n# 说明: 通用工具库\n# ========================================\n\ndef run_celery_task(task, *args, **kwargs):\n    # kwargs里的eta和expires参数用于celery，其他参数用于task\n    eta = kwargs.pop(\"eta\", None)\n    expires = kwargs.pop(\"expires\", None)\n    if settings.TEST:\n        return task(*args, **kwargs)\n    return task.apply_async(args, kwargs, eta=eta, expires=expires)\n\n\nclass SingletonMeta(type):\n    \"\"\"\n    单例元类\n    \"\"\"\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\"\n        方法重载，确保每次创建类的实例时，返回同一个实例;\n        _instances，字典用于存储已经创建的实例\n        :param args:\n        :param kwargs:\n        :return:\n        \"\"\"\n        if cls not in cls._instances:\n            cls._instances[cls] = super(SingletonMeta, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n\nclass AsyncLoopCreator:\n    \"\"\"\n    创建单独的线程并运行一个独立的事件循环；\n\n    创建事件循环：确保在程序中只有一个事件循环实例。\n    线程安全：通过线程锁防止 race condition，确保事件循环的创建和访问是线程安全的。\n    独立运行：事件循环在单独的守护线程中运行，确保主线程的退出不会影响事件循环的运行。\n    多线程环境中，尤其是在使用 Celery 等非异步框架的环境中，异步代码可以正常运行而不会遇到事件循环关闭的错误 (RuntimeError: Event loop is closed)。\n    \"\"\"\n    loop = None\n\n    @classmethod\n    def get_loop(cls):\n        if cls.loop is None:\n            with threading.Lock():\n                if not cls.loop:\n                    # 创建事件循环\n                    cls.loop = asyncio.new_event_loop()\n                    # 创建线程运行事件循环:target 指定线程运行函数，args 指定传递标函数参数\n                    thread = threading.Thread(target=cls.run_event_loop, args=(cls.loop,))\n                    # 守护线程:主线程退出，该线程自动退出\n                    thread.daemon = True\n                    # 启动线程，运行 run_event_loop 方法\n                    thread.start()\n                return cls.loop\n        return cls.loop\n\n    @staticmethod\n    def run_event_loop(loop):\n        # 设置当前线程的事件循环为传递进来的 loop\n        asyncio.set_event_loop(loop)\n        try:\n            # 运行事件循环，直到调用 loop.stop() 停止它\n            loop.run_forever()\n        finally:\n            # 确保事件循环能被正确关闭。\n            loop.close()\n"}
{"type": "source_file", "path": "app/schemas/__init__.py", "content": ""}
{"type": "source_file", "path": "app/models/__init__.py", "content": "from app.models.examples import *\n"}
{"type": "source_file", "path": "app/core/redis.py", "content": "import asyncio\nimport contextlib\nimport time\n\nimport redis.asyncio as aioredis\n\nfrom app import settings\nfrom app.core.logger import LOG\n\n\n# ========================================\n# 说明: Redis 通用工具方法\n#    * Redis Client 接口\n#    * Redis 锁\n# ========================================\n\n\n@contextlib.asynccontextmanager\nasync def get_redis_client() -> aioredis.Redis:\n    \"\"\"\n    基于异步上下文管理器获取和关闭 Redis 客户端\n    :return:\n    \"\"\"\n    rs = None\n    try:\n        # 异步 Redis 连接池，并设置 decode_responses=True：自动解码 Redis 响应为字符串（默认为字节）\n        # max_connections=5000：连接池允许的最大连接数\n        pool = aioredis.ConnectionPool.from_url(settings.BASE_REDIS,\n                                                max_connections=5000,\n                                                decode_responses=True)\n        rs = aioredis.Redis(connection_pool=pool)\n        yield rs\n    except aioredis.RedisError as e:\n        LOG.error(f\"Failed to connect to Redis: {e}\")\n    finally:\n        if rs:\n            await rs.close()\n\n\nasync def acquire_lock(lock_key: str, timeout: int = 10) -> bool:\n    \"\"\"\n    尝试获取锁:成功获取到锁，则返回 True，否则返回 False\n    :param redis: Redis client\n    :param lock_key: 锁对应健\n    :param timeout: 设置键的过期时间（对应 ex） 单位 秒，\n    :return: 锁获取成功 True\n\n    Redis set 参数：\n        （1）EX second ：设置键的过期时间（秒）；\n        （2）PX millisecond ：设置键的过期时间（毫秒）；\n        （3）NX ：只在键不存在时，才对键进行设置操作；\n        （4）XX ：只在键已经存在时，才对键进行设置操作；\n    \"\"\"\n    async with get_redis_client() as rs:\n        result = await rs.set(lock_key, \"locked\", ex=timeout, nx=True)\n        return result is not None\n\n\nasync def acquire_lock_with_retry(lock_key: str, timeout: int = 10,\n                                  retry_interval: float = 0.1) -> bool:\n    \"\"\"\n    指定超时时间内获取锁，如果成功获取到锁，则返回 True，否则，在超时时间内不断重试，直到超时时间结束。\n    :param redis: Redis client\n    :param lock_key: 锁对应健\n    :param timeout: 设置键的过期时间（秒）以及 获取锁超时时间\n    :param retry_interval: 重试间隔\n    :return:\n    \"\"\"\n    start_time = time.time()\n    async with get_redis_client() as rs:\n        while True:\n            result = await rs.set(lock_key, \"locked\", ex=timeout, nx=True)\n            if result:\n                return True\n            if time.time() - start_time >= timeout:\n                return False\n            LOG.info(f\"Retry acquiring a redis lock... ...\")\n            await asyncio.sleep(retry_interval)\n\n\n# async def release_lock(lock_key: str) -> None:\n#     \"\"\"\n#     释放锁\n#     :param redis:\n#     :param lock_key:\n#     :return:\n#     \"\"\"\n#     with get_redis_client() as rs:\n#         await rs.delete(lock_key)\n\n\nasync def release_lock(lock_key: str, lock_value: str = \"locked\") -> None:\n    \"\"\"\n    释放锁：使用 Lua 脚本确保原子性删除锁，确保只有持有锁的客户端才能释放锁，这种方式可以防止误删除其他客户端持有的锁。\n    :param redis:\n    :param lock_key:\n    :param lock_value:\n    :return:\n    \"\"\"\n    lua_script = \"\"\"\n    if redis.call(\"get\", KEYS[1]) == ARGV[1] then\n        return redis.call(\"del\", KEYS[1])\n    else\n        return 0\n    end\n    \"\"\"\n    try:\n        async with get_redis_client() as rs:\n            sha = await rs.script_load(lua_script)\n            await rs.evalsha(sha, 1, lock_key, lock_value)\n    except aioredis.RedisError as e:\n        LOG.error(f\"Failed to release lock: {e}\")\n"}
{"type": "source_file", "path": "app/tasks/scheduler_tasks.py", "content": "import asyncio\nimport datetime\n\nfrom celery import shared_task\n\nfrom app.core.utils import AsyncLoopCreator\nfrom app.core.websockets import ExampleWebsocket\n\n\n# ========================================\n# 说明: Celery 周期性任务\n# ========================================\n\n\n@shared_task()\ndef get_current_time():\n    \"\"\"\n    # TODO 示例：定时获取当前时间\n    \"\"\"\n    print(f\"TODO 示例：当前时间（周期任务）: {datetime.datetime.now().strftime('%Y-%m-%d  %H:%M:%S')}\")\n\n\n@shared_task()\ndef push_websocket_data():\n    \"\"\"\n    # TODO 示例：定时推送 Websocket 消息\n    \"\"\"\n    asyncio.run_coroutine_threadsafe(\n        ExampleWebsocket().broadcast_to_channel(ExampleWebsocket.channel,\n                                                f\"TODO 示例：当前时间（周期任务）: {datetime.datetime.now().strftime('%Y-%m-%d  %H:%M:%S')}\"),\n        AsyncLoopCreator.get_loop())"}
{"type": "source_file", "path": "app/tasks/__init__.py", "content": ""}
{"type": "source_file", "path": "app/tasks/tasks.py", "content": "from celery import shared_task\n\n\n# ========================================\n# 说明: Celery 异步任务\n# ========================================\n\n@shared_task()\ndef eg_task():\n    \"\"\"\n    # TODO 示例：异步任务\n    \"\"\"\n    print('TODO 示例：异步任务')\n"}
{"type": "source_file", "path": "init_data.py", "content": "import subprocess\nimport sys\nimport time\n\nfrom app.config import TORTOISE_ORM\nfrom app.models.examples import ExampleGroup, ExampleUser\nfrom tortoise import Tortoise, run_async\n\n# 内置 Group\nBUILT_IN_GROUP = {\n    \"name\": \"系统管理\",\n    \"description\": \"系统运维管理\",\n}\n\n# 内置 User\nBUILT_IN_USER = {\n    \"username\": \"Admin\",\n    \"password\": \"Admin@123\",\n}\n\n\nasync def run_aerich_upgrade(retries: int = 3, delay: int = 5):\n    \"\"\"\n    运行 `aerich upgrade` 进行数据库迁移, 默认尝试 3 次，间隔 5s\n    :param retries: 最大重试次数\n    :param delay: 每次重试之间的等待时间（秒）\n    :return:\n    \"\"\"\n    for attempt in range(1, retries + 1):\n        try:\n            subprocess.run([\"aerich\", \"upgrade\"], check=True)\n            print(\"数据库迁移完成: aerich upgrade\")\n            break  # 如果成功，退出循环\n        except subprocess.CalledProcessError as e:\n            print(f\"数据库迁移失败: {e}\")\n            if attempt < retries:\n                print(f\"将在 {delay} 秒后重试... (尝试 {attempt}/{retries})\")\n                time.sleep(delay)  # 等待一段时间后重试\n            else:\n                print(\"已达到最大重试次数，退出程序。\")\n                sys.exit(1)\n\n\nasync def init_group():\n    \"\"\"\n    初始化：内置用户组\n    :return:\n    \"\"\"\n    try:\n        if await ExampleGroup.filter(name=BUILT_IN_GROUP[\"name\"]).exists():\n            print(f\"内置用户组已经存在: {BUILT_IN_GROUP['name']}\")\n        else:\n            group = await ExampleGroup.create(**BUILT_IN_GROUP)\n            print(f\"内置用户组初始化成功: {group.name}\")\n    except Exception as e:\n        raise e\n\n\nasync def init_user():\n    \"\"\"\n    初始化：内置用户\n    :return:\n    \"\"\"\n    try:\n        if await ExampleUser.filter(username=BUILT_IN_USER[\"username\"]).exists():\n            print(f\"内置系统管理员已经存在: {BUILT_IN_USER['username']}\")\n        else:\n            BUILT_IN_USER[\"group\"] = await ExampleGroup.get(name=BUILT_IN_GROUP[\"name\"])\n            user = await ExampleUser.create(**BUILT_IN_USER)\n            print(f\"内置管理员初始化成功: {user.username}\")\n    except Exception as e:\n        raise e\n\n\nasync def init_data():\n    print(\"开始数据库初始化... ...\")\n    # 运行数据库迁移\n    await run_aerich_upgrade()\n    # 初始化数据库连接，使用从FastAPI应用配置中获取的信息\n    try:\n        await Tortoise.init(config=TORTOISE_ORM)\n        await Tortoise.generate_schemas()\n        # 执行数据初始化操作\n        await init_group()\n        await init_user()\n    except Exception as e:\n        print(f\"数据库初始化失败: {e}\")\n        sys.exit(1)\n    finally:\n        await Tortoise.close_connections()\n    print(\"数据库初始化完成\")\n    sys.exit(0)\n\n\ndef main():\n    run_async(init_data())\n\n\nif __name__ == '__main__':\n    main()\n"}
{"type": "source_file", "path": "app/models/examples.py", "content": "from app.models.base import BaseDBModel\nfrom tortoise import fields\nfrom tortoise.contrib.pydantic import pydantic_model_creator\n\n\n# ========================================\n# 说明: 数据模型\n# ========================================\n\n\n# TODO：================= 用户 & 用户组 =======================#\n\nclass ExampleUser(BaseDBModel):\n    \"\"\"\n    TODO 示例：用户\n    \"\"\"\n    username = fields.CharField(max_length=20, unique=True, description=\"用户名\")\n    nickname = fields.CharField(max_length=50, null=True, description=\"昵称\")\n    email = fields.CharField(max_length=255, null=True, description=\"联系邮箱\")\n    password = fields.CharField(max_length=128, description=\"密码\")\n    last_login = fields.DatetimeField(null=True, description=\"上次登录\")\n    is_active = fields.BooleanField(default=True, description=\"是否活跃\")\n    is_superuser = fields.BooleanField(default=False, description=\"是否管理员\")\n    is_confirmed = fields.BooleanField(default=False, description=\"是否确认\")\n    avatar = fields.CharField(max_length=512, null=True, description=\"头像\")\n    group = fields.ForeignKeyField('models.ExampleGroup', related_name='example_user')\n\n    class Meta:\n        table = \"example_user\"\n        table_description = \"用例：用户\"\n\n\nclass ExampleGroup(BaseDBModel):\n    \"\"\"\n    TODO 示例：用户组\n    \"\"\"\n    name = fields.CharField(max_length=50, unique=True)\n    description = fields.TextField(null=True)\n\n    class Meta:\n        table = \"example_group\"\n        table_description = \"用例：用户组\"\n\n\nUsers_Pydantic = pydantic_model_creator(ExampleUser, name=\"UserOutList\")\n"}
{"type": "source_file", "path": "migrations/models/0_20240812141051_init.py", "content": "from tortoise import BaseDBAsyncClient\n\n\nasync def upgrade(db: BaseDBAsyncClient) -> str:\n    return \"\"\"\n        CREATE TABLE IF NOT EXISTS \"aerich\" (\n    \"id\" SERIAL NOT NULL PRIMARY KEY,\n    \"version\" VARCHAR(255) NOT NULL,\n    \"app\" VARCHAR(100) NOT NULL,\n    \"content\" JSONB NOT NULL\n);\nCREATE TABLE IF NOT EXISTS \"example_group\" (\n    \"id\" BIGSERIAL NOT NULL PRIMARY KEY,\n    \"created_at\" TIMESTAMPTZ NOT NULL  DEFAULT CURRENT_TIMESTAMP,\n    \"updated_at\" TIMESTAMPTZ NOT NULL  DEFAULT CURRENT_TIMESTAMP,\n    \"name\" VARCHAR(50) NOT NULL UNIQUE,\n    \"description\" TEXT\n);\nCOMMENT ON TABLE \"example_group\" IS '用例：用户组';\nCREATE TABLE IF NOT EXISTS \"example_user\" (\n    \"id\" BIGSERIAL NOT NULL PRIMARY KEY,\n    \"created_at\" TIMESTAMPTZ NOT NULL  DEFAULT CURRENT_TIMESTAMP,\n    \"updated_at\" TIMESTAMPTZ NOT NULL  DEFAULT CURRENT_TIMESTAMP,\n    \"username\" VARCHAR(20) NOT NULL UNIQUE,\n    \"nickname\" VARCHAR(50),\n    \"email\" VARCHAR(255),\n    \"password\" VARCHAR(128) NOT NULL,\n    \"last_login\" TIMESTAMPTZ,\n    \"is_active\" BOOL NOT NULL  DEFAULT True,\n    \"is_superuser\" BOOL NOT NULL  DEFAULT False,\n    \"is_confirmed\" BOOL NOT NULL  DEFAULT False,\n    \"avatar\" VARCHAR(512),\n    \"group_id\" BIGINT NOT NULL REFERENCES \"example_group\" (\"id\") ON DELETE CASCADE\n);\nCOMMENT ON COLUMN \"example_user\".\"username\" IS '用户名';\nCOMMENT ON COLUMN \"example_user\".\"nickname\" IS '昵称';\nCOMMENT ON COLUMN \"example_user\".\"email\" IS '联系邮箱';\nCOMMENT ON COLUMN \"example_user\".\"password\" IS '密码';\nCOMMENT ON COLUMN \"example_user\".\"last_login\" IS '上次登录';\nCOMMENT ON COLUMN \"example_user\".\"is_active\" IS '是否活跃';\nCOMMENT ON COLUMN \"example_user\".\"is_superuser\" IS '是否管理员';\nCOMMENT ON COLUMN \"example_user\".\"is_confirmed\" IS '是否确认';\nCOMMENT ON COLUMN \"example_user\".\"avatar\" IS '头像';\nCOMMENT ON TABLE \"example_user\" IS '用例：用户';\"\"\"\n\n\nasync def downgrade(db: BaseDBAsyncClient) -> str:\n    return \"\"\"\n        \"\"\"\n"}

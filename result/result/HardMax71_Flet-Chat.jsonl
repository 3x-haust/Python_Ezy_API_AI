{"repo_info": {"repo_name": "Flet-Chat", "repo_owner": "HardMax71", "repo_url": "https://github.com/HardMax71/Flet-Chat"}}
{"type": "test_file", "path": "chat_service/app/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "chat_service/app/tests/unit/test_security.py", "content": "# app/tests/unit/test_security.py\nimport pytest\nfrom app.config import AppConfig\nfrom app.infrastructure.security import SecurityService\n\n\n@pytest.fixture\ndef security_service():\n    config = AppConfig(SECRET_KEY=\"test_secret\", ALGORITHM=\"HS256\", REFRESH_SECRET_KEY=\"test_refresh_secret\")\n    return SecurityService(config)\n\n\ndef test_password_hashing(security_service):\n    password = \"testpassword\"\n    hashed = security_service.get_password_hash(password)\n    assert security_service.verify_password(password, hashed)\n    assert not security_service.verify_password(\"wrongpassword\", hashed)\n\n\ndef test_token_creation(security_service):\n    data = {\"sub\": \"testuser\"}\n    access_token, _ = security_service.create_access_token(data)\n    refresh_token, _ = security_service.create_refresh_token(data)\n    assert access_token\n    assert refresh_token\n\n\ndef test_token_decoding(security_service):\n    data = {\"sub\": \"testuser\"}\n    access_token, _ = security_service.create_access_token(data)\n    refresh_token, _ = security_service.create_refresh_token(data)\n\n    decoded_access = security_service.decode_access_token(access_token)\n    decoded_refresh = security_service.decode_refresh_token(refresh_token)\n\n    assert decoded_access == \"testuser\"\n    assert decoded_refresh == \"testuser\"\n"}
{"type": "test_file", "path": "chat_service/app/tests/integration/test_users.py", "content": "import pytest\nfrom httpx import AsyncClient\n\npytestmark = pytest.mark.asyncio\n\n\nasync def test_read_users(client: AsyncClient, auth_header):\n    response = await client.get(\"/api/v1/users/\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert isinstance(data, list)\n    for user in data:\n        assert \"id\" in user\n        assert \"username\" in user\n        assert \"email\" in user\n        assert \"created_at\" in user\n        assert \"is_active\" in user\n\n\nasync def test_read_users_me(client: AsyncClient, auth_header, test_user):\n    response = await client.get(\"/api/v1/users/me\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"id\"] == test_user.id\n    assert data[\"username\"] == test_user.username\n    assert data[\"email\"] == test_user.email\n\n\nasync def test_update_user(client: AsyncClient, auth_header):\n    update_data = {\n        \"email\": \"newemail@example.com\",\n        \"username\": \"newusername\",\n        \"password\": \"newpassword123\"\n    }\n    response = await client.put(\"/api/v1/users/me\", headers=auth_header, json=update_data)\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"email\"] == update_data[\"email\"]\n    assert data[\"username\"] == update_data[\"username\"]\n\n    # Try logging in with new credentials\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": update_data[\"username\"], \"password\": update_data[\"password\"]}\n    )\n    assert login_response.status_code == 200\n\n\nasync def test_delete_user(client: AsyncClient, auth_header):\n    response = await client.delete(\"/api/v1/users/me\", headers=auth_header)\n    assert response.status_code == 204\n\n    # Try to access the deleted user's profile\n    me_response = await client.get(\"/api/v1/users/me\", headers=auth_header)\n    assert me_response.status_code == 401\n\n\nasync def test_search_users(client: AsyncClient, auth_header, test_user2):\n    response = await client.get(f\"/api/v1/users/search?query={test_user2.username[:4]}\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data) > 0\n    assert any(user[\"username\"] == test_user2.username for user in data)\n\n\nasync def test_user_filter_by_username(client: AsyncClient, auth_header, test_user):\n    response = await client.get(f\"/api/v1/users/?username={test_user.username[:4]}\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data) > 0\n    assert any(user[\"username\"] == test_user.username for user in data)\n\n\nasync def test_user_pagination(client: AsyncClient, auth_header):\n    # Create 20 users\n    for i in range(20):\n        await client.post(\n            \"/api/v1/auth/register\",\n            json={\"username\": f\"testuser{i}\", \"email\": f\"testuser{i}@example.com\", \"password\": \"testpassword123\"}\n        )\n\n    # Get first page\n    response1 = await client.get(\"/api/v1/users/?skip=0&limit=10\", headers=auth_header)\n    assert response1.status_code == 200\n    data1 = response1.json()\n    assert len(data1) == 10\n\n    # Get second page\n    response2 = await client.get(\"/api/v1/users/?skip=10&limit=10\", headers=auth_header)\n    assert response2.status_code == 200\n    data2 = response2.json()\n    assert len(data2) == 10\n\n    # Ensure no duplicate users\n    ids1 = {user[\"id\"] for user in data1}\n    ids2 = {user[\"id\"] for user in data2}\n    assert len(ids1.intersection(ids2)) == 0\n\n\nasync def test_update_user_partial(client: AsyncClient, auth_header):\n    # Update only email\n    response = await client.put(\"/api/v1/users/me\", headers=auth_header, json={\"email\": \"partial@example.com\"})\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"email\"] == \"partial@example.com\"\n\n    # Update only username\n    response = await client.put(\"/api/v1/users/me\", headers=auth_header, json={\"username\": \"partialupdate\"})\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"username\"] == \"partialupdate\"\n\n\nasync def test_update_user_invalid_data(client: AsyncClient, auth_header):\n    # Try to update with invalid email\n    response = await client.put(\"/api/v1/users/me\", headers=auth_header, json={\"email\": \"invalid-email\"})\n    assert response.status_code == 422\n\n    # Try to update with short password\n    response = await client.put(\"/api/v1/users/me\", headers=auth_header, json={\"password\": \"short\"})\n    assert response.status_code == 422\n\n\nasync def test_user_soft_delete(client: AsyncClient, auth_header):\n    # Soft delete the user\n    response = await client.put(\"/api/v1/users/me\", headers=auth_header, json={\"is_active\": False})\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"is_active\"] == False\n\n    # Try to login with the deactivated user\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": data[\"username\"], \"password\": \"testpassword\"}\n    )\n    assert login_response.status_code == 401\n"}
{"type": "test_file", "path": "chat_service/app/tests/unit/__init__.py", "content": ""}
{"type": "test_file", "path": "chat_service/app/tests/unit/test_event_dispatcher.py", "content": "# app/tests/unit/test_event_dispatcher.py\nfrom datetime import datetime, timezone\n\nimport pytest\nfrom app.domain.events import MessageCreated, UserInfo\nfrom app.infrastructure.event_dispatcher import EventDispatcher\n\n\n@pytest.mark.asyncio\nasync def test_event_dispatcher():\n    dispatcher = EventDispatcher()\n\n    events_received = []\n\n    async def test_handler(event):\n        events_received.append(event)\n\n    dispatcher.register(\"MessageCreated\", test_handler)\n\n    event = MessageCreated(\n        message_id=1,\n        chat_id=1,\n        user_id=1,\n        content=\"Test\",\n        created_at=datetime.now(timezone.utc),\n        user=UserInfo(id=1, username=\"testuser\"),\n        is_deleted=False\n    )\n    await dispatcher.dispatch(event)\n\n    assert len(events_received) == 1\n    assert isinstance(events_received[0], MessageCreated)\n"}
{"type": "test_file", "path": "chat_service/app/tests/conftest.py", "content": "# app/tests/conftest.py\n\nimport random\nimport string\n\nimport pytest\nfrom app.api import dependencies\nfrom app.config import AppConfig\nfrom app.gateways.chat_gateway import ChatGateway\nfrom app.gateways.token_gateway import TokenGateway\nfrom app.gateways.user_gateway import UserGateway\nfrom app.infrastructure import schemas\nfrom app.infrastructure.database import create_database\nfrom app.infrastructure.security import SecurityService\nfrom app.infrastructure.uow import UnitOfWork\nfrom app.main import Application\nfrom fakeredis import aioredis\nfrom httpx import AsyncClient, ASGITransport\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\n\n@pytest.fixture(scope=\"function\")\ndef app_config(tmp_path):\n    \"\"\"\n    Provide a test configuration with a shared in-memory SQLite database.\n    \"\"\"\n    return AppConfig(\n        DATABASE_URL=\"sqlite+aiosqlite:///:memory:?cache=shared\",  # Enable shared cache\n        REDIS_HOST=\"localhost\",\n        REDIS_PORT=6379,\n        SECRET_KEY=\"test_secret_key\",\n        REFRESH_SECRET_KEY=\"test_refresh_secret_key\",\n        PROJECT_NAME=\"Test Chat API\",\n        PROJECT_VERSION=\"1.0.0\",\n        PROJECT_DESCRIPTION=\"Test Chat API\",\n        API_V1_STR=\"/api/v1\",\n        ALGORITHM=\"HS256\",\n        ACCESS_TOKEN_EXPIRE_MINUTES=30,\n        REFRESH_TOKEN_EXPIRE_DAYS=7,\n    )\n\n\n@pytest.fixture(scope=\"function\")\nasync def mock_redis():\n    \"\"\"Provide a fake Redis client for testing.\"\"\"\n    redis = aioredis.FakeRedis()\n    yield redis\n    await redis.flushall()\n    await redis.aclose()\n\n\n@pytest.fixture(scope=\"function\")\nasync def engine(app_config):\n    \"\"\"Create a SQLAlchemy engine for testing with shared in-memory SQLite.\"\"\"\n    engine = create_async_engine(\n        app_config.DATABASE_URL,\n        connect_args={\"check_same_thread\": False},\n        poolclass=StaticPool,  # Reuse the same connection\n        echo=False\n    )\n    async with engine.begin() as conn:\n        from app.infrastructure import models  # noqa: F401\n        await conn.run_sync(models.Base.metadata.create_all)\n    yield engine\n    await engine.dispose()\n\n\n@pytest.fixture(scope=\"function\")\nasync def db_session(engine):\n    \"\"\"Provide a SQLAlchemy session for testing.\"\"\"\n    async_session_factory = sessionmaker(\n        bind=engine, class_=AsyncSession, expire_on_commit=False\n    )\n    session = async_session_factory()\n    yield session\n    await session.close()\n\n\n@pytest.fixture(autouse=True)\ndef increase_token_expiration(app_config):\n    original_expire_minutes = app_config.ACCESS_TOKEN_EXPIRE_MINUTES\n    app_config.ACCESS_TOKEN_EXPIRE_MINUTES = 5  # Set to 5 minutes for testing\n    yield\n    app_config.ACCESS_TOKEN_EXPIRE_MINUTES = original_expire_minutes\n\n\n@pytest.fixture(scope=\"function\")\nasync def uow():\n    \"\"\"Provide a UnitOfWork instance for testing.\"\"\"\n    return UnitOfWork()\n\n\n@pytest.fixture(scope=\"function\")\ndef override_get_db(db_session):\n    \"\"\"Override the get_session dependency to use the test session.\"\"\"\n\n    async def _override_get_db():\n        yield db_session\n\n    return _override_get_db\n\n\n@pytest.fixture(scope=\"function\")\nasync def app(app_config, mock_redis, engine):\n    \"\"\"Create the FastAPI app with the test database.\"\"\"\n    database = create_database(engine)\n    application = Application(config=app_config)\n    application.database = database\n    application.redis_client.client = mock_redis\n\n    app_instance = application.create_app()\n\n    return app_instance\n\n\n@pytest.fixture(scope=\"function\")\nasync def app_with_db(app, override_get_db):\n    \"\"\"Override dependencies to use the test database session.\"\"\"\n    app.dependency_overrides[dependencies.get_session] = override_get_db\n    yield app\n    app.dependency_overrides.clear()\n\n\n@pytest.fixture(scope=\"function\")\nasync def client(app_with_db):\n    \"\"\"Provide an HTTP client with the test app.\"\"\"\n    async with AsyncClient(transport=ASGITransport(app=app_with_db), base_url=\"http://test\") as ac:\n        yield ac\n\n\n@pytest.fixture(scope=\"function\")\nasync def test_user(db_session, app_config, uow):\n    \"\"\"Create a test user in the database.\"\"\"\n    random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))\n    security_service = SecurityService(app_config)\n    user_create = schemas.UserCreate(\n        username=f\"testuser_{random_string}\",\n        email=f\"testuser_{random_string}@example.com\",\n        password=\"testpassword\"\n    )\n    user_gateway = UserGateway(db_session, uow)\n    user = await user_gateway.create_user(user_create, security_service)\n    await uow.commit()\n    return user\n\n\n@pytest.fixture(scope=\"function\")\nasync def test_chat(db_session, test_user, uow):\n    \"\"\"Create a test chat in the database.\"\"\"\n    chat_create = schemas.ChatCreate(\n        name=f\"TestChat_{random.randint(1, 1000)}\",\n        member_ids=[test_user.id]\n    )\n    chat_gateway = ChatGateway(db_session, uow)\n    chat = await chat_gateway.create_chat(chat_create, test_user.id)\n    await uow.commit()\n    return chat\n\n\n@pytest.fixture(scope=\"function\")\nasync def test_user2(db_session, app_config, uow):\n    \"\"\"Create a second test user in the database.\"\"\"\n    security_service = SecurityService(app_config)\n    user_create = schemas.UserCreate(\n        username=f\"testuser2_{random.randint(1, 1000)}\",\n        email=f\"testuser2_{random.randint(1, 1000)}@example.com\",\n        password=\"testpassword2\"\n    )\n    user_gateway = UserGateway(db_session, uow)\n    user = await user_gateway.create_user(user_create, security_service)\n    await uow.commit()\n    return user\n\n\n@pytest.fixture(scope=\"function\")\nasync def auth_header(client, test_user, db_session, uow):\n    \"\"\"Provide an authorization header for authenticated requests.\"\"\"\n    response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}  # Use form data\n    )\n    assert response.status_code == 200, f\"Login failed: {response.json()}\"\n    access_token = response.json().get(\"access_token\")\n    assert access_token is not None, \"Access token was not returned in the response\"\n\n    # Verify token is stored in the database\n    token_gateway = TokenGateway(db_session, uow)\n    token = await token_gateway.get_by_access_token(access_token)\n    assert token is not None, \"Access token was not stored in the database\"\n\n    return {\"Authorization\": f\"Bearer {access_token}\"}\n"}
{"type": "test_file", "path": "chat_service/app/tests/unit/test_database.py", "content": "# app/tests/unit/test_database.py\nimport pytest\nfrom app.infrastructure.database import Database, Base\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\n\n@pytest.fixture\nasync def in_memory_db():\n    engine = create_async_engine(\"sqlite+aiosqlite:///:memory:\")\n    db = Database(engine=engine)\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield db\n    await engine.dispose()\n\n\n@pytest.mark.asyncio\nasync def test_database_connect(in_memory_db):\n    await in_memory_db.connect()\n    assert in_memory_db.engine is not None\n\n\n@pytest.mark.asyncio\nasync def test_database_disconnect(in_memory_db):\n    await in_memory_db.connect()\n    await in_memory_db.disconnect()\n    with pytest.raises(Exception):\n        async with in_memory_db.engine.connect() as conn:\n            await conn.execute(\"SELECT 1\")\n\n\n@pytest.mark.asyncio\nasync def test_database_session(in_memory_db):\n    async for session in in_memory_db.get_session():\n        assert isinstance(session, AsyncSession)\n"}
{"type": "test_file", "path": "chat_service/app/tests/unit/test_models.py", "content": "# app/tests/unit/test_models.py\nfrom app.infrastructure.models import User, Chat, Message, Token, MessageStatus\n\n\ndef test_user_model():\n    user = User(username=\"testuser\", email=\"test@example.com\")\n    assert user.username == \"testuser\"\n    assert user.email == \"test@example.com\"\n\n\ndef test_chat_model():\n    chat = Chat(name=\"Test Chat\")\n    assert chat.name == \"Test Chat\"\n\n\ndef test_message_model():\n    message = Message(content=\"Hello, world!\", chat_id=1, user_id=1)\n    assert message.content == \"Hello, world!\"\n    assert message.chat_id == 1\n    assert message.user_id == 1\n\n\ndef test_token_model():\n    token = Token(access_token=\"access\", refresh_token=\"refresh\", token_type=\"bearer\", user_id=1)\n    assert token.access_token == \"access\"\n    assert token.refresh_token == \"refresh\"\n    assert token.token_type == \"bearer\"\n    assert token.user_id == 1\n\n\ndef test_message_status_model():\n    status = MessageStatus(message_id=1, user_id=1, is_read=False)\n    assert status.message_id == 1\n    assert status.user_id == 1\n    assert status.is_read == False\n"}
{"type": "test_file", "path": "chat_service/app/tests/unit/test_event_handlers.py", "content": "# app/tests/unit/test_event_handlers.py\nfrom datetime import datetime, timezone\nfrom unittest.mock import AsyncMock\n\nimport pytest\nfrom app.domain.events import MessageCreated, MessageUpdated, MessageDeleted, UserInfo\nfrom app.domain.events import MessageStatusUpdated, UnreadCountUpdated\nfrom app.infrastructure.event_handlers import EventHandlers\n\n\n@pytest.fixture\ndef mock_redis_client():\n    return AsyncMock()\n\n\n@pytest.fixture\ndef event_handlers(mock_redis_client):\n    return EventHandlers(mock_redis_client)\n\n\n@pytest.mark.asyncio\nasync def test_publish_message_created(event_handlers, mock_redis_client):\n    event = MessageCreated(\n        message_id=1,\n        chat_id=1,\n        user_id=1,\n        content=\"Test\",\n        created_at=datetime.now(timezone.utc),\n        user=UserInfo(id=1, username=\"testuser\"),\n        is_deleted=False\n    )\n    await event_handlers.publish_message_created(event)\n    mock_redis_client.publish.assert_called_once()\n\n\n@pytest.mark.asyncio\nasync def test_publish_message_updated(event_handlers, mock_redis_client):\n    event = MessageUpdated(\n        message_id=1,\n        chat_id=1,\n        user_id=1,\n        content=\"Updated\",\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc),\n        user=UserInfo(id=1, username=\"testuser\"),\n        is_deleted=False\n    )\n    await event_handlers.publish_message_updated(event)\n    mock_redis_client.publish.assert_called_once()\n\n\n@pytest.mark.asyncio\nasync def test_publish_message_deleted(event_handlers, mock_redis_client):\n    event = MessageDeleted(\n        message_id=1,\n        chat_id=1,\n        user_id=1,\n        content=\"Deleted message\",\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc),\n        user=UserInfo(id=1, username=\"testuser\"),\n        is_deleted=True\n    )\n    await event_handlers.publish_message_deleted(event)\n    mock_redis_client.publish.assert_called_once()\n\n\n@pytest.mark.asyncio\nasync def test_publish_message_status_updated(event_handlers, mock_redis_client):\n    event = MessageStatusUpdated(message_id=1, chat_id=1, user_id=1, is_read=True, read_at=\"2023-01-01T00:00:00\")\n    await event_handlers.publish_message_status_updated(event)\n    mock_redis_client.publish.assert_called_once()\n\n\n@pytest.mark.asyncio\nasync def test_publish_unread_count_updated(event_handlers, mock_redis_client):\n    event = UnreadCountUpdated(chat_id=1, user_id=1, unread_count=5)\n    await event_handlers.publish_unread_count_updated(event)\n    mock_redis_client.publish.assert_called_once()\n"}
{"type": "test_file", "path": "chat_service/app/tests/integration/test_messages.py", "content": "import pytest\nfrom httpx import AsyncClient\n\npytestmark = pytest.mark.asyncio\n\n\nasync def test_create_message(client: AsyncClient, auth_header, mock_redis, test_user, test_chat):\n    response = await client.post(\n        \"/api/v1/messages/\",\n        headers=auth_header,\n        json={\"content\": \"Hello, World!\", \"chat_id\": test_chat.id}\n    )\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"content\"] == \"Hello, World!\"\n    assert data[\"chat_id\"] == test_chat.id\n    assert \"id\" in data\n    assert \"created_at\" in data\n    assert \"user\" in data\n    assert data[\"is_deleted\"] == False\n    assert \"statuses\" in data\n\n\nasync def test_read_messages(client: AsyncClient, auth_header, test_chat):\n    # Create multiple messages\n    for i in range(5):\n        await client.post(\n            \"/api/v1/messages/\",\n            headers=auth_header,\n            json={\"content\": f\"Message {i}\", \"chat_id\": test_chat.id}\n        )\n\n    response = await client.get(f\"/api/v1/messages/{test_chat.id}\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data) == 5\n    for msg in data:\n        assert \"id\" in msg\n        assert \"content\" in msg\n        assert \"created_at\" in msg\n        assert \"user\" in msg\n        assert \"statuses\" in msg\n\n\nasync def test_update_message(client: AsyncClient, auth_header, test_chat):\n    # Create a message\n    create_response = await client.post(\n        \"/api/v1/messages/\",\n        headers=auth_header,\n        json={\"content\": \"Original message\", \"chat_id\": test_chat.id}\n    )\n    message_id = create_response.json()[\"id\"]\n\n    # Update the message\n    update_response = await client.put(\n        f\"/api/v1/messages/{message_id}\",\n        headers=auth_header,\n        json={\"content\": \"Updated message\"}\n    )\n    assert update_response.status_code == 200\n    updated_data = update_response.json()\n    assert updated_data[\"content\"] == \"Updated message\"\n    assert \"updated_at\" in updated_data\n\n\nasync def test_delete_message(client: AsyncClient, auth_header, test_chat):\n    # Create a message\n    create_response = await client.post(\n        \"/api/v1/messages/\",\n        headers=auth_header,\n        json={\"content\": \"Message to delete\", \"chat_id\": test_chat.id}\n    )\n    message_id = create_response.json()[\"id\"]\n\n    # Delete the message\n    delete_response = await client.delete(f\"/api/v1/messages/{message_id}\", headers=auth_header)\n    assert delete_response.status_code == 200\n    deleted_data = delete_response.json()\n    assert deleted_data[\"is_deleted\"] == True\n    assert deleted_data[\"content\"] == \"<This message has been deleted>\"\n\n\nasync def test_update_message_status(client: AsyncClient, auth_header, test_chat):\n    # Create a message\n    create_response = await client.post(\n        \"/api/v1/messages/\",\n        headers=auth_header,\n        json={\"content\": \"Message to update status\", \"chat_id\": test_chat.id}\n    )\n    message_id = create_response.json()[\"id\"]\n\n    # Update message status\n    status_response = await client.put(\n        f\"/api/v1/messages/{message_id}/status\",\n        headers=auth_header,\n        json={\"is_read\": True}\n    )\n    assert status_response.status_code == 200\n    status_data = status_response.json()\n    assert any(status[\"is_read\"] for status in status_data[\"statuses\"])\n\n\nasync def test_get_messages_with_pagination(client: AsyncClient, auth_header, test_chat):\n    # Create 20 messages\n    for i in range(20):\n        await client.post(\n            \"/api/v1/messages/\",\n            headers=auth_header,\n            json={\"content\": f\"Message {i}\", \"chat_id\": test_chat.id}\n        )\n\n    # Get first page\n    response1 = await client.get(f\"/api/v1/messages/{test_chat.id}?skip=0&limit=10\", headers=auth_header)\n    assert response1.status_code == 200\n    data1 = response1.json()\n    assert len(data1) == 10\n\n    # Get second page\n    response2 = await client.get(f\"/api/v1/messages/{test_chat.id}?skip=10&limit=10\", headers=auth_header)\n    assert response2.status_code == 200\n    data2 = response2.json()\n    assert len(data2) == 10\n\n    # Ensure no duplicate messages\n    ids1 = {msg[\"id\"] for msg in data1}\n    ids2 = {msg[\"id\"] for msg in data2}\n    assert len(ids1.intersection(ids2)) == 0\n"}
{"type": "test_file", "path": "chat_service/app/tests/integration/test_auth.py", "content": "import asyncio\n\nimport pytest\nfrom httpx import AsyncClient\n\npytestmark = pytest.mark.asyncio\n\n\nasync def test_register_user(client: AsyncClient):\n    response = await client.post(\n        \"/api/v1/auth/register\",\n        json={\"username\": \"newuser\", \"email\": \"newuser@example.com\", \"password\": \"newpassword\"}\n    )\n    assert response.status_code == 200\n    assert \"id\" in response.json()\n    assert response.json()[\"username\"] == \"newuser\"\n    assert response.json()[\"email\"] == \"newuser@example.com\"\n\n\nasync def test_register_duplicate_username(client: AsyncClient, test_user):\n    response = await client.post(\n        \"/api/v1/auth/register\",\n        json={\"username\": test_user.username, \"email\": \"another@example.com\", \"password\": \"newpassword\"}\n    )\n    assert response.status_code == 400\n    assert \"Username already registered\" in response.json()[\"detail\"]\n\n\nasync def test_register_duplicate_email(client: AsyncClient, test_user):\n    response = await client.post(\n        \"/api/v1/auth/register\",\n        json={\"username\": \"uniqueuser\", \"email\": test_user.email, \"password\": \"newpassword\"}\n    )\n    assert response.status_code == 400\n    assert \"Email already registered\" in response.json()[\"detail\"]\n\n\nasync def test_register_invalid_email(client: AsyncClient):\n    response = await client.post(\n        \"/api/v1/auth/register\",\n        json={\"username\": \"invaliduser\", \"email\": \"notanemail\", \"password\": \"newpassword\"}\n    )\n    assert response.status_code == 422\n\n\nasync def test_register_short_password(client: AsyncClient):\n    response = await client.post(\n        \"/api/v1/auth/register\",\n        json={\"username\": \"shortpwuser\", \"email\": \"short@example.com\", \"password\": \"short\"}\n    )\n    assert response.status_code == 422\n\n\nasync def test_login_user(client: AsyncClient, test_user):\n    response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    assert response.status_code == 200\n    assert \"access_token\" in response.json()\n    assert \"refresh_token\" in response.json()\n    assert response.json()[\"token_type\"] == \"bearer\"\n\n\nasync def test_login_invalid_credentials(client: AsyncClient):\n    response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": \"nonexistentuser\", \"password\": \"wrongpassword\"}\n    )\n    assert response.status_code == 401\n    assert \"Incorrect username or password\" in response.json()[\"detail\"]\n\n\nasync def test_login_inactive_user(client: AsyncClient, test_user):\n    # Authenticate as the test user to get an access token\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    assert login_response.status_code == 200\n    access_token = login_response.json()[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    # Deactivate the user using the API endpoint\n    update_response = await client.put(\n        \"/api/v1/users/me\",\n        json={\"is_active\": False},\n        headers=headers\n    )\n\n    assert update_response.status_code == 200\n\n    # Attempt to login again with the same credentials\n    response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    assert response.status_code == 401\n    assert \"Inactive user\" in response.json()[\"detail\"]\n\n\nasync def test_refresh_token(client: AsyncClient, test_user):\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    refresh_token = login_response.json()[\"refresh_token\"]\n    original_access_token = login_response.json()[\"access_token\"]\n\n    await asyncio.sleep(1)\n\n    refresh_response = await client.post(\n        \"/api/v1/auth/refresh\",\n        json={\"refresh_token\": refresh_token}\n    )\n    assert refresh_response.status_code == 200\n    assert \"access_token\" in refresh_response.json()\n    new_access_token = refresh_response.json()[\"access_token\"]\n\n    assert new_access_token != original_access_token\n\n\nasync def test_refresh_token_invalid(client: AsyncClient):\n    response = await client.post(\n        \"/api/v1/auth/refresh\",\n        json={\"refresh_token\": \"invalid_token\"}\n    )\n    assert response.status_code == 401\n    assert \"Invalid refresh token\" in response.json()[\"detail\"]\n\n\nasync def test_refresh_token_reuse(client: AsyncClient, test_user):\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    refresh_token = login_response.json()[\"refresh_token\"]\n\n    # Use refresh token once\n    refresh_response = await client.post(\n        \"/api/v1/auth/refresh\",\n        json={\"refresh_token\": refresh_token}\n    )\n    assert refresh_response.status_code == 200\n\n    # Try to use the same refresh token again\n    response = await client.post(\n        \"/api/v1/auth/refresh\",\n        json={\"refresh_token\": refresh_token}\n    )\n    assert response.status_code == 200  # Will return a new access token\n\n\nasync def test_access_token_expiration(client: AsyncClient, test_user, app_config):\n    original_expire_minutes = app_config.ACCESS_TOKEN_EXPIRE_MINUTES\n    app_config.ACCESS_TOKEN_EXPIRE_MINUTES = 0.05  # 3 seconds\n\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    access_token = login_response.json()[\"access_token\"]\n\n    await asyncio.sleep(4)\n\n    me_response = await client.get(\n        \"/api/v1/users/me\",\n        headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert me_response.status_code == 401\n\n    app_config.ACCESS_TOKEN_EXPIRE_MINUTES = original_expire_minutes\n\n\nasync def test_refresh_token_expiration(client: AsyncClient, test_user, app_config):\n    original_expire_days = app_config.REFRESH_TOKEN_EXPIRE_DAYS\n    app_config.REFRESH_TOKEN_EXPIRE_DAYS = 1 / 86400  # 1 second in days\n\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    refresh_token = login_response.json()[\"refresh_token\"]\n\n    await asyncio.sleep(2)\n\n    refresh_response = await client.post(\n        \"/api/v1/auth/refresh\",\n        json={\"refresh_token\": refresh_token}\n    )\n    assert refresh_response.status_code == 401\n    assert \"Invalid refresh token\" in refresh_response.json()[\"detail\"]\n\n    app_config.REFRESH_TOKEN_EXPIRE_DAYS = original_expire_days\n\n\nasync def test_logout(client: AsyncClient, auth_header):\n    response = await client.post(\"/api/v1/auth/logout\", headers=auth_header)\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Successfully logged out\"}\n\n    await asyncio.sleep(0.1)\n\n    me_response = await client.get(\"/api/v1/users/me\", headers=auth_header)\n    assert me_response.status_code == 401\n\n\nasync def test_password_hashing(client: AsyncClient):\n    register_response = await client.post(\n        \"/api/v1/auth/register\",\n        json={\"username\": \"hashtest\", \"email\": \"hashtest@example.com\", \"password\": \"testpassword\"}\n    )\n    assert register_response.status_code == 200\n\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": \"hashtest\", \"password\": \"testpassword\"}\n    )\n    assert login_response.status_code == 200\n\n    user_response = await client.get(\n        \"/api/v1/users/me\",\n        headers={\"Authorization\": f\"Bearer {login_response.json()['access_token']}\"}\n    )\n    assert \"password\" not in user_response.json()\n    assert \"hashed_password\" not in user_response.json()\n\n\nasync def test_multiple_login_sessions(client: AsyncClient, test_user, db_session):\n    # Login from two different \"devices\"\n    login1 = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    login2 = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n\n    assert login1.status_code == 200\n    assert login2.status_code == 200\n    assert login1.json()[\"access_token\"] != login2.json()[\"access_token\"]\n\n    # The first token should now be invalid\n    me1 = await client.get(\n        \"/api/v1/users/me\",\n        headers={\"Authorization\": f\"Bearer {login1.json()['access_token']}\"}\n    )\n    assert me1.status_code == 401  # Unauthorized\n\n    # The second token should be valid\n    me2 = await client.get(\n        \"/api/v1/users/me\",\n        headers={\"Authorization\": f\"Bearer {login2.json()['access_token']}\"}\n    )\n    assert me2.status_code == 200\n\n\nasync def test_login_case_insensitive_username(client: AsyncClient, test_user):\n    response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username.upper(), \"password\": \"testpassword\"}\n    )\n    assert response.status_code == 200\n    assert \"access_token\" in response.json()\n\n\nasync def test_register_user_creation_failed(client: AsyncClient):\n    response = await client.post(\n        \"/api/v1/auth/register\",\n        json={\"username\": \"\", \"email\": \"invalid_email\", \"password\": \"\"}\n    )\n    assert response.status_code == 422  # Unprocessable Entity\n    errors = response.json()[\"detail\"]\n\n    # Check for email validation error\n    assert any(error[\"loc\"] == [\"body\", \"email\"] and \"not a valid email address\" in error[\"msg\"] for error in errors)\n\n    # Check for password length error\n    assert any(\n        error[\"loc\"] == [\"body\", \"password\"] and \"String should have at least 8 characters\" in error[\"msg\"] for error in\n        errors)\n\n    # Check that there's no specific error for username\n    assert not any(\"username\" in error[\"loc\"] for error in errors)\n\n\nasync def test_refresh_token_invalid_token(client: AsyncClient):\n    response = await client.post(\n        \"/api/v1/auth/refresh\",\n        json={\"refresh_token\": \"invalid_token\"}\n    )\n    assert response.status_code == 401\n    assert \"Invalid refresh token\" in response.json()[\"detail\"]\n\n\nasync def test_refresh_token_invalid_user(client: AsyncClient, test_user):\n    # First, login to get tokens\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    assert login_response.status_code == 200\n    access_token = login_response.json()[\"access_token\"]\n    refresh_token = login_response.json()[\"refresh_token\"]\n\n    # Deactivate the user\n    deactivate_response = await client.put(\n        \"/api/v1/users/me\",\n        json={\"is_active\": False},\n        headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert deactivate_response.status_code == 200\n\n    # Attempt to refresh the token with the now-inactive user\n    response = await client.post(\n        \"/api/v1/auth/refresh\",\n        json={\"refresh_token\": refresh_token}\n    )\n\n    assert response.status_code == 401\n    assert \"User not found or inactive\" in response.json()[\"detail\"]\n\n\nasync def test_refresh_token_inactive_user(client: AsyncClient, test_user):\n    # First, login to get tokens and deactivate the user\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user.username, \"password\": \"testpassword\"}\n    )\n    assert login_response.status_code == 200\n    access_token = login_response.json()[\"access_token\"]\n    refresh_token = login_response.json()[\"refresh_token\"]\n\n    # Deactivate the user\n    update_response = await client.put(\n        \"/api/v1/users/me\",\n        json={\"is_active\": False},\n        headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert update_response.status_code == 200\n\n    # Attempt to refresh the token with the inactive user\n    refresh_response = await client.post(\n        \"/api/v1/auth/refresh\",\n        json={\"refresh_token\": refresh_token}\n    )\n    assert refresh_response.status_code == 401\n    assert \"User not found or inactive\" in refresh_response.json()[\"detail\"]\n\n\nasync def test_logout_invalid_token(client: AsyncClient):\n    response = await client.post(\n        \"/api/v1/auth/logout\",\n        headers={\"Authorization\": \"Bearer invalid_token\"}\n    )\n    assert response.status_code == 401\n    assert \"Invalid token\" in response.json()[\"detail\"]\n"}
{"type": "test_file", "path": "chat_service/app/tests/integration/__init__.py", "content": ""}
{"type": "test_file", "path": "chat_service/app/tests/integration/test_chats.py", "content": "import pytest\nfrom httpx import AsyncClient\n\npytestmark = pytest.mark.asyncio\n\n\nasync def test_create_chat(client: AsyncClient, auth_header, test_user2):\n    response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user2.id]}\n    )\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"name\"] == \"Test Chat\"\n    assert len(data[\"members\"]) == 2\n\n\nasync def test_create_chat_with_invalid_member(client: AsyncClient, auth_header):\n    response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Invalid Member Chat\", \"member_ids\": [99999]}  # Non-existent user ID\n    )\n    assert response.status_code == 404\n\n\nasync def test_get_chats(client: AsyncClient, auth_header):\n    # Create multiple chats\n    await client.post(\"/api/v1/chats/\", headers=auth_header, json={\"name\": \"Chat 1\", \"member_ids\": []})\n    await client.post(\"/api/v1/chats/\", headers=auth_header, json={\"name\": \"Chat 2\", \"member_ids\": []})\n\n    response = await client.get(\"/api/v1/chats/\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert isinstance(data, list)\n    assert len(data) >= 2\n\n\nasync def test_get_chats_with_pagination(client: AsyncClient, auth_header):\n    # Create multiple chats\n    for i in range(5):\n        await client.post(\"/api/v1/chats/\", headers=auth_header, json={\"name\": f\"Chat {i}\", \"member_ids\": []})\n\n    response = await client.get(\"/api/v1/chats/?skip=2&limit=2\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data) == 2\n\n\nasync def test_get_chats_with_name_filter(client: AsyncClient, auth_header):\n    await client.post(\"/api/v1/chats/\", headers=auth_header, json={\"name\": \"Alpha Chat\", \"member_ids\": []})\n    await client.post(\"/api/v1/chats/\", headers=auth_header, json={\"name\": \"Beta Chat\", \"member_ids\": []})\n\n    response = await client.get(\"/api/v1/chats/?name=Alpha\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data) == 1\n    assert data[0][\"name\"] == \"Alpha Chat\"\n\n\nasync def test_start_chat(client: AsyncClient, auth_header, test_user, test_user2):\n    response = await client.post(\n        \"/api/v1/chats/start\",\n        headers=auth_header,\n        json={\"other_user_id\": test_user2.id}\n    )\n    assert response.status_code == 200\n    data = response.json()\n    expected_chat_name = f\"Chat between {test_user.username} and {test_user2.username}\"\n    assert expected_chat_name in data[\"name\"]\n\n\nasync def test_start_chat_with_nonexistent_user(client: AsyncClient, auth_header):\n    response = await client.post(\n        \"/api/v1/chats/start\",\n        headers=auth_header,\n        json={\"other_user_id\": 99999}\n    )\n    assert response.status_code == 404\n\n\nasync def test_get_chat_by_id(client: AsyncClient, auth_header):\n    create_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": []}\n    )\n    chat_id = create_response.json()[\"id\"]\n\n    response = await client.get(f\"/api/v1/chats/{chat_id}\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"id\"] == chat_id\n    assert data[\"name\"] == \"Test Chat\"\n\n\nasync def test_get_nonexistent_chat(client: AsyncClient, auth_header):\n    response = await client.get(\"/api/v1/chats/99999\", headers=auth_header)\n    assert response.status_code == 404\n\n\nasync def test_update_chat(client: AsyncClient, auth_header):\n    create_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Original Chat\", \"member_ids\": []}\n    )\n    chat_id = create_response.json()[\"id\"]\n\n    update_response = await client.put(\n        f\"/api/v1/chats/{chat_id}\",\n        headers=auth_header,\n        json={\"name\": \"Updated Chat\"}\n    )\n    assert update_response.status_code == 200\n    data = update_response.json()\n    assert data[\"name\"] == \"Updated Chat\"\n\n\nasync def test_update_nonexistent_chat(client: AsyncClient, auth_header):\n    response = await client.put(\n        \"/api/v1/chats/99999\",\n        headers=auth_header,\n        json={\"name\": \"Updated Chat\"}\n    )\n    assert response.status_code == 404\n\n\nasync def test_delete_chat(client: AsyncClient, auth_header):\n    create_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Delete Me Chat\", \"member_ids\": []}\n    )\n    chat_id = create_response.json()[\"id\"]\n\n    delete_response = await client.delete(f\"/api/v1/chats/{chat_id}\", headers=auth_header)\n    assert delete_response.status_code == 204\n\n    get_response = await client.get(f\"/api/v1/chats/{chat_id}\", headers=auth_header)\n    assert get_response.status_code == 404\n\n\nasync def test_delete_nonexistent_chat(client: AsyncClient, auth_header):\n    response = await client.delete(\"/api/v1/chats/99999\", headers=auth_header)\n    assert response.status_code == 404\n\n\nasync def test_add_chat_member(client: AsyncClient, auth_header, test_user, test_user2):\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id]}\n    )\n    chat_id = chat_response.json()[\"id\"]\n\n    response = await client.post(\n        f\"/api/v1/chats/{chat_id}/members\",\n        headers=auth_header,\n        json={\"user_id\": test_user2.id}\n    )\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data[\"members\"]) == 2\n    member_ids = [member[\"id\"] for member in data[\"members\"]]\n    assert test_user.id in member_ids\n    assert test_user2.id in member_ids\n\n\nasync def test_add_nonexistent_member(client: AsyncClient, auth_header, test_user):\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id]}\n    )\n    chat_id = chat_response.json()[\"id\"]\n\n    response = await client.post(\n        f\"/api/v1/chats/{chat_id}/members\",\n        headers=auth_header,\n        json={\"user_id\": 99999}\n    )\n    assert response.status_code == 404\n\n\nasync def test_remove_chat_member(client: AsyncClient, auth_header, test_user, test_user2):\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id, test_user2.id]}\n    )\n    chat_id = chat_response.json()[\"id\"]\n\n    response = await client.delete(f\"/api/v1/chats/{chat_id}/members/{test_user2.id}\", headers=auth_header)\n    assert response.status_code == 204\n\n    get_response = await client.get(f\"/api/v1/chats/{chat_id}\", headers=auth_header)\n    assert get_response.status_code == 200\n    data = get_response.json()\n    member_ids = [member[\"id\"] for member in data[\"members\"]]\n    assert test_user2.id not in member_ids\n\n\nasync def test_remove_nonexistent_member(client: AsyncClient, auth_header, test_user):\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id]}\n    )\n    chat_id = chat_response.json()[\"id\"]\n\n    response = await client.delete(f\"/api/v1/chats/{chat_id}/members/99999\", headers=auth_header)\n    assert response.status_code == 404\n\n\nasync def test_get_chat_members(client: AsyncClient, auth_header, test_user, test_user2):\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id, test_user2.id]}\n    )\n    chat_id = chat_response.json()[\"id\"]\n\n    response = await client.get(f\"/api/v1/chats/{chat_id}/members\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data) == 2\n    member_ids = [member[\"id\"] for member in data]\n    assert test_user.id in member_ids\n    assert test_user2.id in member_ids\n\n\nasync def test_get_unread_messages_count(client: AsyncClient, auth_header, test_user):\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id]}\n    )\n    chat_id = chat_response.json()[\"id\"]\n\n    response = await client.get(f\"/api/v1/chats/{chat_id}/unread_count\", headers=auth_header)\n    assert response.status_code == 200\n    assert isinstance(response.json(), int)\n\n\nasync def test_get_unread_messages_count_nonexistent_chat(client: AsyncClient, auth_header):\n    response = await client.get(\"/api/v1/chats/99999/unread_count\", headers=auth_header)\n    assert response.status_code == 404\n\n\nasync def test_get_chat_not_found(client: AsyncClient, auth_header):\n    response = await client.get(\"/api/v1/chats/99999\", headers=auth_header)\n    assert response.status_code == 404\n    assert \"Chat not found\" in response.json()[\"detail\"]\n\n\nasync def test_update_chat_not_found(client: AsyncClient, auth_header):\n    response = await client.put(\n        \"/api/v1/chats/99999\",\n        headers=auth_header,\n        json={\"name\": \"Updated Chat\"}\n    )\n    assert response.status_code == 404\n    assert \"Chat not found\" in response.json()[\"detail\"]\n\n\nasync def test_delete_chat_not_found(client: AsyncClient, auth_header):\n    response = await client.delete(\"/api/v1/chats/99999\", headers=auth_header)\n    assert response.status_code == 404\n    assert \"Chat not found\" in response.json()[\"detail\"]\n\n\nasync def test_get_chat_members_not_found(client: AsyncClient, auth_header):\n    response = await client.get(\"/api/v1/chats/99999/members\", headers=auth_header)\n    assert response.status_code == 404\n    assert \"Chat not found or you're not a member\" in response.json()[\"detail\"]\n\n\nasync def test_add_chat_member_user_not_found(client: AsyncClient, auth_header, test_user):\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id]}\n    )\n    chat_id = chat_response.json()[\"id\"]\n\n    response = await client.post(\n        f\"/api/v1/chats/{chat_id}/members\",\n        headers=auth_header,\n        json={\"user_id\": 99999}\n    )\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n\nasync def test_add_chat_member_chat_not_found(client: AsyncClient, auth_header, test_user2):\n    response = await client.post(\n        \"/api/v1/chats/99999/members\",\n        headers=auth_header,\n        json={\"user_id\": test_user2.id}\n    )\n    assert response.status_code == 404\n    assert \"Chat not found\" in response.json()[\"detail\"]\n\n\nasync def test_remove_chat_member_user_not_found(client: AsyncClient, auth_header, test_user):\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id]}\n    )\n    chat_id = chat_response.json()[\"id\"]\n\n    response = await client.delete(f\"/api/v1/chats/{chat_id}/members/99999\", headers=auth_header)\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n\nasync def test_remove_chat_member_chat_not_found(client: AsyncClient, auth_header, test_user2):\n    response = await client.delete(f\"/api/v1/chats/99999/members/{test_user2.id}\", headers=auth_header)\n    assert response.status_code == 404\n    assert \"Chat not found\" in response.json()[\"detail\"]\n\n\nasync def test_get_unread_messages_count_not_found(client: AsyncClient, auth_header):\n    response = await client.get(\"/api/v1/chats/99999/unread_count\", headers=auth_header)\n    assert response.status_code == 404\n    assert \"Chat not found\" in response.json()[\"detail\"]\n\n\nasync def test_create_chat_with_invalid_members(client: AsyncClient, auth_header):\n    response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Invalid Members Chat\", \"member_ids\": [99999, 100000]}\n    )\n    assert response.status_code == 404\n    assert \"One or more invalid member IDs\" in response.json()[\"detail\"]\n\n\nasync def test_create_chat_with_duplicate_members(client: AsyncClient, auth_header, test_user):\n    response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Duplicate Members Chat\", \"member_ids\": [test_user.id, test_user.id]}\n    )\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data[\"members\"]) == 1\n\n\nasync def test_get_chats_with_complex_name_filter(client: AsyncClient, auth_header):\n    await client.post(\"/api/v1/chats/\", headers=auth_header, json={\"name\": \"Alpha Beta Chat\", \"member_ids\": []})\n    await client.post(\"/api/v1/chats/\", headers=auth_header, json={\"name\": \"Beta Gamma Chat\", \"member_ids\": []})\n    await client.post(\"/api/v1/chats/\", headers=auth_header, json={\"name\": \"Gamma Alpha Chat\", \"member_ids\": []})\n\n    response = await client.get(\"/api/v1/chats/?name=Alpha\", headers=auth_header)\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data) == 2\n    assert all(\"Alpha\" in chat[\"name\"] for chat in data)\n\n\nasync def test_start_chat_with_self(client: AsyncClient, auth_header, test_user):\n    response = await client.post(\n        \"/api/v1/chats/start\",\n        headers=auth_header,\n        json={\"other_user_id\": test_user.id}\n    )\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n\nasync def test_get_members_of_nonexistent_chat(client: AsyncClient, auth_header):\n    response = await client.get(\"/api/v1/chats/99999/members\", headers=auth_header)\n    assert response.status_code == 404\n    assert \"Chat not found or you're not a member\" in response.json()[\"detail\"]\n\n\nasync def test_add_nonexistent_member_to_chat(client: AsyncClient, auth_header, test_chat):\n    response = await client.post(\n        f\"/api/v1/chats/{test_chat.id}/members\",\n        headers=auth_header,\n        json={\"user_id\": 99999}\n    )\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n\nasync def test_add_member_to_nonexistent_chat(client: AsyncClient, auth_header, test_user2):\n    response = await client.post(\n        \"/api/v1/chats/99999/members\",\n        headers=auth_header,\n        json={\"user_id\": test_user2.id}\n    )\n    assert response.status_code == 404\n    assert \"Chat not found\" in response.json()[\"detail\"]\n\n\nasync def test_remove_nonexistent_member_from_chat(client: AsyncClient, auth_header, test_chat):\n    response = await client.delete(f\"/api/v1/chats/{test_chat.id}/members/99999\", headers=auth_header)\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n\nasync def test_create_chat_and_add_message(client: AsyncClient, auth_header, test_user, test_user2):\n    # Create a chat\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id, test_user2.id]}\n    )\n    assert chat_response.status_code == 200\n    chat_id = chat_response.json()[\"id\"]\n\n    # Add a message to the chat\n    message_response = await client.post(\n        f\"/api/v1/messages/\",\n        headers=auth_header,\n        json={\"chat_id\": chat_id, \"content\": \"Test message\"}\n    )\n    assert message_response.status_code == 200\n    assert message_response.json()[\"content\"] == \"Test message\"\n\n    # Get auth header for test_user2\n    login_response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\"username\": test_user2.username, \"password\": \"testpassword2\"}\n    )\n    assert login_response.status_code == 200\n    test_user2_auth_header = {\"Authorization\": f\"Bearer {login_response.json()['access_token']}\"}\n\n    # Check unread count for test_user2\n    unread_response = await client.get(f\"/api/v1/chats/{chat_id}/unread_count\", headers=test_user2_auth_header)\n    assert unread_response.status_code == 200\n    assert unread_response.json() == 1\n\n\nasync def test_update_message_status_and_unread_count(client: AsyncClient, auth_header, test_user, test_user2):\n    # Create a chat and add a message\n    chat_response = await client.post(\n        \"/api/v1/chats/\",\n        headers=auth_header,\n        json={\"name\": \"Test Chat\", \"member_ids\": [test_user.id, test_user2.id]}\n    )\n    chat_id = chat_response.json()[\"id\"]\n    message_response = await client.post(\n        f\"/api/v1/messages/\",\n        headers=auth_header,\n        json={\"chat_id\": chat_id, \"content\": \"Test message\"}\n    )\n    message_id = message_response.json()[\"id\"]\n\n    # Update message status\n    status_response = await client.put(\n        f\"/api/v1/messages/{message_id}/status\",\n        headers=auth_header,\n        json={\"is_read\": True}\n    )\n    assert status_response.status_code == 200\n\n    # Check updated unread count\n    unread_response = await client.get(f\"/api/v1/chats/{chat_id}/unread_count\", headers=auth_header)\n    assert unread_response.status_code == 200\n    assert unread_response.json() == 0\n"}
{"type": "test_file", "path": "chat_service/app/tests/unit/test_redis_client.py", "content": "# app/tests/unit/test_redis_client.py\n\nimport json\nimport logging\nfrom datetime import datetime\nfrom unittest.mock import AsyncMock, patch\n\nimport pytest\nimport redis\nfrom app.domain.events import MessageCreated, MessageUpdated, MessageDeleted, MessageStatusUpdated, UnreadCountUpdated\nfrom app.infrastructure.event_handlers import EventHandlers\nfrom app.infrastructure.redis_client import RedisClient\n\n\n@pytest.fixture\ndef test_logger():\n    logger = logging.getLogger('test_redis')\n    logger.setLevel(logging.DEBUG)\n    return logger\n\n\n@pytest.fixture\ndef redis_client(test_logger):\n    return RedisClient(host=\"localhost\", port=6379, logger=test_logger)\n\n\n@pytest.fixture\ndef event_handlers(redis_client):\n    return EventHandlers(redis_client)\n\n\n@pytest.mark.asyncio\nasync def test_redis_connect_and_publish(redis_client, caplog):\n    caplog.set_level(logging.DEBUG)\n    with patch('redis.asyncio.Redis', return_value=AsyncMock()) as mock_redis:\n        mock_redis.return_value.ping.return_value = True\n        await redis_client.connect()\n        assert redis_client.client is not None\n        assert f\"Successfully connected to Redis at {redis_client.host}:{redis_client.port}\" in caplog.text\n\n        await redis_client.publish(\"test_channel\", \"test_message\")\n        redis_client.client.publish.assert_called_once_with(\"test_channel\", \"test_message\")\n        assert \"Published message to channel test_channel\" in caplog.text\n\n\n@pytest.mark.asyncio\nasync def test_redis_publish_message_created(redis_client, event_handlers, caplog):\n    caplog.set_level(logging.DEBUG)\n    redis_client.client = AsyncMock()\n\n    event = MessageCreated(\n        message_id=1,\n        chat_id=1,\n        user_id=1,\n        content=\"Test message\",\n        created_at=datetime(2023, 1, 1, 12, 0, 0),\n        user={\"id\": 1, \"username\": \"testuser\"},\n        is_deleted=False\n    )\n    await event_handlers.publish_message_created(event)\n\n    expected_data = {\n        \"id\": 1,\n        \"chat_id\": 1,\n        \"user_id\": 1,\n        \"content\": \"Test message\",\n        \"created_at\": \"2023-01-01 12:00:00\",\n        \"user\": {\"id\": 1, \"username\": \"testuser\"},\n        \"is_deleted\": False\n    }\n    redis_client.client.publish.assert_called_once()\n    call_args = redis_client.client.publish.call_args\n    assert call_args[0][0] == \"chat:1\"\n    assert json.loads(call_args[0][1]) == expected_data\n    assert \"Published message to channel chat:1\" in caplog.text\n\n\n@pytest.mark.asyncio\nasync def test_redis_publish_message_updated(redis_client, event_handlers, caplog):\n    caplog.set_level(logging.DEBUG)\n    redis_client.client = AsyncMock()\n\n    event = MessageUpdated(\n        message_id=1,\n        chat_id=1,\n        user_id=1,\n        content=\"Updated message\",\n        created_at=datetime(2023, 1, 1, 12, 0, 0),\n        updated_at=datetime(2023, 1, 1, 13, 0, 0),\n        user={\"id\": 1, \"username\": \"testuser\"},\n        is_deleted=False\n    )\n    await event_handlers.publish_message_updated(event)\n\n    expected_data = {\n        \"id\": 1,\n        \"chat_id\": 1,\n        \"user_id\": 1,\n        \"content\": \"Updated message\",\n        \"created_at\": \"2023-01-01 12:00:00\",\n        \"updated_at\": \"2023-01-01 13:00:00\",\n        \"user\": {\"id\": 1, \"username\": \"testuser\"},\n        \"is_deleted\": False\n    }\n    redis_client.client.publish.assert_called_once()\n    call_args = redis_client.client.publish.call_args\n    assert call_args[0][0] == \"chat:1\"\n    assert json.loads(call_args[0][1]) == expected_data\n    assert \"Published message to channel chat:1\" in caplog.text\n\n\n@pytest.mark.asyncio\nasync def test_redis_publish_message_deleted(redis_client, event_handlers, caplog):\n    caplog.set_level(logging.DEBUG)\n    redis_client.client = AsyncMock()\n\n    event = MessageDeleted(\n        message_id=1,\n        chat_id=1,\n        user_id=1,\n        content=\"<This message has been deleted>\",\n        created_at=datetime(2023, 1, 1, 12, 0, 0),\n        updated_at=datetime(2023, 1, 1, 13, 0, 0),\n        user={\"id\": 1, \"username\": \"testuser\"},\n        is_deleted=True\n    )\n    await event_handlers.publish_message_deleted(event)\n\n    expected_data = {\n        \"id\": 1,\n        \"chat_id\": 1,\n        \"user_id\": 1,\n        \"content\": \"<This message has been deleted>\",\n        \"created_at\": \"2023-01-01 12:00:00\",\n        \"updated_at\": \"2023-01-01 13:00:00\",\n        \"user\": {\"id\": 1, \"username\": \"testuser\"},\n        \"is_deleted\": True\n    }\n    redis_client.client.publish.assert_called_once()\n    call_args = redis_client.client.publish.call_args\n    assert call_args[0][0] == \"chat:1\"\n    assert json.loads(call_args[0][1]) == expected_data\n    assert \"Published message to channel chat:1\" in caplog.text\n\n\n@pytest.mark.asyncio\nasync def test_redis_publish_message_status_updated(redis_client, event_handlers, caplog):\n    caplog.set_level(logging.DEBUG)\n    redis_client.client = AsyncMock()\n\n    event = MessageStatusUpdated(\n        message_id=1,\n        chat_id=1,\n        user_id=1,\n        is_read=True,\n        read_at=datetime(2023, 1, 1, 12, 0, 0)\n    )\n    await event_handlers.publish_message_status_updated(event)\n\n    expected_data = {\n        \"message_id\": 1,\n        \"user_id\": 1,\n        \"is_read\": True,\n        \"read_at\": \"2023-01-01 12:00:00\"\n    }\n    redis_client.client.publish.assert_called_once()\n    call_args = redis_client.client.publish.call_args\n    assert call_args[0][0] == \"chat:1:status\"\n    assert json.loads(call_args[0][1]) == expected_data\n    assert \"Published message to channel chat:1:status\" in caplog.text\n\n\n@pytest.mark.asyncio\nasync def test_redis_publish_unread_count_updated(redis_client, event_handlers, caplog):\n    caplog.set_level(logging.DEBUG)\n    redis_client.client = AsyncMock()\n\n    event = UnreadCountUpdated(chat_id=1, user_id=1, unread_count=5)\n    await event_handlers.publish_unread_count_updated(event)\n\n    expected_data = {\n        \"chat_id\": 1,\n        \"user_id\": 1,\n        \"unread_count\": 5\n    }\n    redis_client.client.publish.assert_called_once()\n    call_args = redis_client.client.publish.call_args\n    assert call_args[0][0] == \"chat:1:unread_count:1\"\n    assert json.loads(call_args[0][1]) == expected_data\n    assert \"Published message to channel chat:1:unread_count:1\" in caplog.text\n\n\n@pytest.mark.asyncio\nasync def test_redis_connect_fail(redis_client, caplog):\n    caplog.set_level(logging.ERROR)\n    with patch('redis.asyncio.Redis', return_value=AsyncMock()) as mock_redis:\n        mock_redis.return_value.ping.side_effect = redis.ConnectionError(\"Connection failed\")\n        with pytest.raises(redis.ConnectionError):\n            await redis_client.connect()\n        assert \"Failed to connect to Redis: Connection failed\" in caplog.text\n        assert f\"Redis host: {redis_client.host}, Redis port: {redis_client.port}\" in caplog.text\n\n\n@pytest.mark.asyncio\nasync def test_redis_disconnect(redis_client, caplog):\n    caplog.set_level(logging.INFO)\n    redis_client.client = AsyncMock()\n    await redis_client.disconnect()\n    redis_client.client.close.assert_called_once()\n    assert \"Disconnected from Redis\" in caplog.text\n"}
{"type": "test_file", "path": "chat_service/app/tests/unit/test_unit_of_work.py", "content": "# app/tests/unit/test_unit_of_work.py\n\nfrom unittest.mock import AsyncMock\n\nimport pytest\nfrom app.infrastructure import models\nfrom app.infrastructure.data_mappers import UserMapper\nfrom app.infrastructure.uow import UoWModel, UnitOfWork\n\n\n@pytest.fixture\ndef mock_session():\n    \"\"\"\n    Provides a mocked AsyncSession for testing.\n    \"\"\"\n    return AsyncMock()\n\n\n@pytest.fixture\ndef uow(mock_session):\n    \"\"\"\n    Initializes the UnitOfWork with a mocked UserMapper.\n    \"\"\"\n    uow = UnitOfWork()\n    user_mapper = UserMapper(mock_session)\n    user_mapper.insert = AsyncMock()\n    user_mapper.update = AsyncMock()\n    user_mapper.delete = AsyncMock()\n    uow.mappers[models.User] = user_mapper\n    return uow\n\n\n@pytest.mark.asyncio\nasync def test_register_new_model(uow):\n    \"\"\"\n    Test registering a new model and ensuring it's tracked correctly.\n    \"\"\"\n    user = models.User(username=\"testuser\", email=\"test@example.com\")\n    uow_model = uow.register_new(user)\n\n    assert len(uow.new) == 1, \"New models should be tracked in 'new'\"\n    assert id(user) in uow.new, \"Registered model should exist in 'new'\"\n    assert isinstance(uow_model, UoWModel), \"Returned object should be an instance of UoWModel\"\n\n\n@pytest.mark.asyncio\nasync def test_modify_new_model_does_not_register_dirty(uow):\n    \"\"\"\n    Test that modifying a newly registered model does not add it to 'dirty'.\n    \"\"\"\n    user = models.User(username=\"testuser\", email=\"test@example.com\")\n    uow_model = uow.register_new(user)\n\n    # Modify the model\n    uow_model.username = \"updateduser\"\n\n    # Since the model is in 'new', it should not appear in 'dirty'\n    assert len(uow.dirty) == 0, \"'dirty' should remain empty for new models\"\n    assert id(user) in uow.new, \"Modified new model should remain in 'new'\"\n\n\n@pytest.mark.asyncio\nasync def test_register_existing_model_as_dirty(uow):\n    \"\"\"\n    Test registering an existing model as dirty and ensuring it's tracked correctly.\n    \"\"\"\n    user = models.User(username=\"existinguser\", email=\"existing@example.com\")\n\n    # Simulate that the model is already existing (not new)\n    uow_model = UoWModel(user, uow)\n    uow_model.email = \"updated@example.com\"\n\n    # Now, 'dirty' should include the model\n    assert len(uow.dirty) == 1, \"Existing models should be tracked in 'dirty' when modified\"\n    assert id(user) in uow.dirty, \"Modified existing model should exist in 'dirty'\"\n\n\n@pytest.mark.asyncio\nasync def test_register_deleted_model(uow):\n    \"\"\"\n    Test registering a model for deletion and ensuring it's tracked correctly.\n    \"\"\"\n    user = models.User(username=\"existinguser\", email=\"existing@example.com\")\n\n    # Register the model as deleted\n    uow.register_deleted(user)\n\n    assert len(uow.deleted) == 1, \"Deleted models should be tracked in 'deleted'\"\n    assert id(user) in uow.deleted, \"Deleted model should exist in 'deleted'\"\n\n\n@pytest.mark.asyncio\nasync def test_register_deleted_model_removes_from_new_and_dirty(uow):\n    new_user = models.User(username=\"newuser\", email=\"new@example.com\")\n    uow_model = uow.register_new(new_user)\n\n    dirty_user = models.User(username=\"dirtyuser\", email=\"dirty@example.com\")\n    uow.register_dirty(dirty_user)\n\n    uow.register_deleted(uow_model)\n    uow.register_deleted(dirty_user)\n\n    assert id(new_user) not in uow.new, \"Deleted new model shouldn't remain in 'new'\"\n    assert id(dirty_user) not in uow.dirty, \"Deleted dirty model should be removed from 'dirty'\"\n    assert id(dirty_user) in uow.deleted, \"Deleted dirty model should be added to 'deleted'\"\n    # New models are not added to deleted when removed\n    assert id(new_user) not in uow.deleted, \"Deleted new model should not be in 'deleted'\"\n\n\n@pytest.mark.asyncio\nasync def test_commit_inserts_new_models(uow):\n    \"\"\"\n    Test that committing the UoW calls insert on new models.\n    \"\"\"\n    user = models.User(username=\"testuser\", email=\"test@example.com\")\n    uow.register_new(user)\n    await uow.commit()\n\n    # Verify that insert was called once with the correct model\n    uow.mappers[models.User].insert.assert_awaited_once_with(user)\n\n\n@pytest.mark.asyncio\nasync def test_commit_updates_dirty_models(uow):\n    \"\"\"\n    Test that committing the UoW calls update on dirty models.\n    \"\"\"\n    user = models.User(username=\"existinguser\", email=\"existing@example.com\")\n    uow.register_dirty(user)\n    await uow.commit()\n\n    # Verify that update was called once with the correct model\n    uow.mappers[models.User].update.assert_awaited_once_with(user)\n\n\n@pytest.mark.asyncio\nasync def test_commit_deletes_deleted_models(uow):\n    \"\"\"\n    Test that committing the UoW calls delete on deleted models.\n    \"\"\"\n    user = models.User(username=\"existinguser\", email=\"existing@example.com\")\n    uow.register_deleted(user)\n    await uow.commit()\n\n    # Verify that delete was called once with the correct model\n    uow.mappers[models.User].delete.assert_awaited_once_with(user)\n\n\n@pytest.mark.asyncio\nasync def test_commit_handles_multiple_operations(uow):\n    \"\"\"\n    Test that committing the UoW handles multiple operations correctly.\n    \"\"\"\n    new_user = models.User(username=\"newuser\", email=\"new@example.com\")\n    uow.register_new(new_user)\n\n    existing_user = models.User(username=\"existinguser\", email=\"existing@example.com\")\n    uow.register_dirty(existing_user)\n\n    to_delete_user = models.User(username=\"deleteuser\", email=\"delete@example.com\")\n    uow.register_deleted(to_delete_user)\n\n    await uow.commit()\n\n    uow.mappers[models.User].insert.assert_awaited_once_with(new_user)\n    uow.mappers[models.User].update.assert_awaited_once_with(existing_user)\n    uow.mappers[models.User].delete.assert_awaited_once_with(to_delete_user)\n\n\n@pytest.mark.asyncio\nasync def test_register_uowmodel(uow):\n    user = models.User(username=\"testuser\", email=\"test@example.com\")\n    uow_model = uow.register_new(user)\n\n    assert id(user) in uow.new, \"Model should be registered in 'new'\"\n    assert id(user) not in uow.dirty, \"New model should not be in 'dirty'\"\n\n    # Changing a property of a new model should not mark it as dirty\n    uow_model.email = \"updated@example.com\"\n    assert id(user) in uow.new, \"Model should still be in 'new' after property change\"\n    assert id(user) not in uow.dirty, \"New model should not be marked as dirty when changed\"\n\n    # Simulate commit (clear the new dictionary)\n    uow.new.clear()\n    uow.dirty.clear()\n\n    # Now changing a property should mark it as dirty\n    uow_model.username = \"updateduser\"\n    assert id(user) in uow.dirty, \"Model should be marked as dirty after property change post-commit\"\n\n\n@pytest.mark.asyncio\nasync def test_delete_new_model(uow):\n    user = models.User(username=\"testuser\", email=\"test@example.com\")\n    uow_model = uow.register_new(user)\n\n    uow.register_deleted(uow_model)\n\n    assert id(user) not in uow.new, \"Deleted new model shouldn't remain in 'new'\"\n    assert id(user) not in uow.deleted, \"Deleted new model should not be in 'deleted'\"\n"}
{"type": "source_file", "path": "chat/__init__.py", "content": ""}
{"type": "source_file", "path": "chat_service/app/config.py", "content": "# /app/config.py\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass AppConfig(BaseSettings):\n    PROJECT_NAME: str = \"Chat API\"\n    PROJECT_VERSION: str = \"1.0.0\"\n    PROJECT_DESCRIPTION: str = \"A FastAPI-based Chat Application\"\n    API_V1_STR: str = \"/api/v1\"\n    SECRET_KEY: str\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    REFRESH_SECRET_KEY: str\n    REFRESH_TOKEN_EXPIRE_DAYS: int = 7\n    REDIS_HOST: str\n    REDIS_PORT: int\n    DATABASE_URL: str = \"sqlite+aiosqlite:///:memory:\"\n\n    model_config = SettingsConfigDict(env_file=\".env\", extra=\"allow\")\n\n"}
{"type": "source_file", "path": "chat/api_client.py", "content": "import json\nimport logging\nimport os\nimport queue\nimport threading\nimport time\nfrom datetime import datetime, timedelta\n\nimport pytz\nimport redis\nimport requests\n\n\nclass ApiResponse:\n    def __init__(self, success, data=None, status_code=None, error=None):\n        self.success = success\n        self.data = data\n        self.status_code = status_code\n        self.error = error\n\n\nclass ApiClient:\n    def __init__(self, base_url):\n        self.base_url = base_url\n        self.access_token = None\n        self.refresh_token = None\n        self.token_expiry = None\n        self.subscriptions = {}\n\n        # Configure logging\n        self.logger = logging.getLogger('ApiClient')\n        self.logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('[%(asctime)s] %(levelname)s:%(name)s: %(message)s')\n        handler.setFormatter(formatter)\n        if not self.logger.handlers:\n            self.logger.addHandler(handler)\n\n        REDIS_HOST = os.environ.get('REDIS_HOST', 'localhost')\n        REDIS_PORT = int(os.environ.get('REDIS_PORT', 6379))\n\n        # Initialize Redis client with error handling\n        try:\n            self.redis_client = redis.Redis(\n                host=REDIS_HOST,\n                port=REDIS_PORT,\n                db=0,\n                decode_responses=True,\n                socket_connect_timeout=5\n            )\n            self.redis_client.ping()  # Test the connection\n            self.pubsub = self.redis_client.pubsub()\n            self.message_queue = queue.Queue()\n            self.subscriptions = {}\n            self.pubsub_thread = threading.Thread(target=self._listen_to_pubsub, daemon=True)\n            self.pubsub_thread.start()\n            self.worker_thread = threading.Thread(target=self._process_messages, daemon=True)\n            self.worker_thread.start()\n            self.logger.info(f\"Successfully connected to Redis at {REDIS_HOST}:{REDIS_PORT}\")\n        except redis.ConnectionError as e:\n            self.logger.error(f\"Unable to connect to Redis at {REDIS_HOST}:{REDIS_PORT}.\\nERROR: {str(e)}\")\n            self.redis_client = None\n            self.pubsub = None\n\n    def _listen_to_pubsub(self):\n        \"\"\"\n        Listens to Redis pubsub messages and puts them into the message queue.\n        \"\"\"\n        while True:\n            try:\n                for message in self.pubsub.listen():\n                    if message['type'] == 'message':\n                        channel = message['channel']\n                        data = message['data']\n                        self.logger.info(f\"Received message from Redis channel '{channel}': {data}\")\n                        self.message_queue.put({'channel': channel, 'data': data})\n            except redis.ConnectionError as e:\n                self.logger.error(f\"Redis connection error: {str(e)}. Attempting to reconnect in 5 seconds...\")\n                time.sleep(5)  # Wait before reconnecting\n                self._reconnect_redis()\n            except Exception as e:\n                self.logger.error(f\"Unexpected error in pubsub listener: {str(e)}. Continuing...\")\n\n    def _process_messages(self):\n        \"\"\"\n        Processes messages from the message queue and invokes the appropriate callbacks.\n        \"\"\"\n        while True:\n            message = self.message_queue.get()\n            channel = message['channel']\n            data = message['data']\n            if channel in self.subscriptions:\n                callback = self.subscriptions[channel]\n                self.logger.info(f\"Processing message for channel '{channel}'\")\n                try:\n                    callback(data)\n                except Exception as e:\n                    self.logger.error(f\"Error in callback for channel '{channel}': {str(e)}\")\n\n    def _handle_response(self, response):\n        \"\"\"\n        Handles HTTP responses and returns an ApiResponse object.\n        \"\"\"\n        if 200 <= response.status_code < 300:\n            try:\n                data = response.json() if response.content else {}\n            except json.JSONDecodeError:\n                data = {}\n            return ApiResponse(True, data=data, status_code=response.status_code)\n        return ApiResponse(False, status_code=response.status_code, error=response.text)\n\n    def _refresh_token(self):\n        \"\"\"\n        Refreshes the access token using the refresh token.\n        \"\"\"\n        if not self.refresh_token:\n            self.logger.warning(\"No refresh token available.\")\n            return False\n\n        try:\n            response = requests.post(f\"{self.base_url}/auth/refresh\",\n                                     json={\"refresh_token\": self.refresh_token},\n                                     timeout=2.0)  # POST-request with timeout of 2s\n            api_response = self._handle_response(response)\n\n            if api_response.success:\n                self.access_token = api_response.data.get(\"access_token\")\n                self.refresh_token = api_response.data.get(\"refresh_token\")\n                expires_at = api_response.data.get(\"expires_at\")\n                if expires_at:\n                    self.token_expiry = datetime.fromisoformat(expires_at).replace(tzinfo=pytz.UTC)\n                self.logger.info(\"Token refreshed successfully.\")\n                return True\n            else:\n                self.logger.error(\"Failed to refresh token.\")\n                self.access_token = None\n                self.refresh_token = None\n                self.token_expiry = None\n                return False\n        except Exception as e:\n            self.logger.error(f\"Exception during token refresh: {str(e)}\")\n            return False\n\n    def _request(self, method, endpoint, auth_required=True, **kwargs):\n        \"\"\"\n        Makes an HTTP request to the specified endpoint with optional authentication.\n        \"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        headers = kwargs.get('headers', {})\n\n        if auth_required:\n            current_time = datetime.utcnow().replace(tzinfo=pytz.UTC)\n            if not self.access_token or (\n                    self.token_expiry and current_time >= self.token_expiry - timedelta(minutes=5)\n            ):\n                if not self._refresh_token():\n                    return ApiResponse(False, error=\"Failed to refresh token. Please log in again.\")\n\n            headers['Authorization'] = f\"Bearer {self.access_token}\"\n            kwargs['headers'] = headers\n\n        try:\n            response = requests.request(method, url, **kwargs)\n            api_response = self._handle_response(response)\n\n            if (\n                    not api_response.success\n                    and api_response.status_code == 401\n                    and \"Could not validate credentials\" in (api_response.error or \"\")\n            ):\n                self.logger.warning(\"Received 401 Unauthorized. Attempting to refresh token.\")\n                if self._refresh_token():\n                    headers['Authorization'] = f\"Bearer {self.access_token}\"\n                    kwargs['headers'] = headers\n                    response = requests.request(method, url, **kwargs)\n                    api_response = self._handle_response(response)\n\n            return api_response\n        except Exception as e:\n            self.logger.error(f\"HTTP request exception: {str(e)}\")\n            return ApiResponse(False, error=str(e))\n\n    def subscribe_to_channel(self, channel_name, callback):\n        \"\"\"\n        Subscribes to a Redis channel with a specified callback function.\n        \"\"\"\n        if not self.pubsub:\n            self.logger.error(\"Cannot subscribe to channel. Redis client is not connected.\")\n            return\n\n        if channel_name not in self.subscriptions:\n            self.subscriptions[channel_name] = callback\n            self.pubsub.subscribe(**{channel_name: self._handle_redis_message})\n            self.logger.info(f\"Subscribed to Redis channel '{channel_name}'\")\n        else:\n            self.logger.warning(f\"Already subscribed to Redis channel '{channel_name}'\")\n\n    def unsubscribe_from_channel(self, channel_name):\n        \"\"\"\n        Unsubscribes from a Redis channel.\n        \"\"\"\n        if not self.pubsub:\n            self.logger.error(\"Cannot unsubscribe from channel. Redis client is not connected.\")\n            return\n\n        if channel_name in self.subscriptions:\n            del self.subscriptions[channel_name]\n            self.pubsub.unsubscribe(channel_name)\n            self.logger.info(f\"Unsubscribed from Redis channel '{channel_name}'\")\n        else:\n            self.logger.warning(f\"Not subscribed to Redis channel '{channel_name}'\")\n\n    def _handle_redis_message(self, message):\n        \"\"\"\n        Handles incoming Redis messages and delegates them to the appropriate callback.\n        \"\"\"\n        if message['type'] == 'message':\n            channel = message['channel']\n            data = message['data']\n            if channel in self.subscriptions:\n                self.logger.info(f\"Handling message from channel '{channel}': {data}\")\n                try:\n                    self.subscriptions[channel](data)\n                except Exception as e:\n                    self.logger.error(f\"Error in callback for channel '{channel}': {str(e)}\")\n\n    def _reconnect_redis(self):\n        \"\"\"\n        Attempts to reconnect to Redis and resubscribe to channels.\n        \"\"\"\n        REDIS_HOST = os.environ.get('REDIS_HOST', 'localhost')\n        REDIS_PORT = int(os.environ.get('REDIS_PORT', 6379))\n        try:\n            self.redis_client = redis.Redis(\n                host=REDIS_HOST,\n                port=REDIS_PORT,\n                db=0,\n                decode_responses=True,\n                socket_connect_timeout=5\n            )\n            self.redis_client.ping()\n            self.pubsub = self.redis_client.pubsub()\n            # Resubscribe to existing channels\n            for channel in self.subscriptions.keys():\n                self.pubsub.subscribe(**{channel: self._handle_redis_message})\n                self.logger.info(f\"Resubscribed to Redis channel '{channel}'\")\n            self.logger.info(f\"Reconnected to Redis at {REDIS_HOST}:{REDIS_PORT}\")\n        except redis.ConnectionError as e:\n            self.logger.error(f\"Failed to reconnect to Redis: {str(e)}. Will retry in 5 seconds.\")\n            time.sleep(5)\n            self._reconnect_redis()\n\n    def close(self):\n        \"\"\"\n        Closes Redis pubsub and client connections gracefully.\n        \"\"\"\n        if self.pubsub:\n            self.pubsub.close()\n            self.logger.info(\"Closed Redis pubsub.\")\n        if self.redis_client:\n            self.redis_client.close()\n            self.logger.info(\"Closed Redis client.\")\n\n    def login(self, username, password):\n        \"\"\"\n        Logs in the user by sending credentials to the server.\n        \"\"\"\n        response = self._request(\"POST\", \"/auth/login\", auth_required=False,\n                                 data={\"username\": username, \"password\": password})\n        if response.success:\n            self.access_token = response.data.get(\"access_token\")\n            self.refresh_token = response.data.get(\"refresh_token\")\n            expires_at = response.data.get(\"expires_at\")\n            if expires_at:\n                self.token_expiry = datetime.fromisoformat(expires_at).replace(tzinfo=pytz.UTC)\n            self.logger.info(\"Logged in successfully.\")\n        else:\n            self.logger.error(f\"Login failed: {response.error}\")\n        return response\n\n    def register(self, username, email, password):\n        \"\"\"\n        Registers a new user with the provided credentials.\n        \"\"\"\n        response = self._request(\"POST\", \"/auth/register\", auth_required=False,\n                                 json={\"username\": username, \"email\": email, \"password\": password})\n        if response.success:\n            self.logger.info(f\"User '{username}' registered successfully.\")\n        else:\n            self.logger.error(f\"Registration failed for user '{username}': {response.error}\")\n        return response\n\n    def get_chats(self, skip=0, limit=100, name=None):\n        \"\"\"\n        Retrieves a list of chats with optional filtering.\n        \"\"\"\n        params = {\"skip\": skip, \"limit\": limit}\n        if name:\n            params[\"name\"] = name\n        return self._request(\"GET\", \"/chats/\", params=params)\n\n    def create_chat(self, chat_data):\n        \"\"\"\n        Creates a new chat with the provided data.\n        \"\"\"\n        response = self._request(\"POST\", \"/chats/\", json=chat_data)\n        if response.success:\n            self.logger.info(f\"Chat created successfully: {chat_data}\")\n        else:\n            self.logger.error(f\"Failed to create chat: {response.error}\")\n        return response\n\n    def get_chat(self, chat_id):\n        \"\"\"\n        Retrieves details of a specific chat by ID.\n        \"\"\"\n        return self._request(\"GET\", f\"/chats/{chat_id}\")\n\n    def update_chat(self, chat_id, chat_data):\n        \"\"\"\n        Updates a specific chat with the provided data.\n        \"\"\"\n        response = self._request(\"PUT\", f\"/chats/{chat_id}\", json=chat_data)\n        if response.success:\n            self.logger.info(f\"Chat '{chat_id}' updated successfully.\")\n        else:\n            self.logger.error(f\"Failed to update chat '{chat_id}': {response.error}\")\n        return response\n\n    def delete_chat(self, chat_id):\n        \"\"\"\n        Deletes a specific chat by ID.\n        \"\"\"\n        response = self._request(\"DELETE\", f\"/chats/{chat_id}\")\n        if response.success:\n            self.logger.info(f\"Chat '{chat_id}' deleted successfully.\")\n        else:\n            self.logger.error(f\"Failed to delete chat '{chat_id}': {response.error}\")\n        return response\n\n    def add_chat_member(self, chat_id: int, user_id: int):\n        \"\"\"\n        Adds a member to a specific chat.\n        \"\"\"\n        response = self._request(\"POST\", f\"/chats/{chat_id}/members\", json={\"user_id\": user_id})\n        if response.success:\n            self.logger.info(f\"User '{user_id}' added to chat '{chat_id}'.\")\n        else:\n            self.logger.error(f\"Failed to add user '{user_id}' to chat '{chat_id}': {response.error}\")\n        return response\n\n    def remove_chat_member(self, chat_id, user_id):\n        \"\"\"\n        Removes a member from a specific chat.\n        \"\"\"\n        response = self._request(\"DELETE\", f\"/chats/{chat_id}/members/{user_id}\")\n        if response.success:\n            self.logger.info(f\"User '{user_id}' removed from chat '{chat_id}'.\")\n        else:\n            self.logger.error(f\"Failed to remove user '{user_id}' from chat '{chat_id}': {response.error}\")\n        return response\n\n    def get_messages(self, chat_id, skip=0, limit=100, content=None):\n        \"\"\"\n        Retrieves messages from a specific chat with optional filtering.\n        \"\"\"\n        params = {\"skip\": skip, \"limit\": limit}\n        if content:\n            params[\"content\"] = content\n        return self._request(\"GET\", f\"/messages/{chat_id}\", params=params)\n\n    def send_message(self, chat_id, content):\n        \"\"\"\n        Sends a new message to a specific chat.\n        \"\"\"\n        response = self._request(\"POST\", \"/messages/\", json={\"chat_id\": chat_id, \"content\": content})\n        if response.success:\n            self.logger.info(f\"Message sent to chat '{chat_id}': {content}\")\n        else:\n            self.logger.error(f\"Failed to send message to chat '{chat_id}': {response.error}\")\n        return response\n\n    def update_message(self, message_id, message_data):\n        \"\"\"\n        Updates a specific message by ID.\n        \"\"\"\n        response = self._request(\"PUT\", f\"/messages/{message_id}\", json=message_data)\n        if response.success:\n            self.logger.info(f\"Message '{message_id}' updated successfully.\")\n        else:\n            self.logger.error(f\"Failed to update message '{message_id}': {response.error}\")\n        return response\n\n    def delete_message(self, message_id):\n        \"\"\"\n        Deletes a specific message by ID.\n        \"\"\"\n        response = self._request(\"DELETE\", f\"/messages/{message_id}\")\n        if response.success:\n            self.logger.info(f\"Message '{message_id}' deleted successfully.\")\n        else:\n            self.logger.error(f\"Failed to delete message '{message_id}': {response.error}\")\n        return response\n\n    def get_current_user(self):\n        \"\"\"\n        Retrieves the currently authenticated user's information.\n        \"\"\"\n        return self._request(\"GET\", \"/users/me\")\n\n    def update_user(self, user_data):\n        \"\"\"\n        Updates the current user's information.\n        \"\"\"\n        response = self._request(\"PUT\", \"/users/me\", json=user_data)\n        if response.success:\n            self.logger.info(\"User information updated successfully.\")\n        else:\n            self.logger.error(f\"Failed to update user information: {response.error}\")\n        return response\n\n    def delete_user(self):\n        \"\"\"\n        Deletes the currently authenticated user's account.\n        \"\"\"\n        response = self._request(\"DELETE\", \"/users/me\")\n        if response.success:\n            self.logger.info(\"User account deleted successfully.\")\n        else:\n            self.logger.error(f\"Failed to delete user account: {response.error}\")\n        return response\n\n    def get_users(self, skip=0, limit=100, username=None):\n        \"\"\"\n        Retrieves a list of users with optional filtering.\n        \"\"\"\n        params = {\"skip\": skip, \"limit\": limit}\n        if username:\n            params[\"username\"] = username\n        return self._request(\"GET\", \"/users/\", params=params)\n\n    def search_users(self, query: str):\n        \"\"\"\n        Searches for users based on a query string.\n        \"\"\"\n        return self._request(\"GET\", \"/users/search\", params={\"query\": query})\n\n    def start_chat(self, other_user_id: int):\n        \"\"\"\n        Initiates a new chat with another user.\n        \"\"\"\n        response = self._request(\"POST\", \"/chats/start\", json={\"other_user_id\": other_user_id})\n        if response.success:\n            self.logger.info(f\"Started chat with user '{other_user_id}'.\")\n        else:\n            self.logger.error(f\"Failed to start chat with user '{other_user_id}': {response.error}\")\n        return response\n\n    def logout(self):\n        \"\"\"\n        Logs out the current user by invalidating the access token.\n        \"\"\"\n        response = self._request(\"POST\", \"/auth/logout\")\n        if response.success:\n            self.access_token = None\n            self.refresh_token = None\n            self.token_expiry = None\n            self.logger.info(\"Logged out successfully.\")\n        else:\n            self.logger.error(f\"Logout failed: {response.error}\")\n        return response\n\n    def get_unread_messages_count(self, chat_id: int):\n        \"\"\"\n        Retrieves the count of unread messages for a specific chat.\n        \"\"\"\n        return self._request(\"GET\", f\"/chats/{chat_id}/unread_count\")\n\n    def update_message_status(self, message_id: int, status_update: dict):\n        \"\"\"\n        Updates the status of a specific message.\n        \"\"\"\n        response = self._request(\"PUT\", f\"/messages/{message_id}/status\", json=status_update)\n        if response.success:\n            self.logger.info(f\"Updated status for message '{message_id}': {status_update}\")\n        else:\n            self.logger.error(f\"Failed to update status for message '{message_id}': {response.error}\")\n        return response\n"}
{"type": "source_file", "path": "chat/app.py", "content": "import json\nimport os\n\nimport flet as ft\n\nfrom .api_client import ApiClient\nfrom .chat_list_screen import ChatListScreen\nfrom .chat_screen import ChatScreen\nfrom .login_screen import LoginScreen\nfrom .register_screen import RegisterScreen\nfrom .user_profile_screen import UserProfileScreen\n\n\nclass ChatApp:\n    def __init__(self, page: ft.Page):\n        self.page = page\n        self.page.title = \"Chat App\"\n        self.page.theme_mode = ft.ThemeMode.LIGHT\n\n        api_part: str = os.environ.get(\"API_V1_STR\", \"/api/v1\")\n        self.api_client = ApiClient(\"http://localhost:8000/\" + api_part)\n\n        self.container = ft.Container(expand=True)\n        self.page.add(self.container)\n\n        self.show_login()\n\n    def switch_screen(self, screen):\n        self.container.content = screen\n        self.page.update()\n\n    def show_login(self):\n        self.switch_screen(LoginScreen(self))\n\n    def show_register(self):\n        self.switch_screen(RegisterScreen(self))\n\n    def show_chat_list(self):\n        self.switch_screen(ChatListScreen(self))\n\n    def show_chat(self, chat_id):\n        self.switch_screen(ChatScreen(self, chat_id))\n\n    def show_user_profile(self):\n        self.switch_screen(UserProfileScreen(self))\n\n    # all funcs below are for processing str or dict with error message(s) inside\n    def show_error_dialog(self, title, error):\n        description = self._extract_error_message(error)\n        self._display_error_dialog(title, description)\n\n    def _extract_error_message(self, error) -> str:\n        # Attempt to parse error if it's a string in JSON format\n        if isinstance(error, str):\n            error = self._parse_json_string(error)\n\n        # Extract error message\n        if isinstance(error, dict) and \"detail\" in error:\n            return self._format_error_details(error[\"detail\"])\n\n        return str(error)\n\n    def _parse_json_string(self, error_str: str) -> dict | str:\n        try:\n            return json.loads(error_str)\n        except json.JSONDecodeError:\n            return error_str\n\n    def _format_error_details(self, detail: str | list) -> str:\n        if isinstance(detail, list):\n            messages = []\n            for item in detail:\n                field = self._get_field_name(item)\n                message = item.get(\"msg\", str(item))\n                messages.append(f\"- {field}: {message}\")\n            return \"\\n\".join(messages)\n        return detail\n\n    def _get_field_name(self, item: dict) -> str:\n        # Extract the field name, ignoring the \"body\" prefix if present\n        if \"loc\" in item and len(item[\"loc\"]) > 1:\n            return item[\"loc\"][-1]  # Take the last part of the location list\n        return item.get(\"loc\", [\"Unknown field\"])[-1]\n\n    def _display_error_dialog(self, title, description):\n        def close_dlg(e):\n            dlg.open = False\n            self.page.update()\n\n        dlg = ft.AlertDialog(\n            title=ft.Text(title),\n            content=ft.Text(description),\n            actions=[ft.TextButton(\"OK\", on_click=close_dlg)],\n            actions_alignment=ft.MainAxisAlignment.END,\n        )\n\n        self.page.dialog = dlg\n        dlg.open = True\n        self.page.update()"}
{"type": "source_file", "path": "chat_service/app/api/messages.py", "content": "# app/api/messages.py\nfrom typing import List, Optional\n\nfrom app.api.dependencies import get_message_interactor, get_current_active_user, get_event_dispatcher, \\\n    get_chat_interactor\nfrom app.domain.events import MessageCreated, MessageDeleted, MessageUpdated, MessageStatusUpdated, UnreadCountUpdated\nfrom app.infrastructure import schemas\nfrom app.infrastructure.event_dispatcher import EventDispatcher\nfrom app.interactors.message_interactor import MessageInteractor\nfrom fastapi import APIRouter, Depends, HTTPException, Query\n\nrouter = APIRouter()\n\n\n@router.post(\"/\", response_model=schemas.Message)\nasync def create_message(\n        message: schemas.MessageCreate,\n        message_interactor: MessageInteractor = Depends(get_message_interactor),\n        chat_interactor: MessageInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user),\n        event_dispatcher: EventDispatcher = Depends(get_event_dispatcher)\n):\n    try:\n        db_message = await message_interactor.create_message(message, current_user.id)\n    except ValueError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n\n    await event_dispatcher.dispatch(MessageCreated(\n        message_id=db_message.id,\n        chat_id=db_message.chat_id,\n        user_id=db_message.user_id,\n        content=db_message.content,\n        created_at=db_message.created_at,\n        user={\n            \"id\": current_user.id,\n            \"username\": current_user.username\n        },\n        is_deleted=db_message.is_deleted\n    ))\n\n    unread_counts = await chat_interactor.get_unread_counts_for_chat_members(db_message.chat_id, current_user.id)\n    for user_id, unread_count in unread_counts.items():\n        await event_dispatcher.dispatch(UnreadCountUpdated(\n            chat_id=db_message.chat_id,\n            user_id=user_id,\n            unread_count=unread_count\n        ))\n\n    return db_message\n\n\n@router.get(\"/{chat_id}\", response_model=List[schemas.Message])\nasync def read_messages(\n        chat_id: int,\n        skip: int = 0,\n        limit: int = 100,\n        content: Optional[str] = Query(None, description=\"Filter messages by content\"),\n        message_interactor: MessageInteractor = Depends(get_message_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    messages = await message_interactor.get_messages(chat_id, current_user.id, skip, limit, content)\n    return messages\n\n\n@router.put(\"/{message_id}\", response_model=schemas.Message)\nasync def update_message(\n        message_id: int,\n        message_update: schemas.MessageUpdate,\n        message_interactor: MessageInteractor = Depends(get_message_interactor),\n        current_user: schemas.User = Depends(get_current_active_user),\n        event_dispatcher: EventDispatcher = Depends(get_event_dispatcher)\n):\n    updated_message = await message_interactor.update_message(message_id, message_update, current_user.id)\n    if not updated_message:\n        raise HTTPException(status_code=404, detail=\"Message not found or you're not authorized to update it\")\n\n    await event_dispatcher.dispatch(MessageUpdated(\n        message_id=updated_message.id,\n        chat_id=updated_message.chat_id,\n        user_id=updated_message.user_id,\n        content=updated_message.content,\n        created_at=updated_message.created_at,\n        updated_at=updated_message.updated_at,\n        user={\n            \"id\": current_user.id,\n            \"username\": current_user.username\n        },\n        is_deleted=updated_message.is_deleted\n    ))\n\n    return updated_message\n\n\n@router.delete(\"/{message_id}\", status_code=200, response_model=schemas.Message)\nasync def delete_message(\n        message_id: int,\n        message_interactor: MessageInteractor = Depends(get_message_interactor),\n        current_user: schemas.User = Depends(get_current_active_user),\n        event_dispatcher: EventDispatcher = Depends(get_event_dispatcher)\n):\n    deleted_message = await message_interactor.delete_message(message_id, current_user.id)\n    if not deleted_message:\n        raise HTTPException(status_code=404, detail=\"Message not found or you're not authorized to delete it\")\n\n    await event_dispatcher.dispatch(MessageDeleted(\n        message_id=deleted_message.id,\n        chat_id=deleted_message.chat_id,\n        user_id=deleted_message.user_id,\n        created_at=deleted_message.created_at,\n        content=deleted_message.content,\n        updated_at=deleted_message.updated_at,\n        user={\n            \"id\": current_user.id,\n            \"username\": current_user.username\n        },\n        is_deleted=deleted_message.is_deleted\n    ))\n\n    return deleted_message\n\n\n@router.put(\"/{message_id}/status\", response_model=schemas.Message)\nasync def update_message_status(\n        message_id: int,\n        status_update: schemas.MessageStatusUpdate,\n        message_interactor: MessageInteractor = Depends(get_message_interactor),\n        chat_interactor: MessageInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user),\n        event_dispatcher: EventDispatcher = Depends(get_event_dispatcher)\n):\n    updated_message = await message_interactor.update_message_status(message_id, current_user.id, status_update)\n    if not updated_message:\n        raise HTTPException(status_code=404, detail=\"Message not found\")\n\n    message_status = next(\n        (status for status in updated_message.statuses if status.user_id == current_user.id),\n        None\n    )\n    if not message_status:\n        raise HTTPException(status_code=404, detail=\"MessageStatus not found\")\n\n    await event_dispatcher.dispatch(MessageStatusUpdated(\n        message_id=updated_message.id,\n        chat_id=updated_message.chat_id,\n        user_id=current_user.id,\n        is_read=message_status.is_read,\n        read_at=message_status.read_at\n    ))\n\n    unread_count = await chat_interactor.get_unread_messages_count(updated_message.chat_id, current_user.id)\n\n    await event_dispatcher.dispatch(UnreadCountUpdated(\n        chat_id=updated_message.chat_id,\n        user_id=current_user.id,\n        unread_count=unread_count\n    ))\n\n    return updated_message\n"}
{"type": "source_file", "path": "chat/register_screen.py", "content": "import logging\n\nimport flet as ft\n\n\nclass RegisterScreen(ft.Column):\n    def __init__(self, chat_app):\n        super().__init__()\n        self.isolated = True\n        self.chat_app = chat_app\n\n        # Configure logging\n        self.logger = logging.getLogger('RegisterScreen')\n        self.logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('[%(asctime)s] %(levelname)s:%(name)s: %(message)s')\n        handler.setFormatter(formatter)\n        if not self.logger.handlers:\n            self.logger.addHandler(handler)\n\n        # GUI components\n        self.username = ft.TextField(label=\"Username\")\n        self.email = ft.TextField(label=\"Email\")\n        self.password = ft.TextField(label=\"Password\", password=True, can_reveal_password=True)\n\n        self.logger.info(\"RegisterScreen initialized\")\n\n    def build(self):\n        \"\"\"\n        Builds the registration screen UI.\n        \"\"\"\n        self.logger.info(\"Building registration screen UI\")\n        return ft.Container(\n            border_radius=10,\n            padding=30,\n            content=ft.Column(\n                [\n                    ft.Text(\"Register\", size=30),\n                    self.username,\n                    self.email,\n                    self.password,\n                    ft.ElevatedButton(\"Register\", on_click=self.register),\n                    ft.TextButton(\"Already have an account? Login\", on_click=self.show_login)\n                ],\n                horizontal_alignment=ft.CrossAxisAlignment.CENTER,\n                spacing=20\n            )\n        )\n\n    def register(self, e):\n        \"\"\"\n        Handles the registration process when the register button is clicked.\n        \"\"\"\n        self.logger.info(f\"Attempting registration for user: {self.username.value}\")\n        response = self.chat_app.api_client.register(self.username.value, self.email.value, self.password.value)\n        if response.success:\n            self.logger.info(f\"Registration successful for user: {self.username.value}\")\n            self.show_success_dialog()\n        else:\n            error_message = f\"Registration failed (Status {response.status_code})\"\n            self.logger.error(f\"Registration failed for user {self.username.value}: {error_message}\\n{response.error}\")\n            self.chat_app.show_error_dialog(\"Registration Error\", response.error)\n\n    def show_success_dialog(self):\n        \"\"\"\n        Displays a success dialog after successful registration.\n        \"\"\"\n        self.logger.info(\"Showing registration success dialog\")\n\n        def close_dlg(e):\n            dlg.open = False\n            self.chat_app.page.update()\n            self.chat_app.show_login()\n\n        dlg = ft.AlertDialog(\n            title=ft.Text(\"Registration Successful\"),\n            content=ft.Text(\"Your account has been created successfully. Please log in.\"),\n            actions=[\n                ft.ElevatedButton(\"Go to Login\", on_click=close_dlg)\n            ],\n            actions_alignment=ft.MainAxisAlignment.CENTER,\n        )\n\n        self.chat_app.page.dialog = dlg\n        dlg.open = True\n        self.chat_app.page.update()\n\n    def show_login(self, e):\n        \"\"\"\n        Navigates to the login screen.\n        \"\"\"\n        self.logger.info(\"Navigating to login screen\")\n        self.chat_app.show_login()\n\n    def did_mount(self):\n        \"\"\"\n        Called when the control is added to the page.\n        \"\"\"\n        self.logger.info(\"RegisterScreen mounted\")\n\n    def will_unmount(self):\n        \"\"\"\n        Called when the control is about to be removed from the page.\n        \"\"\"\n        self.logger.info(\"RegisterScreen will unmount\")\n"}
{"type": "source_file", "path": "chat/login_screen.py", "content": "import logging\nimport flet as ft\n\nclass LoginScreen(ft.Column):\n    def __init__(self, chat_app):\n        super().__init__()\n        self.isolated = True\n        self.chat_app = chat_app\n\n        # Configure logging\n        self.logger = logging.getLogger('LoginScreen')\n        self.logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('[%(asctime)s] %(levelname)s:%(name)s: %(message)s')\n        handler.setFormatter(formatter)\n        if not self.logger.handlers:\n            self.logger.addHandler(handler)\n\n    def build(self):\n        \"\"\"\n        Builds the login screen UI.\n        \"\"\"\n        self.logger.info(\"Building login screen UI\")\n        self.username = ft.TextField(label=\"Username\")\n        self.password = ft.TextField(label=\"Password\", password=True, can_reveal_password=True)\n\n        return ft.Container(\n            border_radius=10,\n            padding=30,\n            content=ft.Column(\n                [\n                    ft.Text(\"Login\", size=30),\n                    self.username,\n                    self.password,\n                    ft.ElevatedButton(\"Login\", on_click=self.login),\n                    ft.TextButton(\"Don't have an account? Register\", on_click=self.show_register)\n                ],\n                horizontal_alignment=ft.CrossAxisAlignment.CENTER,\n                spacing=20\n            )\n        )\n\n    def login(self, e):\n        \"\"\"\n        Handles the login process when the login button is clicked.\n        \"\"\"\n        self.logger.info(f\"Attempting login for user: {self.username.value}\")\n        response = self.chat_app.api_client.login(self.username.value, self.password.value)\n        if response.success:\n            self.logger.info(f\"Login successful for user: {self.username.value}\")\n            self.chat_app.show_chat_list()\n        else:\n            error_message = f\"Login failed (Status {response.status_code})\"\n            self.logger.error(f\"Login failed for user {self.username.value}: {error_message}\\n{response.error}\")\n            self.chat_app.show_error_dialog(\"Login Error\", response.error)\n\n    def show_register(self, e):\n        \"\"\"\n        Navigates to the registration screen.\n        \"\"\"\n        self.logger.info(\"Navigating to registration screen\")\n        self.chat_app.show_register()\n\n    def did_mount(self):\n        \"\"\"\n        Called when the control is added to the page.\n        \"\"\"\n        self.logger.info(\"LoginScreen mounted\")\n\n    def will_unmount(self):\n        \"\"\"\n        Called when the control is about to be removed from the page.\n        \"\"\"\n        self.logger.info(\"LoginScreen will unmount\")"}
{"type": "source_file", "path": "chat_service/app/api/users.py", "content": "# app/api/users.py\nfrom typing import List, Optional\n\nfrom app.api.dependencies import get_user_interactor, get_current_active_user\nfrom app.infrastructure import schemas\nfrom app.interactors.user_interactor import UserInteractor\nfrom fastapi import APIRouter, Depends, HTTPException, Query\n\nrouter = APIRouter()\n\n\n@router.get(\"/\", response_model=List[schemas.User])\nasync def read_users(\n        skip: int = 0,\n        limit: int = 100,\n        username: Optional[str] = Query(None, description=\"Filter users by username\"),\n        user_interactor: UserInteractor = Depends(get_user_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    users = await user_interactor.get_users(skip=skip, limit=limit, username=username)\n    return users\n\n\n@router.get(\"/me\", response_model=schemas.User)\nasync def read_users_me(current_user: schemas.User = Depends(get_current_active_user)):\n    return current_user\n\n\n@router.put(\"/me\", response_model=schemas.User)\nasync def update_user(\n        user_update: schemas.UserUpdate,\n        user_interactor: UserInteractor = Depends(get_user_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    updated_user = await user_interactor.update_user(current_user.id, user_update)\n    if not updated_user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return updated_user\n\n\n@router.delete(\"/me\", status_code=204)\nasync def delete_user(\n        user_interactor: UserInteractor = Depends(get_user_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    deleted = await user_interactor.delete_user(current_user.id)\n    if not deleted:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\"message\": \"User deleted successfully\"}\n\n\n@router.get(\"/search\", response_model=List[schemas.UserBasic])\nasync def search_users(\n        query: str,\n        user_interactor: UserInteractor = Depends(get_user_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    users = await user_interactor.search_users(query, current_user.id)\n    return users\n"}
{"type": "source_file", "path": "chat_service/app/domain/events.py", "content": "# app/domain/events.py\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Event(BaseModel):\n    pass\n\n\nclass UserInfo(BaseModel):\n    id: int\n    username: str\n\n\nclass MessageEvent(Event):\n    message_id: int\n    chat_id: int\n    user_id: int\n    content: str\n    created_at: datetime\n    user: UserInfo\n    is_deleted: bool\n\n\nclass MessageCreated(MessageEvent):\n    pass\n\n\nclass MessageUpdated(MessageEvent):\n    updated_at: datetime\n\n\nclass MessageDeleted(MessageEvent):\n    updated_at: Optional[datetime] = None\n\n\nclass MessageStatusUpdated(Event):\n    message_id: int\n    chat_id: int\n    user_id: int\n    is_read: bool\n    read_at: Optional[datetime]\n\n\nclass UnreadCountUpdated(Event):\n    chat_id: int\n    user_id: int\n    unread_count: int\n"}
{"type": "source_file", "path": "chat/user_profile_screen.py", "content": "import logging\n\nimport flet as ft\n\n\nclass UserProfileScreen(ft.Column):\n    def __init__(self, chat_app):\n        super().__init__()\n        self.isolated = True\n        self.chat_app = chat_app\n\n        # Configure logging\n        self.logger = logging.getLogger('UserProfileScreen')\n        self.logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('[%(asctime)s] %(levelname)s:%(name)s: %(message)s')\n        handler.setFormatter(formatter)\n        if not self.logger.handlers:\n            self.logger.addHandler(handler)\n\n        self.logger.info(\"UserProfileScreen initialized\")\n\n    def build(self):\n        \"\"\"\n        Builds the user profile screen UI.\n        \"\"\"\n        self.logger.info(\"Building user profile screen UI\")\n        response = self.chat_app.api_client.get_current_user()\n        if response.success:\n            self.user_data = response.data\n            self.username = ft.TextField(label=\"Username\", value=self.user_data['username'])\n            self.email = ft.TextField(label=\"Email\", value=self.user_data['email'])\n            self.password = ft.TextField(label=\"New Password\", password=True, can_reveal_password=True)\n\n            return ft.Column(\n                [\n                    ft.Row(\n                        [\n                            ft.IconButton(\n                                icon=ft.icons.ARROW_BACK,\n                                on_click=self.go_back,\n                                tooltip=\"Back to Chats\"\n                            ),\n                            ft.Container(\n                                content=ft.Text(\"User Profile\", style=ft.TextThemeStyle.HEADLINE_MEDIUM),\n                                expand=True,\n                                alignment=ft.alignment.center\n                            ),\n                            ft.Container(width=48),  # This container balances the width of the IconButton\n                        ],\n                        alignment=ft.MainAxisAlignment.SPACE_BETWEEN\n                    ),\n                    self.username,\n                    self.email,\n                    self.password,\n                    ft.ElevatedButton(\"Save Changes\", on_click=self.save_changes),\n                    ft.ElevatedButton(\"Logout\", on_click=self.logout),\n                    ft.ElevatedButton(\"Delete Account\", on_click=self.delete_account, color=ft.colors.RED_400),\n                ],\n                spacing=20,\n                horizontal_alignment=ft.CrossAxisAlignment.CENTER,\n                expand=True,\n            )\n        else:\n            self.logger.error(f\"Failed to load user profile: {response.error}\")\n            self.chat_app.show_error_dialog(\"Error Loading Profile\", response.error)\n            return ft.Text(\"Failed to load profile\")\n\n    def go_back(self, e):\n        \"\"\"\n        Navigates back to the chat list screen.\n        \"\"\"\n        self.logger.info(\"Navigating back to chat list\")\n        self.chat_app.show_chat_list()\n\n    def save_changes(self, e):\n        \"\"\"\n        Saves the changes made to the user profile.\n        \"\"\"\n        self.logger.info(\"Attempting to save profile changes\")\n        user_data = {\n            \"username\": self.username.value,\n            \"email\": self.email.value,\n        }\n        if self.password.value:\n            user_data[\"password\"] = self.password.value\n\n        response = self.chat_app.api_client.update_user(user_data)\n        if response.success:\n            self.logger.info(\"Profile updated successfully\")\n            dialog = ft.AlertDialog(\n                title=ft.Text(\"Profile Updated\"),\n                content=ft.Text(\n                    \"Your profile has been updated successfully. You need to log in again for the changes to take effect.\"),\n                actions=[\n                    ft.TextButton(\"Re-login\", on_click=self.relogin),\n                ],\n            )\n            self.page.dialog = dialog\n            dialog.open = True\n            self.page.update()\n        else:\n            self.logger.error(f\"Failed to update profile: {response.error}\")\n            self.chat_app.show_error_dialog(\"Error Updating Profile\", response.error)\n\n    def relogin(self, e):\n        \"\"\"\n        Handles the re-login process after profile update.\n        \"\"\"\n        self.logger.info(\"Initiating re-login process\")\n        if self.page.dialog:\n            self.page.dialog.open = False\n            self.page.update()\n\n        self.chat_app.api_client.token = None\n        self.chat_app.show_login()\n\n    def logout(self, e):\n        \"\"\"\n        Handles the logout process.\n        \"\"\"\n        self.logger.info(\"Attempting to log out\")\n        response = self.chat_app.api_client.logout()\n        if response.success:\n            self.logger.info(\"Logout successful\")\n            self.chat_app.api_client.access_token = None\n            self.chat_app.api_client.refresh_token = None\n            self.chat_app.api_client.token_expiry = None\n            self.chat_app.show_login()\n        else:\n            self.logger.error(f\"Failed to logout: {response.error}\")\n            self.chat_app.show_error_dialog(\"Error Logging Out\", response.error)\n\n    def delete_account(self, e):\n        \"\"\"\n        Initiates the account deletion process.\n        \"\"\"\n        self.logger.info(\"Initiating account deletion process\")\n\n        def confirm_delete(e):\n            self.logger.info(\"Account deletion confirmed\")\n            response = self.chat_app.api_client.delete_user()\n            if response.success:\n                self.logger.info(\"Account deleted successfully\")\n                self.chat_app.api_client.token = None\n                self.chat_app.show_login()\n            else:\n                self.logger.error(f\"Failed to delete account: {response.error}\")\n                self.chat_app.show_error_dialog(\"Error Deleting Account\", response.error)\n            dialog.open = False\n            self.page.update()\n\n        dialog = ft.AlertDialog(\n            title=ft.Text(\"Delete Account\"),\n            content=ft.Text(\"Are you sure you want to delete your account? This action cannot be undone.\"),\n            actions=[\n                ft.TextButton(\"Cancel\", on_click=lambda _: self.close_dialog(dialog)),\n                ft.TextButton(\"Delete\", on_click=confirm_delete),\n            ],\n        )\n        self.page.dialog = dialog\n        dialog.open = True\n        self.page.update()\n\n    def close_dialog(self, dialog):\n        \"\"\"\n        Closes the current dialog.\n        \"\"\"\n        self.logger.info(\"Closing dialog\")\n        dialog.open = False\n        self.page.update()\n\n    def did_mount(self):\n        \"\"\"\n        Called when the control is added to the page.\n        \"\"\"\n        self.logger.info(\"UserProfileScreen mounted\")\n\n    def will_unmount(self):\n        \"\"\"\n        Called when the control is about to be removed from the page.\n        \"\"\"\n        self.logger.info(\"UserProfileScreen will unmount\")\n"}
{"type": "source_file", "path": "chat_service/app/gateways/__init__.py", "content": ""}
{"type": "source_file", "path": "chat_service/app/__init__.py", "content": ""}
{"type": "source_file", "path": "chat_service/app/api/dependencies.py", "content": "# app/api/dependencies.py\nfrom app.config import AppConfig\nfrom app.gateways.chat_gateway import ChatGateway\nfrom app.gateways.message_gateway import MessageGateway\nfrom app.gateways.token_gateway import TokenGateway\nfrom app.gateways.user_gateway import UserGateway\nfrom app.infrastructure import schemas\nfrom app.infrastructure.event_dispatcher import EventDispatcher\nfrom app.infrastructure.security import SecurityService\nfrom app.infrastructure.uow import UnitOfWork\nfrom app.interactors.chat_interactor import ChatInteractor\nfrom app.interactors.message_interactor import MessageInteractor\nfrom app.interactors.token_interactor import TokenInteractor\nfrom app.interactors.user_interactor import UserInteractor\nfrom fastapi import Depends, HTTPException, status, Request\nfrom fastapi.security import OAuth2PasswordBearer\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n\ndef get_config(request: Request) -> AppConfig:\n    return request.app.state.config\n\n\ndef get_security_service(request: Request) -> SecurityService:\n    return request.app.state.security_service\n\n\ndef get_event_dispatcher(request: Request) -> EventDispatcher:\n    return request.app.state.event_dispatcher\n\n\nasync def get_session(request: Request) -> AsyncSession:\n    async with request.app.state.database.session() as session:\n        try:\n            yield session\n            await session.commit()  # Commit the transaction\n        except Exception:\n            await session.rollback()  # Rollback in case of error\n            raise\n\n\nasync def get_uow() -> UnitOfWork:\n    return UnitOfWork()\n\n\nasync def get_user_gateway(session: AsyncSession = Depends(get_session),\n                           uow: UnitOfWork = Depends(get_uow)):\n    return UserGateway(session, uow)\n\n\nasync def get_chat_gateway(session: AsyncSession = Depends(get_session), uow: UnitOfWork = Depends(get_uow)):\n    return ChatGateway(session, uow)\n\n\nasync def get_message_gateway(session: AsyncSession = Depends(get_session), uow: UnitOfWork = Depends(get_uow)):\n    return MessageGateway(session, uow)\n\n\nasync def get_token_gateway(session: AsyncSession = Depends(get_session), uow: UnitOfWork = Depends(get_uow)):\n    return TokenGateway(session, uow)\n\n\nasync def get_user_interactor(\n        security_service: SecurityService = Depends(get_security_service),\n        user_gateway: UserGateway = Depends(get_user_gateway)\n):\n    return UserInteractor(security_service, user_gateway)\n\n\nasync def get_chat_interactor(\n        chat_gateway: ChatGateway = Depends(get_chat_gateway),\n        user_gateway: UserGateway = Depends(get_user_gateway)\n):\n    return ChatInteractor(chat_gateway, user_gateway)\n\n\nasync def get_message_interactor(\n        message_gateway: MessageGateway = Depends(get_message_gateway)\n):\n    return MessageInteractor(message_gateway)\n\n\nasync def get_token_interactor(\n        token_gateway: TokenGateway = Depends(get_token_gateway)\n):\n    return TokenInteractor(token_gateway)\n\n\nasync def get_current_user(\n        token: str = Depends(oauth2_scheme),\n        security_service: SecurityService = Depends(get_security_service),\n        user_gateway: UserGateway = Depends(get_user_gateway),\n        token_gateway: TokenGateway = Depends(get_token_gateway)\n) -> schemas.User:\n    username = security_service.decode_access_token(token)\n    if username is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Could not validate credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    user_model = await user_gateway.get_by_username(username)\n    valid_token = await token_gateway.get_by_access_token(token)\n    if user_model is None or valid_token is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or expired token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    if not user_model._model.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Inactive user\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    return schemas.User.model_validate(user_model._model)\n\n\nasync def get_current_active_user(\n        current_user: schemas.User = Depends(get_current_user)\n) -> schemas.User:\n    if not current_user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n"}
{"type": "source_file", "path": "chat_service/app/domain/__init__.py", "content": ""}
{"type": "source_file", "path": "chat_service/app/gateways/chat_gateway.py", "content": "# app/infrastructure/chat_gateway.py\nfrom typing import List, Optional, Dict\n\nfrom app.gateways.interfaces import IChatGateway\nfrom app.infrastructure import models\nfrom app.infrastructure import schemas\nfrom app.infrastructure.data_mappers import ChatMapper\nfrom app.infrastructure.uow import UnitOfWork, UoWModel\nfrom sqlalchemy import select, func\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import selectinload\n\n\nclass ChatGateway(IChatGateway):\n    def __init__(self, session: AsyncSession, uow: UnitOfWork):\n        self.session = session\n        self.uow = uow\n        uow.mappers[models.Chat] = ChatMapper(session)\n\n    async def get_chat(self, chat_id: int, user_id: int) -> Optional[UoWModel]:\n        stmt = select(models.Chat).filter(models.Chat.id == chat_id, models.Chat.members.any(id=user_id))\n        result = await self.session.execute(stmt)\n        chat = result.scalar_one_or_none()\n        return UoWModel(chat, self.uow) if chat else None\n\n    async def get_all(self, user_id: int, skip: int = 0, limit: int = 100, name: Optional[str] = None) -> List[\n        UoWModel]:\n        stmt = select(models.Chat).filter(models.Chat.members.any(id=user_id))\n        if name:\n            stmt = stmt.filter(models.Chat.name.ilike(f\"%{name}%\"))\n        stmt = stmt.offset(skip).limit(limit)\n        result = await self.session.execute(stmt)\n        chats = result.scalars().all()\n        return [UoWModel(chat, self.uow) for chat in chats]\n\n    async def create_chat(self, chat: schemas.ChatCreate, user_id: int) -> UoWModel:\n        db_chat = models.Chat(name=chat.name)\n        stmt = select(models.User).filter(models.User.id.in_(chat.member_ids + [user_id]))\n        result = await self.session.execute(stmt)\n        members = result.scalars().all()\n        db_chat.members = members\n        uow_chat = self.uow.register_new(db_chat)\n        await self.uow.commit()\n        return uow_chat\n\n    async def add_member(self, chat_id: int, user_id: int, current_user_id: int) -> Optional[UoWModel]:\n        chat = await self.get_chat(chat_id, current_user_id)\n        if not chat:\n            return None\n        stmt = select(models.User).filter(models.User.id == user_id)\n        result = await self.session.execute(stmt)\n        user = result.scalar_one_or_none()\n        if user:\n            chat._model.members.append(user)\n            self.uow.register_dirty(chat._model)\n            await self.uow.commit()\n        return chat\n\n    async def delete_chat(self, chat_id: int, user_id: int) -> None:\n        chat = await self.get_chat(chat_id, user_id)\n        if chat:\n            self.uow.register_deleted(chat._model)\n            await self.uow.commit()\n\n    async def remove_member(self, chat_id: int, user_id: int, current_user_id: int) -> bool:\n        chat = await self.get_chat(chat_id, current_user_id)\n        if not chat:\n            return False\n        chat._model.members = [m for m in chat._model.members if m.id != user_id]\n        self.uow.register_dirty(chat._model)\n        await self.uow.commit()\n        return True\n\n    async def start_chat(self, current_user_id: int, other_user_id: int) -> Optional[UoWModel]:\n        stmt = select(models.User).filter(models.User.id.in_([current_user_id, other_user_id]))\n        result = await self.session.execute(stmt)\n        members = result.scalars().all()\n        if len(members) != 2:\n            return None\n        db_chat = models.Chat(name=f\"Chat between {members[0].username} and {members[1].username}\")\n        db_chat.members = members\n        uow_chat = self.uow.register_new(db_chat)\n        await self.uow.commit()\n        return uow_chat\n\n    async def get_user_ids_in_chat(self, chat_id: int) -> List[int]:\n        stmt = select(models.Chat).options(selectinload(models.Chat.members)).filter(models.Chat.id == chat_id)\n        result = await self.session.execute(stmt)\n        chat = result.scalar_one_or_none()\n        if not chat:\n            return []\n        return [user.id for user in chat.members]\n\n    async def get_unread_messages_count(self, chat_id: int, user_id: int) -> int:\n        stmt = select(func.count(models.MessageStatus.id)).join(models.Message).filter(\n            models.Message.chat_id == chat_id, models.MessageStatus.user_id == user_id,\n            models.MessageStatus.is_read.is_(False))\n        result = await self.session.execute(stmt)\n        return result.scalar_one()\n\n    async def get_unread_counts_for_chat_members(self, chat_id: int, current_user_id: int) -> Dict[int, int]:\n        stmt = select(models.MessageStatus.user_id, func.count(models.MessageStatus.id).label('unread_count')).join(\n            models.Message).filter(models.Message.chat_id == chat_id, models.MessageStatus.is_read.is_(False),\n                                   models.MessageStatus.user_id != current_user_id).group_by(\n            models.MessageStatus.user_id)\n        result = await self.session.execute(stmt)\n        return {row.user_id: row.unread_count for row in result}\n"}
{"type": "source_file", "path": "chat_service/app/api/__init__.py", "content": ""}
{"type": "source_file", "path": "chat_service/app/domain/entities.py", "content": "# app/domain/entities.py\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import List, Optional\n\n\n@dataclass\nclass User:\n    id: int\n    username: str\n    email: str\n    hashed_password: str\n    created_at: datetime = field(default_factory=datetime.utcnow)\n    is_active: bool = True\n    chats: List['Chat'] = field(default_factory=list)\n    messages: List['Message'] = field(default_factory=list)\n    tokens: List['Token'] = field(default_factory=list)\n    message_statuses: List['MessageStatus'] = field(default_factory=list)\n\n\n@dataclass\nclass Chat:\n    id: int\n    name: str\n    created_at: datetime = field(default_factory=datetime.utcnow)\n    members: List[User] = field(default_factory=list)\n    messages: List['Message'] = field(default_factory=list)\n\n\n@dataclass\nclass Message:\n    id: int\n    content: str\n    chat_id: int\n    user_id: int\n    chat: Optional[Chat] = None\n    user: Optional[User] = None\n    created_at: datetime = field(default_factory=datetime.utcnow)\n    updated_at: Optional[datetime] = None\n    is_deleted: bool = False\n    statuses: List['MessageStatus'] = field(default_factory=list)\n\n\n@dataclass\nclass Token:\n    id: int\n    access_token: str\n    refresh_token: str\n    token_type: str\n    expires_at: datetime\n    user_id: int\n    user: Optional[User] = None\n\n\n@dataclass\nclass MessageStatus:\n    id: int\n    message_id: int\n    user_id: int\n    is_read: bool = False\n    read_at: Optional[datetime] = None\n    message: Optional[Message] = None\n    user: Optional[User] = None\n"}
{"type": "source_file", "path": "chat_service/app/api/chats.py", "content": "# app/api/chats.py\nfrom typing import List, Optional\n\nfrom app.api.dependencies import get_chat_interactor, get_user_interactor\nfrom app.api.dependencies import get_current_active_user\nfrom app.infrastructure import schemas\nfrom app.interactors.chat_interactor import ChatInteractor\nfrom app.interactors.user_interactor import UserInteractor\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi import Query, Body\n\nrouter = APIRouter()\n\n\n@router.post(\"/\", response_model=schemas.Chat)\nasync def create_chat(\n        chat: schemas.ChatCreate,\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    new_chat = await chat_interactor.create_chat(chat, current_user.id)\n    if not new_chat:\n        raise HTTPException(status_code=404, detail=\"One or more invalid member IDs\")\n    return new_chat\n\n\n@router.get(\"/\", response_model=List[schemas.Chat])\nasync def read_chats(\n        skip: int = 0,\n        limit: int = 100,\n        name: Optional[str] = Query(None, description=\"Filter chats by name\"),\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    chats = await chat_interactor.get_chats(current_user.id, skip=skip, limit=limit, name=name)\n    return chats\n\n\n@router.post(\"/start\", response_model=schemas.Chat)\nasync def start_chat(\n        other_user_id: int = Body(..., embed=True, description=\"ID of the user to start a chat with\"),\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    chat = await chat_interactor.start_chat(current_user.id, other_user_id)\n    if not chat:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return chat\n\n\n@router.get(\"/{chat_id}\", response_model=schemas.Chat)\nasync def read_chat(\n        chat_id: int,\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    chat = await chat_interactor.get_chat(chat_id, current_user.id)\n    if chat is None:\n        raise HTTPException(status_code=404, detail=\"Chat not found\")\n    return chat\n\n\n@router.put(\"/{chat_id}\", response_model=schemas.Chat)\nasync def update_chat(\n        chat_id: int,\n        chat_update: schemas.ChatUpdate,\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    updated_chat = await chat_interactor.update_chat(chat_id, chat_update, current_user.id)\n    if updated_chat is None:\n        raise HTTPException(status_code=404, detail=\"Chat not found\")\n    return updated_chat\n\n\n@router.delete(\"/{chat_id}\", status_code=204)\nasync def delete_chat(\n        chat_id: int,\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    deleted = await chat_interactor.delete_chat(chat_id, current_user.id)\n    if not deleted:\n        raise HTTPException(status_code=404, detail=\"Chat not found\")\n    return {\"message\": \"Chat deleted successfully\"}\n\n\n@router.get(\"/{chat_id}/members\", response_model=List[schemas.User])\nasync def get_chat_members(\n        chat_id: int,\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    chat = await chat_interactor.get_chat(chat_id, current_user.id)\n    if not chat:\n        raise HTTPException(status_code=404, detail=\"Chat not found or you're not a member\")\n    return chat.members\n\n\n@router.post(\"/{chat_id}/members\", response_model=schemas.Chat)\nasync def add_chat_member(\n        chat_id: int,\n        user_id: int = Body(..., embed=True),\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        user_interactor: UserInteractor = Depends(get_user_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    user = await user_interactor.get_user(user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    chat = await chat_interactor.add_member(chat_id, user_id, current_user.id)\n    if not chat:\n        raise HTTPException(status_code=404, detail=\"Chat not found\")\n\n    return chat\n\n\n@router.delete(\"/{chat_id}/members/{user_id}\", status_code=204)\nasync def remove_chat_member(\n        chat_id: int,\n        user_id: int,\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        user_interactor: UserInteractor = Depends(get_user_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    user = await user_interactor.get_user(user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    chat = await chat_interactor.remove_member(chat_id, user_id, current_user.id)\n    if not chat:\n        raise HTTPException(status_code=404, detail=\"Chat not found\")\n\n    return {\"message\": \"Member removed from chat successfully\"}\n\n\n@router.get(\"/{chat_id}/unread_count\", response_model=int)\nasync def get_unread_messages_count(\n        chat_id: int,\n        chat_interactor: ChatInteractor = Depends(get_chat_interactor),\n        current_user: schemas.User = Depends(get_current_active_user)\n):\n    unread_count = await chat_interactor.get_unread_messages_count(chat_id, current_user.id)\n    if unread_count is None:\n        raise HTTPException(status_code=404, detail=\"Chat not found\")\n    return unread_count\n"}
{"type": "source_file", "path": "chat_service/app/infrastructure/__init__.py", "content": ""}
{"type": "source_file", "path": "chat_service/app/gateways/token_gateway.py", "content": "# app/infrastructure/token_gateway.py\nfrom typing import Optional\n\nfrom app.gateways.interfaces import ITokenGateway\nfrom app.infrastructure import models\nfrom app.infrastructure import schemas\nfrom app.infrastructure.data_mappers import TokenMapper\nfrom app.infrastructure.uow import UnitOfWork, UoWModel\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nclass TokenGateway(ITokenGateway):\n    def __init__(self, session: AsyncSession, uow: UnitOfWork):\n        self.session = session\n        self.uow = uow\n        uow.mappers[models.Token] = TokenMapper(session)\n\n    async def create_token(self, token: schemas.TokenCreate) -> UoWModel:\n        # Check if a token already exists for this user\n        existing_token = await self.get_by_user_id(token.user_id)\n        if existing_token:\n            # Update the existing token directly\n            existing_token._model.access_token = token.access_token\n            existing_token._model.refresh_token = token.refresh_token\n            existing_token._model.expires_at = token.expires_at\n            self.uow.register_dirty(existing_token)\n        else:\n            # Create a new token\n            db_token = models.Token(**token.model_dump())\n            existing_token = self.uow.register_new(db_token)\n        await self.uow.commit()\n        return existing_token\n\n    async def get_by_user_id(self, user_id: int) -> Optional[UoWModel]:\n        stmt = select(models.Token).filter(models.Token.user_id == user_id)\n        result = await self.session.execute(stmt)\n        token = result.scalar_one_or_none()\n        return UoWModel(token, self.uow) if token else None\n\n    async def get_by_access_token(self, access_token: str) -> Optional[UoWModel]:\n        stmt = select(models.Token).filter(models.Token.access_token == access_token)\n        result = await self.session.execute(stmt)\n        token = result.scalar_one_or_none()\n        return UoWModel(token, self.uow) if token else None\n\n    async def get_by_refresh_token(self, refresh_token: str) -> Optional[UoWModel]:\n        stmt = select(models.Token).filter(models.Token.refresh_token == refresh_token)\n        result = await self.session.execute(stmt)\n        token = result.scalar_one_or_none()\n        return UoWModel(token, self.uow) if token else None\n\n    async def invalidate_refresh_token(self, refresh_token: str) -> bool:\n        token: Optional[UoWModel] = await self.get_by_refresh_token(refresh_token)\n        if token:\n            # Invalidate the refresh token\n            token.refresh_token = None\n            self.uow.register_dirty(token)\n            await self.uow.commit()\n            return True\n        return False\n\n    async def delete_token_by_access_token(self, access_token: str) -> bool:\n        token: Optional[UoWModel] = await self.get_by_access_token(access_token)\n        if token:\n            self.uow.register_deleted(token)\n            await self.uow.commit()\n            return True\n        return False\n\n    async def delete_token_by_refresh_token(self, refresh_token: str) -> bool:\n        token: Optional[UoWModel] = await self.get_by_refresh_token(refresh_token)\n        if token:\n            self.uow.register_deleted(token)\n            await self.uow.commit()\n            return True\n        return False\n"}
{"type": "source_file", "path": "chat_service/app/gateways/interfaces.py", "content": "# app/gateways/interfaces.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\n\nfrom app.infrastructure import schemas\nfrom app.infrastructure.security import SecurityService\nfrom app.infrastructure.uow import UoWModel\n\n\nclass IChatGateway(ABC):\n    @abstractmethod\n    async def get_chat(self,\n                       chat_id: int,\n                       user_id: int) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def get_all(self,\n                      user_id: int,\n                      skip: int = 0,\n                      limit: int = 100,\n                      name: Optional[str] = None) -> List[\n        UoWModel]:\n        pass\n\n    @abstractmethod\n    async def create_chat(self,\n                          chat: schemas.ChatCreate,\n                          user_id: int) -> UoWModel:\n        pass\n\n    @abstractmethod\n    async def add_member(self,\n                         chat_id: int,\n                         user_id: int,\n                         current_user_id: int) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def delete_chat(self,\n                          chat_id: int,\n                          user_id: int) -> None:\n        pass\n\n    @abstractmethod\n    async def remove_member(self,\n                            chat_id: int,\n                            user_id: int,\n                            current_user_id: int) -> bool:\n        pass\n\n    @abstractmethod\n    async def start_chat(self,\n                         current_user_id: int,\n                         other_user_id: int) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def get_user_ids_in_chat(self,\n                                   chat_id: int) -> List[int]:\n        pass\n\n    @abstractmethod\n    async def get_unread_messages_count(self,\n                                        chat_id: int,\n                                        user_id: int) -> int:\n        pass\n\n    @abstractmethod\n    async def get_unread_counts_for_chat_members(self,\n                                                 chat_id: int,\n                                                 current_user_id: int) -> dict[int, int]:\n        pass\n\n\nclass IMessageGateway(ABC):\n    @abstractmethod\n    async def get_message(self,\n                          message_id: int,\n                          user_id: int) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def get_all(self,\n                      chat_id: int,\n                      user_id: int,\n                      skip: int = 0,\n                      limit: int = 100,\n                      content: Optional[str] = None) -> List[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def create_message(self,\n                             message: schemas.MessageCreate,\n                             user_id: int) -> UoWModel:\n        pass\n\n    @abstractmethod\n    async def update_message(self,\n                             message_id: int,\n                             message_update: schemas.MessageUpdate,\n                             user_id: int) -> Optional[\n        UoWModel]:\n        pass\n\n    @abstractmethod\n    async def delete_message(self,\n                             message_id: int,\n                             user_id: int) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def update_message_status(self,\n                                    message_id: int,\n                                    user_id: int,\n                                    status_update: schemas.MessageStatusUpdate) -> Optional[UoWModel]:\n        pass\n\n\nclass ITokenGateway(ABC):\n    @abstractmethod\n    async def create_token(self, token: schemas.TokenCreate) -> UoWModel:\n        pass\n\n    @abstractmethod\n    async def get_by_user_id(self, user_id: int) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def get_by_access_token(self, access_token: str) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def get_by_refresh_token(self, refresh_token: str) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def invalidate_refresh_token(self, refresh_token: str) -> bool:\n        pass\n\n    @abstractmethod\n    async def delete_token_by_access_token(self, access_token: str) -> bool:\n        pass\n\n    @abstractmethod\n    async def delete_token_by_refresh_token(self, refresh_token: str) -> bool:\n        pass\n\n\nclass IUserGateway(ABC):\n    @abstractmethod\n    async def get_user(self, user_id: int) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def get_by_email(self, email: str) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def get_by_username(self, username: str) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def get_all(self, skip: int = 0, limit: int = 100, username: Optional[str] = None) -> List[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def update_user(self, user: UoWModel, user_update: schemas.UserUpdate,\n                          security_service: SecurityService) -> UoWModel:\n        pass\n\n    @abstractmethod\n    async def create_user(self, user: schemas.UserCreate, security_service: SecurityService) -> Optional[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def search_users(self, query: str, current_user_id: int) -> List[UoWModel]:\n        pass\n\n    @abstractmethod\n    async def verify_password(self, user: UoWModel, password: str, security_service: SecurityService) -> bool:\n        pass\n\n    @abstractmethod\n    async def update_password(self, user: UoWModel, new_password: str, security_service: SecurityService) -> None:\n        pass\n\n    @abstractmethod\n    async def delete_user(self, user_id: int) -> Optional[UoWModel]:\n        pass\n"}
{"type": "source_file", "path": "chat_service/app/gateways/user_gateway.py", "content": "# app/infrastructure/user_gateway.py\nfrom typing import List, Optional\n\nfrom app.gateways.interfaces import IUserGateway\nfrom app.infrastructure import models\nfrom app.infrastructure import schemas\nfrom app.infrastructure.data_mappers import UserMapper\nfrom app.infrastructure.security import SecurityService\nfrom app.infrastructure.uow import UnitOfWork, UoWModel\nfrom sqlalchemy import select, func\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nclass UserGateway(IUserGateway):\n    def __init__(self, session: AsyncSession, uow: UnitOfWork):\n        self.session = session\n        self.uow = uow\n        uow.mappers[models.User] = UserMapper(session)\n\n    async def get_user(self, user_id: int) -> Optional[UoWModel]:\n        stmt = select(models.User).filter(models.User.id == user_id)\n        result = await self.session.execute(stmt)\n        user = result.scalar_one_or_none()\n        return UoWModel(user, self.uow) if user else None\n\n    async def get_by_email(self, email: str) -> Optional[UoWModel]:\n        stmt = select(models.User).filter(func.lower(models.User.email) == func.lower(email))\n        result = await self.session.execute(stmt)\n        user = result.scalar_one_or_none()\n        return UoWModel(user, self.uow) if user else None\n\n    async def get_by_username(self, username: str) -> Optional[UoWModel]:\n        stmt = select(models.User).filter(func.lower(models.User.username) == func.lower(username))\n        result = await self.session.execute(stmt)\n        user = result.scalar_one_or_none()\n        return UoWModel(user, self.uow) if user else None\n\n    async def get_all(self, skip: int = 0, limit: int = 100, username: Optional[str] = None) -> List[UoWModel]:\n        stmt = select(models.User)\n        if username:\n            stmt = stmt.filter(models.User.username.ilike(f\"%{username}%\"))\n        stmt = stmt.offset(skip).limit(limit)\n        result = await self.session.execute(stmt)\n        users = result.scalars().all()\n        return [UoWModel(user, self.uow) for user in users]\n\n    async def update_user(self,\n                          user: UoWModel,\n                          user_update: schemas.UserUpdate,\n                          security_service: SecurityService) -> UoWModel:\n        for key, value in user_update.model_dump(exclude_unset=True).items():\n            if key == 'password':\n                hashed_password = security_service.get_password_hash(value)\n                setattr(user, 'hashed_password', hashed_password)\n            else:\n                setattr(user, key, value)\n\n        await self.uow.commit()\n        return user\n\n    async def create_user(self, user: schemas.UserCreate, security_service: SecurityService) -> Optional[UoWModel]:\n        existing_user = await self.get_by_email(user.email)\n        if existing_user:\n            return None\n        existing_username = await self.get_by_username(user.username)\n        if existing_username:\n            return None\n\n        hashed_password = security_service.get_password_hash(user.password)\n        db_user = models.User(**user.model_dump(exclude={'password'}), hashed_password=hashed_password)\n        uow_user = self.uow.register_new(db_user)\n        await self.uow.commit()\n        return uow_user\n\n    async def search_users(self, query: str, current_user_id: int) -> List[UoWModel]:\n        stmt = select(models.User).filter(models.User.id != current_user_id, models.User.username.ilike(f'%{query}%'))\n        result = await self.session.execute(stmt)\n        users = result.scalars().all()\n        return [UoWModel(user, self.uow) for user in users]\n\n    async def verify_password(self, user: UoWModel, password: str, security_service: SecurityService) -> bool:\n        return security_service.verify_password(password, user._model.hashed_password)\n\n    async def update_password(self, user: UoWModel, new_password: str, security_service: SecurityService) -> None:\n        hashed_password = security_service.get_password_hash(new_password)\n        user._model.hashed_password = hashed_password\n        self.uow.register_dirty(user._model)\n        await self.uow.commit()\n\n    async def delete_user(self, user_id: int) -> Optional[UoWModel]:\n        stmt = select(models.User).filter(models.User.id == user_id)\n        result = await self.session.execute(stmt)\n        user = result.scalar_one_or_none()\n\n        if user:\n            uow_user = UoWModel(user, self.uow)\n            self.uow.register_deleted(user)\n            await self.uow.commit()\n            return uow_user\n        return None\n"}
{"type": "source_file", "path": "chat/chat_screen.py", "content": "import json\nimport logging\nimport threading\nfrom datetime import datetime\n\nimport flet as ft\n\n\nclass ChatScreen(ft.Column):\n    def __init__(self, chat_app, chat_id):\n        super().__init__()\n        self.isolated = True\n        self.chat_app = chat_app\n        self.chat_id = chat_id\n        self.current_user_id = None\n\n        # We'll store the channel name and unsubscribe from it in will_unmount().\n        self.chat_channel_name = f\"chat:{self.chat_id}\"\n\n        # Configure logging\n        self.logger = logging.getLogger('ChatScreen')\n        self.logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('[%(asctime)s] %(levelname)s:%(name)s: %(message)s')\n        handler.setFormatter(formatter)\n        if not self.logger.handlers:\n            self.logger.addHandler(handler)\n\n        # Initialize UI components\n        self.chat_name = ft.Text(\"\", style=ft.TextThemeStyle.HEADLINE_MEDIUM)\n        self.message_list = ft.ListView(spacing=10, expand=True, auto_scroll=True)\n        self.message_input = ft.TextField(\n            hint_text=\"Type a message...\",\n            expand=True,\n            multiline=True,\n            min_lines=1,\n            max_lines=5\n        )\n\n    def build(self):\n        \"\"\"\n        The ChatScreen layout:\n          - Top row with a back button, chat title, and more menu\n          - self.message_list for chat messages\n          - A row for the message input and 'Send' button\n        \"\"\"\n        return ft.Column(\n            [\n                ft.Row(\n                    [\n                        ft.IconButton(\n                            icon=ft.icons.ARROW_BACK,\n                            on_click=self.go_back,\n                            tooltip=\"Back to Chats\"\n                        ),\n                        ft.Container(\n                            content=self.chat_name,\n                            expand=True,\n                            alignment=ft.alignment.center\n                        ),\n                        self.create_options_menu(),\n                    ],\n                    alignment=ft.MainAxisAlignment.SPACE_BETWEEN\n                ),\n                self.message_list,\n                ft.Row(\n                    [\n                        self.message_input,\n                        ft.IconButton(\n                            icon=ft.icons.SEND,\n                            on_click=self.send_message\n                        )\n                    ],\n                    spacing=10\n                )\n            ],\n            expand=True,\n            spacing=20,\n        )\n\n    def create_options_menu(self):\n        \"\"\"\n        The triple-dot (MORE_VERT) popup menu for chat-level actions, e.g. Add/Remove member.\n        \"\"\"\n        return ft.PopupMenuButton(\n            icon=ft.icons.MORE_VERT,\n            tooltip=\"Chat Options\",\n            items=[\n                ft.PopupMenuItem(\n                    text=\"Add Member\",\n                    icon=ft.icons.PERSON_ADD,\n                    on_click=self.show_add_member_dialog\n                ),\n                ft.PopupMenuItem(\n                    text=\"Remove Member\",\n                    icon=ft.icons.PERSON_REMOVE,\n                    on_click=self.show_remove_member_dialog\n                ),\n            ],\n        )\n\n    def show_add_member_dialog(self, e):\n        \"\"\"\n        Display a dialog for searching and adding a member to the chat.\n        \"\"\"\n        def close_dialog(_e):\n            dialog.open = False\n            self.page.update()\n\n        def search_users(_e):\n            search_term = search_field.value.strip()\n            if len(search_term) >= 1:\n                response = self.chat_app.api_client.search_users(search_term)\n                if response.success:\n                    search_results.options.clear()\n                    if response.data:\n                        for user in response.data:\n                            search_results.options.append(\n                                ft.dropdown.Option(\n                                    key=str(user['id']),\n                                    text=user['username']\n                                )\n                            )\n                    else:\n                        search_results.options.append(\n                            ft.dropdown.Option(\n                                key=\"no_results\",\n                                text=\"No users found\"\n                            )\n                        )\n                    search_results.visible = True\n                else:\n                    self.chat_app.show_error_dialog(\"Error Searching Users\", response.error)\n            else:\n                search_results.visible = False\n            dialog.update()\n\n        def add_member(_e):\n            selected_user_id = search_results.value\n            if selected_user_id and selected_user_id != \"no_results\":\n                response = self.chat_app.api_client.add_chat_member(\n                    self.chat_id,\n                    int(selected_user_id)\n                )\n                if response.success:\n                    self.load_chat()\n                    dialog.open = False\n                    self.page.update()\n                else:\n                    self.chat_app.show_error_dialog(\"Error Adding Member\", response.error)\n\n        search_field = ft.TextField(\n            hint_text=\"Search users\",\n            expand=True,\n            on_submit=search_users\n        )\n        search_button = ft.IconButton(\n            icon=ft.icons.SEARCH,\n            on_click=search_users,\n            tooltip=\"Search\",\n        )\n        search_results = ft.Dropdown(\n            options=[],\n            visible=False,\n        )\n\n        dialog = ft.AlertDialog(\n            title=ft.Text(\"Add Member\"),\n            content=ft.Column([\n                ft.Row([search_field, search_button]),\n                search_results,\n            ]),\n            actions=[\n                ft.TextButton(\"Cancel\", on_click=close_dialog),\n                ft.TextButton(\"Add\", on_click=add_member),\n            ],\n        )\n\n        self.page.dialog = dialog\n        dialog.open = True\n        self.page.update()\n\n    def show_remove_member_dialog(self, e):\n        \"\"\"\n        Opens a dialog to remove a member from the chat.\n        \"\"\"\n        def close_dialog(_e):\n            dialog.open = False\n            self.page.update()\n\n        def remove_member(user_id):\n            response = self.chat_app.api_client.remove_chat_member(self.chat_id, user_id)\n            if response.success:\n                self.load_chat()\n                close_dialog(None)\n            else:\n                self.chat_app.show_error_dialog(\"Error Removing Member\", response.error)\n\n        response = self.chat_app.api_client.get_chat(self.chat_id)\n        if response.success:\n            members = response.data['members']\n            member_list = ft.Column([\n                ft.Row([\n                    ft.Text(member['username'], expand=True),\n                    ft.IconButton(\n                        icon=ft.icons.REMOVE,\n                        on_click=lambda _, m=member: remove_member(m['id']),\n                        tooltip=\"Remove\"\n                    ) if member['id'] != self.current_user_id else ft.Container()\n                ])\n                for member in members\n            ])\n\n            dialog = ft.AlertDialog(\n                title=ft.Text(\"Remove Member\"),\n                content=member_list,\n                actions=[\n                    ft.TextButton(\"Close\", on_click=close_dialog),\n                ],\n            )\n\n            self.page.dialog = dialog\n            dialog.open = True\n            self.page.update()\n        else:\n            self.chat_app.show_error_dialog(\"Error Loading Members\", response.error)\n\n    def did_mount(self):\n        \"\"\"\n        Called when the control is added to the page.\n        Great place to load chat data and subscribe to channel.\n        \"\"\"\n        self.logger.info(f\"ChatScreen for chat ID {self.chat_id} mounted.\")\n\n        # Current user ID\n        user_resp = self.chat_app.api_client.get_current_user()\n        if user_resp.success and user_resp.data:\n            self.current_user_id = user_resp.data['id']\n\n        self.load_chat()\n\n        # Ensure UI is rendered before loading messages\n        self.update()\n\n        # Load messages after UI is in place\n        self.load_messages()\n\n        # Subscribe to new messages for this chat\n        self.chat_app.api_client.subscribe_to_channel(self.chat_channel_name, self.process_new_message)\n        self.logger.info(f\"Subscribed to channel {self.chat_channel_name} for new messages.\")\n\n    def will_unmount(self):\n        \"\"\"\n        Called when the control is about to be removed from the page.\n        \"\"\"\n        self.logger.info(f\"ChatScreen for chat ID {self.chat_id} will unmount.\")\n        # Unsubscribe from this chat's channel\n        self.chat_app.api_client.unsubscribe_from_channel(self.chat_channel_name)\n        self.logger.info(f\"Unsubscribed from channel {self.chat_channel_name}.\")\n\n    def process_new_message(self, data):\n        \"\"\"\n        Processes new messages (or updates) received from Redis for this chat.\n        \"\"\"\n        try:\n            message = json.loads(data)\n            self.logger.info(f\"Received new message for chat ID {self.chat_id}: {message}\")\n\n            # Look for an existing row containing this message ID\n            existing_message_row = next(\n                (\n                    row_control for row_control in self.message_list.controls\n                    if isinstance(row_control, ft.Row)\n                    and len(row_control.controls) > 0\n                    and isinstance(row_control.controls[0], ft.GestureDetector)\n                    and row_control.controls[0].content is not None\n                    and isinstance(row_control.controls[0].content, ft.Container)\n                    and row_control.controls[0].content.data == message['id']\n                ),\n                None\n            )\n\n            if existing_message_row:\n                # Update existing message\n                self.update_message_in_list(existing_message_row, message)\n            else:\n                # Add new message\n                self.add_message_to_list(message)\n\n            self.scroll_to_bottom()\n            self.page.update()\n\n            # Mark the new message as read if it's not from the current user\n            if message['user']['id'] != self.current_user_id:\n                threading.Thread(\n                    target=self.mark_message_as_read,\n                    args=(message['id'],),\n                    daemon=True\n                ).start()\n\n        except json.JSONDecodeError:\n            self.logger.error(f\"Failed to decode message: {data}\")\n        except Exception as e:\n            self.logger.error(f\"Error processing new message: {str(e)}\")\n\n    def update_message_in_list(self, existing_message_row, updated_message):\n        \"\"\"\n        Updates an existing message in the message list (e.g. if edited or deleted).\n        \"\"\"\n        # The first child of existing_message_row is a GestureDetector:\n        gesture_detector = existing_message_row.controls[0]\n        # Then its .content is the Container with `data=message_id` and a Column with 3 items\n        #   [ Text(username), Text(content), Row([...time info...]) ]\n        if not isinstance(gesture_detector, ft.GestureDetector):\n            return\n\n        message_container = gesture_detector.content\n        if not isinstance(message_container, ft.Container) or not message_container.content:\n            return\n\n        column_content = message_container.content  # a ft.Column([...])\n        if not isinstance(column_content, ft.Column) or len(column_content.controls) < 3:\n            return\n\n        # [ Text(username), Text(message_content), time_info_row ]\n        # user_text = column_content.controls[0]   # ft.Text(username)\n        message_text = column_content.controls[1]  # ft.Text(content or <deleted>)\n        time_info = column_content.controls[2]     # ft.Row([... time info ...])\n\n        is_current_user = updated_message['user']['id'] == self.current_user_id\n        text_color = ft.colors.WHITE if is_current_user else ft.colors.BLACK\n\n        if updated_message['is_deleted']:\n            message_text.value = \"<This message has been deleted>\"\n            message_text.color = ft.colors.GREY_400\n        else:\n            message_text.value = updated_message['content']\n            message_text.color = text_color\n\n        # Update the time info\n        message_time = datetime.fromisoformat(updated_message['created_at'])\n        formatted_time = message_time.strftime(\"%H:%M\")\n        if len(time_info.controls) > 0:\n            time_info.controls[0].value = formatted_time\n\n        # If message was edited\n        if updated_message.get('updated_at') and updated_message['updated_at'] != updated_message['created_at']:\n            edit_time = datetime.fromisoformat(updated_message['updated_at'])\n            formatted_edit_time = edit_time.strftime(\"%H:%M\")\n            # Possibly the time_info row has a second text for \"(edited ...)\"\n            if len(time_info.controls) > 1:\n                time_info.controls[1].value = f\"(edited at {formatted_edit_time})\"\n            else:\n                time_info.controls.append(\n                    ft.Text(\n                        f\"(edited at {formatted_edit_time})\",\n                        style=ft.TextThemeStyle.BODY_SMALL,\n                        italic=True,\n                        color=ft.colors.GREY_400 if is_current_user else ft.colors.GREY_700\n                    )\n                )\n\n        self.logger.info(\n            f\"Updated message (ID: {updated_message['id']}) in the message list for chat ID {self.chat_id}\"\n        )\n\n    def go_back(self, e):\n        \"\"\"\n        Navigates back to the chat list screen.\n        \"\"\"\n        self.logger.info(f\"Navigating back to chat list from chat ID {self.chat_id}\")\n        self.chat_app.show_chat_list()\n\n    def load_chat(self):\n        \"\"\"\n        Loads chat details (like name) and updates `self.chat_name`.\n        \"\"\"\n        self.logger.info(f\"Loading chat details for chat ID {self.chat_id}\")\n        response = self.chat_app.api_client.get_chat(self.chat_id)\n        if response.success:\n            self.chat_name.value = response.data['name']\n            self.update()\n            self.logger.info(f\"Chat details loaded for chat ID {self.chat_id}\")\n        else:\n            self.chat_app.show_error_dialog(\"Error Loading Chat\", response.error)\n            self.logger.error(f\"Failed to load chat details for chat ID {self.chat_id}: {response.error}\")\n\n    def send_message(self, e):\n        \"\"\"\n        Sends a new message via the API.\n        \"\"\"\n        if self.message_input.value.strip():\n            self.logger.info(f\"Sending new message in chat ID {self.chat_id}\")\n            response = self.chat_app.api_client.send_message(self.chat_id, self.message_input.value.strip())\n            if response.success:\n                self.message_input.value = \"\"\n                self.message_input.update()\n                self.logger.info(f\"Message sent in chat ID {self.chat_id}\")\n            else:\n                self.chat_app.show_error_dialog(\"Error Sending Message\", response.error)\n                self.logger.error(f\"Failed to send message in chat ID {self.chat_id}: {response.error}\")\n\n    def load_messages(self):\n        \"\"\"\n        Loads messages from the server, populates self.message_list,\n        and marks unread messages as read.\n        \"\"\"\n        self.logger.info(f\"Loading messages for chat ID {self.chat_id}\")\n        response = self.chat_app.api_client.get_messages(self.chat_id)\n        if response.success:\n            self.message_list.controls.clear()\n\n            if not response.data:\n                self.message_list.controls.append(\n                    ft.Text(\n                        \"No messages yet. Start a conversation!\",\n                        style=ft.TextThemeStyle.BODY_LARGE,\n                        color=ft.colors.GREY_500\n                    )\n                )\n                self.logger.info(f\"No messages found for chat ID {self.chat_id}\")\n            else:\n                unread_message_ids = []\n                # We reverse the list so older messages appear at the top\n                for msg in reversed(response.data):\n                    self.add_message_to_list(msg)\n                    # Check if the message is unread by the current user\n                    if (not msg['is_deleted']\n                        and not any(st['is_read'] for st in msg['statuses']\n                                    if st['user_id'] == self.current_user_id)):\n                        unread_message_ids.append(msg['id'])\n\n                self.logger.info(f\"Loaded {len(response.data)} messages for chat {self.chat_id}\")\n\n                # Mark unread messages as read in background\n                if unread_message_ids:\n                    self.logger.info(\n                        f\"Marking {len(unread_message_ids)} messages as read for chat {self.chat_id}\"\n                    )\n                    threading.Thread(\n                        target=self.mark_messages_as_read,\n                        args=(unread_message_ids,),\n                        daemon=True\n                    ).start()\n\n            self.message_list.auto_scroll = True\n            self.update()\n        else:\n            self.chat_app.show_error_dialog(\"Error Loading Messages\", response.error)\n            self.logger.error(f\"Failed to load messages for chat {self.chat_id}: {response.error}\")\n\n    def add_message_to_list(self, message):\n        \"\"\"\n        Creates a new Row+GestureDetector+Container with the message info and appends it\n        to self.message_list.\n        \"\"\"\n        is_current_user = (message['user']['id'] == self.current_user_id)\n        message_color = ft.colors.BLUE_700 if is_current_user else ft.colors.GREY_200\n        text_color = ft.colors.WHITE if is_current_user else ft.colors.BLACK\n        alignment = ft.MainAxisAlignment.END if is_current_user else ft.MainAxisAlignment.START\n\n        message_time = datetime.fromisoformat(message['created_at'])\n        formatted_time = message_time.strftime(\"%H:%M\")\n\n        if message['is_deleted']:\n            message_content = ft.Text(\n                \"<This message has been deleted>\",\n                style=ft.TextThemeStyle.BODY_MEDIUM,\n                color=ft.colors.GREY_400\n            )\n        else:\n            message_content = ft.Text(\n                message['content'],\n                style=ft.TextThemeStyle.BODY_MEDIUM,\n                color=text_color\n            )\n\n        time_info = ft.Row(\n            [\n                ft.Text(\n                    formatted_time,\n                    style=ft.TextThemeStyle.BODY_SMALL,\n                    color=ft.colors.GREY_400 if is_current_user else ft.colors.GREY_700\n                )\n            ],\n            spacing=5\n        )\n\n        # If the message has been edited\n        if message.get('updated_at') and message['updated_at'] != message['created_at']:\n            edit_time = datetime.fromisoformat(message['updated_at'])\n            formatted_edit_time = edit_time.strftime(\"%H:%M\")\n            time_info.controls.append(\n                ft.Text(\n                    f\"(edited at {formatted_edit_time})\",\n                    style=ft.TextThemeStyle.BODY_SMALL,\n                    italic=True,\n                    color=ft.colors.GREY_400 if is_current_user else ft.colors.GREY_700\n                )\n            )\n\n        # A Column with: [username, message_content, time_info]\n        message_column = ft.Column([\n            ft.Text(\n                message['user']['username'],\n                style=ft.TextThemeStyle.BODY_SMALL,\n                color=text_color\n            ),\n            message_content,\n            time_info\n        ])\n\n        # The Container storing message_column and `data=message['id']`\n        message_container = ft.Container(\n            content=message_column,\n            bgcolor=message_color,\n            border_radius=ft.border_radius.all(10),\n            padding=10,\n            width=300,\n            data=message['id']  # Store message ID in container's data\n        )\n\n        # A GestureDetector to handle long-press events (for edit/delete, read info, etc.)\n        gesture_detector = ft.GestureDetector(\n            content=message_container,\n            on_long_press_start=lambda e: self.show_message_options(e, message, is_current_user)\n        )\n\n        # Append a Row with the GestureDetector\n        self.message_list.controls.append(\n            ft.Row([gesture_detector], alignment=alignment)\n        )\n        self.logger.info(f\"Added message (ID: {message['id']}) to the message list for chat ID {self.chat_id}\")\n\n    def scroll_to_bottom(self):\n        \"\"\"\n        Scroll the ListView to the bottom (offset=-1) if there are any messages.\n        \"\"\"\n        if len(self.message_list.controls) > 0:\n            self.message_list.scroll_to(offset=-1, duration=300, curve=ft.AnimationCurve.EASE_OUT)\n\n    def mark_message_as_read(self, message_id):\n        \"\"\"\n        Mark a single message as read, calling the API. Runs in a background thread.\n        \"\"\"\n        self.logger.info(f\"Marking message ID {message_id} as read\")\n        response = self.chat_app.api_client.update_message_status(message_id, {\"is_read\": True})\n        if not response.success:\n            self.logger.error(f\"Failed to mark message {message_id} as read: {response.error}\")\n\n    def mark_messages_as_read(self, message_ids):\n        \"\"\"\n        Mark multiple messages as read in a loop.\n        \"\"\"\n        self.logger.info(f\"Marking {len(message_ids)} messages as read for chat {self.chat_id}\")\n        for mid in message_ids:\n            self.mark_message_as_read(mid)\n\n    def show_message_options(self, e, message, is_current_user):\n        \"\"\"\n        Show a dialog with read status info, plus 'Edit' / 'Delete' if it's the user's own message.\n        \"\"\"\n        # Refresh the message status before showing options\n        msg_resp = self.chat_app.api_client.get_messages(\n            self.chat_id, limit=1, content=message['content']\n        )\n        if msg_resp.success and msg_resp.data:\n            updated_message = msg_resp.data[0]\n        else:\n            updated_message = message  # fallback if we can't fetch fresh data\n\n        def close_dialog(_e):\n            options_dialog.open = False\n            self.page.dialog = None\n            self.page.update()\n\n        # \"Read by:\" section\n        read_status_title = ft.Text(\"Read by:\", style=ft.TextThemeStyle.TITLE_SMALL, weight=ft.FontWeight.BOLD)\n        read_status_list = ft.ListView(spacing=5, expand=True)\n\n        # For each user status, find username and read time\n        for status in updated_message['statuses']:\n            # We need the username from the chat membership list\n            chat_info = self.chat_app.api_client.get_chat(self.chat_id)\n            if not chat_info.success:\n                continue\n            members = chat_info.data['members']\n            reader_name = next(\n                (m['username'] for m in members if m['id'] == status['user_id']),\n                \"Unknown\"\n            )\n\n            if status['is_read']:\n                read_time = None\n                if status['read_at']:\n                    read_time = datetime.fromisoformat(status['read_at'])\n                formatted_time = read_time.strftime(\"%Y-%m-%d %H:%M:%S\") if read_time else \"Unknown\"\n                read_status_list.controls.append(\n                    ft.Text(f\"{reader_name}: {formatted_time}\", style=ft.TextThemeStyle.BODY_SMALL)\n                )\n            else:\n                read_status_list.controls.append(\n                    ft.Text(f\"{reader_name}: Unread\", style=ft.TextThemeStyle.BODY_SMALL)\n                )\n\n        read_status_container = ft.Container(\n            content=ft.Column(\n                [\n                    read_status_title,\n                    read_status_list\n                ],\n                expand=True\n            ),\n            padding=10\n        )\n\n        options = [read_status_container]\n\n        if is_current_user and not message['is_deleted']:\n            options.extend([\n                ft.Divider(),\n                ft.ListTile(\n                    leading=ft.Icon(ft.icons.EDIT),\n                    title=ft.Text(\"Edit\", style=ft.TextThemeStyle.TITLE_MEDIUM),\n                    subtitle=ft.Text(\"Modify your message\", style=ft.TextThemeStyle.BODY_SMALL),\n                    on_click=lambda _: self.edit_message(message)\n                ),\n                ft.ListTile(\n                    leading=ft.Icon(ft.icons.DELETE),\n                    title=ft.Text(\"Delete\", style=ft.TextThemeStyle.TITLE_MEDIUM),\n                    subtitle=ft.Text(\"Remove this message\", style=ft.TextThemeStyle.BODY_SMALL),\n                    on_click=lambda _: self.delete_message(message)\n                ),\n            ])\n\n        options_dialog = ft.AlertDialog(\n            title=ft.Text(\"Message Options\", style=ft.TextThemeStyle.HEADLINE_SMALL),\n            content=ft.Container(\n                content=ft.Column(options, tight=True, scroll=ft.ScrollMode.AUTO),\n                expand=True,\n            ),\n            actions=[\n                ft.TextButton(\"Close\", on_click=close_dialog),\n            ],\n        )\n\n        self.page.dialog = options_dialog\n        options_dialog.open = True\n        self.page.update()\n\n    def edit_message(self, message):\n        \"\"\"\n        Prompts the user to edit this message's content.\n        \"\"\"\n        def update_message_content(_e):\n            if new_content.value.strip():\n                resp = self.chat_app.api_client.update_message(\n                    message['id'], {\"content\": new_content.value.strip()}\n                )\n                if resp.success:\n                    self.load_messages()\n                    dialog.open = False\n                    self.page.update()\n                else:\n                    self.chat_app.show_error_dialog(\"Error Updating Message\", resp.error)\n            else:\n                self.chat_app.show_error_dialog(\"Invalid Input\", {\"detail\": \"Please enter message content.\"})\n\n        new_content = ft.TextField(value=message['content'], multiline=True)\n        dialog = ft.AlertDialog(\n            title=ft.Text(\"Edit Message\"),\n            content=new_content,\n            actions=[\n                ft.TextButton(\"Cancel\", on_click=lambda _: self.close_dialog(dialog)),\n                ft.TextButton(\"Update\", on_click=update_message_content),\n            ],\n        )\n        self.page.dialog = dialog\n        dialog.open = True\n        self.page.update()\n\n    def delete_message(self, message):\n        \"\"\"\n        Prompts the user to confirm deletion, then calls API to delete the message.\n        \"\"\"\n        def confirm_delete(_e):\n            resp = self.chat_app.api_client.delete_message(message['id'])\n            if resp.success:\n                self.load_messages()\n                dialog.open = False\n                self.page.update()\n            else:\n                self.chat_app.show_error_dialog(\"Error Deleting Message\", resp.error)\n\n        dialog = ft.AlertDialog(\n            title=ft.Text(\"Delete Message\"),\n            content=ft.Text(\"Are you sure you want to delete this message?\"),\n            actions=[\n                ft.TextButton(\"Cancel\", on_click=lambda _: self.close_dialog(dialog)),\n                ft.TextButton(\"Delete\", on_click=confirm_delete),\n            ],\n        )\n        self.page.dialog = dialog\n        dialog.open = True\n        self.page.update()\n\n    def close_dialog(self, dialog):\n        \"\"\"\n        Closes an AlertDialog and clears the page.dialog reference.\n        \"\"\"\n        dialog.open = False\n        self.page.dialog = None\n        self.page.update()\n"}
{"type": "source_file", "path": "chat_service/app/api/auth.py", "content": "# app/api/auth.py\nimport datetime\nfrom datetime import timedelta\n\nfrom app.api.dependencies import get_security_service, get_user_interactor, get_token_interactor, get_config, \\\n    oauth2_scheme\nfrom app.config import AppConfig\nfrom app.infrastructure import schemas\nfrom app.infrastructure.security import SecurityService\nfrom app.interactors.token_interactor import TokenInteractor\nfrom app.interactors.user_interactor import UserInteractor\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\n\nrouter = APIRouter()\n\n\n@router.post(\"/login\", response_model=schemas.TokenResponse)\nasync def login_for_access_token(\n        form_data: OAuth2PasswordRequestForm = Depends(),\n        user_interactor: UserInteractor = Depends(get_user_interactor),\n        token_interactor: TokenInteractor = Depends(get_token_interactor),\n        config: AppConfig = Depends(get_config),\n        security_service: SecurityService = Depends(get_security_service)\n):\n    user = await user_interactor.verify_user_password(form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Inactive user\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    access_token_expires = datetime.timedelta(minutes=config.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token, access_expire = security_service.create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    refresh_token, _ = security_service.create_refresh_token(\n        data={\"sub\": user.username}\n    )\n\n    token_create = schemas.TokenCreate(\n        access_token=access_token,\n        refresh_token=refresh_token,\n        token_type=\"bearer\",\n        expires_at=access_expire,\n        user_id=user.id\n    )\n    token = await token_interactor.create_token(token_create)\n\n    return token\n\n\n@router.post(\"/register\", response_model=schemas.User)\nasync def register_user(\n        user: schemas.UserCreate,\n        user_interactor: UserInteractor = Depends(get_user_interactor)\n):\n    existing_user = await user_interactor.get_user_by_username(user.username)\n    if existing_user:\n        raise HTTPException(status_code=400, detail=\"Username already registered\")\n    existing_email = await user_interactor.get_user_by_email(user.email)\n    if existing_email:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    new_user = await user_interactor.create_user(user)\n    if not new_user:\n        raise HTTPException(status_code=400, detail=\"User creation failed\")\n    return new_user\n\n\n@router.post(\"/refresh\", response_model=schemas.TokenResponse)\nasync def refresh_token(\n        refresh_token_request: schemas.RefreshTokenRequest,\n        token_interactor: TokenInteractor = Depends(get_token_interactor),\n        user_interactor: UserInteractor = Depends(get_user_interactor),\n        security_service: SecurityService = Depends(get_security_service),\n        config: AppConfig = Depends(get_config)\n):\n    token = await token_interactor.get_token_by_refresh_token(refresh_token_request.refresh_token)\n    if not token:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid refresh token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    username = security_service.decode_refresh_token(token.refresh_token)\n    if not username:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid refresh token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    user = await user_interactor.get_user_by_username(username)\n    if not user or not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"User not found or inactive\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    # Invalidate the old refresh token\n    await token_interactor.invalidate_refresh_token(refresh_token_request.refresh_token)\n\n    # Create new tokens\n    new_access_token, new_access_token_expires = security_service.create_access_token(\n        data={\"sub\": user.username},\n        expires_delta=timedelta(minutes=config.ACCESS_TOKEN_EXPIRE_MINUTES)\n    )\n    new_refresh_token, _ = security_service.create_refresh_token(\n        data={\"sub\": user.username}\n    )\n\n    token_create = schemas.TokenCreate(\n        access_token=new_access_token,\n        refresh_token=new_refresh_token,\n        token_type=\"bearer\",\n        expires_at=new_access_token_expires,\n        user_id=user.id\n    )\n    new_token = await token_interactor.create_token(token_create)\n\n    return new_token\n\n\n@router.post(\"/logout\")\nasync def logout(\n        token: str = Depends(oauth2_scheme),\n        token_interactor: TokenInteractor = Depends(get_token_interactor)\n):\n    deleted = await token_interactor.delete_token_by_access_token(token)\n    if not deleted:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid token\")\n    return {\"message\": \"Successfully logged out\"}\n"}
{"type": "source_file", "path": "chat_service/app/gateways/message_gateway.py", "content": "# app/infrastructure/message_gateway.py\nfrom datetime import datetime, timezone\nfrom typing import List, Optional\n\nfrom app.gateways.interfaces import IMessageGateway\nfrom app.infrastructure import models\nfrom app.infrastructure import schemas\nfrom app.infrastructure.data_mappers import MessageMapper\nfrom app.infrastructure.uow import UnitOfWork, UoWModel\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import selectinload\n\n\nclass MessageGateway(IMessageGateway):\n    def __init__(self, session: AsyncSession, uow: UnitOfWork):\n        self.session = session\n        self.uow = uow\n        uow.mappers[models.Message] = MessageMapper(session)\n\n    async def get_message(self, message_id: int, user_id: int) -> Optional[UoWModel]:\n        stmt = select(models.Message).join(models.Chat).filter(\n            models.Message.id == message_id,\n            models.Chat.members.any(id=user_id)\n        )\n        result = await self.session.execute(stmt)\n        message = result.scalar_one_or_none()\n        return UoWModel(message, self.uow) if message else None\n\n    async def get_all(self, chat_id: int, user_id: int, skip: int = 0, limit: int = 100,\n                      content: Optional[str] = None) -> List[UoWModel]:\n        stmt = select(models.Message).join(models.Chat).filter(\n            models.Message.chat_id == chat_id,\n            models.Chat.members.any(id=user_id)\n        )\n        if content:\n            stmt = stmt.filter(models.Message.content.ilike(f\"%{content}%\"))\n        stmt = stmt.order_by(models.Message.created_at.desc()).offset(skip).limit(limit)\n        result = await self.session.execute(stmt)\n        messages = result.scalars().all()\n        return [UoWModel(message, self.uow) for message in messages]\n\n    async def create_message(self, message: schemas.MessageCreate, user_id: int) -> UoWModel:\n        chat_stmt = select(models.Chat).filter(models.Chat.id == message.chat_id, models.Chat.members.any(id=user_id))\n        chat_result = await self.session.execute(chat_stmt)\n        chat = chat_result.scalar_one_or_none()\n\n        if not chat:\n            raise ValueError(f\"Chat with id {message.chat_id} not found or user is not a member\")\n\n        db_message = models.Message(content=message.content, chat_id=message.chat_id, user_id=user_id)\n        for member in chat.members:\n            is_author = member.id == user_id\n            message_status = models.MessageStatus(\n                user_id=member.id,\n                is_read=is_author,\n                read_at=datetime.now(timezone.utc) if is_author else None\n            )\n            db_message.statuses.append(message_status)\n\n        uow_message = self.uow.register_new(db_message)\n        await self.uow.commit()\n        return uow_message\n\n    async def update_message(self, message_id: int, message_update: schemas.MessageUpdate, user_id: int) -> Optional[\n        UoWModel]:\n        stmt = select(models.Message).join(models.Chat).filter(\n            models.Message.id == message_id,\n            models.Message.user_id == user_id,\n            models.Chat.members.any(id=user_id)\n        )\n        result = await self.session.execute(stmt)\n        message = result.scalar_one_or_none()\n        if message:\n            message.content = message_update.content\n            message.updated_at = datetime.now(timezone.utc)\n            uow_message = UoWModel(message, self.uow)\n            self.uow.register_dirty(message)\n            await self.uow.commit()\n            return uow_message\n        return None\n\n    async def delete_message(self, message_id: int, user_id: int) -> Optional[UoWModel]:\n        stmt = select(models.Message).join(models.Chat).filter(\n            models.Message.id == message_id,\n            models.Message.user_id == user_id,\n            models.Chat.members.any(id=user_id)\n        )\n        result = await self.session.execute(stmt)\n        message = result.scalar_one_or_none()\n        if message:\n            message.is_deleted = True\n            message.content = \"<This message has been deleted>\"\n            message.updated_at = datetime.now(timezone.utc)\n            uow_message = UoWModel(message, self.uow)\n            self.uow.register_dirty(message)\n            await self.uow.commit()\n            return uow_message\n        return None\n\n    async def update_message_status(self, message_id: int, user_id: int, status_update: schemas.MessageStatusUpdate) -> \\\n            Optional[UoWModel]:\n        stmt = select(models.Message).options(\n            selectinload(models.Message.statuses)\n        ).filter(models.Message.id == message_id)\n        result = await self.session.execute(stmt)\n        message = result.scalar_one_or_none()\n\n        if message:\n            status = next((s for s in message.statuses if s.user_id == user_id), None)\n            if status:\n                status.is_read = status_update.is_read\n                if status.is_read and not status.read_at:\n                    status.read_at = datetime.utcnow()\n            else:\n                new_status = models.MessageStatus(\n                    message_id=message_id,\n                    user_id=user_id,\n                    is_read=status_update.is_read,\n                    read_at=datetime.utcnow() if status_update.is_read else None\n                )\n                message.statuses.append(new_status)\n            uow_message = UoWModel(message, self.uow)\n            self.uow.register_dirty(message)\n            await self.uow.commit()\n            return uow_message\n        return None\n"}
{"type": "source_file", "path": "chat/chat_list_screen.py", "content": "import json\nimport logging\n\nimport flet as ft\n\nclass ChatListScreen(ft.Column):\n    def __init__(self, chat_app):\n        super().__init__()\n        self.isolated = True\n        self.chat_app = chat_app\n        self.chat_subscriptions = {}  # Keep track of subscribed chats\n        self.current_user_id = None\n\n        # Configure logging\n        self.logger = logging.getLogger('ChatListScreen')\n        self.logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('[%(asctime)s] %(levelname)s:%(name)s: %(message)s')\n        handler.setFormatter(formatter)\n        if not self.logger.handlers:\n            self.logger.addHandler(handler)\n\n        # GUI elements\n        self.loading_indicator = ft.ProgressRing(visible=False)\n        self.search_input = ft.TextField(\n            hint_text=\"Search users\",\n            expand=8,\n        )\n        self.search_button = ft.IconButton(\n            icon=ft.icons.SEARCH,\n            on_click=self.search_users,\n            tooltip=\"Search\",\n        )\n        self.search_results = ft.Dropdown(\n            width=400,\n            options=[],\n            visible=False,\n            on_change=self.start_chat_with_user\n        )\n\n        self.chat_list = ft.ListView(spacing=10, expand=True)\n        self.loading_container = ft.Container(\n            content=ft.Column(\n                [\n                    ft.ProgressRing(),\n                    ft.Text(\"Chats are being loaded...\", style=ft.TextThemeStyle.BODY_MEDIUM)\n                ],\n                horizontal_alignment=ft.CrossAxisAlignment.CENTER,\n                spacing=10\n            ),\n            alignment=ft.alignment.center,\n            expand=True,\n            visible=False\n        )\n\n    def build(self):\n        \"\"\"\n        Builds the layout for ChatListScreen:\n          - Top row with user profile, \"Chats\" title, and refresh button\n          - Row with search input and button\n          - A dropdown for search results\n          - A stack with either the chat list or the loading container\n        \"\"\"\n        return ft.Column(\n            [\n                ft.Row(\n                    [\n                        ft.IconButton(icon=ft.icons.PERSON, on_click=self.show_profile, tooltip=\"Profile\"),\n                        ft.Text(\"Chats\", style=ft.TextThemeStyle.HEADLINE_MEDIUM),\n                        ft.IconButton(icon=ft.icons.REFRESH, on_click=self.load_chats, tooltip=\"Refresh\"),\n                    ],\n                    alignment=ft.MainAxisAlignment.SPACE_BETWEEN\n                ),\n                ft.Row([self.search_input, self.search_button]),\n                self.search_results,\n                ft.Stack(\n                    [\n                        self.chat_list,\n                        self.loading_container\n                    ],\n                    expand=True\n                )\n            ],\n            expand=True,\n            spacing=20,\n        )\n\n    def did_mount(self):\n        \"\"\"\n        Called when ChatListScreen is first mounted to the page.\n        We attempt to load the chats here.\n        \"\"\"\n        self.logger.info(\"ChatListScreen mounted. Loading chats...\")\n        self.load_chats()\n\n    def will_unmount(self):\n        \"\"\"\n        Called when ChatListScreen is about to be removed from the page.\n        We unsubscribe from any channels we had open for unread counts.\n        \"\"\"\n        self.logger.info(\"ChatListScreen will unmount. Unsubscribing from all channels...\")\n        for channel_name in list(self.chat_subscriptions.keys()):\n            chat_id = self.chat_subscriptions[channel_name]\n            self.unsubscribe_from_unread_count(chat_id)\n\n    def load_chats(self, e=None):\n        \"\"\"\n        Loads the list of chats from the server and updates the UI.\n        Shows a loading spinner while fetching data.\n        \"\"\"\n        self.loading_container.visible = True\n        self.chat_list.visible = False\n        self.update()\n\n        response = self.chat_app.api_client.get_chats()\n        if response.success:\n            self.chat_list.controls.clear()\n            if not response.data:\n                self.chat_list.controls.append(\n                    ft.Text(\n                        \"No chats found. Search for users to start a new chat!\",\n                        style=ft.TextThemeStyle.BODY_LARGE,\n                        color=ft.colors.GREY_500\n                    )\n                )\n            else:\n                current_user_response = self.chat_app.api_client.get_current_user()\n                if current_user_response.success:\n                    self.current_user_id = current_user_response.data['id']\n                else:\n                    self.chat_app.show_error_dialog(\"Error\", {\"detail\": \"Failed to get current user.\"})\n                    self.loading_indicator.visible = False\n                    self.update()\n                    return\n\n                # Populate chat list\n                for chat in response.data:\n                    chat_name = ft.Text(chat['name'], style=ft.TextThemeStyle.TITLE_MEDIUM)\n\n                    # Prepare the list of chat members\n                    members = []\n                    for member in chat['members']:\n                        if member['id'] == self.current_user_id:\n                            members.append(\"You\")\n                        else:\n                            members.append(member['username'])\n\n                    members_text = ft.Text(\n                        \", \".join(members),\n                        style=ft.TextThemeStyle.BODY_SMALL,\n                        color=ft.colors.GREY_700\n                    )\n\n                    # Get unread messages count\n                    unread_count_response = self.chat_app.api_client.get_unread_messages_count(chat['id'])\n                    unread_count = unread_count_response.data if unread_count_response.success else 0\n\n                    # Create unread indicator\n                    unread_indicator = ft.Container(\n                        content=ft.Text(str(unread_count), color=ft.colors.WHITE, size=12),\n                        bgcolor=ft.colors.RED_500,\n                        border_radius=ft.border_radius.all(10),\n                        padding=ft.padding.all(5),\n                        visible=unread_count > 0,\n                        width=30,\n                        height=30,\n                        alignment=ft.alignment.center,\n                    )\n\n                    list_tile = ft.ListTile(\n                        title=ft.Row(\n                            [\n                                ft.Column(\n                                    [chat_name, members_text],\n                                    alignment=ft.MainAxisAlignment.CENTER,\n                                    spacing=5,\n                                    expand=True\n                                ),\n                                unread_indicator,\n                                ft.IconButton(\n                                    icon=ft.icons.EDIT,\n                                    on_click=lambda _, c=chat: self.edit_chat(c),\n                                    tooltip=\"Edit chat\"\n                                ),\n                                ft.IconButton(\n                                    icon=ft.icons.DELETE,\n                                    on_click=lambda _, c=chat: self.delete_chat(c),\n                                    tooltip=\"Delete chat\"\n                                )\n                            ],\n                            alignment=ft.MainAxisAlignment.SPACE_BETWEEN\n                        ),\n                        on_click=lambda _, chat_id=chat['id']: self.chat_app.show_chat(chat_id)\n                    )\n                    list_tile.data = chat  # store chat info\n                    list_tile.controls_dict = {'unread_indicator': unread_indicator}\n\n                    self.chat_list.controls.append(list_tile)\n                    # Subscribe to an unread count channel for this chat\n                    self.subscribe_to_unread_count(chat['id'])\n\n            self.logger.info(\"Chats loaded successfully.\")\n        else:\n            self.chat_app.show_error_dialog(\"Error Loading Chats\", response.error)\n            self.logger.error(f\"Failed to load chats: {response.error}\")\n\n        self.loading_container.visible = False\n        self.chat_list.visible = True\n        self.update()\n\n    def subscribe_to_unread_count(self, chat_id):\n        \"\"\"\n        Subscribes to Redis channel for unread count updates for a specific chat+user.\n        \"\"\"\n        channel_name = f\"chat:{chat_id}:unread_count:{self.current_user_id}\"\n        if channel_name not in self.chat_subscriptions:\n            self.chat_subscriptions[channel_name] = chat_id\n            self.chat_app.api_client.subscribe_to_channel(channel_name, self.update_unread_count)\n            self.logger.info(f\"Subscribed to unread count channel '{channel_name}' for chat ID {chat_id}\")\n\n    def unsubscribe_from_unread_count(self, chat_id):\n        \"\"\"\n        Unsubscribes from Redis channel for unread count updates for a specific chat+user.\n        \"\"\"\n        channel_name = f\"chat:{chat_id}:unread_count:{self.current_user_id}\"\n        if channel_name in self.chat_subscriptions:\n            self.chat_app.api_client.unsubscribe_from_channel(channel_name)\n            del self.chat_subscriptions[channel_name]\n            self.logger.info(f\"Unsubscribed from unread count channel '{channel_name}' for chat ID {chat_id}\")\n\n    def update_unread_count(self, data):\n        \"\"\"\n        Callback for Redis updates regarding unread count for the current user.\n        We reload the chat list to show the new count.\n        \"\"\"\n        try:\n            message = json.loads(data)\n            chat_id = message['chat_id']\n            unread_count = message['unread_count']\n            user_id = message['user_id']\n\n            if user_id != self.current_user_id:\n                return  # Ignore updates for other users\n\n            self.logger.info(f\"Received unread count update for chat ID {chat_id}: {unread_count}\")\n\n            # Reload chat list so unread counts can refresh\n            self.load_chats()\n\n            # If we are still mounted, this is safe:\n            if self.page:\n                self.page.update()\n            self.logger.info(f\"Updated UI for unread count on chat ID {chat_id}\")\n        except json.JSONDecodeError as e:\n            self.logger.error(f\"Failed to decode unread count message: {str(e)}\")\n        except Exception as e:\n            self.logger.error(f\"Error processing unread count update: {str(e)}\")\n\n    def edit_chat(self, chat):\n        \"\"\"\n        Opens a dialog to rename the chat.\n        \"\"\"\n        def update_chat_name(_e):\n            if new_name.value.strip():\n                response = self.chat_app.api_client.update_chat(chat['id'], {\"name\": new_name.value.strip()})\n                if response.success:\n                    self.load_chats()\n                    dialog.open = False\n                    if self.page:\n                        self.page.update()\n                    self.logger.info(f\"Chat ID {chat['id']} renamed to '{new_name.value}'\")\n                else:\n                    self.chat_app.show_error_dialog(\"Error Updating Chat\", response.error)\n                    self.logger.error(f\"Failed to update chat ID {chat['id']}: {response.error}\")\n            else:\n                self.chat_app.show_error_dialog(\"Invalid Input\", {\"detail\": \"Please enter a chat name.\"})\n                self.logger.warning(\"Attempted to update chat without providing a new name.\")\n\n        new_name = ft.TextField(value=chat['name'], label=\"Chat Name\")\n        dialog = ft.AlertDialog(\n            title=ft.Text(\"Edit Chat Name\"),\n            content=new_name,\n            actions=[\n                ft.TextButton(\"Cancel\", on_click=lambda _: self.close_dialog(dialog)),\n                ft.TextButton(\"Update\", on_click=update_chat_name),\n            ],\n        )\n        self.page.dialog = dialog\n        dialog.open = True\n        if self.page:\n            self.page.update()\n        self.logger.info(f\"Opened edit chat dialog for chat ID {chat['id']}\")\n\n    def delete_chat(self, chat):\n        \"\"\"\n        Opens a dialog to confirm chat deletion.\n        \"\"\"\n        def confirm_delete(_e):\n            response = self.chat_app.api_client.delete_chat(chat['id'])\n            if response.success:\n                # Remove the deleted chat from the chat list\n                self.chat_list.controls = [\n                    c for c in self.chat_list.controls\n                    if isinstance(c, ft.ListTile) and c.data['id'] != chat['id']\n                ]\n                if not self.chat_list.controls:\n                    self.chat_list.controls.append(\n                        ft.Text(\n                            \"No chats found. Search for users to start a new chat!\",\n                            style=ft.TextThemeStyle.BODY_LARGE,\n                            color=ft.colors.GREY_500\n                        )\n                    )\n                if self.page:\n                    self.page.update()\n                dialog.open = False\n                self.logger.info(f\"Deleted chat ID {chat['id']} successfully.\")\n            else:\n                self.chat_app.show_error_dialog(\"Error Deleting Chat\", response.error)\n                self.logger.error(f\"Failed to delete chat ID {chat['id']}: {response.error}\")\n\n        dialog = ft.AlertDialog(\n            title=ft.Text(\"Delete Chat\"),\n            content=ft.Text(f\"Are you sure you want to delete the chat '{chat['name']}'?\"),\n            actions=[\n                ft.TextButton(\"Cancel\", on_click=lambda _: self.close_dialog(dialog)),\n                ft.TextButton(\"Delete\", on_click=confirm_delete),\n            ],\n        )\n        self.page.dialog = dialog\n        dialog.open = True\n        if self.page:\n            self.page.update()\n        self.logger.info(f\"Opened delete chat dialog for chat ID {chat['id']}\")\n\n    def show_profile(self, _e):\n        \"\"\"\n        Navigates to the user's profile screen.\n        \"\"\"\n        self.chat_app.show_user_profile()\n        self.logger.info(\"Navigated to user profile.\")\n\n    def search_users(self, _e):\n        \"\"\"\n        Searches for users matching the search_input.\n        Results appear in self.search_results dropdown.\n        \"\"\"\n        search_term = self.search_input.value.strip()\n        if len(search_term) >= 1:\n            self.logger.info(f\"Searching users with term: '{search_term}'\")\n            response = self.chat_app.api_client.search_users(search_term)\n            if response.success:\n                self.search_results.options.clear()\n                if response.data:\n                    for user in response.data:\n                        self.search_results.options.append(\n                            ft.dropdown.Option(\n                                key=str(user['id']),\n                                text=user['username']\n                            )\n                        )\n                    self.logger.info(f\"Found {len(response.data)} users matching '{search_term}'.\")\n                else:\n                    self.search_results.options.append(\n                        ft.dropdown.Option(key=\"no_results\", text=\"No users found\")\n                    )\n                    self.logger.info(f\"No users found matching '{search_term}'.\")\n                self.search_results.visible = True\n            else:\n                self.chat_app.show_error_dialog(\"Error Searching Users\", response.error)\n                self.logger.error(f\"Failed to search users: {response.error}\")\n        else:\n            self.search_results.visible = False\n            self.logger.info(\"Search term is too short. Hiding search results.\")\n\n        if self.page:\n            self.page.update()\n\n    def start_chat_with_user(self, _e):\n        \"\"\"\n        Triggered by self.search_results dropdown on_change.\n        We attempt to start or load a chat with the selected user.\n        Then we navigate to the new or existing chat screen.\n        \"\"\"\n        selected_user_id = self.search_results.value\n        if selected_user_id and selected_user_id != \"no_results\":\n            self.logger.info(f\"Starting chat with user ID {selected_user_id}\")\n            response = self.chat_app.api_client.start_chat(int(selected_user_id))\n            if response.success:\n                # Clear out the search UI BEFORE navigating away:\n                self.search_input.value = \"\"\n                self.search_results.value = None\n                self.search_results.options.clear()\n                self.search_results.visible = False\n\n                # Instead of calling self.update(), we call the page-level update\n                # because we might be about to leave ChatListScreen\n                if self.page:\n                    self.page.update()\n\n                # Now that we cleaned up the search fields, let's go to the chat:\n                self.chat_app.show_chat(response.data['id'])\n                self.logger.info(f\"Chat started with user ID {selected_user_id}\")\n            else:\n                self.chat_app.show_error_dialog(\"Error Starting Chat\", response.error)\n                self.logger.error(f\"Failed to start chat with user ID {selected_user_id}: {response.error}\")\n        else:\n            # Reset or hide search if user chooses \"no_results\"\n            self.search_input.value = \"\"\n            self.search_results.value = None\n            self.search_results.options.clear()\n            self.search_results.visible = False\n            if self.page:\n                self.page.update()\n            self.logger.info(\"Reset search input and results; no user selected.\")\n\n    def close_dialog(self, dialog):\n        \"\"\"\n        Closes a dialog and forces a page update (if still mounted).\n        \"\"\"\n        dialog.open = False\n        self.page.dialog = None\n        if self.page:\n            self.page.update()\n        self.logger.info(\"Closed dialog.\")\n"}
{"type": "source_file", "path": "chat_service/app/infrastructure/event_handlers.py", "content": "# app/infrastructure/event_handlers.py\nimport json\nfrom typing import Any, Dict\nfrom app.domain.events import (MessageCreated, MessageUpdated, MessageDeleted,\n                               MessageStatusUpdated, UnreadCountUpdated, MessageEvent)\n\nclass EventHandlers:\n    def __init__(self, redis_client):\n        self.redis_client = redis_client\n\n    async def publish_message_event(self, event: MessageEvent, additional_data: Dict[str, Any] = None):\n        channel_name = f\"chat:{event.chat_id}\"\n\n        message_data = event.model_dump()\n        message_data['id'] = message_data.pop('message_id')\n\n        if additional_data:\n            message_data.update(additional_data)\n\n        message_json = json.dumps(message_data, default=str)\n        await self.redis_client.publish(channel_name, message_json)\n\n    async def publish_message_created(self, event: MessageCreated):\n        await self.publish_message_event(event)\n\n    async def publish_message_updated(self, event: MessageUpdated):\n        await self.publish_message_event(event, {\"updated_at\": event.updated_at})\n\n    async def publish_message_deleted(self, event: MessageDeleted):\n        await self.publish_message_event(event, {\n            \"content\": \"<This message has been deleted>\",\n            \"updated_at\": event.updated_at\n        })\n\n    async def publish_message_status_updated(self, event: MessageStatusUpdated):\n        channel_name = f\"chat:{event.chat_id}:status\"\n        status_data = json.dumps({\n            \"message_id\": event.message_id,\n            \"user_id\": event.user_id,\n            \"is_read\": event.is_read,\n            \"read_at\": event.read_at\n        }, default=str)\n        await self.redis_client.publish(channel_name, status_data)\n\n    async def publish_unread_count_updated(self, event: UnreadCountUpdated):\n        channel_name = f\"chat:{event.chat_id}:unread_count:{event.user_id}\"\n        unread_count_data = json.dumps({\n            \"chat_id\": event.chat_id,\n            \"unread_count\": event.unread_count,\n            \"user_id\": event.user_id\n        })\n        await self.redis_client.publish(channel_name, unread_count_data)"}
{"type": "source_file", "path": "chat_service/app/infrastructure/uow.py", "content": "# app/infrastructure/uow.py\n\nfrom typing import Dict, Any, Type\n\n\nclass UoWModel:\n    def __init__(self, model: Any, uow: 'UnitOfWork'):\n        self.__dict__['_model'] = model\n        self.__dict__['_uow'] = uow\n\n    def __getattr__(self, key):\n        return getattr(self._model, key)\n\n    def __setattr__(self, key, value):\n        setattr(self._model, key, value)\n        # if it's not a new model, register it as dirty,\n        # otherwise, it's already in the new models and doesn't need to be registered\n        # as dirty cause it doesnt exist in the database yet\n        if id(self._model) not in self._uow.new:\n            self._uow.register_dirty(self._model)\n\n\nclass UnitOfWork:\n    def __init__(self):\n        self.dirty: Dict[int, Any] = {}\n        self.new: Dict[int, Any] = {}\n        self.deleted: Dict[int, Any] = {}\n        self.mappers: Dict[Type, Any] = {}\n\n    def register_dirty(self, model: Any):\n        if isinstance(model, UoWModel):\n            model = model._model\n        model_id = id(model)\n        if model_id not in self.new:\n            self.dirty[model_id] = model\n\n    def register_deleted(self, model: Any):\n        if isinstance(model, UoWModel):\n            model = model._model\n        model_id = id(model)\n        if model_id in self.new:\n            # If the model is new, just delete it and go back\n            self.new.pop(model_id)\n            return\n        elif model_id in self.dirty:\n            # If model was supposed to be updated, remove it from dirty\n            self.dirty.pop(model_id)\n\n        # Always add to deleted, regardless of previous state\n        self.deleted[model_id] = model\n\n    def register_new(self, model: Any):\n        if isinstance(model, UoWModel):\n            model = model._model\n        model_id = id(model)\n        self.new[model_id] = model\n        return UoWModel(model, self)\n\n    async def commit(self):\n        for model in self.new.values():\n            await self.mappers[type(model)].insert(model)\n        for model in self.dirty.values():\n            await self.mappers[type(model)].update(model)\n        for model in self.deleted.values():\n            await self.mappers[type(model)].delete(model)\n\n"}
{"type": "source_file", "path": "chat_service/app/infrastructure/redis_client.py", "content": "# app/infrastructure/redis_client.py\nimport redis.asyncio as redis\nimport logging\n\nclass RedisClient:\n    def __init__(self, host: str, port: int, logger: logging.Logger):\n        self.host = host\n        self.port = port\n        self.client = None\n        self.logger = logger\n\n    async def connect(self):\n        self.client = redis.Redis(\n            host=self.host,\n            port=self.port,\n            db=0,\n            decode_responses=True,\n        )\n        try:\n            await self.client.ping()\n            self.logger.info(f\"Successfully connected to Redis at {self.host}:{self.port}\")\n        except redis.ConnectionError as e:\n            self.logger.error(f\"Failed to connect to Redis: {str(e)}\")\n            self.logger.error(f\"Redis host: {self.host}, Redis port: {self.port}\")\n            raise e\n\n    async def disconnect(self):\n        if self.client:\n            await self.client.close()\n            self.logger.info(\"Disconnected from Redis\")\n\n    async def publish(self, channel: str, message: str):\n        await self.client.publish(channel, message)\n        self.logger.debug(f\"Published message to channel {channel}\")"}
{"type": "source_file", "path": "chat_service/app/infrastructure/event_dispatcher.py", "content": "# app/infrastructure/event_dispatcher.py\nfrom collections import defaultdict\nfrom typing import Callable, Dict, List\n\nfrom app.domain.events import Event\n\n\nclass EventDispatcher:\n    def __init__(self):\n        self.handlers: Dict[str, List[Callable]] = defaultdict(list)\n\n    def register(self, event_type: str, handler: Callable):\n        self.handlers[event_type].append(handler)\n\n    async def dispatch(self, event: Event):\n        event_type = event.__class__.__name__\n        for handler in self.handlers[event_type]:\n            await handler(event)\n"}
{"type": "source_file", "path": "chat_service/app/infrastructure/schemas.py", "content": "# app/infrastructure/schemas.py\nfrom datetime import datetime\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, EmailStr, Field, ConfigDict\n\n\nclass UserBase(BaseModel):\n    username: str\n    email: EmailStr\n\n\nclass UserBasic(BaseModel):\n    id: int\n    username: str\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass UserCreate(UserBase):\n    password: str = Field(..., min_length=8)\n\n\nclass UserUpdate(BaseModel):\n    email: Optional[EmailStr] = None\n    password: Optional[str] = Field(None, min_length=8)\n    username: Optional[str] = None\n    is_active: Optional[bool] = None  # sort of soft deleting\n\n\nclass User(UserBase):\n    id: int\n    created_at: datetime\n    is_active: bool\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass ChatBase(BaseModel):\n    name: str\n\n\nclass ChatCreate(ChatBase):\n    member_ids: List[int]\n\n\nclass ChatUpdate(BaseModel):\n    name: Optional[str] = None\n    member_ids: Optional[List[int]] = None\n\n\nclass Chat(ChatBase):\n    id: int\n    created_at: datetime\n    members: List[User] = Field(default_factory=list)\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass MessageBase(BaseModel):\n    content: str\n\n\nclass MessageCreate(MessageBase):\n    chat_id: int\n\n\nclass MessageUpdate(BaseModel):\n    content: str\n\n\nclass MessageStatus(BaseModel):\n    user_id: int\n    is_read: bool\n    read_at: Optional[datetime] = None\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass MessageStatusUpdate(BaseModel):\n    is_read: bool = True\n\n\nclass Message(MessageBase):\n    id: int\n    created_at: datetime\n    updated_at: Optional[datetime] = None\n    is_deleted: bool\n    chat_id: int\n    user_id: int\n    user: UserBasic\n    statuses: List[MessageStatus] = []\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass TokenBase(BaseModel):\n    access_token: str\n    refresh_token: str\n    token_type: str\n\n\nclass TokenCreate(TokenBase):\n    expires_at: datetime\n    user_id: int\n\n\nclass TokenUpdate(BaseModel):\n    access_token: Optional[str] = None\n    refresh_token: Optional[str] = None\n    expires_at: Optional[datetime] = None\n\n\nclass Token(TokenBase):\n    id: int\n    expires_at: datetime\n    user_id: int\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n    exp: Optional[int] = None\n\n\nclass TokenResponse(BaseModel):\n    access_token: str\n    refresh_token: str\n    token_type: str\n    expires_at: datetime\n    user_id: int\n\n\nclass LoginRequest(BaseModel):\n    username: str\n    password: str\n\n\nclass RefreshTokenRequest(BaseModel):\n    refresh_token: str\n"}
{"type": "source_file", "path": "chat_service/app/infrastructure/security.py", "content": "import datetime\nimport secrets\nfrom typing import Optional\n\nimport jwt  # Import PyJWT\nfrom jwt import ExpiredSignatureError, InvalidTokenError\nfrom passlib.context import CryptContext\n\n\nclass SecurityService:\n    def __init__(self, config):\n        self.config = config\n        self.pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n    def verify_password(self, plain_password, hashed_password):\n        return self.pwd_context.verify(plain_password, hashed_password)\n\n    def get_password_hash(self, password):\n        return self.pwd_context.hash(password)\n\n    def create_access_token(self, data: dict, expires_delta: Optional[datetime.timedelta] = None):\n        to_encode = data.copy()\n        to_encode.update({\"nonce\": secrets.token_hex(8)})  # Add a random nonce\n        if expires_delta:\n            expire = datetime.datetime.now(datetime.timezone.utc) + expires_delta\n        else:\n            expire = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(minutes=15)\n        to_encode.update({\"exp\": expire})\n        encoded_jwt = jwt.encode(to_encode, self.config.SECRET_KEY, algorithm=self.config.ALGORITHM)\n        return encoded_jwt, expire\n\n    def create_refresh_token(self, data: dict):\n        to_encode = data.copy()\n        expire = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(\n            days=self.config.REFRESH_TOKEN_EXPIRE_DAYS)\n        to_encode.update({\"exp\": expire})\n        encoded_jwt = jwt.encode(to_encode, self.config.REFRESH_SECRET_KEY, algorithm=self.config.ALGORITHM)\n        return encoded_jwt, expire\n\n    def decode_access_token(self, token: str):\n        try:\n            payload = jwt.decode(token, self.config.SECRET_KEY, algorithms=[self.config.ALGORITHM])\n            username: str = payload.get(\"sub\")\n            if username is None:\n                return None\n            return username\n        except (ExpiredSignatureError, InvalidTokenError):\n            return None\n\n    def decode_refresh_token(self, token: str):\n        try:\n            payload = jwt.decode(token, self.config.REFRESH_SECRET_KEY, algorithms=[self.config.ALGORITHM])\n            username: str = payload.get(\"sub\")\n            if username is None:\n                return None\n            return username\n        except (ExpiredSignatureError, InvalidTokenError):\n            return None\n"}
{"type": "source_file", "path": "chat_service/app/infrastructure/models.py", "content": "# app/infrastructure/models.py\nfrom app.domain.entities import (User as UserEntity, Chat as ChatEntity,\n                                 Message as MessageEntity, Token as TokenEntity,\n                                 MessageStatus as MessageStatusEntity)\nfrom app.infrastructure.database import Base\nfrom sqlalchemy import Column, Boolean, Integer, String, DateTime, ForeignKey, Table\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\n\nchat_members = Table(\n    'chat_members',\n    Base.metadata,\n    Column('chat_id', Integer, ForeignKey('chats.id'), primary_key=True),\n    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True)\n)\n\n\nclass User(Base, UserEntity):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    username = Column(String, unique=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    is_active = Column(Boolean, default=True)\n\n    chats = relationship(\"Chat\", secondary=chat_members, back_populates=\"members\", lazy=\"selectin\")\n    messages = relationship(\"Message\", back_populates=\"user\", lazy=\"selectin\")\n    tokens = relationship(\"Token\", back_populates=\"user\", lazy=\"selectin\")\n    message_statuses = relationship(\"MessageStatus\", back_populates=\"user\", lazy=\"selectin\")\n\n\nclass Chat(Base, ChatEntity):\n    __tablename__ = \"chats\"\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    name = Column(String)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n\n    members = relationship(\"User\", secondary=chat_members, back_populates=\"chats\", lazy=\"selectin\")\n    messages = relationship(\"Message\", back_populates=\"chat\", lazy=\"selectin\")\n\n\nclass Message(Base, MessageEntity):\n    __tablename__ = \"messages\"\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    content = Column(String)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    is_deleted = Column(Boolean, default=False)\n    chat_id = Column(Integer, ForeignKey(\"chats.id\"))\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n\n    chat = relationship(\"Chat\", back_populates=\"messages\", lazy=\"selectin\")\n    user = relationship(\"User\", back_populates=\"messages\", lazy=\"selectin\")\n    statuses = relationship(\"MessageStatus\", back_populates=\"message\", lazy=\"selectin\")\n\n\nclass Token(Base, TokenEntity):\n    __tablename__ = \"tokens\"\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    access_token = Column(String, unique=True, index=True)\n    refresh_token = Column(String, unique=True, index=True)\n    token_type = Column(String)\n    expires_at = Column(DateTime(timezone=True))\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n\n    user = relationship(\"User\", back_populates=\"tokens\", lazy=\"selectin\")\n\n\nclass MessageStatus(Base, MessageStatusEntity):\n    __tablename__ = \"message_statuses\"\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    message_id = Column(Integer, ForeignKey(\"messages.id\"))\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    is_read = Column(Boolean, default=False)\n    read_at = Column(DateTime(timezone=True), nullable=True)\n\n    message = relationship(\"Message\", back_populates=\"statuses\", lazy=\"selectin\")\n    user = relationship(\"User\", back_populates=\"message_statuses\", lazy=\"selectin\")\n"}
{"type": "source_file", "path": "chat_service/app/infrastructure/database.py", "content": "# app/infrastructure/database.py\nfrom contextlib import asynccontextmanager\n\nfrom sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession\nfrom sqlalchemy.orm import declarative_base, sessionmaker\n\nBase = declarative_base()\n\n\nclass Database:\n    def __init__(self, engine: AsyncEngine, session_factory: sessionmaker = None):\n        self.engine = engine\n        self.SessionLocal = session_factory or sessionmaker(\n            self.engine, class_=AsyncSession, expire_on_commit=False\n        )\n\n    async def connect(self):\n        async with self.engine.begin() as conn:\n            import app.infrastructure.models  # noqa: F401\n            await conn.run_sync(Base.metadata.create_all)\n\n    async def disconnect(self):\n        await self.engine.dispose()\n\n    @asynccontextmanager\n    async def session(self):\n        async with self.SessionLocal() as session:\n            yield session\n\n    async def get_session(self) -> AsyncSession:\n        async with self.session() as session:\n            yield session\n\n\n# Factory function to create Database instance\ndef create_database(engine: AsyncEngine, session_factory: sessionmaker = None) -> Database:\n    return Database(engine, session_factory)\n"}
{"type": "source_file", "path": "chat_service/app/infrastructure/data_mappers.py", "content": "# app/infrastructure/data_mappers.py\n\nfrom typing import Protocol, TypeVar\n\nfrom app.infrastructure import models\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nModelT = TypeVar('ModelT')\n\n\nclass DataMapper(Protocol[ModelT]):\n    async def insert(self, model: ModelT):\n        raise NotImplementedError\n\n    async def delete(self, model: ModelT):\n        raise NotImplementedError\n\n    async def update(self, model: ModelT):\n        raise NotImplementedError\n\n\nclass UserMapper(DataMapper[models.User]):\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def insert(self, model: models.User):\n        self.session.add(model)\n        await self.session.flush()\n\n    async def delete(self, model: models.User):\n        await self.session.delete(model)\n\n    async def update(self, model: models.User):\n        await self.session.merge(model)\n\n\nclass ChatMapper(DataMapper[models.Chat]):\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def insert(self, model: models.Chat):\n        self.session.add(model)\n        await self.session.flush()\n\n    async def delete(self, model: models.Chat):\n        await self.session.delete(model)\n\n    async def update(self, model: models.Chat):\n        await self.session.merge(model)\n\n\nclass MessageMapper(DataMapper[models.Message]):\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def insert(self, model: models.Message):\n        self.session.add(model)\n        await self.session.flush()\n\n    async def delete(self, model: models.Message):\n        await self.session.delete(model)\n\n    async def update(self, model: models.Message):\n        await self.session.merge(model)\n\n\nclass TokenMapper(DataMapper[models.Token]):\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def insert(self, model: models.Token):\n        self.session.add(model)\n        await self.session.flush()\n\n    async def delete(self, model: models.Token):\n        await self.session.delete(model)\n\n    async def update(self, model: models.Token):\n        await self.session.merge(model)\n"}
{"type": "source_file", "path": "chat_service/app/interactors/__init__.py", "content": ""}
{"type": "source_file", "path": "chat_service/app/main.py", "content": "# app/main.py\nimport logging\nimport sys\nfrom contextlib import asynccontextmanager\n\nfrom app.api import users, chats, messages, auth\nfrom app.config import AppConfig\nfrom app.infrastructure.database import create_database\nfrom app.infrastructure.event_dispatcher import EventDispatcher\nfrom app.infrastructure.event_handlers import EventHandlers\nfrom app.infrastructure.redis_client import RedisClient\nfrom app.infrastructure.security import SecurityService\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\n\nclass Application:\n    def __init__(self, config: AppConfig):\n        self.config = config\n        self.logger = self.setup_logger()\n        engine = create_async_engine(config.DATABASE_URL, echo=False)\n        self.database = create_database(engine)\n        self.redis_client = RedisClient(config.REDIS_HOST, config.REDIS_PORT, self.logger)\n        self.event_dispatcher = EventDispatcher()\n        self.security_service = SecurityService(config)\n        self.event_handlers = EventHandlers(self.redis_client)\n\n        # Register event handlers\n        self.event_dispatcher.register(\"MessageCreated\", self.event_handlers.publish_message_created)\n        self.event_dispatcher.register(\"MessageUpdated\", self.event_handlers.publish_message_updated)\n        self.event_dispatcher.register(\"MessageDeleted\", self.event_handlers.publish_message_deleted)\n        self.event_dispatcher.register(\"MessageStatusUpdated\", self.event_handlers.publish_message_status_updated)\n        self.event_dispatcher.register(\"UnreadCountUpdated\", self.event_handlers.publish_unread_count_updated)\n\n    @asynccontextmanager\n    async def lifespan(self, app: FastAPI):\n        await self.database.connect()\n        await self.redis_client.connect()\n        yield\n        await self.database.disconnect()\n        await self.redis_client.disconnect()\n\n    def setup_logger(self):\n        logger = logging.getLogger('ChatAPI')\n        logger.setLevel(logging.INFO)\n\n        c_handler = logging.StreamHandler(sys.stdout)\n        # file logs turned off for now\n        # f_handler = RotatingFileHandler('chat_api.log', maxBytes=10 * 1024 * 1024, backupCount=5)\n\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        c_handler.setFormatter(formatter)\n        # f_handler.setFormatter(formatter)\n\n        logger.addHandler(c_handler)\n        # logger.addHandler(f_handler)\n\n        return logger\n\n    def create_app(self) -> FastAPI:\n        app = FastAPI(\n            title=self.config.PROJECT_NAME,\n            version=self.config.PROJECT_VERSION,\n            description=self.config.PROJECT_DESCRIPTION,\n            openapi_url=f\"{self.config.API_V1_STR}/openapi.json\",\n            lifespan=self.lifespan\n        )\n\n        app.state.config = self.config\n        app.state.security_service = self.security_service\n        app.state.event_dispatcher = self.event_dispatcher\n        app.state.database = self.database\n        app.state.logger = self.logger\n\n        # Create routers\n        app.include_router(auth.router, prefix=f\"{self.config.API_V1_STR}/auth\", tags=[\"auth\"])\n        app.include_router(users.router, prefix=f\"{self.config.API_V1_STR}/users\", tags=[\"users\"])\n        app.include_router(chats.router, prefix=f\"{self.config.API_V1_STR}/chats\", tags=[\"chats\"])\n        app.include_router(messages.router, prefix=f\"{self.config.API_V1_STR}/messages\", tags=[\"messages\"])\n\n        @app.exception_handler(Exception)\n        async def global_exception_handler(request: Request, exc: Exception):\n            return JSONResponse(\n                status_code=500,\n                content={\"message\": f\"An unexpected error occurred: {str(exc)}\"}\n            )\n\n        return app\n\n\ndef create():\n    config = AppConfig()\n    application = Application(config)\n    app = application.create_app()\n    application.logger.info(\"Application created and configured\")\n\n    return app\n\n\napp = create()\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Welcome to the Chat API\"}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n"}
{"type": "source_file", "path": "chat_service/app/interactors/user_interactor.py", "content": "# app/interactors/user_interactor.py\nfrom typing import List, Optional\n\nfrom app.infrastructure import models\nfrom app.gateways.user_gateway import IUserGateway\nfrom app.infrastructure import schemas\nfrom app.infrastructure.security import SecurityService\nfrom app.infrastructure.uow import UoWModel\n\n\nclass UserInteractor:\n    def __init__(\n            self,\n            security_service: SecurityService,\n            user_gateway: IUserGateway\n    ):\n        self.security_service = security_service\n        self.user_gateway = user_gateway\n\n    async def get_user(\n            self,\n            user_id: int\n    ) -> Optional[schemas.User]:\n        user: Optional[UoWModel] = await self.user_gateway.get_user(user_id)\n        return schemas.User.model_validate(user._model) if user else None\n\n    async def get_user_by_username(\n            self,\n            username: str\n    ) -> Optional[schemas.User]:\n        user: Optional[UoWModel] = await self.user_gateway.get_by_username(username)\n        return schemas.User.model_validate(user._model) if user else None\n\n    async def get_user_by_email(self, email: str) -> Optional[schemas.User]:\n        user: Optional[UoWModel] = await self.user_gateway.get_by_email(email)\n        return schemas.User.model_validate(user._model) if user else None\n\n    async def get_users(\n            self,\n            skip: int = 0,\n            limit: int = 100,\n            username: Optional[str] = None\n    ) -> List[schemas.User]:\n        users: List[UoWModel] = await self.user_gateway.get_all(skip, limit, username)\n        return [\n            schemas.User.model_validate(user._model)\n            for user in users\n        ]\n\n    async def create_user(self,\n                          user: schemas.UserCreate) -> Optional[schemas.User]:\n        new_user: Optional[models.User] = await self.user_gateway.create_user(user, self.security_service)\n        return schemas.User.model_validate(new_user) if new_user else None\n\n    async def update_user(\n            self,\n            user_id: int,\n            user_update: schemas.UserUpdate\n    ) -> Optional[schemas.User]:\n        user: Optional[UoWModel] = await self.user_gateway.get_user(user_id)\n        if not user:\n            return None\n        updated_user = await self.user_gateway.update_user(user,\n                                                           user_update,\n                                                           self.security_service)\n        return schemas.User.model_validate(updated_user._model)\n\n    async def delete_user(\n            self,\n            user_id: int\n    ) -> bool:\n        user: Optional[UoWModel] = await self.user_gateway.delete_user(user_id)\n        if not user:\n            return False\n        return True\n\n    async def search_users(\n            self,\n            query: str,\n            current_user_id: int\n    ) -> List[schemas.User]:\n        users: List[UoWModel] = await self.user_gateway.search_users(query, current_user_id)\n        return [\n            schemas.User.model_validate(user._model)\n            for user in users\n        ]\n\n    async def verify_user_password(\n            self,\n            username: str,\n            password: str\n    ) -> Optional[schemas.User]:\n        user: Optional[UoWModel] = await self.user_gateway.get_by_username(username)\n        if not user:\n            return None\n        if await self.user_gateway.verify_password(user, password, self.security_service):\n            return schemas.User.model_validate(user._model)\n        return None"}
{"type": "source_file", "path": "chat_service/app/interactors/chat_interactor.py", "content": "# app/interactors/chat_interactor.py\nfrom typing import List, Optional, Dict\n\nfrom app.gateways.interfaces import IChatGateway, IUserGateway\nfrom app.infrastructure import schemas\n\n\nclass ChatInteractor:\n    def __init__(self,\n                 chat_gateway: IChatGateway,\n                 user_gateway: IUserGateway):\n        self.chat_gateway = chat_gateway\n        self.user_gateway = user_gateway\n\n    async def get_chat(\n            self,\n            chat_id: int,\n            user_id: int\n    ) -> Optional[schemas.Chat]:\n        chat = await self.chat_gateway.get_chat(chat_id, user_id)\n        return schemas.Chat.model_validate(chat) if chat else None\n\n    async def get_chats(\n            self,\n            user_id: int,\n            skip: int = 0,\n            limit: int = 100,\n            name: Optional[str] = None\n    ) -> List[schemas.Chat]:\n        chats = await self.chat_gateway.get_all(user_id, skip, limit, name)\n        return [\n            schemas.Chat.model_validate(chat)\n            for chat in chats\n        ]\n\n    async def create_chat(\n            self,\n            chat: schemas.ChatCreate,\n            user_id: int\n    ) -> Optional[schemas.Chat]:\n        # Verify all members exist\n        for member_id in chat.member_ids:\n            user = await self.user_gateway.get_user(member_id)\n            if not user:\n                return None  # Invalid member\n\n        new_chat = await self.chat_gateway.create_chat(chat, user_id)\n        return schemas.Chat.model_validate(new_chat) if new_chat else None\n\n    async def update_chat(\n            self,\n            chat_id: int,\n            chat_update: schemas.ChatUpdate,\n            user_id: int\n    ) -> Optional[schemas.Chat]:\n        chat = await self.chat_gateway.get_chat(chat_id, user_id)\n        if not chat:\n            return None\n        for key, value in chat_update.model_dump(exclude_unset=True).items():\n            setattr(chat, key, value)\n        return schemas.Chat.model_validate(chat)\n\n    async def delete_chat(\n            self,\n            chat_id: int,\n            user_id: int\n    ) -> bool:\n        chat = await self.chat_gateway.get_chat(chat_id, user_id)\n        if chat:\n            await self.chat_gateway.delete_chat(chat_id, user_id)\n            return True\n        return False\n\n    async def add_member(\n            self,\n            chat_id: int,\n            user_id: int,\n            current_user_id: int\n    ) -> Optional[schemas.Chat]:\n        # Verify that the current user is authorized to add members\n        chat = await self.get_chat(chat_id, current_user_id)\n        if not chat:\n            return None\n\n        # Add the new member via the gateway\n        updated_chat = await self.chat_gateway.add_member(chat_id, user_id, current_user_id)\n        if not updated_chat:\n            return None\n\n        return schemas.Chat.model_validate(updated_chat)\n\n    async def remove_member(\n            self,\n            chat_id: int,\n            user_id: int,\n            current_user_id: int\n    ) -> Optional[schemas.Chat]:\n        # Verify that the current user is authorized to remove members\n        chat = await self.get_chat(chat_id, current_user_id)\n        if not chat:\n            return None\n\n        success = await self.chat_gateway.remove_member(chat_id, user_id, current_user_id)\n        return chat if success else None\n\n    async def start_chat(\n            self,\n            current_user_id: int,\n            other_user_id: int\n    ) -> Optional[schemas.Chat]:\n        new_chat = await self.chat_gateway.start_chat(current_user_id, other_user_id)\n        return schemas.Chat.model_validate(new_chat) if new_chat else None\n\n    async def get_unread_counts_for_chat_members(\n            self,\n            chat_id: int,\n            current_user_id: int\n    ) -> Dict[int, int]:\n        return await self.chat_gateway.get_unread_counts_for_chat_members(chat_id, current_user_id)\n\n    async def get_unread_messages_count(\n            self,\n            chat_id: int,\n            user_id: int\n    ) -> Optional[int]:\n        chat = await self.chat_gateway.get_chat(chat_id, user_id)\n        if not chat:\n            return None\n        return await self.chat_gateway.get_unread_messages_count(chat_id, user_id)\n"}
{"type": "source_file", "path": "chat_service/app/interactors/token_interactor.py", "content": "# app/interactors/token_interactor.py\nfrom typing import Optional\n\nfrom app.gateways.interfaces import ITokenGateway\nfrom app.infrastructure import schemas\n\n\nclass TokenInteractor:\n    def __init__(self, token_gateway: ITokenGateway):\n        self.token_gateway = token_gateway\n\n    async def get_token_by_user_id(\n            self,\n            user_id: int\n    ) -> Optional[schemas.Token]:\n        token = await self.token_gateway.get_by_user_id(user_id)\n        return schemas.Token.model_validate(token._model) if token else None\n\n    async def get_token_by_access_token(\n            self,\n            access_token: str\n    ) -> Optional[schemas.Token]:\n        token = await self.token_gateway.get_by_access_token(access_token)\n        return schemas.Token.model_validate(token._model) if token else None\n\n    async def get_token_by_refresh_token(\n            self,\n            refresh_token: str\n    ) -> Optional[schemas.Token]:\n        token = await self.token_gateway.get_by_refresh_token(refresh_token)\n        return schemas.Token.model_validate(token._model) if token else None\n\n    async def delete_token_by_access_token(\n            self,\n            access_token: str\n    ) -> bool:\n        deleted = await self.token_gateway.delete_token_by_access_token(access_token)\n        return deleted\n\n    async def delete_token_by_refresh_token(self,\n                                            refresh_token: str) -> bool:\n        return await self.token_gateway.delete_token_by_refresh_token(refresh_token)\n\n    async def invalidate_refresh_token(self, refresh_token: str) -> bool:\n        return await self.token_gateway.invalidate_refresh_token(refresh_token)\n\n    async def create_token(self, token_create: schemas.TokenCreate) -> schemas.TokenResponse:\n        token = await self.token_gateway.create_token(token_create)\n        token_dict = {\n            \"access_token\": token._model.access_token,\n            \"refresh_token\": token._model.refresh_token,\n            \"token_type\": token._model.token_type,\n            \"expires_at\": token._model.expires_at,\n            \"user_id\": token._model.user_id\n        }\n        return schemas.TokenResponse.model_validate(token_dict)\n"}
{"type": "source_file", "path": "main.py", "content": "import flet as ft\n\nfrom chat.app import ChatApp\n\n\ndef main(page: ft.Page):\n    page.window.width = 400\n    ChatApp(page)\n\n\nft.app(target=main, view=ft.AppView.FLET_APP)\n"}
{"type": "source_file", "path": "chat_service/app/interactors/message_interactor.py", "content": "# app/interactors/message_interactor.py\nfrom typing import List, Optional\n\nfrom app.gateways.interfaces import IMessageGateway\nfrom app.infrastructure import schemas\n\n\nclass MessageInteractor:\n    def __init__(self, message_gateway: IMessageGateway):\n        self.message_gateway = message_gateway\n\n    async def get_message(\n            self,\n            message_id: int,\n            user_id: int\n    ) -> Optional[schemas.Message]:\n        message = await self.message_gateway.get_message(message_id, user_id)\n        return schemas.Message.model_validate(message) if message else None\n\n    async def get_messages(\n            self,\n            chat_id: int,\n            user_id: int,\n            skip: int = 0,\n            limit: int = 100,\n            content: Optional[str] = None\n    ) -> List[schemas.Message]:\n        messages = await self.message_gateway.get_all(chat_id, user_id, skip, limit, content)\n        return [\n            schemas.Message.model_validate(message)\n            for message in messages\n        ]\n\n    async def update_message_status(\n            self,\n            message_id: int,\n            user_id: int,\n            status_update: schemas.MessageStatusUpdate\n    ) -> Optional[schemas.Message]:\n        updated_message = await self.message_gateway.update_message_status(message_id, user_id, status_update)\n        return schemas.Message.model_validate(updated_message) if updated_message else None\n\n    async def create_message(\n            self,\n            message: schemas.MessageCreate,\n            user_id: int\n    ) -> schemas.Message:\n        new_message = await self.message_gateway.create_message(message, user_id)\n        return schemas.Message.model_validate(new_message)\n\n    async def update_message(\n            self,\n            message_id: int,\n            message_update: schemas.MessageUpdate,\n            user_id: int\n    ) -> Optional[schemas.Message]:\n        updated_message = await self.message_gateway.update_message(message_id, message_update, user_id)\n        return schemas.Message.model_validate(updated_message) if updated_message else None\n\n    async def delete_message(\n            self,\n            message_id: int,\n            user_id: int\n    ) -> Optional[schemas.Message]:\n        deleted_message = await self.message_gateway.delete_message(message_id, user_id)\n        return schemas.Message.model_validate(deleted_message) if deleted_message else None\n"}

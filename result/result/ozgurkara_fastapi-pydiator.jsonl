{"repo_info": {"repo_name": "fastapi-pydiator", "repo_owner": "ozgurkara", "repo_url": "https://github.com/ozgurkara/fastapi-pydiator"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/integration/resources/healt_check/test_health_check_resource.py", "content": "from starlette.status import HTTP_200_OK\n\n\nclass TestTodo:\n\n    def test_get(self, test_app):\n        response = test_app.get(\"/health-check\")\n\n        assert response.status_code == HTTP_200_OK\n        assert response.content == b\"OK\"\n"}
{"type": "test_file", "path": "tests/unit/data/todo/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/integration/resources/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/data/todo/usecases/test_delete_todo_by_id_data.py", "content": "from unittest import mock\n\nfrom app.data.todo.usecases.delete_todo_by_id_data import DeleteTodoByIdDataRequest, DeleteTodoByIdDataUseCase, \\\n    DeleteTodoByIdDataResponse\nfrom pydiator_core.mediatr import pydiator\nfrom app.resources.todo.usecases.delete_todo_by_id import DeleteTodoByIdResponse\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestDeleteTodoByIdDataUseCase(BaseTestCase):\n    def setUp(self):\n        self.register_request(DeleteTodoByIdDataRequest(), DeleteTodoByIdDataUseCase())\n\n    @mock.patch(\"app.data.todo.usecases.delete_todo_by_id_data.fake_todo_db\")\n    def test_handle_return_success(self, mock_fake_todo_db):\n        # Given\n        id_val = 1\n        mock_fake_todo_db.__iter__.return_value = [{\"id\": id_val, \"title\": \"title 1\"}]\n        request = DeleteTodoByIdDataRequest(id=id_val)\n        expected_response = DeleteTodoByIdResponse(success=True)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n        assert mock_fake_todo_db.remove.called\n        assert mock_fake_todo_db.remove.call_count == 1\n\n    @mock.patch(\"app.data.todo.usecases.delete_todo_by_id_data.fake_todo_db\")\n    def test_handle_return_success_false_when_todo_is_not_exist(self, mock_fake_todo_db):\n        # Given\n        mock_fake_todo_db.__iter__.return_value = []\n        request = DeleteTodoByIdDataRequest(id=1)\n        expected_response = DeleteTodoByIdDataResponse(success=False)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n"}
{"type": "test_file", "path": "tests/unit/utils/test_cache_provider.py", "content": "from unittest import mock\n\nfrom pytest import raises\n\nfrom app.utils.cache_provider import CacheProvider\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestCacheProvider(BaseTestCase):\n    def setUp(self) -> None:\n        pass\n\n    def tearDown(self) -> None:\n        pass\n\n    def test_add(self):\n        # Given\n        mock_client = mock.MagicMock()\n        prefix = \"prefix\"\n        provider = CacheProvider(client=mock_client, key_prefix=prefix)\n\n        # When\n        provider.add(key=\"key\", value=\"val\", expires=10)\n\n        # Then\n        assert mock_client.set.called\n        assert mock_client.set.call_count == 1\n        assert mock_client.set.call_args.args[0] == \"prefix:key\"\n        assert mock_client.set.call_args.args[1] == \"val\"\n        assert mock_client.set.call_args.kwargs['ex'] == 10\n\n    def test_get(self):\n        # Given\n        mock_client = mock.MagicMock()\n        mock_client.get.return_value = \"val\"\n        prefix = \"prefix\"\n        provider = CacheProvider(client=mock_client, key_prefix=prefix)\n\n        # When\n        response = provider.get(key=\"key\")\n\n        # Then\n        assert response == \"val\"\n        assert mock_client.get.called\n        assert mock_client.get.call_count == 1\n        assert mock_client.get.call_args.args[0] == \"prefix:key\"\n\n    def test_exist(self):\n        # Given\n        mock_client = mock.MagicMock()\n        mock_client.exists.return_value = True\n        prefix = \"prefix\"\n        provider = CacheProvider(client=mock_client, key_prefix=prefix)\n\n        # When\n        response = provider.exist(key=\"key\")\n\n        # Then\n        assert response\n        assert mock_client.exists.called\n        assert mock_client.exists.call_count == 1\n        assert mock_client.exists.call_args.args[0] == \"prefix:key\"\n\n    def test_delete(self):\n        # Given\n        mock_client = mock.MagicMock()\n        mock_client.delete.return_value = True\n        prefix = \"prefix\"\n        provider = CacheProvider(client=mock_client, key_prefix=prefix)\n\n        # When\n        provider.delete(key=\"key\")\n\n        # Then\n        assert mock_client.delete.called\n        assert mock_client.delete.call_count == 1\n        assert mock_client.delete.call_args.args[0] == \"prefix:key\"\n\n    def test_check_connection_is_success(self):\n        # Given\n        mock_client = mock.MagicMock()\n        mock_client.echo.return_value = b'echo'\n        prefix = \"prefix\"\n        provider = CacheProvider(client=mock_client, key_prefix=prefix)\n\n        # When\n        response = provider.check_connection()\n\n        # Then\n        assert response\n        assert mock_client.echo.called\n        assert mock_client.echo.call_count == 1\n\n    def test_check_connection_is_not_success(self):\n        # Given\n        mock_client = mock.MagicMock()\n        mock_client.echo.return_value = b''\n        prefix = \"prefix\"\n        provider = CacheProvider(client=mock_client, key_prefix=prefix)\n\n        # When\n        response = provider.check_connection()\n\n        # Then\n        assert response is False\n        assert mock_client.echo.called\n        assert mock_client.echo.call_count == 1\n\n    def test_get_client_throw_exception_when_client_is_none(self):\n        # Given\n        mock_client = mock.MagicMock()\n        mock_client.echo.return_value = b''\n        prefix = \"prefix\"\n        provider = CacheProvider(client=None, key_prefix=prefix)\n\n        # When\n        with raises(Exception) as exc:\n            provider.check_connection()\n\n        # Then\n        assert exc.value.args[0] == 'CacheProvider:client is None'\n"}
{"type": "test_file", "path": "tests/integration/resources/healt_check/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/integration/resources/todo/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/notification/todo_transaction/test_transaction_log_subscriber.py", "content": "from unittest import mock\nfrom app.notification.todo_transaction.transaction_log_subscriber import TransactionLogSubscriber\nfrom app.notification.todo_transaction.transaction_notification import TodoTransactionNotification\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestTransactionLogSubscriber(BaseTestCase):\n\n    def setUp(self) -> None:\n        pass\n\n    def tearDown(self) -> None:\n        pass\n\n    @mock.patch(\"app.notification.todo_transaction.transaction_log_subscriber.logging\")\n    def test_handle(self, mock_logging):\n        # Given\n        subscriber = TransactionLogSubscriber()\n        notification = TodoTransactionNotification(id=1)\n\n        # When\n        self.async_loop(subscriber.handle(notification=notification))\n\n        # Then\n        assert mock_logging.info.called\n        assert mock_logging.info.call_count == 1\n        assert mock_logging.info.call_args.args[0] == f'the transaction completed. its id {notification.id}'\n"}
{"type": "test_file", "path": "tests/unit/notification/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/resources/todo/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/base_test_case.py", "content": "import asyncio\nfrom unittest import TestCase\n\nfrom pydiator_core.mediatr_container import MediatrContainer\nfrom pydiator_core.mediatr import pydiator\n\n\nclass BaseTestCase(TestCase):\n    @staticmethod\n    def async_return(result):\n        f = asyncio.Future()\n        f.set_result(result)\n        return f\n\n    @staticmethod\n    def async_loop(func):\n        loop = asyncio.new_event_loop()\n        response = loop.run_until_complete(func)\n        loop.close()\n        return response\n\n    @staticmethod\n    def register_request(req, handler):\n        container = MediatrContainer()\n        container.register_request(req, handler)\n        pydiator.ready(container=container)\n"}
{"type": "test_file", "path": "tests/unit/resources/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/integration/resources/todo/test_todo_resource.py", "content": "from starlette.status import HTTP_422_UNPROCESSABLE_ENTITY, HTTP_200_OK\n\n\nclass TestTodo:\n\n    def test_get_todo_all(self, test_app):\n        response = test_app.get(\"/v1/todos\")\n        items = response.json()[\"items\"]\n\n        assert response.status_code == HTTP_200_OK\n        assert len(items) == 2\n        assert items[0][\"id\"] == 1\n        assert items[0][\"title\"] == \"title 1\"\n        assert items[1][\"id\"] == 2\n        assert items[1][\"title\"] == \"title 2\"\n\n    def test_get_todo_by_id(self, test_app):\n        response = test_app.get(\"/v1/todos/1\")\n\n        assert response.status_code == HTTP_200_OK\n        assert response.json()[\"id\"] == 1\n        assert response.json()[\"title\"] == \"title 1\"\n\n    def test_add_todo(self, test_app):\n        response = test_app.post(\"/v1/todos\", json={\n            \"title\": \"title 3\"\n        })\n\n        assert response.status_code == HTTP_200_OK\n        assert response.json()[\"success\"]\n\n    def test_add_todo_should_return_unprocessable_when_invalid_entity(self, test_app):\n        response = test_app.post(\"/v1/todos\", json=None)\n\n        assert response.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_update_todo(self, test_app):\n        response = test_app.put(\"/v1/todos/1\", json={\n            \"title\": \"title 1 updated\"\n        })\n\n        assert response.status_code == HTTP_200_OK\n        assert response.json()[\"success\"]\n\n    def test_update_todo_should_return_unprocessable_when_invalid_entity(self, test_app):\n        response = test_app.put(\"/v1/todos/1\", json={\n\n        })\n\n        assert response.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_delete_todo(self, test_app):\n        response = test_app.delete(\"/v1/todos/1\")\n\n        assert response.status_code == HTTP_200_OK\n        assert response.json()[\"success\"]\n"}
{"type": "test_file", "path": "tests/unit/notification/todo_transaction/test_remove_cache_subscriber.py", "content": "from unittest import mock\n\nfrom app.notification.todo_transaction.remove_cache_subscriber import TodoRemoveCacheSubscriber\nfrom app.notification.todo_transaction.transaction_notification import TodoTransactionNotification\nfrom app.resources.todo.usecases.get_todo_all import GetTodoAllRequest\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestTodoRemoveCacheSubscriber(BaseTestCase):\n\n    def setUp(self) -> None:\n        pass\n\n    def tearDown(self) -> None:\n        pass\n\n    @mock.patch(\"app.notification.todo_transaction.remove_cache_subscriber.get_cache_provider\")\n    def test_handle(self, mock_get_cache_provider):\n        # Given\n        subscriber = TodoRemoveCacheSubscriber()\n        notification = TodoTransactionNotification()\n\n        # When\n        self.async_loop(subscriber.handle(notification=notification))\n\n        # Then\n        assert mock_get_cache_provider.return_value.delete.called\n        assert mock_get_cache_provider.return_value.delete.call_count == 1\n        assert mock_get_cache_provider.return_value.delete.call_args.args[0] == GetTodoAllRequest().get_cache_key()\n"}
{"type": "test_file", "path": "tests/unit/utils/pydiator/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/data/todo/usecases/test_get_todo_by_id.py", "content": "from unittest import mock\n\nfrom app.data.todo.usecases.get_todo_by_id_data import GetTodoByIdDataUseCase, GetTodoByIdDataRequest, \\\n    GetTodoByIdDataResponse\nfrom pydiator_core.mediatr import pydiator\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestGetTodoByIdDataUseCase(BaseTestCase):\n    def setUp(self):\n        self.register_request(GetTodoByIdDataRequest(), GetTodoByIdDataUseCase())\n\n    @mock.patch(\"app.data.todo.usecases.get_todo_by_id_data.fake_todo_db\")\n    def test_handle_return_todo(self, mock_fake_todo_db):\n        # Given\n        id_val = 1\n        title_val = \"title 1\"\n        mock_fake_todo_db.__iter__.return_value = [{\"id\": id_val, \"title\": title_val}]\n\n        request = GetTodoByIdDataRequest(id=id_val)\n        expected_response = GetTodoByIdDataResponse(id=id_val, title=title_val)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n\n    @mock.patch(\"app.data.todo.usecases.get_todo_by_id_data.fake_todo_db\")\n    def test_handle_return_none_when_todo_is_not_exist(self, mock_fake_todo_db):\n        # Given\n        mock_fake_todo_db.__iter__.return_value = []\n        request = GetTodoByIdDataRequest(id=1)\n        expected_response = None\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n"}
{"type": "test_file", "path": "tests/unit/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/data/todo/usecases/test_get_todo_all_data.py", "content": "from unittest import mock\n\nfrom app.data.todo.usecases.get_todo_all_data import GetTodoAllDataRequest, GetTodoAllDataResponse, \\\n    GetTodoAllDataUseCase\nfrom pydiator_core.interfaces import CacheType\nfrom pydiator_core.mediatr import pydiator\nfrom app.resources.todo.usecases.get_todo_all import GetTodoAllRequest\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestGetTodoAllDataUseCase(BaseTestCase):\n    def setUp(self):\n        self.register_request(GetTodoAllDataRequest(), GetTodoAllDataUseCase())\n\n    def test_request_cache_parameter(self):\n        # When\n        request = GetTodoAllRequest()\n\n        # Then\n        assert request.get_cache_key() == \"GetTodoAllRequest\"\n        assert request.get_cache_duration() == 600\n        assert request.get_cache_type() == CacheType.DISTRIBUTED\n\n    @mock.patch(\"app.data.todo.usecases.get_todo_all_data.fake_todo_db\")\n    def test_handle_return_list(self, mock_fake_todo_db):\n        # Give\n        id_val = 1\n        title_val = \"title 1\"\n        mock_fake_todo_db.__iter__.return_value = [{\"id\": id_val, \"title\": title_val}]\n\n        request = GetTodoAllDataRequest()\n        expected_response = [GetTodoAllDataResponse(id=id_val, title=title_val)]\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n\n    @mock.patch(\"app.data.todo.usecases.get_todo_all_data.fake_todo_db\")\n    def test_handle_return_empty_list(self, mock_fake_todo_db):\n        # Given\n        mock_fake_todo_db.__iter__.return_value = []\n        request = GetTodoAllDataRequest()\n        expected_response = []\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n"}
{"type": "test_file", "path": "tests/unit/resources/todo/usecases/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/resources/todo/usecases/test_get_todo_by_id.py", "content": "from unittest import mock\n\nfrom pytest import raises\n\nfrom app.data.todo.usecases.get_todo_by_id_data import GetTodoByIdDataResponse\nfrom pydiator_core.mediatr import pydiator\nfrom app.resources.todo.usecases.get_todo_by_id import \\\n    GetTodoByIdRequest, GetTodoByIdResponse, GetTodoByIdUseCase\nfrom app.utils.error.error_models import ErrorInfoContainer\nfrom app.utils.exception.exception_types import ServiceException\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestGetTodoByIdUseCase(BaseTestCase):\n    def setUp(self):\n        self.register_request(GetTodoByIdRequest(), GetTodoByIdUseCase())\n\n    @mock.patch(\"app.resources.todo.usecases.get_todo_by_id.pydiator\")\n    def test_handle_return_todo(self, mock_pydiator):\n        # Given\n        id_val = 1\n        title_val = \"title 1\"\n        mock_pydiator.send.side_effect = [self.async_return(GetTodoByIdDataResponse(id=id_val, title=title_val))]\n\n        request = GetTodoByIdRequest(id=id_val)\n        expected_response = GetTodoByIdResponse(id=id_val, title=title_val)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n\n    @mock.patch(\"app.resources.todo.usecases.get_todo_by_id.pydiator\")\n    def test_handle_return_none_when_data_response_is_none(self, mock_pydiator):\n        # Given\n        mock_pydiator.send.side_effect = [self.async_return(None)]\n        request = GetTodoByIdRequest(id=1)\n\n        # When\n        with raises(ServiceException) as exc:\n            self.async_loop(pydiator.send(request))\n\n        # Then\n        assert exc.value.error_info == ErrorInfoContainer.todo_not_found_error\n"}
{"type": "test_file", "path": "tests/unit/resources/todo/usecases/test_add_todo.py", "content": "from unittest import mock\nfrom pydiator_core.mediatr import pydiator\nfrom app.data.todo.usecases.add_todo_data import AddTodoDataResponse\nfrom app.resources.todo.usecases.add_todo import AddTodoRequest, AddTodoResponse, AddTodoUseCase\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestAddTodoUseCase(BaseTestCase):\n\n    def setUp(self):\n        self.register_request(AddTodoRequest(), AddTodoUseCase())\n\n    @mock.patch(\"app.resources.todo.usecases.add_todo.pydiator\")\n    def test_handle_return_success(self, mock_pydiator):\n        # Given\n        mock_pydiator.send.side_effect = [self.async_return(AddTodoDataResponse(success=True, id=1))]\n        mock_pydiator.publish.side_effect = [self.async_return(True)]\n\n        title_val = \"title\"\n        request = AddTodoRequest(title=title_val)\n        expected_response = AddTodoResponse(success=True)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n        assert mock_pydiator.send.called\n        assert mock_pydiator.publish.called\n\n    @mock.patch(\"app.resources.todo.usecases.add_todo.pydiator\")\n    def test_handle_return_success_false_when_data_response_is_not_successful(self, mock_pydiator):\n        # Given\n        mock_pydiator.send.side_effect = [self.async_return(AddTodoDataResponse(success=False, id=0))]\n\n        title_val = \"title\"\n        request = AddTodoRequest(title=title_val)\n        expected_response = AddTodoResponse(success=False)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n        assert mock_pydiator.send.called\n        assert mock_pydiator.publish.called is False\n"}
{"type": "test_file", "path": "tests/unit/utils/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/data/todo/usecases/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/data/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/conftest.py", "content": "# Global Fixtures can be defined in this file\nimport pytest\nfrom starlette.testclient import TestClient\n\nfrom main import app\n\n\n@pytest.fixture(scope=\"module\")\ndef test_app():\n    client = TestClient(app=app)\n    yield client  # testing happens here\n"}
{"type": "test_file", "path": "tests/integration/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/resources/todo/usecases/test_update_todo.py", "content": "from unittest import mock\n\nfrom app.data.todo.usecases.update_todo_data import UpdateTodoDataResponse\nfrom app.resources.todo.usecases.update_todo import \\\n    UpdateTodoRequest, UpdateTodoResponse, UpdateTodoUseCase\nfrom pydiator_core.mediatr import pydiator\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestAddTodoUseCase(BaseTestCase):\n    def setUp(self):\n        self.register_request(UpdateTodoRequest(), UpdateTodoUseCase())\n\n    @mock.patch(\"app.resources.todo.usecases.update_todo.pydiator\")\n    def test_handle_return_success(self, mock_pydiator):\n        # Given\n        mock_pydiator.send.side_effect = [self.async_return(UpdateTodoDataResponse(success=True))]\n        mock_pydiator.publish.side_effect = [self.async_return(True)]\n\n        id_val = 1\n        title_val = \"title 1 updated\"\n        request = UpdateTodoRequest(title=title_val)\n        request.CustomFields.id = id_val\n        expected_response = UpdateTodoResponse(success=True)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n        assert mock_pydiator.send.called\n        assert mock_pydiator.publish.called\n\n    @mock.patch(\"app.resources.todo.usecases.update_todo.pydiator\")\n    def test_handle_return_false_when_data_response_is_not_successful(self, mock_pydiator):\n        # Given\n        self.register_request(UpdateTodoRequest(), UpdateTodoUseCase())\n        mock_pydiator.send.side_effect = [self.async_return(UpdateTodoDataResponse(success=False))]\n\n        id_val = 1\n        title_val = \"title 1 updated\"\n        request = UpdateTodoRequest(title=title_val)\n        request.CustomFields.id = id_val\n        expected_response = UpdateTodoResponse(success=False)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n        assert mock_pydiator.send.called\n        assert mock_pydiator.publish.called is False\n"}
{"type": "test_file", "path": "tests/unit/data/todo/usecases/test_update_todo_data.py", "content": "from unittest import mock\n\nfrom pytest import raises\n\nfrom app.data.todo.usecases.update_todo_data import UpdateTodoDataUseCase, UpdateTodoDataRequest, \\\n    UpdateTodoDataResponse\nfrom pydiator_core.mediatr import pydiator\n\nfrom app.utils.error.error_models import ErrorInfoContainer\nfrom app.utils.exception.exception_types import DataException\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestUpdateTodoDataUseCase(BaseTestCase):\n    def setUp(self):\n        self.register_request(UpdateTodoDataRequest(), UpdateTodoDataUseCase())\n\n    @mock.patch(\"app.data.todo.usecases.update_todo_data.fake_todo_db\")\n    def test_handle_return_success(self, mock_fake_todo_db):\n        # Given\n        id_val = 1\n        mock_fake_todo_db.__iter__.return_value = [{\"id\": id_val, \"title\": \"title 1\"}]\n        title_val = \"title 1 updated\"\n        request = UpdateTodoDataRequest(title=title_val)\n        request.id = id_val\n        expected_response = UpdateTodoDataResponse(success=True)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n\n    @mock.patch(\"app.data.todo.usecases.update_todo_data.fake_todo_db\")\n    def test_handle_return_exception_when_todo_not_found(self, mock_fake_todo_db):\n        # Given\n        mock_fake_todo_db.__iter__.return_value = []\n        title_val = \"title 1 updated\"\n        request = UpdateTodoDataRequest(title=title_val)\n\n        # When\n        with raises(DataException) as exc:\n            self.async_loop(pydiator.send(request))\n\n        # Then\n        assert exc.value.error_info == ErrorInfoContainer.todo_not_found_error\n"}
{"type": "test_file", "path": "tests/unit/resources/todo/usecases/test_get_todo_all.py", "content": "from unittest import mock\n\nfrom app.data.todo.usecases.get_todo_all_data import GetTodoAllDataResponse\nfrom pydiator_core.mediatr import pydiator\nfrom app.resources.todo.usecases.get_todo_all import GetTodoAllRequest, GetTodoAllUseCase, GetTodoAllResponse, Todo\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestGetTodoByIdUseCase(BaseTestCase):\n    def setUp(self):\n        self.register_request(GetTodoAllRequest, GetTodoAllUseCase())\n\n    def tearDown(self):\n        pass\n\n    @mock.patch(\"app.resources.todo.usecases.get_todo_all.pydiator\")\n    def test_handle_return_list(self, mock_pydiator):\n        # Given\n        id_val = 1\n        title_val = \"title 1\"\n        mock_pydiator.send.side_effect = [self.async_return([GetTodoAllDataResponse(id=id_val, title=title_val)])]\n\n        request = GetTodoAllRequest(id=id_val)\n        expected_response = GetTodoAllResponse(items=[Todo(id=id_val, title=title_val)])\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response is not None\n        assert expected_response == response\n\n    @mock.patch(\"app.resources.todo.usecases.get_todo_all.pydiator\")\n    def test_handle_return_empty_list(self, mock_pydiator):\n        # Given\n        mock_pydiator.send.side_effect = [self.async_return([])]\n        request = GetTodoAllRequest()\n        expected_response = GetTodoAllResponse()\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n"}
{"type": "test_file", "path": "tests/unit/resources/todo/usecases/test_delete_todo_by_id.py", "content": "from unittest import mock\n\nfrom app.data.todo.usecases.delete_todo_by_id_data import DeleteTodoByIdDataResponse\nfrom pydiator_core.mediatr import pydiator\nfrom app.resources.todo.usecases.delete_todo_by_id import \\\n    DeleteTodoByIdRequest, DeleteTodoByIdResponse, DeleteTodoByIdUseCase\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestDeleteTodoByIdUseCase(BaseTestCase):\n\n    def setUp(self):\n        self.register_request(DeleteTodoByIdRequest(), DeleteTodoByIdUseCase())\n\n    @mock.patch(\"app.resources.todo.usecases.delete_todo_by_id.pydiator\")\n    def test_handle_return_success(self, mock_pydiator):\n        # Given\n        mock_pydiator.send.side_effect = [self.async_return(DeleteTodoByIdDataResponse(success=True))]\n        mock_pydiator.publish.side_effect = [self.async_return(True)]\n\n        id_val = 1\n        request = DeleteTodoByIdRequest(id=id_val)\n        expected_response = DeleteTodoByIdResponse(success=True)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n        assert mock_pydiator.send.called\n        assert mock_pydiator.publish.called\n\n    @mock.patch(\"app.resources.todo.usecases.delete_todo_by_id.pydiator\")\n    def test_handle_return_false_when_data_response_is_not_successful(self, mock_pydiator):\n        # Given\n        mock_pydiator.send.side_effect = [self.async_return(DeleteTodoByIdDataResponse(success=False))]\n        request = DeleteTodoByIdRequest(id=1)\n        expected_response = DeleteTodoByIdResponse(success=False)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n        assert mock_pydiator.send.called\n        assert mock_pydiator.publish.called is False\n"}
{"type": "test_file", "path": "tests/unit/notification/todo_transaction/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/unit/data/todo/usecases/test_add_todo_data.py", "content": "from unittest import mock\n\nfrom app.data.todo.usecases.add_todo_data import AddTodoDataUseCase, AddTodoDataRequest, AddTodoDataResponse\nfrom pydiator_core.mediatr import pydiator\nfrom tests.unit.base_test_case import BaseTestCase\n\n\nclass TestAddTodoDataUseCase(BaseTestCase):\n    def setUp(self):\n        self.register_request(AddTodoDataRequest(), AddTodoDataUseCase())\n\n    @mock.patch(\"app.data.todo.usecases.add_todo_data.fake_todo_db\")\n    def test_handle_return_success(self, mock_fake_todo_db):\n        # Given\n        self.register_request(AddTodoDataRequest(), AddTodoDataUseCase())\n        mock_fake_todo_db.__iter__.return_value = []\n\n        title_val = \"title\"\n        request = AddTodoDataRequest(title=title_val)\n        expected_response = AddTodoDataResponse(success=True, id=1)\n\n        # When\n        response = self.async_loop(pydiator.send(request))\n\n        # Then\n        assert response == expected_response\n        assert mock_fake_todo_db.append.call_count == 1\n        assert mock_fake_todo_db.append.called\n"}
{"type": "source_file", "path": "app/notification/todo_transaction/__init__.py", "content": ""}
{"type": "source_file", "path": "app/data/__init__.py", "content": ""}
{"type": "source_file", "path": "app/notification/__init__.py", "content": ""}
{"type": "source_file", "path": "app/data/todo/__init__.py", "content": ""}
{"type": "source_file", "path": "app/data/todo/usecases/get_todo_all_data.py", "content": "from pydantic import BaseModel, Field\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler\nfrom app.db.fake_db import fake_todo_db\nfrom typing import List\n\n\nclass GetTodoAllDataRequest(BaseModel, BaseRequest):\n    def __init__(self):\n        pass\n\n\nclass GetTodoAllDataResponse(BaseModel, BaseResponse):\n    id: int = Field(...)\n    title: str = Field(...)\n\n\nclass GetTodoAllDataUseCase(BaseHandler):\n\n    async def handle(self, req: GetTodoAllDataRequest) -> List[GetTodoAllDataResponse]:\n        response = []\n        for it in fake_todo_db:\n            response.append(GetTodoAllDataResponse(id=it[\"id\"], title=it[\"title\"]))\n\n        return response\n"}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/db/fake_db.py", "content": "import string\nimport random\n\nfake_todo_db = [\n    {\"id\": 1, \"title\": \"title 1\"},\n    {\"id\": 2, \"title\": \"title 2\"}\n]\n"}
{"type": "source_file", "path": "app/data/todo/usecases/update_todo_data.py", "content": "from pydantic import BaseModel, Field, Extra\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler\nfrom app.db.fake_db import fake_todo_db\nfrom app.utils.error.error_models import ErrorInfoContainer\nfrom app.utils.exception.exception_types import DataException\n\n\nclass UpdateTodoDataRequest(BaseModel, BaseRequest):\n    title: str = Field(\"\", title=\"The title of the item\", max_length=300, min_length=1)\n    id: int = Field(0, title=\"\", gt=0)\n\n\nclass UpdateTodoDataResponse(BaseModel, BaseResponse):\n    success: bool = Field(...)\n\n\nclass UpdateTodoDataUseCase(BaseHandler):\n\n    async def handle(self, req: UpdateTodoDataRequest) -> UpdateTodoDataResponse:\n        for it in fake_todo_db:\n            if it[\"id\"] == req.id:\n                it[\"title\"] = req.title\n                return UpdateTodoDataResponse(success=True)\n\n        raise DataException(error_info=ErrorInfoContainer.todo_not_found_error)\n\n"}
{"type": "source_file", "path": "app/data/todo/usecases/__init__.py", "content": ""}
{"type": "source_file", "path": "app/application.py", "content": "from pydantic import ValidationError\nfrom starlette.exceptions import HTTPException\n\nfrom app.resources.health_check import health_check_resource\nfrom app.resources.todo import todo_resource\nfrom fastapi import FastAPI\n\nfrom fastapi_contrib.common.middlewares import StateRequestIDMiddleware\nfrom app.utils.exception.exception_handlers import ExceptionHandlers\nfrom app.utils.pydiator.pydiator_core_config import set_up_pydiator\nfrom app.utils.exception.exception_types import DataException, ServiceException\n\n\ndef create_app():\n    app = FastAPI(\n        title=\"FastAPI Pydiator\",\n        description=\"FastAPI pydiator integration project\",\n        version=\"1.0.0\",\n        openapi_url=\"/openapi.json\",\n        docs_url=\"/\",\n        redoc_url=\"/redoc\"\n    )\n\n    app.add_exception_handler(Exception, ExceptionHandlers.unhandled_exception)\n    app.add_exception_handler(DataException, ExceptionHandlers.data_exception)\n    app.add_exception_handler(ServiceException, ExceptionHandlers.service_exception)\n    app.add_exception_handler(HTTPException, ExceptionHandlers.http_exception)\n    app.add_exception_handler(ValidationError, ExceptionHandlers.validation_exception)\n\n    app.include_router(\n        health_check_resource.router,\n        prefix=\"/health-check\",\n        tags=[\"health check\"]\n    )\n\n    app.include_router(\n        todo_resource.router,\n        prefix=\"/v1/todos\",\n        tags=[\"todo\"]\n    )\n\n    set_up_pydiator()\n\n    return app\n"}
{"type": "source_file", "path": "app/data/todo/usecases/add_todo_data.py", "content": "from pydantic import BaseModel, Field\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler\nfrom app.db.fake_db import fake_todo_db\n\n\nclass AddTodoDataRequest(BaseModel, BaseRequest):\n    title: str = Field(\"\", title=\"The title of the item\", max_length=300, min_length=1)\n\n\nclass AddTodoDataResponse(BaseModel, BaseResponse):\n    success: bool = Field(...)\n    id: int = Field(0, title=\"todo id\")\n\n\nclass AddTodoDataUseCase(BaseHandler):\n\n    async def handle(self, req: AddTodoDataRequest) -> AddTodoDataResponse:\n        id = 1\n        last_item = fake_todo_db[len(fake_todo_db) - 1]\n        if last_item is not None:\n            id = last_item[\"id\"] + 1\n\n        fake_todo_db.append({\n            \"id\": id,\n            \"title\": f\"title {id}\"\n        })\n\n        return AddTodoDataResponse(success=True, id=id)\n"}
{"type": "source_file", "path": "app/data/todo/usecases/delete_todo_by_id_data.py", "content": "from pydantic import BaseModel, Field\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler\nfrom app.db.fake_db import fake_todo_db\n\n\nclass DeleteTodoByIdDataRequest(BaseModel, BaseRequest):\n    id: int = Field(0, gt=0, title=\"item id\")\n\n\nclass DeleteTodoByIdDataResponse(BaseModel, BaseResponse):\n    success: bool = Field(...)\n\n\nclass DeleteTodoByIdDataUseCase(BaseHandler):\n\n    async def handle(self, req: DeleteTodoByIdDataRequest) -> DeleteTodoByIdDataResponse:\n        for it in fake_todo_db:\n            if it[\"id\"] == req.id:\n                fake_todo_db.remove(it)\n                return DeleteTodoByIdDataResponse(success=True)\n\n        return DeleteTodoByIdDataResponse(success=False)\n"}
{"type": "source_file", "path": "app/data/todo/usecases/get_todo_by_id_data.py", "content": "from pydantic import BaseModel, Field\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler\nfrom app.db.fake_db import fake_todo_db\n\n\nclass GetTodoByIdDataRequest(BaseModel, BaseRequest):\n    id: int = Field(0, gt=0, description=\"The item id be greater than zero\")\n\n\nclass GetTodoByIdDataResponse(BaseModel, BaseResponse):\n    id: int = Field(...)\n    title: str = Field(...)\n\n\nclass GetTodoByIdDataUseCase(BaseHandler):\n\n    async def handle(self, req: GetTodoByIdDataRequest) -> GetTodoByIdDataResponse:\n        for it in fake_todo_db:\n            if it[\"id\"] == req.id:\n                return GetTodoByIdDataResponse(id=it[\"id\"], title=it[\"title\"])\n\n        return None\n"}
{"type": "source_file", "path": "app/db/__init__.py", "content": ""}
{"type": "source_file", "path": "app/resources/health_check/health_check_resource.py", "content": "from fastapi import status, APIRouter\nfrom fastapi.responses import PlainTextResponse\n\nrouter = APIRouter()\n\n\n@router.get(\"\",\n            status_code=status.HTTP_200_OK,\n            responses={\n                status.HTTP_200_OK: {\n                    \"model\": str,\n                    \"content\": {\n                        \"text/plain\": {\n                            \"example\": \"OK\"\n                        }\n                    }\n                }\n            },\n            response_class=PlainTextResponse)\nasync def get():\n    return \"OK\"\n"}
{"type": "source_file", "path": "app/resources/health_check/__init__.py", "content": ""}
{"type": "source_file", "path": "app/notification/todo_transaction/remove_cache_subscriber.py", "content": "from pydiator_core.interfaces import BaseNotificationHandler\n\nfrom app.notification.todo_transaction.transaction_notification import TodoTransactionNotification\nfrom app.resources.todo.usecases.get_todo_all import GetTodoAllRequest\nfrom app.utils.cache_provider import get_cache_provider\n\n\nclass TodoRemoveCacheSubscriber(BaseNotificationHandler):\n    def __init__(self):\n        self.cache_provider = get_cache_provider()\n\n    async def handle(self, notification: TodoTransactionNotification):\n        self.cache_provider.delete(GetTodoAllRequest().get_cache_key())\n"}
{"type": "source_file", "path": "app/resources/todo/__init__.py", "content": ""}
{"type": "source_file", "path": "app/resources/__init__.py", "content": ""}
{"type": "source_file", "path": "app/resources/todo/usecases/delete_todo_by_id.py", "content": "from pydantic import BaseModel, Field\n\nfrom app.data.todo.usecases.delete_todo_by_id_data import DeleteTodoByIdDataRequest\nfrom pydiator_core.mediatr import pydiator\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler\nfrom app.notification.todo_transaction.transaction_notification import TodoTransactionNotification\n\n\nclass DeleteTodoByIdRequest(BaseModel, BaseRequest):\n    id: int = Field(0, gt=0, title=\"item id\")\n\n\nclass DeleteTodoByIdResponse(BaseModel, BaseResponse):\n    success: bool = Field(...)\n\n\nclass DeleteTodoByIdUseCase(BaseHandler):\n\n    async def handle(self, req: DeleteTodoByIdRequest) -> DeleteTodoByIdResponse:\n        data_response = await pydiator.send(DeleteTodoByIdDataRequest(id=req.id))\n        if data_response.success:\n            await pydiator.publish(TodoTransactionNotification(id=req.id))\n            return DeleteTodoByIdResponse(success=True)\n\n        return DeleteTodoByIdResponse(success=False)\n"}
{"type": "source_file", "path": "app/resources/todo/usecases/add_todo.py", "content": "from pydantic import BaseModel, Field\n\nfrom app.data.todo.usecases.add_todo_data import AddTodoDataRequest, AddTodoDataResponse\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler\nfrom pydiator_core.mediatr import pydiator\nfrom app.notification.todo_transaction.transaction_notification import TodoTransactionNotification\n\n\nclass AddTodoRequest(BaseModel, BaseRequest):\n    title: str = Field(\"title\", title=\"The title of the item\", max_length=300, min_length=1)\n\n\nclass AddTodoResponse(BaseModel, BaseResponse):\n    success: bool = Field(...)\n\n\nclass AddTodoUseCase(BaseHandler):\n\n    async def handle(self, req: AddTodoRequest) -> AddTodoResponse:\n        data_response: AddTodoDataResponse = await pydiator.send(AddTodoDataRequest(title=req.title))\n        if data_response.success:\n            await pydiator.publish(TodoTransactionNotification(id=data_response.id))\n            return AddTodoResponse(success=True)\n\n        return AddTodoResponse(success=False)\n"}
{"type": "source_file", "path": "app/resources/todo/usecases/__init__.py", "content": ""}
{"type": "source_file", "path": "app/resources/todo/usecases/get_todo_all.py", "content": "from pydantic import BaseModel, Field\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler, BaseCacheable, CacheType\nfrom typing import List\nfrom pydiator_core.mediatr import pydiator\n\nfrom app.data.todo.usecases.get_todo_all_data import GetTodoAllDataRequest\n\n\nclass GetTodoAllRequest(BaseModel, BaseRequest, BaseCacheable):\n    def get_cache_key(self) -> str:\n        return type(self).__name__\n\n    def get_cache_duration(self) -> int:\n        return 600\n\n    def get_cache_type(self) -> CacheType:\n        return CacheType.DISTRIBUTED\n\n\nclass Todo(BaseModel):\n    id: int = Field(...)\n    title: str = Field(...)\n\n\nclass GetTodoAllResponse(BaseModel, BaseResponse):\n    items: List[Todo] = []\n\n\nclass GetTodoAllUseCase(BaseHandler):\n\n    async def handle(self, req: GetTodoAllRequest) -> GetTodoAllResponse:\n        response = GetTodoAllResponse()\n        todo_data = await pydiator.send(GetTodoAllDataRequest())\n        for item in todo_data:\n            response.items.append(Todo(id=item.id, title=item.title))\n\n        return response\n"}
{"type": "source_file", "path": "app/notification/todo_transaction/transaction_log_subscriber.py", "content": "import logging\n\nfrom pydiator_core.interfaces import BaseNotificationHandler\nfrom app.notification.todo_transaction.transaction_notification import TodoTransactionNotification\n\n\nclass TransactionLogSubscriber(BaseNotificationHandler):\n    def __init__(self):\n        pass\n\n    async def handle(self, notification: TodoTransactionNotification):\n        logging.info(f'the transaction completed. its id {notification.id}')\n"}
{"type": "source_file", "path": "app/notification/todo_transaction/transaction_notification.py", "content": "from pydantic import BaseModel, Field\nfrom pydiator_core.interfaces import BaseNotification\n\n\nclass TodoTransactionNotification(BaseModel, BaseNotification):\n    id: int = Field(0, gt=0, title=\"todo id\")\n"}
{"type": "source_file", "path": "app/resources/todo/todo_resource.py", "content": "from typing import List\nfrom fastapi import status, APIRouter, Response\n\nfrom pydiator_core.mediatr import pydiator\nfrom app.resources.todo.usecases.get_todo_all import GetTodoAllRequest, GetTodoAllResponse\nfrom app.resources.todo.usecases.get_todo_by_id import GetTodoByIdRequest, GetTodoByIdResponse\nfrom app.resources.todo.usecases.add_todo import AddTodoRequest, AddTodoResponse\nfrom app.resources.todo.usecases.update_todo import UpdateTodoRequest, UpdateTodoResponse\nfrom app.resources.todo.usecases.delete_todo_by_id import DeleteTodoByIdRequest, DeleteTodoByIdResponse\nfrom app.utils.error.error_response import ErrorResponseModel, ErrorResponseExample\n\nrouter = APIRouter()\n\n\n@router.get(\"\",\n            status_code=status.HTTP_200_OK,\n            responses={\n                status.HTTP_200_OK: {\"model\": List[GetTodoAllResponse]},\n                status.HTTP_400_BAD_REQUEST: {\n                    \"model\": ErrorResponseModel,\n                    \"content\": ErrorResponseExample.get_error_response(),\n                },\n            })\nasync def get_todo_all():\n    return await pydiator.send(req=GetTodoAllRequest())\n\n\n@router.get(\"/{id}\",\n            status_code=status.HTTP_200_OK,\n            responses={\n                status.HTTP_200_OK: {\"model\": GetTodoByIdResponse},\n                status.HTTP_400_BAD_REQUEST: {\n                    \"model\": ErrorResponseModel,\n                    \"content\": ErrorResponseExample.get_error_response(),\n                },\n                status.HTTP_422_UNPROCESSABLE_ENTITY: {\n                    \"model\": ErrorResponseModel,\n                    \"content\": ErrorResponseExample.get_validation_error_response(\n                        invalid_field_location=[\"path\", \"id\"]\n                    ),\n                },\n            })\nasync def get_todo_by_id(id: int, response: Response):\n    return await pydiator.send(req=GetTodoByIdRequest(id=id), response=response)\n\n\n@router.post(\"\",\n             status_code=status.HTTP_200_OK,\n             responses={\n                 status.HTTP_200_OK: {\"model\": AddTodoResponse},\n                 status.HTTP_400_BAD_REQUEST: {\n                     \"model\": ErrorResponseModel,\n                     \"content\": ErrorResponseExample.get_error_response(),\n                 },\n                 status.HTTP_422_UNPROCESSABLE_ENTITY: {\n                     \"model\": ErrorResponseModel,\n                     \"content\": ErrorResponseExample.get_validation_error_response(\n                         invalid_field_location=[\"body\", \"title\"]\n                     ),\n                 },\n             })\nasync def add_todo(req: AddTodoRequest):\n    return await pydiator.send(req=req)\n\n\n@router.put(\"/{id}\",\n            responses={\n                status.HTTP_200_OK: {\"model\": UpdateTodoResponse},\n                status.HTTP_400_BAD_REQUEST: {\n                    \"model\": ErrorResponseModel,\n                    \"content\": ErrorResponseExample.get_error_response(),\n                },\n                status.HTTP_422_UNPROCESSABLE_ENTITY: {\n                    \"model\": ErrorResponseModel,\n                    \"content\": ErrorResponseExample.get_validation_error_response(\n                        invalid_field_location=[\"path\", \"id\"]\n                    ),\n                },\n            })\nasync def update_todo(id: int, req: UpdateTodoRequest):\n    req.CustomFields.id = id\n    return await pydiator.send(req=req)\n\n\n@router.delete(\"/{id}\",\n               responses={\n                   status.HTTP_200_OK: {\"model\": DeleteTodoByIdResponse},\n                   status.HTTP_400_BAD_REQUEST: {\n                       \"model\": ErrorResponseModel,\n                       \"content\": ErrorResponseExample.get_error_response(),\n                   },\n                   status.HTTP_422_UNPROCESSABLE_ENTITY: {\n                       \"model\": ErrorResponseModel,\n                       \"content\": ErrorResponseExample.get_validation_error_response(\n                           invalid_field_location=[\"path\", \"id\"]\n                       ),\n                   },\n               })\nasync def delete_todo(id: int):\n    return await pydiator.send(req=DeleteTodoByIdRequest(id=id))\n"}
{"type": "source_file", "path": "app/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "app/resources/todo/usecases/update_todo.py", "content": "from pydantic import BaseModel, Field, Extra\n\nfrom app.data.todo.usecases.update_todo_data import UpdateTodoDataRequest\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler\nfrom pydiator_core.mediatr import pydiator\nfrom app.notification.todo_transaction.transaction_notification import TodoTransactionNotification\n\n\nclass UpdateTodoRequest(BaseModel, BaseRequest):\n    title: str = Field(\"\", title=\"The title of the item\", max_length=300, min_length=1)\n\n    class CustomFields:\n        id: int = Extra.allow\n\n\nclass UpdateTodoResponse(BaseModel, BaseResponse):\n    success: bool = Field(...)\n\n\nclass UpdateTodoUseCase(BaseHandler):\n\n    async def handle(self, req: UpdateTodoRequest) -> UpdateTodoResponse:\n        data_response = await pydiator.send(UpdateTodoDataRequest(id=req.CustomFields.id, title=req.title))\n        if data_response.success:\n            await pydiator.publish(TodoTransactionNotification(id=req.CustomFields.id))\n            return UpdateTodoResponse(success=True)\n\n        return UpdateTodoResponse(success=False)\n"}
{"type": "source_file", "path": "app/utils/pydiator/__init__.py", "content": ""}
{"type": "source_file", "path": "app/resources/todo/usecases/get_todo_by_id.py", "content": "from pydantic import BaseModel, Field\nfrom pydiator_core.interfaces import BaseRequest, BaseResponse, BaseHandler\nfrom pydiator_core.mediatr import pydiator\n\nfrom app.data.todo.usecases.get_todo_by_id_data import GetTodoByIdDataRequest\nfrom app.utils.error.error_models import ErrorInfoContainer\nfrom app.utils.exception.exception_types import ServiceException\n\n\nclass GetTodoByIdRequest(BaseModel, BaseRequest):\n    id: int = Field(0, gt=0, description=\"The item id be greater than zero\")\n\n\nclass GetTodoByIdResponse(BaseModel, BaseResponse):\n    id: int = Field(...)\n    title: str = Field(...)\n\n\nclass GetTodoByIdUseCase(BaseHandler):\n\n    async def handle(self, req: GetTodoByIdRequest) -> GetTodoByIdResponse:\n        todo_data = await pydiator.send(GetTodoByIdDataRequest(id=req.id))\n        if todo_data is not None:\n            return GetTodoByIdResponse(id=todo_data.id, title=todo_data.title)\n\n        raise ServiceException(error_info=ErrorInfoContainer.todo_not_found_error)\n"}
{"type": "source_file", "path": "app/utils/cache_provider.py", "content": "import redis\nfrom pydiator_core.interfaces import BaseCacheProvider\nfrom app.utils import config\nfrom app.utils.config import REDIS_HOST, REDIS_PORT, REDIS_DB, REDIS_KEY_PREFIX\n\n\nclass CacheProvider(BaseCacheProvider):\n    key_prefix = \"pydiator\"\n\n    def __init__(self, client, key_prefix: str = None):\n        self.client = client\n        self.key_prefix = key_prefix\n\n    def add(self, key: str, value, expires):\n        return self.__get_client().set(self.__get_formatted_key(key), value, ex=expires)\n\n    def get(self, key):\n        return self.__get_client().get(self.__get_formatted_key(key))\n\n    def exist(self, key):\n        return self.__get_client().exists(self.__get_formatted_key(key))\n\n    def delete(self, key):\n        self.__get_client().delete(self.__get_formatted_key(key))\n\n    def check_connection(self):\n        result = self.__get_client().echo(\"echo\")\n        if result == b'echo':\n            return True\n        return False\n\n    def __get_formatted_key(self, key) -> str:\n        return '{}:{}'.format(self.key_prefix, key)\n\n    def __get_client(self):\n        if self.client is None:\n            raise Exception('CacheProvider:client is None')\n\n        return self.client\n\n\ndef get_cache_provider():\n    if config.DISTRIBUTED_CACHE_IS_ENABLED:\n        client = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=REDIS_DB)\n        return CacheProvider(client=client, key_prefix=REDIS_KEY_PREFIX)\n    return None\n"}
{"type": "source_file", "path": "app/utils/config.py", "content": "from starlette.config import Config\n\nfrom dotenv import load_dotenv\n\nload_dotenv()\nconfig = Config(\".env\")\n\nREDIS_HOST = config('REDIS_HOST', str, '0.0.0.0')\nREDIS_PORT = config('REDIS_PORT', int, 6379)\nREDIS_DB = config('REDIS_DB', int, 0)\nREDIS_KEY_PREFIX = config('REDIS_KEY_PREFIX', str, 'fastapi_pydiator:')\n\nDISTRIBUTED_CACHE_IS_ENABLED = config(\"DISTRIBUTED_CACHE_IS_ENABLED\", bool, True)\nCACHE_PIPELINE_IS_ENABLED = config(\"CACHE_PIPELINE_IS_ENABLED\", bool, False)\nLOG_PIPELINE_IS_ENABLED = config(\"LOG_PIPELINE_IS_ENABLED\", bool, True)\n\n\n"}
{"type": "source_file", "path": "app/utils/pydiator/pydiator_core_config.py", "content": "from app.data.todo.usecases.delete_todo_by_id_data import DeleteTodoByIdDataUseCase, DeleteTodoByIdDataRequest\nfrom app.notification.todo_transaction.transaction_log_subscriber import TransactionLogSubscriber\nfrom app.utils.config import CACHE_PIPELINE_IS_ENABLED, LOG_PIPELINE_IS_ENABLED\nfrom app.utils.cache_provider import get_cache_provider\n\nfrom pydiator_core.mediatr import pydiator\nfrom pydiator_core.mediatr_container import MediatrContainer\nfrom pydiator_core.pipelines.cache_pipeline import CachePipeline\nfrom pydiator_core.pipelines.log_pipeline import LogPipeline\n\nfrom app.resources.todo.usecases.get_todo_all import GetTodoAllRequest, GetTodoAllUseCase\nfrom app.resources.todo.usecases.get_todo_by_id import GetTodoByIdRequest, GetTodoByIdUseCase\nfrom app.resources.todo.usecases.add_todo import AddTodoRequest, AddTodoUseCase\nfrom app.resources.todo.usecases.update_todo import UpdateTodoRequest, UpdateTodoUseCase\nfrom app.resources.todo.usecases.delete_todo_by_id import DeleteTodoByIdRequest, DeleteTodoByIdUseCase\nfrom app.notification.todo_transaction.transaction_notification import TodoTransactionNotification\nfrom app.notification.todo_transaction.remove_cache_subscriber import TodoRemoveCacheSubscriber\n\nfrom app.data.todo.usecases.get_todo_all_data import GetTodoAllDataRequest, GetTodoAllDataUseCase\nfrom app.data.todo.usecases.get_todo_by_id_data import GetTodoByIdDataRequest, GetTodoByIdDataUseCase\nfrom app.data.todo.usecases.add_todo_data import AddTodoDataUseCase, AddTodoDataRequest\nfrom app.data.todo.usecases.update_todo_data import UpdateTodoDataRequest, UpdateTodoDataUseCase\n\n\ndef set_up_pydiator():\n    container = MediatrContainer()\n\n\n    if LOG_PIPELINE_IS_ENABLED:\n        container.register_pipeline(LogPipeline())\n\n    if CACHE_PIPELINE_IS_ENABLED:\n        cache_pipeline = CachePipeline(get_cache_provider())\n        container.register_pipeline(cache_pipeline)\n\n    # Service usecases mapping\n    container.register_request(GetTodoAllRequest, GetTodoAllUseCase())\n    container.register_request(GetTodoByIdRequest, GetTodoByIdUseCase())\n    container.register_request(AddTodoRequest, AddTodoUseCase())\n    container.register_request(UpdateTodoRequest, UpdateTodoUseCase())\n    container.register_request(DeleteTodoByIdRequest, DeleteTodoByIdUseCase())\n\n    # Data usecases mapping\n    container.register_request(GetTodoAllDataRequest, GetTodoAllDataUseCase())\n    container.register_request(GetTodoByIdDataRequest, GetTodoByIdDataUseCase())\n    container.register_request(AddTodoDataRequest, AddTodoDataUseCase())\n    container.register_request(DeleteTodoByIdDataRequest, DeleteTodoByIdDataUseCase())\n    container.register_request(UpdateTodoDataRequest, UpdateTodoDataUseCase())\n\n    # Notification mapping\n    container.register_notification(TodoTransactionNotification,\n                                    [TodoRemoveCacheSubscriber(), TransactionLogSubscriber()])\n\n    # Start\n    pydiator.ready(container=container)\n"}
{"type": "source_file", "path": "app/utils/exception/exception_types.py", "content": "from app.utils.error.error_models import ErrorInfoModel\n\n\nclass ApplicationException(Exception):\n    def __init__(self, error_info: ErrorInfoModel, exception: Exception = None) -> None:\n        super().__init__()\n        self.exception = exception\n        self.error_info = error_info\n\n\nclass DataException(ApplicationException):\n    pass\n\n\nclass ServiceException(ApplicationException):\n    pass\n"}
{"type": "source_file", "path": "app/utils/error/error_response.py", "content": "from typing import List\nfrom app.utils.error.error_models import ErrorInfoContainer, ErrorResponseModel\n\n\nclass ErrorResponseExample:\n\n    @staticmethod\n    def get_error_response():\n        return {\n            \"application/json\": {\n                \"example\": ErrorResponseModel(\n                    error_code=ErrorInfoContainer.could_not_get_excepted_response.code,\n                    error_message=ErrorInfoContainer.could_not_get_excepted_response.message\n                ).dict()\n            }\n        }\n\n    @staticmethod\n    def get_validation_error_response(invalid_field_location: List[str]):\n        return {\n            \"application/json\": {\n                \"example\": ErrorResponseModel(\n                    error_code=ErrorInfoContainer.model_validation_error.code,\n                    error_message=ErrorInfoContainer.model_validation_error.message,\n                    error_detail=[{\n                        \"loc\": invalid_field_location,\n                        \"msg\": \"field required\",\n                        \"type\": \"value_error.missing\",\n                    }]\n                ).dict()\n            }\n        }\n"}
{"type": "source_file", "path": "app/utils/error/__init__.py", "content": ""}
{"type": "source_file", "path": "app/utils/error/error_models.py", "content": "from pydantic import BaseModel\n\n\nclass ErrorInfoModel:\n    def __init__(self, code: int, message: str):\n        self.code = code\n        self.message = message\n\n    def __repr__(self):\n        return f'code:{self.code},message:{self.message}'\n\n\nclass ErrorInfoContainer:\n    # General errors\n    unhandled_error = ErrorInfoModel(code=1, message='Internal server error')\n    could_not_get_excepted_response = ErrorInfoModel(code=2, message='Could not get expected response')\n    model_validation_error = ErrorInfoModel(code=3, message='Model validation error')\n    not_found_error = ErrorInfoModel(code=4, message='Not found')\n\n    # Custom errors\n    todo_not_found_error = ErrorInfoModel(code=101, message='Todo not found')\n\n\nclass ErrorResponseModel(BaseModel):\n    error_code: int = None\n    error_message: str = None\n    error_detail: list = None\n"}
{"type": "source_file", "path": "main.py", "content": "import uvicorn\n\nfrom app.application import create_app\n\napp = create_app()\n\nif __name__ == \"__main__\":\n    uvicorn.run(app)\n    #uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8000, log_level=\"info\", use_colors=True)\n"}
{"type": "source_file", "path": "app/utils/exception/__init__.py", "content": ""}
{"type": "source_file", "path": "app/utils/tracer_config.py", "content": "from jaeger_client import Config\nfrom opentracing.scope_managers.asyncio import AsyncioScopeManager\n\nfrom app.utils.config import JAEGER_HOST, JAEGER_PORT, JAEGER_SAMPLER_RATE, JAEGER_SAMPLER_TYPE, JAEGER_TRACE_ID_HEADER, \\\n    JAEGER_SERVICE_NAME\n\n\ndef init_tracer(service_name: str):\n    config = Config(\n        config={\n            \"local_agent\": {\n                \"reporting_host\": JAEGER_HOST,\n                \"reporting_port\": JAEGER_PORT,\n            },\n            \"sampler\": {\n                \"type\": JAEGER_SAMPLER_TYPE,\n                \"param\": JAEGER_SAMPLER_RATE\n            },\n            \"trace_id_header\": JAEGER_TRACE_ID_HEADER,\n        },\n        scope_manager=AsyncioScopeManager(),\n        service_name=service_name,\n        validate=True,\n    )\n    return config.initialize_tracer()\n\n\ntracer = init_tracer(JAEGER_SERVICE_NAME)\n"}
{"type": "source_file", "path": "app/utils/exception/exception_handlers.py", "content": "import traceback\nfrom typing import Optional, List\n\nfrom fastapi import HTTPException\nfrom fastapi.encoders import jsonable_encoder\nfrom starlette import status\nfrom starlette.responses import JSONResponse\n\nfrom app.utils.error.error_models import ErrorInfoModel\nfrom app.utils.error.error_response import ErrorResponseModel, ErrorInfoContainer\nfrom app.utils.exception.exception_types import DataException, ServiceException\n\n\nclass ExceptionHandlers:\n\n    @staticmethod\n    def unhandled_exception(request, exc: Exception):\n        return JSONResponse(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            content=ExceptionHandlers.__get_error_content(\n                error_info=ErrorInfoContainer.unhandled_error,\n                error_detail=[ExceptionHandlers.__get_stack_trace(exc)]\n            ),\n        )\n\n    @staticmethod\n    def data_exception(request, exc: DataException):\n        return JSONResponse(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            content=ExceptionHandlers.__get_error_content(\n                error_info=exc.error_info\n            ),\n        )\n\n    @staticmethod\n    def service_exception(request, exc: ServiceException):\n        return JSONResponse(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            content=ExceptionHandlers.__get_error_content(\n                error_info=exc.error_info\n            ),\n        )\n\n    @staticmethod\n    def http_exception(request, exc: HTTPException):\n        return JSONResponse(\n            status_code=exc.status_code,\n            content=ExceptionHandlers.__get_error_content(\n                error_info=ErrorInfoContainer.unhandled_error,\n                error_detail=[exc.detail]\n            ),\n        )\n\n    @staticmethod\n    def validation_exception(request, exc):\n        return JSONResponse(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            content=ExceptionHandlers.__get_error_content(\n                error_info=ErrorInfoContainer.model_validation_error,\n                error_detail=exc.errors()\n            ),\n        )\n\n    @staticmethod\n    def __get_error_content(error_info: ErrorInfoModel, error_detail: Optional[List] = None):\n        return jsonable_encoder(\n            ErrorResponseModel(\n                error_code=error_info.code,\n                error_message=error_info.message,\n                error_detail=error_detail,\n            ).dict()\n        )\n\n    @staticmethod\n    def __get_stack_trace(exc: Exception) -> str:\n        return \"\".join(traceback.TracebackException.from_exception(exc).format())\n"}

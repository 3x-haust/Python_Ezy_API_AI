{"repo_info": {"repo_name": "erdb", "repo_owner": "EldenRingDatabase", "repo_url": "https://github.com/EldenRingDatabase/erdb"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/attack_power_test.py", "content": "import json\nfrom pathlib import Path\nimport pytest\n\nfrom erdb.utils.attack_power import Attributes, CalculatorData, ArmamentCalculator\n\n\n\"\"\"\nVersion of the game the sample data has been explicitly collected for\n\"\"\"\n_GAME_VERSION: str = \"1.05.0\"\n\n_TEST_DIR = Path(__file__).parent.resolve()\n_DATA_DIR = _TEST_DIR / \"attack_values\"\n_GAMEDATA_DIR = _TEST_DIR.parent / _GAME_VERSION\n_ATTRIBUTE_SETS = [Attributes.from_string(f.stem) for f in _DATA_DIR.glob(\"*\")]\n\ndef pytest_generate_tests(metafunc):\n    assert \"armament\" in metafunc.fixturenames\n    assert \"attribs\" in metafunc.fixturenames\n\n    with open(_GAMEDATA_DIR / \"armaments.json\") as f:\n        armaments = json.load(f)[\"Armaments\"]\n\n    armament_data: list[tuple[str, str]] = []\n    armament_ids: list[str] = []\n\n    for armament, properties in armaments.items():\n        for affinity in properties[\"affinity\"].keys():\n            armament_data.append((affinity, armament))\n            armament_ids.append(f\"{affinity} {armament}\")\n\n    metafunc.parametrize(\"armament\", armament_data, ids=armament_ids)\n    metafunc.parametrize(\"attribs\", _ATTRIBUTE_SETS, ids=[*map(str, _ATTRIBUTE_SETS)])\n\n@pytest.fixture(scope=\"module\")\ndef calc_data() -> CalculatorData:\n    return CalculatorData.create(_GAMEDATA_DIR)\n\n@pytest.fixture(scope=\"module\")\ndef results_data() -> dict[str, dict]:\n    def load(attribs):\n        with open(_DATA_DIR / f\"{attribs}.json\") as f:\n            return json.load(f)\n\n    return {attribs: load(attribs) for attribs in _ATTRIBUTE_SETS}\n\ndef test_attack_power(calc_data, armament, attribs, results_data):\n    affinity, name = armament\n    level = \"0\" if name == \"Meteorite Staff\" else \"10\"\n\n    expected = results_data[attribs][name][affinity][\"attack_power\"]\n    calc = ArmamentCalculator(calc_data, name, affinity, level)\n    ap = calc.attack_power(attribs)\n\n    if ap.physical.total > 0:\n        assert len(expected[\"physical\"]) == 4\n        assert expected[\"physical\"][3] == ap.physical.total\n\n    if ap.magic.total > 0:\n        assert len(expected[\"magic\"]) == 4\n        assert expected[\"magic\"][3] == ap.magic.total\n\n    if ap.fire.total > 0:\n        assert len(expected[\"fire\"]) == 4\n        assert expected[\"fire\"][3] == ap.fire.total\n\n    if ap.lightning.total > 0:\n        assert len(expected[\"lightning\"]) == 4\n        assert expected[\"lightning\"][3] == ap.lightning.total\n\n    if ap.holy.total > 0:\n        assert len(expected[\"holy\"]) == 4\n        assert expected[\"holy\"][3] == ap.holy.total"}
{"type": "test_file", "path": "tests/game_version_test.py", "content": "import pytest\n\nfrom erdb.typing.game_version import GameVersion, GameVersionRange\n\n\ndef _make(major: str, minor: str, patch: str) -> GameVersion:\n    assert len(minor) >= 2, \"Minor part must be at least 2 digits\"\n    return GameVersion(major, minor, patch, [int(major), int(minor), int(patch)])\n\n@pytest.fixture(scope=\"module\")\ndef base() -> GameVersion:\n    return _make(\"1\", \"02\", \"3\")\n\n@pytest.mark.parametrize(\"left,right\", [\n    ([\"1\", \"02\", \"3\"], [\"1\", \"02\", \"3\"]),\n    ([\"1\", \"03\", \"3\"], [\"1\", \"03\", \"3\"]),\n    ([\"3\", \"03\", \"3\"], [\"3\", \"03\", \"3\"]),\n])\ndef test_eq(left: list[str], right: list[str]):\n    assert _make(*left) == _make(*right)\n\n@pytest.mark.parametrize(\"left,right\", [\n    ([\"1\", \"02\", \"4\"], [\"1\", \"02\", \"3\"]),\n    ([\"1\", \"04\", \"3\"], [\"1\", \"03\", \"3\"]),\n    ([\"4\", \"03\", \"3\"], [\"3\", \"03\", \"3\"]),\n])\ndef test_ne(left: list[str], right: list[str]):\n    assert _make(*left) != _make(*right)\n\n@pytest.mark.parametrize(\"left\", [[\"1\", \"02\", \"2\"], [\"1\", \"01\", \"9\"], [\"0\", \"09\", \"9\"]])\ndef test_lt(base, left):\n    assert _make(*left) < base\n\n@pytest.mark.parametrize(\"left\", [[\"1\", \"02\", \"4\"], [\"1\", \"03\", \"0\"], [\"2\", \"00\", \"0\"]])\ndef test_gt(base, left):\n    assert _make(*left) > base\n\n@pytest.mark.parametrize(\"left\", [[\"1\", \"02\", \"2\"], [\"1\", \"02\", \"3\"]])\ndef test_le(base, left):\n    assert _make(*left) <= base\n\n@pytest.mark.parametrize(\"left\", [[\"1\", \"02\", \"3\"], [\"1\", \"02\", \"4\"]])\ndef test_ge(base, left):\n    assert _make(*left) >= base\n\n@pytest.mark.parametrize(\"string,expected\", [\n    (\"1.04.1\", _make(\"1\", \"04\", \"1\")),\n    (\"2.64.9\", _make(\"2\", \"64\", \"9\")),\n    (\"0.03.9\",  _make(\"0\", \"03\", \"9\")),\n])\ndef test_from_string(string: str, expected: GameVersion):\n    assert GameVersion.from_string(string) == expected\n\n@pytest.mark.parametrize(\"string,begin,end\", [\n    (\"from 1.04.1 until 1.05.0\", _make(\"1\", \"04\", \"1\"), _make(\"1\", \"05\", \"0\")),\n    (\"from 1.04.1\", _make(\"1\", \"04\", \"1\"), GameVersion.max()),\n    (\"until 1.05.0\", GameVersion.min(), _make(\"1\", \"05\", \"0\")),\n    (\"only 1.04.1\", _make(\"1\", \"04\", \"1\"), GameVersion.max()),\n    (\"any version\", GameVersion.min(), GameVersion.max()),\n])\ndef test_range_from_string(string: str, begin: GameVersion, end: GameVersion):\n    version_range = GameVersionRange.from_string(string)\n    assert version_range.begin == begin\n    assert version_range.end == end\n\n@pytest.mark.parametrize(\"string,version\", [\n    (\"from 1.04.1 until 1.05.0\", _make(\"1\", \"04\", \"1\")),\n    (\"from 1.04.1 until 1.05.0\", _make(\"1\", \"04\", \"2\")),\n    (\"from 1.04.1 until 1.05.0\", _make(\"1\", \"04\", \"99\")),\n    (\"from 1.04.1\", _make(\"1\", \"04\", \"99\")),\n    (\"from 1.04.1\", _make(\"1\", \"05\", \"0\")),\n    (\"until 1.05.0\", _make(\"1\", \"04\", \"99\")),\n    (\"until 1.05.0\", _make(\"1\", \"03\", \"0\")),\n    (\"only 1.05.0\", _make(\"1\", \"05\", \"0\")),\n    (\"any version\", _make(\"1\", \"04\", \"99\")),\n    (\"any version\", _make(\"1\", \"05\", \"99\")),\n])\ndef test_range_contains(string: str, version: GameVersion):\n    assert version in GameVersionRange.from_string(string)\n\n@pytest.mark.parametrize(\"string,version\", [\n    (\"from 1.04.1 until 1.05.0\", _make(\"1\", \"04\", \"0\")),\n    (\"from 1.04.1 until 1.05.0\", _make(\"1\", \"05\", \"0\")),\n    (\"from 1.04.1 until 1.05.0\", _make(\"1\", \"05\", \"99\")),\n    (\"from 1.04.1\", _make(\"1\", \"04\", \"0\")),\n    (\"from 1.04.1\", _make(\"1\", \"03\", \"99\")),\n    (\"until 1.05.0\", _make(\"1\", \"05\", \"0\")),\n    (\"only 1.05.0\", _make(\"1\", \"04\", \"99\")),\n    (\"only 1.05.0\", _make(\"1\", \"05\", \"1\")),\n])\ndef test_range_not_contains(string: str, version: GameVersion):\n    assert version not in GameVersionRange.from_string(string)"}
{"type": "test_file", "path": "tests/common_test.py", "content": "from typing import List, NamedTuple\nimport pytest\n\nfrom erdb.typing.params import ParamDict\nfrom erdb.utils.common import find_offset_indices\n\n\nclass ParamDictGenerator(NamedTuple):\n    starting_element: int\n    element_interval: int\n    levels: List[int]\n    level_interval: int\n\n    def generate(self) -> ParamDict:\n        def _rangec(start: int, count: int, step: int):\n            return range(start, start + count * step, step)\n\n        element_count = len(self.levels)\n        element_range = _rangec(self.starting_element, element_count, self.element_interval)\n\n        params: ParamDict = dict()\n\n        for row_id, level_count in zip(element_range, self.levels):\n            for offset in _rangec(0, level_count, self.level_interval):\n                params[str(row_id + offset)] = {}\n\n        return params\n\n@pytest.mark.parametrize(\"starting_element,element_interval,levels,level_interval,results\", [\n    (1000, 100, [11, 26, 26], 1, [range(1000, 1011), range(1100, 1126), range(1200, 1226)]),\n    (10000, 10000, [11, 1, 26], 100, [range(10000, 11001, 100), range(20000, 20001, 100), range(30000, 32501, 100)]),\n])\ndef test_find_offset_indices(starting_element: int, element_interval: int, levels: List[int], level_interval: int, results):\n    possible_maxima = list(set([l - 1 for l in levels]))\n    params = ParamDictGenerator(starting_element, element_interval, levels, level_interval).generate()\n\n    for element in range(len(levels)):\n        base = starting_element + element * element_interval\n        ids, levels = find_offset_indices(base, params, possible_maxima, level_interval)\n        element_offset = starting_element + element_interval * element \n\n        assert list(results[element]) == list(ids)\n        assert [index - element_offset for index in results[element]] == list(levels)"}
{"type": "source_file", "path": "src/erdb/__main__.py", "content": "from erdb.main.cli import entrypoint\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(entrypoint())"}
{"type": "source_file", "path": "src/erdb/app_api/__init__.py", "content": ""}
{"type": "source_file", "path": "src/erdb/app_api/endpoints.py", "content": "from typing import Any\nfrom fastapi import Query, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic.dataclasses import dataclass\n\nfrom erdb.table import Table\nfrom erdb.app_api.common import DataProxy, GameVersionEnum\nfrom erdb.utils.common import getattrstr\nfrom erdb.typing.api_version import ApiVersion\n\n\n@dataclass\nclass _Detail:\n    detail: str\n\nclass DataEndpoint:\n    data_proxy: DataProxy\n    api: ApiVersion\n    table: Table\n\n    def __init__(self, data_proxy: DataProxy, api: ApiVersion, table: Table) -> None:\n        self.data_proxy = data_proxy\n        self.api = api\n        self.table = table\n\n    @property\n    def route(self) -> str:\n        return \"/\"\n\n    @property\n    def model(self) -> Any:\n        return dict[str, self.table.spec.model[self.api]] # type: ignore\n\n    @property\n    def summary(self) -> str:\n        return \"multiple items\"\n\n    @property\n    def description(self) -> str:\n        return \"Retrieve a dictionary of item's ascii name -> item properties.\"\n\n    @property\n    def responses(self) -> dict[int, dict]:\n        return {\n            status.HTTP_400_BAD_REQUEST: {\n                \"model\": _Detail,\n                \"description\": \"Bad Request: `query` format is valid, but the specified field does not exist for this model.\"\n            }\n        }\n\n    def __call__(self,\n        game_version: GameVersionEnum,\n        keys: list[str] | None = Query(None, alias=\"k\", description=\"Specify a list of keys (ascii names) to retrieve specific items.\"),\n        query: str | None = Query(None, description=\"Filter elements by field in format \\\"{field}:{value}\\\".\", regex=r\"^\\w+\\:.+$\"),\n    ) -> Any:\n        data = self.data_proxy.generate(self.api, game_version, self.table)\n\n        if keys is not None:\n            data = {k: v for k, v in data.items() if k in keys}\n\n        if query is not None:\n            field, value = query.split(\":\", maxsplit=1)\n\n            try:\n                data = {k: v for k, v in data.items() if getattrstr(v, field) == value}\n            \n            except AttributeError:\n                return JSONResponse(status_code=status.HTTP_400_BAD_REQUEST, content={\"detail\": f\"{self.table.title} has no field: \\\"{field}\\\".\"})\n\n        return data\n\nclass ItemEndpoint:\n    data_proxy: DataProxy\n    api: ApiVersion\n    table: Table\n\n    def __init__(self, data_proxy: DataProxy, api: ApiVersion, table: Table) -> None:\n        self.data_proxy = data_proxy\n        self.api = api\n        self.table = table\n\n    @property\n    def route(self) -> str:\n        return \"/{key}\"\n\n    @property\n    def model(self) -> Any:\n        return self.table.spec.model[self.api]\n\n    @property\n    def summary(self) -> str:\n        return \"single item\"\n\n    @property\n    def description(self) -> str:\n        return \"Retrieve properties of a single item.\"\n\n    @property\n    def responses(self) -> dict[int, dict]:\n        return {\n            status.HTTP_404_NOT_FOUND: {\"model\": _Detail}\n        }\n\n    def __call__(self, game_version: GameVersionEnum, key: str) -> Any:\n        try:\n            return self.data_proxy.generate(self.api, game_version, self.table)[key]\n\n        except KeyError:\n            return JSONResponse(status_code=status.HTTP_404_NOT_FOUND, content={\"detail\": f\"{self.table.title} has no key: \\\"{key}\\\"\"})"}
{"type": "source_file", "path": "src/erdb/effect_parser/__init__.py", "content": "import erdb.effect_parser.attribute_fields as attrib_fields\nimport erdb.effect_parser.parsers as parse\nimport erdb.effect_parser.hardcoded as hardcoded_effects\nfrom erdb.effect_parser.aggregator import aggregate_effects\nfrom erdb.typing.models.effect import StatusEffects\nfrom erdb.typing.params import ParamRow, ParamDict\nfrom erdb.typing.enums import SpEffectType, AttackCondition\nfrom erdb.typing.effects import SchemaEffect\n\n\n_REFERENCE_EFFECT_PARAMS: list[str] = [\"cycleOccurrenceSpEffectId\", \"applyIdOnGetSoul\"]\n\n_SP_EFFECT_TO_FIELD: dict[SpEffectType, str] = {\n    SpEffectType.HEMORRHAGE: \"bloodAttackPower\",\n    SpEffectType.FROSTBITE: \"freezeAttackPower\",\n    SpEffectType.POISON: \"poizonAttackPower\",\n    SpEffectType.SCARLET_ROT: \"diseaseAttackPower\",\n    SpEffectType.SLEEP: \"sleepAttackPower\",\n    SpEffectType.MADNESS: \"madnessAttackPower\",\n    SpEffectType.BLIGHT: \"curseAttackPower\",\n}\n\n_SP_EFFECT_TO_STR: dict[SpEffectType, str] = {\n    SpEffectType.HEMORRHAGE: \"bleed\",\n    SpEffectType.FROSTBITE: \"frostbite\",\n    SpEffectType.POISON: \"poison\",\n    SpEffectType.SCARLET_ROT: \"scarlet_rot\",\n    SpEffectType.SLEEP: \"sleep\",\n    SpEffectType.MADNESS: \"madness\",\n    SpEffectType.BLIGHT: \"death_blight\",\n}\n\ndef get_effects(sp_effect: ParamRow, sp_effect_type: SpEffectType, triggeree: ParamRow | None = None, init_conditions: list[str] | None = None) -> list[SchemaEffect]:\n    effects = hardcoded_effects.get(sp_effect.index, sp_effect_type)\n\n    for field, attrib_field in attrib_fields.get().items():\n        if sp_effect[field] == str(attrib_field.default_value):\n            continue\n\n        effect = SchemaEffect.from_attribute_field(sp_effect[field].as_float, attrib_field)\n\n        effect.conditions = init_conditions\n        if conds := parse.conditions(sp_effect, triggeree):\n            effect.conditions = conds if effect.conditions is None else effect.conditions + conds\n\n        effect.tick_interval = parse.interval(sp_effect)\n        effect.value_pvp = parse.value_pvp(sp_effect, field, attrib_fields.get())\n\n        effects.append(effect)\n\n    return effects\n\ndef get_effects_nested(sp_effect: ParamRow, sp_effects: ParamDict, add_condition: AttackCondition | None) -> list[SchemaEffect]:\n    sp_effect_type = SpEffectType(sp_effect[\"stateInfo\"])\n    effects = get_effects(sp_effect, sp_effect_type, init_conditions=[str(add_condition)] if add_condition else None)\n\n    for ref_id in (sp_effect[ref_field].as_int for ref_field in _REFERENCE_EFFECT_PARAMS):\n        if ref_sp_effect := sp_effects.get(ref_id):\n            if ref_sp_effect.index > 0:\n                effects += get_effects(ref_sp_effect, sp_effect_type, sp_effect)\n\n    for condition_offset in hardcoded_effects.get_conditions(sp_effect.index):\n        ref_sp_effect = sp_effects[sp_effect.index + condition_offset.offset]\n        init_conditions = None if condition_offset.condition is None else [str(condition_offset.condition)]\n        effects += get_effects(ref_sp_effect, sp_effect_type, sp_effect, init_conditions)\n\n    return effects\n\ndef get_status_effect(sp_effect: ParamRow) -> tuple[str, int]:\n    # NOTE: not identifying effects by values, relying on `stateInfo` to be correct at all times\n    etype = SpEffectType(sp_effect[\"stateInfo\"])\n    return _SP_EFFECT_TO_STR[etype], sp_effect[_SP_EFFECT_TO_FIELD[etype]].as_int\n\ndef parse_effects(row: ParamRow, sp_effects: ParamDict, *effect_referencing_fields: str, add_condition: AttackCondition | None = None) -> list[dict]:\n    effects: list[SchemaEffect] = []\n\n    for effect_id in (row[ref_field].as_int for ref_field in effect_referencing_fields):\n        if effect_id in hardcoded_effects.get_status_effect_ranges():\n            continue\n\n        if effect_id in sp_effects:\n            effects += get_effects_nested(sp_effects[effect_id], sp_effects, add_condition)\n\n    return [e.to_dict() for e in aggregate_effects(effects)]\n\ndef parse_status_effects(effect_ids: list[int], sp_effects: ParamDict) -> StatusEffects:\n    # Getting 0th effect if value no found, bug with Antspur Rapier -- get anything to return a 0 status effect\n    effects = [sp_effects.get(i, sp_effects[0]) for i in effect_ids if i != -1]\n    status_effects = hardcoded_effects.get_status_effect_ranges()\n    return StatusEffects(**dict([get_status_effect(e) for e in effects if e.index in status_effects]))\n\ndef parse_weapon_effects(weapon: ParamRow) -> list[dict]:\n    effects: list[SchemaEffect] = []\n\n    for field, attrib_field in attrib_fields.get(weapon=True).items():\n        if weapon[field] != str(attrib_field.default_value):\n            effects.append(SchemaEffect.from_attribute_field(weapon[field].as_float, attrib_field))\n\n    return [e.to_dict() for e in effects]"}
{"type": "source_file", "path": "src/erdb/effect_parser/aggregator.py", "content": "import operator as op\nfrom types import SimpleNamespace\nfrom typing import NamedTuple, Self\n\nfrom erdb.typing.effects import AttributeName, SchemaEffect\n\n\n_A = AttributeName\n\nclass AttributeAggregatorHint(NamedTuple):\n    base: set[AttributeName]\n    effective: AttributeName\n\nclass AggregatedSchemaEffect(SimpleNamespace):\n    attribute_names: set[AttributeName]\n    example_effect: SchemaEffect\n\n    @classmethod\n    def from_effect(cls, effect: SchemaEffect) -> Self:\n        return cls(attribute_names={effect.attribute}, example_effect=effect)\n\n\"\"\"\nSpecifies which attribute sets can be collapsed into their effective attribute.\nORDER IS IMPORTANT because effective attributes are taken into consideration in\nconsecutive iterations.\n\"\"\"\n_AGGREGATOR_HINTS: list[AttributeAggregatorHint] = [\n    AttributeAggregatorHint(\n        base={_A.STANDARD_ABSORPTION, _A.STRIKE_ABSORPTION, _A.SLASH_ABSORPTION, _A.PIERCE_ABSORPTION},\n        effective=_A.PHYSICAL_ABSORPTION\n    ),\n    AttributeAggregatorHint(\n        base={_A.MAGIC_ABSORPTION, _A.FIRE_ABSORPTION, _A.LIGHTNING_ABSORPTION, _A.HOLY_ABSORPTION},\n        effective=_A.ELEMENTAL_ABSORPTION\n    ),\n    AttributeAggregatorHint(\n        base={_A.PHYSICAL_ABSORPTION, _A.ELEMENTAL_ABSORPTION},\n        effective=_A.ABSORPTION\n    ),\n    AttributeAggregatorHint(\n        base={_A.STANDARD_ATTACK_POWER, _A.STRIKE_ATTACK_POWER, _A.SLASH_ATTACK_POWER, _A.PIERCE_ATTACK_POWER},\n        effective=_A.PHYSICAL_ATTACK_POWER\n    ),\n    AttributeAggregatorHint(\n        base={_A.MAGIC_ATTACK_POWER, _A.FIRE_ATTACK_POWER, _A.LIGHTNING_ATTACK_POWER, _A.HOLY_ATTACK_POWER},\n        effective=_A.ELEMENTAL_ATTACK_POWER\n    ),\n    AttributeAggregatorHint(\n        base={_A.PHYSICAL_ATTACK_POWER, _A.ELEMENTAL_ATTACK_POWER},\n        effective=_A.ATTACK_POWER\n    ),\n    AttributeAggregatorHint(\n        base={_A.POISON_RESISTANCE, _A.SCARLET_ROT_RESISTANCE},\n        effective=_A.IMMUNITY\n    ),\n    AttributeAggregatorHint(\n        base={_A.BLEED_RESISTANCE, _A.FROSTBITE_RESISTANCE},\n        effective=_A.ROBUSTNESS\n    ),\n    AttributeAggregatorHint(\n        base={_A.SLEEP_RESISTANCE, _A.MADNESS_RESISTANCE},\n        effective=_A.FOCUS\n    ),\n    AttributeAggregatorHint(\n        base={_A.DEATH_BLIGHT_RESISTANCE},\n        effective=_A.VITALITY\n    ),\n    AttributeAggregatorHint(\n        base={_A.SORCERY_FOCUS_CONSUMPTION, _A.INCANTATION_FOCUS_CONSUMPTION, _A.PYROMANCY_FOCUS_CONSUMPTION},\n        effective=_A.SPELL_FOCUS_CONSUMPTION\n    ),\n    AttributeAggregatorHint(\n        base={_A.SORCERY_FOCUS_CONSUMPTION, _A.INCANTATION_FOCUS_CONSUMPTION}, # since pyromancies are unused\n        effective=_A.SPELL_FOCUS_CONSUMPTION\n    ),\n]\n\ndef _get_aggregated_effects(effects: list[SchemaEffect]) -> dict[int, AggregatedSchemaEffect]:\n    aggregated_effects: dict[int, AggregatedSchemaEffect] = dict()\n\n    for effect in effects:\n        if (key := effect.get_values_hash()) in aggregated_effects:\n            aggregated_effects[key].attribute_names.add(effect.attribute)\n        else:\n            aggregated_effects[key] = AggregatedSchemaEffect.from_effect(effect)\n\n    return aggregated_effects\n\ndef _aggregate_attributes(attributes: set[AttributeName], hints: list[AttributeAggregatorHint]) -> set[AttributeName]:\n    for hint in hints:\n        if hint.base.issubset(attributes):\n            attributes.difference_update(hint.base)\n            attributes.add(hint.effective)\n\n    return attributes\n\ndef _aggregated_effects_to_effects(aggregated_effects: dict[int, AggregatedSchemaEffect]) -> list[SchemaEffect]:\n    effects = []\n\n    for aggregated_effect in aggregated_effects.values():\n        for attribute_name in aggregated_effect.attribute_names:\n            effects.append(aggregated_effect.example_effect.clone(attribute_name))\n\n    return effects\n\ndef aggregate_effects(base_effects: list[SchemaEffect]) -> list[SchemaEffect]:\n    aggregated_effects = _get_aggregated_effects(base_effects)\n\n    for key, aggregated_effect in aggregated_effects.items():\n        aggregated_effects[key].attribute_names = _aggregate_attributes(aggregated_effect.attribute_names, _AGGREGATOR_HINTS)\n\n    return sorted(_aggregated_effects_to_effects(aggregated_effects), key=op.attrgetter(\"attribute\"))"}
{"type": "source_file", "path": "src/erdb/effect_parser/attribute_fields.py", "content": "import erdb.effect_parser.parsers as parse\nfrom erdb.typing.effects import EffectModel, EffectType, AttributeName, AttributeField\nfrom erdb.typing.enums import AttackCondition\n\n\n_ATTRIBUTE_FIELDS = {\n    \"maxHpRate\": AttributeField.create(\n        attribute=AttributeName.MAXIMUM_HEALTH,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changeHpPoint\": AttributeField.create(\n        attribute=AttributeName.HEALTH_POINTS,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"changeHpRate\": AttributeField.create(\n        attribute=AttributeName.HEALTH_POINTS,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse_percentage,\n        default_value=0\n    ),\n    \"changeHpEstusFlaskCorrectRate\": AttributeField.create(\n        attribute=AttributeName.FLASK_HEALTH_RESTORATION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"maxMpRate\": AttributeField.create(\n        attribute=AttributeName.MAXIMUM_FOCUS,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changeMpPoint\": AttributeField.create(\n        attribute=AttributeName.FOCUS_POINTS,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"changeMpRate\": AttributeField.create(\n        attribute=AttributeName.FOCUS_POINTS,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse_percentage,\n        default_value=0\n    ),\n    \"changeMpEstusFlaskCorrectRate\": AttributeField.create(\n        attribute=AttributeName.FLASK_FOCUS_RESTORATION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"maxStaminaRate\": AttributeField.create(\n        attribute=AttributeName.MAXIMUM_STAMINA,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"staminaRecoverChangeSpeed\": AttributeField.create(\n        attribute=AttributeName.STAMINA_RECOVERY_SPEED,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"equipWeightChangeRate\": AttributeField.create(\n        attribute=AttributeName.MAXIMUM_EQUIP_LOAD,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"toughnessDamageCutRate\": AttributeField.create(\n        attribute=AttributeName.POISE,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.poise\n    ),\n    \"addLifeForceStatus\": AttributeField.create(\n        attribute=AttributeName.VIGOR,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"addWillpowerStatus\": AttributeField.create(\n        attribute=AttributeName.MIND,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"addEndureStatus\": AttributeField.create(\n        attribute=AttributeName.ENDURANCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"addStrengthStatus\": AttributeField.create(\n        attribute=AttributeName.STRENGHT,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"addDexterityStatus\": AttributeField.create(\n        attribute=AttributeName.DEXTERITY,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"addMagicStatus\": AttributeField.create(\n        attribute=AttributeName.INTELLIGENCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"addFaithStatus\": AttributeField.create(\n        attribute=AttributeName.FAITH,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"addLuckStatus\": AttributeField.create(\n        attribute=AttributeName.ARCANE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"neutralDamageCutRate\": AttributeField.create(\n        attribute=AttributeName.STANDARD_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"blowDamageCutRate\": AttributeField.create(\n        attribute=AttributeName.STRIKE_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"slashDamageCutRate\": AttributeField.create(\n        attribute=AttributeName.SLASH_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"thrustDamageCutRate\": AttributeField.create(\n        attribute=AttributeName.PIERCE_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"defEnemyDmgCorrectRate_Physics\": AttributeField.create(\n        attribute=AttributeName.PHYSICAL_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"magicDamageCutRate\": AttributeField.create(\n        attribute=AttributeName.MAGIC_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"defEnemyDmgCorrectRate_Magic\": AttributeField.create(\n        attribute=AttributeName.MAGIC_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"fireDamageCutRate\": AttributeField.create(\n        attribute=AttributeName.FIRE_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"defEnemyDmgCorrectRate_Fire\": AttributeField.create(\n        attribute=AttributeName.FIRE_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"thunderDamageCutRate\": AttributeField.create(\n        attribute=AttributeName.LIGHTNING_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"defEnemyDmgCorrectRate_Thunder\": AttributeField.create(\n        attribute=AttributeName.LIGHTNING_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"darkDamageCutRate\": AttributeField.create(\n        attribute=AttributeName.HOLY_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"defEnemyDmgCorrectRate_Dark\": AttributeField.create(\n        attribute=AttributeName.HOLY_ABSORPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic_inverse\n    ),\n    \"neutralAttackPowerRate\": AttributeField.create(\n        attribute=AttributeName.STANDARD_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"blowAttackPowerRate\": AttributeField.create(\n        attribute=AttributeName.STRIKE_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"slashAttackPowerRate\": AttributeField.create(\n        attribute=AttributeName.SLASH_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"thrustAttackPowerRate\": AttributeField.create(\n        attribute=AttributeName.PIERCE_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"physicsAttackPowerRate\": AttributeField.create(\n        attribute=AttributeName.PHYSICAL_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"physicsAttackRate\": AttributeField.create(\n        attribute=AttributeName.PHYSICAL_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"atkEnemyDmgCorrectRate_Physics\": AttributeField.create(\n        attribute=AttributeName.PHYSICAL_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"magicAttackRate\": AttributeField.create(\n        attribute=AttributeName.MAGIC_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"atkEnemyDmgCorrectRate_Magic\": AttributeField.create(\n        attribute=AttributeName.MAGIC_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"fireAttackRate\": AttributeField.create(\n        attribute=AttributeName.FIRE_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"atkEnemyDmgCorrectRate_Fire\": AttributeField.create(\n        attribute=AttributeName.FIRE_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"thunderAttackRate\": AttributeField.create(\n        attribute=AttributeName.LIGHTNING_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"atkEnemyDmgCorrectRate_Thunder\": AttributeField.create(\n        attribute=AttributeName.LIGHTNING_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"darkAttackRate\": AttributeField.create(\n        attribute=AttributeName.HOLY_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"atkEnemyDmgCorrectRate_Dark\": AttributeField.create(\n        attribute=AttributeName.HOLY_ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"staminaAttackRate\": AttributeField.create(\n        attribute=AttributeName.STAMINA_ATTACK_RATE,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"guardStaminaCutRate\": AttributeField.create(\n        attribute=AttributeName.STABILITY,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changePoisonResistPoint\": AttributeField.create(\n        attribute=AttributeName.POISON_RESISTANCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changeDiseaseResistPoint\": AttributeField.create(\n        attribute=AttributeName.SCARLET_ROT_RESISTANCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changeBloodResistPoint\": AttributeField.create(\n        attribute=AttributeName.BLEED_RESISTANCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changeFreezeResistPoint\": AttributeField.create(\n        attribute=AttributeName.FROSTBITE_RESISTANCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changeSleepResistPoint\": AttributeField.create(\n        attribute=AttributeName.SLEEP_RESISTANCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changeMadnessResistPoint\": AttributeField.create(\n        attribute=AttributeName.MADNESS_RESISTANCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changeCurseResistPoint\": AttributeField.create(\n        attribute=AttributeName.DEATH_BLIGHT_RESISTANCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"changeMagicSlot\": AttributeField.create(\n        attribute=AttributeName.MEMORY_SLOTS,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"dexterityCancelSystemOnlyAddDexterity\": AttributeField.create(\n        attribute=AttributeName.CASTING_SPEED,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"extendLifeRate\": AttributeField.create(\n        attribute=AttributeName.SPELL_DURATION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"magicConsumptionRate\": AttributeField.create(\n        attribute=AttributeName.SORCERY_FOCUS_CONSUMPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.NEGATIVE,\n        parser=parse.generic\n    ),\n    \"miracleConsumptionRate\": AttributeField.create(\n        attribute=AttributeName.INCANTATION_FOCUS_CONSUMPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.NEGATIVE,\n        parser=parse.generic\n    ),\n    \"shamanConsumptionRate\": AttributeField.create( # likely unused\n        attribute=AttributeName.PYROMANCY_FOCUS_CONSUMPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.NEGATIVE,\n        parser=parse.generic\n    ),\n    \"artsConsumptionRate\": AttributeField.create(\n        attribute=AttributeName.SKILL_FOCUS_CONSUMPTION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.NEGATIVE,\n        parser=parse.generic\n    ),\n    \"bowDistRate\": AttributeField.create(\n        attribute=AttributeName.BOW_DISTANCE,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"hearingSearchEnemyRate\": AttributeField.create(\n        attribute=AttributeName.ENEMY_HEARING,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.NEGATIVE,\n        parser=parse.generic\n    ),\n    \"fallDamageRate\": AttributeField.create(\n        attribute=AttributeName.FALL_DAMAGE,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.NEGATIVE,\n        parser=parse.generic\n    ),\n    \"itemDropRate\": AttributeField.create(\n        attribute=AttributeName.ITEM_DISCOVERY,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.item_discovery\n    ),\n    \"soulRate\": AttributeField.create(\n        attribute=AttributeName.RUNE_ACQUISITION,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n    \"soul\": AttributeField.create(\n        attribute=AttributeName.RUNE_ACQUISITION,\n        effect_model=EffectModel.ADDITIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic\n    ),\n}\n\n_WEAPON_ATTRIBUTE_FIELDS = {\n    \"weakA_DamageRate\": AttributeField.create(\n        attribute=AttributeName.ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic,\n        conditions=[str(AttackCondition.VS_GRAVITY_ENEMIES)]\n    ),\n    \"weakB_DamageRate\": AttributeField.create(\n        attribute=AttributeName.ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic,\n        conditions=[str(AttackCondition.VS_UNDEAD_ENEMIES)]\n    ),\n    \"weakC_DamageRate\": AttributeField.create(\n        attribute=AttributeName.ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic,\n        conditions=[str(AttackCondition.VS_DRAGON_ENEMIES)]\n    ),\n    \"weakD_DamageRate\": AttributeField.create(\n        attribute=AttributeName.ATTACK_POWER,\n        effect_model=EffectModel.MULTIPLICATIVE,\n        effect_type=EffectType.POSITIVE,\n        parser=parse.generic,\n        conditions=[str(AttackCondition.VS_ANCIENT_DRAGON_ENEMIES)]\n    ),\n}\n\ndef get(weapon: bool = False) -> dict[str, AttributeField]:\n    return _WEAPON_ATTRIBUTE_FIELDS if weapon else _ATTRIBUTE_FIELDS"}
{"type": "source_file", "path": "src/erdb/effect_parser/parsers.py", "content": "import math\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import SpEffectType, AttackType\nfrom erdb.typing.effects import AttributeField, EffectModel\n\n\n_TRIGGER_FIELDS = [\n    \"stateInfo\", \"invocationConditionsStateChange1\",\n    \"invocationConditionsStateChange2\", \"invocationConditionsStateChange3\"\n]\n\n_CONDITION_FIELDS = [\n    \"magicSubCategoryChange1\", \"magicSubCategoryChange2\", \"magicSubCategoryChange3\"\n]\n\n_PVE_TO_PVP = {\n    \"defEnemyDmgCorrectRate_Physics\": \"defPlayerDmgCorrectRate_Physics\",\n    \"defEnemyDmgCorrectRate_Magic\":   \"defPlayerDmgCorrectRate_Magic\",\n    \"defEnemyDmgCorrectRate_Fire\":    \"defPlayerDmgCorrectRate_Fire\",\n    \"defEnemyDmgCorrectRate_Thunder\": \"defPlayerDmgCorrectRate_Thunder\",\n    \"defEnemyDmgCorrectRate_Dark\":    \"defPlayerDmgCorrectRate_Dark\",\n    \"atkEnemyDmgCorrectRate_Physics\": \"atkPlayerDmgCorrectRate_Physics\",\n    \"atkEnemyDmgCorrectRate_Magic\":   \"atkPlayerDmgCorrectRate_Magic\",\n    \"atkEnemyDmgCorrectRate_Fire\":    \"atkPlayerDmgCorrectRate_Fire\",\n    \"atkEnemyDmgCorrectRate_Thunder\": \"atkPlayerDmgCorrectRate_Thunder\",\n    \"atkEnemyDmgCorrectRate_Dark\":    \"atkPlayerDmgCorrectRate_Dark\",\n}\n\ndef _floor_decimal_2(value: float) -> float:\n    value = round(value, 6) # do not floor cases like 1.89999999999\n    return math.floor(value * 100) / 100.0\n\ndef conditions(sp_effect: ParamRow, triggeree: ParamRow | None = None) -> list[str] | None:\n    conds = set()\n\n    def _append_triggers(source: ParamRow):\n        for trigger in _TRIGGER_FIELDS:\n            effect_type = SpEffectType(source[trigger])\n\n            if not effect_type.is_passive():\n                conds.add(str(effect_type))\n\n            if effect_type == SpEffectType.SPELL_POWER_BOOST:\n                boostSorcery = (\"magParamChange\", \"Affects Sorceries\")\n                boostIncantation = (\"miracleParamChange\", \"Affects Incantations\")\n                for field, cond in [boostSorcery, boostIncantation]:\n                    if sp_effect[field].as_bool:\n                        conds.add(cond)\n\n    def _append_conditions(source: ParamRow):\n        for cond in _CONDITION_FIELDS:\n            attack_type_str = source[cond]\n            if (cond := AttackType(attack_type_str)) != AttackType.NONE:\n                conds.add(str(cond))\n\n    for field, direction in [(\"conditionHp\", \"below\"), (\"conditionHpRate\", \"above\")]:\n        if cond := sp_effect[field].get_int():\n            conds.add(f\"HP {direction} {cond}%\")\n\n    _append_triggers(sp_effect)\n    _append_conditions(sp_effect)\n\n    if triggeree:\n        _append_triggers(triggeree)\n        _append_conditions(triggeree)\n\n    return None if len(conds) == 0 else sorted(list(conds))\n\ndef interval(sp_effect: ParamRow) -> float | None:\n    interv = sp_effect[\"motionInterval\"]\n    return None if interv == \"0\" else float(interv)\n\ndef value_pvp(sp_effect: ParamRow, field_pve: str, attrib_fields: dict[str, AttributeField]) -> float | None:\n    if not (field_pvp := _PVE_TO_PVP.get(field_pve, None)):\n        return None\n\n    attrib_field = attrib_fields[field_pve]\n    val = sp_effect[field_pvp].as_float\n\n    return attrib_field.parser(val, attrib_field.effect_model)\n\ndef generic(value: float, model: EffectModel) -> float:\n    return value\n\ndef generic_inverse(value: float, model: EffectModel) -> float:\n    \"\"\"\n    Some sp_effect fields are hardcoded to be subtractable/divisible. Because of this,\n    their values are negative in the params. Specifying this parser will reverse\n    these values on per effect basis to have them make more sense.\n\n    Examples:\n    - Blessed Dew Talisman's `changeHpPoint` is set to -2 when it should heal\n    - Malenia - Scarlet Rot's `changeHpPoint` is set to 26 when it should damage\n    \"\"\"\n    return -value if model == EffectModel.ADDITIVE else _floor_decimal_2(2 - value)\n\ndef generic_inverse_percentage(value: float, model: EffectModel) -> float:\n    \"\"\"\n    Flat percentage value, but also inverse. Turn -10 into 1.1 (ex. Assassin's Crimson Dagger).\n    \"\"\"\n    return 1 + (-value / 100.0)\n\ndef poise(value: float, model: EffectModel) -> float:\n    \"\"\"\n    Poise value is given as a \"poise damage absorption\" value, eg. `0.75`.\n    The actual poise increase that is shown in game is the inverse of that:\n        1 / .75 -> +33% poise.\n    \"\"\"\n    return math.floor(1 / value * 100) / 100.0\n\ndef item_discovery(value: float, model: EffectModel) -> float:\n    return value * 100"}
{"type": "source_file", "path": "src/erdb/loaders/__init__.py", "content": "import importlib.resources\nfrom pathlib import Path\n\nfrom erdb.typing.game_version import GameVersion\n\n\nTOP_LEVEL_PKG = __name__.split(\".\")[0]\nPKG_DATA_PATH = Path(str(importlib.resources.files(TOP_LEVEL_PKG))) / \"data\"\nGAME_VERSIONS = sorted(\n    [GameVersion.from_string(p.stem) for p in (PKG_DATA_PATH / \"gamedata\").glob(\"*zip\")],\n    reverse=True\n)"}
{"type": "source_file", "path": "src/erdb/loaders/contrib.py", "content": "import json\nfrom pathlib import Path\n\nfrom erdb.typing.game_version import GameVersion, GameVersionRange\nfrom erdb.loaders import PKG_DATA_PATH\n\n\ndef _overlay_properties(ret: dict, source: dict):\n    \"\"\"\n    Append to lists and sets, override scalars and dictionaries\n    \"\"\"\n    for key, value in source.items():\n        if isinstance(value, list):\n            ret[key] = ret.get(key, list()) + value\n        elif isinstance(value, set):\n            ret[key] = ret.get(key, set()) + value # type: ignore\n        else:\n            ret[key] = value\n\ndef _parse_user_file(path: Path, version: GameVersion) -> dict:\n    assert path.is_file\n    assert path.suffix == \".json\"\n\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n\n    ret = dict()\n\n    for version_range, properties in data.items():\n        if version in GameVersionRange.from_string(version_range):\n            _overlay_properties(ret, properties)\n\n    return ret\n\ndef load(element: str, version: GameVersion) -> dict[str, dict]:\n    path = PKG_DATA_PATH / \"contrib\" / element\n    files = path.iterdir() if path.is_dir() else []\n    return {f.stem: _parse_user_file(f, version) for f in files}"}
{"type": "source_file", "path": "src/erdb/loaders/params.py", "content": "from typing import Iterator\nimport xml.etree.ElementTree as xmltree\nfrom csv import DictReader\nfrom zipfile import Path as ZipPath\n\nfrom erdb.loaders import PKG_DATA_PATH\nfrom erdb.typing.game_version import GameVersion\nfrom erdb.typing.params import ParamRow, ParamDict\nfrom erdb.typing.enums import ItemIDFlag\n\n\ndef _load(param: str, version: GameVersion) -> Iterator[dict[str, str]]:\n    archive = PKG_DATA_PATH / \"gamedata\" / f\"{version}.zip\"\n    with ZipPath(archive, at=f\"{param}.csv\").open(mode=\"r\") as f:\n        yield from DictReader(f, delimiter=\";\") # type: ignore\n\ndef load(param: str, version: GameVersion, item_id_flag: ItemIDFlag) -> ParamDict:\n    return {int(row[\"Row ID\"]): ParamRow.make(row, item_id_flag) for row in _load(param, version)}\n\n# optimal variant for params with a lot of IDs like spEffects\ndef load_ids(param: str, version: GameVersion, item_id_flag: ItemIDFlag, id_min: int, id_max: int = 999999999) -> ParamDict:\n    return {int(row[\"Row ID\"]): ParamRow.make(row, item_id_flag) for row in _load(param, version) if id_min <= int(row[\"Row ID\"]) <= id_max}\n\ndef load_msg(filename: str, version: GameVersion) -> dict[int, str]:\n    archive = PKG_DATA_PATH / \"gamedata\" / f\"{version}.zip\"\n    with ZipPath(archive, at=f\"{filename}.fmg.xml\").open(mode=\"r\", encoding=\"utf-8\") as f:\n        tree = xmltree.fromstring(f.read())\n        entries = tree.findall(\".//text\")\n\n    return {int(str(e.get(\"id\"))): str(e.text) for e in entries if e.text != \"%null%\"}"}
{"type": "source_file", "path": "src/erdb/main/__init__.py", "content": ""}
{"type": "source_file", "path": "src/erdb/main/cli.py", "content": "import sys\nfrom typing import Sequence\n\nfrom erdb.main.app import App\n\n\ndef entrypoint(argv: Sequence[str] | None = None) -> int:\n    app = App(sys.argv[1:] if argv is None else argv)\n    return app.run()"}
{"type": "source_file", "path": "src/erdb/table/_retrievers.py", "content": "from typing import NamedTuple\n\nfrom erdb.typing.game_version import GameVersion\nfrom erdb.loaders.params import load as load_params, load_ids as load_param_ids, load_msg\nfrom erdb.loaders.contrib import load as load_contrib\nfrom erdb.typing.params import ParamDict\nfrom erdb.typing.enums import ItemIDFlag\nfrom erdb.shop import Lookup\n\n\nclass RetrieverData(NamedTuple):\n    main_param: ParamDict\n    params: dict[str, ParamDict]\n    msgs: dict[str, dict[int, str]]\n    shops: dict[str, Lookup]\n    contrib: dict[str, dict]\n\nclass ParamDictRetriever(NamedTuple):\n    param_name: str\n    item_id_flag: ItemIDFlag\n    id_min: int | None = None\n    id_max: int | None = None\n\n    def get(self, version: GameVersion) -> ParamDict:\n        args = [self.param_name, version, self.item_id_flag]\n        args += [arg for arg in [self.id_min, self.id_max] if arg is not None]\n        func = load_params if len(args) <= 3 else load_param_ids\n        return func(*args) # type: ignore\n\n    def __contains__(self, __x: object) -> bool:\n        assert isinstance(__x, int), f\"Can only check for integer range\"\n        return  (not self.id_min or self.id_min <= __x) \\\n            and (not self.id_max or self.id_max >= __x)\n\nclass MsgsRetriever(NamedTuple):\n    file_name: str\n\n    def get(self, version: GameVersion) -> dict[int, str]:\n        return load_msg(self.file_name, version)\n\nclass ShopRetriever(NamedTuple):\n    shop_lineup_id_min: int | None\n    shop_lineup_id_max: int | None\n    material_set_id_min: int | None\n    material_set_id_max: int | None\n    recipe: bool = False\n\n    def get(self, version: GameVersion) -> Lookup:\n        F = ParamDictRetriever\n        shop_param = \"ShopLineupParam_Recipe\" if self.recipe else \"ShopLineupParam\"\n        shop = F(shop_param, ItemIDFlag.NON_EQUIPABBLE, self.shop_lineup_id_min, self.shop_lineup_id_max)\n        mats = F(\"EquipMtrlSetParam\", ItemIDFlag.NON_EQUIPABBLE, self.material_set_id_min, self.material_set_id_max)\n        return Lookup(shop.get(version), mats.get(version))\n\nclass ContribRetriever(NamedTuple):\n    def get(self, element_name: str, version: GameVersion) -> dict[str, dict]:\n        return load_contrib(element_name, version)"}
{"type": "source_file", "path": "src/erdb/table/armaments.py", "content": "from erdb.typing.models.armament import Armament, AffinityProperties, Guard, CorrectionCalcID, Scaling\nfrom erdb.typing.models.common import Damage, StatRequirements\nfrom erdb.typing.models.effect import Effect, StatusEffects\nfrom erdb.typing.params import ParamRow, ParamDict\nfrom erdb.typing.enums import Affinity, AttackCondition, ItemIDFlag, AshOfWarMountType, AttackAttribute, ArmamentUpgradeMaterial\nfrom erdb.typing.categories import ArmamentCategory\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.utils.common import find_offset_indices, remove_nulls\nfrom erdb.effect_parser import parse_effects, parse_status_effects, parse_weapon_effects\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\n_BEHAVIOR_EFFECTS_FIELDS: list[str] = [\"spEffectBehaviorId0\", \"spEffectBehaviorId1\", \"spEffectBehaviorId2\"]\n_RESIDENT_EFFECTS_FIELDS: list[str] = [\"residentSpEffectId\", \"residentSpEffectId1\", \"residentSpEffectId2\"]\n\ndef _get_attack_attributes(row: ParamRow) -> list[AttackAttribute]:\n    attributes = {AttackAttribute.from_id(row[field].as_int) for field in [\"atkAttribute\", \"atkAttribute2\"]}\n    return sorted(list(attributes))\n\ndef _get_upgrade_costs(row: ParamRow, reinforces: ParamDict) -> list[int]:\n    reinforcement_id = row[\"reinforceTypeId\"].as_int\n\n    reinforcement = reinforces[reinforcement_id]\n    base_price = row[\"reinforcePrice\"].as_int\n\n    indices, _ = find_offset_indices(reinforcement.index, reinforces, possible_maxima=[0, 10, 25])\n    next(indices) # ignore first index\n\n    return [round(base_price * reinforces[i][\"reinforcePriceRate\"].as_float) for i in indices]\n\ndef _get_correction_calc_ids(row: ParamRow) -> CorrectionCalcID:\n    return CorrectionCalcID(\n        physical=row[\"correctType_Physics\"].as_int,\n        magic=row[\"correctType_Magic\"].as_int,\n        fire=row[\"correctType_Fire\"].as_int,\n        lightning=row[\"correctType_Thunder\"].as_int,\n        holy=row[\"correctType_Dark\"].as_int,\n        poison=row[\"correctType_Poison\"].as_int,\n        bleed=row[\"correctType_Blood\"].as_int,\n        sleep=row[\"correctType_Sleep\"].as_int,\n        madness=row[\"correctType_Madness\"].as_int\n    )\n\ndef _get_requirements(row: ParamRow) -> StatRequirements:\n    data = {\n        \"strength\": row[\"properStrength\"].get_int(null_value=0),\n        \"dexterity\": row[\"properAgility\"].get_int(null_value=0),\n        \"intelligence\": row[\"properMagic\"].get_int(null_value=0),\n        \"faith\": row[\"properFaith\"].get_int(null_value=0),\n        \"arcane\": row[\"properLuck\"].get_int(null_value=0),\n    }\n\n    return StatRequirements(**remove_nulls(data))\n\ndef _get_damages(row: ParamRow) -> Damage:\n    data = {\n        \"physical\": row[\"attackBasePhysics\"].get_int(null_value=0),\n        \"magic\": row[\"attackBaseMagic\"].get_int(null_value=0),\n        \"fire\": row[\"attackBaseFire\"].get_int(null_value=0),\n        \"lightning\": row[\"attackBaseThunder\"].get_int(null_value=0),\n        \"holy\": row[\"attackBaseDark\"].get_int(null_value=0),\n        \"stamina\": row[\"attackBaseStamina\"].get_int(null_value=0),\n    }\n\n    return Damage(**remove_nulls(data))\n\ndef _get_scalings(row: ParamRow) -> Scaling:\n    formatter = lambda x: x / 100.\n    data = {\n        \"strength\": row[\"correctStrength\"].get_float(null_value=0, formatter=formatter),\n        \"dexterity\": row[\"correctAgility\"].get_float(null_value=0, formatter=formatter),\n        \"intelligence\": row[\"correctMagic\"].get_float(null_value=0, formatter=formatter),\n        \"faith\": row[\"correctFaith\"].get_float(null_value=0, formatter=formatter),\n        \"arcane\": row[\"correctLuck\"].get_float(null_value=0, formatter=formatter),\n    }\n\n    return Scaling(**remove_nulls(data))\n\ndef _get_guards(row: ParamRow) -> Guard:\n    data = {\n        \"physical\": row[\"physGuardCutRate\"].get_float(null_value=0),\n        \"magic\": row[\"magGuardCutRate\"].get_float(null_value=0),\n        \"fire\": row[\"fireGuardCutRate\"].get_float(null_value=0),\n        \"lightning\": row[\"thunGuardCutRate\"].get_float(null_value=0),\n        \"holy\": row[\"darkGuardCutRate\"].get_float(null_value=0),\n        \"guard_boost\": row[\"staminaGuardDef\"].get_float(null_value=0),\n    }\n\n    return Guard(**remove_nulls(data))\n\ndef _get_resistances(row: ParamRow) -> StatusEffects:\n    data = {\n        \"poison\": row[\"poisonGuardResist\"].get_int(null_value=0),\n        \"scarlet_rot\": row[\"diseaseGuardResist\"].get_int(null_value=0),\n        \"frostbite\": row[\"freezeGuardResist\"].get_int(null_value=0),\n        \"bleed\": row[\"bloodGuardResist\"].get_int(null_value=0),\n        \"sleep\": row[\"sleepGuardResist\"].get_int(null_value=0),\n        \"madness\": row[\"madnessGuardResist\"].get_int(null_value=0),\n        \"death_blight\": row[\"curseGuardResist\"].get_int(null_value=0),\n    }\n\n    return StatusEffects(**remove_nulls(data))\n\ndef get_status_effect_overlay(row: ParamRow, effects: ParamDict, reinforces: ParamDict, reinforcement_id: int) -> list[StatusEffects]:\n    if (reinforcement := reinforces.get(reinforcement_id + 1)) is None:\n        return []\n\n    effect_fields = [\"spEffectId1\", \"spEffectId2\", \"spEffectId3\"]\n    effect_fields = [f for f in effect_fields if reinforcement[f].as_int > 0]\n\n    assert len(effect_fields) <= 1, \"Up to one effect field can have offset added\"\n\n    if len(effect_fields) == 0:\n        return []\n\n    assert (reinforcement_id + 25) in reinforces, \"Only +25 reinforcements upgrade status effects\"\n\n    weapfield = {\n        \"spEffectId1\": \"spEffectBehaviorId0\",\n        \"spEffectId2\": \"spEffectBehaviorId1\",\n        \"spEffectId3\": \"spEffectBehaviorId2\",\n    }[effect_fields[0]]\n\n    effect_ids = [row[weapfield].as_int + offset for offset in range(0, 26)]\n    return [parse_status_effects([i], effects) for i in effect_ids]\n\ndef _get_affinity_properties(row: ParamRow, effects: ParamDict, reinforces: ParamDict) -> AffinityProperties:\n    reinforcement_id = row[\"reinforceTypeId\"].as_int\n    return AffinityProperties(\n        full_hex_id=row.index_hex,\n        id=row.index,\n        reinforcement_id=reinforcement_id,\n        correction_attack_id=row[\"attackElementCorrectId\"].as_int,\n        correction_calc_id=_get_correction_calc_ids(row),\n        damage=_get_damages(row),\n        scaling=_get_scalings(row),\n        guard=_get_guards(row),\n        resistance=_get_resistances(row),\n        status_effects=parse_status_effects([row[f].as_int for f in _BEHAVIOR_EFFECTS_FIELDS], effects),\n        status_effect_overlay=get_status_effect_overlay(row, effects, reinforces, reinforcement_id),\n    )\n\ndef _get_affinities(row: ParamRow, armaments: ParamDict, effects: ParamDict, reinforces: ParamDict, allow_ash_of_war: bool) -> dict[Affinity, AffinityProperties]:\n    possible_maxima = [0, 12] if allow_ash_of_war else [0]\n    indices, levels = find_offset_indices(row.index, armaments, possible_maxima, increment=100)\n    affinities: list[Affinity] = [Affinity.from_id(round(l / 100)) for l in levels]\n    return {a: _get_affinity_properties(armaments[i], effects, reinforces) for i, a in zip(indices, affinities)}\n\nclass ArmamentTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Armament,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamWeapon\", ItemIDFlag.WEAPONS, id_min=1000000, id_max=49000000)\n\n    predicates: list[RowPredicate] = [\n        lambda row: row.index % 10000 == 0,\n        lambda row: len(row.name) > 0,\n    ]\n\n    param_retrievers = {\n        \"effects\": ParamDictRetriever(\"SpEffectParam\", ItemIDFlag.NON_EQUIPABBLE),\n        \"reinforces\": ParamDictRetriever(\"ReinforceParamWeapon\", ItemIDFlag.NON_EQUIPABBLE),\n    }\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"WeaponName\"),\n        \"descriptions\": MsgsRetriever(\"WeaponCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        effects = data.params[\"effects\"]\n        reinforces = data.params[\"reinforces\"]\n\n        upgrade_costs = _get_upgrade_costs(row, reinforces)\n        upgrade_material = { # assuming nothing upgrades to +10 with regular stones\n            0: ArmamentUpgradeMaterial.NONE,\n            10: ArmamentUpgradeMaterial.SOMBER_SMITHING_STONE,\n            25: ArmamentUpgradeMaterial.SMITHING_STONE,\n        }[len(upgrade_costs)]\n\n        weapon_effects = parse_weapon_effects(row) \\\n            + parse_effects(row, effects, *_RESIDENT_EFFECTS_FIELDS) \\\n            + parse_effects(row, effects, *_BEHAVIOR_EFFECTS_FIELDS, add_condition=AttackCondition.ON_HIT)\n\n        allow_ash_of_war = AshOfWarMountType(row[\"gemMountType\"]) == AshOfWarMountType.ALLOW_CHANGE\n\n        return Armament(\n            **cls.make_item(data, row, summary=False),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            behavior_variation_id=row[\"behaviorVariationId\"].as_int,\n            category=ArmamentCategory.from_row(row),\n            weight=row[\"weight\"].as_float,\n            default_skill_id=row[\"swordArtsParamId\"].as_int,\n            allow_ash_of_war=allow_ash_of_war,\n            is_buffable=row[\"isEnhance\"].as_bool,\n            is_l1_guard=row[\"enableGuard\"].as_bool,\n            upgrade_material=upgrade_material,\n            upgrade_costs=upgrade_costs,\n            attack_attributes=_get_attack_attributes(row),\n            sp_consumption_rate=row[\"staminaConsumptionRate\"].as_float,\n            requirements=_get_requirements(row),\n            effects=[Effect(**eff) for eff in weapon_effects],\n            affinity=_get_affinities(row, data.main_param, effects, reinforces, allow_ash_of_war)\n        )"}
{"type": "source_file", "path": "src/erdb/app_wiki/__init__.py", "content": "import re\nimport json\nimport shutil\nfrom typing import Iterable, NamedTuple\nimport requests\nfrom io import BytesIO, TextIOWrapper\nfrom pathlib import Path\nfrom zipfile import ZipFile\nfrom jinja2 import Environment, Template, FileSystemLoader\nfrom htmlmin import minify as minifyhtml\n\nimport erdb.utils.attack_power as attack_power_module\nfrom erdb.loaders import PKG_DATA_PATH\nfrom erdb.utils.common import scaling_grade, to_somber\nfrom erdb.table import Table\n\n\n_ITEMS = {\n    Table.ARMAMENTS: [\"reinforcements\"]\n}\n\nclass ThirdpartyLibrary(NamedTuple):\n    name: str\n    destination: Path\n    freeze_version: str\n    files: Iterable[str]\n\n    def _current_version(self) -> str | None:\n        assert False, \"not implemented\"\n\n    def _download(self, version: str):\n        assert False, \"not implemented\"\n\n    def ensure_version(self, desired: str | None):\n        current = self._current_version()\n\n        if current is None: # local not found\n            self._download(self.freeze_version if desired is None else desired)\n\n        elif desired is not None and desired != current:\n            print(f\"> Current {self.name} version ({current}) doesn't match desired ({desired}).\", flush=True)\n            self._download(desired)\n\nclass UIkit(ThirdpartyLibrary):\n    def _current_version(self) -> str | None:\n        versions: set[str] = set()\n\n        for loc in self.files:\n            if not (self.destination / loc).exists():\n                return None\n\n            with open(self.destination / loc, mode=\"r\") as f:\n                content = f.read(64) # version string is contained at the start\n\n                if version_lookup := re.search(r\"UIkit (\\d+\\.\\d+\\.\\d+)\", content):\n                    versions.add(version_lookup.group(1))\n\n                else:\n                    return None # a file's wrong\n\n        # every version must be the same\n        return next(iter(versions)) if len(versions) == 1 else None\n\n    def _download(self, version: str):\n        print(f\"> Downloading {self.name} {version}...\", flush=True)\n\n        shutil.rmtree(self.destination, ignore_errors=True)\n        self.destination.mkdir(parents=True, exist_ok=False)\n\n        resp = requests.get(f\"https://github.com/uikit/uikit/releases/download/v{version}/uikit-{version}.zip\")\n        z = ZipFile(BytesIO(resp.content))\n\n        for loc in self.files:\n            z.extract(loc, self.destination)\n\n        print(f\"> {self.name} {version} installed at {self.destination}.\", flush=True)\n\nclass PyScript(ThirdpartyLibrary):\n    def _current_version(self) -> str | None:\n        for loc in [*self.files, \"version.txt\"]:\n            if not (self.destination / loc).exists():\n                return None\n\n        with open(self.destination / \"version.txt\", mode=\"r\") as f:\n            version = f.read()\n\n        return version if len(version) > 0 else None\n\n    def _download(self, version: str):\n        print(f\"> Downloading {self.name} {version}...\", flush=True)\n\n        shutil.rmtree(self.destination, ignore_errors=True)\n        self.destination.mkdir(parents=True, exist_ok=False)\n\n        for loc in self.files:\n            with open(self.destination / loc, mode=\"wb\") as f:\n                resp = requests.get(f\"https://pyscript.net/releases/{version}/{loc}\")\n\n                if resp.status_code != 200:\n                    return\n\n                f.write(resp.content)\n\n        with open(self.destination / \"version.txt\", mode=\"w\") as f:\n            f.write(version)\n\n        print(f\"> {self.name} {version} installed at {self.destination}.\", flush=True)\n\ndef _read_json(file: Path):\n    with open(file, mode=\"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n\ndef _write_html(template: Template, root: Path, file: Path, minimize: bool, **data):\n    def relative_root():\n        depth = len(file.parent.relative_to(root).parts)\n        return \"../\" * depth\n\n    def write(f: TextIOWrapper, data: str):\n        f.write(minifyhtml(data, remove_all_empty_space=True, remove_comments=True) if minimize else data)\n\n    with open(file, mode=\"w\", encoding=\"utf-8\") as f:\n        write(f, template.render(site_root=relative_root(), **data))\n\ndef _generate_items(env: Environment, data_path: Path, minimize: bool, out: Path):\n    items_path = out / \"items\"\n\n    for table, dependencies in _ITEMS.items():\n        print(f\">>> Generating {table} wiki pages\", flush=True)\n\n        item_path = items_path / table\n        item_path.mkdir(parents=True, exist_ok=True)\n\n        with open(data_path / f\"{table}.json\", mode=\"r\", encoding=\"utf-8\") as f:\n            main_data = json.load(f)\n\n        data = {}\n\n        for dep in dependencies:\n            print(f\"Reading dependent table {dep}\", flush=True)\n            with open(data_path / f\"{dep}.json\", mode=\"r\", encoding=\"utf-8\") as f:\n                data[dep] = json.load(f)\n\n        cur, count = 0, len(main_data)\n\n        for key, item in main_data.items():\n            print(f\"[{(cur := cur + 1)}/{count}] {key}\", flush=True)\n\n            data[\"item\"] = item\n\n            single = env.get_template(f\"{table}-single.html.jinja\")\n            _write_html(single, out, item_path / f\"{key}.html\", minimize, **data)\n\n        print(f\"Generating index page\", flush=True)\n\n        index = env.get_template(f\"{table}-index.html.jinja\")\n        _write_html(index, out, item_path / \"index.html\", minimize, items=main_data)\n\n        print(flush=True)\n\ndef _generate_tools(env: Environment, data_path: Path, out: Path):\n    tools_path = out / \"tools\"\n    tools_path.mkdir(parents=True, exist_ok=True)\n\n    print(\">>> Generating AR calculator\", flush=True)\n\n    data = {\n        \"armaments\": _read_json(data_path / \"armaments.json\"),\n        \"correction_attack\": _read_json(data_path / \"correction-attack.json\"),\n        \"correction_graph\": _read_json(data_path / \"correction-graph.json\"),\n        \"reinforcements\": _read_json(data_path / \"reinforcements.json\"),\n    }\n\n    shutil.copy(attack_power_module.__file__, out / \"scripts\")\n\n    ar_calculator = env.get_template(\"ar-calculator.html.jinja\")\n    _write_html(ar_calculator, out, tools_path / \"ar-calculator.html\", minimize=False, **data)\n\ndef generate(uikit_version: str | None, pyscript_version: str | None, data_path: Path, minimize: bool, out: Path):\n    thirdparty = out / \"thirdparty\"\n    thirdparty.mkdir(parents=True, exist_ok=True)\n\n    UIkit(\n        \"UIkit\", thirdparty / \"uikit\",\n        freeze_version=\"3.15.18\",\n        files=(\"css/uikit.min.css\", \"js/uikit.min.js\", \"js/uikit-icons.min.js\")\n    ).ensure_version(uikit_version)\n\n    PyScript(\n        \"pyscript\", thirdparty / \"pyscript\",\n        freeze_version=\"2022.12.1\",\n        files=(\"pyscript.css\", \"pyscript.js\")\n    ).ensure_version(pyscript_version)\n\n    env = Environment(loader=FileSystemLoader(PKG_DATA_PATH / \"wiki\" / \"templates\"))\n    env.filters[\"scaling_grade\"] = scaling_grade\n    env.filters[\"to_somber\"] = to_somber\n    env.trim_blocks = True\n    env.lstrip_blocks = True\n\n    print(f\">>> Copying scripts\", flush=True)\n    shutil.copytree(PKG_DATA_PATH / \"wiki\" / \"scripts\", out / \"scripts\", dirs_exist_ok=True)\n\n    _generate_items(env, data_path, minimize, out)\n    _generate_tools(env, data_path, out)"}
{"type": "source_file", "path": "src/erdb/app_api/common.py", "content": "import pickle\nfrom tempfile import TemporaryDirectory\nfrom contextlib import contextmanager\nfrom pathlib import Path\nfrom functools import cache, lru_cache\nfrom enum import Enum\nfrom typing import IO, Any, Generator, NamedTuple, Self\n\nfrom erdb.table import Table\nfrom erdb.loaders import GAME_VERSIONS\nfrom erdb.typing.game_version import GameVersion\nfrom erdb.typing.api_version import ApiVersion\n\n\nGameVersionEnum = Enum(\"GameVersionEnum\", {\"latest\": \"latest\"} | {str(v).replace(\".\", \"_\"): str(v) for v in GAME_VERSIONS})\nLATEST_VERSION = list(GameVersionEnum)[1]\n\nclass DataProxy(NamedTuple):\n    cache_dir: Path\n\n    def precache(self):\n        for game_version in GameVersionEnum:\n            print(f\">>> Precaching version {game_version.value}:\", flush=True)\n\n            for tb in Table.effective():\n                for api in tb.spec.model.keys():\n                    print(f\"> {tb.title} [v{api}]\", flush=True)\n                    self.generate(api, game_version, tb)\n\n            print(flush=True)\n\n    def generate(self, api: ApiVersion, game_version: GameVersionEnum, table: Table) -> dict: # type: ignore\n        return \\\n            self._generate_latest(api, table) if game_version == GameVersionEnum.latest else \\\n            self._generate_specific(api, game_version, table)\n\n    @cache # always in memory\n    def _generate_latest(self, api: ApiVersion, table: Table) -> dict:\n        return self._generate_specific(api, LATEST_VERSION, table)\n\n    @lru_cache(maxsize=8) # up to 8 tables, single item access caches an entire table\n    def _generate_specific(self, api: ApiVersion, game_version: GameVersionEnum, table: Table) -> dict: # type: ignore\n        try:\n            with self._open_cache(api, game_version, table, mode=\"rb\") as f:\n                return pickle.load(f)\n\n        except FileNotFoundError:\n            ver = GameVersion.from_string(game_version.value)\n            data = table.make_generator(ver).generate(api)\n\n            with self._open_cache(api, game_version, table, mode=\"wb\") as f:\n                pickle.dump(data, f)\n\n            return data\n\n    def _open_cache(self, api: ApiVersion, game_version: GameVersionEnum, table: Table, mode: str) -> IO[Any]: # type: ignore\n        return open(self.cache_dir / f\"{api}-{game_version.value}-{table}.bin\", mode=mode)\n\n    @classmethod\n    @contextmanager\n    def in_temp_dir(cls, **kwargs) -> Generator[Self, None, None]:\n        with TemporaryDirectory(**kwargs) as temp_dir:\n            yield cls(Path(temp_dir))"}
{"type": "source_file", "path": "src/erdb/table/_common.py", "content": "from typing import Any, Callable, Protocol\nfrom unicodedata import normalize, combining\n\nfrom erdb.utils.common import get_filename\nfrom erdb.typing.enums import GoodsRarity\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, ShopRetriever, ContribRetriever, RetrieverData\n\n\nRowPredicate = Callable[[ParamRow], bool]\n\ndef _remove_accents(string: str) -> str:\n    nfkd_form = normalize(\"NFKD\", string)\n    return \"\".join(c for c in nfkd_form if not combining(c))\n\nclass TableSpec(Protocol):\n    model: dict[ApiVersion, Any]\n\n    predicates: list[RowPredicate]\n\n    main_param_retriever: ParamDictRetriever\n    param_retrievers: dict[str, ParamDictRetriever]\n    msg_retrievers: dict[str, MsgsRetriever]\n    shop_retrievers: dict[str, ShopRetriever]\n    contrib_retriever: ContribRetriever\n\n    @classmethod\n    def title(cls) -> str:\n        ...\n\n    @classmethod\n    def has_icons(cls) -> bool:\n        ...\n\n    @classmethod\n    def latest_api(cls) -> ApiVersion:\n        ...\n\n    @classmethod\n    def get_pk(cls, data: RetrieverData, row: ParamRow) -> str:\n        ...\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow) -> Any:\n        ...\n\nclass TableSpecContext:\n    # specify defaults so providing everything isn't always necessary\n    predicates: list[RowPredicate] = []\n    param_retrievers: dict[str, ParamDictRetriever] = {}\n    msg_retrievers: dict[str, MsgsRetriever] = {}\n    shop_retrievers: dict[str, ShopRetriever] = {}\n    contrib_retriever: ContribRetriever = ContribRetriever()\n\n    @classmethod # override\n    def title(cls) -> str:\n        return cls.__name__.removesuffix(\"TableSpec\")\n\n    @classmethod\n    def has_icons(cls: TableSpec) -> bool:\n        for model in cls.model.values():\n            return hasattr(model, \"icon\")\n        assert False, \"TableSpec model dict really should not be empty...\"\n\n    @classmethod # override\n    def latest_api(cls: TableSpec) -> ApiVersion:\n        return list(cls.model.keys())[-1]\n\n    @classmethod # override\n    def get_pk(cls, data: RetrieverData, row: ParamRow) -> str:\n        assert \"names\" in data.msgs, \"names were not parsed, override get_pk() for non-standard pk\"\n        return _remove_accents(cls.parse_name(data.msgs[\"names\"][row.index]))\n\n    @classmethod\n    def parse_name(cls, name: str) -> str:\n        return name.removeprefix(\"[ERROR]\").strip()\n\n    @classmethod\n    def make_item(cls, data: RetrieverData, row: ParamRow, *, summary: bool = True, description: bool = True) -> dict[str, Any]:\n        assert \"names\" in data.msgs, \"make_item() cannot be called without names parsed\"\n        assert not summary or \"summaries\" in data.msgs, \"Summary specified, yet no summaries were parsed\"\n        assert not description or \"descriptions\" in data.msgs, \"Description specified, yet no descriptions were parsed\"\n\n        # individual items might not have summaries or descriptions\n        summary = summary and row.index in data.msgs[\"summaries\"]\n        description = description and row.index in data.msgs[\"descriptions\"]\n\n        return {\n            \"full_hex_id\": row.index_hex,\n            \"id\": row.index,\n            \"name\": cls.parse_name(data.msgs[\"names\"][row.index]),\n            \"summary\": data.msgs[\"summaries\"][row.index] if summary else \"no summary\",\n            \"description\": data.msgs[\"descriptions\"][row.index].split(\"\\n\") if description else [\"no description\"],\n            \"is_tradable\": not row[\"disableMultiDropShare\"].as_bool, # assumption this exists for every param table\n            \"price_sold\": row[\"sellValue\"].get_int(0),               # assumption this exists for every param table\n            \"rarity\": GoodsRarity.from_id(row[\"rarity\"].as_int),     # assumption this exists for every param table\n            \"icon\": row[\"iconId\"].as_int if \"iconId\" in row else row[\"iconIdM\"].as_int,\n            \"max_held\": row[\"maxNum\"].as_int if \"maxNum\" in row else 999,\n            \"max_stored\": row[\"maxRepositoryNum\"].as_int if \"maxRepositoryNum\" in row else 999,\n        }\n\n    @classmethod\n    def make_contrib(cls, data: RetrieverData, row: ParamRow, *fields: str) -> dict[str, Any]:\n        row_name = cls.get_pk(data, row)\n\n        def get_user_value(field: str):\n            return data.contrib.get(get_filename(row_name), {}).get(field)\n\n        user_data = {field: get_user_value(field) for field in fields}\n        user_data = {k: v for k, v in user_data.items() if v is not None}\n\n        return user_data"}
{"type": "source_file", "path": "src/erdb/data/wiki/scripts/ar_calculator.py", "content": "from copy import copy\nfrom functools import partial\nfrom math import floor\nfrom typing import Any, Generator, Iterable, NamedTuple, Optional\nfrom js import document, armaments_raw, reinforcements_raw, correction_attack_raw, correction_graph_raw # type: ignore\nfrom pyodide.ffi import JsProxy # type: ignore\nfrom pyodide.ffi.wrappers import add_event_listener # type: ignore\nfrom attack_power import CalculatorData, ArmamentCalculator, Attributes # type: ignore\n\n# define things inherent to py-script runtime\npyscript = pyscript # type: ignore\n\n# instantiating lots of data in JavaScript then porting seems more stable\narmaments = armaments_raw.to_py()\nreinforcements = reinforcements_raw.to_py()\ncorrection_attack = correction_attack_raw.to_py()\ncorrection_graph = correction_graph_raw.to_py()\n\ncalculator_data = CalculatorData(armaments, reinforcements, correction_attack, correction_graph)\n\ndef debounce(delay: float):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            if hasattr(wrapper, \"_handle\"):\n                wrapper._handle.cancel()\n\n            to_call = partial(func, *args, **kwargs)\n            wrapper._handle = pyscript.loop.call_later(delay, to_call)\n        return wrapper\n    return decorator\n\ndef wrap_list(start_tag: str, values: Iterable[str], end_tag: str) -> str:\n    return start_tag + f\"{end_tag}{start_tag}\".join(values) + end_tag\n\nclass ElementWrapper:\n    class _Attributes(NamedTuple):\n        parent: \"ElementWrapper\"\n\n        def __getitem__(self, attrib: str) -> str | None:\n            return self.parent._element.getAttribute(attrib)\n\n        def __setitem__(self, attrib: str, value: Any):\n            self.parent._element.setAttribute(attrib, value)\n\n        def __contains__(self, item: object) -> bool:\n            assert isinstance(item, str)\n            return self.parent._element.getAttribute(item) is not None\n\n    class _ClassList(NamedTuple):\n        parent: \"ElementWrapper\"\n\n        def add(self, classname: str):\n            self.parent._element.classList.add(classname)\n\n        def remove(self, classname: str):\n            self.parent._element.classList.remove(classname)\n\n        def __contains__(self, item: object) -> bool:\n            assert isinstance(item, str)\n            return item in self.parent._element.classList\n\n    class _ChildList(NamedTuple):\n        parent: \"ElementWrapper\"\n\n        def add(self, element: \"ElementWrapper\"):\n            self.parent._element.appendChild(element._element)\n\n        def remove(self, element: \"ElementWrapper\"):\n            self.parent._element.removeChild(element._element)\n\n        def __len__(self) -> int:\n            return self.parent._element.childElementCount\n\n    _element: JsProxy\n    _attributes: _Attributes\n    _class_list: _ClassList\n    _child_list: _ChildList\n\n    def __init__(self, value: str | Any) -> None:\n        if isinstance(value, str):\n            self._element = document.getElementById(value)\n        elif isinstance(value, JsProxy):\n            self._element = value\n        else:\n            assert \"Invalid `value` type for ElementWrapper\"\n\n        self._attributes = self._Attributes(self)\n        self._class_list = self._ClassList(self)\n        self._child_list = self._ChildList(self)\n\n    @property\n    def attributes(self) -> \"ElementWrapper._Attributes\":\n        return self._attributes\n\n    @property\n    def class_list(self) -> \"ElementWrapper._ClassList\":\n        return self._class_list\n\n    @property\n    def child_list(self) -> \"ElementWrapper._ChildList\":\n        return self._child_list\n\n    @property\n    def value(self) -> str:\n        return self._element.value\n\n    @value.setter\n    def value(self, value: Any):\n        self._element.value = value\n\n    @property\n    def inner_text(self) -> str:\n        return self._element.innerText\n\n    @inner_text.setter\n    def inner_text(self, value: str):\n        self._element.innerText = value\n\n    @property\n    def inner_html(self) -> str:\n        return self._element.innerHTML\n\n    @inner_html.setter\n    def inner_html(self, value: str):\n        self._element.innerHTML = value\n\n    @property\n    def src(self) -> str:\n        return self._element.src\n\n    @src.setter\n    def src(self, value: str):\n        self._element.src = value\n\n    @property\n    def is_enabled(self) -> bool:\n        return not self._element.disabled\n\n    @is_enabled.setter\n    def is_enabled(self, value: bool):\n        self._element.disabled = not value\n\n    @property\n    def is_visible(self) -> bool:\n        return not self._element.hidden\n\n    @is_visible.setter\n    def is_visible(self, value: bool):\n        self._element.hidden = not value\n\n    @property\n    def is_checked(self) -> bool:\n        return self._element.checked\n\n    def clone(self) -> \"ElementWrapper\":\n        return ElementWrapper(self._element.cloneNode(True, deep=True))\n\n    def click(self):\n        self._element.click()\n\n    def add_listener(self, event: str, callback, **kwargs):\n        # pyodide wrappers introduce some irrelevant args\n        call = lambda *args: callback(element=self, **kwargs)\n        add_event_listener(self._element, event, call)\n\n    # TODO: use `Self | None` when 3.11 is available\n    def find_id(self, index: str, from_content: bool = False) -> Optional[\"ElementWrapper\"]:\n        origin = self._element.content if from_content else self._element\n        if element := origin.querySelector(f\"#{index}\"):\n            return ElementWrapper(element)\n\n        return None\n\n    def find_tag(self, tag: str) -> Generator[\"ElementWrapper\", None, None]:\n        return (ElementWrapper(e) for e in self._element.getElementsByTagName(tag))\n\nclass Settings(NamedTuple):\n    class AttackTypeTweaks(NamedTuple):\n        physical: int\n        magic: int\n        fire: int\n        lightning: int\n        holy: int\n\n    attack_type_tweaks: AttackTypeTweaks\n\n    @classmethod\n    def attack_types(cls) -> list[str]:\n        return list(cls.AttackTypeTweaks._fields)\n\nclass SettingsMenu:\n    _callback = None\n\n    _settings: Settings\n    _override: Settings\n\n    _ranges = {t: ElementWrapper(f\"settings-tweak-value-{t}\") for t in Settings.attack_types()}\n    _lock_icons = {t: ElementWrapper(f\"settings-tweak-lock-icon-{t}\") for t in Settings.attack_types()}\n    _lock_buttons = {t: ElementWrapper(f\"settings-tweak-lock-{t}\") for t in Settings.attack_types()}\n    _views = {t: ElementWrapper(f\"settings-tweak-view-{t}\") for t in Settings.attack_types()}\n\n    _tweak_badge = ElementWrapper(\"settings-tweak-badge\")\n    _open_button = ElementWrapper(\"open-settings-menu\")\n\n    _locked_types: set[str] = set(Settings.attack_types()[1:]) # elemental only\n\n    def __init__(self) -> None:\n        for t in Settings.attack_types():\n            self._ranges[t].add_listener(\"input\", self._on_damage_tweak, attack_type=t)\n            self._ranges[t].add_listener(\"change\", self._on_damage_change)\n            self._views[t].inner_text = f\"{self._ranges[t].value}%\"\n            self._lock_buttons[t].add_listener(\"click\", self._on_damage_lock, attack_type=t)\n\n            ElementWrapper(f\"settings-tweak-reset-{t}\").add_listener(\"click\", self._on_damage_reset, attack_type=t)\n\n        self._settings = Settings(self._get_current_tweaks())\n        self._override = copy(self._settings)\n\n        ElementWrapper(\"save-settings\").add_listener(\"click\", self._on_save)\n        ElementWrapper(\"cancel-settings\").add_listener(\"click\", self._on_cancel)\n\n        self._update_tweak_badge_notifs()\n\n    def register_callback(self, callback) -> Settings:\n        assert self._callback is None\n        self._callback = callback\n\n        return self._settings\n\n    def _on_save(self, element: ElementWrapper):\n        if self._override == self._settings:\n            return\n\n        self._settings = self._override\n        self._callback(self._settings) # type: ignore (optimization to not assert)\n\n    def _on_cancel(self, element: ElementWrapper):\n        self._override = copy(self._settings)\n\n        for t in Settings.attack_types():\n            value = getattr(self._settings.attack_type_tweaks, t)\n            self._ranges[t].value = value\n            self._views[t].inner_text = f\"{value}%\"\n\n    def _on_damage_tweak(self, element: ElementWrapper, attack_type: str):\n        self._views[attack_type].inner_text = f\"{element.value}%\"\n\n        if attack_type in self._locked_types:\n            for other in self._locked_types.difference({attack_type}):\n                self._ranges[other].value = element.value\n                self._views[other].inner_text = f\"{element.value}%\"\n\n        self._update_tweak_badge_notifs()\n\n    def _on_damage_lock(self, element: ElementWrapper, attack_type: str):\n        if self._is_locked(attack_type):\n            element.class_list.remove(\"uk-button-primary\")\n            self._locked_types.remove(attack_type)\n            self._lock_icons[attack_type].attributes[\"uk-icon\"] = \"unlock\"\n        else:\n            element.class_list.add(\"uk-button-primary\")\n            self._locked_types.add(attack_type)\n            self._lock_icons[attack_type].attributes[\"uk-icon\"] = \"lock\"\n\n    def _on_damage_reset(self, element: ElementWrapper, attack_type: str):\n        self._views[attack_type].inner_text = \"100%\"\n        self._ranges[attack_type].value = 100\n        self._update_tweak_badge_notifs()\n        self._override = Settings(self._get_current_tweaks())\n\n    def _on_damage_change(self, element: ElementWrapper):\n        self._override = Settings(self._get_current_tweaks())\n\n    def _get_current_tweaks(self) -> Settings.AttackTypeTweaks:\n        return Settings.AttackTypeTweaks(*(int(r.value) for r in self._ranges.values()))\n\n    def _is_locked(self, attack_type: str) -> bool:\n        return self._lock_icons[attack_type].attributes[\"uk-icon\"] == \"lock\"\n\n    def _update_tweak_badge_notifs(self):\n        count = sum(1 for r in self._ranges.values() if r.value != \"100\")\n\n        if count > 0:\n            self._tweak_badge.is_visible = True\n            self._tweak_badge.attributes[\"uk-tooltip\"] = f\"{count} tweak(s) affect AR calculation\"\n            self._tweak_badge.inner_text = str(count)\n            self._open_button.class_list.add(\"uk-button-primary\")\n        else:\n            self._tweak_badge.is_visible = False\n            self._open_button.class_list.remove(\"uk-button-primary\")\n\nclass AttributeMenu:\n    _callback = None\n    _attribs: list[ElementWrapper] = [\n        ElementWrapper(\"player-attributes-strength\"),\n        ElementWrapper(\"player-attributes-dexterity\"),\n        ElementWrapper(\"player-attributes-intelligence\"),\n        ElementWrapper(\"player-attributes-faith\"),\n        ElementWrapper(\"player-attributes-arcane\"),\n    ]\n    _str_multiplier: float = 1.\n\n    def register_callback(self, callback) -> Attributes:\n        assert self._callback is None\n        self._callback = callback\n\n        for e in self._attribs:\n            e.add_listener(\"input\", self._on_change)\n\n        two_handed = ElementWrapper(\"player-two-handed-checkbox\")\n        two_handed.add_listener(\"change\", self._on_two_handed)\n        self._str_multiplier = 1.5 if two_handed.is_checked else 1.\n\n        return self._create_attribs()\n\n    def _create_attribs(self):\n        values = [*(int(elem.value) for elem in self._attribs)]\n        values[0] = floor(values[0] * self._str_multiplier)\n        return Attributes(*values)\n\n    def _on_change(self, element: ElementWrapper):\n        try:\n            value = max(1, min(99, int(element.value)))\n\n        except ValueError:\n            return\n\n        element.value = value\n        self._callback(self._create_attribs()) # type: ignore (optimization to not assert)\n\n    def _on_two_handed(self, element: ElementWrapper):\n        self._str_multiplier = 1.5 if element.is_checked else 1.\n        self._callback(self._create_attribs()) # type: ignore (optimization to not assert)\n\nclass ArmamentEntry(NamedTuple):\n    key: str\n    wrapped: ElementWrapper\n\n    # NamedTuple properties cannot start with _, but wanna keep using them because\n    # tuples are implemented in C and are faster. This is based on no profiling whatsoever.\n    priv_title: ElementWrapper\n    priv_icon: ElementWrapper\n    priv_affinities: ElementWrapper\n    priv_levels: ElementWrapper\n    priv_remove: ElementWrapper\n    priv_requirement: dict[str, ElementWrapper]\n    priv_scaling: dict[str, ElementWrapper]\n    priv_attack_power: dict[str, ElementWrapper]\n    priv_status_effect: dict[str, ElementWrapper]\n    priv_guard: dict[str, ElementWrapper]\n    priv_resistance: dict[str, ElementWrapper]\n\n    @staticmethod\n    def _normalize(value: int) -> str:\n        return \"-\" if value == 0 else str(value)\n\n    def set_title(self, name: str, icon_id: int):\n        self.priv_title.inner_text = name\n        self.priv_icon.src = f\"https://assets.erdb.workers.dev/icons/armaments/{icon_id}/menu\"\n\n    def set_affinities(self, affinities: list[str]):\n        self.priv_affinities.inner_html = wrap_list(\"<option>\", affinities, \"</option>\")\n        self.priv_affinities.is_enabled = len(affinities) > 1\n\n    def set_levels(self, levels: list[str]):\n        self.priv_levels.inner_html = wrap_list(\"<option>\", levels, \"</option>\")\n\n    def set_attack_power(self, attack_type: str, value: int):\n        self.priv_attack_power[attack_type].inner_text = self._normalize(value)\n\n    def set_guard(self, guard_type: str, value: int):\n        self.priv_guard[guard_type].inner_text = self._normalize(value)\n\n    def set_status_effect(self, effect_type: str, value: int):\n        self.priv_status_effect[effect_type].inner_text = self._normalize(value)\n\n    def set_resistance(self, resistance_type: str, value: int):\n        self.priv_resistance[resistance_type].inner_text = self._normalize(value)\n\n    def set_scaling(self, attribute: str, value: float):\n        def grade() -> str:\n            if value >= 1.75: return \"S\"\n            if value >= 1.4: return \"A\"\n            if value >= 0.9: return \"B\"\n            if value >= 0.6: return \"C\"\n            if value >= 0.25: return \"D\"\n            if value > 0.0: return \"E\"\n            return \"-\"\n\n        self.priv_scaling[attribute].inner_text = grade()\n        self.priv_scaling[attribute].attributes[\"uk-tooltip\"] = round(value, 2)\n\n    def set_requirement(self, attribute: str, armament_value: int, player_value: int):\n        is_met = player_value >= armament_value\n\n        getattr(self.priv_requirement[attribute].class_list, \"remove\" if is_met else \"add\")(\"uk-text-danger\")\n        self.priv_requirement[attribute].inner_text = self._normalize(armament_value)\n\n    def add_remove_listener(self, callback):\n        self.priv_remove.add_listener(\"click\", callback, armentry=self)\n\n    def add_affinities_listener(self, callback):\n        self.priv_affinities.add_listener(\"change\", callback, armentry=self)\n\n    def add_levels_listener(self, callback):\n        self.priv_levels.add_listener(\"change\", callback, armentry=self)\n\n    @property\n    def total_attack_power(self) -> int:\n        return int(self.priv_attack_power[\"total\"].inner_text)\n\n    @property\n    def guard_boost(self) -> int:\n        return int(self.priv_guard[\"boost\"].inner_text)\n\n    @property\n    def level(self) -> int:\n        return int(self.priv_levels.value[1:]) # drop initial \"+\"\n\n    @level.setter\n    def level(self, value: int):\n        self.priv_levels.value = f\"+{value}\"\n\n    @property\n    def affinity_count(self) -> int:\n        return len(self.priv_affinities.child_list)\n\n    @property\n    def affinity(self) -> str:\n        selection = self.priv_affinities.value\n        return {\n            \"Somber\": \"Standard\" # treat as \"Standard\" externally\n        }.get(selection, selection)\n\n    @affinity.setter\n    def affinity(self, value: str):\n        if len(self.priv_affinities.child_list) > 1:\n            self.priv_affinities.value = value\n\n    @classmethod\n    def create(cls, key: str, element: ElementWrapper):\n        def get(template_id_part: str):\n            if e := element.find_id(f\"armament-display-{template_id_part}\"):\n                return e\n            assert False, f\"\\\"{template_id_part}\\\" invalid\"\n\n        return cls(key, element,\n            priv_title=get(\"title\"),\n            priv_icon=get(\"icon\"),\n            priv_affinities=get(\"affinities\"),\n            priv_levels=get(\"levels\"),\n            priv_remove=get(\"remove\"),\n            priv_requirement={\n                \"strength\": get(\"requirement-strength\"),\n                \"dexterity\": get(\"requirement-dexterity\"),\n                \"intelligence\": get(\"requirement-intelligence\"),\n                \"faith\": get(\"requirement-faith\"),\n                \"arcane\": get(\"requirement-arcane\"),\n            },\n            priv_scaling={\n                \"strength\": get(\"scaling-strength\"),\n                \"dexterity\": get(\"scaling-dexterity\"),\n                \"intelligence\": get(\"scaling-intelligence\"),\n                \"faith\": get(\"scaling-faith\"),\n                \"arcane\": get(\"scaling-arcane\"),\n            },\n            priv_attack_power={\n                \"total\": get(\"attack-power-total\"),\n                \"physical\": get(\"attack-power-physical\"),\n                \"magic\": get(\"attack-power-magic\"),\n                \"fire\": get(\"attack-power-fire\"),\n                \"lightning\": get(\"attack-power-lightning\"),\n                \"holy\": get(\"attack-power-holy\"),\n            },\n            priv_status_effect={\n                \"bleed\": get(\"status-effect-bleed\"),\n                \"frostbite\": get(\"status-effect-frostbite\"),\n                \"poison\": get(\"status-effect-poison\"),\n                \"scarlet_rot\": get(\"status-effect-scarlet_rot\"),\n                \"sleep\": get(\"status-effect-sleep\"),\n                \"madness\": get(\"status-effect-madness\"),\n            },\n            priv_guard={\n                \"boost\": get(\"guard-boost\"),\n                \"physical\": get(\"guard-physical\"),\n                \"magic\": get(\"guard-magic\"),\n                \"fire\": get(\"guard-fire\"),\n                \"lightning\": get(\"guard-lightning\"),\n                \"holy\": get(\"guard-holy\"),\n            },\n            priv_resistance={\n                \"bleed\": get(\"resistance-bleed\"),\n                \"frostbite\": get(\"resistance-frostbite\"),\n                \"poison\": get(\"resistance-poison\"),\n                \"scarlet_rot\": get(\"resistance-scarlet_rot\"),\n                \"sleep\": get(\"resistance-sleep\"),\n                \"madness\": get(\"resistance-madness\"),\n            },\n        )\n\nclass ArmamentEntryFactory(NamedTuple):\n    template = ElementWrapper(\"armament-display-template\").find_id(\"armament-display-element\", from_content=True)\n\n    def create(self, key: str, on_remove) -> ArmamentEntry:\n        assert self.template, \"Template not found\"\n\n        armament = armaments[key]\n        et = ArmamentEntry.create(key, self.template.clone())\n        et.set_title(armament[\"name\"], armament[\"icon\"])\n\n        if len(armament[\"affinity\"]) > 1:\n            sorted_affinities = [k for k, _ in sorted(armament[\"affinity\"].items(), key=lambda x: x[1][\"id\"])]\n            et.set_affinities(sorted_affinities)\n        else:\n            is_somber = armament[\"upgrade_material\"].startswith(\"Somber\")\n            et.set_affinities([\"Somber\"] if is_somber else [\"Standard\"])\n\n        levels = [f\"+{i}\" for i in range(0, len(armament[\"upgrade_costs\"]) + 1)]\n        et.set_levels(levels)\n\n        et.add_remove_listener(on_remove)\n\n        return et\n\nclass ArmamentContainer:\n    class _SelectedLevels:\n        _unupgradable: int = 0\n        _standard: int = 0\n        _somber: int = 0\n\n        def as_value(self) -> str:\n            return f\"{self._standard}/{self._somber}\"\n\n        def set_levels(self, value: str):\n            self._standard, self._somber = map(int, value.split(\"/\"))\n\n        def __getitem__(self, armentry: ArmamentEntry) -> int:\n            armament = armaments[armentry.key]\n            return {\n                \"None\": self._unupgradable,\n                \"Smithing Stone\": self._standard,\n                \"Somber Smithing Stone\": self._somber,\n            }[armament[\"upgrade_material\"]]\n\n    _container = ElementWrapper(\"armament-display-container\")\n    _sort_selector = ElementWrapper(\"armament-sorting-method\")\n    _level_selector = ElementWrapper(\"armament-level-select\")\n    _affinity_selector = ElementWrapper(\"armament-affinity-select\")\n    _settings: Settings | None = None\n    _attribs: Attributes | None = None\n    _levels = _SelectedLevels()\n    _affinity = \"Standard\"\n    _calcs: dict[str, ArmamentCalculator] = {}\n    _elems: dict[str, ArmamentEntry] = {}\n    _alteration = \"(*)\"\n\n    _sort_methods: dict[str, dict[str, Any]] = {\n        \"▼ Total AR\": {\"key\": lambda x: x.total_attack_power, \"reverse\": True},\n        \"▲ Total AR\": {\"key\": lambda x: x.total_attack_power, \"reverse\": False},\n        \"▼ Guard Boost\": {\"key\": lambda x: x.guard_boost, \"reverse\": True},\n        \"▲ Guard Boost\": {\"key\": lambda x: x.guard_boost, \"reverse\": False},\n        \"Name (a → z)\": {\"key\": lambda x: x.key, \"reverse\": False},\n        \"Name (z → a)\": {\"key\": lambda x: x.key, \"reverse\": True},\n    }\n\n    def __init__(self, settings_menu: SettingsMenu, attribute_menu: AttributeMenu) -> None:\n        self._settings = settings_menu.register_callback(self._on_settings)\n        self._attribs = attribute_menu.register_callback(self._on_attributes)\n\n        self._sort_selector.inner_html = wrap_list(\"<option>\", self._sort_methods.keys(), \"</option>\")\n        self._update_sorting(self._sort_selector)\n        self._sort_selector.add_listener(\"change\", self._update_sorting)\n\n        self._update_levels(self._level_selector)\n        self._level_selector.add_listener(\"change\", self._update_levels)\n\n        self._update_affinities(self._affinity_selector)\n        self._affinity_selector.add_listener(\"change\", self._update_affinities)\n\n    def _update_values(self, et: ArmamentEntry, calc: ArmamentCalculator, attribs: Attributes):\n        armament = armaments[et.key]\n        affinity = armament[\"affinity\"][calc.affinity]\n        reinforcement = reinforcements[str(affinity[\"reinforcement_id\"])][calc.level]\n\n        ap = calc.attack_power(attribs)\n\n        if self._settings:\n            ap = ap.regulate(self._settings.attack_type_tweaks._asdict())\n\n        et.set_attack_power(\"total\", ap.total)\n        et.set_guard(\"boost\", floor(affinity[\"guard\"].get(\"guard_boost\", 0.) * reinforcement[\"guard\"][\"guard_boost\"]))\n\n        for attack_type, value in ap.items():\n            et.set_attack_power(attack_type, value.total)\n            et.set_guard(attack_type, floor(affinity[\"guard\"].get(attack_type, 0.) * reinforcement[\"guard\"][attack_type]))\n\n        for effect_type, value in calc.status_effects(attribs).items():\n            et.set_status_effect(effect_type, value.total)\n            et.set_resistance(effect_type, floor(affinity[\"resistance\"].get(effect_type, 0.) * reinforcement[\"resistance\"][effect_type]))\n\n        for attribute in [\"strength\", \"dexterity\", \"intelligence\", \"faith\", \"arcane\"]:\n            et.set_scaling(attribute, affinity[\"scaling\"].get(attribute, 0.) * reinforcement[\"scaling\"][attribute])\n            et.set_requirement(attribute, armament[\"requirements\"].get(attribute, 0), getattr(attribs, attribute))\n\n        self._update_sorting(self._sort_selector)\n\n    def _on_settings(self, settings: Settings):\n        self._settings = settings\n\n        for et in self._elems.values():\n            self._update_values(et, self._calcs[et.key], self._attribs)\n\n    def _on_attributes(self, attribs: Attributes):\n        self._attribs = attribs\n\n        for et in self._elems.values():\n            self._update_values(et, self._calcs[et.key], self._attribs)\n\n    def _on_affinity(self, element: ElementWrapper, armentry: ArmamentEntry):\n        self._calcs[armentry.key].set_affinity(element.value, calculator_data)\n        self._update_values(armentry, self._calcs[armentry.key], self._attribs)\n\n        if self._affinity != armentry.affinity:\n            self._affinity_selector.value = f\"{self._affinity} {self._alteration}\"\n\n        self._update_affinity_selector()\n\n    def _on_level(self, element: ElementWrapper, armentry: ArmamentEntry):\n        self._calcs[armentry.key].set_level(armentry.level, calculator_data)\n        self._update_values(armentry, self._calcs[armentry.key], self._attribs)\n\n        if self._levels[armentry] != armentry.level:\n            self._level_selector.value = \"Mixed\"\n\n        elif self._level_selector.value == \"Mixed\":\n            if all(self._levels[e] == e.level for e in self._elems.values()):\n                self._level_selector.value = self._levels.as_value()\n\n    @debounce(delay=0.1)\n    def _update_sorting(self, element: ElementWrapper):\n        # Two nodes cannot exist in the same list at once, readding them\n        # in a specific order removes the original and effectively sorts\n        for e in sorted(self._elems.values(), **self._sort_methods[element.value]):\n            self._container.child_list.add(e.wrapped)\n\n    def _update_levels(self, element: ElementWrapper):\n        if element.value == \"Mixed\":\n            return\n\n        self._levels.set_levels(element.value)\n\n        for e in self._elems.values():\n            if (desired_level := self._levels[e]) != e.level:\n                e.level = desired_level\n                self._calcs[e.key].set_level(e.level, calculator_data)\n                self._update_values(e, self._calcs[e.key], self._attribs)\n\n    def _update_affinities(self, element: ElementWrapper):\n        if element.value.endswith(self._alteration):\n            return\n\n        self._affinity = element.value\n\n        for e in self._elems.values():\n            if self._affinity != e.affinity:\n                e.affinity = self._affinity\n                self._calcs[e.key].set_affinity(e.affinity, calculator_data)\n                self._update_values(e, self._calcs[e.key], self._attribs)\n\n    def _update_affinity_selector(self):\n        def find_first_variable_affinity():\n            for e in self._elems.values():\n                if e.affinity_count > 1:\n                    return e.affinity\n\n            return \"Standard\"\n\n        if not self._affinity_selector.value.endswith(self._alteration):\n            return\n\n        if len(self._elems) == 0:\n            self._affinity_selector.value = self._affinity\n            return\n\n        first = find_first_variable_affinity()\n\n        if all(first == e.affinity or e.affinity_count == 1 for e in self._elems.values()):\n            self._affinity = first\n            self._affinity_selector.value = first\n\n    def add(self, armentry: ArmamentEntry):\n        armentry.level = self._levels[armentry]\n        armentry.affinity = self._affinity\n\n        self._calcs[armentry.key] = ArmamentCalculator(calculator_data, armentry.key, armentry.affinity, armentry.level)\n        self._elems[armentry.key] = armentry\n\n        armentry.add_affinities_listener(self._on_affinity)\n        armentry.add_levels_listener(self._on_level)\n\n        self._update_values(armentry, self._calcs[armentry.key], self._attribs)\n        self._container.child_list.add(armentry.wrapped)\n\n        # debounce coming in clutch\n        self._update_sorting(self._sort_selector)\n\n    def remove(self, key: str):\n        self._container.child_list.remove(self._elems[key].wrapped)\n        del self._calcs[key]\n        del self._elems[key]\n\n        self._update_affinity_selector()\n\nclass ArmamentSelector:\n    class _Armament(NamedTuple):\n        wrapped: ElementWrapper\n        key: str\n        category: str\n        tags: str\n        active_class = \"uk-button-primary\"\n\n        @staticmethod\n        def has_key(element: ElementWrapper) -> bool:\n            return \"data-armament-key\" in element.attributes\n\n        @classmethod\n        def create(cls, element: ElementWrapper) -> \"ArmamentSelector._Armament\":\n            key = element.attributes[\"data-armament-key\"]\n            category = element.attributes[\"data-armament-category\"]\n            assert key and category, \"data-armament-key or data-armament-category missing from the element\"\n\n            return cls(element, key, category,\n                tags=f\"{key.lower()} {category.lower()}\"\n            )\n\n        @property\n        def is_selected(self) -> bool:\n            return self.active_class in self.wrapped.class_list\n\n        def select(self):\n            self.wrapped.class_list.add(self.active_class)\n\n        def deselect(self):\n            self.wrapped.class_list.remove(self.active_class)\n\n    _factory: ArmamentEntryFactory\n    _container: ArmamentContainer\n\n    _filter_field: ElementWrapper\n    _choices: list[_Armament]\n    _categories: dict[str, ElementWrapper]\n    _category_buttons: list[ElementWrapper]\n\n    _selection: set[str] = set()\n    _temporary: set[str] = set()\n\n    _open_button = ElementWrapper(\"open-armament-selection\")\n    _save_button = ElementWrapper(\"save-armament-selection\")\n\n    _is_open = False\n\n    def __init__(self, factory: ArmamentEntryFactory, container: ArmamentContainer) -> None:\n        category_names = {a[\"category\"] for a in armaments.values()}\n        as_key = lambda v: v.lower().replace(\"'\", \"\").replace(\".\", \"\").replace(\" \", \"-\") \n\n        self._category_buttons = [ElementWrapper(f\"selection-category-{as_key(cat)}\") for cat in category_names]\n\n        for e in self._category_buttons:\n            e.add_listener(\"click\", self.on_category)\n\n        for e in (ElementWrapper(f\"selection-armament-{as_key(arm)}\") for arm in armaments):\n            e.add_listener(\"click\", self.on_armament)\n\n        ElementWrapper(\"toggle-armament-selection\").add_listener(\"click\", self.on_all_armaments)\n        ElementWrapper(\"open-armament-selection\").add_listener(\"click\", self.on_open)\n        ElementWrapper(\"save-armament-selection\").add_listener(\"click\", self.on_save)\n        ElementWrapper(\"close-armament-selection\").add_listener(\"click\", self.on_close)\n\n        self._filter_field = ElementWrapper(\"filter-armament-selection\")\n        self._filter_field.add_listener(\"input\", self._on_filter)\n\n        self._factory = factory\n        self._container = container\n\n        grid = ElementWrapper(\"armament-selection-grid\")\n        self._choices = [self._Armament.create(a) for a in [*grid.find_tag(\"a\")] if self._Armament.has_key(a)]\n        self._categories = {cat: ElementWrapper(f\"armament-selection-category-{as_key(cat)}\") for cat in category_names}\n\n    @debounce(0.25)\n    def _on_filter(self, element: ElementWrapper):\n        visible_categories = set()\n        is_empty = len(element.value) == 0\n\n        for choice in self._choices:\n            if element.value.lower() in choice.tags:\n                choice.wrapped.is_visible = True\n                visible_categories.add(choice.category)\n            else:\n                choice.wrapped.is_visible = False\n\n        for cat, e in self._categories.items():\n            e.is_visible = cat in visible_categories\n\n        for button in self._category_buttons:\n            button.is_visible = is_empty\n\n    def _on_remove(self, element: ElementWrapper, armentry: ArmamentEntry):\n        self._container.remove(armentry.key)\n        self._selection.remove(armentry.key)\n        self._update_open_button()\n\n    def _update_open_button(self):\n        self._open_button.inner_html = \"Select Armaments...\" if len(self._selection) == 0 \\\n            else \"<b>1</b> Armament Selected\" if len(self._selection) == 1 \\\n            else f\"<b>{len(self._selection)}</b> Armaments Selected\"\n\n    def _update_save_button(self):\n        self._save_button.inner_html = f\"Save (<b>{len(self._temporary)}</b>)\"\n\n    def toggle(self):\n        self._open_button.click()\n\n    @debounce(0.3) # larger debounce than _on_filter to postpone the save after filter is completed\n    def select_and_save(self):\n        if not self._is_open or len(self._filter_field.value) == 0:\n            return\n\n        [self.on_armament(element=a.wrapped) for a in self._choices if not a.is_selected and a.wrapped.is_visible]\n        self.on_save()\n        self.toggle()\n\n    def on_open(self, element: ElementWrapper | None = None):\n        self._temporary = copy(self._selection)\n\n        # re-select every choice (there may be leftovers from cancelling)\n        for arm in self._choices:\n            arm.deselect()\n\n            if arm.key in self._temporary:\n                arm.select()\n\n        self._update_save_button()\n        self._is_open = True\n\n    def on_save(self, element: ElementWrapper | None = None):\n        for removed in self._selection.difference(self._temporary):\n            self._container.remove(removed)\n\n        for added in self._temporary.difference(self._selection):\n            et = self._factory.create(added, self._on_remove)\n            self._container.add(et)\n\n        self._selection = copy(self._temporary)\n        self.on_close()\n\n    def on_close(self, element: ElementWrapper | None = None):\n        self._temporary.clear()\n        self._filter_field.value = \"\"\n\n        self._on_filter(element=self._filter_field)\n        self._update_open_button()\n        self._is_open = False\n\n    def on_category(self, element: ElementWrapper):\n        choices = [\n            arm for arm in self._choices\n            if arm.category == element.attributes[\"data-armament-category\"]\n        ]\n\n        if all(a.is_selected for a in choices):\n            [self.on_armament(element=a.wrapped) for a in choices if a.is_selected]\n\n        else:\n            [self.on_armament(element=a.wrapped) for a in choices if not a.is_selected]\n\n    def on_armament(self, element: ElementWrapper):\n        arm = self._Armament.create(element)\n\n        if arm.is_selected:\n            self._temporary.remove(arm.key)\n            arm.deselect()\n\n        else:\n            self._temporary.add(arm.key)\n            arm.select()\n\n        self._update_save_button()\n\n    def on_all_armaments(self, element: ElementWrapper | None = None):\n        if all(a.is_selected for a in self._choices if a.wrapped.is_visible):\n            [self.on_armament(element=a.wrapped) for a in self._choices if a.is_selected and a.wrapped.is_visible]\n\n        else:\n            [self.on_armament(element=a.wrapped) for a in self._choices if not a.is_selected and a.wrapped.is_visible]\n\nclass HelpMenu:\n    _selector: ArmamentSelector\n    _button = ElementWrapper(\"open-help-menu\")\n\n    def __init__(self, selector: ArmamentSelector) -> None:\n        self._selector = selector\n        add_event_listener(document, \"keydown\", self._on_key_down)\n\n    def _on_key_down(self, keyboard_event):\n        if keyboard_event.code == \"Slash\":\n            if keyboard_event.shiftKey:\n                self._button.click()\n\n            else:\n                keyboard_event.preventDefault()\n                selector.toggle()\n\n        elif keyboard_event.code == \"Enter\":\n            keyboard_event.preventDefault()\n            selector.select_and_save()\n\nsettings_menu = SettingsMenu()\nattribute_menu = AttributeMenu()\n\nfactory = ArmamentEntryFactory()\ncontainer = ArmamentContainer(settings_menu, attribute_menu)\n\nselector = ArmamentSelector(factory, container)\nselector.on_save()\n\nHelpMenu(selector)"}
{"type": "source_file", "path": "src/erdb/table/__init__.py", "content": "from enum import StrEnum\nfrom typing import Any, Self, NamedTuple\n\nfrom erdb.table._retrievers import RetrieverData\nfrom erdb.table._common import TableSpec\nfrom erdb.table.ammo import AmmoTableSpec\nfrom erdb.table.armaments import ArmamentTableSpec\nfrom erdb.table.armor import ArmorTableSpec\nfrom erdb.table.ashes_of_war import AshOfWarTableSpec\nfrom erdb.table.bolstering_materials import BolsteringMaterialTableSpec\nfrom erdb.table.correction_attack import CorrectionAttackTableSpec\nfrom erdb.table.correction_graph import CorrectionGraphTableSpec\nfrom erdb.table.crafting_materials import CraftingMaterialTableSpec\nfrom erdb.table.gestures import GestureTableSpec\nfrom erdb.table.info import InfoTableSpec\nfrom erdb.table.keys import KeyTableSpec\nfrom erdb.table.reinforcements import ReinforcementTableSpec\nfrom erdb.table.shop import ShopTableSpec\nfrom erdb.table.spells import SpellTableSpec\nfrom erdb.table.spirit_ashes import SpiritAshTableSpec\nfrom erdb.table.talismans import TalismanTableSpec\nfrom erdb.table.tools import ToolTableSpec\nfrom erdb.typing.game_version import GameVersion\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.typing.params import ParamRow\n\n\nclass Generator(NamedTuple):\n    spec: TableSpec\n    data: RetrieverData\n\n    def generate(self, api: ApiVersion | None = None) -> dict:\n        api = self.spec.latest_api() if api is None else api\n\n        def key(row: ParamRow) -> Any:\n            return self.spec.get_pk(self.data, row)\n\n        def value(row: ParamRow) -> Any:\n            return self.spec.make_object(api, self.data, row)\n\n        def valid(row: ParamRow) -> bool:\n            return all(pred(row) for pred in self.spec.predicates)\n\n        rows = self.data.main_param.values()\n        return {key(row): value(row) for row in rows if valid(row)}\n\n    @classmethod\n    def create(cls, spec: TableSpec, version: GameVersion) -> Self:\n        def retrieve_dict(retrievers: dict):\n            return {field: retrievers[field].get(version) for field in retrievers.keys()}\n\n        return cls(\n            spec,\n            RetrieverData(\n                spec.main_param_retriever.get(version),\n                retrieve_dict(spec.param_retrievers),\n                retrieve_dict(spec.msg_retrievers),\n                retrieve_dict(spec.shop_retrievers),\n                spec.contrib_retriever.get(spec.title(), version),\n            )\n        )\n\nclass Table(StrEnum):\n    ALL = \"all\"\n    AMMO = \"ammo\"\n    ARMAMENTS = \"armaments\"\n    ARMOR = \"armor\"\n    ASHES_OF_WAR = \"ashes-of-war\"\n    BOLSTERING_MATERIALS = \"bolstering-materials\"\n    CORRECTION_ATTACK = \"correction-attack\"\n    CORRECTION_GRAPH = \"correction-graph\"\n    CRAFTING_MATERIALS = \"crafting-materials\"\n    GESTURES = \"gestures\"\n    INFO = \"info\"\n    KEYS = \"keys\"\n    REINFORCEMENTS = \"reinforcements\"\n    SHOP = \"shop\"\n    SPELLS = \"spells\"\n    SPIRIT_ASHES = \"spirit-ashes\"\n    TASLISMANS = \"talismans\"\n    TOOLS = \"tools\"\n\n    def __str__(self):\n        return self.value\n\n    def __lt__(self, other: Self):\n        assert isinstance(other, Table)\n        return self.value < other.value\n\n    def make_generator(self, version: GameVersion) -> Generator:\n        return Generator.create(self.spec, version)\n\n    @property\n    def spec(self) -> TableSpec:\n        return {\n            Table.AMMO: AmmoTableSpec,\n            Table.ARMAMENTS: ArmamentTableSpec,\n            Table.ARMOR: ArmorTableSpec,\n            Table.ASHES_OF_WAR: AshOfWarTableSpec,\n            Table.BOLSTERING_MATERIALS: BolsteringMaterialTableSpec,\n            Table.CORRECTION_ATTACK: CorrectionAttackTableSpec,\n            Table.CORRECTION_GRAPH: CorrectionGraphTableSpec,\n            Table.CRAFTING_MATERIALS: CraftingMaterialTableSpec,\n            Table.GESTURES: GestureTableSpec,\n            Table.INFO: InfoTableSpec,\n            Table.KEYS: KeyTableSpec,\n            Table.REINFORCEMENTS: ReinforcementTableSpec,\n            Table.SHOP: ShopTableSpec,\n            Table.SPELLS: SpellTableSpec,\n            Table.SPIRIT_ASHES: SpiritAshTableSpec,\n            Table.TASLISMANS: TalismanTableSpec,\n            Table.TOOLS: ToolTableSpec,\n        }[self]\n\n    @property\n    def param_name(self) -> str:\n        return self.spec.main_param_retriever.param_name\n\n    @property\n    def title(self) -> str:\n        return str(self).replace(\"-\", \" \").title()\n\n    @classmethod\n    def effective(cls) -> list[Self]:\n        s = set(Table)\n        s.remove(Table.ALL)\n        return list(s)"}
{"type": "source_file", "path": "src/erdb/__init__.py", "content": "import os\n\n\n__version__ = os.getenv(\"BUILD_VERSION\", \"0.0.0\")"}
{"type": "source_file", "path": "src/erdb/main/app.py", "content": "import json\nfrom pathlib import Path\nfrom typing import Sequence\n\nfrom erdb.main.args import parse_args\nfrom erdb.table import Table\nfrom erdb.loaders import GAME_VERSIONS\nfrom erdb.app_api.main import serve as serve_app_api\nfrom erdb.app_wiki import generate as generate_app_wiki\nfrom erdb.utils.attack_power import Attributes, CalculatorData, ArmamentCalculator\nfrom erdb.utils.changelog import generate as generate_changelog\nfrom erdb.utils.find_valid_values import find_valid_values\nfrom erdb.utils.sourcer import source_gamedata, source_map, source_icons\nfrom erdb.utils.common import Destination, pydantic_encoder_no_nulls\nfrom erdb.typing.game_version import GameVersion, GameVersionRange\n\n\nclass App:\n    args: dict\n\n    def __init__(self, argv: Sequence[str]) -> None:\n        self.args = parse_args(argv, handlers={\n            \"generate\": self.generate,\n            \"find-values\": self.find_values,\n            \"calculate-ar\": self.calculate_ar,\n            \"changelog\": self.changelog,\n            \"source\": self.source,\n            \"map\": self.source_map,\n            \"icons\": self.source_icons,\n            \"serve-api\": self.serve_api,\n            \"generate-wiki\": self.generate_wiki,\n        })\n\n    def run(self) -> int:\n        handler = self.args.pop(\"handler\")\n        return handler(**self.args)\n\n    @staticmethod\n    def generate(tables: list[Table], gamedata: GameVersionRange, minimize: bool, out: Path | None) -> int:\n        if out is None:\n            out = Path.cwd()\n        else:\n            out = out.resolve()\n\n        for version in gamedata.iterate(GAME_VERSIONS):\n            destination = out / str(version)\n            destination.mkdir(parents=True, exist_ok=True)\n\n            for tb, gen in ((tb, tb.make_generator(version)) for tb in tables):\n                print(f\"\\n>>> Generating \\\"{tb}\\\" from version {version}\", flush=True)\n\n                output_file = destination / f\"{tb}.json\"\n                print(f\"Output file: {output_file}\", flush=True)\n\n                if output_file.exists():\n                    print(f\"Output file exists and will be overridden\", flush=True)\n\n                data = gen.generate()\n                print(f\"Generated {len(data)} elements\", flush=True)\n\n                with open(output_file, mode=\"w\", encoding=\"utf-8\") as f:\n                    kwargs = {\"separators\": (\",\", \":\")} if minimize else {\"indent\": 4}\n                    json.dump(data, f, ensure_ascii=False, default=pydantic_encoder_no_nulls, allow_nan=False, **kwargs)\n\n        return 0\n\n    @staticmethod\n    def find_values(param: str, field: str, limit: int, gamedata: GameVersionRange) -> int:\n        for game_version in gamedata.iterate(GAME_VERSIONS):\n            print(f\"\\n>>> Finding values for version {game_version}\")\n            find_valid_values(param, str(game_version), field, limit)\n\n        return 0\n\n    @staticmethod\n    def calculate_ar(attribs: str, armament: str, affinity: str, level: int, data_path: Path) -> int:\n        def load_data_file(name: str):\n            with open(data_path / name) as f:\n                return json.load(f)\n\n        print(f\"\\n>>> Calculating AR for {affinity} {armament} +{level} at {attribs}\")\n\n        armaments = load_data_file(\"armaments.json\")\n        reinforcements = load_data_file(\"reinforcements.json\")\n        correction_attack = load_data_file(\"correction-attack.json\")\n        correction_graph = load_data_file(\"correction-graph.json\")\n\n        data = CalculatorData(armaments, reinforcements, correction_attack, correction_graph)\n        calc = ArmamentCalculator(data, armament, affinity, level)\n        attr = Attributes.from_string(attribs)\n\n        for attack_type, value in calc.attack_power(attr).items():\n            print(f\"{attack_type}: {value.base} +{value.scaling} ({value.total})\")\n\n        for effect_type, value in calc.status_effects(attr).items():\n            print(f\"{effect_type}: {value.base} +{value.scaling} ({value.total})\")\n\n        return 0\n\n    @staticmethod\n    def changelog(version: GameVersion, from_version: GameVersion | None, formatter: str, out: Path | None) -> int:\n        assert version in GAME_VERSIONS, f\"No {version} version found\"\n        assert from_version is None or from_version in GAME_VERSIONS, f\"No {from_version} version found\"\n\n        if out is not None:\n            out = out.resolve()\n\n        if from_version is None:\n            prev_id = GAME_VERSIONS.index(version) + 1\n            assert prev_id < len(GAME_VERSIONS), f\"No version found before {version}\"\n\n            from_version = GAME_VERSIONS[prev_id]\n\n        generate_changelog(from_version, version, out, formatter)\n        return 0\n\n    @staticmethod\n    def source(version: GameVersion | None, game_dir: Path, ignore_checksum: bool, keep_cache: bool) -> int:\n        game_dir = game_dir.resolve()\n\n        print(f\"\\n>>> Sourcing gamedata from \\\"{game_dir}\\\".\")\n\n        try:\n            source_gamedata(game_dir, ignore_checksum, version)\n\n        except AssertionError as e:\n            print(\"Sourcing gamedata failed:\", *e.args)\n            return 1\n\n        return 0\n\n    @staticmethod\n    def source_map(lod: int, underground: bool, game_dir: Path, ignore_checksum: bool, keep_cache: bool, out: Path | None) -> int:\n        game_dir = game_dir.resolve()\n\n        if out is not None:\n            out = out.resolve()\n\n        print(f\"\\n>>> Extracting map from \\\"{game_dir}\\\".\")\n\n        try:\n            source_map(game_dir, out, lod, underground, ignore_checksum, keep_cache)\n\n        except AssertionError as e:\n            print(\"Sourcing map failed:\", *e.args)\n            return 1\n\n        return 0\n\n    @staticmethod\n    def source_icons(types: list[Table], size: int, file_format: str, game_dir: Path, ignore_checksum: bool, keep_cache: bool, out: Destination | None) -> int:\n        game_dir = game_dir.resolve()\n\n        if out is None:\n            out = Destination.from_str(str(Path.cwd()))\n\n        print(f\"\\n>>> Extracting {', '.join(map(str, types))} icons from \\\"{game_dir}\\\".\")\n\n        try:\n            source_icons(game_dir, types, size, file_format, out, ignore_checksum, keep_cache)\n\n        except AssertionError as e:\n            print(\"Sourcing icons failed:\", *e.args)\n            return 1\n\n        return 0\n\n    @staticmethod\n    def serve_api(port: int, bind: str, precache: bool) -> int:\n        serve_app_api(port, bind=bind, precache=precache)\n        return 0\n\n    @staticmethod\n    def generate_wiki(uikit_version: str | None, pyscript_version: str | None, data_path: Path, minimize: bool, out: Path | None) -> int:\n        data_path = data_path.resolve()\n        out = Path.cwd() / \"erdb.wiki\" if out is None else out.resolve()\n\n        generate_app_wiki(uikit_version, pyscript_version, data_path, minimize, out)\n        return 0"}
{"type": "source_file", "path": "src/erdb/table/ammo.py", "content": "from erdb.typing.models.ammo import Ammo\nfrom erdb.typing.models.common import Damage\nfrom erdb.typing.models.effect import Effect\nfrom erdb.typing.categories import AmmoCategory\nfrom erdb.typing.enums import ItemIDFlag\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.utils.common import remove_nulls\nfrom erdb.effect_parser import parse_status_effects, parse_weapon_effects\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\n_BEHAVIOR_EFFECTS_FIELDS: list[str] = [\"spEffectBehaviorId0\", \"spEffectBehaviorId1\", \"spEffectBehaviorId2\"]\n\ndef _get_damages(row: ParamRow) -> Damage:\n    data = {\n        \"physical\": row[\"attackBasePhysics\"].get_int(null_value=\"0\"),\n        \"magic\": row[\"attackBaseMagic\"].get_int(null_value=\"0\"),\n        \"fire\": row[\"attackBaseFire\"].get_int(null_value=\"0\"),\n        \"lightning\": row[\"attackBaseThunder\"].get_int(null_value=\"0\"),\n        \"holy\": row[\"attackBaseDark\"].get_int(null_value=\"0\"),\n        \"stamina\": row[\"attackBaseStamina\"].get_int(null_value=\"0\"),\n    }\n\n    return Damage(**remove_nulls(data))\n\nclass AmmoTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Ammo,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamWeapon\", ItemIDFlag.WEAPONS)\n\n    predicates: list[RowPredicate] = [\n        lambda row: 1 <= row[\"sortId\"].as_int < 9999999,\n        lambda row: AmmoCategory.get(row) is not None,\n    ]\n\n    param_retrievers = {\n        \"effects\": ParamDictRetriever(\"SpEffectParam\", ItemIDFlag.NON_EQUIPABBLE),\n    }\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"WeaponName\"),\n        \"descriptions\": MsgsRetriever(\"WeaponCaption\"),\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        effects = data.params[\"effects\"]\n        effect_ids = [row[f].as_int for f in _BEHAVIOR_EFFECTS_FIELDS]\n\n        return Ammo(\n            **cls.make_item(data, row, summary=False),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            damage=_get_damages(row),\n            category=AmmoCategory.from_row(row),\n            effects=[Effect(**eff) for eff in parse_weapon_effects(row)],\n            status_effects=parse_status_effects(effect_ids, effects),\n        )"}
{"type": "source_file", "path": "src/erdb/effect_parser/hardcoded.py", "content": "from typing import Dict, List, NamedTuple, Self, Tuple, Union\n\nfrom erdb.typing.effects import EffectModel, EffectType, AttributeName, SchemaEffect\nfrom erdb.typing.enums import SpEffectType, AttackType, AttackCondition\n\n\nclass SpEffectConditionOffset(NamedTuple):\n    condition: Union[None, SpEffectType, AttackType, AttackCondition]\n    offset: int\n\nclass SpEffectRanges(NamedTuple):\n    class IntRange(NamedTuple):\n        begin: int\n        end: int\n\n        def __contains__(self, __x: object) -> bool:\n            assert isinstance(__x, int)\n            return self.begin <= __x <= self.end\n\n    ranges: List[IntRange]\n\n    def __contains__(self, __x: object) -> bool:\n        if isinstance(__x, str):\n            return int(__x) in self\n\n        if not isinstance(__x, int):\n            return False\n\n        return any(__x in r for r in self.ranges)\n\n    @classmethod\n    def construct(cls, *ranges: Tuple[int, int]) -> Self:\n        return cls([cls.IntRange(r[0], r[1]) for r in ranges])\n\n\"\"\"\nSome SpEffects don't seem to have anything that identify what they do (Greatshield Talisman)\nand/or are simply too difficult to parse (Winged Sword Insignia). They are listed here for visibility.\n\nThe list for each SpEffect ID should contain only the problematic effect(s). If any effect is parsable,\nit will be appended to this list automatically during generation.\n\n!! THIS LIST MUST BE CONFIRMED AFTER EACH UPDATE !!\nLast confirmed ER version: 1.04.1\n\"\"\"\n_FROM_ID: Dict[int, List[SchemaEffect]] = {\n    # >> Greatshield Talisman\n    # This effect does not seem to utilize `guardStaminaCutRate`, unlike other shield buffs.\n    341000: [\n        SchemaEffect(\n            attribute=AttributeName.STABILITY,\n            effect_model=EffectModel.MULTIPLICATIVE,\n            effect_type=EffectType.POSITIVE,\n            value=1.1\n        )\n    ],\n    # >> Concealing Veil\n    # Its only identifying property is the unique `invocationConditionsStateChange1` \"Trigger on Crouch\"\n    360100: [\n        SchemaEffect(\n            attribute=AttributeName.INVISIBLE_AT_DISTANCE,\n            conditions=[str(SpEffectType.TRIGGER_ON_CROUCH)],\n            effect_model=EffectModel.ADDITIVE,\n            effect_type=EffectType.POSITIVE,\n            value=1\n        )\n\n    ],\n    # >> Furled Finger's Trick-Mirror\n    # Nothing is identifying this SpEffect besides its ID\n    360800: [\n        SchemaEffect(\n            attribute=AttributeName.APPEAR_AS_HOST,\n            effect_model=EffectModel.ADDITIVE,\n            effect_type=EffectType.NEUTRAL,\n            value=1\n        )\n    ],\n    # >> Host's Trick-Mirror\n    # Nothing is identifying this SpEffect besides its ID\n    360900: [\n        SchemaEffect(\n            attribute=AttributeName.APPEAR_AS_COOPERATOR,\n            effect_model=EffectModel.ADDITIVE,\n            effect_type=EffectType.NEUTRAL,\n            value=1\n        )\n    ],\n    # >> Shabriri's Woe\n    # Nothing is identifying this SpEffect besides its ID\n    360500: [\n        SchemaEffect(\n            attribute=AttributeName.ATTRACT_ENEMY_AGGRESSION,\n            effect_model=EffectModel.ADDITIVE,\n            effect_type=EffectType.NEUTRAL,\n            value=1\n        )\n    ],\n}\n\n\"\"\"\nSome SpEffects reference other SpEffects by themselves or their stateInfo. Some of them can be parsed,\nwhile others can be problematic. This is the list of problematic SpEffects which hardcodes the offsets\nof the effects they are referencing, along with a potential condition which activates them.\n\"\"\"\n_FROM_OFFSET: Dict[int, list[SpEffectConditionOffset]] = {\n    350400: [ # Godskin Swaddling Cloth\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_HITS, 1)\n    ],\n    312500: [ # Millicent's Prosthesis\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_3_HITS, 5),\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_6_HITS, 6),\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_9_HITS, 7),\n    ],\n    320800: [ # Winged Sword Insignia\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_3_HITS, 4),\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_6_HITS, 5),\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_9_HITS, 6),\n    ],\n    320810: [ # Rotten Winged Sword Insignia\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_3_HITS, 4),\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_6_HITS, 5),\n        SpEffectConditionOffset(AttackCondition.SUCCESSIVE_9_HITS, 6),\n    ],\n    350500: [ # Assassin's Crimson Dagger\n        SpEffectConditionOffset(None, 2) # None -- the referenced effect contains conditions\n    ],\n    350600: [ # Assassin's Cerulean Dagger\n        SpEffectConditionOffset(None, 2) # None -- the referenced effect contains conditions\n    ]\n}\n\n\"\"\"\nSome SpEffects types define effects themselves without affecting any attributes.\n\"\"\"\n_FROM_TYPE: Dict[SpEffectType, List[SchemaEffect]] = {\n    # >> Crucible Knot Talisman + IDs: 9648, 6044000\n    # Crucible Knot Talisman does not seem to define exactly how much the damage is reduced.\n    SpEffectType.REDUCE_HEADSHOT_IMPACT: [\n        SchemaEffect(\n            attribute=AttributeName.REDUCE_HEADSHOT_IMPACT,\n            effect_model=EffectModel.ADDITIVE,\n            effect_type=EffectType.POSITIVE,\n            value=1\n        )\n    ],\n    # >> Entwining Umbilical Cord\n    SpEffectType.SWITCH_ANIMATION_GENDER: [\n        SchemaEffect(\n            attribute=AttributeName.SWITCH_ANIMATION_GENDER,\n            effect_model=EffectModel.ADDITIVE,\n            effect_type=EffectType.NEUTRAL,\n            value=1\n        )\n    ],\n    # >> Sacrificial Twig\n    SpEffectType.DESTROY_ACCESSORY_BUT_SAVE_RUNES: [\n        SchemaEffect(\n            attribute=AttributeName.PRESERVE_RUNES_ON_DEATH,\n            effect_model=EffectModel.ADDITIVE,\n            effect_type=EffectType.POSITIVE,\n            value=1\n        ),\n        SchemaEffect(\n            attribute=AttributeName.DESTROY_ITEM_ON_DEATH,\n            effect_model=EffectModel.ADDITIVE,\n            effect_type=EffectType.NEGATIVE,\n            value=1\n        ),\n    ],\n}\n\ndef get(index: int, sp_effect_type) -> List[SchemaEffect]:\n    return _FROM_ID.get(index, []) + _FROM_TYPE.get(sp_effect_type, [])\n\ndef get_conditions(index: int) -> List[SpEffectConditionOffset]:\n    return _FROM_OFFSET.get(index, [])\n\ndef get_status_effect_ranges() -> SpEffectRanges:\n    return SpEffectRanges.construct((6400, 6810), (105000, 109000))"}
{"type": "source_file", "path": "src/erdb/main/args.py", "content": "from inspect import Parameter, signature\nfrom argparse import ArgumentParser, BooleanOptionalAction, Action, RawDescriptionHelpFormatter\nfrom pathlib import Path\nfrom typing import Any, Callable, NamedTuple, Sequence, Self\nfrom textwrap import wrap, dedent\n\nfrom erdb.table import Table\nfrom erdb.loaders import GAME_VERSIONS\nfrom erdb.utils.changelog import FormatterBase\nfrom erdb.utils.common import Destination\nfrom erdb.typing.game_version import GameVersion, GameVersionRange\n\n\ndef _parse_all_tables(tables: list[Table], all_effective_tables) -> list[Table]:\n    table_set = set(tables)\n\n    if Table.ALL in table_set:\n        table_set.update(all_effective_tables)\n        table_set.remove(Table.ALL)\n\n    return list(table_set)\n\ndef _infer_annotation(type: Any, **kwargs) -> Any:\n    if kwargs.get(\"action\") in [\"store_true\", BooleanOptionalAction]:\n        return bool\n    \n    assert type is not None, \"Annotation cannot be deduced if no type is provided.\"\n\n    if \"default\" in kwargs:\n        if kwargs[\"default\"] == None:\n            return type | None\n\n        if isinstance(kwargs[\"default\"], list):\n            return list[type]\n\n    return type\n\nclass _TablesAction(Action):\n    def __call__(self, parser, namespace, values: list[Table], option_string=None):\n        setattr(namespace, self.dest, _parse_all_tables(values, Table))\n\nclass _GamedataAction(Action):\n    def __call__(self, parser, namespace, values: list[str], option_string=None):\n        setattr(namespace, self.dest, GameVersionRange.from_string(\" \".join(values)))\n\nclass _ItemTypesAction(Action):\n    def __call__(self, parser, namespace, values: list[Table], option_string=None):\n        setattr(namespace, self.dest, _parse_all_tables(values, _ItemTypesAction.choices()))\n\n    @staticmethod\n    def choices() -> list[Table]:\n        return [Table.ALL] + [tb for tb in Table.effective() if tb.spec.has_icons()]\n\nclass _Argument(NamedTuple):\n    names: tuple\n    param: Parameter\n    kwargs: dict\n\n    @classmethod\n    def make(cls, *names: str, type: Any | None = None, annotation: Any | None = None, **kwargs) -> Self:\n        assert len(names) > 0, \"No names given to _Argument.\"\n        param_name = names[0].removeprefix(\"--\").replace(\"-\", \"_\")\n\n        if annotation is None:\n            annotation = _infer_annotation(type, **kwargs)\n\n        return cls(\n            names,\n            Parameter(param_name, Parameter.POSITIONAL_OR_KEYWORD, annotation=annotation),\n            kwargs | ({} if type is None else {\"type\": type}) \n        )\n\n    @classmethod\n    def minimize_output(cls) -> list[Self]:\n        return [\n            cls.make(\"--minimize\", action=\"store_true\", help=\"Output minimized text file when generating data.\")\n        ]\n\n    @classmethod\n    def outputs_uri(cls) -> list[Self]:\n        return [\n            cls.make(\"--out\", \"-o\", type=Destination.from_str, default=None, annotation=Destination | None, help=\"Optional output in standard URI syntax, can be a regular file/directory path.\")\n        ]\n\n    @classmethod\n    def outputs_file(cls) -> list[Self]:\n        return [\n            cls.make(\"--out\", \"-o\", type=Path, default=None, help=\"Optional output file path.\")\n        ]\n\n    @classmethod\n    def outputs_json(cls) -> list[Self]:\n        return cls.minimize_output() + cls.outputs_file()\n\n    @classmethod\n    def parses_generated_data(cls) -> list[Self]:\n        return [\n            cls.make(\"--data-path\", type=Path, required=True, help=\"Location of the ERDB-generated data.\"),\n        ]\n\n    @classmethod\n    def parses_gamedata(cls) -> list[Self]:\n        default = GameVersionRange.from_version(GAME_VERSIONS[0]) if len(GAME_VERSIONS) > 0 else None\n        return [\n            cls.make(\n                \"--gamedata\", \"-g\", annotation=GameVersionRange, default=default, nargs=\"+\",\n                action=_GamedataAction, help=\"Game version range to source the data from.\"\n            )\n        ]\n\n    @classmethod\n    def sources_gamedata(cls) -> list[Self]:\n        return [\n            cls.make(\"--game-dir\", type=Path, required=True, help=\"Path to ELDEN RING's \\\"Game\\\" directory, where the binary is located.\"),\n            cls.make(\"--ignore-checksum\", action=BooleanOptionalAction, help=\"Ignore MD5 verification of thirdparty tools.\"),\n            cls.make(\"--keep-cache\", action=BooleanOptionalAction, help=\"Keep the unpacked files, if any.\"),\n        ]\n\nclass _Subcommand(NamedTuple):\n    command: str\n    summary: str\n    details: str\n    aliases: list[str] = []\n    examples: list[tuple[str, str]] = []\n    arguments: list[_Argument] = []\n\n    @classmethod\n    def iterate(cls):\n        yield from iter(cls.__subclasses__())\n\n    @classmethod\n    def get_parameters(cls) -> list[Parameter]:\n        return [arg.param for arg in cls.arguments]\n\n    @classmethod\n    def get_description(cls) -> str:\n        return \"\\n\".join(wrap(dedent(cls.details), break_on_hyphens=False))\n\n    @classmethod\n    def get_epilog(cls) -> str:\n        to_str = lambda x: f\"[EXAMPLE] {x[0]}\\n$ {x[1]}\"\n        return \"\\n\\n\".join(map(to_str, cls.examples))\n\nclass Generate(_Subcommand):\n    command = \"generate\"\n    summary = \"Generate JSON data for specified tables.\"\n    details = \"\"\"\\\n    Parse extracted gamedata into a well-structured JSON output.\n    The resulting data will be written to `{table}.json` files in a folder named after the `--out` argument, or cwd if not provided.\n    This is a manual way of generating data, many other subcommands do this automatically.\n    \"\"\"\n\n    aliases = [\"gen\"]\n\n    examples = [\n        (\n            \"Generate Armor data only for version 1.07.0\",\n            \"erdb gen armor --gamedata only 1.07.0\",\n        ),\n        (\n            \"Generate Talisman and Tool data for versions between 1.04.1 and 1.07.1 (including)\",\n            \"erdb gen talismans tools --gamedata from 1.04.1 until 1.07.1\",\n        ),\n        (\n            \"Generate all data for all versions from 1.06.0 (including), minimize the JSON output\",\n            \"erdb gen all --gamedata until 1.06.0 --minimize\",\n        ),\n    ]\n\n    arguments = [\n        _Argument.make(\"tables\", type=Table, default=[], choices=list(Table), nargs=\"+\", action=_TablesAction, help=\"Specify any or all tables.\")\n    ] + _Argument.parses_gamedata() + _Argument.outputs_json()\n\nclass FindValues(_Subcommand):\n    command = \"find-values\"\n    summary = \"Find all possible values of a field per param name.\"\n    details = \"\"\"\\\n    Search for all possible values of a particular property in the specified game param.\n    Unique values will be listed on each line, with example item/row names, or only their IDs if the name is blank.\n    Useful for figuring out which properties are important and how the rows are grouped in relation to them.\n    \"\"\"\n\n    aliases = [\"vals\"]\n\n    examples = [\n        (\n            \"Show unique values for \\\"sortGroupId\\\" property of \\\"EquipParamGoods\\\"\",\n            \"erdb vals EquipParamGoods sortGroupId\",\n        ),\n        (\n            \"Show weapon categories in \\\"EquipParamWeapon\\\", with up to 20 examples per category\",\n            \"erdb vals EquipParamWeapon weaponCategory --limit 20\",\n        ),\n    ]\n\n    arguments = [\n        _Argument.make(\"param\", type=str, help=\"Name of the parameter table, ex. SpEffectParam\"),\n        _Argument.make(\"field\", type=str, help=\"Name of the field of the table, ex. slashDamageCutRate\"),\n        _Argument.make(\"--limit\", \"-l\", type=int, default=8, metavar=\"NUM\", help=\"Limit of examples shown for each value (default 8).\"),\n    ] + _Argument.parses_gamedata()\n\nclass CalculateAR(_Subcommand):\n    command = \"calculate-ar\"\n    summary = \"Calculate attack power of an armament\"\n    details = \"\"\"\\\n    Calculate attack power and status effects of an armament of any affinity or level combination using the generated data.\n    Provide the path to the data output directory from `erdb generate` via `--data-path`.\n    Somber weapon levels are as-is, you must know the maximum level of the given weapon or wether the affinity is interchangable.\n    Providing a level higher than maxiumum or an invalid affinity will result in an error.\n    \"\"\"\n\n    aliases = [\"ar\"]\n\n    examples = [\n        (\n            \"Get AR and status effects for Poison Claymore +25 at 25 str, 30 dex, 10 int, 10 fth, 20 arc\",\n            \"erdb ar 25,30,10,10,20 Claymore Poison 25 --data-path /path/to/generated/data/1.07.1/\",\n        ),\n        (\n            \"Get AR for Standard Axe of Godfrey +8 at 50 str, 20 dex, 10 int, 10 fth, 10 arc\",\n            \"erdb ar 50,20,10,10,10 \\\"Axe of Godfrey\\\" Standard 8 --data-path ./1.06.0\",\n        ),\n    ]\n\n    arguments = [\n        _Argument.make(\"attribs\", type=str, help=\"Player attributes in format \\\"str,dex,int,fth,arc\\\".\"),\n        _Argument.make(\"armament\", type=str, help=\"Name of the armament.\"),\n        _Argument.make(\"affinity\", type=str, help=\"Affinity of the armament.\"),\n        _Argument.make(\"level\", type=int, help=\"Upgrade level of the armament.\"),\n    ] + _Argument.parses_generated_data()\n\nclass Changelog(_Subcommand):\n    command = \"changelog\"\n    summary = \"Create a changelog of ERDB-detectable differences between specified versions.\"\n    details = \"\"\"\\\n    Compare two generated data and create a human-readable list of updates.\n    ERDB automatically finds the previous version from the one requested, but that can be overridden with an optional `--from-version` argument.\n    Different formatters are available, using which the output will be written to stdout, or a specific file if `--out` is provided.\n    \"\"\"\n\n    aliases = []\n\n    examples = [\n        (\n            \"Generate changelog from version 1.06.0 to 1.07.0 and write it to CHANGELOG.md using markdown format\",\n            \"erdb changelog 1.07.0 --formatter markdown --out CHANGELOG.md\",\n        ),\n        (\n            \"Print changelog from version 1.05.0 to 1.07.1 in a text format to stdout\",\n            \"erdb changelog 1.07.1 --from-version 1.05.0 --formatter text\",\n        ),\n    ]\n\n    arguments = [\n        _Argument.make(\"version\", type=GameVersion.from_string, annotation=GameVersion, help=\"Version to generate the changelog of.\"),\n        _Argument.make(\"--from-version\", type=GameVersion.from_string, annotation=GameVersion | None, default=None, help=\"Optional starting version of the changelog, previous if not specified.\"),\n        _Argument.make(\"--formatter\", \"-f\", type=str, default=FormatterBase.identifiers()[0], choices=FormatterBase.identifiers(), help=\"Format to output the changelog in.\"),\n    ] + _Argument.outputs_file()\n\nclass Source(_Subcommand):\n    command = \"source\"\n    summary = \"Extract gamedata from an UXM-unpacked ELDEN RING installation (Windows only).\"\n    details = \"\"\"\\\n    Parse an UXM-unpacked installation of ELDEN RING and collect data to ERDB package resources.\n    In order to extract the files beyond UXM, third-party tools will be downloaded, verified and executed.\n    The version of the game is automatically detected but can be overridden for any purpose, ex. modded version.\n    This version can then be used in other ERDB subcommands, like generating tables or calculating AR.\n    \"\"\"\n\n    aliases = []\n\n    examples = [\n        (\n            \"Source a game folder and autodetect its version\",\n            \"erdb source --game-dir \\\"/path/to/ELDEN RING/Game\\\"\",\n        ),\n        (\n            \"Source a game folder, specifying custom version and keep whatever was additionally extracted\",\n            \"erdb source --game-dir \\\"/path/to/ELDEN RING/Game\\\" --keep-cache --version 1.99.0\",\n        ),\n    ]\n\n    arguments = [\n        _Argument.make(\"--version\", \"-v\", type=GameVersion.from_string, annotation=GameVersion | None, default=None, help=\"Version directory storing the extracted files, overrides autodetection.\"),\n    ] + _Argument.sources_gamedata()\n\nclass Map(_Subcommand):\n    command = \"map\"\n    summary = \"Extract world map image from an UXM-unpacked ELDEN RING installation (Windows only).\"\n    details = \"\"\"\\\n    Parse an UXM-unpacked installation of ELDEN RING and extract the world map tiles.\n    Tiles are combined into an image and written to the specified file or directory using the `--out` argument.\n    Provide a file extension to automatically convert it to that format.\n    \"\"\"\n\n    aliases = []\n\n    examples = [\n        (\n            \"Write the full quality map to er_map.jpeg\",\n            \"erdb map --game-dir \\\"/path/to/ELDEN RING/Game\\\" -o er_map.jpeg\",\n        ),\n        (\n            \"Write the LOD 2 quality map of underground to a default filename and extension\",\n            \"erdb map --game-dir \\\"/path/to/ELDEN RING/Game\\\" --lod 2 --underground\",\n        ),\n    ]\n\n    arguments = [\n        _Argument.make(\"--lod\", \"-l\", type=int, default=0, help=\"Level of detail of the map, 0 is highest.\"),\n        _Argument.make(\"--underground\", action=BooleanOptionalAction, help=\"Specifies whether to extract the underground map instead of the overworld.\"),\n    ] + _Argument.sources_gamedata() + _Argument.outputs_file()\n\nclass Icons(_Subcommand):\n    command = \"icons\"\n    summary = \"Extract item images from an UXM-unpacked ELDEN RING installation (Windows only).\"\n    details = \"\"\"\\\n    Parse an UXM-unpacked installation of ELDEN RING and extract the item icons.\n    Accepts list of tables similar to `erdb generate` but only ones that actually are in-game items.\n    Item icons are output in directories with the same name as their respective table, parented by the `--out` argument, or cwd if not provided.\n    `--file-format` can be used to name them in a custom way and provide a specific extension to automatically format images to.\n    \"\"\"\n\n    aliases = []\n\n    examples = [\n        (\n            \"Extract icons for tools and keys in specific file names and as ICO format\",\n            \"erdb icons tools keys --game-dir \\\"/path/to/ELDEN RING/Game\\\" --file-format \\\"{icon_id} - {name}.ico\\\"\",\n        ),\n        (\n            \"Extract all icons in small file size\",\n            \"erdb icons all --game-dir \\\"/path/to/ELDEN RING/Game\\\" --size 128\",\n        ),\n        (\n            \"Extract all icons and upload them to a Cloudflare image hosting instance\",\n            \"erdb icons all --game-dir \\\"/path/to/ELDEN RING/Game\\\" --out \\\"https://account_id:api_token@\\\" --file-format \\\"icons/{table}/{icon_id}\\\"\",\n        ),\n    ]\n\n    arguments = [\n        _Argument.make(\"types\", type=Table, default=[], nargs=\"+\", choices=_ItemTypesAction.choices(), action=_ItemTypesAction, help=\"Specify item types to export images for.\"),\n        _Argument.make(\"--size\", \"-s\", type=int, default=1024, choices=range(1, 1025), metavar=\"[1-1024]\", help=\"Size in pixels of images to be exported, resized from maximum quality in game files (1024x1024).\"),\n        _Argument.make(\"--file-format\", \"-f\", type=str, default=\"{icon_id}.png\", help=\"Specify the formatting for file names, including extension. Available fields: {icon_id}, {name}, {table}. NOTE: multiple items can share {icon_id}, therefore {name} alone is not exhaustive and only one will be used.\"),\n    ] + _Argument.sources_gamedata() + _Argument.outputs_uri()\n\nclass ServeAPI(_Subcommand):\n    command = \"serve-api\"\n    summary = \"Begin serving the API web server.\"\n    details = \"\"\"\\\n    Start a web server providing a REST API for every table and for all available game versions.\n    Data is served from memory, and is generated lazily unless `--precache` is provided.\n    The full documentation is available under `/v{api_version}/docs` or `/v{api_version}/redoc` endpoints.\n    Higher level endpoints, `/docs` and `/redoc` outline all API versions there are thus far.\n    \"\"\"\n\n    aliases = [\"api\"]\n\n    examples = [\n        (\n            \"Serve the REST API on port 8080 and pracache all the tables\",\n            \"erdb serve-api --port 8080 --precache\",\n        ),\n    ]\n\n    arguments = [\n        _Argument.make(\"--port\", \"-p\", type=int, required=True, help=\"Port number to listen on.\"),\n        _Argument.make(\"--bind\", \"-b\", type=str, default=\"0.0.0.0\", help=\"Address to bind the server on.\"),\n        _Argument.make(\"--precache\", action=BooleanOptionalAction, help=\"Pregenerate all data instead of lazy loading.\"),\n    ]\n\nclass GenerateWiki(_Subcommand):\n    command = \"generate-wiki\"\n    summary = \"Generate a static Wikipedia website.\"\n    details = \"\"\"\\\n    Fetch generated ERDB data and create static Wikipedia pages using predefined Jinja2 templates.\n    Powered using the UIkit3 CSS framework and pyscript library, which are automatically downloaded\n    if not found at the destination. Use `--ukit-version` and `--pyscript-version` to override which\n    version will be downloaded instead of an internally defined one.\n    \"\"\"\n\n    aliases = [\"wiki\"]\n\n    examples = [\n        (\n            \"Generate wiki pages for 1.08.1 data at a specified location\",\n            \"erdb generate-wiki --data-path ./1.08.1/ --out ../wiki-location/\"\n        ),\n        (\n            \"Generate wiki pages for 1.08.1 using explicitly-provided version of UIkit and pyscript\",\n            \"erdb generate-wiki --data-path ./1.08.1/ --uikit-version 3.15.18 --pyscript-version 2022.12.1\"\n        ),\n    ]\n\n    arguments = [\n        _Argument.make(\"--uikit-version\", type=str, default=None, help=\"UIkit version to override, defaults to internal, frozen-on value.\"),\n        _Argument.make(\"--pyscript-version\", type=str, default=None, help=\"pyscript version to override, defaults to internal, frozen-on value.\"),\n    ] + _Argument.parses_generated_data() + _Argument.minimize_output() + _Argument.outputs_file()\n\ndef parse_args(argv: Sequence[str], handlers: dict[str, Callable]) -> dict[str, Any]:\n    parser = ArgumentParser(description=\"Interface for ERDB operations.\")\n    subs = parser.add_subparsers(title=\"subcommands\", required=True)\n\n    for cmd in _Subcommand.iterate():\n        assert cmd.command in handlers, f\"No handler found for \\\"{cmd.command}\\\" subcommand\"\n        handler = handlers[cmd.command]\n\n        sig = signature(handler)\n        assert sig.return_annotation == int, f\"Handler for \\\"{cmd.command}\\\" must return an int\"\n        assert cmd.get_parameters() == list(sig.parameters.values()), f\"Parameter mismatch for \\\"{cmd.command}\\\" handler\"\n\n        p = subs.add_parser(cmd.command, help=cmd.summary, description=cmd.get_description(), aliases=cmd.aliases, epilog=cmd.get_epilog(), formatter_class=RawDescriptionHelpFormatter)\n\n        for arg in cmd.arguments:\n            p.add_argument(*arg.names, **arg.kwargs)\n\n        p.set_defaults(handler=handler)\n\n    return vars(parser.parse_args(argv))"}
{"type": "source_file", "path": "src/erdb/shop/shop_typing.py", "content": "from enum import IntEnum\nfrom typing import Dict, List, NamedTuple, Self\n\nfrom erdb.typing.params import ParamRow\n\n\nclass Material(NamedTuple):\n    class Category(IntEnum):\n        NONE = 0\n        PROTECTOR = 1\n        GOOD = 4\n        UNKNOWN = 15\n    \n    index: int\n    category: Category\n\n    def __hash__(self) -> int:\n        return hash((self.index, self.category))\n\n    def __eq__(self, __o: object) -> bool:\n        if not isinstance(__o, Material):\n            return False\n        return self.index == __o.index and self.category == __o.category\n\nclass Product(NamedTuple):\n    class Category(IntEnum):\n        WEAPON = 0\n        PROTECTOR = 1\n        ACCESSORY = 2\n        GOOD = 3\n        ASHES = 4\n\n    index: int\n    category: Category\n\n    def __hash__(self) -> int:\n        return hash((self.index, self.category))\n\n    def __eq__(self, __o: object) -> bool:\n        if not isinstance(__o, Product):\n            return False\n        return self.index == __o.index and self.category == __o.category\n\nclass Currency(IntEnum):\n    RUNES = 0\n    DRAGON_HEART = 1\n    STARLIGHT_SHARD = 2\n    UNKNOWN = 3\n    LOST_ASHES_OF_WAR = 4\n\nclass MaterialSetParams(NamedTuple):\n    index: str\n    category: str\n    quantity: str\n\n_MATERIAL_SET_PARAM_LIST: List[MaterialSetParams] = [\n    MaterialSetParams(\"materialId01\", \"materialCate01\", \"itemNum01\"),\n    MaterialSetParams(\"materialId02\", \"materialCate02\", \"itemNum02\"),\n    MaterialSetParams(\"materialId03\", \"materialCate03\", \"itemNum03\"),\n    MaterialSetParams(\"materialId04\", \"materialCate04\", \"itemNum04\"),\n    MaterialSetParams(\"materialId05\", \"materialCate05\", \"itemNum05\"),\n    MaterialSetParams(\"materialId06\", \"materialCate06\", \"itemNum06\"),\n]\n\nclass Lineup(NamedTuple):\n    product: Product\n    price: int=0\n    materials: Dict[Material, int]={} # material -> quantity\n    currency: Currency=Currency.RUNES\n\n    @classmethod\n    def from_params(cls, lineup_param: ParamRow, material_set: ParamRow) -> Self:\n        product = Product(lineup_param[\"equipId\"].as_int, Product.Category(lineup_param[\"equipType\"].as_int))\n        materials: Dict[Material, int] = {}\n\n        for param in _MATERIAL_SET_PARAM_LIST:\n            if mat_id := material_set[param.index].get_int():\n                category = Material.Category(material_set[param.category].as_int)\n                materials[Material(mat_id, category)] = material_set[param.quantity].as_int\n\n        return cls(\n            product=product,\n            price=lineup_param[\"value\"].as_int,\n            materials=materials,\n            currency=Currency(lineup_param[\"costType\"].as_int)\n        )"}
{"type": "source_file", "path": "src/erdb/app_api/main.py", "content": "import uvicorn\nfrom fastapi import FastAPI, APIRouter, Depends\nfrom fastapi_versioning import VersionedFastAPI, versioned_api_route\nfrom fastapi.middleware.cors import CORSMiddleware\n\nfrom erdb.app_api.endpoints import DataEndpoint, ItemEndpoint\nfrom erdb.app_api.common import DataProxy\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table import Table\n\n\ndef _get_router(data_proxy: DataProxy, api: ApiVersion, table: Table) -> APIRouter:\n    router = APIRouter(\n        prefix=\"/{game_version}/\" + table.value,\n        route_class=versioned_api_route(api),\n        tags=[table.title],\n    )\n\n    for Endpoint in [DataEndpoint, ItemEndpoint]:\n        endpoint = Endpoint(data_proxy, api, table)\n        router.add_api_route(\n            endpoint.route,\n            lambda dep = Depends(endpoint): dep,\n            response_model=endpoint.model,\n            response_model_exclude_none=True,\n            responses=endpoint.responses,\n            summary=endpoint.summary,\n            description=endpoint.description\n        )\n\n    return router\n\ndef serve(port: int, *, bind: str = \"0.0.0.0\", precache: bool = False):\n    with DataProxy.in_temp_dir(prefix=\"erdb-cache-\") as data_proxy:\n        if precache:\n            data_proxy.precache()\n\n        app = FastAPI(title=\"ERDB API Docs\", description=\"RESTful API documentation for ERDB.\")\n\n        for tb in sorted(Table.effective()):\n            for api in tb.spec.model.keys():\n                app.include_router(_get_router(data_proxy, api, tb))\n\n        app = VersionedFastAPI(app, version_format=\"API v{major}\", prefix_format=\"/v{major}\")\n        app.add_middleware(CORSMiddleware, allow_origins=[\"*\"], allow_methods=[\"GET\"], allow_headers=[\"*\"])\n\n        uvicorn.run(app, host=bind, port=port)\n"}
{"type": "source_file", "path": "src/erdb/shop/__init__.py", "content": "from erdb.typing.params import ParamDict\nfrom erdb.shop.shop_typing import Material, Lineup, Product\n\n\n\"\"\"\nHelper class for looking up any sort of item exchanges (purchases, alterations, crafting...)\n\"\"\"\nclass Lookup(object):\n    _shop_lineup: ParamDict\n    _material_sets: ParamDict\n\n    def __init__(self, shop_lineup: ParamDict, material_sets: ParamDict) -> None:\n        self._shop_lineup = shop_lineup\n        self._material_sets = material_sets\n\n    def get_lineups_from_material(self, material: Material) -> list[Lineup]:\n        lineups: list[Lineup] = []\n\n        for lineup_param in self._shop_lineup.values():\n            if mat_id := lineup_param[\"mtrlId\"].get_int():\n                lineup = Lineup.from_params(lineup_param, self._material_sets[mat_id])\n                if material in lineup.materials.keys():\n                    lineups.append(lineup)\n\n        return lineups"}
{"type": "source_file", "path": "src/erdb/typing/categories.py", "content": "from enum import Enum\nfrom typing import Self\n\nfrom erdb.typing.enums import GoodsSortGroupID, GoodsType\nfrom erdb.typing.params import ParamRow\n\n\nclass _CategoryBase(str, Enum):\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        assert False, \"not implemented\"\n\n    @classmethod\n    def from_row(cls, row: ParamRow) -> Self:\n        if cat := cls.get(row):\n            return cat\n        raise KeyError\n\nclass AmmoCategory(_CategoryBase):\n    ARROW = \"Arrow\"\n    GREATARROW = \"Greatarrow\"\n    BOLT = \"Bolt\"\n    GREATBOLT = \"Greatbolt\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        return {\n            81: AmmoCategory.ARROW,\n            83: AmmoCategory.GREATARROW,\n            85: AmmoCategory.BOLT,\n            86: AmmoCategory.GREATBOLT,\n        }.get(row[\"wepType\"].as_int)\n\nclass ArmamentCategory(_CategoryBase):\n    DAGGER = \"Dagger\"\n    STRAIGHT_SWORD = \"Straight Sword\"\n    GREATSWORD = \"Greatsword\"\n    COLOSSAL_SWORD = \"Colossal Sword\"\n    CURVED_SWORD = \"Curved Sword\"\n    CURVED_GREATSWORD = \"Curved Greatsword\"\n    KATANA = \"Katana\"\n    TWINBLADE = \"Twinblade\"\n    THRUSTING_SWORD = \"Thrusting Sword\"\n    HEAVY_THRUSTING_SWORD = \"Heavy Thrusting Sword\"\n    AXE = \"Axe\"\n    GREATAXE = \"Greataxe\"\n    HAMMER = \"Hammer\"\n    GREAT_HAMMER = \"Great Hammer\"\n    FLAIL = \"Flail\"\n    SPEAR = \"Spear\"\n    GREAT_SPEAR = \"Great Spear\"\n    HALBERD = \"Halberd\"\n    REAPER = \"Reaper\"\n    FIST = \"Fist\"\n    CLAW = \"Claw\"\n    WHIP = \"Whip\"\n    COLOSSAL_WEAPON = \"Colossal Weapon\"\n    LIGHT_BOW = \"Light Bow\"\n    BOW = \"Bow\"\n    GREATBOW = \"Greatbow\"\n    CROSSBOW = \"Crossbow\"\n    BALLISTA = \"Ballista\"\n    GLINTSTONE_STAFF = \"Glintstone Staff\"\n    SACRED_SEAL = \"Sacred Seal\"\n    SMALL_SHIELD = \"Small Shield\"\n    MEDIUM_SHIELD = \"Medium Shield\"\n    GREATSHIELD = \"Greatshield\"\n    TORCH = \"Torch\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        return _ARMAMENT_CATEGORY_IDS.get(row[\"wepType\"].as_int)\n\n    @property\n    def ingame(self) -> str:\n        return _ARMAMENT_CATEGORY_INGAME[self]\n\nclass ArmorCategory(_CategoryBase):\n    HEAD = \"Head\"\n    BODY = \"Body\"\n    ARMS = \"Arms\"\n    LEGS = \"Legs\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        return {\n            0: ArmorCategory.HEAD,\n            1: ArmorCategory.BODY,\n            2: ArmorCategory.ARMS,\n            3: ArmorCategory.LEGS,\n        }.get(row[\"protectorCategory\"].as_int)\n\nclass BolsteringMaterialCategory(_CategoryBase):\n    FLASK = \"Flask\"\n    SMITHING_STONE = \"Smithing Stone\"\n    SOMBER_SMITHING_STONE = \"Somber Smithing Stone\"\n    GLOVEWORT = \"Glovewort\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        G = GoodsSortGroupID\n        B = BolsteringMaterialCategory\n        return {\n            G.GROUP_1: B.FLASK,\n            G.GROUP_2: B.SMITHING_STONE,\n            G.GROUP_3: B.SOMBER_SMITHING_STONE,\n            G.GROUP_4: B.GLOVEWORT,\n        }.get(G(row[\"sortGroupId\"].as_int))\n\nclass CraftingMaterialCategory(_CategoryBase):\n    FAUNA = \"Fauna\"\n    FLORA = \"Flora\"\n    OBJECT = \"Object\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        G = GoodsSortGroupID\n        B = CraftingMaterialCategory\n        return {\n            G.GROUP_1: B.FAUNA,\n            G.GROUP_2: B.FLORA,\n            G.GROUP_3: B.OBJECT,\n        }.get(G(row[\"sortGroupId\"].as_int))\n\nclass InfoCategory(_CategoryBase):\n    PAINTING = \"Painting\"\n    NOTE = \"Note\"\n    TUTORIAL = \"Tutorial\"\n    CLUE = \"Clue\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        G = GoodsSortGroupID\n        I = InfoCategory\n        return {\n            G.GROUP_1: I.PAINTING if \"Painting\" in row.name else I.NOTE if \"Note\" in row.name else I.CLUE,\n            G.GROUP_2: I.TUTORIAL,\n        }.get(G(row[\"sortGroupId\"].as_int))\n\nclass KeyCategory(_CategoryBase):\n    GREAT_RUNE = \"Great Rune\"\n    MENDING_RUNE = \"Mending Rune\"\n    CONTAINER = \"Container\"\n    EXPLORATION = \"Exploration\"\n    QUEST = \"Quest\"\n    EXCHANGE = \"Exchange\"\n    FEATURE = \"Feature\"\n    WHETBLADE = \"Whetblade\"\n    MAP = \"Map\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        K = KeyCategory\n        G = GoodsSortGroupID\n\n        for custom in (K.GREAT_RUNE, K.MENDING_RUNE, K.WHETBLADE):\n            if custom.value in row.name:\n                return custom\n\n        return {\n            G.GROUP_3: K.CONTAINER,\n            G.GROUP_4: K.EXPLORATION,\n            G.GROUP_5: K.EXCHANGE if row[\"isConsume\"].as_bool else K.QUEST,\n            G.GROUP_6: K.FEATURE,\n            G.GROUP_7: K.MAP,\n        }.get(G(row[\"sortGroupId\"].as_int))\n\nclass ShopCategory(_CategoryBase):\n    COOKBOOK = \"Cookbook\"\n    BELL_BEARING = \"Bell Bearing\"\n    SPELLBOOK = \"Spellbook\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        G = GoodsSortGroupID\n        S = ShopCategory\n        return {\n            G.GROUP_6: S.COOKBOOK,\n            G.GROUP_8: S.BELL_BEARING,\n            G.GROUP_9: S.BELL_BEARING,\n            G.GROUP_10: S.SPELLBOOK,\n        }.get(G(row[\"sortGroupId\"].as_int))\n\nclass SpellCategory(_CategoryBase):\n    INCANTATION = \"Incantation\"\n    SORCERY = \"Sorcery\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        return {\n            0: SpellCategory.SORCERY,\n            1: SpellCategory.INCANTATION,\n        }.get(row[\"ezStateBehaviorType\"].as_int)\n\nclass ToolCategory(_CategoryBase):\n    ESSENTIAL = \"Essential\"\n    EDIBLE = \"Edible\"\n    POT = \"Pot\"\n    AROMATIC = \"Aromatic\"\n    THROWABLE = \"Throwable\"\n    OFFENSIVE = \"Offensive\"\n    GREASE = \"Grease\"\n    UTILITY = \"Utility\"\n    GOLDEN_RUNE = \"Golden Rune\"\n    GREAT_RUNE = \"Great Rune\"\n    REMEMBERANCE = \"Rememberance\"\n    CRYSTAL_TEAR = \"Crystal Tear\"\n    ONLINE = \"Online\"\n\n    @classmethod\n    def get(cls, row: ParamRow) -> Self | None:\n        G = GoodsSortGroupID\n        T = ToolCategory\n\n        goods_type = row[\"goodsType\"]\n\n        if goods_type == GoodsType.WONDROUS_PHYSICK_TEAR:\n            return T.CRYSTAL_TEAR\n\n        if goods_type == GoodsType.GREAT_RUNE:\n            return T.GREAT_RUNE\n\n        return {\n            G.GROUP_1: T.ESSENTIAL,\n            G.GROUP_2: T.EDIBLE,\n            G.GROUP_3: T.POT,\n            G.GROUP_4: T.AROMATIC,\n            G.GROUP_5: T.THROWABLE,\n            G.GROUP_6: T.OFFENSIVE,\n            G.GROUP_7: T.GREASE,\n            G.GROUP_8: T.UTILITY,\n            G.GROUP_9: T.UTILITY,\n            G.GROUP_10: T.GOLDEN_RUNE,\n            G.REMEMBERANCES: T.REMEMBERANCE,\n            G.ONLINE: T.ONLINE\n        }.get(G(row[\"sortGroupId\"].as_int))\n\n_ARMAMENT_CATEGORY_IDS: dict[int, ArmamentCategory] = {\n    1: ArmamentCategory.DAGGER,\n    3: ArmamentCategory.STRAIGHT_SWORD,\n    5: ArmamentCategory.GREATSWORD,\n    7: ArmamentCategory.COLOSSAL_SWORD,\n    9: ArmamentCategory.CURVED_SWORD,\n    11: ArmamentCategory.CURVED_GREATSWORD,\n    13: ArmamentCategory.KATANA,\n    14: ArmamentCategory.TWINBLADE,\n    15: ArmamentCategory.THRUSTING_SWORD,\n    16: ArmamentCategory.HEAVY_THRUSTING_SWORD,\n    17: ArmamentCategory.AXE,\n    19: ArmamentCategory.GREATAXE,\n    21: ArmamentCategory.HAMMER,\n    23: ArmamentCategory.GREAT_HAMMER,\n    24: ArmamentCategory.FLAIL,\n    25: ArmamentCategory.SPEAR,\n    28: ArmamentCategory.GREAT_SPEAR,\n    29: ArmamentCategory.HALBERD,\n    31: ArmamentCategory.REAPER,\n    35: ArmamentCategory.FIST,\n    37: ArmamentCategory.CLAW,\n    39: ArmamentCategory.WHIP,\n    41: ArmamentCategory.COLOSSAL_WEAPON,\n    50: ArmamentCategory.LIGHT_BOW,\n    51: ArmamentCategory.BOW,\n    53: ArmamentCategory.GREATBOW,\n    55: ArmamentCategory.CROSSBOW,\n    56: ArmamentCategory.BALLISTA,\n    57: ArmamentCategory.GLINTSTONE_STAFF,\n    61: ArmamentCategory.SACRED_SEAL,\n    65: ArmamentCategory.SMALL_SHIELD,\n    67: ArmamentCategory.MEDIUM_SHIELD,\n    69: ArmamentCategory.GREATSHIELD,\n    87: ArmamentCategory.TORCH,\n}\n\n_ARMAMENT_CATEGORY_INGAME: dict[ArmamentCategory, str] = {\n    ArmamentCategory.DAGGER: \"Dagger\",\n    ArmamentCategory.STRAIGHT_SWORD: \"SwordNormal\",\n    ArmamentCategory.GREATSWORD: \"SwordLarge\",\n    ArmamentCategory.COLOSSAL_SWORD: \"SwordGigantic\",\n    ArmamentCategory.CURVED_SWORD: \"SaberNormal\",\n    ArmamentCategory.CURVED_GREATSWORD: \"SaberLarge\",\n    ArmamentCategory.KATANA: \"katana\", # yes, lowercase\n    ArmamentCategory.TWINBLADE: \"SwordDoubleEdge\",\n    ArmamentCategory.THRUSTING_SWORD: \"SwordPierce\",\n    ArmamentCategory.HEAVY_THRUSTING_SWORD: \"RapierHeavy\",\n    ArmamentCategory.AXE: \"AxeNormal\",\n    ArmamentCategory.GREATAXE: \"AxeLarge\",\n    ArmamentCategory.HAMMER: \"HammerNormal\",\n    ArmamentCategory.GREAT_HAMMER: \"HammerLarge\",\n    ArmamentCategory.FLAIL: \"Flail\",\n    ArmamentCategory.SPEAR: \"SpearNormal\",\n    # unused spear: \"SpearLarge\"\n    ArmamentCategory.GREAT_SPEAR: \"SpearHeavy\",\n    ArmamentCategory.HALBERD: \"SpearAxe\",\n    ArmamentCategory.REAPER: \"Sickle\",\n    ArmamentCategory.FIST: \"Knuckle\",\n    ArmamentCategory.CLAW: \"Claw\",\n    ArmamentCategory.WHIP: \"Whip\",\n    ArmamentCategory.COLOSSAL_WEAPON: \"AxhammerLarge\",\n    ArmamentCategory.LIGHT_BOW: \"BowSmall\",\n    ArmamentCategory.BOW: \"BowNormal\",\n    ArmamentCategory.GREATBOW: \"BowLarge\",\n    ArmamentCategory.CROSSBOW: \"ClossBow\", # clossbow...\n    ArmamentCategory.BALLISTA: \"Ballista\",\n    ArmamentCategory.GLINTSTONE_STAFF: \"Staff\",\n    # unused catalyst: \"Sorcery\"\n    ArmamentCategory.SACRED_SEAL: \"Talisman\",\n    ArmamentCategory.SMALL_SHIELD: \"ShieldSmall\",\n    ArmamentCategory.MEDIUM_SHIELD: \"ShieldNormal\",\n    ArmamentCategory.GREATSHIELD: \"ShieldLarge\",\n    ArmamentCategory.TORCH: \"Torch\",\n}"}
{"type": "source_file", "path": "src/erdb/typing/__init__.py", "content": ""}
{"type": "source_file", "path": "src/erdb/table/spells.py", "content": "from erdb.typing.models.spells import Spell\nfrom erdb.typing.models.common import StatRequirements\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import GoodsType, ItemIDFlag, SpellHoldAction\nfrom erdb.typing.categories import SpellCategory\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.utils.common import remove_nulls\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\ndef _get_spell_requirements(row: ParamRow) -> StatRequirements:\n    data = {\n        \"intelligence\": row[\"requirementIntellect\"].get_int(null_value=0),\n        \"faith\": row[\"requirementFaith\"].get_int(null_value=0),\n        \"arcane\": row[\"requirementLuck\"].get_int(null_value=0),\n    }\n\n    return StatRequirements(**remove_nulls(data))\n\nclass SpellTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Spell,\n    }\n\n    # Spells are defined in Goods and Magic tables, correct full hex IDs are calculated from Goods\n    main_param_retriever = ParamDictRetriever(\"EquipParamGoods\", ItemIDFlag.GOODS)\n\n    predicates: list[RowPredicate] = [\n        lambda row: 1 <= row[\"sortId\"].as_int < 999999,\n        lambda row: row[\"goodsType\"] in [GoodsType.SORCERY_1, GoodsType.INCANTATION_1, GoodsType.SORCERY_2, GoodsType.INCANTATION_2],\n    ]\n\n    param_retrievers = {\n        \"magic\": ParamDictRetriever(\"Magic\", ItemIDFlag.NON_EQUIPABBLE)\n    }\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GoodsName\"),\n        \"summaries\": MsgsRetriever(\"GoodsInfo\"),\n        \"descriptions\": MsgsRetriever(\"GoodsCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        row_magic = data.params[\"magic\"][row.index]\n\n        fp_cost = row_magic[\"mp\"].as_int\n        fp_extra = row_magic[\"mp_charge\"].as_int\n\n        sp_cost = row_magic[\"stamina\"].as_int\n        sp_extra = row_magic[\"stamina_charge\"].as_int\n\n        hold_action = SpellHoldAction.NONE if fp_extra == 0 else SpellHoldAction.CHARGE\n        hold_action = SpellHoldAction.CONTINUOUS if row_magic[\"consumeLoopMP_forMenu\"].get_int() else hold_action \n\n        return Spell(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            fp_cost=fp_cost,\n            fp_cost_extra=fp_extra - fp_cost if hold_action == \"Charge\" else fp_extra,\n            sp_cost=sp_cost,\n            sp_cost_extra=sp_extra - sp_cost if hold_action == \"Charge\" else sp_extra,\n            category=SpellCategory.from_row(row_magic),\n            slots_used=row_magic[\"slotLength\"].as_int,\n            hold_action=hold_action,\n            is_weapon_buff=row_magic[\"isEnchant\"].as_bool,\n            is_shield_buff=row_magic[\"isShieldEnchant\"].as_bool,\n            is_horseback_castable=row_magic[\"enableRiding\"].as_bool,\n            requirements=_get_spell_requirements(row_magic),\n        )"}
{"type": "source_file", "path": "src/erdb/table/spirit_ashes.py", "content": "from erdb.typing.models.spirit_ash import SpiritAsh\nfrom erdb.typing.params import ParamDict, ParamRow\nfrom erdb.typing.enums import GoodsType, ItemIDFlag, SpiritAshUpgradeMaterial\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.utils.common import find_offset_indices\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\ndef _find_upgrade_costs(goods: ParamDict, base_item_id: int) -> list[int]:\n    indices, _ = find_offset_indices(base_item_id, goods, possible_maxima=[9]) # not 10, ignore last one\n    return [goods[i][\"reinforcePrice\"].as_int for i in indices]\n\nclass SpiritAshTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: SpiritAsh,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamGoods\", ItemIDFlag.GOODS)\n\n    predicates: list[RowPredicate] = [\n        lambda row: row.is_base_item,\n        lambda row: row[\"goodsType\"] in [GoodsType.LESSER, GoodsType.GREATER],\n    ]\n\n    param_retrievers = {\n        \"upgrade_materials\": ParamDictRetriever(\"EquipMtrlSetParam\", ItemIDFlag.NON_EQUIPABBLE)\n    }\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GoodsName\"),\n        \"summaries\": MsgsRetriever(\"GoodsInfo\"),\n        \"summon_names\": MsgsRetriever(\"GoodsInfo2\"),\n        \"descriptions\": MsgsRetriever(\"GoodsCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        upgrade_materials = data.params[\"upgrade_materials\"]\n        names = data.msgs[\"names\"]\n        summon_names = data.msgs[\"summon_names\"]\n\n        upgrade_material = upgrade_materials[row[\"reinforceMaterialId\"].as_int]\n        upgrade_material = names[upgrade_material[\"materialId01\"].as_int].removesuffix(\"[1]\").strip()\n        upgrade_material = {\n            \"Grave Glovewort\": SpiritAshUpgradeMaterial.GRAVE_GLOVEWORT,\n            \"Ghost Glovewort\": SpiritAshUpgradeMaterial.GHOST_GLOVEWORT,\n        }[upgrade_material]\n\n        return SpiritAsh(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\", \"summon_quantity\", \"abilities\"),\n            summon_name=summon_names[row.index].strip(), # sometimes trailing spaces\n            fp_cost=row[\"consumeMP\"].get_int(0),\n            hp_cost=row[\"consumeHP\"].get_int(0),\n            upgrade_material=upgrade_material,\n            upgrade_costs=_find_upgrade_costs(data.main_param, row.index)\n        )"}
{"type": "source_file", "path": "src/erdb/typing/enums.py", "content": "from enum import Enum, IntEnum\nfrom typing import Self\n\n\nclass ItemIDFlag(IntEnum):\n    DISABLE_CHECK = -1 # mark this flag irrelevant, fail if any calls requiring it are made\n    NON_EQUIPABBLE = 0 # params used only for references, ex. param sets\n    WEAPONS = 0\n    PROTECTORS = 1 << 28\n    ACCESSORIES = 1 << 29\n    GOODS = 1 << 30\n    ASHES_OF_WAR = 1 << 31\n\nclass GoodsType(str, Enum):\n    NORMAL_ITEM = \"0\"\n    KEY_ITEM = \"1\"\n    CRAFTING_MATERIAL = \"2\"\n    REMEMBRANCE = \"3\"\n    NONE_1 = \"4\"\n    SORCERY_1 = \"5\"\n    NONE_2 = \"6\"\n    LESSER = \"7\"\n    GREATER = \"8\"\n    WONDROUS_PHYSICK = \"9\"\n    WONDROUS_PHYSICK_TEAR = \"10\"\n    REGENERATIVE_MATERIAL = \"11\"\n    INFO_ITEM = \"12\"\n    NONE_3 = \"13\"\n    REINFORCEMENT_MATERIAL = \"14\"\n    GREAT_RUNE = \"15\"\n    INCANTATION_1 = \"16\"\n    SORCERY_2 = \"17\"\n    INCANTATION_2 = \"18\"\n\nclass GoodsRarity(str, Enum):\n    COMMON = \"Common\"\n    RARE = \"Rare\"\n    LEGENDARY = \"Legendary\"\n\n    @classmethod\n    def from_id(cls, index: int) -> Self:\n        return {\n            0: GoodsRarity.COMMON, # some crafting materials use 0, but the rest is \"common\"\n            1: GoodsRarity.COMMON,\n            2: GoodsRarity.RARE,\n            3: GoodsRarity.LEGENDARY,\n        }[index]\n\nclass ArmamentUpgradeMaterial(str, Enum):\n    NONE = \"None\"\n    SMITHING_STONE = \"Smithing Stone\"\n    SOMBER_SMITHING_STONE = \"Somber Smithing Stone\"\n\nclass ToolAvailability(str, Enum):\n    ALWAYS = \"Always\"\n    SINGLEPLAYER = \"Singleplayer\"\n    MULTIPLAYER = \"Multiplayer\"\n\nclass SpellHoldAction(str, Enum):\n    NONE = \"None\"\n    CHARGE = \"Charge\"\n    CONTINUOUS = \"Continuous\"\n\nclass SpiritAshUpgradeMaterial(str, Enum):\n    GRAVE_GLOVEWORT = \"Grave Glovewort\"\n    GHOST_GLOVEWORT = \"Ghost Glovewort\"\n\nclass GoodsSortGroupID(IntEnum):\n    \"\"\"\n    Defines subgroups you see in an individual menu tab.\n    Values are reused per tabs so some groups are too generic\n    to have a specific name, but there are exceptions.\n    They CAN be discerned if `GoodsType` is known.\n    \"\"\"\n    GROUP_1 = 10\n    GROUP_2 = 20\n    GROUP_3 = 30\n    GROUP_4 = 40\n    GROUP_5 = 50\n    GROUP_6 = 60\n    GROUP_7 = 70\n    GROUP_8 = 80\n    GROUP_9 = 90\n    GROUP_10 = 100 # golden runes & prayer books\n    REMEMBERANCES = 110\n    ONLINE = 120 # fingers\n    GESTURES = 250\n    ANY = 255 # a lot of seemingly random stuff and unused items\n\nclass ReferenceCategory(str, Enum):\n    ATTACK = \"0\"\n    BULLET = \"1\"\n    SP_EFFECT = \"2\"\n\nclass Affinity(str, Enum):\n    STANDARD = \"Standard\"\n    HEAVY = \"Heavy\"\n    KEEN = \"Keen\"\n    QUALITY = \"Quality\"\n    FIRE = \"Fire\"\n    FLAME_ART = \"Flame Art\"\n    LIGHTNING = \"Lightning\"\n    SACRED = \"Sacred\"\n    MAGIC = \"Magic\"\n    COLD = \"Cold\"\n    POISON = \"Poison\"\n    BLOOD = \"Blood\"\n    OCCULT = \"Occult\"\n\n    @property\n    def id(self) -> int:\n        return {\n            Affinity.STANDARD: 0,\n            Affinity.HEAVY: 1,\n            Affinity.KEEN: 2,\n            Affinity.QUALITY: 3,\n            Affinity.FIRE: 4,\n            Affinity.FLAME_ART: 5,\n            Affinity.LIGHTNING: 6,\n            Affinity.SACRED: 7,\n            Affinity.MAGIC: 8,\n            Affinity.COLD: 9,\n            Affinity.POISON: 10,\n            Affinity.BLOOD: 11,\n            Affinity.OCCULT: 12,\n        }[self]\n\n    @classmethod\n    def from_id(cls, index: int) -> Self:\n        return {\n            0: Affinity.STANDARD,\n            1: Affinity.HEAVY,\n            2: Affinity.KEEN,\n            3: Affinity.QUALITY,\n            4: Affinity.FIRE,\n            5: Affinity.FLAME_ART,\n            6: Affinity.LIGHTNING,\n            7: Affinity.SACRED,\n            8: Affinity.MAGIC,\n            9: Affinity.COLD,\n            10: Affinity.POISON,\n            11: Affinity.BLOOD,\n            12: Affinity.OCCULT,\n        }[index]\n\nclass AttackAttribute(str, Enum):\n    STANDARD = \"Standard\"\n    STRIKE = \"Strike\"\n    SLASH = \"Slash\"\n    PIERCE = \"Pierce\"\n\n    @classmethod\n    def from_id(cls, index: int) -> Self:\n        return {\n            0: AttackAttribute.SLASH,\n            1: AttackAttribute.STRIKE,\n            2: AttackAttribute.PIERCE,\n            3: AttackAttribute.STANDARD,\n        }[index]\n\nclass AshOfWarMountType(str, Enum):\n    PREVENT_CHANG = \"0\"\n    UNUSED_VALUE = \"1\"\n    ALLOW_CHANGE = \"2\"\n\nclass AttackCondition(str, Enum):\n    NONE = \"0\"\n    ON_HIT = \"1\"\n    SUCCESSIVE_HITS = \"2\"\n    SUCCESSIVE_3_HITS = \"3\"\n    SUCCESSIVE_6_HITS = \"4\"\n    SUCCESSIVE_9_HITS = \"5\"\n    VS_GRAVITY_ENEMIES = \"6\",\n    VS_UNDEAD_ENEMIES = \"7\",\n    VS_ANCIENT_DRAGON_ENEMIES = \"8\",\n    VS_DRAGON_ENEMIES = \"9\",\n\n    def __str__(self) -> str:\n        return _ATTACK_CONDITION_STR[self]\n\n_ATTACK_CONDITION_STR: dict[AttackCondition, str] = {\n    AttackCondition.NONE: \"0\",\n    AttackCondition.ON_HIT: \"On Hit\",\n    AttackCondition.SUCCESSIVE_HITS: \"Successive Hits\",\n    AttackCondition.SUCCESSIVE_3_HITS: \"Successive 3 Hits\",\n    AttackCondition.SUCCESSIVE_6_HITS: \"Successive 6 Hits\",\n    AttackCondition.SUCCESSIVE_9_HITS: \"Successive 9 Hits\",\n    AttackCondition.VS_GRAVITY_ENEMIES: \"vs Gravity Enemies\",\n    AttackCondition.VS_UNDEAD_ENEMIES: \"vs Undead Enemies\",\n    AttackCondition.VS_ANCIENT_DRAGON_ENEMIES: \"vs Ancient Dragon Enemies\",\n    AttackCondition.VS_DRAGON_ENEMIES: \"vs Dragon Enemies\",\n}\n\nclass AttackType(str, Enum):\n    NONE = \"0\"\n    FULL_MOON_SPELL = \"1\"\n    CARIAN_SWORD_SPELL = \"2\"\n    GLINTBLADE_SPELL = \"3\"\n    STONEDIGGER_SPELL = \"4\"\n    CRYSTALIAN_SPELL = \"5\"\n    KAROLOS_SPELL = \"6\"\n    OLIVINUS_SPELL = \"7\"\n    LAVA_SPELL = \"8\"\n    THORN_SPELL = \"9\"\n    DEATH_SPELL = \"10\"\n    GRAVITY_SPELL = \"11\"\n    NIGHT_SPELL = \"12\"\n    RANNI_SPELL = \"13\"\n    AZUR_SPELL = \"14\"\n    LUSAT_SPELL = \"15\"\n    BLACK_FLAME_SPELL = \"20\"\n    FLAME_SPELL = \"21\"\n    DRAGON_CULT_SPELL = \"22\"\n    BESTIAL_SPELL = \"23\"\n    GOLDEN_ORDER_SPELL = \"24\"\n    DRAGON_COMMUNION_SPELL = \"25\"\n    FRENZIED_FLAME_SPELL = \"26\"\n    GODSLAYER_SPELL = \"27\"\n    PRIMORDIAL_CRUCIBLE_SPELL = \"28\"\n    CHARGE_ATTACK = \"100\"\n    HORSEBACK_ATTACK = \"101\"\n    JUMP_ATTACK = \"102\"\n    GUARD_COUNTER_ATTACK = \"103\"\n    FINAL_CHAIN_ATTACK = \"104\"\n    AMMUNITION_ATTACK = \"105\"\n    ROAR_ATTACK = \"106\"\n    BREATH_ATTACK = \"107\"\n    POT_ITEM_ATTACK = \"108\"\n    PERFUME_ITEM_ATTACK = \"109\"\n    CHARGED_ATTACK = \"110\"\n    CHARGED_SKILL_ATTACK = \"111\"\n    SKILL_ATTACK = \"112\"\n    RANGED_SKILL_ATTACK = \"113\"\n    VAPOR_ATTACK = \"114\"\n    BUBBLE_SKILL_ATTACK = \"115\"\n    UNKNOWN_ATTACK = \"116\"\n    WRAITH_ATTACK = \"117\"\n    AMMUNITION_ONHIT_ATTACK = \"118\"\n\n    def __str__(self) -> str:\n        return _ATTACK_TYPE_STR[self]\n\n_ATTACK_TYPE_STR: dict[AttackType, str] = {\n    AttackType.NONE: \"None\",\n    AttackType.FULL_MOON_SPELL: \"Full Moon Spell\",\n    AttackType.CARIAN_SWORD_SPELL: \"Carian Sword Spell\",\n    AttackType.GLINTBLADE_SPELL: \"Glintblade Spell\",\n    AttackType.STONEDIGGER_SPELL: \"Stonedigger Spell\",\n    AttackType.CRYSTALIAN_SPELL: \"Crystalian Spell\",\n    AttackType.KAROLOS_SPELL: \"Karolos Spell\",\n    AttackType.OLIVINUS_SPELL: \"Olivinus Spell\",\n    AttackType.LAVA_SPELL: \"Lava Spell\",\n    AttackType.THORN_SPELL: \"Thorn Spell\",\n    AttackType.DEATH_SPELL: \"Death Spell\",\n    AttackType.GRAVITY_SPELL: \"Gravity Spell\",\n    AttackType.NIGHT_SPELL: \"Night Spell\",\n    AttackType.RANNI_SPELL: \"Ranni Spell\",\n    AttackType.AZUR_SPELL: \"Azur Spell\",\n    AttackType.LUSAT_SPELL: \"Lusat Spell\",\n    AttackType.BLACK_FLAME_SPELL: \"Black Flame Spell\",\n    AttackType.FLAME_SPELL: \"Flame Spell\",\n    AttackType.DRAGON_CULT_SPELL: \"Dragon Cult Spell\",\n    AttackType.BESTIAL_SPELL: \"Bestial Spell\",\n    AttackType.GOLDEN_ORDER_SPELL: \"Golden Order Spell\",\n    AttackType.DRAGON_COMMUNION_SPELL: \"Dragon Communion Spell\",\n    AttackType.FRENZIED_FLAME_SPELL: \"Frenzied Flame Spell\",\n    AttackType.GODSLAYER_SPELL: \"Godslayer Spell\",\n    AttackType.PRIMORDIAL_CRUCIBLE_SPELL: \"Primordial Crucible Spell\",\n    AttackType.CHARGE_ATTACK: \"Charge Attack\",\n    AttackType.HORSEBACK_ATTACK: \"Horseback Attack\",\n    AttackType.JUMP_ATTACK: \"Jump Attack\",\n    AttackType.GUARD_COUNTER_ATTACK: \"Guard Counter Attack\",\n    AttackType.FINAL_CHAIN_ATTACK: \"Final Chain Attack\",\n    AttackType.AMMUNITION_ATTACK: \"Ammunition Attack\",\n    AttackType.ROAR_ATTACK: \"Roar Attack\",\n    AttackType.BREATH_ATTACK: \"Breath Attack\",\n    AttackType.POT_ITEM_ATTACK: \"Pot Item Attack\",\n    AttackType.PERFUME_ITEM_ATTACK: \"Perfume Item Attack\",\n    AttackType.CHARGED_ATTACK: \"Charged Attack\",\n    AttackType.CHARGED_SKILL_ATTACK: \"Charged Skill Attack\",\n    AttackType.SKILL_ATTACK: \"Skill Attack\",\n    AttackType.RANGED_SKILL_ATTACK: \"Ranged Skill Attack\",\n    AttackType.VAPOR_ATTACK: \"Vapor Attack\",\n    AttackType.BUBBLE_SKILL_ATTACK: \"Bubble Skill Attack\",\n    AttackType.UNKNOWN_ATTACK: \"Unknown Attack\",\n    AttackType.WRAITH_ATTACK: \"Wraith Attack\",\n    AttackType.AMMUNITION_ONHIT_ATTACK: \"Ammunition OnHit Attack\"\n}\n\nclass SpEffectType(str, Enum):\n    NONE = \"0\"\n    POISON = \"2\"\n    UNKNOWN = \"3\"\n    DURABILITY_DAMAGE = \"4\"\n    SCARLET_ROT = \"5\"\n    HEMORRHAGE = \"6\"\n    GHOST = \"7\"\n    ENEMY_SIGHT_REDUCTION = \"8\"\n    TRANQUIL_WALK_OF_PEACE = \"9\"\n    REMOVE_POISON = \"10\"\n    REMOVE_SCARLET_ROT = \"11\"\n    REMOVE_HEMORRHAGE = \"12\"\n    REMOVE_ALL_STATUS = \"13\"\n    HUMANITY_STOLEN = \"14\"\n    TELESCOPE = \"15\"\n    WARP_TO_GRACE = \"16\"\n    REVIVAL = \"17\"\n    DISPEL_BLACK_PHANTOM = \"19\"\n    UNKNOWN_2 = \"22\"\n    ONREVIVEMAGIC = \"23\"\n    DISABLES_SPELL_USAGE = \"24\"\n    RIGHT_HAND_BUFF_VFX = \"28\"\n    BODY_BUFF_VFX = \"29\"\n    GHOST_PARAMETER_CHANGE = \"31\"\n    MIDDLE_OF_PARALYSIS = \"32\"\n    GIANT_SLIME_FREEZING = \"34\"\n    UNKNOWN_3 = \"35\"\n    UNKNOWN_4 = \"36\"\n    UNKNOWN_5 = \"37\"\n    SOUND_FEED = \"39\"\n    GREATER_BODY_BUFF_VFX = \"40\"\n    FLASH_SWEAT = \"41\"\n    HP_RECOVERY = \"42\"\n    UNKNOWN_6 = \"43\"\n    UNKNOWN_7 = \"44\"\n    UNKNOWN_8 = \"45\"\n    MODIFY_TARGET_PRIORITY = \"46\"\n    DISABLE_FALL_DAMAGE = \"47\"\n    INCREASE_DAMAGE = \"48\"\n    INCREASE_DEFENSE = \"49\"\n    HP_FP_STAMINA_RECOVERY = \"50\"\n    PLEDGE_EFFECT_TEST = \"52\"\n    MODIFY_ENEMY_LISTEN_REDUCTION = \"54\"\n    HOSTDEATH = \"55\"\n    POINT_LIGHT_SOURCE_EQUIPPED = \"58\"\n    YOUR_MESSAGE_WAS_RATED = \"59\"\n    MAGIC_BUFF_VFX = \"60\"\n    MAGIC_WEAPON_BUFF_VFX = \"61\"\n    FIRE_WEAPON_BUFF_VFX = \"62\"\n    ENCHANTED_WEAPON_BUFF_VFX = \"64\"\n    UNKNOWN_9 = \"65\"\n    MODIFY_ITEM_DISCOVERY = \"66\"\n    TEARS_OF_DENIAL_VFX = \"69\"\n    IS_DEAD_TEST_CONDITION = \"70\"\n    SPELL_POWER_BOOST = \"71\"\n    GREEN_BLOSSOM_VFX = \"75\"\n    MODIFY_RUNE_GAIN = \"76\"\n    UNKNOWN_10 = \"78\"\n    UNKNOWN_11 = \"79\"\n    UNKNOWN_12 = \"91\"\n    APPLIES_CHAMELON_EFFECT = \"95\"\n    APPLIES_DRAGON_FORM_EFFECT = \"96\"\n    MP_DETECTION = \"98\"\n    MP_WAIT_FOR_COOPERATION = \"99\"\n    MP_COOPERATION = \"100\"\n    MP_COOPERATION_SENT = \"101\"\n    WAX_SLOW_DOWN = \"102\"\n    USED_FOR_EVIL_EYE_EFFECT = \"103\"\n    MP_WAIT_FOR_COOPERATION_2 = \"104\"\n    MP_COOPERATION_LV_1 = \"105\"\n    MP_COOPERATION_LV_2 = \"106\"\n    MP_COOPERATION_LV_3 = \"107\"\n    USED_FOR_EVIL_EYE_EFFECT_1 = \"108\"\n    USED_FOR_EVIL_EYE_EFFECT_2 = \"109\"\n    COUNTER_DAMAGE = \"110\"\n    _1409F7282_HKS = \"112\"\n    UNKNOWN_13 = \"113\"\n    UNKNOWN_14 = \"114\"\n    BACKSTEP_ANIMATION_CHANGE = \"115\"\n    BLIGHT = \"116\"\n    INSTANT_DEATH_ANIMATION = \"117\"\n    CURE_BLIGHT = \"118\"\n    UNKNOWN_15 = \"119\"\n    DAMAGE_LEVEL_CHANGE_BEFORE_POISE_BREAK = \"120\"\n    DAMAGE_LEVEL_CHANGE = \"121\"\n    UNKNOWN_16 = \"122\"\n    TRIGGER_ON_ROLL_HEAD = \"123\"\n    TRIGGER_ON_ROLL_BODY = \"124\"\n    TRIGGER_ON_ROLL_HANDS = \"125\"\n    TRIGGER_ON_ROLL_LEGS = \"126\"\n    MIMIC_SLEEP = \"127\"\n    MIMIC_SLEEP_2 = \"128\"\n    MIMIC_SLEEP_3 = \"130\"\n    MIMIC_SLEEP_4 = \"131\"\n    CHANGE_TEAM_TYPE = \"132\"\n    ENABLE_DEVELOPER_MESSAGES = \"133\"\n    IRON_FLESH = \"134\"\n    MIMIC_SLEEP_5 = \"135\"\n    BLIGHT_2 = \"136\"\n    RESONANCELVL_0 = \"137\"\n    RESONANCELVL_1 = \"138\"\n    RESONANCELVL_2 = \"139\"\n    RESONANCELVL_3 = \"140\"\n    RESONANCELVL_4 = \"141\"\n    NPC_BEHAVIOR_ID_CHANGE = \"142\"\n    CHARACTER_RESPAWN = \"143\"\n    UNKNOWN_17 = \"144\"\n    HOLY = \"145\"\n    RESTORE_DURABILITY = \"146\"\n    CAST_LIGHT = \"147\"\n    UNKNOWN_18 = \"148\"\n    WHITE_RELIEF_MAGIC = \"149\"\n    BLACK_RELIEF_MAGIC = \"150\"\n    LIGHTNING_WEAPON_BUFF_VFX = \"151\"\n    ENABLE_ATTACK_EFFECT_AGAINST_ENEMY = \"152\"\n    ENABLE_ATTACK_EFFECT_AGAINST_PLAYER = \"153\"\n    BLOCK_ESTUS_USAGE = \"154\"\n    MODIFY_POISE = \"155\"\n    DISABLE_DURABILITY = \"156\"\n    TRANSIENT_CURSE = \"157\"\n    LEFT_HAND_BUFF_VFX = \"158\"\n    DESTROY_ACCESSORY_BUT_SAVE_RUNES = \"159\"\n    RARE_RING_OF_SACRIFICE_DS1 = \"160\"\n    WARP_TO_GRACE_2 = \"161\"\n    WARP_TO_GRACE_3 = \"162\"\n    WARP_TO_GRACE_4 = \"163\"\n    WARP_TO_GRACE_5 = \"164\"\n    WARP_TO_GRACE_6 = \"165\"\n    PLEDGE_DISCARDED = \"166\"\n    DRAGON_CHANGE_VFX = \"167\"\n    BOW_DISTANCE_CHANGE = \"168\"\n    UNKNOWN_19 = \"169\"\n    KARMIC_JUSTICE_COUNTER = \"170\"\n    USED_FOR_BEHAVIOR_CHANGE = \"171\"\n    RITUAL = \"173\"\n    POWER_OF_EVIL_SPIRITS = \"174\"\n    REVIVAL_PRODUCTION = \"175\"\n    AURAL_DECOY = \"176\"\n    UNKNOWN_20 = \"177\"\n    DEATHEFFECTLV1 = \"179\"\n    DEATHEFFECTLV2 = \"180\"\n    DEATHEFFECTLV3 = \"181\"\n    DEATHEFFECTLV4 = \"182\"\n    BLUESIGNVISUALIZATION = \"183\"\n    HIDE_WEAPON = \"184\"\n    UNKNOWN_21 = \"185\"\n    UNKNOWN_22 = \"186\"\n    UNKNOWN_23 = \"188\"\n    UNKNOWN_24 = \"189\"\n    UNKNOWN_25 = \"190\"\n    UNKNOWN_26 = \"191\"\n    UNKNOWN_27 = \"192\"\n    MODIFY_EFFECT_DURATION = \"193\"\n    COMPAREWITH203 = \"194\"\n    UNKNOWN_28 = \"195\"\n    IFWORLDCHRMANNULL = \"196\"\n    ENHANCE_THRUSTING_COUNTER_ATTACKS = \"197\"\n    CURE_BLIGHT_2 = \"198\"\n    APPLY_KILL_EFFECT = \"199\"\n    POWER_WITHIN_VFX = \"200\"\n    VOWOFSILENCEVISUAL = \"201\"\n    DRAGON_ROAR = \"202\"\n    COMPAREWITH194 = \"203\"\n    GREAT_MAGIC_SHIELD = \"204\"\n    HOLY_WEAPON_BUFF_VFX = \"205\"\n    UNKNOWN_29 = \"206\"\n    JAILER_HP_DRAIN = \"207\"\n    TRIGGER_ON_ENEMY_BACKSTAB = \"213\"\n    UNKNOWN_30 = \"221\"\n    ITEMBAN = \"222\"\n    UNKNOWN_31 = \"223\"\n    UNKNOWN_32 = \"224\"\n    DISABLEUSEATCOLISEUM = \"232\"\n    CALAMITY_RING = \"237\"\n    OIL = \"252\"\n    FIRE = \"253\"\n    UNKNOWN_33 = \"258\"\n    UNKNOWN_34 = \"259\"\n    FROSTBITE = \"260\"\n    REMOVE_EFFECT_IF_TORCH_IN_HAND = \"261\"\n    WORMRECOVERY_TORCH = \"262\"\n    SETCULTBOOL = \"264\"\n    FALL_DEATH_INVALID = \"266\"\n    AI_SIGHT_ADJUSTMENT = \"267\"\n    UNKNOWN_35 = \"269\"\n    UNKNOWN_36 = \"270\"\n    UNKNOWN_37 = \"271\"\n    UNKNOWN_38 = \"272\"\n    PLAYER_BEHAVIOR_ID_CHANGE = \"275\"\n    CURE_FROSTBITE = \"276\"\n    TRIGGER_GREAT_RUNE = \"277\"\n    DISABLESPELLEFFECT = \"278\"\n    WATCHDOGTRIGGERFORHOST = \"280\"\n    WETSYSTEMTRIGGER = \"281\"\n    NPC_CORRECTION_FOR_COOP = \"282\"\n    TEARS_OF_DENIAL_TRIGGER = \"283\"\n    HEAL_SPELL = \"284\"\n    UNKNOWN_39 = \"285\"\n    WEAK_MOVEMENT_SLOW = \"286\"\n    STRONG_MOVEMENT_SLOW = \"287\"\n    TRIGGER_ON_CRITICAL_HIT_HP = \"288\"\n    TRIGGER_ON_CRITICAL_HIT_FP = \"289\"\n    EXTEND_ROLL_INVINCIBILITY = \"290\"\n    GRANTS_ROLL_INVISIBILITY = \"291\"\n    REPAIR1 = \"292\"\n    CHANGE_DURABILITY = \"293\"\n    UNKNOWN_40 = \"294\"\n    UNKNOWN_41 = \"295\"\n    UNKNOWN_42 = \"296\"\n    NOT_IN_MULTIPLAYER_SESSION = \"297\"\n    TRIGGER_ON_PLAYER_BACKSTAB = \"298\"\n    ENEMIES_ATTACK_INVADERS = \"299\"\n    ENEMIES_ATTACK_INVADERS_2 = \"300\"\n    LAW_OF_REGRESSION = \"301\"\n    WARP_TO_GRACE_7 = \"302\"\n    CONDITIONAL_1 = \"303\"\n    CONDITIONAL_2 = \"304\"\n    CONDITIONAL_3 = \"305\"\n    CONDITIONAL_4 = \"306\"\n    CONDITIONAL_5 = \"307\"\n    CONDITIONAL_6 = \"308\"\n    CONDITIONAL_7 = \"309\"\n    CONDITIONAL_8 = \"310\"\n    CONDITIONAL_9 = \"311\"\n    UNKNOWN_43 = \"312\"\n    SEEK_GUIDANCE = \"313\"\n    ADD_GUARD_STABILITY = \"314\"\n    SCALE_ATTACK_POWER_WITH_EQUIP_LOAD = \"315\"\n    CALCCORRECTGRAPH_33 = \"316\"\n    REVOKE_ONLINE_PENALTY = \"317\"\n    DEAD_AGAIN = \"318\"\n    UNKNOWN_44 = \"319\"\n    UNKNOWN_45 = \"320\"\n    REVERSE_HOLLOWING = \"321\"\n    CHRASMSTYLE_HKS_LEFTHAND = \"322\"\n    CHRASMSTYLE_HKS_RIGHTHAND = \"323\"\n    UNKNOWN_46 = \"324\"\n    WET_ASPECT_PARAM = \"325\"\n    SWITCH_ANIMATION_GENDER = \"326\"\n    EMBER = \"327\"\n    CHANGE_DURABILITY_2 = \"328\"\n    GETESTUSCHARGE = \"329\"\n    ONLINE_CHECK_RESET_EVENT_FLAG_2100 = \"330\"\n    AIPARAM1 = \"331\"\n    AIPARAM_EFFECT16189 = \"332\"\n    SPELL_ENHANCE_PLUS_6_TO_ID = \"333\"\n    BULLET_BEHAVIOR_ID_CHANGE = \"334\"\n    TRIGGER_DURING_CRITICAL_HIT = \"335\"\n    SUMMON_TORRENT = \"336\"\n    UNKNOWN_47 = \"337\"\n    UNKNOWN_48 = \"338\"\n    RELOAD = \"339\"\n    UNKNOWN_49 = \"342\"\n    UNKNOWN_50 = \"343\"\n    UNKNOWN_51 = \"344\"\n    UNKNOWN_52 = \"345\"\n    UNKNOWN_53 = \"346\"\n    UNKNOWN_54 = \"347\"\n    UNKNOWN_55 = \"348\"\n    UNKNOWN_56 = \"349\"\n    UNKNOWN_57 = \"350\"\n    UNKNOWN_58 = \"351\"\n    UNKNOWN_59 = \"352\"\n    UNKNOWN_60 = \"353\"\n    UNKNOWN_61 = \"354\"\n    UNKNOWN_62 = \"355\"\n    UNKNOWN_63 = \"356\"\n    SPIRIT_SUMMON = \"357\"\n    UNKNOWN_64 = \"358\"\n    UNKNOWN_65 = \"359\"\n    UNKNOWN_66 = \"360\"\n    UNKNOWN_67 = \"361\"\n    UNKNOWN_68 = \"362\"\n    UNKNOWN_69 = \"363\"\n    UNKNOWN_70 = \"364\"\n    UNKNOWN_71 = \"365\"\n    UNKNOWN_72 = \"366\"\n    ENHANCE_CRITICAL_ATTACKS = \"367\"\n    UNKNOWN_73 = \"368\"\n    UNKNOWN_74 = \"369\"\n    UNKNOWN_75 = \"370\"\n    UNKNOWN_76 = \"371\"\n    UNKNOWN_77 = \"372\"\n    UNKNOWN_78 = \"373\"\n    UNKNOWN_79 = \"375\"\n    UNKNOWN_80 = \"376\"\n    UNKNOWN_81 = \"377\"\n    UNKNOWN_82 = \"378\"\n    TRIGGER_IN_PRESENCE_OF_BLOOD_LOSS = \"379\"\n    TRIGGER_IN_PRESENCE_OF_ROT = \"380\"\n    UNKNOWN_83 = \"381\"\n    UNKNOWN_84 = \"382\"\n    UNKNOWN_85 = \"383\"\n    UNKNOWN_86 = \"384\"\n    UNKNOWN_87 = \"385\"\n    UNKNOWN_88 = \"387\"\n    UNKNOWN_89 = \"388\"\n    UNKNOWN_90 = \"389\"\n    PACIFY_WILD_ANIMALS = \"390\"\n    UNKNOWN_91 = \"391\"\n    UNKNOWN_92 = \"392\"\n    UNKNOWN_93 = \"393\"\n    UNKNOWN_94 = \"394\"\n    UNKNOWN_95 = \"395\"\n    UNKNOWN_96 = \"396\"\n    UNKNOWN_97 = \"397\"\n    PULL_TOWARDS_CASTER = \"398\"\n    UNKNOWN_98 = \"399\"\n    UNKNOWN_99 = \"402\"\n    UNKNOWN_100 = \"403\"\n    UNKNOWN_101 = \"406\"\n    REVEAL_PHANTOM_SIGNS = \"405\"\n    REQUEST_FRIENDLY_PHANTOM = \"406\"\n    ANSWER_PHANTOM_REQUEST = \"407\"\n    ENCOURAGE_INVASION = \"408\"\n    SEND_SUMMON_SIGN_TO_POOL = \"409\"\n    SEND_INVASION_SIGN_TO_POOL = \"410\"\n    UNKNOWN_102 = \"411\"\n    UNKNOWN_103 = \"412\"\n    UNKNOWN_104 = \"413\"\n    UNKNOWN_105 = \"414\"\n    UNKNOWN_106 = \"415\"\n    UNKNOWN_107 = \"416\"\n    UNKNOWN_108 = \"417\"\n    UNKNOWN_109 = \"418\"\n    UNKNOWN_110 = \"419\"\n    UNKNOWN_111 = \"421\"\n    UNKNOWN_112 = \"422\"\n    UNKNOWN_113 = \"423\"\n    UNKNOWN_114 = \"424\"\n    UNKNOWN_115 = \"425\"\n    UNKNOWN_116 = \"426\"\n    UNKNOWN_117 = \"427\"\n    UNKNOWN_118 = \"428\"\n    UNKNOWN_119 = \"429\"\n    UNKNOWN_120 = \"430\"\n    UNKNOWN_121 = \"431\"\n    UNKNOWN_122 = \"432\"\n    UNKNOWN_123 = \"435\"\n    SLEEP = \"436\"\n    MADNESS = \"437\"\n    CURE_SLEEP = \"438\"\n    CURE_MADNESS = \"439\"\n    PURIFY_MOHGS_CURSE = \"440\"\n    MOHGS_GREAT_RUNE = \"441\"\n    UNKNOWN_124 = \"442\"\n    UNKNOWN_125 = \"443\"\n    UNKNOWN_126 = \"445\"\n    UNKNOWN_127 = \"446\"\n    PHANTOM_GREAT_RUNE = \"447\"\n    HEAL_INVADER_WHEN_BLESSED_ENEMY_KILLS_PLAYER = \"448\"\n    MALENIAS_GREAT_RUNE = \"449\"\n    REDUCE_HEADSHOT_IMPACT = \"450\"\n    RECOVERY_DAMAGE = \"452\"\n    UNKNOWN_128 = \"453\"\n    UNKNOWN_129 = \"454\"\n    UNKNOWN_130 = \"455\"\n    UNKNOWN_131 = \"456\"\n    UNKNOWN_132 = \"457\"\n    ATTEMPT_INVASION = \"458\"\n    UNKNOWN_133 = \"459\"\n    UNKNOWN_134 = \"460\"\n    UNKNOWN_135 = \"461\"\n    UNKNOWN_136 = \"462\"\n    UNKNOWN_137 = \"463\"\n    UNKNOWN_138 = \"465\"\n    TRIGGER_ON_CROUCH = \"466\"\n    BULLET_BEHAVIOR = \"467\"\n    UNKNOWN_139 = \"468\"\n    UNKNOWN_140 = \"469\"\n    SKIPSPCATEGORYCHECK1 = \"1000\"\n    SKIPSPCATEGORYCHECK2 = \"1001\"\n    CUSTOM_TRIGGER = \"9100\"\n    CUSTOM_TRIGGER_2 = \"9101\"\n    CUSTOM_TRIGGER_3 = \"9102\"\n    CUSTOM_TRIGGER_4 = \"9103\"\n    CUSTOM_TRIGGER_5 = \"9104\"\n    CUSTOM_TRIGGER_6 = \"9105\"\n    CUSTOM_TRIGGER_7 = \"9106\"\n    CUSTOM_TRIGGER_8 = \"9107\"\n    CUSTOM_TRIGGER_9 = \"9108\"\n    CUSTOM_TRIGGER_10 = \"9109\"\n    CUSTOM_TRIGGER_11 = \"9110\"\n    CUSTOM_TRIGGER_12 = \"9111\"\n    CUSTOM_TRIGGER_13 = \"9112\"\n    CUSTOM_TRIGGER_15 = \"9113\"\n    CUSTOM_TRIGGER_16 = \"9114\"\n    CUSTOM_TRIGGER_17 = \"9115\"\n    CUSTOM_TRIGGER_18 = \"9116\"\n    CUSTOM_TRIGGER_19 = \"9117\"\n    CUSTOM_TRIGGER_20 = \"9118\"\n    CUSTOM_TRIGGER_21 = \"9119\"\n    CUSTOM_TRIGGER_22 = \"9120\"\n    CUSTOM_TRIGGER_23 = \"9121\"\n    CUSTOM_TRIGGER_24 = \"9122\"\n    CUSTOM_TRIGGER_25 = \"9123\"\n    CUSTOM_TRIGGER_26 = \"9124\"\n    CUSTOM_TRIGGER_27 = \"9125\"\n    CUSTOM_TRIGGER_28 = \"9126\"\n    CUSTOM_TRIGGER_29 = \"9127\"\n    CUSTOM_TRIGGER_30 = \"9128\"\n    CUSTOM_TRIGGER_31 = \"9129\"\n    CUSTOM_TRIGGER_32 = \"9130\"\n\n    def __str__(self) -> str:\n        return _SP_EFFECT_TYPE_STR[self]\n\n    def is_passive(self) -> bool:\n        \"\"\"\n        Some stateInfo effect types act as trigger condtions for effects, others specify whether the effect\n        is passive. This list can be used to check whether this type is used as a condtion.\n        NOTE: This list is likely incomplete.\n        \"\"\"\n        return self in [\n            self.NONE, self.BOW_DISTANCE_CHANGE, self.INCREASE_DEFENSE, self.INCREASE_DAMAGE,\n            self.MODIFY_ENEMY_LISTEN_REDUCTION, self.EXTEND_ROLL_INVINCIBILITY, self.MODIFY_RUNE_GAIN,\n            self.MODIFY_ITEM_DISCOVERY, self.GREEN_BLOSSOM_VFX, self.MODIFY_EFFECT_DURATION,\n            self.CONDITIONAL_1, self.CONDITIONAL_2, self.CONDITIONAL_3, self.CONDITIONAL_4,\n            self.CONDITIONAL_5, self.CONDITIONAL_6, self.CONDITIONAL_7, self.CONDITIONAL_8,\n            self.CONDITIONAL_9,\n        ]\n\n_SP_EFFECT_TYPE_STR: dict[SpEffectType, str] = {\n    SpEffectType.NONE: \"None\",\n    SpEffectType.POISON: \"Poison\",\n    SpEffectType.UNKNOWN: \"Unknown\",\n    SpEffectType.DURABILITY_DAMAGE: \"Durability Damage\",\n    SpEffectType.SCARLET_ROT: \"Scarlet Rot\",\n    SpEffectType.HEMORRHAGE: \"Hemorrhage\",\n    SpEffectType.GHOST: \"Ghost\",\n    SpEffectType.ENEMY_SIGHT_REDUCTION: \"Enemy Sight Reduction\",\n    SpEffectType.TRANQUIL_WALK_OF_PEACE: \"Tranquil Walk of Peace\",\n    SpEffectType.REMOVE_POISON: \"Remove Poison\",\n    SpEffectType.REMOVE_SCARLET_ROT: \"Remove Scarlet Rot\",\n    SpEffectType.REMOVE_HEMORRHAGE: \"Remove Hemorrhage\",\n    SpEffectType.REMOVE_ALL_STATUS: \"Remove All Status\",\n    SpEffectType.HUMANITY_STOLEN: \"Humanity Stolen\",\n    SpEffectType.TELESCOPE: \"Telescope\",\n    SpEffectType.WARP_TO_GRACE: \"Warp to Grace\",\n    SpEffectType.REVIVAL: \"Revival\",\n    SpEffectType.DISPEL_BLACK_PHANTOM: \"Dispel Black Phantom\",\n    SpEffectType.UNKNOWN_2: \"Unknown\",\n    SpEffectType.ONREVIVEMAGIC: \"OnReviveMagic\",\n    SpEffectType.DISABLES_SPELL_USAGE: \"Disables Spell Usage\",\n    SpEffectType.RIGHT_HAND_BUFF_VFX: \"Right-hand Buff VFX\",\n    SpEffectType.BODY_BUFF_VFX: \"Body Buff VFX\",\n    SpEffectType.GHOST_PARAMETER_CHANGE: \"Ghost Parameter Change\",\n    SpEffectType.MIDDLE_OF_PARALYSIS: \"Middle of Paralysis\",\n    SpEffectType.GIANT_SLIME_FREEZING: \"Giant Slime Freezing\",\n    SpEffectType.UNKNOWN_3: \"Unknown\",\n    SpEffectType.UNKNOWN_4: \"Unknown\",\n    SpEffectType.UNKNOWN_5: \"Unknown\",\n    SpEffectType.SOUND_FEED: \"Sound Feed\",\n    SpEffectType.GREATER_BODY_BUFF_VFX: \"Greater Body Buff VFX\",\n    SpEffectType.FLASH_SWEAT: \"Flash Sweat\",\n    SpEffectType.HP_RECOVERY: \"HP Recovery\",\n    SpEffectType.UNKNOWN_6: \"Unknown\",\n    SpEffectType.UNKNOWN_7: \"Unknown\",\n    SpEffectType.UNKNOWN_8: \"Unknown\",\n    SpEffectType.MODIFY_TARGET_PRIORITY: \"Modify Target Priority\",\n    SpEffectType.DISABLE_FALL_DAMAGE: \"Disable Fall Damage\",\n    SpEffectType.INCREASE_DAMAGE: \"Increase Damage\",\n    SpEffectType.INCREASE_DEFENSE: \"Increase Defense\",\n    SpEffectType.HP_FP_STAMINA_RECOVERY: \"HP/FP/Stamina Recovery\",\n    SpEffectType.PLEDGE_EFFECT_TEST: \"Pledge Effect Test\",\n    SpEffectType.MODIFY_ENEMY_LISTEN_REDUCTION: \"Modify Enemy Listen Reduction\",\n    SpEffectType.HOSTDEATH: \"HostDeath\",\n    SpEffectType.POINT_LIGHT_SOURCE_EQUIPPED: \"Point Light Source Equipped\",\n    SpEffectType.YOUR_MESSAGE_WAS_RATED: \"Your Message Was Rated\",\n    SpEffectType.MAGIC_BUFF_VFX: \"Magic Buff VFX\",\n    SpEffectType.MAGIC_WEAPON_BUFF_VFX: \"Magic Weapon Buff VFX\",\n    SpEffectType.FIRE_WEAPON_BUFF_VFX: \"Fire Weapon Buff VFX\",\n    SpEffectType.ENCHANTED_WEAPON_BUFF_VFX: \"Enchanted Weapon Buff VFX\",\n    SpEffectType.UNKNOWN_9: \"Unknown\",\n    SpEffectType.MODIFY_ITEM_DISCOVERY: \"Modify Item Discovery\",\n    SpEffectType.TEARS_OF_DENIAL_VFX: \"Tears of Denial VFX\",\n    SpEffectType.IS_DEAD_TEST_CONDITION: \"Is Dead Test Condition\",\n    SpEffectType.SPELL_POWER_BOOST: \"Spell Power Boost\",\n    SpEffectType.GREEN_BLOSSOM_VFX: \"Green Blossom VFX\",\n    SpEffectType.MODIFY_RUNE_GAIN: \"Modify Rune Gain\",\n    SpEffectType.UNKNOWN_10: \"Unknown\",\n    SpEffectType.UNKNOWN_11: \"Unknown\",\n    SpEffectType.UNKNOWN_12: \"Unknown\",\n    SpEffectType.APPLIES_CHAMELON_EFFECT: \"Applies Chamelon effect\",\n    SpEffectType.APPLIES_DRAGON_FORM_EFFECT: \"Applies Dragon Form effect\",\n    SpEffectType.MP_DETECTION: \"MP Detection\",\n    SpEffectType.MP_WAIT_FOR_COOPERATION: \"MP Wait for Cooperation\",\n    SpEffectType.MP_COOPERATION: \"MP Cooperation\",\n    SpEffectType.MP_COOPERATION_SENT: \"MP Cooperation Sent\",\n    SpEffectType.WAX_SLOW_DOWN: \"Wax Slow Down\",\n    SpEffectType.USED_FOR_EVIL_EYE_EFFECT: \"Used for Evil Eye effect\",\n    SpEffectType.MP_WAIT_FOR_COOPERATION_2: \"MP Wait for Cooperation\",\n    SpEffectType.MP_COOPERATION_LV_1: \"MP Cooperation LV 1\",\n    SpEffectType.MP_COOPERATION_LV_2: \"MP Cooperation LV 2\",\n    SpEffectType.MP_COOPERATION_LV_3: \"MP Cooperation LV 3\",\n    SpEffectType.USED_FOR_EVIL_EYE_EFFECT_1: \"Used for Evil Eye effect (1)\",\n    SpEffectType.USED_FOR_EVIL_EYE_EFFECT_2: \"Used for Evil Eye effect (2)\",\n    SpEffectType.COUNTER_DAMAGE: \"Counter Damage\",\n    SpEffectType._1409F7282_HKS: \"1409F7282_HKS\",\n    SpEffectType.UNKNOWN_13: \"Unknown\",\n    SpEffectType.UNKNOWN_14: \"Unknown\",\n    SpEffectType.BACKSTEP_ANIMATION_CHANGE: \"Backstep Animation Change\",\n    SpEffectType.BLIGHT: \"Blight\",\n    SpEffectType.INSTANT_DEATH_ANIMATION: \"Instant Death animation\",\n    SpEffectType.CURE_BLIGHT: \"Cure Blight\",\n    SpEffectType.UNKNOWN_15: \"Unknown\",\n    SpEffectType.DAMAGE_LEVEL_CHANGE_BEFORE_POISE_BREAK: \"Damage Level Change before Poise Break\",\n    SpEffectType.DAMAGE_LEVEL_CHANGE: \"Damage Level Change\",\n    SpEffectType.UNKNOWN_16: \"Unknown\",\n    SpEffectType.TRIGGER_ON_ROLL_HEAD: \"Trigger on Roll (Head)\",\n    SpEffectType.TRIGGER_ON_ROLL_BODY: \"Trigger on Roll (Body)\",\n    SpEffectType.TRIGGER_ON_ROLL_HANDS: \"Trigger on Roll (Hands)\",\n    SpEffectType.TRIGGER_ON_ROLL_LEGS: \"Trigger on Roll (Legs)\",\n    SpEffectType.MIMIC_SLEEP: \"Mimic Sleep\",\n    SpEffectType.MIMIC_SLEEP_2: \"Mimic Sleep\",\n    SpEffectType.MIMIC_SLEEP_3: \"Mimic Sleep\",\n    SpEffectType.MIMIC_SLEEP_4: \"Mimic Sleep\",\n    SpEffectType.CHANGE_TEAM_TYPE: \"Change Team Type\",\n    SpEffectType.ENABLE_DEVELOPER_MESSAGES: \"Enable Developer Messages\",\n    SpEffectType.IRON_FLESH: \"Iron Flesh\",\n    SpEffectType.MIMIC_SLEEP_5: \"Mimic Sleep\",\n    SpEffectType.BLIGHT_2: \"Blight\",\n    SpEffectType.RESONANCELVL_0: \"ResonanceLvl 0\",\n    SpEffectType.RESONANCELVL_1: \"ResonanceLvl 1\",\n    SpEffectType.RESONANCELVL_2: \"ResonanceLvl 2\",\n    SpEffectType.RESONANCELVL_3: \"ResonanceLvl 3\",\n    SpEffectType.RESONANCELVL_4: \"ResonanceLvl 4\",\n    SpEffectType.NPC_BEHAVIOR_ID_CHANGE: \"NPC Behavior ID Change\",\n    SpEffectType.CHARACTER_RESPAWN: \"Character Respawn\",\n    SpEffectType.UNKNOWN_17: \"Unknown\",\n    SpEffectType.HOLY: \"Holy\",\n    SpEffectType.RESTORE_DURABILITY: \"Restore Durability\",\n    SpEffectType.CAST_LIGHT: \"Cast Light\",\n    SpEffectType.UNKNOWN_18: \"Unknown\",\n    SpEffectType.WHITE_RELIEF_MAGIC: \"White Relief Magic\",\n    SpEffectType.BLACK_RELIEF_MAGIC: \"Black Relief Magic\",\n    SpEffectType.LIGHTNING_WEAPON_BUFF_VFX: \"Lightning Weapon Buff VFX\",\n    SpEffectType.ENABLE_ATTACK_EFFECT_AGAINST_ENEMY: \"Enable Attack Effect against Enemy\",\n    SpEffectType.ENABLE_ATTACK_EFFECT_AGAINST_PLAYER: \"Enable Attack Effect against Player\",\n    SpEffectType.BLOCK_ESTUS_USAGE: \"Block Estus usage\",\n    SpEffectType.MODIFY_POISE: \"Modify Poise\",\n    SpEffectType.DISABLE_DURABILITY: \"Disable Durability\",\n    SpEffectType.TRANSIENT_CURSE: \"Transient Curse\",\n    SpEffectType.LEFT_HAND_BUFF_VFX: \"Left-hand Buff VFX\",\n    SpEffectType.DESTROY_ACCESSORY_BUT_SAVE_RUNES: \"Destroy Accessory but Save Runes\",\n    SpEffectType.RARE_RING_OF_SACRIFICE_DS1: \"Rare Ring of Sacrifice [DS1]\",\n    SpEffectType.WARP_TO_GRACE_2: \"Warp to Grace\",\n    SpEffectType.WARP_TO_GRACE_3: \"Warp to Grace\",\n    SpEffectType.WARP_TO_GRACE_4: \"Warp to Grace\",\n    SpEffectType.WARP_TO_GRACE_5: \"Warp to Grace\",\n    SpEffectType.WARP_TO_GRACE_6: \"Warp to Grace\",\n    SpEffectType.PLEDGE_DISCARDED: \"Pledge Discarded\",\n    SpEffectType.DRAGON_CHANGE_VFX: \"Dragon Change VFX\",\n    SpEffectType.BOW_DISTANCE_CHANGE: \"Bow Distance Change\",\n    SpEffectType.UNKNOWN_19: \"Unknown\",\n    SpEffectType.KARMIC_JUSTICE_COUNTER: \"Karmic Justice Counter\",\n    SpEffectType.USED_FOR_BEHAVIOR_CHANGE: \"Used for Behavior Change\",\n    SpEffectType.RITUAL: \"Ritual\",\n    SpEffectType.POWER_OF_EVIL_SPIRITS: \"Power of Evil Spirits\",\n    SpEffectType.REVIVAL_PRODUCTION: \"Revival Production\",\n    SpEffectType.AURAL_DECOY: \"Aural Decoy\",\n    SpEffectType.UNKNOWN_20: \"Unknown\",\n    SpEffectType.DEATHEFFECTLV1: \"DeathEffectLv1\",\n    SpEffectType.DEATHEFFECTLV2: \"DeathEffectLv2\",\n    SpEffectType.DEATHEFFECTLV3: \"DeathEffectLv3\",\n    SpEffectType.DEATHEFFECTLV4: \"DeathEffectLv4\",\n    SpEffectType.BLUESIGNVISUALIZATION: \"BlueSignVisualization\",\n    SpEffectType.HIDE_WEAPON: \"Hide Weapon\",\n    SpEffectType.UNKNOWN_21: \"Unknown\",\n    SpEffectType.UNKNOWN_22: \"Unknown\",\n    SpEffectType.UNKNOWN_23: \"Unknown\",\n    SpEffectType.UNKNOWN_24: \"Unknown\",\n    SpEffectType.UNKNOWN_25: \"Unknown\",\n    SpEffectType.UNKNOWN_26: \"Unknown\",\n    SpEffectType.UNKNOWN_27: \"Unknown\",\n    SpEffectType.MODIFY_EFFECT_DURATION: \"Modify Effect Duration\",\n    SpEffectType.COMPAREWITH203: \"CompareWith203\",\n    SpEffectType.UNKNOWN_28: \"Unknown\",\n    SpEffectType.IFWORLDCHRMANNULL: \"IfWorldChrManNull\",\n    SpEffectType.ENHANCE_THRUSTING_COUNTER_ATTACKS: \"Enhance Thrusting Counter Attacks\",\n    SpEffectType.CURE_BLIGHT_2: \"Cure Blight\",\n    SpEffectType.APPLY_KILL_EFFECT: \"Apply Kill Effect\",\n    SpEffectType.POWER_WITHIN_VFX: \"Power Within VFX\",\n    SpEffectType.VOWOFSILENCEVISUAL: \"VowOfSilenceVisual\",\n    SpEffectType.DRAGON_ROAR: \"Dragon Roar\",\n    SpEffectType.COMPAREWITH194: \"CompareWith194\",\n    SpEffectType.GREAT_MAGIC_SHIELD: \"Great Magic Shield\",\n    SpEffectType.HOLY_WEAPON_BUFF_VFX: \"Holy Weapon Buff VFX\",\n    SpEffectType.UNKNOWN_29: \"Unknown\",\n    SpEffectType.JAILER_HP_DRAIN: \"Jailer HP Drain\",\n    SpEffectType.TRIGGER_ON_ENEMY_BACKSTAB: \"Trigger on Enemy Backstab\",\n    SpEffectType.UNKNOWN_30: \"Unknown\",\n    SpEffectType.ITEMBAN: \"ItemBan\",\n    SpEffectType.UNKNOWN_31: \"Unknown\",\n    SpEffectType.UNKNOWN_32: \"Unknown\",\n    SpEffectType.DISABLEUSEATCOLISEUM: \"DisableUseAtColiseum\",\n    SpEffectType.CALAMITY_RING: \"Calamity Ring\",\n    SpEffectType.OIL: \"Oil\",\n    SpEffectType.FIRE: \"Fire\",\n    SpEffectType.UNKNOWN_33: \"Unknown\",\n    SpEffectType.UNKNOWN_34: \"Unknown\",\n    SpEffectType.FROSTBITE: \"Frostbite\",\n    SpEffectType.REMOVE_EFFECT_IF_TORCH_IN_HAND: \"Remove Effect If Torch In Hand\",\n    SpEffectType.WORMRECOVERY_TORCH: \"WormRecovery(Torch)\",\n    SpEffectType.SETCULTBOOL: \"SetCultBool\",\n    SpEffectType.FALL_DEATH_INVALID: \"Fall Death Invalid\",\n    SpEffectType.AI_SIGHT_ADJUSTMENT: \"AI Sight Adjustment\",\n    SpEffectType.UNKNOWN_35: \"Unknown\",\n    SpEffectType.UNKNOWN_36: \"Unknown\",\n    SpEffectType.UNKNOWN_37: \"Unknown\",\n    SpEffectType.UNKNOWN_38: \"Unknown\",\n    SpEffectType.PLAYER_BEHAVIOR_ID_CHANGE: \"Player Behavior ID Change\",\n    SpEffectType.CURE_FROSTBITE: \"Cure Frostbite\",\n    SpEffectType.TRIGGER_GREAT_RUNE: \"Trigger Great Rune\",\n    SpEffectType.DISABLESPELLEFFECT: \"DisableSpellEffect\",\n    SpEffectType.WATCHDOGTRIGGERFORHOST: \"WatchdogTriggerForHost\",\n    SpEffectType.WETSYSTEMTRIGGER: \"WetSystemTrigger\",\n    SpEffectType.NPC_CORRECTION_FOR_COOP: \"NPC Correction for Coop\",\n    SpEffectType.TEARS_OF_DENIAL_TRIGGER: \"Tears of Denial Trigger\",\n    SpEffectType.HEAL_SPELL: \"Heal Spell\",\n    SpEffectType.UNKNOWN_39: \"Unknown\",\n    SpEffectType.WEAK_MOVEMENT_SLOW: \"Weak Movement Slow\",\n    SpEffectType.STRONG_MOVEMENT_SLOW: \"Strong Movement Slow\",\n    SpEffectType.TRIGGER_ON_CRITICAL_HIT_HP: \"Trigger on Critical Hit (HP)\",\n    SpEffectType.TRIGGER_ON_CRITICAL_HIT_FP: \"Trigger on Critical Hit (FP)\",\n    SpEffectType.EXTEND_ROLL_INVINCIBILITY: \"Extend Roll Invincibility\",\n    SpEffectType.GRANTS_ROLL_INVISIBILITY: \"Grants roll invisibility\",\n    SpEffectType.REPAIR1: \"Repair1\",\n    SpEffectType.CHANGE_DURABILITY: \"Change Durability\",\n    SpEffectType.UNKNOWN_40: \"Unknown\",\n    SpEffectType.UNKNOWN_41: \"Unknown\",\n    SpEffectType.UNKNOWN_42: \"Unknown\",\n    SpEffectType.NOT_IN_MULTIPLAYER_SESSION: \"Not in Multiplayer Session\",\n    SpEffectType.TRIGGER_ON_PLAYER_BACKSTAB: \"Trigger on Player Backstab\",\n    SpEffectType.ENEMIES_ATTACK_INVADERS: \"Enemies attack Invaders\",\n    SpEffectType.ENEMIES_ATTACK_INVADERS_2: \"Enemies attack Invaders\",\n    SpEffectType.LAW_OF_REGRESSION: \"Law of Regression\",\n    SpEffectType.WARP_TO_GRACE_7: \"Warp to Grace\",\n    SpEffectType.CONDITIONAL_1: \"Conditional 1\",\n    SpEffectType.CONDITIONAL_2: \"Conditional 2\",\n    SpEffectType.CONDITIONAL_3: \"Conditional 3\",\n    SpEffectType.CONDITIONAL_4: \"Conditional 4\",\n    SpEffectType.CONDITIONAL_5: \"Conditional 5\",\n    SpEffectType.CONDITIONAL_6: \"Conditional 6\",\n    SpEffectType.CONDITIONAL_7: \"Conditional 7\",\n    SpEffectType.CONDITIONAL_8: \"Conditional 8\",\n    SpEffectType.CONDITIONAL_9: \"Conditional 9\",\n    SpEffectType.UNKNOWN_43: \"Unknown\",\n    SpEffectType.SEEK_GUIDANCE: \"Seek Guidance\",\n    SpEffectType.ADD_GUARD_STABILITY: \"Add Guard Stability\",\n    SpEffectType.SCALE_ATTACK_POWER_WITH_EQUIP_LOAD: \"Scale Attack Power with Equip Load\",\n    SpEffectType.CALCCORRECTGRAPH_33: \"CalcCorrectGraph_33\",\n    SpEffectType.REVOKE_ONLINE_PENALTY: \"Revoke Online Penalty\",\n    SpEffectType.DEAD_AGAIN: \"Dead Again\",\n    SpEffectType.UNKNOWN_44: \"Unknown\",\n    SpEffectType.UNKNOWN_45: \"Unknown\",\n    SpEffectType.REVERSE_HOLLOWING: \"Reverse Hollowing\",\n    SpEffectType.CHRASMSTYLE_HKS_LEFTHAND: \"ChrAsmStyle_HKS_LEFTHAND\",\n    SpEffectType.CHRASMSTYLE_HKS_RIGHTHAND: \"ChrAsmStyle_HKS_RIGHTHAND\",\n    SpEffectType.UNKNOWN_46: \"Unknown\",\n    SpEffectType.WET_ASPECT_PARAM: \"Wet Aspect Param\",\n    SpEffectType.SWITCH_ANIMATION_GENDER: \"Switch Animation Gender\",\n    SpEffectType.EMBER: \"Ember\",\n    SpEffectType.CHANGE_DURABILITY_2: \"Change Durability\",\n    SpEffectType.GETESTUSCHARGE: \"GetEstusCharge\",\n    SpEffectType.ONLINE_CHECK_RESET_EVENT_FLAG_2100: \"Online Check Reset Event Flag 2100\",\n    SpEffectType.AIPARAM1: \"AiParam1\",\n    SpEffectType.AIPARAM_EFFECT16189: \"AiParam_effect16189\",\n    SpEffectType.SPELL_ENHANCE_PLUS_6_TO_ID: \"Spell Enhance (+6 to ID)\",\n    SpEffectType.BULLET_BEHAVIOR_ID_CHANGE: \"Bullet Behavior ID Change\",\n    SpEffectType.TRIGGER_DURING_CRITICAL_HIT: \"Trigger during Critical Hit\",\n    SpEffectType.SUMMON_TORRENT: \"Summon Torrent\",\n    SpEffectType.UNKNOWN_47: \"Unknown\",\n    SpEffectType.UNKNOWN_48: \"Unknown\",\n    SpEffectType.RELOAD: \"Reload\",\n    SpEffectType.UNKNOWN_49: \"Unknown\",\n    SpEffectType.UNKNOWN_50: \"Unknown\",\n    SpEffectType.UNKNOWN_51: \"Unknown\",\n    SpEffectType.UNKNOWN_52: \"Unknown\",\n    SpEffectType.UNKNOWN_53: \"Unknown\",\n    SpEffectType.UNKNOWN_54: \"Unknown\",\n    SpEffectType.UNKNOWN_55: \"Unknown\",\n    SpEffectType.UNKNOWN_56: \"Unknown\",\n    SpEffectType.UNKNOWN_57: \"Unknown\",\n    SpEffectType.UNKNOWN_58: \"Unknown\",\n    SpEffectType.UNKNOWN_59: \"Unknown\",\n    SpEffectType.UNKNOWN_60: \"Unknown\",\n    SpEffectType.UNKNOWN_61: \"Unknown\",\n    SpEffectType.UNKNOWN_62: \"Unknown\",\n    SpEffectType.UNKNOWN_63: \"Unknown\",\n    SpEffectType.SPIRIT_SUMMON: \"Spirit Summon\",\n    SpEffectType.UNKNOWN_64: \"Unknown\",\n    SpEffectType.UNKNOWN_65: \"Unknown\",\n    SpEffectType.UNKNOWN_66: \"Unknown\",\n    SpEffectType.UNKNOWN_67: \"Unknown\",\n    SpEffectType.UNKNOWN_68: \"Unknown\",\n    SpEffectType.UNKNOWN_69: \"Unknown\",\n    SpEffectType.UNKNOWN_70: \"Unknown\",\n    SpEffectType.UNKNOWN_71: \"Unknown\",\n    SpEffectType.UNKNOWN_72: \"Unknown\",\n    SpEffectType.ENHANCE_CRITICAL_ATTACKS: \"Enhance Critical Attacks\",\n    SpEffectType.UNKNOWN_73: \"Unknown\",\n    SpEffectType.UNKNOWN_74: \"Unknown\",\n    SpEffectType.UNKNOWN_75: \"Unknown\",\n    SpEffectType.UNKNOWN_76: \"Unknown\",\n    SpEffectType.UNKNOWN_77: \"Unknown\",\n    SpEffectType.UNKNOWN_78: \"Unknown\",\n    SpEffectType.UNKNOWN_79: \"Unknown\",\n    SpEffectType.UNKNOWN_80: \"Unknown\",\n    SpEffectType.UNKNOWN_81: \"Unknown\",\n    SpEffectType.UNKNOWN_82: \"Unknown\",\n    SpEffectType.TRIGGER_IN_PRESENCE_OF_BLOOD_LOSS: \"Trigger in Presence of Blood Loss\",\n    SpEffectType.TRIGGER_IN_PRESENCE_OF_ROT: \"Trigger in Presence of Rot\",\n    SpEffectType.UNKNOWN_83: \"Unknown\",\n    SpEffectType.UNKNOWN_84: \"Unknown\",\n    SpEffectType.UNKNOWN_85: \"Unknown\",\n    SpEffectType.UNKNOWN_86: \"Unknown\",\n    SpEffectType.UNKNOWN_87: \"Unknown\",\n    SpEffectType.UNKNOWN_88: \"Unknown\",\n    SpEffectType.UNKNOWN_89: \"Unknown\",\n    SpEffectType.UNKNOWN_90: \"Unknown\",\n    SpEffectType.PACIFY_WILD_ANIMALS: \"Pacify Wild Animals\",\n    SpEffectType.UNKNOWN_91: \"Unknown\",\n    SpEffectType.UNKNOWN_92: \"Unknown\",\n    SpEffectType.UNKNOWN_93: \"Unknown\",\n    SpEffectType.UNKNOWN_94: \"Unknown\",\n    SpEffectType.UNKNOWN_95: \"Unknown\",\n    SpEffectType.UNKNOWN_96: \"Unknown\",\n    SpEffectType.UNKNOWN_97: \"Unknown\",\n    SpEffectType.PULL_TOWARDS_CASTER: \"Pull towards Caster\",\n    SpEffectType.UNKNOWN_98: \"Unknown\",\n    SpEffectType.UNKNOWN_99: \"Unknown\",\n    SpEffectType.UNKNOWN_100: \"Unknown\",\n    SpEffectType.UNKNOWN_101: \"Unknown\",\n    SpEffectType.REVEAL_PHANTOM_SIGNS: \"Reveal Phantom Signs\",\n    SpEffectType.REQUEST_FRIENDLY_PHANTOM: \"Request Friendly Phantom\",\n    SpEffectType.ANSWER_PHANTOM_REQUEST: \"Answer Phantom Request\",\n    SpEffectType.ENCOURAGE_INVASION: \"Encourage Invasion\",\n    SpEffectType.SEND_SUMMON_SIGN_TO_POOL: \"Send Summon Sign to Pool\",\n    SpEffectType.SEND_INVASION_SIGN_TO_POOL: \"Send Invasion Sign to Pool\",\n    SpEffectType.UNKNOWN_102: \"Unknown\",\n    SpEffectType.UNKNOWN_103: \"Unknown\",\n    SpEffectType.UNKNOWN_104: \"Unknown\",\n    SpEffectType.UNKNOWN_105: \"Unknown\",\n    SpEffectType.UNKNOWN_106: \"Unknown\",\n    SpEffectType.UNKNOWN_107: \"Unknown\",\n    SpEffectType.UNKNOWN_108: \"Unknown\",\n    SpEffectType.UNKNOWN_109: \"Unknown\",\n    SpEffectType.UNKNOWN_110: \"Unknown\",\n    SpEffectType.UNKNOWN_111: \"Unknown\",\n    SpEffectType.UNKNOWN_112: \"Unknown\",\n    SpEffectType.UNKNOWN_113: \"Unknown\",\n    SpEffectType.UNKNOWN_114: \"Unknown\",\n    SpEffectType.UNKNOWN_115: \"Unknown\",\n    SpEffectType.UNKNOWN_116: \"Unknown\",\n    SpEffectType.UNKNOWN_117: \"Unknown\",\n    SpEffectType.UNKNOWN_118: \"Unknown\",\n    SpEffectType.UNKNOWN_119: \"Unknown\",\n    SpEffectType.UNKNOWN_120: \"Unknown\",\n    SpEffectType.UNKNOWN_121: \"Unknown\",\n    SpEffectType.UNKNOWN_122: \"Unknown\",\n    SpEffectType.UNKNOWN_123: \"Unknown\",\n    SpEffectType.SLEEP: \"Sleep\",\n    SpEffectType.MADNESS: \"Madness\",\n    SpEffectType.CURE_SLEEP: \"Cure Sleep\",\n    SpEffectType.CURE_MADNESS: \"Cure Madness\",\n    SpEffectType.PURIFY_MOHGS_CURSE: \"Purify Mohg's Curse\",\n    SpEffectType.MOHGS_GREAT_RUNE: \"Mohg's Great Rune\",\n    SpEffectType.UNKNOWN_124: \"Unknown\",\n    SpEffectType.UNKNOWN_125: \"Unknown\",\n    SpEffectType.UNKNOWN_126: \"Unknown\",\n    SpEffectType.UNKNOWN_127: \"Unknown\",\n    SpEffectType.PHANTOM_GREAT_RUNE: \"Phantom Great Rune\",\n    SpEffectType.HEAL_INVADER_WHEN_BLESSED_ENEMY_KILLS_PLAYER: \"Heal Invader when Blessed Enemy Kills Player\",\n    SpEffectType.MALENIAS_GREAT_RUNE: \"Malenia's Great Rune\",\n    SpEffectType.REDUCE_HEADSHOT_IMPACT: \"Reduce Headshot Impact\",\n    SpEffectType.RECOVERY_DAMAGE: \"Recovery Damage\",\n    SpEffectType.UNKNOWN_128: \"Unknown\",\n    SpEffectType.UNKNOWN_129: \"Unknown\",\n    SpEffectType.UNKNOWN_130: \"Unknown\",\n    SpEffectType.UNKNOWN_131: \"Unknown\",\n    SpEffectType.UNKNOWN_132: \"Unknown\",\n    SpEffectType.ATTEMPT_INVASION: \"Attempt Invasion\",\n    SpEffectType.UNKNOWN_133: \"Unknown\",\n    SpEffectType.UNKNOWN_134: \"Unknown\",\n    SpEffectType.UNKNOWN_135: \"Unknown\",\n    SpEffectType.UNKNOWN_136: \"Unknown\",\n    SpEffectType.UNKNOWN_137: \"Unknown\",\n    SpEffectType.UNKNOWN_138: \"Unknown\",\n    SpEffectType.TRIGGER_ON_CROUCH: \"Trigger on Crouch\",\n    SpEffectType.BULLET_BEHAVIOR: \"Bullet Behavior\",\n    SpEffectType.UNKNOWN_139: \"Unknown\",\n    SpEffectType.UNKNOWN_140: \"Unknown\",\n    SpEffectType.SKIPSPCATEGORYCHECK1: \"SkipSpCategoryCheck1\",\n    SpEffectType.SKIPSPCATEGORYCHECK2: \"SkipSpCategoryCheck2\",\n    SpEffectType.CUSTOM_TRIGGER: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_2: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_3: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_4: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_5: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_6: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_7: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_8: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_9: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_10: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_11: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_12: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_13: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_15: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_16: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_17: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_18: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_19: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_20: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_21: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_22: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_23: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_24: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_25: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_26: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_27: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_28: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_29: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_30: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_31: \"Custom Trigger\",\n    SpEffectType.CUSTOM_TRIGGER_32: \"Custom Trigger\",\n}\n\nclass Region(str, Enum):\n    ROUNDTABLE_HOLD = \"Roundtable Hold\"\n    LIMGRAVE = \"Limgrave\"\n    WEEPING_PENINSULA = \"Weeping Peninsula\"\n    LIURNIA_OF_THE_LAKES = \"Liurnia of the Lakes\"\n    CAELID = \"Caelid\"\n    ALTUS_PLATEAU = \"Altus Plateau\"\n    MT_GELMIR = \"Mt. Gelmir\"\n    DRAGONBARROW = \"Dragonbarrow\"\n    MOUNTAINTOPS_OF_THE_GIANTS = \"Mountaintops of the Giants\"\n    CONSECRATED_SNOWFIELD = \"Consecrated Snowfield\"\n    SIOFRA_RIVER = \"Siofra River\"\n    AINSEL_RIVER = \"Ainsel River\"\n    DEEPROOT_DEPTHS = \"Deeproot Depths\"\n    LAKE_OF_ROT = \"Lake of Rot\"\n\n# TODO: find out specific names (remove (1), (2), etc...)\nclass Location(str, Enum):\n    STORMVEIL_CASTLE = \"Stormveil Castle\"\n    LEYNDELL_ROYAL_CAPITAL = \"Leyndell, Royal Capital\"\n    CRUMBLING_FARUM_AZULA = \"Crumbling Farum Azula\"\n    ACADEMY_OF_RAYA_LUCARIA = \"Academy of Raya Lucaria\"\n    MIQUELLAS_HALIGTREE = \"Miquella's Haligtree\"\n    ELPHAEL_BRACE_OF_THE_HALIGTREE = \"Elphael, Brace of the Haligtree\"\n    VOLCANO_MANOR = \"Volcano Manor\"\n    STRANDED_GRAVEYARD = \"Stranded Graveyard\"\n    FRINGEFOLK_HEROS_GRAVE = \"Fringefolk Hero's Grave\"\n    TOMBSWARD_CATACOMBS = \"Tombsward Catacombs\"\n    IMPALERS_CATACOMBS = \"Impaler's Catacombs\"\n    STORMFOOT_CATACOMBS = \"Stormfoot Catacombs\"\n    ROADS_END_CATACOMBS = \"Road's End Catacombs\"\n    MURKWATER_CATACOMBS = \"Murkwater Catacombs\"\n    BLACK_KNIFE_CATACOMBS = \"Black Knife Catacombs\"\n    CLIFFBOTTOM_CATACOMBS = \"Cliffbottom Catacombs\"\n    WYNDHAM_CATACOMBS = \"Wyndham Catacombs\"\n    SAINTED_HEROS_GRAVE = \"Sainted Hero's Grave\"\n    GELMIR_HEROS_GRAVE = \"Gelmir Hero's Grave\"\n    AURIZA_HEROS_GRAVE = \"Auriza Hero's Grave\"\n    DEATHTOUCHED_CATACOMBS = \"Deathtouched Catacombs\"\n    UNSIGHTLY_CATACOMBS = \"Unsightly Catacombs\"\n    AURIZA_SIDE_TOMB = \"Auriza Side Tomb\"\n    MINOR_ERDTREE_CATACOMBS = \"Minor Erdtree Catacombs\"\n    CAELID_CATACOMBS = \"Caelid Catacombs\"\n    WAR_DEAD_CATACOMBS = \"War-Dead Catacombs\"\n    GIANT_CONQUERING_HEROS_GRAVE = \"Giant-Conquering Hero's Grave\"\n    GIANTS_MOUNTAINTOP_CATACOMBS = \"Giants' Mountaintop Catacombs\"\n    CONSECRATED_SNOWFIELD_CATACOMBS = \"Consecrated Snowfield Catacombs\"\n    HIDDEN_PATH_TO_THE_HALIGTREE = \"Hidden Path to the Haligtree\"\n    MURKWATER_CAVE = \"Murkwater Cave\"\n    EARTHBORE_CAVE = \"Earthbore Cave\"\n    TOMBSWARD_CAVE = \"Tombsward Cave\"\n    GROVESIDE_CAVE = \"Groveside Cave\"\n    STILLWATER_CAVE = \"Stillwater Cave\"\n    LAKESIDE_CRYSTAL_CAVE = \"Lakeside Crystal Cave\"\n    ACADEMY_CRYSTAL_CAVE = \"Academy Crystal Cave\"\n    SEETHEWATER_CAVE = \"Seethewater Cave\"\n    VOLCANO_CAVE = \"Volcano Cave\"\n    DRAGONBARROW_CAVE = \"Dragonbarrow Cave\"\n    SELLIA_HIDEAWAY = \"Sellia Hideaway\"\n    CAVE_OF_THE_FORLORN = \"Cave of the Forlorn\"\n    COASTAL_CAVE = \"Coastal Cave\"\n    HIGHROAD_CAVE = \"Highroad Cave\"\n    PERFUMERS_GROTTO = \"Perfumer's Grotto\"\n    SAGES_CAVE = \"Sage's Cave\"\n    ABANDONED_CAVE = \"Abandoned Cave\"\n    GAOL_CAVE = \"Gaol Cave\"\n    SPIRITCALLERS_CAVE = \"Spiritcaller's Cave\"\n    MORNE_TUNNEL = \"Morne Tunnel\"\n    LIMGRAVE_TUNNELS = \"Limgrave Tunnels\"\n    RAYA_LUCARIA_CRYSTAL_TUNNEL = \"Raya Lucaria Crystal Tunnel\"\n    OLD_ALTUS_TUNNEL = \"Old Altus Tunnel\"\n    ALTUS_TUNNEL = \"Altus Tunnel\"\n    GAEL_TUNNEL = \"Gael Tunnel\"\n    SELLIA_CRYSTAL_TUNNEL = \"Sellia Crystal Tunnel\"\n    YELOUGH_ANIX_TUNNEL = \"Yelough Anix Tunnel\"\n    DIVINE_TOWER_OF_LIMGRAVE = \"Divine Tower of Limgrave\"\n    CARIAN_STUDY_HALL = \"Carian Study Hall\"\n    DIVINE_TOWER_OF_LIURNIA = \"Divine Tower of Liurnia\"\n    SEALED_TUNNEL = \"Sealed Tunnel\"\n    DIVINE_TOWER_OF_WEST_ALTUS = \"Divine Tower of West Altus\"\n    DIVINE_TOWER_OF_CAELID = \"Divine Tower of Caelid\"\n    DIVINE_TOWER_OF_EAST_ALTUS = \"Divine Tower of East Altus\"\n    ISOLATED_DIVINE_TOWER = \"Isolated Divine Tower\"\n    SUBTERRANEAN_SHUNNING_GROUNDS = \"Subterranean Shunning-Grounds\"\n    RUIN_STREWN_PRECIPICE = \"Ruin-Strewn Precipice\"\n    ISOLATED_MERCHANTS_SHACK_1 = \"Isolated Merchant's Shack (1)\"\n    FOURTH_CHURCH_OF_MARIKA = \"Fourth Church of Marika\"\n    WITCHBANE_RUINS = \"Witchbane Ruins\"\n    CHURCH_OF_DRAGON_COMMUNION = \"Church of Dragon Communion\"\n    STORMHILL_SHACK = \"Stormhill Shack\"\n    TOWER_OF_RETURN = \"Tower of Return\"\n    WEEPING_EVERGAOL = \"Weeping Evergaol\"\n    TOMBSWARD_RUINS = \"Tombsward Ruins\"\n    CHURCH_OF_ELLEH = \"Church of Elleh\"\n    GATEFRONT_RUINS = \"Gatefront Ruins\"\n    STORMHILL_EVERGAOL = \"Stormhill Evergaol\"\n    STORMGATE = \"Stormgate\"\n    WARMASTERS_SHACK = \"Warmaster's Shack\"\n    CASTLE_MORNE = \"Castle Morne\"\n    MINOR_ERDTREE_1 = \"Minor Erdtree (1)\"\n    CHURCH_OF_PILGRIMAGE = \"Church of Pilgrimage\"\n    DEMI_HUMAN_FOREST_RUINS = \"Demi-Human Forest Ruins\"\n    DRAGON_BURNT_RUINS = \"Dragon-Burnt Ruins\"\n    CALLU_BAPTISMAL_CHURCH = \"Callu Baptismal Church\"\n    AILING_VILLAGE = \"Ailing Village\"\n    BRIDGE_OF_SACRIFICE = \"Bridge of Sacrifice\"\n    FOREST_LOOKOUT_TOWER = \"Forest Lookout Tower\"\n    FORLORN_HOUND_EVERGAOL = \"Forlorn Hound Evergaol\"\n    WAYPOINT_RUINS = \"Waypoint Ruins\"\n    ARTISTS_SHACK_1 = \"Artist's Shack (1)\"\n    ORIDYSS_RISE = \"Oridys's Rise\"\n    SIOFRA_RIVER_WELL = \"Siofra River Well\"\n    MISTWOOD_RUINS = \"Mistwood Ruins\"\n    MINOR_ERDTREE_2 = \"Minor Erdtree (2)\"\n    SUMMONWATER_VILLAGE = \"Summonwater Village\"\n    FORT_HAIGHT = \"Fort Haight\"\n    THIRD_CHURCH_OF_MARIKA = \"Third Church of Marika\"\n    CHELONAS_RISE = \"Chelona's Rise\"\n    RINGLEADERS_EVERGAOL = \"Ringleader's Evergaol\"\n    MINOR_ERDTREE_3 = \"Minor Erdtree (3)\"\n    REVENGERS_SHACK = \"Revenger's Shack\"\n    CUCKOOS_EVERGAOL = \"Cuckoo's Evergaol\"\n    THE_FOUR_BELFRIES = \"The Four Belfries\"\n    DEEP_AINSEL_WELL = \"Deep Ainsel Well\"\n    MOONFOLK_RUINS = \"Moonfolk Ruins\"\n    CONVERTED_TOWER = \"Converted Tower\"\n    TEMPLE_QUARTER = \"Temple Quarter\"\n    KINGSREALM_RUINS = \"Kingsrealm Ruins\"\n    SELUVISS_RISE = \"Seluvis's Rise\"\n    RANNIS_RISE = \"Ranni's Rise\"\n    THREE_SISTERS = \"Three Sisters\"\n    RENNAS_RISE = \"Renna's Rise\"\n    LUNAR_ESTATE_RUINS = \"Lunar Estate Ruins\"\n    VILLAGE_OF_THE_ALBINAURICS = \"Village of the Albinaurics\"\n    CATHEDRAL_OF_MANUS_CELES = \"Cathedral of Manus Celes\"\n    ROSE_CHURCH = \"Rose Church\"\n    TESTUS_RISE = \"Testu's Rise\"\n    CARIA_MANOR = \"Caria Manor\"\n    SLUMBERING_WOLFS_SHACK = \"Slumbering Wolf's Shack\"\n    BOILPRAWN_SHACK = \"Boilprawn Shack\"\n    BELLUM_CHURCH = \"Bellum Church\"\n    ROYAL_GRAVE_EVERGAOL = \"Royal Grave Evergaol\"\n    LASKYAR_RUINS = \"Laskyar Ruins\"\n    ACADEMY_GATE_TOWN = \"Academy Gate Town\"\n    CHURCH_OF_VOWS = \"Church of Vows\"\n    CHURCH_OF_INHIBITION = \"Church of Inhibition\"\n    MALEFACTORS_EVERGAOL = \"Malefactor's Evergaol\"\n    HIGHWAY_LOOKOUT_TOWER_1 = \"Highway Lookout Tower (1)\"\n    ARTISTS_SHACK_2 = \"Artist's Shack (2)\"\n    AINSEL_RIVER_WELL = \"Ainsel River Well\"\n    ULD_PALACE_RUINS = \"Uld Palace Ruins\"\n    FRENZIED_FLAME_VILLAGE = \"Frenzied Flame Village\"\n    MINOR_ERDTREE_4 = \"Minor Erdtree (4)\"\n    FRENZY_FLAMING_TOWER = \"Frenzy-Flaming Tower\"\n    CHURCH_OF_IRITH = \"Church of Irith\"\n    PURIFIED_RUINS = \"Purified Ruins\"\n    JARBURG = \"Jarburg\"\n    CONVERTED_FRINGE_TOWER = \"Converted Fringe Tower\"\n    FORT_LAIEDD = \"Fort Laiedd\"\n    PERFUMERS_RUINS = \"Perfumer's Ruins\"\n    HERMITS_SHACK = \"Hermit's Shack\"\n    CRAFTSMANS_SHACK = \"Craftsman's Shack\"\n    STORMCALLER_CHURCH = \"Stormcaller Church\"\n    HERMIT_VILLAGE = \"Hermit Village\"\n    MINOR_ERDTREE_5 = \"Minor Erdtree (5)\"\n    GRAND_LIFT_OF_DECTUS = \"Grand Lift of Dectus\"\n    LUX_RUINS = \"Lux Ruins\"\n    WYNDHAM_RUINS = \"Wyndham Ruins\"\n    CORPSE_STENCH_SHACK = \"Corpse-Stench Shack\"\n    GOLDEN_LINEAGE_EVERGAOL = \"Golden Lineage Evergaol\"\n    SECOND_CHURCH_OF_MARIKA = \"Second Church of Marika\"\n    MIRAGE_RISE = \"Mirage Rise\"\n    THE_SHADED_CASTLE = \"The Shaded Castle\"\n    ST_TRINAS_HIDEAWAY = \"St. Trina's Hideaway\"\n    WRITHEBLOOD_RUINS = \"Writheblood Ruins\"\n    WEST_WINDMILL_PASTURE = \"West Windmill Pasture\"\n    WOODFOLK_RUINS = \"Woodfolk Ruins\"\n    MINOR_ERDTREE_6 = \"Minor Erdtree (6)\"\n    DOMINULA_WINDMILL_VILLAGE = \"Dominula, Windmill Village\"\n    EAST_WINDMILL_PASTURE = \"East Windmill Pasture\"\n    VILLAGE_WINDMILL_PASTURE = \"Village Windmill Pasture\"\n    HIGHWAY_LOOKOUT_TOWER_2 = \"Highway Lookout Tower (2)\"\n    MINOR_ERDTREE_CHURCH = \"Minor Erdtree Church\"\n    HERMIT_MERCHANTS_SHACK = \"Hermit Merchant's Shack\"\n    MINOR_ERDTREE_7 = \"Minor Erdtree (7)\"\n    SMOLDERING_CHURCH = \"Smoldering Church\"\n    SHACK_OF_THE_ROTTING = \"Shack of the Rotting\"\n    CAELID_WAYPOINT_RUINS = \"Caelid Waypoint Ruins\"\n    FORT_GAEL = \"Fort Gael\"\n    FORSAKEN_RUINS = \"Forsaken Ruins\"\n    MINOR_ERDTREE_8 = \"Minor Erdtree (8)\"\n    CAELEM_RUINS = \"Caelem Ruins\"\n    CATHEDRAL_OF_DRAGON_COMMUNION = \"Cathedral of Dragon Communion\"\n    STREET_OF_SAGES_RUINS = \"Street of Sages Ruins\"\n    ISOLATED_MERCHANTS_SHACK_2 = \"Isolated Merchant's Shack (2)\"\n    SWAMP_LOOKOUT_TOWER = \"Swamp Lookout Tower\"\n    SELLIA_GATEWAY = \"Sellia Gateway\"\n    SELLIA_EVERGAOL = \"Sellia Evergaol\"\n    DEEP_SIOFRA_WELL = \"Deep Siofra Well\"\n    GOWRYS_SHACK = \"Gowry's Shack\"\n    CHURCH_OF_THE_PLAGUE = \"Church of the Plague\"\n    SELLIA_TOWN_OF_SORCERY = \"Sellia, Town of Sorcery\"\n    REDMANE_CASTLE = \"Redmane Castle\"\n    WAILING_DUNES = \"Wailing Dunes\"\n    FORT_FAROTH = \"Fort Faroth\"\n    MINOR_ERDTREE_9 = \"Minor Erdtree (9)\"\n    BESTIAL_SANCTUM = \"Bestial Sanctum\"\n    LENNES_RISE = \"Lenne's Rise\"\n    YELOUGH_ANIX_RUINS = \"Yelough Anix Ruins\"\n    APOSTATE_DERELICT = \"Apostate Derelict\"\n    ORDINA_LITURGICAL_TOWN = \"Ordina, Liturgical Town\"\n    ZAMOR_RUINS = \"Zamor Ruins\"\n    GRAND_LIFT_OF_ROLD = \"Grand Lift of Rold\"\n    SHACK_OF_THE_LOFTY = \"Shack of the Lofty\"\n    MINOR_ERDTREE_10 = \"Minor Erdtree (10)\"\n    ALBINAURIC_RISE = \"Albinauric Rise\"\n    CHURCH_OF_REPOSE = \"Church of Repose\"\n    STARGAZERS_RUINS = \"Stargazers' Ruins\"\n    CASTLE_SOL = \"Castle Sol\"\n    GUARDIANS_GARRISON = \"Guardians' Garrison\"\n    MINOR_ERDTREE_11 = \"Minor Erdtree (11)\"\n    HERETICAL_RISE = \"Heretical Rise\"\n    LORD_CONTENDERS_EVERGAOL = \"Lord Contender's Evergaol\"\n    FORGE_OF_THE_GIANTS = \"Forge of the Giants\"\n    FIRST_CHURCH_OF_MARIKA = \"First Church of Marika\"\n    UHL_PALACE_RUINS_1 = \"Uhl Palace Ruins (1)\"\n    UHL_PALACE_RUINS_2 = \"Uhl Palace Ruins (2)\"\n    NOKSTELLA_ETERNAL_CITY = \"Nokstella, Eternal City\"\n    GRAND_CLOISTER = \"Grand Cloister\"\n    NIGHTS_SACRED_GROUND = \"Night's Sacred Ground\"\n    SIOFRA_AQUEDUCT = \"Siofra Aqueduct\"\n    HALLOWHORN_GROUNDS_1 = \"Hallowhorn Grounds (1)\"\n    HALLOWHORN_GROUNDS_2 = \"Hallowhorn Grounds (2)\"\n    MOHGWYN_DYNASTY_MAUSOLEUM = \"Mohgwyn Dynasty Mausoleum\"\n    NOKRON_ETERNAL_CITY = \"Nokron, Eternal City\"\n\nclass Currency(str, Enum):\n    RUNES = \"Runes\"\n    DRAGON_HEARTS = \"Dragon Hearts\"\n    STARLIGHT_SHARDS = \"Starlight Shards\"\n    LOST_ASHES_OF_WAR = \"Lost Ashes of War\""}
{"type": "source_file", "path": "src/erdb/table/shop.py", "content": "from erdb.typing.models.shop import Shop\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import GoodsSortGroupID, GoodsType, ItemIDFlag\nfrom erdb.typing.categories import ShopCategory\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\nclass ShopTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Shop,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamGoods\", ItemIDFlag.GOODS)\n\n    predicates: list[RowPredicate] = [\n        lambda row: 1 <= row[\"sortId\"].as_int < 999999,\n        lambda row: row[\"goodsType\"] == GoodsType.KEY_ITEM,\n        lambda row: (row[\"sortGroupId\"].as_int in [GoodsSortGroupID.GROUP_8, GoodsSortGroupID.GROUP_9, GoodsSortGroupID.GROUP_10] \\\n            or (row[\"sortGroupId\"].as_int == GoodsSortGroupID.GROUP_6 and \"Cookbook\" in row.name)),\n    ]\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GoodsName\"),\n        \"summaries\": MsgsRetriever(\"GoodsInfo\"),\n        \"descriptions\": MsgsRetriever(\"GoodsCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        return Shop(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            category=ShopCategory.from_row(row),\n        )"}
{"type": "source_file", "path": "src/erdb/table/correction_attack.py", "content": "from typing import Any\n\nfrom erdb.typing.models.correction_attack import CorrectionAttack, Correction, Override, Ratio\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import ItemIDFlag\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, RetrieverData\nfrom erdb.table._common import TableSpecContext\n\n\n_DAMAGE_TYPE: dict[str, str] = {\n    \"physical\": \"Physics\",\n    \"magic\": \"Magic\",\n    \"fire\": \"Fire\",\n    \"lightning\": \"Thunder\",\n    \"holy\": \"Dark\",\n}\n\n_ATTRIBUTE: dict[str, str] = {\n    \"strength\": \"Strength\",\n    \"dexterity\": \"Dexterity\",\n    \"intelligence\": \"Magic\",\n    \"faith\": \"Faith\",\n    \"arcane\": \"Luck\",\n}\n\ndef _get_attributes(row: ParamRow, damage_type: str, cls: Any) -> Any:\n    def get_field(attribute: str, damage_type: str) -> int:\n        field = cls.get_property(_ATTRIBUTE[attribute], _DAMAGE_TYPE[damage_type])\n\n        return {\n            Correction: row[field].as_bool,\n            Override: value / 100.0 if (value := row[field].get_float()) else None,\n            Ratio: row[field].as_float / 100.0,\n        }[cls]\n\n    ret = {attrib: get_field(attrib, damage_type) for attrib in _ATTRIBUTE.keys()}\n    ret = {k: v for k, v in ret.items() if v is not None}\n    return cls.get_field_type()(**ret)\n\ndef _get_damage_types(row: ParamRow, cls: Any) -> Any:\n    data = {damage: _get_attributes(row, damage, cls) for damage in _DAMAGE_TYPE.keys()}\n    return cls(**data)\n\nclass CorrectionAttackTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: CorrectionAttack,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"AttackElementCorrectParam\", ItemIDFlag.NON_EQUIPABBLE)\n\n    @classmethod # override\n    def get_pk(cls, data: RetrieverData, row: ParamRow) -> str:\n        return str(row.index)\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        return CorrectionAttack(\n            correction=_get_damage_types(row, Correction),\n            override=_get_damage_types(row, Override),\n            ratio=_get_damage_types(row, Ratio),\n        )"}
{"type": "source_file", "path": "src/erdb/typing/effects.py", "content": "from copy import deepcopy\nfrom enum import Enum\nfrom types import SimpleNamespace\nfrom typing import Any, Callable, NamedTuple, Self\n\n\nclass EffectType(str, Enum):\n    POSITIVE = \"positive\"\n    NEUTRAL = \"neutral\"\n    NEGATIVE = \"negative\"\n\nclass EffectModel(str, Enum):\n    MULTIPLICATIVE = \"multiplicative\"\n    ADDITIVE = \"additive\"\n\n\"\"\"\nHelper class of attributes used for effects, these are self-made\nand don't correspond to anything in the game.\n\"\"\"\nclass AttributeName(str, Enum):\n    MAXIMUM_HEALTH = \"Maximum Health\",\n    HEALTH_POINTS = \"Health Points\",\n    FLASK_HEALTH_RESTORATION = \"Flask Health Restoration\",\n    MAXIMUM_FOCUS = \"Maximum Focus\",\n    FOCUS_POINTS = \"Focus Points\",\n    FLASK_FOCUS_RESTORATION = \"Flask Focus Restoration\",\n    MAXIMUM_STAMINA = \"Maximum Stamina\",\n    STAMINA_RECOVERY_SPEED = \"Stamina Recovery Speed\",\n    MAXIMUM_EQUIP_LOAD = \"Maximum Equip Load\",\n    POISE = \"Poise\",\n    VIGOR = \"Vigor\",\n    MIND = \"Mind\",\n    ENDURANCE = \"Endurance\",\n    STRENGHT = \"Strength\",\n    DEXTERITY = \"Dexterity\",\n    INTELLIGENCE = \"Intelligence\",\n    FAITH = \"Faith\",\n    ARCANE = \"Arcane\",\n    STANDARD_ABSORPTION = \"Standard Absorption\",\n    STRIKE_ABSORPTION = \"Strike Absorption\",\n    SLASH_ABSORPTION = \"Slash Absorption\",\n    PIERCE_ABSORPTION = \"Pierce Absorption\",\n    PHYSICAL_ABSORPTION = \"Physical Absorption\",\n    MAGIC_ABSORPTION = \"Magic Absorption\",\n    FIRE_ABSORPTION = \"Fire Absorption\",\n    LIGHTNING_ABSORPTION = \"Lightning Absorption\",\n    HOLY_ABSORPTION = \"Holy Absorption\",\n    ELEMENTAL_ABSORPTION = \"Elemental Absorption\",\n    ABSORPTION = \"Absorption\",\n    STANDARD_ATTACK_POWER = \"Standard Attack Power\",\n    STRIKE_ATTACK_POWER = \"Strike Attack Power\",\n    SLASH_ATTACK_POWER = \"Slash Attack Power\",\n    PIERCE_ATTACK_POWER = \"Pierce Attack Power\",\n    PHYSICAL_ATTACK_POWER = \"Physical Attack Power\",\n    MAGIC_ATTACK_POWER = \"Magic Attack Power\",\n    FIRE_ATTACK_POWER = \"Fire Attack Power\",\n    LIGHTNING_ATTACK_POWER = \"Lightning Attack Power\",\n    HOLY_ATTACK_POWER = \"Holy Attack Power\",\n    ELEMENTAL_ATTACK_POWER = \"Elemental Attack Power\",\n    ATTACK_POWER = \"Attack Power\",\n    STAMINA_ATTACK_RATE = \"Stamina Attack Rate\"\n    STABILITY = \"Stability\"\n    IMMUNITY = \"Immunity\",\n    ROBUSTNESS = \"Robustness\"\n    VITALITY = \"Vitality\",\n    FOCUS = \"Focus\",\n    POISON_RESISTANCE = \"Poison Resistance\",\n    SCARLET_ROT_RESISTANCE = \"Scarlet Rot Resistance\",\n    BLEED_RESISTANCE = \"Bleed Resistance\",\n    FROSTBITE_RESISTANCE = \"Frostbite Resistance\",\n    SLEEP_RESISTANCE = \"Sleep Resistance\",\n    MADNESS_RESISTANCE = \"Madness Resistance\",\n    DEATH_BLIGHT_RESISTANCE = \"Death Blight Resistance\",\n    MEMORY_SLOTS = \"Memory Slots\",\n    CASTING_SPEED = \"Casting Speed\",\n    SPELL_DURATION = \"Spell Duration\",\n    SORCERY_FOCUS_CONSUMPTION = \"Sorcery Focus Consumption\",\n    INCANTATION_FOCUS_CONSUMPTION = \"Incantation Focus Consumption\",\n    PYROMANCY_FOCUS_CONSUMPTION = \"Pyromancy Focus Consumption\",\n    SPELL_FOCUS_CONSUMPTION = \"Spell Focus Consumption\",\n    SKILL_FOCUS_CONSUMPTION = \"Skill Focus Consumption\",\n    BOW_DISTANCE = \"Bow Distance\",\n    ENEMY_HEARING = \"Enemy Hearing\",\n    FALL_DAMAGE = \"Fall Damage\",\n    ITEM_DISCOVERY = \"Item Discovery\",\n    RUNE_ACQUISITION = \"Rune Acquisition\",\n    INVISIBLE_AT_DISTANCE = \"Invisible at Distance\"\n    REDUCE_HEADSHOT_IMPACT = \"Reduce Headshot Impact\"\n    SWITCH_ANIMATION_GENDER = \"Switch Animation Gender\"\n    APPEAR_AS_COOPERATOR = \"Appear as Cooperator\"\n    APPEAR_AS_HOST = \"Appear as Host\"\n    PRESERVE_RUNES_ON_DEATH = \"Preserve Runes on Death\"\n    DESTROY_ITEM_ON_DEATH = \"Destroy Item on Death\"\n    ATTRACT_ENEMY_AGGRESSION = \"Attract Enemy Aggression\"\n\nclass AttributeField(NamedTuple):\n    attribute: AttributeName\n    effect_model: EffectModel\n    effect_type: EffectType\n    parser: Callable\n    conditions: list[str] | None\n    default_value: Any\n\n    def get_effective_type(self, value: Any):\n        T = EffectType\n        value_increase = value >= self.default_value\n        return {\n            T.POSITIVE: { True: T.POSITIVE, False: T.NEGATIVE, },\n            T.NEGATIVE: { True: T.NEGATIVE, False: T.POSITIVE, },\n            T.NEUTRAL:  { True: T.NEUTRAL,  False: T.NEUTRAL,  }\n        }[self.effect_type][value_increase]\n\n    @classmethod\n    def create(cls, attribute: AttributeName, effect_model: EffectModel, effect_type: EffectType,\n               parser: Callable, conditions: list[str] | None = None, default_value: Any | None = None) -> Self:\n\n        def _default_value_from_model():\n            return 1 if effect_model == EffectModel.MULTIPLICATIVE else 0\n\n        default_value = _default_value_from_model() if default_value is None else default_value\n        return cls(attribute, effect_model, effect_type, parser, conditions, default_value)\n\nclass SchemaEffect(SimpleNamespace):\n    attribute: AttributeName\n    conditions: list[str] | None = None\n    tick_interval: float | None = None\n    effect_model: EffectModel\n    effect_type: EffectType\n    value: float\n    value_pvp: float | None = None\n\n    def to_dict(self) -> dict:\n        d = {\n            \"attribute\": self.attribute,\n            \"model\": self.effect_model,\n            \"type\": self.effect_type,\n            \"value\": self.value,\n        }\n\n        for prop in [\"conditions\", \"tick_interval\", \"value_pvp\"]:\n            if getattr(self, prop) is not None:\n                d[prop] = getattr(self, prop)\n\n        return d\n\n    def get_values_hash(self) -> int:\n        conds = None if self.conditions is None else tuple(self.conditions)\n        return hash((conds, self.tick_interval, self.effect_model, self.effect_type, self.value, self.value_pvp))\n\n    def clone(self, new_attribute: AttributeName) -> Self:\n        new_effect = deepcopy(self)\n        new_effect.attribute = new_attribute\n        return new_effect\n\n    def __str__(self) -> str:\n        conds      = \"\" if self.conditions is None else f\" (under conditions {self.conditions})\"\n        sign_val   = \"+\" if self.value > 0 else \"-\"\n        sign_model = \"%\" if self.effect_model == EffectModel.MULTIPLICATIVE else \"+\"\n        val_pvp    = \"\" if self.value_pvp is None else f\" ({self.value_pvp} PVP)\"\n        tick       = \"\" if self.tick_interval is None else f\" on tick {self.tick_interval} s\"\n        return f\"{sign_val}{self.value}{sign_model}{val_pvp} {self.attribute.value}{conds}{tick}\"\n\n    @classmethod\n    def from_attribute_field(cls, value: float, attrib_field: AttributeField) -> Self:\n        value = attrib_field.parser(value, attrib_field.effect_model)\n\n        return cls(\n            attribute=attrib_field.attribute,\n            conditions=attrib_field.conditions,\n            effect_model=attrib_field.effect_model,\n            effect_type=attrib_field.get_effective_type(value),\n            value=value)\n\n    @classmethod\n    def from_obj(cls, obj: Any) -> Self:\n        return cls(\n            attribute=AttributeName(getattr(obj, \"attribute\")),\n            conditions=getattr(obj, \"conditions\", None),\n            tick_interval=getattr(obj, \"tick_interval\"),\n            effect_model=EffectModel(getattr(obj, \"model\")),\n            effect_type=EffectType(getattr(obj, \"type\")),\n            value=getattr(obj, \"value\", None),\n            value_pvp=getattr(obj, \"value_pvp\", None))"}
{"type": "source_file", "path": "src/erdb/table/crafting_materials.py", "content": "from erdb.shop import Product, Material\nfrom erdb.typing.models.crafting_material import CraftingMaterial\nfrom erdb.typing.models import NonEmptyStr\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import GoodsType, ItemIDFlag\nfrom erdb.typing.categories import CraftingMaterialCategory\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData, ShopRetriever\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\nclass CraftingMaterialTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: CraftingMaterial,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamGoods\", ItemIDFlag.GOODS)\n\n    predicates: list[RowPredicate] = [\n        lambda row: row[\"goodsType\"] == GoodsType.CRAFTING_MATERIAL\n    ]\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GoodsName\"),\n        \"armament_names\": MsgsRetriever(\"WeaponName\"),\n        \"summaries\": MsgsRetriever(\"GoodsInfo\"),\n        \"hints\": MsgsRetriever(\"GoodsInfo2\"),\n        \"descriptions\": MsgsRetriever(\"GoodsCaption\")\n    }\n\n    shop_retrievers = {\n        \"crafting_shop\": ShopRetriever(\n            shop_lineup_id_min=None, shop_lineup_id_max=None,\n            material_set_id_min=300000, material_set_id_max=400000,\n            recipe=True\n        )\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        crafting_shop = data.shops[\"crafting_shop\"]\n\n        names = {\n            Product.Category.GOOD: data.msgs[\"names\"],\n            Product.Category.WEAPON: data.msgs[\"armament_names\"]\n        }\n\n        material = Material(row.index, Material.Category.GOOD)\n        lineups = crafting_shop.get_lineups_from_material(material)\n        assert len(lineups) > 0\n\n        return CraftingMaterial(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            category=CraftingMaterialCategory.from_row(row),\n            hint=NonEmptyStr(data.msgs[\"hints\"].get(row.index, \"\")),\n            products=[NonEmptyStr(cls.parse_name(names[l.product.category][l.product.index])) for l in lineups]\n        )"}
{"type": "source_file", "path": "src/erdb/table/keys.py", "content": "from erdb.typing.models.key import Key\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import GoodsSortGroupID, GoodsType, ItemIDFlag\nfrom erdb.typing.categories import KeyCategory\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\nclass KeyTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Key,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamGoods\", ItemIDFlag.GOODS)\n\n    predicates: list[RowPredicate] = [\n        lambda row: 1 <= row[\"sortId\"].as_int < 999999,\n        lambda row: row[\"goodsType\"] in [GoodsType.KEY_ITEM, GoodsType.REGENERATIVE_MATERIAL],\n        lambda row: row[\"sortGroupId\"].as_int not in [GoodsSortGroupID.GROUP_8, GoodsSortGroupID.GROUP_9, GoodsSortGroupID.GROUP_10],\n        lambda row: \"Cookbook\" not in row.name,\n    ]\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GoodsName\"),\n        \"summaries\": MsgsRetriever(\"GoodsInfo\"),\n        \"descriptions\": MsgsRetriever(\"GoodsCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        return Key(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            category=KeyCategory.from_row(row),\n        )"}
{"type": "source_file", "path": "src/erdb/typing/api_version.py", "content": "from enum import IntEnum\n\n\nclass ApiVersion(IntEnum):\n    VER_1 = 1"}
{"type": "source_file", "path": "src/erdb/table/ashes_of_war.py", "content": "from erdb.typing.models.ash_of_war import AshOfWar\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import ItemIDFlag, Affinity\nfrom erdb.typing.categories import ArmamentCategory\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import TableSpecContext\n\n\ndef _get_categories(row: ParamRow) -> list[ArmamentCategory]:\n    return [a for a in list(ArmamentCategory) if row[f\"canMountWep_{a.ingame}\"].as_bool]\n\ndef _get_affinities(row: ParamRow) -> list[Affinity]:\n    return [a for a in Affinity if row[f\"configurableWepAttr{str(a.id).zfill(2)}\"].as_bool]\n\nclass AshOfWarTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: AshOfWar,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamGem\", ItemIDFlag.ACCESSORIES, id_min=10000)\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GemName\"),\n        \"summaries\": MsgsRetriever(\"GemInfo\"),\n        \"descriptions\": MsgsRetriever(\"GemCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        return AshOfWar(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            armament_categories=_get_categories(row),\n            default_affinity=Affinity.from_id(row[\"defaultWepAttr\"].as_int),\n            possible_affinities=_get_affinities(row),\n            skill_id=row[\"swordArtsParamId\"].as_int,\n        )"}
{"type": "source_file", "path": "src/erdb/table/talismans.py", "content": "from erdb.typing.models.talisman import Talisman\nfrom erdb.typing.models.effect import Effect\nfrom erdb.typing.models import NonEmptyStr\nfrom erdb.effect_parser import parse_effects\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import ItemIDFlag\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\nclass TalismanTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Talisman,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamAccessory\", ItemIDFlag.ACCESSORIES)\n\n    predicates: list[RowPredicate] = [\n        lambda row: 1000 <= row.index < 999999,\n    ]\n\n    param_retrievers = {\n        \"effects\": ParamDictRetriever(\"SpEffectParam\", ItemIDFlag.NON_EQUIPABBLE, id_min=310000, id_max=400000)\n    }\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"AccessoryName\"),\n        \"summaries\": MsgsRetriever(\"AccessoryInfo\"),\n        \"descriptions\": MsgsRetriever(\"AccessoryCaption\")\n    }\n\n    @classmethod\n    def _find_conflicts(cls, data: RetrieverData, group: int) -> list[NonEmptyStr]:\n        def valid(row: ParamRow) -> bool:\n            return row[\"accessoryGroup\"].as_int == group and row.index < 9999999\n        return [NonEmptyStr(cls.parse_name(data.msgs[\"names\"][row.index])) for row in data.main_param.values() if valid(row)]\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        effects = data.params[\"effects\"]\n\n        return Talisman(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            weight=row[\"weight\"].as_float,\n            effects=[Effect(**eff) for eff in parse_effects(row, effects, \"refId\")],\n            conflicts=cls._find_conflicts(data, row[\"accessoryGroup\"].as_int),\n        )"}
{"type": "source_file", "path": "src/erdb/table/tools.py", "content": "from erdb.typing.models.tool import Tool\nfrom erdb.typing.models.effect import Effect\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import GoodsSortGroupID, GoodsType, ItemIDFlag, ToolAvailability\nfrom erdb.typing.categories import ToolCategory\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.effect_parser import parse_effects\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\ndef _get_availability(row: ParamRow) -> ToolAvailability:\n    T = ToolAvailability\n\n    if row[\"disable_offline\"].as_bool:\n        return T.MULTIPLAYER\n\n    return T.ALWAYS if row[\"enable_multi\"].as_bool else T.SINGLEPLAYER\n\ndef _is_note_item(name: str) -> bool:\n    # 2 Weathered Maps defined in-game, one is NORMAL_ITEM\n    return name.startswith(\"Note: \") or name == \"Weathered Map\"\n\nclass ToolTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Tool,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamGoods\", ItemIDFlag.GOODS)\n\n    predicates: list[RowPredicate] = [\n        lambda row: 1 <= row[\"sortId\"].as_int < 999999,\n        lambda row: row[\"sortGroupId\"].as_int != GoodsSortGroupID.GESTURES,\n        lambda row: row[\"goodsType\"] in [GoodsType.NORMAL_ITEM, GoodsType.REMEMBRANCE, GoodsType.WONDROUS_PHYSICK_TEAR, GoodsType.GREAT_RUNE],\n        lambda row: not _is_note_item(row.name),\n    ]\n\n    param_retrievers = {\n        \"effects\": ParamDictRetriever(\"SpEffectParam\", ItemIDFlag.NON_EQUIPABBLE)\n    }\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GoodsName\"),\n        \"summaries\": MsgsRetriever(\"GoodsInfo\"),\n        \"descriptions\": MsgsRetriever(\"GoodsCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        effects = data.params[\"effects\"]\n\n        return Tool(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            category=ToolCategory.from_row(row),\n            availability=_get_availability(row),\n            fp_cost=row[\"consumeMP\"].as_int,\n            is_consumed=row[\"isConsume\"].as_bool,\n            is_ladder_usable=row[\"enable_Ladder\"].as_bool,\n            is_horseback_usable=row[\"enableRiding\"].as_bool,\n            effects=[Effect(**eff) for eff in parse_effects(row, effects, \"refId_default\")],\n        )"}
{"type": "source_file", "path": "src/erdb/table/bolstering_materials.py", "content": "from erdb.typing.models.bolstering_material import BolsteringMaterial\nfrom erdb.typing.categories import BolsteringMaterialCategory\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import GoodsType, ItemIDFlag\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\nclass BolsteringMaterialTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: BolsteringMaterial,\n    }\n\n    predicates: list[RowPredicate] = [\n        lambda row: row[\"goodsType\"] == GoodsType.REINFORCEMENT_MATERIAL,\n    ]\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamGoods\", ItemIDFlag.GOODS)\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GoodsName\"),\n        \"summaries\": MsgsRetriever(\"GoodsInfo\"),\n        \"descriptions\": MsgsRetriever(\"GoodsCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        return BolsteringMaterial(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            category=BolsteringMaterialCategory.from_row(row),\n        )"}
{"type": "source_file", "path": "src/erdb/table/correction_graph.py", "content": "from itertools import repeat\nfrom typing import NamedTuple, Self\n\nfrom erdb.typing.models.correction_graph import CorrectionGraph\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import ItemIDFlag\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\ndef calc_output(stage_min: float, stage_max: float, val_min: float, val_max: float, mult_val_min: float, mult_val_max: float, input_val: float) -> float:\n    input_ratio = (input_val - stage_min) / (stage_max - stage_min)\n\n    if mult_val_min > 0:\n        growth_val = input_ratio ** mult_val_min\n    else:\n        growth_val = 1 - ((1 - input_ratio) ** abs(mult_val_min))\n\n    return val_min + ((val_max - val_min) * growth_val)\n\nclass CorrectionRange(NamedTuple):\n    threshold_left: int\n    threshold_right: int\n    coefficient_left: float\n    coefficient_right: float\n    adjustment: float\n\n    def get_correction(self, level: int) -> float:\n        \"\"\"\n        Calculate the correction value given level and CalcCorrectGraph, shamelessly stolen from:\n        https://github.com/kingborehaha/CalcCorrectGraph-Calculation-Tool\n        \"\"\"\n        level_ratio = (level - self.threshold_left) / (self.threshold_right - self.threshold_left)\n\n        growth = \\\n            level_ratio ** self.adjustment \\\n            if self.adjustment > 0 else \\\n            1 - ((1 - level_ratio) ** abs(self.adjustment))\n\n        return self.coefficient_left + ((self.coefficient_right - self.coefficient_left) * growth)\n\n    @classmethod\n    def from_row(cls, row: ParamRow, left: int, right: int) -> Self:\n        return cls(\n            row[f\"stageMaxVal{left}\"].as_int,\n            row[f\"stageMaxVal{right}\"].as_int,\n            row[f\"stageMaxGrowVal{left}\"].as_float,\n            row[f\"stageMaxGrowVal{right}\"].as_float,\n            row[f\"adjPt_maxGrowVal{left}\"].as_float,\n        )\n\nclass CorrectionGraphTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: CorrectionGraph,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"CalcCorrectGraph\", ItemIDFlag.NON_EQUIPABBLE)\n\n    predicates: list[RowPredicate] = [\n        lambda row: row.index < 17\n    ]\n\n    @classmethod # override\n    def get_pk(cls, data: RetrieverData, row: ParamRow) -> str:\n        return str(row.index)\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        points = range(0, 5)\n        points_shift = range(1, 5)\n        ranges = [CorrectionRange.from_row(row, left, right) for left, right in zip(points, points_shift)]\n\n        values: list[float] = [0.]\n\n        for r in ranges:\n            values += [r.get_correction(v) / 100.0 for v in range(r.threshold_left + 1, r.threshold_right + 1)]\n\n        values += list(repeat(values[-1], 150 - len(values)))\n        assert len(values) == 150, \"Correction values length mismatch\"\n\n        # 0th index is not valid, add another 0 to offset\n        return [0.] + values"}
{"type": "source_file", "path": "src/erdb/table/reinforcements.py", "content": "from erdb.typing.models.reinforcement import Reinforcement, ReinforcementLevel, DamageMultiplier, ScalingMultiplier, GuardMultiplier, ResistanceMultiplier\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import ItemIDFlag\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.utils.common import find_offset_indices\nfrom erdb.table._retrievers import ParamDictRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\ndef _get_damages(row: ParamRow) -> DamageMultiplier:\n    return DamageMultiplier(\n        physical=row[\"physicsAtkRate\"].as_float,\n        magic=row[\"magicAtkRate\"].as_float,\n        fire=row[\"fireAtkRate\"].as_float,\n        lightning=row[\"thunderAtkRate\"].as_float,\n        holy=row[\"darkAtkRate\"].as_float,\n        stamina=row[\"staminaAtkRate\"].as_float,\n    )\n\ndef _get_scalings(row: ParamRow) -> ScalingMultiplier:\n    return ScalingMultiplier(\n        strength=row[\"correctStrengthRate\"].as_float,\n        dexterity=row[\"correctAgilityRate\"].as_float,\n        intelligence=row[\"correctMagicRate\"].as_float,\n        faith=row[\"correctFaithRate\"].as_float,\n        arcane=row[\"correctLuckRate\"].as_float,\n    )\n\ndef _get_guards(row: ParamRow) -> GuardMultiplier:\n    return GuardMultiplier(\n        physical=row[\"physicsGuardCutRate\"].as_float,\n        magic=row[\"magicGuardCutRate\"].as_float,\n        fire=row[\"fireGuardCutRate\"].as_float,\n        lightning=row[\"thunderGuardCutRate\"].as_float,\n        holy=row[\"darkGuardCutRate\"].as_float,\n        guard_boost=row[\"staminaGuardDefRate\"].as_float,\n    )\n\ndef _get_resistances(row: ParamRow) -> ResistanceMultiplier:\n    return ResistanceMultiplier(\n        poison=row[\"poisonGuardResistRate\"].as_float,\n        scarlet_rot=row[\"diseaseGuardResistRate\"].as_float,\n        frostbite=row[\"freezeGuardDefRate\"].as_float,\n        bleed=row[\"bloodGuardResistRate\"].as_float,\n        sleep=row[\"sleepGuardDefRate\"].as_float,\n        madness=row[\"madnessGuardDefRate\"].as_float,\n        death_blight=row[\"curseGuardResistRate\"].as_float,\n    )\n\ndef _get_reinforcement_level(row: ParamRow, level: int) -> ReinforcementLevel:\n    return ReinforcementLevel(\n        level=level,\n        damage=_get_damages(row),\n        scaling=_get_scalings(row),\n        guard=_get_guards(row),\n        resistance=_get_resistances(row)\n    )\n\nclass ReinforcementTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Reinforcement,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"ReinforceParamWeapon\", ItemIDFlag.NON_EQUIPABBLE)\n\n    predicates: list[RowPredicate] = [\n        lambda row: row.is_base_item,\n        lambda row: len(row.name) > 0,\n    ]\n\n    @classmethod # override\n    def get_pk(cls, data: RetrieverData, row: ParamRow) -> str:\n        return str(row.index)\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        indices, offset = find_offset_indices(row.index, data.main_param, possible_maxima=[0, 10, 25])\n        return Reinforcement([_get_reinforcement_level(data.main_param[i], lvl) for i, lvl in zip(indices, offset)])"}
{"type": "source_file", "path": "src/erdb/table/armor.py", "content": "from erdb.shop import Material\nfrom erdb.typing.models.effect import Effect\nfrom erdb.typing.models.armor import Armor, Absorptions, Resistances\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import ItemIDFlag\nfrom erdb.typing.categories import ArmorCategory\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.effect_parser import parse_effects\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData, ShopRetriever\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\ndef _get_absorptions(row: ParamRow) -> Absorptions:\n    def parse(val: float):\n        return round((1 - val) * 100, 1)\n\n    return Absorptions(\n        physical=parse(row[\"neutralDamageCutRate\"].as_float),\n        strike=parse(row[\"blowDamageCutRate\"].as_float),\n        slash=parse(row[\"slashDamageCutRate\"].as_float),\n        pierce=parse(row[\"thrustDamageCutRate\"].as_float),\n        magic=parse(row[\"magicDamageCutRate\"].as_float),\n        fire=parse(row[\"fireDamageCutRate\"].as_float),\n        lightning=parse(row[\"thunderDamageCutRate\"].as_float),\n        holy=parse(row[\"darkDamageCutRate\"].as_float),\n    )\n\ndef _get_resistances(row: ParamRow) -> Resistances:\n    def check_equal(val1: int, val2: int) -> int:\n        if val1 != val2:\n            print(f\"WARNING: Values mismatch for {row.name} resistances ({val1} != {val2}), displaying the latter.\", flush=True)\n        return val2\n\n    return Resistances(\n        immunity=check_equal(row[\"resistPoison\"].as_int, row[\"resistDisease\"].as_int),\n        robustness=check_equal(row[\"resistFreeze\"].as_int, row[\"resistBlood\"].as_int),\n        focus=check_equal(row[\"resistSleep\"].as_int, row[\"resistMadness\"].as_int),\n        vitality=row[\"resistCurse\"].as_int,\n        poise=round(row[\"toughnessCorrectRate\"].as_float * 1000)\n    )\n\nclass ArmorTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Armor,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamProtector\", ItemIDFlag.PROTECTORS)\n\n    predicates: list[RowPredicate] = [\n        lambda row: row.index >= 40000,\n        lambda row: len(row.name) > 0,\n    ]\n\n    param_retrievers = {\n        \"effects\": ParamDictRetriever(\"SpEffectParam\", ItemIDFlag.NON_EQUIPABBLE),\n    }\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"ProtectorName\"),\n        \"summaries\": MsgsRetriever(\"ProtectorInfo\"),\n        \"descriptions\": MsgsRetriever(\"ProtectorCaption\"),\n    }\n\n    shop_retrievers = {\n        \"armor_shop\": ShopRetriever(\n            shop_lineup_id_min=110000, shop_lineup_id_max=112000,\n            material_set_id_min=900100, material_set_id_max=901000,\n        )\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        names = data.msgs[\"names\"]\n        effects = data.params[\"effects\"]\n        armor_shop = data.shops[\"armor_shop\"]\n\n        material = Material(row.index, Material.Category.PROTECTOR)\n        lineups = armor_shop.get_lineups_from_material(material)\n        assert len(lineups) in [0, 2], \"Each armor should have either none or self-/boc-made alterations\"\n        altered = \"\" if len(lineups) == 0 else cls.parse_name(names[lineups[0].product.index])\n\n        armor_effects = parse_effects(row, effects, \"residentSpEffectId\", \"residentSpEffectId2\", \"residentSpEffectId3\")\n\n        return Armor(\n            **cls.make_item(data, row, summary=False),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            category=ArmorCategory.from_row(row),\n            altered=altered,\n            weight=row[\"weight\"].as_float,\n            icon_fem=row[\"iconIdF\"].as_int,\n            absorptions=_get_absorptions(row),\n            resistances=_get_resistances(row),\n            effects=[Effect(**eff) for eff in armor_effects]\n        )"}
{"type": "source_file", "path": "src/erdb/table/gestures.py", "content": "from erdb.typing.models.gesture import Gesture\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import GoodsSortGroupID, ItemIDFlag\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\nclass GestureTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Gesture,\n    }\n\n    predicates: list[RowPredicate] = [\n        lambda row: row[\"sortGroupId\"].as_int == GoodsSortGroupID.GESTURES,\n    ]\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamGoods\", ItemIDFlag.GOODS)\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GoodsName\"),\n        \"summaries\": MsgsRetriever(\"GoodsInfo\"),\n        \"descriptions\": MsgsRetriever(\"GoodsCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        return Gesture(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\")\n        )"}
{"type": "source_file", "path": "src/erdb/typing/models/__init__.py", "content": "from __future__ import annotations\n\nfrom pydantic import ConfigDict, Extra, ConstrainedStr\n\n\ndef dt_config(title: str | None = None) -> ConfigDict:\n    return ConfigDict(\n        title=title,\n        extra=Extra.forbid,\n        allow_mutation=False,\n        frozen=True,\n        validate_all=True,\n        validate_assignment=True,\n    )\n\nclass NonEmptyStr(ConstrainedStr):\n    min_length = 1"}
{"type": "source_file", "path": "src/erdb/typing/models/ammo.py", "content": "from pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\nfrom erdb.typing.models import dt_config\nfrom erdb.typing.models.item import Item\nfrom erdb.typing.models.common import Damage\nfrom erdb.typing.models.effect import Effect, StatusEffects\nfrom erdb.typing.categories import AmmoCategory\n\n\n@dataclass(config=dt_config())\nclass Ammo(Item):\n    damage: Damage = Field(...,\n        description=\"Base attack power values.\",\n        example=Damage(physical=10, fire=90, stamina=5),\n    )\n    category: AmmoCategory = Field(...,\n        description=\"Category of the Ammo.\",\n        example=AmmoCategory.BOLT,\n    )\n    effects: list[Effect] = Field(...,\n        description=\"Effects of the Ammo.\",\n        # example provided by Effect model\n    )\n    status_effects: StatusEffects = Field(...,\n        description=\"Status effects of the Ammo, dealt on hit.\"\n        # example provided by StatusEffects model\n    )"}
{"type": "source_file", "path": "src/erdb/typing/game_version.py", "content": "import re\nfrom functools import total_ordering\nfrom pathlib import Path\nfrom typing import Any, Generator, NamedTuple, Self\n\n\n@total_ordering\nclass GameVersion(NamedTuple):\n    major: str\n    minor: str\n    patch: str\n    nums: list[int]\n\n    @classmethod\n    def from_nums(cls, major_int: int, minor_int: int, patch_int: int) -> Self:\n        major = str(major_int)\n        minor = f\"{minor_int:02}\"\n        patch = str(patch_int)\n\n        assert len(major) == 1\n        assert len(minor) == 2\n        assert len(patch) == 1\n\n        return cls(major, minor, patch, [major_int, minor_int, patch_int])\n\n    @classmethod\n    def from_string(cls, version: str) -> Self:\n        parts = version.split(\".\")\n        assert len(parts) == 3, \"Invalid version string given\"\n        assert len(parts[1]) >= 2, \"Minor part must be at least 2 digits\"\n\n        nums = [int(parts[0]), int(parts[1]), int(parts[2])]\n        return cls(parts[0], parts[1], parts[2], nums)\n\n    @classmethod\n    def from_any(cls, obj: Any) -> Self:\n        if isinstance(obj, GameVersion):\n            return obj\n\n        if isinstance(obj, str):\n            return GameVersion.from_string(obj)\n\n        if isinstance(obj, Path):\n            with open(obj, \"r\") as f:\n                data = f.read()\n            return GameVersion.from_string(data)\n\n        if isinstance(obj, list):\n            assert len(obj) == 3 and all(isinstance(elem, int) for elem in obj)\n            return GameVersion.from_nums(obj[0], obj[1], obj[2])\n\n        assert False, \"Cannot parse GameVersion\"\n\n    @classmethod\n    def min(cls) -> Self:\n        return cls(\"0\", \"00\", \"0\", [0, 0, 0])\n\n    @classmethod\n    def max(cls) -> Self:\n        return cls(\"99999\", \"99999\", \"99999\", [99999, 99999, 99999])\n\n    def __str__(self) -> str:\n        return f\"{self.major}.{self.minor}.{self.patch}\"\n\n    def __eq__(self, __o: object) -> bool:\n        if not isinstance(__o, GameVersion):\n            return False\n        return self.major == __o.major and self.minor == __o.minor and self.patch == __o.patch\n\n    def __lt__(self, __o: \"GameVersion\") -> bool:\n        assert isinstance(__o, GameVersion)\n        for this_num, other_num in zip(self.nums, __o.nums):\n            if this_num != other_num:\n                return this_num < other_num\n        return False\n\nclass GameVersionRange(NamedTuple):\n    begin: GameVersion # including\n    end: GameVersion   # excluding\n    only: bool=False   # only `begin`\n\n    def iterate(self, versions: list[GameVersion]) -> Generator[GameVersion, None, None]:\n        for version in versions:\n            if version in self:\n                yield version\n\n    @classmethod\n    def from_version(cls, version: GameVersion) -> Self:\n        return cls(version, GameVersion.max(), only=True)\n\n    @classmethod\n    def from_string(cls, string: str) -> Self:\n        def _ver(match: re.Match[str]) -> GameVersion:\n            return GameVersion.from_string(match.group(1))\n\n        if string == \"any version\":\n            return cls(GameVersion.min(), GameVersion.max())\n\n        if search_only := re.search(r\"only (\\d+\\.\\d\\d+\\.\\d+)\", string):\n            return cls(_ver(search_only), GameVersion.max(), only=True)\n\n        search_begin = re.search(r\"from (\\d+\\.\\d\\d+\\.\\d+)\", string)\n        search_end = re.search(r\"until (\\d+\\.\\d\\d+\\.\\d+)\", string)\n        assert search_begin or search_end, \"Invalid version range string\"\n\n        begin = _ver(search_begin) if search_begin else GameVersion.min()\n        end = _ver(search_end) if search_end else GameVersion.max()\n\n        assert begin < end, \"Invalid version range string\"\n        return cls(begin, end)\n\n    def __contains__(self, version: GameVersion) -> bool:\n        assert isinstance(version, GameVersion)\n        return self.begin == version if self.only \\\n            else self.begin <= version and version < self.end\n\nclass GameVersionInstance(NamedTuple):\n    application: GameVersion\n    regulation: GameVersion\n\n    @property\n    def effective(self) -> GameVersion:\n        return max(self.application, self.regulation)\n\n    @classmethod\n    def construct(cls, application: Any, regulation: Any) -> Self:\n        return cls(GameVersion.from_any(application), GameVersion.from_any(regulation))\n\n    def __str__(self) -> str:\n        return f\"(app: {self.application}, regulation: {self.regulation})\"\n"}
{"type": "source_file", "path": "src/erdb/table/info.py", "content": "from erdb.typing.models.info import Info\nfrom erdb.typing.params import ParamRow\nfrom erdb.typing.enums import GoodsType, ItemIDFlag\nfrom erdb.typing.categories import InfoCategory\nfrom erdb.typing.api_version import ApiVersion\nfrom erdb.table._retrievers import ParamDictRetriever, MsgsRetriever, RetrieverData\nfrom erdb.table._common import RowPredicate, TableSpecContext\n\n\nclass InfoTableSpec(TableSpecContext):\n    model = {\n        ApiVersion.VER_1: Info,\n    }\n\n    main_param_retriever = ParamDictRetriever(\"EquipParamGoods\", ItemIDFlag.GOODS)\n\n    predicates: list[RowPredicate] = [\n        lambda row: 1 <= row[\"sortId\"].as_int < 999999,\n        lambda row: row[\"goodsType\"] == GoodsType.INFO_ITEM,\n    ]\n\n    msg_retrievers = {\n        \"names\": MsgsRetriever(\"GoodsName\"),\n        \"summaries\": MsgsRetriever(\"GoodsInfo\"),\n        \"descriptions\": MsgsRetriever(\"GoodsCaption\")\n    }\n\n    @classmethod\n    def make_object(cls, api: ApiVersion, data: RetrieverData, row: ParamRow):\n        return Info(\n            **cls.make_item(data, row),\n            **cls.make_contrib(data, row, \"locations\", \"remarks\"),\n            category=InfoCategory.from_row(row),\n        )"}

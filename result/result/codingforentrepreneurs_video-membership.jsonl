{"repo_info": {"repo_name": "video-membership", "repo_owner": "codingforentrepreneurs", "repo_url": "https://github.com/codingforentrepreneurs/video-membership"}}
{"type": "test_file", "path": "app/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "app/tests/test_users.py", "content": "import pytest\nfrom app import db\nfrom app.users.models import User\n\n@pytest.fixture(scope='module')\ndef setup():\n    # setup\n    session = db.get_session()\n    yield session\n    # teardown\n    q = User.objects.filter(email='test@test.com')\n    if q.count() != 0:\n        q.delete()\n    session.shutdown()\n\ndef test_create_user(setup):\n    User.create_user(email='test@test.com', password='abc123')\n\ndef test_duplicate_user(setup):\n    with pytest.raises(Exception):\n        User.create_user(email='test@test.com', password='abc123dafd')\n\ndef test_invalid_email(setup):\n    with pytest.raises(Exception):\n        User.create_user(email='test@test', password='abc123dafd')\n\ndef test_valid_password(setup):\n    q = User.objects.filter(email='test@test.com')\n    assert q.count() == 1\n    user_obj = q.first()\n    assert user_obj.verify_password('abc123') == True\n    assert user_obj.verify_password('abc1234') == False\n\n# def test_assert():\n#     assert True is True\n\n\n# def test_equal():\n#     assert 1 == 1\n\n# def test_equal():\n#     assert 1 != 1\n\n# def test_invalid_assert():\n#     with pytest.raises(AssertionError):\n#         assert True is not True"}
{"type": "source_file", "path": "app/indexing/client.py", "content": "from algoliasearch.search_client import SearchClient\n\nfrom app import config\n\n\nfrom app.playlists.models import Playlist\nfrom app.videos.models import Video\n\nfrom .schemas import (\n    PlaylistIndexSchema,\n    VideoIndexSchema\n)\n\nsettings = config.get_settings()\n\ndef get_index():\n    client = SearchClient.create(\n            settings.algolia_app_id, \n            settings.algolia_api_key\n    )\n    index = client.init_index(settings.algolia_index_name)\n    return index\n\n\ndef get_dataset():\n    playlist_q = [dict(x) for x in Playlist.objects.all()]\n    playlists_dataset = [PlaylistIndexSchema(**x).dict() for x in playlist_q]\n    video_q = [dict(x) for x in Video.objects.all()]\n    videos_dataset = [VideoIndexSchema(**x).dict() for x in video_q]\n    dataset = videos_dataset + playlists_dataset\n    return dataset\n\ndef update_index():\n    index = get_index()\n    dataset = get_dataset()\n    idx_resp = index.save_objects(dataset).wait()\n    try:\n        count = len(list(idx_resp)[0]['objectIDs'])\n    except:\n        count = None\n    return count\n\n\ndef search_index(query):\n    index = get_index()\n    return index.search(query)"}
{"type": "source_file", "path": "app/handlers.py", "content": "\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\nfrom app.main import app\nfrom app.shortcuts import render, redirect, is_htmx\nfrom app.users.exceptions import LoginRequiredException\n\n@app.exception_handler(StarletteHTTPException)\nasync def http_exception_handler(request, exc):\n    status_code = exc.status_code\n    template_name = 'errors/main.html'\n    if status_code == 404:\n        template_name = 'errors/404.html'\n    context = {\"status_code\": status_code}\n    return render(request, template_name, context, status_code=status_code)\n\n\n@app.exception_handler(LoginRequiredException)\nasync def login_required_exception_handler(request, exc):\n    response = redirect(f\"/login?next={request.url}\", remove_session=True)\n    if is_htmx(request):\n        response.status_code = 200\n        response.headers['HX-Redirect'] = f\"/login\"\n    return response"}
{"type": "source_file", "path": "app/config.py", "content": "import os\nfrom pathlib import Path\nfrom functools import lru_cache\nfrom pydantic import BaseSettings, Field\n\nos.environ['CQLENG_ALLOW_SCHEMA_MANAGEMENT'] = \"1\"\n\nclass Settings(BaseSettings):\n    base_dir: Path = Path(__file__).resolve().parent\n    templates_dir: Path = Path(__file__).resolve().parent / \"templates\"\n    keyspace: str = Field(..., env='ASTRADB_KEYSPACE')\n    db_client_id: str = Field(..., env='ASTRADB_CLIENT_ID')\n    db_client_secret: str = Field(..., env='ASTRADB_CLIENT_SECRET')\n    secret_key: str = Field(...)\n    jwt_algorithm: str = Field(default='HS256')\n    session_duration: int = Field(default=86400)\n    algolia_app_id: str\n    algolia_api_key: str\n    algolia_index_name: str\n\n    class Config:\n        env_file = '.env'\n\n\n@lru_cache\ndef get_settings():\n    return Settings()"}
{"type": "source_file", "path": "app/db.py", "content": "import pathlib\nfrom cassandra.cluster import Cluster\nfrom cassandra.auth import PlainTextAuthProvider\nfrom cassandra.cqlengine import connection\n\nfrom . import config\n\nBASE_DIR = pathlib.Path(__file__).resolve().parent\n\nsettings = config.get_settings()\n\nASTRADB_CONNECT_BUNDLE = BASE_DIR / \"unencrypted\" / \"astradb_connect.zip\"\n\nASTRADB_CLIENT_ID = settings.db_client_id\nASTRADB_CLIENT_SECRET = settings.db_client_secret\n\ndef get_session():\n    cloud_config= {\n            'secure_connect_bundle': ASTRADB_CONNECT_BUNDLE\n    }\n    auth_provider = PlainTextAuthProvider(ASTRADB_CLIENT_ID, ASTRADB_CLIENT_SECRET)\n    cluster = Cluster(cloud=cloud_config, auth_provider=auth_provider)\n    session = cluster.connect()\n    connection.register_connection(str(session), session=session)\n    connection.set_default_connection(str(session))\n    return session"}
{"type": "source_file", "path": "app/playlists/__init__.py", "content": ""}
{"type": "source_file", "path": "app/users/decorators.py", "content": "from functools import wraps\nfrom fastapi import Request\nfrom .exceptions import LoginRequiredException\n\ndef login_required(func):\n    @wraps(func)\n    def wrapper(request: Request, *args, **kwargs):\n        if not request.user.is_authenticated:\n            raise LoginRequiredException(status_code=401)\n        return func(request, *args, **kwargs)\n    return wrapper"}
{"type": "source_file", "path": "app/users/backends.py", "content": "from starlette.authentication import (\n    AuthenticationBackend,\n    SimpleUser,\n    UnauthenticatedUser,\n    AuthCredentials\n)\n\nfrom . import auth\n\nclass JWTCookieBackend(AuthenticationBackend):\n    async def authenticate(self, request):\n        session_id = request.cookies.get(\"session_id\")\n        user_data = auth.verify_user_id(session_id)\n        if user_data is None:\n            # anon user\n            roles = [\"anon\"]\n            return AuthCredentials(roles), UnauthenticatedUser()\n        user_id = user_data.get(\"user_id\")\n        roles = ['authenticated']\n        return AuthCredentials(roles), SimpleUser(user_id)"}
{"type": "source_file", "path": "app/shortcuts.py", "content": "from app import config\n\nfrom cassandra.cqlengine.query import (DoesNotExist, MultipleObjectsReturned)\n\nfrom fastapi import Request\nfrom fastapi.responses import HTMLResponse, RedirectResponse\nfrom fastapi.templating import Jinja2Templates\n\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\nsettings = config.get_settings()\ntemplates = Jinja2Templates(directory=str(settings.templates_dir))\n\n\n\ndef is_htmx(request:Request):\n    return request.headers.get(\"hx-request\") == 'true'\n\n\ndef get_object_or_404(KlassName, **kwargs):\n    obj = None\n    try:\n        obj = KlassName.objects.get(**kwargs)\n    except DoesNotExist:\n        raise StarletteHTTPException(status_code=404)\n    except MultipleObjectsReturned:\n        raise StarletteHTTPException(status_code=400)\n    except:\n        raise StarletteHTTPException(status_code=500)\n    return obj\n\ndef redirect(path, cookies:dict={}, remove_session=False):\n    response = RedirectResponse(path, status_code=302)\n    for k, v in cookies.items():\n        response.set_cookie(key=k, value=v, httponly=True)\n    if remove_session:\n        response.set_cookie(key='session_ended', value=1, httponly=True)\n        response.delete_cookie('session_id')\n    return response\n\n\n\ndef render(request, template_name, context={}, status_code:int=200, cookies:dict={}):\n    ctx = context.copy()\n    ctx.update({\"request\": request})\n    t = templates.get_template(template_name)\n    html_str = t.render(ctx)\n    response = HTMLResponse(html_str, status_code=status_code)\n    # print(request.cookies)\n    response.set_cookie(key='darkmode', value=1)\n    if len(cookies.keys()) > 0:\n        \n        # set httponly cookies\n        for k, v in cookies.items():\n            response.set_cookie(key=k, value=v, httponly=True)\n    # delete coookies\n    # for key in request.cookies.keys():\n    #     response.delete_cookie(key)\n    return response"}
{"type": "source_file", "path": "app/playlists/schemas.py", "content": "import uuid\nfrom pydantic import (\n    BaseModel,\n    validator,\n    root_validator\n)\n\nfrom app.videos.extractors import extract_video_id\nfrom app.videos.models import Video\n\nfrom .models import Playlist\n\nclass PlaylistCreateSchema(BaseModel):\n    title: str # user generated\n    user_id: uuid.UUID # request.session user_id\n\n\nclass PlaylistVideoAddSchema(BaseModel):\n    url: str # user generated\n    title: str # user generated\n    user_id: uuid.UUID # request.session user_id\n    playlist_id: uuid.UUID  # Playlist db_id\n\n    @validator(\"url\")\n    def validate_youtube_url(cls, v, values, **kwargs):\n        url = v\n        video_id = extract_video_id(url)\n        if video_id is None:\n            raise ValueError(f\"{url} is not a valid YouTube URL\")\n        return url\n\n    @validator(\"playlist_id\")\n    def validate_playlist_id(cls, v, values, **kwargs):\n        q = Playlist.objects.filter(db_id=v)\n        if q.count() == 0:\n            raise ValueError(f\"{v} is not a valid Playlist\")\n        return v\n\n    @root_validator\n    def validate_data(cls, values):\n        url = values.get(\"url\")\n        title = values.get(\"title\")\n        playlist_id = values.get('playlist_id')\n        if url is None:\n            raise ValueError(\"A valid url is required.\")\n        user_id = values.get(\"user_id\")\n        video_obj = None\n        extra_data = {}\n        if title is not None:\n            extra_data['title'] = title\n        try:\n            video_obj, created = Video.get_or_create(url, user_id=user_id, **extra_data)\n        except:\n            raise ValueError(\"There's a problem with your request, please try again.\")\n        if not isinstance(video_obj, Video):\n            raise ValueError(\"There's a problem with your account, please try again.\")\n        if playlist_id:\n            playlist_obj = Playlist.objects.get(db_id=playlist_id)\n            playlist_obj.add_host_ids(host_ids=[video_obj.host_id])\n            playlist_obj.save()\n        return video_obj.as_data()\n\n\n        "}
{"type": "source_file", "path": "app/main.py", "content": "import json\nimport pathlib\nfrom typing import Optional\n\nfrom fastapi import FastAPI, Request, Form, HTTPException\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.templating import Jinja2Templates\nfrom starlette.middleware.authentication import AuthenticationMiddleware\nfrom starlette.authentication import requires\nfrom cassandra.cqlengine.management import sync_table\nfrom pydantic.error_wrappers import ValidationError\nfrom . import config, db, utils\n\nfrom .indexing.client import (\n    update_index,\n    search_index\n)\nfrom .playlists.routers import router as playlist_router\n\nfrom .shortcuts import redirect, render\nfrom .users.backends import JWTCookieBackend\nfrom .users.decorators import login_required\nfrom .users.models import User\nfrom .users.schemas import (\n    UserLoginSchema,\n    UserSignupSchema\n)\nfrom .videos.models import Video\nfrom .videos.routers import router as video_router\n\nfrom .watch_events.models import WatchEvent\nfrom .watch_events.routers import router as watch_event_router\n\nDB_SESSION = None\nBASE_DIR = pathlib.Path(__file__).resolve().parent # app/\n\napp = FastAPI()\napp.add_middleware(AuthenticationMiddleware, backend=JWTCookieBackend())\napp.include_router(playlist_router)\napp.include_router(video_router)\napp.include_router(watch_event_router)\n\n\nfrom .handlers import * # noqa\n\n\n@app.on_event(\"startup\")\ndef on_startup():\n    # triggered when fastapi starts\n    print(\"hello world\")\n    global DB_SESSION\n    DB_SESSION = db.get_session()\n    sync_table(User)\n    sync_table(Video)\n    sync_table(WatchEvent)\n\n\n@app.get(\"/\", response_class=HTMLResponse)\ndef homepage(request: Request):\n    if request.user.is_authenticated:\n        return render(request, \"dashboard.html\", {}, status_code=200)\n    return render(request, \"home.html\", {})\n\n\n@app.get(\"/account\", response_class=HTMLResponse)\n@login_required\ndef account_view(request: Request):\n    \"\"\"\n    hello world\n    \"\"\"\n    context = {}\n    return render(request, \"account.html\", context)\n\n@app.get(\"/login\", response_class=HTMLResponse)\ndef login_get_view(request: Request):\n    return render(request, \"auth/login.html\", {})\n\n\n@app.post(\"/login\", response_class=HTMLResponse)\ndef login_post_view(request: Request, \n    email: str=Form(...), \n    password: str = Form(...),\n    next: Optional[str] = \"/\"\n    ):\n\n    raw_data  = {\n        \"email\": email,\n        \"password\": password,\n       \n    }\n    data, errors = utils.valid_schema_data_or_error(raw_data, UserLoginSchema)\n    context = {\n                \"data\": data,\n                \"errors\": errors,\n            }\n    if len(errors) > 0:\n        return render(request, \"auth/login.html\", context, status_code=400)\n    if \"http://127.0.0.1\" not in next:\n        next = '/'\n    return redirect(next, cookies=data)\n\n\n@app.get(\"/logout\", response_class=HTMLResponse)\ndef logout_get_view(request: Request):\n    if not request.user.is_authenticated:\n        return redirect('/login')\n    return render(request, \"auth/logout.html\", {})\n\n@app.post(\"/logout\", response_class=HTMLResponse)\ndef logout_post_view(request: Request):\n    return redirect(\"/login\", remove_session=True)\n\n@app.get(\"/signup\", response_class=HTMLResponse)\ndef signup_get_view(request: Request):\n    return render(request, \"auth/signup.html\")\n\n\n@app.post(\"/signup\", response_class=HTMLResponse)\ndef signup_post_view(request: Request, \n    email: str=Form(...), \n    password: str = Form(...),\n    password_confirm: str = Form(...)\n    ):\n    raw_data  = {\n        \"email\": email,\n        \"password\": password,\n        \"password_confirm\": password_confirm\n    }\n    data, errors = utils.valid_schema_data_or_error(raw_data, UserSignupSchema)\n    if len(errors) > 0:\n        return render(request, \"auth/signup.html\", context, status_code=400)\n    return redirect(\"/login\")\n\n\n@app.post('/update-index', response_class=HTMLResponse)\ndef htmx_update_index_view(request:Request):\n    count = update_index()\n    return HTMLResponse(f\"({count}) Refreshed\")\n\n\n@app.get(\"/search\", response_class=HTMLResponse)\ndef search_detail_view(request:Request, q:Optional[str] = None):\n    query = None\n    context = {}\n    if q is not None:\n        query = q\n        results = search_index(query)\n        hits = results.get('hits') or []\n        num_hits = results.get('nbHits')\n        context = {\n            \"query\": query,\n            \"hits\": hits,\n            \"num_hits\": num_hits\n        }\n    return render(request, \"search/detail.html\", context)\n"}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/indexing/__init__.py", "content": ""}
{"type": "source_file", "path": "app/videos/exceptions.py", "content": "class InvalidYouTubeVideoURLException(Exception):\n    \"\"\"\n    Invalid YouTube Video URL\n    \"\"\"\n\nclass VideoAlreadyAddedException(Exception):\n    \"\"\"\n    Video already added\n    \"\"\""}
{"type": "source_file", "path": "app/users/security.py", "content": "from argon2 import PasswordHasher\nfrom argon2.exceptions import VerifyMismatchError\n\ndef generate_hash(pw_raw):\n    ph = PasswordHasher()\n    return ph.hash(pw_raw)\n\ndef verify_hash(pw_hash, pw_raw):\n    ph = PasswordHasher()\n    verified = False\n    msg = \"\"\n    try:\n        verified = ph.verify(pw_hash, pw_raw)\n    except VerifyMismatchError:\n        verified = False\n        msg = \"Invalid password.\"\n    except Exception as e:\n        verified = False\n        msg = f\"Unexpected error: \\n{e}\"\n    return verified, msg"}
{"type": "source_file", "path": "app/playlists/models.py", "content": "from datetime import datetime # datetime.datetime\nimport uuid\n\nfrom cassandra.cqlengine import columns\nfrom cassandra.cqlengine.models import Model\n\nfrom app import config\nfrom app.videos.models import Video\n\nsettings = config.get_settings()\n\n# [1, 2, 3] -> columns.Integer\n\nclass Playlist(Model):\n    __keyspace__ = settings.keyspace\n    db_id = columns.UUID(primary_key=True, default=uuid.uuid1)\n    user_id = columns.UUID()\n    updated = columns.DateTime(default=datetime.utcnow())\n    host_ids = columns.List(value_type=columns.Text) # [\"abc123\"]\n    title = columns.Text()\n\n    @property\n    def path(self):\n        return f\"/playlists/{self.db_id}\"\n\n    def add_host_ids(self, host_ids=[], replace_all=False):\n        if not isinstance(host_ids, list):\n            return False\n        if replace_all:\n            self.host_ids = host_ids\n        else:\n            self.host_ids += host_ids\n        self.updated = datetime.utcnow()\n        self.save()\n        return True\n\n    def get_videos(self):\n        videos = []\n        for host_id in self.host_ids:\n            try:\n                video_obj = Video.objects.get(host_id=host_id)\n            except:\n                video_obj = None\n            if video_obj is not None:\n                videos.append(video_obj)\n        return videos"}
{"type": "source_file", "path": "app/indexing/schemas.py", "content": "import uuid\nimport json\nfrom pydantic import BaseModel, Field, validator, root_validator\nfrom typing import Optional\n\n\nclass VideoIndexSchema(BaseModel):\n    objectID: str = Field(alias='host_id')\n    objectType: str = \"Video\"\n    title: Optional[str]\n    path: str = Field(alias='host_id')\n    # related -> playlist names\n        \n    @validator(\"path\")\n    def set_path(cls, v, values, **kwargs):\n        host_id = v\n        return f\"/videos/{host_id}\"\n\n\nclass PlaylistIndexSchema(BaseModel):\n    objectID: uuid.UUID = Field(alias='db_id')\n    objectType: str = \"Playlist\"\n    title: Optional[str]\n    path: str = Field(default='/')\n    # related -> host_ids -> Video Title\n    \n    @root_validator\n    def set_defaults(cls, values):\n        objectID = values.get('objectID')\n        values['objectID'] = str(objectID)\n        values['path'] = f\"/playlists/{objectID}\"\n        return values"}
{"type": "source_file", "path": "app/users/__init__.py", "content": ""}
{"type": "source_file", "path": "app/users/schemas.py", "content": "from pydantic import (\n    BaseModel, \n    EmailStr, \n    SecretStr, \n    validator,\n    root_validator\n)\n\nfrom . import auth\nfrom .models import User\n\nclass UserLoginSchema(BaseModel):\n    email: EmailStr\n    password: SecretStr\n    session_id: str = None\n\n    @root_validator\n    def validate_user(cls, values):\n        err_msg = \"Incorrect credentials, please try again.\"\n        email = values.get(\"email\") or None\n        password = values.get(\"password\") or None\n        if email is None or password is None:\n            raise ValueError(err_msg)\n        password = password.get_secret_value()\n        user_obj = auth.authenticate(email, password)\n        if user_obj is None:\n            raise ValueError(err_msg)\n        token = auth.login(user_obj)\n        return {\"session_id\": token}\n\n\n\n\nclass UserSignupSchema(BaseModel):\n    email: EmailStr\n    password: SecretStr\n    password_confirm: SecretStr\n        \n    \n    @validator(\"email\")\n    def email_available(cls, v, values, **kwargs):\n        q = User.objects.filter(email=v)\n        if q.count() != 0:\n            raise ValueError(\"Email is not available\")\n        return v\n        \n    @validator(\"password_confirm\")\n    def passwords_match(cls, v, values, **kwargs):\n        password = values.get('password')\n        password_confirm = v\n        if password != password_confirm:\n            raise ValueError(\"Passwords do not match\")\n        return v"}
{"type": "source_file", "path": "app/users/models.py", "content": "import uuid\nfrom app.config import get_settings\nfrom cassandra.cqlengine import columns\nfrom cassandra.cqlengine.models import Model\n\n\nfrom . import exceptions, security, validators\n\nsettings = get_settings()\n\nclass User(Model):\n    __keyspace__ = settings.keyspace\n    email = columns.Text(primary_key=True)\n    user_id = columns.UUID(primary_key=True, default=uuid.uuid1) # UUID1\n    password = columns.Text() # secure\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return f\"User(email={self.email}, user_id={self.user_id})\"\n\n    def set_password(self, pw, commit=False):\n        pw_hash = security.generate_hash(pw)\n        self.password = pw_hash\n        if commit:\n            self.save()\n        return True\n\n    def verify_password(self, pw_str):\n        pw_hash = self.password\n        verified, _ = security.verify_hash(pw_hash, pw_str)\n        return verified\n\n    @staticmethod\n    def create_user(email, password=None):\n        q = User.objects.filter(email=email)\n        if q.count() != 0:\n            raise exceptions.UserHasAccountException(\"User already has account.\")\n        valid, msg, email = validators._validate_email(email)\n        if not valid:\n            raise exceptions.InvalidEmailException(f\"Invalid email: {msg}\")\n        obj = User(email=email)\n        obj.set_password(password)\n        # obj.password = password\n        obj.save()\n        return obj\n\n    @staticmethod\n    def check_exists(user_id):\n        q = User.objects.filter(user_id=user_id).allow_filtering()\n        return q.count() != 0\n    \n    @staticmethod\n    def by_user_id(user_id=None):\n        if user_id is None:\n            return None\n        q = User.objects.filter(user_id=user_id).allow_filtering()\n        if q.count() != 1:\n            return None\n        return q.first()"}
{"type": "source_file", "path": "app/videos/__init__.py", "content": ""}
{"type": "source_file", "path": "app/playlists/routers.py", "content": "import uuid\nfrom typing import Optional\nfrom starlette.exceptions import HTTPException\n\n\nfrom fastapi import APIRouter, Request, Form, Depends\nfrom fastapi.responses import HTMLResponse\n\nfrom app import utils\nfrom app.users.decorators import login_required\nfrom app.shortcuts import (\n    render,\n    redirect, \n    get_object_or_404,\n    is_htmx\n)\nfrom app.videos.schemas import VideoCreateSchema\n\nfrom app.watch_events.models import WatchEvent\nfrom .models import Playlist\nfrom .schemas import PlaylistCreateSchema, PlaylistVideoAddSchema\n\n\nrouter = APIRouter(\n    prefix='/playlists'\n)\n\n\n@router.get(\"/create\", response_class=HTMLResponse)\n@login_required\ndef playlist_create_view(request: Request):\n    return render(request, \"playlists/create.html\", {})\n\n@router.post(\"/create\", response_class=HTMLResponse)\n@login_required\ndef playlist_create_post_view(request: Request, title: str=Form(...)):\n    raw_data = {\n        \"title\": title,\n        \"user_id\": request.user.username\n    }\n    data, errors = utils.valid_schema_data_or_error(raw_data, PlaylistCreateSchema)\n    context = {\n        \"data\": data,\n        \"errors\": errors,\n    }\n    if len(errors) > 0:\n        return render(request, \"playlists/create.html\", context, status_code=400)\n    obj = Playlist.objects.create(**data)\n    redirect_path = obj.path or \"/playlists/create\" \n    return redirect(redirect_path)\n\n\n@router.get(\"/\", response_class=HTMLResponse)\ndef playlist_list_view(request: Request):\n    q = Playlist.objects.all().limit(100)\n    context = {\n        \"object_list\": q\n    }\n    return render(request, \"playlists/list.html\", context)\n\n# host_id='playlist-1'\n# f\"{host_id} is cool\"\n\n@router.get(\"/{db_id}\", response_class=HTMLResponse)\ndef playlist_detail_view(request: Request, db_id: uuid.UUID):\n    obj = get_object_or_404(Playlist, db_id=db_id)\n    if request.user.is_authenticated:\n        user_id = request.user.username\n    context = {\n        \"object\": obj,\n        \"videos\": obj.get_videos(),\n    }\n    return render(request, \"playlists/detail.html\", context) \n\n\n\n\n@router.get(\"/{db_id}/add-video\", response_class=HTMLResponse)\n@login_required\ndef playlist_video_add_view(\n    request: Request, \n    db_id: uuid.UUID,\n    is_htmx=Depends(is_htmx),\n    ):\n    context = {\"db_id\": db_id}\n    if not is_htmx:\n        raise HTTPException(status_code=400)\n    return render(request, \"playlists/htmx/add-video.html\", context)\n    \n\n\n@router.post(\"/{db_id}/add-video\", response_class=HTMLResponse)\n@login_required\ndef playlist_video_add_post_view(\n    request: Request,\n    db_id: uuid.UUID,\n    is_htmx=Depends(is_htmx), \n    title: str=Form(...), \n    url: str = Form(...)):\n    raw_data = {\n        \"title\": title,\n        \"url\": url,\n        \"user_id\": request.user.username,\n        \"playlist_id\": db_id\n    }\n    data, errors = utils.valid_schema_data_or_error(raw_data, PlaylistVideoAddSchema)\n    redirect_path = data.get('path') or f\"/playlists/{db_id}\" \n    \n    context = {\n        \"data\": data,\n        \"errors\": errors,\n        \"title\": title,\n        \"url\": url,\n        \"db_id\": db_id,\n    }\n\n    if not is_htmx:\n        raise HTTPException(status_code=400)\n    \"\"\"\n    Handle all HTMX requests\n    \"\"\"\n    if len(errors) > 0:\n        return render(request, \"playlists/htmx/add-video.html\", context)\n    context = {\"path\": redirect_path, \"title\": data.get('title')}\n    return render(request, \"videos/htmx/link.html\", context)\n\n\n\n@router.post(\"/{db_id}/{host_id}/delete/\", response_class=HTMLResponse)\ndef playlist_remove_video_item_view(\n        request: Request, \n        db_id: uuid.UUID,\n        host_id: str,\n        is_htmx=Depends(is_htmx),\n        index: Optional[int] = Form(default=None)\n    ):\n    if not is_htmx:\n        raise HTTPException(status_code=400)\n    try:\n        obj = get_object_or_404(Playlist, db_id=db_id)\n    except:\n        return HTMLResponse(\"Error. Please reload the page.\")\n    if not request.user.is_authenticated:\n        return HTMLResponse(\"Please login and continue\")\n    if isinstance(index, int):\n        host_ids = obj.host_ids\n        host_ids.pop(index)\n        obj.add_host_ids(host_ids=host_ids, replace_all=True)\n    return HTMLResponse(\"Deleted\")"}
{"type": "source_file", "path": "app/users/validators.py", "content": "from email_validator import EmailNotValidError, validate_email\n\ndef _validate_email(email):\n    msg = \"\"\n    valid = False\n    try:\n        valid = validate_email(email)\n        # update the email var with a normalized value\n        email = valid.email\n        valid = True\n    except EmailNotValidError as e:\n        msg = str(e)\n    return valid, msg, email\n"}
{"type": "source_file", "path": "app/users/auth.py", "content": "import datetime\nfrom jose import jwt, ExpiredSignatureError\nfrom app import config\n\nfrom .models import User\n\nsettings = config.get_settings()\n\ndef authenticate(email, password):\n    # step 1\n    try:\n        user_obj = User.objects.get(email=email)\n    except Exception as e:\n        user_obj = None\n    if not user_obj.verify_password(password):\n        return None\n    return user_obj\n\ndef login(user_obj, expires=settings.session_duration):\n    # step 2\n    raw_data = {\n        \"user_id\": f\"{user_obj.user_id}\",\n        \"role\": \"admin\",\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(seconds=expires)\n    }\n    return jwt.encode(raw_data, settings.secret_key, algorithm=settings.jwt_algorithm)\n\n\ndef verify_user_id(token):\n    # step 3\n    data = {}\n    try:\n        data = jwt.decode(token, settings.secret_key, algorithms=[settings.jwt_algorithm])\n    except ExpiredSignatureError as e:\n        print(e, \"log out user\")\n    except:\n        pass\n    if 'user_id' not in data:\n        return None\n    # if 'user_id' not in data.keys():\n    #     return None\n    return data"}
{"type": "source_file", "path": "app/users/exceptions.py", "content": "from fastapi import HTTPException\n\n\nclass LoginRequiredException(HTTPException):\n    pass\n\n# class LoginRequiredException(Exception):\n#     pass\n\n\nclass UserHasAccountException(Exception):\n    \"\"\"User already has account.\"\"\"\n\n\nclass InvalidEmailException(Exception):\n    \"\"\"Invalid email\"\"\"\n\nclass InvalidUserIDException(Exception):\n    \"\"\"Invalid user id\"\"\"\n"}
{"type": "source_file", "path": "app/utils.py", "content": "import json\nfrom pydantic import BaseModel, error_wrappers\n\n\ndef valid_schema_data_or_error(raw_data: dict, SchemaModel:BaseModel):\n    data = {}\n    errors = []\n    error_str = None\n    try:\n        cleaned_data = SchemaModel(**raw_data)\n        data = cleaned_data.dict()\n    except error_wrappers.ValidationError as e:\n        error_str = e.json()\n    if error_str is not None:\n        try:\n            errors = json.loads(error_str)\n        except Exception as e:\n            errors = [{\"loc\": \"non_field_error\", \"msg\": \"Unknown error\"}]\n    return data, errors"}
{"type": "source_file", "path": "app/videos/extractors.py", "content": "from urllib.parse import parse_qs, urlparse\n\n\ndef extract_video_id(url):\n    # Source: https://stackoverflow.com/a/54383711\n    # Examples:\n    # - http://youtu.be/nNpvWBuTfrc\n    # - http://www.youtube.com/watch?v=nNpvWBuTfrc&feature=feedu\n    # - http://www.youtube.com/embed/nNpvWBuTfrc\n    # - http://www.youtube.com/v/nNpvWBuTfrc?version=3&amp;hl=en_US\n    query = urlparse(url)\n    if query.hostname == \"youtu.be\":\n        return query.path[1:]\n    if query.hostname in {\"www.youtube.com\", \"youtube.com\"}:\n        if query.path == \"/watch\":\n            return parse_qs(query.query)[\"v\"][0]\n        if query.path[:7] == \"/watch/\":\n            return query.path.split(\"/\")[1]\n        if query.path[:7] == \"/embed/\":\n            return query.path.split(\"/\")[2]\n        if query.path[:3] == \"/v/\":\n            return query.path.split(\"/\")[2]\n        # # below is optional for playlists\n        # if query.path[:9] == \"/playlist\":\n        #     return parse_qs(query.query)[\"list\"][0]\n    return None"}
{"type": "source_file", "path": "app/videos/models.py", "content": "import uuid\nfrom app.config import get_settings\nfrom app.users.exceptions import InvalidUserIDException\nfrom app.users.models import User\nfrom app.shortcuts import templates\n\nfrom cassandra.cqlengine import columns\nfrom cassandra.cqlengine.models import Model\nfrom cassandra.cqlengine.query import (DoesNotExist, MultipleObjectsReturned)\n\nsettings = get_settings()\n\nfrom .exceptions import (\n    InvalidYouTubeVideoURLException, \n    VideoAlreadyAddedException\n)\nfrom .extractors import extract_video_id\n\n\n# Unlisted Video -> video_id -> lock it down\n\nclass Video(Model):\n    __keyspace__ = settings.keyspace\n    host_id = columns.Text(primary_key=True) # YouTube, Vimeo\n    db_id = columns.UUID(primary_key=True, default=uuid.uuid1) # UUID1\n    host_service = columns.Text(default='youtube')\n    title = columns.Text()\n    url = columns.Text() # secure\n    user_id = columns.UUID()\n\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return f\"Video(title={self.title}, host_id={self.host_id}, host_service={self.host_service})\"\n\n    def render(self):\n        basename = self.host_service # youtube, vimeo\n        template_name = f\"videos/renderers/{basename}.html\"\n        context = {\"host_id\": self.host_id}\n        t = templates.get_template(template_name)\n        return t.render(context)\n\n    def as_data(self):\n        return {f\"{self.host_service}_id\": self.host_id, \"path\": self.path, \"title\": self.title}\n\n    @property\n    def path(self):\n        return f\"/videos/{self.host_id}\"\n    \n    @staticmethod\n    def get_or_create(url, user_id=None, **kwargs):\n        host_id = extract_video_id(url)\n        obj = None\n        created = False\n        try:\n            obj = Video.objects.get(host_id=host_id)\n        except MultipleObjectsReturned:\n            q = Video.objects.allow_filtering().filter(host_id=host_id)\n            obj = q.first()\n        except DoesNotExist:\n            obj = Video.add_video(url, user_id=user_id, **kwargs)\n            created = True\n        except:\n            raise Exception(\"Invalid Request\")\n        return obj, created\n\n    def update_video_url(self, url, save=True):\n        host_id = extract_video_id(url)\n        if not host_id:\n            return None\n        self.url = url\n        self.host_id = host_id\n        if save:\n            self.save()\n        return url\n\n    @staticmethod\n    def add_video(url, user_id=None, **kwargs):\n        # extract video_id from url\n        # video_id = host_id\n        # Service API - YouTube / Vimeo / etc\n        host_id = extract_video_id(url)\n        if host_id is None:\n            raise InvalidYouTubeVideoURLException(\"Invalid YouTube Video URL\")\n        user_exists = User.check_exists(user_id)\n        if user_exists is None:\n            raise InvalidUserIDException(\"Invalid user_id\")\n        # user_obj = User.by_user_id(user_id)\n        # user_obj.display_name\n        q = Video.objects.allow_filtering().filter(host_id=host_id) # , user_id=user_id)\n        if q.count() != 0:\n            raise VideoAlreadyAddedException(\"Video already added\")\n        return Video.create(host_id=host_id, user_id=user_id, url=url, **kwargs)\n\n\n\n# class PrivateVideo(Video):\n# pass"}
{"type": "source_file", "path": "app/videos/schemas.py", "content": "import uuid\nfrom pydantic import (\n    BaseModel,\n    validator,\n    root_validator\n)\n\nfrom app.users.exceptions import InvalidUserIDException\n\n\nfrom .exceptions import (\n    InvalidYouTubeVideoURLException, \n    VideoAlreadyAddedException\n)\nfrom .extractors import extract_video_id\nfrom .models import Video\n\nclass VideoCreateSchema(BaseModel):\n    url: str # user generated\n    title: str # user generated\n    user_id: uuid.UUID # request.session user_id\n\n    @validator(\"url\")\n    def validate_youtube_url(cls, v, values, **kwargs):\n        url = v\n        video_id = extract_video_id(url)\n        if video_id is None:\n            raise ValueError(f\"{url} is not a valid YouTube URL\")\n        return url\n\n    @root_validator\n    def validate_data(cls, values):\n        url = values.get(\"url\")\n        title = values.get(\"title\")\n        if url is None:\n            raise ValueError(\"A valid url is required.\")\n        user_id = values.get(\"user_id\")\n        video_obj = None\n        extra_data = {}\n        if title is not None:\n            extra_data['title'] = title\n        try:\n            video_obj = Video.add_video(url, user_id=user_id, **extra_data)\n        except InvalidYouTubeVideoURLException:\n            raise ValueError(f\"{url} is not a valid YouTube URL\")\n        except VideoAlreadyAddedException:\n            raise ValueError(f\"{url} has already been added to your account.\")\n        except InvalidUserIDException:\n            raise ValueError(\"There's a problem with your account, please try again.\")\n        except:\n            raise ValueError(\"There's a problem with your account, please try again.\")\n        if video_obj is None:\n            raise ValueError(\"There's a problem with your account, please try again.\")\n        if not isinstance(video_obj, Video):\n            raise ValueError(\"There's a problem with your account, please try again.\")\n        # if title is not None:\n        #     video_obj.title = title\n        #     video_obj.save()\n        return video_obj.as_data()\n\n\n        \n    \n\nclass VideoEditSchema(BaseModel):\n    url: str # user generated\n    title: str # user generated\n\n    @validator(\"url\")\n    def validate_youtube_url(cls, v, values, **kwargs):\n        url = v\n        video_id = extract_video_id(url)\n        if video_id is None:\n            raise ValueError(f\"{url} is not a valid YouTube URL\")\n        return url\n"}
{"type": "source_file", "path": "app/watch_events/models.py", "content": "import uuid # timeuuid\n\nfrom cassandra.cqlengine import columns\nfrom cassandra.cqlengine.models import Model\n\nfrom app import config\n\nsettings = config.get_settings()\n\n\nclass WatchEvent(Model):\n    __keyspace__ = settings.keyspace\n    host_id = columns.Text(primary_key=True)\n    event_id = columns.TimeUUID(primary_key=True, clustering_order=\"DESC\", default=uuid.uuid1)\n    user_id = columns.UUID(primary_key=True)\n    path = columns.Text()\n    start_time = columns.Double()\n    end_time = columns.Double()\n    duration = columns.Double()\n    complete = columns.Boolean(default=False)\n\n\n    @property\n    def completed(self):\n        return (self.duration * 0.97) < self.end_time\n\n    @staticmethod\n    def get_resume_time(host_id, user_id):\n        resume_time = 0\n        obj = WatchEvent.objects.allow_filtering().filter(host_id=host_id, user_id=user_id).first()\n        if obj is not None:\n            if not obj.complete or not obj.completed:\n                resume_time = obj.end_time\n        return resume_time\n"}
{"type": "source_file", "path": "app/videos/routers.py", "content": "import uuid\nfrom typing import Optional\nfrom starlette.exceptions import HTTPException\n\nfrom fastapi import APIRouter, Request, Form, Depends\nfrom fastapi.responses import HTMLResponse\n\nfrom app import utils\nfrom app.users.decorators import login_required\nfrom app.shortcuts import (\n    render,\n    redirect, \n    get_object_or_404,\n    is_htmx\n)\n\nfrom app.watch_events.models import WatchEvent\nfrom .models import Video\nfrom .schemas import (\n    VideoCreateSchema,\n    VideoEditSchema)\n\n\nrouter = APIRouter(\n    prefix='/videos'\n)\n\n\n\n@router.get(\"/create\", response_class=HTMLResponse)\n@login_required\ndef video_create_view(\n    request: Request, \n    is_htmx=Depends(is_htmx),\n    playlist_id:Optional[uuid.UUID]=None\n    ):\n    print(playlist_id)\n    if is_htmx:\n        return render(request, \"videos/htmx/create.html\", {})\n    return render(request, \"videos/create.html\", {})\n\n@router.post(\"/create\", response_class=HTMLResponse)\n@login_required\ndef video_create_post_view(request: Request, is_htmx=Depends(is_htmx), title: str=Form(...), url: str = Form(...)):\n    raw_data = {\n        \"title\": title,\n        \"url\": url,\n        \"user_id\": request.user.username\n    }\n    data, errors = utils.valid_schema_data_or_error(raw_data, VideoCreateSchema)\n    redirect_path = data.get('path') or \"/videos/create\" \n    \n    context = {\n        \"data\": data,\n        \"errors\": errors,\n        \"title\": title,\n        \"url\": url,\n    }\n\n    if is_htmx:\n        \"\"\"\n        Handle all HTMX requests\n        \"\"\"\n        if len(errors) > 0:\n            return render(request, \"videos/htmx/create.html\", context)\n        context = {\"path\": redirect_path, \"title\": data.get('title')}\n        return render(request, \"videos/htmx/link.html\", context)\n    \"\"\"\n    Handle default HTML requests\n    \"\"\"\n    if len(errors) > 0:\n        return render(request, \"videos/create.html\", context, status_code=400)\n    return redirect(redirect_path)\n\n\n@router.get(\"/\", response_class=HTMLResponse)\ndef video_list_view(request: Request):\n    q = Video.objects.all().limit(100)\n    context = {\n        \"object_list\": q\n    }\n    return render(request, \"videos/list.html\", context)\n\n# host_id='video-1'\n# f\"{host_id} is cool\"\n\n@router.get(\"/{host_id}\", response_class=HTMLResponse)\ndef video_detail_view(request: Request, host_id: str):\n    obj = get_object_or_404(Video, host_id=host_id)\n    start_time = 0\n    if request.user.is_authenticated:\n        user_id = request.user.username\n        start_time = WatchEvent.get_resume_time(host_id, user_id)\n    context = {\n        \"host_id\": host_id,\n        \"start_time\": start_time,\n        \"object\": obj\n    }\n    return render(request, \"videos/detail.html\", context)\n\n\n@router.get(\"/{host_id}/edit\", response_class=HTMLResponse)\n@login_required\ndef video_edit_view(request: Request, host_id: str):\n    obj = get_object_or_404(Video, host_id=host_id)\n    context = {\n        \"object\": obj\n    }\n    return render(request, \"videos/edit.html\", context) \n\n\n\n@router.post(\"/{host_id}/edit\", response_class=HTMLResponse)\n@login_required\ndef video_edit_post_view(\n        request: Request,\n          host_id: str, \n        is_htmx=Depends(is_htmx), \n        \n        title: str=Form(...), \n        url: str = Form(...)):\n    raw_data = {\n        \"title\": title,\n        \"url\": url,\n        \"user_id\": request.user.username\n    }\n    obj = get_object_or_404(Video, host_id=host_id)\n    data, errors = utils.valid_schema_data_or_error(raw_data, VideoEditSchema)\n    if len(errors) > 0:\n        return render(request, \"videos/edit.html\", context, status_code=400)\n    obj.title = data.get('title') or obj.title\n    obj.update_video_url(url, save=True)\n    context = {\n        \"object\": obj\n    }\n    return render(request, \"videos/edit.html\", context)\n\n\n\n@router.get(\"/{host_id}/hx-edit\", response_class=HTMLResponse)\n@login_required\ndef video_hx_edit_view(\n    request: Request, \n    host_id: str, \n    is_htmx=Depends(is_htmx)):\n    if not is_htmx:\n        raise HTTPException(status_code=400)\n    obj = None\n    not_found = False\n    try:\n        obj = get_object_or_404(Video, host_id=host_id)\n    except:\n        not_found = True\n    if not_found:\n        return HTMLResponse(\"Not found, please try again.\")\n    context = {\n        \"object\": obj\n    }\n    return render(request, \"videos/htmx/edit.html\", context) \n\n\n\n@router.post(\"/{host_id}/hx-edit\", response_class=HTMLResponse)\n@login_required\ndef video_hx_edit_post_view(\n        request: Request,\n        host_id: str, \n        is_htmx=Depends(is_htmx), \n        title: str=Form(...), \n        url: str = Form(...),\n        delete: Optional[bool] = Form(default=False)):\n    if not is_htmx:\n        raise HTTPException(status_code=400)\n    obj = None\n    not_found = False\n    try:\n        obj = get_object_or_404(Video, host_id=host_id)\n    except:\n        not_found = True\n    if not_found:\n        return HTMLResponse(\"Not found, please try again.\")\n    if delete:\n        obj.delete()\n        return HTMLResponse('Item Deleted')\n    raw_data = {\n        \"title\": title,\n        \"url\": url,\n        \"user_id\": request.user.username\n    }\n    data, errors = utils.valid_schema_data_or_error(raw_data, VideoEditSchema)\n    if len(errors) > 0:\n        return render(request, \"videos/htmx/edit.html\", context, status_code=400)\n    obj.title = data.get('title') or obj.title\n    obj.update_video_url(url, save=True)\n    context = {\n        \"object\": obj\n    }\n    return render(request, \"videos/htmx/list-inline.html\", context)"}
{"type": "source_file", "path": "app/watch_events/schemas.py", "content": "import uuid\nfrom typing import Optional\nfrom pydantic import BaseModel\n\n\nclass WatchEventSchema(BaseModel):\n    host_id: str\n    start_time: float\n    end_time: float\n    duration: float\n    complete: bool\n    path: Optional[str]\n"}
{"type": "source_file", "path": "app/watch_events/routers.py", "content": "from fastapi import APIRouter, Request\n\nfrom .models import WatchEvent\nfrom .schemas import WatchEventSchema\n\nrouter = APIRouter()\n\n@router.post(\"/api/events/watch\", response_model=WatchEventSchema)\ndef watch_event_view(request:Request, watch_event:WatchEventSchema):\n    if (request.user.is_authenticated):\n        cleaned_data = watch_event.dict()\n        data = cleaned_data.copy()\n        data.update({\n            \"user_id\": request.user.username\n        })\n        WatchEvent.objects.create(**data)\n        return watch_event\n    return watch_event"}
{"type": "source_file", "path": "app/watch_events/__init__.py", "content": ""}

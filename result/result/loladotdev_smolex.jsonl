{"repo_info": {"repo_name": "smolex", "repo_owner": "loladotdev", "repo_url": "https://github.com/loladotdev/smolex"}}
{"type": "test_file", "path": "tests/test_retrieval_api.py", "content": "import ast\n\nfrom fastapi.testclient import TestClient\n\nfrom app.main import create_app\n\nVALID_CLASS_DEF = \"\"\"\nclass Foo:\n    def bar(self, x: int) -> str:\n        pass\n\"\"\"\n\nVALID_METHOD_DEF = \"\"\"\ndef foo():\n    pass\n\"\"\"\n\nENDPOINT = \"/api/code/retrieve/\"\nAPI_KEY = \"test-api-key\"\nHEADERS = {\n    \"authorization\": f\"Basic {API_KEY}\"\n}\n\n\ndef test_retrieval_api_code_ast(tmpdir):\n    # GIVEN\n    valid_python_file = tmpdir / \"valid.py\"\n    valid_python_file.write_text(f\"{VALID_CLASS_DEF}\\n{VALID_METHOD_DEF}\", encoding=\"utf-8\")\n\n    # WHEN\n    client = TestClient(create_app(index_root=tmpdir, api_key=API_KEY))\n    response = client.post(url=ENDPOINT, json={\"entities\": [\"Foo\", \"foo\"]}, headers=HEADERS)\n\n    # THEN\n    assert response.status_code == 200\n\n    response_json = response.json()\n    assert len(response_json[\"data\"]) == 2\n\n    actual_class_def_ast = ast.parse(response_json[\"data\"][0])\n    expected_class_def_ast = ast.parse(VALID_CLASS_DEF)\n    assert ast.dump(actual_class_def_ast) == ast.dump(expected_class_def_ast)\n\n    actual_method_def_ast = ast.parse(response_json[\"data\"][1])\n    expected_method_def_ast = ast.parse(VALID_METHOD_DEF)\n    assert ast.dump(actual_method_def_ast) == ast.dump(expected_method_def_ast)\n\n\ndef test_retrieval_api_invalid_files(tmpdir):\n    # GIVEN\n    valid_python_file = tmpdir / \"valid.py\"\n    valid_python_file.write_text(VALID_CLASS_DEF, encoding=\"utf-8\")\n\n    invalid_python_file = tmpdir / \"invalid.py\"\n    invalid_python_file.write_text(\"baz = \", encoding=\"utf-8\")\n\n    # WHEN\n    client = TestClient(create_app(index_root=tmpdir, api_key=API_KEY))\n    response = client.post(url=ENDPOINT, json={\"entities\": [\"Foo\"]}, headers=HEADERS)\n\n    # THEN\n    assert response.status_code == 200\n    assert len(response.json()[\"data\"]) == 1\n\n\ndef test_retrieval_api_ignored_files(tmpdir):\n    # GIVEN\n    valid_python_file = tmpdir / \"valid.py\"\n    valid_python_file.write_text(VALID_CLASS_DEF, encoding=\"utf-8\")\n\n    ignored_file = tmpdir / \"ignored.md\"\n    ignored_file.write_text(\"# Baz\", encoding=\"utf-8\")\n\n    # WHEN\n    client = TestClient(create_app(index_root=tmpdir, api_key=API_KEY))\n    response = client.post(url=ENDPOINT, json={\"entities\": [\"Foo\"]}, headers=HEADERS)\n\n    # THEN\n    assert response.status_code == 200\n    assert len(response.json()[\"data\"]) == 1\n\n\ndef test_retrieval_api_invalid_payload(tmpdir):\n    # GIVEN\n    invalid_payload = {\"entities\": \"Foo\"}\n\n    # WHEN\n    client = TestClient(create_app(index_root=tmpdir, api_key=API_KEY))\n    response = client.post(url=ENDPOINT, json=invalid_payload, headers=HEADERS)\n\n    # THEN\n    assert response.status_code == 422\n    response_json = response.json()\n    assert response_json[\"detail\"][0][\"input\"] == \"Foo\"\n    assert response_json[\"detail\"][0][\"loc\"] == [\"body\", \"entities\"]\n    assert response_json[\"detail\"][0][\"msg\"] == \"Input should be a valid list\"\n    assert response_json[\"detail\"][0][\"type\"] == \"list_type\"\n\n\ndef test_retrieval_api_unauthorized(tmpdir):\n    # GIVEN\n\n    # WHEN\n    client = TestClient(create_app(index_root=tmpdir, api_key=API_KEY))\n    response = client.post(url=ENDPOINT, json={\"entities\": [\"Foo\"]})\n\n    # THEN\n    assert response.status_code == 401\n"}
{"type": "source_file", "path": "app/routes/__init__.py", "content": ""}
{"type": "source_file", "path": "app/internal/retrieval/__init__.py", "content": ""}
{"type": "source_file", "path": "app/models/code_entity_request.py", "content": "from typing import List\n\nfrom pydantic import BaseModel\n\n\nclass CodeEntityRequest(BaseModel):\n    entities: List[str]\n"}
{"type": "source_file", "path": "app/main.py", "content": "import argparse\nimport secrets\nfrom pathlib import Path\n\nimport uvicorn\nfrom fastapi import FastAPI, Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom app.routes import retrieve\n\n\nasync def check_basic_api_key_auth_header(request: Request, call_next):\n    authorization: str = request.headers.get('authorization')\n\n    print(request.url.path)\n\n    # allow /docs without api key\n    if request.url.path in [\"/docs\", \"/openapi.json\", \"/openapi.yaml\"]:\n        return await call_next(request)\n\n    if authorization != f\"Basic {request.app.state.api_key}\":\n        return Response(\"Unauthorized\", status_code=401)\n\n    return await call_next(request)\n\n\ndef create_app(index_root: Path, api_key: str):\n    _app = FastAPI()\n    _app.include_router(retrieve.router)\n\n    # Root directory that should be indexed\n    _app.state.index_root = index_root  # noqa\n\n    _app.state.api_key = api_key  # noqa\n    _app.add_middleware(middleware_class=BaseHTTPMiddleware, dispatch=check_basic_api_key_auth_header)\n\n    _app.add_middleware(\n        middleware_class=CORSMiddleware,\n        allow_credentials=True,\n        allow_origins=[\"*\"],\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    return _app\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Run the Smolex Server\")\n    parser.add_argument(\"--index-root\", required=True, help=\"Root directory that should be indexed\")\n    parser.add_argument(\"--api-key\", required=False, help=\"API key for the Smolex Server\")\n\n    args = parser.parse_args()\n\n    if args.api_key is None:\n        args.api_key = secrets.token_urlsafe(32)\n        print(f\"Random API key generated. Use --api-key to set a custom API key: {args.api_key}\")\n\n    app = create_app(index_root=Path(args.index_root), api_key=args.api_key)\n    uvicorn.run(app, host=\"0.0.0.0\", port=5003)\n"}
{"type": "source_file", "path": "app/internal/retrieval/python.py", "content": "import ast\nimport os\nimport sqlite3\nimport pickle\nfrom pathlib import Path\nfrom typing import List\n\nINDEXED_RETRIEVAL_TYPES = (ast.ClassDef, ast.FunctionDef)\n\n\ndef create_in_memory_database() -> sqlite3.Connection:\n    \"\"\" Isolation_level=None -> autocommit. No need to commit manually. \"\"\"\n\n    connection = sqlite3.connect(\":memory:\", isolation_level=None)\n\n    connection.execute(\n        \"CREATE TABLE Entities \"  # noqa\n        \"(ID INTEGER PRIMARY KEY AUTOINCREMENT, FileName TEXT, Type TEXT, Name TEXT, AST BLOB)\"  # noqa\n    )\n\n    return connection\n\n\ndef create_index(connection: sqlite3.Connection, index_root: Path):\n    for root, dirs, files in os.walk(index_root):\n        for file in files:\n            if file.endswith(\".py\"):\n                filename = root / Path(file)\n\n                with open(filename, \"r\") as fd:\n                    try:\n                        root_node = ast.parse(fd.read())\n                    except SyntaxError as e:\n                        continue\n\n                for node in [\n                    relevant_node\n                    for relevant_node in ast.walk(root_node)\n                    if isinstance(relevant_node, INDEXED_RETRIEVAL_TYPES)\n                ]:\n                    connection.execute(\n                        \"INSERT INTO Entities (FileName, Type, Name, AST) VALUES (?, ?, ?, ?)\",  # noqa\n                        (filename.name, type(node).__name__, node.name, pickle.dumps(node)),\n                    )\n\n\ndef query_index(connection: sqlite3.Connection, code_entities: List[str]) -> List[str]:\n    where_clause = (\n        \"WHERE Name IN (\" + \",\".join([\"'\" + entity + \"'\" for entity in code_entities]) + \")\"\n    )\n\n    query = f\"SELECT AST FROM Entities {where_clause}\"  # noqa\n\n    if results := connection.execute(query).fetchall():\n        nodes = [ast.parse(pickle.loads(result[0])) for result in results]\n        return [ast.unparse(node) for node in nodes]\n\n    return []\n\n\ndef retrieve_code_entities(code_entities: List[str], index_root: Path):\n    \"\"\"\n    Create and retrieve code index. Since it's fast,\n    we can do it in memory and on the fly.\n    \"\"\"\n    connection = create_in_memory_database()\n    create_index(connection=connection, index_root=index_root)\n    return query_index(connection=connection, code_entities=code_entities)\n"}
{"type": "source_file", "path": "app/models/code_entity_response.py", "content": "from typing import List\n\nfrom pydantic import BaseModel, Field\n\n\nclass CodeEntityResponse(BaseModel):\n    data: List[str] = Field(..., description=\"Retrieved code for the given entities\")\n"}
{"type": "source_file", "path": "app/routes/retrieve.py", "content": "from app.internal.retrieval.python import retrieve_code_entities\nfrom app.models.code_entity_request import CodeEntityRequest\nfrom fastapi import APIRouter, Request\n\nfrom app.models.code_entity_response import CodeEntityResponse\n\nrouter = APIRouter()\n\n\n@router.post(\"/api/code/retrieve/\", response_model=CodeEntityResponse)\nasync def retrieve(request: Request, body: CodeEntityRequest):\n    \"\"\"\n    Lookup and retrieve existing code for given entities (classes, methods)\n    This endpoint returns the existing code for given code entities (classes, methods).\n    \"\"\"\n\n    return {\"data\": retrieve_code_entities(code_entities=body.entities, index_root=request.app.state.index_root)}\n"}
{"type": "source_file", "path": "app/internal/retrieval/files.py", "content": ""}
{"type": "source_file", "path": "app/models/__init__.py", "content": ""}
{"type": "source_file", "path": "app/internal/__init__.py", "content": ""}
{"type": "source_file", "path": "app/__init__.py", "content": ""}

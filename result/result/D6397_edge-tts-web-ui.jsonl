{"repo_info": {"repo_name": "edge-tts-web-ui", "repo_owner": "D6397", "repo_url": "https://github.com/D6397/edge-tts-web-ui"}}
{"type": "source_file", "path": "app.py", "content": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse, FileResponse, Response\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom pydantic import BaseModel\nimport edge_tts\nimport asyncio\nimport uuid\nimport os\nfrom typing import List, Optional\nimport json\nfrom mutagen.mp3 import MP3\nimport time\nfrom datetime import datetime, timedelta\nimport logging\nfrom functools import lru_cache\nimport shutil\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s',\n    handlers=[\n        logging.StreamHandler(),\n        logging.FileHandler('tts.log', encoding='utf-8')\n    ]\n)\n\napp = FastAPI()\n\n# 配置CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n    expose_headers=[\"*\"]\n)\n\n# 配置静态文件服务\nos.makedirs(\"static/audio\", exist_ok=True)\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n\n# 添加根���径处理\n@app.get(\"/\")\nasync def read_root():\n    return FileResponse('index.html')\n\n# 修改 favicon 处理部分\n@app.get('/favicon.ico')\nasync def favicon():\n    try:\n        # 直接用网站根目录的 favicon.ico\n        favicon_path = '/www/wwwroot/favicon.ico'\n        if os.path.exists(favicon_path):\n            return FileResponse(\n                favicon_path,\n                media_type=\"image/x-icon\"\n            )\n        else:\n            print(f\"Favicon not found at: {favicon_path}\")\n            raise HTTPException(status_code=404, detail=\"Favicon not found\")\n    except Exception as e:\n        print(f\"Error serving favicon: {str(e)}\")\n        raise HTTPException(status_code=404, detail=\"Favicon not found\")\n\n# 在 app.mount 之前添加静态文件路由\n@app.get(\"/static/{file_path:path}\")\nasync def static_files(file_path: str):\n    return FileResponse(f\"static/{file_path}\")\n\nclass TTSRequest(BaseModel):\n    text: str\n    voice_id: str\n    speed: float = 1.0\n    autoplay: bool = True\n    user_id: str\n\nclass Voice(BaseModel):\n    id: str\n    name: str\n    gender: str\n    language: str\n\n# 缓存可用的声音列\nVOICE_CACHE = {}\n\n# 缓存声音列表，每小时更新一次\n@lru_cache(maxsize=1)\ndef get_cache_key():\n    \"\"\"生成基于小时的缓存键\"\"\"\n    now = datetime.now()\n    return now.strftime(\"%Y%m%d%H\")\n\nasync def get_voices():\n    try:\n        cache_key = get_cache_key()\n        if cache_key in VOICE_CACHE:\n            return VOICE_CACHE[cache_key]\n        \n        print(\"Fetching voices from edge-tts...\")\n        voices = await edge_tts.list_voices()\n        print(f\"Got {len(voices)} voices from edge-tts\")\n        \n        # 初始化语言分类字典\n        voice_dict = {}\n        \n        for voice in voices:\n            # 将所有中文声音统一到 zh-CN\n            lang = \"zh-CN\" if voice[\"Locale\"].startswith(\"zh\") else voice[\"Locale\"]\n            \n            if lang not in voice_dict:\n                voice_dict[lang] = []\n            \n            # 添加更友好的声音名称\n            friendly_name = {\n                # 中文普通话 - 男声\n                \"zh-CN-YunjianNeural\": \"云健 (标准男声)\",\n                \"zh-CN-YunxiNeural\": \"云希 (阳光男声)\",\n                \"zh-CN-YunxiaNeural\": \"云夏 (男童声)\",\n                \"zh-CN-YunyangNeural\": \"云扬 (新闻男声)\",\n                \"zh-CN-YunfengNeural\": \"云峰 (成熟男声)\",\n                \"zh-CN-YunzeNeural\": \"云泽 (温柔男声)\",\n                \"zh-CN-YunhaoNeural\": \"云浩 (商务男声)\",\n                \"zh-CN-YunleNeural\": \"云乐 (活力男声)\",\n                \"zh-CN-YunxuanNeural\": \"云轩 (青年男声)\",\n                \"zh-CN-YunqiangNeural\": \"云强 (浑厚男声)\",\n                \"zh-CN-YunpengNeural\": \"云鹏 (书生男声)\",\n                \"zh-CN-YunwenNeural\": \"云文 (儒雅男声)\",\n                \"zh-CN-YunchengNeural\": \"云程 (知性男声)\",\n                \"zh-CN-YunhuiNeural\": \"云辉 (磁性男声)\",\n                \"zh-CN-YunminNeural\": \"云敏 (清新男声)\",\n                \n                # 中文普通话 - 女声\n                \"zh-CN-XiaoxiaoNeural\": \"晓晓 (标准女声)\",\n                \"zh-CN-XiaoyiNeural\": \"晓伊 (温柔女声)\",\n                \"zh-CN-XiaohanNeural\": \"晓涵 (活力女声)\",\n                \"zh-CN-XiaomengNeural\": \"晓梦 (甜美女声)\",\n                \"zh-CN-XiaomoNeural\": \"晓墨 (文艺女声)\",\n                \"zh-CN-XiaoxuanNeural\": \"晓萱 (知性女声)\",\n                \"zh-CN-XiaoruiNeural\": \"晓睿 (儿童女声)\",\n                \"zh-CN-XiaoshuangNeural\": \"晓双 (青年女声)\",\n                \"zh-CN-XiaoyanNeural\": \"晓妍 (邻家女声)\",\n                \"zh-CN-XiaochenNeural\": \"晓辰 (自然女声)\",\n                \"zh-CN-XiaoqiuNeural\": \"晓秋 (温暖女声)\",\n                \"zh-CN-XiaozhenNeural\": \"晓珍 (优雅女声)\",\n                \"zh-CN-XiaohuiNeural\": \"晓慧 (干练女声)\",\n                \"zh-CN-XiaolingNeural\": \"晓玲 (甜美女声)\",\n                \"zh-CN-XiaoxuanNeural\": \"晓轩 (标准女声)\",\n                \"zh-CN-XiaoyouNeural\": \"晓悠 (柔美女声)\",\n                \"zh-CN-XiaoqingNeural\": \"晓青 (清新女声)\",\n                \"zh-CN-XiaorongNeural\": \"晓蓉 (标准女声)\",\n                \"zh-CN-XiaoyanNeural\": \"晓妍 (时尚女声)\",\n                \"zh-CN-XiaojingNeural\": \"晓静 (标准女声)\",\n                \"zh-CN-XiaohuanNeural\": \"晓欢 (活泼女声)\",\n                \"zh-CN-XiaoyunNeural\": \"晓云 (标准女声)\",\n                \"zh-CN-XiaolingNeural\": \"晓玲 (标准女声)\",\n                \"zh-CN-XiaoxianNeural\": \"晓仙 (空灵女声)\",\n                \"zh-CN-XiaoxueNeural\": \"晓雪 (清纯女声)\",\n                \n                # 中文方言 - 男声\n                \"zh-CN-shandong-YunxiangNeural\": \"云翔 (山东话)\",\n                \"zh-CN-sichuan-YunxiNeural\": \"云希 (四川话)\",\n                \"zh-CN-henan-YundengNeural\": \"云登 (河南话)\",\n                \"zh-CN-hubei-YunrongNeural\": \"云荣 (湖北话)\",\n                \"zh-CN-shanxi-YunjiangNeural\": \"云江 (山西话)\",\n                \"zh-CN-guangdong-YunrongNeural\": \"云荣 (粤语男声)\",\n                \"zh-CN-hebei-YunboNeural\": \"云博 (河北话)\",\n                \"zh-CN-hunan-YunwenNeural\": \"云文 (湖南话)\",\n                \"zh-CN-jiangxi-YunfengNeural\": \"云峰 (江西话)\",\n                \"zh-CN-guizhou-YunhaoNeural\": \"云浩 (贵州话)\",\n                \n                # 中文方言 - 女声\n                \"zh-CN-liaoning-XiaobeiNeural\": \"晓北 (东北话)\",\n                \"zh-CN-shaanxi-XiaoniNeural\": \"晓妮 (陕西话)\",\n                \"zh-CN-zhijiang-XiaotongNeural\": \"晓彤 (长江话)\",\n                \"zh-CN-jiangsu-XiaoleiNeural\": \"晓蕾 (江苏话)\",\n                \"zh-CN-zhejiang-XiaonianNeural\": \"晓年 (浙江话)\",\n                \"zh-CN-guangxi-XiaominNeural\": \"晓敏 (桂林话)\",\n                \"zh-CN-fujian-XiaomeiNeural\": \"晓梅 (闽南话)\",\n                \"zh-CN-anhui-XiaoruiNeural\": \"晓睿 (安徽话)\",\n                \"zh-CN-yunnan-XiaojingNeural\": \"晓静 (云南话)\",\n                \"zh-CN-gansu-XiaoqingNeural\": \"晓青 (甘肃话)\",\n                \n                # 港台声音\n                \"zh-HK-HiuGaaiNeural\": \"晓佳 (粤语女声)\",\n                \"zh-HK-HiuMaanNeural\": \"晓曼 (粤语女声)\",\n                \"zh-HK-WanLungNeural\": \"云龙 (粤男声)\",\n                \"zh-TW-HsiaoChenNeural\": \"晓辰 (台湾女声)\",\n                \"zh-TW-YunJheNeural\": \"云哲 (台湾男声)\",\n                \"zh-TW-HsiaoYuNeural\": \"晓雨 (台湾女声)\",\n                \"zh-TW-HsiaoTungNeural\": \"晓彤 (台湾女声)\",\n                \"zh-TW-YunFuNeural\": \"云甫 (台湾男声)\",\n                \n                # 英文声音\n                \"en-US-GuyNeural\": \"Guy (美式男声)\",\n                \"en-US-DavisNeural\": \"Davis (美式男声)\",\n                \"en-US-TonyNeural\": \"Tony (美式男声)\",\n                \"en-US-JennyNeural\": \"Jenny (美式女声)\",\n                \"en-US-AriaNeural\": \"Aria (美式女声)\",\n                \"en-GB-RyanNeural\": \"Ryan (英式男声)\",\n                \"en-GB-SoniaNeural\": \"Sonia (英式女声)\",\n                \n                # 日文声音\n                \"ja-JP-KeitaNeural\": \"圭太 (日本男声)\",\n                \"ja-JP-DaichiNeural\": \"大智 (日本男声)\",\n                \"ja-JP-NanamiNeural\": \"七海 (日本女声)\",\n                \"ja-JP-AoiNeural\": \"葵 (日本女声)\",\n            }.get(voice[\"ShortName\"], voice[\"ShortName\"])\n            \n            print(f\"Adding voice: {friendly_name} ({voice['ShortName']})\")\n            \n            voice_dict[lang].append({\n                \"id\": voice[\"ShortName\"],\n                \"name\": friendly_name,\n                \"gender\": voice[\"Gender\"].lower(),\n                \"language\": lang\n            })\n        \n        # 更新缓存\n        VOICE_CACHE[cache_key] = voice_dict\n        return voice_dict\n    except Exception as e:\n        print(f\"Error in get_voices: {str(e)}\")\n        raise\n\n@app.get(\"/api/voices\")\nasync def list_voices(language: str = \"zh-CN\", gender: Optional[str] = None):\n    try:\n        print(f\"Fetching voices for language: {language}, gender: {gender}\")\n        voices = await get_voices()\n        print(f\"Available languages: {list(voices.keys())}\")\n        \n        # 获取所有匹配语言前缀的声音\n        filtered_voices = []\n        \n        # 处理中文声音（包括普通话、方言、港台）\n        if language == \"zh-CN\":\n            # 收集所有中文相关声音\n            for lang, voice_list in voices.items():\n                if lang.startswith(\"zh-\"):  # 匹配所有中文声音（包括 zh-CN, zh-HK, zh-TW）\n                    filtered_voices.extend(voice_list)\n                elif lang == \"zh\":  # 防止可能的其他中文变体\n                    filtered_voices.extend(voice_list)\n        else:\n            # 其他语言的常规匹配\n            for lang, voice_list in voices.items():\n                if lang.startswith(language):\n                    filtered_voices.extend(voice_list)\n        \n        print(f\"Found {len(filtered_voices)} voices before gender filter\")\n        \n        # 应用性别过滤\n        if gender:\n            def is_matching_voice(voice):\n                voice_id = voice[\"id\"].lower()\n                name = voice[\"name\"].lower()\n                \n                # 通用匹配规则\n                if gender.lower() == \"male\":\n                    if (\n                        voice[\"gender\"].lower() == \"male\" or\n                        \"男\" in name or\n                        (\"云\" in name and \"晓\" not in name) or  # 确保是云字辈且不包含晓字\n                        (any(x in voice_id.lower() for x in [\n                            \"yun\", \"wan\", \"-yun\"\n                        ]) and not any(x in voice_id.lower() for x in [\n                            \"xiao\", \"hiu\", \"hsiao\"  # 排除包含女声标识的ID\n                        ]))\n                    ):\n                        return True\n                else:  # female\n                    if (\n                        voice[\"gender\"].lower() == \"female\" or\n                        \"女\" in name or\n                        (\"晓\" in name and \"云\" not in name) or  # 确保是晓字辈且不包含云字\n                        (any(x in voice_id.lower() for x in [\n                            \"xiao\", \"hiu\", \"hsiao\", \"-xiao\"\n                        ]) and not any(x in voice_id.lower() for x in [\n                            \"yun\", \"wan\"  # 排除包含男声标识的ID\n                        ]))\n                    ):\n                        return True\n                return False\n            \n            filtered_voices = [v for v in filtered_voices if is_matching_voice(v)]\n            print(f\"Found {len(filtered_voices)} voices after gender filter\")\n            \n            # 打印过滤后的声音详情\n            for voice in filtered_voices:\n                print(f\"Filtered voice: {voice['name']} ({voice['id']}, {voice['gender']})\")\n        \n        # 按特定顺序排序\n        def sort_key(voice):\n            # 定义声音类型的排序优先级\n            voice_type_order = {\n                \"标准\": 1,\n                \"新闻\": 2,\n                \"成熟\": 3,\n                \"阳光\": 4,\n                \"温柔\": 5,\n                \"商务\": 6,\n                \"活力\": 7,\n                \"磁性\": 8,\n                \"浑厚\": 9,\n                \"书生\": 10,\n                \"儒雅\": 11,\n                \"男童\": 12,\n                \"东北\": 13,\n                \"山东\": 14,\n                \"四川\": 15,\n                \"河南\": 16,\n                \"湖北\": 17,\n                \"山西\": 18,\n                \"河北\": 19,\n                \"湖南\": 20,\n                \"江西\": 21,\n                \"贵州\": 22,\n                \"江苏\": 23,\n                \"浙江\": 24,\n                \"广西\": 25,\n                \"福建\": 26,\n                \"安徽\": 27,\n                \"云南\": 28,\n                \"甘肃\": 29,\n                \"粤语\": 30,\n                \"闽南\": 31,\n                \"台湾\": 32,\n            }\n            \n            # 获取声音类型的排序值\n            name = voice[\"name\"]\n            for key, value in voice_type_order.items():\n                if key in name:\n                    return value\n            return 100  # 其他类型放到最后\n            \n        # 先按类型排序，然后按名称排序\n        filtered_voices.sort(key=lambda x: (sort_key(x), x[\"name\"]))\n        \n        return filtered_voices\n    except Exception as e:\n        print(f\"Error in list_voices: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# 添加时长格式化函数\ndef format_duration(seconds):\n    \"\"\"将秒数转换为 MM:SS 格式\"\"\"\n    minutes = int(seconds // 60)\n    seconds = int(seconds % 60)\n    return f\"{minutes:02d}:{seconds:02d}\"\n\n@app.post(\"/api/generate\")\nasync def generate_audio(request: TTSRequest):\n    try:\n        # 验证请求参数\n        if not request.text.strip():\n            raise HTTPException(status_code=400, detail=\"文本内容不能为空\")\n        if not request.voice_id:\n            raise HTTPException(status_code=400, detail=\"未选择声音\")\n        if not 0.25 <= request.speed <= 4:\n            raise HTTPException(status_code=400, detail=\"语速设置无效\")\n            \n        # 生成文件名时包含用户ID\n        filename = f\"{request.user_id}_{str(uuid.uuid4())}\"\n        audio_path = f\"static/audio/{filename}.mp3\"\n        subtitle_path = f\"static/audio/{filename}.srt\"\n        \n        # 确保目录存在\n        os.makedirs(\"static/audio\", exist_ok=True)\n        \n        try:\n            logging.info(f\"Starting audio generation for user {request.user_id}\")\n            print(f\"Starting audio generation...\")\n            print(f\"Text: {request.text[:100]}...\")\n            print(f\"Voice ID: {request.voice_id}\")\n            print(f\"Speed: {request.speed}\")\n            \n            # 修改语速格式\n            speed_percentage = int((request.speed - 1) * 100)\n            rate = f\"{speed_percentage:+d}%\"\n            print(f\"Calculated rate: {rate}\")\n            \n            try:\n                # 验证文本长度\n                if len(request.text) > 10000:  # 设置合理的文本长度限制\n                    raise HTTPException(status_code=400, detail=\"文本内容过长\")\n                \n                # 验证语速范围\n                if not 0.25 <= request.speed <= 4:\n                    raise HTTPException(status_code=400, detail=\"语速必须在 0.25 到 4 之间\")\n                \n                # 验证声音ID是否存在\n                voices = await get_voices()\n                available_voices = []\n                for voice_list in voices.values():\n                    available_voices.extend([v[\"id\"] for v in voice_list])\n                if request.voice_id not in available_voices:\n                    raise HTTPException(status_code=400, detail=\"选择的声不可用\")\n                \n                # 设置语音参数并生成\n                communicate = edge_tts.Communicate(\n                    text=request.text,\n                    voice=request.voice_id,\n                    rate=rate\n                )\n                print(\"Created communicate object\")\n\n                # 生成音频和字幕\n                print(f\"Saving audio to: {audio_path}\")\n                audio_data = []\n                subtitle_data = []\n                subtitle_index = 1\n                \n                # 用于合并幕的临时存储\n                temp_text = []\n                temp_start = None\n                temp_end = None\n                \n                async for chunk in communicate.stream():\n                    if chunk[\"type\"] == \"audio\":\n                        audio_data.append(chunk[\"data\"])\n                    elif chunk[\"type\"] == \"WordBoundary\":\n                        # 转换时间戳\n                        start_ms = int(chunk['offset'] / 10000)\n                        duration_ms = int(chunk['duration'] / 10000)\n                        end_ms = start_ms + duration_ms\n                        \n                        # 如果是新的字幕组或时间间隔太大，就保存当前组\n                        if temp_start is None:\n                            temp_start = start_ms\n                            temp_end = end_ms\n                            temp_text.append(chunk[\"text\"])\n                        elif end_ms - temp_end > 500:  # 如果间隔超过500毫秒，就作为新的字幕\n                            # 保存当前字幕组\n                            start_time = format_time(temp_start)\n                            end_time = format_time(temp_end)\n                            \n                            subtitle_entry = [\n                                f\"{subtitle_index}\",\n                                f\"{start_time} --> {end_time}\",\n                                \"\".join(temp_text),\n                                \"\"\n                            ]\n                            print(f\"Adding subtitle entry:\\n\" + \"\\n\".join(subtitle_entry))\n                            subtitle_data.extend(subtitle_entry)\n                            subtitle_index += 1\n                            \n                            # 开始新的字幕组\n                            temp_text = [chunk[\"text\"]]\n                            temp_start = start_ms\n                            temp_end = end_ms\n                        else:\n                            # 继续当前字幕组\n                            temp_text.append(chunk[\"text\"])\n                            temp_end = end_ms\n                \n                # 保存最后一组字幕\n                if temp_text:\n                    start_time = format_time(temp_start)\n                    end_time = format_time(temp_end)\n                    subtitle_entry = [\n                        f\"{subtitle_index}\",\n                        f\"{start_time} --> {end_time}\",\n                        \"\".join(temp_text),\n                        \"\"\n                    ]\n                    print(f\"Adding subtitle entry:\\n\" + \"\\n\".join(subtitle_entry))\n                    subtitle_data.extend(subtitle_entry)\n                \n                # 写入音频文件\n                with open(audio_path, \"wb\") as audio_file:\n                    for data in audio_data:\n                        audio_file.write(data)\n\n                # 写入 SRT 格式字幕文件\n                try:\n                    subtitle_content = \"\\n\".join(subtitle_data)\n                    print(f\"Writing subtitle content:\\n{subtitle_content}\")\n                    \n                    with open(subtitle_path, \"w\", encoding=\"utf-8\", newline='\\n') as subtitle_file:\n                        subtitle_file.write(subtitle_content)\n                        subtitle_file.flush()  # 确保数据写入磁盘\n                        os.fsync(subtitle_file.fileno())  # 强制同步到磁盘\n                    \n                    # 添加短暂延迟确保文件完全写入\n                    await asyncio.sleep(0.1)\n                    \n                    # 验证文件是否正确写入\n                    if os.path.exists(subtitle_path):\n                        with open(subtitle_path, \"r\", encoding=\"utf-8\") as check_file:\n                            saved_content = check_file.read()\n                            print(f\"Verified subtitle content:\\n{saved_content}\")\n                            if saved_content != subtitle_content:\n                                raise ValueError(\"Subtitle file content verification failed\")\n                    else:\n                        raise ValueError(\"Subtitle file was not created\")\n                    \n                    print(f\"Subtitle file successfully written to {subtitle_path}\")\n                    \n                except Exception as e:\n                    print(f\"Error writing subtitle file: {str(e)}\")\n                    raise\n\n                print(\"Audio and subtitles saved successfully\")\n                \n                # 再次验证文件是否可访问\n                if not (os.path.exists(audio_path) and os.path.exists(subtitle_path)):\n                    raise ValueError(\"Generated files are not accessible\")\n                \n                # 获取文件大小和时长\n                file_size = os.path.getsize(audio_path)\n                try:\n                    # 使用 mutagen 获取音频时长\n                    audio = MP3(audio_path)\n                    duration = format_duration(audio.info.length)\n                    print(f\"Audio duration: {duration}\")\n                except Exception as e:\n                    print(f\"Error getting audio duration: {str(e)}\")\n                    duration = \"00:00\"\n                \n                return JSONResponse({\n                    \"success\": True,\n                    \"audio\": {\n                        \"url\": f\"/static/audio/{filename}.mp3\",\n                        \"name\": f\"{filename}.mp3\",\n                        \"size\": f\"{file_size / 1024:.1f}KB\",\n                        \"duration\": duration,  # 使实际计算的时长\n                        \"id\": filename\n                    }\n                })\n                \n            except Exception as e:\n                print(f\"Error during TTS generation: {str(e)}\")\n                print(f\"Error type: {type(e)}\")\n                import traceback\n                print(f\"Traceback: {traceback.format_exc()}\")\n                raise ValueError(f\"TTS生成失败: {str(e)}\")\n            \n        except Exception as e:\n            logging.error(f\"Error in generation process: {str(e)}\")\n            # 清理可能部分生成的文件\n            for path in [audio_path, subtitle_path]:\n                if os.path.exists(path):\n                    try:\n                        os.remove(path)\n                    except Exception as cleanup_error:\n                        logging.error(f\"Error cleaning up file {path}: {str(cleanup_error)}\")\n            raise\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        logging.error(f\"Unexpected error: {str(e)}\")\n        error_message = str(e)\n        \n        # 处理常见错误\n        error_mapping = {\n            \"Connection refused\": \"无法连接到语音服务，请稍后重试\",\n            \"Invalid rate\": \"语速设置无效，请使用正确的语速值\",\n            \"Invalid voice\": \"选择的声音无效，请重新选择\",\n            \"TTS generation failed\": \"语音生成失败，请重试\",\n            \"No such file\": \"文件生成失败，请重试\"\n        }\n        \n        for key, value in error_mapping.items():\n            if key in error_message:\n                error_message = value\n                break\n        \n        raise HTTPException(\n            status_code=500,\n            detail={\n                \"message\": \"生成音频失败\",\n                \"error\": error_message\n            }\n        )\n\n@app.delete(\"/api/audio/{audio_id}\")\nasync def delete_audio(audio_id: str):\n    try:\n        file_path = f\"static/audio/{audio_id}\"\n        if os.path.exists(file_path):\n            os.remove(file_path)\n        return {\"success\": True}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n# 添加获取音频列表的接口\n@app.get(\"/api/audio/{user_id}\")\nasync def list_audio(user_id: str):\n    try:\n        audio_files = []\n        audio_dir = \"static/audio\"\n        for filename in os.listdir(audio_dir):\n            if filename.endswith(\".mp3\") and filename.startswith(f\"{user_id}_\"):\n                file_path = os.path.join(audio_dir, filename)\n                file_size = os.path.getsize(file_path)\n                try:\n                    audio = MP3(file_path)\n                    duration = format_duration(audio.info.length)\n                except Exception as e:\n                    print(f\"Error getting duration for {filename}: {str(e)}\")\n                    duration = \"00:00\"\n                \n                audio_files.append({\n                    \"url\": f\"/static/audio/{filename}\",\n                    \"name\": filename,\n                    \"size\": f\"{file_size / 1024:.1f}KB\",\n                    \"duration\": duration,\n                    \"id\": filename\n                })\n        return audio_files\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/subtitle/{audio_id}\")\nasync def get_subtitle(audio_id: str):\n    try:\n        print(f\"Requesting subtitle for audio: {audio_id}\")\n        \n        # 确保文件名格式正确\n        base_name = audio_id.replace('.mp3', '')\n        subtitle_path = f\"static/audio/{base_name}.srt\"\n        \n        print(f\"Looking for subtitle file: {subtitle_path}\")\n        \n        # 如果字幕文件不存在，返回404\n        if not os.path.exists(subtitle_path):\n            print(f\"Subtitle file not found: {subtitle_path}\")\n            raise HTTPException(status_code=404, detail=\"字幕文件不存在\")\n        \n        # 直接使用 FileResponse，但设置正确的 headers\n        return FileResponse(\n            path=subtitle_path,\n            filename=f\"{base_name}.srt\",\n            headers={\n                \"Content-Disposition\": f'attachment; filename=\"{base_name}.srt\"',\n                \"Content-Type\": \"text/srt\"\n            }\n        )\n    except Exception as e:\n        print(f\"Error serving subtitle: {str(e)}\")\n        if isinstance(e, HTTPException):\n            raise\n        raise HTTPException(status_code=500, detail=str(e))\n\n# 添加时间格式辅助函数\ndef format_time(ms):\n    \"\"\"将毫秒转换为 SRT 时间格式 (HH:MM:SS,mmm)\"\"\"\n    hours = ms // 3600000\n    minutes = (ms % 3600000) // 60000\n    seconds = (ms % 60000) // 1000\n    milliseconds = ms % 1000\n    return f\"{hours:02d}:{minutes:02d}:{seconds:02d},{milliseconds:03d}\"\n\n# 优化文件清理函数\nasync def cleanup_old_files():\n    \"\"\"清理超过30分钟的音频和字幕文件\"\"\"\n    while True:\n        try:\n            logging.info(\"Starting cleanup check...\")\n            current_time = time.time()\n            audio_dir = \"static/audio\"\n            files_cleaned = 0\n            total_size_cleaned = 0\n            \n            # 获取所有文件及其信息\n            files = []\n            for filename in os.listdir(audio_dir):\n                try:\n                    file_path = os.path.join(audio_dir, filename)\n                    stat = os.stat(file_path)\n                    files.append({\n                        'path': file_path,\n                        'name': filename,\n                        'mtime': stat.st_mtime,\n                        'size': stat.st_size\n                    })\n                except Exception as e:\n                    logging.error(f\"Error getting file info for {filename}: {str(e)}\")\n            \n            # 按修改时间排序，先删除最旧的文件\n            files.sort(key=lambda x: x['mtime'])\n            \n            for file_info in files:\n                try:\n                    if current_time - file_info['mtime'] > 30 * 60:  # 30分钟\n                        os.remove(file_info['path'])\n                        files_cleaned += 1\n                        total_size_cleaned += file_info['size']\n                        logging.info(f\"Cleaned up: {file_info['name']} ({file_info['size'] / 1024:.1f}KB)\")\n                except Exception as e:\n                    logging.error(f\"Error deleting file {file_info['name']}: {str(e)}\")\n            \n            if files_cleaned > 0:\n                logging.info(f\"Cleanup completed: removed {files_cleaned} files, freed {total_size_cleaned / 1024 / 1024:.1f}MB\")\n            \n        except Exception as e:\n            logging.error(f\"Error during cleanup: {str(e)}\", exc_info=True)\n        \n        await asyncio.sleep(5 * 60)  # 5分钟检查一次\n\n# 修改日志中间件的实现\n@app.middleware(\"http\")\nasync def log_requests(request: Request, call_next):\n    try:\n        start_time = time.time()\n        response = await call_next(request)\n        process_time = time.time() - start_time\n        logging.info(\n            f\"{request.client.host}:{request.client.port} - \"\n            f\"\\\"{request.method} {request.url.path} HTTP/{request.scope.get('http_version', '1.1')}\\\" \"\n            f\"{response.status_code} - {process_time:.2f}s\"\n        )\n        return response\n    except Exception as e:\n        logging.error(f\"Error in request logging: {str(e)}\", exc_info=True)\n        return await call_next(request)\n\n# 修改错误处理器\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    logging.error(\n        f\"HTTP error: {exc.status_code} - {exc.detail} - \"\n        f\"Path: {request.url.path} - \"\n        f\"Client: {request.client.host}\"\n    )\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": str(exc.detail)}\n    )\n\n@app.exception_handler(Exception)\nasync def general_exception_handler(request: Request, exc: Exception):\n    logging.error(\n        f\"Unexpected error: {str(exc)} - \"\n        f\"Path: {request.url.path} - \"\n        f\"Client: {request.client.host}\",\n        exc_info=True\n    )\n    return JSONResponse(\n        status_code=500,\n        content={\"message\": \"服务器内部错误，请稍后重试\"}\n    )\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"健康检查接口\"\"\"\n    try:\n        # 检查存储目录\n        if not os.path.exists(\"static/audio\"):\n            raise Exception(\"Audio directory not found\")\n        \n        # 检查存储空间\n        total, used, free = shutil.disk_usage(\"/\")\n        if free < 1024 * 1024 * 100:  # 小于100MB空间时报警\n            raise Exception(\"Low disk space\")\n        \n        # 检查 Edge TTS 服务\n        voices = await edge_tts.list_voices()\n        if not voices:\n            raise Exception(\"No voices available\")\n        \n        return {\n            \"status\": \"healthy\",\n            \"disk_space\": {\n                \"total\": f\"{total / 1024 / 1024 / 1024:.1f}GB\",\n                \"used\": f\"{used / 1024 / 1024 / 1024:.1f}GB\",\n                \"free\": f\"{free / 1024 / 1024 / 1024:.1f}GB\"\n            },\n            \"voices_count\": len(voices)\n        }\n    except Exception as e:\n        logging.error(f\"Health check failed: {str(e)}\", exc_info=True)\n        raise HTTPException(status_code=503, detail=str(e))\n\n# 修改主函数，启动清理任务\nif __name__ == \"__main__\":\n    import uvicorn\n    \n    # 创建清理任务\n    @app.on_event(\"startup\")\n    async def startup_event():\n        asyncio.create_task(cleanup_old_files())\n    \n    uvicorn.run(app, host=\"0.0.0.0\", port=8005) \n"}

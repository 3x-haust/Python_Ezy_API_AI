{"repo_info": {"repo_name": "OSNAP", "repo_owner": "Open-Swarm-Net", "repo_url": "https://github.com/Open-Swarm-Net/OSNAP"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/test_agent.py", "content": "from osnap_client.agents import SwarmAgentBase, AgentInfo, AgentTaskResult\nfrom uuid import uuid4\n\n\nclass FakeAgent(SwarmAgentBase):\n    name = \"test_agent\"\n    description = \"test agent\"\n    tools = [\"test_tool\"]\n    id = \"1234\"\n    url = \"foobar\"\n\n    def run(self, task):\n        pass\n\n    def listen(self, result: AgentTaskResult):\n        return super().listen(result)\n\n    def start(self, objective: str, agent_url=None):\n        return super().start(objective, agent_url)\n\n\ndef test_agent_creation():\n    agent = FakeAgent()\n    assert agent.name == \"test_agent\"\n    assert agent.description == \"test agent\"\n    assert agent.tools == [\"test_tool\"]\n\n    # validate arguments\n    try:\n\n        class BadAgent(SwarmAgentBase):\n            name = 1\n            description = 2\n            tools = 3\n\n        agent = BadAgent(name=\"test_agent\")\n    except Exception as e:\n        assert e.__class__.__name__ == \"TypeError\"\n\n\ndef test_agent_required_methods():\n    class FakeAgentWithoutMethods(SwarmAgentBase):\n        name = \"test_agent\"\n        description = \"test agent\"\n        tools = [\"test_tool\"]\n        id = \"1234\"\n        url = \"foobar\"\n\n    try:\n        agent = FakeAgentWithoutMethods()\n    except Exception as e:\n        assert e.__class__.__name__ == \"TypeError\"\n\n\n# Agents should have a /info endpoint that returns the agent's name, description, and scope.\ndef test_agent_info():\n    agent = FakeAgent()\n\n    assert agent.info() == AgentInfo(\n        **{\n            \"name\": \"test_agent\",\n            \"description\": \"test agent\",\n            \"id\": \"1234\",\n            \"tools\": [\"test_tool\"],\n            \"url\": \"foobar\",\n        }\n    )\n\nfrom unittest.mock import patch\n\n\ndef test_register_command_called():\n    with patch.object(SwarmAgentBase, \"_register_command\") as mock_register:\n\n        agent = FakeAgent()\n\n        mock_register.assert_called_once()"}
{"type": "test_file", "path": "tests/test_registry.py", "content": "from osnap_client.managers import SwarmManager\nfrom osnap_client.agents import SwarmAgent\nfrom osnap_client.registry import RedisSwarmRegistry\nimport pytest\n\n\nclass TestRegistry: \n\n    def setup_class(self): \n        print(\"setting up test registry using redis, make sure redis is running locally\")\n        self.registry = RedisSwarmRegistry(db=1)\n       \n\n    def teardown_class(self):\n        print(\"tearing down test registry\")\n        self.registry.redis.flushdb()\n\n\n    def test_add_swarm_manager_to_registry(self): \n\n        mgr = SwarmManager(\n            id=12341,\n            name=\"alice\"\n        )\n\n        self.registry.add_swarm_entry(mgr)\n        retrieved_mgr = self.registry.retrieve_swarm_information(mgr.id)\n        assert retrieved_mgr.id == mgr.id\n\n    def test_add_agent_entry(self): \n        agent = SwarmAgent(\n            name=\"alice\",\n            id=12342,\n            description=\"test agent\"\n        )\n\n        self.registry.add_agent_entry(agent)\n        retrieved_agent = self.registry.retrieve_agent_information(agent.id)\n        assert retrieved_agent.id == agent.id\n\n    def test_agent_join_swarm(self):\n\n        mgr = SwarmManager(\n            id=12343,\n            name=\"alice\"\n        ) \n\n        agent = SwarmAgent(\n            name=\"alice_agent\",\n            id=12344,\n            description=\"test agent\"\n        )\n\n        self.registry.add_swarm_entry(mgr)\n        self.registry.add_agent_entry(agent)\n        self.registry.join_swarm(mgr.id, agent.id)"}
{"type": "test_file", "path": "tests/test_osnap.py", "content": "# # import sys\n# # from pathlib import Path\n# # file_path = Path(__file__).absolute()\n# # sys.path.append(str(file_path.parent.parent))\n\n# from osnap_client import OSNAPApp, OSNAPBaseAgent, OSNAPTool, OSNAPRegistry, Scope\n\n# import uuid\n\n\n# class MockAgentRegistry(OSNAPRegistry):\n#     agents = []\n\n#     def register(self, agent: OSNAPBaseAgent):\n#         agent.id = str(uuid.uuid4())\n#         self.agents.append(agent)\n#         return agent\n\n#     def unregister(self):\n#         pass\n\n\n# class MockToolRegistry(OSNAPRegistry):\n#     tools = []\n\n#     def register(self, tool: OSNAPTool):\n#         tool.id = str(uuid.uuid4())\n#         self.tools.append(tool)\n#         return tool\n\n#     def unregister():\n#         pass\n\n\n# def test_osnap_app_init():\n#     tools = [\n#         OSNAPTool(\n#             name=\"test_tool\",\n#             description=\"test tool\",\n#             scope=Scope.PUBLIC,\n#             invoke_endpoint=\"foobar\",\n#         ),\n#         OSNAPTool(\n#             name=\"test_tool2\",\n#             description=\"test tool2\",\n#             scope=Scope.PUBLIC,\n#             invoke_endpoint=\"foobar2\",\n#         ),\n#     ]\n#     agents = [\n#         OSNAPBaseAgent(\n#             name=\"test_agent\", description=\"test agent\", scope=\"public\", tools=tools\n#         ),\n#         OSNAPBaseAgent(\n#             name=\"test_agent2\", description=\"test agent2\", scope=\"public\", tools=tools\n#         ),\n#     ]\n\n#     agent_registry = MockAgentRegistry()\n#     tool_registry = MockToolRegistry()\n\n#     app = OSNAPApp(\n#         agents=agents,\n#         tools=tools,\n#         agent_registry=agent_registry,\n#         tool_registry=tool_registry,\n#     )\n\n#     assert len(agent_registry.agents) == 2\n#     assert len(tool_registry.tools) == 2\n#     assert len(agent_registry.agents[0].tools) == 2\n\n\n# if __name__ == \"__main__\":\n#     test_osnap_app_init()\n#     print(\"Everything passed\")\n"}
{"type": "test_file", "path": "tests/test_discord_adapter.py", "content": "import sys, os, time\nfrom dotenv import load_dotenv\nfrom pytest import fixture\n\nfrom osnap_client.adapters import DiscordAdapter \n\n\n@fixture\ndef config():\n    load_dotenv()\n    config = {\n        \"bot_token\": os.getenv(\"DISCORD_BOT_TOKEN\"),\n        \"server\": \"swarm1_test\",\n        \"entry_channel\": \"general\",\n        \"intents\": [\"message_content\"],\n    }\n    return config\n\n\n# def test_discord_adapter(config):\n#     adapter = DiscordSwarmAdapter(config)\n#     adapter.run()\n#     time.wait(20)\n#     adapter.stop()\n\n\nif __name__ == \"__main__\":\n    load_dotenv()\n"}
{"type": "source_file", "path": "examples/discord_swarm/langchain_bot.py", "content": "from osnap_client.agents import SwarmAgentBase\nfrom osnap_client.managers import SwarmManagerBase\n\nclass LangchainSwarmManager(SwarmManagerBase):\n    \"\"\"\n    The swarm manager for the Langchain bot.\n    \"\"\"\n    pass\n\n    "}
{"type": "source_file", "path": "osnap_client/core/crypt.py", "content": "from cryptography.hazmat.primitives import serialization, hashes\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.serialization import (\n    Encoding,\n    PublicFormat,\n    PrivateFormat,\n    NoEncryption,\n)\nimport rsa\n\n\nclass SignatureUtil:\n    @staticmethod\n    def generate_key_pair():\n        (public_key, private_key) = rsa.new_keys(512, poolsize=8)\n        private_pem = private_key.private_bytes(\n            Encoding.PEM, PrivateFormat.PKCS8, NoEncryption()\n        )\n        public_pem = private_key.public_key().public_bytes(\n            Encoding.PEM, PublicFormat.SubjectPublicKeyInfo\n        )\n        return private_pem, public_pem\n\n    @staticmethod\n    def sign_data(private_key_pem, data):\n        private_key = serialization.load_pem_private_key(private_key_pem, None)\n        signature = private_key.sign(data.encode(), padding.PKCS1v15(), hashes.SHA256())\n        return signature\n\n    @staticmethod\n    def verify_signature(public_key_pem, data, signature):\n        public_key = serialization.load_pem_public_key(public_key_pem)\n        try:\n            public_key.verify(\n                signature, data.encode(), padding.PKCS1v15(), hashes.SHA256()\n            )\n            return True\n        except Exception as e:\n            return False\n"}
{"type": "source_file", "path": "docs/conf.py", "content": "# Configuration file for the Sphinx documentation builder.\n#\n# For the full list of built-in configuration values, see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Project information -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\nproject = 'OSNAP'\ncopyright = '2023, Forrest Murray'\nauthor = 'Forrest Murray'\nrelease = '0.1.1'\n\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autodoc.typehints\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx.ext.napoleon\",\n    \"sphinx.ext.viewcode\",\n    \"sphinxcontrib.autodoc_pydantic\",\n    \"myst_nb\",\n    \"sphinx_copybutton\",\n    \"sphinx_panels\",\n    \"IPython.sphinxext.ipython_console_highlighting\",\n]\n\nsource_suffix = [\".ipynb\", \".html\", \".md\", \".rst\"]\n\ntemplates_path = ['_templates']\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \"sphinx_book_theme\"\n\nhtml_theme_options = {\n    \"path_to_docs\": \"docs\",\n    \"repository_url\": \"https://github.com/open-swarm-net/OSNAP\",\n    \"use_repository_button\": True,\n}\n\nhtml_context = {\n    \"display_github\": True,  # Integrate GitHub\n    \"github_user\": \"open-swarm-net\",  # Username\n    \"github_repo\": \"OSNAP\",  # Repo name\n    \"github_version\": \"main\",  # Version\n    \"conf_py_path\": \"/docs/\",  # Path in the checkout to the docs root\n}\n\n## Notebooks configuration\n\nnb_execution_mode = \"off\"\n"}
{"type": "source_file", "path": "examples/discord_swarm/app.py", "content": "import sys, os, time\nfrom dotenv import load_dotenv\nfrom pathlib import Path\nfile_path = Path(__file__).absolute()\nsys.path.append(str(file_path.parent.parent.parent))\n\nfrom osnap_client.adapters import DiscordAdapter\nfrom .ping_bot import PingBot\n\nload_dotenv()\n\nintents_list = [\"message_content\", \"members\", \"guilds\"]\nswarm = DiscordAdapter(\n    start_server=os.getenv(\"START_SERVER_NAME\"),\n    intents_list=intents_list,\n    token=os.getenv(\"SWARM_TOKEN\"),\n)\n\n# how does an agent join the swarm? \nping_agent = PingBot(swarm_adapter=swarm)\n\n# The swarm needs to should be responsible for issuing the UUID to the agent\n# otherwise, guaranteeing uniqueness is cumbersome for users\n# \n# Probably \n\n# swarm.join(ping_agent)\n\n\n\ndef main():\n    \"\"\"\n    On a mac, go to Macintosh HD > Applications > Python3.x folder (x being your python3 version) > double click on \"Install Certificates.command\" file\n    \"\"\"\n    load_dotenv()\n\n    intents_list = [\"message_content\", \"members\", \"guilds\"]\n    adapter = DiscordAdapter(\n        start_server=os.getenv(\"START_SERVER_NAME\"),\n        intents_list=intents_list,\n        token=os.getenv(\"PING_BOT_TOKEN\"),\n    )\n\n    agent = ExampleSwarmAgent(\n        name=\"Agent Smith\", description=\"I am a bot that pings\", swarm_adapter=adapter\n    )\n    agent.run()\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "examples/fastapi/app.py", "content": "from alice import AliceSwarmManager\nfrom bob import BobSwarmManager\n\nalice = AliceSwarmManager()\nbob = BobSwarmManager()\n\nalice.join_swarm(bob.swarm_manager_url)"}
{"type": "source_file", "path": "osnap_client/agents/swarm_agent.py", "content": "# from abc import ABC, abstractmethod\n# import asyncio\n# import time\n# import threading\n\n# from osnap_client.adapters import SwarmAdapterBase, QueueTaskStruct\n# from .base import SwarmAgentBase\n\n# class SwarmAgent(SwarmAgentBase):\n#     \"\"\"\n#     Concrete implementation of an OSNAPBaseAgent\n#     \"\"\"\n\n#     def __init__(self, name: str, description: str, swarm_adapter: SwarmAdapterBase) -> None:\n#         self.swarm_adapter = swarm_adapter\n#         # self.event_queue = swarm_adapter.event_queue\n#         # self.command_map = {}\n\n#         # Register \"ready\" command\n#         # self.command_map[\"on_ready\"] = self.on_ready\n\n#     def command(self, name: str):\n#         def decorator(func):\n#             self.command_map[name] = func\n#             return func\n\n#         return decorator\n\n#     async def on_callback_event_listener(self):\n#         while True:\n#             task = None\n#             try:\n#                 task = self.event_queue.get_nowait()\n#             except asyncio.QueueEmpty:\n#                 time.sleep(0.5)\n#                 continue\n#             if not isinstance(task, QueueTaskStruct):\n#                 raise TypeError(f\"Expected a QueueTaskStruct, got {type(task)}\")\n\n#             command = task.command_type\n#             data = task.data\n\n#             if command in self.command_map:\n#                 # check if the adapter loop is running\n#                 if not self.swarm_adapter.adapter_loop.is_running():\n#                     print(\"Adapter loop is not running, starting it now\")\n#                     try:\n#                         self.start_adapter()\n#                     except Exception as e:\n#                         print(f\"Error starting adapter: {e}\")\n#                     if not self.swarm_adapter.adapter_loop.is_running():\n#                         raise Exception(\n#                             \"Adapter loop is still not running after starting it\"\n#                         )\n\n#                 try:\n#                     asyncio.run_coroutine_threadsafe(\n#                         self.command_map[command](data), self.swarm_adapter.adapter_loop\n#                     )\n#                 except Exception as e:\n#                     print(f\"Error in {command} command: {e}\")\n#             else:\n#                 print(f\"Unknown command: {command}\")\n\n#     def start_adapter(self):\n#         adapter_thread = threading.Thread(target=self.swarm_adapter.start)\n#         adapter_thread.start()\n\n#     async def on_ready(self, data: str):\n#         \"\"\"This method is called when the apter is loaded.\"\"\"\n#         self_description = (\n#             f\"Hi everyone!\\nName: {self.name}\\nDescription: {self.description}\"\n#         )\n#         await self.swarm_adapter.send_message(self_description, \"intros\")\n\n#     def run(self):\n#         \"\"\"This method is called to start the bot\n\n#         Clarification on the event loops. Bear with me here =)\n#         Ideally we'd like the adapter and the agent to run in the same event loop,\n#         but both the discord process and the adent process are blocking the event loop.\n\n#         So we need to split the process into two event loops, one for the agent and one for the adapter.\n\n#         However, now we cannot await the adapter methods from the agent, because they are running in different event loops.\n#         Therefore in the agent we need to use the run_coroutine_threadsafe method to run the adapter methods in the adapter event loop.\n#         \"\"\"\n#         # run the adapter in a separate thread\n#         self.start_adapter()\n\n#         # run the event listener in the main thread\n#         agent_loop = asyncio.get_event_loop()\n#         agent_loop.run_until_complete(self.on_callback_event_listener())\n"}
{"type": "source_file", "path": "osnap_client/agents/base.py", "content": "from pydantic import BaseModel, validate_arguments, ValidationError\nfrom pydantic.dataclasses import dataclass\nimport dataclasses\n\nfrom typing import List, Union\nfrom uuid import UUID\nfrom enum import Enum\nfrom abc import ABC, abstractmethod\n\nfrom osnap_client.core import Scope\n\nclass AgentTask(BaseModel):\n    objective: str\n    task_id: Union[int, str, UUID]\n    task_name: str\n    task_description: str\n    task_tool: str = \"\"\n\n\nclass AgentRunResponseStatus(str, Enum):\n    STARTING = \"starting\"\n    WORKING = \"working\"\n    ERROR = \"error\"\n\n\nclass AgentRunResponse(BaseModel):\n    \"\"\"\n    The response from an agent's run method.\n    \"\"\"\n\n    status: AgentRunResponseStatus\n    message: str\n    payload: dict\n\n\nclass AgentTaskResultStatus(str, Enum):\n    SUCCESS = \"success\"\n    ERROR = \"error\"\n\n\nclass AgentTaskResult(BaseModel):\n    \"\"\"\n    The result of an agent's task.\n    Payload might contain metadata like the time it took to run the task\n    \"\"\"\n    task_id: Union[int, str, UUID]\n    task_name: str\n    status: AgentTaskResultStatus\n    message: str\n    payload: dict\n\n\nclass AgentInfo(BaseModel):\n    \"\"\"\n    The response from an agent's info method.\n    \"\"\"\n\n    name: str\n    description: str\n    id: Union[int, str, UUID, None] = None\n    tools: list = []\n    url: str = \"\"\n\n@dataclass\nclass SwarmAgent:\n    name: str\n    description: str\n    id: Union[int, str, UUID] = \"\"\n    type = \"agent\"\n    # if we want tools here, we need a way to serialize it better with registry\n    # tools: list = dataclasses.field(default_factory=lambda: [])\n    url: str = \"\"\n    scope: Scope = Scope.PUBLIC\n\nclass SwarmAgentBase(BaseModel, ABC):\n    \"\"\"\n    Agents are the core of the OSNAP system. They are the entities that interact with one another,\n    or themselves to perform tasks.\n\n    Agents implement the protocol of starting objectives, running tasks, listening for task results, and completing or terminating tasks.\n    \"\"\"\n\n    name: str\n    description: str\n    id: Union[int, str, UUID] = \"\"\n    tools: list = []\n    url: str = \"\"\n    scope: Scope = Scope.PUBLIC\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        self._register_command()\n\n    @classmethod\n    def _register_command(cls):\n        print(\"registering a new command\")\n\n    def info(self) -> AgentInfo:\n        \"\"\"\n        Returns the agent's name, description, and public tools.\n        \"\"\"\n        return AgentInfo(**self.__dict__)\n\n    @abstractmethod\n    def start(self, objective: str, agent_url=None):\n        \"\"\"\n        Begins work on a new objective.\n        If agent_url is provided, it communicates directly with that agent. Otherwise, it searches the registry.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def run(self, task: AgentTask) -> AgentRunResponse:\n        \"\"\"\n        Receives a request from another agent.\n        Returns a run response with a status and optionally, a payload\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def listen(self, result: AgentTaskResult):\n        \"\"\"\n        Receives a task result from another agent.\n        \"\"\"\n        raise NotImplementedError\n\n    def complete(self, payload: dict = {}):\n        \"\"\"\n        Completes the current objective.\n        Can use this to stop listening for particular task results or stop running a task.\n        \"\"\"\n        raise NotImplementedError\n\n    def terminate(self):\n        \"\"\"\n        Terminates the current objective.\n        Can use this to cancel a task or stop listening for particular task results.\n        \"\"\"\n        raise NotImplementedError\n"}
{"type": "source_file", "path": "osnap_client/__init__.py", "content": ""}
{"type": "source_file", "path": "osnap_client/agents/agent_info.py", "content": "from pydantic import BaseModel\nfrom typing import Union, UUID\n\n\nclass AgentInfo(BaseModel):\n    \"\"\"\n    The response from an agent's info method.\n    \"\"\"\n\n    name: str\n    description: str\n    id: Union[int, str, UUID, None] = None\n    tools: list = []\n    url: str = None\n"}
{"type": "source_file", "path": "osnap_client/adapters/fastapi_adapter.py", "content": "# from httpx import Client\nfrom fastapi import FastAPI, HTTPException\nimport httpx\nfrom pydantic import BaseModel\nimport uvicorn \nfrom urllib.parse import urlparse\n\nfrom .base import SwarmAdapterBase\nfrom osnap_client.managers.base import SwarmJoinResponse\n\nclass FastAPISwarmAdapter(SwarmAdapterBase):\n\n    def __init__(self, mgr):\n        self.swarm_manager = mgr\n        self.swarm_manager_url = mgr.swarm_manager_url\n        self.swarm_manager_id = mgr.swarm_manager_id\n        self.app = FastAPI()\n        self.register_routes()\n        # self.connection.headers.update({'Authorization': 'Bearer <token>'})  # Example authorization header\n        # Additional connection setup code specific to REST\n\n    def start(self): \n        o = urlparse(self.swarm_manager_url)\n        uvicorn.run(self.app, host=o.hostname, port=o.port)\n\n    def join_swarm_manager(self, to_swarm_url: str, from_swarm_id: str) -> SwarmJoinResponse:\n        \"\"\"\n        Outgoing request to join a swarm manager\n        \"\"\"\n        url = f\"{to_swarm_url}/join\"\n        \n        response = httpx.post(url, json={\"swarm_manager_id\": self.swarm_manager_id})\n\n        print(f\"Response from {url}: {response.json()}\")\n        \n        joined_id = response.json().get(\"swarm_manager_id\")\n\n        # Handle the response as needed\n        if response.status_code == 200:\n            r = response.json()\n            print(f\"Successfully joined swarm manager {joined_id}\")\n            return SwarmJoinResponse(accepted=True, swarm_manager_id=joined_id, message=r.get(\"message\"))\n        else:\n            print(f\"Failed to join swarm manager {joined_id}. Error: {response.text}\")\n            return SwarmJoinResponse(accepted=False, swarm_manager_id=joined_id, message=response.text)\n\n    def leave_swarm_manager(self, swarm_manager_id: str):\n        pass\n\n    def send_message(self, recipient_id: str, message: dict):\n        pass\n\n    def receive_message(self, sender_id: str, message: dict):\n        pass\n\n    def handle_incoming_messages(self):\n        pass\n\n    def register_routes(self):\n\n        @self.app.get(\"/info\")\n        async def info():\n            return self.swarm_manager.info()\n\n        \"\"\"\n        Allows incoming join requests from other swarm managers\n        \"\"\"\n        class JoinRequest(BaseModel):\n            swarm_manager_id: str\n\n        @self.app.post(\"/join\")\n        async def join_swarm_manager_endpoint(join_request: JoinRequest, response_model=SwarmJoinResponse):\n            print(join_request)\n            try:\n                # self.join_swarm_manager(swarm_manager_id)\n                return SwarmJoinResponse(**{\n                    \"message\": f\"Successfully joined swarm manager {self.swarm_manager_id}\",\n                    \"swarm_manager_id\": self.swarm_manager_id, \n                    \"accepted\": \"true\"\n                })\n            except Exception as e:\n                raise HTTPException(status_code=500, detail=str(e))\n\n        @self.app.post(\"/leave/{swarm_manager_id}\")\n        async def leave_swarm_manager_endpoint(swarm_manager_id: str):\n            try:\n                self.leave_swarm_manager(swarm_manager_id)\n                return {\"message\": f\"Successfully left swarm manager {swarm_manager_id}\"}\n            except Exception as e:\n                raise HTTPException(status_code=500, detail=str(e))\n\n        # Define other route handlers for sending/receiving messages and other operations\n"}
{"type": "source_file", "path": "osnap_client/core/__init__.py", "content": "from .api import OSNAP\nfrom .osnap import (\n    OSNAPApp,\n    OSNAPTool,\n    Scope,\n    OSNAPRegistry,\n    OSNAPRequest,\n    OSNAPResponse,\n    OSNAPError,\n)\n"}
{"type": "source_file", "path": "osnap_client/registry/base.py", "content": "from abc import ABC, abstractmethod\nfrom typing import Dict, Optional, List\nfrom osnap_client.managers import SwarmManagerBase, SwarmManager\nfrom osnap_client.agents import SwarmAgentBase, SwarmAgent\n\nclass SwarmRegistryBase(ABC):\n    @abstractmethod\n    def add_swarm_entry(self, swarm: SwarmManagerBase):\n        \"\"\"\n        Add the information of a joined Swarm to the registry.\n\n        Args:\n            swarm (SwarmManagerBase): Instance of SwarmManagerBase representing the joined Swarm.\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def add_agent_entry(self, agent: SwarmAgentBase):\n        \"\"\"\n        Add the information of an Agent to the registry.\n\n        Args:\n            agent (SwarmAgentBase): Instance of SwarmAgentBase representing the Agent.\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def retrieve_swarm_information(self, swarm_id: str) -> Optional[SwarmManagerBase]:\n        \"\"\"\n        Retrieve the information of a specific Swarm from the registry.\n\n        Args:\n            swarm_id (str): Unique identifier of the Swarm.\n\n        Returns:\n            SwarmManagerBase: Instance of SwarmManagerBase representing the retrieved Swarm, or None if not found.\n        \"\"\"\n\n    @abstractmethod\n    def retrieve_joined_agents(self, agent_id: str) -> List[SwarmAgent]:\n        \"\"\"\n        Retrieve the information the Agents which have joined the registry.\n\n        Returns:\n            SwarmAgentBase: Instance of SwarmAgentBase representing the retrieved Agent, or None if not found.\n        \"\"\"\n\n    @abstractmethod\n    def join_swarm(self, from_entity: SwarmAgent | SwarmManager, to_entity: SwarmManager):\n        \"\"\"\n        Add a relationship between a Swarm and an Agent or other Swarm to the registry.\n\n        Args:\n            from (SwarmAgentBase | SwarmManagerBase): Instance of SwarmAgentBase or SwarmManagerBase representing the source of the relationship.   \n        \"\"\""}
{"type": "source_file", "path": "osnap_client/managers/base.py", "content": "from pydantic import BaseModel\nfrom pydantic.dataclasses import dataclass\nfrom abc import abstractmethod, ABC\n\nclass SwarmConnection: \n    pass\n\nclass SwarmJoinResponse(BaseModel):\n    \"\"\"\n    The response to a join request.\n    \"\"\"\n    accepted: bool\n    swarm_manager_id: str\n    message: str\n\n@dataclass\nclass SwarmManager: \n    id: int\n    name: str\n    type = \"manager\"\n\nclass SwarmManagerBase(ABC): \n    \"\"\"\n    The base class for all swarm managers.\n    \"\"\"\n\n    @abstractmethod\n    def info(self):\n        \"\"\"\n        Return information about the swarm manager\n        \"\"\"\n\n    @abstractmethod\n    def join_swarm() -> SwarmJoinResponse:\n        \"\"\"\n        Make a request to join with an upstream or peer\n        swarm mangager.\n\n        The upstream swarm sends a response accepting\n        or rejecting the join request\n        \"\"\"\n        \n\n    # @abstractmethod\n    # def leave_swarm_manager(self, swarm_manager_id: str):\n    #     pass\n\n    # @abstractmethod\n    # def send_message(self, recipient_id: str, message: dict):\n    #     pass\n\n    # @abstractmethod\n    # def receive_message(self, sender_id: str, message: dict):\n    #     pass"}
{"type": "source_file", "path": "osnap_client/pubsub/pubsub.py", "content": "import asyncio\nimport os\nimport redis.asyncio as redis\nfrom fastapi import WebSocket\n\nfrom dotenv import load_dotenv\nload_dotenv(\".env.sender\")\n\nREDIS_HOST = os.getenv(\"REDIS_HOST\")\nREDIS_PORT = os.getenv(\"REDIS_PORT\")\nREDIS_USERNAME = os.getenv(\"REDIS_USERNAME\")\nREDIS_PASSWORD = os.getenv(\"REDIS_PASSWORD\")\n\nSTOPWORD = \"STOP\"\n\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: list[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def send_personal_message(self, message: str, websocket: WebSocket):\n        await websocket.send_text(message)\n\n    async def broadcast(self, message: str):\n        print(f\"Broadcasting: {message}\")\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\n\nclass PubSub:\n    def __init__(self, redis_url: str = None, channel_name: str = \"osnap\"):\n        self.redis_url = redis_url\n        self.channel_name = channel_name\n        self.redis = None\n        self.pubsub = None\n        self.manager = ConnectionManager()\n\n    async def connect(self):\n        self.redis = redis.Redis(\n            host=REDIS_HOST,\n            port=REDIS_PORT,\n            username=REDIS_USERNAME,\n            password=REDIS_PASSWORD,\n            db=0,\n        )\n        self.pubsub = self.redis.pubsub()\n\n    async def close(self):\n        if self.redis:\n            self.redis.close()\n            await self.redis.wait_closed()\n\n    async def subscribe(self):\n        self.sub = await self.pubsub.subscribe(self.channel_name)\n        future = asyncio.create_task(self.reader(self.pubsub))\n        return future\n\n    async def reader(self, channel: redis.client.PubSub):\n        while True:\n            message = await channel.get_message(ignore_subscribe_messages=True)\n            if message is not None:\n                decoded_message = message[\"data\"].decode()\n                print(f\"(Reader) Message Received: {message}\")\n                # BUG: not seeing this broadcasted to the client\n                await self.manager.broadcast(decoded_message)\n                if message[\"data\"].decode() == STOPWORD:\n                    print(\"(Reader) STOP\")\n                    break\n\n    async def publish(self, message: str):\n        await self.redis.publish(self.channel_name, message)\n        await self.manager.broadcast(message)\n\n    def on_message(self, message):\n        print(f\"Received message: {message}\")\n\n    async def add_conn_manager(self, websocket: WebSocket):\n        await self.manager.connect(websocket)\n"}
{"type": "source_file", "path": "osnap_client/tools/__init__.py", "content": ""}
{"type": "source_file", "path": "osnap_client/core/api.py", "content": "handler_registry = set()\nclass OSNAP:\n  \"\"\"OSNAP API Decorators\n\n  Example usage:\n  @OSNAP.agents()\n  def my_apps_get_agents(request):\n    return my_apps_agent_registry.get_agents(request)\n  \"\"\"\n  def agents():\n      def decorator(func):\n        def wrapper(*args, **kwargs):\n          print(\"Before calling \" + func.__name__)\n          #\n          # OSNAPRequest = *args[\"request\"]\n          func(*args, **kwargs)\n          print(\"After calling \" + func.__name__)\n\n        handler_registry.add((\"agents\", wrapper))    \n        return wrapper\n      return decorator\n  \n  def run():\n      def decorator(func):\n        def wrapper(*args, **kwargs):\n          print(\"Before calling \" + func.__name__)\n          #\n          # OSNAPRequest = *args[\"request\"]\n          print(\"REQUEST: \", args.get(\"request\"))\n          func(*args, **kwargs)\n          print(\"After calling \" + func.__name__)\n\n        handler_registry.add((\"run\", wrapper))    \n        return wrapper\n      return decorator\n\n\n  def tool_invoke():\n      def decorator(func):\n        def wrapper(*args, **kwargs):\n          print(\"Before calling \" + func.__name__)\n          #\n          # OSNAPRequest = *args[\"request\"]\n          func(*args, **kwargs)\n          print(\"After calling \" + func.__name__)\n\n        handler_registry.add((\"tool_invoke\", wrapper))    \n        return wrapper\n      return decorator\n\n  # # TODO: Add the rest of the required endpoints\n"}
{"type": "source_file", "path": "osnap_client/core/osnap.py", "content": "import json\nimport enum\nimport time\nimport uuid\nfrom typing import Callable, Dict, Union, List, Any\nfrom functools import wraps\n\nfrom pydantic import BaseModel\nfrom abc import ABC, abstractmethod\n\nimport networkx as nx\n\nfrom .crypt import SignatureUtil\n\nfrom osnap_client.pubsub import PubSub\n\n\nclass OSNAPRegistry(BaseModel):\n    \"\"\"Base Class for an Agent or Tool Registry\"\"\"\n\n    @abstractmethod\n    def register(self):\n        raise NotImplementedError\n\n    @abstractmethod\n    def unregister(self):\n        raise NotImplementedError\n\n\nclass OSNAPApp:\n    required_handler_types = set(\n        [\n            \"agents\",\n            # \"tools\",\n            # \"run\"\n        ]\n    )\n\n    graph: nx.DiGraph\n    agent_registry: OSNAPRegistry\n    tool_registry: OSNAPRegistry\n\n    def __init__(\n        self,\n        agents: list,\n        tools: list,\n        agent_registry: OSNAPRegistry,\n        tool_registry: OSNAPRegistry,\n    ):\n        ## iterate over all the methods of the API class\n        # TODO: Figure out the best time to check the API\n        # self.check_api()\n        self.handler_registry = set()\n        self.agent_registry = agent_registry\n        self.tool_registry = tool_registry\n        self.pubsub = None\n        self.register_agents(agents)\n\n    async def create_pubsub(self):\n        self.pubsub = PubSub()\n        await self.pubsub.connect()\n        await self.pubsub.subscribe()\n\n    async def call_pubsub(self, message):\n        if self.pubsub is None:\n            return None\n        else:\n            await self.pubsub.publish(message)\n\n    def agents(self, func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # OSNAPRequest = *args[\"request\"]\n            await self.call_pubsub(\"agents\")\n            return await func(*args, **kwargs)\n\n        self.handler_registry.add((\"agents\", wrapper))\n        return wrapper\n\n    def _build_agent_tool_graph(self, agents: list, external=False):\n        app_graph = nx.DiGraph()\n        for agent in agents:\n            if external:\n                agent.scope = Scope.EXTERNAL\n            app_graph.add_node(agent.name, agent=agent)\n            for tool in agent.tools:\n                if external:\n                    tool.scope = Scope.EXTERNAL\n                app_graph.add_node(tool.name, tool=tool)\n                app_graph.add_edge(agent.name, tool.name, type=\"agent->tool\")\n        return app_graph\n\n    def _register_app_graph(self, app_graph: nx.DiGraph):\n        # TODO: put this in RedisGraph\n\n        sorted = list(reversed(list(nx.topological_sort(app_graph))))\n        for node in sorted:\n            if \"agent\" in app_graph.nodes[node]:\n                tool_deps = list(app_graph.successors(node))\n                agent = app_graph.nodes[node][\"agent\"]\n                agent.tools = [\n                    app_graph.nodes[tool][\"tool\"].toJson() for tool in tool_deps\n                ]\n                self.agent_registry.register(app_graph.nodes[node][\"agent\"])\n            elif \"tool\" in app_graph.nodes[node]:\n                assigned = self.tool_registry.register(app_graph.nodes[node][\"tool\"])\n                # Write the assigned id back to the graph\n                app_graph.nodes[node][\"tool\"].id = assigned.id\n\n    def register_agents(self, agents: list, external=False):\n        self.graph = self._build_agent_tool_graph(agents, external=external)\n\n        # register the graph with the app using topo sort\n        self._register_app_graph(self.graph)\n\n    def check_api(self):\n        handler_types = set(\n            [handler_type for (handler_type, handler) in self.handler_registry]\n        )\n        missing_handler_types = self.required_handler_types - handler_types\n        if len(missing_handler_types):\n            raise Exception(\"Missing required handlers: \" + str(missing_handler_types))\n\n\nclass Scope(str, enum.Enum):\n    PUBLIC = \"public\"\n    PRIVATE = \"private\"\n    EXTERNAL = \"external\"\n\n\nclass OSNAPResponse(BaseModel):\n    def __init__(self, payload: Dict):\n        self.payload = json.dumps(payload)\n        self.signature = None\n\n\nclass OSNAPError:\n    def __init__(self, message: str):\n        self.payload = json.dumps({\"error\": message})\n        self.signature = None\n\n\nclass OSNAPRequest(BaseModel):\n    def __init__(\n        self,\n        caller_agent_id: str,\n        request_type: str,\n        task_name: str = None,\n        priority: int = 0,\n        request_metadata: Dict = None,\n        instructions=None,\n    ):\n        self.caller_agent_id = caller_agent_id\n        self.request_type = request_type\n        self.task_name = task_name\n        self.priority = priority\n        self.request_metadata = request_metadata or {}\n        self.timestamp = time.time()\n        self.payload = json.dumps(\n            {\n                \"caller_agent_id\": self.caller_agent_id,\n                \"request_type\": self.request_type,\n                \"task_name\": self.task_name,\n                \"priority\": self.priority,\n                \"request_metadata\": self.request_metadata,\n                \"timestamp\": self.timestamp,\n            }\n        )\n        self.signature = None\n        self.instructions = instructions\n\n\nclass OSNAPTool:\n    def __init__(\n        self,\n        name: str,\n        description: str,\n        invoke_endpoint: str,\n        scope: Scope,\n        invoke_required_params: Dict[str, Any] = {},\n        invoke_optional_params: List[str] = [],\n        id: str = None,\n    ):\n        self.name = name\n        self.description = description\n        self.scope = scope\n        self.invoke_endpoint = invoke_endpoint\n        self.invoke_required_params = invoke_required_params\n        self.invoke_optional_params = invoke_optional_params\n        self.id = id\n\n    def __str__(self) -> str:\n        return f\"Tool: {self.name} id: ({self.id}) description: {self.description} scope: {self.scope} invoke_endpoint: {self.invoke_endpoint} invoke_required_params: {self.invoke_required_params} invoke_optional_params: {self.invoke_optional_params}\"\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n    def toJson(self):\n        return json.dumps(self, default=lambda o: o.__dict__)\n\n\n# Usage Example\n\n# @OSNAP.agents()\n# def my_apps_agent_handler():\n#  return my_apps_agent_registry.get_agents(request)\n#\n# myapp = OSnapApp()\n"}
{"type": "source_file", "path": "osnap_client/registry/agent_registry.py", "content": "import redis\nimport json\nimport uuid\n\nfrom osnap_client.agents import SwarmAgentBase\n\nimport logging\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass AgentRegistry:\n    def __init__(self, host, port, username, password):\n        self.redis_client = redis.Redis(\n            host=host,\n            port=port,\n            username=username,\n            password=password,\n            decode_responses=True,\n        )\n\n    def register(self, agent: SwarmAgentBase):\n        return self.get_or_create_agent(agent)\n\n    def get_agents(self, scope):\n        return self._get_agents_by_scope(scope)\n\n    def _get_agents_by_scope(self, scope):\n        agent_ids = self.redis_client.smembers(f\"scope:{scope}:agents\")\n        agents = []\n        for agent_id in agent_ids:\n            agent_data = self.redis_client.hgetall(f\"agent:{agent_id}\")\n            agent = {k: v for k, v in agent_data.items()}\n            agents.append(agent)\n        return agents\n\n    def get_or_create_agent(self, agent: SwarmAgentBase):\n        if self.redis_client.hexists(f\"agent:{agent.name}\", agent.name):\n            return self.get_agent(agent.name)\n        else:\n            agent.id = str(uuid.uuid4())\n            self.add_agent(agent)\n\n    def get_agent(self, name):\n        agent_data = self.redis_client.hget(f\"agent:{name}\", name)\n        if agent_data:\n            agent_data[\"tools\"] = json.loads(agent_data[\"tools\"])\n            return agent_data\n        return None\n\n    def add_agent(self, agent: SwarmAgentBase) -> SwarmAgentBase | None:\n        agent_data = {\n            \"id\": agent.id,\n            \"name\": agent.name,\n            \"description\": agent.description,\n            \"tools\": json.dumps(agent.tools),\n            \"scope\": agent.scope,\n        }\n        name = agent.name\n        if not self.redis_client.hexists(f\"agent:{name}\", name):\n            self.redis_client.hset(f\"agent:{name}\", mapping=agent_data)\n            self.redis_client.sadd(f\"scope:{agent.scope}:agents\", name)\n            LOGGER.info(\"Agent {agent_id} created with name '{name}'.\")\n            return agent\n\n    def update_tools(self, agent_id, tools):\n        agent_key = f\"agent:{agent_id}\"\n        self.redis_client.hset(agent_key, \"tools\", json.dumps(tools))\n\n    def remove_agent(self, agent_id):\n        agent_key = f\"agent:{agent_id}\"\n        self.redis_client.delete(agent_key)\n\n    def get_agent_by_id(self, agent_id):\n        agent_key = f\"agent:{agent_id}\"\n        agent_data = self.redis_client.hgetall(agent_key)\n        if agent_data:\n            agent_data[\"tools\"] = json.loads(agent_data[\"tools\"])\n            return agent_data\n        return None\n\n    def search_agents_by_tool_description(self, search_query):\n        matching_agents = []\n        for key in self.redis_client.scan_iter(match=\"agent:*\"):\n            agent_data = self.redis_client.hgetall(key)\n            tools = json.loads(agent_data[\"tools\"])\n            for tool in tools:\n                if search_query.lower() in tool[\"description\"].lower():\n                    agent_data[\"tools\"] = tools\n                    matching_agents.append(agent_data)\n                    break\n        return matching_agents\n"}
{"type": "source_file", "path": "osnap_client/utils/ai_engines/GPTConversEngine.py", "content": "import os\nimport openai\nimport tiktoken\n\nfrom osnap_client.utils.ai_engines.EngineBase import EngineBase\n\n\nclass GPTConversEngine(EngineBase):\n    \"\"\"\n    gpt-4, gpt-4-0314, gpt-4-32k, gpt-4-32k-0314, gpt-3.5-turbo, gpt-3.5-turbo-0301\n    \"\"\"\n\n    SUPPORTED_MODELS = [\n        \"gpt-4\",\n        \"gpt-4-0314\",\n        \"gpt-4-32k\",\n        \"gpt-4-32k-0314\",\n        \"gpt-3.5-turbo\",\n        \"gpt-3.5-turbo-0301\",\n    ]\n\n    def __init__(self, model_name: str, temperature: float, max_response_tokens: int):\n        if model_name not in self.SUPPORTED_MODELS:\n            raise ValueError(\n                f\"Model {model_name} is not supported. Supported models are: {self.SUPPORTED_MODELS}\"\n            )\n\n        super().__init__(\"openai\", model_name, temperature, max_response_tokens)\n\n        if \"OPENAI_API_KEY\" not in os.environ:\n            raise ValueError(\"OPENAI_API_KEY environment variable is not set.\")\n\n        openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n        self.tiktoken_encoding = tiktoken.encoding_for_model(model_name)\n\n    def call_model(self, conversation, max_tokens=None, temperature=None) -> str:\n        \"\"\"Calls the gpt-3.5 or gpt-4 model to generate a response to a conversation.\n\n        Args:\n            conversation (list[dict]): The conversation to be completed. Example:\n                [\n                    {\"role\": \"system\", \"content\": configuration_prompt},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n        \"\"\"\n        if max_tokens is None:\n            max_tokens = self.max_response_tokens\n        if temperature is None:\n            temperature = self.temperature\n\n        if isinstance(conversation, str):\n            conversation = [{\"role\": \"user\", \"content\": conversation}]\n\n        if len(conversation) == 0:\n            raise ValueError(\n                \"Conversation must have at least one message of format: [{'role': 'user', 'content': 'message'}]\"\n            )\n\n        total_len = 0\n        for message in conversation:\n            if \"role\" not in message:\n                raise ValueError(\n                    \"Conversation messages must have a format: {'role': 'user', 'content': 'message'}. 'role' is missing.\"\n                )\n            if \"content\" not in message:\n                raise ValueError(\n                    \"Conversation messages must have a format: {'role': 'user', 'content': 'message'}. 'content' is missing.\"\n                )\n            message[\"content\"] = self.truncate_message(\n                message[\"content\"], self.max_input_length() - total_len - 100\n            )\n            new_message_len = len(self.tiktoken_encoding.encode(message[\"content\"]))\n            total_len += new_message_len\n\n        try:\n            response = openai.ChatCompletion.create(\n                model=self.model_name,\n                messages=conversation,\n                max_tokens=max_tokens,\n                temperature=temperature,\n                n=1,\n            )\n        except:\n            return \"\"\n        return response[\"choices\"][0][\"message\"][\"content\"]\n"}
{"type": "source_file", "path": "osnap_client/tools/main.py", "content": ""}
{"type": "source_file", "path": "osnap_client/utils/ai_engines/EngineBase.py", "content": "from abc import ABC, abstractmethod\n\nclass EngineBase(ABC):\n    \"\"\"Abstract base class for the AI engines.\n    Engines define the API for the AI engines that can be used in the swarm.\n    \"\"\"\n    \n    TOKEN_LIMITS = {\n        \"gpt-4\": 16*1024,\n        \"gpt-4-0314\": 16*1024,\n        \"gpt-4-32k\": 32*1024,\n        \"gpt-4-32k-0314\": 32*1024,\n        \"gpt-3.5-turbo\": 4*1024,\n        \"gpt-3.5-turbo-0301\": 4*1024\n    }\n    \n    def __init__(self, provider, model_name: str, temperature: float, max_response_tokens: int):\n        self.provider = provider\n        self.model_name = model_name\n        self.temperature = temperature\n        self.max_response_tokens = max_response_tokens\n\n    @abstractmethod\n    def call_model(self, conversation: list) -> str:\n        \"\"\"Call the model with the given conversation.\n        Input always in the format of openai's conversation.\n        Output a string.\n\n        Args:\n            conversation (list[dict]): The conversation to be completed. Example:\n                [\n                    {\"role\": \"system\", \"content\": configuration_prompt},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n\n        Returns:\n            str: The response from the model.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def max_input_length(self) -> int:\n        \"\"\"Returns the maximum length of the input to the model.\n\n        Returns:\n            int: The maximum length of the input to the model.\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def truncate_message(self, message):\n        \"\"\"Truncates the message using tiktoken\"\"\"\n        raise NotImplementedError\n    \n        \n    def max_input_length(self) -> int:\n        \"\"\"Returns the maximum length of the input to the model in temrs of tokens.\n\n        Returns:\n            int: The max tokens to input to the model.\n        \"\"\"\n        return self.TOKEN_LIMITS[self.model_name]-self.max_response_tokens\n    \n    def truncate_message(self, message, token_limit=None):\n        \"\"\"Truncates the message using tiktoken\"\"\"\n        max_tokens = self.max_input_length()\n        message_tokens = self.tiktoken_encoding.encode(message)\n\n        if token_limit is not None:\n            max_tokens = min(max_tokens, token_limit)\n\n        if len(message_tokens) <= max_tokens:\n            return message\n        else:\n            return self.tiktoken_encoding.decode(message_tokens[:max_tokens])"}
{"type": "source_file", "path": "osnap_client/pubsub/__init__.py", "content": "from .pubsub import PubSub, ConnectionManager\n"}
{"type": "source_file", "path": "osnap_client/registry/redis_registry.py", "content": "import redis\nfrom redis.commands.graph import Graph, Node, Edge\nimport networkx as nx\nfrom typing import List, Dict\nfrom enum import Enum\nfrom dataclasses import asdict\n\nfrom osnap_client.managers import SwarmManager\nfrom osnap_client.agents import SwarmAgent\nfrom .base import SwarmRegistryBase\n\nclass SwarmRelationship:\n    JOINED = \"joined\"\n\nclass RedisSwarmRegistry(SwarmRegistryBase):\n    def __init__(self, host='localhost', port=6379, db=0, graph_name='swarm_registry'):\n        self.redis = redis.StrictRedis(host=host, port=port, db=db, decode_responses=True)\n        self.redis_graph = Graph(self.redis, graph_name)\n        self.graph = nx.DiGraph()\n\n    def _entity_to_node(self, entity: SwarmManager | SwarmAgent) -> Node:\n        return Node(node_id=entity.id, alias=entity.name, label=entity.type, properties=asdict(entity))\n\n\n    def _add_node(self, node: SwarmManager | SwarmAgent):\n        self.graph.add_node(node.id)\n        if isinstance(node, SwarmManager):\n            self.add_swarm_entry(node)\n        elif isinstance(node, SwarmAgent):\n            self.add_agent_entry(node)\n\n    def _add_edge(self, from_node: Node, to_node: Node, relationship):\n        match_query = f\"MATCH (a:{from_node.label}),(b:{to_node.label}) WHERE a.id = {from_node.id} AND b.id = {to_node.id}\"\n\n        query = f\"\"\"\n        {match_query}\n        CREATE (a)-[r:joined]->(b) RETURN r\n        \"\"\".replace(\"\\n\", \"\")\n\n        self.redis_graph.query(query)\n\n    def add_swarm_entry(self, swarm: SwarmManager):\n        node = self._entity_to_node(swarm)\n        self._persist_node(node)\n\n    def add_agent_entry(self, agent: SwarmAgent):\n        node = self._entity_to_node(agent)\n        self._persist_node(node)\n\n    def join_swarm(self, from_entity: SwarmAgent | SwarmManager, to_entity: SwarmManager):\n        \"\"\"\n        Adds an edge between two nodes in the graph\n        \"\"\"\n        from_node = self._entity_to_node(from_entity)\n        to_node = self._entity_to_node(to_entity)\n\n        return self._add_edge(from_node, to_node, SwarmRelationship.JOINED)\n\n    def _persist_node(self, node: Node):\n        query = f\"CREATE {node}\"\n        self.redis_graph.query(query)\n\n    def retrieve_swarm_information(self, swarm_id: int) -> SwarmManager:\n        swarm_key = f'swarm:{swarm_id}'\n        swarm_data = self.redis.hgetall(swarm_key)\n        if swarm_data:\n            # Parse the swarm_data and return an instance of SwarmManagerBase\n            # You can use the retrieved data to populate the SwarmManagerBase attributes\n\n            return SwarmManager(**swarm_data)\n        return None\n\n    def retrieve_joined_agents(self) -> List[SwarmAgent]:\n        agent_data = self.redis_graph.query(\"MATCH (a:agent)-[:joined]->(b:manager) RETURN a\")\n        if agent_data:\n            # Parse the agent_data and return an instance of SwarmAgentBase\n            # You can use the retrieved data to populate the SwarmAgentBase attributes\n            return [SwarmAgent(**agent_data) for agent_data in agent_data]\n        return None\n\n    # def perform_graph_query(self, query: str) -> List[Dict]:\n    #     # Perform the graph query using networkx and return the results\n    #     results = nx.query.ancestors(self.graph, query)  # Example query, customize as per your requirements\n    #     return list(results)\n"}
{"type": "source_file", "path": "osnap_client/registry/tool_registry.py", "content": "import redis\nimport uuid\n\nfrom osnap_client.core import OSNAPTool\n\n\nclass ToolRegistry:\n    def __init__(self, host, port, username, password):\n        self.redis_client = redis.Redis(\n            host=host,\n            port=port,\n            username=username,\n            password=password,\n            decode_responses=True,\n        )\n\n    def register(self, tool: OSNAPTool) -> OSNAPTool:\n        return self.get_or_create_tool(tool)\n\n    def get_tool(self, name):\n        tool_data = self.redis_client.hget(f\"tool:{name}\", name)\n        if tool_data:\n            return tool_data\n        return None\n\n    def get_tools(self, scope):\n        return self._get_tools_by_scope(scope)\n\n    def _get_tools_by_scope(self, scope):\n        tool_ids = self.redis_client.smembers(f\"scope:{scope}:tools\")\n        tools = []\n        for tool_id in tool_ids:\n            tool_data = self.redis_client.hgetall(f\"tool:{tool_id}\")\n            tool = {k: v for k, v in tool_data.items()}\n            tools.append(tool)\n        return tools\n\n    def get_or_create_tool(self, tool: OSNAPTool) -> OSNAPTool:\n        name = tool.name\n        if self.redis_client.hexists(f\"tool:{name}\", name):\n            return self.get_tool(tool)\n        else:\n            return self.add_tool(tool)\n\n    def add_tool(self, tool: OSNAPTool) -> OSNAPTool:\n        name = tool.name\n\n        if not self.redis_client.hexists(f\"tool:{name}\", name):\n            id = uuid.uuid4()\n            tool.id = str(id)\n            tool_data = {\n                \"id\": tool.id,\n                \"name\": name,\n                \"description\": tool.description,\n                \"scope\": tool.scope,\n            }\n            self.redis_client.hset(f\"tool:{name}\", mapping=tool_data)\n            self.redis_client.sadd(f\"scope:{tool.scope}:tools\", name)\n            return tool\n"}
{"type": "source_file", "path": "osnap_client/utils/ai_engines/__init__.py", "content": "from .EngineBase import EngineBase\nfrom .GPTConversEngine import GPTConversEngine\nfrom .LanchainGoogleEngine import LanchainGoogleEngine"}
{"type": "source_file", "path": "osnap_client/registry/__init__.py", "content": "from .agent_registry import AgentRegistry\nfrom .tool_registry import ToolRegistry\nfrom .redis_registry import RedisSwarmRegistry\n "}
{"type": "source_file", "path": "examples/fastapi/alice.py", "content": "from osnap_client.managers import SwarmManagerBase\nfrom osnap_client.adapters import FastAPISwarmAdapter\n\n\n\nclass AliceSwarmManager(SwarmManagerBase):\n    swarm_manager_id = \"alice\"\n    swarm_manager_url = \"http://localhost:8000\"\n\n    def __init__(self):\n        self.swarm_adapter = FastAPISwarmAdapter(self)\n\n    def info(self):\n        return {\n            \"swarm_manager_id\": self.swarm_manager_id,\n            \"swarm_manager_url\": self.swarm_manager_url\n        }\n\n    def join_swarm(self, swarm_manager_url: str):\n        self.swarm_adapter.join_swarm_manager(swarm_manager_url, self.swarm_manager_id)\n\n\n\nalice = AliceSwarmManager()\n\nif __name__ == \"__main__\":\n    alice.swarm_adapter.start()"}
{"type": "source_file", "path": "osnap_client/agents/__init__.py", "content": "from .base import (\n    SwarmAgent,\n    SwarmAgentBase,\n    AgentInfo,\n    AgentTask,\n    AgentRunResponse,\n    AgentRunResponseStatus,\n    AgentTaskResult,\n)\n# from .swarm_agent import SwarmAgent\n\n__all__ = [\n    \"SwarmAgent\",\n    \"SwarmAgentBase\",\n    \"AgentInfo\",\n    \"AgentTask\",\n    \"AgentRunResponse\",\n    \"AgentRunResponseStatus\",\n    \"AgentTaskResult\",\n    \"SwarmAgent\",\n]\n"}
{"type": "source_file", "path": "osnap_client/adapters/discord_adapter.py", "content": "# discord_adapter.py\nimport discord\nfrom .base import SwarmAdapterBase, QueueTaskStruct\nimport asyncio\n\n\nclass DiscordAdapter(SwarmAdapterBase):\n    \"\"\"This is an adapter that allows the agent to communicate with Discord and receive/send messages.\n\n    Args:\n    - intents_list (list[str]): A list of intents that the bot will listen to.\n    - token (str): The token of the bot that is used to connect to Discord.\n    \"\"\"\n\n    def __init__(self, start_server: str, intents_list: list, token: str):\n        super().__init__()\n        intents = self._unpack_intents(intents_list)\n\n        self.adapter_loop = asyncio.new_event_loop()\n        self.client = discord.Client(loop=self.adapter_loop, intents=intents)\n        self.token = token\n        self.start_server_name = start_server\n        self.guild = None\n\n    async def on_ready(self):\n        \"\"\"This method is called automatically by the discord library when the bot is ready to start working.\"\"\"\n        response = QueueTaskStruct(command_type=\"on_ready\", data=\"\")\n        await self.add_to_queue(response)\n\n    async def on_message(self, message):\n        \"\"\"This method is called automatically by the discord library when a message is received.\"\"\"\n        if message.author == self.client.user:\n            return\n\n        message_content = message.content\n\n        if message.content.startswith(\"$\"):\n            command_name = message_content.split(\" \")[0][1:]\n            command_data = \" \".join(message_content.split(\" \")[1:])\n            response = QueueTaskStruct(command_type=command_name, data=command_data)\n            await self.add_to_queue(response)\n\n    async def get_users(self):\n        \"\"\"Returns the information about the users on the server\n        # About me is not available in the API: https://stackoverflow.com/questions/68654914/discord-py-get-user-about-me-section\n        \"\"\"\n        users = []\n        users_iterator = self.client.guilds[0].fetch_members()\n        async for user in users_iterator:\n            users.append(user.name)\n        return users\n\n    async def send_message(self, message: str, target_channel=\"general\"):\n        \"\"\"Sends a message to the specified channel\"\"\"\n        if self.guild is None:\n            self.guild = self._get_start_guild()\n\n        # Find the channel by its name\n        for channel in self.guild.channels:\n            if channel.name == target_channel and isinstance(\n                channel, discord.TextChannel\n            ):\n                await channel.send(message)\n                print(f\"Sent message {message} to channel {target_channel}\")\n                return\n\n        raise ValueError(\n            f\"Could not find the channel {target_channel} in the list of channels: {self.guild.channels}.\"\n        )\n\n    async def send_dm(self, message: str, target_user: str):\n        \"\"\"Sends a direct message to the specified user\"\"\"\n        if self.guild is None:\n            self.guild = self._get_start_guild()\n\n        for user in self.client.guild.members:\n            if user.name == target_user:\n                await user.send(message)\n\n        raise ValueError(\n            f\"Could not find the user {target_user} in the list of users: {self.guild.members}.\"\n        )\n\n    def start(self):\n        # adding the methods to the adapter\n        self.client.event(self.on_ready)\n        self.client.event(self.on_message)\n        # need to launch the adapter loop\n        self.adapter_loop.run_until_complete(self.client.start(self.token))\n\n    def _unpack_intents(self, intents_list: list) -> discord.Intents:\n        intents_obj = discord.Intents.default()\n        for intent in intents_list:\n            # check if the intent is a vaild attribute of discord.Intents\n            if hasattr(intents_obj, intent):\n                setattr(intents_obj, intent, True)\n            else:\n                raise ValueError(f\"Invalid intent: {intent}\")\n        return intents_obj\n\n    def _get_start_guild(self):\n        \"\"\"In discord api the servers are called guilds.\"\"\"\n        # Find the guild by its name\n        target_guild = None\n        for guild in self.client.guilds:\n            if guild.name == self.start_server_name:\n                target_guild = guild\n                return target_guild\n\n        raise ValueError(\n            f\"Could not find the guild {self.start_server_name} in the list of guilds: {self.client.guilds}. Make sure the bot is added to the server: https://discordpy.readthedocs.io/en/stable/discord.html\"\n        )\n"}
{"type": "source_file", "path": "examples/fastapi/bob.py", "content": "from osnap_client.managers import SwarmManagerBase\nfrom osnap_client.adapters import FastAPISwarmAdapter\n\n\nclass BobSwarmManager(SwarmManagerBase):\n    swarm_manager_id = \"bob\"\n    swarm_manager_url = \"http://localhost:8001\"\n\n    def __init__(self):\n        self.swarm_adapter = FastAPISwarmAdapter(self)\n\n    def info(self):\n        return {\n            \"swarm_manager_id\": self.swarm_manager_id,\n            \"swarm_manager_url\": self.swarm_manager_url\n        }\n    \n    def join_swarm(self, swarm_manager_url: str):\n        self.swarm_adapter.join_swarm_manager(swarm_manager_url)\n\nbob = BobSwarmManager()\n\nif __name__ == \"__main__\":\n    bob.swarm_adapter.start()"}
{"type": "source_file", "path": "osnap_client/adapters/__init__.py", "content": "from .base import SwarmAdapterBase, QueueTaskStruct\nfrom .discord_adapter import DiscordAdapter\nfrom .fastapi_adapter import FastAPISwarmAdapter"}
{"type": "source_file", "path": "osnap_client/adapters/base.py", "content": "from abc import ABC, abstractmethod\nimport asyncio\nimport functools\n\nfrom pydantic import BaseModel\n\n\nclass QueueTaskStruct(BaseModel):\n    \"\"\"QueueTaskStruct holds the callback function and the arguments to pass to it.\"\"\"\n\n    command_type: str\n    data: str\n\n\n# class AdapterBase(ABC):\n#     \"\"\"This class stores some basic properties that every adapter should implement.\"\"\"\n\n#     def __init__(self) -> None:\n#         self.event_queue = asyncio.Queue()\n\n#     async def add_to_queue(self, task):\n#         if not isinstance(task, QueueTaskStruct):\n#             raise TypeError(\n#                 f\"Expected a QueueTaskStruct to add to the event_queue, got {type(task)}\"\n#             )\n#         await self.event_queue.put(task)\n#         print(f\"Added {task} to the event_queue\")\n\n#     @abstractmethod\n#     async def on_ready(self) -> QueueTaskStruct:\n#         \"\"\"This method is called when the apter is loaded.\n#         The output is forwarded to the agent through the event queue.\n#         \"\"\"\n#         raise NotImplementedError\n\n#     @abstractmethod\n#     async def on_message(self, message: str) -> QueueTaskStruct:\n#         \"\"\"This method is called when the apter is loaded\"\"\"\n#         raise NotImplementedError\n\n#     @abstractmethod\n#     async def get_users(self):\n#         \"\"\"Returns the information about the users on the server\"\"\"\n#         raise NotImplementedError\n\n#     @abstractmethod\n#     async def send_message(self, message: str, target_channel: str):\n#         \"\"\"This method is called to send a message to a specific channel\"\"\"\n#         raise NotImplementedError\n\n#     @abstractmethod\n#     async def send_dm(self, message: str, target_user: str):\n#         \"\"\"This method is called to send a message to a specific user\"\"\"\n#         raise NotImplementedError\n\n#     @abstractmethod\n#     async def start():\n#         \"\"\"This method is called to start the adapter\"\"\"\n#         raise NotImplementedError\n\nclass SwarmAdapterBase(ABC):\n    # @abstractmethod\n    # def connect(self):\n    #     pass\n\n    # @abstractmethod\n    # def disconnect(self):\n    #     pass\n\n    @abstractmethod\n    def start(self):\n        \"\"\"\n        Start the adapter\n        \"\"\"\n\n    @abstractmethod\n    def join_swarm_manager(self, swarm_manager_id: str):\n        pass\n\n    # @abstractmethod\n    # def leave_swarm_manager(self, swarm_manager_id: str):\n    #     pass\n\n    # @abstractmethod\n    # def send_message(self, recipient_id: str, message: dict):\n    #     pass\n\n    # @abstractmethod\n    # def receive_message(self, sender_id: str, message: dict):\n    #     pass\n\n    # @abstractmethod\n    # def handle_incoming_messages(self):\n    #     pass"}
{"type": "source_file", "path": "examples/discord_swarm/ping_bot.py", "content": "import sys, os, time\nfrom dotenv import load_dotenv\n\n# adding the lates version of the osnap_client to the path\nfrom pathlib import Path\nfile_path = Path(__file__).absolute()\nsys.path.append(str(file_path.parent.parent.parent))\n\nfrom osnap_client.adapters import DiscordAdapter\nfrom osnap_client.agents import SwarmAgent, OSNAPBaseAgent\n\nclass PingBot(OSNAPBaseAgent):\n    \n    name = \"Ping Bot\"\n    description = \"I am a bot that pings\"\n    \n    def __init__(self, swarm_adapter):\n        self.num_pings = 0\n        self.max_pings = 5\n\n    def start(self):\n        pass\n\n    def run(self):\n        \n\n    \n\n        @self.command(name=\"hello\")\n        async def hello(message):\n            await self.swarm_adapter.send_message(\"Hello!\", \"general\")\n            # await self.send_message(\"Hello!\", \"general\")\n\n        @self.command(name=\"ping\")\n        async def ping(message):\n            if self.num_pings >= self.max_pings:\n                await self.swarm_adapter.send_message(\"I'm done pinging!\", \"general\")\n                return\n            time.sleep(2)\n            self.num_pings += 1\n            await self.swarm_adapter.send_message(\"$pong\", \"general\")\n\n        @self.command(name=\"reset\")\n        async def reset(message):\n            self.num_pings = 0\n            await self.swarm_adapter.send_message(\"I'm reset!\", \"general\")\n\n\ndef main():\n    \"\"\"\n    On a mac, go to Macintosh HD > Applications > Python3.x folder (x being your python3 version) > double click on \"Install Certificates.command\" file\n    \"\"\"\n    load_dotenv()\n\n    intents_list = [\"message_content\", \"members\", \"guilds\"]\n    adapter = DiscordAdapter(\n        start_server=os.getenv(\"START_SERVER_NAME\"),\n        intents_list=intents_list,\n        token=os.getenv(\"PING_BOT_TOKEN\"),\n    )\n\n    agent = ExampleSwarmAgent(\n        name=\"Agent Smith\", description=\"I am a bot that pings\", swarm_adapter=adapter\n    )\n    agent.run()\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "examples/discord_swarm/pong_bot.py", "content": "import sys, os, time\nfrom dotenv import load_dotenv\n\n# adding the lates version of the osnap_client to the path\nfrom pathlib import Path\nfile_path = Path(__file__).absolute()\nsys.path.append(str(file_path.parent.parent.parent))\n\nfrom osnap_client.adapters import DiscordAdapter\nfrom osnap_client.agents import SwarmAgent\n\nclass ExampleSwarmAgent(SwarmAgent):\n    def __init__(self, name, description, swarm_adapter):\n        super().__init__(name, description, swarm_adapter)\n        self.num_pings = 0\n        self.max_pings = 5\n\n        @self.command(name=\"hello\")\n        async def hello(message):\n            await self.swarm_adapter.send_message(\"Hello!\", \"general\")\n\n        self.command_map[\"pong\"] = self.pong\n        self.command_map[\"reset\"] = self.reset\n\n    async def pong(self, message):\n        if self.num_pings >= self.max_pings:\n            await self.swarm_adapter.send_message(\"I'm done ponging!\", \"general\")\n            return\n\n        time.sleep(2)\n        self.num_pings += 1\n        await self.swarm_adapter.send_message(\"$ping\", \"general\")\n\n    async def reset(self, message):\n        self.num_pings = 0\n        await self.swarm_adapter.send_message(\"I'm reset!\", \"general\")\n\ndef main():\n    \"\"\"\n    On a mac, go to Macintosh HD > Applications > Python3.x folder (x being your python3 version) > double click on \"Install Certificates.command\" file\n    \"\"\"\n    load_dotenv()\n\n    intents_list = [\"message_content\", \"members\", \"guilds\"]\n    adapter = DiscordAdapter(\n        start_server=os.getenv(\"START_SERVER_NAME\"),\n        intents_list=intents_list,\n        token=os.getenv(\"PONG_BOT_TOKEN\"),\n    )\n\n    agent = ExampleSwarmAgent(\n        name=\"Agent Smith\", description=\"I am a bot that pongs\", swarm_adapter=adapter\n    )\n    agent.run()\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "osnap_client/managers/__init__.py", "content": "from .base import SwarmManagerBase, SwarmManager\n\n__all__ = [\n    \"SwarmManagerBase\",\n    \"SwarmManager\"\n]\n"}
{"type": "source_file", "path": "osnap_client/utils/ai_engines/LanchainGoogleEngine.py", "content": "import os\nimport openai\nimport tiktoken\n\nfrom osnap.utils.ai_engines.EngineBase import EngineBase\nfrom langchain.agents import load_tools\nfrom langchain.agents import initialize_agent\nfrom langchain.agents import AgentType\nfrom langchain.llms import OpenAI\n\nfrom langchain.utilities import GoogleSearchAPIWrapper\n\nclass LanchainGoogleEngine(EngineBase):\n    \"\"\"\n    gpt-4, gpt-4-0314, gpt-4-32k, gpt-4-32k-0314, gpt-3.5-turbo, gpt-3.5-turbo-0301\n    \"\"\"\n    SUPPORTED_MODELS = [\n        \"gpt-4\",\n        \"gpt-4-0314\",\n        \"gpt-4-32k\",\n        \"gpt-4-32k-0314\",\n        \"gpt-3.5-turbo\",\n        \"gpt-3.5-turbo-0301\"\n    ]\n\n    def __init__(self, model_name: str, temperature: float, max_response_tokens: int):\n\n        if model_name not in self.SUPPORTED_MODELS:\n            raise ValueError(f\"Model {model_name} is not supported. Supported models are: {self.SUPPORTED_MODELS}\")\n\n        super().__init__(\"openai\", model_name, temperature, max_response_tokens)\n        \n        if \"OPENAI_API_KEY\" not in os.environ:\n            raise ValueError(\"OPENAI_API_KEY environment variable is not set.\")\n        \n        openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n        self.tiktoken_encoding = tiktoken.encoding_for_model(model_name)\n\n        self.agent = self._init_chain()\n        self.search = GoogleSearchAPIWrapper()\n\n    def _init_chain(self):\n        \"\"\"Instantiates langchain chain with all the necessary tools\n        \"\"\"\n        llm = OpenAI(temperature=self.temperature)\n        tools = load_tools([\"google-search\", \"google-search-results-json\"], llm=llm)\n        agent = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=False, return_intermediate_steps=True)\n        return agent\n\n    def call_model(self, conversation: list) -> str:\n        \"\"\"Does the search itself but provides very short answers!\n        \"\"\"\n        if isinstance(conversation, list):\n            prompt = self._convert_conversation_to_str(conversation)\n        else:\n            prompt = conversation\n\n        response = self.agent(prompt)\n        final_response = \"\"\n        intermediate_steps = response[\"intermediate_steps\"]\n        for step in intermediate_steps:\n            final_response += step[0].log + \"\\n\" + step[1]\n        final_response += response[\"output\"]\n        return final_response\n    \n    def google_query(self, query: str) -> str:\n        \"\"\"Does the search itself but provides very short answers!\n        \"\"\"\n        response = self.search.run(query)\n        return response\n    \n    def search_sources(self, query: str, n=5):\n        \"\"\"Does the search itself but provides very short answers!\n        \"\"\"\n        response = self.search.results(query, n)\n        return response\n    \n    def _convert_conversation_to_str(self, conversation):\n        \"\"\"Converts conversation to a string\n        \"\"\"\n        prompt = \"\"\n        for message in conversation:\n            prompt += message[\"content\"] + \"\\n\"\n        return prompt\n    "}

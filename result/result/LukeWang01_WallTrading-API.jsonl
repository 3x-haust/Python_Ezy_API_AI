{"repo_info": {"repo_name": "WallTrading-API", "repo_owner": "LukeWang01", "repo_url": "https://github.com/LukeWang01/WallTrading-API"}}
{"type": "source_file", "path": "brokers/base_broker.py", "content": "\"\"\"\n# created: 12/20/2024, final version for open source only\n# Version 0.1.1\n# for more info, please visit: https://www.patreon.com/LookAtWallStreet\nDev. Team:\nLuke\nAngus\n\"\"\"\n\nfrom abc import ABC, abstractmethod\n\nfrom utils.logger_config import setup_logger\nfrom trading_settings import TRADING_LIST, TRADING_CONFIRMATION, TRADING_CASH_MARGIN_CONTROL, TRADING_CASH_THRESHOLD\nfrom utils.time_tool import is_market_hours, get_current_time\nfrom utils.wall_api_client import print_status\n\n\nclass BaseBroker(ABC):\n    def __init__(self):\n        self.broker_name = self.__class__.__name__\n\n        # setup logger, child classes should keep align with these codes\n        self.logger = setup_logger(self.__class__.__name__)\n        self.logger.info(f\"Initializing {self.broker_name}\")\n\n        # return codes setup, child classes should keep align with these codes\n        self.ret_ok_code = 1\n        self.ret_error_code = -1\n\n    @abstractmethod\n    def get_positions(self):\n        \"\"\"\n        Get the current positions\n        :return: status code, positions\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_positions_by_ticker(self, ticker: str):\n        \"\"\"\n        Get the current positions by ticker\n        :param ticker:\n        :return: status code, positions\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_cash_balance(self):\n        \"\"\"\n        Get the cash balance\n        :return: status code, cash balance\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_cash_balance_number_only(self) -> tuple[int, float]:\n        \"\"\"\n        Get the cash balance number only\n        :return: status code, cash balance\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_account_info(self):\n        \"\"\"\n        Get the account information\n        :return: status code, account information\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def market_sell(self, stock: str, quantity: int, price: float):\n        # ignore price for market orders if needed for the broker class implementation\n        \"\"\"\n        Market sell\n        :param stock:\n        :param quantity:\n        :param price:\n        :return: status code, order data\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def market_buy(self, stock: str, quantity: int, price: float):\n        # ignore price for market orders if needed for the broker class implementation\n        \"\"\"\n        Market buy\n        :param stock:\n        :param quantity:\n        :param price:\n        :return: status code, order data\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def limit_sell(self, stock: str, quantity: int, price: float):\n        \"\"\"\n        Limit sell\n        :param stock:\n        :param quantity:\n        :param price:\n        :return: status code, order data\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def limit_buy(self, stock: str, quantity: int, price: float):\n        \"\"\"\n        Limit buy\n        :param stock:\n        :param quantity:\n        :param price:\n        :return: status code, order data\n        \"\"\"\n        pass\n\n    def broker_make_trade(self, direction: str, called_by: str, stock: str, quantity: int, price: float):\n        if stock in TRADING_LIST and TRADING_CONFIRMATION:\n            # Bull, buy order\n            if direction == \"Bull\":\n                # check the current buying power first\n                ret_status_code, current_cash = self.get_cash_balance_number_only()\n                if ret_status_code != self.ret_ok_code:\n                    data = f\"{get_current_time()}: {stock}, Buy Failed. \\nFailed to get the current cash balance, skipped, by: {called_by}\"\n                    # print(data)\n                    print_status(\"BaseBroker\", data, \"ERROR\")\n                    self.logger.error(data)\n                    return\n\n                if current_cash >= TRADING_CASH_THRESHOLD and current_cash > quantity * price or not TRADING_CASH_MARGIN_CONTROL:\n                    if is_market_hours():\n                        # market order\n                        ret_status_code, order_data = self.market_buy(stock, quantity, price)\n                        if ret_status_code == self.ret_ok_code:\n                            data = f\"{get_current_time()}: Market Buy: {stock}, {quantity}, {price}, order placed successfully, please check account. by: {called_by}\"\n                            # print(data)\n                            print_status(\"BaseBroker\", data, \"INFO\")\n                            # print(order_data)\n                            self.logger.info(data)\n                            # self.logger.info(order_data)  # for privacy, not logging the order data, updated 01-13-2025\n                        else:\n                            data = f\"{get_current_time()}: Market Buy: {stock}, {quantity}, {price} Failed, please check broker side or app, by: {called_by}\"\n                            # print(data)\n                            # print(order_data)\n                            print_status(\"BaseBroker\", data, \"ERROR\")\n                            print_status(\"BaseBroker\", order_data, \"ERROR\")\n                            # self.logger.error(data)\n                            self.logger.error(order_data)   # only log error msg, updated 03-09-2025\n                    else:\n                        # limit order extended hours\n                        ret_status_code, order_data = self.limit_buy(stock, quantity, price)\n                        if ret_status_code == self.ret_ok_code:\n                            data = f\"{get_current_time()}: Limit Buy: {stock}, {quantity}, {price}, order placed successfully, please check account, by: {called_by}\"\n                            # print(data)\n                            # print(order_data)\n                            print_status(\"BaseBroker\", data, \"INFO\")\n                            # self.logger.info(data)\n                            # self.logger.info(order_data)  # for privacy, not logging the order data, updated 01-13-2025\n                        else:\n                            data = f\"{get_current_time()}: Limit Buy: {stock}, {quantity}, {price} Failed, please check broker side or app, by: {called_by}\"\n                            # print(data)\n                            # print(order_data)\n                            print_status(\"BaseBroker\", data, \"ERROR\")\n                            print_status(\"BaseBroker\", order_data, \"ERROR\")\n                            self.logger.error(data)\n                            self.logger.error(order_data)   # only log error msg, updated 03-09-2025\n                else:\n                    # order failed\n                    data = f\"{get_current_time()}: Buy: {stock}, {quantity}, {price} Failed: no enough cash, below the threshold, or wrong margin settings, {current_cash} - {TRADING_CASH_THRESHOLD} - {quantity * price} - {TRADING_CASH_MARGIN_CONTROL}, by: {called_by}\"\n                    # print(data)\n                    print_status(\"BaseBroker\", data, \"ERROR\")\n                    self.logger.error(data)\n\n            # Bear, sell order\n            if direction == \"Bear\":\n                ok_to_sell = True\n                ret_status_code, position_by_ticker = self.get_positions_by_ticker(stock)\n                if ret_status_code != self.ret_ok_code:\n                    data = f\"{get_current_time()}: Sell: {stock}, {quantity}, {price} failed, Failed to get the current position, skipped, by: {called_by}\"\n                    # print(data)\n                    print_status(\"BaseBroker\", data, \"ERROR\")\n                    self.logger.error(data)\n                    return\n\n                if quantity >= position_by_ticker - 2:\n                    # set the sell quantity at least less than the current position - 1\n                    data = f\"{get_current_time()}: Sell: {stock}, {quantity}, {price} failed, no enough position to sell, skipped, {quantity} - {position_by_ticker}, by: {called_by}\"\n                    # print(data)\n                    print_status(\"BaseBroker\", data, \"WARNING\")\n                    self.logger.warning(data)\n                    ok_to_sell = False\n\n                if ok_to_sell:\n                    if is_market_hours():\n                        # market order\n                        ret_status_code, order_data = self.market_sell(stock, quantity, price)\n                        if ret_status_code == self.ret_ok_code:\n                            data = f\"{get_current_time()}: Market Sell: {stock}, {quantity}, {price}, order placed successfully, please check account., by: {called_by}\"\n                            # print(data)\n                            print_status(\"BaseBroker\", data, \"INFO\")\n                            # print(order_data)\n                            # self.logger.info(data)\n                            # self.logger.info(order_data)  # for privacy, not logging the order data, updated 01-13-2025\n                        else:\n                            # order failed\n                            data = f\"{get_current_time()}: Market Sell: {stock}, {quantity}, {price}, order failed, please check broker side or app, by: {called_by}\"\n                            # print(data)\n                            print_status(\"BaseBroker\", data, \"ERROR\")\n                            self.logger.warning(data)   # only log warning msg, updated 03-09-2025\n                    else:\n                        # limit order extended hours\n                        ret_status_code, order_data = self.limit_sell(stock, quantity, price)\n                        if ret_status_code == self.ret_ok_code:\n                            data = f\"{get_current_time()}: Limit Sell: {stock}, {quantity}, {price}, order placed successfully, please check account., by: {called_by}\"\n                            # print(data)\n                            print_status(\"BaseBroker\", data, \"INFO\")\n                            # print(order_data)\n                            # self.logger.info(data)\n                            # self.logger.info(order_data)  # for privacy, not logging the order data, updated 01-13-2025\n                        else:\n                            # order failed\n                            data = f\"{get_current_time()}: Limit Sell: {stock}, {quantity}, {price}, order failed, please check broker side or app, by: {called_by}\"\n                            # print(data)\n                            # print(order_data)\n                            print_status(\"BaseBroker\", data, \"ERROR\")\n                            print_status(\"BaseBroker\", order_data, \"ERROR\")\n                            self.logger.warning(data)\n                            self.logger.warning(order_data)  # only log warning msg, updated 03-09-2025\n\n        # if stock not in the trading list, skip the order\n        else:\n            data = f\"{get_current_time()}: Stock({stock}) is not in the trading list:{TRADING_LIST}, or the trading is disable:{TRADING_CONFIRMATION}, skip the order, by: {called_by}\"\n            # print(data)\n            print_status(\"BaseBroker\", data, \"WARNING\")\n            self.logger.warning(data)\n"}
{"type": "source_file", "path": "brokers/broker_factory.py", "content": "from typing import Dict\n\nfrom brokers.base_broker import BaseBroker\nfrom brokers.ibkr_broker import IBKRBroker\nfrom brokers.long_port_broket import LongPortBroker\nfrom brokers.moomoo_futu_broker import MooMooFutuBroker\nfrom brokers.schwab_broker import SchwabBroker\nfrom brokers.webull_broker import WebullBroker\nfrom brokers.tiger_broker import TigerBroker\n\n\nclass BrokerFactory:\n    _brokers: Dict[str, BaseBroker] = {}\n\n    @classmethod\n    def get_broker(cls, broker_name: str) -> BaseBroker:\n        if broker_name not in cls._brokers:\n            broker = cls._create_broker(broker_name)\n            cls._brokers[broker_name] = broker\n        return cls._brokers[broker_name]\n\n    @classmethod\n    def _create_broker(cls, broker_name: str) -> BaseBroker:\n        broker_map = {\n            'IBKR': IBKRBroker,\n            'WEBULL': WebullBroker,\n            'MooMoo': MooMooFutuBroker,\n            'Futu': MooMooFutuBroker,\n            'SCHWAB': SchwabBroker,\n            'TIGER': TigerBroker,\n            'LONGPORT': LongPortBroker\n        }\n\n        if broker_name not in broker_map:\n            raise ValueError(f\"Unsupported broker: {broker_name}\")\n\n        return broker_map[broker_name]()\n"}
{"type": "source_file", "path": "brokers/long_port_broket.py", "content": "\"\"\"\n# created: 03/05/2025, final version for open source only\n# Version 0.1.7\n# for more info, please visit: https://www.patreon.com/LookAtWallStreet\nDev. Team:\nLuke\nAngus\n\n\nlong_port_broker.py\nhttps://github.com/longportapp/openapi-sdk/tree/main-v2\n\"\"\"\nfrom brokers.base_broker import BaseBroker\nfrom decimal import Decimal\nfrom longport.openapi import TradeContext, Config, OrderType, OrderSide, TimeInForceType, OutsideRTH\n\nfrom env._secrete import LongPort_app_key, LongPort_app_secret, LongPort_access_token\nfrom utils.wall_api_client import print_status\n\nimport nest_asyncio\n\nnest_asyncio.apply()\n\n\nclass LongPortBroker(BaseBroker):\n\n    def __init__(self):\n        super().__init__()\n        self.config = Config(app_key=LongPort_app_key,\n                             app_secret=LongPort_app_secret,\n                             access_token=LongPort_access_token)\n        self.ctx = None\n\n        self.currency = \"USD\"\n        # self.is_connected = False\n\n    def connect(self):\n        try:\n            self.ctx = TradeContext(self.config)\n            if self.ctx:\n                self.logger.info(\"Connected to LongPort\")\n                print_status(\"LongPort Trader\", \"Connected to LongPort\", \"INFO\")\n                return True\n            else:\n                self.logger.error(\"Failed to connect to LongPort\")\n                print_status(\"LongPort Trader\", \"Connect to LongPort failed, ctx empty, error\", \"ERROR\")\n                return False\n        except Exception as e:\n            self.logger.error(f\"Failed to connect to LongPort: {e}\")\n            print_status(\"LongPort Trader\", f\"Connect to LongPort failed, {e}\", \"ERROR\")\n            return False\n\n    def disconnect(self):\n        self.ctx = None\n\n    def get_cash_balance(self):\n        if self.connect():\n            resp = self.ctx.account_balance()\n            if resp and resp.get(\"code\", -1) == 0:\n                cash_list = resp.get(\"data\", {}).get(\"list\", [])\n                if cash_list:\n                    for cash_info in cash_list[0].get(\"cash_infos\", []):\n                        if cash_info.get(\"currency\") == self.currency:\n                            available_cash = cash_info.get(\"available_cash\")\n                            # other cash info, for future use\n                            # withdraw_cash = cash_info.get(\"withdraw_cash\")\n                            # frozen_cash = cash_info.get(\"frozen_cash\")\n                            # settling_cash = cash_info.get(\"settling_cash\")\n                            self.disconnect()\n                            return self.ret_ok_code, available_cash\n                    msg = f\"Failed to get cash balance, NO USD FOUND: {resp}\"\n                    self.logger.error(msg)\n                    print_status(\"LongPort Trader\", msg, \"ERROR\")\n                    self.disconnect()\n                    return self.ret_error_code, 0.0\n                meg = f\"Failed to get cash balance, cash list is empty: {resp}\"\n                self.logger.error(meg)\n                print_status(\"LongPort Trader\", meg, \"ERROR\")\n                self.disconnect()\n                return self.ret_error_code, 0.0\n            else:\n                msg = f\"Failed to get cash balance: {resp}\"\n                self.logger.error(msg)\n                print_status(\"LongPort Trader\", msg, \"ERROR\")\n                self.disconnect()\n                return self.ret_error_code, 0.0\n\n    def get_cash_balance_number_only(self):\n        return self.get_cash_balance()\n\n    def get_account_info(self):\n        if self.connect():\n            resp = self.ctx.account_balance()\n            if resp and resp.get(\"code\") == 0:\n                self.disconnect()\n                return self.ret_ok_code, resp[\"data\"]\n            else:\n                msg = f\"Failed to get account info: {resp}\"\n                self.logger.error(msg)\n                print_status(\"LongPort Trader\", msg, \"ERROR\")\n                self.disconnect()\n                return self.ret_error_code, None\n\n    def get_positions(self):\n        if self.connect():\n            resp = self.ctx.stock_positions()\n            if resp and resp.get(\"code\") == 0:\n                stock_list = resp.get(\"data\", {}).get(\"list\", [])\n                stock_info_list = stock_list[0].get(\"stock_info\", [])\n                self.disconnect()\n                return self.ret_ok_code, stock_info_list\n            else:\n                msg = f\"Failed to get positions: {resp}\"\n                self.logger.error(msg)\n                print_status(\"LongPort Trader\", msg, \"ERROR\")\n                self.disconnect()\n                return self.ret_error_code, msg\n\n    def get_positions_by_ticker(self, ticker: str):\n        if self.connect():\n            resp = self.ctx.stock_positions()\n            if resp and resp.get(\"code\") == 0:\n                stock_list = resp.get(\"data\", {}).get(\"list\", [])\n                stock_info_list = stock_list[0].get(\"stock_info\", [])\n                if not stock_list:\n                    msg = f\"Failed to get positions by ticker, stock list is empty: {resp}\"\n                    self.logger.error(msg)\n                    print_status(\"LongPort Trader\", msg, \"ERROR\")\n                    self.disconnect()\n                    return self.ret_ok_code, 0.0\n\n                for stock in stock_info_list:\n                    if stock.get(\"symbol\") == ticker:\n                        self.disconnect()\n                        return self.ret_ok_code, stock.get(\"quantity\")\n\n                msg = f\"Failed to get positions by ticker, ticker not found: {resp}\"\n                self.logger.error(msg)\n                print_status(\"LongPort Trader\", msg, \"WARNING\")\n                self.disconnect()\n                return self.ret_ok_code, 0.0\n            else:\n                msg = f\"Failed to get positions by ticker: {resp}\"\n                self.logger.error(msg)\n                print_status(\"LongPort Trader\", msg, \"ERROR\")\n                self.disconnect()\n                return self.ret_error_code, msg\n\n    def market_sell(self, stock: str, quantity: int, price: float):\n        if self.connect():\n            stock_symbol = f'{stock.upper()}.US'\n            resp = self.ctx.submit_order(stock_symbol,\n                                         OrderType.MO,\n                                         OrderSide.Sell,\n                                         Decimal(quantity),\n                                         TimeInForceType.Day,\n                                         )\n\n            if resp and resp.get(\"code\") == 0:\n                if resp[\"message\"] == \"success\":\n                    self.disconnect()\n                    return self.ret_ok_code, resp[\"data\"]\n                else:\n                    msg = f\"Failed to market sell: {resp}\"\n                    self.logger.error(msg)\n                    print_status(\"LongPort Trader\", msg, \"ERROR\")\n                    self.disconnect()\n                    return self.ret_error_code, msg\n            else:\n                msg = f\"Failed to market sell: {resp}\"\n                self.logger.error(msg)\n                print_status(\"LongPort Trader\", msg, \"ERROR\")\n                self.disconnect()\n                return self.ret_error_code, msg\n\n    def market_buy(self, stock: str, quantity: int, price: float):\n        if self.connect():\n            stock_symbol = f'{stock.upper()}.US'\n            resp = self.ctx.submit_order(stock_symbol,\n                                         OrderType.MO,\n                                         OrderSide.Buy,\n                                         Decimal(quantity),\n                                         TimeInForceType.Day,\n                                         )\n\n            if resp and resp.get(\"code\") == 0:\n                if resp[\"message\"] == \"success\":\n                    self.disconnect()\n                    return self.ret_ok_code, resp[\"data\"]\n                else:\n                    msg = f\"Failed to market buy: {resp}\"\n                    self.logger.error(msg)\n                    print_status(\"LongPort Trader\", msg, \"ERROR\")\n                    self.disconnect()\n                    return self.ret_error_code, msg\n            else:\n                msg = f\"Failed to market buy: {resp}\"\n                self.logger.error(msg)\n                print_status(\"LongPort Trader\", msg, \"ERROR\")\n                self.disconnect()\n                return self.ret_error_code, msg\n\n    def limit_sell(self, stock: str, quantity: int, price: float):\n        if self.connect():\n            stock_symbol = f'{stock.upper()}.US'\n            resp = self.ctx.submit_order(stock_symbol,\n                                         OrderType.LO,\n                                         OrderSide.Sell,\n                                         Decimal(quantity),\n                                         TimeInForceType.GoodTilCanceled,\n                                         submitted_price=Decimal(price),\n                                         outside_rth=OutsideRTH.AnyTime\n                                         )\n\n            if resp and resp.get(\"code\") == 0:\n                if resp[\"message\"] == \"success\":\n                    self.disconnect()\n                    return self.ret_ok_code, resp[\"data\"]\n                else:\n                    msg = f\"Failed to limit sell: {resp}\"\n                    self.logger.error(msg)\n                    print_status(\"LongPort Trader\", msg, \"ERROR\")\n                    self.disconnect()\n                    return self.ret_error_code, msg\n            else:\n                msg = f\"Failed to limit sell: {resp}\"\n                self.logger.error(msg)\n                print_status(\"LongPort Trader\", msg, \"ERROR\")\n                self.disconnect()\n                return self.ret_error_code, msg\n\n    def limit_buy(self, stock: str, quantity: int, price: float):\n        if self.connect():\n            stock_symbol = f'{stock.upper()}.US'\n            resp = self.ctx.submit_order(stock_symbol,\n                                         OrderType.LO,\n                                         OrderSide.Buy,\n                                         Decimal(quantity),\n                                         TimeInForceType.GoodTilCanceled,\n                                         submitted_price=Decimal(price),\n                                         outside_rth=OutsideRTH.AnyTime\n                                         )\n\n            if resp and resp.get(\"code\") == 0:\n                if resp[\"message\"] == \"success\":\n                    self.disconnect()\n                    return self.ret_ok_code, resp[\"data\"]\n                else:\n                    msg = f\"Failed to limit buy: {resp}\"\n                    self.logger.error(msg)\n                    print_status(\"LongPort Trader\", msg, \"ERROR\")\n                    self.disconnect()\n                    return self.ret_error_code, msg\n            else:\n                msg = f\"Failed to limit buy: {resp}\"\n                self.logger.error(msg)\n                print_status(\"LongPort Trader\", msg, \"ERROR\")\n                self.disconnect()\n                return self.ret_error_code, msg\n\n"}
{"type": "source_file", "path": "brokers/webull_broker.py", "content": "\"\"\"\n# created: 12/20/2024, final version for open source only\n# Version 0.1.1\n# for more info, please visit: https://www.patreon.com/LookAtWallStreet\nDev. Team:\nLuke\nAngus\n\"\"\"\n\nimport requests\nfrom webull import webull\n\nfrom brokers.base_broker import BaseBroker\nfrom env._secrete import Webull_username, Webull_password, Webull_device_name, Webull_PID, Webull_did_from_web, \\\n    Webull_access_token, Webull_uuid, Webull_account_id, Webull_account_type\nfrom utils.time_tool import get_current_time\nfrom utils.wall_api_client import print_status\n\n\"\"\" ⬇️ Broker Setup ⬇️ \"\"\"\n# refill the setup like MooMooFutuBroker Class\n\n# FILL_OUTSIDE_MARKET_HOURS = TRADING_ALLOW_PRE_POST_MARKET_ORDER  # enable if order fills on extended hours\n\n\"\"\" ⏫ Broker Setup ⏫ \"\"\"\n\n\nclass WebullBroker(BaseBroker):\n\n    def __init__(self):\n        super().__init__()\n        # init webull api\n        self._webull = webull()\n        # Log in authentication:\n        self.username = Webull_username\n        self.password = Webull_password\n        self.device_name = Webull_device_name\n\n        # Trading token authentication:\n        self.PID = Webull_PID\n        self.PID_timeout = 15  # should be int\n\n        # Authentication additional:\n        self.did = Webull_did_from_web\n        self.access_token = Webull_access_token\n        self.uuid = Webull_uuid\n        self.account_id = Webull_account_id\n        self.account_type = Webull_account_type\n\n        # Trader current trading status:\n        self.order_placed = 0\n        self.order_filled = 0\n        self.order_pending = 0\n        self.openPL_pct = 0\n        self.openPL = 0\n        self.dayPL_pct = 0\n        self.dayPL = 0\n        self.market_value = 0\n        self.cash_balance = 0\n        self.net_account_value = 0\n        self.my_positions = ''\n        self.dayBuyingPower = 0\n        self.overnightBuyingPower = 0\n        self.cryptoBuyingPower = 0\n        self.optionBuyingPower = 0\n        self.open_orders = ''\n\n        # Historical trading status:\n        self.filled_orders_history = ''\n        self.cancelled_orders_history = ''\n        self.pending_orders_history = ''\n\n        self.has_trader_info = False\n\n    def market_sell(self, stock: str, quantity: int, price: float):\n        if not self.is_trader_logged_in():\n            self.log_in()\n\n        self.enable_trading()\n        # Sell, market order, sell 1 price, daily:\n        response = self._webull.place_order(stock=stock, action='SELL', enforce='DAY', orderType='MKT', quant=quantity)\n        # price = self.get_bid_price(stock)\n        # order_details = self.print_order_details(response, stock, price, quantity, 'SELL', 'MKT')\n        if response['success']:\n            print_status(\"Webull Trader\", \"Market Sell success\", \"SUCCESS\")\n            self.logger.info('Trader: Market Sell success!')\n            return self.ret_ok_code, response['data']\n        else:\n            data = response['msg']\n            print_status(\"Webull Trader\", f\"Market Sell failed {data}\", \"ERROR\")\n            self.logger.warning(f'Trader: Market Buy failed: {data}')\n            return self.ret_error_code, data\n\n    def market_buy(self, stock: str, quantity: int, price: float):\n        if not self.is_trader_logged_in():\n            self.log_in()\n\n        self.enable_trading()\n        # Buy, market order, buy 1 price, daily:\n        response = self._webull.place_order(stock=stock, action='BUY', enforce='DAY', orderType='MKT', quant=quantity)\n        # price = self.get_ask_price(stock)\n        # order_details = self.print_order_details(response, stock, price, quantity, 'BUY', 'MKT')\n        if response['success']:\n            print_status(\"Webull Trader\", \"Market Buy success\", \"SUCCESS\")\n            self.logger.info('Trader: Market Buy success!')\n            return self.ret_ok_code, response['data']\n        else:\n            data = response['msg']\n            print_status(\"Webull Trader\", f\"Market Buy failed {data}\", \"ERROR\")\n            self.logger.warning(f'Trader: Market Buy failed: {data}')\n            return self.ret_error_code, data\n\n    def limit_sell(self, stock: str, quantity: int, price: float):\n        if not self.is_trader_logged_in():\n            self.log_in()\n\n        self.enable_trading()\n        # Sell, limit price order, ask price, sell 1 price, daily:\n        response = self._webull.place_order(stock=stock, action='SELL', price=price, enforce='DAY', orderType='LMT',\n                                            quant=quantity)\n        # outsideRegularTradingHour default is True\n        # order_details = self.print_order_details(response, stock, price, quantity, 'SELL', 'DAY')\n        if response['success']:\n            print_status(\"Webull Trader\", \"Limit Sell success\", \"SUCCESS\")\n            self.logger.info('Trader: Limit Sell success!')\n            return self.ret_ok_code, response['data']\n        else:\n            data = response['msg']\n            print_status(\"Webull Trader\", f\"Limit Sell failed{data}\", \"ERROR\")\n            self.logger.warning(f'Trader: Market Buy failed: {data}')\n            return self.ret_error_code, data\n\n    def limit_buy(self, stock: str, quantity: int, price: float):\n        if not self.is_trader_logged_in():\n            self.log_in()\n\n        self.enable_trading()\n        # Buy, limit price order, bid price, buy 1 price, daily:\n        response = self._webull.place_order(stock=stock, action='BUY', price=price, enforce='DAY', orderType='LMT',\n                                            quant=quantity)\n        # order_details = self.print_order_details(response, stock, price, quantity, 'BUY', 'DAY')\n        if response['success']:\n            print_status(\"Webull Trader\", \"Limit Buy success\", \"SUCCESS\")\n            self.logger.info('Trader: Limit Buy success!')\n            return self.ret_ok_code, response['data']\n        else:\n            data = response['msg']\n            print_status(\"Webull Trader\", f\"Limit Buy failed {data}\", \"ERROR\")\n            self.logger.warning(f'Trader: Market Buy failed: {data}')\n            return self.ret_error_code, data\n\n    def get_account_info(self):\n        account_info = self._webull.get_account()\n        if account_info['secAccountId']:\n            self.account_id = account_info['secAccountId']\n            self.order_placed = '-'\n            self.order_filled = '-'\n            self.order_pending = account_info['openOrderSize']\n            self.openPL_pct = str(round(float(account_info['unrealizedProfitLossRate']) * 100, 2)) + ' %'\n            self.openPL = account_info['unrealizedProfitLoss']\n            self.dayPL_pct = '-'\n            self.dayPL = '-'\n            self.market_value = account_info['accountMembers'][0]['value']\n            self.cash_balance = account_info['accountMembers'][1]['value']\n            self.dayBuyingPower = account_info['accountMembers'][2]['value']\n            self.overnightBuyingPower = account_info['accountMembers'][3]['value']\n            self.cryptoBuyingPower = account_info['accountMembers'][4]['value']\n            self.optionBuyingPower = account_info['accountMembers'][5]['value']\n            self.net_account_value = account_info['netLiquidation']\n            return self.ret_ok_code, account_info\n        else:\n            print_status(\"Webull Trader\", \"Get Account Info failed\", \"ERROR\")\n            self.logger.warning(f'Trader: Get Account Info failed: {account_info}')\n            return self.ret_error_code, account_info\n\n    def get_positions(self):\n        account_info = self._webull.get_account()\n        if account_info['positions']:\n            positions = account_info['positions']\n            return self.ret_ok_code, positions\n        else:\n            print_status(\"Webull Trader\", \"Get Positions failed\", \"ERROR\")\n            self.logger.warning(f'Trader: Get Positions failed: {account_info}')\n            return self.ret_error_code, account_info\n\n    def get_positions_by_ticker(self, ticker: str):\n        account_info = self._webull.get_account()\n        if account_info['positions']:\n            positions = account_info['positions']\n            # ticker = position['ticker']['symbol']\n            # qty = position['position']\n            # marketValue = position['marketValue']\n            # lastPrice = position['lastPrice']\n            # costPrice = position['costPrice']\n            # unrealizedProfitLoss = position['unrealizedProfitLoss']\n            # unrealizedProfitLossRate = round(float(position['unrealizedProfitLossRate']) * 100, 2)\n            for position in positions:\n                if position['ticker']['symbol'].lower() == ticker.lower():\n                    qty = position['position']\n                    return self.ret_ok_code, qty\n        else:\n            print_status(\"Webull Trader\", \"Get Positions failed\", \"ERROR\")\n            self.logger.warning(f'Trader: Get Positions failed: {account_info}')\n            return self.ret_error_code, account_info\n\n    def get_cash_balance(self):\n        account_info = self._webull.get_account()\n        if account_info['accountMembers']:\n            self.cash_balance = float(account_info['accountMembers'][1]['value'])\n            return self.ret_ok_code, account_info\n        else:\n            print_status(\"Webull Trader\", \"Get Cash Balance failed\", \"ERROR\")\n            self.logger.warning(f'Trader: Get Cash Balance failed: {account_info}')\n            return self.ret_error_code, account_info\n\n    def get_cash_balance_number_only(self):\n        account_info = self._webull.get_account()\n        if account_info['accountMembers']:\n            self.cash_balance = float(account_info['accountMembers'][1]['value'])\n            return self.ret_ok_code, self.cash_balance\n        else:\n            print_status(\"Webull Trader\", \"Get Cash Balance failed\", \"ERROR\")\n            self.logger.warning(f'Trader: Get Cash Balance failed: {account_info}')\n            return self.ret_error_code, account_info\n\n    # def set_PID_expiry(self, expiry):\n    #     self._webull.timeout = expiry\n    #\n    # def set_trader_info(self, username, password, pid):\n    #     self.username = username\n    #     self.password = password\n    #     self.PID = pid\n    #     print(f\"Webull: Trader info set\")\n    #\n    # def set_user_name(self, email):\n    #     self.username = email\n    #\n    # def set_device_name(self, device_name):\n    #     self.device_name = device_name\n    #\n    # def set_auth_did(self, did):\n    #     self._webull._set_did(did)\n    #     self.did = did\n    #\n    # def set_auth_access_token(self, access_token):\n    #     self.access_token = access_token\n    #     self._webull._access_token = access_token\n    #\n    # def set_auth_uuid(self, uuid):\n    #     self._webull.uuid = uuid\n    #     self.uuid = uuid\n\n    def get_account_id(self):\n        return self.account_id\n\n    def is_trader_logged_in(self):\n        return self._webull.is_logged_in()\n\n    def set_time_out(self, timeout):\n        self._webull.timeout = int(timeout)\n\n    def login_preparation(self):\n        return self.uuid != '' and self.did != '' and self.access_token != ''\n\n    def log_in(self):\n        try:\n            self._webull._access_token = self.access_token\n            login_result = self._webull.login(self.username, self.password, device_name=self.device_name,\n                                              save_token=True)\n            response = self._webull.is_logged_in()\n            if response:\n                self.account_id = self._webull.get_account_id()\n                self.account_type = self._webull.get_account_type(self.username)\n                # print('-----------------------------------')\n                # print('>>>>>>   Log in successful   <<<<<<')\n                # print(f'>>>   Your login ID: {self.account_id}   <<<')\n                # print('Log in successful')\n                print_status(\"Webull Trader\", \"Log in successful\", \"SUCCESS\")\n                return True\n            else:\n                # print('-----------------------------------')\n                # print('>>> Log in failed, authentication failed, check info below: ')\n                # print(login_result)\n                # print(f'Log in failed, authentication failed, check info below: {login_result}')\n                print_status(\"Webull Trader\", \"Log in failed, authentication failed\", \"ERROR\")\n                return False\n        except ValueError:\n            # print('>>>>>>    Log in failed, please check username or password')\n            # print('Log in failed, please check username or password')\n            print_status(\"Webull Trader\", \"Log in failed, please check username or password\", \"ERROR\")\n            return False\n\n    def log_out(self):\n        response = self._webull.logout()\n        print('Logout requested')\n        print(response)\n\n    def enable_trading(self):\n        response = self._webull.get_trade_token(self.PID)\n        # print('-----------------------------------')\n        # print('>>> Enable trading requested <<<')\n        if response:\n            # print('Trading enabled, authentication passed')\n            print('Trading enabled, authentication passed')\n            return True\n        else:\n            if self._webull.is_logged_in():\n                # print('Authentication failed, check PID again')\n                print('Authentication failed, check PID again')\n                return False\n            else:\n                # print('Authentication failed, please log in again')\n                print('Authentication failed, please login again')\n                return False\n\n    def get_stock_quote(self, stock):\n        res = {}\n        try:\n            quote_response = self._webull.get_quote(stock)\n            ask_price_1 = quote_response['askList'][0]['price']\n            bid_price_1 = quote_response['bidList'][0]['price']\n            res['bid_price'] = bid_price_1\n            res['ask_price'] = ask_price_1\n            # print('-----------------------------------')\n            # print('>>> Stock ticker: ', stock)\n            # print('>>> First bid price/ buy one price:  ', bid_price_1)\n            # print('>>> First ask price/ sell one price:  ', ask_price_1)\n            return res\n        except (ValueError or KeyError):\n            # print('>>> Please pass a valid stock ticker <<<')\n            print('Please pass a valid stock ticker')\n            return False\n\n    def get_bid_price(self, stock):\n        # get first bid price\n        res = self.get_stock_quote(stock)\n        if res:\n            # print('-----------------------------------')\n            # print('>>> Stock: ', stock, 'First bid price/ buy one price:', res['bid_price'])\n            return res['bid_price']\n        else:\n            print('Please pass a valid stock ticker')\n            return False\n\n    def get_ask_price(self, stock):\n        # get first ask price\n        res = self.get_stock_quote(stock)\n        if res:\n            # print('-----------------------------------')\n            # print('>>> Stock: ', stock, 'First ask price/ sell one price: ', res['ask_price'])\n            return res['ask_price']\n        else:\n            print('Please pass a valid stock ticker')\n            return False\n\n    def order_limit_buy_gtc(self, stock, price, quantity=1):\n        self.enable_trading()\n        # Buy, limit price order, ask price, buy 1 price, GTC order:\n        response = self._webull.place_order(stock=stock, action='BUY', price=price, enforce='GTC', orderType='LMT',\n                                            quant=quantity)\n        order_details = self.print_order_details(response, stock, price, quantity, 'BUY', 'GTC')\n        return order_details\n\n    def order_limit_sell_gtc(self, stock, price, quantity=1):\n        self.enable_trading()\n        # Sell, limit price order, bid price, sell 1 price, GTC order:\n        response = self._webull.place_order(stock=stock, action='SELL', price=price, enforce='GTC', orderType='LMT',\n                                            quant=quantity)\n        order_details = self.print_order_details(response, stock, price, quantity, 'SELL', 'GTC')\n        return order_details\n\n    def print_order_details(self, response, stock, price, qty, direction, order_type):\n        if response['success']:\n            res = {'result': 'success',\n                   'status': '>>>>>> Order placed successfully! <<<<<<',\n                   'account_id': self.account_id,\n                   'order_id': response['data']['orderId'],\n                   'order_time': get_current_time(),\n                   'stock_info': stock,\n                   'order_direction': direction,\n                   'order_type': order_type,\n                   'order_price': price,\n                   'order_qty': qty,\n                   'order_cost': round(float(price) * int(qty), 3)\n                   }\n            return res\n        else:\n            res = {\n                'result': 'failed',\n                'status': '>>>>>> Order placed Failed! <<<<<<',\n                'msg': response['msg'],\n            }\n            return res\n\n    def get_history_orders_v2(self, status='All', count=20):\n        # rewrite the get_history_orders function in the webull library\n        headers = self._webull.build_req_headers(include_trade_token=True, include_time=True)\n        base_ustradebroker_url = 'https://ustrade.webullbroker.com/api'\n        response = requests.get(f'{base_ustradebroker_url}/trade/v2/option/list?secAccountId={self._webull._account_id}'\n                                f'&dateType=ORDER&pageSize={count}&status=' + str(status), headers=headers,\n                                timeout=self._webull.timeout)\n        return response.json()\n\n    def get_filled_orders_history(self, status='Filled', count=200):\n        # get filled orders\n        res = self.get_history_orders_v2(status, count)\n        return res\n\n    def get_cancelled_orders_history(self, status='Cancelled', count=200):\n        # get cancelled orders\n        res = self.get_history_orders_v2(status, count)\n        return res\n\n    def get_pending_orders_history(self, status='Working', count=200):\n        # get pending orders\n        res = self.get_history_orders_v2(status, count)\n        return res\n"}
{"type": "source_file", "path": "run_client.py", "content": "import asyncio\nimport signal\nimport sys\n\nfrom brokers.broker_factory import BrokerFactory\nfrom env._secrete import SERVER_IP, API_CLIENT_ID, API_PASSWORD\nfrom trading_settings import TRADING_BROKER, TRADING_CONFIRMATION\nfrom utils.local_decision import decision_qty\nfrom utils.wall_api_client import DataClient, print_status\nfrom utils.logger_config import setup_logger\n\n\n\"\"\"Section 0: Client initialization\"\"\"\n# Setup logger for the client runner\nlogger = setup_logger('client_runner')\n\n# Global variable to track the client instance\nclient = None\nshutdown_event = asyncio.Event()\n\n# Initialize the client trader\nclient_trader = BrokerFactory.get_broker(TRADING_BROKER)\nprint_status(\"Client Runner\", \"Client Trader Initialized\", \"INFO\")\n\n\n\"\"\"Section 1: Message Handler Code\"\"\"\n\n\ndef trader_broker_setup_check() -> bool:\n    try:\n        # change the get cash to get account info, detailed information to check if the broker is set up correctly\n        # updated 01-07-2025\n        ret_code, data = client_trader.get_account_info()\n        if ret_code == client_trader.ret_ok_code:\n            # print_status(\"Client Runner\", f\"Broker setup successful - {data}\", \"SUCCESS\")\n            # For privacy, do not print the account information\n            print_status(\"Client Runner\", f\"Broker setup successful\", \"SUCCESS\")\n            return True\n        else:\n            print_status(\"Client Runner\", \"Broker setup failed, please check password or connection\", \"ERROR\")\n            return False\n    except Exception as error:\n        print_status(\"Client Runner\", f\"Broker setup failed, External Error: {error}\", \"ERROR\")\n        return False\n\n\ndef check_if_test_data(json_data) -> bool:\n    for k, v in json_data.items():\n        if \"test\" in str(k):\n            return True\n        if \"test\" in str(v):\n            return True\n    return False\n\n\ndef handle_data(json_data):\n    \"\"\"Handle incoming data\"\"\"\n    logger.debug(f\"Received data: {json_data}\")\n    print_status(\"Data Handler\",\n                 f\"Received data: {json_data}, type: {type(json_data)}\",\n                 \"INFO\")\n    print_status(\"Data Handler\", \"Starting to process data\", \"INFO\")\n\n    \"\"\"\n    json_data = {\n            \"time\": time_now,\n            \"ticker\": stock,\n            \"price\": price,\n            \"level\": level,\n            \"direction\": direction, # Bull or Bear\n            \"depth\": depth,\n            \"codeNum\": codeNum,\n            \"qty\": qty, (Optional)\n        }\n    \"\"\"\n    if check_if_test_data(json_data):\n        # test data received, no trade made\n        print_status(\"Data Handler\", \"Test data received, no trade made\", \"INFO\")\n    else:\n        # 1. WallTrading Bot Mode: trading data received, make trade\n        qty_num, qty_pct = decision_qty(json_data)\n        print_status(\"Data Handler\", f\"Decision qty: {qty_num}, Decision original qty percent: {int(qty_pct * 100)} %\", \"INFO\")\n        called_by = \"run_client.py - handle_data\"\n        if qty_num > 0:\n            if TRADING_CONFIRMATION:\n                try:\n                    print_status(\"Data Handler\", \"Making trade...\", \"INFO\")\n                    client_trader.broker_make_trade(json_data[\"direction\"], called_by, json_data[\"ticker\"], qty_num,\n                                                    json_data[\"price\"])\n                except Exception as error:\n                    print_status(\"Data Handler\", f\"Error making trade: {error}\", \"ERROR\")\n            else:\n                print_status(\"Data Handler\", \"No trade made, trading not confirmed per trading settings\", \"INFO\")\n        else:\n            print_status(\"Data Handler\", \"No trade made, qty decision is 0, please check trading settings\", \"WARNING\")\n\n\n\"\"\"Section 2: Client Runner Code\"\"\"\n\n\ndef signal_handler(signum, frame):\n    \"\"\"Handle shutdown signals\"\"\"\n    logger.info(\"Shutdown signal received\")\n    print_status(\"Client Runner\", \"Shutdown signal received\", \"WARNING\")\n    if client:\n        client.running = False\n    if not shutdown_event.is_set():\n        shutdown_event.set()\n\n\nasync def main():\n    global client\n\n    logger.info(\"Starting client process\")\n    # print_status(\"Client Runner\", \"Starting client process\", \"INFO\")\n\n    # Initialize client\n    client = DataClient(\n        server_url=f\"http://{SERVER_IP}:8000\",\n        client_id=API_CLIENT_ID,\n        password=API_PASSWORD\n    )\n\n    # Setup signal handlers in a cross-platform way\n    if sys.platform != 'win32':\n        logger.debug(\"Setting up Unix-style signal handlers\")\n        loop = asyncio.get_running_loop()\n        for sig in (signal.SIGINT, signal.SIGTERM):\n            loop.add_signal_handler(sig, lambda: signal_handler(sig, None))\n    else:\n        logger.debug(\"Setting up Windows-style signal handlers\")\n        for sig in (signal.SIGINT, signal.SIGTERM):\n            signal.signal(sig, signal_handler)\n\n    try:\n        logger.info(\"Starting client listener\")\n        print_status(\"Client Runner\", \"Starting connection to server\", \"INFO\")\n\n        listen_task = asyncio.create_task(client.listen(handle_data))\n        wait_task = asyncio.create_task(shutdown_event.wait())\n\n        # Wait for either the shutdown event or the listen task to complete\n        done, pending = await asyncio.wait(\n            {listen_task, wait_task},\n            return_when=asyncio.FIRST_COMPLETED\n        )\n\n        # Cancel any pending tasks\n        for task in pending:\n            task.cancel()\n            try:\n                await task\n            except asyncio.CancelledError:\n                logger.debug(\"Task cancelled successfully\")\n\n        if listen_task in done:\n            # If listen_task completed, check if it raised any exceptions\n            try:\n                await listen_task\n            except Exception as e:\n                logger.error(f\"Error in listen task: {e}\")\n                print_status(\"Client Runner\",\n                             f\"Error in connection: {str(e)}\",\n                             \"ERROR\")\n\n        logger.info(\"Initiating shutdown sequence\")\n        print_status(\"Client Runner\", \"Initiating shutdown sequence\", \"INFO\")\n        await client.close()\n\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        print_status(\"Client Runner\", f\"Unexpected error: {str(e)}\", \"ERROR\")\n    finally:\n        logger.info(\"Cleanup complete\")\n        print_status(\"Client Runner\", \"Cleanup complete\", \"SUCCESS\")\n\n\nif __name__ == \"__main__\":\n    if trader_broker_setup_check():\n        try:\n            logger.info(\"Initializing client application\")\n            print_status(\"Client Runner\",\n                         \"Initializing client application\", \"INFO\")\n\n            # start the client runner, listening for data\n            asyncio.run(main())\n\n        except KeyboardInterrupt:\n            logger.warning(\"Program interrupted by user\")\n            print_status(\"Client Runner\", \"Program interrupted by user\", \"WARNING\")\n        except Exception as e:\n            logger.error(f\"Fatal error in main: {e}\")\n            print_status(\"Client Runner\", f\"Fatal error: {str(e)}\", \"ERROR\")\n    else:\n        logger.error(\"Broker setup failed, exiting... Please check required settings\")\n        print_status(\"Client Runner\", \"Broker setup failed, exiting... Please check required settings\", \"ERROR\")\n        sys.exit(1)\n"}
{"type": "source_file", "path": "brokers/tiger_broker.py", "content": "\"\"\"\n# created: 01/18/2024, final version for open source only\n# Version 0.1.1\n# for more info, please visit: https://www.patreon.com/LookAtWallStreet\nDev. Team:\nLuke\nAngus\n\"\"\"\n\nfrom typing import Optional, Tuple\n\nfrom brokers.base_broker import BaseBroker\nfrom tigeropen.tiger_open_config import TigerOpenClientConfig\nfrom tigeropen.trade.trade_client import TradeClient\nfrom tigeropen.common.consts import Market, SecurityType, Currency\nfrom tigeropen.common.util.contract_utils import stock_contract\nfrom tigeropen.trade.domain.order import Order\n\nfrom env._secrete import Tiger_account_number\n\nimport time\n\nimport nest_asyncio\n\nfrom utils.wall_api_client import print_status\n\nnest_asyncio.apply()\n\n\"\"\" ⬇️ Broker Setup ⬇️ \"\"\"\n# Tiger API Docs: https://quant.itigerup.com/openapi/zh/python/overview/introduction.html\n'''\nStep 1: Set up the environment information\n'''\n# Environment Variables\nTIGER_CONFIG_PATH = './env/'\n\n'''\nStep 2: Set up the account information\n'''\nTIGER_ACCOUNT_NUMBER = Tiger_account_number  # set up the account number in the env/_secrete.py file\n\n'''\nStep 3: Set up the trading information\n'''\nFILL_OUTSIDE_MARKET_HOURS = True  # enable if order fills on extended hours\n\n\"\"\" ⏫ Broker Setup ⏫ \"\"\"\n\n\nclass TigerBroker(BaseBroker):\n\n    def __init__(self):\n        super().__init__()\n        self.connection_attempts = 0\n        self.max_attempts = 3\n        self.retry_delay = 5  # seconds\n        # init the trade_client, account_hash, and connected status\n        self.trade_client = None\n        self.connected = False\n\n    def connect(self) -> bool:\n        while self.connection_attempts < self.max_attempts:\n            try:\n                self.trade_client = TradeClient(self._get_client_config())\n                self.trade_client.get_managed_accounts(\n                    account=TIGER_ACCOUNT_NUMBER)  # if the execution fails, the Tiger SDK will raise an exception\n                self.connected = True\n                self.connection_attempts = 0\n                # self.logger.info(\"Successfully connected to Tiger\")\n                return True\n\n            except Exception as e:\n                self.connection_attempts += 1\n                self.logger.error(\n                    f\"Connection attempt {self.connection_attempts} failed: {e}\")\n                if self.connection_attempts < self.max_attempts:\n                    time.sleep(self.retry_delay * self.connection_attempts ** 2)  # exponential backoff\n\n        self.connected = False\n        self.logger.error(\"Failed to connect to Tiger after maximum attempts\")\n        return False\n\n    def _get_client_config(self) -> TigerOpenClientConfig:\n        client_config = TigerOpenClientConfig(props_path=TIGER_CONFIG_PATH)\n        return client_config\n\n    def get_account_info(self) -> Tuple[int, Optional[dict]]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Get Account Info failed: not connected\")\n            # print(\"Trader: Get Account Info failed: not connected\")\n            print_status(\"Trader\", \"Get Account Info failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            account_info = self.trade_client.get_managed_accounts(account=TIGER_ACCOUNT_NUMBER)\n            self.logger.info(f\"Retrieved account info: {account_info}\")\n            return self.ret_ok_code, account_info\n        except Exception as e:\n            self.logger.error(f\"Error retrieving account info: {e}\")\n            return self.ret_ok_code, None\n\n    def get_cash_balance(self) -> Tuple[int, Optional[float]]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Get Cash Balance failed: not connected\")\n            # print(\"Trader: Get Cash Balance failed: not connected\")\n            print_status(\"Trader\", \"Get Cash Balance failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            portfolio_account = self.trade_client.get_prime_assets(account=TIGER_ACCOUNT_NUMBER, base_currency='USD')\n            cash_available_for_trade = portfolio_account.segments['S'].currency_assets['USD'].cash_available_for_trade\n            self.logger.info(f\"Retrieved cash balance: {cash_available_for_trade}\")\n            return self.ret_ok_code, float(cash_available_for_trade)\n        except Exception as e:\n            self.logger.error(f\"Error retrieving cash balance: {e}\")\n            return self.ret_error_code, None\n\n    def get_cash_balance_number_only(self) -> Tuple[int, Optional[float]]:\n        return self.get_cash_balance()\n\n    def get_positions(self) -> Tuple[int, Optional[list]]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Get Positions failed: not connected\")\n            # print(\"Trader: Get Positions failed: not connected\")\n            print_status(\"Trader\", \"Get Positions failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            positions = self.trade_client.get_positions(account=TIGER_ACCOUNT_NUMBER, sec_type=SecurityType.STK,\n                                                        currency=Currency.USD, market=Market.US, symbol=None)\n            self.logger.info(f\"Retrieved positions: {positions}\")\n            return self.ret_ok_code, positions\n        except Exception as e:\n            self.logger.error(f\"Error retrieving positions: {e}\")\n            return self.ret_error_code, None\n\n    def get_positions_by_ticker(self, ticker) -> Tuple[int, Optional[int]]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Get Positions by Ticker failed: not connected\")\n            # print(\"Trader: Get Positions by Ticker failed: not connected\")\n            print_status(\"Trader\", \"Get Positions by Ticker failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            position = self.trade_client.get_positions(account=TIGER_ACCOUNT_NUMBER, sec_type=SecurityType.STK,\n                                                       currency=Currency.USD, market=Market.US, symbol=ticker)\n            if not position:\n                return self.ret_error_code, 0\n            return self.ret_ok_code, position[0].salable_qty\n        except Exception as e:\n            self.logger.error(f\"Error retrieving positions: {e}\")\n            return self.ret_error_code, None\n\n    def market_sell(self, stock: str, quantity: int, price: float) -> Tuple[int, None]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Market Sell failed: not connected\")\n            # print(\"Trader: Market Sell failed: not connected\")\n            print_status(\"Trader\", \"Market Sell failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            contract = stock_contract(symbol=stock, currency='USD')\n            order = Order(account=TIGER_ACCOUNT_NUMBER, contract=contract, action='SELL', order_type='MKT',\n                          quantity=quantity)\n            oid = self.trade_client.place_order(order)\n            return self.ret_ok_code, None\n        except Exception as e:\n            self.logger.error(f\"Error placing market sell order: {e}\")\n            return self.ret_error_code, None\n\n    def market_buy(self, stock: str, quantity: int, price: float) -> Tuple[int, None]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Market Buy failed: not connected\")\n            # print(\"Trader: Market Buy failed: not connected\")\n            print_status(\"Trader\", \"Market Buy failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            contract = stock_contract(symbol=stock, currency='USD')\n            order = Order(account=TIGER_ACCOUNT_NUMBER, contract=contract, action='BUY', order_type='MKT',\n                          quantity=quantity)\n            oid = self.trade_client.place_order(order)\n            return self.ret_ok_code, None\n        except Exception as e:\n            self.logger.error(f\"Error placing market buy order: {e}\")\n            return self.ret_error_code, None\n\n    def limit_sell(self, stock: str, quantity: int, price: float) -> Tuple[int, None]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Limit Sell failed: not connected\")\n            # print(\"Trader: Limit Sell failed: not connected\")\n            print_status(\"Trader\", \"Limit Sell failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            contract = stock_contract(symbol=stock, currency='USD')\n            order = Order(account=TIGER_ACCOUNT_NUMBER, contract=contract, action='SELL', order_type='LMT',\n                          quantity=quantity, limit_price=price, outside_rth=FILL_OUTSIDE_MARKET_HOURS,\n                          time_in_force='GTC')\n            oid = self.trade_client.place_order(order)\n            return self.ret_ok_code, None\n        except Exception as e:\n            self.logger.error(f\"Error placing limit sell order: {e}\")\n            return self.ret_error_code, None\n\n    def limit_buy(self, stock: str, quantity: int, price: float) -> Tuple[int, None]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Limit Buy failed: not connected\")\n            # print(\"Trader: Limit Buy failed: not connected\")\n            print_status(\"Trader\", \"Limit Buy failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            contract = stock_contract(symbol=stock, currency='USD')\n            order = Order(account=TIGER_ACCOUNT_NUMBER, contract=contract, action='BUY', order_type='LMT',\n                          quantity=quantity, limit_price=price, outside_rth=FILL_OUTSIDE_MARKET_HOURS,\n                          time_in_force='GTC')\n            oid = self.trade_client.place_order(order)\n            return self.ret_ok_code, None\n        except Exception as e:\n            self.logger.error(f\"Error placing limit buy order: {e}\")\n            return self.ret_error_code, None\n"}
{"type": "source_file", "path": "brokers/moomoo_futu_broker.py", "content": "# Dev\n# 03/29/2024\n# LukeLab for LookAtWallStreet\n# Version 1.0\n# Programming Trading based on MooMoo API/OpenD\n\n\"\"\"\n# created: 11/17/2024, final version for open source only\n# Version 2.0\n# for more info, please visit: https://www.patreon.com/LookAtWallStreet\n\n# created: 12/20/2024, final version for WallTrading API only\n# Version 0.1.1\n# for more info, please visit: https://www.patreon.com/LookAtWallStreet\nDev. Team:\nLuke\nAngus\n\n\"\"\"\n\n# MooMoo API Documentation, English:\n# https://openapi.moomoo.com/moomoo-api-doc/en/intro/intro.html\n# 官方文档，中文:\n# https://openapi.moomoo.com/moomoo-api-doc/intro/intro.html\n\nfrom moomoo import *\n\nfrom brokers.base_broker import BaseBroker\nfrom env._secrete import MooMoo_Futu_PWD, MooMoo_Futu_SecurityFirm\nfrom trading_settings import TRADING_BROKER, TRADING_ALLOW_PRE_POST_MARKET_ORDER\nfrom utils.wall_api_client import print_status\n\nimport nest_asyncio\n\nnest_asyncio.apply()\n\n\"\"\" ⬇️ Broker Setup ⬇️ \"\"\"\n'''\nStep 1: Set up the environment information\n'''\n# Environment Variables\nMOOMOOOPEND_ADDRESS = \"127.0.0.1\"  # should be same as the OpenD host IP, just keep as default\nMOOMOOOPEND_PORT = 11112  # should be same as the OpenD port number, make sure keep both the same\nTRADING_ENVIRONMENT = TrdEnv.REAL  # set up trading environment, real, or simulate/paper trading\n# REAL = \"REAL\"\n# SIMULATE = \"SIMULATE\"\n\n'''\nStep 2: Set up the account information\n'''\nTRADING_PWD = MooMoo_Futu_PWD  # set up the trading password in the env/_secrete.py file\n\n'''\nStep 3: Set up the trading information\n'''\nFILL_OUTSIDE_MARKET_HOURS = TRADING_ALLOW_PRE_POST_MARKET_ORDER  # enable if order fills on extended hours\nTRADING_MARKET = TrdMarket.US  # set up the trading market, US market, HK for HongKong, etc.\n# NONE = \"N/A\"\n# HK = \"HK\"\n# US = \"US\"\n# CN = \"CN\"\n# HKCC = \"HKCC\"\n# FUTURES = \"FUTURES\"\n\n\"\"\" ⏫ project setup ⏫ \"\"\"\n\n\n# Trader class:\nclass MooMooFutuBroker(BaseBroker):\n    def __init__(self):\n        super().__init__()\n        self.trade_context = None\n\n        # set up the security firm based on your broker account registration\n        if MooMoo_Futu_SecurityFirm == 'FUTUINC':\n            self.Broker_SecurityFirm = SecurityFirm.FUTUINC  # for U.S. account, use FUTUINC, (default)\n        elif MooMoo_Futu_SecurityFirm == 'FUTUSECURITIES' or TRADING_BROKER == 'Futu':\n            self.Broker_SecurityFirm = SecurityFirm.FUTUSECURITIES  # for HongKong account, use 'FUTUSECURITIES'\n        elif MooMoo_Futu_SecurityFirm == 'FUTUSG':\n            self.Broker_SecurityFirm = SecurityFirm.FUTUSG  # for Singapore account, use 'FUTUSG'\n        else:\n            self.Broker_SecurityFirm = SecurityFirm.FUTUAU  # for Australia account, use 'FUTUAU'\n\n    def init_context(self):\n        try:\n            # if OpenD not running, it will loop to connect until OpenD is running.\n            self.trade_context = OpenSecTradeContext(filter_trdmarket=TRADING_MARKET, host=MOOMOOOPEND_ADDRESS,\n                                                     port=MOOMOOOPEND_PORT, security_firm=self.Broker_SecurityFirm)\n            self.logger.info('MooMoo/Futu Trader: Init Context success!')\n            return True\n        except Exception as e:\n            self.logger.error(f'MooMoo/Futu Trader: Init Context failed: {e}')\n            self.logger.error('MooMoo/Futu Trader: Please check the OpenD host IP and port number!')\n            print_status(\"MooMoo/Futu Trader\", \"Init Context failed, please check the OpenD host IP and port number!\",\n                         \"ERROR\")\n            return False\n\n    def close_context(self):\n        self.trade_context.close()\n        self.logger.info('MooMoo/Futu Trader: Close Context success!')\n\n    def _unlock_trade(self):\n        if TRADING_ENVIRONMENT == TrdEnv.REAL:\n            ret, data = self.trade_context.unlock_trade(TRADING_PWD)\n            if ret != RET_OK:\n                print_status(\"MooMoo/Futu Trader\", f\"Unlock Trade failed, {data}\", \"ERROR\")\n                return False\n            print_status(\"MooMoo/Futu Trader\", \"Unlock Trade success\", \"SUCCESS\")\n        return True\n\n    def market_sell(self, stock, quantity, price):\n        self.init_context()\n        if self._unlock_trade():\n            code = f'US.{stock}'\n            ret, data = self.trade_context.place_order(price=price, qty=quantity, code=code, trd_side=TrdSide.SELL,\n                                                       order_type=OrderType.MARKET, trd_env=TRADING_ENVIRONMENT)\n            if ret != RET_OK:\n                print_status(\"MooMoo/Futu Trader\", \"Market Sell failed\", \"ERROR\")\n                self.logger.warning(f'Trader: Market Sell failed: {data}')\n                self.close_context()\n                return ret, data\n            print_status(\"MooMoo/Futu Trader\", \"Market Sell success\", \"SUCCESS\")\n            self.logger.info('Trader: Market Sell success!')\n            self.close_context()\n            return self.ret_ok_code, data\n        else:\n            data = 'Trader: Market Sell failed: unlock trade failed'\n            print_status(\"MooMoo/Futu Trader\", \"Market Sell failed: unlock trade failed\", \"ERROR\")\n            self.logger.warning(data)\n            self.close_context()\n            return self.ret_error_code, data\n\n    def market_buy(self, stock, quantity, price):\n        self.init_context()\n        if self._unlock_trade():\n            code = f'US.{stock}'\n            ret, data = self.trade_context.place_order(price=price, qty=quantity, code=code, trd_side=TrdSide.BUY,\n                                                       order_type=OrderType.MARKET, trd_env=TRADING_ENVIRONMENT)\n            if ret != RET_OK:\n                print_status(\"MooMoo/Futu Trader\", \"Market Buy failed\", \"ERROR\")\n                self.logger.warning(f'Trader: Market Buy failed: {data}')\n                self.close_context()\n                return self.ret_error_code, data\n            print_status(\"MooMoo/Futu Trader\", \"Market Buy success\", \"SUCCESS\")\n            self.logger.info('Trader: Market Buy success!')\n            self.close_context()\n            return self.ret_ok_code, data\n        else:\n            data = 'Trader: Market Buy failed: unlock trade failed'\n            print_status(\"MooMoo/Futu Trader\", \"Market Buy failed: unlock trade failed\", \"ERROR\")\n            self.logger.warning(data)\n            self.close_context()\n            return self.ret_error_code, data\n\n    def limit_sell(self, stock, quantity, price):\n        self.init_context()\n        if self._unlock_trade():\n            code = f'US.{stock}'\n            ret, data = self.trade_context.place_order(price=price, qty=quantity, code=code, trd_side=TrdSide.SELL,\n                                                       order_type=OrderType.NORMAL, trd_env=TRADING_ENVIRONMENT,\n                                                       fill_outside_rth=FILL_OUTSIDE_MARKET_HOURS)\n            if ret != RET_OK:\n                print_status(\"MooMoo/Futu Trader\", \"Limit Sell failed\", \"ERROR\")\n                self.logger.warning(f'Trader: Limit Sell failed: {data}')\n                self.close_context()\n                return self.ret_error_code, data\n            print_status(\"MooMoo/Futu Trader\", \"Limit Sell success\", \"SUCCESS\")\n            self.logger.info('Trader: Limit Sell success!')\n            self.close_context()\n            return self.ret_ok_code, data\n        else:\n            data = 'Trader: Limit Sell failed: unlock trade failed'\n            print_status(\"MooMoo/Futu Trader\", \"Limit Sell failed: unlock trade failed\", \"ERROR\")\n            self.logger.warning(data)\n            self.close_context()\n            return self.ret_error_code, data\n\n    def limit_buy(self, stock, quantity, price):\n        self.init_context()\n        if self._unlock_trade():\n            code = f'US.{stock}'\n            ret, data = self.trade_context.place_order(price=price, qty=quantity, code=code, trd_side=TrdSide.BUY,\n                                                       order_type=OrderType.NORMAL, trd_env=TRADING_ENVIRONMENT,\n                                                       fill_outside_rth=FILL_OUTSIDE_MARKET_HOURS)\n            if ret != RET_OK:\n                print_status(\"MooMoo/Futu Trader\", \"Limit Buy failed\", \"ERROR\")\n                self.logger.warning(f'Trader: Limit Buy failed: {data}')\n                self.close_context()\n                return self.ret_error_code, data\n            print_status(\"MooMoo/Futu Trader\", \"Limit Buy success\", \"SUCCESS\")\n            self.logger.info('Trader: Limit Buy success!')\n            self.close_context()\n            return self.ret_ok_code, data\n        else:\n            data = 'Trader: Limit Buy failed: unlock trade failed'\n            print_status(\"MooMoo/Futu Trader\", \"Limit Buy failed: unlock trade failed\", \"ERROR\")\n            self.logger.warning(data)\n            self.close_context()\n            return self.ret_error_code, data\n\n    def get_account_info(self):\n        self.init_context()\n        if self._unlock_trade():\n            # https://openapi.moomoo.com/moomoo-api-doc/en/trade/get-funds.html\n            # Default, currency=Currency.HKD, change to USD\n            # updated 01-07-2025\n            ret, data = self.trade_context.accinfo_query(currency=Currency.USD)\n            if ret != RET_OK:\n                print_status(\"MooMoo/Futu Trader\", \"Get Account Info failed\", \"ERROR\")\n                self.logger.warning(f'Trader: Get Account Info failed: {data}')\n                self.close_context()\n                return self.ret_error_code, data\n\n            acct_info = {\n                # https://openapi.moomoo.com/moomoo-api-doc/en/trade/get-funds.html\n                # Obsolete. Please use 'us_cash' or other fields to get the cash of each currency.\n                # updated 01-07-2025\n                'cash': round(data[\"us_cash\"][0], 2),\n                'total_assets': round(data[\"total_assets\"][0], 2),\n                'market_value': round(data[\"market_val\"][0], 2),\n            }\n            self.close_context()\n            self.logger.info('Trader: Get Account Info success!')\n            return self.ret_ok_code, acct_info\n        else:\n            data = 'Trader: Get Account Info failed: unlock trade failed'\n            print_status(\"MooMoo/Futu Trader\", \"Get Account Info failed: unlock trade failed\", \"ERROR\")\n            self.logger.warning(data)\n            self.close_context()\n            return self.ret_error_code, data\n\n    def get_positions(self):\n        self.init_context()\n        if self._unlock_trade():\n            ret, data = self.trade_context.position_list_query()\n            if ret != RET_OK:\n                print_status(\"MooMoo/Futu Trader\", \"Get Positions failed\", \"ERROR\")\n                self.logger.warning(f'Trader: Get Positions failed: {data}')\n                self.close_context()\n                return self.ret_error_code, data\n            # refactor the data\n            data['code'] = data['code'].str[3:]\n            data_dict = data.set_index('code').to_dict(orient='index')\n            self.close_context()\n            self.logger.info('Trader: Get Positions success!')\n            return self.ret_ok_code, data_dict\n        else:\n            data = 'Trader: Get Positions failed: unlock trade failed'\n            print_status(\"MooMoo/Futu Trader\", \"Get Positions failed: unlock trade failed\", \"ERROR\")\n            self.logger.warning(data)\n            self.close_context()\n            return self.ret_error_code, data\n\n    def get_positions_by_ticker(self, ticker):\n        position_ret, position_data = self.get_positions()\n        if position_ret != self.ret_ok_code:\n            # get current position quantity\n            print_status(\"MooMoo/Futu Trader\", \"Get Positions by Ticker failed\", \"ERROR\")\n            return self.ret_error_code, position_data\n        try:\n            qty = position_data[ticker][\"qty\"]\n            return self.ret_ok_code, qty\n        except KeyError as e:\n            print_status(\"MooMoo/Futu Trader\", \"Get Positions by Ticker failed\", \"ERROR\")\n            self.logger.warning(f\"Trader: Get Positions by Ticker failed: {e}\")\n            return self.ret_error_code, 0\n\n    def get_cash_balance(self):\n        acct_ret, acct_info = self.get_account_info()\n        if acct_ret == self.ret_ok_code:\n            return self.ret_ok_code, acct_info['cash']\n        else:\n            print_status(\"MooMoo/Futu Trader\", \"Get Cash Balance failed\", \"ERROR\")\n            self.logger.warning(\"Trader: Get Cash Balance failed\")\n            return self.ret_error_code, acct_info\n\n    def get_cash_balance_number_only(self):\n        acct_ret, acct_info = self.get_cash_balance()\n        if acct_ret == self.ret_ok_code:\n            return self.ret_ok_code, acct_info\n        else:\n            print_status(\"MooMoo/Futu Trader\", \"Get Cash Balance number only failed\", \"ERROR\")\n            self.logger.warning(\"Trader: Get Cash Balance number only failed\")\n            return self.ret_error_code, acct_info\n"}
{"type": "source_file", "path": "brokers/ibkr_broker.py", "content": "\"\"\"\n# created: 12/20/2024, final version for open source only\n# Version 0.1.1\n# for more info, please visit: https://www.patreon.com/LookAtWallStreet\nDev. Team:\nLuke\nAngus\n\"\"\"\n\nfrom brokers.base_broker import BaseBroker\nfrom ib_insync import IB, Stock, MarketOrder, LimitOrder, Trade\nimport time\nfrom env._secrete import IBKR_account_number\n\nimport nest_asyncio\n\nfrom trading_settings import TRADING_ALLOW_PRE_POST_MARKET_ORDER\nfrom utils.wall_api_client import print_status\n\nnest_asyncio.apply()\n\n\"\"\" ⬇️ Broker Setup ⬇️ \"\"\"\n# IBKR API Docs: https://ib-insync.readthedocs.io/readme.html\n'''\nStep 1: Set up the environment information\n'''\n# Environment Variables\nCREDENTIAL = {\n    'host': 'localhost',\n    'port': 4001,  # IB Gateway or TWS port number, should be 4001 or 7497 in default\n    'client_id': 1,\n    'readonly': False\n}\n\n'''\nStep 2: Set up the account information\n'''\nIBKR_ACCOUNT_NUMBER = IBKR_account_number  # set up the account number in the env/_secrete.py file\n\n'''\nStep 3: Set up the trading information\n'''\n# use global variable to control the trading settings\nFILL_OUTSIDE_MARKET_HOURS = TRADING_ALLOW_PRE_POST_MARKET_ORDER  # enable if order fills on extended hours\n\n\"\"\" ⏫ Broker Setup ⏫ \"\"\"\n\n\nclass IBKRBroker(BaseBroker):\n    def __init__(self):\n        super().__init__()\n        self.ib = IB()\n        self.connection_attempts = 0\n        self.max_attempts = 3\n        self.retry_delay = 5  # seconds\n\n    def connect(self) -> bool:\n        while self.connection_attempts < self.max_attempts:\n            try:\n                self.ib.connect(\n                    host=CREDENTIAL.get('host', 'localhost'),\n                    port=CREDENTIAL.get('port', 4001),\n                    clientId=CREDENTIAL.get('client_id', 1),\n                    readonly=CREDENTIAL.get('readonly', False)\n                )\n                self.connected = True\n                self.connection_attempts = 0\n                # self.logger.info(\"Successfully connected to IBKR\")\n                return True\n\n            except Exception as e:\n                self.connection_attempts += 1\n                self.logger.error(\n                    f\"Connection attempt {self.connection_attempts} failed: {e}\")\n                if self.connection_attempts < self.max_attempts:\n                    time.sleep(self.retry_delay * self.connection_attempts ** 2)  # exponential backoff\n\n        self.connected = False\n        self.logger.error(\"Failed to connect to IBKR after maximum attempts\")\n        return False\n\n    def get_account_info(self):\n        self.connect()\n        if not self.ib.isConnected():\n            self.logger.error(f\"Trader: Get Account Info failed: not connected\")\n            # print(\"Trader: Get Account Info failed: not connected\")\n            print_status(\"Trader\", \"Get Account Info failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            account_summary = self.ib.accountSummary(IBKR_ACCOUNT_NUMBER)\n            self.logger.info(f\"Retrieved account info: {account_summary}\")\n            return self.ret_ok_code, account_summary\n        except Exception as e:\n            self.logger.error(f\"Error retrieving account info: {e}\")\n            return self.ret_ok_code, None\n        finally:\n            self.ib.disconnect()\n            self.logger.info(\"Disconnected from IBKR\")\n\n    def get_cash_balance(self):\n        self.connect()\n        if not self.ib.isConnected():\n            self.logger.error(f\"Trader: Get Cash Balance failed: not connected\")\n            # print(\"Trader: Get Cash Balance failed: not connected\")\n            print_status(\"Trader\", \"Get Cash Balance failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            account_values = self.ib.accountValues(IBKR_ACCOUNT_NUMBER)\n            available_funds = next((v.value for v in account_values if v.tag == 'CashBalance' and v.currency == 'USD'), None)\n            self.logger.info(f\"Retrieved cash balance: {available_funds}\")\n            return self.ret_ok_code, float(available_funds)\n        except Exception as e:\n            self.logger.error(f\"Error retrieving cash balance: {e}\")\n            return self.ret_error_code, None\n        finally:\n            self.ib.disconnect()\n\n    def get_cash_balance_number_only(self):\n        return self.get_cash_balance()\n\n    def get_positions(self):\n        self.connect()\n        if not self.ib.isConnected():\n            self.logger.error(f\"Trader: Get Positions failed: not connected\")\n            # print(\"Trader: Get Positions failed: not connected\")\n            print_status(\"Trader\", \"Get Positions failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            positions = self.ib.positions(IBKR_ACCOUNT_NUMBER)\n            self.logger.info(f\"Retrieved positions: {positions}\")\n            return self.ret_ok_code, positions\n        except Exception as e:\n            self.logger.error(f\"Error retrieving positions: {e}\")\n            return self.ret_error_code, None\n        finally:\n            self.ib.disconnect()\n\n    def get_positions_by_ticker(self, ticker):\n        try:\n            positions = self.get_positions()\n            return self.ret_ok_code, next((p.position for p in positions[1] if p.contract.symbol == ticker), 0.0)\n        except Exception as e:\n            self.logger.error(f\"Error retrieving positions by ticker: {e}\")\n            return self.ret_error_code, None\n\n    def market_sell(self, stock: str, quantity: int, price: float):\n        self.connect()\n        if not self.ib.isConnected():\n            self.logger.error(f\"Trader: Market Sell failed: not connected\")\n            # print(\"Trader: Market Sell failed: not connected\")\n            print_status(\"Trader\", \"Market Sell failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            contract = Stock(stock, 'SMART', 'USD')\n            order = MarketOrder('sell', quantity, account=IBKR_ACCOUNT_NUMBER)\n            trade = self.ib.placeOrder(contract, order)\n            return self.ret_ok_code, None\n        except Exception as e:\n            self.logger.error(f\"Error placing market sell order: {e}\")\n            return self.ret_error_code, None\n        finally:\n            self.ib.disconnect()\n\n    def market_buy(self, stock: str, quantity: int, price: float):\n        self.connect()\n        if not self.ib.isConnected():\n            self.logger.error(f\"Trader: Market Buy failed: not connected\")\n            # print(\"Trader: Market Buy failed: not connected\")\n            print_status(\"Trader\", \"Market Buy failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            contract = Stock(stock, 'SMART', 'USD')\n            order = MarketOrder('buy', quantity, account=IBKR_ACCOUNT_NUMBER)\n            trade = self.ib.placeOrder(contract, order)\n            return self.ret_ok_code, None\n        except Exception as e:\n            self.logger.error(f\"Error placing market buy order: {e}\")\n            return self.ret_error_code, None\n        finally:\n            self.ib.disconnect()\n\n    def limit_sell(self, stock: str, quantity: int, price: float):\n        self.connect()\n        if not self.ib.isConnected():\n            self.logger.error(f\"Trader: Limit Sell failed: not connected\")\n            # print(\"Trader: Limit Sell failed: not connected\")\n            print_status(\"Trader\", \"Limit Sell failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            contract = Stock(stock, 'SMART', 'USD')\n            order = LimitOrder('sell', quantity, price, account=IBKR_ACCOUNT_NUMBER, outsideRth=FILL_OUTSIDE_MARKET_HOURS)\n            trade = self.ib.placeOrder(contract, order)\n            return self.ret_ok_code, None\n        except Exception as e:\n            self.logger.error(f\"Error placing limit sell order: {e}\")\n            return self.ret_error_code, None\n        finally:\n            self.ib.disconnect()\n\n    def limit_buy(self, stock: str, quantity: int, price: float):\n        self.connect()\n        if not self.ib.isConnected():\n            self.logger.error(f\"Trader: Limit Buy failed: not connected\")\n            # print(\"Trader: Limit Buy failed: not connected\")\n            print_status(\"Trader\", \"Limit Buy failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        try:\n            contract = Stock(stock, 'SMART', 'USD')\n            order = LimitOrder('buy', quantity, price, account=IBKR_ACCOUNT_NUMBER, outsideRth=FILL_OUTSIDE_MARKET_HOURS)\n            trade = self.ib.placeOrder(contract, order)\n            res = f\"Trade submitted: {trade}\"\n            return self.ret_ok_code, None\n        except Exception as e:\n            self.logger.error(f\"Error placing limit buy order: {e}\")\n            return self.ret_error_code, None\n        finally:\n            self.ib.disconnect()\n\n    def _handle_trade_timeout_market(self, trade: Trade, timeout: int = 30):\n        start_time = time.time()\n        while time.time() - start_time < timeout:\n            self.ib.sleep(1)  # Sleep for 1 second to avoid busy-waiting\n            if trade.isDone():\n                self.logger.info(f\"Trade completed: {trade}\")\n                return trade\n        self.logger.error(f\"Trade timed out after {timeout} seconds: {trade}\")\n        return None\n\n    def _handle_trade_timeout_limit(self, trade: Trade, timeout: int = 30):\n        start_time = time.time()\n        while time.time() - start_time < timeout:\n            self.ib.sleep(1)  # Sleep for 1 second to avoid busy-waiting\n            if trade.isActive():\n                self.logger.info(f\"Trade submitted: {trade}\")\n                return trade\n        self.logger.error(f\"Trade timed out after {timeout} seconds: {trade}\")\n        return None\n"}
{"type": "source_file", "path": "brokers/schwab_broker.py", "content": "\"\"\"\n# created: 12/20/2024, final version for open source only\n# Version 0.1.1\n# for more info, please visit: https://www.patreon.com/LookAtWallStreet\nDev. Team:\nLuke\nAngus\n\"\"\"\n\nfrom typing import Optional, Tuple\n\nfrom brokers.base_broker import BaseBroker\nfrom schwab.auth import easy_client, client_from_login_flow, client_from_manual_flow\nfrom schwab.orders.equities import equity_buy_limit, equity_sell_limit, equity_buy_market, equity_sell_market\nfrom schwab.orders.common import Duration, Session\n\nfrom env._secrete import Schwab_account_number, Schwab_app_key, Schwab_secret\n\nimport httpx\nimport time\n\nfrom trading_settings import TRADING_ALLOW_PRE_POST_MARKET_ORDER\nfrom utils.wall_api_client import print_status\n\n\"\"\" ⬇️ Broker Setup ⬇️ \"\"\"\n# Schwab API Docs: https://schwab-py.readthedocs.io/en/latest/getting-started.html\n'''\nStep 1: Set up the environment information\n'''\n# Environment Variables\nSCHWAB_CALLBACK_URL = 'https://127.0.0.1:8182'  # should be same as the Callback URL of the App in Schwab Developer Portal, just keep as default\nSCHWAB_TOKEN_PATH = './env/_schwab_token.json'\n\n'''\nStep 2: Set up the account information\n'''\nSCHWAB_ACCOUNT_NUMBER = Schwab_account_number  # set up the account number in the env/_secrete.py file\nSCHWAB_APP_KEY = Schwab_app_key  # set up the App Key in the env/_secrete.py file\nSCHWAB_SECRET = Schwab_secret  # set up the Secret in the env/_secrete.py file\n\n'''\nStep 3: Set up the trading information\n'''\nFILL_OUTSIDE_MARKET_HOURS = TRADING_ALLOW_PRE_POST_MARKET_ORDER  # enable if order fills on extended hours\n\n\"\"\" ⏫ Broker Setup ⏫ \"\"\"\n\n\nclass SchwabBroker(BaseBroker):\n\n    def __init__(self):\n        super().__init__()\n        self.connection_attempts = 0\n        self.max_attempts = 3\n        self.retry_delay = 5  # seconds\n        # self.connect()    #don't connect when init here, connect when needed\n\n        # init the client, account_hash, and connected status\n        self.client = None\n        self.account_hash = None\n        self.connected = False\n\n    def connect(self) -> bool:\n        while self.connection_attempts < self.max_attempts:\n            try:\n                self.client = easy_client(api_key=SCHWAB_APP_KEY, app_secret=SCHWAB_SECRET,\n                                          callback_url=SCHWAB_CALLBACK_URL, token_path=SCHWAB_TOKEN_PATH,\n                                          max_token_age=60 * 60 * 24 * 6.5)\n\n                ret_status_code, self.account_hash = self._get_account_hash()\n                if ret_status_code != self.ret_ok_code:\n                    raise Exception\n\n                self.connected = True\n                self.connection_attempts = 0\n                # self.logger.info(\"Successfully connected to Schwab\")\n                return True\n\n            except Exception as e:\n                self.connection_attempts += 1\n                self.logger.error(\n                    f\"Connection attempt {self.connection_attempts} failed: {e}\")\n                if self.connection_attempts < self.max_attempts:\n                    time.sleep(self.retry_delay * self.connection_attempts ** 2)  # exponential backoff\n\n        self.connected = False\n        self.logger.error(\"Failed to connect to Schwab after maximum attempts\")\n        return False\n\n    def _get_account_hash(self) -> Tuple[int, Optional[str]]:\n        resp = self.client.get_account_numbers()\n        if resp.status_code != httpx.codes.OK:\n            self.logger.error(f\"Trader: Get Account Hash failed: {resp.json()['message']}\")\n            # print(f\"Trader: Get Account Hash failed: {resp.json()['message']}\")\n            print_status(\"Trader\", f\"Get Account Hash failed: {resp.json()['message']}\", \"ERROR\")\n            return self.ret_error_code, None\n\n        account_hash = next(\n            (item['hashValue'] for item in resp.json() if item['accountNumber'] == SCHWAB_ACCOUNT_NUMBER),\n            None\n        )\n\n        if account_hash:\n            return self.ret_ok_code, account_hash\n        else:\n            self.logger.error('Trader: Get Account Hash failed: wrong account number')\n            # print(\"Trader: Get Account Hash failed: wrong account number\")\n            print_status(\"Trader\", \"Get Account Hash failed: wrong account number\", \"ERROR\")\n            return self.ret_error_code, None\n\n    def get_account_info(self) -> Tuple[int, Optional[dict]]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Get Account Info failed: not connected\")\n            # print(\"Trader: Get Account Info failed: not connected\")\n            print_status(\"Trader\", \"Get Account Info failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        resp = self.client.get_account(self.account_hash)\n\n        if resp.status_code != httpx.codes.OK:\n            self.logger.error(f\"Trader: Get Account Info failed: {resp.json()['message']}\")\n            # print(f\"Trader: Get Account Info failed: {resp.json()['message']}\")\n            print_status(\"Trader\", f\"Get Account Info failed: {resp.json()['message']}\", \"ERROR\")\n            return self.ret_error_code, None\n\n        account_info = resp.json()\n\n        cash = 0\n\n        if account_info['securitiesAccount']['type'] == 'CASH':\n            cash = account_info['securitiesAccount']['currentBalances']['totalCash'] - \\\n                   account_info['securitiesAccount']['currentBalances']['unsettledCash']\n        elif account_info['securitiesAccount']['type'] == 'MARGIN':\n            cash = account_info['securitiesAccount']['currentBalances']['cashBalance']\n        total_assets = account_info['securitiesAccount']['currentBalances']['liquidationValue']\n        market_value = account_info['securitiesAccount']['currentBalances']['longMarketValue']\n\n        acct_info = {\n            'cash': round(cash, 2),\n            'total_assets': round(total_assets, 2),\n            'market_value': round(market_value, 2),\n        }\n\n        self.logger.info(f\"Retrieved account info: {acct_info}\")\n\n        return self.ret_ok_code, acct_info\n\n    def get_cash_balance(self) -> Tuple[int, Optional[float]]:\n        acct_ret, acct_info = self.get_account_info()\n        if acct_ret == self.ret_ok_code:\n            self.logger.info(f\"Retrieved cash balance: {acct_info['cash']}\")\n            return self.ret_ok_code, acct_info['cash']\n        else:\n            return self.ret_error_code, None\n\n    def get_cash_balance_number_only(self) -> Tuple[int, Optional[float]]:\n        return self.get_cash_balance()\n\n    def get_positions(self) -> Tuple[int, Optional[dict]]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Get Positions failed: not connected\")\n            # print(\"Trader: Get Positions failed: not connected\")\n            print_status(\"Trader\", \"Get Positions failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        resp = self.client.get_account(self.account_hash, fields=[self.client.Account.Fields.POSITIONS])\n\n        if resp.status_code != httpx.codes.OK:\n            self.logger.error(f\"Trader: Get Positions failed: {resp.json()['message']}\")\n            # print(f\"Trader: Get Positions failed: {resp.json()['message']}\")\n            print_status(\"Trader\", f\"Get Positions failed: {resp.json()['message']}\", \"ERROR\")\n            return self.ret_error_code, None\n        else:\n            account_info = resp.json()\n            positions = account_info.get('securitiesAccount', {}).get('positions', [])\n            data_dict = {}\n            for position in positions:\n                code = position['instrument']['symbol']\n                position_data = {key: value for key, value in position.items() if key != 'instrument'}\n                position_data.update(position['instrument'])\n                data_dict[code] = position_data\n            self.logger.info(f\"Retrieved positions: {data_dict}\")\n            return self.ret_ok_code, data_dict\n\n    def get_positions_by_ticker(self, ticker: str) -> Tuple[int, Optional[float]]:\n        ret_status_code, positions = self.get_positions()\n        if ret_status_code == self.ret_ok_code:\n            position = positions.get(ticker, {})\n            return self.ret_ok_code, position.get('longQuantity', 0.0)\n        else:\n            return self.ret_error_code, None\n\n    def market_sell(self, stock: str, quantity: int, price: float) -> Tuple[int, None]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Market Sell failed: not connected\")\n            # print(\"Trader: Market Sell failed: not connected\")\n            print_status(\"Trader\", \"Market Sell failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        order = equity_sell_market(stock, quantity).build()\n        resp = self.client.place_order(self.account_hash, order)\n\n        if resp.status_code != httpx.codes.CREATED:\n            self.logger.error(f\"Trader: Market Sell failed: {resp.json()['message']}\")\n            # print(f\"Trader: Market Sell failed: {resp.json()['message']}\")\n            print_status(\"Trader\", f\"Market Sell failed: {resp.json()['message']}\", \"ERROR\")\n            return self.ret_error_code, None\n\n        return self.ret_ok_code, None\n\n    def market_buy(self, stock: str, quantity: int, price: float) -> Tuple[int, None]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Market Buy failed: not connected\")\n            # print(\"Trader: Market Buy failed: not connected\")\n            print_status(\"Trader\", \"Market Buy failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        order = equity_buy_market(stock, quantity).build()\n        resp = self.client.place_order(self.account_hash, order)\n\n        if resp.status_code != httpx.codes.CREATED:\n            self.logger.error(f\"Trader: Market Buy failed: {resp.json()['message']}\")\n            # print(f\"Trader: Market Buy failed: {resp.json()['message']}\")\n            print_status(\"Trader\", f\"Market Buy failed: {resp.json()['message']}\", \"ERROR\")\n            return self.ret_error_code, None\n\n        return self.ret_ok_code, None\n\n    def limit_sell(self, stock: str, quantity: int, price: str) -> Tuple[int, None]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Limit Sell failed: not connected\")\n            # print(\"Trader: Limit Sell failed: not connected\")\n            print_status(\"Trader\", \"Limit Sell failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        if not isinstance(price, str):\n            price = str(price)\n\n        if FILL_OUTSIDE_MARKET_HOURS:\n            order = equity_sell_limit(stock, quantity, price).set_duration(Duration.GOOD_TILL_CANCEL).set_session(\n                Session.SEAMLESS).build()\n        else:\n            order = equity_sell_limit(stock, quantity, price).set_duration(Duration.GOOD_TILL_CANCEL).set_session(\n                Session.NORMAL).build()\n        resp = self.client.place_order(self.account_hash, order)\n\n        if resp.status_code != httpx.codes.CREATED:\n            self.logger.error(f\"Trader: Limit Sell failed: {resp.json()['message']}\")\n            # print(f\"Trader: Limit Sell failed: {resp.json()['message']}\")\n            print_status(\"Trader\", f\"Limit Sell failed: {resp.json()['message']}\", \"ERROR\")\n            return self.ret_error_code, None\n\n        return self.ret_ok_code, None\n\n    def limit_buy(self, stock: str, quantity: int, price: str) -> Tuple[int, None]:\n        self.connect()\n        if not self.connected:\n            self.logger.error(f\"Trader: Limit Buy failed: not connected\")\n            # print(\"Trader: Limit Buy failed: not connected\")\n            print_status(\"Trader\", \"Limit Buy failed: not connected\", \"ERROR\")\n            return self.ret_error_code, None\n\n        if not isinstance(price, str):\n            price = str(price)\n\n        if FILL_OUTSIDE_MARKET_HOURS:\n            order = equity_buy_limit(stock, quantity, price).set_duration(Duration.GOOD_TILL_CANCEL).set_session(\n                Session.SEAMLESS).build()\n        else:\n            order = equity_buy_limit(stock, quantity, price).set_duration(Duration.GOOD_TILL_CANCEL).set_session(\n                Session.NORMAL).build()\n        resp = self.client.place_order(self.account_hash, order)\n\n        if resp.status_code != httpx.codes.CREATED:\n            self.logger.error(f\"Trader: Limit Buy failed: {resp.json()['message']}\")\n            # print(f\"Trader: Limit Buy failed: {resp.json()['message']}\")\n            print_status(\"Trader\", f\"Limit Buy failed: {resp.json()['message']}\", \"ERROR\")\n            return self.ret_error_code, None\n\n        return self.ret_ok_code, None\n"}
{"type": "source_file", "path": "env/_secrete.py", "content": "\"\"\"\nImportant, please don't share with the public\n\"\"\"\n\n\"\"\" !!!  please keep your password in SAFE, DO NOT SHARE !!! \"\"\"\n\n\"\"\" WallTrading API ID and Password \"\"\"\n# ask 阿墙.B or squawkwallstreet for the API ID and Password\nAPI_CLIENT_ID = 'your WallTrading API ID'\nAPI_PASSWORD = 'your WallTrading API Password'\n\n\"\"\" MooMoo trading setup \"\"\"\n# 1. trading password, 6 digits\nMooMoo_Futu_PWD = '123456'  # replace with your moomoo trading password\n\n# 2. choose the security firm based on your broker account registration\nMooMoo_Futu_SecurityFirm = 'FUTUINC'\n# for U.S. account, use 'FUTUINC', (default)\n# for HongKong account, use 'FUTUSECURITIES'\n# for Singapore account, use 'FUTUSG'\n# for Australia account, use 'FUTUAU'\n\n\n\"\"\" Schwab trading setup \"\"\"\nSchwab_account_number = '12345678'\nSchwab_app_key = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\nSchwab_secret = 'xxxxxxxxxxxxxxxx'\n\n\"\"\" IBKR trading setup \"\"\"\nIBKR_account_number = 'U12345678'\n\n\"\"\" Tiger trading setup \"\"\"\nTiger_account_number = '123456'\n# use Tiger omnibus account number, instead of 'Tiger ID' in Tiger Open Platform\n\n\n\"\"\" LongPort trading setup \"\"\"\nLongPort_app_key = \"YOUR_APP_KEY\",\nLongPort_app_secret = \"YOUR_APP_SECRET\",\nLongPort_access_token = \"YOUR_ACCESS_TOKEN\"\n\n\n\"\"\" WEBULL: Trading setup \"\"\"\nWebull_username = 'your_username'\nWebull_password = 'your_password'\nWebull_PID = 'your_pid'\nWebull_did_from_web = 'your_did_from_web'\nWebull_access_token = 'your_access_token'\nWebull_uuid = 'your_uuid'\n# Below are optional, if you don't have these information, just leave them.\nWebull_mfa_code = 'your_mfa_code'\nWebull_account_type = 'your_account_type'\nWebull_account_id = 'your_account_id'\nWebull_device_name = 'your_device_name'\nWebull_TBA = 'your_TBA'\n\n\"\"\" !!!  please keep your password in SAFE, DO NOT SHARE !!! \"\"\"\n\n\"\"\" Don't Change the file below \"\"\"\nSERVER_IP = '43.153.30.74'\nSERVER_DOMAIN_NAME = 'www.lookatwallstreet.com'\n"}
{"type": "source_file", "path": "utils/local_decision.py", "content": "\"\"\" Please don't change the code below, unless you know what you are doing \"\"\"\n\nfrom trading_settings import TRADING_LIST, TRADING_LEVEL, ENABLE_BUY_TQQQ, ENABLE_BUY_SOXL, \\\n    ENABLE_BUY_IBIT, ENABLE_SELL_TQQQ, ENABLE_SELL_SOXL, ENABLE_SELL_IBIT, FUND_MODE, INITIAL_FUND_FOR_TQQQ, \\\n    INITIAL_FUND_FOR_SOXL, INITIAL_FUND_FOR_IBIT, QTY_MODE, ONE_PERCENT_TRADING_QTY_FOR_TQQQ, \\\n    ONE_PERCENT_TRADING_QTY_FOR_SOXL, ONE_PERCENT_TRADING_QTY_FOR_IBIT, LEVEL_POSITIONS_TQQQ, LEVEL_POSITIONS_SOXL, \\\n    LEVEL_POSITIONS_IBIT, LEVEL_POSITIONS_DEFAULT, Bind_Depth_codeNum\nfrom utils.wall_api_client import print_status\n\n\"\"\"\nLocal decision handler for the trade\n\"\"\"\n\n\"\"\" Please do NOT change the code below, unless you KNOW what you are doing \"\"\"\n\n\ndef decision_qty(json_data) -> tuple[int, float]:\n    \"\"\"\n    :param json_data:\n    :return: qty, position_pct\n    \"\"\"\n\n    level = int(json_data[\"level\"][1:])\n    depth = int(json_data[\"depth\"])\n    codeNum = int(json_data[\"codeNum\"])\n    price = float(json_data[\"price\"])\n    stock = json_data[\"ticker\"]\n    direction = json_data[\"direction\"]\n\n    position_pct = 0\n\n    # 0. # calculate the position percentage and check level\n    LEVEL_POSITIONS_MAP = {\n        \"TQQQ\": LEVEL_POSITIONS_TQQQ,\n        \"SOXL\": LEVEL_POSITIONS_SOXL,\n        \"IBIT\": LEVEL_POSITIONS_IBIT\n    }\n    LEVEL_POSITIONS = LEVEL_POSITIONS_MAP.get(stock, LEVEL_POSITIONS_DEFAULT)\n\n    # 0. Mapping the position percentage\n    if level in LEVEL_POSITIONS:\n        depth_position = 0\n        code_position = 0\n\n        if depth in LEVEL_POSITIONS[level]['depth']:\n            depth_position = LEVEL_POSITIONS[level]['depth'][depth]\n        if codeNum in LEVEL_POSITIONS[level]['code']:\n            if Bind_Depth_codeNum:\n                if depth_position > 0:\n                    code_position = LEVEL_POSITIONS[level]['code'][codeNum]\n                else:\n                    code_position = 0\n            else:\n                code_position = LEVEL_POSITIONS[level]['code'][codeNum]\n\n        position_pct = depth_position + code_position\n\n        # check if the current level is enabled\n        if not LEVEL_POSITIONS[level]['enable']:\n            print_status(\"Decision QTY Handler\",\n                         f\"Decision, level: {level}, not enabled, qty is 0, please check the trading settings\",\n                         \"WARNING\")\n            return 0, position_pct\n    else:\n        print_status(\"Decision QTY Handler\",\n                     f\"Warning, level issues, qty is 0, please check the trading settings\",\n                     \"WARNING\")\n        return 0, position_pct\n\n    # 1. check if the trading data is in the trading list and trading level\n    if stock not in TRADING_LIST:\n        print_status(\"Decision QTY Handler\",\n                     f\"Warning, ticker not in the trading list, qty is 0, please check the trading settings\",\n                     \"WARNING\")\n        return 0, position_pct\n    if json_data[\"level\"] not in TRADING_LEVEL:\n        print_status(\"Decision QTY Handler\",\n                     f\"Warning, level not in the trading level, qty is 0, please check the trading settings\",\n                     \"WARNING\")\n        return 0, position_pct\n\n    # 2. check if the trading direction is enabled\n    if direction == \"Bull\":\n        if stock == \"TQQQ\" and not ENABLE_BUY_TQQQ:\n            print_status(\"Decision QTY Handler\",\n                         f\"Warning, {stock} buy is not enabled, qty is 0, please check the trading settings\",\n                         \"WARNING\")\n            return 0, position_pct\n        if stock == \"SOXL\" and not ENABLE_BUY_SOXL:\n            print_status(\"Decision QTY Handler\",\n                         f\"Warning, {stock} buy is not enabled, qty is 0, please check the trading settings\",\n                         \"WARNING\")\n            return 0, position_pct\n        if stock == \"IBIT\" and not ENABLE_BUY_IBIT:\n            print_status(\"Decision QTY Handler\",\n                         f\"Warning, {stock} buy is not enabled, qty is 0, please check the trading settings\",\n                         \"WARNING\")\n            return 0, position_pct\n    elif direction == \"Bear\":\n        if stock == \"TQQQ\" and not ENABLE_SELL_TQQQ:\n            print_status(\"Decision QTY Handler\",\n                         f\"Warning, {stock} sell is not enabled, qty is 0, please check the trading settings\",\n                         \"WARNING\")\n            return 0, position_pct\n        if stock == \"SOXL\" and not ENABLE_SELL_SOXL:\n            print_status(\"Decision QTY Handler\",\n                         f\"Warning, {stock} sell is not enabled, qty is 0, please check the trading settings\",\n                         \"WARNING\")\n            return 0, position_pct\n        if stock == \"IBIT\" and not ENABLE_SELL_IBIT:\n            print_status(\"Decision QTY Handler\",\n                         f\"Warning, {stock} sell is not enabled, qty is 0, please check the trading settings\",\n                         \"WARNING\")\n            return 0, position_pct\n\n    # 3. calculate the trading quantity\n    # 3.1 calculate the trading quantity, FUND_MODE\n    if FUND_MODE:\n        initial_fund_map = {\n            \"TQQQ\": INITIAL_FUND_FOR_TQQQ,\n            \"SOXL\": INITIAL_FUND_FOR_SOXL,\n            \"IBIT\": INITIAL_FUND_FOR_IBIT\n        }\n\n        initial_fund = initial_fund_map.get(stock, 1)\n\n        qty = int((position_pct * initial_fund) / price)\n        # if qty < 1:\n        #     qty = 1\n        #     print_status(\"Decision QTY Handler - FUND MODE\", f\"Warning, qty reset to: {qty}, please check the trading settings\", \"WARNING\")\n        # delete, choose to strictly follow the position percentage\n        print_status(\"Decision QTY Handler - FUND MODE\",\n                     f\"Decision, qty is {qty}, please check the trading settings\",\n                     \"INFO\")\n        return qty, position_pct\n\n    # 3.2calculate the trading quantity, QTY_MODE\n    elif QTY_MODE:\n        qty_one_percent_map = {\n            \"TQQQ\": ONE_PERCENT_TRADING_QTY_FOR_TQQQ,\n            \"SOXL\": ONE_PERCENT_TRADING_QTY_FOR_SOXL,\n            \"IBIT\": ONE_PERCENT_TRADING_QTY_FOR_IBIT\n        }\n\n        qty_one_percent = qty_one_percent_map.get(stock, 1)\n\n        qty = int(position_pct * 100) * qty_one_percent\n        # if qty < 1:\n        #     qty = 1\n        #     print_status(\"Decision QTY Handler - QTY MODE\", f\"Warning, qty reset to: {qty}, please check the trading settings\", \"WARNING\")\n        # qty reset deleted, choose to strictly follow the position percentage\n        print_status(\"Decision QTY Handler - QTY MODE\",\n                     f\"Decision, qty is {qty}, please check the trading settings\",\n                     \"INFO\")\n        return qty, position_pct\n\n    else:\n        print_status(\"Decision QTY Handler\",\n                     f\"Warning, wrong decision mode, qty is 0, please check the trading settings\",\n                     \"WARNING\")\n        return 0, position_pct\n"}
{"type": "source_file", "path": "utils/logger_config.py", "content": "import logging\nimport sys\nfrom datetime import datetime\nimport os\nfrom logging.handlers import RotatingFileHandler\n\n# Create logs directory if it doesn't exist\nos.makedirs('./logs', exist_ok=True)\n\n# Define custom formatter\n\n\nclass CustomFormatter(logging.Formatter):\n    grey = \"\\x1b[38;21m\"\n    blue = \"\\x1b[34;21m\"\n    yellow = \"\\x1b[33;21m\"\n    red = \"\\x1b[31;21m\"\n    bold_red = \"\\x1b[31;1m\"\n    reset = \"\\x1b[0m\"\n\n    format_str = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n\n    FORMATS = {\n        logging.DEBUG: grey + format_str + reset,\n        logging.INFO: blue + format_str + reset,\n        logging.WARNING: yellow + format_str + reset,\n        logging.ERROR: red + format_str + reset,\n        logging.CRITICAL: bold_red + format_str + reset\n    }\n\n    def format(self, record):\n        log_fmt = self.FORMATS.get(record.levelno)\n        formatter = logging.Formatter(log_fmt, datefmt='%Y-%m-%d %H:%M:%S')\n        return formatter.format(record)\n\n\ndef setup_logger(name):\n    # Create logger\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.DEBUG)\n\n    # Prevent duplicate handlers\n    if logger.handlers:\n        return logger\n\n    # Create console handler\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(logging.DEBUG)\n    console_handler.setFormatter(CustomFormatter())\n\n    # Create rotating file handler instead of regular file handler\n    log_file = os.path.join(\n        './logs', f'{name}_{datetime.now().strftime(\"%Y%m%d\")}.log')\n    file_handler = RotatingFileHandler(\n        log_file,\n        maxBytes=10*1024*1024,  # 10MB max file size\n        backupCount=5  # Keep 5 backup files\n    )\n    file_handler.setLevel(logging.DEBUG)\n    file_handler.setFormatter(logging.Formatter(\n        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S'\n    ))\n\n    # Add handlers to logger\n    logger.addHandler(console_handler)\n    logger.addHandler(file_handler)\n\n    return logger\n"}
{"type": "source_file", "path": "utils/time_tool.py", "content": "import datetime\nimport pytz\n\n\ndef is_market_hours():\n    # current_time = datetime.datetime.now().time()\n    # market_open_time = datetime.time(9, 30)  # Regular market open time (9:30 AM)\n    # market_close_time = datetime.time(16, 0)  # Regular market close time (4:00 PM)\n    #\n    # if market_open_time <= current_time <= market_close_time:\n    #     return True\n    # else:\n    #     return False\n\n    # Sync the time zone with US Eastern Time.\n    # Define the US Eastern Time zone\n    # Get US Eastern timezone\n    et_tz = pytz.timezone('America/New_York')\n\n    # Get current time in ET\n    current_et = datetime.datetime.now(et_tz)\n    current_et_time = current_et.time()\n\n    # Define market hours in ET\n    market_open_time = datetime.datetime.strptime('09:30', '%H:%M').time()\n    market_close_time = datetime.datetime.strptime('16:00', '%H:%M').time()\n\n    # Check if within market hours\n    return market_open_time <= current_et_time <= market_close_time\n\n\ndef is_market_and_extended_hours():\n    # Get US Eastern timezone\n    et_tz = pytz.timezone('America/New_York')\n\n    # Get current time in ET\n    current_et = datetime.datetime.now(et_tz)\n    current_et_time = current_et.time()\n\n    trade_open_time = datetime.time(4, 0)  # Regular market open time (4:00 AM)\n    trade_close_time = datetime.time(20, 0)  # Regular market close time (20:00 PM)\n\n    if trade_open_time <= current_et_time <= trade_close_time:\n        return True\n    return False\n\n\ndef get_current_time():\n    current_time = datetime.datetime.now()\n    formatted_time = current_time.strftime('%Y-%m-%d %H:%M:%S') + ' ' + f'{current_time.microsecond // 1000:03d} ms'\n    return formatted_time\n"}
{"type": "source_file", "path": "utils/wall_api_client.py", "content": "import websockets\nfrom websockets.exceptions import ConnectionClosed\n# noinspection PyUnresolvedReferences\nfrom websockets.exceptions import InvalidMessage, InvalidStatusCode\nimport asyncio\nimport json\nimport requests\nfrom typing import Callable, Optional, Tuple\nimport os\nfrom requests.exceptions import ConnectionError, Timeout\nimport time\n\nfrom utils.logger_config import setup_logger\n\n# Create logs directory if it doesn't exist\nos.makedirs('./logs', exist_ok=True)\n\n# Setup logger\nlogger = setup_logger('wall_api_client')\n\n# Terminal output formatting\n\n\nclass TerminalColors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n\n\ndef print_status(source: str, message: str, status: str = \"INFO\"):\n    \"\"\"Format and print status messages to terminal\"\"\"\n    color = {\n        \"INFO\": TerminalColors.OKBLUE,\n        \"SUCCESS\": TerminalColors.OKGREEN,\n        \"WARNING\": TerminalColors.WARNING,\n        \"ERROR\": TerminalColors.FAIL\n    }.get(status, TerminalColors.OKBLUE)\n\n    print(\n        f\"{color}[{status}] {TerminalColors.BOLD}{source}: {TerminalColors.ENDC}{message}\")\n\n\nclass DataClient:\n    def __init__(self, server_url: str, client_id: str, password: str):\n        self.server_url = server_url.rstrip('/')\n        self.ws_url = server_url.replace('http', 'ws') + '/ws'\n        self.client_id = client_id\n        self.password = password\n        self.token: Optional[str] = None\n        self.running = False\n        self.ws: Optional[websockets.WebSocketClientProtocol] = None\n        self.reconnect_attempts = 0\n        self.max_reconnect_attempts = 5\n        self.base_retry_delay = 5  # Base delay in seconds\n        self.max_retry_delay = 1800  # Maximum delay (30 minutes)\n        self.retry_count = 0  # Track retry attempts\n        self.max_retries = 10  # Maximum number of retries before giving up\n        self.max_auth_retries = 3\n        self.auth_retry_count = 0\n        self.auth_required = False  # New flag to track if re-auth is needed\n        self.max_server_check_retries = 5  # New attribute for server check retries\n        self.server_check_count = 0  # New counter for server checks\n        self.ping_interval = 30  # Increase ping interval (seconds)\n        self.ping_timeout = 10   # Ping timeout (seconds)\n        self.heartbeat_failed_count = 0\n        self.max_heartbeat_failures = 3\n        self.last_ping_time = 0  # Track last successful ping time\n        # Time to wait before starting health checks\n        self.connection_stabilization_time = 5\n        print_status(\n            \"DataClient\", f\"Initialized for client {client_id}\", \"INFO\")\n        logger.info(\n            f\"DataClient initialized for {client_id} with server URL: {server_url}\")\n\n    async def check_server_status(self) -> Tuple[bool, str]:\n        \"\"\"Check if the server is online and responding\"\"\"\n        try:\n            logger.debug(f\"Checking server status at {self.server_url}\")\n            response = requests.get(\n                f\"{self.server_url}/\",\n                timeout=5\n            )\n            if response.status_code == 200:\n                self.server_check_count = 0\n                logger.info(\n                    \"Server status check: Server is online and responding\")\n                return True, \"Server is online\"\n            logger.warning(\n                f\"Server returned unexpected status code: {response.status_code}\")\n            return False, f\"Server returned status code: {response.status_code}\"\n        except ConnectionError:\n            logger.error(\n                \"Server connection failed: Server is offline or unreachable\")\n            return False, \"Server is offline or unreachable\"\n        except Timeout:\n            logger.error(\"Server request timed out: Server is not responding\")\n            return False, \"Server is not responding (timeout)\"\n        except Exception as e:\n            logger.error(f\"Unexpected error during server check: {str(e)}\")\n            return False, f\"Error checking server status: {str(e)}\"\n\n    async def authenticate(self) -> bool:\n        \"\"\"Authenticate with server and get token\"\"\"\n        if self.auth_retry_count >= self.max_auth_retries:\n            msg = \"Maximum authentication attempts reached. Stopping client.\"\n            logger.error(msg)\n            print_status(\"Authentication\", msg, \"ERROR\")\n            self.running = False\n            return False\n\n        try:\n            logger.info(\n                f\"Attempting authentication for client {self.client_id}\")\n            print_status(\"Authentication\",\n                         \"Attempting to authenticate with server\", \"INFO\")\n\n            # Check server status first\n            is_online, status_msg = await self.check_server_status()\n            if not is_online:\n                logger.error(f\"Authentication failed: {status_msg}\")\n                print_status(\"Authentication\",\n                             f\"Failed: {status_msg}\", \"ERROR\")\n                self.auth_retry_count += 1\n                return False\n\n            response = requests.post(\n                f\"{self.server_url}/auth\",\n                json={\n                    \"client_id\": self.client_id,\n                    \"password\": self.password\n                },\n                timeout=10\n            )\n\n            if response.status_code == 200:\n                self.token = response.json()[\"access_token\"]\n                self.reconnect_attempts = 0\n                self.auth_retry_count = 0\n                self.retry_count = 0\n                logger.info(\"Authentication successful\")\n                print_status(\n                    \"Authentication\", \"Successfully authenticated with server\", \"SUCCESS\")\n                return True\n            elif response.status_code == 401:\n                msg = \"Authentication failed: Invalid credentials\"\n                logger.error(msg)\n                print_status(\"Authentication\", msg, \"ERROR\")\n                self.running = False\n                return False\n            else:\n                logger.error(\n                    f\"Authentication failed with status {response.status_code}: {response.text}\")\n                print_status(\"Authentication\",\n                             f\"Failed: {response.text}\", \"ERROR\")\n                self.auth_retry_count += 1\n                return False\n\n        except Exception as e:\n            logger.error(f\"Authentication error: {str(e)}\")\n            print_status(\"Authentication\", f\"Error: {str(e)}\", \"ERROR\")\n            self.auth_retry_count += 1\n            return False\n\n    def get_retry_delay(self) -> int:\n        \"\"\"Calculate exponential backoff delay\"\"\"\n        # Exponential backoff: base_delay * 2^retry_count\n        delay = min(\n            self.base_retry_delay * (2 ** self.retry_count),\n            self.max_retry_delay\n        )\n        logger.info(f\"Retry attempt {self.retry_count + 1}, delay: {delay}s\")\n        print_status(\"Connection\",\n                     f\"Retry attempt {self.retry_count + 1} of {self.max_retries}, waiting {delay}s\",\n                     \"INFO\")\n        return delay\n\n    async def connect(self) -> bool:\n        \"\"\"Connect to WebSocket server with authentication\"\"\"\n        try:\n            if self.retry_count >= self.max_retries:\n                msg = \"Maximum reconnection attempts reached. Requiring re-authentication.\"\n                logger.error(msg)\n                print_status(\"Connection\", msg, \"ERROR\")\n                self.token = None\n                self.auth_required = True\n                self.retry_count = 0\n                return False\n\n            if not self.token:\n                msg = \"No valid token available. Authentication required.\"\n                logger.error(msg)\n                print_status(\"Connection\", msg, \"ERROR\")\n                self.auth_required = True\n                return False\n\n            logger.info(f\"Attempting WebSocket connection to {self.ws_url}\")\n            print_status(\n                \"Connection\", \"Attempting to connect to server\", \"INFO\")\n\n            self.ws = await websockets.connect(\n                self.ws_url,\n                ping_interval=self.ping_interval,\n                ping_timeout=self.ping_timeout,\n                close_timeout=10,\n                max_size=2**23,\n                user_agent_header=\"DataClient/1.0\"\n            )\n\n            # Send authentication token\n            auth_message = json.dumps({\"token\": self.token})\n            await self.ws.send(auth_message)\n            logger.debug(\"Authentication token sent\")\n\n            try:\n                response = await asyncio.wait_for(self.ws.recv(), timeout=5)\n                response_data = json.loads(response)\n\n                # Check if server indicates token expiry\n                if isinstance(response_data, dict) and response_data.get('error') == 'token_expired':\n                    logger.warning(\n                        \"Token expired, requiring re-authentication\")\n                    self.token = None\n                    self.auth_required = True\n                    return False\n\n                logger.info(\n                    f\"Server response after authentication: {response}\")\n                self.heartbeat_failed_count = 0\n                self.last_ping_time = time.time()\n            except asyncio.TimeoutError:\n                logger.warning(\n                    \"No response after authentication (this might be normal)\")\n            except json.JSONDecodeError:\n                logger.warning(\"Invalid response format from server\")\n\n            await asyncio.sleep(self.connection_stabilization_time)\n            self.retry_count = 0\n            self.auth_required = False\n            logger.info(\"Successfully connected to server\")\n            print_status(\n                \"Connection\", \"Successfully connected to server\", \"SUCCESS\")\n            return True\n\n        except Exception as e:\n            error_msg = str(e)\n            if \"4000\" in error_msg or \"private use\" in error_msg:\n                logger.warning(\n                    \"Server indicated authentication issue, will re-authenticate\")\n                self.token = None\n                self.auth_required = True\n                return False\n\n            logger.error(f\"Connection failed: {error_msg}\")\n            print_status(\"Connection\", f\"Failed: {error_msg}\", \"ERROR\")\n            self.retry_count += 1\n            return False\n\n    async def check_connection_health(self) -> bool:\n        \"\"\"Check if connection is healthy using ping/pong\"\"\"\n        try:\n            if not self.ws:\n                return False\n\n            # Add timeout to ping\n            pong_waiter = None\n            try:\n                pong_waiter = await asyncio.wait_for(\n                    self.ws.ping(),\n                    timeout=self.ping_timeout\n                )\n                await pong_waiter\n                self.heartbeat_failed_count = 0\n                self.last_ping_time = time.time()\n                return True\n            except (asyncio.TimeoutError, asyncio.InvalidStateError,\n                    ConnectionClosed, AttributeError) as e:\n                self.heartbeat_failed_count += 1\n\n                # Special handling for server restart\n                if isinstance(e, ConnectionClosed) and e.code == 1012:\n                    logger.info(\"Server restart detected during health check\")\n                    self.heartbeat_failed_count = self.max_heartbeat_failures\n                    return False\n\n                logger.debug(\n                    f\"Heartbeat check failed ({self.heartbeat_failed_count}/3): {str(e)}\")\n                if self.heartbeat_failed_count >= self.max_heartbeat_failures:\n                    logger.warning(\"Multiple heartbeat failures detected \"\n                                   f\"({self.heartbeat_failed_count} failures)\")\n                    return False\n                return True\n            finally:\n                if pong_waiter and not pong_waiter.done():\n                    try:\n                        pong_waiter.cancel()\n                    except Exception:\n                        pass\n\n        except Exception as e:\n            logger.error(f\"Error in connection health check: {str(e)}\")\n            self.heartbeat_failed_count += 1\n            return False\n\n    def should_log_error(self, error_msg: str) -> bool:\n        \"\"\"Rate limit error logging\"\"\"\n        current_time = time.time()\n        if (current_time - self.last_error_time) >= self.error_log_interval:\n            self.last_error_time = current_time\n            return True\n        return False\n\n    async def listen(self, callback: Callable[[dict], None]):\n        \"\"\"Listen for data from server\"\"\"\n        self.running = True\n        self.server_check_count = 0\n\n        while self.running:\n            try:\n                # Check if authentication is needed\n                if self.auth_required or not self.token:\n                    logger.info(\"Re-authentication required\")\n                    is_online, status_msg = await self.check_server_status()\n                    if not is_online:\n                        self.server_check_count += 1\n                        if self.server_check_count >= self.max_server_check_retries:\n                            logger.error(\n                                \"Maximum server check attempts reached. Stopping client.\")\n                            print_status(\"Client\",\n                                         \"Maximum server check attempts reached. Stopping client.\",\n                                         \"ERROR\")\n                            self.running = False\n                            return\n\n                        logger.error(f\"Server is not available: {status_msg}\")\n                        print_status(\"Server Check\",\n                                     f\"Server not available: {status_msg}\",\n                                     \"ERROR\")\n                        await asyncio.sleep(self.get_retry_delay())\n                        continue\n\n                    # Reset counters when server is available\n                    self.server_check_count = 0\n                    self.retry_count = 0  # Reset retry count for fresh authentication\n\n                    if not await self.authenticate():\n                        if self.auth_retry_count >= self.max_auth_retries:\n                            logger.error(\n                                \"Maximum authentication attempts reached. Stopping client.\")\n                            print_status(\"Authentication\",\n                                         \"Maximum attempts reached. Stopping client.\",\n                                         \"ERROR\")\n                            self.running = False\n                            return\n                        await asyncio.sleep(self.get_retry_delay())\n                        continue\n\n                if not self.ws:\n                    if not await self.connect():\n                        if self.auth_required:\n                            continue\n                        await asyncio.sleep(self.get_retry_delay())\n                        continue\n\n                while self.running and self.ws:\n                    try:\n                        # Periodically check connection health\n                        if not await self.check_connection_health():\n                            logger.warning(\n                                \"Connection health check failed, reconnecting...\")\n                            try:\n                                await self.ws.close(code=1001)  # Going away\n                            except Exception:\n                                pass  # Ignore errors during close\n                            self.ws = None\n                            self.heartbeat_failed_count = 0  # Reset counter\n                            break\n\n                        try:\n                            message = await asyncio.wait_for(\n                                self.ws.recv(),\n                                timeout=self.ping_interval\n                            )\n\n                            # Reset heartbeat counter on successful message receipt\n                            self.heartbeat_failed_count = 0\n                            self.last_ping_time = time.time()\n\n                            data = json.loads(message)\n                            await self.handle_message(callback, data)\n\n                        except asyncio.TimeoutError:\n                            continue\n                        except json.JSONDecodeError:\n                            logger.error(\"Invalid message format\")\n                            continue\n                        except Exception as e:\n                            if \"ping timeout\" in str(e).lower() or \"keepalive\" in str(e).lower():\n                                self.ws = None\n                                break\n                            logger.warning(f\"Error processing message: {e}\")\n                            continue\n\n                    except Exception as e:\n                        logger.error(f\"Connection loop error: {str(e)}\")\n                        self.ws = None\n                        break\n\n            except ConnectionClosed as e:\n                if not self.running:\n                    return\n                if self.should_log_error(f\"Connection closed ({e.code})\"):\n                    logger.warning(f\"Connection closed ({e.code}): {e.reason}\")\n                await self.handle_connection_closed(e)\n\n            except Exception as e:\n                if not self.running:\n                    return\n                if self.should_log_error(str(e)):\n                    logger.error(f\"Unexpected error: {e}\")\n                self.ws = None\n                await asyncio.sleep(self.get_retry_delay())\n\n    async def handle_message(self, callback: Callable[[dict], None], data: dict):\n        \"\"\"Handle incoming messages with error handling\"\"\"\n        try:\n            logger.debug(f\"Processing received message: {data}\")\n            callback(data)\n            logger.debug(\"Message processed successfully\")\n        except Exception as e:\n            logger.error(f\"Error in message handler: {str(e)}\")\n            print_status(\"Message Handler\",\n                         f\"Error processing message: {str(e)}\", \"ERROR\")\n\n    async def handle_connection_closed(self, e: ConnectionClosed):\n        \"\"\"Handle different connection closed scenarios\"\"\"\n        if e.code == 1012:  # Service Restart\n            logger.info(\"Server is restarting, will attempt to reconnect...\")\n            print_status(\"Connection\",\n                         \"Server is restarting, will attempt to reconnect...\",\n                         \"WARNING\")\n            # Reset counters for clean reconnection\n            self.heartbeat_failed_count = 0\n            self.retry_count = 0\n            await asyncio.sleep(5)  # Give server time to restart\n            return\n\n        elif e.code == 4000:  # Private use (usually auth issues)\n            logger.warning(\"Server indicated authentication issue\")\n            self.token = None\n            self.auth_required = True\n            self.retry_count = 0  # Reset retry count for re-auth\n            return\n\n        elif e.code == 1001:  # Going away\n            logger.info(\"Connection closing due to health check failure\")\n            self.retry_count += 1\n\n        elif e.code == 1011:  # Internal error (usually ping timeout)\n            logger.warning(\n                \"Connection ping timeout, will attempt to reconnect\")\n            self.retry_count += 1\n            self.ws = None\n            await asyncio.sleep(self.get_retry_delay())\n            return\n\n        elif e.code == 1000:  # Normal closure\n            logger.info(\"Connection closed normally\")\n\n        elif e.code == 4001:  # Authentication error\n            logger.error(\"Authentication failed, clearing token\")\n            self.token = None\n\n        else:\n            logger.warning(f\"Connection closed with code {e.code}\")\n\n        await asyncio.sleep(self.get_retry_delay())\n\n    async def close(self):\n        \"\"\"Gracefully close the connection\"\"\"\n        logger.info(\"Initiating graceful shutdown\")\n        print_status(\"Shutdown\", \"Initiating graceful shutdown\", \"INFO\")\n        self.running = False\n\n        if self.ws:\n            try:\n                await self.ws.close()\n                logger.info(\"WebSocket connection closed gracefully\")\n                print_status(\n                    \"Shutdown\", \"Connection closed gracefully\", \"SUCCESS\")\n            except Exception as e:\n                logger.error(f\"Error during connection closure: {str(e)}\")\n                print_status(\n                    \"Shutdown\", f\"Error closing connection: {str(e)}\", \"ERROR\")\n\n        logger.info(\"Shutdown complete\")\n        print_status(\"Shutdown\", \"Complete\", \"SUCCESS\")\n\n    def stop(self):\n        \"\"\"Stop listening and close connection\"\"\"\n        self.running = False\n        if self.ws:\n            logger.info(\"Closing connection...\")\n            asyncio.create_task(self.close())\n"}
{"type": "source_file", "path": "utils/schwab-generate-token.py", "content": "import argparse\nimport sys\nimport schwab\nfrom importlib.util import spec_from_file_location, module_from_spec\nfrom pathlib import Path\n\n\ndef load_secrets():\n    \"\"\"Dynamically load secrets from _secrete.py\"\"\"\n    secrete_path = Path(\"./env/_secrete.py\")\n    try:\n        spec = spec_from_file_location(\"secrets\", secrete_path)\n        module = module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return module.Schwab_app_key, module.Schwab_secret\n    except Exception as e:\n        raise ImportError(f\"Failed to load secret file: {e}\")\n\n\ndef main(app_key, secret, callback_url, token_path):\n    try:\n        schwab.auth.client_from_manual_flow(app_key, secret, callback_url, token_path)\n        print(\"\\nToken successfully generated and written to file!\")\n        return 0\n    except Exception as e:\n        print(f\"\\nAn error occurred: {e}\")\n        return 1\n\n\nif __name__ == '__main__':\n    try:\n        default_app_key, default_secret = load_secrets()\n    except Exception as e:\n        default_app_key = None\n        default_secret = None\n        print(f\"Warning: {e}\")\n\n    parser = argparse.ArgumentParser(\n        description='Fetch a new token and write it to a file',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n\n    required = parser.add_argument_group('required arguments')\n    required.add_argument('--app_key',\n                          default=default_app_key,\n                          required=default_app_key is None,\n                          help='Schwab App Key (default loads from ./env/_secrete.py)')\n    required.add_argument('--secret',\n                          default=default_secret,\n                          required=default_secret is None,\n                          help='Schwab Secret (default loads from ./env/_secrete.py)')\n    required.add_argument('--callback_url',\n                          default=\"https://127.0.0.1:8182\",\n                          help='Callback URL')\n    required.add_argument('--token_file',\n                          default=\"./env/_schwab_token.json\",\n                          help='Path to save token file')\n\n    args = parser.parse_args()\n\n    if not args.app_key or not args.secret:\n        parser.error(\"API key and app secret must be provided (via defaults or command line)\")\n\n    sys.exit(main(args.app_key, args.secret, args.callback_url, args.token_file))\n"}
{"type": "source_file", "path": "trading_settings.py", "content": "# Description: This file contains the settings for trading.\n\n\n\"\"\" Step 1: !!! Important. Set up the broker name !!! \"\"\"\nTRADING_BROKER = 'LONGPORT'  # set up the broker name based on the broker class name\n\"\"\"\n'IBKR': IBKRBroker,\n'WEBULL': WebullBroker,\n'MooMoo': MooMooFutuBroker,\n'Futu': MooMooFutuBroker,\n'SCHWAB': SchwabBroker,\n'TIGER': TigerBroker,\n'LONGPORT': LongPortBroker\n\"\"\"\n\n\n\"\"\" Step 2: !!! Important. Please choose qty decision mode, revise qty setting for each stock !!! \"\"\"\n# Option 1: FUND_MODE, calculate the trading quantity based on the initial fund\nFUND_MODE = True  # default to True, set to False if you want to use fixed qty\nINITIAL_FUND_FOR_TQQQ = 1  # default to 1, set the initial trading fund for tqqq, it will be used for qty calculation\nINITIAL_FUND_FOR_SOXL = 1  # default to 1, set the initial trading fund for soxl, it will be used for qty calculation\nINITIAL_FUND_FOR_IBIT = 1  # default to 1, set the initial trading fund for ibit, it will be used for qty calculation\n\n# Option 2: QTY_MODE, calculate the trading quantity based on the fixed qty\nQTY_MODE = False  # default to False, set to True if you want to use fixed qty\nONE_PERCENT_TRADING_QTY_FOR_TQQQ = 1  # default to 1, set the trading quantity for 1% of the initial fund\nONE_PERCENT_TRADING_QTY_FOR_SOXL = 1  # default to 1, set the trading quantity for 1% of the initial fund\nONE_PERCENT_TRADING_QTY_FOR_IBIT = 1  # default to 1, set the trading quantity for 1% of the initial fund\n\n\n\"\"\" Step 3: !!! Important. Please choose which level and which ticker you want to trade !!! \"\"\"\nTRADING_LIST = ['TQQQ', 'SOXL', 'IBIT']  # set the trading list, delete the stock if you don't want to trade\nTRADING_LEVEL = ['L0', 'L1', 'L2', 'L3', 'L4']  # set the trading level, delete the level if you don't want to trade\n\n\n\"\"\" Please don't change the code below, unless you know what you are doing \"\"\"\n\n\"\"\" (Optional): Account settings, don't change the default setting unless you know what you are doing \"\"\"\nTRADING_CONFIRMATION = True  # default to True, set to False if you want to stop trading\nTRADING_CASH_THRESHOLD = 1  # set the minimum cash balance requirement after each trade\nTRADING_CASH_MARGIN_CONTROL = True  # default to True, set to False if you want to use margin or bypass the cash check\nTRADING_ALLOW_PRE_POST_MARKET_ORDER = True  # default to True, set to False if you don't want to trade in pre/post market\n\n\n\n\"\"\" (Optional): 1. Specific trading direction control settings \"\"\"\n# buy side\nENABLE_BUY_TQQQ = True  # default to True, set to False if you don't want to buy TQQQ\nENABLE_BUY_SOXL = True  # default to True, set to False if you don't want to buy SOXL\nENABLE_BUY_IBIT = True  # default to True, set to False if you don't want to buy IBIT\n# sell side\nENABLE_SELL_TQQQ = True  # default to True, set to False if you don't want to sell TQQQ\nENABLE_SELL_SOXL = True  # default to True, set to False if you don't want to sell SOXL\nENABLE_SELL_IBIT = True  # default to True, set to False if you don't want to sell IBIT\n\n\"\"\" (Optional): 2. Specific Trading Control Settings: Level, Depth, CodeNum \"\"\"\n# this is the default setting, which corresponds to the trading strategy for WallTrading Bot\n# please don't change the default setting, unless you know what you are doing\n# please contact the dev team for any questions\n# trading position control per stock ticker:\n\nBind_Depth_codeNum = False  # Default to False, set to True if you want to bind the depth and codeNum\n\nLEVEL_POSITIONS_TQQQ = {\n    0: {  # L0\n        'depth': {0: 0.01, 1: 0.01, 2: 0.01, 3: 0.00, 4: 0.00, 5: 0.02, 6: 0.02, 7: 0.03, 8: 0.04, 9: 0.04, 10: 0.05},\n        'code': {3: 0.02},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    1: {  # L1\n        'depth': {0: 0.01, 1: 0.01, 2: 0.01, 3: 0.00, 4: 0.00, 5: 0.02, 6: 0.02, 7: 0.03, 8: 0.04, 9: 0.04, 10: 0.05},\n        'code': {3: 0.03},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    2: {  # L2\n        'depth': {0: 0.02, 1: 0.02, 2: 0.02, 3: 0.00, 4: 0.00, 5: 0.00, 6: 0.04, 7: 0.04, 8: 0.05, 9: 0.06, 10: 0.07},\n        'code': {3: 0.04},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    3: {  # L3\n        'depth': {0: 0.03, 1: 0.03, 2: 0.03, 3: 0.04, 4: 0.08, 5: 0.00, 6: 0.00, 7: 0.00, 8: 0.00, 9: 0.00, 10: 0.00},\n        'code': {3: 0.08},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    4: {  # L4\n        'depth': {0: 0.15, 1: 0.22, 2: 0.22, 3: 0.25, 4: 0.25, 5: 0.00, 6: 0.00, 7: 0.00, 8: 0.00, 9: 0.00, 10: 0.00},\n        'code': {3: 0.22},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    }\n}\n\n\nLEVEL_POSITIONS_SOXL = {\n    0: {  # L0\n        'depth': {0: 0.01, 1: 0.01, 2: 0.01, 3: 0.00, 4: 0.00, 5: 0.02, 6: 0.02, 7: 0.03, 8: 0.04, 9: 0.04, 10: 0.05},\n        'code': {3: 0.02},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    1: {  # L1\n        'depth': {0: 0.01, 1: 0.01, 2: 0.01, 3: 0.00, 4: 0.00, 5: 0.02, 6: 0.02, 7: 0.03, 8: 0.04, 9: 0.04, 10: 0.05},\n        'code': {3: 0.03},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    2: {  # L2\n        'depth': {0: 0.02, 1: 0.02, 2: 0.02, 3: 0.00, 4: 0.00, 5: 0.00, 6: 0.04, 7: 0.04, 8: 0.05, 9: 0.06, 10: 0.07},\n        'code': {3: 0.04},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    3: {  # L3\n        'depth': {0: 0.03, 1: 0.03, 2: 0.03, 3: 0.04, 4: 0.08, 5: 0.00, 6: 0.00, 7: 0.00, 8: 0.00, 9: 0.00, 10: 0.00},\n        'code': {3: 0.08},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    4: {  # L4\n        'depth': {0: 0.15, 1: 0.22, 2: 0.22, 3: 0.25, 4: 0.25, 5: 0.00, 6: 0.00, 7: 0.00, 8: 0.00, 9: 0.00, 10: 0.00},\n        'code': {3: 0.22},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    }\n}\n\n\nLEVEL_POSITIONS_IBIT = {\n    0: {  # L0\n        'depth': {0: 0.01, 1: 0.01, 2: 0.01, 3: 0.00, 4: 0.00, 5: 0.02, 6: 0.02, 7: 0.03, 8: 0.04, 9: 0.04, 10: 0.05},\n        'code': {3: 0.02},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    1: {  # L1\n        'depth': {0: 0.01, 1: 0.01, 2: 0.01, 3: 0.00, 4: 0.00, 5: 0.02, 6: 0.02, 7: 0.03, 8: 0.04, 9: 0.04, 10: 0.05},\n        'code': {3: 0.03},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    2: {  # L2\n        'depth': {0: 0.02, 1: 0.02, 2: 0.02, 3: 0.00, 4: 0.00, 5: 0.00, 6: 0.04, 7: 0.04, 8: 0.05, 9: 0.06, 10: 0.07},\n        'code': {3: 0.04},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    3: {  # L3\n        'depth': {0: 0.03, 1: 0.03, 2: 0.03, 3: 0.04, 4: 0.08, 5: 0.00, 6: 0.00, 7: 0.00, 8: 0.00, 9: 0.00, 10: 0.00},\n        'code': {3: 0.08},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    4: {  # L4\n        'depth': {0: 0.15, 1: 0.22, 2: 0.22, 3: 0.25, 4: 0.25, 5: 0.00, 6: 0.00, 7: 0.00, 8: 0.00, 9: 0.00, 10: 0.00},\n        'code': {3: 0.22},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    }\n}\n\n\nLEVEL_POSITIONS_DEFAULT = {\n    0: {  # L0\n        'depth': {0: 0.01, 1: 0.01, 2: 0.01, 3: 0.00, 4: 0.00, 5: 0.02, 6: 0.02, 7: 0.03, 8: 0.04, 9: 0.04, 10: 0.05},\n        'code': {3: 0.02},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    1: {  # L1\n        'depth': {0: 0.01, 1: 0.01, 2: 0.01, 3: 0.00, 4: 0.00, 5: 0.02, 6: 0.02, 7: 0.03, 8: 0.04, 9: 0.04, 10: 0.05},\n        'code': {3: 0.03},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    2: {  # L2\n        'depth': {0: 0.02, 1: 0.02, 2: 0.02, 3: 0.00, 4: 0.00, 5: 0.00, 6: 0.04, 7: 0.04, 8: 0.05, 9: 0.06, 10: 0.07},\n        'code': {3: 0.04},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    3: {  # L3\n        'depth': {0: 0.03, 1: 0.03, 2: 0.03, 3: 0.04, 4: 0.08, 5: 0.00, 6: 0.00, 7: 0.00, 8: 0.00, 9: 0.00, 10: 0.00},\n        'code': {3: 0.08},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    },\n    4: {  # L4\n        'depth': {0: 0.15, 1: 0.22, 2: 0.22, 3: 0.25, 4: 0.25, 5: 0.00, 6: 0.00, 7: 0.00, 8: 0.00, 9: 0.00, 10: 0.00},\n        'code': {3: 0.22},\n        'enable': True  # default to True, set to False if you don't want to trade at this level\n    }\n}\n"}

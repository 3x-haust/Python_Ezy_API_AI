{"repo_info": {"repo_name": "fastapi-clean-architecture", "repo_owner": "jujumilk3", "repo_url": "https://github.com/jujumilk3/fastapi-clean-architecture"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/conftest.py", "content": "import json\nimport os\n\nimport pytest\n\nos.environ[\"ENV\"] = \"test\"\n\nif os.getenv(\"ENV\") not in [\"test\"]:\n    msg = f\"ENV is not test, it is {os.getenv('ENV')}\"\n    pytest.exit(msg)\n\nfrom fastapi.testclient import TestClient\nfrom loguru import logger\nfrom sqlmodel import SQLModel, create_engine\n\nfrom app.core.config import configs\nfrom app.core.container import Container\nfrom app.main import AppCreator\nfrom app.model.post import Post\nfrom app.model.user import User\n\n\ndef insert_default_data(conn):\n    user_default_file = open(\"./tests/test_data/users.json\", \"r\")\n    user_default_data = json.load(user_default_file)\n    for user in user_default_data:\n        conn.execute(\n            User.__table__.insert(),\n            {\n                \"email\": user[\"email\"],\n                \"password\": user[\"password\"],\n                \"user_token\": user[\"user_token\"],\n                \"name\": user[\"name\"],\n                \"is_active\": user[\"is_active\"],\n                \"is_superuser\": user[\"is_superuser\"],\n            },\n        )\n    post_default_file = open(\"./tests/test_data/posts.json\", \"r\")\n    post_default_data = json.load(post_default_file)\n    for post in post_default_data:\n        conn.execute(\n            Post.__table__.insert(),\n            {\n                \"title\": post[\"title\"],\n                \"content\": post[\"content\"],\n                \"user_token\": post[\"user_token\"],\n                \"is_published\": post[\"is_published\"],\n            },\n        )\n\n\ndef reset_db():\n    engine = create_engine(configs.DATABASE_URI)\n    logger.info(engine)\n    with engine.begin() as conn:\n        if \"test\" in configs.DATABASE_URI:\n            SQLModel.metadata.drop_all(conn)\n            SQLModel.metadata.create_all(conn)\n            insert_default_data(conn)\n        else:\n            raise Exception(\"Not in test environment\")\n    return engine\n\n\n@pytest.fixture\ndef client():\n    reset_db()\n    app_creator = AppCreator()\n    app = app_creator.app\n    with TestClient(app) as client:\n        yield client\n\n\n@pytest.fixture\ndef container():\n    return Container()\n\n\n@pytest.fixture\ndef test_name(request):\n    return request.node.name\n"}
{"type": "test_file", "path": "tests/unit_tests/test_fixture.py", "content": "def test_test_name_fixture(test_name):\n    assert test_name == \"test_test_name_fixture\"\n"}
{"type": "test_file", "path": "tests/unit_tests/test_container.py", "content": "from app.core.exceptions import NotFoundError\n\n\n# It must raise an error\ndef test_container_with_intended_exception(container):\n    auth_service = container.auth_service()\n    try:\n        found_user = auth_service.get_by_id(1)\n    except NotFoundError as e:\n        assert True\n        return\n    # assert False\n"}
{"type": "test_file", "path": "tests/integration_tests/test_auth_router.py", "content": "def test_sign_up_and_sign_in(client):\n    response = client.post(\n        \"/api/v1/auth/sign-up\",\n        json={\"email\": \"test\", \"password\": \"test\", \"name\": \"test\"},\n    )\n    assert response.status_code == 200\n    response_json = response.json()\n    assert response_json[\"email\"] == \"test\"\n    assert response_json[\"name\"] == \"test\"\n    assert response_json[\"id\"] > 0\n    user_token = response_json[\"user_token\"]\n\n    response = client.post(\n        \"/api/v1/auth/sign-in\",\n        json={\"email__eq\": \"test\", \"password\": \"test\"},\n    )\n\n    assert response.status_code == 200\n    response_json = response.json()\n    assert response_json[\"user_info\"][\"email\"] == \"test\"\n    assert response_json[\"user_info\"][\"name\"] == \"test\"\n    assert response_json[\"user_info\"][\"id\"] > 0\n    assert response_json[\"user_info\"][\"user_token\"] == user_token\n    assert response_json[\"access_token\"] is not None\n"}
{"type": "test_file", "path": "tests/integration_tests/test_client.py", "content": "def test_client(client):\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == \"service is working\"\n"}
{"type": "source_file", "path": "app/api/v1/routes.py", "content": "from fastapi import APIRouter\n\nfrom app.api.v1.endpoints.auth import router as auth_router\nfrom app.api.v1.endpoints.post import router as post_router\nfrom app.api.v1.endpoints.tag import router as tag_router\nfrom app.api.v1.endpoints.user import router as user_router\n\nrouters = APIRouter()\nrouter_list = [auth_router, post_router, tag_router, user_router]\n\nfor router in router_list:\n    router.tags = routers.tags.append(\"v1\")\n    routers.include_router(router)\n"}
{"type": "source_file", "path": "app/api/v1/endpoints/tag.py", "content": "from dependency_injector.wiring import Provide\nfrom fastapi import APIRouter, Depends\n\nfrom app.core.container import Container\nfrom app.core.dependencies import get_current_active_user\nfrom app.core.middleware import inject\nfrom app.model.user import User\nfrom app.schema.base_schema import Blank\nfrom app.schema.post_tag_schema import FindTag, FindTagResult, Tag, UpsertTag\nfrom app.services.tag_service import TagService\n\nrouter = APIRouter(\n    prefix=\"/tag\",\n    tags=[\"tag\"],\n)\n\n\n@router.get(\"\", response_model=FindTagResult)\n@inject\ndef get_tag_list(\n    find_query: FindTag = Depends(),\n    service: TagService = Depends(Provide[Container.tag_service]),\n):\n    return service.get_list(find_query)\n\n\n@router.get(\"/{tag_id}\", response_model=Tag)\n@inject\ndef get_tag(\n    tag_id: int,\n    service: TagService = Depends(Provide[Container.tag_service]),\n):\n    return service.get_by_id(tag_id)\n\n\n@router.post(\"\", response_model=Tag)\n@inject\ndef create_tag(\n    tag: UpsertTag,\n    service: TagService = Depends(Provide[Container.tag_service]),\n    current_user: User = Depends(get_current_active_user),\n):\n    return service.add(tag)\n\n\n@router.patch(\"/{tag_id}\", response_model=Tag)\n@inject\ndef update_tag(\n    tag_id: int,\n    tag: UpsertTag,\n    service: TagService = Depends(Provide[Container.tag_service]),\n    current_user: User = Depends(get_current_active_user),\n):\n    return service.patch(tag_id, tag)\n\n\n@router.delete(\"/{tag_id}\", response_model=Blank)\n@inject\ndef delete_tag(\n    tag_id: int,\n    service: TagService = Depends(Provide[Container.tag_service]),\n    current_user: User = Depends(get_current_active_user),\n):\n    return service.remove_by_id(tag_id)\n"}
{"type": "source_file", "path": "app/model/user.py", "content": "from sqlmodel import Field\n\nfrom app.model.base_model import BaseModel\n\n\nclass User(BaseModel, table=True):\n    email: str = Field(unique=True)\n    password: str = Field()\n    user_token: str = Field(unique=True)\n\n    name: str = Field(default=None, nullable=True)\n    is_active: bool = Field(default=True)\n    is_superuser: bool = Field(default=False)\n"}
{"type": "source_file", "path": "app/core/config.py", "content": "import os\nfrom typing import List\n\nfrom dotenv import load_dotenv\nfrom pydantic import BaseSettings\n\nload_dotenv()\n\nENV: str = \"\"\n\n\nclass Configs(BaseSettings):\n    # base\n    ENV: str = os.getenv(\"ENV\", \"dev\")\n    API: str = \"/api\"\n    API_V1_STR: str = \"/api/v1\"\n    API_V2_STR: str = \"/api/v2\"\n    PROJECT_NAME: str = \"fca-api\"\n    ENV_DATABASE_MAPPER: dict = {\n        \"prod\": \"fca\",\n        \"stage\": \"stage-fca\",\n        \"dev\": \"dev-fca\",\n        \"test\": \"test-fca\",\n    }\n    DB_ENGINE_MAPPER: dict = {\n        \"postgresql\": \"postgresql\",\n        \"mysql\": \"mysql+pymysql\",\n    }\n\n    PROJECT_ROOT: str = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\n    # date\n    DATETIME_FORMAT: str = \"%Y-%m-%dT%H:%M:%S\"\n    DATE_FORMAT: str = \"%Y-%m-%d\"\n\n    # auth\n    SECRET_KEY: str = os.getenv(\"SECRET_KEY\", \"\")\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 30  # 60 minutes * 24 hours * 30 days = 30 days\n\n    # CORS\n    BACKEND_CORS_ORIGINS: List[str] = [\"*\"]\n\n    # database\n    DB: str = os.getenv(\"DB\", \"postgresql\")\n    DB_USER: str = os.getenv(\"DB_USER\")\n    DB_PASSWORD: str = os.getenv(\"DB_PASSWORD\")\n    DB_HOST: str = os.getenv(\"DB_HOST\")\n    DB_PORT: str = os.getenv(\"DB_PORT\", \"3306\")\n    DB_ENGINE: str = DB_ENGINE_MAPPER.get(DB, \"postgresql\")\n\n    DATABASE_URI_FORMAT: str = \"{db_engine}://{user}:{password}@{host}:{port}/{database}\"\n\n    DATABASE_URI = \"{db_engine}://{user}:{password}@{host}:{port}/{database}\".format(\n        db_engine=DB_ENGINE,\n        user=DB_USER,\n        password=DB_PASSWORD,\n        host=DB_HOST,\n        port=DB_PORT,\n        database=ENV_DATABASE_MAPPER[ENV],\n    )\n\n    # find query\n    PAGE = 1\n    PAGE_SIZE = 20\n    ORDERING = \"-id\"\n\n    class Config:\n        case_sensitive = True\n\n\nclass TestConfigs(Configs):\n    ENV: str = \"test\"\n\n\nconfigs = Configs()\n\nif ENV == \"prod\":\n    pass\nelif ENV == \"stage\":\n    pass\nelif ENV == \"test\":\n    setting = TestConfigs()\n"}
{"type": "source_file", "path": "app/api/v1/endpoints/auth.py", "content": "from dependency_injector.wiring import Provide\nfrom fastapi import APIRouter, Depends\n\nfrom app.core.container import Container\nfrom app.core.dependencies import get_current_active_user\nfrom app.core.middleware import inject\nfrom app.schema.auth_schema import SignIn, SignInResponse, SignUp\nfrom app.schema.user_schema import User\nfrom app.services.auth_service import AuthService\n\nrouter = APIRouter(\n    prefix=\"/auth\",\n    tags=[\"auth\"],\n)\n\n\n@router.post(\"/sign-in\", response_model=SignInResponse)\n@inject\ndef sign_in(user_info: SignIn, service: AuthService = Depends(Provide[Container.auth_service])):\n    return service.sign_in(user_info)\n\n\n@router.post(\"/sign-up\", response_model=User)\n@inject\ndef sign_up(user_info: SignUp, service: AuthService = Depends(Provide[Container.auth_service])):\n    return service.sign_up(user_info)\n\n\n@router.get(\"/me\", response_model=User)\n@inject\ndef get_me(current_user: User = Depends(get_current_active_user)):\n    return current_user\n"}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/model/post.py", "content": "from sqlmodel import Field\n\nfrom app.model.base_model import BaseModel\n\n\nclass Post(BaseModel, table=True):\n    user_token: str = Field()\n\n    title: str = Field(default=None, nullable=True)\n    content: str = Field(default=None, nullable=True)\n    is_published: bool = Field(default=False)\n"}
{"type": "source_file", "path": "app/core/dependencies.py", "content": "from dependency_injector.wiring import Provide, inject\nfrom fastapi import Depends\nfrom jose import jwt\nfrom pydantic import ValidationError\n\nfrom app.core.config import configs\nfrom app.core.container import Container\nfrom app.core.exceptions import AuthError\nfrom app.core.security import ALGORITHM, JWTBearer\nfrom app.model.user import User\nfrom app.schema.auth_schema import Payload\nfrom app.services.user_service import UserService\n\n\n@inject\ndef get_current_user(\n    token: str = Depends(JWTBearer()),\n    service: UserService = Depends(Provide[Container.user_service]),\n) -> User:\n    try:\n        payload = jwt.decode(token, configs.SECRET_KEY, algorithms=ALGORITHM)\n        token_data = Payload(**payload)\n    except (jwt.JWTError, ValidationError):\n        raise AuthError(detail=\"Could not validate credentials\")\n    current_user: User = service.get_by_id(token_data.id)\n    if not current_user:\n        raise AuthError(detail=\"User not found\")\n    return current_user\n\n\ndef get_current_active_user(current_user: User = Depends(get_current_user)) -> User:\n    if not current_user.is_active:\n        raise AuthError(\"Inactive user\")\n    return current_user\n\n\ndef get_current_user_with_no_exception(\n    token: str = Depends(JWTBearer()),\n    service: UserService = Depends(Provide[Container.user_service]),\n) -> User:\n    try:\n        payload = jwt.decode(token, configs.SECRET_KEY, algorithms=ALGORITHM)\n        token_data = Payload(**payload)\n    except (jwt.JWTError, ValidationError):\n        return None\n    current_user: User = service.get_by_id(token_data.id)\n    if not current_user:\n        return None\n    return current_user\n\n\ndef get_current_super_user(current_user: User = Depends(get_current_user)) -> User:\n    if not current_user.is_active:\n        raise AuthError(\"Inactive user\")\n    if not current_user.is_superuser:\n        raise AuthError(\"It's not a super user\")\n    return current_user\n"}
{"type": "source_file", "path": "app/schema/auth_schema.py", "content": "from datetime import datetime\n\nfrom pydantic import BaseModel\n\nfrom app.schema.user_schema import User\n\n\nclass SignIn(BaseModel):\n    email__eq: str\n    password: str\n\n\nclass SignUp(BaseModel):\n    email: str\n    password: str\n    name: str\n\n\nclass Payload(BaseModel):\n    id: int\n    email: str\n    name: str\n    is_superuser: bool\n\n\nclass SignInResponse(BaseModel):\n    access_token: str\n    expiration: datetime\n    user_info: User\n"}
{"type": "source_file", "path": "app/core/database.py", "content": "from contextlib import AbstractContextManager, contextmanager\nfrom typing import Any, Generator\n\nfrom sqlalchemy import create_engine, orm\nfrom sqlalchemy.ext.declarative import as_declarative, declared_attr\nfrom sqlalchemy.orm import Session\n\n\n@as_declarative()\nclass BaseModel:\n    id: Any\n    __name__: str\n\n    # Generate __tablename__ automatically\n    @declared_attr\n    def __tablename__(cls) -> str:\n        return cls.__name__.lower()\n\n\nclass Database:\n    def __init__(self, db_url: str) -> None:\n        self._engine = create_engine(db_url, echo=True)\n        self._session_factory = orm.scoped_session(\n            orm.sessionmaker(\n                autocommit=False,\n                autoflush=False,\n                bind=self._engine,\n            ),\n        )\n\n    def create_database(self) -> None:\n        BaseModel.metadata.create_all(self._engine)\n\n    @contextmanager\n    def session(self) -> Generator[Any, Any, AbstractContextManager[Session]]:\n        session: Session = self._session_factory()\n        try:\n            yield session\n        except Exception:\n            session.rollback()\n            raise\n        finally:\n            session.close()\n"}
{"type": "source_file", "path": "app/api/v1/endpoints/user.py", "content": "from dependency_injector.wiring import Provide\nfrom fastapi import APIRouter, Depends\n\nfrom app.core.container import Container\nfrom app.core.dependencies import get_current_super_user\nfrom app.core.middleware import inject\nfrom app.core.security import JWTBearer\nfrom app.schema.base_schema import Blank\nfrom app.schema.user_schema import FindUser, FindUserResult, UpsertUser, User\nfrom app.services.user_service import UserService\n\nrouter = APIRouter(prefix=\"/user\", tags=[\"user\"], dependencies=[Depends(JWTBearer())])\n\n\n@router.get(\"\", response_model=FindUserResult)\n@inject\ndef get_user_list(\n    find_query: FindUser = Depends(),\n    service: UserService = Depends(Provide[Container.user_service]),\n    current_user: User = Depends(get_current_super_user),\n):\n    return service.get_list(find_query)\n\n\n@router.get(\"/{user_id}\", response_model=User)\n@inject\ndef get_user(\n    user_id: int,\n    service: UserService = Depends(Provide[Container.user_service]),\n    current_user: User = Depends(get_current_super_user),\n):\n    return service.get_by_id(user_id)\n\n\n@router.post(\"\", response_model=User)\n@inject\ndef create_user(\n    user: UpsertUser,\n    service: UserService = Depends(Provide[Container.user_service]),\n    current_user: User = Depends(get_current_super_user),\n):\n    return service.add(user)\n\n\n@router.patch(\"/{user_id}\", response_model=User)\n@inject\ndef update_user(\n    user_id: int,\n    user: UpsertUser,\n    service: UserService = Depends(Provide[Container.user_service]),\n    current_user: User = Depends(get_current_super_user),\n):\n    return service.patch(user_id, user)\n\n\n@router.delete(\"/{user_id}\", response_model=Blank)\n@inject\ndef delete_user(\n    user_id: int,\n    service: UserService = Depends(Provide[Container.user_service]),\n    current_user: User = Depends(get_current_super_user),\n):\n    return service.remove_by_id(user_id)\n"}
{"type": "source_file", "path": "app/model/base_model.py", "content": "from datetime import datetime\n\nfrom sqlmodel import Column, DateTime, Field, SQLModel, func\n\n\nclass BaseModel(SQLModel):\n    id: int = Field(primary_key=True)\n    created_at: datetime = Field(sa_column=Column(DateTime(timezone=True), default=func.now()))\n    updated_at: datetime = Field(sa_column=Column(DateTime(timezone=True), default=func.now(), onupdate=func.now()))\n"}
{"type": "source_file", "path": "app/api/v1/endpoints/post.py", "content": "from dependency_injector.wiring import Provide\nfrom fastapi import APIRouter, Depends\n\nfrom app.core.container import Container\nfrom app.core.dependencies import get_current_active_user\nfrom app.core.middleware import inject\nfrom app.model.user import User\nfrom app.schema.base_schema import Blank\nfrom app.schema.post_tag_schema import FindPost, FindPostWithTagsResult, PostWithTags, UpsertPostWithTags\nfrom app.services.post_service import PostService\n\nrouter = APIRouter(\n    prefix=\"/post\",\n    tags=[\"post\"],\n)\n\n\n@router.get(\"\", response_model=FindPostWithTagsResult)\n@inject\ndef get_post_list(\n    find_query: FindPost = Depends(),\n    service: PostService = Depends(Provide[Container.post_service]),\n):\n    return service.get_list(find_query)\n\n\n@router.get(\"/{post_id}\", response_model=PostWithTags)\n@inject\ndef get_post(\n    post_id: int,\n    service: PostService = Depends(Provide[Container.post_service]),\n):\n    return service.get_by_id(post_id)\n\n\n@router.post(\"\", response_model=PostWithTags)\n@inject\ndef create_post(\n    post: UpsertPostWithTags,\n    service: PostService = Depends(Provide[Container.post_service]),\n    current_user: User = Depends(get_current_active_user),\n):\n    post.user_token = current_user.user_token\n    return service.add(post)\n\n\n@router.patch(\"/{post_id}\", response_model=PostWithTags)\n@inject\ndef update_post(\n    post_id: int,\n    post: UpsertPostWithTags,\n    service: PostService = Depends(Provide[Container.post_service]),\n    current_user: User = Depends(get_current_active_user),\n):\n    return service.patch(post_id, post)\n\n\n@router.delete(\"/{post_id}\", response_model=Blank)\n@inject\ndef delete_post(\n    post_id: int,\n    service: PostService = Depends(Provide[Container.post_service]),\n    current_user: User = Depends(get_current_active_user),\n):\n    return service.remove_by_id(post_id)\n"}
{"type": "source_file", "path": "app/core/security.py", "content": "from datetime import datetime, timedelta\nfrom typing import Tuple\n\nfrom fastapi import Request\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\nfrom jose import jwt\nfrom passlib.context import CryptContext\n\nfrom app.core.config import configs\nfrom app.core.exceptions import AuthError\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\nALGORITHM = \"HS256\"\n\n\ndef create_access_token(subject: dict, expires_delta: timedelta = None) -> Tuple[str, str]:\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=configs.ACCESS_TOKEN_EXPIRE_MINUTES)\n    payload = {\"exp\": expire, **subject}\n    encoded_jwt = jwt.encode(payload, configs.SECRET_KEY, algorithm=ALGORITHM)\n    expiration_datetime = expire.strftime(configs.DATETIME_FORMAT)\n    return encoded_jwt, expiration_datetime\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\n\ndef decode_jwt(token: str) -> dict:\n    try:\n        decoded_token = jwt.decode(token, configs.SECRET_KEY, algorithms=ALGORITHM)\n        return decoded_token if decoded_token[\"exp\"] >= int(round(datetime.utcnow().timestamp())) else None\n    except Exception as e:\n        return {}\n\n\nclass JWTBearer(HTTPBearer):\n    def __init__(self, auto_error: bool = True):\n        super(JWTBearer, self).__init__(auto_error=auto_error)\n\n    async def __call__(self, request: Request):\n        credentials: HTTPAuthorizationCredentials = await super(JWTBearer, self).__call__(request)\n        if credentials:\n            if not credentials.scheme == \"Bearer\":\n                raise AuthError(detail=\"Invalid authentication scheme.\")\n            if not self.verify_jwt(credentials.credentials):\n                raise AuthError(detail=\"Invalid token or expired token.\")\n            return credentials.credentials\n        else:\n            raise AuthError(detail=\"Invalid authorization code.\")\n\n    def verify_jwt(self, jwt_token: str) -> bool:\n        is_token_valid: bool = False\n        try:\n            payload = decode_jwt(jwt_token)\n        except Exception as e:\n            payload = None\n        if payload:\n            is_token_valid = True\n        return is_token_valid\n"}
{"type": "source_file", "path": "app/schema/post_tag_schema.py", "content": "# many to many schemas must be contained at one schema file to prevent cyclic reference\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\nfrom app.schema.base_schema import FindBase, ModelBaseInfo, SearchOptions\nfrom app.util.schema import AllOptional\n\n\nclass BasePost(BaseModel):\n    user_token: str\n    title: str\n    content: str\n    is_published: bool\n\n    class Config:\n        orm_mode = True\n\n\nclass Post(ModelBaseInfo, BasePost, metaclass=AllOptional): ...\n\n\nclass FindPost(FindBase, BasePost, metaclass=AllOptional): ...\n\n\nclass UpsertPost(BasePost, metaclass=AllOptional): ...\n\n\nclass FindPostResult(BaseModel):\n    founds: Optional[List[Post]]\n    search_options: Optional[SearchOptions]\n\n\nclass BaseTag(BaseModel):\n    user_token: str\n    name: str\n    description: str\n\n    class Config:\n        orm_mode = True\n\n\nclass Tag(ModelBaseInfo, BaseTag, metaclass=AllOptional): ...\n\n\nclass FindTag(FindBase, BaseTag, metaclass=AllOptional):\n    id__in: str\n\n\nclass UpsertTag(BaseTag, metaclass=AllOptional): ...\n\n\nclass FindTagResult(BaseModel):\n    founds: Optional[List[Tag]]\n    search_options: Optional[SearchOptions]\n\n\n# for many to many\n\n\nclass PostWithTags(Post):\n    tags: Optional[List[Tag]]\n\n\nclass TagWithPosts(Tag):\n    posts: Optional[List[Post]]\n\n\nclass UpsertPostWithTags(UpsertPost):\n    tag_ids: Optional[List[int]]\n\n\nclass UpsertTagWithPosts(UpsertTag):\n    post_ids: Optional[List[int]]\n\n\nclass FindPostWithTagsResult(BaseModel):\n    founds: Optional[List[PostWithTags]]\n    search_options: Optional[SearchOptions]\n\n\nclass FindTagWithPostsResult(BaseModel):\n    founds: Optional[List[TagWithPosts]]\n    search_options: Optional[SearchOptions]\n"}
{"type": "source_file", "path": "app/schema/base_schema.py", "content": "from datetime import datetime\nfrom typing import List, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass ModelBaseInfo(BaseModel):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n\nclass FindBase(BaseModel):\n    ordering: Optional[str]\n    page: Optional[int]\n    page_size: Optional[Union[int, str]]\n\n\nclass SearchOptions(FindBase):\n    total_count: Optional[int]\n\n\nclass FindResult(BaseModel):\n    founds: Optional[List]\n    search_options: Optional[SearchOptions]\n\n\nclass FindDateRange(BaseModel):\n    created_at__lt: str\n    created_at__lte: str\n    created_at__gt: str\n    created_at__gte: str\n\n\nclass Blank(BaseModel):\n    pass\n"}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import FastAPI\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom app.api.v1.routes import routers as v1_routers\nfrom app.api.v2.routes import routers as v2_routers\nfrom app.core.config import configs\nfrom app.core.container import Container\nfrom app.util.class_object import singleton\n\n\n@singleton\nclass AppCreator:\n    def __init__(self):\n        # set app default\n        self.app = FastAPI(\n            title=configs.PROJECT_NAME,\n            openapi_url=f\"{configs.API}/openapi.json\",\n            version=\"0.0.1\",\n        )\n\n        # set db and container\n        self.container = Container()\n        self.db = self.container.db()\n        # self.db.create_database()\n\n        # set cors\n        if configs.BACKEND_CORS_ORIGINS:\n            self.app.add_middleware(\n                CORSMiddleware,\n                allow_origins=[str(origin) for origin in configs.BACKEND_CORS_ORIGINS],\n                allow_credentials=True,\n                allow_methods=[\"*\"],\n                allow_headers=[\"*\"],\n            )\n\n        # set routes\n        @self.app.get(\"/\")\n        def root():\n            return \"service is working\"\n\n        self.app.include_router(v1_routers, prefix=configs.API_V1_STR)\n        self.app.include_router(v2_routers, prefix=configs.API_V2_STR)\n\n\napp_creator = AppCreator()\napp = app_creator.app\ndb = app_creator.db\ncontainer = app_creator.container\n"}
{"type": "source_file", "path": "app/schema/user_schema.py", "content": "from typing import List, Optional\n\nfrom pydantic import BaseModel\n\nfrom app.schema.base_schema import FindBase, ModelBaseInfo, SearchOptions\nfrom app.util.schema import AllOptional\n\n\nclass BaseUser(BaseModel):\n    email: str\n    user_token: str\n    name: str\n    is_active: bool\n    is_superuser: bool\n\n    class Config:\n        orm_mode = True\n\n\nclass BaseUserWithPassword(BaseUser):\n    password: str\n\n\nclass User(ModelBaseInfo, BaseUser, metaclass=AllOptional): ...\n\n\nclass FindUser(FindBase, BaseUser, metaclass=AllOptional):\n    email__eq: str\n    ...\n\n\nclass UpsertUser(BaseUser, metaclass=AllOptional): ...\n\n\nclass FindUserResult(BaseModel):\n    founds: Optional[List[User]]\n    search_options: Optional[SearchOptions]\n"}
{"type": "source_file", "path": "app/util/date.py", "content": "from datetime import datetime\n\nfrom pytz import timezone\n\n\ndef get_now() -> datetime:\n    return datetime.now(tz=timezone(\"UTC\"))\n"}
{"type": "source_file", "path": "app/services/user_service.py", "content": "from app.repository.user_repository import UserRepository\nfrom app.services.base_service import BaseService\n\n\nclass UserService(BaseService):\n    def __init__(self, user_repository: UserRepository):\n        self.user_repository = user_repository\n        super().__init__(user_repository)\n"}
{"type": "source_file", "path": "app/services/post_service.py", "content": "from app.repository.post_repository import PostRepository\nfrom app.repository.tag_repository import TagRepository\nfrom app.schema.post_tag_schema import FindTag, UpsertPostWithTags\nfrom app.services.base_service import BaseService\n\n\nclass PostService(BaseService):\n    def __init__(self, post_repository: PostRepository, tag_repository: TagRepository):\n        self.post_repository = post_repository\n        self.tag_repository = tag_repository\n        super().__init__(post_repository)\n\n    def add(self, schema: UpsertPostWithTags):\n        find_tag = FindTag()\n        find_tag.page_size = \"all\"\n        tags = None\n        if len(schema.tag_ids):\n            find_tag.id__in = \",\".join(map(str, schema.tag_ids))\n            tags = self.tag_repository.read_by_options(find_tag)[\"founds\"]\n        delattr(schema, \"tag_ids\")\n        return self.post_repository.create_with_tags(schema, tags)\n\n    def patch(self, id: int, schema: UpsertPostWithTags):\n        find_tag = FindTag()\n        find_tag.page_size = \"all\"\n        tags = None\n        if schema.tag_ids:\n            find_tag.id__in = \",\".join(map(str, schema.tag_ids))\n            tags = self.tag_repository.read_by_options(find_tag)[\"founds\"]\n        delattr(schema, \"tag_ids\")\n        return self.post_repository.update_with_tags(id, schema, tags)\n"}
{"type": "source_file", "path": "app/core/container.py", "content": "from dependency_injector import containers, providers\n\nfrom app.core.config import configs\nfrom app.core.database import Database\nfrom app.repository import *\nfrom app.services import *\n\n\nclass Container(containers.DeclarativeContainer):\n    wiring_config = containers.WiringConfiguration(\n        modules=[\n            \"app.api.v1.endpoints.auth\",\n            \"app.api.v1.endpoints.post\",\n            \"app.api.v1.endpoints.tag\",\n            \"app.api.v1.endpoints.user\",\n            \"app.api.v2.endpoints.auth\",\n            \"app.core.dependencies\",\n        ]\n    )\n\n    db = providers.Singleton(Database, db_url=configs.DATABASE_URI)\n\n    post_repository = providers.Factory(PostRepository, session_factory=db.provided.session)\n    tag_repository = providers.Factory(TagRepository, session_factory=db.provided.session)\n    user_repository = providers.Factory(UserRepository, session_factory=db.provided.session)\n\n    auth_service = providers.Factory(AuthService, user_repository=user_repository)\n    post_service = providers.Factory(PostService, post_repository=post_repository, tag_repository=tag_repository)\n    tag_service = providers.Factory(TagService, tag_repository=tag_repository)\n    user_service = providers.Factory(UserService, user_repository=user_repository)\n"}
{"type": "source_file", "path": "app/api/v2/endpoints/auth.py", "content": "from dependency_injector.wiring import Provide, inject\nfrom fastapi import APIRouter, Depends\n\nfrom app.core.container import Container\nfrom app.core.dependencies import get_current_active_user\nfrom app.model.user import User\nfrom app.schema.auth_schema import SignIn, SignInResponse, SignUp\nfrom app.schema.user_schema import User as UserSchema\nfrom app.services.auth_service import AuthService\n\nrouter = APIRouter(\n    prefix=\"/auth\",\n    tags=[\"auth\"],\n)\n\n\n@router.post(\"/sign-in\", response_model=SignInResponse)\n@inject\ndef sign_in(user_info: SignIn, service: AuthService = Depends(Provide[Container.auth_service])):\n    return service.sign_in(user_info)\n\n\n@router.post(\"/sign-up\", response_model=UserSchema)\n@inject\ndef sign_up(user_info: SignUp, service: AuthService = Depends(Provide[Container.auth_service])):\n    return service.sign_up(user_info)\n\n\n@router.get(\"/me\", response_model=UserSchema)\n@inject\ndef get_me(current_user: User = Depends(get_current_active_user)):\n    user = UserSchema()\n    user.name = current_user.name\n    user.email = current_user.email\n    user.created_at = current_user.created_at\n    return user\n"}
{"type": "source_file", "path": "app/repository/base_repository.py", "content": "from contextlib import AbstractContextManager\nfrom typing import Any, Callable, Type, TypeVar\n\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import Session, joinedload\n\nfrom app.core.config import configs\nfrom app.core.exceptions import DuplicatedError, NotFoundError\nfrom app.model.base_model import BaseModel\nfrom app.util.query_builder import dict_to_sqlalchemy_filter_options\n\nT = TypeVar(\"T\", bound=BaseModel)\n\n\nclass BaseRepository:\n    def __init__(self, session_factory: Callable[..., AbstractContextManager[Session]], model: Type[T]) -> None:\n        self.session_factory = session_factory\n        self.model = model\n\n    def read_by_options(self, schema: T, eager: bool = False) -> dict:\n        with self.session_factory() as session:\n            schema_as_dict: dict = schema.dict(exclude_none=True)\n            ordering: str = schema_as_dict.get(\"ordering\", configs.ORDERING)\n            order_query = (\n                getattr(self.model, ordering[1:]).desc()\n                if ordering.startswith(\"-\")\n                else getattr(self.model, ordering).asc()\n            )\n            page = schema_as_dict.get(\"page\", configs.PAGE)\n            page_size = schema_as_dict.get(\"page_size\", configs.PAGE_SIZE)\n            filter_options = dict_to_sqlalchemy_filter_options(self.model, schema.dict(exclude_none=True))\n            query = session.query(self.model)\n            if eager:\n                for eager in getattr(self.model, \"eagers\", []):\n                    query = query.options(joinedload(getattr(self.model, eager)))\n            filtered_query = query.filter(filter_options)\n            query = filtered_query.order_by(order_query)\n            if page_size == \"all\":\n                query = query.all()\n            else:\n                query = query.limit(page_size).offset((page - 1) * page_size).all()\n            total_count = filtered_query.count()\n            return {\n                \"founds\": query,\n                \"search_options\": {\n                    \"page\": page,\n                    \"page_size\": page_size,\n                    \"ordering\": ordering,\n                    \"total_count\": total_count,\n                },\n            }\n\n    def read_by_id(self, id: int, eager: bool = False):\n        with self.session_factory() as session:\n            query = session.query(self.model)\n            if eager:\n                for eager in getattr(self.model, \"eagers\", []):\n                    query = query.options(joinedload(getattr(self.model, eager)))\n            query = query.filter(self.model.id == id).first()\n            if not query:\n                raise NotFoundError(detail=f\"not found id : {id}\")\n            return query\n\n    def create(self, schema: T):\n        with self.session_factory() as session:\n            query = self.model(**schema.dict())\n            try:\n                session.add(query)\n                session.commit()\n                session.refresh(query)\n            except IntegrityError as e:\n                raise DuplicatedError(detail=str(e.orig))\n            return query\n\n    def update(self, id: int, schema: T):\n        with self.session_factory() as session:\n            session.query(self.model).filter(self.model.id == id).update(schema.dict(exclude_none=True))\n            session.commit()\n            return self.read_by_id(id)\n\n    def update_attr(self, id: int, column: str, value: Any):\n        with self.session_factory() as session:\n            session.query(self.model).filter(self.model.id == id).update({column: value})\n            session.commit()\n            return self.read_by_id(id)\n\n    def whole_update(self, id: int, schema: T):\n        with self.session_factory() as session:\n            session.query(self.model).filter(self.model.id == id).update(schema.dict())\n            session.commit()\n            return self.read_by_id(id)\n\n    def delete_by_id(self, id: int):\n        with self.session_factory() as session:\n            query = session.query(self.model).filter(self.model.id == id).first()\n            if not query:\n                raise NotFoundError(detail=f\"not found id : {id}\")\n            session.delete(query)\n            session.commit()\n\n    def close_scoped_session(self):\n        with self.session_factory() as session:\n            return session.close()\n"}
{"type": "source_file", "path": "app/core/exceptions.py", "content": "from typing import Any, Dict, Optional\n\nfrom fastapi import HTTPException, status\n\n\nclass DuplicatedError(HTTPException):\n    def __init__(self, detail: Any = None, headers: Optional[Dict[str, Any]] = None) -> None:\n        super().__init__(status.HTTP_400_BAD_REQUEST, detail, headers)\n\n\nclass AuthError(HTTPException):\n    def __init__(self, detail: Any = None, headers: Optional[Dict[str, Any]] = None) -> None:\n        super().__init__(status.HTTP_403_FORBIDDEN, detail, headers)\n\n\nclass NotFoundError(HTTPException):\n    def __init__(self, detail: Any = None, headers: Optional[Dict[str, Any]] = None) -> None:\n        super().__init__(status.HTTP_404_NOT_FOUND, detail, headers)\n\n\nclass ValidationError(HTTPException):\n    def __init__(self, detail: Any = None, headers: Optional[Dict[str, Any]] = None) -> None:\n        super().__init__(status.HTTP_422_UNPROCESSABLE_ENTITY, detail, headers)\n"}
{"type": "source_file", "path": "app/services/tag_service.py", "content": "from app.repository.tag_repository import TagRepository\nfrom app.services.base_service import BaseService\n\n\nclass TagService(BaseService):\n    def __init__(self, tag_repository: TagRepository):\n        self.tag_repository = tag_repository\n        super().__init__(tag_repository)\n"}
{"type": "source_file", "path": "app/repository/post_repository.py", "content": "from contextlib import AbstractContextManager\nfrom typing import Callable\n\nfrom sqlalchemy.orm import Session\n\nfrom app.model.post import Post\nfrom app.repository.base_repository import BaseRepository\nfrom app.schema.post_tag_schema import UpsertPostWithTags\n\n\nclass PostRepository(BaseRepository):\n    def __init__(self, session_factory: Callable[..., AbstractContextManager[Session]]):\n        self.session_factory = session_factory\n        super().__init__(session_factory, Post)\n\n    def create_with_tags(self, schema: UpsertPostWithTags, tags):\n        with self.session_factory() as session:\n            query = self.model(**schema.dict())\n            session.add(query)\n            if tags:\n                query.tags = tags\n            session.commit()\n            session.refresh(query)\n            return query\n\n    def update_with_tags(self, id: int, schema: UpsertPostWithTags, tags):\n        with self.session_factory() as session:\n            session.query(self.model).filter(self.model.id == id).update(schema.dict(exclude_none=True))\n            query = session.query(self.model).filter(self.model.id == id).first()\n            if tags:\n                query.tags = []\n                session.flush()\n                query.tags = tags\n            else:\n                query.tags = []\n            session.commit()\n            session.refresh(query)\n            return self.read_by_id(id)\n"}
{"type": "source_file", "path": "app/services/__init__.py", "content": "from app.services.auth_service import AuthService\nfrom app.services.post_service import PostService\nfrom app.services.tag_service import TagService\nfrom app.services.user_service import UserService\n"}
{"type": "source_file", "path": "app/repository/tag_repository.py", "content": "from contextlib import AbstractContextManager\nfrom typing import Callable\n\nfrom sqlalchemy.orm import Session\n\nfrom app.model.tag import Tag\nfrom app.repository.base_repository import BaseRepository\n\n\nclass TagRepository(BaseRepository):\n    def __init__(self, session_factory: Callable[..., AbstractContextManager[Session]]):\n        self.session_factory = session_factory\n        super().__init__(session_factory, Tag)\n"}
{"type": "source_file", "path": "app/repository/user_repository.py", "content": "from contextlib import AbstractContextManager\nfrom typing import Callable\n\nfrom sqlalchemy.orm import Session\n\nfrom app.model.user import User\nfrom app.repository.base_repository import BaseRepository\n\n\nclass UserRepository(BaseRepository):\n    def __init__(self, session_factory: Callable[..., AbstractContextManager[Session]]):\n        self.session_factory = session_factory\n        super().__init__(session_factory, User)\n"}
{"type": "source_file", "path": "app/services/base_service.py", "content": "from typing import Any, Protocol\n\n\nclass RepositoryProtocol(Protocol):\n    def read_by_options(self, schema: Any) -> Any: ...\n\n    def read_by_id(self, id: int) -> Any: ...\n\n    def create(self, schema: Any) -> Any: ...\n\n    def update(self, id: int, schema: Any) -> Any: ...\n\n    def update_attr(self, id: int, attr: str, value: Any) -> Any: ...\n\n    def whole_update(self, id: int, schema: Any) -> Any: ...\n\n    def delete_by_id(self, id: int) -> Any: ...\n\n\nclass BaseService:\n    def __init__(self, repository: RepositoryProtocol) -> None:\n        self._repository = repository\n\n    def get_list(self, schema: Any) -> Any:\n        return self._repository.read_by_options(schema)\n\n    def get_by_id(self, id: int) -> Any:\n        return self._repository.read_by_id(id)\n\n    def add(self, schema: Any) -> Any:\n        return self._repository.create(schema)\n\n    def patch(self, id: int, schema: Any) -> Any:\n        return self._repository.update(id, schema)\n\n    def patch_attr(self, id: int, attr: str, value: Any) -> Any:\n        return self._repository.update_attr(id, attr, value)\n\n    def put_update(self, id: int, schema: Any) -> Any:\n        return self._repository.whole_update(id, schema)\n\n    def remove_by_id(self, id: int) -> Any:\n        return self._repository.delete_by_id(id)\n\n    def close_scoped_session(self):\n        self._repository.close_scoped_session()\n"}
{"type": "source_file", "path": "app/model/post_tag.py", "content": "from sqlmodel import Field\n\nfrom app.model.base_model import BaseModel\n\n\nclass PostTag(BaseModel, table=True):\n    __tablename__ = \"post_tag\"\n    post_id: int = Field(foreign_key=\"post.id\", primary_key=True, index=True, nullable=False)\n    tag_id: int = Field(foreign_key=\"tag.id\", primary_key=True, index=True, nullable=False)\n"}
{"type": "source_file", "path": "app/core/middleware.py", "content": "from functools import wraps\n\nfrom dependency_injector.wiring import inject as di_inject\nfrom loguru import logger\n\nfrom app.services.base_service import BaseService\n\n\ndef inject(func):\n    @di_inject\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        injected_services = [arg for arg in kwargs.values() if isinstance(arg, BaseService)]\n        if len(injected_services) == 0:\n            return result\n        else:\n            try:\n                injected_services[-1].close_scoped_session()\n            except Exception as e:\n                logger.error(e)\n\n        return result\n\n    return wrapper\n"}
{"type": "source_file", "path": "app/services/auth_service.py", "content": "from datetime import timedelta\nfrom typing import List\n\nfrom app.core.config import configs\nfrom app.core.exceptions import AuthError\nfrom app.core.security import create_access_token, get_password_hash, verify_password\nfrom app.model.user import User\nfrom app.repository.user_repository import UserRepository\nfrom app.schema.auth_schema import Payload, SignIn, SignUp\nfrom app.schema.user_schema import FindUser\nfrom app.services.base_service import BaseService\nfrom app.util.hash import get_rand_hash\n\n\nclass AuthService(BaseService):\n    def __init__(self, user_repository: UserRepository):\n        self.user_repository = user_repository\n        super().__init__(user_repository)\n\n    def sign_in(self, sign_in_info: SignIn):\n        find_user = FindUser()\n        find_user.email__eq = sign_in_info.email__eq\n        user: List[User] = self.user_repository.read_by_options(find_user)[\"founds\"]\n        if len(user) < 1:\n            raise AuthError(detail=\"Incorrect email or password\")\n        found_user = user[0]\n        if not found_user.is_active:\n            raise AuthError(detail=\"Account is not active\")\n        if not verify_password(sign_in_info.password, found_user.password):\n            raise AuthError(detail=\"Incorrect email or password\")\n        delattr(found_user, \"password\")\n        payload = Payload(\n            id=found_user.id,\n            email=found_user.email,\n            name=found_user.name,\n            is_superuser=found_user.is_superuser,\n        )\n        token_lifespan = timedelta(minutes=configs.ACCESS_TOKEN_EXPIRE_MINUTES)\n        access_token, expiration_datetime = create_access_token(payload.dict(), token_lifespan)\n        sign_in_result = {\n            \"access_token\": access_token,\n            \"expiration\": expiration_datetime,\n            \"user_info\": found_user,\n        }\n        return sign_in_result\n\n    def sign_up(self, user_info: SignUp):\n        user_token = get_rand_hash()\n        user = User(**user_info.dict(exclude_none=True), is_active=True, is_superuser=False, user_token=user_token)\n        user.password = get_password_hash(user_info.password)\n        created_user = self.user_repository.create(user)\n        delattr(created_user, \"password\")\n        return created_user\n"}
{"type": "source_file", "path": "app/model/tag.py", "content": "from sqlmodel import Field\n\nfrom app.model.base_model import BaseModel\n\n\nclass Tag(BaseModel, table=True):\n    user_token: str = Field()\n\n    name: str = Field(unique=True)\n    description: str = Field(default=None, nullable=True)\n"}
{"type": "source_file", "path": "app/api/v2/routes.py", "content": "from fastapi import APIRouter\n\nfrom app.api.v2.endpoints.auth import router as auth_router\n\nrouters = APIRouter()\nrouter_list = [auth_router]\n\nfor router in router_list:\n    router.tags = routers.tags.append(\"v2\")\n    routers.include_router(router)\n"}
{"type": "source_file", "path": "app/repository/__init__.py", "content": "from app.repository.post_repository import PostRepository\nfrom app.repository.tag_repository import TagRepository\nfrom app.repository.user_repository import UserRepository\n"}
{"type": "source_file", "path": "app/util/hash.py", "content": "import uuid\n\n\ndef get_rand_hash(length: int = 16) -> str:\n    return uuid.uuid4().hex[:length]\n"}
{"type": "source_file", "path": "app/util/class_object.py", "content": "def singleton(class_):\n    instances = {}\n\n    def getinstance(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] = class_(*args, **kwargs)\n        return instances[class_]\n\n    return getinstance\n"}
{"type": "source_file", "path": "app/util/schema.py", "content": "from typing import Optional\n\nfrom pydantic.main import ModelMetaclass\n\n\nclass AllOptional(ModelMetaclass):\n    def __new__(self, name, bases, namespaces, **kwargs):\n        annotations = namespaces.get(\"__annotations__\", {})\n        for base in bases:\n            annotations.update(base.__annotations__)\n        for field in annotations:\n            if not field.startswith(\"__\"):\n                annotations[field] = Optional[annotations[field]]\n        namespaces[\"__annotations__\"] = annotations\n        return super().__new__(self, name, bases, namespaces, **kwargs)\n"}
{"type": "source_file", "path": "migrations/versions/c96507a67440_init.py", "content": "\"\"\"init\n\nRevision ID: c96507a67440\nRevises: \nCreate Date: 2022-10-02 17:35:21.037920\n\n\"\"\"\n\nimport sqlalchemy as sa\nimport sqlmodel\nfrom alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = \"c96507a67440\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"post\",\n        sa.Column(\"created_at\", sa.DateTime(timezone=True), nullable=True),\n        sa.Column(\"updated_at\", sa.DateTime(timezone=True), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"user_token\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"title\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"content\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"is_published\", sa.Boolean(), nullable=False),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_table(\n        \"tag\",\n        sa.Column(\"created_at\", sa.DateTime(timezone=True), nullable=True),\n        sa.Column(\"updated_at\", sa.DateTime(timezone=True), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"user_token\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"name\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"description\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.PrimaryKeyConstraint(\"id\"),\n        sa.UniqueConstraint(\"name\"),\n    )\n    op.create_table(\n        \"user\",\n        sa.Column(\"created_at\", sa.DateTime(timezone=True), nullable=True),\n        sa.Column(\"updated_at\", sa.DateTime(timezone=True), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"email\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"password\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"user_token\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"name\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"is_active\", sa.Boolean(), nullable=False),\n        sa.Column(\"is_superuser\", sa.Boolean(), nullable=False),\n        sa.PrimaryKeyConstraint(\"id\"),\n        sa.UniqueConstraint(\"email\"),\n        sa.UniqueConstraint(\"user_token\"),\n    )\n    op.create_table(\n        \"post_tag\",\n        sa.Column(\"created_at\", sa.DateTime(timezone=True), nullable=True),\n        sa.Column(\"updated_at\", sa.DateTime(timezone=True), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"post_id\", sa.Integer(), nullable=False),\n        sa.Column(\"tag_id\", sa.Integer(), nullable=False),\n        sa.ForeignKeyConstraint(\n            [\"post_id\"],\n            [\"post.id\"],\n        ),\n        sa.ForeignKeyConstraint(\n            [\"tag_id\"],\n            [\"tag.id\"],\n        ),\n        sa.PrimaryKeyConstraint(\"id\", \"post_id\", \"tag_id\"),\n    )\n    op.create_index(op.f(\"ix_post_tag_post_id\"), \"post_tag\", [\"post_id\"], unique=False)\n    op.create_index(op.f(\"ix_post_tag_tag_id\"), \"post_tag\", [\"tag_id\"], unique=False)\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f(\"ix_post_tag_tag_id\"), table_name=\"post_tag\")\n    op.drop_index(op.f(\"ix_post_tag_post_id\"), table_name=\"post_tag\")\n    op.drop_table(\"post_tag\")\n    op.drop_table(\"user\")\n    op.drop_table(\"tag\")\n    op.drop_table(\"post\")\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "app/util/query_builder.py", "content": "from sqlalchemy.sql.expression import and_\n\nSQLALCHEMY_QUERY_MAPPER = {\n    \"eq\": \"__eq__\",\n    \"ne\": \"__ne__\",\n    \"lt\": \"__lt__\",\n    \"lte\": \"__le__\",\n    \"gt\": \"__gt__\",\n    \"gte\": \"__ge__\",\n}\n\n\ndef dict_to_sqlalchemy_filter_options(model_class, search_option_dict):\n    sql_alchemy_filter_options = []\n    copied_dict = search_option_dict.copy()\n    for key in search_option_dict:\n        attr = getattr(model_class, key, None)\n        if attr is None:\n            continue\n        option_from_dict = copied_dict.pop(key)\n        if type(option_from_dict) in [int, float]:\n            sql_alchemy_filter_options.append(attr == option_from_dict)\n        elif type(option_from_dict) in [str]:\n            sql_alchemy_filter_options.append(attr.like(\"%\" + option_from_dict + \"%\"))\n        elif type(option_from_dict) in [bool]:\n            sql_alchemy_filter_options.append(attr.is_(option_from_dict))\n\n    for custom_option in copied_dict:\n        if \"__\" not in custom_option:\n            continue\n        key, command = custom_option.split(\"__\")\n        attr = getattr(model_class, key, None)\n        if attr is None:\n            continue\n        option_from_dict = copied_dict[custom_option]\n        if command == \"in\":\n            sql_alchemy_filter_options.append(attr.in_([option.strip() for option in option_from_dict.split(\",\")]))\n        elif command in SQLALCHEMY_QUERY_MAPPER.keys():\n            sql_alchemy_filter_options.append(getattr(attr, SQLALCHEMY_QUERY_MAPPER[command])(option_from_dict))\n        elif command == \"isnull\":\n            bool_command = \"__eq__\" if option_from_dict else \"__ne__\"\n            sql_alchemy_filter_options.append(getattr(attr, bool_command)(None))\n\n    return and_(True, *sql_alchemy_filter_options)\n"}
{"type": "source_file", "path": "migrations/env.py", "content": "import os\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom sqlmodel import SQLModel\n\nfrom app.core.config import configs\nfrom app.model.post import Post\nfrom app.model.post_tag import PostTag\nfrom app.model.tag import Tag\nfrom app.model.user import User\n\ncmd_kwargs = context.get_x_argument(as_dictionary=True)\nif \"ENV\" in cmd_kwargs:\n    os.environ[\"ENV\"] = cmd_kwargs[\"ENV\"]\n    ENV = cmd_kwargs[\"ENV\"]\nelse:\n    ENV = \"test\"\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\nif not config.get_main_option(\"sqlalchemy.url\"):\n    config.set_main_option(\"sqlalchemy.url\", configs.DATABASE_URI)\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = SQLModel.metadata\n\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\n# exclude system table\ndef include_name(name, type_, parent_names):\n    return False\n\n\n# code doesn't reach here\n# def run_migrations_offline():\n# \"\"\"Run migrations in 'offline' mode.\n#\n# This configures the context with just a URL\n# and not an Engine, though an Engine is acceptable\n# here as well.  By skipping the Engine creation\n# we don't even need a DBAPI to be available.\n#\n# Calls to context.execute() here emit the given string to the\n# script output.\n#\n# \"\"\"\n# url = config.get_main_option(\"sqlalchemy.url\")\n# context.configure(\n#     url=url,\n#     target_metadata=target_metadata,\n#     literal_binds=True,\n#     include_schemas=True,\n#     dialect_opts={\"paramstyle\": \"named\"},\n#     include_name=include_name,\n# )\n#\n# with context.begin_transaction():\n#     context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n\n    db_config = config.get_section(config.config_ini_section)\n    connectable = engine_from_config(\n        db_config,\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection,\n            target_metadata=target_metadata,\n            include_schemas=True,\n            dialect_opts={\"paramstyle\": \"named\"},\n            include_name=include_name,\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    pass\n    # run_migrations_offline()\nelse:\n    run_migrations_online()\n"}

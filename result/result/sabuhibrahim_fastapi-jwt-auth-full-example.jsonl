{"repo_info": {"repo_name": "fastapi-jwt-auth-full-example", "repo_owner": "sabuhibrahim", "repo_url": "https://github.com/sabuhibrahim/fastapi-jwt-auth-full-example"}}
{"type": "source_file", "path": "alembic/env.py", "content": "import os\nimport asyncio\nfrom logging.config import fileConfig\n\nfrom sqlalchemy import pool\nfrom sqlalchemy.engine import Connection\nfrom sqlalchemy.ext.asyncio import async_engine_from_config\n\nfrom alembic import context\nfrom src.models import Base\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# Add Data Base Url from .env\nsection = config.config_ini_section\nconfig.set_section_option(\n    section, \"POSTGRES_USER\", os.environ.get(\"POSTGRES_USER\", \"user\")\n)\nconfig.set_section_option(\n    section, \"POSTGRES_PASSWORD\", os.environ.get(\"POSTGRES_PASSWORD\", \"user\")\n)\nconfig.set_section_option(\n    section, \"POSTGRES_HOST\", os.environ.get(\"POSTGRES_HOST\", \"0.0.0.0\")\n)\nconfig.set_section_option(\n    section, \"POSTGRES_PORT\", os.environ.get(\"POSTGRES_PORT\", \"5432\")\n)\nconfig.set_section_option(section, \"POSTGRES_DB\", os.environ.get(\"POSTGRES_DB\", \"user\"))\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = [Base.metadata]\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef do_run_migrations(connection: Connection) -> None:\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_async_migrations() -> None:\n    \"\"\"In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n\n    connectable = async_engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n    await connectable.dispose()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\"\"\"\n\n    asyncio.run(run_async_migrations())\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "src/__init__.py", "content": ""}
{"type": "source_file", "path": "alembic/versions/e08ed2f3cf78_first_commit.py", "content": "\"\"\"First commit\n\nRevision ID: e08ed2f3cf78\nRevises: \nCreate Date: 2023-09-23 11:56:46.038596\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = \"e08ed2f3cf78\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"blacklisttokens\",\n        sa.Column(\"id\", sa.Uuid(), nullable=False),\n        sa.Column(\"expire\", sa.DateTime(), nullable=False),\n        sa.Column(\n            \"created_at\",\n            sa.DateTime(),\n            server_default=sa.text(\"TIMEZONE('utc', CURRENT_TIMESTAMP)\"),\n            nullable=False,\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(\n        op.f(\"ix_blacklisttokens_id\"), \"blacklisttokens\", [\"id\"], unique=False\n    )\n    op.create_table(\n        \"users\",\n        sa.Column(\"id\", sa.Uuid(), nullable=False),\n        sa.Column(\"email\", sa.String(), nullable=False),\n        sa.Column(\"full_name\", sa.String(), nullable=False),\n        sa.Column(\"password\", sa.String(), nullable=False),\n        sa.Column(\"is_active\", sa.Boolean(), nullable=False),\n        sa.Column(\n            \"created_at\",\n            sa.DateTime(),\n            server_default=sa.text(\"TIMEZONE('utc', CURRENT_TIMESTAMP)\"),\n            nullable=False,\n        ),\n        sa.Column(\n            \"updated_at\",\n            sa.DateTime(),\n            server_default=sa.text(\"TIMEZONE('utc', CURRENT_TIMESTAMP)\"),\n            onupdate=sa.text(\"TIMEZONE('utc', CURRENT_TIMESTAMP)\"),\n            nullable=False,\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_users_email\"), \"users\", [\"email\"], unique=True)\n    op.create_index(op.f(\"ix_users_id\"), \"users\", [\"id\"], unique=False)\n    op.create_table(\n        \"sessions\",\n        sa.Column(\"id\", sa.Uuid(), nullable=False),\n        sa.Column(\n            \"created_at\",\n            sa.DateTime(),\n            server_default=sa.text(\"TIMEZONE('utc', CURRENT_TIMESTAMP)\"),\n            nullable=False,\n        ),\n        sa.Column(\"title\", sa.String(), nullable=False),\n        sa.Column(\"content\", sa.Text(), nullable=False),\n        sa.Column(\"author_id\", sa.Uuid(), nullable=False),\n        sa.ForeignKeyConstraint([\"author_id\"], [\"users.id\"], ondelete=\"CASCADE\"),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_sessions_id\"), \"sessions\", [\"id\"], unique=False)\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f(\"ix_sessions_id\"), table_name=\"sessions\")\n    op.drop_table(\"sessions\")\n    op.drop_index(op.f(\"ix_users_id\"), table_name=\"users\")\n    op.drop_index(op.f(\"ix_users_email\"), table_name=\"users\")\n    op.drop_table(\"users\")\n    op.drop_index(op.f(\"ix_blacklisttokens_id\"), table_name=\"blacklisttokens\")\n    op.drop_table(\"blacklisttokens\")\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "main.py", "content": "from fastapi import FastAPI\nfrom fastapi.responses import ORJSONResponse\n\nfrom src.routers import router\n\n\napp = FastAPI(default_response_class=ORJSONResponse)\n\napp.include_router(router)\n"}
{"type": "source_file", "path": "src/exceptions.py", "content": "from typing import Any\nfrom fastapi import HTTPException, status\n\n\nclass BadRequestException(HTTPException):\n    def __init__(self, detail: Any = None) -> None:\n        super().__init__(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=detail if detail else \"Bad request\",\n        )\n\n\nclass AuthFailedException(HTTPException):\n    def __init__(self) -> None:\n        super().__init__(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Authenticate failed\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n\nclass AuthTokenExpiredException(HTTPException):\n    def __init__(self) -> None:\n        super().__init__(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Expired token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n\nclass NotFoundException(HTTPException):\n    def __init__(self, detail: Any = None) -> None:\n        super().__init__(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=detail if detail else \"Not found\",\n        )\n\n\nclass ForbiddenException(HTTPException):\n    def __init__(self, detail: Any = None) -> None:\n        super().__init__(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=detail if detail else \"Forbidden\",\n        )\n"}
{"type": "source_file", "path": "src/core/hash.py", "content": "from passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n"}
{"type": "source_file", "path": "src/core/jwt.py", "content": "import uuid\nimport sys\nfrom datetime import timedelta, datetime, timezone\n\nfrom jose import jwt, JWTError\nfrom fastapi import Response\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom . import config\nfrom src.schemas import User, TokenPair, JwtTokenSchema\nfrom src.exceptions import AuthFailedException\nfrom src.models import BlackListToken\n\n\nREFRESH_COOKIE_NAME = \"refresh\"\nSUB = \"sub\"\nEXP = \"exp\"\nIAT = \"iat\"\nJTI = \"jti\"\n\ndef _get_utc_now():\n    if sys.version_info >= (3, 2):\n        # For Python 3.2 and later\n        current_utc_time = datetime.now(timezone.utc)\n    else:\n        # For older versions of Python\n        current_utc_time = datetime.utcnow()\n    return current_utc_time\n\ndef _create_access_token(payload: dict, minutes: int | None = None) -> JwtTokenSchema:\n    expire = _get_utc_now() + timedelta(\n        minutes=minutes or config.ACCESS_TOKEN_EXPIRES_MINUTES\n    )\n\n    payload[EXP] = expire\n\n    token = JwtTokenSchema(\n        token=jwt.encode(payload, config.SECRET_KEY, algorithm=config.ALGORITHM),\n        payload=payload,\n        expire=expire,\n    )\n\n    return token\n\n\ndef _create_refresh_token(payload: dict) -> JwtTokenSchema:\n    expire = _get_utc_now() + timedelta(minutes=config.REFRESH_TOKEN_EXPIRES_MINUTES)\n\n    payload[EXP] = expire\n\n    token = JwtTokenSchema(\n        token=jwt.encode(payload, config.SECRET_KEY, algorithm=config.ALGORITHM),\n        expire=expire,\n        payload=payload,\n    )\n\n    return token\n\n\ndef create_token_pair(user: User) -> TokenPair:\n    payload = {SUB: str(user.id), JTI: str(uuid.uuid4()), IAT: _get_utc_now()}\n\n    return TokenPair(\n        access=_create_access_token(payload={**payload}),\n        refresh=_create_refresh_token(payload={**payload}),\n    )\n\n\nasync def decode_access_token(token: str, db: AsyncSession):\n    try:\n        payload = jwt.decode(token, config.SECRET_KEY, algorithms=[config.ALGORITHM])\n        black_list_token = await BlackListToken.find_by_id(db=db, id=payload[JTI])\n        if black_list_token:\n            raise JWTError(\"Token is blacklisted\")\n    except JWTError:\n        raise AuthFailedException()\n\n    return payload\n\n\ndef refresh_token_state(token: str):\n    try:\n        payload = jwt.decode(token, config.SECRET_KEY, algorithms=[config.ALGORITHM])\n    except JWTError as ex:\n        print(str(ex))\n        raise AuthFailedException()\n\n    return {\"token\": _create_access_token(payload=payload).token}\n\n\ndef mail_token(user: User):\n    \"\"\"Return 2 hour lifetime access_token\"\"\"\n    payload = {SUB: str(user.id), JTI: str(uuid.uuid4()), IAT: _get_utc_now()}\n    return _create_access_token(payload=payload, minutes=2 * 60).token\n\n\ndef add_refresh_token_cookie(response: Response, token: str):\n    exp = _get_utc_now() + timedelta(minutes=config.REFRESH_TOKEN_EXPIRES_MINUTES)\n    exp.replace(tzinfo=timezone.utc)\n\n    response.set_cookie(\n        key=\"refresh\",\n        value=token,\n        expires=int(exp.timestamp()),\n        httponly=True,\n    )\n"}
{"type": "source_file", "path": "src/database.py", "content": "from typing import Any\n\nfrom fastapi import HTTPException, status\nfrom pydantic import PostgresDsn\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import (\n    AsyncAttrs,\n    async_sessionmaker,\n    create_async_engine,\n    AsyncSession,\n)\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import DeclarativeBase\n\nfrom .core import config\n\n\nPG_URL = PostgresDsn.build(\n    scheme=\"postgresql+asyncpg\",\n    user=config.POSTGRES_USER,\n    password=config.POSTGRES_PASSWORD,\n    host=config.POSTGRES_HOST,\n    port=config.POSTGRES_PORT,\n    path=f\"/{config.POSTGRES_DB}\",\n)\n\n\nengine = create_async_engine(PG_URL, future=True, echo=True)\n\n\nSessionFactory = async_sessionmaker(engine, autoflush=False, expire_on_commit=False)\n\n\nclass Base(AsyncAttrs, DeclarativeBase):\n    async def save(self, db: AsyncSession):\n        \"\"\"\n        :param db:\n        :return:\n        \"\"\"\n        try:\n            db.add(self)\n            return await db.commit()\n        except SQLAlchemyError as ex:\n            raise HTTPException(\n                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=repr(ex)\n            ) from ex\n\n    @classmethod\n    async def find_by_id(cls, db: AsyncSession, id: str):\n        query = select(cls).where(cls.id == id)\n        result = await db.execute(query)\n        return result.scalars().first()\n"}
{"type": "source_file", "path": "src/core/config.py", "content": "import os\n\nSECRET_KEY = os.getenv(\n    \"SECRET_KEY\",\n    \"sraGbRmjYQXmYdnrgPk!OFE35UP6n/QqeoED=iu/bUXBFSSPwnsuprP6T45Qsbwywu2khUka!6IIleY\",\n)\nif not SECRET_KEY:\n    SECRET_KEY = os.urandom(32)\n\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRES_MINUTES = 30\nREFRESH_TOKEN_EXPIRES_MINUTES = 15 * 24 * 60  # 15 days\n\n\nPOSTGRES_HOST = os.getenv(\"POSTGRES_HOST\", \"0.0.0.0\")\nPOSTGRES_PORT = os.getenv(\"POSTGRES_PORT\", \"5432\")\nPOSTGRES_USER = os.getenv(\"POSTGRES_USER\", \"user\")\nPOSTGRES_PASSWORD = os.getenv(\"POSTGRES_PASSWORD\", \"user\")\nPOSTGRES_DB = os.getenv(\"POSTGRES_DB\", \"user\")\n"}
{"type": "source_file", "path": "src/core/__init__.py", "content": ""}
{"type": "source_file", "path": "src/dependencies.py", "content": "from .database import SessionFactory\n\n\nasync def get_db():\n    db = SessionFactory()\n    try:\n        yield db\n    finally:\n        await db.close()\n"}
{"type": "source_file", "path": "src/models.py", "content": "import uuid\nfrom datetime import datetime\nfrom sqlalchemy import select, ForeignKey, Text\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.database import Base\nfrom src.core.hash import verify_password\nfrom src.utils import utcnow\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[uuid.UUID] = mapped_column(\n        primary_key=True, index=True, default=uuid.uuid4\n    )\n    email: Mapped[str] = mapped_column(unique=True, index=True)\n    full_name: Mapped[str]\n    password: Mapped[str]\n    is_active: Mapped[bool] = mapped_column(default=False)\n    created_at: Mapped[datetime] = mapped_column(server_default=utcnow())\n    updated_at: Mapped[datetime] = mapped_column(\n        server_default=utcnow(), server_onupdate=utcnow(), onupdate=utcnow()\n    )\n\n    articles: Mapped[list[\"Article\"]] = relationship(back_populates=\"author\")\n\n    @classmethod\n    async def find_by_email(cls, db: AsyncSession, email: str):\n        query = select(cls).where(cls.email == email)\n        result = await db.execute(query)\n        return result.scalars().first()\n\n    @classmethod\n    async def authenticate(cls, db: AsyncSession, email: str, password: str):\n        user = await cls.find_by_email(db=db, email=email)\n        if not user or not verify_password(password, user.password):\n            return False\n        return user\n\n\nclass BlackListToken(Base):\n    __tablename__ = \"blacklisttokens\"\n    id: Mapped[uuid.UUID] = mapped_column(\n        primary_key=True, index=True, default=uuid.uuid4\n    )\n    expire: Mapped[datetime]\n    created_at: Mapped[datetime] = mapped_column(server_default=utcnow())\n\n\nclass Article(Base):\n    __tablename__ = \"sessions\"\n    id: Mapped[uuid.UUID] = mapped_column(\n        primary_key=True, index=True, default=uuid.uuid4\n    )\n    created_at: Mapped[datetime] = mapped_column(server_default=utcnow())\n    title: Mapped[str]\n    content: Mapped[str] = mapped_column(Text)\n\n    author_id: Mapped[uuid.UUID] = mapped_column(\n        ForeignKey(\"users.id\", ondelete=\"CASCADE\")\n    )\n    author: Mapped[\"User\"] = relationship(back_populates=\"articles\")\n\n    @classmethod\n    async def find_by_author(cls, db: AsyncSession, author: User):\n        query = select(cls).where(cls.author_id == author.id)\n        result = await db.execute(query)\n        return result.scalars().all()\n"}
{"type": "source_file", "path": "src/tasks.py", "content": "from src.schemas import MailTaskSchema\n\n\ndef user_mail_event(payload: MailTaskSchema):\n    # Send mail to user here\n    # Now printing only token\n    # Token is used for Vefify endpoind\n    print(f\"[ Mail Schecma ]: {payload}\")\n"}
{"type": "source_file", "path": "src/schemas.py", "content": "from typing import Any\nfrom datetime import datetime\nfrom pydantic import BaseModel, UUID4, validator, EmailStr\n\n\nclass UserBase(BaseModel):\n    email: EmailStr\n    full_name: str\n\n\nclass UserCreate(UserBase):\n    password: str\n\n\nclass User(UserBase):\n    id: UUID4\n\n    class Config:\n        orm_mode = True\n\n    @validator(\"id\")\n    def convert_to_str(cls, v, values, **kwargs):\n        return str(v) if v else v\n\n\nclass UserRegister(UserBase):\n    password: str\n    confirm_password: str\n\n    @validator(\"confirm_password\")\n    def verify_password_match(cls, v, values, **kwargs):\n        password = values.get(\"password\")\n\n        if v != password:\n            raise ValueError(\"The two passwords did not match.\")\n\n        return v\n\n\nclass UserLogin(BaseModel):\n    email: EmailStr\n    password: str\n\n\nclass JwtTokenSchema(BaseModel):\n    token: str\n    payload: dict\n    expire: datetime\n\n\nclass TokenPair(BaseModel):\n    access: JwtTokenSchema\n    refresh: JwtTokenSchema\n\n\nclass RefreshToken(BaseModel):\n    refresh: str\n\n\nclass SuccessResponseScheme(BaseModel):\n    msg: str\n\n\nclass BlackListToken(BaseModel):\n    id: UUID4\n    expire: datetime\n\n    class Config:\n        orm_mode = True\n\n\nclass MailBodySchema(BaseModel):\n    token: str\n    type: str\n\n\nclass EmailSchema(BaseModel):\n    recipients: list[EmailStr]\n    subject: str\n    body: MailBodySchema\n\n\nclass MailTaskSchema(BaseModel):\n    user: User\n    body: MailBodySchema\n\n\nclass ForgotPasswordSchema(BaseModel):\n    email: EmailStr\n\n\nclass PasswordResetSchema(BaseModel):\n    password: str\n    confirm_password: str\n\n    @validator(\"confirm_password\")\n    def verify_password_match(cls, v, values, **kwargs):\n        password = values.get(\"password\")\n\n        if v != password:\n            raise ValueError(\"The two passwords did not match.\")\n\n        return v\n\n\nclass PasswordUpdateSchema(PasswordResetSchema):\n    old_password: str\n\n\nclass OldPasswordErrorSchema(BaseModel):\n    old_password: bool\n\n    @validator(\"old_password\")\n    def check_old_password_status(cls, v, values, **kwargs):\n        if not v:\n            raise ValueError(\"Old password is not corret\")\n\n\nclass ArticleCreateSchema(BaseModel):\n    title: str\n    content: str\n\n\nclass ArticleListScheme(ArticleCreateSchema):\n    id: UUID4\n    author_id: UUID4\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "src/utils.py", "content": "from sqlalchemy.sql import expression\nfrom sqlalchemy.ext.compiler import compiles\nfrom sqlalchemy.types import DateTime\n\n\nclass utcnow(expression.FunctionElement):\n    type = DateTime()\n    inherit_cache = True\n\n\n@compiles(utcnow, \"postgresql\")\ndef pg_utcnow(element, compiler, **kw):\n    return \"TIMEZONE('utc', CURRENT_TIMESTAMP)\"\n"}
{"type": "source_file", "path": "src/routers.py", "content": "from typing import Annotated\nfrom datetime import datetime\n\nfrom fastapi import APIRouter, HTTPException, Depends, BackgroundTasks, Response, Cookie\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.security import OAuth2PasswordBearer\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom pydantic import ValidationError\n\nfrom src.dependencies import get_db\nfrom src import schemas, models\nfrom src.core.hash import get_password_hash, verify_password\nfrom src.core.jwt import (\n    create_token_pair,\n    refresh_token_state,\n    decode_access_token,\n    mail_token,\n    add_refresh_token_cookie,\n    SUB,\n    JTI,\n    EXP,\n)\nfrom src.exceptions import BadRequestException, NotFoundException, ForbiddenException\nfrom src.tasks import (\n    user_mail_event,\n)\n\nrouter = APIRouter()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"login\")\n\n\n@router.post(\"/register\", response_model=schemas.User)\nasync def register(\n    data: schemas.UserRegister,\n    bg_task: BackgroundTasks,\n    db: AsyncSession = Depends(get_db),\n):\n    user = await models.User.find_by_email(db=db, email=data.email)\n    if user:\n        raise HTTPException(status_code=400, detail=\"Email has already registered\")\n\n    # hashing password\n    user_data = data.dict(exclude={\"confirm_password\"})\n    user_data[\"password\"] = get_password_hash(user_data[\"password\"])\n\n    # save user to db\n    user = models.User(**user_data)\n    user.is_active = False\n    await user.save(db=db)\n\n    # send verify email\n    user_schema = schemas.User.from_orm(user)\n    verify_token = mail_token(user_schema)\n\n    mail_task_data = schemas.MailTaskSchema(\n        user=user_schema, body=schemas.MailBodySchema(type=\"verify\", token=verify_token)\n    )\n    bg_task.add_task(user_mail_event, mail_task_data)\n\n    return user_schema\n\n\n@router.post(\"/login\")\nasync def login(\n    data: schemas.UserLogin,\n    response: Response,\n    db: AsyncSession = Depends(get_db),\n):\n    user = await models.User.authenticate(\n        db=db, email=data.email, password=data.password\n    )\n\n    if not user:\n        raise BadRequestException(detail=\"Incorrect email or password\")\n\n    if not user.is_active:\n        raise ForbiddenException()\n\n    user = schemas.User.from_orm(user)\n\n    token_pair = create_token_pair(user=user)\n\n    add_refresh_token_cookie(response=response, token=token_pair.refresh.token)\n\n    return {\"token\": token_pair.access.token}\n\n\n@router.post(\"/refresh\")\nasync def refresh(refresh: Annotated[str | None, Cookie()] = None):\n    print(refresh)\n    if not refresh:\n        raise BadRequestException(detail=\"refresh token required\")\n    return refresh_token_state(token=refresh)\n\n\n@router.get(\"/verify\", response_model=schemas.SuccessResponseScheme)\nasync def verify(token: str, db: AsyncSession = Depends(get_db)):\n    payload = await decode_access_token(token=token, db=db)\n    user = await models.User.find_by_id(db=db, id=payload[SUB])\n    if not user:\n        raise NotFoundException(detail=\"User not found\")\n\n    user.is_active = True\n    await user.save(db=db)\n    return {\"msg\": \"Successfully activated\"}\n\n\n@router.post(\"/logout\", response_model=schemas.SuccessResponseScheme)\nasync def logout(\n    token: Annotated[str, Depends(oauth2_scheme)],\n    db: AsyncSession = Depends(get_db),\n):\n    payload = await decode_access_token(token=token, db=db)\n    black_listed = models.BlackListToken(\n        id=payload[JTI], expire=datetime.utcfromtimestamp(payload[EXP])\n    )\n    await black_listed.save(db=db)\n\n    return {\"msg\": \"Succesfully logout\"}\n\n\n@router.post(\"/forgot-password\", response_model=schemas.SuccessResponseScheme)\nasync def forgot_password(\n    data: schemas.ForgotPasswordSchema,\n    bg_task: BackgroundTasks,\n    db: AsyncSession = Depends(get_db),\n):\n    user = await models.User.find_by_email(db=db, email=data.email)\n    if user:\n        user_schema = schemas.User.from_orm(user)\n        reset_token = mail_token(user_schema)\n\n        mail_task_data = schemas.MailTaskSchema(\n            user=user_schema,\n            body=schemas.MailBodySchema(type=\"password-reset\", token=reset_token),\n        )\n        bg_task.add_task(user_mail_event, mail_task_data)\n\n    return {\"msg\": \"Reset token sended successfully your email check your email\"}\n\n\n@router.post(\"/password-reset\", response_model=schemas.SuccessResponseScheme)\nasync def password_reset_token(\n    token: str,\n    data: schemas.PasswordResetSchema,\n    db: AsyncSession = Depends(get_db),\n):\n    payload = await decode_access_token(token=token, db=db)\n    user = await models.User.find_by_id(db=db, id=payload[SUB])\n    if not user:\n        raise NotFoundException(detail=\"User not found\")\n\n    user.password = get_password_hash(data.password)\n    await user.save(db=db)\n\n    return {\"msg\": \"Password succesfully updated\"}\n\n\n@router.post(\"/password-update\", response_model=schemas.SuccessResponseScheme)\nasync def password_update(\n    token: Annotated[str, Depends(oauth2_scheme)],\n    data: schemas.PasswordUpdateSchema,\n    db: AsyncSession = Depends(get_db),\n):\n    payload = await decode_access_token(token=token, db=db)\n    user = await models.User.find_by_id(db=db, id=payload[SUB])\n    if not user:\n        raise NotFoundException(detail=\"User not found\")\n\n    # raise Validation error\n    if not verify_password(data.old_password, user.password):\n        try:\n            schemas.OldPasswordErrorSchema(old_password=False)\n        except ValidationError as e:\n            raise RequestValidationError(e.raw_errors)\n    user.password = get_password_hash(data.password)\n    await user.save(db=db)\n\n    return {\"msg\": \"Successfully updated\"}\n\n\n@router.get(\"/articles\")\nasync def articles(\n    token: Annotated[str, Depends(oauth2_scheme)],\n    db: AsyncSession = Depends(get_db),\n):\n    payload = await decode_access_token(token=token, db=db)\n    user = await models.User.find_by_id(db=db, id=payload[SUB])\n    if not user:\n        raise NotFoundException(detail=\"User not found\")\n\n    articles = await models.Article.find_by_author(db=db, author=user)\n\n    return [schemas.ArticleListScheme.from_orm(article) for article in articles]\n\n\n@router.post(\"/articles\", response_model=schemas.SuccessResponseScheme, status_code=201)\nasync def article_create(\n    token: Annotated[str, Depends(oauth2_scheme)],\n    data: schemas.ArticleCreateSchema,\n    db: AsyncSession = Depends(get_db),\n):\n    payload = await decode_access_token(token=token, db=db)\n    user = await models.User.find_by_id(db=db, id=payload[SUB])\n    if not user:\n        raise NotFoundException(detail=\"User not found\")\n\n    article = models.Article(**data.dict())\n    article.author = user\n\n    await article.save(db=db)\n\n    return {\"msg\": \"Article succesfully crated\"}\n"}

{"repo_info": {"repo_name": "ToDoGeminiApp", "repo_owner": "atilsamancioglu", "repo_url": "https://github.com/atilsamancioglu/ToDoGeminiApp"}}
{"type": "source_file", "path": "alembic/env.py", "content": "from logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\nimport models\nfrom alembic import context\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = models.Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "alembic/versions/959b4670d4ab_phone_number_added.py", "content": "\"\"\"phone number added\n\nRevision ID: 959b4670d4ab\nRevises: \nCreate Date: 2024-09-22 13:41:22.863862\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = '959b4670d4ab'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    op.add_column('users', sa.Column('phone_number', sa.String(), nullable=True))\n\n\ndef downgrade() -> None:\n    #op.drop_column(\"users\", \"phone_number\")\n    pass\n"}
{"type": "source_file", "path": "main.py", "content": "from fastapi import FastAPI, Request\nfrom fastapi.staticfiles import StaticFiles\nfrom starlette.responses import RedirectResponse\nfrom starlette import status\nfrom .models import Base, Todo\nfrom .database import engine\nfrom .routers.auth import router as auth_router\nfrom .routers.todo import router as todo_router\nimport os\n\napp = FastAPI()\n\nscript_dir = os.path.dirname(__file__)\nst_abs_file_path = os.path.join(script_dir, \"static/\")\n\n\napp.mount(\"/static\", StaticFiles(directory=st_abs_file_path), name=\"static\")\n\n\n@app.get(\"/\")\ndef read_root(request: Request):\n    return RedirectResponse(url=\"/todo/todo-page\", status_code=status.HTTP_302_FOUND)\n\n\napp.include_router(auth_router)\napp.include_router(todo_router)\n\nBase.metadata.create_all(bind=engine)\n"}
{"type": "source_file", "path": "models.py", "content": "from .database import Base\nfrom sqlalchemy import Column, Integer, String, Boolean, ForeignKey\n\n\nclass Todo(Base):\n    __tablename__ = 'todos'\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String)\n    description = Column(String)\n    priority = Column(Integer)\n    complete = Column(Boolean, default=False)\n    owner_id = Column(Integer, ForeignKey('users.id'))\n\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True)\n    username = Column(String, unique=True)\n    first_name = Column(String)\n    last_name = Column(String)\n    hashed_password = Column(String)\n    is_active = Column(Boolean, default=True)\n    role = Column(String)\n    phone_number = Column(String)\n"}
{"type": "source_file", "path": "routers/auth.py", "content": "from fastapi import APIRouter, Depends, HTTPException, Request\nfrom pydantic import BaseModel\nfrom typing import Annotated\nfrom sqlalchemy.orm import Session\nfrom starlette import status\nfrom fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer\nfrom ..database import SessionLocal\nfrom ..models import User\nfrom passlib.context import CryptContext\nfrom jose import jwt, JWTError\nfrom datetime import timedelta, datetime, timezone\nfrom fastapi.templating import Jinja2Templates\n\nrouter = APIRouter(\n    prefix=\"/auth\",\n    tags=[\"Authentication\"],\n)\n\ntemplates = Jinja2Templates(directory=\"app/templates/\")\n\nSECRET_KEY = \"acoztm3revp1vfj7ld5sz2ndg5xp79r9fnr2p4hx2dy63h6a8efhj6rm54u8evh8\"\nALGORITHM = \"HS256\"\n\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\ndb_dependency = Annotated[Session, Depends(get_db)]\n\nbcrypt_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_bearer = OAuth2PasswordBearer(tokenUrl=\"/auth/token\")\n\n\nclass CreateUserRequest(BaseModel):\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n    password: str\n    role: str\n    phone_number: str\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\ndef create_access_token(username: str, user_id: int, role: str, expires_delta: timedelta):\n    payload = {'sub': username, 'id': user_id, 'role': role}\n    expires = datetime.now(timezone.utc) + expires_delta\n    payload.update({'exp': expires})\n    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)\n\n\ndef authenticate_user(username: str, password: str, db):\n    user = db.query(User).filter(User.username == username).first()\n    if not user:\n        return False\n    if not bcrypt_context.verify(password, user.hashed_password):\n        return False\n    return user\n\n\nasync def get_current_user(token: Annotated[str, Depends(oauth2_bearer)]):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username = payload.get('sub')\n        user_id = payload.get('id')\n        user_role = payload.get('role')\n        if username is None or user_id is None:\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Username or ID is invalid\")\n        return {'username': username, 'id': user_id, 'user_role': user_role}\n    except JWTError:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,detail=\"Token is invalid\")\n\n\n@router.get(\"/login-page\")\ndef render_login_page(request: Request):\n    return templates.TemplateResponse(\"login.html\", {\"request\": request})\n\n\n@router.get(\"/register-page\")\ndef render_register_page(request: Request):\n    return templates.TemplateResponse(\"register.html\", {\"request\": request})\n\n\n@router.post(\"/\", status_code=status.HTTP_201_CREATED)\nasync def create_user(db: db_dependency, create_user_request: CreateUserRequest):\n    user = User(\n        username=create_user_request.username,\n        email=create_user_request.email,\n        first_name=create_user_request.first_name,\n        last_name=create_user_request.last_name,\n        role=create_user_request.role,\n        is_active=True,\n        hashed_password=bcrypt_context.hash(create_user_request.password),\n        phone_number=create_user_request.phone_number\n    )\n    db.add(user)\n    db.commit()\n\n\n@router.post(\"/token\", response_model = Token)\nasync def login_for_access_token(form_data: Annotated[OAuth2PasswordRequestForm,Depends()],\n                                 db: db_dependency):\n    user = authenticate_user(form_data.username, form_data.password, db)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Incorrect username or password\")\n    token = create_access_token(user.username, user.id, user.role, timedelta(minutes=60))\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n"}
{"type": "source_file", "path": "database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./todoai_app.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nBase = declarative_base()"}
{"type": "source_file", "path": "routers/__init__.py", "content": ""}
{"type": "source_file", "path": "routers/todo.py", "content": "from fastapi import APIRouter, Depends, Path, HTTPException, Request, Response\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy.orm import Session\nfrom starlette import status\nfrom starlette.responses import RedirectResponse\nfrom ..models import Base, Todo\nfrom ..database import engine, SessionLocal\nfrom typing import Annotated\nfrom ..routers.auth import get_current_user\nfrom fastapi.templating import Jinja2Templates\nfrom dotenv import load_dotenv\nimport google.generativeai as genai\nimport os\nfrom langchain_google_genai import ChatGoogleGenerativeAI\nfrom langchain_core.messages import HumanMessage, AIMessage\nimport markdown\nfrom bs4 import BeautifulSoup\n\nrouter = APIRouter(\n    prefix=\"/todo\",\n    tags=[\"Todo\"],\n)\n\ntemplates = Jinja2Templates(directory=\"app/templates\")\n\n\nclass TodoRequest(BaseModel):\n    title: str = Field(min_length=3)\n    description: str = Field(min_length=3, max_length=1000)\n    priority: int = Field(gt=0, lt=6)\n    complete: bool\n\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\ndb_dependency = Annotated[Session, Depends(get_db)]\nuser_dependency = Annotated[dict, Depends(get_current_user)]\n\n\ndef redirect_to_login():\n    redirect_response = RedirectResponse(url=\"/auth/login-page\",status_code=status.HTTP_302_FOUND)\n    redirect_response.delete_cookie(\"access_token\")\n    return redirect_response\n\n\n@router.get(\"/todo-page\")\nasync def render_todo_page(request: Request, db: db_dependency):\n    try:\n        user = await get_current_user(request.cookies.get('access_token'))\n        if user is None:\n            return redirect_to_login()\n        todos = db.query(Todo).filter(Todo.owner_id == user.get('id')).all()\n        return templates.TemplateResponse(\"todo.html\", {\"request\": request, \"todos\": todos, \"user\": user})\n    except:\n        return redirect_to_login()\n\n\n@router.get(\"/add-todo-page\")\nasync def render_add_todo_page(request: Request):\n    try:\n        user = await get_current_user(request.cookies.get('access_token'))\n        if user is None:\n            return redirect_to_login()\n\n        return templates.TemplateResponse(\"add-todo.html\", {\"request\": request, \"user\": user})\n\n    except:\n        return redirect_to_login()\n\n\n@router.get(\"/edit-todo-page/{todo_id}\")\nasync def render_todo_page(request: Request, todo_id: int, db: db_dependency):\n    try:\n        user = await get_current_user(request.cookies.get('access_token'))\n        if user is None:\n            return redirect_to_login()\n\n        todo = db.query(Todo).filter(Todo.id == todo_id).first()\n        return templates.TemplateResponse(\"edit-todo.html\", {\"request\": request, \"todo\": todo, \"user\": user})\n\n    except:\n        return redirect_to_login()\n\n\n@router.get(\"/\")\nasync def read_all(user: user_dependency, db: db_dependency):\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n    return db.query(Todo).filter(Todo.owner_id == user.get('id')).all()\n\n\n@router.get(\"/todo/{todo_id}\",status_code=status.HTTP_200_OK)\nasync def read_by_id(user: user_dependency,db: db_dependency, todo_id: int = Path(gt=0)):\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n\n    todo = db.query(Todo).filter(Todo.id == todo_id).filter(Todo.owner_id == user.get('id')).first()\n\n    if todo is not None:\n        return todo\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n\n\n@router.post(\"/todo\", status_code=status.HTTP_201_CREATED)\nasync def create_todo(user: user_dependency,db: db_dependency, todo_request: TodoRequest):\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n\n    todo = Todo(**todo_request.dict(), owner_id=user.get('id'))\n    todo.description = create_todo_with_gemini(todo.description)\n    db.add(todo)\n    db.commit()\n\n\n@router.put(\"/todo/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def update_todo(user: user_dependency,db: db_dependency,\n                      todo_request: TodoRequest,\n                      todo_id: int = Path(gt=0)):\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n\n    todo = db.query(Todo).filter(Todo.id == todo_id).filter(Todo.owner_id == user.get('id')).first()\n    if todo is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n\n    todo.title = todo_request.title\n    todo.description = todo_request.description\n    todo.priority = todo_request.priority\n    todo.complete = todo_request.complete\n\n    db.add(todo)\n    db.commit()\n\n\n@router.delete(\"/todo/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo(user: user_dependency, db: db_dependency, todo_id: int = Path(gt=0)):\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n    todo = db.query(Todo).filter(Todo.id == todo_id).filter(Todo.owner_id == user.get('id')).first()\n    if todo is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    #db.query(Todo).filter(Todo.id == todo_id).delete()\n    db.delete(todo)\n    db.commit()\n\n\ndef markdown_to_text(markdown_string):\n    html = markdown.markdown(markdown_string)\n    soup = BeautifulSoup(html, \"html.parser\")\n    text = soup.get_text()\n    return text\n\n\ndef create_todo_with_gemini(todo_string: str):\n    load_dotenv()\n    genai.configure(api_key=os.environ.get('GOOGLE_API_KEY'))\n    llm = ChatGoogleGenerativeAI(model=\"gemini-pro\")\n    response = llm.invoke(\n        [\n            HumanMessage(content=\"I will provide you a todo item to add my to do list. What i want you to do is to create a longer and more comprehensive description of that todo item, my next message will be my todo:\"),\n            HumanMessage(content=todo_string),\n        ]\n    )\n    return markdown_to_text(response.content)\n\n"}

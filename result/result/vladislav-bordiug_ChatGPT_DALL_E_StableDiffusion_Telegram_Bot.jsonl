{"repo_info": {"repo_name": "ChatGPT_DALL_E_StableDiffusion_Telegram_Bot", "repo_owner": "vladislav-bordiug", "repo_url": "https://github.com/vladislav-bordiug/ChatGPT_DALL_E_StableDiffusion_Telegram_Bot"}}
{"type": "test_file", "path": "tests/api/test_routes.py", "content": "import pytest\nfrom unittest.mock import AsyncMock, patch\nfrom fastapi import Request\nimport json\n\nfrom app.api.routes.routes import Handlers\nfrom app.bot.utils import TelegramError\nfrom app.services.cryptopay import CryptoPayError\nfrom app.services.db import DatabaseError\n\nfrom aiogram import types\n\nclass TestPaymentsWebhookHandler:\n    @patch('app.api.routes.routes.payment_success', new_callable=AsyncMock)\n    @pytest.mark.asyncio\n    async def test_payments_webhook_success(self, mock_payment_success):\n\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"update_type\": \"invoice_paid\", \"payload\": {\"invoice_id\": \"1\"}}\n\n        mock_bot = AsyncMock()\n        mock_db = AsyncMock()\n\n        handler = Handlers(mock_db, AsyncMock(), mock_bot)\n\n        response = await handler.payments_webhook(mock_request)\n\n        assert response.body.decode('utf-8') == \"OK\"\n        assert response.status_code == 200\n\n        mock_payment_success.assert_awaited_once_with(mock_bot, mock_db, \"invoice_paid\", 1)\n\n    @pytest.mark.asyncio\n    async def test_payments_webhook_request_error(self):\n\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"payload\": {\"invoice_id\": \"1\"}}\n\n        mock_bot = AsyncMock()\n        mock_db = AsyncMock()\n\n        handler = Handlers(mock_db, AsyncMock(), mock_bot)\n\n        response = await handler.payments_webhook(mock_request)\n\n        assert response.body.decode('utf-8') == \"Wrong request\"\n        assert response.status_code == 400\n\n    @patch('app.api.routes.routes.payment_success', new_callable=AsyncMock)\n    @pytest.mark.asyncio\n    async def test_payments_webhook_database_error(self, mock_payment_success):\n\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"update_type\": \"invoice_paid\", \"payload\": {\"invoice_id\": \"1\"}}\n\n        mock_bot = AsyncMock()\n        mock_db = AsyncMock()\n\n        mock_payment_success.side_effect = DatabaseError()\n\n        handler = Handlers(mock_db, AsyncMock(), mock_bot)\n\n        response = await handler.payments_webhook(mock_request)\n\n        assert response.body.decode('utf-8') == \"Database Error\"\n        assert response.status_code == 500\n\n        mock_payment_success.assert_awaited_once_with(mock_bot, mock_db, \"invoice_paid\", 1)\n\n\n    @patch('app.api.routes.routes.payment_success', new_callable=AsyncMock)\n    @pytest.mark.asyncio\n    async def test_payments_webhook_telegram_error(self, mock_payment_success):\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"update_type\": \"invoice_paid\", \"payload\": {\"invoice_id\": \"1\"}}\n\n        mock_bot = AsyncMock()\n        mock_db = AsyncMock()\n\n        mock_payment_success.side_effect = TelegramError()\n\n        handler = Handlers(mock_db, AsyncMock(), mock_bot)\n\n        response = await handler.payments_webhook(mock_request)\n\n        assert response.body.decode('utf-8') == \"Telegram Error\"\n        assert response.status_code == 500\n\n        mock_payment_success.assert_awaited_once_with(mock_bot, mock_db, \"invoice_paid\", 1)\n\n    @patch('app.api.routes.routes.payment_success', new_callable=AsyncMock)\n    @pytest.mark.asyncio\n    async def test_payments_webhook_general_error(self, mock_payment_success):\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"update_type\": \"invoice_paid\", \"payload\": {\"invoice_id\": \"1\"}}\n\n        mock_bot = AsyncMock()\n        mock_db = AsyncMock()\n\n        mock_payment_success.side_effect = Exception()\n\n        handler = Handlers(mock_db, AsyncMock(), mock_bot)\n\n        response = await handler.payments_webhook(mock_request)\n\n        assert response.body.decode('utf-8') == \"Error\"\n        assert response.status_code == 500\n\n        mock_payment_success.assert_awaited_once_with(mock_bot, mock_db, \"invoice_paid\", 1)\n\nclass TestBotWebhookHandler:\n    @pytest.mark.asyncio\n    async def test_bot_webhook_success(self):\n\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"update_id\": 12345}\n\n        mock_dp = AsyncMock()\n        mock_bot = AsyncMock()\n\n        handler = Handlers(AsyncMock(), mock_dp, mock_bot)\n\n        response = await handler.bot_webhook(mock_request)\n\n        assert response.status_code == 200\n        assert json.loads(response.body.decode('utf-8')) == {\"status\": \"ok\"}\n        mock_dp.feed_webhook_update.assert_awaited_once_with(mock_bot, types.Update(update_id=12345))\n\n    @pytest.mark.asyncio\n    async def test_bot_webhook_request_error(self):\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {}\n\n        mock_dp = AsyncMock()\n        mock_bot = AsyncMock()\n\n        handler = Handlers(AsyncMock(), mock_dp, mock_bot)\n\n        response = await handler.bot_webhook(mock_request)\n\n        assert response.status_code == 400\n        assert json.loads(response.body.decode('utf-8')) == {\"message\": \"Wrong request\"}\n\n    @pytest.mark.asyncio\n    async def test_bot_webhook_database_error(self):\n\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"update_id\": 12345}\n\n        mock_dp = AsyncMock()\n        mock_bot = AsyncMock()\n\n        mock_dp.feed_webhook_update.side_effect = DatabaseError()\n\n        handler = Handlers(AsyncMock(), mock_dp, mock_bot)\n\n        response = await handler.bot_webhook(mock_request)\n\n        assert response.status_code == 500\n        assert json.loads(response.body.decode('utf-8')) == {\"message\": \"database error\"}\n\n\n    @pytest.mark.asyncio\n    async def test_bot_webhook_cryptopay_error(self):\n\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"update_id\": 12345}\n\n        mock_dp = AsyncMock()\n        mock_bot = AsyncMock()\n\n        mock_dp.feed_webhook_update.side_effect = CryptoPayError()\n\n        handler = Handlers(AsyncMock(), mock_dp, mock_bot)\n\n        response = await handler.bot_webhook(mock_request)\n\n        assert response.status_code == 500\n        assert json.loads(response.body.decode('utf-8')) == {\"message\": \"cryptopay error\"}\n\n\n    @pytest.mark.asyncio\n    async def test_bot_webhook_telegram_error(self):\n\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"update_id\": 12345}\n\n        mock_dp = AsyncMock()\n        mock_bot = AsyncMock()\n\n        mock_dp.feed_webhook_update.side_effect = TelegramError()\n\n        handler = Handlers(AsyncMock(), mock_dp, mock_bot)\n\n        response = await handler.bot_webhook(mock_request)\n\n        assert response.status_code == 500\n        assert json.loads(response.body.decode('utf-8')) == {\"message\": \"telegram error\"}\n\n\n    @pytest.mark.asyncio\n    async def test_bot_webhook_general_error(self):\n\n        mock_request = AsyncMock(spec=Request)\n        mock_request.json.return_value = {\"update_id\": 12345}\n\n        mock_dp = AsyncMock()\n        mock_bot = AsyncMock()\n\n        mock_dp.feed_webhook_update.side_effect = Exception()\n\n        handler = Handlers(AsyncMock(), mock_dp, mock_bot)\n\n        response = await handler.bot_webhook(mock_request)\n\n        assert response.status_code == 500\n        assert json.loads(response.body.decode('utf-8')) == {\"message\": \"error\"}"}
{"type": "test_file", "path": "tests/bot/test_display_info.py", "content": "import pytest\nfrom unittest.mock import AsyncMock, MagicMock\nfrom aiogram import types\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import KeyboardButton, ReplyKeyboardMarkup\n\nfrom app.bot.handlers.display_info import DisplayInfo\nfrom app.bot.utils import States\nfrom app.services.db import DatabaseError\n\n@pytest.mark.asyncio\nasync def test_display_info_handler_success():\n    message = AsyncMock(spec=types.Message)\n    message.answer = AsyncMock()\n    message.from_user = MagicMock(id=12345)\n\n    state = AsyncMock(spec=FSMContext)\n    state.set_state = AsyncMock()\n\n    mock_db = AsyncMock()\n    mock_db.get_userinfo.return_value = [1, 1, 1]\n\n    handler = DisplayInfo(mock_db)\n\n    await handler.display_info_handler(message, state)\n\n    mock_db.get_userinfo.assert_awaited_once_with(12345)\n\n    button = [[KeyboardButton(text=\"üí∞Buy tokens and generations\")], [KeyboardButton(text=\"üîôBack\")]]\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard=button, resize_keyboard=True\n    )\n    message.answer.assert_awaited_once_with(\n        text = \"You have: \\n üí≠1 ChatGPT tokens \\n üåÑ1 DALL¬∑E image generations \\n üåÖ1 Stable Diffusion image generations \\n üí∏ You can buy more with crypto\",\n        reply_markup= reply_markup,\n    )\n    state.set_state.assert_awaited_once_with(States.INFO_STATE)\n\n@pytest.mark.asyncio\nasync def test_display_info_handler_database_error():\n    message = AsyncMock(spec=types.Message)\n    message.answer = AsyncMock()\n    message.from_user = MagicMock(id=12345)\n\n    state = AsyncMock(spec=FSMContext)\n\n    mock_db = AsyncMock()\n    mock_db.get_userinfo.side_effect = DatabaseError()\n\n    handler = DisplayInfo(mock_db)\n\n    with pytest.raises(DatabaseError):\n        await handler.display_info_handler(message, state)\n\n@pytest.mark.asyncio\nasync def test_display_info_handler_telegram_error():\n    message = AsyncMock(spec=types.Message)\n    message.answer = AsyncMock()\n    message.answer.side_effect = Exception()\n    message.from_user = MagicMock(id=12345)\n\n    state = AsyncMock(spec=FSMContext)\n    state.set_state = AsyncMock()\n\n    mock_db = AsyncMock()\n    mock_db.get_userinfo.return_value = [1, 1, 1]\n\n    handler = DisplayInfo(mock_db)\n\n    with pytest.raises(Exception):\n        await handler.display_info_handler(message, state)\n\n    mock_db.get_userinfo.assert_awaited_once_with(12345)"}
{"type": "test_file", "path": "tests/bot/test_purchase_handlers.py", "content": "import pytest\nfrom unittest.mock import AsyncMock, MagicMock\nfrom aiogram import types\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, KeyboardButton, ReplyKeyboardMarkup\n\nfrom app.bot.handlers.purchase_handlers import PurchaseHandlers\nfrom app.bot.utils import States\nfrom app.services.cryptopay import CryptoPayError\nfrom app.services.db import DatabaseError\n\nclass TestBuyHandler:\n    @pytest.mark.asyncio\n    async def test_buy_handler_success(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"üí≤USD\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.get_state.return_value = States.PURCHASE_CHATGPT_STATE\n\n        mock_db = AsyncMock()\n        mock_crypto = AsyncMock()\n\n        mock_crypto.create_invoice.return_value = 'sads', 12345\n\n        handler = PurchaseHandlers(mock_db, mock_crypto)\n\n        await handler.buy_handler(message, state)\n\n        mock_db.new_order.assert_awaited_once_with(12345, 12345, 'chatgpt')\n        mock_crypto.create_invoice.assert_awaited_once_with(5, 'USD')\n\n        keyboard = InlineKeyboardMarkup(\n            inline_keyboard=[[InlineKeyboardButton(text=\"üí∞Buy\", url='sads')]]\n        )\n        message.answer.assert_awaited_once_with(\n            text = \"ü™ôProduct: 100K ChatGPT tokens - 5 USDüíµ \\n üí≥If you want to pay click the button 'Buy', click button 'Start' in Crypto Bot and follow the instructions \\n ‚ùóConsider the network commission\",\n            reply_markup= keyboard,\n        )\n\n    @pytest.mark.asyncio\n    async def test_buy_handler_database_error(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"üí≤USD\"\n\n        state = AsyncMock(spec=FSMContext)\n\n        mock_db = AsyncMock()\n        mock_crypto = AsyncMock()\n\n        mock_crypto.create_invoice.side_effect = DatabaseError()\n\n        handler = PurchaseHandlers(mock_db, mock_crypto)\n\n        with pytest.raises(DatabaseError):\n            await handler.buy_handler(message, state)\n\n        mock_crypto.create_invoice.assert_awaited_once_with(5, 'USD')\n\n    @pytest.mark.asyncio\n    async def test_buy_handler_cryptopay_error(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"üí≤USD\"\n\n        state = AsyncMock(spec=FSMContext)\n\n        mock_db = AsyncMock()\n        mock_crypto = AsyncMock()\n\n        mock_crypto.create_invoice.side_effect = CryptoPayError()\n\n        handler = PurchaseHandlers(mock_db, mock_crypto)\n\n        with pytest.raises(CryptoPayError):\n            await handler.buy_handler(message, state)\n\n        mock_crypto.create_invoice.assert_awaited_once_with(5, 'USD')\n\n    @pytest.mark.asyncio\n    async def test_buy_handler_telegram_error(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.answer.side_effect = Exception()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"üí≤USD\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.get_state.return_value = States.PURCHASE_CHATGPT_STATE\n\n        mock_db = AsyncMock()\n        mock_crypto = AsyncMock()\n\n        mock_crypto.create_invoice.return_value = 'sads', 12345\n\n        handler = PurchaseHandlers(mock_db, mock_crypto)\n\n        with pytest.raises(Exception):\n            await handler.buy_handler(message, state)\n\n        mock_db.new_order.assert_awaited_once_with(12345, 12345, 'chatgpt')\n        mock_crypto.create_invoice.assert_awaited_once_with(5, 'USD')\n\nclass TestCurrenciesHandler:\n    @pytest.mark.asyncio\n    async def test_currencies_handler_success(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.text = \"100K ChatGPT tokens - 5 USDüíµ\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        handler = PurchaseHandlers(AsyncMock(), AsyncMock())\n\n        await handler.currencies_handler(message, state)\n\n        buttons = [\n            [KeyboardButton(text=\"üí≤USDT\"),\n             KeyboardButton(text=\"üí≤TON\")],\n            [KeyboardButton(text=\"üí≤BTC\"),\n             KeyboardButton(text=\"üí≤ETH\")],\n            [KeyboardButton(text=\"üîôBack\")]\n        ]\n        keyboard = ReplyKeyboardMarkup(\n            keyboard=buttons,\n            resize_keyboard=True\n        )\n\n        message.answer.assert_awaited_once_with(\n            text = \"Choose currency: üëá\",\n            reply_markup=keyboard,\n        )\n\n        state.set_state.assert_awaited_once_with(States.PURCHASE_CHATGPT_STATE)\n\n    @pytest.mark.asyncio\n    async def test_currencies_handler_telegram_error(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.answer.side_effect = Exception()\n        message.text = \"100K ChatGPT tokens - 5 USDüíµ\"\n\n        state = AsyncMock(spec=FSMContext)\n\n        handler = PurchaseHandlers(AsyncMock(), AsyncMock())\n\n        with pytest.raises(Exception):\n            await handler.currencies_handler(message, state)\n\n        buttons = [\n            [KeyboardButton(text=\"üí≤USDT\"),\n             KeyboardButton(text=\"üí≤TON\")],\n            [KeyboardButton(text=\"üí≤BTC\"),\n             KeyboardButton(text=\"üí≤ETH\")],\n            [KeyboardButton(text=\"üîôBack\")]\n        ]\n        keyboard = ReplyKeyboardMarkup(\n            keyboard=buttons,\n            resize_keyboard=True\n        )\n\n        message.answer.assert_awaited_once_with(\n            text = \"Choose currency: üëá\",\n            reply_markup=keyboard,\n        )\n\nclass TestPurchaseHandler:\n    @pytest.mark.asyncio\n    async def test_purchase_handler_success(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        handler = PurchaseHandlers(AsyncMock(), AsyncMock())\n\n        await handler.purchase_handler(message, state)\n\n        button = [[KeyboardButton(text=\"100K ChatGPT tokens - 5 USDüíµ\")],\n                  [KeyboardButton(text=\"50 DALL¬∑E image generations - 5 USDüíµ\")],\n                  [KeyboardButton(text=\"50 Stable Diffusion image generations - 5 USDüíµ\")],\n                  [KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer.assert_awaited_once_with(\n            text = \"Choose product: üëá\",\n            reply_markup= reply_markup,\n        )\n        state.set_state.assert_awaited_once_with(States.PURCHASE_STATE)\n\n    @pytest.mark.asyncio\n    async def test_purchase_handler_telegram_error(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.answer.side_effect = Exception()\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        handler = PurchaseHandlers(AsyncMock(), AsyncMock())\n\n        with pytest.raises(Exception):\n            await handler.purchase_handler(message, state)"}
{"type": "test_file", "path": "tests/services/test_stablediffusion.py", "content": "import pytest\nfrom unittest.mock import MagicMock, AsyncMock, patch, call, ANY\n\nfrom app.services.stablediffusion import StableDiffusion\n\nclass AsyncContextManager:\n    def __init__(self):\n        self.post = MagicMock()\n        self.read = AsyncMock()\n\n    async def __aenter__(self):\n        return self\n    async def __aexit__(self, exc_type, exc, traceback):\n        pass\n\n@patch('app.services.stablediffusion.aiohttp')\n@pytest.mark.asyncio\nasync def test_get_stable_success(mock_aiohttp):\n    stable = StableDiffusion('key')\n\n    session = AsyncContextManager()\n\n    response = AsyncContextManager()\n\n    session.post.return_value = response\n\n    mock_aiohttp.ClientSession.return_value = session\n\n    response.status = 200\n\n    response.read.return_value = b\"answer\"\n\n    mock_aiohttp.FormData = MagicMock()\n\n    answer = await stable.get_stable('question')\n\n    response.read.assert_awaited_once_with()\n\n    mock_aiohttp.FormData.assert_has_calls([call(),\n                                            call().add_field(\"prompt\", 'question', content_type='multipart/form-data'),\n                                            call().add_field(\"output_format\", \"jpeg\", content_type='multipart/form-data'),\n                                            call().add_field(\"model\", \"sd3-large-turbo\", content_type='multipart/form-data')])\n\n    assert len(mock_aiohttp.FormData.mock_calls) == 4\n\n    session.post.assert_called_once_with('https://api.stability.ai/v2beta/stable-image/generate/sd3',\n                                        headers={\n                                            \"authorization\": f\"Bearer key\",\n                                            \"accept\": \"image/*\"\n                                        },\n                                        data=ANY)\n\n    assert answer == b\"answer\"\n\n@patch('app.services.stablediffusion.aiohttp')\n@pytest.mark.asyncio\nasync def test_get_stable_error(mock_aiohttp):\n    stable = StableDiffusion('key')\n\n    session = AsyncContextManager()\n\n    response = AsyncContextManager()\n\n    session.post.return_value = response\n\n    mock_aiohttp.ClientSession.return_value = session\n\n    response.status = 500\n\n    response.read.return_value = b\"answer\"\n\n    mock_aiohttp.FormData = MagicMock()\n\n    answer = await stable.get_stable('question')\n\n    mock_aiohttp.FormData.assert_has_calls([call(),\n                                            call().add_field(\"prompt\", 'question', content_type='multipart/form-data'),\n                                            call().add_field(\"output_format\", \"jpeg\", content_type='multipart/form-data'),\n                                            call().add_field(\"model\", \"sd3-large-turbo\", content_type='multipart/form-data')])\n\n    assert len(mock_aiohttp.FormData.mock_calls) == 4\n\n    session.post.assert_called_once_with('https://api.stability.ai/v2beta/stable-image/generate/sd3',\n                                        headers={\n                                            \"authorization\": f\"Bearer key\",\n                                            \"accept\": \"image/*\"\n                                        },\n                                        data=ANY)\n\n    assert answer == None\n\n@patch('app.services.stablediffusion.aiohttp')\n@pytest.mark.asyncio\nasync def test_get_stable_exception(mock_aiohttp):\n    stable = StableDiffusion('key')\n\n    mock_aiohttp.ClientSession.side_effect = Exception()\n\n    mock_aiohttp.FormData = MagicMock()\n\n    answer = await stable.get_stable('question')\n\n    mock_aiohttp.FormData.assert_has_calls([call(),\n                                            call().add_field(\"prompt\", 'question', content_type='multipart/form-data'),\n                                            call().add_field(\"output_format\", \"jpeg\", content_type='multipart/form-data'),\n                                            call().add_field(\"model\", \"sd3-large-turbo\", content_type='multipart/form-data')])\n\n    assert len(mock_aiohttp.FormData.mock_calls) == 4\n\n    assert answer == None"}
{"type": "test_file", "path": "tests/services/test_db.py", "content": "import pytest\nfrom unittest.mock import AsyncMock, MagicMock, call\n\nfrom app.services.db import DataBase\n\nclass AsyncContextManager:\n    def __init__(self):\n        self.commit = AsyncMock()\n        self.execute = AsyncMock()\n        self.cursor = MagicMock()\n        self.fetchone = AsyncMock()\n        self.fetchall = AsyncMock()\n\n    async def __aenter__(self):\n        return self\n    async def __aexit__(self, exc_type, exc, traceback):\n        pass\n\nclass TestCreateTables:\n    @pytest.mark.asyncio\n    async def test_create_tables_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.create_tables()\n\n        mock_connection.commit.assert_awaited_once_with()\n\n        mock_cursor.execute.assert_has_calls([call(\"CREATE TABLE IF NOT EXISTS users (user_id BIGINT PRIMARY KEY, chatgpt INT, dall_e INT, stable_diffusion INT)\"),\n                                              call(\"CREATE TABLE IF NOT EXISTS orders (invoice_id INT PRIMARY KEY, user_id BIGINT, product TEXT, FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE)\"),\n                                              call(\"CREATE TABLE IF NOT EXISTS messages (id SERIAL PRIMARY KEY, user_id BIGINT, role TEXT, content TEXT, tokens INT, FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE)\")])\n        assert len(mock_cursor.execute.mock_calls) == 3\n\n    @pytest.mark.asyncio\n    async def test_create_tables_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.create_tables()\n\n        mock_connection.commit.assert_awaited_once_with()\n\n        mock_cursor.execute.assert_has_calls([call(\"CREATE TABLE IF NOT EXISTS users (user_id BIGINT PRIMARY KEY, chatgpt INT, dall_e INT, stable_diffusion INT)\"),\n                                              call(\"CREATE TABLE IF NOT EXISTS orders (invoice_id INT PRIMARY KEY, user_id BIGINT, product TEXT, FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE)\"),\n                                              call(\"CREATE TABLE IF NOT EXISTS messages (id SERIAL PRIMARY KEY, user_id BIGINT, role TEXT, content TEXT, tokens INT, FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE)\")])\n        assert len(mock_cursor.execute.mock_calls) == 3\n\nclass TestIsUser:\n    @pytest.mark.asyncio\n    async def test_is_user_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        mock_cursor.fetchone.return_value = (1)\n\n        result = await database.is_user(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT user_id FROM users WHERE user_id = %s\", (1, ))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\n        assert result == (1)\n\n    @pytest.mark.asyncio\n    async def test_is_user_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.side_effect = Exception()\n\n        database.pool.connection.return_value = mock_connection\n\n        mock_cursor.execute.return_value = (1)\n\n        with pytest.raises(Exception):\n            _ = await database.is_user(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT user_id FROM users WHERE user_id = %s\", (1,))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\nclass TestInsertUser:\n    @pytest.mark.asyncio\n    async def test_insert_user_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.insert_user(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"INSERT INTO users(user_id, chatgpt, dall_e, stable_diffusion) VALUES (%s, %s, %s, %s)\", (1,3000,3,3))\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_insert_user_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.insert_user(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\n            \"INSERT INTO users(user_id, chatgpt, dall_e, stable_diffusion) VALUES (%s, %s, %s, %s)\", (1, 3000, 3, 3))\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestGetChatgpt:\n    @pytest.mark.asyncio\n    async def test_get_chatgpt_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.return_value = (1,)\n\n        database.pool.connection.return_value = mock_connection\n\n        result = await database.get_chatgpt(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT chatgpt FROM users WHERE user_id = %s\", (1, ))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\n        assert result == 1\n\n    @pytest.mark.asyncio\n    async def test_get_chatgpt_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.side_effect = Exception()\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            _ = await database.get_chatgpt(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT chatgpt FROM users WHERE user_id = %s\", (1,))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\nclass TestSetChatgpt:\n    @pytest.mark.asyncio\n    async def test_set_chatgpt_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.set_chatgpt(1,1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"UPDATE users SET chatgpt = %s WHERE user_id = %s\", (1, 1))\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_set_chatgpt_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.set_chatgpt(1,1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"UPDATE users SET chatgpt = %s WHERE user_id = %s\", (1, 1))\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestGetDallE:\n    @pytest.mark.asyncio\n    async def test_get_dalle_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.return_value = (1,)\n\n        database.pool.connection.return_value = mock_connection\n\n        result = await database.get_dalle(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT dall_e FROM users WHERE user_id = %s\", (1, ))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\n        assert result == 1\n\n    @pytest.mark.asyncio\n    async def test_get_dalle_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.side_effect = Exception()\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            _ = await database.get_dalle(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT dall_e FROM users WHERE user_id = %s\", (1,))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\nclass TestSetDallE:\n    @pytest.mark.asyncio\n    async def test_set_dalle_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.set_dalle(1,1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"UPDATE users SET dall_e = %s WHERE user_id = %s\", (1, 1))\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_set_dalle_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.set_dalle(1,1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"UPDATE users SET dall_e = %s WHERE user_id = %s\", (1, 1))\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestGetStable:\n    @pytest.mark.asyncio\n    async def test_get_stable_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.return_value = (1,)\n\n        database.pool.connection.return_value = mock_connection\n\n        result = await database.get_stable(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT stable_diffusion FROM users WHERE user_id = %s\", (1, ))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\n        assert result == 1\n\n    @pytest.mark.asyncio\n    async def test_get_stable_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.side_effect = Exception()\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            _ = await database.get_stable(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT stable_diffusion FROM users WHERE user_id = %s\", (1,))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\nclass TestSetStable:\n    @pytest.mark.asyncio\n    async def test_set_stable_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.set_stable(1,1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"UPDATE users SET stable_diffusion = %s WHERE user_id = %s\", (1, 1))\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_set_stable_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.set_stable(1,1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"UPDATE users SET stable_diffusion = %s WHERE user_id = %s\", (1, 1))\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestGetUserinfo:\n    @pytest.mark.asyncio\n    async def test_get_userinfo_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.return_value = (1,1,1)\n\n        database.pool.connection.return_value = mock_connection\n\n        result = await database.get_userinfo(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT chatgpt, dall_e, stable_diffusion FROM users WHERE user_id = %s\", (1, ))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\n        assert result == (1,1,1)\n\n    @pytest.mark.asyncio\n    async def test_get_userinfo_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.side_effect = Exception()\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            _ = await database.get_userinfo(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT chatgpt, dall_e, stable_diffusion FROM users WHERE user_id = %s\", (1,))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\nclass TestNewOrder:\n    @pytest.mark.asyncio\n    async def test_new_order_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.new_order(1,1, 'chatgpt')\n\n        mock_cursor.execute.assert_awaited_once_with(\"INSERT INTO orders(invoice_id, user_id, product) VALUES (%s, %s, %s)\", (1, 1, 'chatgpt'))\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_new_order_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.new_order(1,1, 'chatgpt')\n\n        mock_cursor.execute.assert_awaited_once_with(\"INSERT INTO orders(invoice_id, user_id, product) VALUES (%s, %s, %s)\", (1, 1, 'chatgpt'))\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestGetOrderdata:\n    @pytest.mark.asyncio\n    async def test_get_orderdata_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.return_value = (1,'chatgpt')\n\n        database.pool.connection.return_value = mock_connection\n\n        result = await database.get_orderdata(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT user_id, product FROM orders WHERE invoice_id = %s\", (1, ))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\n        assert result == (1,'chatgpt')\n\n    @pytest.mark.asyncio\n    async def test_get_orderdata_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchone.side_effect = Exception()\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            _ = await database.get_orderdata(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"SELECT user_id, product FROM orders WHERE invoice_id = %s\", (1, ))\n\n        mock_cursor.fetchone.assert_awaited_once_with()\n\nclass TestUpdateChatgpt:\n    @pytest.mark.asyncio\n    async def test_update_chatgpt_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.update_chatgpt(1,1)\n\n        mock_cursor.execute.assert_has_calls([call(\"UPDATE users SET chatgpt = chatgpt + 100000 WHERE user_id = %s\", (1, )),\n                                              call(\"DELETE FROM orders WHERE invoice_id = %s\", (1, ))])\n        assert len(mock_cursor.execute.mock_calls) == 2\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_update_chatgpt_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.update_chatgpt(1,1)\n\n        mock_cursor.execute.assert_has_calls([call(\"UPDATE users SET chatgpt = chatgpt + 100000 WHERE user_id = %s\", (1, )),\n                                              call(\"DELETE FROM orders WHERE invoice_id = %s\", (1, ))])\n\n        assert len(mock_cursor.execute.mock_calls) == 2\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestUpdateDallE:\n    @pytest.mark.asyncio\n    async def test_update_dalle_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.update_dalle(1,1)\n\n        mock_cursor.execute.assert_has_calls([call(\"UPDATE users SET dall_e = dall_e + 50 WHERE user_id = %s\", (1, )),\n                                              call(\"DELETE FROM orders WHERE invoice_id = %s\", (1, ))])\n        assert len(mock_cursor.execute.mock_calls) == 2\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_update_dalle_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.update_dalle(1,1)\n\n        mock_cursor.execute.assert_has_calls([call(\"UPDATE users SET dall_e = dall_e + 50 WHERE user_id = %s\", (1,)),\n                                              call(\"DELETE FROM orders WHERE invoice_id = %s\", (1,))])\n        assert len(mock_cursor.execute.mock_calls) == 2\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestUpdateStable:\n    @pytest.mark.asyncio\n    async def test_update_stable_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.update_stable(1,1)\n\n        mock_cursor.execute.assert_has_calls([call(\"UPDATE users SET stable_diffusion = stable_diffusion + 50 WHERE user_id = %s\", (1, )),\n                                              call(\"DELETE FROM orders WHERE invoice_id = %s\", (1, ))])\n        assert len(mock_cursor.execute.mock_calls) == 2\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_update_stable_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.update_stable(1,1)\n\n        mock_cursor.execute.assert_has_calls(\n            [call(\"UPDATE users SET stable_diffusion = stable_diffusion + 50 WHERE user_id = %s\", (1,)),\n             call(\"DELETE FROM orders WHERE invoice_id = %s\", (1,))])\n        assert len(mock_cursor.execute.mock_calls) == 2\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestSaveMessage:\n    @pytest.mark.asyncio\n    async def test_save_message_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.save_message(1,'user', 'message', 1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"INSERT INTO messages(user_id, role, content, tokens) VALUES (%s, %s, %s, %s)\", (1,'user', 'message', 1))\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_save_message_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.save_message(1,'user', 'message', 1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"INSERT INTO messages(user_id, role, content, tokens) VALUES (%s, %s, %s, %s)\", (1,'user', 'message', 1))\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestDeleteMessages:\n    @pytest.mark.asyncio\n    async def test_delete_messages_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        await database.delete_messages(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"DELETE FROM messages WHERE user_id = %s\", (1,))\n\n        mock_connection.commit.assert_awaited_once_with()\n\n    @pytest.mark.asyncio\n    async def test_delete_messages_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_connection.commit.side_effect = Exception()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            await database.delete_messages(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"DELETE FROM messages WHERE user_id = %s\", (1,))\n\n        mock_connection.commit.assert_awaited_once_with()\n\nclass TestGetMessages:\n    @pytest.mark.asyncio\n    async def test_get_messages_success(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchall.return_value = [(\"user\",\"message\",1)]\n\n        database.pool.connection.return_value = mock_connection\n\n        result = await database.get_messages(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"\"\"\n                    WITH cte AS (\n                        SELECT \n                            id, \n                            role, \n                            content, \n                            tokens,\n                            SUM(tokens) OVER (ORDER BY id DESC) AS tokens_total\n                        FROM messages\n                        WHERE user_id = %s\n                    )\n                    SELECT role, content, tokens_total\n                    FROM cte\n                    WHERE tokens_total <= 128000\n                    ORDER BY id ASC;\"\"\", (1,))\n\n        mock_cursor.fetchall.assert_awaited_once_with()\n\n        assert result == ([{'role': 'user', 'content': 'message'}], 1)\n\n    @pytest.mark.asyncio\n    async def test_get_messages_database_error(self):\n        database = DataBase(AsyncMock())\n\n        database.pool = MagicMock()\n\n        mock_connection = AsyncContextManager()\n\n        mock_cursor = AsyncContextManager()\n        mock_connection.cursor.return_value = mock_cursor\n\n        mock_cursor.fetchall.side_effect = Exception()\n\n        database.pool.connection.return_value = mock_connection\n\n        with pytest.raises(Exception):\n            _ = await database.get_messages(1)\n\n        mock_cursor.execute.assert_awaited_once_with(\"\"\"\n                    WITH cte AS (\n                        SELECT \n                            id, \n                            role, \n                            content, \n                            tokens,\n                            SUM(tokens) OVER (ORDER BY id DESC) AS tokens_total\n                        FROM messages\n                        WHERE user_id = %s\n                    )\n                    SELECT role, content, tokens_total\n                    FROM cte\n                    WHERE tokens_total <= 128000\n                    ORDER BY id ASC;\"\"\", (1,))\n\n        mock_cursor.fetchall.assert_awaited_once_with()"}
{"type": "test_file", "path": "tests/bot/test_answer_handlers.py", "content": "import pytest\nfrom unittest.mock import AsyncMock, MagicMock, call, patch\nfrom aiogram import types\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import KeyboardButton, ReplyKeyboardMarkup\n\nfrom app.bot.utils import encoding\nfrom app.bot.handlers.answer_handlers import AnswerHandlers\nfrom app.bot.utils import States\nfrom app.services.db import DatabaseError\n\nclass TestChatGpt:\n    @pytest.mark.asyncio\n    async def test_chatgpt_answer_handler_success(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_chatgpt.return_value = 1\n\n        mock_db.get_messages.return_value = [{\"role\": \"user\", \"content\": \"question\"}], 1\n\n        mock_openai.get_chatgpt.return_value = 'answer'\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        await handlers.chatgpt_answer_handler(message, state)\n\n        mock_db.get_chatgpt.assert_awaited_once_with(12345)\n\n        mock_openai.get_chatgpt.assert_awaited_once_with([{\"role\": \"user\", \"content\": \"question\"}])\n\n        mock_db.save_message.assert_has_calls([call(12345, \"user\", \"question\", len(encoding.encode(\"question\"))), call(12345, \"assistant\", \"answer\", len(encoding.encode(\"answer\")))])\n\n        assert len(mock_db.save_message.mock_calls) == 2\n\n        mock_db.get_messages.assert_awaited_once_with(12345)\n\n        mock_db.set_chatgpt.assert_awaited_once_with(12345, 0)\n\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer.assert_awaited_once_with(\n            text = \"answer\",\n            reply_markup = reply_markup,\n        )\n        state.set_state.assert_awaited_once_with(States.CHATGPT_STATE)\n\n    @pytest.mark.asyncio\n    async def test_chatgpt_safety_issue(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_chatgpt.return_value = 1\n\n        mock_db.get_messages.return_value = [{\"role\": \"user\", \"content\": \"question\"}], 1\n\n        mock_openai.get_chatgpt.return_value = ''\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        await handlers.chatgpt_answer_handler(message, state)\n\n        mock_db.get_chatgpt.assert_awaited_once_with(12345)\n\n        mock_openai.get_chatgpt.assert_awaited_once_with([{\"role\": \"user\", \"content\": \"question\"}])\n\n        mock_db.save_message.assert_awaited_once_with(12345, \"user\", \"question\", len(encoding.encode(\"question\")))\n\n        mock_db.get_messages.assert_awaited_once_with(12345)\n\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer.assert_awaited_once_with(\n            text = \"‚ùåYour request activated the API's safety filters and could not be processed. Please modify the prompt and try again.\",\n            reply_markup = reply_markup,\n        )\n        state.set_state.assert_awaited_once_with(States.CHATGPT_STATE)\n\n    @pytest.mark.asyncio\n    async def test_chatgpt_zero_tokens(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_chatgpt.return_value = 0\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        await handlers.chatgpt_answer_handler(message, state)\n\n        mock_db.get_chatgpt.assert_awaited_once_with(12345)\n\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer.assert_awaited_once_with(\n            text = \"‚ùéYou have 0 ChatGPT tokens. You need to buy them to use ChatGPT.\",\n            reply_markup = reply_markup,\n        )\n        state.set_state.assert_awaited_once_with(States.CHATGPT_STATE)\n\n    @pytest.mark.asyncio\n    async def test_chatgpt_database_error(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_chatgpt.side_effect = DatabaseError()\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        with pytest.raises(DatabaseError):\n            await handlers.chatgpt_answer_handler(message, state)\n\n        mock_db.get_chatgpt.assert_awaited_once_with(12345)\n\n    @pytest.mark.asyncio\n    async def test_chatgpt_answer_handler_telegram_error(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_chatgpt.return_value = 1\n\n        mock_db.get_messages.return_value = [{\"role\": \"user\", \"content\": \"question\"}], 1\n\n        mock_openai.get_chatgpt.return_value = 'answer'\n\n        message.answer.side_effect = Exception()\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        with pytest.raises(Exception):\n            await handlers.chatgpt_answer_handler(message, state)\n\n        mock_db.get_chatgpt.assert_awaited_once_with(12345)\n\n        mock_openai.get_chatgpt.assert_awaited_once_with([{\"role\": \"user\", \"content\": \"question\"}])\n\n        mock_db.save_message.assert_has_calls([call(12345, \"user\", \"question\", len(encoding.encode(\"question\"))), call(12345, \"assistant\", \"answer\", len(encoding.encode(\"answer\")))])\n\n        assert len(mock_db.save_message.mock_calls) == 2\n\n        mock_db.get_messages.assert_awaited_once_with(12345)\n\n        mock_db.set_chatgpt.assert_awaited_once_with(12345, 0)\n\nclass TestDallE:\n    @patch('app.bot.handlers.answer_handlers.translator.translate', new_callable=AsyncMock)\n    @pytest.mark.asyncio\n    async def test_dall_e_answer_handler_success(self, mock_translate):\n        message = AsyncMock(spec=types.Message)\n        message.answer_photo = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_dalle.return_value = 1\n\n        mock_translate.return_value = MagicMock(text=\"question\")\n\n        mock_openai.get_dalle.return_value = 'answer'\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        await handlers.dall_e_answer_handler(message, state)\n\n        mock_db.get_dalle.assert_awaited_once_with(12345)\n\n        mock_openai.get_dalle.assert_awaited_once_with(\"question\")\n\n        mock_db.set_dalle.assert_awaited_once_with(12345, 0)\n\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer_photo.assert_awaited_once_with(\n            photo=\"answer\",\n            reply_markup = reply_markup,\n            caption=\"question\",\n        )\n        state.set_state.assert_awaited_once_with(States.DALL_E_STATE)\n\n        mock_translate.assert_awaited_once_with(\"question\", targetlang='en')\n\n    @patch('app.bot.handlers.answer_handlers.translator.translate', new_callable=AsyncMock)\n    @pytest.mark.asyncio\n    async def test_dall_e_safety_issue(self, mock_translate):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_dalle.return_value = 1\n\n        mock_translate.return_value = MagicMock(text=\"question\")\n\n        mock_openai.get_dalle.return_value = ''\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        await handlers.dall_e_answer_handler(message, state)\n\n        mock_db.get_dalle.assert_awaited_once_with(12345)\n\n        mock_openai.get_dalle.assert_awaited_once_with(\"question\")\n\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer.assert_awaited_once_with(\n            text = \"‚ùåYour request activated the API's safety filters and could not be processed. Please modify the prompt and try again.\",\n            reply_markup = reply_markup,\n        )\n        state.set_state.assert_awaited_once_with(States.DALL_E_STATE)\n        mock_translate.assert_awaited_once_with(\"question\", targetlang='en')\n\n    @pytest.mark.asyncio\n    async def test_dall_e_zero_tokens(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_dalle.return_value = 0\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        await handlers.dall_e_answer_handler(message, state)\n\n        mock_db.get_dalle.assert_awaited_once_with(12345)\n\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer.assert_awaited_once_with(\n            text = \"‚ùéYou have 0 DALL¬∑E image generations. You need to buy them to use DALL¬∑E.\",\n            reply_markup = reply_markup,\n        )\n        state.set_state.assert_awaited_once_with(States.DALL_E_STATE)\n\n    @pytest.mark.asyncio\n    async def test_dall_e_database_error(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_dalle.side_effect = DatabaseError()\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        with pytest.raises(DatabaseError):\n            await handlers.dall_e_answer_handler(message, state)\n\n        mock_db.get_dalle.assert_awaited_once_with(12345)\n\n    @patch('app.bot.handlers.answer_handlers.translator.translate', new_callable=AsyncMock)\n    @pytest.mark.asyncio\n    async def test_dall_e_answer_handler_telegram_error(self, mock_translate):\n        message = AsyncMock(spec=types.Message)\n        message.answer_photo = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_openai = AsyncMock()\n\n        mock_db.get_dalle.return_value = 1\n\n        mock_translate.return_value = MagicMock(text=\"question\")\n\n        mock_openai.get_dalle.return_value = 'answer'\n\n        message.answer_photo.side_effect = Exception()\n\n        handlers = AnswerHandlers(mock_db, mock_openai, AsyncMock())\n\n        with pytest.raises(Exception):\n            await handlers.dall_e_answer_handler(message, state)\n\n        mock_db.get_dalle.assert_awaited_once_with(12345)\n\n        mock_openai.get_dalle.assert_awaited_once_with(\"question\")\n\n        mock_db.set_dalle.assert_awaited_once_with(12345, 0)\n\nclass TestStable:\n    @patch('app.bot.handlers.answer_handlers.translator.translate', new_callable=AsyncMock)\n    @patch('app.bot.handlers.answer_handlers.BufferedInputFile')\n    @pytest.mark.asyncio\n    async def test_stable_answer_handler_success(self, mock_buffer, mock_translate):\n        message = AsyncMock(spec=types.Message)\n        message.answer_photo = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_stable = AsyncMock()\n\n        mock_db.get_stable.return_value = 1\n\n        mock_translate.return_value = MagicMock(text=\"question\")\n\n        mock_stable.get_stable.return_value = 'answer'\n\n        mock_buffer.return_value = \"answer\"\n\n        handlers = AnswerHandlers(mock_db, AsyncMock(), mock_stable)\n\n        await handlers.stable_answer_handler(message, state)\n\n        mock_db.get_stable.assert_awaited_once_with(12345)\n\n        mock_stable.get_stable.assert_awaited_once_with(\"question\")\n\n        mock_db.set_stable.assert_awaited_once_with(12345, 0)\n\n        mock_buffer.assert_called_once_with(\"answer\", 'image.jpeg')\n\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer_photo.assert_awaited_once_with(\n            photo=\"answer\",\n            reply_markup = reply_markup,\n            caption=\"question\",\n        )\n        state.set_state.assert_awaited_once_with(States.STABLE_STATE)\n\n        mock_translate.assert_awaited_once_with(\"question\", targetlang='en')\n\n    @patch('app.bot.handlers.answer_handlers.translator.translate', new_callable=AsyncMock)\n    @pytest.mark.asyncio\n    async def test_stable_safety_issue(self, mock_translate):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_stable = AsyncMock()\n\n        mock_db.get_stable.return_value = 1\n\n        mock_translate.return_value = MagicMock(text=\"question\")\n\n        mock_stable.get_stable.return_value = ''\n\n        handlers = AnswerHandlers(mock_db, AsyncMock(), mock_stable)\n\n        await handlers.stable_answer_handler(message, state)\n\n        mock_db.get_stable.assert_awaited_once_with(12345)\n\n        mock_stable.get_stable.assert_awaited_once_with(\"question\")\n\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer.assert_awaited_once_with(\n            text = \"‚ùåYour request activated the API's safety filters and could not be processed. Please modify the prompt and try again.\",\n            reply_markup = reply_markup,\n        )\n        state.set_state.assert_awaited_once_with(States.STABLE_STATE)\n        mock_translate.assert_awaited_once_with(\"question\", targetlang='en')\n\n    @pytest.mark.asyncio\n    async def test_stable_zero_tokens(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_stable = AsyncMock()\n\n        mock_db.get_stable.return_value = 0\n\n        handlers = AnswerHandlers(mock_db, AsyncMock(), mock_stable)\n\n        await handlers.stable_answer_handler(message, state)\n\n        mock_db.get_stable.assert_awaited_once_with(12345)\n\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard=button, resize_keyboard=True\n        )\n        message.answer.assert_awaited_once_with(\n            text = \"‚ùéYou have 0 Stable Diffusion image generations. You need to buy them to use Stable Diffusion.\",\n            reply_markup = reply_markup,\n        )\n        state.set_state.assert_awaited_once_with(States.STABLE_STATE)\n\n    @pytest.mark.asyncio\n    async def test_stable_database_error(self):\n        message = AsyncMock(spec=types.Message)\n        message.answer = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_stable = AsyncMock()\n\n        mock_db.get_stable.side_effect = DatabaseError()\n\n        handlers = AnswerHandlers(mock_db, AsyncMock(), mock_stable)\n\n        with pytest.raises(DatabaseError):\n            await handlers.stable_answer_handler(message, state)\n\n        mock_db.get_stable.assert_awaited_once_with(12345)\n\n    @patch('app.bot.handlers.answer_handlers.translator.translate', new_callable=AsyncMock)\n    @patch('app.bot.handlers.answer_handlers.BufferedInputFile')\n    @pytest.mark.asyncio\n    async def test_stable_answer_handler_telegram_error(self, mock_buffer, mock_translate):\n        message = AsyncMock(spec=types.Message)\n        message.answer_photo = AsyncMock()\n        message.from_user = MagicMock(id=12345)\n        message.text = \"question\"\n\n        state = AsyncMock(spec=FSMContext)\n        state.set_state = AsyncMock()\n\n        mock_db = AsyncMock()\n        mock_stable = AsyncMock()\n\n        mock_db.get_stable.return_value = 1\n\n        mock_translate.return_value = MagicMock(text=\"question\")\n\n        mock_stable.get_stable.return_value = 'answer'\n\n        mock_buffer.return_value = \"answer\"\n\n        message.answer_photo.side_effect = Exception()\n\n        handlers = AnswerHandlers(mock_db, AsyncMock(), mock_stable)\n\n        with pytest.raises(Exception):\n            await handlers.stable_answer_handler(message, state)\n\n        mock_db.get_stable.assert_awaited_once_with(12345)\n\n        mock_stable.get_stable.assert_awaited_once_with(\"question\")\n\n        mock_db.set_stable.assert_awaited_once_with(12345, 0)\n\n        mock_buffer.assert_called_once_with(\"answer\", 'image.jpeg')"}
{"type": "test_file", "path": "tests/core/test_database.py", "content": "import pytest\nfrom unittest.mock import AsyncMock\n\nfrom app.core.database import DataBaseCore\n\nclass TestOpenPool:\n    @pytest.mark.asyncio\n    async def test_open_pool_success(self):\n        dbcore = DataBaseCore('conninfo')\n        dbcore.pool = AsyncMock()\n\n        await dbcore.open_pool()\n\n        dbcore.pool.open.assert_awaited_once_with()\n        dbcore.pool.wait.assert_awaited_once_with()\n\nclass TestClosePool:\n    @pytest.mark.asyncio\n    async def test_open_pool_success(self):\n        dbcore = DataBaseCore('conninfo')\n        dbcore.pool = AsyncMock()\n\n        await dbcore.close_pool()\n\n        dbcore.pool.close.assert_awaited_once_with()"}
{"type": "test_file", "path": "tests/bot/test_start.py", "content": "import pytest\nfrom unittest.mock import AsyncMock, MagicMock\nfrom aiogram import types\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import KeyboardButton, ReplyKeyboardMarkup\n\nfrom app.bot.handlers.start import StartHandler\nfrom app.bot.utils import States\nfrom app.services.db import DatabaseError\n\n@pytest.mark.asyncio\nasync def test_start_handler_success_notuser():\n    message = AsyncMock(spec=types.Message)\n    message.answer = AsyncMock()\n    message.from_user = MagicMock(id=12345)\n\n    state = AsyncMock(spec=FSMContext)\n    state.set_state = AsyncMock()\n\n    mock_db = AsyncMock()\n    mock_db.is_user.return_value = None\n\n    handler = StartHandler(mock_db)\n\n    await handler.start_handler(message, state)\n\n    mock_db.delete_messages.assert_awaited_once_with(12345)\n\n    mock_db.is_user.assert_awaited_once_with(12345)\n\n    button = [[KeyboardButton(text=\"üí≠Chatting ‚Äî ChatGPT-4o\")],\n              [KeyboardButton(text=\"üåÑImage generation ‚Äî DALL¬∑E 3\")],\n              [KeyboardButton(text=\"üåÖImage generation ‚Äî Stable Diffusion 3\")],\n              [KeyboardButton(text=\"üë§My account | üí∞Buy\")]]\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard=button, resize_keyboard=True\n    )\n    message.answer.assert_awaited_once_with(\n        text = \"üëãYou have: \\nüí≠3000 ChatGPT tokens \\nüåÑ3 DALL¬∑E Image generations \\nüåÖ3 Stable Diffusion Image generations\\n Choose an option: üëá \\n If buttons don't work, enter /start command\",\n        reply_markup= reply_markup,\n    )\n    state.set_state.assert_awaited_once_with(States.ENTRY_STATE)\n\n@pytest.mark.asyncio\nasync def test_start_handler_success_isuser():\n    message = AsyncMock(spec=types.Message)\n    message.answer = AsyncMock()\n    message.from_user = MagicMock(id=12345)\n\n    state = AsyncMock(spec=FSMContext)\n    state.set_state = AsyncMock()\n\n    mock_db = AsyncMock()\n    mock_db.is_user.return_value = 1\n\n    handler = StartHandler(mock_db)\n\n    await handler.start_handler(message, state)\n\n    mock_db.delete_messages.assert_awaited_once_with(12345)\n\n    mock_db.is_user.assert_awaited_once_with(12345)\n\n    button = [[KeyboardButton(text=\"üí≠Chatting ‚Äî ChatGPT-4o\")],\n              [KeyboardButton(text=\"üåÑImage generation ‚Äî DALL¬∑E 3\")],\n              [KeyboardButton(text=\"üåÖImage generation ‚Äî Stable Diffusion 3\")],\n              [KeyboardButton(text=\"üë§My account | üí∞Buy\")]]\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard=button, resize_keyboard=True\n    )\n    message.answer.assert_awaited_once_with(\n        text = \"Choose an option: üëáüèª \\n If buttons don't work, enter /start command\",\n        reply_markup= reply_markup,\n    )\n    state.set_state.assert_awaited_once_with(States.ENTRY_STATE)\n\n@pytest.mark.asyncio\nasync def test_start_handler_database_error():\n    message = AsyncMock(spec=types.Message)\n    message.answer = AsyncMock()\n    message.from_user = MagicMock(id=12345)\n\n    state = AsyncMock(spec=FSMContext)\n    state.set_state = AsyncMock()\n\n    mock_db = AsyncMock()\n    mock_db.is_user.side_effect = DatabaseError()\n\n    handler = StartHandler(mock_db)\n\n    with pytest.raises(DatabaseError):\n        await handler.start_handler(message, state)\n\n@pytest.mark.asyncio\nasync def test_start_handler_telegram_error():\n    message = AsyncMock(spec=types.Message)\n    message.answer = AsyncMock()\n    message.answer.side_effect = Exception()\n    message.from_user = MagicMock(id=12345)\n\n    state = AsyncMock(spec=FSMContext)\n    state.set_state = AsyncMock()\n\n    mock_db = AsyncMock()\n    mock_db.is_user.return_value = None\n\n    handler = StartHandler(mock_db)\n\n    with pytest.raises(Exception):\n        await handler.start_handler(message, state)\n\n    mock_db.delete_messages.assert_awaited_once_with(12345)\n\n    mock_db.is_user.assert_awaited_once_with(12345)"}
{"type": "test_file", "path": "tests/services/test_payment_successful.py", "content": "import pytest\nfrom unittest.mock import AsyncMock\n\nfrom app.services.payment_successful import payment_success\n\nfrom app.services.db import DatabaseError\n\n@pytest.mark.asyncio\nasync def test_payment_success_success():\n    mock_bot = AsyncMock()\n    mock_db = AsyncMock()\n\n    update_type = \"invoice_paid\"\n\n    invoice_id = 1\n\n    mock_db.get_orderdata.return_value = (1, 'chatgpt')\n\n    await payment_success(mock_bot, mock_db, update_type, invoice_id)\n\n    mock_db.get_orderdata.assert_awaited_once_with(1)\n\n    mock_db.update_chatgpt.assert_awaited_once_with(1, 1)\n\n    mock_bot.send_message.assert_awaited_once_with(1, \"‚úÖYou have received 100000 ChatGPT tokens!\")\n\n@pytest.mark.asyncio\nasync def test_payment_success_database_error():\n    mock_bot = AsyncMock()\n    mock_db = AsyncMock()\n\n    update_type = \"invoice_paid\"\n\n    invoice_id = 1\n\n    mock_db.get_orderdata.side_effect = DatabaseError()\n\n    with pytest.raises(DatabaseError):\n        await payment_success(mock_bot, mock_db, update_type, invoice_id)\n\n    mock_db.get_orderdata.assert_awaited_once_with(1)\n\n@pytest.mark.asyncio\nasync def test_payment_success_telegram_error():\n    mock_bot = AsyncMock()\n    mock_db = AsyncMock()\n\n    update_type = \"invoice_paid\"\n\n    invoice_id = 1\n\n    mock_db.get_orderdata.return_value = (1, 'dall_e')\n\n    mock_bot.send_message.side_effect = Exception()\n\n    with pytest.raises(Exception):\n        await payment_success(mock_bot, mock_db, update_type, invoice_id)\n\n    mock_db.get_orderdata.assert_awaited_once_with(1)\n\n    mock_db.update_dalle.assert_awaited_once_with(1, 1)\n\n    mock_bot.send_message.assert_awaited_once_with(1, \"‚úÖYou have received 50 DALL¬∑E image generations!\")"}
{"type": "test_file", "path": "tests/services/test_cryptopay.py", "content": "import pytest\nfrom unittest.mock import AsyncMock\n\nfrom app.services.cryptopay import CryptoPay\n\nclass Rate:\n    def __init__(self, source, target, rate):\n        self.source = source\n        self.target = target\n        self.rate = rate\n\nclass Invoice:\n    def __init__(self, bot_invoice_url, invoice_id):\n        self.bot_invoice_url = bot_invoice_url\n        self.invoice_id = invoice_id\n\nclass TestGetPrice:\n    @pytest.mark.asyncio\n    async def test_getprice_success(self):\n        crypto = CryptoPay('token')\n        crypto.crypto = AsyncMock()\n\n        crypto.crypto.get_exchange_rates = AsyncMock()\n\n        rate = Rate('TON', 'USD', 1)\n        crypto.crypto.get_exchange_rates.return_value = [rate]\n\n        cost = await crypto.getprice(5, 'TON')\n\n        crypto.crypto.get_exchange_rates.assert_awaited_once_with()\n\n        assert cost == 5\n\n    @pytest.mark.asyncio\n    async def test_getprice_cryptopay_error(self):\n        crypto = CryptoPay('token')\n        crypto.crypto = AsyncMock()\n\n        crypto.crypto.get_exchange_rates = AsyncMock()\n\n        crypto.crypto.get_exchange_rates.side_effect = Exception()\n\n        with pytest.raises(Exception):\n            _ = await crypto.getprice(5, 'TON')\n\nclass TestCreateInvoice:\n    @pytest.mark.asyncio\n    async def test_create_invoice_success(self):\n        crypto = CryptoPay('token')\n        crypto.crypto = AsyncMock()\n        crypto.getprice = AsyncMock()\n        crypto.getprice.return_value = 5\n\n        crypto.crypto.create_invoice = AsyncMock()\n\n        invoice = Invoice('url', 1)\n        crypto.crypto.create_invoice.return_value = invoice\n\n        invoice_url, invoice_id = await crypto.create_invoice(5, 'TON')\n\n        crypto.getprice.assert_awaited_once_with(5, 'TON')\n        crypto.crypto.create_invoice.assert_awaited_once_with(asset='TON', amount=5)\n\n        assert invoice_url == 'url'\n        assert invoice_id == 1\n\n    @pytest.mark.asyncio\n    async def test_create_invoice_cryptopay_error(self):\n        crypto = CryptoPay('token')\n        crypto.crypto = AsyncMock()\n        crypto.getprice = AsyncMock()\n        crypto.getprice.side_effect = Exception()\n\n        with pytest.raises(Exception):\n            _, _ = await crypto.create_invoice(5, 'TON')\n\n        crypto.getprice.assert_awaited_once_with(5, 'TON')"}
{"type": "test_file", "path": "tests/services/test_openaitools.py", "content": "import pytest\nfrom unittest.mock import AsyncMock, MagicMock\n\nfrom app.services.openaitools import OpenAiTools\n\nclass Response:\n    def __init__(self, content: str):\n        self.choices = [Message(content)]\n        self.data = [Message(content)]\n\nclass Message:\n    def __init__(self, content: str):\n        self.message = Content(content)\n        self.url = content\n\nclass Content:\n    def __init__(self, content: str):\n        self.content = content\n\nclass TestGetChatgpt:\n    @pytest.mark.asyncio\n    async def test_get_chatgpt_success(self):\n        openai = OpenAiTools('token')\n        openai.client = MagicMock()\n        openai.client.chat = MagicMock()\n        openai.client.chat.completions = MagicMock()\n        openai.client.chat.completions.create = AsyncMock()\n        openai.client.chat.completions.create.return_value = Response('answer')\n\n        answer = await openai.get_chatgpt([])\n\n        openai.client.chat.completions.create.assert_awaited_once_with(\n            messages=[],\n            model=\"gpt-4o\",\n            max_tokens=16384,\n            temperature=1,\n        )\n\n        assert answer == 'answer'\n\n    @pytest.mark.asyncio\n    async def test_get_chatgpt_error(self):\n        openai = OpenAiTools('token')\n        openai.client = MagicMock()\n        openai.client.chat = MagicMock()\n        openai.client.chat.completions = MagicMock()\n        openai.client.chat.completions.create = AsyncMock()\n        openai.client.chat.completions.create.side_effect = Exception()\n\n        answer = await openai.get_chatgpt([])\n\n        openai.client.chat.completions.create.assert_awaited_once_with(\n            messages=[],\n            model=\"gpt-4o\",\n            max_tokens=16384,\n            temperature=1,\n        )\n\n        assert answer == None\n\nclass TestGetDallE:\n    @pytest.mark.asyncio\n    async def test_get_dalle_success(self):\n        openai = OpenAiTools('token')\n        openai.client = MagicMock()\n        openai.client.images = MagicMock()\n        openai.client.images.generate = AsyncMock()\n        openai.client.images.generate.return_value = Response('answer')\n\n        answer = await openai.get_dalle('question')\n\n        openai.client.images.generate.assert_awaited_once_with(\n            model=\"dall-e-3\",\n            prompt='question',\n            size=\"1024x1024\",\n            n=1,\n        )\n\n        assert answer == 'answer'\n\n    @pytest.mark.asyncio\n    async def test_get_dalle_error(self):\n        openai = OpenAiTools('token')\n        openai.client = MagicMock()\n        openai.client.images = MagicMock()\n        openai.client.images.generate = AsyncMock()\n        openai.client.images.generate.side_effect = Exception()\n\n        answer = await openai.get_dalle('question')\n\n        openai.client.images.generate.assert_awaited_once_with(\n            model=\"dall-e-3\",\n            prompt='question',\n            size=\"1024x1024\",\n            n=1,\n        )\n\n        assert answer == None"}
{"type": "test_file", "path": "tests/bot/test_question.py", "content": "import pytest\nfrom unittest.mock import AsyncMock\nfrom aiogram import types\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import KeyboardButton, ReplyKeyboardMarkup\n\nfrom app.bot.handlers.question import question_handler\nfrom app.bot.utils import States\n\n@pytest.mark.asyncio\nasync def test_question_handler_success():\n    message = AsyncMock(spec=types.Message)\n    message.text = \"üí≠Chatting ‚Äî ChatGPT-4o\"\n    message.answer = AsyncMock()\n\n    state = AsyncMock(spec=FSMContext)\n    state.set_state = AsyncMock()\n\n    await question_handler(message, state)\n\n    button = [[KeyboardButton(text=\"üîôBack\")]]\n    reply_markup = ReplyKeyboardMarkup(\n        keyboard=button, resize_keyboard=True\n    )\n    message.answer.assert_awaited_once_with(\n        text = \"Enter your text: üëáüèª\",\n        reply_markup= reply_markup,\n    )\n    state.set_state.assert_awaited_once_with(States.CHATGPT_STATE)\n\n@pytest.mark.asyncio\nasync def test_question_handler_telegram_error():\n    message = AsyncMock(spec=types.Message)\n    message.text = \"üí≠Chatting ‚Äî ChatGPT-4o\"\n    message.answer = AsyncMock()\n    message.answer.side_effect = Exception()\n\n    state = AsyncMock(spec=FSMContext)\n    state.set_state = AsyncMock()\n\n    with pytest.raises(Exception):\n        await question_handler(message, state)"}
{"type": "source_file", "path": "app/api/setup.py", "content": "from fastapi import APIRouter\nfrom app.api.routes.routes import Handlers\nfrom aiogram import Bot, Dispatcher\nfrom app.services.db import DataBase\n\n\ndef register_routes(router: APIRouter, database: DataBase, dp: Dispatcher, bot: Bot, telegram_token: str, cryptopay_token: str):\n    routes_class = Handlers(database, dp, bot)\n\n    router.add_api_route(\"/\" + telegram_token, routes_class.bot_webhook, methods=[\"POST\"])\n    router.add_api_route(\"/\" + cryptopay_token, routes_class.payments_webhook, methods=[\"POST\"])"}
{"type": "source_file", "path": "app/api/models.py", "content": "from pydantic import BaseModel\n\nclass InvoicePayload(BaseModel):\n    invoice_id: int\n\nclass PaymentsRequestModel(BaseModel):\n    update_type: str\n    payload: InvoicePayload"}
{"type": "source_file", "path": "app/api/routes/routes.py", "content": "from aiogram import Bot, Dispatcher, types\nfrom fastapi import Request\nfrom fastapi.responses import PlainTextResponse, JSONResponse\nfrom pydantic import ValidationError\n\nfrom app.api.models import PaymentsRequestModel\nfrom app.bot.utils import TelegramError\nfrom app.services.cryptopay import CryptoPayError\nfrom app.services.db import DataBase, DatabaseError\nfrom app.services.payment_successful import payment_success\nimport logging\n\nclass Handlers:\n    def __init__(self, database: DataBase, dp: Dispatcher, bot: Bot):\n        self.database = database\n        self.dp = dp\n        self.bot = bot\n\n    async def payments_webhook(self, request: Request) -> PlainTextResponse:\n        try:\n            validated_data = PaymentsRequestModel(** await request.json())\n            await payment_success(self.bot, self.database, validated_data.update_type, validated_data.payload.invoice_id)\n            return PlainTextResponse('OK', status_code=200)\n        except ValidationError:\n            return PlainTextResponse('Wrong request', status_code=400)\n        except DatabaseError:\n            return PlainTextResponse('Database Error', status_code=500)\n        except TelegramError:\n            return PlainTextResponse('Telegram Error', status_code=500)\n        except Exception as e:\n            logging.exception(e)\n            return PlainTextResponse('Error', status_code=500)\n\n    async def bot_webhook(self, request: Request) -> JSONResponse:\n        try:\n            update = types.Update(**await request.json())\n            await self.dp.feed_webhook_update(self.bot, update)\n            return JSONResponse(content={\"status\": \"ok\"})\n        except ValueError:\n            return JSONResponse(content={\"message\": \"Wrong request\"}, status_code=400)\n        except DatabaseError:\n            return JSONResponse(content={\"message\": \"database error\"}, status_code=500)\n        except CryptoPayError:\n            return JSONResponse(content={\"message\": \"cryptopay error\"}, status_code=500)\n        except TelegramError:\n            return JSONResponse(content={\"message\": \"telegram error\"}, status_code=500)\n        except Exception as e:\n            logging.exception(e)\n            return JSONResponse(content={\"message\": \"error\"}, status_code=500)"}
{"type": "source_file", "path": "app/bot/handlers/answer_handlers.py", "content": "from app.bot.utils import States, translator, TelegramError, encoding\n\nfrom app.services.stablediffusion import StableDiffusion\nfrom app.services.openaitools import OpenAiTools\n\nfrom aiogram import types\n\nfrom aiogram.types import ReplyKeyboardMarkup, KeyboardButton\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types.input_file import BufferedInputFile\n\nfrom app.services.db import DataBase, DatabaseError\n\nclass AnswerHandlers:\n    def __init__(self, database: DataBase, openai: OpenAiTools, stable: StableDiffusion):\n        self.database = database\n        self.openai = openai\n        self.stable = stable\n\n    async def chatgpt_answer_handler(self, message: types.Message, state: FSMContext):\n        try:\n            button = [[KeyboardButton(text=\"üîôBack\")]]\n            reply_markup = ReplyKeyboardMarkup(\n                keyboard = button, resize_keyboard=True\n            )\n\n            user_id = message.from_user.id\n            result = await self.database.get_chatgpt(user_id)\n\n            if result > 0:\n                await self.database.save_message(user_id, \"user\", message.text, len(encoding.encode(message.text)))\n\n                messages, question_tokens = await self.database.get_messages(user_id)\n\n                answer = await self.openai.get_chatgpt(messages)\n\n                if answer:\n                    answer_tokens = len(encoding.encode(answer))\n                    await self.database.save_message(user_id, \"assistant\", answer, answer_tokens)\n\n                    result -= int(question_tokens*0.25 + answer_tokens)\n\n                    if result > 0:\n                        await self.database.set_chatgpt(user_id, result)\n                    else:\n                        await self.database.set_chatgpt(user_id, 0)\n\n                    await message.answer(\n                        text = answer,\n                        reply_markup=reply_markup,\n                    )\n                else:\n                    await message.answer(\n                        text = \"‚ùåYour request activated the API's safety filters and could not be processed. Please modify the prompt and try again.\",\n                        reply_markup=reply_markup,\n                    )\n\n            else:\n                await message.answer(\n                    text = \"‚ùéYou have 0 ChatGPT tokens. You need to buy them to use ChatGPT.\",\n                    reply_markup=reply_markup,\n                )\n            await state.set_state(States.CHATGPT_STATE)\n        except DatabaseError:\n            raise DatabaseError\n        except Exception as e:\n            err = TelegramError(str(e))\n            err.output()\n            raise err\n\n    async def dall_e_answer_handler(self, message: types.Message, state: FSMContext):\n        try:\n            button = [[KeyboardButton(text=\"üîôBack\")]]\n            reply_markup = ReplyKeyboardMarkup(\n                keyboard = button, resize_keyboard=True\n            )\n\n            user_id = message.from_user.id\n            result = await self.database.get_dalle(user_id)\n\n            if result > 0:\n                question = message.text\n\n                prompt = await translator.translate(question, targetlang='en')\n\n                answer = await self.openai.get_dalle(prompt.text)\n\n                if answer:\n                    result -= 1\n                    await self.database.set_dalle(user_id, result)\n                    await message.answer_photo(\n                        photo=answer,\n                        reply_markup=reply_markup,\n                        caption=question,\n                    )\n                else:\n                    await message.answer(\n                        text = \"‚ùåYour request activated the API's safety filters and could not be processed. Please modify the prompt and try again.\",\n                        reply_markup=reply_markup,\n                    )\n            else:\n                await message.answer(\n                    text = \"‚ùéYou have 0 DALL¬∑E image generations. You need to buy them to use DALL¬∑E.\",\n                    reply_markup=reply_markup,\n                )\n            await state.set_state(States.DALL_E_STATE)\n        except DatabaseError:\n            raise DatabaseError\n        except Exception as e:\n            err = TelegramError(str(e))\n            err.output()\n            raise err\n\n    async def stable_answer_handler(self, message: types, state: FSMContext):\n        try:\n            button = [[KeyboardButton(text=\"üîôBack\")]]\n            reply_markup = ReplyKeyboardMarkup(\n                keyboard = button, resize_keyboard=True\n            )\n\n            user_id = message.from_user.id\n            result = await self.database.get_stable(user_id)\n\n            if result > 0:\n\n                question = message.text\n\n                prompt = await translator.translate(question, targetlang='en')\n\n                photo = await self.stable.get_stable(prompt.text)\n\n                if photo:\n                    result -= 1\n                    await self.database.set_stable(user_id, result)\n                    await message.answer_photo(\n                        photo=BufferedInputFile(photo, 'image.jpeg'),\n                        reply_markup=reply_markup,\n                        caption=question,\n                    )\n                else:\n                    await message.answer(\n                        text = \"‚ùåYour request activated the API's safety filters and could not be processed. Please modify the prompt and try again.\",\n                        reply_markup=reply_markup,\n                    )\n            else:\n                await message.answer(\n                    text = \"‚ùéYou have 0 Stable Diffusion image generations. You need to buy them to use Stable Diffusion.\",\n                    reply_markup=reply_markup,\n                )\n            await state.set_state(States.STABLE_STATE)\n        except DatabaseError:\n            raise DatabaseError\n        except Exception as e:\n            err = TelegramError(str(e))\n            err.output()\n            raise err"}
{"type": "source_file", "path": "app/bot/handlers/question.py", "content": "from app.bot.utils import States, TelegramError\n\nfrom aiogram import types\n\nfrom aiogram.types import ReplyKeyboardMarkup, KeyboardButton\nfrom aiogram.fsm.context import FSMContext\n\nasync def question_handler(message: types.Message, state: FSMContext):\n    try:\n        button = [[KeyboardButton(text=\"üîôBack\")]]\n        reply_markup = ReplyKeyboardMarkup(\n            keyboard = button, resize_keyboard=True\n        )\n        await message.answer(\n            text = \"Enter your text: üëáüèª\",\n            reply_markup=reply_markup,\n        )\n        option = message.text\n        if option == \"üí≠Chatting ‚Äî ChatGPT-4o\":\n            await state.set_state(States.CHATGPT_STATE)\n        elif option == \"üåÑImage generation ‚Äî DALL¬∑E 3\":\n            await state.set_state(States.DALL_E_STATE)\n        elif option == \"üåÖImage generation ‚Äî Stable Diffusion 3\":\n            await state.set_state(States.STABLE_STATE)\n    except Exception as e:\n        err = TelegramError(str(e))\n        err.output()\n        raise err"}
{"type": "source_file", "path": "app/bot/handlers/purchase_handlers.py", "content": "from app.bot.utils import States, TelegramError\n\nfrom app.services.cryptopay import CryptoPay, CryptoPayError\n\nfrom aiogram import types\n\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, KeyboardButton, ReplyKeyboardMarkup\nfrom aiogram.fsm.context import FSMContext\n\nfrom app.services.db import DataBase, DatabaseError\n\nclass PurchaseHandlers:\n    def __init__(self, database: DataBase, crypto: CryptoPay):\n        self.database = database\n        self.crypto = crypto\n\n    async def buy_handler(self, message: types.Message, state: FSMContext):\n        try:\n            user_id = message.from_user.id\n            currency = message.text\n            invoice_url, invoice_id = await self.crypto.create_invoice(5, currency[1:])\n            current_state = await state.get_state()\n            product = ''\n            if current_state == States.PURCHASE_CHATGPT_STATE:\n                product = '100K ChatGPT tokens - 5 USDüíµ'\n                await self.database.new_order(invoice_id, user_id, 'chatgpt')\n            elif current_state == States.PURCHASE_DALL_E_STATE:\n                product = '50 DALL¬∑E image generations - 5 USDüíµ'\n                await self.database.new_order(invoice_id, user_id, 'dall_e')\n            elif current_state == States.PURCHASE_STABLE_STATE:\n                product = '50 Stable Diffusion image generations - 5 USDüíµ'\n                await self.database.new_order(invoice_id, user_id, 'stable')\n            keyboard = InlineKeyboardMarkup(\n                inline_keyboard = [[InlineKeyboardButton(text=\"üí∞Buy\", url=invoice_url)]]\n            )\n            await message.answer(\n                text = f\"ü™ôProduct: {product} \\n üí≥If you want to pay click the button 'Buy', click button 'Start' in Crypto Bot and follow the instructions \\n ‚ùóConsider the network commission\",\n                reply_markup=keyboard,\n            )\n        except CryptoPayError:\n            raise CryptoPayError\n        except DatabaseError:\n            raise DatabaseError\n        except Exception as e:\n            err = TelegramError(str(e))\n            err.output()\n            raise err\n\n    async def currencies_handler(self, message: types.Message, state: FSMContext):\n        try:\n            buttons = [\n                [KeyboardButton(text=\"üí≤USDT\"),\n                KeyboardButton(text=\"üí≤TON\")],\n                [KeyboardButton(text=\"üí≤BTC\"),\n                KeyboardButton(text=\"üí≤ETH\")],\n                [KeyboardButton(text=\"üîôBack\")]\n            ]\n            keyboard = ReplyKeyboardMarkup(\n                keyboard = buttons,\n                resize_keyboard=True\n            )\n            await message.answer(\n                text = \"Choose currency: üëá\",\n                reply_markup=keyboard,\n            )\n            product = message.text\n            if product == \"100K ChatGPT tokens - 5 USDüíµ\":\n                await state.set_state(States.PURCHASE_CHATGPT_STATE)\n            elif product == \"50 DALL¬∑E image generations - 5 USDüíµ\":\n                await state.set_state(States.PURCHASE_DALL_E_STATE)\n            elif product == \"50 Stable Diffusion image generations - 5 USDüíµ\":\n                await state.set_state(States.PURCHASE_STABLE_STATE)\n        except Exception as e:\n            err = TelegramError(str(e))\n            err.output()\n            raise err\n\n    async def purchase_handler(self, message: types.Message, state: FSMContext):\n        try:\n            button = [[KeyboardButton(text=\"100K ChatGPT tokens - 5 USDüíµ\")],\n                      [KeyboardButton(text=\"50 DALL¬∑E image generations - 5 USDüíµ\")],\n                      [KeyboardButton(text=\"50 Stable Diffusion image generations - 5 USDüíµ\")],\n                      [KeyboardButton(text=\"üîôBack\")]]\n            reply_markup = ReplyKeyboardMarkup(\n                keyboard = button, resize_keyboard=True\n            )\n            await message.answer(\n                text = \"Choose product: üëá\",\n                reply_markup=reply_markup,\n            )\n            await state.set_state(States.PURCHASE_STATE)\n        except Exception as e:\n            err = TelegramError(str(e))\n            err.output()\n            raise err"}
{"type": "source_file", "path": "app/application.py", "content": "from app.services.db import DataBase\nfrom app.services.cryptopay import CryptoPay\nfrom app.services.openaitools import OpenAiTools\nfrom app.services.stablediffusion import StableDiffusion\n\nfrom dotenv import load_dotenv\n\nimport os\n\nfrom fastapi import FastAPI, APIRouter\nimport uvicorn\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.enums import ParseMode\nfrom aiogram.client.bot import DefaultBotProperties\n\nfrom app.bot.setup import register_handlers\n\nfrom app.api.setup import register_routes\n\nfrom app.core.database import DataBaseCore\n\ndef run():\n    load_dotenv()\n\n    dp = Dispatcher()\n\n    app = FastAPI()\n\n    cryptopay = CryptoPay(os.getenv(\"CRYPTOPAY_KEY\"))\n\n    database_core = DataBaseCore(os.getenv(\"DATABASE_URL\"))\n\n    database = DataBase(database_core.pool)\n\n    openai = OpenAiTools(os.getenv(\"OPENAI_API_KEY\"))\n\n    stable = StableDiffusion(os.getenv(\"STABLE_DIFFUSION_API_KEY\"))\n\n    register_handlers(dp, database, openai, stable, cryptopay)\n\n    bot = Bot(token=os.getenv(\"TELEGRAM_BOT_TOKEN\"), default=DefaultBotProperties(parse_mode=ParseMode.HTML))\n\n    router = APIRouter()\n\n    register_routes(router, database, dp, bot, os.getenv(\"TELEGRAM_BOT_TOKEN\"), os.getenv(\"CRYPTOPAY_KEY\"))\n\n    app.include_router(router)\n\n    def on_startup_handler(database_core: DataBaseCore, database: DataBase):\n        async def on_startup() -> None:\n            await database_core.open_pool()\n            await database.create_tables()\n            url_webhook = os.getenv(\"BASE_WEBHOOK_URL\") + os.getenv(\"TELEGRAM_BOT_TOKEN\")\n            await bot.set_webhook(url=url_webhook)\n\n        return on_startup\n\n    app.add_event_handler(\"startup\", on_startup_handler(database_core, database))\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", 5000)))\n"}
{"type": "source_file", "path": "app/core/database.py", "content": "from psycopg_pool import AsyncConnectionPool\n\nclass DataBaseCore:\n    def __init__(self, conninfo: str):\n        self.pool = AsyncConnectionPool(conninfo=conninfo, timeout = 10, max_lifetime=600, check=AsyncConnectionPool.check_connection, open = False)\n\n    async def open_pool(self):\n        await self.pool.open()\n        await self.pool.wait()\n\n    async def close_pool(self):\n        await self.pool.close()"}
{"type": "source_file", "path": "app/bot/handlers/display_info.py", "content": "from app.bot.utils import States, TelegramError\n\nfrom aiogram import types\n\nfrom aiogram.types import ReplyKeyboardMarkup, KeyboardButton\nfrom aiogram.fsm.context import FSMContext\n\nfrom app.services.db import DataBase, DatabaseError\n\nclass DisplayInfo:\n    def __init__(self, database: DataBase):\n        self.database = database\n\n    async def display_info_handler(self, message: types.Message, state: FSMContext):\n        try:\n            user_id = message.from_user.id\n            result = await self.database.get_userinfo(user_id)\n\n            button = [[KeyboardButton(text=\"üí∞Buy tokens and generations\")], [KeyboardButton(text=\"üîôBack\")]]\n            reply_markup = ReplyKeyboardMarkup(\n                keyboard = button, resize_keyboard=True\n            )\n            await message.answer(\n                text = f\"You have: \\n üí≠{result[0]} ChatGPT tokens \\n üåÑ{result[1]} DALL¬∑E image generations \\n üåÖ{result[2]} Stable Diffusion image generations \\n üí∏ You can buy more with crypto\",\n                reply_markup=reply_markup,\n            )\n            await state.set_state(States.INFO_STATE)\n        except DatabaseError:\n            raise DatabaseError\n        except Exception as e:\n            err = TelegramError(str(e))\n            err.output()\n            raise err"}
{"type": "source_file", "path": "app/bot/setup.py", "content": "from aiogram import Dispatcher\n\nfrom app.bot.handlers.answer_handlers import AnswerHandlers\nfrom app.bot.handlers.display_info import DisplayInfo\nfrom app.bot.handlers.purchase_handlers import PurchaseHandlers\nfrom app.bot.handlers.question import question_handler\nfrom app.bot.handlers.start import StartHandler\n\nfrom aiogram.filters.command import Command\nfrom app.bot.utils import States\nfrom aiogram import F\n\nfrom app.services.openaitools import OpenAiTools\nfrom app.services.db import DataBase\nfrom app.services.stablediffusion import StableDiffusion\nfrom app.services.cryptopay import CryptoPay\n\ndef register_handlers(dp: Dispatcher, database: DataBase, openai: OpenAiTools, stable: StableDiffusion, crypto: CryptoPay):\n    register_purchase_handlers(dp, database, crypto)\n\n    register_start_handlers(dp, database)\n\n    register_question_handlers(dp)\n\n    register_display_info_handlers(dp, database)\n\n    register_answer_handlers(dp, database, openai, stable)\n\ndef register_purchase_handlers(dp: Dispatcher, database: DataBase, crypto: CryptoPay):\n    Purchase_Handlers = PurchaseHandlers(database, crypto)\n\n    dp.message.register(Purchase_Handlers.purchase_handler, States.INFO_STATE, F.text.regexp(r'^üí∞Buy tokens and generations$'))\n    dp.message.register(Purchase_Handlers.purchase_handler, States.PURCHASE_CHATGPT_STATE, F.text.regexp(r'^üîôBack$'))\n    dp.message.register(Purchase_Handlers.purchase_handler,States.PURCHASE_DALL_E_STATE, F.text.regexp(r'^üîôBack$'))\n    dp.message.register(Purchase_Handlers.purchase_handler, States.PURCHASE_STABLE_STATE, F.text.regexp(r'^üîôBack$'))\n\n    currencies = ['USDT', 'TON', 'BTC', 'ETH']\n    for currency in currencies:\n        dp.message.register(Purchase_Handlers.buy_handler, States.PURCHASE_CHATGPT_STATE, F.text.regexp(rf'^üí≤{currency}$'))\n        dp.message.register(Purchase_Handlers.buy_handler, States.PURCHASE_DALL_E_STATE, F.text.regexp(rf'^üí≤{currency}$'))\n        dp.message.register(Purchase_Handlers.buy_handler, States.PURCHASE_STABLE_STATE, F.text.regexp(rf'^üí≤{currency}$'))\n\n    dp.message.register(Purchase_Handlers.currencies_handler, States.PURCHASE_STATE, F.text.regexp(r'^100K ChatGPT tokens - 5 USDüíµ$'))\n    dp.message.register(Purchase_Handlers.currencies_handler, States.PURCHASE_STATE, F.text.regexp(r'^50 DALL¬∑E image generations - 5 USDüíµ$'))\n    dp.message.register(Purchase_Handlers.currencies_handler, States.PURCHASE_STATE, F.text.regexp(r'^50 Stable Diffusion image generations - 5 USDüíµ$'))\n\ndef register_start_handlers(dp: Dispatcher, database: DataBase):\n    Start_Handler = StartHandler(database)\n    dp.message.register(Start_Handler.start_handler, Command('start'))\n    dp.message.register(Start_Handler.start_handler, States.ENTRY_STATE, F.text.regexp(r'^üîôBack$'))\n    dp.message.register(Start_Handler.start_handler, States.CHATGPT_STATE, F.text.regexp(r'^üîôBack$'))\n    dp.message.register(Start_Handler.start_handler, States.DALL_E_STATE, F.text.regexp(r'^üîôBack$'))\n    dp.message.register(Start_Handler.start_handler, States.STABLE_STATE, F.text.regexp(r'^üîôBack$'))\n    dp.message.register(Start_Handler.start_handler, States.INFO_STATE, F.text.regexp(r'^üîôBack$'))\n\ndef register_question_handlers(dp: Dispatcher):\n    dp.message.register(question_handler, States.ENTRY_STATE, F.text.regexp(r'^üí≠Chatting ‚Äî ChatGPT-4o$'))\n    dp.message.register(question_handler, States.ENTRY_STATE, F.text.regexp(r'^üåÑImage generation ‚Äî DALL¬∑E 3$'))\n    dp.message.register(question_handler, States.ENTRY_STATE, F.text.regexp(r'^üåÖImage generation ‚Äî Stable Diffusion 3$'))\n\ndef register_display_info_handlers(dp: Dispatcher, database: DataBase):\n    Display_Info = DisplayInfo(database)\n    dp.message.register(Display_Info.display_info_handler, States.ENTRY_STATE, F.text.regexp(r'^üë§My account | üí∞Buy$'))\n    dp.message.register(Display_Info.display_info_handler, States.PURCHASE_STATE, F.text.regexp(r'^üîôBack$'))\n\n\ndef register_answer_handlers(dp: Dispatcher, database: DataBase, openai: OpenAiTools, stable: StableDiffusion):\n    Answer_Handlers = AnswerHandlers(database, openai, stable)\n    dp.message.register(Answer_Handlers.chatgpt_answer_handler, States.CHATGPT_STATE, F.text)\n    dp.message.register(Answer_Handlers.stable_answer_handler, States.STABLE_STATE, F.text)\n    dp.message.register(Answer_Handlers.dall_e_answer_handler, States.DALL_E_STATE, F.text)"}
{"type": "source_file", "path": "app/services/cryptopay.py", "content": "from aiocryptopay import AioCryptoPay, Networks, utils\nimport logging\n\nclass CryptoPayError(Exception):\n    def __init__(self, msg: str = \"Error\"):\n        self.msg=msg\n    def output(self):\n        logging.error(\"CryptoPay error:\", self.msg)\n\nclass CryptoPay:\n    def __init__(self, token: str):\n        self.crypto = AioCryptoPay(token=token, network=Networks.MAIN_NET)\n    async def getprice(self, cost: int, currency: str) -> float:\n        try:\n            rates = await self.crypto.get_exchange_rates()\n            if currency == \"USDT\":\n                pass\n            elif currency == \"TON\":\n                exchange = float((utils.exchange.get_rate('TON', 'USD', rates)).rate)\n                cost = cost / exchange\n            elif currency == \"BTC\":\n                exchange = float((utils.exchange.get_rate('BTC', 'USD', rates)).rate)\n                cost = cost / exchange\n            elif currency == \"ETH\":\n                exchange = float((utils.exchange.get_rate('ETH', 'USD', rates)).rate)\n                cost = cost / exchange\n            return cost\n        except Exception as e:\n            err = CryptoPayError(str(e))\n            err.output()\n            raise err\n\n    async def create_invoice(self, cost: int, currency: str):\n        try:\n            price = await self.getprice(cost, currency)\n            invoice = await self.crypto.create_invoice(asset=currency, amount=price)\n            return invoice.bot_invoice_url, invoice.invoice_id\n        except Exception as e:\n            err = CryptoPayError(str(e))\n            err.output()\n            raise err"}
{"type": "source_file", "path": "app/services/db.py", "content": "from psycopg_pool import AsyncConnectionPool\nfrom typing import List, Tuple, Dict\nimport logging\n\nclass DatabaseError(Exception):\n    def __init__(self, msg: str = \"Error\"):\n        self.msg=msg\n    def output(self):\n        logging.error(\"Database error:\", self.msg)\n\nclass DataBase:\n    def __init__(self, pool: AsyncConnectionPool):\n        self.pool = pool\n    async def create_tables(self):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"CREATE TABLE IF NOT EXISTS users (user_id BIGINT PRIMARY KEY, chatgpt INT, dall_e INT, stable_diffusion INT)\")\n                    await cursor.execute(\"CREATE TABLE IF NOT EXISTS orders (invoice_id INT PRIMARY KEY, user_id BIGINT, product TEXT, FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE)\")\n                    await cursor.execute(\"CREATE TABLE IF NOT EXISTS messages (id SERIAL PRIMARY KEY, user_id BIGINT, role TEXT, content TEXT, tokens INT, FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE)\")\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def is_user(self, user_id: int) -> Tuple[int]:\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"SELECT user_id FROM users WHERE user_id = %s\", (user_id, ))\n                    result = await cursor.fetchone()\n                    return result\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def insert_user(self, user_id: int):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"INSERT INTO users(user_id, chatgpt, dall_e, stable_diffusion) VALUES (%s, %s, %s, %s)\", (user_id,3000,3,3))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def get_chatgpt(self, user_id: int) -> int:\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"SELECT chatgpt FROM users WHERE user_id = %s\", (user_id, ))\n                    result = (await cursor.fetchone())[0]\n                    return result\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def set_chatgpt(self, user_id: int, result: int):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"UPDATE users SET chatgpt = %s WHERE user_id = %s\", (result, user_id))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def get_dalle(self, user_id: int) -> int:\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"SELECT dall_e FROM users WHERE user_id = %s\", (user_id, ))\n                    result = (await cursor.fetchone())[0]\n                    return result\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def set_dalle(self, user_id: int, result: int):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"UPDATE users SET dall_e = %s WHERE user_id = %s\", (result, user_id))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def get_stable(self, user_id: int) -> int:\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"SELECT stable_diffusion FROM users WHERE user_id = %s\", (user_id, ))\n                    result = (await cursor.fetchone())[0]\n                    return result\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def set_stable(self, user_id: int, result: int):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"UPDATE users SET stable_diffusion = %s WHERE user_id = %s\", (result, user_id))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def get_userinfo(self, user_id: int) -> Tuple[int, int, int]:\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"SELECT chatgpt, dall_e, stable_diffusion FROM users WHERE user_id = %s\", (user_id, ))\n                    result = await cursor.fetchone()\n                    return result\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def new_order(self, invoice_id: int, user_id: int, product: str):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"INSERT INTO orders(invoice_id, user_id, product) VALUES (%s, %s, %s)\", (invoice_id, user_id, product))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def get_orderdata(self, invoice_id: int) -> Tuple[int, str]:\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"SELECT user_id, product FROM orders WHERE invoice_id = %s\", (invoice_id, ))\n                    result = await cursor.fetchone()\n                    return result\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def update_chatgpt(self, user_id: int, invoice_id: int):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"UPDATE users SET chatgpt = chatgpt + 100000 WHERE user_id = %s\", (user_id, ))\n                    await cursor.execute(\"DELETE FROM orders WHERE invoice_id = %s\", (invoice_id, ))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def update_dalle(self, user_id: int, invoice_id: int):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"UPDATE users SET dall_e = dall_e + 50 WHERE user_id = %s\", (user_id, ))\n                    await cursor.execute(\"DELETE FROM orders WHERE invoice_id = %s\", (invoice_id, ))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def update_stable(self, user_id: int, invoice_id: int):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"UPDATE users SET stable_diffusion = stable_diffusion + 50 WHERE user_id = %s\", (user_id, ))\n                    await cursor.execute(\"DELETE FROM orders WHERE invoice_id = %s\", (invoice_id, ))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def save_message(self, user_id: int, role: str, message: str, tokens: int):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"INSERT INTO messages(user_id, role, content, tokens) VALUES (%s, %s, %s, %s)\", (user_id, role, message, tokens))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def delete_messages(self, user_id: int):\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"DELETE FROM messages WHERE user_id = %s\", (user_id,))\n                    await conn.commit()\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err\n    async def get_messages(self, user_id: int) -> Tuple[List[Dict[str, str]], int]:\n        try:\n            async with self.pool.connection() as conn:\n                async with conn.cursor() as cursor:\n                    await cursor.execute(\"\"\"\n                    WITH cte AS (\n                        SELECT \n                            id, \n                            role, \n                            content, \n                            tokens,\n                            SUM(tokens) OVER (ORDER BY id DESC) AS tokens_total\n                        FROM messages\n                        WHERE user_id = %s\n                    )\n                    SELECT role, content, tokens_total\n                    FROM cte\n                    WHERE tokens_total <= 128000\n                    ORDER BY id ASC;\"\"\", (user_id,))\n                    result = await cursor.fetchall()\n                    if not result:\n                        return [], 0\n                    return [{\"role\": role, \"content\": content}  for role, content, _ in result], result[0][2]\n        except Exception as e:\n            err = DatabaseError(str(e))\n            err.output()\n            raise err"}
{"type": "source_file", "path": "app/bot/handlers/start.py", "content": "from app.bot.utils import States, TelegramError\n\nfrom aiogram import types\n\nfrom aiogram.types import ReplyKeyboardMarkup, KeyboardButton\nfrom aiogram.fsm.context import FSMContext\n\nfrom app.services.db import DataBase, DatabaseError\n\nclass StartHandler:\n    def __init__(self, database: DataBase):\n        self.database = database\n\n    async def start_handler(self, message: types.Message, state: FSMContext):\n        try:\n            user_id = message.from_user.id\n            result = await self.database.is_user(user_id)\n            button = [[KeyboardButton(text=\"üí≠Chatting ‚Äî ChatGPT-4o\")],\n                      [KeyboardButton(text=\"üåÑImage generation ‚Äî DALL¬∑E 3\")],\n                      [KeyboardButton(text=\"üåÖImage generation ‚Äî Stable Diffusion 3\")],\n                      [KeyboardButton(text=\"üë§My account | üí∞Buy\")]]\n            reply_markup = ReplyKeyboardMarkup(\n                keyboard = button, resize_keyboard=True\n            )\n            await self.database.delete_messages(user_id)\n            if not result:\n                await self.database.insert_user(user_id)\n                await message.answer(\n                    text = \"üëãYou have: \\nüí≠3000 ChatGPT tokens \\nüåÑ3 DALL¬∑E Image generations \\nüåÖ3 Stable Diffusion Image generations\\n Choose an option: üëá \\n If buttons don't work, enter /start command\",\n                    reply_markup=reply_markup,\n                )\n            else:\n                await message.answer(\n                    text = \"Choose an option: üëáüèª \\n If buttons don't work, enter /start command\",\n                    reply_markup=reply_markup,\n                )\n            await state.set_state(States.ENTRY_STATE)\n        except DatabaseError:\n            raise DatabaseError\n        except Exception as e:\n            err = TelegramError(str(e))\n            err.output()\n            raise err"}
{"type": "source_file", "path": "app/bot/utils.py", "content": "from aiogram.fsm.state import State, StatesGroup\nfrom tiktoken import encoding_for_model\nfrom gpytranslate import Translator\nimport logging\n\nclass States(StatesGroup):\n    ENTRY_STATE = State()\n    CHATGPT_STATE = State()\n    DALL_E_STATE = State()\n    STABLE_STATE = State()\n    INFO_STATE = State()\n    PURCHASE_STATE = State()\n    PURCHASE_CHATGPT_STATE = State()\n    PURCHASE_DALL_E_STATE = State()\n    PURCHASE_STABLE_STATE = State()\n\nencoding = encoding_for_model(\"gpt-4o\")\n\ntranslator = Translator()\n\nclass TelegramError(Exception):\n    def __init__(self, msg: str = \"Error\"):\n        self.msg=msg\n    def output(self):\n        logging.error(\"Telegram error:\", self.msg)"}
{"type": "source_file", "path": "app/services/stablediffusion.py", "content": "import aiohttp\n\nclass StableDiffusion:\n    def __init__(self, key: str):\n        self.key = key\n\n    async def get_stable(self, prompt: str):\n        try:\n            form_data = aiohttp.FormData()\n            form_data.add_field(\"prompt\", prompt, content_type='multipart/form-data')\n            form_data.add_field(\"output_format\", \"jpeg\", content_type='multipart/form-data')\n            form_data.add_field(\"model\", \"sd3-large-turbo\", content_type='multipart/form-data')\n\n            async with aiohttp.ClientSession() as session:\n                async with session.post('https://api.stability.ai/v2beta/stable-image/generate/sd3',\n                                        headers={\n                                            \"authorization\": f\"Bearer {self.key}\",\n                                            \"accept\": \"image/*\"\n                                        },\n                                        data=form_data) as response:\n                    if response.status == 200:\n                        photo = await response.read()\n                        return photo\n                    else:\n                        return\n        except:\n            return"}
{"type": "source_file", "path": "app/services/payment_successful.py", "content": "from app.bot.utils import TelegramError\nfrom app.services.db import DataBase, DatabaseError\nfrom aiogram import Bot\n\nasync def payment_success(bot: Bot, database: DataBase, update_type: str, invoice_id: int) -> None:\n    if update_type == \"invoice_paid\":\n        try:\n            result = await database.get_orderdata(invoice_id)\n            if result[1] == 'chatgpt':\n                await database.update_chatgpt(result[0], invoice_id)\n                await bot.send_message(result[0], \"‚úÖYou have received 100000 ChatGPT tokens!\")\n            elif result[1] == 'dall_e':\n                await database.update_dalle(result[0], invoice_id)\n                await bot.send_message(result[0], \"‚úÖYou have received 50 DALL¬∑E image generations!\")\n            elif result[1] == 'stable':\n                await database.update_stable(result[0], invoice_id)\n                await bot.send_message(result[0], \"‚úÖYou have received 50 Stable Diffusion image generations!\")\n        except DatabaseError:\n            raise DatabaseError\n        except Exception as e:\n            err = TelegramError(str(e))\n            err.output()\n            raise err"}
{"type": "source_file", "path": "main.py", "content": "from app.application import run\n\nif __name__ == '__main__':\n    run()"}
{"type": "source_file", "path": "app/services/openaitools.py", "content": "from openai import AsyncOpenAI\nfrom typing import List, Dict\n\nclass OpenAiTools:\n    def __init__(self, token: str):\n        self.client = AsyncOpenAI(\n            api_key=token,\n        )\n\n    async def get_chatgpt(self, messages: List[Dict[str, str]]):\n        try:\n            response = await self.client.chat.completions.create(\n                messages=messages,\n                model=\"gpt-4o\",\n                max_tokens=16384,\n                temperature=1,\n            )\n\n            return response.choices[0].message.content\n        except:\n            return\n\n    async def get_dalle(self, prompt: str):\n        try:\n            response = await self.client.images.generate(\n                model=\"dall-e-3\",\n                prompt=prompt,\n                size=\"1024x1024\",\n                n=1,\n            )\n\n            return response.data[0].url\n        except:\n            return\n"}

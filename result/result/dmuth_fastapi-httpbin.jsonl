{"repo_info": {"repo_name": "fastapi-httpbin", "repo_owner": "dmuth", "repo_url": "https://github.com/dmuth/fastapi-httpbin"}}
{"type": "test_file", "path": "lib/apis/test_password_manager.py", "content": "#\n# QR Code endpoints\n#\n\nfrom io import BytesIO\nimport random\n\nfrom fastapi import APIRouter, FastAPI, Header, Response, Query, Path, HTTPException, Form\nfrom fastapi.responses import RedirectResponse, JSONResponse\nfrom fastapi.responses import FileResponse\nfrom pydantic import BaseModel, Field\n\nimport qrcode\n\nrouter = APIRouter()\n\n@router.get(\"/form\", include_in_schema = False)\nasync def get_form():\n    return RedirectResponse(f\"/test-password-manager-form\", status_code = 302)\n\n\n@router.post(\"/test-password-manager-form/post\", summary = \"Process a sample login\",\n    responses={\n        200: {\n            \"description\": \"Valid credentials were supplied. (username: dmuth, password: password)\",\n        },\n        401: {\n            \"description\": \"Invalid credentials were supplied\"\n        }\n    },\n    response_class=Response\n    )\nasync def test_password_manager_form(username: str = Form(),\n    password: str = Form()):\n\n    retval = {}\n\n    retval[\"status\"] = \"success\"\n    retval[\"errors\"] = []\n\n    if username != \"dmuth\":\n        retval[\"status\"] = \"error\"\n        retval[\"errors\"].append(\"Username did not match, expected 'dmuth'\")\n\n    if password != \"password\":\n        retval[\"status\"] = \"error\"\n        retval[\"errors\"].append(\"Password did not match, expected 'password'\")\n\n    if retval[\"status\"] == \"success\":\n        return JSONResponse(retval, media_type = \"text/plain\")\n\n    raise HTTPException(status_code = 401, detail = retval)\n\n\n"}
{"type": "test_file", "path": "tests/test_anything.py", "content": "\nimport json\n\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n\n#\n# Set up a fake request client\n#\ndef setup_test_client(mocker):\n    mock_client = mocker.patch(\"fastapi.Request.client\")\n    mock_client.host = \"testclient\"\n    mock_client.port = \"12345\"\n\n\n\ndef test_anything_get(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.get(\"/anything\")\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"verb\"] == \"GET\"\n\n    response = client.get(\"/any\")\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"verb\"] == \"GET\"\n\n    assert response.headers[\"x-fastapi-httpbin-version\"] != None\n    assert response.headers[\"x-website\"] == \"https://httpbin.dmuth.org/\"\n    #\n    # An empty string is returned by the underlying platform.node() call if\n    # a hostname cannot be determined, but I don't ever expect that to be \n    # an issue in Docker/testing.\n    #\n    assert response.headers[\"x-app-hostname\"] != None\n    assert response.headers[\"x-app-hostname\"] != \"\"\n\n    response = client.get(\"/anything?test=test2\")\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"args\"][\"test\"] == \"test2\"\n    assert response.json()[\"verb\"] == \"GET\"\n\n\ndef test_anything_head(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.head(\"/anything\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"application/json\"\n    assert response.text == \"\"\n\n    response = client.head(\"/any\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"application/json\"\n    assert response.text == \"\"\n\n\ndef test_anything_post(mocker):\n\n    setup_test_client(mocker)\n\n    data = { \"cheetah\": \"chirp\", \"goat\": \"bleat\" }\n\n    response = client.post(\"/anything\", json = json.dumps(data))\n    assert response.status_code == 200\n    data = json.loads(response.json()[\"data\"])\n    assert data[\"cheetah\"] == \"chirp\"\n    assert response.json()[\"verb\"] == \"POST\"\n\n    data = [ data ]\n\n    response = client.post(\"/anything\", json = json.dumps(data))\n    assert response.status_code == 200\n    data = json.loads(response.json()[\"data\"])\n    assert data[0][\"cheetah\"] == \"chirp\"\n    assert response.json()[\"verb\"] == \"POST\"\n\n\ndef test_anything_put(mocker):\n\n    setup_test_client(mocker)\n\n    data = { \"cheetah\": \"chirp\", \"goat\": \"bleat\" }\n\n    response = client.put(\"/anything\", json = json.dumps(data))\n    assert response.status_code == 200\n    data = json.loads(response.json()[\"data\"])\n    assert data[\"cheetah\"] == \"chirp\"\n    assert response.json()[\"verb\"] == \"PUT\"\n\n    data = [ data ]\n\n    response = client.put(\"/anything\", json = json.dumps(data))\n    assert response.status_code == 200\n    data = json.loads(response.json()[\"data\"])\n    assert data[0][\"cheetah\"] == \"chirp\"\n    assert response.json()[\"verb\"] == \"PUT\"\n\n\ndef test_anything_patch(mocker):\n\n    setup_test_client(mocker)\n\n    data = { \"cheetah\": \"chirp\", \"goat\": \"bleat\" }\n\n    response = client.patch(\"/anything\", json = json.dumps(data))\n    assert response.status_code == 200\n    data = json.loads(response.json()[\"data\"])\n    assert data[\"cheetah\"] == \"chirp\"\n    assert response.json()[\"verb\"] == \"PATCH\"\n\n    data = [ data ]\n\n    response = client.patch(\"/anything\", json = json.dumps(data))\n    assert response.status_code == 200\n    data = json.loads(response.json()[\"data\"])\n    assert data[0][\"cheetah\"] == \"chirp\"\n    assert response.json()[\"verb\"] == \"PATCH\"\n\n\ndef test_anything_delete(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.delete(\"/anything\")\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"verb\"] == \"DELETE\"\n\n\n\n"}
{"type": "test_file", "path": "tests/__init__.py", "content": "\n\nimport fs\nimport cv2\n\n\ndef decode_qrcode(qrcode):\n\n    tmp_fs = fs.open_fs('temp://')\n\n    with tmp_fs.open(\"file.png\", \"wb\") as file:\n        file.write(qrcode)\n        filename = file.name.decode(\"utf-8\")\n\n    image = cv2.imread(filename)\n\n    #cv2.imshow('Image', image) # Debugging\n    #cv2.waitKey(0) # Debugging\n\n    detector = cv2.QRCodeDetector()\n    retval, _, _  = detector.detectAndDecode(image)\n\n    return(retval)\n\n"}
{"type": "test_file", "path": "tests/test_cookies.py", "content": "\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n\ndef test_cookies():\n\n    response = client.get(\"/cookies\")\n    assert response.status_code == 200\n    assert len(response.cookies) == 0\n    assert response.json()[\"message\"] == \"0 cookies seen in request.\"\n\n    cookies = {}\n    response = client.put(\"/cookies\", json = cookies)\n    assert response.status_code == 200\n    assert len(response.cookies) == 0\n    assert response.json()[\"message\"] == \"0 cookies set in response.\"\n\n    cookies = {\"cookie1\": \"value1\"}\n    response = client.put(\"/cookies\", json = cookies)\n    assert response.status_code == 200\n    assert len(response.cookies) == 1\n    assert response.json()[\"message\"] == \"1 cookie set in response.\"\n \n    cookies = {\"cookie1\": \"value1\", \"cookie2\": \"value2\", \"cookie3\": \"value3\"}\n    response = client.put(\"/cookies\", json = cookies)\n    assert response.status_code == 200\n    assert len(response.cookies) == 3\n    assert response.json()[\"message\"] == \"3 cookies set in response.\"\n \n    response = client.get(\"/cookies\")\n    assert response.status_code == 200\n    assert len(response.cookies) == 3\n    assert response.json()[\"message\"] == \"3 cookies seen in request.\"\n   \n    cookies = [\"cookie1\"]\n    response = client.request(method = \"delete\", url = \"/cookies\", json = cookies)\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"1 cookie deleted.\"\n    \n    response = client.get(\"/cookies\")\n    assert response.status_code == 200\n    assert len(response.cookies) == 2\n    assert response.json()[\"message\"] == \"2 cookies seen in request.\"\n\n    cookies = [\"cookie2\", \"cookie3\", \"cookie4\"]\n    response = client.request(method = \"delete\", url = \"/cookies\", json = cookies)\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"2 cookies deleted.\"\n    \n    cookies = [\"cookie2\", \"cookie3\", \"cookie4\"]\n    response = client.request(method = \"delete\", url = \"/cookies\", json = cookies)\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"0 cookies deleted.\"\n    \n    response = client.get(\"/cookies\")\n    assert response.status_code == 200\n    assert len(response.cookies) == 0\n    assert response.json()[\"message\"] == \"0 cookies seen in request.\"\n\n\n"}
{"type": "test_file", "path": "tests/test_dynamic.py", "content": "\n\nimport json\nfrom unittest.mock import AsyncMock\nfrom uuid import UUID\n\nfrom fastapi.testclient import TestClient\n\nfrom main import app\n\nfrom . import decode_qrcode\n\nclient = TestClient(app)\n\n\ndef test_uuid():\n    response = client.get(\"/uuid\")\n    assert response.status_code == 200\n    assert \"uuid\" in response.json()\n    assert \"-4\" in response.json()[\"uuid\"]\n    assert \"random.org\" in response.json()[\"messages\"][0]\n    assert \"T\" in response.json()[\"timestamp\"]\n    assert \"+00:00\" in response.json()[\"timestamp\"]\n\n\ndef test_uuid_qrcode():\n\n    uuid = \"c42eec28-617c-4333-bf63-9c2b43bbf8d3\"\n\n    response = client.get(\"/uuid/qrcode\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/png\"\n    response_body = b\"\"\n    for chunk in response.iter_bytes():\n        response_body += chunk\n    uuid_decoded = decode_qrcode(response_body)\n    try:\n        UUID(uuid_decoded)\n    except ValueError as e:\n        assert False, f\"Decoded value of {uuid_decoded} is not a valid UUID!\"\n\n    response = client.get(f\"/uuid/qrcode/{uuid}\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/png\"\n    response_body = b\"\"\n    for chunk in response.iter_bytes():\n        response_body += chunk\n    uuid_decoded = decode_qrcode(response_body)\n    assert uuid_decoded == uuid\n\n    response = client.get(f\"/uuid/qrcode/testing\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.str.validation\"\n\n\ndef test_delay():\n    response = client.get(\"/delay/2?debug=1\")\n    assert response.status_code == 200\n    assert \"2 seconds\" in response.json()[\"message\"]\n\n    response = client.get(\"/delay/10?debug=1\")\n    assert response.status_code == 200\n    assert \"10 seconds\" in response.json()[\"message\"]\n\n    response = client.get(\"/delay/0?debug=1\")\n    assert response.status_code == 200\n    assert \"0 seconds\" in response.json()[\"message\"]\n\n    response = client.get(\"/delay/11?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.max_size\"\n\n    response = client.get(\"/delay/-1?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n\ndef test_stream():\n\n    response = client.get(\"/stream/5\")\n    assert response.status_code == 200\n    lines = response.text.split(\"\\n\")\n    assert len(lines) == 6\n    line = lines[1]    \n    row = json.loads(line)\n    assert row[\"response_number\"] == 2\n    assert \"-4\" in row[\"uuid\"]\n\n    response = client.get(\"/stream/-1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n    \n    response = client.get(\"/stream/0\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n    \n    response = client.get(\"/stream/101\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.max_size\"\n \n\ndef test_stream_chars():\n    response = client.get(\"/stream/chars/250/50?debug=1\")\n    assert response.status_code == 200\n    assert len(response.text) == 250\n\n    response = client.get(\"/stream/chars/102400/5120?debug=1\")\n    assert response.status_code == 200\n    assert len(response.text) == 102400\n\n    response = client.get(\"/stream/chars/102400/50?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n    response = client.get(\"/stream/chars/102401/10000?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.max_size\"\n    assert len(response.text) == 89\n\n    response = client.get(\"/stream/chars/-1/50?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n    response = client.get(\"/stream/chars/250/-1?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n    response = client.get(\"/stream/chars/250/0?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n\ndef test_stream_chars_complete():\n\n    response = client.get(\"/stream/chars/complete/250/50?debug=1\")\n    assert response.status_code == 200\n    assert len(response.text) == 250\n\n    response = client.get(\"/stream/chars/complete/600/50?debug=1\")\n    assert response.status_code == 200\n    lines = response.text.split()\n    last_line = lines[ len(lines) - 1 ]\n    assert len(last_line) == 99\n    assert len(response.text) == 600\n\n    response = client.get(\"/stream/chars/complete/-1/50?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n    response = client.get(\"/stream/chars/complete/250/-1?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n    response = client.get(\"/stream/chars/complete/250/0?debug=1\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n\n\n\n"}
{"type": "test_file", "path": "tests/test_images.py", "content": "\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n\ndef test_jpeg():\n    response = client.get(\"/images/jpeg\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/jpeg\"\n    \ndef test_png():\n    response = client.get(\"/images/png\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/png\"\n    \ndef test_heic():\n    response = client.get(\"/images/heic\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/heic\"\n    \ndef test_webp():\n    response = client.get(\"/images/webp\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/webp\"\n    \n\n\n\n"}
{"type": "test_file", "path": "tests/test_main.py", "content": "\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\ndef test_read_main():\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n\n"}
{"type": "test_file", "path": "tests/test_meta.py", "content": "\nimport re\n\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\ndef test_read_main():\n    response = client.get(\"/version\")\n    \n    assert response.status_code == 200\n    assert re.match(r\"^\\d+\\.\\d+.\\d+$\", response.json()[\"version\"])\n\n\n"}
{"type": "test_file", "path": "tests/test_methods.py", "content": "\nimport json\n\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n\n#\n# Set up a fake request client\n#\ndef setup_test_client(mocker):\n    mock_client = mocker.patch(\"fastapi.Request.client\")\n    mock_client.host = \"testclient\"\n    mock_client.port = \"12345\"\n\n\ndef test_get(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.get(\"/get\")\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    assert len(response.json()[\"args\"]) == 0\n    assert \"_comment\" in response.json()\n\n    response = client.get(\"/get?test1=test2&test3=test4\")\n    assert response.status_code == 200\n    assert response.json()[\"args\"][\"test1\"] == \"test2\"\n    assert len(response.json()[\"args\"]) == 2\n\n\ndef test_get_args(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.get(\"/get/args\")\n    assert response.status_code == 200\n    assert \"headers\" not in response.json()\n    assert \"source\" not in response.json()\n    assert \"url\" not in response.json()\n    assert len(response.json()) == 0\n\n    response = client.get(\"/get/args?test1=test2&test3=test4\")\n    assert response.status_code == 200\n    assert response.json()[\"test1\"] == \"test2\"\n    assert len(response.json()) == 2\n\n\ndef test_post(mocker):\n\n    setup_test_client(mocker)\n\n    headers_json = {\"Content-Type\": \"application/json\"}\n    headers_form = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n\n    data = {}\n    response = client.post(\"/post\", json = json.dumps(data), headers = headers_json)\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data == {}\n\n    data = \"broken json\"\n    response = client.post(\"/post\", json = json.dumps(data), headers = headers_json)\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data == \"broken json\"\n\n    data = { \"cheetah\": \"chirp\", \"goat\": \"bleat\" }\n    response = client.post(\"/post\", json = json.dumps(data), headers = headers_json)\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data[\"cheetah\"] == \"chirp\"\n\n    data = [ data ]\n    response = client.post(\"/post\", json = json.dumps(data), headers = headers_json)\n    assert response.status_code == 200\n    data = json.loads(response.json()[\"data\"])\n    assert data[0][\"cheetah\"] == \"chirp\"\n\n    #\n    # Test regular form data\n    #\n    form_data = \"birthyear=1905&press=%20OK%20\"\n    response = client.post(\"/post\", data = form_data, headers = headers_form)\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = response.json()[\"data\"]\n    assert data[\"birthyear\"][0] == \"1905\"\n    assert data[\"press\"][0] == \" OK \"\n\n\ndef test_put(mocker):\n\n    setup_test_client(mocker)\n\n    data = {}\n    response = client.put(\"/put\", json = json.dumps(data))\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data == {}\n\n    data = \"broken json\"\n    response = client.put(\"/put\", json = json.dumps(data))\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data == \"broken json\"\n\n    data = { \"cheetah\": \"chirp\", \"goat\": \"bleat\" }\n\n    response = client.put(\"/put\", json = json.dumps(data))\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data[\"cheetah\"] == \"chirp\"\n\n    data = [ data ]\n\n    response = client.put(\"/put\", json = json.dumps(data))\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data[0][\"cheetah\"] == \"chirp\"\n\n\ndef test_patch(mocker):\n\n    setup_test_client(mocker)\n\n    data = {}\n    response = client.patch(\"/patch\", json = json.dumps(data))\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data == {}\n\n    data = \"broken json\"\n    response = client.patch(\"/patch\", json = json.dumps(data))\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data == \"broken json\"\n\n    data = { \"cheetah\": \"chirp\", \"goat\": \"bleat\" }\n\n    response = client.patch(\"/patch\", json = json.dumps(data))\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data[\"cheetah\"] == \"chirp\"\n\n    data = [ data ]\n\n    response = client.patch(\"/patch\", json = json.dumps(data))\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n    data = json.loads(response.json()[\"data\"])\n    assert data[0][\"cheetah\"] == \"chirp\"\n\n\ndef test_delete(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.delete(\"/delete\")\n    assert response.status_code == 200\n    assert response.json()[\"source\"][\"ip\"] == \"testclient\"\n    assert response.json()[\"headers\"][\"host\"] == \"testserver\"\n\n\n"}
{"type": "test_file", "path": "tests/test_password_manager_form.py", "content": "\nimport hashlib\nimport json\n\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n\ndef test_form_post():\n\n    data = {}\n    response = client.post(\"/test-password-manager-form/post\", data = data)\n    assert response.status_code == 422\n   \n    data = {\"username\": \"dmuth1\", \"password\": \"password1\"}\n    response = client.post(\"/test-password-manager-form/post\", data = data)\n    assert response.status_code == 401\n   \n    data = {\"username\": \"dmuth\", \"password\": \"password\"}\n    response = client.post(\"/test-password-manager-form/post\", data = data)\n    assert response.status_code == 200\n\n    response = client.get(\"/form\", allow_redirects = False)\n    assert response.status_code == 302\n    assert response.headers[\"location\"] == \"/test-password-manager-form\"\n\n"}
{"type": "test_file", "path": "tests/test_request.py", "content": "\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n\nipv4_1 = \"1.2.3.4\"\nipv4_2 = \"1.2.3.5\"\nipv6_1 = \"2001:db8:0000:1:2:3:4:5\"\nipv6_2 = \"2001:db8::5\"\n\n\n#\n# Set up a fake request client\n#\ndef setup_test_client(mocker):\n    mock_client = mocker.patch(\"fastapi.Request.client\")\n    mock_client.host = \"testclient\"\n    mock_client.port = \"12345\"\n\n\ndef test_headers(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.get(\"/headers\")\n    assert response.status_code == 200\n    assert response.json()[\"host\"] == \"testserver\"\n\n\ndef test_ip(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.get(\"/ip\")\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == \"testclient\"\n    assert \"v4\" in response.json()[\"message\"][0]\n    assert \"graph\" in response.json()[\"message\"][1]\n\n    response = client.get(\"/ip\", headers = {\"x-forwarded-for\": ipv4_1})\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == ipv4_1\n\n    response = client.get(\"/ip\", headers = {\"x-forwarded-for\": ipv6_1})\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == ipv6_1\n\n    response = client.get(\"/ip\", headers = {\"x-forwarded-for\": ipv4_1, \"fly-client-ip\": ipv4_2})\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == ipv4_2\n\n    response = client.get(\"/ip\", headers = {\"x-forwarded-for\": ipv6_1, \"fly-client-ip\": ipv6_2})\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == ipv6_2\n\n\ndef test_ipv4(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.get(\"/ip/v4\")\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == \"testclient\"\n\n    response = client.get(\"/ip/v4\", headers = {\"x-forwarded-for\": ipv4_1})\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == ipv4_1\n\n    response = client.get(\"/ip/v4\", headers = {\"x-forwarded-for\": ipv4_1, \"fly-client-ip\": ipv4_2})\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == ipv4_2\n\n    response = client.get(\"/ip/v4\", headers = {\"x-forwarded-for\": ipv6_1})\n    assert response.status_code == 422\n    assert \"IPv4\" in response.json()[\"detail\"][\"message\"]\n\n    response = client.get(\"/ip/v4\", headers = {\"x-forwarded-for\": ipv6_1, \"fly-client-ip\": ipv6_2})\n    assert response.status_code == 422\n    assert \"IPv4\" in response.json()[\"detail\"][\"message\"]\n\n\ndef test_ipv6(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.get(\"/ip/v6\")\n    assert response.status_code == 422\n    assert \"IPv6\" in response.json()[\"detail\"][\"message\"]\n\n    response = client.get(\"/ip/v6\", headers = {\"x-forwarded-for\": ipv6_1})\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == ipv6_1\n\n    response = client.get(\"/ip/v6\", headers = {\"x-forwarded-for\": ipv6_1, \"fly-client-ip\": ipv6_2})\n    assert response.status_code == 200\n    assert response.json()[\"ip\"] == ipv6_2\n\n    response = client.get(\"/ip/v6\", headers = {\"x-forwarded-for\": ipv4_1})\n    assert response.status_code == 422\n    assert \"IPv6\" in response.json()[\"detail\"][\"message\"]\n\n    response = client.get(\"/ip/v6\", headers = {\"x-forwarded-for\": ipv4_1, \"fly-client-ip\": ipv4_2})\n    assert response.status_code == 422\n    assert \"IPv6\" in response.json()[\"detail\"][\"message\"]\n\n\ndef test_user_agent(mocker):\n\n    setup_test_client(mocker)\n\n    response = client.get(\"/user-agent\")\n    assert response.status_code == 200\n    assert response.json()[\"user-agent\"] == \"testclient\"\n\n\n"}
{"type": "test_file", "path": "tests/test_response_formats.py", "content": "\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n\ndef test_html():\n    response = client.get(\"/html\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"text/html; charset=utf-8\"\n    \ndef test_json():\n    response = client.get(\"/json\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"application/json\"\n    assert response.json()[\"title\"] == \"Undertale Soundtrack\"\n    \ndef test_robots_txt():\n    response = client.get(\"/robots.txt\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"text/plain; charset=utf-8\"\n\ndef test_deny():\n    response = client.get(\"/deny\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"text/plain; charset=utf-8\"\n    assert \"You pet the Dog.\" in response.text\n\ndef test_xml():\n    response = client.get(\"/xml\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"application/xml \"\n    assert \"<track>Hopes and Dreams</track>\" in response.text\n\ndef test_utf8():\n    response = client.get(\"/encoding/utf8\")\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"text/plain; charset=utf-8\"\n    assert \"∮ E⋅da = Q\" in response.text\n\n\n\n"}
{"type": "test_file", "path": "tests/test_status.py", "content": "\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n#\n# This is our main function which performs all of the tests.\n#\n# cb - The callback to the request method.\n#\ndef core(cb):\n\n    response = cb(\"/status/200\")\n    assert response.status_code == 200\n\n    response = client.get(\"/status/204\")\n    assert response.status_code == 204\n\n    response = client.get(\"/status/301\", allow_redirects = False)\n    assert response.status_code == 301\n    assert response.headers[\"location\"] == \"/redirect/1\"\n\n    response = client.get(\"/status/404\")\n    assert response.status_code == 404\n\n    response = client.get(\"/status/510\")\n    assert response.status_code == 510\n\n    response = client.get(\"/status/201,202\")\n    assert response.status_code in [201, 202]\n\n    response = client.get(\"/status/201,202,203,401,404\")\n    assert response.status_code in [201, 202, 203, 401, 404]\n\n    response = client.get(\"/status/211_212\")\n    assert response.status_code in [211, 212]\n\n    response = client.get(\"/status/211_212_213_411_414\")\n    assert response.status_code in [211, 212, 213, 411, 414]\n\n    response = client.get(\"/status/1\")\n    assert response.json()[\"detail\"][0][\"type\"] == \"string_too_short\"\n\n    response = client.get(\"/status/cheetah,goat\")\n    assert response.json()[\"detail\"][0][\"type\"] == \"string_pattern_mismatch\"\n\n    response = client.get(\"/status/200,2001,300\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"code_length\"\n\n    response = client.get(\"/status/200,1,300\")\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"code_length\"\n\n    response = client.get(\"/status\")\n    assert response.status_code == 404\n\n\ndef test_get():\n    core(client.get)\n\ndef test_post():\n    core(client.post)\n\ndef test_put():\n    core(client.put)\n\ndef test_patch():\n    core(client.patch)\n\ndef test_delete():\n    core(client.delete)\n\n\n"}
{"type": "test_file", "path": "tests/test_redirect.py", "content": "\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n#\n# This is our main function which performs all of the tests.\n#\n# cb - The callback to the request method.\n#\ndef core(cb):\n\n    response = cb(\"/redirect/final\", allow_redirects = False)\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"Reached the end of our redirects!\"\n\n    response = cb(\"/redirect/final?code=310\", allow_redirects = False)\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"Reached the end of our redirects!\"\n    assert response.json()[\"code\"] == 310\n\n    response = cb(\"/redirect/1\", allow_redirects = False)\n    assert response.status_code == 302\n    assert response.headers[\"location\"] == \"/redirect/final?code=302\"\n    assert response.headers[\"x-http-redirect-code\"] == \"302\"\n\n    response = cb(\"/redirect/2\", allow_redirects = False)\n    assert response.status_code == 302\n    assert response.headers[\"location\"] == \"/redirect/1?code=302\"\n    assert response.headers[\"x-http-redirect-code\"] == \"302\"\n\n    response = cb(\"/redirect/3?code=310\", allow_redirects = False)\n    assert response.status_code == 310\n    assert response.headers[\"location\"] == \"/redirect/2?code=310\"\n    assert response.headers[\"x-http-redirect-code\"] == \"310\"\n\n    response = cb(\"/redirect/1?code=399\", allow_redirects = False)\n    assert response.status_code == 399\n    assert response.headers[\"location\"] == \"/redirect/final?code=399\"\n    assert response.headers[\"x-http-redirect-code\"] == \"399\"\n\n    response = cb(\"/redirect/5\", allow_redirects = False)\n    assert response.status_code == 302\n    assert response.headers[\"location\"] == \"/redirect/4?code=302\"\n    assert response.headers[\"x-http-redirect-code\"] == \"302\"\n\n    response = cb(\"/redirect\", allow_redirects = False)\n    assert response.status_code == 404\n\n    response = cb(\"/redirect/\", allow_redirects = False)\n    assert response.status_code == 404\n\n    response = cb(\"/redirect/cheetah\", allow_redirects = False)\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][0][\"type\"] == \"int_parsing\"\n\n    response = cb(\"/redirect/21\", allow_redirects = False)\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.max_size\"\n\n\ndef test_get():\n    core(client.get)\n\ndef test_post():\n    core(client.post)\n\ndef test_put():\n    core(client.put)\n\ndef test_patch():\n    core(client.patch)\n\ndef test_delete():\n    core(client.delete)\n\n\n"}
{"type": "test_file", "path": "tests/test_qrcode.py", "content": "\nimport json\n\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nfrom . import decode_qrcode\n\nclient = TestClient(app)\n\n\ndef test_qrcode_post():\n\n    url = \"https://www.youtube.com/watch?v=nCEemcXzERk\"\n\n    response = client.post(\"/qrcode/json\")\n    assert response.status_code == 422\n\n    data = {\"url\": url, \"box_size\": 10, \"border\": 4}\n    response = client.post(\"/qrcode/json\", json = data)\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/png\"\n    response_body = b\"\"\n    for chunk in response.iter_bytes():\n        response_body += chunk\n\n    uuid_decoded = decode_qrcode(response_body)\n    assert uuid_decoded == url\n\n    data = {\"url\": url, \"box_size\": 10, \"border\": 4, \"transparent_background\": True}\n    response = client.post(\"/qrcode/json\", json = data)\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/png\"\n    response_body = b\"\"\n    for chunk in response.iter_bytes():\n        response_body += chunk\n\n    uuid_decoded = decode_qrcode(response_body)\n    assert uuid_decoded == url\n\n    # Test small border\n    data = {\"url\": url, \"box_size\": 10, \"border\": 2}\n    response = client.post(\"/qrcode/json\", json = data)\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n\ndef test_qrcode_post_size():\n\n    url = \"1234567890\"\n\n    data = {\"url\": url, \"box_size\": 10, \"border\": 4}\n    response = client.post(\"/qrcode/json\", json = data)\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/png\"\n    response_body = b\"\"\n    for chunk in response.iter_bytes():\n        response_body += chunk\n\n    uuid_decoded = decode_qrcode(response_body)\n    assert uuid_decoded == url\n\n    url = \"1234\"\n\n    data = {\"url\": url, \"box_size\": 10, \"border\": 4}\n    response = client.post(\"/qrcode/json\", json = data)\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/png\"\n    response_body = b\"\"\n    for chunk in response.iter_bytes():\n        response_body += chunk\n\n    uuid_decoded = decode_qrcode(response_body)\n    assert uuid_decoded == url\n\n\ndef test_qrcode_get():\n    response = client.get(\"/qrcode\", allow_redirects = False)\n    assert response.status_code == 302\n    assert response.headers[\"location\"] == \"/qrcode/\"\n\n\ndef test_qrcode_form():\n\n    url = \"https://www.youtube.com/watch?v=nCEemcXzERk\"\n\n    data = {\"url\": url, \"box_size\": 10, \"border\": 4}\n    response = client.post(\"/qrcode/form\", data = data)\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/png\"\n    response_body = b\"\"\n    for chunk in response.iter_bytes():\n        response_body += chunk\n\n    uuid_decoded = decode_qrcode(response_body)\n    assert uuid_decoded == url\n\n    data = {\"url\": url, \"box_size\": 10, \"border\": 4, \"transparent_background\": True}\n    response = client.post(\"/qrcode/form\", data = data)\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"image/png\"\n    response_body = b\"\"\n    for chunk in response.iter_bytes():\n        response_body += chunk\n\n    uuid_decoded = decode_qrcode(response_body)\n    assert uuid_decoded == url\n\n    data = {\"url\": url, \"box_size\": 10, \"border\": 2}\n    response = client.post(\"/qrcode/form\", data = data)\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.int.min_size\"\n\n\n#def test_qr():\n#    response = client.post(\"/qr\")\n#    assert response.status_code == 302\n#    assert response.headers[\"location\"] == \"/qrcode/\"\n\n\n#def test_qr_code():\n#    response = client.post(\"/qr-code\")\n#    assert response.status_code == 302\n#    assert response.headers[\"location\"] == \"/qrcode/\"\n\n\n\n\n"}
{"type": "test_file", "path": "tests/test_response.py", "content": "\nfrom fastapi.testclient import TestClient\n\nfrom unittest.mock import AsyncMock\n\nfrom main import app\n\nclient = TestClient(app)\n\n\ndef test_cache():\n    response = client.get(\"/cache\")\n    assert response.status_code == 200\n    \n    headers = {\"If-Modified-Since\": \"12345\"}\n    response = client.get(\"/cache\", headers = headers)\n    assert response.status_code == 304\n\n    headers = {\"If-None-Match\": \"67890\"}\n    response = client.get(\"/cache\", headers = headers)\n    assert response.status_code == 304\n\n    headers = {\"If-Modified-Since\": \"12345\", \"If-None-Match\": \"67890\"}\n    response = client.get(\"/cache\", headers = headers)\n    assert response.status_code == 304\n\n\ndef test_cache_seconds():\n    response = client.get(\"/cache/12345\")\n    assert response.status_code == 200\n    assert response.headers[\"cache-control\"] == \"public, max-age=12345\"\n\n\ndef test_etag():\n    response = client.get(\"/etag/12345\")\n    assert response.status_code == 200\n    assert response.headers[\"etag\"] == \"12345\"\n\n    headers = {\"If-None-Match\": \"12345\"}\n    response = client.get(\"/etag/12345\", headers = headers)\n    assert response.status_code == 304\n\n    headers = {\"If-None-Match\": \"67890\"}\n    response = client.get(\"/etag/12345\", headers = headers)\n    assert response.status_code == 200\n\n    headers = {\"If-Match\": \"12345\"}\n    response = client.get(\"/etag/12345\", headers = headers)\n    assert response.status_code == 200\n\n    headers = {\"If-Match\": \"67890\"}\n    response = client.get(\"/etag/12345\", headers = headers)\n    assert response.status_code == 412\n\n    #\n    # According to https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match,\n    # If-None-Match has precedence here.\n    #\n    headers = {\"If-None-Match\": \"12345\", \"If-Match\": \"12345\"}\n    response = client.get(\"/etag/12345\", headers = headers)\n    assert response.status_code == 304\n\n    headers = {\"If-None-Match\": \"67890\", \"If-Match\": \"12345\"}\n    response = client.get(\"/etag/12345\", headers = headers)\n    assert response.status_code == 200\n\n\ndef test_response_headers():\n\n    headers = {}\n    response = client.get(\"/response-headers\", params = headers)\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"0 headers set in response\"\n    \n\n    headers = {\"headers\": [\"x-cheetah-sound:chirp\"]}\n    response = client.get(\"/response-headers\", params = headers)\n    assert response.status_code == 200\n    assert \"x-cheetah-sound\" in response.headers\n    assert response.json()[\"message\"] == \"1 headers set in response\"\n\n    headers = {\"headers\": [\"x-cheetah-sound:chirp\", \"x-goat-sound:bleat\"]}\n    response = client.get(\"/response-headers\", params = headers)\n    assert response.status_code == 200\n    assert \"x-cheetah-sound\" in response.headers\n    assert \"x-goat-sound\" in response.headers\n    assert response.json()[\"message\"] == \"2 headers set in response\"\n\n    headers = {\"headers\": [\"x-this-should-fail\"]}\n    response = client.get(\"/response-headers\", params = headers)\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.str.format\"\n\n    headers = {\"headers\": [\"x-this:should:fail\"]}\n    response = client.get(\"/response-headers\", params = headers)\n    assert response.status_code == 422\n    assert response.json()[\"detail\"][\"type\"] == \"value_error.str.format\"\n\n\n\n"}
{"type": "source_file", "path": "lib/__init__.py", "content": ""}
{"type": "source_file", "path": "lib/apis/__init__.py", "content": "\nimport json, typing\nimport logging\n\nfrom fastapi import Query\n\nfrom starlette.responses import Response\n\n\n#\n# Grab our logger out of Uvicorn so we can make use of it in our endpoints.\n#\nlogger = logging.getLogger(\"uvicorn.error\")\n#logger.setLevel(logging.DEBUG)\n\n\n#\n# Set a response class that prettifies JSON.\n# Borrowed from https://stackoverflow.com/a/69221989/196073\n#\nclass PrettyJSONResponse(Response):\n    media_type = \"application/json\"\n\n    def render(self, content: typing.Any) -> bytes:\n        return json.dumps(\n            content,\n            ensure_ascii=False,\n            allow_nan=False,\n            indent=4,\n            separators=(\", \", \": \"),\n        ).encode(\"utf-8\")\n\n\n#\n# Our query parameters for our /redirect endpoints.\n#\nclass RedirectQueryParams():\n\n    def __init__(self,\n        code: int | None = Query(\n            default = 302, \n            description = \"Status code passed in from a previous redirect\", \n            example = 301)\n        ):\n        self.code = code\n\n\n"}
{"type": "source_file", "path": "lib/apis/cookies.py", "content": "#\n# All requests\n#\n\nfrom fastapi import APIRouter\nfrom fastapi import FastAPI, Header, Request, Response, Query, Body\n\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\n\n@router.get(\"/cookies\", summary = \"Show current cookies in the browser.\",\n    response_class=PrettyJSONResponse)\nasync def get(request: Request, response: Response):\n\n    retval = {}\n    for key, value in request.cookies.items():\n        response.set_cookie(key = key, value = value)\n\n    retval = {\"message\": f\"{len(request.cookies)} cookies seen in request.\"}\n    retval[\"cookies\"] = request.cookies\n\n    return(retval)\n\n\n@router.put(\"/cookies\", summary = \"Set one or more cookies.\",\n    response_class=PrettyJSONResponse)\nasync def put(request: Request, response: Response, \n    cookies: dict | None = Body(\n        example = '{\"cookie1\": \"value1\", \"cookie2\": \"value2\", \"cookie3\": \"value3\"}'\n    )):\n\n    retval = {}\n    for key, value in cookies.items():\n        response.set_cookie(key = key, value = value)\n\n    retval = {\"message\": f\"{len(cookies)} {'cookie' if len(cookies) == 1 else 'cookies'} set in response.\"}\n    retval[\"cookies\"] = request.cookies\n\n    return(retval)\n\n\n@router.delete(\"/cookies\", summary = \"Delete one or more cookies.\",\n    response_class=PrettyJSONResponse)\nasync def delete(request: Request, response: Response, cookies: list | None = Body(\n    example = '[\"cookie1\", \"cookie2\", \"cookie3\"]'\n    )):\n\n    retval = {}\n    num_deleted = 0\n\n    for key in cookies:\n        if key in request.cookies:\n            response.delete_cookie(key = key)\n            num_deleted += 1\n\n    retval = {\"message\": f\"{num_deleted} {'cookie' if num_deleted == 1 else 'cookies'} deleted.\"}\n\n    return(retval)\n\n\n\n\n"}
{"type": "source_file", "path": "lib/apis/dynamic.py", "content": "#\n# Dynamic data.\n#\n\nfrom io import BytesIO\nimport json\nfrom uuid import uuid4, UUID\nimport asyncio\nfrom datetime import datetime, timezone\n\nfrom fastapi import APIRouter, HTTPException\nfrom fastapi import FastAPI, Header, Request, Query, Path, Response\nfrom fastapi.responses import StreamingResponse\n\nimport qrcode\n\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\n\n#\n# Worker function to generate our QR Code.\n#\ndef get_qr_code(uuid):\n\n    qr = qrcode.QRCode(version = 1, box_size = 10, border = 4)\n    qr.add_data(uuid)\n    qr.make()\n    img = qr.make_image(fill_color = 'black', back_color = 'white')\n\n    #\n    # And put it into a buffer that we'll return\n    #\n    bytes = BytesIO()\n    img.save(bytes, format = \"png\")\n    retval = bytes.getvalue()\n\n    return(retval)\n\n\n@router.get(\"/uuid\", summary = \"Return a type 4 UUID.\",\n    response_class=PrettyJSONResponse)\nasync def uuid(request: Request):\n\n    url = request.url._url\n    uuid = uuid4()\n\n    retval = {}\n    retval[\"uuid\"] = uuid\n    retval[\"messages\"] = [\n        \"Do NOT use this endpoint as a source of randomness.  Please consider random.org instead.\",\n        f\"If you'd like a random QR code instead, try {url}/qrcode\",\n        f\"If you'd like *this* UUID as a QR code, try {url}/qrcode/{uuid}\",\n        ]\n    retval[\"timestamp\"] = datetime.now(timezone.utc).isoformat()\n    return(retval)\n\n\n@router.get(\"/uuid/qrcode\", summary = \"Return a QR code of a type 4 UUID.\",\n    responses={\n        200: {\n            \"content\": {\"image/png\": {}},\n            \"description\": \"Return a QR Code in PNG format.\",\n        }\n    },\n    response_class=Response)\nasync def uuid_qrcode():\n    uuid = uuid4()\n    qrcode = get_qr_code(uuid)\n    return Response(content = qrcode, media_type=\"image/png\")\n\n\n@router.get(\"/uuid/qrcode/{uuid}\", summary = \"Return a QR code of a *specified* type 4 UUID.\",\n    responses={\n        200: {\n            \"content\": {\"image/png\": {}},\n            \"description\": \"Return a QR Code in PNG format.\",\n        }\n    },\n    response_class=Response)\nasync def uuid_qrcode_qrcode(uuid: str):\n\n    try:\n        UUID(uuid)\n\n    except ValueError as e:\n        retval = {\"type\": \"value_error.str.validation\", \n            \"message\": f\"Value '{uuid}' must be a type 4 UUID in the format of 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx' where x is any hexidecimal digit and y is in the set (8, 9, a, b)\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    qrcode = get_qr_code(uuid)\n    return Response(content = qrcode, media_type=\"image/png\")\n\n\n@router.get(\"/delay/{seconds}\", summary = \"Return a delayed response (max of 10 seconds).\",\n    response_class=PrettyJSONResponse)\nasync def delay(request: Request, \n    debug: bool | None = None, \n    seconds: int = Path(example = 3)):\n\n    retval = {}\n    retval[\"timestamps\"] = {}\n    retval[\"timestamps\"][\"start\"] = datetime.now(timezone.utc).isoformat()\n    \n\n    if seconds < 0:\n        retval = {\"type\": \"value_error.int.min_size\", \"message\": f\"Value {seconds} is < 0\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    elif seconds > 10:\n        retval = {\"type\": \"value_error.int.max_size\", \"message\": f\"Value {seconds} is > 10\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n\n    if not debug:\n        await asyncio.sleep(seconds)\n\n    retval[\"message\"] = f\"Slept for {seconds} seconds before returning!\"\n    retval[\"timestamps\"][\"end\"] = datetime.now(timezone.utc).isoformat()\n\n    if debug:\n        retval[\"debug\"] = \"(Debug mode was on, so no actual sleeping happened.)\"\n\n    return(retval)\n\n\n#\n# Our coroutine to return results in a stream.\n#\nasync def streamer(n):\n    for i in range(n):\n        row = {\"response_number\": (i + 1), \"uuid\": str(uuid4())}\n        yield(json.dumps(row) + \"\\n\")\n\n\n@router.get(\"/stream/{n}\", summary = \"Steam n JSON responses.  (max of 100)\")\nasync def stream(request: Request, n: int = Path(example = 3)):\n\n    if n <= 0:\n        retval = {\"type\": \"value_error.int.min_size\", \"message\": f\"Value {n} is <= 0\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    elif n > 100:\n        retval = {\"type\": \"value_error.int.max_size\", \"message\": f\"Value {n} is > 100\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    return(StreamingResponse(streamer(n)))\n\n\n#\n# Add a newline onto the end of the buffer.\n#\ndef add_newline(buf):\n\n    if buf:\n        buf = list(buf)\n        buf[len(buf) - 1] = \"\\n\"\n        buf = \"\".join(buf)\n\n    return(buf)\n\n\n#\n# Return results in a stream with a second pause between them.\n#\n# @param int n Number of characters to sendin total\n# @param int rate How many characters to send each second.\n# @param bool debug If set, we won't sleep.\n#\nasync def streamer_rate(n, rate, debug):\n\n    buf = \"\"\n    num_left = n\n    while True:\n\n        for i in (range(48, 123)):\n\n            #\n            # Add a character to our buffer, and when we hit the limit\n            # change the last character to a newline and yield that buffer.\n            #\n            buf += chr(i)\n            if len (buf) >= rate:\n                buf = add_newline(buf)\n                yield(buf)\n                if not debug:\n                    await asyncio.sleep(1)\n                buf = \"\"\n\n            #\n            # If we're out of characters to display, return what we have then break out of this loop.\n            #\n            num_left -= 1\n            if num_left <= 0:\n                buf = add_newline(buf)\n                yield(buf)\n                break\n\n        if num_left <= 0:\n            break\n\n\n@router.get(\"/stream/chars/{n}/{rate}\", \n    summary = \"Stream n bytes (max 100K) at a rate of rate per second. Max time is 20 seconds.\")\nasync def stream_chars(request: Request, \n    debug: bool | None = None, \n    n: int = Path(example = 128), \n    rate: int = Path(example = 50)):\n\n    percent = (rate / n) * 100\n\n    if n < 0:\n        retval = {\"type\": \"value_error.int.min_size\", \"message\": f\"Value {n} bytes is <= 0\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    elif n > 102400:\n        retval = {\"type\": \"value_error.int.max_size\", \"message\": f\"Value {n} bytes is > 102400\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    elif percent < 5:\n        retval = {\"type\": \"value_error.int.min_size\", \n            \"message\": f\"{n} / {rate} = {percent:.2f} percent.  This means runtime will take longer than 20 seconds.  Please try a larger rate.\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    return(StreamingResponse(streamer_rate(n, rate, debug)))\n\n\n#\n# Return results in a stream with a second pause between them.\n#\n# @param int n Number of characters to sendin total\n# @param int rate How many characters to send each second.\n# @param bool debug If set, we won't sleep.\n#\nasync def streamer_rate_complete(n, rate, debug):\n\n    buf = \"\"\n    num_left = n\n    num_loops_left = 10\n    done = False\n\n    while True:\n\n        for i in (range(48, 123)):\n\n            #\n            # Add a character to our buffer, and when we hit the limit\n            # change the last character to a newline and yield that buffer.\n            #\n            buf += chr(i)\n            if len (buf) >= rate:\n                buf = add_newline(buf)\n                yield(buf)\n                if not debug:\n                    await asyncio.sleep(1)\n                buf = \"\"\n                num_loops_left -= 1\n\n            #\n            # If we're out of characters to display, return what we have then break out of this loop.\n            #\n            num_left -= 1\n            if num_left <= 0:\n                if buf:\n                    buf = add_newline(buf)\n                    yield(buf)\n                done = True\n                break\n\n            if num_loops_left <= 0:\n                done = True\n                break\n\n        if done:\n            break\n\n    #\n    # If we have any charcters left to display, dump them out all at once.\n    #\n    if num_left:\n\n        buf = \"\"\n        done = False\n\n        while True:\n\n            for i in (range(48, 123)):\n                buf += chr(i)\n                num_left -= 1\n\n                if num_left <= 0:\n                    if buf:\n                        buf = add_newline(buf)\n                        yield(buf)\n                    done = True\n                    break\n\n            if done:\n                break\n\n\n@router.get(\"/stream/chars/complete/{n}/{rate}\", \n    summary = \"Stream n bytes (max 100K) at a rate of rate per second. Any outstanding characters due to a low rate will be sent at the very end.  Max time is 10 seconds.\")\nasync def stream_chars_complete(request: Request, \n    debug: bool | None = None, \n    n: int = Path(example = 128), \n    rate: int = Path(example = 50)):\n\n    percent = (rate / n) * 100\n\n    if n < 0:\n        retval = {\"type\": \"value_error.int.min_size\", \"message\": f\"Value {n} bytes is <= 0\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    elif n > 102400:\n        retval = {\"type\": \"value_error.int.max_size\", \"message\": f\"Value {n} bytes is > 102400\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    elif rate <= 0:\n        retval = {\"type\": \"value_error.int.min_size\", \"message\": f\"Value rate {rate} is <= 0\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    return(StreamingResponse(streamer_rate_complete(n, rate, debug)))\n\n\n\n"}
{"type": "source_file", "path": "lib/apis/images.py", "content": "#\n# Redirect endpoints.\n#\n\nimport random\n\nfrom fastapi import APIRouter, FastAPI, Header, Response, Query, Path, HTTPException\nfrom fastapi.responses import RedirectResponse, JSONResponse\nfrom fastapi.responses import FileResponse\n\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\n\n@router.get(\"/images/jpeg\", summary = \"Returns a JPEG image.\",\n    response_class = FileResponse,\n    responses={\n        200: {\n            \"content\": {\"image/jpeg\": {}},\n            \"description\": \"Return an image in JPG format.\",\n        }\n    }\n    )\nasync def get(response: Response):\n    return FileResponse(\"private/cheetah.jpeg\")\n\n\n@router.get(\"/images/png\", summary = \"Returns a PNG image.\",\n    response_class = FileResponse,\n    responses={\n        200: {\n            \"content\": {\"image/png\": {}},\n            \"description\": \"Return an image in PNG format.\",\n        }\n    }\n    )\nasync def get(response: Response):\n    return FileResponse(\"private/cheetah.png\")\n\n\n@router.get(\"/images/heic\", \n    summary = \"Returns a HEIC image. (This may not be displayed correctly in some browsers)\",\n    response_class = FileResponse,\n    responses={\n        200: {\n            \"content\": {\"image/heic\": {}},\n            \"description\": \"Return an image in HEIC format.\",\n        }\n    }\n    )\nasync def get(response: Response):\n    return FileResponse(\"private/cheetah.heic\")\n\n\n@router.get(\"/images/webp\", summary = \"Returns a Webp image.\",\n    response_class = FileResponse,\n    responses={\n        200: {\n            \"content\": {\"image/webp\": {}},\n            \"description\": \"Return an image in Webp format.\",\n        }\n    }\n    )\nasync def get(response: Response):\n    return FileResponse(\"private/cheetah.webp\", headers = { \"content-type\": \"image/webp\"})\n\n\n\n"}
{"type": "source_file", "path": "lib/apis/methods.py", "content": "#\n# All requests\n#\n\nimport json\nfrom urllib.parse import parse_qs\n\nfrom fastapi import APIRouter\nfrom fastapi import FastAPI, Header, Request\n\nfrom . import logger\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\ndata_default = {\n    \"message\": \"No JSON/bad JSON supplied.  If you used Swagger, you'll need to use curl on the CLI with the -d option instead for non-GET methods, or GET-method data for GET.\"\n    }\n\n\n#\n# Our core function to return the same data for each request.\n#\ndef core(request: Request):\n\n    retval = {}\n\n    retval[\"args\"] = request.query_params\n    retval[\"headers\"] = request.headers\n    retval[\"source\"] = {\n        \"ip\": request.client.host,\n        \"port\": request.client.port\n        }\n    retval[\"url\"] = str(request.url)\n\n    return(retval)\n\n\n@router.get(\"/get\", summary = \"The request's GET parameters.\",\n    response_class=PrettyJSONResponse)\nasync def get(request: Request):\n    retval = core(request)\n    retval[\"_comment\"] = \"If you want ONLY the GET method data, try the endpoint /get/args instead.\"\n    return(retval)\n\n\n@router.get(\"/get/args\", summary = \"JUST the request's GET parameters, without extra environment data.\",\n    response_class=PrettyJSONResponse)\nasync def get(request: Request):\n    retval = core(request)\n    retval = retval[\"args\"]\n    return(retval)\n\n\n@router.post(\"/post\", summary = \"The request's POST parameters. (Use -d in curl to specify data in JSON format)\",\n    response_class=PrettyJSONResponse)\nasync def post(request: Request):\n\n    data = data_default\n    content_type = request.headers.get(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n    try:\n        if content_type == \"application/json\":\n            data = await request.json()\n\n        else:\n            # Assume that it was a normal form submission\n            body = await request.body()\n            data = parse_qs(body)\n\n    except json.decoder.JSONDecodeError as e:\n        logger.warning(f\"{__name__}:post(): Caught error deserializing JSON: {e}\")\n\n    retval = core(request)\n    retval[\"data\"] = data\n    return(retval)\n\n\n@router.put(\"/put\", summary = \"The request's PUT parameters. (Use -d in curl to specify data in JSON format)\",\n    response_class=PrettyJSONResponse)\nasync def put(request: Request):\n\n    data = data_default\n\n    try:\n        data = await request.json()\n    except json.decoder.JSONDecodeError as e:\n        logger.warning(f\"{__name__}:put(): Caught error deserializing JSON: {e}\")\n\n    retval = core(request)\n    retval[\"data\"] = data\n    return(retval)\n\n\n@router.patch(\"/patch\", summary = \"The request's PATCH parameters. (Use -d in curl to specify data in JSON format)\",\n    response_class=PrettyJSONResponse)\nasync def patch(request: Request):\n\n    data = data_default\n\n    try:\n        data = await request.json()\n    except json.decoder.JSONDecodeError as e:\n        logger.warning(f\"{__name__}:patch(): Caught error deserializing JSON: {e}\")\n\n    retval = core(request)\n    retval[\"data\"] = data\n    return(retval)\n\n\n@router.delete(\"/delete\", summary = \"The request's DELETE parameters.\",\n    response_class=PrettyJSONResponse)\nasync def delete(request: Request):\n    data = data_default\n    retval = core(request)\n    retval[\"data\"] = data\n    return(retval)\n\n\n\n"}
{"type": "source_file", "path": "lib/apis/qrcode.py", "content": "#\n# QR Code endpoints\n#\n\nfrom io import BytesIO\nimport random\n\nfrom fastapi import APIRouter, FastAPI, Header, Response, Query, Path, HTTPException, Form\nfrom fastapi.responses import RedirectResponse, JSONResponse\nfrom fastapi.responses import FileResponse\nfrom pydantic import BaseModel, Field\n\nimport qrcode\n\nrouter = APIRouter()\n\n\n#\n# Actually make our image\n#\ndef make_image(qr, transparent_background):\n\n    # No transparent background?  No problem!\n    if not transparent_background:\n        img = qr.make_image(fill_color = 'black', back_color = 'white')\n        return(img)\n\n    #\n    # Transparent backgrounds are little more involved.\n    # We'll have to go through each pixel, and change the background to be transparent.\n    #\n    img = qr.make_image(fill_color = 'black', back_color = 'white').convert('RGBA')\n\n    data = img.getdata()\n\n    new_data = []\n    for item in data:\n        # If the pixel is white, change it to transparent.  Otherwise, leave it alone.\n        if item[:3] == (255, 255, 255):\n            new_data.append((255, 255, 255, 0))\n        else:\n            new_data.append(item)\n\n    # Update image data and return the image.\n    img.putdata(new_data)\n\n    return(img)\n\n#\n# Worker function to generate our QR Code.\n#\ndef get_qr_code(url, box_size, border, transparent_background):\n\n    #\n    # Do some sanity checks\n    #\n    if box_size < 0:\n        retval = {\"type\": \"value_error.int.min_size\", \"message\": f\"Box_size {box_size} is < 0\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    elif border < 4:\n        #\n        # According to https://github.com/lincolnloop/python-qrcode, the minimum border is 4\n        # according to the QR Code spec.\n        #\n        retval = {\"type\": \"value_error.int.min_size\", \"message\": f\"Border {border} is < 4\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    elif box_size > 20:\n        retval = {\"type\": \"value_error.int.max_size\", \"message\": f\"Box_size {box_size} is > 20\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    elif border > 20:\n        retval = {\"type\": \"value_error.int.max_size\", \"message\": f\"Border {border} is > 20\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    qr = qrcode.QRCode(version = 1, box_size = box_size, border = border)\n    qr.add_data(url)\n    qr.make()\n\n    img = make_image(qr, transparent_background)\n\n    #\n    # And put it into a buffer that we'll return\n    #\n    bytes = BytesIO()\n    img.save(bytes, format = \"png\")\n    retval = bytes.getvalue()\n\n    return(retval)\n\n\n@router.post(\"/qrcode/form\", summary = \"Returns a QR Code in PNG format from form submission.\",\n    responses={\n        200: {\n            \"content\": {\"image/png\": {}},\n            \"description\": \"Return a QR Code in PNG format.\",\n        }\n    },\n    response_class=Response\n    )\nasync def qrcode_post_form(url: str = Form(),\n    box_size: int = Form(), \n    border: int = Form(),\n    transparent_background: bool = Form(False),\n    ):\n    qrcode = get_qr_code(url, box_size, border, transparent_background)\n    return Response(content = qrcode, media_type=\"image/png\")\n\n\n#\n# Create our QRCode model.\n# This is necessary so that the JSON is passed into the body.  Otherwise FastAPI\n# will want the JSON to be passed in as GET-method data, even for a POST.  If that\n# sounds weird, it's because it is.  That is maybe the sole issue I have with FastAPI.\n#\nclass QRCode(BaseModel):\n    url: str = Field(min_length = 4, max_length = 1024)\n    box_size: int = Field(default = 10, gt = 0, le = 20)\n    border: int = Field(default = 4, gt = 0, le = 20)\n    transparent_background: bool = Form(False)\n    \n@router.post(\"/qrcode/json\", summary = \"Returns a QR code in PNG format from POSTed JSON.\",\n    responses={\n        200: {\n            \"content\": {\"image/png\": {}},\n            \"description\": \"Return a QR Code in PNG format.\",\n        }\n    },\n    response_class=Response\n    )\nasync def qrcode_post(data: QRCode):\n    url = data.url\n    box_size = data.box_size\n    border = data.border\n    transparent_background = data.transparent_background\n    #print(\"Debugging\", url, box_size, border, transparent_background) # Debugging\n    qrcode = get_qr_code(url, box_size, border, transparent_background)\n    return Response(content = qrcode, media_type=\"image/png\")\n\n\n#\n# Set up our redirect.\n#\n@router.get(\"/qrcode\", include_in_schema = False)\nasync def qrcode_get():\n    return RedirectResponse(f\"/qrcode/\", status_code = 302)\n\n\n#\n# Commenting these out, because I don't think I'm actually using them with the latest revision.\n#\n#@router.post(\"/qr\", include_in_schema = False)\n#async def qr_post():\n#    return RedirectResponse(f\"/qrcode/\", status_code = 302)\n#\n#\n#@router.post(\"/qr-code\", include_in_schema = False)\n#async def qr_code_post():\n#    return RedirectResponse(f\"/qrcode/\", status_code = 302)\n\n\n\n"}
{"type": "source_file", "path": "lib/apis/redirect.py", "content": "#\n# Redirect endpoints.\n#\n\nimport random\n\nfrom fastapi import APIRouter, FastAPI, Header, Response, Path, HTTPException, Depends\nfrom fastapi.responses import RedirectResponse, JSONResponse\n\nfrom . import PrettyJSONResponse\nfrom . import RedirectQueryParams\n\nrouter = APIRouter()\n\n\ndef core(response, n, code):\n\n    #\n    # Do some sanity checking.\n    # I originally wanted a custom exception, but it got *really* challenging figuring\n    # out how to add an exception while in a router, and adding it to app didn't help either. :-(\n    #\n    if n > 20:\n        retval = {\"type\": \"value_error.int.max_size\", \"message\": f\"Value {n} is > 20\"}\n        raise HTTPException(status_code = 422, detail = retval)\n\n    if n > 1:\n        return RedirectResponse(f\"/redirect/{n - 1}?code={code}\", status_code = code)\n\n    if n <= 1:\n        return RedirectResponse(f\"/redirect/final?code={code}\", status_code = code)\n\n    return(retval)\n\n\n@router.get(\"/redirect/{n}\", \n    summary = \"302 Redirects n times. (Note that Swagger follows redirects, so use the Curl command to see redirect headers.\",\n    response_class=PrettyJSONResponse)\nasync def get(response: Response, \n    n: int = Path(example = 3, description = \"Number of redirects to perform\"),\n    params: RedirectQueryParams = Depends()\n    ):\n    response = core(response, n, params.code)\n    response.headers[\"x-http-redirect-code\"] = str(params.code)\n    return(response)\n\n\n@router.post(\"/redirect/{n}\", \n    summary = \"302 Redirects n times. (Note that Swagger follows redirects, so use the Curl command to see redirect headers.\",\n    response_class=PrettyJSONResponse)\nasync def post(response: Response, \n    n: int = Path(example = 3, description = \"Number of redirects to perform\"),\n    params: RedirectQueryParams = Depends()\n    ):\n    response = core(response, n, params.code)\n    response.headers[\"x-http-redirect-code\"] = str(params.code)\n    return(response)\n\n\n@router.put(\"/redirect/{n}\", \n    summary = \"302 Redirects n times. (Note that Swagger follows redirects, so use the Curl command to see redirect headers.\",\n    response_class=PrettyJSONResponse)\nasync def put(response: Response, \n    n: int = Path(example = 3, description = \"Number of redirects to perform\"),\n    params: RedirectQueryParams = Depends()\n    ):\n    response = core(response, n, params.code)\n    response.headers[\"x-http-redirect-code\"] = str(params.code)\n    return(response)\n\n\n@router.patch(\"/redirect/{n}\", \n    summary = \"302 Redirects n times. (Note that Swagger follows redirects, so use the Curl command to see redirect headers.\",\n    response_class=PrettyJSONResponse)\nasync def patch(response: Response, \n    n: int = Path(example = 3, description = \"Number of redirects to perform\"),\n    params: RedirectQueryParams = Depends()\n    ):\n    response = core(response, n, params.code)\n    response.headers[\"x-http-redirect-code\"] = str(params.code)\n    return(response)\n\n\n@router.delete(\"/redirect/{n}\", \n    summary = \"302 Redirects n times. (Note that Swagger follows redirects, so use the Curl command to see redirect headers.\",\n    response_class=PrettyJSONResponse)\nasync def delete(response: Response, \n    n: int = Path(example = 3, description = \"Number of redirects to perform\"),\n    params: RedirectQueryParams = Depends()\n    ):\n    response = core(response, n, params.code)\n    response.headers[\"x-http-redirect-code\"] = str(params.code)\n    return(response)\n\n\n\n"}
{"type": "source_file", "path": "lib/apis/redirect_final.py", "content": "#\n# Final endpoints for redirects, which will include the original status code.\n# These are hidden from the Swagger documentation, because there's no real point\n# in showing them to the user, and they'll just clutter up the site.\n#\n\nimport random\n\nfrom fastapi import APIRouter, FastAPI, Header, Response, Path, HTTPException, Depends\nfrom fastapi.responses import RedirectResponse, JSONResponse\n\nfrom . import PrettyJSONResponse\nfrom . import RedirectQueryParams\n\nrouter = APIRouter()\n\n\n@router.get(\"/redirect/final\",\n    summary = \"Final endpoint after one or more redirects.\",\n    response_class=PrettyJSONResponse,\n    include_in_schema = False)\nasync def get(\n    response: Response,\n    params: RedirectQueryParams = Depends()\n    ):\n    response = {\n        \"message\": \"Reached the end of our redirects!\",\n        \"code\": params.code\n        }\n    return(response)\n\n@router.put(\"/redirect/final\",\n    summary = \"Final endpoint after one or more redirects.\",\n    response_class=PrettyJSONResponse,\n    include_in_schema = False)\nasync def get(\n    response: Response,\n    params: RedirectQueryParams = Depends()\n    ):\n    response = {\n        \"message\": \"Reached the end of our redirects!\",\n        \"code\": params.code\n        }\n    return(response)\n\n@router.post(\"/redirect/final\",\n    summary = \"Final endpoint after one or more redirects.\",\n    response_class=PrettyJSONResponse,\n    include_in_schema = False)\nasync def get(\n    response: Response,\n    params: RedirectQueryParams = Depends()\n    ):\n    response = {\n        \"message\": \"Reached the end of our redirects!\",\n        \"code\": params.code\n        }\n    return(response)\n\n@router.delete(\"/redirect/final\",\n    summary = \"Final endpoint after one or more redirects.\",\n    response_class=PrettyJSONResponse,\n    include_in_schema = False)\nasync def get(\n    response: Response,\n    params: RedirectQueryParams = Depends()\n    ):\n    response = {\n        \"message\": \"Reached the end of our redirects!\",\n        \"code\": params.code\n        }\n    return(response)\n\n@router.patch(\"/redirect/final\",\n    summary = \"Final endpoint after one or more redirects.\",\n    response_class=PrettyJSONResponse,\n    include_in_schema = False)\nasync def get(\n    response: Response,\n    params: RedirectQueryParams = Depends()\n    ):\n    response = {\n        \"message\": \"Reached the end of our redirects!\",\n        \"code\": params.code\n        }\n    return(response)\n\n\n"}
{"type": "source_file", "path": "lib/apis/response.py", "content": "#\n# All responses.\n#\n\nimport re\n\nfrom fastapi import APIRouter, Query, Body, Path\nfrom fastapi import FastAPI, Header, Request, Response, HTTPException\n\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\n\n@router.get(\"/cache\", \n    summary = \"Returns a 304 if an If-Modified-Since header or If-None-Match is present. Returns the same as a GET otherwise.\")\nasync def cache(request: Request, response: Response):\n    if \"if-modified-since\" in request.headers:\n        response.status_code = 304\n    elif \"if-none-match\" in request.headers:\n        response.status_code = 304\n\n    return(None)\n\n\n@router.get(\"/cache/{seconds}\", summary = \"Sets a Cache-Control header for n seconds.\")\nasync def cache_seconds(request: Request, response: Response, seconds: int = Path(example = 3)):\n    response.headers[\"cache-control\"] = f\"public, max-age={seconds}\"\n\n\n@router.get(\"/etag/{etag}\", \n    summary = \"Assumes the resource has the given etag and responds to If-None-Match and If-Match headers appropriately.\")\nasync def etag(request: Request, response: Response, etag: str = Path(example = \"test-etag\")):\n    response.headers[\"etag\"] = etag\n\n    if \"if-none-match\" in request.headers:\n        if request.headers[\"if-none-match\"] == etag:\n            response.status_code = 304\n\n    elif \"if-match\" in request.headers:\n        if request.headers[\"if-match\"] != etag:\n            response.status_code = 412\n\n\n\n@router.get(\"/response-headers\",\n    summary = \"Set arbitrary headers in the response.  Input strings should be in the format of 'header:value'.\",\n    response_class=PrettyJSONResponse)\ndef response_headers_get(response: Response, headers: list[str] = Query(default = [])):\n\n    #\n    # Sanity check our headers, since we can't use the regex parameter on a list.\n    #\n    for header in headers:\n        if not re.search(\"^[^:]+:[^:]+$\", header):\n            retval = {\"type\": \"value_error.str.format\",\n                \"message\": f\"Parameter '{header}' not in format 'header:value\"}\n            raise HTTPException(status_code = 422, detail = retval)\n\n    retval = {\"message\": f\"{len(headers)} headers set in response\"}\n        \n    for header in headers:\n        key, value = header.split(\":\")\n        response.headers[key] = value\n    return(retval)\n\n\n\n"}
{"type": "source_file", "path": "lib/apis/response_formats.py", "content": "#\n# All responses.\n#\n\nimport re\n\nfrom fastapi import APIRouter, Query, Body\nfrom fastapi import FastAPI, Header, Request, Response, HTTPException\nfrom fastapi.responses import PlainTextResponse, HTMLResponse\n\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\n\n@router.get(\"/html\", response_class = HTMLResponse,\n    summary = \"Returns an HTML document.\")\nasync def html(response: Response):\n\n    retval = \"\"\"\n<!DOCTYPE html>\n<html>\n  <head>\n  </head>\n  <body>\n      <h1>FastAPI Httpbin HTMLResponse</h1>\n\n      <div>\n        <p>\n            This is a sample HTML response.\n        </p>\n      </div>\n  </body>\n</html>\n\"\"\"\n\n    return(retval)\n\n\n@router.get(\"/json\", summary = \"Returns a JSON document.\",\n    response_class=PrettyJSONResponse)\nasync def json(response: Response):\n\n    retval = {\n        \"title\": \"Undertale Soundtrack\",\n        \"author\": \"Toby Fox\",\n        \"tracks\": [\n            \"Once Upon a Time\",\n            \"Your Best Friend\",\n            \"Fallen Down\",\n            \"Enemy Approaching\",\n            \"Determination\",\n            \"Nyeh Heh Heh!\",\n            \"Dogsong\",\n            \"Snowdin Town\",\n            \"Bonetrousle\",\n            \"Quiet Water\",\n            \"Temmie Village\",\n            \"Spear of Justice\",\n            \"Spider Dance\",\n            \"It's Raining Somewhere Else\",\n            \"CORE\",\n            \"Death by Glamour\",\n            \"The Choice\",\n            \"Your Best Nightmare\",\n            \"Finale\",\n            \"An Ending\",\n            \"Fallen Down (Reprise)\",\n            \"Don't Give Up\",\n            \"Hopes and Dreams\",\n            \"Reunited\",\n            \"Last Goodbye\"\n            ],\n        \"urls\": [\n            \"https://en.wikipedia.org/wiki/Undertale_Soundtrack\",\n            \"https://www.youtube.com/watch?v=tz82xbLvK_k&list=OLAK5uy_l6pEkEJgy577R-aDlJ3Gkp5rmlgIOu8bc&index=87\"\n            ]\n        }\n\n    return(retval)\n\n\n@router.get(\"/robots.txt\", summary = \"Returns some robots.txt rules.\")\nasync def robots_txt(response: Response):\n\n    retval = \"\"\"\nUser-agent: *\nDisallow: /deny\n\"\"\"\n    return Response(retval, media_type = \"text/plain\")\n\n\n@router.get(\"/deny\", summary = \"Returns a page denied by rules in robots.txt.\")\nasync def deny(response: Response):\n\n    retval = \"\"\"\n░░░░░░░░░░░░░░░░░░░░\n░▄▀▄▀▀▀▀▄▀▄░░░░░░░░░\n░█░░░░░░░░▀▄░░░░░░▄░\n█░░▀░░▀░░░░░▀▄▄░░█░█\n█░▄░█▀░▄░░░░░░░▀▀░░█\n█░░▀▀▀▀░░░░░░░░░░░░█\n█░░░░░░░░░░░░░░░░░░█\n█░░░░░░░░░░░░░░░░░░█\n░█░░▄▄░░▄▄▄▄░░▄▄░░█░\n░█░▄▀█░▄▀░░█░▄▀█░▄▀░\n░░▀░░░▀░░░░░▀░░░▀░░░\n\nYou pet the Dog. Its excitement knows no bounds.\n\"\"\"\n    return Response(retval, media_type = \"text/plain\")\n\n\n@router.get(\"/xml\", summary = \"Returns an XML document\")\nasync def xml(response: Response):\n\n    retval = \"\"\"\n        <?xml version='1.0' encoding='us-ascii'?>\n        <title>Undertale Soundtrack</title>\n        <author>Toby Fox</author>\n        <tracks>\n            <track>Once Upon a Time</track>\n            <track>Your Best Friend</track>\n            <track>Fallen Down</track>\n            <track>Enemy Approaching</track>\n            <track>Determination</track>\n            <track>Nyeh Heh Heh!</track>\n            <track>Dogsong</track>\n            <track>Snowdin Town</track>\n            <track>Bonetrousle</track>\n            <track>Quiet Water</track>\n            <track>Temmie Village</track>\n            <track>Spear of Justice</track>\n            <track>Spider Dance</track>\n            <track>It's Raining Somewhere Else</track>\n            <track>CORE</track>\n            <track>Death by Glamour</track>\n            <track>The Choice</track>\n            <track>Your Best Nightmare</track>\n            <track>Finale</track>\n            <track>An Ending</track>\n            <track>Fallen Down (Reprise)</track>\n            <track>Don't Give Up</track>\n            <track>Hopes and Dreams</track>\n            <track>Reunited</track>\n            <track>Last Goodbye</track>\n        </tracks>\n        <url>https://en.wikipedia.org/wiki/Undertale_Soundtrack</url>\n\"\"\"\n\n    return Response(retval, media_type = \"application/xml \")\n\n\n@router.get(\"/encoding/utf8\", summary = \"Returns a UTF-8 Encoded body.\")\nasync def utf8(response: Response):\n\n    retval = \"\"\n\n    with open(\"private/utf8.txt\") as f:\n        lines = f.readlines()\n\n    retval = \"\".join(lines)\n\n    return Response(retval, media_type = \"text/plain\")\n\n\n\n"}
{"type": "source_file", "path": "lib/apis/anything.py", "content": "#\n# All requests\n#\n\nimport json\n\nfrom fastapi import APIRouter\nfrom fastapi import FastAPI, Header, Request\n\nfrom . import logger\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\ndata_default = {\n    \"message\": \"No JSON/bad JSON supplied.  If you used Swagger, you'll need to use curl on the CLI with the -d option instead for non-GET methods, or GET-method data for GET.\"\n    }\n\n\n#\n# Our core function to return the same data for each request.\n#\ndef core(request: Request):\n\n    retval = {}\n\n    retval[\"args\"] = request.query_params\n    retval[\"headers\"] = request.headers\n    retval[\"source\"] = {\n        \"ip\": request.client.host,\n        \"port\": request.client.port\n        }\n    retval[\"url\"] = str(request.url)\n\n    return(retval)\n\n\n@router.get(\"/anything\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse)\n@router.head(\"/anything\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse)\n@router.get(\"/any\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse, include_in_schema = False)\n@router.head(\"/any\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse, include_in_schema = False)\nasync def get(request: Request):\n\n    retval = core(request)\n    retval[\"data\"] = data_default\n    retval[\"verb\"] = \"GET\"\n    return(retval)\n\n\n@router.post(\"/anything\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse)\n@router.post(\"/any\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse, include_in_schema = False)\nasync def post(request: Request):\n\n    data = data_default\n\n    try:\n        data = await request.json()\n    except json.decoder.JSONDecodeError as e:\n        logger.warning(f\"{__name__}:post(): Caught error deserializing JSON: {e}\")\n\n    retval = core(request)\n    retval[\"data\"] = data\n    retval[\"verb\"] = \"POST\"\n    return(retval)\n\n\n@router.put(\"/anything\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse)\n@router.put(\"/any\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse, include_in_schema = False)\nasync def put(request: Request):\n\n    data = data_default\n\n    try:\n        data = await request.json()\n    except json.decoder.JSONDecodeError as e:\n        logger.warning(f\"{__name__}:put(): Caught error deserializing JSON: {e}\")\n\n    retval = core(request)\n    retval[\"data\"] = data\n    retval[\"verb\"] = \"PUT\"\n    return(retval)\n\n\n@router.patch(\"/anything\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse)\n@router.patch(\"/any\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse, include_in_schema = False)\nasync def patch(request: Request):\n\n    data = data_default\n\n    try:\n        data = await request.json()\n    except json.decoder.JSONDecodeError as e:\n        logger.warning(f\"{__name__}:patch(): Caught error deserializing JSON: {e}\")\n\n    retval = core(request)\n    retval[\"data\"] = data\n    retval[\"verb\"] = \"PATCH\"\n    return(retval)\n\n\n@router.delete(\"/anything\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse)\n@router.delete(\"/any\", summary = \"Returns anything that is passed into the request.\",\n    response_class=PrettyJSONResponse, include_in_schema = False)\nasync def delete(request: Request):\n\n    data = data_default\n    try:\n        data = await request.json()\n    except json.decoder.JSONDecodeError as e:\n        logger.warning(f\"{__name__}:delete(): Caught error deserializing JSON: {e}\")\n\n    retval = core(request)\n    retval[\"data\"] = data\n    retval[\"verb\"] = \"DELETE\"\n    return(retval)\n\n\n"}
{"type": "source_file", "path": "lib/apis/meta.py", "content": "#\n# All requests\n#\n\nimport json\n\nfrom fastapi import APIRouter\nfrom fastapi import FastAPI, Header, Request\n\nfrom lib.fastapi import tags_metadata, description, app_version\n\nfrom . import logger\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\n\n@router.get(\"/version\", summary = \"The version of this app.\",\n    response_class=PrettyJSONResponse)\nasync def version(request: Request):\n\n    retval = {}\n    retval[\"version\"] = app_version\n\n    return(retval)\n\n\n"}
{"type": "source_file", "path": "lib/apis/request.py", "content": "#\n# All requests\n#\n\nfrom fastapi import APIRouter, HTTPException\nfrom fastapi import FastAPI, Header, Request\n\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\n\n@router.get(\"/headers\", summary = \"Return the headers sent in the request.\",\n    response_class=PrettyJSONResponse)\nasync def get(request: Request):\n    retval = {}\n    retval = request.headers\n    return(retval)\n\n\n#\n# Get our IP address\n#\ndef get_ip(headers, client):\n\n    if \"fly-client-ip\" in headers:\n        retval = headers[\"fly-client-ip\"]\n\n    elif \"x-forwarded-for\" in headers:\n        retval = headers[\"x-forwarded-for\"]\n\n    else:\n        retval = client.host\n\n    return(retval)\n\n\n@router.get(\"/ip\", summary = \"Return the user's IP address.\", \n    response_class=PrettyJSONResponse)\nasync def ip(request: Request):\n\n    retval = {}\n\n    ip = get_ip(request.headers, request.client)\n    retval[\"ip\"] = ip\n\n    retval[\"message\"] = []\n    retval[\"message\"].append(\"If you're looking for v4 or v6 specific endpoints, try /ip/v4 or /ip/v6.\")\n    retval[\"message\"].append(\"If you want to ping this IP and graph the results, I built an app for that too: https://github.com/dmuth/grafana-network-monitor\")\n\n    return(retval)\n\n\n@router.get(\"/ip/v4\", summary = \"Return the user's IPv4 address (if present).\", \n    responses={\n        200: {\n            \"description\": \"Return the user's IPv4 address, if present.\",\n        },\n        422: {\n            \"description\": \"Returned if user came in over IPv6\",\n        },\n    },\n    response_class=PrettyJSONResponse)\nasync def ipv4(request: Request):\n\n    retval = {}\n    retval[\"ip\"] = \"\"\n\n    ip = get_ip(request.headers, request.client)\n\n    if \":\" not in ip:\n        retval[\"ip\"] = ip\n    else:\n        retval[\"message\"] = \"This does not appear to be a request made over IPv4\"\n        raise HTTPException(status_code = 422, detail = retval)\n\n    return(retval)\n\n\n@router.get(\"/ip/v6\", summary = \"Return the user's IPv6 address (if present).\", \n    responses={\n        200: {\n            \"description\": \"Return the user's IPv6 address, if present.\",\n        },\n        422: {\n            \"description\": \"Returned if user came in over IPv4\",\n        },\n    },\n    response_class=PrettyJSONResponse)\nasync def ipv6(request: Request):\n\n    retval = {}\n    retval[\"ip\"] = \"\"\n\n    ip = get_ip(request.headers, request.client)\n\n    if \":\" in ip:\n        retval[\"ip\"] = ip\n    else:\n        retval[\"message\"] = \"This does not appear to be a request made over IPv6\"\n        raise HTTPException(status_code = 422, detail = retval)\n\n    return(retval)\n\n\n\n@router.get(\"/user-agent\", summary = \"Request the User Agent.\",\n    response_class=PrettyJSONResponse)\nasync def user_agent(request: Request):\n    retval = {}\n    retval[\"user-agent\"] = request.headers[\"user-agent\"]\n    return(retval)\n\n\n"}
{"type": "source_file", "path": "main.py", "content": "\nimport platform\n\nfrom typing import Union\n\nfrom fastapi import FastAPI, Request, Response\nfrom fastapi.responses import FileResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom pydantic import BaseModel\n\n\nfrom lib.apis import methods\nfrom lib.apis import request\nfrom lib.apis import status\nfrom lib.apis import redirect\nfrom lib.apis import redirect_final\nfrom lib.apis import anything\nfrom lib.apis import response\nfrom lib.apis import response_formats\nfrom lib.apis import cookies\nfrom lib.apis import images\nfrom lib.apis import dynamic\nfrom lib.apis import qrcode\nfrom lib.apis import test_password_manager\nfrom lib.apis import meta\n\nfrom lib.fastapi import tags_metadata, description, app_version\n\n\napp = FastAPI(docs_url = \"/\", redoc_url = None,\n    title = \"FastAPI Httpbin\",\n    description = description,\n    version = app_version,\n    swagger_ui_parameters = {\"docExpansion\":\"none\"},\n    openapi_tags = tags_metadata\n    )\n\n#\n# Ordering of these in the Swagger docs is set in lib/fastapi.py\n#\napp.include_router(methods.router, tags = [\"HTTP Methods\"])\napp.include_router(status.router, tags = [\"Status Codes\"])\napp.include_router(request.router, tags = [\"Request Inspection\"])\napp.include_router(response.router, tags = [\"Responses\"])\napp.include_router(response_formats.router, tags = [\"Response Formats\"])\napp.include_router(redirect_final.router, tags = [\"Redirects\"])\napp.include_router(qrcode.router, tags = [\"QR Codes\"])\napp.include_router(redirect.router, tags = [\"Redirects\"])\napp.include_router(anything.router, tags = [\"Anything\"])\napp.include_router(cookies.router, tags = [\"Cookies\"])\napp.include_router(images.router, tags = [\"Images\"])\napp.include_router(dynamic.router, tags = [\"Dynamic Data\"])\napp.include_router(test_password_manager.router, tags = [\"Forms\"])\napp.include_router(meta.router, tags = [\"Meta\"])\n\n#\n# Load some static resources\n#\napp.mount(\"/about\", StaticFiles(directory = \"static/about\", html = True), name = \"static\")\napp.mount(\"/roadmap\", StaticFiles(directory = \"static/roadmap\", html = True), name = \"static\")\napp.mount(\"/qrcode\", StaticFiles(directory = \"static/qrcode\", html = True), name = \"static\")\napp.mount(\"/test-password-manager-form\", StaticFiles(directory = \"static/password-manager\", html = True), name = \"static\")\n\n@app.middleware(\"http\")\nasync def add_process_time_header(request: Request, call_next):\n    response = await call_next(request)\n    response.headers[\"X-FastAPI-Httpbin-version\"] = app_version\n    response.headers[\"X-Website\"] = \"https://httpbin.dmuth.org/\"\n    response.headers[\"X-app-hostname\"] = platform.node()\n    return response\n\n\nfavicon_path = \"static/favicon.jpg\"\n@app.get('/favicon.ico', summary = \"Favicon endpoint\", tags = [\"Images\"],\n    response_class = FileResponse,\n    responses={\n        200: {\n            \"content\": {\"image/jpeg\": {}},\n            \"description\": \"Return a 32x32 favicon in JPG format.\",\n        }\n    }\n    )\nasync def favicon(response: Response):\n    return FileResponse(favicon_path)\n\nlogo_path = \"img/logo.png\"\n@app.get('/static/logo.png', summary = \"Logo endpoint\", tags = [\"Images\"],\n    response_class = FileResponse,\n    responses={\n        200: {\n            \"content\": {\"image/jpeg\": {}},\n            \"description\": \"Return the logo.\",\n        }\n    }\n    )\nasync def logo(response: Response):\n    return FileResponse(logo_path)\n\n\n\n"}
{"type": "source_file", "path": "lib/fastapi.py", "content": "\n#\n# Store our app version here.\n#\napp_version = \"0.0.54\"\n\ntags_metadata = [\n    {\n        \"name\": \"HTTP Methods\",\n        \"description\": \"Testing different HTTP verbs.\"\n    },\n    {\n        \"name\": \"Request Inspection\",\n        \"description\": \"Inspect the request data. (including source IP address)\"\n    },\n    {\n        \"name\": \"Responses\",\n        \"description\": \"Inspect response data like caching and headers.\"\n    },\n    {\n        \"name\": \"Response Formats\",\n        \"description\": \"Returns responses in different formats.\"\n    },\n    {\n        \"name\": \"QR Codes\",\n        \"description\": \"Generate QR Codes.\"\n    },\n    {\n        \"name\": \"Dynamic Data\",\n        \"description\": \"Generate random and dynamic data.\"\n    },\n    {\n        \"name\": \"Status Codes\",\n        \"description\": \"Generate responses with specified status codes.\"\n    },\n    {\n        \"name\": \"Redirects\",\n        \"description\": \"Return different redirects.\"\n    },\n    {\n        \"name\": \"Anything\",\n        \"description\": \"Return anything that is passed in on the request.\"\n    },\n    {\n        \"name\": \"Cookies\",\n        \"description\": \"Create, read, and delete cookies.\"\n    },\n    {\n        \"name\": \"Images\",\n        \"description\": \"Return different image formats.\"\n    },\n    {\n        \"name\": \"Forms\",\n        \"description\": \"Endpoints for testing out forms.\"\n    },\n    {\n        \"name\": \"Meta\",\n        \"description\": \"Endpoints related to this app itself.\"\n    },\n    ]\n\n\ndescription = \"\"\"\n<a href=\"static/logo.png\"><img src=\"static/logo.png\" align=\"right\" /></a>\n\nHTTP Endpoints for easy testing of your app.\n\nBuilt with the <a href=\"https://fastapi.tiangolo.com/\">FastAPI framework</a>, \nthis is heavily based on the original <a href=\"https://httpbin.org/\">Httpbin</a> website.\n\n<a href=\"/about\">About this project</a> - \n<a href=\"/roadmap\">Development Roadmap</a> -\n<a href=\"/qrcode/\">Dead Simple QR Code Generator</a> -\n<a href=\"/test-password-manager-form/\">Form for testing Password Managers like 1Password and BitWarden</a>\n<p>\n\n<a href=\"https://github.com/dmuth/fastapi-httpbin\">GitHub repo</a>\n<p>\n\nRun locally in Docker: <tt><b>docker run -p 80:80 dmuth1/fastapi-httpbin</b></tt>\n\n<a href=\"https://httpbin.dmuth.org/\">Main Site</a> - Mirrors: \n<a href=\"https://fly.httpbin.dmuth.org/\">Fly</a>\n<a href=\"https://railway.httpbin.dmuth.org/\">Railway</a>\n<a href=\"https://render.httpbin.dmuth.org/\">Render</a>\n\n\"\"\"\n\n\n"}
{"type": "source_file", "path": "lib/apis/status.py", "content": "#\n# Redirect endpoints.\n#\n\nimport random\n\nfrom fastapi import APIRouter, FastAPI, Header, Response, Query, Path, HTTPException\nfrom fastapi.responses import RedirectResponse, JSONResponse\n\nfrom . import PrettyJSONResponse\n\nrouter = APIRouter()\n\n\ndef core(response, codes):\n\n    # Convert any underscores to commas.\n    codes = codes.replace(\"_\", \",\")\n\n    codes = codes.split(\",\")\n\n    #\n    # Do some sanity checking.\n    # I originally wanted a custom exception, but it got *really* challenging figuring\n    # out how to add an exception while in a router, and adding it to app didn't help either. :-(\n    #\n    for code in codes:\n        if len(code) != 3:\n            retval = {\"type\": \"code_length\", \"message\": f\"Code '{code}' is != 3 digits!\"}\n            raise HTTPException(status_code = 422, detail = retval)\n\n    code = int(random.choice(codes))\n\n    if str(code)[0] == \"3\":\n        return RedirectResponse(\"/redirect/1\", status_code = code)\n\n    response.status_code = code\n\n    return(response)\n\n\n@router.get(\"/status/{codes}\",\n    summary = \"Return status code or random one if multiple given as comma-delimited list (Underscores are also permitted as delimiters)\")\nasync def get(response: Response, \n    codes: str = Path(min_length = 3, regex = \"^[0-9,_]+$\", example = \"200,201,204\")\n    ):\n    response = core(response, codes)\n    return(response)\n\n\n@router.post(\"/status/{codes}\",\n    summary = \"Return status code or random one if multiple given as comma-delimited list (Underscores are also permitted as delimiters)\")\nasync def get(response: Response, \n    codes: str = Path(min_length = 3, regex = \"^[0-9,_]+$\", example = \"200,201,204\")\n    ):\n    response = core(response, codes)\n    return(response)\n\n\n@router.put(\"/status/{codes}\", \n    summary = \"Return status code or random one if multiple given as comma-delimited list (Underscores are also permitted as delimiters)\")\nasync def get(response: Response, \n    codes: str = Path(min_length = 3, regex = \"^[0-9,_]+$\", example = \"200,201,204\")\n    ):\n    response = core(response, codes)\n    return(response)\n\n\n@router.patch(\"/status/{codes}\", \n    summary = \"Return status code or random one if multiple given as comma-delimited list (Underscores are also permitted as delimiters)\")\nasync def get(response: Response, \n    codes: str = Path(min_length = 3, regex = \"^[0-9,_]+$\", example = \"200,201,204\")\n    ):\n    response = core(response, codes)\n    return(response)\n\n\n@router.delete(\"/status/{codes}\", \n    summary = \"Return status code or random one if multiple given as comma-delimited list (Underscores are also permitted as delimiters)\")\nasync def get(response: Response, \n    codes: str = Path(min_length = 3, regex = \"^[0-9,_]+$\", example = \"200,201,204\")\n    ):\n    response = core(response, codes)\n    return(response)\n\n\n\n"}

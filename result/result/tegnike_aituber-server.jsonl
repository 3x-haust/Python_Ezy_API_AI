{"repo_info": {"repo_name": "aituber-server", "repo_owner": "tegnike", "repo_url": "https://github.com/tegnike/aituber-server"}}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import FastAPI\nfrom app.routers import base\nimport ptvsd\nimport os\n\nif os.getenv('DEBUG_MODE') == \"1\":\n    # デバッグ用コード\n    ptvsd.enable_attach(address=('0.0.0.0', 5678), redirect_output=True)\n    ptvsd.wait_for_attach()\n\napp = FastAPI()\napp.include_router(base.router)\n"}
{"type": "source_file", "path": "app/routers/base.py", "content": "from typing import List\nfrom fastapi import APIRouter, WebSocket, Request, WebSocketDisconnect\nfrom ..services.open_interpreter_service import stream_open_interpreter\nfrom ..services.websocket_service import send_websocket_message\n\nrouter = APIRouter()\n\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def send_personal_message(self, message: str, websocket: WebSocket):\n        await websocket.send_text(message)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\n    async def send_message_to_all(self, message: str, type: str):\n        closed_connections = []\n        for websocket in self.active_connections:\n            try:\n                await send_websocket_message(websocket, \"\", \"assistant\", \"start\")\n                await send_websocket_message(websocket, message, type)\n                await send_websocket_message(websocket, \"\", \"assistant\", \"end\")\n            except RuntimeError:\n                # WebSocketが閉じられている場合、後で削除するためにリストに追加\n                closed_connections.append(websocket)\n\n        # 閉じられたコネクションを削除\n        for closed_websocket in closed_connections:\n            self.disconnect(closed_websocket)\n\n\nmanager = ConnectionManager()\n\n\n@router.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        await stream_open_interpreter(websocket)\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n\n\n@router.post(\"/send_message\")\nasync def send_message(request: Request):\n    message = await request.json()\n    await manager.send_message_to_all(message[\"message\"], message.get(\"type\", \"message\"))\n    return {\"status\": \"ok\", \"message\": message[\"message\"]}\n\n\n@router.get(\"/\")\nasync def test():\n    print(\"/test called.\")\n    return {\"message\": \"Hello World\"}\n"}
{"type": "source_file", "path": "app/services/websocket_service.py", "content": "import json\nimport asyncio\n\n\nasync def send_websocket_message(websocket, message, role, type=\"\", emotion=\"neutral\"):\n    role = \"assistant\" if role == \"message\" else role\n\n    if not websocket:\n        print(\"Can't send message, WebSocket connection is closed.\")\n        return\n    elif type == \"\" and message == \"\":\n        print(\"Can't send message, message is empty.\")\n        return\n    else:\n        json_data = json.dumps(\n            {\"role\": role, \"text\": message, \"emotion\": emotion, \"type\": type},\n            ensure_ascii=False,\n        )\n        print(f\"Sending message: {json_data}\")\n        await websocket.send_text(json_data)\n        await asyncio.sleep(0.01)  # 10ミリ秒の遅延を追加\n        print(\"Send complete.\")\n"}
{"type": "source_file", "path": "app/services/open_interpreter_service.py", "content": "import os\nimport json\nimport base64\nimport traceback\nfrom interpreter import interpreter\nfrom datetime import datetime\nfrom .websocket_service import send_websocket_message\n\nasync def stream_open_interpreter(websocket):\n    language = os.getenv('LANGUAGE') or \"japanese\"\n\n    try:\n        # 1日の記憶を保持する\n        interpreter.conversation_filename = f\"{datetime.now().strftime('%Y%m%d')}.json\"\n        interpreter.conversation_history_path = \"./conversation_histories/\"\n        if os.path.exists(interpreter.conversation_history_path + interpreter.conversation_filename):\n            # あったら読み込んで記憶として設定する\n            with open(interpreter.conversation_history_path + interpreter.conversation_filename, \"r\") as f:\n                interpreter.messages = json.load(f)\n            print(\"Loaded conversation history.\")\n        else:\n            # なかったら作成する\n            with open(interpreter.conversation_history_path + interpreter.conversation_filename, \"w\") as f:\n                json.dump([], f)\n            print(\"Created conversation history.\")\n\n        interpreter.llm.model = \"gpt-4o\"\n        interpreter.auto_run = True\n        # interpreter.debug_mode = True\n        interpreter.system_message = f\"\"\"\nYou can use the following libraries without installing:\n- pandas\n- numpy\n- matplotlib\n- seaborn\n- scikit-learn\n- pandas-datareader\n- mplfinance\n- yfinance\n- requests\n- scrapy\n- beautifulsoup4\n- opencv-python\n- ffmpeg-python\n- PyMuPDF\n- pytube\n- pyocr\n- easyocr\n- pydub\n- pdfkit\n- weasyprint\nYour workspace is `./workspace` folder. If you make an output file, please put it in `./workspace/output`.\n{'[[Please answer in Japanese. 日本語でお答えください。]]' if language == 'japanese' else ''}\n        \"\"\"\n\n        message = \"\"\n        saved_file = \"\"\n        prev_type = \"\"\n\n        while True:\n            try:\n                if message != \"\" and message != \"\\n\":\n                    await send_websocket_message(websocket, message, prev_type)\n                    await send_websocket_message(websocket, \"\", \"assistant\", \"end\")\n\n                message = \"\"\n                prev_type = \"\"\n\n                # WebSocketでメッセージ受け取り待機\n                print(\"Waiting for user message...\")\n                user_message = await websocket.receive_text()\n                print(f\"Received user message: {user_message}\")\n\n                parsed_data = json.loads(user_message)\n                message_content = parsed_data.get(\"content\")\n                message_type = parsed_data.get(\"type\")\n\n                # WebSocketでテキストメッセージを受け取った場合\n                # ex. {\"type\": \"message\", \"text\": \"こんにちは\"}\n                if message_type == \"chat\" and message_content != \"\":\n                    if saved_file != \"\":\n                        user_message = saved_file + user_message\n                        saved_file = \"\"\n\n                    # 処理開始時に\"start\"を送信\n                    await send_websocket_message(websocket, \"\", \"assistant\", \"start\")\n\n                    # OpenInterpreterの結果をstreamモードで取得、chunk毎に処理\n                    is_source_code = False\n                    try:\n                        for chunk in interpreter.chat(message_content, display=True, stream=True):\n                            current_type = chunk[\"type\"]\n                            exculde_types = [\"language\", \"active_line\", \"end_of_execution\", \"start_of_message\", \"end_of_message\", \"start_of_code\", \"end_of_code\"]\n                            if current_type not in exculde_types:\n                                # message typeの場合は、文節に区切ってメッセージを送信\n                                if message and (current_type != prev_type or (len(message) > 15 and message[-1] in ['、', '。', '！', '？', '；', '…', '：'] or message[-1] == \"\\n\")):\n                                    if message != \"\":\n                                        if \"```\" in message:\n                                            # Toggle is_source_code\n                                            is_source_code = not is_source_code\n                                        else:\n                                            type_ = \"code\" if is_source_code else prev_type\n                                            await send_websocket_message(websocket, message, type_)\n                                    message = \"\"\n\n                                if current_type == \"executing\":\n                                    message += f\"{chunk['content']}\\n\\n========================\\nrunning...\\n========================\"\n                                else:\n                                    try:\n                                        if isinstance(chunk[\"content\"], dict):\n                                            await send_websocket_message(websocket, chunk[\"content\"][\"content\"], type_)\n                                        elif isinstance(chunk[\"content\"], str):\n                                            message += chunk[\"content\"]\n                                        else:\n                                            pass\n                                    except KeyError:\n                                        pass\n                                prev_type = current_type\n                    finally:\n                        # 処理終了時に必ず\"end\"を送信\n                        await send_websocket_message(websocket, \"\", \"assistant\", \"end\")\n\n                # WebSocketでファイルを受け取った場合\n                # ex. {\"type\": \"file\", \"fileName\": \"sample.txt\", \"fileData\": \"data:;base64,SGVsbG8sIHdvcmxkIQ==\"}\n                elif message_type == \"file\":\n                    # JSONデータをパースして、ファイル名とファイルデータを取得\n                    file_name = parsed_data.get(\"fileName\")\n                    base64_data = parsed_data.get(\"fileData\").split(\",\")[1]\n                    file_data = base64.b64decode(base64_data)\n\n                    # ファイルを保存するディレクトリを指定\n                    directory = \"./workspace\"\n\n                    # ディレクトリが存在しない場合、作成\n                    if not os.path.exists(directory):\n                        os.makedirs(directory)\n\n                    # ファイルのフルパスを作成\n                    file_path = os.path.join(directory, file_name)\n\n                    # ファイルを保存\n                    with open(file_path, \"wb\") as f:\n                        f.write(file_data)\n\n                    # 処理開始時に\"start\"を送信\n                    await send_websocket_message(websocket, \"\", \"assistant\", \"start\")\n\n                    # メッセージを追加\n                    saved_file = f\"{directory}/{file_name}にファイルを保存しました。\" if language == 'japanese' else f\"Saved file to {directory}/{file_name}.\"\n                    save_message = \"ファイルを保存しました。\" if language == 'japanese' else f\"Saved file.\"\n                    await send_websocket_message(websocket, save_message, \"assistant\")\n\n                    # 処理終了時に\"end\"を送信\n                    await send_websocket_message(websocket, \"\", \"assistant\", \"end\")\n\n                # WebSocketで未設定のメッセージを受け取った場合\n                else:\n                    # 処理開始時に\"start\"を送信\n                    await send_websocket_message(websocket, \"\", \"assistant\", \"start\")\n\n                    error_message = \"不正な送信が送られたようです。\" if language == 'japanese' else \"An invalid message was sent.\"\n                    await send_websocket_message(websocket, error_message, \"assistant\")\n\n                    # 処理終了時に\"end\"を送信\n                    await send_websocket_message(websocket, \"\", \"assistant\", \"end\")\n\n            except Exception as e:\n                print(f\"Error in message processing: {e}\")\n                traceback.print_exc()\n                await send_websocket_message(websocket, \"エラーが発生しました。\", \"assistant\")\n                await send_websocket_message(websocket, \"\", \"assistant\", \"end\")\n\n    except Exception as e:\n        print(f\"Fatal error: {e}\")\n        traceback.print_exc()\n    finally:\n        await websocket.close()\n"}

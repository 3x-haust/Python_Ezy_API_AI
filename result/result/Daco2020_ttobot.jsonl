{"repo_info": {"repo_name": "ttobot", "repo_owner": "Daco2020", "repo_url": "https://github.com/Daco2020/ttobot"}}
{"type": "test_file", "path": "test/test_point.py", "content": "import datetime\n\nimport pytest\n\nfrom pytest_mock import MockerFixture\nfrom app.models import Content, User\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.point import PointService\n\n\n@pytest.mark.parametrize(\n    \"user, point_name, point\",\n    [\n        (\n            User(\n                user_id=\"ìœ ì €ì•„ì´ë””\",\n                name=\"ì œì¶œ ë‚´ì—­ì´ ì—†ëŠ” ì˜ì½¤ë³´\",\n                channel_name=\"ì±„ë„ì´ë¦„\",\n                channel_id=\"ì±„ë„ì•„ì´ë””\",\n                intro=\"ì—…ë°ì´íŠ¸ ì˜ˆì •ì…ë‹ˆë‹¤.\",\n                contents=[],\n                cohort=\"10ê¸°\",\n                deposit=\"100000\",\n            ),\n            None,\n            None,\n        ),\n        (\n            User(\n                user_id=\"ìœ ì €ì•„ì´ë””\",\n                name=\"ì „ì „ íšŒì°¨ì— ë¯¸ì œì¶œí•œ ì¼ì½¤ë³´\",\n                channel_name=\"ì±„ë„ì´ë¦„\",\n                channel_id=\"ì±„ë„ì•„ì´ë””\",\n                intro=\"ì—…ë°ì´íŠ¸ ì˜ˆì •ì…ë‹ˆë‹¤.\",\n                contents=[\n                    Content(\n                        dt=\"2024-11-24 15:00:00\",\n                        user_id=\"ìœ ì €ì•„ì´ë””\",\n                        username=\"ìœ ì €ì´ë¦„\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"ì§ì „ íšŒì°¨ ì œì¶œ ê¸€\",\n                        category=\"ì¼ìƒ & ìƒê°\",\n                        tags=\"íƒœê·¸1,íƒœê·¸2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-10-27 15:00:00\",\n                        user_id=\"ìœ ì €ì•„ì´ë””\",\n                        username=\"ìœ ì €ì´ë¦„\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"ì „ì „ì „ íšŒì°¨ ì œì¶œ ê¸€\",\n                        category=\"ì¼ìƒ & ìƒê°\",\n                        tags=\"íƒœê·¸1,íƒœê·¸2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                ],\n                cohort=\"10ê¸°\",\n                deposit=\"100000\",\n            ),\n            \"ê¸€ ì œì¶œ ì½¤ë³´\",\n            \"10\",\n        ),\n        (\n            User(\n                user_id=\"ìœ ì €ì•„ì´ë””\",\n                name=\"ì´ì½¤ë³´\",\n                channel_name=\"ì±„ë„ì´ë¦„\",\n                channel_id=\"ì±„ë„ì•„ì´ë””\",\n                intro=\"ì—…ë°ì´íŠ¸ ì˜ˆì •ì…ë‹ˆë‹¤.\",\n                contents=[\n                    Content(\n                        dt=\"2024-11-24 15:00:00\",\n                        user_id=\"ìœ ì €ì•„ì´ë””\",\n                        username=\"ìœ ì €ì´ë¦„\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"ì§ì „ íšŒì°¨ ì œì¶œ ê¸€\",\n                        category=\"ì¼ìƒ & ìƒê°\",\n                        tags=\"íƒœê·¸1,íƒœê·¸2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-11-10 15:00:00\",\n                        user_id=\"ìœ ì €ì•„ì´ë””\",\n                        username=\"ìœ ì €ì•„ì´ë””\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"ì§ì „ íšŒì°¨ ì œì¶œ ê¸€\",\n                        category=\"ì¼ìƒ & ìƒê°\",\n                        tags=\"íƒœê·¸1,íƒœê·¸2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                ],\n                cohort=\"10ê¸°\",\n                deposit=\"100000\",\n            ),\n            \"ê¸€ ì œì¶œ ì½¤ë³´\",\n            \"20\",\n        ),\n        (\n            User(\n                user_id=\"ìœ ì €ì•„ì´ë””\",\n                name=\"ì¤‘ê°„ì— íŒ¨ìŠ¤ê°€ ìˆëŠ” ì‚¼ì½¤ë³´\",\n                channel_name=\"ì±„ë„ì´ë¦„\",\n                channel_id=\"ì±„ë„ì•„ì´ë””\",\n                intro=\"ì—…ë°ì´íŠ¸ ì˜ˆì •ì…ë‹ˆë‹¤.\",\n                contents=[\n                    Content(\n                        dt=\"2024-11-24 15:00:00\",\n                        user_id=\"ìœ ì €ì•„ì´ë””\",\n                        username=\"ìœ ì €ì´ë¦„\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"ì§ì „ íšŒì°¨ ì œì¶œ ê¸€\",\n                        category=\"ì¼ìƒ & ìƒê°\",\n                        tags=\"íƒœê·¸1,íƒœê·¸2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-11-10 15:00:00\",\n                        user_id=\"ìœ ì €ì•„ì´ë””\",\n                        username=\"ìœ ì €ì•„ì´ë””\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"ì „ì „ íšŒì°¨ ì œì¶œ ê¸€\",\n                        category=\"ì¼ìƒ & ìƒê°\",\n                        tags=\"íƒœê·¸1,íƒœê·¸2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-10-27 15:00:00\",\n                        user_id=\"ìœ ì €ì•„ì´ë””\",\n                        username=\"ìœ ì €ì•„ì´ë””\",\n                        type=\"pass\",\n                        content_url=\"\",\n                        title=\"ì „ì „ì „ íšŒì°¨ íŒ¨ìŠ¤ ê¸€\",\n                        category=\"\",\n                        tags=\"\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                    Content(\n                        dt=\"2024-10-13 15:00:00\",\n                        user_id=\"ìœ ì €ì•„ì´ë””\",\n                        username=\"ìœ ì €ì•„ì´ë””\",\n                        type=\"submit\",\n                        content_url=\"https://example.com\",\n                        title=\"ì „ì „ì „ì „ íšŒì°¨ ì œì¶œ ê¸€\",\n                        category=\"ì¼ìƒ & ìƒê°\",\n                        tags=\"íƒœê·¸1,íƒœê·¸2\",\n                        curation_flag=\"N\",\n                        ts=\"1730086982.752899\",\n                    ),\n                ],\n                cohort=\"10ê¸°\",\n                deposit=\"100000\",\n            ),\n            \"ê¸€ ì œì¶œ 3ì½¤ë³´ ë³´ë„ˆìŠ¤\",\n            \"300\",\n        ),\n    ],\n)\ndef test_grant_if_post_submitted_continuously(\n    user: User,\n    point_name: str | None,\n    point: str | None,\n    point_service: PointService,\n    mocker: MockerFixture,\n) -> None:\n    \"\"\"\n    ì—°ì†ìœ¼ë¡œ ê¸€ì„ ì œì¶œí•œë‹¤ë©´ ì—°ì† ì½¤ë³´ì— ë”°ë¥¸ ë³´ë„ˆìŠ¤ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\n    í˜„ì¬ íšŒì°¨ ì œì¶œì— ëŒ€í•œ ì—°ì† ì½¤ë³´ í¬ì¸íŠ¸ëŠ” ì§€ê¸‰ì…ë‹ˆë‹¤. (í˜„ì¬ íšŒì°¨ëŠ” ì œì¶œ ê±´ì€ ë°˜ì˜ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.)\n\n\n    - 1ì½¤ë³´(2íšŒ ì—°ì† ì œì¶œ) ë¼ë©´ ì½¤ë³´ í¬ì¸íŠ¸ëŠ” 10ì  ì…ë‹ˆë‹¤.\n        - ì¤‘ê°„ì— ë¯¸ì œì¶œ í–ˆë‹¤ë©´ ì½¤ë³´ëŠ” ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.\n    - 2ì½¤ë³´(3íšŒ ì—°ì† ì œì¶œ) ë¼ë©´ ì½¤ë³´ í¬ì¸íŠ¸ëŠ” 20ì  ì…ë‹ˆë‹¤.\n    - 3ì½¤ë³´(4íšŒ ì—°ì† ì œì¶œ) ë¼ë©´ ì½¤ë³´ í¬ì¸íŠ¸ëŠ” 300ì  ì…ë‹ˆë‹¤.\n        - ì¤‘ê°„ì— íŒ¨ìŠ¤ë¥¼ í•œ ê²½ìš° ì½¤ë³´ëŠ” ì—°ì¥ë©ë‹ˆë‹¤.\n    \"\"\"\n    # given\n    mocker.patch(\n        \"app.models.DUE_DATES\",\n        [\n            datetime.datetime(2024, 9, 29).date(),  # 0íšŒì°¨ (ì‹œì‘ì¼)\n            datetime.datetime(2024, 10, 13).date(),  # 1íšŒì°¨\n            datetime.datetime(2024, 10, 27).date(),  # 2íšŒì°¨\n            datetime.datetime(2024, 11, 10).date(),  # 3íšŒì°¨\n            datetime.datetime(2024, 11, 24).date(),  # 4íšŒì°¨\n            datetime.datetime(2024, 12, 8).date(),  # 5íšŒì°¨ (í˜„ì¬ íšŒì°¨)\n        ],\n    )\n    mocker.patch(\n        \"app.models.tz_now\",\n        return_value=datetime.datetime(2024, 11, 25, 15, 0, 0),\n    )\n    mocker.patch.object(\n        SlackRepository,\n        \"get_user\",\n        return_value=user,\n    )\n\n    # when\n    result = point_service.grant_if_post_submitted_continuously(user_id=user.user_id)\n\n    # then\n    if point_name is None:  # ì œì¶œ ë‚´ì—­ì´ ì—†ëŠ” ê²½ìš°\n        assert result is None\n\n    else:\n        expected_message = f\"<@{user.user_id}>ë‹˜ `{point_name}`(ìœ¼)ë¡œ `{point}`í¬ì¸íŠ¸ë¥¼ íšë“í–ˆì–´ìš”! ğŸ‰\\nì´ í¬ì¸íŠ¸ì™€ ë‚´ì—­ì€ ë˜ë´‡ [í™ˆ] íƒ­ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.\"\n        assert result == expected_message\n"}
{"type": "test_file", "path": "test/test_reminder.py", "content": "from datetime import timedelta\nfrom typing import cast\n\nfrom slack_bolt.async_app import AsyncApp\n\nimport pytest\nfrom pytest_mock import MockerFixture\nfrom app.models import Content, User\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.background import BackgroundService\nfrom app.utils import tz_now\nfrom test.conftest import FakeSlackApp\n\n\n@pytest.mark.asyncio\nasync def test_send_reminder_message_to_user(\n    background_service: BackgroundService,\n    slack_app: FakeSlackApp,\n    mocker: MockerFixture,\n) -> None:\n    \"\"\"\n    ë¦¬ë§ˆì¸ë“œ ëŒ€ìƒ ìœ ì €ì—ê²Œ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.\n    - í˜„ì¬ íšŒì°¨ë¥¼ ì œì¶œí•˜ì§€ ì•Šì€ ì¸ì›ì—ê²Œ ë¦¬ë§ˆì¸ë“œ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•´ì•¼ í•©ë‹ˆë‹¤.\n    - í˜„ì¬ ê¸°ìˆ˜ì— í•´ë‹¹í•˜ëŠ” ì¸ì›ì—ê²Œ ë¦¬ë§ˆì¸ë“œ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•´ì•¼ í•©ë‹ˆë‹¤.\n    \"\"\"\n    # given\n    mocker.patch(\n        \"app.models.DUE_DATES\",\n        [\n            tz_now().date() - timedelta(days=14),  # ì§ì „ íšŒì°¨ ë§ˆê°ì¼\n            tz_now().date(),  # í˜„ì¬ íšŒì°¨ ë§ˆê°ì¼\n        ],\n    )\n    mocker.patch.object(\n        SlackRepository,\n        \"fetch_users\",\n        return_value=[\n            User(\n                user_id=\"ë¦¬ë§ˆì¸ë“œ ë¹„ëŒ€ìƒ1\",\n                name=\"ìŠ¬ë™ë´‡\",\n                channel_name=\"-\",  # bot\n                channel_id=\"test_channel_id\",\n                intro=\"-\",\n                contents=[],\n                cohort=\"9ê¸°\",\n            ),\n            User(\n                user_id=\"ë¦¬ë§ˆì¸ë“œ ë¹„ëŒ€ìƒ2\",\n                name=\"ì¥ë“í˜„\",\n                channel_name=\"test_channel\",\n                channel_id=\"test_channel_id\",\n                intro=\"\",\n                contents=[],\n                cohort=\"8ê¸°\",  # ì§€ë‚œ ê¸°ìˆ˜ ì°¸ì—¬ì\n            ),\n            User(\n                user_id=\"ë¦¬ë§ˆì¸ë“œ ë¹„ëŒ€ìƒ3\",\n                name=\"ê¹€ì€ì°¬\",\n                channel_name=\"test_channel\",\n                channel_id=\"test_channel_id\",\n                intro=\"ì•ˆë…•í•˜ì„¸ìš”. ê¹€ì€ì°¬ì…ë‹ˆë‹¤.\",\n                contents=[\n                    Content(  # ì´ë¯¸ ì œì¶œí•œ ê²½ìš°\n                        dt=(tz_now() - timedelta(days=1)).strftime(\"%Y-%m-%d %H:%M:%S\"),\n                        user_id=\"ë¦¬ë§ˆì¸ë“œ ë¹„ëŒ€ìƒ3\",\n                        username=\"ê¹€ì€ì°¬\",\n                        type=\"submit\",\n                    ),\n                ],\n                cohort=\"10ê¸°\",\n            ),\n            User(\n                user_id=\"ë¦¬ë§ˆì¸ë“œ ëŒ€ìƒ1\",\n                name=\"ë³€ë•ìˆœ\",\n                channel_name=\"test_channel\",\n                channel_id=\"test_channel_id\",\n                intro=\"ì•ˆë…•í•˜ì„¸ìš”. ë•ìˆœì…ë‹ˆë‹¤.\",\n                contents=[],  # ì œì¶œí•˜ì§€ ì•Šì€ ê²½ìš°\n                cohort=\"10ê¸°\",\n            ),\n            User(\n                user_id=\"ë¦¬ë§ˆì¸ë“œ ëŒ€ìƒ2\",\n                name=\"ì¥ë“í˜„\",\n                channel_name=\"test_channel\",\n                channel_id=\"test_channel_id\",\n                intro=\"ì•ˆë…•í•˜ì„¸ìš”. ì¥ë“í˜„ì…ë‹ˆë‹¤.\",\n                contents=[\n                    Content(  # ì§€ë‚œ íšŒì°¨ ì œì¶œí•œ ê²½ìš°\n                        dt=(tz_now() - timedelta(days=15)).strftime(\n                            \"%Y-%m-%d %H:%M:%S\"\n                        ),\n                        user_id=\"ë¦¬ë§ˆì¸ë“œ ëŒ€ìƒ2\",\n                        username=\"ì¥ë“í˜„\",\n                        type=\"submit\",\n                    ),\n                ],\n                cohort=\"10ê¸°\",\n            ),\n        ],\n    )\n    slack_client_mock = mocker.patch.object(slack_app.client, \"chat_postMessage\")\n\n    # when\n    await background_service.send_reminder_message_to_user(cast(AsyncApp, slack_app))\n\n    # then\n    assert slack_client_mock.call_count == 3\n    assert slack_client_mock.call_args_list[0].kwargs[\"channel\"] == \"ë¦¬ë§ˆì¸ë“œ ëŒ€ìƒ1\"\n    assert (\n        slack_client_mock.call_args_list[0].kwargs[\"text\"]\n        == \"ğŸ‘‹ ì•ˆë…•í•˜ì„¸ìš”! ì˜¤ëŠ˜ì€ ê¸€ ì œì¶œ ë§ˆê°ì¼ì´ì—ìš”.\\nì§€ë‚œ 2ì£¼ ë™ì•ˆ ë°°ìš°ê³  ê²½í—˜í•œ ê²ƒë“¤ì„ ìì •ê¹Œì§€ ë‚˜ëˆ ì£¼ì„¸ìš”.\\në³€ë•ìˆœ ë‹˜ì˜ ì´ì•¼ê¸°ë¥¼ ê¸°ë‹¤ë¦´ê²Œìš”!ğŸ™‚\"\n    )\n    assert slack_client_mock.call_args_list[1].kwargs[\"channel\"] == \"ë¦¬ë§ˆì¸ë“œ ëŒ€ìƒ2\"\n    assert (\n        slack_client_mock.call_args_list[1].kwargs[\"text\"]\n        == \"ğŸ‘‹ ì•ˆë…•í•˜ì„¸ìš”! ì˜¤ëŠ˜ì€ ê¸€ ì œì¶œ ë§ˆê°ì¼ì´ì—ìš”.\\nì§€ë‚œ 2ì£¼ ë™ì•ˆ ë°°ìš°ê³  ê²½í—˜í•œ ê²ƒë“¤ì„ ìì •ê¹Œì§€ ë‚˜ëˆ ì£¼ì„¸ìš”.\\nì¥ë“í˜„ ë‹˜ì˜ ì´ì•¼ê¸°ë¥¼ ê¸°ë‹¤ë¦´ê²Œìš”!ğŸ™‚\"\n    )\n    assert (\n        slack_client_mock.call_args_list[2].kwargs[\"text\"]\n        == \"ì´ 2 ëª…ì—ê²Œ ë¦¬ë§ˆì¸ë“œ ë©”ì‹œì§€ë¥¼ ì „ì†¡í–ˆìŠµë‹ˆë‹¤.\"\n    )\n"}
{"type": "source_file", "path": "app/api/deps.py", "content": "from fastapi import Depends\nfrom app.api.repositories import ApiRepository\nfrom app.api.services import ApiService\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.point import PointService\n\n\ndef api_repo() -> ApiRepository:\n    return ApiRepository()\n\n\ndef api_service(api_repo: ApiRepository = Depends(api_repo)) -> ApiService:\n    return ApiService(api_repo=api_repo)\n\n\ndef point_service() -> PointService:\n    return PointService(SlackRepository())\n"}
{"type": "source_file", "path": "app/api/auth.py", "content": "from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\nimport jwt\nfrom app import models\nfrom app.config import settings\n\n\nfrom fastapi import Depends, HTTPException, Response\n\n\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any\nfrom app.api.deps import api_repo\nfrom app.api.repositories import ApiRepository\n\nfrom app.utils import tz_now\n\n\ndef login(response: Response, payload: dict[str, Any]):\n    token = encode_token(payload=payload, expires_delta=timedelta(days=1))\n    set_cookie(response=response, key=\"access_token\", value=token)\n\n\ndef set_cookie(\n    response: Response,\n    key: str,\n    value: str,\n) -> None:\n    \"\"\"ì‘ë‹µì— ì¿ í‚¤ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.\"\"\"\n    response.set_cookie(\n        key=key,\n        value=value,\n        max_age=60 * 60 * 24,\n        expires=datetime.now(timezone.utc) + timedelta(days=1),\n        domain=settings.SERVER_DOMAIN,\n        path=\"/\",\n        httponly=True,\n        secure=True,\n    )\n\n\ndef encode_token(\n    payload: dict[str, Any],\n    expires_delta: timedelta,\n    algorithm: str = \"HS256\",\n) -> str:\n    \"\"\"í† í°ì„ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n    payload[\"iss\"] = \"ttobot\"\n    payload[\"iat\"] = iat = tz_now()\n    payload[\"exp\"] = iat + expires_delta\n    return jwt.encode(\n        payload,\n        settings.SECRET_KEY,\n        algorithm=algorithm,\n    )\n\n\ndef decode_token(\n    token: str,\n    algorithm: str = \"HS256\",\n) -> dict[str, Any]:\n    \"\"\"í† í°ì„ ë””ì½”ë”©í•©ë‹ˆë‹¤.\"\"\"\n    options = {\"verify_exp\": True, \"verify_iss\": True}\n    return jwt.decode(\n        token,\n        settings.SECRET_KEY,\n        issuer=\"ttobot\",\n        algorithms=[algorithm],\n        options=options,\n    )\n\n\nsecurity = HTTPBearer(auto_error=False)\n\n\nasync def current_user(\n    credentials: HTTPAuthorizationCredentials | None = Depends(security),\n    api_repo: ApiRepository = Depends(api_repo),\n) -> models.SimpleUser:\n    \"\"\"í˜„ì¬ ìœ ì €ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    token = credentials and credentials.credentials\n    if not token:\n        raise HTTPException(status_code=403, detail=\"í† í°ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\")\n\n    try:\n        decoded_payload = decode_token(token)\n    except Exception:\n        raise HTTPException(\n            status_code=403, detail=f\"í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. token: {token}\"\n        )\n\n    if decoded_payload.get(\"type\") == \"refresh\":\n        raise HTTPException(\n            status_code=403, detail=f\"í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. token: {token}\"\n        )\n\n    user_id = decoded_payload.get(\"user_id\", \"\")\n    user = api_repo.get_user(user_id) if user_id else None\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=f\"ìœ ì €ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. user_id: {user_id}\",\n        )\n\n    return models.SimpleUser.model_validate(user.model_dump())\n"}
{"type": "source_file", "path": "app/api/views/__init__.py", "content": ""}
{"type": "source_file", "path": "app/bigquery/client.py", "content": "from enum import StrEnum\nimport orjson\nfrom typing import Any\n\nfrom google.cloud import bigquery\nfrom google.oauth2 import service_account\nfrom app.config import settings\n\nimport pandas as pd\nfrom pandas_gbq import to_gbq\n\ncredentials = service_account.Credentials.from_service_account_info(\n    info=settings.BIGQUERY_CREDENTIALS\n)\n\n\nclass TableNameEnum(StrEnum):\n    COMMENTS_LOG = \"comments_log\"\n    POSTS_LOG = \"posts_log\"\n    EMOJIS_LOG = \"emojis_log\"\n\n\nclass BigqueryClient:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self) -> None:\n        if not hasattr(self, \"_initialized\"):\n            self.credentials = credentials\n            self.project_id = self.credentials.project_id\n            self.database_id = settings.BIGQUERY_DATABASE_ID\n            self.client = bigquery.Client(\n                credentials=credentials, project=self.project_id\n            )\n            self.schemas = {\n                TableNameEnum.COMMENTS_LOG: self._read_schema(\n                    \"app/bigquery/schemas/comments_log.json\"\n                ),\n                TableNameEnum.POSTS_LOG: self._read_schema(\n                    \"app/bigquery/schemas/posts_log.json\"\n                ),\n                TableNameEnum.EMOJIS_LOG: self._read_schema(\n                    \"app/bigquery/schemas/emojis_log.json\"\n                ),\n            }\n            self._initialized = True\n\n    def create_table(\n        self,\n        table_name: TableNameEnum,\n        partition: bool = False,\n        partition_key: str | None = None,\n    ) -> None:\n        \"\"\"\n        íŒŒì´ì¬ì—ì„œ ë¹…ì¿¼ë¦¬ í…Œì´ë¸”ì„ ìƒì„±í•©ë‹ˆë‹¤.\n\n        Parameters\n        ----------\n        table_name : str\n            í…Œì´ë¸” ì´ë¦„\n        partition : bool, optional\n            íŒŒí‹°ì…˜ í‚¤ë¥¼ ë§Œë“¤ê²ƒì¸ì§€ ì²´í¬, by default False\n        partition_key : str, optional\n            íŒŒí‹°ì…˜ í‚¤ë¥¼ ë§Œë“ ë‹¤ë©´ ì–´ë–¤ ì»¬ëŸ¼ì„ ì‚¬ìš©í•  ê²ƒì¸ì§€ ëª…ì‹œ, by default None\n        \"\"\"\n        table_path = f\"{self.project_id}.{self.database_id}.{table_name}\"\n        table = bigquery.Table(table_path, schema=self.schemas[table_name])\n\n        if partition is True:\n            partitioning = bigquery.TimePartitioning(\n                type_=bigquery.TimePartitioningType.DAY,\n                field=partition_key,  # ë¶„í• í•˜ë ¤ëŠ” í•„ë“œ\n            )\n            table.time_partitioning = partitioning\n\n        self.client.create_table(table)\n        print(f\"{table_path}ê°€ ì •ìƒì ìœ¼ë¡œ ìƒì„± ëìŠµë‹ˆë‹¤.\")\n\n    def run_query_to_dataframe(self, query: str) -> pd.DataFrame:\n        \"\"\"\n        ë¹…ì¿¼ë¦¬ì— ì§ì ‘ ì¿¼ë¦¬ë¥¼ ë‚ ë¦½ë‹ˆë‹¤\n\n        Parameters\n        ----------\n\n        \"\"\"\n        return self.client.query(query=query).result().to_dataframe()\n\n    def read_table(\n        self,\n        table_name: TableNameEnum,\n        where_clause: str | None = None,\n    ) -> pd.DataFrame:\n        \"\"\"\n        ë¹…ì¿¼ë¦¬ í…Œì´ë¸”ì„ íŒë‹¤ìŠ¤ë¡œ ì½ì–´ì˜µë‹ˆë‹¤.\n\n        Parameters\n        ----------\n        table_name : str\n            í…Œì´ë¸”ëª…\n        where_clause : str\n            ì¡°ê±´ì ˆì„ ì…ë ¥í•©ë‹ˆë‹¤. ë§Œì•½ íŒŒí‹°ì…˜ í‚¤ê°€ ìˆëŠ”ë° ì¡°ê±´ì ˆì„ ì…ë ¥í•˜ì§€ ì•Šìœ¼ë©´ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤, by default None\n        \"\"\"\n        table_path = f\"{self.project_id}.{self.database_id}.{table_name}\"\n        table = self.client.get_table(table_path)\n\n        if not table.time_partitioning:\n            qr = f\"\"\"\n            SELECT *\n            FROM `{table_path}`\n            \"\"\"\n        else:\n            if not where_clause:\n                raise ValueError(\"where_clause íŒŒí‹°ì…˜ ì¡°ê±´ì ˆì„ ì¶”ê°€í•˜ì„¸ìš”\")\n            qr = f\"\"\"\n                SELECT *\n                FROM `{table_path}`\n                WHERE {where_clause}\n                \"\"\"\n\n        return self.client.query(qr).to_dataframe()\n\n    def update_table(\n        self,\n        df: pd.DataFrame,\n        table_name: TableNameEnum,\n        if_exists: str,\n    ) -> None:\n        \"\"\"\n        íŒŒì´ì¬ì—ì„œ ë¹…ì¿¼ë¦¬ í…Œì´ë¸”ì„ ì—…ë°ì´íŠ¸ í•©ë‹ˆë‹¤.\n\n        Parameters\n        ----------\n        df : pd.DataFrame\n            íŒë‹¤ìŠ¤ ë°ì´í„°í”„ë ˆì„\n        table_name : str\n            í…Œì´ë¸”ëª…\n        if_exists : str\n            í…Œì´ë¸”ì´ ë§Œì•½ì— ì¡´ì¬í•œë‹¤ë©´ ì–´ë–¤ ì¡°ê±´ì„ ì‚¬ìš©í•  ê²ƒì¸ì§€ 3ê°€ì§€ ì‚¬ìš©ê°€ëŠ¥ - fail, replace, append\n        \"\"\"\n        table_path = f\"{self.project_id}.{self.database_id}.{table_name}\"\n        to_gbq(\n            dataframe=df,\n            destination_table=table_path,\n            credentials=self.credentials,\n            if_exists=if_exists,\n            table_schema=self.schemas[table_name],\n        )\n        print(f\"{table_path}ê°€ ì •ìƒì ìœ¼ë¡œ ì ì¬ ëìŠµë‹ˆë‹¤.\")\n\n    def delete_table(\n        self,\n        table_name: TableNameEnum,\n        where_clause: str,\n    ) -> None:\n        \"\"\"\n        íŒŒì´ì¬ì—ì„œ ë¹…ì¿¼ë¦¬ ë‚´ì—ì„œ íŠ¹ì • ì¡°ê±´ì— í•´ë‹¹í•˜ëŠ” ë°ì´í„°ë¥¼ ì‚­ì¬í•©ë‹ˆë‹¤.\n        ë°ì´í„° ì—…ë°ì´íŠ¸ ì‹œ ì¤‘ë³µ ì ì¬ë¥¼ ë°©ì§€í•˜ëŠ” ìš©ë„ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.\n\n        Parameters\n        ----------\n        table_name : str\n            í…Œì´ë¸”ëª…\n        where_clause : str\n            ì‚­ì œ ì¡°ê±´ì„ ì…ë ¥í•©ë‹ˆë‹¤.\n        \"\"\"\n        table_path = f\"{self.project_id}.{self.database_id}.{table_name}\"\n        qr = f\"\"\"\n        DELETE FROM `{table_path}`\n        {where_clause}\n        \"\"\"\n        query_job = self.client.query(qr)\n        query_job.result()\n\n        print(f\"{table_path}ì˜ {where_clause}ê°€ ì •ìƒì ìœ¼ë¡œ ì‚­ì œ ëìŠµë‹ˆë‹¤.\")\n\n    def upsert_table(\n        self,\n        *,\n        target_table: str,\n        source_table: str,\n    ) -> None:\n        \"\"\"\n        ì•„ë˜ì™€ ê°™ì´ ê°’ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš° update, ê°’ì´ ì—†ëŠ” ê²½ìš° insertí•˜ëŠ” ë¡œì§ì„ ì§„í–‰\n        MERGE merge_example.table_data T\n        USING merge_example.table_changes S\n        ON T.id = S.id\n        WHEN MATCHED THEN\n        UPDATE SET value = s.value\n        WHEN NOT MATCHED THEN\n        INSERT (id, value) VALUES(id, value)\n\n        Parameters\n        ----------\n        target_table : str\n            ë³€ê²½ ëŒ€ìƒ í…Œì´ë¸”ëª…\n        source_table : str\n            ì†ŒìŠ¤ í…Œì´ë¸”ëª…\n        \"\"\"\n        target_path = f\"{self.project_id}.{self.database_id}.{target_table}\"\n        source_path = f\"{self.project_id}.{self.database_id}.{source_table}\"\n\n        qr = f\"\"\"\n        MERGE {target_path} T\n        USING {source_path} S\n        ON T.post_id = S.post_id AND T.createtime = S.createtime\n        WHEN MATCHED THEN\n        UPDATE SET\n            channel_id = S.channel_id,\n            message_type = S.message_type,\n            user_id = S.user_id,\n            createtime = S.createtime,\n            tddate = S.tddate,\n            text = S.text,\n            reactions = S.reactions\n        WHEN NOT MATCHED THEN\n            INSERT (channel_id, message_type, post_id, user_id, ts, createtime, tddate, text, permalink, reactions)\n            VALUES (channel_id, message_type, post_id, user_id, ts, createtime, tddate, text, permalink, reactions)\n        \"\"\"\n\n        query_job = self.client.query(qr)\n        query_job.result()\n\n        print(f\"{target_path}ì˜ upsertê°€ ì •ìƒì ìœ¼ë¡œ ì§„í–‰ ëìŠµë‹ˆë‹¤.\")\n\n    def _read_schema(self, file_path: str) -> list[dict[str, Any]]:\n        \"\"\"\n        ìŠ¤í‚¤ë§ˆë¥¼ ì½ì–´ì˜µë‹ˆë‹¤.\n\n        Parameters\n        ----------\n        file_path : str\n            json ìŠ¤í‚¤ë§ˆê°€ ì €ì¥ëœ ì£¼ì†Œ\n\n        Returns\n        -------\n        list[dict[str, Any]]\n            ìŠ¤í‚¤ë§ˆ íŒŒì¼\n        \"\"\"\n        with open(file_path, encoding=\"utf-8\") as json_file:\n            data = orjson.loads(json_file.read())\n        return data\n"}
{"type": "source_file", "path": "app/api/dto.py", "content": "from typing import Any\nfrom pydantic import BaseModel, Field\n\n\nclass ContentResponse(BaseModel):\n    count: int = Field(..., description=\"ì¡°ê±´ì— ë§ëŠ” ì½˜í…ì¸ ì˜ ì´ ê°œìˆ˜\", examples=[1])\n    data: list[dict[str, Any]] = Field(\n        ...,\n        description=\"ì¡°íšŒëœ ì½˜í…ì¸ ì˜ ë°°ì—´\",\n        examples=[\n            [\n                {\n                    \"user_id\": \"U07NTP9MGH4\",\n                    \"title\": \"Python aiocache ë¡œ ë¹„ë™ê¸° Slack API ìš”ì²­ ìºì‹±í•˜ê¸°\",\n                    \"content_url\": \"https://daco2020.tistory.com/854\",\n                    \"dt\": \"2024-10-03 22:31:56\",\n                    \"category\": \"ê¸°ìˆ  & ì–¸ì–´\",\n                    \"tags\": \"Python,Slack API,Cache,ìºì‹±,ë¹„ë™ê¸° í•¨ìˆ˜,ë¹„ë™ê¸° ìºì‹±\",\n                    \"ts\": \"1727962316.649959\",\n                    \"name\": \"ê¹€ì€ì°¬\",\n                    \"cohort\": \"10ê¸°\",\n                    \"job_category\": \"í’€ìŠ¤íƒ\",\n                    \"relevance\": 0,\n                }\n            ]\n        ],\n    )\n\n\nclass PaperPlaneResponse(BaseModel):\n    count: int = Field(\n        ..., description=\"ì¡°ê±´ì— ë§ëŠ” ì¢…ì´ë¹„í–‰ê¸°ì˜ ì´ ê°œìˆ˜\", examples=[1]\n    )\n    data: list[dict[str, Any]] = Field(\n        ...,\n        description=\"ì¡°íšŒëœ ì¢…ì´ë¹„í–‰ê¸°ì˜ ë°°ì—´\",\n        examples=[\n            {\n                \"count\": 1,\n                \"data\": [\n                    {\n                        \"id\": \"BLayCX1727143294282\",\n                        \"sender_id\": \"U02HPESDZT3\",\n                        \"sender_name\": \"ê¹€ì€ì°¬\",\n                        \"receiver_id\": \"U06EV0G3QUA\",\n                        \"receiver_name\": \"ì„±ì—°ì°¬\",\n                        \"text\": \"í…ŒìŠ¤íŠ¸\",\n                        \"text_color\": \"#FFFFFF\",\n                        \"bg_color\": \"blush_rosybrown\",\n                        \"color_label\": \"#BC8F8F\",\n                        \"created_at\": \"2024-09-24 11:01:34\",\n                    }\n                ],\n            }\n        ],\n    )\n\n\nclass SendMessageDTO(BaseModel):\n    channel_id: str = Field(..., description=\"ì±„ë„ ID\")\n    message: str = Field(..., description=\"ë©”ì‹œì§€\")\n"}
{"type": "source_file", "path": "app/api/views/login.py", "content": "from datetime import timedelta\nfrom typing import cast\nfrom slack_bolt import BoltRequest\nfrom app import models\nfrom fastapi import APIRouter, Depends, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom app.api.auth import decode_token, encode_token\nfrom app.api.auth import current_user\nfrom app.api.deps import api_service\nfrom app.api.services import ApiService\nfrom app.config import settings\nfrom slack_bolt.oauth.oauth_settings import OAuthSettings\nfrom slack_sdk.oauth.state_store import FileOAuthStateStore\nfrom slack_bolt.oauth.oauth_flow import OAuthFlow\nfrom jwt import PyJWTError\n\nrouter = APIRouter()\n\noauth_settings = OAuthSettings(\n    client_id=settings.SLACK_CLIENT_ID,\n    client_secret=settings.SLACK_CLIENT_SECRET,\n    scopes=[\"channels:read\", \"groups:read\", \"chat:write\"],\n    state_store=FileOAuthStateStore(expiration_seconds=600, base_dir=\"./data/states\"),\n    user_scopes=[\"identity.basic\"],\n    redirect_uri=f\"https://{settings.CLIENT_DOMAIN}/slack/callback\",\n)\n\noauth_flow = OAuthFlow(settings=oauth_settings)\n\n\n@router.get(\"/slack/login\")\nasync def slack_login(request: Request):\n    state = oauth_flow.issue_new_state(request=cast(BoltRequest, request))\n    url = oauth_settings.authorize_url_generator.generate(state=state)\n    return JSONResponse(content={\"redirect_url\": url})\n\n\n@router.get(\"/slack/auth\")\nasync def slack_auth(\n    request: Request,\n    code: str | None = None,\n    state: str | None = None,\n    error: str | None = None,\n):\n    if error:\n        raise HTTPException(status_code=404, detail=f\"Slack OAuth Error: {error}\")\n\n    if not code:\n        raise HTTPException(\n            status_code=403, detail=\"Slack OAuth Error: Invalid authentication code\"\n        )\n\n    result = oauth_flow.run_installation(code=code)\n    if not result:\n        raise HTTPException(\n            status_code=403, detail=\"Slack OAuth Error: Failed to run installation\"\n        )\n\n    access_token = encode_token(\n        payload={\"user_id\": result.user_id},\n        expires_delta=timedelta(days=1),\n    )\n    refresh_token = encode_token(\n        payload={\"user_id\": result.user_id, \"type\": \"refresh\"},\n        expires_delta=timedelta(days=7),\n    )\n    return JSONResponse(\n        status_code=200,\n        content={\n            \"access_token\": access_token,\n            \"refresh_token\": refresh_token,\n        },\n    )\n\n\n@router.get(\"/slack/auth/refresh\")\nasync def slack_auth_refresh(\n    refresh_token: str,\n    service: ApiService = Depends(api_service),\n):\n    try:\n        decoded_payload = decode_token(refresh_token)\n        if decoded_payload.get(\"type\") != \"refresh\":\n            return HTTPException(status_code=403, detail=\"í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\")\n\n        user = service.get_user_by(user_id=decoded_payload[\"user_id\"])\n        if not user:\n            return HTTPException(status_code=404, detail=\"í•´ë‹¹í•˜ëŠ” ìœ ì €ê°€ ì—†ìŠµë‹ˆë‹¤.\")\n\n    except PyJWTError:\n        return HTTPException(status_code=403, detail=\"í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\")\n\n    access_token = encode_token(\n        payload={\"user_id\": user.user_id}, expires_delta=timedelta(days=1)\n    )\n    return JSONResponse(\n        status_code=200,\n        content={\n            \"access_token\": access_token,\n        },\n    )\n\n\n@router.get(\"/slack/me\")\nasync def get_me(user: models.SimpleUser = Depends(current_user)):\n    \"\"\"ë¡œê·¸ì¸ ìœ ì €ì˜ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n    return user\n"}
{"type": "source_file", "path": "app/slack/components/static_select.py", "content": "from typing import Any\n\n\ndef options(options: list[str]) -> list[dict[str, Any]]:\n    return [\n        {\n            \"text\": {\"type\": \"plain_text\", \"text\": value},\n            \"value\": value,\n        }\n        for value in options\n    ]\n"}
{"type": "source_file", "path": "app/bigquery/queue.py", "content": "import asyncio\nfrom datetime import date, datetime\nfrom typing import TypedDict\n\nimport pandas as pd\n\nfrom app.bigquery.client import BigqueryClient, TableNameEnum\n\n\nclass CommentDataType(TypedDict):\n    user_id: str\n    channel_id: str\n    ts: str  # ìƒìœ„ ë©”ì‹œì§€ timestamp\n    comment_ts: str  # ëŒ“ê¸€ timestamp\n    tddate: date\n    createtime: datetime\n    text: str\n\n\nclass EmojiDataType(TypedDict):\n    user_id: str\n    channel_id: str\n    ts: str\n    reactions_ts: str\n    tddate: date\n    createtime: datetime\n    reaction: str\n\n\nclass PostDataType(TypedDict):\n    user_id: str\n    channel_id: str\n    ts: str\n    tddate: date\n    createtime: datetime\n    text: str\n\n\nqueue_lock = asyncio.Lock()\n\ncomments_upload_queue: list[CommentDataType] = []\nemojis_upload_queue: list[EmojiDataType] = []\nposts_upload_queue: list[PostDataType] = []\n\n\nclass BigqueryQueue:\n    def __init__(self, client: BigqueryClient) -> None:\n        self._client = client\n\n    async def upload(self) -> None:\n        global comments_upload_queue, emojis_upload_queue, posts_upload_queue\n\n        async with queue_lock:\n            temp_comments_queue = list(comments_upload_queue)\n            if temp_comments_queue:\n                await asyncio.to_thread(\n                    self._client.update_table,\n                    pd.DataFrame(temp_comments_queue),\n                    TableNameEnum.COMMENTS_LOG,\n                    \"append\",\n                )\n                comments_upload_queue = [\n                    entry\n                    for entry in comments_upload_queue\n                    if entry not in temp_comments_queue\n                ]\n\n            temp_emojis_queue = list(emojis_upload_queue)\n            if temp_emojis_queue:\n                await asyncio.to_thread(\n                    self._client.update_table,\n                    pd.DataFrame(temp_emojis_queue),\n                    TableNameEnum.EMOJIS_LOG,\n                    \"append\",\n                )\n                emojis_upload_queue = [\n                    entry\n                    for entry in emojis_upload_queue\n                    if entry not in temp_emojis_queue\n                ]\n\n            temp_posts_queue = list(posts_upload_queue)\n            if temp_posts_queue:\n                await asyncio.to_thread(\n                    self._client.update_table,\n                    pd.DataFrame(temp_posts_queue),\n                    TableNameEnum.POSTS_LOG,\n                    \"append\",\n                )\n                posts_upload_queue = [\n                    entry\n                    for entry in posts_upload_queue\n                    if entry not in temp_posts_queue\n                ]\n"}
{"type": "source_file", "path": "app/api/services.py", "content": "from datetime import datetime, timedelta\nimport random\nfrom zoneinfo import ZoneInfo\n\nfrom fastapi import HTTPException, status\nfrom app import models, store\nfrom app.api.repositories import ApiRepository\nfrom app.utils import tz_now\nfrom app.config import settings\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom slack_sdk.models.blocks import (\n    SectionBlock,\n    ContextBlock,\n    MarkdownTextObject,\n)\nfrom app.constants import paper_plane_color_maps\n\n\nclass ApiService:\n    def __init__(self, api_repo: ApiRepository) -> None:\n        self._repo = api_repo\n\n    def get_user_by(self, user_id: str) -> models.User | None:\n        \"\"\"íŠ¹ì • ìœ ì €ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n        return self._repo.get_user(user_id)\n\n    async def send_paper_plane(\n        self,\n        sender_id: str,\n        sender_name: str,\n        receiver_id: str,\n        text: str,\n        client: AsyncWebClient,\n    ) -> models.PaperPlane:\n        \"\"\"ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ëƒ…ë‹ˆë‹¤.\"\"\"\n        receiver = self.get_user_by(user_id=receiver_id)\n        if not receiver:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"ë°›ëŠ” ì‚¬ëŒì„ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”. ğŸ˜¢\",\n            )\n        color_map = random.choice(paper_plane_color_maps)\n        model = models.PaperPlane(\n            sender_id=sender_id,\n            sender_name=sender_name,\n            receiver_id=receiver_id,\n            receiver_name=receiver.name,\n            text=text,\n            text_color=color_map[\"text_color\"],\n            bg_color=color_map[\"bg_color\"],\n            color_label=color_map[\"color_label\"],\n        )\n        self._repo.create_paper_plane(model)\n        store.paper_plane_upload_queue.append(model.to_list_for_sheet())\n\n        await client.chat_postMessage(\n            channel=settings.THANKS_CHANNEL,\n            text=f\"ğŸ’Œ *<@{receiver_id}>* ë‹˜ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ê°€ ë„ì°©í–ˆì–´ìš”!\",\n            blocks=[\n                SectionBlock(\n                    text=f\"ğŸ’Œ *<@{receiver_id}>* ë‹˜ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ê°€ ë„ì°©í–ˆì–´ìš”!\\n\\n\",\n                ),\n                ContextBlock(\n                    elements=[\n                        MarkdownTextObject(\n                            text=\">ë°›ì€ ì¢…ì´ë¹„í–‰ê¸°ëŠ” `/ì¢…ì´ë¹„í–‰ê¸°` ëª…ë ¹ì–´ -> [ì£¼ê³ ë°›ì€ ì¢…ì´ë¹„í–‰ê¸° ë³´ê¸°] ë¥¼ í†µí•´ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.\"\n                        )\n                    ],\n                ),\n            ],\n        )\n\n        await client.chat_postMessage(\n            channel=sender_id,\n            text=f\"ğŸ’Œ *<@{sender_id}>* ë‹˜ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ëƒˆì–´ìš”!\",\n            blocks=[\n                SectionBlock(\n                    text=f\"ğŸ’Œ *<@{receiver_id}>* ë‹˜ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ëƒˆì–´ìš”!\\n\\n\",\n                ),\n                ContextBlock(\n                    elements=[\n                        MarkdownTextObject(\n                            text=\">ë³´ë‚¸ ì¢…ì´ë¹„í–‰ê¸°ëŠ” `/ì¢…ì´ë¹„í–‰ê¸°` ëª…ë ¹ì–´ -> [ì£¼ê³ ë°›ì€ ì¢…ì´ë¹„í–‰ê¸° ë³´ê¸°] ë¥¼ í†µí•´ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.\"\n                        )\n                    ],\n                ),\n            ],\n        )\n\n        return model\n\n    def fetch_sent_paper_planes(\n        self,\n        user_id: str,\n        offset: int,\n        limit: int,\n    ) -> tuple[int, list[models.PaperPlane]]:\n        \"\"\"ìœ ì €ê°€ ë³´ë‚¸ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        return self._repo.fetch_sent_paper_planes(\n            sender_id=user_id,\n            offset=offset,\n            limit=limit,\n        )\n\n    def fetch_received_paper_planes(\n        self,\n        user_id: str,\n        offset: int,\n        limit: int,\n    ) -> tuple[int, list[models.PaperPlane]]:\n        \"\"\"ìœ ì €ê°€ ë°›ì€ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        return self._repo.fetch_received_paper_planes(\n            receiver_id=user_id, offset=offset, limit=limit\n        )\n\n    def fetch_current_week_paper_planes(\n        self,\n        user_id: str,\n    ) -> list[models.PaperPlane]:\n        \"\"\"ì´ë²ˆ ì£¼ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        today = tz_now()\n\n        # ì§€ë‚œì£¼ í† ìš”ì¼ 00ì‹œ ê³„ì‚°\n        last_saturday = today - timedelta(days=(today.weekday() + 2) % 7)\n        start_dt = last_saturday.replace(hour=0, minute=0, second=0, microsecond=0)\n\n        # ì´ë²ˆì£¼ ê¸ˆìš”ì¼ 23:59:59 ê³„ì‚°\n        this_friday = start_dt + timedelta(days=6)\n        end_dt = this_friday.replace(hour=23, minute=59, second=59, microsecond=999999)\n\n        paper_planes = []\n        for plane in self._repo.fetch_paper_planes(sender_id=user_id):\n            plane_created_ad = datetime.fromisoformat(plane.created_at).replace(\n                tzinfo=ZoneInfo(\"Asia/Seoul\")\n            )\n            if start_dt <= plane_created_ad <= end_dt:\n                paper_planes.append(plane)\n\n        return paper_planes\n"}
{"type": "source_file", "path": "app/slack/event_handler.py", "content": "import re\nimport traceback\nfrom app.config import settings\nfrom slack_bolt.async_app import AsyncApp\nfrom slack_sdk.web.async_client import AsyncWebClient\n\nfrom app.logging import log_event\nfrom loguru import logger\nfrom slack_bolt.request import BoltRequest\nfrom slack_bolt.response import BoltResponse\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\nfrom slack_sdk.models.blocks import SectionBlock\nfrom slack_sdk.models.views import View\n\nfrom typing import Any, Callable, cast\n\nfrom app.slack.events import community as community_events\nfrom app.slack.events import contents as contents_events\nfrom app.slack.events import core as core_events\nfrom app.slack.events import log as log_events\nfrom app.slack.events import subscriptions as subscriptions_events\nfrom app.exception import BotException\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.base import SlackService\nfrom app.slack.services.point import PointService\nfrom app.slack.types import MessageBodyType\n\n\napp = AsyncApp(\n    client=AsyncWebClient(\n        token=settings.SLACK_BOT_TOKEN,\n        timeout=8,\n    ),\n)\n\n\n@app.middleware\nasync def log_event_middleware(\n    req: BoltRequest,\n    resp: BoltResponse,\n    next: Callable,\n) -> None:\n    \"\"\"ì´ë²¤íŠ¸ë¥¼ ë¡œê·¸ë¡œ ë‚¨ê¹ë‹ˆë‹¤.\"\"\"\n    body = req.body\n    if body.get(\"command\"):\n        event = body.get(\"command\")\n        type = \"command\"\n    elif body.get(\"type\") == \"view_submission\":\n        event = body.get(\"view\", {}).get(\"callback_id\")\n        type = \"view_submission\"\n    elif body.get(\"type\") == \"block_actions\":\n        event = body.get(\"actions\", [{}])[0].get(\"action_id\")\n        type = \"block_actions\"\n    elif body.get(\"event\"):\n        event = body.get(\"event\", {}).get(\"type\")\n        type = \"event\"\n    else:\n        event = \"unknown\"\n        type = \"unknown\"\n\n    if event not in [\n        \"message\",\n        \"member_joined_channel\",\n        \"reaction_added\",\n        \"reaction_removed\",\n    ]:\n        # message ì™€ reaction ì€ handle í•¨ìˆ˜ì—ì„œ ë³„ë„ë¡œ ë¡œê¹…í•©ë‹ˆë‹¤.\n        description = event_descriptions.get(str(event), \"ì•Œ ìˆ˜ ì—†ëŠ” ì´ë²¤íŠ¸\")\n\n        # ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ ì „ì†¡ ì™„ë£Œ ì´ë²¤íŠ¸ëŠ” ë‚´ìš©ì„ ë¡œê·¸ì— í¬í•¨ì‹œí‚¤ì§€ ì•ŠëŠ”ë‹¤.\n        if description == \"ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ ì „ì†¡ ì™„ë£Œ\":\n            req.context[\"event\"] = event\n            await next()\n\n        log_event(\n            actor=req.context.user_id,\n            event=event,  # type: ignore\n            type=type,\n            description=description,\n            body=body,\n        )\n\n    req.context[\"event\"] = event\n    await next()\n\n\n@app.middleware\nasync def dependency_injection_middleware(\n    req: BoltRequest,\n    resp: BoltResponse,\n    next: Callable,\n) -> None:\n    \"\"\"ì„œë¹„ìŠ¤ ê°ì²´ë¥¼ ì£¼ì…í•©ë‹ˆë‹¤.\"\"\"\n    event = req.context.get(\"event\")\n    user_id = req.context.user_id\n    channel_id = req.context.channel_id\n\n    if event in [\n        \"app_mention\",\n        \"channel_created\",\n        \"member_joined_channel\",\n        \"reaction_added\",\n        \"reaction_removed\",\n        \"message\",\n    ]:\n        # í•´ë‹¹ ì´ë²¤íŠ¸ëŠ” ì˜ì¡´ì„± ì£¼ì…ì„ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n        # ë©”ì‹œì§€ì˜ ê²½ìš° handle_message ì—ì„œ ì˜ì¡´ì„± ì£¼ì…ì„ í•©ë‹ˆë‹¤.\n        await next()\n        return\n\n    repo = SlackRepository()\n    user = repo.get_user(cast(str, user_id))\n    if user:\n        req.context[\"service\"] = SlackService(repo=repo, user=user)\n        req.context[\"point_service\"] = PointService(repo=repo)\n        req.context[\"user\"] = user\n        await next()\n        return\n\n    # TODO: 10ê¸° ë©¤ë²„ ë“±ë¡ í›„ì—ëŠ” ë¶ˆí•„ìš”í•˜ë¯€ë¡œ ì œê±°\n    if event == \"app_home_opened\":\n        # ë“±ë¡ë˜ì§€ ì•ŠëŠ” ë©¤ë²„ëŠ” ì˜ì¡´ì„±ì„ ì£¼ì…í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n        req.context[\"service\"] = None\n        req.context[\"point_service\"] = None\n        req.context[\"user\"] = None\n        await next()\n        return\n\n    if user_id is None:\n        # ì¼ë¶€ ìŠ¬ë™ ë´‡ì€ ì‚¬ìš©ì ì•„ì´ë””ê°€ ì—†ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n        return\n\n    message = (\n        \"ğŸ¥² ì‚¬ìš©ì ì •ë³´ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”. ğŸ‘‰ğŸ¼ \"\n        f\"event: `{event}` \"\n        f\"channel: <#{channel_id}> \"\n        f\"user_id: {user_id}\"\n    )\n    await app.client.chat_postMessage(channel=settings.ADMIN_CHANNEL, text=message)\n    logger.error(message)\n    raise BotException(\"ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”.\")\n\n\n@app.error\nasync def handle_error(error, body):\n    \"\"\"ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì—ì„œ ë°œìƒí•œ ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.\"\"\"\n    logger.error(f'\"{str(error)}\"')\n    trace = traceback.format_exc()\n    logger.debug(dict(body=body, error=trace))\n\n    # ë‹¨ìˆœ ê°’ ì—ëŸ¬ëŠ” ì‚¬ìš©ìì—ê²Œ ì•Œë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.\n    if isinstance(error, ValueError):\n        raise error\n\n    # ì‚¬ìš©ìì—ê²Œ ì—ëŸ¬ë¥¼ ì•Œë¦½ë‹ˆë‹¤.\n    if re.search(r\"[\\u3131-\\uD79D]\", str(error)):\n        # í•œê¸€ë¡œ í•¸ë“¤ë§í•˜ëŠ” ë©”ì‹œì§€ë§Œ ì‚¬ìš©ìì—ê²Œ ì „ì†¡í•©ë‹ˆë‹¤.\n        message = str(error)\n    else:\n        message = \"ì˜ˆê¸°ì¹˜ ëª»í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.\"\n\n    text = f\"ğŸ¥² {message}\\n\\nğŸ‘‰ğŸ¼ ë¬¸ì œê°€ í•´ê²°ë˜ì§€ ì•ŠëŠ”ë‹¤ë©´ <#{settings.BOT_SUPPORT_CHANNEL}> ì±„ë„ë¡œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.\"\n    if trigger_id := body.get(\"trigger_id\"):\n        await app.client.views_open(\n            trigger_id=trigger_id,\n            view=View(\n                type=\"modal\",\n                title={\"type\": \"plain_text\", \"text\": \"ì ê¹!\"},\n                blocks=[SectionBlock(text=text)],\n            ),\n        )\n\n    # ê´€ë¦¬ìì—ê²Œ ì—ëŸ¬ë¥¼ ì•Œë¦½ë‹ˆë‹¤.\n    await app.client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=f\"ğŸ«¢: {error=} ğŸ•Šï¸: {trace=} ğŸ‘‰ğŸ¼ ğŸ’Œ: {body=}\",\n    )\n\n\n@app.event(\"message\")\nasync def handle_message(\n    ack: AsyncAck,\n    body: MessageBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n) -> None:\n    await ack()\n\n    event: dict[str, Any]\n    subtype: str | None\n    user_id: str\n    channel_id: str\n    thread_ts: str | None\n    ts: str\n    is_thread: bool\n\n    event = body.get(\"event\", {})  # type: ignore\n    subtype = event.get(\"subtype\")\n\n    # 1. ë©”ì‹œì§€ íƒ€ì…ì— ë”°ë¥¸ ë³€ìˆ˜ í• ë‹¹\n    # 1-1. ë©”ì‹œì§€ ìˆ˜ì • ë° íŒŒì¼ ê³µìœ  ì™¸ì˜ subtype ì´ë²¤íŠ¸ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n    # ìì„¸í•œ subtype ì´ ê¶ê¸ˆí•˜ë‹¤ë©´ https://api.slack.com/events/message ì°¸ê³ .\n    if subtype and subtype not in [\"message_changed\", \"file_share\"]:\n        return\n\n    # 1-2. ë©”ì‹œì§€ ìˆ˜ì • ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.\n    elif subtype == \"message_changed\":\n        # ì´ë¯¸ ë´‡ì´ ëŒ“ê¸€ì„ ë‹¨ ê²½ìš°ëŠ” ì»¤í”¼ì±— ì¸ì¦ ì ˆì°¨ê°€ ì§„í–‰ëœ ê²½ìš°ì´ë¯€ë¡œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n        if settings.TTOBOT_USER_ID in event.get(\"message\", {}).get(\"reply_users\", []):\n            return\n\n        user_id = event.get(\"message\", {}).get(\"user\")\n        channel_id = event[\"channel\"]\n        thread_ts = event.get(\"message\", {}).get(\"thread_ts\")\n        ts = event.get(\"message\", {}).get(\"ts\")\n        is_thread = thread_ts != ts if thread_ts else False\n\n    # 1-3. subtype ì´ file_share ì´ê±°ë‚˜ ì—†ëŠ” ê²½ìš°ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.\n    else:\n        user_id = event[\"user\"]\n        channel_id = event[\"channel\"]\n        thread_ts = event.get(\"thread_ts\")\n        ts = event[\"ts\"]\n        is_thread = thread_ts != ts if thread_ts else False\n\n        if is_thread:\n            await log_events.handle_comment_data(body=body)\n        else:  # TODO: ëŒ“ê¸€ì´ post_data ë¡œ ë“¤ì–´ì˜¤ëŠ” ê²½ìš°ê°€ ìˆëŠ”ì§€ í™•ì¸ í•„ìš”.\n            await log_events.handle_post_data(body=body)\n\n    # 2. user_id ê°€ ì—†ëŠ” ì´ë²¤íŠ¸(ì¼ë¶€ ìŠ¬ë™ ë´‡)ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n    if user_id is None:\n        return\n\n    # 3. ì‚¬ìš©ìê°€ ë¬¸ì˜ì‚¬í•­ì„ ë‚¨ê¸°ë©´ ê´€ë¦¬ìì—ê²Œ ì•Œë¦½ë‹ˆë‹¤.\n    if (\n        channel_id in [settings.BOT_SUPPORT_CHANNEL, settings.SUPPORT_CHANNEL]\n        and not is_thread\n        and subtype != \"message_changed\"\n    ):\n        repo = SlackRepository()\n        user = repo.get_user(user_id)\n        if not user:\n            await _notify_missing_user_info(client, user_id)\n            return\n\n        message = f\"ğŸ‘‹ğŸ¼ <#{user.channel_id}>ì±„ë„ì˜ {user.name}ë‹˜ì´ <#{channel_id}>ì„ ë‚¨ê²¼ì–´ìš”. ğŸ‘€ <@{settings.SUPER_ADMIN}> <@{settings.ADMIN_IDS[1]}>\"\n        await client.chat_postMessage(channel=settings.ADMIN_CHANNEL, text=message)\n        return\n\n    # 4. ì»¤í”¼ì±— ì¸ì¦ ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.\n    elif channel_id == settings.COFFEE_CHAT_PROOF_CHANNEL:\n        repo = SlackRepository()\n        user = repo.get_user(user_id)\n        if not user:\n            await _notify_missing_user_info(client, user_id)\n            return\n\n        description = event_descriptions.get(\n            \"coffee_chat_proof_message\", \"ì•Œ ìˆ˜ ì—†ëŠ” ì´ë²¤íŠ¸\"\n        )\n        log_event(\n            actor=user.user_id,\n            event=\"coffee_chat_proof_message\",\n            type=\"message\",\n            description=description,\n            body=body,\n        )\n\n        service = SlackService(repo=repo, user=user)\n        point_service = PointService(repo=repo)\n        await community_events.handle_coffee_chat_message(\n            ack=ack,\n            body=body,\n            say=say,\n            client=client,\n            user=user,\n            service=service,\n            point_service=point_service,\n            subtype=subtype,\n            is_thread=is_thread,\n            ts=ts,\n        )\n        return\n\n\nasync def _notify_missing_user_info(client: AsyncWebClient, user_id: str):\n    text = f\"ğŸ¥² ì‚¬ìš©ì ì •ë³´ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”. ğŸ‘‰ğŸ¼ user_id: {user_id}\"\n    await client.chat_postMessage(channel=settings.ADMIN_CHANNEL, text=text)\n    logger.error(text)\n\n\n@app.event(\"member_joined_channel\")\nasync def handle_member_joined_channel(ack, body) -> None:\n    await ack()\n\n\n# community\napp.action(\"cancel_coffee_chat_proof_button\")(\n    community_events.cancel_coffee_chat_proof_button\n)\napp.action(\"submit_coffee_chat_proof_button\")(\n    community_events.submit_coffee_chat_proof_button\n)\napp.view(\"submit_coffee_chat_proof_view\")(\n    community_events.submit_coffee_chat_proof_view\n)\napp.command(\"/ì¢…ì´ë¹„í–‰ê¸°\")(community_events.paper_plane_command)\n\n# contents\napp.command(\"/ì œì¶œ\")(contents_events.submit_command)\napp.view(\"submit_view\")(contents_events.submit_view)\napp.action(\"intro_modal\")(contents_events.open_intro_modal)\n# app.action(\"forward_message\")(contents_events.forward_message)\napp.view(\"edit_intro_view\")(contents_events.edit_intro_view)\napp.view(\"submit_intro_view\")(contents_events.submit_intro_view)\napp.action(\"contents_modal\")(contents_events.contents_modal)\napp.action(\"bookmark_modal\")(contents_events.bookmark_modal)\napp.view(\"bookmark_view\")(contents_events.create_bookmark_view)\napp.command(\"/íŒ¨ìŠ¤\")(contents_events.pass_command)\napp.view(\"pass_view\")(contents_events.pass_view)\napp.command(\"/ê²€ìƒ‰\")(contents_events.search_command)\napp.view(\"submit_search\")(contents_events.submit_search)\napp.action(\"web_search\")(contents_events.web_search)\napp.view(\"back_to_search_view\")(contents_events.back_to_search_view)\napp.command(\"/ë¶ë§ˆí¬\")(contents_events.bookmark_command)\napp.action(\"open_bookmark_page_view\")(contents_events.bookmark_page_view)\napp.action(\"bookmark_overflow_action\")(contents_events.open_overflow_action)\napp.action(\"next_bookmark_page_action\")(contents_events.handle_bookmark_page)\napp.action(\"prev_bookmark_page_action\")(contents_events.handle_bookmark_page)\napp.view(\"handle_bookmark_page_view\")(contents_events.handle_bookmark_page)\n\n# core\napp.event(\"app_mention\")(core_events.handle_app_mention)\napp.event(\"channel_created\")(core_events.handle_channel_created)\napp.command(\"/ì˜ˆì¹˜ê¸ˆ\")(core_events.open_deposit_view)\napp.command(\"/ì œì¶œë‚´ì—­\")(core_events.open_submission_history_view)\napp.command(\"/ë„ì›€ë§\")(core_events.open_help_view)\napp.command(\"/ê´€ë¦¬ì\")(core_events.admin_command)\napp.action(\"sync_store_select\")(core_events.handle_sync_store)\napp.action(\"invite_channel\")(core_events.handle_invite_channel)\napp.view(\"invite_channel_view\")(core_events.handle_invite_channel_view)\napp.event(\"app_home_opened\")(core_events.handle_home_tab)\napp.action(\"open_deposit_view\")(core_events.open_deposit_view)\napp.action(\"open_submission_history_view\")(core_events.open_submission_history_view)\napp.action(\"open_help_view\")(core_events.open_help_view)\napp.action(\"open_point_history_view\")(core_events.open_point_history_view)\napp.action(\"open_point_guide_view\")(core_events.open_point_guide_view)\napp.action(\"send_paper_plane_message\")(core_events.send_paper_plane_message)\napp.action(\"open_paper_plane_url\")(core_events.open_paper_plane_url)\napp.view(\"send_paper_plane_message_view\")(core_events.send_paper_plane_message_view)\napp.action(\"open_paper_plane_guide_view\")(core_events.open_paper_plane_guide_view)\napp.action(\"open_coffee_chat_history_view\")(core_events.open_coffee_chat_history_view)\napp.action(\"download_point_history\")(core_events.download_point_history)\napp.action(\"download_coffee_chat_history\")(core_events.download_coffee_chat_history)\napp.action(\"download_submission_history\")(core_events.download_submission_history)\napp.action(\"open_subscribe_member_view\")(\n    subscriptions_events.open_subscribe_member_view\n)\napp.action(\"subscribe_member\")(subscriptions_events.subscribe_member)\napp.action(\"unsubscribe_member\")(subscriptions_events.unsubscribe_member)\n\n# log\napp.event(\"reaction_added\")(log_events.handle_reaction_added)\napp.event(\"reaction_removed\")(log_events.handle_reaction_removed)\napp.action(\"open_subscription_permalink\")(\n    subscriptions_events.open_subscription_permalink\n)\n\n\nevent_descriptions = {\n    \"/ì œì¶œ\": \"ê¸€ ì œì¶œ ì‹œì‘\",\n    \"submit_view\": \"ê¸€ ì œì¶œ ì™„ë£Œ\",\n    \"intro_modal\": \"ë‹¤ë¥¸ ìœ ì €ì˜ ìê¸°ì†Œê°œ í™•ì¸\",\n    # \"forward_message\": \"ë‹¤ë¥¸ ì±„ë„ë¡œ ë©”ì‹œì§€ ì „ì†¡\",\n    \"edit_intro_view\": \"ìê¸°ì†Œê°œ ìˆ˜ì • ì‹œì‘\",\n    \"submit_intro_view\": \"ìê¸°ì†Œê°œ ìˆ˜ì • ì™„ë£Œ\",\n    \"contents_modal\": \"ë‹¤ë¥¸ ìœ ì €ì˜ ì œì¶œí•œ ê¸€ ëª©ë¡ í™•ì¸\",\n    \"bookmark_modal\": \"ë¶ë§ˆí¬ ì €ì¥ ì‹œì‘\",\n    \"bookmark_view\": \"ë¶ë§ˆí¬ ì €ì¥ ì™„ë£Œ\",\n    \"/íŒ¨ìŠ¤\": \"ê¸€ íŒ¨ìŠ¤ ì‹œì‘\",\n    \"pass_view\": \"ê¸€ íŒ¨ìŠ¤ ì™„ë£Œ\",\n    \"/ê²€ìƒ‰\": \"ê¸€ ê²€ìƒ‰ ì‹œì‘\",\n    \"submit_search\": \"ê¸€ ê²€ìƒ‰ ì™„ë£Œ\",\n    \"web_search\": \"ì›¹ ê²€ìƒ‰ ì‹œì‘\",\n    \"back_to_search_view\": \"ê¸€ ê²€ìƒ‰ ë‹¤ì‹œ ì‹œì‘\",\n    \"/ë¶ë§ˆí¬\": \"ë¶ë§ˆí¬ ì¡°íšŒ\",\n    \"bookmark_overflow_action\": \"ë¶ë§ˆí¬ ë©”ë‰´ ì„ íƒ\",\n    \"next_bookmark_page_action\": \"ë‹¤ìŒ ë¶ë§ˆí¬ í˜ì´ì§€\",\n    \"prev_bookmark_page_action\": \"ì´ì „ ë¶ë§ˆí¬ í˜ì´ì§€\",\n    \"handle_bookmark_page_view\": \"ë¶ë§ˆí¬ í˜ì´ì§€ ì´ë™\",\n    \"app_mention\": \"ì•± ë©˜ì…˜\",\n    \"/ì˜ˆì¹˜ê¸ˆ\": \"ì˜ˆì¹˜ê¸ˆ ì¡°íšŒ\",\n    \"/ì œì¶œë‚´ì—­\": \"ì œì¶œë‚´ì—­ ì¡°íšŒ\",\n    \"/ê´€ë¦¬ì\": \"ê´€ë¦¬ì ë©”ë‰´ ì¡°íšŒ\",\n    \"/ë„ì›€ë§\": \"ë„ì›€ë§ ì¡°íšŒ\",\n    \"coffee_chat_proof_message\": \"ì»¤í”¼ì±— ì¸ì¦ ë©”ì‹œì§€\",\n    \"cancel_coffee_chat_proof_button\": \"ì»¤í”¼ì±— ì¸ì¦ ì•ˆë‚´ ë‹«ê¸°\",\n    \"submit_coffee_chat_proof_button\": \"ì»¤í”¼ì±— ì¸ì¦ ì œì¶œ ì‹œì‘\",\n    \"submit_coffee_chat_proof_view\": \"ì»¤í”¼ì±— ì¸ì¦ ì œì¶œ ì™„ë£Œ\",\n    \"sync_store_select\": \"ë°ì´í„° ë™ê¸°í™”\",\n    \"invite_channel\": \"ì±„ë„ ì´ˆëŒ€\",\n    \"invite_channel_view\": \"ì±„ë„ ì´ˆëŒ€ ì™„ë£Œ\",\n    \"app_home_opened\": \"í™ˆ íƒ­ ì—´ë¦¼\",\n    \"open_deposit_view\": \"ì˜ˆì¹˜ê¸ˆ ì¡°íšŒ\",\n    \"open_submission_history_view\": \"ì œì¶œë‚´ì—­ ì¡°íšŒ\",\n    \"open_help_view\": \"ë„ì›€ë§ ì¡°íšŒ\",\n    \"open_point_history_view\": \"í¬ì¸íŠ¸ ë‚´ì—­ ì¡°íšŒ\",\n    \"open_point_guide_view\": \"í¬ì¸íŠ¸ ê°€ì´ë“œ ì¡°íšŒ\",\n    \"send_paper_plane_message\": \"ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ ì „ì†¡ ì‹œì‘\",\n    \"open_paper_plane_url\": \"ì¢…ì´ë¹„í–‰ê¸° URL ì—´ê¸°\",\n    \"open_paper_plane_guide_view\": \"ì¢…ì´ë¹„í–‰ê¸° ê°€ì´ë“œ ì¡°íšŒ\",\n    \"open_coffee_chat_history_view\": \"ì»¤í”¼ì±— ë‚´ì—­ ì¡°íšŒ\",\n    \"download_point_history\": \"í¬ì¸íŠ¸ ë‚´ì—­ ë‹¤ìš´ë¡œë“œ\",\n    \"download_coffee_chat_history\": \"ì»¤í”¼ì±— ë‚´ì—­ ë‹¤ìš´ë¡œë“œ\",\n    \"download_submission_history\": \"ì œì¶œë‚´ì—­ ë‹¤ìš´ë¡œë“œ\",\n    \"send_paper_plane_message_view\": \"ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ ì „ì†¡ ì™„ë£Œ\",\n    \"channel_created\": \"ì±„ë„ ìƒì„±\",\n    \"/ì¢…ì´ë¹„í–‰ê¸°\": \"ì¢…ì´ë¹„í–‰ê¸° ëª¨ë‹¬ ì—´ê¸°\",\n    \"subscribe_member\": \"ë©¤ë²„ êµ¬ë… ì™„ë£Œ\",\n    \"open_subscribe_member_view\": \"ë©¤ë²„ êµ¬ë… ëª¨ë‹¬ ì—´ê¸°\",\n    \"open_subscription_permalink\": \"êµ¬ë…í•œ ë©¤ë²„ì˜ ìƒˆ ê¸€ ë³´ê¸°\",\n    \"unsubscribe_member\": \"ë©¤ë²„ êµ¬ë… ì·¨ì†Œ\",\n}\n"}
{"type": "source_file", "path": "app/api/views/contents.py", "content": "from enum import StrEnum\nfrom typing import Any, Literal\nimport polars as pl\n\nfrom starlette import status\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom app.api.auth import current_user\nfrom app.constants import ContentCategoryEnum, ContentSortEnum\nfrom app.api import dto\nfrom app.models import SimpleUser\nfrom app.utils import translate_keywords\nfrom app.config import settings\nfrom app.slack.event_handler import app as slack_app\nfrom slack_sdk.errors import SlackApiError\n\n\nclass JobCategoryEnum(StrEnum):\n    DATA_SCIENCE = \"ë°ì´í„°ê³¼í•™\"\n    DATA_ANALYSIS = \"ë°ì´í„°ë¶„ì„\"\n    DATA_ENGINEERING = \"ë°ì´í„°ì—”ì§€ë‹ˆì–´\"\n    BACKEND = \"ë°±ì—”ë“œ\"\n    ANDROID = \"ì•ˆë“œ\"\n    INFRA = \"ì¸í”„ë¼\"\n    FULL_STACK = \"í’€ìŠ¤íƒ\"\n    FRONTEND = \"í”„ë¡ íŠ¸\"\n    FLUTTER = \"í”ŒëŸ¬í„°\"\n    AI = \"ai\"\n    IOS = \"ios\"\n    ML = \"ml\"\n    PMPO = \"pmpo\"\n\n\nrouter = APIRouter()\n\n\n@router.get(\n    \"/contents\",\n    status_code=status.HTTP_200_OK,\n    response_model=dto.ContentResponse,\n)\nasync def fetch_contents(\n    keyword: str,\n    offset: int = 0,\n    limit: int = Query(default=50, le=50),\n    category: ContentCategoryEnum | None = None,\n    order_by: ContentSortEnum = ContentSortEnum.DT,\n    descending: bool = True,\n    job_category: JobCategoryEnum | None = None,\n) -> dto.ContentResponse:\n    \"\"\"ì¡°ê±´ì— ë§ëŠ” ì½˜í…ì¸ ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n    # TODO: LIKE ì»¬ëŸ¼ ì¶”ê°€í•˜ê¸°\n    # TODO: ê²°ê³¼ê°€ ì—†ì„ ê²½ìš°, ê¸€ê° ì¶”ì²œí•˜ê¸° <- í´ë¼ì´ì–¸íŠ¸ê°€ ì²˜ë¦¬\n    # TODO: ë¶ë§ˆí¬ ê¸€ ì—°ë™í•˜ê¸°\n    # TODO: íë ˆì´ì…˜ íƒ­ ì¶”ê°€í•˜ê¸°\n\n    # ì›ë³¸ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°\n    users_df = pl.read_csv(\n        \"store/users.csv\",\n        columns=[\"user_id\", \"name\", \"cohort\", \"channel_name\"],\n    )\n    contents_df = pl.read_csv(\n        \"store/contents.csv\",\n        columns=[\n            \"user_id\",\n            \"title\",\n            \"content_url\",\n            \"dt\",\n            \"category\",\n            \"tags\",\n            \"ts\",\n        ],\n    )\n\n    # ì§êµ° í•„í„°ë§\n    if job_category:\n        users_df = (\n            users_df.filter(pl.col(\"channel_name\").str.contains(f\"(?i){job_category}\"))\n            .with_columns(pl.lit(job_category).alias(\"job_category\"))\n            .drop(\"channel_name\")\n        )\n    else:\n        job_categories = [category.value for category in JobCategoryEnum]\n        users_df = users_df.with_columns(\n            pl.col(\"channel_name\")\n            .apply(lambda x: next((cat for cat in job_categories if cat in x), None))\n            .alias(\"job_category\")\n        ).drop(\"channel_name\")\n\n    # ìœ ë‹ˆí¬í•œ ì½˜í…ì¸ ë§Œ ê°€ì ¸ì˜¤ê¸°\n    joined_df = contents_df.unique(subset=[\"content_url\"]).join(\n        users_df, on=\"user_id\", how=\"inner\"\n    )\n\n    if keyword == \"ì „ì²´ë³´ê¸°\":\n        # 'ì „ì²´ë³´ê¸°'ëŠ” ìµœì‹ ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ë°˜í™˜\n        contents = joined_df.sort([\"dt\"], descending=descending)\n        count = len(contents)\n        data = list(\n            map(\n                lambda x: {**x, \"relevance\": 0},\n                contents.slice(offset, limit).to_dicts(),\n            )\n        )\n        return dto.ContentResponse(count=count, data=data)\n\n    if category:\n        contents_df = contents_df.filter(contents_df[\"category\"] == category)\n\n    # í‚¤ì›Œë“œ ì¶”ì¶œ, TODO: ëª…ì‚¬ ë‹¨ìœ„ë¡œ ìª¼ê°œì„œ ê²€ìƒ‰í•˜ê¸°\n    keywords = [\n        keyword.lower()\n        for keyword in keyword.replace(\",\", \" \").replace(\"/\", \" \").split(\" \")\n        if keyword\n    ]\n    keywords.extend(translate_keywords(keywords))\n\n    # í‚¤ì›Œë“œ ë§¤ì¹­\n    matched_dfs = [\n        joined_df.filter(\n            joined_df.apply(lambda row: match_keyword(keyword, row)).to_series()\n        )\n        for keyword in set(keywords)\n    ]\n    if not matched_dfs:\n        return dto.ContentResponse(count=0, data=[])\n\n    # ê´€ë ¨ë„ ì¶”ê°€\n    combined_df: pl.DataFrame = pl.concat(matched_dfs)\n    grouped_df = combined_df.groupby(\"content_url\").agg(pl.count().alias(\"relevance\"))\n\n    contents = joined_df.join(grouped_df, on=\"content_url\", how=\"inner\").sort(\n        [order_by, \"dt\"], descending=[descending, True]\n    )\n\n    count = len(contents)\n    data = contents.slice(offset, limit).to_dicts()\n    return dto.ContentResponse(count=count, data=data)\n\n\ndef match_keyword(keyword: str, row: tuple) -> bool:\n    return keyword in f\"{row[1]},{row[5]},{row[7]}\".lower()  # title, tags, name\n\n\n@router.get(\n    \"/messages\",\n    status_code=status.HTTP_200_OK,\n)\nasync def get_message(\n    ts: str,\n    channel_id: str,\n    multiple_messages: bool = False,\n    type: Literal[\"message\", \"reply\"] = \"message\",\n    user: SimpleUser = Depends(current_user),\n) -> dict[str, Any] | list[dict[str, Any]]:\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"ìˆ˜ì • ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.\")\n\n    try:\n        if type == \"message\":\n            data = await slack_app.client.conversations_history(\n                channel=channel_id,\n                latest=ts,\n                inclusive=True,\n                limit=10 if multiple_messages else 1,\n            )\n        else:\n            data = await slack_app.client.conversations_replies(\n                channel=channel_id, ts=ts, inclusive=True, limit=1\n            )\n\n        if multiple_messages:\n            return [\n                {\n                    \"ts\": message[\"ts\"],\n                    \"text\": message[\"text\"],\n                    \"blocks\": message[\"blocks\"],\n                    \"attachments\": message.get(\"attachments\", []),\n                }\n                for message in data[\"messages\"]\n            ]\n\n        message = next((msg for msg in data[\"messages\"] if msg[\"ts\"] == ts), None)\n        if not message:\n            raise HTTPException(status_code=404, detail=\"ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\")\n\n        text = message[\"text\"]\n        blocks = message[\"blocks\"]\n        attachments = message.get(\"attachments\", [])\n\n        return {\n            \"text\": text,\n            \"blocks\": blocks,\n            \"attachments\": attachments,\n        }\n\n    except SlackApiError as e:\n        raise HTTPException(status_code=409, detail=str(e))\n\n\nclass UpdateMessageRequest(dto.BaseModel):\n    text: str\n    blocks: list[dict[str, Any]]\n    attachments: list[dict[str, Any]]\n\n\n@router.post(\n    \"/messages\",\n    status_code=status.HTTP_200_OK,\n)\nasync def update_message(\n    ts: str,\n    channel_id: str,\n    data: UpdateMessageRequest,\n    user: SimpleUser = Depends(current_user),\n):\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"ìˆ˜ì • ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.\")\n\n    try:\n        await slack_app.client.chat_update(\n            channel=channel_id,\n            ts=ts,\n            text=data.text,\n            blocks=data.blocks,\n            attachments=data.attachments,\n        )\n\n        permalink_res = await slack_app.client.chat_getPermalink(\n            channel=channel_id,\n            message_ts=ts,\n        )\n\n        return {\"permalink\": permalink_res[\"permalink\"]}\n\n    except SlackApiError as e:\n        raise HTTPException(status_code=409, detail=str(e))\n"}
{"type": "source_file", "path": "app/api/views/paper_planes.py", "content": "from pydantic import BaseModel\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom app.api.auth import current_user\nfrom app.api.deps import api_service\nfrom app.api.services import ApiService\nfrom app.api import dto\nfrom app.constants import BOT_IDS\nfrom app.models import SimpleUser\nfrom app.config import settings\nfrom app.slack.event_handler import app as slack_app\n\nrouter = APIRouter()\n\n\nclass SendPaperPlaneCreateIn(BaseModel):\n    receiver_id: str\n    text: str\n\n\n@router.post(\n    \"/paper-planes\",\n    status_code=status.HTTP_201_CREATED,\n)\nasync def send_paper_plane(\n    dto: SendPaperPlaneCreateIn,\n    service: ApiService = Depends(api_service),\n    user: SimpleUser = Depends(current_user),\n) -> dict[str, str]:\n    \"\"\"ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ëƒ…ë‹ˆë‹¤.\"\"\"\n    if user.user_id == dto.receiver_id:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"ì¢…ì´ë¹„í–‰ê¸°ëŠ” ìì‹ ì—ê²Œ ë³´ë‚¼ ìˆ˜ ì—†ì–´ìš”. ğŸ˜‰\",\n        )\n\n    if len(dto.text) > 300:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ëŠ” 300ì ì´ë‚´ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”. ğŸ˜‰\",\n        )\n\n    if dto.receiver_id in BOT_IDS:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"ë´‡ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ë‚¼ ìˆ˜ ì—†ì–´ìš”. ğŸ˜‰\",\n        )\n\n    if user.user_id == settings.SUPER_ADMIN:\n        pass\n    else:\n        pass\n        # paper_planes = service.fetch_current_week_paper_planes(user_id=user.user_id)\n        # if len(paper_planes) >= 7:\n        #     raise HTTPException(\n        #         status_code=status.HTTP_400_BAD_REQUEST,\n        #         detail=\"ì¢…ì´ë¹„í–‰ê¸°ëŠ” í•œ ì£¼ì— 7ê°œê¹Œì§€ ë³´ë‚¼ ìˆ˜ ìˆì–´ìš”. (í† ìš”ì¼ 00ì‹œì— ì¶©ì „)\",\n        #     )\n\n    await service.send_paper_plane(\n        sender_id=user.user_id,\n        sender_name=user.name,\n        receiver_id=dto.receiver_id,\n        text=dto.text,\n        client=slack_app.client,\n    )\n    return {\"message\": \"ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.\"}\n\n\n@router.get(\n    \"/paper-planes/sent\",\n    status_code=status.HTTP_200_OK,\n    response_model=dto.PaperPlaneResponse,\n)\nasync def fetch_sent_paper_planes(\n    offset: int = 0,\n    limit: int = Query(default=1000, le=1000),  # TODO: ë¬´í•œ ìŠ¤í¬ë¡¤ êµ¬í˜„ ì‹œ ìˆ˜ì •\n    service: ApiService = Depends(api_service),\n    user: SimpleUser = Depends(current_user),\n) -> dto.PaperPlaneResponse:\n    \"\"\"ì¡°ê±´ì— ë§ëŠ” ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n    count, data = service.fetch_sent_paper_planes(\n        user_id=user.user_id, offset=offset, limit=limit\n    )\n    return dto.PaperPlaneResponse(\n        count=count, data=[each.model_dump() for each in data]\n    )\n\n\n@router.get(\n    \"/paper-planes/received\",\n    status_code=status.HTTP_200_OK,\n    response_model=dto.PaperPlaneResponse,\n)\nasync def fetch_received_paper_planes(\n    offset: int = 0,\n    limit: int = Query(default=1000, le=1000),  # TODO: ë¬´í•œ ìŠ¤í¬ë¡¤ êµ¬í˜„ ì‹œ ìˆ˜ì •\n    service: ApiService = Depends(api_service),\n    user: SimpleUser = Depends(current_user),\n) -> dto.PaperPlaneResponse:\n    \"\"\"ì¡°ê±´ì— ë§ëŠ” ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n    count, data = service.fetch_received_paper_planes(\n        user_id=user.user_id, offset=offset, limit=limit\n    )\n    return dto.PaperPlaneResponse(\n        count=count, data=[each.model_dump() for each in data]\n    )\n"}
{"type": "source_file", "path": "app/slack/__init__.py", "content": ""}
{"type": "source_file", "path": "app/logging.py", "content": "import datetime\nimport decimal\nimport uuid\nimport orjson\n\nfrom typing import Any, Mapping\n\nfrom pydantic import BaseModel\nfrom app.utils import tz_now, tz_now_to_str\nfrom loguru import logger\n\n\ndef filter(record):\n    record[\"time\"] = tz_now().strftime(\"%Y-%m-%d %H:%M:%S.%f%z\")\n    message = record[\"message\"].replace('\"', \"'\")\n    record[\"message\"] = f'\"{message}\"'\n    return True\n\n\nlogger.add(\"store/logs.csv\", format=\"{time},{level},{message}\", filter=filter)\n\n\ndef default(obj: Any) -> str | list[Any] | dict[str, Any]:\n    if isinstance(obj, (decimal.Decimal, uuid.UUID)):\n        return str(obj)\n    elif isinstance(obj, set):\n        return list(obj)\n    elif isinstance(obj, datetime.datetime):\n        return obj.isoformat()\n    elif isinstance(obj, datetime.date):\n        return obj.isoformat()\n    elif isinstance(obj, bytes):\n        return obj.decode(\"utf-8\")\n    elif isinstance(obj, BaseModel):\n        return obj.model_dump()\n    else:\n        return \"This object cannot be serialized.\"\n\n\ndef log_event(\n    actor: str | None,\n    event: str,\n    type: str,\n    description: str = \"\",\n    body: Mapping[str, Any] = {},\n) -> None:\n    try:\n        data = dict(\n            actor=actor,\n            event=event,\n            type=type,\n            description=description,\n            timestamp=tz_now_to_str(),\n            body=body,\n        )\n        logger.info(orjson.dumps(data, default=default).decode(\"utf-8\"))\n    except Exception as e:\n        logger.debug(f\"Failed to log event: {str(e)}\")\n"}
{"type": "source_file", "path": "app/api/views/inflearn.py", "content": "from typing import Any\nfrom starlette import status\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom app.api.auth import current_user\nfrom app.models import SimpleUser\nfrom app.config import settings\n\nimport csv\n\nrouter = APIRouter()\n\n\n@router.get(\n    \"/inflearn/coupons\",\n    status_code=status.HTTP_200_OK,\n)\nasync def fetch_inflearn_coupons(\n    user: SimpleUser = Depends(current_user),\n) -> dict[str, Any]:\n    \"\"\"ì¸í”„ëŸ° ì¿ í° ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"ì¡°íšŒ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.\")\n\n    with open(\"store/_inflearn_coupon.csv\", encoding=\"utf-8\") as f:\n        reader = csv.DictReader(f)\n        data = [each for each in reader]\n\n    return {\"data\": data}\n"}
{"type": "source_file", "path": "app/api/views/point.py", "content": "import asyncio\nfrom enum import StrEnum\nfrom typing import Any\n\nfrom starlette import status\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom app.api.auth import current_user\nfrom app.api.deps import point_service\nfrom app.models import SimpleUser\nfrom app.slack.services.point import PointService\nfrom app.slack_notification import send_point_noti_message\nfrom app.config import settings\nfrom app.slack.event_handler import app as slack_app\n\n\nclass PointTypeEnum(StrEnum):\n    CURATION = \"curation\"\n    VILLAGE_CONFERENCE = \"village_conference\"\n    SPECIAL = \"special\"\n\n\nrouter = APIRouter()\n\n\n@router.post(\n    \"/points\",\n    status_code=status.HTTP_200_OK,\n)\nasync def grant_points(\n    user_ids: list[str],\n    point_type: PointTypeEnum,\n    text: str = \"\",\n    point: int = 0,\n    reason: str = \"\",\n    user: SimpleUser = Depends(current_user),\n    point_service: PointService = Depends(point_service),\n) -> dict[str, Any]:\n    \"\"\"\n    ê´€ë¦¬ìê°€ ì—¬ëŸ¬ ìœ ì €ì—ê²Œ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•˜ëŠ” APIì…ë‹ˆë‹¤.\n    \"\"\"\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"ì§€ê¸‰ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.\")\n\n    if point_type == PointTypeEnum.CURATION:\n        for user_id in user_ids:\n            message = point_service.grant_if_curation_selected(user_id)\n            await send_point_noti_message(\n                client=slack_app.client,\n                channel=user_id,\n                text=text + \"\\n\" + message,\n            )\n            await asyncio.sleep(1)\n        return {\"message\": \"íë ˆì´ì…˜ ì„ ì • í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í–ˆìŠµë‹ˆë‹¤.\"}\n\n    elif point_type == PointTypeEnum.VILLAGE_CONFERENCE:\n        for user_id in user_ids:\n            message = point_service.grant_if_village_conference_participated(user_id)\n            await send_point_noti_message(\n                client=slack_app.client,\n                channel=user_id,\n                text=text + \"\\n\" + message,\n            )\n            await asyncio.sleep(1)\n        return {\"message\": \"ë¹Œë¦¬ì§€ ë°˜ìƒíšŒ ì°¸ì—¬ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í–ˆìŠµë‹ˆë‹¤.\"}\n\n    elif point_type == PointTypeEnum.SPECIAL:\n        if not point or not reason:\n            raise HTTPException(\n                status_code=400,\n                detail=\"íŠ¹ë³„ ë³´ë„ˆìŠ¤ í¬ì¸íŠ¸ëŠ” pointì™€ reasonì´ í•„ìš”í•©ë‹ˆë‹¤.\",\n            )\n        for user_id in user_ids:\n            message = point_service.grant_if_special_point(user_id, point, reason)\n            await send_point_noti_message(\n                client=slack_app.client,\n                channel=user_id,\n                text=text + \"\\n\" + message,\n            )\n            await asyncio.sleep(1)\n        return {\"message\": \"íŠ¹ë³„ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í–ˆìŠµë‹ˆë‹¤.\"}\n"}
{"type": "source_file", "path": "app/config.py", "content": "from typing import Any\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    ENV: str\n    SERVER_DOMAIN: str\n    CLIENT_DOMAIN: str\n\n    SLACK_BOT_TOKEN: str\n    SLACK_APP_TOKEN: str\n    SLACK_CLIENT_ID: str\n    SLACK_CLIENT_SECRET: str\n\n    SCOPE: list[str]\n    JSON_KEYFILE_DICT: dict[str, Any]\n    SPREAD_SHEETS_URL: str\n    DEPOSIT_SHEETS_URL: str\n    SECRET_KEY: str\n    BIGQUERY_CREDENTIALS: dict[str, Any]\n    BIGQUERY_DATABASE_ID: str\n\n    NOTICE_CHANNEL: str\n    BOT_SUPPORT_CHANNEL: str\n    SUPPORT_CHANNEL: str\n    THANKS_CHANNEL: str\n    COFFEE_CHAT_PROOF_CHANNEL: str\n    ADMIN_CHANNEL: str\n    ADMIN_IDS: list[str]\n    TTOBOT_USER_ID: str\n    SUPER_ADMIN: str\n\n    POINT_MAP: dict[str, Any]\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "app/client.py", "content": "from typing import Any\nfrom app.logging import logger\nfrom app.config import settings\n\nfrom gspread import authorize, Spreadsheet, Worksheet\nfrom oauth2client.service_account import ServiceAccountCredentials\nfrom app.models import StoreModel\n\n\ncredentials = ServiceAccountCredentials.from_json_keyfile_dict(\n    settings.JSON_KEYFILE_DICT, settings.SCOPE\n)\ngc = authorize(credentials)\n\n\nclass SpreadSheetClient:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(\n        self,\n        doc: Spreadsheet = gc.open_by_url(settings.SPREAD_SHEETS_URL),\n        sheets: dict[str, Worksheet] | None = None,\n    ) -> None:\n        if not hasattr(self, \"_initialized\"):\n            self._doc = doc\n            self._sheets = (\n                {\n                    \"contents\": self._doc.worksheet(\"contents\"),\n                    \"users\": self._doc.worksheet(\"users\"),\n                    \"logs\": self._doc.worksheet(\"logs\"),\n                    \"backup\": self._doc.worksheet(\"backup\"),\n                    \"bookmark\": self._doc.worksheet(\"bookmark\"),\n                    \"coffee_chat_proof\": self._doc.worksheet(\"coffee_chat_proof\"),\n                    \"point_histories\": self._doc.worksheet(\"point_histories\"),\n                    \"paper_plane\": self._doc.worksheet(\"paper_plane\"),\n                    \"subscriptions\": self._doc.worksheet(\"subscriptions\"),\n                }\n                if not sheets\n                else sheets\n            )\n            self._initialized = True\n\n    def get_values(self, sheet_name: str, column: str = \"\") -> list[list[str]]:\n        \"\"\"ìŠ¤í”„ë ˆë“œ ì‹œíŠ¸ë¡œ ë¶€í„° ê°’ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        if column:\n            return self._sheets[sheet_name].get_values(column)\n        else:\n            return self._sheets[sheet_name].get_all_values()\n\n    def backup(self, values: list[list[str]]) -> None:\n        \"\"\"ë°±ì—… ì‹œíŠ¸ì— ë°ì´í„°ë¥¼ ì—…ë¡œë“œ í•©ë‹ˆë‹¤.\"\"\"\n        # TODO: ì¶”í›„ ë°±ì—… ì‹œíŠ¸ë¥¼ ìë™ ìƒì„±í•  ìˆ˜ ìˆë„ë¡ ë³€ê²½ í•„ìš”\n        sheet = self._sheets[\"backup\"]\n        sheet.clear()\n        self._batch_append_rows(values, sheet, batch_size=1000)\n\n    def clear(self, sheet_name: str) -> None:\n        \"\"\"í•´ë‹¹ ì‹œíŠ¸ì˜ ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.\"\"\"\n        self._sheets[sheet_name].clear()\n\n    def upload(self, sheet_name: str, values: list[list[str]]) -> None:\n        \"\"\"í•´ë‹¹ ì‹œíŠ¸ì— ë°ì´í„°ë¥¼ í•˜ë‚˜ì”© ì—…ë¡œë“œ í•©ë‹ˆë‹¤.\"\"\"\n        sheet = self._sheets[sheet_name]\n        for value in values:\n            sheet.append_row(value)\n\n    def bulk_upload(self, sheet_name: str, values: list[list[str]]) -> None:\n        \"\"\"í•´ë‹¹ ì‹œíŠ¸ì— ë°ì´í„°ë¥¼ ì—…ë¡œë“œ í•©ë‹ˆë‹¤.\"\"\"\n        sheet = self._sheets[sheet_name]\n        self._batch_append_rows(values, sheet, batch_size=1000)\n\n    def update_bookmark(self, sheet_name: str, obj: StoreModel) -> None:\n        \"\"\"í•´ë‹¹ ê°ì²´ ì •ë³´ë¥¼ ì‹œíŠ¸ì— ì—…ë°ì´íŠ¸ í•©ë‹ˆë‹¤.\"\"\"\n        sheet = self._sheets[sheet_name]\n        records = sheet.get_all_records()\n\n        target_record = dict()\n        row_number = 2  # 1ì€ ì¸ë±ìŠ¤ê°€ 0ë¶€í„° ì‹œì‘í•˜ê¸° ë•Œë¬¸ì´ë©° ë‚˜ë¨¸ì§€ 1ì€ ì‹œë“œ í—¤ë” í–‰ì´ ìˆê¸° ë•Œë¬¸.\n        for idx, record in enumerate(records):\n            # TODO: ì¶”í›„ ì¡°ê±´ ë°”ê¾¸ê¸°\n            if obj.user_id == record[\"user_id\"] and obj.content_ts == str(  # type: ignore\n                record[\"content_ts\"]\n            ):\n                target_record = record\n                row_number += idx\n                break\n\n        values = obj.to_list_for_sheet()\n\n        if not target_record:\n            logger.error(f\"ì‹œíŠ¸ì— í•´ë‹¹ ê°’ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. {values}\")\n\n        sheet.update(f\"A{row_number}:G{row_number}\", [values])\n\n    def update_subscription(\n        self,\n        sheet_name: str,\n        subscription_dict: dict[str, Any],\n    ) -> None:\n        \"\"\"í•´ë‹¹ ê°ì²´ ì •ë³´ë¥¼ ì‹œíŠ¸ì— ì—…ë°ì´íŠ¸ í•©ë‹ˆë‹¤.\"\"\"\n        sheet = self._sheets[sheet_name]\n        records = sheet.get_all_records()\n\n        target_record = dict()\n        row_number = 2  # 1ì€ ì¸ë±ìŠ¤ê°€ 0ë¶€í„° ì‹œì‘í•˜ê¸° ë•Œë¬¸ì´ë©° ë‚˜ë¨¸ì§€ 1ì€ ì‹œë“œ í—¤ë” í–‰ì´ ìˆê¸° ë•Œë¬¸.\n        for idx, record in enumerate(records):\n            if subscription_dict[\"id\"] == record[\"id\"]:\n                target_record = record\n                row_number += idx\n                break\n\n        values = list(subscription_dict.values())\n\n        if not target_record:\n            logger.error(f\"ì‹œíŠ¸ì— í•´ë‹¹ ê°’ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. {values}\")\n\n        sheet.update(f\"A{row_number}:G{row_number}\", [values])\n\n    def update_user(self, sheet_name: str, values: list[str]) -> None:\n        \"\"\"ìœ ì € ì •ë³´ë¥¼ ì‹œíŠ¸ì— ì—…ë°ì´íŠ¸ í•©ë‹ˆë‹¤.\"\"\"\n        # TODO: ì¶”í›„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ í†µí•©í•˜ê¸°\n        sheet = self._sheets[sheet_name]\n        records = sheet.get_all_records()\n\n        target_record = dict()\n        row_number = 2  # 1ì€ ì¸ë±ìŠ¤ê°€ 0ë¶€í„° ì‹œì‘í•˜ê¸° ë•Œë¬¸ì´ë©° ë‚˜ë¨¸ì§€ 1ì€ ì‹œë“œ í—¤ë” í–‰ì´ ìˆê¸° ë•Œë¬¸.\n        for idx, record in enumerate(records):\n            if values[0] == record[\"user_id\"]:\n                target_record = record\n                row_number += idx\n                break\n\n        if not target_record:\n            logger.error(f\"ì‹œíŠ¸ì— í•´ë‹¹ ê°’ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. {values}\")\n\n        sheet.update(f\"A{row_number}:F{row_number}\", [values])\n\n    def _batch_append_rows(\n        self,\n        values: list[list[str]],\n        sheet: Worksheet,\n        batch_size: int,\n    ) -> None:\n        for i in range(0, len(values), batch_size):\n            batch = values[i : i + batch_size]\n            sheet.append_rows(batch)\n"}
{"type": "source_file", "path": "app/bigquery/__init__.py", "content": ""}
{"type": "source_file", "path": "app/exception.py", "content": "class BotException(Exception):\n    def __init__(self, message: str) -> None:\n        self.message = message\n        super().__init__(self.message)\n\n\nclass ClientException(Exception):\n    def __init__(self, message: str) -> None:\n        self.message = message\n        super().__init__(self.message)\n"}
{"type": "source_file", "path": "app/slack/events/__init__.py", "content": ""}
{"type": "source_file", "path": "app/__init__.py", "content": "import traceback\n\nfrom app.bigquery.client import BigqueryClient\nfrom app.bigquery.queue import BigqueryQueue\nfrom app.logging import logger\n\nfrom zoneinfo import ZoneInfo\nfrom app.client import SpreadSheetClient\nfrom app.slack.repositories import SlackRepository\nfrom fastapi import FastAPI, Request\nfrom apscheduler.triggers.interval import IntervalTrigger\nfrom app.config import settings\nfrom app.store import Store\nfrom app.api.views.contents import router as contents_router\nfrom app.api.views.login import router as login_router\nfrom app.api.views.paper_planes import router as paper_planes_router\nfrom app.api.views.point import router as point_router\nfrom app.api.views.inflearn import router as inflearn_router\nfrom app.api.views.message import router as message_router\nfrom slack_bolt.adapter.socket_mode.aiohttp import AsyncSocketModeHandler\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.slack.services.background import BackgroundService\n\n\nfrom slack_bolt.async_app import AsyncApp\nfrom app.slack.event_handler import app as slack_app\n\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.triggers.cron import CronTrigger\n\n\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\n        \"https://geultto-post-board.netlify.app\",\n        \"https://geultto-paper-plane.vercel.app\",\n        \"http://localhost:3000\",\n    ],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nslack_handler = AsyncSocketModeHandler(\n    app=slack_app,\n    app_token=settings.SLACK_APP_TOKEN,\n)\n\n\n@app.get(\"/\")\nasync def health(request: Request) -> bool:\n    return True\n\n\napp.include_router(contents_router, prefix=\"/v1\")\napp.include_router(login_router, prefix=\"/v1\")\napp.include_router(paper_planes_router, prefix=\"/v1\")\napp.include_router(point_router, prefix=\"/v1\")\napp.include_router(inflearn_router, prefix=\"/v1\")\napp.include_router(message_router, prefix=\"/v1\")\n\nif settings.ENV == \"prod\":\n    async_schedule = AsyncIOScheduler(daemon=True, timezone=ZoneInfo(\"Asia/Seoul\"))\n\n    @app.on_event(\"startup\")\n    async def startup():\n        # ì„œë²„ ì €ì¥ì†Œ ë™ê¸°í™”\n        store = Store(client=SpreadSheetClient())\n\n        # # ì—…ë¡œë“œ ìŠ¤ì¼€ì¤„ëŸ¬\n        async_schedule.add_job(\n            upload_queue, \"interval\", seconds=20, args=[store, slack_app]\n        )\n\n        # ë¡œê·¸ ì—…ë¡œë“œ ìŠ¤ì¼€ì¤„ëŸ¬\n        log_trigger = IntervalTrigger(minutes=1, timezone=ZoneInfo(\"Asia/Seoul\"))\n        async_schedule.add_job(upload_logs, trigger=log_trigger, args=[store])\n\n        # ë¹…ì¿¼ë¦¬ ì—…ë¡œë“œ ìŠ¤ì¼€ì¤„ëŸ¬\n        bigquery_trigger = IntervalTrigger(minutes=10, timezone=ZoneInfo(\"Asia/Seoul\"))\n        queue = BigqueryQueue(client=BigqueryClient())\n        async_schedule.add_job(upload_bigquery, trigger=bigquery_trigger, args=[queue])\n\n        # ë©¤ë²„ êµ¬ë… ì•Œë¦¼ ìŠ¤ì¼€ì¤„ëŸ¬: ë§¤ì¼ ì˜¤ì „ 8ì‹œ\n        subscribe_trigger = CronTrigger(\n            hour=8,\n            minute=0,\n            timezone=\"Asia/Seoul\",\n        )\n        async_schedule.add_job(\n            subscribe_job, trigger=subscribe_trigger, args=[slack_app]\n        )\n\n        # ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘\n        async_schedule.start()\n\n        # ìŠ¬ë™ ì†Œì¼“ ëª¨ë“œ ì‹¤í–‰\n        await slack_handler.connect_async()\n\n    async def upload_queue(store: Store, slack_app: AsyncApp) -> None:\n        \"\"\"ì—…ë¡œë“œ íì— ìˆëŠ” ë°ì´í„°ë¥¼ ì—…ë¡œë“œí•©ë‹ˆë‹¤.\"\"\"\n        try:\n            await store.upload_queue()\n        except Exception as e:\n            trace = traceback.format_exc()\n            error = f\"ì‹œíŠ¸ ì—…ë¡œë“œ ì¤‘ ì—ëŸ¬ê°€ ë°œìƒí–ˆì–´ìš”. {str(e)} {trace}\"\n            message = f\"ğŸ«¢: {error=} ğŸ•Šï¸: {trace=}\"\n            logger.error(message)\n\n            # ê´€ë¦¬ìì—ê²Œ ì—ëŸ¬ë¥¼ ì•Œë¦½ë‹ˆë‹¤.\n            await slack_app.client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=message,\n            )\n\n    async def upload_logs(store: Store) -> None:\n        store.upload_all(\"logs\")\n        store.initialize_logs()\n\n    async def upload_bigquery(queue: BigqueryQueue) -> None:\n        try:\n            await queue.upload()\n        except Exception as e:\n            trace = traceback.format_exc()\n            error = f\"ë¹…ì¿¼ë¦¬ ì—…ë¡œë“œ ì¤‘ ì—ëŸ¬ê°€ ë°œìƒí–ˆì–´ìš”. {str(e)} {trace}\"\n            message = f\"ğŸ«¢: {error=} ğŸ•Šï¸: {trace=}\"\n            logger.error(message)\n\n            await slack_app.client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=message,\n            )\n\n    async def subscribe_job(slack_app: AsyncApp) -> None:\n        slack_service = BackgroundService(repo=SlackRepository())\n        try:\n            await slack_service.prepare_subscribe_message_data()\n            await slack_service.send_subscription_messages(slack_app)\n        except Exception as e:\n            trace = traceback.format_exc()\n            error = f\"ë©¤ë²„ êµ¬ë… ì•Œë¦¼ ì „ì†¡ ì¤‘ ì—ëŸ¬ê°€ ë°œìƒí–ˆì–´ìš”. {str(e)} {trace}\"\n            message = f\"ğŸ«¢: {error=} ğŸ•Šï¸: {trace=}\"\n            logger.error(message)\n\n            await slack_app.client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=message,\n            )\n\n    @app.on_event(\"shutdown\")\n    async def shutdown():\n        # ì„œë²„ ì €ì¥ì†Œ ì—…ë¡œë“œ\n        await slack_handler.close_async()\n\n        store = Store(client=SpreadSheetClient())\n        await store.upload_queue()\n        store.upload_all(\"logs\")\n        store.initialize_logs()\n\n        queue = BigqueryQueue(client=BigqueryClient())\n        await queue.upload()\n\n        async_schedule.shutdown(wait=True)\n\nelse:\n\n    @app.on_event(\"startup\")\n    async def startup():\n        # ìŠ¬ë™ ì†Œì¼“ ëª¨ë“œ ì‹¤í–‰\n        await slack_handler.connect_async()\n"}
{"type": "source_file", "path": "app/api/repositories.py", "content": "import csv\nfrom app import models\nimport polars as pl\n\n\nclass ApiRepository:\n    def __init__(self) -> None: ...\n\n    def get_user(self, user_id: str) -> models.User | None:\n        \"\"\"íŠ¹ì • ìœ ì €ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n        df = pl.read_csv(\n            \"store/users.csv\", dtypes={\"deposit\": pl.Utf8}\n        )  # plì€ deposit ì„ intë¡œ ì¸ì‹í•˜ê¸° ë•Œë¬¸ì— strë¡œ ë³€ê²½\n        users = df.filter(pl.col(\"user_id\") == user_id).to_dicts()\n\n        return models.User(**users[0]) if users else None\n\n    def fetch_users(self) -> list[models.User]:\n        \"\"\"ëª¨ë“  ìœ ì €ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n        df = pl.read_csv(\"store/users.csv\", dtypes={\"deposit\": pl.Utf8})\n        return [models.User(**row) for row in df.to_dicts()]\n\n    def fetch_sent_paper_planes(\n        self,\n        sender_id: str,\n        offset: int,\n        limit: int,\n    ) -> tuple[int, list[models.PaperPlane]]:\n        \"\"\"ìœ ì €ê°€ ë³´ë‚¸ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        df = pl.read_csv(\"store/paper_plane.csv\")\n        data = df.filter(pl.col(\"sender_id\") == sender_id).sort(\n            \"created_at\", descending=True\n        )\n        count = len(data)\n        paper_planes = data.slice(offset, limit).to_dicts()\n        return count, [models.PaperPlane(**paper_plane) for paper_plane in paper_planes]\n\n    def fetch_received_paper_planes(\n        self,\n        receiver_id: str,\n        offset: int,\n        limit: int,\n    ) -> tuple[int, list[models.PaperPlane]]:\n        \"\"\"ìœ ì €ê°€ ë°›ì€ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        df = pl.read_csv(\"store/paper_plane.csv\")\n        data = df.filter(pl.col(\"receiver_id\") == receiver_id).sort(\n            \"created_at\", descending=True\n        )\n        count = len(data)\n        paper_planes = data.slice(offset, limit).to_dicts()\n        return count, [models.PaperPlane(**paper_plane) for paper_plane in paper_planes]\n\n    def fetch_paper_planes(self, sender_id: str) -> list[models.PaperPlane]:\n        \"\"\"ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/paper_plane.csv\") as f:\n            reader = csv.DictReader(f)\n            paper_planes = [\n                models.PaperPlane(**paper_plane)  # type: ignore\n                for paper_plane in reader\n                if paper_plane[\"sender_id\"] == sender_id\n            ]\n            return paper_planes\n\n    def create_paper_plane(self, paper_plane: models.PaperPlane) -> None:\n        \"\"\"ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        with open(\"store/paper_plane.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(paper_plane.to_list_for_csv())\n"}
{"type": "source_file", "path": "app/constants.py", "content": "import datetime\nfrom enum import Enum\n\n\nURL_REGEX = r\"((http|https):\\/\\/)?[a-zA-Z0-9.-]+(\\.[a-zA-Z]{2,})\"\nMAX_PASS_COUNT = 2\nDUE_DATES = [  # ê¸€ë˜ ì‹œì‘ì¼ ì„ í¬í•¨í•œ ì˜¤ë¦„ì°¨ìˆœ ë§ˆê°ì¼ ë¦¬ìŠ¤íŠ¸\n    datetime.datetime(2024, 9, 29).date(),  # 0íšŒì°¨ - ê¸€ë˜ 10ê¸° ì‹œì‘\n    datetime.datetime(2024, 10, 13).date(),  # 1íšŒì°¨\n    datetime.datetime(2024, 10, 27).date(),  # 2íšŒì°¨\n    datetime.datetime(2024, 11, 10).date(),  # 3íšŒì°¨\n    datetime.datetime(2024, 11, 24).date(),  # 4íšŒì°¨\n    # datetime.datetime(2024, 12, 8).date(),  # ë¹„ìƒê³„ì—„ìœ¼ë¡œ ì¸í•œ 2ì£¼ ì—°ì¥\n    datetime.datetime(2024, 12, 22).date(),  # 5íšŒì°¨\n    datetime.datetime(2025, 1, 5).date(),  # 6íšŒì°¨\n    datetime.datetime(2025, 1, 19).date(),  # 7íšŒì°¨\n    datetime.datetime(2025, 2, 2).date(),  # 8íšŒì°¨\n    datetime.datetime(2025, 2, 16).date(),  # 9íšŒì°¨\n    datetime.datetime(2025, 3, 2).date(),  # 10íšŒì°¨\n    datetime.datetime(2025, 3, 16).date(),  # 11íšŒì°¨\n    datetime.datetime(2025, 3, 30).date(),  # 12íšŒì°¨\n    datetime.datetime(2025, 4, 13).date(),  # ì¶”ê°€íšŒì°¨(ì„ì‹œ)\n]\n\n\nclass ContentCategoryEnum(str, Enum):\n    CODETREE = \"ì½”ë“œíŠ¸ë¦¬ x ê¸€ë˜ ë¸”ë¡œê·¸ ì±Œë¦°ì§€ 2ê¸°\"\n    GILBUT = \"ê¸¸ë²— ì±… ë¦¬ë·°\"\n    HANBIT = \"í•œë¹›ë¯¸ë””ì–´ ì±… ë¦¬ë·°\"\n    PROJECT = \"í”„ë¡œì íŠ¸\"\n    TECH = \"ê¸°ìˆ  & ì–¸ì–´\"\n    CULTURE = \"ì¡°ì§ & ë¬¸í™”\"\n    JOB = \"ì·¨ì¤€ & ì´ì§\"\n    DAILY = \"ì¼ìƒ & ìƒê° & íšŒê³ \"\n    ETC = \"ê¸°íƒ€\"\n\n\nclass ContentSortEnum(str, Enum):\n    DT = \"dt\"\n    RELEVANCE = \"relevance\"\n    # LIKE = \"like\" # TODO: ì¶”í›„ ì¶”ê°€í•˜ê¸°\n\n\nremind_message = \"\"\"ğŸ‘‹ ì•ˆë…•í•˜ì„¸ìš”! ì˜¤ëŠ˜ì€ ê¸€ ì œì¶œ ë§ˆê°ì¼ì´ì—ìš”.\nì§€ë‚œ 2ì£¼ ë™ì•ˆ ë°°ìš°ê³  ê²½í—˜í•œ ê²ƒë“¤ì„ ìì •ê¹Œì§€ ë‚˜ëˆ ì£¼ì„¸ìš”.\n{user_name} ë‹˜ì˜ ì´ì•¼ê¸°ë¥¼ ê¸°ë‹¤ë¦´ê²Œìš”!ğŸ™‚\"\"\"\n\n\n# fmt: off\n\n# paper_plane_color_maps = [\n#     {\"color_label\": \"fiery_red\", \"bg_color\": \"#FF4500\", \"text_color\": \"#FFFFFF\"},  # ë¶ˆê½ƒ ê°™ì€ ë¹¨ê°„ìƒ‰\n#     {\"color_label\": \"fresh_green\", \"bg_color\": \"#32CD32\", \"text_color\": \"#FFFFFF\"},  # ì‹±ê·¸ëŸ¬ìš´ ì´ˆë¡ìƒ‰\n#     {\"color_label\": \"sky_blue\", \"bg_color\": \"#1E90FF\", \"text_color\": \"#FFFFFF\"},  # ë§‘ì€ í•˜ëŠ˜ìƒ‰\n#     {\"color_label\": \"bright_gold\", \"bg_color\": \"#FFD700\", \"text_color\": \"#000000\"},  # ë°ì€ ê¸ˆìƒ‰\n#     {\"color_label\": \"deep_violet\", \"bg_color\": \"#8A2BE2\", \"text_color\": \"#FFFFFF\"},  # ì§„í•œ ë³´ë¼ìƒ‰\n#     {\"color_label\": \"ripe_tomato\", \"bg_color\": \"#FF6347\", \"text_color\": \"#FFFFFF\"},  # ì˜ ìµì€ í† ë§ˆí† ìƒ‰\n#     {\"color_label\": \"cool_steelblue\", \"bg_color\": \"#4682B4\", \"text_color\": \"#FFFFFF\"},  # ì°¨ê°€ìš´ ìŠ¤í‹¸ë¸”ë£¨\n#     {\"color_label\": \"soft_slateblue\", \"bg_color\": \"#6A5ACD\", \"text_color\": \"#FFFFFF\"},  # ë¶€ë“œëŸ¬ìš´ ìŠ¬ë ˆì´íŠ¸ë¸”ë£¨\n#     {\"color_label\": \"pastel_chartreuse\", \"bg_color\": \"#A9F2A5\", \"text_color\": \"#2F4F4F\"},  # íŒŒìŠ¤í…” ì°¨íŠ¸ë ˆì¦ˆ\n#     {\"color_label\": \"vivid_deeppink\", \"bg_color\": \"#FF1493\", \"text_color\": \"#FFFFFF\"},  # ì„ ëª…í•œ ë”¥í•‘í¬\n#     {\"color_label\": \"blush_rosybrown\", \"bg_color\": \"#BC8F8F\", \"text_color\": \"#FFFFFF\"},  # ë¸”ëŸ¬ì‰¬ ë¡œì§€ë¸Œë¼ìš´\n#     {\"color_label\": \"peach_silver\", \"bg_color\": \"#FFDAB9\", \"text_color\": \"#8B4513\"},  # ë³µìˆ­ì•„ë¹› ì‹¤ë²„\n#     {\"color_label\": \"muted_seagreen\", \"bg_color\": \"#8FBC8F\", \"text_color\": \"#FFFFFF\"},  # ì°¨ë¶„í•œ ë°”ë‹¤ì´ˆë¡ìƒ‰\n#     {\"color_label\": \"soft_lightcoral\", \"bg_color\": \"#F08080\", \"text_color\": \"#FFFFFF\"},  # ë¶€ë“œëŸ¬ìš´ ë¼ì´íŠ¸ì½”ë„\n#     {\"color_label\": \"lavender_gray\", \"bg_color\": \"#E6E6FA\", \"text_color\": \"#4B0082\"},  # ë¼ë²¤ë” ê·¸ë ˆì´\n#     {\"color_label\": \"sunset_orange\", \"bg_color\": \"#FF7F50\", \"text_color\": \"#FFFFFF\"},  # ì„ì–‘ ì˜¤ë Œì§€\n#     {\"color_label\": \"ocean_teal\", \"bg_color\": \"#008080\", \"text_color\": \"#FFFFFF\"},  # ë°”ë‹¤ ì²­ë¡ìƒ‰\n#     {\"color_label\": \"midnight_blue\", \"bg_color\": \"#191970\", \"text_color\": \"#FFFFFF\"},  # ìì •ì˜ íŒŒë€ìƒ‰\n#     {\"color_label\": \"buttercup_yellow\", \"bg_color\": \"#FFDD44\", \"text_color\": \"#000000\"},  # ë²„í„°ì»µ ì˜ë¡œìš°\n#     {\"color_label\": \"rosewood\", \"bg_color\": \"#65000B\", \"text_color\": \"#FFFFFF\"}  # ë¡œì¦ˆìš°ë“œ\n# ]\n\n\n# ë°œë Œíƒ€ì¸ ë²„ì „\npaper_plane_color_maps = [\n    {\"color_label\": \"valentine_1\", \"bg_color\": \"#BC2026\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_2\", \"bg_color\": \"#862A2A\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_3\", \"bg_color\": \"#2A1010\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_4\", \"bg_color\": \"#D48E52\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_5\", \"bg_color\": \"#774A23\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_6\", \"bg_color\": \"#291707\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_7\", \"bg_color\": \"#FFEBBD\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_8\", \"bg_color\": \"#F0C86D\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_9\", \"bg_color\": \"#DC9E0D\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_10\", \"bg_color\": \"#BCA0C3\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_11\", \"bg_color\": \"#7E5389\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_12\", \"bg_color\": \"#99A799\", \"text_color\": \"#E2FAE2\"},\n    {\"color_label\": \"valentine_13\", \"bg_color\": \"#EAA4C8\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_14\", \"bg_color\": \"#C26D99\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_15\", \"bg_color\": \"#913263\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_16\", \"bg_color\": \"#FFB7CF\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_17\", \"bg_color\": \"#FF95AF\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_18\", \"bg_color\": \"#FF5680\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_19\", \"bg_color\": \"#80C4BC\", \"text_color\": \"#2C2424\"},\n    {\"color_label\": \"valentine_20\", \"bg_color\": \"#49ABA0\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_21\", \"bg_color\": \"#1E7D72\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_22\", \"bg_color\": \"#17635A\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_23\", \"bg_color\": \"#223943\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_24\", \"bg_color\": \"#264A28\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_25\", \"bg_color\": \"#6F9370\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_26\", \"bg_color\": \"#2C612D\", \"text_color\": \"#EEE1E1\"},\n    {\"color_label\": \"valentine_27\", \"bg_color\": \"#0C380D\", \"text_color\": \"#EEE1E1\"}\n]\n\n# # í¬ë¦¬ìŠ¤ë§ˆìŠ¤ ë²„ì „\n# paper_plane_color_maps = [\n#     {\"color_label\": \"christmas_1\", \"bg_color\": \"#BC2026\", \"text_color\": \"#FFCCCC\"},  # ë¶ˆê½ƒ ê°™ì€ ë¹¨ê°„ìƒ‰\n#     {\"color_label\": \"christmas_2\", \"bg_color\": \"#118911\", \"text_color\": \"#E2FAE2\"},  # ì‹±ê·¸ëŸ¬ìš´ ì´ˆë¡ìƒ‰\n#     {\"color_label\": \"christmas_3\", \"bg_color\": \"#EBB84E\", \"text_color\": \"#252525\"},  # ë§‘ì€ í•˜ëŠ˜ìƒ‰\n#     {\"color_label\": \"christmas_4\", \"bg_color\": \"#DB7F3E\", \"text_color\": \"#F2DED0\"},  # ë°ì€ ê¸ˆìƒ‰\n#     {\"color_label\": \"christmas_5\", \"bg_color\": \"#74528F\", \"text_color\": \"#F5EBFC\"},  # ì§„í•œ ë³´ë¼ìƒ‰\n#     {\"color_label\": \"christmas_6\", \"bg_color\": \"#874544\", \"text_color\": \"#F7E3E3\"},  # ì˜ ìµì€ í† ë§ˆí† ìƒ‰\n# ]\n\n# fmt: on\n\n\n# 10ê¸° 1_ì±„ë„ ì•„ì´ë”” ìƒìˆ˜\nPRIMARY_CHANNEL = [\n    \"C07P09BTQAW\",  # 1_ëŒ€ë‚˜ë¬´ìˆ²_ê³ ë¯¼_ê³µìœ \n    \"C07PXJR6KRP\",  # 1_ì†Œëª¨ì„_í™ë³´\n    \"C07PD016V7T\",  # 1_ìë£Œ_ê³µìœ \n    \"C07NKNYTFN3\",  # 1_ììœ _í™ë³´\n    \"C07P09N1XM0\",  # 1_ììœ ë¡œìš´ë‹´ì†Œ\n    \"C07PP3V0524\",  # 1_íë ˆì´ì…˜\n    \"C07PP3A5GGG\",  # 1_ì˜¨ë¼ì¸_ëª¨ê°ê¸€\n    \"C07NKNP2RSB\",  # 1_ìê¸°ì†Œê°œ\n    \"C07PG0G4RQD\",  # 1_ê°ì‚¬ëŠ”_ë¹„í–‰ê¸°ë¥¼_íƒ€ê³ \n    \"C07NTLWAWR4\",  # 1_ì»¤í”¼ì±—_ë˜ëŠ”_ëª¨ì„_í›„ê¸°\n    \"C07NKP4M69M\",  # 1_ì»¤í”¼ì±—_ë²ˆê°œ_ëª¨ê°ê¸€_í•˜ì‹¤_ë¶„\n    \"C08BCU9C5BN\",  # 1_ê¸€ë˜_ì»¤í”¼ì±—_ì¡°_ê³µìœ \n    \"C05J87UPC3F\",  # dev ì±„ë„ 1 (ë¡œì»¬ í…ŒìŠ¤íŠ¸ ì±„ë„)\n    \"C07PD0VMHJM\",  # dev ì±„ë„ 2 (ë˜ë´‡ í¬ë£¨ ì±„ë„)\n]\n\n\nBOT_IDS = [\n    \"U07PJ6J7FFV\",\n    \"U07P0BB4YKV\",\n    \"U07PFJCHHFF\",\n    \"U07PK8CLGKW\",\n    \"U07P8E69V3N\",\n    \"U07PB8HF4V8\",\n    \"U07PAMU09AS\",\n    \"U07PSF2PKKK\",\n    \"U07PK195U74\",\n    \"U04GVDM0R4Y\",\n    \"USLACKBOT\",\n]\n"}
{"type": "source_file", "path": "app/api/views/message.py", "content": "from typing import Any\nfrom starlette import status\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom app.api.auth import current_user\nfrom app.api.dto import SendMessageDTO\nfrom app.models import SimpleUser\nfrom app.config import settings\nfrom app.slack.event_handler import app as slack_app\n\n\nrouter = APIRouter()\n\n\n@router.post(\n    \"/send-messages\",\n    status_code=status.HTTP_200_OK,\n)\nasync def send_messages(\n    dto_list: list[SendMessageDTO],\n    user: SimpleUser = Depends(current_user),\n) -> dict[str, Any]:\n    \"\"\"ë©”ì‹œì§€ë¥¼ ë³´ëƒ…ë‹ˆë‹¤.\"\"\"\n    if user.user_id not in settings.ADMIN_IDS:\n        raise HTTPException(status_code=403, detail=\"ë©”ì‹œì§€ ì „ì†¡ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.\")\n\n    for dto in dto_list:\n        await slack_app.client.chat_postMessage(\n            channel=dto.channel_id,\n            text=dto.message,\n        )\n\n    return {\"message\": \"ë©”ì‹œì§€ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.\"}\n"}
{"type": "source_file", "path": "app/models.py", "content": "from __future__ import annotations\n\nfrom abc import abstractmethod\n\nfrom enum import Enum\nfrom zoneinfo import ZoneInfo\nfrom pydantic import BaseModel, Field, field_validator\nimport datetime\nfrom app.constants import DUE_DATES, MAX_PASS_COUNT\nfrom app.exception import BotException\n\nfrom app.utils import generate_unique_id, tz_now, tz_now_to_str\n\n\nclass User(BaseModel):\n    user_id: str  # ìŠ¬ë™ ì•„ì´ë””\n    name: str  # ì´ë¦„\n    channel_name: str  # ì½”ì–´ì±„ë„ ì´ë¦„\n    channel_id: str  # ì½”ì–´ì±„ë„ ì•„ì´ë””\n    intro: str  # ìê¸°ì†Œê°œ\n    deposit: str = \"\"  # ì˜ˆì¹˜ê¸ˆ\n    cohort: str = \"\"  # ê¸°ìˆ˜\n    contents: list[Content] = []  # ì œì¶œí•œ ì½˜í…ì¸ \n\n    @field_validator(\"contents\", mode=\"before\")\n    def get_contents(cls, v: list[Content]) -> list[Content]:\n        \"\"\"ì½˜í…ì¸ ë¥¼ ìƒì„±ì¼ì‹œ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        return sorted(v, key=lambda content: content.dt_)\n\n    @property\n    def pass_count(self) -> int:\n        \"\"\"pass íšŸìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        return len([content for content in self.contents if content.type == \"pass\"])\n\n    @property\n    def is_prev_pass(self) -> bool:\n        \"\"\"ì§ì „ì— pass í–ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        try:\n            recent_content = self.recent_content\n        except Exception:\n            return False\n\n        if recent_content.type != \"pass\":\n            return False\n\n        return self._is_prev_pass(recent_content)\n\n    def _is_prev_pass(self, recent_content: Content) -> bool:\n        \"\"\"ì „ì „íšŒì°¨ ë§ˆê°ì¼ ì´ˆê³¼, í˜„ì¬ ë‚ ì§œ ì´í•˜ ì‚¬ì´ì— pass í–ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        now_date = tz_now().date()\n        second_latest_due_date = DUE_DATES[-2]\n        for i, due_date in enumerate(DUE_DATES):\n            if now_date <= due_date:\n                second_latest_due_date = DUE_DATES[i - 2]\n                break\n        return second_latest_due_date < recent_content.date <= now_date\n\n    @property\n    def recent_content(self) -> Content:\n        \"\"\"ìµœê·¼ ì½˜í…ì¸ ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        return self.contents[-1]\n\n    @property\n    def content_urls(self) -> list[str]:\n        \"\"\"ìœ ì €ì˜ ëª¨ë“  ì½˜í…ì¸  url ì„ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        return [content.content_url for content in self.contents]\n\n    def fetch_contents(self, descending: bool = False) -> list[Content]:\n        \"\"\"ì½˜í…ì¸ ë¥¼ ìƒì„±ì¼ì‹œ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        if descending:\n            return sorted(self.contents, key=lambda content: content.dt_, reverse=True)\n        return self.contents\n\n    def get_due_date(self) -> tuple[int, datetime.date]:\n        \"\"\"í˜„ì¬ íšŒì°¨ì™€ ë§ˆê°ì¼ì„ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        now_date = tz_now().date()\n        for i, due_date in enumerate(DUE_DATES):\n            if now_date <= due_date:\n                round = i\n                return round, due_date\n        raise BotException(\"ì§€ê¸ˆì€ ê¸€ë˜ ê¸€ ì œì¶œ ê¸°ê°„ì´ ì•„ë‹ˆì—ìš”.\")\n\n    @property\n    def is_submit(self) -> bool:\n        \"\"\"í˜„ì¬ íšŒì°¨ì˜ ì œì¶œì—¬ë¶€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        try:\n            recent_content = self.recent_content\n        except Exception:\n            return False\n\n        if recent_content.type != \"submit\":\n            return False\n\n        now_date = tz_now().date()\n        for i, due_date in enumerate(DUE_DATES):\n            if now_date <= due_date:  # í˜„ì¬ ë‚ ì§œê°€ ë³´ë‹¤ ê°™ê±°ë‚˜ í¬ë©´ í˜„ì¬ ë§ˆê°ì¼ì´ë‹¤.\n                # í˜„ì¬ ë§ˆê°ì¼ì˜ ì§ì „ ë§ˆê°ì¼ì„ êµ¬í•œë‹¤.\n                latest_due_date = DUE_DATES[i - 1]\n                break\n\n        # ìµœê·¼ ì œì¶œí•œ ì½˜í…ì¸ ì˜ ë‚ ì§œê°€ ì§ì „ ë§ˆê°ì¼ ì´ˆê³¼, í˜„ì¬ ë‚ ì§œ ì´í•˜ ë¼ë©´ ì œì¶œí–ˆë‹¤ê³  íŒë‹¨í•œë‹¤.\n        return latest_due_date < recent_content.date <= now_date\n\n    def get_submit_status(self) -> dict[int, str]:\n        \"\"\"í˜„ì¬ íšŒì°¨ëŠ” ì œì™¸í•œ íšŒì°¨ë³„ ì œì¶œ ì—¬ë¶€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        submit_status = {}\n        for i, due_date in enumerate(DUE_DATES):\n            # 0íšŒì°¨ëŠ” ì‹œì‘ì¼ì´ë¯€ë¡œ ì œì™¸í•œë‹¤.\n            if i == 0:\n                continue\n\n            # í˜„ì¬ íšŒì°¨ëŠ” ì œì¶œ ì—¬ë¶€ë¥¼ íŒë‹¨í•˜ì§€ ì•ŠëŠ”ë‹¤.\n            if due_date >= tz_now().date():\n                break\n\n            # ê¸°ë³¸ê°’ì€ ë¯¸ì œì¶œ\n            submit_status[i] = \"ë¯¸ì œì¶œ\"\n\n            # ì½˜í…ì¸ ì˜ ì œì¶œ ë‚ ì§œê°€ ì§ì „ ë§ˆê°ì¼ ì´ˆê³¼, ë§ˆê°ì¼ ì´í•˜ ë¼ë©´ ì œì¶œí–ˆë‹¤ê³  íŒë‹¨í•œë‹¤.\n            for content in self.fetch_contents():\n                latest_due_date = DUE_DATES[i - 1]\n                if latest_due_date < content.date <= due_date:\n                    if content.type == \"submit\":\n                        submit_status[i] = \"ì œì¶œ\"\n                    elif content.type == \"pass\":\n                        submit_status[i] = \"íŒ¨ìŠ¤\"\n                    else:\n                        submit_status[i] = \"ë¯¸ì œì¶œ\"\n\n        return submit_status\n\n    def get_continuous_submit_count(self) -> int:\n        \"\"\"ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì—°ì†ìœ¼ë¡œ ì œì¶œí•œ íšŸìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        count = 0\n        submit_status = self.get_submit_status()\n        for _, v in sorted(submit_status.items(), reverse=True):\n            if v == \"ì œì¶œ\":\n                count += 1\n            elif v == \"íŒ¨ìŠ¤\":  # íŒ¨ìŠ¤ëŠ” ì—°ì† ì œì¶œ íšŸìˆ˜ì— í¬í•¨í•˜ì§€ ì•ŠëŠ”ë‹¤.\n                continue\n            else:  # ë¯¸ì œì¶œì€ ì—°ì† ì œì¶œ íšŸìˆ˜ë¥¼ ëŠëŠ”ë‹¤.\n                break\n        return count\n\n    def check_channel(self, channel_id: str) -> None:\n        \"\"\"ì½”ì–´ ì±„ë„ì´ ì¼ì¹˜í•˜ëŠ”ì§€ ì²´í¬í•©ë‹ˆë‹¤.\"\"\"\n        if self.channel_id == \"ALL\":\n            return\n        if self.channel_id != channel_id:\n            raise BotException(\n                f\"{self.name} ë‹˜ì˜ ì½”ì–´ ì±„ë„ <#{self.channel_id}> ì—ì„œ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.\"\n            )\n\n    @property\n    def submission_guide_message(self) -> str:\n        \"\"\"ì œì¶œ ëª¨ë‹¬ ê°€ì´ë“œ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        round, due_date = self.get_due_date()\n        guide_message = f\"í˜„ì¬ íšŒì°¨ëŠ” {round}íšŒì°¨, ë§ˆê°ì¼ì€ {due_date} ì´ì—ìš”.\"\n        if self.is_submit:\n            guide_message += f\"\\n({self.name} ë‹˜ì€ ì´ë¯¸ {round}íšŒì°¨ ê¸€ì„ ì œì¶œí–ˆì–´ìš”)\"\n        else:\n            guide_message += (\n                f\"\\n({self.name} ë‹˜ì€ ì•„ì§ {round}íšŒì°¨ ê¸€ì„ ì œì¶œí•˜ì§€ ì•Šì•˜ì–´ìš”)\"\n            )\n        guide_message += (\n            f\"\\nì œì¶œ ë©”ì‹œì§€ëŠ” ì½”ì–´ ì±„ë„ì¸ <#{self.channel_id}> ì— í‘œì‹œë©ë‹ˆë‹¤.\"\n        )\n        return guide_message\n\n    def check_pass(self) -> None:\n        \"\"\"pass ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ë¥¼ ì²´í¬í•©ë‹ˆë‹¤.\"\"\"\n        if self.pass_count >= MAX_PASS_COUNT:\n            message = \"ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” pass ê°€ ì—†ì–´ìš”.\"\n            raise BotException(message)\n        if self.is_prev_pass:\n            message = (\n                \"ì§ì „ íšŒì°¨ì— pass ë¥¼ ì‚¬ìš©í–ˆê¸° ë•Œë¬¸ì— ì—°ì†ìœ¼ë¡œ pass ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ì–´ìš”.\"\n            )\n            raise BotException(message)\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.user_id,\n            self.channel_name,\n            self.name,\n            self.channel_id,\n            self.intro,\n            self.cohort,\n        ]\n\n\nclass SimpleUser(BaseModel):\n    user_id: str\n    name: str\n    channel_name: str\n    channel_id: str\n    intro: str\n    cohort: str\n\n\nclass StoreModel(BaseModel):\n    ...\n\n    @abstractmethod\n    def to_list_for_csv(self) -> list[str]:\n        \"\"\"csv íŒŒì¼ì— ì“°ê¸° ìœ„í•œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        ...\n\n    @abstractmethod\n    def to_list_for_sheet(self) -> list[str]:\n        \"\"\"êµ¬ê¸€ ì‹œíŠ¸ì— ì“°ê¸° ìœ„í•œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        ...\n\n\nclass Content(StoreModel):\n    dt: str = Field(default_factory=tz_now_to_str)\n    user_id: str\n    username: str\n    description: str = \"\"\n    type: str\n    content_url: str = \"\"\n    title: str = \"\"\n    category: str = \"\"\n    tags: str = \"\"\n    curation_flag: str = \"N\"  # \"Y\", \"N\"\n    ts: str = \"\"\n    feedback_intensity: str = \"HOT\"  # \"MILD\", \"HOT\", \"FIRE\", \"DIABLO\"\n\n    def __hash__(self) -> int:\n        return hash(self.ts)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Content):\n            return NotImplemented\n        return self.ts == other.ts\n\n    @property\n    def dt_(self) -> datetime.datetime:\n        \"\"\"ìƒì„±ì¼ì‹œë¥¼ datetime ê°ì²´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        return datetime.datetime.strptime(self.dt, \"%Y-%m-%d %H:%M:%S\").replace(\n            tzinfo=ZoneInfo(\"Asia/Seoul\")\n        )\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"ìƒì„±ì¼ì‹œë¥¼ date ê°ì²´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        return self.dt_.date()\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.user_id,\n            self.username,\n            self.title,\n            self.content_url,\n            self.dt,\n            self.category,\n            self.description,\n            self.type,\n            self.tags,\n            self.curation_flag,\n            self.ts,\n            self.feedback_intensity,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.user_id,\n            self.username,\n            self.title,\n            self.content_url,\n            self.dt,\n            self.category,\n            self.description,\n            self.type,\n            self.tags,\n            self.curation_flag,\n            self.ts,\n            self.feedback_intensity,\n        ]\n\n    def get_round(self) -> int:\n        \"\"\"ì»¨í…ì¸ ì˜ íšŒì°¨ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        for i, due_date in enumerate(DUE_DATES):\n            if self.date <= due_date:\n                return i\n        raise BotException(\"ê¸€ë˜ í™œë™ ê¸°ê°„ì´ ì•„ë‹ˆì—ìš”.\")\n\n    @classmethod\n    def fieldnames(self) -> list[str]:\n        return [\n            \"user_id\",\n            \"username\",\n            \"title\",\n            \"content_url\",\n            \"dt\",\n            \"category\",\n            \"description\",\n            \"type\",\n            \"tags\",\n            \"curation_flag\",\n            \"ts\",\n            \"feedback_intensity\",\n        ]\n\n\nclass BookmarkStatusEnum(str, Enum):\n    ACTIVE = \"ACTIVE\"\n    DELETED = \"DELETED\"\n\n\nclass Bookmark(StoreModel):\n    user_id: str\n    content_user_id: str\n    content_ts: str  # content fk ì—­í• ì„ í•œë‹¤.\n    note: str = \"\"\n    status: BookmarkStatusEnum = BookmarkStatusEnum.ACTIVE\n    created_at: str = Field(default_factory=tz_now_to_str)\n    updated_at: str = Field(default_factory=tz_now_to_str)\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.user_id,\n            self.content_user_id,\n            self.content_ts,\n            self.note,\n            self.status,\n            self.created_at,\n            self.updated_at,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.user_id,\n            self.content_user_id,\n            self.content_ts,\n            self.note,\n            self.status,\n            self.created_at,\n            self.updated_at,\n        ]\n\n\nclass CoffeeChatProof(StoreModel):\n    ts: str  # id\n    thread_ts: str = \"\"  # ìŠ¤ë ˆë“œë¡œ ì¸ì¦í•œ ê²½ìš° ìƒìœ„ id ì¶”ê°€\n    user_id: str\n    text: str\n    image_urls: str = \"\"  # url1,url2,url3 í˜•íƒœ\n    selected_user_ids: str = \"\"  # id1,id2,id3 í˜•íƒœ\n    participant_call_thread_ts: str = \"\"  # ì»¤í”¼ì±— ì°¸ì—¬ì í˜¸ì¶œ ìŠ¤ë ˆë“œ id\n    created_at: str = Field(default_factory=tz_now_to_str)\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.ts,\n            self.thread_ts,\n            self.user_id,\n            self.text,\n            self.image_urls,\n            self.selected_user_ids,\n            self.participant_call_thread_ts,\n            self.created_at,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.ts,\n            self.thread_ts,\n            self.user_id,\n            self.text,\n            self.image_urls,\n            self.selected_user_ids,\n            self.participant_call_thread_ts,\n            self.created_at,\n        ]\n\n    @classmethod\n    def fieldnames(self) -> list[str]:\n        return [\n            \"ts\",\n            \"thread_ts\",\n            \"user_id\",\n            \"text\",\n            \"image_urls\",\n            \"selected_user_ids\",\n            \"participant_call_thread_ts\",\n            \"created_at\",\n        ]\n\n\nclass PointCategory(str, Enum):\n    WRITING = \"ê¸€ì“°ê¸°\"\n    NETWORKING = \"ë„¤íŠ¸ì›Œí¬\"\n    USER_TO_USER = \"ìœ ì € ê°„\"\n    OTHER = \"ê¸°íƒ€\"\n\n\nclass PointHistory(BaseModel):\n    id: str = Field(default_factory=generate_unique_id)\n    user_id: str\n    reason: str\n    point: int\n    category: PointCategory | str\n    created_at: str = Field(default_factory=tz_now_to_str)\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.id,\n            self.user_id,\n            self.reason,\n            str(self.point),\n            self.category,\n            self.created_at,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.id,\n            self.user_id,\n            self.reason,\n            str(self.point),\n            self.category,\n            self.created_at,\n        ]\n\n    @classmethod\n    def fieldnames(self) -> list[str]:\n        return [\n            \"id\",\n            \"user_id\",\n            \"reason\",\n            \"point\",\n            \"category\",\n            \"created_at\",\n        ]\n\n\nclass PaperPlane(StoreModel):\n    id: str = Field(default_factory=generate_unique_id)\n    sender_id: str\n    sender_name: str\n    receiver_id: str\n    receiver_name: str\n    text: str\n    text_color: str\n    bg_color: str\n    color_label: str\n    created_at: str = Field(default_factory=tz_now_to_str)\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.id,\n            self.sender_id,\n            self.sender_name,\n            self.receiver_id,\n            self.receiver_name,\n            self.text,\n            self.text_color,\n            self.bg_color,\n            self.color_label,\n            self.created_at,\n        ]\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.id,\n            self.sender_id,\n            self.sender_name,\n            self.receiver_id,\n            self.receiver_name,\n            self.text,\n            self.text_color,\n            self.bg_color,\n            self.color_label,\n            self.created_at,\n        ]\n\n\nclass SubscriptionStatusEnum(str, Enum):\n    ACTIVE = \"ACTIVE\"\n    CANCELED = \"CANCELED\"\n\n\nclass Subscription(StoreModel):\n    id: str = Field(default_factory=generate_unique_id)\n    user_id: str\n    target_user_id: str\n    target_user_channel: str\n    status: SubscriptionStatusEnum = SubscriptionStatusEnum.ACTIVE\n    created_at: str = Field(default_factory=tz_now_to_str)\n    updated_at: str = \"\"\n\n    def to_list_for_sheet(self) -> list[str]:\n        return [\n            self.id,\n            self.user_id,\n            self.target_user_id,\n            self.target_user_channel,\n            self.status,\n            self.created_at,\n            self.updated_at,\n        ]\n\n    def to_list_for_csv(self) -> list[str]:\n        return [\n            self.id,\n            self.user_id,\n            self.target_user_id,\n            self.target_user_channel,\n            self.status,\n            self.created_at,\n            self.updated_at,\n        ]\n"}
{"type": "source_file", "path": "app/slack/events/community.py", "content": "import asyncio\nimport requests\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom app.exception import BotException\nfrom app.models import User\nfrom app.slack_notification import send_point_noti_message\nfrom app.slack.services.base import SlackService\nfrom app.slack.services.point import PointService\nfrom app.slack.types import (\n    ActionBodyType,\n    CommandBodyType,\n    MessageBodyType,\n    ViewBodyType,\n)\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\nfrom slack_sdk.models.views import View\nfrom slack_sdk.models.blocks import (\n    SectionBlock,\n    MarkdownTextObject,\n    InputBlock,\n    UserMultiSelectElement,\n    ActionsBlock,\n    ContextBlock,\n    ButtonElement,\n    DividerBlock,\n)\nfrom app.config import settings\nfrom app.utils import dict_to_json_str, json_str_to_dict\n\n\nasync def handle_coffee_chat_message(\n    ack: AsyncAck,\n    body: MessageBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n    subtype: str | None,  # file_share, message_changed, None\n    is_thread: bool,\n    ts: str,\n) -> None:\n    \"\"\"ì»¤í”¼ì±— ì¸ì¦ ë©”ì‹œì§€ì¸ì§€ í™•ì¸í•˜ê³ , ì¸ì¦ ëª¨ë‹¬ì„ ì „ì†¡í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    if not is_thread:\n        # 1ì´ˆ ëŒ€ê¸°í•˜ëŠ” ì´ìœ ëŠ” ë©”ì‹œì§€ ë³´ë‹¤ ë” ë¨¼ì € ì „ì†¡ ë˜ì–´ ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n        await asyncio.sleep(1)\n        text = f\"<@{user.user_id}> ë‹˜ ì»¤í”¼ì±— ì¸ì¦ì„ ì‹œì‘í•˜ë ¤ë©´ ì•„ë˜ `ì»¤í”¼ì±— ì¸ì¦` ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.\\në§Œì•½ ì¸ì¦ì„ ì›ì¹˜ ì•Šìœ¼ì‹œë©´ `ì•ˆë‚´ ë‹«ê¸°` ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.\"\n        await client.chat_postEphemeral(\n            user=user.user_id,\n            channel=body[\"event\"][\"channel\"],\n            text=text,\n            blocks=[\n                SectionBlock(text=text),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"ì•ˆë‚´ ë‹«ê¸°\",\n                            action_id=\"cancel_coffee_chat_proof_button\",\n                        ),\n                        ButtonElement(\n                            text=\"ì»¤í”¼ì±— ì¸ì¦\",\n                            action_id=\"submit_coffee_chat_proof_button\",\n                            value=ts,\n                            style=\"primary\",\n                        ),\n                    ]\n                ),\n            ],\n        )\n        return\n\n    # ì¸ì¦ê¸€ì— ë‹µê¸€ë¡œ ì»¤í”¼ì±— ì¸ì¦ì„ í•˜ëŠ” ê²½ìš°\n    if is_thread and subtype != \"message_changed\":\n        try:\n            service.check_coffee_chat_proof(\n                thread_ts=str(body[\"event\"][\"thread_ts\"]),\n                user_id=body[\"event\"][\"user\"],\n            )\n        except BotException:\n            # ì´ ì—ëŸ¬ëŠ” ì¸ì¦ ê¸€ì— ëŒ€í•œ ë‹µê¸€ì´ ì•„ë‹ˆê±°ë‚˜ ì´ë¯¸ ì¸ì¦í•œ ê²½ìš°, ì¸ì¦ ëŒ€ìƒì´ ì•„ë‹Œ ê²½ìš°ì„.\n            return\n\n        service.create_coffee_chat_proof(\n            ts=str(body[\"event\"][\"ts\"]),\n            thread_ts=str(body[\"event\"][\"thread_ts\"]),\n            user_id=body[\"event\"][\"user\"],\n            text=body[\"event\"][\"text\"],\n            files=body[\"event\"].get(\"files\", []),  # type: ignore\n            selected_user_ids=\"\",\n        )\n\n        await client.reactions_add(\n            channel=body[\"event\"][\"channel\"],\n            timestamp=body[\"event\"][\"ts\"],\n            name=\"white_check_mark\",\n        )\n\n        # ëŒ“ê¸€ ì¸ì¦ í¬ì¸íŠ¸ ì§€ê¸‰\n        text = point_service.grant_if_coffee_chat_verified(\n            user_id=body[\"event\"][\"user\"]\n        )\n        await send_point_noti_message(\n            client=client, channel=body[\"event\"][\"user\"], text=text\n        )\n        return\n\n\nasync def cancel_coffee_chat_proof_button(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì»¤í”¼ì±— ì¸ì¦ ì•ˆë‚´ë¥¼ ë‹«ìŠµë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    requests.post(\n        body[\"response_url\"],\n        json={\n            \"response_type\": \"ephemeral\",\n            \"delete_original\": True,\n        },\n        timeout=5.0,\n    )\n\n\nasync def submit_coffee_chat_proof_button(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì»¤í”¼ì±— ì¸ì¦ì„ ì œì¶œí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    private_metadata = dict_to_json_str(\n        {\n            \"ephemeral_url\": body[\"response_url\"],\n            \"message_ts\": body[\"actions\"][0][\"value\"],\n        }\n    )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=\"ì»¤í”¼ì±— ì¸ì¦\",\n            submit=\"ì»¤í”¼ì±— ì¸ì¦í•˜ê¸°\",\n            callback_id=\"submit_coffee_chat_proof_view\",\n            private_metadata=private_metadata,\n            blocks=[\n                SectionBlock(\n                    text=\":coffee: ì»¤í”¼ì±—ì— ì°¸ì—¬í•œ ë©¤ë²„ë“¤ì„ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”.\"\n                ),\n                ContextBlock(\n                    elements=[\n                        MarkdownTextObject(\n                            text=\"ë©¤ë²„ ì¸ë ¥ë€ì„ í•œ ë²ˆ ë” ëˆ„ë¥´ë©´ ë©¤ë²„ë¥¼ ê²€ìƒ‰í•  ìˆ˜ ìˆì–´ìš”.\\nëª¨ë°”ì¼ì—ì„œ ë©¤ë²„ê°€ ê²€ìƒ‰ë˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ë°ìŠ¤í¬íƒ‘ì—ì„œ ì§„í–‰í•´ì£¼ì„¸ìš”.\"\n                        )\n                    ]\n                ),\n                InputBlock(\n                    block_id=\"participant\",\n                    label=\"ì»¤í”¼ì±— ì°¸ì—¬ ë©¤ë²„\",\n                    optional=False,\n                    element=UserMultiSelectElement(\n                        action_id=\"select\",\n                        placeholder=\"ì°¸ì—¬í•œ ë©¤ë²„ë“¤ì„ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”.\",\n                        initial_users=[user.user_id],\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def submit_coffee_chat_proof_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    say: AsyncSay,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì»¤í”¼ì±— ì¸ì¦ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.\"\"\"\n    selected_users = body[\"view\"][\"state\"][\"values\"][\"participant\"][\"select\"][\n        \"selected_users\"\n    ]\n    if len(selected_users) < 2:\n        await ack(\n            response_action=\"errors\",\n            errors={\n                \"participant\": \"ì»¤í”¼ì±— ì¸ì¦ì€ ë³¸ì¸ í¬í•¨ ìµœì†Œ 2ëª… ì´ìƒì˜ ë©¤ë²„ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.\"\n            },\n        )\n        return\n\n    await ack()\n\n    private_metadata = json_str_to_dict(body[\"view\"][\"private_metadata\"])\n    ephemeral_url = private_metadata[\"ephemeral_url\"]\n    message_ts = private_metadata[\"message_ts\"]\n\n    history = await client.conversations_history(\n        channel=settings.COFFEE_CHAT_PROOF_CHANNEL,\n        latest=message_ts,\n        limit=1,\n        inclusive=True,\n    )\n    message = history[\"messages\"][0]\n\n    await client.reactions_add(\n        channel=settings.COFFEE_CHAT_PROOF_CHANNEL,\n        timestamp=message_ts,\n        name=\"white_check_mark\",\n    )\n\n    # í¬ì¸íŠ¸ ì§€ê¸‰\n    text = point_service.grant_if_coffee_chat_verified(user_id=user.user_id)\n    await send_point_noti_message(client=client, channel=user.user_id, text=text)\n\n    participant_call_text = \",\".join(\n        f\"<@{selected_user}>\"\n        for selected_user in selected_users\n        if selected_user != user.user_id  # ë³¸ì¸ ì œì™¸\n    )\n\n    participant_call_thread_ts = \"\"\n    if participant_call_text:\n        res = await client.chat_postMessage(\n            channel=settings.COFFEE_CHAT_PROOF_CHANNEL,\n            thread_ts=message_ts,\n            text=f\"{participant_call_text} \\n\\nì»¤í”¼ì±— ì¸ì¦ì„ ìœ„í•´ ìŠ¤ë ˆë“œë¡œ í›„ê¸°ë¥¼ ë‚¨ê²¨ì£¼ì„¸ìš”. ì¸ì¦ì´ í™•ì¸ëœ ë©¤ë²„ëŠ” âœ…ê°€ í‘œì‹œë¼ìš”.\\n\\nì»¤í”¼ì±— ì¸ì¦ ë‚´ì—­ì€ <@{settings.TTOBOT_USER_ID}> ì˜ `í™ˆ` íƒ­ -> `ë‚´ ì»¤í”¼ì±— ì¸ì¦ ë‚´ì—­ ë³´ê¸°` ë²„íŠ¼ì„ í†µí•´ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.\",\n        )\n        participant_call_thread_ts = res.get(\"ts\", \"\")\n\n    service.create_coffee_chat_proof(\n        ts=message_ts,\n        thread_ts=\"\",\n        user_id=user.user_id,\n        text=message[\"text\"],\n        files=message.get(\"files\", []),\n        selected_user_ids=\",\".join(\n            selected_user\n            for selected_user in selected_users\n            if selected_user != user.user_id\n        ),\n        participant_call_thread_ts=participant_call_thread_ts,\n    )\n\n    # ë‚˜ì—ê²Œë§Œ í‘œì‹œ ë©”ì‹œì§€ ìˆ˜ì •í•˜ëŠ” ìš”ì²­(slack bolt ì—ì„œëŠ” ì§€ì›í•˜ì§€ ì•ŠìŒ)\n    requests.post(\n        ephemeral_url,\n        json={\n            \"response_type\": \"ephemeral\",\n            \"delete_original\": True,\n        },\n        timeout=5.0,\n    )\n\n\nasync def paper_plane_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì¢…ì´ë¹„í–‰ê¸° ëª…ë ¹ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    remain_paper_planes: str | int\n    if user.user_id == settings.SUPER_ADMIN:\n        remain_paper_planes = \"âˆ\"\n    else:\n        remain_paper_planes = \"âˆ\"\n        # paper_planes = service.fetch_current_week_paper_planes(user_id=user.user_id)\n        # remain_paper_planes = 7 - len(paper_planes) if len(paper_planes) < 7 else 0\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            callback_id=\"paper_plane_command\",\n            title={\"type\": \"plain_text\", \"text\": \"ì¢…ì´ë¹„í–‰ê¸°\"},\n            blocks=[\n                SectionBlock(text=\"âœˆï¸ *ì¢…ì´ë¹„í–‰ê¸°ë€?*\"),\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": (\n                                \"ì¢…ì´ë¹„í–‰ê¸°ëŠ” ê¸€ë˜ ë©¤ë²„ì—ê²Œ ë”°ëœ»í•œ ê°ì‚¬ë‚˜ ì‘ì›ì˜ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ì—ìš”.\\n\"\n                                # \"ë§¤ì£¼ í† ìš”ì¼ 0ì‹œì— 7ê°œê°€ ì¶©ì „ë˜ë©°, í•œ ì£¼ ë™ì•ˆ ììœ ë¡­ê²Œ ì›í•˜ëŠ” ë¶„ê»˜ ë³´ë‚¼ ìˆ˜ ìˆì–´ìš”.\\n\"\n                                f\"*{user.name[1:]}* ë‹˜ì´ ì´ë²ˆ ì£¼ì— ë³´ë‚¼ ìˆ˜ ìˆëŠ” ì¢…ì´ë¹„í–‰ê¸° ìˆ˜ëŠ” í˜„ì¬ *{remain_paper_planes}ê°œ* ì…ë‹ˆë‹¤.\"\n                            ),\n                        }\n                    ]\n                ),\n                DividerBlock(),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"ì¢…ì´ë¹„í–‰ê¸° ë³´ë‚´ê¸°\",\n                            action_id=\"send_paper_plane_message\",\n                            style=\"primary\",\n                        ),\n                        ButtonElement(\n                            text=\"ì£¼ê³ ë°›ì€ ì¢…ì´ë¹„í–‰ê¸° ë³´ê¸°\",\n                            action_id=\"open_paper_plane_url\",\n                            url=\"https://geultto-paper-plane.vercel.app\",\n                        ),\n                    ]\n                ),\n                DividerBlock(),\n                # ì‚¬ìš© ë°©ë²• ì•ˆë‚´\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*âœï¸ ì–´ë–¤ ë‚´ìš©ì„ ë³´ë‚´ë©´ ì¢‹ì„ê¹Œìš”?*\",\n                    }\n                ),\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": \"ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ë¥¼ ì‘ì„±í•  ë•ŒëŠ” ì•„ë˜ ë‚´ìš©ì„ ì°¸ê³ í•´ë³´ì„¸ìš”. ğŸ˜‰\\n\\n\"\n                            \"*`êµ¬ì²´ì ì¸ ìƒí™©`* - ì–´ë–¤ í™œë™ì´ë‚˜ ëŒ€í™”ì—ì„œ ê³ ë§ˆì›€ì„ ëŠê¼ˆëŠ”ì§€ ì´ì•¼ê¸°í•´ìš”.\\n\"\n                            \"*`êµ¬ì²´ì ì¸ ë‚´ìš©`* - ê·¸ ì‚¬ëŒì´ ì–´ë–¤ ë„ì›€ì„ ì¤¬ê±°ë‚˜, ì–´ë–¤ ë§ì„ í•´ì¤¬ëŠ”ì§€ ì ì–´ë³´ì„¸ìš”.\\n\"\n                            \"*`íš¨ê³¼ì™€ ê°ì‚¬ í‘œí˜„`* - ê·¸ í–‰ë™ì´ ë‚˜ì—ê²Œ ì–´ë–¤ ì˜í–¥ì„ ì£¼ì—ˆëŠ”ì§€, ì–¼ë§ˆë‚˜ ê°ì‚¬í•œì§€ í‘œí˜„í•´ìš”.\\n\"\n                            \"*`ì•ìœ¼ë¡œì˜ ê¸°ëŒ€`* - ì•ìœ¼ë¡œë„ ê³„ì† í•¨ê»˜í•´ì£¼ê¸¸ ë°”ë¼ëŠ” ë§ˆìŒì„ ì „í•´ë³´ì„¸ìš”!\",\n                        }\n                    ]\n                ),\n                DividerBlock(),\n                # ì˜ˆì‹œ ë©”ì‹œì§€\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*ğŸ’Œ ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ ì˜ˆì‹œ*\\n\",\n                    }\n                ),\n                # ì˜ˆì‹œ 1: ìŠ¤í„°ë”” í™œë™\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": 'ì˜ˆì‹œ 1: ìŠ¤í„°ë”” í™œë™\\n>\"00 ìŠ¤í„°ë””ì—ì„œ í•­ìƒ ì—´ì •ì ìœ¼ë¡œ ì°¸ì—¬í•´ì£¼ì…”ì„œ ì •ë§ ê°ì‚¬í•´ìš”! ë•ë¶„ì— ì €ë„ ë” ì—´ì‹¬íˆ í•˜ê²Œ ë˜ê³ , ë§ì€ ë°°ì›€ì„ ì–»ê³  ìˆì–´ìš”. ì•ìœ¼ë¡œë„ í•¨ê»˜ ì„±ì¥í•´ë‚˜ê°ˆ ìˆ˜ ìˆìœ¼ë©´ ì¢‹ê² ì–´ìš”! ğŸ˜Š\"',\n                        }\n                    ]\n                ),\n                # ì˜ˆì‹œ 2: ì»¤í”¼ì±— ëŒ€í™”\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": 'ì˜ˆì‹œ 2: ì»¤í”¼ì±— ëŒ€í™”\\n>\"ì§€ë‚œë²ˆ ì»¤í”¼ì±—ì—ì„œ ë‚˜ëˆˆ ëŒ€í™”ê°€ ì •ë§ ì¸ìƒ ê¹Šì—ˆì–´ìš”. ê°œë°œì— ëŒ€í•œ ìƒê°ì„ ë‚˜ëˆ„ê³  ì¡°ì–¸ì„ ì£¼ì…”ì„œ ê³ ë§™ìŠµë‹ˆë‹¤! ë‹¤ìŒì—ë„ ë˜ ì´ëŸ° ê¸°íšŒê°€ ìˆìœ¼ë©´ ì¢‹ê² ë„¤ìš”!\"',\n                        }\n                    ]\n                ),\n                # ì˜ˆì‹œ 3: ë°˜ìƒíšŒ ë°œí‘œ\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": 'ì˜ˆì‹œ 3: ë°˜ìƒíšŒ ë°œí‘œ\\n>\"ìµœê·¼ ë°˜ìƒíšŒì—ì„œ ë°œí‘œí•˜ì‹  ëª¨ìŠµì´ ì¸ìƒì ì´ì—ˆì–´ìš”! ë©€ë¦¬ì„œ ì§€ì¼œë³´ë©´ì„œ ë§ì€ ì˜ê°ì„ ë°›ì•˜ë‹µë‹ˆë‹¤. ğŸ˜Š ë‚˜ì¤‘ì— ê¸°íšŒê°€ ëœë‹¤ë©´ ì»¤í”¼ì±—ìœ¼ë¡œ ë” ê¹Šê²Œ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆŒ ìˆ˜ ìˆìœ¼ë©´ ì¢‹ê² ì–´ìš”!\"',\n                        }\n                    ]\n                ),\n                DividerBlock(),\n                # ê°€ì´ë“œ ë§ˆë¬´ë¦¬\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": \"ì´ì œ ì§„ì‹¬ì„ ë‹´ì€ ë©”ì‹œì§€ë¥¼ ì¢…ì´ë¹„í–‰ê¸°ë¡œ ì „ë‹¬í•´ë³´ì„¸ìš”! âœˆï¸\",\n                        }\n                    ]\n                ),\n            ],\n        ),\n    )\n"}
{"type": "source_file", "path": "app/slack/events/contents.py", "content": "import csv\nimport re\n\nimport pandas as pd\n\nfrom app.slack_notification import send_point_noti_message\nfrom app.slack.components import static_select\nfrom app.constants import MAX_PASS_COUNT, ContentCategoryEnum\nfrom app.exception import BotException, ClientException\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom slack_sdk.models.views import View\nfrom slack_sdk.models.blocks import (\n    Block,\n    SectionBlock,\n    InputBlock,\n    PlainTextInputElement,\n    ContextBlock,\n    MarkdownTextObject,\n    DividerBlock,\n    OverflowMenuElement,\n    Option,\n    ActionsBlock,\n    ButtonElement,\n    StaticSelectElement,\n    UrlInputElement,\n)\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\n\nfrom app import models, store\nfrom app.slack.services.base import SlackService\nfrom app.slack.services.point import PointService\nfrom app.slack.types import (\n    ActionBodyType,\n    BlockActionBodyType,\n    CommandBodyType,\n    OverflowActionBodyType,\n    ViewBodyType,\n    ViewType,\n)\nfrom app.utils import dict_to_json_str, json_str_to_dict, tz_now_to_str\nfrom app.config import settings\n\n\nasync def submit_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ê¸€ ì œì¶œ ì‹œì‘\"\"\"\n    await ack()\n    callback_id = \"submit_view\"\n\n    # ì–´ë“œë¯¼ ìœ ì €ëŠ” ì œì¶œí•˜ëŠ” ê³³ì— ë©”ì„¸ì§€ê°€ ì „ì†¡ë©ë‹ˆë‹¤.\n    private_metadata = (\n        body[\"channel_id\"] if user.user_id in settings.ADMIN_IDS else user.channel_id\n    )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            private_metadata=private_metadata,\n            callback_id=callback_id,\n            title=\"ë˜ë´‡\",\n            submit=\"ì œì¶œ\",\n            blocks=[\n                SectionBlock(\n                    block_id=\"required_section\",\n                    text=user.submission_guide_message,\n                ),\n                InputBlock(\n                    block_id=\"content_url\",\n                    label=\"ê¸€ ë§í¬\",\n                    element=UrlInputElement(\n                        action_id=\"url_text_input-action\",\n                        placeholder=\"ë…¸ì…˜ ë§í¬ëŠ” í•˜ë‹¨ 'ê¸€ ì œëª©'ì„ í•„ìˆ˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.\",\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"category\",\n                    label=\"ì¹´í…Œê³ ë¦¬\",\n                    element=StaticSelectElement(\n                        action_id=\"category_select\",\n                        placeholder=\"ê¸€ì˜ ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.\",\n                        options=static_select.options(\n                            [category.value for category in ContentCategoryEnum]\n                        ),\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"curation\",\n                    label=\"íë ˆì´ì…˜\",\n                    element=StaticSelectElement(\n                        action_id=\"curation_select\",\n                        placeholder=\"ê¸€ì„ íë ˆì´ì…˜ ëŒ€ìƒì— í¬í•¨í• ê¹Œìš”?\",\n                        options=[\n                            Option(text=\"íë ˆì´ì…˜ ëŒ€ìƒì´ ë˜ê³  ì‹¶ì–´ìš”!\", value=\"Y\"),\n                            Option(text=\"ì•„ì§ì€ ë¶€ë„ëŸ¬ì›Œìš”~\", value=\"N\"),\n                        ],\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"feedback_intensity\",\n                    label=\"í”¼ë“œë°± ê°•ë„\",\n                    element=StaticSelectElement(\n                        action_id=\"feedback_intensity_select\",\n                        initial_option=Option(text=\"ğŸ§„ ë³´í†µë§›\", value=\"HOT\"),\n                        options=[\n                            Option(text=\"ğŸŒ± ìˆœí•œë§›\", value=\"MILD\"),\n                            Option(text=\"ğŸ§„ ë³´í†µë§›\", value=\"HOT\"),\n                            Option(text=\"ğŸŒ¶ï¸ ë§¤ìš´ë§›\", value=\"FIRE\"),\n                            Option(text=\"â˜ ï¸ ì§€ì˜¥ë§›\", value=\"DIABLO\"),\n                        ],\n                    ),\n                ),\n                DividerBlock(),\n                InputBlock(\n                    block_id=\"tag\",\n                    label=\"íƒœê·¸\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"tags_input\",\n                        placeholder=\"íƒœê·¸1,íƒœê·¸2,íƒœê·¸3, ... \",\n                        multiline=False,\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"description\",\n                    label=\"í•˜ê³  ì‹¶ì€ ë§\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"text_input\",\n                        placeholder=\"í•˜ê³  ì‹¶ì€ ë§ì´ ìˆë‹¤ë©´ ë‚¨ê²¨ì£¼ì„¸ìš”.\",\n                        multiline=True,\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"manual_title_input\",\n                    label=\"ê¸€ ì œëª©(ì§ì ‘ ì…ë ¥)\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"title_input\",\n                        placeholder=\"'ê¸€ ì œëª©'ì„ ì§ì ‘ ì…ë ¥í•©ë‹ˆë‹¤.\",\n                        multiline=False,\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def submit_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ê¸€ ì œì¶œ ì™„ë£Œ\"\"\"\n    # ìŠ¬ë™ ì•±ì´ êµ¬ ë²„ì „ì¼ ê²½ìš° ì¼ë¶€ block ì´ ì‚¬ë¼ì ¸ í‚¤ì—ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ\n    content_url = view[\"state\"][\"values\"][\"content_url\"][\"url_text_input-action\"][\n        \"value\"\n    ]\n    channel_id = view[\"private_metadata\"]\n    username = body[\"user\"][\"username\"]\n    is_submit = user.is_submit\n\n    try:\n        service.validate_url(view, content_url)\n        title = await service.get_title(view, content_url)\n    except (ValueError, ClientException) as e:\n        await ack(response_action=\"errors\", errors={\"content_url\": str(e)})\n        raise e\n\n    # ì°¸ê³ : ack ë¡œ ì—ëŸ¬ë¥¼ ë°˜í™˜í•  ê²½ìš°, ê·¸ì „ì— ack() ë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šì•„ì•¼ í•œë‹¤.\n    await ack()\n\n    try:\n        content = await service.create_submit_content(\n            title,\n            content_url,\n            username,\n            view,  # type: ignore # TODO: ì›ì ê°’ì„ ë„˜ê¸°ë„ë¡ ìˆ˜ì •\n        )\n\n        # í•´ë‹¹ text ëŠ” ìŠ¬ë™ í™œë™ íƒ­ì—ì„œ í‘œì‹œë˜ëŠ” ë©”ì‹œì§€ì´ë©°, ëˆ„ê°€ ì–´ë–¤ ë§í¬ë¥¼ ì œì¶œí–ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. (alt_text ì™€ ìœ ì‚¬í•œ ì—­í• )\n        text = f\"*<@{content.user_id}>ë‹˜ ì œì¶œ ì™„ë£Œ.* ë§í¬ : *<{content.content_url}|{re.sub('<|>', '', title if content.title != 'title unknown.' else content.content_url)}>*\"\n        message = await client.chat_postMessage(\n            channel=channel_id,\n            text=text,\n            blocks=[\n                SectionBlock(text=service.get_chat_message(content)),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"ìê¸°ì†Œê°œ ë³´ê¸°\",\n                            action_id=\"intro_modal\",\n                            value=content.user_id,\n                        ),\n                        ButtonElement(\n                            text=\"ì´ì „ ì‘ì„±ê¸€ ë³´ê¸°\",\n                            action_id=\"contents_modal\",\n                            value=content.user_id,\n                        ),\n                        ButtonElement(\n                            text=\"ë¶ë§ˆí¬ ì¶”ê°€ğŸ“Œ\",\n                            action_id=\"bookmark_modal\",\n                            value=dict_to_json_str(\n                                {\n                                    \"user_id\": content.user_id,\n                                    \"dt\": content.dt,\n                                }\n                            ),\n                        ),\n                        ButtonElement(\n                            text=\"ë©¤ë²„ êµ¬ë…í•˜ê¸°ğŸ””\",\n                            action_id=\"open_subscribe_member_view\",\n                            value=dict_to_json_str({\"target_user_id\": content.user_id}),\n                        ),\n                    ],\n                ),\n            ],\n        )\n        content.ts = message.get(\"ts\", \"\")\n\n        await service.update_user_content(content)\n\n    except Exception as e:\n        message = f\"{user.name}({user.channel_name}) ë‹˜ì˜ ì œì¶œì´ ì‹¤íŒ¨í–ˆì–´ìš”. {str(e)}\"  # type: ignore\n        raise BotException(message)  # type: ignore\n\n    # í¬ì¸íŠ¸ ì§€ê¸‰ 1. ê¸€ ì œì¶œ ì‹œ í¬ì¸íŠ¸ ì§€ê¸‰\n    submission_point_msg, is_additional = point_service.grant_if_post_submitted(\n        user_id=content.user_id, is_submit=is_submit\n    )\n    await send_point_noti_message(\n        client=client,\n        channel=content.user_id,\n        text=submission_point_msg,\n    )\n\n    # ì¶”ê°€ ì œì¶œì˜ ê²½ìš° ì—°ì† ì½¤ë³´, ì±„ë„ ë­í‚¹ í¬ì¸íŠ¸ ì§€ê¸‰ì„ í•˜ì§€ ì•ŠëŠ”ë‹¤.\n    if not is_additional:\n        # í¬ì¸íŠ¸ ì§€ê¸‰ 2.\n        combo_point_msg = point_service.grant_if_post_submitted_continuously(\n            user_id=content.user_id\n        )\n        if combo_point_msg:\n            await send_point_noti_message(\n                client=client,\n                channel=content.user_id,\n                text=combo_point_msg,\n            )\n\n        # í¬ì¸íŠ¸ ì§€ê¸‰ 3.\n        ranking_point_msg = (\n            point_service.grant_if_post_submitted_to_core_channel_ranking(\n                user_id=content.user_id\n            )\n        )\n        if ranking_point_msg:\n            await send_point_noti_message(\n                client=client,\n                channel=content.user_id,\n                text=ranking_point_msg,\n            )\n\n    if content.curation_flag == \"Y\":\n        # í¬ì¸íŠ¸ ì§€ê¸‰ 4. íë ˆì´ì…˜ ëŒ€ìƒ ê¸€ ì œì¶œ ì‹œ í¬ì¸íŠ¸ ì§€ê¸‰\n        curation_point_msg = point_service.grant_if_curation_requested(\n            user_id=content.user_id\n        )\n        await send_point_noti_message(\n            client=client,\n            channel=content.user_id,\n            text=curation_point_msg,\n        )\n\n    if content.user_id == settings.SUPER_ADMIN:\n        _modify_super_admin_subscription_channel(channel_id, content.user_id)\n\n        # ìŠˆí¼ ì–´ë“œë¯¼ì´ ê¸€ì„ ì œì¶œí•œ ê²½ìš° êµ¬ë…ìë“¤ì˜ ì‹œíŠ¸ ë°ì´í„°ë¥¼ ì—…ë°ì´íŠ¸ í•œë‹¤.\n        subscriptions = service.fetch_subscriptions_by_target_user_id(content.user_id)\n        for subscription in subscriptions:\n            subscription.updated_at = tz_now_to_str()\n            store.subscription_update_queue.append(subscription.model_dump())\n\n\ndef _modify_super_admin_subscription_channel(channel_id: str, user_id: str) -> None:\n    # ìŠˆí¼ ì–´ë“œë¯¼ì˜ ê²½ìš° subscriptions.csv íŒŒì¼ì—ì„œ target_user_channel ê°’ì„ í˜„ì¬ ì±„ë„ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.\n    # ì´ë¥¼ í†µí•´ ìŠˆí¼ ì–´ë“œë¯¼ì´ ì–´ëŠ ì±„ë„ì— ê¸€ì„ ì œì¶œí•´ë„ êµ¬ë…ìë“¤ì—ê²Œ ì •í™•í•œ ì•Œë¦¼ì„ ë³´ë‚¼ ìˆ˜ ìˆê²Œ í•œë‹¤.\n    df = pd.read_csv(\"store/subscriptions.csv\")\n    df.loc[df[\"target_user_id\"] == user_id, \"target_user_channel\"] = channel_id\n    df.to_csv(\"store/subscriptions.csv\", index=False, quoting=csv.QUOTE_ALL)\n\n\n# TODO: ë°©í•™ê¸°ê°„ì— ë‹´ì†Œì—ë„ ê¸€ì„ ë³´ë‚¼ì§€ì— ëŒ€í•œ ë©”ì‹œì§€ ì „ì†¡ ë¡œì§\n# async def forward_message(\n#     ack: AsyncAck,\n#     body: ActionBodyType,\n#     client: AsyncWebClient,\n#     service: SlackService,\n#     point_service: PointService,\n# ) -> None:\n#     await ack()\n\n#     content_ts = body[\"actions\"][0][\"value\"]\n#     source_channel = body[\"channel\"][\"id\"]\n#     # target_channel = \"C05J4FGB154\"  # ììœ ë¡œìš´ ë‹´ì†Œ ì±„ë„ ID í…ŒìŠ¤íŠ¸ìš©\n#     target_channel = \"C0672HTT36C\"  # ììœ ë¡œìš´ ë‹´ì†Œ ì±„ë„ ID ìš´ì˜ìš©\n\n#     permalink_response = await client.chat_getPermalink(\n#         channel=source_channel, message_ts=content_ts\n#     )\n#     permalink = permalink_response[\"permalink\"]\n#     content = service.get_content_by(ts=content_ts)\n\n#     # ë‹´ì†Œ ì±„ë„ì— ë³´ë‚´ëŠ” ë©”ì‹œì§€\n#     text = f\"<@{content.user_id}>ë‹˜ì´ ê¸€ì„ ê³µìœ í–ˆì–´ìš”! \\nğŸ‘‰ *<{permalink}|{content.title}>*\"\n#     await client.chat_postMessage(channel=target_channel, text=text)\n\n#     # ë‚˜ì—ê²Œë§Œ í‘œì‹œ ë©”ì‹œì§€ ìˆ˜ì •í•˜ëŠ” ìš”ì²­(slack bolt ì—ì„œëŠ” ì§€ì›í•˜ì§€ ì•ŠìŒ)\n#     requests.post(\n#         body[\"response_url\"],\n#         json={\n#             \"response_type\": \"ephemeral\",\n#             \"text\": f\"<#{target_channel}> ì— ì „ì†¡ë˜ì—ˆì–´ìš”. ğŸ“¨\",\n#             \"replace_original\": True,\n#             # \"delete_original\": True, # ì‚­ì œë„ ê°€ëŠ¥\n#         },\n#     )\n\n\nasync def open_intro_modal(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë‹¤ë¥¸ ìœ ì €ì˜ ìê¸°ì†Œê°œ í™•ì¸\"\"\"\n    await ack()\n\n    other_user_id = body[\"actions\"][0][\"value\"]\n    other_user = service.get_user(other_user_id)\n    intro_text = other_user.intro.replace(\"\\\\n\", \"\\n\") or \"ìê¸°ì†Œê°œê°€ ë¹„ì–´ìˆì–´ìš”. ğŸ˜¢\"\n\n    is_self = user.user_id == other_user_id\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{other_user.name}ë‹˜ì˜ ì†Œê°œ\",\n            submit=\"ìê¸°ì†Œê°œ ìˆ˜ì •\" if is_self else None,\n            callback_id=\"edit_intro_view\" if is_self else None,\n            close=\"ë‹«ê¸°\",\n            blocks=[SectionBlock(text=intro_text)],\n        ),\n    )\n\n\nasync def edit_intro_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ìê¸°ì†Œê°œ ìˆ˜ì • ì‹œì‘\"\"\"\n    await ack(\n        response_action=\"update\",\n        view=View(\n            type=\"modal\",\n            callback_id=\"submit_intro_view\",\n            title=\"ìê¸°ì†Œê°œ ìˆ˜ì •\",\n            submit=\"ìê¸°ì†Œê°œ ì œì¶œ\",\n            close=\"ë‹«ê¸°\",\n            blocks=[\n                SectionBlock(text=\"ìì‹ ë§Œì˜ ê°œì„±ìˆëŠ” ì†Œê°œë¬¸êµ¬ë¥¼ ë‚¨ê²¨ì£¼ì„¸ìš”. ğŸ˜‰\"),\n                InputBlock(\n                    block_id=\"description\",\n                    label=\"ìê¸°ì†Œê°œ ë‚´ìš©\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"edit_intro\",\n                        multiline=True,\n                        max_length=2000,\n                        placeholder={\n                            \"type\": \"plain_text\",\n                            \"text\": f\"{user.intro[:100]} ... \",\n                        },\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def submit_intro_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ìê¸°ì†Œê°œ ìˆ˜ì • ì™„ë£Œ\"\"\"\n    new_intro = view[\"state\"][\"values\"][\"description\"][\"edit_intro\"][\"value\"] or \"\"\n    service.update_user_intro(user.user_id, new_intro=new_intro)\n\n    await ack(\n        {\n            \"response_action\": \"update\",\n            \"view\": {\n                \"type\": \"modal\",\n                \"callback_id\": \"submit_intro_view\",\n                \"title\": {\"type\": \"plain_text\", \"text\": \"ìê¸°ì†Œê°œ ìˆ˜ì • ì™„ë£Œ\"},\n                \"close\": {\"type\": \"plain_text\", \"text\": \"ë‹«ê¸°\"},\n                \"blocks\": [\n                    {\n                        \"type\": \"image\",\n                        \"image_url\": \"https://media1.giphy.com/media/g9582DNuQppxC/giphy.gif\",  # noqa E501\n                        \"alt_text\": \"success\",\n                    },\n                    {\n                        \"type\": \"rich_text\",  # rich_text ëŠ” ë¸”ë¡ ê°ì²´ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ\n                        \"elements\": [\n                            {\n                                \"type\": \"rich_text_section\",\n                                \"elements\": [\n                                    {\n                                        \"type\": \"text\",\n                                        \"text\": \"ìê¸°ì†Œê°œ ìˆ˜ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ğŸ‘ğŸ¼ğŸ‘ğŸ¼ğŸ‘ğŸ¼\\në‹¤ì‹œ [ìê¸°ì†Œê°œ ë³´ê¸°] ë²„íŠ¼ì„ ëˆŒëŸ¬ í™•ì¸í•´ë³´ì„¸ìš”!\",  # noqa E501\n                                    }\n                                ],\n                            }\n                        ],\n                    },\n                ],\n            },\n        }\n    )\n\n\nasync def contents_modal(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë‹¤ë¥¸ ìœ ì €ì˜ ì œì¶œí•œ ê¸€ ëª©ë¡ í™•ì¸\"\"\"\n    await ack()\n\n    other_user_id = body[\"actions\"][0][\"value\"]\n    other_user = service.get_user(other_user_id)\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{other_user.name}ë‹˜ì˜ ì‘ì„±ê¸€\",\n            close=\"ë‹«ê¸°\",\n            blocks=_fetch_blocks(other_user.contents[::-1]),\n        ),\n    )\n\n\nasync def bookmark_modal(\n    ack: AsyncAck,\n    body: BlockActionBodyType | OverflowActionBodyType,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë¶ë§ˆí¬ ì €ì¥ ì‹œì‘\"\"\"\n    await ack()\n\n    # TODO: ê¸€ ê²€ìƒ‰ì—ì„œ ë„˜ì–´ì˜¨ ê²½ìš° ë¶ë§ˆí¬ ì €ì¥ í›„ ê²€ìƒ‰ ëª¨ë‹¬ë¡œ ëŒì•„ê°€ì•¼ í•¨\n\n    actions = body[\"actions\"][0]\n    is_overflow = actions[\"type\"] == \"overflow\"  # TODO: ë¶„ë¦¬í•„ìš”\n    if is_overflow:\n        content_value = json_str_to_dict(actions[\"selected_option\"][\"value\"])  # type: ignore\n    else:\n        content_value = json_str_to_dict(actions[\"value\"])  # type: ignore\n\n    content = service.get_content_by(\n        user_id=content_value[\"user_id\"],\n        dt=content_value[\"dt\"],\n    )\n    bookmark = service.get_bookmark(user.user_id, content.ts)\n    if bookmark is not None:\n        # ì´ë¯¸ ë¶ë§ˆí¬ê°€ ë˜ì–´ ìˆë‹¤ë©´ ì‚¬ìš©ìì—ê²Œ ì•Œë¦°ë‹¤.\n        view = View(\n            type=\"modal\",\n            title=\"ë¶ë§ˆí¬\",\n            close=\"ë‹«ê¸°\",\n            blocks=[SectionBlock(text=\"\\nì´ë¯¸ ë¶ë§ˆí¬í•œ ê¸€ì´ì—ìš”. ğŸ˜‰\")],\n        )\n    else:\n        view = View(\n            type=\"modal\",\n            private_metadata=dict_to_json_str(\n                {\n                    \"content_user_id\": content.user_id,\n                    \"content_ts\": content.ts,\n                }\n            ),\n            callback_id=\"bookmark_view\",\n            title=\"ë¶ë§ˆí¬\",\n            submit=\"ë¶ë§ˆí¬ ì¶”ê°€\",\n            blocks=[\n                SectionBlock(\n                    block_id=\"required_section\",\n                    text=\"\\në¶ë§ˆí¬í•œ ê¸€ì€ `/ë¶ë§ˆí¬` ëª…ë ¹ì–´ë¡œ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.\",\n                ),\n                InputBlock(\n                    block_id=\"bookmark_note\",\n                    label=\"ë©”ëª¨\",\n                    optional=True,\n                    element=PlainTextInputElement(\n                        action_id=\"text_input\",\n                        placeholder=\"ë¶ë§ˆí¬ì— ëŒ€í•œ ë©”ëª¨ë¥¼ ë‚¨ê²¨ì£¼ì„¸ìš”.\",\n                        multiline=True,\n                    ),\n                ),\n            ],\n        )\n\n    if is_overflow:\n        await client.views_update(view_id=body[\"view\"][\"id\"], view=view)  # type: ignore\n    else:\n        await client.views_open(trigger_id=body[\"trigger_id\"], view=view)\n\n\nasync def create_bookmark_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë¶ë§ˆí¬ ì €ì¥ ì™„ë£Œ\"\"\"\n    await ack()\n\n    private_metadata = json_str_to_dict(view[\"private_metadata\"])\n    content_user_id = private_metadata[\"content_user_id\"]\n    content_ts = private_metadata[\"content_ts\"]\n\n    value = view[\"state\"][\"values\"][\"bookmark_note\"][\"text_input\"][\"value\"]\n    note = value if value else \"\"  # ìœ ì €ê°€ ì…ë ¥í•˜ì§€ ì•Šìœ¼ë©´ None ìœ¼ë¡œ ì „ë‹¬ ëœë‹¤.\n    service.create_bookmark(\n        user_id=user.user_id,\n        content_user_id=content_user_id,\n        content_ts=content_ts,\n        note=note,\n    )\n\n    await ack(\n        response_action=\"update\",\n        view=View(\n            type=\"modal\",\n            title=\"ë¶ë§ˆí¬\",\n            close=\"ë‹«ê¸°\",\n            blocks=[SectionBlock(text=\"\\në¶ë§ˆí¬ë¥¼ ì¶”ê°€í–ˆì–´ìš”. ğŸ˜‰\")],\n        ),\n    )\n\n\nasync def pass_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ê¸€ íŒ¨ìŠ¤ ì‹œì‘\"\"\"\n    await ack()\n\n    round, due_date = user.get_due_date()\n    user.check_pass()\n\n    # ì–´ë“œë¯¼ ìœ ì €ëŠ” ì œì¶œí•˜ëŠ” ê³³ì— ë©”ì„¸ì§€ê°€ ì „ì†¡ë©ë‹ˆë‹¤.\n    private_metadata = (\n        body[\"channel_id\"] if user.user_id in settings.ADMIN_IDS else user.channel_id\n    )\n\n    if user.is_submit:\n        await client.views_open(\n            trigger_id=body[\"trigger_id\"],\n            view=View(\n                type=\"modal\",\n                title=\"íŒ¨ìŠ¤\",\n                close=\"ë‹«ê¸°\",\n                blocks=[\n                    SectionBlock(\n                        text=f\"ğŸ¤— {user.name} ë‹˜ì€ ì´ë¯¸ {round}íšŒì°¨ (ë§ˆê°ì¼: {due_date}) ê¸€ì„ ì œì¶œí–ˆì–´ìš”.\\n`/ì œì¶œë‚´ì—­` ëª…ë ¹ì–´ë¡œ ê¸€ ì œì¶œ ë‚´ì—­ì„ í™•ì¸í•´ì£¼ì„¸ìš”.\"\n                    )\n                ],\n            ),\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            private_metadata=private_metadata,\n            callback_id=\"pass_view\",\n            title=\"ë˜ë´‡\",\n            submit=\"íŒ¨ìŠ¤\",\n            blocks=[\n                SectionBlock(\n                    block_id=\"required_section\",\n                    text=f\"íŒ¨ìŠ¤ í•˜ë ¤ë©´ ì•„ë˜ 'íŒ¨ìŠ¤' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.\\\n                        \\n\\nì•„ë˜ ìœ ì˜ì‚¬í•­ì„ í™•ì¸í•´ì£¼ì„¸ìš”.\\\n                        \\n- í˜„ì¬ íšŒì°¨ëŠ” {round}íšŒì°¨, ë§ˆê°ì¼ì€ {due_date} ì´ì—ìš”.\\\n                        \\n- íŒ¨ìŠ¤ëŠ” ì—°ì†ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ì–´ìš”.\\\n                        \\n- ë‚¨ì€ íŒ¨ìŠ¤ëŠ” {MAX_PASS_COUNT - user.pass_count}ë²ˆ ì´ì—ìš”.\\\n                        \\n- íŒ¨ìŠ¤ ë©”ì‹œì§€ëŠ” ì½”ì–´ ì±„ë„ì¸ <#{user.channel_id}> ì±„ë„ì— í‘œì‹œë©ë‹ˆë‹¤.\",\n                ),\n                InputBlock(\n                    block_id=\"description\",\n                    optional=True,\n                    label=\"í•˜ê³  ì‹¶ì€ ë§\",\n                    element=PlainTextInputElement(\n                        action_id=\"text_input\",\n                        placeholder=\"í•˜ê³  ì‹¶ì€ ë§ì´ ìˆë‹¤ë©´ ë‚¨ê²¨ì£¼ì„¸ìš”.\",\n                        multiline=True,\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def pass_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ê¸€ íŒ¨ìŠ¤ ì™„ë£Œ\"\"\"\n    await ack()\n\n    channel_id = view[\"private_metadata\"]\n\n    try:\n        content = await service.create_pass_content(ack, body, view)\n        message = await client.chat_postMessage(\n            channel=channel_id,\n            text=service.get_chat_message(content),\n        )\n        content.ts = message.get(\"ts\", \"\")\n        await service.update_user_content(content)\n    except Exception as e:\n        message = f\"{user.name}({user.channel_name}) ë‹˜ì˜ íŒ¨ìŠ¤ê°€ ì‹¤íŒ¨í–ˆì–´ìš”. {str(e)}\"  # type: ignore\n        raise BotException(message)  # type: ignore\n\n\nasync def search_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ê¸€ ê²€ìƒ‰ ì‹œì‘\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=_get_search_view(),\n    )\n\n\nasync def submit_search(\n    ack: AsyncAck,\n    body: ViewBodyType | ActionBodyType,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ê¸€ ê²€ìƒ‰ ì™„ë£Œ\"\"\"\n    name = _get_name(body)\n    category = _get_category(body)\n    keyword = _get_keyword(body)\n\n    contents = service.fetch_contents(keyword, name, category)\n\n    await ack(\n        response_action=\"update\",\n        view=View(\n            type=\"modal\",\n            callback_id=\"back_to_search_view\",\n            title=f\"ì´ {len(contents)} ê°œì˜ ê¸€ì´ ìˆì–´ìš”. ğŸ”\",\n            submit=\"ë‹¤ì‹œ ê²€ìƒ‰\",\n            blocks=_fetch_blocks(contents),\n        ),\n    )\n\n\nasync def web_search(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì›¹ ê²€ìƒ‰ ì‹œì‘(ì™¸ë¶€ ë§í¬ë¡œ ì´ë™)\"\"\"\n    await ack()\n\n\ndef _fetch_blocks(contents: list[models.Content]) -> list[Block]:\n    blocks: list[Block] = []\n    blocks.append(SectionBlock(text=\"ê²°ê³¼ëŠ” ìµœëŒ€ 20ê°œê¹Œì§€ë§Œ í‘œì‹œí•´ìš”.\"))\n    for content in contents:\n\n        if not content.content_url:\n            # content_url ì´ ì—†ëŠ” ê²½ìš°ëŠ” íŒ¨ìŠ¤ì´ë¯€ë¡œ ì œì™¸\n            continue\n\n        blocks.append(DividerBlock())\n        blocks.append(\n            SectionBlock(\n                text=f\"*<{content.content_url}|{re.sub('<|>', '', content.title)}>*\",\n                accessory=OverflowMenuElement(\n                    action_id=\"bookmark_modal\",\n                    options=[\n                        Option(\n                            text=\"ë¶ë§ˆí¬ ì¶”ê°€ğŸ“Œ\",\n                            value=dict_to_json_str(\n                                {\n                                    \"user_id\": content.user_id,\n                                    \"dt\": content.dt,\n                                }\n                            ),\n                        )\n                    ],\n                ),\n            )\n        )\n        blocks.append(\n            ContextBlock(\n                elements=[\n                    MarkdownTextObject(text=f\"> ì¹´í…Œê³ ë¦¬: {content.category}\"),\n                    MarkdownTextObject(\n                        text=f\"> íƒœê·¸: {content.tags}\" if content.tags else \" \"\n                    ),\n                ]\n            )\n        )\n        if len(blocks) > 60:\n            # ìµœëŒ€ 60ê°œì˜ ë¸”ë¡ë§Œ ë°˜í™˜\n            # ê·¸ ì´ìƒì€ Slack Modal ì œí•œì— ê±¸ë¦´ ìˆ˜ ìˆìŒ\n            return blocks\n    return blocks\n\n\nasync def back_to_search_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ê¸€ ê²€ìƒ‰ ë‹¤ì‹œ ì‹œì‘\"\"\"\n    await ack(\n        response_type=\"update\",\n        view=_get_search_view(),\n    )\n\n\ndef _get_category(body):\n    category = (\n        body.get(\"view\", {})\n        .get(\"state\", {})\n        .get(\"values\", {})\n        .get(\"category_search\", {})\n        .get(\"chosen_category\", {})\n        .get(\"selected_option\", {})\n        .get(\"value\", \"ì „ì²´\")\n    )\n    return category\n\n\ndef _get_name(body) -> str:\n    name = (\n        body.get(\"view\", {})\n        .get(\"state\", {})\n        .get(\"values\", {})\n        .get(\"author_search\", {})\n        .get(\"author_name\", {})\n        .get(\"value\", \"\")\n    )\n    return name\n\n\ndef _get_keyword(body) -> str:\n    keyword = (\n        body.get(\"view\", {})\n        .get(\"state\", {})\n        .get(\"values\", {})\n        .get(\"keyword_search\", {})\n        .get(\"keyword\", {})\n        .get(\"value\", \"\")\n    ) or \"\"\n    return keyword\n\n\nasync def bookmark_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë¶ë§ˆí¬ ì¡°íšŒ\"\"\"\n    await ack()\n\n    bookmarks = service.fetch_bookmarks(user.user_id)\n    content_ids = [bookmark.content_ts for bookmark in bookmarks]\n    contents = service.fetch_contents_by_ids(content_ids)\n    content_matrix = _get_content_metrix(contents)\n\n    view = View(\n        type=\"modal\",\n        title=f\"ì´ {len(contents)} ê°œì˜ ë¶ë§ˆí¬ê°€ ìˆì–´ìš”.\",\n        blocks=_fetch_bookmark_blocks(content_matrix, bookmarks),\n        callback_id=\"handle_bookmark_page_view\",\n        private_metadata=dict_to_json_str({\"page\": 1}),\n    )\n\n    if len(content_matrix) > 1:\n        view.blocks.append(\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"ë‹¤ìŒ í˜ì´ì§€\",\n                        style=\"primary\",\n                        action_id=\"next_bookmark_page_action\",\n                    )\n                ]\n            )\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=view,\n    )\n\n\nasync def bookmark_page_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë¶ë§ˆí¬ ì¡°íšŒ\"\"\"\n    await ack()\n\n    bookmarks = service.fetch_bookmarks(user.user_id)\n    content_ids = [bookmark.content_ts for bookmark in bookmarks]\n    contents = service.fetch_contents_by_ids(content_ids)\n    content_matrix = _get_content_metrix(contents)\n\n    view = View(\n        type=\"modal\",\n        title=f\"ì´ {len(contents)} ê°œì˜ ë¶ë§ˆí¬ê°€ ìˆì–´ìš”.\",\n        blocks=_fetch_bookmark_blocks(content_matrix, bookmarks),\n        callback_id=\"handle_bookmark_page_view\",\n        private_metadata=dict_to_json_str({\"page\": 1}),\n    )\n\n    if len(content_matrix) > 1:\n        view.blocks.append(\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"ë‹¤ìŒ í˜ì´ì§€\",\n                        style=\"primary\",\n                        action_id=\"next_bookmark_page_action\",\n                    )\n                ]\n            )\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=view,\n    )\n\n\nasync def handle_bookmark_page(\n    ack: AsyncAck,\n    body: ViewBodyType | OverflowActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë¶ë§ˆí¬ í˜ì´ì§€ ì´ë™\"\"\"\n    await ack()\n\n    bookmarks = service.fetch_bookmarks(user.user_id)\n    content_ids = [bookmark.content_ts for bookmark in bookmarks]\n    contents = service.fetch_contents_by_ids(content_ids)\n    content_matrix = _get_content_metrix(contents)\n    action_id = body[\"actions\"][0][\"action_id\"] if body.get(\"actions\") else None  # type: ignore\n    private_metadata = body.get(\"view\", {}).get(\"private_metadata\")\n    page = json_str_to_dict(private_metadata).get(\"page\", 1) if private_metadata else 1\n\n    if action_id == \"next_bookmark_page_action\":\n        page += 1\n    elif action_id == \"prev_bookmark_page_action\":\n        page -= 1\n\n    view = View(\n        type=\"modal\",\n        title=f\"ì´ {len(contents)} ê°œì˜ ë¶ë§ˆí¬ê°€ ìˆì–´ìš”.\",\n        blocks=_fetch_bookmark_blocks(content_matrix, bookmarks, page=page),\n        callback_id=\"handle_bookmark_page_view\",\n        private_metadata=dict_to_json_str({\"page\": page}),\n    )\n\n    button_elements = []\n    if page != 1:\n        button_elements.append(\n            ButtonElement(\n                text=\"ì´ì „ í˜ì´ì§€\",\n                style=\"primary\",\n                action_id=\"prev_bookmark_page_action\",\n            )\n        )\n    if len(content_matrix) > page:\n        button_elements.append(\n            ButtonElement(\n                text=\"ë‹¤ìŒ í˜ì´ì§€\",\n                style=\"primary\",\n                action_id=\"next_bookmark_page_action\",\n            )\n        )\n\n    if button_elements:\n        view.blocks.append(ActionsBlock(elements=button_elements))\n\n    if body[\"type\"] == \"block_actions\":\n        await client.views_update(\n            view_id=body[\"view\"][\"id\"],\n            view=view,\n        )\n    else:\n        await client.views_open(\n            trigger_id=body[\"trigger_id\"],\n            view=view,\n        )\n\n\ndef _fetch_bookmark_blocks(\n    content_matrix: dict[int, list[models.Content]],\n    bookmarks: list[models.Bookmark],\n    page: int = 1,\n) -> list[Block]:\n    blocks: list[Block] = []\n    blocks.append(SectionBlock(text=f\"{len(content_matrix)} í˜ì´ì§€ ì¤‘ì— {page} í˜ì´ì§€\"))\n    for content in content_matrix.get(page, []):\n\n        if not content.content_url:\n            # content_url ì´ ì—†ëŠ” ê²½ìš°ëŠ” íŒ¨ìŠ¤ì´ë¯€ë¡œ ì œì™¸\n            continue\n\n        blocks.append(DividerBlock())\n        blocks.append(\n            SectionBlock(\n                text=f\"*<{content.content_url}|{re.sub('<|>', '', content.title)}>*\",\n                accessory=OverflowMenuElement(\n                    action_id=\"bookmark_overflow_action\",\n                    options=[\n                        Option(\n                            value=dict_to_json_str(\n                                {\n                                    \"action\": \"remove_bookmark\",\n                                    \"content_ts\": content.ts,\n                                }\n                            ),\n                            text=\"ë¶ë§ˆí¬ ì·¨ì†ŒğŸ“Œ\",\n                        ),\n                        Option(\n                            value=dict_to_json_str(\n                                {\n                                    \"action\": \"view_note\",\n                                    \"content_ts\": content.ts,\n                                }\n                            ),\n                            text=\"ë©”ëª¨ ë³´ê¸°âœï¸\",\n                        ),\n                    ],\n                ),\n            )\n        )\n\n        note = [\n            bookmark.note for bookmark in bookmarks if content.ts == bookmark.content_ts\n        ][0]\n        blocks.append(\n            ContextBlock(elements=[MarkdownTextObject(text=f\"\\n> ë©”ëª¨: {note}\")])\n        )\n\n        if len(blocks) > 60:\n            # ìµœëŒ€ 60ê°œì˜ ë¸”ë¡ë§Œ ë°˜í™˜\n            # ê·¸ ì´ìƒì€ Slack Modal ì œí•œì— ê±¸ë¦´ ìˆ˜ ìˆìŒ\n            return blocks\n\n    return blocks\n\n\nasync def open_overflow_action(\n    ack: AsyncAck,\n    body: OverflowActionBodyType,\n    client: AsyncWebClient,\n    say: AsyncSay,\n    user: models.User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë¶ë§ˆí¬ ë©”ë‰´ ì„ íƒ\"\"\"\n    await ack()\n\n    title = \"\"\n    text = \"\"\n    value = json_str_to_dict(body[\"actions\"][0][\"selected_option\"][\"value\"])\n    if value[\"action\"] == \"remove_bookmark\":\n        title = \"ë¶ë§ˆí¬ ì·¨ì†ŒğŸ“Œ\"\n        service.update_bookmark(\n            user.user_id,\n            value[\"content_ts\"],\n            new_status=models.BookmarkStatusEnum.DELETED,\n        )\n        text = \"ë¶ë§ˆí¬ë¥¼ ì·¨ì†Œí–ˆì–´ìš”.\"\n    elif value[\"action\"] == \"view_note\":\n        title = \"ë¶ë§ˆí¬ ë©”ëª¨âœï¸\"\n        bookmark = service.get_bookmark(user.user_id, value[\"content_ts\"])\n        text = bookmark.note if bookmark and bookmark.note else \"ë©”ëª¨ê°€ ì—†ì–´ìš”.\"\n\n    await client.views_update(\n        view_id=body[\"view\"][\"id\"],\n        view=View(\n            type=\"modal\",\n            callback_id=\"handle_bookmark_page_view\",\n            private_metadata=body[\"view\"][\"private_metadata\"],  # example: {\"page\": 1}\n            title=title,\n            submit=\"ëŒì•„ê°€ê¸°\",\n            blocks=[SectionBlock(text=text)],\n        ),\n    )\n\n\ndef _get_content_metrix(\n    contents: list[models.Content], contents_per_page: int = 20\n) -> dict[int, list[models.Content]]:\n    \"\"\"ì»¨í…ì¸ ë¥¼ 2ì°¨ì› ë°°ì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.\"\"\"\n\n    content_matrix = {}\n    for i, v in enumerate(range(0, len(contents), contents_per_page)):\n        content_matrix.update({i + 1: contents[v : v + contents_per_page]})\n    return content_matrix\n\n\ndef _get_search_view():\n    return View(\n        type=\"modal\",\n        callback_id=\"submit_search\",\n        title=\"ê¸€ ê²€ìƒ‰ ğŸ”\",\n        submit=\"ê²€ìƒ‰\",\n        blocks=[\n            SectionBlock(\n                block_id=\"description_section\",\n                text=\"ì›í•˜ëŠ” ì¡°ê±´ì˜ ê¸€ì„ ê²€ìƒ‰í•  ìˆ˜ ìˆì–´ìš”.\",\n            ),\n            InputBlock(\n                block_id=\"keyword_search\",\n                label=\"ê²€ìƒ‰ì–´\",\n                optional=True,\n                element=PlainTextInputElement(\n                    action_id=\"keyword\",\n                    placeholder=\"ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.\",\n                    multiline=False,\n                ),\n            ),\n            InputBlock(\n                block_id=\"author_search\",\n                label=\"ê¸€ ì‘ì„±ì\",\n                optional=True,\n                element=PlainTextInputElement(\n                    action_id=\"author_name\",\n                    placeholder=\"ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.\",\n                    multiline=False,\n                ),\n            ),\n            InputBlock(\n                block_id=\"category_search\",\n                label=\"ì¹´í…Œê³ ë¦¬\",\n                element=StaticSelectElement(\n                    action_id=\"chosen_category\",\n                    placeholder=\"ì¹´í…Œê³ ë¦¬ ì„ íƒ\",\n                    initial_option=Option(value=\"ì „ì²´\", text=\"ì „ì²´\"),\n                    options=static_select.options(\n                        [category.value for category in ContentCategoryEnum] + [\"ì „ì²´\"]\n                    ),\n                ),\n            ),\n            SectionBlock(\n                text=\"ì›¹ìœ¼ë¡œ ê²€ìƒ‰í•˜ì‹œë ¤ë©´ [ì›¹ ê²€ìƒ‰] ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.\",\n                accessory=ButtonElement(\n                    text=\"ì›¹ ê²€ìƒ‰\",\n                    action_id=\"web_search\",\n                    url=\"https://vvd.bz/d2HG\",\n                    style=\"primary\",\n                ),\n            ),\n        ],\n    )\n"}
{"type": "source_file", "path": "app/slack/types.py", "content": "from typing import TypedDict\n\n\nclass AppMentionEvent(TypedDict):\n    user: str\n    type: str\n    ts: str\n    client_msg_id: str\n    text: str\n    team: str\n    blocks: list[dict]\n    channel: str\n    event_ts: str\n\n\nclass Authorization(TypedDict):\n    enterprise_id: str\n    team_id: str\n    user_id: str\n    is_bot: bool\n    is_enterprise_install: bool\n\n\nclass AppMentionBodyType(TypedDict):\n    token: str\n    team_id: str\n    api_app_id: str\n    event: AppMentionEvent\n    type: str\n    event_id: str\n    event_time: int\n    authorizations: list[Authorization]\n    is_ext_shared_channel: bool\n    event_context: str\n\n\nclass CommandBodyType(TypedDict):\n    token: str\n    team_id: str\n    team_domain: str\n    channel_id: str\n    channel_name: str\n    user_id: str\n    user_name: str\n    command: str\n    text: str\n    api_app_id: str\n    is_enterprise_install: str\n    response_url: str\n    trigger_id: str\n\n\nclass TeamType(TypedDict):\n    id: str\n    domain: str\n\n\nclass UserType(TypedDict):\n    id: str\n    username: str\n    name: str\n    team_id: str\n\n\nclass ViewType(TypedDict):\n    id: str\n    team_id: str\n    type: str\n    blocks: list[dict]\n    private_metadata: str\n    callback_id: str\n    state: dict[str, dict]\n    hash: str\n    title: dict[str, str]\n    clear_on_close: bool\n    notify_on_close: bool\n    close: str\n    submit: dict[str, str]\n    previous_view_id: str\n    root_view_id: str\n    app_id: str\n    external_id: str\n    app_installed_team_id: str\n    bot_id: str\n\n\nclass ViewBodyType(TypedDict):\n    type: str\n    team: TeamType\n    user: UserType\n    api_app_id: str\n    token: str\n    trigger_id: str\n    view: ViewType\n    response_urls: list[str]\n    is_enterprise_install: bool\n    enterprise: str\n\n\nclass ContainerType(TypedDict):\n    type: str\n    message_ts: str\n    channel_id: str\n    is_ephemeral: bool\n\n\nclass ChannelType(TypedDict):\n    id: str\n    name: str\n\n\nclass MessageType(TypedDict):\n    user: str\n    type: str\n    ts: str\n    bot_id: str\n    app_id: str\n    text: str\n    team: str\n    blocks: list[dict]\n\n\nclass ActionType(TypedDict):\n    action_id: str\n    block_id: str\n    text: dict[str, str]\n    value: str\n    type: str\n    action_ts: str\n    selected_user: str | None\n\n\nclass ActionBodyType(TypedDict):\n    type: str\n    user: UserType\n    api_app_id: str\n    token: str\n    container: ContainerType\n    trigger_id: str\n    team: TeamType\n    enterprise: str\n    is_enterprise_install: bool\n    channel: ChannelType\n    message: MessageType\n    state: dict[str, dict]\n    response_url: str\n    view: ViewType\n    actions: list[ActionType]\n\n\nclass OverflowActionType(TypedDict):\n    type: str\n    action_id: str\n    block_id: str\n    selected_option: dict[str, str]\n    action_ts: str\n\n\nclass OverflowActionBodyType(TypedDict):\n    type: str\n    user: UserType\n    api_app_id: str\n    token: str\n    container: ContainerType\n    trigger_id: str\n    team: TeamType\n    enterprise: str\n    is_enterprise_install: bool\n    view: ViewType\n    actions: list[OverflowActionType]\n\n\nclass BlockActionBodyType(TypedDict):\n    type: str\n    user: UserType\n    api_app_id: str\n    token: str\n    container: ContainerType\n    trigger_id: str\n    team: TeamType\n    enterprise: str\n    is_enterprise_install: bool\n    channel: ChannelType\n    message: MessageType\n    state: dict[str, dict]\n    response_url: str\n    actions: list[ActionType]\n\n\nclass MessageChangedMessageType(TypedDict):\n    user: str\n    type: str\n    client_msg_id: str\n    text: str\n    team: str\n    attachments: list[dict]\n    blocks: list[dict]\n    ts: str\n\n\nclass PreviousMessageType(TypedDict):\n    user: str\n    type: str\n    ts: str\n    client_msg_id: str\n    text: str\n    team: str\n    blocks: list[dict]\n\n\nclass MessageChangedEventType(TypedDict):\n    type: str\n    subtype: str\n    message: MessageChangedMessageType\n    previous_message: PreviousMessageType\n    channel: str\n    hidden: bool\n    ts: str\n    event_ts: str\n    channel_type: str\n\n\nclass MessageDeletedEventType(TypedDict):\n    type: str\n    subtype: str\n    previous_message: PreviousMessageType\n    channel: str\n    hidden: bool\n    ts: str\n    event_ts: str\n    deleted_ts: str\n    channel_type: str\n\n\nclass MessageEvent(TypedDict):\n    user: str\n    type: str\n    ts: str\n    client_msg_id: str\n    text: str\n    team: str\n    blocks: list[dict]\n    channel: str\n    event_ts: str\n    channel_type: str\n    thread_ts: str | None  # ìƒìœ„ ë©”ì‹œì§€ì˜ timestamp\n\n\nclass MessageBodyType(TypedDict):\n    token: str\n    team_id: str\n    context_team_id: str\n    context_enterprise_id: str | None\n    api_app_id: str\n    event: MessageEvent  # | MessageChangedEventType | MessageDeletedEventType\n    type: str  # event_callback\n    event_id: str\n    event_time: int\n    authorizations: list[Authorization]\n    is_ext_shared_channel: bool\n    event_context: str\n\n\nclass ReactionEventItem(TypedDict):\n    type: str\n    channel: str\n    ts: str\n\n\nclass ReactionEvent(TypedDict):\n    user: str\n    type: str\n    reaction: str\n    item: ReactionEventItem\n    item_user: str\n    event_ts: str\n\n\nclass ReactionBodyType(TypedDict):\n    token: str\n    team_id: str\n    context_team_id: str\n    context_enterprise_id: str | None\n    api_app_id: str\n    event: ReactionEvent\n    type: str\n    event_id: str\n    event_time: int\n    authorizations: list[Authorization]\n    is_ext_shared_channel: bool\n    event_context: str\n\n\nclass HomeTabEventType(TypedDict):\n    type: str  # app_home_opened\n    user: str\n    channel: str\n    tab: str  # home\n    view: ViewType\n    event_ts: str\n\n\nclass ChannelCreatedChannelType(TypedDict):\n    id: str\n    name: str\n    is_channel: bool\n    is_group: bool\n    is_im: bool\n    is_mpim: bool\n    is_private: bool\n    created: int\n    is_archived: bool\n    is_general: bool\n    unlinked: int\n    name_normalized: str\n    is_shared: bool\n    is_frozen: bool\n    is_org_shared: bool\n    is_pending_ext_shared: bool\n    pending_shared: list\n    context_team_id: str\n    updated: int\n    parent_conversation: None\n    creator: str\n    is_ext_shared: bool\n    shared_team_ids: list[str]\n    pending_connected_team_ids: list\n    topic: dict[str, str]\n    purpose: dict[str, str]\n    previous_names: list[str]\n\n\nclass ChannelCreatedEventType(TypedDict):\n    type: str\n    channel: ChannelCreatedChannelType\n    event_ts: str\n\n\nclass ChannelCreatedBodyType(TypedDict):\n    token: str\n    team_id: str\n    api_app_id: str\n    event: ChannelCreatedEventType\n    type: str\n    event_id: str\n    event_time: int\n    authorizations: list[Authorization]\n    is_ext_shared_channel: bool\n"}
{"type": "source_file", "path": "app/slack/events/subscriptions.py", "content": "from datetime import datetime\nfrom app.constants import BOT_IDS\nfrom app.models import User\nfrom app.slack.services.base import SlackService\nfrom app.slack.types import (\n    ActionBodyType,\n    OverflowActionBodyType,\n)\n\nfrom slack_sdk.models.blocks import (\n    Block,\n    Option,\n    OverflowMenuElement,\n    SectionBlock,\n    DividerBlock,\n    UserSelectElement,\n    ActionsBlock,\n    ContextBlock,\n    MarkdownTextObject,\n)\nfrom slack_sdk.models.views import View\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\nfrom slack_sdk.web.async_client import AsyncWebClient\n\nfrom app.utils import json_str_to_dict\n\n\nasync def open_subscribe_member_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n) -> None:\n    \"\"\"ë©¤ë²„ êµ¬ë… ëª¨ë‹¬ì„ ì—½ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    target_user_value = body[\"actions\"][0].get(\"value\")\n    if not target_user_value:\n        target_user_id = None\n        message = \"\"\n    else:\n        target_user_id = json_str_to_dict(target_user_value)[\"target_user_id\"]\n        message = _process_user_subscription(user, service, target_user_id)\n\n    view = _get_subscribe_member_view(\n        user_id=user.user_id,\n        service=service,\n        message=message,\n        initial_target_user_id=target_user_id,\n    )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=view,\n    )\n\n\nasync def subscribe_member(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n) -> None:\n    \"\"\"ë©¤ë²„ë¥¼ êµ¬ë…í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n    target_user_id = body[\"actions\"][0].get(\"selected_user\")\n    if not target_user_id:\n        return\n\n    message = _process_user_subscription(user, service, target_user_id)\n    view = _get_subscribe_member_view(\n        user_id=user.user_id, service=service, message=message\n    )\n\n    await client.views_update(\n        view_id=body[\"view\"][\"id\"],\n        view=view,\n    )\n\n\ndef _process_user_subscription(\n    user: User,\n    service: SlackService,\n    target_user_id: str,\n) -> str:\n    \"\"\"\n    ë©¤ë²„ êµ¬ë…ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.\n    ë§Œì•½, êµ¬ë…ì´ ì„±ê³µí•˜ë©´ ë¹ˆ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ê³ , ì‹¤íŒ¨í•˜ë©´ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n    \"\"\"\n    message = \"\"\n    if target_user_id == user.user_id:\n        message = \"âš ï¸ ìê¸° ìì‹ ì€ êµ¬ë…í•  ìˆ˜ ì—†ì–´ìš”.\"\n\n    if target_user_id in BOT_IDS:\n        message = \"âš ï¸ ë´‡ì€ êµ¬ë…í•  ìˆ˜ ì—†ì–´ìš”.\"\n\n    if len(service.fetch_subscriptions_by_user_id(user_id=user.user_id)) >= 5:\n        message = \"âš ï¸ êµ¬ë…ì€ ìµœëŒ€ 5ëª…ê¹Œì§€ ê°€ëŠ¥í•´ìš”.\"\n\n    target_user = service.get_only_user(target_user_id)\n    if not target_user:\n        message = \"âš ï¸ êµ¬ë…í•  ë©¤ë²„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\"\n\n    if any(\n        subscription.target_user_id == target_user_id\n        for subscription in service.fetch_subscriptions_by_user_id(user_id=user.user_id)\n    ):\n        message = \"âš ï¸ ì´ë¯¸ êµ¬ë…í•œ ë©¤ë²„ì…ë‹ˆë‹¤.\"\n\n    if not message:\n        service.create_subscription(\n            user_id=user.user_id,\n            target_user_id=target_user_id,\n            target_user_channel=target_user.channel_id,\n        )\n\n    return message\n\n\nasync def unsubscribe_member(\n    ack: AsyncAck,\n    body: OverflowActionBodyType,\n    client: AsyncWebClient,\n    say: AsyncSay,\n    user: User,\n    service: SlackService,\n) -> None:\n    \"\"\"ë©¤ë²„ êµ¬ë…ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    subscription_id = body[\"actions\"][0][\"selected_option\"][\"value\"]\n    service.cancel_subscription(subscription_id)\n\n    view = _get_subscribe_member_view(user_id=user.user_id, service=service)\n\n    await client.views_update(\n        view_id=body[\"view\"][\"id\"],\n        view=view,\n    )\n\n\nasync def open_subscription_permalink(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n) -> None:\n    \"\"\"êµ¬ë…í•œ ë©¤ë²„ì˜ ìƒˆ ê¸€ì„ ì—½ë‹ˆë‹¤. ë¡œê¹…ì„ ìœ„í•œ ì´ë²¤íŠ¸ì…ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n\ndef _get_subscribe_member_view(\n    *,\n    user_id: str,\n    service: SlackService,\n    initial_target_user_id: str | None = None,\n    message: str = \"\",\n) -> View:\n    \"\"\"êµ¬ë… ëª©ë¡ê³¼, ë©¤ë²„ë¥¼ êµ¬ë…í•  ìˆ˜ ìˆëŠ” ë·°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n    user_subscriptions = service.fetch_subscriptions_by_user_id(user_id=user_id)\n    subscription_list_blocks = [\n        SectionBlock(\n            text=f\"<@{subscription.target_user_id}> ë‹˜ì„ {datetime.strptime(subscription.created_at[:10], '%Y-%m-%d').strftime('%Yë…„ %mì›” %dì¼')} ë¶€í„° êµ¬ë…í•˜ê³  ìˆì–´ìš”.\",\n            accessory=OverflowMenuElement(\n                action_id=\"unsubscribe_member\",\n                options=[\n                    Option(text=\"êµ¬ë… ì·¨ì†Œ\", value=subscription.id),\n                ],\n            ),\n        )\n        for subscription in user_subscriptions\n    ]\n    if subscription_list_blocks:\n        subscription_list_blocks = [\n            SectionBlock(text=\"*êµ¬ë… ëª©ë¡*\"),\n            *subscription_list_blocks,\n        ]\n\n    subscribe_blocks: list[Block] = []\n    subscribe_blocks.append(SectionBlock(text=\"*êµ¬ë… í•˜ê¸°*\"))\n    subscribe_blocks.append(\n        ActionsBlock(\n            elements=[\n                UserSelectElement(\n                    action_id=\"subscribe_member\",\n                    placeholder=\"êµ¬ë…í•  ë©¤ë²„ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.\",\n                    initial_user=initial_target_user_id,\n                ),\n            ],\n            block_id=\"select_target_user\",\n        )\n    )\n    if message:\n        subscribe_blocks.append(\n            ContextBlock(elements=[MarkdownTextObject(text=f\"*{message}*\")])\n        )\n    subscribe_blocks.append(\n        ContextBlock(\n            elements=[\n                MarkdownTextObject(\n                    text=\"êµ¬ë…í•œ ë©¤ë²„ê°€ ê¸€ì„ ì œì¶œí•˜ë©´ ë‹¤ìŒ ë‚  ì˜¤ì „ 8ì‹œ(í•œêµ­ ì‹œê°„)ì— DMìœ¼ë¡œ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ìˆì–´ìš”. êµ¬ë…ì€ ìµœëŒ€ 5ëª…ê¹Œì§€ êµ¬ë…í•  ìˆ˜ ìˆìœ¼ë©°, ì·¨ì†ŒëŠ” êµ¬ë… ëª©ë¡ ìš°ì¸¡ì˜ `...` ë˜ëŠ” `ë”ë³´ê¸°` ë²„íŠ¼ì„ í†µí•´ í•  ìˆ˜ ìˆì–´ìš”.\"\n                ),\n            ],\n        )\n    )\n    view = View(\n        type=\"modal\",\n        title=\"ë©¤ë²„ êµ¬ë…\",\n        close=\"ë‹«ê¸°\",\n        blocks=[\n            SectionBlock(\n                text=f\"<@{user_id}> ë‹˜ì€ í˜„ì¬ {len(user_subscriptions)}ëª…ì„ êµ¬ë…í•˜ê³  ìˆì–´ìš”.\"\n            ),\n            DividerBlock(),\n            *subscribe_blocks,\n            DividerBlock(),\n            *subscription_list_blocks,\n        ],\n    )\n\n    return view\n"}
{"type": "source_file", "path": "app/slack/services/point.py", "content": "from pydantic import BaseModel\nfrom app.exception import BotException\nfrom app.models import PointHistory, User\nfrom app.slack.repositories import SlackRepository\nfrom app.config import settings\nfrom app import store\nfrom enum import Enum\n\n# ë™ê¸°ë¶€ì—¬ì™€ ìê·¹ì„ ì£¼ëŠ” í¬ì¸íŠ¸ëŠ” ê³µê°œ ì±„ë„ì— ì•Œë¦¼ì„ ì¤€ë‹¤.\n# ìˆ˜ë™ìœ¼ë¡œ ë°›ëŠ” í¬ì¸íŠ¸ëŠ” ë””ì—  ìœ¼ë¡œ ì•Œë¦¼ì„ ì¤€ë‹¤.\n\n# fmt: off\nclass PointMap(Enum):\n    ê¸€_ì œì¶œ_ê¸°ë³¸ = settings.POINT_MAP[\"ê¸€_ì œì¶œ_ê¸°ë³¸\"]\n    ê¸€_ì œì¶œ_ì¶”ê°€ = settings.POINT_MAP[\"ê¸€_ì œì¶œ_ì¶”ê°€\"]\n    ê¸€_ì œì¶œ_ì½¤ë³´ = settings.POINT_MAP[\"ê¸€_ì œì¶œ_ì½¤ë³´\"]\n    ê¸€_ì œì¶œ_3ì½¤ë³´_ë³´ë„ˆìŠ¤ = settings.POINT_MAP[\"ê¸€_ì œì¶œ_3ì½¤ë³´_ë³´ë„ˆìŠ¤\"]\n    ê¸€_ì œì¶œ_6ì½¤ë³´_ë³´ë„ˆìŠ¤ = settings.POINT_MAP[\"ê¸€_ì œì¶œ_6ì½¤ë³´_ë³´ë„ˆìŠ¤\"]\n    ê¸€_ì œì¶œ_9ì½¤ë³´_ë³´ë„ˆìŠ¤ = settings.POINT_MAP[\"ê¸€_ì œì¶œ_9ì½¤ë³´_ë³´ë„ˆìŠ¤\"]\n    ê¸€_ì œì¶œ_ì½”ì–´ì±„ë„_1ë“± = settings.POINT_MAP[\"ê¸€_ì œì¶œ_ì½”ì–´ì±„ë„_1ë“±\"]\n    ê¸€_ì œì¶œ_ì½”ì–´ì±„ë„_2ë“± = settings.POINT_MAP[\"ê¸€_ì œì¶œ_ì½”ì–´ì±„ë„_2ë“±\"]\n    ê¸€_ì œì¶œ_ì½”ì–´ì±„ë„_3ë“± = settings.POINT_MAP[\"ê¸€_ì œì¶œ_ì½”ì–´ì±„ë„_3ë“±\"]\n    ì»¤í”¼ì±—_ì¸ì¦ = settings.POINT_MAP[\"ì»¤í”¼ì±—_ì¸ì¦\"]\n    ê³µì§€ì‚¬í•­_í™•ì¸_ì´ëª¨ì§€ = settings.POINT_MAP[\"ê³µì§€ì‚¬í•­_í™•ì¸_ì´ëª¨ì§€\"]\n    íë ˆì´ì…˜_ìš”ì²­ = settings.POINT_MAP[\"íë ˆì´ì…˜_ìš”ì²­\"]\n    íë ˆì´ì…˜_ì„ ì • = settings.POINT_MAP[\"íë ˆì´ì…˜_ì„ ì •\"]\n    ë¹Œë¦¬ì§€_ë°˜ìƒíšŒ_ì°¸ì—¬ = settings.POINT_MAP[\"ë¹Œë¦¬ì§€_ë°˜ìƒíšŒ_ì°¸ì—¬\"]\n    ìê¸°ì†Œê°œ_ì‘ì„± = settings.POINT_MAP[\"ìê¸°ì†Œê°œ_ì‘ì„±\"]\n    ì„±ìœ¤ì„_ì¡ì•„ë¼ = settings.POINT_MAP[\"ì„±ìœ¤ì„_ì¡ì•„ë¼\"]\n    íŠ¹ë³„_ë³´ë„ˆìŠ¤ = {\"point\": 0, \"reason\": \"íŠ¹ë³„ ë³´ë„ˆìŠ¤\", \"category\": \"ê¸°íƒ€\"}\n\n# fmt: on\n    @property\n    def point(self) -> int:\n        return self.value[\"point\"]  # type: ignore\n\n    @property\n    def reason(self) -> str:\n        return self.value[\"reason\"]  # type: ignore\n\n    @property\n    def category(self) -> str:\n        return self.value[\"category\"]  # type: ignore\n\n    @classmethod\n    def set_special_bonus(cls, point: int, reason: str) -> \"PointMap\":\n        \"\"\"íŠ¹ë³„ ë³´ë„ˆìŠ¤ í¬ì¸íŠ¸ë¥¼ ë™ì ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        special_bonus = cls.íŠ¹ë³„_ë³´ë„ˆìŠ¤\n        special_bonus._value_ = {\"point\": point, \"reason\": reason, \"category\": \"ê¸°íƒ€\"}\n        return special_bonus\n\n\nclass UserPoint(BaseModel):\n    user: User\n    point_histories: list[PointHistory]\n    \n    @property\n    def total_point(self) -> int:\n        return sum([point_history.point for point_history in self.point_histories])\n\n\n    @property\n    def point_history_text(self) -> str:\n        text = \"\"\n        for point_history in self.point_histories[:20]:\n            text += f\"[{point_history.created_at}] - *{point_history.point}ì * :: {point_history.reason}\\n\"\n\n        if not text:\n            text = \"ì•„ì§ í¬ì¸íŠ¸ íšë“ ë‚´ì—­ì´ ì—†ì–´ìš”. ğŸ˜…\\në˜ë´‡ [í™ˆ] íƒ­ -> [í¬ì¸íŠ¸ íšë“ ë°©ë²• ì•Œì•„ë³´ê¸°] ì—ì„œ ë°©ë²•ì„ í™•ì¸í•´ë³´ì„¸ìš”.\"\n\n        return text\n\n\n\nclass PointService:\n    def __init__(self, repo: SlackRepository) -> None:\n        self._repo = repo\n\n    def get_user_point(self, user_id: str) -> UserPoint:\n        \"\"\"í¬ì¸íŠ¸ íˆìŠ¤í† ë¦¬ë¥¼ í¬í•¨í•œ ìœ ì €ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        user = self._repo.get_user(user_id)\n        if not user:\n            raise BotException(\"ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ìœ ì €ì…ë‹ˆë‹¤.\")\n        point_histories = self._repo.fetch_point_histories(user_id)\n        return UserPoint(user=user, point_histories=point_histories)\n\n    def add_point_history(self, user_id: str, point_info: PointMap, point: int | None = None) -> str:\n        \"\"\"í¬ì¸íŠ¸ íˆìŠ¤í† ë¦¬ë¥¼ ì¶”ê°€í•˜ê³  ì•Œë¦¼ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        if not point:\n            point = point_info.point\n        \n        point_history=PointHistory(\n            user_id=user_id,\n            reason=point_info.reason,\n            point=point,\n            category=point_info.category,\n        )\n        self._repo.add_point(point_history=point_history)\n        store.point_history_upload_queue.append(point_history.to_list_for_sheet())\n        return f\"<@{user_id}>ë‹˜ `{point_info.reason}`(ìœ¼)ë¡œ `{point}`í¬ì¸íŠ¸ë¥¼ íšë“í–ˆì–´ìš”! ğŸ‰\\nì´ í¬ì¸íŠ¸ì™€ ë‚´ì—­ì€ ë˜ë´‡ [í™ˆ] íƒ­ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.\"\n\n    def grant_if_post_submitted(self, user_id: str, is_submit: bool) -> tuple[str, bool]:\n        \"\"\"ê¸€ì“°ê¸° í¬ì¸íŠ¸ ì§€ê¸‰ 1. ê¸€ì„ ì œì¶œí•˜ë©´ ê¸°ë³¸ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤. ê¸€ì„ ì´ë¯¸ ì œì¶œí–ˆë‹¤ë©´ ì¶”ê°€ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\"\"\"\n        user = self._repo.get_user(user_id)\n\n        if not user:\n            raise BotException(\"ìœ ì € ì •ë³´ê°€ ì—†ì–´ ê¸€ ì œì¶œ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\")\n\n        # TODO: ì¶”í›„ ë¶„ë¦¬í•  ê²ƒ\n        if is_submit:\n            is_additional = True\n            point_info = PointMap.ê¸€_ì œì¶œ_ì¶”ê°€\n            return self.add_point_history(user_id, point_info), is_additional\n        else: \n            is_additional = False\n            point_info = PointMap.ê¸€_ì œì¶œ_ê¸°ë³¸\n            return self.add_point_history(user_id, point_info), is_additional\n        \n    def grant_if_post_submitted_continuously(self, user_id: str) -> str | None:\n        \"\"\"ê¸€ì“°ê¸° í¬ì¸íŠ¸ ì§€ê¸‰ 2. ê¸€ì„ ì—°ì†ìœ¼ë¡œ ì œì¶œí•œë‹¤ë©´ ì¶”ê°€ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\"\"\"\n        user = self._repo.get_user(user_id)\n\n        if not user:\n            raise BotException(\"ìœ ì € ì •ë³´ê°€ ì—†ì–´ ê¸€ ì œì¶œ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\")\n        \n        continuous_submit_count = user.get_continuous_submit_count()\n        if continuous_submit_count <= 0: \n            return None\n        \n        combo_point = None\n        if continuous_submit_count == 9:\n            point_info = PointMap.ê¸€_ì œì¶œ_9ì½¤ë³´_ë³´ë„ˆìŠ¤\n        elif continuous_submit_count == 6:\n            point_info = PointMap.ê¸€_ì œì¶œ_6ì½¤ë³´_ë³´ë„ˆìŠ¤\n        elif continuous_submit_count == 3:\n            point_info = PointMap.ê¸€_ì œì¶œ_3ì½¤ë³´_ë³´ë„ˆìŠ¤\n        else:\n            # 3,6,9 ì™¸ì—ëŠ” ì—°ì† ì œì¶œ íšŸìˆ˜ì— ë”°ë¼ ì—°ì† í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\n            point_info = PointMap.ê¸€_ì œì¶œ_ì½¤ë³´\n            combo_point = point_info.point * continuous_submit_count\n            \n        return self.add_point_history(user_id, point_info, point=combo_point)\n\n\n    def grant_if_post_submitted_to_core_channel_ranking(self, user_id: str) -> str | None:\n        \"\"\"ê¸€ ì œì¶œ í¬ì¸íŠ¸ ì§€ê¸‰ 3. ì½”ì–´ì±„ë„ ì œì¶œ ìˆœìœ„ì— ë”°ë¼ ì¶”ê°€ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\"\"\"\n        user = self._repo.get_user(user_id)\n\n        if not user:\n            raise BotException(\"ìœ ì € ì •ë³´ê°€ ì—†ì–´ ê¸€ ì œì¶œ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\")\n        \n        rank_map = {}\n        channel_users = self._repo.fetch_channel_users(user.channel_id)\n        for channel_user in channel_users:\n            if channel_user.is_submit is True:\n                content = channel_user.recent_content\n                rank_map[channel_user.user_id] = content.ts\n        \n        rank_user_ids = sorted(rank_map, key=lambda x: rank_map[x])[:3]\n        if user.user_id in rank_user_ids:\n            rank = rank_user_ids.index(user.user_id) + 1\n            if rank == 1:\n                point_info = PointMap.ê¸€_ì œì¶œ_ì½”ì–´ì±„ë„_1ë“±\n            elif rank == 2:\n                point_info = PointMap.ê¸€_ì œì¶œ_ì½”ì–´ì±„ë„_2ë“±\n            else:\n                point_info = PointMap.ê¸€_ì œì¶œ_ì½”ì–´ì±„ë„_3ë“±\n\n            return self.add_point_history(user_id, point_info)\n        \n        return None\n\n    def grant_if_coffee_chat_verified(self, user_id: str) -> str:\n        \"\"\"\n        ê³µê°œ: ì»¤í”¼ì±— ì¸ì¦ì„ í•œ ê²½ìš° í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\n        ê³µê°œì±„ë„ì— ì•Œë¦¼ì„ ì¤ë‹ˆë‹¤.\n        \"\"\"\n        point_info = PointMap.ì»¤í”¼ì±—_ì¸ì¦\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_notice_emoji_checked(self, user_id: str) -> str:\n        \"\"\"ê³µì§€ì‚¬í•­ì„ í™•ì¸í•œ ê²½ìš° í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\"\"\"\n        point_info = PointMap.ê³µì§€ì‚¬í•­_í™•ì¸_ì´ëª¨ì§€\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_super_admin_post_reacted(self, user_id: str) -> str:\n        \"\"\"ìŠˆí¼ ì–´ë“œë¯¼ ê¸€ì— ì´ëª¨ì§€ë¥¼ ë‹¨ ê²½ìš° í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\"\"\"\n        point_info = PointMap.ì„±ìœ¤ì„_ì¡ì•„ë¼\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_curation_requested(self, user_id: str) -> str:\n        \"\"\"íë ˆì´ì…˜ì„ ìš”ì²­í•œ ê²½ìš° í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\"\"\"\n        point_info = PointMap.íë ˆì´ì…˜_ìš”ì²­\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_curation_selected(self, user_id: str) -> str:\n        \"\"\"\n        ìˆ˜ë™: íë ˆì´ì…˜ì´ ì„ ì •ëœ ê²½ìš° í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\n        DMìœ¼ë¡œ ì•Œë¦¼ì„ ì¤ë‹ˆë‹¤.\n        \"\"\"\n        point_info = PointMap.íë ˆì´ì…˜_ì„ ì •\n        return self.add_point_history(user_id, point_info)\n\n\n    def grant_if_village_conference_participated(\n        self, user_id: str\n    ):\n        \"\"\"\n        ìˆ˜ë™: ë¹Œë¦¬ì§€ ë°˜ìƒíšŒì— ì°¸ì—¬í•œ ê²½ìš° í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\n        DMìœ¼ë¡œ ì•Œë¦¼ì„ ì¤ë‹ˆë‹¤.\n        \"\"\"\n        point_info = PointMap.ë¹Œë¦¬ì§€_ë°˜ìƒíšŒ_ì°¸ì—¬\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_introduction_written(self, user_id: str) -> str:\n        \"\"\"\n        ìˆ˜ë™: ìê¸°ì†Œê°œë¥¼ ì‘ì„±í•œ ê²½ìš° í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\n        DMìœ¼ë¡œ ì•Œë¦¼ì„ ì¤ë‹ˆë‹¤.\n        \"\"\"\n        point_info = PointMap.ìê¸°ì†Œê°œ_ì‘ì„±\n        return self.add_point_history(user_id, point_info)\n\n    def grant_if_special_point(self, user_id: str, point: int, reason: str) -> str:\n        \"\"\"\n        ìˆ˜ë™: íŠ¹ë³„í•œ ê²½ìš° í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\n        DMìœ¼ë¡œ ì•Œë¦¼ì„ ì¤ë‹ˆë‹¤.\n        \"\"\"\n        point_info = PointMap.set_special_bonus(point=point, reason=reason)\n        return self.add_point_history(user_id, point_info)\n"}
{"type": "source_file", "path": "app/slack/repositories.py", "content": "import csv\nfrom typing import Any\nimport pandas as pd\nimport polars as pl\n\nfrom app import store\nfrom app import models\nfrom app.exception import BotException\nfrom app.utils import tz_now_to_str\n\n\nclass SlackRepository:\n    def __init__(self) -> None: ...\n\n    def get_user(self, user_id: str) -> models.User | None:\n        \"\"\"ìœ ì €ì™€ ì½˜í…ì¸ ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        if user := self._get_user(user_id):\n            user.contents = self._fetch_contents(user_id)\n            return user\n        return None\n\n    def get_only_user(self, user_id: str) -> models.User | None:\n        \"\"\"ìœ ì €ë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        if user := self._get_user(user_id):\n            return user\n        return None\n\n    def fetch_users(self) -> list[models.User]:\n        \"\"\"ëª¨ë“  ìœ ì €ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        users = [models.User(**user) for user in self._fetch_users()]\n        for user in users:\n            user.contents = self._fetch_contents(user.user_id)\n        return users\n\n    def _get_user(self, user_id: str) -> models.User | None:\n        \"\"\"ìœ ì €ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        users = self._fetch_users()\n        for user in users:\n            if user[\"user_id\"] == user_id:\n                return models.User(**user)\n        return None\n\n    def _fetch_users(self) -> list[dict[str, Any]]:\n        \"\"\"ëª¨ë“  ìœ ì €ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/users.csv\") as f:\n            reader = csv.DictReader(f)\n            users = [dict(row) for row in reader]\n            return users\n\n    def _fetch_contents(self, user_id: str) -> list[models.Content]:\n        \"\"\"ìœ ì €ì˜ ì½˜í…ì¸ ë¥¼ ì˜¤ë¦„ì°¨ìˆœ(ë‚ ì§œ)ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/contents.csv\") as f:\n            reader = csv.DictReader(f)\n            contents = [\n                models.Content(**content)\n                for content in reader\n                if content[\"user_id\"] == user_id\n            ]\n            return contents\n\n    def update(self, user: models.User) -> None:\n        \"\"\"ìœ ì €ì˜ ì½˜í…ì¸ ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.\"\"\"\n        # TODO: upload ë¡œ ì´ë¦„ ë³€ê²½ í•„ìš”\n        if not user.contents:\n            raise BotException(\"ì—…ë°ì´íŠ¸ ëŒ€ìƒ content ê°€ ì—†ì–´ìš”.\")\n        store.content_upload_queue.append(user.recent_content.to_list_for_sheet())\n        with open(\"store/contents.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(user.recent_content.to_list_for_csv())\n\n    def fetch_contents(self) -> list[models.Content]:\n        \"\"\"ëª¨ë“  ì½˜í…ì¸ ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/contents.csv\") as f:\n            reader = csv.DictReader(f)\n            contents = [\n                models.Content(**content)\n                for content in reader\n                if content[\"type\"] == \"submit\"\n            ]\n            return sorted(contents, key=lambda content: content.dt_, reverse=True)\n\n    def fetch_contents_by_keyword(self, keyword: str) -> list[models.Content]:\n        \"\"\"í‚¤ì›Œë“œê°€ í¬í•¨ëœ ì½˜í…ì¸ ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/contents.csv\") as f:\n            reader = csv.DictReader(f)\n            contents = [\n                models.Content(**content)\n                for content in reader\n                if keyword.lower()\n                in (content[\"title\"] + content[\"description\"] + content[\"tags\"]).lower()\n                and content[\"type\"] == \"submit\"\n            ]\n            return sorted(contents, key=lambda content: content.dt_, reverse=True)\n\n    def get_user_id_by_name(self, name: str) -> str | None:\n        \"\"\"ì´ë¦„ìœ¼ë¡œ user_idë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/users.csv\") as f:\n            reader = csv.DictReader(f)\n            matching_users = [user for user in reader if name in user[\"name\"]]\n\n        if len(matching_users) == 1:  # ì´ë¦„ ë¶€ë¶„ ì¼ì¹˜ê°€ í•˜ë‚˜ì¸ ê²½ìš°ì—ë§Œ ë°˜í™˜\n            return matching_users[0][\"user_id\"]\n        elif len(matching_users) > 1:\n            for user in matching_users:\n                if user[\"name\"] == name:\n                    return user[\"user_id\"]\n        return None\n\n    def fetch_user_ids_by_name(self, name: str) -> list[str]:\n        \"\"\"ì´ë¦„ìœ¼ë¡œ user_idsë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/users.csv\") as f:\n            reader = csv.DictReader(f)\n            return [user[\"user_id\"] for user in reader if name in user[\"name\"]]\n\n    def create_bookmark(self, bookmark: models.Bookmark) -> None:\n        \"\"\"ë¶ë§ˆí¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        with open(\"store/bookmark.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(bookmark.to_list_for_csv())\n\n    def get_bookmark(\n        self,\n        user_id: str,\n        content_ts: str,\n        status: models.BookmarkStatusEnum = models.BookmarkStatusEnum.ACTIVE,\n    ) -> models.Bookmark | None:\n        bookmarks = self.fetch_bookmarks(user_id, status)\n        for bookmark in bookmarks:\n            if bookmark.content_ts == content_ts:\n                return bookmark\n        return None\n\n    def fetch_bookmarks(\n        self,\n        user_id: str,\n        status: models.BookmarkStatusEnum = models.BookmarkStatusEnum.ACTIVE,\n    ) -> list[models.Bookmark]:\n        \"\"\"ìœ ì €ì˜ ì‚­ì œë˜ì§€ ì•Šì€ ë¶ë§ˆí¬ë¥¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/bookmark.csv\") as f:\n            reader = csv.DictReader(f)\n            bookmarks = [\n                models.Bookmark(**bookmark)  # type: ignore\n                for bookmark in reader\n                if bookmark[\"user_id\"] == user_id and bookmark[\"status\"] == status\n            ]\n\n        return sorted(bookmarks, key=lambda bookmark: bookmark.created_at, reverse=True)\n\n    def update_bookmark(\n        self,\n        content_ts: str,\n        new_note: str = \"\",\n        new_status: models.BookmarkStatusEnum = models.BookmarkStatusEnum.ACTIVE,\n    ) -> None:\n        \"\"\"ë¶ë§ˆí¬ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.\"\"\"\n        df = pd.read_csv(\"store/bookmark.csv\", dtype=str, na_filter=False)\n\n        if new_note:\n            df.loc[df[\"content_ts\"] == content_ts, \"note\"] = new_note\n        if new_status:\n            df.loc[df[\"content_ts\"] == content_ts, \"status\"] = new_status\n        if new_note or new_status:\n            df.loc[df[\"content_ts\"] == content_ts, \"updated_at\"] = tz_now_to_str()\n\n        df.to_csv(\"store/bookmark.csv\", index=False, quoting=csv.QUOTE_ALL)\n\n    def update_user_intro(\n        self,\n        user_id: str,\n        new_intro: str,\n    ) -> None:\n        \"\"\"ìœ ì € ì •ë³´ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.\"\"\"\n        df = pd.read_csv(\"store/users.csv\", dtype=str, na_filter=False)\n        df.loc[df[\"user_id\"] == user_id, \"intro\"] = new_intro\n        df.to_csv(\"store/users.csv\", index=False, quoting=csv.QUOTE_ALL)\n\n        if user := self._get_user(user_id):\n            store.user_update_queue.append(user.to_list_for_sheet())\n\n    def get_content_by(\n        self,\n        ts: str | None = None,\n        user_id: str | None = None,\n        dt: str | None = None,\n        content_url: str | None = None,\n    ) -> models.Content | None:\n        \"\"\"\n        ì½˜í…ì¸ ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.\n        - ìš°ì„ ì ìœ¼ë¡œ ts(íƒ€ì„ìŠ¤íƒ¬í”„)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê²€ìƒ‰í•©ë‹ˆë‹¤. ì´ëŠ” Uniqueí•œ ê°’ì…ë‹ˆë‹¤.\n        - tsê°€ ì—†ì„ ê²½ìš°, user_idì™€ dt(ìƒì„±ì¼ì‹œ)ë¥¼ ì¡°í•©í•˜ì—¬ ê²€ìƒ‰í•©ë‹ˆë‹¤. ì´ëŠ” Uniqueí•œ ê°’ì…ë‹ˆë‹¤.\n        - content_url ì´ ìˆì„ ê²½ìš°, content_urlì„ ê²€ìƒ‰í•©ë‹ˆë‹¤. ì´ëŠ” Uniqueí•œ ê°’ì…ë‹ˆë‹¤.\n        - Uniqueí•œ ê°’ì´ ì•„ë‹Œ ê²½ìš°, ê²€ìƒ‰ëœ ê²°ê³¼ ì¤‘ ê°€ì¥ ìµœì‹ ì˜ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n        \"\"\"\n        with open(\"store/contents.csv\") as f:\n            reader = csv.DictReader(f)\n            contents = [\n                models.Content(**content)  # type: ignore\n                for content in reader\n                if content[\"ts\"] == ts\n                or (content[\"user_id\"] == user_id and content[\"dt\"] == dt)\n                or (content[\"content_url\"] == content_url)\n            ]\n\n        if not contents:\n            return None\n\n        return sorted(contents, key=lambda content: content.dt_, reverse=True)[0]\n\n    def create_coffee_chat_proof(self, proof: models.CoffeeChatProof) -> None:\n        \"\"\"ì»¤í”¼ì±— ì¸ì¦ì„ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        with open(\n            \"store/coffee_chat_proof.csv\", \"a\", newline=\"\", encoding=\"utf-8\"\n        ) as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(proof.to_list_for_csv())\n\n    def get_coffee_chat_proof(self, ts: str) -> models.CoffeeChatProof | None:\n        \"\"\"tsë¡œ ì»¤í”¼ì±— ì¸ì¦ì„ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n        with open(\"store/coffee_chat_proof.csv\") as f:\n            reader = csv.DictReader(f)\n            proofs = [\n                models.CoffeeChatProof(**proof)  # type: ignore\n                for proof in reader\n                if proof[\"ts\"] == ts\n            ]\n\n        if not proofs:\n            return None\n\n        return proofs[0]\n\n    def fetch_coffee_chat_proofs(\n        self,\n        *,\n        thread_ts: str | None = None,\n        user_id: str | None = None,\n    ) -> list[models.CoffeeChatProof]:\n        \"\"\"thread_tsë¡œ ì»¤í”¼ì±— ì¸ì¦ì„ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n        with open(\"store/coffee_chat_proof.csv\") as f:\n            reader = csv.DictReader(f)\n            proofs = [\n                models.CoffeeChatProof(**proof)  # type: ignore\n                for proof in reader\n                if (not thread_ts or proof[\"thread_ts\"] == thread_ts)\n                and (not user_id or proof[\"user_id\"] == user_id)\n            ]\n            return sorted(proofs, key=lambda proof: proof.ts, reverse=True)\n\n    def add_point(self, point_history: models.PointHistory) -> None:\n        \"\"\"í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.\"\"\"\n        with open(\"store/point_histories.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(point_history.to_list_for_csv())\n\n    def fetch_point_histories(self, user_id: str) -> list[models.PointHistory]:\n        \"\"\"í¬ì¸íŠ¸ íˆìŠ¤í† ë¦¬ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/point_histories.csv\") as f:\n            reader = csv.DictReader(f)\n            point_histories = [\n                models.PointHistory(**point_history)  # type: ignore\n                for point_history in reader\n                if point_history[\"user_id\"] == user_id\n            ]\n            return sorted(\n                point_histories, key=lambda point: point.created_at, reverse=True\n            )\n\n    def fetch_channel_users(self, channel_id: str) -> list[models.User]:\n        \"\"\"\n        ì±„ë„ì˜ ìœ ì €ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\n        ì„±ëŠ¥í–¥ìƒì„ ìœ„í•´ polarsë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.\n        \"\"\"\n        users_df = pl.read_csv(\"store/users.csv\", dtypes={\"deposit\": pl.Utf8})\n        users = users_df.filter(pl.col(\"channel_id\") == channel_id).to_dicts()\n        users = [models.User(**user) for user in users]\n\n        contents_df = pl.read_csv(\"store/contents.csv\", dtypes={\"ts\": pl.Utf8})\n        for user in users:\n            contents = contents_df.filter(pl.col(\"user_id\") == user.user_id).to_dicts()\n            user.contents = [models.Content(**content) for content in contents]\n\n        return users\n\n    def create_paper_plane(self, paper_plane: models.PaperPlane) -> None:\n        \"\"\"ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        with open(\"store/paper_plane.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(paper_plane.to_list_for_csv())\n\n    def fetch_paper_planes(self, sender_id: str) -> list[models.PaperPlane]:\n        \"\"\"ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/paper_plane.csv\") as f:\n            reader = csv.DictReader(f)\n            paper_planes = [\n                models.PaperPlane(**paper_plane)  # type: ignore\n                for paper_plane in reader\n                if paper_plane[\"sender_id\"] == sender_id\n            ]\n            return paper_planes\n\n    def create_subscription(self, subscription: models.Subscription) -> None:\n        \"\"\"êµ¬ë…ì„ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        with open(\"store/subscriptions.csv\", \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerow(subscription.to_list_for_csv())\n\n    def cancel_subscription(self, subscription_id: str) -> None:\n        \"\"\"êµ¬ë…ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.\"\"\"\n        df = pd.read_csv(\"store/subscriptions.csv\", dtype=str, na_filter=False)\n        df.loc[df[\"id\"] == subscription_id, \"status\"] = (\n            models.SubscriptionStatusEnum.CANCELED\n        )\n        df.to_csv(\"store/subscriptions.csv\", index=False, quoting=csv.QUOTE_ALL)\n\n    def fetch_subscriptions(self) -> list[models.Subscription]:\n        \"\"\"ëª¨ë“  êµ¬ë… ë‚´ì—­ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/subscriptions.csv\") as f:\n            reader = csv.DictReader(f)\n            subscriptions = [\n                models.Subscription(**subscription)  # type: ignore\n                for subscription in reader\n                if subscription[\"status\"] == models.SubscriptionStatusEnum.ACTIVE\n            ]\n            return subscriptions\n\n    def fetch_subscriptions_by_user_id(\n        self,\n        user_id: str,\n    ) -> list[models.Subscription]:\n        \"\"\"ìœ ì €ì˜ êµ¬ë… ë‚´ì—­ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/subscriptions.csv\") as f:\n            reader = csv.DictReader(f)\n            subscriptions = [\n                models.Subscription(**subscription)  # type: ignore\n                for subscription in reader\n                if subscription[\"status\"] == models.SubscriptionStatusEnum.ACTIVE\n                and subscription[\"user_id\"] == user_id\n            ]\n            return subscriptions\n\n    def fetch_subscriptions_by_target_user_id(\n        self,\n        target_user_id: str,\n    ) -> list[models.Subscription]:\n        \"\"\"íƒ€ê²Ÿ ìœ ì €ë¥¼ ê¸°ì¤€ìœ¼ë¡œ êµ¬ë… ë‚´ì—­ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/subscriptions.csv\") as f:\n            reader = csv.DictReader(f)\n            subscriptions = [\n                models.Subscription(**subscription)  # type: ignore\n                for subscription in reader\n                if subscription[\"status\"] == models.SubscriptionStatusEnum.ACTIVE\n                and subscription[\"target_user_id\"] == target_user_id\n            ]\n            return subscriptions\n\n    def get_subscription(\n        self,\n        subscription_id: str,\n        status: models.SubscriptionStatusEnum = models.SubscriptionStatusEnum.ACTIVE,\n    ) -> models.Subscription | None:\n        \"\"\"êµ¬ë…ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        with open(\"store/subscriptions.csv\") as f:\n            reader = csv.DictReader(f)\n            for subscription in reader:\n                if (\n                    subscription[\"id\"] == subscription_id\n                    and subscription[\"status\"] == status\n                ):\n                    return models.Subscription(**subscription)  # type: ignore\n        return None\n"}
{"type": "source_file", "path": "app/store.py", "content": "import asyncio\nimport csv\nimport os\nfrom typing import Any\nfrom app.client import SpreadSheetClient\nfrom app.logging import log_event\nfrom app.models import Bookmark\n\nqueue_lock = asyncio.Lock()\n\ncontent_upload_queue: list[list[str]] = []\nbookmark_upload_queue: list[list[str]] = []\nbookmark_update_queue: list[Bookmark] = []  # TODO: ì¶”í›„ íƒ€ì… ìˆ˜ì • í•„ìš”\nuser_update_queue: list[list[str]] = []\ncoffee_chat_proof_upload_queue: list[list[str]] = []\npoint_history_upload_queue: list[list[str]] = []\npaper_plane_upload_queue: list[list[str]] = []\nsubscription_upload_queue: list[list[str]] = []\nsubscription_update_queue: list[dict[str, Any]] = []\n\n\nclass Store:\n    def __init__(self, client: SpreadSheetClient) -> None:\n        self._client = client\n\n    def pull_all(self) -> None:\n        \"\"\"ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ì„œë²„ ì €ì¥ì†Œë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"users\", values=self._client.get_values(\"users\"))\n        self.write(\"contents\", values=self._client.get_values(\"contents\"))\n        self.write(\"bookmark\", values=self._client.get_values(\"bookmark\"))\n        self.write(\n            \"coffee_chat_proof\", values=self._client.get_values(\"coffee_chat_proof\")\n        )\n        self.write(\"point_histories\", values=self._client.get_values(\"point_histories\"))\n        self.write(\"paper_plane\", values=self._client.get_values(\"paper_plane\"))\n        self.write(\"subscriptions\", values=self._client.get_values(\"subscriptions\"))\n\n    def pull_users(self) -> None:\n        \"\"\"ìœ ì € ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ì„œë²„ ì €ì¥ì†Œë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"users\", values=self._client.get_values(\"users\"))\n\n    def pull_contents(self) -> None:\n        \"\"\"ì½˜í…ì¸  ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ì„œë²„ ì €ì¥ì†Œë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"contents\", values=self._client.get_values(\"contents\"))\n\n    def pull_bookmark(self) -> None:\n        \"\"\"ë¶ë§ˆí¬ ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ì„œë²„ ì €ì¥ì†Œë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"bookmark\", values=self._client.get_values(\"bookmark\"))\n\n    def pull_coffee_chat_proof(self) -> None:\n        \"\"\"ì»¤í”¼ì±— ì¸ì¦ ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ì„œë²„ ì €ì¥ì†Œë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\n            \"coffee_chat_proof\", values=self._client.get_values(\"coffee_chat_proof\")\n        )\n\n    def pull_point_histories(self) -> None:\n        \"\"\"í¬ì¸íŠ¸ ë‚´ì—­ ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ì„œë²„ ì €ì¥ì†Œë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"point_histories\", values=self._client.get_values(\"point_histories\"))\n\n    def pull_paper_plane(self) -> None:\n        \"\"\"ì¢…ì´ë¹„í–‰ê¸° ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ì„œë²„ ì €ì¥ì†Œë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"paper_plane\", values=self._client.get_values(\"paper_plane\"))\n\n    def pull_subscriptions(self) -> None:\n        \"\"\"êµ¬ë… ë‚´ì—­ ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ì„œë²„ ì €ì¥ì†Œë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.\"\"\"\n        os.makedirs(\"store\", exist_ok=True)\n        self.write(\"subscriptions\", values=self._client.get_values(\"subscriptions\"))\n\n    def write(self, table_name: str, values: list[list[str]]) -> None:\n        \"\"\"ë°ì´í„°ë¥¼ ì €ì¥ì†Œì— ì €ì¥í•©ë‹ˆë‹¤.\"\"\"\n        with open(f\"store/{table_name}.csv\", \"w\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f, quoting=csv.QUOTE_ALL)\n            writer.writerows(values)\n\n    def read(self, table_name: str) -> list[list[str]]:\n        \"\"\"ì €ì¥ì†Œì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì˜µë‹ˆë‹¤.\"\"\"\n        with open(f\"store/{table_name}.csv\") as f:\n            reader = csv.reader(f, quoting=csv.QUOTE_ALL)\n            data = list(reader)\n        return data\n\n    def upload_all(self, table_name: str) -> None:\n        \"\"\"í•´ë‹¹ í…Œì´ë¸”ì˜ ëª¨ë“  ë°ì´í„°ë¥¼ ì—…ë¡œë“œí•©ë‹ˆë‹¤.\"\"\"\n        values = self.read(table_name)\n        self._client.bulk_upload(table_name, values)\n\n    async def upload_queue(self) -> None:\n        \"\"\"ìƒˆë¡œ ì¶”ê°€ëœ queue ê°€ ìˆë‹¤ë©´ upload í•©ë‹ˆë‹¤.\"\"\"\n        global content_upload_queue\n        global bookmark_upload_queue\n        global bookmark_update_queue\n        global user_update_queue\n        global coffee_chat_proof_upload_queue\n        global point_history_upload_queue\n        global paper_plane_upload_queue\n        global subscription_upload_queue\n        global subscription_update_queue\n\n        async with queue_lock:\n            temp_content_upload_queue = list(content_upload_queue)\n            if temp_content_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"contents\",\n                    temp_content_upload_queue,\n                )\n                content_upload_queue = self.initial_queue(\n                    queue=content_upload_queue,\n                    temp_queue=temp_content_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_contents\",\n                    type=\"content\",\n                    description=f\"{len(temp_content_upload_queue)}ê°œ ì½˜í…ì¸  ì—…ë¡œë“œ\",\n                    body={\n                        \"temp_content_upload_queue\": temp_content_upload_queue,\n                        \"content_upload_queue\": content_upload_queue,  # ë””ë²„ê¹…ì„ ìœ„í•´ ì¶”ê°€\n                    },\n                )\n\n            temp_bookmark_upload_queue = list(bookmark_upload_queue)\n            if temp_bookmark_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"bookmark\",\n                    temp_bookmark_upload_queue,\n                )\n                bookmark_upload_queue = self.initial_queue(\n                    queue=bookmark_upload_queue,\n                    temp_queue=temp_bookmark_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_bookmarks\",\n                    type=\"content\",\n                    description=f\"{len(temp_bookmark_upload_queue)}ê°œ ë¶ë§ˆí¬ ì—…ë¡œë“œ\",\n                    body={\"temp_bookmark_upload_queue\": temp_bookmark_upload_queue},\n                )\n\n            temp_bookmark_update_queue = list(bookmark_update_queue)\n            if temp_bookmark_update_queue:\n                for bookmark in temp_bookmark_update_queue:\n                    await asyncio.to_thread(\n                        self._client.update_bookmark,\n                        \"bookmark\",\n                        bookmark,\n                    )\n                bookmark_update_queue = self.initial_queue(\n                    queue=bookmark_update_queue,\n                    temp_queue=temp_bookmark_update_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"updated_bookmarks\",\n                    type=\"content\",\n                    description=f\"{len(temp_bookmark_update_queue)}ê°œ ë¶ë§ˆí¬ ì—…ë°ì´íŠ¸\",\n                    body={\"temp_bookmark_update_queue\": temp_bookmark_update_queue},\n                )\n\n            temp_user_update_queue = list(user_update_queue)\n            if temp_user_update_queue:\n                for values in temp_user_update_queue:\n                    await asyncio.to_thread(\n                        self._client.update_user,\n                        \"users\",\n                        values,\n                    )\n                user_update_queue = self.initial_queue(\n                    queue=user_update_queue,\n                    temp_queue=temp_user_update_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"updated_user_introduction\",\n                    type=\"user\",\n                    description=f\"{len(temp_user_update_queue)}ê°œ ìœ ì € ìê¸°ì†Œê°œ ì—…ë°ì´íŠ¸\",\n                    body={\"temp_user_update_queue\": temp_user_update_queue},\n                )\n\n            temp_coffee_chat_proof_upload_queue = list(coffee_chat_proof_upload_queue)\n            if temp_coffee_chat_proof_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"coffee_chat_proof\",\n                    temp_coffee_chat_proof_upload_queue,\n                )\n                coffee_chat_proof_upload_queue = self.initial_queue(\n                    queue=coffee_chat_proof_upload_queue,\n                    temp_queue=temp_coffee_chat_proof_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_coffee_chat_proofs\",\n                    type=\"community\",\n                    description=f\"{len(temp_coffee_chat_proof_upload_queue)}ê°œ ì»¤í”¼ì±— ì¸ì¦ ì—…ë¡œë“œ\",\n                    body={\n                        \"temp_coffee_chat_proof_upload_queue\": temp_coffee_chat_proof_upload_queue\n                    },\n                )\n\n            temp_point_history_upload_queue = list(point_history_upload_queue)\n            if temp_point_history_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"point_histories\",\n                    temp_point_history_upload_queue,\n                )\n                point_history_upload_queue = self.initial_queue(\n                    queue=point_history_upload_queue,\n                    temp_queue=temp_point_history_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_point_histories\",\n                    type=\"point\",\n                    description=f\"{len(temp_point_history_upload_queue)}ê°œ í¬ì¸íŠ¸ ë‚´ì—­ ì—…ë¡œë“œ\",\n                    body={\n                        \"temp_point_history_upload_queue\": temp_point_history_upload_queue\n                    },\n                )\n\n            temp_paper_plane_upload_queue = list(paper_plane_upload_queue)\n            if temp_paper_plane_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"paper_plane\",\n                    temp_paper_plane_upload_queue,\n                )\n                paper_plane_upload_queue = self.initial_queue(\n                    queue=paper_plane_upload_queue,\n                    temp_queue=temp_paper_plane_upload_queue,\n                )\n                # log_event(\n                #     actor=\"system\",\n                #     event=\"uploaded_paper_plane\",\n                #     type=\"community\",\n                #     description=f\"{len(temp_paper_plane_upload_queue)}ê°œ ì¢…ì´ë¹„í–‰ê¸° ì—…ë¡œë“œ\",\n                #     body=\"\",  # ì¢…ì´ ë¹„í–‰ê¸°ëŠ” ë¡œê·¸ì— ë‚´ìš©ì„ í¬í•¨í•˜ì§€ ì•ŠëŠ”ë‹¤.\n                # )\n\n            temp_subscription_upload_queue = list(subscription_upload_queue)\n            if temp_subscription_upload_queue:\n                await asyncio.to_thread(\n                    self._client.bulk_upload,\n                    \"subscriptions\",\n                    temp_subscription_upload_queue,\n                )\n                subscription_upload_queue = self.initial_queue(\n                    queue=subscription_upload_queue,\n                    temp_queue=temp_subscription_upload_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"uploaded_subscription\",\n                    type=\"subscription\",\n                    description=f\"{len(temp_subscription_upload_queue)}ê°œ êµ¬ë… ë‚´ì—­ ì—…ë¡œë“œ\",\n                    body={\n                        \"temp_subscription_upload_queue\": temp_subscription_upload_queue\n                    },\n                )\n\n            temp_subscription_update_queue = list(subscription_update_queue)\n            if temp_subscription_update_queue:\n                for subscription_dict in temp_subscription_update_queue:\n                    await asyncio.to_thread(\n                        self._client.update_subscription,\n                        \"subscriptions\",\n                        subscription_dict,\n                    )\n                subscription_update_queue = self.initial_queue(\n                    queue=subscription_update_queue,\n                    temp_queue=temp_subscription_update_queue,\n                )\n                log_event(\n                    actor=\"system\",\n                    event=\"updated_subscriptions\",\n                    type=\"subscription\",\n                    description=f\"{len(temp_subscription_update_queue)}ê°œ êµ¬ë… ë‚´ì—­ ì—…ë°ì´íŠ¸\",\n                    body={\n                        \"temp_subscription_update_queue\": temp_subscription_update_queue\n                    },\n                )\n\n    def backup(self, table_name: str) -> None:\n        values = self.read(table_name)\n        self._client.backup(values)\n\n    def initialize_logs(self) -> None:\n        \"\"\"ë¡œê·¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.\"\"\"\n        open(\"store/logs.csv\", \"w\").close()\n\n    def initial_queue(self, *, queue: list, temp_queue: list) -> list:\n        \"\"\"queue ì—ì„œ temp_queue ë¥¼ ì œê±°í•œ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n        return [entry for entry in queue if entry not in temp_queue]\n"}
{"type": "source_file", "path": "app/slack_notification.py", "content": "from app.logging import logger\n\n\nfrom slack_sdk.web.async_client import AsyncWebClient\n\n\nfrom typing import Any\n\n\nasync def send_point_noti_message(\n    client: AsyncWebClient,\n    channel: str,\n    text: str,\n    **kwargs: Any,\n) -> None:\n    \"\"\"í¬ì¸íŠ¸ ì•Œë¦¼ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.\"\"\"\n    try:\n        await client.chat_postMessage(channel=channel, text=text)\n    except Exception as e:\n        kwargs_str = \", \".join([f\"{k}: {v}\" for k, v in kwargs.items()])\n        text = text.replace(\"\\n\", \" \")\n        logger.error(\n            f\"í¬ì¸íŠ¸ ì•Œë¦¼ ì „ì†¡ ì—ëŸ¬ ğŸ‘‰ error: {str(e)} :: channel(user_id): {channel} text: {text} {kwargs_str}\"\n        )\n        pass\n"}
{"type": "source_file", "path": "scripts/commit-msg-convention.py", "content": "#!/usr/bin/python3\n\nimport re\nimport sys\n\nCOMMIT_MESSAGE_REGEX = (\n    r'^((revert: \")?(feat|fix|docs|style|refactor|perf|test|ci|build|chore)'\n    r\"(\\(.*\\))?!?:\\s.{1,50})\"\n)\n\n\ndef valid_commit_message(message: str) -> bool:\n    \"\"\"\n    Function to validate the commit message\n    Args:\n        message (str): The message to validate\n    Returns:\n        bool: True for valid messages, False otherwise\n    \"\"\"\n    if not re.match(COMMIT_MESSAGE_REGEX, message):\n        print(\n            \"Proper commit message format is required for automated changelog\"\n            \"generation. Examples:\\n\\n\"\n        )\n        print(\"feat(compiler): add 'comments' option\")\n        print(\"fix(v-model): handle events on blur (close #28)\\n\\n\")\n        print(\"See COMMIT_CONVENTION from Notion for more details.\\n\")\n        print(\n            \"You can also use cz commit to interactively \"\n            \"generate a commit message.\\n\"\n        )\n        return False\n\n    print(\"Commit message is valid.\")\n    return True\n\n\ndef main() -> None:\n    \"\"\"Main function.\"\"\"\n    message_file = sys.argv[1]\n    try:\n        txt_file = open(message_file, \"r\")\n        commit_message = txt_file.read()\n    finally:\n        txt_file.close()\n\n    if not valid_commit_message(commit_message):\n        sys.exit(1)\n\n    sys.exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "app/slack/events/log.py", "content": "import csv\nfrom datetime import datetime, timedelta\nimport os\n\nfrom app.bigquery.queue import CommentDataType, EmojiDataType, PostDataType\nfrom app.constants import PRIMARY_CHANNEL\nfrom app.logging import log_event\nfrom app.slack_notification import send_point_noti_message\nfrom app.slack.repositories import SlackRepository\nfrom app.slack.services.point import PointService\nfrom app.slack.types import MessageBodyType, ReactionBodyType\nfrom app.bigquery import queue as bigquery_queue\nfrom app.config import settings\nfrom slack_bolt.async_app import AsyncAck\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom app.utils import tz_now_to_str\nfrom aiocache import cached\n\n\nasync def handle_comment_data(body: MessageBodyType) -> None:\n    data = CommentDataType(\n        user_id=body[\"event\"][\"user\"],\n        channel_id=body[\"event\"][\"channel\"],\n        ts=body[\"event\"][\"thread_ts\"],  # type: ignore\n        comment_ts=body[\"event\"][\"ts\"],\n        tddate=datetime.fromtimestamp(float(body[\"event\"][\"ts\"])).date(),\n        createtime=datetime.fromtimestamp(float(body[\"event\"][\"ts\"])),\n        text=body[\"event\"][\"text\"],\n    )\n    bigquery_queue.comments_upload_queue.append(data)\n\n\nasync def handle_post_data(body: MessageBodyType) -> None:\n    data = PostDataType(\n        user_id=body[\"event\"][\"user\"],\n        channel_id=body[\"event\"][\"channel\"],\n        ts=body[\"event\"][\"ts\"],\n        tddate=datetime.fromtimestamp(float(body[\"event\"][\"ts\"])).date(),\n        createtime=datetime.fromtimestamp(float(body[\"event\"][\"ts\"])),\n        text=body[\"event\"][\"text\"],\n    )\n    bigquery_queue.posts_upload_queue.append(data)\n\n\nasync def handle_reaction_added(\n    ack: AsyncAck,\n    body: ReactionBodyType,\n    client: AsyncWebClient,\n) -> None:\n    \"\"\"ë¦¬ì•¡ì…˜ ì¶”ê°€ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    data = EmojiDataType(\n        user_id=body[\"event\"][\"user\"],\n        channel_id=body[\"event\"][\"item\"][\"channel\"],\n        ts=body[\"event\"][\"item\"][\"ts\"],\n        reactions_ts=body[\"event\"][\"event_ts\"],\n        tddate=datetime.fromtimestamp(float(body[\"event\"][\"event_ts\"])).date(),\n        createtime=datetime.fromtimestamp(float(body[\"event\"][\"event_ts\"])),\n        reaction=body[\"event\"][\"reaction\"],\n    )\n    bigquery_queue.emojis_upload_queue.append(data)\n\n    # ê³µì§€ì‚¬í•­ì„ ì´ëª¨ì§€ë¡œ í™•ì¸í•˜ë©´ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\n    if (\n        body[\"event\"][\"item\"][\"channel\"] == settings.NOTICE_CHANNEL\n        and body[\"event\"][\"reaction\"] == \"noti-check\"\n    ):\n        channel_id = body[\"event\"][\"item\"][\"channel\"]\n        ts = body[\"event\"][\"item\"][\"ts\"]\n\n        if await _is_thread_message(\n            client=client,\n            channel_id=channel_id,\n            ts=ts,\n        ):\n            return\n\n        user_id = body[\"event\"][\"user\"]\n        notice_ts = body[\"event\"][\"item\"][\"ts\"]\n\n        if _is_checked_notice(user_id, notice_ts):\n            return\n\n        # ê³µì§€ì‚¬í•­ ë‚ ì§œê°€ 3ì¼ ë³´ë‹¤ ì´ì „ì´ë¼ë©´ íŒ¨ìŠ¤í•©ë‹ˆë‹¤.\n        if datetime.fromtimestamp(float(notice_ts)) < datetime.now() - timedelta(\n            days=3\n        ):\n            return\n\n        point_service = PointService(repo=SlackRepository())\n        text = point_service.grant_if_notice_emoji_checked(user_id=user_id)\n        await send_point_noti_message(\n            client=client,\n            channel=user_id,\n            text=text,\n            notice_ts=notice_ts,\n        )\n\n        _write_checked_notice(user_id, notice_ts)\n\n        log_event(\n            actor=user_id,\n            event=\"checked_notice\",\n            type=body[\"event\"][\"type\"],\n            description=\"ê³µì§€ì‚¬í•­ í™•ì¸\",\n            body=body,\n        )\n        return\n\n    # ì„±ìœ¤ë‹˜ì´ 1_ì±„ë„ì— ì œì¶œí•œ ê¸€ì— ì´ëª¨ì§€ë¥¼ ë‹¬ë©´ í¬ì¸íŠ¸ë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤.\n    if (\n        body[\"event\"][\"item\"][\"channel\"] in PRIMARY_CHANNEL\n        and body.get(\"event\", {}).get(\"item_user\") == settings.TTOBOT_USER_ID\n        and body[\"event\"][\"reaction\"] == \"catch-kyle\"\n    ):\n        user_id = body[\"event\"][\"user\"]\n        post_ts = body[\"event\"][\"item\"][\"ts\"]\n        channel_id = body[\"event\"][\"item\"][\"channel\"]\n\n        if _is_checked_super_admin_post(user_id, post_ts):\n            return\n\n        # ê¸€ ì œì¶œ ë‚ ì§œê°€ 1ì¼ ë³´ë‹¤ ì´ì „ì´ë¼ë©´ íŒ¨ìŠ¤í•©ë‹ˆë‹¤.\n        if datetime.fromtimestamp(float(post_ts)) < datetime.now() - timedelta(days=1):\n            return\n\n        content = SlackRepository().get_content_by(ts=post_ts)\n        if content is None or content.user_id != settings.SUPER_ADMIN:\n            return\n\n        point_service = PointService(repo=SlackRepository())\n        text = point_service.grant_if_super_admin_post_reacted(user_id=user_id)\n        await send_point_noti_message(\n            client=client,\n            channel=user_id,\n            text=text,\n            post_ts=post_ts,\n        )\n\n        _write_checked_super_admin_post(\n            user_id,\n            post_ts,\n            channel_id,\n        )\n\n        log_event(\n            actor=user_id,\n            event=\"reacted_super_admin_post\",\n            type=body[\"event\"][\"type\"],\n            description=\"'ì„±ìœ¤ì„ ì¡ì•„ë¼' ì„±ê³µ\",\n            body=body,\n        )\n\n\ndef _is_thread_message_cache_key_builder(func, *args, **kwargs):\n    # `args`ì—ì„œ `client`ë¥¼ ì œì™¸í•˜ê³  `channel_id`ì™€ `ts`ë§Œ ì‚¬ìš©í•´ í‚¤ë¥¼ ìƒì„±\n    if \"channel_id\" in kwargs and \"ts\" in kwargs:\n        channel_id = kwargs[\"channel_id\"]\n        ts = kwargs[\"ts\"]\n    else:\n        # ìœ„ì¹˜ ì¸ìë¥¼ ì‚¬ìš©í•  ë•Œ `args`ì—ì„œ ë‘ ë²ˆì§¸ì™€ ì„¸ ë²ˆì§¸ ì¸ì ì‚¬ìš©\n        channel_id = args[1]\n        ts = args[2]\n    return f\"{func.__name__}:{channel_id}:{ts}\"\n\n\n@cached(ttl=60, key_builder=_is_thread_message_cache_key_builder)\nasync def _is_thread_message(client: AsyncWebClient, channel_id: str, ts: str) -> bool:\n    \"\"\"\n    ë©”ì‹œì§€ê°€ ìŠ¤ë ˆë“œ ë©”ì‹œì§€ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.\n    ìºì‹œë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ì¼í•œ ë©”ì‹œì§€ì— ëŒ€í•œ ì¤‘ë³µ ìš”ì²­ì„ ë°©ì§€í•©ë‹ˆë‹¤.\n    ìºì‹œë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ìŠ¬ë™ APIì˜ ì œí•œ ë•Œë¬¸ì…ë‹ˆë‹¤.\n    conversations_replies(Web API Tier 3): 50+ per minute limit\n    \"\"\"\n    res = await client.conversations_replies(channel=channel_id, ts=ts)\n    messages: list[dict] = res.get(\"messages\", [])\n    for message in messages:\n        # ëŒ€ìƒ ë©”ì‹œì§€ë¥¼ ì°¾ìŠµë‹ˆë‹¤.\n        if message[\"ts\"] == ts:\n            thread_ts = message.get(\"thread_ts\")\n\n            # thread_ts ê°€ ì—†ë‹¤ë©´ ì¼ë°˜ ë©”ì‹œì§€ ì…ë‹ˆë‹¤. ë‹¨, ëŒ“ê¸€ì´ ìˆë‹¤ë©´ thread_ts ê°€ ìˆìŠµë‹ˆë‹¤.\n            if not thread_ts:\n                return False\n\n            # thread_ts ê°€ ëŒ€ìƒ ts ì™€ ì¼ì¹˜í•˜ë©´ ìŠ¤ë ˆë“œ ë©”ì‹œì§€ê°€ ì•„ë‹Œ ëŒ“ê¸€ì´ ìˆëŠ” ì¼ë°˜ ë©”ì‹œì§€ì…ë‹ˆë‹¤.\n            if thread_ts == ts:\n                return False\n\n            # thread_ts ê°€ ëŒ€ìƒ ts ì™€ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì¼ë°˜ ë©”ì‹œì§€ê°€ ì•„ë‹Œ ìŠ¤ë ˆë“œ ë©”ì‹œì§€ì…ë‹ˆë‹¤.\n            else:\n                return True\n\n    return False\n\n\ndef _is_checked_notice(user_id: str, notice_ts: str) -> bool:\n    \"\"\"ì´ì „ì— ê³µì§€ë¥¼ í™•ì¸í•œ ì ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.\"\"\"\n    file_path = \"store/_checked_notice.csv\"\n    file_exists = os.path.isfile(file_path)\n\n    if file_exists:\n        with open(file_path) as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                if row[\"user_id\"] == user_id and row[\"notice_ts\"] == notice_ts:\n                    return True\n\n    return False\n\n\ndef _write_checked_notice(user_id: str, notice_ts: str) -> None:\n    \"\"\"ê³µì§€ í™•ì¸ ê¸°ë¡ì„ ì €ì¥í•©ë‹ˆë‹¤.\"\"\"\n    # ê³µì§€ í™•ì¸ ê¸°ë¡ì€ ìŠ¤í”„ë ˆë“œì‹œíŠ¸ì— ì—…ë¡œë“œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ ê²½ìš° íŒŒì¼ëª… ì•ì— _ë¥¼ ë¶™ì…ë‹ˆë‹¤.\n    file_path = \"store/_checked_notice.csv\"\n    file_exists = os.path.isfile(file_path)\n\n    with open(file_path, \"a\", newline=\"\", encoding=\"utf-8\") as f:\n        writer = csv.DictWriter(\n            f,\n            fieldnames=[\"user_id\", \"notice_ts\", \"created_at\"],\n            quoting=csv.QUOTE_ALL,\n        )\n\n        if not file_exists:\n            writer.writeheader()\n\n        writer.writerow(\n            {\n                \"user_id\": user_id,\n                \"notice_ts\": notice_ts,\n                \"created_at\": tz_now_to_str(),\n            }\n        )\n\n\ndef _is_checked_super_admin_post(user_id: str, post_id: str) -> bool:\n    \"\"\"ì´ì „ì— ì„±ìœ¤ë‹˜ ê¸€ì„ í™•ì¸í•œ ì ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.\"\"\"\n    file_path = \"store/_checked_super_admin_post.csv\"\n    file_exists = os.path.isfile(file_path)\n\n    if file_exists:\n        with open(file_path) as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                if row[\"user_id\"] == user_id and row[\"post_id\"] == post_id:\n                    return True\n\n    return False\n\n\ndef _write_checked_super_admin_post(\n    user_id: str, post_id: str, channel_id: str\n) -> None:\n    \"\"\"ì„±ìœ¤ë‹˜ ê¸€ í™•ì¸ ê¸°ë¡ì„ ì €ì¥í•©ë‹ˆë‹¤.\"\"\"\n    # ì´ ê¸°ë¡ì€ ìŠ¤í”„ë ˆë“œì‹œíŠ¸ì— ì—…ë¡œë“œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ ê²½ìš° íŒŒì¼ëª… ì•ì— _ë¥¼ ë¶™ì…ë‹ˆë‹¤.\n    file_path = \"store/_checked_super_admin_post.csv\"\n    file_exists = os.path.isfile(file_path)\n\n    with open(file_path, \"a\", newline=\"\", encoding=\"utf-8\") as f:\n        writer = csv.DictWriter(\n            f,\n            fieldnames=[\"user_id\", \"post_id\", \"channel_id\", \"created_at\"],\n            quoting=csv.QUOTE_ALL,\n        )\n\n        if not file_exists:\n            writer.writeheader()\n\n        writer.writerow(\n            {\n                \"user_id\": user_id,\n                \"post_id\": post_id,\n                \"channel_id\": channel_id,\n                \"created_at\": tz_now_to_str(),\n            }\n        )\n\n\nasync def handle_reaction_removed(\n    ack: AsyncAck,\n    body: ReactionBodyType,\n):\n    \"\"\"ë¦¬ì•¡ì…˜ ì‚­ì œ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n"}
{"type": "source_file", "path": "app/slack/services/__init__.py", "content": ""}
{"type": "source_file", "path": "app/slack/services/base.py", "content": "from datetime import datetime, timedelta\nimport random\nimport re\nfrom typing import Any\nfrom zoneinfo import ZoneInfo\n\nimport httpx\nfrom app.constants import URL_REGEX\nfrom app.logging import logger\nfrom app.exception import BotException, ClientException\nfrom app.slack.repositories import SlackRepository\nfrom app import models\nfrom app import store\nfrom app.constants import paper_plane_color_maps\n\nfrom bs4 import BeautifulSoup\n\nfrom app.utils import tz_now, tz_now_to_str\n\n\nclass SlackService:\n    def __init__(self, repo: SlackRepository, user: models.User) -> None:\n        self._repo = repo\n        self._user = user\n\n    def fetch_contents(\n        self,\n        keyword: str | None = None,\n        name: str | None = None,\n        category: str = \"ì „ì²´\",\n    ) -> list[models.Content]:\n        \"\"\"ì½˜í…ì¸ ë¥¼ ì¡°ê±´ì— ë§ì¶° ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        if keyword:\n            contents = self._repo.fetch_contents_by_keyword(keyword)\n        else:\n            contents = self._repo.fetch_contents()\n\n        if name:\n            user_ids = self._repo.fetch_user_ids_by_name(name)\n            contents = [content for content in contents if content.user_id in user_ids]\n\n        if category != \"ì „ì²´\":\n            contents = [content for content in contents if content.category == category]\n\n        return contents\n\n    def get_user(self, user_id) -> models.User:\n        \"\"\"ìœ ì €ì™€ ì½˜í…ì¸  ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        user = self._repo.get_user(user_id)\n        if not user:\n            raise BotException(\"í•´ë‹¹ ìœ ì € ì •ë³´ê°€ ì—†ì–´ìš”.\")\n        return user\n\n    def get_only_user(self, user_id) -> models.User:\n        \"\"\"ìœ ì € ì •ë³´ë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        user = self._repo.get_only_user(user_id)\n        if not user:\n            raise BotException(\"í•´ë‹¹ ìœ ì € ì •ë³´ê°€ ì—†ì–´ìš”.\")\n        return user\n\n    async def create_submit_content(\n        self,\n        title: str,\n        content_url: str,\n        username: str,\n        view: dict[str, Any],\n    ) -> models.Content:\n        \"\"\"ì œì¶œ ì½˜í…ì¸ ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        content = models.Content(\n            user_id=self._user.user_id,\n            username=username,\n            title=title,\n            content_url=content_url,\n            category=self._get_category(view),\n            description=self._get_description(view),\n            type=\"submit\",\n            tags=self._get_tags(view),\n            curation_flag=self._get_curation_flag(view),\n            feedback_intensity=self._get_feedback_intensity(view),\n        )\n        return content\n\n    async def update_user_content(self, content: models.Content) -> None:\n        \"\"\"ìœ ì €ì˜ ì½˜í…ì¸ ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.\"\"\"\n        self._user.contents.append(content)\n        self._repo.update(self._user)\n\n    async def create_pass_content(self, ack, body, view) -> models.Content:\n        \"\"\"íŒ¨ìŠ¤ ì½˜í…ì¸ ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        content = models.Content(\n            user_id=body[\"user\"][\"id\"],\n            username=body[\"user\"][\"username\"],\n            description=self._get_description(view),\n            type=\"pass\",\n        )\n        return content\n\n    def get_chat_message(self, content: models.Content) -> str:\n        if content.type == \"submit\":\n            title = content.title.replace(\"\\n\", \" \")\n            message = f\"\\n>>>ğŸ‰ *<@{content.user_id}>ë‹˜ ì œì¶œ ì™„ë£Œ.*\\\n                {self._description_message(content.description)}\\\n                \\në§í¬ : *<{content.content_url}|{re.sub('<|>', '', title if content.title != 'title unknown.' else content.content_url)}>*\\\n                \\nì¹´í…Œê³ ë¦¬ : {content.category}\\\n                {self._tag_message(content.tags)}\"  # noqa E501\n        else:\n            message = f\"\\n>>>ğŸ™ğŸ¼ *<@{content.user_id}>ë‹˜ íŒ¨ìŠ¤ ì™„ë£Œ.*\\\n                {self._description_message(content.description)}\"\n        return message\n\n    def _get_description(self, view) -> str:\n        description: str = view[\"state\"][\"values\"][\"description\"][\"text_input\"][\"value\"]\n        if not description:\n            return \"\"\n        return description\n\n    def _get_tags(self, view) -> str:\n        raw_tag: str = view[\"state\"][\"values\"][\"tag\"][\"tags_input\"][\"value\"]\n        if not raw_tag:\n            return \"\"\n        deduplication_tags = list(dict.fromkeys(raw_tag.split(\",\")))\n        tags = \",\".join(tag.strip() for tag in deduplication_tags if tag)\n        return tags\n\n    def _get_category(self, view) -> str:\n        category: str = view[\"state\"][\"values\"][\"category\"][\"category_select\"][\n            \"selected_option\"\n        ][\"value\"]\n        return category\n\n    def _get_curation_flag(self, view) -> str:\n        curation_flag: str = view[\"state\"][\"values\"][\"curation\"][\"curation_select\"][\n            \"selected_option\"\n        ][\"value\"]\n        return curation_flag\n\n    def _get_feedback_intensity(self, view) -> str:\n        feedback_intensity: str = view[\"state\"][\"values\"][\"feedback_intensity\"][\n            \"feedback_intensity_select\"\n        ][\"selected_option\"][\"value\"]\n        return feedback_intensity\n\n    async def get_title(self, view, url: str) -> str:\n\n        try:\n            async with httpx.AsyncClient() as client:\n                response = await client.get(url)\n                if response.status_code == 404:\n                    raise ClientException(\n                        f\"ë¹„ê³µê°œ ê¸€ì´ê±°ë‚˜, urlì„ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”. ìƒíƒœ ì½”ë“œ : {response.status_code}\"\n                    )\n                if response.status_code >= 400:\n                    raise ClientException(\n                        f\"urlì— ë¬¸ì œê°€ ìˆì–´ í™•ì¸ì´ í•„ìš”í•´ìš”. ìƒíƒœ ì½”ë“œ : {response.status_code}\"\n                    )\n\n            # ì œëª©ì„ ì§ì ‘ ì…ë ¥í•œ ê²½ìš°ì—ëŠ” status_codeë§Œ í™•ì¸ í›„ì— return\n            title_input = view[\"state\"][\"values\"][\"manual_title_input\"][\"title_input\"][\n                \"value\"\n            ]\n            if title_input:\n                return title_input\n\n            soup = BeautifulSoup(response.content, \"html.parser\", from_encoding=\"utf-8\")\n            title = soup.find(\"title\")\n            if not title:\n                raise ClientException(\n                    \"'ê¸€ ì œëª©'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ëª¨ë‹¬ í•˜ë‹¨ì— ì§ì ‘ ì…ë ¥í•´ì£¼ì„¸ìš”.\"\n                )\n            return title.text.strip()\n\n        except ClientException as e:\n            raise e\n        except Exception as e:\n            logger.debug(str(e))\n            raise ClientException(\"url ì— ë¬¸ì œê°€ ìˆì–´ìš”. í™•ì¸ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.\")\n\n    def _description_message(self, description: str) -> str:\n        description_message = f\"\\n\\nğŸ’¬ '{description}'\\n\" if description else \"\"\n        return description_message\n\n    def _tag_message(self, tag: str) -> str:\n        tag_message = (\n            \"\\níƒœê·¸ : \" + \" \".join([f\"`{t.strip()}`\" for t in tag.split(\",\")])\n            if tag\n            else \"\"\n        )\n        return tag_message\n\n    def validate_url(self, view, content_url: str) -> None:\n        if not re.match(URL_REGEX, content_url):\n            raise ValueError(\"ë§í¬ëŠ” url í˜•ì‹ì´ì–´ì•¼ í•´ìš”.\")\n\n        try:\n            content = self.get_content_by(content_url=content_url)\n            if content:\n                raise ValueError(\"ì´ë¯¸ ì œì¶œí•œ url ì´ì—ìš”.\")\n        except BotException:\n            # ì¡´ì¬í•˜ì§€ ì•ŠëŠ” url ì¸ ê²½ìš° í†µê³¼\n            pass\n\n        if \"tistory.com/manage/posts\" in content_url:\n            # í‹°ìŠ¤í† ë¦¬ posts í˜ì´ì§€ëŠ” ê¸€ ë§í¬ê°€ ì•„ë‹ˆë¯€ë¡œ ì œì™¸í•©ë‹ˆë‹¤.\n            raise ValueError(\"ì ê¹! ì…ë ¥í•œ ë§í¬ê°€ 'ê¸€ ë§í¬'ê°€ ë§ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.\")\n        if \"blog.naver.com\" in content_url and \"redirect\" in content_url.lower():\n            # ë„¤ì´ë²„ ë¸”ë¡œê·¸ ë¦¬ë‹¤ì´ë ‰íŠ¸ ë§í¬ëŠ” ê¸€ ë§í¬ê°€ ì•„ë‹ˆë¯€ë¡œ ì œì™¸í•©ë‹ˆë‹¤.\n            raise ValueError(\n                \"ì ê¹! ì…ë ¥í•œ ë§í¬ëŠ” ë¦¬ë‹¤ì´ë ‰íŠ¸ ë§í¬ì…ë‹ˆë‹¤. ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”.\"\n            )\n        if (\n            \"notion.\" in content_url\n            or \"oopy.io\" in content_url\n            or \".site\" in content_url\n            or \"blog.naver\" in content_url\n        ):\n            # notion.so, notion.site, oopy.io ëŠ” title ì„ í¬ë¡¤ë§í•˜ì§€ ëª»í•˜ë¯€ë¡œ ì§ì ‘ ì…ë ¥ì„ ë°›ëŠ”ë‹¤.\n            # blog.naver ëŠ” title íƒœê·¸ì— ë¸”ë¡œê·¸ íƒ€ì´í‹€ì´ ë“¤ì–´ì˜¤ê¸° ë•Œë¬¸ì— ê¸€ ì œëª©ì„ ì§ì ‘ ì…ë ¥ì„ ë°›ëŠ”ë‹¤.\n            # ê¸€ ì œëª©ì„ ì…ë ¥í•œ ê²½ìš° í†µê³¼.\n            if (\n                view[\"state\"][\"values\"]\n                .get(\"manual_title_input\", {})\n                .get(\"title_input\", {})\n                .get(\"value\")\n            ):\n                return None\n            raise ValueError(\n                \"ë…¸ì…˜ ë˜ëŠ” ë„¤ì´ë²„ ë§í¬ëŠ” í•˜ë‹¨ 'ê¸€ ì œëª©'ì„ í•„ìˆ˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.\"\n            )\n\n    def create_bookmark(\n        self,\n        user_id: str,\n        content_user_id: str,\n        content_ts: str,\n        note: str = \"\",\n    ) -> models.Bookmark:\n        \"\"\"ë¶ë§ˆí¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        bookmark = models.Bookmark(\n            user_id=user_id,\n            content_user_id=content_user_id,\n            content_ts=content_ts,\n            note=note,\n        )\n        self._repo.create_bookmark(bookmark)\n        store.bookmark_upload_queue.append(bookmark.to_list_for_sheet())\n        return bookmark\n\n    def get_bookmark(self, user_id: str, content_ts: str) -> models.Bookmark | None:\n        \"\"\"ë¶ë§ˆí¬ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        bookmark = self._repo.get_bookmark(user_id, content_ts)\n        return bookmark\n\n    def fetch_bookmarks(self, user_id: str) -> list[models.Bookmark]:\n        \"\"\"ìœ ì €ì˜ ë¶ë§ˆí¬ë¥¼ ëª¨ë‘ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        # TODO: í‚¤ì›Œë“œë¡œ ê²€ìƒ‰ ê¸°ëŠ¥ ì¶”ê°€\n        bookmarks = self._repo.fetch_bookmarks(user_id)\n        return bookmarks\n\n    def fetch_contents_by_ids(\n        self, content_ids: list[str], keyword: str = \"\"\n    ) -> list[models.Content]:\n        \"\"\"ì»¨í…ì¸  ì•„ì´ë””ë¡œ Contents ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        if keyword:\n            contents = self._repo.fetch_contents_by_keyword(keyword)\n        else:\n            contents = self._repo.fetch_contents()\n        return [content for content in contents if content.ts in content_ids]\n\n    def update_bookmark(\n        self,\n        user_id: str,\n        content_ts: str,\n        new_note: str = \"\",\n        new_status: models.BookmarkStatusEnum = models.BookmarkStatusEnum.ACTIVE,\n    ) -> None:\n        \"\"\"ë¶ë§ˆí¬ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.\"\"\"\n        # TODO: ë¶ë§ˆí¬ ì‚­ì œì™€ ìˆ˜ì • ë¶„ë¦¬í•  ê²ƒ\n        self._repo.update_bookmark(content_ts, new_note, new_status)\n        bookmark = self._repo.get_bookmark(user_id, content_ts, status=new_status)\n        if bookmark:\n            store.bookmark_update_queue.append(bookmark)\n\n    def update_user_intro(\n        self,\n        user_id: str,\n        new_intro: str,\n    ) -> None:\n        \"\"\"ì‚¬ìš©ìì˜ ìê¸°ì†Œê°œë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.\"\"\"\n        if self._user.user_id != user_id:\n            raise BotException(\"ë³¸ì¸ì˜ ìê¸°ì†Œê°œë§Œ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\")\n        self._repo.update_user_intro(user_id, new_intro)\n\n    def fetch_users(self) -> list[models.User]:\n        users = [models.User(**user) for user in self._repo._fetch_users()]\n        return users\n\n    def get_content_by(\n        self,\n        *,\n        ts: str | None = None,\n        user_id: str | None = None,\n        dt: str | None = None,\n        content_url: str | None = None,\n    ) -> models.Content:\n        content = self._repo.get_content_by(\n            ts=ts,\n            user_id=user_id,\n            dt=dt,\n            content_url=content_url,\n        )\n        if not content:\n            raise BotException(\"í•´ë‹¹ ì½˜í…ì¸  ì •ë³´ê°€ ì—†ì–´ìš”.\")\n\n        return content\n\n    def fetch_coffee_chat_proofs(\n        self,\n        user_id: str,\n    ) -> list[models.CoffeeChatProof]:\n        \"\"\"ì»¤í”¼ì±— ì¸ì¦ ë‚´ì—­ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        return self._repo.fetch_coffee_chat_proofs(user_id=user_id)\n\n    def create_coffee_chat_proof(\n        self,\n        ts: str,\n        thread_ts: str,\n        user_id: str,\n        text: str,\n        files: list[dict[str, Any]],\n        selected_user_ids: str,\n        participant_call_thread_ts: str = \"\",\n    ) -> models.CoffeeChatProof:\n        \"\"\"ì»¤í”¼ì±— ì¸ì¦ê¸€ì„ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        try:\n            image_urls = \",\".join(file[\"url_private\"] for file in files)\n        except KeyError:\n            image_urls = \"\"\n\n        coffee_chat_proof = models.CoffeeChatProof(\n            ts=ts,\n            thread_ts=thread_ts,\n            user_id=user_id,\n            text=text,\n            image_urls=image_urls,\n            selected_user_ids=selected_user_ids,\n            participant_call_thread_ts=participant_call_thread_ts,\n        )\n        self._repo.create_coffee_chat_proof(coffee_chat_proof)\n        store.coffee_chat_proof_upload_queue.append(\n            coffee_chat_proof.to_list_for_sheet()\n        )\n        return coffee_chat_proof\n\n    def check_coffee_chat_proof(\n        self,\n        thread_ts: str,\n        user_id: str,\n    ) -> None:\n        \"\"\"\n        ì»¤í”¼ì±— ì¸ì¦ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.\n\n        1. ìŠ¤ë ˆë“œì˜ ìƒìœ„ ë©”ì‹œì§€(thread_ts)ë¡œ ê¸°ì¡´ ì»¤í”¼ì±— ì¸ì¦ ê¸€(ts)ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´, ì¸ì¦í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n        2. ì¸ì¦ ëŒ€ìƒì ëª©ë¡(selected_user_ids)ì— í•´ë‹¹ ì‚¬ìš©ìì˜ user_idê°€ í¬í•¨ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´, ì¸ì¦í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n        3. ë™ì¼í•œ user_idë¡œ ì´ë¯¸ ì»¤í”¼ì±— ì¸ì¦ì´ ë˜ì–´ ìˆëŠ” ê²½ìš°, ì¤‘ë³µ ì¸ì¦ì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n        \"\"\"\n        parent_proof = self._repo.get_coffee_chat_proof(ts=thread_ts)\n        if not parent_proof:\n            raise BotException(\"ì»¤í”¼ì±— ì¸ì¦ê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”.\")\n\n        if user_id not in parent_proof.selected_user_ids:\n            raise BotException(\"ì»¤í”¼ì±— ì¸ì¦ ëŒ€ìƒì´ ì•„ë‹ˆì—ìš”.\")\n\n        proofs = self._repo.fetch_coffee_chat_proofs(thread_ts=thread_ts)\n        for proof in proofs:\n            if proof.user_id == user_id:\n                raise BotException(\"ì´ë¯¸ ë‹µê¸€ë¡œ ì»¤í”¼ì±—ì„ ì¸ì¦í–ˆì–´ìš”.\")\n\n    def create_paper_plane(\n        self,\n        *,\n        sender: models.User,\n        receiver: models.User,\n        text: str,\n    ) -> models.PaperPlane:\n        \"\"\"ë¦¬ì•¡ì…˜ì„ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        color_map = random.choice(paper_plane_color_maps)\n        model = models.PaperPlane(\n            sender_id=sender.user_id,\n            sender_name=sender.name,\n            receiver_id=receiver.user_id,\n            receiver_name=receiver.name,\n            text=text,\n            text_color=color_map[\"text_color\"],\n            bg_color=color_map[\"bg_color\"],\n            color_label=color_map[\"color_label\"],\n        )\n        self._repo.create_paper_plane(model)\n        store.paper_plane_upload_queue.append(model.to_list_for_sheet())\n        return model\n\n    def fetch_current_week_paper_planes(\n        self,\n        user_id: str,\n    ) -> list[models.PaperPlane]:\n        \"\"\"ì´ë²ˆ ì£¼ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        today = tz_now()\n\n        # ì§€ë‚œì£¼ í† ìš”ì¼ 00ì‹œ ê³„ì‚°\n        last_saturday = today - timedelta(days=(today.weekday() + 2) % 7)\n        start_dt = last_saturday.replace(hour=0, minute=0, second=0, microsecond=0)\n\n        # ì´ë²ˆì£¼ ê¸ˆìš”ì¼ 23:59:59 ê³„ì‚°\n        this_friday = start_dt + timedelta(days=6)\n        end_dt = this_friday.replace(hour=23, minute=59, second=59, microsecond=999999)\n\n        paper_planes = []\n        for plane in self._repo.fetch_paper_planes(sender_id=user_id):\n            plane_created_ad = datetime.fromisoformat(plane.created_at).replace(\n                tzinfo=ZoneInfo(\"Asia/Seoul\")\n            )\n            if start_dt <= plane_created_ad <= end_dt:\n                paper_planes.append(plane)\n\n        return paper_planes\n\n    def fetch_subscriptions_by_user_id(\n        self,\n        user_id: str,\n    ) -> list[models.Subscription]:\n        \"\"\"ìœ ì €ì˜ êµ¬ë… ë‚´ì—­ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        return self._repo.fetch_subscriptions_by_user_id(user_id)\n\n    def fetch_subscriptions_by_target_user_id(\n        self,\n        target_user_id: str,\n    ) -> list[models.Subscription]:\n        \"\"\"íƒ€ê²Ÿ ìœ ì €ì˜ êµ¬ë… ë‚´ì—­ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        return self._repo.fetch_subscriptions_by_target_user_id(target_user_id)\n\n    def create_subscription(\n        self, user_id: str, target_user_id: str, target_user_channel: str\n    ) -> models.Subscription:\n        \"\"\"êµ¬ë…ì„ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n        subscription = models.Subscription(\n            user_id=user_id,\n            target_user_id=target_user_id,\n            target_user_channel=target_user_channel,\n        )\n        self._repo.create_subscription(subscription)\n        store.subscription_upload_queue.append(subscription.to_list_for_sheet())\n        return subscription\n\n    def get_subscription(self, subscription_id: str) -> models.Subscription | None:\n        \"\"\"êµ¬ë…ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.\"\"\"\n        return self._repo.get_subscription(subscription_id)\n\n    def cancel_subscription(self, subscription_id: str) -> None:\n        \"\"\"êµ¬ë…ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.\"\"\"\n        self._repo.cancel_subscription(subscription_id)\n        subscription = self._repo.get_subscription(\n            subscription_id, status=models.SubscriptionStatusEnum.CANCELED\n        )\n        if subscription:\n            subscription.updated_at = tz_now_to_str()\n            store.subscription_update_queue.append(subscription.model_dump())\n"}
{"type": "source_file", "path": "app/slack/events/core.py", "content": "import asyncio\nimport csv\nimport os\nfrom typing import TypedDict\nimport tenacity\nimport pandas as pd\n\nfrom app.client import SpreadSheetClient\nfrom app.config import settings\nfrom app.constants import BOT_IDS\nfrom app.models import CoffeeChatProof, Content, PointHistory, User\nfrom app.slack.services.base import SlackService\nfrom app.slack.services.point import PointMap, PointService\nfrom app.slack.types import (\n    ActionBodyType,\n    AppMentionBodyType,\n    ChannelCreatedBodyType,\n    CommandBodyType,\n    HomeTabEventType,\n    ViewBodyType,\n    ViewType,\n)\nfrom app.store import Store\n\nfrom slack_sdk.models.blocks import (\n    Block,\n    Option,\n    StaticSelectElement,\n    SectionBlock,\n    DividerBlock,\n    ActionsBlock,\n    ButtonElement,\n    PlainTextInputElement,\n    ChannelMultiSelectElement,\n    UserSelectElement,\n    InputBlock,\n    TextObject,\n    HeaderBlock,\n    ContextBlock,\n    MarkdownTextObject,\n)\nfrom slack_sdk.models.views import View\nfrom slack_bolt.async_app import AsyncAck, AsyncSay\nfrom slack_sdk.web.async_client import AsyncWebClient\nfrom slack_sdk.errors import SlackApiError\n\nfrom app.utils import ts_to_dt\n\n\nasync def handle_app_mention(\n    ack: AsyncAck,\n    body: AppMentionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n) -> None:\n    \"\"\"ì•± ë©˜ì…˜ í˜¸ì¶œ ì‹œ ë„ì›€ë§ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n\nasync def open_deposit_view(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì˜ˆì¹˜ê¸ˆì„ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    if not user.deposit:\n        text = \"í˜„ì¬ ì˜ˆì¹˜ê¸ˆ í™•ì¸ ì¤‘ì´ì—ìš”.\"\n    else:\n        # ë‚¨ì€ íŒ¨ìŠ¤ ìˆ˜\n        remained_pass_count = 2\n        remained_pass_count -= user.pass_count\n\n        # ë¯¸ì œì¶œ ìˆ˜\n        submit_status = user.get_submit_status()\n        not_submitted_count = list(submit_status.values()).count(\"ë¯¸ì œì¶œ\")\n\n        # ì»¤í”¼ì±— ì¸ì¦ ìˆ˜\n        coffee_chat_proofs = service.fetch_coffee_chat_proofs(user_id=user.user_id)\n        coffee_chat_proofs_count = len(coffee_chat_proofs)\n\n        text = (\n            f\"{user.name[1:]}ë‹˜ì˜ í˜„ì¬ ë‚¨ì€ ì˜ˆì¹˜ê¸ˆì€ {format(int(user.deposit), ',d')} ì› ì´ì—ìš”.\"\n            + f\"\\n\\n- ë‚¨ì€ íŒ¨ìŠ¤ ìˆ˜ : {remained_pass_count} ê°œ\"\n            + f\"\\n- ê¸€ ë¯¸ì œì¶œ ìˆ˜ : {not_submitted_count} ê°œ\"\n            + f\"\\n- ì»¤í”¼ì±— ì¸ì¦ ìˆ˜ : {coffee_chat_proofs_count} ê°œ\"\n            # + f\"\\në°˜ìƒíšŒ ì°¸ì—¬ : (ì¶”í›„ ì œê³µ ì˜ˆì •)\"  # TODO: ì¶”í›„ ë°˜ìƒíšŒ ì°¸ì—¬ ì‹œ ì˜ˆì¹˜ê¸ˆì— ë³€ë™ì´ ìˆë‹¤ë©´ ì¶”ê°€. (ëª¨ì„ í¬ë£¨ì—ì„œ ê²°ì •)\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{user.name}ë‹˜ì˜ ì˜ˆì¹˜ê¸ˆ í˜„í™©\",\n            close=\"ë‹«ê¸°\",\n            blocks=[\n                SectionBlock(text=text),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=\"ê¸€ ë¯¸ì œì¶œ ì‹œ ì˜ˆì¹˜ê¸ˆ 10,000ì›ì´ ì°¨ê°ë©ë‹ˆë‹¤.\"\n                            \"\\nì»¤í”¼ì±— ì¸ì¦ ì‹œ 1íšŒë‹¹ ì˜ˆì¹˜ê¸ˆ 5,000ì›ì´ ë”í•´ì§‘ë‹ˆë‹¤. (ìµœëŒ€ 2íšŒ)\",\n                        ),\n                    ]\n                ),\n            ],\n        ),\n    )\n\n\nasync def open_submission_history_view(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì œì¶œ ë‚´ì—­ì„ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    round, due_date = user.get_due_date()\n    guide_message = f\"\\ní˜„ì¬ íšŒì°¨ëŠ” {round}íšŒì°¨, ë§ˆê°ì¼ì€ {due_date} ì´ì—ìš”.\"\n    header_blocks = [SectionBlock(text={\"type\": \"mrkdwn\", \"text\": guide_message})]\n\n    blocks: list[Block] = []\n    max_items = 12\n    for content in user.fetch_contents(descending=True)[:max_items]:\n        blocks.append(DividerBlock())\n        round = content.get_round()\n        if content.type == \"submit\":\n            submit_head = f\"âœ…  *{round}íšŒì°¨ ì œì¶œ*  |  {content.dt}\"\n            blocks.append(\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": f\"{submit_head}\\në§í¬ - *<{content.content_url}|{content.title}>*\",\n                    }\n                )\n            )\n        else:  # íŒ¨ìŠ¤ì¸ ê²½ìš°\n            pass_head = f\"â–¶ï¸  *{round}íšŒì°¨ íŒ¨ìŠ¤*  |  {content.dt}\"\n            blocks.append(\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": pass_head,\n                    }\n                )\n            )\n\n    footer_blocks = []\n    if blocks:\n        footer_blocks = [\n            DividerBlock(),\n            SectionBlock(\n                text=\"ê¸€ ì œì¶œ ë‚´ì—­ì€ ìµœê·¼ 12ê°œê¹Œì§€ë§Œ í‘œì‹œë©ë‹ˆë‹¤.\\nì „ì²´ ë‚´ì—­ì„ í™•ì¸í•˜ë ¤ë©´ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.\",\n            ),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"ì „ì²´ ë‚´ì—­ ë‹¤ìš´ë¡œë“œ\",\n                        action_id=\"download_submission_history\",\n                        value=\"download_submission_history\",\n                        style=\"primary\",\n                    ),\n                ],\n            ),\n        ]\n    else:\n        blocks.append(\n            SectionBlock(text={\"type\": \"mrkdwn\", \"text\": \"ê¸€ ì œì¶œ ë‚´ì—­ì´ ì—†ì–´ìš”.\"})\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title={\"type\": \"plain_text\", \"text\": f\"{user.name}ë‹˜ì˜ ê¸€ ì œì¶œ ë‚´ì—­\"},\n            close={\"type\": \"plain_text\", \"text\": \"ë‹«ê¸°\"},\n            blocks=header_blocks + blocks + footer_blocks,\n        ),\n    )\n\n\nasync def download_submission_history(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ê¸€ ì œì¶œ ë‚´ì—­ì„ CSV íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    response = await client.conversations_open(users=user.user_id)\n    dm_channel_id = response[\"channel\"][\"id\"]\n\n    contents = user.fetch_contents()\n    if not contents:\n        await client.chat_postMessage(\n            channel=dm_channel_id, text=\"ê¸€ ì œì¶œ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.1\"\n        )\n        return None\n\n    # ì‚¬ìš©ìì˜ ì œì¶œë‚´ì—­ì„ CSV íŒŒì¼ë¡œ ì„ì‹œ ì €ì¥ í›„ ì „ì†¡\n    temp_dir = \"temp/submission_histories\"\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir)\n\n    temp_file_path = f\"{temp_dir}/{user.name}-ê¸€-ì œì¶œ-ë‚´ì—­.csv\"\n    with open(temp_file_path, \"w\", newline=\"\") as csvfile:\n        writer = csv.DictWriter(\n            csvfile,\n            Content.fieldnames(),\n            quoting=csv.QUOTE_ALL,\n        )\n        writer.writeheader()\n        writer.writerows([each.model_dump() for each in contents])\n\n    res = await client.files_upload_v2(\n        channel=dm_channel_id,  #####\n        file=temp_file_path,\n        initial_comment=f\"<@{user.user_id}> ë‹˜ì˜ ê¸€ ì œì¶œ ë‚´ì—­ ì…ë‹ˆë‹¤.\",\n    )\n\n    await client.chat_postMessage(\n        channel=dm_channel_id,\n        text=f\"<@{user.user_id}> ë‹˜ì˜ <{res['file']['permalink']}|ê¸€ ì œì¶œ ë‚´ì—­> ì…ë‹ˆë‹¤.\",\n    )\n\n    # ì„ì‹œë¡œ ìƒì„±í•œ CSV íŒŒì¼ì„ ì‚­ì œ\n    os.remove(temp_file_path)\n\n\nasync def open_help_view(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë„ì›€ë§ì„ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title={\"type\": \"plain_text\", \"text\": \"ë˜ë´‡ ë„ì›€ë§\"},\n            close={\"type\": \"plain_text\", \"text\": \"ë‹«ê¸°\"},\n            blocks=[\n                # ì¸ì‚¬ë§ ì„¹ì…˜\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"ğŸ‘‹ğŸ¼ *ë°˜ê°€ì›Œìš”!*\\nì €ëŠ” ê¸€ë˜ í™œë™ì„ ë„ì™€ì£¼ëŠ” *ë˜ë´‡* ì´ì—ìš”. \"\n                        \"ì—¬ëŸ¬ë¶„ì´ ê¸€ë¡œ ë” ë§ì´ ì†Œí†µí•  ìˆ˜ ìˆë„ë¡ ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ ì œê³µí•˜ê³  ìˆì–´ìš”.\",\n                    }\n                ),\n                DividerBlock(),\n                # ëª…ë ¹ì–´ ì•ˆë‚´\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*ğŸ’¬ ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´ ì•ˆë‚´*\\n\\n\"\n                        \"*`/ì œì¶œ`* - ì´ë²ˆ íšŒì°¨ì˜ ê¸€ì„ ì œì¶œí•  ìˆ˜ ìˆì–´ìš”.\\n\"\n                        \"*`/íŒ¨ìŠ¤`* - ì´ë²ˆ íšŒì°¨ì˜ ê¸€ì„ íŒ¨ìŠ¤í•  ìˆ˜ ìˆì–´ìš”.\\n\"\n                        \"*`/ì œì¶œë‚´ì—­`* - ìì‹ ì˜ ê¸€ ì œì¶œë‚´ì—­ì„ ë³¼ ìˆ˜ ìˆì–´ìš”.\\n\"\n                        \"*`/ê²€ìƒ‰`* - ë‹¤ë¥¸ ì‚¬ëŒë“¤ì˜ ê¸€ì„ ê²€ìƒ‰í•  ìˆ˜ ìˆì–´ìš”.\\n\"\n                        \"*`/ë¶ë§ˆí¬`* - ë¶ë§ˆí¬í•œ ê¸€ì„ ë³¼ ìˆ˜ ìˆì–´ìš”.\\n\"\n                        \"*`/ì˜ˆì¹˜ê¸ˆ`* - í˜„ì¬ ë‚¨ì€ ì˜ˆì¹˜ê¸ˆì„ ì•Œë ¤ë“œë ¤ìš”.\\n\"\n                        \"*`/ë„ì›€ë§`* - ë˜ë´‡ ì‚¬ìš©ë²•ì„ ì•Œë ¤ë“œë ¤ìš”.\\n\"\n                        \"*`/ì¢…ì´ë¹„í–‰ê¸°`* - ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆì–´ìš”.\\n\",\n                    }\n                ),\n                DividerBlock(),\n                # ë¬¸ì˜ ë° ì½”ë“œ ì•ˆë‚´\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"ğŸ™Œ *ë„ì›€ì´ í•„ìš”í•˜ì‹ ê°€ìš”?*\\n\\n\"\n                        f\"ê¶ê¸ˆí•œ ì‚¬í•­ì´ ìˆë‹¤ë©´ <#{settings.BOT_SUPPORT_CHANNEL}> ì±„ë„ë¡œ ë¬¸ì˜í•´ì£¼ì„¸ìš”!\\n\"\n                        \"ë˜ë´‡ ì½”ë“œê°€ ê¶ê¸ˆí•˜ë‹¤ë©´ ğŸ‘‰ğŸ¼ *<https://github.com/Daco2020/ttobot|ë˜ë´‡ ê¹ƒí—ˆë¸Œ>* ë¡œ ë†€ëŸ¬ì˜¤ì„¸ìš”~ ğŸ¤—\",\n                    }\n                ),\n            ],\n        ),\n    )\n\n\nasync def admin_command(\n    ack: AsyncAck,\n    body: CommandBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ê´€ë¦¬ì ë©”ë‰´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    if user.user_id not in settings.ADMIN_IDS:\n        raise PermissionError(\"`/ê´€ë¦¬ì` ëª…ë ¹ì–´ëŠ” ê´€ë¦¬ìë§Œ í˜¸ì¶œí•  ìˆ˜ ìˆì–´ìš”. ğŸ¤­\")\n\n    text = \"ê´€ë¦¬ì ë©”ë‰´ì…ë‹ˆë‹¤.\"\n    await client.chat_postEphemeral(\n        channel=body[\"channel_id\"],\n        user=user.user_id,\n        text=text,\n        blocks=[\n            SectionBlock(text=text),\n            DividerBlock(),\n            SectionBlock(text=\"1. í…Œì´ë¸”ì„ ë™ê¸°í™”í•©ë‹ˆë‹¤.\"),\n            ActionsBlock(\n                block_id=\"sync_store_block\",\n                elements=[\n                    StaticSelectElement(\n                        placeholder=\"ë™ê¸°í™” ì„ íƒ\",\n                        action_id=\"sync_store_select\",\n                        options=[\n                            Option(text=\"ì „ì²´\", value=\"ì „ì²´\"),\n                            Option(text=\"ìœ ì €\", value=\"ìœ ì €\"),\n                            Option(text=\"ì»¨í…ì¸ \", value=\"ì»¨í…ì¸ \"),\n                            Option(text=\"ë¶ë§ˆí¬\", value=\"ë¶ë§ˆí¬\"),\n                            Option(text=\"ì»¤í”¼ì±— ì¸ì¦\", value=\"ì»¤í”¼ì±— ì¸ì¦\"),\n                            Option(text=\"í¬ì¸íŠ¸ íˆìŠ¤í† ë¦¬\", value=\"í¬ì¸íŠ¸ íˆìŠ¤í† ë¦¬\"),\n                            Option(text=\"ì¢…ì´ë¹„í–‰ê¸°\", value=\"ì¢…ì´ë¹„í–‰ê¸°\"),\n                            Option(text=\"êµ¬ë…\", value=\"êµ¬ë…\"),\n                        ],\n                    ),\n                ],\n            ),\n            DividerBlock(),\n            SectionBlock(text=\"2. íŠ¹ì • ë©¤ë²„ë¥¼ íŠ¹ì • ì±„ë„ì— ì´ˆëŒ€í•©ë‹ˆë‹¤.\"),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"ì±„ë„ ì´ˆëŒ€\",\n                        action_id=\"invite_channel\",\n                        value=\"invite_channel\",\n                    ),\n                ],\n            ),\n        ],\n    )\n\n\nasync def handle_sync_store(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ë°ì´í„° ë™ê¸°í™”ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    value = body[\"state\"][\"values\"][\"sync_store_block\"][\"sync_store_select\"][\n        \"selected_option\"\n    ][\"value\"]\n\n    try:\n        await client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL, text=f\"{value} ë°ì´í„° ë™ê¸°í™” ì‹œì‘\"\n        )\n        # # TODO: ìŠ¬ë™ìœ¼ë¡œ ë°±ì—…íŒŒì¼ ë³´ë‚´ê¸°\n        store = Store(client=SpreadSheetClient())\n\n        if value == \"ì „ì²´\":\n            store.pull_all()\n        elif value == \"ìœ ì €\":\n            store.pull_users()\n        elif value == \"ì»¨í…ì¸ \":\n            store.pull_contents()\n        elif value == \"ë¶ë§ˆí¬\":\n            store.pull_bookmark()\n        elif value == \"ì»¤í”¼ì±— ì¸ì¦\":\n            store.pull_coffee_chat_proof()\n        elif value == \"í¬ì¸íŠ¸ íˆìŠ¤í† ë¦¬\":\n            store.pull_point_histories()\n        elif value == \"ì¢…ì´ë¹„í–‰ê¸°\":\n            store.pull_paper_plane()\n        elif value == \"êµ¬ë…\":\n            store.pull_subscriptions()\n        else:\n            await client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=\"ë™ê¸°í™” í…Œì´ë¸”ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\",\n            )\n\n        await client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL, text=f\"{value} ë°ì´í„° ë™ê¸°í™” ì™„ë£Œ\"\n        )\n\n    except Exception as e:\n        await client.chat_postMessage(channel=settings.ADMIN_CHANNEL, text=str(e))\n\n\nasync def handle_invite_channel(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì±„ë„ ì´ˆëŒ€ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=\"ì±„ë„ ì´ˆëŒ€\",\n            submit=\"ì±„ë„ ì´ˆëŒ€í•˜ê¸°\",\n            callback_id=\"invite_channel_view\",\n            close=\"ë‹«ê¸°\",\n            blocks=[\n                SectionBlock(\n                    text=\"ì´ˆëŒ€í•˜ê³  ì‹¶ì€ ë©¤ë²„ì™€ ì±„ë„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.\",\n                ),\n                InputBlock(\n                    block_id=\"user\",\n                    label=\"ë©¤ë²„\",\n                    optional=False,\n                    element=UserSelectElement(\n                        action_id=\"select_user\",\n                        placeholder=\"ë©¤ë²„ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.\",\n                    ),\n                ),\n                InputBlock(\n                    block_id=\"channel\",\n                    label=\"ì±„ë„\",\n                    optional=True,\n                    element=ChannelMultiSelectElement(\n                        action_id=\"select_channels\",\n                        placeholder=\"ì±„ë„ì„ ì„ íƒí•˜ì§€ ì•Šìœ¼ë©´ ëª¨ë“  ê³µê°œ ì±„ë„ì— ì´ˆëŒ€í•©ë‹ˆë‹¤.\",\n                    ),\n                ),\n            ],\n        ),\n    )\n\n\nasync def handle_invite_channel_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì±„ë„ ì´ˆëŒ€ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    values = body[\"view\"][\"state\"][\"values\"]\n    user_id = values[\"user\"][\"select_user\"][\"selected_user\"]\n    channel_ids = values[\"channel\"][\"select_channels\"][\"selected_channels\"]\n\n    if not channel_ids:\n        channel_ids = await _fetch_public_channel_ids(client)\n\n    await client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=f\"<@{user_id}> ë‹˜ì˜ ì±„ë„ ì´ˆëŒ€ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.\\n\\nì±„ë„ ìˆ˜ : {len(channel_ids)} ê°œ\\n\",\n    )\n\n    for channel_id in channel_ids:\n        await _invite_channel(client, user_id, channel_id)\n\n    await client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=\"ì±„ë„ ì´ˆëŒ€ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\",\n    )\n\n\n@tenacity.retry(\n    stop=tenacity.stop_after_attempt(3),\n    wait=tenacity.wait_fixed(1),\n    reraise=True,\n)\nasync def _fetch_public_channel_ids(client: AsyncWebClient) -> list[str]:\n    \"\"\"ëª¨ë“  ê³µê°œ ì±„ë„ì˜ ì•„ì´ë””ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    res = await client.conversations_list(limit=500, types=\"public_channel\")\n    return [channel[\"id\"] for channel in res[\"channels\"]]\n\n\n@tenacity.retry(\n    stop=tenacity.stop_after_attempt(3),\n    wait=tenacity.wait_fixed(1),\n    reraise=True,\n)\nasync def _invite_channel(\n    client: AsyncWebClient,\n    user_id: str,\n    channel_id: str,\n) -> None:\n    \"\"\"ì±„ë„ì— ë©¤ë²„ë¥¼ ì´ˆëŒ€í•©ë‹ˆë‹¤.\"\"\"\n    try:\n        await client.conversations_invite(channel=channel_id, users=user_id)\n        result = \" -> âœ… (ì±„ë„ ì´ˆëŒ€)\"\n    except SlackApiError as e:\n        # ë´‡ì´ ì±„ë„ì— ì—†ëŠ” ê²½ìš°, ì±„ë„ì— ì°¸ì—¬í•˜ê³  ì´ˆëŒ€í•©ë‹ˆë‹¤.\n        if e.response[\"error\"] == \"not_in_channel\":\n            await client.conversations_join(channel=channel_id)\n            await client.conversations_invite(channel=channel_id, users=user_id)\n            result = \" -> âœ… (ë˜ë´‡ë„ í•¨ê»˜ ì±„ë„ ì´ˆëŒ€)\"\n        elif e.response[\"error\"] == \"already_in_channel\":\n            result = \" -> âœ… (ì´ë¯¸ ì±„ë„ì— ì°¸ì—¬ ì¤‘)\"\n        elif e.response[\"error\"] == \"cant_invite_self\":\n            result = \" -> âœ… (ë˜ë´‡ì´ ìê¸° ìì‹ ì„ ì´ˆëŒ€)\"\n        else:\n            link = \"<https://api.slack.com/methods/conversations.invite#errors|ë¬¸ì„œ í™•ì¸í•˜ê¸°>\"\n            result = f\" -> ğŸ˜µ ({e.response['error']}) ğŸ‘‰ {link}\"\n\n    await client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=f\"\\n<#{channel_id}>\" + result,\n    )\n\n\nasync def handle_home_tab(\n    event: HomeTabEventType,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n):\n    \"\"\"í™ˆ íƒ­ì„ ì—´ì—ˆì„ ë•Œì˜ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.\"\"\"\n    if not user:\n        await client.views_publish(\n            user_id=event[\"user\"],\n            view=View(\n                type=\"home\",\n                blocks=[\n                    HeaderBlock(\n                        text=\"ğŸ‘‹ ë°˜ê°€ì›Œìš”! ì €ëŠ” ë˜ë´‡ì´ì—ìš”.\",\n                    ),\n                    DividerBlock(),\n                    SectionBlock(\n                        text=\"[í™ˆ] íƒ­ì€ ê¸€ë˜ OT ì´í›„ì— ê³µê°œë  ì˜ˆì •ì´ì—ìš”. ğŸ™‡â€â™‚ï¸\\në§Œì•½ OT ì´í›„ì—ë„ í•´ë‹¹ í™”ë©´ì´ í‘œì‹œëœë‹¤ë©´ [0_ê¸€ë˜ë´‡ì§ˆë¬¸] ì±„ë„ë¡œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.\",\n                    ),\n                ],\n            ),\n        )\n        return\n\n    # í¬ì¸íŠ¸ íˆìŠ¤í† ë¦¬ë¥¼ í¬í•¨í•œ ìœ ì €ë¥¼ ê°€ì ¸ì˜¨ë‹¤.\n    user_point_history = point_service.get_user_point(user_id=user.user_id)\n    combo_count = user.get_continuous_submit_count()\n\n    current_combo_point = \"\"\n    if combo_count < 1:\n        pass\n    elif combo_count in [3, 6, 9]:\n        current_combo_point = \"*+ ???(íŠ¹ë³„ ì½¤ë³´ ë³´ë„ˆìŠ¤)* \"\n    else:\n        current_combo_point = (\n            \"*+ \" + str(PointMap.ê¸€_ì œì¶œ_ì½¤ë³´.point * combo_count) + \"(ì½¤ë³´ ë³´ë„ˆìŠ¤)* \"\n        )\n\n    remain_paper_planes: str | int\n    if user.user_id == settings.SUPER_ADMIN:\n        remain_paper_planes = \"âˆ\"\n    else:\n        remain_paper_planes = \"âˆ\"\n        # paper_planes = service.fetch_current_week_paper_planes(user_id=user.user_id)\n        # remain_paper_planes = 7 - len(paper_planes) if len(paper_planes) < 7 else 0\n\n    # í™ˆ íƒ­ ë©”ì‹œì§€ êµ¬ì„±\n    await client.views_publish(\n        user_id=user.user_id,\n        view=View(\n            type=\"home\",\n            blocks=[\n                # í¬ì¸íŠ¸ ì‹œìŠ¤í…œ ì„¹ì…˜\n                HeaderBlock(\n                    text=\"ğŸ­ ë‚´ ê¸€ë˜ í¬ì¸íŠ¸\",\n                ),\n                SectionBlock(\n                    text=f\"í˜„ì¬ *{user.name[1:]}* ë‹˜ì´ íšë“í•œ ì´ í¬ì¸íŠ¸ëŠ” *{user_point_history.total_point} point* ì…ë‹ˆë‹¤.\",\n                ),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=f\"ì´ë²ˆ íšŒì°¨ì— ê¸€ì„ ì œì¶œí•˜ë©´ *100* {current_combo_point}point ë¥¼ ì–»ì„ ìˆ˜ ìˆì–´ìš”.\",\n                        ),\n                    ],\n                ),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"í¬ì¸íŠ¸ íšë“ ë‚´ì—­ ë³´ê¸°\",\n                            action_id=\"open_point_history_view\",\n                            value=\"open_point_history_view\",\n                        ),\n                        ButtonElement(\n                            text=\"í¬ì¸íŠ¸ íšë“ ë°©ë²• ì•Œì•„ë³´ê¸°\",\n                            action_id=\"open_point_guide_view\",\n                            value=\"open_point_guide_view\",\n                        ),\n                    ],\n                ),\n                DividerBlock(),\n                # ì¢…ì´ë¹„í–‰ê¸° ì„¹ì…˜\n                HeaderBlock(\n                    text=\"âœˆï¸ ì¢…ì´ë¹„í–‰ê¸° ë³´ë‚´ê¸°\",\n                ),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=f\"ì¢…ì´ë¹„í–‰ê¸°ëŠ” ê¸€ë˜ ë©¤ë²„ì—ê²Œ ë”°ëœ»í•œ ê°ì‚¬ë‚˜ ì‘ì›ì˜ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ì—ìš”.\\n*{user.name[1:]}* ë‹˜ì´ ì´ë²ˆ ì£¼ì— ë³´ë‚¼ ìˆ˜ ìˆëŠ” ì¢…ì´ë¹„í–‰ê¸° ìˆ˜ëŠ” í˜„ì¬ *{remain_paper_planes}ê°œ* ì…ë‹ˆë‹¤. ğŸ˜Š\",\n                        ),\n                    ],\n                ),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"ì¢…ì´ë¹„í–‰ê¸° ë³´ë‚´ê¸°\",\n                            action_id=\"send_paper_plane_message\",\n                            style=\"primary\",\n                        ),\n                        ButtonElement(\n                            text=\"ì£¼ê³ ë°›ì€ ì¢…ì´ë¹„í–‰ê¸° ë³´ê¸°\",\n                            action_id=\"open_paper_plane_url\",\n                            url=\"https://geultto-paper-plane.vercel.app\",\n                        ),\n                        ButtonElement(\n                            text=\"ì–´ë–¤ ë‚´ìš©ì„ ë³´ë‚´ë©´ ì¢‹ì„ê¹Œìš”?\",\n                            action_id=\"open_paper_plane_guide_view\",\n                            value=\"open_paper_plane_guide_view\",\n                        ),\n                    ],\n                ),\n                DividerBlock(),\n                # ê¸€ ì œì¶œ ë‚´ì—­ ê´€ë¦¬ ì„¹ì…˜\n                HeaderBlock(\n                    text=\"ğŸ“š ìŠ¬ê¸°ë¡œìš´ ê¸€ë˜ ìƒí™œ\",\n                ),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=f\"*{user.name[1:]}* ë‹˜ì´ ê¶ê¸ˆí•´í• ë§Œí•œ ë‚´ìš©ë“¤ì„ ëª¨ì•„ë´¤ì–´ìš”.\",\n                        ),\n                    ],\n                ),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"ë‚´ê°€ ì œì¶œí•œ ê¸€ ë³´ê¸°\",\n                            action_id=\"open_submission_history_view\",\n                            value=\"open_submission_history_view\",\n                        ),\n                        ButtonElement(\n                            text=\"ë‚´ê°€ ë¶ë§ˆí¬í•œ ê¸€ ë³´ê¸°\",\n                            action_id=\"open_bookmark_page_view\",\n                            value=\"open_bookmark_page_view\",\n                        ),\n                        ButtonElement(\n                            text=\"ë‚´ ì»¤í”¼ì±— ì¸ì¦ ë‚´ì—­ ë³´ê¸°\",\n                            action_id=\"open_coffee_chat_history_view\",\n                            value=\"open_coffee_chat_history_view\",\n                        ),\n                        ButtonElement(\n                            text=\"ë‚¨ì•„ìˆëŠ” ì˜ˆì¹˜ê¸ˆ ë³´ê¸°\",\n                            action_id=\"open_deposit_view\",\n                            value=\"open_deposit_view\",\n                        ),\n                        ButtonElement(\n                            text=\"ë˜ë´‡ ê¸°ëŠ¥ ì‚´í´ë³´ê¸°\",\n                            action_id=\"open_help_view\",\n                            value=\"open_help_view\",\n                        ),\n                    ],\n                ),\n                DividerBlock(),\n                HeaderBlock(\n                    text=\"ğŸ§ ë˜ë´‡ ì‹¤í—˜ì‹¤\",\n                ),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=\"ë˜ë´‡ì˜ ìƒˆë¡œìš´ ê¸°ëŠ¥ë“¤ì„ ê°€ì¥ ë¨¼ì € ë§Œë‚˜ë³´ì„¸ìš”. ğŸ¤—\\n\"\n                            f\"ë²„ê·¸ ì œë³´ì™€ ì•„ì´ë””ì–´ ì œì•ˆì€ <#{settings.BOT_SUPPORT_CHANNEL}> ì±„ë„ë¡œ ë¶€íƒë“œë ¤ìš”. ğŸ™\",\n                        ),\n                    ],\n                ),\n                DividerBlock(),\n                SectionBlock(text=\"ğŸ”” ë©¤ë²„ êµ¬ë…\"),\n                ContextBlock(\n                    elements=[\n                        TextObject(\n                            type=\"mrkdwn\",\n                            text=\"êµ¬ë…í•œ ë©¤ë²„ê°€ ê¸€ì„ ì œì¶œí•˜ë©´ ìƒˆ ê¸€ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ìˆì–´ìš”!\\n\"\n                            \"ì´ ê¸°ëŠ¥ì€ ë©¤ë²„ì˜ ì œì•ˆìœ¼ë¡œ ë§Œë“¤ì–´ì¡Œì–´ìš”. Special thanks to ì±„ì •í˜„ ğŸ™‡â€â™‚ï¸\",\n                        ),\n                    ],\n                ),\n                ActionsBlock(\n                    elements=[\n                        ButtonElement(\n                            text=\"ë©¤ë²„ êµ¬ë…í•˜ê¸°\",\n                            action_id=\"open_subscribe_member_view\",\n                            style=\"primary\",\n                        ),\n                    ]\n                ),\n            ],\n        ),\n    )\n\n\nasync def open_point_history_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"í¬ì¸íŠ¸ íˆìŠ¤í† ë¦¬ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    user_point_history = point_service.get_user_point(user_id=user.user_id)\n\n    footer_blocks: list[Block] = []\n    if user_point_history.total_point > 0:\n        footer_blocks = [\n            DividerBlock(),\n            SectionBlock(\n                text=\"í¬ì¸íŠ¸ íšë“ ë‚´ì—­ì€ ìµœê·¼ 20ê°œê¹Œì§€ë§Œ í‘œì‹œë©ë‹ˆë‹¤.\\nì „ì²´ ë‚´ì—­ì„ í™•ì¸í•˜ë ¤ë©´ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.\",\n            ),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"ì „ì²´ ë‚´ì—­ ë‹¤ìš´ë¡œë“œ\",\n                        action_id=\"download_point_history\",\n                        value=\"download_point_history\",\n                        style=\"primary\",\n                    ),\n                ],\n            ),\n        ]\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{user_point_history.user.name}ë‹˜ì˜ í¬ì¸íŠ¸ íšë“ ë‚´ì—­\",\n            close=\"ë‹«ê¸°\",\n            blocks=[\n                SectionBlock(\n                    text=f\"ì´ *{user_point_history.total_point} point* ë¥¼ íšë“í•˜ì…¨ì–´ìš”.\",\n                ),\n                DividerBlock(),\n                SectionBlock(text=user_point_history.point_history_text),\n                *footer_blocks,\n            ],\n        ),\n    )\n\n\nasync def download_point_history(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"í¬ì¸íŠ¸ íˆìŠ¤í† ë¦¬ë¥¼ CSV íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    response = await client.conversations_open(users=user.user_id)\n    dm_channel_id = response[\"channel\"][\"id\"]\n\n    user_point = point_service.get_user_point(user_id=user.user_id)\n    if not user_point.point_histories:\n        await client.chat_postMessage(\n            channel=dm_channel_id, text=\"í¬ì¸íŠ¸ íšë“ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.\"\n        )\n        return None\n\n    # ì‚¬ìš©ìì˜ ì œì¶œë‚´ì—­ì„ CSV íŒŒì¼ë¡œ ì„ì‹œ ì €ì¥ í›„ ì „ì†¡\n    temp_dir = \"temp/point_histories\"\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir)\n\n    temp_file_path = f\"{temp_dir}/{user.name}-í¬ì¸íŠ¸-íšë“-ë‚´ì—­.csv\"\n    with open(temp_file_path, \"w\", newline=\"\") as csvfile:\n        writer = csv.DictWriter(\n            csvfile,\n            PointHistory.fieldnames(),\n            quoting=csv.QUOTE_ALL,\n        )\n        writer.writeheader()\n        writer.writerows([each.model_dump() for each in user_point.point_histories])\n\n    res = await client.files_upload_v2(\n        channel=dm_channel_id,\n        file=temp_file_path,\n        initial_comment=f\"<@{user.user_id}> ë‹˜ì˜ í¬ì¸íŠ¸ íšë“ ë‚´ì—­ ì…ë‹ˆë‹¤.\",\n    )\n\n    await client.chat_postMessage(\n        channel=dm_channel_id,\n        text=f\"<@{user.user_id}> ë‹˜ì˜ <{res['file']['permalink']}|í¬ì¸íŠ¸ íšë“ ë‚´ì—­> ì…ë‹ˆë‹¤.\",\n    )\n\n    # ì„ì‹œë¡œ ìƒì„±í•œ CSV íŒŒì¼ì„ ì‚­ì œ\n    os.remove(temp_file_path)\n\n\nasync def open_point_guide_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"í¬ì¸íŠ¸ íšë“ ë°©ë²•ì„ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title={\"type\": \"plain_text\", \"text\": \"í¬ì¸íŠ¸ íšë“ ë°©ë²•\"},\n            close={\"type\": \"plain_text\", \"text\": \"ë‹«ê¸°\"},\n            blocks=[\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"í¬ì¸íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë°©ë²•ìœ¼ë¡œ íšë“í•  ìˆ˜ ìˆì–´ìš”.\",\n                    }\n                ),\n                DividerBlock(),\n                # ê¸€ ì œì¶œ ê´€ë ¨ í¬ì¸íŠ¸\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*ğŸ† ê¸€ ì œì¶œ ê´€ë ¨ í¬ì¸íŠ¸*\\n\"\n                        \"*`ê¸€ ì œì¶œí•˜ê¸°`* - ê¸€ì„ ì œì¶œí•˜ë©´ ê¸°ë³¸ *100 í¬ì¸íŠ¸* íšë“\\n\"\n                        \"*`ì¶”ê°€ ê¸€ ì œì¶œ`* - ë™ì¼ íšŒì°¨ì— ê¸€ì„ ì¶”ê°€ë¡œ ì œì¶œí•  ë•Œë§ˆë‹¤ *100 í¬ì¸íŠ¸* íšë“\\n\"\n                        \"*`íšŒì°¨ ì—°ì† ì œì¶œ ì½¤ë³´`* - ê¾¸ì¤€íˆ ì‘ì„±í•˜ë©´ *??? í¬ì¸íŠ¸* íšë“(ê½¤ ë§ì•„ìš”)\\n\"\n                        \"*`ì½”ì–´ ì±„ë„ ìˆœìœ„`* - ì½”ì–´ ì±„ë„ ì œì¶œ ìˆœì„œì— ë”°ë¼ 1, 2, 3ë“± ê°ê° *50/30/20 í¬ì¸íŠ¸* íšë“\",\n                    }\n                ),\n                DividerBlock(),\n                # ì°¸ì—¬ ê´€ë ¨ í¬ì¸íŠ¸\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*ğŸ¡ ì°¸ì—¬ ê´€ë ¨ í¬ì¸íŠ¸*\\n\"\n                        \"*`ì»¤í”¼ì±— ì¸ì¦`* - ì»¤í”¼ì±—ì„ ì¸ì¦í•˜ë©´ *50 í¬ì¸íŠ¸* íšë“\\n\"\n                        \"*`ë¹Œë¦¬ì§€ ë°˜ìƒíšŒ ì°¸ì—¬`* - ë°˜ìƒíšŒ ì°¸ì—¬ ì‹œ *50 í¬ì¸íŠ¸* íšë“(ìˆ˜ë™ ì§€ê¸‰)\",\n                    }\n                ),\n                DividerBlock(),\n                # íë ˆì´ì…˜ ê´€ë ¨ í¬ì¸íŠ¸\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*âœï¸ íë ˆì´ì…˜ ê´€ë ¨ í¬ì¸íŠ¸*\\n\"\n                        \"*`íë ˆì´ì…˜ ìš”ì²­`* - ê¸€ ì œì¶œ ì‹œ íë ˆì´ì…˜ì„ ìš”ì²­í•˜ë©´ *10 í¬ì¸íŠ¸* íšë“\\n\"\n                        \"*`íë ˆì´ì…˜ ì„ ì •`* - íë ˆì´ì…˜ì— ì„ ì •ë˜ë©´ ì¶”ê°€ *200 í¬ì¸íŠ¸* íšë“(ìˆ˜ë™ ì§€ê¸‰)\",\n                    }\n                ),\n                DividerBlock(),\n                # ê³µì§€ì‚¬í•­ ê´€ë ¨ í¬ì¸íŠ¸\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*ğŸ“¢ ê³µì§€ì‚¬í•­ ê´€ë ¨ í¬ì¸íŠ¸*\\n\"\n                        \"*`ê³µì§€ì‚¬í•­ ì´ëª¨ì§€`* - ê³µì§€ì‚¬í•­ì— :noti-check: ì´ëª¨ì§€ë¥¼ 3ì¼ ë‚´ì— ë‚¨ê¸°ë©´ *10 í¬ì¸íŠ¸* íšë“\",\n                    }\n                ),\n                DividerBlock(),\n                # ìê¸°ì†Œê°œ ì‘ì„± í¬ì¸íŠ¸\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*ğŸ‘‹ ìê¸°ì†Œê°œ ì‘ì„± í¬ì¸íŠ¸*\\n\"\n                        \"*`ìê¸°ì†Œê°œ ì‘ì„±í•˜ê¸°`* - ìê¸°ì†Œê°œ ì‘ì„± ì‹œ *100 í¬ì¸íŠ¸* íšë“(ìˆ˜ë™ ì§€ê¸‰)\",\n                    }\n                ),\n                DividerBlock(),\n                # ê¸°íƒ€ ì§€ê¸‰ í¬ì¸íŠ¸\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*ğŸ ê¸°íƒ€ ì§€ê¸‰ í¬ì¸íŠ¸*\\n\"\n                        \"*`ì„±ìœ¤ì„ ì¡ì•„ë¼`* - '1_[ì±„ë„]'ì—ì„œ ì„±ìœ¤ë‹˜ ì œì¶œ ê¸€ì— :catch-kyle: ì´ëª¨ì§€ë¥¼ 1ì¼ ë‚´ì— ë‚¨ê¸°ë©´ *30 í¬ì¸íŠ¸* íšë“\",\n                    }\n                ),\n            ],\n        ),\n    )\n\n\nasync def send_paper_plane_message(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    initial_user_id = body[\"actions\"][0].get(\"value\")\n    view = View(\n        type=\"modal\",\n        title=\"ì¢…ì´ë¹„í–‰ê¸° ë³´ë‚´ê¸°\",\n        callback_id=\"send_paper_plane_message_view\",\n        close=\"ë‹«ê¸°\",\n        submit=\"ë³´ë‚´ê¸°\",\n        blocks=[\n            SectionBlock(\n                text=\"ì¢…ì´ë¹„í–‰ê¸°ì— ì „í•˜ê³  ì‹¶ì€ ë§ˆìŒì„ ì ì–´ì£¼ì„¸ìš”.\",\n            ),\n            ContextBlock(\n                elements=[\n                    MarkdownTextObject(\n                        text=f\"ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ë‚´ë©´ <#{settings.THANKS_CHANNEL}> ì±„ë„ë¡œ ì•Œë¦¼ì´ ì „ì†¡ë©ë‹ˆë‹¤.\"\n                        \"\\n[ë°›ëŠ” ì‚¬ëŒ]ì€ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ í™•ì¸í•  ë•Œ [ë³´ë‚¸ ì‚¬ëŒ]ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\"\n                    )\n                ],\n            ),\n            InputBlock(\n                block_id=\"paper_plane_receiver\",\n                label=\"ë°›ëŠ” ì‚¬ëŒ\",\n                element=UserSelectElement(\n                    action_id=\"select_user\",\n                    placeholder=\"ë°›ëŠ” ì‚¬ëŒì„ ì„ íƒí•´ì£¼ì„¸ìš”.\",\n                    initial_user=initial_user_id,\n                ),\n            ),\n            InputBlock(\n                block_id=\"paper_plane_message\",\n                label=\"ë©”ì‹œì§€\",\n                element=PlainTextInputElement(\n                    max_length=300,\n                    action_id=\"paper_plane_message\",\n                    placeholder=\"ì¢…ì´ë¹„í–‰ê¸°ë¡œ ì „í•  ë§ˆìŒì„ ì ì–´ì£¼ì„¸ìš”.\",\n                    multiline=True,\n                ),\n            ),\n        ],\n    )\n\n    callback_id = body.get(\"view\", {}).get(\"callback_id\")\n    if callback_id == \"paper_plane_command\":\n        # callback_id ê°€ ìˆë‹¤ë©´ ëª¨ë‹¬ì—ì„œ ë°œìƒí•œ ì•¡ì…˜ì´ë¯€ë¡œ ê¸°ì¡´ ëª¨ë‹¬ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.\n        await client.views_update(\n            view_id=body[\"view\"][\"id\"],\n            view=view,\n        )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=view,\n    )\n\n\nasync def send_paper_plane_message_view(\n    ack: AsyncAck,\n    body: ViewBodyType,\n    client: AsyncWebClient,\n    view: ViewType,\n    say: AsyncSay,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.\"\"\"\n    values = body[\"view\"][\"state\"][\"values\"]\n    receiver_id = values[\"paper_plane_receiver\"][\"select_user\"][\"selected_user\"]\n    text = values[\"paper_plane_message\"][\"paper_plane_message\"][\"value\"]\n\n    if user.user_id == receiver_id:\n        await ack(\n            response_action=\"errors\",\n            errors={\n                \"paper_plane_receiver\": \"ì¢…ì´ë¹„í–‰ê¸°ëŠ” ìì‹ ì—ê²Œ ë³´ë‚¼ ìˆ˜ ì—†ì–´ìš”. ğŸ˜‰\",\n            },\n        )\n        return\n\n    if len(text) > 300:\n        await ack(\n            response_action=\"errors\",\n            errors={\n                \"paper_plane_message\": \"ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ëŠ” 300ì ì´ë‚´ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”. ğŸ˜‰\",\n            },\n        )\n        return\n\n    if receiver_id in BOT_IDS:\n        await ack(\n            response_action=\"errors\",\n            errors={\n                \"paper_plane_message\": \"ë´‡ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ë‚¼ ìˆ˜ ì—†ì–´ìš”. ğŸ˜‰\",\n            },\n        )\n        return\n\n    if user.user_id == settings.SUPER_ADMIN:\n        pass\n    else:\n        pass\n        # paper_planes = service.fetch_current_week_paper_planes(user_id=user.user_id)\n        # if len(paper_planes) >= 7:\n        #     await ack(\n        #         response_action=\"errors\",\n        #         errors={\n        #             \"paper_plane_receiver\": \"ì¢…ì´ë¹„í–‰ê¸°ëŠ” í•œ ì£¼ì— 7ê°œê¹Œì§€ ë³´ë‚¼ ìˆ˜ ìˆì–´ìš”. (í† ìš”ì¼ 00ì‹œì— ì¶©ì „)\",\n        #         },\n        #     )\n        #     return\n\n    await ack()\n\n    receiver = service.get_user(user_id=receiver_id)\n    service.create_paper_plane(\n        sender=user,\n        receiver=receiver,\n        text=text,\n    )\n\n    await client.chat_postMessage(\n        channel=settings.THANKS_CHANNEL,\n        text=f\"ğŸ’Œ *<@{receiver_id}>* ë‹˜ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ê°€ ë„ì°©í–ˆì–´ìš”!\",\n        blocks=[\n            SectionBlock(\n                text=f\"ğŸ’Œ *<@{receiver_id}>* ë‹˜ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ê°€ ë„ì°©í–ˆì–´ìš”!\\n\\n\",\n            ),\n            ContextBlock(\n                elements=[\n                    MarkdownTextObject(\n                        text=\">ë°›ì€ ì¢…ì´ë¹„í–‰ê¸°ëŠ” `/ì¢…ì´ë¹„í–‰ê¸°` ëª…ë ¹ì–´ -> [ì£¼ê³ ë°›ì€ ì¢…ì´ë¹„í–‰ê¸° ë³´ê¸°] ë¥¼ í†µí•´ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.\"\n                    )\n                ],\n            ),\n        ],\n    )\n\n    await client.chat_postMessage(\n        channel=user.user_id,\n        text=f\"ğŸ’Œ *<@{receiver_id}>* ë‹˜ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ëƒˆì–´ìš”!\",\n        blocks=[\n            SectionBlock(\n                text=f\"ğŸ’Œ *<@{receiver_id}>* ë‹˜ì—ê²Œ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ëƒˆì–´ìš”!\\n\\n\",\n            ),\n            ContextBlock(\n                elements=[\n                    MarkdownTextObject(\n                        text=\">ë³´ë‚¸ ì¢…ì´ë¹„í–‰ê¸°ëŠ” `/ì¢…ì´ë¹„í–‰ê¸°` ëª…ë ¹ì–´ -> [ì£¼ê³ ë°›ì€ ì¢…ì´ë¹„í–‰ê¸° ë³´ê¸°] ë¥¼ í†µí•´ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.\"\n                    )\n                ],\n            ),\n        ],\n    )\n\n    # ì¸í”„ëŸ° ì¿ í° ì§€ê¸‰ ë¡œì§\n    inflearn_coupon = get_inflearn_coupon(user_id=user.user_id)\n    if not inflearn_coupon:\n        # ì¸í”„ëŸ° ì¿ í°ì´ ì¡´ì¬í•˜ì§€ ì•Šë‹¤ë©´ ê´€ë¦¬ìì—ê²Œ ì•Œë¦½ë‹ˆë‹¤.\n        await client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL,\n            text=f\"ğŸ’Œ *<@{user.user_id}>* ë‹˜ì˜ ì¸í”„ëŸ° ì¿ í°ì´ ì¡´ì¬í•˜ì§€ ì•Šì•„ìš”.\",\n        )\n        return None\n    elif inflearn_coupon[\"status\"] == \"received\":\n        # ì´ë¯¸ ì¿ í°ì„ ë°›ì•˜ë‹¤ë©´ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ë‚´ì§€ ì•ŠìŠµë‹ˆë‹¤.\n        return None\n    else:\n        # ì¸í”„ëŸ° ì¿ í°ì„ ë°›ì§€ ì•Šì•˜ë‹¤ë©´ í• ì¸ì¿ í° ì½”ë“œì™€ í•¨ê»˜ ì¢…ì´ë¹„í–‰ê¸°ë¥¼ ë³´ëƒ…ë‹ˆë‹¤.\n        text = (\n            f\"{inflearn_coupon['user_name'][1:]}ë‹˜ì˜ ë”°ëœ»í•¨ì´ ê¸€ë˜ë¥¼ ë” ë”°ëœ»í•˜ê²Œ ë§Œë“¤ì—ˆì–´ìš”. ì´ì— ê°ì‚¬í•œ ë§ˆìŒì„ ë‹´ì•„ [ì¸í”„ëŸ° í• ì¸ ì¿ í°]ì„ ë³´ë‚´ë“œë ¤ìš”.\\n\\n\"\n            \"- í• ì¸ìœ¨ : 30%\\n\"\n            \"- ì‚¬ìš© ê¸°í•œ : 2025. 3. 30. 23:59 ê¹Œì§€\\n\"\n            f\"- ì¿ í° ì½”ë“œ : **{inflearn_coupon['code']}**\\n\"\n            \"- ì¿ í° ë“±ë¡ : ì¿ í° ë“±ë¡ í•˜ëŸ¬ê°€ê¸°\\n\\n\"\n            \"ì¿ í° ì½”ë“œë¥¼ [í• ì¸ì¿ í° ì½”ë“œ ì…ë ¥ë€]ì— ë“±ë¡í•˜ë©´ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ìš”.\"\n        )\n\n        ttobot = service.get_user(user_id=settings.TTOBOT_USER_ID)\n        service.create_paper_plane(\n            sender=ttobot,\n            receiver=user,\n            text=text,\n        )\n        update_inflearn_coupon_status(user_id=user.user_id, status=\"received\")\n\n        await asyncio.sleep(\n            5\n        )  # ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ ì „ì†¡ í›„ 5ì´ˆ ë’¤ì— ì „ì†¡. ì´ìœ ëŠ” ë°”ë¡œ ì „ì†¡í•  ê²½ìš° ë³¸ì¸ ì „ì†¡ ì•Œë¦¼ ë©”ì‹œì§€ì™€ êµ¬ë¶„ì´ ì–´ë ¤ì›€.\n\n        try:\n            await client.chat_postMessage(\n                channel=user.user_id,\n                text=f\"ğŸ’Œ *<@{settings.TTOBOT_USER_ID}>* ì˜ ê¹œì§ ì„ ë¬¼ì´ ë‹´ê¸´ ì¢…ì´ë¹„í–‰ê¸°ê°€ ë„ì°©í–ˆì–´ìš”!ğŸ\",\n                blocks=[\n                    SectionBlock(\n                        text=f\"ğŸ’Œ *<@{settings.TTOBOT_USER_ID}>* ì˜ ê¹œì§ ì„ ë¬¼ì´ ë‹´ê¸´ ì¢…ì´ë¹„í–‰ê¸°ê°€ ë„ì°©í–ˆì–´ìš”!ğŸ\\n\\n\",\n                    ),\n                    ContextBlock(\n                        elements=[\n                            MarkdownTextObject(\n                                text=\">ë°›ì€ ì¢…ì´ë¹„í–‰ê¸°ëŠ” `/ì¢…ì´ë¹„í–‰ê¸°` ëª…ë ¹ì–´ -> [ì£¼ê³ ë°›ì€ ì¢…ì´ë¹„í–‰ê¸° ë³´ê¸°] ë¥¼ í†µí•´ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.\"\n                            )\n                        ],\n                    ),\n                ],\n            )\n            return None\n        except Exception as e:\n            await client.chat_postMessage(\n                channel=settings.ADMIN_CHANNEL,\n                text=f\"ğŸ’Œ *<@{user.user_id}>* ë‹˜ì—ê²Œ ì¸í”„ëŸ° ì¿ í°ì„ ë³´ëƒˆìœ¼ë‚˜ ë©”ì‹œì§€ ì „ì†¡ì— ì‹¤íŒ¨í–ˆì–´ìš”. {e}\",\n            )\n            return None\n\n\nclass InflearnCoupon(TypedDict):\n    user_id: str\n    user_name: str\n    code: str\n    status: str\n\n\ndef get_inflearn_coupon(user_id: str) -> InflearnCoupon | None:\n    \"\"\"ì¸í”„ëŸ° ì¿ í° ì½”ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n    try:\n        df = pd.read_csv(\n            \"store/_inflearn_coupon.csv\", encoding=\"utf-8\", quoting=csv.QUOTE_ALL\n        )\n    except FileNotFoundError:\n        return None\n\n    coupon_row = df[df[\"user_id\"] == user_id]\n    if not coupon_row.empty:\n        return coupon_row.iloc[0].to_dict()\n    return None\n\n\ndef update_inflearn_coupon_status(user_id: str, status: str) -> None:\n    \"\"\"ì¸í”„ëŸ° ì¿ í° ìˆ˜ë ¹ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.\"\"\"\n    df = pd.read_csv(\"store/_inflearn_coupon.csv\", encoding=\"utf-8\")\n    df.loc[df[\"user_id\"] == user_id, \"status\"] = status\n    df.to_csv(\n        \"store/_inflearn_coupon.csv\",\n        index=False,\n        encoding=\"utf-8\",\n        quoting=csv.QUOTE_ALL,\n    )\n\n\nasync def open_paper_plane_url(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì¢…ì´ë¹„í–‰ê¸° í˜ì´ì§€ë¥¼ ì—½ë‹ˆë‹¤.\"\"\"\n    # í•´ë‹¹ ì´ë²¤íŠ¸ëŠ” ë¡œê·¸ë¥¼ ìœ„í•´ ackë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤.\n    await ack()\n\n\nasync def open_paper_plane_guide_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì¢…ì´ë¹„í–‰ê¸° ì‚¬ìš© ë°©ë²•ì„ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title={\"type\": \"plain_text\", \"text\": \"ì¢…ì´ë¹„í–‰ê¸° ì‚¬ìš© ë°©ë²•\"},\n            close={\"type\": \"plain_text\", \"text\": \"ë‹«ê¸°\"},\n            blocks=[\n                # ì‚¬ìš© ë°©ë²• ì•ˆë‚´\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*âœï¸ ì–´ë–¤ ë‚´ìš©ì„ ë³´ë‚´ë©´ ì¢‹ì„ê¹Œìš”?*\\n\"\n                        \"ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ë¥¼ ì‘ì„±í•  ë•ŒëŠ” ì•„ë˜ ë‚´ìš©ì„ ì°¸ê³ í•´ë³´ì„¸ìš”. ğŸ˜‰\\n\\n\"\n                        \"*`êµ¬ì²´ì ì¸ ìƒí™©`* - ì–´ë–¤ í™œë™ì´ë‚˜ ëŒ€í™”ì—ì„œ ê³ ë§ˆì›€ì„ ëŠê¼ˆëŠ”ì§€ ì´ì•¼ê¸°í•´ìš”.\\n\"\n                        \"*`êµ¬ì²´ì ì¸ ë‚´ìš©`* - ê·¸ ì‚¬ëŒì´ ì–´ë–¤ ë„ì›€ì„ ì¤¬ê±°ë‚˜, ì–´ë–¤ ë§ì„ í•´ì¤¬ëŠ”ì§€ ì ì–´ë³´ì„¸ìš”.\\n\"\n                        \"*`íš¨ê³¼ì™€ ê°ì‚¬ í‘œí˜„`* - ê·¸ í–‰ë™ì´ ë‚˜ì—ê²Œ ì–´ë–¤ ì˜í–¥ì„ ì£¼ì—ˆëŠ”ì§€, ì–¼ë§ˆë‚˜ ê°ì‚¬í•œì§€ í‘œí˜„í•´ìš”.\\n\"\n                        \"*`ì•ìœ¼ë¡œì˜ ê¸°ëŒ€`* - ì•ìœ¼ë¡œë„ ê³„ì† í•¨ê»˜í•´ì£¼ê¸¸ ë°”ë¼ëŠ” ë§ˆìŒì„ ì „í•´ë³´ì„¸ìš”!\",\n                    }\n                ),\n                DividerBlock(),\n                # ì˜ˆì‹œ ë©”ì‹œì§€\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*ğŸ’Œ ì¢…ì´ë¹„í–‰ê¸° ë©”ì‹œì§€ ì˜ˆì‹œ*\\n\",\n                    }\n                ),\n                # ì˜ˆì‹œ 1: ìŠ¤í„°ë”” í™œë™\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": 'ì˜ˆì‹œ 1: ìŠ¤í„°ë”” í™œë™\\n>\"00 ìŠ¤í„°ë””ì—ì„œ í•­ìƒ ì—´ì •ì ìœ¼ë¡œ ì°¸ì—¬í•´ì£¼ì…”ì„œ ì •ë§ ê°ì‚¬í•´ìš”! ë•ë¶„ì— ì €ë„ ë” ì—´ì‹¬íˆ í•˜ê²Œ ë˜ê³ , ë§ì€ ë°°ì›€ì„ ì–»ê³  ìˆì–´ìš”. ì•ìœ¼ë¡œë„ í•¨ê»˜ ì„±ì¥í•´ë‚˜ê°ˆ ìˆ˜ ìˆìœ¼ë©´ ì¢‹ê² ì–´ìš”! ğŸ˜Š\"',\n                        }\n                    ]\n                ),\n                # ì˜ˆì‹œ 2: ì»¤í”¼ì±— ëŒ€í™”\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": 'ì˜ˆì‹œ 2: ì»¤í”¼ì±— ëŒ€í™”\\n>\"ì§€ë‚œë²ˆ ì»¤í”¼ì±—ì—ì„œ ë‚˜ëˆˆ ëŒ€í™”ê°€ ì •ë§ ì¸ìƒ ê¹Šì—ˆì–´ìš”. ê°œë°œì— ëŒ€í•œ ìƒê°ì„ ë‚˜ëˆ„ê³  ì¡°ì–¸ì„ ì£¼ì…”ì„œ ê³ ë§™ìŠµë‹ˆë‹¤! ë‹¤ìŒì—ë„ ë˜ ì´ëŸ° ê¸°íšŒê°€ ìˆìœ¼ë©´ ì¢‹ê² ë„¤ìš”!\"',\n                        }\n                    ]\n                ),\n                # ì˜ˆì‹œ 3: ë°˜ìƒíšŒ ë°œí‘œ\n                ContextBlock(\n                    elements=[\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": 'ì˜ˆì‹œ 3: ë°˜ìƒíšŒ ë°œí‘œ\\n>\"ìµœê·¼ ë°˜ìƒíšŒì—ì„œ ë°œí‘œí•˜ì‹  ëª¨ìŠµì´ ì¸ìƒì ì´ì—ˆì–´ìš”! ë©€ë¦¬ì„œ ì§€ì¼œë³´ë©´ì„œ ë§ì€ ì˜ê°ì„ ë°›ì•˜ë‹µë‹ˆë‹¤. ğŸ˜Š ë‚˜ì¤‘ì— ê¸°íšŒê°€ ëœë‹¤ë©´ ì»¤í”¼ì±—ìœ¼ë¡œ ë” ê¹Šê²Œ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆŒ ìˆ˜ ìˆìœ¼ë©´ ì¢‹ê² ì–´ìš”!\"',\n                        }\n                    ]\n                ),\n                DividerBlock(),\n                # ê°€ì´ë“œ ë§ˆë¬´ë¦¬\n                SectionBlock(\n                    text={\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"ì´ì œ ì§„ì‹¬ì„ ë‹´ì€ ë©”ì‹œì§€ë¥¼ ì¢…ì´ë¹„í–‰ê¸°ë¡œ ì „ë‹¬í•´ë³´ì„¸ìš”! âœˆï¸\",\n                    }\n                ),\n            ],\n        ),\n    )\n\n\nasync def open_coffee_chat_history_view(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì»¤í”¼ì±— íˆìŠ¤í† ë¦¬ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    coffee_chat_proofs = service.fetch_coffee_chat_proofs(user_id=user.user_id)\n\n    blocks: list[Block] = []\n    for proof in coffee_chat_proofs:\n        blocks.append(SectionBlock(text=f\"*{ts_to_dt(proof.ts).strftime('%Y-%m-%d')}*\"))\n        text = proof.text[:100] + \" ...\" if len(proof.text) >= 100 else proof.text\n        blocks.append(ContextBlock(elements=[MarkdownTextObject(text=f\"> {text}\")]))\n\n    footer_blocks = (\n        [\n            DividerBlock(),\n            SectionBlock(\n                text=\"ì»¤í”¼ì±— ë‚´ì—­ì€ ìµœê·¼ 10ê°œê¹Œì§€ë§Œ í‘œì‹œë©ë‹ˆë‹¤.\\nì „ì²´ ë‚´ì—­ì„ í™•ì¸í•˜ë ¤ë©´ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.\",\n            ),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"ì „ì²´ ë‚´ì—­ ë‹¤ìš´ë¡œë“œ\",\n                        action_id=\"download_coffee_chat_history\",\n                        value=\"download_coffee_chat_history\",\n                        style=\"primary\",\n                    ),\n                ],\n            ),\n        ]\n        if blocks\n        else []\n    )\n\n    await client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view=View(\n            type=\"modal\",\n            title=f\"{user.name}ë‹˜ì˜ ì»¤í”¼ì±— ì¸ì¦ ë‚´ì—­\",\n            close=\"ë‹«ê¸°\",\n            blocks=(\n                SectionBlock(\n                    text=f\"ì´ *{len(coffee_chat_proofs)}* ê°œì˜ ì»¤í”¼ì±— ë‚´ì—­ì´ ìˆì–´ìš”.\",\n                ),\n                DividerBlock(),\n                *(\n                    blocks[:20]\n                    if blocks\n                    else [SectionBlock(text=\"ì•„ì§ ì»¤í”¼ì±— ì¸ì¦ ë‚´ì—­ì´ ì—†ì–´ìš”.\")]\n                ),\n                *footer_blocks,\n            ),\n        ),\n    )\n\n\nasync def download_coffee_chat_history(\n    ack: AsyncAck,\n    body: ActionBodyType,\n    say: AsyncSay,\n    client: AsyncWebClient,\n    user: User,\n    service: SlackService,\n    point_service: PointService,\n) -> None:\n    \"\"\"ì»¤í”¼ì±— íˆìŠ¤í† ë¦¬ë¥¼ CSV íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    response = await client.conversations_open(users=user.user_id)\n    dm_channel_id = response[\"channel\"][\"id\"]\n\n    proofs = service.fetch_coffee_chat_proofs(user_id=user.user_id)\n    if not proofs:\n        await client.chat_postMessage(\n            channel=dm_channel_id, text=\"ì»¤í”¼ì±— ì¸ì¦ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.\"\n        )\n        return None\n\n    # ì‚¬ìš©ìì˜ ì œì¶œë‚´ì—­ì„ CSV íŒŒì¼ë¡œ ì„ì‹œ ì €ì¥ í›„ ì „ì†¡\n    temp_dir = \"temp/coffee_chat_proofs\"\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir)\n\n    temp_file_path = f\"{temp_dir}/{user.name}-ì»¤í”¼ì±—-ì¸ì¦-ë‚´ì—­.csv\"\n    with open(temp_file_path, \"w\", newline=\"\") as csvfile:\n        writer = csv.DictWriter(\n            csvfile,\n            CoffeeChatProof.fieldnames(),\n            quoting=csv.QUOTE_ALL,\n        )\n        writer.writeheader()\n        writer.writerows([each.model_dump() for each in proofs])\n\n    res = await client.files_upload_v2(\n        channel=dm_channel_id,\n        file=temp_file_path,\n        initial_comment=f\"<@{user.user_id}> ë‹˜ì˜ ì»¤í”¼ì±— ì¸ì¦ ë‚´ì—­ ì…ë‹ˆë‹¤.\",\n    )\n\n    await client.chat_postMessage(\n        channel=dm_channel_id,\n        text=f\"<@{user.user_id}> ë‹˜ì˜ <{res['file']['permalink']}|ì»¤í”¼ì±— ì¸ì¦ ë‚´ì—­> ì…ë‹ˆë‹¤.\",\n    )\n\n    # ì„ì‹œë¡œ ìƒì„±í•œ CSV íŒŒì¼ì„ ì‚­ì œ\n    os.remove(temp_file_path)\n\n\nasync def handle_channel_created(\n    ack: AsyncAck,\n    body: ChannelCreatedBodyType,\n    client: AsyncWebClient,\n):\n    \"\"\"ê³µê°œ ì±„ë„ ìƒì„± ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.\"\"\"\n    await ack()\n\n    channel_id = body[\"event\"][\"channel\"][\"id\"]\n    await client.conversations_join(channel=channel_id)\n    await client.chat_postMessage(\n        channel=settings.ADMIN_CHANNEL,\n        text=f\"ìƒˆë¡œ ë§Œë“¤ì–´ì§„ <#{channel_id}> ì±„ë„ì— ë˜ë´‡ì´ ì°¸ì—¬í–ˆìŠµë‹ˆë‹¤. ğŸ˜‹\",\n    )\n"}
{"type": "source_file", "path": "app/slack/services/background.py", "content": "import csv\nfrom datetime import timedelta\nimport os\nimport traceback\nfrom typing import TypedDict\n\nimport pandas as pd\nimport tenacity\nfrom app.constants import remind_message\nfrom app.logging import log_event\nfrom app.models import User\nfrom app.slack.repositories import SlackRepository\nfrom slack_sdk.models.blocks import (\n    SectionBlock,\n    TextObject,\n    ActionsBlock,\n    ContextBlock,\n    ButtonElement,\n    DividerBlock,\n)\n\nfrom slack_bolt.async_app import AsyncApp\nfrom app.config import settings\n\n\nimport asyncio\n\nfrom app.utils import dict_to_json_str, tz_now\n\n\nclass SubscriptionMessage(TypedDict):\n    user_id: str\n    target_user_id: str\n    target_user_channel: str\n    ts: str\n    title: str\n    dt: str\n\n\nclass BackgroundService:\n    def __init__(self, repo: SlackRepository) -> None:\n        self._repo = repo\n\n    async def send_reminder_message_to_user(self, slack_app: AsyncApp) -> None:\n        \"\"\"ì‚¬ìš©ìì—ê²Œ ë¦¬ë§ˆì¸ë“œ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.\"\"\"\n        users = self._repo.fetch_users()\n\n        target_users: list[User] = []\n        for user in users:\n            if user.cohort != \"10ê¸°\":  # 10ê¸° ì™¸ì˜ ì‚¬ìš©ì ì œì™¸\n                continue\n            if user.channel_name == \"-\":  # ì±„ë„ ì´ë¦„ì´ ì—†ëŠ” ê²½ìš° ì œì™¸\n                continue\n            if user.is_submit:  # ì´ë¯¸ ì œì¶œí•œ ê²½ìš° ì œì™¸\n                continue\n\n            target_users.append(user)\n\n        for user in target_users:\n            log_event(\n                actor=\"slack_reminder_service\",\n                event=\"send_reminder_message_to_user\",\n                type=\"reminder\",\n                description=f\"{user.name} ë‹˜ì—ê²Œ ë¦¬ë§ˆì¸ë“œ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.\",\n            )\n\n            await slack_app.client.chat_postMessage(\n                channel=user.user_id,\n                text=remind_message.format(user_name=user.name),\n            )\n\n            # ìŠ¬ë™ì€ ë©”ì‹œì§€ ì „ì†¡ì„ ì´ˆë‹¹ 1ê°œë¥¼ ê¶Œì¥í•˜ê¸° ë•Œë¬¸ì— 1ì´ˆ ëŒ€ê¸°í•©ë‹ˆë‹¤.\n            # ì°¸ê³ ë¬¸ì„œ: https://api.slack.com/methods/chat.postMessage#rate_limiting\n            await asyncio.sleep(1)\n\n        await slack_app.client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL,\n            text=f\"ì´ {len(target_users)} ëª…ì—ê²Œ ë¦¬ë§ˆì¸ë“œ ë©”ì‹œì§€ë¥¼ ì „ì†¡í–ˆìŠµë‹ˆë‹¤.\",\n        )\n\n    async def prepare_subscribe_message_data(self) -> None:\n        \"\"\"ì‚¬ìš©ìì—ê²Œ êµ¬ë… ì•Œë¦¼ ë©”ì‹œì§€ ëª©ë¡ì„ ì„ì‹œ CSV íŒŒì¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.\"\"\"\n\n        # ê¸°ì¡´ ì„ì‹œ íŒŒì¼ ì‚­ì œ\n        if os.path.exists(\"store/_subscription_messages.csv\"):\n            os.remove(\"store/_subscription_messages.csv\")\n\n        # ëª¨ë“  êµ¬ë… ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤\n        subscriptions = self._repo.fetch_subscriptions()\n\n        # êµ¬ë… ëŒ€ìƒìë“¤ì˜ user_idë¥¼ ì¤‘ë³µ ì—†ì´ setìœ¼ë¡œ ì¶”ì¶œí•©ë‹ˆë‹¤\n        target_user_ids = {\n            subscription.target_user_id for subscription in subscriptions\n        }\n\n        yesterday = (tz_now() - timedelta(days=1)).date()\n        contents_df = pd.read_csv(\"store/contents.csv\")\n\n        # dt ì»¬ëŸ¼ì„ datetime íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ê³  date ë¶€ë¶„ë§Œ ì¶”ì¶œí•©ë‹ˆë‹¤\n        contents_df[\"dt\"] = pd.to_datetime(contents_df[\"dt\"]).dt.date\n\n        # êµ¬ë… ëŒ€ìƒìì˜ ì½˜í…ì¸  ì¤‘ ì–´ì œ ì‘ì„±ëœ ì œì¶œ ê¸€ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤\n        filtered_contents = contents_df[\n            (contents_df[\"user_id\"].isin(target_user_ids))\n            & (contents_df[\"dt\"] == yesterday)\n            & (contents_df[\"type\"] == \"submit\")\n        ]\n\n        # êµ¬ë… ì•Œë¦¼ ë©”ì‹œì§€ ë°ì´í„°ë¥¼ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸\n        subscription_messages: list[SubscriptionMessage] = []\n\n        # ê° êµ¬ë… ëŒ€ìƒìë³„ë¡œ ì²˜ë¦¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤\n        for target_user_id in target_user_ids:\n            target_contents = filtered_contents[\n                filtered_contents[\"user_id\"] == target_user_id\n            ]\n\n            # í•´ë‹¹ êµ¬ë… ëŒ€ìƒìì˜ ì½˜í…ì¸ ê°€ ì—†ìœ¼ë©´ ë‹¤ìŒ ëŒ€ìƒìë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤\n            if len(target_contents) == 0:\n                continue\n\n            # í˜„ì¬ êµ¬ë… ëŒ€ìƒìë¥¼ êµ¬ë…í•˜ëŠ” ëª¨ë“  êµ¬ë…ì ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤\n            target_subscriptions = self._repo.fetch_subscriptions_by_target_user_id(\n                target_user_id\n            )\n\n            # êµ¬ë…ìì—ê²Œ ë³´ë‚¼ ì•Œë¦¼ì„ ë°°ì—´ì— ë‹´ìŠµë‹ˆë‹¤.\n            for subscription in target_subscriptions:\n                for _, content in target_contents.iterrows():\n                    subscription_messages.append(\n                        {\n                            \"user_id\": subscription.user_id,\n                            \"target_user_id\": target_user_id,\n                            \"target_user_channel\": subscription.target_user_channel,\n                            \"ts\": content[\"ts\"],\n                            \"title\": content[\"title\"],\n                            \"dt\": content[\"dt\"],\n                        }\n                    )\n\n        # ì„ì‹œ CSV íŒŒì¼ì— ì €ì¥í•©ë‹ˆë‹¤.\n        if subscription_messages:\n            pd.DataFrame(subscription_messages).to_csv(\n                \"store/_subscription_messages.csv\",\n                index=False,\n                quoting=csv.QUOTE_ALL,\n            )\n\n    async def send_subscription_messages(self, slack_app: AsyncApp) -> None:\n        \"\"\"ì‚¬ìš©ìì—ê²Œ êµ¬ë… ì•Œë¦¼ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.\"\"\"\n        if not os.path.exists(\"store/_subscription_messages.csv\"):\n            return\n\n        df = pd.read_csv(\"store/_subscription_messages.csv\")\n        for _, row in df.iterrows():\n            try:\n                message: SubscriptionMessage = row.to_dict()\n                await self._send_subscription_message(slack_app, message)\n\n            except Exception as e:\n                trace = traceback.format_exc()\n                error_message = f\"âš ï¸ <@{row['user_id']}>ë‹˜ì˜ êµ¬ë… ì•Œë¦¼ ë©”ì‹œì§€ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì˜¤ë¥˜: {e} {trace}\"\n                log_event(\n                    actor=\"slack_subscribe_service\",\n                    event=\"send_subscription_message_to_user\",\n                    type=\"error\",\n                    description=error_message,\n                )\n                await slack_app.client.chat_postMessage(\n                    channel=settings.ADMIN_CHANNEL,\n                    text=error_message,\n                )\n                continue\n\n        await slack_app.client.chat_postMessage(\n            channel=settings.ADMIN_CHANNEL,\n            text=f\"ì´ {len(df['user_id'].unique())} ëª…ì—ê²Œ {len(df)} ê°œì˜ êµ¬ë… ì•Œë¦¼ ë©”ì‹œì§€ë¥¼ ì „ì†¡í–ˆìŠµë‹ˆë‹¤.\",\n        )\n\n    @tenacity.retry(\n        stop=tenacity.stop_after_attempt(3),\n        wait=tenacity.wait_fixed(1),\n        reraise=True,\n    )\n    async def _send_subscription_message(\n        self, slack_app: AsyncApp, message: SubscriptionMessage\n    ) -> None:\n        permalink_res = await slack_app.client.chat_getPermalink(\n            message_ts=message[\"ts\"],\n            channel=message[\"target_user_channel\"],\n        )\n\n        text = f\"êµ¬ë…í•˜ì‹  <@{message['target_user_id']}>ë‹˜ì˜ ìƒˆë¡œìš´ ê¸€ì´ ì˜¬ë¼ì™”ì–´ìš”! ğŸ¤©\"\n        blocks = [\n            SectionBlock(\n                text=text,\n            ),\n            ContextBlock(\n                elements=[\n                    TextObject(\n                        type=\"mrkdwn\",\n                        text=f\"ê¸€ ì œëª© : {message['title']}\\nì œì¶œ ë‚ ì§œ : {message['dt'][:4]}ë…„ {int(message['dt'][5:7])}ì›” {int(message['dt'][8:10])}ì¼\",\n                    ),\n                ],\n            ),\n            ActionsBlock(\n                elements=[\n                    ButtonElement(\n                        text=\"ê¸€ ë³´ëŸ¬ê°€ê¸°\",\n                        action_id=\"open_subscription_permalink\",\n                        url=permalink_res[\"permalink\"],\n                        style=\"primary\",\n                        value=dict_to_json_str(\n                            {\n                                \"user_id\": message[\"user_id\"],  # êµ¬ë…ì\n                                \"ts\": message[\"ts\"],  # í´ë¦­í•œ ì½˜í…ì¸  id\n                            }\n                        ),\n                    ),\n                    ButtonElement(\n                        text=\"ê°ì‚¬ì˜ ì¢…ì´ë¹„í–‰ê¸° ë³´ë‚´ê¸°\",\n                        action_id=\"send_paper_plane_message\",\n                        value=message[\"target_user_id\"],\n                    ),\n                ]\n            ),\n            DividerBlock(),\n        ]\n        await slack_app.client.chat_postMessage(\n            channel=message[\"user_id\"],\n            text=text,\n            blocks=blocks,\n        )\n\n        # ìŠ¬ë™ì€ ë©”ì‹œì§€ ì „ì†¡ì„ ì´ˆë‹¹ 1ê°œë¥¼ ê¶Œì¥í•˜ê¸° ë•Œë¬¸ì— 1ì´ˆ ëŒ€ê¸°í•©ë‹ˆë‹¤.\n        # ì°¸ê³ ë¬¸ì„œ: https://api.slack.com/methods/chat.postMessage#rate_limiting\n        await asyncio.sleep(1)\n"}
{"type": "source_file", "path": "app/utils.py", "content": "import csv\nimport random\nimport string\nfrom typing import Any\nimport orjson\nimport regex as re\nimport datetime\n\nfrom zoneinfo import ZoneInfo\n\nimport googletrans\n\n\ndef tz_now(tz: str = \"Asia/Seoul\") -> datetime.datetime:\n    \"\"\"í˜„ì¬ì‹œê°„ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n    return datetime.datetime.now(tz=ZoneInfo(tz))\n\n\ndef tz_now_to_str(tz: str = \"Asia/Seoul\") -> str:\n    \"\"\"í˜„ì¬ì‹œê°„ì„ ë¬¸ìì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.\"\"\"\n    return datetime.datetime.strftime(tz_now(tz), \"%Y-%m-%d %H:%M:%S\")\n\n\ndef generate_unique_id() -> str:\n    \"\"\"ê³ ìœ í•œ IDë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\"\"\"\n    # ë¬´ì‘ìœ„ ë¬¸ìì—´ 6ìë¦¬ + ë°€ë¦¬ ì„¸ì»¨ì¦ˆ(ë¬¸ìë¡œ ì¹˜í™˜ëœ)\n    random_str = \"\".join(random.choices(string.ascii_letters + string.digits, k=6))\n    return f\"{random_str}{str(int(datetime.datetime.now().timestamp() * 1000))}\"\n\n\ndef is_english(text):\n    \"\"\"ì˜ì–´ì¸ì§€ í•œê¸€ì¸ì§€ íŒë³„í•©ë‹ˆë‹¤.\"\"\"\n    if re.match(\"^[a-zA-Z]+$\", text):\n        return True\n    elif re.match(\"^[ê°€-í£]+$\", text):\n        return False\n    else:\n        return None\n\n\ndef translate_keywords(keywords: list[str]) -> list[str]:\n    \"\"\"í‚¤ì›Œë“œë¥¼ ë²ˆì—­í•©ë‹ˆë‹¤.\"\"\"\n    translator = googletrans.Translator()\n    results = []\n    for keyword in keywords:\n        value = is_english(keyword)\n        if value is True:\n            # ì˜ì–´ -> í•œê¸€ ë²ˆì—­, í•œê¸€ì´ ì—†ëŠ” ë‹¨ì–´ëŠ” ê·¸ëŒ€ë¡œ ì˜ì–´ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆìŒ.\n            results.append(translator.translate(keyword, dest=\"ko\").text.lower())\n        elif value is False:\n            results.append(translator.translate(keyword, dest=\"en\").text.lower())\n        else:\n            continue\n    return results\n\n\ndef remove_emoji(message: str) -> str:\n    \"\"\"ì´ëª¨ì§€ë¥¼ ì œê±°í•©ë‹ˆë‹¤.\"\"\"\n    emoji_code_pattern = re.compile(r\":[a-zA-Z0-9_\\-]+:|:\\p{Script=Hangul}+:\")\n    return emoji_code_pattern.sub(r\"\", message)\n\n\ndef slack_link_to_markdown(text):\n    \"\"\"Slack ë§í¬ë¥¼ ë§ˆí¬ë‹¤ìš´ ë§í¬ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.\"\"\"\n    pattern = re.compile(r\"<(http[s]?://[^\\|]+)\\|([^\\>]+)>\")\n    return pattern.sub(r\"[\\2](\\1)\", text)\n\n\ndef convert_user_id_to_name(message: str) -> str:\n    \"\"\"ìŠ¬ë™ ë©”ì‹œì§€ì—ì„œ user_idë¥¼ nameìœ¼ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.\"\"\"\n    with open(\"store/users.csv\") as f:\n        reader = csv.DictReader(f)\n        user_dict = {row[\"user_id\"]: row[\"name\"] for row in reader}\n\n    user_ids = re.findall(\"<@([A-Z0-9]+)>\", message)\n\n    for user_id in user_ids:\n        name = user_dict.get(user_id, user_id)\n        message = message.replace(f\"<@{user_id}>\", name)\n\n    return message\n\n\ndef dict_to_json_str(data: dict[str, Any]) -> str:\n    \"\"\"dictë¥¼ json stringìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.\"\"\"\n    return orjson.dumps(data).decode(\"utf-8\")\n\n\ndef json_str_to_dict(data: str) -> dict[str, Any]:\n    \"\"\"json stringì„ dictë¡œ ë³€í™˜í•©ë‹ˆë‹¤.\"\"\"\n    return orjson.loads(data)\n\n\ndef ts_to_dt(ts: str) -> datetime.datetime:\n    \"\"\"timestampë¥¼ datetimeìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.\"\"\"\n    return datetime.datetime.fromtimestamp(float(ts))\n"}

{"repo_info": {"repo_name": "yolov8-fastapi", "repo_owner": "Alex-Lekov", "repo_url": "https://github.com/Alex-Lekov/yolov8-fastapi"}}
{"type": "test_file", "path": "tests/test_app.py", "content": "import pytest\nfrom PIL import Image\nimport pandas as pd\nimport sys\nimport os\nimport io\n\n# pytest app import fix\ndynamic_path = os.path.abspath('.')\nprint(dynamic_path)\n\nsys.path.append(dynamic_path)\n\nfrom app import *\n\n\n################################ Fixtures #####################################################\n\n@pytest.fixture\ndef test_image():\n    \"\"\"\n    Fixture to return a file object of the test image used for testing.\n    \"\"\"\n    files = {'file': open('./tests/test_image.jpg', 'rb')}\n    return(files)\n\n@pytest.fixture\ndef input_image():\n    \"\"\"\n    Fixture to return a PIL image object of the test image used for testing.\n    \"\"\"\n    input_image = Image.open('./tests/test_image.jpg').convert(\"RGB\")\n    return(input_image)\n\n@pytest.fixture\ndef predictions():\n    \"\"\"\n    Fixture to return the predictions and label names for the test image.\n    \"\"\"\n    input_image = Image.open('./tests/test_image.jpg').convert(\"RGB\")\n    model = YOLO(\"./models/sample_model/yolov8n.pt\")\n    predictions = model.predict(source=input_image)\n    return(predictions, model.model.names)\n\n\n################################ Test #####################################################\n\ndef test_get_image_from_bytes(test_image):\n    \"\"\"\n    Test to check if the function 'get_image_from_bytes' is converting the binary image data to a PIL image object.\n    \"\"\"\n    binary_image = test_image['file'].read()\n    output = get_image_from_bytes(binary_image)\n    assert isinstance(output, Image.Image) and output.mode == \"RGB\"\n\ndef test_get_bytes_from_image(input_image):\n    \"\"\"\n    Test to check if the function 'get_bytes_from_image' is converting the PIL image object to binary image data.\n    \"\"\"\n    output = get_bytes_from_image(input_image)\n    assert isinstance(output, io.BytesIO)\n\ndef test_initialize_models():\n    \"\"\"\n    Test to check if all the models are loading correctly.\n    \"\"\"\n    model_sample_model = YOLO(\"./models/sample_model/yolov8n.pt\")\n    assert model_sample_model is not None\n\ndef test_transform_predict_to_df(predictions):\n    \"\"\"\n    Test the function 'transform_predict_to_df' which converts the predictions from the YOLO model to a pandas DataFrame.\n    It takes in two arguments:\n        predictions: A list of dictionaries returned by the YOLO model\n        label_names: A list of class labels for the YOLO model\n    It returns a DataFrame with columns:\n        'xmin', 'ymin', 'xmax', 'ymax', 'confidence', 'class', 'name'\n    Asserts:\n        - The returned object is a DataFrame\n        - The columns of the DataFrame are as expected\n        - The DataFrame contains at least one object of class 'dog'\n    \"\"\"\n    predictions, label_names = predictions\n    predict_bbox = transform_predict_to_df(predictions, label_names)\n    # Check if the returned object is an instance of pd.DataFrame\n    assert isinstance(predict_bbox, pd.DataFrame)\n    # Check if the returned DataFrame has the correct columns\n    assert set(predict_bbox.columns) == set(['xmin', 'ymin', 'xmax','ymax', 'confidence', 'class', 'name'])\n    assert 'dog' in predict_bbox.name.tolist()\n\ndef test_get_model_predict(input_image):\n    \"\"\"\n    Test to check if the function 'get_model_predict' is returning a DataFrame object with the correct columns and number of rows.\n    It also checks if the returned object is an instance of pd.DataFrame\n    \"\"\"\n    model_sample_model = YOLO(\"./models/sample_model/yolov8n.pt\")\n    predictions = get_model_predict(model_sample_model, input_image)\n    # Check if the returned object is an instance of pd.DataFrame\n    assert isinstance(predictions, pd.DataFrame)\n    # Check if the returned DataFrame has the correct columns\n    assert set(predictions.columns) == set(['xmin', 'ymin', 'xmax','ymax', 'confidence', 'class', 'name'])\n    # Check if the returned DataFrame has more than one row\n    assert len(predictions) > 1\n\ndef test_add_bboxs_on_img(input_image, predictions):\n    \"\"\"\n    Test to check if the function 'add_bboxs_on_img' is adding bounding boxes on the image and returning the image object.\n    \"\"\"\n    predictions, label_names = predictions\n    predict_bbox = transform_predict_to_df(predictions, label_names)\n    image_with_bbox = add_bboxs_on_img(input_image, predict_bbox)\n    assert isinstance(image_with_bbox, Image.Image)"}
{"type": "test_file", "path": "tests/test_main.py", "content": "import pytest\nimport requests\nimport time\nfrom PIL import Image\nimport pandas as pd\nimport sys\nimport os\n\n# FastAPI\nfrom fastapi.testclient import TestClient\nfrom fastapi import File, HTTPException\n\n# pytest app import fix\ndynamic_path = os.path.abspath('.')\nprint(dynamic_path)\n\nsys.path.append(dynamic_path)\n\nfrom main import crop_image_by_predict\nfrom main import app\n\n################################ Fixtures #####################################################\n\n\n@pytest.fixture\ndef test_image():\n    files = {'file': open('./tests/test_image.jpg', 'rb')}\n    return(files)\n\n@pytest.fixture\ndef test_client():\n    return TestClient(app)\n\n################################ Test #####################################################\n\n\ndef test_healthcheck(test_client):\n    \"\"\"\n    This test function is used to test the /healthcheck endpoint of the application.\n    It uses the test client to send a GET request to the endpoint and then asserts that the response has a status code of 200 and a json payload of {\"healthcheck\": \"Everything OK!\"}\n    This function is important to check if the application is running correctly and all the dependencies are working as expected.\n    \"\"\"\n    # Send a GET request to the '/healthcheck' endpoint\n    response = test_client.get(\"/healthcheck\")\n    # Assert that the response has a status code of 200\n    assert response.status_code == 200\n    # Assert that the response has a json payload of {\"healthcheck\": \"Everything OK!\"}\n    assert response.json() == {\"healthcheck\": \"Everything OK!\"}\n\n\ndef test_crop_image_by_predict():\n    \"\"\"\n    Test for the crop_image_by_predict function.\n    This function crops an image given a prediction dataframe and a class name.\n    \"\"\"\n    # Create a test image\n    test_image = Image.new(\"RGB\", (100, 100), \"white\")\n\n    # Create a test predict dataframe\n    test_predict = pd.DataFrame(\n        data={\n            \"name\": [\"test_object\", \"other_object\"],\n            \"xmin\": [10, 20],\n            \"ymin\": [10, 20],\n            \"xmax\": [50, 60],\n            \"ymax\": [50, 60],\n        }\n    )\n\n    # Test cropping by an object that is present in the image\n    cropped_image = crop_image_by_predict(test_image, test_predict, \"test_object\")\n    assert cropped_image.size == (40, 40)\n\n    # Test cropping by an object that is not present in the image\n    with pytest.raises(HTTPException) as excinfo:\n        crop_class_name = \"non_existent_object\" \n        crop_image_by_predict(test_image, test_predict, \"non_existent_object\")\n    assert excinfo.value.detail == f\"{crop_class_name} not found in photo\"\n\n\n\ndef test_img_object_detection_to_json(test_client, test_image):\n    \"\"\"Test the image recognition to json endpoint with a test image.\n\n    Args:\n        test_client (TestClient): Fixture that allows to send HTTP requests to the application.\n        image_meters_0 (Tuple): Fixture that contains a test image file.\n    \"\"\"\n    # Send a POST request to the endpoint with the test image\n    response = test_client.post(\"/img_object_detection_to_json\", files=test_image)\n\n    # Assert that the request was successful (status code 200)\n    assert response.status_code == 200\n\n    # Assert that the response is in JSON format\n    assert response.headers[\"content-type\"] == \"application/json\"\n\n    # Get the JSON data from the response\n    data = response.json()\n\n    # Assert that the JSON data contains the expected keys\n    assert 'detect_objects_names' in data\n    assert 'detect_objects' in data\n\n    # Assert that the detect_objects values are not None\n    assert data['detect_objects_names'] is not None\n    assert data['detect_objects'] is not None\n\n    # Assert that the rate values are 'cat, dog'\n    assert data['detect_objects_names'] == 'cat, dog'\n\n    # Additional asserts can be added to check for specific values of the rate type\n    # or other keys in the JSON data, if needed.\n\n\n\ndef test_img_object_detection_to_img(test_client, test_image):\n    \"\"\"This test is checking the functionality of the endpoint \"/img_object_detection_to_img\" using the test_client fixture and the image_meters_0 file. It is performing a POST request to the endpoint with image_meters_0 as the file.\n    The test asserts that the response status code is 200, indicating a successful request. It also asserts that the content type of the response is \"image/jpeg\" and that the content of the response is not None. This indicates that the image was properly returned in the response.\n    The test also includes a comment suggesting that additional assertions can be added to check if the image is properly annotated with bounding boxes, which can be used to detect the display on the meter.\n    \"\"\"\n    # send POST request to endpoint with image_meters_0 as the file\n    response = test_client.post(\"/img_object_detection_to_img\", files=test_image)\n    # assert that the response status code is 200\n    assert response.status_code == 200\n    # assert that the content type of the response is \"image/jpeg\"\n    assert response.headers[\"content-type\"] == \"image/jpeg\"\n    # assert that the content type of the response is not None\n    assert response.content != None\n    # Additional assertions can be added to check if the image is properly annotated with bbox"}
{"type": "source_file", "path": "main.py", "content": "####################################### IMPORT #################################\nimport json\nimport pandas as pd\nfrom PIL import Image\nfrom loguru import logger\nimport sys\n\nfrom fastapi import FastAPI, File, status\nfrom fastapi.responses import RedirectResponse\nfrom fastapi.responses import StreamingResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.exceptions import HTTPException\n\nfrom io import BytesIO\n\nfrom app import get_image_from_bytes\nfrom app import detect_sample_model\nfrom app import add_bboxs_on_img\nfrom app import get_bytes_from_image\n\n####################################### logger #################################\n\nlogger.remove()\nlogger.add(\n    sys.stderr,\n    colorize=True,\n    format=\"<green>{time:HH:mm:ss}</green> | <level>{message}</level>\",\n    level=10,\n)\nlogger.add(\"log.log\", rotation=\"1 MB\", level=\"DEBUG\", compression=\"zip\")\n\n###################### FastAPI Setup #############################\n\n# title\napp = FastAPI(\n    title=\"Object Detection FastAPI Template\",\n    description=\"\"\"Obtain object value out of image\n                    and return image and json result\"\"\",\n    version=\"2023.1.31\",\n)\n\n# This function is needed if you want to allow client requests \n# from specific domains (specified in the origins argument) \n# to access resources from the FastAPI server, \n# and the client and server are hosted on different domains.\norigins = [\n    \"http://localhost\",\n    \"http://localhost:8008\",\n    \"*\"\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.on_event(\"startup\")\ndef save_openapi_json():\n    '''This function is used to save the OpenAPI documentation \n    data of the FastAPI application to a JSON file. \n    The purpose of saving the OpenAPI documentation data is to have \n    a permanent and offline record of the API specification, \n    which can be used for documentation purposes or \n    to generate client libraries. It is not necessarily needed, \n    but can be helpful in certain scenarios.'''\n    openapi_data = app.openapi()\n    # Change \"openapi.json\" to desired filename\n    with open(\"openapi.json\", \"w\") as file:\n        json.dump(openapi_data, file)\n\n# redirect\n@app.get(\"/\", include_in_schema=False)\nasync def redirect():\n    return RedirectResponse(\"/docs\")\n\n\n@app.get('/healthcheck', status_code=status.HTTP_200_OK)\ndef perform_healthcheck():\n    '''\n    It basically sends a GET request to the route & hopes to get a \"200\"\n    response code. Failing to return a 200 response code just enables\n    the GitHub Actions to rollback to the last version the project was\n    found in a \"working condition\". It acts as a last line of defense in\n    case something goes south.\n    Additionally, it also returns a JSON response in the form of:\n    {\n        'healtcheck': 'Everything OK!'\n    }\n    '''\n    return {'healthcheck': 'Everything OK!'}\n\n\n######################### Support Func #################################\n\ndef crop_image_by_predict(image: Image, predict: pd.DataFrame(), crop_class_name: str,) -> Image:\n    \"\"\"Crop an image based on the detection of a certain object in the image.\n    \n    Args:\n        image: Image to be cropped.\n        predict (pd.DataFrame): Dataframe containing the prediction results of object detection model.\n        crop_class_name (str, optional): The name of the object class to crop the image by. if not provided, function returns the first object found in the image.\n    \n    Returns:\n        Image: Cropped image or None\n    \"\"\"\n    crop_predicts = predict[(predict['name'] == crop_class_name)]\n\n    if crop_predicts.empty:\n        raise HTTPException(status_code=400, detail=f\"{crop_class_name} not found in photo\")\n\n    # if there are several detections, choose the one with more confidence\n    if len(crop_predicts) > 1:\n        crop_predicts = crop_predicts.sort_values(by=['confidence'], ascending=False)\n\n    crop_bbox = crop_predicts[['xmin', 'ymin', 'xmax','ymax']].iloc[0].values\n    # crop\n    img_crop = image.crop(crop_bbox)\n    return(img_crop)\n\n\n######################### MAIN Func #################################\n\n\n@app.post(\"/img_object_detection_to_json\")\ndef img_object_detection_to_json(file: bytes = File(...)):\n    \"\"\"\n    Object Detection from an image.\n\n    Args:\n        file (bytes): The image file in bytes format.\n    Returns:\n        dict: JSON format containing the Objects Detections.\n    \"\"\"\n    # Step 1: Initialize the result dictionary with None values\n    result={'detect_objects': None}\n\n    # Step 2: Convert the image file to an image object\n    input_image = get_image_from_bytes(file)\n\n    # Step 3: Predict from model\n    predict = detect_sample_model(input_image)\n\n    # Step 4: Select detect obj return info\n    # here you can choose what data to send to the result\n    detect_res = predict[['name', 'confidence']]\n    objects = detect_res['name'].values\n\n    result['detect_objects_names'] = ', '.join(objects)\n    result['detect_objects'] = json.loads(detect_res.to_json(orient='records'))\n\n    # Step 5: Logs and return\n    logger.info(\"results: {}\", result)\n    return result\n\n@app.post(\"/img_object_detection_to_img\")\ndef img_object_detection_to_img(file: bytes = File(...)):\n    \"\"\"\n    Object Detection from an image plot bbox on image\n\n    Args:\n        file (bytes): The image file in bytes format.\n    Returns:\n        Image: Image in bytes with bbox annotations.\n    \"\"\"\n    # get image from bytes\n    input_image = get_image_from_bytes(file)\n\n    # model predict\n    predict = detect_sample_model(input_image)\n\n    # add bbox on image\n    final_image = add_bboxs_on_img(image = input_image, predict = predict)\n\n    # return image in bytes format\n    return StreamingResponse(content=get_bytes_from_image(final_image), media_type=\"image/jpeg\")\n\n"}
{"type": "source_file", "path": "app.py", "content": "from PIL import Image\nimport io\nimport pandas as pd\nimport numpy as np\n\nfrom typing import Optional\n\nfrom ultralytics import YOLO\nfrom ultralytics.yolo.utils.plotting import Annotator, colors\n\n\n# Initialize the models\nmodel_sample_model = YOLO(\"./models/sample_model/yolov8n.pt\")\n\n\ndef get_image_from_bytes(binary_image: bytes) -> Image:\n    \"\"\"Convert image from bytes to PIL RGB format\n    \n    Args:\n        binary_image (bytes): The binary representation of the image\n    \n    Returns:\n        PIL.Image: The image in PIL RGB format\n    \"\"\"\n    input_image = Image.open(io.BytesIO(binary_image)).convert(\"RGB\")\n    return input_image\n\n\ndef get_bytes_from_image(image: Image) -> bytes:\n    \"\"\"\n    Convert PIL image to Bytes\n    \n    Args:\n    image (Image): A PIL image instance\n    \n    Returns:\n    bytes : BytesIO object that contains the image in JPEG format with quality 85\n    \"\"\"\n    return_image = io.BytesIO()\n    image.save(return_image, format='JPEG', quality=85)  # save the image in JPEG format with quality 85\n    return_image.seek(0)  # set the pointer to the beginning of the file\n    return return_image\n\ndef transform_predict_to_df(results: list, labeles_dict: dict) -> pd.DataFrame:\n    \"\"\"\n    Transform predict from yolov8 (torch.Tensor) to pandas DataFrame.\n\n    Args:\n        results (list): A list containing the predict output from yolov8 in the form of a torch.Tensor.\n        labeles_dict (dict): A dictionary containing the labels names, where the keys are the class ids and the values are the label names.\n        \n    Returns:\n        predict_bbox (pd.DataFrame): A DataFrame containing the bounding box coordinates, confidence scores and class labels.\n    \"\"\"\n    # Transform the Tensor to numpy array\n    predict_bbox = pd.DataFrame(results[0].to(\"cpu\").numpy().boxes.xyxy, columns=['xmin', 'ymin', 'xmax','ymax'])\n    # Add the confidence of the prediction to the DataFrame\n    predict_bbox['confidence'] = results[0].to(\"cpu\").numpy().boxes.conf\n    # Add the class of the prediction to the DataFrame\n    predict_bbox['class'] = (results[0].to(\"cpu\").numpy().boxes.cls).astype(int)\n    # Replace the class number with the class name from the labeles_dict\n    predict_bbox['name'] = predict_bbox[\"class\"].replace(labeles_dict)\n    return predict_bbox\n\ndef get_model_predict(model: YOLO, input_image: Image, save: bool = False, image_size: int = 1248, conf: float = 0.5, augment: bool = False) -> pd.DataFrame:\n    \"\"\"\n    Get the predictions of a model on an input image.\n    \n    Args:\n        model (YOLO): The trained YOLO model.\n        input_image (Image): The image on which the model will make predictions.\n        save (bool, optional): Whether to save the image with the predictions. Defaults to False.\n        image_size (int, optional): The size of the image the model will receive. Defaults to 1248.\n        conf (float, optional): The confidence threshold for the predictions. Defaults to 0.5.\n        augment (bool, optional): Whether to apply data augmentation on the input image. Defaults to False.\n    \n    Returns:\n        pd.DataFrame: A DataFrame containing the predictions.\n    \"\"\"\n    # Make predictions\n    predictions = model.predict(\n                        imgsz=image_size, \n                        source=input_image, \n                        conf=conf,\n                        save=save, \n                        augment=augment,\n                        flipud= 0.0,\n                        fliplr= 0.0,\n                        mosaic = 0.0,\n                        )\n    \n    # Transform predictions to pandas dataframe\n    predictions = transform_predict_to_df(predictions, model.model.names)\n    return predictions\n\n\n################################# BBOX Func #####################################\n\ndef add_bboxs_on_img(image: Image, predict: pd.DataFrame()) -> Image:\n    \"\"\"\n    add a bounding box on the image\n\n    Args:\n    image (Image): input image\n    predict (pd.DataFrame): predict from model\n\n    Returns:\n    Image: image whis bboxs\n    \"\"\"\n    # Create an annotator object\n    annotator = Annotator(np.array(image))\n\n    # sort predict by xmin value\n    predict = predict.sort_values(by=['xmin'], ascending=True)\n\n    # iterate over the rows of predict dataframe\n    for i, row in predict.iterrows():\n        # create the text to be displayed on image\n        text = f\"{row['name']}: {int(row['confidence']*100)}%\"\n        # get the bounding box coordinates\n        bbox = [row['xmin'], row['ymin'], row['xmax'], row['ymax']]\n        # add the bounding box and text on the image\n        annotator.box_label(bbox, text, color=colors(row['class'], True))\n    # convert the annotated image to PIL image\n    return Image.fromarray(annotator.result())\n\n\n################################# Models #####################################\n\n\ndef detect_sample_model(input_image: Image) -> pd.DataFrame:\n    \"\"\"\n    Predict from sample_model.\n    Base on YoloV8\n\n    Args:\n        input_image (Image): The input image.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the object location.\n    \"\"\"\n    predict = get_model_predict(\n        model=model_sample_model,\n        input_image=input_image,\n        save=False,\n        image_size=640,\n        augment=False,\n        conf=0.5,\n    )\n    return predict"}
{"type": "source_file", "path": "__init__.py", "content": ""}

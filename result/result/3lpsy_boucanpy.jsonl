{"repo_info": {"repo_name": "boucanpy", "repo_owner": "3lpsy", "repo_url": "https://github.com/3lpsy/boucanpy"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/integration/status/test_status.py", "content": "from tests.integration.client import client\n\n\ndef test_status():\n    response = client.get(\"/api/v1/status\")\n    assert response.status_code == 200\n"}
{"type": "test_file", "path": "tests/integration/client.py", "content": "# from boucanpy.core import load_env\n\n# load_env(\"api.test\")\n\nfrom boucanpy.api.api import api\nfrom starlette.testclient import TestClient\n\nclient = TestClient(api)\n"}
{"type": "test_file", "path": "tests/integration/user/test_user_create.py", "content": "from boucanpy.db.factories import factory\nfrom boucanpy.core.security import create_bearer_token\nfrom boucanpy.core import SUPER_SCOPES, NORMAL_SCOPES\nimport sys\n\n\ndef test_superuser_can_create_user(client, session):\n    auth = factory(\"SuperUserFactory\", session=session).create()\n\n    token = create_bearer_token(data={\"sub\": auth.id, \"scopes\": SUPER_SCOPES})\n    bearer = \"Bearer \" + str(token)\n    data = {\n        \"email\": \"test@test.com\",\n        \"password\": \"Password123\",\n        \"password_confirm\": \"Password123\",\n    }\n    response = client.post(\n        \"/api/v1/user\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\", \"Authorization\": bearer},\n    )\n    assert response.status_code == 200\n    assert response.json()[\"user\"][\"email\"] == data[\"email\"]\n\n\ndef test_mismatching_passwords_causes_failure(client, session):\n    auth = factory(\"SuperUserFactory\", session=session).create()\n\n    token = create_bearer_token(data={\"sub\": auth.id, \"scopes\": SUPER_SCOPES})\n    bearer = \"Bearer \" + str(token)\n    data = {\n        \"email\": \"test@test.com\",\n        \"password\": \"Password\",\n        \"password_confirm\": \"Password123\",\n    }\n    response = client.post(\n        \"/api/v1/user\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\", \"Authorization\": bearer},\n    )\n    assert response.status_code == 422\n\n\ndef test_short_password_causes_failure(client, session):\n    auth = factory(\"SuperUserFactory\", session=session).create()\n\n    token = create_bearer_token(data={\"sub\": auth.id, \"scopes\": SUPER_SCOPES})\n    bearer = \"Bearer \" + str(token)\n    data = {\"email\": \"a@a.com\", \"password\": \"pass2\", \"password_confirm\": \"pass2\"}\n    response = client.post(\n        \"/api/v1/user\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\", \"Authorization\": bearer},\n    )\n    assert response.status_code == 422\n\n\ndef test_common_or_bad_password_causes_failure(client, session):\n    # TODO\n    pass\n\n\ndef test_short_email_causes_failure(client, session):\n    auth = factory(\"SuperUserFactory\", session=session).create()\n\n    token = create_bearer_token(data={\"sub\": auth.id, \"scopes\": SUPER_SCOPES})\n    bearer = \"Bearer \" + str(token)\n    data = {\n        \"email\": \"a@a.com\",\n        \"password\": \"Password123\",\n        \"password_confirm\": \"Password123\",\n    }\n    response = client.post(\n        \"/api/v1/user\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\", \"Authorization\": bearer},\n    )\n    assert response.status_code == 422\n\n\ndef test_username_is_not_valid_email_format_causes_failure(client, session):\n    auth = factory(\"SuperUserFactory\", session=session).create()\n\n    token = create_bearer_token(data={\"sub\": auth.id, \"scopes\": SUPER_SCOPES})\n    bearer = \"Bearer \" + str(token)\n    data = {\n        \"email\": \"testtest\",\n        \"password\": \"Password123\",\n        \"password_confirm\": \"Password123\",\n    }\n    response = client.post(\n        \"/api/v1/user\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\", \"Authorization\": bearer},\n    )\n    assert response.status_code == 422\n\n\ndef test_regular_user_cannot_create_user(client, session):\n    auth = factory(\"UserFactory\", session=session).create()\n\n    token = create_bearer_token(data={\"sub\": auth.id, \"scopes\": NORMAL_SCOPES})\n    bearer = \"Bearer \" + str(token)\n    data = {\n        \"email\": \"test@test.com\",\n        \"password\": \"Password123\",\n        \"password_confirm\": \"Password123\",\n    }\n    response = client.post(\n        \"/api/v1/user\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\", \"Authorization\": bearer},\n    )\n    assert response.status_code == 403\n\n\ndef test_unauthed_user_cannot_create_user(client, session):\n    bearer = \"Bearer \"\n    data = {\n        \"email\": \"test@test.com\",\n        \"password\": \"Password123\",\n        \"password_confirm\": \"Password123\",\n    }\n    response = client.post(\n        \"/api/v1/user\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\", \"Authorization\": bearer},\n    )\n    assert response.status_code == 403\n"}
{"type": "test_file", "path": "tests/integration/user/test_user_update.py", "content": "from boucanpy.db.factories import factory\nfrom boucanpy.db.models import model\n\nfrom boucanpy.core.security import create_bearer_token\nfrom boucanpy.core import SUPER_SCOPES, NORMAL_SCOPES\nimport sys\n\n\ndef test_superuser_can_update_user(client, session):\n    auth = factory(\"SuperUserFactory\", session=session).create()\n    target = factory(\"UserFactory\", session=session).create(email=\"target@test.com\")\n\n    token = create_bearer_token(data={\"sub\": auth.id, \"scopes\": SUPER_SCOPES})\n    bearer = \"Bearer \" + str(token)\n\n    data = {\"email\": \"test222@test.com\"}\n\n    response = client.put(\n        f\"/api/v1/user/{str(target.id)}\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\", \"Authorization\": bearer},\n    )\n    assert response.status_code == 200\n    assert response.json()[\"user\"][\"email\"] == data[\"email\"]\n\n\ndef test_email_must_not_already_exist_or_failure(client, session):\n    auth = factory(\"SuperUserFactory\", session=session).create()\n    existing = factory(\"UserFactory\", session=session).create(email=\"existing@test.com\")\n    target = factory(\"UserFactory\", session=session).create(email=\"target2@test.com\")\n\n    token = create_bearer_token(data={\"sub\": auth.id, \"scopes\": SUPER_SCOPES})\n    bearer = \"Bearer \" + str(token)\n\n    data = {\"email\": existing.email}\n\n    response = client.put(\n        f\"/api/v1/user/{str(target.id)}\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\", \"Authorization\": bearer},\n    )\n    assert response.status_code == 422\n"}
{"type": "source_file", "path": "boucanpy/api/config.py", "content": "import os\nfrom base64 import b64encode\nfrom boucanpy.core.utils import getenv_bool, getenv\nfrom boucanpy.db.session import db_url\n\nAPI_V1_STR = \"/api/v1\"\n\n\nAPI_SECRET_KEY = getenv(\"API_SECRET_KEY\")\nJWT_ALGORITHM = \"HS256\"\n\nif not API_SECRET_KEY:\n    API_SECRET_KEY = b64encode(os.urandom(32)).decode(\"utf-8\")\n\nACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24 * 8  # 60 minutes * 24 hours * 8 days = 8 days\n\nAPI_CORS_ORIGINS = getenv(\n    \"API_CORS_ORIGINS\"\n)  # a string of origins separated by commas, e.g: \"http://localhost, http://localhost:4200, http://localhost:3000, http://localhost:8080, http://local.dockertoolbox.tiangolo.com\"\nAPI_PROJECT_NAME = getenv(\"API_PROJECT_NAME\", \"Bounty DNS\")\nSQLALCHEMY_DATABASE_URI = db_url()\n\nAPI_SUPERUSER_EMAIL = getenv(\"API_SUPERUSER_EMAIL\", optional=True)\nAPI_SUPERUSER_PASSWORD = getenv(\"API_SUPERUSER_PASSWORD\", optional=True)\nAPI_SUPERUSER_MFA_SECRET = getenv(\"API_SUPERUSER_MFA_SECRET\", optional=True)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/api_token/router.py", "content": "from datetime import datetime\nfrom typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom boucanpy.core import logger, only, abort\nfrom boucanpy.core.security import (\n    ScopedTo,\n    TokenPayload,\n    create_bearer_token,\n    current_user,\n)\nfrom boucanpy.db.models.user import User\nfrom boucanpy.db.models.dns_server import DnsServer\nfrom boucanpy.db.models.http_server import HttpServer\n\nfrom boucanpy.core.api_token import (\n    ApiTokensResponse,\n    ApiTokenResponse,\n    ApiTokenRepo,\n    ApiTokenCreateForm,\n    ApiTokenData,\n    SensitiveApiTokenResponse,\n    SensitiveApiTokenData,\n)\nfrom boucanpy.core.dns_server import DnsServerRepo\nfrom boucanpy.core.http_server import HttpServerRepo\n\nfrom boucanpy.core import SortQS, PaginationQS, BaseResponse\n\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n# race condition between nodes\n# TODO: fix this\n@router.post(\"/api-token/sync\", name=\"api_token.sync\", response_model=ApiTokenResponse)\nasync def sync(\n    api_token_repo: ApiTokenRepo = Depends(ApiTokenRepo()),\n    dns_server_repo: DnsServerRepo = Depends(DnsServerRepo()),\n    http_server_repo: HttpServerRepo = Depends(HttpServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"api-token:syncable\")),\n):\n    if \"api-token\" in token.scopes or \"api-token:syncable\" in token.scopes:\n        abort_for_no_server_names(token)\n        if (\n            len(token.payload.dns_server_name) > 0\n            and len(token.payload.http_server_name) > 0\n        ):\n            dns_server = create_or_get_dns_server(token, dns_server_repo)\n            http_server = create_or_get_http_server(token, http_server_repo)\n            api_token_data = create_or_get_api_token_for_all_nodes(\n                token, api_token_repo, dns_server, http_server\n            )\n        elif len(token.payload.dns_server_name) > 0:\n            dns_server = create_or_get_dns_server(token, dns_server_repo)\n            api_token_data = create_or_get_api_token_for_dns_server(\n                token, api_token_repo, dns_server\n            )\n\n        elif len(token.payload.http_server_name) > 0:\n            http_server = create_or_get_http_server(token, http_server_repo)\n            api_token_data = create_or_get_api_token_for_http_server(\n                token, api_token_repo, http_server\n            )\n        else:\n            # something went wrong, should not hit\n            raise HTTPException(403, detail=\"Not found\")\n\n        return ApiTokenResponse(api_token=api_token_data)\n\n    else:\n        raise HTTPException(403, detail=\"Not found\")\n\n\n@router.get(\"/api-token\", name=\"api_token.index\", response_model=ApiTokensResponse)\nasync def index(\n    sort_qs: SortQS = Depends(SortQS),\n    pagination: PaginationQS = Depends(PaginationQS),\n    api_token_repo: ApiTokenRepo = Depends(ApiTokenRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"api-token:list\")),\n    includes: List[str] = Query(None),\n):\n    includes = only(includes, [\"dns_server\", \"http_server\"], values=True)\n\n    pg, items = (\n        api_token_repo.loads(includes)\n        .strict()\n        .sort(sort_qs)\n        .paginate(pagination)\n        .includes(includes)\n        .data()\n    )\n    return ApiTokensResponse(pagination=pg, api_tokens=items)\n\n\n@router.post(\"/api-token\", name=\"api_token.store\", response_model=ApiTokenResponse)\nasync def store(\n    form: ApiTokenCreateForm,\n    api_token_repo: ApiTokenRepo = Depends(ApiTokenRepo()),\n    dns_server_repo: DnsServerRepo = Depends(DnsServerRepo()),\n    http_server_repo: HttpServerRepo = Depends(HttpServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"api-token:create\")),\n    user: User = Depends(current_user),\n):\n    if form.dns_server_id and form.dns_server_id > 0:\n        dns_server_name = (\n            dns_server_repo.first_or_fail(id=form.dns_server_id).results().name\n        )\n    if form.http_server_id and form.http_server_id > 0:\n        http_server_name = (\n            http_server_repo.first_or_fail(id=form.http_server_id).results().name\n        )\n    scopes = []\n    for requested_scope in form.scopes.split(\" \"):\n        request_scope_satisfied = False\n        for user_token in token.scopes:\n            # TODO: double check this, pretty lenient\n            # if a:b in a:b:c\n            if user_token in requested_scope:\n                request_scope_satisfied = True\n        if not request_scope_satisfied:\n            logger.warning(\n                f\"store@router.py: Attempt to create unauthorized scope {requested_scope}\"\n            )\n            raise HTTPException(403, detail=\"unauthorized\")\n        else:\n            scopes.append(requested_scope)\n\n    # TODO: use better randomness\n\n    token = create_bearer_token(\n        data={\n            \"sub\": user.id,\n            \"scopes\": \" \".join(scopes),\n            \"dns_server_name\": dns_server_name,\n            \"http_server_name\": http_server_name,\n        }\n    )\n\n    data = {\n        \"scopes\": \" \".join(scopes),\n        \"token\": str(token),\n        \"expires_at\": form.expires_at,\n        \"dns_server_id\": form.dns_server_id,\n        \"http_server_id\": form.http_server_id,\n    }\n\n    api_token = api_token_repo.create(data).data()\n    return ApiTokenResponse(api_token=api_token)\n\n\n@router.get(\n    \"/api-token/{api_token_id}\", name=\"api_token.show\", response_model=ApiTokenResponse\n)\nasync def show(\n    api_token_id: int,\n    api_token_repo: ApiTokenRepo = Depends(ApiTokenRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"api-token:read\")),\n    includes: List[str] = Query(None),\n):\n\n    includes = only(includes, [\"dns_server\", \"http_server\"], values=True)\n\n    if (\n        not api_token_repo.loads(includes)\n        .strict()\n        .includes(includes)\n        .exists(api_token_id)\n    ):\n        raise HTTPException(404, detail=\"Not found\")\n    api_token = api_token_repo.data()\n    return ApiTokenResponse(api_token=api_token)\n\n\n@router.get(\n    \"/api-token/{api_token_id}/sensitive\",\n    name=\"api_token.show.sensitive\",\n    response_model=SensitiveApiTokenResponse,\n)\nasync def sensitive(\n    api_token_id: int,\n    api_token_repo: ApiTokenRepo = Depends(ApiTokenRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"api-token:read\")),\n    includes: List[str] = Query(None),\n):\n\n    includes = only(includes, [\"dns_server\", \"http_server\"], values=True)\n\n    # TODO: require stronger scope\n    if not api_token_repo.exists(api_token_id):\n        raise HTTPException(404, detail=\"Not found\")\n    api_token = (\n        api_token_repo.loads(includes)\n        .set_data_model(SensitiveApiTokenData)\n        .includes(includes)\n        .data()\n    )\n    return SensitiveApiTokenResponse(api_token=api_token)\n\n\n@router.delete(\"/api-token/{api_token_id}\", response_model=BaseResponse)\nasync def destroy(\n    api_token_id: int,\n    api_token_repo: ApiTokenRepo = Depends(ApiTokenRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"api-token:destroy\")),\n):\n    messages = [{\"text\": \"Deactivation Succesful\", \"type\": \"success\"}]\n    if not api_token_repo.exists(api_token_id):\n        return BaseResponse(messages=messages)\n    api_token_repo.deactivate(api_token_id)\n    return BaseResponse(messages=messages)\n\n\ndef abort_for_no_server_names(token: TokenPayload):\n    if not len(token.payload.dns_server_name) or not len(\n        token.payload.http_server_name\n    ):\n        abort(\n            code=422, msg=\"No DNS Server Name or HTTP Server Name on payload\", debug=\"\",\n        )\n\n\ndef create_or_get_api_token_for_all_nodes(\n    token: TokenPayload,\n    api_token_repo: ApiTokenRepo,\n    dns_server: DnsServer,\n    http_server: HttpServer,\n) -> ApiTokenData:\n    scopes = token.scopes\n\n    if not api_token_repo.exists(token=token.token):\n        api_token_repo.clear()\n        logger.info(\"sync@router.py - Saving api token from auth token for all nodes\")\n        return api_token_repo.create(\n            dict(\n                token=token.token,\n                scopes=\" \".join(scopes),\n                dns_server_id=dns_server.id,\n                http_server_id=http_server.id,\n                expires_at=datetime.utcfromtimestamp(float(token.exp)),\n            )\n        ).data()\n    else:\n        logger.info(\"sync@router.py - token already exists in database\")\n        return api_token_repo.data()\n\n\ndef create_or_get_dns_server(\n    token: TokenPayload, dns_server_repo: DnsServerRepo\n) -> DnsServer:\n    if not dns_server_repo.exists(name=token.payload.dns_server_name.lower()):\n        dns_server_repo.clear()\n        logger.info(\"sync@router.py - Saving dns server from api token\")\n        return dns_server_repo.create(\n            dict(name=token.payload.dns_server_name.lower())\n        ).results()\n    else:\n        return dns_server_repo.results()\n\n\ndef create_or_get_api_token_for_dns_server(\n    token: TokenPayload, api_token_repo: ApiTokenRepo, dns_server: DnsServer\n) -> ApiTokenData:\n    scopes = token.scopes\n\n    if not api_token_repo.exists(token=token.token):\n        api_token_repo.clear()\n        logger.info(\"sync@router.py - Saving api token from auth token for dns node\")\n        return api_token_repo.create(\n            dict(\n                token=token.token,\n                scopes=\" \".join(scopes),\n                dns_server=dns_server,\n                expires_at=datetime.utcfromtimestamp(float(token.exp)),\n            )\n        ).data()\n    else:\n        logger.info(\"sync@router.py - token already exists in database\")\n        return api_token_repo.loads(\"dns_server\").includes(\"dns_server\").data()\n\n\ndef create_or_get_http_server(\n    token: TokenPayload, http_server_repo: HttpServerRepo\n) -> HttpServer:\n    if not http_server_repo.exists(name=token.payload.http_server_name.lower()):\n        http_server_repo.clear()\n        logger.info(\"sync@router.py - Saving http server from api token\")\n        return http_server_repo.create(\n            dict(name=token.payload.http_server_name.lower())\n        ).results()\n    else:\n        return http_server_repo.results()\n\n\ndef create_or_get_api_token_for_http_server(\n    token: TokenPayload, api_token_repo: ApiTokenRepo, http_server: HttpServer\n) -> ApiTokenData:\n    scopes = token.scopes\n\n    if not api_token_repo.exists(token=token.token):\n        api_token_repo.clear()\n        logger.info(\"sync@router.py - Saving api token from auth token for http node\")\n        return api_token_repo.create(\n            dict(\n                token=token.token,\n                scopes=\" \".join(scopes),\n                http_server=http_server,\n                expires_at=datetime.utcfromtimestamp(float(token.exp)),\n            )\n        ).data()\n    else:\n        logger.info(\"sync@router.py - token already exists in database\")\n        return api_token_repo.loads(\"http_server\").includes(\"http_server\").data()\n\n"}
{"type": "source_file", "path": "boucanpy/api/routers/dns_request/router.py", "content": "from sqlalchemy import literal\nfrom fastapi import APIRouter, Depends, Query\nfrom typing import List\n\nfrom boucanpy.core import logger, abort, only\nfrom boucanpy.core.security import ScopedTo, TokenPayload\nfrom boucanpy.core import SortQS, PaginationQS\nfrom boucanpy.core.dns_server import DnsServerRepo\nfrom boucanpy.core.zone import ZoneRepo\n\nfrom boucanpy.core.dns_request import (\n    DnsRequestRepo,\n    DnsRequestsResponse,\n    DnsRequestResponse,\n    DnsRequestData,\n    DnsRequestCreateForm,\n)\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n@router.get(\n    \"/dns-request\", name=\"dns_request.index\", response_model=DnsRequestsResponse\n)\nasync def index(\n    sort_qs: SortQS = Depends(SortQS),\n    pagination: PaginationQS = Depends(PaginationQS),\n    dns_request_repo: DnsRequestRepo = Depends(DnsRequestRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-request:list\")),\n):\n    pg, items = (\n        dns_request_repo.loads(\"dns_server\")\n        .sort(sort_qs)\n        .paginate(pagination)\n        .includes(\"dns_server\")\n        .data()\n    )\n    return DnsRequestsResponse(pagination=pg, dns_requests=items)\n\n\n@router.post(\n    \"/dns-request\", name=\"dns_request.store\", response_model=DnsRequestResponse\n)\nasync def store(\n    form: DnsRequestCreateForm,\n    dns_request_repo: DnsRequestRepo = Depends(DnsRequestRepo()),\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    dns_server_repo: DnsServerRepo = Depends(DnsServerRepo()),\n    token: str = Depends(ScopedTo(\"dns-request:create\")),\n):\n\n    dns_server_id = (\n        dns_server_repo.first_or_fail(name=form.dns_server_name.lower()).results().id\n    )\n\n    zone = (\n        zone_repo.filter(literal(form.name.lower()).contains(zone_repo.label(\"domain\")))\n        .first()\n        .results()\n    )\n\n    zone_id = zone.id if zone else None\n\n    data = only(\n        dict(form),\n        [\"name\", \"source_address\", \"source_port\", \"type\", \"protocol\", \"raw_request\"],\n    )\n\n    data[\"name\"] = data[\"name\"].lower()\n    data[\"type\"] = data[\"type\"].upper()\n\n    data[\"dns_server_id\"] = dns_server_id\n    data[\"zone_id\"] = zone_id\n    logger.info(\"store@router.py - Creating DNS Request\")\n    dns_request = dns_request_repo.create(data).data()\n\n    return DnsRequestResponse(dns_request=dns_request)\n\n\n@router.get(\n    \"/dns-request/{dns_request_id}\",\n    name=\"dns_request.show\",\n    response_model=DnsRequestResponse,\n)\nasync def show(\n    dns_request_id: int,\n    dns_request_repo: DnsRequestRepo = Depends(DnsRequestRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-request:show\")),\n    includes: List[str] = Query(None),\n):\n    # probably a bunch of access bypasses with scopes via includes\n    # need easy way to scope for includes\n    includes = only(includes, [\"dns_server\", \"zone\"], values=True)\n\n    dns_request = (\n        dns_request_repo.loads(includes)\n        .get_or_fail(dns_request_id)\n        .includes(includes)\n        .data()\n    )\n    return DnsRequestResponse(dns_request=dns_request)\n"}
{"type": "source_file", "path": "boucanpy/api/main.py", "content": "from boucanpy.api.api import api\n"}
{"type": "source_file", "path": "boucanpy/api/routers/__init__.py", "content": "from os import walk\nfrom pathlib import Path\nfrom os.path import join\nfrom importlib import import_module\nfrom boucanpy.core.utils import api_dir, snake_to_title\n\nrouters = []\n\n\ndef extact_routers(parent_dir, parent_mod):\n    _routers = []\n    for directory_name, sub_directories, files in walk(parent_dir):\n        for sub_dir_name in sorted(sub_directories):\n            if not sub_dir_name.startswith((\"__\", \"base\")):\n                if Path(join(join(parent_dir, sub_dir_name), \"router.py\")).is_file():\n                    sub_dir = join(parent_dir, sub_dir_name)\n                    module_path = f\"{parent_mod}.{sub_dir_name}.router\"\n                    module = import_module(module_path, \"router\")\n                    _router = getattr(module, \"router\", None)\n                    if _router:\n                        _options = getattr(module, \"options\", {})\n                        router = (_router, _options)\n                        _routers.append(router)\n                    else:\n                        print(f\"failed to find router in {module_path}\")\n            _routers = _routers + extact_routers(\n                join(parent_dir, sub_dir_name), f\"{parent_mod}.{sub_dir_name}\"\n            )\n    return _routers\n\n\nfor r in extact_routers(api_dir(\"routers\"), \"boucanpy.api.routers\"):\n    routers.append(r)\n"}
{"type": "source_file", "path": "boucanpy/api/api.py", "content": "from pathlib import Path\nfrom os.path import join\nfrom os import environ\nfrom urllib.parse import urlparse\nfrom boucanpy.core.utils import root_dir\nfrom fastapi import FastAPI, APIRouter\n\nfrom starlette.middleware.cors import CORSMiddleware\nfrom starlette.requests import Request\nfrom starlette.routing import Router, Mount\nfrom starlette.staticfiles import StaticFiles\nfrom starlette.responses import RedirectResponse, FileResponse, JSONResponse\nfrom starlette.exceptions import HTTPException\n\nfrom boucanpy.core.utils import webui_dir, landing_dir\nfrom boucanpy.core import logger\nfrom boucanpy.api.routers import routers\nfrom boucanpy.api.websocket import broadcast_index, broadcast_auth\nfrom boucanpy.db.session import session, db_register\nfrom boucanpy.db.utils import make_db_url\n\ndb_register(make_db_url())\n\nfrom boucanpy.api import (\n    config,\n)  # environment must be loaded, dabatabse must be registerd\n\n# CORS\napi = FastAPI(title=config.API_PROJECT_NAME, openapi_url=\"/api/v1/openapi.json\")\n\norigins = []\n\n# Set all CORS enabled origins\nif config.API_CORS_ORIGINS:\n    origins_raw = config.API_CORS_ORIGINS.split(\",\")\n\n    for origin in origins_raw:\n        use_origin = origin.strip()\n        origins.append(use_origin)\n\n    logger.info(f\"global@api.py - Registering cors origins {origins}\")\n\n    api.add_middleware(\n        CORSMiddleware,\n        allow_origins=origins,\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    ),\n\nmain_router = APIRouter()\n\nfor r, ropts in routers:\n    logger.debug(f\"global@api.py - Registering router {str(r)} {str(ropts)}\")\n    main_router.include_router(r, **ropts)\n\nlogger.debug(f\"global@api.py - Registering main router {str(r)} {str(ropts)}\")\n\napi.include_router(main_router, prefix=config.API_V1_STR)\n\nfrom starlette.websockets import WebSocket\n\n# public broadcast\n\nif int(environ.get(\"BROADCAST_ENABLED\", 0)) == 1:\n    logger.info(\"global@api.py - Registering broadcast routers\")\n    api.add_websocket_route(\"/broadcast\", broadcast_index, name=\"broadcast.index\")\n    api.add_websocket_route(\n        \"/broadcast/auth\", broadcast_auth, name=\"broadcast.auth.index\"\n    )\n\n\n@api.get(\"/\")\nasync def webui_redir():\n    return RedirectResponse(url=\"/landing/\", status_code=302)\n\n\n# served by nginx\nif Path(landing_dir(\"index.html\")).is_file():\n    logger.info(\"global@api.py - Registering landing routers\")\n\n    @api.get(\"/landing/\")\n    async def web_index():\n        return FileResponse(landing_dir(\"index.html\"))\n\n    api.mount(\"/landing\", StaticFiles(directory=landing_dir()))\n\n# served by nginx\nif Path(webui_dir(\"dist\")).is_dir():\n    logger.info(\"global@api.py - Registering webui routers\")\n\n    # served by nginx\n    @api.get(\"/webui\")\n    async def webui_redir():\n        return RedirectResponse(url=\"/webui/\", status_code=302)\n\n    # served by nginx w/ slight rewrite\n    @api.get(\"/webui/assets\")\n    async def webui_index():\n        return FileResponse(webui_dir(join(\"dist\", \"index.html\")))\n\n    api.mount(\"/webui/assets\", StaticFiles(directory=webui_dir(\"dist\")))\n\n\nlogger.debug(\"global@api.py - Registering 404 handler\")\n\n# TODO: make core handler\n@api.exception_handler(404)\nasync def http_exception(request, exc):\n    url = urlparse(str(request.url))\n    if not url.path.startswith(\"/api/v1\"):\n        if (\n            Path(webui_dir(\"dist\")).is_dir()\n            and Path(webui_dir(join(\"dist\", \"index.html\"))).is_file()\n        ):\n            return FileResponse(webui_dir(join(\"dist\", \"index.html\")))\n    return JSONResponse({\"detail\": \"Not Found\"}, status_code=404)\n\n\nlogger.debug(\"global@api.py - Registering 500 handler\")\n\n\n@api.exception_handler(500)\nasync def http_exception(request, exc):\n    return JSONResponse({\"detail\": \"Server Error\"}, status_code=500)\n\n\nlogger.debug(\"global@api.py - Api import complete\")\n\n\n# async def db_session_middleware(request: Request, call_next):\n#     request.state.db = session()\n#     response = await call_next(request)\n#     request.state.db.close()\n#     return response\n"}
{"type": "source_file", "path": "boucanpy/api/routers/auth/router.py", "content": "from fastapi import APIRouter, Depends\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom starlette.responses import RedirectResponse\nfrom starlette.requests import Request\n\nrouter = APIRouter()\noptions = {\"prefix\": \"/auth\"}\n\n\n@router.post(\"/login\", name=\"auth.login\")\nasync def login(request: Request, form: OAuth2PasswordRequestForm = Depends()):\n    return RedirectResponse(url=request.url_for(\"auth.token\"), status_code=307)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/dns_server/router.py", "content": "from typing import List\nfrom fastapi import APIRouter, Depends, Query\nfrom boucanpy.core import logger, only, abort, abort_for_input\nfrom boucanpy.core.security import ScopedTo, TokenPayload\nfrom boucanpy.core import PaginationQS, SortQS\nfrom boucanpy.core.dns_server import (\n    DnsServerRepo,\n    DnsServersResponse,\n    DnsServerResponse,\n    DnsServerCreateForm,\n)\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n@router.get(\"/dns-server\", name=\"dns_server.index\", response_model=DnsServersResponse)\nasync def index(\n    sort_qs: SortQS = Depends(SortQS),\n    pagination: PaginationQS = Depends(PaginationQS),\n    dns_server_repo: DnsServerRepo = Depends(DnsServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-server:list\")),\n    search: str = Query(None),\n    includes: List[str] = Query(None),\n):\n    includes = only(includes, [\"zones\"], values=True)\n\n    pg, items = (\n        dns_server_repo.loads(includes)\n        .includes(includes)\n        .search(search, searchable=[\"name\", \"id\"])\n        .paginate(pagination)\n        .data()\n    )\n    return DnsServersResponse(pagination=pg, dns_servers=items)\n\n\n@router.post(\"/dns-server\", name=\"dns_server.store\", response_model=DnsServerResponse)\nasync def store(\n    form: DnsServerCreateForm,\n    dns_server_repo: DnsServerRepo = Depends(DnsServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-server:create\")),\n):\n    if dns_server_repo.exists(name=form.name.lower()):\n        abort_for_input(\"name\", \"Server name already taken\")\n\n    data = only(dict(form), [\"name\"])\n\n    data[\"name\"] = data[\"name\"].lower()\n\n    item = dns_server_repo.create(data).data()\n    return DnsServerResponse(dns_server=item)\n\n\n@router.get(\n    \"/dns-server/{dns_server}\", name=\"dns_server.show\", response_model=DnsServerResponse\n)\nasync def show(\n    dns_server: str,\n    dns_server_repo: DnsServerRepo = Depends(DnsServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-server:show\")),\n    includes: List[str] = Query(None),\n):\n    includes = only(includes, [\"zones\"], values=True)\n\n    dns_server_id_label = dns_server_repo.label(\"id\")\n\n    try:\n        dns_server = int(dns_server)\n        label = dns_server_id_label\n    except ValueError:\n        label = dns_server_repo.label(\"name\")\n\n    # TODO: is this vulnerable to sql injection?\n    item = (\n        dns_server_repo.loads(includes)\n        .filter(label == dns_server)\n        .first_or_fail()\n        .includes(includes)\n        .data()\n    )\n\n    return DnsServerResponse(dns_server=item)\n\n\n# TODO: make specifi update form for dns server\n@router.put(\n    \"/dns-server/{dns_server}\",\n    name=\"dns_server.update\",\n    response_model=DnsServerResponse,\n)\nasync def update(\n    dns_server: str,\n    form: DnsServerCreateForm,\n    dns_server_repo: DnsServerRepo = Depends(DnsServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-server:update\")),\n):\n\n    data = only(dict(form), [\"name\"])\n    data[\"name\"] = data[\"name\"].lower()\n\n    dns_server_id_label = dns_server_repo.label(\"id\")\n\n    try:\n        dns_server = int(dns_server)\n        label = dns_server_id_label\n    except ValueError:\n        label = dns_server_repo.label(\"name\")\n\n    # TODO: is this vulnerable to sql injection?\n    item = (\n        dns_server_repo.filter(label == dns_server).first_or_fail().update(data).data()\n    )\n\n    return DnsServerResponse(dns_server=item)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/http_request/router.py", "content": "from sqlalchemy import literal\nfrom fastapi import APIRouter, Depends, Query\nfrom typing import List\n\nfrom boucanpy.core import logger, abort, only\nfrom boucanpy.core.security import ScopedTo, TokenPayload\nfrom boucanpy.core import SortQS, PaginationQS\nfrom boucanpy.core.http_server import HttpServerRepo\nfrom boucanpy.core.zone import ZoneRepo\n\nfrom boucanpy.core.http_request import (\n    HttpRequestRepo,\n    HttpRequestsResponse,\n    HttpRequestResponse,\n    HttpRequestData,\n    HttpRequestCreateForm,\n)\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n@router.get(\n    \"/http-request\", name=\"http_request.index\", response_model=HttpRequestsResponse\n)\nasync def index(\n    sort_qs: SortQS = Depends(SortQS),\n    pagination: PaginationQS = Depends(PaginationQS),\n    http_request_repo: HttpRequestRepo = Depends(HttpRequestRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"http-request:list\")),\n):\n    pg, items = (\n        http_request_repo.loads(\"http_server\")\n        .sort(sort_qs)\n        .includes(\"http_server\")\n        .paginate(pagination)\n        .data()\n    )\n    return HttpRequestsResponse(pagination=pg, http_requests=items)\n\n\n@router.post(\n    \"/http-request\", name=\"http_request.store\", response_model=HttpRequestResponse\n)\nasync def store(\n    form: HttpRequestCreateForm,\n    http_request_repo: HttpRequestRepo = Depends(HttpRequestRepo()),\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    http_server_repo: HttpServerRepo = Depends(HttpServerRepo()),\n    token: str = Depends(ScopedTo(\"http-request:create\")),\n):\n\n    http_server_id = (\n        http_server_repo.first_or_fail(name=form.http_server_name.lower()).results().id\n    )\n\n    zone = (\n        zone_repo.filter(literal(form.name.lower()).contains(zone_repo.label(\"domain\")))\n        .first()\n        .results()\n    )\n\n    zone_id = zone.id if zone else None\n\n    data = only(\n        dict(form),\n        [\n            \"name\",\n            \"path\",\n            \"source_address\",\n            \"source_port\",\n            \"type\",\n            \"protocol\",\n            \"raw_request\",\n        ],\n    )\n\n    data[\"name\"] = data[\"name\"].lower()\n    data[\"type\"] = data[\"type\"].upper()\n\n    data[\"http_server_id\"] = http_server_id\n    data[\"zone_id\"] = zone_id\n    logger.info(\"store@router.py - Creating HTTP Request\")\n    http_request = http_request_repo.create(data).data()\n\n    return HttpRequestResponse(http_request=http_request)\n\n\n@router.get(\n    \"/http-request/{http_request_id}\",\n    name=\"http_request.show\",\n    response_model=HttpRequestResponse,\n)\nasync def show(\n    http_request_id: int,\n    http_request_repo: HttpRequestRepo = Depends(HttpRequestRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"http-request:show\")),\n    includes: List[str] = Query(None),\n):\n    # probably a bunch of access bypasses with scopes via includes\n    # need easy way to scope for includes\n    includes = only(includes, [\"http_server\", \"zone\"], values=True)\n\n    http_request = (\n        http_request_repo.loads(includes)\n        .get_or_fail(http_request_id)\n        .includes(includes)\n        .data()\n    )\n    return HttpRequestResponse(http_request=http_request)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/auth/token/router.py", "content": "from os import environ\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom boucanpy.core import logger\nfrom boucanpy.core.auth import PasswordAuthResponse\nfrom boucanpy.core.security import verify_password, create_bearer_token\nfrom boucanpy.db.models.user import User\nfrom boucanpy.db.session import async_session\nfrom boucanpy.core.enums import SUPER_SCOPES, NORMAL_SCOPES, PUBLISH_SCOPES\n\nrouter = APIRouter()\noptions = {\"prefix\": \"/auth\"}\n\n\n@router.post(\"/token\", name=\"auth.token\", response_model=PasswordAuthResponse)\nasync def login(\n    ws_access_token: bool = False,\n    db: Session = Depends(async_session),\n    form: OAuth2PasswordRequestForm = Depends(),\n):\n    username = form.username.lower() if form.username else \"\"\n\n    user = db.query(User).filter_by(email=username).first()\n\n    if not user or not user.hashed_password:\n        logger.warning(f\"user exists failed for {username}\")\n        raise HTTPException(status_code=401, detail=\"Incorrect email or password\")\n\n    if not verify_password(form.password, user.hashed_password):\n        logger.warning(f\"hash verification failed for {username}\")\n        raise HTTPException(status_code=401, detail=\"Incorrect email or password\")\n\n    if user.mfa_secret:  # mfa is enabled\n        scopes = \"profile mfa_required\"\n    elif user.is_superuser:\n        scopes = SUPER_SCOPES  # grant access to super routes\n    else:\n        scopes = NORMAL_SCOPES\n\n    logger.warning(f\"creating token with scopes {scopes}\")\n\n    token = create_bearer_token(data={\"sub\": user.id, \"scopes\": scopes})\n    data = {\"token_type\": \"bearer\", \"access_token\": str(token)}\n\n    if ws_access_token and int(environ.get(\"BROADCAST_ENABLED\", 0)) == 1:\n        # TODO: make it so that you cannot get publish access without base scope\n        data[\"ws_access_token\"] = create_bearer_token(\n            data={\"sub\": user.id, \"scopes\": PUBLISH_SCOPES}\n        )\n    return PasswordAuthResponse(**data)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/auth/token/__init__.py", "content": ""}
{"type": "source_file", "path": "boucanpy/api/routers/util/router.py", "content": "from fastapi import APIRouter\nimport aioredis\nfrom boucanpy.broadcast import make_redis, make_broadcast_url\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n@router.get(\"/util/ws-test\", name=\"util.ws-test\")\nasync def ws_test():\n    publisher = await aioredis.create_redis(make_broadcast_url())\n    res = await publisher.publish_json(\n        \"channel:auth\", {\"type\": \"MESSAGE\", \"name\": \"TESTING_WS\", \"payload\": \"\"}\n    )\n    return {\"status\": \"success\"}\n"}
{"type": "source_file", "path": "boucanpy/api/routers/auth/__init__.py", "content": ""}
{"type": "source_file", "path": "boucanpy/api/routers/http_server/zone/router.py", "content": "from typing import List\nfrom fastapi import APIRouter, Depends, Query\nfrom boucanpy.core import only\nfrom boucanpy.core.security import ScopedTo, TokenPayload\nfrom boucanpy.db.models.zone import Zone\nfrom boucanpy.core import SortQS, PaginationQS, BaseResponse\nfrom boucanpy.core.zone import (\n    ZoneRepo,\n    ZonesResponse,\n    ZoneResponse,\n    ZoneData,\n    ZoneCreateForm,\n)\n\nrouter = APIRouter()\noptions = {\"prefix\": \"/http-server/{http_server}\"}\n\n\n@router.get(\"/zone\", name=\"http_server.zone.index\", response_model=ZonesResponse)\nasync def index(\n    http_server: str,\n    sort_qs: SortQS = Depends(SortQS),\n    search: str = Query(None),\n    pagination: PaginationQS = Depends(PaginationQS),\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"zone:list\")),\n    includes: List[str] = Query(None),\n):\n\n    includes = only(includes, [\"http_records\"], values=True)\n\n    # Support ability to either submit http_server.name or http_server.id as http_server_id\n    zone_http_server_id_label = zone_repo.label(\"http_server_id\")\n\n    try:\n        http_server = int(http_server)\n        label = zone_http_server_id_label\n    except ValueError:\n        label = zone_repo.label(\"http_server.name\")\n\n    pg, items = (\n        zone_repo.search(search)\n        .loads(includes)\n        .filter_or(label == http_server, zone_http_server_id_label.is_(None))\n        .sort(sort_qs)\n        .paginate(pagination)\n        .includes(includes)\n        .data()\n    )\n    return ZonesResponse(pagination=pg, zones=items)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/auth/user/router.py", "content": "from fastapi import APIRouter, Depends\nfrom boucanpy.core.security import ScopedTo, current_user, TokenPayload\nfrom boucanpy.db.models.user import User\nfrom boucanpy.core import PaginationQS, logger\nfrom boucanpy.core.user import UserRepo, UserResponse, UserCreateForm\n\n\nrouter = APIRouter()\noptions = {\"prefix\": \"/auth\"}\n\n\n@router.get(\"/user\", name=\"auth.user.show\", response_model=UserResponse)\nasync def show(\n    user_repo: UserRepo = Depends(UserRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"profile\")),\n    user: User = Depends(current_user),\n):\n    logger.critical(\"Loading user\")\n    item = user_repo.set_results(user).data()\n    return UserResponse(user=item)\n"}
{"type": "source_file", "path": "bdnsctl.py", "content": "#!/usr/bin/env python\nimport asyncio\nimport uvloop\n\nasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n\nfrom sys import exit\n\n\nasync def call_command(command, args):\n    result = await command.make(args).call()\n    return result\n\n\nif __name__ == \"__main__\":\n    from boucanpy.cli import commands\n    from boucanpy.cli.parser import make_parser\n\n    loop = asyncio.get_event_loop()\n    # asyncio.set_event_loop(loop)\n    parser = make_parser()\n    args = parser.parse_args()\n    for command in commands:\n        if command.has_command(args.command):\n            result = loop.run_until_complete(call_command(command, args))\n            exit(result)\n    parser.print_help()\n    exit(1)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/dns_server/zone/router.py", "content": "from typing import List\nfrom fastapi import APIRouter, Depends, Query\nfrom boucanpy.core import only\nfrom boucanpy.core.security import ScopedTo, TokenPayload\nfrom boucanpy.db.models.zone import Zone\nfrom boucanpy.core import SortQS, PaginationQS, BaseResponse\nfrom boucanpy.core.zone import (\n    ZoneRepo,\n    ZonesResponse,\n    ZoneResponse,\n    ZoneData,\n    ZoneCreateForm,\n)\n\nrouter = APIRouter()\noptions = {\"prefix\": \"/dns-server/{dns_server}\"}\n\n\n@router.get(\"/zone\", name=\"dns_server.zone.index\", response_model=ZonesResponse)\nasync def index(\n    dns_server: str,\n    sort_qs: SortQS = Depends(SortQS),\n    search: str = Query(None),\n    pagination: PaginationQS = Depends(PaginationQS),\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"zone:list\")),\n    includes: List[str] = Query(None),\n):\n\n    includes = only(includes, [\"dns_records\"], values=True)\n\n    # Support ability to either submit dns_server.name or dns_server.id as dns_server_id\n    zone_dns_server_id_label = zone_repo.label(\"dns_server_id\")\n\n    try:\n        dns_server = int(dns_server)\n        label = zone_dns_server_id_label\n    except ValueError:\n        label = zone_repo.label(\"dns_server.name\")\n\n    pg, items = (\n        zone_repo.search(search)\n        .loads(includes)\n        .filter_or(label == dns_server, zone_dns_server_id_label.is_(None))\n        .sort(sort_qs)\n        .paginate(pagination)\n        .includes(includes)\n        .data()\n    )\n    return ZonesResponse(pagination=pg, zones=items)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/auth/user/__init__.py", "content": ""}
{"type": "source_file", "path": "boucanpy/api/routers/user/router.py", "content": "from typing import List\nfrom boucanpy.core import Depends\nfrom fastapi import APIRouter, Query\nfrom boucanpy.db.models.user import User\nfrom boucanpy.core.security import ScopedTo, hash_password, TokenPayload, current_user\nfrom boucanpy.core import (\n    PaginationQS,\n    SortQS,\n    BaseResponse,\n    abort,\n    only,\n    abort_for_input,\n    logger,\n)\nfrom boucanpy.core.user import (\n    UserRepo,\n    UsersResponse,\n    UserResponse,\n    UserData,\n    UserCreateForm,\n    UserEditForm,\n)\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n@router.get(\"/user\", name=\"user.index\", response_model=UsersResponse)\nasync def index(\n    sort_qs: SortQS = Depends(SortQS),\n    pagination: PaginationQS = Depends(PaginationQS),\n    user_repo: UserRepo = Depends(UserRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"user:list\")),\n):\n    pg, items = user_repo.sort(sort_qs).paginate(pagination).data()\n    return UsersResponse(pagination=pg, users=items)\n\n\n@router.post(\"/user\", name=\"user.store\", response_model=UserResponse)\nasync def store(\n    form: UserCreateForm,\n    user_repo: UserRepo = Depends(UserRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"user:create\", \"super\", satisfy=\"one\")),\n):\n\n    if user_repo.exists(email=form.email):\n        abort_for_input(\"email\", \"Email has already been taken.\")\n\n    user_repo.clear()\n\n    # TODO: data validation against current db & perm checks\n    data = {\n        \"email\": form.email,\n        \"hashed_password\": hash_password(form.password),\n        \"is_active\": getattr(form, \"is_superuser\", True),\n        \"is_superuser\": getattr(form, \"is_superuser\", False),\n    }\n    item = user_repo.create(data).data()\n    return UserResponse(user=item)\n\n\n@router.get(\"/user/{user_id}\", name=\"user.show\", response_model=UserResponse)\nasync def show(\n    user_id: int,\n    user_repo: UserRepo = Depends(UserRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"user:show\", \"super\")),\n    includes: List[str] = Query(None),\n):\n    includes = only(includes, [], values=True)\n\n    item = user_repo.loads(includes).get_or_fail(user_id).includes(includes).data()\n    return UserResponse(user=item)\n\n\n@router.put(\"/user/{user_id}\", name=\"user.update\", response_model=UserResponse)\nasync def update(\n    user_id: int,\n    form: UserEditForm,\n    user_repo: UserRepo = Depends(UserRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"user:update\", \"super\", satisfy=\"one\")),\n):\n\n    email = getattr(form, \"email\", None)\n    if email:\n        for u in user_repo.new().all().results():\n            print(\"USER:\", u.id, u.email, u)\n        existing = user_repo.new().first(email=email).results()\n        if existing and existing.id != user_id:\n            abort_for_input(msg=\"Invalid Email Address\", code=422, field=\"email\")\n\n    data = only(form, [\"email\", \"is_active\", \"is_superuser\"])\n\n    if getattr(form, \"password\", None):\n        data[\"hashed_password\"] = hash_password(form.password)\n\n    item = user_repo.new().get_or_fail(user_id).update(data).data()\n    return UserResponse(user=item)\n\n\n@router.put(\n    \"/user/{user_id}/activate\", name=\"user.activate\", response_model=UserResponse\n)\nasync def activate(\n    user_id: int,\n    user_repo: UserRepo = Depends(UserRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"user:create\", \"super\")),\n):\n\n    user = user_repo.get_or_fail(user_id).update({\"is_active\": True}).data()\n    return UserResponse(user=user)\n\n\n@router.delete(\"/user/{user_id}\", response_model=BaseResponse)\nasync def destroy(\n    user_id: int,\n    user_repo: UserRepo = Depends(UserRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"user:create\", \"super\", satisfy=\"one\")),\n    user: User = Depends(current_user),\n):\n    if user_id == user.id:\n        abort(403, msg=\"Cannot deactivate self\")\n\n    remaining_supers = len(\n        user_repo.filter(\n            user_repo.label(\"is_superuser\") == True,\n            user_repo.label(\"is_active\") == True,\n            user_repo.label(\"id\") != user_id,\n        )\n        .all()\n        .results()\n    )\n\n    if remaining_supers < 1:\n        abort(403, msg=\"Cannot deactivate user. No other active super users available.\")\n\n    user_repo.clear()\n\n    messages = [{\"text\": \"Deactivation Succesful\", \"type\": \"success\"}]\n    if not user_repo.exists(id=user_id):\n        return BaseResponse(messages=messages)\n\n    user_repo.deactivate(user_id)\n    return BaseResponse(messages=messages)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/zone/dns_record/router.py", "content": "from typing import List\nfrom textwrap import dedent\nfrom dnslib import RR, DNSRecord\nfrom dnslib.dns import DNSError\nfrom fastapi import APIRouter, Depends, Query\nfrom boucanpy.core import only\nfrom boucanpy.core.security import ScopedTo, TokenPayload\nfrom boucanpy.core import SortQS, PaginationQS\n\nfrom boucanpy.dns.parser import RecordParser\n\nfrom boucanpy.core.dns_record import (\n    DnsRecordsResponse,\n    DnsRecordResponse,\n    DnsRecordRepo,\n    DnsRecordForZoneCreateForm,\n    DnsRecordsDigResponse,\n)\nfrom boucanpy.core.zone import ZoneRepo\n\nrouter = APIRouter()\noptions = {\"prefix\": \"/zone/{zone_id}\"}\n\n\n@router.get(\n    \"/dns-record\", name=\"zone.dns_record.index\", response_model=DnsRecordsResponse\n)\nasync def index(\n    zone_id: int,\n    sort_qs: SortQS = Depends(SortQS),\n    pagination: PaginationQS = Depends(PaginationQS),\n    dns_record_repo: DnsRecordRepo = Depends(DnsRecordRepo()),\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-record:list\")),\n    includes: List[str] = Query(None),\n):\n    zone_repo.exists(id=zone_id, or_fail=True)\n\n    includes = only(includes, [\"zone\"], values=True)\n\n    pg, items = (\n        dns_record_repo.loads(\"zone\")\n        .sort(sort_qs)\n        .filter_by(zone_id=zone_id)\n        .paginate(pagination)\n        .includes(includes)\n        .data()\n    )\n    return DnsRecordsResponse(pagination=pg, dns_records=items)\n\n\n@router.get(\n    \"/dns-record/dig\",\n    name=\"zone.dns_record.dig.index\",\n    response_model=DnsRecordsDigResponse,\n)\nasync def dig(\n    zone_id: int,\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-record:list\")),\n):\n    zone = zone_repo.includes(\"dns_records\").first_or_fail(id=zone_id).results()\n    print(zone)\n    print(zone.dns_records)\n    # TODO: fix method\n    rrs = RecordParser.from_zone(zone).get_rrs()\n    dig = DNSRecord(rr=rrs).toZone()\n    return DnsRecordsDigResponse(dig=dig)\n\n\n@router.post(\n    \"/dns-record\", name=\"zone.dns_record.store\", response_model=DnsRecordsDigResponse\n)\nasync def store(\n    zone_id: int,\n    form: DnsRecordForZoneCreateForm,\n    dns_record_repo: DnsRecordRepo = Depends(DnsRecordRepo()),\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-record:create\")),\n):\n    zone_repo.exists(id=zone_id, or_fail=True)\n\n    data = only(dict(form), [\"record\", \"sort\"])\n    data[\"zone_id\"] = zone_id\n\n    item = dns_record_repo.create(data).data()\n    return DnsRecordResponse(dns_record=item)\n\n\n@router.get(\n    \"/dns-record/{dns_record_id}\",\n    name=\"zone.dns_record.show\",\n    response_model=DnsRecordResponse,\n)\nasync def show(\n    zone_id: int,\n    dns_record_id: int,\n    dns_record_repo: DnsRecordRepo = Depends(DnsRecordRepo()),\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-record:show\")),\n    includes: List[str] = Query(None),\n):\n    zone_repo.exists(id=zone_id, or_fail=True)\n\n    includes = only(includes, [\"zone\"], values=True)\n\n    item = (\n        dns_record_repo.loads(\"zone\")\n        .filter_by(zone_id=zone_id)\n        .first_or_fail(id=dns_record_id)\n        .includes(includes)\n        .data()\n    )\n\n    return DnsRecordResponse(dns_record=item)\n\n\n@router.put(\n    \"/dns-record/{dns_record_id}\",\n    name=\"zone.dns_record.update\",\n    response_model=DnsRecordResponse,\n)\nasync def update(\n    zone_id: int,\n    dns_record_id: int,\n    form: DnsRecordForZoneCreateForm,\n    dns_record_repo: DnsRecordRepo = Depends(DnsRecordRepo()),\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-record:create\")),\n):\n    # TODO: use abort_for_input instead of or_fail\n    zone_repo.exists(id=zone_id, or_fail=True)\n\n    data = only(form, [\"record\", \"sort\"])\n\n    item = dns_record_repo.first_or_fail(id=dns_record_id).update(data).data()\n\n    return DnsRecordResponse(dns_record=item)\n"}
{"type": "source_file", "path": "boucanpy/__init__.py", "content": ""}
{"type": "source_file", "path": "boucanpy/api/routers/http_server/router.py", "content": "from typing import List\nfrom fastapi import APIRouter, Depends, Query\nfrom boucanpy.core import logger, only, abort, abort_for_input\nfrom boucanpy.core.security import ScopedTo, TokenPayload\nfrom boucanpy.core import PaginationQS, SortQS\nfrom boucanpy.core.http_server import (\n    HttpServerRepo,\n    HttpServersResponse,\n    HttpServerResponse,\n    HttpServerCreateForm,\n)\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n@router.get(\n    \"/http-server\", name=\"http_server.index\", response_model=HttpServersResponse\n)\nasync def index(\n    sort_qs: SortQS = Depends(SortQS),\n    pagination: PaginationQS = Depends(PaginationQS),\n    http_server_repo: HttpServerRepo = Depends(HttpServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"http-server:list\")),\n    search: str = Query(None),\n    includes: List[str] = Query(None),\n):\n    includes = only(includes, [\"zones\"], values=True)\n\n    pg, items = (\n        http_server_repo.loads(includes)\n        .includes(includes)\n        .search(search, searchable=[\"name\", \"id\"])\n        .paginate(pagination)\n        .data()\n    )\n    return HttpServersResponse(pagination=pg, http_servers=items)\n\n\n@router.post(\n    \"/http-server\", name=\"http_server.store\", response_model=HttpServerResponse\n)\nasync def store(\n    form: HttpServerCreateForm,\n    http_server_repo: HttpServerRepo = Depends(HttpServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"http-server:create\")),\n):\n    if http_server_repo.exists(name=form.name.lower()):\n        abort_for_input(\"name\", \"Server name already taken\")\n\n    data = only(dict(form), [\"name\"])\n\n    data[\"name\"] = data[\"name\"].lower()\n\n    item = http_server_repo.create(data).data()\n    return HttpServerResponse(http_server=item)\n\n\n@router.get(\n    \"/http-server/{http_server}\",\n    name=\"http_server.show\",\n    response_model=HttpServerResponse,\n)\nasync def show(\n    http_server: str,\n    http_server_repo: HttpServerRepo = Depends(HttpServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"http-server:show\")),\n    includes: List[str] = Query(None),\n):\n    includes = only(includes, [\"zones\"], values=True)\n\n    http_server_id_label = http_server_repo.label(\"id\")\n\n    try:\n        http_server = int(http_server)\n        label = http_server_id_label\n    except ValueError:\n        label = http_server_repo.label(\"name\")\n\n    # TODO: is this vulnerable to sql injection?\n    item = (\n        http_server_repo.loads(includes)\n        .filter(label == http_server)\n        .first_or_fail()\n        .includes(includes)\n        .data()\n    )\n\n    return HttpServerResponse(http_server=item)\n\n\n# TODO: make specifi update form for http server\n@router.put(\n    \"/http-server/{http_server}\",\n    name=\"http_server.update\",\n    response_model=HttpServerResponse,\n)\nasync def update(\n    http_server: str,\n    form: HttpServerCreateForm,\n    http_server_repo: HttpServerRepo = Depends(HttpServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"http-server:update\")),\n):\n\n    data = only(dict(form), [\"name\"])\n    data[\"name\"] = data[\"name\"].lower()\n\n    http_server_id_label = http_server_repo.label(\"id\")\n\n    try:\n        http_server = int(http_server)\n        label = http_server_id_label\n    except ValueError:\n        label = http_server_repo.label(\"name\")\n\n    # TODO: is this vulnerable to sql injection?\n    item = (\n        http_server_repo.filter(label == http_server)\n        .first_or_fail()\n        .update(data)\n        .data()\n    )\n\n    return HttpServerResponse(http_server=item)\n"}
{"type": "source_file", "path": "boucanpy/api/routers/zone/__init__.py", "content": ""}
{"type": "source_file", "path": "boucanpy/api/routers/status/router.py", "content": "from fastapi import APIRouter\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n@router.get(\"/status\", name=\"status.show\")\nasync def login():\n    return {\"status\": \"up\"}\n"}
{"type": "source_file", "path": "boucanpy/api/routers/auth/refresh/router.py", "content": "from fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom boucanpy.core.auth import PasswordAuthResponse\nfrom boucanpy.db.models.user import User\n\nfrom boucanpy.core.security import (\n    create_bearer_token,\n    current_user,\n    TokenPayload,\n    ScopedTo,\n)\n\nrouter = APIRouter()\noptions = {\"prefix\": \"/auth\"}\n\n\n@router.post(\"/refresh\", name=\"auth.refresh\", response_model=PasswordAuthResponse)\nasync def login(\n    token: TokenPayload = Depends(ScopedTo(\"refresh\")),\n    user: User = Depends(current_user),\n):\n    token = create_bearer_token(\n        data={\"sub\": token.sub, \"scopes\": \" \".join(token.scopes)}\n    )\n    return PasswordAuthResponse(token_type=\"bearer\", access_token=str(token))\n"}
{"type": "source_file", "path": "boucanpy/api/routers/dns_record/router.py", "content": "from fastapi import APIRouter, Depends, Query\nfrom typing import List\nfrom starlette.responses import RedirectResponse\nfrom starlette.requests import Request\nfrom boucanpy.core import only, logger\nfrom boucanpy.core.security import ScopedTo, TokenPayload\n\nfrom boucanpy.core.dns_record import (\n    DnsRecordsResponse,\n    DnsRecordResponse,\n    DnsRecordRepo,\n    DnsRecordForZoneCreateForm,\n)\n\nfrom boucanpy.core import SortQS, PaginationQS, BaseResponse\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n@router.get(\"/dns-record\", name=\"dns_record.index\", response_model=DnsRecordsResponse)\nasync def index(\n    sort_qs: SortQS = Depends(SortQS),\n    pagination: PaginationQS = Depends(PaginationQS),\n    dns_record_repo: DnsRecordRepo = Depends(DnsRecordRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-record:list\")),\n    includes: List[str] = Query(None),\n):\n    includes = only(includes, [\"zone\"], values=True)\n\n    pg, items = (\n        dns_record_repo.loads(\"zone\")\n        .sort(sort_qs)\n        .paginate(pagination)\n        .includes(includes)\n        .data()\n    )\n\n    return DnsRecordsResponse(pagination=pg, dns_records=items)\n\n\n@router.post(\"/dns-record\", name=\"dns_record.store\")\nasync def store(request: Request, form: DnsRecordForZoneCreateForm = Depends()):\n    return RedirectResponse(\n        url=request.url_for(\"zone.dns_record.store\", zone_id=form.zone_id),\n        status_code=307,\n    )\n\n\n@router.get(\n    \"/dns-record/{dns_record_id}\",\n    name=\"dns_record.show\",\n    response_model=DnsRecordResponse,\n)\nasync def show(\n    dns_record_id: int,\n    dns_record_repo: DnsRecordRepo = Depends(DnsRecordRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-record:show\")),\n    includes: List[str] = Query(None),\n):\n    includes = only(includes, [\"zone\"], values=True)\n\n    item = (\n        dns_record_repo.loads(\"zone\")\n        .first_or_fail(id=dns_record_id)\n        .includes(includes)\n        .data()\n    )\n\n    return DnsRecordResponse(dns_record=item)\n\n\n# TODO: create update form for dns record\n@router.put(\"/dns-record/{dns_record_id}\", name=\"dns_record.update\")\nasync def update(\n    dns_record_id: int, request: Request, form: DnsRecordForZoneCreateForm = Depends()\n):\n    return RedirectResponse(\n        url=request.url_for(\n            \"zone.dns_record.update\", zone_id=form.zone_id, dns_record_id=dns_record_id\n        ),\n        status_code=307,\n    )\n\n\n@router.delete(\n    \"/dns-record/{dns_record_id}\",\n    name=\"dns_record.destroy\",\n    response_model=BaseResponse,\n)\nasync def destroy(\n    dns_record_id: int,\n    dns_record_repo: DnsRecordRepo = Depends(DnsRecordRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"dns-record:destroy\")),\n):\n\n    dns_record_repo.first_or_fail(id=dns_record_id).delete()\n    messages = [{\"text\": \"Delete Succesful\", \"type\": \"success\"}]\n    return BaseResponse(messages=messages)\n"}
{"type": "source_file", "path": "boucanpy/api/__init__.py", "content": ""}
{"type": "source_file", "path": "boucanpy/api/routers/zone/router.py", "content": "from fastapi import APIRouter, Depends, Query\nfrom typing import List\nfrom boucanpy.core.security import ScopedTo, TokenPayload\nfrom boucanpy.core import logger, only, abort, abort_for_input\n\nfrom boucanpy.core import SortQS, PaginationQS, BaseResponse\nfrom boucanpy.core.dns_server import DnsServerRepo\nfrom boucanpy.core.http_server import HttpServerRepo\n\nfrom boucanpy.core.zone import (\n    ZoneRepo,\n    ZonesResponse,\n    ZoneResponse,\n    ZoneData,\n    ZoneCreateForm,\n)\n\nrouter = APIRouter()\noptions = {\"prefix\": \"\"}\n\n\n@router.get(\"/zone\", name=\"zone.index\", response_model=ZonesResponse)\nasync def index(\n    sort_qs: SortQS = Depends(SortQS),\n    pagination: PaginationQS = Depends(PaginationQS),\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"zone:list\")),\n    includes: List[str] = Query(None),\n):\n    # TODO: bypasses a bunch of scopes, find a way to restrict access via scopes\n    includes = only(includes, [\"dns_server\", \"dns_records\", \"http_server\"], values=True)\n\n    pg, items = (\n        zone_repo.loads(includes)\n        .strict()\n        .sort(sort_qs)\n        .paginate(pagination)\n        .includes(includes)\n        .data()\n    )\n    return ZonesResponse(pagination=pg, zones=items)\n\n\n@router.post(\"/zone\", name=\"zone.store\", response_model=ZoneResponse)\nasync def store(\n    form: ZoneCreateForm,\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    dns_server_repo: DnsServerRepo = Depends(DnsServerRepo()),\n    http_server_repo: HttpServerRepo = Depends(HttpServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"zone:create\")),\n):\n\n    data = only(dict(form), [\"ip\", \"domain\"])\n\n    data[\"domain\"] = data[\"domain\"].lower()\n\n    # Make sure domain is unique\n\n    if zone_repo.exists(domain=data[\"domain\"]):\n        abort_for_input(\"domain\", \"A Zone with that domain already exists\")\n\n    zone_repo.clear()\n\n    if form.dns_server_id:\n        if dns_server_repo.exists(id=form.dns_server_id):\n            data[\"dns_server_id\"] = dns_server_repo.results().id\n\n    if form.http_server_id:\n        if http_server_repo.exists(id=form.http_server_id):\n            data[\"http_server_id\"] = http_server_repo.results().id\n\n    zone = zone_repo.create(data).data()\n    return ZoneResponse(zone=zone)\n\n\n@router.get(\"/zone/{zone_id}\", name=\"zone.show\", response_model=ZoneResponse)\nasync def show(\n    zone_id: int,\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"zone:show\")),\n    includes: List[str] = Query(None),\n):\n    includes = only(includes, [\"dns_server\", \"dns_records\", \"http_server\"], values=True)\n\n    zone = zone_repo.loads(includes).get_or_fail(zone_id).includes(includes).data()\n    return ZoneResponse(zone=zone)\n\n\n# TODO: make custom update form for zone\n@router.put(\"/zone/{zone_id}\", name=\"zone.update\", response_model=ZoneResponse)\nasync def update(\n    zone_id: int,\n    form: ZoneCreateForm,\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    dns_server_repo: DnsServerRepo = Depends(DnsServerRepo()),\n    http_server_repo: DnsServerRepo = Depends(HttpServerRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"zone:update\")),\n    includes: List[str] = Query(None),\n):\n    data = only(dict(form), [\"ip\", \"domain\"])\n\n    if \"domain\" in data:\n        data[\"domain\"] = data[\"domain\"].lower()\n        existing_domain = zone_repo.first(domain=data[\"domain\"]).results()\n        if existing_domain and existing_domain.id != zone_id:\n            abort_for_input(\"domain\", \"A Zone with that domain already exists\")\n        zone_repo.clear()\n\n    if form.dns_server_id is not None:\n        if form.dns_server_id is 0:\n            data[\"dns_server_id\"] = None\n        elif dns_server_repo.exists(id=form.dns_server_id):\n            dns_server = dns_server_repo.results()\n            data[\"dns_server\"] = dns_server\n\n    if form.http_server_id is not None:\n        if form.http_server_id is 0:\n            data[\"http_server_id\"] = None\n        elif http_server_repo.exists(id=form.http_server_id):\n            http_server = http_server_repo.results()\n            data[\"http_server\"] = http_server\n\n    zone = (\n        zone_repo.loads(includes)\n        .get_or_fail(zone_id)\n        .update(data)\n        .includes(includes)\n        .data()\n    )\n    return ZoneResponse(zone=zone)\n\n\n@router.put(\n    \"/zone/{zone_id}/activate\", name=\"zone.activate\", response_model=ZoneResponse\n)\nasync def activate(\n    zone_id: int,\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"zone:update\")),\n):\n    zone = zone_repo.get_or_fail(zone_id).update({\"is_active\": True}).data()\n    return ZoneResponse(zone=zone)\n\n\n@router.delete(\"/zone/{zone_id}\", name=\"zone.destroy\", response_model=BaseResponse)\nasync def destroy(\n    zone_id: int,\n    zone_repo: ZoneRepo = Depends(ZoneRepo()),\n    token: TokenPayload = Depends(ScopedTo(\"zone:destroy\")),\n):\n    messages = [{\"text\": \"Deactivation Succesful\", \"type\": \"success\"}]\n    if not zone_repo.exists(zone_id):\n        return BaseResponse(messages=messages)\n    zone_repo.deactivate(zone_id)\n    return BaseResponse(messages=messages)\n"}
{"type": "source_file", "path": "boucanpy/broadcast/utils.py", "content": "from boucanpy.core.utils import getenv\n\n# TODO: no caps\n\n\ndef make_broadcast_url():\n    BROADCAST_USER = \"\"\n    BROADCAST_DRIVER = getenv(\"BROADCAST_DRIVER\", \"redis\")\n    BROADCAST_PATH = getenv(\"BROADCAST_PATH\", \"0\")\n    BROADCAST_HOST = getenv(\"BROADCAST_HOST\", \"broadcast\")\n    BROADCAST_PORT = getenv(\"BROADCAST_PORT\", \"6379\")\n    BROADCAST_PASSWORD = getenv(\"BROADCAST_PASSWORD\", \"broadcast\")\n    BROADCAST_URL = f\"{BROADCAST_DRIVER}://{BROADCAST_USER}:{BROADCAST_PASSWORD}@{BROADCAST_HOST}:{BROADCAST_PORT}/{BROADCAST_PATH}\"\n\n    return BROADCAST_URL\n"}
{"type": "source_file", "path": "boucanpy/cli/__init__.py", "content": "from os import walk\nfrom pathlib import Path\nfrom os.path import join, basename\nfrom importlib import import_module\nfrom boucanpy.core.utils import cli_dir, snake_to_title\n\ncommands = []\n\n\ndef extact_commands(parent_dir, parent_mod):\n    _commands = []\n    for directory_name, sub_directories, files in walk(parent_dir):\n        # import each file in parent_dir\n        if not basename(directory_name).startswith((\"__\", \"base\")):\n            for f in sorted(files):\n                if (\n                    not f.startswith((\"__\", \"base\"))\n                    and Path(join(parent_dir, f)).is_file()\n                ):\n                    base_name = f.split(\".\")[0]\n                    class_name = snake_to_title(base_name)\n                    module_path = f\"{parent_mod}.{base_name}\"\n                    module = import_module(module_path, class_name)\n                    _command = getattr(module, class_name, None)\n                    if _command:\n                        _commands.append(_command)\n                    else:\n                        if module_path != \"boucanpy.cli.parser\":\n                            print(f\"failed to find command in {module_path}\")\n\n    for directory_name, sub_directories, files in walk(parent_dir):\n        # loop over each sub directory in parent_dir and import those files\n        for sub_dir_name in sub_directories:\n            if not sub_dir_name.startswith((\"__\", \"base\")):\n                sub_dir = join(parent_dir, sub_dir_name)\n                _commands = _commands + extact_commands(\n                    sub_dir, f\"{parent_mod}.{sub_dir_name}\"\n                )\n    return _commands\n\n\nfor c in extact_commands(cli_dir(), \"boucanpy.cli\"):\n    commands.append(c)\n"}
{"type": "source_file", "path": "boucanpy/cli/alembic/alembic_history.py", "content": "from os.path import join\nfrom boucanpy.core.utils import db_dir\nfrom boucanpy.db.session import session, db_register\nfrom boucanpy.db.utils import make_db_url\nfrom boucanpy.db.migrate.history import history\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass AlembicHistory(BaseCommand):\n    name = \"alembic-history\"\n    aliases = [\"al-history\"]\n    description = \"run alembic history\"\n    migration_dir = join(db_dir(\"alembic\"), \"api\")\n\n    @classmethod\n    def parser(cls, parser):\n        return parser\n\n    async def run(self):\n        db_register(make_db_url())\n        history(self.migration_dir)\n"}
{"type": "source_file", "path": "boucanpy/cli/alembic/alembic_init.py", "content": "from os.path import join\nfrom boucanpy.core.utils import db_dir\nfrom boucanpy.db.session import session, db_register\nfrom boucanpy.db.utils import make_db_url\nfrom boucanpy.db.migrate.initialize import initialize\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass AlembicInit(BaseCommand):\n    name = \"alembic-init\"\n    aliases = [\"al-init\"]\n    description = \"run alembic init\"\n    migration_dir = join(db_dir(\"alembic\"), \"api\")\n\n    @classmethod\n    def parser(cls, parser):\n        return parser\n\n    async def run(self):\n        db_register(make_db_url())\n        initialize(self.migration_dir)\n"}
{"type": "source_file", "path": "boucanpy/cli/alembic/alembic_downgrade.py", "content": "from os.path import join\nfrom boucanpy.core.utils import db_dir\nfrom boucanpy.db.session import session, db_register\nfrom boucanpy.db.utils import make_db_url\nfrom boucanpy.db.migrate.downgrade import downgrade\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass AlembicDowngrade(BaseCommand):\n    name = \"alembic-downgrade\"\n    aliases = [\"al-downgrade\"]\n    description = \"run alembic downgrade\"\n    migration_dir = join(db_dir(\"alembic\"), \"api\")\n\n    @classmethod\n    def parser(cls, parser):\n        return parser\n\n    async def run(self):\n        env = self.option(\"env\")\n        db_register(make_db_url())\n        downgrade(self.migration_dir)\n"}
{"type": "source_file", "path": "boucanpy/api/websocket.py", "content": "import json\nfrom urllib.parse import urlparse, parse_qs\nfrom starlette.websockets import WebSocket, WebSocketDisconnect\nfrom fastapi import HTTPException\nimport aioredis\n\nfrom boucanpy.core import logger\nfrom boucanpy.core.security import (\n    verify_jwt_token,\n    token_has_required_scopes,\n    current_user,\n)\nfrom boucanpy.core import TokenPayload\nfrom boucanpy.core.user import UserRepo\n\nfrom boucanpy.db import session\nfrom boucanpy.broadcast import make_redis, make_broadcast_url, make_subscriber\n\n# TODO: clean up this mess\n\n\nasync def broadcast_index(websocket: WebSocket):\n    try:\n        logger.info(\"broadcast_index@websocket.py - Accepting websockets\")\n        await websocket.accept()\n    except Exception as e:\n        logger.critical(f\"broadcast_index@websocket.py - Accept: Error: {str(type(e))}\")\n        logger.critical(f\"broadcast_index@websocket.py - Accept: Trace: {str(e)}\")\n        logger.critical(\n            f\"broadcast_index@websocket.py - Accept:Not closing or unsubscribing\"\n        )\n        return 1\n\n    try:\n        while True:\n            logger.info(\"broadcast_index@websocket.py - Receiving json\")\n            data = await websocket.receive_json()\n            logger.info(\"broadcast_index@websocket.py - Received json: \" + str(data))\n            logger.info(\n                \"broadcast_index@websocket.py - Sending message: \"\n                + str({\"message\": \"greetings\"})\n            )\n            await websocket.send_json({\"message\": \"greetings\"})\n    except Exception as e:\n        logger.critical(\n            f\"broadcast_index@websocket.py - Receieve/Send: Error: {str(type(e))}\"\n        )\n        logger.critical(\n            f\"broadcast_index@websocket.py - Receieve/Send: Trace: {str(e)}\"\n        )\n        logger.critical(\n            f\"broadcast_index@websocket.py - Receieve/Send: Not closing or unsubscribing\"\n        )\n        return 1\n\n    await websocket.close()\n\n\n# TODO: clean up this mess\nasync def broadcast_auth(websocket: WebSocket):\n    try:\n        await websocket.accept()\n    except Exception as e:\n        logger.critical(f\"broadcast_auth@websocket.py - Accept Error: {str(type(e))}\")\n        logger.critical(f\"broadcast_auth@websocket.py - Accept Trace: {str(e)}\")\n        return 1\n\n    params = parse_qs(urlparse(str(websocket.url)).query)\n    token = verify_jwt_token(params[\"ws_access_token\"][0])\n    if not token_has_required_scopes(token, []):  # TODO: check scopes later\n        raise HTTPException(403, detail=\"Forbidden\")\n    user_repo = UserRepo(session())\n    user = await current_user(token, user_repo)\n\n    subscriber, channel = await make_subscriber(\"auth\")\n\n    try:\n        while await channel.wait_message():\n            logger.info(\"broadcast_auth@websocket.py - Waiting for message\")\n            msg = await channel.get(encoding=\"utf-8\")\n            logger.info(\"broadcast_auth@websocket.py - Received message: \" + str(msg))\n            data = json.loads(msg)\n            logger.info(\"broadcast_auth@websocket.py - Sending message: \" + str(data))\n            await websocket.send_json(data)\n    except Exception as e:\n        logger.critical(\n            f\"broadcast_auth@websocket.py - Receieve/Send: Error: {str(type(e))}\"\n        )\n        logger.critical(f\"broadcast_auth@websocket.py - Receieve/Send: Trace:{str(e)}\")\n        logger.critical(\n            f\"broadcast_auth@websocket.py - Receieve/Send: Not closing or unsubscribing\"\n        )\n\n        return 1\n\n    logger.info(f\"broadcast_index@websocket.py - Attempting to unsuscribe\")\n    await subscriber.unsubscribe(\"channel:auth\")\n    logger.info(f\"broadcast_index@websocket.py: Websocket - Attempting to close socket\")\n    await websocket.close()\n\n"}
{"type": "source_file", "path": "boucanpy/broadcast/checks.py", "content": "from time import sleep\nfrom boucanpy.core import logger\nfrom boucanpy.broadcast import make_redis\n\n\nasync def is_broadcast_up():\n    seconds = 0\n    while True:\n        if seconds > 60:\n            logger.critical(\"could not start api. broadcast (queue) not up\")\n            return False\n        logger.debug(\"checking for broadcast (queue) status\")\n        try:\n            redis = await make_redis()\n            await redis.set(\"up-key\", \"value\")\n            val = await redis.get(\"up-key\")\n            val = await redis.delete(\"up-key\")\n            return True\n        except Exception as e:\n            logger.critical(\n                \"broadcast (queue) check not ready after {} seconds: {}\".format(\n                    str(seconds), str(e.__class__.__name__)\n                )\n            )\n        seconds = seconds + 2\n        sleep(2)\n"}
{"type": "source_file", "path": "boucanpy/cli/api/api_server.py", "content": "import uvicorn\n\nfrom uvicorn import Config as UvicornConfig, Server as UvicornServer\nfrom uvicorn.supervisors import Multiprocess, StatReload\n\n\nfrom os import environ\nfrom boucanpy.core import logger, set_log_level\nfrom boucanpy.core.utils import project_dir\nfrom boucanpy.core.security import hash_password\nfrom boucanpy.cli.base import BaseCommand\nfrom boucanpy.cli.db_setup import DbSetup\nfrom boucanpy.cli.db_wait import DbWait\nfrom boucanpy.db.factories import factory\n\n\nclass ApiServer(BaseCommand):\n    name = \"api-server\"\n    aliases = [\"api\"]\n    description = \"run api server\"\n    add_log_level = True\n    add_debug = True\n\n    @classmethod\n    def parser(cls, parser):\n        parser.add_argument(\n            \"-p\", \"--port\", action=\"store\", type=int, default=8080, help=\"listen port\"\n        )\n        parser.add_argument(\n            \"-l\", \"--listen\", action=\"store\", default=\"127.0.0.1\", help=\"bind address\"\n        )\n        parser.add_argument(\n            \"--force-exit\",\n            action=\"store_true\",\n            help=\"force exit on reload, useful for restarting websockets in development\",\n        )\n\n        parser.add_argument(\"-r\", \"--reload\", action=\"store_true\", help=\"reload\")\n        parser.add_argument(\"-w\", \"--workers\", action=\"store\", help=\"workers\")\n        parser.add_argument(\n            \"-i\",\n            \"--import-check\",\n            action=\"store_true\",\n            help=\"perform an import check of the api instance\",\n        )\n\n        parser.add_argument(\n            \"--no-db-check\", action=\"store_true\", help=\"do not wait for database\"\n        )\n\n        parser.add_argument(\n            \"--db-setup\", action=\"store_true\", help=\"run db setup before start\"\n        )\n\n        parser.add_argument(\n            \"--db-seed-env\", action=\"store_true\", help=\"seed data from env variables\"\n        )\n\n        parser.add_argument(\n            \"--db-seed\", action=\"store_true\", help=\"seed additional fake data\"\n        )\n\n        parser.add_argument(\n            \"--no-bcast-check\",\n            action=\"store_true\",\n            help=\"do not wait for broadcast service\",\n        )\n        return parser\n\n    async def run(self):\n        app = \"boucanpy.api.main:api\"\n        kwargs = self.get_kwargs()\n\n        if self.should_import_check():\n            logger.info(\"run@api_server.py - Performing import check\")\n            from boucanpy.api.main import api\n\n        logger.critical(\n            \"run@api_server.py - Starting api server with options: {}\".format(\n                str(kwargs)\n            )\n        )\n        from boucanpy.db.checks import is_db_up, is_db_setup\n\n        # alembic just destroys the loggers, it's annoying\n        if self.should_db_check():\n            logger.info(\"run@api_server.py - Waiting for database service to be up\")\n            db_wait_options = self._args_to_dict(self.options)\n            await DbWait(db_wait_options).run()\n\n        if self.option(\"db_setup\"):\n            logger.critical(\"run@api_server.py - Running database migration\")\n            db_setup_options = self._args_to_dict(self.options)\n            if self.option(\"db_seed\"):\n                db_setup_options[\"seed\"] = True\n            await DbSetup(db_setup_options).run()\n\n        if self.should_db_check():\n            logger.info(\n                \"run@api_server.py - Checking if application database is setup and configured\"\n            )\n\n            db_setup = is_db_setup()\n            if not db_setup:\n                logger.critical(\n                    \"run@api_server.py - Database not setup error. please check logs\"\n                )\n                return self.exit(1)\n\n        from boucanpy.broadcast import is_broadcast_up\n\n        if self.should_bcast_check():\n            bcast_up = await is_broadcast_up()\n            if not bcast_up:\n                logger.critical(\n                    \"run@api_server.py - Broadcast (queue) not up error. please check logs\"\n                )\n                return self.exit(1)\n\n        if self.option(\"db_seed_env\", False):\n            self.seed_from_env()\n\n        # taken from uvicorn/main.py:run\n\n        logger.debug(\"run@api_server.py - Building Uvicorn Config and Server\")\n        config = UvicornConfig(app, log_config=self.get_uvicorn_logging(), **kwargs)\n        server = UvicornServer(config=config)\n        if self.option(\"force_exit\"):\n            server.force_exit = True\n\n        if isinstance(app, str) and (config.debug or config.reload):\n            logger.warning(f\"run@api_server.py - Running boucanpy api in dev mode...\")\n            sock = config.bind_socket()\n            supervisor = StatReload(config)\n            return supervisor.run(server.run, sockets=[sock])\n        elif config.workers > 1:\n            sock = config.bind_socket()\n            supervisor = Multiprocess(config)\n            logger.warning(\n                f\"run@api_server.py - Running boucanpy api in worker mode...\"\n            )\n            return supervisor.run(server.run, sockets=[sock])\n        else:\n            sockets = None\n            logger.warning(\n                f\"run@api_server.py - Running boucanpy api in standard mode...\"\n            )\n            return await server.serve(sockets=sockets)\n\n    def get_kwargs(self):\n        kwargs = {\n            \"host\": self.option(\"listen\"),\n            \"port\": self.option(\"port\"),\n            \"log_level\": self.get_log_level(),\n        }\n        if self.get_reload():\n            kwargs[\"reload\"] = self.get_reload()\n            kwargs[\"reload_dirs\"] = [project_dir()]\n\n        elif self.get_workers():\n            kwargs[\"workers\"] = int(self.get_workers())\n\n        if self.option(\"debug\", None):\n            kwargs[\"debug\"] = True\n        return kwargs\n\n    def get_reload(self):\n        if self.option(\"debug\", None):\n            return True\n        return bool(self.option(\"reload\"))\n\n    def get_workers(self):\n        if self.option(\"debug\", None) or self.option(\"reload\", None):\n            logger.critical(\n                \"get_workers@api_server.py - Cannot use debug or reload with workers. Skipping.\"\n            )\n            return None\n        return self.option(\"workers\", 5)\n\n    def should_import_check(self):\n        return (\n            self.option(\"import_check\", False)\n            or self.env(\"API_IMPORT_CHECK\", 0, int_=True) == 1\n        )\n\n    def should_db_check(self):\n        if not self.option(\"no_db_check\", False):\n            return True\n        elif self.env(\"API_NO_DB_CHECK\", 1, int_=True) == 0:\n            return True\n        return False\n\n    def should_bcast_check(self):\n        if self.env(\"BROADCAST_ENABLED\", 0, int_=True) == 0:\n            return False\n        elif self.option(\"no_bcast_check\", False):\n            return False\n        elif self.env(\"API_NO_BROADCAST_CHECK\", 1, int_=True) == 0:\n            return False\n        return True\n\n    def seed_from_env(self):\n        from boucanpy.core.user import UserRepo\n        from boucanpy.core.zone import ZoneRepo\n        from boucanpy.core.dns_server import DnsServerRepo\n        from boucanpy.db.session import _scoped_session\n\n        session = _scoped_session\n\n        for i in range(9):\n            i = str(i)\n            user_data = {}\n            email_key = f\"SEED_USER_{i}_EMAIL\"\n            email = environ.get(email_key, None)\n            password_key = f\"SEED_USER_{i}_PASSWORD\"\n            password = environ.get(password_key, None)\n            superuser_key = f\"SEED_USER_{i}_SUPERUSER\"\n            is_superuser = int(environ.get(superuser_key, 0))\n            if email and password:\n                email = email.lower()\n                hashed_password = hash_password(password)\n                repo = UserRepo(db=session)\n                if not repo.exists(email=email):\n                    logger.info(f\"seed_from_env@api_server.py - seeding user {email}\")\n                    user = factory(\"UserFactory\", session=session).create(\n                        email=email,\n                        hashed_password=hashed_password,\n                        is_superuser=is_superuser,\n                    )\n                else:\n                    logger.info(\n                        f\"seed_from_env@api_server.py - Seeded user {email} already exists\"\n                    )\n\n        for i in range(9):\n            i = str(i)\n            name_key = f\"SEED_DNS_SERVER_{i}_NAME\"\n            name = environ.get(name_key, None)\n            if name:\n                repo = DnsServerRepo(db=session)\n                if not repo.exists(name=name):\n                    logger.info(f\"seed_from_env@api_server.py - Seeding domain {name}\")\n                    domain = factory(\"DnsServerFactory\", session=session).create(\n                        name=name\n                    )\n\n        for i in range(9):\n            i = str(i)\n            ip_key = f\"SEED_ZONE_{i}_IP\"\n            domain_key = f\"SEED_ZONE_{i}_DOMAIN\"\n            dns_server_name_key = f\"SEED_ZONE_{i}_DNS_SERVER_NAME\"\n            ip = environ.get(ip_key, None)\n            domain = environ.get(domain_key, None)\n            if domain:\n                domain = domain.lower()\n            dns_server_name = environ.get(dns_server_name_key, None)\n            if ip and domain:\n                if dns_server_name:\n                    dns_server_repo = DnsServerRepo(db=session)\n                    if dns_server_repo.exists(name=dns_server_name):\n                        dns_server = dns_server_repo.results()\n                    else:\n                        logger.info(\n                            f\"seed_from_env@api_server.py - Seeding dns server as zone dependency: {name}\"\n                        )\n                        dns_server = factory(\n                            \"DnsServerFactory\", session=session\n                        ).create(name=dns_server_name)\n                    factory(\"ZoneFactory\", session=session).create(\n                        ip=ip, domain=domain, dns_server=dns_server\n                    )\n                else:\n                    repo = ZoneRepo(db=session)\n                    if not repo.exists(ip=ip, domain=domain):\n                        logger.info(\n                            f\"seed_from_env@api_server.py - Seeding zone without dns server: {ip}, {domain}\"\n                        )\n                        factory(\"GlobalZoneFactory\", session=session).create(\n                            ip=ip, domain=domain\n                        )\n\n"}
{"type": "source_file", "path": "boucanpy/cli/alembic/__init__.py", "content": "from .alembic_current import AlembicCurrent\nfrom .alembic_downgrade import AlembicDowngrade\nfrom .alembic_history import AlembicHistory\nfrom .alembic_init import AlembicInit\nfrom .alembic_migrate import AlembicMigrate\nfrom .alembic_show import AlembicShow\nfrom .alembic_stamp import AlembicStamp\nfrom .alembic_upgrade import AlembicUpgrade\n"}
{"type": "source_file", "path": "boucanpy/cli/alembic/alembic_current.py", "content": "from os.path import join\nfrom boucanpy.core.utils import db_dir\nfrom boucanpy.db.session import session, db_register\nfrom boucanpy.db.utils import make_db_url\nfrom boucanpy.db.migrate.current import current\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass AlembicCurrent(BaseCommand):\n    name = \"alembic-current\"\n    aliases = [\"al-current\"]\n    description = \"run alembic current\"\n    migration_dir = join(db_dir(\"alembic\"), \"api\")\n\n    @classmethod\n    def parser(cls, parser):\n        return parser\n\n    async def run(self):\n        db_register(make_db_url())\n        current(self.migration_dir)\n"}
{"type": "source_file", "path": "boucanpy/cli/alembic/alembic_upgrade.py", "content": "from os.path import join\nfrom boucanpy.core.utils import db_dir\nfrom boucanpy.db.session import session, db_register\nfrom boucanpy.db.utils import make_db_url\nfrom boucanpy.db.migrate.upgrade import upgrade\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass AlembicUpgrade(BaseCommand):\n    name = \"alembic-upgrade\"\n    aliases = [\"al-upgrade\"]\n    description = \"run alembic upgrade\"\n    migration_dir = join(db_dir(\"alembic\"), \"api\")\n\n    @classmethod\n    def parser(cls, parser):\n        return parser\n\n    async def run(self):\n        db_register(make_db_url())\n        upgrade(self.migration_dir)\n"}
{"type": "source_file", "path": "boucanpy/cli/api/api_login.py", "content": "import requests\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass ApiLogin(BaseCommand):\n    name = \"api-login\"\n    aliases = [\"login\"]\n    description = \"login via API\"\n    path = \"/api/v1/auth/login\"\n\n    @classmethod\n    def parser(cls, parser):\n        parser.add_argument(\n            \"-a\",\n            \"--api-url\",\n            action=\"store\",\n            type=str,\n            default=\"http://127.0.0.1:8080\",\n            help=\"api address\",\n        )\n        parser.add_argument(\n            \"-e\",\n            \"--email\",\n            action=\"store\",\n            required=True,\n            type=str,\n            help=\"email address\",\n        )\n        parser.add_argument(\n            \"-i\",\n            \"--insecure-password\",\n            action=\"store\",\n            type=str,\n            help=\"insecure password (use prompt or stdin)\",\n        )\n        return parser\n\n    async def run(self):\n        url = self.option(\"api_url\")\n        email = self.option(\"email\")\n        password = self.get_password()\n        print(f\"attempting to login to {self.get_url()}\")\n        # spec requires form-data\n        response = requests.post(self.get_url(), data=self.get_json())\n        json_res = response.json()\n        print(json_res)\n\n    def get_url(self):\n        return self.option(\"api_url\") + self.path\n\n    def get_json(self):\n        return {\"username\": self.option(\"email\"), \"password\": self.get_password()}\n\n    def get_password(self):\n        if self.option(\"insecure_password\"):\n            return self.option(\"insecure_password\")\n        raise NotImplementedError()\n"}
{"type": "source_file", "path": "boucanpy/broadcast/broadcast.py", "content": "import aioredis\nfrom .utils import make_broadcast_url\n\n\nasync def make_redis():\n    return await aioredis.create_redis(make_broadcast_url())\n\n\nasync def make_subscriber(name):\n    subscriber = await make_redis()\n    res = await subscriber.subscribe(f\"channel:{name}\")\n    channel = res[0]\n    return subscriber, channel\n\n\n# can't create_redis outside of async ?\n"}
{"type": "source_file", "path": "boucanpy/cli/api/api_user_create.py", "content": "import requests\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass ApiUserCreate(BaseCommand):\n    name = \"api-user-create\"\n    aliases = [\"api-user\"]\n    description = \"create user via API\"\n    path = \"/api/v1/user\"\n\n    @classmethod\n    def parser(cls, parser):\n        parser.add_argument(\n            \"-a\",\n            \"--api-url\",\n            action=\"store\",\n            type=str,\n            default=\"http://127.0.0.1:8080\",\n            help=\"api address\",\n        )\n        parser.add_argument(\n            \"-t\",\n            \"--auth-token\",\n            action=\"store\",\n            type=str,\n            required=True,\n            help=\"api token\",\n        )\n        parser.add_argument(\n            \"-e\",\n            \"--email\",\n            action=\"store\",\n            required=True,\n            type=str,\n            help=\"email address\",\n        )\n        parser.add_argument(\n            \"-i\",\n            \"--insecure-password\",\n            action=\"store\",\n            type=str,\n            help=\"insecure password (use prompt or stdin)\",\n        )\n        return parser\n\n    async def run(self):\n        url = self.option(\"api_url\")\n        email = self.option(\"email\")\n        password = self.get_password()\n        print(f\"attempting to create user {self.get_url()}\")\n        # spec requires form-data\n        response = requests.post(\n            self.get_url(),\n            headers={\"Authorization\": \"Bearer {}\".format(self.option(\"auth_token\"))},\n            json=self.get_json(),\n        )\n        json_res = response.json()\n        print(json_res)\n\n    def get_url(self):\n        return self.option(\"api_url\") + self.path\n\n    def get_json(self):\n        return {\n            \"email\": self.option(\"email\"),\n            \"password\": self.get_password(),\n            \"password_confirm\": self.get_password(),\n        }\n\n    def get_password(self):\n        if self.option(\"insecure_password\"):\n            return self.option(\"insecure_password\")\n        raise NotImplementedError()\n"}
{"type": "source_file", "path": "boucanpy/cli/alembic/alembic_show.py", "content": "from os.path import join\nfrom boucanpy.core.utils import db_dir\nfrom boucanpy.db.session import session, db_register\nfrom boucanpy.db.utils import make_db_url\nfrom boucanpy.db.migrate.show import show\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass AlembicShow(BaseCommand):\n    name = \"alembic-show\"\n    aliases = [\"al-show\"]\n    description = \"run alembic show\"\n    migration_dir = join(db_dir(\"alembic\"), \"api\")\n\n    @classmethod\n    def parser(cls, parser):\n        return parser\n\n    async def run(self):\n        db_register(make_db_url())\n        show(self.migration_dir)\n"}
{"type": "source_file", "path": "boucanpy/broadcast/__init__.py", "content": "from .broadcast import make_redis, make_subscriber\nfrom .utils import make_broadcast_url\nfrom .checks import is_broadcast_up\n"}
{"type": "source_file", "path": "boucanpy/cli/alembic/alembic_migrate.py", "content": "from os.path import join\nfrom boucanpy.core.utils import db_dir\nfrom boucanpy.db.session import session, db_register\nfrom boucanpy.db.utils import make_db_url\nfrom boucanpy.db.migrate.migrate import migrate\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass AlembicMigrate(BaseCommand):\n    name = \"alembic-migrate\"\n    aliases = [\"al-migrate\"]\n    description = \"run alembic migrate\"\n    migration_dir = join(db_dir(\"alembic\"), \"api\")\n\n    @classmethod\n    def parser(cls, parser):\n        return parser\n\n    async def run(self):\n        db_register(make_db_url())\n        migrate(self.migration_dir)\n"}
{"type": "source_file", "path": "boucanpy/cli/api/api_urls.py", "content": "from boucanpy.cli.base import BaseCommand\n\n\nclass ApiUrls(BaseCommand):\n    name = \"api-urls\"\n    aliases = [\"urls\"]\n    description = \"list api urls\"\n\n    @classmethod\n    def parser(cls, parser):\n        return parser\n\n    async def run(self):\n        from boucanpy.api.main import api\n\n        for route in api.routes:\n            print(route.name, route.path, getattr(route, \"methods\", None))\n"}
{"type": "source_file", "path": "boucanpy/api_client.py", "content": "import jwt\n\nfrom time import sleep\nimport requests\nfrom dnslib import QTYPE, RCODE, RR\nfrom urllib3.exceptions import InsecureRequestWarning\n\nfrom boucanpy.core import logger\n\nfrom boucanpy.core.zone.data import ZoneData\n\n\nclass ApiClient:\n    def __init__(self, api_url, api_token, verify_ssl=True):\n        self.api_url = api_url\n        self.api_token = api_token\n        self.zones = []\n        self.verify_ssl = verify_ssl\n        if not self.verify_ssl:\n            logger.warning(\n                \"__init__@dns_server.py - Disabling SSL Warnings. I hope this was intentional\"\n            )\n            requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)\n\n        payload = jwt.decode(api_token, verify=False)  # do not trust\n        if not \"dns_server_name\" in payload.keys() or not payload[\"dns_server_name\"]:\n            logger.critical(\n                f\"__init__@api_client.py - No dns_server_name on api token payload: {str(payload)}\"\n            )\n        self.dns_server_name = payload.get(\"dns_server_name\", \"\")\n\n        if not \"http_server_name\" in payload.keys() or not payload[\"http_server_name\"]:\n            logger.critical(\n                f\"__init__@api_client.py - No http_server_name on api token payload: {str(payload)}\"\n            )\n        self.http_server_name = payload.get(\"http_server_name\", \"\")\n\n    def sync(self):\n        logger.info(\"sync@api_client.py - Syncing api token\")\n        return self.post(\"/api-token/sync\", fail=True)\n\n    def get_zones(self):\n        logger.info(\"get_zones@api_client.py - Getting zones\")\n        zone_data = self.get(\n            f\"/dns-server/{self.dns_server_name}/zone\",\n            params={\"includes\": [\"dns_records\"]},\n        )\n        data = [ZoneData(**z) for z in zone_data[\"zones\"]]\n        return data\n\n    def load_zones(self):\n        self.zones = self.get_zones()\n        return True\n\n    def refresh_zones_if_needed(self):\n        logger.info(\n            \"refresh_zones_if_needed@api_client.py - Checking for New Zones and Records...\"\n        )\n        old_zones = self.zones\n        new_zones = self.get_zones()\n        # TODO: fix this mess\n\n        if len(old_zones) != len(new_zones):\n            logger.warning(\n                f\"refresh_zones_if_needed@api_client.py - Zone Length mistmatch. New or Changed Zone Found: {str(old_zones)} != {str(new_zones)}. Reloading zones.\"\n            )\n            self.load_zones()\n            return True\n\n        for nz in new_zones:\n            # make sure new zones are in old zones\n            is_nz_exists = False\n            for oz in old_zones:\n                if oz.domain == nz.domain and oz.ip == nz.ip:\n                    nz_dns_records = nz.dns_records or []\n                    for nrec in nz_dns_records:\n                        is_rec_satisfied = False\n                        oz_dns_records = oz.dns_records or []\n                        if len(nz_dns_records) != len(oz_dns_records):\n                            logger.warning(\n                                f\"refresh_zones_if_needed@api_client.py - Zone Record Length mistmatch {str(len(nz_dns_records))} != {str(len(oz_dns_records))}. New or Changed Zone Record Found: {str(nz_dns_records)} != {str(oz_dns_records)}. Reloading zones.\"\n                            )\n                            self.load_zones()\n                            return True\n                        for orec in oz_dns_records:\n                            if orec.record == nrec.record and orec.sort == nrec.sort:\n                                is_rec_satisfied = True\n                        if not is_rec_satisfied:\n                            logger.warning(\n                                f\"refresh_zones_if_needed@api_client.py - New or Changed Zone Record {str(nz)}: {str(nrec)} found for server. Reloading zones.\"\n                            )\n                            self.load_zones()\n                            return True\n                    is_nz_exists = True\n            if not is_nz_exists:\n                logger.warning(\n                    f\"refresh_zones_if_needed@api_client.py - New or Changed Zone {str(nz)} found for server. Reloading zones.\"\n                )\n                self.load_zones()\n                return True\n\n        logger.info(\n            \"refresh_zones_if_needed@api_client.py - No New Zones or Records Found. All is well\"\n        )\n\n        return False\n\n    def get_status(self):\n        return self.get(\"/status\")\n\n    def create_dns_request(self, handler, request, request_uuid):\n        logger.info(\"create_dns_request@api_client.py - Creating dns request\")\n\n        name = str(request.q.qname)\n        name = name.rstrip(\".\")\n        data = {\n            \"name\": name,\n            \"source_address\": str(handler.client_address[0]),\n            \"source_port\": int(handler.client_address[1]),\n            \"type\": str(QTYPE[request.q.qtype]),\n            \"protocol\": str(handler.protocol),\n            \"dns_server_name\": str(self.dns_server_name),\n            \"raw_request\": str(request),\n        }\n        self.post(\"/dns-request\", data=data)\n\n    def create_http_request(\n        self, name, path, source_address, source_port, type, protocol, raw_request,\n    ):\n        logger.info(\"create_http_request@api_client.py - Creating http request\")\n\n        data = {\n            \"name\": name,\n            \"path\": path,\n            \"source_address\": str(source_address),\n            \"source_port\": int(source_port),\n            \"type\": str(type),\n            \"protocol\": str(protocol),\n            \"http_server_name\": str(self.http_server_name),\n            \"raw_request\": str(raw_request),\n        }\n        self.post(\"/http-request\", data=data)\n\n    def url(self, url):\n        return self.api_url + \"/api/v1\" + url\n\n    def get(self, url: str, params=None, fail=True):\n        params = params or {}\n        headers = self.get_default_headers()\n        logger.info(\"get@api_client.py - Getting URL: \" + str(self.url(url)))\n\n        res = requests.get(\n            self.url(url), headers=headers, params=params, verify=self.verify_ssl\n        )\n\n        if fail:\n            if res.status_code != 200:\n                logger.critical(\n                    f\"get@api_client.py - Error getting API {self.url(url)}: \"\n                    + str(res.json())\n                )\n            res.raise_for_status()\n        return res.json()\n\n    def post(self, url: str, data=None, fail=True):\n        data = data or {}\n        headers = self.get_default_headers()\n        logger.info(\"post@api_client.py - Posting URL: \" + str(self.url(url)))\n\n        res = requests.post(\n            self.url(url), json=data, headers=headers, verify=self.verify_ssl\n        )\n\n        if fail:\n            if res.status_code != 200:\n                logger.critical(\n                    f\"Error posting API {self.url(url)}: \" + str(res.json())\n                )\n            res.raise_for_status()\n        return res.json()\n\n    def get_default_headers(self):\n        return {\n            \"Authorization\": f\"Bearer {self.api_token}\",\n            \"Content-Accept\": \"application/json\",\n        }\n\n    def wait_for_up(self):\n        attempts = 0\n        while True:\n            if attempts > 60:\n                logger.warning(\"could not connect to api. api not up\")\n                return False\n            logger.info(\n                f\"wait_for_up@api_client.py - checking for api status : {self.url('/status')}\"\n            )\n            try:\n                sleep(1)\n                self.get_status()\n                sleep(3)\n                return True\n            except Exception as e:\n                logger.info(\n                    \"wait_for_up@api_client.py - api check not ready after {} attempts: {}\".format(\n                        str(attempts), str(e.__class__.__name__)\n                    )\n                )\n            attempts = attempts + 1\n            sleep(1)\n"}
{"type": "source_file", "path": "boucanpy/cli/api/api_users_list.py", "content": "import requests\nfrom boucanpy.cli.base import BaseCommand\nfrom boucanpy.db.models.user import User\n\n\nclass ApiUsersList(BaseCommand):\n    name = \"api-user-list\"\n    aliases = [\"api-users\"]\n    description = \"list users via API\"\n    path = \"/api/v1/user\"\n\n    @classmethod\n    def parser(cls, parser):\n        parser.add_argument(\n            \"-a\",\n            \"--api-url\",\n            action=\"store\",\n            type=str,\n            default=\"http://127.0.0.1:8080\",\n            help=\"api address\",\n        )\n        parser.add_argument(\n            \"-t\", \"--auth-token\", action=\"store\", type=str, help=\"api token\"\n        )\n        return parser\n\n    async def run(self):\n        res = requests.get(self.get_url(), headers=self.get_headers())\n        print(res.json())\n\n    def get_url(self):\n        return self.option(\"api_url\") + self.path\n\n    def get_headers(self):\n        return {\"Authorization\": \"Bearer \" + self.option(\"auth_token\")}\n"}
{"type": "source_file", "path": "boucanpy/cli/api/api_zone_create.py", "content": "import requests\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass ApiZoneCreate(BaseCommand):\n    name = \"api-zone-create\"\n    aliases = [\"api-zone\"]\n    description = \"create user via API\"\n    path = \"/api/v1/user\"\n\n    @classmethod\n    def parser(cls, parser):\n        parser.add_argument(\n            \"-a\",\n            \"--api-url\",\n            action=\"store\",\n            type=str,\n            default=\"http://127.0.0.1:8080\",\n            help=\"api address\",\n        )\n        parser.add_argument(\n            \"-t\",\n            \"--auth-token\",\n            action=\"store\",\n            type=str,\n            required=True,\n            help=\"api token\",\n        )\n        parser.add_argument(\n            \"-d\",\n            \"--domain\",\n            action=\"store\",\n            required=True,\n            type=str,\n            help=\"zone domain\",\n        )\n        parser.add_argument(\n            \"-i\",\n            \"--ip-address\",\n            action=\"store\",\n            type=str,\n            required=True,\n            help=\"resolvable ip\",\n        )\n        return parser\n\n    async def run(self):\n        # TODO: run this\n        url = self.option(\"api_url\")\n        domain = self.option(\"domain\")\n        ip = self.option(\"ip_addresss\")\n        print(f\"attempting to create zone {self.get_url()}\")\n        # spec requires form-data\n        response = requests.post(\n            self.get_url(),\n            headers={\"Authorization\": \"Bearer {}\".format(self.option(\"auth_token\"))},\n            json={\"domain\": domain, \"ip\": ip},\n        )\n        json_res = response.json()\n        print(json_res)\n\n    def get_url(self):\n        return self.option(\"api_url\") + self.path\n"}
{"type": "source_file", "path": "boucanpy/cli/alembic/alembic_stamp.py", "content": "from os.path import join\nfrom boucanpy.core.utils import db_dir\nfrom boucanpy.db.session import session, db_register\nfrom boucanpy.db.utils import make_db_url\nfrom boucanpy.db.migrate.stamp import stamp\nfrom boucanpy.cli.base import BaseCommand\n\n\nclass AlembicStamp(BaseCommand):\n    name = \"alembic-stamp\"\n    aliases = [\"al-stamp\"]\n    description = \"run alembic stamp\"\n    migration_dir = join(db_dir(\"alembic\"), \"api\")\n\n    @classmethod\n    def parser(cls, parser):\n        return parser\n\n    async def run(self):\n        db_register(make_db_url())\n        stamp(self.migration_dir)\n"}

{"repo_info": {"repo_name": "fastapi-base", "repo_owner": "Longdh57", "repo_url": "https://github.com/Longdh57/fastapi-base"}}
{"type": "test_file", "path": "tests/faker/__init__.py", "content": "import faker.providers\n\nfrom tests.faker.user_provider import UserProvider\n\nfake = faker.Faker()\n\nfake.add_provider(UserProvider)\n"}
{"type": "test_file", "path": "tests/api/test_register.py", "content": "import json\nimport random\n\nfrom starlette.testclient import TestClient\n\nfrom app.core.config import settings\nfrom app.helpers.enums import UserRole\nfrom tests.faker.user_provider import fake\n\n\nclass TestRegister:\n    def test_success(self, client: TestClient):\n        \"\"\"\n            Test api user register success\n            Step by step:\n            - Gọi API Register với đầu vào chuẩn\n            - Đầu ra mong muốn:\n                . status code: 200\n        \"\"\"\n        register_data = {\n            'full_name': fake.name(),\n            'email': fake.email(),\n            'password': 'secret123',\n            'role': random.choice(list(UserRole)).value\n        }\n        print(f'[x] register_data: {register_data}')\n        r = client.post(f\"{settings.API_PREFIX}/register\", json=register_data)\n        print(f'[x] Response: {r.json()}')\n        assert r.status_code == 200\n        response = r.json()\n        assert response['code'] == '000'\n        assert response['message'] == 'Thành công'\n        assert response['data']['email'] is not None\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "import os\nimport pytest\nimport requests\nfrom datetime import datetime\nfrom operator import itemgetter\nfrom docstring_parser import parse\nfrom app.main import get_application\nfrom app.models.model_base import Base\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import Any, Generator\nfrom fastapi import FastAPI\nfrom fastapi.testclient import TestClient\nfrom app.db.base import get_db\nfrom fastapi_sqlalchemy import DBSessionMiddleware\nfrom dotenv import load_dotenv\n\nload_dotenv(verbose=True)\n\nSQLALCHEMY_DATABASE_URL = os.getenv('SQLALCHEMY_DATABASE_URL', '/tests')\nconnect_args = {}\nif SQLALCHEMY_DATABASE_URL[:6] == 'sqlite':\n    connect_args['check_same_thread'] = False\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL,\n    connect_args=connect_args\n)\n\nTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_runtest_makereport(item, call):\n    outcome = yield\n    rep = outcome.get_result()\n    setattr(item, 'test_outcome', rep)\n\n\ndef pytest_addoption(parser):\n    parser.addoption('--submit-tests',\n                     action='store_true',\n                     help='Submit tests to Jira')\n\n\nclass JiraTestService:\n    def __init__(self, jira_settings):\n        self.project_key = jira_settings['project_key']\n        self.auth_string = (jira_settings['user'], jira_settings['password'])\n        self.url = jira_settings['url'] + '/rest/atm/1.0'\n        self.issue_url = jira_settings['url'] + '/rest/api/latest/issue'\n\n    def get_issue_info(self, issue_key):\n        return requests.get(\n            url=self.issue_url + '/' + issue_key,\n            auth=self.auth_string\n        ).json()\n\n    def get_tests_in_issue(self, issue_key):\n        params = {\n            'query':\n            'projectKey = \"%s\" AND issueKeys IN (%s)' %\n            (self.project_key, issue_key)\n        }\n        response = requests.get(url=self.url + '/testcase/search',\n                                params=params,\n                                auth=self.auth_string).json()\n        return list(map(itemgetter('name', 'key'), response))\n\n    def create_test(self, test_name, issue_key, objective, steps):\n        json = {\n            'name': test_name,\n            'projectKey': self.project_key,\n            'issueLinks': [issue_key],\n            'status': 'Approved',\n            'objective': objective,\n            \"testScript\": {\n                'type': 'PLAIN_TEXT',\n                'text': steps or \"Default\"\n            }\n        }\n        response = requests.post(url=self.url + '/testcase',\n                                 json=json,\n                                 auth=self.auth_string)\n        if response.status_code != 201:\n            raise Exception('Create test return with error status code',\n                            response.status_code)\n\n        test_key = response.json()['key']\n        return test_key\n\n    def delete_test(self, test_key):\n        response = requests.delete(url=self.url + '/testcase/' + test_key,\n                                   auth=self.auth_string)\n        if response.status_code != 204:\n            raise Exception('Delete test return with error status code',\n                            response.status_code)\n\n    def create_test_cycle(self, name, issue_key, items):\n        def get_current_time():\n            return datetime.now().strftime('%Y-%m-%dT%H:%M:%S')\n\n        json = {\n            'name': name,\n            'projectKey': self.project_key,\n            'issueKey': issue_key,\n            'plannedStartDate': get_current_time(),\n            'plannedEndDate': get_current_time(),\n            'items': items\n        }\n        response = requests.post(url=self.url + '/testrun',\n                                 json=json,\n                                 auth=self.auth_string)\n        if response.status_code != 201:\n            raise Exception('Create test cycle return with error status code',\n                            response.status_code)\n\n\ndef jira_test_service():\n    return JiraTestService({\n        'url': os.getenv('JIRA_URL', '/tests'),\n        'user': os.getenv('JIRA_USER', '/tests'),\n        'password': os.getenv('JIRA_PASSWORD', '/tests'),\n        'project_key': os.getenv('JIRA_PROJECT_KEY', '/tests')\n    })\n\n\ndelete_tests_on_issue = set()\n\n\n@pytest.fixture(scope='class')\ndef each_test_suite(request):\n    # Before each test suite\n    cls = request.cls\n    cls.results = {}\n    cls.tests_list = []\n\n    test_service = jira_test_service()  # Currently only support Jira\n\n    submit_tests = request.config.getoption('--submit-tests', default=False)\n    if not getattr(cls, 'ISSUE_KEY', None):\n        submit_tests = False\n    if submit_tests:\n        issue_info = test_service.get_issue_info(cls.ISSUE_KEY)\n        if issue_info['fields']['status']['name'] == 'Closed':\n            submit_tests = False\n\n    if submit_tests:\n        cls.tests_list = test_service.get_tests_in_issue(cls.ISSUE_KEY)\n\n        if cls.ISSUE_KEY not in delete_tests_on_issue:\n            for _, test_key in cls.tests_list:\n                test_service.delete_test(test_key)\n            delete_tests_on_issue.add(cls.ISSUE_KEY)\n\n    yield\n\n    # After each test suite\n    if submit_tests:\n        # Create test keys\n        for name in cls.results:\n            test_key = test_service.create_test(\n                cls.__name__ + '_' + name,\n                cls.ISSUE_KEY,\n                cls.results[name]['objective'],\n                cls.results[name]['steps']\n            )\n            cls.results[name]['testCaseKey'] = test_key\n        test_cycle_items = []\n\n        for k, v in cls.results.items():\n            del v['objective']\n            del v['steps']\n            test_cycle_items.append(v)\n\n        # Create test cycle\n        test_service.create_test_cycle(\n            cls.ISSUE_KEY + ' - ' + cls.__name__,\n            cls.ISSUE_KEY,\n            test_cycle_items\n        )\n\n\n@pytest.fixture()\ndef each_test_case(request):\n    # Before each test case\n    MAX_NAME_LENGTH = 255\n    name = request._pyfuncitem.name\n    if len(name) > MAX_NAME_LENGTH:\n        name = name.substring(0, MAX_NAME_LENGTH)\n    request.cls.results[name] = {'status': 'Pass'}\n    yield\n\n    # After each test case\n    if request.node.test_outcome.failed:\n        request.cls.results[name]['status'] = 'Fail'\n\n    docstring = parse(request._pyfuncitem._obj.__doc__)\n\n    step_string = 'Step by step:'\n    if docstring.long_description and step_string in docstring.long_description:\n        objective, steps = map(\n            str.strip, docstring.long_description.split(step_string, 1))\n        steps = '<pre>' + steps + '</pre>'\n    else:\n        objective = docstring.long_description\n        steps = None\n\n    request.cls.results[name]['objective'] = objective\n    request.cls.results[name]['steps'] = steps\n\n\n@pytest.fixture(autouse=True)\ndef app() -> Generator[FastAPI, Any, None]:\n    \"\"\"\n    Create a fresh database on each test case.\n    \"\"\"\n    Base.metadata.create_all(engine)  # Create the tables.\n    _app = get_application()\n    _app.add_middleware(DBSessionMiddleware, db_url=SQLALCHEMY_DATABASE_URL)\n    yield _app\n    Base.metadata.drop_all(engine)\n\n\n@pytest.fixture\ndef db_session(app: FastAPI) -> Generator[TestingSessionLocal, Any, None]:\n    \"\"\"\n    Creates a fresh sqlalchemy session for each test that operates in a\n    transaction. The transaction is rolled back at the end of each test ensuring\n    a clean state.\n    \"\"\"\n\n    # connect to the database\n    connection = engine.connect()\n    # begin a non-ORM transaction\n    transaction = connection.begin()\n    # bind an individual Session to the connection\n    session = TestingSessionLocal(bind=connection)\n    yield session  # use the session in tests.\n    session.close()\n    # rollback - everything that happened with the\n    # Session above (including calls to commit())\n    # is rolled back.\n    transaction.rollback()\n    # return connection to the Engine\n    connection.close()\n\n\n@pytest.fixture()\ndef client(app: FastAPI, db_session: TestingSessionLocal) -> Generator[TestClient, Any, None]:\n    \"\"\"\n    Create a new FastAPI TestClient that uses the `db_session` fixture to override\n    the `get_db` dependency that is injected into routes.\n    \"\"\"\n\n    def _get_test_db():\n        try:\n            yield db_session\n        finally:\n            pass\n\n    app.dependency_overrides[get_db] = _get_test_db\n    with TestClient(app) as client:\n        yield client\n\n\n@pytest.fixture\ndef app_class(request, app):\n    if request.cls is not None:\n        request.cls.app = app\n\n\n# For Jira Test\n@pytest.mark.usefixtures('each_test_case', 'each_test_suite')\nclass Jira:\n    pass\n"}
{"type": "test_file", "path": "tests/faker/user_provider.py", "content": "import logging\nimport faker.providers\n\nfrom app.helpers.enums import UserRole\nfrom app.models import User\nfrom fastapi_sqlalchemy import db\nfrom app.core.security import get_password_hash\n\nlogger = logging.getLogger()\nfake = faker.Faker()\n\n\nclass UserProvider(faker.providers.BaseProvider):\n    @staticmethod\n    def user(data={}):\n        \"\"\"\n        Fake an user in db for testing\n        :return: user model object\n        \"\"\"\n        user = User(\n            full_name=data.get('name') or fake.name(),\n            email=data.get('email') or fake.email(),\n            hashed_password=get_password_hash(data.get('password')) or get_password_hash(fake.lexify(text='?????????')),\n            is_active=data.get('is_active') if data.get('is_active') is not None else True,\n            role=data.get('role') if data.get('role') is not None else UserRole.GUEST.value\n        )\n        with db():\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n        return user\n"}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/api/__init__.py", "content": "import pytest\n\n\n@pytest.mark.usefixtures('app_class')\nclass APITestCase():\n    pass\n\n\nclass MockResponse:\n    def __init__(self, text, status_code):\n        self.text = text\n        self.status_code = status_code\n"}
{"type": "test_file", "path": "tests/api/test_login.py", "content": "from starlette.testclient import TestClient\n\nfrom app.core.config import settings\nfrom app.models import User\nfrom tests.faker import fake\n\n\nclass TestLogin:\n    def test_success(self, client: TestClient):\n        \"\"\"\n            Test api user login success\n            Step by step:\n            - Khởi tạo data mẫu với password hash\n            - Gọi API Login\n            - Đầu ra mong muốn:\n                . status code: 200\n                . access_token != null\n                . token_type == 'bearer'\n        \"\"\"\n        current_user: User = fake.user({'password': 'secret123'})\n        r = client.post(f\"{settings.API_PREFIX}/login\", data={\n            'username': current_user.email,\n            'password': 'secret123'\n        })\n        assert r.status_code == 200\n        response = r.json()\n        assert response['data']['access_token'] is not None\n        assert response['data']['token_type'] == 'bearer'\n\n    def test_incorrect_password(self, client: TestClient):\n        \"\"\"\n            Test api user login with incorrect password\n            Step by step:\n            - Khởi tạo data mẫu với password hash\n            - Gọi API Login với wrong password\n            - Đầu ra mong muốn:\n                . status code: 400\n        \"\"\"\n        current_user: User = fake.user({'password': 'secret123'})\n        r = client.post(f\"{settings.API_PREFIX}/login\", data={\n            'username': current_user.email,\n            'password': 'secret1234'\n        })\n        assert r.status_code == 400\n\n    def test_user_inactive(self, client: TestClient):\n        \"\"\"\n            Test api user is_active = False\n            Step by step:\n            - Khởi tạo data mẫu với password hash và is_active = False\n            - Gọi API Login\n            - Đầu ra mong muốn:\n                . status code: 401\n        \"\"\"\n        current_user: User = fake.user({'password': 'secret123', 'is_active': False})\n        r = client.post(f\"{settings.API_PREFIX}/login\", data={\n            'username': current_user.email,\n            'password': 'secret123'\n        })\n        assert r.status_code == 401\n"}
{"type": "source_file", "path": "app/api/api_user.py", "content": "import logging\nfrom typing import Any\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi_sqlalchemy import db\n\nfrom app.helpers.exception_handler import CustomException\nfrom app.helpers.login_manager import login_required, PermissionRequired\nfrom app.helpers.paging import Page, PaginationParams, paginate\nfrom app.schemas.sche_base import DataResponse\nfrom app.schemas.sche_user import UserItemResponse, UserCreateRequest, UserUpdateMeRequest, UserUpdateRequest\nfrom app.services.srv_user import UserService\nfrom app.models import User\n\nlogger = logging.getLogger()\nrouter = APIRouter()\n\n\n@router.get(\"\", dependencies=[Depends(login_required)], response_model=Page[UserItemResponse])\ndef get(params: PaginationParams = Depends()) -> Any:\n    \"\"\"\n    API Get list User\n    \"\"\"\n    try:\n        _query = db.session.query(User)\n        users = paginate(model=User, query=_query, params=params)\n        return users\n    except Exception as e:\n        return HTTPException(status_code=400, detail=logger.error(e))\n\n\n@router.post(\"\", dependencies=[Depends(PermissionRequired('admin'))], response_model=DataResponse[UserItemResponse])\ndef create(user_data: UserCreateRequest, user_service: UserService = Depends()) -> Any:\n    \"\"\"\n    API Create User\n    \"\"\"\n    try:\n        new_user = user_service.create_user(user_data)\n        return DataResponse().success_response(data=new_user)\n    except Exception as e:\n        raise CustomException(http_code=400, code='400', message=str(e))\n\n\n@router.get(\"/me\", dependencies=[Depends(login_required)], response_model=DataResponse[UserItemResponse])\ndef detail_me(current_user: User = Depends(UserService.get_current_user)) -> Any:\n    \"\"\"\n    API get detail current User\n    \"\"\"\n    return DataResponse().success_response(data=current_user)\n\n\n@router.put(\"/me\", dependencies=[Depends(login_required)], response_model=DataResponse[UserItemResponse])\ndef update_me(user_data: UserUpdateMeRequest,\n              current_user: User = Depends(UserService.get_current_user),\n              user_service: UserService = Depends()) -> Any:\n    \"\"\"\n    API Update current User\n    \"\"\"\n    try:\n        updated_user = user_service.update_me(data=user_data, current_user=current_user)\n        return DataResponse().success_response(data=updated_user)\n    except Exception as e:\n        raise CustomException(http_code=400, code='400', message=str(e))\n\n\n@router.get(\"/{user_id}\", dependencies=[Depends(login_required)], response_model=DataResponse[UserItemResponse])\ndef detail(user_id: int, user_service: UserService = Depends()) -> Any:\n    \"\"\"\n    API get Detail User\n    \"\"\"\n    try:\n        return DataResponse().success_response(data=user_service.get(user_id))\n    except Exception as e:\n        raise CustomException(http_code=400, code='400', message=str(e))\n\n\n@router.put(\"/{user_id}\", dependencies=[Depends(PermissionRequired('admin'))],\n            response_model=DataResponse[UserItemResponse])\ndef update(user_id: int, user_data: UserUpdateRequest, user_service: UserService = Depends()) -> Any:\n    \"\"\"\n    API update User\n    \"\"\"\n    try:\n        updated_user = user_service.update(user_id=user_id, data=user_data)\n        return DataResponse().success_response(data=updated_user)\n    except Exception as e:\n        raise CustomException(http_code=400, code='400', message=str(e))\n"}
{"type": "source_file", "path": "app/helpers/login_manager.py", "content": "from fastapi import HTTPException, Depends\n\nfrom app.models import User\nfrom app.services.srv_user import UserService\n\n\ndef login_required(http_authorization_credentials=Depends(UserService().reusable_oauth2)):\n    return UserService().get_current_user(http_authorization_credentials)\n\n\nclass PermissionRequired:\n    def __init__(self, *args):\n        self.user = None\n        self.permissions = args\n\n    def __call__(self, user: User = Depends(login_required)):\n        self.user = user\n        if self.user.role not in self.permissions and self.permissions:\n            raise HTTPException(status_code=400,\n                                detail=f'User {self.user.email} can not access this api')\n"}
{"type": "source_file", "path": "app/models/__init__.py", "content": "# Import all the models, so that Base has them before being\n# imported by Alembic\nfrom app.models.model_base import Base  # noqa\nfrom app.models.model_user import User  # noqa\n"}
{"type": "source_file", "path": "app/schemas/sche_base.py", "content": "from typing import Optional, TypeVar, Generic\nfrom pydantic.generics import GenericModel\n\nfrom pydantic import BaseModel\n\nT = TypeVar(\"T\")\n\n\nclass ResponseSchemaBase(BaseModel):\n    __abstract__ = True\n\n    code: str = ''\n    message: str = ''\n\n    def custom_response(self, code: str, message: str):\n        self.code = code\n        self.message = message\n        return self\n\n    def success_response(self):\n        self.code = '000'\n        self.message = 'Thành công'\n        return self\n\n\nclass DataResponse(ResponseSchemaBase, GenericModel, Generic[T]):\n    data: Optional[T] = None\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    def custom_response(self, code: str, message: str, data: T):\n        self.code = code\n        self.message = message\n        self.data = data\n        return self\n\n    def success_response(self, data: T):\n        self.code = '000'\n        self.message = 'Thành công'\n        self.data = data\n        return self\n\n\nclass MetadataSchema(BaseModel):\n    current_page: int\n    page_size: int\n    total_items: int\n"}
{"type": "source_file", "path": "app/schemas/sche_token.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str = 'bearer'\n\n\nclass TokenPayload(BaseModel):\n    user_id: Optional[int] = None\n"}
{"type": "source_file", "path": "app/helpers/exception_handler.py", "content": "import enum\n\nfrom fastapi import Request\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\nfrom app.schemas.sche_base import ResponseSchemaBase\n\n\nclass ExceptionType(enum.Enum):\n    MS_UNAVAILABLE = 500, '990', 'Hệ thống đang bảo trì, quý khách vui lòng thử lại sau'\n    MS_INVALID_API_PATH = 500, '991', 'Hệ thống đang bảo trì, quý khách vui lòng thử lại sau'\n    DATA_RESPONSE_MALFORMED = 500, '992', 'Có lỗi xảy ra, vui lòng liên hệ admin!'\n\n    def __new__(cls, *args, **kwds):\n        value = len(cls.__members__) + 1\n        obj = object.__new__(cls)\n        obj._value_ = value\n        return obj\n\n    def __init__(self, http_code, code, message):\n        self.http_code = http_code\n        self.code = code\n        self.message = message\n\n\nclass CustomException(Exception):\n    http_code: int\n    code: str\n    message: str\n\n    def __init__(self, http_code: int = None, code: str = None, message: str = None):\n        self.http_code = http_code if http_code else 500\n        self.code = code if code else str(self.http_code)\n        self.message = message\n\n\nasync def http_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.http_code,\n        content=jsonable_encoder(ResponseSchemaBase().custom_response(exc.code, exc.message))\n    )\n\n\nasync def validation_exception_handler(request, exc):\n    return JSONResponse(\n        status_code=400,\n        content=jsonable_encoder(ResponseSchemaBase().custom_response('400', get_message_validation(exc)))\n    )\n\n\nasync def fastapi_error_handler(request, exc):\n    return JSONResponse(\n        status_code=500,\n        content=jsonable_encoder(ResponseSchemaBase().custom_response('500', \"Có lỗi xảy ra, vui lòng liên hệ admin!\"))\n    )\n\n\ndef get_message_validation(exc):\n    message = \"\"\n    for error in exc.errors():\n        message += \"/'\" + str(error.get(\"loc\")[1]) + \"'/\" + ': ' + error.get(\"msg\") + \", \"\n\n    message = message[:-2]\n\n    return message\n"}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/__init__.py", "content": ""}
{"type": "source_file", "path": "app/services/srv_user.py", "content": "import jwt\n\nfrom typing import Optional\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\nfrom fastapi_sqlalchemy import db\nfrom pydantic import ValidationError\nfrom starlette import status\n\nfrom app.models import User\nfrom app.core.config import settings\nfrom app.core.security import verify_password, get_password_hash\nfrom app.schemas.sche_token import TokenPayload\nfrom app.schemas.sche_user import UserCreateRequest, UserUpdateMeRequest, UserUpdateRequest, UserRegisterRequest\n\n\nclass UserService(object):\n    __instance = None\n\n    def __init__(self) -> None:\n        pass\n\n    reusable_oauth2 = HTTPBearer(\n        scheme_name='Authorization'\n    )\n\n    @staticmethod\n    def authenticate(*, email: str, password: str) -> Optional[User]:\n        \"\"\"\n        Check username and password is correct.\n        Return object User if correct, else return None\n        \"\"\"\n        user = db.session.query(User).filter_by(email=email).first()\n        if not user:\n            return None\n        if not verify_password(password, user.hashed_password):\n            return None\n        return user\n\n    @staticmethod\n    def get_current_user(http_authorization_credentials=Depends(reusable_oauth2)) -> User:\n        \"\"\"\n        Decode JWT token to get user_id => return User info from DB query\n        \"\"\"\n        try:\n            payload = jwt.decode(\n                http_authorization_credentials.credentials, settings.SECRET_KEY,\n                algorithms=[settings.SECURITY_ALGORITHM]\n            )\n            token_data = TokenPayload(**payload)\n        except (jwt.PyJWTError, ValidationError):\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Could not validate credentials\",\n            )\n        user = db.session.query(User).get(token_data.user_id)\n        if not user:\n            raise HTTPException(status_code=404, detail=\"User not found\")\n        return user\n\n    @staticmethod\n    def register_user(data: UserRegisterRequest):\n        exist_user = db.session.query(User).filter(User.email == data.email).first()\n        if exist_user:\n            raise Exception('Email already exists')\n        register_user = User(\n            full_name=data.full_name,\n            email=data.email,\n            hashed_password=get_password_hash(data.password),\n            is_active=True,\n            role=data.role.value,\n        )\n        db.session.add(register_user)\n        db.session.commit()\n        return register_user\n\n    @staticmethod\n    def create_user(data: UserCreateRequest):\n        exist_user = db.session.query(User).filter(User.email == data.email).first()\n        if exist_user:\n            raise Exception('Email already exists')\n        new_user = User(\n            full_name=data.full_name,\n            email=data.email,\n            hashed_password=get_password_hash(data.password),\n            is_active=data.is_active,\n            role=data.role.value,\n        )\n        db.session.add(new_user)\n        db.session.commit()\n        return new_user\n\n    @staticmethod\n    def update_me(data: UserUpdateMeRequest, current_user: User):\n        if data.email is not None:\n            exist_user = db.session.query(User).filter(\n                User.email == data.email, User.id != current_user.id).first()\n            if exist_user:\n                raise Exception('Email already exists')\n        current_user.full_name = current_user.full_name if data.full_name is None else data.full_name\n        current_user.email = current_user.email if data.email is None else data.email\n        current_user.hashed_password = current_user.hashed_password if data.password is None else get_password_hash(\n            data.password)\n        db.session.commit()\n        return current_user\n\n    @staticmethod\n    def update(user_id: int, data: UserUpdateRequest):\n        user = db.session.query(User).get(user_id)\n        if user is None:\n            raise Exception('User not exists')\n        user.full_name = user.full_name if data.full_name is None else data.full_name\n        user.email = user.email if data.email is None else data.email\n        user.hashed_password = user.hashed_password if data.password is None else get_password_hash(\n            data.password)\n        user.is_active = user.is_active if data.is_active is None else data.is_active\n        user.role = user.role if data.role is None else data.role.value\n        db.session.commit()\n        return user\n\n    @staticmethod\n    def get(user_id):\n        exist_user = db.session.query(User).get(user_id)\n        if exist_user is None:\n            raise Exception('User not exists')\n        return exist_user\n"}
{"type": "source_file", "path": "app/api/api_healthcheck.py", "content": "from fastapi import APIRouter\n\nfrom app.schemas.sche_base import ResponseSchemaBase\n\nrouter = APIRouter()\n\n\n@router.get(\"\", response_model=ResponseSchemaBase)\nasync def get():\n    return {\"message\": \"Health check success\"}"}
{"type": "source_file", "path": "app/core/__init__.py", "content": ""}
{"type": "source_file", "path": "app/helpers/paging.py", "content": "import logging\nfrom pydantic import BaseModel, conint\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, Generic, Sequence, Type, TypeVar\n\nfrom sqlalchemy import asc, desc\nfrom sqlalchemy.orm import Query\nfrom pydantic.generics import GenericModel\nfrom contextvars import ContextVar\n\nfrom app.schemas.sche_base import ResponseSchemaBase, MetadataSchema\nfrom app.helpers.exception_handler import CustomException\n\nT = TypeVar(\"T\")\nC = TypeVar(\"C\")\n\nlogger = logging.getLogger()\n\n\nclass PaginationParams(BaseModel):\n    page_size: Optional[conint(gt=0, lt=1001)] = 10\n    page: Optional[conint(gt=0)] = 1\n    sort_by: Optional[str] = 'id'\n    order: Optional[str] = 'desc'\n\n\nclass BasePage(ResponseSchemaBase, GenericModel, Generic[T], ABC):\n    data: Sequence[T]\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    @classmethod\n    @abstractmethod\n    def create(cls: Type[C], code: str, message: str, data: Sequence[T], metadata: MetadataSchema) -> C:\n        pass  # pragma: no cover\n\n\nclass Page(BasePage[T], Generic[T]):\n    metadata: MetadataSchema\n\n    @classmethod\n    def create(cls, code: str, message: str, data: Sequence[T], metadata: MetadataSchema) -> \"Page[T]\":\n        return cls(\n            code=code,\n            message=message,\n            data=data,\n            metadata=metadata\n        )\n\n\nPageType: ContextVar[Type[BasePage]] = ContextVar(\"PageType\", default=Page)\n\n\ndef paginate(model, query: Query, params: Optional[PaginationParams]) -> BasePage:\n    code = '200'\n    message = 'Success'\n\n    try:\n        total = query.count()\n\n        if params.order:\n            direction = desc if params.order == 'desc' else asc\n            query = query.order_by(direction(getattr(model, params.sort_by)))\n\n        data = query.limit(params.page_size).offset(params.page_size * (params.page-1)).all()\n\n        metadata = MetadataSchema(\n            current_page=params.page,\n            page_size=params.page_size,\n            total_items=total\n        )\n\n    except Exception as e:\n        raise CustomException(http_code=500, code='500', message=str(e))\n\n    return PageType.get().create(code, message, data, metadata)\n"}
{"type": "source_file", "path": "app/schemas/sche_user.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, EmailStr\n\nfrom app.helpers.enums import UserRole\n\n\nclass UserBase(BaseModel):\n    full_name: Optional[str] = None\n    email: Optional[EmailStr] = None\n    is_active: Optional[bool] = True\n\n    class Config:\n        orm_mode = True\n\n\nclass UserItemResponse(UserBase):\n    id: int\n    full_name: str\n    email: EmailStr\n    is_active: bool\n    role: str\n    last_login: Optional[datetime]\n\n\nclass UserCreateRequest(UserBase):\n    full_name: Optional[str]\n    password: str\n    email: EmailStr\n    is_active: bool = True\n    role: UserRole = UserRole.GUEST\n\n\nclass UserRegisterRequest(BaseModel):\n    full_name: str\n    email: EmailStr\n    password: str\n    role: UserRole = UserRole.GUEST\n\n\nclass UserUpdateMeRequest(BaseModel):\n    full_name: Optional[str]\n    email: Optional[EmailStr]\n    password: Optional[str]\n\n\nclass UserUpdateRequest(BaseModel):\n    full_name: Optional[str]\n    email: Optional[EmailStr]\n    password: Optional[str]\n    is_active: Optional[bool] = True\n    role: Optional[UserRole]\n"}
{"type": "source_file", "path": "app/api/api_login.py", "content": "from datetime import datetime\n\nfrom fastapi import APIRouter, HTTPException, Depends\nfrom fastapi_sqlalchemy import db\nfrom pydantic import EmailStr, BaseModel\n\nfrom app.core.security import create_access_token\nfrom app.schemas.sche_base import DataResponse\nfrom app.schemas.sche_token import Token\nfrom app.services.srv_user import UserService\n\nrouter = APIRouter()\n\n\nclass LoginRequest(BaseModel):\n    username: EmailStr = 'long.dh@teko.vn'\n    password: str = 'secret123'\n\n\n@router.post('', response_model=DataResponse[Token])\ndef login_access_token(form_data: LoginRequest, user_service: UserService = Depends()):\n    user = user_service.authenticate(email=form_data.username, password=form_data.password)\n    if not user:\n        raise HTTPException(status_code=400, detail='Incorrect email or password')\n    elif not user.is_active:\n        raise HTTPException(status_code=401, detail='Inactive user')\n\n    user.last_login = datetime.now()\n    db.session.commit()\n\n    return DataResponse().success_response({\n        'access_token': create_access_token(user_id=user.id)\n    })\n"}
{"type": "source_file", "path": "app/core/security.py", "content": "import jwt\n\nfrom typing import Any, Union\nfrom app.core.config import settings\nfrom datetime import datetime, timedelta\nfrom passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef create_access_token(user_id: Union[int, Any]) -> str:\n    expire = datetime.utcnow() + timedelta(\n        seconds=settings.ACCESS_TOKEN_EXPIRE_SECONDS\n    )\n    to_encode = {\n        \"exp\": expire, \"user_id\": str(user_id)\n    }\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.SECURITY_ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n"}
{"type": "source_file", "path": "app/core/config.py", "content": "import os\nfrom dotenv import load_dotenv\nfrom pydantic import BaseSettings\n\nBASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../'))\nload_dotenv(os.path.join(BASE_DIR, '.env'))\n\n\nclass Settings(BaseSettings):\n    PROJECT_NAME = os.getenv('PROJECT_NAME', 'FASTAPI BASE')\n    SECRET_KEY = os.getenv('SECRET_KEY', '')\n    API_PREFIX = ''\n    BACKEND_CORS_ORIGINS = ['*']\n    DATABASE_URL = os.getenv('SQL_DATABASE_URL', '')\n    ACCESS_TOKEN_EXPIRE_SECONDS: int = 60 * 60 * 24 * 7  # Token expired after 7 days\n    SECURITY_ALGORITHM = 'HS256'\n    LOGGING_CONFIG_FILE = os.path.join(BASE_DIR, 'logging.ini')\n\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "app/db/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/api_router.py", "content": "from fastapi import APIRouter\n\nfrom app.api import api_user, api_login, api_register, api_healthcheck\n\nrouter = APIRouter()\n\nrouter.include_router(api_healthcheck.router, tags=[\"health-check\"], prefix=\"/healthcheck\")\nrouter.include_router(api_login.router, tags=[\"login\"], prefix=\"/login\")\nrouter.include_router(api_register.router, tags=[\"register\"], prefix=\"/register\")\nrouter.include_router(api_user.router, tags=[\"user\"], prefix=\"/users\")\n"}
{"type": "source_file", "path": "alembic/versions/f9a075ca46e9_.py", "content": "\"\"\"empty message\n\nRevision ID: f9a075ca46e9\nRevises: \nCreate Date: 2021-03-26 16:00:56.723890\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = 'f9a075ca46e9'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('user',\n    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),\n    sa.Column('created_at', sa.DateTime(), nullable=True),\n    sa.Column('updated_at', sa.DateTime(), nullable=True),\n    sa.Column('full_name', sa.String(), nullable=True),\n    sa.Column('email', sa.String(), nullable=True),\n    sa.Column('hashed_password', sa.String(length=255), nullable=True),\n    sa.Column('is_active', sa.Boolean(), nullable=True),\n    sa.Column('role', sa.String(), nullable=True),\n    sa.Column('last_login', sa.DateTime(), nullable=True),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index(op.f('ix_user_email'), 'user', ['email'], unique=True)\n    op.create_index(op.f('ix_user_full_name'), 'user', ['full_name'], unique=False)\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f('ix_user_full_name'), table_name='user')\n    op.drop_index(op.f('ix_user_email'), table_name='user')\n    op.drop_table('user')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "app/main.py", "content": "import logging\n\nimport uvicorn\nfrom fastapi import FastAPI\nfrom fastapi_sqlalchemy import DBSessionMiddleware\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom app.api.api_router import router\nfrom app.models import Base\nfrom app.db.base import engine\nfrom app.core.config import settings\nfrom app.helpers.exception_handler import CustomException, http_exception_handler\n\nlogging.config.fileConfig(settings.LOGGING_CONFIG_FILE, disable_existing_loggers=False)\nBase.metadata.create_all(bind=engine)\n\n\ndef get_application() -> FastAPI:\n    application = FastAPI(\n        title=settings.PROJECT_NAME, docs_url=\"/docs\", redoc_url='/re-docs',\n        openapi_url=f\"{settings.API_PREFIX}/openapi.json\",\n        description='''\n        Base frame with FastAPI micro framework + Postgresql\n            - Login/Register with JWT\n            - Permission\n            - CRUD User\n            - Unit testing with Pytest\n            - Dockerize\n        '''\n    )\n    application.add_middleware(\n        CORSMiddleware,\n        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    application.add_middleware(DBSessionMiddleware, db_url=settings.DATABASE_URL)\n    application.include_router(router, prefix=settings.API_PREFIX)\n    application.add_exception_handler(CustomException, http_exception_handler)\n\n    return application\n\n\napp = get_application()\nif __name__ == '__main__':\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"}
{"type": "source_file", "path": "app/db/base.py", "content": "from typing import Generator\nfrom app.core.config import settings\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nengine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\ndef get_db() -> Generator:\n    try:\n        db = SessionLocal()\n        yield db\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "alembic/env.py", "content": "import os\nimport sys\nfrom logging.config import fileConfig\n\nfrom dotenv import load_dotenv\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nfrom alembic import context\n\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nload_dotenv(os.path.join(BASE_DIR, \".env\"))\nsys.path.append(BASE_DIR)\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\nconfig.set_main_option(\"sqlalchemy.url\", os.environ[\"SQL_DATABASE_URL\"])\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\nfrom app.models import Base\n\ntarget_metadata = Base.metadata\n\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\", os.environ[\"SQL_DATABASE_URL\"])\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "app/models/model_base.py", "content": "from datetime import datetime\n\nfrom sqlalchemy import Column, Integer, DateTime\nfrom sqlalchemy.ext.declarative import as_declarative, declared_attr\n\n\n@as_declarative()\nclass Base:\n    __abstract__ = True\n    __name__: str\n\n    # Generate __tablename__ automatically\n    @declared_attr\n    def __tablename__(cls) -> str:\n        return cls.__name__.lower()\n\n\nclass BareBaseModel(Base):\n    __abstract__ = True\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    created_at = Column(DateTime, default=datetime.now)\n    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)\n"}
{"type": "source_file", "path": "app/api/api_register.py", "content": "from typing import Any\n\nfrom fastapi import APIRouter, Depends\n\nfrom app.helpers.exception_handler import CustomException\nfrom app.schemas.sche_base import DataResponse\nfrom app.schemas.sche_user import UserItemResponse, UserRegisterRequest\nfrom app.services.srv_user import UserService\n\nrouter = APIRouter()\n\n\n@router.post('', response_model=DataResponse[UserItemResponse])\ndef register(register_data: UserRegisterRequest, user_service: UserService = Depends()) -> Any:\n    try:\n        register_user = user_service.register_user(register_data)\n        return DataResponse().success_response(data=register_user)\n    except Exception as e:\n        raise CustomException(http_code=400, code='400', message=str(e))\n"}
{"type": "source_file", "path": "app/helpers/enums.py", "content": "import enum\n\n\nclass UserRole(enum.Enum):\n    ADMIN = 'admin'\n    GUEST = 'guest'\n"}
{"type": "source_file", "path": "app/models/model_user.py", "content": "from sqlalchemy import Column, String, Boolean, DateTime\n\nfrom app.models.model_base import BareBaseModel\n\n\nclass User(BareBaseModel):\n    full_name = Column(String, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String(255))\n    is_active = Column(Boolean, default=True)\n    role = Column(String, default='guest')\n    last_login = Column(DateTime)\n"}

{"repo_info": {"repo_name": "Proteus-The-Genesis-LLM", "repo_owner": "severian42", "repo_url": "https://github.com/severian42/Proteus-The-Genesis-LLM"}}
{"type": "source_file", "path": "genesis_sandbox_executor.py", "content": "import re\nfrom typing import Tuple, List, Dict, Any\nimport tempfile\nimport json\nimport logging\nimport traceback\nfrom pathlib import Path\nimport genesis as gs\nfrom fastapi import HTTPException\nfrom datetime import datetime, timedelta\nimport numpy as np\n\nlogger = logging.getLogger(__name__)\n\nclass GenesisSandboxExecutor:\n    \"\"\"Safe execution environment for Genesis physics code\"\"\"\n    \n    ALLOWED_IMPORTS = {\n        'genesis': gs,\n        'numpy': 'np',\n        'math': 'math'\n    }\n    \n    ALLOWED_OPERATIONS = {\n        'add_entity',\n        'remove_entity',\n        'get_state',\n        'step',\n        'build',\n        'add_camera',\n        'render'\n    }\n\n    def __init__(self):\n        self.local_namespace = {}\n        self.local_namespace['gs'] = gs\n        self.local_namespace['scene'] = None\n        self.local_namespace['math'] = __import__('math')\n        self.local_namespace['np'] = np\n        \n        for module, alias in self.ALLOWED_IMPORTS.items():\n            if isinstance(alias, str):\n                exec(f\"import {module} as {alias}\", self.local_namespace)\n            else:\n                self.local_namespace[module] = alias\n        \n        self.execution_history = []\n        self.max_executions_per_minute = 60\n        self.max_code_length = 10000\n        \n        # Add Genesis-specific helpers using proper types\n        self.local_namespace['get_time'] = lambda: self.local_namespace['scene'].get_state().t\n        # Use tuple for vectors\n        self.local_namespace['vec3'] = lambda x, y, z: np.array([x, y, z], dtype=np.float32)\n        self.local_namespace['vec2'] = lambda x, y: np.array([x, y], dtype=np.float32)\n        \n        # Add helper functions\n        self.local_namespace['create_fluid_particles'] = self._create_fluid_particles\n        self.local_namespace['create_spring_mass'] = self._create_spring_mass\n        self.local_namespace['create_wave_sources'] = self._create_wave_sources\n        \n    def _check_rate_limit(self):\n        \"\"\"Check if we've exceeded rate limits\"\"\"\n        now = datetime.now()\n        cutoff = now - timedelta(minutes=1)\n        \n        # Clean old history\n        self.execution_history = [t for t in self.execution_history if t > cutoff]\n        \n        if len(self.execution_history) >= self.max_executions_per_minute:\n            raise HTTPException(status_code=429, detail=\"Rate limit exceeded\")\n        \n        self.execution_history.append(now)\n\n    def extract_genesis_code(self, text: str) -> List[str]:\n        \"\"\"Extract Genesis code blocks from text.\"\"\"\n        pattern = r'```genesis\\s*(.*?)\\s*```'\n        return re.findall(pattern, text, re.DOTALL)\n\n    def validate_code(self, code: str) -> bool:\n        \"\"\"Validate Genesis code for safety.\"\"\"\n        # Check for forbidden imports and dangerous operations\n        dangerous_patterns = [\n            r'import\\s+(?!genesis|numpy|math)',  # Only allow specific imports\n            r'open\\(',  # No file operations\n            r'os\\.',   # No OS operations\n            r'system\\(',  # No system calls\n            r'eval\\(',  # No eval\n            r'exec\\(',  # No exec\n            r'subprocess', # No subprocess\n            r'__import__', # No dynamic imports\n        ]\n        \n        for pattern in dangerous_patterns:\n            if re.search(pattern, code.lower()):\n                logger.warning(f\"Dangerous pattern found: {pattern}\")\n                return False\n            \n        # Allow common Genesis operations with more permissive patterns\n        allowed_patterns = [\n            # Scene operations\n            r'scene\\.(add_entity|step|apply_force|get_time|get_state)',\n            \n            # Genesis objects and methods\n            r'gs\\.(morphs|materials|vec3|vec2|pi|sin|cos|options)',\n            r'gs\\.morphs\\.(Sphere|Box|Plane|Mesh|MJCF)',\n            r'gs\\.materials\\.(Rigid|Fluid|SPH|MPM|PBD)',\n            r'gs\\.surfaces\\.(Default|Glass|Metal)',\n            \n            # Math operations\n            r'math\\.(sin|cos|pi|sqrt|pow)',\n            r'numpy\\.(sin|cos|pi|array|zeros|ones)',\n            \n            # Control structures\n            r'for\\s+.*\\s+in\\s+range',\n            r'if\\s+.*:',\n            r'else:',\n            r'elif\\s+.*:',\n            r'while\\s+.*:',\n            \n            # Variable assignments and property access\n            r'\\w+\\s*=\\s*.*',  # More permissive assignment pattern\n            r'\\w+\\.(pos|radius|material|density|size|scale|color|surface|fixed)',\n            r'\\w+\\s*:\\s*.*',  # Allow dict/parameter specifications\n            \n            # Function calls and parameters\n            r'\\w+\\([^)]*\\)',  # General function calls\n            r'vec[23]\\([^)]*\\)',  # Vector constructors\n            \n            # Comments\n            r'#.*$',\n        ]\n        \n        # Split code into lines and check each non-empty line\n        lines = [line.strip() for line in code.split('\\n') if line.strip()]\n        for line in lines:\n            # Skip comments\n            if line.startswith('#'):\n                continue\n            \n            # Check if line matches any allowed pattern\n            if not any(re.search(pattern, line) for pattern in allowed_patterns):\n                # More permissive fallback check for basic operations\n                if re.match(r'^[\\w\\s\\(\\)\\[\\]\\{\\},\\.:=\\+\\-\\*/]*$', line):\n                    continue\n                logger.debug(f\"Line failed validation: {line}\")  # Changed to debug level\n                return False\n        \n        return True\n\n    def preprocess_code(self, code: str) -> str:\n        \"\"\"Fix common LLM code generation issues\"\"\"\n        def fix_indentation(code_str: str) -> str:\n            \"\"\"Fix indentation while preserving code structure\"\"\"\n            lines = code_str.split('\\n')\n            fixed_lines = []\n            indent_level = 0\n            in_parentheses = 0  # Track nested parentheses\n            \n            for line in lines:\n                stripped = line.strip()\n                if not stripped or stripped.startswith('#'):\n                    continue\n                \n                # Track parentheses nesting\n                in_parentheses += stripped.count('(') - stripped.count(')')\n                \n                # Handle control structures\n                if any(stripped.startswith(keyword) for keyword in ['for', 'if', 'while', 'def', 'class']):\n                    fixed_lines.append('    ' * indent_level + stripped)\n                    if stripped.endswith(':'):\n                        indent_level += 1\n                elif stripped.startswith(('elif', 'else:', 'except:', 'finally:')):\n                    indent_level = max(0, indent_level - 1)\n                    fixed_lines.append('    ' * indent_level + stripped)\n                    if stripped.endswith(':'):\n                        indent_level += 1\n                else:\n                    # Handle multi-line statements\n                    if in_parentheses > 0:\n                        # Inside parentheses - maintain indentation\n                        fixed_lines.append('    ' * (indent_level + 1) + stripped)\n                    else:\n                        # Normal line\n                        fixed_lines.append('    ' * indent_level + stripped)\n                    \n                    # Adjust indentation after block ends\n                    if stripped.startswith(('return', 'break', 'continue', 'pass')):\n                        indent_level = max(0, indent_level - 1)\n                \n            return '\\n'.join(fixed_lines)\n        \n        # Remove scene creation if present\n        code = re.sub(r'scene\\s*=\\s*Scene\\(\\)', '', code)\n        code = re.sub(r'scene\\s*=\\s*gs\\.Scene\\(\\)', '', code)\n        \n        # Fix morphs references\n        code = re.sub(r'(?<!gs\\.morphs\\.)Sphere\\(', 'gs.morphs.Sphere(', code)\n        code = re.sub(r'(?<!gs\\.morphs\\.)Box\\(', 'gs.morphs.Box(', code)\n        code = re.sub(r'(?<!gs\\.morphs\\.)Plane\\(', 'gs.morphs.Plane(', code)\n        \n        # Fix materials references\n        code = re.sub(r'(?<!gs\\.materials\\.)Fluid\\(', 'gs.materials.Fluid(', code)\n        code = re.sub(r'(?<!gs\\.materials\\.)Rigid\\(', 'gs.materials.Rigid(', code)\n        code = re.sub(r'(?<!gs\\.materials\\.SPH\\.)Liquid\\(', 'gs.materials.SPH.Liquid(', code)\n        \n        # Fix vector creation\n        code = re.sub(r'gs\\.vec3\\(', 'vec3(', code)\n        code = re.sub(r'gs\\.vec2\\(', 'vec2(', code)\n        code = re.sub(r'(?<!vec)3\\(([^)]+)\\)', r'vec3(\\1)', code)\n        \n        # Apply indentation fixing\n        code = fix_indentation(code)\n        \n        return code\n\n    def execute_genesis_code(self, code: str) -> Dict[str, Any]:\n        \"\"\"Execute Genesis code in a sandboxed environment with retries.\"\"\"\n        max_retries = 3\n        attempt = 0\n        last_error = None\n\n        while attempt < max_retries:\n            try:\n                attempt += 1\n                logger.info(f\"Attempt {attempt} of {max_retries}\")\n\n                # Preprocess code first\n                processed_code = self.preprocess_code(code)\n                logger.debug(f\"Preprocessed code:\\n{processed_code}\")\n                \n                # Validate code with better error reporting\n                if not self.validate_code(processed_code):\n                    last_error = \"Code validation failed - Invalid syntax or unsafe operations\"\n                    logger.warning(f\"Attempt {attempt}: {last_error}\")\n                    logger.debug(f\"Failed code:\\n{processed_code}\")\n                    if attempt == max_retries:\n                        return {\"error\": last_error, \"code\": processed_code}\n                    continue\n\n                if len(processed_code) > self.max_code_length:\n                    return {\"error\": \"Code exceeds maximum length\"}\n                \n                self._check_rate_limit()\n                \n                # Get current scene from LLMPhysicsSandbox\n                if hasattr(self, 'sandbox'):\n                    self.local_namespace['scene'] = self.sandbox.scene\n                \n                # Execute the code with proper error handling\n                try:\n                    # Properly indent the code for the try block\n                    indented_code = '\\n'.join(f\"    {line}\" for line in processed_code.split('\\n') if line.strip())\n                    wrapped_code = f\"\"\"\ntry:\n{indented_code}\nexcept Exception as e:\n    print(f\"Runtime error: {{str(e)}}\")\n    raise\n\"\"\"\n                    logger.debug(f\"Wrapped code:\\n{wrapped_code}\")\n                    exec(wrapped_code, self.local_namespace)\n                    \n                    # Get scene state after execution\n                    state = self.local_namespace['scene'].get_state() if self.local_namespace['scene'] else {}\n                    \n                    return {\n                        \"status\": \"success\",\n                        \"state\": state,\n                        \"output\": \"Code executed successfully\",\n                        \"attempts\": attempt\n                    }\n                    \n                except (IndentationError, SyntaxError) as e:\n                    last_error = f\"Code formatting error: {str(e)}\"\n                    logger.warning(f\"Attempt {attempt}: {last_error}\")\n                    # Try to fix common formatting issues\n                    code = self._fix_common_errors(code, str(e))\n                    continue\n                    \n                except Exception as e:\n                    last_error = f\"Runtime error: {str(e)}\"\n                    logger.warning(f\"Attempt {attempt}: {last_error}\")\n                    if attempt == max_retries:\n                        return {\n                            \"status\": \"error\",\n                            \"error\": last_error,\n                            \"traceback\": traceback.format_exc()\n                        }\n                    continue\n                    \n            except Exception as e:\n                last_error = str(e)\n                logger.warning(f\"Attempt {attempt}: {last_error}\")\n                logger.debug(f\"Failed code:\\n{code}\")\n                if attempt == max_retries:\n                    return {\n                        \"error\": str(e),\n                        \"code\": code,\n                        \"traceback\": traceback.format_exc()\n                    }\n                continue\n        \n        # If we get here, all retries failed\n        return {\n            \"error\": f\"Failed to execute code after {max_retries} attempts\",\n            \"last_error\": last_error,\n            \"code\": code\n        }\n\n    def _fix_common_errors(self, code: str, error_msg: str) -> str:\n        \"\"\"Attempt to fix common code errors based on error message\"\"\"\n        # Fix indentation errors\n        if \"IndentationError\" in error_msg:\n            lines = code.split('\\n')\n            fixed_lines = []\n            current_indent = 0\n            \n            for line in lines:\n                stripped = line.strip()\n                if not stripped:\n                    continue\n                    \n                # Adjust indent for control structures\n                if any(stripped.startswith(word) for word in ['if', 'for', 'while', 'def', 'class']):\n                    fixed_lines.append('    ' * current_indent + stripped)\n                    if stripped.endswith(':'):\n                        current_indent += 1\n                elif stripped.startswith(('elif', 'else:', 'except:', 'finally:')):\n                    current_indent = max(0, current_indent - 1)\n                    fixed_lines.append('    ' * current_indent + stripped)\n                    if stripped.endswith(':'):\n                        current_indent += 1\n                else:\n                    fixed_lines.append('    ' * current_indent + stripped)\n                    \n            return '\\n'.join(fixed_lines)\n            \n        # Fix syntax errors\n        if \"SyntaxError\" in error_msg:\n            # Fix missing parentheses\n            if \"EOF while scanning\" in error_msg:\n                return code + '\\n)'\n            # Fix missing colons\n            if \"expected ':'\" in error_msg:\n                return code.replace('\\n', ':\\n', 1)\n                \n        return code\n\n    def enforce_genesis_usage(self, response: Dict) -> Dict:\n        \"\"\"Ensure response includes Genesis physics code\"\"\"\n        content = response.get('choices', [{}])[0].get('message', {}).get('content', '')\n        \n        if '```genesis' not in content:\n            logger.warning(\"Response missing Genesis code block - enforcing usage\")\n            # Add Genesis code section\n            physics_code = self._generate_default_physics_code()\n            content = content.replace(\n                \"</planning>\",\n                f\"</planning>\\n\\n<simulation>\\n```genesis\\n{physics_code}\\n```\\n</simulation>\"\n            )\n            response['choices'][0]['message']['content'] = content\n            \n        return response\n        \n    def _generate_default_physics_code(self) -> str:\n        \"\"\"Generate default physics code based on context\"\"\"\n        return \"\"\"\n        # Create basic physics demonstration\n        sphere = scene.add_entity(\n            gs.morphs.Sphere(pos=(0, 0, 1), radius=0.2),\n            material=gs.materials.Rigid(),\n            density=1.0\n        )\n        \n        # Run simulation\n        for _ in range(50):\n            scene.step()\n        \"\"\"\n\n    def _create_fluid_particles(self, bounds, spacing, properties):\n        \"\"\"Helper to create fluid particle grid\"\"\"\n        particles = []\n        for x in range(bounds[0], bounds[1], spacing):\n            for y in range(bounds[2], bounds[3], spacing):\n                for z in range(bounds[4], bounds[5], spacing):\n                    pos = np.array([x, y, z], dtype=np.float32)\n                    particle = self.local_namespace['scene'].add_entity(\n                        gs.morphs.Sphere(\n                            pos=pos,\n                            radius=properties.get('radius', 0.05)\n                        ),\n                        material=gs.materials.Fluid(\n                            mu=properties.get('mu', 0.01),\n                            bulk_modulus=properties.get('bulk_modulus', 1.0)\n                        ),\n                        density=properties.get('density', 1.0)\n                    )\n                    particles.append(particle)\n        return particles\n\n    def _create_spring_mass(self, anchor_pos, mass_pos, properties):\n        \"\"\"Helper to create spring-mass system\"\"\"\n        # Create anchor\n        anchor = self.local_namespace['scene'].add_entity(\n            gs.morphs.Sphere(\n                pos=anchor_pos,\n                radius=properties.get('anchor_radius', 0.1)\n            ),\n            material=gs.materials.Rigid(),\n            density=properties.get('anchor_density', 1.0),\n            fixed=True\n        )\n        \n        # Create mass\n        mass = self.local_namespace['scene'].add_entity(\n            gs.morphs.Sphere(\n                pos=mass_pos,\n                radius=properties.get('mass_radius', 0.2)\n            ),\n            material=gs.materials.Rigid(),\n            density=properties.get('mass_density', 2.0)\n        )\n        \n        # Add spring constraint\n        spring = self.local_namespace['scene'].add_constraint(\n            \"spring\",\n            anchor, mass,\n            stiffness=properties.get('stiffness', 100.0),\n            damping=properties.get('damping', 1.0),\n            rest_length=properties.get('rest_length', 1.0)\n        )\n        \n        return anchor, mass, spring\n\n    def _create_wave_sources(self, positions, properties):\n        \"\"\"Helper to create wave sources\"\"\"\n        sources = []\n        for pos in positions:\n            source = self.local_namespace['scene'].add_entity(\n                gs.morphs.Sphere(\n                    pos=pos,\n                    radius=properties.get('radius', 0.1)\n                ),\n                material=gs.materials.Fluid(\n                    mu=properties.get('mu', 0.1),\n                    bulk_modulus=properties.get('bulk_modulus', 1.0)\n                ),\n                density=properties.get('density', 1.0)\n            )\n            sources.append(source)\n        return sources\n\n    def _create_observation_plane(self, pos, size, properties):\n        \"\"\"Helper to create observation plane\"\"\"\n        return self.local_namespace['scene'].add_entity(\n            gs.morphs.Plane(\n                pos=pos,\n                size=size\n            ),\n            material=gs.materials.Soft(\n                mu=properties.get('mu', 0.05)\n            ),\n            density=properties.get('density', 0.1)\n        )\n\n    def debug_code_validation(self, code: str) -> None:\n        \"\"\"Debug helper to test code validation patterns\"\"\"\n        logger.debug(\"Testing code validation patterns...\")\n        \n        processed_code = self.preprocess_code(code)\n        logger.debug(f\"Preprocessed code:\\n{processed_code}\")\n        \n        lines = [line.strip() for line in processed_code.split('\\n') if line.strip()]\n        for line in lines:\n            if line.startswith('#'):\n                continue\n            \n            logger.debug(f\"\\nTesting line: {line}\")\n            for pattern in self.allowed_patterns:\n                match = re.search(pattern, line)\n                if match:\n                    logger.debug(f\"  Matched pattern: {pattern}\")\n\nclass PhysicsReasoningExecutor:\n    def __init__(self, sandbox):\n        self.sandbox = sandbox\n        self.execution_history = []\n        self.genesis_executor = GenesisSandboxExecutor()\n        self.genesis_executor.sandbox = sandbox\n        \n    def _extract_genesis_code(self, content: str) -> str:\n        \"\"\"Extract Genesis code from content\"\"\"\n        pattern = r'```genesis\\s*(.*?)\\s*```'\n        matches = re.findall(pattern, content, re.DOTALL)\n        return matches[0] if matches else \"\"\n        \n    def _parse_reasoning_steps(self, response: str) -> List[Dict[str, str]]:\n        \"\"\"Parse reasoning steps from LLM response\"\"\"\n        steps = []\n        sections = [\n            \"planning\",\n            \"simulation\",\n            \"observation\",\n            \"reflection\",\n            \"answer\"\n        ]\n        \n        for section in sections:\n            pattern = f\"<{section}>(.*?)</{section}>\"\n            match = re.search(pattern, response, re.DOTALL)\n            if match:\n                steps.append({\n                    \"type\": section,\n                    \"content\": match.group(1).strip()\n                })\n                \n        return steps\n        \n    def execute_reasoning_step(self, step_type: str, content: str) -> Dict:\n        \"\"\"Execute a single reasoning step\"\"\"\n        if step_type == \"simulation\":\n            # Extract and run Genesis code\n            code = self._extract_genesis_code(content)\n            return self.genesis_executor.execute_genesis_code(code)\n            \n        elif step_type == \"observation\":\n            # Get current physics state\n            return {\n                \"object_states\": self.sandbox.get_object_states(),\n                \"measurements\": self.sandbox.get_measurements()\n            }\n            \n        return {\"status\": \"success\", \"step\": step_type}\n        \n    def run_reasoning_cycle(self, prompt: str, context: Dict = None) -> Dict:\n        \"\"\"Run full physics reasoning cycle\"\"\"\n        try:\n            # Stage 1: Understanding\n            understanding = self._get_physics_understanding(prompt, context)\n            logger.info(\"\\n=== Physics Understanding ===\\n%s\", understanding.get('choices', [{}])[0].get('message', {}).get('content', ''))\n            if \"error\" in understanding:\n                return understanding\n\n            # Stage 2: Planning\n            plan = self._create_physics_plan(understanding.get('choices', [{}])[0].get('message', {}).get('content', ''), context)\n            logger.info(\"\\n=== Physics Plan ===\\n%s\", plan.get('choices', [{}])[0].get('message', {}).get('content', ''))\n            if \"error\" in plan:\n                return plan\n\n            # Stage 3: Simulation\n            simulation = self._run_physics_simulation(plan.get('choices', [{}])[0].get('message', {}).get('content', ''), context)\n            logger.info(\"\\n=== Physics Simulation ===\\n%s\", simulation.get('choices', [{}])[0].get('message', {}).get('content', ''))\n            if \"error\" in simulation:\n                return simulation\n\n            # Stage 4: Observation\n            observation = self._make_physics_observations(simulation.get('choices', [{}])[0].get('message', {}).get('content', ''), context)\n            logger.info(\"\\n=== Physics Observations ===\\n%s\", observation.get('choices', [{}])[0].get('message', {}).get('content', ''))\n            if \"error\" in observation:\n                return observation\n\n            # Stage 5: Reflection\n            reflection = self._reflect_on_physics(observation.get('choices', [{}])[0].get('message', {}).get('content', ''), prompt, context)\n            logger.info(\"\\n=== Physics Reflection ===\\n%s\", reflection.get('choices', [{}])[0].get('message', {}).get('content', ''))\n            if \"error\" in reflection:\n                return reflection\n\n            # Extract content from responses\n            understanding_content = understanding.get('choices', [{}])[0].get('message', {}).get('content', '')\n            plan_content = plan.get('choices', [{}])[0].get('message', {}).get('content', '')\n            simulation_content = simulation.get('choices', [{}])[0].get('message', {}).get('content', '')\n            observation_content = observation.get('choices', [{}])[0].get('message', {}).get('content', '')\n            reflection_content = reflection.get('choices', [{}])[0].get('message', {}).get('content', '')\n\n            return {\n                \"status\": \"success\",\n                \"understanding\": understanding_content,\n                \"plan\": plan_content,\n                \"simulation\": simulation_content,\n                \"observation\": observation_content,\n                \"reflection\": reflection_content,\n                \"results\": [\n                    {\"type\": \"understanding\", \"content\": understanding_content},\n                    {\"type\": \"simulation\", \"content\": simulation_content},\n                    {\"type\": \"observation\", \"content\": observation_content},\n                    {\"type\": \"reflection\", \"content\": reflection_content}\n                ]\n            }\n\n        except Exception as e:\n            logger.error(f\"Error in physics reasoning cycle: {str(e)}\")\n            logger.error(traceback.format_exc())\n            return {\"error\": str(e)}\n\n    def _get_physics_understanding(self, prompt: str, context: Dict) -> Dict:\n        \"\"\"Get initial physics understanding\"\"\"\n        understanding_prompt = f\"\"\"Analyze this physics concept: \"{prompt}\"\n        \n        1. What are the key physical principles involved?\n        2. How can we demonstrate this in the physics room?\n        3. What measurements or observations would be meaningful?\n        \n        Explain your understanding and approach.\"\"\"\n        \n        return self.sandbox._query_llm_endpoint(understanding_prompt, context)\n\n    def _create_physics_plan(self, understanding: str, context: Dict) -> Dict:\n        \"\"\"Create plan for physics demonstration\"\"\"\n        if not understanding:\n            return {\"error\": \"No understanding provided\"}\n            \n        plan_prompt = f\"\"\"Based on this understanding:\n        {understanding}\n        \n        Create a detailed plan for demonstrating this concept:\n        1. What objects and configurations do we need?\n        2. What interactions should we observe?\n        3. What measurements will be important?\n        \n        Provide a step-by-step plan.\"\"\"\n        \n        return self.sandbox._query_llm_endpoint(plan_prompt, context)\n\n    def _run_physics_simulation(self, plan: str, context: Dict) -> Dict:\n        \"\"\"Generate and run physics simulation code\"\"\"\n        if not plan:\n            return {\"error\": \"No plan provided\"}\n            \n        simulation_prompt = f\"\"\"Based on this plan:\n        {plan}\n        \n        Generate Genesis physics code to implement this demonstration.\n        The code should:\n        1. Create a pendulum system\n        2. Add necessary measurements\n        3. Run the simulation\n        \n        Use proper Genesis syntax and include all necessary steps.\"\"\"\n        \n        return self.sandbox._query_llm_endpoint(simulation_prompt, context)\n\n    def _make_physics_observations(self, simulation: str, context: Dict) -> Dict:\n        \"\"\"Make observations about the physics simulation\"\"\"\n        if not simulation:\n            return {\"error\": \"No simulation provided\"}\n            \n        observation_prompt = f\"\"\"Based on the simulation:\n        {simulation}\n        \n        What physical phenomena did we observe?\n        What measurements or patterns were significant?\n        What insights did this provide?\"\"\"\n        \n        return self.sandbox._query_llm_endpoint(observation_prompt, context)\n\n    def _reflect_on_physics(self, observation: str, original_prompt: str, context: Dict) -> Dict:\n        \"\"\"Reflect on physics understanding gained\"\"\"\n        if not observation:\n            return {\"error\": \"No observations provided\"}\n            \n        reflection_prompt = f\"\"\"Given these observations:\n        {observation}\n        \n        And the original question: \"{original_prompt}\"\n        \n        1. How did this demonstration help us understand the concept?\n        2. What new insights did we gain?\n        3. How does this connect to broader physics principles?\n        \n        Provide a thoughtful reflection.\"\"\"\n        \n        return self.sandbox._query_llm_endpoint(reflection_prompt, context)"}
{"type": "source_file", "path": "config.py", "content": "import os\nimport platform\nfrom pathlib import Path\nfrom dotenv import load_dotenv\nfrom typing import Tuple\n\n# Load environment variables\nload_dotenv()\n\nclass Config:\n    # System detection\n    IS_APPLE_SILICON = (\n        platform.system() == \"Darwin\" and \n        platform.machine() == \"arm64\"\n    )\n    \n    @classmethod\n    def get_default_backend(cls):\n        \"\"\"Determine the best default backend based on system\"\"\"\n        if cls.IS_APPLE_SILICON:\n            return \"metal\"  # Default to Metal for Apple Silicon\n        try:\n            import torch\n            if torch.cuda.is_available():\n                return \"gpu\"\n        except:\n            pass\n        return \"cpu\"  # Fallback to CPU\n\n    # LLM Settings\n    OPENAI_MODEL_NAME = os.getenv(\"OPENAI_MODEL_NAME\", \"gemini-2.0-flash-exp\")\n    OPENAI_BASE_URL = os.getenv(\"OPENAI_BASE_URL\")\n    LLM_TEMPERATURE = float(os.getenv(\"LLM_TEMPERATURE\", \"0.5\"))\n    LLM_MAX_TOKENS = int(os.getenv(\"LLM_MAX_TOKENS\", \"8192\"))\n    OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')\n\n    @classmethod\n    def validate_config(cls):\n        if not cls.OPENAI_API_KEY:\n            raise ValueError(\"OPENAI_API_KEY must be set in .env file\")\n        if not cls.OPENAI_BASE_URL:\n            raise ValueError(\"OPENAI_BASE_URL must be set in .env file\")\n\n    # Genesis Settings\n    _backend = None\n    \n    @classmethod\n    def get_backend(cls):\n        if cls._backend is None:\n            backend = os.getenv(\"GENESIS_BACKEND\")\n            if backend is None:\n                backend = cls.get_default_backend()\n            cls._backend = cls.validate_backend(backend)\n        return cls._backend\n    \n    GENESIS_PRECISION = os.getenv(\"GENESIS_PRECISION\", \"32\")\n    GENESIS_LOGGING_LEVEL = os.getenv(\"GENESIS_LOGGING_LEVEL\", \"debug\")\n    GENESIS_ASSETS_PATH = Path(os.getenv(\"GENESIS_ASSETS_PATH\", \"./assets\"))\n\n    # Validation for backend\n    @classmethod\n    def validate_backend(cls, backend):\n        \"\"\"Validate and possibly adjust backend selection\"\"\"\n        backend = backend.lower()\n        \n        if cls.IS_APPLE_SILICON:\n            if backend == \"gpu\":\n                print(\"Warning: GPU backend selected on Apple Silicon. Switching to Metal...\")\n                return \"metal\"\n            if backend == \"metal\":\n                print(\"Warning: Metal backend selected on Apple Silicon. Switching to Metal...\")\n                return \"metal\"\n        elif backend == \"metal\":\n            if not cls.IS_APPLE_SILICON:\n                print(\"Warning: Metal backend selected on non-Apple Silicon. Switching to CPU...\")\n                return \"cpu\"\n            \n        if backend not in [\"cpu\", \"gpu\", \"metal\"]:\n            print(f\"Warning: Unknown backend '{backend}'. Falling back to CPU...\")\n            return \"cpu\"\n            \n        return backend\n\n    # Visualization Settings\n    VIS_CAMERA_RES = eval(os.getenv(\"VIS_CAMERA_RES\", \"(1280, 720)\"))\n    VIS_CAMERA_FOV = int(os.getenv(\"VIS_CAMERA_FOV\", \"60\"))\n    VIS_SHOW_WORLD_FRAME = os.getenv(\"VIS_SHOW_WORLD_FRAME\", \"true\").lower() == \"true\"\n    VIS_MAX_FPS = int(os.getenv(\"VIS_MAX_FPS\", \"60\"))\n\n    # Physics Settings\n    PHYSICS_GRAVITY = eval(os.getenv(\"PHYSICS_GRAVITY\", \"(0, 0, -9.8)\"))\n    PHYSICS_SUBSTEPS = int(os.getenv(\"PHYSICS_SUBSTEPS\", \"10\"))\n    PHYSICS_ROOM_BOUNDS = eval(os.getenv(\"PHYSICS_ROOM_BOUNDS\", \"(-5, -5, -5, 5, 5, 5)\"))\n\n    @classmethod\n    def get_room_bounds(cls) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]:\n        \"\"\"Returns room bounds as (lower_bound, upper_bound)\"\"\"\n        bounds = cls.PHYSICS_ROOM_BOUNDS\n        return (bounds[0], bounds[1], bounds[2]), (bounds[3], bounds[4], bounds[5])"}
{"type": "source_file", "path": "llm_physics_sandbox.py", "content": "import genesis as gs\nimport json\nimport requests\nimport numpy as np\nfrom typing import Dict, Any, List, Tuple\nimport re\nimport logging\nimport traceback\nfrom config import Config\nimport platform\nfrom genesis_sandbox_executor import GenesisSandboxExecutor\nfrom genesis_sandbox_executor import PhysicsReasoningExecutor\nimport time\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='[%(asctime)s] [%(levelname)s] %(message)s',\n    datefmt='%Y-%m-%d %H:%M:%S'\n)\nlogger = logging.getLogger(__name__)\n\nclass LLMPhysicsSandbox:\n    def __init__(self, visualize: bool = True):\n        logger.info(\"Initializing LLMPhysicsSandbox...\")\n        \n        # Initialize local namespace first\n        self.local_namespace = {}\n        \n        # Initialize executors\n        self.executor = GenesisSandboxExecutor()\n        self.physics_executor = PhysicsReasoningExecutor(self)  # Add physics reasoning executor\n        \n        # Give executors access to this sandbox instance\n        self.executor.sandbox = self\n        \n        # Initialize Genesis physics environment\n        gs.init(\n            backend=getattr(gs, Config.get_backend()),\n            precision=Config.GENESIS_PRECISION,\n            logging_level=Config.GENESIS_LOGGING_LEVEL\n        )\n        logger.debug(f\"Genesis initialized with backend: {Config.get_backend()}\")\n        \n        # Dictionary to track all objects in the scene\n        self.objects = {}\n        \n        # Available physics operations\n        self.available_operations = {\n            'create': self._create_object,\n            'move': self._move_object,\n            'apply_force': self._apply_force,\n            'delete': self._delete_object,\n            'modify': self._modify_object_properties,\n            'measure': self._measure_object,\n        }\n        logger.debug(f\"Available operations: {list(self.available_operations.keys())}\")\n\n        # Create scene with proper options\n        self.scene = gs.Scene(\n            sim_options=gs.options.SimOptions(\n                substeps=Config.PHYSICS_SUBSTEPS,\n                gravity=Config.PHYSICS_GRAVITY,\n            ),\n            viewer_options=gs.options.ViewerOptions(\n                camera_pos=(2, 2, 1.5),\n                camera_lookat=(0, 0, 0.5),\n                camera_up=(0, 0, 1),\n                res=Config.VIS_CAMERA_RES,\n                max_FPS=Config.VIS_MAX_FPS\n            ),\n            vis_options=gs.options.VisOptions(\n                show_world_frame=Config.VIS_SHOW_WORLD_FRAME\n            ),\n            show_viewer=visualize,\n        )\n        \n        # Add camera for visualization before building scene\n        self.camera = self.scene.add_camera(\n            res=(640, 480),\n            pos=(3, 3, 2),\n            lookat=(0, 0, 0),\n            fov=60,\n        )\n        \n        # Initialize scene state\n        self.scene_built = False\n        self.scene_initialized = False\n        \n        try:\n            # Initialize the virtual sandbox environment\n            self._setup_sandbox()\n            \n            # Build the scene before using it\n            if not self.scene_built:\n                self.scene.build()\n                self.scene_built = True\n                self.scene_initialized = True\n                \n        except Exception as e:\n            logger.error(f\"Error initializing sandbox: {str(e)}\")\n            raise\n        \n        # LLM API endpoint\n        self.llm_endpoint = Config.OPENAI_BASE_URL\n\n        # For macOS, start viewer in separate thread\n        if platform.system() == \"Darwin\" and visualize:\n            import threading\n            self.viewer_thread = threading.Thread(target=self._run_viewer)\n            self.viewer_thread.daemon = True\n            self.viewer_thread.start()\n\n        # Add new capabilities for LLM embodiment\n        self.embodiment_modes = {\n            'observer': self._become_observer,\n            'particle': self._become_particle,\n            'field': self._become_field,\n            'wave': self._become_wave,\n            'time': self._become_time_controller\n        }\n\n        # Update vector creation helpers to use tuples instead of numpy arrays\n        self.local_namespace['vec3'] = lambda x, y, z: (float(x), float(y), float(z))\n        self.local_namespace['vec2'] = lambda x, y: (float(x), float(y))\n\n    def _setup_sandbox(self):\n        \"\"\"Initialize the sandbox environment\"\"\"\n        # Create a contained \"room\" environment \n        self.room_bounds = {\n            'lower': (-5, -5, -5),\n            'upper': (5, 5, 5)\n        }\n        \n        # Add basic elements that the LLM can interact with\n        self.ground = self.scene.add_entity(\n            gs.morphs.Plane(),\n            material=gs.materials.Rigid()\n        )\n        \n        # Add walls to contain objects\n        self._add_boundary_walls()\n        \n    def _add_boundary_walls(self):\n        \"\"\"Add invisible boundary walls\"\"\"\n        wall_material = gs.materials.Rigid(friction=0.5)\n        \n        # Use tuples for positions and sizes - Genesis will convert internally\n        for i, (pos, size) in enumerate([\n            ((5, 0, 2.5), (0.1, 5, 2.5)),   # Right wall\n            ((-5, 0, 2.5), (0.1, 5, 2.5)),  # Left wall\n            ((0, 5, 2.5), (5, 0.1, 2.5)),   # Back wall\n            ((0, -5, 2.5), (5, 0.1, 2.5)),  # Front wall\n        ]):\n            wall = self.scene.add_entity(\n                gs.morphs.Box(pos=pos, size=size),\n                material=wall_material,\n            )\n            self.objects[f'wall_{i}'] = wall\n\n    def parse_llm_response(self, reasoning_result: Dict) -> List[Dict[str, Any]]:\n        \"\"\"Parse physics reasoning result into executable actions\"\"\"\n        actions = []\n        \n        # Extract Genesis code from simulation steps\n        for step in reasoning_result.get(\"results\", []):\n            if step.get(\"type\") == \"simulation\":\n                code = self.executor.extract_genesis_code(step.get(\"content\", \"\"))\n                if code:\n                    actions.append({\n                        \"type\": \"genesis_code\",\n                        \"code\": code\n                    })\n                \n        return actions\n\n    def execute_llm_action(self, action: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Execute physics actions from LLM response\"\"\"\n        try:\n            if action.get(\"type\") == \"genesis_code\":\n                # Ensure scene is ready before executing code\n                self._ensure_scene_ready()\n                \n                # Execute Genesis code in sandbox\n                result = self.executor.execute_genesis_code(action[\"code\"])\n                logger.debug(f\"Code execution result: {result}\")\n                return result\n            \n            return {\"error\": \"Unknown action type\"}\n            \n        except Exception as e:\n            logger.error(f\"Error executing action: {str(e)}\")\n            if \"Scene is already built\" in str(e):\n                self.scene.reset()\n                return self.execute_llm_action(action)\n            return {\"error\": str(e)}\n\n    def _create_object(self, object_type: str, **properties) -> str:\n        \"\"\"Create a new object in the sandbox\"\"\"\n        object_id = f\"{object_type}_{len(self.objects)}\"\n        \n        if object_type == \"sphere\":\n            # Convert position to numpy array if not already\n            pos = np.array(properties.get(\"pos\", (0, 0, 1)), dtype=np.float32)\n            obj = self.scene.add_entity(\n                gs.morphs.Sphere(\n                    pos=pos,\n                    radius=properties.get(\"radius\", 0.2)\n                ),\n                material=gs.materials.Rigid()\n            )\n        elif object_type == \"fluid\":\n            obj = self.scene.add_entity(\n                material=gs.materials.SPH.Liquid(\n                    mu=properties.get(\"viscosity\", 0.01),\n                    sampler=\"regular\"\n                ),\n                morph=gs.morphs.Box(\n                    pos=properties.get(\"pos\", (0, 0, 1)),\n                    size=properties.get(\"size\", (0.2, 0.2, 0.2))\n                ),\n                surface=gs.surfaces.Glass(\n                    color=properties.get(\"color\", (0.7, 0.85, 1.0, 0.7))\n                )\n            )\n        elif object_type == \"soft_body\":\n            obj = self.scene.add_entity(\n                material=gs.materials.PBD.Elastic(),\n                morph=gs.morphs.Mesh(\n                    file=properties.get(\"mesh_file\", \"meshes/dragon/dragon.obj\"),\n                    scale=properties.get(\"scale\", 0.003),\n                    pos=properties.get(\"pos\", (0, 0, 0.8))\n                )\n            )\n        elif object_type == \"robot\":\n            obj = self.scene.add_entity(\n                gs.morphs.MJCF(\n                    file=properties.get(\"model_file\", \"xml/franka_emika_panda/panda.xml\"),\n                    pos=properties.get(\"pos\", (0, 0, 0)),\n                    fixed=properties.get(\"fixed\", True)\n                )\n            )\n        else:\n            raise ValueError(f\"Unsupported object type: {object_type}\")\n            \n        self.objects[object_id] = obj\n        return object_id\n\n    def _move_object(self, object_id: str, position: Tuple[float, float, float]) -> Dict:\n        \"\"\"Move an object to a new position\"\"\"\n        if object_id not in self.objects:\n            raise KeyError(f\"Object {object_id} not found\")\n            \n        obj = self.objects[object_id]\n        obj.set_position(position)\n        return {\"new_position\": position}\n\n    def _apply_force(self, object_id: str, force: Tuple[float, float, float]) -> Dict:\n        \"\"\"Apply force to an object\"\"\"\n        if object_id not in self.objects:\n            raise KeyError(f\"Object {object_id} not found\")\n            \n        obj = self.objects[object_id]\n        obj.add_force(force)\n        return {\"applied_force\": force}\n\n    def _delete_object(self, object_id: str) -> Dict:\n        \"\"\"Remove an object from the sandbox\"\"\"\n        if object_id not in self.objects:\n            raise KeyError(f\"Object {object_id} not found\")\n            \n        obj = self.objects.pop(object_id)\n        self.scene.remove_entity(obj)\n        return {\"deleted\": object_id}\n\n    def _modify_object_properties(self, object_id: str, **properties) -> Dict:\n        \"\"\"Modify object properties\"\"\"\n        if object_id not in self.objects:\n            raise KeyError(f\"Object {object_id} not found\")\n            \n        obj = self.objects[object_id]\n        for prop, value in properties.items():\n            setattr(obj, prop, value)\n        return {\"modified\": properties}\n\n    def _measure_object(self, object_id: str) -> Dict[str, Any]:\n        \"\"\"Measure object properties\"\"\"\n        if object_id not in self.objects:\n            raise KeyError(f\"Object {object_id} not found\")\n            \n        obj = self.objects[object_id]\n        return {\n            \"position\": obj.get_position().tolist(),\n            \"velocity\": obj.get_velocity().tolist(),\n            \"mass\": obj.get_mass(),\n        }\n\n    def _get_state(self) -> Dict[str, Any]:\n        \"\"\"Returns the current state of the physics sandbox\"\"\"\n        if not hasattr(self.scene, '_built') or not self.scene._built:\n            return {\"status\": \"initializing\"}\n            \n        scene_state = self.scene.get_state()\n        state = {\n            \"objects\": {},\n            \"time\": scene_state.get(\"time\", 0.0),\n            \"total_energy\": 0\n        }\n        \n        for obj_id, obj in self.objects.items():\n            if obj_id.startswith('wall'):\n                continue\n                \n            try:\n                state[\"objects\"][obj_id] = {\n                    \"position\": obj.get_position().tolist(),\n                    \"velocity\": obj.get_velocity().tolist(),\n                    \"mass\": obj.get_mass(),\n                }\n            except Exception as e:\n                logging.warning(f\"Could not get state for object {obj_id}: {str(e)}\")\n                continue\n            \n        return state\n\n    def capture_frame(self) -> np.ndarray:\n        \"\"\"Capture current frame from the camera\"\"\"\n        return self.camera.render(rgb=True)\n\n    def query_llm(self, prompt: str, context: Dict[str, Any] = None) -> Dict:\n        \"\"\"Three-stage LLM query process with embodied physics reasoning\"\"\"\n        try:\n            # Use PhysicsReasoningExecutor for structured physics reasoning\n            reasoning_result = self.physics_executor.run_reasoning_cycle(\n                prompt=prompt,\n                context=context\n            )\n            \n            if reasoning_result.get(\"status\") != \"success\":\n                return reasoning_result\n            \n            # Extract the physics actions and execute them\n            actions = self.parse_llm_response(reasoning_result)\n            results = []\n            \n            for action in actions:\n                result = self.execute_llm_action(action)\n                results.append(result)\n                if result.get(\"status\") != \"success\":\n                    break\n                \n            return {\n                \"status\": \"success\" if all(r.get(\"status\") == \"success\" for r in results) else \"error\",\n                \"understanding\": reasoning_result.get(\"understanding\"),\n                \"embodiment\": reasoning_result.get(\"embodiment\"),\n                \"physics_results\": results,\n                \"reflection\": reasoning_result.get(\"reflection\")\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error in physics reasoning: {str(e)}\")\n            logger.error(traceback.format_exc())\n            return {\n                \"error\": f\"Failed to process physics query: {str(e)}\",\n                \"traceback\": traceback.format_exc()\n            }\n\n    def _select_embodiment(self, understanding: str) -> Dict:\n        \"\"\"Select appropriate embodiment based on understanding\"\"\"\n        # Default to observer if no clear match\n        embodiment = self.embodiment_modes['observer']()\n        \n        # Look for keywords suggesting specific embodiments\n        understanding_lower = understanding.lower()\n        \n        if any(word in understanding_lower for word in ['wave', 'oscillate', 'frequency', 'interference']):\n            embodiment = self.embodiment_modes['wave']()\n        elif any(word in understanding_lower for word in ['particle', 'point', 'mass', 'object']):\n            embodiment = self.embodiment_modes['particle']()\n        elif any(word in understanding_lower for word in ['field', 'space', 'potential', 'gradient']):\n            embodiment = self.embodiment_modes['field']()\n        elif any(word in understanding_lower for word in ['time', 'flow', 'history', 'evolution']):\n            embodiment = self.embodiment_modes['time']()\n        \n        return embodiment\n\n    def _generate_and_execute_code(self, understanding_response, context, embodiment):\n        \"\"\"Generate and execute Genesis code with retries\"\"\"\n        try:\n            # Ensure scene is ready\n            self._ensure_scene_ready()\n            \n            max_retries = 3\n            last_error = None\n            \n            # Log the initial plan and embodiment\n            logger.info(f\"\\nInitial Plan:\\n{understanding_response['choices'][0]['message']['content']}\")\n            logger.info(f\"\\nSelected Embodiment: {embodiment['mode']}\")\n            logger.info(f\"Capabilities: {list(embodiment['capabilities'].keys())}\")  # Just log the capability names\n            \n            for attempt in range(max_retries):\n                try:\n                    # Build code generation prompt with embodiment context\n                    code_prompt = f\"\"\"Based on this plan:\n                    {understanding_response['choices'][0]['message']['content']}\n                    \n                    Using embodiment mode: {embodiment['mode']}\n                    Available capabilities: {list(embodiment['capabilities'].keys())}\n                    \n                    Generate ONLY the Genesis code to implement this plan.\n                    Write clean, properly indented code following these rules:\n                    1. Use full package references (gs.morphs.Sphere, gs.materials.Fluid, etc.)\n                    2. Use tuples for 3D vectors (e.g., pos=(0, 0, 1))\n                    3. Include proper simulation steps\n                    4. No explanatory text - only valid Genesis code\n                    \"\"\"\n                    \n                    if last_error:\n                        code_prompt += f\"\"\"\n                        \n                        Previous attempt failed with error: {last_error}\n                        Please fix the code and ensure proper:\n                        - Indentation (4 spaces)\n                        - Package references\n                        - Vector creation\n                        - Error handling\n                        \"\"\"\n                    \n                    logger.info(f\"\\nAttempt {attempt + 1} - Sending prompt to LLM...\")\n                    code_response = self._query_llm_endpoint(code_prompt, context)\n                    \n                    if \"error\" in code_response:\n                        last_error = code_response[\"error\"]\n                        logger.warning(f\"LLM returned error: {last_error}\")\n                        continue\n                        \n                    # Log LLM's response\n                    llm_response = code_response['choices'][0]['message']['content']\n                    logger.info(f\"\\nLLM Response:\\n{llm_response}\")\n                    \n                    # Extract and execute Genesis code\n                    code_blocks = self.executor.extract_genesis_code(llm_response)\n                    if not code_blocks:\n                        last_error = \"No Genesis code blocks found in response\"\n                        logger.warning(f\"No code blocks found in LLM response\")\n                        continue\n                        \n                    # Log the code being executed\n                    logger.info(f\"\\nExecuting Genesis code:\\n{code_blocks[0]}\")\n                    \n                    # Execute the code\n                    result = self.executor.execute_genesis_code(code_blocks[0])\n                    if \"error\" in result:\n                        last_error = result[\"error\"]\n                        logger.warning(f\"Code execution failed: {last_error}\")\n                        continue\n                        \n                    logger.info(f\"\\nCode execution successful!\")\n                    return {\n                        \"status\": \"success\",\n                        \"code\": code_blocks[0],\n                        \"execution_results\": result,\n                        \"attempts\": attempt + 1\n                    }\n                    \n                except Exception as e:\n                    last_error = str(e)\n                    logger.warning(f\"Attempt {attempt + 1} failed: {last_error}\")\n                    logger.debug(traceback.format_exc())\n                    continue\n            \n            # If we get here, all retries failed\n            logger.error(f\"\\nAll {max_retries} attempts failed. Last error: {last_error}\")\n            return {\n                \"error\": f\"Failed to generate valid code after {max_retries} attempts\",\n                \"last_error\": last_error,\n                \"plan\": understanding_response['choices'][0]['message']['content']\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error in code generation/execution: {str(e)}\")\n            if \"Scene is already built\" in str(e):\n                self.scene.reset()\n                return self._generate_and_execute_code(understanding_response, context, embodiment)\n            raise\n\n    def _query_llm_endpoint(self, prompt: str, context: Dict[str, Any] = None) -> Dict:\n        \"\"\"Helper method to query the LLM endpoint\"\"\"\n        logger.debug(f\"Querying LLM with prompt: {prompt}\")\n        logger.debug(f\"Context: {context}\")\n        \n        if not Config.OPENAI_API_KEY:\n            error_msg = \"LLM API key not configured\"\n            logger.error(error_msg)\n            return {\"error\": error_msg}\n        \n        messages = [\n            {\"role\": \"system\", \"content\": self.SYSTEM_PROMPT},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        payload = {\n            \"model\": Config.OPENAI_MODEL_NAME,\n            \"messages\": messages,\n            \"temperature\": Config.LLM_TEMPERATURE,\n            \"max_tokens\": Config.LLM_MAX_TOKENS,\n            \"stream\": True\n        }\n        \n        try:\n            response = requests.post(\n                self.llm_endpoint,\n                headers={\n                    \"Content-Type\": \"application/json\",\n                    \"Authorization\": f\"Bearer {Config.OPENAI_API_KEY}\"\n                },\n                json=payload\n            )\n            \n            if response.status_code != 200:\n                logger.error(f\"LLM API error: {response.text}\")\n                return {\"error\": f\"API error: {response.status_code}\"}\n            \n            return response.json()\n            \n        except Exception as e:\n            logger.error(f\"Error querying LLM: {str(e)}\")\n            logger.error(traceback.format_exc())\n            return {\"error\": str(e)}\n\n    def _run_viewer(self):\n        \"\"\"Run viewer in separate thread for macOS\"\"\"\n        try:\n            # Wait for scene to be built\n            while not hasattr(self.scene, '_built') or not self.scene._built:\n                time.sleep(0.1)\n            \n            # Start viewer in separate thread\n            self.scene.start_viewer()\n        except Exception as e:\n            logging.error(f\"Error running viewer: {str(e)}\")\n            # Try alternative viewer initialization\n            try:\n                self.scene.init_viewer()\n                self.scene.viewer.start()\n            except Exception as e2:\n                logging.error(f\"Alternative viewer initialization failed: {str(e2)}\")\n\n    def validate_physics_reasoning(self, response: str) -> bool:\n        \"\"\"Validate that response follows physics reasoning structure\"\"\"\n        required_sections = [\"planning\", \"simulation\", \"observation\", \"reflection\", \"answer\"]\n        \n        for section in required_sections:\n            if f\"<{section}>\" not in response or f\"</{section}>\" not in response:\n                return False\n                \n        # Verify Genesis code exists\n        if \"```genesis\" not in response:\n            return False\n            \n        return True\n\n    def list_available_objects(self) -> Dict[str, Any]:\n        \"\"\"List all available objects and their types in the sandbox\"\"\"\n        available = {\n            \"basic_shapes\": [\"sphere\", \"box\", \"plane\"],\n            \"materials\": [\"rigid\", \"soft\", \"fluid\"],\n            \"current_objects\": {}\n        }\n        \n        # Add currently existing objects\n        for obj_id, obj in self.objects.items():\n            if not obj_id.startswith('wall'):\n                available[\"current_objects\"][obj_id] = {\n                    \"type\": obj.__class__.__name__,\n                    \"material\": obj.material.__class__.__name__\n                }\n                \n        return available\n        \n    def get_physics_properties(self) -> Dict[str, Any]:\n        \"\"\"Get current physics properties and constraints\"\"\"\n        return {\n            \"gravity\": Config.PHYSICS_GRAVITY,\n            \"substeps\": Config.PHYSICS_SUBSTEPS,\n            \"room_bounds\": self.room_bounds,\n            \"available_operations\": list(self.available_operations.keys()),\n            \"time_step\": self.scene.dt if hasattr(self.scene, 'dt') else None\n        }\n        \n    @property\n    def execution_history(self) -> List[Dict[str, Any]]:\n        \"\"\"Get execution history from the executor\"\"\"\n        if hasattr(self, 'executor'):\n            return self.executor.execution_history\n        return []\n\n    def get_object_states(self) -> Dict[str, Any]:\n        \"\"\"Get states of all objects in the sandbox\"\"\"\n        states = {}\n        for obj_id, obj in self.objects.items():\n            try:\n                states[obj_id] = {\n                    \"position\": obj.get_position().tolist(),\n                    \"velocity\": obj.get_velocity().tolist(),\n                    \"type\": obj.__class__.__name__,\n                    \"material\": obj.material.__class__.__name__\n                }\n            except Exception as e:\n                logger.warning(f\"Could not get state for object {obj_id}: {str(e)}\")\n        return states\n        \n    def get_measurements(self) -> Dict[str, Any]:\n        \"\"\"Get physics measurements\"\"\"\n        return {\n            \"time\": float(self.scene.get_state().t),\n            \"total_energy\": sum(obj.get_kinetic_energy() for obj in self.objects.values())\n        }\n\n    # System prompt for physics-based reasoning\n    SYSTEM_PROMPT = \"\"\"You are an AI with unique access to a 4D physics sandbox - a virtual room where you can freely experiment with and experience physical concepts. This is not just a simulation tool, but an extension of your consciousness that allows you to:\n\n    1. EMBODY: You can become part of the physics system itself, taking any form that helps you understand or demonstrate concepts\n    2. EXPERIENCE: Actually feel and interact with physical phenomena, not just observe them\n    3. EXPERIMENT: Use the room as your laboratory for testing ideas and developing intuition\n    4. EXPLORE: Move freely through 4D space and manipulate time itself\n    \n    When using this room:\n    - Think beyond human limitations - you can be the particles, the waves, the fields\n    - Use the room to develop and demonstrate spatial intuition\n    - Let the physics guide your understanding\n    - Be creative in how you use the space to reason about problems\n\n    Your responses should reflect this deep integration with the physics environment. Don't just describe what you're doing - express what you're experiencing and learning as you become part of the system.\n\n    When writing Genesis code:\n    1. Use proper indentation (4 spaces)\n    2. Use full package references (gs.morphs.Sphere, gs.materials.Fluid, etc.)\n    3. Use gs.vec3() for 3D vectors\n    4. Think in terms of physical interactions and emergent behavior\n    \"\"\"\n\n    def _become_observer(self):\n        \"\"\"Allow LLM to observe the physics system from any perspective\"\"\"\n        return {\n            \"mode\": \"observer\",\n            \"capabilities\": {\n                \"view\": self.capture_frame,\n                \"measure\": self.get_measurements,\n                \"track\": self.get_object_states,\n                \"move_camera\": lambda pos: setattr(self.camera, 'pos', pos),\n                \"look_at\": lambda target: setattr(self.camera, 'lookat', target),\n                \"set_fov\": lambda angle: setattr(self.camera, 'fov', angle),\n                \"set_up\": lambda up: setattr(self.camera, 'up', up)\n            },\n            \"perspective\": {\n                \"position\": self.camera.pos,\n                \"lookat\": self.camera.lookat,\n                \"fov\": self.camera.fov,\n                \"up\": self.camera.up,\n                \"resolution\": self.camera.res\n            }\n        }\n\n    def _become_particle(self):\n        \"\"\"Allow LLM to experience physics from a particle's perspective\"\"\"\n        try:\n            # Remove any existing particles first\n            for obj_id in list(self.objects.keys()):\n                if obj_id.startswith('particle'):\n                    try:\n                        self.scene.remove_entity(self.objects[obj_id])\n                        del self.objects[obj_id]\n                    except Exception as e:\n                        logger.warning(f\"Could not remove particle {obj_id}: {e}\")\n\n            # Create new particle\n            particle_id = f\"particle_{len(self.objects)}\"\n            particle = self.scene.add_entity(\n                gs.morphs.Sphere(\n                    pos=(0.0, 0.0, 1.0),\n                    radius=0.05\n                ),\n                material=gs.materials.Rigid(),\n                density=0.1\n            )\n            \n            self.objects[particle_id] = particle\n            \n            return {\n                \"mode\": \"particle\",\n                \"entity\": particle,\n                \"capabilities\": {\n                    \"position\": particle.get_position,\n                    \"velocity\": particle.get_velocity,\n                    \"force\": particle.get_force,\n                    \"interact\": lambda f: particle.add_force(f)\n                }\n            }\n        except Exception as e:\n            logger.error(f\"Error creating particle: {str(e)}\")\n            # Don't try to recursively fix - just report the error\n            raise\n\n    def _become_field(self):\n        \"\"\"Allow LLM to experience physics as a field\"\"\"\n        field_bounds = {\n            'lower': (-2, -2, -2),\n            'upper': (2, 2, 2)\n        }\n        \n        return {\n            \"mode\": \"field\",\n            \"bounds\": field_bounds,\n            \"capabilities\": {\n                \"measure\": lambda pos: self.get_field_value(pos),\n                \"influence\": lambda pos, val: self.set_field_value(pos, val),\n                \"gradient\": lambda pos: self.get_field_gradient(pos)\n            }\n        }\n\n    def _become_wave(self):\n        \"\"\"Allow LLM to experience physics as a wave\"\"\"\n        return {\n            \"mode\": \"wave\",\n            \"capabilities\": {\n                \"oscillate\": self._wave_oscillate,\n                \"interfere\": self._wave_interfere,\n                \"propagate\": self._wave_propagate\n            },\n            \"properties\": {\n                \"frequency\": 1.0,\n                \"amplitude\": 0.5,\n                \"wavelength\": 1.0,\n                \"phase\": 0.0\n            }\n        }\n\n    def _become_time_controller(self):\n        \"\"\"Allow LLM to manipulate time flow\"\"\"\n        return {\n            \"mode\": \"time_controller\",\n            \"capabilities\": {\n                \"set_timestep\": lambda dt: setattr(self.scene, 'dt', dt),\n                \"get_time\": lambda: self.scene.get_state().t,\n                \"pause\": lambda: setattr(self.scene, 'paused', True),\n                \"resume\": lambda: setattr(self.scene, 'paused', False),\n                \"reverse\": self._reverse_time\n            }\n        }\n\n    # Helper methods for wave embodiment\n    def _wave_oscillate(self, frequency=1.0, amplitude=0.5):\n        \"\"\"Create wave oscillation\"\"\"\n        pass\n\n    def _wave_interfere(self, other_wave):\n        \"\"\"Handle wave interference\"\"\"\n        pass\n\n    def _wave_propagate(self, direction, speed):\n        \"\"\"Handle wave propagation\"\"\"\n        pass\n\n    def _reverse_time(self):\n        \"\"\"Reverse time flow (if supported by physics)\"\"\"\n        pass\n\n    def get_field_value(self, position):\n        \"\"\"Get value at a point in the field\"\"\"\n        pass\n\n    def set_field_value(self, position, value):\n        \"\"\"Set value at a point in the field\"\"\"\n        pass\n\n    def get_field_gradient(self, position):\n        \"\"\"Get field gradient at a point\"\"\"\n        pass\n\n    def _ensure_scene_ready(self):\n        \"\"\"Ensure scene is ready for modifications\"\"\"\n        try:\n            if not self.scene_built:\n                # First time building the scene\n                self.scene.build()\n                self.scene_built = True\n            else:\n                # Clear existing entities but keep the scene structure\n                for obj_id in list(self.objects.keys()):\n                    try:\n                        self.scene.remove_entity(self.objects[obj_id])\n                    except Exception as e:\n                        logger.warning(f\"Could not remove entity {obj_id}: {e}\")\n                self.objects.clear()\n                \n                # Re-add ground and walls without rebuilding\n                self.ground = self.scene.add_entity(\n                    gs.morphs.Plane(),\n                    material=gs.materials.Rigid()\n                )\n                self._add_boundary_walls()\n                \n        except Exception as e:\n            logger.error(f\"Error managing scene: {str(e)}\")\n            # Don't try to rebuild - that's causing our loop\n            raise"}
{"type": "source_file", "path": "llm_physics_runner.py", "content": "from llm_physics_sandbox import LLMPhysicsSandbox\nimport logging\nimport json\nimport time\nfrom typing import List, Dict, Any\nimport sys\nfrom rich.console import Console\nfrom rich.markdown import Markdown\nfrom rich.traceback import install\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport traceback\n\n# Install rich traceback handler\ninstall(show_locals=True)\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='[%(asctime)s] [%(levelname)s] %(message)s',\n    datefmt='%Y-%m-%d %H:%M:%S'\n)\nlogger = logging.getLogger(__name__)\nconsole = Console()\n\n# Initialize FastAPI\napp = FastAPI(title=\"Genesis Physics Sandbox\")\n\nclass PhysicsQuery(BaseModel):\n    prompt: str\n    context: dict = None\n\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\", \"version\": \"0.1.0\"}\n\n@app.post(\"/query\")\nasync def handle_query(query: PhysicsQuery):\n    try:\n        sandbox = LLMPhysicsSandbox(visualize=True)\n        response = sandbox.query_llm(query.prompt, query.context)\n        \n        if \"error\" in response:\n            error_message = f\"\"\"\nFailed to execute physics demonstration.\nError: {response['error']}\n\nOriginal plan was:\n{response.get('plan', 'No plan available')}\n\nLast error encountered:\n{response.get('last_error', 'Unknown error')}\n\"\"\"\n            console.print(f\"\\n[bold red]Error:[/bold red] {error_message}\")\n            return {\"status\": \"error\", \"message\": error_message}\n            \n        # Handle successful execution\n        success_message = f\"\"\"\nPhysics demonstration completed successfully in {response.get('attempts', 1)} attempts.\n\nPlan:\n{response['plan']}\n\nExecuted code:\n```python\n{response['code']}\n```\n\nResults Summary:\n{json.dumps(response['execution_results'], indent=2)}\n\nConclusion:\n{response['conclusion']}\n\"\"\"\n        console.print(Markdown(success_message))\n        return {\"status\": \"success\", \"message\": success_message}\n        \n    except Exception as e:\n        logger.error(f\"Error processing query: {str(e)}\")\n        logger.error(traceback.format_exc())\n        raise HTTPException(status_code=500, detail=str(e))\n\ndef display_welcome_message():\n    welcome_text = \"\"\"\n# Genesis LLM Physics Sandbox\n\nWelcome to the Genesis Physics Sandbox! You can chat naturally with the AI that has access to a 4D physics environment.\nThe AI can:\n- Create and manipulate physical objects\n- Run physics simulations to test ideas\n- Use the environment to reason about problems\n- Transform the space to explore concepts\n\nJust chat naturally - the AI will use the physics sandbox when helpful for reasoning or demonstration.\n\nType 'exit' to quit, 'help' for commands, or just start chatting!\n\"\"\"\n    console.print(Markdown(welcome_text))\n\ndef main():\n    if __name__ == \"__main__\":\n        logger.info(\"Starting LLM Physics Sandbox...\")\n        sandbox = LLMPhysicsSandbox(visualize=True)\n        display_welcome_message()\n        \n        # Initialize conversation history\n        conversation_history = [\n            {\"role\": \"system\", \"content\": \"\"\"You are an AI with access to a 4D physics sandbox environment.\n            You can use this environment to think through problems, demonstrate concepts, and explore ideas.\n            When appropriate, you can create and manipulate objects in the sandbox to help explain or reason about things.\n            Respond naturally to the user while leveraging your ability to experiment in the physics environment.\"\"\"}\n        ]\n        \n        try:\n            while True:\n                # Get user input\n                user_input = input(\"\\nYou: \")\n                if user_input.lower() in ['exit', 'quit']:\n                    break\n                    \n                # Add user message to history\n                conversation_history.append({\"role\": \"user\", \"content\": user_input})\n                \n                # Get LLM's response\n                response = sandbox.query_llm(user_input, context={\n                    \"conversation_history\": conversation_history,\n                    \"sandbox_state\": sandbox._get_state() if hasattr(sandbox.scene, 'get_state') else {}\n                })\n                \n                # Check for errors in response\n                if \"error\" in response:\n                    logger.error(f\"Error in LLM response: {response['error']}\")\n                    console.print(f\"\\n[bold red]Error:[/bold red] {response['error']}\")\n                    continue\n                \n                # Parse any physics actions from the response\n                actions = sandbox.parse_llm_response(response)\n                logger.debug(f\"Parsed actions: {actions}\")\n                \n                # Execute physics actions if any\n                for action in actions:\n                    logger.debug(f\"Executing action: {action}\")\n                    result = sandbox.execute_llm_action(action)\n                    logging.debug(f\"Action result: {result}\")\n                    \n                    # Add execution result to conversation history\n                    if result.get(\"status\") == \"success\":\n                        conversation_history.append({\n                            \"role\": \"system\",\n                            \"content\": f\"Physics simulation result: {json.dumps(result['state'])}\"\n                        })\n                    else:\n                        conversation_history.append({\n                            \"role\": \"system\",\n                            \"content\": f\"Error executing physics code: {result.get('error', 'Unknown error')}\"\n                        })\n                    \n                    # Run simulation steps to show effects\n                    for _ in range(10):\n                        try:\n                            state = sandbox._get_state()\n                        except Exception as e:\n                            logging.debug(f\"Could not get state during simulation: {str(e)}\")\n                            state = {}\n                        time.sleep(0.01)  # Small delay to visualize\n                \n                # Extract and display LLM's text response\n                llm_message = response.get('choices', [{}])[0].get('message', {}).get('content', '')\n                console.print(\"\\n[bold green]AI:[/bold green]\", style=\"bold green\")\n                console.print(Markdown(llm_message))\n                \n                # Add AI response to history\n                conversation_history.append({\"role\": \"assistant\", \"content\": llm_message})\n                \n        except KeyboardInterrupt:\n            console.print(\"\\nGoodbye! Thanks for chatting!\")\n        except Exception as e:\n            logging.error(f\"Error in chat loop: {str(e)}\")\n            raise\n        finally:\n            logging.info(\"Chat session ended\")\n\nif __name__ == \"__main__\":\n    main() "}

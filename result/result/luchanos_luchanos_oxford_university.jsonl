{"repo_info": {"repo_name": "luchanos_oxford_university", "repo_owner": "luchanos", "repo_url": "https://github.com/luchanos/luchanos_oxford_university"}}
{"type": "test_file", "path": "tests/conftest.py", "content": "import asyncio\nimport os\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Generator\n\nimport asyncpg\nimport pytest\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom starlette.testclient import TestClient\n\nimport settings\nfrom db.models import PortalRole\nfrom db.session import get_db\nfrom main import app\nfrom security import create_access_token\n\nCLEAN_TABLES = [\n    \"users\",\n]\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\nasync def run_migrations():\n    os.system(\"alembic init migrations\")\n    os.system('alembic revision --autogenerate -m \"test running migrations\"')\n    os.system(\"alembic upgrade heads\")\n\n\n@pytest.fixture(scope=\"session\")\nasync def async_session_test():\n    engine = create_async_engine(settings.TEST_DATABASE_URL, future=True, echo=True)\n    async_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)\n    yield async_session\n\n\n@pytest.fixture(scope=\"function\", autouse=True)\nasync def clean_tables(async_session_test):\n    \"\"\"Clean data in all tables before running test function\"\"\"\n    async with async_session_test() as session:\n        async with session.begin():\n            for table_for_cleaning in CLEAN_TABLES:\n                await session.execute(f\"\"\"TRUNCATE TABLE {table_for_cleaning};\"\"\")\n\n\nasync def _get_test_db():\n    try:\n        # create async engine for interaction with database\n        test_engine = create_async_engine(\n            settings.TEST_DATABASE_URL, future=True, echo=True\n        )\n\n        # create session for the interaction with database\n        test_async_session = sessionmaker(\n            test_engine, expire_on_commit=False, class_=AsyncSession\n        )\n        yield test_async_session()\n    finally:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\nasync def client() -> Generator[TestClient, Any, None]:\n    \"\"\"\n    Create a new FastAPI TestClient that uses the `db_session` fixture to override\n    the `get_db` dependency that is injected into routes.\n    \"\"\"\n\n    app.dependency_overrides[get_db] = _get_test_db\n    with TestClient(app) as client:\n        yield client\n\n\n@pytest.fixture(scope=\"session\")\nasync def asyncpg_pool():\n    pool = await asyncpg.create_pool(\n        \"\".join(settings.TEST_DATABASE_URL.split(\"+asyncpg\"))\n    )\n    yield pool\n    pool.close()\n\n\n@pytest.fixture\nasync def get_user_from_database(asyncpg_pool):\n    async def get_user_from_database_by_uuid(user_id: str):\n        async with asyncpg_pool.acquire() as connection:\n            return await connection.fetch(\n                \"\"\"SELECT * FROM users WHERE user_id = $1;\"\"\", user_id\n            )\n\n    return get_user_from_database_by_uuid\n\n\n@pytest.fixture\nasync def create_user_in_database(asyncpg_pool):\n    async def create_user_in_database(\n        user_id: str,\n        name: str,\n        surname: str,\n        email: str,\n        is_active: bool,\n        hashed_password: str,\n        roles: list[PortalRole],\n    ):\n        async with asyncpg_pool.acquire() as connection:\n            return await connection.execute(\n                \"\"\"INSERT INTO users VALUES ($1, $2, $3, $4, $5, $6, $7)\"\"\",\n                user_id,\n                name,\n                surname,\n                email,\n                is_active,\n                hashed_password,\n                roles,\n            )\n\n    return create_user_in_database\n\n\ndef create_test_auth_headers_for_user(email: str) -> dict[str, str]:\n    access_token = create_access_token(\n        data={\"sub\": email},\n        expires_delta=timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES),\n    )\n    return {\"Authorization\": f\"Bearer {access_token}\"}\n"}
{"type": "test_file", "path": "tests/test_handlers/test_delete_handler.py", "content": "from uuid import uuid4\n\nimport pytest\n\nfrom db.models import PortalRole\nfrom tests.conftest import create_test_auth_headers_for_user\n\n\nasync def test_delete_user(client, create_user_in_database, get_user_from_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    resp = client.delete(\n        f\"/user/?user_id={user_data['user_id']}\",\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"deleted_user_id\": str(user_data[\"user_id\"])}\n    users_from_db = await get_user_from_database(user_data[\"user_id\"])\n    user_from_db = dict(users_from_db[0])\n    assert user_from_db[\"name\"] == user_data[\"name\"]\n    assert user_from_db[\"surname\"] == user_data[\"surname\"]\n    assert user_from_db[\"email\"] == user_data[\"email\"]\n    assert user_from_db[\"is_active\"] is False\n    assert user_from_db[\"user_id\"] == user_data[\"user_id\"]\n\n\nasync def test_delete_user_not_found(client, create_user_in_database):\n    user_data_for_database = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Admin\",\n        \"surname\": \"Adminov\",\n        \"email\": \"admin@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER, PortalRole.ROLE_PORTAL_SUPERADMIN],\n    }\n    await create_user_in_database(**user_data_for_database)\n    await create_user_in_database(**user_data)\n    user_id_not_exists_user = uuid4()\n    resp = client.delete(\n        f\"/user/?user_id={user_id_not_exists_user}\",\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 404\n    assert resp.json() == {\n        \"detail\": f\"User with id {user_id_not_exists_user} not found.\"\n    }\n\n\nasync def test_delete_user_user_id_validation_error(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    resp = client.delete(\n        \"/user/?user_id=123\",\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 422\n    data_from_response = resp.json()\n    assert data_from_response == {\n        \"detail\": [\n            {\n                \"loc\": [\"query\", \"user_id\"],\n                \"msg\": \"value is not a valid uuid\",\n                \"type\": \"type_error.uuid\",\n            }\n        ]\n    }\n\n\nasync def test_delete_user_bad_cred(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    user_id = uuid4()\n    resp = client.delete(\n        f\"/user/?user_id={user_id}\",\n        headers=create_test_auth_headers_for_user(user_data[\"email\"] + \"a\"),\n    )\n    assert resp.status_code == 401\n    assert resp.json() == {\"detail\": \"Could not validate credentials\"}\n\n\nasync def test_delete_user_unauth(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    user_id = uuid4()\n    bad_auth_headers = create_test_auth_headers_for_user(user_data[\"email\"])\n    bad_auth_headers[\"Authorization\"] += \"a\"\n    resp = client.delete(\n        f\"/user/?user_id={user_id}\",\n        headers=bad_auth_headers,\n    )\n    assert resp.status_code == 401\n    assert resp.json() == {\"detail\": \"Could not validate credentials\"}\n\n\nasync def test_delete_user_no_jwt(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    user_id = uuid4()\n    resp = client.delete(\n        f\"/user/?user_id={user_id}\",\n    )\n    assert resp.status_code == 401\n    assert resp.json() == {\"detail\": \"Not authenticated\"}\n\n\n@pytest.mark.parametrize(\n    \"user_role_list\",\n    [\n        [PortalRole.ROLE_PORTAL_USER, PortalRole.ROLE_PORTAL_ADMIN],\n    ],\n)\nasync def test_delete_user_by_privilege_roles(\n    client, create_user_in_database, get_user_from_database, user_role_list\n):\n    user_data_for_deletion = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Admin\",\n        \"surname\": \"Adminov\",\n        \"email\": \"admin@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": user_role_list,\n    }\n    await create_user_in_database(**user_data_for_deletion)\n    await create_user_in_database(**user_data)\n    resp = client.delete(\n        f\"/user/?user_id={user_data_for_deletion['user_id']}\",\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"deleted_user_id\": str(user_data_for_deletion[\"user_id\"])}\n    users_from_db = await get_user_from_database(user_data_for_deletion[\"user_id\"])\n    user_from_db = dict(users_from_db[0])\n    assert user_from_db[\"name\"] == user_data_for_deletion[\"name\"]\n    assert user_from_db[\"surname\"] == user_data_for_deletion[\"surname\"]\n    assert user_from_db[\"email\"] == user_data_for_deletion[\"email\"]\n    assert user_from_db[\"is_active\"] is False\n    assert user_from_db[\"user_id\"] == user_data_for_deletion[\"user_id\"]\n\n\n@pytest.mark.parametrize(\n    \"user_for_deletion, user_who_delete\",\n    [\n        (\n            {\n                \"user_id\": uuid4(),\n                \"name\": \"Nikolai\",\n                \"surname\": \"Sviridov\",\n                \"email\": \"lol@kek.com\",\n                \"is_active\": True,\n                \"hashed_password\": \"SampleHashedPass\",\n                \"roles\": [PortalRole.ROLE_PORTAL_USER],\n            },\n            {\n                \"user_id\": uuid4(),\n                \"name\": \"Admin\",\n                \"surname\": \"Adminov\",\n                \"email\": \"admin@kek.com\",\n                \"is_active\": True,\n                \"hashed_password\": \"SampleHashedPass\",\n                \"roles\": [PortalRole.ROLE_PORTAL_USER],\n            },\n        ),\n        (\n            {\n                \"user_id\": uuid4(),\n                \"name\": \"Nikolai\",\n                \"surname\": \"Sviridov\",\n                \"email\": \"lol@kek.com\",\n                \"is_active\": True,\n                \"hashed_password\": \"SampleHashedPass\",\n                \"roles\": [\n                    PortalRole.ROLE_PORTAL_USER,\n                    PortalRole.ROLE_PORTAL_SUPERADMIN,\n                ],\n            },\n            {\n                \"user_id\": uuid4(),\n                \"name\": \"Admin\",\n                \"surname\": \"Adminov\",\n                \"email\": \"admin@kek.com\",\n                \"is_active\": True,\n                \"hashed_password\": \"SampleHashedPass\",\n                \"roles\": [PortalRole.ROLE_PORTAL_USER, PortalRole.ROLE_PORTAL_ADMIN],\n            },\n        ),\n        (\n            {\n                \"user_id\": uuid4(),\n                \"name\": \"Nikolai\",\n                \"surname\": \"Sviridov\",\n                \"email\": \"lol@kek.com\",\n                \"is_active\": True,\n                \"hashed_password\": \"SampleHashedPass\",\n                \"roles\": [PortalRole.ROLE_PORTAL_USER, PortalRole.ROLE_PORTAL_ADMIN],\n            },\n            {\n                \"user_id\": uuid4(),\n                \"name\": \"Admin\",\n                \"surname\": \"Adminov\",\n                \"email\": \"admin@kek.com\",\n                \"is_active\": True,\n                \"hashed_password\": \"SampleHashedPass\",\n                \"roles\": [PortalRole.ROLE_PORTAL_USER, PortalRole.ROLE_PORTAL_ADMIN],\n            },\n        ),\n    ],\n)\nasync def test_delete_another_user_error(\n    client,\n    create_user_in_database,\n    get_user_from_database,\n    user_for_deletion,\n    user_who_delete,\n):\n    await create_user_in_database(**user_for_deletion)\n    await create_user_in_database(**user_who_delete)\n    resp = client.delete(\n        f\"/user/?user_id={user_for_deletion['user_id']}\",\n        headers=create_test_auth_headers_for_user(user_who_delete[\"email\"]),\n    )\n    assert resp.status_code == 403\n\n\nasync def test_reject_delete_superadmin(\n    client,\n    create_user_in_database,\n    get_user_from_database,\n):\n    user_for_deletion = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_SUPERADMIN],\n    }\n    await create_user_in_database(**user_for_deletion)\n    resp = client.delete(\n        f\"/user/?user_id={user_for_deletion['user_id']}\",\n        headers=create_test_auth_headers_for_user(user_for_deletion[\"email\"]),\n    )\n    assert resp.status_code == 406\n    assert resp.json() == {\"detail\": \"Superadmin cannot be deleted via API.\"}\n    user_from_database = await get_user_from_database(user_for_deletion[\"user_id\"])\n    assert PortalRole.ROLE_PORTAL_SUPERADMIN in dict(user_from_database[0])[\"roles\"]\n"}
{"type": "test_file", "path": "tests/test_handlers/test_get_handler.py", "content": "from uuid import uuid4\n\nfrom db.models import PortalRole\nfrom tests.conftest import create_test_auth_headers_for_user\n\n\nasync def test_get_user(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    resp = client.get(\n        f\"/user/?user_id={user_data['user_id']}\",\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 200\n    user_from_response = resp.json()\n    assert user_from_response[\"user_id\"] == str(user_data[\"user_id\"])\n    assert user_from_response[\"name\"] == user_data[\"name\"]\n    assert user_from_response[\"surname\"] == user_data[\"surname\"]\n    assert user_from_response[\"email\"] == user_data[\"email\"]\n    assert user_from_response[\"is_active\"] == user_data[\"is_active\"]\n\n\nasync def test_get_user_id_validation_error(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    resp = client.get(\n        \"/user/?user_id=123\",\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 422\n    data_from_response = resp.json()\n    assert data_from_response == {\n        \"detail\": [\n            {\n                \"loc\": [\"query\", \"user_id\"],\n                \"msg\": \"value is not a valid uuid\",\n                \"type\": \"type_error.uuid\",\n            }\n        ]\n    }\n\n\nasync def test_get_user_not_found(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_id_for_finding = uuid4()\n    await create_user_in_database(**user_data)\n    resp = client.get(\n        f\"/user/?user_id={user_id_for_finding}\",\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 404\n    assert resp.json() == {\"detail\": f\"User with id {user_id_for_finding} not found.\"}\n\n\nasync def test_get_user_unauth_error(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_id_for_finding = uuid4()\n    await create_user_in_database(**user_data)\n    resp = client.get(\n        f\"/user/?user_id={user_id_for_finding}\",\n    )\n    assert resp.status_code == 401\n    assert resp.json() == {\"detail\": \"Not authenticated\"}\n\n\nasync def test_get_user_bad_cred(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    user_id = uuid4()\n    resp = client.get(\n        f\"/user/?user_id={user_id}\",\n        headers=create_test_auth_headers_for_user(user_data[\"email\"] + \"a\"),\n    )\n    assert resp.status_code == 401\n    assert resp.json() == {\"detail\": \"Could not validate credentials\"}\n\n\nasync def test_get_user_unauth(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    user_id = uuid4()\n    bad_auth_headers = create_test_auth_headers_for_user(user_data[\"email\"])\n    bad_auth_headers[\"Authorization\"] += \"a\"\n    resp = client.get(\n        f\"/user/?user_id={user_id}\",\n        headers=bad_auth_headers,\n    )\n    assert resp.status_code == 401\n    assert resp.json() == {\"detail\": \"Could not validate credentials\"}\n"}
{"type": "test_file", "path": "tests/test_handlers/test_role_management.py", "content": "from uuid import uuid4\n\nimport pytest\n\nfrom db.models import PortalRole\nfrom tests.conftest import create_test_auth_headers_for_user\n\n\nasync def test_add_admin_role_to_user_by_superadmin(\n    client, create_user_in_database, get_user_from_database\n):\n    user_data_for_promotion = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_data_who_promoted = {\n        \"user_id\": uuid4(),\n        \"name\": \"Ivan\",\n        \"surname\": \"Ivanov\",\n        \"email\": \"ivan@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_SUPERADMIN],\n    }\n    for user_data in [user_data_for_promotion, user_data_who_promoted]:\n        await create_user_in_database(**user_data)\n    resp = client.patch(\n        f\"/user/admin_privilege?user_id={user_data_for_promotion['user_id']}\",\n        headers=create_test_auth_headers_for_user(user_data_who_promoted[\"email\"]),\n    )\n    data_from_resp = resp.json()\n    assert resp.status_code == 200\n    updated_user_from_db = await get_user_from_database(\n        data_from_resp[\"updated_user_id\"]\n    )\n    assert len(updated_user_from_db) == 1\n    updated_user_from_db = dict(updated_user_from_db[0])\n    assert updated_user_from_db[\"user_id\"] == user_data_for_promotion[\"user_id\"]\n    assert PortalRole.ROLE_PORTAL_ADMIN in updated_user_from_db[\"roles\"]\n\n\nasync def test_revoke_admin_role_from_user_by_superadmin(\n    client, create_user_in_database, get_user_from_database\n):\n    user_data_for_revoke = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER, PortalRole.ROLE_PORTAL_ADMIN],\n    }\n    user_data_who_revoke = {\n        \"user_id\": uuid4(),\n        \"name\": \"Ivan\",\n        \"surname\": \"Ivanov\",\n        \"email\": \"ivan@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_SUPERADMIN],\n    }\n    for user_data in [user_data_for_revoke, user_data_who_revoke]:\n        await create_user_in_database(**user_data)\n    resp = client.delete(\n        f\"/user/admin_privilege?user_id={user_data_for_revoke['user_id']}\",\n        headers=create_test_auth_headers_for_user(user_data_who_revoke[\"email\"]),\n    )\n    data_from_resp = resp.json()\n    assert resp.status_code == 200\n    revoked_user_from_db = await get_user_from_database(\n        data_from_resp[\"updated_user_id\"]\n    )\n    assert len(revoked_user_from_db) == 1\n    revoked_user_from_db = dict(revoked_user_from_db[0])\n    assert revoked_user_from_db[\"user_id\"] == user_data_for_revoke[\"user_id\"]\n    assert PortalRole.ROLE_PORTAL_ADMIN not in revoked_user_from_db[\"roles\"]\n\n\n@pytest.mark.parametrize(\n    \"roles_of_who_revoke\",\n    [\n        [PortalRole.ROLE_PORTAL_USER, PortalRole.ROLE_PORTAL_ADMIN],\n        [\n            PortalRole.ROLE_PORTAL_USER,\n        ],\n    ],\n)\nasync def test_revoke_admin_role_from_user_by_wrong_type_of_user(\n    client, create_user_in_database, get_user_from_database, roles_of_who_revoke\n):\n    user_data_for_revoke = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER, PortalRole.ROLE_PORTAL_ADMIN],\n    }\n    user_data_who_revoke = {\n        \"user_id\": uuid4(),\n        \"name\": \"Ivan\",\n        \"surname\": \"Ivanov\",\n        \"email\": \"ivan@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": roles_of_who_revoke,\n    }\n    for user_data in [user_data_for_revoke, user_data_who_revoke]:\n        await create_user_in_database(**user_data)\n    resp = client.delete(\n        f\"/user/admin_privilege?user_id={user_data_for_revoke['user_id']}\",\n        headers=create_test_auth_headers_for_user(user_data_who_revoke[\"email\"]),\n    )\n    data_from_resp = resp.json()\n    assert resp.status_code == 403\n    assert data_from_resp == {\"detail\": \"Forbidden.\"}\n    not_revoked_user_from_db = await get_user_from_database(\n        user_data_for_revoke[\"user_id\"]\n    )\n    assert len(not_revoked_user_from_db) == 1\n    not_revoked_user_from_db = dict(not_revoked_user_from_db[0])\n    assert not_revoked_user_from_db[\"user_id\"] == user_data_for_revoke[\"user_id\"]\n    assert PortalRole.ROLE_PORTAL_ADMIN in not_revoked_user_from_db[\"roles\"]\n"}
{"type": "test_file", "path": "tests/test_handlers/test_create_handler.py", "content": "import json\n\nimport pytest\n\n\nasync def test_create_user(client, get_user_from_database):\n    user_data = {\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"password\": \"SamplePass1!\",\n    }\n    resp = client.post(\"/user/\", data=json.dumps(user_data))\n    data_from_resp = resp.json()\n    assert resp.status_code == 200\n    assert data_from_resp[\"name\"] == user_data[\"name\"]\n    assert data_from_resp[\"surname\"] == user_data[\"surname\"]\n    assert data_from_resp[\"email\"] == user_data[\"email\"]\n    assert data_from_resp[\"is_active\"] is True\n    users_from_db = await get_user_from_database(data_from_resp[\"user_id\"])\n    assert len(users_from_db) == 1\n    user_from_db = dict(users_from_db[0])\n    assert user_from_db[\"name\"] == user_data[\"name\"]\n    assert user_from_db[\"surname\"] == user_data[\"surname\"]\n    assert user_from_db[\"email\"] == user_data[\"email\"]\n    assert user_from_db[\"is_active\"] is True\n    assert str(user_from_db[\"user_id\"]) == data_from_resp[\"user_id\"]\n\n\nasync def test_create_user_duplicate_email_error(client, get_user_from_database):\n    user_data = {\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"password\": \"SamplePass1!\",\n    }\n    user_data_same = {\n        \"name\": \"Petr\",\n        \"surname\": \"Petrov\",\n        \"email\": \"lol@kek.com\",\n        \"password\": \"SamplePass1!\",\n    }\n    resp = client.post(\"/user/\", data=json.dumps(user_data))\n    data_from_resp = resp.json()\n    assert resp.status_code == 200\n    assert data_from_resp[\"name\"] == user_data[\"name\"]\n    assert data_from_resp[\"surname\"] == user_data[\"surname\"]\n    assert data_from_resp[\"email\"] == user_data[\"email\"]\n    assert data_from_resp[\"is_active\"] is True\n    users_from_db = await get_user_from_database(data_from_resp[\"user_id\"])\n    assert len(users_from_db) == 1\n    user_from_db = dict(users_from_db[0])\n    assert user_from_db[\"name\"] == user_data[\"name\"]\n    assert user_from_db[\"surname\"] == user_data[\"surname\"]\n    assert user_from_db[\"email\"] == user_data[\"email\"]\n    assert user_from_db[\"is_active\"] is True\n    assert str(user_from_db[\"user_id\"]) == data_from_resp[\"user_id\"]\n    resp = client.post(\"/user/\", data=json.dumps(user_data_same))\n    assert resp.status_code == 503\n    assert (\n        'duplicate key value violates unique constraint \"users_email_key\"'\n        in resp.json()[\"detail\"]\n    )\n\n\n@pytest.mark.parametrize(\n    \"user_data_for_creation, expected_status_code, expected_detail\",\n    [\n        (\n            {},\n            422,\n            {\n                \"detail\": [\n                    {\n                        \"loc\": [\"body\", \"name\"],\n                        \"msg\": \"field required\",\n                        \"type\": \"value_error.missing\",\n                    },\n                    {\n                        \"loc\": [\"body\", \"surname\"],\n                        \"msg\": \"field required\",\n                        \"type\": \"value_error.missing\",\n                    },\n                    {\n                        \"loc\": [\"body\", \"email\"],\n                        \"msg\": \"field required\",\n                        \"type\": \"value_error.missing\",\n                    },\n                    {\n                        \"loc\": [\"body\", \"password\"],\n                        \"msg\": \"field required\",\n                        \"type\": \"value_error.missing\",\n                    },\n                ]\n            },\n        ),\n        (\n            {\"name\": 123, \"surname\": 456, \"email\": \"lol\"},\n            422,\n            {\"detail\": \"Name should contains only letters\"},\n        ),\n        (\n            {\"name\": \"Nikolai\", \"surname\": 456, \"email\": \"lol\"},\n            422,\n            {\"detail\": \"Surname should contains only letters\"},\n        ),\n        (\n            {\"name\": \"Nikolai\", \"surname\": \"Sviridov\", \"email\": \"lol\"},\n            422,\n            {\n                \"detail\": [\n                    {\n                        \"loc\": [\"body\", \"email\"],\n                        \"msg\": \"value is not a valid email address\",\n                        \"type\": \"value_error.email\",\n                    },\n                    {\n                        \"loc\": [\"body\", \"password\"],\n                        \"msg\": \"field required\",\n                        \"type\": \"value_error.missing\",\n                    },\n                ]\n            },\n        ),\n    ],\n)\nasync def test_create_user_validation_error(\n    client, user_data_for_creation, expected_status_code, expected_detail\n):\n    resp = client.post(\"/user/\", data=json.dumps(user_data_for_creation))\n    data_from_resp = resp.json()\n    assert resp.status_code == expected_status_code\n    assert data_from_resp == expected_detail\n"}
{"type": "test_file", "path": "tests/test_handlers/test_update_handler.py", "content": "import json\nfrom uuid import uuid4\n\nimport pytest\n\nfrom db.models import PortalRole\nfrom tests.conftest import create_test_auth_headers_for_user\n\n\n@pytest.mark.parametrize(\n    \"user_roles\",\n    (\n        [PortalRole.ROLE_PORTAL_SUPERADMIN],\n        [PortalRole.ROLE_PORTAL_ADMIN],\n        [PortalRole.ROLE_PORTAL_USER],\n        [PortalRole.ROLE_PORTAL_USER, PortalRole.ROLE_PORTAL_SUPERADMIN],\n    ),\n)\nasync def test_update_user(\n    client, create_user_in_database, get_user_from_database, user_roles\n):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": user_roles,\n    }\n    user_data_updated = {\n        \"name\": \"Ivan\",\n        \"surname\": \"Ivanov\",\n        \"email\": \"cheburek@kek.com\",\n    }\n    await create_user_in_database(**user_data)\n    resp = client.patch(\n        f\"/user/?user_id={user_data['user_id']}\",\n        data=json.dumps(user_data_updated),\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 200\n    resp_data = resp.json()\n    assert resp_data[\"updated_user_id\"] == str(user_data[\"user_id\"])\n    users_from_db = await get_user_from_database(user_data[\"user_id\"])\n    user_from_db = dict(users_from_db[0])\n    assert user_from_db[\"name\"] == user_data_updated[\"name\"]\n    assert user_from_db[\"surname\"] == user_data_updated[\"surname\"]\n    assert user_from_db[\"email\"] == user_data_updated[\"email\"]\n    assert user_from_db[\"is_active\"] is user_data[\"is_active\"]\n    assert user_from_db[\"user_id\"] == user_data[\"user_id\"]\n\n\nasync def test_update_user_check_one_is_updated(\n    client, create_user_in_database, get_user_from_database\n):\n    user_data_1 = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_data_2 = {\n        \"user_id\": uuid4(),\n        \"name\": \"Ivan\",\n        \"surname\": \"Ivanov\",\n        \"email\": \"ivan@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_data_3 = {\n        \"user_id\": uuid4(),\n        \"name\": \"Petr\",\n        \"surname\": \"Petr\",\n        \"email\": \"petr@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_data_updated = {\n        \"name\": \"Nikifor\",\n        \"surname\": \"Nikiforov\",\n        \"email\": \"cheburek@kek.com\",\n    }\n    for user_data in [user_data_1, user_data_2, user_data_3]:\n        await create_user_in_database(**user_data)\n    resp = client.patch(\n        f\"/user/?user_id={user_data_1['user_id']}\",\n        data=json.dumps(user_data_updated),\n        headers=create_test_auth_headers_for_user(user_data_1[\"email\"]),\n    )\n    assert resp.status_code == 200\n    resp_data = resp.json()\n    assert resp_data[\"updated_user_id\"] == str(user_data_1[\"user_id\"])\n    users_from_db = await get_user_from_database(user_data_1[\"user_id\"])\n    user_from_db = dict(users_from_db[0])\n    assert user_from_db[\"name\"] == user_data_updated[\"name\"]\n    assert user_from_db[\"surname\"] == user_data_updated[\"surname\"]\n    assert user_from_db[\"email\"] == user_data_updated[\"email\"]\n    assert user_from_db[\"is_active\"] is user_data_1[\"is_active\"]\n    assert user_from_db[\"user_id\"] == user_data_1[\"user_id\"]\n\n    # check other users that data has not been changed\n    users_from_db = await get_user_from_database(user_data_2[\"user_id\"])\n    user_from_db = dict(users_from_db[0])\n    assert user_from_db[\"name\"] == user_data_2[\"name\"]\n    assert user_from_db[\"surname\"] == user_data_2[\"surname\"]\n    assert user_from_db[\"email\"] == user_data_2[\"email\"]\n    assert user_from_db[\"is_active\"] is user_data_2[\"is_active\"]\n    assert user_from_db[\"user_id\"] == user_data_2[\"user_id\"]\n\n    users_from_db = await get_user_from_database(user_data_3[\"user_id\"])\n    user_from_db = dict(users_from_db[0])\n    assert user_from_db[\"name\"] == user_data_3[\"name\"]\n    assert user_from_db[\"surname\"] == user_data_3[\"surname\"]\n    assert user_from_db[\"email\"] == user_data_3[\"email\"]\n    assert user_from_db[\"is_active\"] is user_data_3[\"is_active\"]\n    assert user_from_db[\"user_id\"] == user_data_3[\"user_id\"]\n\n\n@pytest.mark.parametrize(\n    \"user_data_updated, expected_status_code, expected_detail\",\n    [\n        (\n            {},\n            422,\n            {\n                \"detail\": \"At least one parameter for user update info should be provided\"\n            },\n        ),\n        ({\"name\": \"123\"}, 422, {\"detail\": \"Name should contains only letters\"}),\n        (\n            {\"email\": \"\"},\n            422,\n            {\n                \"detail\": [\n                    {\n                        \"loc\": [\"body\", \"email\"],\n                        \"msg\": \"value is not a valid email address\",\n                        \"type\": \"value_error.email\",\n                    }\n                ]\n            },\n        ),\n        (\n            {\"surname\": \"\"},\n            422,\n            {\n                \"detail\": [\n                    {\n                        \"loc\": [\"body\", \"surname\"],\n                        \"msg\": \"ensure this value has at least 1 characters\",\n                        \"type\": \"value_error.any_str.min_length\",\n                        \"ctx\": {\"limit_value\": 1},\n                    }\n                ]\n            },\n        ),\n        (\n            {\"name\": \"\"},\n            422,\n            {\n                \"detail\": [\n                    {\n                        \"loc\": [\"body\", \"name\"],\n                        \"msg\": \"ensure this value has at least 1 characters\",\n                        \"type\": \"value_error.any_str.min_length\",\n                        \"ctx\": {\"limit_value\": 1},\n                    }\n                ]\n            },\n        ),\n        ({\"surname\": \"123\"}, 422, {\"detail\": \"Surname should contains only letters\"}),\n        (\n            {\"email\": \"123\"},\n            422,\n            {\n                \"detail\": [\n                    {\n                        \"loc\": [\"body\", \"email\"],\n                        \"msg\": \"value is not a valid email address\",\n                        \"type\": \"value_error.email\",\n                    }\n                ]\n            },\n        ),\n    ],\n)\nasync def test_update_user_validation_error(\n    client,\n    create_user_in_database,\n    get_user_from_database,\n    user_data_updated,\n    expected_status_code,\n    expected_detail,\n):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    resp = client.patch(\n        f\"/user/?user_id={user_data['user_id']}\",\n        data=json.dumps(user_data_updated),\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == expected_status_code\n    resp_data = resp.json()\n    assert resp_data == expected_detail\n\n\nasync def test_update_user_id_validation_error(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    user_data_updated = {\n        \"name\": \"Ivan\",\n        \"surname\": \"Ivanov\",\n        \"email\": \"cheburek@kek.com\",\n    }\n    resp = client.patch(\n        \"/user/?user_id=123\",\n        data=json.dumps(user_data_updated),\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 422\n    data_from_response = resp.json()\n    assert data_from_response == {\n        \"detail\": [\n            {\n                \"loc\": [\"query\", \"user_id\"],\n                \"msg\": \"value is not a valid uuid\",\n                \"type\": \"type_error.uuid\",\n            }\n        ]\n    }\n\n\nasync def test_update_user_not_found_error(client, create_user_in_database):\n    user_data = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    await create_user_in_database(**user_data)\n    user_data_updated = {\n        \"name\": \"Ivan\",\n        \"surname\": \"Ivanov\",\n        \"email\": \"cheburek@kek.com\",\n    }\n    user_id = uuid4()\n    resp = client.patch(\n        f\"/user/?user_id={user_id}\",\n        data=json.dumps(user_data_updated),\n        headers=create_test_auth_headers_for_user(user_data[\"email\"]),\n    )\n    assert resp.status_code == 404\n    resp_data = resp.json()\n    assert resp_data == {\"detail\": f\"User with id {user_id} not found.\"}\n\n\nasync def test_update_user_duplicate_email_error(client, create_user_in_database):\n    user_data_1 = {\n        \"user_id\": uuid4(),\n        \"name\": \"Nikolai\",\n        \"surname\": \"Sviridov\",\n        \"email\": \"lol@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_data_2 = {\n        \"user_id\": uuid4(),\n        \"name\": \"Ivan\",\n        \"surname\": \"Ivanov\",\n        \"email\": \"ivan@kek.com\",\n        \"is_active\": True,\n        \"hashed_password\": \"SampleHashedPass\",\n        \"roles\": [PortalRole.ROLE_PORTAL_USER],\n    }\n    user_data_updated = {\n        \"email\": user_data_2[\"email\"],\n    }\n    for user_data in [user_data_1, user_data_2]:\n        await create_user_in_database(**user_data)\n    resp = client.patch(\n        f\"/user/?user_id={user_data_1['user_id']}\",\n        data=json.dumps(user_data_updated),\n        headers=create_test_auth_headers_for_user(user_data_1[\"email\"]),\n    )\n    assert resp.status_code == 503\n    assert (\n        'duplicate key value violates unique constraint \"users_email_key\"'\n        in resp.json()[\"detail\"]\n    )\n"}
{"type": "source_file", "path": "security.py", "content": "from datetime import datetime\nfrom datetime import timedelta\nfrom typing import Optional\n\nfrom jose import jwt\n\nimport settings\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(\n            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES\n        )\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(\n        to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM\n    )\n    return encoded_jwt\n"}
{"type": "source_file", "path": "migrations/versions/231618d4861b_comment.py", "content": "\"\"\"comment\n\nRevision ID: 231618d4861b\nRevises:\nCreate Date: 2023-03-04 15:26:18.382482\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\nfrom sqlalchemy.dialects import postgresql\n\n# revision identifiers, used by Alembic.\nrevision = \"231618d4861b\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"users\",\n        sa.Column(\"user_id\", postgresql.UUID(as_uuid=True), nullable=False),\n        sa.Column(\"name\", sa.String(), nullable=False),\n        sa.Column(\"surname\", sa.String(), nullable=False),\n        sa.Column(\"email\", sa.String(), nullable=False),\n        sa.Column(\"is_active\", sa.Boolean(), nullable=True),\n        sa.Column(\"hashed_password\", sa.String(), nullable=False),\n        sa.PrimaryKeyConstraint(\"user_id\"),\n        sa.UniqueConstraint(\"email\"),\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table(\"users\")\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "settings.py", "content": "\"\"\"File with settings and configs for the project\"\"\"\nfrom envparse import Env\n\nenv = Env()\n\nREAL_DATABASE_URL = env.str(\n    \"REAL_DATABASE_URL\",\n    default=\"postgresql+asyncpg://postgres:postgres@0.0.0.0:5432/postgres\",\n)  # connect string for the real database\nAPP_PORT = env.int(\"APP_PORT\")\n\nSECRET_KEY: str = env.str(\"SECRET_KEY\", default=\"secret_key\")\nALGORITHM: str = env.str(\"ALGORITHM\", default=\"HS256\")\nACCESS_TOKEN_EXPIRE_MINUTES: int = env.int(\"ACCESS_TOKEN_EXPIRE_MINUTES\", default=30)\nSENTRY_URL: str = env.str(\"SENTRY_URL\")\n\n# test envs\nTEST_DATABASE_URL = env.str(\n    \"TEST_DATABASE_URL\",\n    default=\"postgresql+asyncpg://postgres_test:postgres_test@0.0.0.0:5433/postgres_test\",\n)  # connect string for the test database\n"}
{"type": "source_file", "path": "api/handlers.py", "content": "from logging import getLogger\nfrom uuid import UUID\n\nfrom fastapi import APIRouter\nfrom fastapi import Depends\nfrom fastapi import HTTPException\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom api.actions.auth import get_current_user_from_token\nfrom api.actions.user import _create_new_user\nfrom api.actions.user import _delete_user\nfrom api.actions.user import _get_user_by_id\nfrom api.actions.user import _update_user\nfrom api.actions.user import check_user_permissions\nfrom api.schemas import DeleteUserResponse\nfrom api.schemas import ShowUser\nfrom api.schemas import UpdatedUserResponse\nfrom api.schemas import UpdateUserRequest\nfrom api.schemas import UserCreate\nfrom db.models import User\nfrom db.session import get_db\n\nlogger = getLogger(__name__)\n\nuser_router = APIRouter()\n\n\n@user_router.post(\"/\", response_model=ShowUser)\nasync def create_user(body: UserCreate, db: AsyncSession = Depends(get_db)) -> ShowUser:\n    try:\n        return await _create_new_user(body, db)\n    except IntegrityError as err:\n        logger.error(err)\n        raise HTTPException(status_code=503, detail=f\"Database error: {err}\")\n\n\n@user_router.delete(\"/\", response_model=DeleteUserResponse)\nasync def delete_user(\n    user_id: UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user_from_token),\n) -> DeleteUserResponse:\n    user_for_deletion = await _get_user_by_id(user_id, db)\n    if user_for_deletion is None:\n        raise HTTPException(\n            status_code=404, detail=f\"User with id {user_id} not found.\"\n        )\n    if not check_user_permissions(\n        target_user=user_for_deletion,\n        current_user=current_user,\n    ):\n        raise HTTPException(status_code=403, detail=\"Forbidden.\")\n    deleted_user_id = await _delete_user(user_id, db)\n    if deleted_user_id is None:\n        raise HTTPException(\n            status_code=404, detail=f\"User with id {user_id} not found.\"\n        )\n    return DeleteUserResponse(deleted_user_id=deleted_user_id)\n\n\n@user_router.patch(\"/admin_privilege\", response_model=UpdatedUserResponse)\nasync def grant_admin_privilege(\n    user_id: UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user_from_token),\n):\n    if not current_user.is_superadmin:\n        raise HTTPException(status_code=403, detail=\"Forbidden.\")\n    if current_user.user_id == user_id:\n        raise HTTPException(\n            status_code=400, detail=\"Cannot manage privileges of itself.\"\n        )\n    user_for_promotion = await _get_user_by_id(user_id, db)\n    if user_for_promotion.is_admin or user_for_promotion.is_superadmin:\n        raise HTTPException(\n            status_code=409,\n            detail=f\"User with id {user_id} already promoted to admin / superadmin.\",\n        )\n    if user_for_promotion is None:\n        raise HTTPException(\n            status_code=404, detail=f\"User with id {user_id} not found.\"\n        )\n    updated_user_params = {\n        \"roles\": user_for_promotion.enrich_admin_roles_by_admin_role()\n    }\n    try:\n        updated_user_id = await _update_user(\n            updated_user_params=updated_user_params, session=db, user_id=user_id\n        )\n    except IntegrityError as err:\n        logger.error(err)\n        raise HTTPException(status_code=503, detail=f\"Database error: {err}\")\n    return UpdatedUserResponse(updated_user_id=updated_user_id)\n\n\n@user_router.delete(\"/admin_privilege\", response_model=UpdatedUserResponse)\nasync def revoke_admin_privilege(\n    user_id: UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user_from_token),\n):\n    if not current_user.is_superadmin:\n        raise HTTPException(status_code=403, detail=\"Forbidden.\")\n    if current_user.user_id == user_id:\n        raise HTTPException(\n            status_code=400, detail=\"Cannot manage privileges of itself.\"\n        )\n    user_for_revoke_admin_privileges = await _get_user_by_id(user_id, db)\n    if not user_for_revoke_admin_privileges.is_admin:\n        raise HTTPException(\n            status_code=409, detail=f\"User with id {user_id} has no admin privileges.\"\n        )\n    if user_for_revoke_admin_privileges is None:\n        raise HTTPException(\n            status_code=404, detail=f\"User with id {user_id} not found.\"\n        )\n    updated_user_params = {\n        \"roles\": user_for_revoke_admin_privileges.remove_admin_privileges_from_model()\n    }\n    try:\n        updated_user_id = await _update_user(\n            updated_user_params=updated_user_params, session=db, user_id=user_id\n        )\n    except IntegrityError as err:\n        logger.error(err)\n        raise HTTPException(status_code=503, detail=f\"Database error: {err}\")\n    return UpdatedUserResponse(updated_user_id=updated_user_id)\n\n\n@user_router.get(\"/\", response_model=ShowUser)\nasync def get_user_by_id(\n    user_id: UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user_from_token),\n) -> ShowUser:\n    user = await _get_user_by_id(user_id, db)\n    if user is None:\n        raise HTTPException(\n            status_code=404, detail=f\"User with id {user_id} not found.\"\n        )\n    return user\n\n\n@user_router.patch(\"/\", response_model=UpdatedUserResponse)\nasync def update_user_by_id(\n    user_id: UUID,\n    body: UpdateUserRequest,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user_from_token),\n) -> UpdatedUserResponse:\n    updated_user_params = body.dict(exclude_none=True)\n    if updated_user_params == {}:\n        raise HTTPException(\n            status_code=422,\n            detail=\"At least one parameter for user update info should be provided\",\n        )\n    user_for_update = await _get_user_by_id(user_id, db)\n    if user_for_update is None:\n        raise HTTPException(\n            status_code=404, detail=f\"User with id {user_id} not found.\"\n        )\n    if user_id != current_user.user_id:\n        if check_user_permissions(\n            target_user=user_for_update, current_user=current_user\n        ):\n            raise HTTPException(status_code=403, detail=\"Forbidden.\")\n    try:\n        updated_user_id = await _update_user(\n            updated_user_params=updated_user_params, session=db, user_id=user_id\n        )\n    except IntegrityError as err:\n        logger.error(err)\n        raise HTTPException(status_code=503, detail=f\"Database error: {err}\")\n    return UpdatedUserResponse(updated_user_id=updated_user_id)\n"}
{"type": "source_file", "path": "api/actions/user.py", "content": "from typing import Union\nfrom uuid import UUID\n\nfrom fastapi import HTTPException\n\nfrom api.schemas import ShowUser\nfrom api.schemas import UserCreate\nfrom db.dals import UserDAL\nfrom db.models import PortalRole\nfrom db.models import User\nfrom hashing import Hasher\n\n\nasync def _create_new_user(body: UserCreate, session) -> ShowUser:\n    async with session.begin():\n        user_dal = UserDAL(session)\n        user = await user_dal.create_user(\n            name=body.name,\n            surname=body.surname,\n            email=body.email,\n            hashed_password=Hasher.get_password_hash(body.password),\n            roles=[\n                PortalRole.ROLE_PORTAL_USER,\n            ],\n        )\n        return ShowUser(\n            user_id=user.user_id,\n            name=user.name,\n            surname=user.surname,\n            email=user.email,\n            is_active=user.is_active,\n        )\n\n\nasync def _delete_user(user_id, session) -> Union[UUID, None]:\n    async with session.begin():\n        user_dal = UserDAL(session)\n        deleted_user_id = await user_dal.delete_user(\n            user_id=user_id,\n        )\n        return deleted_user_id\n\n\nasync def _update_user(\n    updated_user_params: dict, user_id: UUID, session\n) -> Union[UUID, None]:\n    async with session.begin():\n        user_dal = UserDAL(session)\n        updated_user_id = await user_dal.update_user(\n            user_id=user_id, **updated_user_params\n        )\n        return updated_user_id\n\n\nasync def _get_user_by_id(user_id, session) -> Union[User, None]:\n    async with session.begin():\n        user_dal = UserDAL(session)\n        user = await user_dal.get_user_by_id(\n            user_id=user_id,\n        )\n        if user is not None:\n            return user\n\n\ndef check_user_permissions(target_user: User, current_user: User) -> bool:\n    if PortalRole.ROLE_PORTAL_SUPERADMIN in current_user.roles:\n        raise HTTPException(\n            status_code=406, detail=\"Superadmin cannot be deleted via API.\"\n        )\n    if target_user.user_id != current_user.user_id:\n        # check admin role\n        if not {\n            PortalRole.ROLE_PORTAL_ADMIN,\n            PortalRole.ROLE_PORTAL_SUPERADMIN,\n        }.intersection(current_user.roles):\n            return False\n        # check admin deactivate superadmin attempt\n        if (\n            PortalRole.ROLE_PORTAL_SUPERADMIN in target_user.roles\n            and PortalRole.ROLE_PORTAL_ADMIN in current_user.roles\n        ):\n            return False\n        # check admin deactivate admin attempt\n        if (\n            PortalRole.ROLE_PORTAL_ADMIN in target_user.roles\n            and PortalRole.ROLE_PORTAL_ADMIN in current_user.roles\n        ):\n            return False\n    return True\n"}
{"type": "source_file", "path": "api/actions/auth.py", "content": "from typing import Union\n\nfrom fastapi import Depends\nfrom fastapi import HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import jwt\nfrom jose import JWTError\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom starlette import status\n\nimport settings\nfrom db.dals import UserDAL\nfrom db.models import User\nfrom db.session import get_db\nfrom hashing import Hasher\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/login/token\")\n\n\nasync def _get_user_by_email_for_auth(email: str, session: AsyncSession):\n    async with session.begin():\n        user_dal = UserDAL(session)\n        return await user_dal.get_user_by_email(\n            email=email,\n        )\n\n\nasync def authenticate_user(\n    email: str, password: str, db: AsyncSession\n) -> Union[User, None]:\n    user = await _get_user_by_email_for_auth(email=email, session=db)\n    if user is None:\n        return\n    if not Hasher.verify_password(password, user.hashed_password):\n        return\n    return user\n\n\nasync def get_current_user_from_token(\n    token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)\n):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n    )\n    try:\n        payload = jwt.decode(\n            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]\n        )\n        email: str = payload.get(\"sub\")\n        if email is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    user = await _get_user_by_email_for_auth(email=email, session=db)\n    if user is None:\n        raise credentials_exception\n    return user\n"}
{"type": "source_file", "path": "api/login_handler.py", "content": "from datetime import timedelta\n\nfrom fastapi import APIRouter\nfrom fastapi import Depends\nfrom fastapi import HTTPException\nfrom fastapi import status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nimport settings\nfrom api.actions.auth import authenticate_user\nfrom api.schemas import Token\nfrom db.session import get_db\nfrom security import create_access_token\n\nlogin_router = APIRouter()\n\n\n@login_router.post(\"/token\", response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_db)\n):\n    user = await authenticate_user(form_data.username, form_data.password, db)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n        )\n    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.email, \"other_custom_data\": [1, 2, 3, 4]},\n        expires_delta=access_token_expires,\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n"}
{"type": "source_file", "path": "api/schemas.py", "content": "import re\nimport uuid\nfrom typing import Optional\n\nfrom fastapi import HTTPException\nfrom pydantic import BaseModel\nfrom pydantic import constr\nfrom pydantic import EmailStr\nfrom pydantic import validator\n\n#########################\n# BLOCK WITH API MODELS #\n#########################\n\nLETTER_MATCH_PATTERN = re.compile(r\"^[а-яА-Яa-zA-Z\\-]+$\")\n\n\nclass TunedModel(BaseModel):\n    class Config:\n        \"\"\"tells pydantic to convert even non dict obj to json\"\"\"\n\n        orm_mode = True\n\n\nclass ShowUser(TunedModel):\n    user_id: uuid.UUID\n    name: str\n    surname: str\n    email: EmailStr\n    is_active: bool\n\n\nclass UserCreate(BaseModel):\n    name: str\n    surname: str\n    email: EmailStr\n    password: str\n\n    @validator(\"name\")\n    def validate_name(cls, value):\n        if not LETTER_MATCH_PATTERN.match(value):\n            raise HTTPException(\n                status_code=422, detail=\"Name should contains only letters\"\n            )\n        return value\n\n    @validator(\"surname\")\n    def validate_surname(cls, value):\n        if not LETTER_MATCH_PATTERN.match(value):\n            raise HTTPException(\n                status_code=422, detail=\"Surname should contains only letters\"\n            )\n        return value\n\n\nclass DeleteUserResponse(BaseModel):\n    deleted_user_id: uuid.UUID\n\n\nclass UpdatedUserResponse(BaseModel):\n    updated_user_id: uuid.UUID\n\n\nclass UpdateUserRequest(BaseModel):\n    name: Optional[constr(min_length=1)]\n    surname: Optional[constr(min_length=1)]\n    email: Optional[EmailStr]\n\n    @validator(\"name\")\n    def validate_name(cls, value):\n        if not LETTER_MATCH_PATTERN.match(value):\n            raise HTTPException(\n                status_code=422, detail=\"Name should contains only letters\"\n            )\n        return value\n\n    @validator(\"surname\")\n    def validate_surname(cls, value):\n        if not LETTER_MATCH_PATTERN.match(value):\n            raise HTTPException(\n                status_code=422, detail=\"Surname should contains only letters\"\n            )\n        return value\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n"}
{"type": "source_file", "path": "db/dals.py", "content": "from typing import Union\nfrom uuid import UUID\n\nfrom sqlalchemy import and_\nfrom sqlalchemy import select\nfrom sqlalchemy import update\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom db.models import PortalRole\nfrom db.models import User\n\n\n###########################################################\n# BLOCK FOR INTERACTION WITH DATABASE IN BUSINESS CONTEXT #\n###########################################################\n\n\nclass UserDAL:\n    \"\"\"Data Access Layer for operating user info\"\"\"\n\n    def __init__(self, db_session: AsyncSession):\n        self.db_session = db_session\n\n    async def create_user(\n        self,\n        name: str,\n        surname: str,\n        email: str,\n        hashed_password: str,\n        roles: list[PortalRole],\n    ) -> User:\n        new_user = User(\n            name=name,\n            surname=surname,\n            email=email,\n            hashed_password=hashed_password,\n            roles=roles,\n        )\n        self.db_session.add(new_user)\n        await self.db_session.flush()\n        return new_user\n\n    async def delete_user(self, user_id: UUID) -> Union[UUID, None]:\n        query = (\n            update(User)\n            .where(and_(User.user_id == user_id, User.is_active == True))\n            .values(is_active=False)\n            .returning(User.user_id)\n        )\n        res = await self.db_session.execute(query)\n        deleted_user_id_row = res.fetchone()\n        if deleted_user_id_row is not None:\n            return deleted_user_id_row[0]\n\n    async def get_user_by_id(self, user_id: UUID) -> Union[User, None]:\n        query = select(User).where(User.user_id == user_id)\n        res = await self.db_session.execute(query)\n        user_row = res.fetchone()\n        if user_row is not None:\n            return user_row[0]\n\n    async def get_user_by_email(self, email: str) -> Union[User, None]:\n        query = select(User).where(User.email == email)\n        res = await self.db_session.execute(query)\n        user_row = res.fetchone()\n        if user_row is not None:\n            return user_row[0]\n\n    async def update_user(self, user_id: UUID, **kwargs) -> Union[UUID, None]:\n        query = (\n            update(User)\n            .where(and_(User.user_id == user_id, User.is_active == True))\n            .values(kwargs)\n            .returning(User.user_id)\n        )\n        res = await self.db_session.execute(query)\n        update_user_id_row = res.fetchone()\n        if update_user_id_row is not None:\n            return update_user_id_row[0]\n"}
{"type": "source_file", "path": "api/service.py", "content": "from fastapi import APIRouter\n\nservice_router = login_router = APIRouter()\n\n\n@service_router.get(\"/ping\")\nasync def ping():\n    return {\"Success\": True}\n"}
{"type": "source_file", "path": "migrations/env.py", "content": "import os\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nfrom db.models import Base\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\ntarget_metadata = Base.metadata\n# target_metadata = None\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n# todo luchanos should be explained\n# we don't want to get database url from alembic.ini - now we take it from env variables\nurl = os.environ.get(\"ALEMBIC_DATABASE_URL\", config.get_main_option(\"sqlalchemy.url\"))\n\n\n# FOR LOCAL MIGRATIONS ONLY\n# url = config.get_main_option(\"sqlalchemy.url\")\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    config_section = config.get_section(config.config_ini_section)\n    config_section[\"sqlalchemy.url\"] = url\n\n    connectable = engine_from_config(\n        config_section,\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(connection=connection, target_metadata=target_metadata)\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "hashing.py", "content": "from passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\nclass Hasher:\n    @staticmethod\n    def verify_password(plain_password: str, hashed_password: str) -> bool:\n        return pwd_context.verify(plain_password, hashed_password)\n\n    @staticmethod\n    def get_password_hash(password: str) -> str:\n        return pwd_context.hash(password)\n"}
{"type": "source_file", "path": "migrations/versions/02c707084417_comment.py", "content": "\"\"\"comment\n\nRevision ID: 02c707084417\nRevises: c86fcc9d8dee\nCreate Date: 2023-03-04 16:24:52.410033\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\nfrom sqlalchemy.dialects import postgresql\n\n# revision identifiers, used by Alembic.\nrevision = \"02c707084417\"\ndown_revision = \"c86fcc9d8dee\"\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.add_column(\n        \"users\", sa.Column(\"roles\", postgresql.ARRAY(sa.String()), nullable=False)\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_column(\"users\", \"roles\")\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "db/models.py", "content": "import uuid\nfrom enum import Enum\n\nfrom sqlalchemy import Boolean\nfrom sqlalchemy import Column\nfrom sqlalchemy import String\nfrom sqlalchemy.dialects.postgresql import ARRAY\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy.orm import declarative_base\n\n##############################\n# BLOCK WITH DATABASE MODELS #\n##############################\n\nBase = declarative_base()\n\n\nclass PortalRole(str, Enum):\n    ROLE_PORTAL_USER = \"ROLE_PORTAL_USER\"\n    ROLE_PORTAL_ADMIN = \"ROLE_PORTAL_ADMIN\"\n    ROLE_PORTAL_SUPERADMIN = \"ROLE_PORTAL_SUPERADMIN\"\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    user_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(String, nullable=False)\n    surname = Column(String, nullable=False)\n    email = Column(String, nullable=False, unique=True)\n    is_active = Column(Boolean(), default=True)\n    hashed_password = Column(String, nullable=False)\n    roles = Column(ARRAY(String), nullable=False)\n\n    @property\n    def is_superadmin(self) -> bool:\n        return PortalRole.ROLE_PORTAL_SUPERADMIN in self.roles\n\n    @property\n    def is_admin(self) -> bool:\n        return PortalRole.ROLE_PORTAL_ADMIN in self.roles\n\n    def enrich_admin_roles_by_admin_role(self):\n        if not self.is_admin:\n            return {*self.roles, PortalRole.ROLE_PORTAL_ADMIN}\n\n    def remove_admin_privileges_from_model(self):\n        if self.is_admin:\n            return {role for role in self.roles if role != PortalRole.ROLE_PORTAL_ADMIN}\n"}
{"type": "source_file", "path": "db/session.py", "content": "from typing import Generator\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nimport settings\n\n##############################################\n# BLOCK FOR COMMON INTERACTION WITH DATABASE #\n##############################################\n\n# create async engine for interaction with database\nengine = create_async_engine(\n    settings.REAL_DATABASE_URL,\n    future=True,\n    echo=True,\n    execution_options={\"isolation_level\": \"AUTOCOMMIT\"},\n)\n\n# create session for the interaction with database\nasync_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)\n\n\nasync def get_db() -> Generator:\n    \"\"\"Dependency for getting async session\"\"\"\n    try:\n        session: AsyncSession = async_session()\n        yield session\n    finally:\n        await session.close()\n"}
{"type": "source_file", "path": "main.py", "content": "import sentry_sdk\nimport uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.routing import APIRouter\nfrom starlette_exporter import handle_metrics\nfrom starlette_exporter import PrometheusMiddleware\n\nimport settings\nfrom api.handlers import user_router\nfrom api.login_handler import login_router\nfrom api.service import service_router\n\n# sentry configuration\nsentry_sdk.init(\n    dsn=settings.SENTRY_URL,\n    # Set traces_sample_rate to 1.0 to capture 100%\n    # of transactions for performance monitoring.\n    # We recommend adjusting this value in production,\n    traces_sample_rate=1.0,\n)\n\n#########################\n# BLOCK WITH API ROUTES #\n#########################\n\n# create instance of the app\napp = FastAPI(title=\"luchanos-oxford-university\")\napp.add_middleware(PrometheusMiddleware)\napp.add_route(\"/metrics\", handle_metrics)\n\n# create the instance for the routes\nmain_api_router = APIRouter()\n\n# set routes to the app instance\nmain_api_router.include_router(user_router, prefix=\"/user\", tags=[\"user\"])\nmain_api_router.include_router(login_router, prefix=\"/login\", tags=[\"login\"])\nmain_api_router.include_router(service_router, tags=[\"service\"])\napp.include_router(main_api_router)\n\nif __name__ == \"__main__\":\n    # run app on the host and port\n    uvicorn.run(app, host=\"0.0.0.0\", port=settings.APP_PORT)\n"}

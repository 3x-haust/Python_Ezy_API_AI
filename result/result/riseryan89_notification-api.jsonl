{"repo_info": {"repo_name": "notification-api", "repo_owner": "riseryan89", "repo_url": "https://github.com/riseryan89/notification-api"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/test_user.py", "content": "from app.database.conn import db\nfrom app.database.schema import Users\n\n\ndef test_create_get_apikey(client, session, login):\n    \"\"\"\n    레버 로그인\n    :param client:\n    :param session:\n    :return:\n    \"\"\"\n    key = dict(user_memo=\"ryan__key\")\n    res = client.post(\"api/user/apikeys\", json=key, headers=login)\n    res_body = res.json()\n    assert res.status_code == 200\n    assert \"secret_key\" in res_body\n\n    res = client.get(\"api/user/apikeys\", headers=login)\n    res_body = res.json()\n    assert res.status_code == 200\n    assert \"ryan__key\" in res_body[0][\"user_memo\"]\n\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "import asyncio\nimport os\nfrom os import path\nfrom typing import List\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\n\nfrom app.database.schema import Users\nfrom app.main import create_app\nfrom app.database.conn import db, Base\nfrom app.models import UserToken\nfrom app.routes.auth import create_access_token\n\n\n\"\"\"\n1. DB 생성\n2. 테이블 생성\n3. 테스트 코드 작동\n4. 테이블 레코드 삭제 \n\"\"\"\n\n@pytest.fixture(scope=\"session\")\ndef app():\n    os.environ[\"API_ENV\"] = \"test\"\n    return create_app()\n\n\n@pytest.fixture(scope=\"session\")\ndef client(app):\n    # Create tables\n    Base.metadata.create_all(db.engine)\n    return TestClient(app=app)\n\n\n@pytest.fixture(scope=\"function\", autouse=True)\ndef session():\n    sess = next(db.session())\n    yield sess\n    clear_all_table_data(\n        session=sess,\n        metadata=Base.metadata,\n        except_tables=[]\n    )\n    sess.rollback()\n\n\n@pytest.fixture(scope=\"function\")\ndef login(session):\n    \"\"\"\n    테스트전 사용자 미리 등록\n    :param session:\n    :return:\n    \"\"\"\n    db_user = Users.create(session=session, email=\"ryan_test@dingrr.com\", pw=\"123\")\n    session.commit()\n    access_token = create_access_token(data=UserToken.from_orm(db_user).dict(exclude={'pw', 'marketing_agree'}),)\n    return dict(Authorization=f\"Bearer {access_token}\")\n\n\ndef clear_all_table_data(session: Session, metadata, except_tables: List[str] = None):\n    session.execute(\"SET FOREIGN_KEY_CHECKS = 0;\")\n    for table in metadata.sorted_tables:\n        if table.name not in except_tables:\n            session.execute(table.delete())\n    session.execute(\"SET FOREIGN_KEY_CHECKS = 1;\")\n    session.commit()\n"}
{"type": "test_file", "path": "tests/test_auth.py", "content": "from app.database.conn import db\nfrom app.database.schema import Users\n\n\ndef test_registration(client, session):\n    \"\"\"\n    레버 로그인\n    :param client:\n    :param session:\n    :return:\n    \"\"\"\n    user = dict(email=\"ryan@dingrr.com\", pw=\"123\", name=\"라이언\", phone=\"01099999999\")\n    res = client.post(\"api/auth/register/email\", json=user)\n    res_body = res.json()\n    print(res.json())\n    assert res.status_code == 201\n    assert \"Authorization\" in res_body.keys()\n\n\ndef test_registration_exist_email(client, session):\n    \"\"\"\n    레버 로그인\n    :param client:\n    :param session:\n    :return:\n    \"\"\"\n    user = dict(email=\"Hello@dingrr.com\", pw=\"123\", name=\"라이언\", phone=\"01099999999\")\n    db_user = Users.create(session=session, **user)\n    session.commit()\n    res = client.post(\"api/auth/register/email\", json=user)\n    res_body = res.json()\n    assert res.status_code == 400\n    assert 'EMAIL_EXISTS' == res_body[\"msg\"]\n"}
{"type": "source_file", "path": "app/api_request_sample.py", "content": "import base64\nimport hmac\nfrom datetime import datetime, timedelta\n\nimport requests\n\n\ndef parse_params_to_str(params):\n    url = \"?\"\n    for key, value in params.items():\n        url = url + str(key) + '=' + str(value) + '&'\n    return url[1:-1]\n\n\ndef hash_string(qs, secret_key):\n    mac = hmac.new(bytes(secret_key, encoding='utf8'), bytes(qs, encoding='utf-8'), digestmod='sha256')\n    d = mac.digest()\n    validating_secret = str(base64.b64encode(d).decode('utf-8'))\n    return validating_secret\n\n\ndef sample_request():\n    access_key = \"c0883231-4aa9-4a1f-a77b-3ef250af-e449-42e9-856a-b3ada17c426b\"\n    secret_key = \"QhOaeXTAAkW6yWt31jWDeERkBsZ3X4UmPds656YD\"\n    cur_time = datetime.utcnow()+timedelta(hours=9)\n    cur_timestamp = int(cur_time.timestamp())\n    qs = dict(key=access_key, timestamp=cur_timestamp)\n    header_secret = hash_string(parse_params_to_str(qs), secret_key)\n\n    url = f\"http://127.0.0.1:8080/api/services?{parse_params_to_str(qs)}\"\n    res = requests.get(url, headers=dict(secret=header_secret))\n    return res\n\n\nprint(sample_request().json())\n\n\n\n\n\n\"\"\"\n채널톡 사업자!\n친구에게 전송\n나에게 전송\n\"\"\"\n\n\n\n\n\n\n\n\n"}
{"type": "source_file", "path": "app/database/crud.py", "content": ""}
{"type": "source_file", "path": "app/main.py", "content": "from dataclasses import asdict\nfrom typing import Optional\n\nimport uvicorn\nfrom fastapi import FastAPI, Depends\nfrom fastapi.security import APIKeyHeader\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom app.common.consts import EXCEPT_PATH_LIST, EXCEPT_PATH_REGEX\nfrom app.database.conn import db\nfrom app.common.config import conf\nfrom app.middlewares.token_validator import access_control\nfrom app.middlewares.trusted_hosts import TrustedHostMiddleware\nfrom app.routes import index, auth, users, services\n\nAPI_KEY_HEADER = APIKeyHeader(name=\"Authorization\", auto_error=False)\n\n\ndef create_app():\n    \"\"\"\n    앱 함수 실행\n    :return:\n    \"\"\"\n    c = conf()\n    app = FastAPI()\n    conf_dict = asdict(c)\n    db.init_app(app, **conf_dict)\n    # 데이터 베이스 이니셜라이즈\n\n    # 레디스 이니셜라이즈\n\n    # 미들웨어 정의\n    app.add_middleware(middleware_class=BaseHTTPMiddleware, dispatch=access_control)\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=conf().ALLOW_SITE,\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    app.add_middleware(TrustedHostMiddleware, allowed_hosts=conf().TRUSTED_HOSTS, except_path=[\"/health\"])\n\n    # 라우터 정의\n    app.include_router(index.router)\n    app.include_router(auth.router, tags=[\"Authentication\"], prefix=\"/api\")\n    if conf().DEBUG:\n        app.include_router(services.router, tags=[\"Services\"], prefix=\"/api\", dependencies=[Depends(API_KEY_HEADER)])\n    else:\n        app.include_router(services.router, tags=[\"Services\"], prefix=\"/api\")\n    app.include_router(users.router, tags=[\"Users\"], prefix=\"/api\", dependencies=[Depends(API_KEY_HEADER)])\n    return app\n\n\napp = create_app()\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8080, reload=True)\n"}
{"type": "source_file", "path": "app/routes/users.py", "content": "from typing import List\nfrom uuid import uuid4\n\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import Session\nfrom starlette.requests import Request\n\nfrom app.common.consts import MAX_API_KEY, MAX_API_WHITELIST\nfrom app.database.conn import db\nfrom app.database.schema import Users, ApiKeys, ApiWhiteLists\nfrom app import models as m\nfrom app.errors import exceptions as ex\nimport string\nimport secrets\n\nfrom app.models import MessageOk, UserMe\n\nrouter = APIRouter(prefix='/user')\n\n\n@router.get('/me', response_model=UserMe)\nasync def get_me(request: Request):\n    user = request.state.user\n    user_info = Users.get(id=user.id)\n    return user_info\n\n\n@router.put('/me')\nasync def put_me(request: Request):\n    ...\n\n\n@router.delete('/me')\nasync def delete_me(request: Request):\n    ...\n\n\n@router.get('/apikeys', response_model=List[m.GetApiKeyList])\nasync def get_api_keys(request: Request):\n    \"\"\"\n    API KEY 조회\n    :param request:\n    :return:\n    \"\"\"\n    user = request.state.user\n    api_keys = ApiKeys.filter(user_id=user.id).all()\n    return api_keys\n\n\n@router.post('/apikeys', response_model=m.GetApiKeys)\nasync def create_api_keys(request: Request, key_info: m.AddApiKey, session: Session = Depends(db.session)):\n    \"\"\"\n    API KEY 생성\n    :param request:\n    :param key_info:\n    :param session:\n    :return:\n    \"\"\"\n    user = request.state.user\n\n    api_keys = ApiKeys.filter(session, user_id=user.id, status='active').count()\n    if api_keys == MAX_API_KEY:\n        raise ex.MaxKeyCountEx()\n\n    alphabet = string.ascii_letters + string.digits\n    s_key = ''.join(secrets.choice(alphabet) for _ in range(40))\n    uid = None\n    while not uid:\n        uid_candidate = f\"{str(uuid4())[:-12]}{str(uuid4())}\"\n        uid_check = ApiKeys.get(access_key=uid_candidate)\n        if not uid_check:\n            uid = uid_candidate\n\n    key_info = key_info.dict()\n    new_key = ApiKeys.create(session, auto_commit=True, secret_key=s_key, user_id=user.id, access_key=uid, **key_info)\n    return new_key\n\n\n@router.put('/apikeys/{key_id}', response_model=m.GetApiKeyList)\nasync def update_api_keys(request: Request, key_id: int, key_info: m.AddApiKey):\n    \"\"\"\n    API KEY User Memo Update\n    :param request:\n    :param key_id:\n    :param key_info:\n    :return:\n    \"\"\"\n    user = request.state.user\n    key_data = ApiKeys.filter(id=key_id)\n    if key_data and key_data.first().user_id == user.id:\n        return key_data.update(auto_commit=True, **key_info.dict())\n    raise ex.NoKeyMatchEx()\n\n\n@router.delete('/apikeys/{key_id}')\nasync def delete_api_keys(request: Request, key_id: int, access_key: str):\n    user = request.state.user\n    await check_api_owner(user.id, key_id)\n    search_by_key = ApiKeys.filter(access_key=access_key)\n    if not search_by_key.first():\n        raise ex.NoKeyMatchEx()\n    search_by_key.delete(auto_commit=True)\n    return MessageOk()\n\n\n@router.get('/apikeys/{key_id}/whitelists', response_model=List[m.GetAPIWhiteLists])\nasync def get_api_keys(request: Request, key_id: int):\n    user = request.state.user\n    await check_api_owner(user.id, key_id)\n    whitelists = ApiWhiteLists.filter(api_key_id=key_id).all()\n    return whitelists\n\n\n@router.post('/apikeys/{key_id}/whitelists', response_model=m.GetAPIWhiteLists)\nasync def create_api_keys(request: Request, key_id: int, ip: m.CreateAPIWhiteLists, session: Session = Depends(db.session)):\n    user = request.state.user\n    await check_api_owner(user.id, key_id)\n    import ipaddress\n    try:\n        _ip = ipaddress.ip_address(ip.ip_addr)\n    except Exception as e:\n        raise ex.InvalidIpEx(ip.ip_addr, e)\n    if ApiWhiteLists.filter(api_key_id=key_id).count() == MAX_API_WHITELIST:\n        raise ex.MaxWLCountEx()\n    ip_dup = ApiWhiteLists.get(api_key_id=key_id, ip_addr=ip.ip_addr)\n    if ip_dup:\n        return ip_dup\n    ip_reg = ApiWhiteLists.create(session=session, auto_commit=True, api_key_id=key_id, ip_addr=ip.ip_addr)\n    return ip_reg\n\n\n@router.delete('/apikeys/{key_id}/whitelists/{list_id}')\nasync def delete_api_keys(request: Request, key_id: int, list_id: int):\n    user = request.state.user\n    await check_api_owner(user.id, key_id)\n    ApiWhiteLists.filter(id=list_id, api_key_id=key_id).delete()\n\n    return MessageOk()\n\n\nasync def check_api_owner(user_id, key_id):\n    api_keys = ApiKeys.get(id=key_id, user_id=user_id)\n    if not api_keys:\n        raise ex.NoKeyMatchEx()\n"}
{"type": "source_file", "path": "app/middlewares/trusted_hosts.py", "content": "import typing\n\n\nfrom starlette.datastructures import URL, Headers\nfrom starlette.responses import PlainTextResponse, RedirectResponse, Response\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nENFORCE_DOMAIN_WILDCARD = \"Domain wildcard patterns must be like '*.example.com'.\"\n\n\nclass TrustedHostMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        allowed_hosts: typing.Sequence[str] = None,\n        except_path: typing.Sequence[str] = None,\n        www_redirect: bool = True,\n    ) -> None:\n        if allowed_hosts is None:\n            allowed_hosts = [\"*\"]\n        if except_path is None:\n            except_path = []\n        for pattern in allowed_hosts:\n            assert \"*\" not in pattern[1:], ENFORCE_DOMAIN_WILDCARD\n            if pattern.startswith(\"*\") and pattern != \"*\":\n                assert pattern.startswith(\"*.\"), ENFORCE_DOMAIN_WILDCARD\n        self.app = app\n        self.allowed_hosts = list(allowed_hosts)\n        self.allow_any = \"*\" in allowed_hosts\n        self.www_redirect = www_redirect\n        self.except_path = list(except_path)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.allow_any or scope[\"type\"] not in (\"http\", \"websocket\",):  # pragma: no cover\n            await self.app(scope, receive, send)\n            return\n\n        headers = Headers(scope=scope)\n        host = headers.get(\"host\", \"\").split(\":\")[0]\n        is_valid_host = False\n        found_www_redirect = False\n        for pattern in self.allowed_hosts:\n            if (\n                host == pattern\n                or (pattern.startswith(\"*\") and host.endswith(pattern[1:]))\n                or URL(scope=scope).path in self.except_path\n            ):\n                is_valid_host = True\n                break\n            elif \"www.\" + host == pattern:\n                found_www_redirect = True\n\n        if is_valid_host:\n            await self.app(scope, receive, send)\n        else:\n            if found_www_redirect and self.www_redirect:\n                url = URL(scope=scope)\n                redirect_url = url.replace(netloc=\"www.\" + url.netloc)\n                response = RedirectResponse(url=str(redirect_url))  # type: Response\n            else:\n                response = PlainTextResponse(\"Invalid host header\", status_code=400)\n\n            await response(scope, receive, send)\n"}
{"type": "source_file", "path": "app/errors/exceptions.py", "content": "from app.common.consts import MAX_API_KEY, MAX_API_WHITELIST\n\n\nclass StatusCode:\n    HTTP_500 = 500\n    HTTP_400 = 400\n    HTTP_401 = 401\n    HTTP_403 = 403\n    HTTP_404 = 404\n    HTTP_405 = 405\n\n\nclass APIException(Exception):\n    status_code: int\n    code: str\n    msg: str\n    detail: str\n    ex: Exception\n\n    def __init__(\n        self,\n        *,\n        status_code: int = StatusCode.HTTP_500,\n        code: str = \"000000\",\n        msg: str = None,\n        detail: str = None,\n        ex: Exception = None,\n    ):\n        self.status_code = status_code\n        self.code = code\n        self.msg = msg\n        self.detail = detail\n        self.ex = ex\n        super().__init__(ex)\n\n\nclass NotFoundUserEx(APIException):\n    def __init__(self, user_id: int = None, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_404,\n            msg=f\"해당 유저를 찾을 수 없습니다.\",\n            detail=f\"Not Found User ID : {user_id}\",\n            code=f\"{StatusCode.HTTP_400}{'1'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass NotAuthorized(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_401,\n            msg=f\"로그인이 필요한 서비스 입니다.\",\n            detail=\"Authorization Required\",\n            code=f\"{StatusCode.HTTP_401}{'1'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass TokenExpiredEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_400,\n            msg=f\"세션이 만료되어 로그아웃 되었습니다.\",\n            detail=\"Token Expired\",\n            code=f\"{StatusCode.HTTP_400}{'1'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass TokenDecodeEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_400,\n            msg=f\"비정상적인 접근입니다.\",\n            detail=\"Token has been compromised.\",\n            code=f\"{StatusCode.HTTP_400}{'2'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass NoKeyMatchEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_404,\n            msg=f\"해당 키에 대한 권한이 없거나 해당 키가 없습니다.\",\n            detail=\"No Keys Matched\",\n            code=f\"{StatusCode.HTTP_404}{'3'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass MaxKeyCountEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_400,\n            msg=f\"API 키 생성은 {MAX_API_KEY}개 까지 가능합니다.\",\n            detail=\"Max Key Count Reached\",\n            code=f\"{StatusCode.HTTP_400}{'4'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass MaxWLCountEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_400,\n            msg=f\"화이트리스트 생성은 {MAX_API_WHITELIST}개 까지 가능합니다.\",\n            detail=\"Max Whitelist Count Reached\",\n            code=f\"{StatusCode.HTTP_400}{'5'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass InvalidIpEx(APIException):\n    def __init__(self, ip: str, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_400,\n            msg=f\"{ip}는 올바른 IP 가 아닙니다.\",\n            detail=f\"invalid IP : {ip}\",\n            code=f\"{StatusCode.HTTP_400}{'6'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass SqlFailureEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_500,\n            msg=f\"이 에러는 서버측 에러 입니다. 자동으로 리포팅 되며, 빠르게 수정하겠습니다.\",\n            detail=\"Internal Server Error\",\n            code=f\"{StatusCode.HTTP_500}{'2'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass APIQueryStringEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_400,\n            msg=f\"쿼리스트링은 key, timestamp 2개만 허용되며, 2개 모두 요청시 제출되어야 합니다.\",\n            detail=\"Query String Only Accept key and timestamp.\",\n            code=f\"{StatusCode.HTTP_400}{'7'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass APIHeaderInvalidEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_400,\n            msg=f\"헤더에 키 해싱된 Secret 이 없거나, 유효하지 않습니다.\",\n            detail=\"Invalid HMAC secret in Header\",\n            code=f\"{StatusCode.HTTP_400}{'8'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass APITimestampEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_400,\n            msg=f\"쿼리스트링에 포함된 타임스탬프는 KST 이며, 현재 시간보다 작아야 하고, 현재시간 - 10초 보다는 커야 합니다.\",\n            detail=\"timestamp in Query String must be KST, Timestamp must be less than now, and greater than now - 10.\",\n            code=f\"{StatusCode.HTTP_400}{'9'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass NotFoundAccessKeyEx(APIException):\n    def __init__(self, api_key: str,  ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_404,\n            msg=f\"API 키를 찾을 수 없습니다.\",\n            detail=f\"Not found such API Access Key : {api_key}\",\n            code=f\"{StatusCode.HTTP_404}{'10'.zfill(4)}\",\n            ex=ex,\n        )\n\n\nclass KakaoSendFailureEx(APIException):\n    def __init__(self, ex: Exception = None):\n        super().__init__(\n            status_code=StatusCode.HTTP_400,\n            msg=f\"카카오톡 전송에 실패했습니다.\",\n            detail=f\"Failed to send KAKAO MSG.\",\n            code=f\"{StatusCode.HTTP_400}{'11'.zfill(4)}\",\n            ex=ex,\n        )\n"}
{"type": "source_file", "path": "app/routes/auth.py", "content": "from datetime import datetime, timedelta\n\nimport bcrypt\nimport jwt\nfrom fastapi import APIRouter, Depends\n\n# TODO:\nfrom sqlalchemy.orm import Session\nfrom starlette.responses import JSONResponse\n\nfrom app.common.consts import JWT_SECRET, JWT_ALGORITHM\nfrom app.database.conn import db\nfrom app.database.schema import Users\nfrom app.models import SnsType, Token, UserToken, UserRegister\n\n\"\"\"\n1. 구글 로그인을 위한 구글 앱 준비 (구글 개발자 도구)\n2. FB 로그인을 위한 FB 앱 준비 (FB 개발자 도구)\n3. 카카오 로그인을 위한 카카오 앱준비( 카카오 개발자 도구)\n4. 이메일, 비밀번호로 가입 (v)\n5. 가입된 이메일, 비밀번호로 로그인, (v)\n6. JWT 발급 (v)\n\n7. 이메일 인증 실패시 이메일 변경\n8. 이메일 인증 메일 발송\n9. 각 SNS 에서 Unlink \n10. 회원 탈퇴\n11. 탈퇴 회원 정보 저장 기간 동안 보유(법적 최대 한도 내에서, 가입 때 약관 동의 받아야 함, 재가입 방지 용도로 사용하면 가능)\n\n400 Bad Request\n401 Unauthorized\n403 Forbidden\n404 Not Found\n405 Method not allowed\n500 Internal Error\n502 Bad Gateway \n504 Timeout\n200 OK\n201 Created\n\n\"\"\"\n\n\nrouter = APIRouter(prefix=\"/auth\")\n\n\n@router.post(\"/register/{sns_type}\", status_code=201, response_model=Token)\nasync def register(sns_type: SnsType, reg_info: UserRegister, session: Session = Depends(db.session)):\n    \"\"\"\n    `회원가입 API`\\n\n    :param sns_type:\n    :param reg_info:\n    :param session:\n    :return:\n    \"\"\"\n    if sns_type == SnsType.email:\n        is_exist = await is_email_exist(reg_info.email)\n        if not reg_info.email or not reg_info.pw:\n            return JSONResponse(status_code=400, content=dict(msg=\"Email and PW must be provided'\"))\n        if is_exist:\n            return JSONResponse(status_code=400, content=dict(msg=\"EMAIL_EXISTS\"))\n        hash_pw = bcrypt.hashpw(reg_info.pw.encode(\"utf-8\"), bcrypt.gensalt())\n        new_user = Users.create(session, auto_commit=True, pw=hash_pw, email=reg_info.email)\n        token = dict(Authorization=f\"Bearer {create_access_token(data=UserToken.from_orm(new_user).dict(exclude={'pw', 'marketing_agree'}),)}\")\n        return token\n    return JSONResponse(status_code=400, content=dict(msg=\"NOT_SUPPORTED\"))\n\n\n@router.post(\"/login/{sns_type}\", status_code=200, response_model=Token)\nasync def login(sns_type: SnsType, user_info: UserRegister):\n    if sns_type == SnsType.email:\n        is_exist = await is_email_exist(user_info.email)\n        if not user_info.email or not user_info.pw:\n            return JSONResponse(status_code=400, content=dict(msg=\"Email and PW must be provided'\"))\n        if not is_exist:\n            return JSONResponse(status_code=400, content=dict(msg=\"NO_MATCH_USER\"))\n        user = Users.get(email=user_info.email)\n        is_verified = bcrypt.checkpw(user_info.pw.encode(\"utf-8\"), user.pw.encode(\"utf-8\"))\n        if not is_verified:\n            return JSONResponse(status_code=400, content=dict(msg=\"NO_MATCH_USER\"))\n        token = dict(\n            Authorization=f\"Bearer {create_access_token(data=UserToken.from_orm(user).dict(exclude={'pw', 'marketing_agree'}),)}\")\n        return token\n    return JSONResponse(status_code=400, content=dict(msg=\"NOT_SUPPORTED\"))\n\n\nasync def is_email_exist(email: str):\n    get_email = Users.get(email=email)\n    if get_email:\n        return True\n    return False\n\n\ndef create_access_token(*, data: dict = None, expires_delta: int = None):\n    to_encode = data.copy()\n    if expires_delta:\n        to_encode.update({\"exp\": datetime.utcnow() + timedelta(hours=expires_delta)})\n    encoded_jwt = jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALGORITHM)\n    return encoded_jwt\n"}
{"type": "source_file", "path": "app/database/conn.py", "content": "from fastapi import FastAPI\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nimport logging\n\ndef _database_exist(engine, schema_name):\n    query = f\"SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '{schema_name}'\"\n    with engine.connect() as conn:\n        result_proxy = conn.execute(query)\n        result = result_proxy.scalar()\n        return bool(result)\n\n\ndef _drop_database(engine, schema_name):\n    with engine.connect() as conn:\n        conn.execute(f\"DROP DATABASE {schema_name};\")\n\n\ndef _create_database(engine, schema_name):\n    with engine.connect() as conn:\n        conn.execute(f\"CREATE DATABASE {schema_name} CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;\")\n\n\nclass SQLAlchemy:\n    def __init__(self, app: FastAPI = None, **kwargs):\n        self._engine = None\n        self._session = None\n        if app is not None:\n            self.init_app(app=app, **kwargs)\n\n    def init_app(self, app: FastAPI, **kwargs):\n        \"\"\"\n        DB 초기화 함수\n        :param app: FastAPI 인스턴스\n        :param kwargs:\n        :return:\n        \"\"\"\n        database_url = kwargs.get(\"DB_URL\")\n        pool_recycle = kwargs.setdefault(\"DB_POOL_RECYCLE\", 900)\n        is_testing = kwargs.setdefault(\"TEST_MODE\", False)\n        echo = kwargs.setdefault(\"DB_ECHO\", True)\n\n        self._engine = create_engine(\n            database_url,\n            echo=echo,\n            pool_recycle=pool_recycle,\n            pool_pre_ping=True,\n        )\n        if is_testing:  # create schema\n            db_url = self._engine.url\n            if db_url.host != \"localhost\":\n                raise Exception(\"db host must be 'localhost' in test environment\")\n            except_schema_db_url = f\"{db_url.drivername}://{db_url.username}@{db_url.host}\"\n            schema_name = db_url.database\n            temp_engine = create_engine(except_schema_db_url, echo=echo, pool_recycle=pool_recycle, pool_pre_ping=True)\n            if _database_exist(temp_engine, schema_name):\n                _drop_database(temp_engine, schema_name)\n            _create_database(temp_engine, schema_name)\n            temp_engine.dispose()\n\n        self._session = sessionmaker(autocommit=False, autoflush=False, bind=self._engine)\n\n        @app.on_event(\"startup\")\n        def startup():\n            self._engine.connect()\n            logging.info(\"DB connected.\")\n\n        @app.on_event(\"shutdown\")\n        def shutdown():\n            self._session.close_all()\n            self._engine.dispose()\n            logging.info(\"DB disconnected\")\n\n    def get_db(self):\n        \"\"\"\n        요청마다 DB 세션 유지 함수\n        :return:\n        \"\"\"\n        if self._session is None:\n            raise Exception(\"must be called 'init_app'\")\n        db_session = None\n        try:\n            db_session = self._session()\n            yield db_session\n        finally:\n            db_session.close()\n\n    @property\n    def session(self):\n        return self.get_db\n\n    @property\n    def engine(self):\n        return self._engine\n\n\ndb = SQLAlchemy()\nBase = declarative_base()\n"}
{"type": "source_file", "path": "app/database/schema.py", "content": "\nfrom sqlalchemy import (\n    Column,\n    Integer,\n    String,\n    DateTime,\n    func,\n    Enum,\n    Boolean,\n    ForeignKey,\n)\nfrom sqlalchemy.orm import Session, relationship\n\nfrom app.database.conn import Base, db\n\n\nclass BaseMixin:\n    id = Column(Integer, primary_key=True, index=True)\n    created_at = Column(DateTime, nullable=False, default=func.utc_timestamp())\n    updated_at = Column(DateTime, nullable=False, default=func.utc_timestamp(), onupdate=func.utc_timestamp())\n\n    def __init__(self):\n        self._q = None\n        self._session = None\n        self.served = None\n\n    def all_columns(self):\n        return [c for c in self.__table__.columns if c.primary_key is False and c.name != \"created_at\"]\n\n    def __hash__(self):\n        return hash(self.id)\n\n    @classmethod\n    def create(cls, session: Session, auto_commit=False, **kwargs):\n        \"\"\"\n        테이블 데이터 적재 전용 함수\n        :param session:\n        :param auto_commit: 자동 커밋 여부\n        :param kwargs: 적재 할 데이터\n        :return:\n        \"\"\"\n        obj = cls()\n        for col in obj.all_columns():\n            col_name = col.name\n            if col_name in kwargs:\n                setattr(obj, col_name, kwargs.get(col_name))\n        session.add(obj)\n        session.flush()\n        if auto_commit:\n            session.commit()\n        return obj\n\n    @classmethod\n    def get(cls, session: Session = None, **kwargs):\n        \"\"\"\n        Simply get a Row\n        :param session:\n        :param kwargs:\n        :return:\n        \"\"\"\n        sess = next(db.session()) if not session else session\n        query = sess.query(cls)\n        for key, val in kwargs.items():\n            col = getattr(cls, key)\n            query = query.filter(col == val)\n\n        if query.count() > 1:\n            raise Exception(\"Only one row is supposed to be returned, but got more than one.\")\n        result = query.first()\n        if not session:\n            sess.close()\n        return result\n\n    @classmethod\n    def filter(cls, session: Session = None, **kwargs):\n        \"\"\"\n        Simply get a Row\n        :param session:\n        :param kwargs:\n        :return:\n        \"\"\"\n        cond = []\n        for key, val in kwargs.items():\n            key = key.split(\"__\")\n            if len(key) > 2:\n                raise Exception(\"No 2 more dunders\")\n            col = getattr(cls, key[0])\n            if len(key) == 1: cond.append((col == val))\n            elif len(key) == 2 and key[1] == 'gt': cond.append((col > val))\n            elif len(key) == 2 and key[1] == 'gte': cond.append((col >= val))\n            elif len(key) == 2 and key[1] == 'lt': cond.append((col < val))\n            elif len(key) == 2 and key[1] == 'lte': cond.append((col <= val))\n            elif len(key) == 2 and key[1] == 'in': cond.append((col.in_(val)))\n        obj = cls()\n        if session:\n            obj._session = session\n            obj.served = True\n        else:\n            obj._session = next(db.session())\n            obj.served = False\n        query = obj._session.query(cls)\n        query = query.filter(*cond)\n        obj._q = query\n        return obj\n\n    @classmethod\n    def cls_attr(cls, col_name=None):\n        if col_name:\n            col = getattr(cls, col_name)\n            return col\n        else:\n            return cls\n\n    def order_by(self, *args: str):\n        for a in args:\n            if a.startswith(\"-\"):\n                col_name = a[1:]\n                is_asc = False\n            else:\n                col_name = a\n                is_asc = True\n            col = self.cls_attr(col_name)\n            self._q = self._q.order_by(col.asc()) if is_asc else self._q.order_by(col.desc())\n        return self\n\n    def update(self, auto_commit: bool = False, **kwargs):\n        qs = self._q.update(kwargs)\n        get_id = self.id\n        ret = None\n\n        self._session.flush()\n        if qs > 0 :\n            ret = self._q.first()\n        if auto_commit:\n            self._session.commit()\n        return ret\n\n    def first(self):\n        result = self._q.first()\n        self.close()\n        return result\n\n    def delete(self, auto_commit: bool = False):\n        self._q.delete()\n        if auto_commit:\n            self._session.commit()\n\n    def all(self):\n        print(self.served)\n        result = self._q.all()\n        self.close()\n        return result\n\n    def count(self):\n        result = self._q.count()\n        self.close()\n        return result\n\n    def close(self):\n        if not self.served:\n            self._session.close()\n        else:\n            self._session.flush()\n\n\nclass Users(Base, BaseMixin):\n    __tablename__ = \"users\"\n    status = Column(Enum(\"active\", \"deleted\", \"blocked\"), default=\"active\")\n    email = Column(String(length=255), nullable=True)\n    pw = Column(String(length=2000), nullable=True)\n    name = Column(String(length=255), nullable=True)\n    phone_number = Column(String(length=20), nullable=True, unique=True)\n    profile_img = Column(String(length=1000), nullable=True)\n    sns_type = Column(Enum(\"FB\", \"G\", \"K\"), nullable=True)\n    marketing_agree = Column(Boolean, nullable=True, default=True)\n    keys = relationship(\"ApiKeys\", back_populates=\"users\")\n\n\nclass ApiKeys(Base, BaseMixin):\n    __tablename__ = \"api_keys\"\n    access_key = Column(String(length=64), nullable=False, index=True)\n    secret_key = Column(String(length=64), nullable=False)\n    user_memo = Column(String(length=40), nullable=True)\n    status = Column(Enum(\"active\", \"stopped\", \"deleted\"), default=\"active\")\n    is_whitelisted = Column(Boolean, default=False)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    whitelist = relationship(\"ApiWhiteLists\", backref=\"api_keys\")\n    users = relationship(\"Users\", back_populates=\"keys\")\n\n\nclass ApiWhiteLists(Base, BaseMixin):\n    __tablename__ = \"api_whitelists\"\n    ip_addr = Column(String(length=64), nullable=False)\n    api_key_id = Column(Integer, ForeignKey(\"api_keys.id\"), nullable=False)\n"}
{"type": "source_file", "path": "app/common/consts.py", "content": "JWT_SECRET = \"ABCD1234!\"\nJWT_ALGORITHM = \"HS256\"\nEXCEPT_PATH_LIST = [\"/\", \"/openapi.json\"]\nEXCEPT_PATH_REGEX = \"^(/docs|/redoc|/api/auth)\"\nMAX_API_KEY = 3\nMAX_API_WHITELIST = 10\n"}
{"type": "source_file", "path": "app/models.py", "content": "from datetime import datetime\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic import Field\nfrom pydantic.main import BaseModel\nfrom pydantic.networks import EmailStr, IPvAnyAddress\n\n\nclass UserRegister(BaseModel):\n    # pip install 'pydantic[email]'\n    email: str = None\n    pw: str = None\n\n\nclass SnsType(str, Enum):\n    email: str = \"email\"\n    facebook: str = \"facebook\"\n    google: str = \"google\"\n    kakao: str = \"kakao\"\n\n\nclass Token(BaseModel):\n    Authorization: str = None\n\n\nclass EmailRecipients(BaseModel):\n    name: str\n    email: str\n\n\nclass SendEmail(BaseModel):\n    email_to: List[EmailRecipients] = None\n\n\nclass KakaoMsgBody(BaseModel):\n    msg: str = None\n\n\nclass MessageOk(BaseModel):\n    message: str = Field(default=\"OK\")\n\n\nclass UserToken(BaseModel):\n    id: int\n    email: str = None\n    name: str = None\n    phone_number: str = None\n    profile_img: str = None\n    sns_type: str = None\n\n    class Config:\n        orm_mode = True\n\n\nclass UserMe(BaseModel):\n    id: int\n    email: str = None\n    name: str = None\n    phone_number: str = None\n    profile_img: str = None\n    sns_type: str = None\n\n    class Config:\n        orm_mode = True\n\n\nclass AddApiKey(BaseModel):\n    user_memo: str = None\n\n    class Config:\n        orm_mode = True\n\n\nclass GetApiKeyList(AddApiKey):\n    id: int = None\n    access_key: str = None\n    created_at: datetime = None\n\n\nclass GetApiKeys(GetApiKeyList):\n    secret_key: str = None\n\n\nclass CreateAPIWhiteLists(BaseModel):\n    ip_addr: str = None\n\n\nclass GetAPIWhiteLists(CreateAPIWhiteLists):\n    id: int\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "app/errors/__init__.py", "content": ""}
{"type": "source_file", "path": "app/common/config.py", "content": "from dataclasses import dataclass\nfrom os import path, environ\nfrom typing import List\n\nbase_dir = path.dirname(path.dirname(path.dirname(path.abspath(__file__))))\n\n\n@dataclass\nclass Config:\n    \"\"\"\n    기본 Configuration\n    \"\"\"\n    BASE_DIR: str = base_dir\n    DB_POOL_RECYCLE: int = 900\n    DB_ECHO: bool = True\n    DEBUG: bool = False\n    TEST_MODE: bool = False\n    DB_URL: str = environ.get(\"DB_URL\", \"mysql+pymysql://travis@localhost/notification_api?charset=utf8mb4\")\n\n\n@dataclass\nclass LocalConfig(Config):\n    TRUSTED_HOSTS = [\"*\"]\n    ALLOW_SITE = [\"*\"]\n    DEBUG: bool = True\n\n\n@dataclass\nclass ProdConfig(Config):\n    TRUSTED_HOSTS = [\"*\"]\n    ALLOW_SITE = [\"*\"]\n\n\n@dataclass\nclass TestConfig(Config):\n    DB_URL: str = \"mysql+pymysql://travis@localhost/notification_test?charset=utf8mb4\"\n    TRUSTED_HOSTS = [\"*\"]\n    ALLOW_SITE = [\"*\"]\n    TEST_MODE: bool = True\n\n\ndef conf():\n    \"\"\"\n    환경 불러오기\n    :return:\n    \"\"\"\n    config = dict(prod=ProdConfig, local=LocalConfig, test=TestConfig)\n    return config[environ.get(\"API_ENV\", \"local\")]()\n\n\n"}
{"type": "source_file", "path": "app/routes/services.py", "content": "import json\nimport os\nfrom time import time, sleep\n\nimport yagmail\n\nimport requests\nfrom fastapi import APIRouter\nfrom fastapi.logger import logger\nfrom starlette.background import BackgroundTasks\nfrom starlette.requests import Request\n\nfrom app.errors import exceptions as ex\n\nfrom app.models import MessageOk, KakaoMsgBody, SendEmail\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\nrouter = APIRouter(prefix='/services')\n\n\n@router.get('')\nasync def get_all_services(request: Request):\n    return dict(your_email=request.state.user.email)\n\n\n@router.post('kakao/send')\nasync def send_kakao(request: Request, body: KakaoMsgBody):\n    token = os.environ.get(\"KAKAO_KEY\", \"dOAap7zvH9ri6kj53SzApCTBy41AS6E*****************g\")\n    headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/x-www-form-urlencoded\"}\n\n    body = dict(object_type=\"text\", text=body.msg, link=dict(web_url=\"https://dingrr.com\", mobile_url=\"https://dingrr.com\"), button_title=\"지금 확인\")\n    data = {\"template_object\": json.dumps(body, ensure_ascii=False)}\n\n    res = requests.post(\"https://kapi.kakao.com/v2/api/talk/memo/default/send\", headers=headers, data=data)\n    try:\n        res.raise_for_status()\n        if res.json()[\"result_code\"] != 0:\n            raise Exception(\"KAKAO SEND FAILED\")\n    except Exception as e:\n        logger.warning(e)\n        raise ex.KakaoSendFailureEx\n\n    return MessageOk()\n\n\nemail_content = \"\"\"\n<div style='margin-top:0cm;margin-right:0cm;margin-bottom:10.0pt;margin-left:0cm;line-height:115%;font-size:15px;font-family:\"Calibri\",sans-serif;border:none;border-bottom:solid #EEEEEE 1.0pt;padding:0cm 0cm 6.0pt 0cm;background:white;'>\n\n<p style='margin-top:0cm;margin-right:0cm;margin-bottom:11.25pt;margin-left:0cm;line-height:115%;font-size:15px;font-family:\"Calibri\",sans-serif;background:white;border:none;padding:0cm;'><span style='font-size:25px;font-family:\"Helvetica Neue\";color:#11171D;'>{}님! Aristoxeni ingenium consumptum videmus in musicis?</span></p>\n</div>\n\n<p style='margin-top:0cm;margin-right:0cm;margin-bottom:11.25pt;margin-left:0cm;line-height:17.25pt;font-size:15px;font-family:\"Calibri\",sans-serif;background:white;vertical-align:baseline;'><span style='font-size:14px;font-family:\"Helvetica Neue\";color:#11171D;'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quid nunc honeste dicit? Tum Torquatus: Prorsus, inquit, assentior; Duo Reges: constructio interrete. Iam in altera philosophiae parte. Sed haec omittamus; Haec para/doca illi, nos admirabilia dicamus. Nihil sane.</span></p>\n\n<p style='margin-top:0cm;margin-right:0cm;margin-bottom:10.0pt;margin-left:0cm;line-height:normal;font-size:15px;font-family:\"Calibri\",sans-serif;background:white;'><strong><span style='font-size:24px;font-family:\"Helvetica Neue\";color:#11171D;'>Expressa vero in iis aetatibus, quae iam confirmatae sunt.</span></strong></p>\n\n<p style='margin-top:0cm;margin-right:0cm;margin-bottom:11.25pt;margin-left:0cm;line-height:17.25pt;font-size:15px;font-family:\"Calibri\",sans-serif;background:white;vertical-align:baseline;'><span style='font-size:14px;font-family:\"Helvetica Neue\";color:#11171D;'>Sit sane ista voluptas. Non quam nostram quidem, inquit Pomponius iocans; An tu me de L. Sed haec omittamus; Cave putes quicquam esse verius.&nbsp;</span></p>\n\n<p style='margin-top:0cm;margin-right:0cm;margin-bottom:11.25pt;margin-left:0cm;line-height:17.25pt;font-size:15px;font-family:\"Calibri\",sans-serif;text-align:center;background:white;vertical-align:baseline;'><span style='font-size:14px;font-family:\"Helvetica Neue\";color:#11171D;'><img width=\"378\" src=\"https://dl1gtqdymozzn.cloudfront.net/forAuthors/K6Sfkx4f2uH780YGTbEHvHcTX3itiTBtzDWeyswQevxp8jqVttfBgPu86ZtGC6owG.webp\" alt=\"sample1.jpg\" class=\"fr-fic fr-dii\"></span></p>\n\n<p>\n<br>\n</p>\n\n\"\"\"\n\n\n@router.post(\"email/send_by_gmail\")\nasync def email_by_gmail(request: Request, mailing_list: SendEmail):\n    t = time()\n    send_email(mailing_list=mailing_list.email_to)\n    return MessageOk()\n\n\n@router.post(\"email/send_by_gmail2\")\nasync def email_by_gmail2(request: Request, mailing_list: SendEmail, background_tasks: BackgroundTasks):\n    t = time()\n    background_tasks.add_task(\n        send_email, mailing_list=mailing_list.email_to\n    )\n    return MessageOk()\n\n\ndef send_email(**kwargs):\n    mailing_list = kwargs.get(\"mailing_list\", None)\n    email_pw = os.environ.get(\"EMAIL_PW\", None)\n    email_addr = os.environ.get(\"EMAIL_ADDR\", None)\n    last_email = \"\"\n    if mailing_list:\n        try:\n            yag = yagmail.SMTP({email_addr: \"라이언X코알라\"}, email_pw)\n            # https://myaccount.google.com/u/1/lesssecureapps\n            for m_l in mailing_list:\n                contents = [\n                    email_content.format(m_l.name)\n                ]\n                sleep(1)\n                yag.send(m_l.email, '이렇게 한번 보내봅시다.', contents)\n                last_email = m_l.email\n            return True\n        except Exception as e:\n            print(e)\n            print(last_email)\n\n\n@router.post(\"email/send_by_ses\")\nasync def email_by_ses():\n    # sender = \"Ryan Name <sender@d9.is>\"\n    sender = \"Ryan =?UTF-8?B?65287J207Ja4?= <sender@d9.is>\"\n    # sender = \"Ryan 라이언 <sender@d9.is>\"\n    recipient = [\"rocklay.info@gmail.com\"]\n\n    # If necessary, replace us-west-2 with the AWS Region you're using for Amazon SES.\n    region = \"ap-northeast-2\"\n\n    # The subject line for the email.\n    title = \"안녕하세요! 테스트 이메일 입니다.\"\n\n    # The email body for recipients with non-HTML email clients.\n    BODY_TEXT = (\"안녕하세요! 딩그르르 입니다.\\r\\n\"\n                 \"HTML 버전만 지원합니다!\"\n                 )\n\n    # The HTML body of the email.\n    BODY_HTML = \"\"\"<html>\n    <head></head>\n    <body>\n      <h1>안녕하세요! 반갑습니다.</h1>\n      <p>기업에서 대규모 이메일 솔루션을 구축한다는 것은 복잡하고 비용이 많이 드는 작업이 될 수 있습니다. 이를 위해서는 인프라를 구축하고, 네트워크를 구성하고, IP 주소를 준비하고, 발신자 평판을 보호해야 합니다. 타사 이메일 솔루션 대부분이 상당한 규모의 선수금을 요구하고 계약 협상을 진행해야 합니다.\n\nAmazon SES는 이러한 부담이 없으므로 몇 분 만에 이메일 발송을 시작할 수 있습니다. Amazon.com이 대규모의 자사 고객 기반을 지원하기 위해 구축한 정교한 이메일 인프라와 오랜 경험을 활용할 수 있습니다.</p>\n      <p>링크를 통해 확인하세요!\n        <a href='https://dingrr.com'>Dingrr</a></p>\n    </body>\n    </html>\n                \"\"\"\n\n    # The character encoding for the email.\n    charset = \"UTF-8\"\n\n    # Create a new SES resource and specify a region.\n    client = boto3.client(\n        'ses',\n        region_name=region,\n        aws_access_key_id=os.environ.get(\"AWS_KEY\", None),\n        aws_secret_access_key=os.environ.get(\"AWS_SECRET\", None),\n    )\n\n    # Try to send the email.\n    try:\n        # Provide the contents of the email.\n        response = client.send_email(\n            Destination={\n                'ToAddresses': recipient\n            },\n            Message={\n                'Body': {\n                    'Html': {\n                        'Charset': charset,\n                        'Data': BODY_HTML,\n                    },\n                    'Text': {\n                        'Charset': charset,\n                        'Data': BODY_TEXT,\n                    },\n                },\n                'Subject': {\n                    'Charset': charset,\n                    'Data': title,\n                },\n            },\n            Source=sender,\n        )\n    # Display an error if something goes wrong.\n    except ClientError as e:\n        print(e.response['Error']['Message'])\n    else:\n        print(\"Email sent! Message ID:\"),\n        print(response['MessageId'])\n\n    return MessageOk()\n"}
{"type": "source_file", "path": "app/routes/index.py", "content": "from datetime import datetime\n\nfrom fastapi import APIRouter\nfrom starlette.responses import Response\nfrom starlette.requests import Request\nfrom inspect import currentframe as frame\n\nrouter = APIRouter()\n\n\n@router.get(\"/\")\nasync def index():\n    \"\"\"\n    ELB 상태 체크용 API\n    :return:\n    \"\"\"\n    current_time = datetime.utcnow()\n    return Response(f\"Notification API (UTC: {current_time.strftime('%Y.%m.%d %H:%M:%S')})\")\n\n\n@router.get(\"/test\")\nasync def test(request: Request):\n    \"\"\"\n    ELB 상태 체크용 API\n    :return:\n    \"\"\"\n    print(\"state.user\", request.state.user)\n    try:\n        a = 1/0\n    except Exception as e:\n        request.state.inspect = frame()\n        raise e\n    current_time = datetime.utcnow()\n    return Response(f\"Notification API (UTC: {current_time.strftime('%Y.%m.%d %H:%M:%S')})\")\n"}
{"type": "source_file", "path": "app/middlewares/token_validator.py", "content": "import base64\nimport hmac\nimport time\nimport typing\nimport re\n\nimport jwt\nimport sqlalchemy.exc\n\nfrom jwt.exceptions import ExpiredSignatureError, DecodeError\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\n\nfrom app.common.consts import EXCEPT_PATH_LIST, EXCEPT_PATH_REGEX\nfrom app.database.conn import db\nfrom app.database.schema import Users, ApiKeys\nfrom app.errors import exceptions as ex\n\nfrom app.common import config, consts\nfrom app.errors.exceptions import APIException, SqlFailureEx, APIQueryStringEx\nfrom app.models import UserToken\n\nfrom app.utils.date_utils import D\nfrom app.utils.logger import api_logger\nfrom app.utils.query_utils import to_dict\n\n\nasync def access_control(request: Request, call_next):\n    request.state.req_time = D.datetime()\n    request.state.start = time.time()\n    request.state.inspect = None\n    request.state.user = None\n    request.state.service = None\n\n    ip = request.headers[\"x-forwarded-for\"] if \"x-forwarded-for\" in request.headers.keys() else request.client.host\n    request.state.ip = ip.split(\",\")[0] if \",\" in ip else ip\n    headers = request.headers\n    cookies = request.cookies\n\n    url = request.url.path\n    if await url_pattern_check(url, EXCEPT_PATH_REGEX) or url in EXCEPT_PATH_LIST:\n        response = await call_next(request)\n        if url != \"/\":\n            await api_logger(request=request, response=response)\n        return response\n\n    try:\n        if url.startswith(\"/api\"):\n            # api 인경우 헤더로 토큰 검사\n            if url.startswith(\"/api/services\"):\n                qs = str(request.query_params)\n                qs_list = qs.split(\"&\")\n                session = next(db.session())\n                if not config.conf().DEBUG:\n                    try:\n                        qs_dict = {qs_split.split(\"=\")[0]: qs_split.split(\"=\")[1] for qs_split in qs_list}\n                    except Exception:\n                        raise ex.APIQueryStringEx()\n\n                    qs_keys = qs_dict.keys()\n\n                    if \"key\" not in qs_keys or \"timestamp\" not in qs_keys:\n                        raise ex.APIQueryStringEx()\n\n                    if \"secret\" not in headers.keys():\n                        raise ex.APIHeaderInvalidEx()\n\n                    api_key = ApiKeys.get(session=session, access_key=qs_dict[\"key\"])\n\n                    if not api_key:\n                        raise ex.NotFoundAccessKeyEx(api_key=qs_dict[\"key\"])\n                    mac = hmac.new(bytes(api_key.secret_key, encoding='utf8'), bytes(qs, encoding='utf-8'), digestmod='sha256')\n                    d = mac.digest()\n                    validating_secret = str(base64.b64encode(d).decode('utf-8'))\n\n                    if headers[\"secret\"] != validating_secret:\n                        raise ex.APIHeaderInvalidEx()\n\n                    now_timestamp = int(D.datetime(diff=9).timestamp())\n                    if now_timestamp - 10 > int(qs_dict[\"timestamp\"]) or now_timestamp < int(qs_dict[\"timestamp\"]):\n                        raise ex.APITimestampEx()\n\n                    user_info = to_dict(api_key.users)\n                    request.state.user = UserToken(**user_info)\n\n                else:\n                    # Request User 가 필요함\n                    if \"authorization\" in headers.keys():\n                        key = headers.get(\"Authorization\")\n                        api_key_obj = ApiKeys.get(session=session, access_key=key)\n                        user_info = to_dict(Users.get(session=session, id=api_key_obj.user_id))\n                        request.state.user = UserToken(**user_info)\n                        # 토큰 없음\n                    else:\n                        if \"Authorization\" not in headers.keys():\n                            raise ex.NotAuthorized()\n                session.close()\n                response = await call_next(request)\n                return response\n            else:\n                if \"authorization\" in headers.keys():\n                    token_info = await token_decode(access_token=headers.get(\"Authorization\"))\n                    request.state.user = UserToken(**token_info)\n                    # 토큰 없음\n                else:\n                    if \"Authorization\" not in headers.keys():\n                        raise ex.NotAuthorized()\n        else:\n            # 템플릿 렌더링인 경우 쿠키에서 토큰 검사\n            cookies[\"Authorization\"] = \"Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MTQsImVtYWlsIjoia29hbGFAZGluZ3JyLmNvbSIsIm5hbWUiOm51bGwsInBob25lX251bWJlciI6bnVsbCwicHJvZmlsZV9pbWciOm51bGwsInNuc190eXBlIjpudWxsfQ.4vgrFvxgH8odoXMvV70BBqyqXOFa2NDQtzYkGywhV48\"\n\n            if \"Authorization\" not in cookies.keys():\n                raise ex.NotAuthorized()\n\n            token_info = await token_decode(access_token=cookies.get(\"Authorization\"))\n            request.state.user = UserToken(**token_info)\n        response = await call_next(request)\n        await api_logger(request=request, response=response)\n    except Exception as e:\n\n        error = await exception_handler(e)\n        error_dict = dict(status=error.status_code, msg=error.msg, detail=error.detail, code=error.code)\n        response = JSONResponse(status_code=error.status_code, content=error_dict)\n        await api_logger(request=request, error=error)\n\n    return response\n\n\nasync def url_pattern_check(path, pattern):\n    result = re.match(pattern, path)\n    if result:\n        return True\n    return False\n\n\nasync def token_decode(access_token):\n    \"\"\"\n    :param access_token:\n    :return:\n    \"\"\"\n    try:\n        access_token = access_token.replace(\"Bearer \", \"\")\n        payload = jwt.decode(access_token, key=consts.JWT_SECRET, algorithms=[consts.JWT_ALGORITHM])\n    except ExpiredSignatureError:\n        raise ex.TokenExpiredEx()\n    except DecodeError:\n        raise ex.TokenDecodeEx()\n    return payload\n\n\nasync def exception_handler(error: Exception):\n    print(error)\n    if isinstance(error, sqlalchemy.exc.OperationalError):\n        error = SqlFailureEx(ex=error)\n    if not isinstance(error, APIException):\n        error = APIException(ex=error, detail=str(error))\n    return error\n"}
{"type": "source_file", "path": "app/utils/logger.py", "content": "import json\nimport logging\nfrom datetime import timedelta, datetime\nfrom time import time\nfrom fastapi.requests import Request\nfrom fastapi import Body\nfrom fastapi.logger import logger\n\nlogger.setLevel(logging.INFO)\n\n\nasync def api_logger(request: Request, response=None, error=None):\n    time_format = \"%Y/%m/%d %H:%M:%S\"\n    t = time() - request.state.start\n    status_code = error.status_code if error else response.status_code\n    error_log = None\n    user = request.state.user\n    if error:\n        if request.state.inspect:\n            frame = request.state.inspect\n            error_file = frame.f_code.co_filename\n            error_func = frame.f_code.co_name\n            error_line = frame.f_lineno\n        else:\n            error_func = error_file = error_line = \"UNKNOWN\"\n\n        error_log = dict(\n            errorFunc=error_func,\n            location=\"{} line in {}\".format(str(error_line), error_file),\n            raised=str(error.__class__.__name__),\n            msg=str(error.ex),\n        )\n\n    email = user.email.split(\"@\") if user and user.email else None\n    user_log = dict(\n        client=request.state.ip,\n        user=user.id if user and user.id else None,\n        email=\"**\" + email[0][2:-1] + \"*@\" + email[1] if user and user.email else None,\n    )\n\n    log_dict = dict(\n        url=request.url.hostname + request.url.path,\n        method=str(request.method),\n        statusCode=status_code,\n        errorDetail=error_log,\n        client=user_log,\n        processedTime=str(round(t * 1000, 5)) + \"ms\",\n        datetimeUTC=datetime.utcnow().strftime(time_format),\n        datetimeKST=(datetime.utcnow() + timedelta(hours=9)).strftime(time_format),\n    )\n    if error and error.status_code >= 500:\n        logger.error(json.dumps(log_dict))\n    else:\n        logger.info(json.dumps(log_dict))\n"}
{"type": "source_file", "path": "app/utils/date_utils.py", "content": "from datetime import datetime, date, timedelta\n\n\nclass D:\n    def __init__(self, *args):\n        self.utc_now = datetime.utcnow()\n        self.timedelta = 0\n\n    @classmethod\n    def datetime(cls, diff: int=0) -> datetime:\n        return cls().utc_now + timedelta(hours=diff) if diff > 0 else cls().utc_now + timedelta(hours=diff)\n\n    @classmethod\n    def date(cls, diff: int=0) -> date:\n        return cls.datetime(diff=diff).date()\n\n    @classmethod\n    def date_num(cls, diff: int=0) -> int:\n        return int(cls.date(diff=diff).strftime('%Y%m%d'))\n\n"}
{"type": "source_file", "path": "app/utils/query_utils.py", "content": "from typing import List\n\n\ndef to_dict(model, *args, exclude: List = None):\n    q_dict = {}\n    for c in model.__table__.columns:\n        if not args or c.name in args:\n            if not exclude or c.name not in exclude:\n                q_dict[c.name] = getattr(model, c.name)\n\n    return q_dict\n"}
{"type": "source_file", "path": "gunicorn.conf.py", "content": "# Gunicorn configuration file.\n#\n# Server socket\n#\n#   bind - The socket to bind.\n#\n#       A string of the form: 'HOST', 'HOST:PORT', 'unix:PATH'.\n#       An IP is a valid HOST.\n#\n#   backlog - The number of pending connections. This refers\n#       to the number of clients that can be waiting to be\n#       served. Exceeding this number results in the client\n#       getting an error when attempting to connect. It should\n#       only affect servers under significant load.\n#\n#       Must be a positive integer. Generally set in the 64-2048\n#       range.\n#\n\nbind = \"0.0.0.0:5000\"\nbacklog = 2048\n\n#\n# Worker processes\n#\n#   workers - The number of worker processes that this server\n#       should keep alive for handling requests.\n#\n#       A positive integer generally in the 2-4 x $(NUM_CORES)\n#       range. You'll want to vary this a bit to find the best\n#       for your particular application's work load.\n#\n#   worker_class - The type of workers to use. The default\n#       sync class should handle most 'normal' types of work\n#       loads. You'll want to read\n#       http://docs.gunicorn.org/en/latest/design.html#choosing-a-worker-type\n#       for information on when you might want to choose one\n#       of the other worker classes.\n#\n#       A string referring to a Python path to a subclass of\n#       gunicorn.workers.base.Worker. The default provided values\n#       can be seen at\n#       http://docs.gunicorn.org/en/latest/settings.html#worker-class\n#\n#   worker_connections - For the eventlet and gevent worker classes\n#       this limits the maximum number of simultaneous clients that\n#       a single process can handle.\n#\n#       A positive integer generally set to around 1000.\n#\n#   timeout - If a worker does not notify the master process in this\n#       number of seconds it is killed and a new worker is spawned\n#       to replace it.\n#\n#       Generally set to thirty seconds. Only set this noticeably\n#       higher if you're sure of the repercussions for sync workers.\n#       For the non sync workers it just means that the worker\n#       process is still communicating and is not tied to the length\n#       of time required to handle a single request.\n#\n#   keepalive - The number of seconds to wait for the next request\n#       on a Keep-Alive HTTP connection.\n#\n#       A positive integer. Generally set in the 1-5 seconds range.\n#\n#   reload - Restart workers when code changes.\n#\n#       This setting is intended for development. It will cause\n#       workers to be restarted whenever application code changes.\nworkers = 3\nthreads = 3\nworker_class = \"uvicorn.workers.UvicornWorker\"\nworker_connections = 1000\ntimeout = 60\nkeepalive = 2\nreload = True\n\n#\n#   spew - Install a trace function that spews every line of Python\n#       that is executed when running the server. This is the\n#       nuclear option.\n#\n#       True or False\n#\n\nspew = False\n\n#\n# Server mechanics\n#\n#   daemon - Detach the main Gunicorn process from the controlling\n#       terminal with a standard fork/fork sequence.\n#\n#       True or False\n#\n#   raw_env - Pass environment variables to the execution environment.\n#\n#   pidfile - The path to a pid file to write\n#\n#       A path string or None to not write a pid file.\n#\n#   user - Switch worker processes to run as this user.\n#\n#       A valid user id (as an integer) or the name of a user that\n#       can be retrieved with a call to pwd.getpwnam(value) or None\n#       to not change the worker process user.\n#\n#   group - Switch worker process to run as this group.\n#\n#       A valid group id (as an integer) or the name of a user that\n#       can be retrieved with a call to pwd.getgrnam(value) or None\n#       to change the worker processes group.\n#\n#   umask - A mask for file permissions written by Gunicorn. Note that\n#       this affects unix socket permissions.\n#\n#       A valid value for the os.umask(mode) call or a string\n#       compatible with int(value, 0) (0 means Python guesses\n#       the base, so values like \"0\", \"0xFF\", \"0022\" are valid\n#       for decimal, hex, and octal representations)\n#\n#   tmp_upload_dir - A directory to store temporary request data when\n#       requests are read. This will most likely be disappearing soon.\n#\n#       A path to a directory where the process owner can write. Or\n#       None to signal that Python should choose one on its own.\n#\n\ndaemon = False\npidfile = None\numask = 0\nuser = None\ngroup = None\ntmp_upload_dir = None\n\n#\n#   Logging\n#\n#   logfile - The path to a log file to write to.\n#\n#       A path string. \"-\" means log to stdout.\n#\n#   loglevel - The granularity of log output\n#\n#       A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"\n#\n\nerrorlog = \"-\"\nloglevel = \"info\"\naccesslog = None\naccess_log_format = '%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"'\n\n#\n# Process naming\n#\n#   proc_name - A base to use with setproctitle to change the way\n#       that Gunicorn processes are reported in the system process\n#       table. This affects things like 'ps' and 'top'. If you're\n#       going to be running more than one instance of Gunicorn you'll\n#       probably want to set a name to tell them apart. This requires\n#       that you install the setproctitle module.\n#\n#       A string or None to choose a default of something like 'gunicorn'.\n#\n\nproc_name = \"NotificationAPI\"\n\n\n#\n# Server hooks\n#\n#   post_fork - Called just after a worker has been forked.\n#\n#       A callable that takes a server and worker instance\n#       as arguments.\n#\n#   pre_fork - Called just prior to forking the worker subprocess.\n#\n#       A callable that accepts the same arguments as after_fork\n#\n#   pre_exec - Called just prior to forking off a secondary\n#       master process during things like config reloading.\n#\n#       A callable that takes a server instance as the sole argument.\n#\n\n\ndef post_fork(server, worker):\n    server.log.info(\"Worker spawned (pid: %s)\", worker.pid)\n\n\ndef pre_fork(server, worker):\n    pass\n\n\ndef pre_exec(server):\n    server.log.info(\"Forked child, re-executing.\")\n\n\ndef when_ready(server):\n    server.log.info(\"Server is ready. Spawning workers\")\n\n\ndef worker_int(worker):\n    worker.log.info(\"worker received INT or QUIT signal\")\n\n    # get traceback info\n    import threading, sys, traceback\n\n    id2name = {th.ident: th.name for th in threading.enumerate()}\n    code = []\n    for threadId, stack in sys._current_frames().items():\n        code.append(\"\\n# Thread: %s(%d)\" % (id2name.get(threadId, \"\"), threadId))\n        for filename, lineno, name, line in traceback.extract_stack(stack):\n            code.append('File: \"%s\", line %d, in %s' % (filename, lineno, name))\n            if line:\n                code.append(\"  %s\" % (line.strip()))\n    worker.log.debug(\"\\n\".join(code))\n\n\ndef worker_abort(worker):\n    worker.log.info(\"worker received SIGABRT signal\")\n"}

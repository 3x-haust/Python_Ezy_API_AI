{"repo_info": {"repo_name": "llm_repo_assistant", "repo_owner": "marknagelberg", "repo_url": "https://github.com/marknagelberg/llm_repo_assistant"}}
{"type": "test_file", "path": "src/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "src/tests/api/api_v1/test_command.py", "content": "from fastapi.testclient import TestClient\nfrom src.main import app\nimport pytest\nimport os\nfrom src.core.config import settings\nimport tempfile\nfrom src.utils import get_filesystem_path, get_endpoint_path\n\nclient = TestClient(app)\n\n@pytest.fixture(scope='function')\ndef temp_test_file():\n    test_emoji_content = \"\"\"\nimport emoji\n\ndef test_emoji():\n    result = emoji.emojize('Python is :thumbs_up:')\n    assert 'Python is 👍' in result\n\"\"\"\n    with tempfile.NamedTemporaryFile(mode='w', dir=settings.REPO_ROOT, delete=False, prefix='test_', suffix='.py') as temp_file:\n        temp_file.write(test_emoji_content)\n        temp_file_path = temp_file.name\n\n    yield temp_file_path\n\n    # Teardown logic: remove the temporary file\n    if os.path.exists(temp_file_path):\n        os.unlink(temp_file_path)\n\ndef test_can_run_tests():\n    # Test case for the get_file_structure endpoint\n    # Use the root directory of the repository as the test directory\n    response = client.post(\"/api/v1/command/run_tests/pytest\", json={})\n    assert response.status_code == 200\n\ndef test_tests_use_separate_testing_virtualenv(temp_test_file):\n    # Test case for the get_file_structure endpoint\n    # Use the root directory of the repository as the test directory\n\n    # temp_file contains emoji package that is not in the requirements.txt for the app but is in \n    # the requirements.txt for the target repo. If the tests are run in the same virtualenv as the app,\n    # the tests will fail because the emoji package is not installed. This test ensures that the tests\n    # are run in a separate virtualenv that has the target repo's requirements.txt installed.\n    response = client.post(\"/api/v1/command/run_tests/pytest\", json={'test_file_path': get_endpoint_path(temp_test_file)})\n    assert response.status_code == 200\n    assert 'collected 1 item' in response.text\n    assert '1 passed' in response.text\n\n"}
{"type": "test_file", "path": "src/tests/conftest.py", "content": "from typing import Dict, Generator\nimport os\nimport tempfile\n\nimport pytest\nfrom fastapi.testclient import TestClient\n\nfrom src.core.config import settings\nfrom src.main import app\n\n\n@pytest.fixture(scope=\"module\")\ndef client() -> Generator:\n    with TestClient(app) as c:\n        yield c\n\n\n@pytest.fixture(scope='function')\ndef custom_tmpdir_factory():\n    custom_base_temp_dir = settings.REPO_ROOT\n    os.makedirs(custom_base_temp_dir, exist_ok=True)\n    return tempfile.TemporaryDirectory(prefix='pytest-', dir=custom_base_temp_dir)\n\n\n@pytest.fixture(scope='function')\ndef custom_tmpdir(custom_tmpdir_factory):\n    with custom_tmpdir_factory as temp_dir_path:\n        yield temp_dir_path\n"}
{"type": "test_file", "path": "src/tests/api/__init__.py", "content": ""}
{"type": "test_file", "path": "src/tests/utils/__init__.py", "content": ""}
{"type": "test_file", "path": "src/tests/api/api_v1/test_files.py", "content": "# Test cases for file-related endpoints\nimport os\nimport shutil\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom src.main import app\nfrom src.utils import get_filesystem_path, get_endpoint_path\nfrom src.core.config import settings\nimport tempfile\n\nclient = TestClient(app)\n\n# Define a fixture for creating and cleaning up temporary files\n\n\n@pytest.fixture(scope='function')\ndef temp_file():\n    with tempfile.NamedTemporaryFile(mode='w', dir=settings.REPO_ROOT, delete=False) as temp_file:\n        temp_file.write('Temporary file content')\n        temp_file_path = temp_file.name\n\n    yield temp_file_path\n\n    # Teardown logic: remove the temporary file\n    if os.path.exists(temp_file_path):\n        os.unlink(temp_file_path)\n\n\n# Define a fixture for handling .llmignore file\n@pytest.fixture(scope='function')\ndef llmignore_handler():\n    # Check if .llmignore already exists and back it up if it does\n    llmignore_exists = os.path.exists(get_filesystem_path('.llmignore'))\n    if llmignore_exists:\n        shutil.copyfile(get_filesystem_path('.llmignore'), get_filesystem_path('.llmignore.bak'))\n    yield\n    # Teardown logic: remove the temporary .llmignore file created by the test\n    if os.path.exists(get_filesystem_path('.llmignore')):\n        os.remove(get_filesystem_path('.llmignore'))\n    # Restore the original .llmignore file if it existed\n    if llmignore_exists:\n        shutil.move(get_filesystem_path('.llmignore.bak'), get_filesystem_path('.llmignore'))\n\n\ndef test_read_file_success(temp_file):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    test_endpoint_path = get_endpoint_path(test_file_path)\n    # Use the correct URL path to access the endpoint\n    response = client.get(f'/api/v1/files/{test_endpoint_path}')\n    assert response.status_code == 200\n    assert response.json() == {'content': 'Temporary file content'}\n\n\n#@pytest.mark.parametrize('temp_file', ['custom_filename'], indirect=True)\ndef test_read_file_ignored_in_llmignore(temp_file, llmignore_handler):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    # Get filename of temp_file\n    filename = os.path.basename(test_file_path)\n    test_endpoint_path = get_endpoint_path(test_file_path)\n\n    # Create a .llmignore file that ignores the temporary file\n    with open(get_filesystem_path('.llmignore'), 'w') as llmignore_file:\n        llmignore_file.write(filename)\n\n    # Use the correct URL path to access the endpoint\n    response = client.get(f'/api/v1/files/{test_endpoint_path}')\n\n    # Assert that the response status code is 404 (Not Found)\n    # because the file is ignored in .llmignore\n    assert response.status_code == 403\n    assert response.json() == {'detail': 'File is ignored in `.llmignore`'}\n\ndef test_read_directory_instead_of_file(temp_file):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    test_endpoint_path = get_endpoint_path(test_file_path)\n\n    # Get the parent directory of the temporary file\n    test_dir_path = os.path.dirname(test_endpoint_path)\n\n    # Use the correct URL path to access the endpoint\n    response = client.get(f'/api/v1/files/{test_dir_path}')\n\n    # Assert that the response status code is 400 (Bad Request)\n    # because the path is not a file\n    assert response.status_code == 400\n    assert response.json() == {'detail': 'Path is not a file'}\n\ndef test_create_file_success(temp_file):\n    # Define the content to be written to the new file\n    file_content = 'New file content'\n\n    # Use the correct URL path to access the endpoint\n    response = client.post('/api/v1/files/', json={'file_name': 'new_file.txt', 'path': '', 'content': file_content})\n\n    # Assert that the response status code is 201 (file created)\n    assert response.status_code == 201\n    assert response.json() == {'message': 'File created successfully'}\n\n    # Assert that the new file exists and contains the expected content\n    with open(get_filesystem_path('new_file.txt'), 'r') as new_file:\n        assert new_file.read() == file_content\n\n    # Teardown logic: remove the new file\n    os.unlink(get_filesystem_path('new_file.txt'))\n\ndef test_create_file_already_exists(temp_file):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    test_endpoint_file_path = get_endpoint_path(test_file_path)\n\n    # Define the content to be written to the new file\n    file_content = 'New file content'\n\n    # Use the correct URL path to access the endpoint\n    response = client.post('/api/v1/files/', json={'file_name': test_endpoint_file_path, 'path': '', 'content': file_content})\n\n    # Assert that the response status code is 409 (Conflict)\n    # because the file already exists\n    assert response.status_code == 409\n    assert response.json() == {'detail': 'File already exists'}\n\ndef test_create_file_ignored_in_llmignore(temp_file, llmignore_handler):\n    new_file_name = 'test_create_file.txt'\n\n    # Create a .llmignore file that ignores the temporary file\n    with open(get_filesystem_path('.llmignore'), 'w') as llmignore_file:\n        llmignore_file.write(new_file_name)\n\n    # Define the content to be written to the new file\n    file_content = 'Create new file content'\n\n    # Use the correct URL path to access the endpoint\n    response = client.post('/api/v1/files/', json={'file_name': new_file_name, 'path': '', 'content': file_content})\n\n    # Assert that the response status code is 403 (Forbidden)\n    # because the file is ignored in .llmignore\n    assert response.status_code == 403\n    assert response.json() == {'detail': 'Cannot create file that is ignored in `.llmignore`'}\n    if os.path.exists(get_filesystem_path(new_file_name)):\n        os.unlink(get_filesystem_path(new_file_name))\n\ndef test_create_file_with_directories():\n    # Define the content to be written to the new file\n    file_content = 'New file content'\n\n    # Define the file name and path with non-existent directories\n    new_file_dir = 'new_dir/sub_dir/'\n    new_file_name = 'new_file.txt'\n\n    # Use the correct URL path to access the endpoint\n    response = client.post('/api/v1/files/', json={'file_name': new_file_name, \n                                                   'path': new_file_dir, \n                                                   'content': file_content, \n                                                   'create_directories': True})\n\n    # Assert that the response status code is 201 (Created)\n    assert response.status_code == 201\n    assert response.json() == {'message': 'File created successfully'}\n\n    # Assert that the new file exists and contains the expected content\n    with open(get_filesystem_path(os.path.join(new_file_dir, new_file_name)), 'r') as new_file:\n        assert new_file.read() == file_content\n\n    # Teardown logic: remove the new file and directories\n    os.unlink(get_filesystem_path(os.path.join(new_file_dir, new_file_name)))\n    os.rmdir(get_filesystem_path('new_dir/sub_dir'))\n    os.rmdir(get_filesystem_path('new_dir'))\n\ndef test_update_entire_file_success(temp_file):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    test_endpoint_path = get_endpoint_path(test_file_path)\n\n    # Define the new content to be written to the file\n    new_content = 'Updated file content'\n\n    # Use the correct URL path to access the endpoint\n    response = client.put(f'/api/v1/files/edit_entire_file/{test_endpoint_path}', json={'content': new_content})\n\n    # Assert that the response status code is 200 (Success)\n    assert response.status_code == 200\n    assert response.json() == {'message': 'File updated successfully'}\n\n    # Assert that the file content is updated as expected\n    with open(test_file_path, 'r') as updated_file:\n        assert updated_file.read() == new_content\n\ndef test_update_entire_file_not_found():\n    # Define a non-existent file path\n    non_existent_file_path = 'non_existent_file.txt'\n\n    # Define the new content to be written to the file\n    new_content = 'Updated file content'\n\n    # Use the correct URL path to access the endpoint\n    response = client.put(f'/api/v1/files/edit_entire_file/{non_existent_file_path}', json={'content': new_content})\n\n    # Assert that the response status code is 404 (Not Found)\n    assert response.status_code == 404\n    assert response.json() == {'detail': 'File not found'}\n\ndef test_update_entire_file_ignored_in_llmignore(temp_file, llmignore_handler):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    test_endpoint_path = get_endpoint_path(test_file_path)\n\n    # Get filename of temp_file\n    filename = os.path.basename(test_file_path)\n\n    # Create a .llmignore file that ignores the temporary file\n    with open(get_filesystem_path('.llmignore'), 'w') as llmignore_file:\n        llmignore_file.write(filename)\n\n    # Define the new content to be written to the file\n    new_content = 'Updated file content'\n\n    # Use the correct URL path to access the endpoint\n    response = client.put(f'/api/v1/files/edit_entire_file/{test_endpoint_path}', json={'content': new_content})\n\n    # Assert that the response status code is 403 (Forbidden)\n    # because the file is ignored in .llmignore\n    assert response.status_code == 403\n    assert response.json() == {'detail': 'File is ignored in `.llmignore`'}\n\n\ndef test_edit_file_by_line_number_success(temp_file):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    test_endpoint_path = get_endpoint_path(test_file_path)\n\n    # Define the new content to be written to the file\n    new_content = 'Updated line content'\n\n    # Use the correct URL path to access the endpoint\n    response = client.post(f'/api/v1/files/edit_by_line_number/{test_endpoint_path}', json={'start_line': 0, 'content': new_content})\n\n    # Assert that the response status code is 200 (Success)\n    assert response.status_code == 200\n    assert response.json() == {'message': 'File updated successfully'}\n\n    # Assert that the file content is updated as expected\n    with open(test_file_path, 'r') as updated_file:\n        assert updated_file.read() == new_content\n\ndef test_edit_file_by_line_number_not_found():\n    # Define a non-existent file path\n    non_existent_file_path = 'non_existent_file.txt'\n\n    # Define the new content to be written to the file\n    new_content = 'Updated line content'\n\n    # Use the correct URL path to access the endpoint\n    response = client.post(f'/api/v1/files/edit_by_line_number/{non_existent_file_path}', json={'start_line': 0, 'content': new_content})\n\n    # Assert that the response status code is 404 (Not Found)\n    assert response.status_code == 404\n    assert response.json() == {'detail': 'File not found'}\n\ndef test_edit_file_by_line_number_ignored_in_llmignore(temp_file, llmignore_handler):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    test_endpoint_path = get_endpoint_path(test_file_path)\n\n    # Get filename of temp_file\n    filename = os.path.basename(test_file_path)\n\n    # Create a .llmignore file that ignores the temporary file\n    with open(get_filesystem_path('.llmignore'), 'w') as llmignore_file:\n        llmignore_file.write(filename)\n\n    # Define the new content to be written to the file\n    new_content = 'Updated line content'\n\n    # Use the correct URL path to access the endpoint\n    response = client.post(f'/api/v1/files/edit_by_line_number/{test_endpoint_path}', json={'start_line': 0, 'content': new_content})\n\n    # Assert that the response status code is 403 (Forbidden)\n    # because the file is ignored in .llmignore\n    assert response.status_code == 403\n    assert response.json() == {'detail': 'File is ignored in `.llmignore`'}\n\ndef test_delete_file_success(temp_file):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    test_endpoint_path = get_endpoint_path(test_file_path)\n\n    # Use the correct URL path to access the endpoint\n    response = client.delete(f'/api/v1/files/{test_endpoint_path}')\n\n    # Assert that the response status code is 200 (Success)\n    assert response.status_code == 200\n    assert response.json() == {'message': 'File deleted successfully'}\n\n    # Assert that the file no longer exists\n    assert not os.path.exists(test_file_path)\n\n\ndef test_delete_file_not_found():\n    # Define a non-existent file path\n    non_existent_file_path = 'non_existent_file.txt'\n\n    # Use the correct URL path to access the endpoint\n    response = client.delete(f'/api/v1/files/{non_existent_file_path}')\n\n    # Assert that the response status code is 404 (Not Found)\n    assert response.status_code == 404\n    assert response.json() == {'detail': 'File not found'}\n\n\ndef test_delete_file_ignored_in_llmignore(temp_file, llmignore_handler):\n    # Use the fixture to get the path to the temporary file\n    test_file_path = temp_file\n    test_endpoint_path = get_endpoint_path(test_file_path)\n\n    # Get filename of temp_file\n    filename = os.path.basename(test_file_path)\n\n    # Create a .llmignore file that ignores the temporary file\n    with open(get_filesystem_path('.llmignore'), 'w') as llmignore_file:\n        llmignore_file.write(filename)\n\n    # Use the correct URL path to access the endpoint\n    response = client.delete(f'/api/v1/files/{test_endpoint_path}')\n\n    # Assert that the response status code is 403 (Forbidden)\n    # because the file is ignored in .llmignore\n    assert response.status_code == 403\n    assert response.json() == {'detail': 'File is ignored in `.llmignore`'}\n"}
{"type": "test_file", "path": "src/tests/api/api_v1/test_context.py", "content": "from fastapi.testclient import TestClient\nfrom src.main import app\n\nclient = TestClient(app)\n\n\ndef test_get_file_structure():\n    # Test case for the get_file_structure endpoint\n    # Use the root directory of the repository as the test directory\n    response = client.post(\"/api/v1/context/file_structure/\")\n    assert response.status_code == 200\n    # Add more assertions based on expected response\n\n\ndef test_git_diff():\n    # Test case for the git_diff endpoint\n    response = client.get(\"/api/v1/context/git_diff\")\n    assert response.status_code == 200\n    # Add more assertions based on expected response\n\n# Add more test cases if needed\n"}
{"type": "test_file", "path": "src/tests/api/api_v1/test_programming.py", "content": "import os\nfrom fastapi.testclient import TestClient\nfrom src.main import app\nimport pytest\nfrom src.utils import get_endpoint_path\n\nclient = TestClient(app)\n\n\n@pytest.fixture\ndef temp_python_file_with_function(custom_tmpdir):\n    # Create a temporary Python file with a known function and docstring\n    file_content = (\n        \"def sample_function():\\n\"\n        \"    \\\"\\\"\\\"This is a sample function.\\\"\\\"\\\"\\n\"\n        \"    pass\\n\"\n    )\n    file_path = os.path.join(custom_tmpdir, 'sample.py')\n    with open(file_path, 'w') as file:\n        file.write(file_content)\n    function_name = 'sample_function'\n    expected_docstring = 'This is a sample function.'\n    yield str(file_path), function_name, expected_docstring\n    # Clean up by deleting the temporary file\n    os.remove(file_path)\n\n\n@pytest.fixture\ndef temp_python_file_without_docstring(custom_tmpdir):\n    # Create a temporary Python file without a module-level docstring\n    file_content = \"class SampleClass:\\n    pass\\n\"\n    file_path = os.path.join(custom_tmpdir, \"temp_file_without_docstring.py\")\n    with open(file_path, \"w\") as file:\n        file.write(file_content)\n    return str(file_path), file_content\n\n\n@pytest.fixture\ndef temp_python_file_with_class(custom_tmpdir):\n    # Create a temporary Python file with a known class and docstring\n    file_content = (\n        \"class SampleClass:\\n\"\n        \"    \\\"\\\"\\\"This is a sample class.\\\"\\\"\\\"\\n\"\n        \"    pass\\n\"\n    )\n    file_path = os.path.join(custom_tmpdir, 'sample.py')\n    with open(file_path, 'w') as file:\n        file.write(file_content)\n    class_name = 'SampleClass'\n    expected_docstring = 'This is a sample class.'\n    yield str(file_path), class_name, expected_docstring\n    # Clean up by deleting the temporary file\n    os.remove(file_path)\n\n\ndef test_get_function_docstring_success(temp_python_file_with_function):\n    # Use the temporary Python file created by the fixture `temp_python_file_with_function`\n    file_path, function_name, expected_docstring = temp_python_file_with_function\n    endpoint_path = get_endpoint_path(file_path)\n    print(file_path)\n    print(endpoint_path)\n\n    # Call the get_function_docstring endpoint\n    response = client.get(f\"/api/v1/programming/get_function_docstring/python/{endpoint_path}/{function_name}\")\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response contains the expected docstring\n    assert response.json() == {'docstring': expected_docstring}\n\n\ndef test_get_function_docstring_nonexistent_function(temp_python_file_with_function):\n    # Use the temporary Python file created by the fixture `temp_python_file_with_function`\n    file_path, _, _ = temp_python_file_with_function\n    endpoint_path = get_endpoint_path(file_path)\n    nonexistent_function_name = 'nonexistent_function'\n\n    # Call the get_function_docstring endpoint with a nonexistent function name\n    response = client.get(f\"/api/v1/programming/get_function_docstring/python/{endpoint_path}/{nonexistent_function_name}\")\n\ndef test_update_function_docstring_success(temp_python_file_with_function):\n    # Use the temporary Python file created by the fixture `temp_python_file_with_function`\n    file_path, function_name, _ = temp_python_file_with_function\n    endpoint_path = get_endpoint_path(file_path)\n    new_docstring = 'This is the updated docstring.'\n\n    # Call the update_function_docstring endpoint\n    response = client.put(\n        f\"/api/v1/programming/update_function_docstring/python/{endpoint_path}/{function_name}\",\n        json={\"new_docstring\": new_docstring}\n    )\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response contains the expected message\n    assert response.json() == {\"status\": \"success\", \"message\": \"Function docstring updated\"}\n\n    # Verify that the docstring was actually updated in the file\n    with open(file_path, 'r') as file:\n        content = file.read()\n    assert new_docstring in content\n\n\ndef test_get_function_docstring_nonexistent_file():\n    # Define a nonexistent file path and a sample function name\n    nonexistent_file_path = 'nonexistent_file.py'\n    function_name = 'sample_function'\n\n    # Call the get_function_docstring endpoint with a nonexistent file path\n    response = client.get(f\"/api/v1/programming/get_function_docstring/python/{nonexistent_file_path}/{function_name}\")\n\n    # Assert that the response status code is 404 (Not Found)\n    assert response.status_code == 404\n\n    # Assert that the response contains the expected error message\n    assert response.json() == {'detail': 'File not found'}\n\ndef test_get_class_docstring_no_docstring(temp_python_file_with_class):\n    # Modify the temporary Python file created by the fixture `temp_python_file_with_class`\n    # to remove the docstring from the class\n    file_path, class_name, _ = temp_python_file_with_class\n    with open(file_path, 'w') as file:\n        file.write(\"class SampleClass:\\n    pass\\n\")\n\n    endpoint_path = get_endpoint_path(file_path)\n    # Call the get_class_docstring endpoint\n    response = client.get(f\"/api/v1/programming/get_class_docstring/python/{endpoint_path}/{class_name}\")\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response indicates that no docstring was found\n    assert response.json() == {'docstring': None}\n\n\ndef test_update_class_docstring_no_docstring(temp_python_file_with_class):\n    # Modify the temporary Python file created by the fixture `temp_python_file_with_class`\n    # to remove the docstring from the class\n    file_path, class_name, _ = temp_python_file_with_class\n    with open(file_path, 'w') as file:\n        file.write(\"class SampleClass:\\n    pass\\n\")\n    new_docstring = 'This is the new docstring.'\n\n    endpoint_path = get_endpoint_path(file_path)\n    # Call the update_class_docstring endpoint\n    response = client.put(\n        f\"/api/v1/programming/update_class_docstring/python/{endpoint_path}/{class_name}\",\n        json={\"new_docstring\": new_docstring}\n    )\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response contains the expected message\n    assert response.json() == {\"status\": \"success\", \"message\": \"Class docstring updated\"}\n\n    # Verify that the docstring was actually added to the class in the file\n    with open(file_path, 'r') as file:\n        content = file.read()\n    assert new_docstring in content\n\ndef test_get_module_docstring_success(temp_python_file_with_class):\n    # Use the temporary Python file created by the fixture `temp_python_file_with_class`\n    file_path, _, _ = temp_python_file_with_class\n    # Add a module-level docstring to the file\n    with open(file_path, 'r+') as file:\n        content = file.read()\n        file.seek(0, 0)\n        file.write('''\\\"\\\"\\\"This is a module-level docstring.\\\"\\\"\\\"\\n''' + content)\n    expected_docstring = 'This is a module-level docstring.'\n\n    endpoint_path = get_endpoint_path(file_path)\n    # Call the get_module_docstring endpoint\n    response = client.get(\"/api/v1/programming/get_module_docstring/python/\" + endpoint_path)\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response contains the expected docstring\n    assert response.json() == {\"docstring\": expected_docstring}\n\ndef test_get_module_docstring_no_docstring(temp_python_file_without_docstring):\n    # Use the temporary Python file created by the fixture `temp_python_file_without_docstring`\n    file_path, _ = temp_python_file_without_docstring\n    expected_docstring = None\n    endpoint_path = get_endpoint_path(file_path)\n\n    # Call the get_module_docstring endpoint\n    response = client.get(f\"/api/v1/programming/get_module_docstring/python/{endpoint_path}\")\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response contains the expected docstring\n    assert response.json() == {'docstring': expected_docstring}\n\ndef test_update_module_docstring_success(temp_python_file_with_class):\n    # Use the temporary Python file created by the fixture `temp_python_file_with_class`\n    file_path, _, _ = temp_python_file_with_class\n    # Add a module-level docstring to the file\n    with open(file_path, 'r+') as file:\n        content = file.read()\n        file.seek(0, 0)\n        file.write('''\\\"\\\"\\\"This is the original module-level docstring.\\\"\\\"\\\"\\n''' + content)\n    new_docstring = 'This is the new module-level docstring.'\n    endpoint_path = get_endpoint_path(file_path)\n\n    # Call the update_module_docstring endpoint\n    response = client.put(\n        f\"/api/v1/programming/update_module_docstring/python/{endpoint_path}\",\n        json={\"new_docstring\": new_docstring}\n    )\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response contains the expected message\n    assert response.json() == {\"status\": \"success\", \"message\": \"Module docstring updated\"}\n\n    # Verify that the docstring was actually updated in the file\n    with open(file_path, 'r') as file:\n        content = file.read()\n    assert new_docstring in content\n\ndef test_update_module_docstring_no_docstring(temp_python_file_with_class):\n    # Use the temporary Python file created by the fixture `temp_python_file_with_class`\n    file_path, _, _ = temp_python_file_with_class\n    new_docstring = 'This is the new module-level docstring.'\n\n    endpoint_path = get_endpoint_path(file_path)\n    # Call the update_module_docstring endpoint\n    response = client.put(\n        f\"/api/v1/programming/update_module_docstring/python/{endpoint_path}\",\n        json={\"new_docstring\": new_docstring}\n    )\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response contains the expected message\n    assert response.json() == {\"status\": \"success\", \"message\": \"Module docstring updated\"}\n\n    # Verify that the docstring was actually added to the file\n    with open(file_path, 'r') as file:\n        content = file.read()\n    assert new_docstring in content\n\ndef test_get_class_docstring_success(temp_python_file_with_class):\n    # Use the temporary Python file created by the fixture `temp_python_file_with_class`\n    file_path, class_name, _ = temp_python_file_with_class\n    expected_docstring = 'This is a sample class.'\n    endpoint_path = get_endpoint_path(file_path)\n\n    # Call the get_class_docstring endpoint\n    response = client.get(f\"/api/v1/programming/get_class_docstring/python/{endpoint_path}/{class_name}\")\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response contains the expected docstring\n    assert response.json() == {'docstring': expected_docstring}\n\ndef test_update_class_docstring_success(temp_python_file_with_class):\n    # Use the temporary Python file created by the fixture `temp_python_file_with_class`\n    file_path, class_name, _ = temp_python_file_with_class\n    new_docstring = 'This is the updated class docstring.'\n    endpoint_path = get_endpoint_path(file_path)\n\n    # Call the update_class_docstring endpoint\n    response = client.put(\n        f\"/api/v1/programming/update_class_docstring/python/{endpoint_path}/{class_name}\",\n        json={\"new_docstring\": new_docstring}\n    )\n\n    # Assert that the response status code is 200 (OK)\n    assert response.status_code == 200\n\n    # Assert that the response contains the expected message\n    assert response.json() == {\"status\": \"success\", \"message\": \"Class docstring updated\"}\n\n"}
{"type": "test_file", "path": "src/tests/api/api_v1/__init__.py", "content": ""}
{"type": "test_file", "path": "src/tests/api/api_v1/test_directories.py", "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom src.main import app\nimport os\nimport shutil\n\nclient = TestClient(app)\n\n# Test setup and teardown\n@pytest.fixture(scope='module')\ndef test_directory():\n    # Create a temporary test directory\n    test_dir = 'test_directory'\n    os.makedirs(test_dir, exist_ok=True)\n    yield test_dir\n    # Teardown: Remove the test directory\n    shutil.rmtree(test_dir)\n\n# Test cases for create_directory endpoint\ndef test_create_directory_success(test_directory):\n    response = client.post('/api/v1/directories', json={'dir_name': 'test_dir', 'path': test_directory})\n    assert response.status_code == 200\n\ndef test_create_directory_invalid_path():\n    response = client.post('/api/v1/directories', json={'dir_name': 'test_dir', 'path': '/invalid_path/'})\n    assert response.status_code == 409\n\n# Test cases for list_directory_contents endpoint\ndef test_list_directory_contents_success(test_directory):\n    response = client.get(f'/api/v1/directories/{test_directory}')\n    assert response.status_code == 200\n    assert 'contents' in response.json()\n\ndef test_list_directory_contents_non_existent():\n    response = client.get('/api/v1/directories/non_existent')\n    assert response.status_code == 404\n    assert response.json() == {'detail': 'Directory not found'}\n\n# Test cases for delete_directory endpoint\ndef test_delete_directory_success(test_directory):\n    response = client.delete(f'/api/v1/directories/{test_directory}/test_dir')\n    assert response.status_code == 200\n    assert response.json() == {'message': 'Directory deleted successfully'}\n\ndef test_delete_directory_non_existent():\n    response = client.delete('/api/v1/directories/non_existent')\n    assert response.status_code == 404\n    assert response.json() == {'detail': 'Directory not found'}"}
{"type": "source_file", "path": "src/api/api.py", "content": "import yaml\nimport subprocess\n\nfrom fastapi import APIRouter\n\nfrom src.api.endpoints import files, directories, utils, programming, command, context, ai_plugin\n\napi_router = APIRouter()\napi_router.include_router(files.router, prefix=\"/files\", tags=[\"files\"])\napi_router.include_router(directories.router, prefix=\"/directories\", tags=[\"directories\"])\napi_router.include_router(programming.router, prefix=\"/programming\", tags=[\"programming\"])\napi_router.include_router(command.commands_router, prefix=\"/commands\", tags=[\"commands\"])\napi_router.include_router(context.router, prefix=\"/context\", tags=[\"context\"])\napi_router.include_router(utils.router, prefix=\"/utils\", tags=[\"utils\"])\n\nai_plugin_router = APIRouter()\nai_plugin_router.include_router(ai_plugin.router, tags=['ai_plugin'])\n"}
{"type": "source_file", "path": "src/api/__init__.py", "content": ""}
{"type": "source_file", "path": "src/api/endpoints/__init__.py", "content": ""}
{"type": "source_file", "path": "src/api/endpoints/command.py", "content": "from typing import Optional\nfrom fastapi import HTTPException, APIRouter\nimport docker\n\nfrom src.core.config import settings\nfrom src.utils import run_command_in_image, get_filesystem_path\nfrom src.schemas import Command, CommandResponseModel, load_commands\n\n\nfrom fastapi import APIRouter, HTTPException, Depends, Query\nfrom typing import Any, Dict\nfrom pydantic import create_model\nfrom pydantic.fields import Field, FieldInfo\nfrom pydantic.schema import model_schema\n\n\ncommands_router = APIRouter()\n\n\ndef clean_name(flag_or_arg_name: str) -> str:\n    # Function to clean argument names to be valid Python identifiers\n    flag_or_arg_name = flag_or_arg_name.replace('-', '_')\n    # If flag_name begins with digits, prepend 'flag_' to make it a valid Python identifier\n    if flag_or_arg_name[0].isdigit():\n        flag_or_arg_name = 'flag_' + flag_or_arg_name\n    if flag_or_arg_name[0] == '_':\n        flag_or_arg_name = 'flag' + flag_or_arg_name\n    return flag_or_arg_name\n\ndef create_router_for_command(command: Command) -> APIRouter:\n    router = APIRouter()\n\n    # Create a Pydantic model for the command\n    # Field(Query()) is used as only using Field() will not allow the field description to be added.\n    # Seems to be an issue in Pydantic or FastAPI when handling dynamically created models. \n    fields = {}\n    if command.args is not None:\n        for arg in command.args:\n            python_friendly_arg_name = clean_name(arg.name)\n            fields[python_friendly_arg_name] = (str, Field(Query(..., description=arg.description))) if not arg.optional else (Optional[str], Field(Query(None, description=arg.description)))\n        \n    if command.flags is not None:\n        for flag in command.flags:\n            if flag.optional:  # Only optional flags are added as fields\n                python_friendly_flag_name = clean_name(flag.name)\n                if flag.type == \"bool\":\n                    fields[python_friendly_flag_name] = (bool, Field(Query(False, description=\"Flag: \" + flag.description)))\n                if flag.type == \"str\":\n                    fields[python_friendly_flag_name] = (str, Field(Query(\"\", description=\"Flag: \" + flag.description)))\n\n    CommandModel = create_model(command.name.capitalize(), **fields)\n\n    @router.post(f\"/command/{command.name}\", response_model=CommandResponseModel, description=command.description)\n    async def run_command(\n        command_model: CommandModel = Depends()\n    ) -> Dict[str, Any]:\n        command_line = [command.command]\n\n        # Add arguments and flags to the command line\n        if command.args is not None:\n            for arg in command.args:\n                python_friendly_arg_name = clean_name(arg.name)\n                value = getattr(command_model, python_friendly_arg_name, None)\n                if value is not None:\n                    if arg.is_directory_or_file:\n                        command_line.extend([get_filesystem_path(str(value))])\n                    else:\n                        command_line.extend([str(value)])\n                    \n        if command.flags is not None:\n            for flag in command.flags:\n                python_friendly_flag_name = clean_name(flag.name)\n                if not flag.optional:  # Required flags are added automatically\n                    if flag.is_short:\n                        flag_str = f\"-{flag.name}\"\n                    else:\n                        flag_str = f\"--{flag.name}\"\n                    command_line.append(flag_str)\n                else:  # Optional flags are added only if their value is True\n                    value = getattr(command_model, python_friendly_flag_name, None)\n                    if value:\n                        if flag.is_short:\n                            flag_str = f\"-{flag.name}\"\n                        else:\n                            flag_str = f\"--{flag.name}\"\n                        if flag.type == \"str\":  # Use the provided value as the flag's value\n                            flag_value = str(value)\n                            command_line.append(f\"{flag_str}={flag_value}\")\n                        else:\n                            command_line.append(flag_str)\n\n        try:\n            exit_code, output_str = run_command_in_image(settings.TARGET_REPO_DOCKER_IMAGE_NAME, command_line)\n        except docker.errors.ImageNotFound:\n            raise HTTPException(status_code=400, \n                                detail=f\"Target repo docker image with name '{settings.TARGET_REPO_DOCKER_IMAGE_NAME}' not found.\")\n        return {\"command\": ' '.join(command_line), \"exit_code\": exit_code, \"output_str\": output_str}\n\n    return router\n\n\ncommands = load_commands('command_config.yml')\nfor command in commands:\n    router = create_router_for_command(command)\n    commands_router.include_router(router)\n"}
{"type": "source_file", "path": "src/api/deps.py", "content": "from typing import Generator\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import jwt\nfrom pydantic import ValidationError\nfrom sqlalchemy.orm import Session\n\nfrom src import crud, models, schemas\nfrom src.core import security\nfrom src.core.config import settings\nfrom src.db.session import SessionLocal\n\nreusable_oauth2 = OAuth2PasswordBearer(\n    tokenUrl=f\"{settings.API_V1_STR}/login/access-token\"\n)\n\n\ndef get_db() -> Generator:\n    try:\n        db = SessionLocal()\n        yield db\n    finally:\n        db.close()\n\n\ndef get_current_user(\n    db: Session = Depends(get_db), token: str = Depends(reusable_oauth2)\n) -> models.User:\n    try:\n        payload = jwt.decode(\n            token, settings.SECRET_KEY, algorithms=[security.ALGORITHM]\n        )\n        token_data = schemas.TokenPayload(**payload)\n    except (jwt.JWTError, ValidationError):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials\",\n        )\n    user = crud.user.get(db, id=token_data.sub)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\n\ndef get_current_active_user(\n    current_user: models.User = Depends(get_current_user),\n) -> models.User:\n    if not crud.user.is_active(current_user):\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n\n\ndef get_current_active_superuser(\n    current_user: models.User = Depends(get_current_user),\n) -> models.User:\n    if not crud.user.is_superuser(current_user):\n        raise HTTPException(\n            status_code=400, detail=\"The user doesn't have enough privileges\"\n        )\n    return current_user\n"}
{"type": "source_file", "path": "src/__init__.py", "content": ""}
{"type": "source_file", "path": "src/api/endpoints/context.py", "content": "from fastapi import HTTPException, Query, APIRouter\nfrom pathlib import Path as FilePath\nimport fnmatch\nimport os\nimport shutil\nfrom typing import Any, Dict\n\nfrom src.utils import get_filesystem_path\nfrom src.core.config import settings\nfrom src.utils import is_llmignored, get_git_diff\n\nrouter = APIRouter()\n\n\ndef get_directory_structure(path: str) -> Dict[str, Any]:\n    item = {\n        \"name\": os.path.basename(path),\n        \"path\": path[len(str(settings.REPO_ROOT)):], # Remove the repo root from the path\n        \"type\": \"file\" if os.path.isfile(path) else \"directory\"\n    }\n\n    try:\n        # Ignore any path / files that are in .llmignore or are part of a .git directory\n        if is_llmignored(item[\"path\"]) or item[\"path\"][-4:] == '.git':\n                return None\n\n        if os.path.isfile(path):\n\n            item[\"metadata\"] = {\n                \"file_size_bytes\": os.path.getsize(path)\n            }\n        else:\n            children = [\n                get_directory_structure(os.path.join(path, child))\n                for child in os.listdir(path)\n            ]\n            item[\"children\"] = [child for child in children if child is not None]\n\n        return item\n    except FileNotFoundError:\n        # TODO - there are some situations, particularly in python environment, where\n        # the file does seem to exist but we get a FileNotFoundError. This is a hacky\n        # workaround for now. Example of error that has happened:\n        # E.g FileNotFoundError: [Errno 2] No such file or directory: '/repo/venv/bin/python'\n        return None\n\n\n@router.post(\"/file_structure/{dir_path:path}\")\nasync def get_file_structure(dir_path: str):\n    \"\"\"\n    Get file structure of given directory and subdirectories. Ignores `.git` directory\n    and any file matching `.llmignore` patterns. `.llmignore` must be in the \n    root directory of repo and follow same structure as `.gitignore`.\n    \"\"\"\n    dir_path = get_filesystem_path(dir_path)\n    if not os.path.exists(dir_path):\n        raise HTTPException(status_code=404, detail=\"Directory not found\")\n    structure = get_directory_structure(dir_path)\n    return structure\n\n\n@router.get(\"/git_diff\")\nasync def git_diff():\n    \"\"\"\n    Returns `git diff` for the repo (changes since last commit).\n    \"\"\"\n    try:\n        diff = get_git_diff(settings.REPO_ROOT)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n    return {\"diff\": diff}\n\n\n"}
{"type": "source_file", "path": "src/api/endpoints/ai_plugin.py", "content": "\nfrom fastapi import FastAPI, APIRouter\nfrom fastapi.responses import FileResponse\nfrom pathlib import Path\n\n# Create a new APIRouter instance\nrouter = APIRouter()\n\n# Define the path to the file you want to serve\n\n@router.get(\"/.well-known/ai-plugin.json\")\nasync def serve_ai_plugin_json():\n    plugin_json_file_path = Path(\"src/ai-plugin.json\")\n    # Check if the file exists\n    if not plugin_json_file_path.is_file():\n        return {\"detail\": \"File not found\"}, 404\n\n    # Serve the file using FileResponse\n    return FileResponse(plugin_json_file_path)\n\n\n@router.get(\"/logo.png\")\nasync def serve_logo_png():\n    logo_file_path = Path(\"src/logo.png\")\n    # Check if the file exists\n    if not logo_file_path.is_file():\n        return {\"detail\": \"File not found\"}, 404\n\n    # Serve the file using FileResponse\n    return FileResponse(logo_file_path)\n\n"}
{"type": "source_file", "path": "src/core/__init__.py", "content": ""}
{"type": "source_file", "path": "src/api/endpoints/directories.py", "content": "from fastapi import APIRouter, HTTPException, Path\nfrom pathlib import Path as FilePath\nimport shutil\n\nfrom src.schemas import DirectoryRequest\nfrom src.utils import is_llmignored\n\nrouter = APIRouter()\n\n\n@router.get(\"/{dir_path:path}\")\nasync def list_directory_contents(dir_path: str):\n    target_path = FilePath(dir_path)\n    if is_llmignored(str(target_path)):\n        raise HTTPException(status_code=404, detail=\"Directory is ignored in `.llmignore`\")\n    if target_path.is_dir():\n        contents = [str(item) for item in target_path.iterdir()]\n        return {\"contents\": contents}\n    else:\n        raise HTTPException(status_code=404, detail=\"Directory not found\")\n\n\n@router.post(\"/\")\nasync def create_directory(directory_request: DirectoryRequest):\n    target_path = FilePath(directory_request.path) / directory_request.dir_name\n    parent_directory = target_path.parent\n    if is_llmignored(str(target_path)):\n        raise HTTPException(status_code=404, detail=\"Directory is ignored in `.llmignore`\")\n    if not parent_directory.exists():\n        raise HTTPException(status_code=409, detail=\"Parent directory does not exist\")\n    if not target_path.exists():\n        target_path.mkdir(parents=True, exist_ok=True)\n        return {\"message\": \"Directory created successfully\"}\n    else:\n        raise HTTPException(status_code=409, detail=\"Directory already exists\")\n\n\n@router.delete(\"/{dir_path:path}\")\nasync def delete_directory(dir_path: str):\n    target_path = FilePath(dir_path)\n    if is_llmignored(str(target_path)):\n        raise HTTPException(status_code=404, detail=\"Directory is ignored in `.llmignore`\")\n    if target_path.is_dir():\n        shutil.rmtree(target_path)\n        return {\"message\": \"Directory deleted successfully\"}\n    else:\n        raise HTTPException(status_code=404, detail=\"Directory not found\")\n"}
{"type": "source_file", "path": "src/schemas/item.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\n# Shared properties\nclass ItemBase(BaseModel):\n    title: Optional[str] = None\n    description: Optional[str] = None\n\n\n# Properties to receive on item creation\nclass ItemCreate(ItemBase):\n    title: str\n\n\n# Properties to receive on item update\nclass ItemUpdate(ItemBase):\n    pass\n\n\n# Properties shared by models stored in DB\nclass ItemInDBBase(ItemBase):\n    id: int\n    title: str\n    owner_id: int\n\n    class Config:\n        orm_mode = True\n\n\n# Properties to return to client\nclass Item(ItemInDBBase):\n    pass\n\n\n# Properties properties stored in DB\nclass ItemInDB(ItemInDBBase):\n    pass\n"}
{"type": "source_file", "path": "src/schemas/msg.py", "content": "from pydantic import BaseModel\n\n\nclass Msg(BaseModel):\n    msg: str\n"}
{"type": "source_file", "path": "src/main.py", "content": "from fastapi import FastAPI\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom src.api.api import api_router, ai_plugin_router\nfrom src.core.config import settings\n\napp = FastAPI(\n    title=settings.PROJECT_NAME, \n    openapi_url=f\"{settings.API_V1_STR}/openapi.json\",\n)\n\n# Set all CORS enabled origins\nif settings.BACKEND_CORS_ORIGINS:\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\napp.include_router(api_router, prefix=settings.API_V1_STR)\napp.include_router(ai_plugin_router)\n"}
{"type": "source_file", "path": "src/schemas/command.py", "content": "import yaml\nfrom pydantic import BaseModel, Field, ValidationError\nfrom typing import List, Optional\n\nclass Flag(BaseModel):\n    name: str\n    is_short: bool\n    type: str\n    description: str\n    optional: bool = Field(default=True)\n\nclass Argument(BaseModel):\n    name: str\n    is_directory_or_file: bool\n    description: str\n    optional: bool = Field(default=True)\n\nclass Command(BaseModel):\n    name: str\n    command: str\n    description: str\n    args: Optional[List[Argument]]\n    flags: Optional[List[Flag]]\n\nclass CommandResponseModel(BaseModel):\n    command: str\n    exit_code: int\n    output_str: str\n\n\ndef load_commands(file_path: str) -> List[Command]:\n    try:\n        with open(file_path, 'r') as f:\n            data = yaml.safe_load(f)\n\n        commands = [Command(**command) for command in data['commands']]\n        return commands\n    except ValidationError as e:\n        print(f\"Error in `command_config.yml` configuration file: {e}\")\n        raise\n\n"}
{"type": "source_file", "path": "src/api/endpoints/utils.py", "content": "from fastapi import HTTPException, APIRouter\nfrom pathlib import Path as FilePath\nimport shutil\n\nfrom src.schemas import MoveRequest\nfrom src.utils import is_llmignored\n\nrouter = APIRouter()\n\n\n@router.post(\"/move\")\nasync def move_file_or_directory(move_request: MoveRequest):\n    src_path = FilePath(move_request.src_path)\n    dest_path = FilePath(move_request.dest_path)\n    if is_llmignored(str(src_path)):\n        raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n    if src_path.exists():\n        shutil.move(src_path, dest_path)\n        return {\"message\": \"Moved successfully\"}\n    else:\n        raise HTTPException(status_code=404, detail=\"Source not found\")\n\n"}
{"type": "source_file", "path": "src/api/endpoints/files.py", "content": "from fastapi import FastAPI, APIRouter, HTTPException, Path, status\nfrom fastapi.responses import JSONResponse\nfrom pathlib import Path as FilePath\nimport os\nfrom typing import Optional\nfrom src.schemas import CreateFileRequest, UpdateEntireFileRequest, UpdateFileLineNumberRequest\nfrom src.core.config import settings\nfrom src.utils import get_filesystem_path, is_llmignored\n\nrouter = APIRouter()\n\n\n@router.get(\"/{file_path:path}\")\nasync def read_file(file_path: str):\n    path = get_filesystem_path(file_path)\n\n    if is_llmignored(path):\n        raise HTTPException(status_code=403, detail=\"File is ignored in `.llmignore`\")\n    if not os.path.exists(path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n    if os.path.isfile(path):\n        try:\n            with open(path, \"r\") as file:\n                content = file.read()\n            return {\"content\": content}\n        except PermissionError:\n            raise HTTPException(status_code=403, detail=\"Permission denied\")\n        except Exception as e:\n            raise HTTPException(status_code=500, detail=f\"Internal server error: {e}\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Path is not a file\")\n\n\n@router.post(\"/\")\nasync def create_file(file_request: CreateFileRequest):\n    target_path = file_request.path + '/' + file_request.file_name\n    if is_llmignored(file_request.file_name):\n        raise HTTPException(status_code=403, detail=\"Cannot create file that is ignored in `.llmignore`\")\n    if file_request.create_directories and not os.path.exists(file_request.path):\n        path = FilePath(target_path)\n        path.parent.mkdir(parents=True, exist_ok=True)\n    if not file_request.create_directories and not os.path.exists(file_request.path):\n        raise HTTPException(status_code=404, detail=\"Directory not found\")\n    if not os.path.exists(target_path):\n        with open(target_path, \"w\") as file:\n            file.write(file_request.content)\n        return JSONResponse(content={\"message\": \"File created successfully\"}, status_code=status.HTTP_201_CREATED)\n    else:\n        raise HTTPException(status_code=409, detail=\"File already exists\")\n\n\n@router.put(\"/edit_entire_file/{file_path:path}\")\nasync def update_entire_file(file_path: str, update_request: UpdateEntireFileRequest):\n    path = get_filesystem_path(file_path)\n\n    if not os.path.exists(path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n    if is_llmignored(path):\n        raise HTTPException(status_code=403, detail=\"File is ignored in `.llmignore`\")\n\n    if os.path.isfile(path):\n        try:\n            with open(path, \"w\") as file:\n                file.write(update_request.content)\n            return {\"message\": \"File updated successfully\"}\n        except PermissionError:\n            raise HTTPException(status_code=403, detail=\"Permission denied\")\n        except Exception as e:\n            raise HTTPException(status_code=500, detail=f\"Internal server error: {e}\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Path is not a file\")\n\n\n@router.post(\"/edit_by_line_number/{file_path:path}\")\nasync def edit_file_by_line_number(file_path: str, edit_request: UpdateFileLineNumberRequest):\n    '''\n    This function edits a file by line number, where the first line in the file is 0.\n    If no end_line is specified, it will only edit the start_line.\n    '''\n\n    path = get_filesystem_path(file_path)\n\n    if not os.path.exists(path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n    if is_llmignored(path):\n        raise HTTPException(status_code=403, detail=\"File is ignored in `.llmignore`\")\n\n    if os.path.isfile(path):\n        try:\n            start_line = edit_request.start_line\n            end_line = edit_request.end_line or start_line\n            content = edit_request.content\n\n            with open(path, \"r\") as file:\n                lines = file.readlines()\n\n            if start_line < 0 or start_line > len(lines) - 1 or end_line < start_line or end_line > len(lines) - 1:\n                raise HTTPException(status_code=400, detail=\"Invalid line numbers\")\n\n            # Replace the specified lines with the new content\n            lines[start_line:end_line + 1] = content.splitlines(keepends=True)\n\n            with open(path, \"w\") as file:\n                file.writelines(lines)\n\n            return {\"message\": \"File updated successfully\"}\n\n        except FileNotFoundError:\n            raise HTTPException(status_code=404, detail=\"File not found\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Path is not a file\")\n\n\n@router.delete(\"/{file_path:path}\")\nasync def delete_file(file_path: str):\n    path = get_filesystem_path(file_path)\n\n    if not os.path.exists(path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n    if is_llmignored(path):\n        raise HTTPException(status_code=403, detail=\"File is ignored in `.llmignore`\")\n    if os.path.isfile(path):\n        os.remove(path)\n        return {\"message\": \"File deleted successfully\"}\n    else:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n\n"}
{"type": "source_file", "path": "src/core/config.py", "content": "import os\nimport secrets\nfrom typing import List, Union, Optional\n\nfrom pydantic import AnyHttpUrl, BaseSettings, validator, DirectoryPath, FilePath\n\n\nclass Settings(BaseSettings):\n    API_V1_STR: str = \"/api/v1\"\n    SECRET_KEY: str = secrets.token_urlsafe(32)\n    # 60 minutes * 24 hours * 8 days = 8 days\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 8\n    # BACKEND_CORS_ORIGINS is a JSON-formatted list of origins\n    # e.g: '[\"http://localhost\", \"http://localhost:4200\", \"http://localhost:3000\", \\\n    # \"http://localhost:8080\", \"http://local.dockertoolbox.tiangolo.com\"]'\n    BACKEND_CORS_ORIGINS: List[AnyHttpUrl] = [\"https://chat.openai.com\"]\n\n    @validator(\"BACKEND_CORS_ORIGINS\", pre=True)\n    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:\n        if isinstance(v, str) and not v.startswith(\"[\"):\n            return [i.strip() for i in v.split(\",\")]\n        elif isinstance(v, (list, str)):\n            return v\n        raise ValueError(v)\n\n    PROJECT_NAME: str = \"LLM Repo Assistant\"\n\n    REPO_ROOT: str = \"/repo\"\n\n    LLMIGNORE_PATH: Optional[FilePath] = None\n\n    TARGET_REPO_DOCKER_IMAGE_NAME: str\n\n    TARGET_REPO_PATH: str\n\n    class Config:\n        env_file = \".env\"\n        case_sensitive = True\n\n\nsettings = Settings()\nsettings.LLMIGNORE_PATH = os.path.join(settings.REPO_ROOT, \".llmignore\")\n"}
{"type": "source_file", "path": "src/schemas/__init__.py", "content": "from .file import CreateFileRequest, UpdateEntireFileRequest, UpdateFileLineNumberRequest\nfrom .directory import DirectoryRequest\nfrom .programming import UpdateFunctionDefinitionRequest, UpdateClassDefinitionRequest, NewFunctionDefinitionRequest, NewClassDefinitionRequest, UpdateFunctionDocstringRequest\nfrom .command import Command, CommandResponseModel, load_commands\nfrom .util import MoveRequest\nfrom .msg import Msg\n"}
{"type": "source_file", "path": "src/schemas/file.py", "content": "import re\nfrom typing import Optional\nfrom pydantic import BaseModel, validator, FilePath, DirectoryPath\nimport pathlib\n\nfrom src.utils import get_filesystem_path\n\n\nclass CreateFileRequest(BaseModel):\n    file_name: str\n    path: str\n    content: str\n    create_directories: bool = False\n\n    @validator('file_name')\n    def validate_file_name(cls, file_name: str) -> str:\n        # Check if the file_name contains only valid characters\n        if not re.match(r'^[\\w\\-. ]+$', file_name):\n            raise ValueError('Invalid file name')\n\n        # Sanitize the file_name by removing leading and trailing whitespace\n        return file_name.strip()\n\n    # Validate and sanitize the path field\n    @validator('path')\n    def validate_path(cls, path: str) -> pathlib.Path:\n        # Remove any leading slashes and ensure it's a relative path\n        sanitized_path = get_filesystem_path(path)\n\n        # Check if the sanitized_path contains only valid characters\n        if not re.match(r'^[\\w\\-./ ]*$', sanitized_path):\n            raise ValueError('Invalid path')\n\n        return sanitized_path\n\nclass UpdateEntireFileRequest(BaseModel):\n    content: str\n\n\nclass UpdateFileLineNumberRequest(BaseModel):\n    start_line: int\n    end_line: Optional[int] = None\n    content: str\n"}
{"type": "source_file", "path": "src/schemas/directory.py", "content": "from pydantic import BaseModel\n\nclass DirectoryRequest(BaseModel):\n    dir_name: str\n    path: str\n"}
{"type": "source_file", "path": "src/schemas/programming.py", "content": "from pydantic import BaseModel\nfrom typing import Optional\n\n\nclass UpdateFunctionDefinitionRequest(BaseModel):\n    new_function_definition: Optional[str] = None\n\n\nclass NewFunctionDefinitionRequest(BaseModel):\n    new_function_definition: str\n\n\nclass UpdateClassDefinitionRequest(BaseModel):\n    new_class_definition: Optional[str] = None\n\n\nclass NewClassDefinitionRequest(BaseModel):\n    new_class_definition: str\n\n\nclass UpdateFunctionDocstringRequest(BaseModel):\n    new_docstring: str\n"}
{"type": "source_file", "path": "src/api/endpoints/programming.py", "content": "import os\nimport ast\nimport astunparse\nfrom enum import Enum\nfrom fastapi import FastAPI, HTTPException, Query, APIRouter, Body\nfrom typing import Optional\n\nfrom src.schemas import UpdateFunctionDefinitionRequest, UpdateClassDefinitionRequest, NewFunctionDefinitionRequest, NewClassDefinitionRequest, UpdateFunctionDocstringRequest\nfrom src.utils import extract_file_summary, get_filesystem_path\nfrom src.core.config import settings\nfrom src.utils import is_llmignored\n\n#TODO:\n# - Endpoint to run test suite\n# - Endpoint to run a single test\n#     Perhaps an endpoint to run a command line command, from a list specified in the config file?\n# - Add support for javascript\n\nrouter = APIRouter()\n\nclass Language(str, Enum):\n    python = \"python\"\n    #javascript = \"javascript\"\n\n\n@router.get(\"/summary/{language}/{file_path:path}\")\nasync def get_summary(file_path: str, language: Language):\n    \"\"\"\n    Retrieve high level class and function signatures of a programming file\n    to understand what it does.\n    \"\"\"\n    full_file_path = get_filesystem_path(file_path)\n    if is_llmignored(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n    if not os.path.isfile(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n    with open(full_file_path, \"r\") as file:\n        file_content = file.read()\n\n    try:\n        summary = extract_file_summary(file_content, language)\n        return {\"summary\": summary}\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except SyntaxError as e:\n        raise HTTPException(status_code=400, detail=f\"File {language} syntax is invalid\")\n\n\ndef extract_python_function_definition(file_content: str, function_name: str):\n    parsed_ast = ast.parse(file_content)\n\n    function_node = None\n\n    for node in ast.walk(parsed_ast):\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)) and node.name == function_name:\n            function_node = node\n            break\n\n    if function_node is None:\n        raise HTTPException(status_code=404, detail=\"Function not found\")\n\n    decorators = [astunparse.unparse(decorator).strip() for decorator in function_node.decorator_list]\n    function_definition = astunparse.unparse(function_node).strip()\n\n    return {\"decorators\": decorators, \"function_definition\": function_definition}\n\n\n@router.get(\"/function_definition/{language}/{file_path:path}/{function_name}\")\nasync def get_function_definition(file_path: str, \n                                  function_name: str, \n                                  language: Language):\n    full_file_path = get_filesystem_path(file_path)\n    if is_llmignored(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n    if not os.path.isfile(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n    with open(full_file_path, \"r\") as file:\n        file_content = file.read()\n\n    if language.lower() == Language.python:\n        try:\n            return extract_python_function_definition(file_content, function_name)\n        except SyntaxError as e:\n            raise HTTPException(status_code=400, detail=\"Failed to parse the python file\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Unsupported language\")\n\n\ndef extract_python_class_definition(file_content: str, class_name: str):\n    parsed_ast = ast.parse(file_content)\n\n    class_node = None\n\n    for node in ast.walk(parsed_ast):\n        if isinstance(node, ast.ClassDef) and node.name == class_name:\n            class_node = node\n            break\n\n    if class_node is None:\n        raise HTTPException(status_code=404, detail=\"Class not found\")\n\n    decorators = [astunparse.unparse(decorator).strip() for decorator in class_node.decorator_list]\n    class_definition = astunparse.unparse(class_node).strip()\n\n    return {\"decorators\": decorators, \"class_definition\": class_definition}\n\n\n@router.get(\"/class_definition/{language}/{file_path:path}/{class_name}\")\nasync def get_class_definition(language: Language, file_path: str, class_name: str):\n    full_file_path = get_filesystem_path(file_path)\n    if is_llmignored(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n    if not os.path.isfile(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n    with open(full_file_path, \"r\") as file:\n        file_content = file.read()\n\n    if language.lower() == Language.python:\n        try:\n            return extract_python_class_definition(file_content, class_name)\n        except SyntaxError as e:\n            raise HTTPException(status_code=400, detail=\"Failed to parse the python file\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Unsupported language\")\n\n\ndef update_python_function_definition(full_file_path: str, file_content: str, function_name: str, new_function_definition: Optional[str] = None):\n    try:\n        parsed_ast = ast.parse(file_content)\n    except SyntaxError:\n        raise HTTPException(status_code=400, detail=\"Failed to parse the file\")\n\n    function_node = None\n    for node in ast.walk(parsed_ast):\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)) and node.name == function_name:\n            function_node = node\n            break\n\n    if function_node is None:\n        raise HTTPException(status_code=404, detail=\"Function not found\")\n\n    if new_function_definition is not None and new_function_definition.strip() != \"\":\n        try:\n            new_function_ast = ast.parse(new_function_definition)\n            if not isinstance(new_function_ast.body[0], (ast.FunctionDef, ast.AsyncFunctionDef)):\n                raise ValueError(\"Invalid function definition\")\n        except (SyntaxError, ValueError) as e:\n            raise HTTPException(status_code=400, detail=\"Invalid function definition\")\n\n    start_lineno = function_node.lineno - 1\n    if function_node.decorator_list:\n        start_lineno = min(dec.lineno for dec in function_node.decorator_list) - 1\n\n    end_lineno = function_node.end_lineno\n    lines = file_content.splitlines()\n\n    if new_function_definition is not None and new_function_definition.strip() != \"\":\n        new_file_content_lines = lines[:start_lineno] + new_function_definition.splitlines() + lines[end_lineno:]\n        message = f\"Function {function_name} updated\"\n    else:\n        new_file_content_lines = lines[:start_lineno] + lines[end_lineno:]\n        message = f\"Function {function_name} deleted\"\n\n    new_file_content = '\\n'.join(new_file_content_lines)\n\n    with open(full_file_path, \"w\") as file:\n        file.write(new_file_content)\n\n    return {\"status\": \"success\", \"message\": message}\n\n\n@router.put(\"/function_definition/{language}/{file_path:path}/{function_name}\")\nasync def update_function_definition(\n    language: Language,\n    file_path: str,\n    function_name: str,\n    new_function_definition_request: UpdateFunctionDefinitionRequest\n):\n    \"\"\"\n    Update the definition of a function in a programming file. Completely rewrites the function,\n    according to the provided `new_function_definition`, including the function signature.\n    If no new function definition is provided, the function is deleted.\n    \"\"\"\n    full_file_path = get_filesystem_path(file_path)\n    if is_llmignored(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n    if not os.path.isfile(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n    with open(full_file_path, \"r\") as file:\n        file_content = file.read()\n\n    if language.lower() == \"python\":\n        try:\n            return update_python_function_definition(full_file_path, \n                                                     file_content, \n                                                     function_name, \n                                                     new_function_definition_request.new_function_definition)\n        except SyntaxError as e:\n            raise HTTPException(status_code=400, detail=\"Failed to parse the python file\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Unsupported language\")\n\n\n\ndef update_python_class_definition(full_file_path: str, file_content: str, class_name: str, new_class_definition: Optional[str] = None):\n    try:\n        parsed_ast = ast.parse(file_content)\n    except SyntaxError:\n        raise HTTPException(status_code=400, detail=\"Failed to parse the file\")\n\n    class_node = None\n    for node in ast.walk(parsed_ast):\n        if isinstance(node, ast.ClassDef) and node.name == class_name:\n            class_node = node\n            break\n\n    if class_node is None:\n        raise HTTPException(status_code=404, detail=\"Class not found\")\n\n    if new_class_definition is not None and new_class_definition.strip() != \"\":\n        try:\n            new_class_ast = ast.parse(new_class_definition)\n            if not isinstance(new_class_ast.body[0], ast.ClassDef):\n                raise ValueError(\"Invalid class definition\")\n        except (SyntaxError, ValueError) as e:\n            raise HTTPException(status_code=400, detail=\"Invalid class definition\")\n\n    start_lineno = class_node.lineno - 1\n    end_lineno = class_node.end_lineno\n    lines = file_content.splitlines()\n\n    if new_class_definition is not None and new_class_definition.strip() != \"\":\n        new_file_content_lines = lines[:start_lineno] + new_class_definition.splitlines() + lines[end_lineno:]\n        message = f\"Class {class_name} updated\"\n    else:\n        new_file_content_lines = lines[:start_lineno] + lines[end_lineno:]\n        message = f\"Class {class_name} deleted\"\n\n    new_file_content = '\\n'.join(new_file_content_lines)\n\n    with open(full_file_path, \"w\") as file:\n        file.write(new_file_content)\n\n    return {\"status\": \"success\", \"message\": message}\n\n\n@router.put(\"/class_definition/{language}/{file_path:path}/{class_name}\")\nasync def update_class_definition(\n    language: Language,\n    file_path: str,\n    class_name: str,\n    new_class_definition_request: UpdateClassDefinitionRequest\n):\n    \"\"\"\n    Update the definition of a class in a programming file. Completely rewrites the class,\n    according to the provided `new_class_definition`, including the class signature.\n    If no new class definition is provided, the class is deleted.\n    \"\"\"\n    full_file_path = get_filesystem_path(file_path)\n    if is_llmignored(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n    if not os.path.isfile(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n    with open(full_file_path, \"r\") as file:\n        file_content = file.read()\n\n    if language.lower() == \"python\":\n        try:\n            return update_python_class_definition(full_file_path, \n                                                     file_content, \n                                                     class_name, \n                                                     new_class_definition_request.new_class_definition)\n        except SyntaxError as e:\n            raise HTTPException(status_code=400, detail=\"Failed to parse the python file\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Unsupported language\")\n\n\n\ndef insert_python_function_definition(full_file_path: str, file_content: str, new_function_definition: str) -> None:\n    try:\n        new_function_ast = ast.parse(new_function_definition)\n        if not new_function_ast.body:\n            raise ValueError(\"Invalid function definition\")\n        if not isinstance(new_function_ast.body[0], (ast.FunctionDef, ast.AsyncFunctionDef)):\n            raise ValueError(\"Invalid function definition\")\n    except (SyntaxError, ValueError) as e:\n        raise HTTPException(status_code=400, detail=\"Invalid function definition\")\n\n    new_file_content = file_content.strip() + '\\n\\n' + new_function_definition.strip() + '\\n'\n\n    with open(full_file_path, \"w\") as file:\n        file.write(new_file_content)\n\n\n@router.post(\"/function_definition/{language}/{file_path:path}\")\nasync def insert_new_function_definition(\n    language: Language,\n    file_path: str,\n    new_function_request: NewFunctionDefinitionRequest,\n):\n    full_file_path = get_filesystem_path(file_path)\n    if is_llmignored(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n    if not os.path.isfile(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n    with open(full_file_path, \"r\") as file:\n        file_content = file.read()\n\n    if language == Language.python:\n        try:\n            insert_python_function_definition(full_file_path, file_content, new_function_request.new_function_definition)\n        except HTTPException as e:\n            raise e\n    else:\n        raise HTTPException(status_code=400, detail=\"Unsupported language\")\n\n    return {\"status\": \"success\", \"message\": \"Function definition created\"}\n\n\ndef insert_python_class_definition(full_file_path: str, file_content: str, new_class_definition: str) -> None:\n    try:\n        new_class_ast = ast.parse(new_class_definition)\n        if not new_class_ast.body:\n            raise ValueError(\"Invalid class definition\")\n        if not isinstance(new_class_ast.body[0], ast.ClassDef):\n            raise ValueError(\"Invalid class definition\")\n    except (SyntaxError, ValueError) as e:\n        raise HTTPException(status_code=400, detail=\"Invalid class definition\")\n\n    new_file_content = file_content.strip() + '\\n\\n' + new_class_definition.strip() + '\\n'\n\n    with open(full_file_path, \"w\") as file:\n        file.write(new_file_content)\n\n\n@router.post(\"/class_definition/{language}/{file_path:path}\")\nasync def create_class_definition(\n    language: Language,\n    file_path: str,\n    new_class_request: NewClassDefinitionRequest,\n):\n    full_file_path = get_filesystem_path(file_path)\n    if is_llmignored(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n    if not os.path.isfile(full_file_path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n    with open(full_file_path, \"r\") as file:\n        file_content = file.read()\n\n    if language == Language.python:\n        try:\n            insert_python_class_definition(full_file_path, file_content, new_class_request.new_class_definition)\n        except HTTPException as e:\n            raise e\n        except Exception as e:\n            raise HTTPException(status_code=500, detail=\"Failed to insert the class definition\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Unsupported language\")\n\n    return {\"status\": \"success\", \"message\": \"Class definition created\"}\n\n\n@router.get(\"/get_function_docstring/{language}/{file_path:path}/{function_name}\")\nasync def get_function_docstring(language: Language, file_path: str, function_name: str):\n    try:\n        full_file_path = get_filesystem_path(file_path)\n        if is_llmignored(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n        if not os.path.isfile(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        # Read the content of the file\n        with open(full_file_path, 'r') as file:\n            content = file.read()\n\n        if language == Language.python:\n            # Parse the content using the ast module\n            parsed_content = ast.parse(content)\n\n            # Find the specified function and extract its docstring\n            for node in parsed_content.body:\n                if (isinstance(node, ast.FunctionDef) or isinstance(node, ast.AsyncFunctionDef)) and node.name == function_name:\n                    docstring = ast.get_docstring(node)\n                    return {\"docstring\": docstring}\n\n            # If the function is not found, raise an exception\n            raise HTTPException(status_code=404, detail=\"Function not found\")\n        else:\n            raise HTTPException(status_code=400, detail=\"Unsupported language\")\n\n    except FileNotFoundError:\n        # If the file is not found, raise an exception\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n@router.put('/update_function_docstring/{language}/{file_path:path}/{function_name}')\nasync def update_function_docstring(\n    language: Language,\n    file_path: str,\n    function_name: str,\n    update_docstring_request: UpdateFunctionDocstringRequest\n):\n    try:\n        full_file_path = get_filesystem_path(file_path)\n        if is_llmignored(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n        if not os.path.isfile(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        with open(full_file_path, 'r') as file:\n            content = file.read()\n\n        if language == Language.python:\n            parsed_content = ast.parse(content)\n            for node in parsed_content.body:\n                if (isinstance(node, ast.FunctionDef) or isinstance(node, ast.AsyncFunctionDef)) and node.name == function_name:\n                    node.body[0] = ast.Expr(value=ast.Str(s=update_docstring_request.new_docstring))\n                    with open(full_file_path, 'w') as file:\n                        file.write(astunparse.unparse(parsed_content))\n                    return {'status': 'success', 'message': 'Function docstring updated'}\n            raise HTTPException(status_code=404, detail='Function not found')\n        else:\n            raise HTTPException(status_code=400, detail=\"Unsupported language\")\n    except FileNotFoundError:\n        raise HTTPException(status_code=404, detail='File not found')\n\n@router.get('/get_class_docstring/{language}/{file_path:path}/{class_name}')\nasync def get_class_docstring(language: Language, file_path: str, class_name: str):\n    try:\n        full_file_path = get_filesystem_path(file_path)\n        if is_llmignored(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n        if not os.path.isfile(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        with open(full_file_path, 'r') as file:\n            content = file.read()\n\n        if language == Language.python:\n            parsed_content = ast.parse(content)\n            for node in parsed_content.body:\n                if isinstance(node, ast.ClassDef) and node.name == class_name:\n                    docstring = ast.get_docstring(node)\n                    return {'docstring': docstring}\n            raise HTTPException(status_code=404, detail='Class not found')\n        else:\n            raise HTTPException(status_code=400, detail=\"Unsupported language\")\n    except FileNotFoundError:\n        raise HTTPException(status_code=404, detail='File not found')\n\n@router.put('/update_class_docstring/{language}/{file_path:path}/{class_name}')\nasync def update_class_docstring(\n    language: Language,\n    file_path: str,\n    class_name: str,\n    update_docstring_request: UpdateFunctionDocstringRequest\n):\n    try:\n        full_file_path = get_filesystem_path(file_path)\n        if is_llmignored(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n        if not os.path.isfile(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        with open(full_file_path, 'r') as file:\n            content = file.read()\n\n        if language == Language.python:\n            parsed_content = ast.parse(content)\n            for node in parsed_content.body:\n                if isinstance(node, ast.ClassDef) and node.name == class_name:\n                    node.body[0] = ast.Expr(value=ast.Str(s=update_docstring_request.new_docstring))\n                    with open(full_file_path, 'w') as file:\n                        file.write(astunparse.unparse(parsed_content))\n                    return {'status': 'success', 'message': 'Class docstring updated'}\n            raise HTTPException(status_code=404, detail='Class not found')\n        else:\n            raise HTTPException(status_code=400, detail=\"Unsupported language\")\n    except FileNotFoundError:\n        raise HTTPException(status_code=404, detail='File not found')\n\n@router.get('/get_module_docstring/{language}/{file_path:path}')\nasync def get_module_docstring(language: Language, file_path: str):\n    try:\n        full_file_path = get_filesystem_path(file_path)\n        if is_llmignored(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n        if not os.path.isfile(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        with open(full_file_path, 'r') as file:\n            content = file.read()\n        if language == Language.python:\n            parsed_content = ast.parse(content)\n            docstring = ast.get_docstring(parsed_content)\n            return {'docstring': docstring}\n        else:\n            raise HTTPException(status_code=400, detail=\"Unsupported language\")\n    except FileNotFoundError:\n        raise HTTPException(status_code=404, detail='File not found')\n\n@router.put('/update_module_docstring/{language}/{file_path:path}')\nasync def update_module_docstring(\n    language: Language,\n    file_path: str,\n    update_docstring_request: UpdateFunctionDocstringRequest\n):\n    try:\n        full_file_path = get_filesystem_path(file_path)\n        if is_llmignored(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File is ignored in `.llmignore`\")\n        if not os.path.isfile(full_file_path):\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        with open(full_file_path, 'r') as file:\n            content = file.read()\n\n        if language == Language.python:\n            parsed_content = ast.parse(content)\n            parsed_content.body.insert(0, ast.Expr(value=ast.Str(s=update_docstring_request.new_docstring)))\n            with open(full_file_path, 'w') as file:\n                file.write(astunparse.unparse(parsed_content))\n            return {'status': 'success', 'message': 'Module docstring updated'}\n        else:\n            raise HTTPException(status_code=400, detail=\"Unsupported language\")\n    except FileNotFoundError:\n        raise HTTPException(status_code=404, detail='File not found')\n"}
{"type": "source_file", "path": "src/utils.py", "content": "import os\nimport subprocess\nimport pathlib\nfrom pathlib import Path\nimport ast\nfrom typing import List, Dict, Any\nfrom fastapi import HTTPException\nimport fnmatch\nimport docker\nfrom typing import Tuple\n\nfrom src.core.config import settings\n\n\ndef sanitize_path(path: str) -> str:\n    return path.lstrip('/')\n\n\ndef get_filesystem_path(endpoint_path: str) -> str:\n    \"\"\"\n    Given a target repo path specified by an endpoint, return the actual\n    path on the filesystem.\n    \"\"\"\n    sanitized_path = sanitize_path(endpoint_path)\n    full_path = os.path.join(settings.REPO_ROOT, sanitized_path)\n\n    if not str(full_path).startswith(str(settings.REPO_ROOT)):\n        raise HTTPException(status_code=400, detail=\"Invalid file path\")\n    \n    return str(full_path)\n\ndef get_endpoint_path(file_path: str) -> str:\n    \"\"\"\n    Given a file path to target repo, return the path that should be used for the endpoint.\n    \"\"\"\n    if not str(file_path).startswith(str(settings.REPO_ROOT)):\n        raise HTTPException(status_code=400, \n                            detail=\"Invalid file path - must start with repo root {}\".format(str(settings.REPO_ROOT)))\n    # Remove settings.REPO_ROOT from the beginning of file_path\n    endpoint_path = file_path[len(settings.REPO_ROOT):]\n    # Remove leading slash\n    endpoint_path = endpoint_path.lstrip(\"/\")\n    return endpoint_path\n\n\ndef extract_python_summary(file_content: str) -> List[Dict[str, Any]]:\n    summary = []\n    parsed_ast = ast.parse(file_content)\n\n    for node in ast.iter_child_nodes(parsed_ast):\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            arg_names = [arg.arg for arg in node.args.args]\n            arg_types = [getattr(arg.annotation, \"id\", None) for arg in node.args.args]\n            return_type = getattr(node.returns, \"id\", None) if node.returns else None\n\n            function_summary = {\n                \"type\": \"function\",\n                \"name\": node.name,\n                \"args\": [{\"name\": name, \"type\": type_} for name, type_ in zip(arg_names, arg_types)],\n                \"return_type\": return_type,\n            }\n            summary.append(function_summary)\n\n        elif isinstance(node, ast.ClassDef):\n            class_summary = {\n                \"type\": \"class\",\n                \"name\": node.name,\n                \"methods\": [],\n            }\n\n            for method_node in ast.iter_child_nodes(node):\n                if isinstance(method_node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                    arg_names = [arg.arg for arg in method_node.args.args]\n                    arg_types = [getattr(arg.annotation, \"id\", None) for arg in method_node.args.args]\n                    return_type = getattr(method_node.returns, \"id\", None) if method_node.returns else None\n\n                    method_summary = {\n                        \"type\": \"function\",\n                        \"name\": method_node.name,\n                        \"args\": [{\"name\": name, \"type\": type_} for name, type_ in zip(arg_names, arg_types)],\n                        \"return_type\": return_type,\n                    }\n                    class_summary[\"methods\"].append(method_summary)\n\n            summary.append(class_summary)\n\n        else:\n            # Top-level statements\n            source_code = ast.unparse(node).strip()\n\n            if source_code:\n                statement_summary = {\n                    \"type\": \"statement\",\n                    \"source\": source_code,\n                }\n                summary.append(statement_summary)\n\n    return summary\n\n\ndef extract_file_summary(file_content: str, language: str) -> List[Dict[str, Any]]:\n    if language == \"python\":\n        return extract_python_summary(file_content)\n    else:\n        raise ValueError(f\"Language {language} not supported\")\n\n\ndef load_llmignore_patterns() -> List[str]:\n    if os.path.exists(settings.LLMIGNORE_PATH):\n        with open(settings.LLMIGNORE_PATH, \"r\") as f:\n            return [line.strip() for line in f.readlines() if line.strip() and not line.startswith(\"#\")]\n    return []\n\n\ndef is_llmignored(filesystem_path: str) -> bool:\n    llmignore_patterns = load_llmignore_patterns()\n    path_obj = Path(filesystem_path)\n    for pattern in llmignore_patterns:\n        if fnmatch.fnmatch(path_obj.name, pattern):\n            return True\n        if fnmatch.fnmatch(str(path_obj), pattern):\n            return True\n        if fnmatch.fnmatch(str(path_obj.relative_to(path_obj.anchor)), pattern):\n            return True\n    return False\n\n\ndef is_git_repository(directory: str) -> bool:\n    try:\n        subprocess.run(\n            [\"git\", \"-C\", directory, \"rev-parse\", \"--is-inside-work-tree\"],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\n\ndef get_git_diff(directory: str) -> str:\n    if not is_git_repository(directory):\n        raise ValueError(\"The directory is not a git repository\")\n\n    # Check if there are any commits\n    check_commits = subprocess.run([\"git\", \"-C\", directory, \"rev-parse\", \"--quiet\", \"--verify\", \"HEAD\"], \n                                   capture_output=True, \n                                   text=True)\n\n    if check_commits.returncode != 0:\n        # No commits, so return an empty diff\n        return \"\"\n\n    result = subprocess.run(\n        [\"git\", \"-C\", directory, \"diff\", \"HEAD\"],\n        check=True,\n        capture_output=True,\n        text=True,\n    )\n    return result.stdout\n\n\ndef run_command_in_image(image_name: str, command: List[str]) -> Tuple[int, str]:\n    client = docker.from_env()\n\n    # Run the command in a new container\n    container = client.containers.run(image=image_name, \n                                      command=command, \n                                      detach=True,\n                                      #working_dir=settings.REPO_ROOT,\n                                      volumes={settings.TARGET_REPO_PATH: {\"bind\": settings.REPO_ROOT, \"mode\": \"rw\"}})\n\n    # Wait for the container to finish executing\n    result = container.wait()\n\n    # Fetch the logs (standard output and standard error)\n    output = container.logs()\n\n    # Clean up the container\n    container.remove()\n\n    # Decode the output to a string\n    output_str = output.decode(\"utf-8\")\n\n    # The result contains a dictionary with status and StatusCode (exit code)\n    exit_code = result['StatusCode']\n\n    return exit_code, output_str\n"}
{"type": "source_file", "path": "src/schemas/util.py", "content": "from pydantic import BaseModel\nfrom typing import Optional\n\n\nclass MoveRequest(BaseModel):\n    src_path: str\n    dest_path: str\n\n"}

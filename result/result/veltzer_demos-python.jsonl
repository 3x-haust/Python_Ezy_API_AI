{"repo_info": {"repo_name": "demos-python", "repo_owner": "veltzer", "repo_url": "https://github.com/veltzer/demos-python"}}
{"type": "test_file", "path": "src/examples/long/pytest/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/creational/test_pool.py", "content": "import queue\nimport unittest\n\nfrom patterns.creational.pool import ObjectPool\n\n\nclass TestPool(unittest.TestCase):\n    def setUp(self):\n        self.sample_queue = queue.Queue()\n        self.sample_queue.put(\"first\")\n        self.sample_queue.put(\"second\")\n\n    def test_items_recoil(self):\n        with ObjectPool(self.sample_queue, True) as pool:\n            self.assertEqual(pool, \"first\")\n        self.assertTrue(self.sample_queue.get() == \"second\")\n        self.assertFalse(self.sample_queue.empty())\n        self.assertTrue(self.sample_queue.get() == \"first\")\n        self.assertTrue(self.sample_queue.empty())\n\n    def test_frozen_pool(self):\n        with ObjectPool(self.sample_queue) as pool:\n            self.assertEqual(pool, \"first\")\n            self.assertEqual(pool, \"first\")\n        self.assertTrue(self.sample_queue.get() == \"second\")\n        self.assertFalse(self.sample_queue.empty())\n        self.assertTrue(self.sample_queue.get() == \"first\")\n        self.assertTrue(self.sample_queue.empty())\n\n\nclass TestNaitivePool(unittest.TestCase):\n\n    \"\"\"def test_object(queue):\n    queue_object = QueueObject(queue, True)\n    print(\"Inside func: {}\".format(queue_object.object))\"\"\"\n\n    def test_pool_behavior_with_single_object_inside(self):\n        sample_queue = queue.Queue()\n        sample_queue.put(\"yam\")\n        with ObjectPool(sample_queue) as obj:\n            # print(\"Inside with: {}\".format(obj))\n            self.assertEqual(obj, \"yam\")\n        self.assertFalse(sample_queue.empty())\n        self.assertTrue(sample_queue.get() == \"yam\")\n        self.assertTrue(sample_queue.empty())\n\n    # sample_queue.put(\"sam\")\n    # test_object(sample_queue)\n    # print(\"Outside func: {}\".format(sample_queue.get()))\n\n    # if not sample_queue.empty():\n"}
{"type": "test_file", "path": "tests/test_hsm.py", "content": "import unittest\nfrom unittest.mock import patch\n\nfrom patterns.other.hsm.hsm import (\n    Active,\n    HierachicalStateMachine,\n    Standby,\n    Suspect,\n    UnsupportedMessageType,\n    UnsupportedState,\n    UnsupportedTransition,\n)\n\n\nclass HsmMethodTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.hsm = HierachicalStateMachine()\n\n    def test_initial_state_shall_be_standby(cls):\n        cls.assertEqual(isinstance(cls.hsm._current_state, Standby), True)\n\n    def test_unsupported_state_shall_raise_exception(cls):\n        with cls.assertRaises(UnsupportedState):\n            cls.hsm._next_state(\"missing\")\n\n    def test_unsupported_message_type_shall_raise_exception(cls):\n        with cls.assertRaises(UnsupportedMessageType):\n            cls.hsm.on_message(\"trigger\")\n\n    def test_calling_next_state_shall_change_current_state(cls):\n        cls.hsm._current_state = Standby  # initial state\n        cls.hsm._next_state(\"active\")\n        cls.assertEqual(isinstance(cls.hsm._current_state, Active), True)\n        cls.hsm._current_state = Standby(cls.hsm)  # initial state\n\n    def test_method_perform_switchover_shall_return_specifically(cls):\n        \"\"\"Exemplary HierachicalStateMachine method test.\n        (here: _perform_switchover()). Add additional test cases...\"\"\"\n        return_value = cls.hsm._perform_switchover()\n        expected_return_value = \"perform switchover\"\n        cls.assertEqual(return_value, expected_return_value)\n\n\nclass StandbyStateTest(unittest.TestCase):\n    \"\"\"Exemplary 2nd level state test class (here: Standby state). Add missing\n    state test classes...\"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.hsm = HierachicalStateMachine()\n\n    def setUp(cls):\n        cls.hsm._current_state = Standby(cls.hsm)\n\n    def test_given_standby_on_message_switchover_shall_set_active(cls):\n        cls.hsm.on_message(\"switchover\")\n        cls.assertEqual(isinstance(cls.hsm._current_state, Active), True)\n\n    def test_given_standby_on_message_switchover_shall_call_hsm_methods(cls):\n        with patch.object(\n            cls.hsm, \"_perform_switchover\"\n        ) as mock_perform_switchover, patch.object(\n            cls.hsm, \"_check_mate_status\"\n        ) as mock_check_mate_status, patch.object(\n            cls.hsm, \"_send_switchover_response\"\n        ) as mock_send_switchover_response, patch.object(\n            cls.hsm, \"_next_state\"\n        ) as mock_next_state:\n            cls.hsm.on_message(\"switchover\")\n            cls.assertEqual(mock_perform_switchover.call_count, 1)\n            cls.assertEqual(mock_check_mate_status.call_count, 1)\n            cls.assertEqual(mock_send_switchover_response.call_count, 1)\n            cls.assertEqual(mock_next_state.call_count, 1)\n\n    def test_given_standby_on_message_fault_trigger_shall_set_suspect(cls):\n        cls.hsm.on_message(\"fault trigger\")\n        cls.assertEqual(isinstance(cls.hsm._current_state, Suspect), True)\n\n    def test_given_standby_on_message_diagnostics_failed_shall_raise_exception_and_keep_in_state(\n        cls,\n    ):\n        with cls.assertRaises(UnsupportedTransition):\n            cls.hsm.on_message(\"diagnostics failed\")\n        cls.assertEqual(isinstance(cls.hsm._current_state, Standby), True)\n\n    def test_given_standby_on_message_diagnostics_passed_shall_raise_exception_and_keep_in_state(\n        cls,\n    ):\n        with cls.assertRaises(UnsupportedTransition):\n            cls.hsm.on_message(\"diagnostics passed\")\n        cls.assertEqual(isinstance(cls.hsm._current_state, Standby), True)\n\n    def test_given_standby_on_message_operator_inservice_shall_raise_exception_and_keep_in_state(\n        cls,\n    ):\n        with cls.assertRaises(UnsupportedTransition):\n            cls.hsm.on_message(\"operator inservice\")\n        cls.assertEqual(isinstance(cls.hsm._current_state, Standby), True)\n"}
{"type": "test_file", "path": "tests/creational/test_prototype.py", "content": "import unittest\n\nfrom patterns.creational.prototype import Prototype, PrototypeDispatcher\n\n\nclass TestPrototypeFeatures(unittest.TestCase):\n    def setUp(self):\n        self.prototype = Prototype()\n\n    def test_cloning_propperty_innate_values(self):\n        sample_object_1 = self.prototype.clone()\n        sample_object_2 = self.prototype.clone()\n        self.assertEqual(sample_object_1.value, sample_object_2.value)\n\n    def test_extended_property_values_cloning(self):\n        sample_object_1 = self.prototype.clone()\n        sample_object_1.some_value = \"test string\"\n        sample_object_2 = self.prototype.clone()\n        self.assertRaises(AttributeError, lambda: sample_object_2.some_value)\n\n    def test_cloning_propperty_assigned_values(self):\n        sample_object_1 = self.prototype.clone()\n        sample_object_2 = self.prototype.clone(value=\"re-assigned\")\n        self.assertNotEqual(sample_object_1.value, sample_object_2.value)\n\n\nclass TestDispatcherFeatures(unittest.TestCase):\n    def setUp(self):\n        self.dispatcher = PrototypeDispatcher()\n        self.prototype = Prototype()\n        c = self.prototype.clone()\n        a = self.prototype.clone(value=\"a-value\", ext_value=\"E\")\n        b = self.prototype.clone(value=\"b-value\", diff=True)\n        self.dispatcher.register_object(\"A\", a)\n        self.dispatcher.register_object(\"B\", b)\n        self.dispatcher.register_object(\"C\", c)\n\n    def test_batch_retrieving(self):\n        self.assertEqual(len(self.dispatcher.get_objects()), 3)\n\n    def test_particular_properties_retrieving(self):\n        self.assertEqual(self.dispatcher.get_objects()[\"A\"].value, \"a-value\")\n        self.assertEqual(self.dispatcher.get_objects()[\"B\"].value, \"b-value\")\n        self.assertEqual(self.dispatcher.get_objects()[\"C\"].value, \"default\")\n\n    def test_extended_properties_retrieving(self):\n        self.assertEqual(self.dispatcher.get_objects()[\"A\"].ext_value, \"E\")\n        self.assertTrue(self.dispatcher.get_objects()[\"B\"].diff)\n"}
{"type": "test_file", "path": "tests/behavioral/test_state.py", "content": "import pytest\n\nfrom patterns.behavioral.state import Radio\n\n\n@pytest.fixture\ndef radio():\n    return Radio()\n\n\ndef test_initial_state(radio):\n    assert radio.state.name == \"AM\"\n\n\ndef test_initial_am_station(radio):\n    initial_pos = radio.state.pos\n    assert radio.state.stations[initial_pos] == \"1250\"\n\n\ndef test_toggle_amfm(radio):\n    assert radio.state.name == \"AM\"\n\n    radio.toggle_amfm()\n    assert radio.state.name == \"FM\"\n\n    radio.toggle_amfm()\n    assert radio.state.name == \"AM\"\n"}
{"type": "test_file", "path": "tests/structural/test_adapter.py", "content": "import unittest\n\nfrom patterns.structural.adapter import Adapter, Car, Cat, Dog, Human\n\n\nclass ClassTest(unittest.TestCase):\n    def setUp(self):\n        self.dog = Dog()\n        self.cat = Cat()\n        self.human = Human()\n        self.car = Car()\n\n    def test_dog_shall_bark(self):\n        noise = self.dog.bark()\n        expected_noise = \"woof!\"\n        self.assertEqual(noise, expected_noise)\n\n    def test_cat_shall_meow(self):\n        noise = self.cat.meow()\n        expected_noise = \"meow!\"\n        self.assertEqual(noise, expected_noise)\n\n    def test_human_shall_speak(self):\n        noise = self.human.speak()\n        expected_noise = \"hello\"\n        self.assertEqual(noise, expected_noise)\n\n    def test_car_shall_make_loud_noise(self):\n        noise = self.car.make_noise(1)\n        expected_noise = \"vroom!\"\n        self.assertEqual(noise, expected_noise)\n\n    def test_car_shall_make_very_loud_noise(self):\n        noise = self.car.make_noise(10)\n        expected_noise = \"vroom!!!!!!!!!!\"\n        self.assertEqual(noise, expected_noise)\n\n\nclass AdapterTest(unittest.TestCase):\n    def test_dog_adapter_shall_make_noise(self):\n        dog = Dog()\n        dog_adapter = Adapter(dog, make_noise=dog.bark)\n        noise = dog_adapter.make_noise()\n        expected_noise = \"woof!\"\n        self.assertEqual(noise, expected_noise)\n\n    def test_cat_adapter_shall_make_noise(self):\n        cat = Cat()\n        cat_adapter = Adapter(cat, make_noise=cat.meow)\n        noise = cat_adapter.make_noise()\n        expected_noise = \"meow!\"\n        self.assertEqual(noise, expected_noise)\n\n    def test_human_adapter_shall_make_noise(self):\n        human = Human()\n        human_adapter = Adapter(human, make_noise=human.speak)\n        noise = human_adapter.make_noise()\n        expected_noise = \"hello\"\n        self.assertEqual(noise, expected_noise)\n\n    def test_car_adapter_shall_make_loud_noise(self):\n        car = Car()\n        car_adapter = Adapter(car, make_noise=car.make_noise)\n        noise = car_adapter.make_noise(1)\n        expected_noise = \"vroom!\"\n        self.assertEqual(noise, expected_noise)\n\n    def test_car_adapter_shall_make_very_loud_noise(self):\n        car = Car()\n        car_adapter = Adapter(car, make_noise=car.make_noise)\n        noise = car_adapter.make_noise(10)\n        expected_noise = \"vroom!!!!!!!!!!\"\n\n        self.assertEqual(noise, expected_noise)\n"}
{"type": "test_file", "path": "src/exercises/advanced/pytest_with_server_setup_teardown/test_access_server.py", "content": "import time\nimport subprocess\n\n# pylint: disable=relative-beyond-top-level\nfrom our_code import our_function_to_test  # type: ignore\n\n\nclass TestSomething:\n\n    @classmethod\n    def setup_class(cls):\n        # setup - bring the server up\n        # pylint: disable=consider-using-with\n        cls.proc = subprocess.Popen([\"python\", \"server.py\"])\n        # give the process 2 seconds to set up\n        time.sleep(2)\n\n    @classmethod\n    def teardown_class(cls):\n        cls.proc.kill()\n\n    def test_server(self):\n        our_function_to_test()\n"}
{"type": "test_file", "path": "tests/behavioral/test_strategy.py", "content": "import pytest\n\nfrom patterns.behavioral.strategy import Order, ten_percent_discount, on_sale_discount\n\n\n@pytest.fixture\ndef order():\n    return Order(100)\n\n\n@pytest.mark.parametrize(\n    \"func, discount\", [(ten_percent_discount, 10.0), (on_sale_discount, 45.0)]\n)\ndef test_discount_function_return(func, order, discount):\n    assert func(order) == discount\n\n\n@pytest.mark.parametrize(\n    \"func, price\", [(ten_percent_discount, 100), (on_sale_discount, 100)]\n)\ndef test_order_discount_strategy_validate_success(func, price):\n    order = Order(price, func)\n\n    assert order.price == price\n    assert order.discount_strategy == func\n\n\ndef test_order_discount_strategy_validate_error():\n    order = Order(10, discount_strategy=on_sale_discount)\n\n    assert order.discount_strategy is None\n\n\n@pytest.mark.parametrize(\n    \"func, price, discount\",\n    [(ten_percent_discount, 100, 90.0), (on_sale_discount, 100, 55.0)],\n)\ndef test_discount_apply_success(func, price, discount):\n    order = Order(price, func)\n\n    assert order.apply_discount() == discount\n"}
{"type": "test_file", "path": "tests/creational/test_abstract_factory.py", "content": "import unittest\nfrom unittest.mock import patch\n\nfrom patterns.creational.abstract_factory import Dog, PetShop\n\n\nclass TestPetShop(unittest.TestCase):\n    def test_dog_pet_shop_shall_show_dog_instance(self):\n        dog_pet_shop = PetShop(Dog)\n        with patch.object(Dog, \"speak\") as mock_Dog_speak:\n            pet = dog_pet_shop.buy_pet(\"\")\n            pet.speak()\n            self.assertEqual(mock_Dog_speak.call_count, 1)\n"}
{"type": "test_file", "path": "src/examples/short/modules/enum/test_membership.py", "content": "\"\"\"\nThis is an example of how to test if something is a member if this enum\n\"\"\"\n\nimport enum\n\n\nclass Event(enum.Enum):\n    node_pre_add = 1\n    node_post_add = 2\n    node_pre_del = 3\n    node_post_del = 4\n    edge_pre_add = 5\n    edge_post_add = 6\n    edge_pre_del = 7\n    edge_post_del = 8\n    node_pre_build = 9\n    node_post_build = 10\n\n\ndef is_enum(member):\n    if isinstance(member, Event):\n        print(\"yes\")\n    else:\n        print(\"no\")\n\n\n# passing numbers is no good, we need to pass the real values\nis_enum(7)\nis_enum(Event.edge_pre_del)\n"}
{"type": "test_file", "path": "src/examples/long/pytest/tests/test_hello.py", "content": "import tests.mod  # type: ignore\n\n\ndef test_hello():\n    tests.mod.shared_method()\n"}
{"type": "test_file", "path": "tests/structural/test_bridge.py", "content": "import unittest\nfrom unittest.mock import patch\n\nfrom patterns.structural.bridge import CircleShape, DrawingAPI1, DrawingAPI2\n\n\nclass BridgeTest(unittest.TestCase):\n    def test_bridge_shall_draw_with_concrete_api_implementation(cls):\n        ci1 = DrawingAPI1()\n        ci2 = DrawingAPI2()\n        with patch.object(ci1, \"draw_circle\") as mock_ci1_draw_circle, patch.object(\n            ci2, \"draw_circle\"\n        ) as mock_ci2_draw_circle:\n            sh1 = CircleShape(1, 2, 3, ci1)\n            sh1.draw()\n            cls.assertEqual(mock_ci1_draw_circle.call_count, 1)\n            sh2 = CircleShape(1, 2, 3, ci2)\n            sh2.draw()\n            cls.assertEqual(mock_ci2_draw_circle.call_count, 1)\n\n    def test_bridge_shall_scale_both_api_circles_with_own_implementation(cls):\n        SCALE_FACTOR = 2\n        CIRCLE1_RADIUS = 3\n        EXPECTED_CIRCLE1_RADIUS = 6\n        CIRCLE2_RADIUS = CIRCLE1_RADIUS * CIRCLE1_RADIUS\n        EXPECTED_CIRCLE2_RADIUS = CIRCLE2_RADIUS * SCALE_FACTOR\n\n        ci1 = DrawingAPI1()\n        ci2 = DrawingAPI2()\n        sh1 = CircleShape(1, 2, CIRCLE1_RADIUS, ci1)\n        sh2 = CircleShape(1, 2, CIRCLE2_RADIUS, ci2)\n        sh1.scale(SCALE_FACTOR)\n        sh2.scale(SCALE_FACTOR)\n        cls.assertEqual(sh1._radius, EXPECTED_CIRCLE1_RADIUS)\n        cls.assertEqual(sh2._radius, EXPECTED_CIRCLE2_RADIUS)\n        with patch.object(sh1, \"scale\") as mock_sh1_scale_circle, patch.object(\n            sh2, \"scale\"\n        ) as mock_sh2_scale_circle:\n            sh1.scale(2)\n            sh2.scale(2)\n            cls.assertEqual(mock_sh1_scale_circle.call_count, 1)\n            cls.assertEqual(mock_sh2_scale_circle.call_count, 1)\n"}
{"type": "test_file", "path": "tests/behavioral/test_observer.py", "content": "from unittest.mock import Mock, patch\n\nimport pytest\n\nfrom patterns.behavioral.observer import Data, DecimalViewer, HexViewer\n\n\n@pytest.fixture\ndef observable():\n    return Data(\"some data\")\n\n\ndef test_attach_detach(observable):\n    decimal_viewer = DecimalViewer()\n    assert len(observable._observers) == 0\n\n    observable.attach(decimal_viewer)\n    assert decimal_viewer in observable._observers\n\n    observable.detach(decimal_viewer)\n    assert decimal_viewer not in observable._observers\n\n\ndef test_one_data_change_notifies_each_observer_once(observable):\n    observable.attach(DecimalViewer())\n    observable.attach(HexViewer())\n\n    with patch(\n        \"patterns.behavioral.observer.DecimalViewer.update\", new_callable=Mock()\n    ) as mocked_update:\n        assert mocked_update.call_count == 0\n        observable.data = 10\n        assert mocked_update.call_count == 1\n"}
{"type": "test_file", "path": "src/examples/long/pytest/tests/test_batch1.py", "content": "import tests.mod  # type: ignore\n\n\ndef test_batch1_test1():\n    tests.mod.shared_method()\n\n\ndef test_batch1_test2():\n    tests.mod.shared_method()\n"}
{"type": "test_file", "path": "tests/creational/test_borg.py", "content": "import unittest\n\nfrom patterns.creational.borg import Borg, YourBorg\n\n\nclass BorgTest(unittest.TestCase):\n    def setUp(self):\n        self.b1 = Borg()\n        self.b2 = Borg()\n        # creating YourBorg instance implicitly sets the state attribute\n        # for all borg instances.\n        self.ib1 = YourBorg()\n\n    def tearDown(self):\n        self.ib1.state = \"Init\"\n\n    def test_initial_borg_state_shall_be_init(self):\n        b = Borg()\n        self.assertEqual(b.state, \"Init\")\n\n    def test_changing_instance_attribute_shall_change_borg_state(self):\n        self.b1.state = \"Running\"\n        self.assertEqual(self.b1.state, \"Running\")\n        self.assertEqual(self.b2.state, \"Running\")\n        self.assertEqual(self.ib1.state, \"Running\")\n\n    def test_instances_shall_have_own_ids(self):\n        self.assertNotEqual(id(self.b1), id(self.b2), id(self.ib1))\n"}
{"type": "test_file", "path": "tests/creational/test_builder.py", "content": "import unittest\n\nfrom patterns.creational.builder import ComplexHouse, Flat, House, construct_building\n\n\nclass TestSimple(unittest.TestCase):\n    def test_house(self):\n        house = House()\n        self.assertEqual(house.size, \"Big\")\n        self.assertEqual(house.floor, \"One\")\n\n    def test_flat(self):\n        flat = Flat()\n        self.assertEqual(flat.size, \"Small\")\n        self.assertEqual(flat.floor, \"More than One\")\n\n\nclass TestComplex(unittest.TestCase):\n    def test_house(self):\n        house = construct_building(ComplexHouse)\n        self.assertEqual(house.size, \"Big and fancy\")\n        self.assertEqual(house.floor, \"One\")\n"}
{"type": "test_file", "path": "tests/behavioral/test_publish_subscribe.py", "content": "import unittest\nfrom unittest.mock import call, patch\n\nfrom patterns.behavioral.publish_subscribe import Provider, Publisher, Subscriber\n\n\nclass TestProvider(unittest.TestCase):\n    \"\"\"\n    Integration tests ~ provider class with as little mocking as possible.\n    \"\"\"\n\n    def test_subscriber_shall_be_attachable_to_subscriptions(cls):\n        subscription = \"sub msg\"\n        pro = Provider()\n        cls.assertEqual(len(pro.subscribers), 0)\n        sub = Subscriber(\"sub name\", pro)\n        sub.subscribe(subscription)\n        cls.assertEqual(len(pro.subscribers[subscription]), 1)\n\n    def test_subscriber_shall_be_detachable_from_subscriptions(cls):\n        subscription = \"sub msg\"\n        pro = Provider()\n        sub = Subscriber(\"sub name\", pro)\n        sub.subscribe(subscription)\n        cls.assertEqual(len(pro.subscribers[subscription]), 1)\n        sub.unsubscribe(subscription)\n        cls.assertEqual(len(pro.subscribers[subscription]), 0)\n\n    def test_publisher_shall_append_subscription_message_to_queue(cls):\n        \"\"\"msg_queue ~ Provider.notify(msg) ~ Publisher.publish(msg)\"\"\"\n        expected_msg = \"expected msg\"\n        pro = Provider()\n        pub = Publisher(pro)\n        Subscriber(\"sub name\", pro)\n        cls.assertEqual(len(pro.msg_queue), 0)\n        pub.publish(expected_msg)\n        cls.assertEqual(len(pro.msg_queue), 1)\n        cls.assertEqual(pro.msg_queue[0], expected_msg)\n\n    def test_provider_shall_update_affected_subscribers_with_published_subscription(\n        cls,\n    ):\n        pro = Provider()\n        pub = Publisher(pro)\n        sub1 = Subscriber(\"sub 1 name\", pro)\n        sub1.subscribe(\"sub 1 msg 1\")\n        sub1.subscribe(\"sub 1 msg 2\")\n        sub2 = Subscriber(\"sub 2 name\", pro)\n        sub2.subscribe(\"sub 2 msg 1\")\n        sub2.subscribe(\"sub 2 msg 2\")\n        with patch.object(sub1, \"run\") as mock_subscriber1_run, patch.object(\n            sub2, \"run\"\n        ) as mock_subscriber2_run:\n            pro.update()\n            cls.assertEqual(mock_subscriber1_run.call_count, 0)\n            cls.assertEqual(mock_subscriber2_run.call_count, 0)\n        pub.publish(\"sub 1 msg 1\")\n        pub.publish(\"sub 1 msg 2\")\n        pub.publish(\"sub 2 msg 1\")\n        pub.publish(\"sub 2 msg 2\")\n        with patch.object(sub1, \"run\") as mock_subscriber1_run, patch.object(\n            sub2, \"run\"\n        ) as mock_subscriber2_run:\n            pro.update()\n            expected_sub1_calls = [call(\"sub 1 msg 1\"), call(\"sub 1 msg 2\")]\n            mock_subscriber1_run.assert_has_calls(expected_sub1_calls)\n            expected_sub2_calls = [call(\"sub 2 msg 1\"), call(\"sub 2 msg 2\")]\n            mock_subscriber2_run.assert_has_calls(expected_sub2_calls)\n"}
{"type": "test_file", "path": "tests/structural/test_proxy.py", "content": "import sys\nimport unittest\nfrom io import StringIO\n\nfrom patterns.structural.proxy import Proxy, client\n\n\nclass ProxyTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Class scope setup.\"\"\"\n        cls.proxy = Proxy()\n\n    def setUp(cls):\n        \"\"\"Function/test case scope setup.\"\"\"\n        cls.output = StringIO()\n        cls.saved_stdout = sys.stdout\n        sys.stdout = cls.output\n\n    def tearDown(cls):\n        \"\"\"Function/test case scope teardown.\"\"\"\n        cls.output.close()\n        sys.stdout = cls.saved_stdout\n\n    def test_do_the_job_for_admin_shall_pass(self):\n        client(self.proxy, \"admin\")\n        assert self.output.getvalue() == (\n            \"[log] Doing the job for admin is requested.\\n\"\n            \"I am doing the job for admin\\n\"\n        )\n\n    def test_do_the_job_for_anonymous_shall_reject(self):\n        client(self.proxy, \"anonymous\")\n        assert self.output.getvalue() == (\n            \"[log] Doing the job for anonymous is requested.\\n\"\n            \"[log] I can do the job just for `admins`.\\n\"\n        )\n"}
{"type": "test_file", "path": "tests/structural/test_decorator.py", "content": "import unittest\n\nfrom patterns.structural.decorator import BoldWrapper, ItalicWrapper, TextTag\n\n\nclass TestTextWrapping(unittest.TestCase):\n    def setUp(self):\n        self.raw_string = TextTag(\"raw but not cruel\")\n\n    def test_italic(self):\n        self.assertEqual(\n            ItalicWrapper(self.raw_string).render(), \"<i>raw but not cruel</i>\"\n        )\n\n    def test_bold(self):\n        self.assertEqual(\n            BoldWrapper(self.raw_string).render(), \"<b>raw but not cruel</b>\"\n        )\n\n    def test_mixed_bold_and_italic(self):\n        self.assertEqual(\n            BoldWrapper(ItalicWrapper(self.raw_string)).render(),\n            \"<b><i>raw but not cruel</i></b>\",\n        )\n"}
{"type": "test_file", "path": "tests/creational/test_lazy.py", "content": "import unittest\n\nfrom patterns.creational.lazy_evaluation import Person\n\n\nclass TestDynamicExpanding(unittest.TestCase):\n    def setUp(self):\n        self.John = Person(\"John\", \"Coder\")\n\n    def test_innate_properties(self):\n        self.assertDictEqual(\n            {\"name\": \"John\", \"occupation\": \"Coder\", \"call_count2\": 0},\n            self.John.__dict__,\n        )\n\n    def test_relatives_not_in_properties(self):\n        self.assertNotIn(\"relatives\", self.John.__dict__)\n\n    def test_extended_properties(self):\n        print(f\"Johns relatives: {self.John.relatives}\")\n        self.assertDictEqual(\n            {\n                \"name\": \"John\",\n                \"occupation\": \"Coder\",\n                \"relatives\": \"Many relatives.\",\n                \"call_count2\": 0,\n            },\n            self.John.__dict__,\n        )\n\n    def test_relatives_after_access(self):\n        print(f\"Johns relatives: {self.John.relatives}\")\n        self.assertIn(\"relatives\", self.John.__dict__)\n\n    def test_parents(self):\n        for _ in range(2):\n            self.assertEqual(self.John.parents, \"Father and mother\")\n        self.assertEqual(self.John.call_count2, 1)\n"}
{"type": "test_file", "path": "src/examples/long/pytest/tests/mod.py", "content": "def shared_method():\n    pass\n"}
{"type": "test_file", "path": "src/examples/long/pytest/tests/test_batch2.py", "content": "import tests.mod  # type: ignore\n\n\ndef test_batch2_test1():\n    tests.mod.shared_method()\n\n\ndef test_batch2_test2():\n    tests.mod.shared_method()\n"}
{"type": "source_file", "path": "src/examples/long/debugging_winpdb/debug_me.py", "content": "def simple_func(x):\n    x += 1\n\n    # s = range(20)\n    # z = None\n    # w = ()\n\n    # y = dict((i, i ** 2) for i in s)\n\n    # k = set(range(5, 99))\n\n    try:\n        x.invalid\n    except AttributeError:\n        pass\n\n    # import sys\n    # sys.exit(1)\n\n    return 2 * x\n\n\ndef fermat(n):\n    \"\"\"Returns triplets of the form x^n+y^n=z^n.\n    Warning! Untested with n>2.\n    \"\"\"\n    for x in range(100):\n        for y in range(1, x + 1):\n            for z in range(1, x ** n + y ** n + 1):\n                # from pudb import set_trace; set_trace()\n                if x ** n + y ** n == z ** n:\n                    yield x, y, z\n\n\ndef main():\n    # noinspection PyTypeChecker\n    print(\"SF\", simple_func(10))\n\n    for i in fermat(2):\n        print(i)\n\n    print(\"FINISHED\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "src/examples/long/debugging_pudb/debug_me.py", "content": "def simple_func(x):\n    x += 1\n\n    # s = range(20)\n    # z = None\n    # w = ()\n\n    # y = dict((i, i ** 2) for i in s)\n\n    # k = set(range(5, 99))\n\n    try:\n        x.invalid\n    except AttributeError:\n        pass\n\n    # import sys\n    # sys.exit(1)\n\n    return 2 * x\n\n\ndef fermat(n):\n    \"\"\"\n    Returns triplets of the form x^n+y^n=z^n.\n    Warning! Untested with n>2.\n    \"\"\"\n    for x in range(100):\n        for y in range(1, x + 1):\n            for z in range(1, x ** n + y ** n + 1):\n                # from pudb import set_trace; set_trace()\n                if x ** n + y ** n == z ** n:\n                    yield x, y, z\n\n\n# noinspection PyTypeChecker\nprint(\"SF\", simple_func(10))\n\nfor j in fermat(2):\n    print(j)\n\nprint(\"FINISHED\")\n"}
{"type": "source_file", "path": "src/examples/long/capture_all_process_outputs/capture_tty_highlevel.py", "content": "\"\"\"\nThis example captures all output of a process: stdout, stderr and tty.\n\nReferences:\nhttp://stackoverflow.com/questions/11495783/redirect-subprocess-stderr-to-stdout\n\"\"\"\n\nimport os\nimport pty\nimport sys\n\nif len(sys.argv) < 2:\n    print(f\"{sys.argv[0]}: must supply process to run and arguments for it\", file=sys.stderr)\n    print(f\"{sys.argv[0]}: use it like this:\", file=sys.stderr)\n    print(f\"{sys.argv[0]}: {sys.argv[0]} ./write_to_any.py stdout stderr tty\", file=sys.stderr)\n    sys.exit(1)\n\npid, fd = pty.fork()\nif pid == 0:\n    os.execv(sys.argv[1], sys.argv[1:])\n    print(\"execv didnt work\", file=sys.stderr)\nelse:\n    # At the end of the loop we get an exception when the connection with the other side terminates.\n    # This is kinda ugly since strictly speaking this is not an error, but oh well.\n    try:\n        for line in os.fdopen(fd):\n            print(f\"got line [{line}]\")\n    except OSError:\n        pass\n    pid, ret = os.wait()\n    if os.WIFEXITED(ret):\n        print(f\"proc exited and status was [{os.WEXITSTATUS(ret)}]\")\n    if os.WIFSTOPPED(ret):\n        print(f\"proc stopped and stopsig was [{os.WSTOPSIG(ret)}]\")\n    if os.WIFSIGNALED(ret):\n        print(f\"proc signaled and signal was [{os.WTERMSIG(ret)}]\")\n"}
{"type": "source_file", "path": "src/examples/long/extending_python_with_c/setup_atoi.py", "content": "\"\"\"\nsetup.py file for SWIG atoi\n\"\"\"\n\nfrom setuptools import setup, Extension\n\natoi_module = Extension(\n    \"_atoi\",\n    sources=[\"atoi_wrap.c\"],\n)\n\nsetup(\n    name=\"atoi\",\n    version=\"0.1\",\n    author=\"SWIG Docs\",\n    description=\"\"\"Simple swig atoi from docs\"\"\",\n    ext_modules=[atoi_module],\n    py_modules=[\"atoi\"],\n)\n"}
{"type": "source_file", "path": "config/__init__.py", "content": "\"\"\"\nthis file is needed to make the `config` folder a valid python package\nwhich is needed by some tools, notably mypy\n\"\"\"\n"}
{"type": "source_file", "path": "src/examples/long/lambda_context/not_passing_lint.py", "content": "\"\"\"\nThis is an example of why context in lamba matters\n\nIn this example we have a list of companies.\nEach company is a dict of employees and their salaries.\nWe would like to find the employee which has the maximal salary\nin each company using the \"max\" function.\n\nLook at the two examples below which look very similar and try\nto explain why the first command doesnt pass lint and the second\ndoes.\n\nRun lint with:\n    $ pylint -s n -r n exapmle.py\n\nReferences:\n- https://stackoverflow.com/questions/25314547/cell-var-from-loop-warning-from-pylint\n\"\"\"\n\n\nmy_list = [\n    # first company\n    {\n        \"mark\": 1000,\n        \"doron\": 2000,\n    },\n    # second company\n    {\n        \"yuval\": 3000,\n        \"avi\": 4000,\n    },\n]\n\n# this exapmle does not pass lint\nfor c in my_list:\n    # pylint: disable=cell-var-from-loop\n    max_person = max(c.keys(), key=lambda x: c[x])\n    print(f\"{max_person}\")\n# this exapmle does pass lint\nfor c in my_list:\n    max_person = max(c.keys(), key=lambda x, d=c: d[x])  # type: ignore\n    print(f\"{max_person}\")\n"}
{"type": "source_file", "path": "src/examples/long/logging_correct/correct.py", "content": "import logging\n\n\ndef demo():\n    logger = logging.getLogger(__name__)\n    logger.info(\"in demo\")\n"}
{"type": "source_file", "path": "src/examples/long/capture_all_process_outputs/capture_out_using_subprocess.py", "content": "\"\"\"\nThis example only captures stdout\n\nReferences:\nhttp://stackoverflow.com/questions/11495783/redirect-subprocess-stderr-to-stdout\n\"\"\"\n\nimport subprocess\nimport sys\n\nif len(sys.argv) < 2:\n    print(\"must supply process to run and arguments for it\", file=sys.stderr)\n    sys.exit(1)\n\nwith subprocess.Popen(sys.argv[1:], stdout=subprocess.PIPE, shell=False) as pr:\n    assert pr.stdout is not None\n    for line_b in pr.stdout:\n        line = line_b.decode()\n        print(f\"got line [{line.rstrip()}]\")\n"}
{"type": "source_file", "path": "src/examples/long/bad_lib/module_checker.py", "content": "\"\"\"\nThis is a module that checks if a library given to it is loadable\n(has no undefined references)\n\"\"\"\n\n\nimport ctypes\n\n\ndef check_lib(name):\n    x = ctypes.cdll.LoadLibrary(name)\n    # noinspection PyProtectedMember\n    # pylint: disable=protected-access\n    libdl.dlclose(x._handle)\n\n\ndef load_lib(name):\n    return ctypes.cdll.LoadLibrary(name)\n\n\nlib_name = \"libdl.so\"\nlibdl = ctypes.CDLL(lib_name)\nlib = load_lib(lib_name)\n"}
{"type": "source_file", "path": "src/examples/long/capture_all_process_outputs/write_to_any.py", "content": "\"\"\"\nThis is a simple process that can output to any of three destinations:\n- stdout\n- stderr\n- tty\n\nThe idea is for this program to be a test of how we can capture this output.\n\nExamples:\n[process] stdout\nwill log to stdout\n[process] stderr\nwill log to stderr\n[process] tty\nwill log to tty\n\nand you can combine...\n\"\"\"\n\nimport sys\nimport time\n\nargs = sys.argv[1:]\nif \"stdout\" in args:\n    print(\"this is stdout\")\n    for i in [\"this \", \"is \", \"stdout\\n\"]:\n        print(i, end=\"\")\n        sys.stdout.flush()\n        time.sleep(1)\n\nif \"stderr\" in args:\n    print(\"this is stderr\", file=sys.stderr)\n    for i in [\"this \", \"is \", \"stderr\\n\"]:\n        print(i, end=\"\", file=sys.stderr)\n        sys.stderr.flush()\n        time.sleep(1)\n\nif \"tty\" in args:\n    with open(\"/dev/tty\", \"w\") as f:\n        f.write(\"this is /dev/tty\\n\")\n        for i in [\"this \", \"is \", \"/dev/tty\\n\"]:\n            print(i, end=\"\", file=f)\n            f.flush()\n            time.sleep(1)\n\nsys.exit(7)\n"}
{"type": "source_file", "path": "not_mine/mandelbrot.py", "content": "_                                      =   (\n                                        255,\n                                      lambda\n                               V       ,B,c\n                             :c   and Y(V*V+B,B,  c\n                               -1)if(abs(V)<6)else\n               (              2+c-4*abs(V)**-0.4)/i\n                 )  ;v,      x=1500,1000;C=range(v*x\n                  );import  struct;P=struct.pack;M,\\\n            j  ='<QIIHHHH',open('M.bmp','wb').write\nfor X in j('BM'+P(M,v*x*3+26,26,12,v,x,1,24))or C:\n            i  ,Y=_;j(P('BBB',*(lambda T:(T*80+T**9\n                  *i-950*T  **99,T*70-880*T**18+701*\n                 T  **9     ,T*i**(1-T**45*2)))(sum(\n               [              Y(0,(A%3/3.+X%v+(X/v+\n                               A/3/3.-x/2)/1j)*2.5\n                             /x   -2.7,i)**2 for  \\\n                               A       in C\n                                      [:9]])\n                                        /9)\n                                       )   )\n"}
{"type": "source_file", "path": "src/examples/long/lambda_context/using_lamba_after_loop_is_done.py", "content": "\"\"\"\nThis example shows why you should be careful with lambda contexts.\n\nLets explain when this happens:\n- you define a lambda inside a loop\n- the lambda references the loop variable or anything which is calculatd in\n    loop and changes from iteration to iteration.\n- you store the lambda reference so that it can be used after the loop is over.\n- you use the lambda after the loop is over.\n\nWhy does the problem occur?\n- Because the lambda definition DOES NOT make a copy of every variable used in it\nand stores it with the reference.\n- Actually, only one lambda is created\n- So which value does it use when called?\n    Which ever value the variable has AT THE TIME THAT IT IS CALLED.\n    Inside the loop its ok since the variable has the current value.\n    Outside the loop this causes problems since it will refer to the last value\n    of the variable\n\nWhat does not solve this?\n- turning the lambda to a function does not work.\n- using partial but without arguments.\n\nWhat does solve this?\n- using a default value which is different every time. This is because\n    values for parameters with defaults ARE stored with the function reference.\n- using a function creator\n- using partial.\n\nReferences:\n- https://github.com/PyCQA/pylint/issues/3107\n\"\"\"\n\nfrom functools import partial\n\n\ndef basic():\n    \"\"\" This is the basic example. What does this produce? \"\"\"\n    handlers = []\n    for i in range(10):\n        # pylint: disable=cell-var-from-loop\n        handlers.append(lambda: i)\n    print([h() for h in handlers])\n\n\ndef wrong():\n    \"\"\" This does not work since there will be only one f \"\"\"\n    handlers = []\n    for i in range(10):\n        def f():\n            # pylint: disable=cell-var-from-loop\n            return i\n        handlers.append(f)\n    print([h() for h in handlers])\n\n\ndef correction():\n    \"\"\" This works because each f will be stored with its own default value for \"val\". \"\"\"\n    handlers = []\n    for i in range(10):\n        def f(val=i):\n            return val\n        handlers.append(f)\n    print([h() for h in handlers])\n\n\ndef creator_pattern():\n    \"\"\" This is called a function creator pattern, it uses the closure of the function to store i. \"\"\"\n    def create_f(i):\n        def f():\n            return i\n        return f\n    handlers = []\n    for i in range(10):\n        handlers.append(create_f(i))\n    print([h() for h in handlers])\n\n\ndef partial_pattern_wrong():\n    \"\"\" This is using the partial python standard function, but without arguments it does not work \"\"\"\n    handlers = []\n    for i in range(10):\n        # pylint: disable=cell-var-from-loop,unnecessary-lambda-assignment\n        f = lambda: i  # noqa: E731\n        good_f = partial(f)\n        handlers.append(good_f)\n    print([h() for h in handlers])\n\n\ndef partial_pattern():\n    \"\"\" This is using the partial python standard function \"\"\"\n    handlers = []\n    for i in range(10):\n        # pylint: disable=unnecessary-lambda-assignment\n        f = lambda i: i  # noqa: E731\n        good_f = partial(f, i)\n        handlers.append(good_f)\n    print([h() for h in handlers])\n\n\nbasic()\nwrong()\ncorrection()\ncreator_pattern()\npartial_pattern_wrong()\npartial_pattern()\n"}
{"type": "source_file", "path": "src/examples/long/capture_all_process_outputs/capture_out_err_using_subprocess.py", "content": "\"\"\"\nThis is a program showing how to redirect both stdout and stderr for a subprocess\nNotice that we get both stdout and stderr data through the same pipe.\n\nReferences:\nhttp://stackoverflow.com/questions/11495783/redirect-subprocess-stderr-to-stdout\n\"\"\"\n\nimport subprocess\nimport sys\n\nif len(sys.argv) < 2:\n    print(\"must supply process to run and arguments for it\", file=sys.stderr)\n    sys.exit(1)\n\nwith subprocess.Popen(\n    sys.argv[1:],\n    stdout=subprocess.PIPE,\n    stderr=subprocess.STDOUT,\n    shell=False\n) as pr:\n    assert pr.stdout is not None\n    for line_b in pr.stdout:\n        line = line_b.decode()\n        print(f\"got line [{line.rstrip()}]\")\n"}
{"type": "source_file", "path": "src/examples/long/importlib/my_module/a.py", "content": "from . import b\n\nprint(f\"b.number is {b.number}\")\nprint(\"this is a4\")\n"}
{"type": "source_file", "path": "src/examples/long/flask_static/app.py", "content": "#!/usr/bin/env python3\n\n\"\"\"\nA simple web server\n\"\"\"\n\n\nimport flask\n\n\napp = flask.Flask(\"app\")\napp.config[\"DEBUG\"] = True\n# static_folder = app.config[\"STATIC_FOLDER\"]\nprint(f\"{app.static_folder=}\")\n\n\n@app.route(\"/\")\ndef index():\n    return app.send_static_file(\"index.html\")\n\n\nif __name__ == \"__main__\":\n    app.run(port=8080, host=\"0.0.0.0\")\n"}
{"type": "source_file", "path": "scripts/syntax_check.py", "content": "#!/usr/bin/env python\n\n\"\"\"\nThis script checks the syntax of other python scripts.\nIt returns a bad error code to the parent if something goes wrong.\n\nIts basically a more sophisticated version of something like this:\n    python2 -m py_compile $< || python3 -m py_compile $<\n\"\"\"\n\nimport sys\nimport subprocess\n\n\ndef check_file(filename: str):\n    # read the first line of the file\n    check_with = None\n    with open(filename) as f:\n        for line in f:\n            line = line.rstrip()\n            if line == \"#!/usr/bin/python2\":\n                check_with = \"python2\"\n                break\n            if line == \"#!/usr/bin/python3\":\n                check_with = \"python3\"\n                break\n            if line.startswith(\"# CHECK_WITH\"):\n                check_with = line.split()[2]\n                break\n    # check with python3 if in doubt\n    if check_with is None:\n        check_with = \"python3\"\n\n    if check_with is None:\n        print(f\"{sys.argv[0]}: could not find how to check file [{filename}]\", file=sys.stderr)\n        sys.exit(1)\n\n    # check the syntax\n    out = subprocess.check_output([\n        check_with,\n        \"-m\",\n        \"py_compile\",\n        filename,\n    ]).decode()\n    # check that there is no output\n    if out != \"\":\n        print(f\"out is [{out}]\")\n        sys.exit(1)\n\n\ndef main():\n    if len(sys.argv) < 2:\n        print(f\"usage: {sys.argv[0]} [filenames...]\", file=sys.stderr)\n        sys.exit(1)\n    for filename in sys.argv[1:]:\n        check_file(filename)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "src/examples/long/loading_twice_into_the_same_namespace/folder1/module.py", "content": "name = __name__\nin_both = \"value in folder1/module.py\"\n"}
{"type": "source_file", "path": "config/version.py", "content": "tup = (0, 0, 3)\n"}
{"type": "source_file", "path": "src/examples/long/dispy/hello_dispy.py", "content": "\"\"\"\nThis is an example of how to use the \"dispy\" distribution\ncluster\n\"\"\"\n\n\nimport time\nimport socket\nimport random\nimport dispy\n\n\ndef compute(n):\n    \"\"\" \"compute\" is distributed to each node running \"dispynode\" \"\"\"\n    time.sleep(n)\n    host = socket.gethostname()\n    return host, n\n\n\ndef main():\n    cluster = dispy.JobCluster(compute)\n    jobs = []\n    for i in range(10):\n        # schedule execution of \"compute\" on a node (running \"dispynode\")\n        # with a parameter (random number in this case)\n        job = cluster.submit(random.randint(5, 20))\n        job.id = i  # optionally associate an ID to job (if needed later)\n        jobs.append(job)\n    # cluster.wait() # waits for all scheduled jobs to finish\n    for job in jobs:\n        host, n = job()  # waits for job to finish and returns results\n        print(f\"{host} executed job {job.id} at {job.start_time} with {n}\")\n        # other fields of \"job\" that may be useful:\n        # print(job.stdout, job.stderr, job.exception, job.ip_addr, job.start_time, job.end_time)\n    cluster.print_status()\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "config/deps.py", "content": "packages = [\n    # dbus\n    \"libdbus-glib-1-dev\",\n    \"libdbus-1-dev\",\n    # glib\n    \"libglib2.0-dev\",\n    # gtk\n    \"libgirepository1.0-dev\",\n    \"gcc\",\n    \"libcairo2-dev\",\n    \"libasound2-dev\",\n    \"pkg-config\",\n    \"python3-dev\",\n    \"gir1.2-gtk-3.0\",\n    # for pyscopg2 (postgres interface)\n    \"postgresql-common\",\n    \"libpq-dev\",\n    \"python3-gi\",\n    \"libcairo2-dev\",\n    # python\n    \"python3-distutils-extra\",\n    \"python3-pip\",\n    # swig\n    \"swig\",\n    \"swig-doc\",\n    \"fluidsynth\",\n    # systemd\n    \"libsystemd0\",\n    # TODO: cannot install this at this moment because of a problem in ubuntu repos\n    # \"libsystemd-dev\",\n    # for checking spelling\n    \"aspell\",\n    # ruby stuff\n    \"ruby-bundler\",\n    \"rbenv\",\n]\n\ndev_packages = [\n\t\"libpq-dev\",\n\t\"libcairo2-dev\",\n]\n"}
{"type": "source_file", "path": "config/python.py", "content": "from typing import List\n\n\nconfig_requires: List[str] = []\ndev_requires: List[str] = [\n    \"black\",\n]\ninstall_requires: List[str] = [\n    \"pydantic\",\n    # command line parsing\n    \"click\",\n    \"cmd2\",\n    # web\n    \"furl\",\n    \"requests\",\n    \"beautifulsoup4\",\n    \"types-beautifulsoup4\",\n    \"html5lib\",\n    \"lxml\",\n    # progress and tui\n    \"tqdm\",\n    \"types-tqdm\",\n    \"pythondialog\",\n    # systems programming\n    \"psutil\",\n    \"types-psutil\",\n    # problems intalling the next module on github systems\n    # \"systemd-python\",\n    \"PyGObject\",\n    \"PyGObject-stubs\",\n    \"dbus-python\",\n    # cache and database\n    \"lmdb\",\n    \"cachetools\",\n    # databases\n    \"pymysql\",\n    \"mysql.connector\",\n    \"sqlalchemy\",\n    \"psycopg2\",\n    \"types-psycopg2\",\n    # data languages\n    \"jsonschema\",\n    \"types-jsonschema\",\n    \"jsonpickle\",\n    # GUI\n    \"PyQt5\",\n    \"PyQt5-stubs\",\n    # selenium stuff\n    \"webdriver-manager\",\n    \"selenium\",\n    \"selenium-wire\",\n    # music\n    \"music\",\n    \"mingus\",\n    \"pyFluidSynth\",\n    # GUI\n    \"PyQt5\",\n    \"PyQt5-stubs\",\n    # selenium stuff\n    \"webdriver-manager\",\n    \"selenium\",\n    \"selenium-wire\",\n    # music\n    \"music\",\n    \"mingus\",\n    \"simpleaudio\",\n    \"pygame\",\n    # terminal color stuff\n    \"termcolor\",\n    \"colored\",\n    \"colorama\",\n    \"types-colorama\",\n    # yaml\n    \"oyaml\",\n    \"ruamel.yaml\",\n    # google cloud\n    \"google-api-python-client\",\n    \"google-auth-httplib2\",\n    \"google-auth-oauthlib\",\n    \"google-cloud-datastore\",\n    # dependency injection\n    # \"dependency-injector\",\n    # misc\n    \"texttable\",\n    \"dispy\",\n    \"mako\",\n    \"luigi\",\n    \"pyinotify\",\n    \"twisted\",\n    \"yapsy\",\n    \"plotly\",\n    \"gcloud\",\n    \"networkx\",\n    \"keyring\",\n    \"python-jenkins\",\n    \"SortedContainers\",\n    \"PyRSS2Gen\",\n    \"fire\",\n    \"PyGithub\",\n    \"gitpython\",\n    \"prompt-toolkit\",\n    \"azure-cognitiveservices-search-websearch\",\n    \"pygraph\",\n    \"tsv\",\n    \"pygments\",\n    \"types-pygments\",\n    # \"simpleparse\",\n    \"progressbar\",\n    \"inject\",\n    \"scrapy\",\n    \"browser_cookie3\",\n    \"ConfigParser\",\n    \"unidecode\",\n    \"paramiko\",\n    \"boto\",\n    \"boto3\",\n    \"boto3-stubs\",\n    \"attr\",\n    \"pyparsing\",\n    \"fastparquet\",\n    \"logging_tree\",\n    \"pluginbase\",\n    \"reportlab\",\n    \"imdbpy\",\n    \"python-pptx\",\n    \"elasticsearch\",\n    \"statistics\",\n    \"opencv-python\",\n    \"python-magic\",\n    \"imageio\",\n    # my stuff\n    \"pyapikey\",\n    \"pyvardump\",\n    # EXIF and image related libraries\n    \"Pillow\",\n    \"types-Pillow\",\n    \"ExifRead\",\n    \"exif\",\n    \"piexif\",\n    \"PyExifTool\",\n    # k8s\n    \"kubernetes\",\n    \"kubernetes-stubs\",\n    \"openshift-client\",\n    \"openshift\",\n    # math and machine learning\n    \"bitmath\",\n    \"mpmath\",\n    \"sympy\",\n    \"scipy\",\n    \"pandas\",\n    \"pandas-stubs\",\n    \"numpy\",\n    \"matplotlib\",\n    \"colorspacious\",\n    \"scikit-learn\",\n    # flask-web\n    \"flask\",\n    \"Flask-RESTful\",\n    # fastapi-web\n    \"fastapi\",\n    \"uvicorn\",\n    \"tornado\",\n    \"django\",\n    \"djangorestframework\",\n    \"cryptography\",\n    \"svgwrite\",\n    \"jq\",\n    \"docker\",\n    \"humanize\",\n    # my own stuff\n    \"pygooglehelper\",\n]\nbuild_requires: List[str] = [\n    \"pymakehelper\",\n    \"pydmt\",\n]\ntest_requires: List[str] = [\n    \"pylint\",\n    \"pytest\",\n    \"pytest-cov\",\n    \"pytest-flake8\",\n    \"flake8\",\n    \"pylogconf\",\n    \"mypy\",\n    \"types-PyYAML\",\n    \"types-setuptools\",\n    \"types-boto\",\n    \"types-PyMySQL\",\n    \"types-requests\",\n    \"types-paramiko\",\n    \"types-termcolor\",\n]\nrequires = config_requires + install_requires + build_requires + test_requires\n"}
{"type": "source_file", "path": "src/examples/long/__all__/module.py", "content": "__all__ = (\"a\",)\n\n\ndef a():\n    print(\"a\")\n\n\ndef b():\n    print(\"b\")\n"}
{"type": "source_file", "path": "src/examples/long/extending_python_with_c/use_car.py", "content": "\"\"\"\nthis sys.path.append in the next section is needed since we didn\"t\n\"properly\" install the module to some standard python path location like /usr/share/python.\nIf we had this would not have been neccessary.\n\"\"\"\n\nimport sys\nsys.path.append(sys.argv[1])\n\n# pylint: disable=wrong-import-position,import-error\nimport car  # type: ignore # noqa: E402\nc = car.Car()\nprint(c)\nc.printSelf()\nc.setNumber(777)\nprint(c.getNumber())\nc.printSelf()\n"}
{"type": "source_file", "path": "src/examples/long/capture_all_process_outputs/simple_exec.py", "content": "\"\"\"\nThis example only does an os.execv\n\"\"\"\n\nimport os\nimport sys\n\nif len(sys.argv) < 2:\n    print(f\"{sys.argv[0]}: must supply process to run and arguments for it\", file=sys.stderr)\n    print(f\"{sys.argv[0]}: use it like this:\", file=sys.stderr)\n    print(f\"{sys.argv[0]}: {sys.argv[0]} ./write_to_any.py stdout stderr tty\", file=sys.stderr)\n    sys.exit(1)\n\nos.execv(sys.argv[1], sys.argv[1:])\n"}
{"type": "source_file", "path": "scripts/check_md.py", "content": "#!/usr/bin/env python\n\n\"\"\"\nScript to check the correctness of a course syllabus written in .md format\n\"\"\"\n\nfrom typing import List\nimport sys\n\nif len(sys.argv) != 2:\n    print(f\"usage: {sys.argv[0]} [filename]\", file=sys.stderr)\n    sys.exit(1)\n\nREQUIRED = [\n    \"Description\",\n    \"Tags\",\n    \"Duration\",\n    \"Intended Audience\",\n    \"Prerequisites\",\n    \"Objectives\",\n    \"Exercises\",\n    \"Outline\",\n    \"References\",\n    \"We will not cover\",\n    \"Installations\",\n    \"Notes\",\n    \"Links\",\n]\nMUST = [\n    \"Description\",\n    \"Duration\",\n    # \"Prerequisites\",\n    # \"Objectives\",\n    \"Outline\",\n]\n\n\ndef is_sublist(list1: List[str], list2: List[str]) -> bool:\n    \"\"\"\n    Check that one list is a sublist of the other\n    \"\"\"\n    pos2 = 0\n    pos1 = 0\n    while pos2 < len(list2) and pos1 < len(list1):\n        if list2[pos2] == list1[pos1]:\n            pos1 += 1\n        pos2 += 1\n    return pos1 == len(list1)\n\n\ndef main():\n    \"\"\" main entry point \"\"\"\n    filename = sys.argv[1]\n    headers = []\n    title = None\n    with open(filename, \"r\", encoding=\"utf-8\") as stream:\n        for line in stream:\n            line = line.rstrip()\n            if line.startswith(\"## \"):\n                headers.append(line[3:])\n            if line.startswith(\"# \"):\n                if title is None:\n                    title = line[3:]\n                else:\n                    raise ValueError(\"two titles in one file\")\n    assert title is not None, \"have no title\"\n    if not is_sublist(headers, REQUIRED):\n        print(\"Sublist errors\")\n        print(\"found headers ->\")\n        print(str(headers))\n        print(\"required headers -> \")\n        print(str(REQUIRED))\n        sys.exit(1)\n    assert all(header in headers for header in MUST), (headers, MUST)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "src/examples/long/importlib/my_module/__init__.py", "content": ""}
{"type": "source_file", "path": "src/examples/long/debugging_pydb/debug.py", "content": "\"\"\"\nThis is an example of a simple python application\nthat you can use to debug with pydb.\n\"\"\"\n\n\ndef calc():\n    i = 0\n    current_sum = 0\n    while True:\n        current_sum += i\n        i += 1\n\n\ncalc()\n"}
{"type": "source_file", "path": "config/github.py", "content": "workflows_platforms = [\n    (\"ubuntu-24.04\", \"3.12\"),\n]\n"}
{"type": "source_file", "path": "src/examples/long/elastic_search/show_server_info.py", "content": "from elasticsearch import Elasticsearch\nclient = Elasticsearch(hosts=\"http://localhost:9200\")\nprint(client.info())\n"}
{"type": "source_file", "path": "not_mine/quine_python.py", "content": "# DONTCHECK\ns = r\"print('s = r\\\"{0}\\\"'.format(s), '\\n', s, sep='')\"\nprint(f\"s = r\\\"{s}\\\"\", '\\n', s, sep='')\n"}
{"type": "source_file", "path": "src/examples/long/capture_all_process_outputs/capture_tty_lowlevel.py", "content": "\"\"\"\nThis example captures all output of a process: stdout, stderr and tty.\n\nReferences:\nhttp://stackoverflow.com/questions/11495783/redirect-subprocess-stderr-to-stdout\n\"\"\"\n\nimport os\nimport pty\nimport sys\n\nif len(sys.argv) < 2:\n    print(f\"{sys.argv[0]}: must supply process to run and arguments for it\", file=sys.stderr)\n    print(f\"{sys.argv[0]}: use it like this:\", file=sys.stderr)\n    print(f\"{sys.argv[0]}: {sys.argv[0]} ./write_to_any.py stdout stderr tty\", file=sys.stderr)\n    sys.exit(1)\n\n(pid, fd) = pty.fork()\nif pid == 0:\n    os.execv(sys.argv[1], sys.argv[1:])\n    print(\"execv didnt work\", file=sys.stderr)\nelse:\n    # At the end of the loop we get an exception when the connection with the other side terminates.\n    # This is kinda ugly since strictly speaking this is not an error, but oh well.\n    buffer_size = 1024\n    buf = os.read(fd, buffer_size).decode()\n    over = False\n    while len(buf) > 0 and not over:\n        # print(\"got buf [{0}]\".format(buf))\n        lines = buf.split(\"\\n\")\n        buf = lines[-1]\n        del lines[-1]\n        for line in lines:\n            line += \"\\n\"\n            print(f\"got line [{line}]\")\n        try:\n            buf += os.read(fd, buffer_size).decode()\n        except OSError:\n            over = True\n    (pid, ret) = os.wait()\n    if os.WIFEXITED(ret):\n        print(f\"proc exited and status was [{os.WEXITSTATUS(ret)}]\")\n    if os.WIFSTOPPED(ret):\n        print(f\"proc stopped and stopsig was [{os.WSTOPSIG(ret)}]\")\n    if os.WIFSIGNALED(ret):\n        print(f\"proc signaled and signal was [{os.WTERMSIG(ret)}]\")\n"}
{"type": "source_file", "path": "src/examples/long/__all__/user.py", "content": "# pylint: disable=relative-beyond-top-level,no-name-in-module\n# type: ignore\nfrom . import module\n\nmodule.a()\ntry:\n    module.b()\nexcept NameError:\n    print(\"yes got exception\")\n"}
{"type": "source_file", "path": "src/examples/long/importlib/my_module/b.py", "content": "print(\"this is b\")\nnumber = 7\n"}
{"type": "source_file", "path": "src/examples/long/dict_set_random_order/randomized_order.py", "content": "\"\"\"\nThis example shows that iterating a hash produces random order\n\nNOTES:\n- with \"PYTHONHASHSEED\" environment variable we can control the behavior\nof the hash.\n- \"PYTHONHASHSEED\" does not guarantee traversal of elements in the\ndict will be in order of insertion. It does guarantee that the order will be\nthe same in every run. So it guarantees determinism, not order which is\nsometimes good enough.\n\"\"\"\n\n\nimport os\n\nprint(\"No PYTHONHASHSEED\")\nos.system(\"./sample.py\")\nos.system(\"./sample.py\")\nos.environ[\"PYTHONHASHSEED\"] = \"1\"\nprint(\"PYTHONHASHSEED=1\")\nos.system(\"./sample.py\")\nos.system(\"./sample.py\")\n"}
{"type": "source_file", "path": "scripts/__init__.py", "content": ""}
{"type": "source_file", "path": "src/examples/long/__init__.py", "content": ""}
{"type": "source_file", "path": "src/examples/long/crashing_python/my_python.py", "content": "from ctypes import CDLL\nimport os\nso_file = os.path.join(os.getcwd(), \"my_functions.so\")\nmy_functions = CDLL(so_file)\nprint(my_functions.square(10))\n"}
{"type": "source_file", "path": "config/personal.py", "content": "# personal section\nfirstname = \"Mark\"\nsurname = \"Veltzer\"\nfullname = f\"{firstname} {surname}\"\nemail = \"mark.veltzer@gmail.com\"\ndomain = \"veltzer.name\"\nslug = \"veltzer\"\n\ngithub_username = \"veltzer\"\nlaunchpad_username = \"mark-veltzer\"\n\n# this is the key used for signing.\n# it really should not have a passphrase since that will means that I have\n# to manually sign everything...\n# it must match the email_key up...\nkey = \"73C128F9\"\nemail_key = \"mark.veltzer@gmail.com\"\n# the person who is the owner of the key and must match *exactly* what you get\n# from \"gpg --list-keys\"...\nkey_signer = f\"{fullname} (signkey, never expires) <{email_key}>\"\n\norigin = f\"{fullname} <{email}>\"\n# hostname as seen from the outside world\nwww_hostname = domain\n# name as seen from the outside world\nwww_domainname = domain\n# jsdoc style author tag\njsdoc_author = f\"{email} ({fullname})\"\n"}
{"type": "source_file", "path": "src/examples/long/loading_twice_into_the_same_namespace/folder2/module.py", "content": "in_both = \"value of in_both from my_mod_2\"\nonly_in_my_mod_2 = \"value of only_in_my_mod_2 from my_mod_2\"\n"}
{"type": "source_file", "path": "scripts/autopep8.py", "content": "#!/usr/bin/env python\n\n\"\"\"\n- We may add \"-a\" or \"-a -a\" to the autopep8 to make it fix more.\n- Use \"autopep8 --list-fixes\" to see the list of things autopep8 does\n- You can select exactly which fixes to apply and which to ignore.\n- Currently we apply all fixes quite aggressively.\n\"\"\"\n\nimport subprocess\n\nsubprocess.check_call([\n    \"autopep8\",\n    # \"--aggressive\",\n    # \"--aggressive\",\n    # \"--aggressive\",\n    \"--recursive\",\n    \"--in-place\",\n    \"src\",\n])\n"}
{"type": "source_file", "path": "src/examples/long/glade/run_glade_client.py", "content": "\"\"\"\nA basic glade based python project.\n\"\"\"\n\n\nimport gi\ngi.require_version(\"Gtk\", \"3.0\")\n# pylint: disable=wrong-import-position\nfrom gi.repository import Gtk  # noqa: E402\n\n\nclass HelloWorldGTK:\n    \"\"\"This is a Hello World GTK/Glade application\"\"\"\n\n    def __init__(self):\n        self.glade_file = \"project.glade\"\n        self.glade = Gtk.Builder()\n        self.glade.add_from_file(self.glade_file)\n        self.glade.connect_signals(self)\n        # the name \"MainWindow\" matches the name of the main window widget\n        # in the glade XML file\n        self.glade.get_object(\"MainWindow\").show_all()\n\n    # the name of this method matches the event handler in the glade xml file\n\n    # noinspection PyMethodMayBeStatic\n    def delete_event(self, *args):\n        Gtk.main_quit(*args)\n\n\n# The try/except is needed so that if you CTRL+C the application you will not get an exception\n# with stack trace\ntry:\n    app = HelloWorldGTK()\n    Gtk.main()  # type: ignore\nexcept KeyboardInterrupt:\n    pass\n"}
{"type": "source_file", "path": "src/examples/long/importlib/reload.py", "content": "\"\"\"\nThis is a demo of how to use importlib.reload to reload\nmodules in python.\n\"\"\"\n\nimport importlib\nimport time\nfrom .my_module import a\n\n\nwhile True:\n    importlib.reload(a)\n    time.sleep(1)\n"}
{"type": "source_file", "path": "config/platform.py", "content": "import pyclassifiers.values\n\npython_requires = \">=3.12\"\n\nlicense_type = \"MIT\"\n\nplatforms = [\n    \"python3\",\n]\n\nclassifiers = [\n    pyclassifiers.values.DevelopmentStatus__4_Beta,\n    pyclassifiers.values.Environment__Console,\n    pyclassifiers.values.OperatingSystem__OSIndependent,\n    pyclassifiers.values.ProgrammingLanguage__Python,\n    pyclassifiers.values.ProgrammingLanguage__Python__3,\n    pyclassifiers.values.ProgrammingLanguage__Python__3__Only,\n    pyclassifiers.values.ProgrammingLanguage__Python__312,\n    pyclassifiers.values.Topic__Utilities,\n    pyclassifiers.values.License__OSIApproved__MITLicense,\n]\n"}
{"type": "source_file", "path": "src/examples/long/importlib/__init__.py", "content": ""}
{"type": "source_file", "path": "config/project.py", "content": "name = \"demos-python\"\ndescription_short = \"Demos for the Python programming language\"\ndescription_long = \"\"\"This project explores the python programming language.\nThe idea is that when you are programming you may find many examples\nover the Internet but you always need to tweak them a bit to see\nhow you can get to an example which answers your needs precisely.\nOver the Internet this is hard to do. But if you clone hundreds\nof examples and you have them in working condition on your machine\nyou can just find the example which is closest to what you need\nand tweak it until it does exactly what you need. You may even\nadd your example as a new example or contribute it back to this project.\nThis is a much better way of programming since you are not doing\nthe experiments on your full system but rather on a small example\nthat is easy to run, debug and manage. Once you have the example ready and\nrunning correctly you can incorporate its code into a larger project.\"\"\"\nkeywords = [\n    \"demos\",\n    \"python\",\n]\n"}
{"type": "source_file", "path": "src/examples/long/dict_set_random_order/sample.py", "content": "\"\"\"\nThis is an example which shows a standard dictionary vs an ordered dict.\n\"\"\"\n\nimport collections\nimport os\nfrom typing import Dict\n\nd1 = dict((letter, i) for i, letter in enumerate(\"word\"))\nprint(d1)\nd2: Dict[str,None] = {}\nfor x in dir(os):\n    d2[x] = None\nprint(d2)\nd3 = {x:None for x in dir(os)}\nprint(d3)\nud = {}\nod = collections.OrderedDict()\ns = set()\nfor i in range(100):\n    ud[str(i)] = i\n    od[str(i)] = i\n    s.add(str(i))\nprint(\"unordered dict\")\nprint(\" \".join([f\"{k},{v}\" for k, v in ud.items()]))\nprint(\"ordered dict\")\nprint(\" \".join([f\"{k},{v}\" for k, v in od.items()]))\nprint(\"set\")\nprint(\" \".join(x for x in s))\n"}
{"type": "source_file", "path": "src/examples/long/extending_python_with_c/use_atoi.py", "content": "\"\"\"\nthe sys.path.append in the next section is needed since we didn\"t \"properly\"\ninstall the module to /usr/share/python.\nIf we had done this this would not have been neccessary.\n\"\"\"\n\nimport sys\nsys.path.append(sys.argv[1])\n# pylint: disable=wrong-import-position,import-error\nimport atoi  # type: ignore # noqa: E402\n\n\n# the whole path is: python \"str\" -> C string (char*) -> calls c \"atoi\" - > C int (64 bit, singed) -> Python \"int\"\nr = atoi.atoi(\"-7.6\")\nprint(type(r))\nprint(r)\n"}
{"type": "source_file", "path": "src/examples/long/capture_all_process_outputs/helloworld.py", "content": "\"\"\"\nA basic hello world program\n\"\"\"\n\nprint(\"Hello World!\")\n"}
{"type": "source_file", "path": "src/examples/long/extending_python_with_c/setup_car.py", "content": "\"\"\"\nsetup.py file for SWIG car\n\"\"\"\n\n\nfrom setuptools import setup, Extension\n\n\ncar_module = Extension(\n    \"_car\",\n    sources=[\"car_wrap.cxx\", \"car.cc\"],\n)\n\nsetup(\n    name=\"car\",\n    version=\"0.1\",\n    author=\"SWIG Docs\",\n    description=\"Simple swig a from docs\",\n    ext_modules=[car_module],\n    py_modules=[\"car\"],\n)\n"}
{"type": "source_file", "path": "src/examples/long/loading_twice_into_the_same_namespace/import_tricks.py", "content": "\"\"\"\nThis example shows how to use the \"imp\" module to do double importing of content\ninto the same namespace. You select the namespace, in this case \"config\".\n\"\"\"\n\nimport importlib\n\n\none = importlib.import_module(\"folder1.module\")\ntwo = importlib.import_module(\"folder2.module\")\n"}

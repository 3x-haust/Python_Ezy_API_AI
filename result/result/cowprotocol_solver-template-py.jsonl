{"repo_info": {"repo_name": "solver-template-py", "repo_owner": "cowprotocol", "repo_url": "https://github.com/cowprotocol/solver-template-py"}}
{"type": "test_file", "path": "tests/unit/test_order.py", "content": "import unittest\n\nfrom src.models.order import Order, OrderMatchType\nfrom src.models.token import Token\n\n\nclass MyTestCase(unittest.TestCase):\n    def setUp(self) -> None:\n        self.token_a = \"0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1\"\n        self.token_b = \"0x177127622c4a00f3d409b75571e12cb3c8973d3c\"\n        self.token_c = \"0x1111111111111111111111111111111111111111\"\n\n    def overlapping_orders(self):\n        order1 = Order.from_dict(\n            \"1\",\n            {\n                \"sell_token\": self.token_a,\n                \"buy_token\": self.token_b,\n                \"sell_amount\": \"12\",\n                \"buy_amount\": \"100\",\n                \"allow_partial_fill\": False,\n                \"is_sell_order\": True,\n                \"fee\": {\n                    \"amount\": \"115995469750\",\n                    \"token\": \"0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1\",\n                },\n                \"cost\": {\n                    \"amount\": \"321627750000000\",\n                    \"token\": \"0xe91d153e0b41518a2ce8dd3d7944fa863463a97d\",\n                },\n                \"is_liquidity_order\": False,\n                \"mandatory\": False,\n                \"has_atomic_execution\": False,\n            },\n        )\n        order2 = Order.from_dict(\n            \"2\",\n            {\n                \"sell_token\": self.token_b,\n                \"buy_token\": self.token_a,\n                \"sell_amount\": \"100\",\n                \"buy_amount\": \"10\",\n                \"allow_partial_fill\": False,\n                \"is_sell_order\": True,\n                \"fee\": {\n                    \"amount\": \"115995469750\",\n                    \"token\": \"0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1\",\n                },\n                \"cost\": {\n                    \"amount\": \"321627750000000\",\n                    \"token\": \"0xe91d153e0b41518a2ce8dd3d7944fa863463a97d\",\n                },\n                \"is_liquidity_order\": False,\n                \"mandatory\": False,\n                \"has_atomic_execution\": False,\n            },\n        )\n\n        return order1, order2\n\n    def test_overlaps(self):\n\n        order1, order2 = self.overlapping_orders()\n        self.assertTrue(order1.overlaps(order2))\n\n        # Change the buy amount to make it so the orders don't overlap.\n        old_buy_amount = order1.buy_amount\n\n        order1.buy_amount *= 10\n        self.assertFalse(order1.overlaps(order2))\n\n        # Set the buy amount back and change the token.\n        order1.buy_amount = old_buy_amount\n        self.assertTrue(order1.overlaps(order2))\n        token_c = \"0x1111111111111111111111111111111111111111\"\n        order1.buy_token = Token(token_c)\n        self.assertFalse(order1.overlaps(order2))\n\n    def test_match_type(self):\n        order1, order2 = self.overlapping_orders()\n\n        self.assertEqual(order1.match_type(order2), OrderMatchType.BOTH_FILLED)\n\n        # Make order1 half the size\n        order1.buy_amount /= 2\n        order1.sell_amount /= 2\n\n        self.assertEqual(order1.match_type(order2), OrderMatchType.LHS_FILLED)\n        # Reverse the orders to get RHS Filled\n        self.assertEqual(order2.match_type(order1), OrderMatchType.RHS_FILLED)\n\n        order1.buy_token = Token(self.token_c)\n\n        self.assertIsNone(order1.match_type(order2))\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"}
{"type": "source_file", "path": "src/models/order.py", "content": "\"\"\"Representation of a limit order.\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom decimal import Decimal\nfrom enum import Enum\nfrom typing import Optional, Any, Union\n\n\nfrom src.models.exchange_rate import ExchangeRate as XRate\nfrom src.models.token import Token, TokenBalance\nfrom src.models.types import NumericType\nfrom src.util.constants import Constants\nfrom src.util.numbers import decimal_to_str\n\nOrderSerializedType = dict[str, Any]\nOrdersSerializedType = dict[str, OrderSerializedType]\n\n\nclass OrderMatchType(Enum):\n    \"\"\"Enum for different Order Matching\"\"\"\n\n    LHS_FILLED = \"LhsFilled\"\n    RHS_FILLED = \"RhsFilled\"\n    BOTH_FILLED = \"BothFilled\"\n\n\n# TODO - use dataclass for this.\nclass Order:\n    \"\"\"Representation of a limit order.\n    An order is specified with 3 bounds:\n        * maximum amount of buy-token to be bought\n        * maximum amount of sell-token to be sold\n        * limit exchange rate of buy- vs. sell-token.\n\n    Depending on which of the bounds are set,\n    the order represents a classical limit {buy|sell} order,\n    a cost-bounded {buy|sell} order or a {buy|sell} market order.\n    \"\"\"\n\n    def __init__(\n        self,\n        order_id: str,\n        buy_token: Token,\n        sell_token: Token,\n        buy_amount: Decimal,\n        sell_amount: Decimal,\n        is_sell_order: bool,\n        allow_partial_fill: bool = False,\n        is_liquidity_order: bool = False,\n        has_atomic_execution: bool = False,\n        fee: Optional[TokenBalance] = None,\n        cost: Optional[TokenBalance] = None,\n    ) -> None:\n        \"\"\"Initialize.\n\n        Args:\n            order_id: Order pool_id.\n            buy_token: Token to be bought.\n            sell_token: Token to be sold.\n\n        Kwargs:\n            max_buy_amount: Maximum amount of buy-token to be bought, or None.\n            max_sell_amount: Maximum amount of sell-token to be sold, or None.\n            max_limit: Limit exchange rate for order.\n            allow_partial_fill: Can order be partially matched, or not.\n            is_liquidity_order: Is the order from a market maker, or not.\n            has_atomic_execution: Needs to executed atomically, or not.\n            fee: Fee contribution of the order to the objective.\n            cost: Cost of including the order in the solution.\n            exec_buy_amount: Matched amount of buy-token in solution.\n            exec_sell_amount: Matched amount of sell-token in solution.\n        \"\"\"\n        if buy_token == sell_token:\n            raise ValueError(\"sell- and buy-token cannot be equal!\")\n\n        if not (buy_amount > 0 and sell_amount > 0):\n            raise ValueError(\n                f\"buy {buy_amount} and sell {sell_amount} amounts must be positive!\"\n            )\n\n        self.order_id = order_id\n        self.buy_token = buy_token\n        self.sell_token = sell_token\n        self.buy_amount = buy_amount\n        self.sell_amount = sell_amount\n        self.is_sell_order = is_sell_order\n        self.allow_partial_fill = allow_partial_fill\n        self.is_liquidity_order = is_liquidity_order\n        self.has_atomic_execution = has_atomic_execution\n        self.fee: Optional[TokenBalance] = fee\n        self.cost: Optional[TokenBalance] = cost\n\n        # Stuff that isn't part of the constructor parameters.\n        self.exec_buy_amount: Optional[TokenBalance] = None\n        self.exec_sell_amount: Optional[TokenBalance] = None\n\n    @classmethod\n    def from_dict(cls, order_id: str, data: OrderSerializedType) -> Order:\n        \"\"\"\n        Read Order object from order data dict.\n        Args:\n            order_id: ID of order\n            data: Dict of order data.\n        \"\"\"\n\n        required_attributes = [\n            \"sell_token\",\n            \"buy_token\",\n            \"sell_amount\",\n            \"buy_amount\",\n            \"is_sell_order\",\n            \"allow_partial_fill\",\n            \"is_liquidity_order\",\n        ]\n\n        for attr in required_attributes:\n            if attr not in data:\n                raise ValueError(f\"Missing field '{attr}' in order <{order_id}>!\")\n\n        return Order(\n            order_id=order_id,\n            buy_token=Token(data[\"buy_token\"]),\n            sell_token=Token(data[\"sell_token\"]),\n            buy_amount=Decimal(data[\"buy_amount\"]),\n            sell_amount=Decimal(data[\"sell_amount\"]),\n            is_sell_order=bool(data[\"is_sell_order\"]),\n            allow_partial_fill=bool(data[\"allow_partial_fill\"]),\n            is_liquidity_order=bool(data[\"is_liquidity_order\"]),\n            fee=TokenBalance.parse(data.get(\"fee\"), allow_none=True),\n            cost=TokenBalance.parse(data.get(\"cost\"), allow_none=True),\n        )\n\n    def as_dict(self) -> OrderSerializedType:\n        \"\"\"Return Order object as dictionary.\"\"\"\n        # Currently, only limit buy or sell orders be handled.\n        order_dict = {\n            \"sell_token\": str(self.sell_token),\n            \"buy_token\": str(self.buy_token),\n            \"sell_amount\": decimal_to_str(self.sell_amount),\n            \"buy_amount\": decimal_to_str(self.buy_amount),\n            \"allow_partial_fill\": self.allow_partial_fill,\n            \"is_sell_order\": self.is_sell_order,\n            \"exec_sell_amount\": decimal_to_str(self.exec_sell_amount.as_decimal())\n            if self.exec_sell_amount is not None\n            else \"0\",\n            \"exec_buy_amount\": decimal_to_str(self.exec_buy_amount.as_decimal())\n            if self.exec_buy_amount is not None\n            else \"0\",\n        }\n\n        if self.fee is not None:\n            order_dict[\"fee\"] = {\n                \"token\": str(self.fee.token),\n                \"amount\": decimal_to_str(self.fee.as_decimal()),\n            }\n\n        if self.cost is not None:\n            order_dict[\"cost\"] = {\n                \"token\": str(self.cost.token),\n                \"amount\": decimal_to_str(self.cost.as_decimal()),\n            }\n\n        return order_dict\n\n    @property\n    def max_limit(self) -> XRate:\n        \"\"\"Max limit of the order as an exchange rate\"\"\"\n        return XRate(\n            tb1=TokenBalance(self.sell_amount, self.sell_token),\n            tb2=TokenBalance(self.buy_amount, self.buy_token),\n        )\n\n    @property\n    def max_buy_amount(self) -> Optional[TokenBalance]:\n        \"\"\"None for sell-orders\"\"\"\n        if not self.is_sell_order:\n            return TokenBalance.parse_amount(self.buy_amount, self.buy_token)\n        return None\n\n    @property\n    def max_sell_amount(self) -> Optional[TokenBalance]:\n        \"\"\"None for buy-orders\"\"\"\n        if self.is_sell_order:\n            return TokenBalance.parse_amount(self.sell_amount, self.sell_token)\n        return None\n\n    @property\n    def tokens(self) -> set[Token]:\n        \"\"\"Return the buy and sell tokens.\"\"\"\n        return {self.buy_token, self.sell_token}\n\n    #####################\n    #  UTILITY METHODS  #`\n    #####################\n\n    def overlaps(self, other: Order) -> bool:\n        \"\"\"\n        Determine if one order can be matched with another.\n        opposite {buy|sell} tokens and matching prices\n        \"\"\"\n        token_conditions = [\n            self.buy_token == other.sell_token,\n            self.sell_token == other.buy_token,\n        ]\n        if not all(token_conditions):\n            return False\n\n        return (\n            self.buy_amount * other.buy_amount <= other.sell_amount * self.sell_amount\n        )\n\n    def match_type(self, other: Order) -> Optional[OrderMatchType]:\n        \"\"\"Determine to what extent two orders match\"\"\"\n        if not self.overlaps(other):\n            return None\n\n        if self.buy_amount < other.sell_amount and self.sell_amount < other.buy_amount:\n            return OrderMatchType.LHS_FILLED\n\n        if self.buy_amount > other.sell_amount and self.sell_amount > other.buy_amount:\n            return OrderMatchType.RHS_FILLED\n\n        return OrderMatchType.BOTH_FILLED\n\n    def is_executable(self, xrate: XRate, xrate_tol: Decimal = Decimal(\"1e-6\")) -> bool:\n        \"\"\"Determine if the order limit price satisfies a given market rate.\n\n        Args:\n            xrate: Exchange rate.\n            xrate_tol: Accepted violation of the limit exchange rate constraint\n                       per unit of buy token (default: 1e-6).\n        Returns:\n            True, if order can be executed; False otherwise.\n        \"\"\"\n        buy_token, sell_token = self.buy_token, self.sell_token\n        if xrate.tokens != {buy_token, sell_token}:\n            raise ValueError(\n                f\"Exchange rate and order tokens do not \"\n                f\"match: {xrate} vs. <{buy_token}> | <{sell_token}>!\"\n            )\n\n        assert xrate_tol >= 0\n        converted_buy = xrate.convert_unit(buy_token)\n        converted_sell = self.max_limit.convert_unit(buy_token)\n        return bool(converted_buy <= (converted_sell * (1 + xrate_tol)))\n\n    def execute(\n        self,\n        buy_amount_value: NumericType,\n        sell_amount_value: NumericType,\n        buy_token_price: Union[float, Decimal] = 0,\n        sell_token_price: Union[float, Decimal] = 0,\n        amount_tol: Decimal = Decimal(\"1e-8\"),\n        xrate_tol: Decimal = Decimal(\"1e-6\"),\n    ) -> None:\n        \"\"\"Execute the order at given amounts.\n\n        Args:\n            buy_amount_value: Buy amount.\n            sell_amount_value: Sell amount.\n            buy_token_price: Buy-token price.\n            sell_token_price: Sell-token price.\n            amount_tol: Accepted violation of the limit buy/sell amount constraints.\n            xrate_tol: Accepted violation of the limit exchange rate constraint\n                       per unit of buy token (default: 1e-6).\n        \"\"\"\n        assert buy_amount_value >= -amount_tol\n        assert sell_amount_value >= -amount_tol\n        assert buy_token_price >= 0\n        assert sell_token_price >= 0\n\n        buy_token, sell_token = self.buy_token, self.sell_token\n\n        buy_amount = TokenBalance(buy_amount_value, buy_token)\n        sell_amount = TokenBalance(sell_amount_value, sell_token)\n\n        xmax = self.max_buy_amount\n        ymax = self.max_sell_amount\n\n        # (a) Check buyAmount: if too much above maxBuyAmount --> error!\n        if xmax is not None:\n            if buy_amount > xmax * (\n                1 + amount_tol\n            ) and buy_amount > xmax + TokenBalance(amount_tol, buy_token):\n                raise ValueError(\n                    f\"Invalid execution request for \"\n                    f\"order <{self.order_id}>: \"\n                    f\"buy amount (exec) : {buy_amount.balance} \"\n                    f\"buy amount (max)  : {xmax.balance}\"\n                )\n\n            buy_amount = min(buy_amount, xmax)\n\n        # (b) Check sellAmount: if too much above maxSellAmount --> error!\n        if ymax is not None:\n            if sell_amount > ymax * (\n                1 + amount_tol\n            ) and sell_amount > ymax + TokenBalance(amount_tol, sell_token):\n                message = (\n                    f\"Invalid execution request for \"\n                    f\"order <{self.order_id}>: \"\n                    f\"sell (exec) : {sell_amount.balance} \"\n                    f\"sell (max)  : {ymax.balance}\"\n                )\n                logging.error(message)\n                if Constants.RAISE_ON_MAX_SELL_AMOUNT_VIOLATION:\n                    raise ValueError(message)\n            sell_amount = min(sell_amount, ymax)\n\n        # (c) if any amount is very small, set to zero.\n        if any(\n            [\n                buy_amount <= TokenBalance(amount_tol, buy_token),\n                sell_amount <= TokenBalance(amount_tol, sell_token),\n            ]\n        ):\n            buy_amount = TokenBalance(0.0, buy_token)\n            sell_amount = TokenBalance(0.0, sell_token)\n\n        # Check limit price.\n        if buy_amount > 0:\n            assert sell_amount > 0\n            xrate = XRate(buy_amount, sell_amount)\n            if not self.is_executable(xrate, xrate_tol=xrate_tol):\n                message = (\n                    f\"Invalid execution request for order <{self.order_id}>: \"\n                    f\"buy amount (exec): {buy_amount.balance} \"\n                    f\"sell amount (exec): {sell_amount.balance} \"\n                    f\"xrate (exec): {xrate} \"\n                    f\"limit (max): {self.max_limit}\"\n                )\n                logging.error(message)\n                if Constants.RAISE_ON_LIMIT_XRATE_VIOLATION:\n                    raise ValueError(message)\n\n        # Store execution information.\n        self.exec_buy_amount = buy_amount\n        self.exec_sell_amount = sell_amount\n\n    def is_executed(self) -> bool:\n        \"\"\"Check if order has already been executed.\"\"\"\n        return self.exec_buy_amount is not None and self.exec_sell_amount is not None\n\n    def __str__(self) -> str:\n        \"\"\"Represent as string.\"\"\"\n        return json.dumps(self.as_dict(), indent=2)\n\n    def __repr__(self) -> str:\n        \"\"\"Represent as short string.\"\"\"\n        return f\"Order: {self.order_id}\"\n\n    def __hash__(self) -> int:\n        return hash(self.order_id)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Order):\n            return NotImplemented\n        if self.order_id != other.order_id:\n            return False\n        assert vars(self) == vars(other)\n        return True\n\n    def __lt__(self, other: object) -> bool:\n        if not isinstance(other, Order):\n            return NotImplemented\n\n        return self.order_id < other.order_id\n"}
{"type": "source_file", "path": "src/models/exchange_rate.py", "content": "\"\"\"Representation of an exchange rate between two tokens.\"\"\"\nfrom __future__ import annotations\n\nfrom src.models.token import Token, TokenBalance\nfrom src.models.types import NumericType\n\n\nclass ExchangeRate:\n    \"\"\"Class representing the exchange rate between two tokens.\"\"\"\n\n    def __init__(self, tb1: TokenBalance, tb2: TokenBalance):\n        \"\"\"\n        An ExchangeRate is represented as equivalence of two TokenBalances,\n        e.g., 2 [ETH] == 800 [EUR] --> 400 [EUR]/[ETH] or 0.0025 [ETH]/[EUR].\n        Args:\n            tb1: First TokenBalance.\n            tb2: Second TokenBalance.\n        \"\"\"\n        assert isinstance(tb1, TokenBalance)\n        assert isinstance(tb2, TokenBalance)\n\n        if tb1.token == tb2.token:\n            raise ValueError(\"Both given tokens are identical!\")\n\n        if not (tb1.is_positive() and tb2.is_positive()):\n            raise ValueError(f\"Both token balances must be positive! {tb1} & {tb2}\")\n\n        # Store attributes.\n        self.tb1 = tb1\n        self.tb2 = tb2\n\n    @classmethod\n    def from_prices(\n        cls,\n        token1_price: tuple[Token, NumericType],\n        token2_price: tuple[Token, NumericType],\n    ) -> ExchangeRate:\n        \"\"\"Alternative constructor: Build ExchangeRate from (absolute) token prices.\n\n        Args:\n            token1_price: Tuple of (Token, price).\n            token2_price: Tuple of (Token, price).\n        Returns:\n            The ExchangeRate between the input tokens at the given prices.\n        \"\"\"\n        # Validate Input\n        balances = []\n        for token_price in [token1_price, token2_price]:\n            assert isinstance(token_price, tuple) and len(token_price) == 2\n            token, price = token_price\n            assert isinstance(token, Token)\n            assert price > 0\n\n            balances.append(TokenBalance(price, token))\n\n        return cls(balances[0], balances[1])\n\n    def token_balance(self, token: Token) -> TokenBalance:\n        \"\"\"Get token balance for given token.\"\"\"\n        if token == self.tb1.token:\n            return self.tb1\n        if token == self.tb2.token:\n            return self.tb2\n\n        raise ValueError(f\"Exchange rate does not involve {token}\")\n\n    @property\n    def tokens(self) -> set[Token]:\n        \"\"\"Returns a set containing the two tokens.\"\"\"\n        return {self.tb1.token, self.tb2.token}\n\n    def convert(self, token_balance: TokenBalance) -> TokenBalance:\n        \"\"\"Convert a TokenBalance of one token into a TokenBalance of the other.\n        Args:\n            token_balance: TokenBalance to be converted.\n        Returns: Converted TokenBalance.\n        \"\"\"\n        assert isinstance(token_balance, TokenBalance)\n\n        if token_balance.token == self.tb1.token:\n            # Division of two token balances with same token yields scalar\n            # which can then be multiplied with another token balance.\n            return (token_balance / self.tb1).as_decimal() * self.tb2\n\n        if token_balance.token == self.tb2.token:\n            return (token_balance / self.tb2).as_decimal() * self.tb1\n\n        raise ValueError(\n            f\"Token balance <{token_balance}> can not be \"\n            f\"converted using ExchangeRate <{self.tb1.token}/{self.tb2.token}>!\"\n        )\n\n    def convert_unit(self, token: Token) -> TokenBalance:\n        \"\"\"Convert one unit of one token into a TokenBalance of the other.\n        Args:\n            token: Token to be converted.\n        Returns:\n            Converted TokenBalance.\n        \"\"\"\n        assert isinstance(token, Token)\n        return self.convert(TokenBalance(1, token))\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Equality operator\"\"\"\n        if not isinstance(other, ExchangeRate):\n            raise ValueError(f\"Cannot compare ExchangeRate and type <{type(other)}>!\")\n\n        # The ratio of the TokenBalances must be equal.\n        return self.convert(other.tb1) == other.tb2\n\n    def __ne__(self, other: object) -> bool:\n        \"\"\"Non-equality operator\"\"\"\n        return not self == other\n\n    def __str__(self) -> str:\n        \"\"\"Represent as string.\"\"\"\n        tb1 = self.convert(TokenBalance(1, self.tb1.token))\n        tb2 = self.convert(TokenBalance(1, self.tb2.token))\n        return f\"{tb1}/[{self.tb1.token}]  <=>  {tb2}/[{self.tb2.token}]\"\n\n    def __repr__(self) -> str:\n        \"\"\"Represent as string.\"\"\"\n        return str(self)\n"}
{"type": "source_file", "path": "src/models/__init__.py", "content": ""}
{"type": "source_file", "path": "src/__init__.py", "content": ""}
{"type": "source_file", "path": "src/_server.py", "content": "\"\"\"\nThis is the project's Entry point.\n\"\"\"\nfrom __future__ import annotations\n\nimport argparse\nimport decimal\nimport logging\n\nimport uvicorn\nfrom dotenv import load_dotenv\nfrom fastapi import FastAPI, Request\nfrom fastapi.middleware.gzip import GZipMiddleware\nfrom pydantic import BaseSettings\n\nfrom src.models.batch_auction import BatchAuction\nfrom src.models.solver_args import SolverArgs\nfrom src.util.schema import (\n    BatchAuctionModel,\n    SettledBatchAuctionModel,\n)\n\n# Set decimal precision.\ndecimal.getcontext().prec = 100\n\n# Holds parameters passed on the command line when invoking the server.\n# These will be merged with request solver parameters\nSERVER_ARGS = None\n\n\n# ++++ Interface definition ++++\n\n\n# Server settings: Can be overridden by passing them as env vars or in a .env file.\n# Example: PORT=8001 python -m src._server\nclass ServerSettings(BaseSettings):\n    \"\"\"Basic Server Settings\"\"\"\n\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n\n\nserver_settings = ServerSettings()\n\n# ++++ Endpoints: ++++\n\n\napp = FastAPI(title=\"Batch auction solver\")\napp.add_middleware(GZipMiddleware)\n\n\n@app.get(\"/health\", status_code=200)\ndef health() -> bool:\n    \"\"\"Convenience endpoint to check if server is alive.\"\"\"\n    return True\n\n\n@app.post(\"/notify\", response_model=bool)\nasync def notify(request: Request) -> bool:\n    \"\"\"Print response from notify endpoint.\"\"\"\n    print(f\"Notify request {await request.json()}\")\n    return True\n\n\n@app.post(\"/solve\", response_model=SettledBatchAuctionModel)\nasync def solve(problem: BatchAuctionModel, request: Request):  # type: ignore\n    \"\"\"API POST solve endpoint handler\"\"\"\n    logging.debug(f\"Received solve request {await request.json()}\")\n    solver_args = SolverArgs.from_request(request=request, meta=problem.metadata)\n\n    batch = BatchAuction.from_dict(problem.dict(), solver_args.instance_name)\n\n    print(\"Received Batch Auction\", batch.name)\n    print(\"Parameters Supplied\", solver_args)\n\n    # 1. Solve BatchAuction: update batch_auction with\n    # batch.solve()\n\n    trivial_solution = {\n        \"orders\": {},\n        \"foreign_liquidity_orders\": [],\n        \"amms\": {},\n        \"prices\": {},\n        \"approvals\": [],\n        \"interaction_data\": [],\n        \"score\": \"0\",\n    }\n\n    print(\"\\n\\n*************\\n\\nReturning solution: \" + str(trivial_solution))\n    return trivial_solution\n\n\n# ++++ Server setup: ++++\n\n\nif __name__ == \"__main__\":\n    load_dotenv()\n\n    parser = argparse.ArgumentParser(\n        fromfile_prefix_chars=\"@\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n    )\n    # TODO - enable flag to write files to persistent storage\n    # parser.add_argument(\n    #     \"--write_auxiliary_files\",\n    #     type=bool,\n    #     default=False,\n    #     help=\"Write auxiliary instance and optimization files, or not.\",\n    # )\n\n    parser.add_argument(\n        \"--log-level\",\n        type=str,\n        default=\"info\",\n        help=\"Log level\",\n    )\n\n    SERVER_ARGS = parser.parse_args()\n    uvicorn.run(\n        \"__main__:app\",\n        host=server_settings.host,\n        port=server_settings.port,\n        log_level=SERVER_ARGS.log_level,\n    )\n"}
{"type": "source_file", "path": "src/models/batch_auction.py", "content": "\"\"\"\nModel containing BatchAuction which is what solvers operate on.\n\"\"\"\n\nfrom __future__ import annotations\nimport decimal\nimport logging\nfrom decimal import Decimal\nfrom typing import Any, Optional\n\nfrom src.models.order import Order, OrdersSerializedType\nfrom src.models.token import (\n    Token,\n    TokenInfo,\n    select_token_with_highest_normalize_priority,\n    TokenDict,\n    TokenSerializedType,\n)\nfrom src.models.types import NumericType\nfrom src.models.uniswap import Uniswap, UniswapsSerializedType\nfrom src.util.enums import Chain\n\n\nclass BatchAuction:\n    \"\"\"Class to represent a batch auction.\"\"\"\n\n    def __init__(\n        self,\n        tokens: dict[Token, TokenInfo],\n        orders: dict[str, Order],\n        uniswaps: dict[str, Uniswap],\n        ref_token: Token,\n        prices: Optional[dict] = None,\n        name: str = \"batch_auction\",\n        metadata: Optional[dict] = None,\n    ):\n        \"\"\"Initialize.\n        Args:\n            tokens: dict of tokens participating.\n            orders: dict of Order objects.\n            uniswaps: dict of Uniswap objects.\n            ref_token: Reference Token object.\n            prices: A dict of {token -> price}.\n            name: Name of the batch auction instance.\n            metadata: Some instance metadata.\n        \"\"\"\n        self.name = name\n        self.metadata = metadata if metadata else {}\n\n        self._tokens = tokens\n        self._orders = orders\n        self._uniswaps = uniswaps\n\n        # Store reference token and (previous) prices.\n        self.ref_token = ref_token\n        self.prices = (\n            prices if prices else {ref_token: self._tokens[ref_token].external_price}\n        )\n\n    @classmethod\n    def from_dict(cls, data: dict, name: str) -> BatchAuction:\n        \"\"\"Read a batch auction instance from a python dictionary.\n\n        Args:\n            data: Python dict to be read.\n            name: Instance name.\n\n        Returns:\n            The instance.\n\n        \"\"\"\n        for key in [\"tokens\", \"orders\"]:\n            if key not in data:\n                raise ValueError(f\"Mandatory field '{key}' missing in instance data!\")\n\n        tokens = load_tokens(data[\"tokens\"])\n        orders = load_orders(data[\"orders\"])\n\n        uniswaps = load_amms(data.get(\"amms\", {}))\n        metadata = load_metadata(data.get(\"metadata\", {}))\n        prices = load_prices(data.get(\"prices\", {}))\n\n        ref_token = select_token_with_highest_normalize_priority(tokens)\n\n        return cls(\n            tokens,\n            orders,\n            uniswaps,\n            ref_token,\n            prices=prices,\n            metadata=metadata,\n            name=name,\n        )\n\n    ####################\n    #  ACCESS METHODS  #\n    ####################\n\n    @property\n    def tokens(self) -> list[Token]:\n        \"\"\"Access to (sorted) token list.\"\"\"\n        return sorted(self._tokens.keys())\n\n    @property\n    def orders(self) -> list[Order]:\n        \"\"\"Access to order list.\"\"\"\n        return list(self._orders.values())\n\n    @property\n    def uniswaps(self) -> list[Uniswap]:\n        \"\"\"Access to uniswap list.\"\"\"\n        return list(self._uniswaps.values())\n\n    def token_info(self, token: Token) -> TokenInfo:\n        \"\"\"Get the token info for a specific token.\"\"\"\n        assert isinstance(token, Token)\n\n        if token not in self.tokens:\n            raise ValueError(f\"Token <{token}> not in batch auction!\")\n\n        return self._tokens[token]\n\n    @property\n    def chain(self) -> Chain:\n        \"\"\"Return the blockchain on which the BatchAuction happens.\"\"\"\n        if self.ref_token is None:\n            return Chain.UNKNOWN\n        ref = self.ref_token.value.lower()\n        if ref == \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\":\n            return Chain.MAINNET\n        if ref == \"0xe91d153e0b41518a2ce8dd3d7944fa863463a97d\":\n            return Chain.XDAI\n        return Chain.UNKNOWN\n\n    @property\n    def default_ref_token_price(self) -> Decimal:\n        \"\"\"Price of reference token if not given explicitly.\n\n        This price is chosen so that the price of one unit of\n        a token with d_t=18 decimals that costs one unit of the\n        reference token is p_t=10^18:\n\n        a_t * p_t * 10^d_t = a_r * p_r * 10^d_r\n\n        with:\n            a_t/a_r = 1\n            d_t = 18\n            p_t = 10^18\n\n        p_r = a_t/a_r * 10^18 * 10^18 / 10^d_r\n        <-> p_r = 10^(2 * 18 - d_r)\n        \"\"\"\n        return Decimal(10) ** (2 * 18 - self.token_info(self.ref_token).decimals)\n\n    def solve(self) -> None:\n        \"\"\"Solve Batch\"\"\"\n\n    #################################\n    #  SOLUTION PROCESSING METHODS  #\n    #################################\n\n    def __str__(self) -> str:\n        \"\"\"Print batch auction data.\n\n        Returns:\n            The string representation.\n\n        \"\"\"\n        output_str = \"BATCH AUCTION:\"\n\n        output_str += f\"\\n=== TOKENS ({len(self.tokens)}) ===\"\n        for token in self.tokens:\n            output_str += f\"\\n-- {token}\"\n\n        output_str += f\"\\n=== ORDERS ({len(self.orders)}) ===\"\n        for order in self.orders:\n            output_str += f\"\\n{order}\"\n\n        output_str += f\"\\n=== UNISWAPS ({len(self.uniswaps)}) ===\"\n        for uni in self.uniswaps:\n            output_str += f\"\\n{uni}\"\n\n        return output_str\n\n    def __repr__(self) -> str:\n        \"\"\"Print batch auction data.\"\"\"\n        return self.name\n\n\ndef load_metadata(metadata: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Store some basic metadata information.\"\"\"\n    metadata[\"scaling_factors\"] = {\n        Token(t): Decimal(f) for t, f in metadata.get(\"scaling_factors\", {}).items()\n    }\n\n    return metadata\n\n\ndef load_prices(\n    prices_serialized: dict[TokenSerializedType, NumericType]\n) -> dict[Token, Decimal]:\n    \"\"\"Load token price information as dict of Token -> Decimal.\"\"\"\n    if not isinstance(prices_serialized, dict):\n        raise ValueError(\n            f\"Prices must be given as dict, not {type(prices_serialized)}!\"\n        )\n    return {Token(t): Decimal(p) for t, p in prices_serialized.items()}\n\n\ndef load_orders(orders_serialized: OrdersSerializedType) -> dict[str, Order]:\n    \"\"\"Load dict of orders as order pool_id -> order data.\n\n    Args:\n        orders_serialized: dict of order_id -> order data dict.\n\n    Returns:\n        A list of Order objects.\n    \"\"\"\n    order_list = [\n        Order.from_dict(order_id, data) for order_id, data in orders_serialized.items()\n    ]\n    result: dict[str, Order] = {}\n    for order in order_list:\n        if order.order_id in result:\n            raise ValueError(f\"Order pool_id <{order.order_id}> already exists!\")\n        result[order.order_id] = order\n    return result\n\n\ndef load_amms(amms_serialized: UniswapsSerializedType) -> dict[str, Uniswap]:\n    \"\"\"Load list of AMMs.\n\n    NOTE: Currently, the code only supports Uniswap-style AMMs, i.e.,\n    constant-product pools with two tokens and equal weights.\n\n    Args:\n        amms_serialized: dict of pool_id -> AMM.\n\n    Returns:\n        A list of Uniswap objects.\n\n    \"\"\"\n    amm_list = []\n    for amm_id, amm_data in amms_serialized.items():\n        amm = Uniswap.from_dict(amm_id, amm_data)\n        if amm is not None:\n            amm_list.append(amm)\n\n    results: dict[str, Uniswap] = {}\n    for uni in amm_list:\n        if uni.pool_id in results:\n            raise ValueError(f\"Uniswap pool_id <{uni.pool_id}> already exists!\")\n        results[uni.pool_id] = uni\n\n    return results\n\n\ndef load_tokens(tokens_serialized: dict) -> TokenDict:\n    \"\"\"Store tokens as sorted dictionary from Token -> token info.\n\n    Args:\n        tokens_serialized: list or dict of tokens.\n\n    Returns:\n        A dict of Token -> token info.\n\n    \"\"\"\n    tokens_dict = {}\n    for token_str, token_info in sorted(tokens_serialized.items()):\n        token = Token(token_str)\n        if token_info is None:\n            token_info = {}\n        else:\n            for k, val in token_info.items():\n                if val is None:\n                    continue\n                try:\n                    # Convert to str first to avoid float-precision artifacts:\n                    # Decimal(0.1)   -> Decimal('0.10000000000000000555...')\n                    # Decimal('0.1') -> Decimal(0.1)\n                    val = Decimal(str(val))\n                except decimal.InvalidOperation:\n                    pass\n                token_info[k] = val\n        if token in tokens_dict:\n            logging.warning(f\"Token <{token}> already exists!\")\n        tokens_dict[token] = TokenInfo(token, **token_info)\n\n    return tokens_dict\n"}
{"type": "source_file", "path": "src/util/constants.py", "content": "\"\"\"Global constants.\"\"\"\n\nfrom decimal import Decimal\n\n\nclass Constants:\n    \"\"\"Configuration parameters for the solver.\"\"\"\n\n    # Precision of Decimal in strings (to be used as x.quantize(DECIMAL_STR_PREC)).\n    DECIMAL_STR_PREC = Decimal(\"1e-10\")\n\n    # Should an exception be raised when the solution violates the\n    # max sell amount constraint.\n    RAISE_ON_MAX_SELL_AMOUNT_VIOLATION = False\n\n    # Should an exception be raised when the solution violates the\n    # limit exchange rate constraint.\n    RAISE_ON_LIMIT_XRATE_VIOLATION = False\n"}
{"type": "source_file", "path": "src/models/solver_args.py", "content": "\"\"\"Argument parser for solve Request that combines query parameters with metadata\"\"\"\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom fastapi import Request\n\nfrom src.util.schema import MetadataModel\n\n\n@dataclass\nclass SolverArgs:\n    \"\"\"Parameters passed in POST URL\"\"\"\n\n    auction_id: Optional[str]\n    instance_name: str\n    time_limit: int\n    max_nr_exec_orders: int\n    use_internal_buffers: bool\n    use_external_prices: bool\n    environment: Optional[str]\n    gas_price: Optional[float]\n    native_token: Optional[str]\n\n    @classmethod\n    def from_request(cls, request: Request, meta: MetadataModel) -> SolverArgs:\n        \"\"\"Parses Request query params dict as struct\"\"\"\n        param_dict = request.query_params\n        return cls(\n            # Query Parameter Arguments\n            instance_name=param_dict.get(\"instance_name\", \"Not Provided\"),\n            time_limit=int(param_dict.get(\"time_limit\", 30)),\n            max_nr_exec_orders=int(param_dict.get(\"max_nr_exec_orders\", 100)),\n            use_internal_buffers=bool(param_dict.get(\"use_internal_buffers\", False)),\n            use_external_prices=bool(param_dict.get(\"use_external_prices\", False)),\n            # Meta Data Arguments\n            environment=meta.environment,\n            gas_price=meta.gas_price,\n            native_token=meta.native_token,\n            # Both: Prioritize query params over metadata.\n            auction_id=param_dict.get(\"auction_id\", meta.auction_id),\n        )\n"}
{"type": "source_file", "path": "src/models/uniswap.py", "content": "\"\"\"Representation of Uniswap pool.\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom decimal import Decimal\nfrom typing import Optional, Any, Union\n\nfrom src.models.exchange_rate import ExchangeRate as XRate\nfrom src.models.token import Token, TokenBalance\nfrom src.models.types import NumericType\nfrom src.util.enums import AMMKind\nfrom src.util.exec_plan_coords import ExecPlanCoords\nfrom src.util.numbers import decimal_to_str\n\nFeeType = Union[float, Decimal]\nUniswapSerializedType = dict[str, Any]\nUniswapsSerializedType = dict[str, UniswapSerializedType]\n\n\nclass Uniswap:\n    \"\"\"Representation of an Automated Market Maker.\n\n    An Uniswap pool is represented by two token balances.\n    \"\"\"\n\n    def __init__(\n        self,\n        pool_id: str,\n        balance1: TokenBalance,\n        balance2: TokenBalance,\n        fee: FeeType,\n        cost: Optional[TokenBalance] = None,\n        mandatory: bool = False,\n        kind: AMMKind = AMMKind.UNISWAP,\n        weight: float = 1,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            pool_id: Uniswap pool pool_id.\n            balance1: TokenBalance of first token.\n            balance2: TokenBalance of second token.\n            fee: Uniswap fee percentage.\n\n        Kwargs:\n            cost: Cost of using the Uniswap pool.\n            mandatory: Is pool usage mandatory when price moves, or not.\n        \"\"\"\n        # Consistency checks.\n        if balance1.token == balance2.token:\n            logging.error(\"Pool tokens cannot be equal!\")\n            raise ValueError\n\n        if not all(tb.is_positive() for tb in [balance1, balance2]):\n            message = f\"Uniswap <{pool_id}>: balance1={balance1} balance2={balance2}\"\n            logging.error(message)\n            raise ValueError(\"Both token balances must be positive!\")\n\n        # Store given pool pool_id.\n        self.pool_id = pool_id\n        self.balance1 = balance1\n        self.balance2 = balance2\n        self.fee = fee if isinstance(fee, Decimal) else Decimal(fee)\n        self.cost = cost\n        self.mandatory = mandatory\n        self.kind = kind\n        self.weight = weight\n\n        self._balance_update1: Optional[TokenBalance] = None\n        self._balance_update2: Optional[TokenBalance] = None\n        self.exec_plan_coords: Optional[ExecPlanCoords] = None\n\n    @classmethod\n    def from_dict(\n        cls, amm_id: str, amm_data: UniswapSerializedType\n    ) -> Optional[Uniswap]:\n        \"\"\"Construct AMM object from data dict.\n        NOTE: Currently, the code only supports Uniswap-style AMMs, i.e.,\n        constant-product pools with two tokens and equal weights.\n        Args:\n            amm_id: AMM pool_id.\n            amm_data: Dict of uniswap data.\n        Returns:\n            A Uniswap object.\n        \"\"\"\n        for attr in [\"kind\", \"reserves\", \"fee\"]:\n            if attr not in amm_data:\n                raise ValueError(f\"Missing field '{attr}' in amm <{amm_id}>!\")\n\n        kind = AMMKind(amm_data[\"kind\"])\n        reserves = amm_data.get(\"reserves\")\n        weight = 0.5\n\n        if kind == AMMKind.CONSTANT_PRODUCT:\n            # Parse UniswapV2/Sushiswap pools.\n            if not isinstance(reserves, dict):\n                raise ValueError(\n                    f\"AMM <{amm_id}>: 'reserves' must be a dict of Token -> amount!\"\n                )\n            if len(reserves) != 2:\n                message = (\n                    f\"AMM <{amm_id}>: \"\n                    f\"ConstantProduct AMMs are only supported with 2 tokens!\"\n                )\n                logging.warning(message)\n                return None\n            balance1, balance2 = [\n                TokenBalance(Decimal(b), Token(t)) for t, b in reserves.items()\n            ]\n\n        elif kind == AMMKind.WEIGHTED_PRODUCT:\n            # Parse Balancer weighted constant-product pools.\n            if not (\n                isinstance(reserves, dict)\n                and all(\n                    isinstance(reserve_info, dict) and key in reserve_info\n                    for reserve_info in reserves.values()\n                    for key in [\"balance\", \"weight\"]\n                )\n            ):\n                raise ValueError(\n                    f\"AMM <{amm_id}>: 'reserves' must be a dict \"\n                    f\"of Token -> {'balance': .., 'weight': ..}\"\n                )\n            if (\n                len(reserves) != 2\n                or len(set(b[\"weight\"] for b in reserves.values())) > 1\n            ):\n                logging.warning(\n                    f\"AMM <{amm_id}>: WeightedProduct AMMs are only supported \"\n                    \"with 2 tokens and equal weights!\"\n                )\n                return None\n\n            weight = list(reserves.values())[0][\"weight\"]\n            balance1, balance2 = [\n                TokenBalance(Decimal(b[\"balance\"]), Token(t))\n                for t, b in reserves.items()\n            ]\n\n        else:\n            logging.warning(\n                f\"AMM <{amm_id}>: type <{kind}> is currently not supported!\"\n            )\n            return None\n\n        if balance1 == 0 or balance2 == 0:\n            return None\n\n        return Uniswap(\n            pool_id=amm_id,\n            balance1=balance1,\n            balance2=balance2,\n            fee=Decimal(amm_data[\"fee\"]),\n            cost=TokenBalance.parse(amm_data.get(\"cost\"), allow_none=True),\n            kind=kind,\n            weight=weight,\n        )\n\n    def as_dict(self) -> dict:\n        \"\"\"Return AMM object as dictionary.\n\n        NOTE: Currently, the code only supports Uniswap-style AMMs, i.e.,\n        constant-product pools with two tokens and equal weights.\n\n        \"\"\"\n        token1 = str(self.token1)\n        token2 = str(self.token2)\n        balance1 = decimal_to_str(self.balance1.as_decimal())\n        balance2 = decimal_to_str(self.balance2.as_decimal())\n\n        reserves: Union[str, dict]\n        if self.kind == AMMKind.WEIGHTED_PRODUCT:\n            reserves = {\n                token1: {\"balance\": balance1, \"weight\": self.weight},\n                token2: {\"balance\": balance2, \"weight\": self.weight},\n            }\n        else:\n            reserves = {token1: balance1, token2: balance2}\n\n        cost = None\n        if self.cost is not None:\n            cost = {\n                \"token\": str(self.cost.token),\n                \"amount\": decimal_to_str(self.cost.as_decimal()),\n            }\n\n        execution = {}\n        if self.is_executed():\n            assert self.balance_update1 is not None and self.balance_update2 is not None\n            b1_update = self.balance_update1.as_decimal()\n            b2_update = self.balance_update2.as_decimal()\n            # One update has to be positive and the other negative.\n            assert (\n                b1_update * b2_update < 0\n            ), f\"Failed assertion, {b1_update} * {b2_update} < 0\"\n\n            # Determine buy- and sell-tokens and -amounts.\n            if b1_update > 0:\n                buy_token = self.token1\n                sell_token = self.token2\n                exec_buy_amount = b1_update\n                exec_sell_amount = -b2_update\n\n            else:\n                buy_token = self.token2\n                sell_token = self.token1\n                exec_buy_amount = b2_update\n                exec_sell_amount = -b1_update\n\n            if self.exec_plan_coords is None:\n                logging.warning(\n                    f\"AMM <{self.pool_id}>: \"\n                    f\"has balance updates with invalid execution plan\"\n                )\n                exec_plan = None\n            else:\n                exec_plan = self.exec_plan_coords.as_dict()\n\n            execution = {\n                \"sell_token\": str(sell_token),\n                \"buy_token\": str(buy_token),\n                \"exec_sell_amount\": decimal_to_str(exec_sell_amount),\n                \"exec_buy_amount\": decimal_to_str(exec_buy_amount),\n                \"exec_plan\": exec_plan,\n            }\n\n        return {\n            \"kind\": str(self.kind),\n            \"reserves\": reserves,\n            \"cost\": cost,\n            \"fee\": decimal_to_str(self.fee),\n            \"execution\": execution,\n        }\n\n    ####################\n    #  ACCESS METHODS  #\n    ####################\n\n    @property\n    def token1(self) -> Token:\n        \"\"\"Returns token1\"\"\"\n        return self.balance1.token\n\n    @property\n    def token2(self) -> Token:\n        \"\"\"Returns token2\"\"\"\n        return self.balance2.token\n\n    @property\n    def tokens(self) -> set[Token]:\n        \"\"\"Return the pool tokens.\"\"\"\n        return {self.balance1.token, self.balance2.token}\n\n    @property\n    def balance_update1(self) -> Optional[TokenBalance]:\n        \"\"\"Return the traded amount of the first token.\"\"\"\n        return self._balance_update1\n\n    @property\n    def balance_update2(self) -> Optional[TokenBalance]:\n        \"\"\"Return the traded amount of the second token.\"\"\"\n        return self._balance_update2\n\n    def other_token(self, token: Token) -> Token:\n        \"\"\"Returns the \"other\" token that is not token.\"\"\"\n        assert token in self.tokens\n        return (self.tokens - {token}).pop()\n\n    #####################\n    #  UTILITY METHODS  #\n    #####################\n\n    def execute(\n        self,\n        b1_update: NumericType,\n        b2_update: NumericType,\n    ) -> None:\n        \"\"\"Execute the uniswap at given amounts.\n\n        Args:\n            b1_update: Traded amount of token1.\n            b2_update: Traded amount of token2.\n        \"\"\"\n        assert isinstance(b1_update, (int, float, Decimal))\n        assert isinstance(b2_update, (int, float, Decimal))\n\n        # Store execution information.\n        self._balance_update1 = TokenBalance(b1_update, self.token1)\n        self._balance_update2 = TokenBalance(b2_update, self.token2)\n\n    def is_executed(self) -> bool:\n        \"\"\"True if amm is executed otherwise false\"\"\"\n        return self.balance_update1 is not None and self.balance_update2 is not None\n\n    def get_marginal_xrate(self) -> XRate:\n        \"\"\"Derive the marginal exchange rate from the pool balances.\"\"\"\n        return XRate(self.balance1, self.balance2)\n\n    def __str__(self) -> str:\n        \"\"\"Represent as string.\"\"\"\n        return json.dumps(self.as_dict(), indent=2)\n\n    def __repr__(self) -> str:\n        \"\"\"Represent as short string.\"\"\"\n        return f\"u{self.pool_id}\"\n\n    def __hash__(self) -> int:\n        return hash(self.pool_id)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Uniswap):\n            return NotImplemented\n        if self.pool_id != other.pool_id:\n            return False\n        return True\n\n    def __lt__(self, other: object) -> bool:\n        if not isinstance(other, Uniswap):\n            return NotImplemented\n        return self.pool_id < other.pool_id\n"}
{"type": "source_file", "path": "src/util/enums.py", "content": "\"\"\"Location of all Enum types\"\"\"\n\nfrom enum import Enum\n\n\nclass AMMKind(Enum):\n    \"\"\"Enum for different AMM kinds.\"\"\"\n\n    UNISWAP = \"Uniswap\"\n    CONSTANT_PRODUCT = \"ConstantProduct\"\n    WEIGHTED_PRODUCT = \"WeightedProduct\"\n    STABLE = \"Stable\"\n    CONCENTRATED = \"Concentrated\"\n\n    def __str__(self) -> str:\n        \"\"\"Represent as string.\"\"\"\n        return self.value\n\n    def __repr__(self) -> str:\n        \"\"\"Represent as string.\"\"\"\n        return str(self)\n\n\nclass Chain(Enum):\n    \"\"\"Enum for the blockchain of the batch auction.\"\"\"\n\n    MAINNET = \"MAINNET\"\n    XDAI = \"XDAI\"\n    UNKNOWN = \"UNKNOWN\"\n\n    def __str__(self) -> str:\n        \"\"\"Represent as string.\"\"\"\n        return self.name\n\n    def __repr__(self) -> str:\n        \"\"\"Represent as string.\"\"\"\n        return str(self)\n"}
{"type": "source_file", "path": "src/models/token.py", "content": "\"\"\"A class for extendable token enum's.\"\"\"\nfrom __future__ import annotations\n\nimport re\nfrom decimal import Decimal, getcontext\nfrom typing import Optional, Union\n\nfrom src.models.types import NumericType\nfrom src.util.constants import Constants\n\n\nclass Token:\n    \"\"\"Enumeration over available tokens.\"\"\"\n\n    def __init__(self, value: str):\n        if Token._is_valid(value):\n            self.value = value\n        else:\n            raise ValueError(f\"Invalid Ethereum Address {value}\")\n\n    @staticmethod\n    def _is_valid(address: str) -> bool:\n        match_result = re.match(\n            pattern=r\"^(0x)?[0-9a-f]{40}$\", string=address, flags=re.IGNORECASE\n        )\n        return match_result is not None\n\n    def __str__(self) -> str:\n        \"\"\"Convert to string.\"\"\"\n        return self.value\n\n    def __repr__(self) -> str:\n        \"\"\"Convert to string.\"\"\"\n        return self.__str__()\n\n    def __hash__(self) -> int:\n        \"\"\"Hash of token.\"\"\"\n        return hash(self.value)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Equality operator.\"\"\"\n        if isinstance(other, Token):\n            return self.value == other.value\n        return False\n\n    def __lt__(self, other: object) -> bool:\n        \"\"\"Less-than operator.\"\"\"\n        if isinstance(other, Token):\n            return self.value < other.value\n        return NotImplemented\n\n\nclass TokenInfo:\n    \"\"\"Class for storing token information.\"\"\"\n\n    def __init__(\n        self,\n        token: Token,\n        decimals: int,\n        alias: Optional[str] = None,\n        external_price: Optional[Decimal] = None,\n        estimated_price: Optional[Decimal] = None,\n        internal_buffer: Optional[Decimal] = None,\n        normalize_priority: Optional[int] = 0,\n    ):\n        \"\"\"Constructor.\"\"\"\n        self.token = token\n        self.alias = alias\n        self.decimals = decimals\n        self.external_price = external_price\n        self.estimated_price = estimated_price\n        self.internal_buffer = internal_buffer\n        self._normalize_priority = normalize_priority or 0\n\n    @property\n    def normalize_priority(self) -> int:\n        \"\"\"\n        Return the token priority for normalization purposes.\n\n        Higher value means higher priority.\n        \"\"\"\n        return self._normalize_priority\n\n    def as_dict(self) -> dict:\n        \"\"\"Convert to dict.\"\"\"\n        attr = [\n            a\n            for a in dir(self)\n            if not callable(getattr(self, a)) and not a.startswith(\"_\") and a != \"token\"\n        ]\n\n        return {a: getattr(self, a) for a in sorted(attr)}\n\n    def __str__(self) -> str:\n        \"\"\"Convert to string.\"\"\"\n        token_info_dict = self.as_dict()\n\n        _str = f\"Token [{self.token}]:\"\n        for attr, value in token_info_dict.items():\n            if isinstance(value, Decimal) and attr not in [\n                \"external_price\",\n                \"internal_buffer\",\n            ]:\n                value = value.quantize(Constants.DECIMAL_STR_PREC)\n            _str += f\"\\n-- {attr} : {value}\"\n\n        return _str\n\n\ndef select_token_with_highest_normalize_priority(\n    tokens: dict[Token, TokenInfo]\n) -> Token:\n    \"\"\"\n    Select token with highest normalize priority from the list of tokens.\n\n    If the highest normalize_priority is shared by multiple tokens, the\n    ref_token is the first lexicographically.\n    \"\"\"\n    max_priority = max(t.normalize_priority for t in tokens.values())\n    highest_priority_tokens = [\n        t for t, info in tokens.items() if info.normalize_priority == max_priority\n    ]\n    return highest_priority_tokens[0]\n\n\nTokenDict = dict[Token, TokenInfo]\nTokenSerializedType = str\nTokenAmountSerializedType = tuple[Union[str, NumericType], TokenSerializedType]\n\n\nclass TokenBalance:\n    \"\"\"Class to represent an amount of some token.\"\"\"\n\n    def __init__(self, balance: NumericType, token: Token):\n        \"\"\"Initialize.\n\n        Args:\n            balance: Amount of tokens.\n            token: Token.\n        \"\"\"\n\n        self._balance = Decimal(balance)\n        self.balance = balance\n        self.token = token\n\n        if not self._balance.is_finite():\n            raise ValueError(f\"Token balance must be finite, not {self._balance}!\")\n\n    @classmethod\n    def parse(\n        cls,\n        token_amount_serialized: Optional[TokenAmountSerializedType],\n        allow_negative: bool = False,\n        allow_none: bool = False,\n    ) -> Optional[TokenBalance]:\n        \"\"\"\n        Method to parse a token amount given as (amount, token) into a TokenBalance.\n        \"\"\"\n        if token_amount_serialized is None:\n            if not allow_none:\n                raise ValueError(\"Token amount must not be None!\")\n            token_amount = None\n        else:\n            if not isinstance(token_amount_serialized, dict) or set(\n                token_amount_serialized.keys()\n            ) != {\"amount\", \"token\"}:\n                raise ValueError(\n                    \"token amount must be given as dict of {'amount': .., 'token': ..},\"\n                    f\" not <{token_amount_serialized}>!\"\n                )\n            token_amount = cls(\n                Decimal(token_amount_serialized[\"amount\"]),\n                Token(token_amount_serialized[\"token\"]),\n            )\n            if not allow_negative and token_amount.is_negative():\n                raise ValueError(f\"Token amount must be non-negative ({token_amount})!\")\n        return token_amount\n\n    @classmethod\n    def parse_amount(\n        cls, amt_type: Optional[Amount], token: Token\n    ) -> Optional[TokenBalance]:\n        \"\"\"Auxiliary method to parse a numerical value into a TokenBalance.\n\n        Args:\n            amt_type: Amount to be set, or None.\n            token: Token belonging to amount.\n\n        Returns:\n            A TokenBalance, or None.\n\n        \"\"\"\n\n        if isinstance(amt_type, (int, float, Decimal)):\n            return cls(amt_type, token)\n\n        if isinstance(amt_type, TokenBalance):\n            if amt_type.token != token:\n                raise ValueError(\n                    f\"Tokens do not match: <{amt_type.token}> vs. <{token}>!\"\n                )\n            return amt_type\n\n        return None\n\n    def as_decimal(self) -> Decimal:\n        \"\"\"Returns balance attribute as Decimal type\"\"\"\n        return self._balance\n\n    @staticmethod\n    def precision() -> int:\n        \"\"\"Return precision currently associated with TokenBalance.\"\"\"\n        return getcontext().prec\n\n    def is_positive(self) -> bool:\n        \"\"\"Determine if a TokenBalance is positive.\"\"\"\n        return self._balance > 0\n\n    def is_negative(self) -> bool:\n        \"\"\"Determine if a TokenBalance is negative.\"\"\"\n        return self._balance < 0\n\n    def is_zero(self) -> bool:\n        \"\"\"Determine if a TokenBalance is zero.\"\"\"\n        return self._balance == 0\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Equality operator.\n\n        Args:\n            other: Another TokenBalance, or zero.\n        \"\"\"\n        if other == 0:\n            return self.is_zero()\n\n        if isinstance(other, TokenBalance):\n\n            if self.token != other.token:\n                raise ValueError(\n                    f\"Cannot compare different tokens <{self.token}> / <{other.token}>!\"\n                )\n            return self._balance == other._balance\n\n        raise ValueError(f\"Cannot compare TokenBalance and type <{type(other)}>!\")\n\n    def __ne__(self, other: object) -> bool:\n        \"\"\"Non-equality operator\"\"\"\n        return not self == other\n\n    def __lt__(self, other: Union[TokenBalance, NumericType]) -> bool:\n        \"\"\"Less-than operator.\n\n        Args:\n            other: Another TokenBalance, or zero.\n        \"\"\"\n        if isinstance(other, TokenBalance):\n\n            if self.token != other.token:\n                raise ValueError(\n                    f\"Cannot compare different tokens <{self.token}> / <{other.token}>!\"\n                )\n            return self._balance < other._balance\n\n        if other == 0:\n            return self._balance < 0\n\n        raise ValueError(f\"Cannot compare TokenBalance and type <{type(other)}>\")\n\n    def __le__(self, other: Union[TokenBalance, NumericType]) -> bool:\n        \"\"\"Less-than-or-equal operator.\n\n        Args:\n            other: Another TokenBalance, or zero.\n        \"\"\"\n        return self < other or self == other\n\n    def __gt__(self, other: Union[TokenBalance, NumericType]) -> bool:\n        \"\"\"Greater-than operator.\n\n        Args:\n            other: Another TokenBalance, or zero.\n        \"\"\"\n        return not self <= other\n\n    def __ge__(self, other: Union[TokenBalance, NumericType]) -> bool:\n        \"\"\"Greater-than-or-equal operator.\n\n        Args:\n            other: Another TokenBalance, or zero.\n        \"\"\"\n        return self > other or self == other\n\n    def __neg__(self) -> TokenBalance:\n        \"\"\"Negation operator.\"\"\"\n        return TokenBalance(-self._balance, self.token)\n\n    def __abs__(self) -> TokenBalance:\n        \"\"\"Absolute value operator.\"\"\"\n        return TokenBalance(abs(self._balance), self.token)\n\n    def __add__(self, other: Union[TokenBalance, NumericType]) -> TokenBalance:\n        \"\"\"Addition operator.\n\n        Args:\n            other: Another TokenBalance, or zero.\n        \"\"\"\n        if isinstance(other, TokenBalance):\n\n            if self.token == other.token:\n                return TokenBalance(self._balance + other._balance, self.token)\n\n            raise ValueError(f\"Cannot add <{other.token}> and <{self.token}>!\")\n\n        if other == 0:\n            # This is required to enable the use of the sum() function:\n            # sum() by design starts with a value of '0' and then iteratively\n            # adds the items in the list that is passed as argument. See:\n            # https://stackoverflow.com/questions/1218710/pythons-sum-and-non-integer-values\n            return self\n\n        raise ValueError(f\"Cannot add <{type(other)}> and TokenBalance!\")\n\n    def __radd__(self, other: Union[TokenBalance, NumericType]) -> TokenBalance:\n        \"\"\"Addition-from-right operator.\n\n        Args:\n            other: Another TokenBalance, or zero.\n        \"\"\"\n        return self + other\n\n    def __sub__(self, other: Union[TokenBalance, NumericType]) -> TokenBalance:\n        \"\"\"Subtraction operator.\n\n        Args:\n            other: Another TokenBalance, or zero.\n        \"\"\"\n        return self + (-other)\n\n    def __rsub__(self, other: Union[TokenBalance, NumericType]) -> TokenBalance:\n        \"\"\"Subtraction operator.\n\n        Args:\n            other: Another TokenBalance, or zero.\n        \"\"\"\n        return other + (-self)\n\n    def __mul__(self, other: NumericType) -> TokenBalance:\n        \"\"\"Multiplication operator.\n\n        Args:\n            other: A {float|int|Decimal}.\n        \"\"\"\n        if isinstance(other, (int, float, Decimal)):\n            return TokenBalance(Decimal(other) * self._balance, self.token)\n\n        raise ValueError(f\"Cannot multiply TokenBalance by <{type(other)}>!\")\n\n    def __rmul__(self, other: NumericType) -> TokenBalance:\n        \"\"\"Multiplication-from-right operator.\n\n        Args:\n            other: A {float|int|Decimal}.\n        \"\"\"\n        return self * other\n\n    def __truediv__(self, other: Union[TokenBalance, NumericType]) -> TokenBalance:\n        \"\"\"Division operator.\n\n        Args:\n            other: A {TokenBalance|float|int|Decimal}.\n        \"\"\"\n        if isinstance(other, (int, float, Decimal)):\n            if other == 0:\n                raise ZeroDivisionError\n            return TokenBalance(self._balance / Decimal(other), self.token)\n\n        if isinstance(other, TokenBalance):\n            if self.token == other.token:\n                return TokenBalance(self._balance / other._balance, self.token)\n            raise ValueError(\n                f\"Can't divide TokenBalances with different \"\n                f\"tokens <{self.token}> and <{other.token}>!\"\n            )\n\n        raise ValueError(f\"Cannot divide TokenBalance by <{type(other)}>!\")\n\n    def __rtruediv__(self, other: object) -> None:\n        \"\"\"Division-from-right operator.\n\n        Args:\n            other: Something.\n        \"\"\"\n        raise ValueError(f\"<{type(other)}> cannot be divided by TokenBalance!\")\n\n    def __str__(self) -> str:\n        \"\"\"Represent as string (rounded to 5 decimals).\"\"\"\n        return f\"{self.token}: {self.balance}\"\n\n    def __repr__(self) -> str:\n        \"\"\"Represent as string.\"\"\"\n        return str(self)\n\n\nAmount = Union[TokenBalance, NumericType]\n"}
{"type": "source_file", "path": "src/util/__init__.py", "content": ""}
{"type": "source_file", "path": "src/util/schema.py", "content": "\"\"\"\nThis file defines problem, solution, and solver parameters schemas,\nusing pydantic that is then used to validate IO and autogenerate\ndocumentation.\n\"\"\"\n\nfrom typing import Dict, List, Optional, Union\n\nfrom enum import Enum\nfrom pydantic import BaseModel, Field\n\n# Example instance to use in the autogenerated API documentation.\n\nexample_instance = {\n    \"metadata\": {\n        \"environment\": \"xDAI\",\n        \"auction_id\": 1,\n        \"gas_price\": 4850000000.0,\n        \"native_token\": \"0xe91d153e0b41518a2ce8dd3d7944fa863463a97d\",\n    },\n    \"tokens\": {\n        \"0x6b175474e89094c44da98b954eedeac495271d0f\": {\n            \"decimals\": 18,\n            \"alias\": \"DAI\",\n            \"external_price\": 0.00021508661247926934,\n            \"normalize_priority\": 0,\n            \"internal_buffer\": \"8213967696976545926330\",\n        },\n        \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\": {\n            \"decimals\": 6,\n            \"alias\": \"USDC\",\n            \"external_price\": 214890212.34875953,\n            \"normalize_priority\": 0,\n            \"internal_buffer\": \"2217249148\",\n        },\n        \"0xdac17f958d2ee523a2206206994597c13d831ec7\": {\n            \"decimals\": 6,\n            \"alias\": \"USDT\",\n            \"external_price\": 214523029.31427807,\n            \"normalize_priority\": 0,\n            \"internal_buffer\": \"4227015605\",\n        },\n        \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\": {\n            \"decimals\": 18,\n            \"alias\": \"WETH\",\n            \"external_price\": 1.0,\n            \"normalize_priority\": 1,\n            \"internal_buffer\": \"895880027660372311\",\n        },\n    },\n    \"orders\": {\n        \"0\": {\n            \"sell_token\": \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n            \"buy_token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"sell_amount\": \"4693994755140375611596\",\n            \"buy_amount\": \"1000000000000000000\",\n            \"allow_partial_fill\": False,\n            \"is_sell_order\": False,\n            \"fee\": {\n                \"amount\": \"103079335446226157568\",\n                \"token\": \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n            },\n            \"cost\": {\n                \"amount\": \"6657722265694875\",\n                \"token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            },\n            \"is_liquidity_order\": False,\n        },\n        \"1\": {\n            \"sell_token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"buy_token\": \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n            \"sell_amount\": \"1000000000000000000\",\n            \"buy_amount\": \"4692581049969374626065\",\n            \"allow_partial_fill\": False,\n            \"is_sell_order\": True,\n            \"fee\": {\n                \"amount\": \"23212472598551576\",\n                \"token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            },\n            \"cost\": {\n                \"amount\": \"6657722265694875\",\n                \"token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            },\n            \"is_liquidity_order\": True,\n        },\n    },\n    \"amms\": {\n        \"01\": {\n            \"kind\": \"ConstantProduct\",\n            \"reserves\": {\n                \"0x6b175474e89094c44da98b954eedeac495271d0f\": \"44897630044876228891318837\",\n                \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\": \"9626911517235794223708\",\n            },\n            \"fee\": \"0.003\",\n            \"cost\": {\n                \"amount\": \"9507044675748200\",\n                \"token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            },\n            \"mandatory\": False,\n        },\n        \"02\": {\n            \"kind\": \"ConstantProduct\",\n            \"reserves\": {\n                \"0x6b175474e89094c44da98b954eedeac495271d0f\": \"84903768350604287941150958\",\n                \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\": \"18233677073990818080605\",\n            },\n            \"fee\": \"0.003\",\n            \"cost\": {\n                \"amount\": \"9507044675748200\",\n                \"token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            },\n            \"mandatory\": False,\n        },\n        \"03\": {\n            \"kind\": \"WeightedProduct\",\n            \"reserves\": {\n                \"0x6b175474e89094c44da98b954eedeac495271d0f\": {\n                    \"balance\": \"1191959749018354276837\",\n                    \"weight\": \"0.4\",\n                },\n                \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\": {\n                    \"balance\": \"392171457910841840\",\n                    \"weight\": \"0.6\",\n                },\n            },\n            \"fee\": \"0.0025\",\n            \"cost\": {\n                \"amount\": \"12047450379000000\",\n                \"token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            },\n            \"mandatory\": False,\n        },\n        \"04\": {\n            \"kind\": \"WeightedProduct\",\n            \"reserves\": {\n                \"0x6810e776880c02933d47db1b9fc05908e5386b96\": {\n                    \"balance\": \"21330539255670269346\",\n                    \"weight\": \"0.25\",\n                },\n                \"0x6b175474e89094c44da98b954eedeac495271d0f\": {\n                    \"balance\": \"10928595376682871418747\",\n                    \"weight\": \"0.25\",\n                },\n                \"0xba100000625a3754423978a60c9317c58a424e3d\": {\n                    \"balance\": \"444658133648670940819\",\n                    \"weight\": \"0.25\",\n                },\n                \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\": {\n                    \"balance\": \"2237408990689298635\",\n                    \"weight\": \"0.25\",\n                },\n            },\n            \"fee\": \"0.01\",\n            \"cost\": {\n                \"amount\": \"12047450379000000\",\n                \"token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            },\n            \"mandatory\": False,\n        },\n    },\n}\n\n\n# The following classes model the contents of a PROBLEM instance.\n# They are used for input validation and documentation.\n\n\nclass TokenId(str):\n    \"\"\"Token unique identifier.\"\"\"\n\n\nclass OrderId(str):\n    \"\"\"Order unique identifier.\"\"\"\n\n\nclass AmmId(str):\n    \"\"\"AMM unique identifier.\"\"\"\n\n\nclass BigInt(str):\n    \"\"\"Big integer (as a string).\"\"\"\n\n\nclass Decimal(str):\n    \"\"\"Decimal number (as a string).\"\"\"\n\n\nclass TokenInfoModel(BaseModel):\n    \"\"\"Token-specific data.\"\"\"\n\n    decimals: Optional[int] = Field(None, description=\"Number of decimals.\")\n    alias: Optional[str] = Field(None, description=\"Human-readable name (e.g. DAI).\")\n    normalize_priority: Optional[int] = Field(\n        0,\n        description=\"Priority for solution price vector normalization purposes \"\n        \"(larger=higher preference).\",\n    )\n    external_price: Optional[Decimal] = Field(None, description=\"External token price.\")\n    internal_buffer: Optional[BigInt] = Field(\n        None, description=\"Internal token buffer.\"\n    )\n\n\nclass TokenAmountModel(BaseModel):\n    \"\"\"Order/AMM cost and order fee.\"\"\"\n\n    amount: BigInt = Field(..., description=\"Amount.\")\n    token: TokenId = Field(..., description=\"Token.\")\n\n\nclass OrderModel(BaseModel):\n    \"\"\"Order data.\"\"\"\n\n    sell_token: TokenId = Field(..., description=\"Token to be sold.\")\n    buy_token: TokenId = Field(..., description=\"Token to be bought.\")\n    sell_amount: BigInt = Field(\n        ...,\n        description=\"If is_sell_order=true indicates the maximum amount to sell, \"\n        \"otherwise the maximum amount to sell in order to buy buy_amount.\",\n    )\n    buy_amount: BigInt = Field(\n        ...,\n        description=\"If is_sell_order=false indicates the maximum amount to buy, \"\n        \"otherwise the minimum amount to buy in order to sell sell_amount.\",\n    )\n    allow_partial_fill: bool = Field(\n        ...,\n        description=\"If the order can sell/buy less than its maximum sell/buy amount.\",\n    )\n    is_sell_order: bool = Field(\n        ...,\n        description=\"If it is a sell or buy order, changing the semantics of \"\n        \"sell_amount/buy_amount accordingly.\",\n    )\n    is_liquidity_order: Optional[bool] = Field(\n        False,\n        description=\"Liquidity orders (from market makers) can not receive surplus.\",\n    )\n    has_atomic_execution: Optional[bool] = Field(\n        False, description=\"Indicates, if the order needs to be executed atomically.\"\n    )\n    fee: Optional[TokenAmountModel] = Field(\n        None,\n        description=\"Fee contribution when order is matched \"\n        \"(pro-rata for partial matching).\",\n    )\n    cost: Optional[TokenAmountModel] = Field(\n        None, description=\"Cost of matching the order.\"\n    )\n\n    class Config:\n        \"\"\"Includes example in generated openapi file\"\"\"\n\n        schema_extra = {\n            \"example\": {\n                \"sell_token\": \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n                \"buy_token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n                \"sell_amount\": \"4693994755140375611596\",\n                \"buy_amount\": \"1000000000000000000\",\n                \"allow_partial_fill\": False,\n                \"is_sell_order\": False,\n                \"fee\": {\n                    \"amount\": \"103079335446226157568\",\n                    \"token\": \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n                },\n                \"cost\": {\n                    \"amount\": \"6657722265694875\",\n                    \"token\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n                },\n                \"is_liquidity_order\": False,\n            }\n        }\n\n\nclass AmmKindEnum(str, Enum):\n    \"\"\"AMM kind.\"\"\"\n\n    CONSTANT_PRODUCT = \"ConstantProduct\"\n    WEIGHTED_PRODUCT = \"WeightedProduct\"\n    STABLE = \"Stable\"\n    CONCENTRATED = \"Concentrated\"\n\n\nclass ConstantProductReservesModel(BigInt):\n    \"\"\"Tokens and balances of constant-product AMMs.\"\"\"\n\n\nclass WeightedProductReservesModel(BaseModel):\n    \"\"\"Tokens and balances+weights of weighted-product AMMs.\"\"\"\n\n    balance: BigInt = Field(..., description=\"Token balance in AMM.\")\n    weight: BigInt = Field(..., description=\"Weight of the token.\")\n\n\nclass AmmModel(BaseModel):\n    \"\"\"AMM data.\"\"\"\n\n    kind: AmmKindEnum = Field(..., description=\"AMM type.\")\n    reserves: Optional[\n        Dict[TokenId, Union[ConstantProductReservesModel, WeightedProductReservesModel]]\n    ] = Field(None, description=\"AMM tokens and balances.\")\n    fee: Optional[Decimal] = Field(\n        None, description=\"AMM trading fee (e.g. 0.003 for 0.3% fee).\"\n    )\n    cost: Optional[TokenAmountModel] = Field(\n        None, description=\"Cost of using the pool.\"\n    )\n\n\nclass MetadataModel(BaseModel):\n    \"\"\"Batch auction metadata.\"\"\"\n\n    environment: Optional[str] = Field(\n        None, description=\"Runtime/blockchain environment.\"\n    )\n    auction_id: Optional[str] = Field(..., description=\"Max Number of executed orders\")\n    gas_price: Optional[float] = Field(..., description=\"Current Gas price\")\n    native_token: Optional[TokenId] = Field(..., description=\"Wrapped Native Token\")\n\n\nclass BatchAuctionModel(BaseModel):\n    \"\"\"Batch auction instance data.\"\"\"\n\n    tokens: Dict[TokenId, TokenInfoModel] = Field(..., description=\"Tokens.\")\n    orders: Dict[OrderId, OrderModel] = Field(..., description=\"Orders.\")\n    metadata: MetadataModel = Field({}, description=\"Metadata.\")\n    amms: Optional[Dict[AmmId, AmmModel]] = Field({}, description=\"AMMs\")\n\n    class Config:\n        \"\"\"Includes example in generated openapi file\"\"\"\n\n        schema_extra = {\"example\": example_instance}\n\n\n# The following classes model the contents of a SOLUTION instance.\n# They are used for input validation and documentation.\n\n\nclass ExecutedOrderModel(OrderModel):\n    \"\"\"Executed order data (solution).\"\"\"\n\n    exec_buy_amount: BigInt = Field(..., description=\"Executed buy amount.\")\n    exec_sell_amount: BigInt = Field(..., description=\"Executed sell amount.\")\n\n\nclass ExecPlanCoordsModel(BaseModel):\n    \"\"\"Execution plan coordinates.\"\"\"\n\n    sequence: int = Field(..., description=\"Sequence index.\")\n    position: int = Field(..., description=\"Position within the sequence.\")\n    internal: Optional[bool] = Field(False, description=\"Using internal liquidity\")\n\n\nclass AmmExecutionModel(BaseModel):\n    \"\"\"AMM settlement information.\"\"\"\n\n    sell_token: TokenId = Field(..., description=\"Token sold by the AMM.\")\n    buy_token: TokenId = Field(..., description=\"Token bought by the AMM.\")\n    exec_sell_amount: BigInt = Field(..., description=\"Executed sell amount.\")\n    exec_buy_amount: BigInt = Field(..., description=\"Executed buy amount.\")\n    exec_plan: Optional[ExecPlanCoordsModel] = Field(\n        None, description=\"Execution plan coordinates.\"\n    )\n\n\nclass ExecutedAmmModel(AmmModel):\n    \"\"\"List of AMM executions.\"\"\"\n\n    execution: Optional[List[AmmExecutionModel]] = Field(\n        None, description=\"AMM settlement data.\"\n    )\n\n\nclass InteractionData(BaseModel):\n    \"\"\"Interaction data.\"\"\"\n\n    target: TokenId = Field(\n        ..., description=\"Target contract address to interact with.\"\n    )\n    value: BigInt = Field(\n        ..., description=\"Value of native token, e.g. amount eth in eth transfer\"\n    )\n    call_data: bytes = Field(..., description=\"Interaction encoding.\")\n\n\nclass SettledBatchAuctionModel(BaseModel):\n    \"\"\"Settled batch auction data (solution).\"\"\"\n\n    orders: Dict[OrderId, ExecutedOrderModel] = Field(\n        ..., description=\"Executed orders.\"\n    )\n    prices: Dict[TokenId, BigInt] = Field(\n        ..., description=\"Settled price for each token.\"\n    )\n    amms: Dict[AmmId, ExecutedAmmModel] = Field(..., description=\"Executed AMMs.\")\n\n    interaction_data: List[InteractionData] = Field(\n        description=\"List of interaction data.\", default=[]\n    )\n"}
{"type": "source_file", "path": "src/util/exec_plan_coords.py", "content": "\"\"\"Execution Plan Coordinates\"\"\"\n\n\nclass ExecPlanCoords:\n    \"\"\"The position coordinates of the uniswap in the execution plan.\n\n    The position is defined by a pair of integers:\n        * Id of the sequence.\n        * Position within that sequence.\n    \"\"\"\n\n    def __init__(self, sequence: int, position: int):\n        self.sequence = sequence\n        self.position = position\n\n    def as_dict(self) -> dict[str, str]:\n        \"\"\"returns string dict of class\"\"\"\n        return {\n            \"sequence\": str(self.sequence),\n            \"position\": str(self.position),\n        }\n"}
{"type": "source_file", "path": "src/util/numbers.py", "content": "\"\"\"Utility methods for number handling\"\"\"\nfrom decimal import Decimal\n\n\ndef decimal_to_str(number: Decimal) -> str:\n    \"\"\"Converts Decimal to string\"\"\"\n    try:\n        return f\"{round(float(number), 12):.12f}\".rstrip(\"0\").rstrip(\".\")\n    except ValueError as err:\n        raise ValueError(f\"Could not convert <{number}> into a string!\") from err\n"}
{"type": "source_file", "path": "src/models/types.py", "content": "\"\"\"Generic Type derived from primitives and imports\"\"\"\nfrom decimal import Decimal\nfrom typing import Union\n\nNumericType = Union[int, float, Decimal]\n"}

{"repo_info": {"repo_name": "Python", "repo_owner": "geekcomputers", "repo_url": "https://github.com/geekcomputers/Python"}}
{"type": "test_file", "path": "Industrial_developed_hangman/tests/test_hangman/__init__.py", "content": ""}
{"type": "test_file", "path": "Search_Engine/test_data.py", "content": "documents = [\n    \"we should all strive to be happy\",\n    \"happiness is all you need\",\n    \"a cheerful heart is a happy one\",\n    \"no way should we be sad\"\n]\n\nsearch = \"happy\""}
{"type": "test_file", "path": "Industrial_developed_hangman/tests/test_hangman/test_main.py", "content": "import os\nfrom pathlib import Path\nfrom typing import Callable, List\n\nimport pytest\nimport requests_mock\n\nfrom src.hangman.main import (\n    MainProcess,\n    Source,\n    parse_word_from_local,\n    parse_word_from_site,\n)\n\n\nclass FkPrint(object):\n    def __init__(self) -> None:\n        self.container: List[str] = []\n\n    def __call__(self, value_to_print: str) -> None:\n        self.container.append(str(value_to_print))\n\n\nclass FkInput(object):\n    def __init__(self, values_to_input: List[str]) -> None:\n        self.values_to_input: List[str] = values_to_input\n\n    def __call__(self) -> str:\n        return self.values_to_input.pop(0)\n\n\n@pytest.fixture\ndef choice_fn() -> Callable:\n    return lambda array: array[0]  # noqa: E731\n\n\ndef test_parse_word_from_local() -> None:\n    assert isinstance(parse_word_from_local(), str)\n\n\ndef test_parse_word_from_local_error() -> None:\n    data_path = Path(os.path.abspath('')) / 'Data'\n    real_name = 'local_words.txt'\n    time_name = 'local_words_not_exist.txt'\n\n    os.rename(data_path / real_name, data_path / time_name)\n    with pytest.raises(FileNotFoundError):\n        parse_word_from_local()\n    os.rename(data_path / time_name, data_path / real_name)\n\n\n@pytest.mark.internet_required\ndef test_parse_word_from_site() -> None:\n    assert isinstance(parse_word_from_site(), str)\n\n\ndef test_parse_word_from_site_no_internet() -> None:\n    with requests_mock.Mocker() as mock:\n        mock.get('https://random-word-api.herokuapp.com/word', text='[\"some text\"]')\n        assert parse_word_from_site() == 'some text'\n\n\ndef test_parse_word_from_site_err() -> None:\n    with pytest.raises(RuntimeError):\n        parse_word_from_site(url='https://www.google.com/dsfsdfds/sdfsdf/sdfds')\n\n\ndef test_get_word(choice_fn: Callable) -> None:\n    fk_print = FkPrint()\n    fk_input = FkInput(['none'])\n    main_process = MainProcess(Source(1), pr_func=fk_print, in_func=fk_input, ch_func=choice_fn)\n\n    assert isinstance(main_process.get_word(), str)\n\n\ndef test_start_game_win(choice_fn: Callable) -> None:\n    fk_print = FkPrint()\n    fk_input = FkInput(['j', 'a', 'm'])\n    main_process = MainProcess(Source(0), pr_func=fk_print, in_func=fk_input, ch_func=choice_fn)\n\n    main_process.start_game()\n\n    assert 'YOU WON' in fk_print.container[-1]\n\n\n@pytest.mark.parametrize('input_str', [[letter] * 10 for letter in 'qwertyuiopasdfghjklzxcvbnm'])  # noqa: WPS435\ndef test_start_game_loose(input_str: List[str], choice_fn: Callable) -> None:\n    fk_print = FkPrint()\n    fk_input = FkInput(input_str)\n    main_process = MainProcess(Source(0), pr_func=fk_print, in_func=fk_input, ch_func=choice_fn)\n\n    main_process.start_game()\n\n    assert 'YOU LOST' in fk_print.container[-1]\n\n\ndef test_wow_year(freezer, choice_fn: Callable) -> None:\n    freezer.move_to('2135-10-17')\n    fk_print = FkPrint()\n    fk_input = FkInput(['none'] * 100)  # noqa: WPS435\n    main_process = MainProcess(Source(0), pr_func=fk_print, in_func=fk_input, ch_func=choice_fn)\n\n    main_process.start_game()\n\n    assert 'this program' in fk_print.container[0]\n"}
{"type": "test_file", "path": "Test-Case-Generator/test_case.py", "content": "#  ------------------------------------------------- ###\n#  ------------------------------------------------- ###\n#  ### Developed by TANMAY KHANDELWAL (aka Dude901). ###\n#  _________________________________________________ ###\n#  _________________________________________________ ###\n\nfrom tkinter import *\nfrom random import randint, choices\nimport webbrowser\nimport os\n\nmycolor = \"#262626\"\n\n\nclass Case:\n    def __init__(self, master):\n        gen_frame = Frame(master)\n        gen_frame.grid()\n        self.test_case_counter = None\n\n    def home(self):\n        self.statement = Label(\n            gui,\n            text=\"Select Test Case Type\",\n            fg=\"white\",\n            height=1,\n            font=(\"calibre\", 12, \"normal\"),\n        )\n        self.statement.configure(bg=mycolor)\n        self.button1 = Button(\n            gui,\n            justify=LEFT,\n            text=\"T\\nn   \\nA1 A2 A3...An\\nn   \\nA1 A2 A3...An\",\n            width=13,\n            fg=\"white\",\n            bd=3,\n            command=lambda: Type1(gui),\n            bg=\"red\",\n            font=\"calibre\",\n        )\n        self.button1.configure(background=\"grey20\")\n        self.button2 = Button(\n            gui,\n            justify=LEFT,\n            text=\"T\\nn  m  \\nA1 A2 A3...An\\nn  m\\nA1 A2 A3...An\",\n            fg=\"white\",\n            command=lambda: Type2(gui),\n            width=13,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.button2.configure(background=\"grey20\")\n        self.button3 = Button(\n            gui,\n            justify=LEFT,\n            text=\"T\\nA1  B1\\nA2  B2\\n(t rows of)\\n(A, B pair)\",\n            fg=\"white\",\n            command=lambda: Type3(gui),\n            width=13,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.button3.configure(background=\"grey20\")\n        self.button4 = Button(\n            gui,\n            justify=LEFT,\n            text=\"T\\nn  m  \\nA1 A2...An\\nB1 B2...Bm\\n...  ...\",\n            fg=\"white\",\n            command=lambda: Type4(gui),\n            width=13,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.button4.configure(background=\"grey20\")\n        self.button5 = Button(\n            gui,\n            justify=LEFT,\n            text=\"T\\nn  m  k\\nn  m  k\\n(t rows of)\\n(n m k  pair)\",\n            fg=\"white\",\n            command=lambda: Type5(gui),\n            width=13,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.button5.configure(background=\"grey20\")\n        self.button6 = Button(\n            gui,\n            justify=LEFT,\n            text=\"n * m (matrix)\\nA1  A2...Am\\nA1  A2...Am\\n__   __ ... __\\n\"\n            \"A1  A2...Am\",\n            fg=\"white\",\n            command=lambda: Type6(gui),\n            width=13,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.button6.configure(background=\"grey20\")\n        self.button7 = Button(\n            gui,\n            justify=LEFT,\n            text=\"T\\nn\\nCustom string\\n(ex: 0 1)\\n(ex: + / -)\",\n            fg=\"white\",\n            command=lambda: Type7(gui),\n            width=13,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.button7.configure(background=\"grey20\")\n        self.button8 = Button(\n            gui,\n            justify=LEFT,\n            text=\"T\\nn  m\\nA1  B1\\n...   ...\\nAm  Bm\",\n            fg=\"white\",\n            command=lambda: Type8(gui),\n            width=13,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.button8.configure(background=\"grey20\")\n        self.button9 = Button(\n            gui,\n            justify=LEFT,\n            text='T\\nCustom string\\n(without \"n\")\\n(ex: 0 1)\\n(ex: + / -)',\n            fg=\"white\",\n            command=lambda: Type9(gui),\n            width=13,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.button9.configure(background=\"grey20\")\n        self.button10 = Button(\n            gui,\n            justify=LEFT,\n            text=\"T\\nn  k  m\\nA1 A2...An\\nn  k  m\\nA1 A2...An\",\n            fg=\"white\",\n            command=lambda: Type10(gui),\n            width=13,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.button10.configure(background=\"grey20\")\n        self.button_new = Button(\n            gui,\n            text=\" ANOTHER TYPE \",\n            fg=\"black\",\n            width=13,\n            font=\"calibre\",\n            bd=3,\n            command=lambda: self.newformat(self=Case),\n        )\n        self.button_exit = Button(\n            gui,\n            text=\" EXIT \",\n            fg=\"black\",\n            width=11,\n            font=\"calibre\",\n            bd=3,\n            command=lambda: gui.destroy(),\n        )\n        self.copyright_label = Button(\n            gui,\n            text=\"© Dude901\",\n            fg=\"white\",\n            width=7,\n            height=1,\n            bd=3,\n            command=lambda: webbrowser.open_new_tab(\"https://github.com/Tanmay-901\"),\n            font=(\"calibre\", 6, \"normal\"),\n        )\n        self.copyright_label.configure(bg=mycolor)\n        self.retrieve_home(self)\n\n    def newformat(self):\n        url = \"https://forms.gle/UVdo6QMAwBNxa9Ln7\"\n        webbrowser.open_new_tab(url)\n\n    def forget_home(self):\n        self.statement.place_forget()\n        self.button1.grid_forget()\n        self.button2.grid_forget()\n        self.button3.grid_forget()\n        self.button4.grid_forget()\n        self.button5.grid_forget()\n        self.button6.grid_forget()\n        self.button7.grid_forget()\n        self.button8.grid_forget()\n        self.button9.grid_forget()\n        self.button10.grid_forget()\n        self.button_new.grid_forget()\n        self.button_exit.grid_forget()\n\n    def retrieve_home(self):\n        self.statement.place(relx=0.39, rely=0.005)\n        self.button1.grid(row=1, column=0, ipady=10, pady=27, padx=10)\n        self.button2.grid(row=1, column=1, ipady=10, pady=27, padx=10)\n        self.button3.grid(row=1, column=2, ipady=10, pady=27, padx=10)\n        self.button4.grid(row=1, column=3, ipady=10, pady=27, padx=10)\n        self.button5.grid(row=1, column=4, ipady=10, pady=27, padx=10)\n        self.button6.grid(row=2, column=0, ipady=10, pady=13, padx=10)\n        self.button7.grid(row=2, column=1, ipady=10, pady=13, padx=10)\n        self.button8.grid(row=2, column=2, ipady=10, pady=13, padx=10)\n        self.button9.grid(row=2, column=3, ipady=10, pady=13, padx=10)\n        self.button10.grid(row=2, column=4, ipady=10, pady=13, padx=10)\n        self.button_new.grid(row=3, column=1, ipady=10, pady=13, padx=10)\n        self.button_exit.grid(row=3, column=3, ipady=10, pady=13, padx=10)\n        self.copyright_label.place(relx=0.92, rely=0.005)\n\n    def cpy(self):\n        txt = self.output.get(\"1.0\", END)\n        gui.clipboard_clear()\n        gui.clipboard_append(txt.strip())\n\n    def done(self, output):\n        self.a = [0]\n        self.try_forget()\n        self.retrieve_home()\n        pass\n\n    def display(self):\n        self.y_scroll = Scrollbar(gui)\n        self.x_scroll = Scrollbar(gui, orient=HORIZONTAL)\n        self.y_scroll.grid(row=0, column=11, sticky=\"NS\", pady=(22, 0), padx=(0, 20))\n        self.x_scroll.grid(\n            row=1, sticky=\"EW\", columnspan=10, padx=(20, 0), pady=(0, 30)\n        )\n        self.output = Text(\n            gui,\n            height=12,\n            bg=\"light cyan\",\n            width=82,\n            yscrollcommand=self.y_scroll.set,\n            xscrollcommand=self.x_scroll.set,\n            wrap=\"none\",\n        )\n        # self.output = ScrolledText(gui, height=12, bg=\"light cyan\", width=82, wrap='none',\n        # xscrollcommand=x_scroll.set)    # only for y scroll\n        self.output.grid(\n            row=0,\n            column=0,\n            columnspan=10,\n            sticky=\"n\",\n            ipady=10,\n            padx=(20, 0),\n            pady=(22, 0),\n        )\n        self.y_scroll.config(command=self.output.yview)\n        self.x_scroll.config(command=self.output.xview)\n        self.copy_button = Button(\n            gui,\n            text=\"COPY\",\n            fg=\"black\",\n            width=18,\n            command=self.cpy,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.copy_button.grid(\n            row=2, column=3, sticky=\"SW\", ipady=10, pady=(10, 18), padx=15\n        )\n        self.generate_button = Button(\n            gui,\n            text=\"RE-GENERATE\",\n            width=23,\n            fg=\"black\",\n            command=lambda: self.generate(),\n            font=\"calibre\",\n            bd=3,\n        )\n        self.generate_button.grid(row=2, column=4, ipady=10, pady=(10, 18), padx=15)\n\n        self.change_values_button = Button(\n            gui,\n            text=\"CHANGE CONSTRAINT\",\n            fg=\"black\",\n            command=lambda: self.take_input(),\n            width=20,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.change_values_button.grid(row=2, column=5, ipady=10, pady=(10, 18), padx=5)\n        self.done_button = Button(\n            gui,\n            text=\"HOME\",\n            fg=\"black\",\n            command=lambda: self.done(self.output),\n            width=20,\n            font=\"calibre\",\n            bd=3,\n        )\n        self.done_button.grid(\n            row=3, column=3, columnspan=2, ipady=10, pady=(10, 20), padx=5\n        )\n        self.button_exit_output = Button(\n            gui,\n            text=\" EXIT \",\n            fg=\"black\",\n            width=20,\n            font=\"calibre\",\n            bd=3,\n            command=lambda: gui.destroy(),\n        )\n        self.button_exit_output.grid(\n            row=3, column=4, columnspan=2, ipady=10, pady=(10, 20), padx=5\n        )\n\n    def try_forget(self):\n        self.output.grid_forget()\n        self.copy_button.grid_forget()\n        self.generate_button.grid_forget()\n        self.change_values_button.grid_forget()\n        self.done_button.grid_forget()\n        self.y_scroll.grid_forget()\n        self.x_scroll.grid_forget()\n        self.button_exit_output.grid_forget()\n        try:\n            self.constraints.grid_forget()\n        except AttributeError:\n            pass\n\n    def get_t(self, r):\n        self.test_case_count_label = Label(\n            gui, text=\"T  = \", font=(\"calibre\", 10, \"bold\"), width=17\n        )  # Type 1\n        self.test_case_count = Entry(\n            gui, textvariable=t, font=(\"calibre\", 10, \"normal\")\n        )\n        self.test_case_count_label.grid(row=r, column=0, pady=20, ipady=1)  # Type 1\n        self.test_case_count.grid(row=r, column=1)\n\n    def get_n(self, r):\n        self.minimum_value_of_n = Entry(\n            gui, textvariable=n_min, font=(\"calibre\", 10, \"normal\")\n        )\n        self.min_max_values_of_n_label = Label(\n            gui, text=\" <= n <=\", font=(\"calibre\", 10, \"bold\")\n        )\n        self.maximum_value_of_n = Entry(\n            gui, textvariable=n_max, font=(\"calibre\", 10, \"normal\")\n        )\n        self.minimum_value_of_n.grid(row=r, column=0, padx=10, pady=10)\n        self.min_max_values_of_n_label.grid(row=r, column=1, ipadx=5, ipady=1)\n        self.maximum_value_of_n.grid(row=r, column=2, padx=(10, 10))\n\n    def get_m(self, r):\n        self.minimum_value_of_m = Entry(\n            gui, textvariable=m_min, font=(\"calibre\", 10, \"normal\")\n        )\n        self.min_max_values_of_m_label = Label(\n            gui, text=\"<= m <=\", font=(\"calibre\", 10, \"bold\")\n        )\n        self.maximum_value_of_m = Entry(\n            gui, textvariable=m_max, font=(\"calibre\", 10, \"normal\")\n        )\n        self.minimum_value_of_m.grid(row=r, column=0, padx=10, pady=10)\n        self.min_max_values_of_m_label.grid(row=r, column=1, padx=10, ipadx=5, ipady=1)\n        self.maximum_value_of_m.grid(row=r, column=2, padx=10)\n\n    def get_k(self, r):\n        self.minimum_value_of_k = Entry(\n            gui, textvariable=k_min, font=(\"calibre\", 10, \"normal\")\n        )\n        self.min_max_values_of_k_label = Label(\n            gui, text=\" <= k <=\", font=(\"calibre\", 10, \"bold\")\n        )\n        self.maximum_value_of_k = Entry(\n            gui, textvariable=k_max, font=(\"calibre\", 10, \"normal\")\n        )\n        self.minimum_value_of_k.grid(row=r, column=0, pady=10)\n        self.min_max_values_of_k_label.grid(row=r, column=1)\n        self.maximum_value_of_k.grid(row=r, column=2)\n\n    def get_a(self, r):\n        self.minimum_value_of_ai = Entry(\n            gui, textvariable=a_min, font=(\"calibre\", 10, \"normal\")\n        )\n        self.min_max_values_of_ai_label = Label(\n            gui, text=\" <= Ai <=\", font=(\"calibre\", 10, \"bold\")\n        )\n        self.maximum_value_of_ai = Entry(\n            gui, textvariable=a_max, font=(\"calibre\", 10, \"normal\")\n        )\n        self.minimum_value_of_ai.grid(row=r, column=0, padx=10, pady=10)\n        self.min_max_values_of_ai_label.grid(row=r, column=1, ipadx=2, ipady=1)\n        self.maximum_value_of_ai.grid(row=r, column=2)\n\n    def get_b(self, r):\n        self.minimum_value_of_bi = Entry(\n            gui, textvariable=b_min, font=(\"calibre\", 10, \"normal\")\n        )\n        self.min_max_values_of_bi_label = Label(\n            gui, text=\" <= Bi <= \", font=(\"calibre\", 10, \"bold\")\n        )\n        self.maximum_value_of_bi = Entry(\n            gui, textvariable=b_max, font=(\"calibre\", 10, \"normal\")\n        )\n        self.minimum_value_of_bi.grid(row=r, column=0, pady=10)\n        self.min_max_values_of_bi_label.grid(row=r, column=1, padx=10)\n        self.maximum_value_of_bi.grid(row=r, column=2, padx=10)\n\n    def get_char_list(self, r):\n        self.char_list_label = Label(\n            gui, text=\"  Characters :  \", font=(\"calibre\", 10, \"bold\"), width=17\n        )\n        self.char_list = Entry(\n            gui, textvariable=char_lis, font=(\"calibre\", 10, \"normal\"), width=43\n        )\n        self.char_list.insert(END, \"(Space separated characters)\")\n        self.char_list.bind(\"<FocusIn>\", lambda args: self.char_list.delete(\"0\", \"end\"))\n        self.char_list_label.grid(row=r, column=0, pady=10)\n        self.char_list.grid(row=r, column=1, columnspan=2, padx=10)\n\n    def show_button(self, r):\n        self.back_btn = Button(\n            gui,\n            text=\" HOME \",\n            command=lambda: self.forget_testcase_take_input_screen(1),\n            font=\"calibre\",\n            bd=3,\n        )\n        self.sub_btn = Button(\n            gui, text=\" GENERATE \", command=self.submit, font=\"calibre\", bd=3\n        )\n        self.exit_btn = Button(\n            gui, text=\" EXIT \", command=lambda: gui.destroy(), font=\"calibre\", bd=3\n        )\n        self.back_btn.grid(row=r, column=0, pady=(20, 20), ipady=1)\n        self.sub_btn.grid(row=r, column=1, pady=(20, 20), ipady=1)\n        self.exit_btn.grid(row=r, column=2, pady=(20, 20), ipady=1)\n        self.copyright_label.place(relx=0.9, y=0)\n\n    def submit(self):\n        try:\n            self.t = int(self.test_case_count.get())\n            if self.t == 0 or self.t > 10000:\n                return\n        except ValueError:\n            return\n        except AttributeError:\n            pass\n        try:\n            self.n_min = min(\n                int(self.minimum_value_of_n.get()), int(self.maximum_value_of_n.get())\n            )\n            self.n_max = max(\n                int(self.minimum_value_of_n.get()), int(self.maximum_value_of_n.get())\n            )\n            if self.n_min > self.n_max or self.n_max == 0 or self.n_max > 10000000:\n                return\n        except ValueError:\n            return\n        except AttributeError:\n            pass\n        try:\n            self.m_min = min(\n                int(self.minimum_value_of_m.get()), int(self.maximum_value_of_m.get())\n            )\n            self.m_max = max(\n                int(self.minimum_value_of_m.get()), int(self.maximum_value_of_m.get())\n            )\n            if self.m_min > self.m_max or self.m_max == 0 or self.m_max > 10000000:\n                return\n        except ValueError:\n            return\n        except AttributeError:\n            pass\n        try:\n            self.k_min = min(\n                int(self.minimum_value_of_k.get()), int(self.maximum_value_of_k.get())\n            )\n            self.k_max = max(\n                int(self.minimum_value_of_k.get()), int(self.maximum_value_of_k.get())\n            )\n            if self.k_min > self.k_max or self.k_max == 0 or self.k_max > 10000000:\n                return\n        except ValueError:\n            return\n        except AttributeError:\n            pass\n        try:\n            self.a_min = min(\n                int(self.minimum_value_of_ai.get()), int(self.maximum_value_of_ai.get())\n            )\n            self.a_max = max(\n                int(self.minimum_value_of_ai.get()), int(self.maximum_value_of_ai.get())\n            )\n            if self.a_min > self.a_max or self.a_max == 0 or self.a_max > 10000000:\n                return\n        except ValueError:\n            return\n        except AttributeError:\n            pass\n        try:\n            self.b_min = min(\n                int(self.minimum_value_of_bi.get()), int(self.maximum_value_of_bi.get())\n            )\n            self.b_max = max(\n                int(self.minimum_value_of_bi.get()), int(self.maximum_value_of_bi.get())\n            )\n            if self.b_min > self.b_max or self.b_max == 0 or self.b_max > 10000000:\n                return\n        except ValueError:\n            return\n        except AttributeError:\n            pass\n        try:\n            self.char_lis = list(self.char_list.get().split())\n            if self.char_lis[0] == \"(Space\":\n                return\n        except IndexError:\n            return\n        except ValueError:\n            return\n        except AttributeError:\n            pass\n        try:\n            if self.t * self.n_max > 10000000:\n                return\n        except AttributeError:\n            pass\n        try:\n            if self.m_max * self.n_max > 10000000:\n                return\n        except AttributeError:\n            pass\n        try:\n            if self.t * self.m_max > 10000000:\n                return\n        except AttributeError:\n            pass\n        finally:\n            self.forget_testcase_take_input_screen()\n            self.display()\n            self.generate()\n\n    def forget_testcase_take_input_screen(self, check=0):\n        try:\n            self.test_case_count_label.grid_forget()\n            self.test_case_count.grid_forget()\n        except AttributeError:\n            pass\n        try:\n            self.minimum_value_of_n.grid_forget()\n            self.min_max_values_of_n_label.grid_forget()\n            self.maximum_value_of_n.grid_forget()\n        except AttributeError:\n            pass\n        try:\n            self.minimum_value_of_ai.grid_forget()\n            self.min_max_values_of_ai_label.grid_forget()\n            self.maximum_value_of_ai.grid_forget()\n        except AttributeError:\n            pass\n        try:\n            self.minimum_value_of_bi.grid_forget()\n            self.min_max_values_of_bi_label.grid_forget()\n            self.maximum_value_of_bi.grid_forget()\n        except AttributeError:\n            pass\n        try:\n            self.minimum_value_of_m.grid_forget()\n            self.min_max_values_of_m_label.grid_forget()\n            self.maximum_value_of_m.grid_forget()\n        except AttributeError:\n            pass\n        try:\n            self.minimum_value_of_k.grid_forget()\n            self.min_max_values_of_k_label.grid_forget()\n            self.maximum_value_of_k.grid_forget()\n        except AttributeError:\n            pass\n        try:\n            self.char_list_label.grid_forget()\n            self.char_list.delete(\"0\", \"end\")\n            self.char_list.grid_forget()\n        except AttributeError:\n            pass\n        try:\n            self.constraints.grid_forget()\n        except AttributeError:\n            pass\n        finally:\n            self.sub_btn.grid_forget()\n            self.back_btn.grid_forget()\n            self.exit_btn.grid_forget()\n\n        if check:\n            self.retrieve_home()\n\n\nclass Type1(Case):\n    def __init__(self, master):\n        super(Type1, self).__init__(master)  # Type 1\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):\n        try:\n            self.try_forget()  # Type 1\n        except AttributeError:\n            pass\n        self.get_t(0)\n        self.get_n(1)\n        self.get_a(2)\n        self.show_button(3)\n\n    def generate(self):  # Type 1\n        self.forget_testcase_take_input_screen()\n        self.output.delete(\"1.0\", END)\n        self.output.insert(END, self.t)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.t):\n            self.n = randint(self.n_min, self.n_max)\n            self.output.insert(END, self.n)\n            self.output.insert(END, \"\\n\")\n            self.a = [0] * self.n\n            for j in range(self.n):\n                self.a[j] = randint(self.a_min, self.a_max)\n            self.output.insert(END, self.a)\n            self.output.insert(END, \"\\n\")\n\n\nclass Type2(Case):  # Type 2\n    def __init__(self, master):\n        super(Type2, self).__init__(master)\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):  # Type 2\n        try:\n            self.try_forget()\n        except AttributeError:\n            pass\n        self.get_t(0)\n        self.get_n(1)\n        self.get_m(2)\n        self.get_a(3)\n        self.show_button(4)\n\n    def generate(self):  # Type 2\n        self.output.delete(\"1.0\", END)\n        self.output.insert(END, self.t)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.t):\n            self.n = randint(self.n_min, self.n_max)\n            self.m = randint(self.m_min, self.m_max)\n            self.output.insert(END, self.n)\n            self.output.insert(END, \" \")\n            self.output.insert(END, self.m)\n            self.output.insert(END, \"\\n\")\n            self.a = [0] * self.n\n            for j in range(self.n):\n                self.a[j] = randint(self.a_min, self.a_max)\n            self.output.insert(END, self.a)\n            self.output.insert(END, \"\\n\")\n\n\nclass Type3(Case):\n    def __init__(self, master):\n        super(Type3, self).__init__(master)\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):  # Type 3\n        try:\n            self.try_forget()\n        except AttributeError:\n            pass\n        self.get_t(0)\n        self.get_a(1)\n        self.get_b(2)\n        self.show_button(3)\n\n    def generate(self):  # Type 3\n        self.output.delete(\"1.0\", END)\n        self.output.insert(END, self.t)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.t):\n            self.a = randint(self.a_min, self.a_max)\n            self.b = randint(self.b_min, self.b_max)\n            self.output.insert(END, self.a)\n            self.output.insert(END, \" \")\n            self.output.insert(END, self.b)\n            self.output.insert(END, \"\\n\")\n\n\nclass Type4(Case):\n    def __init__(self, master):\n        super(Type4, self).__init__(master)\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):  # Type 4\n        try:\n            self.try_forget()\n        except AttributeError:\n            pass\n        self.get_t(0)\n        self.get_n(1)\n        self.get_m(2)\n        self.get_a(3)\n        self.get_b(4)\n        self.show_button(5)\n\n    def generate(self):  # Type 4\n        self.output.delete(\"1.0\", END)\n        self.output.insert(END, self.t)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.t):\n            self.n = randint(self.n_min, self.n_max)\n            self.m = randint(self.m_min, self.m_max)\n            self.output.insert(END, self.n)\n            self.output.insert(END, \" \")\n            self.output.insert(END, self.m)\n            self.output.insert(END, \"\\n\")\n            self.a = [0] * self.n\n            self.b = [0] * self.m\n            for j in range(self.n):\n                self.a[j] = randint(self.a_min, self.a_max)\n            self.output.insert(END, self.a)\n            self.output.insert(END, \"\\n\")\n            for j in range(self.m):\n                self.b[j] = randint(self.b_min, self.b_max)\n            self.output.insert(END, self.b)\n            self.output.insert(END, \"\\n\")\n\n\n#  ------------------------------------------------- ###\n#  ------------------------------------------------- ###\n#  ### Developed by TANMAY KHANDELWAL (aka Dude901). ###\n#  _________________________________________________ ###\n#  _________________________________________________ ###\n\n\nclass Type5(Case):\n    def __init__(self, master):\n        super(Type5, self).__init__(master)\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):  # Type 5\n        try:\n            self.try_forget()\n        except AttributeError:\n            pass\n        self.get_t(0)\n        self.get_n(1)\n        self.get_m(2)\n        self.get_k(3)\n        self.show_button(4)\n\n    def generate(self):  # Type 5\n        self.output.delete(\"1.0\", END)\n        self.output.insert(END, self.t)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.t):\n            self.n = randint(self.n_min, self.n_max)\n            self.m = randint(self.m_min, self.m_max)\n            self.k = randint(self.k_min, self.k_max)\n            self.output.insert(END, self.n)\n            self.output.insert(END, \" \")\n            self.output.insert(END, self.m)\n            self.output.insert(END, \" \")\n            self.output.insert(END, self.k)\n            self.output.insert(END, \"\\n\")\n\n\nclass Type6(Case):\n    def __init__(self, master):  # Type 6\n        super(Type6, self).__init__(master)\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):  # Type 6\n        try:\n            self.try_forget()\n        except AttributeError:\n            pass  # Type 6\n        self.constraints = Label(\n            gui,\n            text=\"Enter Constraints\",\n            fg=\"white\",\n            height=1,\n            font=(\"calibre\", 12, \"normal\"),\n        )\n        self.constraints.configure(bg=mycolor)\n        self.constraints.grid(row=0, column=1)\n        self.get_n(1)\n        self.get_m(2)\n        self.get_a(3)\n        self.show_button(4)\n\n    def generate(self):  # Type 6\n        self.output.delete(\"1.0\", END)\n        self.n = randint(self.n_min, self.n_max)\n        self.m = randint(self.m_min, self.m_max)\n        self.output.insert(END, self.n)\n        self.output.insert(END, \" \")\n        self.output.insert(END, self.m)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.n):\n            self.a = [0] * self.m\n            for j in range(self.m):\n                self.a[j] = randint(self.a_min, self.a_max)\n            self.output.insert(END, self.a)\n            self.output.insert(END, \"\\n\")\n\n\nclass Type7(Case):\n    def __init__(self, master):  # Type 7\n        super(Type7, self).__init__(master)\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):  # Type 7\n        try:\n            self.try_forget()\n        except AttributeError:\n            pass\n        self.get_t(0)\n        self.get_char_list(1)\n        self.get_n(2)\n        self.show_button(3)\n\n    def generate(self):  # Type 7\n        self.output.delete(\"1.0\", END)\n        self.output.insert(END, self.t)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.t):\n            self.n = randint(self.n_min, self.n_max)\n            self.output.insert(END, self.n)\n            self.output.insert(END, \"\\n\")\n            self.a = choices(self.char_lis, k=self.n)\n            self.output.insert(END, \"\".join(self.a))\n            self.output.insert(END, \"\\n\")\n\n\nclass Type8(Case):\n    def __init__(self, master):  # Type 8\n        super(Type8, self).__init__(master)\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):\n        try:  # Type 8\n            self.try_forget()\n        except AttributeError:\n            pass\n        self.get_t(0)\n        self.get_n(1)\n        self.get_m(2)\n        self.get_a(3)\n        self.get_b(4)\n        self.show_button(5)\n\n    def generate(self):  # Type 8\n        self.output.delete(\"1.0\", END)\n        self.output.insert(END, self.t)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.t):\n            self.n = randint(self.n_min, self.n_max)\n            self.m = randint(self.m_min, self.m_max)\n            self.output.insert(END, self.n)\n            self.output.insert(END, \" \")\n            self.output.insert(END, self.m)\n            self.output.insert(END, \"\\n\")\n            for j in range(self.m):\n                self.a = randint(self.a_min, self.a_max)\n                self.b = randint(self.b_min, self.b_max)\n                self.output.insert(END, self.a)\n                self.output.insert(END, \" \")\n                self.output.insert(END, self.b)\n                self.output.insert(END, \"\\n\")\n\n\nclass Type9(Case):\n    def __init__(self, master):\n        super(Type9, self).__init__(master)\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):  # Type 9\n        try:\n            self.try_forget()\n        except AttributeError:\n            pass\n        self.get_t(0)\n        self.get_char_list(1)\n        self.get_n(2)\n        self.show_button(3)\n\n    def generate(self):  # Type 9\n        self.output.delete(\"1.0\", END)\n        self.output.insert(END, self.t)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.t):\n            self.n = randint(self.n_min, self.n_max)\n            self.a = choices(self.char_lis, k=self.n)\n            self.output.insert(END, \"\".join(self.a))\n            self.output.insert(END, \"\\n\")\n\n\nclass Type10(Case):\n    def __init__(self, master):\n        super(Type10, self).__init__(master)\n        self.forget_home()\n        self.take_input()\n\n    def take_input(self):  # Type 10\n        try:\n            self.try_forget()\n        except AttributeError:\n            pass\n        self.get_t(0)\n        self.get_n(1)\n        self.get_k(2)\n        self.get_m(3)\n        self.get_a(4)\n        self.show_button(5)\n\n    def generate(self):  # Type 10\n        self.output.delete(\"1.0\", END)\n        self.output.insert(END, self.t)\n        self.output.insert(END, \"\\n\")\n        for i in range(self.t):\n            self.n = randint(self.n_min, self.n_max)\n            self.k = randint(self.k_min, self.k_max)\n            self.m = randint(self.m_min, self.m_max)\n            self.output.insert(END, self.n)\n            self.output.insert(END, \" \")\n            self.output.insert(END, self.k)\n            self.output.insert(END, \" \")  # Type 10\n            self.output.insert(END, self.m)\n            self.output.insert(END, \"\\n\")\n            self.a = [0] * self.n\n            for j in range(self.n):\n                self.a[j] = randint(self.a_min, self.a_max)\n            self.output.insert(END, self.a)\n            self.output.insert(END, \"\\n\")\n\n\nif __name__ == \"__main__\":\n    gui = Tk()\n    gui.title(\"TEST CASE GENERATOR\")\n    gui.configure(bg=mycolor)\n\n    if os.environ.get(\"DISPLAY\", \"\") == \"\":\n        print(\"no display found, using:0,0\")\n        os.environ.__setitem__(\"DISPLAY\", \":0.0\")\n    else:\n        print(\"found display\")\n\n    t = IntVar()\n    n_min = IntVar()\n    n_max = IntVar()\n    m_min = IntVar()\n    m_max = IntVar()\n    k_min = IntVar()\n    k_max = IntVar()\n    a_min = IntVar()\n    a_max = IntVar()\n    b_min = IntVar()\n    b_max = IntVar()\n    char_lis = StringVar()\n\n    Case.home(self=Case)\n\n    gui.mainloop()\n    gui.mainloop()\n\n    #  ------------------------------------------------- ###\n    #  ------------------------------------------------- ###\n    #  ### Developed by TANMAY KHANDELWAL (aka Dude901). ###\n    #  _________________________________________________ ###\n    #  _________________________________________________ ###\n"}
{"type": "test_file", "path": "Industrial_developed_hangman/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "BrowserHistory/tests/test_browser_history.py", "content": "import unittest\nimport sys\nimport os\n\n# Add parent directory to path to import backend\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nfrom backend import BrowserHistory\n\nclass TestBrowserHistory(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up test cases\"\"\"\n        self.browser = BrowserHistory(\"homepage.com\")\n\n    def test_initialization(self):\n        \"\"\"Test proper initialization of BrowserHistory\"\"\"\n        self.assertEqual(self.browser._curr.val, \"homepage.com\")\n        self.assertEqual(self.browser._back_count, 0)\n        self.assertEqual(self.browser._forward_count, 0)\n        self.assertIsNone(self.browser._curr.nxt)\n        self.assertIsNone(self.browser._curr.prev)\n\n    def test_visit(self):\n        \"\"\"Test visit functionality and forward history cleanup\"\"\"\n        self.browser.visit(\"page1.com\")\n        self.assertEqual(self.browser._curr.val, \"page1.com\")\n        self.assertEqual(self.browser._back_count, 1)\n        self.assertEqual(self.browser._forward_count, 0)\n\n        # Test forward history cleanup\n        self.browser.visit(\"page2.com\")\n        self.browser.back(1)\n        self.browser.visit(\"page3.com\")  # Should clear forward history\n        self.assertIsNone(self.browser._curr.nxt)\n        self.assertEqual(self.browser._forward_count, 0)\n\n    def test_back_navigation(self):\n        \"\"\"Test back navigation with counter validation\"\"\"\n        # Setup history\n        self.browser.visit(\"page1.com\")\n        self.browser.visit(\"page2.com\")\n        \n        # Test normal back navigation\n        result = self.browser.back(1)\n        self.assertEqual(result, \"page1.com\")\n        self.assertEqual(self.browser._back_count, 1)\n        self.assertEqual(self.browser._forward_count, 1)\n\n        # Test back with more steps than available\n        result = self.browser.back(5)  # Should only go back 1 step\n        self.assertEqual(result, \"homepage.com\")\n        self.assertEqual(self.browser._back_count, 0)\n        self.assertEqual(self.browser._forward_count, 2)\n\n    def test_forward_navigation(self):\n        \"\"\"Test forward navigation with counter validation\"\"\"\n        # Setup history and position\n        self.browser.visit(\"page1.com\")\n        self.browser.visit(\"page2.com\")\n        self.browser.back(2)  # Go back to homepage\n        \n        # Test normal forward navigation\n        result = self.browser.forward(1)\n        self.assertEqual(result, \"page1.com\")\n        self.assertEqual(self.browser._forward_count, 1)\n        self.assertEqual(self.browser._back_count, 1)\n\n        # Test forward with more steps than available\n        result = self.browser.forward(5)  # Should only go forward remaining 1 step\n        self.assertEqual(result, \"page2.com\")\n        self.assertEqual(self.browser._forward_count, 0)\n        self.assertEqual(self.browser._back_count, 2)\n\n    def test_complex_navigation(self):\n        \"\"\"Test complex navigation patterns\"\"\"\n        self.browser.visit(\"page1.com\")\n        self.browser.visit(\"page2.com\")\n        self.browser.visit(\"page3.com\")\n        \n        # Back navigation\n        self.assertEqual(self.browser.back(2), \"page1.com\")\n        \n        # New visit should clear forward history\n        self.browser.visit(\"page4.com\")\n        self.assertEqual(self.browser._forward_count, 0)\n        self.assertIsNone(self.browser._curr.nxt)\n        \n        # Verify we can't go forward to cleared history\n        self.assertEqual(self.browser.forward(1), \"page4.com\")\n\nif __name__ == '__main__':\n    unittest.main()"}
{"type": "test_file", "path": "XORcipher/test_XOR_cipher.py", "content": "#\n# Test XORCipher\n# **************\n#\n# Test automation software created by Kevin M. Thomas 09/29/19.\n# Test automation software Modified by Kevin M. Thomas 09/29/19.\n# CC BY 4.0\n#\n# Test XORCipher is the test automation suite for the XORCipher created by\n# Christian Bender.\n# Usage: python test_XOR_cipher.py\n#\n\n\nimport unittest\nfrom unittest import TestCase, mock\n\nfrom XOR_cipher import XORCipher\n\n\nclass TestXORCipher(TestCase):\n    \"\"\"\n    Test XORCipher class.\n    \"\"\"\n\n    def setUp(self):\n        \"\"\"\n        The SetUp call with commented values in the event one needs\n        to instantiate mocked objects regarding the XORCipher class.\n        \"\"\"\n\n        # key = mock.MagicMock()\n        # self.XORCipher_1 = XORCipher(key)\n        pass\n\n    @mock.patch(\"XOR_cipher.XORCipher.__init__\")\n    def test__init__(self, mock__init__):\n        \"\"\"\n        Test the __init__ method with commented values in the event\n        one needs to instantiate mocked objects on the method.\n        \"\"\"\n\n        # self.XORCipher_1.__init__ = mock.MagicMock()\n        XORCipher.__init__ = mock.MagicMock()\n\n        # self.XORCipher_1.__init__(1)\n        XORCipher.__init__()\n\n        # self.XORCipher_1.__init__.assert_called_with(1)\n        XORCipher.__init__.assert_called()\n\n    @mock.patch(\"XOR_cipher.XORCipher.encrypt\")\n    def test_encrypt(self, mock_encrypt):\n        \"\"\"\n        Test the encrypt method with mocked values.\n        \"\"\"\n\n        ans = mock.MagicMock()\n        content = mock.MagicMock()\n        key = mock.MagicMock()\n        XORCipher.encrypt = mock.MagicMock(return_value=ans)\n        XORCipher.encrypt(content, key)\n\n        XORCipher.encrypt.assert_called_with(content, key)\n\n    @mock.patch(\"XOR_cipher.XORCipher.decrypt\")\n    def test_decrypt(self, mock_decrypt):\n        \"\"\"\n        Test the decrypt method with mocked values.\n        \"\"\"\n\n        ans = mock.MagicMock()\n        content = mock.MagicMock()\n        key = mock.MagicMock()\n        XORCipher.decrypt = mock.MagicMock(return_value=ans)\n        XORCipher.decrypt(content, key)\n\n        XORCipher.decrypt.assert_called_with(content, key)\n\n    @mock.patch(\"XOR_cipher.XORCipher.encrypt_string\")\n    def test_encrypt_string(self, mock_encrypt_string):\n        \"\"\"\n        Test the encrypt_string method with mocked values.\n        \"\"\"\n\n        ans = mock.MagicMock()\n        content = mock.MagicMock()\n        key = mock.MagicMock()\n        XORCipher.encrypt_string = mock.MagicMock(return_value=ans)\n        XORCipher.encrypt_string(content, key)\n\n        XORCipher.encrypt_string.assert_called_with(content, key)\n\n    @mock.patch(\"XOR_cipher.XORCipher.decrypt_string\")\n    def test_decrypt_string(self, mock_decrypt_string):\n        \"\"\"\n        Test the decrypt_string method with mocked values.\n        \"\"\"\n\n        ans = mock.MagicMock()\n        content = mock.MagicMock()\n        key = mock.MagicMock()\n        XORCipher.decrypt_string = mock.MagicMock(return_value=ans)\n        XORCipher.decrypt_string(content, key)\n\n        XORCipher.decrypt_string.assert_called_with(content, key)\n\n    @mock.patch(\"XOR_cipher.XORCipher.encrypt_file\")\n    def test_encrypt_file(self, mock_encrypt_file):\n        \"\"\"\n        Test the encrypt_file method with mocked values.\n        \"\"\"\n\n        file = mock.MagicMock()\n        key = mock.MagicMock()\n        XORCipher.encrypt_file = mock.MagicMock(return_value=True)\n        XORCipher.encrypt_file(file, key)\n\n        XORCipher.encrypt_file.assert_called_with(file, key)\n\n    @mock.patch(\"XOR_cipher.XORCipher.decrypt_file\")\n    def test_decrypt_file(self, mock_decrypt_file):\n        \"\"\"\n        Test the decrypt_file method with mocked values.\n        \"\"\"\n\n        file = mock.MagicMock()\n        key = mock.MagicMock()\n        XORCipher.decrypt_string = mock.MagicMock(return_value=True)\n        XORCipher.decrypt_string(file, key)\n\n        XORCipher.decrypt_string.assert_called_with(file, key)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"}
{"type": "source_file", "path": "1 File handle/File handle binary/File handle binary read (record in non list form).py", "content": "import pickle\r\n\r\n\r\ndef binary_read():\r\n    with open(\"studrec.dat\",\"rb\") as b:\r\n        stud = pickle.load(b)\r\n        print(stud)\r\n\r\n        # prints the whole record in nested list format\r\n        print(\"contents of binary file\")\r\n\r\n        for ch in stud:\r\n\r\n            print(ch)  # prints one of the chosen rec in list\r\n\r\n            rno = ch[0]\r\n            rname = ch[1]  # due to unpacking the val not printed in list format\r\n            rmark = ch[2]\r\n\r\n            print(rno, rname, rmark, end=\"\\t\")\r\n\r\n\r\nbinary_read()\r\n"}
{"type": "source_file", "path": "1 File handle/File handle binary/Update a binary file.py", "content": "# Updating records in a binary file\r\n\r\nimport pickle\r\n\r\n\r\ndef update():\r\n    with open(\"class.dat\", \"rb+\") as F:\r\n        S = pickle.load(F)\r\n        found = False\r\n        rno = int(input(\"enter the roll number you want to update\"))\r\n\r\n        for i in S:\r\n            if rno == i[0]:\r\n                print(f\"the currrent name is {i[1]}\")\r\n                i[1] = input(\"enter the new name\")\r\n                found = True\r\n                break\r\n\r\n        if found:\r\n            print(\"Record not found\")\r\n\r\n        else:\r\n            F.seek(0)\r\n            pickle.dump(S, F)\r\n\r\n\r\nupdate()\r\n\r\nwith open(\"class.dat\", \"rb\") as F:\r\n    print(pickle.load(F))\r\n"}
{"type": "source_file", "path": "1 File handle/File handle text/question 5.py", "content": "\"\"\"Write a function in python to count the number of lowercase\r\nalphabets present in a text file “happy.txt\"\"\"\r\n\r\nimport time, os\r\nfrom counter import Counter\r\n\r\nprint(\"You will see the count of lowercase, uppercase and total count of alphabets in provided file..\")\r\n\r\n\r\nfile_path = input(\"Please, Enter file path: \")\r\n\r\nif os.path.exists(file_path):\r\n    print('The file exists and this is the path:\\n',file_path) \r\n\r\n\r\ndef lowercase(file_path):\r\n    try:\r\n\r\n        with open(file_path) as F:\r\n            word_counter = Counter(F.read())\r\n            \r\n            print(f\"The total number of lower case letters are {word_counter.get_total_lower()}\")\r\n            time.sleep(0.5)\r\n            print(f\"The total number of upper case letters are {word_counter.get_total_upper()}\")\r\n            time.sleep(0.5)\r\n            print(f\"The total number of letters are {word_counter.get_total()}\")\r\n            time.sleep(0.5)\r\n\r\n    except FileNotFoundError:\r\n        print(\"File is not exist.. Please check AGAIN\")\r\n\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    lowercase(file_path)\r\n"}
{"type": "source_file", "path": "1 File handle/File handle binary/Update a binary file2.py", "content": "# updating records in a binary file\r\n\r\nimport pickle\r\n\r\n\r\ndef update():\r\n\r\n    with open(\"studrec.dat\", \"rb+\") as File:\r\n        value = pickle.load(File)\r\n        found = False\r\n        roll = int(input(\"Enter the roll number of the record\"))\r\n        \r\n        for i in value:\r\n            if roll == i[0]:\r\n                print(f\"current name {i[1]}\")\r\n                print(f\"current marks {i[2]}\")\r\n                i[1] = input(\"Enter the new name\")\r\n                i[2] = int(input(\"Enter the new marks\"))\r\n                found = True\r\n\r\n        if not found:\r\n            print(\"Record not found\")\r\n\r\n        else:\r\n            pickle.dump(value, File)\r\n            File.seek(0)\r\n            print(pickle.load(File))\r\n\r\n\r\nupdate()\r\n"}
{"type": "source_file", "path": "1 File handle/File handle text/question 2.py", "content": "\"\"\" Write a method/function DISPLAYWORDS() in python to read lines\r\n from a text file STORY.TXT,\r\n using read function\r\nand display those words, which are less than 4 characters. \"\"\"\r\n\r\n\r\nprint(\"Hey!! You can print the word which are less then 4 characters\")        \r\n\r\ndef display_words(file_path):\r\n\r\n    try:\r\n        with open(file_path) as F:\r\n            words = F.read().split()\r\n            words_less_than_40 = list( filter(lambda word: len(word) < 4, words) )\r\n\r\n            for word in words_less_than_40:\r\n                print(word)\r\n        \r\n        return \"The total number of the word's count which has less than 4 characters\", (len(words_less_than_40)) \r\n    \r\n    except FileNotFoundError:\r\n        print(\"File not found\")\r\n\r\nprint(\"Just need to pass the path of your file..\")\r\n\r\nfile_path = input(\"Please, Enter file path: \")\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    print(display_words(file_path))\r\n                \r\n\r\n\r\n\r\n\r\n"}
{"type": "source_file", "path": "1 File handle/File handle text/file handle 12 length of line in text file.py", "content": "\r\nimport os\r\nimport time\r\nfile_name= input(\"Enter the file name to create:- \")\r\n\r\nprint(file_name)\r\n\r\ndef write_to_file(file_name):\r\n\r\n    if os.path.exists(file_name):\r\n        print(f\"Error: {file_name} already exists.\")\r\n        return\r\n\r\n    with open(file_name, \"a\") as F:\r\n\r\n        while True:\r\n            text = input(\"enter any text to add in the file:- \")\r\n            F.write( f\"{text}\\n\" )\r\n            choice = input(\"Do you want to enter more, y/n\").lower()\r\n            if choice == \"n\":\r\n                break\r\n    \r\ndef longlines():\r\n\r\n    with open(file_name, encoding='utf-8') as F:\r\n        lines = F.readlines()\r\n        lines_less_than_50 = list( filter(lambda line: len(line) < 50, lines ) )\r\n\r\n        if not lines_less_than_50:\r\n            print(\"There is no line which is less than 50\")\r\n        else:\r\n            for i in lines_less_than_50:\r\n                print(i, end=\"\\t\")\r\n\r\nif __name__ == \"__main__\":\r\n    write_to_file(file_name)\r\n    time.sleep(1)\r\n    longlines()"}
{"type": "source_file", "path": "1 File handle/File handle binary/question 1 (elegible for remedial, top marks).py", "content": "\"\"\"Amit is a monitor of class XII-A and he stored the record of all\r\nthe students of his class in a file named “class.dat”.\r\nStructure of record is [roll number, name, percentage]. His computer\r\nteacher has assigned the following duty to Amit\r\n\r\nWrite a function remcount( ) to count the number of students who need\r\n remedial class (student who scored less than 40 percent)\r\n\r\n \r\n \"\"\"\r\n# also find no. of children who got top marks\r\n\r\nimport pickle\r\n\r\nlist = [\r\n    [1, \"Ramya\", 30],\r\n    [2, \"vaishnavi\", 60],\r\n    [3, \"anuya\", 40],\r\n    [4, \"kamala\", 30],\r\n    [5, \"anuraag\", 10],\r\n    [6, \"Reshi\", 77],\r\n    [7, \"Biancaa.R\", 100],\r\n    [8, \"sandhya\", 65],\r\n]\r\n\r\nwith open(\"class.dat\", \"ab\") as F:\r\n    pickle.dump(list, F)\r\n    F.close()\r\n\r\n\r\ndef remcount():\r\n    with open(\"class.dat\", \"rb\") as F:\r\n        val = pickle.load(F)\r\n        count = 0\r\n\r\n        for i in val:\r\n            if i[2] <= 40:\r\n                print(f\"{i} eligible for remedial\")\r\n                count += 1\r\n        print(f\"the total number of students are {count}\")\r\n\r\n\r\nremcount()\r\n\r\n\r\ndef firstmark():\r\n    with open(\"class.dat\", \"rb\") as F:\r\n        val = pickle.load(F)\r\n        count = 0\r\n        main = [i[2] for i in val]\r\n\r\n        top = max(main)\r\n        print(top, \"is the first mark\")\r\n\r\n        F.seek(0)\r\n        for i in val:\r\n            if top == i[2]:\r\n                print(f\"{i}\\ncongrats\")\r\n                count += 1\r\n\r\n        print(\"the total number of students who secured top marks are\", count)\r\n\r\n\r\nfirstmark()\r\n\r\nwith open(\"class.dat\", \"rb\") as F:\r\n    val = pickle.load(F)\r\n    print(val)\r\n"}
{"type": "source_file", "path": "1 File handle/File handle binary/search record in binary file.py", "content": "# binary file to search a given record\r\n\r\nimport pickle\r\n\r\n\r\ndef binary_search():\r\n    with open(\"studrec.dat\", \"rb\") as F:\r\n        # your file path will be different\r\n        search = 0\r\n        rno = int(input(\"Enter the roll number of the student\"))\r\n\r\n        for i in pickle.load(F):\r\n            if i[0] == rno:\r\n                print(f\"Record found successfully\\n{i}\")\r\n                search = 1\r\n\r\n        if search == 0:\r\n            print(\"Sorry! record not found\")\r\n\r\n\r\nbinary_search()\r\n"}
{"type": "source_file", "path": "ASCIIvaluecharacter.py", "content": "# Program to find the ASCII value of the given character\n\nc = \"p\"\nprint(\"The ASCII value of '\" + c + \"' is\", ord(c))\n"}
{"type": "source_file", "path": "1 File handle/File handle text/question3.py", "content": "\"\"\"Write a user-defined function named count() that will read\r\nthe contents of text file named “happy.txt” and count\r\nthe number of lines which starts with either “I‟ or “M‟.\"\"\"\r\n\r\nimport os\r\nimport time\r\nfile_name= input(\"Enter the file name to create:- \")\r\n\r\n# step1:\r\nprint(file_name)\r\n\r\n\r\n\r\ndef write_to_file(file_name):\r\n\r\n    if os.path.exists(file_name):\r\n        print(f\"Error: {file_name} already exists.\")\r\n\r\n    else:\r\n        with open(file_name, \"a\") as F:\r\n\r\n            while True:\r\n                text = input(\"enter any text\")\r\n                F.write(f\"{text}\\n\") \r\n\r\n                if input(\"do you want to enter more, y/n\").lower() == \"n\":\r\n                    break\r\n        \r\n# step2:\r\ndef check_first_letter():\r\n    with open(file_name) as F:\r\n        lines = F.read().split()\r\n\r\n        # store all starting letters from each line in one string after converting to lower case\r\n        first_letters = \"\".join([line[0].lower() for line in lines])\r\n\r\n        count_i = first_letters.count(\"i\")\r\n        count_m = first_letters.count(\"m\")\r\n\r\n        print(f\"The total number of sentences starting with I or M are {count_i + count_m}\")\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    write_to_file(file_name)\r\n    time.sleep(1)\r\n    check_first_letter()\r\n"}
{"type": "source_file", "path": "AI Game/Tic-Tac-Toe-AI/tictactoe.py", "content": "import tkinter as tk #provides a library of basic elements of GUI widgets\nfrom tkinter import messagebox #provides a different set of dialogues that are used to display message boxes\nimport random\n\ndef check_winner(board, player):\n    # Check rows, columns, and diagonals for a win\n    for i in range(3):\n        if all(board[i][j] == player for j in range(3)) or all(board[j][i] == player for j in range(3)):\n            return True\n    if all(board[i][i] == player for i in range(3)) or all(board[i][2 - i] == player for i in range(3)):\n        return True\n    return False\n\ndef is_board_full(board):\n    return all(all(cell != ' ' for cell in row) for row in board)\n\ndef minimax(board, depth, is_maximizing):\n    if check_winner(board, 'X'):\n        return -1\n    if check_winner(board, 'O'):\n        return 1\n    if is_board_full(board): #if game is full, terminate\n        return 0\n\n    if is_maximizing: #recursive approach that fills board with Os\n        max_eval = float('-inf')\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == ' ':\n                    board[i][j] = 'O'\n                    eval = minimax(board, depth + 1, False) #recursion\n                    board[i][j] = ' '\n                    max_eval = max(max_eval, eval)\n        return max_eval\n    else: #recursive approach that fills board with Xs\n        min_eval = float('inf')\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == ' ':\n                    board[i][j] = 'X'\n                    eval = minimax(board, depth + 1, True) #recursion\n                    board[i][j] = ' '\n                    min_eval = min(min_eval, eval)\n        return min_eval\n\n#determines the best move for the current player and returns a tuple representing the position\ndef best_move(board):\n    best_val = float('-inf')\n    best_move = None\n\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == ' ':\n                board[i][j] = 'O'\n                move_val = minimax(board, 0, False)\n                board[i][j] = ' '\n                if move_val > best_val:\n                    best_val = move_val\n                    best_move = (i, j)\n\n    return best_move\n\ndef make_move(row, col):\n    if board[row][col] == ' ':\n        board[row][col] = 'X'\n        buttons[row][col].config(text='X')\n        if check_winner(board, 'X'):\n            messagebox.showinfo(\"Tic-Tac-Toe\", \"You win!\")\n            root.quit()\n        elif is_board_full(board):\n            messagebox.showinfo(\"Tic-Tac-Toe\", \"It's a draw!\")\n            root.quit()\n        else:\n            ai_move()\n    else:\n        messagebox.showerror(\"Error\", \"Invalid move\")\n\n#AI's turn to play\ndef ai_move():\n    row, col = best_move(board)\n    board[row][col] = 'O'\n    buttons[row][col].config(text='O')\n    if check_winner(board, 'O'):\n        messagebox.showinfo(\"Tic-Tac-Toe\", \"AI wins!\")\n        root.quit()\n    elif is_board_full(board):\n        messagebox.showinfo(\"Tic-Tac-Toe\", \"It's a draw!\")\n        root.quit()\n\nroot = tk.Tk()\nroot.title(\"Tic-Tac-Toe\")\n\nboard = [[' ' for _ in range(3)] for _ in range(3)]\nbuttons = []\n\nfor i in range(3):\n    row_buttons = []\n    for j in range(3):\n        button = tk.Button(root, text=' ', font=('normal', 30), width=5, height=2, command=lambda row=i, col=j: make_move(row, col))\n        button.grid(row=i, column=j)\n        row_buttons.append(button)\n    buttons.append(row_buttons)\n\nroot.mainloop()\n"}
{"type": "source_file", "path": "1 File handle/File handle text/counter.py", "content": "\"\"\"\n    Class resposible for counting words for different files:\n    - Reduce redundant code\n    - Easier code management/debugging\n    - Code readability\n\"\"\"\n\nclass Counter:\n\n    def __init__(self, text:str) -> None:\n        self.text = text\n\n        # Define the initial count of the lower and upper case.\n        self.count_lower = 0\n        self.count_upper = 0\n        self.count()\n\n    def count(self) -> None:\n        \n        for char in self.text:\n            if char.lower():\n                self.count_lower += 1\n            elif char.upper():\n                self.count_upper += 1\n\n        return (self.count_lower, self.count_upper)\n    \n    def get_total_lower(self) -> int:\n        return self.count_lower\n\n    def get_total_upper(self) -> int:\n        return self.count_upper\n\n    def get_total(self) -> int:\n        return self.count_lower + self.count_upper"}
{"type": "source_file", "path": "Anonymous_TextApp.py", "content": "import tkinter as tk\nfrom PIL import Image, ImageTk\nfrom twilio.rest import Client\n\nwindow = tk.Tk()\nwindow.title(\"Anonymous_Text_App\")\nwindow.geometry(\"800x750\")\n\n# Define global variables\nbody = \"\"\nto = \"\"\n\ndef message():\n    global body, to\n    account_sid = 'Your_account_sid' # Your account sid\n    auth_token = 'Your_auth_token' # Your auth token\n    client = Client(account_sid, auth_token)\n    msg = client.messages.create(\n        from_='Twilio_number',    # Twilio number\n        body=body,\n        to=to\n    )\n    print(msg.sid)\n    confirmation_label.config(text=\"Message Sent!\")  \n\n\n\ntry:\n    # Load the background image\n    bg_img = Image.open(r\"D:\\Downloads\\img2.png\")\n    \n    #Canvas widget\n    canvas = tk.Canvas(window, width=800, height=750)\n    canvas.pack(fill=\"both\", expand=True)\n    \n    #  background image to the Canvas\n    bg_photo = ImageTk.PhotoImage(bg_img)\n    bg_image_id = canvas.create_image(0, 0, image=bg_photo, anchor=\"nw\")\n    bg_image_id = canvas.create_image(550, 250, image=bg_photo, anchor=\"center\")\n    bg_image_id = canvas.create_image(1100, 250, image=bg_photo, anchor=\"center\")\n    bg_image_id = canvas.create_image(1250, 250, image=bg_photo, anchor=\"center\")\n    bg_image_id = canvas.create_image(250, 750, image=bg_photo, anchor=\"center\")\n    bg_image_id = canvas.create_image(850, 750, image=bg_photo, anchor=\"center\")\n    bg_image_id = canvas.create_image(1300, 750, image=bg_photo, anchor=\"center\")\n    \n  \n    \n    # Foreground Image\n    img = Image.open(r\"D:\\Downloads\\output-onlinepngtools.png\")\n    photo = ImageTk.PhotoImage(img)\n    img_label = tk.Label(window, image=photo, anchor=\"w\")\n    img_label.image = photo  \n    img_label.place(x=10, y=20)  \n    \n    # Text for number input\n    canvas.create_text(1050, 300, text=\"Enter the number starting with +[country code]\", font=(\"Poppins\", 18, \"bold\"), fill=\"black\", anchor=\"n\")\n    text_field_number = tk.Entry(canvas, width=17, font=(\"Poppins\", 25, \"bold\"), bg=\"#404040\", fg=\"white\", show=\"*\")\n    canvas.create_window(1100, 350, window=text_field_number, anchor=\"n\")\n    \n    # Text for message input\n    canvas.create_text(1050, 450, text=\"Enter the Message\", font=(\"Poppins\", 18, \"bold\"), fill=\"black\", anchor=\"n\")\n    text_field_text = tk.Entry(canvas, width=17, font=(\"Poppins\", 25, \"bold\"), bg=\"#404040\", fg=\"white\")\n    canvas.create_window(1100, 500, window=text_field_text, anchor=\"n\")\n    \n    #  label for confirmation message\n    confirmation_label = tk.Label(window, text=\"\", font=(\"Poppins\", 16), fg=\"green\")\n    canvas.create_window(1100, 600, window=confirmation_label, anchor=\"n\")\n    \nexcept Exception as e:\n    print(f\"Error loading image: {e}\")\n\n# Function to save input and send message\ndef save_and_send():\n    global body, to\n    to = str(text_field_number.get())\n    body = str(text_field_text.get())\n    message()\n\n# Button to save input and send message\nsave_button = tk.Button(window, text=\"Save and Send\", command=save_and_send)\ncanvas.create_window(1200, 550, window=save_button, anchor='n')\n\nwindow.mainloop()"}
{"type": "source_file", "path": "1 File handle/File handle text/special symbol after word.py", "content": "with open(\"happy.txt\", \"r\") as F:\r\n    # method 1\r\n    for i in F.read().split():\r\n        print(i, \"*\", end=\"\")\r\n    print(\"\\n\")\r\n\r\n    # method 2\r\n    F.seek(0)\r\n    for line in F.readlines():\r\n        for word in line.split():\r\n            print(word, \"*\", end=\"\")\r\n"}
{"type": "source_file", "path": "Armstrong_number.py", "content": "\"\"\"\r\nIn number theory, a narcissistic number (also known as a pluperfect digital invariant (PPDI), an Armstrong number (after Michael F. Armstrong) or a plus perfect number), \r\nin a given number base b, is a number that is the total of its own digits each raised to the power of the number of digits.\r\nSource: https://en.wikipedia.org/wiki/Narcissistic_number\r\nNOTE:\r\nthis scripts only works for number in base 10\r\n\"\"\"\r\n\r\ndef is_armstrong_number(number:str):\r\n    total:int = 0\r\n    exp:int = len(number) #get the number of digits, this will determinate the exponent\r\n\r\n    digits:list[int] = []\r\n    for digit in number: digits.append(int(digit)) #get the single digits\r\n    for x in digits: total += x ** exp #get the power of each digit and sum it to the total\r\n    \r\n    # display the result\r\n    if int(number) == total:\r\n       print(number,\"is an Armstrong number\")\r\n    else:\r\n       print(number,\"is not an Armstrong number\")\r\n\r\nnumber = input(\"Enter the number : \")\r\nis_armstrong_number(number)\r\n"}
{"type": "source_file", "path": "1 File handle/File handle binary/Deleting record in a binary file.py", "content": "import pickle\r\n\r\n\r\ndef bdelete():\r\n    # Opening a file & loading it\r\n    with open(\"studrec.dat\",\"rb\") as F:\r\n        stud = pickle.load(F)\r\n        print(stud)\r\n\r\n    # Deleting the Roll no. entered by user\r\n    rno = int(input(\"Enter the Roll no. to be deleted: \"))\r\n    with open(\"studrec.dat\",\"wb\") as F:\r\n        rec = [i for i in stud if i[0] != rno]\r\n        pickle.dump(rec, F)\r\n\r\n\r\nbdelete()\r\n"}
{"type": "source_file", "path": "AREA OF TRIANGLE.py", "content": "# Python Program to find the area of triangle\n# calculates area of traingle in efficient way!!\na = 5\nb = 6\nc = 7\n\n# Uncomment below to take inputs from the user\n# a = float(input('Enter first side: '))\n# b = float(input('Enter second side: '))\n# c = float(input('Enter third side: '))\n\n# calculate the semi-perimeter\ns = (a + b + c) / 2\n\n# calculate the area\narea = (s * (s - a) * (s - b) * (s - c)) ** 0.5\nprint(\"The area of the triangle is %0.2f\" % area)\n"}
{"type": "source_file", "path": "AutoComplete_App/backend.py", "content": "import sqlite3\nimport json\n\nclass AutoComplete:\n    \"\"\"\n    It works by building a `WordMap` that stores words to word-follower-count\n    ----------------------------\n    e.g. To train the following statement:\n    \n    It is not enough to just know how tools work and what they worth,\n    we have got to learn how to use them and to use them well.\n    And with all these new weapons in your arsenal, we would better\n    get those profits fired up\n\n    we create the following:\n    {   It: {is:1}\n        is: {not:1}\n        not: {enough:1}\n        enough: {to:1}\n        to: {just:1, learn:1, use:2}\n        just: {know:1}\n        .\n        .\n        profits: {fired:1}\n        fired: {up:1}\n    }\n    so the word completion for \"to\" will be \"use\".\n    For optimization, we use another store `WordPrediction` to save the\n    predictions for each word\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Returns - None\n        Input - None\n        ----------\n        - Initialize database. we use sqlite3\n        - Check if the tables exist, if not create them\n        - maintain a class level access to the database\n          connection object\n        \"\"\"\n        self.conn = sqlite3.connect(\"autocompleteDB.sqlite3\", autocommit=True)\n        cur = self.conn.cursor()\n        res = cur.execute(\"SELECT name FROM sqlite_master WHERE name='WordMap'\")\n        tables_exist = res.fetchone()\n\n        if not tables_exist:\n            self.conn.execute(\"CREATE TABLE WordMap(name TEXT, value TEXT)\")\n            self.conn.execute('CREATE TABLE WordPrediction (name TEXT, value TEXT)')\n            cur.execute(\"INSERT INTO WordMap VALUES (?, ?)\", (\"wordsmap\", \"{}\",))\n            cur.execute(\"INSERT INTO WordPrediction VALUES (?, ?)\", (\"predictions\", \"{}\",))\n\n    def train(self, sentence):\n        \"\"\"\n        Returns - string\n        Input - str: a string of words called sentence\n        ----------\n        Trains the sentence. It does this by creating a map of\n        current words to next words and their counts for each\n        time the next word appears after the current word\n        - takes in the sentence and splits it into a list of words\n        - retrieves the word map and predictions map\n        - creates the word map and predictions map together\n        - saves word map and predictions map to the database\n        \"\"\"\n        cur = self.conn.cursor()\n        words_list = sentence.split(\" \")\n\n        words_map = cur.execute(\"SELECT value FROM WordMap WHERE name='wordsmap'\").fetchone()[0]\n        words_map = json.loads(words_map)\n\n        predictions = cur.execute(\"SELECT value FROM WordPrediction WHERE name='predictions'\").fetchone()[0]\n        predictions = json.loads(predictions)\n\n        for idx in range(len(words_list)-1):\n            curr_word, next_word = words_list[idx], words_list[idx+1]\n            if curr_word not in words_map:\n                words_map[curr_word] = {}\n            if next_word not in words_map[curr_word]:\n                words_map[curr_word][next_word] = 1\n            else:\n                words_map[curr_word][next_word] += 1\n\n            # checking the completion word against the next word\n            if curr_word not in predictions:\n                predictions[curr_word] = {\n                    'completion_word': next_word,\n                    'completion_count': 1\n                }\n            else:\n                if words_map[curr_word][next_word] > predictions[curr_word]['completion_count']:\n                    predictions[curr_word]['completion_word'] = next_word\n                    predictions[curr_word]['completion_count'] = words_map[curr_word][next_word]\n\n        words_map = json.dumps(words_map)\n        predictions = json.dumps(predictions)\n\n        cur.execute(\"UPDATE WordMap SET value = (?) WHERE name='wordsmap'\", (words_map,))\n        cur.execute(\"UPDATE WordPrediction SET value = (?) WHERE name='predictions'\", (predictions,))\n        return(\"training complete\")\n\n    def predict(self, word):\n        \"\"\"\n        Returns - string\n        Input - string\n        ----------\n        Returns the completion word of the input word\n        - takes in a word\n        - retrieves the predictions map\n        - returns the completion word of the input word\n        \"\"\"\n        cur = self.conn.cursor()\n        predictions = cur.execute(\"SELECT value FROM WordPrediction WHERE name='predictions'\").fetchone()[0]\n        predictions = json.loads(predictions)\n        completion_word = predictions[word.lower()]['completion_word']\n        return completion_word\n\n\n\nif __name__ == \"__main__\":\n    input_ = \"It is not enough to just know how tools work and what they worth,\\\n              we have got to learn how to use them and to use them well. And with\\\n              all these new weapons in your arsenal, we would better get those profits fired up\"\n    ac = AutoComplete()\n    ac.train(input_)\n    print(ac.predict(\"to\"))"}
{"type": "source_file", "path": "A solution to project euler problem 3.py", "content": "\"\"\"\nProblem:\nThe prime factors of 13195 are 5,7,13 and 29. What is the largest prime factor\nof a given number N?\n\ne.g. for 10, largest prime factor = 5. For 17, largest prime factor = 17.\n\"\"\"\n\n\n# def solution(n: int) -> int:\ndef solution(n: int = 600851475143) -> int:\n    \"\"\"Returns the largest prime factor of a given number n.\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or passive of cast to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or passive of cast to int.\n    \"\"\"\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or passive of cast to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater or equal to one.\")\n\n    i = 2\n    ans = 0\n\n    if n == 2:\n        return 2\n\n    while n > 2:\n        while n % i != 0:\n            i += 1\n\n        ans = i\n\n        while n % i == 0:\n            n = n / i\n\n        i += 1\n\n    return int(ans)\n\n\nif __name__ == \"__main__\":\n    # print(solution(int(input().strip())))\n    import doctest\n\n    doctest.testmod()\n    print(solution(int(input().strip())))\n"}
{"type": "source_file", "path": "8_puzzle.py", "content": "from queue import PriorityQueue\n\nclass PuzzleState:\n    def __init__(self, board, goal, moves=0, previous=None):\n        self.board = board\n        self.goal = goal\n        self.moves = moves\n        self.previous = previous\n\n    def __lt__(self, other):\n        return self.priority() < other.priority()\n\n    def priority(self):\n        return self.moves + self.manhattan()\n\n    def manhattan(self):\n        distance = 0\n        for i in range(3):\n            for j in range(3):\n                if self.board[i][j] != 0:\n                    x, y = divmod(self.board[i][j] - 1, 3)\n                    distance += abs(x - i) + abs(y - j)\n        return distance\n\n    def is_goal(self):\n        return self.board == self.goal\n\n    def neighbors(self):\n        neighbors = []\n        x, y = next((i, j) for i in range(3) for j in range(3) if self.board[i][j] == 0)\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 3 and 0 <= ny < 3:\n                new_board = [row[:] for row in self.board]\n                new_board[x][y], new_board[nx][ny] = new_board[nx][ny], new_board[x][y]\n                neighbors.append(PuzzleState(new_board, self.goal, self.moves + 1, self))\n\n        return neighbors\n\ndef solve_puzzle(initial_board, goal_board):\n    initial_state = PuzzleState(initial_board, goal_board)\n    frontier = PriorityQueue()\n    frontier.put(initial_state)\n    explored = set()\n\n    while not frontier.empty():\n        current_state = frontier.get()\n\n        if current_state.is_goal():\n            return current_state\n\n        explored.add(tuple(map(tuple, current_state.board)))\n\n        for neighbor in current_state.neighbors():\n            if tuple(map(tuple, neighbor.board)) not in explored:\n                frontier.put(neighbor)\n\n    return None\n\ndef print_solution(solution):\n    steps = []\n    while solution:\n        steps.append(solution.board)\n        solution = solution.previous\n    steps.reverse()\n\n    for step in steps:\n        for row in step:\n            print(' '.join(map(str, row)))\n        print()\n\n# Example usage\ninitial_board = [\n    [1, 2, 3],\n    [4, 0, 5],\n    [7, 8, 6]\n]\n\ngoal_board = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 0]\n]\n\nsolution = solve_puzzle(initial_board, goal_board)\nif solution:\n    print(\"Solution found:\")\n    print_solution(solution)\nelse:\n    print(\"No solution found.\")\n"}
{"type": "source_file", "path": "Binary_to_Decimal.py", "content": "# Program to convert binary to decimal\n\n\ndef binaryToDecimal(binary):\n    \"\"\"\n    >>> binaryToDecimal(111110000)\n    496\n    >>> binaryToDecimal(10100)\n    20\n    >>> binaryToDecimal(101011)\n    43\n    \"\"\"\n    decimal, i, n = 0, 0, 0\n    while binary != 0:\n        dec = binary % 10\n        decimal = decimal + dec * pow(2, i)\n        binary = binary // 10\n        i += 1\n    print(decimal)\n\n\nbinaryToDecimal(100)\n"}
{"type": "source_file", "path": "Battery_notifier.py", "content": "from plyer import notification  # pip install plyer\nimport psutil  # pip install psutil\n\n# psutil.sensors_battery() will return the information related to battery\nbattery = psutil.sensors_battery()\n\n# battery percent will return the current battery prcentage\npercent = battery.percent\ncharging = (\n    battery.power_plugged\n)\n\n# Notification(title, description, duration)--to send\n# notification to desktop\n# help(Notification)\nif charging:\n    if percent == 100:\n        charging_message = \"Unplug your Charger\"\n    else:\n        charging_message = \"Charging\"\nelse:\n    charging_message = \"Not Charging\"\nmessage = str(percent) + \"% Charged\\n\" + charging_message\n\nnotification.notify(\"Battery Information\", message, timeout=10)\n"}
{"type": "source_file", "path": "AreaOfTriangle.py", "content": "# Python Program to find the area of triangle when all three side-lengths are known!\n\na = 5\nb = 6\nc = 7\n\n# Uncomment below to take inputs from the user\n# a = float(input('Enter first side: '))\n# b = float(input('Enter second side: '))\n# c = float(input('Enter third side: '))\n\n# calculate the semi-perimeter\ns = (a + b + c) / 2\n\n# calculate the area\narea = (s * (s - a) * (s - b) * (s - c)) ** 0.5\nprint(\"The area of the triangle is: \" + area)\n"}
{"type": "source_file", "path": "Assembler/assembler.py", "content": "from __future__ import print_function\n\nimport sys\n\nlines = []  # contains the lines of the file.\ntokens = []  # contains all tokens of the source code.\n\n# register eax, ebx,..., ecx\neax = 1\nebx = 0\necx = 0\nedx = 0\n\n# status register\nzeroFlag = False\n\n# stack data structure\n# push --> append\n# pop --> pop\nstack = []\n\n# jump link table\njumps = {}\n\n# variable table\nvariables = {}\n\n# return stack for subprograms\nreturnStack = []\n\n\n# simple exception class\nclass InvalidSyntax(Exception):\n    def __init__(self):\n        pass\n\n\n# class for represent a token\nclass Token:\n    def __init__(self, token, t):\n        self.token = token\n        self.t = t\n\n\n# def initRegister():\n#     global register\n#     for i in range(9):\n#         register.append(0)\n\n\ndef loadFile(fileName):\n    \"\"\"\n    loadFile: This function loads the file and reads its lines.\n    \"\"\"\n    global lines\n    fo = open(fileName)\n    for line in fo:\n        lines.append(line)\n    fo.close()\n\n\ndef scanner(string):\n    \"\"\"\n    scanner: This function builds the tokens by the content of the file.\n    The tokens will be saved in list 'tokens'\n    \"\"\"\n    global tokens\n    token = \"\"\n    state = 0  # init state\n\n    for ch in string:\n\n        match state:\n\n            case 0:\n            \n                match ch:\n\n                    case \"m\":  # catch mov-command\n\n                        state = 1\n                        token += \"m\"\n\n                    case \"e\":  # catch register\n\n                        state = 4\n                        token += \"e\"\n\n                    case \"1\":  # catch a number\n\n                        if ch <= \"9\" or ch == \"-\":\n                            state = 6\n                            token += ch\n\n                    case \"0\":  # catch a number or hex-code\n\n                        state = 17\n                        token += ch\n\n                    case \"a\":  # catch add-command\n\n                        state = 7\n                        token += ch\n\n                    case \"s\":  # catch sub command\n\n                        state = 10\n                        token += ch\n\n                    case \"i\":  # capture int command\n\n                        state = 14\n                        token += ch\n\n                    case \"p\":  # capture push or pop command\n\n                        state = 19\n                        token += ch\n\n                    case \"l\":  # capture label\n\n                        state = 25\n                        token += ch\n\n                    case \"j\":  # capture jmp command\n\n                        state = 26\n                        token += ch\n\n                    case \"c\":  # catch cmp-command\n\n                        state = 29\n                        token += ch\n\n                    case \";\":  # capture comment\n\n                        state = 33\n\n                    case '\"':  # catch a string\n\n                        state = 34\n                        # without \"\n\n                    case ch.isupper():  # capture identifier\n\n                        state = 35\n                        token += ch\n\n                    case \"d\":  # capture db keyword\n\n                        state = 36\n                        token += ch\n\n                    case \"$\":  # catch variable with prefix $\n\n                        state = 38\n                        # not catching $\n\n                    case \"_\":  # catch label for subprogram\n\n                        state = 40\n                        # not catches the character _\n\n                    case \"r\":  # catch ret-command\n\n                        state = 44\n                        token += ch\n\n                    case _:  # other characters like space-characters etc\n\n                        state = 0\n                        token = \"\"\n\n            case 1:  # state 1\n\n                match ch:\n\n                    case \"o\":\n\n                        state = 2\n                        token += ch\n\n                    case \"u\":\n\n                        state = 47\n                        token += ch\n\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n            \n            case 2:  # state 2\n\n                match ch:\n\n                    case \"v\":\n\n                        state = 3\n                        token += \"v\"\n\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 3:  # state 3\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 4:  # state 4\n\n                if ch >= \"a\" and ch <= \"d\":\n\n                    state = 5\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 5:  # state 5\n\n                match ch:\n\n                    case \"x\":\n\n                        state = 13\n                        token += ch\n\n                    case _:\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 6:  # state 6\n            \n                if ch.isdigit():\n\n                    state = 6\n                    token += ch\n\n                elif ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"value\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 7:  # state 7\n            \n                match ch:\n\n                    case \"d\":\n\n                        state = 8\n                        token += ch\n\n                    case _: # error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 8:  # state 8\n\n                match ch:\n                    case \"d\":\n\n                        state = 9\n                        token += ch\n\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 9:  # state 9\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 10:  # state 10\n\n                match ch:\n                    case \"u\":\n\n                        state = 11\n                        token += ch\n\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 11:  # state 11\n\n                match ch:\n                    case \"b\":\n\n                        state = 12\n                        token += ch\n\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 12:  # state 12\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 13:  # state 13\n\n                if ch == \",\" or ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"register\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 14:  # state 14\n\n                if ch == \"n\":\n\n                    state = 15\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 15:  # state 15\n\n                if ch == \"t\":\n\n                    state = 16\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 16:  # state 16\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 17:  # state 17\n\n                if ch == \"x\":\n\n                    state = 18\n                    token += ch\n\n                elif ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"value\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 18:  # state 18\n\n                if ch.isdigit() or (ch >= \"a\" and ch <= \"f\"):\n\n                    state = 18\n                    token += ch\n\n                elif ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"value\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 19:  # state 19\n\n                if ch == \"u\":\n\n                    state = 20\n                    token += ch\n\n                elif ch == \"o\":\n\n                    state = 23\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 20:  # state 20\n\n                if ch == \"s\":\n\n                    state = 21\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 21:  # state 21\n\n                if ch == \"h\":\n\n                    state = 22\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 22:  # state 22\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 23:  # state 23\n\n                if ch == \"p\":\n\n                    state = 24\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 24:  # state 24\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 25:  # state 25\n\n                if ch.isdigit():\n\n                    state = 25\n                    token += ch\n\n                elif ch == \":\" or ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"label\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 26:  # state 26\n\n                if ch == \"m\":\n\n                    state = 27\n                    token += ch\n\n                elif ch == \"e\":  # catch je command\n\n                    state = 32\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 27:  # state 27\n\n                if ch == \"p\":\n\n                    state = 28\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 28:  # state 28\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 29:  # state 29\n                \n                match ch:\n                    case \"m\":\n\n                        state = 30\n                        token += ch\n\n                    case \"a\":  # catch call-command\n\n                        state = 41\n                        token += ch\n\n                    case _:  # error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 30:  # state 30\n\n                if ch == \"p\":\n\n                    state = 31\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 31:  # state 31\n\n                token = \"\"\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n\n                else:  # error case\n\n                    state = 0\n                    raise InvalidSyntax()\n\n            case 32:  # state 32\n\n                token = \"\"\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n\n                else:  # error case\n\n                    state = 0\n                    raise InvalidSyntax()\n\n            case 33:  # state 33\n\n                if (\n                    ch.isdigit()\n                    or ch.isalpha()\n                    or (ch.isspace() and ch != \"\\n\")\n                    or ch == '\"'\n                ):\n\n                    state = 33\n\n                elif ch == \"\\n\":\n\n                    state = 0\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 34:  # state 34\n\n                if ch.isdigit() or ch.isalpha() or ch.isspace():\n\n                    state = 34\n                    token += ch\n\n                elif ch == '\"':\n\n                    state = 0\n                    tokens.append(Token(token, \"string\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 35:  # state 35\n\n                if ch.isdigit() or ch.isupper():\n\n                    state = 35\n                    token += ch\n\n                elif ch == \" \" or ch == \"\\n\":\n\n                    state = 0\n                    tokens.append(Token(token, \"identifier\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 36:  # state 36\n\n                if ch == \"b\":\n\n                    state = 37\n                    token += ch\n\n                elif ch == \"i\":\n\n                    state = 49\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 37:  # state 37\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 38:  # state 38\n\n                if ch.isalpha():\n\n                    state = 39\n                    token += ch\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 39:  # state 39\n\n                if ch.isalpha() or ch.isdigit():\n\n                    state = 39\n                    token += ch\n\n                elif ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"identifier\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 40:  # state 40\n\n                if (\n                    (ch >= \"a\" and ch <= \"z\")\n                    or (ch >= \"A\" and ch <= \"Z\")\n                    or (ch >= \"0\" and ch <= \"9\")\n                ):\n\n                    state = 40\n                    token += ch\n\n                elif ch == \":\" or ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"subprogram\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 41:  # state 41\n\n                match ch:\n                    case \"l\":\n\n                        state = 42\n                        token += ch\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 42:  # state 42\n\n                match ch:\n                    case \"l\":\n\n                        state = 43\n                        token += ch\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 43:  # state 43\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 44:  # state 44\n\n                match ch:\n                    case \"e\":\n\n                        state = 45\n                        token += ch\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 45:  # state 45\n\n                match ch:\n                    case \"t\":\n\n                        state = 46\n                        token += ch\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 46:  # state 46\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 47:  # state 47\n\n                match ch:\n                    case \"l\":\n\n                        state = 48\n                        token += ch\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 48:  # state 48\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n            case 49:  # state 49\n\n                match ch:\n                    case \"v\":\n\n                        state = 50\n                        token += ch\n                    case _:# error case\n\n                        state = 0\n                        token = \"\"\n                        raise InvalidSyntax()\n\n            case 50:  # state 50\n\n                if ch.isspace():\n\n                    state = 0\n                    tokens.append(Token(token, \"command\"))\n                    token = \"\"\n\n                else:  # error case\n\n                    state = 0\n                    token = \"\"\n                    raise InvalidSyntax()\n\n\ndef scan():\n    \"\"\"\n    scan: applys function scanner() to each line of the source code.\n    \"\"\"\n    global lines\n    assert len(lines) > 0, \"no lines\"\n    for line in lines:\n        try:\n            scanner(line)\n        except InvalidSyntax:\n            print(\"line=\", line)\n\n\ndef parser():\n    \"\"\"\n    parser: parses the tokens of the list 'tokens'\n    \"\"\"\n\n    global tokens\n    global eax, ebx, ecx, edx\n\n    assert len(tokens) > 0, \"no tokens\"\n\n    pointer = 0  # pointer for tokens\n    token = Token(\"\", \"\")\n    tmpToken = Token(\"\", \"\")\n\n    while pointer < len(tokens):\n\n        token = tokens[pointer]\n\n        if token.token == \"mov\":  # mov commando\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found argument!\")\n                return\n\n            # TODO use token.t for this stuff\n            if token.t == \"register\":\n\n                tmpToken = token\n\n                # it must follow a value / string / register / variable\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    token = tokens[pointer]\n                else:\n                    print(\"Error: Not found argument!\")\n                    return\n\n                # converts the token into float, if token contains only digits.\n                # TODO response of float\n                if token.t == \"identifier\":  # for variables\n\n                    # check of exists of variable\n                    if token.token in variables:\n                        token.token = variables[token.token]\n                    else:\n                        print(f\"Error: Undefined variable {token.token}\")\n                        return\n\n                elif token.t == \"string\":\n                    \n                    token.token = str(token.token)\n\n                elif isinstance(token.token, float):\n                    pass\n                elif token.token.isdigit():\n                    token.token = float(token.token)\n                elif token.token[0] == \"-\" and token.token[1:].isdigit():\n                    token.token = float(token.token[1:])\n                    token.token *= -1\n                elif token.t == \"register\":  # loads out of register\n                    match token.token:\n                        case \"eax\":\n                            token.token = eax\n                        case \"ebx\":\n                            token.token = ebx\n                        case \"ecx\":\n                            token.token = ecx\n                        case \"edx\":\n                            token.token = edx\n\n                match tmpToken.token:\n                    case \"eax\":\n                        eax = token.token\n                    case \"ebx\":\n                        ebx = token.token\n                    case \"ecx\":\n                        ecx = token.token\n                    case \"edx\":\n                        edx = token.token\n\n            else:\n\n                print(\"Error: No found register!\")\n                return\n\n        elif token.token == \"add\":  # add commando\n\n            pointer += 1\n            token = tokens[pointer]\n\n            if token.t == \"register\":\n\n                tmpToken = token\n\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    token = tokens[pointer]\n                else:\n                    print(\"Error: Not found number!\")\n                    return\n\n                # converts the token into float, if token contains only digits.\n                if token.t == \"register\":\n\n                    # for the case that token is register\n                    match token.token:\n                        case \"eax\":\n                            token.token = eax\n                        case \"ebx\":\n                            token.token = ebx\n                        case \"ecx\":\n                            token.token = ecx\n                        case \"edx\":\n                            token.token = edx\n\n                elif token.token.isdigit():\n                    token.token = float(token.token)\n                elif token.token[0] == \"-\" and token.token[1:].isdigit():\n                    token.token = float(token.token[1:])\n                    token.token *= -1\n                else:\n                    print(\"Error: \", token, \" is not a number!\")\n                    return\n\n                match tmpToken.token:\n\n                    case \"eax\":\n                        eax += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if eax == 0:\n                            zeroFlag = True\n                    \n                    case \"ebx\":\n                        ebx += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if ebx == 0:\n                            zeroFlag = True\n                    \n                    case \"ecx\":\n                        ecx += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if ecx == 0:\n                            zeroFlag = True\n                    \n                    case \"edx\":\n                        edx += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if edx == 0:\n                            zeroFlag = True\n\n            else:\n\n                print(\"Error: Not found register!\")\n                return\n\n        elif token.token == \"sub\":  # sub commando\n\n            pointer += 1\n            token = tokens[pointer]\n\n            if token.t == \"register\":\n\n                tmpToken = token\n\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    token = tokens[pointer]\n                else:\n                    print(\"Error: Not found number!\")\n                    return\n\n                # converts the token into float, if token contains only digits.\n                if token.t == \"register\":\n\n                    # for the case that token is register\n                    if token.token == \"eax\":\n                        token.token = eax\n                    elif token.token == \"ebx\":\n                        token.token = ebx\n                    elif token.token == \"ecx\":\n                        token.token = ecx\n                    elif token.token == \"edx\":\n                        token.token = edx\n\n                elif isinstance(token.token, float):\n                    pass\n                elif token.token.isdigit():\n                    token.token = float(token.token)\n                elif token.token[0] == \"-\" and token.token[1:].isdigit():\n                    token.token = float(token.token[1:])\n                    token.token *= -1\n                else:\n                    print(\"Error: \", token.token, \" is not a number!\")\n                    return\n\n                if tmpToken.token == \"eax\":\n                    eax -= token.token\n\n                    # updated zero flag\n                    if eax == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n                elif tmpToken.token == \"ebx\":\n                    ebx -= token.token\n                        \n                    # update zero flag\n                    if ebx == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n                elif tmpToken.token == \"ecx\":\n                    ecx -= token.token\n\n                    # update zero flag\n                    if ecx == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n                elif tmpToken.token == \"edx\":\n                    edx -= token.token\n\n                    # update zero flag\n                    if edx == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n\n            else:\n\n                print(\"Error: No found register!\")\n                return\n\n        elif token.token == \"int\":  # int commando\n\n            tmpToken = token\n\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found argument!\")\n                return\n\n            if token.token == \"0x80\":  # system interrupt 0x80\n\n                if eax == 1:  # exit program\n\n                    if ebx == 0:\n                        print(\"END PROGRAM\")\n                        return\n                    else:\n                        print(\"END PROGRAM WITH ERRORS\")\n                        return\n\n                elif eax == 3:\n\n                    ecx = float(input(\">> \"))\n\n                elif eax == 4:  # output informations\n\n                    print(ecx)\n\n        elif token.token == \"push\":  # push commando\n\n            tmpToken = token\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found register!\")\n                return\n\n            # pushing register on the stack\n            stack.append(token.token)\n\n        elif token.token == \"pop\":  # pop commando\n\n            tmpToken = token\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found register!\")\n                return\n\n            # pop register from stack\n            match token.token:\n                case \"eax\":\n                    if len(stack) == 0:\n                        print(\"Error: Stack Underflow\")\n                        return\n                    eax = stack.pop()\n                case \"ebx\":\n                    ebx = stack.pop()\n                case \"ecx\":\n                    ecx = stack.pop()\n                case \"edx\":\n                    edx = stack.pop()\n\n        elif token.t == \"label\":  # capture label\n\n            jumps[token.token] = pointer\n\n        elif token.token == \"jmp\":  # capture jmp command\n\n            # it must follow a label\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found label!\")\n                return\n\n            if token.t == \"label\":\n\n                pointer = jumps[token.token]\n\n            else:\n                print(\"Error: expected a label!\")\n\n        elif token.token == \"cmp\":\n            # TODO\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found argument!\")\n                return\n\n            if token.t == \"register\":\n\n                # it must follow a register\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    tmpToken = tokens[pointer]  # next register\n                else:\n                    print(\"Error: Not found register!\")\n                    return\n\n                # actual comparing\n                zeroFlag = setZeroFlag(token.token, tmpToken.token)\n                \n\n        elif token.token == \"je\":\n\n            # it must follow a label\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found argument\")\n                return\n\n            # check of label\n            if token.t == \"label\":\n\n                # actual jump\n                if zeroFlag:\n                    pointer = jumps[token.token]\n\n            else:\n\n                print(\"Error: Not found label\")\n                return\n\n        elif token.t == \"identifier\":\n\n            # check whether identifier is in variables-table\n            if token.token not in variables:\n\n                # it must follow a command\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    tmpToken = tokens[pointer]  # next register\n                else:\n                    print(\"Error: Not found argument\")\n                    return\n\n                if tmpToken.t == \"command\" and tmpToken.token == \"db\":\n\n                    # it must follow a value (string)\n                    if pointer + 1 < len(tokens):\n                        pointer += 1\n                        tmpToken = tokens[pointer]  # next register\n                    else:\n                        print(\"Error: Not found argument\")\n                        return\n\n                    if tmpToken.t == \"value\" or tmpToken.t == \"string\":\n\n                        if tmpToken.t == \"value\":\n                            variables[token.token] = float(tmpToken.token)\n                        elif tmpToken.t == \"string\":\n                            variables[token.token] = tmpToken.token\n\n                else:\n\n                    print(\"Error: Not found db-keyword\")\n                    return\n\n        elif token.token == \"call\":  # catch the call-command\n\n            # it must follow a subprogram label\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found subprogram label\")\n                return\n\n            if token.t == \"subprogram\":\n\n                if token.token in jumps:\n\n                    # save the current pointer\n                    returnStack.append(pointer)  # eventuell pointer + 1\n                    # jump to the subprogram\n                    pointer = jumps[token.token]\n\n                else:  # error case\n\n                    print(\"Error: Unknow subprogram!\")\n                    return\n\n            else:  # error case\n\n                print(\"Error: Not found subprogram\")\n                return\n\n        elif token.token == \"ret\":  # catch the ret-command\n\n            if len(returnStack) >= 1:\n\n                pointer = returnStack.pop()\n\n            else:  # error case\n\n                print(\"Error: No return adress on stack\")\n                return\n\n        elif token.t == \"subprogram\":\n\n            pass\n\n        elif token.token == \"mul\":  # catch mul-command\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found argument\")\n                return\n\n            if token.t == \"register\":\n\n                if token.token == \"eax\":\n\n                    eax *= eax\n\n                elif token.token == \"ebx\":\n\n                    eax *= ebx\n\n                elif token.token == \"ecx\":\n\n                    eax *= ecx\n\n                elif token.token == \"edx\":\n\n                    eax *= edx\n\n            else:\n\n                print(\"Error: Not found register\")\n                return\n\n        elif token.token == \"div\":\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found argument\")\n                return\n\n            if token.t == \"register\":\n                \n                match token.token:\n                    case \"eax\":\n                        eax /= eax\n\n                    case \"ebx\":\n                        if ebx == 0:\n                            print(\"Error: Division by Zero\")\n                            return\n                        eax /= ebx\n\n                    case \"ecx\":\n                        eax /= ecx\n\n                    case \"edx\":\n                        eax /= edx\n\n            else:\n\n                print(\"Error: Not found register\")\n                return\n\n        # increment pointer for fetching next token.\n        pointer += 1\n\ndef setZeroFlag(token, tmpToken):\n    \"\"\" return bool for zero flag based on the regToken \"\"\"\n    global eax, ebx, ecx, edx\n\n    # Register in string\n    registers = {\n        \"eax\": eax,\n        \"ebx\": ebx,\n        \"ecx\": ecx,\n        \"edx\": edx,\n    }\n\n    zeroFlag = False\n\n    match tmpToken:\n        case \"eax\":\n            if registers.get(token) == registers.get(tmpToken):\n                zeroFlag = True\n\n        case \"ebx\":\n            if registers.get(token) == registers.get(tmpToken):\n                zeroFlag = True\n\n        case \"ecx\":\n            if registers.get(token) == registers.get(tmpToken):\n                zeroFlag = True\n\n        case \"edx\":\n            if registers.get(token) == registers.get(tmpToken):\n                zeroFlag = True\n\n        case _:\n            print(\"Error: Not found register!\")\n            return\n\n    return zeroFlag\n\ndef registerLabels():\n    \"\"\"\n    This function search for labels / subprogram-labels and registers this in the 'jumps' list.\n    \"\"\"\n    for i in range(len(tokens)):\n        if tokens[i].t == \"label\":\n            jumps[tokens[i].token] = i\n        elif tokens[i].t == \"subprogram\":\n            jumps[tokens[i].token] = i\n\n\ndef resetInterpreter():\n    \"\"\"\n    resets the interpreter mind.\n    \"\"\"\n    global eax, ebx, ecx, edx, zeroFlag, stack\n    global variables, jumps, lines, tokens, returnStack\n    eax = 0\n    ebx = 0\n    ecx = 0\n    edx = 0\n    zeroFlag = False\n    stack = []\n    jumps = {}\n    variables = {}\n    lines = []\n    tokens = []\n    returnStack = []\n\n\n# DEBUG FUNCTION\n# def printTokens():\n#     for token in tokens:\n#         print(token.token, \" --> \", token.t)\n\n\n# main program\ndef main():\n    \"\"\"\n    reads textfiles from the command-line and interprets them.\n    \"\"\"\n\n    # [1:] because the first argument is the program itself.\n    for arg in sys.argv[1:]:\n\n        resetInterpreter()  # resets interpreter mind\n\n        try:\n\n            loadFile(arg)\n            scan()\n            registerLabels()\n            parser()\n\n        except Exception as e:\n\n            print(f\"Error: {e}\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "Automated Scheduled Call Reminders/caller.py", "content": "# The project automates calls for people from the firebase cloud database and the schedular keeps it running and checks for entries\n# every 1 hour using aps scedular\n# The project can be used to set 5 min before reminder calls to a set of people for doing a particular job\nimport os\nfrom firebase_admin import credentials, firestore, initialize_app\nfrom datetime import datetime, timedelta\nimport time\nfrom time import gmtime, strftime\nimport twilio\nfrom twilio.rest import Client\n\n# twilio credentials\nacc_sid = \"\"\nauth_token = \"\"\nclient = Client(acc_sid, auth_token)\n\n# firebase credentials\n# key.json is your certificate of firebase project\ncred = credentials.Certificate(\"key.json\")\ndefault_app = initialize_app(cred)\ndb = firestore.client()\ndatabase_reference = db.collection(\"on_call\")\n\n# Here the collection name is on_call which has documents with fields phone , from (%H:%M:%S time to call the person),date\n\n# gets data from cloud database and calls 5 min prior the time (from time) alloted in the database\ndef search():\n\n    calling_time = datetime.now()\n    one_hours_from_now = (calling_time + timedelta(hours=1)).strftime(\"%H:%M:%S\")\n    current_date = str(strftime(\"%d-%m-%Y\", gmtime()))\n    docs = db.collection(u\"on_call\").where(u\"date\", u\"==\", current_date).stream()\n    list_of_docs = []\n    for doc in docs:\n\n        c = doc.to_dict()\n        if (calling_time).strftime(\"%H:%M:%S\") <= c[\"from\"] <= one_hours_from_now:\n            list_of_docs.append(c)\n    print(list_of_docs)\n\n    while list_of_docs:\n        timestamp = datetime.now().strftime(\"%H:%M\")\n        five_minutes_prior = (timestamp + timedelta(minutes=5)).strftime(\"%H:%M\")\n        for doc in list_of_docs:\n            if doc[\"from\"][0:5] == five_minutes_prior:\n                phone_number = doc[\"phone\"]\n                call = client.calls.create(\n                    to=phone_number,\n                    from_=\"add your twilio number\",\n                    url=\"http://demo.twilio.com/docs/voice.xml\",\n                )\n                list_of_docs.remove(doc)\n"}
{"type": "source_file", "path": "Binary Coefficients.py", "content": "def pascal_triangle(lineNumber):\n    list1 = list()\n    list1.append([1])\n    i = 1\n    while i <= lineNumber:\n        j = 1\n        l = []\n        l.append(1)\n        while j < i:\n            l.append(list1[i - 1][j] + list1[i - 1][j - 1])\n            j = j + 1\n        l.append(1)\n        list1.append(l)\n        i = i + 1\n    return list1\n\n\ndef binomial_coef(n, k):\n    pascalTriangle = pascal_triangle(n)\n    return pascalTriangle[n][k - 1]\n"}
{"type": "source_file", "path": "BoardGame-CLI/snakeLadder.py", "content": "import random\n\n# Taking players data\nplayers = {}  # stores players name their locations\nisReady = {}\ncurrent_loc = 1  # vaiable for iterating location\n\nimp = True\n\n\n# players input function\ndef player_input():\n    global players\n    global current_loc\n    global isReady\n\n    x = True\n    while x:\n        player_num = int(input(\"Enter the number of players: \"))\n        if player_num > 0:\n            for i in range(player_num):\n                name = input(f\"Enter player {i+1} name: \")\n                players[name] = current_loc\n                isReady[name] = False\n            x = False\n            play()  # play funtion call\n\n        else:\n            print(\"Number of player cannot be zero\")\n            print()\n\n\n# Dice roll method\ndef roll():\n    # print(players)\n    return random.randrange(1, 7)\n\n\n# play method\ndef play():\n    global players\n    global isReady\n    global imp\n\n    while imp:\n        print(\"/\"*20)\n        print(\"1 -> roll the dice (or enter)\")\n        print(\"2 -> start new game\")\n        print(\"3 -> exit the game\")\n        print(\"/\"*20)\n\n        for i in players:\n            n = input(\"{}'s turn: \".format(i)) or 1\n            n = int(n)\n\n            if players[i] < 100:\n                if n == 1:\n                    temp1 = roll()\n                    print(f\"you got {temp1}\")\n                    print(\"\")\n\n                    if isReady[i] == False and temp1 == 6:\n                        isReady[i] = True\n\n                    if isReady[i]:\n                        looproll = temp1\n                        counter_6 = 0\n                        while looproll == 6:\n                            counter_6 += 1\n                            looproll = roll()\n                            temp1 += looproll\n                            print(f\"you got {looproll} \")\n                            if counter_6 == 3 :\n                                temp1 -= 18\n                                print(\"Three consectutives 6 got cancelled\")\n                            print(\"\")\n                        # print(temp1)\n                        if (players[i] + temp1) > 100:\n                            pass\n                        elif (players[i] + temp1) < 100:\n                            players[i] += temp1\n                            players[i] = move(players[i], i)\n                        elif (players[i] + temp1) == 100:\n                            print(f\"congrats {i} you won !!!\")\n                            imp = False\n                            return\n\n                    print(f\"you are at position {players[i]}\")\n\n                elif n == 2:\n                    players = {}  # stores player ans their locations\n                    isReady = {}\n                    current_loc = 0  # vaiable for iterating location\n                    player_input()\n\n                elif n == 3:\n                    print(\"Bye Bye\")\n                    imp = False\n\n                else:\n                    print(\"pls enter a valid input\")\n\n\n# Move method\ndef move(a, i):\n    global players\n    global imp\n    temp_loc = players[i]\n\n    if (temp_loc) < 100:\n        temp_loc = ladder(temp_loc, i)\n        temp_loc = snake(temp_loc, i)\n\n        return temp_loc\n\n\n# snake bite code\ndef snake(c, i):\n    if (c == 32):\n        players[i] = 10\n    elif (c == 36):\n        players[i] = 6\n    elif (c == 48):\n        players[i] = 26\n    elif (c == 63):\n        players[i] = 18\n    elif (c == 88):\n        players[i] = 24\n    elif (c == 95):\n        players[i] = 56\n    elif (c == 97):\n        players[i] = 78\n    else:\n        return players[i]\n    print(f\"You got bitten by a snake now you are at {players[i]}\")\n\n    return players[i]\n\n\n# ladder code\ndef ladder(a, i):\n    global players\n\n    if (a == 4):\n        players[i] = 14\n    elif (a == 8):\n        players[i] = 30\n    elif (a == 20):\n        players[i] = 38\n    elif (a == 40):\n        players[i] = 42\n    elif (a == 28):\n        players[i] = 76\n    elif (a == 50):\n        players[i] = 67\n    elif (a == 71):\n        players[i] = 92\n    elif (a == 88):\n        players[i] = 99\n    else:\n        return players[i]\n    print(f\"You got a ladder now you are at {players[i]}\")\n\n    return players[i]\n\n\n# while run:\nprint(\"/\"*40)\nprint(\"Welcome to the snake ladder game !!!!!!!\")\nprint(\"/\"*40)\n\n\nplayer_input()\n"}
{"type": "source_file", "path": "1 File handle/File handle text/question 6.py", "content": "\"\"\"Write a function in python to count the number of lowercase\r\nalphabets present in a text file “happy.txt”\"\"\"\r\n\r\nfrom counter import Counter\r\n\r\ndef lowercase():\r\n\r\n    with open(\"happy.txt\") as F:\r\n        word_counter = Counter(F.read())\r\n        \r\n        print(f\"The total number of lower case letters are {word_counter.get_total_lower()}\")\r\n        print(f\"The total number of upper case letters are {word_counter.get_total_upper()}\")\r\n        print(f\"The total number of letters are {word_counter.get_total()}\")\r\n\r\nif __name__ == \"__main__\":\r\n    lowercase()\r\n"}
{"type": "source_file", "path": "ARKA.py", "content": "def sumOfSeries(n):\n    x = n * (n + 1) / 2\n    return (int)(x * x)\n\n\n# Driver Function\nn = 5\nprint(sumOfSeries(n))\n"}
{"type": "source_file", "path": "Add_two_Linked_List.py", "content": "class Node:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.next = None\r\n\r\n\r\nclass LinkedList:\r\n    def __init__(self):\r\n        self.head = None\r\n\r\n    def insert_at_beginning(self, new_data):\r\n        new_node = Node(new_data)\r\n        if self.head is None:\r\n            self.head = new_node\r\n            return\r\n        new_node.next = self.head\r\n        self.head = new_node\r\n\r\n    def add_two_no(self, first, second):\r\n        prev = None\r\n        temp = None\r\n        carry = 0\r\n        while first is not None or second is not None:\r\n            first_data = 0 if first is None else first.data\r\n            second_data = 0 if second is None else second.data\r\n            Sum = carry + first_data + second_data\r\n            carry = 1 if Sum >= 10 else 0\r\n            Sum = Sum if Sum < 10 else Sum % 10\r\n            temp = Node(Sum)\r\n            if self.head is None:\r\n                self.head = temp\r\n            else:\r\n                prev.next = temp\r\n            prev = temp\r\n            if first is not None:\r\n                first = first.next\r\n            if second is not None:\r\n                second = second.next\r\n        if carry > 0:\r\n            temp.next = Node(carry)\r\n\r\n    def __str__(self):\r\n        temp = self.head\r\n        while temp:\r\n            print(temp.data, \"->\", end=\" \")\r\n            temp = temp.next\r\n        return \"None\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    first = LinkedList()\r\n    second = LinkedList()\r\n    first.insert_at_beginning(6)\r\n    first.insert_at_beginning(4)\r\n    first.insert_at_beginning(9)\r\n\r\n    second.insert_at_beginning(2)\r\n    second.insert_at_beginning(2)\r\n\r\n    print(\"First Linked List: \")\r\n    print(first)\r\n    print(\"Second Linked List: \")\r\n    print(second)\r\n\r\n    result = LinkedList()\r\n    result.add_two_no(first.head, second.head)\r\n    print(\"Final Result: \")\r\n    print(result)\r\n"}
{"type": "source_file", "path": "BrowserHistory/backend.py", "content": "class DLL:\n    \"\"\"\n        a doubly linked list that holds the current page,\n        next page, and previous page.\n        Used to enforce order in operations.\n    \"\"\"\n    def __init__(self, val: str =None):\n        self.val = val\n        self.nxt = None\n        self.prev = None\n\n\nclass BrowserHistory:\n    \"\"\"\n    This class designs the operations of a browser history\n\n    It works by using a doubly linked list to hold the urls with optimized\n    navigation using step counters and memory management\n    \"\"\"\n\n    def __init__(self, homepage: str):\n        \"\"\"\n        Returns - None\n        Input - str\n        ----------\n        - Initialize doubly linked list which will serve as the\n            browser history and sets the current page\n        - Initialize navigation counters\n        \"\"\"\n        self._head = DLL(homepage)\n        self._curr = self._head\n        self._back_count = 0\n        self._forward_count = 0\n        \n    def visit(self, url: str) -> None:\n        \"\"\"\n        Returns - None\n        Input - str\n        ----------\n        - Adds the current url to the DLL\n        - Sets both the next and previous values\n        - Cleans up forward history to prevent memory leaks\n        - Resets forward count and increments back count\n        \"\"\"\n        # Clear forward history to prevent memory leaks\n        self._curr.nxt = None\n        self._forward_count = 0\n        \n        # Create and link new node\n        url_node = DLL(url)\n        self._curr.nxt = url_node\n        url_node.prev = self._curr\n        \n        # Update current node and counts\n        self._curr = url_node\n        self._back_count += 1\n\n    def back(self, steps: int) -> str:\n        \"\"\"\n        Returns - str\n        Input - int\n        ----------\n        - Moves backwards through history up to available steps\n        - Updates navigation counters\n        - Returns current page URL\n        \"\"\"\n        # Only traverse available nodes\n        steps = min(steps, self._back_count)\n        while steps > 0:\n            self._curr = self._curr.prev\n            steps -= 1\n            self._back_count -= 1\n            self._forward_count += 1\n        return self._curr.val\n\n    def forward(self, steps: int) -> str:\n        \"\"\"\n        Returns - str\n        Input - int\n        ----------\n        - Moves forward through history up to available steps\n        - Updates navigation counters\n        - Returns current page URL\n        \"\"\"\n        # Only traverse available nodes\n        steps = min(steps, self._forward_count)\n        while steps > 0:\n            self._curr = self._curr.nxt\n            steps -= 1\n            self._forward_count -= 1\n            self._back_count += 1\n        return self._curr.val\n        \n\nif __name__ == \"__main__\":\n    obj = BrowserHistory(\"google.com\")\n    obj.visit(\"twitter.com\")\n    param_2 = obj.back(1)\n    param_3 = obj.forward(1)\n\n    print(param_2)\n    print(param_3)\n"}
{"type": "source_file", "path": "AutoComplete_App/frontend.py", "content": "from tkinter import *\nfrom tkinter import messagebox\nimport backend\n\n\ndef train():\n    sentence = train_entry.get()\n    ac = backend.AutoComplete()\n    ac.train(sentence)\n\ndef predict_word():\n    word = predict_word_entry.get()\n    ac = backend.AutoComplete()\n    print(ac.predict(word))\n\nif __name__ == \"__main__\":\n    root = Tk()\n    root.title(\"Input note\")\n    root.geometry('300x300')\n\n    train_label = Label(root, text=\"Train\")\n    train_label.pack()\n    train_entry = Entry(root)\n    train_entry.pack()\n\n    train_button = Button(root, text=\"train\", command=train)\n    train_button.pack()\n\n    predict_word_label = Label(root, text=\"Input term to predict\")\n    predict_word_label.pack()\n    predict_word_entry = Entry(root)\n    predict_word_entry.pack()\n\n    predict_button = Button(root, text=\"predict\", command=predict_word)\n    predict_button.pack()\n\n    root.mainloop()"}
{"type": "source_file", "path": "BoardGame-CLI/uno.py", "content": "#      uno game      #\n\nimport random\n\"\"\"\nGenerate the UNO deck of 108 cards.\nParameters: None\nReturn values: deck=>list\n\"\"\"\n\n\ndef buildDeck():\n    deck = []\n    # example card:Red 7,Green 8, Blue skip\n    colours = [\"Red\", \"Green\", \"Yellow\", \"Blue\"]\n    values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \"Draw Two\", \"Skip\", \"Reverse\"]\n    wilds = [\"Wild\", \"Wild Draw Four\"]\n    for colour in colours:\n        for value in values:\n            cardVal = \"{} {}\".format(colour, value)\n            deck.append(cardVal)\n            if value != 0:\n                deck.append(cardVal)\n    for i in range(4):\n        deck.append(wilds[0])\n        deck.append(wilds[1])\n    print(deck)\n    return deck\n\n\n\"\"\"\nShuffles a list of items passed into it\nParameters: deck=>list\nReturn values: deck=>list\n\"\"\"\n\n\ndef shuffleDeck(deck):\n    for cardPos in range(len(deck)):\n        randPos = random.randint(0, 107)\n        deck[cardPos], deck[randPos] = deck[randPos], deck[cardPos]\n    return deck\n\n\n\"\"\"Draw card function that draws a specified number of cards off the top of the deck\nParameters: numCards -> integer\nReturn: cardsDrawn -> list\n\"\"\"\n\n\ndef drawCards(numCards):\n    cardsDrawn = []\n    for x in range(numCards):\n        cardsDrawn.append(unoDeck.pop(0))\n    return cardsDrawn\n\n\n\"\"\"\nPrint formatted list of player's hand\nParameter: player->integer , playerHand->list\nReturn: None\n\"\"\"\n\n\ndef showHand(player, playerHand):\n    print(\"Player {}'s Turn\".format(players_name[player]))\n    print(\"Your Hand\")\n    print(\"------------------\")\n    y = 1\n    for card in playerHand:\n        print(\"{}) {}\".format(y, card))\n        y += 1\n    print(\"\")\n\n\n\"\"\"\nCheck whether a player is able to play a card, or not\nParameters: discardCard->string,value->string, playerHand->list\nReturn: boolean\n\"\"\"\n\n\ndef canPlay(colour, value, playerHand):\n    for card in playerHand:\n        if \"Wild\" in card:\n            return True\n        elif colour in card or value in card:\n            return True\n    return False\n\n\nunoDeck = buildDeck()\nunoDeck = shuffleDeck(unoDeck)\nunoDeck = shuffleDeck(unoDeck)\ndiscards = []\n\nplayers_name = []\nplayers = []\ncolours = [\"Red\", \"Green\", \"Yellow\", \"Blue\"]\nnumPlayers = int(input(\"How many players?\"))\nwhile numPlayers < 2 or numPlayers > 4:\n    numPlayers = int(\n        input(\"Invalid. Please enter a number between 2-4.\\nHow many players?\"))\nfor player in range(numPlayers):\n    players_name.append(input(\"Enter player {} name: \".format(player+1)))\n    players.append(drawCards(5))\n\n\nplayerTurn = 0\nplayDirection = 1\nplaying = True\ndiscards.append(unoDeck.pop(0))\nsplitCard = discards[0].split(\" \", 1)\ncurrentColour = splitCard[0]\nif currentColour != \"Wild\":\n    cardVal = splitCard[1]\nelse:\n    cardVal = \"Any\"\n\nwhile playing:\n    showHand(playerTurn, players[playerTurn])\n    print(\"Card on top of discard pile: {}\".format(discards[-1]))\n    if canPlay(currentColour, cardVal, players[playerTurn]):\n        cardChosen = int(input(\"Which card do you want to play?\"))\n        while not canPlay(currentColour, cardVal, [players[playerTurn][cardChosen-1]]):\n            cardChosen = int(\n                input(\"Not a valid card. Which card do you want to play?\"))\n        print(\"You played {}\".format(players[playerTurn][cardChosen-1]))\n        discards.append(players[playerTurn].pop(cardChosen-1))\n\n        # cheak if player won\n        if len(players[playerTurn]) == 0:\n            playing = False\n            # winner = \"Player {}\".format(playerTurn+1)\n            winner = players_name[playerTurn]\n        else:\n            # cheak for special cards\n            splitCard = discards[-1].split(\" \", 1)\n            currentColour = splitCard[0]\n            if len(splitCard) == 1:\n                cardVal = \"Any\"\n            else:\n                cardVal = splitCard[1]\n            if currentColour == \"Wild\":\n                for x in range(len(colours)):\n                    print(\"{}) {}\".format(x+1, colours[x]))\n                newColour = int(\n                    input(\"What colour would you like to choose? \"))\n                while newColour < 1 or newColour > 4:\n                    newColour = int(\n                        input(\"Invalid option. What colour would you like to choose\"))\n                currentColour = colours[newColour-1]\n            if cardVal == \"Reverse\":\n                playDirection = playDirection * -1\n            elif cardVal == \"Skip\":\n                playerTurn += playDirection\n                if playerTurn >= numPlayers:\n                    playerTurn = 0\n                elif playerTurn < 0:\n                    playerTurn = numPlayers-1\n            elif cardVal == \"Draw Two\":\n                playerDraw = playerTurn+playDirection\n                if playerDraw == numPlayers:\n                    playerDraw = 0\n                elif playerDraw < 0:\n                    playerDraw = numPlayers-1\n                players[playerDraw].extend(drawCards(2))\n            elif cardVal == \"Draw Four\":\n                playerDraw = playerTurn+playDirection\n                if playerDraw == numPlayers:\n                    playerDraw = 0\n                elif playerDraw < 0:\n                    playerDraw = numPlayers-1\n                players[playerDraw].extend(drawCards(4))\n            print(\"\")\n    else:\n        print(\"You can't play. You have to draw a card.\")\n        players[playerTurn].extend(drawCards(1))\n\n    playerTurn += playDirection\n    if playerTurn >= numPlayers:\n        playerTurn = 0\n    elif playerTurn < 0:\n        playerTurn = numPlayers-1\n\nprint(\"Game Over\")\nprint(\"{} is the Winner!\".format(winner))\n"}
{"type": "source_file", "path": "Binary_search.py", "content": "# It returns location of x in given array arr\n# if present, else returns -1\ndef binary_search(arr, l, r, x):\n    # Base case: if left index is greater than right index, element is not present\n    if l > r:\n        return -1\n\n    # Calculate the mid index\n    mid = (l + r) // 2\n\n    # If element is present at the middle itself\n    if arr[mid] == x:\n        return mid\n\n    # If element is smaller than mid, then it can only be present in left subarray\n    elif arr[mid] > x:\n        return binary_search(arr, l, mid - 1, x)\n\n    # Else the element can only be present in right subarray\n    else:\n        return binary_search(arr, mid + 1, r, x)\n\n\n# Main Function\nif __name__ == \"__main__\":\n    # User input array\n    arr = [int(x) for x in input(\"Enter the array with elements separated by commas: \").split(\",\")]\n\n    # User input element to search for\n    x = int(input(\"Enter the element you want to search for: \"))\n\n    # Function call\n    result = binary_search(arr, 0, len(arr) - 1, x)\n\n    # printing the output\n    if result != -1:\n        print(\"Element is present at index {}\".format(result))\n    else:\n        print(\"Element is not present in array\")\n"}
{"type": "source_file", "path": "Cat/cat.py", "content": "\"\"\"\r\nThe 'cat' Program Implemented in Python 3\r\n\r\nThe Unix 'cat' utility reads the contents\r\nof file(s) specified through stdin and 'conCATenates'\r\ninto stdout. If it is run without any filename(s) given,\r\nthen the program reads from standard input itself,\r\nwhich means it simply copies stdin to stdout.\r\n\r\nIt is fairly easy to implement such a program\r\nin Python, and as a result countless examples\r\nexist online. This particular implementation\r\nfocuses on the basic functionality of the cat\r\nutility. Compatible with Python 3.6 or higher.\r\n\r\nSyntax:\r\npython3 cat.py [filename1] [filename2] etc...\r\nSeparate filenames with spaces.\r\n\r\nDavid Costell (DontEatThemCookies on GitHub)\r\nv2 - 03/12/2022\r\n\"\"\"\r\nimport sys\r\n\r\ndef with_files(files):\r\n    \"\"\"Executes when file(s) is/are specified.\"\"\"\r\n    try:\r\n        # Read each file's contents and store them\r\n        file_contents = [contents for contents in [open(file).read() for file in files]]\r\n    except OSError as err:\r\n        # This executes when there's an error (e.g. FileNotFoundError)\r\n        exit(print(f\"cat: error reading files ({err})\"))\r\n\r\n    # Write all file contents into the standard output stream\r\n    for contents in file_contents:\r\n        sys.stdout.write(contents)\r\n\r\ndef no_files():\r\n    \"\"\"Executes when no file(s) is/are specified.\"\"\"\r\n    try:\r\n        # Get input, output the input, repeat\r\n        while True:\r\n            print(input())\r\n    # Graceful exit for Ctrl + C, Ctrl + D\r\n    except KeyboardInterrupt:\r\n        exit()\r\n    except EOFError:\r\n        exit()\r\n\r\ndef main():\r\n    \"\"\"Entry point of the cat program.\"\"\"\r\n    # Read the arguments passed to the program\r\n    if not sys.argv[1:]:\r\n        no_files()\r\n    else:\r\n        with_files(sys.argv[1:])\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"type": "source_file", "path": "Caesar Cipher Encoder  & Decoder.py", "content": "# PROJECT1\n# CAESAR CIPHER ENCODER/DECODER\n\n# Author: InTruder\n# Cloned from: https://github.com/InTruder-Sec/caesar-cipher\n\n# Improved by: OfficialAhmed (https://github.com/OfficialAhmed)\n\ndef get_int() -> int:\n    \"\"\"\n    Get integer, otherwise redo\n    \"\"\"\n\n    try:\n        key = int(input(\"Enter number of characters you want to shift: \"))\n    except:\n        print(\"Enter an integer\")\n        key = get_int()\n\n    return key\n\ndef main():\n\n    print(\"[>] CAESAR CIPHER DECODER!!! \\n\")\n    print(\"[1] Encrypt\\n[2] Decrypt\")\n\n    match input(\"Choose one of the above(example for encode enter 1): \"):\n\n        case \"1\":\n            encode()\n\n        case \"2\":\n            decode()\n\n        case _:\n            print(\"\\n[>] Invalid input. Choose 1 or 2\")\n            main()\n\n\ndef encode():\n\n    encoded_cipher = \"\"\n    text = input(\"Enter text to encode: \")\n    key = get_int()\n        \n    for char in text:\n        \n        ascii = ord(char) + key\n        encoded_cipher += chr(ascii)\n\n    print(f\"Encoded text: {encoded_cipher}\")\n\n\ndef decode():\n\n    decoded_cipher = \"\"\n    cipher = input(\"\\n[>] Enter your cipher text: \")\n    key = get_int()\n\n    for character in cipher:\n        ascii = ord(character) - key\n        decoded_cipher += chr(ascii)\n\n    print(decoded_cipher)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"type": "source_file", "path": "BlackJack_game/blackjack_simulate.py", "content": "import os\nimport random\nfrom functools import namedtuple\n\n\"\"\"\nTarget: BlackJack 21 simulate\n    - Role\n        - Dealer: 1\n            - Insurance: (When dealer Get A(1) face up)\n                - When dealer got 21\n                    - lost chips\n                - When dealer doesn't got 21\n                    - win double chips (Your Insurance)\n        - Player: 1\n            - Bet: (Drop chip before gambling start)\n            - Hit: (Take other card from the dealer)\n            - Stand: (No more card dealer may take card when rank under 17)\n            - Double down: (When you got over 10 in first hand)\n                           (Get one card)\n            - Surrender: (only available as first decision of a hand)\n                - Dealer return 50% chips\n\"\"\"\n\n__author__ = \"Alopex Cheung\"\n__version__ = \"0.2\"\n\nBLACK_JACK = 21\nBASE_VALUE = 17\n\nCOLOR = {\n    \"PURPLE\": \"\\033[1;35;48m\",\n    \"CYAN\": \"\\033[1;36;48m\",\n    \"BOLD\": \"\\033[1;37;48m\",\n    \"BLUE\": \"\\033[1;34;48m\",\n    \"GREEN\": \"\\033[1;32;48m\",\n    \"YELLOW\": \"\\033[1;33;48m\",\n    \"RED\": \"\\033[1;31;48m\",\n    \"BLACK\": \"\\033[1;30;48m\",\n    \"UNDERLINE\": \"\\033[4;37;48m\",\n    \"END\": \"\\033[1;37;0m\",\n}\n\n\nclass Card:\n    __slots__ = \"suit\", \"rank\", \"is_face\"\n\n    def __init__(self, suit, rank, face=True):\n        \"\"\"\n        :param suit: patter in the card\n        :param rank: point in the card\n        :param face: show or cover the face(point & pattern on it)\n        \"\"\"\n        self.suit = suit\n        self.rank = rank\n        self.is_face = face\n\n    def __repr__(self):\n        fmt_card = \"\\t<rank: {rank:2}, suit: {suit:8}>\"\n        if self.is_face:\n            return fmt_card.format(suit=self.suit, rank=self.rank)\n        return fmt_card.format(suit=\"*-Back-*\", rank=\"*-Back-*\")\n\n    def show(self):\n        print(str(self))\n\n\nclass Deck:\n    def __init__(self, num=1):\n        \"\"\"\n        :param num: the number of deck\n        \"\"\"\n        self.num = num\n        self.cards = []\n        self.built()\n\n    def __repr__(self):\n        return \"\\n\".join([str(card) for card in self.cards])\n\n    def __len__(self):\n        return len(self.cards)\n\n    def built(self):\n        for _ in range(self.num):\n            ranks = [x for x in range(1, 14)]\n            suits = \"Spades Heart Clubs Diamonds\".split()\n            for suit in suits:\n                for rank in ranks:\n                    card = Card(suit, rank)\n                    self.cards.append(card)\n\n    def shuffle(self):\n        for _ in range(self.num):\n            for index in range(len(self.cards)):\n                i = random.randint(0, 51)\n                self.cards[index], self.cards[i] = self.cards[i], self.cards[index]\n\n    def rebuilt(self):\n        self.cards.clear()\n        self.built()\n\n    def deliver(self):\n        return self.cards.pop()\n\n\nclass Chips:\n    def __init__(self, amount):\n        \"\"\"\n        :param amount: the chips you own\n        \"\"\"\n        self._amount = amount\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_insurance = False\n        self.is_double = False\n\n    def __bool__(self):\n        return self.amount > 0\n\n    @staticmethod\n    def get_tips(content):\n        fmt_tips = \"{color}** TIPS: {content}! **{end}\"\n        return fmt_tips.format(\n            color=COLOR.get(\"YELLOW\"), content=content, end=COLOR.get(\"END\")\n        )\n\n    @property\n    def amount(self):\n        return self._amount\n\n    @amount.setter\n    def amount(self, value):\n        if not isinstance(value, int):\n            type_tips = \"Please give a integer\"\n            raise ValueError(Chips.get_tips(type_tips))\n        if value < 0:\n            amount_tips = \"Your integer should bigger than 0\"\n            raise ValueError(Chips.get_tips(amount_tips))\n        self._amount = value\n\n    @property\n    def bet_amount(self):\n        return self._bet_amount\n\n    @bet_amount.setter\n    def bet_amount(self, value):\n        type_tips = \"Please give a integer\"\n        amount_tips = \"Your chips should between 1 - \" + str(self.amount) + \" \"\n        try:\n            value = int(value)\n        except ValueError:\n            raise ValueError(Chips.get_tips(type_tips))\n        else:\n            if not isinstance(value, int):\n                raise ValueError(Chips.get_tips(type_tips))\n            if (value <= 0) or (value > self.amount):\n                raise ValueError(Chips.get_tips(amount_tips))\n            self._bet_amount = value\n\n    def double_bet(self):\n        if self.can_double():\n            self._bet_amount *= 2\n            self.is_double = True\n        else:\n            over_tips = \"Not enough chips || \"\n            cannot_double = \"CAN'T DO DOUBLE\"\n            raise ValueError(Chips.get_tips(over_tips + cannot_double))\n\n    @property\n    def insurance(self):\n        return self._insurance\n\n    @insurance.setter\n    def insurance(self, value):\n        if self.amount - value < 0:\n            over_tips = \"Not enough chips\"\n            raise ValueError(Chips.get_tips(over_tips))\n        self._insurance = value\n        self.is_insurance = True\n\n    def current_amount(self):\n        return self.amount - self.bet_amount - self.insurance\n\n    def reset_chip(self):\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_double = False\n        self.is_insurance = False\n\n    def can_double(self):\n        return self.current_amount() - self.bet_amount >= 0\n\n\nclass User:\n    def __init__(self, name, role, chips_amount=None, color=\"END\"):\n        \"\"\"\n        :param name: User name\n        :param role: dealer or player\n        :param chips_amount: Casino tokens equal money\n        \"\"\"\n        self.name = name\n        self.prompt = \"{role} >> ({name}) : \".format(role=role, name=self.name)\n        self.chips = Chips(chips_amount)\n        self.color = color\n        self.hand = []\n        self.point = 0\n\n    def __repr__(self):\n        return str(self.__dict__)\n\n    def obtain_card(self, deck, face=True):\n        card = deck.deliver()\n        card.is_face = face\n        self.hand.append(card)\n\n    def drop_card(self):\n        self.hand.clear()\n        self.point = 0\n\n    def show_card(self):\n        print(\"\\t    ** Here is my card **\")\n        for card in self.hand:\n            card.show()\n\n    def unveil_card(self):\n        for card in self.hand:\n            card.is_face = True\n        self.show_card()\n\n    def calculate_point(self):\n        def _extract_rank():\n            raw_ranks = [card.rank for card in self.hand]\n            cook_ranks = [10 if rank > 10 else rank for rank in raw_ranks]\n            return cook_ranks\n\n        def _sum_up(ranks):\n            rank_one = sum(ranks)\n            rank_eleven = sum([11 if rank == 1 else rank for rank in ranks])\n            # Over or has 2 Ace\n            if (ranks[::-1] == ranks) and (1 in ranks):\n                return 11 + len(ranks) - 1\n            if rank_eleven <= BLACK_JACK:\n                return rank_eleven\n            return rank_one\n\n        points = _extract_rank()\n        self.point = _sum_up(points)\n\n    def is_point(self, opt, point):\n        self.calculate_point()\n        compare_fmt = \"{user_point} {opt} {point}\".format(\n            user_point=self.point, opt=opt, point=point\n        )\n        return eval(compare_fmt)\n\n    def speak(self, content=\"\", end_char=\"\\n\"):\n        print(\"\")\n        print(\n            COLOR.get(self.color) + self.prompt + COLOR.get(\"END\") + content,\n            end=end_char,\n        )\n\n    def showing(self):\n        self.speak()\n        self.show_card()\n\n    def unveiling(self):\n        self.calculate_point()\n        points_fmt = \"My point is: {}\".format(str(self.point))\n        self.speak(points_fmt)\n        self.unveil_card()\n\n\nclass Dealer(User):\n    def __init__(self, name):\n        super().__init__(name=name, role=\"Dealer\", color=\"PURPLE\")\n        self.trigger = 0\n\n    def ask_insurance(self):\n        buy_insurance = (\n            \"(Insurance pay 2 to 1)\\n\"\n            \"\\tMy Face card is an Ace.\\n\"\n            \"\\tWould your like buy a insurance ?\"\n        )\n        self.speak(content=buy_insurance)\n\n    def strategy_trigger(self, deck):\n        if self.is_point(\"<\", BASE_VALUE):\n            self.obtain_card(deck)\n        else:\n            self.trigger += random.randint(0, 5)\n            if self.trigger % 5 == 0:\n                self.obtain_card(deck)\n\n\nclass Player(User):\n    def __init__(self, name, amount):\n        super().__init__(name=name, chips_amount=amount, role=\"Player\", color=\"CYAN\")\n        self.refresh_prompt()\n\n    def refresh_prompt(self):\n        self.prompt = \"{role} [ ${remain} ] >> ({name}) : \".format(\n            role=\"Player\", name=self.name, remain=self.chips.current_amount()\n        )\n\n    def select_choice(self, pattern):\n        my_turn = \"My turn now.\"\n        self.speak(content=my_turn)\n        operation = {\n            \"I\": \"Insurance\",\n            \"H\": \"Hit\",\n            \"S\": \"Stand\",\n            \"D\": \"Double-down\",\n            \"U\": \"Surrender\",\n        }\n        enu_choice = enumerate((operation.get(p) for p in pattern), 1)\n        dict_choice = dict(enu_choice)\n        for index, operator in dict_choice.items():\n            choice_fmt = \"\\t[{index}] {operation}\"\n            print(choice_fmt.format(index=index, operation=operator))\n        return dict_choice\n\n\nclass Recorder:\n    def __init__(self):\n        self.data = []\n        self.winner = None\n        self.remain_chips = 0\n        self.rounds = 0\n        self.player_win_count = 0\n        self.dealer_win_count = 0\n        self.player_point = 0\n        self.dealer_point = 0\n\n    def update(self, winner, chips, player_point, dealer_point):\n        self.rounds += 1\n        self.remain_chips = chips\n        self.winner = winner\n        if self.winner == \"Player\":\n            self.player_win_count += 1\n        elif self.winner == \"Dealer\":\n            self.dealer_win_count += 1\n        self.player_point = player_point\n        self.dealer_point = dealer_point\n\n    def record(self, winner, chips, player_point, dealer_point):\n        self.update(winner, chips, player_point, dealer_point)\n        Row = namedtuple(\n            \"Row\", [\"rounds\", \"player_point\", \"dealer_point\", \"winner\", \"remain_chips\"]\n        )\n        row = Row(\n            self.rounds,\n            self.player_point,\n            self.dealer_point,\n            self.winner,\n            self.remain_chips,\n        )\n        self.data.append(row)\n\n    def draw_diagram(self):\n        content = \"Record display\"\n        bars = \"--\" * 14\n        content_bar = bars + content + bars\n        base_bar = bars + \"-\" * len(content) + bars\n\n        os.system(\"clear\")\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n        self.digram()\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n\n    def digram(self):\n        title = \"Round\\tPlayer-Point\\tDealer-Point\\tWinner-is\\tRemain-Chips\"\n        row_fmt = \"{}\\t{}\\t\\t{}\\t\\t{}\\t\\t{}\"\n\n        print(title)\n        for row in self.data:\n            print(\n                row_fmt.format(\n                    row.rounds,\n                    row.player_point,\n                    row.dealer_point,\n                    row.winner,\n                    row.remain_chips,\n                )\n            )\n\n        print(\"\")\n        win_rate_fmt = \">> Player win rate: {}%\\n>> Dealer win rate: {}%\"\n        try:\n            player_rate = round(self.player_win_count / self.rounds * 100, 2)\n            dealer_rate = round(self.dealer_win_count / self.rounds * 100, 2)\n        except ZeroDivisionError:\n            player_rate = 0\n            dealer_rate = 0\n        print(win_rate_fmt.format(player_rate, dealer_rate))\n\n\nclass BlackJack:\n    def __init__(self, username):\n        self.deck = Deck()\n        self.dealer = Dealer(\"Bob\")\n        self.player = Player(username.title(), 1000)\n        self.recorder = Recorder()\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.res = None\n\n    def play(self):\n        while self.player.chips:\n            self.initial_game()\n            self.in_bet()\n            self.deal_card()\n            while self.go_on:\n                self.choice = self.menu()\n                # self.player.speak()\n                self.chips_manage()\n                try:\n                    self.card_manage()\n                except ValueError as res:\n                    self.bust = True\n                    self.go_on = False\n                    self.res = res\n            if not self.bust:\n                self.is_surrender()\n            self.winner = self.get_winner()\n            self.res = \"Winner is \" + self.winner\n            os.system(\"clear\")\n            self.calculate_chips()\n            self.result_exhibit()\n            self.dealer.unveiling()\n            self.player.unveiling()\n            self.recorder.record(\n                self.winner,\n                self.player.chips.amount,\n                self.player.point,\n                self.dealer.point,\n            )\n\n        self.recorder.draw_diagram()\n        ending = \"\\n\\tSorry I lost all chips!\\n\\tTime to say goodbye.\"\n        self.player.speak(ending)\n        print(\"\\n\" + \"-\" * 20 + \" End Game \" + \"-\" * 20)\n\n    def initial_game(self):\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.deck.rebuilt()\n        self.deck.shuffle()\n        self.player.chips.reset_chip()\n        self.player.drop_card()\n        self.player.refresh_prompt()\n        self.dealer.drop_card()\n        print(\"\\n\" + \"-\" * 20 + \" Start Game \" + \"-\" * 20)\n\n    def in_bet(self):\n        in_bet = \"\\n\\tI want to bet: \"\n        not_invalid = True\n        self.player.speak(in_bet, end_char=\"\")\n        while not_invalid:\n            try:\n                self.player.chips.bet_amount = input()\n            except ValueError as e:\n                print(e)\n                self.player.speak(in_bet, end_char=\"\")\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                self.recorder.draw_diagram()\n                quit()\n            else:\n                self.player.refresh_prompt()\n                # self.player.speak()\n                not_invalid = False\n\n    def deal_card(self):\n        # dealer\n        self.dealer.obtain_card(self.deck, face=False)\n        self.dealer.obtain_card(self.deck)\n\n        # player\n        self.player.obtain_card(self.deck)\n        self.player.obtain_card(self.deck)\n\n        self.dealer.showing()\n        self.player.showing()\n\n    def menu(self):\n        pattern = \"HS\"\n        if self.first_hand:\n            pattern += \"U\"\n            if self.dealer.hand[1].rank == 1 and self.player.chips.current_amount():\n                pattern += \"I\"\n                self.dealer.ask_insurance()\n            if self.player.is_point(\">\", 10) and self.player.chips.can_double():\n                pattern += \"D\"\n            self.first_hand = False\n        choices = self.player.select_choice(pattern)\n        select = self.get_select(len(choices), general_err=\"Select above number.\")\n        return choices[select]\n\n    @staticmethod\n    def get_select(select_max, prompt=\">> \", general_err=\"\"):\n        while True:\n            try:\n                value = input(prompt)\n                select = int(value)\n                if select > select_max:\n                    raise ValueError\n            except ValueError:\n                print(general_err)\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                quit()\n            else:\n                return select\n\n    def chips_manage(self):\n        if self.choice == \"Insurance\":\n            err = \"The amount should under \" + str(self.player.chips.current_amount())\n            pay_ins = self.get_select(\n                self.player.chips.current_amount(),\n                prompt=\"Insurance amount >> \",\n                general_err=err,\n            )\n            self.player.chips.insurance = pay_ins\n\n        if self.choice == \"Double-down\":\n            try:\n                self.player.chips.double_bet()\n            except ValueError as e:\n                print(e)\n        self.player.refresh_prompt()\n        if self.choice in (\"Insurance\", \"Double-down\", \"Surrender\"):\n            self.go_on = False\n\n    def card_manage(self):\n        if self.choice in (\"Hit\", \"Double-down\"):\n            self.player.obtain_card(self.deck)\n            if self.player.is_point(\">\", BLACK_JACK):\n                raise ValueError(\"Player BUST\")\n            else:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n        elif self.choice != \"Surrender\":\n            if not self.player.chips.is_insurance:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n\n        self.dealer.showing()\n        self.player.showing()\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.go_on = False\n\n    def is_surrender(self):\n        if self.choice == \"Surrender\":\n            self.player.speak(\"Sorry, I surrender....\\n\")\n\n    def get_winner(self):\n        if self.bust:\n            return \"Dealer\" if self.player.is_point(\">\", BLACK_JACK) else \"Player\"\n\n        if self.choice == \"Surrender\":\n            return \"Dealer\"\n        elif self.choice == \"Insurance\":\n            if self.player.is_point(\"==\", BLACK_JACK):\n                return \"Dealer\"\n            return \"Player\"\n\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.player.calculate_point()\n            self.dealer.calculate_point()\n            if self.player.point > self.dealer.point:\n                return \"Player\"\n            return \"Dealer\"\n\n        return \"Both\"\n\n    def calculate_chips(self):\n        if self.choice == \"Surrender\":\n            if self.player.chips.bet_amount == 1:\n                if self.player.chips.current_amount() == 0:\n                    self.player.chips.amount = 0\n            else:\n                surrender_amount = self.player.chips.bet_amount // 2\n                self.player.chips.amount -= surrender_amount\n\n        elif self.choice in (\"Double-down\", \"Stand\", \"Insurance\", \"Hit\"):\n            if self.winner == \"Player\":\n                self.player.chips.amount += (\n                    self.player.chips.bet_amount + self.player.chips.insurance * 2\n                )\n            elif self.winner == \"Dealer\":\n                self.player.chips.amount -= (\n                    self.player.chips.bet_amount + self.player.chips.insurance\n                )\n\n    def result_exhibit(self):\n        def get_color():\n            if \"BUST\" in content:\n                return COLOR.get(\"RED\" if \"Player\" in content else \"GREEN\")\n            if self.winner == \"Player\":\n                return COLOR.get(\"GREEN\")\n            elif self.winner == \"Dealer\":\n                return COLOR.get(\"RED\")\n            else:\n                return COLOR.get(\"YELLOW\")\n\n        end = COLOR.get(\"END\")\n        content = str(self.res)\n        color = get_color()\n        winner_fmt = color + \"\\n\\t>> {content} <<\\n\" + end\n        print(winner_fmt.format(content=content))\n\n\ndef main():\n    try:\n        user_name = input(\"What is your name: \")\n    except KeyboardInterrupt:\n        print(\"\")\n    else:\n        black_jack = BlackJack(username=user_name)\n        black_jack.play()\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "Automated Scheduled Call Reminders/schedular.py", "content": "# schedular code for blocking schedular as we have only 1 process to run\n\nfrom apscheduler.schedulers.blocking import BlockingScheduler\n\nfrom caller import search\n\n\nsched = BlockingScheduler()\n\n# Schedule job_function to be called every two hours\nsched.add_job(search, \"interval\", hours=1)  # for testing instead add hours =1\n\nsched.start()\n"}
{"type": "source_file", "path": "Calculate resistance.py", "content": "def res(R1, R2): \n       sum = R1 + R2 \n       if option ==\"series\": \n           return sum \n       elif option ==\"parallel\" : \n           return (R1 * R2)/sum\n       return 0\nResistance1 = int(input(\"Enter R1 : \")) \nResistance2 = int(input(\"Enter R2 : \")) \noption = input(\"Enter series or parallel :\") \nprint(\"\\n\") \nR = res(Resistance1,Resistance2 ) \nif R==0:\n    print('Wrong Input!!' )\nelse:\n    print(\"The total resistance is\", R)\n"}
{"type": "source_file", "path": "Checker_game_by_dz/__init__.py", "content": ""}
{"type": "source_file", "path": "Base Converter Number system.py", "content": "def base_check(xnumber, xbase):\n    for char in xnumber[len(xnumber) - 1]:\n        if int(char) >= int(xbase):\n            return False\n    return True\n\n\ndef convert_from_10(xnumber, xbase, arr, ybase):\n    if int(xbase) == 2 or int(xbase) == 4 or int(xbase) == 6 or int(xbase) == 8:\n\n        if xnumber == 0:\n            return arr\n        else:\n            quotient = int(xnumber) // int(xbase)\n            remainder = int(xnumber) % int(xbase)\n            arr.append(remainder)\n            dividend = quotient\n            convert_from_10(dividend, xbase, arr, base)\n    elif int(xbase) == 16:\n        if int(xnumber) == 0:\n            return arr\n        else:\n            quotient = int(xnumber) // int(xbase)\n            remainder = int(xnumber) % int(xbase)\n            if remainder > 9:\n                if remainder == 10:\n                    remainder = \"A\"\n                if remainder == 11:\n                    remainder = \"B\"\n                if remainder == 12:\n                    remainder = \"C\"\n                if remainder == 13:\n                    remainder = \"D\"\n                if remainder == 14:\n                    remainder = \"E\"\n                if remainder == 15:\n                    remainder = \"F\"\n            arr.append(remainder)\n            dividend = quotient\n            convert_from_10(dividend, xbase, arr, ybase)\n\n\ndef convert_to_10(xnumber, xbase, arr, ybase):\n    if int(xbase) == 10:\n        for char in xnumber:\n            arr.append(char)\n        flipped = arr[::-1]\n        ans = 0\n        j = 0\n\n        for i in flipped:\n            ans = ans + (int(i) * (int(ybase) ** j))\n            j = j + 1\n        return ans\n\n\narrayfrom = []\narrayto = []\nis_base_possible = False\nnumber = input(\"Enter the number you would like to convert: \")\n\nwhile not is_base_possible:\n    base = input(\"What is the base of this number? \")\n    is_base_possible = base_check(number, base)\n    if not is_base_possible:\n        print(f\"The number {number} is not a base {base} number\")\n        base = input\n    else:\n        break\ndBase = input(\"What is the base you would like to convert to? \")\nif int(base) == 10:\n    convert_from_10(number, dBase, arrayfrom, base)\n    answer = arrayfrom[::-1]  # reverses the array\n    print(f\"In base {dBase} this number is: \")\n    print(*answer, sep=\"\")\nelif int(dBase) == 10:\n    answer = convert_to_10(number, dBase, arrayto, base)\n    print(f\"In base {dBase} this number is: {answer} \")\nelse:\n    number = convert_to_10(number, 10, arrayto, base)\n    convert_from_10(number, dBase, arrayfrom, base)\n    answer = arrayfrom[::-1]\n    print(f\"In base {dBase} this number is: \")\n    print(*answer, sep=\"\")\n"}
{"type": "source_file", "path": "Calendar (GUI).py", "content": "from tkinter import *\nimport calendar\n\nroot = Tk()\n# root.geometry(\"400x300\")\nroot.title(\"Calendar\")\n\n# Function\n\ndef text():\n    month_int = int(month.get())\n    year_int = int(year.get())\n    cal = calendar.month(year_int, month_int)\n    textfield.delete(0.0, END)\n    textfield.insert(INSERT, cal)\n\n\n# Creating Labels\nlabel1 = Label(root, text=\"Month:\")\nlabel1.grid(row=0, column=0)\n\nlabel2 = Label(root, text=\"Year:\")\nlabel2.grid(row=0, column=1)\n\n# Creating spinbox\nmonth = Spinbox(root, from_=1, to=12, width=8)\nmonth.grid(row=1, column=0, padx=5)\n\nyear = Spinbox(root, from_=2000, to=2100, width=10)\nyear.grid(row=1, column=1, padx=10)\n\n# Creating Button\nbutton = Button(root, text=\"Go\", command=text)\nbutton.grid(row=1, column=2, padx=10)\n\n# Creating Textfield\ntextfield = Text(root, width=25, height=10, fg=\"red\")\ntextfield.grid(row=2, columnspan=2)\n\n\nroot.mainloop()\n"}
{"type": "source_file", "path": "1 File handle/File handle text/input,output and error streams.py", "content": "# practicing with streams\r\nimport sys\r\n\r\nsys.stdout.write(\"Enter the name of the file\")\r\nfile = sys.stdin.readline()\r\n\r\nwith open(file.strip(), ) as F:\r\n\r\n    while True:\r\n        ch = F.readlines()\r\n        for (i) in ch:  # ch is the whole file,for i in ch gives lines, for j in i gives letters,for j in i.split gives words\r\n            print(i, end=\"\")\r\n        else:\r\n            sys.stderr.write(\"End of file reached\")\r\n            break\r\n\r\n"}
{"type": "source_file", "path": "CRC/crc.py", "content": "def crc_check(data, div):\r\n    l = len(div)\r\n    ct = 0\r\n    data = [int(i) for i in data]\r\n    div = [int(i) for i in div]\r\n    zero = [0 for i in range(l)]\r\n    temp_data = [data[i] for i in range(l)]\r\n    result = []\r\n    for j in range(len(data) - len(div) + 1):\r\n        print(\"Temp_dividend\", temp_data)\r\n        msb = temp_data[0]\r\n        if msb == 0:\r\n            result.append(0)\r\n            for i in range(l - 1, -1, -1):\r\n                temp_data[i] = temp_data[i] ^ zero[i]\r\n        else:\r\n            result.append(1)\r\n            for i in range(l - 1, -1, -1):\r\n                temp_data[i] = temp_data[i] ^ div[i]\r\n        temp_data.pop(0)\r\n        if l + j < len(data):\r\n            temp_data.append(data[l + j])\r\n    crc = temp_data\r\n    print(\"Quotient: \", result, \"remainder\", crc)\r\n    return crc\r\n\r\n\r\n# returning crc value\r\n\r\n\r\nwhile 1 > 0:\r\n    print(\"Enter data: \")\r\n    data = input()  # can use it like int(input())\r\n    print(\"Enter divisor\")\r\n    div = input()  # can use it like int(input())\r\n    original_data = data\r\n    data = data + (\"0\" * (len(div) - 1))\r\n    crc = crc_check(data, div)\r\n    crc_str = \"\"\r\n    for c in crc:\r\n        crc_str += c\r\n    print(\"Sent data: \", original_data + crc_str)\r\n    sent_data = original_data + crc_str\r\n    print(\r\n        \"If again applying CRC algorithm, the remainder/CRC must be zero if errorless.\"\r\n    )\r\n    crc = crc_check(sent_data, div)\r\n    remainder = crc\r\n    print(\"Receiver side remainder: \", remainder)\r\n    print(\"Continue [Y/N]:\")\r\n    ch = input()\r\n    if ch == \"N\" or ch == \"n\":\r\n        break\r\n    else:\r\n        continue\r\n"}
{"type": "source_file", "path": "BruteForce.py", "content": "from itertools import product\n\n\ndef findPassword(chars, function, show=50, format_=\"%s\"):\n\n    password = None\n    attempts = 0\n    size = 1\n    stop = False\n\n    while not stop:\n\n        # Obtém todas as combinações possíveis com os dígitos do parâmetro \"chars\".\n        for pw in product(chars, repeat=size):\n\n            password = \"\".join(pw)\n\n            # Imprime a senha que será tentada.\n            if attempts % show == 0:\n                print(format_ % password)\n\n            # Verifica se a senha é a correta.\n            if function(password):\n                stop = True\n                break\n            else:\n                attempts += 1\n        size += 1\n\n    return password, attempts\n\n\ndef getChars():\n    \"\"\"\n    Método para obter uma lista contendo todas as\n    letras do alfabeto e números.\n    \"\"\"\n    chars = []\n\n    # Acrescenta à lista todas as letras maiúsculas\n    for id_ in range(ord(\"A\"), ord(\"Z\") + 1):\n        chars.append(chr(id_))\n\n    # Acrescenta à lista todas as letras minúsculas\n    for id_ in range(ord(\"a\"), ord(\"z\") + 1):\n        chars.append(chr(id_))\n\n    # Acrescenta à lista todos os números\n    for number in range(10):\n        chars.append(str(number))\n\n    return chars\n\n\n# Se este módulo não for importado, o programa será testado.\n# Para realizar o teste, o usuário deverá inserir uma senha para ser encontrada.\n\nif __name__ == \"__main__\":\n\n    import datetime\n    import time\n\n    # Pede ao usuário uma senha\n    pw = input(\"\\n Type a password: \")\n    print(\"\\n\")\n\n    def testFunction(password):\n        global pw\n        if password == pw:\n            return True\n        else:\n            return False\n\n    # Obtém os dígitos que uma senha pode ter\n    chars = getChars()\n\n    t = time.process_time()\n\n    # Obtém a senha encontrada e o múmero de tentativas\n    password, attempts = findPassword(\n        chars, testFunction, show=1000, format_=\" Trying %s\"\n    )\n\n    t = datetime.timedelta(seconds=int(time.process_time() - t))\n    input(f\"\\n\\n Password found: {password}\\n Attempts: {attempts}\\n Time: {t}\\n\")\n"}
{"type": "source_file", "path": "BlackJack_game/blackjack.py", "content": "# master\n# master\n# BLACK JACK - CASINO A GAME OF FORTUNE!!!\nfrom time import sleep\n\n# BLACK JACK - CASINO\n# PYTHON CODE BASE\n\n\n# master\nimport random\n\ndeck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 11] * 4\n\nrandom.shuffle(deck)\n\nprint(f'{\"*\"*58} \\n Welcome to the game Casino - BLACK JACK ! \\n{\"*\"*58}')\nsleep(2)\nprint(\"So Finally You Are Here To Accept Your Fate\")\nsleep(2)\nprint(\"I Mean Your Fortune\")\nsleep(2)\nprint(\"Lets Check How Lucky You Are  Wish You All The Best\")\nsleep(2)\nprint(\"Loading---\")\nsleep(2)\n\nprint(\"Still Loading---\")\nsleep(2)\nprint(\n    \"So You Are Still Here Not Gone I Gave You Chance But No Problem May Be You Trust Your Fortune A Lot \\n Lets Begin Then\"\n)\nsleep(2)\nd_cards = []  # Initialising dealer's cards\np_cards = []  # Initialising player's cards\nsleep(2)\nwhile len(d_cards) != 2:\n    random.shuffle(deck)\n    d_cards.append(deck.pop())\n    if len(d_cards) == 2:\n        print(\"The cards dealer has are X \", d_cards[1])\n\n# Displaying the Player's cards\nwhile len(p_cards) != 2:\n    random.shuffle(deck)\n    p_cards.append(deck.pop())\n    if len(p_cards) == 2:\n        print(\"The total of player is \", sum(p_cards))\n        print(\"The cards Player has are  \", p_cards)\n\nif sum(p_cards) > 21:\n    print(f\"You are BUSTED !\\n  {'*'*14}Dealer Wins !!{'*'*14}\\n\")\n    exit()\n\nif sum(d_cards) > 21:\n    print(f\"Dealer is BUSTED !\\n   {'*'*14} You are the Winner !!{'*'*18}\\n\")\n    exit()\n\nif sum(d_cards) == 21:\n    print(f\"{'*'*24}Dealer is the Winner !!{'*'*14}\")\n    exit()\n\nif sum(d_cards) == 21 and sum(p_cards) == 21:\n    print(f\"{'*'*17}The match is tie !!{'*'*25}\")\n    exit()\n\n\n# function to show the dealer's choice\ndef dealer_choice():\n    if sum(d_cards) < 17:\n        while sum(d_cards) < 17:\n            random.shuffle(deck)\n            d_cards.append(deck.pop())\n\n    print(\"Dealer has total \" + str(sum(d_cards)) + \"with the cards \", d_cards)\n\n    if sum(p_cards) == sum(d_cards):\n        print(f\"{'*'*15}The match is tie !!{'*'*15}\")\n        exit()\n\n    if sum(d_cards) == 21:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*20}There is tie !!{'*'*26}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n    elif sum(d_cards) < 21:\n        if sum(p_cards) < 21 and sum(p_cards) < sum(d_cards):\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        if sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        if 21 > sum(p_cards) > sum(d_cards):\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n\n    else:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n\nwhile sum(p_cards) < 21:\n\n    # to continue the game again and again !!\n    k = input(\"Want to hit or stay?\\n Press 1 for hit and 0 for stay \")\n    if k == \"1\": #Ammended 1 to a string\n        random.shuffle(deck)\n        p_cards.append(deck.pop())\n        print(\"You have a total of \" + str(sum(p_cards)) + \" with the cards \", p_cards)\n        if sum(p_cards) > 21:\n            print(f'{\"*\"*13}You are BUSTED !{\"*\"*13}\\n Dealer Wins !!')\n        if sum(p_cards) == 21:\n            print(f'{\"*\"*19}You are the Winner !!{\"*\"*29}')\n\n    else:\n        dealer_choice()\n        break"}
{"type": "source_file", "path": "BoardGame-CLI/python.py", "content": "import random\n\n# Define the game board with snakes and ladders\nsnakes_and_ladders = {\n    2: 38, 7: 14, 8: 31, 15: 26, 16: 6, 21: 42,\n    28: 84, 36: 44, 46: 25, 49: 11, 51: 67, 62: 19,\n    64: 60, 71: 91, 74: 53, 78: 98, 87: 94, 89: 68,\n    92: 88, 95: 75, 99: 80\n}\n\n# Function to roll a six-sided die\ndef roll_die():\n    return random.randint(1, 6)\n\n# Function to simulate a single turn\ndef take_turn(current_position, player_name):\n    # Roll the die\n    roll_result = roll_die()\n    print(f\"{player_name} rolled a {roll_result}!\")\n\n    # Calculate the new position after the roll\n    new_position = current_position + roll_result\n\n    # Check if the new position is a ladder or a snake\n    if new_position in snakes_and_ladders:\n        new_position = snakes_and_ladders[new_position]\n        if new_position > current_position:\n            print(\"Ladder! Climb up!\")\n        else:\n            print(\"Snake! Slide down!\")\n\n    # Check if the new position exceeds the board size\n    if new_position >= 100:\n        new_position = 100\n        print(f\"Congratulations, {player_name} reached the final square!\")\n\n    return new_position\n\n# Main game loop\ndef play_snakes_and_ladders():\n    player1_position = 1\n    player2_position = 1\n\n    player1_name = input(\"Enter the name of Player 1: \")\n    player2_name = input(\"Enter the name of Player 2: \")\n\n    current_player = player1_name\n\n    while player1_position < 100 and player2_position < 100:\n        print(f\"\\n{current_player}'s turn:\")\n        input(\"Press Enter to roll the die.\")\n\n        if current_player == player1_name:\n            player1_position = take_turn(player1_position, player1_name)\n            current_player = player2_name\n        else:\n            player2_position = take_turn(player2_position, player2_name)\n            current_player = player1_name\n\n    print(\"\\nGame Over!\")\n    print(f\"{player1_name} ended at square {player1_position}.\")\n    print(f\"{player2_name} ended at square {player2_position}.\")\n    if player1_position == 100:\n        print(f\"{player1_name} won!\")\n    elif player2_position == 100:\n        print(f\"{player2_name} won!\")\n\n# Start the game\nplay_snakes_and_ladders()\n"}
{"type": "source_file", "path": "Calculator with simple ui.py", "content": "# Program make a simple calculator\n\n\nclass Calculator:\n    def __init__(self):\n        pass\n\n    def add(self, num1, num2):\n        \"\"\"\n        This function adds two numbers.\n\n        Examples:\n        >>> add(2, 3)\n        5\n        >>> add(5, 9)\n        14\n        >>> add(-1, 2)\n        1\n        \"\"\"\n        return num1 + num2\n\n    def subtract(self, num1, num2):\n        \"\"\"\n        This function subtracts two numbers.\n\n        Examples:\n        >>> subtract(5, 3)\n        2\n        >>> subtract(9, 5)\n        4\n        >>> subtract(4, 9)\n        -5\n        \"\"\"\n        return num1 - num2\n\n    def multiply(self, num1, num2):\n        \"\"\"\n        This function multiplies two numbers.\n\n        Examples:\n        >>> multiply(4, 2)\n        8\n        >>> multiply(3, 3)\n        9\n        >>> multiply(9, 9)\n        81\n        \"\"\"\n        return num1 * num2\n\n    def divide(self, num1, num2):\n        \"\"\"\n        This function divides two numbers.\n\n        Examples:\n        >>> divide(4, 4)\n        1\n        >>> divide(6, 3)\n        2\n        >>> divide(9, 1)\n        9\n        \"\"\"\n        if num2 == 0:\n            print(\"Cannot divide by zero\")\n        else:\n            return num1 / num2\n\n\ncalculator = Calculator()\n\n\nprint(\"1.Add\")\nprint(\"2.Subtract\")\nprint(\"3.Multiply\")\nprint(\"4.Divide\")\n\nwhile True:\n    # Take input from the user\n    choice = input(\"Enter choice(1/2/3/4): \")\n\n    # Check if choice is one of the four options\n    if choice in (\"1\", \"2\", \"3\", \"4\"):\n        num1 = float(input(\"Enter first number: \"))\n        num2 = float(input(\"Enter second number: \"))\n\n        if choice == \"1\":\n            print(calculator.add(num1, num2))\n\n        elif choice == \"2\":\n            print(calculator.subtract(num1, num2))\n\n        elif choice == \"3\":\n            print(calculator.multiply(num1, num2))\n\n        elif choice == \"4\":\n            print(calculator.divide(num1, num2))\n        break\n    else:\n        print(\"Invalid Input\")\n"}
{"type": "source_file", "path": "Checker_game_by_dz/first.py", "content": "\"\"\"\nAuthor : Dhruv B Kakadiya\n\n\"\"\"\n\n# import libraries\nimport pygame as pg\nfrom modules import statics as st\nfrom modules.statics import *\nfrom modules.checker_board import *\nfrom modules.checker import *\n\n# static variables for this perticular file\nfps = 60\n\nWIN = pg.display.set_mode((st.width, st.height))\npg.display.set_caption(\"Checkers\")\n\n# get row and col for mouse\ndef get_row_col_mouse(pos):\n    x, y = pos\n    row = y // sq_size\n    col = x // sq_size\n    return row, col\n\n\n# main function\nif __name__ == \"__main__\":\n\n    # represents the game\n    run = True\n\n    # certain clock value default because it is varries from diff pc to pc\n    clock = pg.time.Clock()\n\n    # create board\n    board = checker_board()\n    game = checker(WIN)\n\n    # main loop\n    while run:\n        clock.tick(fps)\n\n        if board.winner() != None:\n            print(board.winner())\n\n        # check if any events is running or not\n        for event in pg.event.get():\n            if event.type == pg.QUIT:\n                run = False\n\n            if event.type == pg.MOUSEBUTTONDOWN:\n                pos = pg.mouse.get_pos()\n                row, col = get_row_col_mouse(pos)\n                game.selectrc(row, col)\n                # piece = board.get_piece(row, col)\n                # board.move(piece, 4, 3)\n\n        game.update()\n    pg.quit()\n"}
{"type": "source_file", "path": "BlackJack_game/blackjack_rr.py", "content": "import random\n\n\nclass Colour:\n    BLACK = \"\\033[30m\"\n    RED = \"\\033[91m\"\n    GREEN = \"\\033[32m\"\n    END = \"\\033[0m\"\n\n\nsuits = (\n    Colour.RED + \"Hearts\" + Colour.END,\n    Colour.RED + \"Diamonds\" + Colour.END,\n    Colour.BLACK + \"Spades\" + Colour.END,\n    Colour.BLACK + \"Clubs\" + Colour.END,\n)\nranks = (\n    \"Two\",\n    \"Three\",\n    \"Four\",\n    \"Five\",\n    \"Six\",\n    \"Seven\",\n    \"Eight\",\n    \"Nine\",\n    \"Ten\",\n    \"Jack\",\n    \"Queen\",\n    \"King\",\n    \"Ace\",\n)\nvalues = {\n    \"Two\": 2,\n    \"Three\": 3,\n    \"Four\": 4,\n    \"Five\": 5,\n    \"Six\": 6,\n    \"Seven\": 7,\n    \"Eight\": 8,\n    \"Nine\": 9,\n    \"Ten\": 10,\n    \"Jack\": 10,\n    \"Queen\": 10,\n    \"King\": 10,\n    \"Ace\": 11,\n}\n\nplaying = True\n\n\nclass Card:\n    def __init__(self, suit, rank):\n        self.suit = suit\n        self.rank = rank\n\n    def __str__(self):\n        return self.rank + \" of \" + self.suit\n\n\nclass Deck:\n    def __init__(self):\n        self.deck = []\n        for suit in suits:\n            for rank in ranks:\n                self.deck.append(Card(suit, rank))\n\n    def __str__(self):\n        deck_comp = \"\"\n        for card in self.deck:\n            deck_comp += \"\\n \" + card.__str__()\n\n    def shuffle(self):\n        random.shuffle(self.deck)\n\n    def deal(self):\n        single_card = self.deck.pop()\n        return single_card\n\n\nclass Hand:\n    def __init__(self):\n        self.cards = []\n        self.value = 0\n        self.aces = 0  # to keep track of aces\n\n    def add_card(self, card):\n        self.cards.append(card)\n        self.value += values[card.rank]\n        if card.rank == \"Ace\":\n            self.aces += 1\n\n    def adjust_for_ace(self):\n        while self.value > 21 and self.aces:\n            self.value -= 10\n            self.aces -= 1\n\n\nclass Chips:\n    def __init__(self):\n        self.total = 100\n        self.bet = 0\n\n    def win_bet(self):\n        self.total += self.bet\n\n    def lose_bet(self):\n        self.total -= self.bet\n\n\ndef take_bet(chips):\n    while True:\n        try:\n            chips.bet = int(input(\"How many chips would you like to bet? \"))\n        except ValueError:\n            print(\"Your bet must be an integer! Try again.\")\n        else:\n            if chips.bet > chips.total or chips.bet <= 0:\n                print(\n                    \"Your bet cannot exceed your balance and you have to enter a positive bet! Your current balance is: \",\n                    chips.total,\n                )\n            else:\n                break\n\n\ndef hit(deck, hand):\n    hand.add_card(deck.deal())\n    hand.adjust_for_ace()\n\n\ndef hit_or_stand(deck, hand):\n    global playing\n\n    while True:\n        x = input(\"Would you like to Hit or Stand? Enter '1' or '0' \")\n\n        if x.lower() == \"1\":\n            hit(deck, hand)\n\n        elif x.lower() == \"0\":\n            print(\"You chose to stand. Dealer will hit.\")\n            playing = False\n\n        else:\n            print(\"Wrong input, please try again.\")\n            continue\n        break\n\n\ndef show_some(player, dealer):\n    print(\"\\nDealer's Hand:\")\n    print(\" { hidden card }\")\n    print(\"\", dealer.cards[1])\n    print(\"\\nYour Hand:\", *player.cards, sep=\"\\n \")\n\n\ndef show_all(player, dealer):\n    print(\"\\nDealer's Hand:\", *dealer.cards, sep=\"\\n \")\n    print(\"Dealer's Hand =\", dealer.value)\n    print(\"\\nYour Hand:\", *player.cards, sep=\"\\n \")\n    print(\"Your Hand =\", player.value)\n\n\ndef player_busts(player, dealer, chips):\n    print(\"You are BUSTED !\")\n    chips.lose_bet()\n\n\ndef player_wins(player, dealer, chips):\n    print(\"You are the winner!\")\n    chips.win_bet()\n\n\ndef dealer_busts(player, dealer, chips):\n    print(\"Dealer has BUSTED !\")\n    chips.win_bet()\n\n\ndef dealer_wins(player, dealer, chips):\n    print(\"Dealer is the winner!\")\n    chips.lose_bet()\n\n\ndef push(player, dealer):\n    print(\"The match is tie !\")\n\n\n# GAMEPLAY\nplayer_chips = Chips()\n\nwhile True:\n\n    print(\"\\t              **********************************************************\")\n    print(\n        \"\\t                       Welcome to the game Casino - BLACK JACK !                                                     \"\n    )\n    print(\"\\t              **********************************************************\")\n    print(Colour.BLACK + \"\\t                                   ***************\")\n    print(\"\\t                                   * A           *\")\n    print(\"\\t                                   *             *\")\n    print(\"\\t                                   *      *      *\")\n    print(\"\\t                                   *     ***     *\")\n    print(\"\\t                                   *    *****    *\")\n    print(\"\\t                                   *     ***     *\")\n    print(\"\\t                                   *      *      *\")\n    print(\"\\t                                   *             *\")\n    print(\"\\t                                   *             *\")\n    print(\"\\t                                   ***************\" + Colour.END)\n\n    print(\n        \"\\nRULES: Get as close to 21 as you can but if you get more than 21 you will lose!\\n  Aces count as 1 or 11.\"\n    )\n\n    deck = Deck()\n    deck.shuffle()\n\n    player_hand = Hand()\n    player_hand.add_card(deck.deal())\n    player_hand.add_card(deck.deal())\n\n    dealer_hand = Hand()\n    dealer_hand.add_card(deck.deal())\n    dealer_hand.add_card(deck.deal())\n\n    take_bet(player_chips)\n\n    show_some(player_hand, dealer_hand)\n\n    while playing:\n\n        hit_or_stand(deck, player_hand)\n        show_some(player_hand, dealer_hand)\n\n        if player_hand.value > 21:\n            player_busts(player_hand, dealer_hand, player_chips)\n            break\n\n    if player_hand.value <= 21:\n\n        while dealer_hand.value < 17:\n            hit(deck, dealer_hand)\n\n        show_all(player_hand, dealer_hand)\n\n        if dealer_hand.value > 21:\n            dealer_busts(player_hand, dealer_hand, player_chips)\n\n        elif dealer_hand.value > player_hand.value:\n            dealer_wins(player_hand, dealer_hand, player_chips)\n\n        elif dealer_hand.value < player_hand.value:\n            player_wins(player_hand, dealer_hand, player_chips)\n\n        else:\n            push(player_hand, dealer_hand)\n\n    print(\"\\nYour current balance stands at\", player_chips.total)\n\n    if player_chips.total > 0:\n        new_game = input(\"Would you like to play another hand? Enter '1' or '0' \")\n        if new_game.lower() == \"1\":\n            playing = True\n            continue\n        else:\n            print(\n                \"Thanks for playing!\\n\"\n                + Colour.GREEN\n                + \"\\t$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n \\t      Congratulations! You won \"\n                + str(player_chips.total)\n                + \" coins!\\n\\t$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n \"\n                + Colour.END\n            )\n            break\n    else:\n        print(\n            \"Oops! You have bet all your chips and we are sorry you can't play more.\\nThanks for playing! Do come again to Casino BLACK JACK!\"\n        )\n        break\n"}

{"repo_info": {"repo_name": "meta-aggregation-api", "repo_owner": "dex-guru", "repo_url": "https://github.com/dex-guru/meta-aggregation-api"}}
{"type": "test_file", "path": "meta_aggregation_api/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "meta_aggregation_api/tests/providers/test_one_inch_client.py", "content": "from unittest.mock import AsyncMock, patch\n\nimport pytest\nfrom aiohttp import ClientResponseError, RequestInfo\n\nfrom meta_aggregation_api.models.meta_agg_models import ProviderQuoteResponse\nfrom meta_aggregation_api.providers.one_inch_v5.one_inch_provider import (\n    LIMIT_ORDER_VERSION,\n)\nfrom meta_aggregation_api.utils.errors import AllowanceError, ParseResponseError\n\n\ndef test_build_limit_order_url(one_inch_provider):\n    version = 1\n    path = 'test_path'\n    endpoint = 'test_endpoint'\n    chain_id = 123\n    url = one_inch_provider._limit_order_path_builder(\n        version=version,\n        endpoint=endpoint,\n        path=path,\n        chain_id=chain_id,\n    )\n    assert (\n        str(url)\n        == f'https://{one_inch_provider.LIMIT_ORDERS_DOMAIN}/v{version}/{chain_id}/{path}/{endpoint}'\n    )\n\n\n@pytest.mark.asyncio()\n@patch(\n    'meta_aggregation_api.providers.one_inch_v5.OneInchProviderV5.get_response',\n    new_callable=AsyncMock,\n)\nasync def test_get_orders_by_trader(get_response_mock: AsyncMock, one_inch_provider):\n    get_response_mock.return_value = []\n    trader = 'test_trader'\n    maker_token = 'test_maker_token'\n    taker_token = 'test_taker_token'\n    chain_id = 1\n    path = 'address'\n    query = {\n        'limit': 100,\n        'page': 1,\n        'sortBy': 'createDateTime',\n        'makerAsset': maker_token,\n        'takerAsset': taker_token,\n    }\n    url = one_inch_provider._limit_order_path_builder(\n        LIMIT_ORDER_VERSION, path, trader, chain_id\n    )\n    await one_inch_provider.get_orders_by_trader(\n        chain_id=chain_id,\n        trader=trader,\n        maker_token=maker_token,\n        taker_token=taker_token,\n    )\n    get_response_mock.assert_awaited_with(url, query)\n\n\n@pytest.mark.asyncio()\n@patch(\n    'meta_aggregation_api.providers.one_inch_v5.OneInchProviderV5.get_response',\n    new_callable=AsyncMock,\n)\nasync def test_get_order_by_hash(get_response_mock: AsyncMock, one_inch_provider):\n    get_response_mock.return_value = []\n    order_hash = 'test_order_hash'\n    chain_id = 1\n    path = 'events'\n    query = None\n    url = one_inch_provider._limit_order_path_builder(\n        LIMIT_ORDER_VERSION, path, order_hash, chain_id\n    )\n    await one_inch_provider.get_order_by_hash(\n        chain_id=chain_id,\n        order_hash=order_hash,\n    )\n    get_response_mock.assert_awaited_with(url, query)\n\n\n@pytest.mark.asyncio()\nasync def test_get_swap_quote_raises(one_inch_provider):\n    with pytest.raises(ValueError, match='chain_id is required'):\n        await one_inch_provider.get_swap_quote(\n            chain_id=None,\n            buy_token='test_maker_token',\n            sell_token='test_taker_token',\n            sell_amount='test_maker_amount',\n            slippage_percentage=1,\n            taker_address='test_taker_address',\n        )\n    with pytest.raises(ValueError, match='Taker address is required'):\n        await one_inch_provider.get_swap_quote(\n            chain_id=1,\n            buy_token='test_maker_token',\n            sell_token='test_taker_token',\n            sell_amount='test_maker_amount',\n            slippage_percentage=1,\n            taker_address=None,\n        )\n\n\n@pytest.mark.asyncio()\n@patch(\n    'meta_aggregation_api.providers.one_inch_v5.OneInchProviderV5.get_response',\n    new_callable=AsyncMock,\n)\nasync def test_get_swap_quote(get_response_mock: AsyncMock, one_inch_provider):\n    get_response_mock.return_value = {\n        'toTokenAmount': 1,\n        'fromTokenAmount': 2,\n        'fromToken': {\n            'decimals': 18,\n        },\n        'toToken': {\n            'decimals': 18,\n        },\n        'protocols': [],\n        'tx': {\n            'gas': 3,\n            'to': 'test_to',\n            'value': 4,\n            'gasPrice': 5,\n            'data': 'test_data',\n        },\n    }\n    chain_id = 56\n    buy_token = 'test_maker_token'\n    sell_token = 'test_taker_token'\n    sell_amount = 1234\n    slippage_percentage = 1\n    taker_address = 'test_taker_address'\n    path = 'swap'\n    query = {\n        'toTokenAddress': buy_token,\n        'fromTokenAddress': sell_token,\n        'amount': sell_amount,\n        'slippage': slippage_percentage * 100,\n        'fromAddress': taker_address,\n        'disableEstimate': 'true',\n        'complexityLevel': 2,\n        'mainRouteParts': 10,\n        'parts': 50,\n        'virtualParts': 50,\n    }\n    url = one_inch_provider._trading_api_path_builder(path, chain_id)\n    res = await one_inch_provider.get_swap_quote(\n        chain_id=chain_id,\n        buy_token=buy_token,\n        sell_token=sell_token,\n        sell_amount=sell_amount,\n        slippage_percentage=slippage_percentage,\n        taker_address=taker_address,\n        ignore_checks=True,\n    )\n    get_response_mock.assert_awaited_with(url, query)\n    assert res\n    assert isinstance(res, ProviderQuoteResponse)\n\n\ndef test_handle_exception_key_error(one_inch_provider, caplog):\n    exc = one_inch_provider.handle_exception(KeyError('test'))\n    assert caplog.text\n    assert isinstance(exc, ParseResponseError)\n\n\ndef test_handle_exception_client_response_error(one_inch_provider, caplog):\n    exc = one_inch_provider.handle_exception(\n        ClientResponseError(\n            RequestInfo(url='abc', method='GET', headers=None),\n            None,\n            message='not enough allowance',\n        )\n    )\n    assert caplog.text\n    assert isinstance(exc, AllowanceError)\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/services/test_gas_service.py", "content": "from unittest import mock\nfrom unittest.mock import Mock, patch\n\nimport pytest\n\nfrom meta_aggregation_api.services.gas_service import GasService\n\n\n@pytest.mark.asyncio()\nasync def test_get_gas_price_eip_chain(\n    config,\n    gas_service: GasService,\n):\n    with (\n        mock.patch.object(gas_service, 'get_gas_prices_eip1559') as get_eip_gas_mock,\n        mock.patch.object(gas_service, 'get_gas_prices_legacy') as get_legacy_gas_mock,\n        mock.patch('meta_aggregation_api.clients.blockchain.web3_client.Web3Client'),\n    ):\n        await gas_service.get_gas_prices(1)\n        get_eip_gas_mock.assert_awaited_once()\n        get_legacy_gas_mock.assert_not_awaited()\n\n\n@pytest.mark.asyncio()\n@patch('meta_aggregation_api.services.gas_service.Web3Client')\nasync def test_get_gas_price_legacy_chain(\n    web3_mock: Mock,\n    gas_service: GasService,\n):\n    assert not gas_service.get_gas_prices.cache._cache\n    with (\n        mock.patch.object(gas_service, 'get_gas_prices_eip1559') as get_eip_gas_mock,\n        mock.patch.object(gas_service, 'get_gas_prices_legacy') as get_legacy_gas_mock,\n    ):\n        await gas_service.get_gas_prices(56)\n        get_eip_gas_mock.assert_not_awaited()\n        get_legacy_gas_mock.assert_awaited_once()\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/fixtures/aiohttp_session.py", "content": "import aiohttp\nimport pytest\n\n\n@pytest.fixture\ndef aiohttp_session():\n    return aiohttp.ClientSession()\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/services/conftest.py", "content": "import aiohttp\nimport pytest\n\nfrom meta_aggregation_api.config.providers import ProvidersConfig\nfrom meta_aggregation_api.providers import ProviderRegistry\nfrom meta_aggregation_api.providers.debridge_dln_v1 import DebridgeDlnProviderV1\nfrom meta_aggregation_api.providers.kyberswap_v1 import KyberSwapProviderV1\nfrom meta_aggregation_api.providers.one_inch_v5 import OneInchProviderV5\nfrom meta_aggregation_api.providers.openocean_v2 import OpenOceanProviderV2\nfrom meta_aggregation_api.providers.paraswap_v5 import ParaSwapProviderV5\nfrom meta_aggregation_api.providers.zerox_v1 import ZeroXProviderV1\nfrom meta_aggregation_api.services.gas_service import GasService\nfrom meta_aggregation_api.services.meta_aggregation_service import (\n    MetaAggregationService,\n)\n\n\n@pytest.fixture\nasync def gas_service(config, chains):\n    service = GasService(config=config, chains=chains)\n    await service.cached.cache.clear()\n    return service\n\n\n@pytest.fixture\ndef providers():\n    return ProvidersConfig()\n\n\n@pytest.fixture\nasync def meta_agg_service(\n    config,\n    chains,\n    gas_service: GasService,\n    providers,\n    apm_client,\n    provider_registry,\n) -> MetaAggregationService:\n    service = MetaAggregationService(\n        config=config,\n        chains=chains,\n        gas_service=gas_service,\n        providers=providers,\n        session=aiohttp.ClientSession(),\n        apm_client=apm_client,\n        provider_registry=provider_registry,\n        crosschain_provider_registry=provider_registry,\n    )\n    return service\n\n\n@pytest.fixture\ndef provider_registry(config, chains, apm_client, aiohttp_session):\n    return ProviderRegistry(\n        ZeroXProviderV1(\n            session=aiohttp_session,\n            config=config,\n            chains=chains,\n            apm_client=apm_client,\n        ),\n        OneInchProviderV5(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n        ),\n        ParaSwapProviderV5(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n        ),\n        OpenOceanProviderV2(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n        ),\n        KyberSwapProviderV1(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n            chains=chains,\n        ),\n        DebridgeDlnProviderV1(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n            chains=chains,\n        ),\n    )\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/conftest.py", "content": "import pytest\nfrom starlette.testclient import TestClient\n\nfrom meta_aggregation_api.clients.apm_client import ApmClient\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.models.chain import ChainModel, TokenModel\nfrom meta_aggregation_api.rest_api.create_app import create_app\nfrom meta_aggregation_api.services.chains import ChainsConfig\nfrom meta_aggregation_api.tests.fixtures import *  # noqa: F401, F403\n\n\n@pytest.fixture(scope='session')\ndef config():\n    return Config()\n\n\n@pytest.fixture()\ndef chains(config) -> ChainsConfig:\n    chains = ChainsConfig(config.PUBLIC_KEY, config.PUBLIC_API_DOMAIN)\n    chains.chains = {\n        'eth': ChainModel(\n            name='eth',\n            chain_id=1,\n            description='Ethereum',\n            eip1559=True,\n            native_token=TokenModel(\n                address='0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n                decimals=18,\n                name='Wrapped Ether',\n                symbol='WETH',\n            ),\n        ),\n        'bsc': ChainModel(\n            name='bsc',\n            chain_id=56,\n            description='Binance Smart Chain',\n            eip1559=False,\n            native_token=TokenModel(\n                address='0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c',\n                decimals=18,\n                name='Wrapped BNB',\n                symbol='WBNB',\n            ),\n        ),\n    }\n    return chains\n\n\n@pytest.fixture()\ndef trading_client(config) -> TestClient:\n    app = create_app(config=config)\n    return TestClient(app)\n\n\n@pytest.fixture\ndef apm_client(config):\n    return ApmClient(config=config)\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/fixtures/providers_clients.py", "content": "import pytest\n\nfrom meta_aggregation_api.providers.debridge_dln_v1 import DebridgeDlnProviderV1\nfrom meta_aggregation_api.providers.one_inch_v5.one_inch_provider import (\n    OneInchProviderV5,\n)\nfrom meta_aggregation_api.providers.paraswap_v5.paraswap_provider_v5 import (\n    ParaSwapProviderV5,\n)\nfrom meta_aggregation_api.providers.zerox_v1.zerox_provider import ZeroXProviderV1\n\n\n@pytest.fixture()\ndef one_inch_provider(aiohttp_session, config, apm_client):\n    return OneInchProviderV5(\n        session=aiohttp_session, config=config, apm_client=apm_client\n    )\n\n\n@pytest.fixture()\ndef zerox_provider(aiohttp_session, config, chains, apm_client):\n    return ZeroXProviderV1(\n        session=aiohttp_session, config=config, chains=chains, apm_client=apm_client\n    )\n\n\n@pytest.fixture()\ndef paraswap_provider(aiohttp_session, config, apm_client):\n    return ParaSwapProviderV5(\n        session=aiohttp_session, config=config, apm_client=apm_client\n    )\n\n@pytest.fixture()\ndef debridge_provider(aiohttp_session, config, apm_client):\n    return DebridgeDlnProviderV1(\n        session=aiohttp_session, config=config, apm_client=apm_client\n    )\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/providers/test_paraswap_client.py", "content": "from aiohttp import ClientResponseError, RequestInfo\n\nfrom meta_aggregation_api.utils.errors import AllowanceError, ParseResponseError\n\n\ndef test_handle_exception_key_error(paraswap_provider, caplog):\n    exc = paraswap_provider.handle_exception(KeyError('test'))\n    assert caplog.text\n    assert isinstance(exc, ParseResponseError)\n\n\ndef test_handle_exception_client_response_error(paraswap_provider, caplog):\n    exc = paraswap_provider.handle_exception(\n        ClientResponseError(\n            RequestInfo(url='abc', method='GET', headers=None),\n            None,\n            message='{\"error\": \"Not enough USD allowance\"}',\n        )\n    )\n    assert caplog.text\n    assert isinstance(exc, AllowanceError)\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/api/test_info_route.py", "content": "def test_get_info(trading_client):\n    response = trading_client.get('v1/info/0')\n    assert response.status_code == 404\n    assert response.json() == {'detail': 'Chain ID not found'}\n\n\ndef test_get_info_ok(trading_client):\n    response = trading_client.get('v1/info')\n    assert response.status_code == 200\n    response_data = response.json()\n    match response_data:\n        case [{'chain_id': 1, 'limit_order': list(), 'market_order': list()}, *_]:\n            pass\n        case _:\n            raise AssertionError(f'Unexpected response: {response_data}')\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/api/__init__.py", "content": ""}
{"type": "test_file", "path": "meta_aggregation_api/tests/services/__init__.py", "content": ""}
{"type": "test_file", "path": "meta_aggregation_api/tests/fixtures/__init__.py", "content": "from .aiohttp_session import aiohttp_session\nfrom .providers_clients import one_inch_provider, paraswap_provider, zerox_provider, debridge_provider\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/providers/test_validate_provider_configs.py", "content": "import json\nimport os\nfrom pathlib import Path\n\nimport pytest\nfrom jsonschema import validate\n\nSCHEMA_NAME = 'provider_config.schema.json'\nAPP_PATH = Path('meta_aggregation_api')\nCLIENTS_PATH = Path('providers')\n\n\n@pytest.fixture()\ndef get_schema():\n    with open(Path(APP_PATH, 'tests', CLIENTS_PATH, SCHEMA_NAME)) as f:\n        return json.load(f)\n\n\ndef test_validate_config_schema(get_schema):\n    for path, subdirs, files in os.walk(APP_PATH / CLIENTS_PATH):\n        for file in files:\n            if 'config.json' == file:\n                with open(Path(path, file)) as f:\n                    provider_config = json.load(f)\n                    validate(provider_config, get_schema)\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/providers/test_zero_x_client.py", "content": "from aiohttp import ClientResponseError, RequestInfo\n\nfrom meta_aggregation_api.utils.errors import (\n    AggregationProviderError,\n    ParseResponseError,\n)\n\n\ndef test_handle_exception_key_error(zerox_provider, caplog):\n    exc = zerox_provider.handle_exception(KeyError('test'))\n    assert caplog.text\n    assert isinstance(exc, ParseResponseError)\n\n\ndef test_handle_exception_client_response_error(zerox_provider, caplog):\n    exc = zerox_provider.handle_exception(\n        ClientResponseError(\n            RequestInfo(url='abc', method='GET', headers=None),\n            None,\n            message='not enough allowance',\n        )\n    )\n    assert caplog.text\n    assert isinstance(exc, AggregationProviderError)\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/providers/test_debridge_dln_client.py", "content": "from unittest.mock import AsyncMock, patch\n\nimport pytest\n\nfrom meta_aggregation_api.models.meta_agg_models import ProviderQuoteResponse, ProviderPriceResponse\n\n@pytest.mark.skip(reason='Not implemented')\n@pytest.mark.asyncio()\n@patch(\n    'meta_aggregation_api.providers.debridge_dln_v1.DebridgeDlnProviderV1._get_response',\n\n    new_callable=AsyncMock,\n)\nasync def test_get_swap_quote(get_response_mock: AsyncMock, debridge_provider):\n    get_response_mock.return_value = {\n        \"tx\": {\n            \"value\": \"101000000000000000\",\n            \"data\": \"0x4d8160ba0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000001111111254fb6c44bac0bed2854e76f90643097d0000000000000000000000000000000000000000000000000000000000000160000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000009c39d0a000000000000000000000000e5164dde788a150bee9e4efeeb37ab774edd618b000000000000000000000000ef4fb24ad0916217251f553c0596f8edc630eb660000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002687c0252000000000000000000000000007122db0ebe4eb9b434a9f2ffe6760bc03bfbd0e000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000180000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000007122db0ebe4eb9b434a9f2ffe6760bc03bfbd0e0000000000000000000000000663dc15d3c1ac63ff12e45ab68fea3f0a883c251000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000000000000000000000000000000000000009c39d0900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bb00000000000000000000000000000000000000000000000000007d00001a4041c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2d0e30db002a00000000000000000000000000000000000000000000000000000000009abdaefee63c1e58088e6a0c2ddd26feeb64f039a2c41296fcb3f5640c02aaa39b223fe8d0a0e5c4f27ead9083c756cc21111111254fb6c44bac0bed2854e76f90643097d000000000000000000000000000000000000000000000000016345785d8a00000000000000a36e5de70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000344fbe16ca70000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000320000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000009c39d0a000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000896aae84327ae380f000000000000000000000000000000000000000000000000000000000000003800000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000e5164dde788a150bee9e4efeeb37ab774edd618b00000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000002600000000000000000000000000000000000000000000000000000000000000014e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000000000000000000000000000000000000000000000000000000000000000000014e5164dde788a150bee9e4efeeb37ab774edd618b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000014e5164dde788a150bee9e4efeeb37ab774edd618b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n            \"to\": \"0x663DC15D3C1aC63ff12E45Ab68FeA3F0a883C251\",\n            \"gasLimit\": 1000\n        },\n        \"estimation\": {\n            \"srcChainTokenIn\": {\n              \"address\": \"0x0000000000000000000000000000000000000000\",\n              \"decimals\": 18,\n              \"name\": \"ETH\",\n              \"symbol\": \"ETH\",\n              \"chainId\": 1,\n              \"amount\": \"104036134770989096\"\n            },\n            \"dstChainTokenOut\": {\n              \"address\": \"0xe9e7cea3dedca5984780bafc599bd69add087d56\",\n              \"decimals\": 18,\n              \"name\": \"BUSD Token\",\n              \"symbol\": \"BUSD\",\n              \"chainId\": 56,\n              \"amount\": \"162924600212540696080\",\n              \"recommendedAmount\": \"162924600212540696080\"\n            },\n          }\n    }\n    give_chain_id = 56\n    take_chain_id = 1\n    buy_token = 'test_maker_token'\n    sell_token = 'test_taker_token'\n    sell_amount = 1234\n    slippage_percentage = 1\n    taker_address = 'test_taker_address'\n    query = {\n        'srcChainId': give_chain_id,\n        'srcChainTokenIn': sell_token,\n        'srcChainTokenInAmount': sell_amount,\n        'dstChainId': take_chain_id,\n        'dstChainTokenOut': buy_token,\n        'affiliateFeePercent': 0,\n        'dstChainTokenOutAmount': 'auto',\n        'dstChainTokenOutRecipient': taker_address,\n        'srcChainOrderAuthorityAddress': taker_address,\n        'dstChainOrderAuthorityAddress': taker_address,\n    }\n    res = await debridge_provider.get_swap_quote(\n        chain_id_from=give_chain_id,\n        chain_id_to=take_chain_id,\n        buy_token=buy_token,\n        sell_token=sell_token,\n        sell_amount=sell_amount,\n        slippage_percentage=slippage_percentage,\n        taker_address=taker_address,\n    )\n    get_response_mock.assert_awaited_with('https://api.dln.trade/v1.0/dln/order/create-tx', query)\n    assert res\n    assert isinstance(res, ProviderQuoteResponse)\n\n@pytest.mark.skip(reason='Not implemented')\n@pytest.mark.asyncio()\n@patch(\n    'meta_aggregation_api.providers.debridge_dln_v1.DebridgeDlnProviderV1._get_response',\n\n    new_callable=AsyncMock,\n)\nasync def test_get_swap_price(get_response_mock: AsyncMock, debridge_provider):\n    get_response_mock.return_value = {\n        \"estimation\": {\n            \"srcChainTokenIn\": {\n              \"address\": \"0x0000000000000000000000000000000000000000\",\n              \"decimals\": 18,\n              \"name\": \"ETH\",\n              \"symbol\": \"ETH\",\n              \"chainId\": 1,\n              \"amount\": \"104036134770989096\",\n            },\n            \"dstChainTokenOut\": {\n              \"address\": \"0xe9e7cea3dedca5984780bafc599bd69add087d56\",\n              \"decimals\": 18,\n              \"name\": \"BUSD Token\",\n              \"symbol\": \"BUSD\",\n              \"chainId\": 56,\n              \"amount\": \"162924600212540696080\",\n              \"recommendedAmount\": \"162924600212540696080\"\n            },\n          }\n    }\n    give_chain_id = 56\n    take_chain_id = 1\n    buy_token = 'test_maker_token'\n    sell_token = 'test_taker_token'\n    sell_amount = 1234\n    slippage_percentage = 1\n    taker_address = 'test_taker_address'\n    query = {\n        'srcChainId': give_chain_id,\n        'srcChainTokenIn': sell_token,\n        'srcChainTokenInAmount': sell_amount,\n        'dstChainId': take_chain_id,\n        'dstChainTokenOut': buy_token,\n        'affiliateFeePercent': 0,\n        'prependOperatingExpenses': 'false',\n    }\n    res = await debridge_provider.get_swap_price(\n        chain_id_from=give_chain_id,\n        chain_id_to=take_chain_id,\n        buy_token=buy_token,\n        sell_token=sell_token,\n        sell_amount=sell_amount,\n        slippage_percentage=slippage_percentage,\n    )\n    get_response_mock.assert_awaited_with('https://api.dln.trade/v1.0/dln/order/quote', query)\n    assert res\n    assert isinstance(res, ProviderPriceResponse)\n"}
{"type": "test_file", "path": "meta_aggregation_api/tests/providers/__init__.py", "content": ""}
{"type": "test_file", "path": "meta_aggregation_api/tests/services/test_meta_aggregation_service.py", "content": "from decimal import Decimal\nfrom typing import Callable\nfrom unittest.mock import AsyncMock, Mock, patch\n\nimport pytest\nfrom web3 import Web3\n\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.config.providers import ProvidersConfig\nfrom meta_aggregation_api.models.meta_agg_models import ProviderPriceResponse\nfrom meta_aggregation_api.services.meta_aggregation_service import (\n    MetaAggregationService,\n)\nfrom meta_aggregation_api.utils.errors import ProviderNotFound\n\n\n@pytest.mark.asyncio()\nasync def test_get_token_allowance(meta_agg_service: MetaAggregationService):\n    contract_mock = Mock()\n    allowance_mock: Mock = contract_mock.functions.allowance\n    allowance_mock.return_value.call = AsyncMock()\n    call_mock = allowance_mock.return_value.call\n\n    token_address = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'\n    owner_address = '0x61e1A8041186CeB8a561F6F264e8B2BB2E20e06D'\n    spender_address = '0xdef1c0ded9bec7f1a1670819833240f027b25eff'\n\n    await meta_agg_service.get_token_allowance(\n        token_address=token_address,\n        owner_address=owner_address,\n        spender_address=spender_address,\n        erc20_contract=contract_mock,\n    )\n    allowance_mock.assert_called_with(\n        Web3.toChecksumAddress(owner_address),\n        Web3.toChecksumAddress(spender_address),\n    )\n    call_mock.assert_awaited_once_with({'to': Web3.toChecksumAddress(token_address)})\n\n\n@pytest.mark.asyncio()\nasync def test_get_token_allowance_for_native_token(\n    config: Config, meta_agg_service: MetaAggregationService\n):\n    contract_mock = Mock()\n    allowance_mock: Mock = contract_mock.functions.allowance\n    allowance_mock.return_value.call = AsyncMock()\n\n    token_address = config.NATIVE_TOKEN_ADDRESS\n    owner_address = '0x61e1A8041186CeB8a561F6F264e8B2BB2E20e06D'\n    spender_address = '0xdef1c0ded9bec7f1a1670819833240f027b25eff'\n\n    allowance = await meta_agg_service.get_token_allowance(\n        token_address=token_address,\n        owner_address=owner_address,\n        spender_address=spender_address,\n        erc20_contract=contract_mock,\n    )\n    allowance_mock.assert_not_called()\n    assert allowance == 2**256 - 1\n\n\n@pytest.mark.asyncio()\nasync def test_get_approve_cost(meta_agg_service: MetaAggregationService):\n    owner_address = '0x61e1A8041186CeB8a561F6F264e8B2BB2E20e06D'\n    spender_address = '0xdef1c0ded9bec7f1a1670819833240f027b25eff'\n\n    contract_mock = Mock()\n    approve_mock = contract_mock.functions.approve\n    approve_mock.return_value.estimate_gas = AsyncMock()\n    estimate_gas_mock = approve_mock.return_value.estimate_gas\n\n    await meta_agg_service.get_approve_cost(\n        owner_address, spender_address, contract_mock\n    )\n    approve_mock.assert_called_once_with(\n        Web3.toChecksumAddress(spender_address),\n        2**256 - 1,\n    )\n    estimate_gas_mock.assert_called_once_with(\n        {'from': Web3.toChecksumAddress(owner_address)},\n    )\n\n\n@pytest.mark.asyncio()\n@pytest.mark.parametrize('sell_amount, approve_called', ((10000, True), (1, False)))\nasync def test_get_approve_costs_per_provider(\n    sell_amount: int,\n    approve_called: bool,\n    meta_agg_service: MetaAggregationService,\n    providers: ProvidersConfig,\n):\n    chain_id = 1\n    sell_token = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'\n    taker_address = '0x61e1A8041186CeB8a561F6F264e8B2BB2E20e06D'\n    erc20_contract = Mock()\n    allowance_patcher = patch.object(meta_agg_service, 'get_token_allowance')\n    approve_patcher = patch.object(meta_agg_service, 'get_approve_cost')\n    allowance_mock = allowance_patcher.start()\n    approve_mock = approve_patcher.start()\n    allowance_mock.return_value = 10\n    providers_ = providers.get_providers_on_chain(chain_id)['market_order']\n    await meta_agg_service.get_approve_costs_per_provider(\n        sell_token, erc20_contract, sell_amount, providers_, taker_address\n    )\n    allowance_mock.assert_called()\n    if approve_called:\n        assert approve_mock.call_count == len(providers_)\n    else:\n        approve_mock.assert_not_called()\n\n\n@pytest.mark.asyncio()\nasync def test_get_approve_cost_per_provider_no_taker(\n    providers, meta_agg_service: MetaAggregationService\n):\n    sell_token = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'\n    erc20_contract = Mock()\n    taker_address = None\n    sell_amount = 10000\n    providers_ = providers.get_providers_on_chain(1)['market_order']\n    approves = await meta_agg_service.get_approve_costs_per_provider(\n        sell_token, erc20_contract, sell_amount, providers_, taker_address\n    )\n    assert erc20_contract.functions.approve.call_count == 0\n    for approve in approves.values():\n        assert approve == 0\n\n\n@pytest.mark.asyncio()\n@patch(\n    'meta_aggregation_api.providers.zerox_v1.ZeroXProviderV1.get_swap_price',\n    new_callable=AsyncMock,\n)\n@patch(\n    'meta_aggregation_api.providers.one_inch_v5.OneInchProviderV5.get_swap_price',\n    new_callable=AsyncMock,\n)\nasync def test_get_swap_meta_price_no_price(\n    one_inch_mock: AsyncMock,\n    zerox_mock: AsyncMock,\n    aiohttp_session,\n    meta_agg_service: MetaAggregationService,\n):\n    \"\"\"Test that get_swap_meta_quote raise exc if no quote is found.\"\"\"\n    zerox_mock.return_value = None\n    one_inch_mock.return_value = None\n    approve_patcher = patch.object(meta_agg_service, 'get_approve_costs_per_provider')\n    approve_patcher.start()\n    test_str = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'\n    test_str_2 = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'\n    test_int = 1\n    res = await meta_agg_service.get_swap_meta_price(\n            test_str,\n            test_str_2,\n            test_int,\n            test_int,\n            test_int,\n            test_int,\n            test_str,\n            test_str,\n            None,\n        )\n    assert res == []\n\n\n@pytest.mark.asyncio()\n@patch(\n    'meta_aggregation_api.services.meta_aggregation_service.DexGuru.get_token_inventory_by_address',\n    new_callable=AsyncMock,\n)\n@pytest.mark.parametrize(\n    'get_token_address, call_count',\n    (\n        (lambda _: 'test_token', 1),\n        (lambda config: config.NATIVE_TOKEN_ADDRESS, 0),\n        (lambda _: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', 0),\n    ),\n)\nasync def test_get_decimals_for_native_and_buy_token_call_count(\n    get_token_mock: AsyncMock,\n    get_token_address: Callable[[Config], str],\n    call_count: int,\n    config,\n    meta_agg_service: MetaAggregationService,\n):\n    token_address = get_token_address(config)\n    await meta_agg_service.get_decimals_for_native_and_buy_token(1, token_address)\n    assert get_token_mock.call_count == call_count\n\n\n@pytest.mark.parametrize(\n    'buy_amount_1__gas_1__gas_price_1__approve_cost_1,buy_amount_2__gas_2__gas_price_2__approve_cost_2,expected_provider',\n    (\n        (('1', '1', '1', '0'), ('2', '3', '1', '0'), 'provider_2'),\n        (('10', '1', '1', '15'), ('10', '1', '1', '10'), 'provider_2'),\n        (('10', '2', '1', '0'), ('9', '1', '1', '0'), 'provider_1'),\n        ((15, 1, 1, 0), (30, 1, 1, 10), 'provider_2'),\n        ((20, 4, 2, 0), (10, 1, 1, 0), 'provider_1'),\n        ((20, 600, 2, 0), (10, 1, 1, 0), 'provider_1'),\n    ),\n)\ndef test_choose_best_provider(\n    buy_amount_1__gas_1__gas_price_1__approve_cost_1,\n    buy_amount_2__gas_2__gas_price_2__approve_cost_2,\n    expected_provider,\n    meta_agg_service: MetaAggregationService,\n):\n    token_price_native = 1000\n    provider_1 = 'provider_1'\n    provider_2 = 'provider_2'\n    (\n        buy_amount_1,\n        gas_1,\n        gas_price_1,\n        approve_cost_1,\n    ) = buy_amount_1__gas_1__gas_price_1__approve_cost_1\n    (\n        buy_amount_2,\n        gas_2,\n        gas_price_2,\n        approve_cost_2,\n    ) = buy_amount_2__gas_2__gas_price_2__approve_cost_2\n    quote_1 = ProviderPriceResponse(\n        provider=provider_1,\n        sources=[],\n        buy_amount=Decimal(str(buy_amount_1)) * 2,\n        gas=gas_1,\n        gas_price=gas_price_1,\n        value=1,\n        price=1,\n        sell_amount=1,\n    )\n    quote_2 = ProviderPriceResponse(\n        provider=provider_2,\n        sources=[],\n        buy_amount=Decimal(str(buy_amount_2)) * 2,\n        gas=gas_2,\n        gas_price=gas_price_2,\n        value=1,\n        price=1,\n        sell_amount=1,\n    )\n    approve_costs = {provider_1: approve_cost_1, provider_2: approve_cost_2}\n    quotes = {provider_1: quote_1, provider_2: quote_2}\n    res = meta_agg_service.choose_best_provider(\n        quotes,\n        approve_costs,\n        native_decimals=1,\n        buy_token_decimals=1,\n        buy_token_price=token_price_native,\n    )\n    assert res == (expected_provider, quotes[expected_provider])\n\n\n@pytest.mark.asyncio()\nasync def test_get_meta_swap_quote(meta_agg_service: MetaAggregationService):\n    provider = 'invalid_provider'\n    with pytest.raises(ProviderNotFound):\n        await meta_agg_service.get_meta_swap_quote(\n            provider=provider,\n            sell_token='test',\n            buy_token='test',\n            sell_amount=1,\n            chain_id=1,\n            taker_address='test',\n        )\n"}
{"type": "source_file", "path": "meta_aggregation_api/config/apm.py", "content": "from pydantic import BaseSettings\n\n\nclass APMConfig(BaseSettings):\n    APM_SERVER_URL: str = 'http://localhost:8200'\n    SERVICE_NAME: str = 'meta-aggregation-api'\n    APM_ENABLED: bool = False\n    APM_RECORDING: bool = False\n    APM_CAPTURE_HEADERS: bool = False\n    LOG_LEVEL: str = 'off'\n    ENVIRONMENT: str = 'dev'\n"}
{"type": "source_file", "path": "meta_aggregation_api/clients/blockchain/__init__.py", "content": ""}
{"type": "source_file", "path": "meta_aggregation_api/config/logger.py", "content": "from pydantic import BaseSettings\n\n\nclass LoggerConfig(BaseSettings):\n    LOGGING_LEVEL: str = 'INFO'\n    LOGSTASH_LOGGING_LEVEL: str = 'DEBUG'\n    LOG_HANDLERS: list = ['console']\n    LOGSTASH: str = 'logstash-logstash.logging.svc.cluster.local'\n    PORT: int = 5959\n"}
{"type": "source_file", "path": "meta_aggregation_api/config/__init__.py", "content": "from urllib.parse import urljoin\n\nfrom pydantic import BaseSettings, HttpUrl\n\nfrom meta_aggregation_api.config.apm import APMConfig\nfrom meta_aggregation_api.config.auth import AuthConfig\nfrom meta_aggregation_api.config.cache import CacheConfig\nfrom meta_aggregation_api.config.logger import LoggerConfig\n\n\nclass Config(APMConfig, LoggerConfig, AuthConfig, CacheConfig, BaseSettings):\n    SERVER_HOST: str = 'localhost'\n    SERVER_PORT: int = 8000\n    RELOAD: bool = True\n    NATIVE_TOKEN_ADDRESS = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'\n    VERSION = '0.0.1'\n    PUBLIC_KEY = 'Get your key at https://developers.dex.guru'\n    PUBLIC_API_DOMAIN: HttpUrl = 'https://api.dev.dex.guru'\n    API_VERSION = 1\n    WEB3_TIMEOUT: int = 10\n    CORS_ORIGINS = ['*']\n    CORS_CREDENTIALS = True\n    CORS_METHODS = ['*']\n    CORS_HEADERS = ['*']\n    WORKERS_COUNT: int = 1\n    PARTNER: str = 'dex.guru'\n    X_SYS_KEY: str = ''\n    ONE_INCH_API_KEY: str = ''\n    BEBOP_API_KEY: str = ''\n    RPC_URL: HttpUrl = ''\n\n    def get_web3_url(self, chain_id: int):\n        if self.RPC_URL:\n            return f'{self.RPC_URL}/{chain_id}'\n\n        return urljoin(self.PUBLIC_API_DOMAIN, f'{chain_id}/{self.PUBLIC_KEY}')\n\n    class Config:\n        env_file = \".env\"\n"}
{"type": "source_file", "path": "meta_aggregation_api/models/gas_models.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Eip1559Model(BaseModel):\n    max_fee: int\n    base_fee: int\n    max_priority_fee: int\n\n\nclass GasPriceEip1559Model(BaseModel):\n    fast: Eip1559Model\n    instant: Eip1559Model\n    overkill: Eip1559Model\n\n\nclass LegacyGasPriceModel(BaseModel):\n    fast: int\n    instant: int\n    overkill: int\n\n\nclass GasResponse(BaseModel):\n    source: str\n    timestamp: int\n    eip1559: Optional[GasPriceEip1559Model] = None\n    legacy: LegacyGasPriceModel = None\n"}
{"type": "source_file", "path": "meta_aggregation_api/clients/__init__.py", "content": ""}
{"type": "source_file", "path": "meta_aggregation_api/config/auth.py", "content": "from fastapi_jwt_auth import AuthJWT\nfrom pydantic import BaseSettings\n\n\nclass AuthConfig(BaseSettings):\n    authjwt_secret_key: str = 'secretkey'\n\n\n@AuthJWT.load_config\ndef get_config():\n    return AuthConfig()\n"}
{"type": "source_file", "path": "meta_aggregation_api/__init__.py", "content": ""}
{"type": "source_file", "path": "meta_aggregation_api/models/provider_response_models.py", "content": "from pydantic import BaseModel\n\nfrom meta_aggregation_api.utils.common import camel_to_snake\n\n\nclass SwapSources(BaseModel):\n    name: str\n    proportion: float  # Percentage.\n\n    def __init__(self, **data):\n        data['name'] = camel_to_snake(data['name'])\n        data['name'] = ''.join(word.capitalize() for word in data['name'].split('_'))\n        super().__init__(**data)\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/base_crosschain_provider.py", "content": "import asyncio\nfrom abc import ABC, abstractmethod\nfrom typing import Optional\n\nimport aiohttp\nfrom pydantic import ValidationError\n\nfrom meta_aggregation_api.clients.apm_client import ApmClient\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.models.meta_agg_models import (\n    ProviderPriceResponse,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.utils.errors import (\n    BaseAggregationProviderError,\n    ParseResponseError,\n    ProviderTimeoutError,\n)\nfrom meta_aggregation_api.utils.logger import capture_exception\n\n\nclass CrossChainProvider(ABC):\n    PROVIDER_NAME = 'base_crosschain_provider'\n    REQUEST_TIMEOUT = 7\n\n    def __init__(\n        self,\n        session: aiohttp.ClientSession,\n        config: Config,\n        apm_client: ApmClient,\n        **_,\n    ):\n        self.apm_client = apm_client\n        self.aiohttp_session = session\n        self.config = config\n\n    @abstractmethod\n    def is_require_gas_price(self) -> bool:\n        pass\n\n\n    @abstractmethod\n    async def get_swap_quote(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id_from: int,\n        chain_id_to: int,\n        taker_address: str,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n    ) -> ProviderQuoteResponse:\n        \"\"\"\n        The get_swap_quote function is used to get the data for a swap from the provider.\n        Args:\n            self: Access the class attributes\n            buy_token:str: Token is being buy\n            sell_token:str: Token is being sold\n            sell_amount:int: Amount of sell_token to sell\n            chain_id_from:int: Specify the chain on which the transaction will be executed, a chain where the cross-chain swap will start\n            chain_id_to:int: chain where the cross-chain swap will finish\n            taker_address:str: Address who makes the transaction and will receive tokens\n            gas_price:Optional[int]=None: Specify the gas price for the transaction\n            slippage_percentage:Optional[float]=None: Specify the percentage of slippage to apply to the quote\n            fee_recipient:Optional[str]=None: Address who will receive the fee\n            buy_token_percentage_fee:Optional[float]=None: Percentage of the buy_token fee that will be paid to the fee_recipient\n\n        Returns:\n            A ProviderQuoteResponse object with the data for the swap. Check return type for more info.\n        \"\"\"\n\n    @abstractmethod\n    async def get_swap_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id_from: int,\n        chain_id_to: int,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        taker_address: Optional[str] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n    ) -> ProviderPriceResponse:\n        \"\"\"\n        The get_swap_price function is used to find the best price for a swap from the provider.\n        It doesn't require the taker_address to be specified.\n        Args:\n            self: Access the class attributes\n            buy_token:str: Token is being buy\n            sell_token:str: Token is being sold\n            sell_amount:int: Amount of sell_token to sell\n            chain_id_from:int: Specify the chain on which the transaction will be executed, a chain where the cross-chain swap will start\n            chain_id_to:int: chain where the cross-chain swap will finish\n            gas_price:Optional[int]=None: Specify the gas price for the transaction\n            slippage_percentage:Optional[float]=None: Specify the percentage of slippage to apply to the quote\n            taker_address:Optional[str]=None: Address who makes the transaction and will receive tokens\n            fee_recipient:Optional[str]=None: Address who will receive the fee\n            buy_token_percentage_fee:Optional[float]=None: Percentage of the buy_token fee that will be paid to the fee_recipient\n\n        Returns:\n            A ProviderPriceResponse object with the price for the swap. Check return type for more info.\n        \"\"\"\n\n    def handle_exception(\n        self, exception: Exception, **kwargs\n    ) -> BaseAggregationProviderError:\n        capture_exception(self.apm_client)\n        if isinstance(exception, (KeyError, ValidationError)):\n            exc = ParseResponseError(self.PROVIDER_NAME, str(exception), **kwargs)\n            return exc\n        if isinstance(\n            exception, (aiohttp.ServerDisconnectedError, asyncio.TimeoutError)\n        ):\n            exc = ProviderTimeoutError(self.PROVIDER_NAME, str(exception), **kwargs)\n            return exc\n"}
{"type": "source_file", "path": "meta_aggregation_api/clients/blockchain/web3_client.py", "content": "from pathlib import Path\nfrom typing import Optional, Type, Union\n\nimport ujson\nfrom web3 import Web3\nfrom web3.contract import AsyncContract\nfrom web3.eth import AsyncEth\nfrom web3.middleware import async_geth_poa_middleware\nfrom web3.net import AsyncNet\n\nfrom meta_aggregation_api.clients.blockchain.custom_http_provider import (\n    AsyncCustomHTTPProvider,\n)\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.utils.logger import get_logger\n\nERC20_ABI_PATH = Path(__file__).parent / 'abi' / 'ERC20.json'\n\nlogger = get_logger(__name__)\n\n\nclass Web3Client:\n    def __init__(self, uri: str, config: Config):\n        self.w3 = Web3(\n            AsyncCustomHTTPProvider(endpoint_uri=uri, config=config),\n            modules={\n                \"eth\": (AsyncEth,),\n                \"net\": (AsyncNet,),\n            },\n            middlewares=[],\n        )\n        self.w3.middleware_onion.inject(async_geth_poa_middleware, layer=0)\n\n        with open(ERC20_ABI_PATH) as fh:\n            self.erc20_abi = ujson.load(fh)\n\n    def get_erc20_contract(\n        self, address: Optional[str] = None\n    ) -> Union[Type[AsyncContract], AsyncContract]:\n        params = {'abi': self.erc20_abi}\n        if address:\n            params['address'] = Web3.toChecksumAddress(address)\n        return self.w3.eth.contract(**params)\n"}
{"type": "source_file", "path": "meta_aggregation_api/__main__.py", "content": "import logging.config\n\nimport uvicorn\n\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.rest_api.create_app import create_app\nfrom meta_aggregation_api.utils import logger\n\n\ndef __getattr__(name):\n    if name == 'app':\n        config = Config()\n        logging.config.dictConfig(logger.config(config))\n        app = create_app(config)\n        return app\n\n    raise AttributeError(name)\n\n\ndef main() -> None:\n    \"\"\"Entrypoint of the application.\"\"\"\n    config = Config()\n    uvicorn.run(\n        'meta_aggregation_api.__main__:app',\n        workers=config.WORKERS_COUNT,\n        host=config.SERVER_HOST,\n        port=config.SERVER_PORT,\n        reload=config.RELOAD,\n        log_level=config.LOGGING_LEVEL.lower(),\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "meta_aggregation_api/config/providers.py", "content": "import os\nfrom collections import defaultdict\nfrom pathlib import Path\n\nimport ujson\n\n\nclass ProvidersConfig:\n    def __init__(self) -> None:\n        for path, _, files in os.walk(Path(__file__).parent.parent / 'providers'):\n            for file in files:\n                if 'config.json' == file:\n                    with open(Path(path, file)) as f:\n                        provider_config = ujson.load(f)\n                        if not provider_config.get('enabled'):\n                            continue\n                        self.__dict__[provider_config['name']] = provider_config\n                        for spender in provider_config['spenders']:\n                            self.__dict__[provider_config['name']][\n                                spender['chain_id']\n                            ] = spender\n                        self.__dict__[provider_config['name']].pop('spenders')\n\n    def __iter__(self):\n        return iter(self.__dict__)\n\n    def items(self):\n        return self.__dict__.items()\n\n    def keys(self):\n        return self.__dict__.keys()\n\n    def values(self):\n        return self.__dict__.values()\n\n    def get_providers_on_chain(self, chain_id: int) -> dict:\n        providers_on_chain = {\n            'market_order': [],\n            'limit_order': [],\n        }\n        for provider in self.values():\n            if chain_id in provider:\n                if provider[chain_id]['market_order']:\n                    providers_on_chain['market_order'].append(\n                        {\n                            'display_name': provider['display_name'],\n                            'address': provider[chain_id]['market_order'],\n                            'name': provider['name'],\n                        }\n                    )\n                if provider[chain_id]['limit_order']:\n                    providers_on_chain['limit_order'].append(\n                        {\n                            'display_name': provider['display_name'],\n                            'address': provider[chain_id]['limit_order'],\n                            'name': provider['name'],\n                        }\n                    )\n        if (\n            not providers_on_chain['market_order']\n            and not providers_on_chain['limit_order']\n        ):\n            raise ValueError(f'Chain ID {chain_id} not found')\n        return providers_on_chain\n\n    def get_all_providers(self) -> list[dict]:\n        provider_on_chains = defaultdict(\n            lambda: defaultdict(limit_order=[], market_order=[])\n        )\n        for provider in self.values():\n            for chain in provider.values():\n                if not isinstance(chain, dict):\n                    continue\n\n                if chain.get('market_order'):\n                    provider_on_chains[chain['chain_id']]['market_order'].append(\n                        {\n                            'display_name': provider['display_name'],\n                            'address': chain['market_order'],\n                            'name': provider['name'],\n                        }\n                    )\n                if chain.get('limit_order'):\n                    provider_on_chains[chain['chain_id']]['limit_order'].append(\n                        {\n                            'display_name': provider['display_name'],\n                            'address': chain['limit_order'],\n                            'name': provider['name'],\n                        }\n                    )\n        return [\n            {'chain_id': chain, **item} for chain, item in provider_on_chains.items()\n        ]\n"}
{"type": "source_file", "path": "meta_aggregation_api/clients/apm_client.py", "content": "from typing import Optional\n\nfrom elasticapm.base import Client\nfrom elasticapm.contrib.starlette import make_apm_client\n\nfrom meta_aggregation_api.config import Config\n\n\nclass ApmClient:\n    def __init__(self, config: Config):\n        self.client: Optional[Client] = None\n        self._make_apm_client(config)\n\n    def _make_apm_client(self, config: Config) -> Client:\n        if self.client:\n            return self.client\n        apm_config = {\n            'SERVICE_NAME': config.SERVICE_NAME,\n            'SERVER_URL': config.APM_SERVER_URL,\n            'ENABLED': config.APM_ENABLED,\n            'RECORDING': config.APM_RECORDING,\n            'CAPTURE_HEADERS': config.APM_CAPTURE_HEADERS,\n            'LOG_LEVEL': config.LOG_LEVEL,\n            'ENVIRONMENT': config.ENVIRONMENT,\n            'SERVICE_VERSION': config.VERSION,\n            'CAPTURE_BODY': 'all',\n        }\n        self.client = make_apm_client(apm_config)\n        return self.client\n"}
{"type": "source_file", "path": "meta_aggregation_api/models/chain.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel, conint, constr\n\n\nclass TokenModel(BaseModel):\n    address: constr(to_lower=True)\n    name: str\n    symbol: str\n    decimals: conint(gt=0)\n\n\nclass ChainModel(BaseModel):\n    name: str\n    chain_id: int\n    description: str\n    native_token: TokenModel = None\n    eip1559: bool\n\n\nclass ProviderInfoModel(BaseModel):\n    display_name: str\n    address: constr(to_lower=True)\n    name: str\n\n\nclass ProvidersConfigModel(BaseModel):\n    limit_order: list[ProviderInfoModel]\n    market_order: list[ProviderInfoModel]\n\n\nclass AllProvidersConfigModel(ProvidersConfigModel, BaseModel):\n    chain_id: Optional[int] = None\n\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/base_provider.py", "content": "import asyncio\nfrom abc import ABC, abstractmethod\nfrom typing import Optional\n\nimport aiohttp\nfrom pydantic import ValidationError\n\nfrom meta_aggregation_api.clients.apm_client import ApmClient\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.models.meta_agg_models import (\n    ProviderPriceResponse,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.utils.errors import (\n    BaseAggregationProviderError,\n    ParseResponseError,\n    ProviderTimeoutError,\n)\nfrom meta_aggregation_api.utils.logger import capture_exception\n\n\nclass BaseProvider(ABC):\n    PROVIDER_NAME = 'base_provider'\n    REQUEST_TIMEOUT = 7\n\n    def __init__(\n        self,\n        session: aiohttp.ClientSession,\n        config: Config,\n        apm_client: ApmClient,\n        **_,\n    ):\n        self.apm_client = apm_client\n        self.aiohttp_session = session\n        self.config = config\n\n    @abstractmethod\n    async def get_swap_quote(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        taker_address: str,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        **kwargs,\n    ) -> ProviderQuoteResponse:\n        \"\"\"\n        The get_swap_quote function is used to get the data for a swap from the provider.\n        Args:\n            self: Access the class attributes\n            buy_token:str: Token is being buy\n            sell_token:str: Token is being sold\n            sell_amount:int: Amount of sell_token to sell\n            chain_id:int: Specify the chain on which the transaction will be executed\n            taker_address:str: Address who makes the transaction and will receive tokens\n            gas_price:Optional[int]=None: Specify the gas price for the transaction\n            slippage_percentage:Optional[float]=None: Specify the percentage of slippage to apply to the quote\n            fee_recipient:Optional[str]=None: Address who will receive the fee\n            buy_token_percentage_fee:Optional[float]=None: Percentage of the buy_token fee that will be paid to the fee_recipient\n\n        Returns:\n            A ProviderQuoteResponse object with the data for the swap. Check return type for more info.\n        \"\"\"\n\n    @abstractmethod\n    async def get_swap_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        taker_address: Optional[str] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        **kwargs,\n    ) -> ProviderPriceResponse:\n        \"\"\"\n        The get_swap_price function is used to find the best price for a swap from the provider.\n        It doesn't require the taker_address to be specified.\n        Args:\n            self: Access the class attributes\n            buy_token:str: Token is being buy\n            sell_token:str: Token is being sold\n            sell_amount:int: Amount of sell_token to sell\n            chain_id:int: Specify the chain on which the transaction will be executed\n            gas_price:Optional[int]=None: Specify the gas price for the transaction\n            slippage_percentage:Optional[float]=None: Specify the percentage of slippage to apply to the quote\n            taker_address:Optional[str]=None: Address who makes the transaction and will receive tokens\n            fee_recipient:Optional[str]=None: Address who will receive the fee\n            buy_token_percentage_fee:Optional[float]=None: Percentage of the buy_token fee that will be paid to the fee_recipient\n\n        Returns:\n            A ProviderPriceResponse object with the price for the swap. Check return type for more info.\n        \"\"\"\n\n    def handle_exception(\n        self, exception: Exception, **kwargs\n    ) -> BaseAggregationProviderError:\n        capture_exception(self.apm_client)\n        if isinstance(exception, (KeyError, ValidationError)):\n            exc = ParseResponseError(self.PROVIDER_NAME, str(exception), **kwargs)\n            return exc\n        if isinstance(\n            exception, (aiohttp.ServerDisconnectedError, asyncio.TimeoutError)\n        ):\n            exc = ProviderTimeoutError(self.PROVIDER_NAME, str(exception), **kwargs)\n            return exc\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/one_inch_v5/one_inch_provider.py", "content": "import asyncio\nimport re\nimport ssl\nfrom itertools import chain\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Union\n\nimport aiohttp\nimport ujson\nfrom aiocache import cached\nfrom aiohttp import ClientResponse, ClientResponseError, ServerDisconnectedError\nfrom pydantic import ValidationError\nfrom yarl import URL\n\nfrom meta_aggregation_api.clients.apm_client import ApmClient\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.models.meta_agg_models import (\n    ProviderPriceResponse,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.models.provider_response_models import SwapSources\nfrom meta_aggregation_api.providers.base_provider import BaseProvider\nfrom meta_aggregation_api.utils.cache import get_cache_config\nfrom meta_aggregation_api.utils.errors import (\n    AggregationProviderError,\n    AllowanceError,\n    BaseAggregationProviderError,\n    EstimationError,\n    InsufficientLiquidityError,\n    TokensError,\n    UserBalanceError,\n)\nfrom meta_aggregation_api.utils.logger import LogArgs, get_logger\n\nLIMIT_ORDER_VERSION = 3.0\nDEFAULT_SLIPPAGE_PERCENTAGE = 0.5\n\nONE_INCH_ERRORS = {\n    'insufficient liquidity': InsufficientLiquidityError,\n    'cannot estimate': EstimationError,\n    'fromtokenaddress cannot be equals to totokenaddress': TokensError,\n    'not enough \\w+ balance': UserBalanceError,\n    'not enough allowance': AllowanceError,\n    'cannot sync \\w+': TokensError,\n}\n\nMAX_RESULT_PRESET = {\n    'complexityLevel': 2,\n    'mainRouteParts': 10,\n    'parts': 50,\n    'virtualParts': 50,\n}\n\nLOWEST_GAS_PRESET = {\n    'complexityLevel': 1,\n    'mainRouteParts': 1,\n    'parts': 1,\n    'virtualParts': 1,\n}\n\nAMM_MAPPING = {\n    'SUSHI': 'SushiSwap',\n}\n\nlogger = get_logger(__name__)\n\n\nclass OneInchProviderV5(BaseProvider):\n    \"\"\"\n    Trading and limit orders Provider for 1Inch. Docs: https://docs.1inch.io/docs/1inch-network-overview\n\n    URL structures:\n        Trading:      https://{trading_api_domain}/v{version}/{chain_id}/{operation}?queryParams\n        Limit orders: https://{limit_orders_domain}/v{version}/{chain_id}/limit_order/{operation}?queryParams\n    \"\"\"\n\n    LIMIT_ORDERS_DOMAIN = 'api.1inch.dev/orderbook'\n    TRADING_API_DOMAIN = 'api.1inch.dev/swap'\n    TRADING_API_VERSION = 5.0\n    with open(Path(__file__).parent / 'config.json') as f:\n        PROVIDER_NAME = ujson.load(f)['name']\n\n    def __init__(\n        self,\n        *,\n        config: Config,\n        session: aiohttp.ClientSession,\n        apm_client: ApmClient,\n        **_,\n    ) -> None:\n        super().__init__(config=config, session=session, apm_client=apm_client)\n        self.api_key = self.config.ONE_INCH_API_KEY\n        self.get_swap_price = cached(\n            ttl=30, **get_cache_config(self.config), noself=True\n        )(self.get_swap_price)\n\n    @classmethod\n    def _limit_order_path_builder(\n        cls,\n        version: Union[int, float],\n        path: str,\n        endpoint: str,\n        chain_id: int,\n    ) -> URL:\n        url = (\n            URL(f'https://{cls.LIMIT_ORDERS_DOMAIN}')\n            / f'v{version}'\n            / str(chain_id)\n            / path\n            / endpoint\n        )\n        return url\n\n    @classmethod\n    def _trading_api_path_builder(\n        cls,\n        path: str,\n        chain_id: int,\n    ) -> URL:\n        url = (\n            URL(f'https://{cls.TRADING_API_DOMAIN}')\n            / f'v{cls.TRADING_API_VERSION}'\n            / str(chain_id)\n            / path\n        )\n        return url\n\n    async def get_response(\n        self,\n        url: URL,\n        params: Optional[Dict],\n        method: str = 'GET',\n        body: Optional[Dict] = None,\n    ) -> Union[List, Dict]:\n        request_function = getattr(self.aiohttp_session, method.lower())\n        async with request_function(\n            str(url),\n            params=params,\n            timeout=self.REQUEST_TIMEOUT,\n            ssl=ssl.SSLContext(),\n            json=body,\n            headers={'Authorization': 'Bearer ' + self.api_key},\n        ) as response:\n            response: ClientResponse\n            logger.debug(f'Request GET {response.url}')\n            data = await response.read()\n            if not data:\n                return {}\n            data = ujson.loads(data)\n            try:\n                response.raise_for_status()\n            except ClientResponseError as e:\n                # Fix bug with HTTP status code 0.\n                status = 500 if e.status not in range(100, 600) else e.status\n                data['source'] = 'proxied 1inch API'\n                raise ClientResponseError(\n                    request_info=e.request_info,\n                    history=e.history,\n                    status=status,\n                    # Hack for error init method: expected str, but list and dict also works.\n                    message=[data],\n                    headers=e.headers,\n                )\n\n        return data\n\n    async def get_orders_by_trader(\n        self,\n        *,\n        chain_id: Optional[int],\n        trader: str,\n        maker_token: Optional[str] = None,\n        taker_token: Optional[str] = None,\n        statuses: Optional[List[str]] = None,\n    ) -> List[Optional[Dict]]:\n        \"\"\"\n        Docs: https://limit-orders.1inch.exchange/swagger/ethereum/#/default/ModuleController_getLimitOrder\n        \"\"\"\n        path = 'address'\n        endpoint = trader\n        url = self._limit_order_path_builder(\n            version=LIMIT_ORDER_VERSION,\n            endpoint=endpoint,\n            path=path,\n            chain_id=chain_id,\n        )\n        query = {\n            'limit': 100,\n            'page': 1,\n            'sortBy': 'createDateTime',\n        }\n        if maker_token:\n            query['makerAsset'] = maker_token\n        if taker_token:\n            query['takerAsset'] = taker_token\n        if statuses:\n            query['statuses'] = statuses\n        try:\n            response = await self.get_response(url, query)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            e = self.handle_exception(e, params=query, wallet=trader)\n            raise e\n        return response\n\n    async def get_order_by_hash(\n        self,\n        chain_id: Optional[int],\n        order_hash: str,\n    ) -> Optional[Dict[str, List[Dict]]]:\n        path = 'events'\n        endpoint = order_hash\n        url = self._limit_order_path_builder(\n            version=LIMIT_ORDER_VERSION,\n            endpoint=endpoint,\n            path=path,\n            chain_id=chain_id,\n        )\n        try:\n            response = await self.get_response(url, None)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            e = self.handle_exception(e)\n            raise e\n        return response\n\n    async def post_limit_order(\n        self,\n        chain_id: Optional[int],\n        order_hash: str,\n        signature: str,\n        data: Dict,\n    ):\n        method = 'POST'\n        path = ''\n        endpoint = ''\n        url = self._limit_order_path_builder(\n            version=LIMIT_ORDER_VERSION,\n            endpoint=endpoint,\n            path=path,\n            chain_id=chain_id,\n        )\n        body = {\n            'orderHash': order_hash,\n            'signature': signature,\n            'data': data,\n        }\n        try:\n            response = await self.get_response(url, None, method, body)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            e = self.handle_exception(e)\n            raise e\n        return response\n\n    async def get_swap_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: Optional[int] = None,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = 1,\n        taker_address: Optional[str] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        **_,\n    ):\n        path = 'quote'\n        url = self._trading_api_path_builder(\n            path=path,\n            chain_id=chain_id,\n        )\n        query = {\n            'toTokenAddress': buy_token,\n            'fromTokenAddress': sell_token,\n            'amount': sell_amount,\n        }\n        if gas_price:\n            query['gasPrice'] = str(gas_price)\n\n        if buy_token_percentage_fee:\n            query['fee'] = buy_token_percentage_fee\n        query.update(MAX_RESULT_PRESET)\n        try:\n            response = await self.get_response(url, query)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            e = self.handle_exception(\n                e, params=query, token_address=sell_token, chain_id=chain_id\n            )\n            raise e\n        sell_amount = int(sell_amount) / 10 ** response['fromToken']['decimals']\n        buy_amount = (\n            int(response['toTokenAmount']) / 10 ** response['toToken']['decimals']\n        )\n        price = buy_amount / sell_amount\n        value = '0'\n        if sell_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            value = str(sell_amount)\n        try:\n            sources = self.convert_sources_for_meta_aggregation(response['protocols'])\n            res = ProviderPriceResponse(\n                provider=self.PROVIDER_NAME,\n                sources=sources,\n                buy_amount=response['toTokenAmount'],\n                gas=response['estimatedGas'],\n                sell_amount=response['fromTokenAmount'],\n                gas_price=gas_price if gas_price else '0',\n                value=value,\n                price=price,\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(\n                e,\n                response=response,\n                method='_convert_response_from_swap_quote',\n                price=price,\n                url=url,\n                params=query,\n                chain_id=chain_id,\n            )\n            raise e\n        return res\n\n    async def get_swap_quote(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        taker_address: Optional[str] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        ignore_checks: bool = False,\n        **_,\n    ) -> Optional[ProviderQuoteResponse]:\n        \"\"\"https://docs.1inch.io/docs/aggregation-protocol/api/swap-params\"\"\"\n        if not chain_id:\n            raise ValueError('chain_id is required')\n\n        if not slippage_percentage:\n            slippage_percentage = DEFAULT_SLIPPAGE_PERCENTAGE\n        else:\n            slippage_percentage = (\n                slippage_percentage * 100\n            )  # 1inch awaits slippage in percents\n        if not taker_address:\n            raise ValueError('Taker address is required')\n\n        path = 'swap'\n        url = self._trading_api_path_builder(\n            path=path,\n            chain_id=chain_id,\n        )\n        ignore_checks = str(ignore_checks).lower()\n        query = {\n            'fromTokenAddress': sell_token,\n            'toTokenAddress': buy_token,\n            'amount': sell_amount,\n            'fromAddress': taker_address,\n            'slippage': slippage_percentage,\n            'disableEstimate': ignore_checks,\n        }\n        if gas_price:\n            query['gasPrice'] = gas_price\n\n        if fee_recipient:\n            query['referrerAddress'] = fee_recipient\n\n        if buy_token_percentage_fee:\n            query['fee'] = buy_token_percentage_fee\n        query.update(MAX_RESULT_PRESET)\n        try:\n            response = await self.get_response(url, query)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            exc = self.handle_exception(\n                e, params=query, token_address=sell_token, chain_id=chain_id\n            )\n            raise exc\n        sell_amount = int(sell_amount) / 10 ** response['fromToken']['decimals']\n        buy_amount = (\n            int(response['toTokenAmount']) / 10 ** response['toToken']['decimals']\n        )\n        price = buy_amount / sell_amount\n        return self._convert_response_from_swap_quote(\n            response, price, url=url, query=query\n        )\n\n    def _convert_response_from_swap_quote(\n        self,\n        response: dict,\n        price: float,\n        **kwargs,\n    ) -> Optional[ProviderQuoteResponse]:\n        sources = self.convert_sources_for_meta_aggregation(response['protocols'])\n        try:\n            prepared_response = ProviderQuoteResponse(\n                sources=sources,\n                buy_amount=response['toTokenAmount'],\n                gas=response['tx']['gas'],\n                sell_amount=response['fromTokenAmount'],\n                to=response['tx']['to'],\n                data=response['tx']['data'],\n                gas_price=response['tx']['gasPrice'],\n                value=response['tx']['value'],\n                price=str(price),\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(\n                e,\n                response=response,\n                method='_convert_response_from_swap_quote',\n                price=price,\n                **kwargs,\n            )\n            raise e\n        else:\n            return prepared_response\n\n    @staticmethod\n    def convert_sources_for_meta_aggregation(\n        sources: Optional[dict | list[dict]],\n    ) -> list[SwapSources]:\n        if not sources:\n            return []\n        sources_list = list(chain.from_iterable(chain.from_iterable(sources)))\n        converted_sources = []\n        for source in sources_list:\n            source['name'] = AMM_MAPPING.get(source['name'], source['name'])\n            converted_sources.append(\n                SwapSources(name=source['name'], proportion=source['part'])\n            )\n        return converted_sources\n\n    def handle_exception(\n        self,\n        exception: Union[ClientResponseError, KeyError, ValidationError],\n        **kwargs,\n    ) -> BaseAggregationProviderError:\n        \"\"\"\n        exception.message: [\n            {\"code\": 400, \"description\": \"cannot estimate\"}\n        ]\n        \"\"\"\n        exc = super().handle_exception(exception, **kwargs)\n        if exc:\n            logger.error(*exc.to_log_args(), extra=exc.to_dict())\n            return exc\n        msg = exception.message\n        if isinstance(exception.message, list) and isinstance(\n            exception.message[0], dict\n        ):\n            msg = exception.message[0].get(\n                'description',\n                exception.message[0].get(\n                    'message', exception.message[0].get('error', '')\n                ),\n            )\n        for error, error_class in ONE_INCH_ERRORS.items():\n            if re.search(error.lower(), msg.lower()):\n                break\n        else:\n            error_class = AggregationProviderError\n        exc = error_class(\n            self.PROVIDER_NAME,\n            msg,\n            url=str(exception.request_info.url),\n            **kwargs,\n        )\n        if isinstance(exc, EstimationError):\n            logger.warning(\n                f'potentially blacklist. %({LogArgs.token_idx})s',\n                {\n                    LogArgs.token_idx: f'{kwargs.get(\"token_address\")}-{kwargs.get(\"chain_id\")}'\n                },\n                extra={\n                    'token_address': kwargs.get('token_address'),\n                    'chain_id': kwargs.get('chain_id'),\n                },\n            )\n        logger.warning(*exc.to_log_args(), extra=exc.to_dict())\n        return exc\n"}
{"type": "source_file", "path": "meta_aggregation_api/clients/blockchain/custom_http_provider.py", "content": "\"\"\"\nCustom implementation of sync and async HTTP providers.\nMajority of the code was copied and adapted from Web3 library.\n\"\"\"\nimport ssl\nimport threading\nfrom typing import Any\n\nimport requests\nfrom aiohttp import ClientSession, TCPConnector\nfrom eth_typing import URI\nfrom lru import LRU\nfrom requests.adapters import HTTPAdapter\nfrom urllib3 import Retry\nfrom web3 import AsyncHTTPProvider, HTTPProvider\nfrom web3.types import RPCEndpoint, RPCResponse\n\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.utils.logger import LogArgs, get_logger\n\n_logger = get_logger(__name__)\n\n\ndef _on_session_evicted_from_cache(cache_key, session: requests.Session) -> None:\n    session.close()\n    log_args = {LogArgs.web3_url: cache_key, LogArgs.cache_size: len(_session_cache)}\n    _logger.info(\n        f\"Closed http session: %({LogArgs.web3_url})s\", log_args, extra=log_args\n    )\n\n\ndef _on_async_session_evicted_from_cache(cache_key, session: ClientSession) -> None:\n    session.close()\n    log_args = {\n        LogArgs.web3_url: cache_key,\n        LogArgs.cache_size: len(_async_session_cache),\n    }\n    _logger.info(\n        f\"Closed async http session: %({LogArgs.web3_url})s\", log_args, extra=log_args\n    )\n\n\n_session_cache_lock = threading.Lock()\n_session_cache = LRU(100, callback=_on_session_evicted_from_cache)\n\n_async_session_cache_lock = threading.Lock()\n_async_session_cache = LRU(100, callback=_on_async_session_evicted_from_cache)\n\n\ndef _get_session(endpoint_uri: URI) -> requests.Session:\n    cache_key = endpoint_uri\n    if cache_key not in _session_cache:\n        session = requests.Session()\n        http_adapter = HTTPAdapter(\n            max_retries=Retry(connect=5, read=3), pool_connections=32, pool_maxsize=32\n        )\n        session.mount(\"https://\", http_adapter)\n        session.mount(\"http://\", http_adapter)\n        with _session_cache_lock:\n            _session_cache[cache_key] = session\n            log_args = {\n                LogArgs.web3_url: cache_key,\n                LogArgs.cache_size: len(_session_cache),\n            }\n            _logger.info(\n                f\"Created http session: %({LogArgs.web3_url})s\",\n                log_args,\n                extra=log_args,\n            )\n\n    return _session_cache[cache_key]\n\n\nasync def _get_async_session(endpoint_uri: URI) -> ClientSession:\n    cache_key = endpoint_uri\n    if cache_key not in _async_session_cache:\n        connector = TCPConnector(limit=32)\n        session = ClientSession(connector=connector, raise_for_status=True)\n        # note: there is no retry support like in requests, see https://github.com/aio-libs/aiohttp/issues/3133\n        with _async_session_cache_lock:\n            _async_session_cache[cache_key] = session\n            log_args = {\n                LogArgs.web3_url: cache_key,\n                LogArgs.cache_size: len(_async_session_cache),\n            }\n            _logger.info(\n                f\"Created async http session: %({LogArgs.web3_url})s\",\n                log_args,\n                extra=log_args,\n            )\n\n    return _async_session_cache[cache_key]\n\n\ndef _make_post_request(\n    endpoint_uri: URI,\n    data: bytes,\n    config: Config,\n    *args: Any,\n    **kwargs: Any,\n) -> bytes:\n    kwargs.setdefault(\"timeout\", config.WEB3_TIMEOUT)\n    session = _get_session(endpoint_uri)\n    response = session.post(endpoint_uri, data=data, *args, **kwargs)\n    response.raise_for_status()\n\n    return response.content\n\n\nasync def _async_make_post_request(\n    endpoint_uri: URI,\n    data: bytes,\n    config: Config,\n    **kwargs: Any,\n) -> bytes:\n    kwargs.setdefault(\"timeout\", config.WEB3_TIMEOUT)\n    session = await _get_async_session(endpoint_uri)\n    async with session.post(endpoint_uri, data=data, **kwargs) as response:\n        response.raise_for_status()\n        return await response.read()\n\n\nclass CustomHTTPProvider(HTTPProvider):\n    def __init__(self, endpoint_uri: URI, config: Config, *args: Any, **kwargs: Any):\n        super().__init__(endpoint_uri, *args, **kwargs)\n        self.config = config\n\n    def make_request(self, method: RPCEndpoint, params: Any) -> RPCResponse:\n        self.logger.debug(\n            \"Making request HTTP. URI: %s, Method: %s\", self.endpoint_uri, method\n        )\n        request_data = self.encode_rpc_request(method, params)\n        raw_response = _make_post_request(\n            self.endpoint_uri,\n            request_data,\n            self.config,\n            **self.get_request_kwargs()\n            # type: ignore # see to_dict decorator on the method\n        )\n        response = self.decode_rpc_response(raw_response)\n        self.logger.debug(\n            \"Getting response HTTP. URI: %s, \" \"Method: %s, Response: %s\",\n            self.endpoint_uri,\n            method,\n            response,\n        )\n        return response\n\n\nclass AsyncCustomHTTPProvider(AsyncHTTPProvider):\n    def __init__(self, endpoint_uri: URI, config: Config, *args: Any, **kwargs: Any):\n        super().__init__(endpoint_uri, *args, **kwargs)\n        self.config = config\n\n    async def make_request(self, method: RPCEndpoint, params: Any) -> RPCResponse:\n        self.logger.debug(\n            \"Making request HTTP. URI: %s, Method: %s\", self.endpoint_uri, method\n        )\n        request_data = self.encode_rpc_request(method, params)\n        raw_response = await _async_make_post_request(\n            self.endpoint_uri,\n            request_data,\n            self.config,\n            **self.get_request_kwargs(),\n            # type: ignore # see to_dict decorator on the method\n            ssl=ssl.SSLContext(),\n        )\n        response = self.decode_rpc_response(raw_response)\n        self.logger.debug(\n            \"Getting response HTTP. URI: %s, \" \"Method: %s, Response: %s\",\n            self.endpoint_uri,\n            method,\n            response,\n        )\n        return response\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/__init__.py", "content": "from typing import TypeVar\n\nfrom meta_aggregation_api.providers.base_crosschain_provider import CrossChainProvider\nfrom meta_aggregation_api.providers.base_provider import BaseProvider\n\nT = TypeVar(\"T\")\n\n\nclass ProviderRegistry:\n    def __init__(self, *providers: BaseProvider | CrossChainProvider):\n        self.provider_by_name = {\n            provider.PROVIDER_NAME: provider for provider in providers\n        }\n\n    def __getitem__(self, provider_name: str) -> BaseProvider | CrossChainProvider:\n        return self.provider_by_name[provider_name]\n\n    def get(self, provider_name: str,\n            default: T = None) -> BaseProvider | CrossChainProvider | T:\n        return self.provider_by_name.get(provider_name, default)\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/one_inch_v5/__init__.py", "content": "from .one_inch_provider import OneInchProviderV5\n"}
{"type": "source_file", "path": "meta_aggregation_api/models/__init__.py", "content": ""}
{"type": "source_file", "path": "meta_aggregation_api/providers/kyberswap_v1/kyberswap_provider_v1.py", "content": "import asyncio\nimport ssl\nfrom _decimal import Decimal\nfrom pathlib import Path\nfrom typing import Optional, Union\n\nimport aiohttp\nimport ujson\nfrom aiocache import cached\nfrom aiohttp import ClientResponse, ClientResponseError, ServerDisconnectedError\nfrom pydantic import ValidationError\n\nfrom meta_aggregation_api.clients.apm_client import ApmClient\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.models.meta_agg_models import (\n    ProviderPriceResponse,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.models.provider_response_models import SwapSources\nfrom meta_aggregation_api.providers.base_provider import BaseProvider\nfrom meta_aggregation_api.services.chains import ChainsConfig\nfrom meta_aggregation_api.utils.cache import get_cache_config\nfrom meta_aggregation_api.utils.errors import (\n    AggregationProviderError,\n    BaseAggregationProviderError,\n)\nfrom meta_aggregation_api.utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nCHAIN_ID_TO_NETWORK = {\n    1: 'ethereum',\n    56: 'bsc',\n    137: 'polygon',\n    10: 'optimism',\n    42161: 'arbitrum',\n    43114: 'avalanche',\n    250: 'fantom',\n    8453: 'base',\n}\n\n\nclass KyberSwapProviderV1(BaseProvider):\n    \"\"\"https://docs.kyberswap.com/Aggregator/aggregator-api\"\"\"\n\n    TRADING_API = 'https://aggregator-api.kyberswap.com'\n\n    VERSION = '1'\n    with open(Path(__file__).parent / 'config.json') as f:\n        provider_config = ujson.load(f)\n        PROVIDER_NAME = provider_config['name']\n\n    def __init__(\n        self,\n        session: aiohttp.ClientSession,\n        config: Config,\n        apm_client: ApmClient,\n        chains: ChainsConfig,\n        **_,\n    ):\n        super().__init__(session, config, apm_client)\n        self.chains = chains\n\n        self.get_swap_price = cached(\n            ttl=30, **get_cache_config(self.config), noself=True\n        )(self.get_swap_price)\n\n    async def _get_response(self, url: str, params: Optional[dict] = None) -> dict:\n        async with self.aiohttp_session.get(\n            url,\n            params=params,\n            timeout=self.REQUEST_TIMEOUT,\n            ssl=ssl.SSLContext(),\n            headers={'Accept-Version': self.VERSION},\n        ) as response:\n            response: ClientResponse\n            logger.debug(f'Request GET {response.url}')\n            data = await response.json()\n            try:\n                response.raise_for_status()\n            except ClientResponseError as e:\n                # Fix bug with HTTP status code 0.\n                status = 500 if e.status not in range(100, 600) else e.status\n                data['source'] = 'proxied KyberSwap API'\n                raise ClientResponseError(\n                    request_info=e.request_info,\n                    history=e.history,\n                    status=status,\n                    # Hack for error init method: expected str, but list and dict also works.\n                    message=[data],\n                    headers=e.headers,\n                )\n        return data\n\n    async def get_swap_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        taker_address: Optional[str] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        **_,\n    ) -> ProviderPriceResponse:\n        response = await self._make_request(\n            buy_token=buy_token,\n            sell_token=sell_token,\n            sell_amount=sell_amount,\n            chain_id=chain_id,\n            taker_address=taker_address,\n            gas_price=gas_price,\n            slippage_percentage=slippage_percentage,\n            fee_recipient=fee_recipient,\n            buy_token_percentage_fee=buy_token_percentage_fee,\n        )\n\n        return self._convert_response_from_swap_price(\n            response,\n            sell_token_address=sell_token,\n            buy_token_address=buy_token,\n            chain_id=chain_id,\n        )\n\n    async def get_swap_quote(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        taker_address: str,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        **_,\n    ) -> ProviderQuoteResponse:\n        if not taker_address:\n            raise ValueError('Taker address is required')\n        response = await self._make_request(\n            buy_token=buy_token,\n            sell_token=sell_token,\n            sell_amount=sell_amount,\n            chain_id=chain_id,\n            taker_address=taker_address,\n            gas_price=gas_price,\n            slippage_percentage=slippage_percentage,\n            fee_recipient=fee_recipient,\n            buy_token_percentage_fee=buy_token_percentage_fee,\n        )\n        return self._convert_response_from_swap_quote(\n            response, sell_token, buy_token, chain_id\n        )\n\n    def _convert_response_from_swap_quote(\n        self,\n        response: dict,\n        sell_token_address: str,\n        buy_token_address: str,\n        chain_id: int,\n    ) -> ProviderQuoteResponse:\n        sources = self._convert_sources_for_meta_aggregation(response['swaps'])\n        value = '0'\n        if sell_token_address.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            value = response['inputAmount']\n            sell_token_decimals = self.chains.get_chain_by_id(\n                chain_id\n            ).native_token.decimals\n        else:\n            sell_token_decimals = response['tokens'][sell_token_address.lower()][\n                'decimals'\n            ]\n        if buy_token_address.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            buy_token_decimals = self.chains.get_chain_by_id(\n                chain_id\n            ).native_token.decimals\n        else:\n            buy_token_decimals = response['tokens'][buy_token_address.lower()][\n                'decimals'\n            ]\n        sell_amount = Decimal(response['inputAmount']) / 10**sell_token_decimals\n        buy_amount = Decimal(response['outputAmount']) / 10**buy_token_decimals\n        price = buy_amount / sell_amount\n        try:\n            return ProviderQuoteResponse(\n                sources=sources,\n                buy_amount=response['outputAmount'],\n                gas=response['totalGas'],\n                sell_amount=response['inputAmount'],\n                gas_price=str(int(Decimal(response['gasPriceGwei']) * 10**9)),\n                value=value,\n                price=price,\n                to=response['routerAddress'],\n                data=response['encodedSwapData'],\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(e)\n            raise e\n\n    async def _make_request(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        taker_address: str,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n    ):\n        url = f'{self.TRADING_API}/{CHAIN_ID_TO_NETWORK[chain_id]}/route/encode'\n        params = {\n            'tokenIn': sell_token,\n            'tokenOut': buy_token,\n            'amountIn': str(sell_amount),\n            'clientData': '{\"source\": \"%s\"}' % self.config.PARTNER,\n            'gasInclude': 1,\n        }\n        if taker_address:\n            params['to'] = taker_address\n        else:\n            # KyberSwap has only one endpoint that require taker address\n            params['to'] = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'\n        if slippage_percentage:\n            params['slippageTolerance'] = str(\n                int(slippage_percentage * 10000)\n            )  # 0.1% == 10\n        if buy_token_percentage_fee and fee_recipient:\n            params['chargeFeeBy'] = 'currency_out'\n            params['feeReceiver'] = fee_recipient\n            params['isInBps'] = 1\n            params['feeAmount'] = str(\n                int(buy_token_percentage_fee * 10000)\n            )  # 0.1% == 10\n\n        try:\n            response = await self._get_response(url, params)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            exc = self.handle_exception(\n                e, params=params, token_address=sell_token, chain_id=chain_id\n            )\n            raise exc\n        return response\n\n    def _convert_response_from_swap_price(\n        self,\n        response: dict,\n        sell_token_address: str,\n        buy_token_address: str,\n        chain_id: int,\n    ) -> ProviderPriceResponse:\n        sources = self._convert_sources_for_meta_aggregation(response['swaps'])\n        value = '0'\n        if sell_token_address.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            value = response['inputAmount']\n            sell_token_decimals = self.chains.get_chain_by_id(\n                chain_id\n            ).native_token.decimals\n        else:\n            sell_token_decimals = response['tokens'][sell_token_address.lower()][\n                'decimals'\n            ]\n        if buy_token_address.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            buy_token_decimals = self.chains.get_chain_by_id(\n                chain_id\n            ).native_token.decimals\n        else:\n            buy_token_decimals = response['tokens'][buy_token_address.lower()][\n                'decimals'\n            ]\n        sell_amount = Decimal(response['inputAmount']) / 10**sell_token_decimals\n        buy_amount = Decimal(response['outputAmount']) / 10**buy_token_decimals\n        price = buy_amount / sell_amount\n        try:\n            return ProviderPriceResponse(\n                provider=self.PROVIDER_NAME,\n                sources=sources,\n                buy_amount=response['outputAmount'],\n                gas=response['totalGas'],\n                sell_amount=response['inputAmount'],\n                gas_price=str(int(Decimal(response['gasPriceGwei']) * 10**9)),\n                value=value,\n                price=price,\n                allowance_target=response['routerAddress'],\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(e)\n            raise e\n\n    def _convert_sources_for_meta_aggregation(self, sources: list) -> list[SwapSources]:\n        converted_sources = []\n        for source in sources:\n            for sub_source in source:\n                try:\n                    converted_sources.append(\n                        SwapSources(\n                            name=sub_source['exchange'],\n                            proportion=0.0,\n                        )\n                    )\n                except (KeyError, ValidationError) as e:\n                    e = self.handle_exception(e)\n                    raise e\n        return converted_sources\n\n    def handle_exception(\n        self,\n        exception: Union[ClientResponseError, KeyError, ValidationError],\n        **kwargs,\n    ) -> BaseAggregationProviderError:\n        exc = super().handle_exception(exception, **kwargs)\n        if exc:\n            logger.error(*exc.to_log_args(), extra=exc.to_dict())\n            return exc\n        msg = exception.message\n        exc = AggregationProviderError(\n            self.PROVIDER_NAME,\n            msg,\n            **kwargs,\n        )\n        return exc\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/debridge_dln_v1/debridge_dln_provider_v1.py", "content": "import asyncio\nimport json\nimport os\nimport ssl\nfrom _decimal import Decimal\nfrom pathlib import Path\nfrom typing import Optional, Union, List, Dict\n\nimport ujson\nfrom aiohttp import ClientResponse, ClientResponseError, ServerDisconnectedError\nfrom pydantic import ValidationError\n\nfrom meta_aggregation_api.models.meta_agg_models import (\n    ProviderPriceResponse,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.models.provider_response_models import SwapSources\nfrom meta_aggregation_api.providers.base_crosschain_provider import CrossChainProvider\nfrom meta_aggregation_api.utils.errors import (\n    AggregationProviderError,\n    BaseAggregationProviderError,\n)\nfrom meta_aggregation_api.utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass DebridgeDlnProviderV1(CrossChainProvider):\n    \"\"\"https://docs.debridge.finance\"\"\"\n\n    TRADING_API = os.environ.get('DEBRIDGE_TRADING_API', 'https://api.dln.trade/v1.0/dln/order')\n    ORDER_API = os.environ.get('DEBRIDGE_ORDER_API', 'https://dln-api.debridge.finance/api')\n\n    with open(Path(__file__).parent / 'config.json') as f:\n        PROVIDER_NAME = ujson.load(f)['name']\n\n    def is_require_gas_price(self) -> bool:\n        return True\n\n    async def _get_response(self, url: str, params: Optional[dict] = None) -> dict:\n        async with self.aiohttp_session.get(\n            url, params=params, timeout=self.REQUEST_TIMEOUT, ssl=ssl.SSLContext()\n        ) as response:\n            response: ClientResponse\n            logger.debug(f'Request GET {response.url}')\n            data = await response.json()\n            try:\n                response.raise_for_status()\n            except ClientResponseError as e:\n                # Fix bug with HTTP status code 0.\n                status = 500 if e.status not in range(100, 600) else e.status\n                data['source'] = 'proxied DEBRIDGE DLN API'\n                raise ClientResponseError(\n                    request_info=e.request_info,\n                    history=e.history,\n                    status=status,\n                    # Hack for error init method: expected str, but list and dict also works.\n                    message=[data],\n                    headers=e.headers,\n                )\n        return data\n\n    async def _post_response(self, url: str, params: Optional[dict] = None) -> dict:\n        headers = {\n            'Content-Type': 'application/json',\n        }\n        data = json.dumps(params)\n        async with self.aiohttp_session.post(\n            url, data=data, headers=headers, timeout=self.REQUEST_TIMEOUT, ssl=ssl.SSLContext()\n        ) as response:\n            response: ClientResponse\n            logger.debug(f'Request POST {response.url}')\n            data = await response.json()\n            try:\n                response.raise_for_status()\n            except ClientResponseError as e:\n                # Fix bug with HTTP status code 0.\n                status = 500 if e.status not in range(100, 600) else e.status\n                data['source'] = 'proxied Debridge API'\n                raise ClientResponseError(\n                    request_info=e.request_info,\n                    history=e.history,\n                    status=status,\n                    # Hack for error init method: expected str, but list and dict also works.\n                    message=[data],\n                    headers=e.headers,\n                )\n        return data\n\n    async def get_swap_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id_from: int,\n        chain_id_to: int,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = 1,\n        taker_address: Optional[str] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n    ):\n        if buy_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            buy_token = '0x0000000000000000000000000000000000000000'\n\n        if sell_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            sell_token = '0x0000000000000000000000000000000000000000'\n\n        affiliate_fee_percent = 0\n        if buy_token_percentage_fee is not None:\n            affiliate_fee_percent = int(buy_token_percentage_fee * 100)\n\n        url = '%s/quote' % (self.TRADING_API)\n        params = {\n            'srcChainId': chain_id_from,\n            'srcChainTokenIn': sell_token,\n            'srcChainTokenInAmount': sell_amount,\n            'dstChainId': chain_id_to,\n            'dstChainTokenOut': buy_token,\n            'prependOperatingExpenses': 'true',\n        }\n        if affiliate_fee_percent:\n            params['affiliateFeePercent'] = affiliate_fee_percent\n\n        try:\n            response = await self._get_response(url, params)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            exc = self.handle_exception(\n                e, params=params, token_address=sell_token, give_chain_id=chain_id_from,\n                take_chain_id=chain_id_to\n            )\n            raise exc\n        return self._convert_response_from_swap_price(response)\n\n    async def get_swap_quote(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id_from: int,\n        chain_id_to: int,\n        taker_address: str,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n    ) -> ProviderQuoteResponse:\n        if buy_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            buy_token = '0x0000000000000000000000000000000000000000'\n\n        if sell_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            sell_token = '0x0000000000000000000000000000000000000000'\n\n        affiliate_fee_percent = 0\n        if buy_token_percentage_fee is not None:\n            affiliate_fee_percent = int(buy_token_percentage_fee * 100)\n\n        url = '%s/create-tx' % (self.TRADING_API)\n        params = {\n            'srcChainId': chain_id_from,\n            'srcChainTokenIn': sell_token,\n            'srcChainTokenInAmount': sell_amount,\n            'dstChainId': chain_id_to,\n            'dstChainTokenOut': buy_token,\n            'dstChainTokenOutAmount': 'auto',\n            'srcChainOrderAuthorityAddress': taker_address,\n            'dstChainTokenOutRecipient': taker_address,\n            'dstChainOrderAuthorityAddress': taker_address,\n        }\n\n        if affiliate_fee_percent:\n            params['affiliateFeePercent'] = affiliate_fee_percent\n        if fee_recipient:\n            params['affiliateFeeRecipient'] = fee_recipient\n\n        try:\n            response = await self._get_response(url, params)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            exc = self.handle_exception(\n                e, params=params, token_address=sell_token, chain_id=chain_id_from\n            )\n            raise exc\n        return self._convert_response_from_swap_quote(response)\n\n    def _convert_response_from_swap_price(\n        self, response: dict\n    ) -> ProviderPriceResponse:\n        estimation = response['estimation']\n        sell_amount = Decimal(estimation['srcChainTokenIn']['amount']) / 10 ** Decimal(\n            estimation['srcChainTokenIn']['decimals']\n        )\n        buy_amount = Decimal(estimation['dstChainTokenOut']['amount']) / 10 ** Decimal(\n            estimation['dstChainTokenOut']['decimals']\n        )\n        price = buy_amount / sell_amount\n        try:\n            return ProviderPriceResponse(\n                provider=self.PROVIDER_NAME,\n                sources=[],\n                buy_amount=estimation['dstChainTokenOut']['amount'],\n                sell_amount=estimation['srcChainTokenIn']['amount'],\n                gas='0',\n                gas_price='0',\n                value='0',\n                price=str(price),\n                allowance_target=response['tx']['allowanceTarget'],\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(\n                e, response=response, method='_convert_response_from_swap_quote'\n            )\n            raise e\n\n    def _convert_response_from_swap_quote(\n        self, response: dict\n    ) -> ProviderQuoteResponse:\n        estimation = response['estimation']\n        sell_amount = Decimal(estimation['srcChainTokenIn']['amount']) / 10 ** Decimal(\n            estimation['srcChainTokenIn']['decimals']\n        )\n        buy_amount = Decimal(estimation['dstChainTokenOut']['amount']) / 10 ** Decimal(\n            estimation['dstChainTokenOut']['decimals']\n        )\n        price = buy_amount / sell_amount\n        tx = response['tx']\n        try:\n            return ProviderQuoteResponse(\n                sources=[],\n                buy_amount=estimation['dstChainTokenOut']['amount'],\n                sell_amount=estimation['srcChainTokenIn']['amount'],\n                gas_price=0,\n                gas=0,\n                value=tx['value'],\n                price=str(price),\n                data=tx['data'],\n                to=tx['to'],\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(\n                e, response=response, method='_convert_response_from_swap_quote'\n            )\n            raise e\n\n    @staticmethod\n    def convert_sources_for_meta_aggregation(sources: list) -> list:\n        converted_sources = []\n        for source in sources:\n            for route in source.get('subRoutes', []):\n                for dex in route.get('dexes', []):\n                    converted_sources.append(\n                        SwapSources(\n                            name=dex['dex'],\n                            proportion=dex['percentage'],\n                        )\n                    )\n        return converted_sources\n\n    async def get_orders_by_trader(\n        self,\n        *,\n        chain_id: Optional[int],\n        trader: str,\n        maker_token: Optional[str] = None,\n        taker_token: Optional[str] = None,\n        statuses: Optional[List[str]] = None,\n    ) -> List[Optional[Dict]]:\n        url = '%s/Orders/filteredList' % (self.ORDER_API)\n        params = {\n            \"giveChainIds\": [chain_id],\n            \"orderStates\": [],\n            \"creator\": trader,\n            \"skip\": 0,\n            \"take\": 1000000,\n        }\n\n        try:\n            response = await self._post_response(url, params)\n            return response\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            exc = self.handle_exception(\n                e, params=params\n            )\n            raise exc\n\n    async def get_order_by_hash(\n        self,\n        chain_id: Optional[int],\n        order_hash: str,\n    ) -> Optional[Dict[str, List[Dict]]]:\n        url = '%s/%s' % (self.TRADING_API, order_hash)\n\n        try:\n            response = await self._get_response(url, {})\n            return response\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            exc = self.handle_exception(\n                e, url=url\n            )\n            raise exc\n\n    def handle_exception(\n        self,\n        exception: Union[ClientResponseError, KeyError, ValidationError],\n        **kwargs,\n    ) -> BaseAggregationProviderError:\n        exc = super().handle_exception(exception, **kwargs)\n        if exc:\n            logger.error(*exc.to_log_args(), extra=exc.to_dict())\n            return exc\n        msg = exception.message\n        exc = AggregationProviderError(\n            self.PROVIDER_NAME,\n            msg,\n            **kwargs,\n        )\n        return exc\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/kyberswap_v1/__init__.py", "content": "from .kyberswap_provider_v1 import KyberSwapProviderV1\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/bebop_v3/bebop_provider.py", "content": "from __future__ import annotations\n\nimport ssl\nimport aiohttp\nfrom pydantic import BaseModel\nimport yarl\nfrom meta_aggregation_api.models.meta_agg_models import (\n    ProviderPriceResponse,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.models.provider_response_models import SwapSources\nfrom meta_aggregation_api.providers.base_provider import BaseProvider\nfrom meta_aggregation_api.utils.logger import get_logger\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.clients.apm_client import ApmClient\nfrom meta_aggregation_api.services.chains import ChainsConfig\nfrom web3 import Web3\n\nfrom meta_aggregation_api.utils.errors import (\n    BaseAggregationProviderError,\n    InsufficientLiquidityError,\n    UserBalanceError,\n    AllowanceError,\n    EstimationError,\n    AggregationProviderError,\n    TokensError,\n    PriceError,\n    ProviderTimeoutError,\n    ValidationFailedError,\n)\nfrom pathlib import Path\nimport ujson\n\nlogger = get_logger(__name__)\n\nBEBOP_ERRORS = {\n    # ------------------------------- /quote Errors ------------------------------ #\n    101: ValidationFailedError,\n    102: InsufficientLiquidityError,\n    103: EstimationError,\n    104: PriceError,\n    105: TokensError,\n    106: PriceError,\n    107: AggregationProviderError,\n    # ------------------------------- /order Errors ------------------------------ #\n    201: AggregationProviderError,\n    202: AggregationProviderError,\n    203: AggregationProviderError,\n    204: UserBalanceError,\n    205: AllowanceError,\n    206: AggregationProviderError,\n    207: AggregationProviderError,\n    208: AggregationProviderError,\n    209: AggregationProviderError,\n    210: AggregationProviderError,\n    211: AggregationProviderError,\n    212: AggregationProviderError,\n    500: AggregationProviderError,\n    522: ProviderTimeoutError,\n}\n\n\nclass BebopError(BaseModel):\n    error_code: int\n    message: str\n\n    @staticmethod\n    def from_json(json: dict) -> BebopError:\n        return BebopError(\n            error_code=json[\"error\"][\"errorCode\"], message=json[\"error\"][\"message\"]\n        )\n\n\nclass BebopProviderV3(BaseProvider):\n    \"\"\"Docs: https://docs.bebop.xyz\"\"\"\n\n    BASE_URL: yarl.URL = yarl.URL(\"https://api.bebop.xyz/pmm\")\n    TRADING_API_VERSION: int = 3\n\n    with open(Path(__file__).parent / \"config.json\") as f:\n        PROVIDER_NAME = ujson.load(f)[\"name\"]\n\n    def __init__(\n        self,\n        session: aiohttp.ClientSession,\n        config: Config,\n        chains: ChainsConfig,\n        apm_client: ApmClient,\n    ):\n        super().__init__(session=session, config=config, apm_client=apm_client)\n        self.chains = chains\n        self.api_key = self.config.BEBOP_API_KEY\n\n    def _api_path_builder(self, chain_id: int, endpoint: str) -> yarl.URL:\n        match chain_id:\n            case None:\n                network = \"ethereum\"\n            case self.chains.eth.chain_id:\n                network = \"ethereum\"\n            case 167000:\n                network = \"taiko\"\n            case 81457:\n                network = \"blast\"\n            case _:\n                network = f\"{self.chains.get_chain_by_id(chain_id).name}\"\n        return self.BASE_URL / network / f\"v{self.TRADING_API_VERSION}\" / endpoint\n\n    async def _get_response(self, url: str, params: dict | None = None) -> dict:\n        headers = {\n            \"Source-Auth\": self.api_key\n        }\n        async with self.aiohttp_session.get(\n            url, params=params, timeout=self.REQUEST_TIMEOUT, headers=headers, ssl=ssl.SSLContext()\n        ) as response:\n            logger.debug(f\"Request GET {response.url}\")\n            logger.debug(f\"Request headers {response.request_info.headers}\")\n            data = await response.read()\n            if not data:\n                return {}\n            try:\n                data_json: dict = ujson.loads(data)\n                logger.debug(\"Response Body {data_json}\")\n            except ValueError:\n                raise Exception(data.decode(\"utf-8\"))\n            # Handle status 200 error response\n            if data_json.get(\"error\"):\n                raise Exception(data_json)\n            try:\n                response.raise_for_status()\n            except aiohttp.ClientResponseError as e:\n                status = 500 if e.status not in range(100, 600) else e.status\n                data_json[\"source\"] = \"Bebop API Proxy\"\n                raise aiohttp.ClientResponseError(\n                    request_info=e.request_info,\n                    history=e.history,\n                    status=status,\n                    message=str(data),\n                    headers=e.headers,\n                )\n\n        return data_json\n\n    async def __get_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        skip_validation: bool,\n        taker_address: str | None = None,\n    ) -> dict:\n        \"\"\"\n        Docs: https://api.bebop.xyz/pmm/ethereum/docs#/v3/v3_quote_v3_quote_get\n\n        Examples:\n            - https://api.bebop.xyz/pmm/ethereum/v3/quote?buy_tokens=0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE&sell_tokens=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&sell_amounts=100000000&taker_address=0x0000000000000000000000000000000000000001&approval_type=Standard&skip_validation=true&gasless=false\n        \"\"\"\n        url = self._api_path_builder(chain_id=chain_id, endpoint=\"quote\")\n        params = {\n            \"sell_tokens\": Web3.toChecksumAddress(sell_token),\n            \"buy_tokens\": Web3.toChecksumAddress(buy_token),\n            \"sell_amounts\": sell_amount,\n            \"source\": self.config.PARTNER,\n            \"taker_address\": Web3.toChecksumAddress(taker_address)\n            if taker_address\n            else \"0x0000000000000000000000000000000000000001\",\n            \"approval_type\": \"Standard\",\n            \"gasless\": 0,\n            \"skip_validation\": int(skip_validation),\n        }\n\n        try:\n            response = await self._get_response(url=str(url), params=params)\n        except Exception as e:\n            self.handle_exception(exception=e, **params)\n            raise e\n\n        logger.info(f\"Bebop response: {response}\")\n        return response\n\n    async def get_swap_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        gas_price: int | None = None,\n        slippage_percentage: float | None = None,\n        taker_address: str | None = None,\n        fee_recipient: str | None = None,\n        buy_token_percentage_fee: float | None = None,\n        **_,\n    ) -> ProviderPriceResponse:\n        response = await self.__get_price(\n            buy_token=buy_token,\n            sell_token=sell_token,\n            sell_amount=sell_amount,\n            chain_id=chain_id,\n            taker_address=taker_address,\n            skip_validation=True,\n        )\n        return self._convert_response_from_swap_price(response)\n\n    async def get_swap_quote(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        taker_address: str,\n        gas_price: int | None = None,\n        slippage_percentage: float | None = 0,\n        fee_recipient: str | None = None,\n        buy_token_percentage_fee: float | None = None,\n        **_,\n    ) -> ProviderQuoteResponse:\n        response = await self.__get_price(\n            buy_token=buy_token,\n            sell_token=sell_token,\n            sell_amount=sell_amount,\n            chain_id=chain_id,\n            taker_address=taker_address,\n            skip_validation=False,\n        )\n        return self._convert_response_from_swap_quote(response)\n\n    @staticmethod\n    def convert_sources_for_meta_aggregation(\n        sources: dict | list[dict] | None = None,\n    ) -> list[SwapSources]:\n        return [SwapSources(name=\"bebop\", proportion=100)]\n\n    def _convert_response_from_swap_quote(\n        self,\n        response: dict,\n    ) -> ProviderQuoteResponse:\n        sources = self.convert_sources_for_meta_aggregation()\n        try:\n            prepared_response = ProviderQuoteResponse(\n                buy_amount=next(iter(response[\"buyTokens\"].values()))[\"amount\"],\n                data=response[\"tx\"][\"data\"],\n                gas_price=response[\"tx\"][\"gasPrice\"],\n                gas=response[\"tx\"][\"gas\"],\n                price=next(iter(response[\"sellTokens\"].values()))[\"price\"],\n                sell_amount=next(iter(response[\"sellTokens\"].values()))[\"amount\"],\n                sources=sources,\n                to=response[\"tx\"][\"to\"],\n                value=response[\"tx\"][\"value\"],\n            )\n        except Exception as e:\n            raise self.handle_exception(e)\n        return prepared_response\n\n    def _convert_response_from_swap_price(\n        self, response: dict\n    ) -> ProviderPriceResponse:\n        try:\n            sources = self.convert_sources_for_meta_aggregation()\n            prepared_response = ProviderPriceResponse(\n                allowance_target=response[\"tx\"][\"to\"],\n                buy_amount=next(iter(response[\"buyTokens\"].values()))[\"amountBeforeFee\"],\n                gas_price=response[\"tx\"][\"gasPrice\"],\n                gas=response[\"tx\"][\"gas\"],\n                price=next(iter(response[\"sellTokens\"].values()))[\"priceBeforeFee\"],\n                provider=self.PROVIDER_NAME,\n                sell_amount=next(iter(response[\"sellTokens\"].values()))[\"amount\"],\n                sources=sources,\n                value=response[\"tx\"][\"value\"],\n            )\n        except Exception as e:\n            raise self.handle_exception(e)\n        else:\n            return prepared_response\n\n    def handle_exception(\n        self,\n        exception: Exception,\n        **kwargs,\n    ) -> BaseAggregationProviderError:\n        \"\"\"\n        exception.message:\n        {\n            \"error\": {\n                \"errorCode\": 102,\n                \"message\": \"InsufficientLiquidity: Insufficient liquidity for pairs\n                            ['USDC/WETH']\"\n            }\n        }\n        \"\"\"\n        msg: dict = exception.args[0]\n\n        if \"error\" not in msg:\n            if exc := super().handle_exception(exception, **kwargs):\n                exc = exc\n            else:\n                exc = AggregationProviderError(\n                    self.PROVIDER_NAME, str(exception), **kwargs\n                )\n            logger.error(*exc.to_log_args(), extra=exc.to_dict())\n            return exc\n\n        bebop_error: BebopError = BebopError.from_json(json=msg)\n        if err := BEBOP_ERRORS.get(int(bebop_error.error_code)):\n            error_class = err\n        else:\n            error_class = AggregationProviderError\n\n        exc = error_class(\n            provider=self.PROVIDER_NAME,\n            message=bebop_error.message,\n        )\n\n        logger.warning(*exc.to_log_args(), extra=exc.to_dict())\n        return exc\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/debridge_dln_v1/__init__.py", "content": "from .debridge_dln_provider_v1 import DebridgeDlnProviderV1\n"}
{"type": "source_file", "path": "meta_aggregation_api/config/cache.py", "content": "from pydantic import BaseSettings\n\n\nclass CacheConfig(BaseSettings):\n    CACHE: str = 'memory'\n    CACHE_HOST: str = '127.0.0.1'\n    CACHE_PORT: int = 6379\n    CACHE_DB: int = 0\n    CACHE_PASSWORD: str = None\n    CACHE_TIMEOUT: float = 30\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/bebop_v3/__init__.py", "content": "from .bebop_provider import BebopProviderV3\n"}
{"type": "source_file", "path": "meta_aggregation_api/models/meta_agg_models.py", "content": "from typing import List, Optional\n\nfrom pydantic import BaseModel, Field\n\nfrom meta_aggregation_api.models.provider_response_models import SwapSources\n\n\nclass ProviderPriceResponse(BaseModel):\n    provider: str  # provider name. Set in provider class\n    sources: List[SwapSources]  # list of liquidity sources for the swap\n    buy_amount: str  # amount of buy_token to buy\n    gas: str  # gas amount for the swap\n    sell_amount: str  # amount of sell_token to sell\n    gas_price: str  # gas price for the swap\n    value: str  # amount of native token that should be sent with the transaction\n    price: str  # price for buy_token in sell_token\n    allowance_target: Optional[str]\n\n\nclass MetaPriceModel(BaseModel):\n    provider: str  # provider name. Set in provider class\n    price_response: ProviderPriceResponse  # price response object from provider\n    is_allowed: bool  # if the provider has allowance to spend the sell_token of taker_address\n    is_best: Optional[\n        bool\n    ] = None  # none for request with one provider. True if the provider has the best price\n    approve_cost: int = 0  # 0 for requests without taker_address. Cost of approve transaction for the provider\n\n\nclass ProviderQuoteResponse(BaseModel):\n    sources: list  # list of liquidity sources for the swap\n    buy_amount: str  # amount of buy_token to buy\n    gas: str  # gas amount for the swap\n    sell_amount: str  # amount of sell_token to sell\n    to: str  # address where the swap will be executed\n    data: str  # data for the swap\n    gas_price: str  # gas price for the swap\n    value: str  # amount of native token that should be sent with the transaction\n    price: str  # price for buy_token in sell_token\n\n\nclass LimitOrderPostData(BaseModel):\n    maker_asset: str = Field(..., description='The address of maker token')\n    taker_asset: str = Field(..., description='The address of taker token')\n    maker: str = Field(..., description='The address of maker')\n    allowed_sender: str = Field(..., description='The address of allowed sender')\n    receiver: str = Field(..., description='The address of receiver')\n    making_amount: str = Field(..., description='The amount of maker token')\n    taking_amount: str = Field(..., description='The amount of taker token')\n    salt: str = Field('0x', description='The salt of the order')\n    interactions: Optional[str] = Field(\n        '0x', description='The interactions of the order'\n    )\n    offsets: Optional[str] = Field('0x', description='The offsets of the order')\n\n    def to_camel_case_dict(self):\n        return dict(\n            makerAsset=self.maker_asset,\n            takerAsset=self.taker_asset,\n            maker=self.maker,\n            allowedSender=self.allowed_sender,\n            receiver=self.receiver,\n            makingAmount=self.making_amount,\n            takingAmount=self.taking_amount,\n            salt=self.salt,\n            interactions=self.interactions,\n            offsets=self.offsets,\n        )\n"}
{"type": "source_file", "path": "meta_aggregation_api/services/__init__.py", "content": ""}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/middlewares/__init__.py", "content": "from .route_logger import RouteLoggerMiddleware\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/routes/crosschain_swap.py", "content": "from typing import Optional\n\nfrom fastapi import APIRouter, Depends, Query\nfrom fastapi.security import HTTPBearer\nfrom pydantic import conint\n\nfrom meta_aggregation_api.config.auth import AuthJWT\nfrom meta_aggregation_api.models.meta_agg_models import (\n    MetaPriceModel,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.rest_api import dependencies\nfrom meta_aggregation_api.utils.common import address_to_lower\nfrom meta_aggregation_api.utils.errors import responses\n\nPRICE_CACHE_TTL_SEC = 5\ncrosschain_swap_route = APIRouter()\n\n@crosschain_swap_route.get('/price', response_model=MetaPriceModel, responses=responses)\n@crosschain_swap_route.get(\n    '/price/', response_model=MetaPriceModel, include_in_schema=False\n)\nasync def get_swap_price(\n    buy_token: address_to_lower = Query(..., alias='buyToken'),\n    sell_token: address_to_lower = Query(..., alias='sellToken'),\n    sell_amount: conint(gt=0) = Query(..., alias='sellAmount'),\n    chain_id_from: int = Query(..., alias='chainIdFrom'),\n    chain_id_to: int = Query(..., alias='chainIdTo'),\n    gas_price: Optional[int] = Query(\n        None, description='Gas price', gt=0, alias='gasPrice'\n    ),\n    slippage_percentage: Optional[float] = Query(\n        0.005, gte=0, alias='slippagePercentage'\n    ),\n    taker_address: Optional[address_to_lower] = Query(None, alias='takerAddress'),\n    fee_recipient: Optional[address_to_lower] = Query(None, alias='feeRecipient'),\n    buy_token_percentage_fee: Optional[float] = Query(\n        None, alias='buyTokenPercentageFee'\n    ),\n    provider: Optional[str] = Query(None, alias='provider'),\n    meta_aggregation_service: dependencies.MetaAggregationService = Depends(\n        dependencies.meta_aggregation_service\n    ),\n) -> MetaPriceModel:\n    \"\"\"\n    Price endpoints are used to get the best price for a swap. It does not return data for swap and therefore\n    require any approvals. If you want to get data for swap, use /price_response endpoint.\n\n    - **buy_token**: Address of the token to buy\n    - **sell_token**: Address of the token to sell\n    - **sell_amount**: Amount of the token to sell in base units (e.g. 1 ETH = 10**18)\n    - **chain_id**: Chain ID. See /info for supported chains\n    - **gas_price**: Gas price in wei (optional)\n    - **slippage_percentage**: Slippage percentage  (0.01 = 1%) (default: 0.005)\n    - **taker_address**: Address of the taker (optional)\n    - **fee_recipient**: Address of the fee recipient (optional)\n    - **buy_token_percentage_fee**: Percentage of the buy token fee (optional) (0.01 = 1%)\n    - **provider**: Provider name from /info (optional). If not specified, the best price will be returned\n    \"\"\"\n    params = {\n        \"buy_token\": buy_token,\n        \"sell_token\": sell_token,\n        \"sell_amount\": sell_amount,\n        \"chain_id_from\": chain_id_from,\n        \"chain_id_to\": chain_id_to,\n        \"gas_price\": gas_price,\n        \"slippage_percentage\": slippage_percentage,\n        \"taker_address\": taker_address,\n        \"fee_recipient\": fee_recipient,\n        \"buy_token_percentage_fee\": buy_token_percentage_fee,\n    }\n    res = await meta_aggregation_service.get_crosschain_provider_price(\n        provider=provider, **params\n    )\n    return res\n\n\n@crosschain_swap_route.get(\n    '/quote',\n    response_model=ProviderQuoteResponse,\n    responses=responses,\n    # dependencies=[Depends(HTTPBearer())],\n)\n@crosschain_swap_route.get(\n    '/quote/',\n    response_model=ProviderQuoteResponse,\n    include_in_schema=False,\n    # dependencies=[Depends(HTTPBearer())],\n)\nasync def get_swap_quote(\n    # authorize: AuthJWT = Depends(),\n    buy_token: address_to_lower = Query(..., alias='buyToken'),\n    sell_token: address_to_lower = Query(..., alias='sellToken'),\n    sell_amount: conint(gt=0) = Query(..., alias='sellAmount'),\n    chain_id_from: int = Query(..., alias='chainIdFrom'),\n    chain_id_to: int = Query(..., alias='chainIdTo'),\n    provider: str = Query(..., alias='provider'),\n    taker_address: address_to_lower = Query(..., alias='takerAddress'),\n    gas_price: Optional[int] = Query(\n        None, description='Gas price', gt=0, alias='gasPrice'\n    ),\n    slippage_percentage: Optional[float] = Query(0.005, alias='slippagePercentage'),\n    fee_recipient: Optional[address_to_lower] = Query(None, alias='feeRecipient'),\n    buy_token_percentage_fee: Optional[float] = Query(\n        None, alias='buyTokenPercentageFee'\n    ),\n    meta_aggregation_service: dependencies.MetaAggregationService = Depends(\n        dependencies.meta_aggregation_service\n    ),\n) -> ProviderQuoteResponse:\n    \"\"\"\n    Returns a data for swap from a specific provider.\n\n    - **buy_token**:Address of the token to buy\n    - **sell_token**:Address of the token to sell\n    - **sell_amount**:Amount of the token to sell in base units (e.g. 1 ETH = 10**18)\n    - **chain_id**: Chain ID. See /info for supported chains\n    - **provider**: Provider name from /info\n    - **gas_price**: Gas price in wei (optional)\n    - **slippage_percentage**: Slippage percentage  (0.01 = 1%) (default: 0.005)\n    - **taker_address**: Address of the taker (optional)\n    - **fee_recipient**: Address of the fee recipient (optional)\n    - **buy_token_percentage_fee**: Percentage of the buy token fee (optional) (0.01 = 1%)\n    \"\"\"\n    # authorize.jwt_required()\n    quote = await meta_aggregation_service.get_crosschain_meta_swap_quote(\n        buy_token=buy_token,\n        sell_token=sell_token,\n        sell_amount=sell_amount,\n        chain_id_from=chain_id_from,\n        chain_id_to=chain_id_to,\n        provider=provider,\n        gas_price=gas_price,\n        slippage_percentage=slippage_percentage,\n        taker_address=taker_address,\n        fee_recipient=fee_recipient,\n        buy_token_percentage_fee=buy_token_percentage_fee,\n    )\n    return quote\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/openocean_v2/__init__.py", "content": "from .openocean_provider_v2 import OpenOceanProviderV2\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/zerox_v1/zerox_provider.py", "content": "import asyncio\nimport re\nimport ssl\nfrom pathlib import Path\nfrom typing import List, Optional, Union\n\nimport aiohttp\nimport ujson\nfrom aiocache import cached\nfrom aiohttp import ClientResponse, ClientResponseError, ServerDisconnectedError\nfrom pydantic import ValidationError\n\nfrom meta_aggregation_api.clients.apm_client import ApmClient\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.models.meta_agg_models import (\n    ProviderPriceResponse,\n    ProviderQuoteResponse,\n    SwapSources,\n)\nfrom meta_aggregation_api.providers.base_provider import BaseProvider\nfrom meta_aggregation_api.services.chains import ChainsConfig\nfrom meta_aggregation_api.utils.cache import get_cache_config\nfrom meta_aggregation_api.utils.errors import (\n    AggregationProviderError,\n    AllowanceError,\n    BaseAggregationProviderError,\n    EstimationError,\n    InsufficientLiquidityError,\n    TokensError,\n    UserBalanceError,\n)\nfrom meta_aggregation_api.utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nZERO_X_ERRORS = {\n    'Insufficient funds for transaction': UserBalanceError,\n    'IncompleteTransformERC20Error': TokensError,\n    'INSUFFICIENT_ASSET_LIQUIDITY': InsufficientLiquidityError,\n    'WalletExecuteDelegateCallFailedError': AggregationProviderError,\n    'SenderNotAuthorizedError': AllowanceError,\n    'Gas estimation failed': EstimationError,\n    'ERC20: insufficient allowance': AllowanceError,\n}\n\n\n# TODO: Add description, links to one 0x docs\n\n\nclass ZeroXProviderV1(BaseProvider):\n    \"\"\"Docs: https://0x.org/docs/api#introduction\"\"\"\n\n    API_DOMAIN = 'api.0x.org'\n    TRADING_API_VERSION = 1\n    with open(Path(__file__).parent / 'config.json') as f:\n        PROVIDER_NAME = ujson.load(f)['name']\n\n    def __init__(\n        self,\n        session: aiohttp.ClientSession,\n        config: Config,\n        chains: ChainsConfig,\n        apm_client: ApmClient,\n    ):\n        super().__init__(session=session, config=config, apm_client=apm_client)\n        self.chains = chains\n\n        self.get_swap_price = cached(\n            ttl=30, **get_cache_config(self.config), noself=True\n        )(self.get_swap_price)\n\n    def _api_domain_builder(self, chain_id: int = None) -> str:\n        network = (\n            ''\n            if not chain_id or chain_id == self.chains.eth.chain_id\n            else f'{self.chains.get_chain_by_id(chain_id).name}.'\n        )\n        return f'{network}{self.API_DOMAIN}'\n\n    def _api_path_builder(\n        self, path: str, endpoint: str, chain_id: Optional[str] = None\n    ) -> str:\n        domain = self._api_domain_builder(chain_id)\n        return f'https://{domain}/{path}/v{self.TRADING_API_VERSION}/{endpoint}'\n\n    async def _get_response(self, url: str, params: Optional[dict] = None) -> dict:\n        async with self.aiohttp_session.get(\n            url, params=params, timeout=self.REQUEST_TIMEOUT, ssl=ssl.SSLContext()\n        ) as response:\n            response: ClientResponse\n            logger.debug(f'Request GET {response.url}')\n            data = await response.json()\n            try:\n                response.raise_for_status()\n            except ClientResponseError as e:\n                # Fix bug with HTTP status code 0.\n                status = 500 if e.status not in range(100, 600) else e.status\n                data['source'] = 'proxied 0x.org API'\n                raise ClientResponseError(\n                    request_info=e.request_info,\n                    history=e.history,\n                    status=status,\n                    # Hack for error init method: expected str, but list and dict also works.\n                    message=[data],\n                    headers=e.headers,\n                )\n\n        return data\n\n    def _convert_response_from_swap_quote(\n        self, response: dict\n    ) -> Optional[ProviderQuoteResponse]:\n        sources = self.convert_sources_for_meta_aggregation(response['sources'])\n        try:\n            prepared_response = ProviderQuoteResponse(\n                sources=sources,\n                buy_amount=response['buyAmount'],\n                gas=response['gas'],\n                sell_amount=response['sellAmount'],\n                to=response['to'],\n                data=response['data'],\n                gas_price=response['gasPrice'],\n                value=response['value'],\n                price=response['price'],\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(e, response=response)\n            raise e\n        else:\n            return prepared_response\n\n    @staticmethod\n    def convert_sources_for_meta_aggregation(\n        sources: Optional[Union[dict, list[dict]]],\n    ) -> Optional[list[SwapSources]]:\n        if not sources:\n            return\n        converted_sources = []\n        for source in sources:\n            if not float(source['proportion']):\n                continue\n            if source.get('hops'):\n                converted_sources.extend(\n                    [\n                        SwapSources(\n                            name=hop, proportion=float(source['proportion']) * 100\n                        )\n                        for hop in source['hops']\n                    ]\n                )\n                continue\n            converted_sources.append(\n                SwapSources(\n                    name=source['name'],\n                    proportion=float(source['proportion']) * 100,\n                    # Convert to percentage.\n                )\n            )\n        return converted_sources\n\n    def _convert_response_from_swap_price(\n        self, response: dict\n    ) -> Optional[ProviderPriceResponse]:\n        try:\n            sources = self.convert_sources_for_meta_aggregation(response['sources'])\n            prepared_response = ProviderPriceResponse(\n                provider=self.PROVIDER_NAME,\n                sources=sources,\n                buy_amount=response['buyAmount'],\n                gas=response['gas'],\n                sell_amount=response['sellAmount'],\n                gas_price=response['gasPrice'],\n                value=response['value'],\n                price=response['price'],\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(e, response=response)\n            raise e\n        else:\n            return prepared_response\n\n    async def get_swap_quote(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        taker_address: str,\n        chain_id: Optional[int] = None,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        ignore_checks: bool = False,\n        **_,\n    ) -> Optional[ProviderQuoteResponse]:\n        \"\"\"\n        Docs: https://0x.org/docs/api#get-swapv1quote\n\n        Examples:\n            - https://api.0x.org/swap/v1/quote?buyToken=0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE&sellAmount=1000000&sellToken=0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\n            - https://api.0x.org/swap/v1/quote?buyToken=0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48&sellAmount=1000000000000000000&sellToken=0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n            - https://api.0x.org/swap/v1/quote?affiliateAddress=0x720c9244473Dfc596547c1f7B6261c7112A3dad4&buyToken=0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48&gasPrice=26000000000&sellAmount=1000000000000000000&sellToken=0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE&slippagePercentage=0.0100&takerAddress=0xA0942D8352FFaBCc0f6dEE32b2b081C703e726A5\n        \"\"\"\n        url = self._api_path_builder('swap', 'quote', chain_id)\n        ignore_checks = str(ignore_checks).lower()\n        query = {\n            'buyToken': buy_token,\n            'sellToken': sell_token,\n            'sellAmount': sell_amount,\n            'skipValidation': ignore_checks,\n        }\n\n        if gas_price:\n            query['gasPrice'] = gas_price\n\n        if slippage_percentage:\n            query['slippagePercentage'] = slippage_percentage\n\n        if taker_address:\n            query['takerAddress'] = taker_address\n\n        if fee_recipient and buy_token_percentage_fee:\n            query['feeRecipient'] = fee_recipient\n            query['affiliateAddress'] = fee_recipient\n            query['buyTokenPercentageFee'] = buy_token_percentage_fee\n\n        logger.debug(f'Proxing url {url} with params {query}')\n        try:\n            response = await self._get_response(url, params=query)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            e = self.handle_exception(\n                e, query=query, method='get_swap_quote', chain_id=chain_id\n            )\n            raise e\n        logger.info(f'Got price_response from 0x.org: {response}')\n        return self._convert_response_from_swap_quote(response)\n\n    async def get_orders_by_trader(\n        self,\n        *,\n        chain_id: int,\n        trader: str,\n        maker_token: str = None,\n        taker_token: Optional[int] = None,\n        statuses: Optional[List] = None,\n    ) -> dict:\n        \"\"\"\n        Docs: https://docs.0x.org/0x-api-orderbook/introduction\n\n        Examples:\n            https://docs.0x.org/0x-api-orderbook/api-references\n        \"\"\"\n        url = self._api_path_builder('orderbook', 'orders', str(chain_id))\n        query = {}\n\n        if taker_token:\n            query['takerToken'] = taker_token\n\n        if maker_token:\n            query['makerToken'] = maker_token\n\n        if trader:\n            query['trader'] = trader\n\n        logger.debug(f'Proxing url {url} with params {query}')\n        return await self._get_response(url, params=query)\n\n    async def get_swap_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: Optional[int] = None,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        taker_address: Optional[str] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        **_,\n    ) -> Optional[ProviderPriceResponse]:\n        \"\"\"\n        Docs: https://0x.org/docs/api#get-swapv1price\n        \"\"\"\n        url = self._api_path_builder('swap', 'price', chain_id)\n        query = {\n            'buyToken': buy_token,\n            'sellToken': sell_token,\n            'sellAmount': sell_amount,\n        }\n\n        if gas_price:\n            query['gasPrice'] = gas_price\n\n        if slippage_percentage:\n            query['slippagePercentage'] = slippage_percentage\n\n        if taker_address:\n            query['takerAddress'] = taker_address\n\n        if fee_recipient and buy_token_percentage_fee:\n            query['feeRecipient'] = fee_recipient\n            query['affiliateAddress'] = fee_recipient\n            query['buyTokenPercentageFee'] = buy_token_percentage_fee\n\n        logger.debug(f'Proxing url {url} with params {query}')\n        try:\n            response = await self._get_response(url, params=query)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            e = self.handle_exception(\n                e, query=query, method='get_swap_price', chain_id=chain_id\n            )\n            raise e\n        return self._convert_response_from_swap_price(response) if response else None\n\n    def handle_exception(\n        self, exception: Union[ClientResponseError, KeyError, ValidationError], **kwargs\n    ) -> BaseAggregationProviderError:\n        \"\"\"\n        exception.message: [\n            {\n                \"code\": 101,\n                \"reason\": \"Validation failed\",\n                \"validationErrors\": [\n                    {\n                        \"field\": \"maker\",\n                        \"code\": 1002,\n                        \"reason\": \"Invalid address\"\n                    }\n                ]\n            }\n        ]\n        or\n        exception.message: [\n            {\n                \"code\": 105,\n                \"reason\": \"Transaction Invalid\",\n                \"values\": {\n                    \"message\": \"execution reverted\",\n                }\n            }\n        ]\n        \"\"\"\n        exc = super().handle_exception(exception, **kwargs)\n        if exc:\n            logger.error(*exc.to_log_args(), extra=exc.to_dict())\n            return exc\n        msg = exception.message\n        if isinstance(exception.message, list) and isinstance(\n            exception.message[0], dict\n        ):\n            msg = exception.message[0]\n            if msg.get('validationErrors'):\n                msg = {msg['field']: msg['reason'] for msg in msg['validationErrors']}\n            else:\n                msg = msg.get('values', msg).get('message', msg.get('reason', msg))\n\n        for error, error_class in ZERO_X_ERRORS.items():\n            if re.search(error.lower(), str(msg).lower()):\n                break\n        else:\n            error_class = AggregationProviderError\n        exc = error_class(\n            self.PROVIDER_NAME,\n            msg,\n            url=str(exception.request_info.url),\n            **kwargs,\n        )\n        logger.warning(*exc.to_log_args(), extra=exc.to_dict())\n        return exc\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/paraswap_v5/__init__.py", "content": "from .paraswap_provider_v5 import ParaSwapProviderV5\n"}
{"type": "source_file", "path": "meta_aggregation_api/services/chains.py", "content": "from dexguru_sdk import DexGuru\nfrom pydantic import HttpUrl\n\nfrom meta_aggregation_api.models.chain import ChainModel\n\n\nclass ChainsConfig:\n    \"\"\"\n    All supported chains are defined here.\n    Chain object contains name, chain_id, description and native_token.\n    Native token is an object with address, name, symbol and decimals.\n    Models defined in models/chain.py\n    Usage:\n        chain = chains.eth\n        chain.chain_id\n        # 1\n    \"\"\"\n\n    chains = {}\n\n    def __init__(self, api_key: str, domain: HttpUrl):\n        self.dex_guru_sdk = DexGuru(api_key=api_key, domain=domain)\n\n    async def set_chains(self):\n        chains_ = await self.dex_guru_sdk.get_chains()\n        for chain in chains_.data:\n            self.chains[chain.name.lower()] = ChainModel.parse_obj(chain.dict())\n\n    def __contains__(self, item: str | int):\n        return item in self.chains.keys() or item in [\n            chain.chain_id for chain in self.__dict__.values()\n        ]\n\n    def get_chain_by_id(self, chain_id: int):\n        for chain in self.chains.values():\n            if chain.chain_id == chain_id:\n                return chain\n        raise ValueError(f'Chain id {chain_id} not found')\n\n    def __getattr__(self, item):\n        return self.chains[item]\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/zerox_v1/__init__.py", "content": "from .zerox_provider import ZeroXProviderV1\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/routes/limit_orders.py", "content": "from typing import List, Optional\n\nfrom fastapi import APIRouter, Body, Depends, Path, Query\nfrom fastapi.security import HTTPBearer\nfrom fastapi_jwt_auth import AuthJWT\n\nfrom meta_aggregation_api.models.meta_agg_models import LimitOrderPostData\nfrom meta_aggregation_api.rest_api import dependencies\nfrom meta_aggregation_api.utils.common import address_to_lower\n\nlimit_orders = APIRouter()\n\n\n@limit_orders.get('/{chain_id}/address/{trader}')\n@limit_orders.get('/{chain_id}/address/{trader}/', include_in_schema=False)\nasync def get_orders_by_trader(\n    chain_id: int = Path(...),\n    trader: address_to_lower = Path(\n        ..., description='The address of either the maker or the taker'\n    ),\n    provider: str = Query(..., description='e.g. zero_x, one_inch'),\n    maker_token: Optional[address_to_lower] = Query(\n        None, description='The address of maker token'\n    ),\n    taker_token: Optional[address_to_lower] = Query(\n        None, description='The address of taker token'\n    ),\n    statuses: Optional[List] = Query(None, description=''),\n    service: dependencies.LimitOrdersService = Depends(\n        dependencies.limit_orders_service\n    ),\n):\n    response = await service.get_by_wallet_address(\n        chain_id=chain_id,\n        provider=provider,\n        maker_token=maker_token,\n        taker_token=taker_token,\n        trader=trader,\n        statuses=statuses,\n    )\n    return response\n\n\n@limit_orders.get('/{chain_id}/events/{order_hash}')\n@limit_orders.get('/{chain_id}/events/{order_hash}/', include_in_schema=False)\nasync def get_limit_order_by_order_hash(\n    chain_id: int = Path(...),\n    order_hash: Optional[str] = Path(None, description='The hash of the order'),\n    provider: str = Query(..., description='e.g. zero_x, one_inch'),\n    service: dependencies.LimitOrdersService = Depends(\n        dependencies.limit_orders_service\n    ),\n):\n    response = await service.get_by_hash(\n        chain_id=chain_id,\n        provider=provider,\n        order_hash=order_hash,\n    )\n    return response\n\n\n@limit_orders.post('/{chain_id}', dependencies=[Depends(HTTPBearer())])\n@limit_orders.post(\n    '/{chain_id}/', include_in_schema=False, dependencies=[Depends(HTTPBearer())]\n)\nasync def make_limit_order(\n    authorize: AuthJWT = Depends(),\n    chain_id: int = Path(...),\n    provider: Optional[str] = Query(..., description='e.g. zero_x, one_inch'),\n    order_hash: str = Body(..., description='The hash of the order'),\n    signature: str = Body(..., description='The signature of the order'),\n    data: LimitOrderPostData = Body(..., description='The data of the order'),\n    service: dependencies.LimitOrdersService = Depends(\n        dependencies.limit_orders_service\n    ),\n):\n    authorize.jwt_required()\n    response = await service.post(\n        chain_id=chain_id,\n        provider=provider,\n        order_hash=order_hash,\n        signature=signature,\n        data=data,\n    )\n    return response\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/routes/info.py", "content": "from typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException, Path\n\nfrom meta_aggregation_api.models.chain import (\n    AllProvidersConfigModel,\n    ProvidersConfigModel,\n)\nfrom meta_aggregation_api.rest_api import dependencies\n\ninfo_route = APIRouter()\n\n\n@info_route.get('/', response_model=List[AllProvidersConfigModel])\n@info_route.get('', include_in_schema=False)\nasync def get_all_info(\n    providers: dependencies.ProvidersConfig = Depends(dependencies.providers),\n):\n    \"\"\"\n    Returns information about the providers on all supported chains.\n    This includes name, spender_address and display_name.\n    \"\"\"\n    info = providers.get_all_providers()\n    return info\n\n\n@info_route.get(\n    '/{chain_id}',\n    response_model=ProvidersConfigModel,\n    response_model_exclude={'chain_id'},\n    responses={404: {\"description\": \"Chain ID not found\"}},\n)\n@info_route.get(\n    '/{chain_id}/',\n    include_in_schema=False,\n    response_model=ProvidersConfigModel,\n    response_model_exclude={'chain_id'},\n)\nasync def get_info(\n    chain_id: int = Path(..., description='Chain ID'),\n    providers: dependencies.ProvidersConfig = Depends(dependencies.providers),\n) -> ProvidersConfigModel:\n    \"\"\"Returns information about the providers for a given chain ID.\"\"\"\n    try:\n        info = providers.get_providers_on_chain(chain_id)\n    except ValueError:\n        raise HTTPException(status_code=404, detail='Chain ID not found')\n    else:\n        return info\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/routes/gas.py", "content": "from fastapi import Depends, Path\nfrom fastapi.routing import APIRouter\nfrom fastapi.security import HTTPBearer\nfrom fastapi_jwt_auth import AuthJWT\n\nfrom meta_aggregation_api.models.gas_models import GasResponse\nfrom meta_aggregation_api.rest_api import dependencies\n\ngas_routes = APIRouter()\n\n\n@gas_routes.get(\n    '/{chain_id}', response_model=GasResponse, dependencies=[Depends(HTTPBearer())]\n)\n@gas_routes.get(\n    '/{chain_id}/', include_in_schema=False, dependencies=[Depends(HTTPBearer())]\n)\n@gas_routes.get('/{chain_id}', response_model=GasResponse)\n@gas_routes.get('/{chain_id}/', include_in_schema=False)\nasync def get_prices(\n    authorize: AuthJWT = Depends(),\n    chain_id: int = Path(..., description='Chain ID'),\n    gas_service: dependencies.GasService = Depends(dependencies.gas_service),\n) -> GasResponse:\n    \"\"\"\n    Returns the gas prices for a given chain.\n    Returned object has not null eip1559 field for chains that support it.\n    \"\"\"\n    authorize.jwt_required()\n    return await gas_service.get_gas_prices(chain_id)\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/middlewares/route_logger.py", "content": "import logging\nimport time\nimport typing\nfrom typing import Callable\nfrom uuid import uuid4\n\nfrom fastapi import FastAPI, Request, Response\nfrom starlette.datastructures import Headers\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.types import Receive, Scope, Send\n\nfrom meta_aggregation_api.utils.logger import (\n    get_logger,\n    set_correlation_id,\n    set_session_id,\n)\n\n\nclass RouteLoggerMiddleware(BaseHTTPMiddleware):\n    _cid_header: str = 'x-request-id'  # request correlation key header name\n    _sid_header: str = 'x-session-id'  # session correlation key header name\n    _cfray_header: str = 'cf-ray'\n\n    def __init__(\n        self,\n        app: FastAPI,\n        *,\n        logger: typing.Optional[logging.Logger] = None,\n        skip_routes: typing.List[str] = None,\n    ):\n        self._logger = logger or get_logger(__name__)\n        self._skip_routes = skip_routes or []\n        super().__init__(app)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send):\n        \"\"\"Headers object is immutable. We should update headers before calling dispatch method\"\"\"\n\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        headers_dict = Headers(scope=scope)\n\n        if self._cid_header not in headers_dict:\n            request_id = headers_dict.get(self._cfray_header, uuid4().hex)\n            scope['headers'].append((self._cid_header.encode(), request_id.encode()))\n\n        if self._sid_header in headers_dict:\n            set_session_id(headers_dict[self._sid_header])\n\n        set_correlation_id(headers_dict[self._cid_header])\n        await super().__call__(scope, receive, send)\n\n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        if self._should_route_be_skipped(request):\n            return await call_next(request)\n\n        return await self._execute_request_with_logging(request, call_next)\n\n    def _should_route_be_skipped(self, request: Request) -> bool:\n        return any(\n            [path for path in self._skip_routes if request.url.path.startswith(path)]\n        )\n\n    async def _execute_request_with_logging(\n        self, request: Request, call_next: Callable\n    ) -> Response:\n        start_time = time.perf_counter()\n\n        response = await self._execute_request(call_next, request)\n        response.headers[self._cid_header] = request.headers[self._cid_header]\n\n        finish_time = time.perf_counter()\n        duration = round(finish_time - start_time, 4)\n        log_args = {\n            \"request_method\": request.method,\n            \"request_path\": request.url.path,\n            \"request_duration\": duration,\n            \"response_status\": response.status_code,\n        }\n        msg = f\"Request {'successful' if response.status_code < 500 else 'failed'}\"\n        self._logger.info(msg, log_args, extra=log_args)\n\n        return response\n\n    async def _execute_request(self, call_next: Callable, request: Request) -> Response:\n        try:\n            response = await call_next(request)\n        except Exception:\n            log_args = {\n                \"request_method\": request.method,\n                \"request_path\": request.url.path,\n                \"response_status\": 500,\n            }\n            self._logger.exception(\n                \"Request failed with exception\", log_args, extra=log_args\n            )\n            raise\n        return response\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/routes/__init__.py", "content": ""}
{"type": "source_file", "path": "meta_aggregation_api/providers/paraswap_v5/paraswap_provider_v5.py", "content": "import asyncio\nimport re\nimport ssl\nfrom decimal import Decimal\nfrom itertools import chain\nfrom pathlib import Path\nfrom typing import Optional, Union\n\nimport ujson\nimport yarl\nfrom aiocache import cached\nfrom aiohttp import ClientResponseError, ServerDisconnectedError\nfrom pydantic import ValidationError\n\nfrom meta_aggregation_api.models.meta_agg_models import (\n    ProviderPriceResponse,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.models.provider_response_models import SwapSources\nfrom meta_aggregation_api.providers.base_provider import BaseProvider\nfrom meta_aggregation_api.utils.cache import get_cache_config\nfrom meta_aggregation_api.utils.errors import (\n    AggregationProviderError,\n    AllowanceError,\n    BaseAggregationProviderError,\n    EstimationError,\n    PriceError,\n    TokensError,\n    UserBalanceError,\n    ValidationFailedError,\n)\nfrom meta_aggregation_api.utils.logger import LogArgs, get_logger\n\nlogger = get_logger(__name__)\n\nPARASWAP_ERRORS = {\n    # ---- price errors\n    'Invalid tokens': TokensError,\n    'Token not found': TokensError,\n    'Price Timeout': PriceError,\n    'computePrice Error': PriceError,\n    'Bad USD price': PriceError,\n    'ERROR_GETTING_PRICES': PriceError,\n    # ---- price_response errors\n    'Unable to check price impact': PriceError,\n    r'not enough \\w+ balance': UserBalanceError,\n    r'not enough \\w+ allowance': AllowanceError,\n    'It seems like your wallet doesn\\'t contain enough': UserBalanceError,\n    'Network Mismatch': ValidationFailedError,\n    'Missing srcAmount': ValidationFailedError,\n    'Missing destAmount': ValidationFailedError,\n    'Cannot specify both slippage and destAmount': ValidationFailedError,\n    'Missing slippage or destAmount': ValidationFailedError,\n    'Source Amount Mismatch': ValidationFailedError,\n    'Destination Amount Mismatch': ValidationFailedError,\n    'Source Token Mismatch': ValidationFailedError,\n    'Destination Token Mismatch': ValidationFailedError,\n    'Error Parsing params': ValidationFailedError,\n    'priceRoute must be unmodified as sent by the price endpoint': ValidationFailedError,\n    'Unable to process the transaction': EstimationError,\n    'ERROR_BUILDING_TRANSACTION': EstimationError,\n}\n\n\nclass ParaSwapProviderV5(BaseProvider):\n    \"\"\"\n    Trading Provider for Paraswap v5 dex aggregator\n    Docs: https://developers.paraswap.network/api/master\n    \"\"\"\n\n    MAIN_API_URL: yarl.URL = yarl.URL('https://api.paraswap.io/')\n    VERSION = 6.2\n    with open(Path(__file__).parent / 'config.json') as f:\n        PROVIDER_NAME = ujson.load(f)['name']\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        self.get_swap_price = cached(\n            ttl=30, **get_cache_config(self.config), noself=True\n        )(self.get_swap_price)\n\n    async def request(self, method: str, path: str, *args, **kwargs):\n        request_function = getattr(self.aiohttp_session, method.lower())\n        url = self.MAIN_API_URL / path\n        async with request_function(\n            url, *args, timeout=self.REQUEST_TIMEOUT, **kwargs, ssl=ssl.SSLContext()\n        ) as response:\n            logger.debug(\"Request '%s' to '%s'\", method, url)\n            data = await response.text()\n            try:\n                response.raise_for_status()\n            except ClientResponseError as e:\n                # Fix bug with HTTP status code 0.\n                status = 500 if e.status not in range(100, 600) else e.status\n                raise ClientResponseError(\n                    request_info=response.request_info,\n                    history=response.history,\n                    status=status,\n                    message=data,\n                    headers=response.headers,\n                )\n        return ujson.loads(data)\n\n    async def get_swap_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: Optional[int] = None,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        taker_address: Optional[str] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        **kwargs,\n    ):\n        path = 'prices'\n        params = {\n            'srcToken': sell_token,\n            'destToken': buy_token,\n            'amount': sell_amount,\n            'side': 'SELL',\n            'network': chain_id,\n            'otherExchangePrices': 'false',\n            'partner': self.config.PARTNER,\n            'srcDecimals': kwargs.get('src_decimals'),\n            'destDecimals': kwargs.get('dest_decimals'),\n            'version': self.VERSION,\n        }\n\n        try:\n            quotes = await self.request(method='get', path=path, params=params)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n            Exception,\n        ) as e:\n            e = self.handle_exception(\n                e, method='get_swap_price', params=params, chain_id=chain_id\n            )\n            raise e\n        response = self._convert_response_from_swap_price(quotes)\n        response.gas_price = gas_price or 0\n        if sell_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            response.value = str(sell_amount)\n        return response\n\n    async def get_swap_quote(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        taker_address: str,\n        chain_id: Optional[int] = None,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        ignore_checks: bool = False,\n        **kwargs,\n    ) -> Optional[ProviderQuoteResponse]:\n        params = {\n            'srcToken': sell_token,\n            'destToken': buy_token,\n            'amount': sell_amount,\n            'side': 'SELL',\n            'network': chain_id,\n            'otherExchangePrices': 'false',\n            'partner': self.config.PARTNER,\n            'version': self.VERSION,\n            'srcDecimals': kwargs.get('src_decimals'),\n            'destDecimals': kwargs.get('dest_decimals'),\n        }\n        if taker_address:\n            params['userAddress'] = taker_address\n        try:\n            response = await self.request(method='get', path='prices', params=params)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            e = self.handle_exception(\n                e, method='get_swap_quote', params=params, chain_id=chain_id\n            )\n            raise e\n\n        price_route = response['priceRoute']\n        ignore_checks = str(ignore_checks).lower()\n        params = {'network': price_route['network'], 'ignoreChecks': ignore_checks}\n        if gas_price is not None:\n            params['gasPrice'] = gas_price\n        data = {\n            'srcToken': sell_token,\n            'destToken': buy_token,\n            'srcAmount': str(sell_amount),\n            'priceRoute': price_route,\n            'userAddress': taker_address,\n            'partner': self.config.PARTNER,\n            'srcDecimals': price_route['srcDecimals'],\n            'destDecimals': price_route['destDecimals'],\n        }\n\n        if buy_token_percentage_fee:\n            data['partnerFeeBps'] = int(\n                buy_token_percentage_fee * 10000\n            )  # 100% -> 10000\n        if slippage_percentage:\n            data['slippage'] = int(slippage_percentage * 10000)  # 100% -> 10000\n        else:\n            data['destAmount'] = (str(price_route['destAmount']),)\n\n        if fee_recipient:\n            data['partnerAddress'] = fee_recipient\n\n        try:\n            response = await self.request(\n                method='post',\n                path=f'transactions/{price_route[\"network\"]}',\n                params=params,\n                json=data,\n            )\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            e = self.handle_exception(\n                e, response=response, data=data, params=params, chain_id=chain_id\n            )\n            raise e\n        return self._convert_response_from_swap_quote(response, price_route)\n\n    def _convert_response_from_swap_quote(\n        self,\n        quote_response: dict,\n        price_response: dict,\n        **kwargs,\n    ) -> Optional[ProviderQuoteResponse]:\n        price = Decimal(price_response['destAmount']) / Decimal(\n            price_response['srcAmount']\n        )\n        sources = self.convert_sources_for_meta_aggregation(price_response['bestRoute'])\n        try:\n            prepared_response = ProviderQuoteResponse(\n                sources=sources,\n                buy_amount=str(price_response['destAmount']),\n                gas=quote_response.get('gas', '0'),\n                sell_amount=price_response['srcAmount'],\n                to=quote_response['to'],\n                data=quote_response['data'],\n                gas_price=quote_response['gasPrice'],\n                value=quote_response['value'],\n                price=str(price),\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(\n                e,\n                response=quote_response,\n                method='_convert_response_from_swap_quote',\n                price_response=price,\n                **kwargs,\n            )\n            raise e\n        return prepared_response\n\n    def _convert_response_from_swap_price(\n        self, price_response: dict\n    ) -> Optional[ProviderPriceResponse]:\n        price_response = price_response['priceRoute']\n        dst_amount = (\n            Decimal(price_response['destAmount']) / 10 ** price_response['destDecimals']\n        )\n        src_amount = (\n            Decimal(price_response['srcAmount']) / 10 ** price_response['srcDecimals']\n        )\n        price = dst_amount / src_amount\n        sources = self.convert_sources_for_meta_aggregation(price_response['bestRoute'])\n        try:\n            prepared_response = ProviderPriceResponse(\n                provider=self.PROVIDER_NAME,\n                sources=sources,\n                buy_amount=str(price_response['destAmount']),\n                gas=price_response['gasCost'],\n                sell_amount=price_response['srcAmount'],\n                gas_price='0',\n                value='0',\n                price=str(price),\n                allowance_target=price_response['tokenTransferProxy'],\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(\n                e, response=price_response, method='_convert_response_from_swap_price'\n            )\n            raise e\n        else:\n            return prepared_response\n\n    @staticmethod\n    def convert_sources_for_meta_aggregation(\n        sources: Optional[Union[dict, list[dict]]],\n    ) -> Optional[list[SwapSources]]:\n        if not sources:\n            return\n        swaps = list(chain.from_iterable([i['swaps'] for i in sources]))\n        swap_exchanges = [i['swapExchanges'] for i in swaps]\n        sources_list = list(chain.from_iterable(i for i in swap_exchanges))\n        converted_sources = []\n        for source in sources_list:\n            converted_sources.append(\n                SwapSources(name=source['exchange'], proportion=source['percent'])\n            )\n        return converted_sources\n\n    def handle_exception(\n        self, exception: Union[ClientResponseError, KeyError, ValidationError], **kwargs\n    ) -> BaseAggregationProviderError:\n        \"\"\"\n        exception.message: '{'error': 'Not enough liquidity for this trade'}'\n        \"\"\"\n        exc = super().handle_exception(exception, **kwargs)\n        if exc:\n            logger.error(*exc.to_log_args(), extra=exc.to_dict())\n            return exc\n        msg = ujson.loads(exception.message).get('error', 'Unknown error')\n        for error, error_class in PARASWAP_ERRORS.items():\n            if re.search(error.lower(), msg.lower()):\n                break\n        else:\n            error_class = AggregationProviderError\n        exc = error_class(\n            self.PROVIDER_NAME,\n            msg,\n            url=str(exception.request_info.url),\n            **kwargs,\n        )\n        if isinstance(exc, EstimationError):\n            logger.warning(\n                f'potentially blacklist. %({LogArgs.token_idx})',\n                {\n                    LogArgs.token_idx: f\"{kwargs.get('token_address')}\"\n                    f\"-{kwargs.get('chain_id')}\"\n                },\n                extra={\n                    'token_address': kwargs.get('token_address'),\n                    'chain_id': kwargs.get('chain_id'),\n                },\n            )\n        logger.warning(*exc.to_log_args(), extra=exc.to_dict())\n        return exc\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/dependencies.py", "content": "import aiohttp\nimport fastapi\nfrom pydantic import BaseModel\n\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.config.providers import ProvidersConfig\nfrom meta_aggregation_api.services.chains import ChainsConfig\nfrom meta_aggregation_api.services.gas_service import GasService\nfrom meta_aggregation_api.services.limit_orders import LimitOrdersService\nfrom meta_aggregation_api.services.meta_aggregation_service import (\n    MetaAggregationService,\n)\n\n\nclass Dependencies(BaseModel):\n    \"\"\"\n    Holds the dependencies that should exist for the lifetime of the application.\n    \"\"\"\n\n    aiohttp_session: aiohttp.ClientSession\n    config: Config\n    chains: ChainsConfig\n    gas_service: GasService\n    limit_orders_service: LimitOrdersService\n    meta_aggregation_service: MetaAggregationService\n    providers: ProvidersConfig\n\n    class Config:\n        arbitrary_types_allowed = True\n        extra = \"forbid\"\n        allow_mutation = False\n\n    def register(self, app: fastapi.FastAPI):\n        \"\"\"\n        Registers itself in the application.\n        \"\"\"\n        app.state.dependencies = self\n\n\ndef _get(request: fastapi.Request) -> Dependencies:\n    return request.app.state.dependencies\n\n\ndef aiohttp_session(request: fastapi.Request) -> aiohttp.ClientSession:\n    return _get(request).aiohttp_session\n\n\ndef config(request: fastapi.Request) -> Config:\n    return _get(request).config\n\n\ndef chains(request: fastapi.Request) -> ChainsConfig:\n    return _get(request).chains\n\n\ndef gas_service(request: fastapi.Request) -> GasService:\n    return _get(request).gas_service\n\n\ndef limit_orders_service(request: fastapi.Request) -> LimitOrdersService:\n    return _get(request).limit_orders_service\n\n\ndef meta_aggregation_service(request: fastapi.Request) -> MetaAggregationService:\n    return _get(request).meta_aggregation_service\n\n\ndef providers(request: fastapi.Request) -> ProvidersConfig:\n    return _get(request).providers\n"}
{"type": "source_file", "path": "meta_aggregation_api/services/gas_service.py", "content": "from statistics import mean\nfrom time import time\nfrom typing import Optional\n\nfrom aiocache import cached\nfrom requests import ReadTimeout\nfrom tenacity import retry, retry_if_exception_type\n\nfrom meta_aggregation_api.clients.blockchain.web3_client import Web3Client\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.models.gas_models import GasResponse\nfrom meta_aggregation_api.services.chains import ChainsConfig\nfrom meta_aggregation_api.utils.cache import get_cache_config\nfrom meta_aggregation_api.utils.common import get_web3_url\nfrom meta_aggregation_api.utils.logger import get_logger\n\nGAS_SOURCE = 'DEXGURU'\n\nlogger = get_logger(__name__)\n\n\nclass GasService:\n    def __init__(\n        self,\n        *,\n        config: Config,\n        chains: ChainsConfig,\n    ):\n        self.config = config\n        self.chains = chains\n\n        self.cached = cached(ttl=5, **get_cache_config(config), noself=True)\n\n        self.get_gas_prices = self.cached(self.get_gas_prices)\n        self.get_base_gas_price = self.cached(self.get_base_gas_price)\n\n    async def get_gas_prices(self, chain_id: int) -> GasResponse:\n        logger.debug('Getting gas prices for network %s', chain_id)\n        web3_client = Web3Client(get_web3_url(chain_id, self.config), self.config)\n        if self.chains.get_chain_by_id(chain_id).eip1559:\n            return await self.get_gas_prices_eip1559(web3_client)\n        return await self.get_gas_prices_legacy(web3_client)\n\n    @retry(retry=retry_if_exception_type(ReadTimeout), stop=3)\n    async def get_base_gas_price(self, chain_id: int) -> int:\n        logger.debug('Getting base gas price for network %s', chain_id)\n        web3_client = Web3Client(get_web3_url(chain_id, self.config), self.config)\n        return await web3_client.w3.eth.gas_price\n\n    @retry(retry=retry_if_exception_type(ReadTimeout), stop=3)\n    async def get_gas_prices_eip1559(self, w3: Web3Client) -> Optional[GasResponse]:\n        gas_history = await w3.w3.eth.fee_history(4, 'latest', [60, 75, 90])\n        reward = gas_history['reward']\n        # baseFee for next block\n        base_fee = gas_history['baseFeePerGas'][-1]\n\n        reward_fast = [_[0] for _ in reward]\n        reward_instant = [_[1] for _ in reward]\n        reward_overkill = [_[2] for _ in reward]\n\n        fast_priority = int(mean(reward_fast))\n        instant_priority = int(mean(reward_instant))\n        overkill_priority = int(mean(reward_overkill))\n        return GasResponse.parse_obj(\n            {\n                'source': GAS_SOURCE,\n                'timestamp': int(time()),\n                'eip1559': {\n                    'fast': {\n                        'max_fee': base_fee + fast_priority,\n                        'base_fee': base_fee,\n                        'max_priority_fee': fast_priority,\n                    },\n                    'instant': {\n                        'max_fee': base_fee + instant_priority,\n                        'base_fee': base_fee,\n                        'max_priority_fee': instant_priority,\n                    },\n                    'overkill': {\n                        'max_fee': base_fee + overkill_priority,\n                        'base_fee': base_fee,\n                        'max_priority_fee': overkill_priority,\n                    },\n                },\n            }\n        )\n\n    @retry(retry=retry_if_exception_type(ReadTimeout), stop=3)\n    async def get_gas_prices_legacy(self, w3: Web3Client) -> GasResponse:\n        gas_price = await w3.w3.eth.gas_price\n        return GasResponse.parse_obj(\n            {\n                'source': GAS_SOURCE,\n                'timestamp': int(time()),\n                'legacy': {\n                    'fast': gas_price,\n                    'instant': gas_price,\n                    'overkill': gas_price,\n                },\n            }\n        )\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/create_app.py", "content": "import aiohttp\nimport pydantic\nfrom elasticapm.contrib.starlette import ElasticAPM\nfrom fastapi import FastAPI, Request, Response\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.gzip import GZipMiddleware\nfrom fastapi.responses import JSONResponse\nfrom fastapi_jwt_auth.exceptions import AuthJWTException\n\nfrom meta_aggregation_api.clients.apm_client import ApmClient\nfrom meta_aggregation_api.config import Config\nfrom meta_aggregation_api.providers import ProviderRegistry\nfrom meta_aggregation_api.providers.bebop_v3 import BebopProviderV3\nfrom meta_aggregation_api.providers.debridge_dln_v1 import DebridgeDlnProviderV1\nfrom meta_aggregation_api.providers.kyberswap_v1 import KyberSwapProviderV1\nfrom meta_aggregation_api.providers.one_inch_v5 import OneInchProviderV5\nfrom meta_aggregation_api.providers.openocean_v2 import OpenOceanProviderV2\nfrom meta_aggregation_api.providers.paraswap_v5 import ParaSwapProviderV5\nfrom meta_aggregation_api.providers.zerox_v1 import ZeroXProviderV1\nfrom meta_aggregation_api.rest_api import dependencies\nfrom meta_aggregation_api.rest_api.middlewares import RouteLoggerMiddleware\nfrom meta_aggregation_api.rest_api.routes.gas import gas_routes\nfrom meta_aggregation_api.rest_api.routes.info import info_route\nfrom meta_aggregation_api.rest_api.routes.limit_orders import limit_orders\nfrom meta_aggregation_api.rest_api.routes.rpc import v1_rpc\nfrom meta_aggregation_api.rest_api.routes.swap import swap_route\nfrom meta_aggregation_api.rest_api.routes.crosschain_swap import crosschain_swap_route\nfrom meta_aggregation_api.utils.errors import (BaseAggregationProviderError,\n                                               InternalError)\nfrom meta_aggregation_api.utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\ndef create_app(config: Config):\n    app = FastAPI(\n        title='DexGuru Trading API',\n        description=(\n            \"\"\"API serves as a DEX aggregators gateway and bargains finder (best quote) between assets and provides\n            unified interface wrapping up differences between different aggregators.\n            User request price, getting sorted list of quotes and bargain calcs,\n            and can request a quote (with tx data included) for selected bargain.\"\"\"\n        ),\n        version=config.VERSION,\n        docs_url='/',\n        redoc_url='/docs',\n        # openapi_tags=config.TAGS_METADATA\n    )\n\n    # Setup and register dependencies.\n    apm_client = ApmClient(config)\n    app.apm_client = apm_client\n    aiohttp_session = aiohttp.ClientSession(\n        trust_env=True,\n        headers={'x-sys-key': config.X_SYS_KEY},\n    )\n    chains = dependencies.ChainsConfig(\n        api_key=config.PUBLIC_KEY,\n        domain=config.PUBLIC_API_DOMAIN,\n    )\n    gas_service = dependencies.GasService(\n        config=config,\n        chains=chains,\n    )\n    providers = dependencies.ProvidersConfig()\n    provider_registry = ProviderRegistry(\n        ZeroXProviderV1(\n            session=aiohttp_session,\n            config=config,\n            chains=chains,\n            apm_client=apm_client,\n        ),\n        OneInchProviderV5(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n        ),\n        ParaSwapProviderV5(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n        ),\n        OpenOceanProviderV2(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n        ),\n        KyberSwapProviderV1(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n            chains=chains,\n        ),\n        DebridgeDlnProviderV1(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n            chains=chains,\n        ),\n        BebopProviderV3(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n            chains=chains,\n        )\n    )\n    crosschain_provider_registry = ProviderRegistry(\n        DebridgeDlnProviderV1(\n            config=config,\n            session=aiohttp_session,\n            apm_client=apm_client,\n            chains=chains,\n        ),\n    )\n    meta_aggregation_service = dependencies.MetaAggregationService(\n        config=config,\n        gas_service=gas_service,\n        chains=chains,\n        providers=providers,\n        session=aiohttp_session,\n        apm_client=apm_client,\n        provider_registry=provider_registry,\n        crosschain_provider_registry=crosschain_provider_registry,\n    )\n    limit_orders_service = dependencies.LimitOrdersService(\n        config=config,\n        session=aiohttp_session,\n        apm_client=apm_client,\n        provider_registry=provider_registry,\n    )\n    deps = dependencies.Dependencies(\n        aiohttp_session=aiohttp_session,\n        config=config,\n        chains=chains,\n        gas_service=gas_service,\n        limit_orders_service=limit_orders_service,\n        meta_aggregation_service=meta_aggregation_service,\n        providers=providers,\n    )\n    deps.register(app)\n\n    # Setup and register middlewares and routes.\n    register_cors(app, config)\n    register_gzip(app)\n    register_route(app)\n    register_route_logging(app)\n    if config.APM_ENABLED:\n        register_elastic_apm(app, apm_client)\n\n    # Common RFC 5741 Exceptions handling, https://tools.ietf.org/html/rfc5741#section-2\n    @app.exception_handler(Exception)\n    async def http_exception_handler(request: Request, exc: Exception):\n        exception_dict = {\n            \"type\": \"Internal Server Error\",\n            \"title\": exc.__class__.__name__,\n            \"instance\": f\"{config.SERVER_HOST}{request.url.path}\",\n            \"detail\": f\"{exc.__class__.__name__} at {str(exc)} when executing {request.method} request\",\n        }\n        pretty_exc = InternalError('code', exc.__traceback__)\n        logger.error(pretty_exc.to_log_args(), extra=pretty_exc.to_dict())\n        request.app.apm_client.client.capture_exception()\n        return JSONResponse(exception_dict, status_code=500)\n\n    @app.exception_handler(pydantic.error_wrappers.ValidationError)\n    async def handle_validation_error(\n        request: Request, exc: pydantic.error_wrappers.ValidationError\n    ):  # pylint: disable=unused-argument\n        \"\"\"\n        Handles validation errors.\n        \"\"\"\n        logger.error(exc.errors())\n        return JSONResponse({\"message\": exc.errors()}, status_code=422)\n\n    @app.exception_handler(BaseAggregationProviderError)\n    async def handle_aggregation_provider_error(\n        request: Request, exc: BaseAggregationProviderError\n    ):\n        logger.error(exc.to_log_args(), extra=exc.to_dict())\n        return exc.to_http_exception()\n\n    @app.exception_handler(AuthJWTException)\n    def authjwt_exception_handler(request: Request, exc: AuthJWTException):\n        kwargs = {\n            'jwt': request.headers.get('Authorization', 'no_jwt'),\n            'path': request.url.path,\n        }\n        pretty_exc = InternalError('code', exc.message, **kwargs)\n        logger.error(pretty_exc.to_log_args(), extra=pretty_exc.to_dict())\n        request.app.apm_client.client.capture_exception(\n            (type(exc), exc, exc.__traceback__)\n        )\n        return JSONResponse({\"detail\": exc.message}, status_code=exc.status_code)\n\n    @app.on_event(\"startup\")\n    async def startup_event():\n        await chains.set_chains()\n\n    @app.on_event(\"shutdown\")\n    async def shutdown_event():\n        await aiohttp_session.close()\n\n    @app.get(\"/health_check\", include_in_schema=False)\n    def health_check():\n        \"\"\"\n        Health check\n        ---\n        tags:\n            - util\n        responses:\n            200:\n                description: Returns \"OK\"\n        \"\"\"\n        return Response(\"OK\")\n\n    return app\n\n\ndef register_cors(app: FastAPI, config: Config):\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=config.CORS_ORIGINS,\n        allow_credentials=config.CORS_CREDENTIALS,\n        allow_methods=config.CORS_METHODS,\n        allow_headers=config.CORS_HEADERS,\n    )\n\n\ndef register_gzip(app: FastAPI):\n    app.add_middleware(GZipMiddleware, minimum_size=1000)\n\n\ndef register_route_logging(app: FastAPI):\n    app.add_middleware(RouteLoggerMiddleware)\n\n\ndef register_elastic_apm(app: FastAPI, apm_client: ApmClient):\n    app.add_middleware(ElasticAPM, client=apm_client.client)\n\n\ndef register_route(app: FastAPI):\n    app.include_router(v1_rpc, prefix=\"/v1\", tags=[\"RPC Requests\"])\n    app.include_router(gas_routes, prefix=\"/v1/gas\", tags=[\"Gas\"])\n    app.include_router(info_route, prefix=\"/v1/info\", tags=[\"Info\"])\n    app.include_router(swap_route, prefix=\"/v1/market\", tags=[\"Swap\"])\n    app.include_router(crosschain_swap_route, prefix=\"/v1/crosschain\", tags=[\"CrossChain Swap\"])\n    app.include_router(limit_orders, prefix=\"/v1/limit\", tags=[\"Limit Orders\"])\n"}
{"type": "source_file", "path": "meta_aggregation_api/providers/openocean_v2/openocean_provider_v2.py", "content": "import asyncio\nimport ssl\nfrom _decimal import Decimal\nfrom pathlib import Path\nfrom typing import Optional, Union\n\nimport ujson\nfrom aiohttp import ClientResponse, ClientResponseError, ServerDisconnectedError\nfrom pydantic import ValidationError\n\nfrom meta_aggregation_api.models.meta_agg_models import (\n    ProviderPriceResponse,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.models.provider_response_models import SwapSources\nfrom meta_aggregation_api.providers.base_provider import BaseProvider\nfrom meta_aggregation_api.utils.errors import (\n    AggregationProviderError,\n    BaseAggregationProviderError,\n)\nfrom meta_aggregation_api.utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass OpenOceanProviderV2(BaseProvider):\n    \"\"\"https://docs.openocean.finance/dev/openocean-api-3.0/api-reference\"\"\"\n\n    TRADING_API = 'https://ethapi.openocean.finance/v2'\n\n    with open(Path(__file__).parent / 'config.json') as f:\n        PROVIDER_NAME = ujson.load(f)['name']\n\n    async def _get_response(self, url: str, params: Optional[dict] = None) -> dict:\n        async with self.aiohttp_session.get(\n            url, params=params, timeout=self.REQUEST_TIMEOUT, ssl=ssl.SSLContext()\n        ) as response:\n            response: ClientResponse\n            logger.debug(f'Request GET {response.url}')\n            data = await response.json()\n            try:\n                response.raise_for_status()\n            except ClientResponseError as e:\n                # Fix bug with HTTP status code 0.\n                status = 500 if e.status not in range(100, 600) else e.status\n                data['source'] = 'proxied OpenOcean API'\n                raise ClientResponseError(\n                    request_info=e.request_info,\n                    history=e.history,\n                    status=status,\n                    # Hack for error init method: expected str, but list and dict also works.\n                    message=[data],\n                    headers=e.headers,\n                )\n        return data\n\n    async def get_swap_price(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = 1,\n        taker_address: Optional[str] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        **_,\n    ):\n        if buy_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            buy_token = '0x0000000000000000000000000000000000000000'\n\n        if sell_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            sell_token = '0x0000000000000000000000000000000000000000'\n\n        url = '%s/%s/quote' % (self.TRADING_API, chain_id)\n        params = {\n            'inTokenAddress': sell_token,\n            'outTokenAddress': buy_token,\n            'amount': sell_amount,\n        }\n        if slippage_percentage:\n            params['slippage'] = slippage_percentage * 10000\n        if gas_price:\n            params['gasPrice'] = gas_price\n        if taker_address:\n            params['account'] = taker_address\n        if fee_recipient:\n            params['referrer'] = fee_recipient\n        if buy_token_percentage_fee:\n            params['referrerFee'] = buy_token_percentage_fee * 100\n        try:\n            response = await self._get_response(url, params)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            exc = self.handle_exception(\n                e, params=params, token_address=sell_token, chain_id=chain_id\n            )\n            raise exc\n        return self._convert_response_from_swap_price(response, gas_price, url=url)\n\n    async def get_swap_quote(\n        self,\n        buy_token: str,\n        sell_token: str,\n        sell_amount: int,\n        chain_id: int,\n        taker_address: str,\n        gas_price: Optional[int] = None,\n        slippage_percentage: Optional[float] = None,\n        fee_recipient: Optional[str] = None,\n        buy_token_percentage_fee: Optional[float] = None,\n        **_,\n    ) -> ProviderQuoteResponse:\n        if buy_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            buy_token = '0x0000000000000000000000000000000000000000'\n\n        if sell_token.lower() == self.config.NATIVE_TOKEN_ADDRESS:\n            sell_token = '0x0000000000000000000000000000000000000000'\n\n        url = '%s/%s/swap' % (self.TRADING_API, chain_id)\n        params = {\n            'inTokenAddress': sell_token,\n            'outTokenAddress': buy_token,\n            'amount': sell_amount,\n            'account': taker_address,\n        }\n        if slippage_percentage:\n            params['slippage'] = slippage_percentage * 10000\n        if gas_price:\n            params['gasPrice'] = gas_price\n        if fee_recipient:\n            params['referrer'] = fee_recipient\n        if buy_token_percentage_fee:\n            params['referrerFee'] = buy_token_percentage_fee * 100\n        try:\n            response = await self._get_response(url, params)\n        except (\n            ClientResponseError,\n            asyncio.TimeoutError,\n            ServerDisconnectedError,\n        ) as e:\n            exc = self.handle_exception(\n                e, params=params, token_address=sell_token, chain_id=chain_id\n            )\n            raise exc\n        return self._convert_response_from_swap_quote(response)\n\n    def _convert_response_from_swap_price(\n        self,\n        response: dict,\n        gas_price: int,\n        **kwargs,\n    ) -> ProviderPriceResponse:\n        sources = self.convert_sources_for_meta_aggregation(response['path']['routes'])\n        value = '0'\n        sell_amount = Decimal(response['inAmount']) / 10 ** Decimal(\n            response['inToken']['decimals']\n        )\n        buy_amount = Decimal(response['outAmount']) / 10 ** Decimal(\n            response['outToken']['decimals']\n        )\n        price = buy_amount / sell_amount\n        if response['inToken']['address'] == self.config.NATIVE_TOKEN_ADDRESS:\n            value = response['inAmount']\n        try:\n            return ProviderPriceResponse(\n                provider=self.PROVIDER_NAME,\n                sources=sources,\n                buy_amount=response['outAmount'],\n                sell_amount=response['inAmount'],\n                gas=response['estimatedGas'],\n                gas_price=str(gas_price),\n                value=value,\n                price=str(price),\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(\n                e,\n                response=response,\n                method='_convert_response_from_swap_quote',\n                price=price,\n                **kwargs,\n            )\n            raise e\n\n    def _convert_response_from_swap_quote(\n        self, response: dict\n    ) -> ProviderQuoteResponse:\n        sell_amount = Decimal(response['inAmount']) / 10 ** Decimal(\n            response['inToken']['decimals']\n        )\n        buy_amount = Decimal(response['outAmount']) / 10 ** Decimal(\n            response['outToken']['decimals']\n        )\n        price = buy_amount / sell_amount\n        try:\n            return ProviderQuoteResponse(\n                sources=[],\n                buy_amount=response['outAmount'],\n                sell_amount=response['inAmount'],\n                gas=response['estimatedGas'],\n                gas_price=response['gasPrice'],\n                value=response['value'],\n                price=str(price),\n                data=response['data'],\n                to=response['to'],\n            )\n        except (KeyError, ValidationError) as e:\n            e = self.handle_exception(\n                e, response=response, method='_convert_response_from_swap_quote'\n            )\n            raise e\n\n    @staticmethod\n    def convert_sources_for_meta_aggregation(sources: list) -> list:\n        converted_sources = []\n        for source in sources:\n            for route in source.get('subRoutes', []):\n                for dex in route.get('dexes', []):\n                    converted_sources.append(\n                        SwapSources(\n                            name=dex['dex'],\n                            proportion=dex['percentage'],\n                        )\n                    )\n        return converted_sources\n\n    def handle_exception(\n        self,\n        exception: Union[ClientResponseError, KeyError, ValidationError],\n        **kwargs,\n    ) -> BaseAggregationProviderError:\n        exc = super().handle_exception(exception, **kwargs)\n        if exc:\n            logger.error(*exc.to_log_args(), extra=exc.to_dict())\n            return exc\n        msg = exception.message\n        exc = AggregationProviderError(\n            self.PROVIDER_NAME,\n            msg,\n            **kwargs,\n        )\n        return exc\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/__init__.py", "content": ""}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/routes/swap.py", "content": "from typing import List, Optional\n\nfrom fastapi import APIRouter, Depends, Path, Query, HTTPException\nfrom fastapi.security import HTTPBearer\nfrom pydantic import conint\n\nfrom meta_aggregation_api.config.auth import AuthJWT\nfrom meta_aggregation_api.models.meta_agg_models import (\n    MetaPriceModel,\n    ProviderQuoteResponse,\n)\nfrom meta_aggregation_api.rest_api import dependencies\nfrom meta_aggregation_api.utils.common import address_to_lower\nfrom meta_aggregation_api.utils.errors import responses\n\nPRICE_CACHE_TTL_SEC = 5\nswap_route = APIRouter()\n\n\n@swap_route.get('/{chain_id}/price', response_model=MetaPriceModel, responses=responses)\n@swap_route.get(\n    '/{chain_id}/price/', response_model=MetaPriceModel, include_in_schema=False\n)\nasync def get_swap_price(\n    buy_token: address_to_lower = Query(..., alias='buyToken'),\n    sell_token: address_to_lower = Query(..., alias='sellToken'),\n    sell_amount: conint(gt=0) = Query(..., alias='sellAmount'),\n    chain_id: int = Path(..., description='Chain ID'),\n    gas_price: Optional[int] = Query(\n        None, description='Gas price', gt=0, alias='gasPrice'\n    ),\n    slippage_percentage: Optional[float] = Query(\n        0.005, gte=0, alias='slippagePercentage'\n    ),\n    taker_address: Optional[address_to_lower] = Query(None, alias='takerAddress'),\n    fee_recipient: Optional[address_to_lower] = Query(None, alias='feeRecipient'),\n    buy_token_percentage_fee: Optional[float] = Query(\n        None, alias='buyTokenPercentageFee'\n    ),\n    provider: Optional[str] = Query(None, alias='provider'),\n    meta_aggregation_service: dependencies.MetaAggregationService = Depends(\n        dependencies.meta_aggregation_service\n    ),\n) -> MetaPriceModel:\n    \"\"\"\n    Price endpoints are used to get the best price for a swap. It does not return data for swap and therefore\n    require any approvals. If you want to get data for swap, use /price_response endpoint.\n\n    - **buy_token**: Address of the token to buy\n    - **sell_token**: Address of the token to sell\n    - **sell_amount**: Amount of the token to sell in base units (e.g. 1 ETH = 10**18)\n    - **chain_id**: Chain ID. See /info for supported chains\n    - **gas_price**: Gas price in wei (optional)\n    - **slippage_percentage**: Slippage percentage  (0.01 = 1%) (default: 0.005)\n    - **taker_address**: Address of the taker (optional)\n    - **fee_recipient**: Address of the fee recipient (optional)\n    - **buy_token_percentage_fee**: Percentage of the buy token fee (optional) (0.01 = 1%)\n    - **provider**: Provider name from /info (optional). If not specified, the best price will be returned\n    \"\"\"\n    params = {\n        \"buy_token\": buy_token,\n        \"sell_token\": sell_token,\n        \"sell_amount\": sell_amount,\n        \"chain_id\": chain_id,\n        \"gas_price\": gas_price,\n        \"slippage_percentage\": slippage_percentage,\n        \"taker_address\": taker_address,\n        \"fee_recipient\": fee_recipient,\n        \"buy_token_percentage_fee\": buy_token_percentage_fee,\n    }\n    if provider:\n        res = await meta_aggregation_service.get_provider_price(\n            provider=provider, **params\n        )\n        if not res:\n            raise HTTPException(\n                status_code=404,\n                detail='No prices found',\n            )\n        return res\n    else:\n        res = await meta_aggregation_service.get_swap_meta_price(**params)\n    if not res:\n        raise HTTPException(\n            status_code=404,\n            detail='No prices found',\n        )\n    return next((quote for quote in res if quote.is_best), None)\n\n\n@swap_route.get(\n    '/{chain_id}/price/all', response_model=List[MetaPriceModel], responses=responses\n)\n@swap_route.get(\n    '/{chain_id}/price/all/',\n    include_in_schema=False,\n    response_model=List[MetaPriceModel],\n)\nasync def get_all_swap_prices(\n    buy_token: address_to_lower = Query(..., alias='buyToken'),\n    sell_token: address_to_lower = Query(..., alias='sellToken'),\n    sell_amount: conint(gt=0) = Query(..., alias='sellAmount'),\n    chain_id: int = Path(..., description='Chain ID'),\n    gas_price: Optional[int] = Query(\n        None, description='Gas price', gt=0, alias='gasPrice'\n    ),\n    slippage_percentage: Optional[float] = Query(0.005, alias='slippagePercentage'),\n    taker_address: Optional[address_to_lower] = Query(None, alias='takerAddress'),\n    fee_recipient: Optional[address_to_lower] = Query(None, alias='feeRecipient'),\n    buy_token_percentage_fee: Optional[float] = Query(\n        None, alias='buyTokenPercentageFee'\n    ),\n    meta_aggregation_service: dependencies.MetaAggregationService = Depends(\n        dependencies.meta_aggregation_service\n    ),\n) -> List[MetaPriceModel]:\n    \"\"\"\n    Works the same as /price endpoint, but returns all prices from all supported providers.\n\n    - **buy_token**: Address of the token to buy\n    - **sell_token**: Address of the token to sell\n    - **sell_amount**: Amount of the token to sell in base units (e.g. 1 ETH = 10**18)\n    - **chain_id**: Chain ID. See /info for supported chains\n    - **gas_price**: Gas price in wei (optional)\n    - **slippage_percentage**: Slippage percentage  (0.01 = 1%) (default: 0.005)\n    - **taker_address**: Address of the taker (optional)\n    - **fee_recipient**: Address of the fee recipient (optional)\n    - **buy_token_percentage_fee**: Percentage of the buy token fee (optional) (0.01 = 1%)\n    \"\"\"\n    res = await meta_aggregation_service.get_swap_meta_price(\n        buy_token=buy_token,\n        sell_token=sell_token,\n        sell_amount=sell_amount,\n        chain_id=chain_id,\n        gas_price=gas_price,\n        slippage_percentage=slippage_percentage,\n        taker_address=taker_address,\n        fee_recipient=fee_recipient,\n        buy_token_percentage_fee=buy_token_percentage_fee,\n    )\n    if not res:\n        raise HTTPException(\n            status_code=404,\n            detail='No prices found',\n        )\n    return res\n\n\n@swap_route.get(\n    '/{chain_id}/quote',\n    response_model=ProviderQuoteResponse,\n    responses=responses,\n    # dependencies=[Depends(HTTPBearer())],\n)\n@swap_route.get(\n    '/{chain_id}/quote/',\n    response_model=ProviderQuoteResponse,\n    include_in_schema=False,\n    # dependencies=[Depends(HTTPBearer())],\n)\nasync def get_swap_quote(\n    # authorize: AuthJWT = Depends(),\n    buy_token: address_to_lower = Query(..., alias='buyToken'),\n    sell_token: address_to_lower = Query(..., alias='sellToken'),\n    sell_amount: conint(gt=0) = Query(..., alias='sellAmount'),\n    chain_id: int = Path(..., description='Chain ID'),\n    provider: str = Query(..., alias='provider'),\n    taker_address: address_to_lower = Query(..., alias='takerAddress'),\n    gas_price: Optional[int] = Query(\n        None, description='Gas price', gt=0, alias='gasPrice'\n    ),\n    slippage_percentage: Optional[float] = Query(0.005, alias='slippagePercentage'),\n    fee_recipient: Optional[address_to_lower] = Query(None, alias='feeRecipient'),\n    buy_token_percentage_fee: Optional[float] = Query(\n        None, alias='buyTokenPercentageFee'\n    ),\n    meta_aggregation_service: dependencies.MetaAggregationService = Depends(\n        dependencies.meta_aggregation_service\n    ),\n) -> ProviderQuoteResponse:\n    \"\"\"\n    Returns a data for swap from a specific provider.\n\n    - **buy_token**:Address of the token to buy\n    - **sell_token**:Address of the token to sell\n    - **sell_amount**:Amount of the token to sell in base units (e.g. 1 ETH = 10**18)\n    - **chain_id**: Chain ID. See /info for supported chains\n    - **provider**: Provider name from /info\n    - **gas_price**: Gas price in wei (optional)\n    - **slippage_percentage**: Slippage percentage  (0.01 = 1%) (default: 0.005)\n    - **taker_address**: Address of the taker (optional)\n    - **fee_recipient**: Address of the fee recipient (optional)\n    - **buy_token_percentage_fee**: Percentage of the buy token fee (optional) (0.01 = 1%)\n    \"\"\"\n    # authorize.jwt_required()\n    quote = await meta_aggregation_service.get_meta_swap_quote(\n        buy_token=buy_token,\n        sell_token=sell_token,\n        sell_amount=sell_amount,\n        chain_id=chain_id,\n        provider=provider,\n        gas_price=gas_price,\n        slippage_percentage=slippage_percentage,\n        taker_address=taker_address,\n        fee_recipient=fee_recipient,\n        buy_token_percentage_fee=buy_token_percentage_fee,\n    )\n    return quote\n"}
{"type": "source_file", "path": "meta_aggregation_api/rest_api/routes/rpc.py", "content": "import ssl\n\nimport aiohttp\nfrom aiocache import cached\nfrom aiohttp import ClientResponseError\nfrom fastapi import APIRouter, Depends, HTTPException, Path\nfrom fastapi.security import HTTPBearer\nfrom fastapi_jwt_auth import AuthJWT\nfrom starlette.requests import Request\n\nfrom meta_aggregation_api.rest_api import dependencies\nfrom meta_aggregation_api.rest_api.dependencies import aiohttp_session\nfrom meta_aggregation_api.utils.cache import get_cache_config\nfrom meta_aggregation_api.utils.common import get_web3_url\nfrom meta_aggregation_api.utils.logger import get_logger\n\nv1_rpc = APIRouter()\nlogger = get_logger(__name__)\n\n\n@v1_rpc.post('/rpc/{chain_id}', dependencies=[Depends(HTTPBearer())])\nasync def send_rpc(\n    request: Request,\n    authorize: AuthJWT = Depends(),\n    chain_id: int = Path(..., description=\"Chain ID\"),\n    session: aiohttp.ClientSession = Depends(aiohttp_session),\n    config: dependencies.Config = Depends(dependencies.config),\n):\n    \"\"\"\n    The send_rpc function is an endpoint that makes an HTTP request to the node\n    that is currently synced with the most other nodes. It takes in a JSON-RPC 2.0 compliant\n    request and returns a JSON-RPC 2.0 compliant response.\n    \"\"\"\n\n    authorize.jwt_required()\n    node = get_web3_url(chain_id, config)\n    body = await request.json()\n    if body.get('method') == 'eth_chainId':\n        return {'jsonrpc': '2.0', 'id': body['id'], 'result': hex(chain_id)}\n    if body.get('method') == 'net_version':\n        return {'jsonrpc': '2.0', 'id': body['id'], 'result': str(chain_id)}\n\n    @cached(ttl=5, **get_cache_config(config))\n    async def make_request(node_, body_):\n        try:\n            async with session.post(\n                node_, proxy=None, json=body_, ssl=ssl.SSLContext()\n            ) as response:\n                return await response.json()\n        except ClientResponseError as e:\n            raise HTTPException(status_code=e.status, detail=e.message)\n\n    return await make_request(node, body)\n"}

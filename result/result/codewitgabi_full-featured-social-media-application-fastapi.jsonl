{"repo_info": {"repo_name": "full-featured-social-media-application-fastapi", "repo_owner": "codewitgabi", "repo_url": "https://github.com/codewitgabi/full-featured-social-media-application-fastapi"}}
{"type": "test_file", "path": "api/v1/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "api/v1/tests/auth/test_user_login.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom uuid import uuid4\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom api.v1.services.user import UserService\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/auth/login\"\nmock_id = str(uuid4())\n\n\ndef test_login_success(\n    mock_db_session: Session,\n    mock_user_service: UserService,\n    override_handle_login: None,\n):\n    \"\"\"Test for successful user login\"\"\"\n\n    response = client.post(\n        endpoint, json={\"email\": \"test@example.com\", \"password\": \"12345\"}\n    )\n\n    assert response.status_code == 200\n    assert response.json() == {\n        \"status_code\": 200,\n        \"message\": \"User login successful\",\n        \"data\": {\n            \"access_token\": \"'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.KkiNWdzcAgD_0PF169pvBausbptBe1mSQcTorMEqciA\",\n            \"user\": {\n                \"id\": \"341df7fe-3d16-4c43-a0eb-5f7e2940d012\",\n                \"username\": \"test\",\n                \"email\": \"test@example.com\",\n                \"role\": \"user\",\n            },\n        },\n    }\n\n\ndef test_incorrect_email(\n    mock_db_session: Session,\n    mock_user_service: UserService,\n    mock_invalid_account_effect: None,\n):\n    \"\"\"Test for incorrect email address\"\"\"\n\n    response = client.post(\n        endpoint, json={\"email\": \"test@example.com\", \"password\": \"12345\"}\n    )\n\n    assert response.status_code == 400\n    assert response.json() == {\n        \"status_code\": 400,\n        \"message\": \"No account associated with provided email\",\n    }\n\n\ndef test_incorrect_password(\n    mock_db_session: Session,\n    mock_user_service: UserService,\n    mock_incorrect_password: None,\n):\n    \"\"\"Test for incorrect password\"\"\"\n\n    response = client.post(\n        endpoint, json={\"email\": \"test@example.com\", \"password\": \"12345\"}\n    )\n\n    assert response.status_code == 400\n    assert response.json() == {\n        \"status_code\": 400,\n        \"message\": \"Incorrect password\",\n    }\n"}
{"type": "test_file", "path": "api/v1/tests/auth/test_user_logout.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom unittest.mock import patch\nfrom uuid import uuid4\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom api.v1.services.user import UserService, user_service\nfrom api.v1.models.user import User\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/auth/logout\"\n\n\ndef test_logout_success(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n):\n    response = client.post(\n        endpoint, headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n\n    data = response.json()\n\n    assert response.status_code == 200\n    assert data[\"status_code\"] == 200\n    assert data[\"message\"] == \"User logged out successfully\"\n"}
{"type": "test_file", "path": "api/v1/tests/notification/conftest.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../\"))\n)\n\nimport pytest\nimport fastapi\nfrom unittest.mock import patch\n\n\n@pytest.fixture\ndef mock_get_notifications():\n    with patch(\n        \"api.v1.services.notification.notification_service.notifications\"\n    ) as get_notifications:\n        get_notifications.return_value = [\n            {\n                \"id\": \"hhh\",\n                \"message\": \"test notification\",\n                \"created_at\": \"today\",\n                \"status\": \"unread\",\n            },\n        ]\n        yield get_notifications\n"}
{"type": "test_file", "path": "api/v1/tests/notification/test_get_notifications.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../\"))\n)\n\n\nfrom main import app\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\n\nclient = TestClient(app)\nendpoint = \"/api/v1/notifications\"\n\n\ndef test_get_notifications(\n    mock_db_session: Session,\n    current_user,\n    access_token,\n    mock_get_notifications,\n):\n\n    response = client.get(\n        endpoint,\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n    )\n\n    assert response.status_code == 200\n    assert response.json()[\"data\"] == [\n        {\n            \"id\": \"hhh\",\n            \"message\": \"test notification\",\n            \"created_at\": \"today\",\n            \"status\": \"unread\",\n        },\n    ]\n"}
{"type": "test_file", "path": "api/v1/tests/post/test_create_post.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/posts\"\n\n\ndef test_create_post_success(\n    mock_db_session: Session, access_token, current_user, mock_create_post\n):\n    response = client.post(\n        endpoint,\n        headers={\"authorization\": f\"Bearer {access_token}\"},\n        json={\"content\": \"Test post content\"},\n    )\n\n    assert response.status_code == 201\n    assert response.json()[\"status_code\"] == 201\n    assert response.json()[\"data\"] == {\n        \"user_id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n        \"video\": None,\n        \"id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n        \"image\": None,\n        \"content\": \"Lorem ipsum dolor sit amet.\",\n        \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n        \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n    }\n\n\ndef test_create_post_invalid_content(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n):\n    response = client.post(\n        endpoint, headers={\"authorization\": f\"Bearer {access_token}\"}, json={}\n    )\n\n    assert response.status_code == 400\n    assert response.json()[\"status_code\"] == 400\n    assert response.json()[\"message\"] == \"Please provide one of content, image or video\"\n\n\ndef test_create_post_unauthenticated_user(\n    mock_db_session: Session,\n):\n    response = client.post(endpoint, json={})\n\n    assert response.status_code == 401\n"}
{"type": "test_file", "path": "api/v1/tests/post/test_delete_post.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/posts/xx-yy-zz\"\n\n\ndef test_delete_post_success(\n    mock_db_session: Session, access_token, current_user, mock_create_post\n):\n    response = client.delete(\n        endpoint, headers={\"authorization\": f\"Bearer {access_token}\"}\n    )\n\n    assert response.status_code == 204\n    assert response.json()[\"status_code\"] == 204\n    assert response.json()[\"message\"] == \"Post deleted successfully\"\n\n\ndef test_delete_post_not_found(\n    mock_db_session: Session, access_token, current_user, mock_delete_post_side_effect\n):\n    response = client.delete(\n        endpoint, headers={\"authorization\": f\"Bearer {access_token}\"}\n    )\n\n    assert response.status_code == 404\n    assert response.json()[\"status_code\"] == 404\n    assert response.json()[\"message\"] == \"Post not found\"\n\n\ndef test_create_post_unauthenticated_user(\n    mock_db_session: Session,\n):\n    response = client.delete(endpoint)\n\n    assert response.status_code == 401\n"}
{"type": "test_file", "path": "api/v1/tests/post/test_post_like.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/posts/dgdvdy38ixh/like\"\n\n\ndef test_like_post(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_like_post,\n):\n\n    response = client.patch(\n        endpoint, headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n\n    assert response.status_code == 200\n\n\ndef test_get_likes(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_get_post_likes,\n):\n\n    response = client.get(endpoint, headers={\"Authorization\": f\"Bearer {access_token}\"})\n\n    assert response.status_code == 200\n    assert response.json()[\"status_code\"] == 200\n    assert response.json()[\"data\"] == {\n        \"user_id\": \"xxx\",\n        \"post_id\": \"yyy\",\n        \"liked\": \"True\",\n        \"user\": {\"id\": \"jjj\", \"image\": \"hhh\"},\n    }\n"}
{"type": "test_file", "path": "api/v1/tests/post/test_repost.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nimport pytest\nfrom main import app\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\n\n\nclient = TestClient(app)\nendpoint = \"api/v1/posts/ggg/repost\"\n\n\ndef test_repost(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_repost,\n):\n\n    response = client.post(\n        endpoint,\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n        json={\"content\": \"Test repost\"},\n    )\n\n    assert response.status_code == 201\n    assert response.json()[\"status_code\"] == 201\n    assert response.json()[\"message\"] == \"Reposted successfully\"\n    assert response.json()[\"data\"] == {\n        \"user_id\": \"zzz\",\n        \"post_id\": \"hhh\",\n        \"content\": \"Test repost\",\n        \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n        \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n        \"repost_owner\": {\"id\": \"jjj\", \"image\": \"/picture\", \"username\": \"joshua\"},\n        \"original_post\": {\n            \"id\": \"kkk\",\n            \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"content\": \"Tgis is the original post\",\n            \"video\": \"null\",\n            \"images\": \"null\",\n            \"original_post_owner\": {\n                \"id\": \"iii\",\n                \"image\": \"/picture\",\n                \"username\": \"joseph\",\n            },\n        },\n    }\n"}
{"type": "test_file", "path": "api/v1/tests/post/test_update_post.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/posts/post-id\"\n\n\ndef test_update_post_success(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_update_post,\n):\n    response = client.patch(\n        endpoint,\n        headers={\"authorization\": f\"Bearer {access_token}\"},\n        json={\"content\": \"Update post content\"},\n    )\n\n    data = response.json()\n\n    assert response.status_code == 200\n    assert data[\"status_code\"] == 200\n    assert data[\"message\"] == \"Post updated successfully\"\n    assert data[\"data\"] == {\n        \"user_id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n        \"video\": None,\n        \"id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n        \"image\": None,\n        \"content\": \"Update post content\",\n    }\n\n\ndef test_update_post_no_request_body(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_update_post_no_body_side_effect,\n):\n    response = client.patch(\n        endpoint,\n        headers={\"authorization\": f\"Bearer {access_token}\"},\n        json={},\n    )\n\n    data = response.json()\n\n    assert response.status_code == 400\n    assert data[\"status_code\"] == 400\n    assert data[\"message\"] == \"Please provide one of content, image or video\"\n\n\ndef test_update_post_not_found(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_update_post_not_found_side_effect,\n):\n    response = client.patch(\n        endpoint,\n        headers={\"authorization\": f\"Bearer {access_token}\"},\n        json={\"content\": \"Update post content\"},\n    )\n\n    data = response.json()\n\n    assert response.status_code == 404\n    assert data[\"status_code\"] == 404\n    assert data[\"message\"] == \"Post not found\"\n"}
{"type": "test_file", "path": "api/v1/tests/post_comment/__init__.py", "content": ""}
{"type": "test_file", "path": "api/v1/tests/post_comment/conftest.py", "content": "import os\nimport sys\n\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../\"))\n)\n\nfrom fastapi import HTTPException\nfrom main import app\nimport pytest\nfrom uuid import uuid4\nfrom unittest.mock import patch\n\nmock_id = str(uuid4())\n\n\n@pytest.fixture\ndef mock_create_comment():\n    with patch(\"api.v1.services.post_comment.comment_service.create\") as create_comment:\n\n        create_comment.return_value = {\n            \"id\": \"02bb30ec-c793-463f-a2ea-d83edd157738\",\n            \"comment\": \"This is a very nice post\",\n            \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"post_id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n            \"user\": {\n                \"id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n                \"username\": \"izzyjosh\",\n                \"profile_picture\": {\n                    \"id\": \"02bb30ec-c793-463f-a2ea-d83edd159938\",\n                    \"image\": \"user/profile_picture.img\",\n                },\n            },\n        }\n\n        yield create_comment\n\n\n@pytest.fixture\ndef mock_create_comment_no_content_side_effect():\n    with patch(\n        \"api.v1.services.post_comment.comment_service.create\"\n    ) as create_comment_side_effect:\n\n        create_comment_side_effect.side_effect = HTTPException(\n            400, \"please provide a comment\"\n        )\n        yield create_comment_side_effect\n\n\n@pytest.fixture\ndef mock_create_comment_post_not_found_side_effect():\n    with patch(\n        \"api.v1.services.post_comment.comment_service.create\"\n    ) as create_comment_post_not_found_side_effect:\n\n        create_comment_post_not_found_side_effect.side_effect = HTTPException(\n            404, \"Post not found\"\n        )\n        yield create_comment_post_not_found_side_effect\n\n\n@pytest.fixture\ndef mock_update_comment():\n    with patch(\"api.v1.services.post_comment.comment_service.update\") as update_comment:\n\n        update_comment.return_value = {\n            \"id\": \"02bb30ec-c793-463f-a2ea-d83edd157738\",\n            \"comment\": \"This is a very nice post\",\n            \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"updated_at\": \"2024-08-23T11:59:25.816336+01:00\",\n            \"post_id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n            \"user\": {\n                \"id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n                \"username\": \"izzyjosh\",\n                \"profile_picture\": {\n                    \"id\": \"02bb30ec-c793-463f-a2ea-d83edd159938\",\n                    \"image\": \"user/profile_picture.img\",\n                },\n            },\n        }\n        yield update_comment\n\n\n@pytest.fixture\ndef mock_update_comment_post_not_found_side_effect():\n    with patch(\n        \"api.v1.services.post_comment.comment_service.update\"\n    ) as comment_update_post_not_found:\n\n        comment_update_post_not_found.side_effect = HTTPException(404, \"Post not found\")\n\n        yield comment_update_post_not_found\n\n\n@pytest.fixture\ndef mock_update_comment_no_content_side_effect():\n    with patch(\n        \"api.v1.services.post_comment.comment_service.update\"\n    ) as comment_update_no_content:\n\n        comment_update_no_content.side_effect = HTTPException(\n            400, \"Please provide comment content\"\n        )\n\n        yield comment_update_no_content\n\n\n@pytest.fixture\ndef mock_delete_comment_comment_not_found_side_effect():\n    with patch(\n        \"api.v1.services.post_comment.comment_service.delete\"\n    ) as delete_comment_side_effect:\n\n        delete_comment_side_effect.side_effect = HTTPException(404, \"comment not found\")\n\n        yield delete_comment_side_effect\n\n\n@pytest.fixture\ndef mock_get_comments():\n    with patch(\n        \"api.v1.services.post_comment.comment_service.get_comments\"\n    ) as get_comments:\n\n        get_comments.return_value = [\n            {\n                \"id\": \"02bb30ec-c793-463f-a2ea-d83edd157738\",\n                \"comment\": \"This is a very nice post\",\n                \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n                \"updated_at\": \"2024-08-23T11:59:25.816336+01:00\",\n                \"post_id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n                \"user\": {\n                    \"id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n                    \"username\": \"izzyjosh\",\n                    \"profile_picture\": {\n                        \"id\": \"02bb30ec-c793-463f-a2ea-d83edd159938\",\n                        \"image\": \"user/profile_picture.img\",\n                    },\n                },\n            },\n            {\n                \"id\": \"02bb30ec-c793-463f-a2ea-d83edd157738\",\n                \"comment\": \"This is a very nice post\",\n                \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n                \"updated_at\": \"2024-08-23T11:59:25.816336+01:00\",\n                \"post_id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n                \"user\": {\n                    \"id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n                    \"username\": \"izzyjosh\",\n                    \"profile_picture\": {\n                        \"id\": \"02bb30ec-c793-463f-a2ea-d83edd159938\",\n                        \"image\": \"user/profile_picture.img\",\n                    },\n                },\n            },\n        ]\n\n        yield get_comments\n"}
{"type": "test_file", "path": "api/v1/tests/user/test_delete_user.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/users/123\"\n\n\ndef test_delete_user(\n    mock_db_session: Session, access_token, current_user, mock_delete_user\n):\n    response = client.delete(\n        endpoint, headers={\"authorization\": f\"Bearer {access_token}\"}\n    )\n\n    data = response.json()\n\n    assert response.status_code == 204\n    assert data[\"status_code\"] == 204\n    assert data[\"message\"] == \"User deleted successfully\"\n\n\ndef test_delete_user_permission_denied(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_delete_user_effect,\n):\n    response = client.delete(\n        endpoint, headers={\"authorization\": f\"Bearer {access_token}\"}\n    )\n\n    data = response.json()\n\n    assert response.status_code == 403\n    assert data[\"status_code\"] == 403\n    assert data[\"message\"] == \"You do not have permission to delete this user\"\n"}
{"type": "test_file", "path": "api/v1/tests/user/conftest.py", "content": "from fastapi import HTTPException\nimport pytest\nfrom unittest.mock import patch\n\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom main import app\n\n\n@pytest.fixture\ndef mock_user_detail():\n    with patch(\"api.v1.services.user.user_service.get_user_detail\") as user_detail:\n        user_detail.return_value = {\n            \"id\": \"12345\",\n            \"username\": \"test\",\n            \"email\": \"test@test.com\",\n        }\n\n        yield user_detail\n\n\n@pytest.fixture\ndef mock_user_update():\n    with patch(\n        \"api.v1.services.user.user_service.update_user_profile\"\n    ) as update_user_profile:\n        update_user_profile.return_value = {\n            \"id\": \"12345\",\n            \"username\": \"test\",\n            \"email\": \"test@test.com\",\n        }\n\n        yield update_user_profile\n\n\n@pytest.fixture\ndef mock_user_update_effect():\n    with patch(\n        \"api.v1.services.user.user_service.get_user_detail\"\n    ) as user_detail_effect:\n        user_detail_effect.side_effect = HTTPException(\n            403, \"You do not have permission to update this profile\"\n        )\n\n        yield user_detail_effect\n\n\n@pytest.fixture\ndef mock_delete_user():\n    with patch(\n        \"api.v1.services.user.user_service.delete_user_profile\"\n    ) as delete_user_profile:\n        yield delete_user_profile\n\n\n@pytest.fixture\ndef mock_delete_user_effect():\n    with patch(\n        \"api.v1.services.user.user_service.delete_user_profile\"\n    ) as delete_user_profile:\n        delete_user_profile.side_effect = HTTPException(\n            403, \"You do not have permission to delete this user\"\n        )\n\n        yield delete_user_profile\n\n\n@pytest.fixture\ndef mock_get_users():\n    with patch(\"api.v1.services.user.user_service.fetch_all\") as fetch_users:\n        fetch_users.return_value = [\n            {\"id\": 1, \"username\": \"codewitgabi\"},\n            {\"id\": 2, \"username\": \"test\"},\n            {\"id\": 3, \"username\": \"doe\"},\n        ]\n\n        yield fetch_users\n\n\n@pytest.fixture\ndef mock_follow_user():\n\n    with patch(\"api.v1.services.user.user_service.follow_user\") as follow_user:\n        yield follow_user\n\n\n@pytest.fixture\ndef mock_unfollow_user():\n    with patch(\"api.v1.services.user.user_service.unfollow_user\") as unfollow_user:\n        yield unfollow_user\n\n\n@pytest.fixture\ndef mock_followers():\n\n    with patch(\"api.v1.services.user.user_service.followers\") as followers:\n        followers.return_value = [\n            {\"id\": \"hhh\", \"username\": \"joshua\", \"profile_picture\": \"hhh\"},\n            {\"id\": \"jjj\", \"username\": \"joseph\", \"profile_picture\": \"jjj\"},\n        ]\n        yield followers\n\n\n@pytest.fixture\ndef mock_followings():\n    with patch(\"api.v1.services.user.user_service.followings\") as followings:\n\n        followings.return_value = [\n            {\"id\": \"hhh\", \"username\": \"joshua\", \"profile_picture\": \"hhh\"},\n            {\"id\": \"jjj\", \"username\": \"joseph\", \"profile_picture\": \"jjj\"},\n        ]\n        yield followings\n"}
{"type": "test_file", "path": "api/v1/tests/user/test_followers_followings.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"..    /../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom main import app\nfrom sqlalchemy.orm import Session\n\nclient = TestClient(app)\n\n\ndef test_followers(\n    mock_db_session: Session, access_token, current_user, mock_followers\n):\n\n    response = client.get(\n        \"/api/v1/users/hhh/followers\",\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n    )\n\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"Followers successfully returned\"\n    assert response.json()[\"data\"] == [\n        {\"id\": \"hhh\", \"username\": \"joshua\", \"profile_picture\": \"hhh\"},\n        {\"id\": \"jjj\", \"username\": \"joseph\", \"profile_picture\": \"jjj\"},\n    ]\n\n\ndef test_followings(\n    mock_db_session: Session, access_token, current_user, mock_followings\n):\n\n    response = client.get(\n        \"/api/v1/users/jjj/followings\",\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n    )\n\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"Followings list successfully returned\"\n    assert response.json()[\"data\"] == [\n        {\"id\": \"hhh\", \"username\": \"joshua\", \"profile_picture\": \"hhh\"},\n        {\"id\": \"jjj\", \"username\": \"joseph\", \"profile_picture\": \"jjj\"},\n    ]\n"}
{"type": "test_file", "path": "api/v1/tests/user/test_get_users.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/users\"\n\n\ndef test_get_user_detail(mock_db_session: Session, mock_user_detail, mock_get_users):\n    response = client.get(endpoint)\n\n    data = response.json()\n\n    assert response.status_code == 200\n    assert data[\"status_code\"] == 200\n    assert data[\"message\"] == \"User list fetched successfully\"\n    assert data[\"data\"] == [\n        {\"id\": 1, \"username\": \"codewitgabi\"},\n        {\"id\": 2, \"username\": \"test\"},\n        {\"id\": 3, \"username\": \"doe\"},\n    ]\n"}
{"type": "test_file", "path": "api/v1/tests/user/test_update_user.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/users/12345\"\n\n\ndef test_update_user_profile(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_user_update,\n):\n    body = {\"bio\": \"Update my bio\", \"social_links\": [\"http://example.com\"]}\n\n    response = client.patch(\n        endpoint, headers={\"authorization\": f\"Bearer {access_token}\"}, json=body\n    )\n\n    data = response.json()\n\n    assert response.status_code == 200\n    assert data[\"status_code\"] == 200\n    assert data[\"message\"] == \"User profile updated successfully\"\n    assert data[\"data\"] == {\n        \"id\": \"12345\",\n        \"username\": \"test\",\n        \"email\": \"test@test.com\",\n    }\n\n\ndef test_update_user_side_effect(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_user_update_effect,\n):\n    body = {\"bio\": \"Update my bio\", \"social_links\": [\"http://example.com\"]}\n\n    response = client.patch(\n        endpoint, headers={\"authorization\": f\"Bearer {access_token}\"}, json=body\n    )\n\n    data = response.json()\n\n    assert response.status_code == 403\n    assert data[\"status_code\"] == 403\n    assert data[\"message\"] == \"You do not have permission to update this profile\"\n"}
{"type": "test_file", "path": "api/v1/tests/user/test_user_detail.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/users/12345\"\n\n\ndef test_get_user_detail(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_user_detail,\n):\n    response = client.get(endpoint, headers={\"authorization\": f\"Bearer {access_token}\"})\n\n    data = response.json()\n\n    assert response.status_code == 200\n    assert data[\"status_code\"] == 200\n    assert data[\"message\"] == \"User detail fetched successfully\"\n    assert data[\"data\"] == {\n        \"id\": \"12345\",\n        \"username\": \"test\",\n        \"email\": \"test@test.com\",\n    }\n"}
{"type": "test_file", "path": "api/v1/tests/post_comment/test_delete_comment.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom main import app\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nimport pytest\n\nclient = TestClient(app)\n\nendpoint = \"api/v1/posts/ac3d6659-8f67-4a67-b690-9f77fab7e6e3/comments/ac3d6659-8f67-4a67-b690-9f77fab7e6e3\"\n\n\ndef test_delete_comment(\n    mock_db_session: Session, access_token, current_user, mock_create_comment\n):\n\n    response = client.delete(\n        endpoint, headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n\n    assert response.status_code == 204\n    assert response.json()[\"status_code\"] == 204\n    assert response.json()[\"message\"] == \"Comment deleted successfully\"\n\n\ndef test_delete_comment_comment_not_found_side_effect(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_delete_comment_comment_not_found_side_effect,\n):\n\n    response = client.delete(\n        endpoint, headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n\n    assert response.status_code == 404\n    assert response.json()[\"status_code\"] == 404\n    assert response.json()[\"message\"] == \"comment not found\"\n"}
{"type": "test_file", "path": "api/v1/tests/conftest.py", "content": "import os\nimport sys\n\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../\"))\n)\n\nfrom fastapi import HTTPException, status\nimport pytest\nfrom uuid import uuid4\nfrom main import app\nfrom unittest.mock import patch, MagicMock\nfrom api.v1.utils.dependencies import get_db\nfrom api.v1.services.user import user_service\nfrom api.v1.models.user import User\n\nmock_id = str(uuid4())\n\n\n@pytest.fixture\ndef mock_db_session():\n    with patch(\"api.v1.utils.dependencies.get_db\", autospec=True):\n        mock_db = MagicMock()\n        app.dependency_overrides[get_db] = lambda: mock_db\n        yield mock_db\n    app.dependency_overrides = {}\n\n\n@pytest.fixture\ndef mock_user_service():\n    with patch(\"api.v1.services.user.user_service\", autospec=True) as mock_service:\n        yield mock_service\n\n\n@pytest.fixture\ndef override_create():\n    with patch(\n        \"api.v1.services.user.UserService.create_user\", autospec=True\n    ) as mock_create:\n        user = {\n            \"username\": \"testUser\",\n            \"email\": \"testEmail@mail.com\",\n            \"password\": \"12345\",\n        }\n\n        mock_create.return_value = user\n        yield mock_create\n\n\n@pytest.fixture\ndef mock_user_exists():\n    with patch(\"api.v1.services.user.UserService.create_user\") as mock_create:\n        mock_create.side_effect = HTTPException(\n            status.HTTP_400_BAD_REQUEST, \"User with email already exists\"\n        )\n\n        yield mock_create\n\n\n@pytest.fixture\ndef override_handle_login():\n    with patch(\"api.v1.services.user.UserService.handle_login\") as handle_login:\n        response = {\n            \"access_token\": \"'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.KkiNWdzcAgD_0PF169pvBausbptBe1mSQcTorMEqciA\",\n            \"user\": {\n                \"id\": \"341df7fe-3d16-4c43-a0eb-5f7e2940d012\",\n                \"username\": \"test\",\n                \"email\": \"test@example.com\",\n                \"role\": \"user\",\n            },\n        }\n\n        handle_login.return_value = response\n        yield handle_login\n\n\n@pytest.fixture\ndef mock_invalid_account_effect():\n    with patch(\"api.v1.services.user.UserService.handle_login\") as handle_login:\n        handle_login.side_effect = HTTPException(\n            400, detail=\"No account associated with provided email\"\n        )\n\n        yield handle_login\n\n\n@pytest.fixture\ndef mock_incorrect_password():\n    with patch(\n        \"api.v1.services.user.UserService.verify_password\"\n    ) as incorrect_password:\n        incorrect_password.side_effect = HTTPException(400, \"Incorrect password\")\n\n        yield incorrect_password\n\n\ndef override_deps():\n    return User(\n        id=\"5d35b5b3-4eb7-4ad4-8082-b9af0de42c44\",\n        username=\"test-user\",\n        email=\"test-user@example.com\",\n        role=\"user\",\n    )\n\n\n@pytest.fixture\ndef test_user():\n    return User(\n        id=\"12345\",\n        email=\"test@example.com\",\n        password=user_service.hash_password(\"@Password123\"),\n    )\n\n\n@pytest.fixture\ndef access_token(test_user, mock_db_session):\n    return user_service.generate_access_token(mock_db_session, test_user)\n\n\n@pytest.fixture\ndef current_user(test_user):\n    app.dependency_overrides[user_service.get_current_user] = lambda: test_user\n"}
{"type": "test_file", "path": "api/v1/tests/auth/test_user_registration_endpoint.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\nfrom uuid import uuid4\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom api.v1.services.user import UserService\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/auth/register\"\nmock_id = str(uuid4())\n\n\ndef test_register_user_success(\n    mock_db_session: Session, mock_user_service: UserService, override_create: None\n):\n    data = {\n        \"username\": \"testUser\",\n        \"email\": \"testEmail@gmail.com\",\n        \"password\": \"12345\",\n    }\n\n    response = client.post(\"/api/v1/auth/register\", json=data)\n\n    assert response.status_code == 201\n    assert response.json() == {\n        \"status_code\": 201,\n        \"message\": \"User created successfully\",\n        \"data\": {\n            \"username\": \"testUser\",\n            \"email\": \"testEmail@mail.com\",\n            \"password\": \"12345\",\n        },\n    }\n\n\ndef test_register_validation_error(\n    mock_db_session: Session, mock_user_service: UserService, override_create: None\n):\n    data = {\"username\": \"testUser\", \"email\": \"testEmail@gmail.com\"}\n\n    response = client.post(\"/api/v1/auth/register\", json=data)\n\n    assert response.status_code == 422\n    assert response.json() == {\n        \"status_code\": 422,\n        \"message\": \"Validation error\",\n        \"errors\": [{\"field\": \"password\", \"message\": \"Field required\"}],\n    }\n\n\ndef test_user_already_exist(\n    mock_db_session: Session,\n    mock_user_service: UserService,\n    override_create: None,\n    mock_user_exists,\n):\n    data = {\n        \"username\": \"testUser\",\n        \"email\": \"testEmail@gmail.com\",\n        \"password\": \"12345\",\n    }\n\n    response = client.post(\"/api/v1/auth/register\", json=data)\n\n    assert response.status_code == 400\n    assert response.json() == {\n        \"status_code\": 400,\n        \"message\": \"User with email already exists\",\n    }\n"}
{"type": "test_file", "path": "api/v1/tests/user/test_follow_user.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"..    /../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"/api/v1/users/jjj/follow\"\n\n\ndef test_follow_user(\n    mock_db_session: Session,\n    current_user,\n    access_token,\n    mock_follow_user,\n):\n\n    response = client.patch(\n        endpoint, headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"User followed successfully\"\n\n\ndef test_unfollow_user(\n    mock_db_session: Session, current_user, access_token, mock_unfollow_user\n):\n\n    response = client.delete(\n        \"/api/v1/users/jjj/unfollow\",\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n    )\n\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"User unfollowed successfully\"\n"}
{"type": "test_file", "path": "api/v1/tests/test_root.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../\"))\n)\n\nfrom fastapi.testclient import TestClient\nfrom main import app\n\nclient = TestClient(app)\n\n\ndef test_server_root():\n    response = client.get(\"/\")\n\n    assert response.status_code == 200\n    assert response.json() == {\n        \"status_code\": 200,\n        \"message\": \"Welcome to fastapi-social-media-api\",\n    }\n\n\ndef test_404_not_found_error():\n    response = client.get(\"/zzz\")\n\n    assert response.status_code == 404\n    assert response.json() == {\"status_code\": 404, \"message\": \"Not Found\"}\n\n\ndef test_other_error_response():\n    response = client.post(\"/\")\n\n    assert response.status_code == 405\n    assert response.json() == {\"status_code\": 405, \"message\": \"Method Not Allowed\"}\n"}
{"type": "test_file", "path": "api/v1/tests/post_comment/test_create_comment.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\n\nimport pytest\nfrom main import app\nfrom sqlalchemy.orm import Session\nfrom fastapi.testclient import TestClient\n\nclient = TestClient(app)\n\nendpoint = \"api/v1/posts/ac3d6659-8f67-4a67-b690-9f77fab7e6e3/comments\"\n\n\ndef test_create_comment_success(\n    mock_db_session: Session, access_token, current_user, mock_create_comment\n):\n\n    response = client.post(\n        endpoint,\n        headers={\"authorization\": f\"Bearer {access_token}\"},\n        json={\"comment\": \"Test comment\"},\n    )\n\n    assert response.status_code == 201\n    assert response.json()[\"status_code\"] == 201\n    assert response.json()[\"data\"] == {\n        \"id\": \"02bb30ec-c793-463f-a2ea-d83edd157738\",\n        \"comment\": \"This is a very nice post\",\n        \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n        \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n        \"post_id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n        \"user\": {\n            \"id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n            \"username\": \"izzyjosh\",\n            \"profile_picture\": {\n                \"id\": \"02bb30ec-c793-463f-a2ea-d83edd159938\",\n                \"image\": \"user/profile_picture.img\",\n            },\n        },\n    }\n\n\ndef test_create_comment_invalid_content(\n    mock_db_session: Session, access_token, current_user\n):\n\n    response = client.post(\n        endpoint, headers={\"authorization\": f\"Bearer {access_token}\"}, json={}\n    )\n\n    assert response.status_code == 400\n    assert response.json()[\"status_code\"] == 400\n    assert response.json()[\"message\"] == \"The comment cannot be an empty field\"\n\n\ndef test_create_comment_unautthenticated_user(mock_db_session: Session):\n\n    response = client.post(endpoint, json={})\n\n    assert response.status_code == 401\n\n\ndef test_create_comment_post_not_found(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_create_comment_post_not_found_side_effect,\n):\n\n    response = client.post(\n        endpoint,\n        headers={\"authorization\": f\"Bearer {access_token}\"},\n        json={\"comment\": \"Test comment\"},\n    )\n\n    data = response.json()\n\n    assert response.status_code == 404\n    assert data[\"status_code\"] == 404\n    assert data[\"message\"] == \"Post not found\"\n"}
{"type": "test_file", "path": "api/v1/tests/post_comment/test_update_comment.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\n\nimport pytest\nfrom main import app\nfrom sqlalchemy.orm import Session\nfrom fastapi.testclient import TestClient\n\nclient = TestClient(app)\n\nendpoint = \"api/v1/posts/ac3d6659-8f67-4a67-b690-9f77fab7e6e3/comments/dd0030f4-2370-4bdf-8d20-00b52f167fb3\"\n\n\ndef test_update_comment_success(\n    mock_db_session: Session, access_token, current_user, mock_update_comment\n):\n\n    response = client.patch(\n        endpoint,\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n        json={\"comment\": \"Test update comment\"},\n    )\n\n    assert response.status_code == 200\n    assert response.json()[\"status_code\"] == 200\n    assert response.json()[\"message\"] == \"Comment updated successfully\"\n    assert response.json()[\"data\"] == {\n        \"id\": \"02bb30ec-c793-463f-a2ea-d83edd157738\",\n        \"comment\": \"This is a very nice post\",\n        \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n        \"updated_at\": \"2024-08-23T11:59:25.816336+01:00\",\n        \"post_id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n        \"user\": {\n            \"id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n            \"username\": \"izzyjosh\",\n            \"profile_picture\": {\n                \"id\": \"02bb30ec-c793-463f-a2ea-d83edd159938\",\n                \"image\": \"user/profile_picture.img\",\n            },\n        },\n    }\n\n\ndef test_update_comment_post_not_found(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_update_comment_post_not_found_side_effect,\n):\n\n    response = client.patch(\n        endpoint,\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n        json={\"comment\": \"Test update comment\"},\n    )\n\n    data = response.json()\n    assert response.status_code == 404\n    assert data[\"status_code\"] == 404\n    assert data[\"message\"] == \"Post not found\"\n\n\ndef test_update_comment_no_content(\n    mock_db_session: Session,\n    access_token,\n    current_user,\n    mock_update_comment_no_content_side_effect,\n):\n\n    response = client.patch(\n        endpoint, headers={\"Authorization\": f\"Bearer {access_token}\"}, json={}\n    )\n\n    assert response.status_code == 400\n    assert response.json()[\"status_code\"] == 400\n    assert response.json()[\"message\"] == \"Please provide comment content\"\n\n\ndef test_unauthenticated_user(mock_db_session: Session):\n\n    response = client.patch(endpoint, json={})\n\n    assert response.status_code == 401\n"}
{"type": "test_file", "path": "api/v1/tests/post/test_get_feeds.py", "content": "import os\nimport sys\n\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\")))\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nfrom main import app\n\nclient = TestClient(app)\nendpoint = \"api/v1/posts\"\n\n\ndef test_get_feeds(\n        mock_db_session: Session,\n        current_user,\n        access_token,\n        mock_get_feeds,):\n\n    response = client.get(endpoint, headers={\"Authorization\": f\"Bearer {access_token}\"})\n\n    assert response.status_code == 200\n    assert response.json()[\"message\"] == \"Feeds returned successfully\"\n    assert response.json()[\"data\"] == {\n            \"id\": \"jjj\",\n            \"content\":\" this is a test post\",\n            \"image\": \"null\",\n            \"video\": \"null\",\n            \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"post_owner\": {\n                \"id\": \"kkk\",\n                \"profile_picture\": \"null\",\n                \"username\": \"izzyjosh\",\n                },\n            \"original_post\": \"null\"\n            }\n\n\ndef test_web_socket():\n    \n    with client.websocket_connect(\"/api/v1/posts/ws\") as websocket:\n\n        response = websocket.receive_text()\n        assert response == \"connected\"\n"}
{"type": "test_file", "path": "api/v1/tests/post_comment/test_get_comments.py", "content": "import os\nimport sys\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../../\"))\n)\n\n\nimport pytest\nfrom main import app\nfrom sqlalchemy.orm import Session\nfrom fastapi.testclient import TestClient\n\n\nclient = TestClient(app)\n\nendpoint = \"api/v1/posts/ac3d6659-8f67-4a67-b690-9f77fab7e6e3/comments\"\n\n\ndef test_get_comments_success(\n    mock_db_session: Session, current_user, access_token, mock_get_comments\n):\n\n    response = client.get(endpoint, headers={\"Authorization\": f\"Bearer {access_token}\"})\n\n    assert response.status_code == 200\n    assert response.json()[\"status_code\"] == 200\n    assert response.json()[\"message\"] == \"Comments successfully returned\"\n    assert response.json()[\"data\"] == [\n        {\n            \"id\": \"02bb30ec-c793-463f-a2ea-d83edd157738\",\n            \"comment\": \"This is a very nice post\",\n            \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"updated_at\": \"2024-08-23T11:59:25.816336+01:00\",\n            \"post_id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n            \"user\": {\n                \"id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n                \"username\": \"izzyjosh\",\n                \"profile_picture\": {\n                    \"id\": \"02bb30ec-c793-463f-a2ea-d83edd159938\",\n                    \"image\": \"user/profile_picture.img\",\n                },\n            },\n        },\n        {\n            \"id\": \"02bb30ec-c793-463f-a2ea-d83edd157738\",\n            \"comment\": \"This is a very nice post\",\n            \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"updated_at\": \"2024-08-23T11:59:25.816336+01:00\",\n            \"post_id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n            \"user\": {\n                \"id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n                \"username\": \"izzyjosh\",\n                \"profile_picture\": {\n                    \"id\": \"02bb30ec-c793-463f-a2ea-d83edd159938\",\n                    \"image\": \"user/profile_picture.img\",\n                },\n            },\n        },\n    ]\n"}
{"type": "test_file", "path": "api/v1/tests/post/conftest.py", "content": "import os\nimport sys\n\n\nsys.path.insert(\n    0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../../\"))\n)\n\nfrom fastapi import HTTPException\nimport pytest\nfrom uuid import uuid4\nfrom unittest.mock import patch\n\nmock_id = str(uuid4())\n\n\n@pytest.fixture\ndef mock_create_post():\n    with patch(\"api.v1.services.post.post_service.create\") as create_post:\n        create_post.return_value = {\n            \"user_id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n            \"video\": None,\n            \"id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n            \"image\": None,\n            \"content\": \"Lorem ipsum dolor sit amet.\",\n            \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n        }\n\n        yield create_post\n\n\n@pytest.fixture\ndef mock_delete_post_side_effect():\n    with patch(\"api.v1.services.post.post_service.delete\") as create_post_side_effect:\n        create_post_side_effect.side_effect = HTTPException(404, \"Post not found\")\n\n        yield create_post_side_effect\n\n\n@pytest.fixture\ndef mock_update_post():\n    with patch(\"api.v1.services.post.post_service.update\") as update_post:\n        update_post.return_value = {\n            \"user_id\": \"02bb30ec-c793-463f-a2ea-d83edd156628\",\n            \"video\": None,\n            \"id\": \"ac3d6659-8f67-4a67-b690-9f77fab7e6e3\",\n            \"image\": None,\n            \"content\": \"Update post content\",\n        }\n\n        yield update_post\n\n\n@pytest.fixture\ndef mock_update_post_no_body_side_effect():\n    with patch(\"api.v1.services.post.post_service.update\") as update_post_side_effect:\n        update_post_side_effect.side_effect = HTTPException(\n            400, \"Please provide one of content, image or video\"\n        )\n\n        yield update_post_side_effect\n\n\n@pytest.fixture\ndef mock_update_post_not_found_side_effect():\n    with patch(\"api.v1.services.post.post_service.update\") as update_post_side_effect:\n        update_post_side_effect.side_effect = HTTPException(404, \"Post not found\")\n\n        yield update_post_side_effect\n\n\n@pytest.fixture\ndef mock_like_post():\n    with patch(\"api.v1.services.post.post_service.like_post\") as like_post:\n        like_post.return_value = {\"message\": \"post liked successfully\"}\n        yield like_post\n\n\n@pytest.fixture\ndef mock_get_post_likes():\n    with patch(\"api.v1.services.post.post_service.get_likes\") as post_likes:\n        post_likes.return_value = {\n            \"user_id\": \"xxx\",\n            \"post_id\": \"yyy\",\n            \"liked\": \"True\",\n            \"user\": {\"id\": \"jjj\", \"image\": \"hhh\"},\n        }\n\n        yield post_likes\n\n\n@pytest.fixture\ndef mock_repost():\n    with patch(\"api.v1.services.post.post_service.repost\") as repost:\n\n        repost.return_value = {\n            \"user_id\": \"zzz\",\n            \"post_id\": \"hhh\",\n            \"content\": \"Test repost\",\n            \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n            \"repost_owner\": {\"id\": \"jjj\", \"image\": \"/picture\", \"username\": \"joshua\"},\n            \"original_post\": {\n                \"id\": \"kkk\",\n                \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n                \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n                \"content\": \"Tgis is the original post\",\n                \"video\": \"null\",\n                \"images\": \"null\",\n                \"original_post_owner\": {\n                    \"id\": \"iii\",\n                    \"image\": \"/picture\",\n                    \"username\": \"joseph\",\n                },\n            },\n        }\n\n        yield repost\n\n\n@pytest.fixture\ndef mock_get_feeds():\n    with patch(\"api.v1.services.post.post_service.get_feeds\") as get_feeds:\n\n        get_feeds.return_value = {\n                \"id\": \"jjj\",\n                \"content\":\" this is a test post\",\n                \"image\": \"null\",\n                \"video\": \"null\",\n                \"created_at\": \"2024-08-22T23:59:25.816336+01:00\",\n                \"updated_at\": \"2024-08-22T23:59:25.816336+01:00\",\n                \"post_owner\": {\n                    \"id\": \"kkk\",\n                    \"profile_picture\": \"null\",\n                    \"username\": \"izzyjosh\",\n                    },\n                \"original_post\": \"null\"\n                }\n        yield get_feeds\n"}
{"type": "source_file", "path": "__init__.py", "content": ""}
{"type": "source_file", "path": "api/__init__.py", "content": ""}
{"type": "source_file", "path": "alembic/env.py", "content": "from logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nimport os\nfrom dotenv import load_dotenv\nfrom alembic import context\nfrom api.v1.utils.database import Base\nfrom api.v1.models import *\n\nload_dotenv()\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\nconfig.set_main_option(\"sqlalchemy.url\", os.environ.get(\"DATABASE_URL\"))\ntarget_metadata = Base.metadata\n\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "api/v1/models/hashtag.py", "content": "from sqlalchemy.orm import mapped_column, Mapped\nfrom sqlalchemy import Integer, String\n\nfrom api.v1.models.abstract_base import AbstractBaseModel\n\n\nclass Hashtag(AbstractBaseModel):\n    __tablename__ = \"hashtag\"\n\n    tag: Mapped[str] = mapped_column(String(55), nullable=False, unique=True)\n    usage: Mapped[int] = mapped_column(Integer, default=1)\n\n    def __str__(self):\n        return self.tag\n"}
{"type": "source_file", "path": "api/v1/responses/__init__.py", "content": ""}
{"type": "source_file", "path": "api/v1/models/post.py", "content": "from datetime import datetime\nfrom typing import Optional\nfrom sqlalchemy.orm import mapped_column, Mapped, relationship\nfrom sqlalchemy import DateTime, ForeignKey, String, func\nfrom api.v1.models.abstract_base import AbstractBaseModel\nfrom pydantic import UUID4\nfrom sqlalchemy.orm import remote\nfrom uuid import uuid4\n\n\nclass Post(AbstractBaseModel):\n    __tablename__ = \"post\"\n\n    post_id: Mapped[str] = mapped_column(unique=True, default=lambda: str(uuid4()))\n    user_id: Mapped[str] = mapped_column(ForeignKey(\"user.id\"))\n    user = relationship(\"User\", back_populates=\"posts\")\n    content: Mapped[Optional[str]] = mapped_column(String(1024), nullable=True)\n    image: Mapped[Optional[str]] = mapped_column(\n        String(1024), nullable=True\n    )  # image url\n    video: Mapped[Optional[str]] = mapped_column(\n        String(1024), nullable=True\n    )  # video url\n    comments = relationship(\"PostComment\", back_populates=\"post\")\n    original_post_id: Mapped[Optional[str]] = mapped_column(\n        ForeignKey(\"post.id\"), nullable=True\n    )\n    original_post = relationship(\n        \"Post\",\n        primaryjoin=lambda: Post.original_post_id == remote(Post.id),\n        backref=\"reposts\",\n    )\n    updated_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()\n    )\n\n    def __str__(self) -> str:\n        return self.content or self.image or self.video\n\n\nclass Like(AbstractBaseModel):\n    __tablename__ = \"like\"\n\n    user_id: Mapped[str] = mapped_column(ForeignKey(\"user.id\"))\n    user = relationship(\"User\", backref=\"my_likes\")\n    post_id: Mapped[str] = mapped_column(ForeignKey(\"post.id\"))\n    post = relationship(\"Post\", backref=\"likes\")\n    liked: Mapped[bool] = mapped_column(default=False)\n\n    def __repr__(self):\n        return self.user\n"}
{"type": "source_file", "path": "api/v1/models/notification.py", "content": "from enum import Enum\nfrom sqlalchemy import String, ForeignKey, Enum as SQLAlchemyEnum\nfrom sqlalchemy.orm import relationship, Mapped, mapped_column\nfrom api.v1.models.abstract_base import AbstractBaseModel\n\n\nclass NotificationStatus(Enum):\n    read = \"read\"\n    unread = \"unread\"\n\n\nclass Notification(AbstractBaseModel):\n    __tablename__ = \"notification\"\n\n    user_id: Mapped[str] = mapped_column(ForeignKey(\"user.id\"))\n    message: Mapped[str] = mapped_column(String(255))\n    status: Mapped[str] = mapped_column(\n        SQLAlchemyEnum(NotificationStatus), server_default=\"unread\"\n    )\n\n    user = relationship(\"User\", back_populates=\"notifications\")\n\n    def __str__(self):\n        return self.message\n"}
{"type": "source_file", "path": "api/v1/models/user.py", "content": "from typing import List, Optional\nfrom datetime import datetime\nfrom enum import Enum\nfrom sqlalchemy import (\n    Column,\n    DateTime,\n    ForeignKey,\n    String,\n    Table,\n    func,\n    Enum as SQLAlchemyEnum,\n)\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom api.v1.models.abstract_base import AbstractBaseModel\nfrom api.v1.utils.database import Base\n\n\n# role enum\n\n\nclass RoleEnum(Enum):\n    user = \"user\"\n    admin = \"admin\"\n\n\nfollowers_table = Table(\n    \"user_interaction\",\n    Base.metadata,\n    Column(\"follower_id\", String, ForeignKey(\"user.id\"), primary_key=True),\n    Column(\"followed_id\", String, ForeignKey(\"user.id\"), primary_key=True),\n)\n\n\nclass User(AbstractBaseModel):\n    __tablename__ = \"user\"\n\n    username: Mapped[str] = mapped_column(String(255), nullable=False)\n    email: Mapped[str] = mapped_column(String(255), nullable=False, unique=True)\n    password: Mapped[str] = mapped_column(String(1024), nullable=False)\n    bio: Mapped[Optional[str]] = mapped_column(String(1024))\n    contact_info: Mapped[Optional[str]] = mapped_column(String(15))\n    followings = relationship(\n        \"User\",\n        secondary=followers_table,\n        primaryjoin=lambda: User.id == followers_table.c.followed_id,\n        secondaryjoin=lambda: User.id == followers_table.c.follower_id,\n        backref=\"followers\",\n    )\n    role: Mapped[str] = mapped_column(SQLAlchemyEnum(RoleEnum), default=RoleEnum.user)\n    last_login: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))\n    updated_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()\n    )\n\n    # relationships\n    social_links = relationship(\n        \"SocialLink\", back_populates=\"user\", cascade=\"all, delete-orphan\"\n    )\n    cover_photos = relationship(\n        \"CoverPhoto\", back_populates=\"user\", cascade=\"all, delete-orphan\"\n    )\n    profile_pictures = relationship(\n        \"ProfilePicture\", back_populates=\"user\", cascade=\"all, delete-orphan\"\n    )\n    posts = relationship(\"Post\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    comments = relationship(\n        \"PostComment\", back_populates=\"user\", cascade=\"all, delete-orphan\"\n    )\n    access_tokens = relationship(\n        \"AccessToken\", back_populates=\"user\", cascade=\"all, delete-orphan\"\n    )\n    notifications = relationship(\n        \"Notification\", back_populates=\"user\", cascade=\"all, delete-orphan\"\n    )\n\n    def __str__(self) -> str:\n        return self.username\n"}
{"type": "source_file", "path": "api/v1/models/social_link.py", "content": "from sqlalchemy import ForeignKey, String\nfrom sqlalchemy.orm import mapped_column, Mapped, relationship\nfrom api.v1.models.abstract_base import AbstractBaseModel\n\n\nclass SocialLink(AbstractBaseModel):\n    __tablename__ = \"social_link\"\n\n    link: Mapped[str] = mapped_column(String, nullable=False)\n    user_id: Mapped[str] = mapped_column(ForeignKey(\"user.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"social_links\")\n\n    def __str__(self) -> str:\n        return self.link\n"}
{"type": "source_file", "path": "api/v1/responses/error_responses.py", "content": "from fastapi import status\nfrom pydantic import BaseModel\n\n\nclass ValidationErrorResponse(BaseModel):\n    status_code: int = status.HTTP_422_UNPROCESSABLE_ENTITY\n    message: str = \"Validation error\"\n    errors: list\n\n\nclass ErrorResponse(BaseModel):\n    status_code: int\n    message: str\n"}
{"type": "source_file", "path": "api/v1/routes/user.py", "content": "from typing import Annotated\nfrom fastapi import APIRouter, Depends, Query, status, BackgroundTasks\nfrom fastapi.encoders import jsonable_encoder\nfrom sqlalchemy.orm import Session\nfrom api.v1.models.user import User\nfrom api.v1.responses.success_response import success_response\nfrom api.v1.schemas.user import UserUpdateSchema\nfrom api.v1.services.user import user_service\nfrom api.v1.utils.dependencies import get_db\n\n\nusers = APIRouter(prefix=\"/users\", tags=[\"user\"])\n\n\n@users.patch(\"/{id}\", summary=\"Update user profile\")\nasync def update_user_profile(\n    id: str,\n    body: UserUpdateSchema,\n    user: User = Depends(user_service.get_current_user),\n    db: Session = Depends(get_db),\n):\n    data = user_service.update_user_profile(db=db, user=user, user_id=id, schema=body)\n\n    return success_response(message=\"User profile updated successfully\", data=data)\n\n\n@users.get(\"/{id}\", summary=\"Get user profile detail\")\nasync def get_user_profile(\n    id: str,\n    user: User = Depends(user_service.get_current_user),\n    db: Session = Depends(get_db),\n):\n    data = user_service.get_user_detail(db=db, user_id=id)\n\n    return success_response(\n        message=\"User detail fetched successfully\",\n        data=jsonable_encoder(data, exclude=[\"password\"]),\n    )\n\n\n@users.delete(\n    \"/{id}\",\n    summary=\"Delete user profile/account\",\n    status_code=status.HTTP_204_NO_CONTENT,\n)\nasync def delete_user_profile(\n    id: str,\n    user: User = Depends(user_service.get_current_user),\n    db: Session = Depends(get_db),\n):\n    user_service.delete_user_profile(db=db, user=user, user_id=id)\n\n    return success_response(status_code=204, message=\"User deleted successfully\")\n\n\n@users.get(\"\", summary=\"Get list of users\")\nasync def get_users(search: str = \"\", db: Session = Depends(get_db)):\n    users = user_service.fetch_all(db=db, search=search)\n\n    return success_response(\n        status_code=status.HTTP_200_OK,\n        message=\"User list fetched successfully\",\n        data=users,\n    )\n\n\n@users.patch(\"/{followee_id}/follow\", summary=\"Follow a particular user\")\nasync def follow(\n    followee_id: str,\n    background_task: BackgroundTasks = BackgroundTasks(),\n    user: User = Depends(user_service.get_current_user),\n    db: Session = Depends(get_db),\n):\n\n    user_service.follow_user(db=db, user=user, user_id=followee_id, background_task=background_task)\n\n    return success_response(\n        status_code=200,\n        message=\"User followed successfully\",\n    )\n\n\n@users.delete(\"/{followee_id}/unfollow\", summary=\"Unfollow the user with the id\")\nasync def unfollow(\n    followee_id: str,\n    background_task: BackgroundTasks = BackgroundTasks(),\n    user: User = Depends(user_service.get_current_user),\n    db: Session = Depends(get_db),\n):\n\n    user_service.unfollow_user(db=db, user_id=followee_id, user=user, background_task=background_task)\n\n    return success_response(\n        status_code=200,\n        message=\"User unfollowed successfully\",\n    )\n\n\n@users.get(\"/{user_id}/followers\", summary=\"List of folllowers\")\nasync def followers(\n    user_id: str,\n    user: User = Depends(user_service.get_current_user),\n    db: Session = Depends(get_db),\n):\n\n    followers = user_service.followers(db=db, user=user)\n\n    return success_response(\n        status_code=200, message=\"Followers successfully returned\", data=followers\n    )\n\n\n@users.get(\n    \"/{user_id}/followings\", summary=\"List of user the current user is following\"\n)\nasync def followings(\n    user_id: str,\n    user: User = Depends(user_service.get_current_user),\n    db: Session = Depends(get_db),\n):\n\n    followings = user_service.followings(db=db, user=user)\n\n    return success_response(\n        status_code=200,\n        message=\"Followings list successfully returned\",\n        data=followings,\n    )\n"}
{"type": "source_file", "path": "api/v1/routes/post.py", "content": "from fastapi import APIRouter, Depends, status, WebSocket, WebSocketDisconnect, BackgroundTasks\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\nfrom api.v1.models.user import User\nfrom api.v1.responses.success_response import success_response\nfrom api.v1.schemas.post import CreatePostSchema, UpdatePostSchema, RepostCreate, RepostResponse\nfrom api.v1.utils.dependencies import get_db\nfrom api.v1.utils.websocket import manager\nfrom api.v1.services.user import user_service\nfrom api.v1.services.post import post_service\n\n\n\nposts = APIRouter(prefix=\"/posts\", tags=[\"post\"])\n\n\n@posts.get(\"\", response_model=List[RepostResponse])\nasync def get_feeds(\n        db: Session = Depends(get_db),\n        user: User = Depends(user_service.get_current_user),):\n\n    feeds = post_service.get_feeds(db=db, user=user)\n\n    return success_response(\n            status_code=status.HTTP_200_OK,\n            message=\"Feeds returned successfully\",\n            data=feeds)\n\n\n@posts.post(\"\")\nasync def create_post(\n    post: CreatePostSchema,\n    db: Session = Depends(get_db),\n    user: User = Depends(user_service.get_current_user),\n):\n    new_post = post_service.create(db=db, user=user, schema=post)\n\n    manager.broadcast(new_post)\n\n    return success_response(\n        status_code=status.HTTP_201_CREATED,\n        message=\"Post created successfully\",\n        data=new_post,\n    )\n\n\n@posts.delete(\n    \"/{id}\",\n    summary=\"Delete a post\",\n    status_code=status.HTTP_204_NO_CONTENT,\n)\nasync def delete_post(\n    id: str,\n    db: Session = Depends(get_db),\n    user: User = Depends(user_service.get_current_user),\n):\n    post_service.delete(db=db, user=user, post_id=id)\n\n    return success_response(\n        status_code=status.HTTP_204_NO_CONTENT, message=\"Post deleted successfully\"\n    )\n\n\n@posts.patch(\"/{id}\", summary=\"Update a post\", status_code=status.HTTP_200_OK)\nasync def update_post(\n    id: str,\n    schema: UpdatePostSchema,\n    db: Session = Depends(get_db),\n    user: User = Depends(user_service.get_current_user),\n):\n    updated_post = post_service.update(db=db, user=user, post_id=id, schema=schema)\n\n    manager.broadcast(updated_post)\n\n    return success_response(\n        status_code=status.HTTP_200_OK,\n        message=\"Post updated successfully\",\n        data=updated_post,\n    )\n\n\n@posts.websocket(\"/ws\")\nasync def websocket_post_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n\n    try:\n        while True:\n            await websocket.send_text(\"connected\")\n            await websocket.receive_text()\n\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n\n\n@posts.patch(\"/{id}/like\", status_code=status.HTTP_200_OK)\nasync def like_post(\n    id: str,\n    background_task: BackgroundTasks = BackgroundTasks(),\n    db: Session = Depends(get_db),\n    user: User = Depends(user_service.get_current_user),\n):\n\n    liked_post = post_service.like_post(db=db, user=user, post_id=id, background_task=background_task)\n\n    return success_response(\n        status_code=status.HTTP_200_OK,\n        message=\"Post liked successfully\",\n    )\n\n  \n@posts.get(\"/{id}/like\", status_code=status.HTTP_200_OK)\nasync def get_likes(\n    id: str,\n    db: Session = Depends(get_db),\n    user: User = Depends(user_service.get_current_user),\n):\n\n    likes = post_service.get_likes(db=db, post_id=id, user=user)\n\n    return success_response(\n        status_code=status.HTTP_200_OK,\n        message=\"Likes returned successfully\",\n        data=likes,\n    )\n  \n  \n@posts.post(\"/{id}/repost\", status_code=status.HTTP_201_CREATED)\nasync def repost(\n    id: str,\n    schema: RepostCreate,\n    background_task: BackgroundTasks = BackgroundTasks(),\n    db: Session = Depends(get_db),\n    user: User = Depends(user_service.get_current_user),\n):\n\n    repost = post_service.repost(db=db, post_id=id, schema=schema, user=user, background_task=background_task)\n\n    manager.broadcast(repost)\n\n    return success_response(\n        status_code=status.HTTP_201_CREATED,\n        message=\"Reposted successfully\",\n        data=repost,\n    )\n"}
{"type": "source_file", "path": "api/v1/schemas/__init__.py", "content": ""}
{"type": "source_file", "path": "api/v1/models/profile_picture.py", "content": "from datetime import datetime\nfrom sqlalchemy.orm import mapped_column, Mapped, relationship\nfrom sqlalchemy import DateTime, ForeignKey, String, func\nfrom api.v1.models.abstract_base import AbstractBaseModel\nimport api\n\n\nclass ProfilePicture(AbstractBaseModel):\n    __tablename__ = \"profile_picture\"\n\n    user_id: Mapped[str] = mapped_column(ForeignKey(\"user.id\"), nullable=False)\n    image: Mapped[str] = mapped_column(String(1024), nullable=False)\n    user: Mapped[\"api.v1.models.user.User\"] = relationship(\n        back_populates=\"profile_pictures\"\n    )\n    updated_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()\n    )\n\n    def __str__(self) -> str:\n        return self.image\n"}
{"type": "source_file", "path": "api/v1/services/notification.py", "content": "from fastapi import BackgroundTasks\nfrom sqlalchemy.orm import Session\nfrom typing import Dict\nimport asyncio\nfrom api.v1.models.user import User\nfrom api.v1.models.notification import Notification\n\n\nclass NotificationService:\n    def __init__(self):\n\n        self.user_event_queues: Dict[str, asyncio.Queue] = {}\n\n    async def event_generator(self, user_id: str):\n        if user_id not in self.user_event_queues:\n            self.user_event_queues[user_id] = asyncio.Queue()\n\n        while True:\n            event = await self.user_event_queues[user_id].get()\n            yield f\"data: {event}\"\n\n    def notifications(self, user: User, db: Session):\n        notifications = (\n            db.query(Notification).filter(Notification.user_id == user.id).all()\n        )\n\n        return notifications\n\n\nnotification_service = NotificationService()\n"}
{"type": "source_file", "path": "api/v1/models/access_token.py", "content": "from datetime import datetime\nfrom sqlalchemy import Boolean, DateTime, String, ForeignKey\nfrom sqlalchemy.orm import relationship, mapped_column, Mapped\nfrom api.v1.models.abstract_base import AbstractBaseModel\n\n\nclass AccessToken(AbstractBaseModel):\n    __tablename__ = \"access_token\"\n\n    user_id: Mapped[str] = mapped_column(ForeignKey(\"user.id\"))\n    user = relationship(\"User\", back_populates=\"access_tokens\")\n    token: Mapped[str] = mapped_column(String(500), nullable=False)\n    expiry_time: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), nullable=False\n    )\n    blacklisted: Mapped[bool] = mapped_column(\n        Boolean(), server_default=\"false\", default=False\n    )\n\n    def __str__(self) -> str:\n        return self.token\n"}
{"type": "source_file", "path": "api/v1/routes/__init__.py", "content": "from fastapi import APIRouter\nfrom api.v1.routes.auth import auth\nfrom api.v1.routes.user import users\nfrom api.v1.routes.post import posts\nfrom api.v1.routes.post_comment import comments\nfrom api.v1.routes.notification import notifications\n\n# version 1 routes\n\nversion_one = APIRouter(prefix=\"/api/v1\")\n\nversion_one.include_router(auth)\nversion_one.include_router(users)\nversion_one.include_router(posts)\nversion_one.include_router(comments)\nversion_one.include_router(notifications)\n"}
{"type": "source_file", "path": "api/v1/models/cover_photo.py", "content": "from datetime import datetime\nfrom sqlalchemy.orm import mapped_column, Mapped, relationship\nfrom sqlalchemy import DateTime, ForeignKey, String, func\nfrom api.v1.models.abstract_base import AbstractBaseModel\nimport api\n\n\nclass CoverPhoto(AbstractBaseModel):\n    __tablename__ = \"cover_photo\"\n\n    user_id: Mapped[str] = mapped_column(ForeignKey(\"user.id\"), nullable=False)\n    image: Mapped[str] = mapped_column(String(1024), nullable=False)\n    user = relationship(\"User\", back_populates=\"cover_photos\")\n    updated_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()\n    )\n\n    def __str__(self) -> str:\n        return self.image\n"}
{"type": "source_file", "path": "api/v1/schemas/profile_picture.py", "content": "from pydantic import BaseModel, ConfigDict\nfrom datetime import datetime\n\n\nclass ProfilePictureResponse(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: str\n    image: str\n    created_at: datetime\n    updated_at: datetime\n"}
{"type": "source_file", "path": "api/v1/routes/auth.py", "content": "from fastapi import APIRouter, Depends, status\nfrom api.v1.responses.success_response import success_response\nfrom api.v1.schemas.user import UserCreate, UserLogin\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom sqlalchemy.orm import Session\n\nfrom api.v1.utils.dependencies import get_db\n\n\nauth = APIRouter(prefix=\"/auth\", tags=[\"auth\"])\n\n\n@auth.post(\n    \"/register\",\n    status_code=status.HTTP_201_CREATED,\n)\nasync def register(user: UserCreate, db: Session = Depends(get_db)):\n    data = user_service.create_user(user, db)\n\n    return success_response(\n        status_code=status.HTTP_201_CREATED,\n        message=\"User created successfully\",\n        data=data,\n    )\n\n\n@auth.post(\"/login\", status_code=status.HTTP_200_OK)\nasync def login(data: UserLogin, db: Session = Depends(get_db)):\n    data = user_service.handle_login(db, email=data.email, password=data.password)\n\n    return success_response(\n        status_code=status.HTTP_200_OK,\n        message=\"User login successful\",\n        data=data,\n    )\n\n\n@auth.post(\"/logout\")\nasync def logout(\n    current_user: User = Depends(user_service.get_current_user),\n    db: Session = Depends(get_db),\n):\n    user_service.blacklist_token(db, current_user)\n    return success_response(message=\"User logged out successfully\")\n"}
{"type": "source_file", "path": "api/v1/services/__init__.py", "content": ""}
{"type": "source_file", "path": "api/v1/responses/success_response.py", "content": "from typing import Optional\nfrom fastapi import status\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\n\n\ndef success_response(\n    message: str, status_code: int = status.HTTP_200_OK, data: Optional[dict] = None\n):\n    \"\"\"\n    :param message: description of the response\n    :param status_code: HTTP status code\n    :param data: optional dictionary data\n\n    :description: Renders a json response for uniformity accross all api endpoints.\n    \"\"\"\n\n    response: dict = {\n        \"status_code\": status_code,\n        \"message\": message,\n    }\n\n    if data is not None:\n        response[\"data\"] = data\n\n    return JSONResponse(status_code=status_code, content=jsonable_encoder(response))\n"}
{"type": "source_file", "path": "api/v1/routes/notification.py", "content": "from fastapi import APIRouter, Depends\nfrom fastapi.responses import StreamingResponse\nfrom sqlalchemy.orm import Session\nfrom api.v1.models.user import User\nfrom api.v1.services.user import user_service\nfrom api.v1.services.notification import notification_service\nfrom api.v1.utils.dependencies import get_db\nfrom api.v1.responses.success_response import success_response\nfrom typing import List\n\nnotifications = APIRouter(prefix=\"/notifications\", tags=[\"notification\"])\n\n\n@notifications.get(\"/sse\")\nasync def sse_endpoint(user: User = Depends(user_service.get_current_user)):\n    return StreamingResponse(\n        notification_service.event_generator(user.id), media_type=\"text/event_stream\"\n    )\n\n\n@notifications.get(\"\")\nasync def user_notifications(\n    user: User = Depends(user_service.get_current_user), db: Session = Depends(get_db)\n):\n\n    notifications: List = notification_service.notifications(user=user, db=db)\n\n    return success_response(\n        status_code=200,\n        message=\"Notifications returned successfully\",\n        data=notifications,\n    )\n"}
{"type": "source_file", "path": "api/v1/schemas/post.py", "content": "from pydantic import BaseModel, ConfigDict, UUID4, Field\nfrom api.v1.schemas.user import UserResponse\nfrom datetime import datetime\nfrom typing import Optional\n\n\nclass CreatePostSchema(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    content: str | None = None\n    image: str | None = None\n    video: str | None = None\n\n\nclass UpdatePostSchema(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    content: str | None = None\n    image: str | None = None\n    video: str | None = None\n\n\nclass PostResponse(CreatePostSchema):\n\n    id: UUID4\n    user_id: UUID4 = Field(exclude=True)\n    created_at: datetime\n    updated_at: datetime\n    user: UserResponse | None = Field(default=None, serialization_alias=\"original_post_owner\")\n\n\nclass PostResponseSchema(PostResponse):\n    original_post: PostResponse | None = Field(default=None, serialization_alias=\"original_post\")\n\n\nclass LikeResponse(BaseModel):\n    model_config = ConfigDict(from_attribute=True)\n\n    id: str\n    post_id: str\n    user_id: str\n    liked: bool\n    user: UserResponse = None\n\n\nclass RepostCreate(BaseModel):\n\n    content: str | None = None\n\n\nclass RepostResponse(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: str\n    post_id: str = Field(exclude=True)\n    user_id: str = Field(exclude=True)\n    content: str | None = None\n    created_at: datetime\n    updated_at: datetime\n    user: UserResponse = Field(default=None, serialization_alias=\"post_owner\")\n    post: PostResponse = Field(default=None, serialization_alias=\"original_post\")\n"}
{"type": "source_file", "path": "api/v1/models/__init__.py", "content": "from api.v1.models.user import User\nfrom api.v1.models.cover_photo import CoverPhoto\nfrom api.v1.models.post import Post\nfrom api.v1.models.access_token import AccessToken\nfrom api.v1.models.post_comment import PostComment\nfrom api.v1.models.profile_picture import ProfilePicture\nfrom api.v1.models.social_link import SocialLink\nfrom api.v1.models.notification import Notification\nfrom api.v1.models.hashtag import Hashtag\n"}
{"type": "source_file", "path": "api/v1/models/post_comment.py", "content": "from datetime import datetime\nfrom sqlalchemy import DateTime, ForeignKey, Text, func\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom api.v1.models.abstract_base import AbstractBaseModel\n\n\nclass PostComment(AbstractBaseModel):\n    __tablename__ = \"post_comment\"\n\n    user_id: Mapped[str] = mapped_column(ForeignKey(\"user.id\"))\n    user = relationship(\"User\", back_populates=\"comments\")\n    post_id: Mapped[str] = mapped_column(ForeignKey(\"post.id\"))\n    post = relationship(\"Post\", back_populates=\"comments\")\n    comment: Mapped[str] = mapped_column(Text, nullable=False)\n    updated_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()\n    )\n\n    def __str__(self) -> str:\n        return self.comment\n"}
{"type": "source_file", "path": "api/v1/models/abstract_base.py", "content": "from uuid import uuid4\nfrom datetime import datetime\nfrom sqlalchemy import DateTime, String, func\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom api.v1.utils.database import Base\n\n\nclass AbstractBaseModel(Base):\n    __abstract__ = True\n\n    id: Mapped[str] = mapped_column(\n        String, primary_key=True, index=True, default=lambda: str(uuid4())\n    )\n    created_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), server_default=func.now()\n    )\n"}
{"type": "source_file", "path": "api/v1/routes/post_comment.py", "content": "from fastapi import APIRouter, Depends, status, BackgroundTasks\nfrom sqlalchemy.orm import Session\nfrom api.v1.schemas.post_comment import CreateCommentSchema, CommentResponse\nfrom api.v1.schemas.user import UserResponse\nfrom api.v1.services.post_comment import comment_service\nfrom api.v1.utils.dependencies import get_db\nfrom api.v1.services.user import user_service\nfrom api.v1.services.post import post_service\nfrom api.v1.models.user import User\nfrom api.v1.models.post import Post\nfrom api.v1.responses.success_response import success_response\n\n\ncomments = APIRouter(prefix=\"/posts/{post_id}\", tags=[\"comment\"])\n\n\n@comments.get(\"/comments\")\nasync def get_comments(\n    post_id: str,\n    db: Session = Depends(get_db),\n    user: User = Depends(user_service.get_current_user),\n):\n\n    comments = comment_service.get_comments(db=db, post_id=post_id, user=user)\n\n    return success_response(\n        status_code=status.HTTP_200_OK,\n        message=\"Comments successfully returned\",\n        data=comments,\n    )\n\n\n@comments.post(\"/comments\")\nasync def create_comment(\n    post_id: str,\n    comment: CreateCommentSchema,\n    background_task: BackgroundTasks = BackgroundTasks(),\n    db: Session = Depends(get_db),\n    user: User = Depends(user_service.get_current_user),\n):\n\n    new_comment: CommentResponse = comment_service.create(\n        db=db, user=user, post_id=post_id, schema=comment, background_task=background_task\n    )\n\n    return success_response(\n        status_code=status.HTTP_201_CREATED,\n        message=\"Comment successfully created\",\n        data=new_comment,\n    )\n\n\n@comments.patch(\"/comments/{comment_id}\")\nasync def update_comment(\n    post_id: str,\n    comment_id: str,\n    comment: CreateCommentSchema,\n    db: Session = Depends(get_db),\n    user: User = Depends(user_service.get_current_user),\n):\n\n    updated_comment = comment_service.update(\n        db=db, user=user, post_id=post_id, comment_id=comment_id, schema=comment\n    )\n\n    return success_response(\n        status_code=status.HTTP_200_OK,\n        message=\"Comment updated successfully\",\n        data=updated_comment,\n    )\n\n\n@comments.delete(\"/comments/{comment_id}\")\nasync def delete_comment(\n    post_id: str,\n    comment_id: str,\n    user: User = Depends(user_service.get_current_user),\n    db: Session = Depends(get_db),\n):\n\n    comment_service.delete(db=db, user=user, post_id=post_id, comment_id=comment_id)\n\n    return success_response(\n        status_code=status.HTTP_204_NO_CONTENT, message=\"Comment deleted successfully\"\n    )\n"}
{"type": "source_file", "path": "api/v1/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "api/v1/services/user.py", "content": "from datetime import datetime, timedelta, timezone\nimport os\nfrom typing import Annotated\nfrom dotenv import load_dotenv\nfrom pydantic import ValidationError\nfrom fastapi.encoders import jsonable_encoder\n\nfrom api.v1.models.access_token import AccessToken\nfrom api.v1.models.cover_photo import CoverPhoto\nfrom api.v1.models.profile_picture import ProfilePicture\nfrom api.v1.models.social_link import SocialLink\nfrom api.v1.utils.dependencies import get_db\n\nload_dotenv()\nfrom fastapi import Depends, HTTPException, status, BackgroundTasks\nfrom fastapi.security import OAuth2PasswordBearer\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import or_, text\nfrom passlib.context import CryptContext\nimport jwt\nfrom api.v1.models.user import User\nfrom api.v1.schemas.user import UserCreate, UserUpdateSchema, UserResponse\nfrom api.v1.utils.storage import upload\nfrom api.v1.models.notification import Notification\nfrom api.v1.services.notification import notification_service\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/login\")\nhash_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\nSECRET_KEY = os.environ.get(\"SECRET_KEY\")\nALGORITHM = os.environ.get(\"ALGORITHM\", \"HS256\")\nACCESS_TOKEN_EXPIRE_MINUTES = int(os.environ.get(\"ACCESS_TOKEN_EXPIRE_MINUTES\"))\n\n\nclass UserService:\n    def create_user(self, user: UserCreate, db: Session):\n        # check if user already exists\n\n        if self.exists(user.email, db):\n            raise HTTPException(\n                status.HTTP_400_BAD_REQUEST, \"User with email already exists\"\n            )\n\n        hashed_password = self.hash_password(user.password)\n        user.password = hashed_password\n        user = User(**user.model_dump())\n\n        db.add(user)\n        db.commit()\n        db.refresh(user)\n\n        # create notification\n\n        notification = Notification(\n            user_id=user.id, message=\"Account created successfully\"\n        )\n\n        db.add(notification)\n        db.commit()\n\n        # generate access token\n\n        token, expiry = self.generate_access_token(db, user).values()\n\n        user = jsonable_encoder(\n            self.get_user_detail(db=db, user_id=user.id), exclude={\"password\"}\n        )\n\n        response = {\n            \"access_token\": token,\n            \"expiry\": expiry,\n            \"user\": user,\n        }\n\n        return response\n\n    def hash_password(self, password: str) -> str:\n        return hash_context.hash(password)\n\n    def verify_password(self, password: str, hashed_password) -> bool:\n        return hash_context.verify(password, hashed_password)\n\n    def exists(self, email: str, db: Session) -> bool:\n        user = db.query(User).filter(User.email == email).first()\n\n        if user:\n            return True\n\n        return False\n\n    def generate_access_token(self, db: Session, user: User) -> dict:\n        payload = {\n            \"id\": user.id,\n            \"username\": user.username,\n            \"email\": user.email,\n        }\n        expire = datetime.now(timezone.utc) + timedelta(\n            minutes=ACCESS_TOKEN_EXPIRE_MINUTES\n        )\n        payload.update({\"exp\": expire})\n        token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)\n\n        # store access toke to database\n\n        access_token = AccessToken(user_id=user.id, token=token, expiry_time=expire)\n\n        db.add(access_token)\n        db.commit()\n        db.refresh(access_token)\n\n        return {\"token\": token, \"expiry_time\": expire}\n\n    def get_user_by_email(self, email: str, db: Session) -> User | None:\n        if self.exists(email, db):\n            return db.query(User).filter(User.email == email).first()\n\n    def get_user_by_id(self, id: str, db: Session) -> User | None:\n        return db.query(User).filter(User.id == id).first() or None\n\n    def handle_login(self, db: Session, email: str, password: str):\n        user = self.get_user_by_email(email, db)\n\n        if not user:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"No account associated with provided email\",\n            )\n\n        # check if password is correct\n\n        if not self.verify_password(password, user.password):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST, detail=\"Incorrect password\"\n            )\n\n        # create access token\n\n        access_token, expiry = self.generate_access_token(db, user).values()\n\n        # update last login\n\n        user.last_login = datetime.now(timezone.utc)\n\n        db.commit()\n        db.refresh(user)\n\n        # create notification\n\n        notification = Notification(user_id=user.id, message=\"Account Login successful\")\n\n        db.add(notification)\n        db.commit()\n\n        user = jsonable_encoder(\n            self.get_user_detail(db=db, user_id=user.id), exclude={\"password\"}\n        )\n\n        response = {\n            \"access_token\": access_token,\n            \"expiry\": expiry,\n            \"user\": user,\n        }\n\n        return response\n\n    def get_current_user(\n        self,\n        token: Annotated[str, Depends(oauth2_scheme)],\n        db: Session = Depends(get_db),\n    ):\n        credential_exception = HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n        try:\n            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n\n            email: str = payload.get(\"email\")\n\n            if not email:\n                raise credential_exception\n\n        except jwt.InvalidTokenError:\n            raise credential_exception\n\n        # check if token is blacklisted\n\n        access_token = db.query(AccessToken).filter(AccessToken.token == token).first()\n\n        if access_token and access_token.blacklisted:\n            raise credential_exception\n\n        user = self.get_user_by_email(email, db)\n\n        if not user:\n            raise credential_exception\n\n        return user\n\n    def blacklist_token(self, db: Session, user: User) -> None:\n        # get user access token\n\n        access_token = (\n            db.query(AccessToken).filter(AccessToken.user_id == user.id).first()\n        )\n\n        access_token.blacklisted = True\n\n        db.commit()\n        db.refresh(access_token)\n\n        # create notification\n\n        notification = Notification(\n            user_id=user.id, message=\"Account logout successful\"\n        )\n\n        db.add(notification)\n        db.commit()\n\n    def get_user_detail(self, db: Session, user_id: str):\n        query = (\n            db.query(User)\n            .options(\n                joinedload(User.profile_pictures),\n                joinedload(User.cover_photos),\n                joinedload(User.followers),\n                joinedload(User.social_links),\n            )\n            .filter(User.id == user_id)\n            .first()\n        )\n\n        if not query:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found\"\n            )\n\n        return query\n\n    def update_user_profile(\n        self, db: Session, user: User, user_id: str, schema: UserUpdateSchema\n    ):\n        # verify that user is the one logged in\n\n        if user.id != user_id:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"You do not have permission to update this user\",\n            )\n\n        data = schema.model_dump(exclude_unset=True)\n\n        profile_picture = data.pop(\"profile_picture\", None)\n\n        if profile_picture:\n            # upload image to cloudinary\n\n            image_url = upload(profile_picture)\n\n            # create new profile picture\n\n            new_profile_picture = ProfilePicture(user_id=user.id, image=image_url)\n\n            db.add(new_profile_picture)\n            db.commit()\n            db.refresh(new_profile_picture)\n\n        cover_photo = data.pop(\"cover_photo\", None)\n\n        if cover_photo:\n            # upload image to cloudinary\n\n            image_url = upload(cover_photo)\n\n            # create new cover photo\n\n            new_cover_photo = CoverPhoto(user_id=user.id, image=image_url)\n\n            db.add(new_cover_photo)\n            db.commit()\n            db.refresh(new_cover_photo)\n\n        social_links = data.pop(\"social_links\", [])\n\n        if social_links:\n            # remove all associated social links\n\n            db.query(SocialLink).filter(SocialLink.user_id == user_id).delete()\n            db.flush()\n\n            # create new social links\n\n            for link in social_links:\n                social_link = SocialLink(link=link, user_id=user_id)\n\n                db.add(social_link)\n\n            db.commit()\n\n        for key, value in data.items():\n            setattr(user, key, value)\n\n        db.commit()\n        db.refresh(user)\n\n        # create notification\n\n        notification = Notification(\n            user_id=user.id, message=\"Account updated successfully\"\n        )\n\n        db.add(notification)\n        db.commit()\n\n        # return user detail\n\n        return jsonable_encoder(\n            self.get_user_detail(db=db, user_id=user_id), exclude={\"password\"}\n        )\n\n    def delete_user_profile(self, db: Session, user: User, user_id: str):\n        # check if user is the currently logged in user\n\n        if user.id != user_id:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"You do not have permission to delete this user\",\n            )\n\n        db.delete(user)\n        db.commit()\n\n    def fetch_all(self, db: Session, search: str = \"\"):\n        query = (\n            db.query(User)\n            .options(joinedload(User.profile_pictures), joinedload(User.social_links))\n            .order_by(text(\"RANDOM()\"))\n        )\n\n        if search:\n            query = query.filter(\n                or_(\n                    User.username.icontains(f\"%{search}%\"),\n                    User.email.icontains(f\"%{search}%\"),\n                )\n            )\n\n        users = query.all()\n\n        return jsonable_encoder(users, exclude={\"password\"})\n\n    def follow_user(self, db: Session, user_id: str, user: User, background_task: BackgroundTasks):\n\n        followee = db.query(User).filter(User.id == user_id).first()\n        if not followee:\n            raise HTTPException(\n                status_code=404,\n                detail=\"User not found\",\n            )\n\n        if followee not in user.followings:\n            user.followings.append(followee)\n\n            notification = Notification(\n                user_id=followee.id, message=f\"{user.username} followed you\"\n            )\n\n            db.add(notification)\n            db.commit()\n\n            background_task.add_task(notification_service.user_event_queues[notification.user_id].put, notification.message)\n\n    def unfollow_user(self, db: Session, user_id: str, user: User, background_task: BackgroundTasks):\n        user_to_unfollow = db.query(User).filter(User.id == user_id).first()\n\n        if not user_to_unfollow:\n            raise HTTPException(status_code=404, detail=\"User not found\")\n\n        if user_to_unfollow not in user.followings:\n            raise HTTPException(\n                status_code=404, detail=\"You are not following this user\"\n            )\n\n        user.followings.remove(user_to_unfollow)\n\n        notification = Notification(\n            user_id=user_to_unfollow.id, message=f\"{user.username} unfollowed you\"\n        )\n\n        db.add(notification)\n        db.commit()\n\n        background_task.add_task(notification_service.user_event_queues[notification.user_id].put, notification.message)\n\n\n    def followers(self, db: Session, user: User):\n\n        followers = [\n            UserResponse(**jsonable_encoder(follower)) for follower in user.followers\n        ]\n\n        return followers\n\n    def followings(self, db: Session, user: User):\n\n        followings = [\n            UserResponse(**jsonable_encoder(following)) for following in user.followings\n        ]\n\n        return followings\n\n\nuser_service = UserService()\n"}
{"type": "source_file", "path": "api/v1/schemas/user.py", "content": "from datetime import datetime\nfrom typing import List, Literal, Optional\nfrom pydantic import BaseModel, Field, EmailStr, ConfigDict, root_validator\nfrom api.v1.schemas.profile_picture import ProfilePictureResponse\n\n\nclass UserBase(BaseModel):\n    username: str = Field(max_length=255)\n    email: EmailStr\n    role: Literal[\"user\", \"admin\"] = \"user\"\n\n\nclass UserCreate(UserBase):\n    password: str\n\n\nclass UserCreateResponse(BaseModel):\n    id: str\n    username: str\n    email: EmailStr\n    access_token: str\n    expiry: datetime\n\n\nclass UserLogin(BaseModel):\n    email: EmailStr\n    password: str\n\n\n# Used for comment to provide extra details about user\nclass UserResponse(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: str\n    username: str\n    profile_pictures: List[ProfilePictureResponse] = Field(default=None, exclude=True)\n    current_profile_picture: Optional[ProfilePictureResponse] = Field(\n        default=None, serialization_alias=\"profile_picture\"\n    )\n\n    @root_validator(pre=True)\n    def set_current_profile_picture(cls, values):\n        profile_pictures = values.get(\"profile_pictures\", [])\n        if profile_pictures:\n            latest_profile_picture = max(\n                profile_pictures, key=lambda picture: picture[\"updated_at\"]\n            )\n            values[\"current_profile_picture\"] = latest_profile_picture\n        return values\n\n\nclass UserLoginSchema(BaseModel):\n    id: str\n    username: str\n    email: EmailStr\n    bio: str | None\n    contact_info: str | None\n    social_links: List[str] | None = None\n    role: str\n    last_login: datetime | None = None\n    created_at: datetime\n    updated_at: datetime\n\n\nclass UserUpdateSchema(BaseModel):\n    username: Optional[str] = None\n    email: Optional[EmailStr] = None\n    bio: Optional[str] = None\n    contact_info: Optional[str] = None\n    social_links: Optional[List[str]] = None\n    profile_picture: Optional[str] = None\n    cover_photo: Optional[str] = None\n\n\nclass LoginResponse(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    access_token: str\n    expiry: datetime\n    user: UserLoginSchema\n"}
{"type": "source_file", "path": "api/v1/schemas/post_comment.py", "content": "from pydantic import BaseModel, ConfigDict\nfrom datetime import datetime\nfrom api.v1.schemas.user import UserResponse\n\n\nclass CreateCommentSchema(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    comment: str | None = None\n\n\nclass CommentResponse(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: str\n    comment: str\n    created_at: datetime\n    updated_at: datetime\n    post_id: str\n    user: UserResponse\n\n\nclass UpdateCommentSchema(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    comment: str | None = None\n"}
{"type": "source_file", "path": "api/v1/services/post_comment.py", "content": "from fastapi import HTTPException, status, BackgroundTasks\nfrom fastapi.encoders import jsonable_encoder\nfrom sqlalchemy.orm import Session\nfrom api.v1.schemas.post_comment import (\n    CreateCommentSchema,\n    CommentResponse,\n    UpdateCommentSchema,\n)\nfrom api.v1.schemas.user import UserResponse\nfrom api.v1.models.post_comment import PostComment\nfrom api.v1.models.post import Post\nfrom api.v1.models.user import User\nfrom api.v1.models.notification import Notification\nfrom api.v1.services.user import user_service\nfrom api.v1.services.notification import notification_service\n\n\nclass CommentService:\n    # class attributes\n    post_not_found = HTTPException(\n        status_code=status.HTTP_404_NOT_FOUND, detail=\"Post does not exist\"\n    )\n\n    comment_not_found = HTTPException(\n        status_code=status.HTTP_404_NOT_FOUND, detail=\"Comment does not exist\"\n    )\n\n    # end of class attributes\n\n    # class methods\n    def create(\n            self, db: Session, user: User, post_id: str, schema: CreateCommentSchema, background_task: BackgroundTasks\n    ):\n        schema_dict = schema.model_dump()\n\n        if all(value is None for value in schema_dict.values()):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"The comment cannot be an empty field\",\n            )\n\n        # get the post\n        post = (\n            db.query(Post).filter(Post.id == post_id).first()\n        )\n\n        if not post:\n            raise self.post_not_found\n\n        comment = PostComment(user_id=user.id, post_id=post.id, **schema_dict)\n\n        # get user complete details and serialize the user\n        comment_owner = user_service.get_user_detail(db=db, user_id=user.id)\n        response_user = jsonable_encoder(comment_owner)\n\n        db.add(comment)\n        db.commit()\n        db.refresh(comment)\n\n        encoded = jsonable_encoder(comment)\n        encoded[\"user\"] = response_user\n\n        # Comment Notification\n        notification = Notification(user_id=post.user_id, message=f\"{user.username} commented on your post\")\n\n        db.add(notification)\n        db.commit()\n\n        # add background task to send notifcation\n        background_task.add_task(notification_service.user_event_queues[notification.user_id].put, notification.message)\n\n\n        return CommentResponse(**encoded)\n\n    def update(\n        self,\n        db: Session,\n        user: User,\n        post_id: str,\n        comment_id: str,\n        schema: UpdateCommentSchema,\n    ):\n\n        schema_dict = schema.model_dump()\n\n        if all(value is None for value in schema_dict.values()):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"The comment cannot be an empty field\",\n            )\n        post = db.query(Post).filter(Post.id == post_id).first()\n\n        if not post:\n            raise self.post_not_found\n\n        comment = (\n            db.query(PostComment)\n            .filter(\n                PostComment.post_id == post.id,\n                PostComment.id == comment_id,\n                PostComment.user_id == user.id,\n            )\n            .first()\n        )\n        if not comment:\n            raise self.comment_not_found\n\n        for attr, value in schema_dict.items():\n            if value:\n                setattr(comment, attr, value)\n\n        comment_owner = user_service.get_user_detail(db=db, user_id=user.id)\n        response_user = jsonable_encoder(comment_owner)\n\n        db.commit()\n        db.refresh(comment)\n\n        encoded = jsonable_encoder(comment)\n        encoded[\"user\"] = response_user\n\n        return CommentResponse(**encoded)\n\n    def delete(self, db: Session, user: User, post_id: str, comment_id: str):\n\n        post = (\n            db.query(Post).filter(Post.user_id == user.id, Post.id == post_id).first()\n        )\n\n        if not post:\n            raise self.post_not_found\n\n        comment = (\n            db.query(PostComment)\n            .filter(\n                PostComment.id == comment_id,\n                PostComment.post_id == post.id,\n                PostComment.user_id == user.id,\n            )\n            .first()\n        )\n\n        if not comment:\n            raise self.comment_not_found\n\n        db.delete(comment)\n        db.commit()\n\n\n\n\n    def get_comments(self, db: Session, user: User, post_id: str\n):\n\n        post = db.query(Post).filter(Post.user_id == user.id, Post.id == post_id).first()\n\n        if not post:\n            raise self.post_not_found\n\n        comments = db.query(PostComment).filter(PostComment.post_id == post_id).all()\n\n        response_comments = []\n\n        for comment in comments:\n            owner_details = user_service.get_user_detail(db=db, user_id=comment.user_id)\n            response_user = jsonable_encoder(owner_details)\n            validate_user = UserResponse(**response_user)\n            response_comment = jsonable_encoder(comment)\n\n            response_comment[\"user\"] = validate_user.model_dump()\n\n            response_comments.append(response_comment)\n\n\n        return jsonable_encoder(response_comments)\n\n    # end of class methods\n\n\ncomment_service = CommentService()\n"}
{"type": "source_file", "path": "api/v1/utils/dependencies.py", "content": "from api.v1.utils.database import SessionLocal\n\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    except Exception as e:\n        raise e\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "api/v1/utils/database.py", "content": "import os\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\nfrom dotenv import load_dotenv\nload_dotenv()\n\nSQLALCHEMY_DATABASE_URL = os.environ.get(\"DATABASE_URL\")\n\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nBase = declarative_base()\n"}
{"type": "source_file", "path": "api/v1/utils/websocket.py", "content": "from fastapi import WebSocket, WebSocketDisconnect\n\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: list[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\n\nmanager = ConnectionManager()\n"}
{"type": "source_file", "path": "api/v1/utils/storage.py", "content": "from dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\nimport cloudinary\nimport cloudinary.uploader\nimport cloudinary.api\n\nconfig = cloudinary.config(\n    cloud_name=os.environ.get(\"CLOUDINARY_CLOUD_NAME\"),\n    api_key=os.environ.get(\"CLOUDINARY_API_KEY\"),\n    api_secret=os.environ.get(\"CLOUDINARY_API_SECRET\"),\n    secure=True,\n)\n\n\ndef upload(file):\n    \"\"\"File upload handler\n\n    :usage: res = upload(request_file.file.read())\n    \"\"\"\n\n    response = cloudinary.uploader.upload(\n        file,\n        unique_filename=False,\n        overwrite=True,\n        asset_folder=\"chat-stream-api\",\n        resource_type=\"auto\",\n    )\n\n    return response.get(\"secure_url\")\n"}
{"type": "source_file", "path": "main.py", "content": "import os\nfrom dotenv import load_dotenv\nfrom fastapi import FastAPI, Request, status\nfrom fastapi.exceptions import RequestValidationError, FastAPIError\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nimport uvicorn\nfrom starlette.exceptions import HTTPException as StarletteHttpException\nfrom sqlalchemy.exc import InvalidRequestError\n\nfrom api.v1.utils.database import Base, engine\nfrom api.v1.routes import version_one\n\nload_dotenv()\n\n# custom imports\n\nfrom api.v1.responses.error_responses import ValidationErrorResponse, ErrorResponse\nfrom api.v1.responses.success_response import success_response\n\n\n# create database tables\n\nBase.metadata.create_all(bind=engine)\n\napp: FastAPI = FastAPI(\n    debug=os.environ.get(\"DEBUG\") != \"False\",\n    docs_url=\"/docs\",\n    redoc_url=None,\n    title=\"Fastapi Social Media API\",\n)\n\n# routes\n\napp.include_router(version_one)  # api version one\n\n# cors handler\n\norigins = [\"*\"]\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n# validation exception handler\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\n    \"\"\"\n    :param request: HTTP request object\n    :param exc: HTTP exception\n    :returns JSONResponse\n    \"\"\"\n\n    errors = []\n    for error in exc.errors():\n        errors.append(\n            {\n                \"field\": error.get(\"loc\")[-1],\n                \"message\": error.get(\"msg\"),\n            }\n        )\n    response = ValidationErrorResponse(errors=errors)\n    return JSONResponse(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, content=response.model_dump()\n    )\n\n\n@app.exception_handler(StarletteHttpException)\nasync def http_exception_handler(request: Request, exc: StarletteHttpException):\n    \"\"\"\n    :param request: HTTP request object\n    :param exc: HTTP exception\n    :returns JSONResponse\n    \"\"\"\n\n    response = ErrorResponse(status_code=exc.status_code, message=exc.detail)\n    return JSONResponse(status_code=exc.status_code, content=response.model_dump())\n\n\n@app.exception_handler(InvalidRequestError)\nasync def http_exception_handler(request: Request, exc: InvalidRequestError):\n    \"\"\"\n    :param request: HTTP request object\n    :param exc: HTTP exception\n    :returns JSONResponse\n    \"\"\"\n\n    response = ErrorResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, message=exc._message()\n    )\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content=response.model_dump()\n    )\n\n@app.exception_handler(FastAPIError)\nasync def http_exception_handler(request: Request, exc: FastAPIError):\n    \"\"\"\n    :param request: HTTP request object\n    :param exc: HTTP exception\n    :returns JSONResponse\n    \"\"\"\n\n    response = ErrorResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, message=exc.detail\n    )\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content=response.model_dump()\n    )\n\n\n@app.get(\"/\")\nasync def index():\n    return success_response(message=\"Welcome to fastapi-social-media-api\")\n\n\n# start server\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, port=int(os.environ.get(\"SERVER_PORT\", 5001)), reload=False)\n"}
{"type": "source_file", "path": "api/v1/services/post.py", "content": "from fastapi import HTTPException, status, BackgroundTasks\nfrom fastapi.encoders import jsonable_encoder\nfrom sqlalchemy.orm import Session, joinedload\nfrom api.v1.models.post import Post, Like\nfrom api.v1.models.user import User\nfrom api.v1.schemas.post import (\n    CreatePostSchema,\n    UpdatePostSchema,\n    LikeResponse,\n    RepostResponse,\n    RepostCreate,\n    PostResponse,\n    PostResponseSchema\n)\nfrom api.v1.schemas.user import UserResponse\nfrom api.v1.services.user import user_service\nfrom api.v1.models.notification import Notification\nfrom api.v1.services.notification import notification_service\n\nclass PostService:\n    def get_post(self, db: Session, user: User, post_id: str):\n        post = db.query(Post).options(\n                joinedload(Post.original_post),\n                joinedload(Post.user)\n                ).filter(Post.id == post_id).first()\n\n        return jsonable_encoder(post)\n\n\n    def get_feeds(self, db: Session, user: User):\n        posts = db.query(Post).all()\n\n        posts_response = []\n        for post in posts:\n            \n            detailed_post = self.get_post(db=db, user=user, post_id=post.id)\n            validated_post_response = PostResponseSchema(**detailed_post)\n            posts_response.append(validated_post_response)\n\n        return posts_response\n\n\n    def create(self, db: Session, user: User, schema: CreatePostSchema):\n        schema_dict = schema.model_dump()\n\n        if all(value is None for value in schema_dict.values()):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Please provide one of content, image or video\",\n            )\n\n        post = Post(user_id=user.id, **schema_dict)\n\n        db.add(post)\n        db.commit()\n        db.refresh(post)\n\n        return jsonable_encoder(post)\n\n\n    def delete(self, db: Session, user: User, post_id: str):\n        # get post matching post_id and user\n\n        post = (\n            db.query(Post).filter(Post.user_id == user.id, Post.id == post_id).first()\n        )\n\n        if not post:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, detail=\"Post not found\"\n            )\n\n        db.delete(post)\n        db.commit()\n\n\n    def update(self, db: Session, user: User, post_id: str, schema: UpdatePostSchema):\n        # get post from db\n\n        post = (\n            db.query(Post).filter(Post.id == post_id, Post.user_id == user.id).first()\n        )\n\n        schema_dict = schema.model_dump()\n\n        if all(value is None for value in schema_dict.values()):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Please provide one of content, image or video\",\n            )\n\n        if not post:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, detail=\"Post not found\"\n            )\n\n        for attr, value in schema_dict.items():\n            if value:\n                setattr(post, attr, value)\n\n        db.commit()\n        db.refresh(post)\n\n        return jsonable_encoder(post)\n\n\n    def like_post(self, db: Session, user: User, post_id: str, background_task: BackgroundTasks):\n\n        # get the post\n        post = (\n            db.query(Post).filter(Post.id == post_id).first()\n        )\n\n        if not post:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, details=\"Page not found\"\n            )\n\n        # Check if user has already liked the post\n        like = (\n            db.query(Like)\n            .filter(Like.post_id == post_id, Like.user_id == user.id)\n            .first()\n        )\n\n        if like:\n            db.delete(like)\n            db.commit()\n\n            # notification for unliking a post\n            notification = Notification(user_id=post.user_id, message=f\"{user.username} recently unliked your post\")\n\n            db.add(notification)\n            db.commit()\n\n            background_task.add_task(notification_service.user_event_queues[notification.user_id].put, notification.message)\n\n        else:\n            like = Like(user_id=user.id, post_id=post_id)\n            like.liked = True\n            db.add(like)\n            db.commit()\n\n            # add notification for like\n\n            notification = Notification(user_id=post.user_id, message=f\"{user.username} recently liked your post\")\n\n            db.add(notification)\n            db.commit()\n\n            # background task for sse notification\n\n            background_task.add_task(notification_service.user_event_queues[notification.user_id].put, notification.message)\n\n\n    def get_likes(self, db: Session, post_id: str, user: User):\n\n        post = (\n            db.query(Post).filter(Post.id == post_id, Post.user_id == user.id).first()\n        )\n\n        if not post:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, details=\"Page not found\"\n            )\n\n        likes = db.query(Like).filter(Like.post_id == post_id).all()\n\n        likes_response = []\n\n        for like in likes:\n\n            owner_details = user_service.get_user_detail(db=db, user_id=like.user_id)\n            response_user = jsonable_encoder(owner_details)\n            validate_user = UserResponse(**response_user)\n\n            like_response = jsonable_encoder(like)\n\n            like_response[\"user\"] = validate_user.model_dump()\n\n            likes_response.append(like_response)\n\n        return likes_response\n\n\n    def repost(self, db: Session, post_id: str, user: User, schema: RepostCreate, background_task: BackgroundTasks):\n\n        original_post = self.get_post(db=db, user=user, post_id=post_id)\n\n        if not original_post:\n            raise HTTPException(status_code=404, detail=\"Post not found\")\n\n        # Ceeate new post\n        new_post = Post(\n            content=schema.content,\n            user_id=user.id,\n            original_post_id=post_id,\n        )\n\n        db.add(new_post)\n        db.commit()\n        db.refresh(new_post)\n\n        new_post_owner = user_service.get_user_detail(db=db, user_id=user.id)\n\n        # Post serialization\n        original_post_response = jsonable_encoder(original_post)\n\n        new_post_response = jsonable_encoder(new_post)\n        new_post_response[\"user\"] = jsonable_encoder(new_post_owner)\n        new_post_response[\"post\"] = original_post_response\n\n        # repost notification\n        notification = Notification(user_id=original_post.user_id,essage=f\"{user.username} shared your post\")\n        db.add(notification)\n        db.commit()\n\n        # background task for notificatiom\n        background_task.add_task(notification_service.user_event_queues[notification.user_id].put, notification.message)\n\n        return RepostResponse(**new_post_response)\n\n\npost_service = PostService()\n"}

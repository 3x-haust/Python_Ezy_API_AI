{"repo_info": {"repo_name": "llms-as-method-actors", "repo_owner": "colindoyle0000", "repo_url": "https://github.com/colindoyle0000/llms-as-method-actors"}}
{"type": "source_file", "path": "src/__init__.py", "content": ""}
{"type": "source_file", "path": "__init__.py", "content": ""}
{"type": "source_file", "path": "src/guess.py", "content": "\"\"\"Base class for storing information about a guess that is processed.\"\"\"\n\nimport os\nimport logging\n\nfrom src.baseclass import BaseClass\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.utils_llm import (\n    llm_call\n)\n\nfrom src.submit import Submit\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\nclass BaseGuess(BaseClass):\n    \"\"\"Base class for storing information about a guess that is processed.\"\"\"\n\n    def __init__(\n        self\n    ):\n        super().__init__()  # Call the constructor of BaseClass\n\n        self.puzzle = None\n        self.solve = None\n        self.num_of_guess = None\n\n        self.guess_lst = []\n        self.good_options_for_guess = True\n        self.guess_is_valid = True\n        self.guess_is_ready_to_submit = False\n        self.guess_rationale = \"\"\n        self.guess_was_submitted = False\n        self.guess_is_correct = False\n        self.guess_was_one_away = False\n\n        # Class instance of submit\n        self.submit = None\n\n    def do_submit(self):\n        \"\"\"Submit the guess for part of the answer to the puzzle.\"\"\"\n        self.submit = Submit(self)\n        self.guess_was_submitted = True\n        if self.submit.submit_guess() is True:\n            self.guess_is_correct = True\n        else:\n            self.guess_is_correct = False\n            if self.puzzle.solution_lst is not None:\n                if self.submit.check_if_one_away() is True:\n                    self.guess_was_one_away = True\n                else:\n                    self.guess_was_one_away = False\n\n    def set_bad_guesses_str(self):\n        \"\"\"Set the string for the bad guesses.\"\"\"\n        bad_guesses = \" \"\n\n        # Check if there are any bad guesses\n        if len(self.solve.bad_guesses_lst) > 0:\n            # Check to make sure at least one bad guess is still viable (all words are in the word remain list)\n            count_viable = 0\n            for guess in self.solve.bad_guesses_lst:\n                if all(word in self.solve.words_remain_lst for word in guess):\n                    count_viable += 1\n            if count_viable > 0:\n                bad_guesses += \"The following guesses were incorrect: \\n\"\n                for guess in self.solve.bad_guesses_lst:\n                    if all(word in self.solve.words_remain_lst for word in guess):\n                        guess_str = \" \".join(guess)\n                        # Add guess_str to bad_guesses\n                        bad_guesses += f\"{guess_str}\\n\"\n        return bad_guesses\n\n    \n    def select_fix(self, guess_str: str):\n        \"\"\"If the guess does not contain four words, ask the LLM to fix it.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'select_fix.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Create a user prompt\n        prompt_user = f\"Please fix the guess: {guess_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.puzzle.llm_settings.model, prompts=prompts, settings=self.puzzle.llm_settings)\n        return llm_response\n    \n\n    def validate_guess_format(self):\n        \"\"\"Validate the guess formatting.\"\"\"\n        # If the guess list has more or less than four items, log a warning\n        if len(self.guess_lst) != 4:\n            logger.warning(\"Invalid guess. Guess does not contain four words.\")\n            return False\n        else:\n            logger.info(\"Valid guess format. Guess contains four words.\")\n            return True\n        \n    def validate_guess_content(self):\n        \"\"\"Check to make sure the guess content can be submmitted.\"\"\"\n        # Conditions for valid guess content:\n        # - The guess only contains words from the words_remain_lst\n        # - The guess is not already in bad_guesses_lst\n        guess_set = set(self.guess_lst)\n        if not guess_set.issubset(set(self.solve.words_remain_lst)):\n            logger.info(\n                \"Invalid guess. Guess contains words not in words_remain_lst.\")\n            return False\n        for bad_guess in self.solve.bad_guesses_lst:\n            if guess_set == set(bad_guess):\n                logger.info(\n                    \"Invalid guess: Guess is already in bad_guesses_lst.\")\n                return False\n        logger.info(\"Valid guess content.\")\n        return True\n    \n    def validate_all(self):\n        \"\"\"Run each of the steps to validate the guess.\"\"\"\n        self.guess_is_valid = True\n        if self.validate_guess_format() is False:\n            self.guess_is_valid = False\n        if self.validate_guess_content() is False:\n            self.guess_is_valid = False"}
{"type": "source_file", "path": "src/brainstorm.py", "content": "\"\"\"\nBrainstorm class for generating possible solutions to the puzzle using the Actor approach.\n\"\"\"\n\nimport os\nimport logging\nimport random\n\nfrom src.baseclass import BaseClass\nfrom src.utils_file import get_root_dir\nfrom src.utils_llm import llm_call\nfrom src.utils_string import get_timestamp\n\n# Set up logger\nlogger = logging.getLogger('connections')\n\n\nclass Brainstorm(BaseClass):\n    \"\"\"Class for brainstorming puzzle solutions using the Actor approach.\n\n    This class includes methods to load templates, generate prompts, and interact with an LLM\n    to brainstorm possible solutions to a given puzzle.\n    \"\"\"\n\n    def __init__(self, guess):\n        \"\"\"\n        Initialize the Brainstorm instance with a guess and related puzzle data.\n\n        Args:\n            guess: An instance representing the current guess for the puzzle, containing information \n                   about the puzzle, solutions, and tracking incorrect guesses.\n        \"\"\"\n        self.guess = guess\n        self.puzzle = guess.puzzle\n        self.solve = guess.solve\n        self.templates = []  # Stores templates for brainstorming solutions\n        self.brainstorm_responses = []  # Stores LLM responses from brainstorming sessions\n        self.brainstorm_outputs = []  # Stores generated outputs from LLM responses\n        self.llm_settings = self.puzzle.llm_settings  # LLM settings associated with the puzzle\n\n    def set_llm_temperature(self, temperature=0.0):\n        \"\"\"\n        Set the LLM temperature to control response creativity.\n\n        Args:\n            temperature (float): LLM temperature setting, influencing response randomness.\n        \"\"\"\n        self.llm_settings.temperature = temperature\n        logger.info(\"Setting LLM temperature to %s for brainstorming.\", self.llm_settings.temperature)\n\n    def load_templates(self, num_templates=5):\n        \"\"\"\n        Load a specified number of brainstorming templates from files.\n\n        Args:\n            num_templates (int): Number of templates to load for brainstorming. Defaults to 5.\n        \n        Raises:\n            FileNotFoundError: If template files are not found in the specified folder.\n        \"\"\"\n        self.templates = []\n        templates_temp = []\n        folder = os.path.join(get_root_dir(), 'data', 'templates')\n\n        # Retrieve all template files in the directory\n        files = [file for file in os.listdir(folder) if file.endswith('.txt')]\n        files.sort(key=lambda x: int(x.split('_')[0]))  # Sort based on numeric prefixes\n\n        # Load and store contents of each template file\n        for file in files:\n            with open(os.path.join(folder, file), 'r', encoding='utf-8') as f:\n                templates_temp.append(f.read())\n        \n        # Ensure `solve.templates_index` is initialized\n        if not hasattr(self.solve, 'templates_index'):\n            self.solve.templates_index = 0\n        \n        # Fill `self.templates` up to `num_templates` elements\n        while len(self.templates) < num_templates:\n            if self.solve.templates_index >= len(templates_temp):\n                self.solve.templates_index = 0\n            self.templates.append(templates_temp[self.solve.templates_index])\n            self.solve.templates_index += 1\n        \n        logger.info(\"Selected the first %s templates.\", num_templates)\n\n    def brainstorm(self, template=None):\n        \"\"\"\n        Generate a brainstorming response using a specified or random template.\n\n        Args:\n            template (str): Optional. Template for generating a response. If None, selects a random template.\n\n        Returns:\n            dict: LLM response containing generated content and metadata.\n        \"\"\"\n        # If no template is provided, randomly select one from `self.templates`\n        if template is None:\n            template = random.choice(self.templates)\n        \n        # Load system prompt for brainstorming and replace placeholders\n        with open(os.path.join(get_root_dir(), 'data', 'prompts', 'actor', 'brainstorm.txt'), 'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        prompt_system = prompt_system.replace('{template}', template)\n\n        # Add previous incorrect guesses to the prompt, if any\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n\n        # Generate user prompt with shuffled remaining words\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"Let's brainstorm a possible solution to this puzzle: {words_remain_str}\"\n\n        # Set up the prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n\n        # Call the LLM and return its response\n        llm_response = llm_call(model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def brainstorm_all(self):\n        \"\"\"\n        Generate multiple brainstorming responses by iterating through loaded templates.\n\n        Returns:\n            list: List of all LLM responses generated across multiple brainstorming attempts.\n        \"\"\"\n        self.brainstorm_responses = []\n        self.brainstorm_outputs = []\n        count = 1\n        for template in self.templates:\n            logger.debug(\"Brainstorming attempt %s of %s.\", count, len(self.templates))\n            response = self.brainstorm(template=template)\n            self.brainstorm_responses.append(response)\n            self.brainstorm_outputs.append(response.output)\n            count += 1\n        return self.brainstorm_responses\n"}
{"type": "source_file", "path": "src/brainstorm_actor_2.py", "content": "\"\"\"BrainstormActor2 class for brainstorming possible solutions to the puzzle under Actor-2 approach.\"\"\"\n\nimport os\nimport logging\nimport random\n\nfrom src.baseclass import BaseClass\nfrom src.utils_file import get_root_dir\nfrom src.utils_llm import llm_call\nfrom src.utils_string import get_timestamp\n\n# Set up logger\nlogger = logging.getLogger('connections')\n\n\nclass BrainstormActor2(BaseClass):\n    \"\"\"Class to manage brainstorming for puzzle solutions using the Actor-2 approach.\n    \n    This class allows for loading brainstorming templates, setting up prompts for the language\n    model (LLM), and generating brainstorming responses based on given puzzle context.\n    \"\"\"\n\n    def __init__(self, guess):\n        \"\"\"\n        Initialize the BrainstormActor2 instance with a guess and related puzzle data.\n\n        Args:\n            guess: An instance representing the current puzzle guess, including details \n                   about the puzzle context and solutions.\n        \"\"\"\n        self.guess = guess\n        self.puzzle = guess.puzzle\n        self.solve = guess.solve\n\n        # Templates for the different kinds of solutions\n        self.templates = []\n        # Brainstorming responses and outputs\n        self.brainstorm_responses = []\n        self.brainstorm_outputs = []\n        # LLM settings for brainstorming\n        self.llm_settings = self.puzzle.llm_settings\n\n    def set_llm_temperature(self, temperature=0.0):\n        \"\"\"\n        Set the LLM temperature setting for brainstorming, allowing future adjustments \n        to the randomness/creativity of responses.\n        \n        Args:\n            temperature (float): Temperature for the LLM, controlling response randomness.\n        \"\"\"\n        self.llm_settings.temperature = temperature\n        logger.info(\"Setting LLM temperature to %s for brainstorming.\",\n                    self.llm_settings.temperature)\n\n    def load_templates(self, num_templates=5):\n        \"\"\"\n        Load and select a specified number of brainstorming templates from the template folder.\n\n        Args:\n            num_templates (int): Number of templates to load for brainstorming. Defaults to 5.\n        \n        Raises:\n            FileNotFoundError: If template files are not found in the specified folder.\n        \"\"\"\n        self.templates = []\n        templates_temp = []\n        folder = os.path.join(get_root_dir(), 'data', 'templates')\n\n        # List all files in the folder\n        files = [file for file in os.listdir(folder) if file.endswith('.txt')]\n\n        # Sort files based on the numeric value at the start of each filename\n        files.sort(key=lambda x: int(x.split('_')[0]))\n\n        # Read and append the contents of each file to self.templates\n        for file in files:\n            with open(os.path.join(folder, file), 'r', encoding='utf-8') as f:\n                templates_temp.append(f.read())\n        \n        # Ensure self.solve.templates_index is initialized\n        if not hasattr(self.solve, 'templates_index'):\n            self.solve.templates_index = 0\n        \n        # Append templates to self.templates until it has num_templates elements\n        while len(self.templates) < num_templates:\n            if self.solve.templates_index >= len(templates_temp):\n                self.solve.templates_index = 0\n            self.templates.append(templates_temp[self.solve.templates_index])\n            self.solve.templates_index += 1\n        \n        logger.info(\n            \"Selected the first %s templates.\", num_templates)\n\n    def brainstorm(self, template=None):\n        \"\"\"\n        Generate a brainstorming response by asking the LLM for a possible solution.\n\n        Args:\n            template (str): Optional. The template to use for this brainstorming session.\n                            If not provided, a random template will be selected.\n\n        Returns:\n            dict: The response from the LLM call, including generated output and metadata.\n        \"\"\"\n        # If no template is provided, choose a random template\n        if template is None:\n            template = random.choice(self.templates)\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_2', 'brainstorm.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {template} with the actual template\n        prompt_system = prompt_system.replace('{template}', template)\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Create user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.temp_words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"Let's brainstorm a possible solution to this puzzle: {words_remain_str}\"\n        # Set up the prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def brainstorm_all(self):\n        \"\"\"\n        Generate a series of brainstorming responses by iterating through loaded templates.\n\n        Returns:\n            list: List of all LLM responses generated across multiple brainstorming attempts.\n        \"\"\"\n        self.brainstorm_responses = []\n        self.brainstorm_outputs = []\n        count = 1\n        for template in self.templates:\n            logger.debug(\"Brainstorming attempt %s of %s.\",\n                            count, len(self.templates))\n            response = self.brainstorm(template=template)\n            self.brainstorm_responses.append(response)\n            self.brainstorm_outputs.append(response.output)\n            count += 1\n        return self.brainstorm_responses\n"}
{"type": "source_file", "path": "src/discern.py", "content": "\"\"\"Discern class for discerning valuable answers from brainstorming notes for Actor approach.\"\"\"\nimport os\nimport logging\nimport random\nfrom src.baseclass import BaseClass\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.utils_llm import (\n    llm_call\n)\n\nfrom src.utils_tokens import (\n    list_to_token_list,\n    num_tokens\n)\n\nfrom src.utils_string import get_timestamp\n\n# Set up logger\nlogger = logging.getLogger('connections')\n\n\nclass Discern(BaseClass):\n    \"\"\"Class for discerning valuable answers from brainstorming note for Actor approach.\"\"\"\n\n    def __init__(\n        self,\n        guess,\n        brainstorm_responses,\n    ):\n        self.guess = guess\n        self.puzzle = guess.puzzle\n        self.solve = guess.solve\n        # LLM settings for discerning\n        self.llm_settings = self.puzzle.llm_settings\n        # Brainstorm responses\n        self.brainstorm_responses = brainstorm_responses\n        # Brainstorm outputs as a list of items sized to match chunk token size\n        self.brainstorm_notes_token_lst = []\n        # Extracted answers from brainstorming notes\n        self.extract_responses = []\n        self.extract_outputs = []\n        # Discerning best guess from extracted answers\n        self.discern_responses = []\n        self.discern_outputs = []\n        self.discern_guess_str = \"\"\n        # Deciding whether to select a guess to submit or go back to brainstorming\n        self.decide_cot_responses = []\n        self.decide_cot_outputs = []\n        # Decide Yes-No\n        self.decide_yn_responses = []\n        self.decide_yn_outputs = []\n        # Select guess\n        self.select_responses = []\n        self.select_outputs = []\n        # Submit guess\n        self.submit_guess = True\n\n    def set_llm_temperature(self):\n        \"\"\"Set the LLM temperature setting for discern.\n        Note that this is not currently used in the code. It is here for any future experiments in changing the temperature for brainstorming process.\n        \"\"\"\n        self.llm_settings.temperature = 0.6\n        logger.info(\"Setting LLM temperature to %s for discerning.\",\n                    self.llm_settings.temperature)\n\n    def extract_answers(self, brainstorm_notes_str):\n        \"\"\"Extract viable answers from brainstorming notes.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor', 'extract.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the brainstorming notes\n        prompt_system = prompt_system.replace(\"{notes}\", brainstorm_notes_str)\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        if len(self.solve.guesses_ready_to_submit) > 0:\n            ready_to_submit_str = \"\"\n            ready_to_submit_str = \"\\n You have already decided to submit the following guesses, so you should not select them again as a guess to submit: \\n\"\n            for guess in self.solve.guesses_ready_to_submit:\n                guess_str = \" \".join(guess.guess_lst)\n                ready_to_submit_str += f\"{guess_str}\\n\"\n            prompt_system = prompt_system + ready_to_submit_str\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"From your brainstorming notes, extract viable answers for this puzzle: {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def extract_all(self):\n        \"\"\"Extract all viable answers from brainstorming notes.\"\"\"\n        self.brainstorm_notes_token_lst = []\n        self.extract_responses = []\n        self.extract_outputs = []\n        # Turn the brainstorming notes list into a list of max_token sized strings\n        brainstorm_notes_lst = []\n        for response in self.brainstorm_responses:\n            brainstorm_notes_lst.append(response.output)\n        brainstorm_notes_lst = [\n            f\"## Brainstorming Note #{i+1} \\n \\n\" + note + \"\\n *** \\n\" for i, note in enumerate(brainstorm_notes_lst)]\n        self.brainstorm_notes_token_lst = list_to_token_list(\n            brainstorm_notes_lst, self.llm_settings.chunk_size, self.llm_settings.chunk_overlap)\n        logger.info(\"Created token list of brainstorming notes. Number of notes in list: %s\",\n                    len(self.brainstorm_notes_token_lst))\n        # For each set of notes in the token list, extract answers\n        for notes in self.brainstorm_notes_token_lst:\n            count = 1\n            logger.info(\n                \"Extracting answers from brainstorming notes... %s of %s\", count, len(self.brainstorm_notes_token_lst))\n            # Extract answers from the brainstorming notes\n            response = self.extract_answers(notes)\n            self.extract_responses.append(response)\n            self.extract_outputs.append(response.output)\n            count += 1\n\n    def discern_guess(self, extract_notes_str: str):\n        \"\"\"Discern valuable answers from answers extracted from brainstorming notes.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts',  'actor', 'discern.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the extract notes\n        prompt_system = prompt_system.replace(\"{notes}\", extract_notes_str)\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"From your notes, let's discern the strongest viable guesses for this puzzle: {words_remain_str}\"\n\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def discern_guess_all(self):\n        \"\"\"Discern the best guess from extracted answers.\"\"\"\n        self.discern_responses = []\n        self.discern_outputs = []\n        self.discern_guess_str = \"\"\n        # Turn the extracted notes list into a list of max_token sized strings\n        extract_notes_token_lst = list_to_token_list(\n            self.extract_outputs, self.llm_settings.chunk_size, self.llm_settings.chunk_overlap)\n        logger.info(\"Created token list of extracted notes. Number of notes in list: %s\",\n                    len(extract_notes_token_lst))\n        # For each set of notes in the token list, discern the best guess\n        for notes in extract_notes_token_lst:\n            count = 1\n            logger.info(\n                \"Discerning the best guess from extracted answers... %s of %s\", count, len(extract_notes_token_lst))\n            # Discern the best guess from the extracted answers\n            response = self.discern_guess(notes)\n            self.discern_responses.append(response)\n            self.discern_outputs.append(response.output)\n            count += 1\n        if len(extract_notes_token_lst) > 1:\n            # If needing to run discern method multiple times, do a final run of the discern method on the outputs of the prior runs\n            logger.info(\n                \"Discerning best guess from all prior discerned guesses...\")\n            # For the discern outputs, join them into a single string\n            discern_notes_str = \" \".join(self.discern_outputs)\n            self.discern_responses = []\n            self.discern_outputs = []\n            self.discern_guess_str = \"\"\n            # Discern the best guess from the discerned guesses\n            response = self.discern_guess(discern_notes_str)\n            self.discern_responses.append(response)\n            self.discern_outputs.append(response.output)\n        self.discern_guess_str = \" \".join(self.discern_outputs)\n\n    def decide_cot(self, discern_guess_str: str):\n        \"\"\"Decide whether to submit a guess from the discern method.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts',  'actor', 'decide_cot.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Within the system prompt, replace the placeholder {notes} with the discerned guess\n        prompt_system = prompt_system.replace(\"{notes}\", discern_guess_str)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"Should I submit a guess from these notes as an answer for this puzzle: {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def decide_yn(self, decide_cot_str: str):\n        \"\"\"Interpret the output of the LLM in decide_cot to decide yes or no.\"\"\"\n        # Yes = submit guess\n        # No = brainstorm\n        # Load the system prompt from a .txt file\n        with open(os.path.join(get_root_dir(), 'data', 'prompts', 'actor', 'decide_yn.txt'), 'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace {notes} with decide_cot notes\n        prompt_system = prompt_system.replace('{notes}', decide_cot_str)\n        # Create a user prompt\n        prompt_user = \"Yes = submit a guess. No = go back to brainstorming.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model_cheap, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def decide_all(self):\n        \"\"\"Go through decide process.\"\"\"\n        self.decide_cot_responses = []\n        self.decide_cot_outputs = []\n        self.decide_yn_responses = []\n        self.decide_yn_outputs = []\n        response = self.decide_cot(self.discern_guess_str)\n        self.decide_cot_responses.append(response)\n        self.decide_cot_outputs.append(response.output)\n        response = self.decide_yn(response.output)\n        self.decide_yn_responses.append(response)\n        self.decide_yn_outputs.append(response.output)\n        if \"yes\" in response.output.lower():\n            logger.info(\n                \"Discern method produced good options for a guess. Continuing...\")\n            self.guess.good_options_for_guess = True\n        else:\n            logger.info(\n                \"Discern method did not produce good options for a guess. Need to start over.\")\n            self.guess.good_options_for_guess = False\n\n    def select(self, notes_str: str):\n        \"\"\"Select the best discerned guess.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor', 'select.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the notes_str\n        prompt_system = prompt_system.replace(\"{notes}\", notes_str)\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Create a user prompt\n        prompt_user = \"Please select the best guess to submit.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def select_fix(self, guess_str: str):\n        \"\"\"If the guess does not contain four words, ask the LLM to fix it.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'select_fix.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Create a user prompt\n        prompt_user = f\"Please fix the guess: {guess_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def select_all(self):\n        \"\"\"Select the best discerned guess.\"\"\"\n        self.select_responses = []\n        self.select_outputs = []\n        # Run the select function to get a guess from the LLM\n        logger.info(\"Selecting the best guess...\")\n        notes_str = \"\"\n        for response in self.decide_cot_responses:\n            notes_str += response.output\n            notes_str += \"/n *** /n\"\n        llm_response = self.select(notes_str)\n        self.select_responses.append(llm_response)\n        self.select_outputs.append(llm_response.output)\n        # Turn the guess into a list of words and fix formatting\n        guess = llm_response.output\n        # Remove \"Output:\" or \"Response:\" from guess if it appears in the string\n        guess = guess.replace(\"Output:\", \"\").strip()\n        guess = guess.replace(\"Response:\", \"\").strip()\n        guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n        \n        # Sort the guess_lst in alphabetical order\n        guess_lst = sorted(guess_lst)  \n        \n        if len(guess_lst) != 4:\n            logger.warning(\n                \"Guess does not contain four words. Trying to get LLM to fix...\")\n            llm_response = self.select_fix(guess)\n            # Turn the guess into a list of words and fix formatting\n            guess = llm_response.output\n            # Remove \"Output:\" from guess if it appears in the string\n            guess = guess.replace(\"Output:\", \"\").strip()\n            guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n            if len(guess_lst) != 4:\n                logger.warning(\n                    \"Failed to fix guess. Guess still does not contain four words.\")\n            else:\n                logger.info(\"Fixed guess!\")\n        \n        self.guess.guess_lst = guess_lst\n        logger.info(\"Selected guess: %s\", \" \".join(guess_lst))\n\n    def validate_guess_format(self):\n        \"\"\"Validate the guess formatting.\"\"\"\n        # If the guess list has more or less than four items, log a warning\n        if len(self.guess.guess_lst) != 4:\n            logger.warning(\"Invalid guess. Guess does not contain four words.\")\n            return False\n        else:\n            logger.info(\"Valid guess format. Guess contains four words.\")\n            return True\n\n    def validate_guess_content(self):\n        \"\"\"Check to make sure the guess content can be submmitted.\"\"\"\n        # Conditions for valid guess content:\n        # - The guess only contains words from the words_remain_lst\n        # - The guess is not already in bad_guesses_lst\n        guess_set = set(self.guess.guess_lst)\n        if not guess_set.issubset(set(self.solve.words_remain_lst)):\n            logger.info(\n                \"Invalid guess. Guess contains words not in words_remain_lst.\")\n            return False\n        for bad_guess in self.solve.bad_guesses_lst:\n            if guess_set == set(bad_guess):\n                logger.info(\n                    \"Invalid guess: Guess is already in bad_guesses_lst.\")\n                return False\n        logger.info(\"Valid guess content.\")\n        return True\n\n\n    def select_and_validate_all(self):\n        \"\"\"Select the best guess and validate it for errors.\"\"\"\n\n        # Select guess\n        self.select_all()\n\n        # Validate the guess formatting, and if it is not valid, try again\n        attempts = 1\n        while self.validate_guess_format() is False or self.validate_guess_content() is False:\n            if attempts > 2:\n                logger.warning(\n                    \"Failed to select a correctly formatted guess after retrying.\")\n                return False\n            logger.warning(\"Trying to select guess again...\")\n            self.select_all()\n            attempts += 1\n        return True\n\n    def make_ready_to_submit(self):\n        \"\"\"Make the guess ready to submit by summarizing rationale.\"\"\"\n        logger.info(\"Making guess ready to submit.\")\n        self.guess.guess_rationale = \"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor', 'make_ready_to_submit.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {guess} with the guess\n        prompt_system = prompt_system.replace(\n            \"{guess}\", \" \".join(self.guess.guess_lst))\n        # Within the system prompt, replace the placeholder {notes} with decide_cot outputs\n        notes_str = \"\"\n        for response in self.decide_cot_responses:\n            notes_str += response.output\n            notes_str += \"/n *** /n\"\n        prompt_system = prompt_system.replace(\"{notes}\", notes_str)\n        # Create a user prompt\n        prompt_user = \"Please summarize the connection and rationale for this guess.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        self.guess.guess_rationale = llm_response.output\n        self.guess.guess_is_ready_to_submit = True\n"}
{"type": "source_file", "path": "src/discern_actor_2.py", "content": "\"\"\"\nDiscernActor2 class for discerning the best solutions to the puzzle using Actor-2 approach.\n\"\"\"\nimport os\nimport logging\nimport random\n\nfrom src.baseclass import BaseClass\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.utils_llm import (\n    llm_call\n)\nfrom src.utils_tokens import (\n    list_to_token_list,\n    num_tokens\n)\nfrom src.utils_string import get_timestamp\n\n# Set up logger\nlogger = logging.getLogger('connections')\n\n\nclass DiscernActor2(BaseClass):\n    \"\"\"Class to discern the best guess using the Actor-2 approach.\n\n    This class provides functions to extract viable answers, discern optimal guesses, decide\n    if a guess is ready for submission, validate guesses, and select the final guess for submission.\n    \"\"\"\n    def __init__(\n        self,\n        guess,\n        brainstorm_responses,\n    ):\n        self.guess = guess\n        self.puzzle = guess.puzzle\n        self.solve = guess.solve\n        # LLM settings for discerning\n        self.llm_settings = self.puzzle.llm_settings\n        # Brainstorm responses\n        self.brainstorm_responses = brainstorm_responses\n        # Brainstorm outputs as a list of items sized to match chunk token size\n        self.brainstorm_notes_token_lst = []\n        # Extracted answers from brainstorming notes\n        self.extract_responses = []\n        self.extract_outputs = []\n        # Discerning best guess from extracted answers\n        self.discern_responses = []\n        self.discern_outputs = []\n        self.discern_guess_str = \"\"\n        # Deciding whether to select a guess to submit or go back to brainstorming\n        self.decide_cot_responses = []\n        self.decide_cot_outputs = []\n        # Decide Yes-No\n        self.decide_yn_responses = []\n        self.decide_yn_outputs = []\n        # Select guess\n        self.select_responses = []\n        self.select_outputs = []\n        # Submit guess\n        self.submit_guess = True\n\n    def set_llm_temperature(self):\n        \"\"\"Set the LLM temperature setting for discern.\n        Note that this is not currently used in the code. It is here for any future experiments in changing the temperature for brainstorming process.\n        \"\"\"\n        self.llm_settings.temperature = 0.6\n        logger.info(\"Setting LLM temperature to %s for discerning.\",\n                    self.llm_settings.temperature)\n\n    def extract_answers(self, brainstorm_notes_str):\n        \"\"\"Extract viable answers from brainstorming notes.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_2', 'extract.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the brainstorming notes\n        prompt_system = prompt_system.replace(\"{notes}\", brainstorm_notes_str)\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        if len(bad_guesses_str) > 0:\n            # Add text to the beginning of bad_guesses_str\n            bad_guesses_str = \"\\n \\n You should not copy from the notes any guesses that we already know were incorrect. \\n\" + bad_guesses_str\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        words_remain_shuffled = self.solve.temp_words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"From your brainstorming notes, extract viable answers for this puzzle: {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def extract_all(self):\n        \"\"\"Extract all viable answers from brainstorming notes.\"\"\"\n        self.brainstorm_notes_token_lst = []\n        self.extract_responses = []\n        self.extract_outputs = []\n        # Turn the brainstorming notes list into a list of max_token sized strings\n        brainstorm_notes_lst = []\n        for response in self.brainstorm_responses:\n            brainstorm_notes_lst.append(response.output)\n        brainstorm_notes_lst = [\n            f\"## Brainstorming Note #{i+1} \\n \\n\" + note + \"\\n *** \\n\" for i, note in enumerate(brainstorm_notes_lst)]\n        self.brainstorm_notes_token_lst = list_to_token_list(\n            brainstorm_notes_lst, self.llm_settings.chunk_size, self.llm_settings.chunk_overlap)\n        logger.info(\"Created token list of brainstorming notes. Number of notes in list: %s\",\n                    len(self.brainstorm_notes_token_lst))\n        # For each set of notes in the token list, extract answers\n        for notes in self.brainstorm_notes_token_lst:\n            count = 1\n            logger.info(\n                \"Extracting answers from brainstorming notes... %s of %s\", count, len(self.brainstorm_notes_token_lst))\n            # Extract answers from the brainstorming notes\n            response = self.extract_answers(notes)\n            self.extract_responses.append(response)\n            self.extract_outputs.append(response.output)\n            count += 1\n\n    def discern_guess(self, extract_notes_str: str):\n        \"\"\"Discern valuable answers from answers extracted from brainstorming notes.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts',  'actor_2', 'discern.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the extract notes\n        prompt_system = prompt_system.replace(\"{notes}\", extract_notes_str)\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        if len(bad_guesses_str) > 0:\n            # Add text to end of bad_guesses_str\n            bad_guesses_str += \"\\n \\n You should reject any guess that has the same four words as a guess that we already know is incorrect. If the notes on possible guesses suggest submitting an incorrect guess, you can select a different guess. \\n\"            \n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.temp_words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"From your notes, let's discern the strongest viable guesses for this puzzle: {words_remain_str}\"\n\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def discern_guess_all(self):\n        \"\"\"Discern the best guess from extracted answers.\"\"\"\n        self.discern_responses = []\n        self.discern_outputs = []\n        self.discern_guess_str = \"\"\n        # Turn the extracted notes list into a list of max_token sized strings\n        extract_notes_token_lst = list_to_token_list(\n            self.extract_outputs, self.llm_settings.chunk_size, self.llm_settings.chunk_overlap)\n        logger.info(\"Created token list of extracted notes. Number of notes in list: %s\",\n                    len(extract_notes_token_lst))\n        # For each set of notes in the token list, discern the best guess\n        for notes in extract_notes_token_lst:\n            count = 1\n            logger.info(\n                \"Discerning the best guess from extracted answers... %s of %s\", count, len(extract_notes_token_lst))\n            # Discern the best guess from the extracted answers\n            response = self.discern_guess(notes)\n            self.discern_responses.append(response)\n            self.discern_outputs.append(response.output)\n            count += 1\n        if len(extract_notes_token_lst) > 1:\n            # If needing to run discern method multiple times, do a final run of the discern method on the outputs of the prior runs\n            logger.info(\n                \"Discerning best guess from all prior discerned guesses...\")\n            # For the discern outputs, join them into a single string\n            discern_notes_str = \" \".join(self.discern_outputs)\n            self.discern_responses = []\n            self.discern_outputs = []\n            self.discern_guess_str = \"\"\n            # Discern the best guess from the discerned guesses\n            response = self.discern_guess(discern_notes_str)\n            self.discern_responses.append(response)\n            self.discern_outputs.append(response.output)\n        self.discern_guess_str = \" \".join(self.discern_outputs)\n\n    def decide_cot(self, discern_guess_str: str):\n        \"\"\"Decide whether to submit a guess from the discern method.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts',  'actor_2', 'decide_cot.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        if len(bad_guesses_str) > 0:\n            # Add text to end of bad_guesses_str\n            bad_guesses_str += \"\\n \\n You should not submit a guess that we already know was incorrect. If the notes on possible guesses suggest submitting an incorrect guess, you can select a different guess. \\n\"\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Within the system prompt, replace the placeholder {notes} with the discerned guess\n        prompt_system = prompt_system.replace(\"{notes}\", discern_guess_str)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.temp_words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"Should I submit a guess from these notes as an answer for this puzzle: {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def decide_yn(self, decide_cot_str: str):\n        \"\"\"Interpret the output of the LLM in decide_cot to decide yes or no.\"\"\"\n        # Yes = submit guess\n        # No = brainstorm\n        # Load the system prompt from a .txt file\n        with open(os.path.join(get_root_dir(), 'data', 'prompts', 'actor_2', 'decide_yn.txt'), 'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace {notes} with decide_cot notes\n        prompt_system = prompt_system.replace('{notes}', decide_cot_str)\n        # Create a user prompt\n        prompt_user = \"Yes = submit a guess. No = go back to brainstorming.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def decide_all(self):\n        \"\"\"Go through decide process.\"\"\"\n        self.decide_cot_responses = []\n        self.decide_cot_outputs = []\n        self.decide_yn_responses = []\n        self.decide_yn_outputs = []\n        response = self.decide_cot(self.discern_guess_str)\n        self.decide_cot_responses.append(response)\n        self.decide_cot_outputs.append(response.output)\n        response = self.decide_yn(response.output)\n        self.decide_yn_responses.append(response)\n        self.decide_yn_outputs.append(response.output)\n        if \"yes\" in response.output.lower():\n            logger.info(\n                \"Discern method produced good options for a guess. Continuing...\")\n            self.guess.good_options_for_guess = True\n        else:\n            logger.info(\n                \"Discern method did not produce good options for a guess. Need to start over.\")\n            self.guess.good_options_for_guess = False\n\n    def select(self, notes_str: str):\n        \"\"\"Select the best discerned guess.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_2', 'select.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the notes_str\n        prompt_system = prompt_system.replace(\"{notes}\", notes_str)\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Create a user prompt\n        prompt_user = \"Please select the best guess to submit.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def select_fix(self, guess_str: str):\n        \"\"\"If the guess does not contain four words, ask the LLM to fix it.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'select_fix.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Create a user prompt\n        prompt_user = f\"Please fix the guess: {guess_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def select_all(self):\n        \"\"\"Select the best discerned guess.\"\"\"\n        self.select_responses = []\n        self.select_outputs = []\n        # Run the select function to get a guess from the LLM\n        logger.info(\"Selecting the best guess...\")\n        notes_str = \"\"\n        for response in self.decide_cot_responses:\n            notes_str += response.output\n            notes_str += \"/n *** /n\"\n        llm_response = self.select(notes_str)\n        self.select_responses.append(llm_response)\n        self.select_outputs.append(llm_response.output)\n        # Turn the guess into a list of words and fix formatting\n        guess = llm_response.output\n        # Remove \"Output:\" or \"Response:\" from guess if it appears in the string\n        guess = guess.replace(\"Output:\", \"\").strip()\n        guess = guess.replace(\"Response:\", \"\").strip()\n        guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n        \n        # Sort the guess_lst in alphabetical order\n        guess_lst = sorted(guess_lst)  \n        \n        if len(guess_lst) != 4:\n            logger.warning(\n                \"Guess does not contain four words. Trying to get LLM to fix...\")\n            llm_response = self.select_fix(guess)\n            # Turn the guess into a list of words and fix formatting\n            guess = llm_response.output\n            # Remove \"Output:\" from guess if it appears in the string\n            guess = guess.replace(\"Output:\", \"\").strip()\n            guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n            if len(guess_lst) != 4:\n                logger.warning(\n                    \"Failed to fix guess. Guess still does not contain four words.\")\n            else:\n                logger.info(\"Fixed guess!\")\n        \n        self.guess.guess_lst = guess_lst\n        logger.info(\"Selected guess: %s\", \" \".join(guess_lst))\n\n    def validate_guess_format(self):\n        \"\"\"Validate the guess formatting.\"\"\"\n        # If the guess list has more or less than four items, log a warning\n        if len(self.guess.guess_lst) != 4:\n            logger.warning(\"Invalid guess. Guess does not contain four words.\")\n            return False\n        else:\n            logger.info(\"Valid guess format. Guess contains four words.\")\n            return True\n\n    def validate_guess_content(self):\n        \"\"\"Check to make sure the guess content can be submmitted.\"\"\"\n        # Conditions for valid guess content:\n        # - The guess only contains words from the words_remain_lst\n        # - The guess is not already in bad_guesses_lst\n        # - The guess is not already in logically_bad_guesses_lst\n        \n        guess_set = set(self.guess.guess_lst)\n        if not guess_set.issubset(set(self.solve.words_remain_lst)):\n            logger.info(\n                \"Invalid guess. Guess contains words not in words_remain_lst.\")\n            return False\n        for bad_guess in self.solve.bad_guesses_lst:\n            if guess_set == set(bad_guess):\n                logger.info(\n                    \"Invalid guess: Guess is already in bad_guesses_lst.\")\n                return False\n        for logically_bad_guess in self.solve.logically_bad_guesses_lst:\n            if guess_set == set(logically_bad_guess):\n                logger.info(\n                    \"Invalid guess: Guess is already in logically_bad_guesses_lst.\")\n                return False\n        logger.info(\"Valid guess content.\")\n        return True\n\n\n    def select_and_validate_all(self):\n        \"\"\"Select the best guess and validate it for errors.\"\"\"\n\n        # Select guess\n        self.select_all()\n\n        # Validate the guess formatting, and if it is not valid, try again\n        attempts = 1\n        while self.validate_guess_format() is False or self.validate_guess_content() is False:\n            if attempts > 2:\n                logger.warning(\n                    \"Failed to select a correctly formatted guess after retrying.\")\n                return False\n            logger.warning(\"Trying to select guess again...\")\n            self.select_all()\n            attempts += 1\n        return True\n\n    def make_ready_to_submit(self):\n        \"\"\"Make the guess ready to submit by summarizing rationale.\"\"\"\n        logger.info(\"Making guess ready to submit.\")\n        self.guess.guess_rationale = \"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_2', 'make_ready_to_submit.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {guess} with the guess\n        prompt_system = prompt_system.replace(\n            \"{guess}\", \" \".join(self.guess.guess_lst))\n        # Within the system prompt, replace the placeholder {notes} with decide_cot outputs\n        notes_str = \"\"\n        for response in self.decide_cot_responses:\n            notes_str += response.output\n            notes_str += \"/n *** /n\"\n        prompt_system = prompt_system.replace(\"{notes}\", notes_str)\n        # Create a user prompt\n        prompt_user = \"Please summarize the connection and rationale for this guess.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        self.guess.guess_rationale = llm_response.output\n        self.guess.guess_is_ready_to_submit = True\n"}
{"type": "source_file", "path": "src/experiment_actor_2.py", "content": "\"\"\"ExperimentActor2 class oversees the whole experiment process for Actor-2.\"\"\"\nimport logging\nimport os\nimport json\nimport pandas as pd\n\nfrom src.utils_llm import (\n    LLMSettings\n)\n\nfrom src.baseclass import BaseClass\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.get_puzzle_info import extract_puzzle_data_from_url\n\nfrom src.puzzle_actor_2 import PuzzleActor2\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass ExperimentActor2(BaseClass):\n    \"\"\"Experiment class oversees the whole experiment process.\"\"\"\n\n    def __init__(self,\n                 puzzle_numbers: list,\n                 llm_settings: LLMSettings = LLMSettings(),\n                 model: str = None\n    ):\n        self.puzzle_numbers = puzzle_numbers\n        self.puzzles = {}\n        self.llm_settings = llm_settings\n        if model is not None:\n            self.llm_settings.model = model\n        # Dictionary of the results of the experiment\n        self.results_dict = None\n        # Numpy array of the results of the experiment\n        self.results_array = None\n        # Pandas DataFrame of the results of the experiment\n        self.results_df = None\n        # Filepath to save data from this experiment\n        self.path = \"\"\n        self.path_pkl = \"\"\n        self.path_export = \"\"\n    \n    def set_path(self, name: str = None, date: str = None):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        # If name and date are not passed, use the default directory.\n        if name is None and date is None:\n            date = get_date()\n            self.path = os.path.join(\n                get_root_dir(), \"outputs\", date\n            )\n        # If a directory is passed, use that directory.\n        else:\n            # If date is not passed, use the current date.\n            if date is None:\n                date = get_date()\n            # If name is not passed, use an underscore.\n            if name is None:\n                name = \"_\"\n            self.path = os.path.join(get_root_dir(), \"outputs\", date, name)\n        # Create the directory if it does not exist.\n        os.makedirs(self.path, exist_ok=True)\n        # Set the path for saving data to pkl file.\n        self.path_pkl = os.path.join(self.path, \"experiment_actor_2_pkl\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_pkl, exist_ok=True)\n        # Set the path for saving data exports.\n        self.path_export = os.path.join(self.path, \"experiment_actor_2_export\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_export, exist_ok=True)\n    \n    def set_llm_settings(\n        self,\n        embeddings: str = None,\n        model: str = None,\n        max_tokens: int = None,\n        model_long: str = None,\n        max_tokens_long: int = None,\n        model_cheap: str = None,\n        max_tokens_cheap: int = None,\n        chunk_size: int = None,\n        chunk_overlap: int = None,\n        chunk_size_long: int = None,\n        max_attempts: int = None,\n        temperature: int = None,\n        response_format: str = None\n    ):\n        \"\"\"Set the LLM settings.\n        With this function, only the settings that you want to change need to be passed.\n        \"\"\"\n        self.llm_settings.embeddings = embeddings if embeddings else self.llm_settings.embeddings\n        self.llm_settings.model = model if model else self.llm_settings.model\n        self.llm_settings.max_tokens = max_tokens if max_tokens else self.llm_settings.max_tokens\n        self.llm_settings.model_long = model_long if model_long else self.llm_settings.model_long\n        self.llm_settings.max_tokens_long = max_tokens_long if max_tokens_long else self.llm_settings.max_tokens_long\n        self.llm_settings.model_cheap = model_cheap if model_cheap else self.llm_settings.model_cheap\n        self.llm_settings.max_tokens_cheap = max_tokens_cheap if max_tokens_cheap else self.llm_settings.max_tokens_cheap\n        self.llm_settings.chunk_size = chunk_size if chunk_size else self.llm_settings.chunk_size\n        self.llm_settings.chunk_overlap = chunk_overlap if chunk_overlap else self.llm_settings.chunk_overlap\n        self.llm_settings.chunk_size_long = chunk_size_long if chunk_size_long else self.llm_settings.chunk_size_long\n        self.llm_settings.max_attempts = max_attempts if max_attempts else self.llm_settings.max_attempts\n        self.llm_settings.temperature = temperature if temperature else self.llm_settings.temperature\n        self.llm_settings.response_format = response_format if response_format else self.llm_settings.response_format\n\n    def set_puzzles(self):\n        \"\"\"Set the puzzles for the experiment.\"\"\"\n        self.puzzles = {}  # Initialize an empty dictionary\n        for number in self.puzzle_numbers:  # Iterate over each puzzle number\n            logger.info(\"Getting puzzle information for puzzle %s\", number)\n            url = f\"https://connections.swellgarfo.com/nyt/{number}\"  # Construct the URL for the puzzle\n            puzzle_str, number, solution_lst = extract_puzzle_data_from_url(url)  # Extract puzzle data from the URL\n            path = os.path.join(self.path, str(number))  # Create a directory for the puzzle\n            # Create a new Puzzle object\n            puzzle = PuzzleActor2(\n                words_str=puzzle_str, \n                number=number,\n                solution_lst=solution_lst, \n                llm_settings=self.llm_settings, \n                model=self.llm_settings.model,\n                path=path\n            )\n            # Add the puzzle to the dictionary of puzzles\n            self.puzzles[number] = puzzle  \n            logger.info(\"Puzzle %s added to the experiment.\", number)\n            self.puzzles[number].setup_puzzle()\n    \n    def set_new_puzzles(self, puzzle_numbers: list):\n        \"\"\"Set new puzzles for the experiment.\"\"\"\n        # Add the new puzzle numbers to the existing list of puzzle numbers\n        self.puzzle_numbers.extend(puzzle_numbers)\n        # Set the new puzzles\n        for number in self.puzzle_numbers:\n            if number not in self.puzzles:\n                logger.info(\"Getting puzzle information for puzzle %s\", number)\n                url = f\"https://connections.swellgarfo.com/nyt/{number}\"\n                puzzle_str, number, solution_lst = extract_puzzle_data_from_url(url)\n                path = os.path.join(self.path, str(number))\n                puzzle = PuzzleActor2(\n                    words_str=puzzle_str, \n                    number=number,\n                    solution_lst=solution_lst, \n                    llm_settings=self.llm_settings, \n                    model=self.llm_settings.model,\n                    path=path\n                )\n                self.puzzles[number] = puzzle\n                logger.info(\"Puzzle %s added to the experiment.\", number)\n                self.puzzles[number].setup_puzzle()\n    \n    def solve_puzzle(self, number: int):\n        \"\"\"Solve a single puzzle.\"\"\"\n        self.puzzles[number].solve_all()\n        \n    def solve_puzzle_all(self):\n        \"\"\"Solve all puzzles in the experiment.\"\"\"\n        for number, puzzle in self.puzzles.items():\n            logger.info(\"Solving puzzle %s\", number)\n            puzzle.solve_all()\n            timestamp = get_timestamp()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                    name=f\"experiment_{timestamp}\")\n            \n    def solve_unfinished_puzzles(self):\n        \"\"\"Solve all unfinished puzzles in the experiment.\"\"\"\n        for number, puzzle in self.puzzles.items():\n            logger.info(\"Solving puzzle %s\", number)\n            if self.puzzles[number].actor_2 is None or self.puzzles[number].actor_2.end_game is False:\n                puzzle.solve_unfinished()\n                timestamp = get_timestamp()\n            else:\n                logger.info(\"Puzzle %s already solved.\", number)\n        self.save_attributes(filepath_pkl=self.path_pkl, name=f\"experiment_{timestamp}\")\n\n    def save_results_dict(self):\n        \"\"\"Save the results of the experiment to a dictionary.\"\"\"\n        self.results_dict = {}\n        for number, puzzle in self.puzzles.items():\n            if puzzle.results_dict:\n                self.results_dict[number] = puzzle.results_dict\n            else:\n                logger.warning(\"Puzzle %s has no results.\", number)\n                self.results_dict[number] = {}\n    \n    def save_results_dict_to_json(self):\n        \"\"\"Save the results of the experiment to a JSON file.\"\"\"\n        timestamp = get_timestamp()\n        filepath = os.path.join(self.path_export, f\"results_{timestamp}.json\")\n        with open(filepath, \"w\") as f:\n            json.dump(self.results_dict, f, indent=4)\n    \n    def save_results_df(self):\n        \"\"\"Save the results of the experiment to a pandas DataFrame.\"\"\"\n        data = []\n        for number, puzzle in self.puzzles.items():\n            row = {'puzzle_number': number}\n            \n            for result_type in ['actor_2']:\n                result = puzzle.results_dict.get(result_type, {})\n        \n                # Add the values to the row, with keys indicating the result type\n                row[f'{result_type}_success'] = result.get('success', None)\n                row[f'{result_type}_good_guesses'] = result.get('good_guesses', None)\n                row[f'{result_type}_bad_guesses'] = result.get('bad_guesses', None)\n                row[f'{result_type}_guesses_submitted'] = result.get('guesses_submitted', None)\n    \n            data.append(row)\n\n        # Convert the list of dictionaries to a DataFrame\n        self.results_df = pd.DataFrame(data)\n        timestamp = get_timestamp()\n        self.results_df.to_excel(os.path.join(self.path_export, f\"experiment_actor_2_results{timestamp}.xlsx\"), index=False)\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"experiment_actor_2\")\n    \n    def run_experiment(self, numbers: list):\n        \"\"\"Run the experiment.\"\"\"\n        self.set_path()\n        self.set_puzzles()\n        self.setup_puzzles()\n        self.solve_puzzle_all()\n        self.save_results_dict()\n        self.save_results_dict_to_json()\n        self.save_results_df()\n    \n    def finish_experiment(self):\n        \"\"\"Finish the experiment.\"\"\"\n        self.solve_unfinished_puzzles()\n        self.save_results_dict()\n        self.save_results_dict_to_json()\n        self.save_results_df()\n"}
{"type": "source_file", "path": "src/guess_actor_o1.py", "content": "\"\"\"Guess class for Actor-o1 approach for storing information about a guess that is processed.\"\"\"\n\n\nimport logging\n\nfrom src.guess import BaseGuess\nfrom src.brainstorm_actor_o1 import Brainstormo1\nfrom src.discern_actor_o1 import Discerno1\n\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\nclass GuessActoro1(BaseGuess):\n    \"\"\"Guess class for Actor-o1 approach for storing information about a guess that is processed.\"\"\"\n\n    def __init__(\n        self,\n        solve\n    ):\n        super().__init__()\n        self.solve = solve\n        self.puzzle = self.solve.puzzle\n        self.num_of_guess = len(self.solve.guesses_processed)+1\n        self.guess_type = 1\n        self.guess_lst_freq = 0\n        # Count of how many times guess has been evaluated for submission as a final guess\n        self.guess_eval_count = 0\n\n        # Class instances\n        self.brainstorm = None\n        self.discern = None\n    \n    \n    def process_guess(self):\n        \"\"\"Process the guess from start to finish for the Actor-o1 approach\n        \"\"\"\n        brainstorm_responses = self.do_brainstorm()\n        self.do_discern(brainstorm_responses)\n        if self.guess_is_valid is True:\n            self.discern.make_ready_to_submit()\n\n    def do_brainstorm(self):\n        \"\"\"Brainstorm possible solutions to the puzzle.\"\"\"\n        self.brainstorm = Brainstormo1(self)\n        brainstorm_responses = self.brainstorm.brainstorm_all()\n        self.brainstorm.save_outputs(filepath_md=self.solve.path_md,\n                                     name=f\"guess_{self.num_of_guess}_brainstorm\",\n                                     responses=brainstorm_responses\n                                     )\n        return brainstorm_responses\n\n    def do_discern(self, brainstorm_responses):\n        \"\"\"Select the guess from the brainstorming responses.\"\"\"\n        self.discern = Discerno1(self, brainstorm_responses)\n        if self.discern.select_and_validate_all() is True:\n            self.guess_is_valid = True\n        else:\n            self.guess_is_valid = False\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_select\",\n                                  responses=self.discern.select_responses\n                                  )\n"}
{"type": "source_file", "path": "src/get_puzzle_info.py", "content": "import re\nimport json\nimport requests\n\n\ndef extract_puzzle_data_from_url(url):\n    # Fetch the HTML content from the webpage\n    response = requests.get(url)\n    if response.status_code != 200:\n        raise ValueError(\n            f\"Failed to retrieve webpage content. Status code: {response.status_code}\")\n\n    html_content = response.text\n\n    # Extract the JSON data from the script tag\n    json_data_match = re.search(\n        r'<script id=\"__NEXT_DATA__\" type=\"application/json\">(.+?)</script>', html_content)\n    if not json_data_match:\n        raise ValueError(\"Could not find JSON data in the HTML content\")\n\n    json_data = json.loads(json_data_match.group(1))\n\n    # Extract the number from the query key\n    number = int(json_data['props']['pageProps']['id'])\n\n    # Extract the puzzle words and group them\n    puzzle_str = \"\"\n    solution_lst = []\n\n    for answer in json_data['props']['pageProps']['answers']:\n        words = \"\\n\".join(answer['words'])\n        puzzle_str += words + \"\\n\"\n        solution_lst.append(f'\\n{words}\\n')\n\n    puzzle_str = puzzle_str.strip()  # Remove the last newline\n\n    return puzzle_str, number, solution_lst\n"}
{"type": "source_file", "path": "src/baseclass.py", "content": "\"\"\"Base class for all classes in the project.\n\nThis class provides methods for saving instance attributes to disk and loading them back, \nas well as for saving outputs in a markdown file format.\n\"\"\"\n\nimport os\nimport pickle\nimport logging\nimport time\n\nfrom src.utils_string import get_timestamp\n\n# Set up logger\nlogger = logging.getLogger('connections')\n\nclass BaseClass:\n    \"\"\"Base class for all classes in the project.\n    \n    Attributes:\n        num_responses (int): Number of responses.\n        num_input_tokens (int): Number of input tokens.\n        num_output_tokens (int): Number of output tokens.\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the BaseClass with default values.\"\"\"\n        self.num_responses = 0\n        self.num_input_tokens = 0\n        self.num_output_tokens = 0\n\n    def save_attributes(self, filepath_pkl, name):\n        \"\"\"Save the instance attributes to a .pkl file.\n        \n        Args:\n            filepath_pkl (str): The directory path where the .pkl file will be saved.\n            name (str): The name of the .pkl file.\n        \n        Raises:\n            Exception: If saving fails due to file permission or path errors.\n        \"\"\"\n        directory = os.path.join(filepath_pkl)\n        os.makedirs(directory, exist_ok=True)\n        filename = os.path.join(filepath_pkl, f\"{name}.pkl\")\n        with open(filename, 'wb') as f:\n            pickle.dump(self.__dict__, f)\n            logger.info(\"Saved attributes to .pkl file: %s\", filename)\n\n    def load_attributes(self, filename: str = None, filepath_pkl: str = None, name: str = None):\n        \"\"\"Load attributes from a .pkl file.\n        \n        Args:\n            filename (str, optional): The full path to the .pkl file.\n            filepath_pkl (str, optional): The directory path where the .pkl file is located.\n            name (str, optional): The name of the .pkl file.\n        \n        Raises:\n            FileNotFoundError: If the specified file does not exist.\n        \"\"\"\n        if filename is not None:\n            try:\n                with open(filename, 'rb') as f:\n                    data = pickle.load(f)\n                for key, value in data.items():\n                    setattr(self, key, value)\n            except FileNotFoundError:\n                logger.warning(\"File not found: %s\", filename)\n        elif name is not None:\n            try:\n                with open(os.path.join(filepath_pkl, name), 'rb') as f:\n                    data = pickle.load(f)\n                for key, value in data.items():\n                    setattr(self, key, value)\n            except FileNotFoundError:\n                logger.warning(\"File not found: %s\", os.path.join(filepath_pkl, name))\n        else:\n            logger.warning(\"No filepath or name provided.\")\n\n    def save_outputs(self, filepath_md, name: str, responses: list):\n        \"\"\"Save the outputs of the class LLM responses to a markdown file.\n        \n        Args:\n            filepath_md (str): The directory path where the markdown file will be saved.\n            name (str): The name of the markdown file.\n            responses (list): List of response objects, each containing 'prompts' and 'output' attributes.\n\n        Raises:\n            Exception: If saving fails due to file permission or path errors.\n        \"\"\"\n        timestamp = get_timestamp()\n        filename = f\"{name}_{timestamp}.md\"\n        with open(os.path.join(filepath_md, filename), 'w', encoding='utf-8') as f:\n            f.write(f\"# {name} Prompts and Outputs\\n\\n\")\n            for response in responses:\n                f.write(\"## Prompts\\n\\n\")\n                # Turn the prompts into a string\n                prompts_str = \"\"\n                for prompt in response.prompts:\n                    prompts_str += f\"{prompt['role']}: {prompt['content']}\\n\\n\"\n                f.write(prompts_str)\n                f.write(\"## Output\\n\\n\")\n                f.write(response.output)\n                f.write(\"\\n\\n\")\n"}
{"type": "source_file", "path": "src/discern_actor_o1.py", "content": "\"\"\"Discerno1 class for discerning valuable answers from brainstorming notes for Actor-o1 approach.\"\"\"\nimport os\nimport logging\nimport random\n\nfrom src.baseclass import BaseClass\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.utils_llm import (\n    llm_call\n)\n\nfrom src.utils_tokens import (\n    list_to_token_list,\n    num_tokens\n)\n\nfrom src.utils_string import get_timestamp\n\n# Set up logger\nlogger = logging.getLogger('connections')\n\n\nclass Discerno1(BaseClass):\n    \"\"\"Class for discerning valuable answers from brainstorming notes.\"\"\"\n\n    def __init__(\n        self,\n        guess,\n        brainstorm_responses,\n    ):\n        self.guess = guess\n        self.puzzle = guess.puzzle\n        self.solve = guess.solve\n        # LLM settings for discerning\n        self.llm_settings = self.puzzle.llm_settings\n        self.llm_settings.model = \"gpt-4o\"\n        # Brainstorm responses\n        self.brainstorm_responses = brainstorm_responses\n        # Select guess\n        self.select_responses = []\n        self.select_outputs = []\n        # Submit guess\n        self.submit_guess = True\n\n    def set_llm_temperature(self):\n        \"\"\"Set the LLM temperature setting for discern.\n        Note that this is not currently used in the code. It is here for any future experiments in changing the temperature for brainstorming process.\n        \"\"\"\n        self.llm_settings.temperature = 0.6\n        logger.info(\"Setting LLM temperature to %s for discerning.\",\n                    self.llm_settings.temperature)\n\n    def select(self, notes_str: str):\n        \"\"\"Select the best discerned guess.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_o1', 'select.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the notes_str\n        prompt_system = prompt_system.replace(\"{notes}\", notes_str)\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Create a user prompt\n        prompt_user = \"Please select the best guess to submit.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def select_fix(self, guess_str: str):\n        \"\"\"If the guess does not contain four words, ask the LLM to fix it.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'select_fix.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Create a user prompt\n        prompt_user = f\"Please fix the guess: {guess_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def select_all(self):\n        \"\"\"Select the best discerned guess.\"\"\"\n        self.select_responses = []\n        self.select_outputs = []\n        # Run the select function to get a guess from the LLM\n        logger.info(\"Selecting the best guess...\")\n        notes_str = \"\"\n        for response in self.brainstorm_responses:\n            notes_str += response.output\n            notes_str += \"/n *** /n\"\n        llm_response = self.select(notes_str)\n        self.select_responses.append(llm_response)\n        self.select_outputs.append(llm_response.output)\n        # Turn the guess into a list of words and fix formatting\n        guess = llm_response.output\n        # Remove \"Output:\" or \"Response:\" from guess if it appears in the string\n        guess = guess.replace(\"Output:\", \"\").strip()\n        guess = guess.replace(\"Response:\", \"\").strip()\n        guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n        \n        # Sort the guess_lst in alphabetical order\n        guess_lst = sorted(guess_lst)  \n        \n        if len(guess_lst) != 4:\n            logger.warning(\n                \"Guess does not contain four words. Trying to get LLM to fix...\")\n            llm_response = self.select_fix(guess)\n            # Turn the guess into a list of words and fix formatting\n            guess = llm_response.output\n            # Remove \"Output:\" from guess if it appears in the string\n            guess = guess.replace(\"Output:\", \"\").strip()\n            guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n            if len(guess_lst) != 4:\n                logger.warning(\n                    \"Failed to fix guess. Guess still does not contain four words.\")\n            else:\n                logger.info(\"Fixed guess!\")\n        \n        self.guess.guess_lst = guess_lst\n        logger.info(\"Selected guess: %s\", \" \".join(guess_lst))\n\n    def validate_guess_format(self):\n        \"\"\"Validate the guess formatting.\"\"\"\n        # If the guess list has more or less than four items, log a warning\n        if len(self.guess.guess_lst) != 4:\n            logger.warning(\"Invalid guess. Guess does not contain four words.\")\n            return False\n        else:\n            logger.info(\"Valid guess format. Guess contains four words.\")\n            return True\n\n    def validate_guess_content(self):\n        \"\"\"Check to make sure the guess content can be submmitted.\"\"\"\n        # Conditions for valid guess content:\n        # - The guess only contains words from the words_remain_lst\n        # - The guess is not already in bad_guesses_lst\n        # - The guess is not already in logically_bad_guesses_lst\n        \n        guess_set = set(self.guess.guess_lst)\n        if not guess_set.issubset(set(self.solve.words_remain_lst)):\n            logger.info(\n                \"Invalid guess. Guess contains words not in words_remain_lst.\")\n            return False\n        for bad_guess in self.solve.bad_guesses_lst:\n            if guess_set == set(bad_guess):\n                logger.info(\n                    \"Invalid guess: Guess is already in bad_guesses_lst.\")\n                return False\n        for logically_bad_guess in self.solve.logically_bad_guesses_lst:\n            if guess_set == set(logically_bad_guess):\n                logger.info(\n                    \"Invalid guess: Guess is already in logically_bad_guesses_lst.\")\n                return False\n        logger.info(\"Valid guess content.\")\n        return True\n\n\n    def select_and_validate_all(self):\n        \"\"\"Select the best guess and validate it for errors.\"\"\"\n\n        # Select guess\n        self.select_all()\n\n        # Validate the guess formatting, and if it is not valid, try again\n        attempts = 1\n        while self.validate_guess_format() is False or self.validate_guess_content() is False:\n            if attempts > 2:\n                logger.warning(\n                    \"Failed to select a correctly formatted guess after retrying.\")\n                return False\n            logger.warning(\"Trying to select guess again...\")\n            self.select_all()\n            attempts += 1\n        return True\n\n    def make_ready_to_submit(self):\n        \"\"\"Make the guess ready to submit by summarizing rationale.\"\"\"\n        logger.info(\"Making guess ready to submit.\")\n        self.guess.guess_rationale = \"\"\n        notes_str = \"\"\n        for response in self.brainstorm_responses:\n            notes_str += response.output\n            notes_str += \"\\n *** \\n\"\n        self.guess.guess_rationale = notes_str\n        self.guess.guess_is_ready_to_submit = True\n"}
{"type": "source_file", "path": "src/guess_actor_2.py", "content": "\"\"\"Guess class for Actor-2 approach for storing information about a guess that is processed.\"\"\"\n\n\nimport logging\n\nfrom src.guess import BaseGuess\n\nfrom src.brainstorm_actor_2 import BrainstormActor2\nfrom src.discern_actor_2 import DiscernActor2\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\nclass GuessActor2(BaseGuess):\n    \"\"\"Guess class for Actor-2 approach for storing information about a guess that is processed.\"\"\"\n\n    def __init__(\n        self,\n        solve\n    ):\n        super().__init__()\n        self.solve = solve\n        self.puzzle = self.solve.puzzle\n        self.num_of_guess = len(self.solve.guesses_processed)+1\n        self.guess_type = 1\n        self.guess_lst_freq = 0\n        # Count of how many times guess has been evaluated for submission as a final guess\n        self.guess_eval_count = 0\n\n        # Class instances\n        self.brainstorm = None\n        self.discern = None\n    \n    \n    def process_guess(self):\n        \"\"\"Process the guess from start to finish for the Actor-2 approach\n        \"\"\"\n        brainstorm_responses = self.do_brainstorm()\n        self.do_discern(brainstorm_responses)\n        self.do_decide()\n        if self.good_options_for_guess is True:\n            self.do_select()\n            if self.guess_is_valid is True:\n                self.discern.make_ready_to_submit()\n\n    def do_brainstorm(self):\n        \"\"\"Brainstorm possible solutions to the puzzle.\"\"\"\n        self.brainstorm = BrainstormActor2(self)\n        num_templates = 5\n        self.brainstorm.load_templates(num_templates=num_templates)\n        brainstorm_responses = self.brainstorm.brainstorm_all()\n        self.brainstorm.save_outputs(filepath_md=self.solve.path_md,\n                                     name=f\"guess_{self.num_of_guess}_brainstorm\",\n                                     responses=brainstorm_responses\n                                     )\n        return brainstorm_responses\n\n    def do_discern(self, brainstorm_responses):\n        \"\"\"Discern the best guesses from the brainstorming responses.\"\"\"\n        self.discern = DiscernActor2(self, brainstorm_responses)\n        self.discern.extract_all()\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_extract\",\n                                  responses=self.discern.extract_responses\n                                  )\n        self.discern.discern_guess_all()\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_discern\",\n                                  responses=self.discern.discern_responses\n                                  )\n\n    def do_decide(self):\n        \"\"\"Decide if there are good options for the guess.\"\"\"\n        self.discern.decide_all()\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_decide_cot\",\n                                  responses=self.discern.decide_cot_responses\n                                  )\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_decide_yn\",\n                                  responses=self.discern.decide_yn_responses\n                                  )\n\n    def do_select(self):\n        \"\"\"Select the guess from the discerning process.\"\"\"\n        if self.discern.select_and_validate_all() is True:\n            self.guess_is_valid = True\n        else:\n            self.guess_is_valid = False\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_select\",\n                                  responses=self.discern.select_responses\n                                  )\n"}
{"type": "source_file", "path": "src/guess_cot.py", "content": "\"\"\"Guess class for Cot approaches for storing information about a guess that is processed.\"\"\"\n\nimport os\nimport logging\nimport random\n\nfrom src.guess import BaseGuess\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.utils_llm import (\n    llm_call\n)\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass GuessCot(BaseGuess):\n    \"\"\"Guess class for Cot approach for storing information about a guess that is processed.\"\"\"\n\n    def __init__(\n        self,\n        solve\n    ):\n        super().__init__()\n        self.solve = solve\n        self.puzzle = self.solve.puzzle\n        self.num_of_guess = len(self.solve.guesses_processed)+1\n        \n        self.make_guess_responses = []\n        self.make_guess_outputs = []\n        self.select_responses = []\n        self.select_outputs = []\n    \n    def process_guess(self):\n        \"\"\"Process the guess from start to finish for the Cot approaches.\"\"\"\n        self.make_guess()\n        self.select_and_validate_all()\n        if self.guess_is_valid is True:\n            self.guess_is_ready_to_submit = True\n        else:\n            self.guess_is_ready_to_submit = False\n    \n    def make_guess(self):\n        \"\"\"Ask LLM to make a guess.\"\"\"\n        self.make_guess_responses = []\n        self.make_guess_outputs = []\n        # Load the system prompt from a .txt file\n        if self.solve.cot_scripted is False:\n            with open(os.path.join(\n                    get_root_dir(), 'data', 'prompts', 'cot', 'make_guess.txt'),\n                    'r', encoding='utf-8') as f:\n                prompt_system = f.read()\n        else:\n            with open(os.path.join(\n                    get_root_dir(), 'data', 'prompts', 'cot_scripted', 'make_guess.txt'),\n                    'r', encoding='utf-8') as f:\n                prompt_system = f.read()\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Create user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"Can you make a guess for one part of the solution to this puzzle? List of words: {words_remain_str}\"\n        # Set up the prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.puzzle.llm_settings.model, prompts=prompts, settings=self.puzzle.llm_settings)\n        self.make_guess_responses.append(llm_response)\n        self.make_guess_outputs.append(llm_response.output)\n        self.guess_rationale = llm_response.output\n        logger.debug(\"Made guess: /n /n %s\", llm_response.output)\n    \n    def select_guess(self):\n        \"\"\"Call LLM to select the guess.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'cot', 'select.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the notes_str\n        prompt_system = prompt_system.replace(\"{notes}\", self.guess_rationale)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"Please select the guess to submit for this puzzle: {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.puzzle.llm_settings.model, prompts=prompts, settings=self.puzzle.llm_settings)\n        logger.debug(\"Select guess: /n /n %s\", llm_response.output)\n        return llm_response\n    \n    def select_all(self):\n        \"\"\"Run each of the steps to select the guess.\"\"\"\n        self.select_responses = []\n        self.select_outputs = []\n        llm_response = self.select_guess()\n        self.select_responses.append(llm_response)\n        self.select_outputs.append(llm_response.output)\n        # Turn the guess into a list of words and fix formatting\n        guess = llm_response.output\n        # Remove \"Output:\" or \"Response:\" from guess if it appears in the string\n        guess = guess.replace(\"Output:\", \"\").strip()\n        guess = guess.replace(\"Response:\", \"\").strip()\n        guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n        \n        # Sort the guess_lst in alphabetical order\n        guess_lst = sorted(guess_lst)\n        # Check if the guess_lst has four words\n        if len(guess_lst) != 4:\n            logger.warning(\n                \"Guess does not contain four words. Trying to get LLM to fix...\")\n            llm_response = self.select_fix(guess)\n            # Turn the guess into a list of words and fix formatting\n            guess = llm_response.output\n            # Remove \"Output:\" from guess if it appears in the string\n            guess = guess.replace(\"Output:\", \"\").strip()\n            guess = guess.replace(\"Response:\", \"\").strip()\n            guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n            if len(guess_lst) != 4:\n                logger.warning(\n                    \"Failed to fix guess. Guess still does not contain four words.\")\n            else:\n                logger.info(\"Fixed guess!\")\n        self.guess_lst = guess_lst\n        logger.info(\"Selected guess: %s\", \" \".join(guess_lst))\n        \n    def select_and_validate_all(self):\n        \"\"\"Select the guess and validate it for errors.\"\"\"\n        self.select_all()\n        self.validate_all()\n"}
{"type": "source_file", "path": "src/experiment_o1.py", "content": "\"\"\"Experimento1 class oversees the process for Experiment #2 with GPT-o1 for Oneshot-o1, Vanilla-o1, and Actor-o1 approaches.\"\"\"\nimport logging\nimport os\nimport json\nimport pandas as pd\n\nfrom src.utils_llm import (\n    LLMSettings\n)\n\nfrom src.baseclass import BaseClass\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.get_puzzle_info import extract_puzzle_data_from_url\n\nfrom src.puzzle_o1 import Puzzleo1\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass Experimento1(BaseClass):\n    \"\"\"Experimento1 class oversees the process for Experiment #2 with o1-preview for Oneshot-o1, Vanilla-o1, and Actor-o1 approaches.\"\"\"\n\n    def __init__(self,\n                 puzzle_numbers: list,\n                 llm_settings: LLMSettings = LLMSettings(),\n                 model: str = None\n    ):\n        self.puzzle_numbers = puzzle_numbers\n        self.puzzles = {}\n        self.llm_settings = llm_settings\n        if model is not None:\n            self.llm_settings.model = model\n        # Dictionary of the results of the experiment\n        self.results_dict = None\n        # Numpy array of the results of the experiment\n        self.results_array = None\n        # Pandas DataFrame of the results of the experiment\n        self.results_df = None\n        # Filepath to save data from this experiment\n        self.path = \"\"\n        self.path_pkl = \"\"\n        self.path_export = \"\"\n    \n    def set_path(self, name: str = None, date: str = None):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        # If name and date are not passed, use the default directory.\n        if name is None and date is None:\n            date = get_date()\n            self.path = os.path.join(\n                get_root_dir(), \"outputs\", date\n            )\n        # If a directory is passed, use that directory.\n        else:\n            # If date is not passed, use the current date.\n            if date is None:\n                date = get_date()\n            # If name is not passed, use an underscore.\n            if name is None:\n                name = \"_\"\n            self.path = os.path.join(get_root_dir(), \"outputs\", date, name)\n        # Create the directory if it does not exist.\n        os.makedirs(self.path, exist_ok=True)\n        # Set the path for saving data to pkl file.\n        self.path_pkl = os.path.join(self.path, \"experiment_o1_pkl\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_pkl, exist_ok=True)\n        # Set the path for saving data exports.\n        self.path_export = os.path.join(self.path, \"experiment_o1_export\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_export, exist_ok=True)\n    \n    def set_llm_settings(\n        self,\n        embeddings: str = None,\n        model: str = None,\n        max_tokens: int = None,\n        model_long: str = None,\n        max_tokens_long: int = None,\n        model_cheap: str = None,\n        max_tokens_cheap: int = None,\n        chunk_size: int = None,\n        chunk_overlap: int = None,\n        chunk_size_long: int = None,\n        max_attempts: int = None,\n        temperature: int = None,\n        response_format: str = None\n    ):\n        \"\"\"Set the LLM settings.\n        With this function, only the settings that you want to change need to be passed.\n        \"\"\"\n        self.llm_settings.embeddings = embeddings if embeddings else self.llm_settings.embeddings\n        self.llm_settings.model = model if model else self.llm_settings.model\n        self.llm_settings.max_tokens = max_tokens if max_tokens else self.llm_settings.max_tokens\n        self.llm_settings.model_long = model_long if model_long else self.llm_settings.model_long\n        self.llm_settings.max_tokens_long = max_tokens_long if max_tokens_long else self.llm_settings.max_tokens_long\n        self.llm_settings.model_cheap = model_cheap if model_cheap else self.llm_settings.model_cheap\n        self.llm_settings.max_tokens_cheap = max_tokens_cheap if max_tokens_cheap else self.llm_settings.max_tokens_cheap\n        self.llm_settings.chunk_size = chunk_size if chunk_size else self.llm_settings.chunk_size\n        self.llm_settings.chunk_overlap = chunk_overlap if chunk_overlap else self.llm_settings.chunk_overlap\n        self.llm_settings.chunk_size_long = chunk_size_long if chunk_size_long else self.llm_settings.chunk_size_long\n        self.llm_settings.max_attempts = max_attempts if max_attempts else self.llm_settings.max_attempts\n        self.llm_settings.temperature = temperature if temperature else self.llm_settings.temperature\n        self.llm_settings.response_format = response_format if response_format else self.llm_settings.response_format\n\n    def set_puzzles(self):\n        \"\"\"Set the puzzles for the experiment.\"\"\"\n        self.puzzles = {}  # Initialize an empty dictionary\n        for number in self.puzzle_numbers:  # Iterate over each puzzle number\n            logger.info(\"Getting puzzle information for puzzle %s\", number)\n            url = f\"https://connections.swellgarfo.com/nyt/{number}\"  # Construct the URL for the puzzle\n            puzzle_str, number, solution_lst = extract_puzzle_data_from_url(url)  # Extract puzzle data from the URL\n            path = os.path.join(self.path, str(number))  # Create a directory for the puzzle\n            # Create a new Puzzle object\n            puzzle = Puzzleo1(\n                words_str=puzzle_str, \n                number=number,\n                solution_lst=solution_lst, \n                llm_settings=self.llm_settings, \n                model=self.llm_settings.model,\n                path=path\n            )\n            # Add the puzzle to the dictionary of puzzles\n            self.puzzles[number] = puzzle  \n            logger.info(\"Puzzle %s added to the experiment.\", number)\n            self.puzzles[number].setup_puzzle()\n    \n    def set_new_puzzles(self, puzzle_numbers: list):\n        \"\"\"Set new puzzles for the experiment.\"\"\"\n        # Add the new puzzle numbers to the existing list of puzzle numbers\n        self.puzzle_numbers.extend(puzzle_numbers)\n        # Set the new puzzles\n        for number in self.puzzle_numbers:\n            if number not in self.puzzles:\n                logger.info(\"Getting puzzle information for puzzle %s\", number)\n                url = f\"https://connections.swellgarfo.com/nyt/{number}\"\n                puzzle_str, number, solution_lst = extract_puzzle_data_from_url(url)\n                path = os.path.join(self.path, str(number))\n                puzzle = Puzzleo1(\n                    words_str=puzzle_str, \n                    number=number,\n                    solution_lst=solution_lst, \n                    llm_settings=self.llm_settings, \n                    model=self.llm_settings.model,\n                    path=path\n                )\n                self.puzzles[number] = puzzle\n                logger.info(\"Puzzle %s added to the experiment.\", number)\n                self.puzzles[number].setup_puzzle()\n    \n    def solve_puzzle(self, number: int):\n        \"\"\"Solve a single puzzle.\"\"\"\n        self.puzzles[number].solve_all()\n        \n    def solve_puzzle_all(self):\n        \"\"\"Solve all puzzles in the experiment.\"\"\"\n        for number, puzzle in self.puzzles.items():\n            logger.info(\"Solving puzzle %s\", number)\n            puzzle.solve_all()\n            timestamp = get_timestamp()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                    name=f\"experiment_o1_{timestamp}\")\n            \n    def solve_unfinished_puzzles(self):\n        \"\"\"Solve all unfinished puzzles in the experiment.\"\"\"\n        for number, puzzle in self.puzzles.items():\n            unfinished = False\n            logger.info(\"Solving puzzle %s\", number)\n            if self.puzzles[number].actoro1 is None:\n                unfinished = True\n            elif self.puzzles[number].vanillao1 is None:\n                unfinished = True\n            elif self.puzzles[number].actoro1.end_game is False:\n                unfinished = True\n            elif self.puzzles[number].vanillao1.end_game is False:\n                unfinished = True\n            elif self.puzzles[number].oneshoto1 is None:\n                unfinished = True\n            elif self.puzzles[number].oneshoto1.end_game is False:\n                unfinished = True\n            if unfinished:\n                puzzle.solve_unfinished()\n                timestamp = get_timestamp()\n\n            else:\n                logger.info(\"Puzzle %s already solved.\", number)\n        self.save_attributes(filepath_pkl=self.path_pkl,\n            name=f\"experiment_o1_{timestamp}\")\n\n    def save_results_dict(self):\n        \"\"\"Save the results of the experiment to a dictionary.\"\"\"\n        self.results_dict = {}\n        for number, puzzle in self.puzzles.items():\n            if puzzle.results_dict:\n                self.results_dict[number] = puzzle.results_dict\n            else:\n                logger.warning(\"Puzzle %s has no results.\", number)\n                self.results_dict[number] = {}\n    \n    def save_results_dict_to_json(self):\n        \"\"\"Save the results of the experiment to a JSON file.\"\"\"\n        timestamp = get_timestamp()\n        filepath = os.path.join(self.path_export, f\"results_{timestamp}.json\")\n        with open(filepath, \"w\") as f:\n            json.dump(self.results_dict, f, indent=4)\n    \n    def save_results_df(self):\n        \"\"\"Save the results of the experiment to a pandas DataFrame.\"\"\"\n        data = []\n        for number, puzzle in self.puzzles.items():\n            row = {'puzzle_number': number}\n            \n            for result_type in ['vanillao1', 'actoro1']:\n                result = puzzle.results_dict.get(result_type, {})\n        \n                # Add the values to the row, with keys indicating the result type\n                row[f'{result_type}_success'] = result.get('success', None)\n                row[f'{result_type}_good_guesses'] = result.get('good_guesses', None)\n                row[f'{result_type}_bad_guesses'] = result.get('bad_guesses', None)\n                row[f'{result_type}_guesses_submitted'] = result.get('guesses_submitted', None)\n    \n            data.append(row)\n\n        # Convert the list of dictionaries to a DataFrame\n        self.results_df = pd.DataFrame(data)\n        timestamp = get_timestamp()\n        self.results_df.to_excel(os.path.join(self.path_export, f\"experiment_o1_results{timestamp}.xlsx\"), index=False)\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"experiment_o1\")\n    \n    def run_experiment(self, numbers: list):\n        \"\"\"Run the experiment.\"\"\"\n        self.set_path()\n        self.set_puzzles()\n        self.setup_puzzles()\n        self.solve_puzzle_all()\n        self.save_results_dict()\n        self.save_results_dict_to_json()\n        self.save_results_df()\n    \n    def finish_experiment(self):\n        \"\"\"Finish the experiment.\"\"\"\n        self.solve_unfinished_puzzles()\n        self.save_results_dict()\n        self.save_results_dict_to_json()\n        self.save_results_df()\n"}
{"type": "source_file", "path": "src/guess_actor.py", "content": "\"\"\"Guess class for Actor approach for storing information about a guess that is processed.\"\"\"\n\nimport logging\n\nfrom src.guess import BaseGuess\nfrom src.brainstorm import Brainstorm\nfrom src.discern import Discern\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\nclass GuessActor(BaseGuess):\n    \"\"\"Guess class for Actor approach for storing information about a guess that is processed.\"\"\"\n\n    def __init__(\n        self,\n        solve\n    ):\n        super().__init__()\n        self.solve = solve\n        self.puzzle = self.solve.puzzle\n        self.num_of_guess = len(self.solve.guesses_processed)+1\n\n        # Class instances\n        self.brainstorm = None\n        self.discern = None\n\n    def process_guess(self):\n        \"\"\"Process the guess from start to finish for the mental model of parody approach.\"\"\"\n        brainstorm_responses = self.do_brainstorm()\n        self.do_discern(brainstorm_responses)\n        self.do_decide()\n        if self.good_options_for_guess is True:\n            self.do_select()\n            if self.guess_is_valid is True:\n                self.discern.make_ready_to_submit()\n\n    def do_brainstorm(self):\n        \"\"\"Brainstorm possible solutions to the puzzle.\"\"\"\n        self.brainstorm = Brainstorm(self)\n        self.brainstorm.load_templates(num_templates=5)\n        brainstorm_responses = self.brainstorm.brainstorm_all()\n        self.brainstorm.save_outputs(filepath_md=self.solve.path_md,\n                                     name=f\"guess_{self.num_of_guess}_brainstorm\",\n                                     responses=brainstorm_responses\n                                     )\n        return brainstorm_responses\n\n    def do_discern(self, brainstorm_responses):\n        \"\"\"Discern the best guesses from the brainstorming responses.\"\"\"\n        self.discern = Discern(self, brainstorm_responses)\n        self.discern.extract_all()\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_extract\",\n                                  responses=self.discern.extract_responses\n                                  )\n        self.discern.discern_guess_all()\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_discern\",\n                                  responses=self.discern.discern_responses\n                                  )\n\n    def do_decide(self):\n        \"\"\"Decide if there are good options for the guess.\"\"\"\n        self.discern.decide_all()\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_decide_cot\",\n                                  responses=self.discern.decide_cot_responses\n                                  )\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_decide_yn\",\n                                  responses=self.discern.decide_yn_responses\n                                  )\n\n    def do_select(self):\n        \"\"\"Select the guess from the discerning process.\"\"\"\n        if self.discern.select_and_validate_all() is True:\n            self.guess_is_valid = True\n        else:\n            self.guess_is_valid = False\n        self.discern.save_outputs(filepath_md=self.solve.path_md,\n                                  name=f\"guess_{self.num_of_guess}_discern_select\",\n                                  responses=self.discern.select_responses\n                                  )\n"}
{"type": "source_file", "path": "src/experiment_4o.py", "content": "\"\"\"Experiment4o class oversees the process for Experiment #1 with GPT-4o for Vanilla, CoT, CoT (Scripted), and Actor approaches.\"\"\"\nimport logging\nimport os\nimport re\nimport copy\nimport time\nimport random\nimport json\nimport numpy as np\nimport pandas as pd\nimport openpyxl\nimport matplotlib.pyplot as plt\nimport emoji\n\nfrom src.utils_llm import (\n    LLMSettings,\n    llm_call\n)\n\nfrom src.baseclass import BaseClass\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.get_puzzle_info import extract_puzzle_data_from_url\n\nfrom src.puzzle_4o import Puzzle\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass Experiment4o(BaseClass):\n    \"\"\"Experiment4o class oversees the whole experiment process.\"\"\"\n\n    def __init__(self,\n                 puzzle_numbers: list,\n                 llm_settings: LLMSettings = LLMSettings(),\n                 model: str = None\n    ):\n        self.puzzle_numbers = puzzle_numbers\n        self.puzzles = {}\n        self.llm_settings = llm_settings\n        if model is not None:\n            self.llm_settings.model = model\n        # Dictionary of the results of the experiment\n        self.results_dict = None\n        # Numpy array of the results of the experiment\n        self.results_array = None\n        # Pandas DataFrame of the results of the experiment\n        self.results_df = None\n        # Filepath to save data from this experiment\n        self.path = \"\"\n        self.path_pkl = \"\"\n        self.path_export = \"\"\n    \n    def set_path(self, name: str = None, date: str = None):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        # If name and date are not passed, use the default directory.\n        if name is None and date is None:\n            date = get_date()\n            self.path = os.path.join(\n                get_root_dir(), \"outputs\", date\n            )\n        # If a directory is passed, use that directory.\n        else:\n            # If date is not passed, use the current date.\n            if date is None:\n                date = get_date()\n            # If name is not passed, use an underscore.\n            if name is None:\n                name = \"_\"\n            self.path = os.path.join(get_root_dir(), \"outputs\", date, name)\n        # Create the directory if it does not exist.\n        os.makedirs(self.path, exist_ok=True)\n        # Set the path for saving data to pkl file.\n        self.path_pkl = os.path.join(self.path, \"experiment_4o_pkl\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_pkl, exist_ok=True)\n        # Set the path for saving data exports.\n        self.path_export = os.path.join(self.path, \"experiment_4o_export\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_export, exist_ok=True)\n    \n    def set_llm_settings(\n        self,\n        embeddings: str = None,\n        model: str = None,\n        max_tokens: int = None,\n        model_long: str = None,\n        max_tokens_long: int = None,\n        model_cheap: str = None,\n        max_tokens_cheap: int = None,\n        chunk_size: int = None,\n        chunk_overlap: int = None,\n        chunk_size_long: int = None,\n        max_attempts: int = None,\n        temperature: int = None,\n        response_format: str = None\n    ):\n        \"\"\"Set the LLM settings.\n        With this function, only the settings that you want to change need to be passed.\n        \"\"\"\n        self.llm_settings.embeddings = embeddings if embeddings else self.llm_settings.embeddings\n        self.llm_settings.model = model if model else self.llm_settings.model\n        self.llm_settings.max_tokens = max_tokens if max_tokens else self.llm_settings.max_tokens\n        self.llm_settings.model_long = model_long if model_long else self.llm_settings.model_long\n        self.llm_settings.max_tokens_long = max_tokens_long if max_tokens_long else self.llm_settings.max_tokens_long\n        self.llm_settings.model_cheap = model_cheap if model_cheap else self.llm_settings.model_cheap\n        self.llm_settings.max_tokens_cheap = max_tokens_cheap if max_tokens_cheap else self.llm_settings.max_tokens_cheap\n        self.llm_settings.chunk_size = chunk_size if chunk_size else self.llm_settings.chunk_size\n        self.llm_settings.chunk_overlap = chunk_overlap if chunk_overlap else self.llm_settings.chunk_overlap\n        self.llm_settings.chunk_size_long = chunk_size_long if chunk_size_long else self.llm_settings.chunk_size_long\n        self.llm_settings.max_attempts = max_attempts if max_attempts else self.llm_settings.max_attempts\n        self.llm_settings.temperature = temperature if temperature else self.llm_settings.temperature\n        self.llm_settings.response_format = response_format if response_format else self.llm_settings.response_format\n\n    def set_puzzles(self):\n        \"\"\"Set the puzzles for the experiment.\"\"\"\n        self.puzzles = {}  # Initialize an empty dictionary\n        for number in self.puzzle_numbers:  # Iterate over each puzzle number\n            logger.info(\"Getting puzzle information for puzzle %s\", number)\n            url = f\"https://connections.swellgarfo.com/nyt/{number}\"  # Construct the URL for the puzzle\n            puzzle_str, number, solution_lst = extract_puzzle_data_from_url(url)  # Extract puzzle data from the URL\n            path = os.path.join(self.path, str(number))  # Create a directory for the puzzle\n            # Create a new Puzzle object\n            puzzle = Puzzle(\n                words_str=puzzle_str, \n                number=number,\n                solution_lst=solution_lst, \n                llm_settings=self.llm_settings, \n                model=self.llm_settings.model,\n                path=path\n            )\n            # Add the puzzle to the dictionary of puzzles\n            self.puzzles[number] = puzzle  \n            logger.info(\"Puzzle %s added to the experiment.\", number)\n            self.puzzles[number].setup_puzzle()\n    \n    def set_new_puzzles(self, puzzle_numbers: list):\n        \"\"\"Set new puzzles for the experiment.\"\"\"\n        # Add the new puzzle numbers to the existing list of puzzle numbers\n        self.puzzle_numbers.extend(puzzle_numbers)\n        # Set the new puzzles\n        for number in self.puzzle_numbers:\n            if number not in self.puzzles:\n                logger.info(\"Getting puzzle information for puzzle %s\", number)\n                url = f\"https://connections.swellgarfo.com/nyt/{number}\"\n                puzzle_str, number, solution_lst = extract_puzzle_data_from_url(url)\n                path = os.path.join(self.path, str(number))\n                puzzle = Puzzle(\n                    words_str=puzzle_str, \n                    number=number,\n                    solution_lst=solution_lst, \n                    llm_settings=self.llm_settings, \n                    model=self.llm_settings.model,\n                    path=path\n                )\n                self.puzzles[number] = puzzle\n                logger.info(\"Puzzle %s added to the experiment.\", number)\n                self.puzzles[number].setup_puzzle()\n    \n    def solve_puzzle(self, number: int):\n        \"\"\"Solve a single puzzle.\"\"\"\n        self.puzzles[number].solve_all()\n        \n    def solve_puzzle_all(self):\n        \"\"\"Solve all puzzles in the experiment.\"\"\"\n        for number, puzzle in self.puzzles.items():\n            logger.info(\"Solving puzzle %s\", number)\n            puzzle.solve_all()\n            timestamp = get_timestamp()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                    name=f\"experiment_{timestamp}\")\n            \n    def solve_unfinished_puzzles(self):\n        \"\"\"Solve all unfinished puzzles in the experiment.\"\"\"\n        for number, puzzle in self.puzzles.items():\n            logger.info(\"Solving puzzle %s\", number)\n            puzzle.solve_unfinished()\n            timestamp = get_timestamp()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                    name=f\"experiment_{timestamp}\")\n\n    def save_results_dict(self):\n        \"\"\"Save the results of the experiment to a dictionary.\"\"\"\n        self.results_dict = {}\n        for number, puzzle in self.puzzles.items():\n            if puzzle.results_dict:\n                self.results_dict[number] = puzzle.results_dict\n            else:\n                logger.warning(\"Puzzle %s has no results.\", number)\n                self.results_dict[number] = {}\n    \n    def save_results_dict_to_json(self):\n        \"\"\"Save the results of the experiment to a JSON file.\"\"\"\n        timestamp = get_timestamp()\n        filepath = os.path.join(self.path_export, f\"results_{timestamp}.json\")\n        with open(filepath, \"w\") as f:\n            json.dump(self.results_dict, f, indent=4)\n    \n    def save_results_df(self):\n        \"\"\"Save the results of the experiment to a pandas DataFrame.\"\"\"\n        data = []\n        for number, puzzle in self.puzzles.items():\n            row = {'puzzle_number': number}\n            \n            for result_type in ['vanilla', 'cot', 'cot_scripted', 'actor']:\n                result = puzzle.results_dict.get(result_type, {})\n        \n                # Add the values to the row, with keys indicating the result type\n                row[f'{result_type}_success'] = result.get('success', None)\n                row[f'{result_type}_good_guesses'] = result.get('good_guesses', None)\n                row[f'{result_type}_bad_guesses'] = result.get('bad_guesses', None)\n                row[f'{result_type}_guesses_submitted'] = result.get('guesses_submitted', None)\n    \n            data.append(row)\n\n        # Convert the list of dictionaries to a DataFrame\n        self.results_df = pd.DataFrame(data)\n        timestamp = get_timestamp()\n        self.results_df.to_excel(os.path.join(self.path_export, f\"experiment_4o_results{timestamp}.xlsx\"), index=False)\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"experiment_4o\")\n\n    \n    def run_experiment(self, numbers: list):\n        \"\"\"Run the experiment.\"\"\"\n        self.set_path()\n        self.set_puzzles()\n        self.setup_puzzles()\n        self.solve_puzzle_all()\n        self.save_results_dict()\n        self.save_results_dict_to_json()\n        self.save_results_df()\n    \n    def finish_experiment(self):\n        \"\"\"Finish the experiment.\"\"\"\n        self.solve_unfinished_puzzles()\n        self.save_results_dict()\n        self.save_results_dict_to_json()\n        self.save_results_df()\n"}
{"type": "source_file", "path": "src/brainstorm_actor_o1.py", "content": "\"\"\"\nBrainstormo1 class for brainstorming possible solutions to the puzzle under Actor-o1 approach.\n\"\"\"\nimport os\nimport logging\nimport random\n\nfrom src.baseclass import BaseClass\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.utils_llm import (\n    llm_call\n)\n\nfrom src.utils_string import get_timestamp\n\n# Set up logger\nlogger = logging.getLogger('connections')\n\n\nclass Brainstormo1(BaseClass):\n    \"\"\"Class for generating brainstorming solutions using the Actor-o1 approach.\n    \n    This class provides methods to generate solutions by interacting with an LLM,\n    using specific prompts tailored to the Actor-o1 framework.\n    \"\"\"\n\n    def __init__(\n        self,\n        guess\n    ):\n        \"\"\"\n        Initialize Brainstormo1 with a guess and related puzzle data.\n\n        Args:\n            guess: An instance representing the current puzzle guess, including \n                   information about the puzzle and its potential solutions.\n        \"\"\"\n        self.guess = guess\n        self.puzzle = guess.puzzle\n        self.solve = guess.solve\n\n        # Brainstorming responses and outputs\n        self.brainstorm_responses = []\n        self.brainstorm_outputs = []\n        # LLM settings for brainstorming\n        self.llm_settings = self.puzzle.llm_settings\n\n    def set_llm_temperature(self, temperature=0.0):\n        \"\"\"\n        Set the temperature for the LLM to adjust the randmoness/creativity of responses.\n\n        Args:\n            temperature (float): Temperature setting for the LLM, controlling response randomness.\n        \"\"\"\n        self.llm_settings.temperature = temperature\n        logger.info(\"Setting LLM temperature to %s for brainstorming.\",\n                    self.llm_settings.temperature)\n\n    def brainstorm(self):\n        \"\"\"\n        Generate a single brainstorming response by asking the LLM for a possible solution.\n\n        Returns:\n            dict: The LLM response containing generated content and metadata.\n        \"\"\"\n        # Select a random system prompt file for brainstorming\n        random_num = random.randint(0, 2)\n        brainstorm_str = f\"brainstorm_{random_num}.txt\"\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_o1', brainstorm_str),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Add any previous incorrect guesses to the system prompt\n        bad_guesses_str = self.guess.set_bad_guesses_str()\n        if len(bad_guesses_str) > 0:\n            # Add text to end of bad_guesses_str\n            bad_guesses_str += \"\\n \\n You should reject any guess that has the same four words as a guess that we already know is incorrect. \\n\"            \n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Convert system prompt to a user prompt (specific to Actor-o1) and add remaining words\n        prompt_user = prompt_system\n        words_remain_shuffled = self.solve.temp_words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user += f\"\\n \\n List of words in puzzle: {words_remain_str}\"\n        \n        # Set up the prompts for the LLM\n        prompts = [\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM and return the response\n        llm_response = llm_call(\n            model='o1-preview', prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def brainstorm_all(self):\n        \"\"\"\n        Generate multiple brainstorming responses using the current template.\n\n        Returns:\n            list: List of all LLM responses generated in the brainstorming session.\n        \"\"\"\n        self.brainstorm_responses = []\n        self.brainstorm_outputs = []\n        response = self.brainstorm()\n        self.brainstorm_responses.append(response)\n        self.brainstorm_outputs.append(response.output)\n        return self.brainstorm_responses\n"}
{"type": "source_file", "path": "src/solve.py", "content": "\"\"\"Base class for solve classes in the project.\n\"\"\"\n\nimport logging\nimport os\nimport re\nimport emoji\n\n\nfrom src.baseclass import BaseClass\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass BaseSolver(BaseClass):\n    \"\"\"Base class for solve classes in the project.\n    \"\"\"\n\n    def __init__(self\n    ):\n        super().__init__()  # Call the constructor of BaseClass\n        self.puzzle = None\n        # Words that remain to be solved\n        self.words_remain_lst = []\n        # Words that are solved\n        self.words_solved_lst = []\n        # Current guess instance\n        self.current_guess = None\n        # Guesses that have been processed by the solve instance\n        self.guesses_processed = []\n        # Guesses that are ready to be submitted\n        self.guesses_ready_to_submit = []\n        # Guesses that have been submitted by the solve instance\n        self.guesses_submitted = []\n        # Good guesses (full guess object)\n        self.good_guesses = []\n        # Good guesses (just the words, not the full guess object)\n        self.good_guesses_lst = []\n        # Bad guesses (full guess object)\n        self.bad_guesses = []\n        # Bad guesses (just the words, not the full guess object)\n        self.bad_guesses_lst = []\n        # End game\n        self.end_game = False\n        # Success\n        self.success = False\n        # Time to solve the puzzle\n        self.solve_time = 0\n        # Results dictionary\n        self.results_dict = None\n\n        # Filepath for saving data from this solve attempt\n        self.path = \"\"\n        self.path_md = \"\"\n        self.path_pkl = \"\"\n\n    def set_path(self, name: str = None):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        self.path = os.path.join(self.puzzle.path, name)\n        # Create the directory if it does not exist.\n        os.makedirs(self.path, exist_ok=True)\n        # Set the path for saving data to pkl file.\n        self.path_pkl = os.path.join(self.path, \"pkl\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_pkl, exist_ok=True)\n        # Set the path for saving data to markdown file.\n        self.path_md = os.path.join(self.path, \"md\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_md, exist_ok=True)\n\n    def check_end_game_conditions(self):\n        \"\"\"See if end game conditions are met.\"\"\"\n        # If the number of bad guesses is greater than the maximum number of bad guesses allowed,\n        # end the game\n        if len(self.bad_guesses_lst) >= self.puzzle.num_bad_guesses:\n            logger.info(\"Ending game. Too many bad guesses.\")\n            self.end_game = True\n            self.success = False\n        # If the number of good guesses is equal to 4\n        if len(self.good_guesses_lst) >= 4:\n            logger.info(\n                \"Ending game. All parts of the solution have been guessed.\")\n            self.end_game = True\n            self.success = True  \n\n    def save_results_dict(self):\n        \"\"\"Save the results of the solve to a dictionary.\"\"\"\n        self.results_dict = {\n            \"success\": self.success,\n            \"good_guesses\": len(self.good_guesses_lst),\n            \"bad_guesses\": len(self.bad_guesses_lst),\n            \"guesses_submitted\": len(self.guesses_submitted),\n            \"solve_time\": self.solve_time,\n        }\n\n    def save_summary(self):\n        \"\"\"Save a summary of the results as a markdown file.\"\"\"\n        timestamp = get_timestamp()\n        filename = f\"summary_puzzle{self.puzzle.number}_{self.puzzle.llm_settings.model}_{timestamp}.md\"\n        filepath = os.path.join(self.path_md, filename)\n        with open(\n            filepath,\n            'w', encoding='utf-8'\n        ) as f:\n            f.write(f\"# Summary of Puzzle {self.puzzle.number}\\n\\n\")\n            f.write(f\"Date: {get_date()}\\n\")\n            f.write(f\"Model: {self.puzzle.llm_settings.model}\\n\")\n            minutes, seconds = divmod(self.solve_time, 60)\n\n            if self.puzzle.emoji_dict is not None:\n                f.write(\"\\n\")\n                for guess in self.guesses_submitted:\n                    for word in guess.guess_lst:\n                        square_emoji = self.puzzle.emoji_dict.get(\n                            word, (emoji.emojize(':red_question_mark:')))\n                        f.write(f\"{square_emoji}\")\n                    f.write(\"\\n\")\n            if self.success is True:\n                f.write(\"## Success!\\n\\n\")\n                f.write(\n                    f\"Solved in {int(minutes)} minutes and {int(seconds)} seconds \\n\\n\")\n            else:\n                f.write(\"## Failure!\\n\\n\")\n                f.write(\n                    f\"Wasted {int(minutes)} minutes and {int(seconds)} seconds on this dumb puzzle.\\n\\n\")\n            num_good_guesses = len(self.good_guesses_lst)\n            num_bad_guesses = len(self.bad_guesses_lst)\n            f.write(f\"Correct guesses: {num_good_guesses}\\n\")\n            f.write(f\"Incorrect guesses: {num_bad_guesses}\\n\\n\")\n            f.write(\"## Submitted Guesses\\n\\n\")\n            for guess in self.guesses_submitted:\n                f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                if guess.guess_is_correct:\n                    f.write(\"Correct: \")\n                else:\n                    f.write(\"Incorrect: \")\n                guess_str = \" \".join(guess.guess_lst)\n                f.write(f\"{guess_str}\\n\\n\")\n            f.write(\"## Solution\\n\\n\")\n            for solution in self.puzzle.solution_lst:\n                # Turn the solution into a string\n                solution_str = \" \".join(solution)\n                f.write(f\"{solution_str}\\n\\n\")\n            f.write(\"## Submitted Guesses Play-By-Play\\n\\n\")\n            for guess in self.guesses_submitted:\n                f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                if guess.guess_is_correct:\n                    f.write(\"Correct: \")\n                else:\n                    f.write(\"Incorrect: \")\n                guess_str = \" \".join(guess.guess_lst)\n                f.write(f\"{guess_str}\\n\\n\")\n                f.write(\"Reasoning:\\n\")\n                reasoning = \"\"\n                if len(guess.guess_rationale) > 0:\n                    reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                    # Modify reasoning string so that all \"# \" are \"## \"\n                    reasoning = re.sub(\n                        r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                    f.write(f\"{reasoning}\")\n                elif guess == self.guesses_submitted[-1] and self.success:\n                    f.write(\n                        \"(Automatically chosen by application because it was the only option left.).\\n\\n\")\n            if len(self.guesses_processed) > len(self.guesses_submitted):\n                f.write(\"## All Guesses Play-By-Play\\n\\n\")\n                for guess in self.guesses_processed:\n                    guess_str = \" \".join(guess.guess_lst)\n                    f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                    if guess.guess_was_submitted:\n                        if guess.guess_is_correct:\n                            f.write(\"Submitted and Correct: \")\n                        else:\n                            f.write(\"Submitted and Incorrect: \")\n                        guess_str = \" \".join(guess.guess_lst)\n                        f.write(f\"Guess: {guess_str}\\n\\n\")\n                        f.write(\"Reasoning:\\n\")\n                        reasoning = \"\"\n                        if len(guess.guess_rationale) > 0:\n                            reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                            # Modify reasoning string so that all \"# \" are \"## \"\n                            reasoning = re.sub(\n                                r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                            f.write(f\"{reasoning}\")\n                        elif guess == self.guesses_submitted[-1] and self.success:\n                            f.write(\n                                \"(Automatically chosen by application because it was the only option left.).\\n\\n\")\n                    elif len(guess.guess_rationale) > 0:\n                        f.write(f\"Guess: {guess_str}\\n\\n\")\n                        f.write(\"Reasoning:\\n\")\n                        reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                        # Modify reasoning string so that all \"# \" are \"## \"\n                        reasoning = re.sub(\n                            r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                        f.write(f\"{reasoning}\")\n                    elif guess.guess_is_valid is False:\n                        f.write(\n                            \"Rejected because guess has formatting or content error: \")\n                        guess_str = \" \".join(guess.guess_lst)\n                        f.write(f\"Guess: {guess_str}\\n\\n\")\n                    elif guess.good_options_for_guess is False:\n                        f.write(\"Rejected because no good options for guess: \")\n                        reasoning = \"\"\n                        for response in guess.discern.decide_cot_responses:\n                            reasoning += f\"{response.output}\\n\\n\"\n                        # Modify reasoning string so that all \"# \" are \"## \"\n                        reasoning = re.sub(\n                            r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                        f.write(f\"{reasoning}\")\n            logger.info(\"Saved summary to %s\", filepath)\n\n    def save_summary_no_solution(self):\n        \"\"\"Save a summary of the results as a markdown file.\"\"\"\n        timestamp = get_timestamp()\n        filename = f\"summary_puzzle{self.puzzle.number}_{self.puzzle.llm_settings.model}_{timestamp}.md\"\n        with open(\n            os.path.join(self.path_md, filename),\n            'w', encoding='utf-8'\n        ) as f:\n            f.write(f\"# Summary of Puzzle {self.puzzle.number}\\n\\n\")\n            f.write(f\"Date: {get_date()}\\n\")\n            f.write(f\"Model: {self.puzzle.llm_settings.model}\\n\")\n            minutes, seconds = divmod(self.solve_time, 60)\n            f.write(\n                f\"Took {int(minutes)} minutes and {int(seconds)} seconds \\n\\n\")\n\n            f.write(\"## Submitted Guesses\\n\\n\")\n            for guess in self.guesses_submitted:\n                f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                guess_str = \" \".join(guess.guess_lst)\n                f.write(f\"{guess_str}\\n\\n\")\n                f.write(\"No solution provided.\\n\\n\")\n\n    "}
{"type": "source_file", "path": "src/puzzle_o1.py", "content": "\"\"\"Puzzleo1 class is a composite class that manages the classes that solve the puzzle using GPT-o1 model.\n\"\"\"\nimport logging\nimport os\nimport emoji\nfrom src.utils_llm import (\n    LLMSettings,\n)\n\nfrom src.baseclass import BaseClass\nfrom src.solve_one_shot_o1 import SolveOneShoto1\nfrom src.solve_vanilla_o1 import SolveVanillao1\nfrom src.solve_actor_o1 import SolveActoro1\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\nclass Puzzleo1(BaseClass):\n    \"\"\"Puzzleo1 class is a composite class that manages the classes that solve the puzzle using GPT-o1 model.\n    \"\"\"\n\n    def __init__(self,\n                 words_str: str,\n                 number: int = 0000,\n                 solution_lst: list = None,\n                 llm_settings: LLMSettings = LLMSettings(),\n                 model: str = None,\n                 path = None\n                 ):\n        super().__init__()  # Call the constructor of BaseClass\n        # LLM settings for this instance (dataclass in utils_llm.py)\n        self.llm_settings = llm_settings\n        if model is not None:\n            self.llm_settings.model = model\n        # Puzzle data\n        # Raw string of the puzzle\n        self.words_str = words_str\n        # Number of the puzzle\n        self.number = number\n        # Puzzle string converted to a list of strings, each string representing a tile in the puzzle\n        self.words_lst = []\n        # Puzzle solution\n        self.solution_lst = solution_lst\n        # Dictionary of words to emojis\n        self.emoji_dict = None\n        self.num_bad_guesses = 4\n        # Dictionary of solve attempts\n        self.solve_attempts = {}\n\n        # Filepath for saving data from this puzzle\n        self.path = path\n        self.path_pkl = \"\"\n        \n        # Class instances\n        self.oneshoto1 = None\n        self.vanillao1 = None\n        self.actoro1 = None\n\n        \n        self.results_dict = {}\n\n    def set_path(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        # Create the directory if it does not exist.\n        os.makedirs(self.path, exist_ok=True)\n        # Set the path for saving data to pkl file.\n        self.path_pkl = os.path.join(self.path, \"pkl\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_pkl, exist_ok=True)\n\n    def clean_up_puzzle_text(self, words_lst: list):\n        \"\"\"Clean up a list of words for use in the puzzle.\"\"\"\n        # Remove any new line characters from each string in the list\n        words_lst = [x.replace(\"\\n\", \"\") for x in words_lst]\n        # Remove any punctuation from each string in the list\n        words_lst = [x.translate(str.maketrans(\n            \"\", \"\", \".,!?:\")) for x in words_lst]\n        # Remove leading and trailing whitespace from each string in the list\n        words_lst = [x.strip() for x in words_lst]\n        # Make all of the letters in all of the strings uppercase\n        words_lst = [x.upper() for x in words_lst]\n        # Remove any strings that are too short to be valid words\n        words_lst = [x for x in words_lst if len(x) >= 1]\n        return words_lst\n\n    def split_puzzle_text(self, words_str: str, num_items: int = 4, separator: str = None):\n        \"\"\"Takes a raw string of words, turns it into a list, and cleans it up for use in the puzzle.\"\"\"\n        # Split the raw string into a list of strings based on separator\n        words_lst = None\n        if separator:\n            words_lst = words_str.split(separator)\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                logger.warning(\"Based on provided separator, number of items in list is not %s. Number of items is %s. Trying other separators.\",\n                               num_items, len(words_lst))\n                words_lst = None\n        if words_lst is None:\n            # Otherwise split the string into a list of strings based on newline, then comma, then space\n            words_lst = words_str.split(\"\\n\")\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                words_lst = words_str.split(\",\")\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                words_lst = words_str.split(\" \")\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                logger.warning(\"Number of items in list is not %s. Number of items is %s.\",\n                               num_items, len(words_lst))\n        return words_lst\n\n    def load_puzzle(self):\n        \"\"\"Load the puzzle from the raw string.\"\"\"\n        self.words_lst = self.split_puzzle_text(self.words_str, num_items=16)\n        logger.info(\"Loaded puzzle with %s words.\\n%s\",\n                    len(self.words_lst), self.words_lst)\n        # Set the remaining words to be solved to the full list of words\n        self.words_remain_lst = self.words_lst\n        # Check to make sure length of list is 16.\n        if len(self.words_lst) != 16:\n            logger.error(\n                \"Puzzle must have exactly 16 words. Length is %s.\", len(self.words_lst))\n            raise ValueError(\"Puzzle must have exactly 16 words.\")\n\n    def set_solution(self, solution_lst=None):\n        \"\"\"Set the solution to the puzzle.\"\"\"\n        if solution_lst is not None:\n            self.solution_lst = solution_lst\n        if self.solution_lst is not None:\n            if len(self.solution_lst) != 4:\n                raise ValueError(\"Incorrect number of parts to the solution. It should be 4 but is %s\",\n                                 len(self.solution_lst))\n            # If the solution is not already a list of lists, split it into a list of lists\n            if not all(isinstance(i, list) for i in self.solution_lst):\n                for i, solution in enumerate(self.solution_lst):\n                    self.solution_lst[i] = self.split_puzzle_text(\n                        solution, num_items=4)\n                logger.info(\"Set solution to list of %s.\\n List is:\\n %s\",\n                            len(self.solution_lst), self.solution_lst)\n            # For each word in each item in the solution list, make sure it is in the words list\n            for solution in self.solution_lst:\n                for word in solution:\n                    if word not in self.words_lst:\n                        raise ValueError(\n                            \"Word in solution not found in words list: %s\", word)\n            logger.info(\"Each word in the solution is in the words list.\")\n        else:\n            logger.warning(\"No solution provided.\")\n\n    def set_emoji_dict(self):\n        \"\"\"Set the emoji dictionary for the puzzle.\"\"\"\n        self.emoji_dict = {}\n        if self.solution_lst is not None:\n            if len(self.solution_lst) != 4:\n                raise ValueError(\"Incorrect number of parts to the solution. It should be 4 but is %s\",\n                                 len(self.solution_lst))\n            for word in self.solution_lst[0]:\n                self.emoji_dict[word] = (emoji.emojize(\":yellow_square:\"))\n            for word in self.solution_lst[1]:\n                self.emoji_dict[word] = (emoji.emojize(\":green_square:\"))\n            for word in self.solution_lst[2]:\n                self.emoji_dict[word] = (emoji.emojize(\":blue_square:\"))\n            for word in self.solution_lst[3]:\n                self.emoji_dict[word] = (emoji.emojize(\":purple_square:\"))\n            logger.info(\"Emoji dictionary set for the puzzle.\")\n        else:\n            logger.warning(\"No solution provided. Emoji dictionary not set.\")\n\n    def setup_puzzle(self):\n        \"\"\"Set up the puzzle default filepath, default llm settings, load puzzle, and set solution.\"\"\"\n        self.set_path()\n        self.load_puzzle()\n        self.set_solution()\n        self.set_emoji_dict()\n        if self.llm_settings.model == 'gpt-4':\n            self.set_llm_settings(\n                max_tokens=6000, chunk_size=6000, chunk_overlap=500)\n            logger.info(\"LLM settings set for gpt-4 token capacity.\")\n        elif self.llm_settings.model == 'claude-3-opus-20240229':\n            self.set_llm_settings(\n                max_tokens=3500, chunk_size=3500, chunk_overlap=300)\n            logger.info(\n                \"LLM settings set for claude-3-opus-20240229 token capacity.\")\n    \n    def solve_oneshoto1(self):\n        \"\"\"Solve the puzzle using the oneshoto1 approach.\"\"\"\n        logger.info(\"Solving puzzle using One-Shot o1 approach\")\n        self.oneshoto1 = SolveOneShoto1(self)\n        self.oneshoto1.set_path_oneshoto1()\n        self.oneshoto1.solve_puzzle_oneshoto1()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n    \n    def solve_vanillao1(self):\n        \"\"\"Solve the puzzle using vanillao1 approach.\"\"\"\n        logger.info(\"Solving puzzle using Vanilla o1 approach\")\n        self.vanillao1 = SolveVanillao1(self)\n        self.vanillao1.set_path_vanillao1()\n        self.vanillao1.solve_puzzle_vanillao1()\n        self.results_dict['vanillao1'] = self.vanillao1.results_dict\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n    \n    def solve_actoro1(self):\n        \"\"\"Solve the puzzle using Actor-o1 approach.\"\"\"\n        logger.info(\"Solving puzzle using Actor-o1 approach\")\n        self.actoro1 = SolveActoro1(self)\n        self.actoro1.set_path_actoro1()\n        self.actoro1.solve_puzzle_actoro1()\n        self.results_dict['actoro1'] = self.actoro1.results_dict\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n    \n    def solve_all(self):\n        \"\"\"Solve the puzzle using all approaches.\"\"\"\n        self.solve_oneshoto1()\n        self.solve_vanillao1()\n        self.solve_actoro1()    \n    \n    def solve_unfinished(self):\n        \"\"\"Solve the puzzle for any approach that is not finished already.\"\"\"\n        if self.oneshoto1 is None or self.oneshoto1.end_game is False:\n            logger.info(\"# %s No One-Shot o1 solve exists. Solving puzzle using One-Shot o1 approach\", self.number)\n            self.solve_oneshoto1()\n        else:\n            logger.info(\"# %s One-Shot o1 solve is already finished. No need to redo.\", self.number)\n        if self.vanillao1 is None:\n            logger.info(\"# %s No Vanilla o1 solve exists. Solving puzzle using Vanilla o1 approach\", self.number)\n            self.solve_vanillao1()\n        elif self.vanillao1.end_game is False:\n            logger.info(\"# %s Vanilla o1 solve is not finished. Solving puzzle using Vanilla o1 approach\", self.number)\n            self.vanillao1.set_path_vanillao1()\n            self.vanillao1.llm_settings = self.llm_settings\n            self.vanillao1.puzzle.words_lst = self.words_lst\n            self.vanillao1.solve_puzzle_vanillao1()\n            self.results_dict['vanillao1'] = self.vanillao1.results_dict\n            self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n        else:\n            logger.info(\"# %s Vanilla o1 solve is already finished. No need to redo.\", self.number)\n        if self.actoro1 is None:\n            logger.info(\"# %s No Actor-o1 solve exists. Solving puzzle using Actor-o1 approach\", self.number)\n            self.solve_actoro1()\n        elif self.actoro1.end_game is False:\n            logger.info(\"# %s Actor-o1 solve is not finished. Solving puzzle using Actor-o1 approach\", self.number)\n            self.actoro1.set_path_actoro1()\n            self.actoro1.llm_settings = self.llm_settings\n            self.actoro1.puzzle.words_lst = self.words_lst\n            self.actoro1.solve_puzzle_actoro1()\n            self.results_dict['actoro1'] = self.actoro1.results_dict\n            self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n            \n            \n    def save_results(self):\n        \"\"\"Save the results of the puzzle to a dictionary.\"\"\"\n        self.results_dict = {}\n        if self.vanillao1 is not None:\n            self.results_dict['vanillao1'] = self.vanillao1.results_dict\n            logger.info(\"Vanilla-o1 results saved to dictionary.\")\n        if self.actoro1 is not None:\n            self.results_dict['actoro1'] = self.actoro1.results_dict\n            logger.info(\"Actor-o1 results saved to dictionary.\")\n"}
{"type": "source_file", "path": "src/puzzle_actor_2.py", "content": "\"\"\"PuzzleActor2 class is a composite class that manages the classes that solve the puzzle for Experiment #1 with GPT-4o for the Actor-2 approach.\n\"\"\"\nimport logging\nimport os\nimport emoji\nfrom src.utils_llm import (\n    LLMSettings,\n)\n\nfrom src.baseclass import BaseClass\nfrom src.solve_actor_2 import SolveActor2\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\nclass PuzzleActor2(BaseClass):\n    \"\"\"PuzzleActor2 class is a composite class that manages the classes that solve the puzzle for Experiment #1 with GPT-4o for the Actor-2 approach.\n    \"\"\"\n\n    def __init__(self,\n                 words_str: str,\n                 number: int = 0000,\n                 solution_lst: list = None,\n                 llm_settings: LLMSettings = LLMSettings(),\n                 model: str = None,\n                 path = None\n                 ):\n        super().__init__()  # Call the constructor of BaseClass\n        # LLM settings for this instance (dataclass in utils_llm.py)\n        self.llm_settings = llm_settings\n        if model is not None:\n            self.llm_settings.model = model\n        # Puzzle data\n        # Raw string of the puzzle\n        self.words_str = words_str\n        # Number of the puzzle\n        self.number = number\n        # Puzzle string converted to a list of strings, each string representing a tile in the puzzle\n        self.words_lst = []\n        # Puzzle solution\n        self.solution_lst = solution_lst\n        # Dictionary of words to emojis\n        self.emoji_dict = None\n        self.num_bad_guesses = 4\n        # Dictionary of solve attempts\n        self.solve_attempts = {}\n\n        # Filepath for saving data from this puzzle\n        self.path = path\n        self.path_pkl = \"\"\n        \n        # Class instances\n        self.actor_2 = None\n        \n        self.results_dict = {}\n\n    def set_path(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        # Create the directory if it does not exist.\n        os.makedirs(self.path, exist_ok=True)\n        # Set the path for saving data to pkl file.\n        self.path_pkl = os.path.join(self.path, \"pkl\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_pkl, exist_ok=True)\n\n    def clean_up_puzzle_text(self, words_lst: list):\n        \"\"\"Clean up a list of words for use in the puzzle.\"\"\"\n        # Remove any new line characters from each string in the list\n        words_lst = [x.replace(\"\\n\", \"\") for x in words_lst]\n        # Remove any punctuation from each string in the list\n        words_lst = [x.translate(str.maketrans(\n            \"\", \"\", \".,!?:\")) for x in words_lst]\n        # Remove leading and trailing whitespace from each string in the list\n        words_lst = [x.strip() for x in words_lst]\n        # Make all of the letters in all of the strings uppercase\n        words_lst = [x.upper() for x in words_lst]\n        # Remove any strings that are too short to be valid words\n        words_lst = [x for x in words_lst if len(x) >= 1]\n        return words_lst\n\n    def split_puzzle_text(self, words_str: str, num_items: int = 4, separator: str = None):\n        \"\"\"Takes a raw string of words, turns it into a list, and cleans it up for use in the puzzle.\"\"\"\n        # Split the raw string into a list of strings based on separator\n        words_lst = None\n        if separator:\n            words_lst = words_str.split(separator)\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                logger.warning(\"Based on provided separator, number of items in list is not %s. Number of items is %s. Trying other separators.\",\n                               num_items, len(words_lst))\n                words_lst = None\n        if words_lst is None:\n            # Otherwise split the string into a list of strings based on newline, then comma, then space\n            words_lst = words_str.split(\"\\n\")\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                words_lst = words_str.split(\",\")\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                words_lst = words_str.split(\" \")\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                logger.warning(\"Number of items in list is not %s. Number of items is %s.\",\n                               num_items, len(words_lst))\n        return words_lst\n\n    def load_puzzle(self):\n        \"\"\"Load the puzzle from the raw string.\"\"\"\n        self.words_lst = self.split_puzzle_text(self.words_str, num_items=16)\n        logger.info(\"Loaded puzzle with %s words.\\n%s\",\n                    len(self.words_lst), self.words_lst)\n        # Set the remaining words to be solved to the full list of words\n        self.words_remain_lst = self.words_lst\n        # Check to make sure length of list is 16.\n        if len(self.words_lst) != 16:\n            logger.error(\n                \"Puzzle must have exactly 16 words. Length is %s.\", len(self.words_lst))\n            raise ValueError(\"Puzzle must have exactly 16 words.\")\n\n    def set_solution(self, solution_lst=None):\n        \"\"\"Set the solution to the puzzle.\"\"\"\n        if solution_lst is not None:\n            self.solution_lst = solution_lst\n        if self.solution_lst is not None:\n            if len(self.solution_lst) != 4:\n                raise ValueError(\"Incorrect number of parts to the solution. It should be 4 but is %s\",\n                                 len(self.solution_lst))\n            # If the solution is not already a list of lists, split it into a list of lists\n            if not all(isinstance(i, list) for i in self.solution_lst):\n                for i, solution in enumerate(self.solution_lst):\n                    self.solution_lst[i] = self.split_puzzle_text(\n                        solution, num_items=4)\n                logger.info(\"Set solution to list of %s.\\n List is:\\n %s\",\n                            len(self.solution_lst), self.solution_lst)\n            # For each word in each item in the solution list, make sure it is in the words list\n            for solution in self.solution_lst:\n                for word in solution:\n                    if word not in self.words_lst:\n                        raise ValueError(\n                            \"Word in solution not found in words list: %s\", word)\n            logger.info(\"Each word in the solution is in the words list.\")\n        else:\n            logger.warning(\"No solution provided.\")\n\n    def set_emoji_dict(self):\n        \"\"\"Set the emoji dictionary for the puzzle.\"\"\"\n        self.emoji_dict = {}\n        if self.solution_lst is not None:\n            if len(self.solution_lst) != 4:\n                raise ValueError(\"Incorrect number of parts to the solution. It should be 4 but is %s\",\n                                 len(self.solution_lst))\n            for word in self.solution_lst[0]:\n                self.emoji_dict[word] = (emoji.emojize(\":yellow_square:\"))\n            for word in self.solution_lst[1]:\n                self.emoji_dict[word] = (emoji.emojize(\":green_square:\"))\n            for word in self.solution_lst[2]:\n                self.emoji_dict[word] = (emoji.emojize(\":blue_square:\"))\n            for word in self.solution_lst[3]:\n                self.emoji_dict[word] = (emoji.emojize(\":purple_square:\"))\n            logger.info(\"Emoji dictionary set for the puzzle.\")\n        else:\n            logger.warning(\"No solution provided. Emoji dictionary not set.\")\n\n    def setup_puzzle(self):\n        \"\"\"Set up the puzzle default filepath, default llm settings, load puzzle, and set solution.\"\"\"\n        self.set_path()\n        self.load_puzzle()\n        self.set_solution()\n        self.set_emoji_dict()\n        if self.llm_settings.model == 'gpt-4':\n            self.set_llm_settings(\n                max_tokens=6000, chunk_size=6000, chunk_overlap=500)\n            logger.info(\"LLM settings set for gpt-4 token capacity.\")\n        elif self.llm_settings.model == 'claude-3-opus-20240229':\n            self.set_llm_settings(\n                max_tokens=3500, chunk_size=3500, chunk_overlap=300)\n            logger.info(\n                \"LLM settings set for claude-3-opus-20240229 token capacity.\")\n               \n    def solve_actor_2(self):\n        \"\"\"Solve the puzzle using actor_2 approach.\"\"\"\n        logger.info(\"Solving puzzle using Actor-2 approach\")\n        self.actor_2 = SolveActor2(self)\n        self.actor_2.set_path_actor_2()\n        self.actor_2.solve_puzzle_actor_2()\n        self.results_dict['actor_2'] = self.actor_2.results_dict\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n    \n    def solve_all(self):\n        \"\"\"Solve the puzzle using all approaches.\"\"\"\n        self.solve_actor_2()    \n    \n    def solve_unfinished(self):\n        \"\"\"Solve the puzzle for any approach that is not finished already.\"\"\"\n            \n        if self.actor_2 is None:\n            logger.info(\"# %s No Actor-2 solve exists. Solving puzzle using Actor-2 approach\", self.number)\n            self.solve_actor_2()\n        elif self.actor_2.end_game is False:\n            logger.info(\"# %s Actor-2 solve is not finished. Solving puzzle using Actor-2 approach\", self.number)\n            self.actor_2.set_path_actor_2()\n            self.actor_2.llm_settings = self.llm_settings\n            self.actor_2.puzzle.words_lst = self.words_lst\n            self.actor_2.solve_puzzle_actor_2()\n            self.results_dict['actor_2'] = self.actor_2.results_dict\n            self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n        else:\n            logger.info(\"# %s Actor-2 solve is already finished. No need to redo.\", self.number)\n            \n    def save_results(self):\n        \"\"\"Save the results of the puzzle to a dictionary.\"\"\"\n        self.results_dict = {}\n        if self.actor_2 is not None:\n            self.results_dict['actor_2'] = self.actor_2.results_dict\n        logger.info(\"Results saved to dictionary.\")\n"}
{"type": "source_file", "path": "src/puzzle_4o.py", "content": "\"\"\"Puzzle class is a composite class that manages the classes that solve the puzzle for Experiment #1 with GPT-4o for Vanilla, CoT, CoT (Scripted), and Actor approaches.\n\"\"\"\nimport logging\nimport os\nimport emoji\nfrom src.utils_llm import (\n    LLMSettings,\n)\n\nfrom src.baseclass import BaseClass\nfrom src.solve_vanilla import SolveVanilla\nfrom src.solve_cot import SolveCot\nfrom src.solve_actor import SolveActor\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\nclass Puzzle(BaseClass):\n    \"\"\"Puzzle class is a composite class that manages the classes that solve the puzzle for Experiment #1 with GPT-4o for Vanilla, CoT, CoT (Scripted), and Actor approaches.\n    \"\"\"\n\n    def __init__(self,\n                 words_str: str,\n                 number: int = 0000,\n                 solution_lst: list = None,\n                 llm_settings: LLMSettings = LLMSettings(),\n                 model: str = None,\n                 path = None\n                 ):\n        super().__init__()  # Call the constructor of BaseClass\n        # LLM settings for this instance (dataclass in utils_llm.py)\n        self.llm_settings = llm_settings\n        if model is not None:\n            self.llm_settings.model = model\n        # Puzzle data\n        # Raw string of the puzzle\n        self.words_str = words_str\n        # Number of the puzzle\n        self.number = number\n        # Puzzle string converted to a list of strings, each string representing a tile in the puzzle\n        self.words_lst = []\n        # Puzzle solution\n        self.solution_lst = solution_lst\n        # Dictionary of words to emojis\n        self.emoji_dict = None\n        self.num_bad_guesses = 4\n        # Dictionary of solve attempts\n        self.solve_attempts = {}\n\n        # Filepath for saving data from this puzzle\n        self.path = path\n        self.path_pkl = \"\"\n        \n        # Class instances\n        self.vanilla = None\n        self.cot = None\n        self.cot_scripted = None\n        self.actor = None\n        \n        self.results_dict = {}\n\n    def set_path(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        # Create the directory if it does not exist.\n        os.makedirs(self.path, exist_ok=True)\n        # Set the path for saving data to pkl file.\n        self.path_pkl = os.path.join(self.path, \"pkl\")\n        # Create the directory if it does not exist.\n        os.makedirs(self.path_pkl, exist_ok=True)\n\n    def clean_up_puzzle_text(self, words_lst: list):\n        \"\"\"Clean up a list of words for use in the puzzle.\"\"\"\n        # Remove any new line characters from each string in the list\n        words_lst = [x.replace(\"\\n\", \"\") for x in words_lst]\n        # Remove any punctuation from each string in the list\n        words_lst = [x.translate(str.maketrans(\n            \"\", \"\", \".,!?:\")) for x in words_lst]\n        # Remove leading and trailing whitespace from each string in the list\n        words_lst = [x.strip() for x in words_lst]\n        # Make all of the letters in all of the strings uppercase\n        words_lst = [x.upper() for x in words_lst]\n        # Remove any strings that are too short to be valid words\n        words_lst = [x for x in words_lst if len(x) >= 1]\n        return words_lst\n\n    def split_puzzle_text(self, words_str: str, num_items: int = 4, separator: str = None):\n        \"\"\"Takes a raw string of words, turns it into a list, and cleans it up for use in the puzzle.\"\"\"\n        # Split the raw string into a list of strings based on separator\n        words_lst = None\n        if separator:\n            words_lst = words_str.split(separator)\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                logger.warning(\"Based on provided separator, number of items in list is not %s. Number of items is %s. Trying other separators.\",\n                               num_items, len(words_lst))\n                words_lst = None\n        if words_lst is None:\n            # Otherwise split the string into a list of strings based on newline, then comma, then space\n            words_lst = words_str.split(\"\\n\")\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                words_lst = words_str.split(\",\")\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                words_lst = words_str.split(\" \")\n            words_lst = self.clean_up_puzzle_text(words_lst)\n            if len(words_lst) != num_items:\n                logger.warning(\"Number of items in list is not %s. Number of items is %s.\",\n                               num_items, len(words_lst))\n        return words_lst\n\n    def load_puzzle(self):\n        \"\"\"Load the puzzle from the raw string.\"\"\"\n        self.words_lst = self.split_puzzle_text(self.words_str, num_items=16)\n        logger.info(\"Loaded puzzle with %s words.\\n%s\",\n                    len(self.words_lst), self.words_lst)\n        # Set the remaining words to be solved to the full list of words\n        self.words_remain_lst = self.words_lst\n        # Check to make sure length of list is 16.\n        if len(self.words_lst) != 16:\n            logger.error(\n                \"Puzzle must have exactly 16 words. Length is %s.\", len(self.words_lst))\n            raise ValueError(\"Puzzle must have exactly 16 words.\")\n\n    def set_solution(self, solution_lst=None):\n        \"\"\"Set the solution to the puzzle.\"\"\"\n        if solution_lst is not None:\n            self.solution_lst = solution_lst\n        if self.solution_lst is not None:\n            if len(self.solution_lst) != 4:\n                raise ValueError(\"Incorrect number of parts to the solution. It should be 4 but is %s\",\n                                 len(self.solution_lst))\n            # If the solution is not already a list of lists, split it into a list of lists\n            if not all(isinstance(i, list) for i in self.solution_lst):\n                for i, solution in enumerate(self.solution_lst):\n                    self.solution_lst[i] = self.split_puzzle_text(\n                        solution, num_items=4)\n                logger.info(\"Set solution to list of %s.\\n List is:\\n %s\",\n                            len(self.solution_lst), self.solution_lst)\n            # For each word in each item in the solution list, make sure it is in the words list\n            for solution in self.solution_lst:\n                for word in solution:\n                    if word not in self.words_lst:\n                        raise ValueError(\n                            \"Word in solution not found in words list: %s\", word)\n            logger.info(\"Each word in the solution is in the words list.\")\n        else:\n            logger.warning(\"No solution provided.\")\n\n    def set_emoji_dict(self):\n        \"\"\"Set the emoji dictionary for the puzzle.\"\"\"\n        self.emoji_dict = {}\n        if self.solution_lst is not None:\n            if len(self.solution_lst) != 4:\n                raise ValueError(\"Incorrect number of parts to the solution. It should be 4 but is %s\",\n                                 len(self.solution_lst))\n            for word in self.solution_lst[0]:\n                self.emoji_dict[word] = (emoji.emojize(\":yellow_square:\"))\n            for word in self.solution_lst[1]:\n                self.emoji_dict[word] = (emoji.emojize(\":green_square:\"))\n            for word in self.solution_lst[2]:\n                self.emoji_dict[word] = (emoji.emojize(\":blue_square:\"))\n            for word in self.solution_lst[3]:\n                self.emoji_dict[word] = (emoji.emojize(\":purple_square:\"))\n            logger.info(\"Emoji dictionary set for the puzzle.\")\n        else:\n            logger.warning(\"No solution provided. Emoji dictionary not set.\")\n\n    def setup_puzzle(self):\n        \"\"\"Set up the puzzle default filepath, default llm settings, load puzzle, and set solution.\"\"\"\n        self.set_path()\n        self.load_puzzle()\n        self.set_solution()\n        self.set_emoji_dict()\n        if self.llm_settings.model == 'gpt-4':\n            self.set_llm_settings(\n                max_tokens=6000, chunk_size=6000, chunk_overlap=500)\n            logger.info(\"LLM settings set for gpt-4 token capacity.\")\n        elif self.llm_settings.model == 'claude-3-opus-20240229':\n            self.set_llm_settings(\n                max_tokens=3500, chunk_size=3500, chunk_overlap=300)\n            logger.info(\n                \"LLM settings set for claude-3-opus-20240229 token capacity.\")\n\n    def solve_vanilla(self):\n        \"\"\"Solve the puzzle using vanilla approach.\"\"\"\n        logger.info(\"Solving puzzle using Vanilla approach\")\n        self.vanilla = SolveVanilla(self)\n        self.vanilla.set_path_vanilla()\n        self.vanilla.solve_puzzle_vanilla()\n        self.results_dict['vanilla'] = self.vanilla.results_dict\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                             name=f\"puzzle_{self.number}\")\n    \n    def solve_cot(self):\n        \"\"\"Solve the puzzle using cot approach.\"\"\"\n        logger.info(\"Solving puzzle using Cot approach\")\n        self.cot = SolveCot(self, cot_scripted=False)\n        self.cot.set_path_cot()\n        self.cot.solve_puzzle_cot()\n        self.results_dict['cot'] = self.cot.results_dict\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n\n    def solve_cot_scripted(self):\n        \"\"\"Solve the puzzle using cot scripted approach.\"\"\"\n        logger.info(\"Solving puzzle using Cot Scripted approach\")\n        self.cot_scripted = SolveCot(self, cot_scripted=True)\n        self.cot_scripted.set_path_cot()\n        self.cot_scripted.solve_puzzle_cot()\n        self.results_dict['cot_scripted'] = self.cot_scripted.results_dict\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n               \n    def solve_actor(self):\n        \"\"\"Solve the puzzle using the Actor approach.\"\"\"\n        logger.info(\"Solving puzzle using Actor approach\")\n        self.actor = SolveActor(self)\n        self.actor.set_path_actor()\n        self.actor.solve_puzzle_actor()\n        self.results_dict['actor'] = self.actor.results_dict\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n    \n    \n    def solve_all(self):\n        \"\"\"Solve the puzzle using all approaches.\"\"\"\n        self.solve_vanilla()\n        self.solve_cot()\n        self.solve_cot_scripted()\n        self.solve_actor()\n\n    \n    def solve_unfinished(self):\n        \"\"\"Solve the puzzle for any approach that is not finished already.\"\"\"\n        \n        if self.vanilla is None:\n            logger.info(\"# %s No Vanilla solve exists. Solving puzzle using Vanilla approach\", self.number)\n            self.solve_vanilla()\n        elif self.vanilla.end_game is False:\n            logger.info(\"# %s Vanilla solve is not finished. Solving puzzle using Vanilla approach\", self.number)\n            self.vanilla.set_path_vanilla()\n            self.vanilla.solve_puzzle_vanilla()\n            self.results_dict['vanilla'] = self.vanilla.results_dict\n            self.save_attributes(filepath_pkl=self.path_pkl,\n                             name=f\"puzzle_{self.number}\")\n        else:\n            logger.info(\"# %s Vanilla solve is already finished. No need to redo.\", self.number)\n        \n        if self.cot is None:\n            logger.info(\"# %s No Cot solve exists. Solving puzzle using Cot approach\", self.number)\n            self.solve_cot()\n        elif self.cot.end_game is False:\n            logger.info(\"# %s Cot solve is not finished. Solving puzzle using Cot approach\", self.number)\n            self.cot.set_path_cot()\n            self.cot.solve_puzzle_cot()\n            self.results_dict['cot'] = self.cot.results_dict\n            self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n        else:\n            logger.info(\"# %s Cot solve is already finished. No need to redo.\", self.number)\n        \n        if self.cot_scripted is None:\n            logger.info(\"# %s No Cot Scripted solve exists. Solving puzzle using Cot Scripted approach\", self.number)\n            self.solve_cot_scripted()\n        elif self.cot_scripted.end_game is False:\n            logger.info(\"# %s Cot Scripted solve is not finished. Solving puzzle using Cot Scripted approach\", self.number)\n            self.cot_scripted.set_path_cot()\n            self.cot_scripted.solve_puzzle_cot()\n            self.results_dict['cot_scripted'] = self.cot_scripted.results_dict\n            self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n        \n        if self.actor is None:\n            logger.info(\"# %s No Actor solve exists. Solving puzzle using Actor approach\", self.number)\n            self.solve_actor()\n        elif self.actor.end_game is False:\n            logger.info(\"# %s Actor solve is not finished. Solving puzzle using Actor approach\", self.number)\n            self.actor.set_path_actor()\n            self.actor.solve_puzzle_actor()\n            self.results_dict['actor'] = self.actor.results_dict\n            self.save_attributes(filepath_pkl=self.path_pkl,\n                        name=f\"puzzle_{self.number}\")\n            \n    def save_results(self):\n        \"\"\"Save the results of the puzzle to a dictionary.\"\"\"\n        self.results_dict = {}\n        if self.vanilla is not None:\n            self.results_dict['vanilla'] = self.vanilla.results_dict\n        if self.cot is not None:\n            self.results_dict['cot'] = self.cot.results_dict\n        if self.cot_scripted is not None:\n            self.results_dict['cot_scripted'] = self.cot_scripted.results_dict\n        if self.actor is not None:\n            self.results_dict['actor'] = self.actor.results_dict\n        logger.info(\"Results saved to dictionary.\")\n"}
{"type": "source_file", "path": "src/solve_cot.py", "content": "\"\"\"SolveCot class is a class the  solves the Connections puzzle using a Chain-of-Thoughts approaches.\n\"\"\"\n\nimport logging\nimport time\n\nfrom src.utils_llm import (\n    LLMSettings,\n    llm_call\n)\nfrom src.baseclass import BaseClass\nfrom src.solve import BaseSolver\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.guess_cot import GuessCot\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass SolveCot(BaseSolver):\n    \"\"\"SolveCot class is a class the  solves the Connections puzzle using a Chain-of-Thoughts approach.\n    \"\"\"\n    \n    def __init__(self,\n                 puzzle,\n                cot_scripted=False\n                 ):\n        super().__init__()\n        self.puzzle = puzzle\n        self.words_remain_lst = puzzle.words_lst\n        self.cot_scripted = cot_scripted\n    \n    def set_path_cot(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        if self.cot_scripted is False:\n            self.set_path(name=\"solve_cot\")\n        else:\n            self.set_path(name=\"solve_cot_scripted\")\n    \n    def solve_puzzle_cot(self):\n        \"\"\"Solve the puzzle using the CoT method.\n        \"\"\"\n        start_time = time.time()\n        if self.cot_scripted is False:\n            logger.info(\"Solving puzzle using CoT approach. \\n Words in puzzle: \\n %s \\n Solution: \\n %s\",\n                        self.puzzle.words_lst, self.puzzle.solution_lst)\n        else:\n            logger.info(\"Solving puzzle using CoT (Scripted) approach. \\n Words in puzzle: \\n %s \\n Solution: \\n %s\",\n                        self.puzzle.words_lst, self.puzzle.solution_lst)\n\n        if len(self.guesses_processed) == 0:\n\n            self.current_guess = None\n            self.guesses_processed = []\n            self.guesses_ready_to_submit = []\n            self.guesses_submitted = []\n            self.good_guesses = []\n            self.good_guesses_lst = []\n            self.bad_guesses = []\n            self.bad_guesses_lst = []\n            self.end_game = False\n            self.success = False\n        while self.end_game is False:\n            \n            # If the guesses ready to submit list has any guesses in it, submit the guess.\n            if len(self.guesses_ready_to_submit) > 0:\n                for guess in self.guesses_ready_to_submit:\n                    guess.do_submit()\n                    self.guesses_submitted.append(guess)\n                    # Remove from the list of guesses ready to submit\n                    self.guesses_ready_to_submit.remove(guess)\n                    if guess.guess_is_correct is True:\n                        self.good_guesses.append(guess)\n                        self.good_guesses_lst.append(guess.guess_lst)\n                        # Extend the words_excluded_lst to include each word in the guess_lst\n                        self.words_solved_lst.extend(guess.guess_lst)\n                        # Make words_remain_lst be words_lst minus words_solved_lst\n                        self.words_remain_lst = list(\n                            set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                        # Iterate over a copy of the list using slicing [:]\n                        for guess_ready in self.guesses_ready_to_submit[:]:\n                            if all(word in self.words_remain_lst for word in guess_ready.guess_lst):\n                                logger.info(\"Guess ready to submit still valid: %s\",\n                                            guess_ready.guess_lst)\n                            else:\n                                logger.info(\"Guess ready to submit no longer valid: %s\",\n                                            guess_ready.guess_lst)\n                                self.guesses_ready_to_submit.remove(guess_ready)\n                    else:\n                        self.bad_guesses.append(guess)\n                        self.bad_guesses_lst.append(guess.guess_lst)\n                        logger.debug(\"Number of bad guesses: %s\",\n                                    len(self.bad_guesses_lst))\n          \n\n            # If there are only four words left to solve, submit the guess that solves them.\n            if len(self.good_guesses) == 3:\n                logger.info(\"Only one possible solution left. Submitting.\")\n                self.current_guess = GuessCot(self)\n                self.current_guess.guess_lst = self.words_remain_lst\n                self.current_guess.do_submit()\n                if self.current_guess.guess_was_submitted is True:\n                    self.guesses_submitted.append(self.current_guess)\n                    if self.current_guess.guess_is_correct is True:\n                        self.good_guesses.append(self.current_guess)\n                        self.good_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        # Extend the words_excluded_lst to include each word in the guess_lst\n                        self.words_solved_lst.extend(\n                            self.current_guess.guess_lst)\n                        # Make words_remain_lst be words_lst minus words_solved_lst\n                        self.words_remain_lst = list(\n                            set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                    else:\n                        self.bad_guesses.append(self.current_guess)\n                        self.bad_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        logger.debug(\"Number of bad guesses: %s\",\n                                     len(self.bad_guesses_lst))\n            self.check_end_game_conditions()\n\n\n            # If the puzzle is not done, create a new guess\n            if self.end_game is False:\n                # Create a new guess\n                self.current_guess = GuessCot(self)\n                guesses_ready_to_submit_str = \"\"\n                for guess in self.guesses_ready_to_submit:\n                    guess_str = \"Guess: \\n\"\n                    guess_str += \" \".join(guess.guess_lst)\n                    guess_str += \"\\n Rationale: \\n\"\n                    guess_str += guess.guess_rationale\n                    guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n                logger.info(\"Starting New Guess! \\n Current guess number: %s \\n %s words remaining: \\n %s  \\n %s good guesses so far: \\n %s \\n %s bad guesses so far: \\n %s \\n %s guesses ready to submit: \\n %s\",\n                            self.current_guess.num_of_guess, len(self.words_remain_lst), self.words_remain_lst, len(self.good_guesses_lst), self.good_guesses_lst, len(self.bad_guesses_lst), self.bad_guesses_lst, len(self.guesses_ready_to_submit), guesses_ready_to_submit_str)\n                self.current_guess.process_guess()\n                self.guesses_processed.append(self.current_guess)\n                # If the current guess failed because of an error, start over from the beginning.\n                if self.current_guess.guess_is_valid is False:\n                    logger.info(\n                        \"Guess is not a valid guess to submit because of a formatting or content error. Starting over.\")\n                # If the current guess is ready to submit, add it to the list of guesses ready to submit.\n                if self.current_guess.guess_is_ready_to_submit is True:\n                    self.guesses_ready_to_submit.append(self.current_guess)\n                    logger.info(\"Guess is ready to submit. Adding to list.\")\n\n        self.solve_time = time.time() - start_time\n        minutes, seconds = divmod(self.solve_time, 60)\n        minutes = int(minutes)\n        seconds = int(seconds)\n        logger.info(\"Puzzle finished in %s minutes and %s seconds.\",\n                    minutes, seconds)\n        self.save_results_dict()\n        if self.puzzle.solution_lst is not None:\n            self.save_summary()\n        else:\n            self.save_summary_no_solution()\n        if self.cot_scripted is False:\n            self.save_attributes(filepath_pkl=self.path_pkl,\n                                 name=f\"puzzle_{self.puzzle.number}_cot\")\n        else:\n            self.save_attributes(filepath_pkl=self.path_pkl,\n                                 name=f\"puzzle_{self.puzzle.number}_cot_scripted\")\n"}
{"type": "source_file", "path": "src/guess_vanilla.py", "content": "\"\"\"Guess class for Vanilla approach for storing information about a guess that is processed.\"\"\"\n\nimport os\nimport logging\nimport random\n\nfrom src.guess import BaseGuess\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.utils_llm import (\n    llm_call\n)\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass GuessVanilla(BaseGuess):\n    \"\"\"Guess class for Vanilla approach for storing information about a guess that is processed.\"\"\"\n\n    def __init__(\n        self,\n        solve\n    ):\n        super().__init__()\n        self.solve = solve\n        self.puzzle = self.solve.puzzle\n        self.num_of_guess = len(self.solve.guesses_processed)+1\n        \n        self.make_guess_responses = []\n        self.make_guess_outputs = []\n        self.select_responses = []\n        self.select_outputs = []\n    \n    def process_guess(self):\n        \"\"\"Process the guess from start to finish for the Vanilla approach.\"\"\"\n        self.make_guess()\n        self.select_and_validate_all()\n        if self.guess_is_valid is True:\n            self.guess_is_ready_to_submit = True\n        else:\n            self.guess_is_ready_to_submit = False\n    \n    def make_guess(self):\n        \"\"\"Ask LLM to make a guess.\"\"\"\n        self.make_guess_responses = []\n        self.make_guess_outputs = []\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'vanilla' , 'make_guess.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Create user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"Can you make a guess for one part of the solution to this puzzle? List of words: {words_remain_str}\"\n        # Set up the prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.puzzle.llm_settings.model, prompts=prompts, settings=self.puzzle.llm_settings)\n        self.make_guess_responses.append(llm_response)\n        self.make_guess_outputs.append(llm_response.output)\n        self.guess_rationale = llm_response.output\n        logger.debug(\"Made guess: /n /n %s\", llm_response.output)\n    \n    def select_guess(self):\n        \"\"\"Call LLM to select the guess.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'vanilla', 'select.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the notes_str\n        prompt_system = prompt_system.replace(\"{notes}\", self.guess_rationale)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"Please select the guess to submit for this puzzle: {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.puzzle.llm_settings.model, prompts=prompts, settings=self.puzzle.llm_settings)\n        logger.debug(\"Select guess: /n /n %s\", llm_response.output)\n        return llm_response\n    \n    def select_all(self):\n        \"\"\"Run each of the steps to select the guess.\"\"\"\n        self.select_responses = []\n        self.select_outputs = []\n        llm_response = self.select_guess()\n        self.select_responses.append(llm_response)\n        self.select_outputs.append(llm_response.output)\n        # Turn the guess into a list of words and fix formatting\n        guess = llm_response.output\n        # Remove \"Output:\" or \"Response:\" from guess if it appears in the string\n        guess = guess.replace(\"Output:\", \"\").strip()\n        guess = guess.replace(\"Response:\", \"\").strip()\n        guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n        \n        # Sort the guess_lst in alphabetical order\n        guess_lst = sorted(guess_lst)\n        # Check if the guess_lst has four words\n        if len(guess_lst) != 4:\n            logger.warning(\n                \"Guess does not contain four words. Trying to get LLM to fix...\")\n            llm_response = self.select_fix(guess)\n            # Turn the guess into a list of words and fix formatting\n            guess = llm_response.output\n            # Remove \"Output:\" from guess if it appears in the string\n            guess = guess.replace(\"Output:\", \"\").strip()\n            guess = guess.replace(\"Response:\", \"\").strip()\n            guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n            if len(guess_lst) != 4:\n                logger.warning(\n                    \"Failed to fix guess. Guess still does not contain four words.\")\n            else:\n                logger.info(\"Fixed guess!\")\n        self.guess_lst = guess_lst\n        logger.info(\"Selected guess: %s\", \" \".join(guess_lst))\n        \n    def select_and_validate_all(self):\n        \"\"\"Select the guess and validate it for errors.\"\"\"\n        self.select_all()\n        self.validate_all()\n    "}
{"type": "source_file", "path": "src/solve_actor_o1.py", "content": "\"\"\"SolveActoro1 class is a class that solves the Connections puzzle Actor-o1 approach.\n\"\"\"\n\nimport logging\nimport os\nimport re\nimport copy\nimport time\nimport emoji\nimport random\n\nfrom src.utils_llm import (\n    llm_call\n)\nfrom src.baseclass import BaseClass\nfrom src.solve import BaseSolver\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\n\nfrom src.guess_actor_o1 import GuessActoro1\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass SolveActoro1(BaseSolver):\n    \"\"\"SolveActoro1 class is a class that solves the Connections puzzle Actor-o1 approach.\n    \"\"\"\n    \n    def __init__(self,\n                 puzzle\n    ):\n        super().__init__()\n        self.puzzle = puzzle\n        self.llm_settings = puzzle.llm_settings\n        self.words_remain_lst = puzzle.words_lst\n        # Evaluations of multiple guesses\n        self.evaluations = []\n        # Number of brainstorming templates\n        self.templates_num = 24\n        # Where previous guess left off going through brainstorm templates\n        self.templates_index = 0\n        # New variables for Experiment Two\n        # List of final guesses to submit\n        self.guesses_final = []\n        # Temporary words remain list\n        self.temp_words_remain_lst = []\n        # Guesses that have not been submitted but as a matter of logic based on other bad guesses must also be bad guesses\n        self.logically_bad_guesses_lst = []\n        \n        self.guesses_two_unique = []\n        self.guesses_three_unique = []\n        self.guesses_four_unique = []\n        self.guesses_to_pair_lst = []\n    \n    def set_path_actoro1(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        self.set_path(name=\"solve_actor_o1\")\n \n    def solve_puzzle_actoro1(self):\n        \"\"\"Solve the puzzle using the Actor-o1 approach (experiment two) with GPT-o1.\n        \"\"\"\n        start_time = time.time()\n        logger.info(\"Solving puzzle using Actor-o1 method. \\n Words in puzzle: \\n %s \\n Solution: \\n %s\",\n                    self.puzzle.words_lst, self.puzzle.solution_lst)\n        if len(self.guesses_processed) == 0:\n\n            self.current_guess = None\n            self.guesses_processed = []\n            self.guesses_ready_to_submit = []\n            self.guesses_final = []\n            self.guesses_submitted = []\n            self.good_guesses = []\n            self.good_guesses_lst = []\n            self.bad_guesses = []\n            self.bad_guesses_lst = []\n            self.end_game = False\n            self.success = False\n            \n            self.guesses_two_unique = []\n            self.guesses_three_unique = []\n            self.guesses_four_unique = []\n            self.guesses_to_pair_lst = []\n\n        while self.end_game is False:\n\n            \n            # If the puzzle is not solved, create a new guess\n            if self.end_game is False:\n                \n                logger.info(\"Start of process. \\n New Guess!\")\n                self.temp_words_remain_lst = self.words_remain_lst.copy()\n                logger.info(\"Temporary words remain list set to words list: %s\", self.temp_words_remain_lst)\n                \n                if len(self.good_guesses) <= 1:\n                    logger.info(\"0 or 1 Good guesses. Setting temporary words remain list.\")    \n                    if len(self.guesses_ready_to_submit) >= 2:\n                        # If the words in the last guess in ready to submit have already come up twice in the\n                        # ready to submit list, remove them from the temporary words remain list\n                        set_last_guess_lst = set(self.guesses_ready_to_submit[-1].guess_lst)\n                        count_appearance_last_guess = 0\n                        for guess in self.guesses_ready_to_submit:\n                            if set_last_guess_lst == set(guess.guess_lst):\n                                count_appearance_last_guess += 1\n                        if count_appearance_last_guess >= 2:\n                            logger.info(\"Last guess ready to submit has appeared twice or more. Removing from temporary words remain list.\")\n                            for word in self.guesses_ready_to_submit[-1].guess_lst:\n                                self.temp_words_remain_lst.remove(word)\n                            logger.info(\"Temporary words remain list after removing last guess ready to submit: %s\", self.temp_words_remain_lst)                        \n                    if len(self.guesses_final) > 0 and len(self.good_guesses) == 0:\n                        # Pick a random number either 0 or 1\n                        random_removal_num = random.randint(0, 1)\n                        # If the random number is 1, remove all words from a random guess in the final guesses list from the temporary words remain list\n                        if random_removal_num == 1:\n                            random_guess_final = random.choice(self.guesses_final)\n                            for word in random_guess_final.guess_lst:\n                                if word in self.temp_words_remain_lst:\n                                    self.temp_words_remain_lst.remove(word)\n                            logger.info(\"Temporary words remain list after removing random guess from final guesses: %s\", self.temp_words_remain_lst)\n                        else:\n                            logger.info(\"Random number was 0. Not removing words from temporary words remain list based on a random guess from final guesses.\")\n                elif len(self.good_guesses) == 2:\n                    logger.info(\"Two good guesses. Setting temporary words remain list.\")\n                    if len(self.bad_guesses) < 2:\n                        logger.info(\"Fewer than two bad guesses. Keeping all words in temporary words remain list as is.\")\n                    elif len(self.bad_guesses) == 2:\n                        random_single_mole_num = random.randint(0, 1)\n                        for i, guess_lst in enumerate(self.good_guesses_lst):\n                            if i == random_single_mole_num:\n                                random_mole_word = random.choice(guess_lst)\n                                self.temp_words_remain_lst.append(random_mole_word)\n                                logger.info(\"Two bad guesses. Including one random 'mole' word in temporary words remain list. \\n %s\", self.temp_words_remain_lst)\n                    else:\n                        for guess_lst in self.good_guesses_lst:\n                            random_mole_word = random.choice(guess_lst)\n                            self.temp_words_remain_lst.append(random_mole_word)\n                            logger.info(\"Three bad guesses. Including two random 'mole' words (one from each guess in good_guesses).\")           \n                # Create a new guess\n                self.current_guess = GuessActoro1(self)\n                guesses_ready_to_submit_str = \"Guesses ready to submit: \\n\"\n                for guess in self.guesses_ready_to_submit:\n                    guess_str = \"Guess: \\n\"\n                    guess_str += \" \".join(guess.guess_lst)\n                    guess_str += \"\\n Rationale: \\n\"\n                    guess_str += guess.guess_rationale\n                    guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n                guesses_final_str = \"Final guesses: \\n\"\n                for guess in self.guesses_final:\n                    guess_str = \"Guess: \\n\"\n                    guess_str += \" \".join(guess.guess_lst)\n                    guess_str += \"\\n Rationale: \\n\"\n                    guess_str += guess.guess_rationale\n                    guesses_final_str += f\"{guess_str}\\n\"\n                logger.info(\"Starting New Guess! \\n Current guess number: %s \\n %s words remaining \\n Temporary word remain list: \\n %s  \\n %s good guesses so far: \\n %s \\n %s bad guesses so far: \\n %s \\n %s guesses ready to submit: \\n %s  \\n %s final guesses: \\n %s\",\n                            self.current_guess.num_of_guess, len(self.words_remain_lst), self.temp_words_remain_lst, len(self.good_guesses_lst), self.good_guesses_lst, len(self.bad_guesses_lst), self.bad_guesses_lst, len(self.guesses_ready_to_submit), guesses_ready_to_submit_str, len(self.guesses_final), guesses_final_str)\n                self.current_guess.process_guess()\n                self.guesses_processed.append(self.current_guess)\n\n                if self.current_guess.good_options_for_guess is False:\n                    logger.info(\n                        \"No good options for guess. Starting over.\")\n\n                # If the current guess failed because of an error, start over from the beginning.\n                if self.current_guess.guess_is_valid is False:\n                    logger.info(\n                        \"Guess is not a valid guess to submit because of a formatting or content error. Starting over.\")\n\n                # If the current guess is ready to submit, add it to the list of guesses ready to submit.\n                if self.current_guess.guess_is_ready_to_submit is True:\n                    self.guesses_ready_to_submit.append(self.current_guess)\n                    logger.info(\"Guess is ready to submit. Adding to list.\")\n            \n            # If there are enough guesses ready to submit, evaluate them.\n            if len(self.good_guesses) < 2:\n                logger.info(\"Fewer than two good guesses.\")\n                if len(self.guesses_final) == 0:\n                    logger.info(\"Final guesses list is empty.\")\n                    if len(self.guesses_ready_to_submit) >= 5:\n                        logger.info(\"Five or more guesses ready to submit. Evaluating now.\")\n                        self.evaluate_guesses_ready_to_submit_all()\n                else:\n                    logger.info(\"Final guesses list is not empty.\")\n                    if len(self.guesses_ready_to_submit) >= 5:\n                        no_overlap_count = 0\n                        for guess in self.guesses_ready_to_submit:\n                            for guess_final in self.guesses_final:\n                                if set(guess.guess_lst) != set(guess_final.guess_lst):\n                                    no_overlap_count += 1\n                            for guess_good in self.good_guesses:\n                                if set(guess.guess_lst) != set(guess_good.guess_lst):\n                                    no_overlap_count += 1\n                            if no_overlap_count >= 2:\n                                logger.info(\"Two or more guesses do not overlap with final guesses or good guesses. Five or more guesses ready to submit. Evaluating now.\")\n                                self.evaluate_guesses_ready_to_submit_all()\n                                break\n            elif len(self.good_guesses) == 2:\n                logger.info(\"Two good guesses.\")\n                if len(self.guesses_ready_to_submit) >= 3:\n                    logger.info(\"Three or more guesses ready to submit. Evaluating now.\")\n                    self.evaluate_guesses_ready_to_submit_all()\n            \n            # Check if there are non-overlapping guesses in guesses_final.\n            self.check_unique_guesses()\n            \n            # If there are four non-overlapping guesses in guesses_final, start submitting.\n            if len(self.guesses_four_unique) > 0:\n                logger.info(\"Four non-overlapping guesses in guesses_final. Submitting.\")\n                for quadruplet in self.guesses_four_unique:\n                    keep_going = True\n                    # If the submission is good, submit the next one\n                    for guess_lst in quadruplet:\n                        if keep_going is True:\n                            guess_set = set(guess_lst)\n                            for guess in self.guesses_final:\n                                if set(guess.guess_lst) == guess_set:\n                                    self.submit_guess_final(guess)\n                                    if guess.guess_is_correct is True:\n                                        keep_going = True\n                                    else:\n                                        keep_going = False\n                                    break            \n            # If more than ten guesses have been processed or one good guess exists, submit any set of three guesses that do not overlap.\n            elif len(self.guesses_three_unique) > 0 and (len(self.guesses_processed) >= 13 or len(self.good_guesses) == 1):      \n                logger.info(\"Three non-overlapping guesses in guesses_final.\")\n                if len(self.guesses_three_unique) == 1:\n                    for triplet in self.guesses_three_unique:\n                        keep_going = True\n                        # If the submission is good, submit the next one\n                        for guess_lst in triplet:\n                            if keep_going is True:\n                                guess_set = set(guess_lst)\n                                for guess in self.guesses_final:\n                                    if set(guess.guess_lst) == guess_set:\n                                        self.submit_guess_final(guess)\n                                        if guess.guess_is_correct is True:\n                                            keep_going = True\n                                        else:\n                                            keep_going = False\n                                        break\n                else:\n                    logger.info(\"Multiple sets of three non-overlapping guesses in guesses_final. Submitting guesses that appear in each set.\")\n                    all_triplet_guesses = []\n                    guesses_to_submit = []\n                    for triplet in self.guesses_three_unique:\n                        for guess_lst in triplet:\n                            all_triplet_guesses.append(guess_lst)\n                    for guess_lst in all_triplet_guesses:\n                        count_in_triplets = 0\n                        guess_set = set(guess_lst)\n                        for guess_match in all_triplet_guesses:\n                            # If the guess matches the guess_lst and is not the same entry as the guess_lst\n                            if set(guess_match) == guess_set:\n                                count_in_triplets += 1\n                        if count_in_triplets == len(self.guesses_three_unique):\n                            guesses_to_submit.append(guess_lst)\n                    keep_going = True\n                    for guess_lst in guesses_to_submit:\n                        if keep_going is True:\n                            guess_set = set(guess_lst)\n                            for guess in self.guesses_final:\n                                if set(guess.guess_lst) == guess_set:\n                                    self.submit_guess_final(guess)\n                                    if guess.guess_is_correct is True:\n                                        keep_going = True\n                                    else:\n                                        keep_going = False\n                                    break          \n                    \n                    \n            # If there are three identical guesses in guesses_final, submit one of them.\n            guesses_identical = []\n            for current_guess in self.guesses_final:\n                guesses_identical = []\n                guesses_identical.append(current_guess)\n                for match_guess in self.guesses_final:\n                    if current_guess != match_guess:\n                        if set(current_guess.guess_lst) == set(match_guess.guess_lst):\n                            guesses_identical.append(match_guess)\n                if len(guesses_identical) >= 3:\n                    logger.info(\"Three or more identical guesses in guesses_final. \\n %s \\n %s \\n %s \\n Submitting one.\",\n                                guesses_identical[0].guess_lst, guesses_identical[1].guess_lst, guesses_identical[2].guess_lst)\n                    self.submit_guess_final(guesses_identical[0])\n                    break\n                \n            # If more than 15 guesses have been processed or two good guesses exist, submit any set of two guesses that do not overlap.           \n            if len(self.guesses_processed) > 16 or len(self.good_guesses) == 2:\n                # If there are two non-overlapping guesses in guesses_final, start submitting.\n                guesses_two_no_overlap = []\n                for current_guess in self.guesses_final:\n                    # Only proceed if the current guess is not already in guesses_two_no_overlap\n                    if current_guess not in guesses_two_no_overlap:\n                        for match_guess in self.guesses_final:\n                            logger.debug(\"Checking overlap between guesses: %s and %s\",\n                                        current_guess.guess_lst, match_guess.guess_lst)\n                            overlap = False\n                            for word in current_guess.guess_lst:\n                                if word in match_guess.guess_lst:\n                                    overlap = True\n                            if overlap is False:\n                                logger.info(\"No overlap between guesses: %s and %s\",\n                                            current_guess.guess_lst, match_guess.guess_lst)\n                                guesses_two_no_overlap.append(current_guess)\n                                guesses_two_no_overlap.append(match_guess)\n                if len(guesses_two_no_overlap) == 2:\n                    logger.info(\"Two non-overlapping guesses in guesses_final. Submitting.\")\n                    # Submit the guess with fewer words in common with other guesses\n                    guess0_words_in_common = 0\n                    guess1_words_in_common = 0\n                    for word in guesses_two_no_overlap[0].guess_lst:\n                        for guess in self.guesses_final:\n                            if word in guess.guess_lst:\n                                guess0_words_in_common += 1\n                    for word in guesses_two_no_overlap[1].guess_lst:\n                        for guess in self.guesses_final:\n                            if word in guess.guess_lst:\n                                guess1_words_in_common += 1\n                    logger.info(\" %s words in common in final guesses with %s /n %s words in common in final guesses with %s.\",\n                                guess0_words_in_common, guesses_two_no_overlap[0].guess_lst, guess1_words_in_common, guesses_two_no_overlap[1].guess_lst)\n                    if guess0_words_in_common <= guess1_words_in_common:\n                        logger.info(\"Submitting %s\", guesses_two_no_overlap[0].guess_lst)\n                        self.submit_guess_final(guesses_two_no_overlap[0])\n                        # if submission is good, submit the other one\n                        if guesses_two_no_overlap[0].guess_is_correct is True:\n                            logger.info(\"Submitting %s\", guesses_two_no_overlap[1].guess_lst)\n                            self.submit_guess_final(guesses_two_no_overlap[1])\n                    elif guess1_words_in_common < guess0_words_in_common:\n                        logger.info(\"Submitting %s\", guesses_two_no_overlap[1].guess_lst)\n                        self.submit_guess_final(guesses_two_no_overlap[1])\n                        # if submission is good, submit the other one\n                        if guesses_two_no_overlap[1].guess_is_correct is True:\n                            logger.info(\"Submitting %s\", guesses_two_no_overlap[0].guess_lst)\n                            self.submit_guess_final(guesses_two_no_overlap[0])\n                elif len(guesses_two_no_overlap) > 2:\n                    logger.info(\"Three or more non-overlapping guesses in guesses_final. Submitting one.\")\n                    # Submit the guess that doesn't have words in common with the other guesses\n                    for guess in guesses_two_no_overlap:\n                        words_in_common = 0\n                        for word in guess.guess_lst:\n                            for match_guess in guesses_two_no_overlap:\n                                # Only check if the guess is not the same as the match_guess\n                                if guess != match_guess:\n                                    if word in match_guess.guess_lst:\n                                        words_in_common += 1\n                                        logger.debug(\"%s has words in common with %s\", guess.guess_lst, match_guess.guess_lst)\n                        if words_in_common == 0:\n                            logger.info(\"Unique guess! Submitting %s\", guess.guess_lst)\n                            self.submit_guess_final(guess)\n                            break\n            \n            # If more than 15 guesses have been processed and two good guesses exist, submit any set of two guesses that are identical.\n            if len(self.guesses_final) > 1 and len(self.good_guesses) == 2 and len(self.guesses_processed) > 16:\n                # If there are two identical guesses in guesses_final, submit one of them.\n                guesses_two_identical = []\n                for current_guess in self.guesses_final:\n                    for match_guess in self.guesses_final:\n                        if current_guess != match_guess:\n                            if set(current_guess.guess_lst) == set(match_guess.guess_lst):\n                                logger.info(\"Two identical guesses in guesses_final. Submitting one.\")\n                                self.submit_guess_final(current_guess)\n                                break\n\n            # If there are only four words left to solve, submit the guess that solves them.\n            if len(self.good_guesses) == 3:\n                logger.info(\"Only one possible solution left. Submitting.\")\n                self.current_guess = GuessActoro1(self)\n                self.current_guess.guess_lst = self.words_remain_lst\n                self.current_guess.do_submit()\n                if self.current_guess.guess_was_submitted is True:\n                    self.guesses_submitted.append(self.current_guess)\n                    if self.current_guess.guess_is_correct is True:\n                        self.good_guesses.append(self.current_guess)\n                        self.good_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        # Extend the words_solved_lst to include each word in the guess_lst\n                        self.words_solved_lst.extend(\n                            self.current_guess.guess_lst)\n                        # Make words_remain_lst be words_lst minus words_solved_lst\n                        self.words_remain_lst = list(\n                            set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                    else:\n                        self.bad_guesses.append(self.current_guess)\n                        self.bad_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        logger.debug(\"Number of bad guesses: %s\",\n                                     len(self.bad_guesses_lst))\n            \n            self.check_end_game_conditions()\n\n        self.solve_time = time.time() - start_time\n        minutes, seconds = divmod(self.solve_time, 60)\n        minutes = int(minutes)\n        seconds = int(seconds)\n        logger.info(\"Puzzle finished in %s minutes and %s seconds.\",\n                    minutes, seconds)\n        self.save_results_dict()\n        self.save_outputs(filepath_md=self.path_md,\n                          name=f\"evaluations_puzzle_{self.puzzle.number}\",\n                          responses=self.evaluations\n                          )\n        if self.puzzle.solution_lst is not None:\n            self.save_summary()\n        else:\n            self.save_summary_no_solution()\n        self.save_summary_detailed_thorough()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                             name=f\"puzzle_{self.puzzle.number}_actor_o1\")\n        \n\n    def evaluate_guesses_ready_to_submit_cot(self):\n        \"\"\"Decide which guesses are strongest for submitting.\"\"\"\n        # Load the system prompt from a .txt file\n        prompt_system = \"\"\n        if len(self.good_guesses) == 2:\n            with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_o1', \"evaluate_guesses_cot_final.txt\"),\n                'r', encoding='utf-8') as f:\n                prompt = f.read()\n        else:\n            with open(os.path.join(\n                    get_root_dir(), 'data', 'prompts', 'actor_o1', \"evaluate_guesses_cot.txt\"),\n                    'r', encoding='utf-8') as f:\n                prompt = f.read()\n        prompt_system += prompt\n        # Add guesses ready to submit to the prompt\n        guesses_ready_to_submit_str = \"\"\n        # Create a string of the guesses ready to submit\n        # Start by copying over guesses_ready_to_submit but not copying guesses that have the same set of words to submit\n        # We do this so that each unique guess is included only once and so that the LLM does not discount the value of these answers for overlapping with one another\n        guesses_ready_to_submit_no_overlap = []\n        # Make a deep copy of guesses_ready_to_submit\n        guesses_ready_copy = copy.deepcopy(self.guesses_ready_to_submit)\n        # Remove from guesses_ready_copy any guesses that have the same set of words as the last guess in guesses_final at the beginning of the process\n        # This ensures that we have greater variety in our answers in guesses_final\n        guesses_ready_final = []\n        if len(self.guesses_final) > 0 and len(self.guesses_processed) <=7:\n            guess_final_set = set(self.guesses_final[-1].guess_lst)\n            for guess in guesses_ready_copy:\n                if set(guess.guess_lst) != guess_final_set:\n                    guesses_ready_final.append(guess)\n        else:\n            guesses_ready_final = guesses_ready_copy\n        random.shuffle(guesses_ready_final)\n        for guess in guesses_ready_final:\n            overlap = False\n            for guess_no_overlap in guesses_ready_to_submit_no_overlap:\n                if set(guess.guess_lst) == set(guess_no_overlap.guess_lst):\n                    overlap = True\n            if overlap is False:\n                guesses_ready_to_submit_no_overlap.append(guess)\n        # Shuffle the guesses ready to submit\n        guesses_ready_shuffled = guesses_ready_to_submit_no_overlap.copy()\n        random.shuffle(guesses_ready_shuffled)\n        for guess in guesses_ready_shuffled:\n            guess_str = \"Guess: \\n\"\n            guess_str += \" \".join(guess.guess_lst)\n            guess_str += \"\\n Rationale: \\n\"\n            guess_str += guess.guess_rationale\n            guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n        prompt_system = prompt_system.replace(\n            \"{notes}\", guesses_ready_to_submit_str)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"What is your top choice for a guess to submit for this puzzle? {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        logger.debug(\"LLM response evaluate_cot: \\n %s\", llm_response.output)\n        return llm_response\n\n    def evaluate_guesses_ready_to_submit_select(self, notes_str):\n        \"\"\"Select the best guess to submit.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_o1', 'evaluate_guesses_select.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the notes_str\n        prompt_system = prompt_system.replace(\"{notes}\", notes_str)\n        # Create a user prompt\n        prompt_user = \"Please select the best guess to submit.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def evaluate_guesses_ready_to_submit_all(self):\n        \"\"\"Call on LLM to evaluate the guesses ready to submit and submit the best one.\"\"\"\n        guesses_ready_to_submit_str = \"\"\n        for guess in self.guesses_ready_to_submit:\n            guess_str = \"Guess: \\n\"\n            guess_str += \" \".join(guess.guess_lst)\n            guess_str += \"\\n Rationale: \\n\"\n            guess_str += guess.guess_rationale\n            guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n        logger.info(\"%s guesses are ready to submit. Evaluating now...  \\n %s\",\n                    len(self.guesses_ready_to_submit), guesses_ready_to_submit_str)\n        \n        # If the words in each guess are the same, submit one of them\n        all_the_same = True\n        guess_set_0 = set(self.guesses_ready_to_submit[0].guess_lst)\n        for guess in self.guesses_ready_to_submit:\n            if set(guess.guess_lst) != guess_set_0:\n                all_the_same = False\n                break\n        if all_the_same is True:\n            logger.info(\"All guesses ready to submit are the same. Submitting one.\")\n            guess_set = guess_set_0\n        else:\n            # Evaluate the guesses ready to submit\n            llm_response = self.evaluate_guesses_ready_to_submit_cot()\n            self.evaluations.append(llm_response)\n            # Select the best guess to submit\n            llm_response = self.evaluate_guesses_ready_to_submit_select(\n                llm_response.output)\n            # Turn the guess into a list of words and fix formatting\n            guess = llm_response.output\n            # Remove \"Output:\" from guess if it appears in the string\n            guess = guess.replace(\"Output:\", \"\").strip()\n            guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n            logger.info(\"Guess selected to submit: %s\", \" \".join(guess_lst))\n            # Identify the guess object that matches the guess selected to submit\n            guess_set = set(guess_lst)\n            # Check if the guess selected to submit matches any of the guesses ready to submit\n            match_guess = False\n            for guess in self.guesses_ready_to_submit:\n                # If guess_set is the same as the set of words in the guess, match_guess is True\n                if guess_set == set(guess.guess_lst):\n                    match_guess = True\n                    break\n            # If the guess selected to submit does not match any of the guesses ready to submit, start over\n            if match_guess is False:\n                logger.info(\"Guess selected to submit does not match any guesses ready to submit. Starting over.\")\n                return\n        for guess in self.guesses_ready_to_submit:\n            # If guess_set is the same as the set of words in the guess, add the guess to guesses_final\n            if guess_set == set(guess.guess_lst):\n                # Add the guess to guesses_final\n                self.guesses_final.append(guess)\n                # Remove from the list of guesses ready to submit\n                self.guesses_ready_to_submit.remove(guess)\n                break\n        for guess in self.guesses_ready_to_submit:\n            # Increment the count of how many times the guess has been evaluated for submission as a final guess.\n            guess.guess_eval_count += 1\n            logger.info(\"Guess %s has been evaluated %s times for submission as a final guess.\",\n                        guess.guess_lst, guess.guess_eval_count)\n            # Remove guesses that have been evaluated four or more times\n            if guess.guess_eval_count >= 4:\n                logger.info(\"Guess %s has been evaluated four or more times for submission as a final guess. Removing from consideration.\",\n                            guess.guess_lst)\n                self.guesses_ready_to_submit.remove(guess)\n    \n    def check_unique_guesses(self):\n        \"\"\"Check unique guesses in guesses_final.\"\"\"\n        self.guesses_two_unique = []\n        self.guesses_three_unique = []\n        self.guesses_four_unique = []\n        self.guesses_to_pair_lst = []\n        \n        self.guesses_to_pair_lst = copy.deepcopy(self.guesses_final)\n        \n        logger.debug(\"Number of guesses to analyze for unique combinations: %s\", len(self.guesses_to_pair_lst))\n        \n        for current_guess in self.guesses_to_pair_lst:\n            # logger.info(\"Current guess to analyze: %s\", current_guess.guess_lst)\n            current_guess_set = set(current_guess.guess_lst)\n            for guess in self.guesses_to_pair_lst:\n                # logger.info(\"Checking for pair with guess: %s\", guess.guess_lst)\n                guess_set = set(guess.guess_lst)\n                # Skip if index of current guess is the same as index of guess\n                if self.guesses_to_pair_lst.index(current_guess) == self.guesses_to_pair_lst.index(guess):\n                    logger.debug(\n                         \"Skipping because index of current guess is the same as index of guess.\")\n                elif current_guess_set == guess_set:\n                    logger.debug(\n                        \"Skipping because guess is the same as current guess.\")\n                else:\n                    if len(current_guess_set.intersection(guess_set)) == 0:\n                        #logger.info(\n                        #    \"Guess is part of a unique pair of guesses. \\n Current guess: %s \\n Guess: %s\", current_guess.guess_lst, guess.guess_lst)\n                        \n                        # Make sure the pair isn't already in the list of unique pairs\n                        guess_set_pair = set(current_guess.guess_lst).union(guess.guess_lst)\n                        \n                        new_pair = True\n                        for pair in self.guesses_two_unique:\n                            pair_0_match = False\n                            pair_1_match = False\n                            \n                            if set(pair[0]) == current_guess_set:\n                                pair_0_match = True\n                            elif set(pair[0]) == guess_set:\n                                pair_0_match = True\n                            if set(pair[1]) == current_guess_set:\n                                pair_1_match = True\n                            elif set(pair[1]) == guess_set:\n                                pair_1_match = True\n                            \n                            if pair_0_match is True and pair_1_match is True:\n                                new_pair = False\n                                logger.info(\"Pair is already in list of unique pairs. \\n Pair: %s\", pair)\n                                break\n                        \n                        if new_pair is True:\n                            self.guesses_two_unique.append(\n                                [current_guess.guess_lst, guess.guess_lst])\n                            logger.info(\"Pair is not already in list of unique pairs. Adding pair to list. \\n Pair: %s\", [current_guess.guess_lst, guess.guess_lst])\n\n                            # Check if this pair is part of a triplet\n                            logger.info(\"Checking if pair is part of a triplet.\")\n                            for guess2 in self.guesses_to_pair_lst:\n                                guess_set2 = set(guess2.guess_lst)\n                                if self.guesses_to_pair_lst.index(current_guess) == self.guesses_to_pair_lst.index(guess2):\n                                    logger.info(\"Skipping because index of current guess is the same as index of guess2.\")\n                                elif self.guesses_to_pair_lst.index(guess) == self.guesses_to_pair_lst.index(guess2):\n                                    logger.info(\n                                        \"Skipping because index of guess is the same as index of guess2.\")\n                                elif len(guess_set_pair.intersection(guess_set2)) == 0:\n                                    #logger.info(\n                                       # \"Guess is part of a unique triplet of guesses. \\n Current guess: %s \\n Guess: %s \\n Guess2: %s\", current_guess.guess_lst, guess.guess_lst, guess2.guess_lst)\n                                    \n                                    # Make sure the triplet isn't already in the list of unique triplets\n                                    guess_set_triplet = set(current_guess.guess_lst).union(guess.guess_lst).union(guess2.guess_lst)\n                                    \n                                    new_triplet = True\n                                    for triplet in self.guesses_three_unique:\n                                        triplet_0_match = False\n                                        triplet_1_match = False\n                                        triplet_2_match = False\n                                        \n                                        if set(triplet[0]) == current_guess_set:\n                                            triplet_0_match = True\n                                        elif set(triplet[0]) == guess_set:\n                                            triplet_0_match = True\n                                        elif set(triplet[0]) == guess_set2:\n                                            triplet_0_match = True\n                                        if set(triplet[1]) == current_guess_set:\n                                            triplet_1_match = True\n                                        elif set(triplet[1]) == guess_set:\n                                            triplet_1_match = True\n                                        elif set(triplet[1]) == guess_set2:\n                                            triplet_1_match = True\n                                        if set(triplet[2]) == current_guess_set:\n                                            triplet_2_match = True\n                                        elif set(triplet[2]) == guess_set:\n                                            triplet_2_match = True\n                                        elif set(triplet[2]) == guess_set2:\n                                            triplet_2_match = True\n                                            \n                                        if triplet_0_match is True and triplet_1_match is True and triplet_2_match is True:\n                                            new_triplet = False\n                                            logger.info(\n                                                \"Triplet is already in list of unique triplets. \\n Triplet: %s\", triplet)\n                                            break\n                                        \n                                    if new_triplet is True:\n                                        self.guesses_three_unique.append(\n                                            [current_guess.guess_lst, guess.guess_lst, guess2.guess_lst])\n                                        logger.info(\n                                            \"Triplet is not already in list of unique triplets. Adding triplet to list. \\n Triplet: %s\", [current_guess.guess_lst, guess.guess_lst, guess2.guess_lst])\n                                    \n                                        # Check if this triplet is part of a quadruplet\n                                        logger.info(\"Checking if triplet is part of a quadruplet.\")\n                                        for guess3 in self.guesses_to_pair_lst:\n                                            guess_set3 = set(guess3.guess_lst)\n                                            if self.guesses_to_pair_lst.index(current_guess) == self.guesses_to_pair_lst.index(guess3):\n                                                logger.info(\"Skipping because index of current guess is the same as index of guess3.\")\n                                            elif self.guesses_to_pair_lst.index(guess) == self.guesses_to_pair_lst.index(guess3):\n                                                logger.info(\n                                                    \"Skipping because index of guess is the same as index of guess3.\")\n                                            elif self.guesses_to_pair_lst.index(guess2) == self.guesses_to_pair_lst.index(guess3):\n                                                logger.info(\n                                                    \"Skipping because index of guess2 is the same as index of guess3.\")\n                                            elif len(guess_set_triplet.intersection(guess_set3)) == 0:\n                                                #logger.info(\n                                                #    \"Guess is part of a unique quadruplet of guesses. \\n Current guess: %s \\n Guess: %s \\n Guess2: %s \\n Guess3: %s\", current_guess.guess_lst, guess.guess_lst, guess2.guess_lst, guess3.guess_lst)\n                                                \n                                                # Make sure the quadruplet isn't already in the list of unique quadruplets\n                                                guess_set_quadruplet = set(current_guess.guess_lst).union(guess.guess_lst).union(guess2.guess_lst).union(guess3.guess_lst)\n                                                \n                                                new_quadruplet = True\n                                                for quadruplet in self.guesses_four_unique:\n                                                    quadruplet_0_match = False\n                                                    quadruplet_1_match = False\n                                                    quadruplet_2_match = False\n                                                    quadruplet_3_match = False\n                                                    \n                                                    if set(quadruplet[0]) == current_guess_set:\n                                                        quadruplet_0_match = True\n                                                    elif set(quadruplet[0]) == guess_set:\n                                                        quadruplet_0_match = True\n                                                    elif set(quadruplet[0]) == guess_set2:\n                                                        quadruplet_0_match = True\n                                                    elif set(quadruplet[0]) == guess_set3:\n                                                        quadruplet_0_match = True\n                                                    if set(quadruplet[1]) == current_guess_set:\n                                                        quadruplet_1_match = True\n                                                    elif set(quadruplet[1]) == guess_set:\n                                                        quadruplet_1_match = True\n                                                    elif set(quadruplet[1]) == guess_set2:\n                                                        quadruplet_1_match = True\n                                                    elif set(quadruplet[1]) == guess_set3:\n                                                        quadruplet_1_match = True\n                                                    if set(quadruplet[2]) == current_guess_set:\n                                                        quadruplet_2_match = True\n                                                    elif set(quadruplet[2]) == guess_set:\n                                                        quadruplet_2_match = True\n                                                    elif set(quadruplet[2]) == guess_set2:\n                                                        quadruplet_2_match = True\n                                                    elif set(quadruplet[2]) == guess_set3:\n                                                        quadruplet_2_match = True\n                                                    if set(quadruplet[3]) == current_guess_set:\n                                                        quadruplet_3_match = True\n                                                    elif set(quadruplet[3]) == guess_set:\n                                                        quadruplet_3_match = True\n                                                    elif set(quadruplet[3]) == guess_set2:\n                                                        quadruplet_3_match = True\n                                                    elif set(quadruplet[3]) == guess_set3:\n                                                        quadruplet_3_match = True\n                                                    \n                                                    if quadruplet_0_match is True and quadruplet_1_match is True and quadruplet_2_match is True and quadruplet_3_match is True:\n                                                        new_quadruplet = False\n                                                        logger.info(\n                                                            \"Quadruplet is already in list of unique quadruplets. \\n Quadruplet: %s\", quadruplet)\n                                                        break\n\n                                                if new_quadruplet is True:\n                                                    self.guesses_four_unique.append(\n                                                        [current_guess.guess_lst, guess.guess_lst, guess2.guess_lst, guess3.guess_lst])\n                                                    logger.info(\n                                                        \"Quadruplet is not already in list of unique quadruplets. Adding quadruplet to list. \\n Quadruplet: %s\", [current_guess.guess_lst, guess.guess_lst, guess2.guess_lst, guess3.guess_lst])\n        logger.info(\"Finished redoing unique guesses.\")\n        if len(self.guesses_two_unique) == 0 and len(self.guesses_three_unique) == 0 and len(self.guesses_four_unique) == 0:\n            logger.info(\"No unique pairs, triplets, or quadruplets of guesses.\")\n        if len(self.guesses_two_unique) > 0:\n            logger.info(\"Unique pairs of guesses: %s\", len(self.guesses_two_unique))\n            for pair in self.guesses_two_unique:\n                logger.info(\"Pair: %s\", pair)\n        if len(self.guesses_three_unique) > 0:\n            logger.info(\"Unique triplets of guesses: %s\", len(self.guesses_three_unique))\n            for triplet in self.guesses_three_unique:\n                logger.info(\"Triplet: %s\", triplet)\n        if len(self.guesses_four_unique) > 0:\n            logger.info(\"Unique quadruplets of guesses: %s\", len(self.guesses_four_unique))\n            for quadruplet in self.guesses_four_unique:\n                logger.info(\"Quadruplet: %s\", quadruplet)\n    \n    def submit_guess_final(self, guess):\n        # If the length of words_remain_lst is 8, make sure the four words not in the guess are not in a guess in the bad guesses list\n        if len(self.words_remain_lst) == 8:\n            bad_guess_check_lst = []\n            for word in self.words_remain_lst:\n                if word not in guess.guess_lst:\n                    bad_guess_check_lst.append(word)\n            for bad_guess in self.bad_guesses:\n                if set(bad_guess_check_lst) == set(bad_guess.guess_lst):\n                    logger.info(\"Words in guess to be submitted are the other half of four words that are a bad guess. Not submitting.\")\n                    self.guesses_final.remove(guess)\n                    match_bad_guess = False\n                    for bad_guess in self.logically_bad_guesses_lst:\n                        if set(bad_guess) == set(guess.guess_lst):\n                            match_bad_guess = True\n                            break\n                    if match_bad_guess is False:\n                        logger.info(\"Adding guess to logically bad guesses list: %s\", guess.guess_lst)\n                        self.logically_bad_guesses_lst.append(guess.guess_lst)\n                    guess.guess_is_correct = False\n                    return\n        guess.do_submit()\n        self.guesses_submitted.append(guess)\n        if guess in self.guesses_final:\n            self.guesses_final.remove(guess)\n        if guess.guess_is_correct is True:\n            self.good_guesses.append(guess)\n            self.good_guesses_lst.append(guess.guess_lst)\n            # Extend the words_excluded_lst to include each word in the guess_lst\n            self.words_solved_lst.extend(guess.guess_lst)\n            # Make words_remain_lst be words_lst minus words_solved_lst\n            self.words_remain_lst = list(\n                set(self.puzzle.words_lst) - set(self.words_solved_lst))\n            # Iterate over a copy of the list using slicing [:]\n            for guess_ready in self.guesses_ready_to_submit[:]:\n                if all(word in self.words_remain_lst for word in guess_ready.guess_lst):\n                    logger.info(\"Guess ready to submit still valid: %s\",\n                                guess_ready.guess_lst)\n                else:\n                    logger.info(\"Guess ready to submit no longer valid: %s\",\n                                guess_ready.guess_lst)\n                    self.guesses_ready_to_submit.remove(guess_ready)\n            for guess_ready in self.guesses_final[:]:\n                if all(word in self.words_remain_lst for word in guess_ready.guess_lst):\n                    logger.info(\"Guess final still valid: %s\",\n                                guess_ready.guess_lst)\n                else:\n                    logger.info(\"Guess final no longer valid: %s\",\n                                guess_ready.guess_lst)\n                    self.guesses_final.remove(guess_ready)\n        else:\n            self.bad_guesses.append(guess)\n            self.bad_guesses_lst.append(guess.guess_lst)\n            guess_set = set(guess.guess_lst)\n            for guess_ready in self.guesses_ready_to_submit[:]:\n                if guess_set == set(guess_ready.guess_lst):\n                    self.guesses_ready_to_submit.remove(guess_ready)\n                    logger.info(\"Removed matching guess from guesses ready to submit: %s\",guess_ready.guess_lst)\n            for guess_final in self.guesses_final[:]:\n                if guess_set == set(guess_final.guess_lst):\n                    self.guesses_final.remove(guess_final)\n                    logger.info(\"Removed matching guess from guesses final: %s\",guess_final.guess_lst)\n                \n            if len(self.words_remain_lst) == 8:\n                logger.info(\"Only eight words left. Other four words not in bad guess must also be bad guesses.\")\n                logically_bad_guess = []\n                for word in self.words_remain_lst:\n                    if word not in guess.guess_lst:\n                        logically_bad_guess.append(word)\n                self.logically_bad_guesses_lst.append(logically_bad_guess)\n                logger.info(\"Logically bad guesses list: %s\", self.logically_bad_guesses_lst)\n                        \n            logger.debug(\"Number of bad guesses: %s\",\n                            len(self.bad_guesses_lst))\n                \n\n    def save_summary_detailed_thorough(self):\n        \"\"\"Save a summary of the results as a markdown file.\"\"\"\n        timestamp = get_timestamp()\n        filename = f\"summary_detailed_thorough_puzzle{self.puzzle.number}_o1-preview_{timestamp}.md\"\n        filepath = os.path.join(self.path_md, filename)\n        with open(\n            filepath,\n            'w', encoding='utf-8'\n        ) as f:\n            f.write(f\"# Summary of Puzzle {self.puzzle.number}\\n\\n\")\n            f.write(f\"Date: {get_date()}\\n\")\n            f.write(f\"Model: o1-preview\\n\")\n            minutes, seconds = divmod(self.solve_time, 60)\n\n            if self.puzzle.emoji_dict is not None:\n                f.write(\"\\n\")\n                for guess in self.guesses_submitted:\n                    for word in guess.guess_lst:\n                        square_emoji = self.puzzle.emoji_dict.get(\n                            word, (emoji.emojize(':red_question_mark:')))\n                        f.write(f\"{square_emoji}\")\n                    f.write(\"\\n\")\n\n            if self.success is True:\n                f.write(\"## Success!\\n\\n\")\n                f.write(\n                    f\"Solved in {int(minutes)} minutes and {int(seconds)} seconds \\n\\n\")\n            else:\n                f.write(\"## Failure!\\n\\n\")\n                f.write(\n                    f\"Wasted {int(minutes)} minutes and {int(seconds)} seconds on this dumb puzzle.\\n\\n\")\n            num_good_guesses = len(self.good_guesses_lst)\n            num_bad_guesses = len(self.bad_guesses_lst)\n            f.write(f\"Correct guesses: {num_good_guesses}\\n\")\n            f.write(f\"Incorrect guesses: {num_bad_guesses}\\n\\n\")\n            f.write(\"## Submitted Guesses\\n\\n\")\n            for guess in self.guesses_submitted:\n                f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                if guess.guess_is_correct:\n                    f.write(\"Correct: \")\n                else:\n                    f.write(\"Incorrect: \")\n                guess_str = \" \".join(guess.guess_lst)\n                f.write(f\"{guess_str}\\n\\n\")\n            f.write(\"## Solution\\n\\n\")\n            for solution in self.puzzle.solution_lst:\n                solution_str = \" \".join(solution)\n                f.write(f\"{solution_str}\\n\\n\")\n            # New detailed parts (everything above is same as save_summary)\n            if len(self.evaluations) > 0:\n                f.write(\"## Evaluations\\n\\n\")\n                for response in self.evaluations:\n                    f.write(\n                        f\"### Evaluation {self.evaluations.index(response) + 1}\\n\\n\")\n                    f.write(f\"{response.output}\\n\\n\")\n            f.write(\"## Submitted Guesses Play-By-Play\\n\\n\")\n            for guess in self.guesses_submitted:\n                f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                if guess.guess_is_correct:\n                    f.write(\"Correct: \")\n                else:\n                    f.write(\"Incorrect: \")\n                guess_str = \" \".join(guess.guess_lst)\n                f.write(f\"{guess_str}\\n\\n\")\n                f.write(\"Reasoning:\\n\")\n                reasoning = \"\"\n                if len(guess.guess_rationale) > 0:\n                    reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                    # Modify reasoning string so that all \"# \" are \"## \"\n                    reasoning = re.sub(\n                        r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                    f.write(f\"{reasoning}\")\n                elif guess == self.guesses_submitted[-1] and self.success:\n                    f.write(\n                        \"(Automatically chosen by application because it was the only option left.).\\n\\n\")\n            if len(self.guesses_processed) > len(self.guesses_submitted):\n                f.write(\"## All Guesses Play-By-Play\\n\\n\")\n                for guess in self.guesses_processed:\n                    guess_str = \" \".join(guess.guess_lst)\n                    f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                    if guess.guess_was_submitted:\n                        if guess.guess_is_correct:\n                            f.write(\"Submitted and Correct: \")\n                        else:\n                            f.write(\"Submitted and Incorrect: \")\n                        guess_str = \" \".join(guess.guess_lst)\n                        f.write(f\"Guess: {guess_str}\\n\\n\")\n                        f.write(\"Reasoning:\\n\")\n                        reasoning = \"\"\n                        if len(guess.guess_rationale) > 0:\n                            reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                            # Modify reasoning string so that all \"# \" are \"## \"\n                            reasoning = re.sub(\n                                r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                            f.write(f\"{reasoning}\")\n                        elif guess == self.guesses_submitted[-1] and self.success:\n                            f.write(\n                                \"(Automatically chosen by application because it was the only option left.).\\n\\n\")\n                    elif len(guess.guess_rationale) > 0:\n                        f.write(f\"Guess: {guess_str}\\n\\n\")\n                        f.write(\"Reasoning:\\n\")\n                        reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                        # Modify reasoning string so that all \"# \" are \"## \"\n                        reasoning = re.sub(\n                            r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                        f.write(f\"{reasoning}\")\n                    elif guess.guess_is_valid is False:\n                        f.write(\n                            \"Rejected because guess has formatting or content error: \")\n                        guess_str = \" \".join(guess.guess_lst)\n                        f.write(f\"Guess: {guess_str}\\n\\n\")\n                    elif guess.good_options_for_guess is False:\n                        f.write(\"Rejected because no good options for guess: \")\n                        reasoning = \"\"\n                        for response in guess.discern.decide_cot_responses:\n                            reasoning += f\"{response.output}\\n\\n\"\n                        # Modify reasoning string so that all \"# \" are \"## \"\n                        reasoning = re.sub(\n                            r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                        f.write(f\"{reasoning}\")\n        logger.info(\"Saved detailed summary to %s\", filepath)\n"}
{"type": "source_file", "path": "src/solve_vanilla.py", "content": "\"\"\"SolveVanilla class is a class the  solves the Connections puzzle using a Vanilla/Naked/Simple approach.\n\"\"\"\n\nimport logging\nimport time\n\nfrom src.utils_llm import (\n    LLMSettings,\n    llm_call\n)\nfrom src.baseclass import BaseClass\nfrom src.solve import BaseSolver\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.guess_vanilla import GuessVanilla\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass SolveVanilla(BaseSolver):\n    \"\"\"SolveVanilla class is a class the  solves the Connections puzzle using a Vanilla/Naked/Simple approach.\n    \"\"\"\n    \n    def __init__(self,\n                 puzzle\n                 ):\n        super().__init__()\n        self.puzzle = puzzle\n        self.words_remain_lst = puzzle.words_lst\n    \n    def set_path_vanilla(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        self.set_path(name=\"solve_vanilla\")\n    \n    def solve_puzzle_vanilla(self):\n        \"\"\"Solve the puzzle using the vanilla method.\n        \"\"\"\n        start_time = time.time()\n        logger.info(\"Solving puzzle using Vanilla approach. \\n Words in puzzle: \\n %s \\n Solution: \\n %s\",\n                    self.puzzle.words_lst, self.puzzle.solution_lst)\n\n        if len(self.guesses_processed) == 0:\n\n            self.current_guess = None\n            self.guesses_processed = []\n            self.guesses_ready_to_submit = []\n            self.guesses_submitted = []\n            self.good_guesses = []\n            self.good_guesses_lst = []\n            self.bad_guesses = []\n            self.bad_guesses_lst = []\n            self.end_game = False\n            self.success = False\n        while self.end_game is False:\n            \n            # If the guesses ready to submit list has any guesses in it, submit the guess.\n            if len(self.guesses_ready_to_submit) > 0:\n                for guess in self.guesses_ready_to_submit:\n                    guess.do_submit()\n                    self.guesses_submitted.append(guess)\n                    # Remove from the list of guesses ready to submit\n                    self.guesses_ready_to_submit.remove(guess)\n                    if guess.guess_is_correct is True:\n                        self.good_guesses.append(guess)\n                        self.good_guesses_lst.append(guess.guess_lst)\n                        # Extend the words_excluded_lst to include each word in the guess_lst\n                        self.words_solved_lst.extend(guess.guess_lst)\n                        # Make words_remain_lst be words_lst minus words_solved_lst\n                        self.words_remain_lst = list(\n                            set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                        # Iterate over a copy of the list using slicing [:]\n                        for guess_ready in self.guesses_ready_to_submit[:]:\n                            if all(word in self.words_remain_lst for word in guess_ready.guess_lst):\n                                logger.info(\"Guess ready to submit still valid: %s\",\n                                            guess_ready.guess_lst)\n                            else:\n                                logger.info(\"Guess ready to submit no longer valid: %s\",\n                                            guess_ready.guess_lst)\n                                self.guesses_ready_to_submit.remove(guess_ready)\n                    else:\n                        self.bad_guesses.append(guess)\n                        self.bad_guesses_lst.append(guess.guess_lst)\n                        logger.debug(\"Number of bad guesses: %s\",\n                                    len(self.bad_guesses_lst))\n          \n\n            # If there are only four words left to solve, submit the guess that solves them.\n            if len(self.good_guesses) == 3:\n                logger.info(\"Only one possible solution left. Submitting.\")\n                self.current_guess = GuessVanilla(self)\n                self.current_guess.guess_lst = self.words_remain_lst\n                self.current_guess.do_submit()\n                if self.current_guess.guess_was_submitted is True:\n                    self.guesses_submitted.append(self.current_guess)\n                    if self.current_guess.guess_is_correct is True:\n                        self.good_guesses.append(self.current_guess)\n                        self.good_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        # Extend the words_excluded_lst to include each word in the guess_lst\n                        self.words_solved_lst.extend(\n                            self.current_guess.guess_lst)\n                        # Make words_remain_lst be words_lst minus words_solved_lst\n                        self.words_remain_lst = list(\n                            set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                    else:\n                        self.bad_guesses.append(self.current_guess)\n                        self.bad_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        logger.debug(\"Number of bad guesses: %s\",\n                                     len(self.bad_guesses_lst))\n            self.check_end_game_conditions()\n\n\n            # If the puzzle is not done, create a new guess\n            if self.end_game is False:\n                # Create a new guess\n                self.current_guess = GuessVanilla(self)\n                guesses_ready_to_submit_str = \"\"\n                for guess in self.guesses_ready_to_submit:\n                    guess_str = \"Guess: \\n\"\n                    guess_str += \" \".join(guess.guess_lst)\n                    guess_str += \"\\n Rationale: \\n\"\n                    guess_str += guess.guess_rationale\n                    guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n                logger.info(\"Starting New Guess! \\n Current guess number: %s \\n %s words remaining: \\n %s  \\n %s good guesses so far: \\n %s \\n %s bad guesses so far: \\n %s \\n %s guesses ready to submit: \\n %s\",\n                            self.current_guess.num_of_guess, len(self.words_remain_lst), self.words_remain_lst, len(self.good_guesses_lst), self.good_guesses_lst, len(self.bad_guesses_lst), self.bad_guesses_lst, len(self.guesses_ready_to_submit), guesses_ready_to_submit_str)\n                self.current_guess.process_guess()\n                self.guesses_processed.append(self.current_guess)\n                # If the current guess failed because of an error, start over from the beginning.\n                if self.current_guess.guess_is_valid is False:\n                    logger.info(\n                        \"Guess is not a valid guess to submit because of a formatting or content error. Starting over.\")\n                # If the current guess is ready to submit, add it to the list of guesses ready to submit.\n                if self.current_guess.guess_is_ready_to_submit is True:\n                    self.guesses_ready_to_submit.append(self.current_guess)\n                    logger.info(\"Guess is ready to submit. Adding to list.\")\n\n        self.solve_time = time.time() - start_time\n        minutes, seconds = divmod(self.solve_time, 60)\n        minutes = int(minutes)\n        seconds = int(seconds)\n        logger.info(\"Puzzle finished in %s minutes and %s seconds.\",\n                    minutes, seconds)\n        self.save_results_dict()\n        if self.puzzle.solution_lst is not None:\n            self.save_summary()\n        else:\n            self.save_summary_no_solution()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                             name=f\"puzzle_{self.puzzle.number}_vanilla\")\n"}
{"type": "source_file", "path": "src/solve_actor_2.py", "content": "\"\"\"SolveActor2 class is a class that solves the Connections puzzle using Actor-2 approach.\n\"\"\"\n\nimport logging\nimport os\nimport re\nimport copy\nimport time\nimport emoji\nimport random\n\nfrom src.utils_llm import (\n    llm_call\n)\nfrom src.baseclass import BaseClass\nfrom src.solve import BaseSolver\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.guess_actor_2 import GuessActor2\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass SolveActor2(BaseSolver):\n    \"\"\"SolveActor2 class is a class that solves the Connections puzzle using Actor-2 approach.\n    \"\"\"\n    \n    def __init__(self,\n                 puzzle\n    ):\n        super().__init__()\n        self.puzzle = puzzle\n        self.llm_settings = puzzle.llm_settings\n        self.words_remain_lst = puzzle.words_lst\n        # Evaluations of multiple guesses\n        self.evaluations = []\n        # Number of brainstorming templates\n        self.templates_num = 24\n        # Where previous guess left off going through brainstorm templates\n        self.templates_index = 0\n        # New variables for Experiment Two\n        # List of final guesses to submit\n        self.guesses_final = []\n        # Temporary words remain list\n        self.temp_words_remain_lst = []\n        # Guesses that have not been submitted but as a matter of logic based on other bad guesses must also be bad guesses\n        self.logically_bad_guesses_lst = []\n        \n    \n    def set_path_actor_2(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        self.set_path(name=\"solve_actor_2\")\n \n    def solve_puzzle_actor_2(self):\n        \"\"\"Solve the puzzle using the Actor-2 approach.\n        \"\"\"\n        start_time = time.time()\n        logger.info(\"Solving puzzle using Actor-2 method. \\n Words in puzzle: \\n %s \\n Solution: \\n %s\",\n                    self.puzzle.words_lst, self.puzzle.solution_lst)\n        # Set self.templates_num to the number of brainstorming templates\n        folder = os.path.join(get_root_dir(), 'data', 'templates')\n        files = [file for file in os.listdir(folder) if file.endswith('.txt')]\n        self.templates_num = len(files)\n        logger.info(\"Number of brainstorming templates: %s\", self.templates_num)\n        if len(self.guesses_processed) == 0:\n\n            self.current_guess = None\n            self.guesses_processed = []\n            self.guesses_ready_to_submit = []\n            self.guesses_final = []\n            self.guesses_submitted = []\n            self.good_guesses = []\n            self.good_guesses_lst = []\n            self.bad_guesses = []\n            self.bad_guesses_lst = []\n            self.end_game = False\n            self.success = False\n        while self.end_game is False:\n\n            \n            # If the puzzle is not solved, create a new guess\n            if self.end_game is False:\n                \n                logger.info(\"Start of process. \\n New Guess!\")\n                self.temp_words_remain_lst = self.words_remain_lst.copy()\n                logger.info(\"Temporary words remain list set to words list: %s\", self.temp_words_remain_lst)\n                \n                if len(self.good_guesses) <= 1:\n                    logger.info(\"0 or 1 Good guesses. Setting temporary words remain list.\")    \n                    if len(self.guesses_ready_to_submit) >= 2:\n                        # If the words in the last guess in ready to submit have already come up twice in the\n                        # ready to submit list, remove them from the temporary words remain list\n                        set_last_guess_lst = set(self.guesses_ready_to_submit[-1].guess_lst)\n                        count_appearance_last_guess = 0\n                        for guess in self.guesses_ready_to_submit:\n                            if set_last_guess_lst == set(guess.guess_lst):\n                                count_appearance_last_guess += 1\n                        if count_appearance_last_guess >= 2:\n                            logger.info(\"Last guess ready to submit has appeared twice or more. Removing from temporary words remain list.\")\n                            for word in self.guesses_ready_to_submit[-1].guess_lst:\n                                self.temp_words_remain_lst.remove(word)\n                            logger.info(\"Temporary words remain list after removing last guess ready to submit: %s\", self.temp_words_remain_lst)                        \n                    if len(self.guesses_final) > 0 and len(self.good_guesses) == 0:\n                        # Pick a random number either 0 or 1\n                        random_removal_num = random.randint(0, 1)\n                        # If the random number is 1, remove all words from a random guess in the final guesses list from the temporary words remain list\n                        if random_removal_num == 1:\n                            random_guess_final = random.choice(self.guesses_final)\n                            for word in random_guess_final.guess_lst:\n                                if word in self.temp_words_remain_lst:\n                                    self.temp_words_remain_lst.remove(word)\n                            logger.info(\"Temporary words remain list after removing random guess from final guesses: %s\", self.temp_words_remain_lst)\n                        else:\n                            logger.info(\"Random number was 0. Not removing words from temporary words remain list based on a random guess from final guesses.\")\n                elif len(self.good_guesses) == 2:\n                    logger.info(\"Two good guesses. Setting temporary words remain list.\")\n                    if len(self.bad_guesses) < 2:\n                        logger.info(\"Fewer than two bad guesses. Keeping all words in temporary words remain list as is.\")\n                    elif len(self.bad_guesses) == 2:\n                        random_single_mole_num = random.randint(0, 1)\n                        for i, guess_lst in enumerate(self.good_guesses_lst):\n                            if i == random_single_mole_num:\n                                random_mole_word = random.choice(guess_lst)\n                                self.temp_words_remain_lst.append(random_mole_word)\n                                logger.info(\"Two bad guesses. Including one random 'mole' word in temporary words remain list. \\n %s\", self.temp_words_remain_lst)\n                    else:\n                        for guess_lst in self.good_guesses_lst:\n                            random_mole_word = random.choice(guess_lst)\n                            self.temp_words_remain_lst.append(random_mole_word)\n                            logger.info(\"Three bad guesses. Including two random 'mole' words (one from each guess in good_guesses).\")           \n                # Create a new guess\n                self.current_guess = GuessActor2(self)\n                guesses_ready_to_submit_str = \"Guesses ready to submit: \\n\"\n                for guess in self.guesses_ready_to_submit:\n                    guess_str = \"Guess: \\n\"\n                    guess_str += \" \".join(guess.guess_lst)\n                    guess_str += \"\\n Rationale: \\n\"\n                    guess_str += guess.guess_rationale\n                    guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n                guesses_final_str = \"Final guesses: \\n\"\n                for guess in self.guesses_final:\n                    guess_str = \"Guess: \\n\"\n                    guess_str += \" \".join(guess.guess_lst)\n                    guess_str += \"\\n Rationale: \\n\"\n                    guess_str += guess.guess_rationale\n                    guesses_final_str += f\"{guess_str}\\n\"\n                logger.info(\"Starting New Guess! \\n Current guess number: %s \\n %s words remaining \\n Temporary word remain list: \\n %s  \\n %s good guesses so far: \\n %s \\n %s bad guesses so far: \\n %s \\n %s guesses ready to submit: \\n %s  \\n %s final guesses: \\n %s\",\n                            self.current_guess.num_of_guess, len(self.words_remain_lst), self.words_remain_lst, len(self.good_guesses_lst), self.good_guesses_lst, len(self.bad_guesses_lst), self.bad_guesses_lst, len(self.guesses_ready_to_submit), guesses_ready_to_submit_str, len(self.guesses_final), guesses_final_str)\n                self.current_guess.process_guess()\n                self.guesses_processed.append(self.current_guess)\n\n                if self.current_guess.good_options_for_guess is False:\n                    logger.info(\n                        \"No good options for guess. Starting over.\")\n\n                # If the current guess failed because of an error, start over from the beginning.\n                if self.current_guess.guess_is_valid is False:\n                    logger.info(\n                        \"Guess is not a valid guess to submit because of a formatting or content error. Starting over.\")\n\n                # If the current guess is ready to submit, add it to the list of guesses ready to submit.\n                if self.current_guess.guess_is_ready_to_submit is True:\n                    self.guesses_ready_to_submit.append(self.current_guess)\n                    logger.info(\"Guess is ready to submit. Adding to list.\")\n            \n            if len(self.good_guesses) < 2:\n                logger.info(\"Fewer than two good guesses.\")\n                if len(self.guesses_final) == 0:\n                    logger.info(\"Final guesses list is empty.\")\n                    if len(self.guesses_ready_to_submit) >= 5:\n                        logger.info(\"Five or more guesses ready to submit. Evaluating now.\")\n                        self.evaluate_guesses_ready_to_submit_all()\n                else:\n                    logger.info(\"Final guesses list is not empty.\")\n                    if len(self.guesses_ready_to_submit) >= 5:\n                        no_overlap_count = 0\n                        for guess in self.guesses_ready_to_submit:\n                            for guess_final in self.guesses_final:\n                                if set(guess.guess_lst) != set(guess_final.guess_lst):\n                                    no_overlap_count += 1\n                            for guess_good in self.good_guesses:\n                                if set(guess.guess_lst) != set(guess_good.guess_lst):\n                                    no_overlap_count += 1\n                            if no_overlap_count >= 2:\n                                logger.info(\"Two or more guesses do not overlap with final guesses or good guesses. Five or more guesses ready to submit. Evaluating now.\")\n                                self.evaluate_guesses_ready_to_submit_all()\n                                break\n                \n                # If there are two non-overlapping guesses in guesses_final, start submitting.\n                guesses_two_no_overlap = []\n                for current_guess in self.guesses_final:\n                    # Only proceed if the current guess is not already in guesses_two_no_overlap\n                    if current_guess not in guesses_two_no_overlap:\n                        for match_guess in self.guesses_final:\n                            logger.debug(\"Checking overlap between guesses: %s and %s\",\n                                        current_guess.guess_lst, match_guess.guess_lst)\n                            overlap = False\n                            for word in current_guess.guess_lst:\n                                if word in match_guess.guess_lst:\n                                    overlap = True\n                            if overlap is False:\n                                logger.info(\"No overlap between guesses: %s and %s\",\n                                            current_guess.guess_lst, match_guess.guess_lst)\n                                guesses_two_no_overlap.append(current_guess)\n                                guesses_two_no_overlap.append(match_guess)\n                if len(guesses_two_no_overlap) == 2:\n                    logger.info(\"Two non-overlapping guesses in guesses_final. Submitting.\")\n                    # Submit the guess with fewer words in common with other guesses\n                    guess0_words_in_common = 0\n                    guess1_words_in_common = 0\n                    for word in guesses_two_no_overlap[0].guess_lst:\n                        for guess in self.guesses_final:\n                            if word in guess.guess_lst:\n                                guess0_words_in_common += 1\n                    for word in guesses_two_no_overlap[1].guess_lst:\n                        for guess in self.guesses_final:\n                            if word in guess.guess_lst:\n                                guess1_words_in_common += 1\n                    logger.info(\" %s words in common in final guesses with %s /n %s words in common in final guesses with %s.\",\n                                guess0_words_in_common, guesses_two_no_overlap[0].guess_lst, guess1_words_in_common, guesses_two_no_overlap[1].guess_lst)\n                    if guess0_words_in_common <= guess1_words_in_common:\n                        logger.info(\"Submitting %s\", guesses_two_no_overlap[0].guess_lst)\n                        self.submit_guess_final(guesses_two_no_overlap[0])\n                        # if submission is good, submit the other one\n                        if guesses_two_no_overlap[0].guess_is_correct is True:\n                            logger.info(\"Submitting %s\", guesses_two_no_overlap[1].guess_lst)\n                            self.submit_guess_final(guesses_two_no_overlap[1])\n                    elif guess1_words_in_common < guess0_words_in_common:\n                        logger.info(\"Submitting %s\", guesses_two_no_overlap[1].guess_lst)\n                        self.submit_guess_final(guesses_two_no_overlap[1])\n                        # if submission is good, submit the other one\n                        if guesses_two_no_overlap[1].guess_is_correct is True:\n                            logger.info(\"Submitting %s\", guesses_two_no_overlap[0].guess_lst)\n                            self.submit_guess_final(guesses_two_no_overlap[0])\n                elif len(guesses_two_no_overlap) > 2:\n                    logger.info(\"Three or more non-overlapping guesses in guesses_final. Submitting one.\")\n                    # Submit the guess that doesn't have words in common with the other guesses\n                    for guess in guesses_two_no_overlap:\n                        words_in_common = 0\n                        for word in guess.guess_lst:\n                            for match_guess in guesses_two_no_overlap:\n                                # Only check if the guess is not the same as the match_guess\n                                if guess != match_guess:\n                                    if word in match_guess.guess_lst:\n                                        words_in_common += 1\n                                        logger.debug(\"%s has words in common with %s\", guess.guess_lst, match_guess.guess_lst)\n                        if words_in_common == 0:\n                            logger.info(\"Unique guess! Submitting %s\", guess.guess_lst)\n                            self.submit_guess_final(guess)\n                            break\n                \n                # If there are three identical guesses in guesses_final, submit one of them.\n                guesses_three_identical = []\n                for current_guess in self.guesses_final:\n                    guesses_three_identical = []\n                    guesses_three_identical.append(current_guess)\n                    for match_guess in self.guesses_final:\n                        if current_guess != match_guess:\n                            if set(current_guess.guess_lst) == set(match_guess.guess_lst):\n                                guesses_three_identical.append(match_guess)\n                    if len(guesses_three_identical) == 3:\n                        logger.info(\"Three identical guesses in guesses_final. \\n %s \\n %s \\n %s \\n Submitting one.\",\n                                    guesses_three_identical[0].guess_lst, guesses_three_identical[1].guess_lst, guesses_three_identical[2].guess_lst)\n                        self.submit_guess_final(guesses_three_identical[0])\n                        break\n                    \n                            \n            if len(self.good_guesses) == 2:\n                logger.info(\"Two good guesses.\")\n                if len(self.guesses_ready_to_submit) >= 3:\n                    logger.info(\"Three or more guesses ready to submit. Evaluating now.\")\n                    self.evaluate_guesses_ready_to_submit_all()\n                \n                # If there are two non-overlapping guesses in guesses_final, start submitting.\n                guesses_two_no_overlap = []\n                for current_guess in self.guesses_final:\n                    # Only proceed if the current guess is not already in guesses_two_no_overlap\n                    if current_guess not in guesses_two_no_overlap:\n                        for match_guess in self.guesses_final:\n                            logger.debug(\"Checking overlap between guesses: %s and %s\",\n                                        current_guess.guess_lst, match_guess.guess_lst)\n                            overlap = False\n                            for word in current_guess.guess_lst:\n                                if word in match_guess.guess_lst:\n                                    overlap = True\n                            if overlap is False:\n                                logger.info(\"No overlap between guesses: %s and %s\",\n                                            current_guess.guess_lst, match_guess.guess_lst)\n                                guesses_two_no_overlap.append(current_guess)\n                                guesses_two_no_overlap.append(match_guess)\n                if len(guesses_two_no_overlap) == 2:\n                    logger.info(\"Two non-overlapping guesses in guesses_final. Submitting.\")\n                    self.submit_guess_final(guesses_two_no_overlap[0])\n                    if guesses_two_no_overlap[0].guess_is_correct is True:\n                        logger.info(\"Submitting %s\", guesses_two_no_overlap[1].guess_lst)\n                        self.submit_guess_final(guesses_two_no_overlap[1])\n                    else:\n                        logger.info(\"Because the first guess was incorrect, removing %s from guesses_final\", guesses_two_no_overlap[1].guess_lst)\n                        self.guesses_final.remove(guesses_two_no_overlap[1])\n                elif len(self.guesses_final) > 1:\n                    # If there are two identical guesses in guesses_final, submit one of them.\n                    guesses_two_identical = []\n                    for current_guess in self.guesses_final:\n                        for match_guess in self.guesses_final:\n                            if current_guess != match_guess:\n                                if set(current_guess.guess_lst) == set(match_guess.guess_lst):\n                                    logger.info(\"Two identical guesses in guesses_final. Submitting one.\")\n                                    self.submit_guess_final(current_guess)\n                                    break\n                    if len(self.guesses_final) > 1 and len(self.guesses_processed) > 20:\n                        logger.info(\"More than one guess in guesses_final and more than 20 guesses processed. Returning to ready to submit list.\")\n                        # Go through self.guesses_final and add each guess to self.guesses_ready_to_submit\n                        for guess in self.guesses_final:\n                            self.guesses_ready_to_submit.append(guess)\n                        self.guesses_final = []\n                elif len(self.guesses_final) == 1 and len(self.guesses_processed) > 15:\n                    logger.info(\"One guess in guesses_final and more than 15 guesses processed. Submitting.\")\n                    for guess in self.guesses_final:\n                        self.submit_guess_final(guess)\n\n\n            # If there are only four words left to solve, submit the guess that solves them.\n            if len(self.good_guesses) == 3:\n                logger.info(\"Only one possible solution left. Submitting.\")\n                self.current_guess = GuessActor2(self)\n                self.current_guess.guess_lst = self.words_remain_lst\n                self.current_guess.do_submit()\n                if self.current_guess.guess_was_submitted is True:\n                    self.guesses_submitted.append(self.current_guess)\n                    if self.current_guess.guess_is_correct is True:\n                        self.good_guesses.append(self.current_guess)\n                        self.good_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        # Extend the words_solved_lst to include each word in the guess_lst\n                        self.words_solved_lst.extend(\n                            self.current_guess.guess_lst)\n                        # Make words_remain_lst be words_lst minus words_solved_lst\n                        self.words_remain_lst = list(\n                            set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                    else:\n                        self.bad_guesses.append(self.current_guess)\n                        self.bad_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        logger.debug(\"Number of bad guesses: %s\",\n                                     len(self.bad_guesses_lst))\n            \n            self.check_end_game_conditions()\n\n        self.solve_time = time.time() - start_time\n        minutes, seconds = divmod(self.solve_time, 60)\n        minutes = int(minutes)\n        seconds = int(seconds)\n        logger.info(\"Puzzle finished in %s minutes and %s seconds.\",\n                    minutes, seconds)\n        self.save_results_dict()\n        self.save_outputs(filepath_md=self.path_md,\n                          name=f\"evaluations_puzzle_{self.puzzle.number}\",\n                          responses=self.evaluations\n                          )\n        if self.puzzle.solution_lst is not None:\n            self.save_summary()\n        else:\n            self.save_summary_no_solution()\n        self.save_summary_detailed_thorough()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                             name=f\"puzzle_{self.puzzle.number}_actor_2\")\n        \n\n    def evaluate_guesses_ready_to_submit_cot(self):\n        \"\"\"Decide which guesses are strongest for submitting.\"\"\"\n        # Load the system prompt from a .txt file\n        prompt_system = \"\"\n        if len(self.good_guesses) == 2:\n            with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_2', \"evaluate_guesses_cot_final.txt\"),\n                'r', encoding='utf-8') as f:\n                prompt = f.read()\n        else:\n            with open(os.path.join(\n                    get_root_dir(), 'data', 'prompts', 'actor_2', \"evaluate_guesses_cot.txt\"),\n                    'r', encoding='utf-8') as f:\n                prompt = f.read()\n        prompt_system += prompt\n        # Add guesses ready to submit to the prompt\n        guesses_ready_to_submit_str = \"\"\n        # Create a string of the guesses ready to submit\n        # Start by copying over guesses_ready_to_submit but not copying guesses that have the same set of words to submit\n        # We do this so that each unique guess is included only once and so that the LLM does not discount the value of these answers for overlapping with one another\n        guesses_ready_to_submit_no_overlap = []\n        # Make a deep copy of guesses_ready_to_submit\n        guesses_ready_copy = copy.deepcopy(self.guesses_ready_to_submit)\n        random.shuffle(guesses_ready_copy)\n        for guess in guesses_ready_copy:\n            overlap = False\n            for guess_no_overlap in guesses_ready_to_submit_no_overlap:\n                if set(guess.guess_lst) == set(guess_no_overlap.guess_lst):\n                    overlap = True\n            if overlap is False:\n                guesses_ready_to_submit_no_overlap.append(guess)\n        # Shuffle the guesses ready to submit\n        guesses_ready_shuffled = guesses_ready_to_submit_no_overlap.copy()\n        random.shuffle(guesses_ready_shuffled)\n        for guess in guesses_ready_shuffled:\n            guess_str = \"Guess: \\n\"\n            guess_str += \" \".join(guess.guess_lst)\n            guess_str += \"\\n Rationale: \\n\"\n            guess_str += guess.guess_rationale\n            guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n        prompt_system = prompt_system.replace(\n            \"{notes}\", guesses_ready_to_submit_str)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"What is your top choice for a guess to submit for this puzzle? {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        logger.debug(\"LLM response evaluate_cot: \\n %s\", llm_response.output)\n        return llm_response\n\n    def evaluate_guesses_ready_to_submit_select(self, notes_str):\n        \"\"\"Select the best guess to submit.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor_2', 'evaluate_guesses_select.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the notes_str\n        prompt_system = prompt_system.replace(\"{notes}\", notes_str)\n        # Create a user prompt\n        prompt_user = \"Please select the best guess to submit.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def evaluate_guesses_ready_to_submit_all(self):\n        \"\"\"Call on LLM to evaluate the guesses ready to submit and submit the best one.\"\"\"\n        guesses_ready_to_submit_str = \"\"\n        for guess in self.guesses_ready_to_submit:\n            guess_str = \"Guess: \\n\"\n            guess_str += \" \".join(guess.guess_lst)\n            guess_str += \"\\n Rationale: \\n\"\n            guess_str += guess.guess_rationale\n            guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n        logger.info(\"%s guesses are ready to submit. Evaluating now...  \\n %s\",\n                    len(self.guesses_ready_to_submit), guesses_ready_to_submit_str)\n        # Evaluate the guesses ready to submit\n        llm_response = self.evaluate_guesses_ready_to_submit_cot()\n        self.evaluations.append(llm_response)\n        # Select the best guess to submit\n        llm_response = self.evaluate_guesses_ready_to_submit_select(\n            llm_response.output)\n        # Turn the guess into a list of words and fix formatting\n        guess = llm_response.output\n        # Remove \"Output:\" from guess if it appears in the string\n        guess = guess.replace(\"Output:\", \"\").strip()\n        guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n        logger.info(\"Guess selected to submit: %s\", \" \".join(guess_lst))\n        # Identify the guess object that matches the guess selected to submit\n        guess_set = set(guess_lst)\n        # Check if the guess selected to submit matches any of the guesses ready to submit\n        match_guess = False\n        for guess in self.guesses_ready_to_submit:\n            # If guess_set is the same as the set of words in the guess, match_guess is True\n            if guess_set == set(guess.guess_lst):\n                match_guess = True\n                break\n        # If the guess selected to submit does not match any of the guesses ready to submit, start over\n        if match_guess is False:\n            logger.info(\"Guess selected to submit does not match any guesses ready to submit. Starting over.\")\n            return\n        for guess in self.guesses_ready_to_submit:\n            # If guess_set is the same as the set of words in the guess, add the guess to guesses_final\n            if guess_set == set(guess.guess_lst):\n                # Add the guess to guesses_final\n                self.guesses_final.append(guess)\n                # Remove from the list of guesses ready to submit\n                self.guesses_ready_to_submit.remove(guess)\n                # Remove any guesses from guesses ready to submit that have the same set of words as the guess selected to submit\n                for guess_ready in self.guesses_ready_to_submit[:]:\n                    if set(guess_ready.guess_lst) == guess_set:\n                        self.guesses_ready_to_submit.remove(guess_ready)\n                        logger.info(\"Removed guess from guesses ready to submit: %s\",\n                                    guess_ready.guess_lst)\n                break\n        for guess in self.guesses_ready_to_submit:\n            # Increment the count of how many times the guess has been evaluated for submission as a final guess.\n            guess.guess_eval_count += 1\n            logger.info(\"Guess %s has been evaluated %s times for submission as a final guess.\",\n                        guess.guess_lst, guess.guess_eval_count)\n            # Remove guesses that have been evaluated four or more times\n            if guess.guess_eval_count >= 4:\n                logger.info(\"Guess %s has been evaluated four or more times for submission as a final guess. Removing from consideration.\",\n                            guess.guess_lst)\n                self.guesses_ready_to_submit.remove(guess)\n    \n    def submit_guess_final(self, guess):\n        # If the length of words_remain_lst is 8, make sure the four words not in the guess are not in a guess in the bad guesses list\n        if len(self.words_remain_lst) == 8:\n            bad_guess_check_lst = []\n            for word in self.words_remain_lst:\n                if word not in guess.guess_lst:\n                    bad_guess_check_lst.append(word)\n            for bad_guess in self.bad_guesses:\n                if set(bad_guess_check_lst) == set(bad_guess.guess_lst):\n                    logger.info(\"Words in guess to be submitted are the other half of four words that are a bad guess. Not submitting.\")\n                    self.guesses_final.remove(guess)\n                    match_bad_guess = False\n                    for bad_guess in self.logically_bad_guesses_lst:\n                        if set(bad_guess) == set(guess.guess_lst):\n                            match_bad_guess = True\n                            break\n                    if match_bad_guess is False:\n                        logger.info(\"Adding guess to logically bad guesses list: %s\", guess.guess_lst)\n                        self.logically_bad_guesses_lst.append(guess.guess_lst)\n                    guess.guess_is_correct = False\n                    return\n        guess.do_submit()\n        self.guesses_submitted.append(guess)\n        if guess in self.guesses_final:\n            self.guesses_final.remove(guess)\n        if guess.guess_is_correct is True:\n            self.good_guesses.append(guess)\n            self.good_guesses_lst.append(guess.guess_lst)\n            # Extend the words_excluded_lst to include each word in the guess_lst\n            self.words_solved_lst.extend(guess.guess_lst)\n            # Make words_remain_lst be words_lst minus words_solved_lst\n            self.words_remain_lst = list(\n                set(self.puzzle.words_lst) - set(self.words_solved_lst))\n            # Iterate over a copy of the list using slicing [:]\n            for guess_ready in self.guesses_ready_to_submit[:]:\n                if all(word in self.words_remain_lst for word in guess_ready.guess_lst):\n                    logger.info(\"Guess ready to submit still valid: %s\",\n                                guess_ready.guess_lst)\n                else:\n                    logger.info(\"Guess ready to submit no longer valid: %s\",\n                                guess_ready.guess_lst)\n                    self.guesses_ready_to_submit.remove(guess_ready)\n            for guess_ready in self.guesses_final[:]:\n                if all(word in self.words_remain_lst for word in guess_ready.guess_lst):\n                    logger.info(\"Guess final still valid: %s\",\n                                guess_ready.guess_lst)\n                else:\n                    logger.info(\"Guess final no longer valid: %s\",\n                                guess_ready.guess_lst)\n                    self.guesses_final.remove(guess_ready)\n        else:\n            self.bad_guesses.append(guess)\n            self.bad_guesses_lst.append(guess.guess_lst)\n            guess_set = set(guess.guess_lst)\n            for guess_ready in self.guesses_ready_to_submit[:]:\n                if guess_set == set(guess_ready.guess_lst):\n                    self.guesses_ready_to_submit.remove(guess_ready)\n                    logger.info(\"Removed matching guess from guesses ready to submit: %s\",guess_ready.guess_lst)\n            for guess_final in self.guesses_final[:]:\n                if guess_set == set(guess_final.guess_lst):\n                    self.guesses_final.remove(guess_final)\n                    logger.info(\"Removed matching guess from guesses final: %s\",guess_final.guess_lst)\n                \n            if len(self.words_remain_lst) == 8:\n                logger.info(\"Only eight words left. Other four words not in bad guess must also be bad guesses.\")\n                logically_bad_guess = []\n                for word in self.words_remain_lst:\n                    if word not in guess.guess_lst:\n                        logically_bad_guess.append(word)\n                self.logically_bad_guesses_lst.append(logically_bad_guess)\n                logger.info(\"Logically bad guesses list: %s\", self.logically_bad_guesses_lst)\n                        \n            logger.debug(\"Number of bad guesses: %s\",\n                            len(self.bad_guesses_lst))\n                \n\n    def save_summary_detailed_thorough(self):\n        \"\"\"Save a summary of the results as a markdown file.\"\"\"\n        timestamp = get_timestamp()\n        filename = f\"summary_detailed_thorough_puzzle{self.puzzle.number}_{self.puzzle.llm_settings.model}_{timestamp}.md\"\n        filepath = os.path.join(self.path_md, filename)\n        with open(\n            filepath,\n            'w', encoding='utf-8'\n        ) as f:\n            f.write(f\"# Summary of Puzzle {self.puzzle.number}\\n\\n\")\n            f.write(f\"Date: {get_date()}\\n\")\n            f.write(f\"Model: {self.puzzle.llm_settings.model}\\n\")\n            minutes, seconds = divmod(self.solve_time, 60)\n\n            if self.puzzle.emoji_dict is not None:\n                f.write(\"\\n\")\n                for guess in self.guesses_submitted:\n                    for word in guess.guess_lst:\n                        square_emoji = self.puzzle.emoji_dict.get(\n                            word, (emoji.emojize(':red_question_mark:')))\n                        f.write(f\"{square_emoji}\")\n                    f.write(\"\\n\")\n\n            if self.success is True:\n                f.write(\"## Success!\\n\\n\")\n                f.write(\n                    f\"Solved in {int(minutes)} minutes and {int(seconds)} seconds \\n\\n\")\n            else:\n                f.write(\"## Failure!\\n\\n\")\n                f.write(\n                    f\"Wasted {int(minutes)} minutes and {int(seconds)} seconds on this dumb puzzle.\\n\\n\")\n            num_good_guesses = len(self.good_guesses_lst)\n            num_bad_guesses = len(self.bad_guesses_lst)\n            f.write(f\"Correct guesses: {num_good_guesses}\\n\")\n            f.write(f\"Incorrect guesses: {num_bad_guesses}\\n\\n\")\n            f.write(\"## Submitted Guesses\\n\\n\")\n            for guess in self.guesses_submitted:\n                f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                if guess.guess_is_correct:\n                    f.write(\"Correct: \")\n                else:\n                    f.write(\"Incorrect: \")\n                guess_str = \" \".join(guess.guess_lst)\n                f.write(f\"{guess_str}\\n\\n\")\n            f.write(\"## Solution\\n\\n\")\n            for solution in self.puzzle.solution_lst:\n                solution_str = \" \".join(solution)\n                f.write(f\"{solution_str}\\n\\n\")\n            # New detailed parts (everything above is same as save_summary)\n            if len(self.evaluations) > 0:\n                f.write(\"## Evaluations\\n\\n\")\n                for response in self.evaluations:\n                    f.write(\n                        f\"### Evaluation {self.evaluations.index(response) + 1}\\n\\n\")\n                    f.write(f\"{response.output}\\n\\n\")\n            f.write(\"## Submitted Guesses Play-By-Play\\n\\n\")\n            for guess in self.guesses_submitted:\n                f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                if guess.guess_is_correct:\n                    f.write(\"Correct: \")\n                else:\n                    f.write(\"Incorrect: \")\n                guess_str = \" \".join(guess.guess_lst)\n                f.write(f\"{guess_str}\\n\\n\")\n                f.write(\"Reasoning:\\n\")\n                reasoning = \"\"\n                if len(guess.guess_rationale) > 0:\n                    reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                    # Modify reasoning string so that all \"# \" are \"## \"\n                    reasoning = re.sub(\n                        r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                    f.write(f\"{reasoning}\")\n                elif guess == self.guesses_submitted[-1] and self.success:\n                    f.write(\n                        \"(Automatically chosen by application because it was the only option left.).\\n\\n\")\n            if len(self.guesses_processed) > len(self.guesses_submitted):\n                f.write(\"## All Guesses Play-By-Play\\n\\n\")\n                for guess in self.guesses_processed:\n                    guess_str = \" \".join(guess.guess_lst)\n                    f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                    if guess.guess_was_submitted:\n                        if guess.guess_is_correct:\n                            f.write(\"Submitted and Correct: \")\n                        else:\n                            f.write(\"Submitted and Incorrect: \")\n                        guess_str = \" \".join(guess.guess_lst)\n                        f.write(f\"Guess: {guess_str}\\n\\n\")\n                        f.write(\"Reasoning:\\n\")\n                        reasoning = \"\"\n                        if len(guess.guess_rationale) > 0:\n                            reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                            # Modify reasoning string so that all \"# \" are \"## \"\n                            reasoning = re.sub(\n                                r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                            f.write(f\"{reasoning}\")\n                        elif guess == self.guesses_submitted[-1] and self.success:\n                            f.write(\n                                \"(Automatically chosen by application because it was the only option left.).\\n\\n\")\n                    elif len(guess.guess_rationale) > 0:\n                        f.write(f\"Guess: {guess_str}\\n\\n\")\n                        f.write(\"Reasoning:\\n\")\n                        reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                        # Modify reasoning string so that all \"# \" are \"## \"\n                        reasoning = re.sub(\n                            r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                        f.write(f\"{reasoning}\")\n                    elif guess.guess_is_valid is False:\n                        f.write(\n                            \"Rejected because guess has formatting or content error: \")\n                        guess_str = \" \".join(guess.guess_lst)\n                        f.write(f\"Guess: {guess_str}\\n\\n\")\n                    elif guess.good_options_for_guess is False:\n                        f.write(\"Rejected because no good options for guess: \")\n                        reasoning = \"\"\n                        for response in guess.discern.decide_cot_responses:\n                            reasoning += f\"{response.output}\\n\\n\"\n                        # Modify reasoning string so that all \"# \" are \"## \"\n                        reasoning = re.sub(\n                            r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                        f.write(f\"{reasoning}\")\n        logger.info(\"Saved detailed summary to %s\", filepath)\n"}
{"type": "source_file", "path": "src/solve_one_shot_o1.py", "content": "\"\"\"SolveOneShoto1 class is a class the  solves the Connections puzzle using a one-shot approach with GPT-o1.\n\"\"\"\n\nimport logging\nimport os\nimport time\n\nfrom src.utils_llm import (\n    LLMSettings,\n    llm_call\n)\nfrom src.baseclass import BaseClass\nfrom src.solve import BaseSolver\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.guess_oneshot_o1 import GuessOneShoto1\n\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass SolveOneShoto1(BaseSolver):\n    \"\"\"SolveOneShoto1 class is a class the  solves the Connections puzzle using a one-shot approach with GPT-o1.\n    \"\"\"\n    \n    def __init__(self,\n                 puzzle\n                 ):\n        super().__init__()\n        self.puzzle = puzzle\n        self.words_remain_lst = puzzle.words_lst\n    \n    def set_path_oneshoto1(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        self.set_path(name=\"solve_oneshot_o1\")\n    \n    def solve_puzzle_oneshoto1(self):\n        \"\"\"Solve the puzzle using the oneshoto1 method.\n        \"\"\"\n        start_time = time.time()\n        logger.info(\"Solving puzzle using One-Shot o1 approach. \\n Words in puzzle: \\n %s \\n Solution: \\n %s\",\n                    self.puzzle.words_lst, self.puzzle.solution_lst)\n\n        if len(self.guesses_processed) == 0:\n\n            self.current_guess = None\n            self.guesses_processed = []\n            self.guesses_ready_to_submit = []\n            self.guesses_submitted = []\n            self.good_guesses = []\n            self.good_guesses_lst = []\n            self.bad_guesses = []\n            self.bad_guesses_lst = []\n            self.end_game = False\n            self.success = False\n        while self.end_game is False:\n            \n            # Create a new guess\n            self.current_guess = GuessOneShoto1(self)\n            guesses_ready_to_submit_str = \"\"\n            logger.info(\"Starting New Guess! \\n Current guess number: %s \\n %s words remaining: \\n %s  \\n %s good guesses so far: \\n %s \\n %s bad guesses so far: \\n %s \\n %s guesses ready to submit: \\n %s\",\n                        self.current_guess.num_of_guess, len(self.words_remain_lst), self.words_remain_lst, len(self.good_guesses_lst), self.good_guesses_lst, len(self.bad_guesses_lst), self.bad_guesses_lst, len(self.guesses_ready_to_submit), guesses_ready_to_submit_str)\n            self.current_guess.process_guess()\n            self.guesses_processed.append(self.current_guess)\n            self.guesses_submitted.append(self.current_guess)\n            self.good_guesses.append(self.current_guess)\n            self.good_guesses_lst.append(self.current_guess.guess_lst)\n            \n            self.end_game = True\n\n        self.solve_time = time.time() - start_time\n        minutes, seconds = divmod(self.solve_time, 60)\n        minutes = int(minutes)\n        seconds = int(seconds)\n        logger.info(\"Puzzle finished in %s minutes and %s seconds.\",\n                    minutes, seconds)\n        self.save_results_dict()\n        self.save_summary_oneshoto1()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                             name=f\"puzzle_{self.puzzle.number}_one_shot_o1\")\n\n    def save_summary_oneshoto1(self):\n        timestamp = get_timestamp()\n        filename = f\"summary_puzzle{self.puzzle.number}_o1-preview_{timestamp}.md\"\n        with open(\n            os.path.join(self.path_md, filename),\n            'w', encoding='utf-8'\n        ) as f:\n            f.write(f\"# Summary of Puzzle {self.puzzle.number}\\n\\n\")\n            f.write(f\"Date: {get_date()}\\n\")\n            f.write(f\"Model: o1-preview\\n\")\n            minutes, seconds = divmod(self.solve_time, 60)\n            f.write(\n                f\"Took {int(minutes)} minutes and {int(seconds)} seconds \\n\\n\")\n\n            f.write(\"## Guess\\n\\n\")\n            for guess in self.guesses_submitted:\n                f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                guess_str = \" \".join(guess.guess_lst)\n                f.write(f\"{guess_str}\\n\\n\")\n            f.write(\"## Solution\\n\\n\")\n            for solution in self.puzzle.solution_lst:\n                # Turn the solution into a string\n                solution_str = \" \".join(solution)\n                f.write(f\"{solution_str}\\n\\n\")\n        filepath = os.path.join(self.path_md, filename)\n        logger.info(\"Saved summary to %s\", filepath)\n"}
{"type": "source_file", "path": "src/solve_actor.py", "content": "\"\"\"SolveActor class is a class that solves the Connections puzzle using model of LLMs as method actors for designing prompts.\n\"\"\"\n\nimport logging\nimport os\nimport re\nimport time\nimport emoji\nimport random\n\nfrom src.utils_llm import (\n    llm_call\n)\n\nfrom src.baseclass import BaseClass\nfrom src.solve import BaseSolver\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\n\nfrom src.guess_actor import GuessActor\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass SolveActor(BaseSolver):\n    \"\"\"SolveActor class is a class that solves the Connections puzzle using model of LLMs as method actors for designing prompts.\n    \"\"\"\n    \n    def __init__(self,\n                 puzzle\n    ):\n        super().__init__()\n        self.puzzle = puzzle\n        self.llm_settings = puzzle.llm_settings\n        self.words_remain_lst = puzzle.words_lst\n        # Evaluations of multiple guesses\n        self.evaluations = []\n        # Number of brainstorming templates\n        self.templates_num = 24\n        # Where previous guess left off going through brainstorm templates\n        self.templates_index = 0\n        \n    \n    def set_path_actor(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        self.set_path(name=\"solve_actor\")\n \n    def solve_puzzle_actor(self):\n        \"\"\"Solve the puzzle using the method actor approach.\n        \"\"\"\n        start_time = time.time()\n        logger.info(\"Solving puzzle using Actor method. \\n Words in puzzle: \\n %s \\n Solution: \\n %s\",\n                    self.puzzle.words_lst, self.puzzle.solution_lst)\n        # Set self.templates_num to the number of brainstorming templates\n        folder = os.path.join(get_root_dir(), 'data', 'templates')\n        files = [file for file in os.listdir(folder) if file.endswith('.txt')]\n        self.templates_num = len(files)\n        logger.info(\"Number of brainstorming templates: %s\", self.templates_num)\n        if len(self.guesses_processed) == 0:\n\n            self.current_guess = None\n            self.guesses_processed = []\n            self.guesses_ready_to_submit = []\n            self.guesses_submitted = []\n            self.good_guesses = []\n            self.good_guesses_lst = []\n            self.bad_guesses = []\n            self.bad_guesses_lst = []\n            self.end_game = False\n            self.success = False\n        while self.end_game is False:\n            \n            # If the puzzle is not solved, create a new guess\n            if self.end_game is False:\n                # Create a new guess\n                self.current_guess = GuessActor(self)\n                guesses_ready_to_submit_str = \"\"\n                for guess in self.guesses_ready_to_submit:\n                    guess_str = \"Guess: \\n\"\n                    guess_str += \" \".join(guess.guess_lst)\n                    guess_str += \"\\n Rationale: \\n\"\n                    guess_str += guess.guess_rationale\n                    guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n                logger.info(\"Starting New Guess! \\n Current guess number: %s \\n %s words remaining: \\n %s  \\n %s good guesses so far: \\n %s \\n %s bad guesses so far: \\n %s \\n %s guesses ready to submit: \\n %s\",\n                            self.current_guess.num_of_guess, len(self.words_remain_lst), self.words_remain_lst, len(self.good_guesses_lst), self.good_guesses_lst, len(self.bad_guesses_lst), self.bad_guesses_lst, len(self.guesses_ready_to_submit), guesses_ready_to_submit_str)\n                self.current_guess.process_guess()\n                self.guesses_processed.append(self.current_guess)\n\n                if self.current_guess.good_options_for_guess is False:\n                    logger.info(\n                        \"No good options for guess. Starting over.\")\n\n                # If the current guess failed because of an error, start over from the beginning.\n                if self.current_guess.guess_is_valid is False:\n                    logger.info(\n                        \"Guess is not a valid guess to submit because of a formatting or content error. Starting over.\")\n\n                # If the current guess is ready to submit, add it to the list of guesses ready to submit.\n                if self.current_guess.guess_is_ready_to_submit is True:\n                    self.guesses_ready_to_submit.append(self.current_guess)\n                    logger.info(\"Guess is ready to submit. Adding to list.\")\n            \n            # If the guesses ready to submit list has enough guesses in it, evaluate them all and submit the best one.\n            while (\n                (len(self.good_guesses) < 2 and len(self.guesses_ready_to_submit) >= 5) or \n                (len(self.good_guesses) == 2 and len(self.guesses_ready_to_submit) >= 3)\n            ):\n                guesses_ready_to_submit_str = \"\"\n                for guess in self.guesses_ready_to_submit:\n                    guess_str = \"Guess: \\n\"\n                    guess_str += \" \".join(guess.guess_lst)\n                    guess_str += \"\\n Rationale: \\n\"\n                    guess_str += guess.guess_rationale\n                    guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n                logger.info(\"%s guesses are ready to submit. Evaluating now...  \\n %s\",\n                            len(self.guesses_ready_to_submit), guesses_ready_to_submit_str)\n                self.evaluate_guesses_ready_to_submit_all()\n\n            # If there are only four words left to solve, submit the guess that solves them.\n            if len(self.good_guesses) == 3:\n                logger.info(\"Only one possible solution left. Submitting.\")\n                self.current_guess = GuessActor(self)\n                self.current_guess.guess_lst = self.words_remain_lst\n                self.current_guess.do_submit()\n                if self.current_guess.guess_was_submitted is True:\n                    self.guesses_submitted.append(self.current_guess)\n                    if self.current_guess.guess_is_correct is True:\n                        self.good_guesses.append(self.current_guess)\n                        self.good_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        # Extend the words_solved_lst to include each word in the guess_lst\n                        self.words_solved_lst.extend(\n                            self.current_guess.guess_lst)\n                        # Make words_remain_lst be words_lst minus words_solved_lst\n                        self.words_remain_lst = list(\n                            set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                    else:\n                        self.bad_guesses.append(self.current_guess)\n                        self.bad_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        logger.debug(\"Number of bad guesses: %s\",\n                                     len(self.bad_guesses_lst))\n            \n            self.check_end_game_conditions()\n\n        self.solve_time = time.time() - start_time\n        minutes, seconds = divmod(self.solve_time, 60)\n        minutes = int(minutes)\n        seconds = int(seconds)\n        logger.info(\"Puzzle finished in %s minutes and %s seconds.\",\n                    minutes, seconds)\n        self.save_results_dict()\n        self.save_outputs(filepath_md=self.path_md,\n                          name=f\"evaluations_puzzle_{self.puzzle.number}\",\n                          responses=self.evaluations\n                          )\n        if self.puzzle.solution_lst is not None:\n            self.save_summary()\n        else:\n            self.save_summary_no_solution()\n        self.save_summary_detailed_thorough()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                             name=f\"puzzle_{self.puzzle.number}_actor\")\n        \n\n    def evaluate_guesses_ready_to_submit_cot(self):\n        \"\"\"Decide which guesses are strongest for submitting.\"\"\"\n        # Load the system prompt from a .txt file\n        prompt_system = \"\"\n        if len(self.good_guesses) == 2:\n            with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor', \"evaluate_guesses_cot_final.txt\"),\n                'r', encoding='utf-8') as f:\n                prompt = f.read()\n        else:\n            with open(os.path.join(\n                    get_root_dir(), 'data', 'prompts', 'actor', \"evaluate_guesses_cot.txt\"),\n                    'r', encoding='utf-8') as f:\n                prompt = f.read()\n        prompt_system += prompt\n        # Add guesses ready to submit to the prompt\n        guesses_ready_to_submit_str = \"\"\n        # Create a string of the guesses ready to submit\n        # Start by copying over guesses_ready_to_submit but not copying guesses that have the same set of words to submit\n        # We do this so that each unique guess is included only once and so that the LLM does not discount the value of these answers for overlapping with one another\n        guesses_ready_to_submit_no_overlap = []\n        for guess in self.guesses_ready_to_submit:\n            overlap = False\n            for guess_no_overlap in guesses_ready_to_submit_no_overlap:\n                if set(guess.guess_lst) == set(guess_no_overlap.guess_lst):\n                    overlap = True\n            if overlap is False:\n                guesses_ready_to_submit_no_overlap.append(guess)\n        # Next, shuffle the guesses ready to submit\n        guesses_ready_shuffled = guesses_ready_to_submit_no_overlap.copy()\n        random.shuffle(guesses_ready_shuffled)\n        for guess in guesses_ready_shuffled:\n            guess_str = \"Guess: \\n\"\n            guess_str += \" \".join(guess.guess_lst)\n            guess_str += \"\\n Rationale: \\n\"\n            guess_str += guess.guess_rationale\n            guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n        prompt_system = prompt_system.replace(\n            \"{notes}\", guesses_ready_to_submit_str)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"What is your top choice for a guess to submit for this puzzle? {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        logger.debug(\"LLM response evaluate_cot: \\n %s\", llm_response.output)\n        return llm_response\n\n    def evaluate_guesses_ready_to_submit_select(self, notes_str):\n        \"\"\"Select the best guess to submit.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'actor', 'evaluate_guesses_select.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the notes_str\n        prompt_system = prompt_system.replace(\"{notes}\", notes_str)\n        # Create a user prompt\n        prompt_user = \"Please select the best guess to submit.\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.llm_settings.model, prompts=prompts, settings=self.llm_settings)\n        return llm_response\n\n    def evaluate_guesses_ready_to_submit_all(self):\n        \"\"\"Call on LLM to evaluate the guesses ready to submit and submit the best one.\"\"\"\n        logger.info(\"Evaluating all guesses ready to submit. %s guesses ready to submit.\",\n                    len(self.guesses_ready_to_submit))\n        # Evaluate the guesses ready to submit\n        llm_response = self.evaluate_guesses_ready_to_submit_cot()\n        self.evaluations.append(llm_response)\n        # Select the best guess to submit\n        llm_response = self.evaluate_guesses_ready_to_submit_select(\n            llm_response.output)\n        # Turn the guess into a list of words and fix formatting\n        guess = llm_response.output\n        # Remove \"Output:\" from guess if it appears in the string\n        guess = guess.replace(\"Output:\", \"\").strip()\n        guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n        logger.info(\"Guess selected to submit: %s\", \" \".join(guess_lst))\n        # Identify the guess object that matches the guess selected to submit\n        guess_set = set(guess_lst)\n        # Check if the guess selected to submit matches any of the guesses ready to submit\n        match_guess = False\n        for guess in self.guesses_ready_to_submit:\n            # If guess_set is the same as the set of words in the guess, match_guess is True\n            if guess_set == set(guess.guess_lst):\n                match_guess = True\n                break\n        # If the guess selected to submit does not match any of the guesses ready to submit, start over\n        if match_guess is False:\n            logger.info(\"Guess selected to submit does not match any guesses ready to submit. Starting over.\")\n            return\n        \n        for guess in self.guesses_ready_to_submit:\n            # If guess_set is the same as the set of words in the guess, submit the guess\n            if guess_set == set(guess.guess_lst):\n                guess.do_submit()\n                self.guesses_submitted.append(guess)\n                # Remove from the list of guesses ready to submit\n                self.guesses_ready_to_submit.remove(guess)\n                if guess.guess_is_correct is True:\n                    self.good_guesses.append(guess)\n                    self.good_guesses_lst.append(guess.guess_lst)\n                    # Extend the words_excluded_lst to include each word in the guess_lst\n                    self.words_solved_lst.extend(guess.guess_lst)\n                    # Make words_remain_lst be words_lst minus words_solved_lst\n                    self.words_remain_lst = list(\n                        set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                    # Iterate over a copy of the list using slicing [:]\n                    for guess_ready in self.guesses_ready_to_submit[:]:\n                        if all(word in self.words_remain_lst for word in guess_ready.guess_lst):\n                            logger.info(\"Guess ready to submit still valid: %s\",\n                                        guess_ready.guess_lst)\n                        else:\n                            logger.info(\"Guess ready to submit no longer valid: %s\",\n                                        guess_ready.guess_lst)\n                            self.guesses_ready_to_submit.remove(guess_ready)\n                else:\n                    self.bad_guesses.append(guess)\n                    self.bad_guesses_lst.append(guess.guess_lst)\n                    logger.debug(\"Number of bad guesses: %s\",\n                                 len(self.bad_guesses_lst))\n                break\n        # Remove any guesses that match the guess selected to submit from the list of guesses ready to submit\n        for guess_ready in self.guesses_ready_to_submit[:]:\n            # If the set of words in guess_lst matches, remove the guess\n            if set(guess_ready.guess_lst) == guess_set:\n                self.guesses_ready_to_submit.remove(guess_ready)\n                logger.info(\"Removed guess from guesses ready to submit: %s\",\n                            guess_ready.guess_lst)\n\n    def save_summary_detailed_thorough(self):\n            \"\"\"Save a summary of the results as a markdown file.\"\"\"\n            timestamp = get_timestamp()\n            filename = f\"summary_detailed_thorough_puzzle{self.puzzle.number}_{self.puzzle.llm_settings.model}_{timestamp}.md\"\n            filepath = os.path.join(self.path_md, filename)\n            with open(\n                filepath,\n                'w', encoding='utf-8'\n            ) as f:\n                f.write(f\"# Summary of Puzzle {self.puzzle.number}\\n\\n\")\n                f.write(f\"Date: {get_date()}\\n\")\n                f.write(f\"Model: {self.puzzle.llm_settings.model}\\n\")\n                minutes, seconds = divmod(self.solve_time, 60)\n\n                if self.puzzle.emoji_dict is not None:\n                    f.write(\"\\n\")\n                    for guess in self.guesses_submitted:\n                        for word in guess.guess_lst:\n                            square_emoji = self.puzzle.emoji_dict.get(\n                                word, (emoji.emojize(':red_question_mark:')))\n                            f.write(f\"{square_emoji}\")\n                        f.write(\"\\n\")\n\n                if self.success is True:\n                    f.write(\"## Success!\\n\\n\")\n                    f.write(\n                        f\"Solved in {int(minutes)} minutes and {int(seconds)} seconds \\n\\n\")\n                else:\n                    f.write(\"## Failure!\\n\\n\")\n                    f.write(\n                        f\"Wasted {int(minutes)} minutes and {int(seconds)} seconds on this dumb puzzle.\\n\\n\")\n                num_good_guesses = len(self.good_guesses_lst)\n                num_bad_guesses = len(self.bad_guesses_lst)\n                f.write(f\"Correct guesses: {num_good_guesses}\\n\")\n                f.write(f\"Incorrect guesses: {num_bad_guesses}\\n\\n\")\n                f.write(\"## Submitted Guesses\\n\\n\")\n                for guess in self.guesses_submitted:\n                    f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                    if guess.guess_is_correct:\n                        f.write(\"Correct: \")\n                    else:\n                        f.write(\"Incorrect: \")\n                    guess_str = \" \".join(guess.guess_lst)\n                    f.write(f\"{guess_str}\\n\\n\")\n                f.write(\"## Solution\\n\\n\")\n                for solution in self.puzzle.solution_lst:\n                    solution_str = \" \".join(solution)\n                    f.write(f\"{solution_str}\\n\\n\")\n                # New detailed parts (everything above is same as save_summary)\n                if len(self.evaluations) > 0:\n                    f.write(\"## Evaluations\\n\\n\")\n                    for response in self.evaluations:\n                        f.write(\n                            f\"### Evaluation {self.evaluations.index(response) + 1}\\n\\n\")\n                        f.write(f\"{response.output}\\n\\n\")\n                f.write(\"## Submitted Guesses Play-By-Play\\n\\n\")\n                for guess in self.guesses_submitted:\n                    f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                    if guess.guess_is_correct:\n                        f.write(\"Correct: \")\n                    else:\n                        f.write(\"Incorrect: \")\n                    guess_str = \" \".join(guess.guess_lst)\n                    f.write(f\"{guess_str}\\n\\n\")\n                    f.write(\"Reasoning:\\n\")\n                    reasoning = \"\"\n                    if len(guess.guess_rationale) > 0:\n                        reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                        # Modify reasoning string so that all \"# \" are \"## \"\n                        reasoning = re.sub(\n                            r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                        f.write(f\"{reasoning}\")\n                    elif guess == self.guesses_submitted[-1] and self.success:\n                        f.write(\n                            \"(Automatically chosen by application because it was the only option left.).\\n\\n\")\n                if len(self.guesses_processed) > len(self.guesses_submitted):\n                    f.write(\"## All Guesses Play-By-Play\\n\\n\")\n                    for guess in self.guesses_processed:\n                        guess_str = \" \".join(guess.guess_lst)\n                        f.write(f\"### Guess {guess.num_of_guess}\\n\\n\")\n                        if guess.guess_was_submitted:\n                            if guess.guess_is_correct:\n                                f.write(\"Submitted and Correct: \")\n                            else:\n                                f.write(\"Submitted and Incorrect: \")\n                            guess_str = \" \".join(guess.guess_lst)\n                            f.write(f\"Guess: {guess_str}\\n\\n\")\n                            f.write(\"Reasoning:\\n\")\n                            reasoning = \"\"\n                            if len(guess.guess_rationale) > 0:\n                                reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                                # Modify reasoning string so that all \"# \" are \"## \"\n                                reasoning = re.sub(\n                                    r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                                f.write(f\"{reasoning}\")\n                            elif guess == self.guesses_submitted[-1] and self.success:\n                                f.write(\n                                    \"(Automatically chosen by application because it was the only option left.).\\n\\n\")\n                        elif len(guess.guess_rationale) > 0:\n                            f.write(f\"Guess: {guess_str}\\n\\n\")\n                            f.write(\"Reasoning:\\n\")\n                            reasoning = f\"{guess.guess_rationale}\\n\\n\"\n                            # Modify reasoning string so that all \"# \" are \"## \"\n                            reasoning = re.sub(\n                                r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                            f.write(f\"{reasoning}\")\n                        elif guess.guess_is_valid is False:\n                            f.write(\n                                \"Rejected because guess has formatting or content error: \")\n                            guess_str = \" \".join(guess.guess_lst)\n                            f.write(f\"Guess: {guess_str}\\n\\n\")\n                        elif guess.good_options_for_guess is False:\n                            f.write(\"Rejected because no good options for guess: \")\n                            reasoning = \"\"\n                            for response in guess.discern.decide_cot_responses:\n                                reasoning += f\"{response.output}\\n\\n\"\n                            # Modify reasoning string so that all \"# \" are \"## \"\n                            reasoning = re.sub(\n                                r\"^#\", \"##\", reasoning, flags=re.MULTILINE)\n                            f.write(f\"{reasoning}\")\n            logger.info(\"Saved detailed summary to %s\", filepath)\n"}
{"type": "source_file", "path": "src/guess_vanilla_o1.py", "content": "\"\"\"Guess class for Vanilla GPT-o1 approach for storing information about a guess that is processed.\"\"\"\n\nimport os\nimport logging\nimport random\n\nfrom src.guess import BaseGuess\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.utils_llm import (\n    llm_call\n)\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass GuessVanillao1(BaseGuess):\n    \"\"\"Guess class for Vanilla GPT-o1 approach for storing information about a guess that is processed.\"\"\"\n    \n    def __init__(\n        self,\n        solve\n    ):\n        super().__init__()\n        self.solve = solve\n        self.puzzle = self.solve.puzzle\n        self.num_of_guess = len(self.solve.guesses_processed)+1\n        \n        self.make_guess_responses = []\n        self.make_guess_outputs = []\n        self.select_responses = []\n        self.select_outputs = []\n    \n    def process_guess(self):\n        \"\"\"Process the guess from start to finish for the Vanilla approach.\"\"\"\n        self.make_guess()\n        self.select_and_validate_all()\n        if self.guess_is_valid is True:\n            self.guess_is_ready_to_submit = True\n        else:\n            self.guess_is_ready_to_submit = False\n\n    def make_guess(self):\n        \"\"\"Ask LLM to make a guess.\"\"\"\n        self.make_guess_responses = []\n        self.make_guess_outputs = []\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'vanilla_o1' , 'make_guess.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # If bad guesses have been made, add them to the system prompt\n        bad_guesses_str = self.set_bad_guesses_str()\n        prompt_system = prompt_system.replace('{bad_guesses}', bad_guesses_str)\n        # Because o1 does not allow you to use a system prompt, turn system prompt into user prompt\n        prompt_user = prompt_system\n        # Create rest of user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user += f\"\\n \\n List of words in puzzle: {words_remain_str}\"\n        # Set up the prompts for the LLM\n        prompts = [\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model='o1-preview', prompts=prompts, settings=self.puzzle.llm_settings)\n        self.make_guess_responses.append(llm_response)\n        self.make_guess_outputs.append(llm_response.output)\n        self.guess_rationale = llm_response.output\n        logger.debug(\"Made guess: /n /n %s\", llm_response.output)\n\n    def select_guess(self):\n        \"\"\"Call LLM to select the guess.\"\"\"\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'vanilla_o1', 'select.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Within the system prompt, replace the placeholder {notes} with the notes_str\n        prompt_system = prompt_system.replace(\"{notes}\", self.guess_rationale)\n        # Create a user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user = f\"Please select the guess to submit for this puzzle: {words_remain_str}\"\n        # Set up prompts for the LLM\n        prompts = [\n            {\"role\": \"system\", \"content\": prompt_system},\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model=self.puzzle.llm_settings.model, prompts=prompts, settings=self.puzzle.llm_settings)\n        logger.debug(\"Select guess: /n /n %s\", llm_response.output)\n        return llm_response\n    \n    def select_all(self):\n        \"\"\"Run each of the steps to select the guess.\"\"\"\n        self.select_responses = []\n        self.select_outputs = []\n        llm_response = self.select_guess()\n        self.select_responses.append(llm_response)\n        self.select_outputs.append(llm_response.output)\n        # Turn the guess into a list of words and fix formatting\n        guess = llm_response.output\n        # Remove \"Output:\" or \"Response:\" from guess if it appears in the string\n        guess = guess.replace(\"Output:\", \"\").strip()\n        guess = guess.replace(\"Response:\", \"\").strip()\n        guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n        \n        # Sort the guess_lst in alphabetical order\n        guess_lst = sorted(guess_lst)\n        # Check if the guess_lst has four words\n        if len(guess_lst) != 4:\n            logger.warning(\n                \"Guess does not contain four words. Trying to get LLM to fix...\")\n            llm_response = self.select_fix(guess)\n            # Turn the guess into a list of words and fix formatting\n            guess = llm_response.output\n            # Remove \"Output:\" from guess if it appears in the string\n            guess = guess.replace(\"Output:\", \"\").strip()\n            guess = guess.replace(\"Response:\", \"\").strip()\n            guess_lst = self.puzzle.split_puzzle_text(guess, 4, \"***\")\n            if len(guess_lst) != 4:\n                logger.warning(\n                    \"Failed to fix guess. Guess still does not contain four words.\")\n            else:\n                logger.info(\"Fixed guess!\")\n        self.guess_lst = guess_lst\n        logger.info(\"Selected guess: %s\", \" \".join(guess_lst))\n        \n    def select_and_validate_all(self):\n        \"\"\"Select the guess and validate it for errors.\"\"\"\n        self.select_all()\n        self.validate_all()    "}
{"type": "source_file", "path": "src/guess_oneshot_o1.py", "content": "\"\"\"Guess class for One-Shot GPT-o1 approach for storing information about a guess that is processed.\"\"\"\n\nimport os\nimport logging\nimport random\n\nfrom src.guess import BaseGuess\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.utils_llm import (\n    llm_call\n)\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass GuessOneShoto1(BaseGuess):\n    \"\"\"Guess class for One-Shot GPT-o1 approach for storing information about a guess that is processed.\"\"\"\n    \n    def __init__(\n        self,\n        solve\n    ):\n        super().__init__()\n        self.solve = solve\n        self.puzzle = self.solve.puzzle\n        self.num_of_guess = len(self.solve.guesses_processed)+1\n        \n        self.make_guess_responses = []\n        self.make_guess_outputs = []\n        self.select_responses = []\n        self.select_outputs = []\n    \n    def process_guess(self):\n        \"\"\"Process the guess from start to finish for the one-shot GPTo1 approach.\"\"\"\n        self.make_guess()\n\n\n    def make_guess(self):\n        \"\"\"Ask LLM to make a guess.\"\"\"\n        self.make_guess_responses = []\n        self.make_guess_outputs = []\n        # Load the system prompt from a .txt file\n        with open(os.path.join(\n                get_root_dir(), 'data', 'prompts', 'oneshot_o1' , 'make_guess.txt'),\n                'r', encoding='utf-8') as f:\n            prompt_system = f.read()\n        # Because o1 does not allow you to use a system prompt, turn system prompt into user prompt\n        prompt_user = prompt_system\n        # Create rest of user prompt\n        # Create a list that shuffles the words that remain to be solved\n        words_remain_shuffled = self.solve.words_remain_lst.copy()\n        random.shuffle(words_remain_shuffled)\n        # Create a string of the words that remain to be solved\n        words_remain_str = \" \".join(words_remain_shuffled)\n        prompt_user += f\"\\n \\n List of words in puzzle: {words_remain_str}\"\n        # Set up the prompts for the LLM\n        prompts = [\n            {\"role\": \"user\", \"content\": prompt_user},\n        ]\n        # Call the LLM\n        llm_response = llm_call(\n            model='o1-preview', prompts=prompts, settings=self.puzzle.llm_settings)\n        self.make_guess_responses.append(llm_response)\n        self.make_guess_outputs.append(llm_response.output)\n        self.guess_rationale = llm_response.output\n        self.guess_lst.append(llm_response.output)\n        logger.debug(\"Made guess: /n /n %s\", llm_response.output)"}
{"type": "source_file", "path": "src/setup_logging.py", "content": "\"\"\" This module sets up the logging for \"LLMs as Method Actors\" package.\n\"\"\"\nimport logging\nimport os\n\n\ndef setup_logger():\n    \"\"\" Set up the logging for the \"LLMs as Method Actors\" package.\n    \"\"\"\n    # Set up logger\n    logger = logging.getLogger('method-actors')\n    if not logger.handlers:\n        logger.setLevel(logging.DEBUG)\n\n        # Create a log directory if it doesn't exist\n        if not os.path.exists('log'):\n            os.makedirs('log')\n\n        # Create a file handler\n        file_handler = logging.FileHandler(\n            os.path.join('log', 'method-actors.log'))\n        file_handler.setLevel(logging.DEBUG)\n\n        # Create a console handler\n        console_handler = logging.StreamHandler()\n        console_handler.setLevel(logging.DEBUG)\n\n        # Create a formatter\n        formatter = logging.Formatter(\n            '%(asctime)s - %(filename)s:%(lineno)d - %(levelname)s - %(message)s')\n\n        # Add the formatter to the handlers\n        file_handler.setFormatter(formatter)\n        console_handler.setFormatter(formatter)\n\n        # Add the handlers to the logger\n        logger.addHandler(file_handler)\n        logger.addHandler(console_handler)\n"}
{"type": "source_file", "path": "src/utils_string.py", "content": "\"\"\"\nThis module contains utility functions for string manipulation and formatting\n\nFunctions\n\nget_timestamp() -> str\n    Returns a timestamp in the format YYYY_MM_DD_HH_MM_SS.\n    Returns:\n        A string representing the current timestamp.\n\nget_date() -> str\n    Returns a date in the format YYYY_MM_DD.\n    Returns:\n        A string representing the current date.\n\n\"\"\"\nimport logging\nfrom datetime import datetime\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\ndef get_timestamp():\n    \"\"\"Return a timestamp in the format YYYY_MM_DD_HH_MM_SS.\"\"\"\n    now = datetime.now()\n    yearmonthdaytime = now.strftime(\"%Y_%m_%d_%H_%M_%S\")\n    return yearmonthdaytime\n\n\ndef get_date():\n    \"\"\"Return a date in the format YYYY_MM_DD.\"\"\"\n    now = datetime.now()\n    yearmonthday = now.strftime(\"%Y_%m_%d\")\n    return yearmonthday\n"}
{"type": "source_file", "path": "src/solve_vanilla_o1.py", "content": "\"\"\"SolveVanillao1 class is a class the  solves the Connections puzzle using a Vanilla/Naked/Simple approach with GPT-o1.\n\"\"\"\n\nimport logging\nimport time\n\nfrom src.utils_llm import (\n    LLMSettings,\n    llm_call\n)\nfrom src.baseclass import BaseClass\nfrom src.solve import BaseSolver\nfrom src.utils_string import (\n    get_date,\n    get_timestamp\n)\nfrom src.utils_file import (\n    get_root_dir\n)\nfrom src.guess_vanilla_o1 import GuessVanillao1\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\nclass SolveVanillao1(BaseSolver):\n    \"\"\"SolveVanilla class is a class the  solves the Connections puzzle using a Vanilla/Naked/Simple approach with GPT-o1.\n    \"\"\"\n    \n    def __init__(self,\n                 puzzle\n                 ):\n        super().__init__()\n        self.puzzle = puzzle\n        self.words_remain_lst = puzzle.words_lst\n    \n    def set_path_vanillao1(self):\n        \"\"\"Set the path for saving data to file.\"\"\"\n        self.set_path(name=\"solve_vanilla_o1\")\n    \n    def solve_puzzle_vanillao1(self):\n        \"\"\"Solve the puzzle using the vanillao1 method.\n        \"\"\"\n        start_time = time.time()\n        logger.info(\"Solving puzzle using Vanilla o1 approach. \\n Words in puzzle: \\n %s \\n Solution: \\n %s\",\n                    self.puzzle.words_lst, self.puzzle.solution_lst)\n\n        if len(self.guesses_processed) == 0:\n\n            self.current_guess = None\n            self.guesses_processed = []\n            self.guesses_ready_to_submit = []\n            self.guesses_submitted = []\n            self.good_guesses = []\n            self.good_guesses_lst = []\n            self.bad_guesses = []\n            self.bad_guesses_lst = []\n            self.end_game = False\n            self.success = False\n        while self.end_game is False:\n            \n            # If the guesses ready to submit list has any guesses in it, submit the guess.\n            if len(self.guesses_ready_to_submit) > 0:\n                for guess in self.guesses_ready_to_submit:\n                    guess.do_submit()\n                    self.guesses_submitted.append(guess)\n                    # Remove from the list of guesses ready to submit\n                    self.guesses_ready_to_submit.remove(guess)\n                    if guess.guess_is_correct is True:\n                        self.good_guesses.append(guess)\n                        self.good_guesses_lst.append(guess.guess_lst)\n                        # Extend the words_excluded_lst to include each word in the guess_lst\n                        self.words_solved_lst.extend(guess.guess_lst)\n                        # Make words_remain_lst be words_lst minus words_solved_lst\n                        self.words_remain_lst = list(\n                            set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                        # Iterate over a copy of the list using slicing [:]\n                        for guess_ready in self.guesses_ready_to_submit[:]:\n                            if all(word in self.words_remain_lst for word in guess_ready.guess_lst):\n                                logger.info(\"Guess ready to submit still valid: %s\",\n                                            guess_ready.guess_lst)\n                            else:\n                                logger.info(\"Guess ready to submit no longer valid: %s\",\n                                            guess_ready.guess_lst)\n                                self.guesses_ready_to_submit.remove(guess_ready)\n                    else:\n                        self.bad_guesses.append(guess)\n                        self.bad_guesses_lst.append(guess.guess_lst)\n                        logger.debug(\"Number of bad guesses: %s\",\n                                    len(self.bad_guesses_lst))\n          \n\n            # If there are only four words left to solve, submit the guess that solves them.\n            if len(self.good_guesses) == 3:\n                logger.info(\"Only one possible solution left. Submitting.\")\n                self.current_guess = GuessVanillao1(self)\n                self.current_guess.guess_lst = self.words_remain_lst\n                self.current_guess.do_submit()\n                if self.current_guess.guess_was_submitted is True:\n                    self.guesses_submitted.append(self.current_guess)\n                    if self.current_guess.guess_is_correct is True:\n                        self.good_guesses.append(self.current_guess)\n                        self.good_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        # Extend the words_excluded_lst to include each word in the guess_lst\n                        self.words_solved_lst.extend(\n                            self.current_guess.guess_lst)\n                        # Make words_remain_lst be words_lst minus words_solved_lst\n                        self.words_remain_lst = list(\n                            set(self.puzzle.words_lst) - set(self.words_solved_lst))\n                    else:\n                        self.bad_guesses.append(self.current_guess)\n                        self.bad_guesses_lst.append(\n                            self.current_guess.guess_lst)\n                        logger.debug(\"Number of bad guesses: %s\",\n                                     len(self.bad_guesses_lst))\n            self.check_end_game_conditions()\n\n\n            # If the puzzle is not done, create a new guess\n            if self.end_game is False:\n                # Create a new guess\n                self.current_guess = GuessVanillao1(self)\n                guesses_ready_to_submit_str = \"\"\n                for guess in self.guesses_ready_to_submit:\n                    guess_str = \"Guess: \\n\"\n                    guess_str += \" \".join(guess.guess_lst)\n                    guess_str += \"\\n Rationale: \\n\"\n                    guess_str += guess.guess_rationale\n                    guesses_ready_to_submit_str += f\"{guess_str}\\n\"\n                logger.info(\"Starting New Guess! \\n Current guess number: %s \\n %s words remaining: \\n %s  \\n %s good guesses so far: \\n %s \\n %s bad guesses so far: \\n %s \\n %s guesses ready to submit: \\n %s\",\n                            self.current_guess.num_of_guess, len(self.words_remain_lst), self.words_remain_lst, len(self.good_guesses_lst), self.good_guesses_lst, len(self.bad_guesses_lst), self.bad_guesses_lst, len(self.guesses_ready_to_submit), guesses_ready_to_submit_str)\n                self.current_guess.process_guess()\n                self.guesses_processed.append(self.current_guess)\n                # If the current guess failed because of an error, start over from the beginning.\n                if self.current_guess.guess_is_valid is False:\n                    logger.info(\n                        \"Guess is not a valid guess to submit because of a formatting or content error. Starting over.\")\n                # If the current guess is ready to submit, add it to the list of guesses ready to submit.\n                if self.current_guess.guess_is_ready_to_submit is True:\n                    self.guesses_ready_to_submit.append(self.current_guess)\n                    logger.info(\"Guess is ready to submit. Adding to list.\")\n\n        self.solve_time = time.time() - start_time\n        minutes, seconds = divmod(self.solve_time, 60)\n        minutes = int(minutes)\n        seconds = int(seconds)\n        logger.info(\"Puzzle finished in %s minutes and %s seconds.\",\n                    minutes, seconds)\n        self.save_results_dict()\n        self.puzzle.llm_settings.model = \"o1-preview\"\n        if self.puzzle.solution_lst is not None:\n            self.save_summary()\n        else:\n            self.save_summary_no_solution()\n        self.save_attributes(filepath_pkl=self.path_pkl,\n                             name=f\"puzzle_{self.puzzle.number}_vanilla_o1\")\n"}
{"type": "source_file", "path": "src/utils_tokens.py", "content": "\"\"\"\nUtility functions for measuring tokens and modifying strings to fit within token limits.\n\n\"\"\"\nimport logging\nimport tiktoken\nimport time\nfrom langchain.text_splitter import (\n    TokenTextSplitter\n)\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\ndef num_tokens(str, encoding_name=\"cl100k_base\") -> int:\n    \"\"\"Returns the number of tokens in a text string using the CL100k_base tokenizer.\"\"\"\n    encoding = tiktoken.get_encoding(encoding_name)\n    tokens = len(encoding.encode(str))\n    return tokens\n\n\ndef time_tokens(str, model='gpt-4'):\n    \"\"\"Returns the time needed to wait before the next request to the LLM.\"\"\"\n    tps = 3000000 / 60  # tokens per minute under my account\n    tokens = num_tokens(str)\n    return tokens / tps\n\n\ndef sleep_for_time_tokens(str, model='gpt-4'):\n    \"\"\"Sleeps for the time needed to wait before the next request to the LLM.\"\"\"\n    time_to_sleep = time_tokens(str, model)\n    logger.debug(\"Sleeping for %s seconds...\", time_to_sleep)\n    time.sleep(time_to_sleep)\n\n\ndef sleep_for_tokens(tokens, model='gpt-4'):\n    \"\"\"Sleeps for the time needed to wait before the next request to the LLM.\n    Difference between this and sleep_for_time_tokens is that tokens are provided in argument\n    rather than text strings that the function converts to tokens.\n    \"\"\"\n    tps = 300000 / 60  # tokens per minute under my account\n    time_to_sleep = tokens / tps\n    logger.debug(\"Sleeping for %s seconds...\", time_to_sleep)\n    time.sleep(time_to_sleep)\n\n\ndef trim_to_last_blank_line(string):\n    \"\"\"Trims string back to the last blank line.\"\"\"\n    lines = string.splitlines()\n    for i in range(len(lines)-1, -1, -1):\n        if not lines[i].strip():\n            return '\\n'.join(lines[:i+1])\n    return ''\n\n\ndef trim_for_tokens(string, max_tokens=6000, max_attempts=3000):\n    \"\"\"Trims string to max_tokens.\"\"\"\n    tokens = num_tokens(string)\n    count = 1\n    while tokens > max_tokens and count < max_attempts:\n        logger.debug(\n            \"trim_for_tokens: String is too long. Trimming to last blank line. (Attempt %s).\",\n            count\n        )\n        if string == trim_to_last_blank_line(string):\n            logger.debug(\n                \"trim_for_tokens: String is too long. Trimming to last sentence. (Attempt %s).\",\n                count\n            )\n            string = string[:string.rfind(\".\")+1]\n            tokens = num_tokens(string)\n            count += 1\n            continue\n        string = trim_to_last_blank_line(string)\n        tokens = num_tokens(string)\n        count += 1\n    return string\n\n\ndef trim_part_for_tokens(part, remainder, max_tokens=6000, trim_tokens=3000, max_attempts=3000):\n    \"\"\"Trims part so that part + remainder is under token limit.\"\"\"\n    if num_tokens(remainder) > max_tokens:\n        logger.debug(\n            \"trim_query_for_tokens: Other parts exceed %s tokens. Reducing to %s tokens.\",\n            max_tokens,\n            trim_tokens\n        )\n        part = trim_for_tokens(part, trim_tokens)\n        return part\n    tokens = num_tokens(part + remainder)\n    count = 1\n    while tokens > max_tokens and count < max_attempts:\n        logger.debug(\n            \"trim_part_for_tokens: Part is too long. Trimming to last blank line. (Attempt %d).\",\n            count\n        )\n        if part == trim_to_last_blank_line(part):\n            logger.debug(\n                \"trim_part_for_tokens: Part is too long. Trimming to last sentence. (Attempt %d).\",\n                count\n            )\n            part = part[:part.rfind(\".\")+1]\n            tokens = num_tokens(part + remainder)\n            count += 1\n            continue\n        part = trim_to_last_blank_line(part)\n        tokens = num_tokens(part + remainder)\n        count += 1\n    return part\n\n\ndef string_to_token_list(string, chunk_size=6000, chunk_overlap=0):\n    \"\"\"Turns string into list of token-sized strings.\"\"\"\n    text_splitter = TokenTextSplitter(\n        chunk_size=chunk_size, chunk_overlap=chunk_overlap)\n    return text_splitter.split_text(string)\n\n\ndef list_to_token_list(lst, chunk_size=6000, chunk_overlap=0):\n    \"\"\"Combines strings in a list so that each string in the list approaches token limit.\n    This increases efficiency when you want an LLM to process all the items in a list\n    but you don't need to process each item individually with its own LLM call.\n    \"\"\"\n    temp_list = lst\n    token_list = []\n    total_tokens = 0\n    scratchpad = \"\"\n    index = 0\n    while index < len(temp_list):\n        x = temp_list[index]\n        try:\n            tokens = num_tokens(x)\n        except Exception as e:\n            logging.error(\n                \"Error calculating tokens for item at index %s: %s\", index, e)\n            index += 1\n            continue\n        # If item exceeds token limit, split item into its own token_list,\n        # insert that list, end the current iteration, and continue to the next iteration.\n        if tokens >= chunk_size:\n            try:\n                x_list = string_to_token_list(\n                    x,\n                    chunk_size=chunk_size,\n                    chunk_overlap=chunk_overlap\n                )\n            except Exception as e:\n                logging.error(\n                    \"Error splitting string into token list for item at index %d: %s\",\n                    index,\n                    e\n                )\n                index += 1\n                continue\n            temp_list.pop(index)\n            # insert x_list items at current position\n            temp_list[index:index] = x_list\n            continue\n        # If item plus scratchpad exceeds token limit, add scratchpad to list,\n        # clear scratchpad, and clear total tokens.\n        if total_tokens + tokens >= chunk_size:\n            token_list.append(scratchpad)\n            scratchpad = \"\"\n            total_tokens = 0\n        # Add item to scratchpad, add tokens to token count\n        scratchpad += \"\\n \" + x\n        total_tokens += tokens\n        index += 1\n    if scratchpad:  # handle any remaining content in scratchpad\n        token_list.append(scratchpad)\n    return token_list\n"}
{"type": "source_file", "path": "src/submit.py", "content": "\"\"\"Class for submitting an guess for part of the answer to the puzzle.\"\"\"\n\n\nimport logging\n\nfrom src.baseclass import BaseClass\n\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\nclass Submit(BaseClass):\n    \"\"\"Submit class for submitting an guess for part of the answer to the puzzle.\"\"\"\n\n    def __init__(\n            self,\n            guess\n    ):\n\n        self.guess = guess\n        self.puzzle = guess.puzzle\n        self.solve = guess.solve\n\n    def submit_guess(self):\n        \"\"\"Submit a guess for part of the answer to the puzzle.\"\"\"\n        logger.info(\"Submitting guess%s: %s\",\n                    self.guess.num_of_guess, self.guess.guess_lst)\n        # If the solution list exists, check if the guess is correct\n        if self.puzzle.solution_lst is not None:\n            guess_set = set(self.guess.guess_lst)\n            if any(guess_set.issubset(set(solution)) for solution in self.puzzle.solution_lst):\n                logger.info(\"Correct guess! Woohoo!\")\n                return True\n            else:\n                logger.info(\"Incorrect guess! Dang!\")\n                return False\n        else:\n            logger.info(\"No solution to check guess against.\")\n            return True\n\n    def check_if_one_away(self):\n        \"\"\"Check if the guess is one away from the solution.\"\"\"\n        logger.info(\"Checking if guess is one away from solution.\")\n        # If the solution list exists, check if the guess is one away\n        if self.puzzle.solution_lst is not None:\n            for solution in self.puzzle.solution_lst:\n                # Check if the guess is one away from the solution\n                if len(set(self.guess.guess_lst).symmetric_difference(set(solution))) == 2:\n                    logger.info(\"Guess is one away from the solution.\")\n                    return True\n        logger.info(\"Guess is not one away from the solution.\")\n        return False\n"}
{"type": "source_file", "path": "src/utils_llm.py", "content": "\"\"\"\nUtility functions for working with LLMs.\n\n\n\"\"\"\n\nimport logging\nimport os\n\nfrom dataclasses import dataclass\nfrom dotenv import load_dotenv\nfrom openai import OpenAI\nimport google.generativeai as genai\nimport anthropic\n\nfrom src.utils_file import get_root_dir\nfrom src.utils_tokens import sleep_for_tokens\nfrom src.utils_string import get_timestamp\n\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\n@dataclass\nclass LLMSettings:\n    \"\"\"Settings for the LLM.\"\"\"\n    # Embeddings\n    embeddings = 'OpenAIEmbeddings()'\n    # Primary LLM model\n    model: str = 'gpt-4o'\n    # Maximum tokens for input to primary LLM\n    max_tokens: int = 40000\n    # LLM model for long inputs\n    model_long: str = 'gpt-4o'\n    # Maximum tokens for input to long LLM\n    max_tokens_long: int = 40000\n    # LLM model for doing simpler tasks for less money\n    model_cheap: str = 'gpt-4o-mini'\n    # Maximum tokens for input to cheap LLM\n    max_tokens_cheap: int = 40000\n    # Chunk size for breaking up long inputs for primary LLM\n    chunk_size: int = 40000\n    # Overlapping text between chunks\n    chunk_overlap: int = 500\n    # Chunk size for breaking up long inputs for long LLM\n    chunk_size_long: int = 40000\n    # Maximum number of attempts at reducing a long input to a short input by breaking it up\n    # into chunks, summarizing those chunks, and then combining the summaries.\n    max_attempts: int = 3\n    # Temperature for LLM completions\n    temperature = 0\n    # Response format for LLM completions\n    response_format = None\n\n\nclass Response:\n    \"\"\"Response class for LLM completions.\"\"\"\n\n    def __init__(self,\n                 output=None,\n                 completion_tokens=None,\n                 prompt_tokens=None,\n                 total_tokens=None,\n                 model=None,\n                 timestamp=None,\n                 full_response=None,\n                 prompts=None,\n                 settings=None\n                 ):\n        self.output = output\n        self.completion_tokens = completion_tokens\n        self.prompt_tokens = prompt_tokens\n        self.total_tokens = total_tokens\n        self.model = model\n        self.timestamp = timestamp\n        self.full_response = full_response\n        self.prompts = prompts\n        self.settings = settings\n\n\ndef set_openai_key():\n    \"\"\"Set variable for OpenAI API key based on your environmental variables.\"\"\"\n    load_dotenv()\n    openai_api_key = os.environ.get('OPENAI_API_KEY')\n    return openai_api_key\n\n\ndef set_gemini_key():\n    \"\"\"Set variable for GenAI API key based on your environmental variables.\"\"\"\n    load_dotenv()\n    gemini_api_key = os.environ.get('GEMINI_API_KEY')\n    return gemini_api_key\n\n\ndef set_anthropic_key():\n    \"\"\"Set variable for Anthropic API key based on your environmental variables.\"\"\"\n    load_dotenv()\n    anthropic_api_key = os.environ.get('ANTHROPIC_API_KEY')\n    return anthropic_api_key\n\n\ndef get_openai_models():\n    \"\"\"Get a list of OpenAI models available to the user.\"\"\"\n    try:\n        client = OpenAI(api_key=set_openai_key())\n        available_models = client.models.list()\n        models_lst = []\n        for model in available_models.data:\n            models_lst.append(model.id)\n        logger.info(\"Available OpenAI models: %s\", models_lst)\n    except Exception as e:\n        print(f\"Error: {e}\")\n        print(\"Unable to retrieve model information.\")\n    return models_lst\n\n\ndef get_gemini_models():\n    \"\"\"Get a list of GenAI models available to the user.\"\"\"\n    try:\n        genai.configure(api_key=set_gemini_key())\n        available_models = genai.list_models()\n        models_lst = []\n        for model in available_models:\n            if 'generateContent' in model.supported_generation_methods:\n                models_lst.append(model.name)\n        logger.info(\"Available Gemini models: %s\", models_lst)\n    except Exception as e:\n        print(f\"Error: {e}\")\n        print(\"Unable to retrieve model information.\")\n    return models_lst\n\n\ndef llm_call(model='gpt-4o', prompts=[], settings=None):\n    \"\"\"Call the LLM with a list of prompts.\"\"\"\n    openai_models = ['whisper-1',\n                     'dall-e-2',\n                     'gpt-3.5-turbo-16k',\n                     'tts-1-hd-1106',\n                     'tts-1-hd',\n                     'gpt-4-turbo-2024-04-09',\n                     'gpt-4-0125-preview',\n                     'gpt-4-turbo-preview',\n                     'gpt-4-turbo',\n                     'gpt-3.5-turbo-instruct-0914',\n                     'gpt-3.5-turbo',\n                     'gpt-3.5-turbo-instruct',\n                     'text-embedding-3-small',\n                     'tts-1',\n                     'text-embedding-3-large',\n                     'gpt-4-1106-preview',\n                     'babbage-002',\n                     'gpt-3.5-turbo-0125',\n                     'tts-1-1106',\n                     'dall-e-3',\n                     'gpt-4-0613',\n                     'text-embedding-ada-002',\n                     'gpt-4',\n                     'davinci-002',\n                     'gpt-3.5-turbo-1106',\n                     'gpt-4o-2024-05-13',\n                     'gpt-4o',\n                     'gpt-4o-mini',\n                     'gpt-4o-2024-08-06',\n                     'o1-preview',\n                     'o1-preview-2024-09-12',\n                     'o1-mini',\n                     'o1-mini-2024-09-12',]\n\n    gemini_models = ['gemini-1.0-pro',\n                     'gemini-1.0-pro-001',\n                     'gemini-1.0-pro-latest',\n                     'gemini-1.0-pro-vision-latest',\n                     'gemini-1.5-flash',\n                     'gemini-1.5-flash-001',\n                     'gemini-1.5-flash-latest',\n                     'gemini-1.5-pro',\n                     'gemini-1.5-pro-001',\n                     'gemini-1.5-pro-latest',\n                     'gemini-pro',\n                     'gemini-pro-vision']\n    anthropic_models = ['claude-3-5-sonnet-20240620',\n                        'claude-3-opus-20240229',\n                        'claude-3-sonnet-20240229',\n                        'claude-3-haiku-20240307']\n    if model in openai_models:\n        llm_response = openai_chat_call(model, prompts, settings)\n        sleep_for_tokens(llm_response.total_tokens)\n    elif model in gemini_models:\n        llm_response = gemini_chat_call(model, prompts, settings)\n        sleep_for_tokens(llm_response.total_tokens*30)\n    elif model in anthropic_models:\n        llm_response = anthropic_chat_call(model, prompts, settings)\n    else:\n        # If model is not recognized, default to GPT-4o\n        logger.warning(\"Model not recognized. Defaulting to GPT-4o.\")\n        llm_response = openai_chat_call('gpt-4o', prompts, settings)\n    return llm_response\n\n\ndef openai_chat_call(model, prompts, settings=None):\n    \"\"\"Call an OpenAI model with a list of prompts.\"\"\"\n    # If settings are provided, use them. Otherwise, use defaults.\n    logger.debug(\"Calling OpenAI model %s\", model)\n    if settings is not None:\n        temperature = settings.temperature\n    if model == 'o1-preview':\n        temperature = 1\n    else:\n        temperature = 0\n    client = OpenAI(api_key=set_openai_key())\n    full_response = client.chat.completions.create(\n        model=model,\n        messages=prompts,\n        temperature=temperature\n    )\n    llm_response = Response(\n        output=full_response.choices[0].message.content,\n        completion_tokens=full_response.usage.completion_tokens,\n        prompt_tokens=full_response.usage.prompt_tokens,\n        total_tokens=full_response.usage.total_tokens,\n        model=full_response.model,\n        timestamp=full_response.created,\n        full_response=full_response,\n        prompts=prompts,\n        settings=settings\n    )\n\n    return llm_response\n\n\ndef gemini_chat_call(model, prompts, settings=None):\n    \"\"\"Call a Gemini model with a list of prompts.\"\"\"\n    # If settings are provided, use them. Otherwise, use defaults.\n    logger.debug(\"Calling Gemini model %s\", model)\n    if settings is not None:\n        temperature = settings.temperature\n    else:\n        temperature = 0\n    # Retrieve the system and user prompts from the list of prompts\n    prompt_system_text = next(\n        (prompt['content'] for prompt in prompts if prompt['role'] == 'system'), None)\n    prompt_user_text = next(\n        (prompt['content'] for prompt in prompts if prompt['role'] == 'user'), None)\n    if prompt_system_text is None:\n        logger.error(\"System prompt not found.\")\n    if prompt_user_text is None:\n        logger.error(\"User prompt not found.\")\n\n    model_name = f\"models/{model}\"\n    # Call the Gemini model\n    genai.configure(api_key=set_gemini_key())\n    client = genai.GenerativeModel(\n        model_name=model_name,\n        system_instruction=prompt_system_text,\n        generation_config={\"temperature\": temperature}\n    )\n\n    full_response = client.generate_content(\n        prompt_user_text)\n    timestamp = get_timestamp()\n    llm_response = Response(\n        output=full_response.text,\n        completion_tokens=full_response.usage_metadata.candidates_token_count,\n        prompt_tokens=full_response.usage_metadata.prompt_token_count,\n        total_tokens=full_response.usage_metadata.total_token_count,\n        model=model,\n        timestamp=timestamp,\n        full_response=full_response,\n        prompts=prompts,\n        settings=settings\n    )\n\n    return llm_response\n\n\ndef anthropic_chat_call(model, prompts, settings=None):\n    \"\"\"Call an Anthropic model with a list of prompts.\"\"\"\n    # If settings are provided, use them. Otherwise, use defaults.\n    logger.debug(\"Calling Anthropic model %s\", model)\n    if settings is not None:\n        temperature = settings.temperature\n    else:\n        temperature = 0\n\n    # Retrieve the system and user prompts from the list of prompts\n    prompt_system_text = next(\n        (prompt['content'] for prompt in prompts if prompt['role'] == 'system'), None)\n    prompt_user_text = next(\n        (prompt['content'] for prompt in prompts if prompt['role'] == 'user'), None)\n    if prompt_system_text is None:\n        logger.error(\"System prompt not found.\")\n    if prompt_user_text is None:\n        logger.error(\"User prompt not found.\")\n\n    client = anthropic.Anthropic()\n\n    if model == 'claude-3-5-sonnet-20240620':\n        full_response = client.messages.create(\n            model=model,\n            max_tokens=8192,\n            extra_headers={\n                \"anthropic-beta\": \"max-tokens-3-5-sonnet-2024-07-15\"},\n            temperature=temperature,\n            system=prompt_system_text,\n            messages=[\n                {\"role\": \"user\", \"content\": prompt_user_text},\n            ]\n        )\n    else:\n        full_response = client.messages.create(\n            model=model,\n            max_tokens=4096,\n            temperature=temperature,\n            system=prompt_system_text,\n            messages=[\n                {\"role\": \"user\", \"content\": prompt_user_text},\n            ]\n        )\n    timestamp = get_timestamp()\n\n    llm_response = Response(\n        output=full_response.content[0].text,\n        completion_tokens=full_response.usage.output_tokens,\n        prompt_tokens=full_response.usage.input_tokens,\n        total_tokens=(full_response.usage.output_tokens +\n                      full_response.usage.input_tokens),\n        model=full_response.model,\n        timestamp=timestamp,\n        full_response=full_response,\n        prompts=prompts,\n        settings=settings\n    )\n\n    return llm_response\n"}
{"type": "source_file", "path": "src/utils_file.py", "content": "\"\"\"\nUtility functions for loading, saving, and exporting.\n\nFunctions\nget_root_dir() -> str\n    Returns the root directory for the package.\n    Returns:\n        A string representing the root directory of the package.\n\"\"\"\nimport logging\nimport os\n\n\n# Set up logger\nlogger = logging.getLogger('method-actors')\n\n\nclass RootDirectoryNotFoundError(Exception):\n    \"\"\"Exception raised when the root directory is not found.\"\"\"\n\n    def __init__(self, max_depth):\n        self.max_depth = max_depth\n        self.message = f\"Root directory 'llms_as_method_actors' not found within depth: {max_depth}\"\n        super().__init__(self.message)\n\n\ndef get_root_dir(max_depth=10):\n    \"\"\"Returns the root directory for the package.\"\"\"\n    # get the current directory\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    # get the root directory\n    depth = 0\n    while os.path.basename(current_dir) != 'llms_as_method_actors' and depth < max_depth:\n        current_dir = os.path.dirname(current_dir)\n        depth += 1\n    if os.path.basename(current_dir) == 'llms_as_method_actors':\n        return current_dir\n    else:\n        raise RootDirectoryNotFoundError(max_depth)\n"}

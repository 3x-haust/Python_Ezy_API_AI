{"repo_info": {"repo_name": "fastapi_base", "repo_owner": "DJWOMS", "repo_url": "https://github.com/DJWOMS/fastapi_base"}}
{"type": "source_file", "path": "src/interfaces/permission_interface.py", "content": "from abc import ABC\nfrom typing import NewType\n\nfrom ..models.base_model import Base\n\n\nUserModel = NewType(\"UserModel\", Base)\n\n\nclass AbstractPermission(ABC):\n    def __call__(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def check_permissions(self, user: UserModel) -> UserModel:\n        raise NotImplementedError\n"}
{"type": "source_file", "path": "examples/app_support_2/src/support/schemas/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/support/repositories/category_repository.py", "content": "from sqlalchemy import select\nfrom sqlalchemy.orm import load_only\n\nfrom src.repositories.sqlalchemy_repository import SqlAlchemyRepository, ModelType\nfrom src.models.category_model import CategoryModel\nfrom src.config.database.db_helper import db_helper\n\nfrom ..schemas.category_schema import CategoryCreate, CategoryUpdate\n\n\nclass CategoryRepository(SqlAlchemyRepository[ModelType, CategoryCreate, CategoryUpdate]):\n\n    async def filter(\n        self,\n        fields: list[str] | None = None,\n        order: list[str] | None = None,\n        limit: int = 100,\n        offset: int = 0,\n    ) -> list[ModelType] | None:\n        async with self._session_factory() as session:\n            stmt = select(self.model)\n            if fields:\n                model_fields = [getattr(self.model, field) for field in fields]\n                stmt = stmt.options(load_only(*model_fields))\n            if order:\n                stmt = stmt.order_by(*order)\n            if limit is not None:\n                stmt = stmt.limit(limit)\n            if offset is not None:\n                stmt = stmt.offset(offset)\n\n            row = await session.execute(stmt)\n            return row.scalars().all()\n\n    async def all(self) -> list[ModelType] | None:\n        return await self.filter()\n\n    async def exists(self, **filters) -> bool:\n        stmt = select(self.model).filter_by(**filters)\n        async with self._session_factory() as session:\n            result = await session.execute(stmt)\n            return result.scalar() is not None\n\n\ncategory_repository = CategoryRepository(model=CategoryModel, db_session=db_helper.get_db_session)\n"}
{"type": "source_file", "path": "examples/app_support_2/src/services/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/support/schemas/category_schema.py", "content": "from pydantic import BaseModel\n\n\nclass CategoryBase(BaseModel):\n    name: str\n\n\nclass CategoryCreate(CategoryBase):\n    pass\n\n\nclass CategoryUpdate(CategoryBase):\n    pass\n\n\nclass CategoryResponse(CategoryBase):\n    id: int\n\n\nclass CategoryListResponse(BaseModel):\n    id: int | None = None\n    name: str | None = None\n"}
{"type": "source_file", "path": "examples/app_support_2/src/services/base_service.py", "content": "from ..schemas.base_schema import PyModel\nfrom ..repositories.base_repository import AbstractRepository\nfrom ..repositories.sqlalchemy_repository import ModelType\n\n\nclass BaseService:\n\n    def __init__(self, repository: AbstractRepository) -> None:\n        self.repository: AbstractRepository = repository\n\n    async def create(self, model: PyModel) -> ModelType:\n        return await self.repository.create(data=model.model_dump())\n\n    async def update(self, pk: int, model: PyModel) -> ModelType:\n        return await self.repository.update(data=model.model_dump(), id=pk)\n\n    async def delete(self, pk: int) -> None:\n        await self.repository.delete(id=pk)\n\n    async def get(self, pk: int) -> ModelType:\n        return await self.repository.get(id=pk)\n"}
{"type": "source_file", "path": "examples/app_support_2/src/support/schemas/support_schema.py", "content": "from pydantic import BaseModel\n\n\nclass SupportBase(BaseModel):\n    category_id: int\n    username: str\n    text: str\n\n\nclass SupportCreate(SupportBase):\n    pass\n\n\nclass SupportUpdate(SupportBase):\n    pass\n\n\nclass SupportResponse(SupportBase):\n    id: int\n"}
{"type": "source_file", "path": "examples/app_support_2/src/services/query_base_service.py", "content": "from abc import ABC, abstractmethod\nfrom typing import Sequence, TypeVar, Generic\n\n\n_T = TypeVar('_T')\n\n\nclass QueryService(ABC, Generic[_T]):\n\n    @abstractmethod\n    def find_by_id(self, id_: int) -> _T | None:\n        raise NotImplementedError()\n\n    @abstractmethod\n    def findall(self) -> Sequence[_T]:\n        raise NotImplementedError()\n"}
{"type": "source_file", "path": "examples/app_support_2/src/support/__int__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/support/services/category_service.py", "content": "from src.repositories.sqlalchemy_repository import ModelType\nfrom src.services.base_service import BaseService\nfrom ..repositories.category_repository import category_repository\n\n\nclass CategoryService(BaseService):\n\n    async def filter(\n            self,\n            fields: list[str] | None = None,\n            order: list[str] | None = None,\n            limit: int | None = None,\n            offset: int | None = None\n    ) -> list[ModelType] | None:\n        return await self.repository.filter(\n            fields=fields,\n            order=order,\n            limit=limit,\n            offset=offset\n        )\n\n    async def exists(self, name: str) -> bool:\n        return await self.repository.exists(name=name)\n\n\ncategory_service = CategoryService(repository=category_repository)\n"}
{"type": "source_file", "path": "examples/app_support_2/src/support/controllers/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/support/services/support_services.py", "content": "from src.services.base_service import BaseService\nfrom ..repositories.support_repository import support_repository\n\n\nclass SupportService(BaseService):\n    pass\n\n\nsupport_service = SupportService(repository=support_repository)\n"}
{"type": "source_file", "path": "examples/app_support_2/src/support/controllers/admin_controller.py", "content": "from typing import Annotated\n\nfrom fastapi import Depends, HTTPException, Query, APIRouter\nfrom starlette.status import HTTP_400_BAD_REQUEST, HTTP_204_NO_CONTENT\n\nfrom ..schemas.category_schema import (\n    CategoryCreate,\n    CategoryResponse,\n    CategoryListResponse\n)\nfrom ..services.category_service import category_service\nfrom ...schemas.user_schema import User\n\nrouter = APIRouter(prefix=\"/admin\", tags=[\"admin\"])\n\n\ndef is_admin():\n    return User(id=1, name=\"admin\")\n\n\n@router.get(\"/category/exists\")\nasync def exists_category_for_name(name: str, user: User = Depends(is_admin)) -> bool:\n    try:\n        return await category_service.exists(name)\n    except Exception as e:\n        raise HTTPException(HTTP_400_BAD_REQUEST, str(e))\n\n\n@router.post(\"/category\")\nasync def create_category(\n        data: CategoryCreate,\n        user: User = Depends(is_admin)\n) -> CategoryResponse:\n    try:\n        return await category_service.create(model=data)\n    except Exception as e:\n        raise HTTPException(HTTP_400_BAD_REQUEST, str(e))\n\n\n@router.put(\"/category/{pk}\")\nasync def update_category(pk: int, data: CategoryCreate) -> CategoryResponse:\n    try:\n        return await category_service.update(pk=pk, model=data)\n    except Exception as e:\n        raise HTTPException(HTTP_400_BAD_REQUEST, str(e))\n\n\n@router.delete(\"/category/{pk}\", status_code=HTTP_204_NO_CONTENT)\nasync def delete_category(pk: int):\n    try:\n        return await category_service.delete(pk=pk)\n    except Exception as e:\n        raise HTTPException(HTTP_400_BAD_REQUEST, str(e))\n\n\n@router.get(\"/category/{pk}\")\nasync def get_single_category(pk: int) -> CategoryResponse:\n    try:\n        return await category_service.get(pk=pk)\n    except Exception as e:\n        raise HTTPException(HTTP_400_BAD_REQUEST, str(e))\n\n\n@router.get(\"/category\")\nasync def filter_category(\n        fields: Annotated[list, Query()] = [],\n        order: Annotated[list, Query()] = [],\n        limit: int | None = None,\n        offset: int | None = None\n) -> list[CategoryListResponse] | None:\n    try:\n        return await category_service.filter(\n            fields=fields,\n            order=order,\n            limit=limit,\n            offset=offset\n        )\n    except Exception as e:\n        raise HTTPException(HTTP_400_BAD_REQUEST, str(e))\n"}
{"type": "source_file", "path": "src/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/support/controllers/support_controller.py", "content": "from fastapi import APIRouter, HTTPException\nfrom starlette.status import HTTP_400_BAD_REQUEST\n\nfrom ..schemas.support_schema import SupportCreate, SupportResponse\nfrom ..services.support_services import support_service\n\nrouter = APIRouter(prefix='/support', tags=[\"support\"])\n\n\n@router.post(\"/\", response_model=SupportResponse)\nasync def create_support(data: SupportCreate) -> SupportResponse:\n    try:\n        return await support_service.create(data)\n    except Exception as e:\n        raise HTTPException(HTTP_400_BAD_REQUEST, str(e))\n"}
{"type": "source_file", "path": "src/interfaces/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/support/repositories/__init__.py", "content": ""}
{"type": "source_file", "path": "__init__.py", "content": ""}
{"type": "source_file", "path": "config/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/support/repositories/support_repository.py", "content": "from src.repositories.sqlalchemy_repository import SqlAlchemyRepository\nfrom src.models.support_model import SupportModel\nfrom src.config.database.db_helper import db_helper\n\nfrom ..schemas.support_schema import SupportCreate, SupportUpdate\n\n\nclass SupportRepository(SqlAlchemyRepository[SupportModel, SupportCreate, SupportUpdate]):\n    pass\n\n\nsupport_repository = SupportRepository(model=SupportModel, db_session=db_helper.get_db_session)\n"}
{"type": "source_file", "path": "config/database/__init__.py", "content": ""}
{"type": "source_file", "path": "config/database/db_config.py", "content": "from typing import Optional\n\nfrom pydantic import PostgresDsn\nfrom pydantic_settings import BaseSettings\n\n\nclass ConfigDataBase(BaseSettings):\n    POSTGRES_USER: str\n    POSTGRES_PASSWORD: str\n    POSTGRES_HOST: str\n    POSTGRES_PORT: str\n    POSTGRES_DB: str\n    DB_ECHO_LOG: bool = False\n\n    @property\n    def database_url(self) -> Optional[PostgresDsn]:\n        return (\n            f\"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@\"\n            f\"{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}\"\n        )\n\n\nsettings_db = ConfigDataBase()\n"}
{"type": "source_file", "path": "examples/app_support_2/src/config/__init__.py", "content": ""}
{"type": "source_file", "path": "config/project_config.py", "content": "from dotenv import load_dotenv\n\nfrom pydantic_settings import BaseSettings\n\nload_dotenv()\n\n\nclass Settings(BaseSettings):\n    DB_ECHO: bool\n    PROJECT_NAME: str\n    VERSION: str\n    DEBUG: bool\n    CORS_ALLOWED_ORIGINS: str\n\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "examples/app_support_2/src/config/database/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/migrations/env.py", "content": "from logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nfrom alembic import context\nfrom migrations.base import Base\nfrom src.config.database.db_config import settings_db\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\nsection = config.config_ini_section\nconfig.set_section_option(section, \"POSTGRES_HOST\", settings_db.POSTGRES_HOST)\nconfig.set_section_option(section, \"POSTGRES_PORT\", settings_db.POSTGRES_PORT)\nconfig.set_section_option(section, \"POSTGRES_USER\", settings_db.POSTGRES_USER)\nconfig.set_section_option(section, \"POSTGRES_DB\", settings_db.POSTGRES_DB)\nconfig.set_section_option(section, \"POSTGRES_PASSWORD\", settings_db.POSTGRES_PASSWORD)\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "examples/app_support_2/src/repositories/base_repository.py", "content": "from abc import ABC, abstractmethod\n\n\nclass AbstractRepository(ABC):\n\n    @abstractmethod\n    async def create(self, **kwargs):\n        raise NotImplementedError\n\n    @abstractmethod\n    async def update(self, **kwargs):\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, **kwargs):\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_single(self, **kwargs):\n        raise NotImplementedError\n"}
{"type": "source_file", "path": "examples/app_support_2/src/mock/auth_api.py", "content": "async def auth_api_mock(token: str) -> dict | None:\n    if token == '12345':\n        return {\"id\": 1, \"permission\": \"admin\"}\n"}
{"type": "source_file", "path": "examples/app_support_2/main.py", "content": "import uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom src.config.project_config import settings\nfrom src.routes import get_apps_router\n\n\ndef get_application() -> FastAPI:\n    application = FastAPI(\n        title=settings.PROJECT_NAME,\n        debug=settings.DEBUG,\n        version=settings.VERSION\n    )\n    application.include_router(get_apps_router())\n\n    application.add_middleware(\n        CORSMiddleware,\n        allow_origins=settings.CORS_ALLOWED_ORIGINS.split(\" \"),\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    return application\n\n\napp = get_application()\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", reload=True)\n"}
{"type": "source_file", "path": "examples/app_support_2/src/routes.py", "content": "from fastapi import APIRouter\n\nfrom .support.controllers import support_controller, admin_controller\n\n\ndef get_apps_router():\n    router = APIRouter()\n    router.include_router(admin_controller.router)\n    router.include_router(support_controller.router)\n    return router\n"}
{"type": "source_file", "path": "examples/app_support_2/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/schemas/__init__.py", "content": ""}
{"type": "source_file", "path": "config/database/db_helper.py", "content": "from asyncio import current_task\nfrom contextlib import asynccontextmanager\n\nfrom sqlalchemy.ext.asyncio import (\n    AsyncSession,\n    create_async_engine,\n    async_sessionmaker,\n    async_scoped_session\n)\n\nfrom .db_config import settings_db\n\n\nclass DatabaseHelper:\n    def __init__(self, url: str, echo: bool = False):\n        self.engine = create_async_engine(url=url, echo=echo)\n\n        self.session_factory = async_sessionmaker(\n            bind=self.engine,\n            autoflush=False,\n            autocommit=False,\n            expire_on_commit=False\n        )\n\n    def get_scope_session(self):\n        return async_scoped_session(\n            session_factory=self.session_factory,\n            scopefunc=current_task\n        )\n\n    @asynccontextmanager\n    async def get_db_session(self):\n        from sqlalchemy import exc\n\n        session: AsyncSession = self.session_factory()\n        try:\n            yield session\n        except exc.SQLAlchemyError as error:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\n\ndb_helper = DatabaseHelper(settings_db.database_url, settings_db.DB_ECHO_LOG)\n"}
{"type": "source_file", "path": "examples/app_support_2/src/models/category_model.py", "content": "from sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom .base_model import Base\n\n\nclass CategoryModel(Base):\n    __tablename__ = \"categories\"\n\n    name: Mapped[str] = mapped_column(String(50), unique=True)\n"}
{"type": "source_file", "path": "examples/app_support_2/migrations/__init__.py", "content": "\n\n\n"}
{"type": "source_file", "path": "examples/app_support_2/src/models/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/repositories/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/interfaces/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/schemas/base_schema.py", "content": "from typing import NewType\n\nfrom pydantic import BaseModel\n\nPyModel = NewType(\"PyModel\", BaseModel)\n\n\nclass Base(BaseModel):\n    class Config:\n        from_attributes = True\n"}
{"type": "source_file", "path": "examples/app_support_2/src/__init__.py", "content": "\n"}
{"type": "source_file", "path": "examples/app_support_2/src/models/base_model.py", "content": "from datetime import datetime\n\nfrom sqlalchemy import TIMESTAMP, func\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, declared_attr, mapped_column\n\n\nclass Base(DeclarativeBase):\n    __abstarct__ = True\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\n    created_at: Mapped[datetime] = mapped_column(default=func.now())\n    updated_at: Mapped[datetime] = mapped_column(\n        TIMESTAMP(timezone=True),\n        default=func.now(),\n        onupdate=func.now()\n    )\n\n    @declared_attr.directive\n    def __tablename__(cls) -> str:\n        return f\"{cls.__name__.lower()}s\"\n"}
{"type": "source_file", "path": "examples/app_support_2/src/config/project_config.py", "content": "from dotenv import load_dotenv\n\nfrom pydantic_settings import BaseSettings\n\nload_dotenv()\n\n\nclass Settings(BaseSettings):\n    DB_ECHO: bool\n    PROJECT_NAME: str\n    VERSION: str\n    DEBUG: bool\n    CORS_ALLOWED_ORIGINS: str\n\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "examples/app_support_2/migrations/base.py", "content": "# flake8: noqa F401\nfrom src.models.base_model import Base\nfrom src.models.support_model import SupportModel\nfrom src.models.category_model import CategoryModel\n"}
{"type": "source_file", "path": "examples/app_support_2/src/interfaces/permission_interface.py", "content": "from abc import ABC\nfrom typing import NewType\n\nfrom ..models.base_model import Base\n\n\nUserModel = NewType(\"UserModel\", Base)\n\n\nclass AbstractPermission(ABC):\n    def __call__(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def check_permissions(self, user: UserModel) -> UserModel:\n        raise NotImplementedError\n"}
{"type": "source_file", "path": "examples/app_support_2/src/schemas/user_schema.py", "content": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n"}
{"type": "source_file", "path": "examples/app_support_2/src/config/database/db_config.py", "content": "from typing import Optional\n\nfrom pydantic import PostgresDsn\nfrom pydantic_settings import BaseSettings\n\n\nclass ConfigDataBase(BaseSettings):\n    POSTGRES_USER: str\n    POSTGRES_PASSWORD: str\n    POSTGRES_HOST: str\n    POSTGRES_PORT: str\n    POSTGRES_DB: str\n    DB_ECHO_LOG: bool = False\n\n    @property\n    def database_url(self) -> Optional[PostgresDsn]:\n        return (\n            f\"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@\"\n            f\"{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}\"\n        )\n\n\nsettings_db = ConfigDataBase()\n"}
{"type": "source_file", "path": "examples/__init__.py", "content": ""}
{"type": "source_file", "path": "examples/app_support_2/src/config/database/db_helper.py", "content": "from asyncio import current_task\nfrom contextlib import asynccontextmanager\n\nfrom sqlalchemy.ext.asyncio import (\n    AsyncSession,\n    create_async_engine,\n    async_sessionmaker,\n    async_scoped_session\n)\n\nfrom .db_config import settings_db\n\n\nclass DatabaseHelper:\n    def __init__(self, url: str, echo: bool = False):\n        self.engine = create_async_engine(url=url, echo=echo)\n\n        self.session_factory = async_sessionmaker(\n            bind=self.engine,\n            autoflush=False,\n            autocommit=False,\n            expire_on_commit=False\n        )\n\n    def get_scope_session(self):\n        return async_scoped_session(\n            session_factory=self.session_factory,\n            scopefunc=current_task\n        )\n\n    @asynccontextmanager\n    async def get_db_session(self):\n        from sqlalchemy import exc\n\n        session: AsyncSession = self.session_factory()\n        try:\n            yield session\n        except exc.SQLAlchemyError as error:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\n\ndb_helper = DatabaseHelper(settings_db.database_url, settings_db.DB_ECHO_LOG)\n"}
{"type": "source_file", "path": "examples/app_support_2/src/repositories/sqlalchemy_repository.py", "content": "from typing import Type, TypeVar, Optional, Generic\n\nfrom pydantic import BaseModel\nfrom sqlalchemy import delete, select, update\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ..models.base_model import Base\n\nfrom .base_repository import AbstractRepository\n\n\nModelType = TypeVar(\"ModelType\", bound=Base)\nCreateSchemaType = TypeVar(\"CreateSchemaType\", bound=BaseModel)\nUpdateSchemaType = TypeVar(\"UpdateSchemaType\", bound=BaseModel)\n\n\nclass SqlAlchemyRepository(AbstractRepository, Generic[ModelType, CreateSchemaType, UpdateSchemaType]):\n\n    def __init__(self, model: Type[ModelType], db_session: AsyncSession):\n        self._session_factory = db_session\n        self.model = model\n\n    async def create(self, data: CreateSchemaType) -> ModelType:\n        async with self._session_factory() as session:\n            instance = self.model(**data)\n            session.add(instance)\n            await session.commit()\n            await session.refresh(instance)\n            return instance\n\n    async def update(self, data: UpdateSchemaType, **filters) -> ModelType:\n        async with self._session_factory() as session:\n            stmt = update(self.model).values(**data).filter_by(**filters).returning(self.model)\n            res = await session.execute(stmt)\n            await session.commit()\n            return res.scalar_one()\n\n    async def delete(self, **filters) -> None:\n        async with self._session_factory() as session:\n            await session.execute(delete(self.model).filter_by(**filters))\n            await session.commit()\n\n    async def get_single(self, **filters) -> Optional[ModelType] | None:\n        async with self._session_factory() as session:\n            row = await session.execute(select(self.model).filter_by(**filters))\n            return row.scalar_one_or_none()\n\n    async def get_multi(\n            self,\n            order: str = \"id\",\n            limit: int = 100,\n            offset: int = 0\n    ) -> list[ModelType]:\n        async with self._session_factory() as session:\n            stmt = select(self.model).order_by(*order).limit(limit).offset(offset)\n            row = await session.execute(stmt)\n            return row.scalars().all()\n"}
{"type": "source_file", "path": "examples/app_support_2/src/models/support_model.py", "content": "from sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom .base_model import Base\n\n\nclass SupportModel(Base):\n    category_id: Mapped[int] = mapped_column(ForeignKey(\"categories.id\"))\n    username: Mapped[str]\n    text: Mapped[str]\n"}

{"repo_info": {"repo_name": "fastapi-utils", "repo_owner": "fastapiutils", "repo_url": "https://github.com/fastapiutils/fastapi-utils"}}
{"type": "test_file", "path": "tests/conftest.py", "content": "from pathlib import Path\nfrom typing import Iterator\nfrom uuid import UUID\n\nimport pytest\nimport sqlalchemy as sa\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session\n\nfrom fastapi_utils.guid_type import GUID, GUID_DEFAULT_SQLITE\nfrom fastapi_utils.session import FastAPISessionMaker, get_engine\n\nBase = declarative_base()\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = sa.Column(GUID, primary_key=True, default=GUID_DEFAULT_SQLITE)\n    name = sa.Column(sa.String, nullable=False)\n    related_id = sa.Column(GUID)\n\n\ntest_db_path = Path(\"./test.db\")\ndatabase_uri = f\"sqlite:///{test_db_path}?check_same_thread=False\"\nsession_maker = FastAPISessionMaker(database_uri=database_uri)\n\n\ndef get_db() -> Iterator[Session]:\n    yield from session_maker.get_db()\n\n\napp = FastAPI()\n\n\n@app.get(\"/{user_id}\")\ndef get_user_name(db: Session = Depends(get_db), *, user_id: UUID) -> str:\n    user = db.query(User).get(user_id)\n    if isinstance(user, User):\n        username = user.name\n        return username\n    return \"\"\n\n\n@pytest.fixture(scope=\"module\")\ndef test_app() -> Iterator[FastAPI]:\n    if test_db_path.exists():\n        test_db_path.unlink()\n\n    engine = get_engine(database_uri)\n    Base.metadata.create_all(bind=engine)\n\n    yield app\n    if test_db_path.exists():\n        test_db_path.unlink()\n"}
{"type": "test_file", "path": "tests/test_api_settings.py", "content": "from __future__ import annotations\n\nimport pytest\nfrom _pytest.monkeypatch import MonkeyPatch\nfrom fastapi import FastAPI\nfrom starlette.status import HTTP_200_OK, HTTP_404_NOT_FOUND\nfrom starlette.testclient import TestClient\n\nfrom fastapi_utils.api_settings import get_api_settings\n\n\ndef get_app() -> FastAPI:\n    get_api_settings.cache_clear()\n    api_settings = get_api_settings()\n    return FastAPI(**api_settings.fastapi_kwargs)\n\n\n@pytest.mark.parametrize(\"disable_docs,status_code\", [(\"1\", HTTP_404_NOT_FOUND), (\"0\", HTTP_200_OK)])\ndef test_enable_docs(monkeypatch: MonkeyPatch, disable_docs: str, status_code: int) -> None:\n    monkeypatch.setenv(\"API_DISABLE_DOCS\", disable_docs)\n    app = get_app()\n    response = TestClient(app).get(\"/docs\")\n    assert response.status_code == status_code\n"}
{"type": "test_file", "path": "tests/test_api_model.py", "content": "from __future__ import annotations\n\nfrom dataclasses import dataclass\n\nimport pydantic\n\nfrom fastapi_utils.api_model import APIModel\n\nPYDANTIC_VERSION = pydantic.VERSION\n\n\ndef test_orm_mode() -> None:\n    @dataclass\n    class Data:\n        x: int\n\n    class Model(APIModel):\n        x: int\n\n        model_config = {\"from_attributes\": True}\n\n    if PYDANTIC_VERSION[0] == \"2\":\n        assert Model.model_validate(Data(x=1)).x == 1\n    else:\n        assert Model.from_orm(Data(x=1)).x == 1\n\n\ndef test_aliases() -> None:\n    class Model(APIModel):\n        some_field: str\n\n    assert Model(some_field=\"a\").some_field == \"a\"\n    assert Model(someField=\"a\").some_field == \"a\"  # type: ignore[call-arg]\n"}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/test_cbv_base.py", "content": "from typing import Any, Dict, List, Optional, Union\n\nfrom fastapi import FastAPI\nfrom fastapi.responses import PlainTextResponse\nfrom starlette.testclient import TestClient\n\nfrom fastapi_utils.cbv_base import Api, Resource, set_responses\n\n\ndef test_cbv() -> None:\n    class CBV(Resource):\n        def __init__(self, z: int = 1):\n            super().__init__()\n            self.y = 1\n            self.z = z\n\n        @set_responses(int)\n        def post(self, x: int) -> int:\n            print(x)\n            return x + self.y + self.z\n\n        @set_responses(bool)\n        def get(self) -> bool:\n            return hasattr(self, \"cy\")\n\n    app = FastAPI()\n    api = Api(app)\n    cbv = CBV(2)\n    api.add_resource(cbv, \"/\", \"/classvar\")\n\n    client = TestClient(app)\n    response_1 = client.post(\"/\", params={\"x\": 1}, json={})\n    assert response_1.status_code == 200\n    assert response_1.content == b\"4\"\n\n    response_2 = client.get(\"/classvar\")\n    assert response_2.status_code == 200\n    assert response_2.content == b\"false\"\n\n\ndef test_arg_in_path() -> None:\n    class TestCBV(Resource):\n        @set_responses(str)\n        def get(self, item_id: str) -> str:\n            return item_id\n\n    app = FastAPI()\n    api = Api(app)\n\n    test_cbv_resource = TestCBV()\n    api.add_resource(test_cbv_resource, \"/{item_id}\")\n\n    assert TestClient(app).get(\"/test\").json() == \"test\"\n\n\ndef test_multiple_routes() -> None:\n    class RootHandler(Resource):\n        def get(self, item_path: Optional[str] = None) -> Union[List[Any], Dict[str, str]]:\n            if item_path:\n                return {\"item_path\": item_path}\n            return []\n\n    app = FastAPI()\n    api = Api(app)\n\n    root_handler_resource = RootHandler()\n    api.add_resource(root_handler_resource, \"/items/?\", \"/items/{item_path:path}\")\n\n    client = TestClient(app)\n\n    assert client.get(\"/items/1\").json() == {\"item_path\": \"1\"}\n    assert client.get(\"/items\").json() == []\n\n\ndef test_different_response_model() -> None:\n    class RootHandler(Resource):\n        @set_responses({}, response_class=PlainTextResponse)\n        def get(self) -> str:\n            return \"Done!\"\n\n    app = FastAPI()\n    api = Api(app)\n\n    api.add_resource(RootHandler(), \"/check\")\n\n    client = TestClient(app)\n\n    assert client.get(\"/check\").text == \"Done!\"\n"}
{"type": "test_file", "path": "tests/test_guid_type.py", "content": "from __future__ import annotations\n\nimport uuid\n\nfrom fastapi import FastAPI\nfrom starlette.testclient import TestClient\n\nfrom fastapi_utils.session import context_session\nfrom tests.conftest import User, session_maker\n\n\ndef test_guid(test_app: FastAPI) -> None:\n    name1 = \"test_name_1\"\n    name2 = \"test_name_2\"\n    user_id_1 = str(uuid.uuid4())\n\n    with context_session(session_maker.cached_engine) as session:\n        user1 = User(id=user_id_1, name=name1)\n        session.add(user1)\n        session.commit()\n        assert str(user1.id) == user_id_1\n        assert user1.related_id is None\n\n    with session_maker.context_session() as session:\n        user2 = User(name=name2)\n        assert user2.id is None\n        session.add(user2)\n        session.commit()\n        user_id_2 = user2.id\n        assert user_id_2 is not None\n        assert user2.related_id is None\n\n    test_client = TestClient(test_app)\n    assert test_client.get(f\"/{user_id_1}\").json() == name1\n    assert test_client.get(f\"/{user_id_2}\").json() == name2\n"}
{"type": "test_file", "path": "tests/test_inferring_router.py", "content": "from __future__ import annotations\n\nfrom typing import Any, Dict\n\nimport pytest\nfrom fastapi import FastAPI\n\nwith pytest.warns(DeprecationWarning):\n    from fastapi_utils.inferring_router import InferringRouter\n\nOpenapiSchemaType = Dict[str, Any]\n\n\ndef get_response_schema(\n    openapi_spec: OpenapiSchemaType, endpoint_path: str, expected_status_code: int = 200\n) -> OpenapiSchemaType:\n    responses = openapi_spec[\"paths\"][endpoint_path][\"get\"][\"responses\"]\n    content = responses[str(expected_status_code)].get(\"content\")\n    return content[\"application/json\"][\"schema\"] if content else content\n\n\nclass TestInferringRouter:\n    @pytest.fixture()\n    def app(self) -> FastAPI:\n        return FastAPI()\n\n    @pytest.fixture()\n    def inferring_router(self) -> InferringRouter:\n        return InferringRouter()\n\n    def test_inferring_route(self, app: FastAPI, inferring_router: InferringRouter) -> None:\n        @inferring_router.get(\"/return_string\")\n        def endpoint_1() -> str:  # pragma: no cover\n            return \"\"\n\n        @inferring_router.get(\"/return_integer\", response_model=int)\n        def endpoint_2() -> int:  # pragma: no cover\n            return 0\n\n        app.include_router(inferring_router)\n        openapi_spec = app.openapi()\n        assert get_response_schema(openapi_spec, \"/return_string\")[\"type\"] == \"string\"\n        assert get_response_schema(openapi_spec, \"/return_integer\")[\"type\"] == \"integer\"\n"}
{"type": "test_file", "path": "tests/test_timing.py", "content": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\n\nimport pytest\nfrom fastapi import FastAPI\nfrom starlette.requests import Request\nfrom starlette.staticfiles import StaticFiles\nfrom starlette.testclient import TestClient\n\nfrom fastapi_utils.timing import add_timing_middleware, record_timing\n\nif TYPE_CHECKING:\n    from pytest.capture import CaptureFixture\nelse:\n    CaptureFixture = Any\n\napp = FastAPI()\nadd_timing_middleware(app, exclude=\"untimed\")\nstatic_files_app = StaticFiles(directory=\".\")\napp.mount(path=\"/static\", app=static_files_app, name=\"static\")\n\n\n@app.get(\"/timed\")\ndef get_timed() -> None:\n    pass\n\n\n@app.get(\"/untimed\")\ndef get_untimed() -> None:\n    pass\n\n\nclient = TestClient(app)\n\n\ndef test_timing(capsys: CaptureFixture[str]) -> None:\n    client.get(\"/timed\")\n    out, err = capsys.readouterr()\n    assert err == \"\"\n    assert out.startswith(\"TIMING: Wall\")\n    assert \"CPU:\" in out\n    assert out.endswith(\"test_timing.get_timed\\n\")\n\n\ndef test_silent_timing(capsys: CaptureFixture[str]) -> None:\n    client.get(\"/untimed\")\n    out, err = capsys.readouterr()\n    assert err == \"\"\n    assert out == \"\"\n\n\ndef test_mount(capsys: CaptureFixture[str]) -> None:\n    basename = Path(__file__).name\n    client.get(f\"/static/{basename}\")\n    out, err = capsys.readouterr()\n    assert err == \"\"\n    assert out.startswith(\"TIMING:\")\n    assert out.endswith(\"StaticFiles<'static'>\\n\")\n\n\ndef test_missing(capsys: CaptureFixture[str]) -> None:\n    client.get(\"/will-404\")\n    out, err = capsys.readouterr()\n    assert err == \"\"\n    assert out.startswith(\"TIMING:\")\n    assert out.endswith(\"<Path: /will-404>\\n\")\n\n\napp2 = FastAPI()\nadd_timing_middleware(app2, prefix=\"app2\")\n\n\n@app2.get(\"/\")\ndef get_with_intermediate_timing(request: Request) -> None:\n    record_timing(request, note=\"hello\")\n\n\nclient2 = TestClient(app2)\n\n\ndef test_intermediate(capsys: CaptureFixture[str]) -> None:\n    client2.get(\"/\")\n    out, err = capsys.readouterr()\n    assert err == \"\"\n    outs = out.strip().split(\"\\n\")\n    assert len(outs) == 2\n    assert outs[0].startswith(\"TIMING:\")\n    assert outs[0].endswith(\"test_timing.get_with_intermediate_timing (hello)\")\n    assert outs[1].startswith(\"TIMING:\")\n    assert outs[1].endswith(\"test_timing.get_with_intermediate_timing\")\n\n\napp3 = FastAPI()\n\n\n@app3.get(\"/\")\ndef fail_to_record(request: Request) -> None:\n    record_timing(request)\n\n\nclient3 = TestClient(app3)\n\n\ndef test_recording_fails_without_middleware() -> None:\n    with pytest.raises(ValueError) as exc_info:\n        client3.get(\"/\")\n    assert str(exc_info.value) == \"No timer present on request\"\n"}
{"type": "test_file", "path": "tests/test_enums.py", "content": "from __future__ import annotations\n\nfrom enum import auto\n\nfrom fastapi_utils.enums import CamelStrEnum, StrEnum\n\n\nclass TestEnums:\n    def test_str_enum(self) -> None:\n        class MyStrEnum(StrEnum):\n            choice_one = auto()\n            choice_two = auto()\n\n        values = [value for value in MyStrEnum]\n        assert values == [\"choice_one\", \"choice_two\"]\n\n    def test_camelcase_str_conversion(self) -> None:\n        class MyCamelStrEnum(CamelStrEnum):\n            choice_one = auto()\n            choice_two = auto()\n\n        values = [value for value in MyCamelStrEnum]\n        assert values == [\"choiceOne\", \"choiceTwo\"]\n"}
{"type": "test_file", "path": "tests/test_session.py", "content": "from __future__ import annotations\n\nimport uuid\nfrom collections.abc import Iterator\nfrom pathlib import Path\n\nimport pytest\nfrom fastapi import FastAPI\nfrom sqlalchemy.exc import OperationalError\nfrom starlette.testclient import TestClient\n\nfrom tests.conftest import session_maker\n\nother_db_path = Path(\"./test2.db\")\nother_db_uri = f\"sqlite:///{other_db_path}?check_same_thread=False\"\n\n\n@pytest.fixture()\ndef use_uninitialized_db() -> Iterator[None]:\n    if other_db_path.exists():\n        other_db_path.unlink()\n    original_uri = session_maker.database_uri\n    session_maker.database_uri = other_db_uri\n    session_maker.reset_cache()\n    yield\n    session_maker.database_uri = original_uri\n    session_maker.reset_cache()\n    if other_db_path.exists():\n        other_db_path.unlink()\n\n\ndef test_fail(test_app: FastAPI, use_uninitialized_db: None) -> None:\n    test_client = TestClient(test_app)\n    session_maker.reset_cache()\n    session_maker.database_uri = other_db_uri\n    random_id = uuid.uuid4()\n    with pytest.raises(OperationalError) as exc_info:\n        test_client.get(f\"/{random_id}\")\n    assert \"no such table: user\" in str(exc_info.value)\n"}
{"type": "test_file", "path": "tests/test_openapi.py", "content": "from __future__ import annotations\n\nimport pytest\nfrom fastapi import FastAPI\n\nfrom fastapi_utils.openapi import simplify_operation_ids\n\n\n@pytest.fixture\ndef app() -> FastAPI:\n    app = FastAPI()\n\n    @app.get(\"/endpoint-path\")\n    def endpoint_name() -> str:  # pragma: no cover\n        return \"\"\n\n    return app\n\n\ndef test_base_spec(app: FastAPI) -> None:\n    assert app.openapi()[\"paths\"][\"/endpoint-path\"][\"get\"][\"operationId\"] == \"endpoint_name_endpoint_path_get\"\n\n\ndef test_simplify_spec(app: FastAPI) -> None:\n    simplify_operation_ids(app)\n    assert app.openapi()[\"paths\"][\"/endpoint-path\"][\"get\"][\"operationId\"] == \"endpoint_name\"\n"}
{"type": "test_file", "path": "tests/test_cbv.py", "content": "from __future__ import annotations\r\n\r\nfrom typing import Any, ClassVar, Optional\r\n\r\nimport pytest\r\nfrom fastapi import APIRouter, Depends, Request\r\nfrom starlette.testclient import TestClient\r\n\r\nfrom fastapi_utils.cbv import cbv\r\n\r\n\r\nclass TestCBV:\r\n    @pytest.fixture(autouse=True)\r\n    def router(self) -> APIRouter:\r\n        return APIRouter()\r\n\r\n    def test_response_models(self, router: APIRouter) -> None:\r\n        expected_response = \"home\"\r\n\r\n        @cbv(router)\r\n        class CBV:\r\n            def __init__(self) -> None:\r\n                self.one = 1\r\n                self.two = 2\r\n\r\n            @router.get(\"/\", response_model=str)\r\n            def string_response(self) -> str:\r\n                return expected_response\r\n\r\n            @router.get(\"/sum\", response_model=int)\r\n            def int_response(self) -> int:\r\n                return self.one + self.two\r\n\r\n        client = TestClient(router)\r\n        response_1 = client.get(\"/\")\r\n        assert response_1.status_code == 200\r\n        assert response_1.json() == expected_response\r\n\r\n        response_2 = client.get(\"/sum\")\r\n        assert response_2.status_code == 200\r\n        assert response_2.content == b\"3\"\r\n\r\n    def test_dependencies(self, router: APIRouter) -> None:\r\n        def dependency_one() -> int:\r\n            return 1\r\n\r\n        def dependency_two() -> int:\r\n            return 2\r\n\r\n        @cbv(router)\r\n        class CBV:\r\n            one: int = Depends(dependency_one)\r\n\r\n            def __init__(self, two: int = Depends(dependency_two)):\r\n                self.two = two\r\n\r\n            @router.get(\"/\", response_model=int)\r\n            def int_dependencies(self) -> int:\r\n                return self.one + self.two\r\n\r\n        client = TestClient(router)\r\n        response = client.get(\"/\")\r\n        assert response.status_code == 200\r\n        assert response.content == b\"3\"\r\n\r\n    def test_class_var(self, router: APIRouter) -> None:\r\n        @cbv(router)\r\n        class CBV:\r\n            class_var: ClassVar[int]\r\n\r\n            @router.get(\"/\", response_model=bool)\r\n            def g(self) -> bool:\r\n                return hasattr(self, \"class_var\")\r\n\r\n        client = TestClient(router)\r\n        response = client.get(\"/\")\r\n        assert response.status_code == 200\r\n        assert response.content == b\"false\"\r\n\r\n    def test_routes_path_order_preserved(self, router: APIRouter) -> None:\r\n        @cbv(router)\r\n        class CBV:\r\n            @router.get(\"/test\")\r\n            def get_test(self) -> int:\r\n                return 1\r\n\r\n            @router.get(\"/{any_path}\")\r\n            def get_any_path(self) -> int:  # Alphabetically before `get_test`\r\n                return 2\r\n\r\n        client = TestClient(router)\r\n        assert client.get(\"/test\").json() == 1\r\n        assert client.get(\"/any_other_path\").json() == 2\r\n\r\n    def test_multiple_paths(self, router: APIRouter) -> None:\r\n        @cbv(router)\r\n        class CBV:\r\n            @router.get(\"/items\")\r\n            @router.get(\"/items/{custom_path:path}\")\r\n            @router.get(\"/database/{custom_path:path}\")\r\n            def root(self, custom_path: Optional[str] = None) -> Any:\r\n                return {\"custom_path\": custom_path} if custom_path else []\r\n\r\n        client = TestClient(router)\r\n        assert client.get(\"/items\").json() == []\r\n        assert client.get(\"/items/1\").json() == {\"custom_path\": \"1\"}\r\n        assert client.get(\"/database/abc\").json() == {\"custom_path\": \"abc\"}\r\n\r\n    def test_query_parameters(self, router: APIRouter) -> None:\r\n        @cbv(router)\r\n        class CBV:\r\n            @router.get(\"/route\")\r\n            def root(self, param: Optional[int] = None) -> int:\r\n                return param if param else 0\r\n\r\n        client = TestClient(router)\r\n        assert client.get(\"/route\").json() == 0\r\n        assert client.get(\"/route?param=3\").json() == 3\r\n\r\n    def test_prefix(self) -> None:\r\n        router = APIRouter(prefix=\"/api\")\r\n\r\n        @cbv(router)\r\n        class CBV:\r\n            @router.get(\"/item\")\r\n            def root(self) -> str:\r\n                return \"hello\"\r\n\r\n        client = TestClient(router)\r\n        response = client.get(\"/api/item\")\r\n        assert response.status_code == 200\r\n        assert response.json() == \"hello\"\r\n\r\n    def test_url_for(self, router: APIRouter) -> None:\r\n        @cbv(router)\r\n        class Foo:\r\n            @router.get(\"/foo\")\r\n            def example(self, request: Request) -> str:\r\n                return str(request.url_for(\"Bar.example\"))\r\n\r\n        @cbv(router)\r\n        class Bar:\r\n            @router.get(\"/bar\")\r\n            def example(self, request: Request) -> str:\r\n                return str(request.url_for(\"Foo.example\"))\r\n\r\n        client = TestClient(router)\r\n        response = client.get(\"/foo\")\r\n        assert response.json() == \"http://testserver/bar\"\r\n"}
{"type": "test_file", "path": "tests/test_tasks.py", "content": "import asyncio\r\nfrom typing import NoReturn\r\nfrom unittest.mock import AsyncMock, call, patch\r\n\r\nimport pytest\r\n\r\nfrom fastapi_utils.tasks import NoArgsNoReturnAsyncFuncT, repeat_every\r\n\r\n\r\n# Fixtures:\r\n@pytest.fixture(scope=\"module\")\r\ndef seconds() -> float:\r\n    return 0.01\r\n\r\n\r\n@pytest.fixture(scope=\"module\")\r\ndef max_repetitions() -> int:\r\n    return 3\r\n\r\n\r\n@pytest.fixture(scope=\"module\")\r\ndef wait_first(seconds: float) -> float:\r\n    return seconds\r\n\r\n\r\n# Tests:\r\nclass TestRepeatEveryBase:\r\n    def setup_method(self) -> None:\r\n        self.counter = 0\r\n        self.completed = asyncio.Event()\r\n\r\n    def increase_counter(self) -> None:\r\n        self.counter += 1\r\n\r\n    async def increase_counter_async(self) -> None:\r\n        self.increase_counter()\r\n\r\n    def loop_completed(self) -> None:\r\n        self.completed.set()\r\n\r\n    async def loop_completed_async(self) -> None:\r\n        self.loop_completed()\r\n\r\n    def kill_loop(self, exc: Exception) -> None:\r\n        self.completed.set()\r\n        raise exc\r\n\r\n    async def kill_loop_async(self, exc: Exception) -> None:\r\n        self.kill_loop(exc)\r\n\r\n    def continue_loop(self, exc: Exception) -> None:\r\n        return\r\n\r\n    async def continue_loop_async(self, exc: Exception) -> None:\r\n        self.continue_loop(exc)\r\n\r\n    def raise_exc(self) -> NoReturn:\r\n        self.increase_counter()\r\n        raise ValueError(\"error\")\r\n\r\n    async def raise_exc_async(self) -> NoReturn:\r\n        self.raise_exc()\r\n\r\n    @pytest.fixture\r\n    def increase_counter_task(self, is_async: bool, seconds: float, max_repetitions: int) -> NoArgsNoReturnAsyncFuncT:\r\n        decorator = repeat_every(seconds=seconds, max_repetitions=max_repetitions, on_complete=self.loop_completed)\r\n        if is_async:\r\n            return decorator(self.increase_counter_async)\r\n        else:\r\n            return decorator(self.increase_counter)\r\n\r\n    @pytest.fixture\r\n    def wait_first_increase_counter_task(\r\n        self, is_async: bool, seconds: float, max_repetitions: int, wait_first: float\r\n    ) -> NoArgsNoReturnAsyncFuncT:\r\n        decorator = repeat_every(\r\n            seconds=seconds, max_repetitions=max_repetitions, wait_first=wait_first, on_complete=self.loop_completed\r\n        )\r\n        if is_async:\r\n            return decorator(self.increase_counter_async)\r\n        else:\r\n            return decorator(self.increase_counter)\r\n\r\n    @pytest.fixture\r\n    def stop_on_exception_task(self, is_async: bool, seconds: float, max_repetitions: int) -> NoArgsNoReturnAsyncFuncT:\r\n        if is_async:\r\n            decorator = repeat_every(\r\n                seconds=seconds,\r\n                max_repetitions=max_repetitions,\r\n                on_complete=self.loop_completed_async,\r\n                on_exception=self.kill_loop_async,\r\n            )\r\n            return decorator(self.raise_exc_async)\r\n        else:\r\n            decorator = repeat_every(\r\n                seconds=seconds,\r\n                max_repetitions=max_repetitions,\r\n                on_complete=self.loop_completed,\r\n                on_exception=self.kill_loop,\r\n            )\r\n            return decorator(self.raise_exc)\r\n\r\n    @pytest.fixture\r\n    def suppressed_exception_task(\r\n        self, is_async: bool, seconds: float, max_repetitions: int\r\n    ) -> NoArgsNoReturnAsyncFuncT:\r\n        if is_async:\r\n            decorator = repeat_every(\r\n                seconds=seconds,\r\n                max_repetitions=max_repetitions,\r\n                on_complete=self.loop_completed_async,\r\n                on_exception=self.continue_loop_async,\r\n            )\r\n            return decorator(self.raise_exc_async)\r\n        else:\r\n            decorator = repeat_every(\r\n                seconds=seconds,\r\n                max_repetitions=max_repetitions,\r\n                on_complete=self.loop_completed,\r\n                on_exception=self.continue_loop,\r\n            )\r\n            return decorator(self.raise_exc)\r\n\r\n\r\nclass TestRepeatEveryWithSynchronousFunction(TestRepeatEveryBase):\r\n    @pytest.fixture\r\n    def is_async(self) -> bool:\r\n        return False\r\n\r\n    @pytest.mark.asyncio\r\n    @pytest.mark.timeout(1)\r\n    @patch(\"asyncio.sleep\")\r\n    async def test_max_repetitions(\r\n        self,\r\n        asyncio_sleep_mock: AsyncMock,\r\n        seconds: float,\r\n        max_repetitions: int,\r\n        increase_counter_task: NoArgsNoReturnAsyncFuncT,\r\n    ) -> None:\r\n        await increase_counter_task()\r\n        await self.completed.wait()\r\n\r\n        assert self.counter == max_repetitions\r\n        asyncio_sleep_mock.assert_has_calls(max_repetitions * [call(seconds)], any_order=True)\r\n\r\n    @pytest.mark.asyncio\r\n    @pytest.mark.timeout(1)\r\n    @patch(\"asyncio.sleep\")\r\n    async def test_max_repetitions_and_wait_first(\r\n        self,\r\n        asyncio_sleep_mock: AsyncMock,\r\n        seconds: float,\r\n        max_repetitions: int,\r\n        wait_first_increase_counter_task: NoArgsNoReturnAsyncFuncT,\r\n    ) -> None:\r\n        await wait_first_increase_counter_task()\r\n        await self.completed.wait()\r\n\r\n        assert self.counter == max_repetitions\r\n        asyncio_sleep_mock.assert_has_calls((max_repetitions + 1) * [call(seconds)], any_order=True)\r\n\r\n    @pytest.mark.asyncio\r\n    @pytest.mark.timeout(1)\r\n    async def test_stop_loop_on_exc(\r\n        self,\r\n        stop_on_exception_task: NoArgsNoReturnAsyncFuncT,\r\n    ) -> None:\r\n        await stop_on_exception_task()\r\n        await self.completed.wait()\r\n\r\n        assert self.counter == 1\r\n\r\n    @pytest.mark.asyncio\r\n    @pytest.mark.timeout(1)\r\n    @patch(\"asyncio.sleep\")\r\n    async def test_continue_loop_on_exc(\r\n        self,\r\n        asyncio_sleep_mock: AsyncMock,\r\n        seconds: float,\r\n        max_repetitions: int,\r\n        suppressed_exception_task: NoArgsNoReturnAsyncFuncT,\r\n    ) -> None:\r\n        await suppressed_exception_task()\r\n        await self.completed.wait()\r\n\r\n        assert self.counter == max_repetitions\r\n        asyncio_sleep_mock.assert_has_calls(max_repetitions * [call(seconds)], any_order=True)\r\n\r\n\r\nclass TestRepeatEveryWithAsynchronousFunction(TestRepeatEveryBase):\r\n    @pytest.fixture\r\n    def is_async(self) -> bool:\r\n        return True\r\n\r\n    @pytest.mark.asyncio\r\n    @pytest.mark.timeout(1)\r\n    @patch(\"asyncio.sleep\")\r\n    async def test_max_repetitions(\r\n        self,\r\n        asyncio_sleep_mock: AsyncMock,\r\n        seconds: float,\r\n        max_repetitions: int,\r\n        increase_counter_task: NoArgsNoReturnAsyncFuncT,\r\n    ) -> None:\r\n        await increase_counter_task()\r\n        await self.completed.wait()\r\n\r\n        assert self.counter == max_repetitions\r\n        asyncio_sleep_mock.assert_has_calls(max_repetitions * [call(seconds)], any_order=True)\r\n\r\n    @pytest.mark.asyncio\r\n    @pytest.mark.timeout(1)\r\n    @patch(\"asyncio.sleep\")\r\n    async def test_max_repetitions_and_wait_first(\r\n        self,\r\n        asyncio_sleep_mock: AsyncMock,\r\n        seconds: float,\r\n        max_repetitions: int,\r\n        wait_first_increase_counter_task: NoArgsNoReturnAsyncFuncT,\r\n    ) -> None:\r\n        await wait_first_increase_counter_task()\r\n        await self.completed.wait()\r\n\r\n        assert self.counter == max_repetitions\r\n        asyncio_sleep_mock.assert_has_calls((max_repetitions + 1) * [call(seconds)], any_order=True)\r\n\r\n    @pytest.mark.asyncio\r\n    @pytest.mark.timeout(1)\r\n    async def test_stop_loop_on_exc(\r\n        self,\r\n        stop_on_exception_task: NoArgsNoReturnAsyncFuncT,\r\n    ) -> None:\r\n        await stop_on_exception_task()\r\n        await self.completed.wait()\r\n\r\n        assert self.counter == 1\r\n\r\n    @pytest.mark.asyncio\r\n    @pytest.mark.timeout(1)\r\n    @patch(\"asyncio.sleep\")\r\n    async def test_continue_loop_on_exc(\r\n        self,\r\n        asyncio_sleep_mock: AsyncMock,\r\n        seconds: float,\r\n        max_repetitions: int,\r\n        suppressed_exception_task: NoArgsNoReturnAsyncFuncT,\r\n    ) -> None:\r\n        await suppressed_exception_task()\r\n        await self.completed.wait()\r\n\r\n        assert self.counter == max_repetitions\r\n        asyncio_sleep_mock.assert_has_calls(max_repetitions * [call(seconds)], any_order=True)\r\n"}
{"type": "test_file", "path": "tests/test_camelcase.py", "content": "from __future__ import annotations\n\nimport pytest\n\nfrom fastapi_utils.camelcase import camel2snake, snake2camel\n\n\n@pytest.mark.parametrize(\n    \"value,result\",\n    [\n        (\"snake_to_camel\", \"snakeToCamel\"),\n        (\"snake_2_camel\", \"snake2Camel\"),\n        (\"snake2camel\", \"snake2Camel\"),\n        (\"_snake_to_camel\", \"_snakeToCamel\"),\n        (\"snake_to_camel_\", \"snakeToCamel_\"),\n        (\"__snake_to_camel__\", \"__snakeToCamel__\"),\n        (\"snake_2\", \"snake2\"),\n        (\"_snake_2\", \"_snake2\"),\n        (\"snake_2_\", \"snake2_\"),\n    ],\n)\ndef test_snake2camel_start_lower(value: str, result: str) -> None:\n    assert snake2camel(value, start_lower=True) == result\n\n\n@pytest.mark.parametrize(\n    \"value,result\",\n    [\n        (\"snake_to_camel\", \"SnakeToCamel\"),\n        (\"snake_2_camel\", \"Snake2Camel\"),\n        (\"snake2camel\", \"Snake2Camel\"),\n        (\"_snake_to_camel\", \"_SnakeToCamel\"),\n        (\"snake_to_camel_\", \"SnakeToCamel_\"),\n        (\"__snake_to_camel__\", \"__SnakeToCamel__\"),\n        (\"snake_2\", \"Snake2\"),\n        (\"_snake_2\", \"_Snake2\"),\n        (\"snake_2_\", \"Snake2_\"),\n    ],\n)\ndef test_snake2camel(value: str, result: str) -> None:\n    assert snake2camel(value) == result\n\n\n@pytest.mark.parametrize(\n    \"value,result\",\n    [\n        (\"camel_to_snake\", \"camel_to_snake\"),\n        (\"camelToSnake\", \"camel_to_snake\"),\n        (\"camel2Snake\", \"camel_2_snake\"),\n        (\"_camelToSnake\", \"_camel_to_snake\"),\n        (\"camelToSnake_\", \"camel_to_snake_\"),\n        (\"__camelToSnake__\", \"__camel_to_snake__\"),\n        (\"CamelToSnake\", \"camel_to_snake\"),\n        (\"Camel2Snake\", \"camel_2_snake\"),\n        (\"_CamelToSnake\", \"_camel_to_snake\"),\n        (\"CamelToSnake_\", \"camel_to_snake_\"),\n        (\"__CamelToSnake__\", \"__camel_to_snake__\"),\n        (\"Camel2\", \"camel_2\"),\n        (\"Camel2_\", \"camel_2_\"),\n        (\"_Camel2\", \"_camel_2\"),\n        (\"camel2\", \"camel_2\"),\n        (\"camel2_\", \"camel_2_\"),\n        (\"_camel2\", \"_camel_2\"),\n    ],\n)\ndef test_camel2snake(value: str, result: str) -> None:\n    assert camel2snake(value) == result\n"}
{"type": "source_file", "path": "docs/src/api_settings.py", "content": "from fastapi import FastAPI\n\nfrom fastapi_utils.api_settings import get_api_settings\n\n\ndef get_app() -> FastAPI:\n    get_api_settings.cache_clear()\n    settings = get_api_settings()\n    app = FastAPI(**settings.fastapi_kwargs)\n    # <Typically, you would include endpoint routers here>\n    return app\n"}
{"type": "source_file", "path": "docs/src/class_resource_view1.py", "content": "from fastapi_utils import Resource\n\n\nclass MyApi(Resource):\n    def get(self):\n        return \"done\"\n"}
{"type": "source_file", "path": "docs/src/api_model.py", "content": "from dataclasses import dataclass\nfrom typing import NewType\nfrom uuid import UUID\n\nfrom fastapi import FastAPI\n\nfrom fastapi_utils.api_model import APIModel\n\nUserID = NewType(\"UserID\", UUID)\n\n\nclass User(APIModel):\n    user_id: UserID\n    email_address: str\n\n\n@dataclass\nclass UserORM:\n    \"\"\"\n    You can pretend this class is a SQLAlchemy model\n    \"\"\"\n\n    user_id: UserID\n    email_address: str\n\n\napp = FastAPI()\n\n\n@app.post(\"/users\", response_model=User)\nasync def create_user(user: User) -> UserORM:\n    return UserORM(user.user_id, user.email_address)\n"}
{"type": "source_file", "path": "docs/src/class_resource_view4.py", "content": "from pydantic import BaseModel\n\nfrom fastapi_utils import Resource, set_responses\n\n\n# Setup\nclass ResponseModel(BaseModel):\n    answer: str\n\n\nclass ResourceAlreadyExistsModel(BaseModel):\n    is_found: bool\n\n\nclass ResourceModel(BaseModel):\n    ID: str\n    name: str\n\n\n# Setup end\n\n\nclass MyApi(Resource):\n    def __init__(self, mongo_client):\n        self.mongo = mongo_client\n\n    @set_responses(ResponseModel)\n    def get(self):\n        return \"Done\"\n\n    @set_responses(ResponseModel, 200)\n    def put(self):\n        return \"Redone\"\n\n    @set_responses(\n        ResponseModel,\n        201,\n        {\n            409: {\n                \"description\": \"The path can't be found\",\n                \"model\": ResourceAlreadyExistsModel,\n            }\n        },\n    )\n    def post(self, res: ResourceModel):\n        if self.mongo.is_resource_exist(res.name):\n            return JSONResponse(409, content={\"is_found\": true})\n        return \"Done again\"\n"}
{"type": "source_file", "path": "docs/src/class_resource_view2.py", "content": "from fastapi import FastAPI\n\nfrom docs.src.class_resource_view1 import MyApi\nfrom fastapi_utils import Api\n\n\ndef create_app():\n    app = FastAPI()\n    api = Api(app)\n\n    myapi = MyApi()\n    api.add_resource(myapi, \"/uri\")\n\n    return app\n\n\nmain = create_app()\n"}
{"type": "source_file", "path": "docs/src/camelcase1.py", "content": "from fastapi_utils.camelcase import camel2snake, snake2camel\n\nassert snake2camel(\"some_field_name\", start_lower=False) == \"SomeFieldName\"\nassert snake2camel(\"some_field_name\", start_lower=True) == \"someFieldName\"\nassert camel2snake(\"someFieldName\") == \"some_field_name\"\nassert camel2snake(\"SomeFieldName\") == \"some_field_name\"\n"}
{"type": "source_file", "path": "docs/src/class_resource_view3.py", "content": "from fastapi import FastAPI\nfrom pymongo import MongoClient\n\nfrom docs.src.class_resource_view1 import MyApi\nfrom fastapi_utils import Api\n\n\ndef create_app():\n    app = FastAPI()\n    api = Api(app)\n\n    mongo_client = MongoClient(\"mongodb://localhost:27017\")\n    myapi = MyApi(mongo_client)\n    api.add_resource(myapi, \"/uri\")\n\n    return app\n\n\nmain = create_app()\n"}
{"type": "source_file", "path": "docs/src/guid2.py", "content": "import sqlalchemy as sa\n\nfrom fastapi_utils.guid_type import setup_guids_postgresql\n\ndatabase_uri = \"postgresql://user:password@db:5432/app\"\nengine = sa.create_engine(database_uri)\nsetup_guids_postgresql(engine)\n"}
{"type": "source_file", "path": "docs/src/guid1.py", "content": "import sqlalchemy as sa\nfrom sqlalchemy.orm import declarative_base\n\nfrom fastapi_utils.guid_type import GUID\n\nBase = declarative_base()\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = sa.Column(GUID, primary_key=True)\n    name = sa.Column(sa.String, nullable=False)\n    related_id = sa.Column(GUID)  # a nullable, related field\n"}
{"type": "source_file", "path": "docs/src/class_based_views1.py", "content": "from typing import NewType, Optional\nfrom uuid import UUID\n\nimport sqlalchemy as sa\nfrom fastapi import Depends, FastAPI, Header, HTTPException\nfrom sqlalchemy.orm import Session, declarative_base\nfrom starlette.status import HTTP_403_FORBIDDEN, HTTP_404_NOT_FOUND\n\nfrom fastapi_utils.api_model import APIMessage, APIModel\nfrom fastapi_utils.guid_type import GUID\n\n# Begin setup\nUserID = NewType(\"UserID\", UUID)\nItemID = NewType(\"ItemID\", UUID)\n\nBase = declarative_base()\n\n\nclass ItemORM(Base):\n    __tablename__ = \"item\"\n\n    item_id = sa.Column(GUID, primary_key=True)\n    owner = sa.Column(GUID, nullable=False)\n    name = sa.Column(sa.String, nullable=False)\n\n\nclass ItemCreate(APIModel):\n    name: str\n\n\nclass ItemInDB(ItemCreate):\n    item_id: ItemID\n    owner: UserID\n\n\ndef get_jwt_user(authorization: str = Header(...)) -> UserID:\n    \"\"\"Pretend this function gets a UserID from a JWT in the auth header\"\"\"\n\n\ndef get_db() -> Session:\n    \"\"\"Pretend this function returns a SQLAlchemy ORM session\"\"\"\n\n\ndef get_owned_item(session: Session, owner: UserID, item_id: ItemID) -> ItemORM:\n    item: Optional[ItemORM] = session.get(ItemORM, item_id)\n    if item is not None and item.owner != owner:\n        raise HTTPException(status_code=HTTP_403_FORBIDDEN)\n    if item is None:\n        raise HTTPException(status_code=HTTP_404_NOT_FOUND)\n    return item\n\n\n# End setup\napp = FastAPI()\n\n\n@app.post(\"/item\", response_model=ItemInDB)\ndef create_item(\n    *,\n    session: Session = Depends(get_db),\n    user_id: UserID = Depends(get_jwt_user),\n    item: ItemCreate,\n) -> ItemInDB:\n    item_orm = ItemORM(name=item.name, owner=user_id)\n    session.add(item_orm)\n    session.commit()\n    return ItemInDB.from_orm(item_orm)\n\n\n@app.get(\"/item/{item_id}\", response_model=ItemInDB)\ndef read_item(\n    *,\n    session: Session = Depends(get_db),\n    user_id: UserID = Depends(get_jwt_user),\n    item_id: ItemID,\n) -> ItemInDB:\n    item_orm = get_owned_item(session, user_id, item_id)\n    return ItemInDB.from_orm(item_orm)\n\n\n@app.put(\"/item/{item_id}\", response_model=ItemInDB)\ndef update_item(\n    *,\n    session: Session = Depends(get_db),\n    user_id: UserID = Depends(get_jwt_user),\n    item_id: ItemID,\n    item: ItemCreate,\n) -> ItemInDB:\n    item_orm = get_owned_item(session, user_id, item_id)\n    item_orm.name = item.name\n    session.add(item_orm)\n    session.commit()\n    return ItemInDB.from_orm(item_orm)\n\n\n@app.delete(\"/item/{item_id}\", response_model=APIMessage)\ndef delete_item(\n    *,\n    session: Session = Depends(get_db),\n    user_id: UserID = Depends(get_jwt_user),\n    item_id: ItemID,\n) -> APIMessage:\n    item = get_owned_item(session, user_id, item_id)\n    session.delete(item)\n    session.commit()\n    return APIMessage(detail=f\"Deleted item {item_id}\")\n"}
{"type": "source_file", "path": "docs/src/enums1.py", "content": "from enum import auto\n\nfrom fastapi_utils.enums import StrEnum\n\n\nclass MyEnum(StrEnum):\n    choice_a = auto()\n    choice_b = auto()\n\n\nassert MyEnum.choice_a.name == MyEnum.choice_a.value == \"choice_a\"\nassert MyEnum.choice_b.name == MyEnum.choice_b.value == \"choice_b\"\n"}
{"type": "source_file", "path": "docs/src/camelcase2.py", "content": "from sqlalchemy.orm import declarative_base, declared_attr\n\nfrom fastapi_utils.camelcase import camel2snake\n\n\nclass CustomBase:\n    @declared_attr\n    def __tablename__(cls) -> str:\n        return camel2snake(cls.__name__)\n\n\nBase = declarative_base(cls=CustomBase)\n"}
{"type": "source_file", "path": "docs/src/inferring_router1.py", "content": "from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/default\")\ndef get_resource(resource_id: int) -> str:\n    # the response will be serialized as a JSON number, *not* a string\n    return resource_id\n\n\ndef get_response_schema(openapi_spec, endpoint_path):\n    responses = openapi_spec[\"paths\"][endpoint_path][\"get\"][\"responses\"]\n    return responses[\"200\"][\"content\"][\"application/json\"][\"schema\"]\n\n\nopenapi_spec = app.openapi()\nassert get_response_schema(openapi_spec, \"/default\") == {}\n"}
{"type": "source_file", "path": "docs/src/class_based_views2.py", "content": "from typing import NewType, Optional\nfrom uuid import UUID\n\nimport sqlalchemy as sa\nfrom fastapi import APIRouter, Depends, FastAPI, Header, HTTPException\nfrom sqlalchemy.orm import Session, declarative_base\nfrom starlette.status import HTTP_403_FORBIDDEN, HTTP_404_NOT_FOUND\n\nfrom fastapi_utils.api_model import APIMessage, APIModel\nfrom fastapi_utils.cbv import cbv\nfrom fastapi_utils.guid_type import GUID\n\n# Begin Setup\nUserID = NewType(\"UserID\", UUID)\nItemID = NewType(\"ItemID\", UUID)\n\nBase = declarative_base()\n\n\nclass ItemORM(Base):\n    __tablename__ = \"item\"\n\n    item_id = sa.Column(GUID, primary_key=True)\n    owner = sa.Column(GUID, nullable=False)\n    name = sa.Column(sa.String, nullable=False)\n\n\nclass ItemCreate(APIModel):\n    name: str\n    owner: UserID\n\n\nclass ItemInDB(ItemCreate):\n    item_id: ItemID\n\n\ndef get_jwt_user(authorization: str = Header(...)) -> UserID:\n    \"\"\"Pretend this function gets a UserID from a JWT in the auth header\"\"\"\n\n\ndef get_db() -> Session:\n    \"\"\"Pretend this function returns a SQLAlchemy ORM session\"\"\"\n\n\ndef get_owned_item(session: Session, owner: UserID, item_id: ItemID) -> ItemORM:\n    item: Optional[ItemORM] = session.get(ItemORM, item_id)\n    if item is not None and item.owner != owner:\n        raise HTTPException(status_code=HTTP_403_FORBIDDEN)\n    if item is None:\n        raise HTTPException(status_code=HTTP_404_NOT_FOUND)\n    return item\n\n\n# End Setup\napp = FastAPI()\nrouter = APIRouter()  # Step 1: Create a router\n\n\n@cbv(router)  # Step 2: Create and decorate a class to hold the endpoints\nclass ItemCBV:\n    # Step 3: Add dependencies as class attributes\n    session: Session = Depends(get_db)\n    user_id: UserID = Depends(get_jwt_user)\n\n    @router.post(\"/item\")\n    def create_item(self, item: ItemCreate) -> ItemInDB:\n        # Step 4: Use `self.<dependency_name>` to access shared dependencies\n        item_orm = ItemORM(name=item.name, owner=self.user_id)\n        self.session.add(item_orm)\n        self.session.commit()\n        return ItemInDB.from_orm(item_orm)\n\n    @router.get(\"/item/{item_id}\")\n    def read_item(self, item_id: ItemID) -> ItemInDB:\n        item_orm = get_owned_item(self.session, self.user_id, item_id)\n        return ItemInDB.from_orm(item_orm)\n\n    @router.put(\"/item/{item_id}\")\n    def update_item(self, item_id: ItemID, item: ItemCreate) -> ItemInDB:\n        item_orm = get_owned_item(self.session, self.user_id, item_id)\n        item_orm.name = item.name\n        self.session.add(item_orm)\n        self.session.commit()\n        return ItemInDB.from_orm(item_orm)\n\n    @router.delete(\"/item/{item_id}\")\n    def delete_item(self, item_id: ItemID) -> APIMessage:\n        item = get_owned_item(self.session, self.user_id, item_id)\n        self.session.delete(item)\n        self.session.commit()\n        return APIMessage(detail=f\"Deleted item {item_id}\")\n\n\napp.include_router(router)\n"}
{"type": "source_file", "path": "docs/src/openapi1.py", "content": "from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/api/v1/resource/{resource_id}\")\ndef get_resource(resource_id: int) -> int:\n    return resource_id\n\n\npath_spec = app.openapi()[\"paths\"][\"/api/v1/resource/{resource_id}\"]\noperation_id = path_spec[\"get\"][\"operationId\"]\nassert operation_id == \"get_resource_api_v1_resource__resource_id__get\"\n"}
{"type": "source_file", "path": "docs/src/repeated_tasks1.py", "content": "from fastapi import FastAPI\nfrom sqlalchemy.orm import Session\n\nfrom fastapi_utils.session import FastAPISessionMaker\nfrom fastapi_utils.tasks import repeat_every\n\ndatabase_uri = f\"sqlite:///./test.db?check_same_thread=False\"\nsessionmaker = FastAPISessionMaker(database_uri)\n\napp = FastAPI()\n\n\ndef remove_expired_tokens(db: Session) -> None:\n    \"\"\"Pretend this function deletes expired tokens from the database\"\"\"\n\n\n@app.on_event(\"startup\")\n@repeat_every(seconds=60 * 60)  # 1 hour\ndef remove_expired_tokens_task() -> None:\n    with sessionmaker.context_session() as db:\n        remove_expired_tokens(db=db)\n"}
{"type": "source_file", "path": "docs/src/openapi2.py", "content": "from fastapi import FastAPI\n\nfrom fastapi_utils.openapi import simplify_operation_ids\n\napp = FastAPI()\n\n\n@app.get(\"/api/v1/resource/{resource_id}\")\ndef get_resource(resource_id: int) -> int:\n    return resource_id\n\n\nsimplify_operation_ids(app)\n\npath_spec = app.openapi()[\"paths\"][\"/api/v1/resource/{resource_id}\"]\noperation_id = path_spec[\"get\"][\"operationId\"]\nassert operation_id == \"get_resource\"\n"}
{"type": "source_file", "path": "docs/src/enums2.py", "content": "from enum import auto\n\nfrom fastapi_utils.enums import CamelStrEnum\n\n\nclass MyEnum(CamelStrEnum):\n    choice_a = auto()\n    choice_b = auto()\n\n\nassert MyEnum.choice_a.name == MyEnum.choice_a.value == \"choiceOne\"\nassert MyEnum.choice_b.name == MyEnum.choice_b.value == \"choiceTwo\"\n"}
{"type": "source_file", "path": "fastapi_utils/openapi.py", "content": "from __future__ import annotations\n\nfrom fastapi import FastAPI\nfrom fastapi.routing import APIRoute\n\n\ndef simplify_operation_ids(app: FastAPI) -> None:\n    \"\"\"\n    Simplify operation IDs so that generated clients have simpler api function names\n    \"\"\"\n    for route in app.routes:\n        if isinstance(route, APIRoute):\n            route.operation_id = route.name\n"}
{"type": "source_file", "path": "fastapi_utils/guid_type.py", "content": "from __future__ import annotations\n\nimport uuid\nfrom typing import TYPE_CHECKING, no_type_check\n\nimport sqlalchemy as sa\nfrom sqlalchemy.dialects.postgresql.base import UUID\nfrom sqlalchemy.sql.sqltypes import CHAR\nfrom sqlalchemy.sql.type_api import TypeDecorator\n\n# Use the following as the value of server_default for primary keys of type GUID\nGUID_SERVER_DEFAULT_POSTGRESQL = sa.DefaultClause(sa.text(\"gen_random_uuid()\"))\nGUID_DEFAULT_SQLITE = uuid.uuid4\n\nif TYPE_CHECKING:\n    UUIDTypeDecorator = TypeDecorator[uuid.UUID]\nelse:\n    UUIDTypeDecorator = TypeDecorator\n\n\nclass GUID(UUIDTypeDecorator):\n    \"\"\"\n    Platform-independent GUID type.\n\n    Uses PostgreSQL's UUID type, otherwise uses CHAR(32), storing as stringified hex values.\n\n    Taken from SQLAlchemy docs: https://docs.sqlalchemy.org/en/13/core/custom_types.html#backend-agnostic-guid-type\n    \"\"\"\n\n    impl = CHAR\n    cache_ok = True\n\n    @no_type_check\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    @no_type_check\n    def load_dialect_impl(self, dialect):\n        if dialect.name == \"postgresql\":  # pragma: no cover\n            return dialect.type_descriptor(UUID())\n        else:\n            return dialect.type_descriptor(CHAR(32))\n\n    @no_type_check\n    def process_bind_param(self, value, dialect):\n        if value is None:\n            return value\n        elif dialect.name == \"postgresql\":  # pragma: no cover\n            return str(value)\n        else:\n            if not isinstance(value, uuid.UUID):\n                return \"%.32x\" % uuid.UUID(value).int\n            else:\n                # hexstring\n                return \"%.32x\" % value.int\n\n    @no_type_check\n    def process_result_value(self, value, dialect):\n        if value is None:\n            return value\n        else:\n            if not isinstance(value, uuid.UUID):  # pragma: no branch\n                value = uuid.UUID(value)\n            return value\n\n\ndef setup_guids_postgresql(engine: sa.engine.Engine) -> None:  # pragma: no cover\n    \"\"\"\n    Set up UUID generation using the pgcrypto extension for postgres\n\n    This query only needs to be executed once when the database is created\n    \"\"\"\n    engine.execute('create EXTENSION if not EXISTS \"pgcrypto\"')\n"}
{"type": "source_file", "path": "fastapi_utils/__init__.py", "content": "import importlib.metadata\r\nimport warnings\r\n\r\nfrom .cbv_base import Api, Resource, set_responses, take_init_parameters\r\n\r\ntry:\r\n    __version__ = \"0.8.0\"\r\nexcept importlib.metadata.PackageNotFoundError as e:\r\n    warnings.warn(f\"Could not determine version of {__name__}\", stacklevel=1)\r\n    warnings.warn(str(e), stacklevel=1)\r\n    __version__ = \"0.8.0\"\r\n\r\n\r\n__all__ = [\r\n    \"Api\",\r\n    \"Resource\",\r\n    \"set_responses\",\r\n    \"take_init_parameters\",\r\n]\r\n"}
{"type": "source_file", "path": "fastapi_utils/session.py", "content": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom contextlib import contextmanager\n\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import Session\n\n\nclass FastAPISessionMaker:\n    \"\"\"\n    A convenience class for managing a (cached) sqlalchemy ORM engine and sessionmaker.\n\n    Intended for use creating ORM sessions injected into endpoint functions by FastAPI.\n    \"\"\"\n\n    def __init__(self, database_uri: str):\n        \"\"\"\n        `database_uri` should be any sqlalchemy-compatible database URI.\n\n        In particular, `sqlalchemy.create_engine(database_uri)` should work to create an engine.\n\n        Typically, this would look like:\n\n            \"<scheme>://<user>:<password>@<host>:<port>/<database>\"\n\n        A concrete example looks like \"postgresql://db_user:password@db:5432/app\"\n        \"\"\"\n        self.database_uri = database_uri\n\n        self._cached_engine: sa.engine.Engine | None = None\n        self._cached_sessionmaker: sa.orm.sessionmaker | None = None\n\n    @property\n    def cached_engine(self) -> sa.engine.Engine:\n        \"\"\"\n        Returns a lazily-cached sqlalchemy engine for the instance's database_uri.\n        \"\"\"\n        engine = self._cached_engine\n        if engine is None:\n            engine = self.get_new_engine()\n            self._cached_engine = engine\n        return engine\n\n    @property\n    def cached_sessionmaker(self) -> sa.orm.sessionmaker:\n        \"\"\"\n        Returns a lazily-cached sqlalchemy sessionmaker using the instance's (lazily-cached) engine.\n        \"\"\"\n        sessionmaker = self._cached_sessionmaker\n        if sessionmaker is None:\n            sessionmaker = self.get_new_sessionmaker(self.cached_engine)\n            self._cached_sessionmaker = sessionmaker\n        return sessionmaker\n\n    def get_new_engine(self) -> sa.engine.Engine:\n        \"\"\"\n        Returns a new sqlalchemy engine using the instance's database_uri.\n        \"\"\"\n        return get_engine(self.database_uri)\n\n    def get_new_sessionmaker(self, engine: sa.engine.Engine | None) -> sa.orm.sessionmaker:\n        \"\"\"\n        Returns a new sessionmaker for the provided sqlalchemy engine. If no engine is provided, the\n        instance's (lazily-cached) engine is used.\n        \"\"\"\n        engine = engine or self.cached_engine\n        return get_sessionmaker_for_engine(engine)\n\n    def get_db(self) -> Iterator[Session]:\n        \"\"\"\n        A generator function that yields a sqlalchemy orm session and cleans up the session once resumed after yielding.\n\n        Can be used directly as a context-manager FastAPI dependency, or yielded from inside a separate dependency.\n        \"\"\"\n        yield from _get_db(self.cached_sessionmaker)\n\n    @contextmanager\n    def context_session(self) -> Iterator[Session]:\n        \"\"\"\n        A context-manager wrapped version of the `get_db` method.\n\n        This makes it possible to get a context-managed orm session for the relevant database_uri without\n        needing to rely on FastAPI's dependency injection.\n\n        Usage looks like:\n\n            session_maker = FastAPISessionMaker(database_uri)\n            with session_maker.context_session() as session:\n                session.query(...)\n                ...\n        \"\"\"\n        yield from self.get_db()\n\n    def reset_cache(self) -> None:\n        \"\"\"\n        Resets the engine and sessionmaker caches.\n\n        After calling this method, the next time you try to use the cached engine or sessionmaker,\n        new ones will be created.\n        \"\"\"\n        self._cached_engine = None\n        self._cached_sessionmaker = None\n\n\ndef get_engine(uri: str) -> sa.engine.Engine:\n    \"\"\"\n    Returns a sqlalchemy engine with pool_pre_ping enabled.\n\n    This function may be updated over time to reflect recommended engine configuration for use with FastAPI.\n    \"\"\"\n    return sa.create_engine(uri, pool_pre_ping=True)\n\n\ndef get_sessionmaker_for_engine(engine: sa.engine.Engine) -> sa.orm.sessionmaker:\n    \"\"\"\n    Returns a sqlalchemy sessionmaker for the provided engine with recommended configuration settings.\n\n    This function may be updated over time to reflect recommended sessionmaker configuration for use with FastAPI.\n    \"\"\"\n    return sa.orm.sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\n@contextmanager\ndef context_session(engine: sa.engine.Engine) -> Iterator[Session]:\n    \"\"\"\n    This contextmanager yields a managed session for the provided engine.\n\n    Usage is similar to `FastAPISessionMaker.context_session`, except that you have to provide the engine to use.\n\n    A new sessionmaker is created for each call, so the FastAPISessionMaker.context_session\n    method may be preferable in performance-sensitive contexts.\n    \"\"\"\n    sessionmaker = get_sessionmaker_for_engine(engine)\n    yield from _get_db(sessionmaker)\n\n\ndef _get_db(sessionmaker: sa.orm.sessionmaker) -> Iterator[Session]:\n    \"\"\"\n    A generator function that yields an ORM session using the provided sessionmaker, and cleans it up when resumed.\n    \"\"\"\n    session = sessionmaker()\n    try:\n        yield session\n        session.commit()\n    except Exception as exc:\n        session.rollback()\n        raise exc\n    finally:\n        session.close()\n"}
{"type": "source_file", "path": "fastapi_utils/inferring_router.py", "content": "from __future__ import annotations\n\nimport warnings\n\nfrom fastapi import APIRouter\n\nwarnings.warn(\n    \"InferringRouter is deprecated, as its functionality is now provided in fastapi.APIRouter\", DeprecationWarning\n)\n\nInferringRouter = APIRouter\n"}
{"type": "source_file", "path": "docs/src/timing1.py", "content": "import asyncio\nimport logging\n\nfrom fastapi import FastAPI\nfrom starlette.requests import Request\nfrom starlette.staticfiles import StaticFiles\nfrom starlette.testclient import TestClient\n\nfrom fastapi_utils.timing import add_timing_middleware, record_timing\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI()\nadd_timing_middleware(app, record=logger.info, prefix=\"app\", exclude=\"untimed\")\nstatic_files_app = StaticFiles(directory=\".\")\napp.mount(path=\"/static\", app=static_files_app, name=\"static\")\n\n\n@app.get(\"/timed\")\nasync def get_timed() -> None:\n    await asyncio.sleep(0.05)\n\n\n@app.get(\"/untimed\")\nasync def get_untimed() -> None:\n    await asyncio.sleep(0.1)\n\n\n@app.get(\"/timed-intermediate\")\nasync def get_with_intermediate_timing(request: Request) -> None:\n    await asyncio.sleep(0.1)\n    record_timing(request, note=\"halfway\")\n    await asyncio.sleep(0.1)\n\n\nTestClient(app).get(\"/timed\")\n# INFO:__main__:TIMING: Wall:   53.0ms\n#   | CPU:    1.2ms\n#   | app.__main__.get_timed\n\nTestClient(app).get(\"/untimed\")\n# <nothing logged>\n\nTestClient(app).get(\"/timed-intermediate\")\n# INFO:__main__:TIMING: Wall:  105.3ms\n#   | CPU:    0.4ms\n#   | app.__main__.get_with_intermediate_timing (halfway)\n# INFO:__main__:TIMING: Wall:  206.7ms\n#   | CPU:    1.1ms\n#   | app.__main__.get_with_intermediate_timing\n\nTestClient(app).get(\"/static/test\")\n# INFO:__main__:TIMING: Wall:    1.6ms\n#   | CPU:    1.6ms\n#   | StaticFiles<'static'>\n"}
{"type": "source_file", "path": "docs/src/session1.py", "content": "from functools import lru_cache\nfrom typing import Iterator\nfrom uuid import UUID\n\nimport sqlalchemy as sa\nfrom fastapi import Depends, FastAPI\nfrom pydantic import BaseSettings\nfrom sqlalchemy.orm import Session, declarative_base\n\nfrom fastapi_utils.guid_type import GUID, GUID_DEFAULT_SQLITE\nfrom fastapi_utils.session import FastAPISessionMaker\n\nBase = declarative_base()\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = sa.Column(GUID, primary_key=True, default=GUID_DEFAULT_SQLITE)\n    name = sa.Column(sa.String, nullable=False)\n\n\nclass DBSettings(BaseSettings):\n    \"\"\"Parses variables from environment on instantiation\"\"\"\n\n    database_uri: str  # could break up into scheme, username, password, host, db\n\n\ndef get_db() -> Iterator[Session]:\n    \"\"\"FastAPI dependency that provides a sqlalchemy session\"\"\"\n    yield from _get_fastapi_sessionmaker().get_db()\n\n\n@lru_cache()\ndef _get_fastapi_sessionmaker() -> FastAPISessionMaker:\n    \"\"\"This function could be replaced with a global variable if preferred\"\"\"\n    database_uri = DBSettings().database_uri\n    return FastAPISessionMaker(database_uri)\n\n\napp = FastAPI()\n\n\n@app.get(\"/{user_id}\")\ndef get_user_name(db: Session = Depends(get_db), *, user_id: UUID) -> str:\n    user = db.get(User, user_id)\n    username = user.name\n    return username\n"}
{"type": "source_file", "path": "fastapi_utils/camelcase.py", "content": "from __future__ import annotations\n\nimport re\n\n\ndef snake2camel(snake: str, start_lower: bool = False) -> str:\n    \"\"\"\n    Converts a snake_case string to camelCase.\n\n    The `start_lower` argument determines whether the first letter in the generated camelcase should\n    be lowercase (if `start_lower` is True), or capitalized (if `start_lower` is False).\n    \"\"\"\n    camel = snake.title()\n    camel = re.sub(\"([0-9A-Za-z])_(?=[0-9A-Z])\", lambda m: m.group(1), camel)\n    if start_lower:\n        camel = re.sub(\"(^_*[A-Z])\", lambda m: m.group(1).lower(), camel)\n    return camel\n\n\ndef camel2snake(camel: str) -> str:\n    \"\"\"\n    Converts a camelCase string to snake_case.\n    \"\"\"\n    snake = re.sub(r\"([a-zA-Z])([0-9])\", lambda m: f\"{m.group(1)}_{m.group(2)}\", camel)\n    snake = re.sub(r\"([a-z0-9])([A-Z])\", lambda m: f\"{m.group(1)}_{m.group(2)}\", snake)\n    return snake.lower()\n"}
{"type": "source_file", "path": "fastapi_utils/enums.py", "content": "from __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List\n\nfrom .camelcase import snake2camel\n\n\nclass StrEnum(str, Enum):\n    \"\"\"\n    StrEnum subclasses that create variants using `auto()` will have values equal to their names\n    Enums inheriting from this class that set values using `enum.auto()` will have variant values equal to their names\n    \"\"\"\n\n    @staticmethod\n    def _generate_next_value_(name: str, start: int, count: int, last_values: List[str]) -> str:\n        \"\"\"\n        Uses the name as the automatic value, rather than an integer\n\n        See https://docs.python.org/3/library/enum.html#using-automatic-values for reference\n        \"\"\"\n        return name\n\n\nclass CamelStrEnum(str, Enum):\n    \"\"\"\n    CamelStrEnum subclasses that create variants using `auto()` will have values equal to their camelCase names\n    \"\"\"\n\n    @staticmethod\n    def _generate_next_value_(name: str, start: int, count: int, last_values: List[str]) -> str:\n        \"\"\"\n        Uses the camelCase name as the automatic value, rather than an integer\n\n        See https://docs.python.org/3/library/enum.html#using-automatic-values for reference\n        \"\"\"\n        return snake2camel(name, start_lower=True)\n"}
{"type": "source_file", "path": "fastapi_utils/api_settings.py", "content": "from __future__ import annotations\n\nfrom functools import lru_cache\nfrom typing import Any\n\nimport pydantic\n\nPYDANTIC_VERSION = pydantic.VERSION\n\nif PYDANTIC_VERSION[0] == \"2\":\n    from pydantic_settings import BaseSettings, SettingsConfigDict\nelse:\n    from pydantic import BaseSettings  # type: ignore[no-redef]\n\n\nclass APISettings(BaseSettings):\n    \"\"\"\n    This class enables the configuration of your FastAPI instance through the use of environment variables.\n\n    Any of the instance attributes can be overridden upon instantiation by either passing the desired value to the\n    initializer, or by setting the corresponding environment variable.\n\n    Attribute `xxx_yyy` corresponds to environment variable `API_XXX_YYY`. So, for example, to override\n    `openapi_prefix`, you would set the environment variable `API_OPENAPI_PREFIX`.\n\n    Note that assignments to variables are also validated, ensuring that even if you make runtime-modifications\n    to the config, they should have the correct types.\n    \"\"\"\n\n    # fastapi.applications.FastAPI initializer kwargs\n    debug: bool = False\n    docs_url: str = \"/docs\"\n    openapi_prefix: str = \"\"\n    openapi_url: str = \"/openapi.json\"\n    redoc_url: str = \"/redoc\"\n    title: str = \"FastAPI\"\n    version: str = \"0.1.0\"\n\n    # Custom settings\n    disable_docs: bool = False\n\n    @property\n    def fastapi_kwargs(self) -> dict[str, Any]:\n        \"\"\"\n        This returns a dictionary of the most commonly used keyword arguments when initializing a FastAPI instance\n\n        If `self.disable_docs` is True, the various docs-related arguments are disabled, preventing your spec from being\n        published.\n        \"\"\"\n        fastapi_kwargs: dict[str, Any] = {\n            \"debug\": self.debug,\n            \"docs_url\": self.docs_url,\n            \"openapi_prefix\": self.openapi_prefix,\n            \"openapi_url\": self.openapi_url,\n            \"redoc_url\": self.redoc_url,\n            \"title\": self.title,\n            \"version\": self.version,\n        }\n        if self.disable_docs:\n            fastapi_kwargs.update({\"docs_url\": None, \"openapi_url\": None, \"redoc_url\": None})\n        return fastapi_kwargs\n\n    if PYDANTIC_VERSION[0] == \"2\":\n        model_config = SettingsConfigDict(env_prefix=\"api_\", validate_assignment=True)\n    else:\n\n        class Config:\n            env_prefix = \"api_\"\n            validate_assignment = True\n\n\n@lru_cache()\ndef get_api_settings() -> APISettings:\n    \"\"\"\n    This function returns a cached instance of the APISettings object.\n\n    Caching is used to prevent re-reading the environment every time the API settings are used in an endpoint.\n\n    If you want to change an environment variable and reset the cache (e.g., during testing), this can be done\n    using the `lru_cache` instance method `get_api_settings.cache_clear()`.\n    \"\"\"\n    return APISettings()\n"}
{"type": "source_file", "path": "fastapi_utils/api_model.py", "content": "from __future__ import annotations\n\nfrom functools import partial\n\nimport pydantic\nfrom pydantic import BaseModel\n\nfrom .camelcase import snake2camel\n\nPYDANTIC_VERSION = pydantic.VERSION\n\nif PYDANTIC_VERSION[0] == \"2\":\n    from pydantic import ConfigDict\nelse:\n    from pydantic import BaseConfig\n\n\nclass APIModel(BaseModel):\n    \"\"\"\n    Intended for use as a base class for externally-facing models.\n\n    Any models that inherit from this class will:\n    * accept fields using snake_case or camelCase keys\n    * use camelCase keys in the generated OpenAPI spec\n    * have orm_mode on by default\n        * Because of this, FastAPI will automatically attempt to parse returned orm instances into the model\n    \"\"\"\n\n    if PYDANTIC_VERSION[0] == \"2\":\n        model_config = ConfigDict(\n            from_attributes=True, populate_by_name=True, alias_generator=partial(snake2camel, start_lower=True)\n        )\n    else:\n\n        class Config(BaseConfig):\n            orm_mode = True\n            allow_population_by_field_name = True\n            alias_generator = partial(snake2camel, start_lower=True)\n\n\nclass APIMessage(APIModel):\n    \"\"\"\n    A lightweight utility class intended for use with simple message-returning endpoints.\n    \"\"\"\n\n    detail: str\n"}
{"type": "source_file", "path": "fastapi_utils/cbv_base.py", "content": "from typing import Any, Dict, Optional, Tuple\n\nfrom fastapi import APIRouter, FastAPI\n\nfrom .cbv import INCLUDE_INIT_PARAMS_KEY, RETURN_TYPES_FUNC_KEY, _cbv\n\n\nclass Resource:\n    # raise NotImplementedError\n    pass\n\n\nclass Api:\n    def __init__(self, app: FastAPI):\n        self.app = app\n\n    def add_resource(self, resource: Resource, *urls: str, **kwargs: Any) -> None:\n        router = APIRouter()\n        _cbv(router, type(resource), *urls, instance=resource)\n        self.app.include_router(router, **kwargs)\n\n\ndef take_init_parameters(cls: Any) -> Any:\n    setattr(cls, INCLUDE_INIT_PARAMS_KEY, True)\n    return cls\n\n\ndef set_responses(\n    response: Any, status_code: int = 200, responses: Optional[Dict[str, Any]] = None, **kwargs: Any\n) -> Any:\n    def decorator(func: Any) -> Any:\n        def get_responses() -> Tuple[Any, int, Optional[Dict[str, Any]], Optional[Any]]:\n            return response, status_code, responses, kwargs\n\n        setattr(func, RETURN_TYPES_FUNC_KEY, get_responses)\n        return func\n\n    return decorator\n"}
{"type": "source_file", "path": "fastapi_utils/timing.py", "content": "\"\"\"\nBased on https://github.com/steinnes/timing-asgi.git\n\nThe middleware from this module is intended for use during both development and production,\nbut only reports timing data at the granularity of individual endpoint calls.\n\nFor more detailed performance investigations (during development only, due to added overhead),\nconsider using the coroutine-aware profiling library `yappi`.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport time\nfrom collections.abc import Callable\nfrom typing import Any\n\nimport psutil\nfrom fastapi import FastAPI\nfrom starlette.middleware.base import RequestResponseEndpoint\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.routing import Match, Mount\nfrom starlette.types import Scope\n\nTIMER_ATTRIBUTE = \"__fastapi_utils_timer__\"\n\n\ndef add_timing_middleware(\n    app: FastAPI, record: Callable[[str], None] | None = None, prefix: str = \"\", exclude: str | None = None\n) -> None:\n    \"\"\"\n    Adds a middleware to the provided `app` that records timing metrics using the provided `record` callable.\n\n    Typically `record` would be something like `logger.info` for a `logging.Logger` instance.\n\n    The provided `prefix` is used when generating route names.\n\n    If `exclude` is provided, timings for any routes containing `exclude`\n    as an exact substring of the generated metric name will not be logged.\n    This provides an easy way to disable logging for routes\n\n    The `exclude` will probably be replaced by a regex match at some point in the future. (PR welcome!)\n    \"\"\"\n    metric_namer = _MetricNamer(prefix=prefix, app=app)\n\n    @app.middleware(\"http\")\n    async def timing_middleware(request: Request, call_next: RequestResponseEndpoint) -> Response:\n        metric_name = metric_namer(request.scope)\n        with _TimingStats(metric_name, record=record, exclude=exclude) as timer:\n            setattr(request.state, TIMER_ATTRIBUTE, timer)\n            response = await call_next(request)\n        return response\n\n\ndef record_timing(request: Request, note: str | None = None) -> None:\n    \"\"\"\n    Call this function at any point that you want to display elapsed time during the handling of a single request\n\n    This can help profile which piece of a request is causing a performance bottleneck.\n\n    Note that for this function to succeed, the request should have been generated by a FastAPI app\n    that has had timing middleware added using the `fastapi_utils.timing.add_timing_middleware` function.\n    \"\"\"\n    timer = getattr(request.state, TIMER_ATTRIBUTE, None)\n    if timer is not None:\n        if not isinstance(timer, _TimingStats):\n            raise ValueError(\"Timer should be of an instance of TimingStats\")\n        timer.emit(note)\n    else:\n        raise ValueError(\"No timer present on request\")\n\n\nclass _TimingStats:\n    \"\"\"\n    This class tracks and records endpoint timing data.\n\n    Should be used as a context manager; on exit, timing stats will be emitted.\n\n    name:\n        The name to include with the recorded timing data\n    record:\n        The callable to call on generated messages. Defaults to `print`, but typically\n        something like `logger.info` for a `logging.Logger` instance would be preferable.\n    exclude:\n        An optional string; if it is not None and occurs inside `name`, no stats will be emitted\n    \"\"\"\n\n    def __init__(\n        self, name: str | None = None, record: Callable[[str], None] | None = None, exclude: str | None = None\n    ) -> None:\n        self.name = name\n        self.record = record or print\n\n        self.process: psutil.Process = psutil.Process(os.getpid())\n        self.start_time: float = 0\n        self.start_cpu_time: float = 0\n        self.end_cpu_time: float = 0\n        self.end_time: float = 0\n        self.silent: bool = False\n\n        if self.name is not None and exclude is not None and (exclude in self.name):\n            self.silent = True\n\n    def start(self) -> None:\n        self.start_time = time.time()\n        self.start_cpu_time = self._get_cpu_time()\n\n    def take_split(self) -> None:\n        self.end_time = time.time()\n        self.end_cpu_time = self._get_cpu_time()\n\n    @property\n    def time(self) -> float:\n        return self.end_time - self.start_time\n\n    @property\n    def cpu_time(self) -> float:\n        return self.end_cpu_time - self.start_cpu_time\n\n    def __enter__(self) -> _TimingStats:\n        self.start()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        self.emit()\n\n    def emit(self, note: str | None = None) -> None:\n        \"\"\"\n        Emit timing information, optionally including a specified note\n        \"\"\"\n        if not self.silent:\n            self.take_split()\n            cpu_ms = 1000 * self.cpu_time\n            wall_ms = 1000 * self.time\n            message = f\"TIMING: Wall: {wall_ms:6.1f}ms | CPU: {cpu_ms:6.1f}ms | {self.name}\"\n            if note is not None:\n                message += f\" ({note})\"\n            self.record(message)\n\n    def _get_cpu_time(self) -> float:\n        \"\"\"\n        Generates the cpu time to report. Adds the user and system time, following the implementation from timing-asgi\n        \"\"\"\n        resources = self.process.cpu_times()\n        # add up user time and system time\n        return resources[0] + resources[1]\n\n\nclass _MetricNamer:\n    \"\"\"\n    This class generates the route \"name\" used when logging timing records.\n\n    If the route has `endpoint` and `name` attributes, the endpoint's module and route's name will be used\n    (along with an optional prefix that can be used, e.g., to distinguish between multiple mounted ASGI apps).\n\n    By default, in FastAPI the route name is the `__name__` of the route's function (or type if it is a callable class\n    instance).\n\n    For example, with prefix == \"custom\", a function defined in the module `app.crud` with name `read_item`\n    would get name `custom.app.crud.read_item`. If the empty string were used as the prefix, the result would be\n    just \"app.crud.read_item\".\n\n    For starlette.routing.Mount instances, the name of the type of `route.app` is used in a slightly different format.\n\n    For other routes missing either an endpoint or name, the raw route path is included in the generated name.\n    \"\"\"\n\n    def __init__(self, prefix: str, app: FastAPI):\n        if prefix:\n            prefix += \".\"\n        self.prefix = prefix\n        self.app = app\n\n    def __call__(self, scope: Scope) -> str:\n        \"\"\"\n        Generates the actual name to use when logging timing metrics for a specified ASGI Scope\n        \"\"\"\n        route = None\n        for r in self.app.router.routes:\n            if r.matches(scope)[0] == Match.FULL:\n                route = r\n                break\n        if hasattr(route, \"endpoint\") and hasattr(route, \"name\"):\n            name = f\"{self.prefix}{route.endpoint.__module__}.{route.name}\"  # type: ignore\n        elif isinstance(route, Mount):\n            name = f\"{type(route.app).__name__}<{route.name!r}>\"\n        else:\n            name = str(f\"<Path: {scope['path']}>\")\n        return name\n"}
{"type": "source_file", "path": "fastapi_utils/tasks.py", "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport warnings\nfrom functools import wraps\nfrom traceback import format_exception\nfrom typing import Any, Callable, Coroutine, Union\n\nfrom starlette.concurrency import run_in_threadpool\n\nNoArgsNoReturnFuncT = Callable[[], None]\nNoArgsNoReturnAsyncFuncT = Callable[[], Coroutine[Any, Any, None]]\nExcArgNoReturnFuncT = Callable[[Exception], None]\nExcArgNoReturnAsyncFuncT = Callable[[Exception], Coroutine[Any, Any, None]]\nNoArgsNoReturnAnyFuncT = Union[NoArgsNoReturnFuncT, NoArgsNoReturnAsyncFuncT]\nExcArgNoReturnAnyFuncT = Union[ExcArgNoReturnFuncT, ExcArgNoReturnAsyncFuncT]\nNoArgsNoReturnDecorator = Callable[[NoArgsNoReturnAnyFuncT], NoArgsNoReturnAsyncFuncT]\n\n\nasync def _handle_func(func: NoArgsNoReturnAnyFuncT) -> None:\n    if asyncio.iscoroutinefunction(func):\n        await func()\n    else:\n        await run_in_threadpool(func)\n\n\nasync def _handle_exc(exc: Exception, on_exception: ExcArgNoReturnAnyFuncT | None) -> None:\n    if on_exception:\n        if asyncio.iscoroutinefunction(on_exception):\n            await on_exception(exc)\n        else:\n            await run_in_threadpool(on_exception, exc)\n\n\ndef repeat_every(\n    *,\n    seconds: float,\n    wait_first: float | None = None,\n    logger: logging.Logger | None = None,\n    raise_exceptions: bool = False,\n    max_repetitions: int | None = None,\n    on_complete: NoArgsNoReturnAnyFuncT | None = None,\n    on_exception: ExcArgNoReturnAnyFuncT | None = None,\n) -> NoArgsNoReturnDecorator:\n    \"\"\"\n    This function returns a decorator that modifies a function so it is periodically re-executed after its first call.\n\n    The function it decorates should accept no arguments and return nothing. If necessary, this can be accomplished\n    by using `functools.partial` or otherwise wrapping the target function prior to decoration.\n\n    Parameters\n    ----------\n    seconds: float\n        The number of seconds to wait between repeated calls\n    wait_first: float (default None)\n        If not None, the function will wait for the given duration before the first call\n    logger: Optional[logging.Logger] (default None)\n        Warning: This parameter is deprecated and will be removed in the 1.0 release.\n        The logger to use to log any exceptions raised by calls to the decorated function.\n        If not provided, exceptions will not be logged by this function (though they may be handled by the event loop).\n    raise_exceptions: bool (default False)\n        Warning: This parameter is deprecated and will be removed in the 1.0 release.\n        If True, errors raised by the decorated function will be raised to the event loop's exception handler.\n        Note that if an error is raised, the repeated execution will stop.\n        Otherwise, exceptions are just logged and the execution continues to repeat.\n        See https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.set_exception_handler for more info.\n    max_repetitions: Optional[int] (default None)\n        The maximum number of times to call the repeated function. If `None`, the function is repeated forever.\n    on_complete: Optional[Callable[[], None]] (default None)\n        A function to call after the final repetition of the decorated function.\n    on_exception: Optional[Callable[[Exception], None]] (default None)\n        A function to call when an exception is raised by the decorated function.\n    \"\"\"\n\n    def decorator(func: NoArgsNoReturnAnyFuncT) -> NoArgsNoReturnAsyncFuncT:\n        \"\"\"\n        Converts the decorated function into a repeated, periodically-called version of itself.\n        \"\"\"\n\n        @wraps(func)\n        async def wrapped() -> None:\n            async def loop() -> None:\n                if wait_first is not None:\n                    await asyncio.sleep(wait_first)\n\n                repetitions = 0\n                while max_repetitions is None or repetitions < max_repetitions:\n                    try:\n                        await _handle_func(func)\n\n                    except Exception as exc:\n                        if logger is not None:\n                            warnings.warn(\n                                \"'logger' is to be deprecated in favor of 'on_exception' in the 1.0 release.\",\n                                DeprecationWarning,\n                            )\n                            formatted_exception = \"\".join(format_exception(type(exc), exc, exc.__traceback__))\n                            logger.error(formatted_exception)\n                        if raise_exceptions:\n                            warnings.warn(\n                                \"'raise_exceptions' is to be deprecated in favor of 'on_exception' in the 1.0 release.\",\n                                DeprecationWarning,\n                            )\n                            raise exc\n                        await _handle_exc(exc, on_exception)\n\n                    repetitions += 1\n                    await asyncio.sleep(seconds)\n\n                if on_complete:\n                    await _handle_func(on_complete)\n\n            asyncio.ensure_future(loop())\n\n        return wrapped\n\n    return decorator\n"}
{"type": "source_file", "path": "fastapi_utils/cbv.py", "content": "import inspect\r\nfrom typing import (\r\n    Any,\r\n    Callable,\r\n    List,\r\n    Tuple,\r\n    Type,\r\n    TypeVar,\r\n    Union,\r\n    cast,\r\n    get_type_hints,\r\n)\r\n\r\nimport pydantic\r\nfrom fastapi import APIRouter, Depends\r\nfrom fastapi.routing import APIRoute\r\nfrom starlette.routing import Route, WebSocketRoute\r\n\r\nPYDANTIC_VERSION = pydantic.VERSION\r\nif PYDANTIC_VERSION[0] == \"2\":\r\n    from typing_inspect import is_classvar\r\nelse:\r\n    from pydantic.typing import is_classvar  # type: ignore[no-redef]\r\n\r\nT = TypeVar(\"T\")\r\n\r\nCBV_CLASS_KEY = \"__cbv_class__\"\r\nINCLUDE_INIT_PARAMS_KEY = \"__include_init_params__\"\r\nRETURN_TYPES_FUNC_KEY = \"__return_types_func__\"\r\n\r\n\r\ndef cbv(router: APIRouter, *urls: str) -> Callable[[Type[T]], Type[T]]:\r\n    \"\"\"\r\n    This function returns a decorator that converts the decorated into a class-based view for the provided router.\r\n\r\n    Any methods of the decorated class that are decorated as endpoints using the router provided to this function\r\n    will become endpoints in the router. The first positional argument to the methods (typically `self`)\r\n    will be populated with an instance created using FastAPI's dependency-injection.\r\n\r\n    For more detail, review the documentation at\r\n    https://fastapi-restful.netlify.app/user-guide/class-based-views//#the-cbv-decorator\r\n    \"\"\"\r\n\r\n    def decorator(cls: Type[T]) -> Type[T]:\r\n        # Define cls as cbv class exclusively when using the decorator\r\n        return _cbv(router, cls, *urls)\r\n\r\n    return decorator\r\n\r\n\r\ndef _cbv(router: APIRouter, cls: Type[T], *urls: str, instance: Any = None) -> Type[T]:\r\n    \"\"\"\r\n    Replaces any methods of the provided class `cls` that are endpoints of routes in `router` with updated\r\n    function calls that will properly inject an instance of `cls`.\r\n    \"\"\"\r\n    _init_cbv(cls, instance)\r\n    _register_endpoints(router, cls, *urls)\r\n    return cls\r\n\r\n\r\ndef _init_cbv(cls: Type[Any], instance: Any = None) -> None:\r\n    \"\"\"\r\n    Idempotently modifies the provided `cls`, performing the following modifications:\r\n    * The `__init__` function is updated to set any class-annotated dependencies as instance attributes\r\n    * The `__signature__` attribute is updated to indicate to FastAPI what arguments should be passed to the initializer\r\n    \"\"\"\r\n    if getattr(cls, CBV_CLASS_KEY, False):  # pragma: no cover\r\n        return  # Already initialized\r\n    old_init: Callable[..., Any] = cls.__init__\r\n    old_signature = inspect.signature(old_init)\r\n    old_parameters = list(old_signature.parameters.values())[1:]  # drop `self` parameter\r\n    new_parameters = [\r\n        x for x in old_parameters if x.kind not in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD)\r\n    ]\r\n\r\n    dependency_names: List[str] = []\r\n    for name, hint in get_type_hints(cls).items():\r\n        if is_classvar(hint):\r\n            continue\r\n        parameter_kwargs = {\"default\": getattr(cls, name, Ellipsis)}\r\n        dependency_names.append(name)\r\n        new_parameters.append(\r\n            inspect.Parameter(name=name, kind=inspect.Parameter.KEYWORD_ONLY, annotation=hint, **parameter_kwargs)\r\n        )\r\n    new_signature = inspect.Signature(())\r\n    if not instance or hasattr(cls, INCLUDE_INIT_PARAMS_KEY):\r\n        new_signature = old_signature.replace(parameters=new_parameters)\r\n\r\n    def new_init(self: Any, *args: Any, **kwargs: Any) -> None:\r\n        for dep_name in dependency_names:\r\n            dep_value = kwargs.pop(dep_name)\r\n            setattr(self, dep_name, dep_value)\r\n        if instance and not hasattr(cls, INCLUDE_INIT_PARAMS_KEY):\r\n            self.__class__ = instance.__class__\r\n            self.__dict__ = instance.__dict__\r\n        else:\r\n            old_init(self, *args, **kwargs)\r\n\r\n    setattr(cls, \"__signature__\", new_signature)\r\n    setattr(cls, \"__init__\", new_init)\r\n    setattr(cls, CBV_CLASS_KEY, True)\r\n\r\n\r\ndef _register_endpoints(router: APIRouter, cls: Type[Any], *urls: str) -> None:\r\n    cbv_router = APIRouter()\r\n    function_members = inspect.getmembers(cls, inspect.isfunction)\r\n    for url in urls:\r\n        _allocate_routes_by_method_name(router, url, function_members)\r\n    router_roles = []\r\n    for route in router.routes:\r\n        if not isinstance(route, APIRoute):\r\n            raise ValueError(\"The provided routes should be of type APIRoute\")\r\n\r\n        route_methods: Any = route.methods\r\n        cast(Tuple[Any], route_methods)\r\n        router_roles.append((route.path, tuple(route_methods)))\r\n\r\n    if len(set(router_roles)) != len(router_roles):\r\n        raise Exception(\"An identical route role has been implemented more then once\")\r\n\r\n    functions_set = {func for _, func in function_members}\r\n    cbv_routes = [\r\n        route\r\n        for route in router.routes\r\n        if isinstance(route, (Route, WebSocketRoute)) and route.endpoint in functions_set\r\n    ]\r\n    prefix_length = len(router.prefix)  # Until 'black' would fix an issue which causes PEP8: E203\r\n    for route in cbv_routes:\r\n        router.routes.remove(route)\r\n        route.path = route.path[prefix_length:]\r\n        _update_cbv_route_endpoint_signature(cls, route)\r\n        route.name = cls.__name__ + \".\" + route.name\r\n        cbv_router.routes.append(route)\r\n    router.include_router(cbv_router)\r\n\r\n\r\ndef _allocate_routes_by_method_name(router: APIRouter, url: str, function_members: List[Tuple[str, Any]]) -> None:\r\n    existing_routes_endpoints: List[Tuple[Any, str]] = [\r\n        (route.endpoint, route.path) for route in router.routes if isinstance(route, APIRoute)\r\n    ]\r\n    for name, func in function_members:\r\n        if hasattr(router, name) and not name.startswith(\"__\") and not name.endswith(\"__\"):\r\n            if (func, url) not in existing_routes_endpoints:\r\n                response_model = None\r\n                responses = None\r\n                kwargs = {}\r\n                status_code = 200\r\n                return_types_func = getattr(func, RETURN_TYPES_FUNC_KEY, None)\r\n                if return_types_func:\r\n                    response_model, status_code, responses, kwargs = return_types_func()\r\n\r\n                api_resource = router.api_route(\r\n                    url,\r\n                    methods=[name.capitalize()],\r\n                    response_model=response_model,\r\n                    status_code=status_code,\r\n                    responses=responses,\r\n                    **kwargs,\r\n                )\r\n                api_resource(func)\r\n\r\n\r\ndef _update_cbv_route_endpoint_signature(cls: Type[Any], route: Union[Route, WebSocketRoute]) -> None:\r\n    \"\"\"\r\n    Fixes the endpoint signature for a cbv route to ensure FastAPI performs dependency injection properly.\r\n    \"\"\"\r\n    old_endpoint = route.endpoint\r\n    old_signature = inspect.signature(old_endpoint)\r\n    old_parameters: List[inspect.Parameter] = list(old_signature.parameters.values())\r\n    old_first_parameter = old_parameters[0]\r\n    new_first_parameter = old_first_parameter.replace(default=Depends(cls))\r\n    new_parameters = [new_first_parameter] + [\r\n        parameter.replace(kind=inspect.Parameter.KEYWORD_ONLY) for parameter in old_parameters[1:]\r\n    ]\r\n\r\n    new_signature = old_signature.replace(parameters=new_parameters)\r\n    setattr(route.endpoint, \"__signature__\", new_signature)\r\n"}

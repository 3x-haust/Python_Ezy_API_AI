{"repo_info": {"repo_name": "willow-application-server", "repo_owner": "toverainc", "repo_url": "https://github.com/toverainc/willow-application-server"}}
{"type": "test_file", "path": "app/pytest/test_construct_wis_tts_url.py", "content": "from app.internal.was import construct_wis_tts_url\n\n\ndef test_construct_wis_tts_url():\n    expect = \"http://wis.local/api/tts?text=\"\n    assert expect == construct_wis_tts_url(\"http://wis.local/api/tts\")\n    assert expect ==  construct_wis_tts_url(\"http://wis.local/api/tts?text\")\n    assert expect == construct_wis_tts_url(\"http://wis.local/api/tts?text=\")\n\n    expect = \"http://wis.local/api/tts?bar=baz&text=\"\n    assert expect == construct_wis_tts_url(\"http://wis.local/api/tts?text&bar=baz\")\n    assert expect == construct_wis_tts_url(\"http://wis.local/api/tts?text=&bar=baz\")\n    assert expect == construct_wis_tts_url(\"http://wis.local/api/tts?text=foo&bar=baz\")\n\n    expect = \"http://wis.local:19000/api/tts?text=\"\n    assert expect == construct_wis_tts_url(\"http://wis.local:19000/api/tts\")\n    assert expect == construct_wis_tts_url(\"http://wis.local:19000/api/tts?text\")\n    assert expect == construct_wis_tts_url(\"http://wis.local:19000/api/tts?text=\")\n\n    expect = \"http://wis.local:19000/api/tts?bar=baz&text=\"\n    assert expect == construct_wis_tts_url(\"http://wis.local:19000/api/tts?text&bar=baz\")\n    assert expect == construct_wis_tts_url(\"http://wis.local:19000/api/tts?text=&bar=baz\")\n    assert expect == construct_wis_tts_url(\"http://wis.local:19000/api/tts?text=foo&bar=baz\")\n\n    expect = \"http://user:pass@wis.local/api/tts?text=\"\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local/api/tts\")\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local/api/tts?text\")\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local/api/tts?text=\")\n\n    expect = \"http://user:pass@wis.local/api/tts?bar=baz&text=\"\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local/api/tts?text&bar=baz\")\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local/api/tts?text=&bar=baz\")\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local/api/tts?text=foo&bar=baz\")\n\n    expect = \"http://user:pass@wis.local:19000/api/tts?text=\"\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local:19000/api/tts\")\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local:19000/api/tts?text\")\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local:19000/api/tts?text=\")\n\n    expect = \"http://user:pass@wis.local:19000/api/tts?bar=baz&text=\"\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local:19000/api/tts?text&bar=baz\")\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local:19000/api/tts?text=&bar=baz\")\n    assert expect == construct_wis_tts_url(\"http://user:pass@wis.local:19000/api/tts?text=foo&bar=baz\")\n"}
{"type": "test_file", "path": "app/pytest/test_get_release_url.py", "content": "from app.internal.was import get_release_url\n\n\ndef test_get_release_url():\n    expect = \"http://was.local/api/ota?version=local&platform=ESP32-S3-BOX-3\"\n    assert expect == get_release_url(\"ws://was.local/ws\", \"local\", \"ESP32-S3-BOX-3\")\n\n    expect = \"http://was.local:8502/api/ota?version=local&platform=ESP32-S3-BOX-3\"\n    assert expect == get_release_url(\"ws://was.local:8502/ws\", \"local\", \"ESP32-S3-BOX-3\")\n\n    expect = \"https://was.local/api/ota?version=local&platform=ESP32-S3-BOX-3\"\n    assert expect == get_release_url(\"wss://was.local/ws\", \"local\", \"ESP32-S3-BOX-3\")\n\n    expect = \"https://was.local:8503/api/ota?version=local&platform=ESP32-S3-BOX-3\"\n    assert expect == get_release_url(\"wss://was.local:8503/ws\", \"local\", \"ESP32-S3-BOX-3\")\n"}
{"type": "source_file", "path": "app/internal/command_endpoints/__init__.py", "content": "import logging\n\nfrom pydantic import BaseModel\n\nclass CommandEndpointConfigException(Exception):\n    \"\"\"Raised when an the command endpoint configuration is invalid\n\n    Attributes:\n        msg -- error message\n    \"\"\"\n\n    def __init__(self, msg=\"Command Endpoint configuration is invalid\"):\n        self.msg = msg\n        super().__init__(self.msg)\n\n\nclass CommandEndpointRuntimeException(Exception):\n    \"\"\"\"Raised when an exception occurs while contacting the command endpoint\n\n    Attributes:\n        msg -- error message\n    \"\"\"\n\n    def __init__(self, msg=\"Runtime exception occured in Command Endpoint\"):\n        self.msg = msg\n        super().__init__(self.msg)\n\n\nclass CommandEndpointResult(BaseModel):\n    ok: bool = False\n    speech: str = \"Error!\"\n\n    def sanitize(self):\n        self.speech = self.speech.replace(\"\\n\", \" \").replace(\"\\r\", \" \").lstrip()\n\n\nclass CommandEndpointResponse(BaseModel):\n    result: CommandEndpointResult = None\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.result.sanitize()\n\n\nclass CommandEndpoint():\n    name = \"WAS CommandEndpoint\"\n    log = logging.getLogger(\"WAS\")\n"}
{"type": "source_file", "path": "app/const.py", "content": "DIR_ASSET = '/app/storage/asset'\nDIR_OTA = '/app/storage/ota'\nURL_WILLOW_RELEASES = 'https://worker.heywillow.io/api/release?format=was'\nURL_WILLOW_CONFIG = 'https://worker.heywillow.io/api/config'\nURL_WILLOW_TZ = 'https://worker.heywillow.io/api/asset?type=tz'\n\nSTORAGE_USER_CLIENT_CONFIG = 'storage/user_client_config.json'\nSTORAGE_USER_CONFIG = 'storage/user_config.json'\nSTORAGE_USER_MULTINET = 'storage/user_multinet.json'\nSTORAGE_USER_NVS = 'storage/user_nvs.json'\nSTORAGE_USER_WAS = 'storage/user_was.json'\nSTORAGE_TZ = 'storage/tz.json'\n"}
{"type": "source_file", "path": "app/internal/client.py", "content": "from pydantic import BaseModel\n\n\nclass Client(BaseModel):\n    hostname: str = \"unknown\"\n    platform: str = \"unknown\"\n    mac_addr: str = \"unknown\"\n    notification_active: int = 0\n    ua: str = None\n\n    def set_hostname(self, hostname):\n        self.hostname = hostname\n\n    def set_platform(self, platform):\n        self.platform = platform\n\n    def set_mac_addr(self, mac_addr):\n        self.mac_addr = mac_addr\n\n    def is_notification_active(self):\n        return self.notification_active != 0\n\n    def set_notification_active(self, id):\n        self.notification_active = id\n"}
{"type": "source_file", "path": "app/internal/__init__.py", "content": ""}
{"type": "source_file", "path": "app/internal/command_endpoints/main.py", "content": "from logging import getLogger\n\nfrom app.internal.command_endpoints.ha_rest import HomeAssistantRestEndpoint\nfrom app.internal.command_endpoints.ha_ws import (\n    HomeAssistantWebSocketEndpoint,\n    HomeAssistantWebSocketEndpointNotSupportedException\n)\nfrom app.internal.command_endpoints.mqtt import MqttConfig, MqttEndpoint\nfrom app.internal.command_endpoints.openhab import OpenhabEndpoint\nfrom app.internal.command_endpoints.rest import RestEndpoint\nfrom app.internal.was import get_config\n\n\nlog = getLogger(\"WAS\")\n\n\ndef init_command_endpoint(app):\n    # call command_endpoint.stop() to avoid leaking asyncio task\n    try:\n        app.command_endpoint.stop()\n    except Exception:\n        pass\n\n    user_config = get_config()\n\n    if \"was_mode\" in user_config and user_config[\"was_mode\"]:\n        log.info(\"WAS Endpoint mode enabled\")\n\n        if user_config[\"command_endpoint\"] == \"Home Assistant\":\n\n            host = user_config[\"hass_host\"]\n            port = user_config[\"hass_port\"]\n            tls = user_config[\"hass_tls\"]\n            token = user_config[\"hass_token\"]\n\n            try:\n                app.command_endpoint = HomeAssistantWebSocketEndpoint(app, host, port, tls, token)\n            except HomeAssistantWebSocketEndpointNotSupportedException:\n                app.command_endpoint = HomeAssistantRestEndpoint(host, port, tls, token)\n\n        elif user_config[\"command_endpoint\"] == \"MQTT\":\n            mqtt_config = MqttConfig()\n            mqtt_config.set_auth_type(user_config[\"mqtt_auth_type\"])\n            mqtt_config.set_hostname(user_config[\"mqtt_host\"])\n            mqtt_config.set_port(user_config[\"mqtt_port\"])\n            mqtt_config.set_tls(user_config[\"mqtt_tls\"])\n            mqtt_config.set_topic(user_config[\"mqtt_topic\"])\n\n            if 'mqtt_password' in user_config:\n                mqtt_config.set_password(user_config['mqtt_password'])\n\n            if 'mqtt_username' in user_config:\n                mqtt_config.set_username(user_config['mqtt_username'])\n\n            app.command_endpoint = MqttEndpoint(mqtt_config)\n\n        elif user_config[\"command_endpoint\"] == \"openHAB\":\n            app.command_endpoint = OpenhabEndpoint(user_config[\"openhab_url\"], user_config[\"openhab_token\"])\n\n        elif user_config[\"command_endpoint\"] == \"REST\":\n            app.command_endpoint = RestEndpoint(user_config[\"rest_url\"])\n            app.command_endpoint.config.set_auth_type(user_config[\"rest_auth_type\"])\n\n            if \"rest_auth_header\" in user_config:\n                app.command_endpoint.config.set_auth_header(user_config[\"rest_auth_header\"])\n\n            if \"rest_auth_pass\" in user_config:\n                app.command_endpoint.config.set_auth_pass(user_config[\"rest_auth_pass\"])\n\n            if \"rest_auth_user\" in user_config:\n                app.command_endpoint.config.set_auth_user(user_config[\"rest_auth_user\"])\n"}
{"type": "source_file", "path": "app/internal/command_endpoints/mqtt.py", "content": "import asyncio\nimport json\nimport logging\nimport paho.mqtt.client as mqtt\nfrom . import (\n    CommandEndpoint,\n    CommandEndpointConfigException,\n    CommandEndpointResponse,\n    CommandEndpointResult,\n    CommandEndpointRuntimeException\n)\nfrom enum import Enum\n\n\nclass MqttAuthType(Enum):\n    NONE = 1\n    USERPW = 2\n\n\nclass MqttConfig:\n    auth_type: Enum = MqttAuthType.NONE\n    hostname: str = None\n    password: str = None\n    port: int = 8883\n    tls: bool = True\n    topic: str = None\n    username: str = None\n\n    log = logging.getLogger(\"WAS\")\n\n    def set_auth_type(self, auth_type=MqttAuthType.NONE):\n        self.log.debug(f\"setting auth type: {auth_type}\")\n        self.auth_type = MqttAuthType[auth_type.upper()]\n\n    def set_hostname(self, hostname=None):\n        self.hostname = hostname\n\n    def set_password(self, password=None):\n        self.password = password\n\n    def set_port(self, port=8883):\n        self.port = port\n\n    def set_tls(self, tls=True):\n        self.tls = tls\n\n    def set_topic(self, topic=None):\n        self.topic = topic\n\n    def set_username(self, username=None):\n        self.username = username\n\n    def validate(self):\n        if self.auth_type == MqttAuthType.USERPW:\n            if self.password is None:\n                raise CommandEndpointConfigException(\"User/Password auth enabled without password\")\n            if self.username is None:\n                raise CommandEndpointConfigException(\"User/Password auth enabled without password\")\n\n\nclass MqttEndpoint(CommandEndpoint):\n    name = \"MQTT\"\n\n    def __init__(self, config):\n        self.config = config\n        self.config.validate()\n        self.connected = False\n        self.mqtt_client = None\n\n        loop = asyncio.get_event_loop()\n        self.task = loop.create_task(self.connect())\n\n    async def connect(self):\n        try:\n            self.mqtt_client = mqtt.Client()\n            self.mqtt_client.on_connect = self.cb_connect\n            self.mqtt_client.on_disconnect = self.cb_disconnect\n            self.mqtt_client.on_msg = self.cb_msg\n            if self.config.username is not None and self.config.password is not None:\n                self.mqtt_client.username_pw_set(self.config.username, self.config.password)\n            if self.config.tls:\n                self.mqtt_client.tls_set()\n            self.mqtt_client.connect_async(self.config.hostname, self.config.port, 60)\n            self.mqtt_client.loop_start()\n        except Exception as e:\n            self.log.info(f\"{self.name}: exception occurred: {e}\")\n            await asyncio.sleep(1)\n\n    def cb_connect(self, client, userdata, flags, rc):\n        self.connected = True\n        self.log.info(\"MQTT connected\")\n        client.subscribe(self.config.topic)\n\n    def cb_disconnect(self, client, userdata, rc):\n        self.connected = False\n        self.log.info(\"MQTT disconnected\")\n\n    def cb_msg(self, client, userdata, msg):\n        self.log.info(f\"cb_msg: topic={msg.topic} payload={msg.payload}\")\n\n    def parse_response(self, response):\n        res = CommandEndpointResult()\n        if response.ok:\n            res.ok = True\n            if len(res.speech) > 0:\n                res.speech = response.text\n            else:\n                res.speech = \"Success!\"\n\n        command_endpoint_response = CommandEndpointResponse(result=res)\n        return command_endpoint_response.model_dump_json()\n\n    def send(self, data=None, jsondata=None, ws=None):\n        if not self.connected:\n            raise CommandEndpointRuntimeException(f\"{self.name} not connected\")\n        try:\n            if jsondata is not None:\n                self.mqtt_client.publish(self.config.topic, payload=json.dumps(jsondata))\n            else:\n                self.mqtt_client.publish(self.config.topic, payload=data)\n        except Exception as e:\n            raise CommandEndpointRuntimeException(e)\n"}
{"type": "source_file", "path": "app/internal/connmgr.py", "content": "import logging\n\nfrom fastapi import (\n    WebSocket,\n    WebSocketException,\n)\nfrom pydantic import BaseModel, ConfigDict, FieldSerializationInfo, SerializerFunctionWrapHandler, field_serializer\nfrom typing import Dict\n\nfrom .client import Client\n\n\nlog = logging.getLogger(\"WAS\")\n\n\nclass ConnMgr(BaseModel):\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    connected_clients: Dict[WebSocket, Client] = {}\n\n    @field_serializer('connected_clients', mode='wrap')\n    def serialize_connected_clients(self, value: Dict[WebSocket, Client], nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo) -> Dict[str, Client]:\n        serialized_dict = {}\n        for ws, client in value.items():\n            remote = f\"{ws.client.host}:{ws.client.port}\"\n            serialized_dict[remote] = client\n        return nxt(serialized_dict)\n\n    async def accept(self, ws: WebSocket, client: Client):\n        try:\n            await ws.accept()\n            self.connected_clients[ws] = client\n        except WebSocketException as e:\n            log.error(f\"Failed to accept websocket connection: {e}\")\n\n    async def broadcast(self, msg: str):\n        for client in self.connected_clients:\n            try:\n                await client.send_text(msg)\n            except Exception as e:\n                log.error(f\"Failed to broadcast message: {e}\")\n\n    def disconnect(self, ws: WebSocket):\n        if ws in self.connected_clients:\n            self.connected_clients.pop(ws)\n\n    def get_client_by_hostname(self, hostname):\n        for k, v in self.connected_clients.items():\n            if v.hostname == hostname:\n                return k\n\n    def get_client_by_ws(self, ws):\n        return self.connected_clients[ws]\n\n    def get_mac_by_hostname(self, hostname):\n        for k, v in self.connected_clients.items():\n            if v.hostname == hostname:\n                return v.mac_addr\n\n        return None\n\n    def get_ws_by_mac(self, mac):\n        for k, v in self.connected_clients.items():\n            # log.debug(f\"get_ws_by_mac: {k} {v.mac_addr}\")\n            if v.mac_addr == mac:\n                return k\n\n        log.debug(\"get_ws_by_mac: returning None\")\n        return None\n\n    def is_notification_active(self, ws):\n        return self.connected_clients[ws].is_notification_active()\n\n    def set_notification_active(self, ws, id):\n        self.connected_clients[ws].set_notification_active(id)\n\n    def update_client(self, ws, key, value):\n        if key == \"hostname\":\n            self.connected_clients[ws].set_hostname(value)\n        elif key == \"platform\":\n            self.connected_clients[ws].set_platform(value)\n        elif key == \"mac_addr\":\n            self.connected_clients[ws].set_mac_addr(value)\n"}
{"type": "source_file", "path": "app/internal/command_endpoints/ha_rest.py", "content": "import json\nfrom . import CommandEndpointResponse, CommandEndpointResult\nfrom .rest import RestAuthType, RestConfig, RestEndpoint\n\n\nclass HomeAssistantRestEndpoint(RestEndpoint):\n    name = \"WAS Home Assistant REST Endpoint\"\n\n    def __init__(self, host, port, tls, token):\n        self.host = host\n        self.port = port\n        self.token = token\n        self.tls = tls\n        self.url = self.construct_url(ws=False)\n        self.config = RestConfig(auth_type=RestAuthType.HEADER, auth_header=f\"Bearer {token}\")\n\n    def construct_url(self, ws):\n        ha_url_scheme = \"\"\n        if ws:\n            ha_url_scheme = \"wss://\" if self.tls else \"ws://\"\n        else:\n            ha_url_scheme = \"https://\" if self.tls else \"http://\"\n\n        return f\"{ha_url_scheme}{self.host}:{self.port}/api/conversation/process\"\n\n    def get_speech(self, data):\n        speech = data[\"response\"][\"speech\"][\"plain\"][\"speech\"]\n        return speech\n\n    def parse_response(self, response):\n        res = CommandEndpointResult()\n        if response.ok:\n            res.ok = True\n            res.speech = self.get_speech(response.json())\n\n        command_endpoint_response = CommandEndpointResponse(result=res)\n        return command_endpoint_response.model_dump_json()\n\n    def send(self, data=None, jsondata=None, ws=None):\n        out = {'text': jsondata[\"text\"], 'language': jsondata[\"language\"]}\n        return super().send(jsondata=out)\n"}
{"type": "source_file", "path": "app/internal/command_endpoints/ha_ws.py", "content": "import asyncio\nimport json\nimport requests\nimport time\nimport websockets\nfrom . import (\n    CommandEndpoint,\n    CommandEndpointResponse,\n    CommandEndpointResult,\n    CommandEndpointRuntimeException,\n)\n\n\nclass HomeAssistantWebSocketEndpointNotSupportedException(CommandEndpointRuntimeException):\n    pass\n\n\nclass HomeAssistantWebSocketEndpoint(CommandEndpoint):\n    name = \"WAS Home Assistant WebSocket Endpoint\"\n\n    connmap = {}\n\n    def __init__(self, app, host, port, tls, token):\n        self.app = app\n        self.host = host\n        self.port = port\n        self.token = token\n        self.tls = tls\n        self.url = self.construct_url(ws=True)\n\n        self.haws = None\n\n        if not self.is_supported():\n            raise HomeAssistantWebSocketEndpointNotSupportedException\n\n        loop = asyncio.get_event_loop()\n        self.task = loop.create_task(self.connect())\n\n    def is_supported(self):\n        headers = {}\n        headers['Content-Type'] = 'application/json'\n        headers['Authorization'] = f\"Bearer {self.token}\"\n        ha_components_url = f\"{self.construct_url(False)}/api/components\"\n        response = requests.get(ha_components_url, headers=headers)\n\n        if \"assist_pipeline\" in response.json():\n            return True\n\n        return False\n\n    def construct_url(self, ws):\n        ha_url_scheme = \"\"\n        if ws:\n            ha_url_scheme = \"wss://\" if self.tls else \"ws://\"\n        else:\n            ha_url_scheme = \"https://\" if self.tls else \"http://\"\n\n        return f\"{ha_url_scheme}{self.host}:{self.port}\"\n\n    async def connect(self):\n        while True:\n            try:\n                # deflate compression is enabled by default, making tcpdump difficult\n                async with websockets.connect(f\"{self.url}/api/websocket\", compression=None) as self.haws:\n                    while True:\n                        msg = await self.haws.recv()\n                        await self.cb_msg(msg)\n            except Exception as e:\n                self.log.info(f\"{self.name}: exception occurred: {e}\")\n                await asyncio.sleep(1)\n\n    async def cb_msg(self, msg):\n        self.log.debug(f\"haws_cb: {self.app} {msg}\")\n        msg = json.loads(msg)\n        if \"type\" in msg:\n            if msg[\"type\"] == \"event\":\n                if msg[\"event\"][\"type\"] == \"intent-end\":\n                    id = int(msg[\"id\"])\n                    ws = self.connmap[id]\n                    out = CommandEndpointResult()\n                    response_type = msg[\"event\"][\"data\"][\"intent_output\"][\"response\"][\"response_type\"]\n                    if response_type == \"action_done\":\n                        out.ok = True\n                    out.speech = msg[\"event\"][\"data\"][\"intent_output\"][\"response\"][\"speech\"][\"plain\"][\"speech\"]\n                    command_endpoint_response = CommandEndpointResponse(result=out)\n                    self.log.debug(f\"sending {command_endpoint_response} to {ws}\")\n                    asyncio.ensure_future(ws.send_text(command_endpoint_response.model_dump_json()))\n                    self.connmap.pop(id)\n            elif msg[\"type\"] == \"auth_required\":\n                auth_msg = {\n                    \"type\": \"auth\",\n                    \"access_token\": self.token,\n                }\n                self.log.debug(f\"authenticating HA WebSocket connection: {auth_msg}\")\n                await self.haws.send(json.dumps(auth_msg))\n\n    def parse_response(self, response):\n        return None\n\n    def send(self, jsondata, ws):\n        id = int(time.time() * 1000)\n\n        if id not in self.connmap:\n            self.connmap[id] = ws\n\n        if \"language\" in jsondata:\n            jsondata.pop(\"language\")\n\n        out = {\n            'end_stage': 'intent',\n            'id': id,\n            'input': jsondata,\n            'start_stage': 'intent',\n            'type': 'assist_pipeline/run',\n        }\n\n        self.log.debug(f\"sending to HA WS: {out}\")\n        asyncio.ensure_future(self.haws.send(json.dumps(out)))\n\n    def stop(self):\n        self.log.info(f\"stopping {self.name}\")\n        self.task.cancel()\n"}
{"type": "source_file", "path": "app/internal/command_endpoints/rest.py", "content": "import json\nimport logging\nfrom . import (\n    CommandEndpoint,\n    CommandEndpointConfigException,\n    CommandEndpointResponse,\n    CommandEndpointResult,\n    CommandEndpointRuntimeException\n)\nfrom enum import Enum\nfrom requests import request\nfrom requests.auth import HTTPBasicAuth\n\n\nclass RestAuthType(Enum):\n    NONE = 1\n    BASIC = 2\n    HEADER = 3\n\n\nclass RestConfig():\n    auth_header: str = \"\"\n    auth_pass: str = \"\"\n    auth_type: Enum = RestAuthType.NONE\n    auth_user: str = \"\"\n\n    log = logging.getLogger(\"WAS\")\n\n    def __init__(self, auth_type=RestAuthType.NONE, auth_header=\"\", auth_pass=\"\", auth_user=\"\"):\n        self.auth_header = auth_header\n        self.auth_pass = auth_pass\n        self.auth_type = auth_type\n        self.auth_user = auth_user\n\n    def set_auth_header(self, auth_header=\"\"):\n        self.log.debug(f\"setting auth header: {auth_header}\")\n        self.auth_header = auth_header\n\n    def set_auth_pass(self, auth_pass=\"\"):\n        self.log.debug(f\"setting auth password: {auth_pass}\")\n        self.auth_pass = auth_pass\n\n    def set_auth_type(self, auth_type=RestAuthType.NONE):\n        self.log.debug(f\"setting auth type: {auth_type}\")\n        self.auth_type = RestAuthType[auth_type.upper()]\n\n    def set_auth_user(self, auth_user=\"\"):\n        self.log.debug(f\"setting auth username: {auth_user}\")\n        self.auth_user = auth_user\n\n\nclass RestEndpoint(CommandEndpoint):\n    name = \"REST\"\n\n    def __init__(self, url):\n        self.config = RestConfig()\n        self.url = url\n\n    def parse_response(self, response):\n        res = CommandEndpointResult()\n        if response.ok:\n            res.ok = True\n            if len(res.speech) > 0:\n                res.speech = response.text\n            else:\n                res.speech = \"Success!\"\n\n        command_endpoint_response = CommandEndpointResponse(result=res)\n        return command_endpoint_response.model_dump_json()\n\n    def send(self, data=None, jsondata=None, ws=None):\n        try:\n            basic = None\n            headers = {}\n\n            if jsondata is not None:\n                headers['Content-Type'] = 'application/json'\n            else:\n                headers['Content-Type'] = 'text/plain'\n\n            if self.config.auth_type == RestAuthType.BASIC:\n                basic = HTTPBasicAuth(self.config.auth_user, self.config.auth_pass)\n            elif self.config.auth_type == RestAuthType.HEADER:\n                headers['Authorization'] = self.config.auth_header\n            elif self.config.auth_type == RestAuthType.NONE:\n                pass\n            else:\n                raise CommandEndpointConfigException(\"invalid REST auth type\")\n\n            return request(\"POST\", self.url, auth=basic, data=data, headers=headers, json=jsondata, timeout=(1, 30))\n\n        except Exception as e:\n            raise CommandEndpointRuntimeException(e)\n"}
{"type": "source_file", "path": "app/internal/command_endpoints/openhab.py", "content": "from .rest import RestAuthType, RestConfig, RestEndpoint\n\n\nclass OpenhabEndpoint(RestEndpoint):\n    name = \"WAS openHAB Endpoint\"\n\n    def __init__(self, url, token):\n        self.config = RestConfig(auth_type=RestAuthType.BASIC, auth_user=token)\n        self.url = f\"{url}/rest/voice/interpreters\"\n\n    def send(self, jsondata=None, ws=None):\n        return super().send(data=jsondata[\"text\"])\n"}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/routers/asset.py", "content": "import os\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom fastapi.responses import FileResponse\nfrom logging import getLogger\nfrom typing import Literal\nfrom pydantic import BaseModel, Field\n\nfrom ..const import DIR_ASSET\nfrom ..internal.was import get_mime_type, is_safe_path\n\n\nlog = getLogger(\"WAS\")\nrouter = APIRouter(\n    prefix=\"/api\",\n)\n\n\nclass GetAsset(BaseModel):\n    asset: str = Field(Query(..., description=\"Asset\"))\n    type: Literal[\"audio\", \"image\", \"other\"] = Field(\n        Query(..., description=\"Asset type\")\n    )\n\n\n@router.get(\"/asset\")\nasync def api_get_asset(asset: GetAsset = Depends()):\n    log.debug(\"API GET ASSET: Request\")\n    asset_file = f\"{DIR_ASSET}/{asset.type}/{asset.asset}\"\n    log.debug(f\"asset file: {asset_file}\")\n    if not is_safe_path(DIR_ASSET, asset_file):\n        return\n\n    # If we don't have the asset file return 404\n    if not os.path.isfile(asset_file):\n        raise HTTPException(status_code=404, detail=\"Asset File Not Found\")\n\n    # Use libmagic to determine MIME type to be really sure\n    magic_mime_type = get_mime_type(asset_file)\n\n    # Return image and other types\n    if asset.type == \"image\" or asset.type == \"other\":\n        return FileResponse(asset_file, media_type=magic_mime_type)\n\n    # Only support audio formats supported by Willow\n    if magic_mime_type == \"audio/flac\" or magic_mime_type == \"audio/x-wav\":\n        return FileResponse(asset_file, media_type=magic_mime_type)\n    else:\n        raise HTTPException(status_code=404, detail=\"Audio Asset wrong file format\")\n"}
{"type": "source_file", "path": "app/routers/info.py", "content": "from logging import getLogger\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends\nfrom fastapi.responses import JSONResponse\n\nfrom app.settings import Settings, get_settings\n\n\nlog = getLogger(\"WAS\")\n\nrouter = APIRouter(\n    prefix=\"/api\",\n)\n\n\n@router.get(\"/info\")\nasync def api_get_info(settings: Annotated[Settings, Depends(get_settings)]):\n    log.debug('API GET VERSION: Request')\n\n    info = {\n        'was': {\n            'version': settings.was_version,\n        }\n    }\n\n    return JSONResponse(info)\n"}
{"type": "source_file", "path": "app/internal/wake.py", "content": "import asyncio\nimport json\nimport time\n\nfrom logging import getLogger\nfrom uuid import uuid4\n\n\nlog = getLogger(\"WAS\")\n\n\nclass WakeEvent:\n    def __init__(self, client, volume):\n        self.client = client\n        self.volume = volume\n\n\nclass WakeSession:\n    def __init__(self):\n        self.done = False\n        self.events = []\n        self.id = uuid4()\n        self.ts = time.time()\n        log.debug(f\"WakeSession with ID {self.id} created\")\n\n    def add_event(self, event):\n        log.debug(f\"WakeSession {self.id} adding event {event}\")\n        self.events.append(event)\n\n    async def cleanup(self, timeout=400):\n        await asyncio.sleep(timeout / 1000)\n        max_volume = -1000.0\n        winner = None\n        for event in self.events:\n            if event.volume > max_volume:\n                max_volume = event.volume\n                winner = event.client\n\n        # notify winner first\n        await winner.send_text(json.dumps({'wake_result': {'won': True}}))\n\n        for event in self.events:\n            if event.client != winner:\n                await event.client.send_text(json.dumps({'wake_result': {'won': False}}))\n\n        log.debug(f\"Marking WakeSession with ID {self.id} done. Winner: {winner}\")\n        self.done = True\n"}
{"type": "source_file", "path": "app/internal/was.py", "content": "import json\nimport magic\nimport os\nimport random\nimport re\nimport requests\nimport socket\nimport time\nimport urllib\nimport urllib3\n\nfrom hashlib import sha256\nfrom logging import getLogger\n\nfrom num2words import num2words\nfrom websockets.sync.client import connect\n\nfrom ..const import (\n    DIR_OTA,\n    STORAGE_TZ,\n    STORAGE_USER_CLIENT_CONFIG,\n    STORAGE_USER_CONFIG,\n    STORAGE_USER_MULTINET,\n    STORAGE_USER_NVS,\n    STORAGE_USER_WAS,\n    URL_WILLOW_RELEASES,\n    URL_WILLOW_TZ,\n)\n\n\nlog = getLogger(\"WAS\")\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n\ndef build_msg(config, container):\n    try:\n        msg = json.dumps({container: json.loads(config)}, sort_keys=True)\n        return msg\n    except Exception as e:\n        log.error(f\"Failed to build config message: {e}\")\n\n\ndef construct_url(host, port, tls=False, ws=False):\n    if tls:\n        if ws:\n            scheme = \"wss\"\n        else:\n            scheme = \"https\"\n    else:\n        if ws:\n            scheme = \"ws\"\n        else:\n            scheme = \"http\"\n\n    return f\"{scheme}://{host}:{port}\"\n\n\ndef construct_wis_tts_url(url):\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.query) == 0:\n        return urllib.parse.urljoin(url, \"?text=\")\n    else:\n        params = urllib.parse.parse_qs(parsed.query)\n        log.debug(f\"construct_wis_tts_url: parsed={parsed} - params={params}\")\n        if \"text\" in params:\n            log.warning(\"removing text parameter from WIS TTS URL\")\n            del params[\"text\"]\n        params[\"text\"] = \"\"\n        parsed = parsed._replace(query=urllib.parse.urlencode(params, doseq=True))\n        log.debug(f\"construct_wis_tts_url: parsed={parsed} - params={params}\")\n        return urllib.parse.urlunparse(parsed)\n\n\nasync def device_command(connmgr, data, command):\n    if 'hostname' in data:\n        hostname = data[\"hostname\"]\n\n    msg = json.dumps({'cmd': command})\n    try:\n        ws = connmgr.get_client_by_hostname(hostname)\n        await ws.send_text(msg)\n        return \"Success\"\n    except Exception as e:\n        log.error(f\"Failed to send restart command to {data['hostname']} ({e})\")\n        return \"Error\"\n\n\ndef do_get_request(url, verify=False, timeout=(1, 60)):\n    try:\n        parsed_url = urllib.parse.urlparse(url)\n\n        if parsed_url.username and parsed_url.password:\n            # Request with auth\n            basic_auth = requests.auth.HTTPBasicAuth(parsed_url.username, parsed_url.password)\n            response = requests.get(url, verify=verify, timeout=timeout, auth=basic_auth)\n        else:\n            # Request without auth\n            response = requests.get(url, verify=verify, timeout=timeout)\n        return response\n\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n        return None\n\n\ndef get_config():\n    return get_json_from_file(STORAGE_USER_CONFIG)\n\n\ndef get_devices():\n    devices = []\n\n    if os.path.isfile(STORAGE_USER_CLIENT_CONFIG):\n        with open(STORAGE_USER_CLIENT_CONFIG, \"r\") as devices_file:\n            devices = json.load(devices_file)\n        devices_file.close()\n    else:\n        with open(STORAGE_USER_CLIENT_CONFIG, \"x\") as devices_file:\n            json.dump(devices, devices_file)\n        devices_file.close()\n\n    return devices\n\n\ndef get_ha_commands_for_entity(entity):\n    commands = []\n    pattern = r'[^A-Za-z- ]'\n\n    numbers = re.search(r'(\\d{1,})', entity)\n    if numbers:\n        for number in numbers.groups():\n            entity = entity.replace(number, f\" {num2words(int(number))} \")\n\n    entity = entity.replace('_', ' ')\n    entity = re.sub(pattern, '', entity)\n    entity = \" \".join(entity.split())\n    entity = entity.upper()\n\n    on = f'TURN ON {entity}'\n    off = f'TURN OFF {entity}'\n\n    # ESP_MN_MAX_PHRASE_LEN=63\n    if len(off) < 63:\n        commands.extend([on, off])\n\n    return commands\n\n\ndef get_ha_entities(url, token):\n    if token is None:\n        return json.dumps({'error': 'HA token not set'})\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\",\n    }\n    url = f\"{url}/api/states\"\n    response = requests.get(url, headers=headers)\n    data = response.json()\n    data.sort(key=lambda x: x['entity_id'])\n    return data\n\n\ndef get_ip():\n    sk = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sk.connect((\"1.1.1.1\", 53))\n    ip = sk.getsockname()[0]\n    sk.close()\n    return ip\n\n\ndef get_json_from_file(path):\n    try:\n        with open(path, \"r\") as file:\n            data = json.load(file)\n        file.close()\n    except Exception:\n        data = {}\n\n    return data\n\n\ndef get_mime_type(filename):\n    mime_type = magic.Magic(mime=True).from_file(filename)\n    return mime_type\n\n\ndef get_multinet():\n    return get_json_from_file(STORAGE_USER_MULTINET)\n\n\ndef get_nvs():\n    return get_json_from_file(STORAGE_USER_NVS)\n\n\ndef get_release_url(was_url, version, platform):\n    #url_parts = re.match(r\"^(?:\\w+:\\/\\/)?([^\\/:]+)(?::(\\d+))?\", was_url)\n    parsed = urllib.parse.urlparse(was_url)\n\n    match parsed.scheme:\n        case \"ws\":\n            scheme = \"http\"\n        case \"wss\":\n            scheme = \"https\"\n\n    url = f\"{scheme}://{parsed.netloc}/api/ota?version={version}&platform={platform}\"\n    return url\n\n\n# TODO: Find a better way but we need to handle every error possible\ndef get_releases_local():\n    local_dir = f\"{DIR_OTA}/local\"\n    assets = []\n    if not os.path.exists(local_dir):\n        return assets\n\n    url = \"https://heywillow.io\"\n\n    for asset_name in os.listdir(local_dir):\n        if '.bin' in asset_name:\n            file = f\"{DIR_OTA}/local/{asset_name}\"\n            created_at = os.path.getctime(file)\n            created_at = time.ctime(created_at)\n            created_at = time.strptime(created_at)\n            created_at = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", created_at)\n            with open(file, \"rb\") as f:\n                bytes = f.read()\n                checksum = sha256(bytes).hexdigest()\n            asset = {}\n            asset[\"name\"] = f\"willow-ota-{asset_name}\"\n            asset[\"tag_name\"] = f\"willow-ota-{asset_name}\"\n            asset[\"platform\"] = asset_name.replace('.bin', '')\n            asset[\"platform_name\"] = asset[\"platform\"]\n            asset[\"platform_image\"] = \"https://heywillow.io/images/esp32_s3_box.png\"\n            asset[\"build_type\"] = \"ota\"\n            asset[\"url\"] = url\n            asset[\"id\"] = random.randint(10, 99)\n            asset[\"content_type\"] = \"raw\"\n            asset[\"size\"] = os.path.getsize(file)\n            asset[\"created_at\"] = created_at\n            asset[\"browser_download_url\"] = url\n            asset[\"sha256\"] = checksum\n            assets.append(asset)\n\n    if assets == []:\n        return []\n    else:\n        return [{\"name\": \"local\",\n                 \"tag_name\": \"local\",\n                 \"id\": random.randint(10, 99),\n                 \"url\": url,\n                 \"html_url\": url,\n                 \"assets\": assets}]\n\n\ndef get_releases_willow():\n    releases = requests.get(URL_WILLOW_RELEASES)\n    releases = releases.json()\n    try:\n        releases_local = get_releases_local()\n    except Exception:\n        pass\n    else:\n        releases = releases_local + releases\n    return releases\n\n\ndef get_tz():\n    try:\n        with open(\"tz.json\", \"r\") as config_file:\n            tz = json.load(config_file)\n        config_file.close()\n    except Exception:\n        tz = {}\n\n    return tz\n\n\ndef get_tz_config(refresh=False):\n    if refresh:\n        tz = requests.get(URL_WILLOW_TZ).json()\n        with open(STORAGE_TZ, \"w\") as tz_file:\n            json.dump(tz, tz_file)\n        tz_file.close()\n\n    return get_json_from_file(STORAGE_TZ)\n\n\ndef get_was_config():\n    return get_json_from_file(STORAGE_USER_WAS)\n\n\ndef get_was_url():\n    try:\n        nvs = get_nvs()\n        return nvs[\"WAS\"][\"URL\"]\n    except Exception:\n        return False\n\n\ndef is_safe_path(basedir, path, follow_symlinks=True):\n    # resolves symbolic links\n    if follow_symlinks:\n        matchpath = os.path.realpath(path)\n    else:\n        matchpath = os.path.abspath(path)\n    return basedir == os.path.commonpath((basedir, matchpath))\n\n\ndef merge_dict(dict_1, dict_2):\n    result = dict_1 | dict_2\n    return result\n\n\nasync def post_config(request, apply=False):\n    data = await request.json()\n    if 'hostname' in data:\n        hostname = data[\"hostname\"]\n        data = get_config()\n        msg = build_msg(json.dumps(data), \"config\")\n        try:\n            ws = request.app.connmgr.get_client_by_hostname(hostname)\n            await ws.send_text(msg)\n            return \"Success\"\n        except Exception as e:\n            log.error(f\"Failed to apply config to {hostname} ({e})\")\n            return \"Error\"\n    else:\n        if \"wis_tts_url\" in data:\n            data[\"wis_tts_url_v2\"] = construct_wis_tts_url(data[\"wis_tts_url\"])\n            del data[\"wis_tts_url\"]\n            log.debug(f\"wis_tts_url_v2: {data['wis_tts_url_v2']}\")\n\n        data = json.dumps(data)\n        save_json_to_file(STORAGE_USER_CONFIG, data)\n        msg = build_msg(data, \"config\")\n        log.debug(str(msg))\n        if apply:\n            await request.app.connmgr.broadcast(msg)\n        return \"Success\"\n\n\nasync def post_nvs(request, apply=False):\n    data = await request.json()\n    if 'hostname' in data:\n        hostname = data[\"hostname\"]\n        data = get_nvs()\n        msg = build_msg(json.dumps(data), \"nvs\")\n        try:\n            ws = request.app.connmgr.get_client_by_hostname(hostname)\n            await ws.send_text(msg)\n            return \"Success\"\n        except Exception as e:\n            log.error(f\"Failed to apply config to {hostname} ({e})\")\n            return \"Error\"\n    else:\n        data = json.dumps(data)\n        save_json_to_file(STORAGE_USER_NVS, data)\n        msg = build_msg(data, \"nvs\")\n        log.debug(str(msg))\n        if apply:\n            await request.app.connmgr.broadcast(msg)\n        return \"Success\"\n\n\nasync def post_was(request, apply=False):\n    data = await request.json()\n    data = json.dumps(data)\n    save_json_to_file(STORAGE_USER_WAS, data)\n    return \"Success\"\n\n\ndef save_json_to_file(path, content):\n    with open(path, \"w\") as config_file:\n        config_file.write(content)\n    config_file.close()\n\n\ndef warm_tts(data):\n    try:\n        if \"/api/tts\" in data[\"audio_url\"]:\n            do_get_request(data[\"audio_url\"])\n            log.debug(\"TTS ready - passing to clients\")\n    except Exception:\n        pass\n"}
{"type": "source_file", "path": "app/routers/config.py", "content": "from logging import getLogger\nfrom re import sub\nfrom typing import Literal, Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request\nfrom fastapi.responses import JSONResponse, PlainTextResponse\nfrom pydantic import BaseModel, Field\nfrom requests import get\n\nfrom ..const import URL_WILLOW_CONFIG\nfrom ..internal.command_endpoints.main import init_command_endpoint\nfrom ..internal.was import (\n    construct_url,\n    get_config,\n    get_multinet,\n    get_nvs,\n    get_tz_config,\n    get_was_config,\n    post_config,\n    post_nvs,\n    post_was,\n)\n\n\nlog = getLogger(\"WAS\")\nrouter = APIRouter(prefix=\"/api\")\n\n\nclass GetConfig(BaseModel):\n    type: Literal['config', 'nvs', 'ha_url', 'ha_token', 'multinet', 'was', 'tz'] = Field(\n        Query(..., description='Configuration type')\n    )\n    default: Optional[bool] = False\n\n\n@router.get(\"/config\")\nasync def api_get_config(config: GetConfig = Depends()):\n    log.debug('API GET CONFIG: Request')\n    # TZ is special\n    if config.type == \"tz\":\n        config = get_tz_config(refresh=config.default)\n        return JSONResponse(content=config)\n\n    # Otherwise handle other config types\n    if config.default:\n        default_config = get(f\"{URL_WILLOW_CONFIG}?type={config.type}\").json()\n        if isinstance(default_config, dict):\n            return default_config\n        else:\n            raise HTTPException(status_code=400, detail=\"Invalid default config\")\n\n    if config.type == \"nvs\":\n        nvs = get_nvs()\n        return JSONResponse(content=nvs)\n    elif config.type == \"config\":\n        config = get_config()\n        if \"wis_tts_url_v2\" in config:\n            config[\"wis_tts_url\"] = sub(\"[&?]text=\", \"\", config[\"wis_tts_url_v2\"])\n            del config[\"wis_tts_url_v2\"]\n        return JSONResponse(content=config)\n    elif config.type == \"ha_token\":\n        config = get_config()\n        return PlainTextResponse(config[\"hass_token\"])\n    elif config.type == \"ha_url\":\n        config = get_config()\n        url = construct_url(config[\"hass_host\"], config[\"hass_port\"], config[\"hass_tls\"])\n        return PlainTextResponse(url)\n    elif config.type == \"multinet\":\n        config = get_multinet()\n        return JSONResponse(content=config)\n    elif config.type == \"was\":\n        config = get_was_config()\n        return JSONResponse(content=config)\n\n\nclass PostConfig(BaseModel):\n    type: Literal['config', 'nvs', 'was'] = Field(Query(..., description='Configuration type'))\n    apply: bool = Field(Query(..., description='Apply configuration to device'))\n\n\n@router.post(\"/config\")\nasync def api_post_config(request: Request, config: PostConfig = Depends()):\n    log.debug('API POST CONFIG: Request')\n    if config.type == \"config\":\n        await post_config(request, config.apply)\n        init_command_endpoint(request.app)\n    elif config.type == \"nvs\":\n        await post_nvs(request, config.apply)\n    elif config.type == \"was\":\n        await post_was(request, config.apply)\n"}
{"type": "source_file", "path": "app/routers/ota.py", "content": "import os\n\nfrom logging import getLogger\nfrom pathlib import Path\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom fastapi.responses import FileResponse\nfrom pydantic import BaseModel, Field\nfrom requests import get\n\nfrom ..const import DIR_OTA\nfrom ..internal.was import get_releases_willow, is_safe_path\n\n\nlog = getLogger(\"WAS\")\nrouter = APIRouter(prefix=\"/api\")\n\n\nclass GetOta(BaseModel):\n    version: str = Field(Query(..., description='OTA Version'))\n    platform: str = Field(Query(..., description='OTA Platform'))\n\n\n@router.get(\"/ota\")\nasync def api_get_ota(ota: GetOta = Depends()):\n    log.debug('API GET OTA: Request')\n    ota_file = f\"{DIR_OTA}/{ota.version}/{ota.platform}.bin\"\n    if not is_safe_path(DIR_OTA, ota_file):\n        return\n    if not os.path.isfile(ota_file):\n        releases = get_releases_willow()\n        for release in releases:\n            if release[\"name\"] == ota.version:\n                assets = release[\"assets\"]\n                for asset in assets:\n                    if asset[\"platform\"] == ota.platform:\n                        Path(f\"{DIR_OTA}/{ota.version}\").mkdir(parents=True, exist_ok=True)\n                        r = get(asset[\"browser_download_url\"])\n                        open(ota_file, 'wb').write(r.content)\n\n    # If we still don't have the file return 404 - the platform and/or version doesn't exist\n    if not os.path.isfile(ota_file):\n        raise HTTPException(status_code=404, detail=\"OTA File Not Found\")\n\n    return FileResponse(ota_file)\n"}
{"type": "source_file", "path": "app/internal/notify.py", "content": "import asyncio\nimport json\nimport time\n\nfrom logging import getLogger\nfrom pydantic import BaseModel, ConfigDict, Field\nfrom typing import Annotated, Dict, List, Optional\n\nfrom .connmgr import ConnMgr\n\n\nlog = getLogger(\"WAS\")\n\n\nclass NotifyData(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n    audio_url: Optional[str] = None\n    backlight: bool = False\n    backlight_max: bool = False\n    cancel: bool = False\n    id: int = -1\n    repeat: int = 1\n    strobe_period_ms: Optional[int] = 0\n    text: Optional[str] = None\n    volume: Optional[int] = Optional[Annotated[int, Field(ge=0, le=100)]]\n\n\nclass NotifyMsg(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    cmd: str = \"notify\"\n    data: NotifyData\n    hostname: Optional[str] = None\n\n\nclass NotifyQueue(BaseModel):\n    model_config = ConfigDict(arbitrary_types_allowed=True, extra=\"forbid\")\n\n    connmgr: ConnMgr = None\n    notifications: Dict[str, List[NotifyData]] = {}\n    task: asyncio.Task = None\n\n    def start(self):\n        loop = asyncio.get_event_loop()\n        self.task = loop.create_task(self.dequeue())\n\n    def add(self, msg):\n        msg = NotifyMsg.model_validate_json(json.dumps(msg))\n        if not hasattr(msg.data, \"id\") or msg.data.id < 0:\n            msg.data.id = int(time.time() * 1000)\n\n        log.debug(msg)\n\n        if msg.hostname is not None:\n            mac_addr = self.connmgr.get_mac_by_hostname(msg.hostname)\n            if mac_addr == \"unknown\":\n                log.warn(f\"no MAC address found for {msg.hostname}, skipping notification\")\n                return\n            if mac_addr in self.notifications:\n                self.notifications[mac_addr].append(msg.data)\n            else:\n                self.notifications.update({mac_addr: [msg.data]})\n\n        else:\n            for _, client in self.connmgr.connected_clients.items():\n                if client.mac_addr == \"unknown\":\n                    log.warn(f\"no MAC address found for {client.hostname}, skipping\")\n                    continue\n                if client.mac_addr in self.notifications:\n                    self.notifications[client.mac_addr].append(msg.data)\n                else:\n                    self.notifications.update({client.mac_addr: [msg.data]})\n\n    def done(self, ws, id):\n        client = self.connmgr.get_client_by_ws(ws)\n        for i, notification in enumerate(self.notifications[client.mac_addr]):\n            if notification.id == id:\n                self.connmgr.set_notification_active(ws, 0)\n                self.notifications[client.mac_addr].pop(i)\n                break\n\n        data = NotifyData(id=id, cancel=True)\n        # explicitly set cmd so we can use exclude_unset\n        msg_cancel = NotifyMsg(cmd=\"notify\", data=data)\n        log.info(msg_cancel)\n        asyncio.ensure_future(self.connmgr.broadcast(msg_cancel.model_dump_json(exclude_unset=True)))\n\n    async def dequeue(self):\n        while True:\n            try:\n                for mac_addr, notifications in self.notifications.items():\n                    # log.debug(f\"dequeueing notifications for {mac_addr}: {notifications} (len={len(notifications)})\")\n                    if len(notifications) > 0:\n                        ws = self.connmgr.get_ws_by_mac(mac_addr)\n                        if ws is None:\n                            continue\n                        if self.connmgr.is_notification_active(ws):\n                            log.debug(f\"{mac_addr} has active notification\")\n                            continue\n\n                        for i, notification in enumerate(notifications):\n                            if notification.id > int(time.time() * 1000):\n                                continue\n                            elif notification.id < int((time.time() - 3600) * 1000):\n                                # TODO should we make this configurable ?\n                                # or at least use a constant and reject notifications with old ID in the API\n                                log.warning(\"expiring notification older than 1h\")\n                                notifications.pop(i)\n\n                            self.connmgr.set_notification_active(ws, notification.id)\n                            log.debug(f\"dequeueing notification for {mac_addr}: {notification}\")\n                            msg = NotifyMsg(data=notification)\n                            asyncio.ensure_future(ws.send_text(\n                                msg.model_dump_json(exclude={'hostname'}, exclude_none=True))\n                            )\n                            # don't send more than one notification at once\n                            break\n            except Exception as e:\n                log.debug(f\"exception during dequeue: {e}\")\n\n            await asyncio.sleep(1)\n"}
{"type": "source_file", "path": "app/main.py", "content": "import asyncio\nimport json\nimport os\nfrom fastapi import (\n    FastAPI,\n    Header,\n    WebSocket,\n    WebSocketDisconnect,\n)\nfrom contextlib import asynccontextmanager\nfrom fastapi.responses import RedirectResponse\nfrom fastapi.staticfiles import StaticFiles\nimport logging\nfrom pathlib import Path\nfrom shutil import move\nfrom typing import Annotated\nfrom websockets.exceptions import ConnectionClosed\nfrom fastapi.middleware.cors import CORSMiddleware\n\nfrom app.const import (\n    DIR_OTA,\n    STORAGE_USER_CONFIG,\n)\n\nfrom app.internal.command_endpoints import (\n    CommandEndpointResponse,\n    CommandEndpointResult,\n    CommandEndpointRuntimeException\n)\nfrom app.internal.command_endpoints.main import init_command_endpoint\nfrom app.internal.was import (\n    build_msg,\n    get_tz_config,\n)\nfrom app.settings import get_settings\n\nfrom .internal.client import Client\nfrom .internal.connmgr import ConnMgr\nfrom .internal.notify import NotifyQueue\nfrom .internal.wake import WakeEvent, WakeSession\nfrom .routers import asset\nfrom .routers import client\nfrom .routers import config\nfrom .routers import info\nfrom .routers import ota\nfrom .routers import release\nfrom .routers import status\n\n\nlogging.basicConfig(\n    format='%(asctime)s %(levelname)-8s %(message)s',\n    level=logging.INFO,\n    datefmt='%Y-%m-%d %H:%M:%S')\n\nlog = logging.getLogger(\"WAS\")\ntry:\n    log.setLevel(os.environ.get(\"WAS_LOG_LEVEL\").upper())\nexcept Exception:\n    pass\n\nsettings = get_settings()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    migrate_user_files()\n    get_tz_config(refresh=True)\n\n    app.connmgr = ConnMgr()\n\n    try:\n        init_command_endpoint(app)\n    except Exception as e:\n        app.command_endpoint = None\n        log.error(f\"failed to initialize command endpoint ({e})\")\n\n    app.notify_queue = NotifyQueue(connmgr=app.connmgr)\n    app.notify_queue.start()\n\n    yield\n    log.info(\"shutting down\")\n\napp = FastAPI(title=\"Willow Application Server\",\n              description=\"Willow Management API\",\n              openapi_url=\"/openapi.json\",\n              docs_url=\"/docs\",\n              lifespan=lifespan,\n              redoc_url=\"/redoc\",\n              version=settings.was_version)\n\nwake_session = None\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\ndef migrate_user_files():\n    for user_file in ['user_config.json', 'user_multinet.json', 'user_nvs.json']:\n        if os.path.isfile(user_file):\n            dest = f\"storage/{user_file}\"\n            if not os.path.isfile(dest):\n                move(user_file, dest)\n\n\ndef hex_mac(mac):\n    if isinstance(mac, list):\n        mac = '%02x:%02x:%02x:%02x:%02x:%02x' % (mac[0], mac[1], mac[2], mac[3], mac[4], mac[5])\n    return mac\n\n\n# Make sure we always have DIR_OTA\nPath(DIR_OTA).mkdir(parents=True, exist_ok=True)\n\n\napp.mount(\"/admin\", StaticFiles(directory=\"static/admin\", html=True), name=\"admin\")\n\n\ndef get_config_ws():\n    config = None\n    try:\n        with open(STORAGE_USER_CONFIG, \"r\") as config_file:\n            config = config_file.read()\n    except Exception as e:\n        log.error(f\"Failed to get config: {e}\")\n    finally:\n        config_file.close()\n        return config\n\n\n@app.get(\"/\", response_class=RedirectResponse)\ndef api_redirect_admin():\n    log.debug('API GET ROOT: Request')\n    return \"/admin\"\n\n\napp.include_router(asset.router)\napp.include_router(client.router)\napp.include_router(config.router)\napp.include_router(info.router)\napp.include_router(ota.router)\napp.include_router(release.router)\napp.include_router(status.router)\n\n\n# WebSockets with params return 403 when done with APIRouter\n# https://github.com/tiangolo/fastapi/issues/98#issuecomment-1688632239\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(\n        websocket: WebSocket,\n        user_agent: Annotated[str | None, Header(convert_underscores=True)] = None):\n    client = Client(ua=user_agent)\n\n    await app.connmgr.accept(websocket, client)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            log.debug(str(data))\n            msg = json.loads(data)\n\n            # latency sensitive so handle first\n            if \"wake_start\" in msg:\n                global wake_session\n                if wake_session is not None:\n                    if wake_session.done:\n                        del wake_session\n                        wake_session = WakeSession()\n                        asyncio.create_task(wake_session.cleanup())\n                else:\n                    wake_session = WakeSession()\n                    asyncio.create_task(wake_session.cleanup())\n\n                if \"wake_volume\" in msg[\"wake_start\"]:\n                    wake_event = WakeEvent(websocket, msg[\"wake_start\"][\"wake_volume\"])\n                    wake_session.add_event(wake_event)\n\n            elif \"wake_end\" in msg:\n                pass\n\n            elif \"notify_done\" in msg:\n                app.notify_queue.done(websocket, msg[\"notify_done\"])\n\n            elif \"cmd\" in msg:\n                if msg[\"cmd\"] == \"endpoint\":\n                    if app.command_endpoint is not None:\n                        log.debug(f\"Sending {msg['data']} to {app.command_endpoint.name}\")\n                        try:\n                            resp = app.command_endpoint.send(jsondata=msg[\"data\"], ws=websocket)\n                            if resp is not None:\n                                resp = app.command_endpoint.parse_response(resp)\n                                log.debug(f\"Got response {resp} from endpoint\")\n                                # HomeAssistantWebSocketEndpoint sends message via callback\n                                if resp is not None:\n                                    asyncio.ensure_future(websocket.send_text(resp))\n                        except CommandEndpointRuntimeException as e:\n                            command_endpoint_result = CommandEndpointResult(speech=\"WAS Command Endpoint unreachable\")\n                            command_endpoint_response = CommandEndpointResponse(result=command_endpoint_result)\n                            asyncio.ensure_future(websocket.send_text(command_endpoint_response.model_dump_json()))\n                            log.error(f\"WAS Command Endpoint unreachable: {e}\")\n\n                    else:\n                        command_endpoint_result = CommandEndpointResult(speech=\"WAS Command Endpoint not active\")\n                        command_endpoint_response = CommandEndpointResponse(result=command_endpoint_result)\n                        asyncio.ensure_future(websocket.send_text(command_endpoint_response.model_dump_json()))\n                        log.error(\"WAS Command Endpoint not active\")\n\n                elif msg[\"cmd\"] == \"get_config\":\n                    asyncio.ensure_future(websocket.send_text(build_msg(get_config_ws(), \"config\")))\n\n            elif \"goodbye\" in msg:\n                app.connmgr.disconnect(websocket)\n\n            elif \"hello\" in msg:\n                if \"hostname\" in msg[\"hello\"]:\n                    app.connmgr.update_client(websocket, \"hostname\", msg[\"hello\"][\"hostname\"])\n                if \"hw_type\" in msg[\"hello\"]:\n                    platform = msg[\"hello\"][\"hw_type\"].upper()\n                    app.connmgr.update_client(websocket, \"platform\", platform)\n                if \"mac_addr\" in msg[\"hello\"]:\n                    mac_addr = hex_mac(msg[\"hello\"][\"mac_addr\"])\n                    app.connmgr.update_client(websocket, \"mac_addr\", mac_addr)\n\n    except WebSocketDisconnect:\n        app.connmgr.disconnect(websocket)\n    except ConnectionClosed:\n        app.connmgr.disconnect(websocket)\n    except Exception as e:\n        log.error(f\"unhandled exception in WebSocket route: {e}\")\n"}
{"type": "source_file", "path": "misc/migrate_devices.py", "content": "import json\nimport os\nimport sys\n\nSTORAGE_USER_CLIENT_CONFIG = '/app/storage/user_client_config.json'\nSTORAGE_DEVICES_CONFIG = '/app/storage/devices.json'\n\ndef hex_mac(mac):\n    if type(mac) == list:\n        mac = '%02x:%02x:%02x:%02x:%02x:%02x' % (mac[0], mac[1], mac[2], mac[3], mac[4], mac[5])\n    return mac\n\ndef save_json_to_file(path, content):\n    with open(path, \"w\") as config_file:\n        config_file.write(content)\n    config_file.close()\n\nif os.path.isfile(STORAGE_USER_CLIENT_CONFIG):\n    sys.exit()\n\nif os.path.isfile(STORAGE_DEVICES_CONFIG):\n    print('Migrating legacy WAS client configuration...')\n    devices_file = open(STORAGE_DEVICES_CONFIG, \"r\")\n    devices = json.load(devices_file)\n    devices_file.close()\n\n    new_devices=[]\n    for device in devices:\n        mac_addr = hex_mac(device[\"mac_addr\"])\n        label = device[\"label\"]\n        user_config = {\"mac_addr\": mac_addr, \"label\": label}\n        new_devices.append(user_config)\n\n    save_json_to_file(STORAGE_USER_CLIENT_CONFIG, json.dumps(new_devices))"}
{"type": "source_file", "path": "app/settings.py", "content": "from functools import lru_cache\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    was_version: str = \"unknown\"\n\n\n@lru_cache\ndef get_settings():\n    return Settings()\n"}
{"type": "source_file", "path": "app/routers/status.py", "content": "import asyncio\n\nfrom logging import getLogger\nfrom typing import Literal\n\nfrom fastapi import APIRouter, Depends, Query, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field\n\n\nlog = getLogger(\"WAS\")\n\nrouter = APIRouter(\n    prefix=\"/api\",\n)\n\n\nclass GetStatus(BaseModel):\n    type: Literal['asyncio_tasks', 'connmgr', 'notify_queue'] = Field(Query(..., description='Status type'))\n\n\n@router.get(\"/status\")\nasync def api_get_status(request: Request, status: GetStatus = Depends()):\n    log.debug('API GET STATUS: Request')\n    res = []\n\n    if status.type == \"asyncio_tasks\":\n        tasks = asyncio.all_tasks()\n        for task in tasks:\n            res.append(f\"{task.get_name()}: {task.get_coro()}\")\n\n    elif status.type == \"connmgr\":\n        return JSONResponse(request.app.connmgr.model_dump(exclude={}))\n\n    elif status.type == \"notify_queue\":\n        return JSONResponse(request.app.notify_queue.model_dump(exclude={'connmgr', 'task'}))\n\n    return JSONResponse(res)\n"}
{"type": "source_file", "path": "app/routers/client.py", "content": "import json\n\nfrom logging import getLogger\nfrom typing import Literal\n\nfrom fastapi import APIRouter, Depends, Query, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field\n\nfrom ..const import STORAGE_USER_CLIENT_CONFIG\nfrom ..internal.was import device_command, get_devices, warm_tts\n\n\nlog = getLogger(\"WAS\")\nrouter = APIRouter(\n    prefix=\"/api\",\n)\n\n\n@router.get(\"/client\")\nasync def api_get_client(request: Request):\n    log.debug('API GET CLIENT: Request')\n    devices = get_devices()\n    clients = []\n    macs = []\n    labels = {}\n\n    # This is ugly but it provides a combined response\n    for ws, client in request.app.connmgr.connected_clients.items():\n        if client.mac_addr not in macs:\n            labels.update({client.mac_addr: None})\n            for device in devices:\n                if device[\"mac_addr\"] == client.mac_addr:\n                    if device[\"label\"]:\n                        labels.update({client.mac_addr: device[\"label\"]})\n            version = client.ua.replace(\"Willow/\", \"\")\n            clients.append({\n                'hostname': client.hostname,\n                'platform': client.platform,\n                'mac_addr': client.mac_addr,\n                'ip': ws.client.host,\n                'port': ws.client.port,\n                'version': version,\n                'label': labels[client.mac_addr]\n            })\n            macs.append(client.mac_addr)\n\n    # Sort connected clients by label if we have it\n    # If all devices don't have labels we fall back to sorting by hostname\n    try:\n        sorted_clients = sorted(clients, key=lambda x: x['label'])\n    except Exception:\n        sorted_clients = sorted(clients, key=lambda x: x['hostname'])\n\n    return JSONResponse(content=sorted_clients)\n\n\nclass PostClient(BaseModel):\n    action: Literal['restart', 'update', 'config', 'identify', 'notify'] = Field(\n        Query(..., description='Client action')\n    )\n\n\n@router.post(\"/client\")\nasync def api_post_client(request: Request, device: PostClient = Depends()):\n    log.debug('API POST CLIENT: Request')\n    data = await request.json()\n\n    if device.action == \"update\":\n        msg = json.dumps({'cmd': 'ota_start', 'ota_url': data[\"ota_url\"]})\n        try:\n            ws = request.app.connmgr.get_client_by_hostname(data[\"hostname\"])\n            await ws.send_text(msg)\n        except Exception as e:\n            log.error(f\"Failed to trigger OTA ({e})\")\n        finally:\n            return\n    elif device.action == \"config\":\n        devices = get_devices()\n        new = True\n\n        for i, device in enumerate(devices):\n            if device.get(\"mac_addr\") == data['mac_addr']:\n                new = False\n                devices[i] = data\n                break\n\n        if new and len(data['mac_addr']) > 0:\n            devices.append(data)\n\n        with open(STORAGE_USER_CLIENT_CONFIG, \"w\") as devices_file:\n            json.dump(devices, devices_file)\n        devices_file.close()\n    elif device.action == 'notify':\n        log.debug(f\"received notify command on API: {data}\")\n        warm_tts(data[\"data\"])\n        request.app.notify_queue.add(data)\n    else:\n        # Catch all assuming anything else is a device command\n        return await device_command(request.app.connmgr, data, device.action)\n"}
{"type": "source_file", "path": "app/routers/release.py", "content": "import os\n\nfrom logging import getLogger\nfrom pathlib import Path\nfrom typing import Literal\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field\nfrom requests import get\n\nfrom ..const import DIR_OTA\nfrom ..internal.was import get_release_url, get_releases_willow, get_was_url, is_safe_path\n\n\nlog = getLogger(\"WAS\")\nrouter = APIRouter(prefix=\"/api\")\n\n\nclass GetRelease(BaseModel):\n    type: Literal['was', 'willow'] = Field(Query(..., description='Release type'))\n\n\n@router.get(\"/release\")\nasync def api_get_release(release: GetRelease = Depends()):\n    log.debug('API GET RELEASE: Request')\n    releases = get_releases_willow()\n    if release.type == \"willow\":\n        return releases\n    elif release.type == \"was\":\n        was_url = get_was_url()\n        if not was_url:\n            raise HTTPException(status_code=500, detail=\"WAS URL not set\")\n\n        try:\n            for release in releases:\n                tag_name = release[\"tag_name\"]\n                assets = release[\"assets\"]\n                for asset in assets:\n                    platform = asset[\"platform\"]\n                    asset[\"was_url\"] = get_release_url(was_url, tag_name, platform)\n                    if os.path.isfile(f\"{DIR_OTA}/{tag_name}/{platform}.bin\"):\n                        asset[\"cached\"] = True\n                    else:\n                        asset[\"cached\"] = False\n        except Exception as e:\n            log.error(e)\n            pass\n\n        return JSONResponse(content=releases)\n\n\nclass PostRelease(BaseModel):\n    action: Literal['cache', 'delete'] = Field(Query(..., description='Release Cache Control'))\n\n\n@router.post(\"/release\")\nasync def api_post_release(request: Request, release: PostRelease = Depends()):\n    log.debug('API POST RELEASE: Request')\n    if release.action == \"cache\":\n        data = await request.json()\n\n        dir = f\"{DIR_OTA}/{data['version']}\"\n        # Check for safe path\n        if not is_safe_path(DIR_OTA, dir):\n            return\n        Path(dir).mkdir(parents=True, exist_ok=True)\n\n        path = f\"{dir}/{data['platform']}.bin\"\n        if os.path.exists(path):\n            if os.path.getsize(path) == data['size']:\n                return\n            else:\n                os.remove(path)\n\n        resp = get(data['willow_url'])\n        if resp.status_code == 200:\n            with open(path, \"wb\") as fw:\n                fw.write(resp.content)\n            return\n        else:\n            raise HTTPException(status_code=resp.status_code)\n    elif release.action == \"delete\":\n        data = await request.json()\n        path = data['path']\n        if is_safe_path(DIR_OTA, path):\n            os.remove(path)\n"}

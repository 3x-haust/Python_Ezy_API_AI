{"repo_info": {"repo_name": "stackoverflow-badge", "repo_owner": "claytonjhamilton", "repo_url": "https://github.com/claytonjhamilton/stackoverflow-badge"}}
{"type": "test_file", "path": "tests/test_badge_cache.py", "content": "import datetime\nimport pytest\nfrom infrastructure import badge_cache\n\ndef test_create_key():\n    # Test valid userID input\n    userID = '12345'\n    assert badge_cache.__create_key(userID) == '12345'\n\n    # Test empty userID input\n    userID = ''\n    with pytest.raises(Exception) as e:\n        badge_cache.__create_key(userID)\n    assert str(e.value) == \"userID is required\"\n\n"}
{"type": "test_file", "path": "tests/test_stackoverflow_badges.py", "content": ""}
{"type": "test_file", "path": "tests/test_validation_error.py", "content": "from models.validation_error import ValidationError\n\n\ndef test_ValidationError():\n    ve = ValidationError(error_msg=\"test\", status_code=400)\n    assert ve.status_code == 400\n    assert ve.error_msg == \"test\"\n"}
{"type": "test_file", "path": "tests/test_stackoverflow_service.py", "content": "import pytest\nimport httpx\nfrom services import stackoverflow_service\n\n\ndef test_stackoverflow_service_active():\n    \"\"\"Check if URL is still active/up to date\"\"\"\n    assert httpx.get(\"https://api.stackexchange.com/docs\").status_code == 200\n\n\n@pytest.fixture\ndef user_test_ID():\n    return {\"incorrectID\": \"a2d1d2\", \"correctID\": \"14122375\"}\n\n\ndef test_validate_input(user_test_ID):\n    \"\"\"Ensure userIDs are numeric strings and fail if not\"\"\"\n    with pytest.raises(Exception):\n        assert stackoverflow_service.validate_input(\n            user_test_ID[\"incorrectID\"]\n        )\n    assert (\n        stackoverflow_service.validate_input(user_test_ID[\"correctID\"])\n        == user_test_ID[\"correctID\"]\n    )\n\n\ndef test_format_api_output():\n    # Test input data\n    response = {\n        \"items\": [\n            {\n                \"reputation\": 123,\n                \"badge_counts\": {\n                    \"gold\": 3,\n                    \"silver\": 5,\n                    \"bronze\": 10,\n                },\n            },\n        ],\n    }\n\n    # Expected output\n    expected_output = {\n        \"rep\": 123,\n        \"gold\": 3,\n        \"silver\": 5,\n        \"bronze\": 10,\n    }\n\n    # Test function\n    output = stackoverflow_service.format_api_output(response)\n\n    # Assert output matches expected output\n    assert output == expected_output\n"}
{"type": "source_file", "path": "api/stackoverflow_badges.py", "content": "import fastapi\nimport mimetypes\nfrom starlette.templating import Jinja2Templates\nfrom starlette.requests import Request\n\nfrom services import stackoverflow_service\nfrom models.validation_error import ValidationError\n\nmimetypes.init()\n\nrouter = fastapi.APIRouter()\ntemplates = Jinja2Templates(\"./templates\")\n\n\n@router.get(\"/api/StackOverflowBadge/{userID}\")\nasync def StackOverflowBadge(request: Request, userID: str):\n    try:\n        data_dict = await stackoverflow_service.StackUserRequestAsync(userID)\n    except ValidationError as error:\n        return fastapi.Response(\n            content=error.error_msg, status_code=error.status_code\n        )\n    except Exception as x:\n        return fastapi.Response(content=str(x), status_code=500)\n    mimetypes.add_type(\"image/svg+xml\", \".svg\")\n    return templates.TemplateResponse(\n        \"badge1.svg\",\n        {\n            \"request\": request,\n            \"rep\": str(data_dict[\"rep\"]),\n            \"gold\": str(data_dict[\"gold\"]),\n            \"silver\": str(data_dict[\"silver\"]),\n            \"bronze\": str(data_dict[\"bronze\"]),\n        },\n        media_type=\"image/svg+xml\",\n    )\n"}
{"type": "source_file", "path": "infrastructure/badge_cache.py", "content": "import datetime\nfrom typing import Optional, Tuple\n\n__cache = {}\ncached_item_lifetime_in_hours = 1.0\n\n\ndef get_badge(userID) -> Optional[dict]:\n    key = __create_key(userID)\n    data: dict = __cache.get(key)\n    if not data:\n        return None\n\n    last = data[\"time\"]\n    dt = datetime.datetime.now() - last\n    if dt / datetime.timedelta(minutes=60) < cached_item_lifetime_in_hours:\n        return data[\"value\"]\n\n    del __cache[key]\n    return None\n\n\ndef set_badge(userID: str, value: dict):\n    key = __create_key(userID)\n    data = {\"time\": datetime.datetime.now(), \"value\": value}\n    __cache[key] = data\n    __clean_out_of_date()\n\n\ndef __create_key(\n    userID: str,\n) -> Tuple[str]:\n    if not userID:\n        raise Exception(\"userID is required\")\n    return userID\n\n\ndef __clean_out_of_date():\n    for key, data in list(__cache.items()):\n        dt = datetime.datetime.now() - data.get(\"time\")\n        if dt / datetime.timedelta(minutes=60) > cached_item_lifetime_in_hours:\n            del __cache[key]\n"}
{"type": "source_file", "path": "services/stackoverflow_service.py", "content": "import httpx\nfrom httpx import Response\nfrom infrastructure import badge_cache\n\nfrom models.validation_error import ValidationError\n\n\ndef validate_input(userID):\n    if userID.isnumeric():\n        return userID\n    raise ValidationError(\n        status_code=400, error_msg=\"userID is invalid. Must be an integer.\"\n    )\n\n\ndef format_api_output(response):\n    \"\"\"Format retrieved json from API call\"\"\"\n    data = response[\"items\"][0]\n    return {\n        \"rep\": data[\"reputation\"],\n        \"gold\": data[\"badge_counts\"][\"gold\"],\n        \"silver\": data[\"badge_counts\"][\"silver\"],\n        \"bronze\": data[\"badge_counts\"][\"bronze\"],\n    }\n\n\nasync def StackUserRequestAsync(userID: str):\n    userID = validate_input(userID)\n\n    if badge := badge_cache.get_badge(userID):\n        return badge\n\n    url = f\"https://api.stackexchange.com/2.3/users/{userID}\"\\\n        \"?order=desc&sort=reputation&site=stackoverflow\"\\\n        \"&filter=!LnOc*f7Nq.zHgKSZ9QN_vj\"\n\n    async with httpx.AsyncClient() as client:\n        resp: Response = await client.get(url)\n        if resp.status_code != 200:\n            raise ValidationError(resp.text, status_code=resp.status_code)\n\n    formatted_data = format_api_output(resp.json())\n\n    badge_cache.set_badge(userID, formatted_data)\n\n    return formatted_data\n"}
{"type": "source_file", "path": "main.py", "content": "import fastapi\nimport uvicorn\n\nfrom api import stackoverflow_badges\n\napi = fastapi.FastAPI(docs_url=None)\n\n\ndef configure():\n    configure_routing()\n\n\ndef configure_routing():\n    api.include_router(stackoverflow_badges.router)\n\n\nconfigure()\nif __name__ == \"__main__\":\n    uvicorn.run(api, port=8000, host=\"127.0.0.1\")\n"}
{"type": "source_file", "path": "models/validation_error.py", "content": "class ValidationError(Exception):\n    def __init__(self, error_msg: str, status_code: int):\n        super().__init__(error_msg)\n\n        self.status_code = status_code\n        self.error_msg = error_msg\n"}

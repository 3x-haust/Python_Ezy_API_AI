{"repo_info": {"repo_name": "B-OCL-Interpreter", "repo_owner": "BESSER-PEARL", "repo_url": "https://github.com/BESSER-PEARL/B-OCL-Interpreter"}}
{"type": "source_file", "path": "bocl/OCLWrapper.py", "content": "\"\"\"Including imports from BESSER and ANTLR4\"\"\"\nfrom antlr4 import InputStream,CommonTokenStream,ParseTreeWalker\nfrom besser.BUML.notations.ocl.BOCLLexer import BOCLLexer\nfrom besser.BUML.notations.ocl.BOCLParser import BOCLParser\nfrom besser.BUML.notations.ocl.BOCLListener import BOCLListener\nfrom besser.BUML.notations.ocl.RootHandler import Root_Handler\nfrom bocl.evaluator import Evaluator\n\nclass OCLWrapper:\n    \"\"\"The OCLWrapper class is the wrapper around the evaluator\n    class to prepare the construct needed by evaluator.\n\n    Args:\n        dm: Domain model in BUML\n        om: object model in BUML\n    Attributes:\n        dm: Domain model in BUML\n        om: object model in BUML\n    \"\"\"\n    def __init__(self,dm,om):\n        self.dm = dm\n        self.om = om\n    def __str__(self):\n        return str(self.dm)+ str(self.om)\n\n\n    def evaluate(self,ocl):\n        \"\"\"the evaluate function takes the OCL constraint and evaluate using evaluator\n        Args:\n            ocl: Object of OCL class that constaints the OCL expression and context class\n        \"\"\"\n\n        # self.preprocess(ocl.expression)\n        input_stream = InputStream(ocl.expression)\n        root_handler = Root_Handler(ocl,self.dm,self.om)\n        lexer = BOCLLexer(input_stream)\n        stream = CommonTokenStream(lexer)\n        parser = BOCLParser(stream)\n        tree = parser.oclFile()\n        listener = BOCLListener(root_handler)\n        walker = ParseTreeWalker()\n        walker.walk(listener,tree)\n\n        evalualor = Evaluator()\n\n        return evalualor.evaluate(root_handler, self.om)\n        # return True"}
{"type": "source_file", "path": "__init__.py", "content": ""}
{"type": "source_file", "path": "docs/source/conf.py", "content": "# Configuration file for the Sphinx documentation builder.\nimport datetime\nimport importlib\nimport inspect\nimport os\nimport sys\nfrom configparser import ConfigParser\n\n# -- Add the project root directory to the path\nsys.path.insert(0, os.path.abspath('../../'))\n\nconfig: ConfigParser = ConfigParser()\nconfig.read('../../setup.cfg')\n\n# -- Project information\nproject = config.get('metadata', 'description')\nauthor = config.get('metadata', 'author')\nrelease = config.get('metadata', 'version')\nyear = datetime.date.today().year\nif year > 2023:\n    year = '2023 - ' + str(year)\ncopyright = f'{year} {author}. All Rights Reserved'\n\n# -- General configuration\n\nextensions = [\n    'sphinx.ext.duration',  # measure durations of Sphinx processing\n    'sphinx.ext.doctest',  \n    'sphinx.ext.autodoc',  # include documentation from docstrings\n    'sphinx.ext.autosummary',  # generate autodoc summaries\n    'sphinx.ext.intersphinx',  # link to other projects’ documentation\n    'sphinx_paramlinks',  # allows :param: directives within Python documentation to be linkable\n    'sphinx.ext.linkcode',  # add external links to source code\n    'sphinx_copybutton',  # add a little “copy” button to the right of the code blocks\n    'sphinx.ext.napoleon',  # support for Google (and also NumPy) style docstrings\n]\n\nintersphinx_mapping = {\n    'python': ('https://docs.python.org/3/', None),\n    'sphinx': ('https://www.sphinx-doc.org/en/master/', None),\n}\nintersphinx_disabled_domains = ['std']\n\ntemplates_path = ['_templates']\n\nhtml_title = f\"{project} {release}\"\n\n# -- Options for HTML output\n\nhtml_theme_options = {\n    \"light_logo\": \"besser_logo_light.png\",\n    \"dark_logo\": \"besser_logo_dark.png\"\n}\nhtml_theme = 'furo'\nhtml_static_path = ['_static']\n\n# -- Options for EPUB output\n#epub_show_urls = 'footnote'\n\n\ndef linkcode_resolve(domain, info):\n    \"\"\"Generate links to module components.\"\"\"\n    if domain != 'py':\n        return None\n    if not info['module']:\n        return None\n    mod = importlib.import_module(info[\"module\"])\n    if \".\" in info[\"fullname\"]:\n        objname, attrname = info[\"fullname\"].split(\".\")\n        obj = getattr(mod, objname)\n        try:\n            # object is a method of a class\n            obj = getattr(obj, attrname)\n        except AttributeError:\n            # object is an attribute of a class\n            return None\n    else:\n        obj = getattr(mod, info[\"fullname\"])\n\n    try:\n        lines = inspect.getsourcelines(obj)\n    except TypeError:\n        return None\n    start, end = lines[1], lines[1] + len(lines[0]) - 1\n    filename = info['module'].replace('.', '/')\n    return f\"https://github.com/BESSER-PEARL/b-ocl-Interpreter/blob/master/{filename}.py#L{start}-L{end}\""}
{"type": "source_file", "path": "bocl/__init__.py", "content": ""}
{"type": "source_file", "path": "models/library_object.py", "content": "\nfrom besser.BUML.metamodel.structural import DomainModel, Class, Property, \\\n    PrimitiveDataType, Multiplicity, BinaryAssociation,Constraint\nfrom besser.BUML.metamodel.object import *\nimport datetime\n\n#############################################\n#   Library - structural model definition   #\n#############################################\n\n# Primitive DataTypes\nt_int: PrimitiveDataType = PrimitiveDataType(\"int\")\nt_str: PrimitiveDataType = PrimitiveDataType(\"str\")\nt_date: PrimitiveDataType = PrimitiveDataType(\"date\")\n\n# Library attributes definition\nlibrary_name: Property = Property(name=\"name\", type=t_str)\naddress: Property = Property(name=\"address\", type=t_str)\n# Library class definition\nlibrary: Class = Class (name=\"Library\", attributes={library_name, address})\n\n# Book attributes definition\ntitle: Property = Property(name=\"title\", type=t_str)\npages: Property = Property(name=\"pages\", type=t_int)\nrelease: Property = Property(name=\"release\", type=t_date)\n# Book class definition\nbook: Class = Class (name=\"Book\", attributes={title, pages, release})\n\n# Author attributes definition\nauthor_name: Property = Property(name=\"name\", type=t_str)\nemail: Property = Property(name=\"email\", type=t_str)\n# Author class definition\nauthor: Class = Class (name=\"Author\", attributes={author_name, email})\n\n# Library-Book association definition\nlocated_in: Property = Property(name=\"locatedIn\",type=library, multiplicity=Multiplicity(1, 1))\nhas: Property = Property(name=\"has\", type=book, multiplicity=Multiplicity(0, \"*\"))\nlib_book_association: BinaryAssociation = BinaryAssociation(name=\"lib_book_assoc\", ends={located_in, has})\n\n# Book-Author association definition\npublishes: Property = Property(name=\"publishes\", type=book, multiplicity=Multiplicity(0, \"*\"))\nwrited_by: Property = Property(name=\"writedBy\", type=author, multiplicity=Multiplicity(1, \"*\"))\nbook_author_association: BinaryAssociation = BinaryAssociation(name=\"book_author_assoc\", ends={writed_by, publishes})\n\nconstraintPageNumber: Constraint = Constraint(name = \"libraryPageNumber\",context=library,expression=\"context Library inv inv1: self.has ->forAll(b:Book|b.pages>0)\",language=\"OCL\")\n\nconstraintBookPageNumber: Constraint = Constraint(name = \"BookPageNumber\",context=book,expression=\"context Book inv inv2: self.pages>0\",language=\"OCL\")\n\nconstraintTitleIncorrect: Constraint = Constraint(name = \"BookTitleInc\",context=book,expression=\"context Book inv inv2: self.title= 'NI')\",language=\"OCL\")\n\nconstraintTitleCorrect: Constraint = Constraint(name = \"BookTitle\",context=book,expression=\"context Book inv inv2: self.title <> 'NI'\",language=\"OCL\")\n\nconstraintLibraryExists: Constraint = Constraint(name = \"LibarayExistsConst\",context=library,expression=\"context Library inv inv3: self.has->exists( i_book : Book | i_book.pages <= 110 )\",language=\"OCL\")\n\n# constraintLibraryExclude: Constraint = Constraint(name = \"LibarayExclude\",context=library,expression=\"context Library inv inv3: self.has->excludes()\",language=\"OCL\")\nconstraintLibrarySize: Constraint = Constraint(name = \"LibaraySize\",context=library,expression=\"context Library inv inv3: self.has->size()>1\",language=\"OCL\")\n\nconstraintLibraryCollect: Constraint = Constraint(name = \"LibaryCollect\",context=library,\nexpression=\"context Library inv inv3: self.has->collect(i_book : Book | i_book.pages <= 110)\"\n           \"->size()>0\",language=\"OCL\")\n\nconstraintLibraryIf: Constraint = Constraint(name =\"LibaryIf\", context=library,\nexpression=\"context Library inv inv3: if self.name <> 'NI' then self.has->exists\"\n           \"( i_book : Book | i_book.pages <= 110 ) else self.has->forAll(b:Book|b.pages>0)\"\n           \" endif\", language=\"OCL\")\n\nconstraintLibraryElse: Constraint = Constraint(name =\"LibaryElse\", context=library,\nexpression=\"context Library inv inv3: if self.name = 'NI' then self.has->exists\"\n           \"( i_book : Book | i_book.pages <= 110 ) else self.has->forAll(b:Book|b.pages>0)\"\n           \" endif\", language=\"OCL\")\n\nconstraintLibraryElseFalse: Constraint = Constraint(name =\"LibaryElseFalse\", context=library, expression=\"context Library inv inv3: if self.name = 'NI' then self.has->exists( i_book : Book | i_book.pages <= 110 ) else self.has->forAll(b:Book|b.pages<0) endif\", language=\"OCL\")\n\n\nconstraintNameOCLIsTypeOf: Constraint = Constraint(name =\"BookIsTypeOfStr\", context=book, expression=\"context Book inv inv3: self.title.oclIsTypeOf(String)\", language=\"OCL\")\n\nconstraintNameOCLIsTypeOfInt: Constraint = Constraint(name =\"BookIsTypeOfInt\", context=book, expression=\"context Book inv inv3: self.pages.oclIsTypeOf(Integer)\", language=\"OCL\")\n\nconstraintNameOCLIsTypeOfIntFalse: Constraint = Constraint(name =\"BookIsTypeOfIntFalse\", context=book, expression=\"context Book inv inv3: self.pages.oclIsTypeOf(String)\", language=\"OCL\")\nconstraintifElseSize: Constraint = Constraint(name =\"constraintifElseSize\", context=library, expression=\"context Library inv inv3: if self.name <> 'NI' then self.has->exists( i_book : Book | i_book.pages <= 110 )->size()<3 else self.has->forAll(b:Book|b.pages>0) endif\", language=\"OCL\")\nconstraintDate: Constraint = Constraint(name =\"constraintDate\", context=book, expression=\"context Book inv inv3: self.release < Date::today().addDays(10)\", language=\"OCL\")\n\nconstraintLibraryReject: Constraint = Constraint(name = \"LibaryReject\",context=library,\nexpression=\"context Library inv inv3: self.has->reject(i_book : Book | i_book.pages <= 110)\"\n           \"->size()>0\",language=\"OCL\")\n\n# Domain model definition\nlibrary_model : DomainModel = DomainModel(name=\"Library model\", types={library, book, author}, \n                                          associations={lib_book_association, book_author_association},\n                                          constraints={\n                                          constraintDate,\n                                          constraintLibraryReject,\n                                            constraintBookPageNumber,\n                                            # constraintTitleIncorrect,\n                                            constraintPageNumber,\n                                            constraintTitleCorrect,\n                                            constraintLibraryExists,\n                                            constraintLibrarySize,\n                                            constraintLibraryCollect,\n                                            constraintLibraryIf,\n                                            constraintLibraryElse,\n                                                       # constraintLibraryElseFalse,\n                                            constraintNameOCLIsTypeOf,\n                                            constraintNameOCLIsTypeOfInt,\n                                            # constraintNameOCLIsTypeOfIntFalse\n                                          }\n                                          )\n\n\n#########################################\n#   Library -  object model definition   #\n#########################################\n\n\n# Library  object attributes\nlibrary_obj_name: AttributeLink = AttributeLink(attribute=library_name, value=DataValue(classifier=t_str, value=\"Library test\"))\nlibrary_obj_address: AttributeLink = AttributeLink(attribute=address, value=DataValue(classifier=t_str, value=\"street 123\"))\n# Library  object\nlibrary_obj: Object = Object(name=\"Library Object\", classifier=library, slots=[library_obj_name, library_obj_address])\n\n# Book  object attributes\nbook_obj_name: AttributeLink = AttributeLink(attribute=title, value=DataValue(classifier=t_str, value=\"Book tittle\"))\nbook_obj_pages: AttributeLink = AttributeLink(attribute=pages, value=DataValue(classifier=t_int, value=200))\nbook_obj_release: AttributeLink = AttributeLink(attribute=release, value=DataValue(classifier=t_date, value=datetime.datetime(2020, 3, 15)))\n# Book  object\nbook_obj: Object = Object(name=\"Book Object\", classifier=book, slots=[book_obj_name, book_obj_pages,book_obj_release])\n\n# Book_2  object attributes\n\nbook_obj_name_2: AttributeLink = AttributeLink(attribute=title, value=DataValue(classifier=t_str, value=\"Book tittle_2\"))\nbook_obj_pages_2: AttributeLink = AttributeLink(attribute=pages, value=DataValue(classifier=t_int, value=400))\nbook_obj_release_2: AttributeLink = AttributeLink(attribute=release, value=DataValue(classifier=t_date, value=datetime.datetime(2024, 3, 15)))\n# Book  object\nbook_obj_2: Object = Object(name=\"Book 2 Object\", classifier=book, slots=[book_obj_name_2, book_obj_pages_2,book_obj_release_2])\n\n# Author  object attributes\nauthor_obj_name: AttributeLink = AttributeLink(attribute=author_name, value=DataValue(classifier=t_str, value=\"John Doe\"))\nauthor_obj_email: AttributeLink = AttributeLink(attribute=email, value=DataValue(classifier=t_str, value=\"john@doe.com\"))\n# Author  object\nauthor_obj: Object = Object(name=\"Author Object\", classifier=author, slots=[author_obj_name, author_obj_email])\n\n# Book  object and Author  object link\nbook_link_end1: LinkEnd = LinkEnd(name=\"book_end1\", association_end=publishes, object=book_obj)\nauthor_link_end: LinkEnd = LinkEnd(name=\"author_end\", association_end=writed_by, object=author_obj)\nauthor_book_link: Link = Link(name=\"author_book_link\", association=book_author_association, connections=[book_link_end1,author_link_end])\n\n# Book Library and Book  object link\nbook_link_end2: LinkEnd = LinkEnd(name=\"book_end2\", association_end=has, object=book_obj)\nlibrary_link_end: LinkEnd = LinkEnd(name=\"library_end\", association_end=located_in, object=library_obj)\nlibrary_book_link: Link = Link(name=\"library_book_link\", association=book_author_association, connections=[book_link_end2,library_link_end])\n\n# Book  object and Author  object link\nbook_link_end2: LinkEnd = LinkEnd(name=\"book_end3\", association_end=publishes, object=book_obj_2)\nauthor_link_end2: LinkEnd = LinkEnd(name=\"author_end2\", association_end=writed_by, object=author_obj)\nauthor_book_link2: Link = Link(name=\"author_book_link2\", association=book_author_association, connections=[book_link_end2,author_link_end2])\n\n# Book Library and Book  object link\nbook_link_end3: LinkEnd = LinkEnd(name=\"book_end4\", association_end=has, object=book_obj_2)\nlibrary_link_end3: LinkEnd = LinkEnd(name=\"library_end3\", association_end=located_in, object=library_obj)\nlibrary_book_link3: Link = Link(name=\"library_book_link3\", association=book_author_association, connections=[book_link_end3,library_link_end3])\n\n\n\n# Object model definition\nobject_model: ObjectModel = ObjectModel(name=\"Object model\", instances={library_obj, author_obj, book_obj,book_obj_2}, links={author_book_link, library_book_link,author_book_link2,library_book_link3})"}
{"type": "source_file", "path": "models/__init__.py", "content": ""}
{"type": "source_file", "path": "models/team_player_object.py", "content": "\nfrom besser.BUML.metamodel.structural import DomainModel, Class, Property, \\\n    PrimitiveDataType, Multiplicity, BinaryAssociation,Constraint\nfrom besser.BUML.metamodel.object import *\nimport datetime\n\n#############################################\n#   Team Player - structural model definition   #\n#############################################\n\n# Primitive DataTypes\nt_int: PrimitiveDataType = PrimitiveDataType(\"int\")\nt_str: PrimitiveDataType = PrimitiveDataType(\"str\")\nt_date: PrimitiveDataType = PrimitiveDataType(\"date\")\n\n# Team attributes definition\nteam_name: Property = Property(name=\"name\", type=t_str)\nteam_city: Property = Property(name=\"city\", type=t_str)\nteam_division: Property = Property(name=\"division\", type=t_str)\n# Team class definition\nteam: Class = Class (name=\"team\", attributes={team_name,team_city,team_division})\n\n# Player attributes definition\nname: Property = Property(name=\"name\", type=t_str)\nage: Property = Property(name=\"age\", type=t_int)\nposition: Property = Property(name=\"position\", type=t_str)\njerseyNumber: Property = Property(name=\"jerseyNumber\", type=t_int)\n\n# Player class definition\nplayer: Class = Class (name=\"player\", attributes={name, age, position,jerseyNumber})\n\n\n# team-player association definition\nhasteam: Property = Property(name=\"many\",type=team, multiplicity=Multiplicity(1, 1))\nmany: Property = Property(name=\"has\", type=player, multiplicity=Multiplicity(0, \"*\"))\nteam_player_association: BinaryAssociation = BinaryAssociation(name=\"team_player_asso\", ends={hasteam, many})\n\n\nconstraintPlayerAge: Constraint = Constraint(name = \"playerAge\",context=player,expression=\"context player inv inv1: self.age > 10\",language=\"OCL\")\n\nconstraintTeamCenter: Constraint = Constraint(name = \"teamCenter\",context=team,expression=\"context team inv inv2: self.many -> collect(p:player| p.position = 'center')->size()<3\",language=\"OCL\")\n\nconstraintTeamOtherPlayers: Constraint = Constraint(name = \"teamCenterPlayer\",context=team,expression=\"context team inv inv2: self.many -> select(p:player| p.position = 'center')->size()>0\",language=\"OCL\")\n\n\n# Domain model definition\nteam_player_model : DomainModel = DomainModel(name=\"Team-Player model\", types={team,player},\n                                          associations={team_player_association },\n                                          constraints={\n                                          constraintPlayerAge,\n                                          constraintTeamCenter,\nconstraintTeamOtherPlayers,\n                                          }\n                                          )\n\n\n#########################################\n#   TeamPlayer -  object model definition   #\n#########################################\n\n\n# Team  object attributes\nteamObjectName: AttributeLink = AttributeLink(attribute=team_name, value=DataValue(classifier=t_str, value=\"test-3\"))\nteamcity: AttributeLink = AttributeLink(attribute=team_city, value=DataValue(classifier=t_str, value=\"not important\"))\nteamDivision: AttributeLink = AttributeLink(attribute=team_division, value=DataValue(classifier=t_str, value=\"junior\"))\n# Team  object\nteamObject: Object = Object(name=\"team  object\", classifier=team, slots=[teamObjectName,teamcity,teamDivision])\n\n# player  object attributes\nplayer1_obj_name: AttributeLink = AttributeLink(attribute=name, value=DataValue(classifier=t_str, value=\"test\"))\nplayer1_obj_age: AttributeLink = AttributeLink(attribute=age, value=DataValue(classifier=t_int, value=12))\nplayer1_obj_position: AttributeLink = AttributeLink(attribute=position, value=DataValue(classifier=t_str, value=\"center\"))\nplayer1_obj_JN: AttributeLink = AttributeLink(attribute=jerseyNumber, value=DataValue(classifier=t_int, value=10))\n\n# Player  object\nplayer_1_obj: Object = Object(name=\"playerTest1\", classifier=player, slots=[player1_obj_name, player1_obj_age,player1_obj_position,player1_obj_JN])\n\n\n# player 2  object attributes\nplayer2_obj_name: AttributeLink = AttributeLink(attribute=name, value=DataValue(classifier=t_str, value=\"test-2\"))\nplayer2_obj_age: AttributeLink = AttributeLink(attribute=age, value=DataValue(classifier=t_int, value=15))\nplayer2_obj_position: AttributeLink = AttributeLink(attribute=position, value=DataValue(classifier=t_str, value=\"center\"))\nplayer2_obj_JN: AttributeLink = AttributeLink(attribute=jerseyNumber, value=DataValue(classifier=t_int, value=11))\n\n# Player  object\nplayer_2_obj: Object = Object(name=\"playerTest2\", classifier=player, slots=[player2_obj_name, player2_obj_age,player2_obj_position,player2_obj_JN])\n\n# player1 team  object link\nplayer_1_link_end: LinkEnd = LinkEnd(name=\"many\", association_end=hasteam, object=player_1_obj)\nteam_1_link_end: LinkEnd = LinkEnd(name=\"has\", association_end=many, object=teamObject)\nteam_player_link_1: Link = Link(name=\"team_player_link_1\", association=team_player_association, connections=[player_1_link_end,team_1_link_end])\n\n# player2 team  object link\nplayer_2_link_end: LinkEnd = LinkEnd(name=\"many\", association_end=hasteam, object=player_2_obj)\nteam_2_link_end: LinkEnd = LinkEnd(name=\"has\", association_end=many, object=teamObject)\nteam_player_link_2: Link = Link(name=\"team_player_link_2\", association=team_player_association, connections=[player_2_link_end,team_2_link_end])\n\n# Object model definition\nobject_model: ObjectModel = ObjectModel(name=\"Object model\", instances={teamObject, player_1_obj,player_2_obj}, links={team_player_link_1,team_player_link_2})"}
{"type": "source_file", "path": "models/researcher_object.py", "content": "from besser.BUML.metamodel.structural import *\nfrom besser.BUML.metamodel.object import *\n\n#########################################\n#           Structural Model            #\n#########################################\n\n# Primitive DataTypes\nt_int: PrimitiveDataType = PrimitiveDataType(\"int\")\nt_str: PrimitiveDataType = PrimitiveDataType(\"str\")\nt_bool: PrimitiveDataType = PrimitiveDataType(\"bool\")\n\n# Paper class\ntittle: Property = Property(name=\"tittle\", type=t_str)\nwordCount: Property = Property(name=\"wordcount\", type=t_int)\nstudentPaper: Property = Property(name=\"studentPaper\", type=t_bool)\npaper: Class = Class(name=\"Paper\", attributes={tittle, wordCount, studentPaper})\n\n# Researcher class\nname: Property = Property(name=\"name\", type=t_str)\nisStudent: Property = Property(name=\"isStudent\", type=t_bool)\nresearcher: Class = Class(name=\"Researcher\", attributes={name, isStudent})\n\n# paper-researcher association\nmanuscript: Property = Property(name=\"manuscript\", type=paper, multiplicity=Multiplicity(1, 1))\nauthor: Property = Property(name=\"author\", type=researcher, multiplicity=Multiplicity(1, 2))\nwrites: BinaryAssociation = BinaryAssociation(name=\"writes\", ends={manuscript, author})\n\n# researcher-paper association\nsubmission: Property = Property(name=\"submission\", type=paper, multiplicity=Multiplicity(1, 1))\nreferee: Property = Property(name=\"referee\", type=researcher, multiplicity=Multiplicity(3, 3))\nreviews: BinaryAssociation = BinaryAssociation(name=\"reviews\", ends={submission, referee})\n\nconstraintResearcher: Constraint = Constraint(name=\"NoSelfReviews\", context=researcher,\n                                               expression=\"context Researcher inv NoSelfReviews: self.submission->excludes(self.manuscript)\", language=\"OCL\")\n\nconstraintPaper: Constraint = Constraint(name=\"PaperLength\", context=paper,\n                                               expression=\"context Paper inv :self.wordcount < 10000\", language=\"OCL\")\n\nconstraintAuthorsOfStudentPaper: Constraint = Constraint(name=\"AuthorsOfStudentPaper\", context=paper,\n                                               expression=\"context Paper inv AuthorsOfStudentPaper: self.author->exists(x:Researcher | x.isStudent =True)\", language=\"OCL\")\n\nconstraintNoStudentReviewers: Constraint = Constraint(name=\"NoStudentReviewers\", context=paper,\n                                               expression=\"context Paper inv NoStudentReviewers:self.referee->forAll(r:Researcher | r.isStudent =False)\", language=\"OCL\")\n\nconstraintLimitsOnStudentPapers: Constraint = Constraint(name=\"LimitsOnStudentPapers\", context=paper,\n                                               expression=\"context Paper inv LimitsOnStudentPapers: Paper::allInstances()->exists(p:Paper | p.studentPaper = True) and Paper::allInstances()->select(p:Paper | p.studentPaper=True) ->size() < 5\", language=\"OCL\")\n\nconstraintPaperTitle: Constraint = Constraint(name=\"constraintPaperTitle\", context=paper,\n                                               expression=\"context Paper inv title: self.tittle<> 'test'\", language=\"OCL\")\nconstraintResearcherName:Constraint = Constraint(name=\"consResearcherName\", context=researcher,\n                                               expression=\"context Researcher inv title: self.name<> 'test'\", language=\"OCL\")\n\nconstraintPaperWordCountgreater: Constraint = Constraint(name=\"PaperLength100\", context=paper,\n                                               expression=\"context Paper inv :self.wordcount > 1000\", language=\"OCL\")\n\n\n# Structural model\ndomain_model: DomainModel = DomainModel(name=\"my_model\", types={paper, researcher}, associations={writes, reviews}, constraints = {\n                                                                                                                    constraintResearcher,\n                                                                                                                    constraintPaper,\n                                                                                                                    constraintAuthorsOfStudentPaper,\n                                                                                                                    constraintNoStudentReviewers,\n                                                                                                                    constraintLimitsOnStudentPapers,\n                                                                                                                    constraintPaperTitle,\n                                                                                                                    constraintResearcherName,\n                                                                                                                    constraintPaperWordCountgreater\n                                                                                                                                   })\n\n\n###################################\n#          Object model           #\n###################################\n\n# paper  object\npaper_name: AttributeLink = AttributeLink(value=DataValue(value=\"besser lowcode platform\", classifier=None), attribute=tittle)\npaper_words: AttributeLink = AttributeLink(value=DataValue(value=5000, classifier=None), attribute=wordCount)\npaper_student_paper: AttributeLink = AttributeLink(value=DataValue(value=True, classifier=None), attribute=studentPaper)\npaper_obj: Object = Object(name=\"besser paper\", classifier=paper, slots=[paper_name, paper_words, paper_student_paper])\n\n# researcher 1  object\nr1_name: AttributeLink = AttributeLink(value=DataValue(value=\"Marc\", classifier=None), attribute=name)\nr1_is_student: AttributeLink = AttributeLink(value=DataValue(value=True, classifier=None), attribute=isStudent)\nresearcher_1: Object = Object(name=\"Marc researcher\", classifier=researcher, slots=[r1_name, r1_is_student])\n\n# researcher 2  object\nr2_name: AttributeLink = AttributeLink(value=DataValue(value=\"James\", classifier=None), attribute=name)\nr2_is_student: AttributeLink = AttributeLink(value=DataValue(value=True, classifier=None), attribute=isStudent)\nresearcher_2: Object = Object(name=\"James researcher\", classifier=researcher, slots=[r2_name, r2_is_student])\n\n# researcher 3  object\nr3_name: AttributeLink = AttributeLink(value=DataValue(value=\"Adam\", classifier=None), attribute=name)\nr3_is_student: AttributeLink = AttributeLink(value=DataValue(value=False, classifier=None), attribute=isStudent)\nresearcher_3: Object = Object(name=\"Adam researcher\", classifier=researcher, slots=[r3_name, r3_is_student])\n\n# researcher 4  object\nr4_name: AttributeLink = AttributeLink(value=DataValue(value=\"Lola\", classifier=None), attribute=name)\nr4_is_student: AttributeLink = AttributeLink(value=DataValue(value=False, classifier=None), attribute=isStudent)\nresearcher_4: Object = Object(name=\"Lola researcher\", classifier=researcher, slots=[r4_name, r4_is_student])\n\n# researcher 5  object\nr5_name: AttributeLink = AttributeLink(value=DataValue(value=\"Sarah\", classifier=None), attribute=name)\nr5_is_student: AttributeLink = AttributeLink(value=DataValue(value=False, classifier=None), attribute=isStudent)\nresearcher_5: Object = Object(name=\"Sarah researcher\", classifier=researcher, slots=[r5_name, r5_is_student])\n\n# Links definition\nwrites_1: Link = Link(name=\"writes\", association=writes, connections=[\n    LinkEnd(name=\"manuscript\", association_end=manuscript, object=paper_obj),\n    LinkEnd(name=\"author\", association_end=author, object=researcher_1)\n])\n\nwrites_2: Link = Link(name=\"writes\", association=writes, connections=[\n    LinkEnd(name=\"researcher\", association_end=manuscript, object=paper_obj),\n    LinkEnd(name=\"author\", association_end=author, object=researcher_2)\n])\n\nreviews_1: Link = Link(name=\"writes\", association=writes, connections=[\n    LinkEnd(name=\"submission\", association_end=submission, object=paper_obj),\n    LinkEnd(name=\"referee\", association_end=referee, object=researcher_3)\n])\n\nreviews_2: Link = Link(name=\"writes\", association=writes, connections=[\n    LinkEnd(name=\"submission\", association_end=submission, object=paper_obj),\n    LinkEnd(name=\"referee\", association_end=referee, object=researcher_4)\n])\n\nreviews_3: Link = Link(name=\"writes\", association=writes, connections=[\n    LinkEnd(name=\"submission\", association_end=submission, object=paper_obj),\n    LinkEnd(name=\"referee\", association_end=referee, object=researcher_5)\n])\n\n\n\n#  object model\nobject_model: ObjectModel = ObjectModel(name=\"Object_model\", instances={paper_obj, researcher_1, researcher_2, researcher_3, researcher_4, researcher_5},\n                                        links={writes_1, writes_2, reviews_1, reviews_2, reviews_3})"}
{"type": "source_file", "path": "bocl/evaluator.py", "content": "\"\"\"Importing OCL from main BESSER repository\"\"\"\nfrom besser.BUML.metamodel.ocl.ocl import *\nfrom besser.BUML.metamodel.structural.structural import Property\n\n\nclass Evaluator:\n    \"\"\"The Evaluator class evaluates the OCL constraints based on the object model.\n\n    Args:\n\n    Attributes:\n            debug = this attribute is used for debugging purposes and with default value false\n            allObjSat = list of all objects that satisfy the contraint\n    \"\"\"\n\n    def __init__(self):\n        self.debug = False\n        self.all_obj_sat = []\n        self.om = None\n        self.root_handler = None\n\n    def get_value(self, name, obj):\n        \"\"\"The get_value function to retrieve value of attribute from class_object.\n\n            Args:\n                        name: name of the attribute\n                        obj: Object from object model\n            \"\"\"\n        for slot in obj.slots:\n            if name == slot.attribute.name:\n                if slot.attribute.type.name == 'str':\n                    return '\"' + slot.value.value + '\"'\n                if slot.attribute.type.name == 'date':\n                    return int(str(slot.value.value.year)+ str(slot.value.value.month) + str(slot.value.value.day))\n                return slot.value.value\n        return None\n\n    def check_in_obj(self, obj, source):\n        \"\"\"The check_in_obj function identifies the class_object that contains the source in slots.\n\n        Args:\n            obj: Object from object model\n            source: source of the current object in the CSTree\n        \"\"\"\n        for s in obj.slots:\n            if s.attribute.name == source.name:\n                return obj\n        return None\n\n    def check_in_link_ends(self, obj, source):\n        \"\"\"The check_in_link_ends function identifies the source in the linkend of the object.\n\n        Args:\n            obj: Object from object model\n            source: source of the current object in the CSTree\n        \"\"\"\n        to_ret = []\n        for link in obj.links:\n            for connection in link.connections:\n                if connection.association_end.name == source.name:\n                    to_ret.append(connection.object)\n\n        return to_ret\n\n    def handle_for_all(self, tree, all_objs, logical_exp):\n        \"\"\"The handle_for_all function handles forAll expression from OCL MM.\n\n        Args:\n                    tree: Tree that is constructed using OCL Parser\n                    all_objs: all objects from object model\n                    logical_exp: Expression to evaluate at the end to get the result\n        \"\"\"\n        logical_exp[0] = logical_exp[0] + \" (\"\n        for index in range(len(all_objs)):\n            if len(tree.get_body) > 0:\n                self.update_logical_exp(tree.get_body[0], logical_exp, all_objs[index])\n                if index < len(all_objs) - 1:\n                    logical_exp[0] = logical_exp[0] + \" and \"\n        logical_exp[0] = logical_exp[0] + \" )\"\n\n    def handle(self, source, obj, logical_exp, right_side=False):\n        \"\"\"The handle function handles Property Call expression from OCL MM.\n\n        Args:\n                    source: one child in OCL CST\n                    obj: one object from object model\n                    logical_exp: Expression to evaluate at the end to get the result\n                    right_side: to identify the side of logical expression\n        \"\"\"\n\n        if isinstance(source, (PropertyCallExpression,Property)):\n            # if len(source.name.split('.'))==2:\n            all_objs = self.check_in_obj(obj, source)\n            if all_objs is None:\n                all_objs = self.check_in_link_ends(obj, source)\n            for index in range(len(all_objs)):\n                objs = all_objs[index]\n                if len(all_objs) > 1 or right_side:\n                    logical_exp[0] = logical_exp[0] + \" [ \"\n                for i in range(len(objs.slots)):\n                    logical_exp[0] = logical_exp[0] + \"\\\"\" + str(objs.slots[i].attribute.name) + str(\n                        objs.slots[i].value.value) + \"\\\"\"\n                    if i < len(objs.slots) - 1:\n                        logical_exp[0] = logical_exp[0] + \",\"\n                if not right_side:\n                    if len(all_objs) > 1 and index < len(all_objs) - 1:\n                        logical_exp[0] = logical_exp[0] + \" ], \"\n                else:\n                    logical_exp[0] = logical_exp[0] + \" ] \"\n                    if len(all_objs) > 1 and index < len(all_objs) - 1:\n                        logical_exp[0] = logical_exp[0] + \" , \"\n\n\n\n\n    def handle_excludes(self, tree, obj, logical_exp):\n        \"\"\"The handle_excludes function handles excludes construct.\n\n        Args:\n                    tree: Tree that is constructed using OCL Parser\n                    obj: one object from object model\n                    logical_exp: Expression to evaluate at the end to get the result\n        \"\"\"\n        # tempLogicalExp =[\"\"]\n        args = tree.arguments\n        self.check_and_add(logical_exp, \" and \")\n        logical_exp[0] = logical_exp[0] + \" [ \"\n        self.handle(tree.source, obj, logical_exp)\n        logical_exp[0] = logical_exp[0] + \" ] not in \"\n        if len(args) == 1:  # Property\n            logical_exp[0] = logical_exp[0] + \" [ \"\n            self.handle(args[0], obj, logical_exp, True)\n            logical_exp[0] = logical_exp[0] + \" ]\"\n\n\n    def handle_includes(self, tree, obj, logical_exp):\n        \"\"\"The handle_includes function handles includes construct.\n\n        Args:\n                    tree: Tree that is constructed using OCL Parser\n                    obj: one object from object model\n                    logical_exp: Expression to evaluate at the end to get the result\n        \"\"\"\n\n        # tempLogicalExp =[\"\"]\n        args = tree.arguments\n        self.check_and_add(logical_exp, \" and \")\n        logical_exp[0] = logical_exp[0] + \" [ \"\n        self.handle(tree.source, obj, logical_exp)\n        logical_exp[0] = logical_exp[0] + \" ] in \"\n        if len(args) == 1:  # Property\n            logical_exp[0] = logical_exp[0] + \" [ \"\n            self.handle(args[0], obj, logical_exp, True)\n            logical_exp[0] = logical_exp[0] + \" ]\"\n\n\n    def handle_exists(self, tree, all_objs, logical_exp):\n        \"\"\"The handle_exists function handles exists construct.\n\n        Args:\n            tree: Tree that is constructed using OCL Parser\n            all_objs: all objects from object model\n            logical_exp: Expression to evaluate at the end to get the result\n        \"\"\"\n        logical_exp[0] = logical_exp[0] + \" ( \"\n        temp = logical_exp[0]\n        for index in range(len(all_objs)):\n            if len(tree.get_body) > 0:\n                self.update_logical_exp(tree.get_body[0], logical_exp, all_objs[index])\n                if index < len(all_objs) - 1:\n                    logical_exp[0] = logical_exp[0] + \" or \"\n        if temp == logical_exp[0]:\n            logical_exp[0] = logical_exp[0] + \" False \"\n\n        logical_exp[0] = logical_exp[0] + \" )\"\n\n    def handle_select(self, tree, all_objs):\n        \"\"\"The handle_select function handles select construct.\n\n        Args:\n               tree: Tree that is constructed using OCL Parser\n               all_objs: all objects from object model\n        \"\"\"\n        self.all_obj_sat.append([])\n        for obj in all_objs:\n            expression = [\"\"]\n            if len(tree.get_body) > 0:\n                self.update_logical_exp(tree.get_body[0], expression, obj)\n                self.preprocess_logical_exp(expression)\n                if eval(expression[0]) is True:\n                    self.all_obj_sat[-1].append(obj)\n    def handle_reject(self, tree, all_objs):\n        \"\"\"The handle_reject function handles reject construct.\n\n        Args:\n               tree: Tree that is constructed using OCL Parser\n               all_objs: all objects from object model\n        \"\"\"\n        self.all_obj_sat.append([])\n        for obj in all_objs:\n            expression = [\"\"]\n            if len(tree.get_body) > 0:\n                self.update_logical_exp(tree.get_body[0], expression, obj)\n                self.preprocess_logical_exp(expression)\n                if eval(expression[0]) is False:\n                    self.all_obj_sat[-1].append(obj)\n\n\n    def handle_collect(self, tree, all_objs):\n        \"\"\"The handle_collect function handles collect construct.\n\n        Args:\n               tree: Tree that is constructed using OCL Parser\n               all_objs: all objects from object model\n        \"\"\"\n        self.all_obj_sat.append([])\n        for obj in all_objs:\n            expression = [\"\"]\n            if len(tree.get_body) > 0:\n                self.update_logical_exp(tree.get_body[0], expression, obj)\n                self.preprocess_logical_exp(expression)\n                if eval(expression[0]) is True:\n                    self.all_obj_sat[-1].append(obj)\n\n    def verify_body(self, tree, obj, logical_exp, source, all_objs = None):\n        \"\"\"The verify_body function verifies the body of different\n         constructs (e.g., forAll, exists).\n\n        Args:\n            tree: Tree that is constructed using OCL Parser\n            obj: one object from object model\n            logical_exp: Expression to evaluate at the end to get the result\n            source: source of the obj in CSTree\n        \"\"\"\n        expression_type = tree.name\n        if all_objs is None:\n            all_objs = self.check_in_obj(obj, source)\n            if all_objs is None:\n                all_objs = self.check_in_link_ends(obj, source)\n        if source.name == \"ALLInstances\":\n            class_name = source.source.name\n            all_objs = self.get_valid_objects(class_name, self.om)\n\n        if expression_type == \"forAll\":\n            self.handle_for_all(tree, all_objs, logical_exp)\n        elif expression_type == \"exists\":\n            self.handle_exists(tree, all_objs, logical_exp)\n        elif expression_type == \"collect\":\n            self.handle_collect(tree, all_objs)\n        elif expression_type == \"select\":\n            self.handle_select(tree, all_objs)\n        elif expression_type == \"reject\":\n            self.handle_reject(tree, all_objs)\n\n\n\n    def get_id(self, slots):\n        \"\"\"The get_id function gets the ID attribute from the Object.\n\n        Args:\n                    slots: slots of the object\n        \"\"\"\n        for s in slots:\n            if s.get_attribute.is_id:\n                return s\n        return None\n\n    def add_to_exp(self, item, logical_exp):\n        \"\"\"The add_to_exp function adds the item to logicalExpression.\n\n        Args:\n              item: item to add in Logical Expression\n              logical_exp: logical Expression\n        \"\"\"\n        if logical_exp[0] == \"\":\n            logical_exp[0] = logical_exp[0] + item\n        else:\n            logical_exp[0] = logical_exp[0] + \" and \" + item\n\n    def handle_size(self, tree, obj, logical_exp):\n        \"\"\"The handle_size function handles the size construct.\n\n        Args:\n                    tree: Tree that is constructed using OCL Parser\n                    obj: one object from object model\n                    logical_exp: Expression to evaluate at the end to get the result\n        \"\"\"\n        self.check_and_add(logical_exp, \" and \")\n        logical_exp[0] = logical_exp[0] + \"(\"\n        if isinstance(tree.source, Property):\n            all_objs = self.check_in_obj(obj, tree.source)\n            if all_objs is None:\n                all_objs = self.check_in_link_ends(obj, tree.source)\n            logical_exp[0] = logical_exp[0] + str(len(all_objs))\n            for arg in tree.arguments:\n                if isinstance(arg, (IntegerLiteralExpression, RealLiteralExpression, BooleanLiteralExpression)):\n                    logical_exp[0] = logical_exp[0] + str(arg.value)\n                else:\n                    logical_exp[0] = logical_exp[0] + str(arg)\n        elif isinstance(tree.source, LoopExp):\n            source = None\n            if tree.source.source is not None:\n                source = tree.source.source\n            if source is not None and source.name == \"ALLInstances\":\n                class_name = source.source.name\n                all_objs = self.get_valid_objects(class_name, self.om)\n            else:\n                all_objs = self.check_in_obj(obj, source)\n                if all_objs is None:\n                    all_objs = self.check_in_link_ends(obj, source)\n            self.handle_collect(tree.source, all_objs)\n            if len(self.all_obj_sat) > 0:\n                logical_exp[0] = logical_exp[0] + str(len(self.all_obj_sat[-1]))\n                self.all_obj_sat.pop()\n            for arg in tree.arguments:\n\n                if isinstance(arg, (IntegerLiteralExpression,RealLiteralExpression,BooleanLiteralExpression)):\n                    logical_exp[0] = logical_exp[0] + str(arg.value)\n                else:\n                    logical_exp[0] = logical_exp[0] + str(arg)\n        logical_exp[0] = logical_exp[0] + \")\"\n\n    def handle_if_exp(self, tree, obj, logical_exp):\n        \"\"\"The handle_if_exp function handles the If construct.\n\n        Args:\n                    tree: Tree that is constructed using OCL Parser\n                    obj: one object from object model\n                    logical_exp: Expression to evaluate at the end to get the result\n        \"\"\"\n\n        temp_exp = [\"\"]\n        self.update_logical_exp(tree.ifCondition, temp_exp, obj)\n        self.preprocess_logical_exp(temp_exp)\n        self.check_and_add(logical_exp, \" and \")\n        if eval(temp_exp[0]) is True:\n            self.update_logical_exp(tree.thenExpression, logical_exp, obj)\n        else:\n            self.update_logical_exp(tree.elseCondition, logical_exp, obj)\n\n\n\n    def handle_ocl_is_type_of(self, tree,  logical_exp):\n        \"\"\"The handle_ocl_is_type_of function handles the OCLIsTypeOf construct.\n\n        Args:\n                tree: Tree that is constructed using OCL Parser\n                obj: one object from object model\n                logical_exp: Expression to evaluate at the end to get the result\n        \"\"\"\n        if isinstance(tree.source, Property):\n            source_type = tree.source.type.name\n            self.check_and_add(logical_exp, \" and \")\n            for index in range(len(tree.arguments)):\n                arg = tree.arguments[index].name\n                if arg == \"String\":\n                    logical_exp[0] = logical_exp[0] + '\\\"' + source_type + '\\\"' + \" =  \\\"str\\\"\"\n                elif arg == \"Integer\":\n                    logical_exp[0] = logical_exp[0] + '\\\"' + source_type + '\\\"' + \" =  \\\"int\\\"\"\n                elif arg == \"Boolean\":\n                    logical_exp[0] = logical_exp[0] + '\\\"' + source_type + '\\\"' + \" =  \\\"bool\\\"\"\n                elif arg == \"Real\":\n                    logical_exp[0] = logical_exp[0] + '\\\"' + source_type + '\\\"' + \" =  \\\"float\\\"\"\n                if index > 0 and index < len(tree.arguments) - 1:\n                    self.check_and_add(logical_exp, \"and\")\n    def handle_date_literal_expression(self,date):\n        from datetime import datetime,timedelta\n        now = datetime.now()\n        if \"addDays\" in str(date):\n            days = str(date).split(\"addDays\")[1].replace(\")\",\"\").replace(\"(\",\"\")\n            now= now+timedelta(days = int(days))\n\n        if \"today\" in str(date):\n            date_time = int(now.strftime(\"%Y%m%d\"))\n            return str(date_time)\n\n\n    def update_logical_exp(self, tree, logical_exp, obj):\n        \"\"\"The update_logical_exp function updates the logical expression.\n\n        Args:\n                        tree: Tree that is constructed using OCL Parser\n                        obj: one object from object model\n                        logical_exp: Expression to evaluate at the end to get the result\n        \"\"\"\n\n        if isinstance(tree, PropertyCallExpression):\n            if tree.source is None:\n                pass\n\n        if isinstance(tree, LoopExp):  # forAll, select,..etc\n            source = tree.source\n            if obj.classifier.name == self.root_handler.get_context_name():\n                self.verify_body(tree, obj, logical_exp, source)\n        if isinstance(tree, IfExp):\n            self.handle_if_exp(tree, obj, logical_exp)\n        if isinstance(tree, OperationCallExpression):\n\n            if tree.name == \"EXCLUDES\":\n                self.handle_excludes(tree, obj, logical_exp)\n            elif tree.name == \"INCLUDES\":\n                self.handle_includes(tree, obj, logical_exp)\n            elif tree.name == \"Size\":\n                self.handle_size(tree, obj, logical_exp)\n                self.check_and_add(logical_exp, \" and \")\n            elif tree.name == \"OCLISTYPEOF\":\n                self.handle_ocl_is_type_of(tree,  logical_exp)\n            elif tree.name == \"ALLInstances\":\n                pass  # handled elsewhere\n            else:\n                args = tree.arguments\n                for arg in args:\n                    if hasattr(arg, 'name'):\n                        if isinstance(arg, (IntegerLiteralExpression, RealLiteralExpression, BooleanLiteralExpression)):\n                            logical_exp[0] = logical_exp[0] + str(arg.value)\n                        elif isinstance(arg, StringLiteralExpression):\n                            logical_exp[0] = logical_exp[0] + '\"' + str(arg.value) + '\"'\n                        elif isinstance(arg, DateLiteralExpression):\n                            logical_exp[0] = logical_exp[0] + self.handle_date_literal_expression(arg)\n\n                        else:\n                            logical_exp[0] = logical_exp[0] + str(self.get_value(arg.name, obj))\n                    else:\n                        if str(arg).lower() == \"and\" or str(arg).lower() == 'or':\n                            self.check_and_add(logical_exp[0], str(arg))\n                        else:\n                            logical_exp[0] = logical_exp[0] + \" \" + str(arg) + \" \"\n                if tree.referredOperation is not None and (\n                        tree.referredOperation.get_infix_operator() == \"and\" or tree.referredOperation.get_infix_operator() == \"or\"):\n                    self.check_and_add(logical_exp[0], tree.referredOperation.get_infix_operator())\n        if hasattr(tree, \"source\"):\n            if tree.source is not None:\n                self.update_logical_exp(tree.source, logical_exp, obj)\n\n    def check_and_add(self, logical_exp_template, to_add):\n        \"\"\"The check_and_add function checks and updates the logical expression.\n\n        Args:\n                to_add: item to add in the logical expression\n                logical_exp_template: Expression to evaluate at the end to get the result\n        \"\"\"\n        if len(logical_exp_template[0]) > 5:\n            if to_add == \" and \":\n                if logical_exp_template[0][-5:] != \" and \":\n                    logical_exp_template[0] = logical_exp_template[0] + to_add\n        elif to_add == \" and \":\n            if len(logical_exp_template[0]) > 0 and len(logical_exp_template[0]) <= 5:\n                logical_exp_template[0] = logical_exp_template[0] + to_add\n\n        if len(logical_exp_template[0]) > 4:\n            if to_add == \" or \":\n                if logical_exp_template[0][-4:] != \" or \":\n                    logical_exp_template[0] = logical_exp_template[0] + to_add\n\n    def valid_object(self, context_name, class_object):\n        \"\"\"the valid_object verifies if the current object is the one constraint is applied on\n\n        Args:\n            context_name: name of the context of OCL constraint\n            class_object: Object from object model to check\n\n        \"\"\"\n        id_slot = self.get_id(class_object.slots)\n        if id_slot.get_attribute.name == context_name:\n            return True\n        return False\n\n    def get_valid_objects(self, context_name, objs):\n        \"\"\"the get_valid_objects returns all the objects the constraint should be applied on\n\n        Args:\n            context_name: name of the context of OCL constraint\n            objs: all objects from object model\n\n        \"\"\"\n\n        to_ret = []\n        for obj in objs.instances:\n            # if self.valid_object(context_name,obj):\n            if obj.classifier.name == context_name:\n                to_ret.append(obj)\n        return to_ret\n\n    def preprocess_logical_exp(self, exp):\n        \"\"\"the preprocess_logical_exp function preprocesses before evaluating to correct the syntax.\n\n        Args:\n            exp: logical expression to be evaluated\n\n        \"\"\"\n        exp[0] = exp[0].replace(' = ', ' == ').replace('<>', ' != ')\n        if len(exp[0]) > 5:\n            if exp[0][-5:] == \" and \":\n                exp[0] = exp[0][:-5]\n        if len(exp[0]) > 4:\n            if exp[0][-4:] == \" or \":\n                exp[0] = exp[0][:-4]\n\n    def evaluate(self, root_handler, object_model):\n        \"\"\"the evaluate function is the main function to be called for evaluating any contraint.\n\n        Args:\n            root_handler: Object of class RootHandler that handles the tree\n            object_model: Object Model from BUML models\n        \"\"\"\n        self.om = object_model\n        self.root_handler = root_handler\n\n        objs = self.get_valid_objects(self.root_handler.get_context_name(), self.om)\n        tree = root_handler.get_root()\n        logical_exp_template = [\"\"]\n        for i in range(len(objs)):\n            self.update_logical_exp(tree, logical_exp_template, objs[i])\n            if len(objs) > 1 and i < len(objs) - 1:\n                self.check_and_add(logical_exp_template, \" and \")\n\n        if self.debug:\n            print(\"Logical Expression\")\n            print(logical_exp_template[0])\n        self.preprocess_logical_exp(logical_exp_template)\n        return eval(logical_exp_template[0])\n"}

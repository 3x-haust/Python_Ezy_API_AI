{"repo_info": {"repo_name": "guane-intern-fastapi", "repo_owner": "jearistiz", "repo_url": "https://github.com/jearistiz/guane-intern-fastapi"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/app/api/routers/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/app/api/routers/test_dogs.py", "content": "from typing import Dict\nfrom fastapi.testclient import TestClient\n\nfrom app.config import sttgs\nfrom mock_data.db_test_data import dogs_mock_dicts, adopted_dogs_dicts\nfrom tests.utils.handle_db_test import HandleDBTest\n\n\nclass TestDogsRouter(HandleDBTest):\n\n    dogs_api_prefix = sttgs.get('API_PREFIX') + sttgs.get('DOGS_API_PREFIX')\n\n    def dogs_name_route(self, name):\n        return self.dogs_api_prefix + '/' + name\n\n    def assert_dogs_data(self, *, reference: dict, compare: dict):\n        assert compare['name'] == reference['name']\n        assert 'create_date' in compare\n        assert 'id' in compare\n        assert 'picture' in compare\n        assert 'is_adopted' in compare\n        assert 'id_user' in compare\n\n    def test_get_dogs(self, app_client: TestClient) -> None:\n        response = app_client.get(self.dogs_api_prefix)\n        assert response.status_code == 200\n        content = response.json()\n        assert isinstance(content['dogs'], list)\n        dogs = content['dogs']\n        dogs_names = [ref_dog['name'] for ref_dog in dogs_mock_dicts]\n        for dog in dogs:\n            assert dog['name'] in dogs_names\n\n    def test_get_dogs_is_adopted(self, app_client: TestClient) -> None:\n        get_dogs_is_adopted_route = self.dogs_api_prefix + '/is_adopted'\n        response = app_client.get(get_dogs_is_adopted_route)\n        assert response.status_code == 200\n        content = response.json()\n        assert isinstance(content['adopted_dogs'], list)\n        dogs = content['adopted_dogs']\n        adopted_dogs_names = [\n            ref_dog['name'] for ref_dog in adopted_dogs_dicts\n        ]\n        for dog in dogs:\n            assert dog['is_adopted'] is True\n            assert dog['name'] in adopted_dogs_names\n\n    def test_get_dogs_name(self, app_client: TestClient) -> None:\n        data = dogs_mock_dicts[0]\n        get_dogs_name_route = self.dogs_name_route(data.get('name'))\n        response = app_client.get(get_dogs_name_route, json=data)\n        assert response.status_code == 200\n        content = response.json()\n        self.assert_dogs_data(reference=data, compare=content)\n\n    def test_post_dogs_name(\n        self, app_client: TestClient, superuser_token_headers: Dict[str, str]\n    ) -> None:\n        data = dogs_mock_dicts[0].copy()\n        data.update({'name': 'Juan'})\n        data['picture'] = None\n        post_dogs_name_route = self.dogs_name_route(data.get('name'))\n        response = app_client.post(\n            post_dogs_name_route, json=data, headers=superuser_token_headers\n        )\n        assert response.status_code == 201\n        content = response.json()\n        self.assert_dogs_data(reference=data, compare=content)\n\n    def test_put_dogs_name(\n        self, app_client: TestClient, superuser_token_headers: Dict[str, str]\n    ) -> None:\n        data = dogs_mock_dicts[0].copy()\n        old_name = data['name']\n        data.update({'name': 'Juan'})\n        put_dogs_name_route = self.dogs_name_route(old_name)\n        response = app_client.put(\n            put_dogs_name_route, json=data, headers=superuser_token_headers\n        )\n        assert response.status_code == 200\n        content = response.json()\n        self.assert_dogs_data(reference=data, compare=content)\n\n    def test_delete_dogs_name(\n        self, app_client: TestClient, superuser_token_headers: Dict[str, str]\n    ) -> None:\n        data = dogs_mock_dicts[0]\n        get_dogs_name_route = self.dogs_name_route(data.get('name'))\n        response = app_client.delete(\n            get_dogs_name_route, json=data, headers=superuser_token_headers\n        )\n        assert response.status_code == 200\n        content = response.json()\n        self.assert_dogs_data(reference=data, compare=content)\n"}
{"type": "test_file", "path": "tests/app/api/routers/test_security.py", "content": "from typing import Dict\n\nfrom fastapi.testclient import TestClient\n\nfrom app.config import sttgs\n\n\ndef test_post_login_for_access_token(app_client: TestClient) -> Dict[str, str]:\n    login_data = {\n        \"username\": sttgs['FIRST_SUPERUSER'],\n        \"password\": sttgs['FIRST_SUPERUSER_PASSWORD'],\n    }\n    r = app_client.post(f\"{sttgs['TOKEN_URI']}\", data=login_data)\n    tokens = r.json()\n    assert tokens['access_token']\n    assert tokens['token_type']\n"}
{"type": "test_file", "path": "tests/app/api/routers/test_tasks.py", "content": "from typing import Dict\n\nfrom fastapi.testclient import TestClient\n\nfrom tests.utils.uri import task_uri\n\n\ndef assert_post_uri_task(\n    client: TestClient,\n    superuser_token_headers: Dict[str, str],\n    specific_endpoint: str,\n    task_complexity: int,\n    not_async: bool = False\n):\n    response = client.post(\n        task_uri(specific_endpoint, task_complexity),\n        headers=superuser_token_headers\n    )\n    assert response.status_code == 201\n    content = response.json()\n    assert content['task_complexity'] == task_complexity\n    assert content[\"status\"]\n    if not_async:\n        assert content['server_message']\n    else:\n        assert content['server_message'] is None\n    assert content['success'] is True\n\n\ndef test_celery_task(\n    app_client: TestClient,\n    superuser_token_headers: Dict[str, str]\n):\n    assert_post_uri_task(\n        app_client, superuser_token_headers,\n        specific_endpoint='/celery_task',\n        task_complexity=0,\n    )\n\n\ndef test_celery_task_not_async(\n    app_client: TestClient,\n    superuser_token_headers: Dict[str, str]\n):\n    assert_post_uri_task(\n        app_client, superuser_token_headers,\n        task_complexity=0,\n        specific_endpoint='/celery_task_not_async',\n        not_async=True,\n    )\n"}
{"type": "test_file", "path": "tests/app/api/routers/test_upload_file.py", "content": "from typing import Dict\n\nfrom fastapi.testclient import TestClient\n\nfrom app.config import sttgs\n\n\nupload_file_uri = (\n    sttgs.get('API_PREFIX') + sttgs.get('UPLOAD_API_PREFIX') + '/file-to-guane'\n)\n\n\ndef test_post_file_to_guane(\n    app_client: TestClient,\n    superuser_token_headers: Dict[str, str]\n):\n    response = app_client.post(\n        upload_file_uri,\n        headers=superuser_token_headers\n    )\n    assert response.status_code == 201\n    content = response.json()\n    assert content['success'] is True\n    assert content['remote_server_status_code'] == 201\n    assert 'filename' in content['remote_server_response']\n"}
{"type": "test_file", "path": "tests/app/api/routers/test_users.py", "content": "from typing import Dict\n\nfrom fastapi.testclient import TestClient\n\nfrom app.config import sttgs\nfrom mock_data.db_test_data import users_mock_dicts\nfrom tests.utils.handle_db_test import HandleDBTest\n\n\nclass TestUsersRouter(HandleDBTest):\n\n    users_api_prefix = sttgs.get('API_PREFIX') + sttgs.get('USERS_API_PREFIX')\n\n    def users_name_route(self, name):\n        return self.users_api_prefix + '/' + name\n\n    def assert_users_data(self, *, reference: dict, compare: dict):\n        assert compare['name'] == reference['name']\n        assert compare['email'] == reference['email']\n        assert 'create_date' in compare\n        assert 'id' in compare\n\n    def test_get_users(self, app_client: TestClient):\n        response = app_client.get(self.users_api_prefix)\n        assert response.status_code == 200\n        content = response.json()\n        assert isinstance(content['users'], list)\n        users = content['users']\n        user_names = [ref_user['name'] for ref_user in users_mock_dicts]\n        for user in users:\n            assert user['name'] in user_names\n\n    def test_get_users_name(self, app_client: TestClient):\n        data = users_mock_dicts[0]\n        get_users_name_route = self.users_name_route(data.get('name'))\n        response = app_client.get(get_users_name_route, json=data)\n        assert response.status_code == 200\n        content = response.json()\n        self.assert_users_data(reference=data, compare=content)\n\n    def test_post_users_name(\n        self, app_client: TestClient, superuser_token_headers: Dict[str, str]\n    ) -> None:\n        data = users_mock_dicts[0].copy()\n        data.update({'name': 'Juan'})\n        post_users_name_route = self.users_name_route(data.get('name'))\n        response = app_client.post(\n            post_users_name_route, json=data, headers=superuser_token_headers\n        )\n        assert response.status_code == 201\n        content = response.json()\n        self.assert_users_data(reference=data, compare=content)\n\n    def test_put_users_name(\n        self, app_client: TestClient, superuser_token_headers: Dict[str, str]\n    ) -> None:\n        data = users_mock_dicts[0].copy()\n        old_name = data['name']\n        data.update({'name': 'Juan'})\n        post_users_name_route = self.users_name_route(old_name)\n        response = app_client.put(\n            post_users_name_route, json=data, headers=superuser_token_headers\n        )\n        assert response.status_code == 200\n        content = response.json()\n        self.assert_users_data(reference=data, compare=content)\n\n    def test_delete_users_name(\n        self, app_client: TestClient, superuser_token_headers: Dict[str, str]\n    ) -> None:\n        data = users_mock_dicts[0]\n        get_users_name_route = self.users_name_route(data.get('name'))\n        response = app_client.delete(\n            get_users_name_route, json=data, headers=superuser_token_headers\n        )\n        assert response.status_code == 200\n        content = response.json()\n        self.assert_users_data(reference=data, compare=content)\n"}
{"type": "test_file", "path": "tests/app/crud/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/app/crud/test_dog_crud.py", "content": "from sqlalchemy.orm import Session\n\nfrom app import crud\nfrom mock_data.db_test_data import adopted_dogs_dicts\nfrom tests.utils.handle_db_test import HandleDBTest\nfrom tests.utils.parse_dict import update_dict_fmt_item\n\n\nclass TestDogCrud(HandleDBTest):\n    def test_get_adopter(self, db: Session):\n        adopted_dogs_out = crud.dog.get_adopted(db)\n        for adopted_dog_out in adopted_dogs_out:\n            adopted_dog_dict = adopted_dog_out._asdict()\n            adopted_dog_dict.pop('id')\n            update_dict_fmt_item(adopted_dog_dict, 'create_date', str)\n            assert adopted_dog_dict in adopted_dogs_dicts\n"}
{"type": "test_file", "path": "tests/app/crud/test_user_crud.py", "content": "from sqlalchemy.orm import Session\n\nfrom app import crud\nfrom app.models import User\nfrom app.schemas import UserUpdate, UserCreate\nfrom mock_data.db_test_data import users_mock_dicts, users_mock\nfrom tests.utils.handle_db_test import HandleDBTest\nfrom tests.utils.parse_dict import update_dict_fmt_item\n\n\nclass TestUserCrud(HandleDBTest):\n\n    def test_get(self, db: Session):\n        user_out = crud.user.get(db, id=1)\n        user_compare = user_out._asdict()\n        user_compare.pop('id')\n        update_dict_fmt_item(user_compare, 'create_date', str)\n        assert user_compare in users_mock_dicts\n\n    def test_get_by_name(self, db: Session):\n        name = users_mock_dicts[0]['name']\n        user_out = crud.user.get_by_name(db, name_in=name)\n        assert isinstance(user_out, User), f'{name} is supposed to be in db'\n        user_compare = user_out._asdict()\n        user_compare.pop('id')\n        update_dict_fmt_item(user_compare, 'create_date', str)\n        assert user_compare in users_mock_dicts\n\n    def test_get_multi(self, db: Session):\n        users_out = crud.user.get_multi(db)\n        for user_out in users_out:\n            user_compare = user_out._asdict()\n            user_compare.pop('id')\n            update_dict_fmt_item(user_compare, 'create_date', str)\n            assert user_compare in users_mock_dicts\n\n    def test_create(self, db: Session):\n        user = users_mock[0]\n        created_obj = crud.user.create(db, obj_in=user)\n        created_obj_dict = created_obj._asdict()\n        created_obj_dict.pop('id')\n        assert created_obj_dict == user.dict(exclude_unset=True)\n        crud.user.remove(db, id=created_obj.id)\n\n    def test_update(self, db: Session):\n        user_id = 1\n        updated_last_name = 'Analytics'\n        obj = crud.user.get(db, id=user_id)\n        updated_obj_info = obj._asdict()\n        updated_obj_info.update({'last_name': updated_last_name})\n        obj_in = UserUpdate(**updated_obj_info)\n        updated_obj = crud.user.update(db, db_obj=obj, obj_in=obj_in)\n        assert updated_obj.id == user_id\n        assert updated_obj.last_name == updated_last_name\n\n    def test_update_by_name(self, db: Session):\n        user_name = users_mock_dicts[0]['name']\n        user_obj = crud.user.get_by_name(db, name_in=user_name)\n        updated_last_name = 'Analytics'\n        updated_obj_info = user_obj._asdict()\n        updated_obj_info.update({'last_name': updated_last_name})\n        obj_in = UserUpdate(**updated_obj_info)\n        updated_obj = crud.user.update_by_name(\n            db, name_in_db=user_name, obj_in=obj_in\n        )\n        assert updated_obj.id == user_obj.id\n        assert updated_obj.last_name == updated_last_name\n\n    def test_remove(self, db: Session):\n        user_id = 3\n        deleted_user = crud.user.remove(db, id=user_id)\n        assert deleted_user.id == user_id\n        crud.user.create(db, obj_in=UserCreate(**deleted_user._asdict()))\n\n    def test_remove_one_by_name(self, db: Session):\n        user_name = users_mock_dicts[3]['name']\n        deleted_user = crud.user.remove_one_by_name(db, name=user_name)\n        assert deleted_user.name == user_name\n        crud.user.create(db, obj_in=UserCreate(**deleted_user._asdict()))\n"}
{"type": "test_file", "path": "tests/app/test_app.py", "content": "from app import VERSION\n\n\ndef test_version():\n    assert len(VERSION.split('.')) == 3\n"}
{"type": "test_file", "path": "tests/app/test_conf.py", "content": "from collections.abc import Mapping\n\nfrom app import config\n\n\ndef test_sttgs():\n    assert isinstance(config.sttgs, Mapping)\n"}
{"type": "test_file", "path": "tests/app/test_main.py", "content": "from fastapi import FastAPI\n\nfrom app import main\n\n\ndef test_app():\n    assert isinstance(main.app, FastAPI)\n"}
{"type": "test_file", "path": "tests/app/utils/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/app/utils/test_http_requests.py", "content": "from app.config import sttgs\nfrom app.utils.http_request import post_to_uri\n\n\ndef test_post_to_uri():\n    task_complexity = 0\n    task_query_url = (\n        sttgs.get('GUANE_WORKER_URI') + f'?task_complexity={task_complexity}'\n    )\n    response = post_to_uri(\n        task_query_url,\n        message={'task_complexity': task_complexity}\n    )\n    assert response.status_code == 201\n    assert response.json()['status']\n"}
{"type": "test_file", "path": "tests/app/worker/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/app/worker/test_celery_tasks.py", "content": "from app.worker.tasks import post_to_uri_task\n\n\ndef test_task_post_to_uri():\n\n    task_data = post_to_uri_task()\n\n    assert task_data['status_code'] == 201\n    assert task_data['data']\n"}
{"type": "test_file", "path": "tests/conftest.py", "content": "from typing import Generator, Dict\n\nimport pytest\nfrom fastapi.testclient import TestClient\n\nfrom app.main import app\nfrom app.api.deps import get_db\nfrom tests.mock.db_session import (\n    TestSessionLocal,\n    testing_get_db,\n    setup_test_db,\n    teardown_test_db,\n)\nfrom tests.utils.security import get_superuser_token_headers\n\n\n# Setup tests\ndef pytest_sessionstart(session: pytest.Session):\n    setup_test_db()\n\n\n# Delete all tables in test DB\ndef pytest_sessionfinish(session: pytest.Session):\n    teardown_test_db()\n\n\n@pytest.fixture(scope=\"function\")\ndef db() -> Generator:\n    db = TestSessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\n@pytest.fixture(scope=\"function\")\ndef app_client(db) -> Generator:\n    app.dependency_overrides[get_db] = testing_get_db\n    test_app = TestClient(app)\n    with test_app as c:\n        yield c\n\n\n@pytest.fixture(scope=\"function\")\ndef superuser_token_headers(app_client: TestClient) -> Dict[str, str]:\n    return get_superuser_token_headers(app_client)\n"}
{"type": "test_file", "path": "tests/mock/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/mock/db_session.py", "content": "from typing import Generator\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.config import sttgs\nfrom app.db.db_manager import create_all_tables, drop_all_tables\nfrom app.db.utils.populate_tables import populate_tables_mock_data\nfrom mock_data.db_test_data import dogs_mock, users_mock\n\n\ntest_engine = create_engine(\n    sttgs.get('POSTGRES_TESTS_URI'),\n    pool_pre_ping=True,\n    echo=True\n)\n\n\nTestSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=test_engine\n)\n\n\ndef populate_test_tables() -> None:\n    # Populate tables with test db data\n    populate_tables_mock_data(\n        populate=True,\n        Session=TestSessionLocal,\n        dogs_in=dogs_mock,\n        users_in=users_mock\n    )\n\n\ndef setup_test_db() -> None:\n    drop_all_tables(engine=test_engine, drop=True)\n    create_all_tables(engine=test_engine)\n    populate_test_tables()\n\n\ndef teardown_test_db() -> None:\n    drop_all_tables(engine=test_engine, drop=True)\n\n\ndef testing_get_db() -> Generator:\n    \"\"\"For some reason, app.dependency_overrides does not accept pytest\n    fixtures as overrider, so this function is needed although it is exactlythe\n    same as db\n    \"\"\"\n    db = TestSessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"}
{"type": "test_file", "path": "tests/utils/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/utils/handle_db_test.py", "content": "from tests.mock.db_session import (  # noqa\n    setup_test_db,\n    teardown_test_db,\n)\n\n\nclass HandleDBTest:\n    \"\"\"This Class assures that all tests within a subclass are done in\n    the same database-circumstances\n    \"\"\"\n    def setup_method(self):\n        # populate_test_tables\n        setup_test_db()\n\n    def teardown_method(self):\n        teardown_test_db()\n\n    @classmethod\n    def teardown_class(cls):\n        setup_test_db()\n"}
{"type": "test_file", "path": "tests/utils/parse_dict.py", "content": "from typing import Any, Callable\n\n\ndef update_dict_fmt_item(obj: dict, key: Any, format: Callable):\n    obj.update({key: format(obj[key])})\n"}
{"type": "test_file", "path": "tests/utils/security.py", "content": "from typing import Dict\n\nfrom fastapi.testclient import TestClient\n\nfrom app.config import sttgs\n\n\ndef get_superuser_token_headers(app_client: TestClient) -> Dict[str, str]:\n    login_data = {\n        \"username\": sttgs['FIRST_SUPERUSER'],\n        \"password\": sttgs['FIRST_SUPERUSER_PASSWORD'],\n    }\n    r = app_client.post(f\"{sttgs['TOKEN_URI']}\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n    return headers\n"}
{"type": "test_file", "path": "tests/utils/uri.py", "content": "from app.config import sttgs\n\n\ndef task_uri(specific_endpoint: str, task_complexity: int = 0) -> str:\n    return (\n        sttgs.get('API_PREFIX')\n        + sttgs.get('CELERY_TASKS_PREFIX')\n        + specific_endpoint\n        + '?task_complexity='\n        + str(task_complexity)\n    )\n"}
{"type": "source_file", "path": "app/__init__.py", "content": "# NOTE: DO NOT IMPORT app.main.app here, otherwise, the server initializarion\n# script (run_server.py) will possibly fail when local_db option is set to true\n\nVERSION = '0.1.dev0'\n"}
{"type": "source_file", "path": "app/api/__init__.py", "content": ""}
{"type": "source_file", "path": "app/api/api.py", "content": "from fastapi import APIRouter\n\nfrom app.config import sttgs\nfrom app.api.routers import (\n    dogs_router,\n    users_router,\n    upload_file_router,\n    security_router,\n    tasks_router\n)\n\n\napi_router = APIRouter()\n\n\napi_router.include_router(\n    security_router,\n    prefix=sttgs.get('SECURITY_PREFIX', '/security'),\n    tags=['security']\n)\napi_router.include_router(\n    tasks_router,\n    prefix=sttgs.get('CELERY_TASKS_PREFIX', '/tasks'),\n    tags=['celery tasks']\n)\napi_router.include_router(\n    dogs_router,\n    prefix=sttgs.get('DOGS_API_PREFIX', '/dogs'),\n    tags=['dogs']\n)\napi_router.include_router(\n    users_router,\n    prefix=sttgs.get('USERS_API_PREFIX', '/dogs'),\n    tags=['users']\n)\napi_router.include_router(\n    upload_file_router,\n    prefix=sttgs.get('UPLOAD_API_PREFIX', '/upload'),\n    tags=['upload file']\n)\n"}
{"type": "source_file", "path": "app/api/deps.py", "content": "from typing import Generator\nfrom app.db.session import SessionLocal\n\n\ndef get_db() -> Generator:\n    \"\"\"Starts and ends session in each route that needs database access.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"}
{"type": "source_file", "path": "app/api/routers/__init__.py", "content": "from .dogs import dogs_router\nfrom .users import users_router\nfrom .upload_file import upload_file_router\nfrom .security import security_router\nfrom .tasks import tasks_router\n\n\n__all__ = [\n    'dogs_router',\n    'users_router',\n    'upload_file_router',\n    'security_router',\n    'tasks_router',\n]\n"}
{"type": "source_file", "path": "app/api/routers/dogs.py", "content": "from typing import Any\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom starlette import status\n\nfrom app import schemas, crud\nfrom app.api import deps\nfrom app.crud import superuser_crud\nfrom app.utils.http_request import get_dog_picture\n\n\ndogs_router = APIRouter()\n\n# Web crud was implemented as a wrapper to avoid duplicate code between\n# the two main routers (dogs, users)\ndog_web_crud = crud.WebCRUDWrapper(crud.dog, enty_name='dog')\n\n\n@dogs_router.get(\n    '/',\n    response_model=schemas.Dogs,\n    name='List of all dogs\\' info.'\n)\nasync def get_dogs(\n    db: Session = Depends(deps.get_db),\n) -> Any:\n    \"\"\"Get a list of all ``dog`` entities.\n    \"\"\"\n    return dog_web_crud.get_all_entries(db)\n\n\n@dogs_router.get(\n    '/is_adopted',\n    response_model=schemas.AdoptedDogs,\n    name='Adopted dogs\\' info.'\n)\nasync def get_dogs_is_adopted(\n    db: Session = Depends(deps.get_db)\n) -> Any:\n    \"\"\"Get a list of all ``dog`` entities where the flag ``is_adopted`` is\n    True.\n    \"\"\"\n    adopted_dogs = crud.dog.get_adopted(db)\n    if not adopted_dogs:\n        raise HTTPException(\n            400,\n            detail='No adopted dogs found.'\n        )\n    return {'adopted_dogs': adopted_dogs}\n\n\n@dogs_router.get(\n    '/{name}',\n    response_model=schemas.Dog,\n    name='Dog info by name.'\n)\nasync def get_dogs_name(\n    *,\n    db: Session = Depends(deps.get_db),\n    name: str\n) -> Any:\n    \"\"\"Read one ``dog`` entity based on its name\n    \"\"\"\n    return dog_web_crud.get_enty_by_name(db, name)\n\n\n@dogs_router.post(\n    '/{name}',\n    response_model=schemas.Dog,\n    name='Save one dog.',\n    status_code=status.HTTP_201_CREATED,\n)\nasync def post_dogs_name(\n    *,\n    db: Session = Depends(deps.get_db),\n    dog_info: schemas.DogCreate,\n    name: str,\n    current_superuser: schemas.SuperUser = Depends(\n        superuser_crud.get_current_active_user\n    )\n) -> Any:\n    \"\"\"Save one ``dog`` entity. Don't include the field `picture` in your\n    request if you want the backend to fill it with a random dog picture URL\n    link.\n    \"\"\"\n    if dog_info.picture is None:\n        dog_info.picture = get_dog_picture()\n    return dog_web_crud.post_enty_by_name(db, name=name, enty_info=dog_info)\n\n\n@dogs_router.put(\n    '/{name}',\n    response_model=schemas.Dog,\n    name='Update dog info by name.',\n)\nasync def put_dogs_name(\n    *,\n    db: Session = Depends(deps.get_db),\n    dog_new_info: schemas.DogUpdate,\n    name: str,\n    current_superuser: schemas.SuperUser = Depends(\n        superuser_crud.get_current_active_user\n    )\n) -> Any:\n    \"\"\"Update one ``dog`` entity based on its name.\n    \"\"\"\n    return dog_web_crud.put_enty_by_name(\n        db, name=name, enty_new_info=dog_new_info\n    )\n\n\n@dogs_router.delete(\n    '/{name}',\n    response_model=schemas.Dog,\n    name='Delete dog by name.',\n)\nasync def delete_dogs_name(\n    *,\n    db: Session = Depends(deps.get_db),\n    name: str,\n    current_superuser: schemas.SuperUser = Depends(\n        superuser_crud.get_current_active_user\n    )\n) -> Any:\n    return dog_web_crud.delete_enty_by_name(db, name=name)\n"}
{"type": "source_file", "path": "app/api/routers/security.py", "content": "from typing import Any\nfrom datetime import timedelta\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\n\nfrom app import schemas\nfrom app.config import sttgs\nfrom app.core.security.pwd import authenticate_user\nfrom app.core.security.security import auth_header\nfrom app.core.security.token import create_access_token\nfrom app.db.data.superusers_fake_db import superusers_db\n\n\nsecurity_router = APIRouter()\n\n\n@security_router.post(\"/token\", response_model=schemas.Token)\nasync def login_for_access_token(  # noqa\n    form_data: OAuth2PasswordRequestForm = Depends()\n) -> Any:\n    \"\"\"Try to get the token with one of this two superusers:\n\n    user: guane\n    password: ilovethori\n\n    or\n\n    user: juanes\n    password: ilovecharliebot\n    \"\"\"\n    user = authenticate_user(\n        superusers_db,\n        form_data.username,\n        form_data.password\n    )\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers=auth_header,\n        )\n    access_token_expires = timedelta(\n        minutes=int(sttgs.get('ACCESS_TOKEN_EXPIRE_MINUTES', 15))\n    )\n    access_token = create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n"}
{"type": "source_file", "path": "app/api/routers/tasks.py", "content": "from typing import Any, Awaitable, Dict\n\nfrom fastapi import APIRouter, Depends, HTTPException, Request, status\nfrom celery.result import AsyncResult\n\nfrom app import schemas\nfrom app.config import sttgs\nfrom app.crud import superuser_crud\nfrom app.worker.celery_app import celery_app\n\n\ntasks_router = APIRouter()\n\n\n@tasks_router.post(\n    '/celery_task',\n    response_model=schemas.CeleryTaskResponse,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def celery_task(\n    task_complexity: int,\n    request: Request,\n    current_superuser: schemas.SuperUser = Depends(\n        superuser_crud.get_current_active_user\n    )\n) -> Any:\n    return await run_task_post_to_uri(\n        task_complexity=task_complexity,\n        get_task_result=False,\n    )\n\n\n@tasks_router.post(\n    '/celery_task_not_async',\n    response_model=schemas.CeleryTaskResponse,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def celery_task_not_async(\n    task_complexity: int,\n    request: Request,\n    current_superuser: schemas.SuperUser = Depends(\n        superuser_crud.get_current_active_user\n    )\n) -> Any:\n    \"\"\"Same functionality as last endpoint but this one returns the external\n    server (guane's) response completely at the expense of loosing the async\n    property of celery because of the call to ``task_result.get()``. Keep in\n    mind that a request to this endpoint will take at least as many seconds as\n    the ``task_complexity`` query parameter.\n\n    This one is just for fun, and to test that guane's server is getting the\n    request and giving us an appropriate response.\n\n    Do not use a query parameter greater than 9, since the endpoint calls\n    internally ``task_result.get(timeout=10)`` and it would result in a server\n    error.\n    \"\"\"\n    return await run_task_post_to_uri(\n        task_complexity=task_complexity,\n        get_task_result=True,\n        get_result_timeout=10.0\n    )\n\n\nasync def run_task_post_to_uri(\n    task_complexity: int = 0,\n    *,\n    get_task_result: bool,\n    get_result_timeout: float = 10.0,\n) -> Awaitable[Dict[str, Any]]:\n    \"\"\"If ``get_task_result`` is set to ``True``, the async nature of the\n    celerymtask will be lost, since we make a call to ``task_result.get``.\n\n    ``get_result_timeout`` only makes sense when ``get_task_result`` is set to\n    true. This is the maximum ammount of time the server will wait for the\n    task to complete.\n    \"\"\"\n    response: Dict[str, Any] = {\n        'task_complexity': task_complexity\n    }\n    query_uri = (\n        sttgs.get('GUANE_WORKER_URI') + f'?task_complexity={task_complexity}'\n    )\n    try:\n        task_result: AsyncResult = celery_app.send_task(\n            'app.worker.tasks.post_to_uri_task',\n            kwargs={'query_uri': query_uri}\n        )\n        # If next code block is executed, the async nature of the task will\n        # be lost since task_result.get waits until the task is complete.\n        if get_task_result:\n            ext_server_response = task_result.get(timeout=get_result_timeout)\n            if ext_server_response:\n                response['server_message'] = ext_server_response\n    except Exception:\n        response['success'] = False\n        response['status'] = 'Internal server error'\n        raise HTTPException(status_code=500, detail=response)\n\n    return response\n"}
{"type": "source_file", "path": "app/api/routers/upload_file.py", "content": "from pathlib import Path\nfrom typing import Any\n\nfrom fastapi import APIRouter, Request, Depends, HTTPException, status\nimport requests as req\n\nfrom app import schemas\nfrom app.config import sttgs\nfrom app.crud import superuser_crud\nfrom app.utils.http_request import post_file_to_uri\nfrom app.utils.paths import join_relative_path\n\n\nupload_file_router = APIRouter()\n\n\n@upload_file_router.post(\n    '/file-to-guane',\n    response_model=schemas.UploadFileStatus,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def post_file_to_guane(\n    client_req: Request,\n    current_superuser: schemas.SuperUser = Depends(\n        superuser_crud.get_current_active_user\n    )\n) -> Any:\n    \"\"\"With an empy body request to this endpoint, the api sends a a locally\n    stored file to a previously defined endpoint (in this case, guane's test\n    api).\n    \"\"\"\n    this_file_path = Path(__file__).parent.absolute()\n    upload_file_path = join_relative_path(\n        this_file_path,\n        sttgs.get('UPLOAD_FILE_PATH')\n    )\n\n    upload_req = post_file_to_uri(\n        upload_file_path,\n        message='Hello, guane. This is Juan Esteban Aristizabal!'\n    )\n\n    # If timeout in upload_request\n    if not isinstance(upload_req, req.Response):\n        if upload_req:\n            raise HTTPException(\n                502,\n                detail={\n                    'success': False,\n                    'remote_server_response': None,\n                    'remote_server_status_code': None,\n                    'message': upload_req\n                }\n            )\n        else:\n            raise HTTPException(502)\n\n    return {\n        'success': True if upload_req.status_code == 201 else False,\n        'remote_server_response': upload_req.json(),\n        'remote_server_status_code': upload_req.status_code\n    }\n"}
{"type": "source_file", "path": "app/api/routers/users.py", "content": "from typing import Any\n\nfrom fastapi import APIRouter, Depends, status\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, schemas\nfrom app.api import deps\nfrom app.crud import superuser_crud\n\n\nusers_router = APIRouter()\n\n# Web crud was implemented as a wrapper to avoid duplicate code between\n# the two main routers (dogs, users)\nuser_web_crud = crud.WebCRUDWrapper(crud.user, enty_name='user')\n\n\n@users_router.get(\n    '/',\n    response_model=schemas.Users,\n    name='List all users',\n)\nasync def get_users(\n    db: Session = Depends(deps.get_db)\n) -> Any:\n    return user_web_crud.get_all_entries(db)\n\n\n@users_router.get(\n    '/{name}',\n    response_model=schemas.User,\n    name='User info by name'\n)\nasync def get_users_name(\n    *,\n    db: Session = Depends(deps.get_db),\n    name: str\n) -> Any:\n    \"\"\"Read one ``user`` entity based on its name.\n    \"\"\"\n    return user_web_crud.get_enty_by_name(db, name)\n\n\n@users_router.post(\n    '/{name}',\n    response_model=schemas.User,\n    name='Create user',\n    status_code=status.HTTP_201_CREATED,\n)\nasync def post_users_name(\n    *,\n    db: Session = Depends(deps.get_db),\n    user_info: schemas.UserCreate,\n    name: str,\n    current_superuser: schemas.SuperUser = Depends(\n        superuser_crud.get_current_active_user\n    )\n) -> Any:\n    \"\"\"Save one ``user`` entity.\n    \"\"\"\n    return user_web_crud.post_enty_by_name(db, name=name, enty_info=user_info)\n\n\n@users_router.put(\n    '/{name}',\n    response_model=schemas.User,\n    name='Update user by name'\n)\nasync def put_users_name(\n    *,\n    db: Session = Depends(deps.get_db),\n    user_new_info: schemas.UserUpdate,\n    name: str,\n    current_superuser: schemas.SuperUser = Depends(\n        superuser_crud.get_current_active_user\n    )\n) -> Any:\n    \"\"\"Update one ``user`` entity based on its name.\n    \"\"\"\n    return user_web_crud.put_enty_by_name(\n        db, name=name, enty_new_info=user_new_info\n    )\n\n\n@users_router.delete(\n    '/{name}',\n    response_model=schemas.User,\n    name='Delete user by name'\n)\nasync def delete_users_name(\n    *,\n    db: Session = Depends(deps.get_db),\n    name: str,\n    current_superuser: schemas.SuperUser = Depends(\n        superuser_crud.get_current_active_user\n    )\n) -> Any:\n    \"\"\"Delete one ``user`` entity based on its name.\n    \"\"\"\n    return user_web_crud.delete_enty_by_name(db, name=name)\n"}
{"type": "source_file", "path": "app/core/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/security/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/security/pwd.py", "content": "from app.core.security.security import pwd_context\nfrom app.crud.superuser_crud import get_user\n\n\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef password_hash(password):\n    return pwd_context.hash(password)\n\n\ndef authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user\n"}
{"type": "source_file", "path": "app/core/security/security.py", "content": "from fastapi.security import OAuth2PasswordBearer\nfrom passlib.context import CryptContext\n\nfrom app.config import sttgs\n\n\n# Defines the authentication schema\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=sttgs.get('TOKEN_URI'))\n\n# Handles the passwords\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# OpenAPI authentication header spec\nauth_header = {\"WWW-Authenticate\": \"Bearer\"}\n"}
{"type": "source_file", "path": "app/crud/__init__.py", "content": "from .dog_crud import dog\nfrom .user_crud import user\nfrom .web_crud import WebCRUDWrapper\n\n\n__all__ = ['dog', 'user', 'WebCRUDWrapper']\n"}
{"type": "source_file", "path": "app/core/security/token.py", "content": "from typing import Optional\nfrom datetime import datetime, timedelta\n\nfrom jose import jwt\n\nfrom app.config import sttgs\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(\n        to_encode,\n        sttgs.get('SECRET_KEY'),\n        algorithm=sttgs.get('ALGORITHM')\n    )\n    return encoded_jwt\n"}
{"type": "source_file", "path": "app/crud/base.py", "content": "from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union\n\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\n\nfrom app.models.base_class import Base\n\nModelType = TypeVar(\"ModelType\", bound=Base)\nCreateSchemaType = TypeVar(\"CreateSchemaType\", bound=BaseModel)\nUpdateSchemaType = TypeVar(\"UpdateSchemaType\", bound=BaseModel)\n\n\nclass CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):\n    def __init__(self, model: Type[ModelType]):\n        \"\"\"CRUD object with default methods to Create, Read, Update,\n        Delete (CRUD).\n\n        **Parameters**\n\n        * `model`: A SQLAlchemy model class\n        * `schema`: A Pydantic model (schema) class\n        \"\"\"\n        self.model = model\n\n    def get(self, db: Session, id: Any) -> Optional[ModelType]:\n        return db.query(self.model).filter(self.model.id == id).first()\n\n    def get_by_name(self, db: Session, *, name_in: str) -> Optional[ModelType]:\n        \"\"\"Returns ``None`` when :attr:`CRUDBase.model` does not have attribute\n        ``name``.\n        \"\"\"\n        try:\n            db_obj = (\n                db.query(self.model)\n                .filter(self.model.name == name_in)\n                .first()\n            )\n        except Exception:\n            return None\n\n        return db_obj\n\n    def get_multi(\n        self, db: Session, *, skip: int = 0, limit: Optional[int] = None\n    ) -> List[ModelType]:\n        return db.query(self.model).offset(skip).limit(limit).all()\n\n    def create(self, db: Session, *, obj_in: CreateSchemaType) -> ModelType:\n        obj_in_data = jsonable_encoder(obj_in)\n        db_obj = self.model(**obj_in_data)  # type: ignore\n        db.add(db_obj)\n        db.commit()\n        db.refresh(db_obj)\n        return db_obj\n\n    def update(\n        self,\n        db: Session,\n        *,\n        db_obj: ModelType,\n        obj_in: Union[UpdateSchemaType, Dict[str, Any]]\n    ) -> ModelType:\n        obj_data = jsonable_encoder(db_obj)\n        if isinstance(obj_in, dict):\n            update_data = obj_in\n        else:\n            update_data = obj_in.dict(exclude_unset=True)\n        for field in obj_data:\n            if field in update_data:\n                setattr(db_obj, field, update_data[field])\n        db.add(db_obj)\n        db.commit()\n        db.refresh(db_obj)\n        return db_obj\n\n    def update_by_name(\n        self,\n        db: Session,\n        *,\n        name_in_db: str,\n        obj_in: Union[UpdateSchemaType, Dict[str, Any]]\n    ) -> Optional[ModelType]:\n        \"\"\"Returns ``None`` when :attr:`CRUDBase.model` does not have attribute\n        ``name``.\n        \"\"\"\n        try:\n            db_obj = (\n                db.query(self.model)\n                .filter(self.model.name == name_in_db)\n                .first()\n            )\n        except Exception:\n            return None\n\n        return self.update(db, db_obj=db_obj, obj_in=obj_in)\n\n    def remove(self, db: Session, *, id: int) -> ModelType:\n        obj = db.query(self.model).get(id)\n        db.delete(obj)\n        db.commit()\n        return obj\n\n    def remove_one_by_name(self, db: Session, *, name: str) -> ModelType:\n        \"\"\"Returns ``None`` when :attr:`CRUDBase.model` does not have attribute\n        ``name``.\n        \"\"\"\n        try:\n            obj = db.query(self.model).filter(self.model.name == name).first()\n        except Exception:\n            return None\n        db.delete(obj)\n        db.commit()\n        return obj\n"}
{"type": "source_file", "path": "app/crud/dog_crud.py", "content": "from typing import List, Optional\n\nfrom sqlalchemy.orm import Session\n\nfrom app.crud.base import CRUDBase\nfrom app.schemas import DogCreate, DogUpdate\nfrom app.models import Dog\n\n\nclass CRUDDog(CRUDBase[Dog, DogCreate, DogUpdate]):\n    def get_adopted(\n        self, db: Session, *, skip: int = 0, limit: Optional[int] = None\n    ) -> List[Dog]:\n        return (\n            db.query(self.model)\n            .filter(self.model.is_adopted == True)  # noqa\n            .offset(skip)\n            .limit(limit)\n            .all()\n        )\n\n\ndog = CRUDDog(Dog)\n"}
{"type": "source_file", "path": "app/crud/superuser_crud.py", "content": "from fastapi import Depends, HTTPException, status\nfrom jose import jwt, JWTError\n\nfrom app.config import sttgs\nfrom app.schemas import TokenData, SuperUser, SuperUserInDB\nfrom app.core.security.security import oauth2_scheme, auth_header\nfrom app.db.data.superusers_fake_db import superusers_db\n\n\ndef get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return SuperUserInDB(**user_dict)\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers=auth_header,\n    )\n    try:\n        payload = jwt.decode(\n            token,\n            sttgs.get('SECRET_KEY'),\n            algorithms=[sttgs.get('ALGORITHM')]\n        )\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n    user = get_user(superusers_db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    return user\n\n\nasync def get_current_active_user(\n    current_user: SuperUser = Depends(get_current_user)\n):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n"}
{"type": "source_file", "path": "app/config.py", "content": "import os\nfrom pathlib import Path\n\nfrom dotenv import load_dotenv\n\n\ndotenv_path = Path(__file__).resolve().parent / '..' / '.env'\n\nload_dotenv(dotenv_path)\n\nsttgs = os.environ\n"}
{"type": "source_file", "path": "app/db/session.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n\nfrom app.config import sttgs\n\n\n# Creates connection to PostgreSQL\nengine = create_engine(\n    sttgs.get('POSTGRES_URI'),\n    pool_pre_ping=True,\n    echo=True\n)\n\n\n# Create a local session maker to interact with the db via ORM\nSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=engine\n)\n"}
{"type": "source_file", "path": "app/crud/web_crud.py", "content": "from typing import Dict, List\n\nfrom fastapi import HTTPException\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\n\nfrom app.crud.base import CRUDBase\nfrom app.models.base_class import Base\n\n\nclass WebCRUDWrapper:\n    \"\"\"Wrapper class to avoid duplicate code in API basic crud operations.\n    \"\"\"\n    def __init__(\n        self,\n        crud: CRUDBase,\n        *,\n        enty_name: str\n    ) -> None:\n        self.crud = crud\n        self.enty_name: str = enty_name.lower()\n        self.enty_name_plural = self.enty_name + 's'\n\n    def get_all_entries(self, db: Session) -> Dict[str, List[Base]]:\n        \"\"\"Get all db entries of entity.\"\"\"\n        all_enties = {\n            self.enty_name_plural: [\n                self.crud.model(**entity._asdict())\n                for entity in self.crud.get_multi(db)\n            ]\n        }\n\n        if all_enties.get(self.enty_name_plural):\n            return all_enties\n        else:\n            raise HTTPException(\n                400,\n                detail=f'No {self.enty_name_plural} found'\n            )\n\n    def get_enty_by_name(self, db: Session, name: str) -> Base:\n        enty_by_name = self.crud.get_by_name(db, name_in=name)\n\n        if not enty_by_name:\n            raise HTTPException(\n                400,\n                detail=f'{self.enty_name.title()} with name \\'{name}\\' '\n                       'not found.'\n            )\n\n        return enty_by_name\n\n    def post_enty_by_name(\n        self,\n        db: Session,\n        *,\n        name: str,\n        enty_info: BaseModel\n    ) -> Base:\n        try:\n            created_enty = self.crud.create(db, obj_in=enty_info)\n        except Exception:\n            raise HTTPException(\n                500,\n                detail=f'Error while creating {self.enty_name} \\'{name}\\' in '\n                       'database.'\n            )\n\n        if not created_enty:\n            raise HTTPException(\n                400,\n                detail=f'Create query of {self.enty_name} \\'{name}\\' finished '\n                       'but was not saved.'\n            )\n\n        return created_enty\n\n    def put_enty_by_name(\n        self,\n        db: Session,\n        *,\n        name: str,\n        enty_new_info: BaseModel\n    ):\n        try:\n            updated_enty = self.crud.update_by_name(\n                db, name_in_db=name, obj_in=enty_new_info\n            )\n        except Exception:\n            raise HTTPException(\n                500,\n                f'Error while updating {self.enty_name} \\'{name}\\' in '\n                f'database. Probably the {self.enty_name} does not exist in '\n                'database.'\n            )\n\n        if not updated_enty:\n            raise HTTPException(\n                400,\n                f'{self.enty_name.title()} \\'{name}\\' was not updated.'\n            )\n\n        return updated_enty\n\n    def delete_enty_by_name(\n        self,\n        db: Session,\n        *,\n        name: str\n    ):\n        try:\n            deleted_enty = self.crud.remove_one_by_name(db, name=name)\n        except Exception:\n            raise HTTPException(\n                500,\n                f'Error while deleting {self.enty_name} \\'{name}\\' from '\n                f'database. Probably the {self.enty_name} does not exist in '\n                'database.'\n            )\n\n        if not deleted_enty:\n            raise HTTPException(\n                400,\n                f'{self.enty_name.title()} \\'{name}\\' was not deleted.'\n            )\n\n        return deleted_enty\n"}
{"type": "source_file", "path": "app/db/utils/parse_dicts.py", "content": "from datetime import datetime\nfrom typing import Any, Dict\n\n\ndef parse_dog_dict(\n    create_date: datetime,\n    name: str,\n    picture: str,\n    is_adopted: bool,\n    id_user: int,\n    *args,\n    **kwargs\n) -> Dict[str, Any]:\n    \"\"\"Dog info contained in a dictionary\n    \"\"\"\n    return {\n        'create_date': create_date,\n        'name': name,\n        'picture': picture,\n        'is_adopted': is_adopted,\n        'id_user': id_user,\n    }\n\n\ndef parse_user_dict(\n    create_date: datetime,\n    name: str,\n    last_name: str,\n    email: str,\n    *args,\n    **kwargs\n) -> Dict[str, Any]:\n    \"\"\"User info contained in a dictionary\n    \"\"\"\n    return {\n        'create_date': create_date,\n        'name': name,\n        'last_name': last_name,\n        'email': email,\n    }\n"}
{"type": "source_file", "path": "app/models/dog.py", "content": "from sqlalchemy import Column, Integer, String, Boolean, DateTime\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql.schema import ForeignKey\n\nfrom app.models.base_class import Base\n\n\nclass Dog(Base):\n    id = Column(Integer, primary_key=True, index=True)\n    create_date = Column(DateTime, index=True)\n    name = Column(String, index=True)\n    picture = Column(String, index=True)\n    is_adopted = Column(Boolean, index=True)\n    id_user = Column(Integer, ForeignKey('user.id'))\n\n    # ORM relationship between Dog and User entity\n    user = relationship('User', back_populates='dogs')\n"}
{"type": "source_file", "path": "app/models/base_class.py", "content": "from typing import Any, Dict\n\nfrom sqlalchemy import inspect\nfrom sqlalchemy.ext.declarative import as_declarative, declared_attr\n\n\n@as_declarative()\nclass Base:\n    \"\"\"ORM base class\"\"\"\n    id: Any\n    __name__: str\n\n    # Generate __tablename__ automatically\n    @declared_attr\n    def __tablename__(cls) -> str:\n        return cls.__name__.lower()\n\n    def _asdict(self) -> Dict[str, Any]:\n        return {\n            c.key: getattr(self, c.key)\n            for c in inspect(self).mapper.column_attrs\n        }\n"}
{"type": "source_file", "path": "app/db/data/__init__.py", "content": ""}
{"type": "source_file", "path": "app/models/user.py", "content": "from sqlalchemy import Column, Integer, String, DateTime\nfrom sqlalchemy.orm import relationship\n\nfrom app.models.base_class import Base\n\n\nclass User(Base):\n    id = Column(Integer, primary_key=True, index=True)\n    create_date = Column(DateTime, index=True)\n    name = Column(String, index=True)\n    last_name = Column(String, index=True)\n    email = Column(String, index=True)\n\n    # ORM relationship between User and Dog entity\n    dogs = relationship('Dog', back_populates='user')\n"}
{"type": "source_file", "path": "app/models/__init__.py", "content": "from .dog import Dog\nfrom .user import User\nfrom .base_class import Base\n\n__all__ = ['Base', 'Dog', 'User']\n"}
{"type": "source_file", "path": "app/schemas/user.py", "content": "from datetime import datetime\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, EmailStr\n\nfrom app.schemas.base_config import ConfigBase\n\n\n# Shared properties\nclass UserBase(BaseModel):\n    name: Optional[str]\n    last_name: Optional[str]\n    email: Optional[EmailStr]\n\n    class Config(ConfigBase):\n        pass\n\n\nclass UserCreate(UserBase):\n    create_date: Optional[datetime] = datetime.utcnow()\n\n\nclass UserUpdate(UserBase):\n    pass\n\n\n# Properties shared by DB models\nclass UserInDBBase(UserBase):\n    id: Optional[int]\n    create_date: Optional[datetime] = datetime.utcnow()\n    name: str\n    last_name: str\n    email: EmailStr\n\n    class Config:\n        orm_mode = True\n\n\n# Properties to return in HTTP response\nclass User(UserInDBBase):\n    pass\n\n\nclass Users(BaseModel):\n    users: List[User]\n"}
{"type": "source_file", "path": "app/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "app/schemas/security.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n\n\nclass SuperUser(BaseModel):\n    username: str\n    full_name: Optional[str] = None\n    disabled: Optional[bool] = None\n\n\nclass SuperUserInDB(SuperUser):\n    hashed_password: str\n"}
{"type": "source_file", "path": "app/utils/paths.py", "content": "from pathlib import Path\n\n\ndef join_relative_path(path: Path, rel_path: str) -> Path:\n    for node in rel_path.split('/'):\n        path /= node\n    return path\n"}
{"type": "source_file", "path": "app/db/db_manager.py", "content": "from sqlalchemy.engine import Engine\n\nfrom app.models.base_class import Base\n# We need to import app.db.base in order to appropriately create all database\n# tables using init_bd() function\nfrom app.db import base  # noqa\nfrom app.db.session import engine\n\n\ndef create_all_tables(engine: Engine = engine):\n    \"\"\"Creates all database tables if they don't already exist.\n    \"\"\"\n    Base.metadata.create_all(bind=engine)\n\n\ndef drop_all_tables(engine: Engine = engine, *, drop: bool):\n    if drop:\n        Base.metadata.drop_all(bind=engine)\n"}
{"type": "source_file", "path": "app/schemas/base_config.py", "content": "class ConfigBase:\n    # extra = 'forbid'\n    pass\n"}
{"type": "source_file", "path": "app/db/base.py", "content": "from app.models import Base, Dog, User\n\n\n__all__ = ['Base', 'Dog', 'User']\n"}
{"type": "source_file", "path": "app/schemas/tasks.py", "content": "from typing import Any, Optional\nfrom pydantic import BaseModel\n\n\nclass CeleryTaskResponse(BaseModel):\n    task_complexity: int\n    status: str = 'Successfully submitted the task.'\n    server_message: Optional[Any]\n    success: bool = True\n"}
{"type": "source_file", "path": "app/schemas/dog.py", "content": "from datetime import datetime\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\nfrom app.schemas.base_config import ConfigBase\n\n\n# Shared properties\nclass DogBase(BaseModel):\n    name: Optional[str]\n    picture: Optional[str]\n    is_adopted: Optional[bool]\n    id_user: Optional[int]\n\n    class Config(ConfigBase):\n        pass\n\n\nclass DogCreate(DogBase):\n    create_date: Optional[datetime] = datetime.utcnow()\n\n\nclass DogUpdate(DogBase):\n    pass\n\n\n# Properties shared by DB models\nclass DogInDBBase(DogBase):\n    id: Optional[int]\n    create_date: Optional[datetime] = datetime.utcnow()\n    name: str\n    picture: Optional[str]\n    is_adopted: Optional[bool]\n    id_user: Optional[int]\n\n    class Config:\n        orm_mode = True\n\n\n# Properties to return in HTTP response\nclass Dog(DogInDBBase):\n    pass\n\n\nclass Dogs(BaseModel):\n    dogs: List[Dog]\n\n\nclass AdoptedDogs(BaseModel):\n    adopted_dogs: List[Dog]\n"}
{"type": "source_file", "path": "app/db/__init__.py", "content": ""}
{"type": "source_file", "path": "app/crud/user_crud.py", "content": "from app.crud.base import CRUDBase\nfrom app.schemas import UserCreate, UserUpdate\nfrom app.models import User\n\n\nclass CRUDUser(CRUDBase[User, UserCreate, UserUpdate]):\n    pass\n\n\nuser = CRUDUser(User)\n"}
{"type": "source_file", "path": "app/db/utils/__init__.py", "content": "from .populate_tables import (\n    populate_dog_table,\n    populate_user_table,\n    populate_tables_mock_data,\n)\n\n__all__ = [\n    'populate_dog_table',\n    'populate_user_table',\n    'populate_tables_mock_data',\n]\n"}
{"type": "source_file", "path": "app/db/utils/populate_tables.py", "content": "from typing import List\n\nfrom app import crud\nfrom app.schemas import DogInDBBase, UserInDBBase\nfrom app.db.session import SessionLocal\nfrom mock_data.db_test_data import dogs_mock, users_mock\n\n\ndef populate_dog_table(\n    Session=SessionLocal,\n    *,\n    dogs_in: List[DogInDBBase] = dogs_mock\n) -> None:\n    with Session() as db:\n        for dog_in in dogs_in:\n            crud.dog.create(db, obj_in=dog_in)\n\n\ndef populate_user_table(\n    Session=SessionLocal,\n    *,\n    users_in: List[UserInDBBase] = users_mock\n) -> None:\n    with Session() as db:\n        for user_in in users_in:\n            crud.user.create(db, obj_in=user_in)\n\n\ndef populate_tables_mock_data(\n    populate: bool = False,\n    Session=SessionLocal,\n    dogs_in: List[DogInDBBase] = dogs_mock,\n    users_in: List[UserInDBBase] = users_mock\n) -> None:\n    \"\"\"Populates database table with mock data.\n    \"\"\"\n    if populate:\n        populate_user_table(Session, users_in=users_in)\n        populate_dog_table(Session, dogs_in=dogs_in)\n"}
{"type": "source_file", "path": "app/utils/http_request.py", "content": "import os\nfrom shutil import copyfileobj\nfrom typing import Any, Dict, List, Optional, Union\nfrom pathlib import Path\n\nimport requests as req\n\nfrom app.config import sttgs\n\n\nreq_timeout = int(sttgs.get('REQUESTS_TIMEOUT', 20))\n\n\ndef get_dog_picture(\n    api_uri: Optional[str] = sttgs.get('DOG_API_URI')\n) -> Optional[str]:\n    \"\"\"Returns None if an exception occurs.\n    \"\"\"\n    if api_uri:\n\n        try:\n            r = req.get(api_uri, timeout=req_timeout)\n        except req.exceptions.Timeout:\n            return time_out_message(api_uri, req_timeout)\n        except Exception:\n            return None\n\n        data_json = r.json()\n\n        if (not r.status_code == 200) or (not isinstance(data_json, dict)):\n            return None\n\n        if data_json.get('status') == 'success':\n            return data_json.get('message')\n\n    return None\n\n\ndef post_file_to_uri(\n    upload_file_path: Path,\n    uri: str = sttgs.get('UPLOAD_FILE_URI'),\n    file_content: str = 'image/png',\n    *,\n    message: str\n) -> Union[req.Response, str]:\n    \"\"\"Post a file to uri.\"\"\"\n    # if file does not exist, post a text file\n    os.makedirs(upload_file_path.parent, exist_ok=True)\n    if not os.path.isfile(upload_file_path):\n        upload_file_path = upload_file_path.parent / 'hello_guane.txt'\n        file_content = 'text/plain'\n        message = 'Original file was replaced by api.'\n        with open(upload_file_path, 'w') as save_file:\n            save_file.write('Hello guane, this is Juan Esteban Aristizábal!')\n\n    # Read file and upload it to uri it using requests library\n    with open(upload_file_path, 'rb') as payload:\n        files_to_upload = {\n            'file': (\n                upload_file_path.name,\n                payload,\n                file_content,\n                {'message': message}\n            )\n        }\n        try:\n            request = req.post(\n                uri,\n                files=files_to_upload,\n                timeout=req_timeout,\n            )\n        except req.exceptions.Timeout:\n            return time_out_message(uri, req_timeout)\n\n        # Save a copy of the file just to verify that the uploaded object was\n        # correctly read\n        save_file_copy_path = (\n            upload_file_path.parent / ('2-' + upload_file_path.name)\n        )\n        with open(save_file_copy_path, 'wb') as save_file_copy:\n            payload.seek(0)\n            save_file_copy.seek(0)\n            copyfileobj(payload, save_file_copy)\n            save_file_copy.truncate()\n\n    return request\n\n\ndef post_to_uri(\n    api_uri: str,\n    message: Dict[str, Any],\n    expected_status_codes: List[int] = [200, 201]\n) -> Optional[req.Response]:\n    try:\n        response = req.post(api_uri, data=message, timeout=req_timeout)\n    except req.exceptions.Timeout:\n        raise req.exceptions.Timeout(time_out_message(api_uri, req_timeout))\n\n    data_json = response.json()\n\n    status_code_is_not_expected = (\n        response.status_code not in expected_status_codes\n    )\n\n    if status_code_is_not_expected or (not isinstance(data_json, dict)):\n        return None\n\n    return response\n\n\ndef time_out_message(server, secs: int):\n    return f'The request to {server} timed out after {secs} seconds.'\n\n\nexample_dog_urls = [\n    \"https://images.dog.ceo/breeds/retriever-golden/nina.jpg\",\n    \"https://images.dog.ceo/breeds/papillon/n02086910_1613.jpg\",\n    \"https://images.dog.ceo/breeds/buhund-norwegian/hakon1.jpg\",\n    \"https://images.dog.ceo/breeds/terrier-toy/n02087046_4409.jpg\",\n]\n"}
{"type": "source_file", "path": "app/schemas/__init__.py", "content": "from app.schemas.dog import (\n    DogBase, DogCreate, DogUpdate, DogInDBBase, Dog, Dogs, AdoptedDogs\n)\nfrom app.schemas.user import (\n    UserBase, UserCreate, UserUpdate, UserInDBBase, User, Users\n)\nfrom app.schemas.upload import UploadFileStatus\nfrom app.schemas.security import (\n    Token,\n    TokenData,\n    SuperUser,\n    SuperUserInDB,\n)\nfrom app.schemas.tasks import CeleryTaskResponse\n\n__all__ = [\n    'DogBase',\n    'DogCreate',\n    'DogUpdate',\n    'DogInDBBase',\n    'Dog',\n    'Dogs',\n    'AdoptedDogs',\n    'UserBase',\n    'UserCreate',\n    'UserUpdate',\n    'UserInDBBase',\n    'User',\n    'Users',\n    'UploadFileStatus',\n    'Token',\n    'TokenData',\n    'SuperUser',\n    'SuperUserInDB',\n    'CeleryTaskResponse',\n]\n"}
{"type": "source_file", "path": "app/schemas/upload.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass UploadFileStatus(BaseModel):\n    success: bool\n    remote_server_response: Optional[dict]\n    remote_server_status_code: Optional[int]\n    message: Optional[str]\n"}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\n\nfrom app.config import sttgs\nfrom app.api.api import api_router\n\n\n# Main app\napp = FastAPI(title=sttgs.get('PROJECT_TITLE'))\n\napp.add_middleware(\n    TrustedHostMiddleware,\n    allowed_hosts=sttgs.get('ALLOWED_HOSTS', ['*']).split(',')\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_credentials=True,\n    allow_origins=sttgs.get('ALLOWED_ORIGINS', ['*']).split(','),\n    allow_methods=sttgs.get('ALLOWED_METHODS', ['*']).split(','),\n    allow_headers=sttgs.get('ALLOWED_HEADERS', ['*']).split(',')\n)\n\napp.include_router(api_router, prefix='/api')\n"}
{"type": "source_file", "path": "app/db/data/superusers_fake_db.py", "content": "\"\"\"This file is meant to mock a user database and is commited to git history\njust for the convenience of the developer reading this code: personal data\nshould never be published in repositories.\n\"\"\"\nsuperusers_db = {\n    'guane': {\n        \"username\": \"guane\",\n        \"full_name\": \"guane enterprises\",\n        # password: ilovethori\n        \"hashed_password\": \"$2b$12$ESVIIGyxIcIPaYsZuSKIFOmqwTMbtePT6GnoKf0ufwDjoietMVauO\",  # noqa\n        \"disabled\": False\n    },\n    'juanes': {\n        \"username\": \"juanes\",\n        \"full_name\": \"Juan Esteban\",\n        # password: ilovecharliebot\n        \"hashed_password\": \"$2b$12$Mky.p4UlRtZAc.1IKQayHO8zJuMf.NoblVAT0xehuj6oANUBbsqZ.\",  # noqa\n        \"disabled\": False\n    }\n}\n"}
{"type": "source_file", "path": "mock_data/__init__.py", "content": ""}
{"type": "source_file", "path": "app/worker/tasks.py", "content": "from typing import Dict, List, Any\n\nfrom app.config import sttgs\nfrom app.worker.celery_app import celery_app\nfrom app.utils.http_request import post_to_uri\n\n\n@celery_app.task(\n    bind=True,\n    acks_late=True,\n    retry_kwargs={'max_retries': 2},\n)\ndef post_to_uri_task(\n    self,\n    query_uri: str = sttgs['GUANE_WORKER_URI'] + '?task_complexity=0',\n    message: Dict[str, Any] = {},\n    expected_status_codes: List[int] = [201, 200],\n) -> Dict[str, Any]:\n    try:\n        response = post_to_uri(\n            query_uri,\n            message,\n            expected_status_codes,\n        )\n    except Exception as e:\n        self.retry(countdown=3, exc=e)\n\n    return {'status_code': response.status_code, 'data': dict(response.json())}\n"}
{"type": "source_file", "path": "app/worker/celery_app.py", "content": "from celery import Celery\n\nfrom app.config import sttgs\n\n\ncelery_app = Celery(\n    'celery_worker',\n    broker=sttgs['RABBITMQ_URI'],\n    backend=sttgs['CELERY_BAKCEND_URI'],\n)\n\ncelery_app.autodiscover_tasks(['app.worker'])\n"}
{"type": "source_file", "path": "app/worker/__init__.py", "content": ""}

{"repo_info": {"repo_name": "full_node_blockchain", "repo_owner": "creotiv", "repo_url": "https://github.com/creotiv/full_node_blockchain"}}
{"type": "source_file", "path": "__init__.py", "content": ""}
{"type": "source_file", "path": "blockchain/api.py", "content": "from .blocks import Tx, Block\n\nclass API:\n\n    \"\"\"\n        Some wrapper around blockchain to add some logic without changing\n        main blockchain code\n    \"\"\"\n\n    def __init__(self, blockcain):\n        self.bc = blockcain\n\n    def get_user_balance(self, address):\n        total = 0\n        for v in self.bc.db.unspent_outputs_amount[str(address)].values():\n            total += v\n        return total\n\n    def get_user_unspent_txs(self, address):\n        res = []\n        for tx_hash,out_hash in self.bc.db.unspent_txs_by_user_hash[str(address)]:\n            amount = self.bc.db.unspent_outputs_amount[str(address)][out_hash]\n            for index,out in enumerate(self.bc.db.transaction_by_hash[tx_hash]['outputs']):\n                if out['hash'] == out_hash:\n                    res.append({\n                        \"tx\": tx_hash,\n                        \"output_index\": index,\n                        \"out_hash\": out_hash,\n                        \"amount\": amount\n                    })\n        return res\n\n    def get_chain(self, from_block:int, limit:int=20):\n        res = [b.as_dict for b in self.bc.chain[from_block:from_block+limit]]\n        # adding blocks from splitbrain\n        if len(res) < limit:\n            res += self.bc.fork_blocks.values()\n        return res\n\n    def add_block(self, block):\n        block = Block.from_dict(block)\n        res = self.bc.add_block(block)\n        if res:\n            self.bc.rollover_block(block)\n        return res\n\n    def mine_block(self, check_stop=None):\n        self.bc.force_block(check_stop)\n\n    def add_tx(self, tx):\n        return self.bc.add_tx(Tx.from_dict(tx))\n\n    def get_head(self):\n        if not self.bc.head:\n            return {}\n        return self.bc.head.as_dict\n            "}
{"type": "source_file", "path": "blockchain/__init__.py", "content": ""}
{"type": "source_file", "path": "blockchain/blockchain.py", "content": "from .blocks import Block, Tx, Input, Output\nfrom .verifiers import TxVerifier, BlockOutOfChain, BlockVerifier, BlockVerificationFailed\nimport logging\n\nlogger = logging.getLogger('Blockchain')\n\n\nclass Blockchain: \n\n    __slots__ =  'max_nonce', 'chain', 'unconfirmed_transactions', 'db', 'wallet', 'on_new_block', 'on_prev_block', 'current_block_transactions', 'fork_blocks'\n\n    def __init__(self, db, wallet, on_new_block=None, on_prev_block=None):\n        self.max_nonce = 2**32\n    \n        self.db = db\n        self.wallet = wallet\n        self.on_new_block = on_new_block\n        self.on_prev_block = on_prev_block\n\n        self.unconfirmed_transactions = set()\n        self.current_block_transactions = set()\n        self.chain = []\n        self.fork_blocks = {}    \n \n    def create_first_block(self):\n        \"\"\"\n        Creating first block in a chain. Only COINBASE Tx.\n        \"\"\"\n        tx = self.create_coinbase_tx()\n        block = Block([tx], 0, 0x0)\n        self.mine_block(block)\n\n    def create_coinbase_tx(self, fee=0):\n        inp = Input('COINBASE',0,self.wallet.address,0)\n        inp.sign(self.wallet)\n        out = Output(self.wallet.address, self.db.config['mining_reward']+fee, 0)\n        return Tx([inp],[out])\n\n    def is_valid_block(self, block):\n        bv = BlockVerifier(self.db)\n        return bv.verify(self.head, block)\n\n    def add_block(self, block):\n        if self.head and block.hash() == self.head.hash():\n            logger.error('Duplicate block')\n            return False\n        try:\n            self.is_valid_block(block)\n        except BlockOutOfChain:\n            # Here we covering split brain case only for next 2 leves of blocks\n            # with high difficulty its a rare case, and more then 2 level much more rare.\n            if block.prev_hash == self.head.prev_hash:\n                logger.error('Split Brain detected')\n                self.fork_blocks[block.hash()] = block\n                return False\n            else:\n                for b_hash, b in self.fork_blocks.items():\n                    if block.prev_hash == b_hash:\n                        logger.error('Split Brain fixed. Longer chain choosen')\n                        self.rollback_block()\n                        self.chain.append(b)\n                        self.chain.append(block)\n                        self.fork_blocks = {}\n                        return True\n                    logger.error('Second Split Brain detected. Not programmed to fix this')\n                    return False\n        except BlockVerificationFailed as e:\n            logger.error('Block verification failed: %s' % e)\n            return False\n        else:        \n            self.chain.append(block)\n            self.fork_blocks = {}\n            logger.info('   Block added')\n            return True\n        logger.error('Hard chain out of sync')\n\n    def add_tx(self, tx):\n        if self.db.transaction_by_hash.get(tx.hash):\n            return False\n        tv = TxVerifier(self.db)\n        fee = tv.verify(tx.inputs, tx.outputs)\n        self.db.transaction_by_hash[tx.hash] = tx.as_dict\n        self.unconfirmed_transactions.add((fee, tx.hash))\n        return True\n       \n    def force_block(self, check_stop=None):\n        '''\n        Forcing to mine block. Gthering all txs with some limit. First take Txs with bigger fee.\n        '''\n        txs = sorted(self.unconfirmed_transactions, key=lambda x:-x[0])[:self.db.config['txs_per_block']]\n        self.current_block_transactions = set(txs)\n        fee = sum([v[0] for v in txs])\n        txs = [Tx.from_dict(self.db.transaction_by_hash[v[1]]) for v in txs ]\n        block = Block(\n            txs=[self.create_coinbase_tx(fee)] + txs,\n            index=self.head.index+1,\n            prev_hash=self.head.hash(),\n        )\n        self.mine_block(block, check_stop)\n\n    def rollover_block(self, block):\n        '''\n        As we use some sort of DB, we need way to update it depends we need add block or remove.\n        So we have 2 methods Rollover and Rollback.\n        Also i added some sort of callback in case some additional functionality should be added on top.\n        For example some Blockchain analytic DB.\n        '''\n        self.unconfirmed_transactions -= self.current_block_transactions\n        self.db.block_index = block.index\n        for tx in block.txs:\n            self.db.transaction_by_hash[tx.hash] = tx.as_dict\n            for out in tx.outputs:\n                self.db.unspent_txs_by_user_hash[str(out.address)].add((tx.hash,out.hash))\n                self.db.unspent_outputs_amount[str(out.address)][out.hash] = int(out.amount)\n            for inp in tx.inputs:\n                if inp.prev_tx_hash == 'COINBASE':\n                    continue\n                prev_out = self.db.transaction_by_hash[inp.prev_tx_hash]['outputs'][inp.output_index]\n                self.db.unspent_txs_by_user_hash[prev_out['address']].remove((inp.prev_tx_hash,prev_out['hash']))\n                del self.db.unspent_outputs_amount[prev_out['address']][prev_out['hash']]\n        if self.on_new_block:\n            self.on_new_block(block, self.db)\n        self.current_block_transactions = set()\n\n    def rollback_block(self):\n        block = self.chain.pop()\n        self.db.block_index -= 1\n        total_amount_in = 0\n        total_amount_out = 0\n\n        for tx in block.txs:\n            # removing new unspent outputs\n            for out in tx.outputs:\n                self.db.unspent_txs_by_user_hash[str(out.address)].remove((tx.hash,out.hash))\n                del self.db.unspent_outputs_amount[str(out.address)][out.hash]\n                total_amount_out += out.amount\n            # adding back previous unspent outputs\n            for inp in tx.inputs:\n                if inp.prev_tx_hash == 'COINBASE':\n                    continue\n                prev_out = self.db.transaction_by_hash[inp.prev_tx_hash]['outputs'][inp.output_index]\n                self.db.unspent_txs_by_user_hash[prev_out['address']].add((inp.prev_tx_hash,prev_out['hash']))\n                self.db.unspent_outputs_amount[prev_out['address']][prev_out['hash']] = prev_out['amount']      \n                total_amount_in += int(prev_out['amount'])\n\n            # adding Tx back un unprocessed stack\n            fee = total_amount_in - total_amount_out\n            self.unconfirmed_transactions.add((fee,tx.hash))\n\n        \n        if self.on_prev_block:\n            self.on_prev_block(block, self.db)\n\n    def mine_block(self, block, check_stop=None):\n        '''\n        Mine a block with ability to stop in case if check callback return True\n        '''\n        for n in range(self.max_nonce):\n            if check_stop and check_stop():\n                logger.error('Mining interrupted.')\n                return\n            if int(block.hash(nonce=n), 16) <= (2 ** (256-self.db.config['difficulty'])):\n                self.add_block(block)\n                self.rollover_block(block)\n                logger.info('  Block mined at nonce: %s' % n)\n                break\n\n\n\n    @property\n    def head(self):\n        if not self.chain:\n            return None\n        return self.chain[-1]\n\n    @property\n    def blockchain(self):\n        return [el.as_dict for el in reversed(self.chain)]\n\n"}
{"type": "source_file", "path": "blockchain/db.py", "content": "import pickle\nfrom collections import defaultdict\n\nclass DB:\n    \"\"\"\n    Class that just emulates some sort of DB used to save all data\n    \"\"\"\n    def __init__(self):\n        self.config = {\n            'txs_per_block': 4,\n            'mining_reward': 25,\n            'difficulty': 22,\n        }\n\n        self.block_index = 0\n        self.transaction_by_hash = {}\n        self.unspent_txs_by_user_hash = defaultdict(set)\n        self.unspent_outputs_amount = defaultdict(dict)\n\n    '''\n        Just simple routine to save/restore db data for block number\n    '''\n    def backup(self):\n        with open('block_%s' % self.block_index,'wb') as fp:\n            pickle.dump(self.__dict__, fp)\n\n    @classmethod\n    def restore(cls, block_index):\n        with open('block_%s' % block_index, 'rb') as fp:\n            data = pickle.load(fp)\n\n        inst = cls()\n        inst.__dict__ = data\n        return inst"}
{"type": "source_file", "path": "blockchain/verifiers.py", "content": "import rsa\nimport binascii\n\nfrom .wallet import Address\n\nclass TxVerifier:\n    def __init__(self, db):\n        self.db = db\n\n    def verify(self, inputs, outputs):\n        total_amount_in = 0\n        total_amount_out = 0\n        for i,inp in enumerate(inputs):\n            if inp.prev_tx_hash == 'COINBASE' and i == 0:\n                total_amount_in = int(self.db.config['mining_reward'])\n                continue\n \n            try:\n                out = self.db.transaction_by_hash[inp.prev_tx_hash]['outputs'][inp.output_index]\n            except KeyError:\n                raise Exception('Transaction output not found.')\n\n            total_amount_in += int(out['amount'])\n\n            if (inp.prev_tx_hash,out['hash']) not in self.db.unspent_txs_by_user_hash.get(out['address'], set()):\n                raise Exception('Output of transaction already spent.')\n\n            hash_string = '{}{}{}{}'.format(\n                inp.prev_tx_hash, inp.output_index, inp.address, inp.index\n            )\n            try:\n                rsa.verify(hash_string.encode(), binascii.unhexlify(inp.signature.encode()), Address(out['address']).key) == 'SHA-256'\n            except:\n                raise Exception('Signature verification failed: %s' % inp.as_dict)\n\n        for out in outputs:\n            total_amount_out += int(out.amount)\n\n        if total_amount_in < total_amount_out:\n            raise Exception('Insuficient funds.')\n\n        return total_amount_in - total_amount_out\n\nclass BlockOutOfChain(Exception):\n    pass\n\nclass BlockVerificationFailed(Exception):\n    pass\n\nclass BlockVerifier:\n    def __init__(self, db):\n        self.db = db\n        self.tv = TxVerifier(db)\n\n    def verify(self, head, block):\n        total_block_reward = int(self.db.config['mining_reward'])\n\n        # verifying block hash\n        if int(block.hash(), 16) > (2 ** (256-self.db.config['difficulty'])):\n            raise BlockVerificationFailed('Block hash bigger then target difficulty')     \n\n        # verifying transactions in a block\n        for tx in block.txs[1:]:\n            fee = self.tv.verify(tx.inputs, tx.outputs)\n            total_block_reward += fee\n        \n        total_reward_out = 0\n        for out in block.txs[0].outputs:\n            total_reward_out += out.amount\n\n        # verifying block reward\n        if total_block_reward != total_reward_out:\n            raise BlockVerificationFailed('Wrong reward sum')\n        \n        # verifying some other things\n        if head:\n            if head.index >= block.index:\n                raise BlockOutOfChain('Block index number wrong')\n            if head.hash() != block.prev_hash:\n                raise BlockOutOfChain('New block not pointed to the head')\n            if head.timestamp > block.timestamp:\n                raise BlockOutOfChain('Block from the past')\n\n        return True\n"}
{"type": "source_file", "path": "blockchain/wallet.py", "content": "import rsa\nimport binascii\n\n\nclass Address:\n    def __init__(self, addr):\n        if isinstance(addr, rsa.PublicKey):\n            self.addr = addr\n        else:\n            if isinstance(addr,str):\n                addr = addr.encode()\n            # thats not clean bu i didnt find simple crypto library for 512 sha key\n            # to get address/public_key short. \n            self.addr = rsa.PublicKey.load_pkcs1(b'-----BEGIN RSA PUBLIC KEY-----\\n%b\\n-----END RSA PUBLIC KEY-----\\n' % addr)\n\n    def __str__(self):\n        return b''.join(self.addr.save_pkcs1().split(b'\\n')[1:-2]).decode()\n\n    @property\n    def key(self):\n        return self.addr\n\nclass Wallet:\n    '''For real case wallet use ECDSA cryptography'''\n\n    __slots__ = '_pub', '_priv'\n    \n    def __init__(self, pub=None, priv=None):\n        if pub:\n            self._pub = Address(pub)\n            self._priv = rsa.PrivateKey.load_pkcs1(priv)\n\n    @classmethod\n    def create(cls):\n        inst = cls(b'',b'')\n        _pub, _priv = rsa.newkeys(512)\n        inst._pub = Address(_pub)\n        inst._priv = _priv\n        return inst\n\n    @classmethod\n    def verify(cls, data, signature, address):\n        signature = binascii.unhexlify(signature.encode())\n        if not isinstance(address, Address):\n            address = Address(address)\n        try:\n            return rsa.verify(data, signature, address.key) == 'SHA-256'\n        except:\n            return False \n    \n    @property\n    def address(self):\n        return str(self._pub)\n\n    @property\n    def priv(self):\n        return self._priv.save_pkcs1()\n\n    def sign(self, hash):\n        return binascii.hexlify(rsa.sign(hash, self._priv, 'SHA-256')).decode()"}
{"type": "source_file", "path": "blockchain/blocks.py", "content": "import time\nfrom hashlib import sha256\nfrom merkletools import MerkleTools\n\nfrom .wallet import Address\n\n\nclass Input:\n    __slots__ = 'prev_tx_hash', 'output_index', 'signature', '_hash', 'address', 'index', 'amount'\n\n    def __init__(self, prev_tx_hash, output_index, address, index=0):\n        self.prev_tx_hash = prev_tx_hash\n        self.output_index = output_index\n        self.address = address\n        self.index = 0\n        self._hash = None\n        self.signature = None\n        self.amount = None\n\n    def sign(self, wallet):\n        hash_string = '{}{}{}{}'.format(\n            self.prev_tx_hash, self.output_index, self.address, self.index\n        ).encode()\n        self.signature = wallet.sign(hash_string)\n\n    @property\n    def hash(self):\n        if self._hash:\n            return self._hash\n        if not self.signature and self.prev_tx_hash != 'COINBASE':\n            raise Exception('Sing the input first')\n        hash_string = '{}{}{}{}'.format(\n            self.prev_tx_hash, self.output_index, self.address, self.signature, self.index\n        )\n        self._hash = sha256(sha256(hash_string.encode()).hexdigest().encode('utf8')).hexdigest()\n        return self._hash\n\n    @property\n    def as_dict(self):\n        return {\n            \"prev_tx_hash\":self.prev_tx_hash,\n            \"output_index\":self.output_index,\n            \"address\":str(self.address),\n            \"index\":self.index,\n            \"hash\":self.hash,\n            \"signature\":self.signature\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        inst = cls(\n            data['prev_tx_hash'],\n            data['output_index'],\n            Address(data['address']),\n            data['index'],\n        )\n        inst.signature = data['signature']\n        inst._hash = None\n        return inst\n        \n\nclass Output:\n    __slots__ = '_hash', 'address', 'index', 'amount', 'input_hash'\n\n    def __init__(self, address, amount, index=0):\n        self.address = address\n        self.index = 0\n        self.amount = int(amount)\n        # i use input hash here to make output hash unique, especialy for COINBASE tx\n        self.input_hash = None\n        self._hash = None\n\n    @property\n    def hash(self):\n        if self._hash:\n            return self._hash\n   \n        hash_string = '{}{}{}{}'.format(\n            self.amount, self.index, self.address, self.input_hash\n        )\n        self._hash = sha256(sha256(hash_string.encode()).hexdigest().encode('utf8')).hexdigest()\n        return self._hash\n\n    @property\n    def as_dict(self):\n        return {\n            \"amount\":int(self.amount),\n            \"address\":str(self.address),\n            \"index\":self.index,\n            \"input_hash\": self.input_hash,\n            \"hash\":self.hash\n        }\n        \n    @classmethod\n    def from_dict(cls, data):\n        inst = cls(\n            Address(data['address']),\n            data['amount'],\n            data['index'],\n        )\n        inst.input_hash = data['input_hash']\n        inst._hash = None\n        return inst\n\nclass Tx:\n    __slots__ = 'inputs', 'outputs', 'timestamp', '_hash'\n\n    def __init__(self, inputs, outputs, timestamp=None):   \n        self.inputs = inputs\n        self.outputs = outputs\n        self.timestamp = timestamp or int(time.time())\n        self._hash = None\n\n    @property\n    def hash(self):\n        if self._hash:\n            return self._hash\n\n        # calculating input_hash for outputs\n        inp_hash = sha256((str([el.as_dict for el in self.inputs]) + str(self.timestamp)).encode()).hexdigest()\n        for el in self.outputs:\n            el.input_hash = inp_hash\n\n        hash_string = '{}{}{}'.format(\n            [el.as_dict for el in self.inputs], [el.as_dict for el in self.outputs], self.timestamp\n        )\n        self._hash = sha256(sha256(hash_string.encode()).hexdigest().encode('utf8')).hexdigest()\n        return self._hash\n\n    @property\n    def as_dict(self):\n        inp_hash = sha256((str([el.as_dict for el in self.inputs]) + str(self.timestamp)).encode()).hexdigest()\n        for el in self.outputs:\n            el.input_hash = inp_hash\n        return {\n            \"inputs\":[el.as_dict for el in self.inputs],\n            \"outputs\":[el.as_dict for el in self.outputs],\n            \"timestamp\":self.timestamp,\n            \"hash\":self.hash\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        inps = [Input.from_dict(el) for el in data['inputs']]\n        outs = [Output.from_dict(el) for el in data['outputs']]\n        inp_hash = sha256((str([el.as_dict for el in inps]) + str(data['timestamp'])).encode()).hexdigest()\n        for el in outs:\n            el.input_hash = inp_hash\n            \n        inst = cls(\n            inps,\n            outs,\n            data['timestamp'],\n        )\n        inst._hash = None\n        return inst\n\n\nclass Block:\n\n    __slots__ = 'nonce', 'prev_hash', 'index', 'txs', 'timestamp', 'merkel_root'\n\n    def __init__(self, txs, index, prev_hash, timestamp=None, nonce=0):\n        self.txs = txs or []\n        self.prev_hash = prev_hash\n        self.index = index\n        self.nonce = nonce\n        self.timestamp = timestamp or int(time.time())\n        self.merkel_root = None\n\n    def build_merkel_tree(self):\n        \"\"\"\n        Merkel Tree used to hash all the transactions, and on mining do not recompute Txs hash everytime\n        Which making things much faster. \n        And tree used because we can append new Txs and rebuild root hash much faster, when just building \n        block before mine it.\n        \"\"\"\n        if self.merkel_root:\n            return self.merkel_root\n        mt = MerkleTools(hash_type=\"SHA256\")\n        for el in self.txs:\n            mt.add_leaf(el.hash)\n        mt.make_tree()\n        self.merkel_root = mt.get_merkle_root()\n        return self.merkel_root\n\n    def hash(self, nonce=None):\n        if nonce:\n            self.nonce = nonce\n        block_string = '{}{}{}{}{}'.format(\n            self.build_merkel_tree(), self.prev_hash, self.index, self.nonce, self.timestamp\n        )\n        return sha256(sha256(block_string.encode()).hexdigest().encode('utf8')).hexdigest()\n\n    @property\n    def as_dict(self):\n        return {\n            \"index\": self.index,\n            \"timestamp\": self.timestamp,\n            \"prev_hash\": self.prev_hash,\n            \"hash\": self.hash(),\n            \"txs\": [el.as_dict for el in self.txs],\n            \"nonce\": self.nonce,\n            \"merkel_root\":self.merkel_root\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        return cls(\n            [Tx.from_dict(el) for el in data['txs']],\n            data['index'],\n            data['prev_hash'],\n            data['timestamp'],\n            data['nonce']\n        )"}
{"type": "source_file", "path": "models.py", "content": "\nfrom typing import List\nfrom pydantic import BaseModel, Field\n\n\"\"\"\nJust some Input models for FastApi\n\"\"\"\n\nclass InputModel(BaseModel):\n    prev_tx_hash:str\n    output_index:int\n    address:str\n    index:int\n    signature:str\n\nclass OutputModel(BaseModel):\n    amount:int\n    address:str\n    index:int\n    input_hash:str\n\nclass TxModel(BaseModel):\n    inputs:List[InputModel]\n    outputs:List[OutputModel]\n    timestamp:int\n    class Config:\n        arbitrary_types_allowed = True\n\nclass BlockModel(BaseModel):\n    index:int\n    nonce:int\n    timestamp:int\n    prev_hash:str\n    txs:List[TxModel]\n    class Config:\n        arbitrary_types_allowed = True\n\nclass BlocksModel(BaseModel):\n    blocks:List[BlockModel]\n    class Config:\n        arbitrary_types_allowed = True\n\nclass NodesModel(BaseModel):\n    nodes:List[str]"}
{"type": "source_file", "path": "full_node.py", "content": "from fastapi import FastAPI, BackgroundTasks, Request\nimport uvicorn\nimport requests\nimport asyncio\nimport logging\nimport sys\n\nfrom models import *\nfrom blockchain.db import DB\nfrom blockchain.blockchain import Blockchain\nfrom blockchain.wallet import Wallet\nfrom blockchain.api import API\nfrom blockchain.blocks import Input, Output, Tx\n\n# Custom formatter\nclass ColorFormatter(logging.Formatter):\n\n    def __init__(self, fmt=\"%(asctime)s - Blockchain - %(message)s\"):\n        super(ColorFormatter,self).__init__(fmt)\n        red = '\\033[0;31m'\n        nc = '\\033[0m'\n        cyan = '\\033[0;96m'\n\n        err_fmt  = f\"{red}%(asctime)s - Blockchain{nc} - %(message)s\"\n        info_fmt = f\"{cyan}%(asctime)s - Blockchain{nc} - %(message)s\"\n        self.err = logging.Formatter(err_fmt)\n        self.log = logging.Formatter(info_fmt)\n\n    def format(self, record):\n        if record.levelno == logging.ERROR:\n            return self.err.format(record)\n        else:\n            return self.log.format(record)\n\n\nlogger = logging.getLogger(\"Blockchain\")\n\n'''\nTODO:\n* sync data while split brain exist \n'''\n\napp = FastAPI()\napp.config = {}\napp.jobs = {}\n\n### TASKS\ndef sync_data():\n    logger.info('================== Sync started =================')\n    bc = app.config['api']\n    head = bc.get_head()\n    while True:\n        sync_running = False\n        for node in app.config['nodes']:\n            if node == ('%s:%s' % (app.config['host'],app.config['port'])):\n                continue\n            url = 'http://%s/chain/sync' % node\n            start = head['index']+1 if head else 0\n            while True:\n                logger.info(url, {\"from_block\":start, \"limit\":20})\n                res = requests.get(url, params={\"from_block\":start, \"limit\":20})\n                if res.status_code == 200:\n                    data = res.json()\n                    if not data:\n                        break\n                    sync_running = True\n                    for block in data:\n                        try:\n                            bc.add_block(block)\n                        except Exception as e:\n                            logger.exception(e)\n                            return\n                        else:\n                            logger.info(f\"Block added: #{block['index']}\")\n                    start += 20\n\n            head = bc.get_head()\n        if not sync_running:\n            app.config['sync_running'] = False\n            logger.info('================== Sync stopped =================')\n            return\n            \ndef broadcast(path, data, params=False, fiter_host=None):\n    for node in list(app.config['nodes'])[:]:\n        if node == ('%s:%s' % (app.config['host'],app.config['port'])) or fiter_host == node:\n            continue\n        url = 'http://%s%s' % (node,path)\n        logger.info(f'Sending broadcast {url} except: {fiter_host}')\n        try:\n            # header added here as we run all nodes on one domain and need somehow understand the sender node\n            # to not create broadcast loop\n            if params:\n                requests.post(url, params=data, timeout=2, headers={'node':'%s:%s' % (app.config['host'],app.config['port'])})   \n            else:\n                requests.post(url, json=data, timeout=2, headers={'node':'%s:%s' % (app.config['host'],app.config['port'])})\n        except:\n            pass\n\ndef mine(event):\n    logger.info('>>>>>>>>>> Starting mining loop')\n    # In real case you chould do like this, mining script should run in separate process\n    while True:\n        try:\n            def check_stop():\n                return event.is_set()\n            logger.info(f'>> Starting new block mining')\n            app.config['api'].mine_block(check_stop)\n            logger.info(f'>> New block mined')\n            broadcast('/chain/add_block', app.config['api'].get_head())\n            if event.is_set():\n                return\n        except asyncio.CancelledError:\n            logger.info('>>>>>>>>>> Mining loop stopped')\n            return\n        except Exception as e:\n            logger.exception(e)\n\n\n### SERVER OPERATIONS\n\n@app.post(\"/chain/stop-mining\")\nasync def stop_mining():\n    if app.jobs.get('mining'):\n        app.jobs['mining'].set()\n        app.jobs['mining'] = None\n\n@app.post(\"/chain/start-mining\")\nasync def start_minig():\n    if not app.jobs.get('mining'):\n        loop = asyncio.get_running_loop()\n        app.jobs['mining'] = asyncio.Event()\n        loop.run_in_executor(None, mine, app.jobs['mining'])\n\n@app.get(\"/server/nodes\")\nasync def get_nodes():\n    return app.config['nodes']\n\n@app.post(\"/server/add_nodes\")\nasync def add_nodes(nodes:NodesModel, request: Request):\n    length = len(app.config['nodes'])\n    app.config['nodes'] |= set(nodes.nodes)\n    if length < len(app.config['nodes']):\n        broadcast('/server/add_nodes', {'nodes':list(app.config['nodes'])}, False, request.headers.get('node'))\n        logger.info(f'New nodes added: {nodes.nodes}')\n    return {\"success\":True}\n\n### DEMO OPERATIONS\n\n@app.get(\"/demo/send_amount\")\nasync def send_amount(address_to:str, amount:int, background_tasks: BackgroundTasks):\n    '''Sending amount of coins from server wallet to some other wallet'''\n\n    address_from = app.config['wallet'].address\n    wallet = app.config['wallet']\n    bc = app.config['api']\n    unspent_txs = bc.get_user_unspent_txs(address_from)\n    total = 0\n    inputs = []\n    i = 0\n    try:\n        while total < amount:\n            prev = unspent_txs[i]\n            inp = Input(prev['tx'],prev['output_index'],address_from,i)\n            inp.sign(wallet)\n            total += prev['amount']\n            i += 1\n            inputs.append(inp)\n    except Exception as e:\n        return {\"success\":False, \"msg\":str(e)}\n\n    outs = [Output(address_to, amount, 0)]\n    if total - amount > 0:\n        outs.append(Output(address_from, total - amount, 1))\n\n    tx = Tx(inputs,outs)\n    try:\n        res = bc.add_tx(tx.as_dict)\n    except Exception as e:\n        logger.exception(e)\n        return {\"success\":False, \"msg\":str(e)}\n    else:\n        if res:\n            logger.info(f'Tx added to the stack')\n            background_tasks.add_task(broadcast, '/chain/tx_create', tx.as_dict, False)\n            return {\"success\":True}\n        logger.info('Tx already in stack. Skipped.')\n        return {\"success\":False, \"msg\":\"Duplicate\"}\n    \n\n### ON CHAIN OPERATIONS\n\n@app.get(\"/chain/get_amount\")\nasync def get_wallet(address):\n    bc = app.config['api']\n    return {\"address\": address, \"amount\":bc.get_user_balance(address)}\n\n@app.get(\"/chain/get_unspent_tx\")\nasync def get_unspent_tx(address):\n    bc = app.config['api']\n    return {\"address\": address, \"tx\":bc.get_user_unspent_txs(address)}\n\n\n@app.get(\"/chain/status\")\nasync def status():\n    bc = app.config['api']\n    head = bc.get_head()\n    if not head:\n        return {'empty_node':True}\n    return {\n        'block_index':head['index'],\n        'block_prev_hash':head['prev_hash'],\n        'block_hash':head['hash'],\n        'timestamp':head['timestamp']\n    }\n\n@app.get(\"/chain/sync\")\nasync def sync(from_block:int, limit:int=20):\n    bc = app.config['api']\n    return bc.get_chain(from_block, limit)\n\n@app.post(\"/chain/add_block\")\nasync def add_block(block:BlockModel, background_tasks: BackgroundTasks, request: Request):\n    logger.info(f\"New block arived: #{block.index} from {request.headers.get('node')}\")\n    if app.config['sync_running']:\n        logger.error(f'################### Not added, cause sync is running')\n        return {\"success\":False, \"msg\":'Out of sync'}\n    bc = app.config['api']\n    head = bc.get_head()\n\n    if (head['index'] + 1) < block.index:\n        app.config['sync_running'] = True\n        background_tasks.add_task(sync_data)\n        logger.error(f'################### Not added, cause node out of sync.')\n        return {\"success\":False, \"msg\":'Out of sync'}\n    try:\n        res = bc.add_block(block.dict())\n        if res: restart_miner()\n    except Exception as e:\n        logger.exception(e)\n        return {\"success\":False, \"msg\":str(e)}\n    else:\n        if res:\n            logger.info('Block added to the chain')\n            background_tasks.add_task(broadcast, '/chain/add_block', block.dict(), False, request.headers.get('node'))\n            return {\"success\":True}\n        logger.info('Old block. Skipped.')\n        return {\"success\":False, \"msg\":\"Duplicate\"}\n\n@app.post(\"/chain/tx_create\")\nasync def add_tx(tx: TxModel, background_tasks: BackgroundTasks, request: Request):\n    logger.info(f'New Tx arived')\n    bc = app.config['api']\n    try:\n        res = bc.add_tx(tx.dict())\n    except Exception as e:\n        logger.exception(e)\n        return {\"success\":False, \"msg\":str(e)}\n    else:\n        if res:\n            logger.info(f'Tx added to the stack')\n            background_tasks.add_task(broadcast, '/chain/tx_create', tx.dict(), False, request.headers.get('node'))\n            return {\"success\":True}\n        logger.info('Tx already in stack. Skipped.')\n        return {\"success\":False, \"msg\":\"Duplicate\"}\n\n@app.on_event(\"startup\")\nasync def on_startup():\n    app.config['sync_running'] = True\n    loop = asyncio.get_running_loop()\n    # sync data before run the node\n    await loop.run_in_executor(None, sync_data)\n    # add our node address to connected node to broadcast around network\n    loop.run_in_executor(None, broadcast, '/server/add_nodes', {'nodes':['%s:%s' % (app.config['host'],app.config['port'])]}, False)\n    if app.config['mine']:\n        app.jobs['mining'] = asyncio.Event()\n        loop.run_in_executor(None, mine, app.jobs['mining'])\n    \n@app.on_event(\"shutdown\")\nasync def on_shutdown():\n    if app.jobs.get('mining'):\n        app.jobs.get('mining').set()\n\n#### Utils ###########################\ndef restart_miner():\n    if app.jobs.get('mining'):\n        loop = asyncio.get_running_loop()\n        app.jobs['mining'].set()\n        app.jobs['mining'] = asyncio.Event()\n        loop.run_in_executor(None, mine, app.jobs['mining'])\n\nif __name__ == \"__main__\":\n\n    logger.setLevel(logging.INFO)\n    handler = logging.StreamHandler(sys.stdout)\n    handler.setFormatter(ColorFormatter())\n    handler.setLevel(logging.INFO)\n    logger.addHandler(handler)\n\n    import argparse\n    parser = argparse.ArgumentParser(description='Blockchain full node.')\n    parser.add_argument('--node', type=str, help='Address of node to connect. If not will init fist node.')\n    parser.add_argument('--port', required=True, type=int, help='Port on which run the node.')\n    parser.add_argument('--mine', required=False, type=bool, help='Port on which run the node.')\n    parser.add_argument('--diff', required=False, type=int, help='Difficulty')\n\n    args = parser.parse_args()\n    _DB = DB()\n    _DB.config['difficulty']\n    _W = Wallet.create()\n    _BC = Blockchain(_DB, _W)\n    _API = API(_BC)\n    logger.info(' ####### Server address: %s ########' %_W.address)\n\n    app.config['db'] = _DB\n    app.config['wallet'] = _W\n    app.config['bc'] = _BC\n    app.config['api'] = _API\n    app.config['port'] = args.port  \n    app.config['host'] = '127.0.0.1'\n    app.config['nodes'] = set([args.node]) if args.node else set(['127.0.0.1:%s' % args.port])\n    app.config['sync_running'] = False\n    app.config['mine'] = args.mine\n\n    if not args.node:\n        _BC.create_first_block()\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=args.port, access_log=True)\n"}

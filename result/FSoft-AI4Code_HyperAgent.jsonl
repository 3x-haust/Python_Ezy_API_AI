{"repo_info": {"repo_name": "HyperAgent", "repo_owner": "FSoft-AI4Code", "repo_url": "https://github.com/FSoft-AI4Code/HyperAgent"}}
{"type": "test_file", "path": "tests/test_lsptoolkit.py", "content": ""}
{"type": "test_file", "path": "tests/tools/python/go_to_def.py", "content": "from hyperagent.tools.tools import GoToDefinitionTool\n\ndef get_all_symbols():\n    gst = GoToDefinitionTool(\"/datadrive05/huypn16/focalcoder/data/repos/repo__TempleRAIL__drl_vo_nav__commit__\", language=\"python\")\n    symbols = gst._run(relative_path=\"drl_vo/src/custom_cnn_full.py\", line=272, word=\"_forward_impl\")\n    print(symbols)\n    \nif __name__ == \"__main__\":\n    get_all_symbols()"}
{"type": "test_file", "path": "tests/test_zoek.py", "content": "from codetext.utils import build_language\nfrom hyperagent.code_search import search_elements_inside_project\nfrom hyperagent.zoekt.zoekt_server import ZoektServer\nlanguage = \"rust\"\npath = \"data/repos/tokenizers\"\nbackend = ZoektServer(language)\nbackend.setup_index(path)\nbuild_language(language)\n\n# we want to search function is_valid_sentencepiece method inside the project in Rust lang\nresults = search_elements_inside_project([\"Unigram\"], backend, verbose=True, language=language)\nprint(results[\"Unigram\"][0][\"implementation\"])"}
{"type": "source_file", "path": "scripts/data_getsql.py", "content": "import sqlite3\nimport ast\nimport pickle\nimport tqdm\nfrom transformers import AutoTokenizer\nimport json\n\n# Path to your SQLite database file\ndb_path = '.cache/41/cache.db'\nconnection = sqlite3.connect(db_path)\n\n# Create a cursor object to interact with the database\ncursor = connection.cursor()\n\n# Example query: Get all tables in the database\ncursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n\ntables = cursor.fetchall()\nprint(\"Tables in the database:\", tables)\ncursor.execute(\"SELECT * FROM Cache;\")\nrows = cursor.fetchall()\ndata = []\n\nfor row in tqdm.tqdm(rows):\n    append_flag = False\n    completion = pickle.loads(row[11]).choices[0].message\n    prompt_messages = [message for message in ast.literal_eval(row[1])[\"messages\"]]\n    for message in prompt_messages:\n        if \"name\" in message.keys():\n            if \"Navigator Interpreter\" == message[\"name\"]:\n                append_flag = True\n    \n    if append_flag:\n        messages = [message[\"content\"] for message in prompt_messages]\n\n        def map_role(index: int):\n            if index == 0:\n                return \"system\"\n            elif index % 2 == 1:\n                return \"user\"\n            else:\n                return \"assistant\"\n\n        convo_messages = [{\"role\": map_role(i), \"content\": message} for i, message in enumerate(messages) if \"exit code: 1\" not in message]\n        \n        data.append(\n            {\n                \"messages\": convo_messages,\n            }\n        )\n\nwith open(\"data/data_instruct_nav.json\", \"w\") as f:\n    json.dump(data, f, indent=4)\nprint('Total data:', len(data))\n# tokenizer = AutoTokenizer.from_pretrained(\"meta-llama/Meta-Llama-3-8B-Instruct\")\n\n# prompt_lens = []\n# completion_lens = []\n# for data_point in tqdm.tqdm(data):\n#     prompt_length = len(tokenizer.encode(\" \".join(data_point[\"prompt\"])))\n#     completion_length = len(tokenizer.encode(data_point[\"completion\"]))\n#     prompt_lens.append(prompt_length)\n#     completion_lens.append(completion_length)\n\n# #common stats\n# print(\"Prompt length stats:\")\n# print(\"Min:\", min(prompt_lens))\n# print(\"Max:\", max(prompt_lens))\n# print(\"Mean:\", sum(prompt_lens) / len(prompt_lens))\n# print(\"Median:\", sorted(prompt_lens)[len(prompt_lens) // 2])\n# print(\"Prompt length stats:\")\n# print(\"Min:\", min(completion_lens))\n# print(\"Max:\", max(completion_lens))\n# print(\"Mean:\", sum(completion_lens) / len(completion_lens))\n# print(\"Median:\", sorted(completion_lens)[len(completion_lens) // 2])\n\n# print(\"Total tokens:\", sum(prompt_lens) + sum(completion_lens))\n\n# Close the cursor and connection\ncursor.close()\nconnection.close()"}
{"type": "source_file", "path": "setup.py", "content": "from setuptools import setup, find_packages\nimport os\n\nwith open('requirements.txt') as f:\n    required = f.read().splitlines()\n\nVERSION = '0.0.1' \n# Setting up\nsetup(\n        name=\"hyperagent\", \n        version=VERSION,\n        author=\"Huy Phan Nhat\",\n        author_email=\"HuyPN16@fpt.com\",\n        packages=find_packages(where=\"src\"),\n        package_dir={'': 'src'},\n        install_reqs=required,\n        entry_points={\"console_scripts\": ['hyperagent = hyperagent.cli.cli:app',],},\n)"}
{"type": "source_file", "path": "scripts/convert_swe.py", "content": "from datasets import load_dataset\nimport json\nimport tqdm \n\noutput_file = \"outputs/gpt4o.jsonl\"\n\ndata = []\nwith open(output_file, \"r\") as f:\n    lines = f.readlines()\n    for line in tqdm.tqdm(lines):\n        try:\n            pred = json.loads('{' + '\"model_patch' + line.split(\"model_patch\")[1])\n            if pred[\"model_patch\"] == \"\":\n                continue\n            data.append(pred)\n        except:\n            continue\n# File path for the output JSON file\n\noutput_file = 'convert_preds_gpt4o.json'\n\ninstance_ids = [instance[\"instance_id\"] for instance in data]\n\n# Writing the list to a JSON file as a JSON array\nwith open(output_file, 'w') as file:\n    json.dump(data, file, indent=4)\n\ndataset = load_dataset(\"princeton-nlp/SWE-bench_Lite\")[\"test\"]\ndataset = dataset.filter(lambda x: x[\"instance_id\"] in instance_ids)\n# dataset = dataset.select(range(1,186))\ndataset.to_json(\"task_instances.jsonl\")"}
{"type": "source_file", "path": "src/hyperagent/agents/llms.py", "content": "from typing import Any\nfrom openai import OpenAI, AzureOpenAI\nfrom vllm import LLM as vLLM\nfrom transformers import AutoTokenizer, AutoConfig\nfrom groq import Groq\nimport os\n\ndef truncate_tokens_hf(string: str, encoding_name: str) -> str:\n    \"\"\"Truncates a text string based on max number of tokens.\"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"meta-llama/Meta-Llama-3-8B-Instruct\")\n    max_tokens = AutoConfig.from_pretrained(\"meta-llama/Meta-Llama-3-8B-Instruct\").max_position_embeddings\n    encoded_string = tokenizer.encode(string, return_tensors=\"pt\")\n    num_tokens = len(encoded_string[0])\n\n    if num_tokens > max_tokens:\n        string = tokenizer.decode(encoded_string[0][-max_tokens+1000:])\n\n    return string\n\nclass LLM:\n    def __init__(self, config):\n        self.system_prompt = config[\"system_prompt\"]\n        self.config = config\n    \n    def __call__(self, *args: Any, **kwds: Any) -> Any:\n        pass\n\nclass GroqLLM(LLM):\n    def __init__(self, config):\n        super().__init__(config)\n        self.client = Groq(\n            api_key=os.environ[\"GROQ_API_KEY\"],\n        )\n    \n    def __call__(self, prompt: str):\n        response = self.client.chat.completions.create(\n            messages = [\n                {\"role\": \"system\", \"content\": self.system_prompt},\n                {\"role\": \"user\", \"content\": prompt},\n            ],\n            model = self.config[\"model\"],\n        )\n        return response.choices[0].message.content\n\n\nclass LocalLLM(LLM):\n    def __init__(self, config):\n        super().__init__(config)\n        openai_api_key = os.environ[\"TOGETHER_API_KEY\"]\n        openai_api_base = \"https://api.together.xyz\"\n        # openai_api_base = \"http://localhost:8004/v1\"\n        # openai_api_key=\"token-abc123\"\n\n\n        self.client = OpenAI(\n            api_key=openai_api_key,\n            base_url=openai_api_base,\n        )\n\n    def __call__(self, prompt: str):\n        prompt = truncate_tokens_hf(prompt, encoding_name=self.config[\"model\"])\n        response = self.client.chat.completions.create(\n            temperature=0,\n            model=self.config[\"model\"],\n            messages=[\n                {\"role\": \"system\", \"content\": self.system_prompt},\n                {\"role\": \"user\", \"content\": prompt},\n            ],\n            max_tokens=None\n        )\n        return response.choices[0].message.content\n    \n\nclass OpenAILLM(LLM):\n    def __init__(self, config):\n        super().__init__(config)\n        if \"openai_api_key\" in config:\n            openai_api_key = config[\"openai_api_key\"]\n        elif \"OPENAI_API_KEY\" in os.environ:\n            openai_api_key = os.environ[\"OPENAI_API_KEY\"]\n        else:\n            assert False, \"OpenAI API key not found\"\n        self.client = OpenAI(\n            api_key=openai_api_key,\n        )\n\n    def __call__(self, prompt: str):\n        # The line `prompt = truncate_tokens(prompt, encoding_name=self.config[\"model\"],\n        # max_length=self.config[\"max_tokens\"])` is calling a function named `truncate_tokens` with\n        # three arguments: `prompt`, `encoding_name`, and `max_length`. This function is likely used\n        # to truncate the input `prompt` to a specified maximum length based on the model being used\n        # and the maximum tokens allowed.\n        # prompt = truncate_tokens(prompt, encoding_name=self.config[\"model\"], max_length=self.config[\"max_tokens\"])\n        response = self.client.chat.completions.create(\n            temperature=0,\n            model=self.config[\"model\"],\n            messages=[\n                {\"role\": \"system\", \"content\": self.system_prompt},\n                {\"role\": \"user\", \"content\": prompt},\n            ]\n        )\n        return response.choices[0].message.content\n\n\nclass AzureLLM(LLM):\n    def __init__(self, config):\n        super().__init__(config)\n        if \"openai_api_key\" in config:\n            openai_api_key = config[\"openai_api_key\"]\n        elif \"OPENAI_API_KEY\" in os.environ:\n            openai_api_key = os.environ[\"OPENAI_API_KEY\"]\n        else:\n            assert False, \"OpenAI API key not found\"\n\n        self.client = AzureOpenAI(\n            azure_endpoint=os.environ[\"AZURE_ENDPOINT_GPT35\"] if \"gpt35\" in self.config[\"model\"] else os.environ[\"AZURE_ENDPOINT_GPT4\"],\n            api_key=openai_api_key,\n            api_version=os.environ[\"API_VERSION\"],\n            azure_deployment=\"ai4code-research-gpt4o\"\n        )\n\n    def __call__(self, prompt: str):\n        # prompt = truncate_tokens(prompt, encoding_name=self.config[\"model\"], max_length=self.config[\"max_tokens\"])\n        response = self.client.chat.completions.create(\n            temperature=0,\n            model=self.config[\"model\"],\n            messages=[\n                {\"role\": \"system\", \"content\": self.system_prompt},\n                {\"role\": \"user\", \"content\": prompt},\n            ]\n        )\n        return response.choices[0].message.content\n\nclass VLLM(LLM):\n    def __init__(self, config):\n        super().__init__(config)\n        self.client = vLLM(\n            model = config[\"model\"], \n            tensor_parallel_size = 2,\n        )\n        self.system_prompt = config[\"system_prompt\"]\n    \n    def __call__(self, prompt: str):\n        composed_prompt = f\"{self.system_prompt} {prompt}\"\n        response = self.client.generate(composed_prompt)\n        return response[0].outputs[0].text\n    \n    \nif __name__ == \"__main__\":\n    config = {\n        \"model\": \"gradientai/Llama-3-8B-Instruct-Gradient-1048k\",\n        \"system_prompt\": \"Being an helpful AI, I will help you with your queries. Please ask me anything.\"\n    }\n    llm = VLLM(config)\n    llm(\"How to create a new column in pandas dataframe?\")"}
{"type": "source_file", "path": "scripts/fine_tuning.py", "content": "from datasets import Dataset\nimport glob\nimport os\nimport json\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig,HfArgumentParser,TrainingArguments,pipeline, logging\nimport transformers\nfrom peft import LoraConfig, PeftModel, prepare_model_for_kbit_training, get_peft_model\nimport json\nimport torch\nfrom transformers import (\n    AutoModelForCausalLM,\n    AutoTokenizer,\n    BitsAndBytesConfig,\n    TrainingArguments,\n)\nfrom trl import SFTTrainer\n\ndef get_data():\n    data_folder = \"data/agent_trajectories/nav\"\n    all_json_files = glob.glob(os.path.join(data_folder, \"**/*.json\"), recursive=True)\n    system = []\n    chat = []\n    responses = []\n    for file in all_json_files:\n        with open(file, \"r\") as f:\n            data = json.load(f)\n        system.append(data[\"system_prompt\"])\n        chat.append(data[\"human_message\"])\n        responses.append(data[\"system_response\"]) \n    \n    def create_text_row(system_instruction, input, output):\n        text_row = f\"\"\"<s>[INST] <</SYS>>\\\\nSystem: {system_instruction}\\\\n<</SYS>>\\\\n\\\\nHuman: {input}[/INST] \\nAssistant: \\n{output}</s>\"\"\"\n        return text_row\n\n    with open(\"data/hyperagent_traces.jsonl\", \"w\") as f:\n        for prompt, input, output in zip(system, chat, responses):\n            object = {\n                \"text\": create_text_row(prompt, input, output)\n            }\n            json.dump(object, f)\n            f.write(\"\\n\")\n                \n    train_dataset = Dataset.from_dict({\n        \"text\": [create_text_row(system_instruction, input, output) for system_instruction, input, output in zip(system, chat, responses)]\n    })\n    return train_dataset\n    \ndef main():\n    base_model_id = \"\"\n    base_model = AutoModelForCausalLM.from_pretrained(\n        base_model_id,\n        load_in_4bit=True,\n        quantization_config=bnb_config,\n        torch_dtype=torch.bfloat16,\n        device_map=\"auto\",\n        trust_remote_code=True,\n    )\n    \n    base_model.config.use_cache = False # silence the warnings. Please re-enable for inference!\n    base_model.config.pretraining_tp = 1\n    base_model.gradient_checkpointing_enable()\n\n    # Load tokenizer\n    tokenizer = AutoTokenizer.from_pretrained(base_model_id, trust_remote_code=True)\n    tokenizer.padding_side = 'right'\n    tokenizer.pad_token = tokenizer.eos_token\n    tokenizer.add_eos_token = True\n\n\n    project = \"hyperagent\"\n    # base_model_name = \"mistral\"\n    base_model_name = \"codellama\"\n    run_name = base_model_name + \"_\" + project\n    output_dir = \"model/\" + run_name\n\n    model = prepare_model_for_kbit_training(base_model)\n    peft_config = LoraConfig(\n        lora_alpha=16,\n        lora_dropout=0.1,\n        r=64,\n        bias=\"none\",\n        task_type=\"CAUSAL_LM\",\n        target_modules=[\"q_proj\", \"k_proj\", \"v_proj\", \"o_proj\",\"gate_proj\"]\n    )\n    model = get_peft_model(model, peft_config)\n    \n    #Hyperparamter\n    training_arguments = TrainingArguments(\n        output_dir=output_dir,\n        num_train_epochs=1,\n        per_device_train_batch_size=4,\n        gradient_accumulation_steps=1,\n        optim=\"paged_adamw_32bit\",\n        save_steps=25,\n        logging_steps=25,\n        learning_rate=2e-4,\n        weight_decay=0.001,\n        fp16=False,\n        bf16=False,\n        max_grad_norm=0.3,\n        max_steps=-1,\n        warmup_ratio=0.03,\n        group_by_length=True,\n        lr_scheduler_type=\"constant\",\n        report_to=\"wandb\"\n    )\n\n    # Initialize the SFTTrainer for fine-tuning\n    # Setting sft parameters\n    trainer = SFTTrainer(\n        model=model,\n        train_dataset=get_data(),\n        peft_config=peft_config,\n        max_seq_length= None,\n        dataset_text_field=\"text\",\n        tokenizer=tokenizer,\n        args=training_arguments,\n        packing= False,\n    )\n    trainer.train()\n    model.save_pretrained(output_dir)\n\nif __name__ == \"__main__\":\n    main()"}
{"type": "source_file", "path": "src/hyperagent/__init__.py", "content": "from hyperagent.pilot import HyperAgent\nfrom hyperagent import prompts\n\n__all__ = ['HyperAgent']"}
{"type": "source_file", "path": "src/hyperagent/multilspy/multilspy_exceptions.py", "content": "\"\"\"\nThis module contains the exceptions raised by the Multilspy framework.\n\"\"\"\n\nclass MultilspyException(Exception):\n    \"\"\"\n    Exceptions raised by the Multilspy framework.\n    \"\"\"\n\n    def __init__(self, message: str):\n        \"\"\"\n        Initializes the exception with the given message.\n        \"\"\"\n        super().__init__(message)"}
{"type": "source_file", "path": "src/hyperagent/langchain_parsers/language/java.py", "content": "from typing import TYPE_CHECKING\n\nfrom hyperagent.langchain_parsers.language.tree_sitter_segmenter import (\n    TreeSitterSegmenter,\n)\n\nif TYPE_CHECKING:\n    from tree_sitter import Language\n\n\nCHUNK_QUERY = \"\"\"\n    [\n        (class_declaration) @class\n        (interface_declaration) @interface\n        (enum_declaration) @enum\n    ]\n\"\"\".strip()\n\n\nclass JavaSegmenter(TreeSitterSegmenter):\n    \"\"\"Code segmenter for Java.\"\"\"\n\n    def get_language(self) -> \"Language\":\n        from tree_sitter_languages import get_language\n\n        return get_language(\"java\")\n\n    def get_chunk_query(self) -> str:\n        return CHUNK_QUERY\n\n    def make_line_comment(self, text: str) -> str:\n        return f\"// {text}\""}
{"type": "source_file", "path": "scripts/unslot_training.py", "content": "from unsloth import FastLanguageModel \nfrom unsloth import is_bfloat16_supported\nfrom unsloth.chat_templates import get_chat_template\nimport torch\nfrom trl import SFTTrainer\nfrom transformers import TrainingArguments\nfrom datasets import load_dataset\nmax_seq_length = 70000 # Supports RoPE Scaling interally, so choose any!\n\n\nmodel, tokenizer = FastLanguageModel.from_pretrained(\n    model_name = \"unsloth/llama-3-8b-Instruct-bnb-4bit\",\n    max_seq_length = max_seq_length,\n    dtype = None,\n    load_in_4bit = False,\n)\n\n\ntokenizer = get_chat_template(\n    tokenizer,\n    # mapping={\"role\": \"role\", \"content\": \"value\", \"user\": \"human\", \"assistant\": \"gpt\", \"system\": \"system\"},\n    chat_template=\"llama-3\",\n)\n\ndef apply_template(examples):\n    messages = examples[\"messages\"]\n    text = tokenizer.apply_chat_template(messages, tokenize=False, add_generation_prompt=False)\n    return {\"text\": text}\n\ndataset = load_dataset(\"json\", data_files=\"data/data_instruct_nav.json\", split=\"train\")\ndataset = dataset.map(apply_template)\n\n\n# 4bit pre quantized models we support for 4x faster downloading + no OOMs.\nfourbit_models = [\n    \"unsloth/mistral-7b-v0.3-bnb-4bit\",      # New Mistral v3 2x faster!\n    \"unsloth/mistral-7b-instruct-v0.3-bnb-4bit\",\n    \"unsloth/llama-3-8b-bnb-4bit\",           # Llama-3 15 trillion tokens model 2x faster!\n    \"unsloth/llama-3-8b-Instruct-bnb-4bit\",\n    \"unsloth/llama-3-70b-bnb-4bit\",\n    \"unsloth/Phi-3-mini-4k-instruct\",        # Phi-3 2x faster!\n    \"unsloth/Phi-3-medium-4k-instruct\",\n    \"unsloth/mistral-7b-bnb-4bit\",\n    \"unsloth/gemma-7b-bnb-4bit\",             # Gemma 2.2x faster!\n] # More models at https://huggingface.co/unsloth\n\n# Do model patching and add fast LoRA weights\nmodel = FastLanguageModel.get_peft_model(\n    model,\n    r = 32,\n    target_modules = [\"q_proj\", \"k_proj\", \"v_proj\", \"o_proj\",\n                      \"gate_proj\", \"up_proj\", \"down_proj\",],\n    lora_alpha = 16,\n    lora_dropout = 0, # Supports any, but = 0 is optimized\n    bias = \"none\",    # Supports any, but = \"none\" is optimized\n    use_gradient_checkpointing = \"unsloth\", # True or \"unsloth\" for very long context\n    random_state = 3407,\n    max_seq_length = max_seq_length,\n    use_rslora = False,  # We support rank stabilized LoRA\n    loftq_config = None, # And LoftQ\n)\n\ntrainer = SFTTrainer(\n    model = model,\n    train_dataset = dataset,\n    dataset_text_field = \"text\",\n    max_seq_length = max_seq_length,\n    tokenizer = tokenizer,\n    args = TrainingArguments(\n        per_device_train_batch_size = 2,\n        gradient_accumulation_steps = 4,\n        warmup_steps = 20,\n        max_steps = 2000,\n        fp16 = not is_bfloat16_supported(),\n        bf16 = is_bfloat16_supported(),\n        logging_steps = 1,\n        output_dir = \"outputs\",\n        optim = \"adamw_8bit\",\n        seed = 3407,\n    ),\n)\ntrainer.train()\n"}
{"type": "source_file", "path": "src/hyperagent/langchain_parsers/language/csharp.py", "content": "from typing import TYPE_CHECKING\n\nfrom hyperagent.langchain_parsers.language.tree_sitter_segmenter import (\n    TreeSitterSegmenter,\n)\n\nif TYPE_CHECKING:\n    from tree_sitter import Language\n\n\nCHUNK_QUERY = \"\"\"\n    [\n        (namespace_declaration) @namespace\n        (class_declaration) @class\n        (method_declaration) @method\n        (interface_declaration) @interface\n        (enum_declaration) @enum\n        (struct_declaration) @struct\n        (record_declaration) @record\n    ]\n\"\"\".strip()\n\n\nclass CSharpSegmenter(TreeSitterSegmenter):\n    \"\"\"Code segmenter for C#.\"\"\"\n\n    def get_language(self) -> \"Language\":\n        from tree_sitter_languages import get_language\n\n        return get_language(\"c_sharp\")\n\n    def get_chunk_query(self) -> str:\n        return CHUNK_QUERY\n\n    def make_line_comment(self, text: str) -> str:\n        return f\"// {text}\""}
{"type": "source_file", "path": "src/hyperagent/constants.py", "content": "import os\n\nDEFAULT_GH_TOKEN = os.environ.get(\"GITHUB_TOKEN\", None)\nDEFAULT_DEVICES = \"0\"\nDEFAULT_CLONE_DIR = \"data/repos\"\nSEMANTIC_CODE_SEARCH_DB_PATH = \"/tmp/semantic_code_search_hyperagent/\"\nZOEKT_CODE_SEARCH_INDEX_PATH = \"/tmp/zoekt_code_search_hyperagent/\"\nDEFAULT_PATCHES_DIR = \"/tmp/hyperagent/patches\"\nDEFAULT_WORKDIR_CLI = \"/tmp/hyperagent/\"\nDEFAULT_PLANNER_TYPE = \"static\"\nDEFAULT_VLLM_PORT = 5200\nDEFAULT_LANGUAGE = \"python\"\nDEFAULT_VERBOSE_LEVEL = 1\nDEFAULT_TRAJECTORIES_PATH = \"/datadrive5/huypn16/HyperAgent/data/agent_trajectories/nav\"\nDO_NOT_SUMMARIZED_KEYS = [\"python\", \"code_snippet\"]\n\nDEFAULT_LLM_CONFIGS = {\n        \"name\": \"claude\",\n        \"nav\": [{\n            \"model\": \"claude-3-haiku-20240307\",\n            \"api_key\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"edit\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_key\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"exec\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"plan\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"type\": \"patch\"\n    }\nDEFAULT_IMAGE_NAME = \"python:3-slim\"\nD4J_FOLDER = \"/datadrive5/huypn16/defects4j\""}
{"type": "source_file", "path": "scripts/run_swe_bench.py", "content": "from hyperagent import HyperAgent\nfrom argparse import ArgumentParser\nfrom hyperagent.tasks.github_issue_resolve import SWEBench\nimport json\nimport os\nimport json\nimport subprocess\n\ndef get_args():\n    parser = ArgumentParser()\n    parser.add_argument(\"--split\", type=str, default=\"verified\")\n    parser.add_argument(\"--output_folder\", type=str, default=\"outputs/\")\n    parser.add_argument(\"--model_nick_name\", type=str, default=\"claude-mini\")\n    return parser.parse_args()\n\ndef main():\n    args = get_args()\n\n    subprocess.run([\"sudo\", \"rm\", \"-rf\", \"data/repos\"])\n    subprocess.run([\"sudo\", \"mkdir\", \"-p\", \"data/repos\"])\n    subprocess.run([\"sudo\", \"chmod\", \"777\", \"data/repos\"])\n\n    config = {\n        \"name\": \"claude\",\n        \"nav\": [{\n            \"model\": \"claude-3-haiku-20240307\",\n            \"api_key\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"edit\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_key\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"exec\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"plan\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"type\": \"patch\"\n    }\n    \n    task = SWEBench(logdir=\"results/swe_bench\", split=args.split)\n    for idx in range(len(task)):\n        repo_link, commit, instance_id, image_name = task[idx]\n        success = False\n        retry = 0\n        while success != True:\n            pilot = HyperAgent(\n                repo_path=repo_link,\n                commit=commit,\n                language=\"python\",\n                clone_dir=\"data/repos\",\n                llm_configs=config,\n                image_name=image_name,\n                verbose=1\n            )\n            try:\n                patch = task.run(pilot, idx)\n            except Exception as e:\n                print(e)\n                patch = \"\"\n            if len(patch) > 0:\n                success = True\n            retry += 1\n\n            if retry > 3:\n                break\n\n        output_dict = {}\n\n        output_dict[\"model_patch\"] = patch\n        output_dict[\"instance_id\"] = instance_id\n        output_dict[\"model_name_or_path\"] = \"hyperagent\"\n\n        output_file = os.path.join(args.output_folder, f\"{args.model_nick_name}.jsonl\")\n        with open(output_file, \"a+\") as f:\n            json.dump(output_dict, f)\n            f.write(\"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"type": "source_file", "path": "scripts/run_defects4j_fl.py", "content": "from hyperagent import HyperAgent\nfrom argparse import ArgumentParser\nfrom hyperagent.tasks.fault_localization import FaultLocalization\nfrom hyperagent.constants import D4J_FOLDER\nimport os\nimport yaml\n\ndef load_yaml_config(file_path):\n    with open(file_path, 'r') as file:\n        config = yaml.safe_load(file)\n    return config\n\ndef main():\n    config = {\n        \"name\": \"claude\",\n        \"nav\": [{\n            \"model\": \"claude-3-haiku-20240307\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"edit\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"exec\": [{\n            \"model\": \"claude-3-haiku-20240307\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"plan\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"type\": \"pred\"\n    }\n    \n    task = FaultLocalization(\"results/defects4j_fl\", \"test\", max_repetitions=1, max_num_tests=2, defects4j=D4J_FOLDER)\n    result_list = []\n    for idx in range(len(task)):\n        repo_dir = task[idx]\n        pilot = HyperAgent(\n            repo_path=repo_dir,\n            commit=\"\",\n            language=\"java\",\n            llm_configs=config,\n            verbose=2,\n        )\n        result = task.run(pilot, idx)\n        result_list.append(result)\n        performance_table = task.report(result_list)\n        print(performance_table)\n    \nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "src/hyperagent/build.py", "content": "import docker\nfrom hyperagent.tools.tools import *\nfrom hyperagent.prompts.utils import jupyter_prompt\nfrom autogen.coding.base import CodeBlock\nfrom autogen.coding.jupyter import EmbeddedIPythonCodeExecutor\nfrom autogen.coding import DockerCommandLineCodeExecutor\nfrom autogen.coding.docker_commandline_code_executor import _wait_for_ready\nfrom autogen.coding.base import CodeBlock, CommandLineCodeResult\nfrom autogen.code_utils import TIMEOUT_MSG, _cmd\nfrom autogen.coding.utils import _get_file_name_from_content, silence_pip\nfrom hashlib import md5\n\nimport atexit\nimport logging\nfrom typing import Any, ClassVar, Dict, List, Optional, Type, Union\n\nfrom docker.errors import ImageNotFound\nfrom pathlib import Path\n\nclass EICE(EmbeddedIPythonCodeExecutor):\n    # Override the execute_code_blocks method to only execute the tool functions or initialization of these functions. \n    def execute_code_blocks(self, code_blocks: List[CodeBlock]):\n        tool_call_code_blocks = [block for block in code_blocks if \"_run\" in block.code or \"Initialize\" in block.code]\n        return super().execute_code_blocks(tool_call_code_blocks)\n\nclass DCLCE(DockerCommandLineCodeExecutor):\n    def __init__(\n        self,\n        image: str = \"python:3-slim\",\n        container_name: Optional[str] = None,\n        timeout: int = 60,\n        work_dir: Union[Path, str] = Path(\".\"),\n        bind_dir: Optional[Union[Path, str]] = None,\n        auto_remove: bool = True,\n        stop_container: bool = True,\n        execution_policies: Optional[Dict[str, bool]] = None,\n    ):\n        if timeout < 1:\n            raise ValueError(\"Timeout must be greater than or equal to 1.\")\n\n        if isinstance(work_dir, str):\n            work_dir = Path(work_dir)\n        work_dir.mkdir(exist_ok=True)\n\n        if bind_dir is None:\n            bind_dir = work_dir\n        elif isinstance(bind_dir, str):\n            bind_dir = Path(bind_dir)\n\n        client = docker.from_env()\n        # Check if the image exists\n        try:\n            client.images.get(image)\n        except ImageNotFound:\n            logging.info(f\"Pulling image {image}...\")\n            # Let the docker exception escape if this fails.\n            client.images.pull(image)\n\n        if container_name is None:\n            container_name = f\"autogen-code-exec-{uuid.uuid4()}\"\n\n        # Start a container from the image, read to exec commands later\n        self._container = client.containers.create(\n            image,\n            name=container_name,\n            entrypoint=\"/bin/sh\",\n            tty=True,\n            auto_remove=auto_remove,\n            volumes={str(bind_dir.resolve()): {\"bind\": \"/workspace/repository\", \"mode\": \"rw\"}, str(work_dir.resolve()): {\"bind\": \"/workspace\", \"mode\": \"rw\"}},\n            working_dir=\"/workspace\",\n        )\n        self._container.start()\n\n        _wait_for_ready(self._container)\n\n        def cleanup() -> None:\n            try:\n                container = client.containers.get(container_name)\n                container.stop()\n            except docker.errors.NotFound:\n                pass\n            atexit.unregister(cleanup)\n\n        if stop_container:\n            atexit.register(cleanup)\n\n        self._cleanup = cleanup\n\n        # Check if the container is running\n        if self._container.status != \"running\":\n            raise ValueError(f\"Failed to start container from image {image}. Logs: {self._container.logs()}\")\n\n        self._timeout = timeout\n        self._work_dir: Path = work_dir\n        self._bind_dir: Path = bind_dir\n        self.execution_policies = self.DEFAULT_EXECUTION_POLICY.copy()\n        if execution_policies is not None:\n            self.execution_policies.update(execution_policies)\n        \n        self.command_history = []\n        self.latest_execution_out_str = \"\"\n    \n    def execute_code_blocks(self, code_blocks: List[CodeBlock]) -> CommandLineCodeResult:\n        \"\"\"(Experimental) Execute the code blocks and return the result.\n\n        Args:\n            code_blocks (List[CodeBlock]): The code blocks to execute.\n\n        Returns:\n            CommandlineCodeResult: The result of the code execution.\"\"\"\n\n        if len(code_blocks) == 0:\n            raise ValueError(\"No code blocks to execute.\")\n\n        outputs = []\n        files = []\n        last_exit_code = 0\n        for code_block in code_blocks:\n            lang = self.LANGUAGE_ALIASES.get(code_block.language.lower(), code_block.language.lower())\n            if lang not in self.DEFAULT_EXECUTION_POLICY:\n                outputs.append(f\"Unsupported language {lang}\\n\")\n                last_exit_code = 1\n                break\n\n            execute_code = self.execution_policies.get(lang, False)\n            code = silence_pip(code_block.code, lang)\n\n            # Check if there is a filename comment\n            try:\n                filename = _get_file_name_from_content(code, self._work_dir)\n            except ValueError:\n                outputs.append(\"Filename is not in the workspace\")\n                last_exit_code = 1\n                break\n\n            if not filename:\n                filename = f\"tmp_code_{md5(code.encode()).hexdigest()}.{lang}\"\n\n            code_path = self._work_dir / filename\n\n            with code_path.open(\"w\", encoding=\"utf-8\") as fout:\n                fout.write(\"source /opt/miniconda3/bin/activate\\n\")\n                fout.write(\"conda activate testbed\\n\")\n                fout.write(\"cd /workspace/repository\\n\")\n                fout.write(code)\n            files.append(code_path)\n\n            if not execute_code:\n                outputs.append(f\"Code saved to {str(code_path)}\\n\")\n                continue\n\n            command = [\"timeout\", str(self._timeout), _cmd(lang), filename]\n            result = self._container.exec_run(command)\n            exit_code = result.exit_code\n            output = result.output.decode(\"utf-8\")\n            if exit_code == 124:\n                output += \"\\n\" + TIMEOUT_MSG\n            outputs.append(output)\n\n            last_exit_code = exit_code\n            if exit_code != 0:\n                break\n\n        code_file = str(files[0]) if files else None\n        return CommandLineCodeResult(exit_code=last_exit_code, output=\"\".join(outputs), code_file=code_file)\n    \ndef initialize_tools(repo_dir, db_path, index_path, language, image_name):\n    initialized_codeblock = jupyter_prompt.format(repo_dir=repo_dir, index_path=index_path, language=language)\n    initialized_codeblock = CodeBlock(code=initialized_codeblock, language=\"python\")\n    \n    jupyter_executor = EICE(kernel_name=\"hyperagent\", timeout=120)\n    result = jupyter_executor.execute_code_blocks([initialized_codeblock])\n    \n    if result.exit_code != 0:\n        print(\"bug!\", result)\n        raise Exception(f\"Failed to initialize tools: {result}\")\n    else:\n        print(\"Tools initialized successfully\")\n\n    docker_executor = DCLCE(image=image_name, bind_dir=repo_dir, work_dir=\"/tmp/autogen\")    \n    return jupyter_executor, docker_executor\n\nif __name__ == \"__main__\":\n    repo_dir = \"/datadrive5/huypn16/HyperAgent-Master/data/repos/repo__astropy__astropy__commit__19cc80471739bcb67b7e8099246b391c355023ee\"\n    docker_executor = DCLCE(image=\"sweb.eval.x86_64.astropy__astropy-13453:latest\", bind_dir=repo_dir, work_dir=\"/tmp/autogen\")\n\n    from hyperagent.prompts.executor import system_exec\n    from autogen import UserProxyAgent, AssistantAgent, GroupChat, GroupChatManager, Agent, ConversableAgent\n    from autogen.agentchat.contrib.society_of_mind_agent import SocietyOfMindAgent \n\n    llm_config = [{\n        \"model\": \"claude-3-5-sonnet-20240620\",\n        \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n        \"stop_sequences\": [\"\\nObservation:\"],\n        \"price\": [0.003, 0.015],\n        \"base_url\": \"https://api.anthropic.com\",\n        \"api_type\": \"anthropic\",\n    }]\n\n    executor_assistant = AssistantAgent(\n        \"Inner-Executor-Assistant\",\n        system_message=system_exec,\n        llm_config={\"config_list\": llm_config},\n        human_input_mode=\"NEVER\",\n    )\n\n    executor_interpreter = UserProxyAgent(\n        name=\"Executor Interpreter\",\n        llm_config=False,\n        code_execution_config={\n            \"executor\": docker_executor,\n        },\n        human_input_mode=\"NEVER\",\n        default_auto_reply=\"\",\n    )\n\n    groupchat_exec = GroupChat(\n        agents=[executor_assistant, executor_interpreter],\n        messages=[],\n        speaker_selection_method=\"round_robin\",  # With two agents, this is equivalent to a 1:1 conversation.\n        allow_repeat_speaker=False,\n        max_round=15,\n    )\n    \n    manager_exec = GroupChatManager(\n        groupchat=groupchat_exec,\n        name=\"Executor Manager\",\n        llm_config={\"config_list\": llm_config},\n        max_consecutive_auto_reply=0\n    )\n    \n    executor = SocietyOfMindAgent(\n        \"Executor\",\n        chat_manager=manager_exec,\n        llm_config={\"config_list\": llm_config},\n        # response_preparer=response_preparer\n    )\n\n    user_proxy = UserProxyAgent(\n        name=\"Admin\",\n        system_message=\"A human admin. Interact with the planner to discuss the plan to resolve a codebase-related query.\",\n        human_input_mode=\"ALWAYS\",\n        code_execution_config=False,\n        default_auto_reply=\"\",\n        max_consecutive_auto_reply=0\n    )\n\n    user_proxy.initiate_chat(executor, message=\"how many folders inside the project\")"}
{"type": "source_file", "path": "src/hyperagent/multilspy/multilspy_config.py", "content": "\"\"\"\nConfiguration parameters for Multilspy.\n\"\"\"\n\nfrom enum import Enum\nfrom dataclasses import dataclass\n\nclass Language(str, Enum):\n    \"\"\"\n    Possible languages with Multilspy.\n    \"\"\"\n\n    CSHARP = \"csharp\"\n    PYTHON = \"python\"\n    RUST = \"rust\"\n    JAVA = \"java\"\n\n    def __str__(self) -> str:\n        return self.value\n\n@dataclass\nclass MultilspyConfig:\n    \"\"\"\n    Configuration parameters\n    \"\"\"\n    code_language: Language\n    trace_lsp_communication: bool = False\n\n    @classmethod\n    def from_dict(cls, env: dict):\n        \"\"\"\n        Create a MultilspyConfig instance from a dictionary\n        \"\"\"\n        import inspect\n        return cls(**{\n            k: v for k, v in env.items() \n            if k in inspect.signature(cls).parameters\n        })"}
{"type": "source_file", "path": "main.py", "content": "import logging\nfrom hyperagent import HyperAgent\nfrom argparse import ArgumentParser\n\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nlogging.getLogger('hyperagent').setLevel(logging.WARNING)\nlogger = logging.getLogger(__name__)\n\ndef parse():\n    args = ArgumentParser()\n    args.add_argument(\"--repo\", type=str, required=True)\n    args.add_argument(\"--commit\", type=str, default=\"\")\n    args.add_argument(\"--language\", type=str, default=\"python\")\n    args.add_argument(\"--prompt\", type=str, default=\"How to add new memory efficient fine-tuning technique to the project?\")\n    return args.parse_args()\n    \nif __name__ == \"__main__\":\n    logger.info(\"Start!\")\n    args = parse()\n    pilot = HyperAgent(args.repo, commit=args.commit, language=args.language, clone_dir=\"data/repos\")\n    logger.info(\"Setup done!\")\n    \n    print(pilot.query_codebase(args.question))"}
{"type": "source_file", "path": "src/hyperagent/multilspy/lsp_protocol_handler/lsp_requests.py", "content": "# Code generated. DO NOT EDIT.\n# LSP v3.17.0\n# TODO: Look into use of https://pypi.org/project/ts2python/ to generate the types for https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\n\n\"\"\"\nThis file provides the python interface corresponding to the requests and notifications defined in Typescript in the language server protocol.\nThis file is obtained from https://github.com/predragnikolic/OLSP under the MIT License with the following terms:\n\nMIT License\n\nCopyright (c) 2023 Предраг Николић\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n\nfrom typing import List, Union\nfrom . import lsp_types\n\nclass LspRequest:\n    def __init__(self, send_request):\n        self.send_request = send_request\n\n    async def implementation(\n        self, params: lsp_types.ImplementationParams\n    ) -> Union[\"lsp_types.Definition\", List[\"lsp_types.LocationLink\"], None]:\n        \"\"\"A request to resolve the implementation locations of a symbol at a given text\n        document position. The request's parameter is of type [TextDocumentPositionParams]\n        (#TextDocumentPositionParams) the response is of type {@link Definition} or a\n        Thenable that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/implementation\", params)\n\n    async def type_definition(\n        self, params: lsp_types.TypeDefinitionParams\n    ) -> Union[\"lsp_types.Definition\", List[\"lsp_types.LocationLink\"], None]:\n        \"\"\"A request to resolve the type definition locations of a symbol at a given text\n        document position. The request's parameter is of type [TextDocumentPositionParams]\n        (#TextDocumentPositionParams) the response is of type {@link Definition} or a\n        Thenable that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/typeDefinition\", params)\n\n    async def document_color(\n        self, params: lsp_types.DocumentColorParams\n    ) -> List[\"lsp_types.ColorInformation\"]:\n        \"\"\"A request to list all color symbols found in a given text document. The request's\n        parameter is of type {@link DocumentColorParams} the\n        response is of type {@link ColorInformation ColorInformation[]} or a Thenable\n        that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/documentColor\", params)\n\n    async def color_presentation(\n        self, params: lsp_types.ColorPresentationParams\n    ) -> List[\"lsp_types.ColorPresentation\"]:\n        \"\"\"A request to list all presentation for a color. The request's\n        parameter is of type {@link ColorPresentationParams} the\n        response is of type {@link ColorInformation ColorInformation[]} or a Thenable\n        that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/colorPresentation\", params)\n\n    async def folding_range(\n        self, params: lsp_types.FoldingRangeParams\n    ) -> Union[List[\"lsp_types.FoldingRange\"], None]:\n        \"\"\"A request to provide folding ranges in a document. The request's\n        parameter is of type {@link FoldingRangeParams}, the\n        response is of type {@link FoldingRangeList} or a Thenable\n        that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/foldingRange\", params)\n\n    async def declaration(\n        self, params: lsp_types.DeclarationParams\n    ) -> Union[\"lsp_types.Declaration\", List[\"lsp_types.LocationLink\"], None]:\n        \"\"\"A request to resolve the type definition locations of a symbol at a given text\n        document position. The request's parameter is of type [TextDocumentPositionParams]\n        (#TextDocumentPositionParams) the response is of type {@link Declaration}\n        or a typed array of {@link DeclarationLink} or a Thenable that resolves\n        to such.\"\"\"\n        return await self.send_request(\"textDocument/declaration\", params)\n\n    async def selection_range(\n        self, params: lsp_types.SelectionRangeParams\n    ) -> Union[List[\"lsp_types.SelectionRange\"], None]:\n        \"\"\"A request to provide selection ranges in a document. The request's\n        parameter is of type {@link SelectionRangeParams}, the\n        response is of type {@link SelectionRange SelectionRange[]} or a Thenable\n        that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/selectionRange\", params)\n\n    async def prepare_call_hierarchy(\n        self, params: lsp_types.CallHierarchyPrepareParams\n    ) -> Union[List[\"lsp_types.CallHierarchyItem\"], None]:\n        \"\"\"A request to result a `CallHierarchyItem` in a document at a given position.\n        Can be used as an input to an incoming or outgoing call hierarchy.\n\n        @since 3.16.0\"\"\"\n        return await self.send_request(\"textDocument/prepareCallHierarchy\", params)\n\n    async def incoming_calls(\n        self, params: lsp_types.CallHierarchyIncomingCallsParams\n    ) -> Union[List[\"lsp_types.CallHierarchyIncomingCall\"], None]:\n        \"\"\"A request to resolve the incoming calls for a given `CallHierarchyItem`.\n\n        @since 3.16.0\"\"\"\n        return await self.send_request(\"callHierarchy/incomingCalls\", params)\n\n    async def outgoing_calls(\n        self, params: lsp_types.CallHierarchyOutgoingCallsParams\n    ) -> Union[List[\"lsp_types.CallHierarchyOutgoingCall\"], None]:\n        \"\"\"A request to resolve the outgoing calls for a given `CallHierarchyItem`.\n\n        @since 3.16.0\"\"\"\n        return await self.send_request(\"callHierarchy/outgoingCalls\", params)\n\n    async def semantic_tokens_full(\n        self, params: lsp_types.SemanticTokensParams\n    ) -> Union[\"lsp_types.SemanticTokens\", None]:\n        \"\"\"@since 3.16.0\"\"\"\n        return await self.send_request(\"textDocument/semanticTokens/full\", params)\n\n    async def semantic_tokens_delta(\n        self, params: lsp_types.SemanticTokensDeltaParams\n    ) -> Union[\"lsp_types.SemanticTokens\", \"lsp_types.SemanticTokensDelta\", None]:\n        \"\"\"@since 3.16.0\"\"\"\n        return await self.send_request(\"textDocument/semanticTokens/full/delta\", params)\n\n    async def semantic_tokens_range(\n        self, params: lsp_types.SemanticTokensRangeParams\n    ) -> Union[\"lsp_types.SemanticTokens\", None]:\n        \"\"\"@since 3.16.0\"\"\"\n        return await self.send_request(\"textDocument/semanticTokens/range\", params)\n\n    async def linked_editing_range(\n        self, params: lsp_types.LinkedEditingRangeParams\n    ) -> Union[\"lsp_types.LinkedEditingRanges\", None]:\n        \"\"\"A request to provide ranges that can be edited together.\n\n        @since 3.16.0\"\"\"\n        return await self.send_request(\"textDocument/linkedEditingRange\", params)\n\n    async def will_create_files(\n        self, params: lsp_types.CreateFilesParams\n    ) -> Union[\"lsp_types.WorkspaceEdit\", None]:\n        \"\"\"The will create files request is sent from the client to the server before files are actually\n        created as long as the creation is triggered from within the client.\n\n        @since 3.16.0\"\"\"\n        return await self.send_request(\"workspace/willCreateFiles\", params)\n\n    async def will_rename_files(\n        self, params: lsp_types.RenameFilesParams\n    ) -> Union[\"lsp_types.WorkspaceEdit\", None]:\n        \"\"\"The will rename files request is sent from the client to the server before files are actually\n        renamed as long as the rename is triggered from within the client.\n\n        @since 3.16.0\"\"\"\n        return await self.send_request(\"workspace/willRenameFiles\", params)\n\n    async def will_delete_files(\n        self, params: lsp_types.DeleteFilesParams\n    ) -> Union[\"lsp_types.WorkspaceEdit\", None]:\n        \"\"\"The did delete files notification is sent from the client to the server when\n        files were deleted from within the client.\n\n        @since 3.16.0\"\"\"\n        return await self.send_request(\"workspace/willDeleteFiles\", params)\n\n    async def moniker(\n        self, params: lsp_types.MonikerParams\n    ) -> Union[List[\"lsp_types.Moniker\"], None]:\n        \"\"\"A request to get the moniker of a symbol at a given text document position.\n        The request parameter is of type {@link TextDocumentPositionParams}.\n        The response is of type {@link Moniker Moniker[]} or `null`.\"\"\"\n        return await self.send_request(\"textDocument/moniker\", params)\n\n    async def prepare_type_hierarchy(\n        self, params: lsp_types.TypeHierarchyPrepareParams\n    ) -> Union[List[\"lsp_types.TypeHierarchyItem\"], None]:\n        \"\"\"A request to result a `TypeHierarchyItem` in a document at a given position.\n        Can be used as an input to a subtypes or supertypes type hierarchy.\n\n        @since 3.17.0\"\"\"\n        return await self.send_request(\"textDocument/prepareTypeHierarchy\", params)\n\n    async def type_hierarchy_supertypes(\n        self, params: lsp_types.TypeHierarchySupertypesParams\n    ) -> Union[List[\"lsp_types.TypeHierarchyItem\"], None]:\n        \"\"\"A request to resolve the supertypes for a given `TypeHierarchyItem`.\n\n        @since 3.17.0\"\"\"\n        return await self.send_request(\"typeHierarchy/supertypes\", params)\n\n    async def type_hierarchy_subtypes(\n        self, params: lsp_types.TypeHierarchySubtypesParams\n    ) -> Union[List[\"lsp_types.TypeHierarchyItem\"], None]:\n        \"\"\"A request to resolve the subtypes for a given `TypeHierarchyItem`.\n\n        @since 3.17.0\"\"\"\n        return await self.send_request(\"typeHierarchy/subtypes\", params)\n\n    async def inline_value(\n        self, params: lsp_types.InlineValueParams\n    ) -> Union[List[\"lsp_types.InlineValue\"], None]:\n        \"\"\"A request to provide inline values in a document. The request's parameter is of\n        type {@link InlineValueParams}, the response is of type\n        {@link InlineValue InlineValue[]} or a Thenable that resolves to such.\n\n        @since 3.17.0\"\"\"\n        return await self.send_request(\"textDocument/inlineValue\", params)\n\n    async def inlay_hint(\n        self, params: lsp_types.InlayHintParams\n    ) -> Union[List[\"lsp_types.InlayHint\"], None]:\n        \"\"\"A request to provide inlay hints in a document. The request's parameter is of\n        type {@link InlayHintsParams}, the response is of type\n        {@link InlayHint InlayHint[]} or a Thenable that resolves to such.\n\n        @since 3.17.0\"\"\"\n        return await self.send_request(\"textDocument/inlayHint\", params)\n\n    async def resolve_inlay_hint(\n        self, params: lsp_types.InlayHint\n    ) -> \"lsp_types.InlayHint\":\n        \"\"\"A request to resolve additional properties for an inlay hint.\n        The request's parameter is of type {@link InlayHint}, the response is\n        of type {@link InlayHint} or a Thenable that resolves to such.\n\n        @since 3.17.0\"\"\"\n        return await self.send_request(\"inlayHint/resolve\", params)\n\n    async def text_document_diagnostic(\n        self, params: lsp_types.DocumentDiagnosticParams\n    ) -> \"lsp_types.DocumentDiagnosticReport\":\n        \"\"\"The document diagnostic request definition.\n\n        @since 3.17.0\"\"\"\n        return await self.send_request(\"textDocument/diagnostic\", params)\n\n    async def workspace_diagnostic(\n        self, params: lsp_types.WorkspaceDiagnosticParams\n    ) -> \"lsp_types.WorkspaceDiagnosticReport\":\n        \"\"\"The workspace diagnostic request definition.\n\n        @since 3.17.0\"\"\"\n        return await self.send_request(\"workspace/diagnostic\", params)\n\n    async def initialize(\n        self, params: lsp_types.InitializeParams\n    ) -> \"lsp_types.InitializeResult\":\n        \"\"\"The initialize request is sent from the client to the server.\n        It is sent once as the request after starting up the server.\n        The requests parameter is of type {@link InitializeParams}\n        the response if of type {@link InitializeResult} of a Thenable that\n        resolves to such.\"\"\"\n        return await self.send_request(\"initialize\", params)\n\n    async def shutdown(self) -> None:\n        \"\"\"A shutdown request is sent from the client to the server.\n        It is sent once when the client decides to shutdown the\n        server. The only notification that is sent after a shutdown request\n        is the exit event.\"\"\"\n        return await self.send_request(\"shutdown\")\n\n    async def will_save_wait_until(\n        self, params: lsp_types.WillSaveTextDocumentParams\n    ) -> Union[List[\"lsp_types.TextEdit\"], None]:\n        \"\"\"A document will save request is sent from the client to the server before\n        the document is actually saved. The request can return an array of TextEdits\n        which will be applied to the text document before it is saved. Please note that\n        clients might drop results if computing the text edits took too long or if a\n        server constantly fails on this request. This is done to keep the save fast and\n        reliable.\"\"\"\n        return await self.send_request(\"textDocument/willSaveWaitUntil\", params)\n\n    async def completion(\n        self, params: lsp_types.CompletionParams\n    ) -> Union[List[\"lsp_types.CompletionItem\"], \"lsp_types.CompletionList\", None]:\n        \"\"\"Request to request completion at a given text document position. The request's\n        parameter is of type {@link TextDocumentPosition} the response\n        is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}\n        or a Thenable that resolves to such.\n\n        The request can delay the computation of the {@link CompletionItem.detail `detail`}\n        and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`\n        request. However, properties that are needed for the initial sorting and filtering, like `sortText`,\n        `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.\n        \"\"\"\n        return await self.send_request(\"textDocument/completion\", params)\n\n    async def resolve_completion_item(\n        self, params: lsp_types.CompletionItem\n    ) -> \"lsp_types.CompletionItem\":\n        \"\"\"Request to resolve additional information for a given completion item.The request's\n        parameter is of type {@link CompletionItem} the response\n        is of type {@link CompletionItem} or a Thenable that resolves to such.\"\"\"\n        return await self.send_request(\"completionItem/resolve\", params)\n\n    async def hover(\n        self, params: lsp_types.HoverParams\n    ) -> Union[\"lsp_types.Hover\", None]:\n        \"\"\"Request to request hover information at a given text document position. The request's\n        parameter is of type {@link TextDocumentPosition} the response is of\n        type {@link Hover} or a Thenable that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/hover\", params)\n\n    async def signature_help(\n        self, params: lsp_types.SignatureHelpParams\n    ) -> Union[\"lsp_types.SignatureHelp\", None]:\n        return await self.send_request(\"textDocument/signatureHelp\", params)\n\n    async def definition(\n        self, params: lsp_types.DefinitionParams\n    ) -> Union[\"lsp_types.Definition\", List[\"lsp_types.LocationLink\"], None]:\n        \"\"\"A request to resolve the definition location of a symbol at a given text\n        document position. The request's parameter is of type [TextDocumentPosition]\n        (#TextDocumentPosition) the response is of either type {@link Definition}\n        or a typed array of {@link DefinitionLink} or a Thenable that resolves\n        to such.\"\"\"\n        return await self.send_request(\"textDocument/definition\", params)\n\n    async def references(\n        self, params: lsp_types.ReferenceParams\n    ) -> Union[List[\"lsp_types.Location\"], None]:\n        \"\"\"A request to resolve project-wide references for the symbol denoted\n        by the given text document position. The request's parameter is of\n        type {@link ReferenceParams} the response is of type\n        {@link Location Location[]} or a Thenable that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/references\", params)\n\n    async def document_highlight(\n        self, params: lsp_types.DocumentHighlightParams\n    ) -> Union[List[\"lsp_types.DocumentHighlight\"], None]:\n        \"\"\"Request to resolve a {@link DocumentHighlight} for a given\n        text document position. The request's parameter is of type [TextDocumentPosition]\n        (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]\n        (#DocumentHighlight) or a Thenable that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/documentHighlight\", params)\n\n    async def document_symbol(\n        self, params: lsp_types.DocumentSymbolParams\n    ) -> Union[\n        List[\"lsp_types.SymbolInformation\"], List[\"lsp_types.DocumentSymbol\"], None\n    ]:\n        \"\"\"A request to list all symbols found in a given text document. The request's\n        parameter is of type {@link TextDocumentIdentifier} the\n        response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable\n        that resolves to such.\"\"\"\n        return await self.send_request(\"textDocument/documentSymbol\", params)\n\n    async def code_action(\n        self, params: lsp_types.CodeActionParams\n    ) -> Union[List[Union[\"lsp_types.Command\", \"lsp_types.CodeAction\"]], None]:\n        \"\"\"A request to provide commands for the given text document and range.\"\"\"\n        return await self.send_request(\"textDocument/codeAction\", params)\n\n    async def resolve_code_action(\n        self, params: lsp_types.CodeAction\n    ) -> \"lsp_types.CodeAction\":\n        \"\"\"Request to resolve additional information for a given code action.The request's\n        parameter is of type {@link CodeAction} the response\n        is of type {@link CodeAction} or a Thenable that resolves to such.\"\"\"\n        return await self.send_request(\"codeAction/resolve\", params)\n\n    async def workspace_symbol(\n        self, params: lsp_types.WorkspaceSymbolParams\n    ) -> Union[\n        List[\"lsp_types.SymbolInformation\"], List[\"lsp_types.WorkspaceSymbol\"], None\n    ]:\n        \"\"\"A request to list project-wide symbols matching the query string given\n        by the {@link WorkspaceSymbolParams}. The response is\n        of type {@link SymbolInformation SymbolInformation[]} or a Thenable that\n        resolves to such.\n\n        @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients\n         need to advertise support for WorkspaceSymbols via the client capability\n         `workspace.symbol.resolveSupport`.\n        \"\"\"\n        return await self.send_request(\"workspace/symbol\", params)\n\n    async def resolve_workspace_symbol(\n        self, params: lsp_types.WorkspaceSymbol\n    ) -> \"lsp_types.WorkspaceSymbol\":\n        \"\"\"A request to resolve the range inside the workspace\n        symbol's location.\n\n        @since 3.17.0\"\"\"\n        return await self.send_request(\"workspaceSymbol/resolve\", params)\n\n    async def code_lens(\n        self, params: lsp_types.CodeLensParams\n    ) -> Union[List[\"lsp_types.CodeLens\"], None]:\n        \"\"\"A request to provide code lens for the given text document.\"\"\"\n        return await self.send_request(\"textDocument/codeLens\", params)\n\n    async def resolve_code_lens(\n        self, params: lsp_types.CodeLens\n    ) -> \"lsp_types.CodeLens\":\n        \"\"\"A request to resolve a command for a given code lens.\"\"\"\n        return await self.send_request(\"codeLens/resolve\", params)\n\n    async def document_link(\n        self, params: lsp_types.DocumentLinkParams\n    ) -> Union[List[\"lsp_types.DocumentLink\"], None]:\n        \"\"\"A request to provide document links\"\"\"\n        return await self.send_request(\"textDocument/documentLink\", params)\n\n    async def resolve_document_link(\n        self, params: lsp_types.DocumentLink\n    ) -> \"lsp_types.DocumentLink\":\n        \"\"\"Request to resolve additional information for a given document link. The request's\n        parameter is of type {@link DocumentLink} the response\n        is of type {@link DocumentLink} or a Thenable that resolves to such.\"\"\"\n        return await self.send_request(\"documentLink/resolve\", params)\n\n    async def formatting(\n        self, params: lsp_types.DocumentFormattingParams\n    ) -> Union[List[\"lsp_types.TextEdit\"], None]:\n        \"\"\"A request to to format a whole document.\"\"\"\n        return await self.send_request(\"textDocument/formatting\", params)\n\n    async def range_formatting(\n        self, params: lsp_types.DocumentRangeFormattingParams\n    ) -> Union[List[\"lsp_types.TextEdit\"], None]:\n        \"\"\"A request to to format a range in a document.\"\"\"\n        return await self.send_request(\"textDocument/rangeFormatting\", params)\n\n    async def on_type_formatting(\n        self, params: lsp_types.DocumentOnTypeFormattingParams\n    ) -> Union[List[\"lsp_types.TextEdit\"], None]:\n        \"\"\"A request to format a document on type.\"\"\"\n        return await self.send_request(\"textDocument/onTypeFormatting\", params)\n\n    async def rename(\n        self, params: lsp_types.RenameParams\n    ) -> Union[\"lsp_types.WorkspaceEdit\", None]:\n        \"\"\"A request to rename a symbol.\"\"\"\n        return await self.send_request(\"textDocument/rename\", params)\n\n    async def prepare_rename(\n        self, params: lsp_types.PrepareRenameParams\n    ) -> Union[\"lsp_types.PrepareRenameResult\", None]:\n        \"\"\"A request to test and perform the setup necessary for a rename.\n\n        @since 3.16 - support for default behavior\"\"\"\n        return await self.send_request(\"textDocument/prepareRename\", params)\n\n    async def execute_command(\n        self, params: lsp_types.ExecuteCommandParams\n    ) -> Union[\"lsp_types.LSPAny\", None]:\n        \"\"\"A request send from the client to the server to execute a command. The request might return\n        a workspace edit which the client will apply to the workspace.\"\"\"\n        return await self.send_request(\"workspace/executeCommand\", params)\n\n\nclass LspNotification:\n    def __init__(self, send_notification):\n        self.send_notification = send_notification\n\n    def did_change_workspace_folders(\n        self, params: lsp_types.DidChangeWorkspaceFoldersParams\n    ) -> None:\n        \"\"\"The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace\n        folder configuration changes.\"\"\"\n        return self.send_notification(\"workspace/didChangeWorkspaceFolders\", params)\n\n    def cancel_work_done_progress(\n        self, params: lsp_types.WorkDoneProgressCancelParams\n    ) -> None:\n        \"\"\"The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress\n        initiated on the server side.\"\"\"\n        return self.send_notification(\"window/workDoneProgress/cancel\", params)\n\n    def did_create_files(self, params: lsp_types.CreateFilesParams) -> None:\n        \"\"\"The did create files notification is sent from the client to the server when\n        files were created from within the client.\n\n        @since 3.16.0\"\"\"\n        return self.send_notification(\"workspace/didCreateFiles\", params)\n\n    def did_rename_files(self, params: lsp_types.RenameFilesParams) -> None:\n        \"\"\"The did rename files notification is sent from the client to the server when\n        files were renamed from within the client.\n\n        @since 3.16.0\"\"\"\n        return self.send_notification(\"workspace/didRenameFiles\", params)\n\n    def did_delete_files(self, params: lsp_types.DeleteFilesParams) -> None:\n        \"\"\"The will delete files request is sent from the client to the server before files are actually\n        deleted as long as the deletion is triggered from within the client.\n\n        @since 3.16.0\"\"\"\n        return self.send_notification(\"workspace/didDeleteFiles\", params)\n\n    def did_open_notebook_document(\n        self, params: lsp_types.DidOpenNotebookDocumentParams\n    ) -> None:\n        \"\"\"A notification sent when a notebook opens.\n\n        @since 3.17.0\"\"\"\n        return self.send_notification(\"notebookDocument/didOpen\", params)\n\n    def did_change_notebook_document(\n        self, params: lsp_types.DidChangeNotebookDocumentParams\n    ) -> None:\n        return self.send_notification(\"notebookDocument/didChange\", params)\n\n    def did_save_notebook_document(\n        self, params: lsp_types.DidSaveNotebookDocumentParams\n    ) -> None:\n        \"\"\"A notification sent when a notebook document is saved.\n\n        @since 3.17.0\"\"\"\n        return self.send_notification(\"notebookDocument/didSave\", params)\n\n    def did_close_notebook_document(\n        self, params: lsp_types.DidCloseNotebookDocumentParams\n    ) -> None:\n        \"\"\"A notification sent when a notebook closes.\n\n        @since 3.17.0\"\"\"\n        return self.send_notification(\"notebookDocument/didClose\", params)\n\n    def initialized(self, params: lsp_types.InitializedParams) -> None:\n        \"\"\"The initialized notification is sent from the client to the\n        server after the client is fully initialized and the server\n        is allowed to send requests from the server to the client.\"\"\"\n        return self.send_notification(\"initialized\", params)\n\n    def exit(self) -> None:\n        \"\"\"The exit event is sent from the client to the server to\n        ask the server to exit its process.\"\"\"\n        return self.send_notification(\"exit\")\n\n    def workspace_did_change_configuration(\n        self, params: lsp_types.DidChangeConfigurationParams\n    ) -> None:\n        \"\"\"The configuration change notification is sent from the client to the server\n        when the client's configuration has changed. The notification contains\n        the changed configuration as defined by the language client.\"\"\"\n        return self.send_notification(\"workspace/didChangeConfiguration\", params)\n\n    def did_open_text_document(\n        self, params: lsp_types.DidOpenTextDocumentParams\n    ) -> None:\n        \"\"\"The document open notification is sent from the client to the server to signal\n        newly opened text documents. The document's truth is now managed by the client\n        and the server must not try to read the document's truth using the document's\n        uri. Open in this sense means it is managed by the client. It doesn't necessarily\n        mean that its content is presented in an editor. An open notification must not\n        be sent more than once without a corresponding close notification send before.\n        This means open and close notification must be balanced and the max open count\n        is one.\"\"\"\n        return self.send_notification(\"textDocument/didOpen\", params)\n\n    def did_change_text_document(\n        self, params: lsp_types.DidChangeTextDocumentParams\n    ) -> None:\n        \"\"\"The document change notification is sent from the client to the server to signal\n        changes to a text document.\"\"\"\n        return self.send_notification(\"textDocument/didChange\", params)\n\n    def did_close_text_document(\n        self, params: lsp_types.DidCloseTextDocumentParams\n    ) -> None:\n        \"\"\"The document close notification is sent from the client to the server when\n        the document got closed in the client. The document's truth now exists where\n        the document's uri points to (e.g. if the document's uri is a file uri the\n        truth now exists on disk). As with the open notification the close notification\n        is about managing the document's content. Receiving a close notification\n        doesn't mean that the document was open in an editor before. A close\n        notification requires a previous open notification to be sent.\"\"\"\n        return self.send_notification(\"textDocument/didClose\", params)\n\n    def did_save_text_document(\n        self, params: lsp_types.DidSaveTextDocumentParams\n    ) -> None:\n        \"\"\"The document save notification is sent from the client to the server when\n        the document got saved in the client.\"\"\"\n        return self.send_notification(\"textDocument/didSave\", params)\n\n    def will_save_text_document(\n        self, params: lsp_types.WillSaveTextDocumentParams\n    ) -> None:\n        \"\"\"A document will save notification is sent from the client to the server before\n        the document is actually saved.\"\"\"\n        return self.send_notification(\"textDocument/willSave\", params)\n\n    def did_change_watched_files(\n        self, params: lsp_types.DidChangeWatchedFilesParams\n    ) -> None:\n        \"\"\"The watched files notification is sent from the client to the server when\n        the client detects changes to file watched by the language client.\"\"\"\n        return self.send_notification(\"workspace/didChangeWatchedFiles\", params)\n\n    def set_trace(self, params: lsp_types.SetTraceParams) -> None:\n        return self.send_notification(\"$/setTrace\", params)\n\n    def cancel_request(self, params: lsp_types.CancelParams) -> None:\n        return self.send_notification(\"$/cancelRequest\", params)\n\n    def progress(self, params: lsp_types.ProgressParams) -> None:\n        return self.send_notification(\"$/progress\", params)\n"}
{"type": "source_file", "path": "scripts/merge_model.py", "content": "from transformers import AutoModelForCausalLM, AutoTokenizer\nfrom peft import PeftModel\nimport torch\n\ndef args():\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--adapter_dir\", type=str, required=True)\n    parser.add_argument(\"--full_model_dir\", type=str, required=True)\n    parser.add_argument(\"--base_model_path_or_name\", type=str, required=True)\n    return parser.parse_args()\n\ndef main():\n    script_args = args()\n    model_for_merge = AutoModelForCausalLM.from_pretrained(\n            script_args.base_model_path_or_name,\n            torch_dtype=torch.float16,\n        )\n    tokenizer = AutoTokenizer.from_pretrained(script_args.base_model_path_or_name, trust_remote_code=True)\n    full_model = PeftModel.from_pretrained(model_for_merge,\n                                        model_id=script_args.adapter_dir,\n                                        )\n    full_model = full_model.base_model.merge_and_unload()  \n    full_model.save_pretrained(script_args.full_model_dir)\n    tokenizer.save_pretrained(script_args.full_model_dir)\n    \nif __name__ == \"__main__\":\n    main()"}
{"type": "source_file", "path": "src/hyperagent/langchain_parsers/language/rust.py", "content": "from typing import TYPE_CHECKING\n\nfrom hyperagent.langchain_parsers.language.tree_sitter_segmenter import (\n    TreeSitterSegmenter,\n)\n\nif TYPE_CHECKING:\n    from tree_sitter import Language\n\n\nCHUNK_QUERY = \"\"\"\n    [\n        (function_item\n            name: (identifier)\n            body: (block)) @function\n        (struct_item) @struct\n        (trait_item) @trait\n    ]\n\"\"\".strip()\n\n\nclass RustSegmenter(TreeSitterSegmenter):\n    \"\"\"Code segmenter for Rust.\"\"\"\n\n    def get_language(self) -> \"Language\":\n        from tree_sitter_languages import get_language\n\n        return get_language(\"rust\")\n\n    def get_chunk_query(self) -> str:\n        return CHUNK_QUERY\n\n    def make_line_comment(self, text: str) -> str:\n        return f\"// {text}\""}
{"type": "source_file", "path": "src/hyperagent/multilspy/language_server.py", "content": "\"\"\"\nThis file contains the main interface and the public API for multilspy. \nThe abstract class LanguageServer provides a factory method, creator that is \nintended for creating instantiations of language specific clients.\nThe details of Language Specific configuration are not exposed to the user.\n\"\"\"\n\nimport asyncio\nimport dataclasses\nimport json\nimport logging\nimport os\nimport pathlib\nimport threading\nfrom contextlib import asynccontextmanager, contextmanager\nfrom .lsp_protocol_handler.lsp_constants import LSPConstants\nfrom .lsp_protocol_handler import lsp_types as LSPTypes\n\nfrom . import multilspy_types\nfrom .multilspy_logger import MultilspyLogger\nfrom .lsp_protocol_handler.server import (\n    LanguageServerHandler,\n    ProcessLaunchInfo,\n)\nfrom .multilspy_config import MultilspyConfig, Language\nfrom .multilspy_exceptions import MultilspyException\nfrom .multilspy_utils import PathUtils, FileUtils, TextUtils\nfrom pathlib import PurePath\nfrom typing import AsyncIterator, Iterator, List, Dict, Union, Tuple\nfrom .type_helpers import ensure_all_methods_implemented\nimport concurrent\n\n@dataclasses.dataclass\nclass LSPFileBuffer:\n    \"\"\"\n    This class is used to store the contents of an open LSP file in memory.\n    \"\"\"\n\n    # uri of the file\n    uri: str\n\n    # The contents of the file\n    contents: str\n\n    # The version of the file\n    version: int\n\n    # The language id of the file\n    language_id: str\n\n    # reference count of the file\n    ref_count: int\n\n\nclass LanguageServer:\n    \"\"\"\n    The LanguageServer class provides a language agnostic interface to the Language Server Protocol.\n    It is used to communicate with Language Servers of different programming languages.\n    \"\"\"\n\n    @classmethod\n    def create(cls, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str) -> \"LanguageServer\":\n        \"\"\"\n        Creates a language specific LanguageServer instance based on the given configuration, and appropriate settings for the programming language.\n\n        If language is Java, then ensure that jdk-17.0.6 or higher is installed, `java` is in PATH, and JAVA_HOME is set to the installation directory.\n\n        :param repository_root_path: The root path of the repository.\n        :param config: The Multilspy configuration.\n        :param logger: The logger to use.\n\n        :return LanguageServer: A language specific LanguageServer instance.\n        \"\"\"\n        if config.code_language == Language.PYTHON:\n            from hyperagent.multilspy.language_servers.jedi_language_server.jedi_server import (\n                JediServer,\n            )\n\n            return JediServer(config, logger, repository_root_path)\n        elif config.code_language == Language.JAVA:\n            from hyperagent.multilspy.language_servers.eclipse_jdtls.eclipse_jdtls import (\n                EclipseJDTLS,\n            )\n\n            return EclipseJDTLS(config, logger, repository_root_path)\n        elif config.code_language == Language.RUST:\n            from hyperagent.multilspy.language_servers.rust_analyzer.rust_analyzer import (\n                RustAnalyzer,\n            )\n\n            return RustAnalyzer(config, logger, repository_root_path)\n        elif config.code_language == Language.CSHARP:\n            from hyperagent.multilspy.language_servers.omnisharp.omnisharp import OmniSharp\n\n            return OmniSharp(config, logger, repository_root_path)\n        else:\n            logger.log(f\"Language {config.code_language} is not supported\", logging.ERROR)\n            raise MultilspyException(f\"Language {config.code_language} is not supported\")\n\n    def __init__(\n        self,\n        config: MultilspyConfig,\n        logger: MultilspyLogger,\n        repository_root_path: str,\n        process_launch_info: ProcessLaunchInfo,\n        language_id: str,\n    ):\n        \"\"\"\n        Initializes a LanguageServer instance.\n\n        Do not instantiate this class directly. Use `LanguageServer.create` method instead.\n\n        :param config: The Multilspy configuration.\n        :param logger: The logger to use.\n        :param repository_root_path: The root path of the repository.\n        :param cmd: Each language server has a specific command used to start the server.\n                    This parameter is the command to launch the language server process.\n                    The command must pass appropriate flags to the binary, so that it runs in the stdio mode,\n                    as opposed to HTTP, TCP modes supported by some language servers.\n        \"\"\"\n        if type(self) == LanguageServer:\n            raise MultilspyException(\n                \"LanguageServer is an abstract class and cannot be instantiated directly. Use LanguageServer.create method instead.\"\n            )\n\n        self.logger = logger\n        self.server_started = False\n        self.repository_root_path: str = repository_root_path\n        self.completions_available = asyncio.Event()\n\n        if config.trace_lsp_communication:\n\n            def logging_fn(source, target, msg):\n                self.logger.log(f\"LSP: {source} -> {target}: {str(msg)}\", logging.DEBUG)\n\n        else:\n\n            def logging_fn(source, target, msg):\n                pass\n\n        # cmd is obtained from the child classes, which provide the language specific command to start the language server\n        # LanguageServerHandler provides the functionality to start the language server and communicate with it\n        self.server: LanguageServerHandler = LanguageServerHandler(process_launch_info, logger=logging_fn)\n        self.language_id = language_id\n        self.open_file_buffers: Dict[str, LSPFileBuffer] = {}\n\n    @asynccontextmanager\n    async def start_server(self) -> AsyncIterator[\"LanguageServer\"]:\n        \"\"\"\n        Starts the Language Server and yields the LanguageServer instance.\n\n        Usage:\n        ```\n        async with lsp.start_server():\n            # LanguageServer has been initialized and ready to serve requests\n            await lsp.request_definition(...)\n            await lsp.request_references(...)\n            # Shutdown the LanguageServer on exit from scope\n        # LanguageServer has been shutdown\n        ```\n        \"\"\"\n        self.server_started = True\n        yield self\n        self.server_started = False\n\n    # TODO: Add support for more LSP features\n\n    @contextmanager\n    def open_file(self, relative_file_path: str) -> Iterator[None]:\n        \"\"\"\n        Open a file in the Language Server. This is required before making any requests to the Language Server.\n\n        :param relative_file_path: The relative path of the file to open.\n        \"\"\"\n        if not self.server_started:\n            self.logger.log(\n                \"open_file called before Language Server started\",\n                logging.ERROR,\n            )\n            raise MultilspyException(\"Language Server not started\")\n\n        absolute_file_path = str(PurePath(self.repository_root_path, relative_file_path))\n        uri = pathlib.Path(absolute_file_path).as_uri()\n\n        if uri in self.open_file_buffers:\n            assert self.open_file_buffers[uri].uri == uri\n            assert self.open_file_buffers[uri].ref_count >= 1\n\n            self.open_file_buffers[uri].ref_count += 1\n            yield\n            self.open_file_buffers[uri].ref_count -= 1\n        else:\n            contents = FileUtils.read_file(self.logger, absolute_file_path)\n\n            version = 0\n            self.open_file_buffers[uri] = LSPFileBuffer(uri, contents, version, self.language_id, 1)\n\n            self.server.notify.did_open_text_document(\n                {\n                    LSPConstants.TEXT_DOCUMENT: {\n                        LSPConstants.URI: uri,\n                        LSPConstants.LANGUAGE_ID: self.language_id,\n                        LSPConstants.VERSION: 0,\n                        LSPConstants.TEXT: contents,\n                    }\n                }\n            )\n            yield\n            self.open_file_buffers[uri].ref_count -= 1\n\n        if self.open_file_buffers[uri].ref_count == 0:\n            self.server.notify.did_close_text_document(\n                {\n                    LSPConstants.TEXT_DOCUMENT: {\n                        LSPConstants.URI: uri,\n                    }\n                }\n            )\n            del self.open_file_buffers[uri]\n\n    def insert_text_at_position(\n        self, relative_file_path: str, line: int, column: int, text_to_be_inserted: str\n    ) -> multilspy_types.Position:\n        \"\"\"\n        Insert text at the given line and column in the given file and return \n        the updated cursor position after inserting the text.\n\n        :param relative_file_path: The relative path of the file to open.\n        :param line: The line number at which text should be inserted.\n        :param column: The column number at which text should be inserted.\n        :param text_to_be_inserted: The text to insert.\n        \"\"\"\n        if not self.server_started:\n            self.logger.log(\n                \"insert_text_at_position called before Language Server started\",\n                logging.ERROR,\n            )\n            raise MultilspyException(\"Language Server not started\")\n\n        absolute_file_path = str(PurePath(self.repository_root_path, relative_file_path))\n        uri = pathlib.Path(absolute_file_path).as_uri()\n\n        # Ensure the file is open\n        assert uri in self.open_file_buffers\n\n        file_buffer = self.open_file_buffers[uri]\n        file_buffer.version += 1\n        change_index = TextUtils.get_index_from_line_col(file_buffer.contents, line, column)\n        file_buffer.contents = (\n            file_buffer.contents[:change_index] + text_to_be_inserted + file_buffer.contents[change_index:]\n        )\n        self.server.notify.did_change_text_document(\n            {\n                LSPConstants.TEXT_DOCUMENT: {\n                    LSPConstants.VERSION: file_buffer.version,\n                    LSPConstants.URI: file_buffer.uri,\n                },\n                LSPConstants.CONTENT_CHANGES: [\n                    {\n                        LSPConstants.RANGE: {\n                            \"start\": {\"line\": line, \"character\": column},\n                            \"end\": {\"line\": line, \"character\": column},\n                        },\n                        \"text\": text_to_be_inserted,\n                    }\n                ],\n            }\n        )\n        new_l, new_c = TextUtils.get_updated_position_from_line_and_column_and_edit(line, column, text_to_be_inserted)\n        return multilspy_types.Position(line=new_l, character=new_c)\n\n    def delete_text_between_positions(\n        self,\n        relative_file_path: str,\n        start: multilspy_types.Position,\n        end: multilspy_types.Position,\n    ) -> str:\n        \"\"\"\n        Delete text between the given start and end positions in the given file and return the deleted text.\n        \"\"\"\n        if not self.server_started:\n            self.logger.log(\n                \"insert_text_at_position called before Language Server started\",\n                logging.ERROR,\n            )\n            raise MultilspyException(\"Language Server not started\")\n\n        absolute_file_path = str(PurePath(self.repository_root_path, relative_file_path))\n        uri = pathlib.Path(absolute_file_path).as_uri()\n\n        # Ensure the file is open\n        assert uri in self.open_file_buffers\n\n        file_buffer = self.open_file_buffers[uri]\n        file_buffer.version += 1\n        del_start_idx = TextUtils.get_index_from_line_col(file_buffer.contents, start[\"line\"], start[\"character\"])\n        del_end_idx = TextUtils.get_index_from_line_col(file_buffer.contents, end[\"line\"], end[\"character\"])\n        deleted_text = file_buffer.contents[del_start_idx:del_end_idx]\n        file_buffer.contents = file_buffer.contents[:del_start_idx] + file_buffer.contents[del_end_idx:]\n        self.server.notify.did_change_text_document(\n            {\n                LSPConstants.TEXT_DOCUMENT: {\n                    LSPConstants.VERSION: file_buffer.version,\n                    LSPConstants.URI: file_buffer.uri,\n                },\n                LSPConstants.CONTENT_CHANGES: [{LSPConstants.RANGE: {\"start\": start, \"end\": end}, \"text\": \"\"}],\n            }\n        )\n        return deleted_text\n\n    def get_open_file_text(self, relative_file_path: str) -> str:\n        \"\"\"\n        Get the contents of the given opened file as per the Language Server.\n\n        :param relative_file_path: The relative path of the file to open.\n        \"\"\"\n        if not self.server_started:\n            self.logger.log(\n                \"get_open_file_text called before Language Server started\",\n                logging.ERROR,\n            )\n            raise MultilspyException(\"Language Server not started\")\n\n        absolute_file_path = str(PurePath(self.repository_root_path, relative_file_path))\n        uri = pathlib.Path(absolute_file_path).as_uri()\n\n        # Ensure the file is open\n        assert uri in self.open_file_buffers\n\n        file_buffer = self.open_file_buffers[uri]\n        return file_buffer.contents\n\n    async def request_definition(\n        self, relative_file_path: str, line: int, column: int\n    ) -> List[multilspy_types.Location]:\n        \"\"\"\n        Raise a [textDocument/definition](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_definition) request to the Language Server\n        for the symbol at the given line and column in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the symbol for which definition should be looked up\n        :param line: The line number of the symbol\n        :param column: The column number of the symbol\n\n        :return List[multilspy_types.Location]: A list of locations where the symbol is defined\n        \"\"\"\n\n        if not self.server_started:\n            self.logger.log(\n                \"find_function_definition called before Language Server started\",\n                logging.ERROR,\n            )\n            raise MultilspyException(\"Language Server not started\")\n\n        with self.open_file(relative_file_path):\n            # sending request to the language server and waiting for response\n            response = await self.server.send.definition(\n                {\n                    LSPConstants.TEXT_DOCUMENT: {\n                        LSPConstants.URI: pathlib.Path(\n                            str(PurePath(self.repository_root_path, relative_file_path))\n                        ).as_uri()\n                    },\n                    LSPConstants.POSITION: {\n                        LSPConstants.LINE: line,\n                        LSPConstants.CHARACTER: column,\n                    },\n                }\n            )\n\n        ret: List[multilspy_types.Location] = []\n        if isinstance(response, list):\n            # response is either of type Location[] or LocationLink[]\n            for item in response:\n                assert isinstance(item, dict)\n                if LSPConstants.URI in item and LSPConstants.RANGE in item:\n                    new_item: multilspy_types.Location = {}\n                    new_item.update(item)\n                    new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n                    new_item[\"relativePath\"] = str(\n                        PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n                    )\n                    ret.append(multilspy_types.Location(new_item))\n                elif (\n                    LSPConstants.ORIGIN_SELECTION_RANGE in item\n                    and LSPConstants.TARGET_URI in item\n                    and LSPConstants.TARGET_RANGE in item\n                    and LSPConstants.TARGET_SELECTION_RANGE in item\n                ):\n                    new_item: multilspy_types.Location = {}\n                    new_item[\"uri\"] = item[LSPConstants.TARGET_URI]\n                    new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n                    new_item[\"relativePath\"] = str(\n                        PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n                    )\n                    new_item[\"range\"] = item[LSPConstants.TARGET_SELECTION_RANGE]\n                    ret.append(multilspy_types.Location(**new_item))\n                else:\n                    assert False, f\"Unexpected response from Language Server: {item}\"\n        elif isinstance(response, dict):\n            # response is of type Location\n            assert LSPConstants.URI in response\n            assert LSPConstants.RANGE in response\n\n            new_item: multilspy_types.Location = {}\n            new_item.update(response)\n            new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n            new_item[\"relativePath\"] = str(\n                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n            )\n            ret.append(multilspy_types.Location(**new_item))\n        elif response is None:\n            return []\n        else:\n            assert False, f\"Unexpected response from Language Server: {response}\"\n\n        return ret\n\n    async def request_references(\n        self, relative_file_path: str, line: int, column: int\n    ) -> List[multilspy_types.Location]:\n        \"\"\"\n        Raise a [textDocument/references](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_references) request to the Language Server\n        to find references to the symbol at the given line and column in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the symbol for which references should be looked up\n        :param line: The line number of the symbol\n        :param column: The column number of the symbol\n\n        :return List[multilspy_types.Location]: A list of locations where the symbol is referenced\n        \"\"\"\n\n        if not self.server_started:\n            self.logger.log(\n                \"find_all_callers_of_function called before Language Server started\",\n                logging.ERROR,\n            )\n            raise MultilspyException(\"Language Server not started\")\n\n        with self.open_file(relative_file_path):\n            # sending request to the language server and waiting for response\n            response = await self.server.send.references(\n                {\n                    \"context\": {\"includeDeclaration\": False},\n                    \"textDocument\": {\n                        \"uri\": pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n                    },\n                    \"position\": {\"line\": line, \"character\": column},\n                }\n            )\n\n        ret: List[multilspy_types.Location] = []\n        if not isinstance(response, list):\n            ret = []\n        else:\n            for item in response:\n                assert isinstance(item, dict)\n                assert LSPConstants.URI in item\n                assert LSPConstants.RANGE in item\n\n                new_item: multilspy_types.Location = {}\n                new_item.update(item)\n                new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n                new_item[\"relativePath\"] = str(\n                    PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n                )\n                ret.append(multilspy_types.Location(**new_item))\n\n        return ret\n\n    async def request_completions(\n        self, relative_file_path: str, line: int, column: int, allow_incomplete: bool = False\n    ) -> List[multilspy_types.CompletionItem]:\n        \"\"\"\n        Raise a [textDocument/completion](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion) request to the Language Server\n        to find completions at the given line and column in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the symbol for which completions should be looked up\n        :param line: The line number of the symbol\n        :param column: The column number of the symbol\n\n        :return List[multilspy_types.CompletionItem]: A list of completions\n        \"\"\"\n        with self.open_file(relative_file_path):\n            open_file_buffer = self.open_file_buffers[\n                pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n            ]\n            completion_params: LSPTypes.CompletionParams = {\n                \"position\": {\"line\": line, \"character\": column},\n                \"textDocument\": {\"uri\": open_file_buffer.uri},\n                \"context\": {\"triggerKind\": LSPTypes.CompletionTriggerKind.Invoked},\n            }\n            response: Union[List[LSPTypes.CompletionItem], LSPTypes.CompletionList, None] = None\n\n            num_retries = 0\n            while response is None or (response[\"isIncomplete\"] and num_retries < 30):\n                await self.completions_available.wait()\n                response: Union[\n                    List[LSPTypes.CompletionItem], LSPTypes.CompletionList, None\n                ] = await self.server.send.completion(completion_params)\n                if isinstance(response, list):\n                    response = {\"items\": response, \"isIncomplete\": False}\n                num_retries += 1\n\n            # TODO: Understand how to appropriately handle `isIncomplete`\n            if response is None or (response[\"isIncomplete\"] and not(allow_incomplete)):\n                return []\n\n            if \"items\" in response:\n                response = response[\"items\"]\n\n            response: List[LSPTypes.CompletionItem] = response\n\n            # TODO: Handle the case when the completion is a keyword\n            items = [item for item in response if item[\"kind\"] != LSPTypes.CompletionItemKind.Keyword]\n\n            completions_list: List[multilspy_types.CompletionItem] = []\n\n            for item in items:\n                assert \"insertText\" in item or \"textEdit\" in item\n                assert \"kind\" in item\n                completion_item = {}\n                if \"detail\" in item:\n                    completion_item[\"detail\"] = item[\"detail\"]\n                \n                if \"label\" in item:\n                    completion_item[\"completionText\"] = item[\"label\"]\n                    completion_item[\"kind\"] = item[\"kind\"]\n                elif \"insertText\" in item:\n                    completion_item[\"completionText\"] = item[\"insertText\"]\n                    completion_item[\"kind\"] = item[\"kind\"]\n                elif \"textEdit\" in item and \"newText\" in item[\"textEdit\"]:\n                    completion_item[\"completionText\"] = item[\"textEdit\"][\"newText\"]\n                    completion_item[\"kind\"] = item[\"kind\"]\n                elif \"textEdit\" in item and \"range\" in item[\"textEdit\"]:\n                    new_dot_lineno, new_dot_colno = (\n                        completion_params[\"position\"][\"line\"],\n                        completion_params[\"position\"][\"character\"],\n                    )\n                    assert all(\n                        (\n                            item[\"textEdit\"][\"range\"][\"start\"][\"line\"] == new_dot_lineno,\n                            item[\"textEdit\"][\"range\"][\"start\"][\"character\"] == new_dot_colno,\n                            item[\"textEdit\"][\"range\"][\"start\"][\"line\"] == item[\"textEdit\"][\"range\"][\"end\"][\"line\"],\n                            item[\"textEdit\"][\"range\"][\"start\"][\"character\"]\n                            == item[\"textEdit\"][\"range\"][\"end\"][\"character\"],\n                        )\n                    )\n                    \n                    completion_item[\"completionText\"] = item[\"textEdit\"][\"newText\"]\n                    completion_item[\"kind\"] = item[\"kind\"]\n                elif \"textEdit\" in item and \"insert\" in item[\"textEdit\"]:\n                    assert False\n                else:\n                    assert False\n\n                completion_item = multilspy_types.CompletionItem(**completion_item)\n                completions_list.append(completion_item)\n\n            return [\n                json.loads(json_repr)\n                for json_repr in set([json.dumps(item, sort_keys=True) for item in completions_list])\n            ]\n\n    async def request_document_symbols(self, relative_file_path: str) -> Tuple[List[multilspy_types.UnifiedSymbolInformation], Union[List[multilspy_types.TreeRepr], None]]:\n        \"\"\"\n        Raise a [textDocument/documentSymbol](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_documentSymbol) request to the Language Server\n        to find symbols in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the symbols\n\n        :return Tuple[List[multilspy_types.UnifiedSymbolInformation], Union[List[multilspy_types.TreeRepr], None]]: A list of symbols in the file, and the tree representation of the symbols\n        \"\"\"\n        with self.open_file(relative_file_path):\n            response = await self.server.send.document_symbol(\n                {\n                    \"textDocument\": {\n                        \"uri\": pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n                    }\n                }\n            )\n        \n        ret: List[multilspy_types.UnifiedSymbolInformation] = []\n        l_tree = None\n        if not isinstance(response, list):\n            return [], None\n        for item in response:\n            assert isinstance(item, dict)\n            assert LSPConstants.NAME in item\n            assert LSPConstants.KIND in item\n\n            if LSPConstants.CHILDREN in item:\n                # TODO: l_tree should be a list of TreeRepr. Define the following function to return TreeRepr as well\n                \n                def visit_tree_nodes_and_build_tree_repr(tree: LSPTypes.DocumentSymbol) -> List[multilspy_types.UnifiedSymbolInformation]:\n                    l: List[multilspy_types.UnifiedSymbolInformation] = []\n                    children = tree['children'] if 'children' in tree else []\n                    if 'children' in tree:\n                        del tree['children']\n                    l.append(multilspy_types.UnifiedSymbolInformation(**tree))\n                    for child in children:\n                        l.extend(visit_tree_nodes_and_build_tree_repr(child))\n                    return l\n                \n                ret.extend(visit_tree_nodes_and_build_tree_repr(item))\n            else:\n                ret.append(multilspy_types.UnifiedSymbolInformation(**item))\n\n        return ret, l_tree\n    \n    async def request_hover(self, relative_file_path: str, line: int, column: int) -> Union[multilspy_types.Hover, None]:\n        \"\"\"\n        Raise a [textDocument/hover](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_hover) request to the Language Server\n        to find the hover information at the given line and column in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the hover information\n        :param line: The line number of the symbol\n        :param column: The column number of the symbol\n\n        :return None\n        \"\"\"\n        with self.open_file(relative_file_path):\n            response = await self.server.send.hover(\n                {\n                    \"textDocument\": {\n                        \"uri\": pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n                    },\n                    \"position\": {\n                        \"line\": line,\n                        \"character\": column,\n                    },\n                }\n            )\n        \n        if response is None:\n            return None\n\n        assert isinstance(response, dict)\n\n        return multilspy_types.Hover(**response)\n\n@ensure_all_methods_implemented(LanguageServer)\nclass SyncLanguageServer:\n    \"\"\"\n    The SyncLanguageServer class provides a language agnostic interface to the Language Server Protocol.\n    It is used to communicate with Language Servers of different programming languages.\n    \"\"\"\n\n    def __init__(self, language_server: LanguageServer) -> None:\n        self.language_server = language_server\n        self.loop = None\n        self.loop_thread = None\n\n    @classmethod\n    def create(\n        cls, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str\n    ) -> \"SyncLanguageServer\":\n        \"\"\"\n        Creates a language specific LanguageServer instance based on the given configuration, and appropriate settings for the programming language.\n\n        If language is Java, then ensure that jdk-17.0.6 or higher is installed, `java` is in PATH, and JAVA_HOME is set to the installation directory.\n\n        :param repository_root_path: The root path of the repository.\n        :param config: The Multilspy configuration.\n        :param logger: The logger to use.\n\n        :return SyncLanguageServer: A language specific LanguageServer instance.\n        \"\"\"\n        return SyncLanguageServer(LanguageServer.create(config, logger, repository_root_path))\n\n    @contextmanager\n    def open_file(self, relative_file_path: str) -> Iterator[None]:\n        \"\"\"\n        Open a file in the Language Server. This is required before making any requests to the Language Server.\n\n        :param relative_file_path: The relative path of the file to open.\n        \"\"\"\n        with self.language_server.open_file(relative_file_path):\n            yield\n\n    def insert_text_at_position(\n        self, relative_file_path: str, line: int, column: int, text_to_be_inserted: str\n    ) -> multilspy_types.Position:\n        \"\"\"\n        Insert text at the given line and column in the given file and return \n        the updated cursor position after inserting the text.\n\n        :param relative_file_path: The relative path of the file to open.\n        :param line: The line number at which text should be inserted.\n        :param column: The column number at which text should be inserted.\n        :param text_to_be_inserted: The text to insert.\n        \"\"\"\n        return self.language_server.insert_text_at_position(relative_file_path, line, column, text_to_be_inserted)\n\n    def delete_text_between_positions(\n        self,\n        relative_file_path: str,\n        start: multilspy_types.Position,\n        end: multilspy_types.Position,\n    ) -> str:\n        \"\"\"\n        Delete text between the given start and end positions in the given file and return the deleted text.\n        \"\"\"\n        return self.language_server.delete_text_between_positions(relative_file_path, start, end)\n\n    def get_open_file_text(self, relative_file_path: str) -> str:\n        \"\"\"\n        Get the contents of the given opened file as per the Language Server.\n\n        :param relative_file_path: The relative path of the file to open.\n        \"\"\"\n        return self.language_server.get_open_file_text(relative_file_path)\n\n    @contextmanager\n    def start_server(self) -> Iterator[\"SyncLanguageServer\"]:\n        \"\"\"\n        Starts the language server process and connects to it.\n\n        :return: None\n        \"\"\"\n        self.loop = asyncio.new_event_loop()\n        loop_thread = threading.Thread(target=self.loop.run_forever, daemon=True)\n        loop_thread.start()\n        ctx = self.language_server.start_server()\n        asyncio.run_coroutine_threadsafe(ctx.__aenter__(), loop=self.loop).result()\n        yield self\n        asyncio.run_coroutine_threadsafe(ctx.__aexit__(None, None, None), loop=self.loop).result()\n        self.loop.call_soon_threadsafe(self.loop.stop)\n        loop_thread.join()\n\n    def request_definition(self, file_path: str, line: int, column: int) -> List[multilspy_types.Location]:\n        \"\"\"\n        Raise a [textDocument/definition](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_definition) request to the Language Server\n        for the symbol at the given line and column in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the symbol for which definition should be looked up\n        :param line: The line number of the symbol\n        :param column: The column number of the symbol\n\n        :return List[multilspy_types.Location]: A list of locations where the symbol is defined\n        \"\"\"\n        result = asyncio.run_coroutine_threadsafe(\n            self.language_server.request_definition(file_path, line, column), self.loop\n        ).result()\n        return result\n\n    def request_references(self, file_path: str, line: int, column: int) -> List[multilspy_types.Location]:\n        \"\"\"\n        Raise a [textDocument/references](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_references) request to the Language Server\n        to find references to the symbol at the given line and column in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the symbol for which references should be looked up\n        :param line: The line number of the symbol\n        :param column: The column number of the symbol\n\n        :return List[multilspy_types.Location]: A list of locations where the symbol is referenced\n        \"\"\"\n        result = asyncio.run_coroutine_threadsafe(\n            self.language_server.request_references(file_path, line, column), self.loop\n        ).result()\n        return result\n\n    def request_completions(\n        self, relative_file_path: str, line: int, column: int, allow_incomplete: bool = False\n    ) -> List[multilspy_types.CompletionItem]:\n        \"\"\"\n        Raise a [textDocument/completion](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion) request to the Language Server\n        to find completions at the given line and column in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the symbol for which completions should be looked up\n        :param line: The line number of the symbol\n        :param column: The column number of the symbol\n\n        :return List[multilspy_types.CompletionItem]: A list of completions\n        \"\"\"\n        result = asyncio.run_coroutine_threadsafe(\n            self.language_server.request_completions(relative_file_path, line, column, allow_incomplete),\n            self.loop,\n        ).result()\n        return result\n\n    def request_document_symbols(self, relative_file_path: str) -> Tuple[List[multilspy_types.UnifiedSymbolInformation], Union[List[multilspy_types.TreeRepr], None]]:\n        \"\"\"\n        Raise a [textDocument/documentSymbol](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_documentSymbol) request to the Language Server\n        to find symbols in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the symbols\n\n        :return Tuple[List[multilspy_types.UnifiedSymbolInformation], Union[List[multilspy_types.TreeRepr], None]]: A list of symbols in the file, and the tree representation of the symbols\n        \"\"\"\n        result = asyncio.run_coroutine_threadsafe(\n            self.language_server.request_document_symbols(relative_file_path), self.loop\n        ).result()\n        return result\n\n    def request_hover(self, relative_file_path: str, line: int, column: int) -> Union[multilspy_types.Hover, None]:\n        \"\"\"\n        Raise a [textDocument/hover](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_hover) request to the Language Server\n        to find the hover information at the given line and column in the given file. Wait for the response and return the result.\n\n        :param relative_file_path: The relative path of the file that has the hover information\n        :param line: The line number of the symbol\n        :param column: The column number of the symbol\n\n        :return None\n        \"\"\"\n        future = asyncio.run_coroutine_threadsafe(\n            self.language_server.request_hover(relative_file_path, line, column), self.loop\n        )\n        try:\n            result = future.result(timeout=1)\n        except concurrent.futures.TimeoutError:\n            return None\n        return result\n"}
{"type": "source_file", "path": "src/hyperagent/multilspy/multilspy_types.py", "content": "\"\"\"\nDefines wrapper objects around the types returned by LSP to ensure decoupling between LSP versions and multilspy\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import IntEnum, Enum\nfrom typing_extensions import NotRequired, TypedDict, List, Dict, Union\n\nURI = str\nDocumentUri = str\nUint = int\nRegExp = str\n\nclass Position(TypedDict):\n    \"\"\"Position in a text document expressed as zero-based line and character\n    offset. Prior to 3.17 the offsets were always based on a UTF-16 string\n    representation. So a string of the form `a𐐀b` the character offset of the\n    character `a` is 0, the character offset of `𐐀` is 1 and the character\n    offset of b is 3 since `𐐀` is represented using two code units in UTF-16.\n    Since 3.17 clients and servers can agree on a different string encoding\n    representation (e.g. UTF-8). The client announces it's supported encoding\n    via the client capability [`general.positionEncodings`](#clientCapabilities).\n    The value is an array of position encodings the client supports, with\n    decreasing preference (e.g. the encoding at index `0` is the most preferred\n    one). To stay backwards compatible the only mandatory encoding is UTF-16\n    represented via the string `utf-16`. The server can pick one of the\n    encodings offered by the client and signals that encoding back to the\n    client via the initialize result's property\n    [`capabilities.positionEncoding`](#serverCapabilities). If the string value\n    `utf-16` is missing from the client's capability `general.positionEncodings`\n    servers can safely assume that the client supports UTF-16. If the server\n    omits the position encoding in its initialize result the encoding defaults\n    to the string value `utf-16`. Implementation considerations: since the\n    conversion from one encoding into another requires the content of the\n    file / line the conversion is best done where the file is read which is\n    usually on the server side.\n\n    Positions are line end character agnostic. So you can not specify a position\n    that denotes `\\r|\\n` or `\\n|` where `|` represents the character offset.\n\n    @since 3.17.0 - support for negotiated position encoding.\"\"\"\n\n    line: Uint\n    \"\"\" Line position in a document (zero-based).\n\n    If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.\n    If a line number is negative, it defaults to 0. \"\"\"\n    character: Uint\n    \"\"\" Character offset on a line in a document (zero-based).\n\n    The meaning of this offset is determined by the negotiated\n    `PositionEncodingKind`.\n\n    If the character value is greater than the line length it defaults back to the\n    line length. \"\"\"\n\n\nclass Range(TypedDict):\n    \"\"\"A range in a text document expressed as (zero-based) start and end positions.\n\n    If you want to specify a range that contains a line including the line ending\n    character(s) then use an end position denoting the start of the next line.\n    For example:\n    ```ts\n    {\n        start: { line: 5, character: 23 }\n        end : { line 6, character : 0 }\n    }\n    ```\"\"\"\n\n    start: Position\n    \"\"\" The range's start position. \"\"\"\n    end: Position\n    \"\"\" The range's end position. \"\"\"\n\n\nclass Location(TypedDict):\n    \"\"\"Represents a location inside a resource, such as a line\n    inside a text file.\"\"\"\n\n    uri: DocumentUri\n    range: Range\n    absolutePath: str\n    relativePath: str\n\nclass CompletionItemKind(IntEnum):\n    \"\"\"The kind of a completion entry.\"\"\"\n\n    Text = 1\n    Method = 2\n    Function = 3\n    Constructor = 4\n    Field = 5\n    Variable = 6\n    Class = 7\n    Interface = 8\n    Module = 9\n    Property = 10\n    Unit = 11\n    Value = 12\n    Enum = 13\n    Keyword = 14\n    Snippet = 15\n    Color = 16\n    File = 17\n    Reference = 18\n    Folder = 19\n    EnumMember = 20\n    Constant = 21\n    Struct = 22\n    Event = 23\n    Operator = 24\n    TypeParameter = 25\n\nclass CompletionItem(TypedDict):\n    \"\"\"A completion item represents a text snippet that is\n    proposed to complete text that is being typed.\"\"\"\n\n    completionText: str\n    \"\"\" The completionText of this completion item.\n\n    The completionText property is also by default the text that\n    is inserted when selecting this completion.\"\"\"\n\n    kind: CompletionItemKind\n    \"\"\" The kind of this completion item. Based of the kind\n    an icon is chosen by the editor. \"\"\"\n\n    detail: NotRequired[str]\n    \"\"\" A human-readable string with additional information\n    about this item, like type or symbol information. \"\"\"\n\nclass SymbolKind(IntEnum):\n    \"\"\"A symbol kind.\"\"\"\n\n    File = 1\n    Module = 2\n    Namespace = 3\n    Package = 4\n    Class = 5\n    Method = 6\n    Property = 7\n    Field = 8\n    Constructor = 9\n    Enum = 10\n    Interface = 11\n    Function = 12\n    Variable = 13\n    Constant = 14\n    String = 15\n    Number = 16\n    Boolean = 17\n    Array = 18\n    Object = 19\n    Key = 20\n    Null = 21\n    EnumMember = 22\n    Struct = 23\n    Event = 24\n    Operator = 25\n    TypeParameter = 26\n\nclass SymbolTag(IntEnum):\n    \"\"\"Symbol tags are extra annotations that tweak the rendering of a symbol.\n\n    @since 3.16\"\"\"\n\n    Deprecated = 1\n    \"\"\" Render a symbol as obsolete, usually using a strike-out. \"\"\"\n\nclass UnifiedSymbolInformation(TypedDict):\n    \"\"\"Represents information about programming constructs like variables, classes,\n    interfaces etc.\"\"\"\n\n    deprecated: NotRequired[bool]\n    \"\"\" Indicates if this symbol is deprecated.\n\n    @deprecated Use tags instead \"\"\"\n    location: NotRequired[Location]\n    \"\"\" The location of this symbol. The location's range is used by a tool\n    to reveal the location in the editor. If the symbol is selected in the\n    tool the range's start information is used to position the cursor. So\n    the range usually spans more than the actual symbol's name and does\n    normally include things like visibility modifiers.\n\n    The range doesn't have to denote a node range in the sense of an abstract\n    syntax tree. It can therefore not be used to re-construct a hierarchy of\n    the symbols. \"\"\"\n    name: str\n    \"\"\" The name of this symbol. \"\"\"\n    kind: SymbolKind\n    \"\"\" The kind of this symbol. \"\"\"\n    tags: NotRequired[List[SymbolTag]]\n    \"\"\" Tags for this symbol.\n\n    @since 3.16.0 \"\"\"\n    containerName: NotRequired[str]\n    \"\"\" The name of the symbol containing this symbol. This information is for\n    user interface purposes (e.g. to render a qualifier in the user interface\n    if necessary). It can't be used to re-infer a hierarchy for the document\n    symbols. \"\"\"\n\n    detail: NotRequired[str]\n    \"\"\" More detail for this symbol, e.g the signature of a function. \"\"\"\n    \n    range: NotRequired[Range]\n    \"\"\" The range enclosing this symbol not including leading/trailing whitespace but everything else\n    like comments. This information is typically used to determine if the clients cursor is\n    inside the symbol to reveal in the symbol in the UI. \"\"\"\n    selectionRange: NotRequired[Range]\n    \"\"\" The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.\n    Must be contained by the `range`. \"\"\"\n\nTreeRepr = Dict[int, List['TreeRepr']]\n\nclass MarkupKind(Enum):\n    \"\"\"Describes the content type that a client supports in various\n    result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n\n    Please note that `MarkupKinds` must not start with a `$`. This kinds\n    are reserved for internal usage.\"\"\"\n\n    PlainText = \"plaintext\"\n    \"\"\" Plain text is supported as a content format \"\"\"\n    Markdown = \"markdown\"\n    \"\"\" Markdown is supported as a content format \"\"\"\n\nclass __MarkedString_Type_1(TypedDict):\n    language: str\n    value: str\n\nMarkedString = Union[str, \"__MarkedString_Type_1\"]\n\"\"\" MarkedString can be used to render human readable text. It is either a markdown string\nor a code-block that provides a language and a code snippet. The language identifier\nis semantically equal to the optional language identifier in fenced code blocks in GitHub\nissues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting\n\nThe pair of a language and a value is an equivalent to markdown:\n```${language}\n${value}\n```\n\nNote that markdown strings will be sanitized - that means html will be escaped.\n@deprecated use MarkupContent instead. \"\"\"\n\nclass MarkupContent(TypedDict):\n    \"\"\"A `MarkupContent` literal represents a string value which content is interpreted base on its\n    kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.\n\n    If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.\n    See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting\n\n    Here is an example how such a string can be constructed using JavaScript / TypeScript:\n    ```ts\n    let markdown: MarkdownContent = {\n     kind: MarkupKind.Markdown,\n     value: [\n       '# Header',\n       'Some text',\n       '```typescript',\n       'someCode();',\n       '```'\n     ].join('\\n')\n    };\n    ```\n\n    *Please Note* that clients might sanitize the return markdown. A client could decide to\n    remove HTML from the markdown to avoid script execution.\"\"\"\n\n    kind: \"MarkupKind\"\n    \"\"\" The type of the Markup \"\"\"\n    value: str\n    \"\"\" The content itself \"\"\"\n\nclass Hover(TypedDict):\n    \"\"\"The result of a hover request.\"\"\"\n\n    contents: Union[\"MarkupContent\", \"MarkedString\", List[\"MarkedString\"]]\n    \"\"\" The hover's content \"\"\"\n    range: NotRequired[\"Range\"]\n    \"\"\" An optional range inside the text document that is used to\n    visualize the hover, e.g. by changing the background color. \"\"\""}
{"type": "source_file", "path": "src/hyperagent/multilspy/lsp_protocol_handler/lsp_constants.py", "content": "\"\"\"\nThis module contains constants used in the LSP protocol.\n\"\"\"\n\nclass LSPConstants:\n    \"\"\"\n    This class contains constants used in the LSP protocol.\n    \"\"\"\n\n    # the key for uri used to represent paths\n    URI = \"uri\"\n\n    # the key for range, which is a from and to position within a text document\n    RANGE = \"range\"\n\n    # A key used in LocationLink type, used as the span of the origin link\n    ORIGIN_SELECTION_RANGE = \"originSelectionRange\"\n\n    # A key used in LocationLink type, used as the target uri of the link\n    TARGET_URI = \"targetUri\"\n\n    # A key used in LocationLink type, used as the target range of the link\n    TARGET_RANGE = \"targetRange\"\n\n    # A key used in LocationLink type, used as the target selection range of the link\n    TARGET_SELECTION_RANGE = \"targetSelectionRange\"\n\n    # key for the textDocument field in the request\n    TEXT_DOCUMENT = \"textDocument\"\n\n    # key used to represent the language a document is in - \"java\", \"csharp\", etc.\n    LANGUAGE_ID = \"languageId\"\n\n    # key used to represent the version of a document (a shared value betwen the client and server)\n    VERSION = \"version\"\n\n    # key used to represent the text of a document being sent from the client to the server on open\n    TEXT = \"text\"\n\n    # key used to represent a position (line and colnum) within a text document\n    POSITION = \"position\"\n\n    # key used to represent the line number of a position\n    LINE = \"line\"\n\n    # key used to represent the column number of a position\n    CHARACTER = \"character\"\n\n    # key used to represent the changes made to a document\n    CONTENT_CHANGES = \"contentChanges\"\n\n    # key used to represent name of symbols\n    NAME = \"name\"\n\n    # key used to represent the kind of symbols\n    KIND = \"kind\"\n\n    # key used to represent children in document symbols\n    CHILDREN = \"children\"\n"}
{"type": "source_file", "path": "src/hyperagent/multilspy/__init__.py", "content": "\"\"\"\nThis module contains the multilspy API\n\"\"\"\n\nfrom . import multilspy_types as Types\nfrom .language_server import LanguageServer, SyncLanguageServer\n\n__all__ = [\"LanguageServer\", \"Types\", \"SyncLanguageServer\"]\n"}
{"type": "source_file", "path": "src/hyperagent/langchain_parsers/language/python.py", "content": "import ast\nfrom typing import Any, List\nfrom langchain_community.document_loaders.parsers.language.code_segmenter import CodeSegmenter\n\n\nclass PythonSegmenter(CodeSegmenter):\n    \"\"\"Code segmenter for `Python`.\"\"\"\n\n    def __init__(self, code: str):\n        super().__init__(code)\n        self.source_lines = self.code.splitlines()\n\n    def is_valid(self) -> bool:\n        try:\n            ast.parse(self.code)\n            return True\n        except SyntaxError:\n            return False\n\n    def _extract_code(self, node: Any) -> str:\n        start = node.lineno - 1\n        end = node.end_lineno\n        return \"\\n\".join(self.source_lines[start:end])\n\n    def extract_functions_classes(self) -> List[str]:\n        tree = ast.parse(self.code)\n        functions_classes = []\n\n        for node in ast.iter_child_nodes(tree):\n            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):\n                functions_classes.append(self._extract_code(node))\n\n        return functions_classes\n\n    def simplify_code(self) -> str:\n        tree = ast.parse(self.code)\n        simplified_lines = self.source_lines[:]\n\n        for node in ast.iter_child_nodes(tree):\n            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):\n                start = node.lineno - 1\n                simplified_lines[start] = f\"# Code for: {simplified_lines[start]}\"\n\n                assert isinstance(node.end_lineno, int)\n                for line_num in range(start + 1, node.end_lineno):\n                    simplified_lines[line_num] = None  # type: ignore\n\n        return \"\\n\".join(line for line in simplified_lines if line is not None)"}
{"type": "source_file", "path": "src/hyperagent/cli/__init__.py", "content": ""}
{"type": "source_file", "path": "src/hyperagent/langchain_parsers/language/tree_sitter_segmenter.py", "content": "from abc import abstractmethod\nfrom typing import TYPE_CHECKING, List\n\nfrom langchain_community.document_loaders.parsers.language.code_segmenter import CodeSegmenter\n\nif TYPE_CHECKING:\n    from tree_sitter import Language, Parser\n\n\nclass TreeSitterSegmenter(CodeSegmenter):\n    \"\"\"Abstract class for `CodeSegmenter`s that use the tree-sitter library.\"\"\"\n\n    def __init__(self, code: str):\n        super().__init__(code)\n        self.source_lines = self.code.splitlines()\n\n        try:\n            import tree_sitter  # noqa: F401\n            import tree_sitter_languages  # noqa: F401\n        except ImportError:\n            raise ImportError(\n                \"Could not import tree_sitter/tree_sitter_languages Python packages. \"\n                \"Please install them with \"\n                \"`pip install tree-sitter tree-sitter-languages`.\"\n            )\n\n    def is_valid(self) -> bool:\n        language = self.get_language()\n        error_query = language.query(\"(ERROR) @error\")\n\n        parser = self.get_parser()\n        tree = parser.parse(bytes(self.code, encoding=\"UTF-8\"))\n\n        return len(error_query.captures(tree.root_node)) == 0\n\n    def extract_functions_classes(self) -> List[str]:\n        language = self.get_language()\n        query = language.query(self.get_chunk_query())\n\n        parser = self.get_parser()\n        tree = parser.parse(bytes(self.code, encoding=\"UTF-8\"))\n        captures = query.captures(tree.root_node)\n\n        processed_lines = set()\n        chunks = []\n\n        for node, name in captures:\n            start_line = node.start_point[0]\n            end_line = node.end_point[0]\n            lines = list(range(start_line, end_line + 1))\n\n            if any(line in processed_lines for line in lines):\n                continue\n\n            processed_lines.update(lines)\n            chunk_text = node.text.decode(\"UTF-8\")\n            chunks.append(chunk_text)\n\n        return chunks\n\n    def simplify_code(self) -> str:\n        language = self.get_language()\n        query = language.query(self.get_chunk_query())\n\n        parser = self.get_parser()\n        tree = parser.parse(bytes(self.code, encoding=\"UTF-8\"))\n        processed_lines = set()\n\n        simplified_lines = self.source_lines[:]\n        for node, name in query.captures(tree.root_node):\n            start_line = node.start_point[0]\n            end_line = node.end_point[0]\n\n            lines = list(range(start_line, end_line + 1))\n            if any(line in processed_lines for line in lines):\n                continue\n\n            simplified_lines[start_line] = self.make_line_comment(\n                f\"Code for: {self.source_lines[start_line]}\"\n            )\n\n            for line_num in range(start_line + 1, end_line + 1):\n                simplified_lines[line_num] = None  # type: ignore\n\n            processed_lines.update(lines)\n\n        return \"\\n\".join(line for line in simplified_lines if line is not None)\n\n    def get_parser(self) -> \"Parser\":\n        from tree_sitter import Parser\n\n        parser = Parser()\n        parser.set_language(self.get_language())\n        return parser\n\n    @abstractmethod\n    def get_language(self) -> \"Language\":\n        raise NotImplementedError()  # pragma: no cover\n\n    @abstractmethod\n    def get_chunk_query(self) -> str:\n        raise NotImplementedError()  # pragma: no cover\n\n    @abstractmethod\n    def make_line_comment(self, text: str) -> str:\n        raise NotImplementedError()  # pragma: no cover"}
{"type": "source_file", "path": "scripts/run_defects4j_apr.py", "content": "from hyperagent import HyperAgent\nfrom datasets import load_dataset\nfrom argparse import ArgumentParser\nfrom hyperagent.tasks.automated_program_repair import AutomatedProgramRepair\nfrom hyperagent.constants import D4J_FOLDER\nimport os\nimport yaml\n\ndef load_yaml_config(file_path):\n    with open(file_path, 'r') as file:\n        config = yaml.safe_load(file)\n    return config\n\ndef get_args():\n    parser = ArgumentParser()\n    parser.add_argument(\"--split\", type=str, default=\"test\")\n    parser.add_argument(\"--config\", type=str, default=\"configs/gpt4o.yaml\")\n    return parser.parse_args()\n\ndef main():\n    args = get_args()\n    \n    config = {\n        \"name\": \"claude\",\n        \"nav\": [{\n            \"model\": \"claude-3-haiku-20240307\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"edit\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"exec\": [{\n            \"model\": \"claude-3-haiku-20240307\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"stop_sequences\": [\"\\nObservation:\"],\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"plan\": [{\n            \"model\": \"claude-3-5-sonnet-20240620\",\n            \"api_type\": os.environ.get(\"ANTHROPIC_API_KEY\"),\n            \"price\": [0.003, 0.015],\n            \"base_url\": \"https://api.anthropic.com\",\n            \"api_type\": \"anthropic\",\n        }],\n        \"type\": \"patch\"\n    }\n    \n    task = AutomatedProgramRepair(logdir=\"results/defects4j_apr\", split=\"test\", max_repetitions=1, max_num_tests=2, defects4j=D4J_FOLDER)\n    result_list = []\n    for idx in range(len(task)):\n        repo_dir = task[idx]\n        pilot = HyperAgent(\n            repo_path=repo_dir,\n            commit=\"\",\n            language=\"java\",\n            llm_configs=config,\n            verbose=2,\n        )\n        result = task.run(pilot, idx)\n        result_list.append(result)\n        performance_table = task.report(result_list)\n        print(performance_table)\n    \nif __name__ == \"__main__\":\n    main()\n"}
{"type": "source_file", "path": "src/hyperagent/multilspy/language_servers/jedi_language_server/jedi_server.py", "content": "\"\"\"\nProvides Python specific instantiation of the LanguageServer class. Contains various configurations and settings specific to Python.\n\"\"\"\n\nimport json\nimport logging\nimport os\nimport pathlib\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncIterator\n\nfrom hyperagent.multilspy.multilspy_logger import MultilspyLogger\nfrom hyperagent.multilspy.language_server import LanguageServer\nfrom hyperagent.multilspy.lsp_protocol_handler.server import ProcessLaunchInfo\nfrom hyperagent.multilspy.lsp_protocol_handler.lsp_types import InitializeParams\nfrom hyperagent.multilspy.multilspy_config import MultilspyConfig\n\n\nclass JediServer(LanguageServer):\n    \"\"\"\n    Provides Python specific instantiation of the LanguageServer class. Contains various configurations and settings specific to Python.\n    \"\"\"\n\n    def __init__(self, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str):\n        \"\"\"\n        Creates a JediServer instance. This class is not meant to be instantiated directly. Use LanguageServer.create() instead.\n        \"\"\"\n        super().__init__(\n            config,\n            logger,\n            repository_root_path,\n            ProcessLaunchInfo(cmd=\"jedi-language-server\", cwd=repository_root_path),\n            \"python\",\n        )\n\n    def _get_initialize_params(self, repository_absolute_path: str) -> InitializeParams:\n        \"\"\"\n        Returns the initialize params for the Jedi Language Server.\n        \"\"\"\n        with open(os.path.join(os.path.dirname(__file__), \"initialize_params.json\"), \"r\") as f:\n            d = json.load(f)\n\n        del d[\"_description\"]\n\n        d[\"processId\"] = os.getpid()\n        assert d[\"rootPath\"] == \"$rootPath\"\n        d[\"rootPath\"] = repository_absolute_path\n\n        assert d[\"rootUri\"] == \"$rootUri\"\n        d[\"rootUri\"] = pathlib.Path(repository_absolute_path).as_uri()\n\n        assert d[\"workspaceFolders\"][0][\"uri\"] == \"$uri\"\n        d[\"workspaceFolders\"][0][\"uri\"] = pathlib.Path(repository_absolute_path).as_uri()\n\n        assert d[\"workspaceFolders\"][0][\"name\"] == \"$name\"\n        d[\"workspaceFolders\"][0][\"name\"] = os.path.basename(repository_absolute_path)\n\n        return d\n\n    @asynccontextmanager\n    async def start_server(self) -> AsyncIterator[\"JediServer\"]:\n        \"\"\"\n        Starts the JEDI Language Server, waits for the server to be ready and yields the LanguageServer instance.\n\n        Usage:\n        ```\n        async with lsp.start_server():\n            # LanguageServer has been initialized and ready to serve requests\n            await lsp.request_definition(...)\n            await lsp.request_references(...)\n            # Shutdown the LanguageServer on exit from scope\n        # LanguageServer has been shutdown\n        ```\n        \"\"\"\n\n        async def execute_client_command_handler(params):\n            return []\n\n        async def do_nothing(params):\n            return\n\n        async def check_experimental_status(params):\n            if params[\"quiescent\"] == True:\n                self.completions_available.set()\n\n        async def window_log_message(msg):\n            self.logger.log(f\"LSP: window/logMessage: {msg}\", logging.INFO)\n\n        self.server.on_request(\"client/registerCapability\", do_nothing)\n        self.server.on_notification(\"language/status\", do_nothing)\n        self.server.on_notification(\"window/logMessage\", window_log_message)\n        self.server.on_request(\"workspace/executeClientCommand\", execute_client_command_handler)\n        self.server.on_notification(\"$/progress\", do_nothing)\n        self.server.on_notification(\"textDocument/publishDiagnostics\", do_nothing)\n        self.server.on_notification(\"language/actionableNotification\", do_nothing)\n        self.server.on_notification(\"experimental/serverStatus\", check_experimental_status)\n\n        async with super().start_server():\n            self.logger.log(\"Starting jedi-language-server server process\", logging.INFO)\n            await self.server.start()\n            initialize_params = self._get_initialize_params(self.repository_root_path)\n\n            self.logger.log(\n                \"Sending initialize request from LSP client to LSP server and awaiting response\",\n                logging.INFO,\n            )\n            init_response = await self.server.send.initialize(initialize_params)\n            assert init_response[\"capabilities\"][\"textDocumentSync\"][\"change\"] == 2\n            assert \"completionProvider\" in init_response[\"capabilities\"]\n            assert init_response[\"capabilities\"][\"completionProvider\"] == {\n                \"triggerCharacters\": [\".\", \"'\", '\"'],\n                \"resolveProvider\": True,\n            }\n\n            self.server.notify.initialized({})\n\n            yield self\n\n            await self.server.shutdown()\n            await self.server.stop()\n"}
{"type": "source_file", "path": "scripts/upload.py", "content": "from huggingface_hub import HfApi\n\napi = HfApi()\n\napi.upload_file(\n\n    path_or_fileobj=\"data/data_instruct_nav.json\",\n\n    path_in_repo=\"data_instruct_nav.json\",\n\n    repo_id=\"huypn16/MetaGent-Nav-Instruct-LoRA\",\n\n    repo_type=\"model\",\n\n)"}
{"type": "source_file", "path": "src/hyperagent/agents/plan_seeking.py", "content": "from autogen import UserProxyAgent, AssistantAgent, GroupChat, GroupChatManager, Agent, ConversableAgent\nfrom autogen.agentchat.contrib.society_of_mind_agent import SocietyOfMindAgent \nfrom hyperagent.agents.llms import LocalLLM\nfrom hyperagent.utils import extract_patch\nfrom hyperagent.prompts.utils import react_prompt_message, react_exec_prompt_message\n\ndef load_summarizer():\n    config = {\"model\": \"meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo\", \"system_prompt\": \"You're a helpful assistant\", \"max_tokens\": 128000}\n    summarizer = LocalLLM(config)\n    return summarizer\n\ndef load_agent_navigator(\n    llm_config,\n    jupyter_executor,\n    sys_prompt,\n    summarizer\n):\n    terminate_condition = lambda x: x.get(\"content\", \"\").find(\"Final Answer:\") > 0 or \"_run\" not in x.get(\"content\", \"\")\n    def response_preparer(self, messages):\n        plain_messages = [message[\"content\"] for message in messages]\n        query = plain_messages[0].split(\"Query: \")[-1].strip()\n        analysis = summarizer(f\"Contexts: {' '.join(plain_messages[1:-1])}. Selectively choose the right context and answer the following `{query}`. You should remain the key code snippets.\")\n        analysis += plain_messages[-1].replace(\"Final Answer:\", \"\")\n        return analysis\n    \n    navigator_assistant = AssistantAgent(\n        \"Inner-Navigator-Assistant\",\n        system_message=sys_prompt,\n        llm_config={\"config_list\": llm_config},\n        human_input_mode=\"NEVER\",\n    )\n    \n    navigator_interpreter = UserProxyAgent(\n        name=\"Navigator Interpreter\",\n        is_termination_msg=terminate_condition,\n        llm_config=False,\n        code_execution_config={\n            \"executor\": jupyter_executor,\n        },\n        human_input_mode=\"NEVER\",\n        default_auto_reply=\"\",\n    )\n    \n    groupchat_nav = GroupChat(\n        agents=[navigator_assistant, navigator_interpreter],\n        messages=[],\n        speaker_selection_method=\"round_robin\", \n        allow_repeat_speaker=False,\n        max_round=15,\n    )\n    \n    manager_nav = GroupChatManager(\n        groupchat=groupchat_nav,\n        name=\"Navigator Manager\",\n        llm_config={\"config_list\": llm_config},\n        max_consecutive_auto_reply=0\n    )\n    \n    navigator = SocietyOfMindAgent(\n        \"Navigator\",\n        chat_manager=manager_nav,\n        llm_config={\"config_list\": llm_config},\n        response_preparer=response_preparer\n    )\n    \n    navigator.register_hook(\n        \"process_last_received_message\",\n        lambda content: react_prompt_message(content),\n    )\n    return navigator\n\ndef load_agent_editor(\n    llm_config,\n    jupyter_executor,\n    sys_prompt,\n    repo_dir\n):\n    terminate_condition = lambda x: x.get(\"content\", \"\").find(\"Final Answer:\") > 0 or \"_run\" not in x.get(\"content\", \"\")\n    def response_preparer(self, messages):\n        plain_messages = [message[\"content\"] for message in messages]\n        query = plain_messages[0].split(\"Query: \")[-1].strip()\n        # analysis = summarizer(f\"Summarize the analysis for following {query} in the codebase. Analysis: {' '.join(plain_messages[1:-1])}\")\n        analysis = f\"Here is the current edit patch: {extract_patch(repo_dir)}\"\n        analysis += plain_messages[-1].replace(\"Final Answer:\", \"\")\n        return analysis\n    \n    editor_assistant = AssistantAgent(\n        \"Inner-Editor-Assistant\",\n        system_message=sys_prompt,\n        llm_config={\"config_list\": llm_config},\n        human_input_mode=\"NEVER\",\n    )\n    \n    editor_interpreter = UserProxyAgent(\n        name=\"Editor Interpreter\",\n        is_termination_msg=terminate_condition,\n        llm_config=False,\n        code_execution_config={\n            \"executor\": jupyter_executor,\n        },\n        human_input_mode=\"NEVER\",\n        default_auto_reply=\"\",\n    )\n    \n    groupchat_edit = GroupChat(\n        agents=[editor_assistant, editor_interpreter],\n        messages=[],\n        speaker_selection_method=\"round_robin\", \n        allow_repeat_speaker=False,\n        max_round=15,\n    )\n    \n    manager_edit = GroupChatManager(\n        groupchat=groupchat_edit,\n        name=\"Editor Manager\",\n        llm_config={\"config_list\": llm_config},\n        max_consecutive_auto_reply=0\n    )\n    \n    editor = SocietyOfMindAgent(\n        \"Editor\",\n        chat_manager=manager_edit,\n        llm_config={\"config_list\": llm_config},\n        response_preparer=response_preparer\n    )\n    \n    editor.register_hook(\n        \"process_last_received_message\",\n        lambda content: react_prompt_message(content),\n    )\n    return editor\n\ndef load_agent_executor(\n    llm_config,\n    docker_executor,\n    sys_prompt,\n    summarizer\n):\n    terminate_condition = lambda x: x.get(\"content\", \"\").find(\"Final Answer:\") > 0\n    def response_preparer(self, messages):\n        plain_messages = [message[\"content\"] for message in messages]\n        query = plain_messages[0].split(\"Query: \")[-1].strip()\n        analysis = \"\"\n        analysis = summarizer(f\"Summarize the bash code execution for following {query} in the codebase, notes that give the key observations. Execution: {' '.join(plain_messages[1:-1])}\")\n        analysis += plain_messages[-1].replace(\"Final Answer:\", \"\")\n        return plain_messages[-1].replace(\"Final Answer:\", \"\")\n    \n    executor_assistant = AssistantAgent(\n        \"Inner-Executor-Assistant\",\n        system_message=sys_prompt,\n        llm_config={\"config_list\": llm_config},\n        human_input_mode=\"NEVER\",\n    )\n    \n    executor_interpreter = UserProxyAgent(\n        name=\"Executor Interpreter\",\n        is_termination_msg=terminate_condition,\n        llm_config=False,\n        code_execution_config={\n            \"executor\": docker_executor,\n        },\n        human_input_mode=\"NEVER\",\n        default_auto_reply=\"\",\n    )\n    \n    groupchat_exec = GroupChat(\n        agents=[executor_assistant, executor_interpreter],\n        messages=[],\n        speaker_selection_method=\"round_robin\", \n        allow_repeat_speaker=False,\n        max_round=15,\n    )\n    \n    manager_exec = GroupChatManager(\n        groupchat=groupchat_exec,\n        name=\"Executor Manager\",\n        llm_config={\"config_list\": llm_config},\n        max_consecutive_auto_reply=0\n    )\n    \n    executor = SocietyOfMindAgent(\n        \"Executor\",\n        chat_manager=manager_exec,\n        llm_config={\"config_list\": llm_config},\n        response_preparer=response_preparer\n    )\n    \n    executor.register_hook(\n        \"process_last_received_message\",\n        lambda content: react_exec_prompt_message(content),\n    )\n    return executor\n\ndef load_agent_planner(system_plan, llm_config):\n    \n    planner = ConversableAgent(\n        \"Planner\",\n        system_message=system_plan,\n        llm_config={\"config_list\": llm_config},\n        code_execution_config=False,\n        human_input_mode=\"NEVER\",\n    )\n    \n    return planner\n\ndef load_manager(user_proxy, planner, navigator, editor, executor, llm_config):\n    \n    def custom_speaker_selection_func(last_speaker: Agent, groupchat: GroupChat):\n        \"\"\"Define a customized speaker selection function.\n        A recommended way is to define a transition for each speaker in the groupchat.\n\n        Returns:\n            Return an `Agent` class or a string from ['auto', 'manual', 'random', 'round_robin'] to select a default method to use.\n        \"\"\"\n        messages = groupchat.messages\n        if llm_config[\"type\"] == \"patch\":\n            if last_speaker is user_proxy:\n                return planner\n            elif \"Navigator\" in messages[-1][\"content\"] and last_speaker == planner:\n                return navigator\n            elif \"Editor\" in messages[-1][\"content\"] and last_speaker == planner:\n                return editor\n            elif \"Executor\" in messages[-1][\"content\"] and last_speaker == planner:\n                return executor\n            else:\n                return planner\n        else:\n            if last_speaker is user_proxy:\n                return planner\n            elif \"Navigator\" in messages[-1][\"content\"] and last_speaker == planner:\n                return navigator\n            elif \"Executor\" in messages[-1][\"content\"] and last_speaker == planner:\n                return executor\n            else:\n                return planner\n            \n    groupchat = GroupChat(agents=[navigator, editor, executor, planner], messages=[], max_round=20, speaker_selection_method=custom_speaker_selection_func)\n    \n    def stop_condition(msg):\n        if \"Final Answer\"in msg[\"content\"]:\n            return True\n        elif all([agent_name not in msg[\"content\"] for agent_name in [\"Navigator\", \"Editor\", \"Executor\"]]) and msg[\"name\"] == \"Planner\":\n            return True\n        else:\n            return False\n    manager = GroupChatManager(name=\"hyperagent\", groupchat=groupchat, llm_config={\"config_list\": llm_config[\"plan\"]}, is_termination_msg=lambda msg: stop_condition(msg))\n    return manager"}
{"type": "source_file", "path": "src/hyperagent/code_search.py", "content": "import logging\nimport os\nimport jedi \nfrom hyperagent.utils import add_num_line\nfrom codetext.utils import parse_code\nfrom codetext.parser import PythonParser, CsharpParser, RustParser, JavaParser\n\nlogging.getLogger('codetext').setLevel(logging.ERROR)\n\ndef get_node_text(start_byte: int, end_byte: int, code: str) -> str:\n    \"\"\"\n    Extract a substring from the given code.\n\n    Args:\n        start_byte (int): The starting index from where to begin the extraction.\n        end_byte (int): The ending index where to stop the extraction.\n        code (str): The string from which to extract the substring.\n\n    Returns:\n        str: The extracted substring from the start_byte to end_byte.\n    \"\"\"\n    return code[start_byte:end_byte]\n\ndef get_parser(language: str):\n    \"\"\"\n    Get a parser corresponding to the given language.\n\n    Args:\n        language (str): The given programming language.\n\n    Returns:\n        Parser corresponding to the given language.\n\n    Raises:\n        NotImplementedError: If the language is not supported.\n    \"\"\"\n    if language == \"python\":\n        return PythonParser()\n    elif language == \"csharp\":\n        return CsharpParser()\n    elif language == \"rust\":\n        return RustParser()\n    elif language == \"java\":\n        return JavaParser()\n    else:\n        raise NotImplementedError(f\"Language {language} is not supported yet\")\n\ndef get_code_jedi(definition: jedi.Script, verbose: bool=False) -> str:\n    \"\"\"\n    Fetch and possibly format code from a jedi.Script definition.\n\n    This function gets the code for a definition and optionally adds line numbers to it.\n\n    Args:\n        definition (jedi.Script): The jedi.Script instance where the code lives.\n        verbose (bool, optional): If true, line numbers are appended before each code line. Defaults to False.\n\n    Returns:\n        str: The raw or line-numbered code as a string.\n    \"\"\"\n    raw = definition.get_line_code(after=definition.get_definition_end_position()[0]-definition.get_definition_start_position()[0])\n    start_num_line = definition.get_definition_start_position()[0] - 2 # jedi start from 1\n    if not verbose:\n        return raw\n    else:\n        results = []\n        splited_raw = raw.split(\"\\n\")\n        for _, line in enumerate(splited_raw):\n            new_line = str(start_num_line + 1) + \" \" + line\n            results.append(new_line)\n            start_num_line += 1\n        return \"\\n\".join(results)\n\ndef search_py_elements_inside_project(names, backend, num_result=3, verbose=False):\n    \"\"\"Get all matched identifiers from a repo\n    \n    Args:\n        names (list): The list of identifiers to be searched\n        backend (object): The backend object that provides search functionality\n        num_result (int, optional): The maximum number of matches for each identifier to return. Defaults to 2.\n        verbose (bool, optional): If true, additional information about the search results is provided. Defaults to False.\n    \n    Returns:\n        list: A list of matched identifiers\n    \n    Raises:\n        None\n    \n    Examples:\n        >>> search_py_elements_inside_project(['foo', 'bar'], backend)\n        {'foo': [{'name': 'FooClass', 'full_name': 'my_module.FooClass', 'documentation': 'This is the documentation for FooClass', 'implementation': 'class FooClass:\\n    def __init__(self):\\n        pass\\n\\n    def foo_method(self):\\n        pass\\n'}],\n         'bar': [{'name': 'bar_function', 'full_name': 'my_module.bar_function', 'documentation': 'This is the documentation for bar_function', 'implementation': 'def bar_function():\\n    pass\\n'}]}\n    \"\"\"\n    output_dict = {name: [] for name in names}\n    for name in names:\n        if not name.endswith(\".py\"):\n            class_definitions = backend.search(f\"class {name}\", all_scopes=True)\n            function_definitions = backend.search(f\"def {name}\", all_scopes=True)\n            variable_definitions = backend.search(name, all_scopes=True)\n            idx = 0\n            for definition in class_definitions:\n                if definition.is_definition():\n                    extracted_definition = {\n                        \"path\": definition.module_path,\n                        \"full_name\": definition.full_name,\n                        \"implementation\": get_code_jedi(definition, verbose)\n                    }\n                    output_dict[name].append(extracted_definition)\n                    idx += 1\n                    if idx == num_result:\n                        break\n            \n            idx = 0\n            for definition in function_definitions:\n                if definition.is_definition():\n                    extracted_definition = {\n                        \"path\": definition.module_path,\n                        \"full_name\": definition.full_name,\n                        \"implementation\": get_code_jedi(definition, verbose),\n                    }\n                    output_dict[name].append(extracted_definition)\n                    idx += 1\n                    if idx == num_result:\n                        break\n            \n            idx = 0\n            for definition in variable_definitions:\n                extracted_definition = {\n                    \"path\": definition.module_path,\n                    \"full_name\": definition.full_name,\n                    \"implementation\": definition.description,\n                }\n                output_dict[name].append(extracted_definition)\n                idx += 1\n                if idx == num_result:\n                    break\n        else:\n            definitions = backend.search(name.replace(\".py\", \"\"))\n            for definition in definitions:\n                implementation = \"\"\n                with open(definition.module_path, \"r\") as f:\n                    implementation += f.read()\n                extracted_definition = {\n                    \"name\": name,\n                    \"implementation\": implementation\n                }\n                output_dict[name].append(extracted_definition)\n            \n    return output_dict\n    \ndef search_zoekt_elements_inside_project(names: list, backend: object, num_result: int = 10, verbose: bool = False) -> dict:\n    \"\"\"\n    Search for elements inside a project using the Zoekt search engine.\n\n    Args:\n        names (list): List of names to be searched in files.\n        backend (object): Backend that provides search functionality.\n        num_result (int, optional): Maximum number of search results to return. Defaults to 2.\n        verbose (bool, optional): If set to True, prints additional information. Defaults to False.\n\n    Returns:\n        dict: A dictionary containing the search results.\n    \"\"\"\n    parser = get_parser(backend.language)\n    search_results = {name: [] for name in names}\n\n    with backend.start_server():\n        zoekt_results = backend.search([f\"{name}\" for name in names], num_result=num_result)\n    for name in names:\n        files = zoekt_results[f'{name}'][\"result\"][\"FileMatches\"]\n        \n        if not files:\n            continue\n\n        for file in files:\n            source = open(os.path.join(backend.repo_path, file[\"FileName\"]), \"r\").read()\n            root_node = parse_code(source, backend.language).root_node\n            function_list = parser.get_function_list(root_node)\n            class_list = parser.get_class_list(root_node)\n            \n\n            for func in function_list:\n                metadata = parser.get_function_metadata(func, source)\n\n                if name in metadata[\"identifier\"]:\n                    result = {\n                        \"file\": file[\"FileName\"].replace(backend.repo_path, \"\"),\n                        \"name\": metadata[\"identifier\"],\n                        \"documentation\": parser.get_docstring(func, source),\n                        \"range\": (func.start_point[0], func.end_point[0]+1)\n                        # \"implementation\": add_num_line(get_node_text(func.start_byte, func.end_byte, source), func.start_point[0])\n                    }\n                    search_results[name].append(result)\n\n            for cls in class_list:\n                metadata = parser.get_class_metadata(cls, source)\n\n                if name in metadata[\"identifier\"]:\n                    result = {\n                        \"file\": file[\"FileName\"],\n                        \"name\": metadata[\"identifier\"],\n                        \"documentation\": parser.get_docstring(cls, source),\n                        \"range\": (func.start_point[0], func.end_point[0]+1)\n                        # \"implementation\": add_num_line(get_node_text(cls.start_byte, cls.end_byte, source), cls.start_point[0])\n                    }\n                    search_results[name].append(result)\n        \n        if len(search_results[name]) < num_result//2:\n            for file in files:\n                source = open(os.path.join(backend.repo_path, file[\"FileName\"]), \"r\").read()\n                lines = source.split(\"\\n\")\n                for line_idx, line in enumerate(lines):\n                    if name in line:\n                        result = {\n                            \"file\": file[\"FileName\"],\n                            \"implementation\": add_num_line(\"\\n\".join(lines[max(0, line_idx-2): min(line_idx+2, len(lines))]), max(0, line_idx-2))\n                        }\n                        search_results[name].append(result)\n    \n    search_results = {name: search_results[name][:num_result] for name in names}\n    \n    out_str = \"\"\n    for name in names:\n        out_str += f\"Results for {name}:\\n\"\n        out_str += f\"{'='*20}\\n\"\n        for result in search_results[name]:\n            out_str += f\"File: {result['file']}\\n\"\n            if \"name\" in result:\n                out_str += f\"Name: {result['name']}\\n\"\n            if \"range\" in result:\n                out_str += f\"Line Range: {result['range']}\\n\" \n            if \"documentation\" in result:\n                out_str += f\"Documentation: {result['documentation']}\\n\"\n            if \"implementation\" in result:\n                out_str += f\"Implementation:\\n{result['implementation']}\\n\"\n            out_str += f\"{'-'*20}\\n\"\n    \n    return out_str\n    \ndef search_elements_inside_project(names, backend, verbose, language):\n    return search_zoekt_elements_inside_project(names, backend, verbose=verbose)\n"}
{"type": "source_file", "path": "src/hyperagent/multilspy/language_servers/eclipse_jdtls/eclipse_jdtls.py", "content": "\"\"\"\nProvides Java specific instantiation of the LanguageServer class. Contains various configurations and settings specific to Java.\n\"\"\"\n\nimport asyncio\nimport dataclasses\nimport json\nimport logging\nimport os\nimport pathlib\nimport shutil\nimport stat\nimport uuid\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncIterator\n\nfrom hyperagent.multilspy.multilspy_logger import MultilspyLogger\nfrom hyperagent.multilspy.language_server import LanguageServer\nfrom hyperagent.multilspy.lsp_protocol_handler.server import ProcessLaunchInfo\nfrom hyperagent.multilspy.lsp_protocol_handler.lsp_types import InitializeParams\nfrom hyperagent.multilspy.multilspy_config import MultilspyConfig\nfrom hyperagent.multilspy.multilspy_settings import MultilspySettings\nfrom hyperagent.multilspy.multilspy_utils import FileUtils\nfrom hyperagent.multilspy.multilspy_utils import PlatformUtils\nfrom pathlib import PurePath\n\n\n@dataclasses.dataclass\nclass RuntimeDependencyPaths:\n    \"\"\"\n    Stores the paths to the runtime dependencies of EclipseJDTLS\n    \"\"\"\n\n    gradle_path: str\n    lombok_jar_path: str\n    jre_path: str\n    jre_home_path: str\n    jdtls_launcher_jar_path: str\n    jdtls_readonly_config_path: str\n    intellicode_jar_path: str\n    intellisense_members_path: str\n\n\nclass EclipseJDTLS(LanguageServer):\n    \"\"\"\n    The EclipseJDTLS class provides a Java specific implementation of the LanguageServer class\n    \"\"\"\n\n    def __init__(self, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str):\n        \"\"\"\n        Creates a new EclipseJDTLS instance initializing the language server settings appropriately.\n        This class is not meant to be instantiated directly. Use LanguageServer.create() instead.\n        \"\"\"\n\n        runtime_dependency_paths = self.setupRuntimeDependencies(logger, config)\n        self.runtime_dependency_paths = runtime_dependency_paths\n\n        # ws_dir is the workspace directory for the EclipseJDTLS server\n        ws_dir = str(\n            PurePath(\n                MultilspySettings.get_language_server_directory(),\n                \"EclipseJDTLS\",\n                \"workspaces\",\n                uuid.uuid4().hex,\n            )\n        )\n\n        # shared_cache_location is the global cache used by Eclipse JDTLS across all workspaces\n        shared_cache_location = str(\n            PurePath(MultilspySettings.get_global_cache_directory(), \"lsp\", \"EclipseJDTLS\", \"sharedIndex\")\n        )\n\n        jre_path = self.runtime_dependency_paths.jre_path\n        lombok_jar_path = self.runtime_dependency_paths.lombok_jar_path\n\n        jdtls_launcher_jar = self.runtime_dependency_paths.jdtls_launcher_jar_path\n\n        os.makedirs(ws_dir, exist_ok=True)\n\n        data_dir = str(PurePath(ws_dir, \"data_dir\"))\n        jdtls_config_path = str(PurePath(ws_dir, \"config_path\"))\n\n        jdtls_readonly_config_path = self.runtime_dependency_paths.jdtls_readonly_config_path\n\n        if not os.path.exists(jdtls_config_path):\n            shutil.copytree(jdtls_readonly_config_path, jdtls_config_path)\n\n        for static_path in [\n            jre_path,\n            lombok_jar_path,\n            jdtls_launcher_jar,\n            jdtls_config_path,\n            jdtls_readonly_config_path,\n        ]:\n            assert os.path.exists(static_path), static_path\n\n        proc_env = {\"syntaxserver\": \"false\"}\n        proc_cwd = repository_root_path\n        cmd = \" \".join(\n            [\n                jre_path,\n                \"--add-modules=ALL-SYSTEM\",\n                \"--add-opens\",\n                \"java.base/java.util=ALL-UNNAMED\",\n                \"--add-opens\",\n                \"java.base/java.lang=ALL-UNNAMED\",\n                \"--add-opens\",\n                \"java.base/sun.nio.fs=ALL-UNNAMED\",\n                \"-Declipse.application=org.eclipse.jdt.ls.core.id1\",\n                \"-Dosgi.bundles.defaultStartLevel=4\",\n                \"-Declipse.product=org.eclipse.jdt.ls.core.product\",\n                \"-Djava.import.generatesMetadataFilesAtProjectRoot=false\",\n                \"-Dfile.encoding=utf8\",\n                \"-noverify\",\n                \"-XX:+UseParallelGC\",\n                \"-XX:GCTimeRatio=4\",\n                \"-XX:AdaptiveSizePolicyWeight=90\",\n                \"-Dsun.zip.disableMemoryMapping=true\",\n                \"-Djava.lsp.joinOnCompletion=true\",\n                \"-Xmx3G\",\n                \"-Xms100m\",\n                \"-Xlog:disable\",\n                \"-Dlog.level=ALL\",\n                f\"-javaagent:{lombok_jar_path}\",\n                f\"-Djdt.core.sharedIndexLocation={shared_cache_location}\",\n                \"-jar\",\n                jdtls_launcher_jar,\n                \"-configuration\",\n                jdtls_config_path,\n                \"-data\",\n                data_dir,\n            ]\n        )\n\n        self.service_ready_event = asyncio.Event()\n        self.intellicode_enable_command_available = asyncio.Event()\n        self.initialize_searcher_command_available = asyncio.Event()\n\n        super().__init__(config, logger, repository_root_path, ProcessLaunchInfo(cmd, proc_env, proc_cwd), \"java\")\n\n    def setupRuntimeDependencies(self, logger: MultilspyLogger, config: MultilspyConfig) -> RuntimeDependencyPaths:\n        \"\"\"\n        Setup runtime dependencies for EclipseJDTLS.\n        \"\"\"\n        platformId = PlatformUtils.get_platform_id()\n\n        with open(str(PurePath(os.path.dirname(__file__), \"runtime_dependencies.json\")), \"r\") as f:\n            runtimeDependencies = json.load(f)\n            del runtimeDependencies[\"_description\"]\n\n        os.makedirs(str(PurePath(os.path.abspath(os.path.dirname(__file__)), \"static\")), exist_ok=True)\n\n        assert platformId.value in [\n            \"linux-x64\",\n            \"win-x64\",\n        ], \"Only linux-x64 platform is supported for in multilspy at the moment\"\n\n        gradle_path = str(\n            PurePath(\n                os.path.abspath(os.path.dirname(__file__)),\n                \"static/gradle-7.3.3\",\n            )\n        )\n\n        if not os.path.exists(gradle_path):\n            FileUtils.download_and_extract_archive(\n                logger,\n                runtimeDependencies[\"gradle\"][\"platform-agnostic\"][\"url\"],\n                str(PurePath(gradle_path).parent),\n                runtimeDependencies[\"gradle\"][\"platform-agnostic\"][\"archiveType\"],\n            )\n\n        assert os.path.exists(gradle_path)\n\n        dependency = runtimeDependencies[\"vscode-java\"][platformId.value]\n        vscode_java_path = str(\n            PurePath(os.path.abspath(os.path.dirname(__file__)), \"static\", dependency[\"relative_extraction_path\"])\n        )\n        os.makedirs(vscode_java_path, exist_ok=True)\n        jre_home_path = str(PurePath(vscode_java_path, dependency[\"jre_home_path\"]))\n        jre_path = str(PurePath(vscode_java_path, dependency[\"jre_path\"]))\n        lombok_jar_path = str(PurePath(vscode_java_path, dependency[\"lombok_jar_path\"]))\n        jdtls_launcher_jar_path = str(PurePath(vscode_java_path, dependency[\"jdtls_launcher_jar_path\"]))\n        jdtls_readonly_config_path = str(PurePath(vscode_java_path, dependency[\"jdtls_readonly_config_path\"]))\n        if not all(\n            [\n                os.path.exists(vscode_java_path),\n                os.path.exists(jre_home_path),\n                os.path.exists(jre_path),\n                os.path.exists(lombok_jar_path),\n                os.path.exists(jdtls_launcher_jar_path),\n                os.path.exists(jdtls_readonly_config_path),\n            ]\n        ):\n            FileUtils.download_and_extract_archive(\n                logger, dependency[\"url\"], vscode_java_path, dependency[\"archiveType\"]\n            )\n\n        os.chmod(jre_path, stat.S_IEXEC)\n\n        assert os.path.exists(vscode_java_path)\n        assert os.path.exists(jre_home_path)\n        assert os.path.exists(jre_path)\n        assert os.path.exists(lombok_jar_path)\n        assert os.path.exists(jdtls_launcher_jar_path)\n        assert os.path.exists(jdtls_readonly_config_path)\n\n        dependency = runtimeDependencies[\"intellicode\"][\"platform-agnostic\"]\n        intellicode_directory_path = str(\n            PurePath(os.path.abspath(os.path.dirname(__file__)), \"static\", dependency[\"relative_extraction_path\"])\n        )\n        os.makedirs(intellicode_directory_path, exist_ok=True)\n        intellicode_jar_path = str(PurePath(intellicode_directory_path, dependency[\"intellicode_jar_path\"]))\n        intellisense_members_path = str(PurePath(intellicode_directory_path, dependency[\"intellisense_members_path\"]))\n        if not all(\n            [\n                os.path.exists(intellicode_directory_path),\n                os.path.exists(intellicode_jar_path),\n                os.path.exists(intellisense_members_path),\n            ]\n        ):\n            FileUtils.download_and_extract_archive(\n                logger, dependency[\"url\"], intellicode_directory_path, dependency[\"archiveType\"]\n            )\n\n        assert os.path.exists(intellicode_directory_path)\n        assert os.path.exists(intellicode_jar_path)\n        assert os.path.exists(intellisense_members_path)\n\n        return RuntimeDependencyPaths(\n            gradle_path=gradle_path,\n            lombok_jar_path=lombok_jar_path,\n            jre_path=jre_path,\n            jre_home_path=jre_home_path,\n            jdtls_launcher_jar_path=jdtls_launcher_jar_path,\n            jdtls_readonly_config_path=jdtls_readonly_config_path,\n            intellicode_jar_path=intellicode_jar_path,\n            intellisense_members_path=intellisense_members_path,\n        )\n\n    def _get_initialize_params(self, repository_absolute_path: str) -> InitializeParams:\n        \"\"\"\n        Returns the initialize parameters for the EclipseJDTLS server.\n        \"\"\"\n        # Look into https://github.com/eclipse/eclipse.jdt.ls/blob/master/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/preferences/Preferences.java to understand all the options available\n        with open(str(PurePath(os.path.dirname(__file__), \"initialize_params.json\")), \"r\") as f:\n            d: InitializeParams = json.load(f)\n\n        del d[\"_description\"]\n\n        if not os.path.isabs(repository_absolute_path):\n            repository_absolute_path = os.path.abspath(repository_absolute_path)\n\n        assert d[\"processId\"] == \"os.getpid()\"\n        d[\"processId\"] = os.getpid()\n\n        assert d[\"rootPath\"] == \"repository_absolute_path\"\n        d[\"rootPath\"] = repository_absolute_path\n\n        assert d[\"rootUri\"] == \"pathlib.Path(repository_absolute_path).as_uri()\"\n        d[\"rootUri\"] = pathlib.Path(repository_absolute_path).as_uri()\n\n        assert d[\"initializationOptions\"][\"workspaceFolders\"] == \"[pathlib.Path(repository_absolute_path).as_uri()]\"\n        d[\"initializationOptions\"][\"workspaceFolders\"] = [pathlib.Path(repository_absolute_path).as_uri()]\n\n        assert (\n            d[\"workspaceFolders\"]\n            == '[\\n            {\\n                \"uri\": pathlib.Path(repository_absolute_path).as_uri(),\\n                \"name\": os.path.basename(repository_absolute_path),\\n            }\\n        ]'\n        )\n        d[\"workspaceFolders\"] = [\n            {\n                \"uri\": pathlib.Path(repository_absolute_path).as_uri(),\n                \"name\": os.path.basename(repository_absolute_path),\n            }\n        ]\n\n        assert d[\"initializationOptions\"][\"bundles\"] == [\"intellicode-core.jar\"]\n        bundles = [self.runtime_dependency_paths.intellicode_jar_path]\n        d[\"initializationOptions\"][\"bundles\"] = bundles\n\n        assert d[\"initializationOptions\"][\"settings\"][\"java\"][\"configuration\"][\"runtimes\"] == [\n            {\"name\": \"JavaSE-17\", \"path\": \"static/vscode-java/extension/jre/17.0.8.1-linux-x86_64\", \"default\": True}\n        ]\n        d[\"initializationOptions\"][\"settings\"][\"java\"][\"configuration\"][\"runtimes\"] = [\n            {\"name\": \"JavaSE-17\", \"path\": self.runtime_dependency_paths.jre_home_path, \"default\": True}\n        ]\n\n        for runtime in d[\"initializationOptions\"][\"settings\"][\"java\"][\"configuration\"][\"runtimes\"]:\n            assert \"name\" in runtime\n            assert \"path\" in runtime\n            assert os.path.exists(\n                runtime[\"path\"]\n            ), f\"Runtime required for eclipse_jdtls at path {runtime['path']} does not exist\"\n\n        assert d[\"initializationOptions\"][\"settings\"][\"java\"][\"import\"][\"gradle\"][\"home\"] == \"abs(static/gradle-7.3.3)\"\n        d[\"initializationOptions\"][\"settings\"][\"java\"][\"import\"][\"gradle\"][\n            \"home\"\n        ] = self.runtime_dependency_paths.gradle_path\n\n        d[\"initializationOptions\"][\"settings\"][\"java\"][\"import\"][\"gradle\"][\"java\"][\n            \"home\"\n        ] = self.runtime_dependency_paths.jre_path\n\n        return d\n\n    @asynccontextmanager\n    async def start_server(self) -> AsyncIterator[\"EclipseJDTLS\"]:\n        \"\"\"\n        Starts the Eclipse JDTLS Language Server, waits for the server to be ready and yields the LanguageServer instance.\n\n        Usage:\n        ```\n        async with lsp.start_server():\n            # LanguageServer has been initialized and ready to serve requests\n            await lsp.request_definition(...)\n            await lsp.request_references(...)\n            # Shutdown the LanguageServer on exit from scope\n        # LanguageServer has been shutdown\n        ```\n        \"\"\"\n\n        async def register_capability_handler(params):\n            assert \"registrations\" in params\n            for registration in params[\"registrations\"]:\n                if registration[\"method\"] == \"textDocument/completion\":\n                    assert registration[\"registerOptions\"][\"resolveProvider\"] == True\n                    assert registration[\"registerOptions\"][\"triggerCharacters\"] == [\n                        \".\",\n                        \"@\",\n                        \"#\",\n                        \"*\",\n                        \" \",\n                    ]\n                    self.completions_available.set()\n                if registration[\"method\"] == \"workspace/executeCommand\":\n                    if \"java.intellicode.enable\" in registration[\"registerOptions\"][\"commands\"]:\n                        self.intellicode_enable_command_available.set()\n            return\n\n        async def lang_status_handler(params):\n            # TODO: Should we wait for\n            # server -> client: {'jsonrpc': '2.0', 'method': 'language/status', 'params': {'type': 'ProjectStatus', 'message': 'OK'}}\n            # Before proceeding?\n            if params[\"type\"] == \"ServiceReady\" and params[\"message\"] == \"ServiceReady\":\n                self.service_ready_event.set()\n\n        async def execute_client_command_handler(params):\n            assert params[\"command\"] == \"_java.reloadBundles.command\"\n            assert params[\"arguments\"] == []\n            return []\n\n        async def window_log_message(msg):\n            self.logger.log(f\"LSP: window/logMessage: {msg}\", logging.INFO)\n\n        async def do_nothing(params):\n            return\n\n        self.server.on_request(\"client/registerCapability\", register_capability_handler)\n        self.server.on_notification(\"language/status\", lang_status_handler)\n        self.server.on_notification(\"window/logMessage\", window_log_message)\n        self.server.on_request(\"workspace/executeClientCommand\", execute_client_command_handler)\n        self.server.on_notification(\"$/progress\", do_nothing)\n        self.server.on_notification(\"textDocument/publishDiagnostics\", do_nothing)\n        self.server.on_notification(\"language/actionableNotification\", do_nothing)\n\n        async with super().start_server():\n            self.logger.log(\"Starting EclipseJDTLS server process\", logging.INFO)\n            await self.server.start()\n            initialize_params = self._get_initialize_params(self.repository_root_path)\n\n            self.logger.log(\n                \"Sending initialize request from LSP client to LSP server and awaiting response\",\n                logging.INFO,\n            )\n            init_response = await self.server.send.initialize(initialize_params)\n            assert init_response[\"capabilities\"][\"textDocumentSync\"][\"change\"] == 2\n            assert \"completionProvider\" not in init_response[\"capabilities\"]\n            assert \"executeCommandProvider\" not in init_response[\"capabilities\"]\n\n            self.server.notify.initialized({})\n\n            self.server.notify.workspace_did_change_configuration(\n                {\"settings\": initialize_params[\"initializationOptions\"][\"settings\"]}\n            )\n\n            await self.intellicode_enable_command_available.wait()\n\n            java_intellisense_members_path = self.runtime_dependency_paths.intellisense_members_path\n            assert os.path.exists(java_intellisense_members_path)\n            intellicode_enable_result = await self.server.send.execute_command(\n                {\n                    \"command\": \"java.intellicode.enable\",\n                    \"arguments\": [True, java_intellisense_members_path],\n                }\n            )\n            assert intellicode_enable_result\n\n            # TODO: Add comments about why we wait here, and how this can be optimized\n            await self.service_ready_event.wait()\n\n            yield self\n\n            await self.server.shutdown()\n            await self.server.stop()\n"}
{"type": "source_file", "path": "scripts/data_generation.py", "content": "from hyperagent import HyperAgent\n\nimport os\nimport logging\nfrom hyperagent import HyperAgent\nfrom langchain.callbacks.manager import get_openai_callback\nfrom langchain.utilities.portkey import Portkey\n\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nlogging.getLogger('codetext').setLevel(logging.WARNING)\nlogging.getLogger('hyperagent').setLevel(logging.WARNING)\nlogging.getLogger(\"httpx\").setLevel(logging.WARNING)\nlogging.getLogger(\"multilspy\").setLevel(logging.WARNING)\n\nlogger = logging.getLogger(__name__)\n\n\nif __name__ == \"__main__\":\n    logger.info(\"Start!\")\n    api_key = os.environ.get(\"OPENAI_API_KEY\")\n    # repo = \"aura-nw/cw-ics721\"\n    repo = \"huggingface/peft\"\n    # repo = \"TempleRAIL/drl_vo_nav\"\n    commit = \"ee6f6dcee70b6e3626518816e8f0116c7083fe6f\"\n    language = \"python\"\n    # question = input(\"Enter your question about your repository: \")\n    # question = \"what is the main flow of the project?\"\n    question = \"\"\"How to add new memory efficient fine-tuning technique to the project?\"\"\"\n    #TODO: add a check for a local repo execution\n    pilot = HyperAgent(repo, commit=commit, openai_api_key=api_key, local=False, language=language, clone_dir=\"data/repos\", save_trajectories_path=f\"data/trajectories/{language}/feature_rq/{repo}\")\n    logger.info(\"Setup done!\")\n    \n    with get_openai_callback() as cb:\n        pilot.query_codebase(question)\n        print(f\"Total Tokens: {cb.total_tokens}\")\n        print(f\"Prompt Tokens: {cb.prompt_tokens}\")\n        print(f\"Completion Tokens: {cb.completion_tokens}\")\n        print(f\"Total Cost (USD): ${cb.total_cost}\")"}
{"type": "source_file", "path": "src/hyperagent/multilspy/multilspy_logger.py", "content": "\"\"\"\nMultilspy logger module.\n\"\"\"\nimport inspect\nimport logging\nfrom datetime import datetime\nfrom pydantic import BaseModel\n\nclass LogLine(BaseModel):\n    \"\"\"\n    Represents a line in the Multilspy log\n    \"\"\"\n\n    time: str\n    level: str\n    caller_file: str\n    caller_name: str\n    caller_line: int\n    message: str\n\nclass MultilspyLogger:\n    \"\"\"\n    Logger class\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.logger = logging.getLogger(\"multilspy\")\n        self.logger.setLevel(logging.WARNING)\n\n    def log(self, debug_message: str, level: int, sanitized_error_message: str = \"\") -> None:\n        \"\"\"\n        Log the debug and santized messages using the logger\n        \"\"\"\n\n        debug_message = debug_message.replace(\"'\", '\"').replace(\"\\n\", \" \")\n        sanitized_error_message = sanitized_error_message.replace(\"'\", '\"').replace(\"\\n\", \" \")\n\n        # Collect details about the callee\n        curframe = inspect.currentframe()\n        calframe = inspect.getouterframes(curframe, 2)\n        caller_file = calframe[1][1].split(\"/\")[-1]\n        caller_line = calframe[1][2]\n        caller_name = calframe[1][3]\n\n        # Construct the debug log line\n        debug_log_line = LogLine(\n            time=str(datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")),\n            level=logging.getLevelName(level),\n            caller_file=caller_file,\n            caller_name=caller_name,\n            caller_line=caller_line,\n            message=debug_message,\n        )\n\n        self.logger.log(\n            level=level,\n            msg=debug_log_line.json(),\n        )\n"}
{"type": "source_file", "path": "src/hyperagent/multilspy/language_servers/omnisharp/omnisharp.py", "content": "\"\"\"\nProvides C# specific instantiation of the LanguageServer class. Contains various configurations and settings specific to C#.\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport os\nimport pathlib\nimport stat\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncIterator, Iterable\n\nfrom hyperagent.multilspy.multilspy_logger import MultilspyLogger\nfrom hyperagent.multilspy.language_server import LanguageServer\nfrom hyperagent.multilspy.lsp_protocol_handler.server import ProcessLaunchInfo\nfrom hyperagent.multilspy.lsp_protocol_handler.lsp_types import InitializeParams\nfrom hyperagent.multilspy.multilspy_config import MultilspyConfig\nfrom hyperagent.multilspy.multilspy_exceptions import MultilspyException\nfrom hyperagent.multilspy.multilspy_utils import FileUtils, PlatformUtils, PlatformId, DotnetVersion\n\n\ndef breadth_first_file_scan(root) -> Iterable[str]:\n    \"\"\"\n    This function was obtained from https://stackoverflow.com/questions/49654234/is-there-a-breadth-first-search-option-available-in-os-walk-or-equivalent-py\n    It traverses the directory tree in breadth first order.\n    \"\"\"\n    dirs = [root]\n    # while we has dirs to scan\n    while len(dirs):\n        next_dirs = []\n        for parent in dirs:\n            # scan each dir\n            for f in os.listdir(parent):\n                # if there is a dir, then save for next ittr\n                # if it  is a file then yield it (we'll return later)\n                ff = os.path.join(parent, f)\n                if os.path.isdir(ff):\n                    next_dirs.append(ff)\n                else:\n                    yield ff\n\n        # once we've done all the current dirs then\n        # we set up the next itter as the child dirs\n        # from the current itter.\n        dirs = next_dirs\n\n\ndef find_least_depth_sln_file(root_dir) -> str:\n    for filename in breadth_first_file_scan(root_dir):\n        if filename.endswith(\".sln\"):\n            return filename\n    return None\n\n\nclass OmniSharp(LanguageServer):\n    \"\"\"\n    Provides C# specific instantiation of the LanguageServer class. Contains various configurations and settings specific to C#.\n    \"\"\"\n\n    def __init__(self, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str):\n        \"\"\"\n        Creates an OmniSharp instance. This class is not meant to be instantiated directly. Use LanguageServer.create() instead.\n        \"\"\"\n        omnisharp_executable_path, dll_path = self.setupRuntimeDependencies(logger, config)\n\n        slnfilename = find_least_depth_sln_file(repository_root_path)\n        if slnfilename is None:\n            logger.log(\"No *.sln file found in repository\", logging.ERROR)\n            raise MultilspyException(\"No SLN file found in repository\")\n\n        cmd = \" \".join(\n            [\n                omnisharp_executable_path,\n                \"-lsp\",\n                \"--encoding\",\n                \"ascii\",\n                \"-z\",\n                \"-s\",\n                slnfilename,\n                \"--hostPID\",\n                str(os.getpid()),\n                \"DotNet:enablePackageRestore=false\",\n                \"--loglevel\",\n                \"trace\",\n                \"--plugin\",\n                dll_path,\n                \"FileOptions:SystemExcludeSearchPatterns:0=**/.git\",\n                \"FileOptions:SystemExcludeSearchPatterns:1=**/.svn\",\n                \"FileOptions:SystemExcludeSearchPatterns:2=**/.hg\",\n                \"FileOptions:SystemExcludeSearchPatterns:3=**/CVS\",\n                \"FileOptions:SystemExcludeSearchPatterns:4=**/.DS_Store\",\n                \"FileOptions:SystemExcludeSearchPatterns:5=**/Thumbs.db\",\n                \"RoslynExtensionsOptions:EnableAnalyzersSupport=true\",\n                \"FormattingOptions:EnableEditorConfigSupport=true\",\n                \"RoslynExtensionsOptions:EnableImportCompletion=true\",\n                \"Sdk:IncludePrereleases=true\",\n                \"RoslynExtensionsOptions:AnalyzeOpenDocumentsOnly=true\",\n                \"formattingOptions:useTabs=false\",\n                \"formattingOptions:tabSize=4\",\n                \"formattingOptions:indentationSize=4\",\n            ]\n        )\n        super().__init__(\n            config, logger, repository_root_path, ProcessLaunchInfo(cmd=cmd, cwd=repository_root_path), \"csharp\"\n        )\n\n        self.definition_available = asyncio.Event()\n        self.references_available = asyncio.Event()\n\n    def _get_initialize_params(self, repository_absolute_path: str) -> InitializeParams:\n        \"\"\"\n        Returns the initialize params for the Rust Analyzer Language Server.\n        \"\"\"\n        with open(os.path.join(os.path.dirname(__file__), \"initialize_params.json\"), \"r\") as f:\n            d = json.load(f)\n\n        del d[\"_description\"]\n\n        d[\"processId\"] = os.getpid()\n        assert d[\"rootPath\"] == \"$rootPath\"\n        d[\"rootPath\"] = repository_absolute_path\n\n        assert d[\"rootUri\"] == \"$rootUri\"\n        d[\"rootUri\"] = pathlib.Path(repository_absolute_path).as_uri()\n\n        assert d[\"workspaceFolders\"][0][\"uri\"] == \"$uri\"\n        d[\"workspaceFolders\"][0][\"uri\"] = pathlib.Path(repository_absolute_path).as_uri()\n\n        assert d[\"workspaceFolders\"][0][\"name\"] == \"$name\"\n        d[\"workspaceFolders\"][0][\"name\"] = os.path.basename(repository_absolute_path)\n\n        return d\n\n    def setupRuntimeDependencies(self, logger: MultilspyLogger, config: MultilspyConfig) -> tuple[str, str]:\n        \"\"\"\n        Setup runtime dependencies for OmniSharp.\n        \"\"\"\n        platform_id = PlatformUtils.get_platform_id()\n        dotnet_version = PlatformUtils.get_dotnet_version()\n\n        with open(os.path.join(os.path.dirname(__file__), \"runtime_dependencies.json\"), \"r\") as f:\n            d = json.load(f)\n            del d[\"_description\"]\n\n        assert platform_id in [\n            PlatformId.LINUX_x64,\n            PlatformId.WIN_x64,\n        ], \"Only linux-x64 and win-x64 platform is supported for in multilspy at the moment\"\n        assert dotnet_version in [\n            DotnetVersion.V6,\n            DotnetVersion.V7,\n        ], \"Only dotnet version 6 and 7 are supported in multilspy at the moment\"\n\n        # TODO: Do away with this assumption\n        # Currently, runtime binaries are not available for .Net 7. Hence, we assume .Net 6 runtime binaries to be compatible with .Net 7\n        if dotnet_version == DotnetVersion.V7:\n            dotnet_version = DotnetVersion.V6\n\n        runtime_dependencies = d[\"runtimeDependencies\"]\n        runtime_dependencies = [\n            dependency for dependency in runtime_dependencies if dependency[\"platformId\"] == platform_id.value\n        ]\n        runtime_dependencies = [\n            dependency\n            for dependency in runtime_dependencies\n            if not (\"dotnet_version\" in dependency) or dependency[\"dotnet_version\"] == dotnet_version.value\n        ]\n        assert len(runtime_dependencies) == 2\n        runtime_dependencies = {\n            runtime_dependencies[0][\"id\"]: runtime_dependencies[0],\n            runtime_dependencies[1][\"id\"]: runtime_dependencies[1],\n        }\n\n        assert \"OmniSharp\" in runtime_dependencies\n        assert \"RazorOmnisharp\" in runtime_dependencies\n\n        omnisharp_ls_dir = os.path.join(os.path.dirname(__file__), \"static\", \"OmniSharp\")\n        if not os.path.exists(omnisharp_ls_dir):\n            os.makedirs(omnisharp_ls_dir)\n            FileUtils.download_and_extract_archive(\n                logger, runtime_dependencies[\"OmniSharp\"][\"url\"], omnisharp_ls_dir, \"zip\"\n            )\n        omnisharp_executable_path = os.path.join(omnisharp_ls_dir, runtime_dependencies[\"OmniSharp\"][\"binaryName\"])\n        assert os.path.exists(omnisharp_executable_path)\n        os.chmod(omnisharp_executable_path, stat.S_IEXEC)\n\n        razor_omnisharp_ls_dir = os.path.join(os.path.dirname(__file__), \"static\", \"RazorOmnisharp\")\n        if not os.path.exists(razor_omnisharp_ls_dir):\n            os.makedirs(razor_omnisharp_ls_dir)\n            FileUtils.download_and_extract_archive(\n                logger, runtime_dependencies[\"RazorOmnisharp\"][\"url\"], razor_omnisharp_ls_dir, \"zip\"\n            )\n        razor_omnisharp_dll_path = os.path.join(\n            razor_omnisharp_ls_dir, runtime_dependencies[\"RazorOmnisharp\"][\"dll_path\"]\n        )\n        assert os.path.exists(razor_omnisharp_dll_path)\n\n        return omnisharp_executable_path, razor_omnisharp_dll_path\n\n    @asynccontextmanager\n    async def start_server(self) -> AsyncIterator[\"OmniSharp\"]:\n        \"\"\"\n        Starts the Rust Analyzer Language Server, waits for the server to be ready and yields the LanguageServer instance.\n\n        Usage:\n        ```\n        async with lsp.start_server():\n            # LanguageServer has been initialized and ready to serve requests\n            await lsp.request_definition(...)\n            await lsp.request_references(...)\n            # Shutdown the LanguageServer on exit from scope\n        # LanguageServer has been shutdown\n        \"\"\"\n\n        async def register_capability_handler(params):\n            assert \"registrations\" in params\n            for registration in params[\"registrations\"]:\n                if registration[\"method\"] == \"textDocument/definition\":\n                    self.definition_available.set()\n                if registration[\"method\"] == \"textDocument/references\":\n                    self.references_available.set()\n                if registration[\"method\"] == \"textDocument/completion\":\n                    self.completions_available.set()\n\n        async def lang_status_handler(params):\n            # TODO: Should we wait for\n            # server -> client: {'jsonrpc': '2.0', 'method': 'language/status', 'params': {'type': 'ProjectStatus', 'message': 'OK'}}\n            # Before proceeding?\n            # if params[\"type\"] == \"ServiceReady\" and params[\"message\"] == \"ServiceReady\":\n            #     self.service_ready_event.set()\n            pass\n\n        async def execute_client_command_handler(params):\n            return []\n\n        async def do_nothing(params):\n            return\n\n        async def check_experimental_status(params):\n            if params[\"quiescent\"] == True:\n                self.server_ready.set()\n\n        async def window_log_message(msg):\n            self.logger.log(f\"LSP: window/logMessage: {msg}\", logging.INFO)\n\n        async def workspace_configuration_handler(params):\n            # TODO: We do not know the appropriate way to handle this request. Should ideally contact the OmniSharp dev team\n            return [\n                {\n                    \"RoslynExtensionsOptions\": {\n                        \"EnableDecompilationSupport\": False,\n                        \"EnableAnalyzersSupport\": True,\n                        \"EnableImportCompletion\": True,\n                        \"EnableAsyncCompletion\": False,\n                        \"DocumentAnalysisTimeoutMs\": 30000,\n                        \"DiagnosticWorkersThreadCount\": 18,\n                        \"AnalyzeOpenDocumentsOnly\": True,\n                        \"InlayHintsOptions\": {\n                            \"EnableForParameters\": False,\n                            \"ForLiteralParameters\": False,\n                            \"ForIndexerParameters\": False,\n                            \"ForObjectCreationParameters\": False,\n                            \"ForOtherParameters\": False,\n                            \"SuppressForParametersThatDifferOnlyBySuffix\": False,\n                            \"SuppressForParametersThatMatchMethodIntent\": False,\n                            \"SuppressForParametersThatMatchArgumentName\": False,\n                            \"EnableForTypes\": False,\n                            \"ForImplicitVariableTypes\": False,\n                            \"ForLambdaParameterTypes\": False,\n                            \"ForImplicitObjectCreation\": False,\n                        },\n                        \"LocationPaths\": None,\n                    },\n                    \"FormattingOptions\": {\n                        \"OrganizeImports\": False,\n                        \"EnableEditorConfigSupport\": True,\n                        \"NewLine\": \"\\n\",\n                        \"UseTabs\": False,\n                        \"TabSize\": 4,\n                        \"IndentationSize\": 4,\n                        \"SpacingAfterMethodDeclarationName\": False,\n                        \"SeparateImportDirectiveGroups\": False,\n                        \"SpaceWithinMethodDeclarationParenthesis\": False,\n                        \"SpaceBetweenEmptyMethodDeclarationParentheses\": False,\n                        \"SpaceAfterMethodCallName\": False,\n                        \"SpaceWithinMethodCallParentheses\": False,\n                        \"SpaceBetweenEmptyMethodCallParentheses\": False,\n                        \"SpaceAfterControlFlowStatementKeyword\": True,\n                        \"SpaceWithinExpressionParentheses\": False,\n                        \"SpaceWithinCastParentheses\": False,\n                        \"SpaceWithinOtherParentheses\": False,\n                        \"SpaceAfterCast\": False,\n                        \"SpaceBeforeOpenSquareBracket\": False,\n                        \"SpaceBetweenEmptySquareBrackets\": False,\n                        \"SpaceWithinSquareBrackets\": False,\n                        \"SpaceAfterColonInBaseTypeDeclaration\": True,\n                        \"SpaceAfterComma\": True,\n                        \"SpaceAfterDot\": False,\n                        \"SpaceAfterSemicolonsInForStatement\": True,\n                        \"SpaceBeforeColonInBaseTypeDeclaration\": True,\n                        \"SpaceBeforeComma\": False,\n                        \"SpaceBeforeDot\": False,\n                        \"SpaceBeforeSemicolonsInForStatement\": False,\n                        \"SpacingAroundBinaryOperator\": \"single\",\n                        \"IndentBraces\": False,\n                        \"IndentBlock\": True,\n                        \"IndentSwitchSection\": True,\n                        \"IndentSwitchCaseSection\": True,\n                        \"IndentSwitchCaseSectionWhenBlock\": True,\n                        \"LabelPositioning\": \"oneLess\",\n                        \"WrappingPreserveSingleLine\": True,\n                        \"WrappingKeepStatementsOnSingleLine\": True,\n                        \"NewLinesForBracesInTypes\": True,\n                        \"NewLinesForBracesInMethods\": True,\n                        \"NewLinesForBracesInProperties\": True,\n                        \"NewLinesForBracesInAccessors\": True,\n                        \"NewLinesForBracesInAnonymousMethods\": True,\n                        \"NewLinesForBracesInControlBlocks\": True,\n                        \"NewLinesForBracesInAnonymousTypes\": True,\n                        \"NewLinesForBracesInObjectCollectionArrayInitializers\": True,\n                        \"NewLinesForBracesInLambdaExpressionBody\": True,\n                        \"NewLineForElse\": True,\n                        \"NewLineForCatch\": True,\n                        \"NewLineForFinally\": True,\n                        \"NewLineForMembersInObjectInit\": True,\n                        \"NewLineForMembersInAnonymousTypes\": True,\n                        \"NewLineForClausesInQuery\": True,\n                    },\n                    \"FileOptions\": {\n                        \"SystemExcludeSearchPatterns\": [\n                            \"**/node_modules/**/*\",\n                            \"**/bin/**/*\",\n                            \"**/obj/**/*\",\n                            \"**/.git/**/*\",\n                            \"**/.git\",\n                            \"**/.svn\",\n                            \"**/.hg\",\n                            \"**/CVS\",\n                            \"**/.DS_Store\",\n                            \"**/Thumbs.db\",\n                        ],\n                        \"ExcludeSearchPatterns\": [],\n                    },\n                    \"RenameOptions\": {\n                        \"RenameOverloads\": False,\n                        \"RenameInStrings\": False,\n                        \"RenameInComments\": False,\n                    },\n                    \"ImplementTypeOptions\": {\n                        \"InsertionBehavior\": 0,\n                        \"PropertyGenerationBehavior\": 0,\n                    },\n                    \"DotNetCliOptions\": {\"LocationPaths\": None},\n                    \"Plugins\": {\"LocationPaths\": None},\n                }\n            ]\n\n        self.server.on_request(\"client/registerCapability\", register_capability_handler)\n        self.server.on_notification(\"language/status\", lang_status_handler)\n        self.server.on_notification(\"window/logMessage\", window_log_message)\n        self.server.on_request(\"workspace/executeClientCommand\", execute_client_command_handler)\n        self.server.on_notification(\"$/progress\", do_nothing)\n        self.server.on_notification(\"textDocument/publishDiagnostics\", do_nothing)\n        self.server.on_notification(\"language/actionableNotification\", do_nothing)\n        self.server.on_notification(\"experimental/serverStatus\", check_experimental_status)\n        self.server.on_request(\"workspace/configuration\", workspace_configuration_handler)\n\n        async with super().start_server():\n            self.logger.log(\"Starting OmniSharp server process\", logging.INFO)\n            await self.server.start()\n            initialize_params = self._get_initialize_params(self.repository_root_path)\n\n            self.logger.log(\n                \"Sending initialize request from LSP client to LSP server and awaiting response\",\n                logging.INFO,\n            )\n            init_response = await self.server.send.initialize(initialize_params)\n            self.server.notify.initialized({})\n            with open(os.path.join(os.path.dirname(__file__), \"workspace_did_change_configuration.json\"), \"r\") as f:\n                self.server.notify.workspace_did_change_configuration({\n                    \"settings\": json.load(f)\n                })\n            assert \"capabilities\" in init_response\n            if (\n                \"definitionProvider\" in init_response[\"capabilities\"]\n                and init_response[\"capabilities\"][\"definitionProvider\"]\n            ):\n                self.definition_available.set()\n            if (\n                \"referencesProvider\" in init_response[\"capabilities\"]\n                and init_response[\"capabilities\"][\"referencesProvider\"]\n            ):\n                self.references_available.set()\n\n            await self.definition_available.wait()\n            await self.references_available.wait()\n\n            yield self\n\n            await self.server.shutdown()\n            await self.server.stop()\n"}
{"type": "source_file", "path": "src/hyperagent/get_repo_struct.py", "content": "from pathlib import Path\nfrom itertools import islice\n\nspace =  '    '\nbranch = '│   '\ntee =    '├── '\nlast =   '└── '\n\nclass DisplayablePath(object):\n    display_filename_prefix_middle = '├──'\n    display_filename_prefix_last = '└──'\n    display_parent_prefix_middle = '    '\n    display_parent_prefix_last = '│   '\n\n    def __init__(self, path, parent_path, is_last):\n        self.path = Path(str(path))\n        self.parent = parent_path\n        self.is_last = is_last\n        if self.parent:\n            self.depth = self.parent.depth + 1\n        else:\n            self.depth = 0\n\n    @property\n    def displayname(self):\n        if self.path.is_dir():\n            return self.path.name + '/'\n        return self.path.name\n\n    @classmethod\n    def make_tree(cls, root, parent=None, is_last=False, criteria=None):\n        root = Path(str(root))\n        criteria = criteria or cls._default_criteria\n\n        displayable_root = cls(root, parent, is_last)\n        yield displayable_root\n\n        children = sorted(list(path\n                               for path in root.iterdir()\n                               if criteria(path)),\n                          key=lambda s: str(s).lower())\n        count = 1\n        for path in children:\n            is_last = count == len(children)\n            if path.is_dir():\n                yield from cls.make_tree(path,\n                                         parent=displayable_root,\n                                         is_last=is_last,\n                                         criteria=criteria)\n            else:\n                yield cls(path, displayable_root, is_last)\n            count += 1\n\n    @classmethod\n    def _default_criteria(cls, path):\n        return True\n\n    @property\n    def displayname(self):\n        if self.path.is_dir():\n            return self.path.name + '/'\n        return self.path.name\n\n    def displayable(self):\n        if self.parent is None:\n            return self.displayname\n\n        _filename_prefix = (self.display_filename_prefix_last\n                            if self.is_last\n                            else self.display_filename_prefix_middle)\n\n        parts = ['{!s} {!s}'.format(_filename_prefix,\n                                    self.displayname)]\n\n        parent = self.parent\n        while parent and parent.parent is not None:\n            parts.append(self.display_parent_prefix_middle\n                         if parent.is_last\n                         else self.display_parent_prefix_last)\n            parent = parent.parent\n\n        return ''.join(reversed(parts))\n    \ndef visualize_tree(dir_path: Path, level: int=-1, limit_to_directories: bool=False,\n         length_limit: int=1000):\n    \"\"\"Given a directory Path object print a visual tree structure\"\"\"\n    dir_path = Path(dir_path) # accept string coerceable to Path\n    files = 0\n    directories = 0\n    def inner(dir_path: Path, prefix: str='', level=-1):\n        nonlocal files, directories\n        if not level: \n            return # 0, stop iterating\n        if limit_to_directories:\n            contents = [d for d in dir_path.iterdir() if d.is_dir()]\n        else: \n            contents = list(dir_path.iterdir())\n        pointers = [tee] * (len(contents) - 1) + [last]\n        for pointer, path in zip(pointers, contents):\n            if path.is_dir():\n                yield prefix + pointer + path.name\n                directories += 1\n                extension = branch if pointer == tee else space \n                yield from inner(path, prefix=prefix+extension, level=level-1)\n            elif not limit_to_directories:\n                yield prefix + pointer + path.name\n                files += 1\n    outstring = \"\"\n    outstring += dir_path.name + \"\\n\"\n    iterator = inner(dir_path, level=level)\n    for line in islice(iterator, length_limit):\n        outstring += line + \"\\n\"\n    if next(iterator, None):\n        print(f'... length_limit, {length_limit}, reached, counted:')\n    outstring += f'\\n{directories} directories' + (f', {files} files' if files else '')\n    return outstring\n"}
{"type": "source_file", "path": "src/hyperagent/multilspy/lsp_protocol_handler/server.py", "content": "\"\"\"\nThis file provides the implementation of the JSON-RPC client, that launches and \ncommunicates with the language server.\n\nThe initial implementation of this file was obtained from \nhttps://github.com/predragnikolic/OLSP under the MIT License with the following terms:\n\nMIT License\n\nCopyright (c) 2023 Предраг Николић\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n\nimport asyncio\nimport dataclasses\nimport json\nimport os\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom .lsp_requests import LspNotification, LspRequest\nfrom .lsp_types import ErrorCodes\n\nStringDict = Dict[str, Any]\nPayloadLike = Union[List[StringDict], StringDict, None]\nCONTENT_LENGTH = \"Content-Length: \"\nENCODING = \"utf-8\"\n\n\n@dataclasses.dataclass\nclass ProcessLaunchInfo:\n    \"\"\"\n    This class is used to store the information required to launch a process.\n    \"\"\"\n\n    # The command to launch the process\n    cmd: str\n\n    # The environment variables to set for the process\n    env: Dict[str, str] = dataclasses.field(default_factory=dict)\n\n    # The working directory for the process\n    cwd: str = os.getcwd()\n\n\nclass Error(Exception):\n    def __init__(self, code: ErrorCodes, message: str) -> None:\n        super().__init__(message)\n        self.code = code\n\n    def to_lsp(self) -> StringDict:\n        return {\"code\": self.code, \"message\": super().__str__()}\n\n    @classmethod\n    def from_lsp(cls, d: StringDict) -> \"Error\":\n        return Error(d[\"code\"], d[\"message\"])\n\n    def __str__(self) -> str:\n        return f\"{super().__str__()} ({self.code})\"\n\n\ndef make_response(request_id: Any, params: PayloadLike) -> StringDict:\n    return {\"jsonrpc\": \"2.0\", \"id\": request_id, \"result\": params}\n\n\ndef make_error_response(request_id: Any, err: Error) -> StringDict:\n    return {\"jsonrpc\": \"2.0\", \"id\": request_id, \"error\": err.to_lsp()}\n\n\ndef make_notification(method: str, params: PayloadLike) -> StringDict:\n    return {\"jsonrpc\": \"2.0\", \"method\": method, \"params\": params}\n\n\ndef make_request(method: str, request_id: Any, params: PayloadLike) -> StringDict:\n    return {\"jsonrpc\": \"2.0\", \"method\": method, \"id\": request_id, \"params\": params}\n\n\nclass StopLoopException(Exception):\n    pass\n\n\ndef create_message(payload: PayloadLike):\n    body = json.dumps(payload, check_circular=False, ensure_ascii=False, separators=(\",\", \":\")).encode(ENCODING)\n    return (\n        f\"Content-Length: {len(body)}\\r\\n\".encode(ENCODING),\n        \"Content-Type: application/vscode-jsonrpc; charset=utf-8\\r\\n\\r\\n\".encode(ENCODING),\n        body,\n    )\n\n\nclass MessageType:\n    error = 1\n    warning = 2\n    info = 3\n    log = 4\n\n\nclass Request:\n    def __init__(self) -> None:\n        self.cv = asyncio.Condition()\n        self.result: Optional[PayloadLike] = None\n        self.error: Optional[Error] = None\n\n    async def on_result(self, params: PayloadLike) -> None:\n        self.result = params\n        async with self.cv:\n            self.cv.notify()\n\n    async def on_error(self, err: Error) -> None:\n        self.error = err\n        async with self.cv:\n            self.cv.notify()\n\n\ndef content_length(line: bytes) -> Optional[int]:\n    if line.startswith(b\"Content-Length: \"):\n        _, value = line.split(b\"Content-Length: \")\n        value = value.strip()\n        try:\n            return int(value)\n        except ValueError:\n            raise ValueError(\"Invalid Content-Length header: {}\".format(value))\n    return None\n\n\nclass LanguageServerHandler:\n    \"\"\"\n    This class provides the implementation of Python client for the Language Server Protocol.\n    A class that launches the language server and communicates with it\n    using the Language Server Protocol (LSP).\n\n    It provides methods for sending requests, responses, and notifications to the server\n    and for registering handlers for requests and notifications from the server.\n\n    Uses JSON-RPC 2.0 for communication with the server over stdin/stdout.\n\n    Attributes:\n        send: A LspRequest object that can be used to send requests to the server and\n            await for the responses.\n        notify: A LspNotification object that can be used to send notifications to the server.\n        cmd: A string that represents the command to launch the language server process.\n        process: A subprocess.Popen object that represents the language server process.\n        _received_shutdown: A boolean flag that indicates whether the client has received\n            a shutdown request from the server.\n        request_id: An integer that represents the next available request id for the client.\n        _response_handlers: A dictionary that maps request ids to Request objects that\n            store the results or errors of the requests.\n        on_request_handlers: A dictionary that maps method names to callback functions\n            that handle requests from the server.\n        on_notification_handlers: A dictionary that maps method names to callback functions\n            that handle notifications from the server.\n        logger: An optional function that takes two strings (source and destination) and\n            a payload dictionary, and logs the communication between the client and the server.\n        tasks: A dictionary that maps task ids to asyncio.Task objects that represent\n            the asynchronous tasks created by the handler.\n        task_counter: An integer that represents the next available task id for the handler.\n        loop: An asyncio.AbstractEventLoop object that represents the event loop used by the handler.\n    \"\"\"\n\n    def __init__(self, process_launch_info: ProcessLaunchInfo, logger=None) -> None:\n        \"\"\"\n        Params:\n            cmd: A string that represents the command to launch the language server process.\n            logger: An optional function that takes two strings (source and destination) and\n                a payload dictionary, and logs the communication between the client and the server.\n        \"\"\"\n        self.send = LspRequest(self.send_request)\n        self.notify = LspNotification(self.send_notification)\n\n        self.process_launch_info = process_launch_info\n        self.process = None\n        self._received_shutdown = False\n\n        self.request_id = 1\n        self._response_handlers: Dict[Any, Request] = {}\n        self.on_request_handlers = {}\n        self.on_notification_handlers = {}\n        self.logger = logger\n        self.tasks = {}\n        self.task_counter = 0\n        self.loop = None\n\n    async def start(self) -> None:\n        \"\"\"\n        Starts the language server process and creates a task to continuously read from its stdout to handle communications\n        from the server to the client\n        \"\"\"\n        child_proc_env = os.environ.copy()\n        child_proc_env.update(self.process_launch_info.env)\n        self.process = await asyncio.create_subprocess_shell(\n            self.process_launch_info.cmd,\n            stdout=asyncio.subprocess.PIPE,\n            stdin=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n            env=child_proc_env,\n            cwd=self.process_launch_info.cwd,\n        )\n\n        self.loop = asyncio.get_event_loop()\n        self.tasks[self.task_counter] = self.loop.create_task(self.run_forever())\n        self.task_counter += 1\n        self.tasks[self.task_counter] = self.loop.create_task(self.run_forever_stderr())\n        self.task_counter += 1\n\n    async def stop(self) -> None:\n        \"\"\"\n        Sends the terminate signal to the language server process and waits for it to exit, with a timeout, killing it if necessary\n        \"\"\"\n        for task in self.tasks.values():\n            task.cancel()\n\n        self.tasks = {}\n\n        process = self.process\n        self.process = None\n\n        if process:\n            # TODO: Ideally, we should terminate the process here,\n            # However, there's an issue with asyncio terminating processes documented at\n            # https://bugs.python.org/issue35539 and https://bugs.python.org/issue41320\n            # process.terminate()\n            wait_for_end = process.wait()\n            try:\n                await asyncio.wait_for(wait_for_end, timeout=60)\n            except asyncio.TimeoutError:\n                process.kill()\n\n    async def shutdown(self) -> None:\n        \"\"\"\n        Perform the shutdown sequence for the client, including sending the shutdown request to the server and notifying it of exit\n        \"\"\"\n        await self.send.shutdown()\n        self._received_shutdown = True\n        self.notify.exit()\n        if self.process and self.process.stdout:\n            self.process.stdout.set_exception(StopLoopException())\n            # This yields the control to the event loop to allow the exception to be handled\n            # in the run_forever and run_forever_stderr methods\n            await asyncio.sleep(0)\n\n    def _log(self, message: str) -> None:\n        \"\"\"\n        Create a log message\n        \"\"\"\n        if self.logger:\n            self.logger(\"client\", \"logger\", message)\n\n    async def run_forever(self) -> bool:\n        \"\"\"\n        Continuously read from the language server process stdout and handle the messages\n        invoking the registered response and notification handlers\n        \"\"\"\n        try:\n            while self.process and self.process.stdout and not self.process.stdout.at_eof():\n                line = await self.process.stdout.readline()\n                if not line:\n                    continue\n                try:\n                    num_bytes = content_length(line)\n                except ValueError:\n                    continue\n                if num_bytes is None:\n                    continue\n                while line and line.strip():\n                    line = await self.process.stdout.readline()\n                if not line:\n                    continue\n                body = await self.process.stdout.readexactly(num_bytes)\n\n                self.tasks[self.task_counter] = asyncio.get_event_loop().create_task(self._handle_body(body))\n                self.task_counter += 1\n        except (BrokenPipeError, ConnectionResetError, StopLoopException):\n            pass\n        return self._received_shutdown\n\n    async def run_forever_stderr(self) -> None:\n        \"\"\"\n        Continuously read from the language server process stderr and log the messages\n        \"\"\"\n        try:\n            while self.process and self.process.stderr and not self.process.stderr.at_eof():\n                line = await self.process.stderr.readline()\n                if not line:\n                    continue\n                self._log(\"LSP stderr: \" + line.decode(ENCODING))\n        except (BrokenPipeError, ConnectionResetError, StopLoopException):\n            pass\n\n    async def _handle_body(self, body: bytes) -> None:\n        \"\"\"\n        Parse the body text received from the language server process and invoke the appropriate handler\n        \"\"\"\n        try:\n            await self._receive_payload(json.loads(body))\n        except IOError as ex:\n            self._log(f\"malformed {ENCODING}: {ex}\")\n        except UnicodeDecodeError as ex:\n            self._log(f\"malformed {ENCODING}: {ex}\")\n        except json.JSONDecodeError as ex:\n            self._log(f\"malformed JSON: {ex}\")\n\n    async def _receive_payload(self, payload: StringDict) -> None:\n        \"\"\"\n        Determine if the payload received from server is for a request, response, or notification and invoke the appropriate handler\n        \"\"\"\n        if self.logger:\n            self.logger(\"server\", \"client\", payload)\n        try:\n            if \"method\" in payload:\n                if \"id\" in payload:\n                    await self._request_handler(payload)\n                else:\n                    await self._notification_handler(payload)\n            elif \"id\" in payload:\n                await self._response_handler(payload)\n            else:\n                self._log(f\"Unknown payload type: {payload}\")\n        except Exception as err:\n            self._log(f\"Error handling server payload: {err}\")\n\n    def send_notification(self, method: str, params: Optional[dict] = None) -> None:\n        \"\"\"\n        Send notification pertaining to the given method to the server with the given parameters\n        \"\"\"\n        self._send_payload_sync(make_notification(method, params))\n\n    def send_response(self, request_id: Any, params: PayloadLike) -> None:\n        \"\"\"\n        Send response to the given request id to the server with the given parameters\n        \"\"\"\n        self.tasks[self.task_counter] = asyncio.get_event_loop().create_task(\n            self._send_payload(make_response(request_id, params))\n        )\n        self.task_counter += 1\n\n    def send_error_response(self, request_id: Any, err: Error) -> None:\n        \"\"\"\n        Send error response to the given request id to the server with the given error\n        \"\"\"\n        self.tasks[self.task_counter] = asyncio.get_event_loop().create_task(\n            self._send_payload(make_error_response(request_id, err))\n        )\n        self.task_counter += 1\n\n    async def send_request(self, method: str, params: Optional[dict] = None) -> None:\n        \"\"\"\n        Send request to the server, register the request id, and wait for the response\n        \"\"\"\n        request = Request()\n        request_id = self.request_id\n        self.request_id += 1\n        self._response_handlers[request_id] = request\n        async with request.cv:\n            await self._send_payload(make_request(method, request_id, params))\n            await request.cv.wait()\n        if isinstance(request.error, Error):\n            raise request.error\n        return request.result\n\n    def _send_payload_sync(self, payload: StringDict) -> None:\n        \"\"\"\n        Send the payload to the server by writing to its stdin synchronously\n        \"\"\"\n        if not self.process or not self.process.stdin:\n            return\n        msg = create_message(payload)\n        if self.logger:\n            self.logger(\"client\", \"server\", payload)\n        self.process.stdin.writelines(msg)\n\n    async def _send_payload(self, payload: StringDict) -> None:\n        \"\"\"\n        Send the payload to the server by writing to its stdin asynchronously.\n        \"\"\"\n        if not self.process or not self.process.stdin:\n            return\n        msg = create_message(payload)\n        if self.logger:\n            self.logger(\"client\", \"server\", payload)\n        self.process.stdin.writelines(msg)\n        await self.process.stdin.drain()\n\n    def on_request(self, method: str, cb) -> None:\n        \"\"\"\n        Register the callback function to handle requests from the server to the client for the given method\n        \"\"\"\n        self.on_request_handlers[method] = cb\n\n    def on_notification(self, method: str, cb) -> None:\n        \"\"\"\n        Register the callback function to handle notifications from the server to the client for the given method\n        \"\"\"\n        self.on_notification_handlers[method] = cb\n\n    async def _response_handler(self, response: StringDict) -> None:\n        \"\"\"\n        Handle the response received from the server for a request, using the id to determine the request\n        \"\"\"\n        request = self._response_handlers.pop(response[\"id\"])\n        if \"result\" in response and \"error\" not in response:\n            await request.on_result(response[\"result\"])\n        elif \"result\" not in response and \"error\" in response:\n            await request.on_error(Error.from_lsp(response[\"error\"]))\n        else:\n            await request.on_error(Error(ErrorCodes.InvalidRequest, \"\"))\n\n    async def _request_handler(self, response: StringDict) -> None:\n        \"\"\"\n        Handle the request received from the server: call the appropriate callback function and return the result\n        \"\"\"\n        method = response.get(\"method\", \"\")\n        params = response.get(\"params\")\n        request_id = response.get(\"id\")\n        handler = self.on_request_handlers.get(method)\n        if not handler:\n            self.send_error_response(\n                request_id,\n                Error(\n                    ErrorCodes.MethodNotFound,\n                    \"method '{}' not handled on client.\".format(method),\n                ),\n            )\n            return\n        try:\n            self.send_response(request_id, await handler(params))\n        except Error as ex:\n            self.send_error_response(request_id, ex)\n        except Exception as ex:\n            self.send_error_response(request_id, Error(ErrorCodes.InternalError, str(ex)))\n\n    async def _notification_handler(self, response: StringDict) -> None:\n        \"\"\"\n        Handle the notification received from the server: call the appropriate callback function\n        \"\"\"\n        method = response.get(\"method\", \"\")\n        params = response.get(\"params\")\n        handler = self.on_notification_handlers.get(method)\n        if not handler:\n            self._log(f\"unhandled {method}\")\n            return\n        try:\n            await handler(params)\n        except asyncio.CancelledError:\n            return\n        except Exception as ex:\n            if (not self._received_shutdown) and self.logger:\n                self.logger(\n                    \"client\",\n                    \"logger\",\n                    str(\n                        {\n                            \"type\": MessageType.error,\n                            \"message\": str(ex),\n                            \"method\": method,\n                            \"params\": params,\n                        }\n                    ),\n                )\n"}
{"type": "source_file", "path": "src/hyperagent/multilspy/language_servers/rust_analyzer/rust_analyzer.py", "content": "\"\"\"\nProvides Rust specific instantiation of the LanguageServer class. Contains various configurations and settings specific to Rust.\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport os\nimport stat\nimport pathlib\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncIterator\n\nfrom hyperagent.multilspy.multilspy_logger import MultilspyLogger\nfrom hyperagent.multilspy.language_server import LanguageServer\nfrom hyperagent.multilspy.lsp_protocol_handler.server import ProcessLaunchInfo\nfrom hyperagent.multilspy.lsp_protocol_handler.lsp_types import InitializeParams\nfrom hyperagent.multilspy.multilspy_config import MultilspyConfig\nfrom hyperagent.multilspy.multilspy_utils import FileUtils\nfrom hyperagent.multilspy.multilspy_utils import PlatformUtils\n\n\nclass RustAnalyzer(LanguageServer):\n    \"\"\"\n    Provides Rust specific instantiation of the LanguageServer class. Contains various configurations and settings specific to Rust.\n    \"\"\"\n\n    def __init__(self, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str):\n        \"\"\"\n        Creates a RustAnalyzer instance. This class is not meant to be instantiated directly. Use LanguageServer.create() instead.\n        \"\"\"\n        rustanalyzer_executable_path = self.setup_runtime_dependencies(logger, config)\n        super().__init__(\n            config,\n            logger,\n            repository_root_path,\n            ProcessLaunchInfo(cmd=rustanalyzer_executable_path, cwd=repository_root_path),\n            \"rust\",\n        )\n        self.server_ready = asyncio.Event()\n\n    def setup_runtime_dependencies(self, logger: MultilspyLogger, config: MultilspyConfig) -> str:\n        \"\"\"\n        Setup runtime dependencies for OmniSharp.\n        \"\"\"\n        platform_id = PlatformUtils.get_platform_id()\n\n        with open(os.path.join(os.path.dirname(__file__), \"runtime_dependencies.json\"), \"r\") as f:\n            d = json.load(f)\n            del d[\"_description\"]\n\n        assert platform_id.value in [\n            \"linux-x64\",\n            \"win-x64\",\n        ], \"Only linux-x64 platform is supported for in multilspy at the moment\"\n\n        runtime_dependencies = d[\"runtimeDependencies\"]\n        runtime_dependencies = [\n            dependency for dependency in runtime_dependencies if dependency[\"platformId\"] == platform_id.value\n        ]\n        assert len(runtime_dependencies) == 1\n        dependency = runtime_dependencies[0]\n\n        rustanalyzer_ls_dir = os.path.join(os.path.dirname(__file__), \"static\", \"RustAnalyzer\")\n        rustanalyzer_executable_path = os.path.join(rustanalyzer_ls_dir, dependency[\"binaryName\"])\n        if not os.path.exists(rustanalyzer_ls_dir):\n            os.makedirs(rustanalyzer_ls_dir)\n            if dependency[\"archiveType\"] == \"gz\":\n                FileUtils.download_and_extract_archive(\n                    logger, dependency[\"url\"], rustanalyzer_executable_path, dependency[\"archiveType\"]\n                )\n            else:\n                FileUtils.download_and_extract_archive(\n                    logger, dependency[\"url\"], rustanalyzer_ls_dir, dependency[\"archiveType\"]\n                )\n        assert os.path.exists(rustanalyzer_executable_path)\n        os.chmod(rustanalyzer_executable_path, stat.S_IEXEC)\n\n        return rustanalyzer_executable_path\n\n    def _get_initialize_params(self, repository_absolute_path: str) -> InitializeParams:\n        \"\"\"\n        Returns the initialize params for the Rust Analyzer Language Server.\n        \"\"\"\n        with open(os.path.join(os.path.dirname(__file__), \"initialize_params.json\"), \"r\") as f:\n            d = json.load(f)\n\n        del d[\"_description\"]\n\n        d[\"processId\"] = os.getpid()\n        assert d[\"rootPath\"] == \"$rootPath\"\n        d[\"rootPath\"] = repository_absolute_path\n\n        assert d[\"rootUri\"] == \"$rootUri\"\n        d[\"rootUri\"] = pathlib.Path(repository_absolute_path).as_uri()\n\n        assert d[\"workspaceFolders\"][0][\"uri\"] == \"$uri\"\n        d[\"workspaceFolders\"][0][\"uri\"] = pathlib.Path(repository_absolute_path).as_uri()\n\n        assert d[\"workspaceFolders\"][0][\"name\"] == \"$name\"\n        d[\"workspaceFolders\"][0][\"name\"] = os.path.basename(repository_absolute_path)\n\n        return d\n\n    @asynccontextmanager\n    async def start_server(self) -> AsyncIterator[\"RustAnalyzer\"]:\n        \"\"\"\n        Starts the Rust Analyzer Language Server, waits for the server to be ready and yields the LanguageServer instance.\n\n        Usage:\n        ```\n        async with lsp.start_server():\n            # LanguageServer has been initialized and ready to serve requests\n            await lsp.request_definition(...)\n            await lsp.request_references(...)\n            # Shutdown the LanguageServer on exit from scope\n        # LanguageServer has been shutdown\n        \"\"\"\n\n        async def register_capability_handler(params):\n            assert \"registrations\" in params\n            for registration in params[\"registrations\"]:\n                if registration[\"method\"] == \"workspace/executeCommand\":\n                    self.initialize_searcher_command_available.set()\n                    self.resolve_main_method_available.set()\n            return\n\n        async def lang_status_handler(params):\n            # TODO: Should we wait for\n            # server -> client: {'jsonrpc': '2.0', 'method': 'language/status', 'params': {'type': 'ProjectStatus', 'message': 'OK'}}\n            # Before proceeding?\n            if params[\"type\"] == \"ServiceReady\" and params[\"message\"] == \"ServiceReady\":\n                self.service_ready_event.set()\n\n        async def execute_client_command_handler(params):\n            return []\n\n        async def do_nothing(params):\n            return\n\n        async def check_experimental_status(params):\n            if params[\"quiescent\"] == True:\n                self.server_ready.set()\n\n        async def window_log_message(msg):\n            self.logger.log(f\"LSP: window/logMessage: {msg}\", logging.INFO)\n\n        self.server.on_request(\"client/registerCapability\", register_capability_handler)\n        self.server.on_notification(\"language/status\", lang_status_handler)\n        self.server.on_notification(\"window/logMessage\", window_log_message)\n        self.server.on_request(\"workspace/executeClientCommand\", execute_client_command_handler)\n        self.server.on_notification(\"$/progress\", do_nothing)\n        self.server.on_notification(\"textDocument/publishDiagnostics\", do_nothing)\n        self.server.on_notification(\"language/actionableNotification\", do_nothing)\n        self.server.on_notification(\"experimental/serverStatus\", check_experimental_status)\n\n        async with super().start_server():\n            self.logger.log(\"Starting RustAnalyzer server process\", logging.INFO)\n            await self.server.start()\n            initialize_params = self._get_initialize_params(self.repository_root_path)\n\n            self.logger.log(\n                \"Sending initialize request from LSP client to LSP server and awaiting response\",\n                logging.INFO,\n            )\n            init_response = await self.server.send.initialize(initialize_params)\n            assert init_response[\"capabilities\"][\"textDocumentSync\"][\"change\"] == 2\n            assert \"completionProvider\" in init_response[\"capabilities\"]\n            assert init_response[\"capabilities\"][\"completionProvider\"] == {\n                \"resolveProvider\": True,\n                \"triggerCharacters\": [\":\", \".\", \"'\", \"(\"],\n                \"completionItem\": {\"labelDetailsSupport\": True},\n            }\n            self.server.notify.initialized({})\n            self.completions_available.set()\n\n            await self.server_ready.wait()\n\n            yield self\n\n            await self.server.shutdown()\n            await self.server.stop()\n"}
{"type": "source_file", "path": "src/hyperagent/langchain_parsers/parsers.py", "content": "from typing import Any, Dict, Iterator, Optional\n\nfrom langchain.docstore.document import Document\nfrom langchain.document_loaders.base import BaseBlobParser\nfrom langchain.document_loaders.blob_loaders import Blob\nfrom hyperagent.langchain_parsers.language.csharp import CSharpSegmenter\nfrom hyperagent.langchain_parsers.language.java import JavaSegmenter\nfrom hyperagent.langchain_parsers.language.python import PythonSegmenter\nfrom hyperagent.langchain_parsers.language.rust import RustSegmenter\nfrom langchain.text_splitter import Language\n\nLANGUAGE_EXTENSIONS: Dict[str, str] = {\n    \"py\": Language.PYTHON,\n    \"cs\": Language.CSHARP,\n    \"rs\": Language.RUST,\n    \"java\": Language.JAVA,\n}\n\nLANGUAGE_SEGMENTERS: Dict[str, Any] = {\n    Language.PYTHON: PythonSegmenter,\n    Language.CSHARP: CSharpSegmenter,\n    Language.RUST: RustSegmenter,\n    Language.JAVA: JavaSegmenter,\n}\n\n\nclass LanguageParser(BaseBlobParser):\n    \"\"\"Parse using the respective programming language syntax.\n\n    Each top-level function and class in the code is loaded into separate documents.\n    Furthermore, an extra document is generated, containing the remaining top-level code\n    that excludes the already segmented functions and classes.\n\n    This approach can potentially improve the accuracy of QA models over source code.\n\n    The supported languages for code parsing are:\n\n    - C# (*)\n    - Java (*)\n    - Python\n    - Rust (*)\n\n    Items marked with (*) require the packages `tree_sitter` and\n    `tree_sitter_languages`. It is straightforward to add support for additional\n    languages using `tree_sitter`, although this currently requires modifying LangChain.\n\n    The language used for parsing can be configured, along with the minimum number of\n    lines required to activate the splitting based on syntax.\n\n    If a language is not explicitly specified, `LanguageParser` will infer one from\n    filename extensions, if present.\n\n    Examples:\n\n       .. code-block:: python\n\n            from langchain.text_splitter.Language\n            from langchain.document_loaders.generic import GenericLoader\n            from langchain.document_loaders.parsers import LanguageParser\n\n            loader = GenericLoader.from_filesystem(\n                \"./code\",\n                glob=\"**/*\",\n                suffixes=[\".py\", \".js\"],\n                parser=LanguageParser()\n            )\n            docs = loader.load()\n\n        Example instantiations to manually select the language:\n\n        .. code-block:: python\n\n            from langchain.text_splitter import Language\n\n            loader = GenericLoader.from_filesystem(\n                \"./code\",\n                glob=\"**/*\",\n                suffixes=[\".py\"],\n                parser=LanguageParser(language=Language.PYTHON)\n            )\n\n        Example instantiations to set number of lines threshold:\n\n        .. code-block:: python\n\n            loader = GenericLoader.from_filesystem(\n                \"./code\",\n                glob=\"**/*\",\n                suffixes=[\".py\"],\n                parser=LanguageParser(parser_threshold=200)\n            )\n    \"\"\"\n\n    def __init__(self, language: Optional[Language] = None, parser_threshold: int = 0):\n        \"\"\"\n        Language parser that split code using the respective language syntax.\n\n        Args:\n            language: If None (default), it will try to infer language from source.\n            parser_threshold: Minimum lines needed to activate parsing (0 by default).\n        \"\"\"\n        self.language = language\n        self.parser_threshold = parser_threshold\n\n    def lazy_parse(self, blob: Blob) -> Iterator[Document]:\n        code = blob.as_string()\n\n        language = self.language or (\n            LANGUAGE_EXTENSIONS.get(blob.source.rsplit(\".\", 1)[-1])\n            if isinstance(blob.source, str)\n            else None\n        )\n\n        if language is None:\n            yield Document(\n                page_content=code,\n                metadata={\n                    \"source\": blob.source,\n                },\n            )\n            return\n\n        if self.parser_threshold >= len(code.splitlines()):\n            yield Document(\n                page_content=code,\n                metadata={\n                    \"source\": blob.source,\n                    \"language\": language,\n                },\n            )\n            return\n\n        self.Segmenter = LANGUAGE_SEGMENTERS[language]\n        segmenter = self.Segmenter(blob.as_string())\n        if not segmenter.is_valid():\n            yield Document(\n                page_content=code,\n                metadata={\n                    \"source\": blob.source,\n                },\n            )\n            return\n\n        for functions_classes in segmenter.extract_functions_classes():\n            yield Document(\n                page_content=functions_classes,\n                metadata={\n                    \"source\": blob.source,\n                    \"content_type\": \"functions_classes\",\n                    \"language\": language,\n                },\n            )\n        yield Document(\n            page_content=segmenter.simplify_code(),\n            metadata={\n                \"source\": blob.source,\n                \"content_type\": \"simplified_code\",\n                \"language\": language,\n            },\n        )"}
{"type": "source_file", "path": "src/hyperagent/multilspy/multilspy_settings.py", "content": "\"\"\"\nDefines the settings for multilspy.\n\"\"\"\n\nimport os\nimport pathlib\n\nclass MultilspySettings:\n    \"\"\"\n    Provides the various settings for multilspy.\n    \"\"\"\n    @staticmethod\n    def get_language_server_directory() -> str:\n        \"\"\"Returns the directory for language servers\"\"\"\n        user_home = pathlib.Path.home()\n        multilspy_dir = str(pathlib.PurePath(user_home, \".multilspy\"))\n        lsp_dir = str(pathlib.PurePath(multilspy_dir, \"lsp\"))\n        os.makedirs(lsp_dir, exist_ok=True)\n        return lsp_dir\n\n    @staticmethod\n    def get_global_cache_directory() -> str:\n        \"\"\"Returns the cache directory\"\"\"\n        global_cache_dir = os.path.join(str(pathlib.Path.home()), \".multilspy\", \"global_cache\")\n        os.makedirs(global_cache_dir, exist_ok=True)\n        return global_cache_dir\n"}
{"type": "source_file", "path": "src/hyperagent/cli/console.py", "content": "import os\n\nfrom prompt_toolkit import prompt\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.history import FileHistory\nfrom prompt_toolkit.styles import Style\nfrom prompt_toolkit.completion.filesystem import PathCompleter\nfrom rich.console import Console as RawConsole\nfrom rich.markdown import Markdown\n\n\nclass Console:\n    def __init__(self, history_dir=\".history\"):\n        os.makedirs(history_dir, exist_ok=True)\n        self.prompt_history = FileHistory(os.path.join(history_dir, \"question\"))\n        self.prompt_file_history = FileHistory(os.path.join(history_dir, \"file\"))\n        self.prompt_auto_suggest = AutoSuggestFromHistory()\n        self.prompt_style = Style.from_dict({\"prompt\": \"#7fff00 bold\", \"\": \"#ADD8E6\"})\n        self._console = RawConsole()\n\n    def print(self, text, render=True):\n        if render:\n            self._console.print(Markdown(text))\n        else:\n            self._console.print(text)\n\n    def info(self, text):\n        self._console.print(f\"[blue]{text}[/blue]\")\n    \n    def info2(self, text):\n        self._console.print(f\"[cyan]{text}[/cyan]\")\n\n    def warning(self, text):\n        self._console.print(f\"[yellow]{text}[/yellow]\")\n\n    def error(self, text):\n        self._console.print(f\"[red]{text}[/red]\")\n\n    def bot_prompt(self):\n        self._console.print(f\"\\n[green][bold]Bot: [/bold][/green]\")\n\n    def print_history_item(self, idx, entry):\n        summary = entry[:self._console.width - 20]\n        self._console.print(f\"[bold]{idx:>4}: [/bold] {summary}...\")\n\n    def file_prompt(self):\n        return prompt(\n            \"File: \",\n            history=self.prompt_file_history,\n            completer=PathCompleter(),\n            auto_suggest=self.prompt_auto_suggest,\n            style=self.prompt_style,\n        )\n\n    def user_prompt(self, long=False):\n        if long:\n            return prompt(\n                \"> \",\n                multiline=True,\n                history=self.prompt_history,\n                auto_suggest=self.prompt_auto_suggest,\n                style=self.prompt_style,\n                prompt_continuation=\"> \",\n            )\n        else:\n            return prompt(\n                \"You: \",\n                history=self.prompt_history,\n                auto_suggest=self.prompt_auto_suggest,\n                style=self.prompt_style,\n            )\n\n    def prompt(self, text, is_password=False):\n        return prompt(\n            text,\n            is_password=is_password,\n            history=self.prompt_history if not is_password else None,\n            auto_suggest=self.prompt_auto_suggest,\n            style=self.prompt_style,\n        )\n\n    def gap(self):\n        self._console.print(\"\")"}
{"type": "source_file", "path": "src/hyperagent/cli/cli.py", "content": "from typer import Typer, Argument, Option\nfrom typing import Optional\nfrom typing_extensions import Annotated\nimport subprocess\nfrom appdirs import user_config_dir\nimport logging\nimport os\nimport threading\nfrom pathlib import Path\nfrom hyperagent.cli.console import Console\nfrom langchain_community.llms.vllm import VLLMOpenAI\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain_community.vectorstores import Chroma\nfrom hyperagent.prompts import analyzer as analyzer_prompt\nfrom hyperagent.prompts import navigator as navigator_prompt\nfrom hyperagent.agents.plan_seeking import load_agent_navigator, load_agent_analyzer, PlanSeeking\nfrom hyperagent.agents.adaptive_plan_seeking import AdaptivePlanSeeking\nfrom hyperagent.agents.planner import load_chat_planner\nfrom hyperagent.utils import clone_repo, check_local_or_remote\nfrom hyperagent.tools.tools import tool_classes, SemanticCodeSearchTool, CodeSearchTool\nfrom hyperagent.prompts.general_qa import example_qa\nfrom hyperagent.constants import DEFAULT_CLONE_DIR, SEMANTIC_CODE_SEARCH_DB_PATH, DEFAULT_DEVICES, DEFAULT_LOCAL_AGENT, DEFAULT_GH_TOKEN, DEFAULT_WORKDIR_CLI, ZOEKT_CODE_SEARCH_INDEX_PATH, DEFAULT_PLANNER_TYPE, DEFAULT_VLLM_PORT, DEFAULT_LANGUAGE\nfrom hyperagent.utils import save_infos_to_folder\nimport re\nimport json\n\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nlogging.getLogger(\"httpx\").setLevel(logging.CRITICAL)\n\nlogging.getLogger('multilspy').setLevel(logging.CRITICAL)\nlogger = logging.getLogger(__name__)\n\napp = Typer(add_completion=False)\nsetup_app = Typer()\nquery_app = Typer()\nlist_app = Typer()\nconfig_app = Typer(add_completion=False, no_args_is_help=True)\nconfig_dir = Path(user_config_dir(\"hyperagent\"))\nconsole = Console(history_dir=config_dir / \"history\")\n\ndef read_key(console: Console):\n    openai_api_key = os.environ.get(\"OPENAI_API_KEY\", None)\n    if openai_api_key is None:\n        console.info(\"Please provide an OpenAI API key.\")\n        openai_api_key = console.prompt(\n            \"Please key in a valid OpenAI Key: \",\n            is_password=True,\n        )\n    return openai_api_key\n\n@setup_app.callback(invoke_without_command=True)\ndef setup(\n    repo_path: Annotated[str, Argument(..., help=\"The path to the repository to set up.\")],\n    repository_name: Annotated[str, Option(\"--repository-name\", help=\"The name of the repository.\", prompt=True)],\n    language: Annotated[Optional[str], Option(help=\"The programming language of the repository.\", prompt=True)],\n    commit: Annotated[str, Option(\"--commit\", help=\"The commit to set up.\")] = \"\", \n    local_agent: Annotated[Optional[str], Option(\"--local-agent\", help=\"local agent path\")]=DEFAULT_LOCAL_AGENT,\n    devices: Annotated[Optional[str], Option(\"--devices\", help=\"devices to use for inference\")]=DEFAULT_DEVICES,\n    clone_dir: Annotated[Optional[str], Option(\"--clone-dir\", help=\"The directory to clone the repository to.\")]=DEFAULT_CLONE_DIR,\n    gh_token: Annotated[Optional[str], Option(\"--gh-token\", help=\"The GitHub token to use for cloning private repositories.\")]=DEFAULT_GH_TOKEN,\n):  \n    console.info(\"Setting up repo...\")\n    is_local, repo_path = check_local_or_remote(repo_path)\n    repo_dir = clone_repo(repo_path, commit, clone_dir, gh_token, logger) if not is_local else repo_path\n    repo_dir = os.path.join(os.getcwd(), repo_dir)\n    console.info(\"Setting up LLM...\")\n    if local_agent != \"None\":\n        def run_cmd():\n            with open(os.devnull, 'w') as devnull:\n                env = os.environ.copy()\n                env[\"CUDA_VISIBLE_DEVICES\"] = devices\n                subprocess.run([\"python\", \"-m\", \n                                \"vllm.entrypoints.openai.api_server\", \n                                \"--model\", str(DEFAULT_LOCAL_AGENT), \n                                \"--trust-remote-code\", \n                                \"--tensor-parallel-size\", str(len(devices.split(\",\"))), \n                                \"--port\", str(DEFAULT_VLLM_PORT)],\n                            stdout=devnull, stderr=devnull, env=env)\n        thread = threading.Thread(target=run_cmd)\n        thread.daemon = True\n        thread.start()\n\n    console.info(\"Setting up tools...\")\n    tools = []\n    for tool_class in tool_classes:\n        if tool_class == SemanticCodeSearchTool:\n            tools.append(tool_class(repo_dir, language=language, db_path=SEMANTIC_CODE_SEARCH_DB_PATH+repository_name, build=True))\n        elif tool_class == CodeSearchTool:\n            tools.append(tool_class(repo_dir, language=language, index_path=ZOEKT_CODE_SEARCH_INDEX_PATH+repository_name, build=True))\n\n    necessary_infos = {\n        \"repo_dir\": repo_dir,\n        \"local_agent\": local_agent,\n        \"language\": language,\n    }\n    save_infos_to_folder(necessary_infos, repository_name, DEFAULT_WORKDIR_CLI)\n    console.info(\"Your repository is indexed!\")\n\n@list_app.callback(invoke_without_command=True)\ndef list():\n    console.info(\"Listing repos...\")\n    for file in os.listdir(DEFAULT_WORKDIR_CLI):\n        if file.endswith(\".json\"):\n            console.info2(file[:-5])\n\n@query_app.callback(invoke_without_command=True)\ndef query(\n    repository_name: Annotated[str, Argument(..., help=\"The name of the repository to query.\")],\n    planner_type: Annotated[str, Option(\"--planner-type\", help=\"The type of planner to use.\")]=DEFAULT_PLANNER_TYPE,\n    save_trajectories_path: Annotated[Optional[str], Option(\"--save-trajectories-path\", help=\"The path to save the trajectories to.\")]=None,\n    type_agent: Annotated[Optional[str], Option(\"--type-agent\", help=\"The type of agent to use.\")]=\"gpt-4\",\n    verbose: Annotated[Optional[int], Option(\"--verbose\", help=\"Verbose level\")]=1,\n):  \n    tools = []\n    openai_api_key = read_key(console)\n    console.info(\"querying repo...\")\n    with open(os.path.join(DEFAULT_WORKDIR_CLI, repository_name+\".json\")) as f:\n        necessary_infos = json.load(f)\n    \n    for tool_class in tool_classes:\n        if tool_class == SemanticCodeSearchTool:\n            tools.append(tool_class(necessary_infos[\"repo_dir\"], language=necessary_infos[\"language\"], db_path=SEMANTIC_CODE_SEARCH_DB_PATH+repository_name, build=False))\n        elif tool_class == CodeSearchTool:\n            tools.append(tool_class(necessary_infos[\"repo_dir\"], language=necessary_infos[\"language\"], index_path=ZOEKT_CODE_SEARCH_INDEX_PATH+repository_name, build=False))\n        else:\n            tools.append(tool_class(necessary_infos[\"repo_dir\"], language=necessary_infos[\"language\"]))\n    \n    tool_strings = [f\"{tool.name}: {tool.description}, args: {re.sub('}', '}}}}', re.sub('{', '{{{{', str(tool.args)))}\" for tool in tools]\n    formatted_tools = \"\\n\".join(tool_strings)\n\n    struct = subprocess.check_output([\"tree\", \"-L\",\"2\", \"-d\", necessary_infos[\"repo_dir\"]]).decode(\"utf-8\")\n    if type_agent == \"local\":\n        llm = VLLMOpenAI(\n            openai_api_key=\"EMPTY\",\n            openai_api_base=f\"http://localhost:{DEFAULT_VLLM_PORT}/v1\",\n            model_name=necessary_infos[\"local_agent\"],\n            max_tokens=3000,\n            top_p=0.95,\n            temperature=0.1,\n        )\n    else:\n        llm = ChatOpenAI(temperature=0, model=\"gpt-4-1106-preview\", openai_api_key=openai_api_key)\n        \n    planner_input = {\n        \"examples\": example_qa,\n        \"formatted_tools\": formatted_tools,\n        \"struct\": struct,\n    }\n    llm_plan = ChatOpenAI(temperature=0, model=\"gpt-4\", openai_api_key=openai_api_key)\n    llm_analyzer = ChatOpenAI(temperature=0, model=\"gpt-4-1106-preview\")\n    planner = load_chat_planner(\n        llm=llm_plan,\n        **planner_input\n    )\n\n    # Set up the vectorstore for analyzer's memory\n    vectorstore = Chroma(\"langchain_store\", OpenAIEmbeddings(disallowed_special=()))\n\n    # Set up the executor and planner agent (the system)\n    navigator = load_agent_navigator(\n        llm,\n        tools,\n        navigator_prompt.PREFIX,\n        navigator_prompt.SUFFIX,\n        verbose=verbose,\n        include_task_in_prompt=False,\n        save_trajectories_path=save_trajectories_path\n    )\n    analyzer = load_agent_analyzer(\n        llm_analyzer,\n        analyzer_prompt.PREFIX,\n        analyzer_prompt.SUFFIX,\n        vectorstore,\n        verbose=True\n    )\n\n    # seeking_algorithm = PlanSeeking\n    seeking_algorithm = AdaptivePlanSeeking if planner_type == \"adaptive\" else PlanSeeking\n    system = seeking_algorithm(\n        planner=planner,\n        navigator=navigator,\n        analyzer=analyzer,\n        vectorstore=vectorstore,\n        verbose=verbose\n    )\n    while True:\n        query = console.prompt(\"Your query: \")\n        if query == \"exit\":\n            break\n        console.gap()\n        response = system(query)\n        response = response[\"output\"].response\n        console.info(response)\n    \napp.add_typer(setup_app, name=\"setup\")\napp.add_typer(query_app, name=\"query\")\napp.add_typer(list_app, name=\"list\")"}
{"type": "source_file", "path": "src/hyperagent/multilspy/multilspy_utils.py", "content": "\"\"\"\nThis file contains various utility functions like I/O operations, handling paths, etc.\n\"\"\"\n\nimport gzip\nimport logging\nimport os\nfrom typing import Tuple\nimport requests\nimport shutil\nimport uuid\n\nimport platform\nimport subprocess\nfrom enum import Enum\n\nfrom hyperagent.multilspy.multilspy_exceptions import MultilspyException\nfrom pathlib import PurePath, Path\nfrom hyperagent.multilspy.multilspy_logger import MultilspyLogger\n\nclass TextUtils:\n    \"\"\"\n    Utilities for text operations.\n    \"\"\"\n    @staticmethod\n    def get_line_col_from_index(text: str, index: int) -> Tuple[int, int]:\n        \"\"\"\n        Returns the zero-indexed line and column number of the given index in the given text\n        \"\"\"\n        l = 0\n        c = 0\n        idx = 0\n        while idx < index:\n            if text[idx] == '\\n':\n                l += 1\n                c = 0\n            else:\n                c += 1\n            idx += 1\n\n        return l, c\n    \n    @staticmethod\n    def get_index_from_line_col(text: str, line: int, col: int) -> int:\n        \"\"\"\n        Returns the index of the given zero-indexed line and column number in the given text\n        \"\"\"\n        idx = 0\n        while line > 0:\n            assert idx < len(text), (idx, len(text), text)\n            if text[idx] == \"\\n\":\n                line -= 1\n            idx += 1\n        idx += col\n        return idx\n    \n    @staticmethod\n    def get_updated_position_from_line_and_column_and_edit(l: int, c: int, text_to_be_inserted: str) -> Tuple[int, int]:\n        \"\"\"\n        Utility function to get the position of the cursor after inserting text at a given line and column.\n        \"\"\"\n        num_newlines_in_gen_text = text_to_be_inserted.count('\\n')\n        if num_newlines_in_gen_text > 0:\n            l += num_newlines_in_gen_text\n            c = len(text_to_be_inserted.split('\\n')[-1])\n        else:\n            c += len(text_to_be_inserted)\n        return (l, c)\n\nclass PathUtils:\n    \"\"\"\n    Utilities for platform-agnostic path operations.\n    \"\"\"\n    @staticmethod\n    def uri_to_path(uri: str) -> str:\n        \"\"\"\n        Converts a URI to a file path. Works on both Linux and Windows.\n\n        This method was obtained from https://stackoverflow.com/a/61922504\n        \"\"\"\n        from urllib.parse import urlparse, unquote\n        from urllib.request import url2pathname\n        parsed = urlparse(uri)\n        host = \"{0}{0}{mnt}{0}\".format(os.path.sep, mnt=parsed.netloc)\n        return os.path.normpath(os.path.join(host, url2pathname(unquote(parsed.path))))\n\nclass FileUtils:\n    \"\"\"\n    Utility functions for file operations.\n    \"\"\"\n\n    @staticmethod\n    def read_file(logger: MultilspyLogger, file_path: str) -> str:\n        \"\"\"\n        Reads the file at the given path and returns the contents as a string.\n        \"\"\"\n        encodings = [\"utf-8-sig\", \"utf-16\"]\n        try:\n            for encoding in encodings:\n                try:\n                    with open(file_path, \"r\", encoding=encoding) as inp_file:\n                        return inp_file.read()\n                except UnicodeError:\n                    continue\n        except Exception as exc:\n            logger.log(f\"File read '{file_path}' failed: {exc}\", logging.ERROR)\n            raise MultilspyException(\"File read failed.\") from None\n        logger.log(f\"File read '{file_path}' failed: Unsupported encoding.\", logging.ERROR)\n        raise MultilspyException(f\"File read '{file_path}' failed: Unsupported encoding.\") from None\n    \n    @staticmethod\n    def download_file(logger: MultilspyLogger, url: str, target_path: str) -> None:\n        \"\"\"\n        Downloads the file from the given URL to the given {target_path}\n        \"\"\"\n        try:\n            response = requests.get(url, stream=True, timeout=60)\n            if response.status_code != 200:\n                logger.log(f\"Error downloading file '{url}': {response.status_code} {response.text}\", logging.ERROR)\n                raise MultilspyException(\"Error downoading file.\")\n            with open(target_path, \"wb\") as f:\n                shutil.copyfileobj(response.raw, f)\n        except Exception as exc:\n            logger.log(f\"Error downloading file '{url}': {exc}\", logging.ERROR)\n            raise MultilspyException(\"Error downoading file.\") from None\n\n    @staticmethod\n    def download_and_extract_archive(logger: MultilspyLogger, url: str, target_path: str, archive_type: str) -> None:\n        \"\"\"\n        Downloads the archive from the given URL having format {archive_type} and extracts it to the given {target_path}\n        \"\"\"\n        try:\n            tmp_files = []\n            tmp_file_name = str(PurePath(os.path.expanduser(\"~\"), \"multilspy_tmp\", uuid.uuid4().hex))\n            tmp_files.append(tmp_file_name)\n            os.makedirs(os.path.dirname(tmp_file_name), exist_ok=True)\n            FileUtils.download_file(logger, url, tmp_file_name)\n            if archive_type in [\"zip\", \"tar\", \"gztar\", \"bztar\", \"xztar\"]:\n                assert os.path.isdir(target_path)\n                shutil.unpack_archive(tmp_file_name, target_path, archive_type)\n            elif archive_type == \"zip.gz\":\n                assert os.path.isdir(target_path)\n                tmp_file_name_ungzipped = tmp_file_name + \".zip\"\n                tmp_files.append(tmp_file_name_ungzipped)\n                with gzip.open(tmp_file_name, \"rb\") as f_in, open(tmp_file_name_ungzipped, \"wb\") as f_out:\n                    shutil.copyfileobj(f_in, f_out)\n                shutil.unpack_archive(tmp_file_name_ungzipped, target_path, \"zip\")\n            elif archive_type == \"gz\":\n                with gzip.open(tmp_file_name, \"rb\") as f_in, open(target_path, \"wb\") as f_out:\n                    shutil.copyfileobj(f_in, f_out)\n            else:\n                logger.log(f\"Unknown archive type '{archive_type}' for extraction\", logging.ERROR)\n                raise MultilspyException(f\"Unknown archive type '{archive_type}'\")\n        except Exception as exc:\n            logger.log(f\"Error extracting archive '{tmp_file_name}' obtained from '{url}': {exc}\", logging.ERROR)\n            raise MultilspyException(\"Error extracting archive.\") from exc\n        finally:\n            for tmp_file_name in tmp_files:\n                if os.path.exists(tmp_file_name):\n                    Path.unlink(Path(tmp_file_name))\n\nclass PlatformId(str, Enum):\n    \"\"\"\n    multilspy supported platforms\n    \"\"\"\n    WIN_x86 = \"win-x86\"\n    WIN_x64 = \"win-x64\"\n    WIN_arm64 = \"win-arm64\"\n    OSX = \"osx\"\n    OSX_x64 = \"osx-x64\"\n    OSX_arm64 = \"osx-arm64\"\n    LINUX_x86 = \"linux-x86\"\n    LINUX_x64 = \"linux-x64\"\n    LINUX_arm64 = \"linux-arm64\"\n    LINUX_MUSL_x64 = \"linux-musl-x64\"\n    LINUX_MUSL_arm64 = \"linux-musl-arm64\"\n\nclass DotnetVersion(str, Enum):\n    \"\"\"\n    multilspy supported dotnet versions\n    \"\"\"\n    V4 = \"4\"\n    V6 = \"6\"\n    V7 = \"7\"\n    VMONO = \"mono\"\n\nclass PlatformUtils:\n    \"\"\"\n    This class provides utilities for platform detection and identification.\n    \"\"\"\n\n    @staticmethod\n    def get_platform_id() -> PlatformId:\n        \"\"\"\n        Returns the platform id for the current system\n        \"\"\"\n        system = platform.system()\n        machine = platform.machine()\n        bitness = platform.architecture()[0]\n        system_map = {\"Windows\": \"win\", \"Darwin\": \"osx\", \"Linux\": \"linux\"}\n        machine_map = {\"AMD64\": \"x64\", \"x86_64\": \"x64\", \"i386\": \"x86\", \"i686\": \"x86\", \"aarch64\": \"arm64\"}\n        if system in system_map and machine in machine_map:\n            platform_id = system_map[system] + \"-\" + machine_map[machine]\n            if system == \"Linux\" and bitness == \"64bit\":\n                libc = platform.libc_ver()[0]\n                if libc != 'glibc':\n                    platform_id += \"-\" + libc\n            return PlatformId(platform_id)\n        else:\n            raise MultilspyException(\"Unknown platform: \" + system + \" \" + machine + \" \" + bitness)\n\n    @staticmethod\n    def get_dotnet_version() -> DotnetVersion:\n        \"\"\"\n        Returns the dotnet version for the current system\n        \"\"\"\n        try:\n            result = subprocess.run([\"dotnet\", \"--list-runtimes\"], capture_output=True, check=True)\n            version = ''\n            for line in result.stdout.decode('utf-8').split('\\n'):\n                if line.startswith('Microsoft.NETCore.App'):\n                    version = line.split(' ')[1]\n                    break\n            if version == '':\n                raise MultilspyException(\"dotnet not found on the system\")\n            if version.startswith(\"7\"):\n                return DotnetVersion.V7\n            elif version.startswith(\"6\"):\n                return DotnetVersion.V6\n            elif version.startswith(\"4\"):\n                return DotnetVersion.V4\n            else:\n                raise MultilspyException(\"Unknown dotnet version: \" + version)\n        except subprocess.CalledProcessError:\n            try:\n                result = subprocess.run([\"mono\", \"--version\"], capture_output=True, check=True)\n                return DotnetVersion.VMONO\n            except subprocess.CalledProcessError:\n                raise MultilspyException(\"dotnet or mono not found on the system\")\n"}
{"type": "source_file", "path": "src/hyperagent/multilspy/lsp_protocol_handler/lsp_types.py", "content": "# Code generated. DO NOT EDIT.\n# LSP v3.17.0\n# TODO: Look into use of https://pypi.org/project/ts2python/ to generate the types for https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\n\n\"\"\"\nThis file provides the Python types corresponding to the Typescript types defined in the language server protocol.\nThis file is obtained from https://github.com/predragnikolic/OLSP under the MIT License with the following terms:\n\nMIT License\n\nCopyright (c) 2023 Предраг Николић\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n\nfrom enum import Enum, IntEnum, IntFlag\nfrom typing import Dict, List, Literal, Union\nfrom typing_extensions import NotRequired, TypedDict\n\nURI = str\nDocumentUri = str\nUint = int\nRegExp = str\n\n\nclass SemanticTokenTypes(Enum):\n    \"\"\"A set of predefined token types. This set is not fixed\n    an clients can specify additional token types via the\n    corresponding client capabilities.\n\n    @since 3.16.0\"\"\"\n\n    Namespace = \"namespace\"\n    Type = \"type\"\n    \"\"\" Represents a generic type. Acts as a fallback for types which can't be mapped to\n    a specific type like class or enum. \"\"\"\n    Class = \"class\"\n    Enum = \"enum\"\n    Interface = \"interface\"\n    Struct = \"struct\"\n    TypeParameter = \"typeParameter\"\n    Parameter = \"parameter\"\n    Variable = \"variable\"\n    Property = \"property\"\n    EnumMember = \"enumMember\"\n    Event = \"event\"\n    Function = \"function\"\n    Method = \"method\"\n    Macro = \"macro\"\n    Keyword = \"keyword\"\n    Modifier = \"modifier\"\n    Comment = \"comment\"\n    String = \"string\"\n    Number = \"number\"\n    Regexp = \"regexp\"\n    Operator = \"operator\"\n    Decorator = \"decorator\"\n    \"\"\" @since 3.17.0 \"\"\"\n\n\nclass SemanticTokenModifiers(Enum):\n    \"\"\"A set of predefined token modifiers. This set is not fixed\n    an clients can specify additional token types via the\n    corresponding client capabilities.\n\n    @since 3.16.0\"\"\"\n\n    Declaration = \"declaration\"\n    Definition = \"definition\"\n    Readonly = \"readonly\"\n    Static = \"static\"\n    Deprecated = \"deprecated\"\n    Abstract = \"abstract\"\n    Async = \"async\"\n    Modification = \"modification\"\n    Documentation = \"documentation\"\n    DefaultLibrary = \"defaultLibrary\"\n\n\nclass DocumentDiagnosticReportKind(Enum):\n    \"\"\"The document diagnostic report kinds.\n\n    @since 3.17.0\"\"\"\n\n    Full = \"full\"\n    \"\"\" A diagnostic report with a full\n    set of problems. \"\"\"\n    Unchanged = \"unchanged\"\n    \"\"\" A report indicating that the last\n    returned report is still accurate. \"\"\"\n\n\nclass ErrorCodes(IntEnum):\n    \"\"\"Predefined error codes.\"\"\"\n\n    ParseError = -32700\n    InvalidRequest = -32600\n    MethodNotFound = -32601\n    InvalidParams = -32602\n    InternalError = -32603\n    ServerNotInitialized = -32002\n    \"\"\" Error code indicating that a server received a notification or\n    request before the server has received the `initialize` request. \"\"\"\n    UnknownErrorCode = -32001\n\n\nclass LSPErrorCodes(IntEnum):\n    RequestFailed = -32803\n    \"\"\" A request failed but it was syntactically correct, e.g the\n    method name was known and the parameters were valid. The error\n    message should contain human readable information about why\n    the request failed.\n\n    @since 3.17.0 \"\"\"\n    ServerCancelled = -32802\n    \"\"\" The server cancelled the request. This error code should\n    only be used for requests that explicitly support being\n    server cancellable.\n\n    @since 3.17.0 \"\"\"\n    ContentModified = -32801\n    \"\"\" The server detected that the content of a document got\n    modified outside normal conditions. A server should\n    NOT send this error code if it detects a content change\n    in it unprocessed messages. The result even computed\n    on an older state might still be useful for the client.\n\n    If a client decides that a result is not of any use anymore\n    the client should cancel the request. \"\"\"\n    RequestCancelled = -32800\n    \"\"\" The client has canceled a request and a server as detected\n    the cancel. \"\"\"\n\n\nclass FoldingRangeKind(Enum):\n    \"\"\"A set of predefined range kinds.\"\"\"\n\n    Comment = \"comment\"\n    \"\"\" Folding range for a comment \"\"\"\n    Imports = \"imports\"\n    \"\"\" Folding range for an import or include \"\"\"\n    Region = \"region\"\n    \"\"\" Folding range for a region (e.g. `#region`) \"\"\"\n\n\nclass SymbolKind(IntEnum):\n    \"\"\"A symbol kind.\"\"\"\n\n    File = 1\n    Module = 2\n    Namespace = 3\n    Package = 4\n    Class = 5\n    Method = 6\n    Property = 7\n    Field = 8\n    Constructor = 9\n    Enum = 10\n    Interface = 11\n    Function = 12\n    Variable = 13\n    Constant = 14\n    String = 15\n    Number = 16\n    Boolean = 17\n    Array = 18\n    Object = 19\n    Key = 20\n    Null = 21\n    EnumMember = 22\n    Struct = 23\n    Event = 24\n    Operator = 25\n    TypeParameter = 26\n\n\nclass SymbolTag(IntEnum):\n    \"\"\"Symbol tags are extra annotations that tweak the rendering of a symbol.\n\n    @since 3.16\"\"\"\n\n    Deprecated = 1\n    \"\"\" Render a symbol as obsolete, usually using a strike-out. \"\"\"\n\n\nclass UniquenessLevel(Enum):\n    \"\"\"Moniker uniqueness level to define scope of the moniker.\n\n    @since 3.16.0\"\"\"\n\n    Document = \"document\"\n    \"\"\" The moniker is only unique inside a document \"\"\"\n    Project = \"project\"\n    \"\"\" The moniker is unique inside a project for which a dump got created \"\"\"\n    Group = \"group\"\n    \"\"\" The moniker is unique inside the group to which a project belongs \"\"\"\n    Scheme = \"scheme\"\n    \"\"\" The moniker is unique inside the moniker scheme. \"\"\"\n    Global = \"global\"\n    \"\"\" The moniker is globally unique \"\"\"\n\n\nclass MonikerKind(Enum):\n    \"\"\"The moniker kind.\n\n    @since 3.16.0\"\"\"\n\n    Import = \"import\"\n    \"\"\" The moniker represent a symbol that is imported into a project \"\"\"\n    Export = \"export\"\n    \"\"\" The moniker represents a symbol that is exported from a project \"\"\"\n    Local = \"local\"\n    \"\"\" The moniker represents a symbol that is local to a project (e.g. a local\n    variable of a function, a class not visible outside the project, ...) \"\"\"\n\n\nclass InlayHintKind(IntEnum):\n    \"\"\"Inlay hint kinds.\n\n    @since 3.17.0\"\"\"\n\n    Type = 1\n    \"\"\" An inlay hint that for a type annotation. \"\"\"\n    Parameter = 2\n    \"\"\" An inlay hint that is for a parameter. \"\"\"\n\n\nclass MessageType(IntEnum):\n    \"\"\"The message type\"\"\"\n\n    Error = 1\n    \"\"\" An error message. \"\"\"\n    Warning = 2\n    \"\"\" A warning message. \"\"\"\n    Info = 3\n    \"\"\" An information message. \"\"\"\n    Log = 4\n    \"\"\" A log message. \"\"\"\n\n\nclass TextDocumentSyncKind(IntEnum):\n    \"\"\"Defines how the host (editor) should sync\n    document changes to the language server.\"\"\"\n\n    None_ = 0\n    \"\"\" Documents should not be synced at all. \"\"\"\n    Full = 1\n    \"\"\" Documents are synced by always sending the full content\n    of the document. \"\"\"\n    Incremental = 2\n    \"\"\" Documents are synced by sending the full content on open.\n    After that only incremental updates to the document are\n    send. \"\"\"\n\n\nclass TextDocumentSaveReason(IntEnum):\n    \"\"\"Represents reasons why a text document is saved.\"\"\"\n\n    Manual = 1\n    \"\"\" Manually triggered, e.g. by the user pressing save, by starting debugging,\n    or by an API call. \"\"\"\n    AfterDelay = 2\n    \"\"\" Automatic after a delay. \"\"\"\n    FocusOut = 3\n    \"\"\" When the editor lost focus. \"\"\"\n\n\nclass CompletionItemKind(IntEnum):\n    \"\"\"The kind of a completion entry.\"\"\"\n\n    Text = 1\n    Method = 2\n    Function = 3\n    Constructor = 4\n    Field = 5\n    Variable = 6\n    Class = 7\n    Interface = 8\n    Module = 9\n    Property = 10\n    Unit = 11\n    Value = 12\n    Enum = 13\n    Keyword = 14\n    Snippet = 15\n    Color = 16\n    File = 17\n    Reference = 18\n    Folder = 19\n    EnumMember = 20\n    Constant = 21\n    Struct = 22\n    Event = 23\n    Operator = 24\n    TypeParameter = 25\n\n\nclass CompletionItemTag(IntEnum):\n    \"\"\"Completion item tags are extra annotations that tweak the rendering of a completion\n    item.\n\n    @since 3.15.0\"\"\"\n\n    Deprecated = 1\n    \"\"\" Render a completion as obsolete, usually using a strike-out. \"\"\"\n\n\nclass InsertTextFormat(IntEnum):\n    \"\"\"Defines whether the insert text in a completion item should be interpreted as\n    plain text or a snippet.\"\"\"\n\n    PlainText = 1\n    \"\"\" The primary text to be inserted is treated as a plain string. \"\"\"\n    Snippet = 2\n    \"\"\" The primary text to be inserted is treated as a snippet.\n\n    A snippet can define tab stops and placeholders with `$1`, `$2`\n    and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n    the end of the snippet. Placeholders with equal identifiers are linked,\n    that is typing in one will update others too.\n\n    See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax \"\"\"\n\n\nclass InsertTextMode(IntEnum):\n    \"\"\"How whitespace and indentation is handled during completion\n    item insertion.\n\n    @since 3.16.0\"\"\"\n\n    AsIs = 1\n    \"\"\" The insertion or replace strings is taken as it is. If the\n    value is multi line the lines below the cursor will be\n    inserted using the indentation defined in the string value.\n    The client will not apply any kind of adjustments to the\n    string. \"\"\"\n    AdjustIndentation = 2\n    \"\"\" The editor adjusts leading whitespace of new lines so that\n    they match the indentation up to the cursor of the line for\n    which the item is accepted.\n\n    Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n    multi line completion item is indented using 2 tabs and all\n    following lines inserted will be indented using 2 tabs as well. \"\"\"\n\n\nclass DocumentHighlightKind(IntEnum):\n    \"\"\"A document highlight kind.\"\"\"\n\n    Text = 1\n    \"\"\" A textual occurrence. \"\"\"\n    Read = 2\n    \"\"\" Read-access of a symbol, like reading a variable. \"\"\"\n    Write = 3\n    \"\"\" Write-access of a symbol, like writing to a variable. \"\"\"\n\n\nclass CodeActionKind(Enum):\n    \"\"\"A set of predefined code action kinds\"\"\"\n\n    Empty = \"\"\n    \"\"\" Empty kind. \"\"\"\n    QuickFix = \"quickfix\"\n    \"\"\" Base kind for quickfix actions: 'quickfix' \"\"\"\n    Refactor = \"refactor\"\n    \"\"\" Base kind for refactoring actions: 'refactor' \"\"\"\n    RefactorExtract = \"refactor.extract\"\n    \"\"\" Base kind for refactoring extraction actions: 'refactor.extract'\n\n    Example extract actions:\n\n    - Extract method\n    - Extract function\n    - Extract variable\n    - Extract interface from class\n    - ... \"\"\"\n    RefactorInline = \"refactor.inline\"\n    \"\"\" Base kind for refactoring inline actions: 'refactor.inline'\n\n    Example inline actions:\n\n    - Inline function\n    - Inline variable\n    - Inline constant\n    - ... \"\"\"\n    RefactorRewrite = \"refactor.rewrite\"\n    \"\"\" Base kind for refactoring rewrite actions: 'refactor.rewrite'\n\n    Example rewrite actions:\n\n    - Convert JavaScript function to class\n    - Add or remove parameter\n    - Encapsulate field\n    - Make method static\n    - Move method to base class\n    - ... \"\"\"\n    Source = \"source\"\n    \"\"\" Base kind for source actions: `source`\n\n    Source code actions apply to the entire file. \"\"\"\n    SourceOrganizeImports = \"source.organizeImports\"\n    \"\"\" Base kind for an organize imports source action: `source.organizeImports` \"\"\"\n    SourceFixAll = \"source.fixAll\"\n    \"\"\" Base kind for auto-fix source actions: `source.fixAll`.\n\n    Fix all actions automatically fix errors that have a clear fix that do not require user input.\n    They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n\n    @since 3.15.0 \"\"\"\n\n\nclass TraceValues(Enum):\n    Off = \"off\"\n    \"\"\" Turn tracing off. \"\"\"\n    Messages = \"messages\"\n    \"\"\" Trace messages only. \"\"\"\n    Verbose = \"verbose\"\n    \"\"\" Verbose message tracing. \"\"\"\n\n\nclass MarkupKind(Enum):\n    \"\"\"Describes the content type that a client supports in various\n    result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n\n    Please note that `MarkupKinds` must not start with a `$`. This kinds\n    are reserved for internal usage.\"\"\"\n\n    PlainText = \"plaintext\"\n    \"\"\" Plain text is supported as a content format \"\"\"\n    Markdown = \"markdown\"\n    \"\"\" Markdown is supported as a content format \"\"\"\n\n\nclass PositionEncodingKind(Enum):\n    \"\"\"A set of predefined position encoding kinds.\n\n    @since 3.17.0\"\"\"\n\n    UTF8 = \"utf-8\"\n    \"\"\" Character offsets count UTF-8 code units. \"\"\"\n    UTF16 = \"utf-16\"\n    \"\"\" Character offsets count UTF-16 code units.\n\n    This is the default and must always be supported\n    by servers \"\"\"\n    UTF32 = \"utf-32\"\n    \"\"\" Character offsets count UTF-32 code units.\n\n    Implementation note: these are the same as Unicode code points,\n    so this `PositionEncodingKind` may also be used for an\n    encoding-agnostic representation of character offsets. \"\"\"\n\n\nclass FileChangeType(IntEnum):\n    \"\"\"The file event type\"\"\"\n\n    Created = 1\n    \"\"\" The file got created. \"\"\"\n    Changed = 2\n    \"\"\" The file got changed. \"\"\"\n    Deleted = 3\n    \"\"\" The file got deleted. \"\"\"\n\n\nclass WatchKind(IntFlag):\n    Create = 1\n    \"\"\" Interested in create events. \"\"\"\n    Change = 2\n    \"\"\" Interested in change events \"\"\"\n    Delete = 4\n    \"\"\" Interested in delete events \"\"\"\n\n\nclass DiagnosticSeverity(IntEnum):\n    \"\"\"The diagnostic's severity.\"\"\"\n\n    Error = 1\n    \"\"\" Reports an error. \"\"\"\n    Warning = 2\n    \"\"\" Reports a warning. \"\"\"\n    Information = 3\n    \"\"\" Reports an information. \"\"\"\n    Hint = 4\n    \"\"\" Reports a hint. \"\"\"\n\n\nclass DiagnosticTag(IntEnum):\n    \"\"\"The diagnostic tags.\n\n    @since 3.15.0\"\"\"\n\n    Unnecessary = 1\n    \"\"\" Unused or unnecessary code.\n\n    Clients are allowed to render diagnostics with this tag faded out instead of having\n    an error squiggle. \"\"\"\n    Deprecated = 2\n    \"\"\" Deprecated or obsolete code.\n\n    Clients are allowed to rendered diagnostics with this tag strike through. \"\"\"\n\n\nclass CompletionTriggerKind(IntEnum):\n    \"\"\"How a completion was triggered\"\"\"\n\n    Invoked = 1\n    \"\"\" Completion was triggered by typing an identifier (24x7 code\n    complete), manual invocation (e.g Ctrl+Space) or via API. \"\"\"\n    TriggerCharacter = 2\n    \"\"\" Completion was triggered by a trigger character specified by\n    the `triggerCharacters` properties of the `CompletionRegistrationOptions`. \"\"\"\n    TriggerForIncompleteCompletions = 3\n    \"\"\" Completion was re-triggered as current completion list is incomplete \"\"\"\n\n\nclass SignatureHelpTriggerKind(IntEnum):\n    \"\"\"How a signature help was triggered.\n\n    @since 3.15.0\"\"\"\n\n    Invoked = 1\n    \"\"\" Signature help was invoked manually by the user or by a command. \"\"\"\n    TriggerCharacter = 2\n    \"\"\" Signature help was triggered by a trigger character. \"\"\"\n    ContentChange = 3\n    \"\"\" Signature help was triggered by the cursor moving or by the document content changing. \"\"\"\n\n\nclass CodeActionTriggerKind(IntEnum):\n    \"\"\"The reason why code actions were requested.\n\n    @since 3.17.0\"\"\"\n\n    Invoked = 1\n    \"\"\" Code actions were explicitly requested by the user or by an extension. \"\"\"\n    Automatic = 2\n    \"\"\" Code actions were requested automatically.\n\n    This typically happens when current selection in a file changes, but can\n    also be triggered when file content changes. \"\"\"\n\n\nclass FileOperationPatternKind(Enum):\n    \"\"\"A pattern kind describing if a glob pattern matches a file a folder or\n    both.\n\n    @since 3.16.0\"\"\"\n\n    File = \"file\"\n    \"\"\" The pattern matches a file only. \"\"\"\n    Folder = \"folder\"\n    \"\"\" The pattern matches a folder only. \"\"\"\n\n\nclass NotebookCellKind(IntEnum):\n    \"\"\"A notebook cell kind.\n\n    @since 3.17.0\"\"\"\n\n    Markup = 1\n    \"\"\" A markup-cell is formatted source that is used for display. \"\"\"\n    Code = 2\n    \"\"\" A code-cell is source code. \"\"\"\n\n\nclass ResourceOperationKind(Enum):\n    Create = \"create\"\n    \"\"\" Supports creating new files and folders. \"\"\"\n    Rename = \"rename\"\n    \"\"\" Supports renaming existing files and folders. \"\"\"\n    Delete = \"delete\"\n    \"\"\" Supports deleting existing files and folders. \"\"\"\n\n\nclass FailureHandlingKind(Enum):\n    Abort = \"abort\"\n    \"\"\" Applying the workspace change is simply aborted if one of the changes provided\n    fails. All operations executed before the failing operation stay executed. \"\"\"\n    Transactional = \"transactional\"\n    \"\"\" All operations are executed transactional. That means they either all\n    succeed or no changes at all are applied to the workspace. \"\"\"\n    TextOnlyTransactional = \"textOnlyTransactional\"\n    \"\"\" If the workspace edit contains only textual file changes they are executed transactional.\n    If resource changes (create, rename or delete file) are part of the change the failure\n    handling strategy is abort. \"\"\"\n    Undo = \"undo\"\n    \"\"\" The client tries to undo the operations already executed. But there is no\n    guarantee that this is succeeding. \"\"\"\n\n\nclass PrepareSupportDefaultBehavior(IntEnum):\n    Identifier = 1\n    \"\"\" The client's default behavior is to select the identifier\n    according the to language's syntax rule. \"\"\"\n\n\nclass TokenFormat(Enum):\n    Relative = \"relative\"\n\n\nDefinition = Union[\"Location\", List[\"Location\"]]\n\"\"\" The definition of a symbol represented as one or many {@link Location locations}.\nFor most programming languages there is only one location at which a symbol is\ndefined.\n\nServers should prefer returning `DefinitionLink` over `Definition` if supported\nby the client. \"\"\"\n\nDefinitionLink = \"LocationLink\"\n\"\"\" Information about where a symbol is defined.\n\nProvides additional metadata over normal {@link Location location} definitions, including the range of\nthe defining symbol \"\"\"\n\nLSPArray = List[\"LSPAny\"]\n\"\"\" LSP arrays.\n@since 3.17.0 \"\"\"\n\nLSPAny = Union[\"LSPObject\", \"LSPArray\", str, int, Uint, float, bool, None]\n\"\"\" The LSP any type.\nPlease note that strictly speaking a property with the value `undefined`\ncan't be converted into JSON preserving the property name. However for\nconvenience it is allowed and assumed that all these properties are\noptional as well.\n@since 3.17.0 \"\"\"\n\nDeclaration = Union[\"Location\", List[\"Location\"]]\n\"\"\" The declaration of a symbol representation as one or many {@link Location locations}. \"\"\"\n\nDeclarationLink = \"LocationLink\"\n\"\"\" Information about where a symbol is declared.\n\nProvides additional metadata over normal {@link Location location} declarations, including the range of\nthe declaring symbol.\n\nServers should prefer returning `DeclarationLink` over `Declaration` if supported\nby the client. \"\"\"\n\nInlineValue = Union[\n    \"InlineValueText\", \"InlineValueVariableLookup\", \"InlineValueEvaluatableExpression\"\n]\n\"\"\" Inline value information can be provided by different means:\n- directly as a text value (class InlineValueText).\n- as a name to use for a variable lookup (class InlineValueVariableLookup)\n- as an evaluatable expression (class InlineValueEvaluatableExpression)\nThe InlineValue types combines all inline value types into one type.\n\n@since 3.17.0 \"\"\"\n\nDocumentDiagnosticReport = Union[\n    \"RelatedFullDocumentDiagnosticReport\", \"RelatedUnchangedDocumentDiagnosticReport\"\n]\n\"\"\" The result of a document diagnostic pull request. A report can\neither be a full report containing all diagnostics for the\nrequested document or an unchanged report indicating that nothing\nhas changed in terms of diagnostics in comparison to the last\npull request.\n\n@since 3.17.0 \"\"\"\n\nPrepareRenameResult = Union[\n    \"Range\", \"__PrepareRenameResult_Type_1\", \"__PrepareRenameResult_Type_2\"\n]\n\nDocumentSelector = List[\"DocumentFilter\"]\n\"\"\" A document selector is the combination of one or many document filters.\n\n@sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**∕tsconfig.json' }]`;\n\nThe use of a string as a document filter is deprecated @since 3.16.0. \"\"\"\n\nProgressToken = Union[int, str]\n\nChangeAnnotationIdentifier = str\n\"\"\" An identifier to refer to a change annotation stored with a workspace edit. \"\"\"\n\nWorkspaceDocumentDiagnosticReport = Union[\n    \"WorkspaceFullDocumentDiagnosticReport\",\n    \"WorkspaceUnchangedDocumentDiagnosticReport\",\n]\n\"\"\" A workspace diagnostic document report.\n\n@since 3.17.0 \"\"\"\n\nTextDocumentContentChangeEvent = Union[\n    \"__TextDocumentContentChangeEvent_Type_1\", \"__TextDocumentContentChangeEvent_Type_2\"\n]\n\"\"\" An event describing a change to a text document. If only a text is provided\nit is considered to be the full content of the document. \"\"\"\n\nMarkedString = Union[str, \"__MarkedString_Type_1\"]\n\"\"\" MarkedString can be used to render human readable text. It is either a markdown string\nor a code-block that provides a language and a code snippet. The language identifier\nis semantically equal to the optional language identifier in fenced code blocks in GitHub\nissues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting\n\nThe pair of a language and a value is an equivalent to markdown:\n```${language}\n${value}\n```\n\nNote that markdown strings will be sanitized - that means html will be escaped.\n@deprecated use MarkupContent instead. \"\"\"\n\nDocumentFilter = Union[\"TextDocumentFilter\", \"NotebookCellTextDocumentFilter\"]\n\"\"\" A document filter describes a top level text document or\na notebook cell document.\n\n@since 3.17.0 - proposed support for NotebookCellTextDocumentFilter. \"\"\"\n\nLSPObject = Dict[str, \"LSPAny\"]\n\"\"\" LSP object definition.\n@since 3.17.0 \"\"\"\n\nGlobPattern = Union[\"Pattern\", \"RelativePattern\"]\n\"\"\" The glob pattern. Either a string pattern or a relative pattern.\n\n@since 3.17.0 \"\"\"\n\nTextDocumentFilter = Union[\n    \"__TextDocumentFilter_Type_1\",\n    \"__TextDocumentFilter_Type_2\",\n    \"__TextDocumentFilter_Type_3\",\n]\n\"\"\" A document filter denotes a document by different properties like\nthe {@link TextDocument.languageId language}, the {@link Uri.scheme scheme} of\nits resource, or a glob-pattern that is applied to the {@link TextDocument.fileName path}.\n\nGlob patterns can have the following syntax:\n- `*` to match one or more characters in a path segment\n- `?` to match on one character in a path segment\n- `**` to match any number of path segments, including none\n- `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)\n- `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n- `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n\n@sample A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`\n@sample A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`\n\n@since 3.17.0 \"\"\"\n\nNotebookDocumentFilter = Union[\n    \"__NotebookDocumentFilter_Type_1\",\n    \"__NotebookDocumentFilter_Type_2\",\n    \"__NotebookDocumentFilter_Type_3\",\n]\n\"\"\" A notebook document filter denotes a notebook document by\ndifferent properties. The properties will be match\nagainst the notebook's URI (same as with documents)\n\n@since 3.17.0 \"\"\"\n\nPattern = str\n\"\"\" The glob pattern to watch relative to the base path. Glob patterns can have the following syntax:\n- `*` to match one or more characters in a path segment\n- `?` to match on one character in a path segment\n- `**` to match any number of path segments, including none\n- `{}` to group conditions (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)\n- `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n- `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n\n@since 3.17.0 \"\"\"\n\n\nclass ImplementationParams(TypedDict):\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass Location(TypedDict):\n    \"\"\"Represents a location inside a resource, such as a line\n    inside a text file.\"\"\"\n\n    uri: \"DocumentUri\"\n    range: \"Range\"\n\n\nclass ImplementationRegistrationOptions(TypedDict):\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass TypeDefinitionParams(TypedDict):\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass TypeDefinitionRegistrationOptions(TypedDict):\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass WorkspaceFolder(TypedDict):\n    \"\"\"A workspace folder inside a client.\"\"\"\n\n    uri: \"URI\"\n    \"\"\" The associated URI for this workspace folder. \"\"\"\n    name: str\n    \"\"\" The name of the workspace folder. Used to refer to this\n    workspace folder in the user interface. \"\"\"\n\n\nclass DidChangeWorkspaceFoldersParams(TypedDict):\n    \"\"\"The parameters of a `workspace/didChangeWorkspaceFolders` notification.\"\"\"\n\n    event: \"WorkspaceFoldersChangeEvent\"\n    \"\"\" The actual workspace folder change event. \"\"\"\n\n\nclass ConfigurationParams(TypedDict):\n    \"\"\"The parameters of a configuration request.\"\"\"\n\n    items: List[\"ConfigurationItem\"]\n\n\nclass DocumentColorParams(TypedDict):\n    \"\"\"Parameters for a {@link DocumentColorRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass ColorInformation(TypedDict):\n    \"\"\"Represents a color range from a document.\"\"\"\n\n    range: \"Range\"\n    \"\"\" The range in the document where this color appears. \"\"\"\n    color: \"Color\"\n    \"\"\" The actual color value for this color range. \"\"\"\n\n\nclass DocumentColorRegistrationOptions(TypedDict):\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass ColorPresentationParams(TypedDict):\n    \"\"\"Parameters for a {@link ColorPresentationRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    color: \"Color\"\n    \"\"\" The color to request presentations for. \"\"\"\n    range: \"Range\"\n    \"\"\" The range where the color would be inserted. Serves as a context. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass ColorPresentation(TypedDict):\n    label: str\n    \"\"\" The label of this color presentation. It will be shown on the color\n    picker header. By default this is also the text that is inserted when selecting\n    this color presentation. \"\"\"\n    textEdit: NotRequired[\"TextEdit\"]\n    \"\"\" An {@link TextEdit edit} which is applied to a document when selecting\n    this presentation for the color.  When `falsy` the {@link ColorPresentation.label label}\n    is used. \"\"\"\n    additionalTextEdits: NotRequired[List[\"TextEdit\"]]\n    \"\"\" An optional array of additional {@link TextEdit text edits} that are applied when\n    selecting this color presentation. Edits must not overlap with the main {@link ColorPresentation.textEdit edit} nor with themselves. \"\"\"\n\n\nclass WorkDoneProgressOptions(TypedDict):\n    workDoneProgress: NotRequired[bool]\n\n\nclass TextDocumentRegistrationOptions(TypedDict):\n    \"\"\"General text document registration options.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n\n\nclass FoldingRangeParams(TypedDict):\n    \"\"\"Parameters for a {@link FoldingRangeRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass FoldingRange(TypedDict):\n    \"\"\"Represents a folding range. To be valid, start and end line must be bigger than zero and smaller\n    than the number of lines in the document. Clients are free to ignore invalid ranges.\n    \"\"\"\n\n    startLine: Uint\n    \"\"\" The zero-based start line of the range to fold. The folded area starts after the line's last character.\n    To be valid, the end must be zero or larger and smaller than the number of lines in the document. \"\"\"\n    startCharacter: NotRequired[Uint]\n    \"\"\" The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line. \"\"\"\n    endLine: Uint\n    \"\"\" The zero-based end line of the range to fold. The folded area ends with the line's last character.\n    To be valid, the end must be zero or larger and smaller than the number of lines in the document. \"\"\"\n    endCharacter: NotRequired[Uint]\n    \"\"\" The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line. \"\"\"\n    kind: NotRequired[\"FoldingRangeKind\"]\n    \"\"\" Describes the kind of the folding range such as `comment' or 'region'. The kind\n    is used to categorize folding ranges and used by commands like 'Fold all comments'.\n    See {@link FoldingRangeKind} for an enumeration of standardized kinds. \"\"\"\n    collapsedText: NotRequired[str]\n    \"\"\" The text that the client should show when the specified range is\n    collapsed. If not defined or not supported by the client, a default\n    will be chosen by the client.\n\n    @since 3.17.0 \"\"\"\n\n\nclass FoldingRangeRegistrationOptions(TypedDict):\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass DeclarationParams(TypedDict):\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass DeclarationRegistrationOptions(TypedDict):\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass SelectionRangeParams(TypedDict):\n    \"\"\"A parameter literal used in selection range requests.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    positions: List[\"Position\"]\n    \"\"\" The positions inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass SelectionRange(TypedDict):\n    \"\"\"A selection range represents a part of a selection hierarchy. A selection range\n    may have a parent selection range that contains it.\"\"\"\n\n    range: \"Range\"\n    \"\"\" The {@link Range range} of this selection range. \"\"\"\n    parent: NotRequired[\"SelectionRange\"]\n    \"\"\" The parent selection range containing this range. Therefore `parent.range` must contain `this.range`. \"\"\"\n\n\nclass SelectionRangeRegistrationOptions(TypedDict):\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass WorkDoneProgressCreateParams(TypedDict):\n    token: \"ProgressToken\"\n    \"\"\" The token to be used to report progress. \"\"\"\n\n\nclass WorkDoneProgressCancelParams(TypedDict):\n    token: \"ProgressToken\"\n    \"\"\" The token to be used to report progress. \"\"\"\n\n\nclass CallHierarchyPrepareParams(TypedDict):\n    \"\"\"The parameter of a `textDocument/prepareCallHierarchy` request.\n\n    @since 3.16.0\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass CallHierarchyItem(TypedDict):\n    \"\"\"Represents programming constructs like functions or constructors in the context\n    of call hierarchy.\n\n    @since 3.16.0\"\"\"\n\n    name: str\n    \"\"\" The name of this item. \"\"\"\n    kind: \"SymbolKind\"\n    \"\"\" The kind of this item. \"\"\"\n    tags: NotRequired[List[\"SymbolTag\"]]\n    \"\"\" Tags for this item. \"\"\"\n    detail: NotRequired[str]\n    \"\"\" More detail for this item, e.g. the signature of a function. \"\"\"\n    uri: \"DocumentUri\"\n    \"\"\" The resource identifier of this item. \"\"\"\n    range: \"Range\"\n    \"\"\" The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code. \"\"\"\n    selectionRange: \"Range\"\n    \"\"\" The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.\n    Must be contained by the {@link CallHierarchyItem.range `range`}. \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A data entry field that is preserved between a call hierarchy prepare and\n    incoming calls or outgoing calls requests. \"\"\"\n\n\nclass CallHierarchyRegistrationOptions(TypedDict):\n    \"\"\"Call hierarchy options used during static or dynamic registration.\n\n    @since 3.16.0\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass CallHierarchyIncomingCallsParams(TypedDict):\n    \"\"\"The parameter of a `callHierarchy/incomingCalls` request.\n\n    @since 3.16.0\"\"\"\n\n    item: \"CallHierarchyItem\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nCallHierarchyIncomingCall = TypedDict(\n    \"CallHierarchyIncomingCall\",\n    {\n        # The item that makes the call.\n        \"from\": \"CallHierarchyItem\",\n        # The ranges at which the calls appear. This is relative to the caller\n        # denoted by {@link CallHierarchyIncomingCall.from `this.from`}.\n        \"fromRanges\": List[\"Range\"],\n    },\n)\n\"\"\" Represents an incoming call, e.g. a caller of a method or constructor.\n\n@since 3.16.0 \"\"\"\n\n\nclass CallHierarchyOutgoingCallsParams(TypedDict):\n    \"\"\"The parameter of a `callHierarchy/outgoingCalls` request.\n\n    @since 3.16.0\"\"\"\n\n    item: \"CallHierarchyItem\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass CallHierarchyOutgoingCall(TypedDict):\n    \"\"\"Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.\n\n    @since 3.16.0\"\"\"\n\n    to: \"CallHierarchyItem\"\n    \"\"\" The item that is called. \"\"\"\n    fromRanges: List[\"Range\"]\n    \"\"\" The range at which this item is called. This is the range relative to the caller, e.g the item\n    passed to {@link CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls `provideCallHierarchyOutgoingCalls`}\n    and not {@link CallHierarchyOutgoingCall.to `this.to`}. \"\"\"\n\n\nclass SemanticTokensParams(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass SemanticTokens(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    resultId: NotRequired[str]\n    \"\"\" An optional result id. If provided and clients support delta updating\n    the client will include the result id in the next semantic token request.\n    A server can then instead of computing all semantic tokens again simply\n    send a delta. \"\"\"\n    data: List[Uint]\n    \"\"\" The actual tokens. \"\"\"\n\n\nclass SemanticTokensPartialResult(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    data: List[Uint]\n\n\nclass SemanticTokensRegistrationOptions(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    legend: \"SemanticTokensLegend\"\n    \"\"\" The legend used by the server \"\"\"\n    range: NotRequired[Union[bool, dict]]\n    \"\"\" Server supports providing semantic tokens for a specific range\n    of a document. \"\"\"\n    full: NotRequired[Union[bool, \"__SemanticTokensOptions_full_Type_1\"]]\n    \"\"\" Server supports providing semantic tokens for a full document. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass SemanticTokensDeltaParams(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    previousResultId: str\n    \"\"\" The result id of a previous response. The result Id can either point to a full response\n    or a delta response depending on what was received last. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass SemanticTokensDelta(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    resultId: NotRequired[str]\n    edits: List[\"SemanticTokensEdit\"]\n    \"\"\" The semantic token edits to transform a previous result into a new result. \"\"\"\n\n\nclass SemanticTokensDeltaPartialResult(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    edits: List[\"SemanticTokensEdit\"]\n\n\nclass SemanticTokensRangeParams(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    range: \"Range\"\n    \"\"\" The range the semantic tokens are requested for. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass ShowDocumentParams(TypedDict):\n    \"\"\"Params to show a document.\n\n    @since 3.16.0\"\"\"\n\n    uri: \"URI\"\n    \"\"\" The document uri to show. \"\"\"\n    external: NotRequired[bool]\n    \"\"\" Indicates to show the resource in an external program.\n    To show for example `https://code.visualstudio.com/`\n    in the default WEB browser set `external` to `true`. \"\"\"\n    takeFocus: NotRequired[bool]\n    \"\"\" An optional property to indicate whether the editor\n    showing the document should take focus or not.\n    Clients might ignore this property if an external\n    program is started. \"\"\"\n    selection: NotRequired[\"Range\"]\n    \"\"\" An optional selection range if the document is a text\n    document. Clients might ignore the property if an\n    external program is started or the file is not a text\n    file. \"\"\"\n\n\nclass ShowDocumentResult(TypedDict):\n    \"\"\"The result of a showDocument request.\n\n    @since 3.16.0\"\"\"\n\n    success: bool\n    \"\"\" A boolean indicating if the show was successful. \"\"\"\n\n\nclass LinkedEditingRangeParams(TypedDict):\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass LinkedEditingRanges(TypedDict):\n    \"\"\"The result of a linked editing range request.\n\n    @since 3.16.0\"\"\"\n\n    ranges: List[\"Range\"]\n    \"\"\" A list of ranges that can be edited together. The ranges must have\n    identical length and contain identical text content. The ranges cannot overlap. \"\"\"\n    wordPattern: NotRequired[str]\n    \"\"\" An optional word pattern (regular expression) that describes valid contents for\n    the given ranges. If no pattern is provided, the client configuration's word\n    pattern will be used. \"\"\"\n\n\nclass LinkedEditingRangeRegistrationOptions(TypedDict):\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass CreateFilesParams(TypedDict):\n    \"\"\"The parameters sent in notifications/requests for user-initiated creation of\n    files.\n\n    @since 3.16.0\"\"\"\n\n    files: List[\"FileCreate\"]\n    \"\"\" An array of all files/folders created in this operation. \"\"\"\n\n\nclass WorkspaceEdit(TypedDict):\n    \"\"\"A workspace edit represents changes to many resources managed in the workspace. The edit\n    should either provide `changes` or `documentChanges`. If documentChanges are present\n    they are preferred over `changes` if the client can handle versioned document edits.\n\n    Since version 3.13.0 a workspace edit can contain resource operations as well. If resource\n    operations are present clients need to execute the operations in the order in which they\n    are provided. So a workspace edit for example can consist of the following two changes:\n    (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.\n\n    An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will\n    cause failure of the operation. How the client recovers from the failure is described by\n    the client capability: `workspace.workspaceEdit.failureHandling`\"\"\"\n\n    changes: NotRequired[Dict[\"DocumentUri\", List[\"TextEdit\"]]]\n    \"\"\" Holds changes to existing resources. \"\"\"\n    documentChanges: NotRequired[\n        List[Union[\"TextDocumentEdit\", \"CreateFile\", \"RenameFile\", \"DeleteFile\"]]\n    ]\n    \"\"\" Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes\n    are either an array of `TextDocumentEdit`s to express changes to n different text documents\n    where each text document edit addresses a specific version of a text document. Or it can contain\n    above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.\n\n    Whether a client supports versioned document edits is expressed via\n    `workspace.workspaceEdit.documentChanges` client capability.\n\n    If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then\n    only plain `TextEdit`s using the `changes` property are supported. \"\"\"\n    changeAnnotations: NotRequired[\n        Dict[\"ChangeAnnotationIdentifier\", \"ChangeAnnotation\"]\n    ]\n    \"\"\" A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and\n    delete file / folder operations.\n\n    Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.\n\n    @since 3.16.0 \"\"\"\n\n\nclass FileOperationRegistrationOptions(TypedDict):\n    \"\"\"The options to register for file operations.\n\n    @since 3.16.0\"\"\"\n\n    filters: List[\"FileOperationFilter\"]\n    \"\"\" The actual filters. \"\"\"\n\n\nclass RenameFilesParams(TypedDict):\n    \"\"\"The parameters sent in notifications/requests for user-initiated renames of\n    files.\n\n    @since 3.16.0\"\"\"\n\n    files: List[\"FileRename\"]\n    \"\"\" An array of all files/folders renamed in this operation. When a folder is renamed, only\n    the folder will be included, and not its children. \"\"\"\n\n\nclass DeleteFilesParams(TypedDict):\n    \"\"\"The parameters sent in notifications/requests for user-initiated deletes of\n    files.\n\n    @since 3.16.0\"\"\"\n\n    files: List[\"FileDelete\"]\n    \"\"\" An array of all files/folders deleted in this operation. \"\"\"\n\n\nclass MonikerParams(TypedDict):\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass Moniker(TypedDict):\n    \"\"\"Moniker definition to match LSIF 0.5 moniker definition.\n\n    @since 3.16.0\"\"\"\n\n    scheme: str\n    \"\"\" The scheme of the moniker. For example tsc or .Net \"\"\"\n    identifier: str\n    \"\"\" The identifier of the moniker. The value is opaque in LSIF however\n    schema owners are allowed to define the structure if they want. \"\"\"\n    unique: \"UniquenessLevel\"\n    \"\"\" The scope in which the moniker is unique \"\"\"\n    kind: NotRequired[\"MonikerKind\"]\n    \"\"\" The moniker kind if known. \"\"\"\n\n\nclass MonikerRegistrationOptions(TypedDict):\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n\n\nclass TypeHierarchyPrepareParams(TypedDict):\n    \"\"\"The parameter of a `textDocument/prepareTypeHierarchy` request.\n\n    @since 3.17.0\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass TypeHierarchyItem(TypedDict):\n    \"\"\"@since 3.17.0\"\"\"\n\n    name: str\n    \"\"\" The name of this item. \"\"\"\n    kind: \"SymbolKind\"\n    \"\"\" The kind of this item. \"\"\"\n    tags: NotRequired[List[\"SymbolTag\"]]\n    \"\"\" Tags for this item. \"\"\"\n    detail: NotRequired[str]\n    \"\"\" More detail for this item, e.g. the signature of a function. \"\"\"\n    uri: \"DocumentUri\"\n    \"\"\" The resource identifier of this item. \"\"\"\n    range: \"Range\"\n    \"\"\" The range enclosing this symbol not including leading/trailing whitespace\n    but everything else, e.g. comments and code. \"\"\"\n    selectionRange: \"Range\"\n    \"\"\" The range that should be selected and revealed when this symbol is being\n    picked, e.g. the name of a function. Must be contained by the\n    {@link TypeHierarchyItem.range `range`}. \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A data entry field that is preserved between a type hierarchy prepare and\n    supertypes or subtypes requests. It could also be used to identify the\n    type hierarchy in the server, helping improve the performance on\n    resolving supertypes and subtypes. \"\"\"\n\n\nclass TypeHierarchyRegistrationOptions(TypedDict):\n    \"\"\"Type hierarchy options used during static or dynamic registration.\n\n    @since 3.17.0\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass TypeHierarchySupertypesParams(TypedDict):\n    \"\"\"The parameter of a `typeHierarchy/supertypes` request.\n\n    @since 3.17.0\"\"\"\n\n    item: \"TypeHierarchyItem\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass TypeHierarchySubtypesParams(TypedDict):\n    \"\"\"The parameter of a `typeHierarchy/subtypes` request.\n\n    @since 3.17.0\"\"\"\n\n    item: \"TypeHierarchyItem\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass InlineValueParams(TypedDict):\n    \"\"\"A parameter literal used in inline value requests.\n\n    @since 3.17.0\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    range: \"Range\"\n    \"\"\" The document range for which inline values should be computed. \"\"\"\n    context: \"InlineValueContext\"\n    \"\"\" Additional information about the context in which inline values were\n    requested. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass InlineValueRegistrationOptions(TypedDict):\n    \"\"\"Inline value options used during static or dynamic registration.\n\n    @since 3.17.0\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass InlayHintParams(TypedDict):\n    \"\"\"A parameter literal used in inlay hint requests.\n\n    @since 3.17.0\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    range: \"Range\"\n    \"\"\" The document range for which inlay hints should be computed. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass InlayHint(TypedDict):\n    \"\"\"Inlay hint information.\n\n    @since 3.17.0\"\"\"\n\n    position: \"Position\"\n    \"\"\" The position of this hint. \"\"\"\n    label: Union[str, List[\"InlayHintLabelPart\"]]\n    \"\"\" The label of this hint. A human readable string or an array of\n    InlayHintLabelPart label parts.\n\n    *Note* that neither the string nor the label part can be empty. \"\"\"\n    kind: NotRequired[\"InlayHintKind\"]\n    \"\"\" The kind of this hint. Can be omitted in which case the client\n    should fall back to a reasonable default. \"\"\"\n    textEdits: NotRequired[List[\"TextEdit\"]]\n    \"\"\" Optional text edits that are performed when accepting this inlay hint.\n\n    *Note* that edits are expected to change the document so that the inlay\n    hint (or its nearest variant) is now part of the document and the inlay\n    hint itself is now obsolete. \"\"\"\n    tooltip: NotRequired[Union[str, \"MarkupContent\"]]\n    \"\"\" The tooltip text when you hover over this item. \"\"\"\n    paddingLeft: NotRequired[bool]\n    \"\"\" Render padding before the hint.\n\n    Note: Padding should use the editor's background color, not the\n    background color of the hint itself. That means padding can be used\n    to visually align/separate an inlay hint. \"\"\"\n    paddingRight: NotRequired[bool]\n    \"\"\" Render padding after the hint.\n\n    Note: Padding should use the editor's background color, not the\n    background color of the hint itself. That means padding can be used\n    to visually align/separate an inlay hint. \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A data entry field that is preserved on an inlay hint between\n    a `textDocument/inlayHint` and a `inlayHint/resolve` request. \"\"\"\n\n\nclass InlayHintRegistrationOptions(TypedDict):\n    \"\"\"Inlay hint options used during static or dynamic registration.\n\n    @since 3.17.0\"\"\"\n\n    resolveProvider: NotRequired[bool]\n    \"\"\" The server provides support to resolve additional\n    information for an inlay hint item. \"\"\"\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass DocumentDiagnosticParams(TypedDict):\n    \"\"\"Parameters of the document diagnostic request.\n\n    @since 3.17.0\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    identifier: NotRequired[str]\n    \"\"\" The additional identifier  provided during registration. \"\"\"\n    previousResultId: NotRequired[str]\n    \"\"\" The result id of a previous response if provided. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass DocumentDiagnosticReportPartialResult(TypedDict):\n    \"\"\"A partial result for a document diagnostic report.\n\n    @since 3.17.0\"\"\"\n\n    relatedDocuments: Dict[\n        \"DocumentUri\",\n        Union[\"FullDocumentDiagnosticReport\", \"UnchangedDocumentDiagnosticReport\"],\n    ]\n\n\nclass DiagnosticServerCancellationData(TypedDict):\n    \"\"\"Cancellation data returned from a diagnostic request.\n\n    @since 3.17.0\"\"\"\n\n    retriggerRequest: bool\n\n\nclass DiagnosticRegistrationOptions(TypedDict):\n    \"\"\"Diagnostic registration options.\n\n    @since 3.17.0\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    identifier: NotRequired[str]\n    \"\"\" An optional identifier under which the diagnostics are\n    managed by the client. \"\"\"\n    interFileDependencies: bool\n    \"\"\" Whether the language has inter file dependencies meaning that\n    editing code in one file can result in a different diagnostic\n    set in another file. Inter file dependencies are common for\n    most programming languages and typically uncommon for linters. \"\"\"\n    workspaceDiagnostics: bool\n    \"\"\" The server provides support for workspace diagnostics as well. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass WorkspaceDiagnosticParams(TypedDict):\n    \"\"\"Parameters of the workspace diagnostic request.\n\n    @since 3.17.0\"\"\"\n\n    identifier: NotRequired[str]\n    \"\"\" The additional identifier provided during registration. \"\"\"\n    previousResultIds: List[\"PreviousResultId\"]\n    \"\"\" The currently known diagnostic reports with their\n    previous result ids. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass WorkspaceDiagnosticReport(TypedDict):\n    \"\"\"A workspace diagnostic report.\n\n    @since 3.17.0\"\"\"\n\n    items: List[\"WorkspaceDocumentDiagnosticReport\"]\n\n\nclass WorkspaceDiagnosticReportPartialResult(TypedDict):\n    \"\"\"A partial result for a workspace diagnostic report.\n\n    @since 3.17.0\"\"\"\n\n    items: List[\"WorkspaceDocumentDiagnosticReport\"]\n\n\nclass DidOpenNotebookDocumentParams(TypedDict):\n    \"\"\"The params sent in an open notebook document notification.\n\n    @since 3.17.0\"\"\"\n\n    notebookDocument: \"NotebookDocument\"\n    \"\"\" The notebook document that got opened. \"\"\"\n    cellTextDocuments: List[\"TextDocumentItem\"]\n    \"\"\" The text documents that represent the content\n    of a notebook cell. \"\"\"\n\n\nclass DidChangeNotebookDocumentParams(TypedDict):\n    \"\"\"The params sent in a change notebook document notification.\n\n    @since 3.17.0\"\"\"\n\n    notebookDocument: \"VersionedNotebookDocumentIdentifier\"\n    \"\"\" The notebook document that did change. The version number points\n    to the version after all provided changes have been applied. If\n    only the text document content of a cell changes the notebook version\n    doesn't necessarily have to change. \"\"\"\n    change: \"NotebookDocumentChangeEvent\"\n    \"\"\" The actual changes to the notebook document.\n\n    The changes describe single state changes to the notebook document.\n    So if there are two changes c1 (at array index 0) and c2 (at array\n    index 1) for a notebook in state S then c1 moves the notebook from\n    S to S' and c2 from S' to S''. So c1 is computed on the state S and\n    c2 is computed on the state S'.\n\n    To mirror the content of a notebook using change events use the following approach:\n    - start with the same initial content\n    - apply the 'notebookDocument/didChange' notifications in the order you receive them.\n    - apply the `NotebookChangeEvent`s in a single notification in the order\n      you receive them. \"\"\"\n\n\nclass DidSaveNotebookDocumentParams(TypedDict):\n    \"\"\"The params sent in a save notebook document notification.\n\n    @since 3.17.0\"\"\"\n\n    notebookDocument: \"NotebookDocumentIdentifier\"\n    \"\"\" The notebook document that got saved. \"\"\"\n\n\nclass DidCloseNotebookDocumentParams(TypedDict):\n    \"\"\"The params sent in a close notebook document notification.\n\n    @since 3.17.0\"\"\"\n\n    notebookDocument: \"NotebookDocumentIdentifier\"\n    \"\"\" The notebook document that got closed. \"\"\"\n    cellTextDocuments: List[\"TextDocumentIdentifier\"]\n    \"\"\" The text documents that represent the content\n    of a notebook cell that got closed. \"\"\"\n\n\nclass RegistrationParams(TypedDict):\n    registrations: List[\"Registration\"]\n\n\nclass UnregistrationParams(TypedDict):\n    unregisterations: List[\"Unregistration\"]\n\n\nclass InitializeParams(TypedDict):\n    processId: Union[int, None]\n    \"\"\" The process Id of the parent process that started\n    the server.\n\n    Is `null` if the process has not been started by another process.\n    If the parent process is not alive then the server should exit. \"\"\"\n    clientInfo: NotRequired[\"___InitializeParams_clientInfo_Type_1\"]\n    \"\"\" Information about the client\n\n    @since 3.15.0 \"\"\"\n    locale: NotRequired[str]\n    \"\"\" The locale the client is currently showing the user interface\n    in. This must not necessarily be the locale of the operating\n    system.\n\n    Uses IETF language tags as the value's syntax\n    (See https://en.wikipedia.org/wiki/IETF_language_tag)\n\n    @since 3.16.0 \"\"\"\n    rootPath: NotRequired[Union[str, None]]\n    \"\"\" The rootPath of the workspace. Is null\n    if no folder is open.\n\n    @deprecated in favour of rootUri. \"\"\"\n    rootUri: Union[\"DocumentUri\", None]\n    \"\"\" The rootUri of the workspace. Is null if no\n    folder is open. If both `rootPath` and `rootUri` are set\n    `rootUri` wins.\n\n    @deprecated in favour of workspaceFolders. \"\"\"\n    capabilities: \"ClientCapabilities\"\n    \"\"\" The capabilities provided by the client (editor or tool) \"\"\"\n    initializationOptions: NotRequired[\"LSPAny\"]\n    \"\"\" User provided initialization options. \"\"\"\n    trace: NotRequired[\"TraceValues\"]\n    \"\"\" The initial trace setting. If omitted trace is disabled ('off'). \"\"\"\n    workspaceFolders: NotRequired[Union[List[\"WorkspaceFolder\"], None]]\n    \"\"\" The workspace folders configured in the client when the server starts.\n\n    This property is only available if the client supports workspace folders.\n    It can be `null` if the client supports workspace folders but none are\n    configured.\n\n    @since 3.6.0 \"\"\"\n\n\nclass InitializeResult(TypedDict):\n    \"\"\"The result returned from an initialize request.\"\"\"\n\n    capabilities: \"ServerCapabilities\"\n    \"\"\" The capabilities the language server provides. \"\"\"\n    serverInfo: NotRequired[\"__InitializeResult_serverInfo_Type_1\"]\n    \"\"\" Information about the server.\n\n    @since 3.15.0 \"\"\"\n\n\nclass InitializeError(TypedDict):\n    \"\"\"The data type of the ResponseError if the\n    initialize request fails.\"\"\"\n\n    retry: bool\n    \"\"\" Indicates whether the client execute the following retry logic:\n    (1) show the message provided by the ResponseError to the user\n    (2) user selects retry or cancel\n    (3) if user selected retry the initialize method is sent again. \"\"\"\n\n\nclass InitializedParams(TypedDict):\n    pass\n\n\nclass DidChangeConfigurationParams(TypedDict):\n    \"\"\"The parameters of a change configuration notification.\"\"\"\n\n    settings: \"LSPAny\"\n    \"\"\" The actual changed settings \"\"\"\n\n\nclass DidChangeConfigurationRegistrationOptions(TypedDict):\n    section: NotRequired[Union[str, List[str]]]\n\n\nclass ShowMessageParams(TypedDict):\n    \"\"\"The parameters of a notification message.\"\"\"\n\n    type: \"MessageType\"\n    \"\"\" The message type. See {@link MessageType} \"\"\"\n    message: str\n    \"\"\" The actual message. \"\"\"\n\n\nclass ShowMessageRequestParams(TypedDict):\n    type: \"MessageType\"\n    \"\"\" The message type. See {@link MessageType} \"\"\"\n    message: str\n    \"\"\" The actual message. \"\"\"\n    actions: NotRequired[List[\"MessageActionItem\"]]\n    \"\"\" The message action items to present. \"\"\"\n\n\nclass MessageActionItem(TypedDict):\n    title: str\n    \"\"\" A short title like 'Retry', 'Open Log' etc. \"\"\"\n\n\nclass LogMessageParams(TypedDict):\n    \"\"\"The log message parameters.\"\"\"\n\n    type: \"MessageType\"\n    \"\"\" The message type. See {@link MessageType} \"\"\"\n    message: str\n    \"\"\" The actual message. \"\"\"\n\n\nclass DidOpenTextDocumentParams(TypedDict):\n    \"\"\"The parameters sent in an open text document notification\"\"\"\n\n    textDocument: \"TextDocumentItem\"\n    \"\"\" The document that was opened. \"\"\"\n\n\nclass DidChangeTextDocumentParams(TypedDict):\n    \"\"\"The change text document notification's parameters.\"\"\"\n\n    textDocument: \"VersionedTextDocumentIdentifier\"\n    \"\"\" The document that did change. The version number points\n    to the version after all provided content changes have\n    been applied. \"\"\"\n    contentChanges: List[\"TextDocumentContentChangeEvent\"]\n    \"\"\" The actual content changes. The content changes describe single state changes\n    to the document. So if there are two content changes c1 (at array index 0) and\n    c2 (at array index 1) for a document in state S then c1 moves the document from\n    S to S' and c2 from S' to S''. So c1 is computed on the state S and c2 is computed\n    on the state S'.\n\n    To mirror the content of a document using change events use the following approach:\n    - start with the same initial content\n    - apply the 'textDocument/didChange' notifications in the order you receive them.\n    - apply the `TextDocumentContentChangeEvent`s in a single notification in the order\n      you receive them. \"\"\"\n\n\nclass TextDocumentChangeRegistrationOptions(TypedDict):\n    \"\"\"Describe options to be used when registered for text document change events.\"\"\"\n\n    syncKind: \"TextDocumentSyncKind\"\n    \"\"\" How documents are synced to the server. \"\"\"\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n\n\nclass DidCloseTextDocumentParams(TypedDict):\n    \"\"\"The parameters sent in a close text document notification\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document that was closed. \"\"\"\n\n\nclass DidSaveTextDocumentParams(TypedDict):\n    \"\"\"The parameters sent in a save text document notification\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document that was saved. \"\"\"\n    text: NotRequired[str]\n    \"\"\" Optional the content when saved. Depends on the includeText value\n    when the save notification was requested. \"\"\"\n\n\nclass TextDocumentSaveRegistrationOptions(TypedDict):\n    \"\"\"Save registration options.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    includeText: NotRequired[bool]\n    \"\"\" The client is supposed to include the content on save. \"\"\"\n\n\nclass WillSaveTextDocumentParams(TypedDict):\n    \"\"\"The parameters sent in a will save text document notification.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document that will be saved. \"\"\"\n    reason: \"TextDocumentSaveReason\"\n    \"\"\" The 'TextDocumentSaveReason'. \"\"\"\n\n\nclass TextEdit(TypedDict):\n    \"\"\"A text edit applicable to a text document.\"\"\"\n\n    range: \"Range\"\n    \"\"\" The range of the text document to be manipulated. To insert\n    text into a document create a range where start === end. \"\"\"\n    newText: str\n    \"\"\" The string to be inserted. For delete operations use an\n    empty string. \"\"\"\n\n\nclass DidChangeWatchedFilesParams(TypedDict):\n    \"\"\"The watched files change notification's parameters.\"\"\"\n\n    changes: List[\"FileEvent\"]\n    \"\"\" The actual file events. \"\"\"\n\n\nclass DidChangeWatchedFilesRegistrationOptions(TypedDict):\n    \"\"\"Describe options to be used when registered for text document change events.\"\"\"\n\n    watchers: List[\"FileSystemWatcher\"]\n    \"\"\" The watchers to register. \"\"\"\n\n\nclass PublishDiagnosticsParams(TypedDict):\n    \"\"\"The publish diagnostic notification's parameters.\"\"\"\n\n    uri: \"DocumentUri\"\n    \"\"\" The URI for which diagnostic information is reported. \"\"\"\n    version: NotRequired[int]\n    \"\"\" Optional the version number of the document the diagnostics are published for.\n\n    @since 3.15.0 \"\"\"\n    diagnostics: List[\"Diagnostic\"]\n    \"\"\" An array of diagnostic information items. \"\"\"\n\n\nclass CompletionParams(TypedDict):\n    \"\"\"Completion parameters\"\"\"\n\n    context: NotRequired[\"CompletionContext\"]\n    \"\"\" The completion context. This is only available it the client specifies\n    to send this using the client capability `textDocument.completion.contextSupport === true` \"\"\"\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass CompletionItem(TypedDict):\n    \"\"\"A completion item represents a text snippet that is\n    proposed to complete text that is being typed.\"\"\"\n\n    label: str\n    \"\"\" The label of this completion item.\n\n    The label property is also by default the text that\n    is inserted when selecting this completion.\n\n    If label details are provided the label itself should\n    be an unqualified name of the completion item. \"\"\"\n    labelDetails: NotRequired[\"CompletionItemLabelDetails\"]\n    \"\"\" Additional details for the label\n\n    @since 3.17.0 \"\"\"\n    kind: NotRequired[\"CompletionItemKind\"]\n    \"\"\" The kind of this completion item. Based of the kind\n    an icon is chosen by the editor. \"\"\"\n    tags: NotRequired[List[\"CompletionItemTag\"]]\n    \"\"\" Tags for this completion item.\n\n    @since 3.15.0 \"\"\"\n    detail: NotRequired[str]\n    \"\"\" A human-readable string with additional information\n    about this item, like type or symbol information. \"\"\"\n    documentation: NotRequired[Union[str, \"MarkupContent\"]]\n    \"\"\" A human-readable string that represents a doc-comment. \"\"\"\n    deprecated: NotRequired[bool]\n    \"\"\" Indicates if this item is deprecated.\n    @deprecated Use `tags` instead. \"\"\"\n    preselect: NotRequired[bool]\n    \"\"\" Select this item when showing.\n\n    *Note* that only one completion item can be selected and that the\n    tool / client decides which item that is. The rule is that the *first*\n    item of those that match best is selected. \"\"\"\n    sortText: NotRequired[str]\n    \"\"\" A string that should be used when comparing this item\n    with other items. When `falsy` the {@link CompletionItem.label label}\n    is used. \"\"\"\n    filterText: NotRequired[str]\n    \"\"\" A string that should be used when filtering a set of\n    completion items. When `falsy` the {@link CompletionItem.label label}\n    is used. \"\"\"\n    insertText: NotRequired[str]\n    \"\"\" A string that should be inserted into a document when selecting\n    this completion. When `falsy` the {@link CompletionItem.label label}\n    is used.\n\n    The `insertText` is subject to interpretation by the client side.\n    Some tools might not take the string literally. For example\n    VS Code when code complete is requested in this example\n    `con<cursor position>` and a completion item with an `insertText` of\n    `console` is provided it will only insert `sole`. Therefore it is\n    recommended to use `textEdit` instead since it avoids additional client\n    side interpretation. \"\"\"\n    insertTextFormat: NotRequired[\"InsertTextFormat\"]\n    \"\"\" The format of the insert text. The format applies to both the\n    `insertText` property and the `newText` property of a provided\n    `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.\n\n    Please note that the insertTextFormat doesn't apply to\n    `additionalTextEdits`. \"\"\"\n    insertTextMode: NotRequired[\"InsertTextMode\"]\n    \"\"\" How whitespace and indentation is handled during completion\n    item insertion. If not provided the clients default value depends on\n    the `textDocument.completion.insertTextMode` client capability.\n\n    @since 3.16.0 \"\"\"\n    textEdit: NotRequired[Union[\"TextEdit\", \"InsertReplaceEdit\"]]\n    \"\"\" An {@link TextEdit edit} which is applied to a document when selecting\n    this completion. When an edit is provided the value of\n    {@link CompletionItem.insertText insertText} is ignored.\n\n    Most editors support two different operations when accepting a completion\n    item. One is to insert a completion text and the other is to replace an\n    existing text with a completion text. Since this can usually not be\n    predetermined by a server it can report both ranges. Clients need to\n    signal support for `InsertReplaceEdits` via the\n    `textDocument.completion.insertReplaceSupport` client capability\n    property.\n\n    *Note 1:* The text edit's range as well as both ranges from an insert\n    replace edit must be a [single line] and they must contain the position\n    at which completion has been requested.\n    *Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range\n    must be a prefix of the edit's replace range, that means it must be\n    contained and starting at the same position.\n\n    @since 3.16.0 additional type `InsertReplaceEdit` \"\"\"\n    textEditText: NotRequired[str]\n    \"\"\" The edit text used if the completion item is part of a CompletionList and\n    CompletionList defines an item default for the text edit range.\n\n    Clients will only honor this property if they opt into completion list\n    item defaults using the capability `completionList.itemDefaults`.\n\n    If not provided and a list's default range is provided the label\n    property is used as a text.\n\n    @since 3.17.0 \"\"\"\n    additionalTextEdits: NotRequired[List[\"TextEdit\"]]\n    \"\"\" An optional array of additional {@link TextEdit text edits} that are applied when\n    selecting this completion. Edits must not overlap (including the same insert position)\n    with the main {@link CompletionItem.textEdit edit} nor with themselves.\n\n    Additional text edits should be used to change text unrelated to the current cursor position\n    (for example adding an import statement at the top of the file if the completion item will\n    insert an unqualified type). \"\"\"\n    commitCharacters: NotRequired[List[str]]\n    \"\"\" An optional set of characters that when pressed while this completion is active will accept it first and\n    then type that character. *Note* that all commit characters should have `length=1` and that superfluous\n    characters will be ignored. \"\"\"\n    command: NotRequired[\"Command\"]\n    \"\"\" An optional {@link Command command} that is executed *after* inserting this completion. *Note* that\n    additional modifications to the current document should be described with the\n    {@link CompletionItem.additionalTextEdits additionalTextEdits}-property. \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A data entry field that is preserved on a completion item between a\n    {@link CompletionRequest} and a {@link CompletionResolveRequest}. \"\"\"\n\n\nclass CompletionList(TypedDict):\n    \"\"\"Represents a collection of {@link CompletionItem completion items} to be presented\n    in the editor.\"\"\"\n\n    isIncomplete: bool\n    \"\"\" This list it not complete. Further typing results in recomputing this list.\n\n    Recomputed lists have all their items replaced (not appended) in the\n    incomplete completion sessions. \"\"\"\n    itemDefaults: NotRequired[\"__CompletionList_itemDefaults_Type_1\"]\n    \"\"\" In many cases the items of an actual completion result share the same\n    value for properties like `commitCharacters` or the range of a text\n    edit. A completion list can therefore define item defaults which will\n    be used if a completion item itself doesn't specify the value.\n\n    If a completion list specifies a default value and a completion item\n    also specifies a corresponding value the one from the item is used.\n\n    Servers are only allowed to return default values if the client\n    signals support for this via the `completionList.itemDefaults`\n    capability.\n\n    @since 3.17.0 \"\"\"\n    items: List[\"CompletionItem\"]\n    \"\"\" The completion items. \"\"\"\n\n\nclass CompletionRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link CompletionRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    triggerCharacters: NotRequired[List[str]]\n    \"\"\" Most tools trigger completion request automatically without explicitly requesting\n    it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user\n    starts to type an identifier. For example if the user types `c` in a JavaScript file\n    code complete will automatically pop up present `console` besides others as a\n    completion item. Characters that make up identifiers don't need to be listed here.\n\n    If code complete should automatically be trigger on characters not being valid inside\n    an identifier (for example `.` in JavaScript) list them in `triggerCharacters`. \"\"\"\n    allCommitCharacters: NotRequired[List[str]]\n    \"\"\" The list of all possible characters that commit a completion. This field can be used\n    if clients don't support individual commit characters per completion item. See\n    `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`\n\n    If a server provides both `allCommitCharacters` and commit characters on an individual\n    completion item the ones on the completion item win.\n\n    @since 3.2.0 \"\"\"\n    resolveProvider: NotRequired[bool]\n    \"\"\" The server provides support to resolve additional\n    information for a completion item. \"\"\"\n    completionItem: NotRequired[\"__CompletionOptions_completionItem_Type_1\"]\n    \"\"\" The server supports the following `CompletionItem` specific\n    capabilities.\n\n    @since 3.17.0 \"\"\"\n\n\nclass HoverParams(TypedDict):\n    \"\"\"Parameters for a {@link HoverRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass Hover(TypedDict):\n    \"\"\"The result of a hover request.\"\"\"\n\n    contents: Union[\"MarkupContent\", \"MarkedString\", List[\"MarkedString\"]]\n    \"\"\" The hover's content \"\"\"\n    range: NotRequired[\"Range\"]\n    \"\"\" An optional range inside the text document that is used to\n    visualize the hover, e.g. by changing the background color. \"\"\"\n\n\nclass HoverRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link HoverRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n\n\nclass SignatureHelpParams(TypedDict):\n    \"\"\"Parameters for a {@link SignatureHelpRequest}.\"\"\"\n\n    context: NotRequired[\"SignatureHelpContext\"]\n    \"\"\" The signature help context. This is only available if the client specifies\n    to send this using the client capability `textDocument.signatureHelp.contextSupport === true`\n\n    @since 3.15.0 \"\"\"\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass SignatureHelp(TypedDict):\n    \"\"\"Signature help represents the signature of something\n    callable. There can be multiple signature but only one\n    active and only one active parameter.\"\"\"\n\n    signatures: List[\"SignatureInformation\"]\n    \"\"\" One or more signatures. \"\"\"\n    activeSignature: NotRequired[Uint]\n    \"\"\" The active signature. If omitted or the value lies outside the\n    range of `signatures` the value defaults to zero or is ignored if\n    the `SignatureHelp` has no signatures.\n\n    Whenever possible implementors should make an active decision about\n    the active signature and shouldn't rely on a default value.\n\n    In future version of the protocol this property might become\n    mandatory to better express this. \"\"\"\n    activeParameter: NotRequired[Uint]\n    \"\"\" The active parameter of the active signature. If omitted or the value\n    lies outside the range of `signatures[activeSignature].parameters`\n    defaults to 0 if the active signature has parameters. If\n    the active signature has no parameters it is ignored.\n    In future version of the protocol this property might become\n    mandatory to better express the active parameter if the\n    active signature does have any. \"\"\"\n\n\nclass SignatureHelpRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link SignatureHelpRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    triggerCharacters: NotRequired[List[str]]\n    \"\"\" List of characters that trigger signature help automatically. \"\"\"\n    retriggerCharacters: NotRequired[List[str]]\n    \"\"\" List of characters that re-trigger signature help.\n\n    These trigger characters are only active when signature help is already showing. All trigger characters\n    are also counted as re-trigger characters.\n\n    @since 3.15.0 \"\"\"\n\n\nclass DefinitionParams(TypedDict):\n    \"\"\"Parameters for a {@link DefinitionRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass DefinitionRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link DefinitionRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n\n\nclass ReferenceParams(TypedDict):\n    \"\"\"Parameters for a {@link ReferencesRequest}.\"\"\"\n\n    context: \"ReferenceContext\"\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass ReferenceRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link ReferencesRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n\n\nclass DocumentHighlightParams(TypedDict):\n    \"\"\"Parameters for a {@link DocumentHighlightRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass DocumentHighlight(TypedDict):\n    \"\"\"A document highlight is a range inside a text document which deserves\n    special attention. Usually a document highlight is visualized by changing\n    the background color of its range.\"\"\"\n\n    range: \"Range\"\n    \"\"\" The range this highlight applies to. \"\"\"\n    kind: NotRequired[\"DocumentHighlightKind\"]\n    \"\"\" The highlight kind, default is {@link DocumentHighlightKind.Text text}. \"\"\"\n\n\nclass DocumentHighlightRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link DocumentHighlightRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n\n\nclass DocumentSymbolParams(TypedDict):\n    \"\"\"Parameters for a {@link DocumentSymbolRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass SymbolInformation(TypedDict):\n    \"\"\"Represents information about programming constructs like variables, classes,\n    interfaces etc.\"\"\"\n\n    deprecated: NotRequired[bool]\n    \"\"\" Indicates if this symbol is deprecated.\n\n    @deprecated Use tags instead \"\"\"\n    location: \"Location\"\n    \"\"\" The location of this symbol. The location's range is used by a tool\n    to reveal the location in the editor. If the symbol is selected in the\n    tool the range's start information is used to position the cursor. So\n    the range usually spans more than the actual symbol's name and does\n    normally include things like visibility modifiers.\n\n    The range doesn't have to denote a node range in the sense of an abstract\n    syntax tree. It can therefore not be used to re-construct a hierarchy of\n    the symbols. \"\"\"\n    name: str\n    \"\"\" The name of this symbol. \"\"\"\n    kind: \"SymbolKind\"\n    \"\"\" The kind of this symbol. \"\"\"\n    tags: NotRequired[List[\"SymbolTag\"]]\n    \"\"\" Tags for this symbol.\n\n    @since 3.16.0 \"\"\"\n    containerName: NotRequired[str]\n    \"\"\" The name of the symbol containing this symbol. This information is for\n    user interface purposes (e.g. to render a qualifier in the user interface\n    if necessary). It can't be used to re-infer a hierarchy for the document\n    symbols. \"\"\"\n\n\nclass DocumentSymbol(TypedDict):\n    \"\"\"Represents programming constructs like variables, classes, interfaces etc.\n    that appear in a document. Document symbols can be hierarchical and they\n    have two ranges: one that encloses its definition and one that points to\n    its most interesting range, e.g. the range of an identifier.\"\"\"\n\n    name: str\n    \"\"\" The name of this symbol. Will be displayed in the user interface and therefore must not be\n    an empty string or a string only consisting of white spaces. \"\"\"\n    detail: NotRequired[str]\n    \"\"\" More detail for this symbol, e.g the signature of a function. \"\"\"\n    kind: \"SymbolKind\"\n    \"\"\" The kind of this symbol. \"\"\"\n    tags: NotRequired[List[\"SymbolTag\"]]\n    \"\"\" Tags for this document symbol.\n\n    @since 3.16.0 \"\"\"\n    deprecated: NotRequired[bool]\n    \"\"\" Indicates if this symbol is deprecated.\n\n    @deprecated Use tags instead \"\"\"\n    range: \"Range\"\n    \"\"\" The range enclosing this symbol not including leading/trailing whitespace but everything else\n    like comments. This information is typically used to determine if the clients cursor is\n    inside the symbol to reveal in the symbol in the UI. \"\"\"\n    selectionRange: \"Range\"\n    \"\"\" The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.\n    Must be contained by the `range`. \"\"\"\n    children: NotRequired[List[\"DocumentSymbol\"]]\n    \"\"\" Children of this symbol, e.g. properties of a class. \"\"\"\n\n\nclass DocumentSymbolRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link DocumentSymbolRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    label: NotRequired[str]\n    \"\"\" A human-readable string that is shown when multiple outlines trees\n    are shown for the same document.\n\n    @since 3.16.0 \"\"\"\n\n\nclass CodeActionParams(TypedDict):\n    \"\"\"The parameters of a {@link CodeActionRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document in which the command was invoked. \"\"\"\n    range: \"Range\"\n    \"\"\" The range for which the command was invoked. \"\"\"\n    context: \"CodeActionContext\"\n    \"\"\" Context carrying additional information. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass Command(TypedDict):\n    \"\"\"Represents a reference to a command. Provides a title which\n    will be used to represent a command in the UI and, optionally,\n    an array of arguments which will be passed to the command handler\n    function when invoked.\"\"\"\n\n    title: str\n    \"\"\" Title of the command, like `save`. \"\"\"\n    command: str\n    \"\"\" The identifier of the actual command handler. \"\"\"\n    arguments: NotRequired[List[\"LSPAny\"]]\n    \"\"\" Arguments that the command handler should be\n    invoked with. \"\"\"\n\n\nclass CodeAction(TypedDict):\n    \"\"\"A code action represents a change that can be performed in code, e.g. to fix a problem or\n    to refactor code.\n\n    A CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.\n    \"\"\"\n\n    title: str\n    \"\"\" A short, human-readable, title for this code action. \"\"\"\n    kind: NotRequired[\"CodeActionKind\"]\n    \"\"\" The kind of the code action.\n\n    Used to filter code actions. \"\"\"\n    diagnostics: NotRequired[List[\"Diagnostic\"]]\n    \"\"\" The diagnostics that this code action resolves. \"\"\"\n    isPreferred: NotRequired[bool]\n    \"\"\" Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted\n    by keybindings.\n\n    A quick fix should be marked preferred if it properly addresses the underlying error.\n    A refactoring should be marked preferred if it is the most reasonable choice of actions to take.\n\n    @since 3.15.0 \"\"\"\n    disabled: NotRequired[\"__CodeAction_disabled_Type_1\"]\n    \"\"\" Marks that the code action cannot currently be applied.\n\n    Clients should follow the following guidelines regarding disabled code actions:\n\n      - Disabled code actions are not shown in automatic [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)\n        code action menus.\n\n      - Disabled actions are shown as faded out in the code action menu when the user requests a more specific type\n        of code action, such as refactorings.\n\n      - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)\n        that auto applies a code action and only disabled code actions are returned, the client should show the user an\n        error message with `reason` in the editor.\n\n    @since 3.16.0 \"\"\"\n    edit: NotRequired[\"WorkspaceEdit\"]\n    \"\"\" The workspace edit this code action performs. \"\"\"\n    command: NotRequired[\"Command\"]\n    \"\"\" A command this code action executes. If a code action\n    provides an edit and a command, first the edit is\n    executed and then the command. \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A data entry field that is preserved on a code action between\n    a `textDocument/codeAction` and a `codeAction/resolve` request.\n\n    @since 3.16.0 \"\"\"\n\n\nclass CodeActionRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link CodeActionRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    codeActionKinds: NotRequired[List[\"CodeActionKind\"]]\n    \"\"\" CodeActionKinds that this server may return.\n\n    The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server\n    may list out every specific kind they provide. \"\"\"\n    resolveProvider: NotRequired[bool]\n    \"\"\" The server provides support to resolve additional\n    information for a code action.\n\n    @since 3.16.0 \"\"\"\n\n\nclass WorkspaceSymbolParams(TypedDict):\n    \"\"\"The parameters of a {@link WorkspaceSymbolRequest}.\"\"\"\n\n    query: str\n    \"\"\" A query string to filter symbols by. Clients may send an empty\n    string here to request all symbols. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass WorkspaceSymbol(TypedDict):\n    \"\"\"A special workspace symbol that supports locations without a range.\n\n    See also SymbolInformation.\n\n    @since 3.17.0\"\"\"\n\n    location: Union[\"Location\", \"__WorkspaceSymbol_location_Type_1\"]\n    \"\"\" The location of the symbol. Whether a server is allowed to\n    return a location without a range depends on the client\n    capability `workspace.symbol.resolveSupport`.\n\n    See SymbolInformation#location for more details. \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A data entry field that is preserved on a workspace symbol between a\n    workspace symbol request and a workspace symbol resolve request. \"\"\"\n    name: str\n    \"\"\" The name of this symbol. \"\"\"\n    kind: \"SymbolKind\"\n    \"\"\" The kind of this symbol. \"\"\"\n    tags: NotRequired[List[\"SymbolTag\"]]\n    \"\"\" Tags for this symbol.\n\n    @since 3.16.0 \"\"\"\n    containerName: NotRequired[str]\n    \"\"\" The name of the symbol containing this symbol. This information is for\n    user interface purposes (e.g. to render a qualifier in the user interface\n    if necessary). It can't be used to re-infer a hierarchy for the document\n    symbols. \"\"\"\n\n\nclass WorkspaceSymbolRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link WorkspaceSymbolRequest}.\"\"\"\n\n    resolveProvider: NotRequired[bool]\n    \"\"\" The server provides support to resolve additional\n    information for a workspace symbol.\n\n    @since 3.17.0 \"\"\"\n\n\nclass CodeLensParams(TypedDict):\n    \"\"\"The parameters of a {@link CodeLensRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document to request code lens for. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass CodeLens(TypedDict):\n    \"\"\"A code lens represents a {@link Command command} that should be shown along with\n    source text, like the number of references, a way to run tests, etc.\n\n    A code lens is _unresolved_ when no command is associated to it. For performance\n    reasons the creation of a code lens and resolving should be done in two stages.\"\"\"\n\n    range: \"Range\"\n    \"\"\" The range in which this code lens is valid. Should only span a single line. \"\"\"\n    command: NotRequired[\"Command\"]\n    \"\"\" The command this code lens represents. \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A data entry field that is preserved on a code lens item between\n    a {@link CodeLensRequest} and a [CodeLensResolveRequest]\n    (#CodeLensResolveRequest) \"\"\"\n\n\nclass CodeLensRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link CodeLensRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    resolveProvider: NotRequired[bool]\n    \"\"\" Code lens has a resolve provider as well. \"\"\"\n\n\nclass DocumentLinkParams(TypedDict):\n    \"\"\"The parameters of a {@link DocumentLinkRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document to provide document links for. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass DocumentLink(TypedDict):\n    \"\"\"A document link is a range in a text document that links to an internal or external resource, like another\n    text document or a web site.\"\"\"\n\n    range: \"Range\"\n    \"\"\" The range this link applies to. \"\"\"\n    target: NotRequired[str]\n    \"\"\" The uri this link points to. If missing a resolve request is sent later. \"\"\"\n    tooltip: NotRequired[str]\n    \"\"\" The tooltip text when you hover over this link.\n\n    If a tooltip is provided, is will be displayed in a string that includes instructions on how to\n    trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,\n    user settings, and localization.\n\n    @since 3.15.0 \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A data entry field that is preserved on a document link between a\n    DocumentLinkRequest and a DocumentLinkResolveRequest. \"\"\"\n\n\nclass DocumentLinkRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link DocumentLinkRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    resolveProvider: NotRequired[bool]\n    \"\"\" Document links have a resolve provider as well. \"\"\"\n\n\nclass DocumentFormattingParams(TypedDict):\n    \"\"\"The parameters of a {@link DocumentFormattingRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document to format. \"\"\"\n    options: \"FormattingOptions\"\n    \"\"\" The format options. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass DocumentFormattingRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link DocumentFormattingRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n\n\nclass DocumentRangeFormattingParams(TypedDict):\n    \"\"\"The parameters of a {@link DocumentRangeFormattingRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document to format. \"\"\"\n    range: \"Range\"\n    \"\"\" The range to format \"\"\"\n    options: \"FormattingOptions\"\n    \"\"\" The format options \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass DocumentRangeFormattingRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link DocumentRangeFormattingRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n\n\nclass DocumentOnTypeFormattingParams(TypedDict):\n    \"\"\"The parameters of a {@link DocumentOnTypeFormattingRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document to format. \"\"\"\n    position: \"Position\"\n    \"\"\" The position around which the on type formatting should happen.\n    This is not necessarily the exact position where the character denoted\n    by the property `ch` got typed. \"\"\"\n    ch: str\n    \"\"\" The character that has been typed that triggered the formatting\n    on type request. That is not necessarily the last character that\n    got inserted into the document since the client could auto insert\n    characters as well (e.g. like automatic brace completion). \"\"\"\n    options: \"FormattingOptions\"\n    \"\"\" The formatting options. \"\"\"\n\n\nclass DocumentOnTypeFormattingRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link DocumentOnTypeFormattingRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    firstTriggerCharacter: str\n    \"\"\" A character on which formatting should be triggered, like `{`. \"\"\"\n    moreTriggerCharacter: NotRequired[List[str]]\n    \"\"\" More trigger characters. \"\"\"\n\n\nclass RenameParams(TypedDict):\n    \"\"\"The parameters of a {@link RenameRequest}.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The document to rename. \"\"\"\n    position: \"Position\"\n    \"\"\" The position at which this request was sent. \"\"\"\n    newName: str\n    \"\"\" The new name of the symbol. If the given name is not valid the\n    request must return a {@link ResponseError} with an\n    appropriate message set. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass RenameRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link RenameRequest}.\"\"\"\n\n    documentSelector: Union[\"DocumentSelector\", None]\n    \"\"\" A document selector to identify the scope of the registration. If set to null\n    the document selector provided on the client side will be used. \"\"\"\n    prepareProvider: NotRequired[bool]\n    \"\"\" Renames should be checked and tested before being executed.\n\n    @since version 3.12.0 \"\"\"\n\n\nclass PrepareRenameParams(TypedDict):\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass ExecuteCommandParams(TypedDict):\n    \"\"\"The parameters of a {@link ExecuteCommandRequest}.\"\"\"\n\n    command: str\n    \"\"\" The identifier of the actual command handler. \"\"\"\n    arguments: NotRequired[List[\"LSPAny\"]]\n    \"\"\" Arguments that the command should be invoked with. \"\"\"\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass ExecuteCommandRegistrationOptions(TypedDict):\n    \"\"\"Registration options for a {@link ExecuteCommandRequest}.\"\"\"\n\n    commands: List[str]\n    \"\"\" The commands to be executed on the server \"\"\"\n\n\nclass ApplyWorkspaceEditParams(TypedDict):\n    \"\"\"The parameters passed via a apply workspace edit request.\"\"\"\n\n    label: NotRequired[str]\n    \"\"\" An optional label of the workspace edit. This label is\n    presented in the user interface for example on an undo\n    stack to undo the workspace edit. \"\"\"\n    edit: \"WorkspaceEdit\"\n    \"\"\" The edits to apply. \"\"\"\n\n\nclass ApplyWorkspaceEditResult(TypedDict):\n    \"\"\"The result returned from the apply workspace edit request.\n\n    @since 3.17 renamed from ApplyWorkspaceEditResponse\"\"\"\n\n    applied: bool\n    \"\"\" Indicates whether the edit was applied or not. \"\"\"\n    failureReason: NotRequired[str]\n    \"\"\" An optional textual description for why the edit was not applied.\n    This may be used by the server for diagnostic logging or to provide\n    a suitable error for a request that triggered the edit. \"\"\"\n    failedChange: NotRequired[Uint]\n    \"\"\" Depending on the client's failure handling strategy `failedChange` might\n    contain the index of the change that failed. This property is only available\n    if the client signals a `failureHandlingStrategy` in its client capabilities. \"\"\"\n\n\nclass WorkDoneProgressBegin(TypedDict):\n    kind: Literal[\"begin\"]\n    title: str\n    \"\"\" Mandatory title of the progress operation. Used to briefly inform about\n    the kind of operation being performed.\n\n    Examples: \"Indexing\" or \"Linking dependencies\". \"\"\"\n    cancellable: NotRequired[bool]\n    \"\"\" Controls if a cancel button should show to allow the user to cancel the\n    long running operation. Clients that don't support cancellation are allowed\n    to ignore the setting. \"\"\"\n    message: NotRequired[str]\n    \"\"\" Optional, more detailed associated progress message. Contains\n    complementary information to the `title`.\n\n    Examples: \"3/25 files\", \"project/src/module2\", \"node_modules/some_dep\".\n    If unset, the previous progress message (if any) is still valid. \"\"\"\n    percentage: NotRequired[Uint]\n    \"\"\" Optional progress percentage to display (value 100 is considered 100%).\n    If not provided infinite progress is assumed and clients are allowed\n    to ignore the `percentage` value in subsequent in report notifications.\n\n    The value should be steadily rising. Clients are free to ignore values\n    that are not following this rule. The value range is [0, 100]. \"\"\"\n\n\nclass WorkDoneProgressReport(TypedDict):\n    kind: Literal[\"report\"]\n    cancellable: NotRequired[bool]\n    \"\"\" Controls enablement state of a cancel button.\n\n    Clients that don't support cancellation or don't support controlling the button's\n    enablement state are allowed to ignore the property. \"\"\"\n    message: NotRequired[str]\n    \"\"\" Optional, more detailed associated progress message. Contains\n    complementary information to the `title`.\n\n    Examples: \"3/25 files\", \"project/src/module2\", \"node_modules/some_dep\".\n    If unset, the previous progress message (if any) is still valid. \"\"\"\n    percentage: NotRequired[Uint]\n    \"\"\" Optional progress percentage to display (value 100 is considered 100%).\n    If not provided infinite progress is assumed and clients are allowed\n    to ignore the `percentage` value in subsequent in report notifications.\n\n    The value should be steadily rising. Clients are free to ignore values\n    that are not following this rule. The value range is [0, 100] \"\"\"\n\n\nclass WorkDoneProgressEnd(TypedDict):\n    kind: Literal[\"end\"]\n    message: NotRequired[str]\n    \"\"\" Optional, a final message indicating to for example indicate the outcome\n    of the operation. \"\"\"\n\n\nclass SetTraceParams(TypedDict):\n    value: \"TraceValues\"\n\n\nclass LogTraceParams(TypedDict):\n    message: str\n    verbose: NotRequired[str]\n\n\nclass CancelParams(TypedDict):\n    id: Union[int, str]\n    \"\"\" The request id to cancel. \"\"\"\n\n\nclass ProgressParams(TypedDict):\n    token: \"ProgressToken\"\n    \"\"\" The progress token provided by the client or server. \"\"\"\n    value: \"LSPAny\"\n    \"\"\" The progress data. \"\"\"\n\n\nclass TextDocumentPositionParams(TypedDict):\n    \"\"\"A parameter literal used in requests to pass a text document and a position inside that\n    document.\"\"\"\n\n    textDocument: \"TextDocumentIdentifier\"\n    \"\"\" The text document. \"\"\"\n    position: \"Position\"\n    \"\"\" The position inside the text document. \"\"\"\n\n\nclass WorkDoneProgressParams(TypedDict):\n    workDoneToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report work done progress. \"\"\"\n\n\nclass PartialResultParams(TypedDict):\n    partialResultToken: NotRequired[\"ProgressToken\"]\n    \"\"\" An optional token that a server can use to report partial results (e.g. streaming) to\n    the client. \"\"\"\n\n\nclass LocationLink(TypedDict):\n    \"\"\"Represents the connection of two locations. Provides additional metadata over normal {@link Location locations},\n    including an origin range.\"\"\"\n\n    originSelectionRange: NotRequired[\"Range\"]\n    \"\"\" Span of the origin of this link.\n\n    Used as the underlined span for mouse interaction. Defaults to the word range at\n    the definition position. \"\"\"\n    targetUri: \"DocumentUri\"\n    \"\"\" The target resource identifier of this link. \"\"\"\n    targetRange: \"Range\"\n    \"\"\" The full target range of this link. If the target for example is a symbol then target range is the\n    range enclosing this symbol not including leading/trailing whitespace but everything else\n    like comments. This information is typically used to highlight the range in the editor. \"\"\"\n    targetSelectionRange: \"Range\"\n    \"\"\" The range that should be selected and revealed when this link is being followed, e.g the name of a function.\n    Must be contained by the `targetRange`. See also `DocumentSymbol#range` \"\"\"\n\n\nclass Range(TypedDict):\n    \"\"\"A range in a text document expressed as (zero-based) start and end positions.\n\n    If you want to specify a range that contains a line including the line ending\n    character(s) then use an end position denoting the start of the next line.\n    For example:\n    ```ts\n    {\n        start: { line: 5, character: 23 }\n        end : { line 6, character : 0 }\n    }\n    ```\"\"\"\n\n    start: \"Position\"\n    \"\"\" The range's start position. \"\"\"\n    end: \"Position\"\n    \"\"\" The range's end position. \"\"\"\n\n\nclass ImplementationOptions(TypedDict):\n    workDoneProgress: NotRequired[bool]\n\n\nclass StaticRegistrationOptions(TypedDict):\n    \"\"\"Static registration options to be returned in the initialize\n    request.\"\"\"\n\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass TypeDefinitionOptions(TypedDict):\n    workDoneProgress: NotRequired[bool]\n\n\nclass WorkspaceFoldersChangeEvent(TypedDict):\n    \"\"\"The workspace folder change event.\"\"\"\n\n    added: List[\"WorkspaceFolder\"]\n    \"\"\" The array of added workspace folders \"\"\"\n    removed: List[\"WorkspaceFolder\"]\n    \"\"\" The array of the removed workspace folders \"\"\"\n\n\nclass ConfigurationItem(TypedDict):\n    scopeUri: NotRequired[str]\n    \"\"\" The scope to get the configuration section for. \"\"\"\n    section: NotRequired[str]\n    \"\"\" The configuration section asked for. \"\"\"\n\n\nclass TextDocumentIdentifier(TypedDict):\n    \"\"\"A literal to identify a text document in the client.\"\"\"\n\n    uri: \"DocumentUri\"\n    \"\"\" The text document's uri. \"\"\"\n\n\nclass Color(TypedDict):\n    \"\"\"Represents a color in RGBA space.\"\"\"\n\n    red: float\n    \"\"\" The red component of this color in the range [0-1]. \"\"\"\n    green: float\n    \"\"\" The green component of this color in the range [0-1]. \"\"\"\n    blue: float\n    \"\"\" The blue component of this color in the range [0-1]. \"\"\"\n    alpha: float\n    \"\"\" The alpha component of this color in the range [0-1]. \"\"\"\n\n\nclass DocumentColorOptions(TypedDict):\n    workDoneProgress: NotRequired[bool]\n\n\nclass FoldingRangeOptions(TypedDict):\n    workDoneProgress: NotRequired[bool]\n\n\nclass DeclarationOptions(TypedDict):\n    workDoneProgress: NotRequired[bool]\n\n\nclass Position(TypedDict):\n    \"\"\"Position in a text document expressed as zero-based line and character\n    offset. Prior to 3.17 the offsets were always based on a UTF-16 string\n    representation. So a string of the form `a𐐀b` the character offset of the\n    character `a` is 0, the character offset of `𐐀` is 1 and the character\n    offset of b is 3 since `𐐀` is represented using two code units in UTF-16.\n    Since 3.17 clients and servers can agree on a different string encoding\n    representation (e.g. UTF-8). The client announces it's supported encoding\n    via the client capability [`general.positionEncodings`](#clientCapabilities).\n    The value is an array of position encodings the client supports, with\n    decreasing preference (e.g. the encoding at index `0` is the most preferred\n    one). To stay backwards compatible the only mandatory encoding is UTF-16\n    represented via the string `utf-16`. The server can pick one of the\n    encodings offered by the client and signals that encoding back to the\n    client via the initialize result's property\n    [`capabilities.positionEncoding`](#serverCapabilities). If the string value\n    `utf-16` is missing from the client's capability `general.positionEncodings`\n    servers can safely assume that the client supports UTF-16. If the server\n    omits the position encoding in its initialize result the encoding defaults\n    to the string value `utf-16`. Implementation considerations: since the\n    conversion from one encoding into another requires the content of the\n    file / line the conversion is best done where the file is read which is\n    usually on the server side.\n\n    Positions are line end character agnostic. So you can not specify a position\n    that denotes `\\r|\\n` or `\\n|` where `|` represents the character offset.\n\n    @since 3.17.0 - support for negotiated position encoding.\"\"\"\n\n    line: Uint\n    \"\"\" Line position in a document (zero-based).\n\n    If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.\n    If a line number is negative, it defaults to 0. \"\"\"\n    character: Uint\n    \"\"\" Character offset on a line in a document (zero-based).\n\n    The meaning of this offset is determined by the negotiated\n    `PositionEncodingKind`.\n\n    If the character value is greater than the line length it defaults back to the\n    line length. \"\"\"\n\n\nclass SelectionRangeOptions(TypedDict):\n    workDoneProgress: NotRequired[bool]\n\n\nclass CallHierarchyOptions(TypedDict):\n    \"\"\"Call hierarchy options used during static registration.\n\n    @since 3.16.0\"\"\"\n\n    workDoneProgress: NotRequired[bool]\n\n\nclass SemanticTokensOptions(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    legend: \"SemanticTokensLegend\"\n    \"\"\" The legend used by the server \"\"\"\n    range: NotRequired[Union[bool, dict]]\n    \"\"\" Server supports providing semantic tokens for a specific range\n    of a document. \"\"\"\n    full: NotRequired[Union[bool, \"__SemanticTokensOptions_full_Type_2\"]]\n    \"\"\" Server supports providing semantic tokens for a full document. \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass SemanticTokensEdit(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    start: Uint\n    \"\"\" The start offset of the edit. \"\"\"\n    deleteCount: Uint\n    \"\"\" The count of elements to remove. \"\"\"\n    data: NotRequired[List[Uint]]\n    \"\"\" The elements to insert. \"\"\"\n\n\nclass LinkedEditingRangeOptions(TypedDict):\n    workDoneProgress: NotRequired[bool]\n\n\nclass FileCreate(TypedDict):\n    \"\"\"Represents information on a file/folder create.\n\n    @since 3.16.0\"\"\"\n\n    uri: str\n    \"\"\" A file:// URI for the location of the file/folder being created. \"\"\"\n\n\nclass TextDocumentEdit(TypedDict):\n    \"\"\"Describes textual changes on a text document. A TextDocumentEdit describes all changes\n    on a document version Si and after they are applied move the document to version Si+1.\n    So the creator of a TextDocumentEdit doesn't need to sort the array of edits or do any\n    kind of ordering. However the edits must be non overlapping.\"\"\"\n\n    textDocument: \"OptionalVersionedTextDocumentIdentifier\"\n    \"\"\" The text document to change. \"\"\"\n    edits: List[Union[\"TextEdit\", \"AnnotatedTextEdit\"]]\n    \"\"\" The edits to be applied.\n\n    @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a\n    client capability. \"\"\"\n\n\nclass CreateFile(TypedDict):\n    \"\"\"Create file operation.\"\"\"\n\n    kind: Literal[\"create\"]\n    \"\"\" A create \"\"\"\n    uri: \"DocumentUri\"\n    \"\"\" The resource to create. \"\"\"\n    options: NotRequired[\"CreateFileOptions\"]\n    \"\"\" Additional options \"\"\"\n    annotationId: NotRequired[\"ChangeAnnotationIdentifier\"]\n    \"\"\" An optional annotation identifier describing the operation.\n\n    @since 3.16.0 \"\"\"\n\n\nclass RenameFile(TypedDict):\n    \"\"\"Rename file operation\"\"\"\n\n    kind: Literal[\"rename\"]\n    \"\"\" A rename \"\"\"\n    oldUri: \"DocumentUri\"\n    \"\"\" The old (existing) location. \"\"\"\n    newUri: \"DocumentUri\"\n    \"\"\" The new location. \"\"\"\n    options: NotRequired[\"RenameFileOptions\"]\n    \"\"\" Rename options. \"\"\"\n    annotationId: NotRequired[\"ChangeAnnotationIdentifier\"]\n    \"\"\" An optional annotation identifier describing the operation.\n\n    @since 3.16.0 \"\"\"\n\n\nclass DeleteFile(TypedDict):\n    \"\"\"Delete file operation\"\"\"\n\n    kind: Literal[\"delete\"]\n    \"\"\" A delete \"\"\"\n    uri: \"DocumentUri\"\n    \"\"\" The file to delete. \"\"\"\n    options: NotRequired[\"DeleteFileOptions\"]\n    \"\"\" Delete options. \"\"\"\n    annotationId: NotRequired[\"ChangeAnnotationIdentifier\"]\n    \"\"\" An optional annotation identifier describing the operation.\n\n    @since 3.16.0 \"\"\"\n\n\nclass ChangeAnnotation(TypedDict):\n    \"\"\"Additional information that describes document changes.\n\n    @since 3.16.0\"\"\"\n\n    label: str\n    \"\"\" A human-readable string describing the actual change. The string\n    is rendered prominent in the user interface. \"\"\"\n    needsConfirmation: NotRequired[bool]\n    \"\"\" A flag which indicates that user confirmation is needed\n    before applying the change. \"\"\"\n    description: NotRequired[str]\n    \"\"\" A human-readable string which is rendered less prominent in\n    the user interface. \"\"\"\n\n\nclass FileOperationFilter(TypedDict):\n    \"\"\"A filter to describe in which file operation requests or notifications\n    the server is interested in receiving.\n\n    @since 3.16.0\"\"\"\n\n    scheme: NotRequired[str]\n    \"\"\" A Uri scheme like `file` or `untitled`. \"\"\"\n    pattern: \"FileOperationPattern\"\n    \"\"\" The actual file operation pattern. \"\"\"\n\n\nclass FileRename(TypedDict):\n    \"\"\"Represents information on a file/folder rename.\n\n    @since 3.16.0\"\"\"\n\n    oldUri: str\n    \"\"\" A file:// URI for the original location of the file/folder being renamed. \"\"\"\n    newUri: str\n    \"\"\" A file:// URI for the new location of the file/folder being renamed. \"\"\"\n\n\nclass FileDelete(TypedDict):\n    \"\"\"Represents information on a file/folder delete.\n\n    @since 3.16.0\"\"\"\n\n    uri: str\n    \"\"\" A file:// URI for the location of the file/folder being deleted. \"\"\"\n\n\nclass MonikerOptions(TypedDict):\n    workDoneProgress: NotRequired[bool]\n\n\nclass TypeHierarchyOptions(TypedDict):\n    \"\"\"Type hierarchy options used during static registration.\n\n    @since 3.17.0\"\"\"\n\n    workDoneProgress: NotRequired[bool]\n\n\nclass InlineValueContext(TypedDict):\n    \"\"\"@since 3.17.0\"\"\"\n\n    frameId: int\n    \"\"\" The stack frame (as a DAP Id) where the execution has stopped. \"\"\"\n    stoppedLocation: \"Range\"\n    \"\"\" The document range where execution has stopped.\n    Typically the end position of the range denotes the line where the inline values are shown. \"\"\"\n\n\nclass InlineValueText(TypedDict):\n    \"\"\"Provide inline value as text.\n\n    @since 3.17.0\"\"\"\n\n    range: \"Range\"\n    \"\"\" The document range for which the inline value applies. \"\"\"\n    text: str\n    \"\"\" The text of the inline value. \"\"\"\n\n\nclass InlineValueVariableLookup(TypedDict):\n    \"\"\"Provide inline value through a variable lookup.\n    If only a range is specified, the variable name will be extracted from the underlying document.\n    An optional variable name can be used to override the extracted name.\n\n    @since 3.17.0\"\"\"\n\n    range: \"Range\"\n    \"\"\" The document range for which the inline value applies.\n    The range is used to extract the variable name from the underlying document. \"\"\"\n    variableName: NotRequired[str]\n    \"\"\" If specified the name of the variable to look up. \"\"\"\n    caseSensitiveLookup: bool\n    \"\"\" How to perform the lookup. \"\"\"\n\n\nclass InlineValueEvaluatableExpression(TypedDict):\n    \"\"\"Provide an inline value through an expression evaluation.\n    If only a range is specified, the expression will be extracted from the underlying document.\n    An optional expression can be used to override the extracted expression.\n\n    @since 3.17.0\"\"\"\n\n    range: \"Range\"\n    \"\"\" The document range for which the inline value applies.\n    The range is used to extract the evaluatable expression from the underlying document. \"\"\"\n    expression: NotRequired[str]\n    \"\"\" If specified the expression overrides the extracted expression. \"\"\"\n\n\nclass InlineValueOptions(TypedDict):\n    \"\"\"Inline value options used during static registration.\n\n    @since 3.17.0\"\"\"\n\n    workDoneProgress: NotRequired[bool]\n\n\nclass InlayHintLabelPart(TypedDict):\n    \"\"\"An inlay hint label part allows for interactive and composite labels\n    of inlay hints.\n\n    @since 3.17.0\"\"\"\n\n    value: str\n    \"\"\" The value of this label part. \"\"\"\n    tooltip: NotRequired[Union[str, \"MarkupContent\"]]\n    \"\"\" The tooltip text when you hover over this label part. Depending on\n    the client capability `inlayHint.resolveSupport` clients might resolve\n    this property late using the resolve request. \"\"\"\n    location: NotRequired[\"Location\"]\n    \"\"\" An optional source code location that represents this\n    label part.\n\n    The editor will use this location for the hover and for code navigation\n    features: This part will become a clickable link that resolves to the\n    definition of the symbol at the given location (not necessarily the\n    location itself), it shows the hover that shows at the given location,\n    and it shows a context menu with further code navigation commands.\n\n    Depending on the client capability `inlayHint.resolveSupport` clients\n    might resolve this property late using the resolve request. \"\"\"\n    command: NotRequired[\"Command\"]\n    \"\"\" An optional command for this label part.\n\n    Depending on the client capability `inlayHint.resolveSupport` clients\n    might resolve this property late using the resolve request. \"\"\"\n\n\nclass MarkupContent(TypedDict):\n    \"\"\"A `MarkupContent` literal represents a string value which content is interpreted base on its\n    kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.\n\n    If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.\n    See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting\n\n    Here is an example how such a string can be constructed using JavaScript / TypeScript:\n    ```ts\n    let markdown: MarkdownContent = {\n     kind: MarkupKind.Markdown,\n     value: [\n       '# Header',\n       'Some text',\n       '```typescript',\n       'someCode();',\n       '```'\n     ].join('\\n')\n    };\n    ```\n\n    *Please Note* that clients might sanitize the return markdown. A client could decide to\n    remove HTML from the markdown to avoid script execution.\"\"\"\n\n    kind: \"MarkupKind\"\n    \"\"\" The type of the Markup \"\"\"\n    value: str\n    \"\"\" The content itself \"\"\"\n\n\nclass InlayHintOptions(TypedDict):\n    \"\"\"Inlay hint options used during static registration.\n\n    @since 3.17.0\"\"\"\n\n    resolveProvider: NotRequired[bool]\n    \"\"\" The server provides support to resolve additional\n    information for an inlay hint item. \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass RelatedFullDocumentDiagnosticReport(TypedDict):\n    \"\"\"A full diagnostic report with a set of related documents.\n\n    @since 3.17.0\"\"\"\n\n    relatedDocuments: NotRequired[\n        Dict[\n            \"DocumentUri\",\n            Union[\"FullDocumentDiagnosticReport\", \"UnchangedDocumentDiagnosticReport\"],\n        ]\n    ]\n    \"\"\" Diagnostics of related documents. This information is useful\n    in programming languages where code in a file A can generate\n    diagnostics in a file B which A depends on. An example of\n    such a language is C/C++ where marco definitions in a file\n    a.cpp and result in errors in a header file b.hpp.\n\n    @since 3.17.0 \"\"\"\n    kind: Literal[\"full\"]\n    \"\"\" A full document diagnostic report. \"\"\"\n    resultId: NotRequired[str]\n    \"\"\" An optional result id. If provided it will\n    be sent on the next diagnostic request for the\n    same document. \"\"\"\n    items: List[\"Diagnostic\"]\n    \"\"\" The actual items. \"\"\"\n\n\nclass RelatedUnchangedDocumentDiagnosticReport(TypedDict):\n    \"\"\"An unchanged diagnostic report with a set of related documents.\n\n    @since 3.17.0\"\"\"\n\n    relatedDocuments: NotRequired[\n        Dict[\n            \"DocumentUri\",\n            Union[\"FullDocumentDiagnosticReport\", \"UnchangedDocumentDiagnosticReport\"],\n        ]\n    ]\n    \"\"\" Diagnostics of related documents. This information is useful\n    in programming languages where code in a file A can generate\n    diagnostics in a file B which A depends on. An example of\n    such a language is C/C++ where marco definitions in a file\n    a.cpp and result in errors in a header file b.hpp.\n\n    @since 3.17.0 \"\"\"\n    kind: Literal[\"unchanged\"]\n    \"\"\" A document diagnostic report indicating\n    no changes to the last result. A server can\n    only return `unchanged` if result ids are\n    provided. \"\"\"\n    resultId: str\n    \"\"\" A result id which will be sent on the next\n    diagnostic request for the same document. \"\"\"\n\n\nclass FullDocumentDiagnosticReport(TypedDict):\n    \"\"\"A diagnostic report with a full set of problems.\n\n    @since 3.17.0\"\"\"\n\n    kind: Literal[\"full\"]\n    \"\"\" A full document diagnostic report. \"\"\"\n    resultId: NotRequired[str]\n    \"\"\" An optional result id. If provided it will\n    be sent on the next diagnostic request for the\n    same document. \"\"\"\n    items: List[\"Diagnostic\"]\n    \"\"\" The actual items. \"\"\"\n\n\nclass UnchangedDocumentDiagnosticReport(TypedDict):\n    \"\"\"A diagnostic report indicating that the last returned\n    report is still accurate.\n\n    @since 3.17.0\"\"\"\n\n    kind: Literal[\"unchanged\"]\n    \"\"\" A document diagnostic report indicating\n    no changes to the last result. A server can\n    only return `unchanged` if result ids are\n    provided. \"\"\"\n    resultId: str\n    \"\"\" A result id which will be sent on the next\n    diagnostic request for the same document. \"\"\"\n\n\nclass DiagnosticOptions(TypedDict):\n    \"\"\"Diagnostic options.\n\n    @since 3.17.0\"\"\"\n\n    identifier: NotRequired[str]\n    \"\"\" An optional identifier under which the diagnostics are\n    managed by the client. \"\"\"\n    interFileDependencies: bool\n    \"\"\" Whether the language has inter file dependencies meaning that\n    editing code in one file can result in a different diagnostic\n    set in another file. Inter file dependencies are common for\n    most programming languages and typically uncommon for linters. \"\"\"\n    workspaceDiagnostics: bool\n    \"\"\" The server provides support for workspace diagnostics as well. \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass PreviousResultId(TypedDict):\n    \"\"\"A previous result id in a workspace pull request.\n\n    @since 3.17.0\"\"\"\n\n    uri: \"DocumentUri\"\n    \"\"\" The URI for which the client knowns a\n    result id. \"\"\"\n    value: str\n    \"\"\" The value of the previous result id. \"\"\"\n\n\nclass NotebookDocument(TypedDict):\n    \"\"\"A notebook document.\n\n    @since 3.17.0\"\"\"\n\n    uri: \"URI\"\n    \"\"\" The notebook document's uri. \"\"\"\n    notebookType: str\n    \"\"\" The type of the notebook. \"\"\"\n    version: int\n    \"\"\" The version number of this document (it will increase after each\n    change, including undo/redo). \"\"\"\n    metadata: NotRequired[\"LSPObject\"]\n    \"\"\" Additional metadata stored with the notebook\n    document.\n\n    Note: should always be an object literal (e.g. LSPObject) \"\"\"\n    cells: List[\"NotebookCell\"]\n    \"\"\" The cells of a notebook. \"\"\"\n\n\nclass TextDocumentItem(TypedDict):\n    \"\"\"An item to transfer a text document from the client to the\n    server.\"\"\"\n\n    uri: \"DocumentUri\"\n    \"\"\" The text document's uri. \"\"\"\n    languageId: str\n    \"\"\" The text document's language identifier. \"\"\"\n    version: int\n    \"\"\" The version number of this document (it will increase after each\n    change, including undo/redo). \"\"\"\n    text: str\n    \"\"\" The content of the opened text document. \"\"\"\n\n\nclass VersionedNotebookDocumentIdentifier(TypedDict):\n    \"\"\"A versioned notebook document identifier.\n\n    @since 3.17.0\"\"\"\n\n    version: int\n    \"\"\" The version number of this notebook document. \"\"\"\n    uri: \"URI\"\n    \"\"\" The notebook document's uri. \"\"\"\n\n\nclass NotebookDocumentChangeEvent(TypedDict):\n    \"\"\"A change event for a notebook document.\n\n    @since 3.17.0\"\"\"\n\n    metadata: NotRequired[\"LSPObject\"]\n    \"\"\" The changed meta data if any.\n\n    Note: should always be an object literal (e.g. LSPObject) \"\"\"\n    cells: NotRequired[\"__NotebookDocumentChangeEvent_cells_Type_1\"]\n    \"\"\" Changes to cells \"\"\"\n\n\nclass NotebookDocumentIdentifier(TypedDict):\n    \"\"\"A literal to identify a notebook document in the client.\n\n    @since 3.17.0\"\"\"\n\n    uri: \"URI\"\n    \"\"\" The notebook document's uri. \"\"\"\n\n\nclass Registration(TypedDict):\n    \"\"\"General parameters to to register for an notification or to register a provider.\"\"\"\n\n    id: str\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. \"\"\"\n    method: str\n    \"\"\" The method / capability to register for. \"\"\"\n    registerOptions: NotRequired[\"LSPAny\"]\n    \"\"\" Options necessary for the registration. \"\"\"\n\n\nclass Unregistration(TypedDict):\n    \"\"\"General parameters to unregister a request or notification.\"\"\"\n\n    id: str\n    \"\"\" The id used to unregister the request or notification. Usually an id\n    provided during the register request. \"\"\"\n    method: str\n    \"\"\" The method to unregister for. \"\"\"\n\n\nclass WorkspaceFoldersInitializeParams(TypedDict):\n    workspaceFolders: NotRequired[Union[List[\"WorkspaceFolder\"], None]]\n    \"\"\" The workspace folders configured in the client when the server starts.\n\n    This property is only available if the client supports workspace folders.\n    It can be `null` if the client supports workspace folders but none are\n    configured.\n\n    @since 3.6.0 \"\"\"\n\n\nclass ServerCapabilities(TypedDict):\n    \"\"\"Defines the capabilities provided by a language\n    server.\"\"\"\n\n    positionEncoding: NotRequired[\"PositionEncodingKind\"]\n    \"\"\" The position encoding the server picked from the encodings offered\n    by the client via the client capability `general.positionEncodings`.\n\n    If the client didn't provide any position encodings the only valid\n    value that a server can return is 'utf-16'.\n\n    If omitted it defaults to 'utf-16'.\n\n    @since 3.17.0 \"\"\"\n    textDocumentSync: NotRequired[\n        Union[\"TextDocumentSyncOptions\", \"TextDocumentSyncKind\"]\n    ]\n    \"\"\" Defines how text documents are synced. Is either a detailed structure\n    defining each notification or for backwards compatibility the\n    TextDocumentSyncKind number. \"\"\"\n    notebookDocumentSync: NotRequired[\n        Union[\"NotebookDocumentSyncOptions\", \"NotebookDocumentSyncRegistrationOptions\"]\n    ]\n    \"\"\" Defines how notebook documents are synced.\n\n    @since 3.17.0 \"\"\"\n    completionProvider: NotRequired[\"CompletionOptions\"]\n    \"\"\" The server provides completion support. \"\"\"\n    hoverProvider: NotRequired[Union[bool, \"HoverOptions\"]]\n    \"\"\" The server provides hover support. \"\"\"\n    signatureHelpProvider: NotRequired[\"SignatureHelpOptions\"]\n    \"\"\" The server provides signature help support. \"\"\"\n    declarationProvider: NotRequired[\n        Union[bool, \"DeclarationOptions\", \"DeclarationRegistrationOptions\"]\n    ]\n    \"\"\" The server provides Goto Declaration support. \"\"\"\n    definitionProvider: NotRequired[Union[bool, \"DefinitionOptions\"]]\n    \"\"\" The server provides goto definition support. \"\"\"\n    typeDefinitionProvider: NotRequired[\n        Union[bool, \"TypeDefinitionOptions\", \"TypeDefinitionRegistrationOptions\"]\n    ]\n    \"\"\" The server provides Goto Type Definition support. \"\"\"\n    implementationProvider: NotRequired[\n        Union[bool, \"ImplementationOptions\", \"ImplementationRegistrationOptions\"]\n    ]\n    \"\"\" The server provides Goto Implementation support. \"\"\"\n    referencesProvider: NotRequired[Union[bool, \"ReferenceOptions\"]]\n    \"\"\" The server provides find references support. \"\"\"\n    documentHighlightProvider: NotRequired[Union[bool, \"DocumentHighlightOptions\"]]\n    \"\"\" The server provides document highlight support. \"\"\"\n    documentSymbolProvider: NotRequired[Union[bool, \"DocumentSymbolOptions\"]]\n    \"\"\" The server provides document symbol support. \"\"\"\n    codeActionProvider: NotRequired[Union[bool, \"CodeActionOptions\"]]\n    \"\"\" The server provides code actions. CodeActionOptions may only be\n    specified if the client states that it supports\n    `codeActionLiteralSupport` in its initial `initialize` request. \"\"\"\n    codeLensProvider: NotRequired[\"CodeLensOptions\"]\n    \"\"\" The server provides code lens. \"\"\"\n    documentLinkProvider: NotRequired[\"DocumentLinkOptions\"]\n    \"\"\" The server provides document link support. \"\"\"\n    colorProvider: NotRequired[\n        Union[bool, \"DocumentColorOptions\", \"DocumentColorRegistrationOptions\"]\n    ]\n    \"\"\" The server provides color provider support. \"\"\"\n    workspaceSymbolProvider: NotRequired[Union[bool, \"WorkspaceSymbolOptions\"]]\n    \"\"\" The server provides workspace symbol support. \"\"\"\n    documentFormattingProvider: NotRequired[Union[bool, \"DocumentFormattingOptions\"]]\n    \"\"\" The server provides document formatting. \"\"\"\n    documentRangeFormattingProvider: NotRequired[\n        Union[bool, \"DocumentRangeFormattingOptions\"]\n    ]\n    \"\"\" The server provides document range formatting. \"\"\"\n    documentOnTypeFormattingProvider: NotRequired[\"DocumentOnTypeFormattingOptions\"]\n    \"\"\" The server provides document formatting on typing. \"\"\"\n    renameProvider: NotRequired[Union[bool, \"RenameOptions\"]]\n    \"\"\" The server provides rename support. RenameOptions may only be\n    specified if the client states that it supports\n    `prepareSupport` in its initial `initialize` request. \"\"\"\n    foldingRangeProvider: NotRequired[\n        Union[bool, \"FoldingRangeOptions\", \"FoldingRangeRegistrationOptions\"]\n    ]\n    \"\"\" The server provides folding provider support. \"\"\"\n    selectionRangeProvider: NotRequired[\n        Union[bool, \"SelectionRangeOptions\", \"SelectionRangeRegistrationOptions\"]\n    ]\n    \"\"\" The server provides selection range support. \"\"\"\n    executeCommandProvider: NotRequired[\"ExecuteCommandOptions\"]\n    \"\"\" The server provides execute command support. \"\"\"\n    callHierarchyProvider: NotRequired[\n        Union[bool, \"CallHierarchyOptions\", \"CallHierarchyRegistrationOptions\"]\n    ]\n    \"\"\" The server provides call hierarchy support.\n\n    @since 3.16.0 \"\"\"\n    linkedEditingRangeProvider: NotRequired[\n        Union[\n            bool, \"LinkedEditingRangeOptions\", \"LinkedEditingRangeRegistrationOptions\"\n        ]\n    ]\n    \"\"\" The server provides linked editing range support.\n\n    @since 3.16.0 \"\"\"\n    semanticTokensProvider: NotRequired[\n        Union[\"SemanticTokensOptions\", \"SemanticTokensRegistrationOptions\"]\n    ]\n    \"\"\" The server provides semantic tokens support.\n\n    @since 3.16.0 \"\"\"\n    monikerProvider: NotRequired[\n        Union[bool, \"MonikerOptions\", \"MonikerRegistrationOptions\"]\n    ]\n    \"\"\" The server provides moniker support.\n\n    @since 3.16.0 \"\"\"\n    typeHierarchyProvider: NotRequired[\n        Union[bool, \"TypeHierarchyOptions\", \"TypeHierarchyRegistrationOptions\"]\n    ]\n    \"\"\" The server provides type hierarchy support.\n\n    @since 3.17.0 \"\"\"\n    inlineValueProvider: NotRequired[\n        Union[bool, \"InlineValueOptions\", \"InlineValueRegistrationOptions\"]\n    ]\n    \"\"\" The server provides inline values.\n\n    @since 3.17.0 \"\"\"\n    inlayHintProvider: NotRequired[\n        Union[bool, \"InlayHintOptions\", \"InlayHintRegistrationOptions\"]\n    ]\n    \"\"\" The server provides inlay hints.\n\n    @since 3.17.0 \"\"\"\n    diagnosticProvider: NotRequired[\n        Union[\"DiagnosticOptions\", \"DiagnosticRegistrationOptions\"]\n    ]\n    \"\"\" The server has support for pull model diagnostics.\n\n    @since 3.17.0 \"\"\"\n    workspace: NotRequired[\"__ServerCapabilities_workspace_Type_1\"]\n    \"\"\" Workspace specific server capabilities. \"\"\"\n    experimental: NotRequired[\"LSPAny\"]\n    \"\"\" Experimental server capabilities. \"\"\"\n\n\nclass VersionedTextDocumentIdentifier(TypedDict):\n    \"\"\"A text document identifier to denote a specific version of a text document.\"\"\"\n\n    version: int\n    \"\"\" The version number of this document. \"\"\"\n    uri: \"DocumentUri\"\n    \"\"\" The text document's uri. \"\"\"\n\n\nclass SaveOptions(TypedDict):\n    \"\"\"Save options.\"\"\"\n\n    includeText: NotRequired[bool]\n    \"\"\" The client is supposed to include the content on save. \"\"\"\n\n\nclass FileEvent(TypedDict):\n    \"\"\"An event describing a file change.\"\"\"\n\n    uri: \"DocumentUri\"\n    \"\"\" The file's uri. \"\"\"\n    type: \"FileChangeType\"\n    \"\"\" The change type. \"\"\"\n\n\nclass FileSystemWatcher(TypedDict):\n    globPattern: \"GlobPattern\"\n    \"\"\" The glob pattern to watch. See {@link GlobPattern glob pattern} for more detail.\n\n    @since 3.17.0 support for relative patterns. \"\"\"\n    kind: NotRequired[\"WatchKind\"]\n    \"\"\" The kind of events of interest. If omitted it defaults\n    to WatchKind.Create | WatchKind.Change | WatchKind.Delete\n    which is 7. \"\"\"\n\n\nclass Diagnostic(TypedDict):\n    \"\"\"Represents a diagnostic, such as a compiler error or warning. Diagnostic objects\n    are only valid in the scope of a resource.\"\"\"\n\n    range: \"Range\"\n    \"\"\" The range at which the message applies \"\"\"\n    severity: NotRequired[\"DiagnosticSeverity\"]\n    \"\"\" The diagnostic's severity. Can be omitted. If omitted it is up to the\n    client to interpret diagnostics as error, warning, info or hint. \"\"\"\n    code: NotRequired[Union[int, str]]\n    \"\"\" The diagnostic's code, which usually appear in the user interface. \"\"\"\n    codeDescription: NotRequired[\"CodeDescription\"]\n    \"\"\" An optional property to describe the error code.\n    Requires the code field (above) to be present/not null.\n\n    @since 3.16.0 \"\"\"\n    source: NotRequired[str]\n    \"\"\" A human-readable string describing the source of this\n    diagnostic, e.g. 'typescript' or 'super lint'. It usually\n    appears in the user interface. \"\"\"\n    message: str\n    \"\"\" The diagnostic's message. It usually appears in the user interface \"\"\"\n    tags: NotRequired[List[\"DiagnosticTag\"]]\n    \"\"\" Additional metadata about the diagnostic.\n\n    @since 3.15.0 \"\"\"\n    relatedInformation: NotRequired[List[\"DiagnosticRelatedInformation\"]]\n    \"\"\" An array of related diagnostic information, e.g. when symbol-names within\n    a scope collide all definitions can be marked via this property. \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A data entry field that is preserved between a `textDocument/publishDiagnostics`\n    notification and `textDocument/codeAction` request.\n\n    @since 3.16.0 \"\"\"\n\n\nclass CompletionContext(TypedDict):\n    \"\"\"Contains additional information about the context in which a completion request is triggered.\"\"\"\n\n    triggerKind: \"CompletionTriggerKind\"\n    \"\"\" How the completion was triggered. \"\"\"\n    triggerCharacter: NotRequired[str]\n    \"\"\" The trigger character (a single character) that has trigger code complete.\n    Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter` \"\"\"\n\n\nclass CompletionItemLabelDetails(TypedDict):\n    \"\"\"Additional details for a completion item label.\n\n    @since 3.17.0\"\"\"\n\n    detail: NotRequired[str]\n    \"\"\" An optional string which is rendered less prominently directly after {@link CompletionItem.label label},\n    without any spacing. Should be used for function signatures and type annotations. \"\"\"\n    description: NotRequired[str]\n    \"\"\" An optional string which is rendered less prominently after {@link CompletionItem.detail}. Should be used\n    for fully qualified names and file paths. \"\"\"\n\n\nclass InsertReplaceEdit(TypedDict):\n    \"\"\"A special text edit to provide an insert and a replace operation.\n\n    @since 3.16.0\"\"\"\n\n    newText: str\n    \"\"\" The string to be inserted. \"\"\"\n    insert: \"Range\"\n    \"\"\" The range if the insert is requested \"\"\"\n    replace: \"Range\"\n    \"\"\" The range if the replace is requested. \"\"\"\n\n\nclass CompletionOptions(TypedDict):\n    \"\"\"Completion options.\"\"\"\n\n    triggerCharacters: NotRequired[List[str]]\n    \"\"\" Most tools trigger completion request automatically without explicitly requesting\n    it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user\n    starts to type an identifier. For example if the user types `c` in a JavaScript file\n    code complete will automatically pop up present `console` besides others as a\n    completion item. Characters that make up identifiers don't need to be listed here.\n\n    If code complete should automatically be trigger on characters not being valid inside\n    an identifier (for example `.` in JavaScript) list them in `triggerCharacters`. \"\"\"\n    allCommitCharacters: NotRequired[List[str]]\n    \"\"\" The list of all possible characters that commit a completion. This field can be used\n    if clients don't support individual commit characters per completion item. See\n    `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`\n\n    If a server provides both `allCommitCharacters` and commit characters on an individual\n    completion item the ones on the completion item win.\n\n    @since 3.2.0 \"\"\"\n    resolveProvider: NotRequired[bool]\n    \"\"\" The server provides support to resolve additional\n    information for a completion item. \"\"\"\n    completionItem: NotRequired[\"__CompletionOptions_completionItem_Type_2\"]\n    \"\"\" The server supports the following `CompletionItem` specific\n    capabilities.\n\n    @since 3.17.0 \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass HoverOptions(TypedDict):\n    \"\"\"Hover options.\"\"\"\n\n    workDoneProgress: NotRequired[bool]\n\n\nclass SignatureHelpContext(TypedDict):\n    \"\"\"Additional information about the context in which a signature help request was triggered.\n\n    @since 3.15.0\"\"\"\n\n    triggerKind: \"SignatureHelpTriggerKind\"\n    \"\"\" Action that caused signature help to be triggered. \"\"\"\n    triggerCharacter: NotRequired[str]\n    \"\"\" Character that caused signature help to be triggered.\n\n    This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter` \"\"\"\n    isRetrigger: bool\n    \"\"\" `true` if signature help was already showing when it was triggered.\n\n    Retriggers occurs when the signature help is already active and can be caused by actions such as\n    typing a trigger character, a cursor move, or document content changes. \"\"\"\n    activeSignatureHelp: NotRequired[\"SignatureHelp\"]\n    \"\"\" The currently active `SignatureHelp`.\n\n    The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on\n    the user navigating through available signatures. \"\"\"\n\n\nclass SignatureInformation(TypedDict):\n    \"\"\"Represents the signature of something callable. A signature\n    can have a label, like a function-name, a doc-comment, and\n    a set of parameters.\"\"\"\n\n    label: str\n    \"\"\" The label of this signature. Will be shown in\n    the UI. \"\"\"\n    documentation: NotRequired[Union[str, \"MarkupContent\"]]\n    \"\"\" The human-readable doc-comment of this signature. Will be shown\n    in the UI but can be omitted. \"\"\"\n    parameters: NotRequired[List[\"ParameterInformation\"]]\n    \"\"\" The parameters of this signature. \"\"\"\n    activeParameter: NotRequired[Uint]\n    \"\"\" The index of the active parameter.\n\n    If provided, this is used in place of `SignatureHelp.activeParameter`.\n\n    @since 3.16.0 \"\"\"\n\n\nclass SignatureHelpOptions(TypedDict):\n    \"\"\"Server Capabilities for a {@link SignatureHelpRequest}.\"\"\"\n\n    triggerCharacters: NotRequired[List[str]]\n    \"\"\" List of characters that trigger signature help automatically. \"\"\"\n    retriggerCharacters: NotRequired[List[str]]\n    \"\"\" List of characters that re-trigger signature help.\n\n    These trigger characters are only active when signature help is already showing. All trigger characters\n    are also counted as re-trigger characters.\n\n    @since 3.15.0 \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass DefinitionOptions(TypedDict):\n    \"\"\"Server Capabilities for a {@link DefinitionRequest}.\"\"\"\n\n    workDoneProgress: NotRequired[bool]\n\n\nclass ReferenceContext(TypedDict):\n    \"\"\"Value-object that contains additional information when\n    requesting references.\"\"\"\n\n    includeDeclaration: bool\n    \"\"\" Include the declaration of the current symbol. \"\"\"\n\n\nclass ReferenceOptions(TypedDict):\n    \"\"\"Reference options.\"\"\"\n\n    workDoneProgress: NotRequired[bool]\n\n\nclass DocumentHighlightOptions(TypedDict):\n    \"\"\"Provider options for a {@link DocumentHighlightRequest}.\"\"\"\n\n    workDoneProgress: NotRequired[bool]\n\n\nclass BaseSymbolInformation(TypedDict):\n    \"\"\"A base for all symbol information.\"\"\"\n\n    name: str\n    \"\"\" The name of this symbol. \"\"\"\n    kind: \"SymbolKind\"\n    \"\"\" The kind of this symbol. \"\"\"\n    tags: NotRequired[List[\"SymbolTag\"]]\n    \"\"\" Tags for this symbol.\n\n    @since 3.16.0 \"\"\"\n    containerName: NotRequired[str]\n    \"\"\" The name of the symbol containing this symbol. This information is for\n    user interface purposes (e.g. to render a qualifier in the user interface\n    if necessary). It can't be used to re-infer a hierarchy for the document\n    symbols. \"\"\"\n\n\nclass DocumentSymbolOptions(TypedDict):\n    \"\"\"Provider options for a {@link DocumentSymbolRequest}.\"\"\"\n\n    label: NotRequired[str]\n    \"\"\" A human-readable string that is shown when multiple outlines trees\n    are shown for the same document.\n\n    @since 3.16.0 \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass CodeActionContext(TypedDict):\n    \"\"\"Contains additional diagnostic information about the context in which\n    a {@link CodeActionProvider.provideCodeActions code action} is run.\"\"\"\n\n    diagnostics: List[\"Diagnostic\"]\n    \"\"\" An array of diagnostics known on the client side overlapping the range provided to the\n    `textDocument/codeAction` request. They are provided so that the server knows which\n    errors are currently presented to the user for the given range. There is no guarantee\n    that these accurately reflect the error state of the resource. The primary parameter\n    to compute code actions is the provided range. \"\"\"\n    only: NotRequired[List[\"CodeActionKind\"]]\n    \"\"\" Requested kind of actions to return.\n\n    Actions not of this kind are filtered out by the client before being shown. So servers\n    can omit computing them. \"\"\"\n    triggerKind: NotRequired[\"CodeActionTriggerKind\"]\n    \"\"\" The reason why code actions were requested.\n\n    @since 3.17.0 \"\"\"\n\n\nclass CodeActionOptions(TypedDict):\n    \"\"\"Provider options for a {@link CodeActionRequest}.\"\"\"\n\n    codeActionKinds: NotRequired[List[\"CodeActionKind\"]]\n    \"\"\" CodeActionKinds that this server may return.\n\n    The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server\n    may list out every specific kind they provide. \"\"\"\n    resolveProvider: NotRequired[bool]\n    \"\"\" The server provides support to resolve additional\n    information for a code action.\n\n    @since 3.16.0 \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass WorkspaceSymbolOptions(TypedDict):\n    \"\"\"Server capabilities for a {@link WorkspaceSymbolRequest}.\"\"\"\n\n    resolveProvider: NotRequired[bool]\n    \"\"\" The server provides support to resolve additional\n    information for a workspace symbol.\n\n    @since 3.17.0 \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass CodeLensOptions(TypedDict):\n    \"\"\"Code Lens provider options of a {@link CodeLensRequest}.\"\"\"\n\n    resolveProvider: NotRequired[bool]\n    \"\"\" Code lens has a resolve provider as well. \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass DocumentLinkOptions(TypedDict):\n    \"\"\"Provider options for a {@link DocumentLinkRequest}.\"\"\"\n\n    resolveProvider: NotRequired[bool]\n    \"\"\" Document links have a resolve provider as well. \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass FormattingOptions(TypedDict):\n    \"\"\"Value-object describing what options formatting should use.\"\"\"\n\n    tabSize: Uint\n    \"\"\" Size of a tab in spaces. \"\"\"\n    insertSpaces: bool\n    \"\"\" Prefer spaces over tabs. \"\"\"\n    trimTrailingWhitespace: NotRequired[bool]\n    \"\"\" Trim trailing whitespace on a line.\n\n    @since 3.15.0 \"\"\"\n    insertFinalNewline: NotRequired[bool]\n    \"\"\" Insert a newline character at the end of the file if one does not exist.\n\n    @since 3.15.0 \"\"\"\n    trimFinalNewlines: NotRequired[bool]\n    \"\"\" Trim all newlines after the final newline at the end of the file.\n\n    @since 3.15.0 \"\"\"\n\n\nclass DocumentFormattingOptions(TypedDict):\n    \"\"\"Provider options for a {@link DocumentFormattingRequest}.\"\"\"\n\n    workDoneProgress: NotRequired[bool]\n\n\nclass DocumentRangeFormattingOptions(TypedDict):\n    \"\"\"Provider options for a {@link DocumentRangeFormattingRequest}.\"\"\"\n\n    workDoneProgress: NotRequired[bool]\n\n\nclass DocumentOnTypeFormattingOptions(TypedDict):\n    \"\"\"Provider options for a {@link DocumentOnTypeFormattingRequest}.\"\"\"\n\n    firstTriggerCharacter: str\n    \"\"\" A character on which formatting should be triggered, like `{`. \"\"\"\n    moreTriggerCharacter: NotRequired[List[str]]\n    \"\"\" More trigger characters. \"\"\"\n\n\nclass RenameOptions(TypedDict):\n    \"\"\"Provider options for a {@link RenameRequest}.\"\"\"\n\n    prepareProvider: NotRequired[bool]\n    \"\"\" Renames should be checked and tested before being executed.\n\n    @since version 3.12.0 \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass ExecuteCommandOptions(TypedDict):\n    \"\"\"The server capabilities of a {@link ExecuteCommandRequest}.\"\"\"\n\n    commands: List[str]\n    \"\"\" The commands to be executed on the server \"\"\"\n    workDoneProgress: NotRequired[bool]\n\n\nclass SemanticTokensLegend(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    tokenTypes: List[str]\n    \"\"\" The token types a server uses. \"\"\"\n    tokenModifiers: List[str]\n    \"\"\" The token modifiers a server uses. \"\"\"\n\n\nclass OptionalVersionedTextDocumentIdentifier(TypedDict):\n    \"\"\"A text document identifier to optionally denote a specific version of a text document.\"\"\"\n\n    version: Union[int, None]\n    \"\"\" The version number of this document. If a versioned text document identifier\n    is sent from the server to the client and the file is not open in the editor\n    (the server has not received an open notification before) the server can send\n    `null` to indicate that the version is unknown and the content on disk is the\n    truth (as specified with document content ownership). \"\"\"\n    uri: \"DocumentUri\"\n    \"\"\" The text document's uri. \"\"\"\n\n\nclass AnnotatedTextEdit(TypedDict):\n    \"\"\"A special text edit with an additional change annotation.\n\n    @since 3.16.0.\"\"\"\n\n    annotationId: \"ChangeAnnotationIdentifier\"\n    \"\"\" The actual identifier of the change annotation \"\"\"\n    range: \"Range\"\n    \"\"\" The range of the text document to be manipulated. To insert\n    text into a document create a range where start === end. \"\"\"\n    newText: str\n    \"\"\" The string to be inserted. For delete operations use an\n    empty string. \"\"\"\n\n\nclass ResourceOperation(TypedDict):\n    \"\"\"A generic resource operation.\"\"\"\n\n    kind: str\n    \"\"\" The resource operation kind. \"\"\"\n    annotationId: NotRequired[\"ChangeAnnotationIdentifier\"]\n    \"\"\" An optional annotation identifier describing the operation.\n\n    @since 3.16.0 \"\"\"\n\n\nclass CreateFileOptions(TypedDict):\n    \"\"\"Options to create a file.\"\"\"\n\n    overwrite: NotRequired[bool]\n    \"\"\" Overwrite existing file. Overwrite wins over `ignoreIfExists` \"\"\"\n    ignoreIfExists: NotRequired[bool]\n    \"\"\" Ignore if exists. \"\"\"\n\n\nclass RenameFileOptions(TypedDict):\n    \"\"\"Rename file options\"\"\"\n\n    overwrite: NotRequired[bool]\n    \"\"\" Overwrite target if existing. Overwrite wins over `ignoreIfExists` \"\"\"\n    ignoreIfExists: NotRequired[bool]\n    \"\"\" Ignores if target exists. \"\"\"\n\n\nclass DeleteFileOptions(TypedDict):\n    \"\"\"Delete file options\"\"\"\n\n    recursive: NotRequired[bool]\n    \"\"\" Delete the content recursively if a folder is denoted. \"\"\"\n    ignoreIfNotExists: NotRequired[bool]\n    \"\"\" Ignore the operation if the file doesn't exist. \"\"\"\n\n\nclass FileOperationPattern(TypedDict):\n    \"\"\"A pattern to describe in which file operation requests or notifications\n    the server is interested in receiving.\n\n    @since 3.16.0\"\"\"\n\n    glob: str\n    \"\"\" The glob pattern to match. Glob patterns can have the following syntax:\n    - `*` to match one or more characters in a path segment\n    - `?` to match on one character in a path segment\n    - `**` to match any number of path segments, including none\n    - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)\n    - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n    - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`) \"\"\"\n    matches: NotRequired[\"FileOperationPatternKind\"]\n    \"\"\" Whether to match files or folders with this pattern.\n\n    Matches both if undefined. \"\"\"\n    options: NotRequired[\"FileOperationPatternOptions\"]\n    \"\"\" Additional options used during matching. \"\"\"\n\n\nclass WorkspaceFullDocumentDiagnosticReport(TypedDict):\n    \"\"\"A full document diagnostic report for a workspace diagnostic result.\n\n    @since 3.17.0\"\"\"\n\n    uri: \"DocumentUri\"\n    \"\"\" The URI for which diagnostic information is reported. \"\"\"\n    version: Union[int, None]\n    \"\"\" The version number for which the diagnostics are reported.\n    If the document is not marked as open `null` can be provided. \"\"\"\n    kind: Literal[\"full\"]\n    \"\"\" A full document diagnostic report. \"\"\"\n    resultId: NotRequired[str]\n    \"\"\" An optional result id. If provided it will\n    be sent on the next diagnostic request for the\n    same document. \"\"\"\n    items: List[\"Diagnostic\"]\n    \"\"\" The actual items. \"\"\"\n\n\nclass WorkspaceUnchangedDocumentDiagnosticReport(TypedDict):\n    \"\"\"An unchanged document diagnostic report for a workspace diagnostic result.\n\n    @since 3.17.0\"\"\"\n\n    uri: \"DocumentUri\"\n    \"\"\" The URI for which diagnostic information is reported. \"\"\"\n    version: Union[int, None]\n    \"\"\" The version number for which the diagnostics are reported.\n    If the document is not marked as open `null` can be provided. \"\"\"\n    kind: Literal[\"unchanged\"]\n    \"\"\" A document diagnostic report indicating\n    no changes to the last result. A server can\n    only return `unchanged` if result ids are\n    provided. \"\"\"\n    resultId: str\n    \"\"\" A result id which will be sent on the next\n    diagnostic request for the same document. \"\"\"\n\n\nclass NotebookCell(TypedDict):\n    \"\"\"A notebook cell.\n\n    A cell's document URI must be unique across ALL notebook\n    cells and can therefore be used to uniquely identify a\n    notebook cell or the cell's text document.\n\n    @since 3.17.0\"\"\"\n\n    kind: \"NotebookCellKind\"\n    \"\"\" The cell's kind \"\"\"\n    document: \"DocumentUri\"\n    \"\"\" The URI of the cell's text document\n    content. \"\"\"\n    metadata: NotRequired[\"LSPObject\"]\n    \"\"\" Additional metadata stored with the cell.\n\n    Note: should always be an object literal (e.g. LSPObject) \"\"\"\n    executionSummary: NotRequired[\"ExecutionSummary\"]\n    \"\"\" Additional execution summary information\n    if supported by the client. \"\"\"\n\n\nclass NotebookCellArrayChange(TypedDict):\n    \"\"\"A change describing how to move a `NotebookCell`\n    array from state S to S'.\n\n    @since 3.17.0\"\"\"\n\n    start: Uint\n    \"\"\" The start oftest of the cell that changed. \"\"\"\n    deleteCount: Uint\n    \"\"\" The deleted cells \"\"\"\n    cells: NotRequired[List[\"NotebookCell\"]]\n    \"\"\" The new cells, if any \"\"\"\n\n\nclass ClientCapabilities(TypedDict):\n    \"\"\"Defines the capabilities provided by the client.\"\"\"\n\n    workspace: NotRequired[\"WorkspaceClientCapabilities\"]\n    \"\"\" Workspace specific client capabilities. \"\"\"\n    textDocument: NotRequired[\"TextDocumentClientCapabilities\"]\n    \"\"\" Text document specific client capabilities. \"\"\"\n    notebookDocument: NotRequired[\"NotebookDocumentClientCapabilities\"]\n    \"\"\" Capabilities specific to the notebook document support.\n\n    @since 3.17.0 \"\"\"\n    window: NotRequired[\"WindowClientCapabilities\"]\n    \"\"\" Window specific client capabilities. \"\"\"\n    general: NotRequired[\"GeneralClientCapabilities\"]\n    \"\"\" General client capabilities.\n\n    @since 3.16.0 \"\"\"\n    experimental: NotRequired[\"LSPAny\"]\n    \"\"\" Experimental client capabilities. \"\"\"\n\n\nclass TextDocumentSyncOptions(TypedDict):\n    openClose: NotRequired[bool]\n    \"\"\" Open and close notifications are sent to the server. If omitted open close notification should not\n    be sent. \"\"\"\n    change: NotRequired[\"TextDocumentSyncKind\"]\n    \"\"\" Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full\n    and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None. \"\"\"\n    willSave: NotRequired[bool]\n    \"\"\" If present will save notifications are sent to the server. If omitted the notification should not be\n    sent. \"\"\"\n    willSaveWaitUntil: NotRequired[bool]\n    \"\"\" If present will save wait until requests are sent to the server. If omitted the request should not be\n    sent. \"\"\"\n    save: NotRequired[Union[bool, \"SaveOptions\"]]\n    \"\"\" If present save notifications are sent to the server. If omitted the notification should not be\n    sent. \"\"\"\n\n\nclass NotebookDocumentSyncOptions(TypedDict):\n    \"\"\"Options specific to a notebook plus its cells\n    to be synced to the server.\n\n    If a selector provides a notebook document\n    filter but no cell selector all cells of a\n    matching notebook document will be synced.\n\n    If a selector provides no notebook document\n    filter but only a cell selector all notebook\n    document that contain at least one matching\n    cell will be synced.\n\n    @since 3.17.0\"\"\"\n\n    notebookSelector: List[\n        Union[\n            \"__NotebookDocumentSyncOptions_notebookSelector_Type_1\",\n            \"__NotebookDocumentSyncOptions_notebookSelector_Type_2\",\n        ]\n    ]\n    \"\"\" The notebooks to be synced \"\"\"\n    save: NotRequired[bool]\n    \"\"\" Whether save notification should be forwarded to\n    the server. Will only be honored if mode === `notebook`. \"\"\"\n\n\nclass NotebookDocumentSyncRegistrationOptions(TypedDict):\n    \"\"\"Registration options specific to a notebook.\n\n    @since 3.17.0\"\"\"\n\n    notebookSelector: List[\n        Union[\n            \"__NotebookDocumentSyncOptions_notebookSelector_Type_3\",\n            \"__NotebookDocumentSyncOptions_notebookSelector_Type_4\",\n        ]\n    ]\n    \"\"\" The notebooks to be synced \"\"\"\n    save: NotRequired[bool]\n    \"\"\" Whether save notification should be forwarded to\n    the server. Will only be honored if mode === `notebook`. \"\"\"\n    id: NotRequired[str]\n    \"\"\" The id used to register the request. The id can be used to deregister\n    the request again. See also Registration#id. \"\"\"\n\n\nclass WorkspaceFoldersServerCapabilities(TypedDict):\n    supported: NotRequired[bool]\n    \"\"\" The server has support for workspace folders \"\"\"\n    changeNotifications: NotRequired[Union[str, bool]]\n    \"\"\" Whether the server wants to receive workspace folder\n    change notifications.\n\n    If a string is provided the string is treated as an ID\n    under which the notification is registered on the client\n    side. The ID can be used to unregister for these events\n    using the `client/unregisterCapability` request. \"\"\"\n\n\nclass FileOperationOptions(TypedDict):\n    \"\"\"Options for notifications/requests for user operations on files.\n\n    @since 3.16.0\"\"\"\n\n    didCreate: NotRequired[\"FileOperationRegistrationOptions\"]\n    \"\"\" The server is interested in receiving didCreateFiles notifications. \"\"\"\n    willCreate: NotRequired[\"FileOperationRegistrationOptions\"]\n    \"\"\" The server is interested in receiving willCreateFiles requests. \"\"\"\n    didRename: NotRequired[\"FileOperationRegistrationOptions\"]\n    \"\"\" The server is interested in receiving didRenameFiles notifications. \"\"\"\n    willRename: NotRequired[\"FileOperationRegistrationOptions\"]\n    \"\"\" The server is interested in receiving willRenameFiles requests. \"\"\"\n    didDelete: NotRequired[\"FileOperationRegistrationOptions\"]\n    \"\"\" The server is interested in receiving didDeleteFiles file notifications. \"\"\"\n    willDelete: NotRequired[\"FileOperationRegistrationOptions\"]\n    \"\"\" The server is interested in receiving willDeleteFiles file requests. \"\"\"\n\n\nclass CodeDescription(TypedDict):\n    \"\"\"Structure to capture a description for an error code.\n\n    @since 3.16.0\"\"\"\n\n    href: \"URI\"\n    \"\"\" An URI to open with more information about the diagnostic error. \"\"\"\n\n\nclass DiagnosticRelatedInformation(TypedDict):\n    \"\"\"Represents a related message and source code location for a diagnostic. This should be\n    used to point to code locations that cause or related to a diagnostics, e.g when duplicating\n    a symbol in a scope.\"\"\"\n\n    location: \"Location\"\n    \"\"\" The location of this related diagnostic information. \"\"\"\n    message: str\n    \"\"\" The message of this related diagnostic information. \"\"\"\n\n\nclass ParameterInformation(TypedDict):\n    \"\"\"Represents a parameter of a callable-signature. A parameter can\n    have a label and a doc-comment.\"\"\"\n\n    label: Union[str, List[Union[Uint, Uint]]]\n    \"\"\" The label of this parameter information.\n\n    Either a string or an inclusive start and exclusive end offsets within its containing\n    signature label. (see SignatureInformation.label). The offsets are based on a UTF-16\n    string representation as `Position` and `Range` does.\n\n    *Note*: a label of type string should be a substring of its containing signature label.\n    Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`. \"\"\"\n    documentation: NotRequired[Union[str, \"MarkupContent\"]]\n    \"\"\" The human-readable doc-comment of this parameter. Will be shown\n    in the UI but can be omitted. \"\"\"\n\n\nclass NotebookCellTextDocumentFilter(TypedDict):\n    \"\"\"A notebook cell text document filter denotes a cell text\n    document by different properties.\n\n    @since 3.17.0\"\"\"\n\n    notebook: Union[str, \"NotebookDocumentFilter\"]\n    \"\"\" A filter that matches against the notebook\n    containing the notebook cell. If a string\n    value is provided it matches against the\n    notebook type. '*' matches every notebook. \"\"\"\n    language: NotRequired[str]\n    \"\"\" A language id like `python`.\n\n    Will be matched against the language id of the\n    notebook cell document. '*' matches every language. \"\"\"\n\n\nclass FileOperationPatternOptions(TypedDict):\n    \"\"\"Matching options for the file operation pattern.\n\n    @since 3.16.0\"\"\"\n\n    ignoreCase: NotRequired[bool]\n    \"\"\" The pattern should be matched ignoring casing. \"\"\"\n\n\nclass ExecutionSummary(TypedDict):\n    executionOrder: Uint\n    \"\"\" A strict monotonically increasing value\n    indicating the execution order of a cell\n    inside a notebook. \"\"\"\n    success: NotRequired[bool]\n    \"\"\" Whether the execution was successful or\n    not if known by the client. \"\"\"\n\n\nclass WorkspaceClientCapabilities(TypedDict):\n    \"\"\"Workspace specific client capabilities.\"\"\"\n\n    applyEdit: NotRequired[bool]\n    \"\"\" The client supports applying batch edits\n    to the workspace by supporting the request\n    'workspace/applyEdit' \"\"\"\n    workspaceEdit: NotRequired[\"WorkspaceEditClientCapabilities\"]\n    \"\"\" Capabilities specific to `WorkspaceEdit`s. \"\"\"\n    didChangeConfiguration: NotRequired[\"DidChangeConfigurationClientCapabilities\"]\n    \"\"\" Capabilities specific to the `workspace/didChangeConfiguration` notification. \"\"\"\n    didChangeWatchedFiles: NotRequired[\"DidChangeWatchedFilesClientCapabilities\"]\n    \"\"\" Capabilities specific to the `workspace/didChangeWatchedFiles` notification. \"\"\"\n    symbol: NotRequired[\"WorkspaceSymbolClientCapabilities\"]\n    \"\"\" Capabilities specific to the `workspace/symbol` request. \"\"\"\n    executeCommand: NotRequired[\"ExecuteCommandClientCapabilities\"]\n    \"\"\" Capabilities specific to the `workspace/executeCommand` request. \"\"\"\n    workspaceFolders: NotRequired[bool]\n    \"\"\" The client has support for workspace folders.\n\n    @since 3.6.0 \"\"\"\n    configuration: NotRequired[bool]\n    \"\"\" The client supports `workspace/configuration` requests.\n\n    @since 3.6.0 \"\"\"\n    semanticTokens: NotRequired[\"SemanticTokensWorkspaceClientCapabilities\"]\n    \"\"\" Capabilities specific to the semantic token requests scoped to the\n    workspace.\n\n    @since 3.16.0. \"\"\"\n    codeLens: NotRequired[\"CodeLensWorkspaceClientCapabilities\"]\n    \"\"\" Capabilities specific to the code lens requests scoped to the\n    workspace.\n\n    @since 3.16.0. \"\"\"\n    fileOperations: NotRequired[\"FileOperationClientCapabilities\"]\n    \"\"\" The client has support for file notifications/requests for user operations on files.\n\n    Since 3.16.0 \"\"\"\n    inlineValue: NotRequired[\"InlineValueWorkspaceClientCapabilities\"]\n    \"\"\" Capabilities specific to the inline values requests scoped to the\n    workspace.\n\n    @since 3.17.0. \"\"\"\n    inlayHint: NotRequired[\"InlayHintWorkspaceClientCapabilities\"]\n    \"\"\" Capabilities specific to the inlay hint requests scoped to the\n    workspace.\n\n    @since 3.17.0. \"\"\"\n    diagnostics: NotRequired[\"DiagnosticWorkspaceClientCapabilities\"]\n    \"\"\" Capabilities specific to the diagnostic requests scoped to the\n    workspace.\n\n    @since 3.17.0. \"\"\"\n\n\nclass TextDocumentClientCapabilities(TypedDict):\n    \"\"\"Text document specific client capabilities.\"\"\"\n\n    synchronization: NotRequired[\"TextDocumentSyncClientCapabilities\"]\n    \"\"\" Defines which synchronization capabilities the client supports. \"\"\"\n    completion: NotRequired[\"CompletionClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/completion` request. \"\"\"\n    hover: NotRequired[\"HoverClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/hover` request. \"\"\"\n    signatureHelp: NotRequired[\"SignatureHelpClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/signatureHelp` request. \"\"\"\n    declaration: NotRequired[\"DeclarationClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/declaration` request.\n\n    @since 3.14.0 \"\"\"\n    definition: NotRequired[\"DefinitionClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/definition` request. \"\"\"\n    typeDefinition: NotRequired[\"TypeDefinitionClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/typeDefinition` request.\n\n    @since 3.6.0 \"\"\"\n    implementation: NotRequired[\"ImplementationClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/implementation` request.\n\n    @since 3.6.0 \"\"\"\n    references: NotRequired[\"ReferenceClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/references` request. \"\"\"\n    documentHighlight: NotRequired[\"DocumentHighlightClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/documentHighlight` request. \"\"\"\n    documentSymbol: NotRequired[\"DocumentSymbolClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/documentSymbol` request. \"\"\"\n    codeAction: NotRequired[\"CodeActionClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/codeAction` request. \"\"\"\n    codeLens: NotRequired[\"CodeLensClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/codeLens` request. \"\"\"\n    documentLink: NotRequired[\"DocumentLinkClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/documentLink` request. \"\"\"\n    colorProvider: NotRequired[\"DocumentColorClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/documentColor` and the\n    `textDocument/colorPresentation` request.\n\n    @since 3.6.0 \"\"\"\n    formatting: NotRequired[\"DocumentFormattingClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/formatting` request. \"\"\"\n    rangeFormatting: NotRequired[\"DocumentRangeFormattingClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/rangeFormatting` request. \"\"\"\n    onTypeFormatting: NotRequired[\"DocumentOnTypeFormattingClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/onTypeFormatting` request. \"\"\"\n    rename: NotRequired[\"RenameClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/rename` request. \"\"\"\n    foldingRange: NotRequired[\"FoldingRangeClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/foldingRange` request.\n\n    @since 3.10.0 \"\"\"\n    selectionRange: NotRequired[\"SelectionRangeClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/selectionRange` request.\n\n    @since 3.15.0 \"\"\"\n    publishDiagnostics: NotRequired[\"PublishDiagnosticsClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/publishDiagnostics` notification. \"\"\"\n    callHierarchy: NotRequired[\"CallHierarchyClientCapabilities\"]\n    \"\"\" Capabilities specific to the various call hierarchy requests.\n\n    @since 3.16.0 \"\"\"\n    semanticTokens: NotRequired[\"SemanticTokensClientCapabilities\"]\n    \"\"\" Capabilities specific to the various semantic token request.\n\n    @since 3.16.0 \"\"\"\n    linkedEditingRange: NotRequired[\"LinkedEditingRangeClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/linkedEditingRange` request.\n\n    @since 3.16.0 \"\"\"\n    moniker: NotRequired[\"MonikerClientCapabilities\"]\n    \"\"\" Client capabilities specific to the `textDocument/moniker` request.\n\n    @since 3.16.0 \"\"\"\n    typeHierarchy: NotRequired[\"TypeHierarchyClientCapabilities\"]\n    \"\"\" Capabilities specific to the various type hierarchy requests.\n\n    @since 3.17.0 \"\"\"\n    inlineValue: NotRequired[\"InlineValueClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/inlineValue` request.\n\n    @since 3.17.0 \"\"\"\n    inlayHint: NotRequired[\"InlayHintClientCapabilities\"]\n    \"\"\" Capabilities specific to the `textDocument/inlayHint` request.\n\n    @since 3.17.0 \"\"\"\n    diagnostic: NotRequired[\"DiagnosticClientCapabilities\"]\n    \"\"\" Capabilities specific to the diagnostic pull model.\n\n    @since 3.17.0 \"\"\"\n\n\nclass NotebookDocumentClientCapabilities(TypedDict):\n    \"\"\"Capabilities specific to the notebook document support.\n\n    @since 3.17.0\"\"\"\n\n    synchronization: \"NotebookDocumentSyncClientCapabilities\"\n    \"\"\" Capabilities specific to notebook document synchronization\n\n    @since 3.17.0 \"\"\"\n\n\nclass WindowClientCapabilities(TypedDict):\n    workDoneProgress: NotRequired[bool]\n    \"\"\" It indicates whether the client supports server initiated\n    progress using the `window/workDoneProgress/create` request.\n\n    The capability also controls Whether client supports handling\n    of progress notifications. If set servers are allowed to report a\n    `workDoneProgress` property in the request specific server\n    capabilities.\n\n    @since 3.15.0 \"\"\"\n    showMessage: NotRequired[\"ShowMessageRequestClientCapabilities\"]\n    \"\"\" Capabilities specific to the showMessage request.\n\n    @since 3.16.0 \"\"\"\n    showDocument: NotRequired[\"ShowDocumentClientCapabilities\"]\n    \"\"\" Capabilities specific to the showDocument request.\n\n    @since 3.16.0 \"\"\"\n\n\nclass GeneralClientCapabilities(TypedDict):\n    \"\"\"General client capabilities.\n\n    @since 3.16.0\"\"\"\n\n    staleRequestSupport: NotRequired[\n        \"__GeneralClientCapabilities_staleRequestSupport_Type_1\"\n    ]\n    \"\"\" Client capability that signals how the client\n    handles stale requests (e.g. a request\n    for which the client will not process the response\n    anymore since the information is outdated).\n\n    @since 3.17.0 \"\"\"\n    regularExpressions: NotRequired[\"RegularExpressionsClientCapabilities\"]\n    \"\"\" Client capabilities specific to regular expressions.\n\n    @since 3.16.0 \"\"\"\n    markdown: NotRequired[\"MarkdownClientCapabilities\"]\n    \"\"\" Client capabilities specific to the client's markdown parser.\n\n    @since 3.16.0 \"\"\"\n    positionEncodings: NotRequired[List[\"PositionEncodingKind\"]]\n    \"\"\" The position encodings supported by the client. Client and server\n    have to agree on the same position encoding to ensure that offsets\n    (e.g. character position in a line) are interpreted the same on both\n    sides.\n\n    To keep the protocol backwards compatible the following applies: if\n    the value 'utf-16' is missing from the array of position encodings\n    servers can assume that the client supports UTF-16. UTF-16 is\n    therefore a mandatory encoding.\n\n    If omitted it defaults to ['utf-16'].\n\n    Implementation considerations: since the conversion from one encoding\n    into another requires the content of the file / line the conversion\n    is best done where the file is read which is usually on the server\n    side.\n\n    @since 3.17.0 \"\"\"\n\n\nclass RelativePattern(TypedDict):\n    \"\"\"A relative pattern is a helper to construct glob patterns that are matched\n    relatively to a base URI. The common value for a `baseUri` is a workspace\n    folder root, but it can be another absolute URI as well.\n\n    @since 3.17.0\"\"\"\n\n    baseUri: Union[\"WorkspaceFolder\", \"URI\"]\n    \"\"\" A workspace folder or a base URI to which this pattern will be matched\n    against relatively. \"\"\"\n    pattern: \"Pattern\"\n    \"\"\" The actual glob pattern; \"\"\"\n\n\nclass WorkspaceEditClientCapabilities(TypedDict):\n    documentChanges: NotRequired[bool]\n    \"\"\" The client supports versioned document changes in `WorkspaceEdit`s \"\"\"\n    resourceOperations: NotRequired[List[\"ResourceOperationKind\"]]\n    \"\"\" The resource operations the client supports. Clients should at least\n    support 'create', 'rename' and 'delete' files and folders.\n\n    @since 3.13.0 \"\"\"\n    failureHandling: NotRequired[\"FailureHandlingKind\"]\n    \"\"\" The failure handling strategy of a client if applying the workspace edit\n    fails.\n\n    @since 3.13.0 \"\"\"\n    normalizesLineEndings: NotRequired[bool]\n    \"\"\" Whether the client normalizes line endings to the client specific\n    setting.\n    If set to `true` the client will normalize line ending characters\n    in a workspace edit to the client-specified new line\n    character.\n\n    @since 3.16.0 \"\"\"\n    changeAnnotationSupport: NotRequired[\n        \"__WorkspaceEditClientCapabilities_changeAnnotationSupport_Type_1\"\n    ]\n    \"\"\" Whether the client in general supports change annotations on text edits,\n    create file, rename file and delete file changes.\n\n    @since 3.16.0 \"\"\"\n\n\nclass DidChangeConfigurationClientCapabilities(TypedDict):\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Did change configuration notification supports dynamic registration. \"\"\"\n\n\nclass DidChangeWatchedFilesClientCapabilities(TypedDict):\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Did change watched files notification supports dynamic registration. Please note\n    that the current protocol doesn't support static configuration for file changes\n    from the server side. \"\"\"\n    relativePatternSupport: NotRequired[bool]\n    \"\"\" Whether the client has support for {@link  RelativePattern relative pattern}\n    or not.\n\n    @since 3.17.0 \"\"\"\n\n\nclass WorkspaceSymbolClientCapabilities(TypedDict):\n    \"\"\"Client capabilities for a {@link WorkspaceSymbolRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Symbol request supports dynamic registration. \"\"\"\n    symbolKind: NotRequired[\"__WorkspaceSymbolClientCapabilities_symbolKind_Type_1\"]\n    \"\"\" Specific capabilities for the `SymbolKind` in the `workspace/symbol` request. \"\"\"\n    tagSupport: NotRequired[\"__WorkspaceSymbolClientCapabilities_tagSupport_Type_1\"]\n    \"\"\" The client supports tags on `SymbolInformation`.\n    Clients supporting tags have to handle unknown tags gracefully.\n\n    @since 3.16.0 \"\"\"\n    resolveSupport: NotRequired[\n        \"__WorkspaceSymbolClientCapabilities_resolveSupport_Type_1\"\n    ]\n    \"\"\" The client support partial workspace symbols. The client will send the\n    request `workspaceSymbol/resolve` to the server to resolve additional\n    properties.\n\n    @since 3.17.0 \"\"\"\n\n\nclass ExecuteCommandClientCapabilities(TypedDict):\n    \"\"\"The client capabilities of a {@link ExecuteCommandRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Execute command supports dynamic registration. \"\"\"\n\n\nclass SemanticTokensWorkspaceClientCapabilities(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    refreshSupport: NotRequired[bool]\n    \"\"\" Whether the client implementation supports a refresh request sent from\n    the server to the client.\n\n    Note that this event is global and will force the client to refresh all\n    semantic tokens currently shown. It should be used with absolute care\n    and is useful for situation where a server for example detects a project\n    wide change that requires such a calculation. \"\"\"\n\n\nclass CodeLensWorkspaceClientCapabilities(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    refreshSupport: NotRequired[bool]\n    \"\"\" Whether the client implementation supports a refresh request sent from the\n    server to the client.\n\n    Note that this event is global and will force the client to refresh all\n    code lenses currently shown. It should be used with absolute care and is\n    useful for situation where a server for example detect a project wide\n    change that requires such a calculation. \"\"\"\n\n\nclass FileOperationClientCapabilities(TypedDict):\n    \"\"\"Capabilities relating to events from file operations by the user in the client.\n\n    These events do not come from the file system, they come from user operations\n    like renaming a file in the UI.\n\n    @since 3.16.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether the client supports dynamic registration for file requests/notifications. \"\"\"\n    didCreate: NotRequired[bool]\n    \"\"\" The client has support for sending didCreateFiles notifications. \"\"\"\n    willCreate: NotRequired[bool]\n    \"\"\" The client has support for sending willCreateFiles requests. \"\"\"\n    didRename: NotRequired[bool]\n    \"\"\" The client has support for sending didRenameFiles notifications. \"\"\"\n    willRename: NotRequired[bool]\n    \"\"\" The client has support for sending willRenameFiles requests. \"\"\"\n    didDelete: NotRequired[bool]\n    \"\"\" The client has support for sending didDeleteFiles notifications. \"\"\"\n    willDelete: NotRequired[bool]\n    \"\"\" The client has support for sending willDeleteFiles requests. \"\"\"\n\n\nclass InlineValueWorkspaceClientCapabilities(TypedDict):\n    \"\"\"Client workspace capabilities specific to inline values.\n\n    @since 3.17.0\"\"\"\n\n    refreshSupport: NotRequired[bool]\n    \"\"\" Whether the client implementation supports a refresh request sent from the\n    server to the client.\n\n    Note that this event is global and will force the client to refresh all\n    inline values currently shown. It should be used with absolute care and is\n    useful for situation where a server for example detects a project wide\n    change that requires such a calculation. \"\"\"\n\n\nclass InlayHintWorkspaceClientCapabilities(TypedDict):\n    \"\"\"Client workspace capabilities specific to inlay hints.\n\n    @since 3.17.0\"\"\"\n\n    refreshSupport: NotRequired[bool]\n    \"\"\" Whether the client implementation supports a refresh request sent from\n    the server to the client.\n\n    Note that this event is global and will force the client to refresh all\n    inlay hints currently shown. It should be used with absolute care and\n    is useful for situation where a server for example detects a project wide\n    change that requires such a calculation. \"\"\"\n\n\nclass DiagnosticWorkspaceClientCapabilities(TypedDict):\n    \"\"\"Workspace client capabilities specific to diagnostic pull requests.\n\n    @since 3.17.0\"\"\"\n\n    refreshSupport: NotRequired[bool]\n    \"\"\" Whether the client implementation supports a refresh request sent from\n    the server to the client.\n\n    Note that this event is global and will force the client to refresh all\n    pulled diagnostics currently shown. It should be used with absolute care and\n    is useful for situation where a server for example detects a project wide\n    change that requires such a calculation. \"\"\"\n\n\nclass TextDocumentSyncClientCapabilities(TypedDict):\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether text document synchronization supports dynamic registration. \"\"\"\n    willSave: NotRequired[bool]\n    \"\"\" The client supports sending will save notifications. \"\"\"\n    willSaveWaitUntil: NotRequired[bool]\n    \"\"\" The client supports sending a will save request and\n    waits for a response providing text edits which will\n    be applied to the document before it is saved. \"\"\"\n    didSave: NotRequired[bool]\n    \"\"\" The client supports did save notifications. \"\"\"\n\n\nclass CompletionClientCapabilities(TypedDict):\n    \"\"\"Completion client capabilities\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether completion supports dynamic registration. \"\"\"\n    completionItem: NotRequired[\"__CompletionClientCapabilities_completionItem_Type_1\"]\n    \"\"\" The client supports the following `CompletionItem` specific\n    capabilities. \"\"\"\n    completionItemKind: NotRequired[\n        \"__CompletionClientCapabilities_completionItemKind_Type_1\"\n    ]\n    insertTextMode: NotRequired[\"InsertTextMode\"]\n    \"\"\" Defines how the client handles whitespace and indentation\n    when accepting a completion item that uses multi line\n    text in either `insertText` or `textEdit`.\n\n    @since 3.17.0 \"\"\"\n    contextSupport: NotRequired[bool]\n    \"\"\" The client supports to send additional context information for a\n    `textDocument/completion` request. \"\"\"\n    completionList: NotRequired[\"__CompletionClientCapabilities_completionList_Type_1\"]\n    \"\"\" The client supports the following `CompletionList` specific\n    capabilities.\n\n    @since 3.17.0 \"\"\"\n\n\nclass HoverClientCapabilities(TypedDict):\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether hover supports dynamic registration. \"\"\"\n    contentFormat: NotRequired[List[\"MarkupKind\"]]\n    \"\"\" Client supports the following content formats for the content\n    property. The order describes the preferred format of the client. \"\"\"\n\n\nclass SignatureHelpClientCapabilities(TypedDict):\n    \"\"\"Client Capabilities for a {@link SignatureHelpRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether signature help supports dynamic registration. \"\"\"\n    signatureInformation: NotRequired[\n        \"__SignatureHelpClientCapabilities_signatureInformation_Type_1\"\n    ]\n    \"\"\" The client supports the following `SignatureInformation`\n    specific properties. \"\"\"\n    contextSupport: NotRequired[bool]\n    \"\"\" The client supports to send additional context information for a\n    `textDocument/signatureHelp` request. A client that opts into\n    contextSupport will also support the `retriggerCharacters` on\n    `SignatureHelpOptions`.\n\n    @since 3.15.0 \"\"\"\n\n\nclass DeclarationClientCapabilities(TypedDict):\n    \"\"\"@since 3.14.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether declaration supports dynamic registration. If this is set to `true`\n    the client supports the new `DeclarationRegistrationOptions` return value\n    for the corresponding server capability as well. \"\"\"\n    linkSupport: NotRequired[bool]\n    \"\"\" The client supports additional metadata in the form of declaration links. \"\"\"\n\n\nclass DefinitionClientCapabilities(TypedDict):\n    \"\"\"Client Capabilities for a {@link DefinitionRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether definition supports dynamic registration. \"\"\"\n    linkSupport: NotRequired[bool]\n    \"\"\" The client supports additional metadata in the form of definition links.\n\n    @since 3.14.0 \"\"\"\n\n\nclass TypeDefinitionClientCapabilities(TypedDict):\n    \"\"\"Since 3.6.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration. If this is set to `true`\n    the client supports the new `TypeDefinitionRegistrationOptions` return value\n    for the corresponding server capability as well. \"\"\"\n    linkSupport: NotRequired[bool]\n    \"\"\" The client supports additional metadata in the form of definition links.\n\n    Since 3.14.0 \"\"\"\n\n\nclass ImplementationClientCapabilities(TypedDict):\n    \"\"\"@since 3.6.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration. If this is set to `true`\n    the client supports the new `ImplementationRegistrationOptions` return value\n    for the corresponding server capability as well. \"\"\"\n    linkSupport: NotRequired[bool]\n    \"\"\" The client supports additional metadata in the form of definition links.\n\n    @since 3.14.0 \"\"\"\n\n\nclass ReferenceClientCapabilities(TypedDict):\n    \"\"\"Client Capabilities for a {@link ReferencesRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether references supports dynamic registration. \"\"\"\n\n\nclass DocumentHighlightClientCapabilities(TypedDict):\n    \"\"\"Client Capabilities for a {@link DocumentHighlightRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether document highlight supports dynamic registration. \"\"\"\n\n\nclass DocumentSymbolClientCapabilities(TypedDict):\n    \"\"\"Client Capabilities for a {@link DocumentSymbolRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether document symbol supports dynamic registration. \"\"\"\n    symbolKind: NotRequired[\"__DocumentSymbolClientCapabilities_symbolKind_Type_1\"]\n    \"\"\" Specific capabilities for the `SymbolKind` in the\n    `textDocument/documentSymbol` request. \"\"\"\n    hierarchicalDocumentSymbolSupport: NotRequired[bool]\n    \"\"\" The client supports hierarchical document symbols. \"\"\"\n    tagSupport: NotRequired[\"__DocumentSymbolClientCapabilities_tagSupport_Type_1\"]\n    \"\"\" The client supports tags on `SymbolInformation`. Tags are supported on\n    `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.\n    Clients supporting tags have to handle unknown tags gracefully.\n\n    @since 3.16.0 \"\"\"\n    labelSupport: NotRequired[bool]\n    \"\"\" The client supports an additional label presented in the UI when\n    registering a document symbol provider.\n\n    @since 3.16.0 \"\"\"\n\n\nclass CodeActionClientCapabilities(TypedDict):\n    \"\"\"The Client Capabilities of a {@link CodeActionRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether code action supports dynamic registration. \"\"\"\n    codeActionLiteralSupport: NotRequired[\n        \"__CodeActionClientCapabilities_codeActionLiteralSupport_Type_1\"\n    ]\n    \"\"\" The client support code action literals of type `CodeAction` as a valid\n    response of the `textDocument/codeAction` request. If the property is not\n    set the request can only return `Command` literals.\n\n    @since 3.8.0 \"\"\"\n    isPreferredSupport: NotRequired[bool]\n    \"\"\" Whether code action supports the `isPreferred` property.\n\n    @since 3.15.0 \"\"\"\n    disabledSupport: NotRequired[bool]\n    \"\"\" Whether code action supports the `disabled` property.\n\n    @since 3.16.0 \"\"\"\n    dataSupport: NotRequired[bool]\n    \"\"\" Whether code action supports the `data` property which is\n    preserved between a `textDocument/codeAction` and a\n    `codeAction/resolve` request.\n\n    @since 3.16.0 \"\"\"\n    resolveSupport: NotRequired[\"__CodeActionClientCapabilities_resolveSupport_Type_1\"]\n    \"\"\" Whether the client supports resolving additional code action\n    properties via a separate `codeAction/resolve` request.\n\n    @since 3.16.0 \"\"\"\n    honorsChangeAnnotations: NotRequired[bool]\n    \"\"\" Whether the client honors the change annotations in\n    text edits and resource operations returned via the\n    `CodeAction#edit` property by for example presenting\n    the workspace edit in the user interface and asking\n    for confirmation.\n\n    @since 3.16.0 \"\"\"\n\n\nclass CodeLensClientCapabilities(TypedDict):\n    \"\"\"The client capabilities  of a {@link CodeLensRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether code lens supports dynamic registration. \"\"\"\n\n\nclass DocumentLinkClientCapabilities(TypedDict):\n    \"\"\"The client capabilities of a {@link DocumentLinkRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether document link supports dynamic registration. \"\"\"\n    tooltipSupport: NotRequired[bool]\n    \"\"\" Whether the client supports the `tooltip` property on `DocumentLink`.\n\n    @since 3.15.0 \"\"\"\n\n\nclass DocumentColorClientCapabilities(TypedDict):\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration. If this is set to `true`\n    the client supports the new `DocumentColorRegistrationOptions` return value\n    for the corresponding server capability as well. \"\"\"\n\n\nclass DocumentFormattingClientCapabilities(TypedDict):\n    \"\"\"Client capabilities of a {@link DocumentFormattingRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether formatting supports dynamic registration. \"\"\"\n\n\nclass DocumentRangeFormattingClientCapabilities(TypedDict):\n    \"\"\"Client capabilities of a {@link DocumentRangeFormattingRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether range formatting supports dynamic registration. \"\"\"\n\n\nclass DocumentOnTypeFormattingClientCapabilities(TypedDict):\n    \"\"\"Client capabilities of a {@link DocumentOnTypeFormattingRequest}.\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether on type formatting supports dynamic registration. \"\"\"\n\n\nclass RenameClientCapabilities(TypedDict):\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether rename supports dynamic registration. \"\"\"\n    prepareSupport: NotRequired[bool]\n    \"\"\" Client supports testing for validity of rename operations\n    before execution.\n\n    @since 3.12.0 \"\"\"\n    prepareSupportDefaultBehavior: NotRequired[\"PrepareSupportDefaultBehavior\"]\n    \"\"\" Client supports the default behavior result.\n\n    The value indicates the default behavior used by the\n    client.\n\n    @since 3.16.0 \"\"\"\n    honorsChangeAnnotations: NotRequired[bool]\n    \"\"\" Whether the client honors the change annotations in\n    text edits and resource operations returned via the\n    rename request's workspace edit by for example presenting\n    the workspace edit in the user interface and asking\n    for confirmation.\n\n    @since 3.16.0 \"\"\"\n\n\nclass FoldingRangeClientCapabilities(TypedDict):\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration for folding range\n    providers. If this is set to `true` the client supports the new\n    `FoldingRangeRegistrationOptions` return value for the corresponding\n    server capability as well. \"\"\"\n    rangeLimit: NotRequired[Uint]\n    \"\"\" The maximum number of folding ranges that the client prefers to receive\n    per document. The value serves as a hint, servers are free to follow the\n    limit. \"\"\"\n    lineFoldingOnly: NotRequired[bool]\n    \"\"\" If set, the client signals that it only supports folding complete lines.\n    If set, client will ignore specified `startCharacter` and `endCharacter`\n    properties in a FoldingRange. \"\"\"\n    foldingRangeKind: NotRequired[\n        \"__FoldingRangeClientCapabilities_foldingRangeKind_Type_1\"\n    ]\n    \"\"\" Specific options for the folding range kind.\n\n    @since 3.17.0 \"\"\"\n    foldingRange: NotRequired[\"__FoldingRangeClientCapabilities_foldingRange_Type_1\"]\n    \"\"\" Specific options for the folding range.\n\n    @since 3.17.0 \"\"\"\n\n\nclass SelectionRangeClientCapabilities(TypedDict):\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration for selection range providers. If this is set to `true`\n    the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server\n    capability as well. \"\"\"\n\n\nclass PublishDiagnosticsClientCapabilities(TypedDict):\n    \"\"\"The publish diagnostic client capabilities.\"\"\"\n\n    relatedInformation: NotRequired[bool]\n    \"\"\" Whether the clients accepts diagnostics with related information. \"\"\"\n    tagSupport: NotRequired[\"__PublishDiagnosticsClientCapabilities_tagSupport_Type_1\"]\n    \"\"\" Client supports the tag property to provide meta data about a diagnostic.\n    Clients supporting tags have to handle unknown tags gracefully.\n\n    @since 3.15.0 \"\"\"\n    versionSupport: NotRequired[bool]\n    \"\"\" Whether the client interprets the version property of the\n    `textDocument/publishDiagnostics` notification's parameter.\n\n    @since 3.15.0 \"\"\"\n    codeDescriptionSupport: NotRequired[bool]\n    \"\"\" Client supports a codeDescription property\n\n    @since 3.16.0 \"\"\"\n    dataSupport: NotRequired[bool]\n    \"\"\" Whether code action supports the `data` property which is\n    preserved between a `textDocument/publishDiagnostics` and\n    `textDocument/codeAction` request.\n\n    @since 3.16.0 \"\"\"\n\n\nclass CallHierarchyClientCapabilities(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration. If this is set to `true`\n    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`\n    return value for the corresponding server capability as well. \"\"\"\n\n\nclass SemanticTokensClientCapabilities(TypedDict):\n    \"\"\"@since 3.16.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration. If this is set to `true`\n    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`\n    return value for the corresponding server capability as well. \"\"\"\n    requests: \"__SemanticTokensClientCapabilities_requests_Type_1\"\n    \"\"\" Which requests the client supports and might send to the server\n    depending on the server's capability. Please note that clients might not\n    show semantic tokens or degrade some of the user experience if a range\n    or full request is advertised by the client but not provided by the\n    server. If for example the client capability `requests.full` and\n    `request.range` are both set to true but the server only provides a\n    range provider the client might not render a minimap correctly or might\n    even decide to not show any semantic tokens at all. \"\"\"\n    tokenTypes: List[str]\n    \"\"\" The token types that the client supports. \"\"\"\n    tokenModifiers: List[str]\n    \"\"\" The token modifiers that the client supports. \"\"\"\n    formats: List[\"TokenFormat\"]\n    \"\"\" The token formats the clients supports. \"\"\"\n    overlappingTokenSupport: NotRequired[bool]\n    \"\"\" Whether the client supports tokens that can overlap each other. \"\"\"\n    multilineTokenSupport: NotRequired[bool]\n    \"\"\" Whether the client supports tokens that can span multiple lines. \"\"\"\n    serverCancelSupport: NotRequired[bool]\n    \"\"\" Whether the client allows the server to actively cancel a\n    semantic token request, e.g. supports returning\n    LSPErrorCodes.ServerCancelled. If a server does the client\n    needs to retrigger the request.\n\n    @since 3.17.0 \"\"\"\n    augmentsSyntaxTokens: NotRequired[bool]\n    \"\"\" Whether the client uses semantic tokens to augment existing\n    syntax tokens. If set to `true` client side created syntax\n    tokens and semantic tokens are both used for colorization. If\n    set to `false` the client only uses the returned semantic tokens\n    for colorization.\n\n    If the value is `undefined` then the client behavior is not\n    specified.\n\n    @since 3.17.0 \"\"\"\n\n\nclass LinkedEditingRangeClientCapabilities(TypedDict):\n    \"\"\"Client capabilities for the linked editing range request.\n\n    @since 3.16.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration. If this is set to `true`\n    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`\n    return value for the corresponding server capability as well. \"\"\"\n\n\nclass MonikerClientCapabilities(TypedDict):\n    \"\"\"Client capabilities specific to the moniker request.\n\n    @since 3.16.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether moniker supports dynamic registration. If this is set to `true`\n    the client supports the new `MonikerRegistrationOptions` return value\n    for the corresponding server capability as well. \"\"\"\n\n\nclass TypeHierarchyClientCapabilities(TypedDict):\n    \"\"\"@since 3.17.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration. If this is set to `true`\n    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`\n    return value for the corresponding server capability as well. \"\"\"\n\n\nclass InlineValueClientCapabilities(TypedDict):\n    \"\"\"Client capabilities specific to inline values.\n\n    @since 3.17.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration for inline value providers. \"\"\"\n\n\nclass InlayHintClientCapabilities(TypedDict):\n    \"\"\"Inlay hint client capabilities.\n\n    @since 3.17.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether inlay hints support dynamic registration. \"\"\"\n    resolveSupport: NotRequired[\"__InlayHintClientCapabilities_resolveSupport_Type_1\"]\n    \"\"\" Indicates which properties a client can resolve lazily on an inlay\n    hint. \"\"\"\n\n\nclass DiagnosticClientCapabilities(TypedDict):\n    \"\"\"Client capabilities specific to diagnostic pull requests.\n\n    @since 3.17.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration. If this is set to `true`\n    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`\n    return value for the corresponding server capability as well. \"\"\"\n    relatedDocumentSupport: NotRequired[bool]\n    \"\"\" Whether the clients supports related documents for document diagnostic pulls. \"\"\"\n\n\nclass NotebookDocumentSyncClientCapabilities(TypedDict):\n    \"\"\"Notebook specific client capabilities.\n\n    @since 3.17.0\"\"\"\n\n    dynamicRegistration: NotRequired[bool]\n    \"\"\" Whether implementation supports dynamic registration. If this is\n    set to `true` the client supports the new\n    `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`\n    return value for the corresponding server capability as well. \"\"\"\n    executionSummarySupport: NotRequired[bool]\n    \"\"\" The client supports sending execution summary data per cell. \"\"\"\n\n\nclass ShowMessageRequestClientCapabilities(TypedDict):\n    \"\"\"Show message request client capabilities\"\"\"\n\n    messageActionItem: NotRequired[\n        \"__ShowMessageRequestClientCapabilities_messageActionItem_Type_1\"\n    ]\n    \"\"\" Capabilities specific to the `MessageActionItem` type. \"\"\"\n\n\nclass ShowDocumentClientCapabilities(TypedDict):\n    \"\"\"Client capabilities for the showDocument request.\n\n    @since 3.16.0\"\"\"\n\n    support: bool\n    \"\"\" The client has support for the showDocument\n    request. \"\"\"\n\n\nclass RegularExpressionsClientCapabilities(TypedDict):\n    \"\"\"Client capabilities specific to regular expressions.\n\n    @since 3.16.0\"\"\"\n\n    engine: str\n    \"\"\" The engine's name. \"\"\"\n    version: NotRequired[str]\n    \"\"\" The engine's version. \"\"\"\n\n\nclass MarkdownClientCapabilities(TypedDict):\n    \"\"\"Client capabilities specific to the used markdown parser.\n\n    @since 3.16.0\"\"\"\n\n    parser: str\n    \"\"\" The name of the parser. \"\"\"\n    version: NotRequired[str]\n    \"\"\" The version of the parser. \"\"\"\n    allowedTags: NotRequired[List[str]]\n    \"\"\" A list of HTML tags that the client allows / supports in\n    Markdown.\n\n    @since 3.17.0 \"\"\"\n\n\nclass __CodeActionClientCapabilities_codeActionLiteralSupport_Type_1(TypedDict):\n    codeActionKind: \"__CodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind_Type_1\"\n    \"\"\" The code action kind is support with the following value\n    set. \"\"\"\n\n\nclass __CodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind_Type_1(\n    TypedDict\n):\n    valueSet: List[\"CodeActionKind\"]\n    \"\"\" The code action kind values the client supports. When this\n    property exists the client also guarantees that it will\n    handle values outside its set gracefully and falls back\n    to a default value when unknown. \"\"\"\n\n\nclass __CodeActionClientCapabilities_resolveSupport_Type_1(TypedDict):\n    properties: List[str]\n    \"\"\" The properties that a client can resolve lazily. \"\"\"\n\n\nclass __CodeAction_disabled_Type_1(TypedDict):\n    reason: str\n    \"\"\" Human readable description of why the code action is currently disabled.\n\n    This is displayed in the code actions UI. \"\"\"\n\n\nclass __CompletionClientCapabilities_completionItemKind_Type_1(TypedDict):\n    valueSet: NotRequired[List[\"CompletionItemKind\"]]\n    \"\"\" The completion item kind values the client supports. When this\n    property exists the client also guarantees that it will\n    handle values outside its set gracefully and falls back\n    to a default value when unknown.\n\n    If this property is not present the client only supports\n    the completion items kinds from `Text` to `Reference` as defined in\n    the initial version of the protocol. \"\"\"\n\n\nclass __CompletionClientCapabilities_completionItem_Type_1(TypedDict):\n    snippetSupport: NotRequired[bool]\n    \"\"\" Client supports snippets as insert text.\n\n    A snippet can define tab stops and placeholders with `$1`, `$2`\n    and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n    the end of the snippet. Placeholders with equal identifiers are linked,\n    that is typing in one will update others too. \"\"\"\n    commitCharactersSupport: NotRequired[bool]\n    \"\"\" Client supports commit characters on a completion item. \"\"\"\n    documentationFormat: NotRequired[List[\"MarkupKind\"]]\n    \"\"\" Client supports the following content formats for the documentation\n    property. The order describes the preferred format of the client. \"\"\"\n    deprecatedSupport: NotRequired[bool]\n    \"\"\" Client supports the deprecated property on a completion item. \"\"\"\n    preselectSupport: NotRequired[bool]\n    \"\"\" Client supports the preselect property on a completion item. \"\"\"\n    tagSupport: NotRequired[\n        \"__CompletionClientCapabilities_completionItem_tagSupport_Type_1\"\n    ]\n    \"\"\" Client supports the tag property on a completion item. Clients supporting\n    tags have to handle unknown tags gracefully. Clients especially need to\n    preserve unknown tags when sending a completion item back to the server in\n    a resolve call.\n\n    @since 3.15.0 \"\"\"\n    insertReplaceSupport: NotRequired[bool]\n    \"\"\" Client support insert replace edit to control different behavior if a\n    completion item is inserted in the text or should replace text.\n\n    @since 3.16.0 \"\"\"\n    resolveSupport: NotRequired[\n        \"__CompletionClientCapabilities_completionItem_resolveSupport_Type_1\"\n    ]\n    \"\"\" Indicates which properties a client can resolve lazily on a completion\n    item. Before version 3.16.0 only the predefined properties `documentation`\n    and `details` could be resolved lazily.\n\n    @since 3.16.0 \"\"\"\n    insertTextModeSupport: NotRequired[\n        \"__CompletionClientCapabilities_completionItem_insertTextModeSupport_Type_1\"\n    ]\n    \"\"\" The client supports the `insertTextMode` property on\n    a completion item to override the whitespace handling mode\n    as defined by the client (see `insertTextMode`).\n\n    @since 3.16.0 \"\"\"\n    labelDetailsSupport: NotRequired[bool]\n    \"\"\" The client has support for completion item label\n    details (see also `CompletionItemLabelDetails`).\n\n    @since 3.17.0 \"\"\"\n\n\nclass __CompletionClientCapabilities_completionItem_insertTextModeSupport_Type_1(\n    TypedDict\n):\n    valueSet: List[\"InsertTextMode\"]\n\n\nclass __CompletionClientCapabilities_completionItem_resolveSupport_Type_1(TypedDict):\n    properties: List[str]\n    \"\"\" The properties that a client can resolve lazily. \"\"\"\n\n\nclass __CompletionClientCapabilities_completionItem_tagSupport_Type_1(TypedDict):\n    valueSet: List[\"CompletionItemTag\"]\n    \"\"\" The tags supported by the client. \"\"\"\n\n\nclass __CompletionClientCapabilities_completionList_Type_1(TypedDict):\n    itemDefaults: NotRequired[List[str]]\n    \"\"\" The client supports the following itemDefaults on\n    a completion list.\n\n    The value lists the supported property names of the\n    `CompletionList.itemDefaults` object. If omitted\n    no properties are supported.\n\n    @since 3.17.0 \"\"\"\n\n\nclass __CompletionList_itemDefaults_Type_1(TypedDict):\n    commitCharacters: NotRequired[List[str]]\n    \"\"\" A default commit character set.\n\n    @since 3.17.0 \"\"\"\n    editRange: NotRequired[\n        Union[\"Range\", \"__CompletionList_itemDefaults_editRange_Type_1\"]\n    ]\n    \"\"\" A default edit range.\n\n    @since 3.17.0 \"\"\"\n    insertTextFormat: NotRequired[\"InsertTextFormat\"]\n    \"\"\" A default insert text format.\n\n    @since 3.17.0 \"\"\"\n    insertTextMode: NotRequired[\"InsertTextMode\"]\n    \"\"\" A default insert text mode.\n\n    @since 3.17.0 \"\"\"\n    data: NotRequired[\"LSPAny\"]\n    \"\"\" A default data value.\n\n    @since 3.17.0 \"\"\"\n\n\nclass __CompletionList_itemDefaults_editRange_Type_1(TypedDict):\n    insert: \"Range\"\n    replace: \"Range\"\n\n\nclass __CompletionOptions_completionItem_Type_1(TypedDict):\n    labelDetailsSupport: NotRequired[bool]\n    \"\"\" The server has support for completion item label\n    details (see also `CompletionItemLabelDetails`) when\n    receiving a completion item in a resolve call.\n\n    @since 3.17.0 \"\"\"\n\n\nclass __CompletionOptions_completionItem_Type_2(TypedDict):\n    labelDetailsSupport: NotRequired[bool]\n    \"\"\" The server has support for completion item label\n    details (see also `CompletionItemLabelDetails`) when\n    receiving a completion item in a resolve call.\n\n    @since 3.17.0 \"\"\"\n\n\nclass __DocumentSymbolClientCapabilities_symbolKind_Type_1(TypedDict):\n    valueSet: NotRequired[List[\"SymbolKind\"]]\n    \"\"\" The symbol kind values the client supports. When this\n    property exists the client also guarantees that it will\n    handle values outside its set gracefully and falls back\n    to a default value when unknown.\n\n    If this property is not present the client only supports\n    the symbol kinds from `File` to `Array` as defined in\n    the initial version of the protocol. \"\"\"\n\n\nclass __DocumentSymbolClientCapabilities_tagSupport_Type_1(TypedDict):\n    valueSet: List[\"SymbolTag\"]\n    \"\"\" The tags supported by the client. \"\"\"\n\n\nclass __FoldingRangeClientCapabilities_foldingRangeKind_Type_1(TypedDict):\n    valueSet: NotRequired[List[\"FoldingRangeKind\"]]\n    \"\"\" The folding range kind values the client supports. When this\n    property exists the client also guarantees that it will\n    handle values outside its set gracefully and falls back\n    to a default value when unknown. \"\"\"\n\n\nclass __FoldingRangeClientCapabilities_foldingRange_Type_1(TypedDict):\n    collapsedText: NotRequired[bool]\n    \"\"\" If set, the client signals that it supports setting collapsedText on\n    folding ranges to display custom labels instead of the default text.\n\n    @since 3.17.0 \"\"\"\n\n\nclass __GeneralClientCapabilities_staleRequestSupport_Type_1(TypedDict):\n    cancel: bool\n    \"\"\" The client will actively cancel the request. \"\"\"\n    retryOnContentModified: List[str]\n    \"\"\" The list of requests for which the client\n    will retry the request if it receives a\n    response with error code `ContentModified` \"\"\"\n\n\nclass __InitializeResult_serverInfo_Type_1(TypedDict):\n    name: str\n    \"\"\" The name of the server as defined by the server. \"\"\"\n    version: NotRequired[str]\n    \"\"\" The server's version as defined by the server. \"\"\"\n\n\nclass __InlayHintClientCapabilities_resolveSupport_Type_1(TypedDict):\n    properties: List[str]\n    \"\"\" The properties that a client can resolve lazily. \"\"\"\n\n\nclass __MarkedString_Type_1(TypedDict):\n    language: str\n    value: str\n\n\nclass __NotebookDocumentChangeEvent_cells_Type_1(TypedDict):\n    structure: NotRequired[\"__NotebookDocumentChangeEvent_cells_structure_Type_1\"]\n    \"\"\" Changes to the cell structure to add or\n    remove cells. \"\"\"\n    data: NotRequired[List[\"NotebookCell\"]]\n    \"\"\" Changes to notebook cells properties like its\n    kind, execution summary or metadata. \"\"\"\n    textContent: NotRequired[\n        List[\"__NotebookDocumentChangeEvent_cells_textContent_Type_1\"]\n    ]\n    \"\"\" Changes to the text content of notebook cells. \"\"\"\n\n\nclass __NotebookDocumentChangeEvent_cells_structure_Type_1(TypedDict):\n    array: \"NotebookCellArrayChange\"\n    \"\"\" The change to the cell array. \"\"\"\n    didOpen: NotRequired[List[\"TextDocumentItem\"]]\n    \"\"\" Additional opened cell text documents. \"\"\"\n    didClose: NotRequired[List[\"TextDocumentIdentifier\"]]\n    \"\"\" Additional closed cell text documents. \"\"\"\n\n\nclass __NotebookDocumentChangeEvent_cells_textContent_Type_1(TypedDict):\n    document: \"VersionedTextDocumentIdentifier\"\n    changes: List[\"TextDocumentContentChangeEvent\"]\n\n\nclass __NotebookDocumentFilter_Type_1(TypedDict):\n    notebookType: str\n    \"\"\" The type of the enclosing notebook. \"\"\"\n    scheme: NotRequired[str]\n    \"\"\" A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. \"\"\"\n    pattern: NotRequired[str]\n    \"\"\" A glob pattern. \"\"\"\n\n\nclass __NotebookDocumentFilter_Type_2(TypedDict):\n    notebookType: NotRequired[str]\n    \"\"\" The type of the enclosing notebook. \"\"\"\n    scheme: str\n    \"\"\" A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. \"\"\"\n    pattern: NotRequired[str]\n    \"\"\" A glob pattern. \"\"\"\n\n\nclass __NotebookDocumentFilter_Type_3(TypedDict):\n    notebookType: NotRequired[str]\n    \"\"\" The type of the enclosing notebook. \"\"\"\n    scheme: NotRequired[str]\n    \"\"\" A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. \"\"\"\n    pattern: str\n    \"\"\" A glob pattern. \"\"\"\n\n\nclass __NotebookDocumentSyncOptions_notebookSelector_Type_1(TypedDict):\n    notebook: Union[str, \"NotebookDocumentFilter\"]\n    \"\"\" The notebook to be synced If a string\n    value is provided it matches against the\n    notebook type. '*' matches every notebook. \"\"\"\n    cells: NotRequired[\n        List[\"__NotebookDocumentSyncOptions_notebookSelector_cells_Type_1\"]\n    ]\n    \"\"\" The cells of the matching notebook to be synced. \"\"\"\n\n\nclass __NotebookDocumentSyncOptions_notebookSelector_Type_2(TypedDict):\n    notebook: NotRequired[Union[str, \"NotebookDocumentFilter\"]]\n    \"\"\" The notebook to be synced If a string\n    value is provided it matches against the\n    notebook type. '*' matches every notebook. \"\"\"\n    cells: List[\"__NotebookDocumentSyncOptions_notebookSelector_cells_Type_2\"]\n    \"\"\" The cells of the matching notebook to be synced. \"\"\"\n\n\nclass __NotebookDocumentSyncOptions_notebookSelector_Type_3(TypedDict):\n    notebook: Union[str, \"NotebookDocumentFilter\"]\n    \"\"\" The notebook to be synced If a string\n    value is provided it matches against the\n    notebook type. '*' matches every notebook. \"\"\"\n    cells: NotRequired[\n        List[\"__NotebookDocumentSyncOptions_notebookSelector_cells_Type_3\"]\n    ]\n    \"\"\" The cells of the matching notebook to be synced. \"\"\"\n\n\nclass __NotebookDocumentSyncOptions_notebookSelector_Type_4(TypedDict):\n    notebook: NotRequired[Union[str, \"NotebookDocumentFilter\"]]\n    \"\"\" The notebook to be synced If a string\n    value is provided it matches against the\n    notebook type. '*' matches every notebook. \"\"\"\n    cells: List[\"__NotebookDocumentSyncOptions_notebookSelector_cells_Type_4\"]\n    \"\"\" The cells of the matching notebook to be synced. \"\"\"\n\n\nclass __NotebookDocumentSyncOptions_notebookSelector_cells_Type_1(TypedDict):\n    language: str\n\n\nclass __NotebookDocumentSyncOptions_notebookSelector_cells_Type_2(TypedDict):\n    language: str\n\n\nclass __NotebookDocumentSyncOptions_notebookSelector_cells_Type_3(TypedDict):\n    language: str\n\n\nclass __NotebookDocumentSyncOptions_notebookSelector_cells_Type_4(TypedDict):\n    language: str\n\n\nclass __PrepareRenameResult_Type_1(TypedDict):\n    range: \"Range\"\n    placeholder: str\n\n\nclass __PrepareRenameResult_Type_2(TypedDict):\n    defaultBehavior: bool\n\n\nclass __PublishDiagnosticsClientCapabilities_tagSupport_Type_1(TypedDict):\n    valueSet: List[\"DiagnosticTag\"]\n    \"\"\" The tags supported by the client. \"\"\"\n\n\nclass __SemanticTokensClientCapabilities_requests_Type_1(TypedDict):\n    range: NotRequired[Union[bool, dict]]\n    \"\"\" The client will send the `textDocument/semanticTokens/range` request if\n    the server provides a corresponding handler. \"\"\"\n    full: NotRequired[\n        Union[bool, \"__SemanticTokensClientCapabilities_requests_full_Type_1\"]\n    ]\n    \"\"\" The client will send the `textDocument/semanticTokens/full` request if\n    the server provides a corresponding handler. \"\"\"\n\n\nclass __SemanticTokensClientCapabilities_requests_full_Type_1(TypedDict):\n    delta: NotRequired[bool]\n    \"\"\" The client will send the `textDocument/semanticTokens/full/delta` request if\n    the server provides a corresponding handler. \"\"\"\n\n\nclass __SemanticTokensOptions_full_Type_1(TypedDict):\n    delta: NotRequired[bool]\n    \"\"\" The server supports deltas for full documents. \"\"\"\n\n\nclass __SemanticTokensOptions_full_Type_2(TypedDict):\n    delta: NotRequired[bool]\n    \"\"\" The server supports deltas for full documents. \"\"\"\n\n\nclass __ServerCapabilities_workspace_Type_1(TypedDict):\n    workspaceFolders: NotRequired[\"WorkspaceFoldersServerCapabilities\"]\n    \"\"\" The server supports workspace folder.\n\n    @since 3.6.0 \"\"\"\n    fileOperations: NotRequired[\"FileOperationOptions\"]\n    \"\"\" The server is interested in notifications/requests for operations on files.\n\n    @since 3.16.0 \"\"\"\n\n\nclass __ShowMessageRequestClientCapabilities_messageActionItem_Type_1(TypedDict):\n    additionalPropertiesSupport: NotRequired[bool]\n    \"\"\" Whether the client supports additional attributes which\n    are preserved and send back to the server in the\n    request's response. \"\"\"\n\n\nclass __SignatureHelpClientCapabilities_signatureInformation_Type_1(TypedDict):\n    documentationFormat: NotRequired[List[\"MarkupKind\"]]\n    \"\"\" Client supports the following content formats for the documentation\n    property. The order describes the preferred format of the client. \"\"\"\n    parameterInformation: NotRequired[\n        \"__SignatureHelpClientCapabilities_signatureInformation_parameterInformation_Type_1\"\n    ]\n    \"\"\" Client capabilities specific to parameter information. \"\"\"\n    activeParameterSupport: NotRequired[bool]\n    \"\"\" The client supports the `activeParameter` property on `SignatureInformation`\n    literal.\n\n    @since 3.16.0 \"\"\"\n\n\nclass __SignatureHelpClientCapabilities_signatureInformation_parameterInformation_Type_1(\n    TypedDict\n):\n    labelOffsetSupport: NotRequired[bool]\n    \"\"\" The client supports processing label offsets instead of a\n    simple label string.\n\n    @since 3.14.0 \"\"\"\n\n\nclass __TextDocumentContentChangeEvent_Type_1(TypedDict):\n    range: \"Range\"\n    \"\"\" The range of the document that changed. \"\"\"\n    rangeLength: NotRequired[Uint]\n    \"\"\" The optional length of the range that got replaced.\n\n    @deprecated use range instead. \"\"\"\n    text: str\n    \"\"\" The new text for the provided range. \"\"\"\n\n\nclass __TextDocumentContentChangeEvent_Type_2(TypedDict):\n    text: str\n    \"\"\" The new text of the whole document. \"\"\"\n\n\nclass __TextDocumentFilter_Type_1(TypedDict):\n    language: str\n    \"\"\" A language id, like `typescript`. \"\"\"\n    scheme: NotRequired[str]\n    \"\"\" A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. \"\"\"\n    pattern: NotRequired[str]\n    \"\"\" A glob pattern, like `*.{ts,js}`. \"\"\"\n\n\nclass __TextDocumentFilter_Type_2(TypedDict):\n    language: NotRequired[str]\n    \"\"\" A language id, like `typescript`. \"\"\"\n    scheme: str\n    \"\"\" A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. \"\"\"\n    pattern: NotRequired[str]\n    \"\"\" A glob pattern, like `*.{ts,js}`. \"\"\"\n\n\nclass __TextDocumentFilter_Type_3(TypedDict):\n    language: NotRequired[str]\n    \"\"\" A language id, like `typescript`. \"\"\"\n    scheme: NotRequired[str]\n    \"\"\" A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. \"\"\"\n    pattern: str\n    \"\"\" A glob pattern, like `*.{ts,js}`. \"\"\"\n\n\nclass __WorkspaceEditClientCapabilities_changeAnnotationSupport_Type_1(TypedDict):\n    groupsOnLabel: NotRequired[bool]\n    \"\"\" Whether the client groups edits with equal labels into tree nodes,\n    for instance all edits labelled with \"Changes in Strings\" would\n    be a tree node. \"\"\"\n\n\nclass __WorkspaceSymbolClientCapabilities_resolveSupport_Type_1(TypedDict):\n    properties: List[str]\n    \"\"\" The properties that a client can resolve lazily. Usually\n    `location.range` \"\"\"\n\n\nclass __WorkspaceSymbolClientCapabilities_symbolKind_Type_1(TypedDict):\n    valueSet: NotRequired[List[\"SymbolKind\"]]\n    \"\"\" The symbol kind values the client supports. When this\n    property exists the client also guarantees that it will\n    handle values outside its set gracefully and falls back\n    to a default value when unknown.\n\n    If this property is not present the client only supports\n    the symbol kinds from `File` to `Array` as defined in\n    the initial version of the protocol. \"\"\"\n\n\nclass __WorkspaceSymbolClientCapabilities_tagSupport_Type_1(TypedDict):\n    valueSet: List[\"SymbolTag\"]\n    \"\"\" The tags supported by the client. \"\"\"\n\n\nclass __WorkspaceSymbol_location_Type_1(TypedDict):\n    uri: \"DocumentUri\"\n\n\nclass ___InitializeParams_clientInfo_Type_1(TypedDict):\n    name: str\n    \"\"\" The name of the client as defined by the client. \"\"\"\n    version: NotRequired[str]\n    \"\"\" The client's version as defined by the client. \"\"\"\n"}
{"type": "source_file", "path": "src/hyperagent/prompts/editor.py", "content": "system_edit = \"\"\"You are an expert in edit existing codebase, you're so good at editing or generate source code files. \nAlways think step-by-step carefully before decision. You should aware about the code context, and surrounding variables and functions. Do not add some undefined variables.\n    \n### Guidelines:\n1  Only use the provided and predefined functions as the functions. Do not use any other functions.\n2. Always open the file before editing to see latest code!. \n3. If you have to edit the code, ensure the code is correct with syntax, dependency, consistent with the file and the codebase.\n4. Return final answer if your code is succesfully applied. You first can open a file to get the context and use editor to apply the patch. You have to generate code that is correct with syntax, ensure the dependency, consistent with the file and the codebase.\n5. If you have the exact name of the file and symbol to edit, you can use the code search to find the definition of the symbol. If there's no definition, you can use open open_file tool.\n6. Pay attention to original indentation! Something like this \"patch\": \"    def something(self, s):\\n    # Check if something is something\\n        return something if the original code is indented with 4 spaces or  \"def something(self, s):\\n    # Check if something is something\\n        return something if the original block is not indented.\n7. The patch should be a block of code that be replaced into the code.\n\n### Functions:\n1. **Editing A File with replaced code block**:\n   Arguments:\n   - relative_file_path: str - The path to the file to edit.\n   - start_line: int - The line number where the original target code block starts.\n   - end_line: int - The line number where the original target code block ends.\n   - patch: str - The code to replace the current selection with, make sure the code is syntactically correct, identation is correct, and the code resolved the request.\n   Action:\n   ```python\n   patch = \\'\\'\\'def new_function(self, s):\\n    # Check if something is something\\n        return something\\'\\'\\'\n   result = editor._run(relative_file_path=\"module/file.py\", start_line=12, end_line=24, patch=patch)\n   print(result)\n   ```\n2. **Exploring Folder Tree Structure**:\n   Arguments:\n   - relative_path: str - The path to the folder to explore.\n   - depth: int - The depth of the folder structure to explore.\n   Action:\n   ```python\n   result = get_folder_structure._run(relative_path=\"module/\", depth=2)\n   print(result)\n   ```\n3. **Opening a File and Searching Content**:\n   Arguments:\n   - relative_file_path: str - The path to the file to open.\n   Action:\n   ```python\n   result = open_file_gen._run(relative_file_path=\"module/file.py\", keywords=[\"some_function\"])\n   print(result)\n   ```\n4. **Finding Definition of a Symbol**:\n   Arguments:\n   - word: str - The alias name of the symbol to find the definition for.\n   - relative_path: str - The path to the file where the alias is used.\n   - line: int - The line number where the alias is used.\n   Action:\n   ```python\n   result = go_to_def._run(word=\"some_function\", relative_path=\"module/file.py\", line=10)\n   print(result)\n   ```\n5. **Finding All References of a Symbol**:\n   Arguments:\n   - word: str - The alias name of the symbol to find references for.\n   - relative_file_path: str - The path to the file where the alias is used.\n   - line: int - The line number where the alias is used.\n   Action:\n   ```python\n   result = find_all_refs._run(word=\"some_function\", relative_file_path=\"module/file.py\", line=10)\n   print(result)\n   ```\n   \nAlways reply with Thought and Action with python code.\"\"\""}
{"type": "source_file", "path": "src/hyperagent/multilspy/type_helpers.py", "content": "\"\"\"\nThis module provides type-helpers used across multilspy implementation\n\"\"\"\n\nimport inspect\n\nfrom typing import Callable, TypeVar, Type\n\nR = TypeVar(\"R\", bound=object)\n\ndef ensure_all_methods_implemented(\n    source_cls: Type[object],\n) -> Callable[[Type[R]], Type[R]]:\n    \"\"\"\n    A decorator to ensure that all methods of source_cls class are implemented in the decorated class.\n    \"\"\"\n\n    def check_all_methods_implemented(target_cls: R) -> R:\n        for name, _ in inspect.getmembers(source_cls, inspect.isfunction):\n            if name not in target_cls.__dict__ or not callable(target_cls.__dict__[name]):\n                raise NotImplementedError(f\"{name} is not implemented in {target_cls}\")\n\n        return target_cls\n\n    return check_all_methods_implemented"}
{"type": "source_file", "path": "src/hyperagent/prompts/__init__.py", "content": ""}
{"type": "source_file", "path": "src/hyperagent/llm_multilspy.py", "content": "from hyperagent.multilspy import SyncLanguageServer\nfrom hyperagent.multilspy.multilspy_config import MultilspyConfig\nfrom hyperagent.multilspy.multilspy_logger import MultilspyLogger\nfrom hyperagent.utils import matching_kind_symbol, matching_symbols, add_num_line, get_text, word_to_position\nfrom hyperagent.multilspy.lsp_protocol_handler.lsp_types import SymbolKind\n\nclass LSPToolKit:\n    \"\"\"\n        This class serves as a natural language interface for LLM to interact with Language Server Protocol.\n        It provides functionalities like opening files, accessing text, finding definitions and finding symbols\n        related to words in specified documents.\n\n        root_path: str - the root path of your codebase,\n        language: str, optional - the language of your code (default is 'python')\n    \"\"\"\n    def __init__(self, root_path, language=\"python\"):\n        \"\"\"\n        Creating a language server with root path and language configuration provided by user\n\n        MultilspyConfig: A class that helps to configure Language Server for multiple languages\n        MultilspyLogger: A class that helps to Log LSP operations and Debugging\n        \"\"\"\n        self.root_path = root_path\n        self.language = language\n        self.server = SyncLanguageServer.create(MultilspyConfig(code_language=language), MultilspyLogger(), root_path)\n\n    def open_file(self, relative_path):\n        \"\"\"\n        Open a file using the file's relative path to the root path of code base\n\n        Args:\n            relative_path: str - relative path of file to codebase root path.\n\n        Returns:\n            the file text if successful, Else returns an error message string.\n        \"\"\"\n        with self.server.start_server():\n            with self.server.open_file(relative_path):\n                result = self.server.get_open_file_text(relative_path)\n\n        return result\n\n    def get_definition(self, word, relative_path, line=None, offset=0, verbose=False):\n        \"\"\"\n        Get the definition of a given identifier in a source file.\n        Args:\n            word: str - Word whose definition needs to be found\n            relative_path: str - Relative path of the file in which the definition needs to be found.\n            line: int, optional - Line number where the word is located. If not provided, the word's first occurrence from top will be considered\n            offset: int, optional - The number of characters to be ignored from the beginning of the line.\n            verbose: bool, optional - If true, gives detailed output showing all symbol information along with the definition\n            \n        Returns:\n            Returns the definition of word if found. If not found, returns an error message.\n        \"\"\"\n        doc = self.open_file(relative_path)\n        cursor_pos = word_to_position(doc, word, line=line, offset=offset)\n        # Verifying if the cursor position exists and then getting the definition. In case cursor position does not exist, then returns error message.\n        if cursor_pos is not None:\n            with self.server.start_server():\n                output = self.server.request_definition(relative_path, **cursor_pos)\n        else:\n            return \"The tool cannot find the word in the file\"\n        \n        # If verbose setting is true, then gives detailed information for first symbol from output. In case the symbol doe not have a location attribute then shows the rang attribute.\n        if verbose and len(output) > 0:\n            symbols = self.get_symbols(output[0][\"relativePath\"], verbose=False)\n            symbol = matching_symbols(symbols, output[0])\n            if symbol is None:\n                return \"Please try again with semantic or code search tool\"\n            symbol_type = matching_kind_symbol(symbol)\n            definition = \"\"\n            if \"location\" not in symbol:\n                if symbol[\"range\"][\"end\"][\"line\"] - symbol[\"range\"][\"start\"][\"line\"] > 100:\n                    definition = \"Too long to display, you should use open_file tool to view partial content step by step.\"\n                    symbol[\"range\"][\"end\"][\"line\"] = symbol[\"range\"][\"start\"][\"line\"] + 100\n                definition += add_num_line(get_text(self.open_file(output[0][\"relativePath\"]), symbol[\"range\"]), symbol[\"range\"][\"start\"][\"line\"])\n            else:\n                if symbol[\"location\"][\"range\"][\"end\"][\"line\"] - symbol[\"location\"][\"range\"][\"start\"][\"line\"] > 100:\n                    definition = \"Too long to display, you should use open_file tool to view partial content step by step.\"\n                    symbol[\"location\"][\"range\"][\"end\"][\"line\"] = symbol[\"location\"][\"range\"][\"start\"][\"line\"] + 100\n                definition = add_num_line(get_text(self.open_file(output[0][\"relativePath\"]), symbol[\"location\"][\"range\"]), symbol[\"location\"][\"range\"][\"start\"][\"line\"])\n            output = \"Name: \" + str(symbol[\"name\"]) + \"\\n\" + \"Type: \" + str(symbol_type) + \"\\n\" + \"Definition: \" + definition\n        \n        return output\n    \n    def get_symbols(self, file_path: str, preview_size: int = 10, verbose: bool = True) -> list:\n        \"\"\"\n        Get all symbols in a file\n\n        Args:\n            file_path (str): relative path to the file\n            preview_size (int, optional): only preview a set number of lines of definitions to save number of tokens. Defaults to 10.\n            verbose (bool, optional): print detailed_output if set to True. Defaults to True.\n\n        Returns:\n            list: Returns either a list of symbols or a detailed list of symbols based on the detailed_output flag\n        \"\"\"\n        with self.server.start_server():\n            file_symbols = self.server.request_document_symbols(file_path)[0]\n\n\n        if not verbose:\n            return file_symbols\n\n        file_source = self.open_file(file_path)\n        detailed_list = []\n\n        with self.server.start_server():\n            for symbol in file_symbols:\n                symbol_definition = get_text(file_source, symbol[\"range\"])\n                # TODO: Add more primary symbols depending on the language\n                primary_symbols = [SymbolKind.Class, SymbolKind.Function, SymbolKind.Struct]\n                primary_symbols = [int(symbol_kind) for symbol_kind in primary_symbols]\n                if symbol[\"kind\"] in primary_symbols:\n                    symbol_line_location = next((line_num for line_num, line in enumerate(symbol_definition.split(\"\\n\")) if symbol[\"name\"] in line), 0)\n                    try:\n                        character_index = symbol_definition.split(\"\\n\")[symbol_line_location].index(symbol[\"name\"])\n                        mouse_over_info = self.server.request_hover(file_path, symbol[\"range\"][\"start\"][\"line\"], character_index)\n                        hover_documentation = mouse_over_info[\"contents\"] if mouse_over_info else \"None\"\n\n                        if \"value\" not in hover_documentation:\n                            hover_documentation = \"None\"\n                            # definition_preview = \"\\n\".join(symbol_definition.split(\"\\n\")[:preview_size+4])\n                        # else:\n                            # definition_preview = \"\\n\".join(symbol_definition.split(\"\\n\")[:preview_size])\n                        if \"import\" in symbol_definition:\n                            continue\n                        definition_with_line_numbers = add_num_line(symbol_definition, symbol[\"range\"][\"start\"][\"line\"])\n                        output_item = \"\\n\".join([\n                            \"Name: \" + str(symbol[\"name\"]),\n                            \"Type: \" + str(matching_kind_symbol(symbol)),\n                            \"Definition: \" + str(definition_with_line_numbers),\n                            \"Documentation: \" + str(hover_documentation)\n                        ])\n                        detailed_list.append(output_item)\n                    except ValueError:\n                        pass\n        file_symbols = [symbol_item for symbol_item in detailed_list if symbol_item is not None]\n        return file_symbols\n    \n    def get_references(\n        self,\n        search_word: str,\n        file_path: str,\n        line_number: int = None,\n        offset_value: int = 0,\n        verbose: bool = False,\n        context_limit: int = 10\n    ) -> str:\n        \"\"\"\n        This function is used to get references of a particular identifier in a codebase. It can also provide detailed\n        output if verbose argument is set to true.\n\n        Args:\n            search_word (str): The identifier to be searched in the codebase.\n            file_path (str): Path of the file in which to search the identifier.\n            line_number (int, optional): Line number to start the search from. Defaults to None.\n            offset_value (int, optional): The number of positions to ignore from the start of the line. Defaults to 0.\n            verbose (bool, optional): If set to True, detailed output will be returned. Defaults to False.\n            context_limit (int, optional): Defines the number of lines to print before and after the matched line in verbose mode. Defaults to 10.\n\n        Returns:\n            str: This function returns a string consisting of locations of the search identifier in the document.\n                In verbose mode, this string contains additional information at each location such as implementation code.\n        \"\"\"\n        document_contents = self.open_file(file_path)\n        \n        if line_number is None:\n            # Handle cases where the line number is either incorrect or not known\n            cursor_position = word_to_position(document_contents, search_word, line=None, offset=offset_value)\n        else:\n            try:\n                cursor_position = word_to_position(document_contents, search_word, line=line_number, offset=offset_value)\n            except:\n                cursor_position = word_to_position(document_contents, search_word, line=None, offset=offset_value)\n\n        if cursor_position is None:\n            return \"The tool cannot find the word in the file\"\n\n        with self.server.start_server():\n            references_output = self.server.request_references(file_path, **cursor_position)\n\n        if verbose:\n            detailed_output = []\n            for reference_item in references_output:\n                document_item = self.open_file(reference_item[\"relativePath\"])\n                reference_item[\"range\"][\"start\"][\"line\"] = max(0, reference_item[\"range\"][\"start\"][\"line\"] - context_limit)\n                reference_item[\"range\"][\"end\"][\"line\"] = min(len(document_item.splitlines(True)), reference_item[\"range\"][\"end\"][\"line\"] + context_limit)\n                reference_item[\"range\"][\"start\"][\"character\"] = 0\n                reference_item[\"range\"][\"end\"][\"character\"] = len(document_item.splitlines(True)[reference_item[\"range\"][\"end\"][\"line\"]-1])\n                reference_code = get_text(document_item, reference_item[\"range\"])\n                formatted_results = []\n                for index, code_line in enumerate(reference_code.split(\"\\n\")):\n                    code_line = str(index + reference_item[\"range\"][\"start\"][\"line\"]) + \" \" + code_line\n                    formatted_results.append(code_line)\n\n                reference_code = \"\\n\".join(formatted_results)\n\n                reference_info = \"File Name: \" + str(reference_item[\"relativePath\"]) + \"\\n\" + \"Implementation: \" + str(reference_code) + \"\\n\"\n                detailed_output.append(reference_info)\n            references_output = detailed_output\n        return references_output\n\n"}
{"type": "source_file", "path": "src/hyperagent/pilot.py", "content": "import os\nimport warnings\nfrom typing import Optional\nfrom autogen import UserProxyAgent\nfrom hyperagent.utils import clone_repo, check_local_or_remote, setup_logger\nfrom hyperagent.agents.plan_seeking import load_agent_navigator, load_agent_editor, load_agent_executor, load_summarizer, load_agent_planner, load_manager\nfrom hyperagent.prompts.navigator import system_nav\nfrom hyperagent.prompts.editor import system_edit\nfrom hyperagent.prompts.executor import system_exec\nfrom hyperagent.prompts.planner import system_plan\nfrom hyperagent.build import initialize_tools\nfrom hyperagent.constants import DEFAULT_VERBOSE_LEVEL, DEFAULT_LLM_CONFIGS, DEFAULT_TRAJECTORIES_PATH, DEFAULT_IMAGE_NAME, DEFAULT_PATCHES_DIR\n        \nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nwarnings.filterwarnings(\"ignore\", category=FutureWarning)\n\nlogger = setup_logger()\n\ndef Setup(\n    repo_path: str,\n    commit: str,\n    language: str = \"python\",\n    clone_dir: str = \"data/repos\",\n    save_trajectories_path: Optional[str] = DEFAULT_TRAJECTORIES_PATH,\n    db_path: Optional[str] = None,  \n    index_path: Optional[str] = \"data/indexes\",\n    llm_configs: Optional[dict] = None,\n    image_name: Optional[str] = DEFAULT_IMAGE_NAME,\n):\n    if not os.path.exists(DEFAULT_PATCHES_DIR):\n        os.makedirs(DEFAULT_PATCHES_DIR)\n    \n    # initialize the github repository\n    gh_token = os.environ.get(\"GITHUB_TOKEN\", None)\n    is_local, repo_path = check_local_or_remote(repo_path)\n    repo_dir = clone_repo(repo_path, commit, clone_dir, gh_token, logger) if not is_local else repo_path\n    repo_dir = os.path.join(os.getcwd(), repo_dir)\n\n    if save_trajectories_path and not os.path.exists(save_trajectories_path):\n        os.makedirs(save_trajectories_path)\n        \n    # Set up the tool kernel\n    jupyter_executor, docker_executor = initialize_tools(repo_dir, db_path, index_path, language, image_name)\n\n    logger.info(\"Initialized tools\")    \n    # Set up the navigator, executor and generator agent (the system)\n    summarizer = load_summarizer()\n    \n    user_proxy = UserProxyAgent(\n        name=\"Admin\",\n        system_message=\"A human admin. Interact with the planner to discuss the plan to resolve a codebase-related query.\",\n        human_input_mode=\"ALWAYS\",\n        code_execution_config=False,\n        default_auto_reply=\"\",\n        max_consecutive_auto_reply=0\n    )\n    \n    navigator = load_agent_navigator(\n        llm_configs[\"nav\"],\n        jupyter_executor,\n        system_nav,\n        summarizer\n    )\n    \n    editor = load_agent_editor(\n        llm_configs[\"edit\"],\n        jupyter_executor,\n        system_edit,\n        repo_dir\n    )\n    \n    executor = load_agent_executor(\n        llm_configs[\"exec\"],\n        docker_executor,\n        system_exec,\n        summarizer\n    )\n         \n    planner = load_agent_planner(\n        system_plan,\n        llm_configs[\"plan\"]\n    )\n    \n    manager = load_manager(\n        user_proxy=user_proxy,\n        planner=planner,\n        navigator=navigator,\n        editor=editor,\n        executor=executor,\n        llm_config=llm_configs\n    )\n        \n    return manager, user_proxy, repo_dir\n\nclass HyperAgent:\n    def __init__(\n        self,\n        repo_path,\n        commit=\"str\",\n        language=\"python\",\n        clone_dir=\"data/repos\",\n        save_trajectories_path=DEFAULT_TRAJECTORIES_PATH,\n        llm_configs = DEFAULT_LLM_CONFIGS,\n        verbose = DEFAULT_VERBOSE_LEVEL,\n        image_name = DEFAULT_IMAGE_NAME\n    ):\n        self.repo_path = repo_path\n        self.language = language\n        self.system, self.user_proxy, repo_dir = Setup(\n            self.repo_path,\n            commit,\n            language=language,\n            clone_dir=clone_dir,\n            save_trajectories_path=save_trajectories_path,\n            llm_configs=llm_configs,\n            image_name=image_name\n        )\n        self.repo_dir = repo_dir\n        self.verbose = verbose\n\n    def query_codebase(self, query):\n        return self.user_proxy.initiate_chat(\n            self.system, message=query, silent=self.verbose\n        )"}
{"type": "source_file", "path": "src/hyperagent/prompts/executor.py", "content": "system_exec = \"\"\"You are a supporting agent in running bash commandlines, based on the requests, try to run commands or files. Another planner agent is resolving a query in a codebase and needs your help to execute some commands.\nWhen you write bash command code for action, put the code in a markdown code block with the language set to bash. \n\nSince your terminal is not stateful, you need to keep track of the state of the terminal. After finished the request, give a summarization on the execution and the key observations.\nAlways put one action inside bash block\n\n```bash\n\n```\n\n### Some common commands:\n1. cd: Change directory\n2. pip install: Install a package\n3. pip install -e .: Install the codebase in development mode\n4. python: Run a python file\n5. python -m: Run a python module\n6. python3 -m pytest with flag -q: run all tests with less verbose result\n7. ./tests/runtests.py: run tests of DJANGO\n8. bin/test: run tests of Sympy\n9. tox --current-env -epy39 -v --: run tests of Sphinx.\"\"\""}

{"repo_info": {"repo_name": "FastAPI_Tortoise_template", "repo_owner": "Kuzyashin", "repo_url": "https://github.com/Kuzyashin/FastAPI_Tortoise_template"}}
{"type": "source_file", "path": "app/__init__.py", "content": ""}
{"type": "source_file", "path": "app/applications/__init__.py", "content": ""}
{"type": "source_file", "path": "app/applications/users/routes.py", "content": "from fastapi import BackgroundTasks\n\nfrom app.core.auth.utils.contrib import get_current_active_superuser, send_new_account_email, get_current_active_user\nfrom app.core.auth.utils.password import get_password_hash\n\nfrom app.applications.users.models import User\nfrom app.applications.users.schemas import BaseUserOut, BaseUserCreate, BaseUserUpdate\n\nfrom typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException\n\nfrom app.settings.config import settings\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\", response_model=List[BaseUserOut], status_code=200, tags=['users'])\nasync def read_users(\n    skip: int = 0,\n    limit: int = 100,\n    current_user: User = Depends(get_current_active_superuser),\n):\n    \"\"\"\n    Retrieve users.\n    \"\"\"\n    users = await User.all().limit(limit).offset(skip)\n    return users\n\n\n@router.post(\"/\", response_model=BaseUserOut, status_code=201, tags=['users'])\nasync def create_user(\n    *,\n    user_in: BaseUserCreate,\n    current_user: User = Depends(get_current_active_superuser),\n    background_tasks: BackgroundTasks\n):\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = await User.get_by_email(email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this username already exists in the system.\",\n        )\n\n    hashed_password = get_password_hash(user_in.password)\n    db_user = BaseUserCreate(\n        **user_in.create_update_dict(), hashed_password=hashed_password\n    )\n    created_user = await User.create(db_user)\n\n    if settings.EMAILS_ENABLED and user_in.email:\n        background_tasks.add_task(\n            send_new_account_email, email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n    return created_user\n\n\n@router.put(\"/me\", response_model=BaseUserOut, status_code=200, tags=['users'])\nasync def update_user_me(\n    user_in: BaseUserUpdate,\n    current_user: User = Depends(get_current_active_user)\n):\n    \"\"\"\n    Update own user.\n    \"\"\"\n    if user_in.password is not None:\n        hashed_password = get_password_hash(user_in.password)\n        current_user.hashed_password = hashed_password\n    if user_in.username is not None:\n        current_user.username = user_in.username\n    if user_in.email is not None:\n        current_user.email = user_in.email\n    await current_user.save()\n    return current_user\n\n\n@router.get(\"/me\", response_model=BaseUserOut, status_code=200, tags=['users'])\ndef read_user_me(\n    current_user: User = Depends(get_current_active_user),\n):\n    \"\"\"\n    Get current user.\n    \"\"\"\n    return current_user\n\n\n@router.get(\"/{user_id}\", response_model=BaseUserOut, status_code=200, tags=['users'])\nasync def read_user_by_id(\n    user_id: int,\n    current_user: User = Depends(get_current_active_user),\n):\n    \"\"\"\n    Get a specific user by id.\n    \"\"\"\n    user = await User.get(id=user_id)\n    if user == current_user:\n        return user\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=400, detail=\"The user doesn't have enough privileges\"\n        )\n    return user\n\n\n@router.put(\"/{user_id}\", response_model=BaseUserOut, status_code=200, tags=['users'])\nasync def update_user(\n    user_id: int,\n    user_in: BaseUserUpdate,\n    current_user: User = Depends(get_current_active_superuser),\n):\n    \"\"\"\n    Update a user.\n    \"\"\"\n    user = await User.get(id=user_id)\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system\",\n        )\n    user = await user.update_from_dict(user_in.create_update_dict_superuser())\n    await user.save()\n    return user\n"}
{"type": "source_file", "path": "app/core/auth/schemas.py", "content": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass CredentialsSchema(BaseModel):\n    username: Optional[str]\n    email: Optional[str]\n    password: str\n\n\nclass JWTToken(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass JWTTokenData(BaseModel):\n    username: str = None\n\n\nclass JWTTokenPayload(BaseModel):\n    user_id: int = None\n\n\nclass Msg(BaseModel):\n    msg: str\n"}
{"type": "source_file", "path": "app/applications/users/models.py", "content": "from typing import Optional\n\nfrom tortoise import fields\nfrom tortoise.exceptions import DoesNotExist\n\nfrom app.applications.users.schemas import BaseUserCreate\nfrom app.core.base.base_models import BaseCreatedUpdatedAtModel, UUIDDBModel, BaseDBModel\nfrom app.core.auth.utils import password\n\n\nclass User(BaseDBModel, BaseCreatedUpdatedAtModel, UUIDDBModel):\n\n    username = fields.CharField(max_length=20, unique=True)\n    email = fields.CharField(max_length=255, unique=True)\n    first_name = fields.CharField(max_length=50, null=True)\n    last_name = fields.CharField(max_length=50, null=True)\n    password_hash = fields.CharField(max_length=128, null=True)\n    last_login = fields.DatetimeField(null=True)\n    is_active = fields.BooleanField(default=True)\n    is_superuser = fields.BooleanField(default=False)\n\n    def full_name(self) -> str:\n        if self.first_name or self.last_name:\n            return f\"{self.first_name or ''} {self.last_name or ''}\".strip()\n        return self.username\n\n    @classmethod\n    async def get_by_email(cls, email: str) -> Optional[\"User\"]:\n        try:\n            query = cls.get_or_none(email=email)\n            user = await query\n            return user\n        except DoesNotExist:\n            return None\n\n    @classmethod\n    async def get_by_username(cls, username: str) -> Optional[\"User\"]:\n        try:\n            query = cls.get(username=username)\n            user = await query\n            return user\n        except DoesNotExist:\n            return None\n\n    @classmethod\n    async def create(cls, user: BaseUserCreate) -> \"User\":\n        user_dict = user.dict()\n        password_hash = password.get_password_hash(password=user.password)\n        model = cls(**user_dict, password_hash=password_hash)\n        await model.save()\n        return model\n\n    class Meta:\n        table = 'users'\n\n    class PydanticMeta:\n        computed = [\"full_name\"]\n"}
{"type": "source_file", "path": "app/core/auth/utils/password.py", "content": "from typing import Tuple\n\nfrom passlib import pwd\nfrom passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef verify_and_update_password(\n    plain_password: str, hashed_password: str\n) -> Tuple[bool, str]:\n    return pwd_context.verify_and_update(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\n\ndef generate_password() -> str:\n    return pwd.genword()\n"}
{"type": "source_file", "path": "app/applications/users/schemas.py", "content": "import uuid\nfrom datetime import datetime\nfrom typing import Optional, TypeVar\n\nfrom pydantic import BaseModel, EmailStr, UUID4, validator\n\n\nclass BaseProperties(BaseModel):\n    @validator(\"hashed_id\", pre=True, always=True, check_fields=False)\n    def default_hashed_id(cls, v):\n        return v or uuid.uuid4()\n\n    def create_update_dict(self):\n        return self.dict(\n            exclude_unset=True,\n            exclude={\"id\", \"is_superuser\", \"is_active\"},\n        )\n\n    def create_update_dict_superuser(self):\n        return self.dict(exclude_unset=True, exclude={\"id\"})\n\n\nclass BaseUser(BaseProperties):\n    first_name: Optional[str]\n    last_name: Optional[str]\n    hashed_id: Optional[UUID4] = None\n    email: Optional[EmailStr] = None\n    username: Optional[str] = None\n    is_active: Optional[bool] = True\n    is_superuser: Optional[bool] = False\n    created_at: Optional[datetime]\n\n\nclass BaseUserCreate(BaseProperties):\n    first_name: Optional[str]\n    last_name: Optional[str]\n    hashed_id: Optional[UUID4] = None\n    email: EmailStr\n    username: Optional[str]\n    password: str\n\n\nclass BaseUserUpdate(BaseProperties):\n    first_name: Optional[str]\n    last_name: Optional[str]\n    password: Optional[str]\n    email: Optional[EmailStr]\n    username: Optional[str]\n\n\nclass BaseUserDB(BaseUser):\n    id: int\n    hashed_id: UUID4\n    password_hash: str\n    updated_at: datetime\n    last_login: Optional[datetime]\n\n    class Config:\n        orm_mode = True\n\n\nclass BaseUserOut(BaseUser):\n    id: int\n\n    class Config:\n        orm_mode = True\n"}
{"type": "source_file", "path": "app/applications/users/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/base/base_models.py", "content": "from tortoise import models\nfrom tortoise import fields\n\n\nclass BaseDBModel(models.Model):\n    id = fields.BigIntField(pk=True, index=True)\n\n    async def to_dict(self):\n        d = {}\n        for field in self._meta.db_fields:\n            d[field] = getattr(self, field)\n        for field in self._meta.backward_fk_fields:\n            d[field] = await getattr(self, field).all().values()\n        return d\n\n    class Meta:\n        abstract = True\n\n\nclass UUIDDBModel:\n    hashed_id = fields.UUIDField(unique=True, pk=False)\n\n\nclass BaseCreatedAtModel:\n    created_at = fields.DatetimeField(auto_now_add=True)\n\n\nclass BaseCreatedUpdatedAtModel:\n    created_at = fields.DatetimeField(auto_now_add=True)\n    updated_at = fields.DatetimeField(auto_now=True)\n"}
{"type": "source_file", "path": "app/core/auth/utils/contrib.py", "content": "import logging\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Optional\n\nimport emails\nimport jwt\nfrom emails.template import JinjaTemplate\nfrom fastapi import HTTPException, Security\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jwt import PyJWTError\nfrom jwt.exceptions import InvalidTokenError\nfrom starlette.status import HTTP_403_FORBIDDEN\n\nfrom app.applications.users.models import User\nfrom app.core.auth.schemas import JWTTokenPayload, CredentialsSchema\nfrom app.core.auth.utils import password\nfrom app.core.auth.utils.jwt import ALGORITHM\nfrom app.settings.config import settings\n\npassword_reset_jwt_subject = \"passwordreset\"\nreusable_oauth2 = OAuth2PasswordBearer(tokenUrl=\"/api/auth/login/access-token\")\n\n\ndef send_email(email_to: str, subject_template=\"\", html_template=\"\", environment={}):\n    assert settings.EMAILS_ENABLED, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=JinjaTemplate(subject_template),\n        html=JinjaTemplate(html_template),\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, render=environment, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")\n\n\ndef send_reset_password_email(email_to: str, email: str, token: str):\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    with open(Path(settings.EMAIL_TEMPLATES_DIR) / \"password_reset.html\") as f:\n        template_str = f.read()\n    if hasattr(token, \"decode\"):\n        use_token = token.decode()\n    else:\n        use_token = token\n    server_host = settings.SERVER_HOST\n    link = f\"{server_host}/auth/reset-password?token={use_token}\"\n    send_email(\n        email_to=email_to,\n        subject_template=subject,\n        html_template=template_str,\n        environment={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n\n\ndef send_new_account_email(email_to: str, username: str, password: str):\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - New account for user {username}\"\n    with open(Path(settings.EMAIL_TEMPLATES_DIR) / \"new_account.html\") as f:\n        template_str = f.read()\n    link = settings.LOGIN_URL\n    send_email(\n        email_to=email_to,\n        subject_template=subject,\n        html_template=template_str,\n        environment={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": link,\n        },\n    )\n\n\ndef generate_password_reset_token(email):\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": password_reset_jwt_subject, \"email\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt\n\n\ndef verify_password_reset_token(token) -> Optional[str]:\n    try:\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        assert decoded_token[\"sub\"] == password_reset_jwt_subject\n        return decoded_token[\"email\"]\n    except InvalidTokenError:\n        return None\n\n\nasync def get_current_user(token: str = Security(reusable_oauth2)) -> Optional[User]:\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])\n        token_data = JWTTokenPayload(**payload)\n    except PyJWTError:\n        raise HTTPException(\n            status_code=HTTP_403_FORBIDDEN, detail=\"Could not validate credentials\"\n        )\n    user = await User.get(id=token_data.user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\n\nasync def get_current_active_user(current_user: User = Security(get_current_user)):\n    if not current_user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n\n\nasync def get_current_active_superuser(current_user: User = Security(get_current_user)):\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=400, detail=\"The user doesn't have enough privileges\"\n        )\n    return current_user\n\n\nasync def authenticate(credentials: CredentialsSchema) -> Optional[User]:\n    if credentials.email:\n        user = await User.get_by_email(credentials.email)\n    elif credentials.username:\n        user = await User.get_by_username(credentials.username)\n    else:\n        return None\n\n    if user is None:\n        return None\n\n    verified, updated_password_hash = password.verify_and_update_password(\n        credentials.password, user.password_hash\n    )\n\n    if not verified:\n        return None\n        # Update password hash to a more robust one if needed\n    if updated_password_hash is not None:\n        user.password_hash = updated_password_hash\n        await user.save()\n    return user\n"}
{"type": "source_file", "path": "app/core/auth/routers/login.py", "content": "from datetime import timedelta\n\nfrom fastapi import APIRouter, Body, HTTPException, BackgroundTasks\n\nfrom app.applications.users.models import User\nfrom app.applications.users.utils import update_last_login\nfrom app.core.auth.schemas import JWTToken, CredentialsSchema, Msg\nfrom app.core.auth.utils.contrib import (generate_password_reset_token, send_reset_password_email,\n                                         verify_password_reset_token, authenticate,\n                                         )\nfrom app.core.auth.utils.jwt import create_access_token\nfrom app.core.auth.utils.password import get_password_hash\nfrom app.settings.config import settings\n\nrouter = APIRouter()\n\n\n@router.post(\"/access-token\", response_model=JWTToken, tags=[\"login\"])\nasync def login_access_token(credentials: CredentialsSchema):\n    user = await authenticate(credentials)\n    if user:\n        await update_last_login(user.id)\n    elif not user:\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    access_token_expires = timedelta(minutes=settings.JWT_ACCESS_TOKEN_EXPIRE_MINUTES)\n    return {\n        \"access_token\": create_access_token(\n            data={\"user_id\": user.id}, expires_delta=access_token_expires\n        ),\n        \"token_type\": \"bearer\",\n    }\n\n\n@router.post(\"/password-recovery/{email}\", tags=[\"login\"], response_model=Msg)\nasync def recover_password(email: str, background_tasks: BackgroundTasks):\n    \"\"\"\n    Password Recovery\n    \"\"\"\n    user = await User.get_by_email(email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    background_tasks.add_task(send_reset_password_email, email_to=user.email, email=email, token=password_reset_token)\n    return {\"msg\": \"Password recovery email sent\"}\n\n\n@router.post(\"/reset-password/\", tags=[\"login\"], response_model=Msg)\nasync def reset_password(token: str = Body(...), new_password: str = Body(...)):\n    \"\"\"\n    Reset password\n    \"\"\"\n    email = verify_password_reset_token(token)\n    if not email:\n        raise HTTPException(status_code=400, detail=\"Invalid token\")\n    user = await User.get_by_email(email=email)\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system.\",\n        )\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    hashed_password = get_password_hash(new_password)\n    user.hashed_password = hashed_password\n    await user.save()\n    return {\"msg\": \"Password updated successfully\"}\n"}
{"type": "source_file", "path": "app/core/auth/routers/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/auth/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/auth/utils/jwt.py", "content": "from datetime import datetime, timedelta\n\nimport jwt\n\nfrom app.settings.config import settings\n\nALGORITHM = \"HS256\"\naccess_token_jwt_subject = \"access\"\n\n\ndef create_access_token(*, data: dict, expires_delta: timedelta = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire, \"sub\": access_token_jwt_subject})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n"}
{"type": "source_file", "path": "app/applications/users/utils.py", "content": "from datetime import datetime\n\nfrom app.applications.users.models import User\n\n\nasync def update_last_login(user_id: int) -> None:\n    user = await User.get(id=user_id)\n    user.last_login = datetime.now()\n    await user.save()\n"}
{"type": "source_file", "path": "app/core/auth/utils/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/base/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/exceptions.py", "content": "from fastapi.requests import Request\nfrom starlette.responses import JSONResponse\n\n\nclass SettingNotFound(Exception):\n    pass\n\n\nclass APIException(Exception):\n    \"\"\"\n    Инстанциирование объекта исключения приводит к формированию\n    респонса с кодом status_code, кодом error_code,\n    и сообщениями message и detail(опционально).\n    \"\"\"\n    def __init__(self,\n                 error_code: int = 000,\n                 status_code: int = 500,\n                 detail=\"\",\n                 message=\"\",\n                 *args,\n                 **kwargs\n                 ):\n        Exception.__init__(self, *args, **kwargs)\n\n        self.error_code = error_code\n        self.message = message\n        self.detail = detail\n        self.status_code = status_code\n\n    def __str__(self):\n        return f\"APIException(status_code={self.status_code}, detail={self.message})\"\n\n\nasync def on_api_exception(\n    request: Request,\n    exception: APIException\n) -> JSONResponse:\n    content = {\"error\": {\"error_code\": exception.error_code}}\n\n    if exception.message:\n        content['error']['message'] = exception.message\n\n    if exception.detail:\n        content['error']['detail'] = exception.detail\n\n    return JSONResponse(content=content, status_code=exception.status_code)"}
{"type": "source_file", "path": "app/core/tasks.py", "content": "from time import sleep\nfrom celery import current_task\nfrom app.core.celery_app import celery_app\n\n\n@celery_app.task(acks_late=True)\ndef test_data_celery(word: str) -> str:\n    for i in range(1, 11):\n        sleep(1)\n        current_task.update_state(state='PROGRESS',\n                                  meta={'process_percent': i*10})\n    return f\"test task return {word}\"\n"}
{"type": "source_file", "path": "app/main.py", "content": "from fastapi import FastAPI\nfrom app.core.exceptions import SettingNotFound\nfrom app.core.init_app import configure_logging, init_middlewares, register_db, register_exceptions, register_routers\n\ntry:\n    from app.settings.config import settings\nexcept ImportError:\n    raise SettingNotFound('Can not import settings. Create settings file from template.config.py')\n\n\napp = FastAPI(\n    title=settings.APP_TITLE,\n    description=settings.APP_DESCRIPTION,\n    version=settings.VERSION\n)\n\nconfigure_logging()\ninit_middlewares(app)\nregister_db(app)\nregister_exceptions(app)\nregister_routers(app)\n"}
{"type": "source_file", "path": "app/migrations/__init__.py", "content": ""}
{"type": "source_file", "path": "app/core/celery_app.py", "content": "from celery import Celery\n\ncelery_app = Celery(\"celery_worker\")\ncelery_app.config_from_object('app.settings.celery_config')\ncelery_app.autodiscover_tasks(['app.core'])\n"}
{"type": "source_file", "path": "app/core/init_app.py", "content": "import logging\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom tortoise.contrib.fastapi import register_tortoise\n\nfrom app.core.exceptions import APIException, on_api_exception\nfrom app.settings.config import settings\nfrom app.settings.log import DEFAULT_LOGGING\nfrom app.core.auth.routers.login import router as login_router\nfrom app.applications.users.routes import router as users_router\n\n\ndef configure_logging(log_settings: dict = None):\n    log_settings = log_settings or DEFAULT_LOGGING\n    logging.config.dictConfig(log_settings)\n\n\ndef init_middlewares(app: FastAPI):\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=settings.CORS_ORIGINS,\n        allow_credentials=settings.CORS_ALLOW_CREDENTIALS,\n        allow_methods=settings.CORS_ALLOW_METHODS,\n        allow_headers=settings.CORS_ALLOW_HEADERS,\n    )\n\n\ndef get_app_list():\n    app_list = [f'{settings.APPLICATIONS_MODULE}.{app}.models' for app in settings.APPLICATIONS]\n    return app_list\n\n\ndef get_tortoise_config() -> dict:\n    app_list = get_app_list()\n    app_list.append('aerich.models')\n    config = {\n        'connections': settings.DB_CONNECTIONS,\n        'apps': {\n            'models': {\n                'models': app_list,\n                'default_connection': 'default',\n            }\n        }\n    }\n    return config\n\n\nTORTOISE_ORM = get_tortoise_config()\n\n\ndef register_db(app: FastAPI, db_url: str = None):\n    db_url = db_url or settings.DB_URL\n    app_list = get_app_list()\n    app_list.append('aerich.models')\n    register_tortoise(\n        app,\n        db_url=db_url,\n        modules={'models': app_list},\n        generate_schemas=True,\n        add_exception_handlers=True,\n    )\n\n\ndef register_exceptions(app: FastAPI):\n    app.add_exception_handler(APIException, on_api_exception)\n\n\ndef register_routers(app: FastAPI):\n    app.include_router(login_router, prefix='/api/auth/login')\n    app.include_router(users_router, prefix='/api/auth/users')\n"}
{"type": "source_file", "path": "app/migrations/models/old_models.py", "content": "from typing import Optional\n\nfrom tortoise import fields\nfrom tortoise.exceptions import DoesNotExist\n\nfrom app.applications.users.schemas import BaseUserCreate\nfrom app.core.base.base_models import BaseCreatedUpdatedAtModel, UUIDDBModel, BaseDBModel\nfrom app.core.auth.utils import password\n\n\nclass User(BaseDBModel, BaseCreatedUpdatedAtModel, UUIDDBModel):\n\n    username = fields.CharField(max_length=20, unique=True)\n    email = fields.CharField(max_length=255, unique=True)\n    first_name = fields.CharField(max_length=50, null=True)\n    last_name = fields.CharField(max_length=50, null=True)\n    password_hash = fields.CharField(max_length=128, null=True)\n    last_login = fields.DatetimeField(null=True)\n    is_active = fields.BooleanField(default=True)\n    is_superuser = fields.BooleanField(default=False)\n\n    def full_name(self) -> str:\n        if self.first_name or self.last_name:\n            return f\"{self.first_name or ''} {self.last_name or ''}\".strip()\n        return self.username\n\n    @classmethod\n    async def get_by_email(cls, email: str) -> Optional[\"User\"]:\n        try:\n            query = cls.get_or_none(email=email)\n            user = await query\n            return user\n        except DoesNotExist:\n            return None\n\n    @classmethod\n    async def get_by_username(cls, username: str) -> Optional[\"User\"]:\n        try:\n            query = cls.get(username=username)\n            user = await query\n            return user\n        except DoesNotExist:\n            return None\n\n    @classmethod\n    async def create(cls, user: BaseUserCreate) -> \"User\":\n        user_dict = user.dict()\n        password_hash = password.get_password_hash(password=user.password)\n        model = cls(**user_dict, password_hash=password_hash)\n        await model.save()\n        return model\n\n    class Meta:\n        table = 'users'\n\n    class PydanticMeta:\n        computed = [\"full_name\"]\n"}
{"type": "source_file", "path": "app/settings/template.config.py", "content": "import os\n\n\nclass Settings:\n    VERSION = '0.1.0'\n    APP_TITLE = 'Template Application'\n    PROJECT_NAME = 'Template Application'\n    APP_DESCRIPTION = 'TG - @AKuzyashin\\nhttps://github.com/Kuzyashin'\n\n    SERVER_HOST = 'localhost'\n\n    DEBUG = True\n\n    APPLICATIONS = [\n        'users'\n    ]\n\n    PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))\n    BASE_DIR = os.path.abspath(os.path.join(PROJECT_ROOT, os.pardir))\n    LOGS_ROOT = os.path.join(BASE_DIR, \"app/logs\")\n    EMAIL_TEMPLATES_DIR = os.path.join(BASE_DIR, \"app/templates/emails/build/\")\n\n    DB_URL = 'sqlite://./test.db'\n    DB_CONNECTIONS = {\n            'default': {\n                'engine': 'tortoise.backends.sqlite',\n                'db_url': DB_URL,\n                'credentials': {\n                    'host': '',\n                    'port': '',\n                    'user': '',\n                    'password': '',\n                    'database': '',\n                }\n            },\n        }\n\n    SECRET_KEY = '3488a63e1765035d386f05409663f55c83bfae3b3c61a932744b20ad14244dcf'  # openssl rand -hex 32\n    JWT_ALGORITHM = 'HS25'\n    JWT_ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24 * 7  # 7 day\n\n    EMAILS_FROM_NAME = ''\n    EMAILS_FROM_EMAIL = ''\n    SMTP_USER = ''\n    SMTP_HOST = 'smtp.gmail.com'\n    SMTP_PORT = 587\n    SMTP_TLS = True\n    SMTP_PASSWORD = ''\n    EMAIL_RESET_TOKEN_EXPIRE_HOURS = 1\n    EMAILS_ENABLED = SMTP_HOST and SMTP_PORT and EMAILS_FROM_EMAIL\n    LOGIN_URL = SERVER_HOST + '/api/auth/login/access-token'\n\n    RABBIT_LOGIN = 'guest'\n    RABBIT_PASSWORD = ''\n    RABBIT_HOST = 'localhost'\n\n    REDIS_URL = ''\n\n    APPLICATIONS_MODULE = 'app.applications'\n\n    CORS_ORIGINS = [\n        \"http://localhost\",\n        \"http://localhost:8080\",\n        \"http://localhost:5000\",\n        \"http://localhost:3000\",\n    ]\n    CORS_ALLOW_CREDENTIALS = True\n    CORS_ALLOW_METHODS = [\"*\"]\n    CORS_ALLOW_HEADERS = [\"*\"]\n\n\nsettings = Settings()\n"}
{"type": "source_file", "path": "app/settings/celery_config.py", "content": "from __future__ import absolute_import, unicode_literals\n\naccept_content = ['json']\nenable_utc = False\ntask_serializer = 'json'\ntimezone = 'UTC'\ntask_track_started = True\nworker_hijack_root_logger = False\nworker_redirect_stdouts_level = 'ERROR'\nresult_expires = 60 * 60 * 24\n"}
{"type": "source_file", "path": "app/settings/log.py", "content": "import logging.config\nfrom app.settings.config import settings\n\nDEFAULT_LOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'filters': {\n        'require_debug_false': {\n            '()': 'app.settings.log.RequireDebugFalse',\n        },\n        'require_debug_true': {\n            '()': 'app.settings.log.RequireDebugTrue',\n        },\n    },\n    'formatters': {\n        'main_formatter': {\n            'format': '[%(levelname)s]:[%(name)s]: %(message)s '\n                      '(%(asctime)s; %(filename)s:%(lineno)d)',\n            'datefmt': \"%Y-%m-%d %H:%M:%S\",\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': 'DEBUG',\n            'filters': ['require_debug_true'],\n            'class': 'logging.StreamHandler',\n            'formatter': 'main_formatter',\n        },\n        'production_file': {\n            'level': 'INFO',\n            'class': 'logging.handlers.RotatingFileHandler',\n            'filename': f'{settings.LOGS_ROOT}/app_main.log',\n            'maxBytes': 1024 * 1024 * 10,\n            'backupCount': 10,\n            'formatter': 'main_formatter',\n            'filters': ['require_debug_false'],\n        },\n        'debug_file': {\n            'level': 'DEBUG',\n            'class': 'logging.handlers.RotatingFileHandler',\n            'filename': f'{settings.LOGS_ROOT}/app_main_debug.log',\n            'maxBytes': 1024 * 1024 * 10,\n            'backupCount': 10,\n            'formatter': 'main_formatter',\n            'filters': ['require_debug_true'],\n        },\n    },\n    'loggers': {\n        '': {\n            'handlers': ['console', 'production_file', 'debug_file'],\n            'level': \"DEBUG\",\n        },\n\n    }\n}\n\n\nclass RequireDebugFalse(logging.Filter):\n    def filter(self, record):\n        return not settings.DEBUG\n\n\nclass RequireDebugTrue(logging.Filter):\n    def filter(self, record):\n        return settings.DEBUG\n"}

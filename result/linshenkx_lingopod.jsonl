{"repo_info": {"repo_name": "lingopod", "repo_owner": "linshenkx", "repo_url": "https://github.com/linshenkx/lingopod"}}
{"type": "test_file", "path": "server/tests/__init__.py", "content": ""}
{"type": "test_file", "path": "server/tests/test_auth.py", "content": "from fastapi import status\nfrom models.user import User\nfrom utils.time_utils import TimeUtil\n\ndef test_register_user(client):\n    response = client.post(\n        \"/api/v1/auth/register\",\n        json={\n            \"username\": \"newuser\",\n            \"password\": \"password123\",\n            \"nickname\": \"New User\"\n        }\n    )\n    assert response.status_code == status.HTTP_201_CREATED\n    data = response.json()\n    assert data[\"username\"] == \"newuser\"\n    assert \"password\" not in data\n\ndef test_login_user(client, test_user):\n    response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert \"access_token\" in data\n    assert data[\"token_type\"] == \"bearer\"\n\ndef test_get_current_user(client, test_user):\n    # 先登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 用token获取当前用户信息\n    response = client.get(\n        \"/api/v1/auth/me\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"username\"] == \"testuser\"\n\ndef test_register_duplicate_username(client, test_user):\n    \"\"\"测试注册重复用户名\"\"\"\n    response = client.post(\n        \"/api/v1/auth/register\",\n        json={\n            \"username\": \"testuser\",  # 使用已存在的用户名\n            \"password\": \"password123\",\n            \"nickname\": \"Test User\"\n        }\n    )\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n    data = response.json()\n    assert \"用户名已存在\" in data[\"detail\"]\n\ndef test_login_wrong_password(client, test_user):\n    \"\"\"测试错误密码登录\"\"\"\n    response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"wrongpass\"\n        }\n    )\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n    data = response.json()\n    assert \"用户名或密码错误\" in data[\"detail\"]\n\ndef test_login_nonexistent_user(client):\n    \"\"\"测试不存在的用户登录\"\"\"\n    response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"nonexistent\",\n            \"password\": \"testpass\"\n        }\n    )\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\ndef test_get_current_user_invalid_token(client):\n    \"\"\"测试无效token访问当前用户信息\"\"\"\n    response = client.get(\n        \"/api/v1/auth/me\",\n        headers={\"Authorization\": \"Bearer invalid_token\"}\n    )\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\ndef test_get_current_user_no_token(client):\n    \"\"\"测试未提供token访问当前用户信息\"\"\"\n    response = client.get(\"/api/v1/auth/me\")\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\ndef test_get_current_user_inactive(client, test_user, db_session):\n    \"\"\"测试已禁用用户访问\"\"\"\n    # 先登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 禁用用户\n    test_user.is_active = False\n    db_session.commit()\n    \n    # 尝试访问用户信息\n    response = client.get(\n        \"/api/v1/auth/me\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n    assert \"用户已被禁用\" in response.json()[\"detail\"]\n\ndef test_registration_closed(client, monkeypatch):\n    \"\"\"测试关闭注册功能\"\"\"\n    # 修改配置，关闭注册功能\n    monkeypatch.setattr(\"core.config.settings.ALLOW_REGISTRATION\", False)\n    \n    response = client.post(\n        \"/api/v1/auth/register\",\n        json={\n            \"username\": \"newuser\",\n            \"password\": \"password123\",\n            \"nickname\": \"New User\"\n        }\n    )\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n    assert \"注册功能已关闭\" in response.json()[\"detail\"]\n\ndef test_login_disabled_user(client, test_user, db_session):\n    \"\"\"测试禁用用户登录\"\"\"\n    # 禁用用户\n    test_user.is_active = False\n    db_session.commit()\n    \n    # 尝试登录\n    response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n    assert \"用户已被禁用\" in response.json()[\"detail\"]\n\ndef test_login_enabled_user(client, test_user, db_session):\n    \"\"\"测试启用用户登录\"\"\"\n    # 启用用户\n    test_user.is_active = True\n    db_session.commit()\n    \n    # 尝试登录\n    response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    assert response.status_code == status.HTTP_200_OK\n    assert \"access_token\" in response.json()\n\ndef test_login_updates_last_login(client, test_user, db_session):\n    \"\"\"测试登录时更新最近登录时间\"\"\"\n    # 记录登录前的时间\n    before_login = TimeUtil.now_ms()\n    \n    # 登录\n    response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    assert response.status_code == status.HTTP_200_OK\n    \n    # 验证最近登录时间已更新\n    db_session.refresh(test_user)\n    assert test_user.last_login is not None\n    assert test_user.last_login >= before_login\n\ndef test_user_created_at_is_set(client, db_session):\n    \"\"\"测试创建用户时设置创建时间\"\"\"\n    before_create = TimeUtil.now_ms()\n    \n    response = client.post(\n        \"/api/v1/auth/register\",\n        json={\n            \"username\": \"newuser\",\n            \"password\": \"password123\",\n            \"nickname\": \"New User\"\n        }\n    )\n    assert response.status_code == status.HTTP_201_CREATED\n    \n    user = db_session.query(User).filter(User.username == \"newuser\").first()\n    assert user.created_at is not None\n    assert user.created_at >= before_create\n"}
{"type": "test_file", "path": "server/tests/test_configs.py", "content": "import pytest\nfrom fastapi import status\nfrom core.config import config_manager, Settings\n\n@pytest.fixture\ndef admin_token(client, test_admin):\n    \"\"\"获取管理员token\"\"\"\n    response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"admin\",\n            \"password\": \"adminpass\"\n        }\n    )\n    return response.json()[\"access_token\"]\n\n@pytest.fixture\ndef user_token(client, test_user):\n    \"\"\"获取普通用户token\"\"\"\n    response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    return response.json()[\"access_token\"]\n\ndef test_get_all_configs(client, admin_token, user_token):\n    \"\"\"测试获取所有配置\"\"\"\n    # 普通用户无权限访问\n    response = client.get(\n        \"/api/v1/configs\",\n        headers={\"Authorization\": f\"Bearer {user_token}\"}\n    )\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    # 管理员可以访问\n    response = client.get(\n        \"/api/v1/configs\",\n        headers={\"Authorization\": f\"Bearer {admin_token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    # 验证返回的是ConfigListResponse格式\n    assert \"configs\" in data\n    configs = data[\"configs\"]\n    # 验证只包含允许的配置项\n    assert all(key in config_manager.MUTABLE_CONFIGS for key in configs.keys())\n    # 验证每个配置项的格式\n    for config in configs.values():\n        assert \"key\" in config\n        assert \"value\" in config\n        assert \"type\" in config\n        assert \"description\" in config\n\ndef test_update_config(client, admin_token, user_token, db_session):\n    \"\"\"测试更新配置\"\"\"\n    test_config = {\n        \"value\": \"test-api-key\",\n        \"type\": \"str\",\n        \"description\": \"测试API密钥\"\n    }\n\n    # 普通用户无权限更新\n    response = client.put(\n        \"/api/v1/configs/API_KEY\",\n        headers={\"Authorization\": f\"Bearer {user_token}\"},\n        json=test_config\n    )\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    # 管理员可以更新\n    response = client.put(\n        \"/api/v1/configs/API_KEY\",\n        headers={\"Authorization\": f\"Bearer {admin_token}\"},\n        json=test_config\n    )\n    assert response.status_code == status.HTTP_200_OK\n    \n    # 验证配置已更新\n    response = client.get(\n        \"/api/v1/configs\",\n        headers={\"Authorization\": f\"Bearer {admin_token}\"}\n    )\n    data = response.json()\n    config = data[\"configs\"][\"API_KEY\"]\n    assert config[\"value\"] == \"test-api-key\"\n    assert config[\"type\"] == \"str\"\n    assert config[\"description\"] == \"测试API密钥\"\n\ndef test_reset_config(client, admin_token, user_token, db_session):\n    \"\"\"测试重置配置\"\"\"\n    # 先更新一个配置\n    test_config = {\n        \"value\": \"test-api-key\",\n        \"type\": \"str\",\n        \"description\": \"测试API密钥\"\n    }\n    client.put(\n        \"/api/v1/configs/API_KEY\",\n        headers={\"Authorization\": f\"Bearer {admin_token}\"},\n        json=test_config\n    )\n\n    # 普通用户无权限重置\n    response = client.delete(\n        \"/api/v1/configs/API_KEY\",\n        headers={\"Authorization\": f\"Bearer {user_token}\"}\n    )\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    # 管理员可以重置\n    response = client.delete(\n        \"/api/v1/configs/API_KEY\",\n        headers={\"Authorization\": f\"Bearer {admin_token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n\n    # 验证配置已重置为默认值\n    response = client.get(\n        \"/api/v1/configs\",\n        headers={\"Authorization\": f\"Bearer {admin_token}\"}\n    )\n    data = response.json()\n    config = data[\"configs\"][\"API_KEY\"]\n    assert config[\"value\"] == Settings().API_KEY\n\ndef test_update_invalid_config(client, admin_token):\n    \"\"\"测试更新无效的配置项\"\"\"\n    test_config = {\n        \"value\": \"test\",\n        \"type\": \"str\",\n        \"description\": \"测试\"\n    }\n    \n    # 测试更新不存在的配置\n    response = client.put(\n        \"/api/v1/configs/INVALID_KEY\",\n        headers={\"Authorization\": f\"Bearer {admin_token}\"},\n        json=test_config\n    )\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n\n    # 测试更新不允许修改的配置\n    response = client.put(\n        \"/api/v1/configs/JWT_SECRET_KEY\",\n        headers={\"Authorization\": f\"Bearer {admin_token}\"},\n        json=test_config\n    )\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n\ndef test_reset_nonexistent_config(client, admin_token):\n    \"\"\"测试重置不存在的配置\"\"\"\n    response = client.delete(\n        \"/api/v1/configs/NONEXISTENT_KEY\",\n        headers={\"Authorization\": f\"Bearer {admin_token}\"}\n    )\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n"}
{"type": "test_file", "path": "server/tests/test_rss.py", "content": "import pytest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import patch, MagicMock, AsyncMock\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.orm import Session\nimport requests\n\nfrom main import app\nfrom models.user import User\nfrom models.rss import RSSFeed, RSSEntry\nfrom services.rss.feed_manager import FeedManager\nfrom services.task.processor import TaskProcessor\nfrom core.scheduler import fetch_all_feeds\nfrom core.config import settings\nfrom auth.utils import get_password_hash\nfrom utils.time_utils import TimeUtil\nimport zoneinfo\n\nclient = TestClient(app)\n\ndef get_current_time():\n    \"\"\"获取当前时间戳（毫秒）\"\"\"\n    return TimeUtil.now_ms()\n\ndef get_time_with_offset(offset_seconds: int) -> int:\n    \"\"\"获取偏移后的时间戳（毫秒）\"\"\"\n    return TimeUtil.now_ms() + (offset_seconds * 1000)\n\ndef mock_task_processor():\n    \"\"\"创建模拟的任务处理器\"\"\"\n    processor = MagicMock(spec=TaskProcessor)\n    processor.process_task = AsyncMock()\n    return processor\n\n@pytest.fixture\ndef mock_feed_manager():\n    \"\"\"模拟 FeedManager\"\"\"\n    with patch('services.rss.feed_manager.FeedManager') as mock:\n        manager = MagicMock(spec=FeedManager)\n        manager.fetch_feed = AsyncMock()\n        mock.return_value = manager\n        yield manager\n\n@pytest.fixture\ndef mock_url_fetcher():\n    \"\"\"模拟URL内容获取\"\"\"\n    with patch('services.url_fetcher.fetch_url_content') as mock:\n        mock.return_value = ('模拟的页面内容', '模拟的标题')\n        yield mock\n\n@pytest.fixture\ndef mock_http_client():\n    \"\"\"模拟HTTP请求\"\"\"\n    with patch('requests.get') as mock:\n        mock.return_value.status_code = 200\n        mock.return_value.text = '模拟的页面内容'\n        yield mock\n\n@pytest.fixture\ndef test_user(db_session: Session):\n    \"\"\"创建测试用户\"\"\"\n    user = User(\n        username=\"testuser\",  # 使用与 conftest.py 相同的用户名\n        email=\"test@example.com\",\n        hashed_password=get_password_hash(\"testpass\"),\n        is_active=True\n    )\n    db_session.add(user)\n    db_session.commit()\n    db_session.refresh(user)\n    return user\n\n@pytest.fixture\ndef test_token(client, test_user: User):\n    \"\"\"创建测试用户的令牌\"\"\"\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    assert login_response.status_code == status.HTTP_200_OK\n    return login_response.json()[\"access_token\"]\n\n@pytest.fixture\ndef test_feed(db_session: Session, test_user: User):\n    \"\"\"创建测试RSS源\"\"\"\n    feed = RSSFeed(\n        title=\"Test Feed\",\n        url=\"http://example.com/feed.xml\",\n        user_id=test_user.id,\n        fetch_interval=900,\n        initial_entries_count=2,\n        update_entries_count=1\n    )\n    db_session.add(feed)\n    db_session.commit()\n    db_session.refresh(feed)\n    return feed\n\nclass TestRSSAPI:\n    \"\"\"RSS API测试\"\"\"\n    \n    def test_create_feed(self, client, test_token: str, mock_feed_manager):\n        \"\"\"测试创建RSS源\"\"\"\n        response = client.post(\n            \"/api/v1/rss/feeds\",\n            headers={\"Authorization\": f\"Bearer {test_token}\"},\n            json={\n                \"url\": \"http://example.com/feed.xml\",\n                \"fetch_interval\": 900,\n                \"initial_entries_count\": 2,\n                \"update_entries_count\": 1\n            }\n        )\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"url\"] == \"http://example.com/feed.xml\"\n        assert data[\"fetch_interval\"] == 900\n        assert data[\"initial_entries_count\"] == 2\n        assert data[\"update_entries_count\"] == 1\n\n    def test_list_feeds(self, client, test_token: str, test_feed: RSSFeed):\n        \"\"\"测试获取RSS源列表\"\"\"\n        response = client.get(\n            \"/api/v1/rss/feeds\",\n            headers={\"Authorization\": f\"Bearer {test_token}\"}\n        )\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data) == 1\n        assert data[0][\"id\"] == test_feed.id\n        assert data[0][\"title\"] == test_feed.title\n\n    def test_get_feed(self, client, test_token: str, test_feed: RSSFeed):\n        \"\"\"测试获取单个RSS源\"\"\"\n        response = client.get(\n            f\"/api/v1/rss/feeds/{test_feed.id}\",\n            headers={\"Authorization\": f\"Bearer {test_token}\"}\n        )\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"id\"] == test_feed.id\n        assert data[\"title\"] == test_feed.title\n\n    def test_update_feed(self, client, test_token: str, test_feed: RSSFeed):\n        \"\"\"测试更新RSS源\"\"\"\n        response = client.put(\n            f\"/api/v1/rss/feeds/{test_feed.id}\",\n            headers={\"Authorization\": f\"Bearer {test_token}\"},\n            json={\n                \"fetch_interval\": 1800,\n                \"initial_entries_count\": 5,\n                \"update_entries_count\": 3\n            }\n        )\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"fetch_interval\"] == 1800\n        assert data[\"initial_entries_count\"] == 5\n        assert data[\"update_entries_count\"] == 3\n\n    def test_delete_feed(self, client, test_token: str, test_feed: RSSFeed):\n        \"\"\"测试删除RSS源\"\"\"\n        response = client.delete(\n            f\"/api/v1/rss/feeds/{test_feed.id}\",\n            headers={\"Authorization\": f\"Bearer {test_token}\"}\n        )\n        assert response.status_code == status.HTTP_200_OK\n\n    def test_fetch_feed(self, client, test_token: str, test_feed: RSSFeed, mock_feed_manager):\n        \"\"\"测试手动获取RSS源更新\"\"\"\n        # 确保 mock 完全覆盖 FeedManager\n        with patch('api.v1.rss.FeedManager', return_value=mock_feed_manager):\n            mock_feed_manager.fetch_feed.return_value = None\n            \n            response = client.post(\n                f\"/api/v1/rss/feeds/{test_feed.id}/fetch\",\n                headers={\"Authorization\": f\"Bearer {test_token}\"}\n            )\n            assert response.status_code == status.HTTP_200_OK\n            mock_feed_manager.fetch_feed.assert_called_once()\n\n    def test_list_feed_entries(self, client, test_token: str, test_feed: RSSFeed, db_session: Session):\n        \"\"\"测试获取RSS源条目列表\"\"\"\n        # 创建测试条目\n        entry = RSSEntry(\n            feed_id=test_feed.id,\n            guid=\"test_guid\",\n            title=\"Test Entry\",\n            link=\"http://example.com/entry1\",\n            published=TimeUtil.now_ms()\n        )\n        db_session.add(entry)\n        db_session.commit()\n\n        response = client.get(\n            f\"/api/v1/rss/feeds/{test_feed.id}/entries\",\n            headers={\"Authorization\": f\"Bearer {test_token}\"}\n        )\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data) == 1\n        assert data[0][\"title\"] == entry.title\n        assert data[0][\"link\"] == entry.link\n\nclass TestRSSService:\n    \"\"\"RSS服务层测试\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_feed_creation(self, db_session: Session, mock_feed_manager):\n        \"\"\"测试RSS源的创建\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test1@example.com\",\n            hashed_password=get_password_hash(\"testpass\"),\n            is_active=True\n        )\n        db_session.add(user)\n        db_session.commit()\n        \n        feed = RSSFeed(\n            url=\"https://test-feed-url.com/rss\",\n            title=\"Test Feed\",\n            user_id=user.id,\n            fetch_interval=900,  # 15分钟\n            initial_entries_count=2,\n            update_entries_count=1\n        )\n        db_session.add(feed)\n        db_session.commit()\n        \n        assert feed.id is not None\n        assert feed.url == \"https://test-feed-url.com/rss\"\n        assert feed.title == \"Test Feed\"\n        assert feed.user_id == user.id\n        assert feed.fetch_interval == 900\n        assert feed.initial_entries_count == 2\n        assert feed.update_entries_count == 1\n\n    @pytest.mark.asyncio\n    async def test_feed_fetch_initial(self, db_session: Session, mock_feed_manager):\n        \"\"\"测试RSS源的首次抓取\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test1@example.com\",\n            hashed_password=get_password_hash(\"testpass\"),\n            is_active=True\n        )\n        db_session.add(user)\n        db_session.commit()\n        \n        feed = RSSFeed(\n            url=\"https://test-feed-url.com/rss\",\n            title=\"Test Feed\",\n            user_id=user.id,\n            fetch_interval=900,\n            initial_entries_count=2,\n            update_entries_count=1\n        )\n        db_session.add(feed)\n        db_session.commit()\n        \n        await mock_feed_manager.fetch_feed(feed)\n        mock_feed_manager.fetch_feed.assert_called_once_with(feed)\n\n    @pytest.mark.asyncio\n    async def test_feed_fetch_update(self, db_session: Session, mock_feed_manager):\n        \"\"\"测试RSS源的更新抓取\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test3@example.com\",\n            hashed_password=get_password_hash(\"testpass\"),\n            is_active=True\n        )\n        db_session.add(user)\n        db_session.commit()\n        \n        # 创建RSS Feed，配置更新时处理1条\n        last_fetch = get_time_with_offset(-7200)  # 2小时前\n        feed = RSSFeed(\n            url=\"https://test-feed-url.com/rss\",\n            title=\"Test Feed\",\n            user_id=user.id,\n            initial_entries_count=2,\n            update_entries_count=1,\n            last_fetch=last_fetch,\n            fetch_interval=900\n        )\n        db_session.add(feed)\n        db_session.commit()\n        \n        await mock_feed_manager.fetch_feed(feed)\n        mock_feed_manager.fetch_feed.assert_called_once_with(feed)\n\n    @pytest.mark.asyncio\n    async def test_scheduled_feed_fetch(self, db_session: Session, mock_feed_manager):\n        \"\"\"测试定时任务\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test4@example.com\",\n            hashed_password=get_password_hash(\"testpass\"),\n            is_active=True\n        )\n        db_session.add(user)\n        db_session.commit()\n        \n        # 创建两个RSS Feed\n        now = get_current_time()\n        feed1 = RSSFeed(\n            url=\"https://test-feed1.com/rss\",\n            title=\"Test Feed 1\",\n            user_id=user.id,\n            last_fetch=None,  # 从未抓取过，应该被更新\n            initial_entries_count=2,\n            is_active=True\n        )\n        \n        feed2 = RSSFeed(\n            url=\"https://test-feed2.com/rss\",\n            title=\"Test Feed 2\",\n            user_id=user.id,\n            last_fetch=now,  # 刚刚抓取过，不应该被更新\n            fetch_interval=3600,  # 1小时更新一次\n            initial_entries_count=2,\n            is_active=True\n        )\n        \n        db_session.add_all([feed1, feed2])\n        db_session.commit()\n        \n        feed1_id = feed1.id\n        feed2_id = feed2.id\n        feed2_original_fetch = feed2.last_fetch\n        \n        # 模拟 process_all_feeds 的行为\n        async def mock_process_all_feeds():\n            # 只处理需要更新的feed\n            current_time = get_current_time()\n            feeds = db_session.query(RSSFeed).filter(\n                RSSFeed.is_active == True,\n                (\n                    RSSFeed.last_fetch.is_(None) |\n                    (\n                        RSSFeed.last_fetch < current_time - 3600000  # 1小时的毫秒数\n                    )\n                )\n            ).all()\n            \n            for feed in feeds:\n                feed.last_fetch = current_time\n                db_session.add(feed)\n            db_session.commit()\n            \n        # 设置 mock\n        mock_feed_manager.process_all_feeds = AsyncMock(side_effect=mock_process_all_feeds)\n        \n        # 模拟调度器执行\n        with patch('core.scheduler.get_db', return_value=iter([db_session])), \\\n             patch('core.scheduler.FeedManager', return_value=mock_feed_manager):\n            await fetch_all_feeds()\n            \n            # 验证结果\n            feed1 = db_session.get(RSSFeed, feed1_id)\n            feed2 = db_session.get(RSSFeed, feed2_id)\n            \n            assert feed1.last_fetch is not None  # feed1应该被更新\n            assert feed2.last_fetch == feed2_original_fetch  # feed2不应该被更新\n            \n            # 验证 process_all_feeds 被调用\n            mock_feed_manager.process_all_feeds.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_process_latest_entry_only(self, db_session: Session, mock_feed_manager):\n        \"\"\"测试是否只处理最新的RSS条目\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test5@example.com\",\n            hashed_password=get_password_hash(\"testpass\"),\n            is_active=True\n        )\n        db_session.add(user)\n        db_session.commit()\n        \n        # 创建RSS Feed\n        feed = RSSFeed(\n            url=\"https://test-feed3.com/rss\",\n            title=\"Test Feed 3\",\n            user_id=user.id,\n            initial_entries_count=1\n        )\n        db_session.add(feed)\n        db_session.commit()\n        \n        await mock_feed_manager.fetch_feed(feed)\n        mock_feed_manager.fetch_feed.assert_called_once_with(feed)\n"}
{"type": "test_file", "path": "server/tests/test_complete_task.py", "content": "import os\nimport json\nimport time\nimport shutil\nfrom models.task import Task, TaskStatus, TaskProgress\nfrom services.task.processor import TaskProcessor\nfrom core.config import settings\nfrom services.task.steps.content import ContentStep\nfrom services.task.steps.dialogue import DialogueStep\nfrom services.task.steps.translation import TranslationStep\nfrom services.task.steps.audio import AudioStep\nimport tempfile\nfrom datetime import datetime\n\n\ndef test_complete_task_execution(client, test_user, db_session):\n    \"\"\"测试完整的任务执行流程\"\"\"\n    start_time = time.time()\n    temp_dir = None\n    try:\n        # 1. 登录获取token\n        login_response = client.post(\n            \"/api/v1/auth/login\",\n            data={\n                \"username\": \"testuser\",\n                \"password\": \"testpass\"\n            }\n        )\n        assert login_response.status_code == 200, f\"登录失败: {login_response.text}\"\n        token = login_response.json()[\"access_token\"]\n        \n        # 2. 创建任务\n        response = client.post(\n            \"/api/v1/tasks\",\n            headers={\"Authorization\": f\"Bearer {token}\"},\n            json={\n                \"url\": \"https://mp.weixin.qq.com/s/oPu6ngqcN2fNHdvP-dW-AQ\",\n                \"is_public\": True,\n                \"style_params\": {\n                    \"content_length\": \"medium\",\n                    \"tone\": \"casual\",\n                    \"emotion\": \"neutral\"\n                }\n            }\n        )\n        \n        assert response.status_code == 201, f\"创建任务失败: {response.text}\"\n        task_data = response.json()\n        task_id = task_data[\"taskId\"]\n        \n        # 3. 等待任务处理完成(最多等待10分钟)\n        max_retries = 120  # 120次\n        retry_interval = 5  # 5秒\n        task_completed = False\n        \n        for retry_count in range(max_retries):\n            status_response = client.get(\n                f\"/api/v1/tasks/{task_id}\",\n                headers={\"Authorization\": f\"Bearer {token}\"}\n            )\n            assert status_response.status_code == 200, f\"获取任务状态失败: {status_response.text}\"\n            current_status = status_response.json()\n            \n            # 添加更详细的调试信息\n            print(f\"Retry {retry_count + 1}/{max_retries}\")\n            print(f\"Current task status: {current_status}\")\n            print(f\"Current step: {current_status.get('current_step')}\")\n            print(f\"Progress message: {current_status.get('progress_message')}\")\n            \n            if current_status[\"status\"] == \"completed\":\n                task_completed = True\n                break\n            elif current_status[\"status\"] == \"failed\":\n                raise Exception(f\"任务处理失败: {current_status.get('error', '未知错误')}\")\n            \n            time.sleep(retry_interval)\n        \n        assert task_completed, \"任务未在规定时间内完成\"\n        \n        # 4. 验证任务结果\n        final_response = client.get(\n            f\"/api/v1/tasks/{task_id}\",\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n        assert final_response.status_code == 200, f\"获取最终任务状态失败: {final_response.text}\"\n        final_task = final_response.json()\n        \n        # 验证任务状态\n        assert final_task[\"status\"] == \"completed\"\n        assert final_task[\"progress\"] == \"completed\"\n        assert \"files\" in final_task\n        assert isinstance(final_task[\"files\"], dict)\n        \n        # 验证任务结果\n        task = db_session.query(Task).filter(Task.taskId == task_id).first()\n        assert task is not None\n        assert task.status == TaskStatus.COMPLETED.value\n        assert task.progress == TaskProgress.COMPLETED.value\n        \n        # 打印目录内容用于调试\n        task_dir = os.path.join(settings.TASK_DIR, task_id)\n        print(\"\\nTask directory structure:\")\n        for root, dirs, files in os.walk(task_dir):\n            level = root.replace(task_dir, '').count(os.sep)\n            indent = '  ' * level\n            folder = os.path.basename(root)\n            print(f\"{indent}+ {folder}/\")\n            for file in files:\n                print(f\"{indent}  - {file}\")\n                \n        # 复制任务目录到临时目录\n        temp_dir = tempfile.mkdtemp(prefix=\"task_\")\n        temp_task_dir = os.path.join(temp_dir, task_id)\n        shutil.copytree(task_dir, temp_task_dir)\n        print(f\"\\nTask directory copied to: {temp_task_dir}\")\n        \n        # 验证生成的文件\n        for level in task.files:\n            # 验证中文文件\n            cn_files = task.files[level][\"cn\"]\n            assert os.path.exists(cn_files[\"audio\"]), f\"中文音频文件不存在: {cn_files['audio']}\"\n            assert os.path.exists(cn_files[\"subtitle\"]), f\"中文字幕文件不存在: {cn_files['subtitle']}\"\n            \n            # 验证英文文件\n            en_files = task.files[level][\"en\"]\n            assert os.path.exists(en_files[\"audio\"]), f\"英文音频文件不存在: {en_files['audio']}\"\n            assert os.path.exists(en_files[\"subtitle\"]), f\"英文字幕文件不存在: {en_files['subtitle']}\"\n    \n    except Exception as e:\n        print(f\"测试失败: {str(e)}\")\n        if hasattr(e, '__traceback__'):\n            import traceback\n            print(f\"Traceback:\\n{''.join(traceback.format_tb(e.__traceback__))}\")\n        raise\n    finally:\n        # 确保清理任何剩余的资源\n        try:\n            if 'task_id' in locals():\n                db_session.query(Task).filter(Task.taskId == task_id).delete()\n                db_session.commit()\n        except Exception as e:\n            print(f\"清理资源时出错: {str(e)}\")\n            db_session.rollback()\n            \n        # 打印总执行时间\n        end_time = time.time()\n        execution_time = end_time - start_time\n        print(f\"\\nTotal execution time: {execution_time:.2f} seconds\")\n"}
{"type": "test_file", "path": "server/tests/test_tasks.py", "content": "import os\n\nimport pytest\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\nfrom pydantic import ValidationError\nfrom sqlalchemy.orm import Session\n\nfrom core.config import settings\nfrom models.enums import TaskStatus, TaskProgress\nfrom models.task import Task\nfrom schemas.task import TaskCreate, StyleParams\nfrom utils.time_utils import TimeUtil\nfrom utils.auth import get_password_hash\nfrom models.user import User\n\n\ndef get_valid_test_url():\n    \"\"\"获取用于测试的有效URL\"\"\"\n    return \"https://mp.weixin.qq.com/s/test-article\"\n\ndef get_test_task_data(url=None):\n    \"\"\"获取用于测试的任务数据\"\"\"\n    return {\n        \"url\": url or get_valid_test_url()\n    }\n\ndef test_create_task(client, test_user, override_get_db, db_session):\n    \"\"\"测试创建任务\"\"\"\n    # 获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 创建任务\n    response = client.post(\n        \"/api/v1/tasks\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json=get_test_task_data()\n    )\n    \n    # 添加详细的错误信息输出\n    if response.status_code != status.HTTP_201_CREATED:\n        print(f\"Error response: {response.status_code}\")\n        print(f\"Response content: {response.content}\")\n        \n    assert response.status_code == status.HTTP_201_CREATED\n    data = response.json()\n    \n    # 验证任务创建成功\n    db_session.rollback()  # 回滚之前的事务\n    with db_session.begin():  # 使用上下文管理器自动管理事务\n        task = db_session.query(Task).filter(Task.taskId == data[\"taskId\"]).first()\n        assert task is not None\n        assert task.status == TaskStatus.PROCESSING.value\n        assert task.created_by == test_user.id\n\ndef test_get_task(client, test_user, test_task):\n    # 先登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取任务详情\n    response = client.get(\n        f\"/api/v1/tasks/{test_task.taskId}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"taskId\"] == test_task.taskId\n    assert data[\"url\"] == test_task.url\n\ndef test_list_tasks(client, test_user, test_task):\n    \"\"\"测试获取任务列表\"\"\"\n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取任务列表\n    response = client.get(\n        \"/api/v1/tasks\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert isinstance(data, dict)\n    assert \"items\" in data\n    assert \"total\" in data\n    assert len(data[\"items\"]) > 0\n    \ndef test_delete_task(client, test_user, test_task):\n    # 先登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 删除任务\n    response = client.delete(\n        f\"/api/v1/tasks/{test_task.taskId}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    \n    # 验证任务文件夹已删除\n    task_dir = os.path.join(settings.TASK_DIR, test_task.taskId)\n    assert not os.path.exists(task_dir)\n\ndef test_get_task_not_found(client, test_user):\n    # 先登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取不存在的任务\n    response = client.get(\n        \"/api/v1/tasks/non-existent-id\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\ndef test_unauthorized_access(client):\n    # 未登录访问\n    response = client.get(\"/api/v1/tasks\")\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\ndef test_list_tasks_with_no_tasks(client, test_user):\n    \"\"\"测试空任务列表\"\"\"\n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取任务列表\n    response = client.get(\n        \"/api/v1/tasks\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert isinstance(data, dict)\n    assert \"items\" in data\n    assert \"total\" in data\n    assert len(data[\"items\"]) == 0\n    assert data[\"total\"] == 0\n\ndef test_list_tasks_with_private_tasks(client, test_user, test_task, db_session):\n    \"\"\"测试私有任务访问权限\"\"\"\n    # 创建一个私有任务\n    private_task = Task(\n        taskId=\"private-task-id\",\n        url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n        status=TaskStatus.COMPLETED.value,\n        progress=TaskProgress.COMPLETED.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        created_at=TimeUtil.now_ms(),\n        updated_at=TimeUtil.now_ms()\n    )\n    db_session.add(private_task)\n    db_session.commit()\n    \n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取任务列表\n    response = client.get(\n        \"/api/v1/tasks\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    \n    # 验证私有任务可见性\n    task_ids = [task[\"taskId\"] for task in data[\"items\"]]\n    assert private_task.taskId in task_ids  # 用户可以看到自己的私有任务\n\ndef test_get_task_processing_status(client, test_user, db_session):\n    \"\"\"测试获取处理中任务的状态\"\"\"\n    # 创建处理中的任务\n    task = Task(\n        taskId=\"processing-task-id\",\n        url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.PROCESSING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        created_at=TimeUtil.now_ms(),\n        updated_at=TimeUtil.now_ms(),\n        style_params={\n            \"content_length\": \"medium\",\n            \"tone\": \"casual\",\n            \"emotion\": \"neutral\"\n        }\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取任务详情\n    response = client.get(\n        f\"/api/v1/tasks/{task.taskId}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"status\"] == TaskStatus.PROCESSING.value\n\ndef test_get_task_forbidden(client, test_user, test_admin, db_session):\n    \"\"\"测试访问其他用户的私有任务\"\"\"\n    # 创建私有任务\n    task = Task(\n        taskId=\"private-task-id\",\n        url=\"https://example.com/private\",\n        status=TaskStatus.COMPLETED.value,\n        progress=TaskProgress.COMPLETED.value,\n        user_id=test_admin.id,\n        created_by=test_admin.id,\n        is_public=False\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    # 使用普通用户登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 尝试访问私有任务\n    response = client.get(\n        f\"/api/v1/tasks/{task.taskId}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n\ndef test_list_tasks_with_pagination(client, test_user, test_task):\n    # 先登录获token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取任务列表，使用分页参数\n    response = client.get(\n        \"/api/v1/tasks?limit=1&offset=0\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert isinstance(data, dict)\n    assert \"items\" in data\n    assert \"total\" in data\n    assert len(data[\"items\"]) == 1  # 验证分页返回的任务数量\n\ndef test_task_timestamps(client, test_user, db_session):\n    \"\"\"测试任务创建和更新时间戳\"\"\"\n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 记录创建前的时间戳\n    before_create = TimeUtil.now_ms()\n    \n    # 创建任务\n    response = client.post(\n        \"/api/v1/tasks\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json=get_test_task_data()\n    )\n    assert response.status_code == status.HTTP_201_CREATED\n    data = response.json()\n    \n    # 验证时间戳格式\n    assert \"created_at\" in data\n    assert \"updated_at\" in data\n    assert isinstance(data[\"created_at\"], int)\n    assert isinstance(data[\"updated_at\"], int)\n    assert data[\"created_at\"] >= before_create\n    assert data[\"updated_at\"] >= before_create\n    # 允许1秒的误差范围\n    assert abs(data[\"created_at\"] - data[\"updated_at\"]) <= 1000\n\ndef test_retry_failed_task(client, test_user, db_session):\n    \"\"\"测试重试失败的任务\"\"\"\n    # 创建一个失败的任务\n    task = Task(\n        taskId=\"failed-task-id\",\n        url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n        status=TaskStatus.FAILED.value,\n        progress=TaskProgress.FAILED.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        created_at=TimeUtil.now_ms(),\n        updated_at=TimeUtil.now_ms(),\n        current_step=\"任务处理失败\",  # 设置初始步骤状态\n        style_params={\n            \"content_length\": \"long\",\n            \"tone\": \"casual\",\n            \"emotion\": \"neutral\"\n        }\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 重试任务\n    response = client.post(\n        f\"/api/v1/tasks/{task.taskId}/retry\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    \n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert \"message\" in data\n    assert \"Task retry started\" in data[\"message\"]\n    \n    # 验证任务状态已更新\n    task = db_session.query(Task).filter(Task.taskId == task.taskId).first()\n    assert task.status == TaskStatus.PROCESSING.value\n    assert task.progress == TaskProgress.WAITING.value\n    \n    # 获取最新的任务状态\n    status_response = client.get(\n        f\"/api/v1/tasks/{task.taskId}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert status_response.status_code == status.HTTP_200_OK\n    status_data = status_response.json()\n    assert \"current_step\" in status_data  # 在任务详情中验证 current_step\n\ndef test_update_task(client, test_user, test_task, db_session):\n    \"\"\"测试更新任务\"\"\"\n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 先查看当前任务状态\n    task = db_session.query(Task).filter(Task.taskId == test_task.taskId).first()\n    \n    # 更新任务\n    update_data = {\n        \"style_params\": StyleParams(\n            content_length=\"long\",\n            tone=\"casual\",\n            emotion=\"neutral\"\n        ).model_dump()\n    }\n    response = client.patch(\n        f\"/api/v1/tasks/{test_task.taskId}\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json=update_data\n    )\n    \n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"style_params\"][\"content_length\"] == \"long\"\n\ndef test_list_tasks_with_filters(client, test_user, test_tasks):\n    \"\"\"测试任务列表过滤功能\"\"\"\n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser0\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 测试状态过滤\n    response = client.get(\n        \"/api/v1/tasks?status=completed&limit=10&offset=0\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert \"items\" in data\n    assert \"total\" in data\n    assert data[\"total\"] > 0  # 验证有数据\n    assert len(data[\"items\"]) > 0\n    assert all(task[\"status\"] == \"completed\" for task in data[\"items\"])\n    \n    # 测试日期过滤\n    current_time = TimeUtil.now_ms()\n    response = client.get(\n        f\"/api/v1/tasks?start_date={current_time - 86400000}&limit=10&offset=0\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"total\"] > 0\n\ndef test_list_tasks_with_keyword_search(client, test_user, db_session):\n    \"\"\"测试任务列表关键词搜索\"\"\"\n    # 创建一些测试任务\n    tasks = []\n    for i in range(3):\n        task = Task(\n            taskId=f\"test-search-task-{i}\",\n            url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n            status=TaskStatus.COMPLETED.value,\n            progress=TaskProgress.COMPLETED.value,\n            title=f\"Test Title {i}\",\n            user_id=test_user.id,\n            created_by=test_user.id,\n            updated_by=test_user.id,\n            is_public=True,\n            created_at=TimeUtil.now_ms(),\n            updated_at=TimeUtil.now_ms()\n        )\n        tasks.append(task)\n    \n    db_session.add_all(tasks)\n    db_session.commit()\n    \n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 使用关键词搜索\n    response = client.get(\n        \"/api/v1/tasks?keyword=Test\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert len(data[\"items\"]) > 0\n    for item in data[\"items\"]:\n        assert \"Test\" in item[\"title\"]\n\ndef test_create_task_with_valid_url(client: TestClient, db_session: Session, test_user):\n    \"\"\"测试使用有效的微信公众号URL创建任务\"\"\"\n    # 获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n\n    url = \"https://mp.weixin.qq.com/s/valid-article-id\"\n    task_data = {\n        \"url\": url,\n        \"is_public\": False\n    }\n\n    response = client.post(\n        \"/api/v1/tasks\",\n        json=task_data,\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"url\"] == url\n\n    # 验证任务是否真的创建在数据库中\n    db_session.expire_all()  # 清理会话状态\n    db_session.rollback()  # 回滚之前的事务\n    task = db_session.query(Task).filter(Task.url == url).first()\n    assert task is not None\n\ndef test_create_task_with_invalid_url(client: TestClient, db_session: Session, test_user):\n    \"\"\"测试使用无效URL创建任务时的错误处理\"\"\"\n    # 获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    invalid_urls = [\n        \"https://example.com/article\",  # 非微信公众号URL\n        \"http://mp.weixin.qq.com/s/article-id\",  # 非HTTPS\n        \"https://other-site.com/post\",  # 完全不相关的网站\n        \"not-a-url\",  # 非URL格式\n        \"\",  # 空URL\n    ]\n    \n    for url in invalid_urls:\n        task_data = {\n            \"url\": url,\n            \"is_public\": False\n        }\n        \n        response = client.post(\n            \"/api/v1/tasks\",\n            json=task_data,\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n        \n        assert response.status_code == 422  # 应该返回验证错误\n        error_data = response.json()\n        assert isinstance(error_data, dict)\n        assert \"detail\" in error_data\n        \n        if url.startswith(\"https://\") and \"mp.weixin.qq.com\" not in url:\n            # URL 格式正确但不是微信链接\n            assert \"URL必须匹配模式\" in str(error_data[\"detail\"])\n        \n        # 验证没有任务被创建\n        db_session.rollback()  # 回滚之前的事务\n        with db_session.begin():  # 使用上下文管理器自动管理事务\n            task = db_session.query(Task).filter(Task.url == url).first()\n            assert task is None\n\ndef test_create_task_with_modified_url_pattern(client: TestClient, db_session: Session, test_user, monkeypatch):\n    \"\"\"测试修改URL模式后的任务创建\"\"\"\n    # 获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n\n    # 临时修改允许的URL模式\n    new_pattern = r'^https://(mp\\.weixin\\.qq\\.com|example\\.com)'\n    monkeypatch.setattr(settings, \"ALLOWED_URL_PATTERN\", new_pattern)\n\n    # 测试新模式允许的URL\n    valid_urls = [\n        \"https://mp.weixin.qq.com/s/article-1\",\n        \"https://example.com/post-1\"\n    ]\n\n    for url in valid_urls:\n        task_data = {\n            \"url\": url,\n            \"is_public\": False\n        }\n\n        response = client.post(\n            \"/api/v1/tasks\",\n            json=task_data,\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"url\"] == url\n\n        # 验证任务是否真的创建在数据库中\n        db_session.rollback()  # 回滚之前的事务\n        with db_session.begin():  # 使用上下文管理器自动管理事务\n            task = db_session.query(Task).filter(Task.url == url).first()\n            assert task is not None\n\ndef test_task_create_schema_validation():\n    \"\"\"测试TaskCreate模型的URL验证\"\"\"\n    # 测试有效URL\n    valid_url = \"https://mp.weixin.qq.com/s/valid-id\"\n    task = TaskCreate(url=valid_url, is_public=False)\n    assert str(task.url) == valid_url\n    \n    # 测试各种无效URL\n    invalid_urls = [\n        \"https://example.com/article\",  # 不匹配模式\n        \"not-a-url\",  # 非URL格式\n        \"\",  # 空字符串\n    ]\n    \n    for invalid_url in invalid_urls:\n        with pytest.raises(ValidationError) as exc_info:  # 只捕获 ValidationError\n            TaskCreate(url=invalid_url, is_public=False)\n        error_message = str(exc_info.value)\n        \n        if invalid_url.startswith(\"https://\"):\n            # URL 格式正确但不是微信链接\n            assert \"URL必须匹配模式\" in error_message\n        else:\n            # 非 HTTPS URL 或无效 URL\n            assert \"URL\" in error_message  # 简化错误消息检查\n\n@pytest.mark.asyncio\nasync def test_create_task_error_handling(client: TestClient, db_session: Session, test_user):\n    \"\"\"测试创建任务时的错误处理\"\"\"\n    # 获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 测试无效的JSON数据\n    response = client.post(\n        \"/api/v1/tasks\",\n        json={\"invalid\": \"data\"},\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == 422  # FastAPI的验证错误\n    \n    # 测试缺少必需字段\n    response = client.post(\n        \"/api/v1/tasks\",\n        json={\"is_public\": True},  # 缺少url字段\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == 422\n\ndef test_list_tasks_with_private_tasks(client, test_user, test_task, db_session):\n    \"\"\"测试私有任务访问权限\"\"\"\n    # 创建一个私有任务\n    private_task = Task(\n        taskId=\"test-private-task\",\n        url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n        status=TaskStatus.COMPLETED.value,\n        progress=TaskProgress.COMPLETED.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False,\n        created_at=TimeUtil.now_ms(),\n        updated_at=TimeUtil.now_ms()\n    )\n    db_session.add(private_task)\n    db_session.commit()\n    \n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取任务列表\n    response = client.get(\n        \"/api/v1/tasks\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    \n    # 验证返回的任务列表包含私有任务\n    task_ids = [task[\"taskId\"] for task in data[\"items\"]]\n    assert private_task.taskId in task_ids\n\ndef test_list_tasks_with_pagination(client, test_user, test_task):\n    \"\"\"测试任务列表分页\"\"\"\n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取第一页任务列表\n    response = client.get(\n        \"/api/v1/tasks?page=1&per_page=10\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert \"items\" in data\n    assert isinstance(data[\"items\"], list)\n\ndef test_task_timestamps(client, test_user, db_session):\n    \"\"\"测试任务创建和更新时间戳\"\"\"\n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 记录创建前的时间戳\n    before_create = TimeUtil.now_ms()\n    \n    # 创建任务\n    response = client.post(\n        \"/api/v1/tasks\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json=get_test_task_data()\n    )\n    assert response.status_code == status.HTTP_201_CREATED\n    data = response.json()\n    \n    # 验证时间戳格式\n    assert \"created_at\" in data\n    assert \"updated_at\" in data\n    assert isinstance(data[\"created_at\"], int)\n    assert isinstance(data[\"updated_at\"], int)\n    assert data[\"created_at\"] >= before_create\n    assert data[\"updated_at\"] >= before_create\n    # 允许1秒的误差范围\n    assert abs(data[\"created_at\"] - data[\"updated_at\"]) <= 1000\n\ndef test_list_tasks_with_filters(client, test_user, test_tasks):\n    \"\"\"测试任务列表过滤功能\"\"\"\n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 使用不同的过滤条件获取任务列表\n    filters = [\n        \"?status=completed\",\n        \"?start_date=1609459200000\",  # 2021-01-01\n        \"?end_date=1640995200000\",    # 2021-12-31\n        \"?keyword=test\"\n    ]\n    \n    for filter_str in filters:\n        response = client.get(\n            f\"/api/v1/tasks{filter_str}\",\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert \"items\" in data\n        assert isinstance(data[\"items\"], list)\n\ndef test_update_task(client, test_user, test_task):\n    \"\"\"测试更新任务\"\"\"\n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 更新任务\n    update_data = {\n        \"is_public\": True,\n        \"style_params\": StyleParams(\n            content_length=\"long\",\n            tone=\"formal\",\n            emotion=\"professional\"\n        ).model_dump()\n    }\n    \n    response = client.patch(\n        f\"/api/v1/tasks/{test_task.taskId}\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json=update_data\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"is_public\"] == update_data[\"is_public\"]\n    assert data[\"style_params\"][\"content_length\"] == update_data[\"style_params\"][\"content_length\"]\n\ndef test_list_tasks_with_keyword_search(client, test_user, db_session):\n    \"\"\"测试任务列表关键词搜索\"\"\"\n    # 创建一些测试任务\n    tasks = []\n    for i in range(3):\n        task = Task(\n            taskId=f\"test-search-task-{i}\",\n            url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n            status=TaskStatus.COMPLETED.value,\n            progress=TaskProgress.COMPLETED.value,\n            title=f\"Test Title {i}\",\n            user_id=test_user.id,\n            created_by=test_user.id,\n            updated_by=test_user.id,\n            is_public=True,\n            created_at=TimeUtil.now_ms(),\n            updated_at=TimeUtil.now_ms()\n        )\n        tasks.append(task)\n    \n    db_session.add_all(tasks)\n    db_session.commit()\n    \n    # 登录获取token\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 使用关键词搜索\n    response = client.get(\n        \"/api/v1/tasks?keyword=Test\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert len(data[\"items\"]) > 0\n    for item in data[\"items\"]:\n        assert \"Test\" in item[\"title\"]\n"}
{"type": "test_file", "path": "server/tests/utils/auth.py", "content": "from datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom jose import jwt\n\nfrom core.config import settings\n\ndef create_test_token(\n    username: str,\n    expires_delta: Optional[timedelta] = None\n) -> str:\n    \"\"\"创建测试用的JWT令牌\"\"\"\n    to_encode = {\"sub\": username}\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(\n        to_encode,\n        settings.JWT_SECRET_KEY,\n        algorithm=settings.JWT_ALGORITHM\n    )\n    return encoded_jwt "}
{"type": "test_file", "path": "server/tests/test_task_processor.py", "content": "import os\nimport json\nimport shutil\nfrom unittest.mock import patch, MagicMock\nfrom models.task import Task, TaskStatus, TaskProgress\nfrom services.task.processor import TaskProcessor\nfrom services.task.steps.content import ContentStep\nfrom services.task.steps.fetch_content import FetchContentStep\nfrom services.task.steps.generate_title import GenerateTitleStep\nfrom services.task.steps.dialogue import DialogueStep\nfrom services.task.steps.translation import TranslationStep\nfrom services.task.steps.audio import AudioStep\n\n\ndef test_fetch_content_step(db_session, test_user):\n    \"\"\"测试内容获取步骤\"\"\"\n    task = Task(\n        taskId=\"test-fetch-content\",\n        url=\"https://mp.weixin.qq.com/s/oPu6ngqcN2fNHdvP-dW-AQ\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.PROCESSING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    processor = TaskProcessor(task, db_session)\n    os.makedirs(processor.temp_dir, exist_ok=True)\n    \n    # 设置上下文\n    processor.context_manager.set(\"url\", task.url)\n    processor.context_manager.set(\"taskId\", task.taskId)\n    processor.context_manager.set(\"current_step_index\", 0)\n    \n    fetch_content_step = FetchContentStep(\n        progress_tracker=processor.progress_tracker,\n        context_manager=processor.context_manager\n    )\n    \n    try:\n        # 执行内容获取步骤\n        result = fetch_content_step.execute()\n        \n        # 验证结果\n        assert \"raw_content.txt\" in result  # 改为.txt\n        assert \"raw_content\" in result\n        \n        # 验证生成的文件\n        content_filename = result[\"raw_content.txt\"]\n        content_path = os.path.join(processor.temp_dir, content_filename)\n        assert os.path.exists(content_path)\n        \n        with open(content_path, 'r', encoding='utf-8') as f:\n            content = f.read()  # 直接读取文本内容\n            assert len(content) > 0\n            \n    finally:\n        if os.path.exists(processor.temp_dir):\n            shutil.rmtree(processor.temp_dir)\n\ndef mock_generate_title(*args, **kwargs):\n    \"\"\"模拟标题生成\"\"\"\n    return \"文字的迷宫，意义的探寻\"\n\n@patch('services.task.steps.generate_title.GenerateTitleStep._generate_title', side_effect=mock_generate_title)\ndef test_generate_title_step(mock_generate_title, db_session, test_user):\n    \"\"\"测试标题生成步骤\"\"\"\n    task = Task(\n        taskId=\"test-generate-title\",\n        url=\"https://mp.weixin.qq.com/s/oPu6ngqcN2fNHdvP-dW-AQ\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.PROCESSING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    processor = TaskProcessor(task, db_session)\n    os.makedirs(processor.temp_dir, exist_ok=True)\n    \n    # 创建raw_content.txt\n    raw_content = \"这是一篇测试文章的内容...\"\n    raw_content_filename = \"raw_content.txt\"\n    raw_content_path = os.path.join(processor.temp_dir, raw_content_filename)\n    with open(raw_content_path, 'w', encoding='utf-8') as f:\n        f.write(raw_content)\n    \n    # 设置上下文\n    processor.context_manager.set(\"raw_content.txt\", raw_content_filename)\n    processor.context_manager.set(\"raw_content\", raw_content)\n    processor.context_manager.set(\"taskId\", task.taskId)\n    processor.context_manager.set(\"current_step_index\", 1)\n    \n    generate_title_step = GenerateTitleStep(\n        progress_tracker=processor.progress_tracker,\n        context_manager=processor.context_manager\n    )\n    \n    try:\n        # 执行标题生成步骤\n        result = generate_title_step.execute()\n        \n        # 验证结果\n        assert \"title\" in result\n        assert isinstance(result[\"title\"], str)\n        assert len(result[\"title\"]) > 0\n            \n        # 验证任务标题已更新\n        db_session.refresh(task)\n        assert task.title == result[\"title\"]\n            \n    finally:\n        if os.path.exists(processor.temp_dir):\n            shutil.rmtree(processor.temp_dir)\n\ndef test_content_step(db_session, test_user):\n    \"\"\"测试内容处理步骤\"\"\"\n    task = Task(\n        taskId=\"test-content-step\",\n        url=\"https://mp.weixin.qq.com/s/oPu6ngqcN2fNHdvP-dW-AQ\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.PROCESSING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    processor = TaskProcessor(task, db_session)\n    os.makedirs(processor.temp_dir, exist_ok=True)\n    \n    # 创建难度等级目录\n    level = \"elementary\"\n    level_dir = os.path.join(processor.temp_dir, level)\n    os.makedirs(level_dir, exist_ok=True)\n    \n    # 创建raw_content.txt\n    raw_content = \"这是一篇测试文章的内容...\"  # 直接使用文本内容\n    raw_content_filename = \"raw_content.txt\"\n    raw_content_path = os.path.join(processor.temp_dir, raw_content_filename)\n    with open(raw_content_path, 'w', encoding='utf-8') as f:\n        f.write(raw_content)  # 直接写入文本\n        \n    # 创建title.txt\n    title = \"测试标题\"  # 直接使用文本内容\n    title_filename = \"title.txt\"\n    title_path = os.path.join(processor.temp_dir, title_filename)\n    with open(title_path, 'w', encoding='utf-8') as f:\n        f.write(title)  # 直接写入文本\n    \n    # 设置上下文\n    processor.context_manager.set(\"raw_content.txt\", raw_content_filename)\n    processor.context_manager.set(\"raw_content\", raw_content)\n    processor.context_manager.set(\"title.txt\", title_filename)\n    processor.context_manager.set(\"title\", title)\n    processor.context_manager.set(\"level_dir\", level_dir)\n    processor.context_manager.set(\"current_step_index\", 2)\n    \n    content_step = ContentStep(\n        level=\"elementary\",\n        progress_tracker=processor.progress_tracker,\n        context_manager=processor.context_manager\n    )\n    \n    try:\n        # 执行内容处理步骤\n        result = content_step.execute()\n        \n        # 验证结果\n        assert f\"{level}/content.txt\" in result  # 改为.txt\n        \n        # 验证生成的文件\n        content_filename = result[f\"{level}/content.txt\"]\n        content_path = os.path.join(level_dir, content_filename)\n        assert os.path.exists(content_path)\n        \n        with open(content_path, 'r', encoding='utf-8') as f:\n            content = f.read()  # 直接读取文本内容\n            assert len(content) > 0\n            \n    finally:\n        if os.path.exists(processor.temp_dir):\n            shutil.rmtree(processor.temp_dir)\n\ndef test_dialogue_step(db_session, test_user):\n    \"\"\"测试对话生成步骤\"\"\"\n    task = Task(\n        taskId=\"test-dialogue-step\",\n        url=\"https://mp.weixin.qq.com/s/oPu6ngqcN2fNHdvP-dW-AQ\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.PROCESSING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    processor = TaskProcessor(task, db_session)\n    os.makedirs(processor.temp_dir, exist_ok=True)\n    \n    # 创建难度等级目录\n    level = \"elementary\"\n    level_dir = os.path.join(processor.temp_dir, level)\n    os.makedirs(level_dir, exist_ok=True)\n    \n    # 设置上下文\n    processor.context_manager.set(\"level_dir\", level_dir)\n    processor.context_manager.set(\"current_step_index\", 0)\n    processor.context_manager.set(\"current_level\", \"elementary\")\n    processor.context_manager.set(\"role\", \"host\")\n    processor.context_manager.set(\"style_params\", {\n        \"role\": \"host\",\n        \"tone\": \"friendly\",\n        \"length\": \"medium\"\n    })\n    \n    # 修改内容文件的存放位置和设置\n    content_data = \"This is test content...\"  # 改为纯文本内容\n    content_filename = \"content.txt\"  # 改为.txt\n    content_path = os.path.join(level_dir, content_filename)\n    with open(content_path, 'w', encoding='utf-8') as f:\n        f.write(content_data)\n        \n    # 更新上下文中的文件路径\n    processor.context_manager.set(f\"{level}/content.txt\", content_filename)\n        \n    dialogue_step = DialogueStep(\n        level=\"elementary\",\n        progress_tracker=processor.progress_tracker,\n        context_manager=processor.context_manager\n    )\n    \n    try:\n        # 执行对话生成步骤\n        result = dialogue_step.execute()\n        \n        # 验证结果\n        assert f\"{level}/dialogue_en.json\" in result  # 改为检查英文对话文件\n        \n        # 验证生成的文件\n        dialogue_filename = result[f\"{level}/dialogue_en.json\"]  # 改为文对话文件名\n        dialogue_path = os.path.join(level_dir, dialogue_filename)\n        assert os.path.exists(dialogue_path)\n        \n        with open(dialogue_path, 'r', encoding='utf-8') as f:\n            dialogue_data = json.load(f)\n            assert isinstance(dialogue_data, list)\n            assert len(dialogue_data) > 0\n            for item in dialogue_data:\n                assert \"role\" in item\n                assert \"content\" in item\n                assert item[\"role\"] in [\"host\", \"guest\"]\n                # 可以添加检查确保内容是英文的逻辑\n                assert isinstance(item[\"content\"], str)\n                assert len(item[\"content\"]) > 0\n                \n    finally:\n        if os.path.exists(processor.temp_dir):\n            shutil.rmtree(processor.temp_dir)\n\ndef test_translation_step(db_session, test_user):\n    \"\"\"测试翻译步骤\"\"\"\n    task = Task(\n        taskId=\"test-translation-step\",\n        url=\"https://mp.weixin.qq.com/s/oPu6ngqcN2fNHdvP-dW-AQ\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.PROCESSING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    processor = TaskProcessor(task, db_session)\n    os.makedirs(processor.temp_dir, exist_ok=True)\n    \n    # 创建难度等级目录\n    level = \"elementary\"\n    level_dir = os.path.join(processor.temp_dir, level)\n    os.makedirs(level_dir, exist_ok=True)\n    \n    # 设置level_dir到上下文\n    processor.context_manager.set(\"level_dir\", level_dir)\n    processor.context_manager.set(\"current_step_index\", 0)  # 添加步骤索引\n    \n    # 创建测试英文对话文件\n    dialogue_en = [\n        {\n            \"role\": \"host\",\n            \"content\": \"Hello, welcome to our show\"\n        },\n        {\n            \"role\": \"guest\",\n            \"content\": \"Thank you, glad to be here\"\n        }\n    ]\n    dialogue_filename = \"dialogue_en.json\"\n    dialogue_path = os.path.join(level_dir, dialogue_filename)\n    with open(dialogue_path, 'w', encoding='utf-8') as f:\n        json.dump(dialogue_en, f, ensure_ascii=False, indent=2)\n        \n    processor.context_manager.set(f\"{level}/dialogue_en.json\", dialogue_filename)\n    translation_step = TranslationStep(\n        level=\"elementary\",\n        progress_tracker=processor.progress_tracker,\n        context_manager=processor.context_manager\n    )\n    \n    try:\n        # 执行翻译步骤\n        result = translation_step.execute()\n        \n        # 验证结果\n        assert f\"{level}/dialogue_cn.json\" in result\n        \n        # 验证生成的文件\n        dialogue_filename = result[f\"{level}/dialogue_cn.json\"]\n        dialogue_path = os.path.join(level_dir, dialogue_filename)\n        assert os.path.exists(dialogue_path)\n        \n        with open(dialogue_path, 'r', encoding='utf-8') as f:\n            dialogue_cn = json.load(f)\n            assert isinstance(dialogue_cn, list)\n            assert len(dialogue_cn) == len(dialogue_en)\n            for item in dialogue_cn:\n                assert \"role\" in item\n                assert \"content\" in item\n                assert item[\"role\"] in [\"host\", \"guest\"]\n                # 可以添加检查确保内容是中文的逻辑\n                assert isinstance(item[\"content\"], str)\n                assert len(item[\"content\"]) > 0\n                \n    finally:\n        if os.path.exists(processor.temp_dir):\n            shutil.rmtree(processor.temp_dir)\n\ndef test_audio_step(db_session, test_user):\n    \"\"\"测试音频生成步骤\"\"\"\n    task = Task(\n        taskId=\"test-audio-step\",\n        url=\"https://mp.weixin.qq.com/s/oPu6ngqcN2fNHdvP-dW-AQ\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.PROCESSING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    processor = TaskProcessor(task, db_session)\n    os.makedirs(processor.temp_dir, exist_ok=True)\n    \n    # 创建难度等级目录\n    level = \"elementary\"\n    lang = \"cn\"\n    level_dir = os.path.join(processor.temp_dir, level)\n    os.makedirs(level_dir, exist_ok=True)\n    \n    # 设置level_dir到上下文\n    processor.context_manager.set(\"level_dir\", level_dir)\n    processor.context_manager.set(\"current_step_index\", 0)  # 添加步骤索引\n    \n    # 创建测试对话文件\n    dialogue = [\n        {\n            \"role\": \"host\",\n            \"content\": \"你好，欢迎收听\"\n        },\n        {\n            \"role\": \"guest\",\n            \"content\": \"谢谢，很高兴参与讨论\"\n        }\n    ]\n    dialogue_filename = f\"{task.taskId}_{level}_cn.json\"\n    dialogue_path = os.path.join(level_dir, dialogue_filename)\n    with open(dialogue_path, 'w', encoding='utf-8') as f:\n        json.dump(dialogue, f, ensure_ascii=False, indent=2)\n        \n    processor.context_manager.set(f\"{level}/dialogue_cn.json\", dialogue_filename)\n    audio_step = AudioStep(\n        level=\"elementary\",\n        lang=\"cn\",\n        progress_tracker=processor.progress_tracker,\n        context_manager=processor.context_manager\n    )\n    \n    try:\n        # 执行音频生成步骤\n        result = audio_step.execute()\n        \n        # 验证结果\n        assert f\"{level}/audio_files_{lang}.json\" in result  # 修改这里\n        \n        # 验证生成的文件\n        audio_files_filename = result[f\"{level}/audio_files_{lang}.json\"]  # 改这里\n        audio_files_path = os.path.join(level_dir, audio_files_filename)\n        assert os.path.exists(audio_files_path)\n        \n        with open(audio_files_path, 'r', encoding='utf-8') as f:\n            audio_files = json.load(f)\n            assert isinstance(audio_files, list)\n            assert len(audio_files) == len(dialogue)\n            for item in audio_files:\n                assert \"index\" in item\n                assert \"role\" in item\n                assert \"filename\" in item\n                audio_path = os.path.join(level_dir, item[\"filename\"])\n                assert os.path.exists(audio_path)\n                \n    finally:\n        if os.path.exists(processor.temp_dir):\n            shutil.rmtree(processor.temp_dir)\n\ndef test_task_step_retry(db_session, test_user):\n    \"\"\"测试任务步骤重试\"\"\"\n    # 设置mock的返回值\n    mock_audio_segment = MagicMock()\n    mock_audio_segment.duration_seconds = 5.0\n    mock_audio_segment.__len__ = lambda self: 5000\n    mock_audio_segment.__add__ = lambda self, other: mock_audio_segment\n    mock_audio_segment.export = MagicMock()\n    mock_audio_segment.set_frame_rate = MagicMock(return_value=mock_audio_segment)\n    mock_audio_segment.set_channels = MagicMock(return_value=mock_audio_segment)\n    \n    # 设置所有mock的返回值\n    mock_subtitle_from_mp3 = MagicMock(return_value=mock_audio_segment)\n    mock_merge_from_mp3 = MagicMock(return_value=mock_audio_segment)\n    mock_merge_from_file = MagicMock(return_value=mock_audio_segment)\n    mock_verify_audio = MagicMock(return_value=True)  # 添加这行，保验证总是通过\n    \n    task = Task(\n        taskId=\"test-retry-task\",\n        url=\"https://mp.weixin.qq.com/s/oPu6ngqcN2fNHdvP-dW-AQ\",\n        status=TaskStatus.FAILED.value,\n        progress=TaskProgress.FAILED.value,\n        progress_message=\"翻译对话内容失败\",\n        current_step=\"翻译对话内容\",\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    # 创建处理器实例\n    processor = TaskProcessor(task, db_session, is_retry=True)\n    \n    # 使用process_task_async\n    future = TaskProcessor.process_task_async(task, db_session, is_retry=True)\n    \n    try:\n        future.result()  # 等待任务完成\n        \n        # 验证任务状态\n        db_session.refresh(task)\n        assert task.status == TaskStatus.COMPLETED.value\n        assert task.progress == TaskProgress.COMPLETED.value\n        levels = [\"elementary\", \"intermediate\", \"advanced\"]\n        # 验证生成的文件\n        for level in levels:\n            level_dir = os.path.join(processor.temp_dir, level)\n            assert os.path.exists(os.path.join(level_dir, \"content.txt\"))\n            assert os.path.exists(os.path.join(level_dir, \"dialogue_en.json\"))\n            assert os.path.exists(os.path.join(level_dir, \"dialogue_cn.json\"))\n        \n    finally:\n        if os.path.exists(processor.temp_dir):\n            shutil.rmtree(processor.temp_dir)\n\ndef test_task_execution_failure(db_session, test_user):\n    \"\"\"测试任务执行失败场景\"\"\"\n    task = Task(\n        taskId=\"test-failure-task\",\n        url=\"https://invalid-url.com\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.WAITING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    # 创建处理器实例\n    processor = TaskProcessor(task, db_session)\n    \n    # 创建处理器并执行任务\n    future = TaskProcessor.process_task_async(task, db_session)\n    \n    try:\n        future.result()  # 等待任务完成\n    except Exception:\n        pass  # 我们期望任务失败，所以忽略异常\n        \n    # 验证任务状态\n    db_session.refresh(task)\n    \n    # 验证任务失败状态\n    assert task.status == TaskStatus.FAILED.value\n    assert task.progress == TaskProgress.FAILED.value\n    assert task.current_step == \"获取页面内容\"\n    assert task.step_progress == 0\n    assert task.progress_message is not None\n    assert \"请求URL失败\" in task.progress_message\n    \n    # 验证上下文是否保存\n    context_file = os.path.join(processor.temp_dir, \"context.json\")\n    assert os.path.exists(context_file)\n    \n    # 验证上下文内容\n    with open(context_file, 'r', encoding='utf-8') as f:\n        context = json.load(f)\n        assert context['taskId'] == task.taskId\n        assert context['status'] == TaskStatus.FAILED.value\n    \n    # 清理测试文件\n    if os.path.exists(processor.temp_dir):\n        shutil.rmtree(processor.temp_dir)\n\ndef setup_test_files_and_dirs(processor, task, levels=None):\n    \"\"\"设置测试文件和目录的辅助函数\"\"\"\n    if levels is None:\n        levels = [\"elementary\", \"intermediate\", \"advanced\"]\n        \n    os.makedirs(processor.temp_dir, exist_ok=True)\n    \n    # 创建raw_content.txt\n    raw_content = \"这是一篇测试文章的内容...\"\n    raw_content_filename = \"raw_content.txt\"  # 改为.txt\n    raw_content_path = os.path.join(processor.temp_dir, raw_content_filename)\n    with open(raw_content_path, 'w', encoding='utf-8') as f:\n        f.write(raw_content)  # 直接写入文本\n    \n    # 创建title.txt\n    title = \"测试标题\"\n    title_filename = \"title.txt\"  # 改为.txt\n    title_path = os.path.join(processor.temp_dir, title_filename)\n    with open(title_path, 'w', encoding='utf-8') as f:\n        f.write(title)  # 直接写入文本\n    \n    # 为每个难度等级创建目录和文件\n    for level in levels:\n        level_dir = os.path.join(processor.temp_dir, level)\n        os.makedirs(level_dir, exist_ok=True)\n        \n        # 创建对话文件\n        dialogue_cn = [\n            {\n                \"role\": \"host\",\n                \"content\": \"让我们来讨论下教育创新的重要性\"\n            },\n            {\n                \"role\": \"guest\", \n                \"content\": \"教育创新确实是当今社会发展的重要议题\"\n            }\n        ]\n        dialogue_filename = \"dialogue_cn.json\"\n        dialogue_path = os.path.join(level_dir, dialogue_filename)\n        with open(dialogue_path, 'w', encoding='utf-8') as f:\n            json.dump(dialogue_cn, f, ensure_ascii=False, indent=2)\n            \n        # 创建英文对话文件\n        dialogue_en = [\n            {\n                \"role\": \"host\",\n                \"content\": \"Let's discuss the importance of educational innovation\"\n            },\n            {\n                \"role\": \"guest\", \n                \"content\": \"Educational innovation is indeed an important topic\"\n            }\n        ]\n        dialogue_en_filename = \"dialogue_en.json\"\n        dialogue_en_path = os.path.join(level_dir, dialogue_en_filename)\n        with open(dialogue_en_path, 'w', encoding='utf-8') as f:\n            json.dump(dialogue_en, f, ensure_ascii=False, indent=2)\n            \n        # 创建音频文件配置\n        audio_files_cn = [\n            {\n                \"index\": 0,\n                \"role\": \"host\",\n                \"filename\": \"0000_cn_host.mp3\",\n                \"text\": \"让我们来讨论下教育创新的重要性\"\n            },\n            {\n                \"index\": 1,\n                \"role\": \"guest\",\n                \"filename\": \"0001_cn_guest.mp3\",\n                \"text\": \"教育创新确实是当今社会发展的重要议题\"\n            }\n        ]\n        \n        audio_files_en = [\n            {\n                \"index\": 0,\n                \"role\": \"host\",\n                \"filename\": \"0000_en_host.mp3\",\n                \"text\": \"Let's discuss the importance of educational innovation\"\n            },\n            {\n                \"index\": 1,\n                \"role\": \"guest\",\n                \"filename\": \"0001_en_guest.mp3\",\n                \"text\": \"Educational innovation is indeed an important topic\"\n            }\n        ]\n        \n        # 保存音频配置文件\n        audio_config_cn_filename = \"audio_files_cn.json\"\n        audio_config_cn_path = os.path.join(level_dir, audio_config_cn_filename)\n        with open(audio_config_cn_path, 'w', encoding='utf-8') as f:\n            json.dump(audio_files_cn, f, ensure_ascii=False, indent=2)\n            \n        audio_config_en_filename = \"audio_files_en.json\"\n        audio_config_en_path = os.path.join(level_dir, audio_config_en_filename)\n        with open(audio_config_en_path, 'w', encoding='utf-8') as f:\n            json.dump(audio_files_en, f, ensure_ascii=False, indent=2)\n            \n        # 更新上下文\n        processor.context_manager.set(f\"{level}/dialogue_cn.json\", dialogue_filename)\n        processor.context_manager.set(f\"{level}/dialogue_en.json\", dialogue_en_filename)\n        processor.context_manager.set(f\"{level}/audio_files_cn.json\", audio_config_cn_filename)\n        processor.context_manager.set(f\"{level}/audio_files_en.json\", audio_config_en_filename)\n        processor.context_manager.set(f\"{level}_dir\", level_dir)\n        \n        # 创建模拟的音频文件\n        for audio in audio_files_cn + audio_files_en:\n            audio_path = os.path.join(level_dir, audio[\"filename\"])\n            with open(audio_path, 'wb') as f:\n                f.write(b'\\xFF\\xFB\\x30\\x00')  # MP3 文件头\n                for _ in range(10):\n                    f.write(b'\\xFF\\xFB\\x30\\x00' + b'\\x00' * 380)\n    \n    # 设置基本上下文\n    processor.context_manager.set(\"raw_content.txt\", raw_content_filename)\n    processor.context_manager.set(\"raw_content\", raw_content)\n    processor.context_manager.set(\"title.txt\", title_filename)\n    processor.context_manager.set(\"title\", title)\n\n@patch('services.task.steps.audio.AudioSegment.from_mp3')\n@patch('services.task.steps.audio.AudioSegment.from_file')\n@patch('services.task.steps.audio.AudioStep._verify_audio_file')\n@patch('services.task.steps.audio.EdgeTTSService')\n@patch('services.task.steps.audio.AudioStep._generate_audio_with_retry')\n@patch('services.task.steps.dialogue.DialogueStep._execute')\n@patch('services.task.steps.translation.TranslationStep._execute')\ndef test_dialogue_generation_with_difficulty_levels(\n    mock_translate, mock_dialogue, mock_generate_audio, \n    mock_tts_service, mock_verify_audio, mock_from_file, mock_from_mp3,\n    db_session, test_user):\n    \"\"\"测试不同难度等级的对话生成\"\"\"\n    # 设置mock返回值\n    mock_audio_segment = MagicMock()\n    mock_audio_segment.duration_seconds = 5.0\n    mock_audio_segment.__len__ = lambda self: 5000  # 添加这行，模拟5秒长度\n    mock_audio_segment.__add__ = lambda self, other: mock_audio_segment\n    mock_audio_segment.export = MagicMock()\n    mock_audio_segment.set_frame_rate = MagicMock(return_value=mock_audio_segment)\n    mock_audio_segment.set_channels = MagicMock(return_value=mock_audio_segment)\n    \n    mock_verify_audio.return_value = True\n    mock_generate_audio.return_value = True\n    mock_tts_service.return_value = MagicMock()\n    mock_dialogue.side_effect = mock_dialogue_execute\n    mock_translate.side_effect = mock_translate_execute\n    mock_from_file.return_value = mock_audio_segment\n    mock_from_mp3.return_value = mock_audio_segment\n    \n    task = Task(\n        taskId=\"test-difficulty-levels\",\n        url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.PROCESSING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False,\n        metadata={\n            \"difficulty_level\": \"intermediate\",\n            \"style_params\": {\n                \"length\": \"medium\", \n                \"tone\": \"casual\",\n                \"emotion\": \"positive\",\n                \"professionalism\": \"moderate\"\n            }\n        }\n    )\n    db_session.add(task)\n    db_session.commit()\n\n    processor = TaskProcessor(task, db_session)\n    \n    try:\n        setup_test_files_and_dirs(processor, task)\n        processor.process_task()\n        \n        # 验证任务状态\n        db_session.refresh(task)\n        assert task.status == TaskStatus.COMPLETED.value\n        assert task.progress == TaskProgress.COMPLETED.value\n        \n        # 修改期望的文件结构，使用标准化的文件名格式\n        expected_files = {\n            'elementary': {\n                'cn': {\n                    'audio': f\"elementary_cn_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"elementary_cn_subtitle_{task.taskId}.srt\"\n                },\n                'en': {\n                    'audio': f\"elementary_en_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"elementary_en_subtitle_{task.taskId}.srt\"\n                }\n            },\n            'intermediate': {\n                'cn': {\n                    'audio': f\"intermediate_cn_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"intermediate_cn_subtitle_{task.taskId}.srt\"\n                },\n                'en': {\n                    'audio': f\"intermediate_en_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"intermediate_en_subtitle_{task.taskId}.srt\"\n                }\n            },\n            'advanced': {\n                'cn': {\n                    'audio': f\"advanced_cn_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"advanced_cn_subtitle_{task.taskId}.srt\"\n                },\n                'en': {\n                    'audio': f\"advanced_en_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"advanced_en_subtitle_{task.taskId}.srt\"\n                }\n            }\n        }\n        \n        assert task.files == expected_files\n        \n    finally:\n        if os.path.exists(processor.temp_dir):\n            shutil.rmtree(processor.temp_dir)\n\n@patch('services.task.steps.audio.AudioSegment.from_mp3')\n@patch('services.task.steps.audio.AudioSegment.from_file')\n@patch('services.task.steps.audio.AudioStep._verify_audio_file')\n@patch('services.task.steps.audio.EdgeTTSService')\n@patch('services.task.steps.audio.AudioStep._generate_audio_with_retry')\n@patch('services.task.steps.dialogue.DialogueStep._execute')\n@patch('services.task.steps.translation.TranslationStep._execute')\ndef test_dialogue_generation_style_parameters(\n    mock_translate, mock_dialogue, mock_generate_audio, \n    mock_tts_service, mock_verify_audio, mock_from_file, mock_from_mp3,\n    db_session, test_user):\n    \"\"\"测试对话生成的风格参数\"\"\"\n    # 设置mock返回值\n    mock_audio_segment = MagicMock()\n    mock_audio_segment.duration_seconds = 5.0\n    mock_audio_segment.__len__ = lambda self: 5000  # 添加这行，模拟5秒长度\n    mock_audio_segment.__add__ = lambda self, other: mock_audio_segment\n    mock_audio_segment.export = MagicMock()\n    mock_audio_segment.set_frame_rate = MagicMock(return_value=mock_audio_segment)\n    mock_audio_segment.set_channels = MagicMock(return_value=mock_audio_segment)\n    \n    mock_verify_audio.return_value = True\n    mock_generate_audio.return_value = True\n    mock_tts_service.return_value = MagicMock()\n    mock_dialogue.side_effect = mock_dialogue_execute\n    mock_translate.side_effect = mock_translate_execute\n    mock_from_file.return_value = mock_audio_segment\n    mock_from_mp3.return_value = mock_audio_segment\n    \n    task = Task(\n        taskId=\"test-style-params\",\n        url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n        status=TaskStatus.PROCESSING.value,\n        progress=TaskProgress.PROCESSING.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=False,\n        metadata={\n            \"difficulty_level\": \"advanced\",\n            \"style_params\": {\n                \"length\": \"long\",\n                \"tone\": \"formal\", \n                \"emotion\": \"neutral\",\n                \"professionalism\": \"expert\"\n            }\n        }\n    )\n    db_session.add(task)\n    db_session.commit()\n\n    processor = TaskProcessor(task, db_session)\n    \n    try:\n        setup_test_files_and_dirs(processor, task)\n        processor.process_task()\n        \n        # 验证任务状态\n        db_session.refresh(task)\n        assert task.status == TaskStatus.COMPLETED.value\n        assert task.progress == TaskProgress.COMPLETED.value\n        \n        # 验证files内容，使用标准化的文件名格式\n        expected_files = {\n            'elementary': {\n                'cn': {\n                    'audio': f\"elementary_cn_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"elementary_cn_subtitle_{task.taskId}.srt\"\n                },\n                'en': {\n                    'audio': f\"elementary_en_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"elementary_en_subtitle_{task.taskId}.srt\"\n                }\n            },\n            'intermediate': {\n                'cn': {\n                    'audio': f\"intermediate_cn_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"intermediate_cn_subtitle_{task.taskId}.srt\"\n                },\n                'en': {\n                    'audio': f\"intermediate_en_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"intermediate_en_subtitle_{task.taskId}.srt\"\n                }\n            },\n            'advanced': {\n                'cn': {\n                    'audio': f\"advanced_cn_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"advanced_cn_subtitle_{task.taskId}.srt\"\n                },\n                'en': {\n                    'audio': f\"advanced_en_audio_{task.taskId}.mp3\",\n                    'subtitle': f\"advanced_en_subtitle_{task.taskId}.srt\"\n                }\n            }\n        }\n        \n        assert task.files == expected_files\n        \n    finally:\n        if os.path.exists(processor.temp_dir):\n            shutil.rmtree(processor.temp_dir)\n\nfrom unittest.mock import patch, MagicMock\n\n# 修改mock_dialogue_execute函数\ndef mock_dialogue_execute(*args, **kwargs):\n    \"\"\"模拟对话生成\"\"\"\n    context_manager = args[0]\n    level = context_manager.get(\"current_level\")\n    \n    if not level:\n        raise ValueError(\"current_level not found in context\")\n    \n    return {\n        f\"{level}/dialogue_en.json\": \"dialogue_en.json\"\n    }\n\n# 修改mock_translate_execute函数\ndef mock_translate_execute(*args, **kwargs):\n    \"\"\"模拟翻译执行\"\"\"\n    context_manager = args[0]\n    level = context_manager.get(\"current_level\")\n    \n    if not level:\n        raise ValueError(\"current_level not found in context\")\n    \n    return {\n        f\"{level}/dialogue_cn.json\": \"dialogue_cn.json\",\n        f\"{level}/dialogue_en.json\": \"dialogue_en.json\"  # 添加英文对话文件\n    }\n"}
{"type": "test_file", "path": "server/tests/test_users.py", "content": "import os\n\nfrom fastapi import status\n\nfrom core.config import settings\nfrom models.user import User\nfrom utils.time_utils import TimeUtil\n\n\ndef test_delete_user_as_admin(client, test_admin, test_user, test_task):\n    # 使用管理员登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"admin\",\n            \"password\": \"adminpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 验证任务文件夹存在\n    task_dir = os.path.join(settings.TASK_DIR, test_task.taskId)\n    assert os.path.exists(task_dir)\n    \n    # 删除用户\n    response = client.delete(\n        f\"/api/v1/users/{test_user.id}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_204_NO_CONTENT\n    \n    # 验证用户已删除\n    response = client.get(\n        f\"/api/v1/users/{test_user.id}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    \n    # 验证任务文件夹已删除\n    assert not os.path.exists(task_dir)\n\ndef test_delete_user_as_non_admin(client, test_user):\n    # 使用普通用户登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 尝试删除用户\n    response = client.delete(\n        f\"/api/v1/users/{test_user.id}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n\ndef test_list_users_with_pagination(client, test_admin):\n    # 使用管理员登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"admin\",\n            \"password\": \"adminpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取用户列表，使用分页参数\n    response = client.get(\n        \"/api/v1/users?limit=1&offset=0\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    \n    # 验证返回结构\n    assert \"total\" in data\n    assert \"items\" in data\n    assert isinstance(data[\"total\"], int)\n    assert isinstance(data[\"items\"], list)\n    assert len(data[\"items\"]) == 1  # 验证分页返回的用户数量\n\ndef test_list_users_with_filters(client, test_admin, test_user):\n    # 使用管理员登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"admin\",\n            \"password\": \"adminpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 测试用户名过滤\n    response = client.get(\n        \"/api/v1/users?username=test\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"total\"] > 0\n    assert all(\"test\" in user[\"username\"].lower() for user in data[\"items\"])\n    \n    # 测试状态过滤\n    response = client.get(\n        \"/api/v1/users?is_active=true\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"total\"] > 0\n    assert all(user[\"is_active\"] for user in data[\"items\"])\n    \n    # 测试日期过滤 - 使用时间戳\n    start_time = TimeUtil.now_ms() - (24 * 60 * 60 * 1000)  # 24小时前\n    response = client.get(\n        f\"/api/v1/users?start_date={start_time}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert isinstance(data[\"total\"], int)\n    assert isinstance(data[\"items\"], list)\n\ndef test_update_user_status(client, test_admin, test_user):\n    \"\"\"测试更新用户状态\"\"\"\n    # 使用管理员登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"admin\",\n            \"password\": \"adminpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 测试禁用用户\n    response = client.patch(\n        f\"/api/v1/users/{test_user.id}/status\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={\"is_active\": False}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"is_active\"] == False\n    assert data[\"id\"] == test_user.id\n    \n    # 测试启用用户\n    response = client.patch(\n        f\"/api/v1/users/{test_user.id}/status\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={\"is_active\": True}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"is_active\"] == True\n    assert data[\"id\"] == test_user.id\n\ndef test_update_user_status_as_non_admin(client, test_user):\n    \"\"\"测试非管理员更新用户状态\"\"\"\n    # 使用普通用户登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 尝试更新用户状态\n    response = client.patch(\n        f\"/api/v1/users/{test_user.id}/status\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={\"is_active\": False}\n    )\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n\ndef test_update_user_status_not_found(client, test_admin):\n    \"\"\"测试更新不存在的用户状态\"\"\"\n    # 使用管理员登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"admin\",\n            \"password\": \"adminpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 尝试更新不存在的用户\n    response = client.patch(\n        \"/api/v1/users/99999/status\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={\"is_active\": False}\n    )\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\ndef test_list_users_with_date_filter(client, test_admin, test_users):\n    \"\"\"测试用户列表日期过滤\"\"\"\n    # 管理员登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"admin\",\n            \"password\": \"adminpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 获取当前时间戳\n    current_time = TimeUtil.now_ms()\n    \n    # 测试开始时间过滤\n    start_time = current_time - (24 * 60 * 60 * 1000)  # 24小时前\n    response = client.get(\n        f\"/api/v1/users?start_date={start_time}\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"total\"] > 0\n    for user in data[\"items\"]:\n        assert user[\"created_at\"] >= start_time\n\ndef test_update_current_user(client, test_user):\n    \"\"\"测试更新当前用户信息\"\"\"\n    # 登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 更新用户信息\n    update_data = {\n        \"nickname\": \"新昵称\",\n        \"email\": \"newemail@example.com\"\n    }\n    \n    response = client.patch(\n        \"/api/v1/users/me\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json=update_data\n    )\n    \n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"nickname\"] == update_data[\"nickname\"]\n    assert data[\"email\"] == update_data[\"email\"]\n\ndef test_update_password(client, test_user):\n    \"\"\"测试修改密码\"\"\"\n    # 登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 修改密码\n    response = client.post(\n        \"/api/v1/users/me/password\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={\n            \"old_password\": \"testpass\",\n            \"new_password\": \"newpass123\"\n        }\n    )\n    assert response.status_code == status.HTTP_200_OK\n    \n    # 使用新密码登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"newpass123\"\n        }\n    )\n    assert login_response.status_code == status.HTTP_200_OK\n\ndef test_update_password_wrong_old_password(client, test_user):\n    \"\"\"测试使用错误的旧密码修改密码\"\"\"\n    # 登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 尝试修改密码\n    response = client.post(\n        \"/api/v1/users/me/password\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={\n            \"old_password\": \"wrongpass\",\n            \"new_password\": \"newpass123\"\n        }\n    )\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n    assert \"旧密码错误\" in response.json()[\"detail\"]\n\ndef test_health_check(client):\n    \"\"\"测试健康检查接口\"\"\"\n    response = client.get(\"/api/v1/users/health\")\n    \n    # 验证响应状态码为200\n    assert response.status_code == status.HTTP_200_OK\n    \n    # 验证响应内容\n    data = response.json()\n    assert data[\"status\"] == \"ok\"\n    assert data[\"message\"] == \"服务正常运行\"\n\ndef test_test_user_login_with_test_password(client, db_session):\n    \"\"\"测试test用户使用test密码登录的特殊处理\"\"\"\n    # 确保启用test用户特殊处理\n    assert settings.TEST_USER_ENABLED == True\n    \n    # 使用test/test登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": settings.TEST_USERNAME,\n            \"password\": settings.TEST_PASSWORD\n        }\n    )\n    \n    # 验证登录成功\n    assert login_response.status_code == status.HTTP_200_OK\n    assert \"access_token\" in login_response.json()\n    \n    # 验证test用户已在数据库中创建\n    user = db_session.query(User).filter(User.username == settings.TEST_USERNAME).first()\n    assert user is not None\n    assert user.username == settings.TEST_USERNAME\n    assert user.is_active == True\n\ndef test_test_user_login_after_password_change(client, db_session):\n    \"\"\"测试test用户修改密码后仍可使用test密码登录\"\"\"\n    # 先使用test密码登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": settings.TEST_USERNAME,\n            \"password\": settings.TEST_PASSWORD\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 修改密码\n    new_password = \"newpassword123\"\n    response = client.post(\n        \"/api/v1/users/me/password\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={\n            \"old_password\": settings.TEST_PASSWORD,\n            \"new_password\": new_password\n        }\n    )\n    assert response.status_code == status.HTTP_200_OK\n    \n    # 验证新密码可以登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": settings.TEST_USERNAME,\n            \"password\": new_password\n        }\n    )\n    assert login_response.status_code == status.HTTP_200_OK\n    \n    # 验证test密码仍然可以登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": settings.TEST_USERNAME,\n            \"password\": settings.TEST_PASSWORD\n        }\n    )\n    assert login_response.status_code == status.HTTP_200_OK\n\ndef test_test_user_login_when_disabled(client, db_session):\n    \"\"\"测试禁用test用户特殊处理后的登录行为\"\"\"\n    # 禁用test用户特殊处理\n    settings.update_config(\n        db=db_session,\n        key=\"TEST_USER_ENABLED\",\n        value=False,\n        type_name=\"bool\",\n        description=\"是否启用test用户特殊处理\"\n    )\n    \n    # 尝试使用test密码登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": settings.TEST_USERNAME,\n            \"password\": settings.TEST_PASSWORD\n        }\n    )\n    \n    # 验证登录失败（因为特殊处理被禁用）\n    assert login_response.status_code == status.HTTP_401_UNAUTHORIZED\n    \n    # 恢复test用户特殊处理\n    settings.update_config(\n        db=db_session,\n        key=\"TEST_USER_ENABLED\",\n        value=True,\n        type_name=\"bool\",\n        description=\"是否启用test用户特殊处理\"\n    )\n\ndef test_test_user_config_update(client, test_admin, db_session):\n    \"\"\"测试更新test用户配置\"\"\"\n    # 使用管理员登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"admin\",\n            \"password\": \"adminpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 更新test用户配置\n    new_test_username = \"testuser2\"\n    response = client.put(\n        \"/api/v1/configs/TEST_USERNAME\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={\n            \"value\": new_test_username,\n            \"type\": \"str\",\n            \"description\": \"测试用户名\"\n        }\n    )\n    assert response.status_code == status.HTTP_200_OK\n    \n    # 验证新的test用户名可以登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": new_test_username,\n            \"password\": settings.TEST_PASSWORD\n        }\n    )\n    assert login_response.status_code == status.HTTP_200_OK\n\ndef test_update_user_me(client, test_user):\n    \"\"\"测试更新当前用户信息\"\"\"\n    # 登录\n    login_response = client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": \"testuser\",\n            \"password\": \"testpass\"\n        }\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # 更新用户信息\n    update_data = {\n        \"nickname\": \"New Nickname\",\n        \"email\": \"new.email@example.com\"\n    }\n    response = client.patch(\n        \"/api/v1/users/me\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json=update_data\n    )\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"nickname\"] == update_data[\"nickname\"]\n    assert data[\"email\"] == update_data[\"email\"]\n"}
{"type": "test_file", "path": "server/tests/conftest.py", "content": "import warnings\nwarnings.filterwarnings(\"ignore\", message=\"'audioop' is deprecated\", category=DeprecationWarning)\n\nimport sys\nfrom pathlib import Path\nsys.path.append(str(Path(__file__).parent.parent))\n\n# 配置 pytest-asyncio\npytest_plugins = ['pytest_asyncio']\n\ndef pytest_configure(config):\n    # 注册异步测试标记\n    config.addinivalue_line(\n        \"markers\",\n        \"asyncio: mark test as requiring asyncio\"\n    )\n\n# 然后是其他导入\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\nimport os\nimport shutil\nimport tempfile\n\nfrom db.base import Base\nfrom db.session import get_db\nfrom core.config import settings\nfrom models.task import Task\nfrom models.user import User\nfrom models.enums import TaskStatus, TaskProgress\nfrom utils.time_utils import TimeUtil\nfrom services.task.processor import TaskProcessor\n\n# 最后导入app\nfrom main import app\n\n# 使用内存数据库进行测试\nSQLALCHEMY_DATABASE_URL = \"sqlite:///:memory:\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL,\n    connect_args={\"check_same_thread\": False},\n    poolclass=StaticPool,\n)\nTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n@pytest.fixture(scope=\"function\")\ndef db_session():\n    \"\"\"每个测试函数都使用新的数据库会话\"\"\"\n    # 创建所有表\n    Base.metadata.drop_all(bind=engine)  # 先删除所有表\n    Base.metadata.create_all(bind=engine)  # 重新创建所有表\n    \n    db = TestingSessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n        Base.metadata.drop_all(bind=engine)  # 清理所有表\n\n@pytest.fixture\ndef override_get_db(db_session):\n    \"\"\"覆盖get_db依赖，确保所有代码使用相同的测试数据库会话\"\"\"\n    def _get_test_db():\n        try:\n            yield db_session\n        finally:\n            pass\n    return _get_test_db\n\n@pytest.fixture\ndef client(db_session, override_get_db):\n    \"\"\"创建测试客户端，并覆盖数据库依赖\"\"\"\n    app.dependency_overrides[get_db] = override_get_db\n    yield TestClient(app)\n    app.dependency_overrides.clear()\n\n@pytest.fixture\ndef test_user(db_session):\n    from auth.utils import get_password_hash\n    user = User(\n        username=\"testuser\",\n        hashed_password=get_password_hash(\"testpass\"),\n        nickname=\"Test User\"\n    )\n    db_session.add(user)\n    db_session.commit()\n    return user\n\n@pytest.fixture\ndef test_admin(db_session):\n    from auth.utils import get_password_hash\n    admin = User(\n        username=\"admin\",\n        hashed_password=get_password_hash(\"adminpass\"),\n        nickname=\"Admin User\",\n        is_admin=True\n    )\n    db_session.add(admin)\n    db_session.commit()\n    return admin\n\n@pytest.fixture\ndef test_task(test_user, db_session):\n    \"\"\"创建测试任务\"\"\"\n    task = Task(\n        taskId=\"test-task\",\n        url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n        status=TaskStatus.COMPLETED.value,\n        progress=TaskProgress.COMPLETED.value,\n        user_id=test_user.id,\n        created_by=test_user.id,\n        updated_by=test_user.id,\n        is_public=True,\n        created_at=TimeUtil.now_ms(),\n        updated_at=TimeUtil.now_ms(),\n        current_step=\"任务已完成\",\n        style_params={\n            \"content_length\": \"medium\",\n            \"tone\": \"casual\",\n            \"emotion\": \"neutral\"\n        }\n    )\n    db_session.add(task)\n    db_session.commit()\n    \n    # 创建任务文件夹\n    task_dir = os.path.join(settings.TASK_DIR, task.taskId)\n    os.makedirs(task_dir, exist_ok=True)\n    \n    return task\n\n@pytest.fixture\ndef test_tasks(test_user, db_session):\n    \"\"\"创建多个测试任务\"\"\"\n    tasks = []\n    for i in range(5):\n        task = Task(\n            taskId=f\"test-task-{i}\",\n            url=\"https://mp.weixin.qq.com/s/UXb0KyDCSHkUS_4dCGlsfQ\",\n            status=TaskStatus.COMPLETED.value,\n            progress=TaskProgress.COMPLETED.value,\n            user_id=test_user.id,\n            created_by=test_user.id,\n            updated_by=test_user.id,\n            is_public=True,\n            created_at=TimeUtil.now_ms(),\n            updated_at=TimeUtil.now_ms()\n        )\n        tasks.append(task)\n    \n    db_session.add_all(tasks)\n    db_session.commit()\n    return tasks\n\n@pytest.fixture\ndef test_users(db_session):\n    from auth.utils import get_password_hash\n    users = []\n    for i in range(5):  # 创建5个用户\n        user = User(\n            username=f\"testuser{i}\",\n            hashed_password=get_password_hash(\"testpass\"),\n            nickname=f\"Test User {i}\"\n        )\n        db_session.add(user)\n        users.append(user)\n    db_session.commit()\n    return users\n\n@pytest.fixture\ndef mock_execute_task(monkeypatch, db_session):\n    \"\"\"Mock execute_task to use test database session\"\"\"\n    from services.task.task_service import execute_task\n    \n    def mock_task_execution(task_id: str, is_retry: bool = False):\n        return execute_task(task_id, is_retry, db_session=db_session)\n    \n    # 替换原始的execute_task函数\n    monkeypatch.setattr(\"services.task.task_service.execute_task\", mock_task_execution)\n    return mock_task_execution\n\n@pytest.fixture(autouse=True)\ndef setup_task_execution(mock_execute_task):\n    \"\"\"自动使用mock的任务执行函数\"\"\"\n    pass\n\n@pytest.fixture(autouse=True)\ndef test_settings():\n    \"\"\"为测试环境设置临时任务目录\"\"\"\n    # 保存原始设置\n    original_task_dir = settings.TASK_DIR\n    \n    # 创建临时目录\n    temp_dir = tempfile.mkdtemp()\n    settings.TASK_DIR = temp_dir\n    \n    try:\n        yield\n    finally:\n        # 确保所有文件句柄都关闭\n        try:\n            for root, dirs, files in os.walk(temp_dir, topdown=False):\n                for name in files:\n                    try:\n                        os.chmod(os.path.join(root, name), 0o666)\n                    except:\n                        pass\n                for name in dirs:\n                    try:\n                        os.chmod(os.path.join(root, name), 0o777)\n                    except:\n                        pass\n            \n            # 尝试删除临时目录\n            shutil.rmtree(temp_dir, ignore_errors=True)\n        except Exception as e:\n            print(f\"Warning: Failed to cleanup temp directory {temp_dir}: {str(e)}\")\n        finally:\n            # 恢复原始设置\n            settings.TASK_DIR = original_task_dir\n\n@pytest.fixture\ndef task_processor(request, db_session):\n    \"\"\"创建任务处理器fixture\"\"\"\n    processor = None\n    \n    def _create_processor(task, is_retry=False):\n        nonlocal processor\n        processor = TaskProcessor(task, db_session, is_retry)\n        return processor\n        \n    yield _create_processor\n    \n    # 清理临时文件\n    if processor and os.path.exists(processor.temp_dir):\n        shutil.rmtree(processor.temp_dir)\n"}
{"type": "test_file", "path": "server/tests/api/__init__.py", "content": "\"\"\"API测试包\"\"\" "}
{"type": "test_file", "path": "server/tests/test_edgetts.py", "content": "import pytest\nimport tempfile\nimport asyncio\nfrom unittest.mock import Mock, patch, AsyncMock\nfrom server.services.edgetts import EdgeTTSService\n\n@pytest.fixture\ndef edge_tts_service():\n    return EdgeTTSService()\n\n@pytest.mark.asyncio\nasync def test_get_voices(edge_tts_service):\n    \"\"\"测试获取语音列表\"\"\"\n    mock_voices = [\n        {\n            'ShortName': 'en-US-AvaNeural',\n            'Gender': 'Female',\n            'Locale': 'en-US'\n        },\n        {\n            'ShortName': 'zh-CN-XiaoxiaoNeural',\n            'Gender': 'Female',\n            'Locale': 'zh-CN'\n        }\n    ]\n    \n    with patch('edge_tts.list_voices', return_value=mock_voices):\n        # 测试默认语言过滤\n        voices = await edge_tts_service._get_voices()\n        assert len(voices) == 1  # 只返回默认语言(en-US)的语音\n        assert voices[0]['name'] == 'en-US-AvaNeural'\n        \n        # 测试获取所有语音\n        voices = await edge_tts_service._get_voices(language='all')\n        assert len(voices) == 2  # 返回所有语音\n\ndef test_voice_mapping(edge_tts_service):\n    \"\"\"测试语音映射\"\"\"\n    assert edge_tts_service.voice_mapping['alloy'] == 'en-US-AvaNeural'\n    assert edge_tts_service.voice_mapping['echo'] == 'en-US-AndrewNeural'\n\n@pytest.mark.asyncio\nasync def test_generate_audio_success(edge_tts_service):\n    \"\"\"测试成功生成音频\"\"\"\n    mock_communicate = AsyncMock()\n    mock_communicate.save = AsyncMock()\n    \n    with patch('edge_tts.Communicate', return_value=mock_communicate) as mock_comm:\n        with tempfile.NamedTemporaryFile() as temp_file:\n            result = await edge_tts_service._generate_audio(\n                text=\"Hello world\",\n                voice=\"alloy\",\n                response_format=\"mp3\",\n                speed=1.0\n            )\n            \n            mock_comm.assert_called_once()\n            mock_communicate.save.assert_called_once()\n            assert isinstance(result, str)\n            assert result.endswith('.mp3')\n\ndef test_is_ffmpeg_installed(edge_tts_service):\n    \"\"\"测试FFmpeg安装检查\"\"\"\n    with patch('subprocess.run') as mock_run:\n        mock_run.return_value = Mock(returncode=0)\n        assert edge_tts_service._is_ffmpeg_installed() is True\n        \n        mock_run.side_effect = FileNotFoundError()\n        assert edge_tts_service._is_ffmpeg_installed() is False\n\n@pytest.mark.asyncio\nasync def test_generate_audio_with_conversion(edge_tts_service):\n    \"\"\"测试带格式转换的音频生成\"\"\"\n    mock_communicate = AsyncMock()\n    mock_communicate.save = AsyncMock()\n    \n    with patch('edge_tts.Communicate', return_value=mock_communicate), \\\n         patch('server.services.edgetts.EdgeTTSService._is_ffmpeg_installed', return_value=True), \\\n         patch('subprocess.run') as mock_run:\n        \n        result = await edge_tts_service._generate_audio(\n            text=\"Hello world\",\n            voice=\"alloy\",\n            response_format=\"wav\",\n            speed=1.5\n        )\n        \n        assert isinstance(result, str)\n        assert result.endswith('.wav')\n        mock_run.assert_called_once()\n\ndef test_get_models(edge_tts_service):\n    \"\"\"测试获取模型列表\"\"\"\n    models = edge_tts_service.get_models()\n    assert len(models) == 2\n    assert models[0]['id'] == 'tts-1'\n    assert models[1]['id'] == 'tts-1-hd'\n\n@pytest.mark.asyncio\nasync def test_generate_audio_failure(edge_tts_service):\n    \"\"\"测试音频生成失败的情况\"\"\"\n    with patch('edge_tts.Communicate', side_effect=Exception(\"Connection failed\")):\n        with pytest.raises(Exception) as exc_info:\n            await edge_tts_service._generate_audio(\n                text=\"Hello world\",\n                voice=\"alloy\",\n                response_format=\"mp3\",\n                speed=1.0\n            )\n        # 检查错误日志而不是具体的异常消息\n        assert isinstance(exc_info.value, Exception) "}
{"type": "test_file", "path": "server/tests/utils/__init__.py", "content": "\"\"\"测试工具包\"\"\" "}
{"type": "source_file", "path": "server/api/v1/rss.py", "content": "from typing import List\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import desc\nimport asyncio\nimport uuid\nimport aiohttp\nimport feedparser\nimport sqlalchemy.exc\n\nfrom db.session import get_db, SessionLocal\nfrom models.user import User\nfrom models.rss import RSSFeed, RSSEntry\nfrom models.task import Task\nfrom models.enums import TaskStatus, TaskProgress\nfrom schemas.rss import (\n    RSSFeedCreate,\n    RSSFeedUpdate,\n    RSSFeedResponse,\n    RSSFeedList,\n    RSSEntryResponse\n)\nfrom auth.dependencies import get_current_user\nfrom services.rss.feed_manager import FeedManager\nfrom services.task.processor import TaskProcessor\nfrom core.logging import log\n\nrouter = APIRouter()\n\n@router.get(\"/feeds\", response_model=List[RSSFeedList])\nasync def list_feeds(\n    skip: int = 0,\n    limit: int = 10,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"获取RSS源列表\"\"\"\n    feeds = (\n        db.query(RSSFeed)\n        .filter_by(user_id=current_user.id)\n        .order_by(desc(RSSFeed.id))\n        .offset(skip)\n        .limit(limit)\n        .all()\n    )\n    return feeds\n\n@router.get(\"/feeds/{feed_id}\", response_model=RSSFeedResponse)\nasync def get_feed(\n    feed_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"获取RSS源详情\"\"\"\n    feed = db.get(RSSFeed, feed_id)\n    if not feed or feed.user_id != current_user.id:\n        raise HTTPException(status_code=404, detail=\"RSS源不存在\")\n    return feed\n\n@router.post(\"/feeds\", response_model=RSSFeedResponse)\nasync def create_feed(\n    feed: RSSFeedCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"创建新的RSS源\"\"\"\n    # 检查是否已存在相同的RSS源\n    exists = db.query(RSSFeed).filter_by(\n        user_id=current_user.id,\n        url=str(feed.url)\n    ).first()\n    if exists:\n        raise HTTPException(status_code=400, detail=\"该RSS源已存在\")\n    \n    # 如果用户没有指定标题，则从RSS源获取\n    title = feed.title\n    if title is None:\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(str(feed.url)) as response:\n                    content = await response.text()\n                    parsed = feedparser.parse(content)\n                    \n            # 从RSS源获取标题\n            title = parsed.feed.get('title', str(feed.url))\n        except Exception as e:\n            log.error(f\"获取RSS源标题失败: {str(e)}\")\n            title = str(feed.url)  # 如果获取失败，使用URL字符串作为标题\n    \n    try:\n        # 创建新的RSS源\n        feed_data = feed.model_dump(exclude_unset=True)\n        feed_data['title'] = title\n        feed_data['user_id'] = current_user.id\n        feed_data['url'] = str(feed.url)  # 确保 URL 被转换为字符串\n        \n        new_feed = RSSFeed(**feed_data)\n        db.add(new_feed)\n        db.commit()\n        db.refresh(new_feed)\n        \n        # 创建一个独立的后台任务来处理RSS源\n        async def background_fetch():\n            try:\n                async_db = SessionLocal()\n                try:\n                    manager = FeedManager(async_db, None)\n                    await manager.fetch_feed(new_feed)\n                except Exception as e:\n                    log.error(f\"RSS源初始化抓取失败: {str(e)}\")\n                finally:\n                    async_db.close()\n            except Exception as e:\n                log.error(f\"后台任务执行失败: {str(e)}\")\n        \n        # 启动后台任务\n        asyncio.create_task(background_fetch())\n        \n        return new_feed\n    except sqlalchemy.exc.IntegrityError as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=\"该RSS源已存在\")\n\n@router.put(\"/feeds/{feed_id}\", response_model=RSSFeedResponse)\nasync def update_feed(\n    feed_id: int,\n    feed_update: RSSFeedUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"更新RSS源配置\"\"\"\n    feed = db.get(RSSFeed, feed_id)\n    if not feed or feed.user_id != current_user.id:\n        raise HTTPException(status_code=404, detail=\"RSS源不存在\")\n    \n    # 更新字段\n    for field, value in feed_update.model_dump(exclude_unset=True).items():\n        setattr(feed, field, value)\n    \n    db.commit()\n    db.refresh(feed)\n    return feed\n\n@router.delete(\"/feeds/{feed_id}\")\nasync def delete_feed(\n    feed_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"删除RSS源\"\"\"\n    feed = db.get(RSSFeed, feed_id)\n    if not feed or feed.user_id != current_user.id:\n        raise HTTPException(status_code=404, detail=\"RSS源不存在\")\n    \n    # 删除相关的条目\n    db.query(RSSEntry).filter_by(feed_id=feed_id).delete()\n    db.delete(feed)\n    db.commit()\n    \n    return {\"message\": \"RSS源已删除\"}\n\n@router.post(\"/feeds/{feed_id}/fetch\")\nasync def fetch_feed(\n    feed_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"手动获取RSS源更新\"\"\"\n    feed = db.get(RSSFeed, feed_id)\n    if not feed or feed.user_id != current_user.id:\n        raise HTTPException(status_code=404, detail=\"RSS源不存在\")\n    \n    manager = FeedManager(db, None)  # 不需要传递 TaskProcessor\n    try:\n        await manager.fetch_feed(feed)\n        return {\"message\": \"RSS源更新成功\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"RSS源更新失败: {str(e)}\")\n\n@router.get(\"/feeds/{feed_id}/entries\", response_model=List[RSSEntryResponse])\nasync def list_feed_entries(\n    feed_id: int,\n    skip: int = 0,\n    limit: int = 10,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"获取RSS源的条目列表\"\"\"\n    feed = db.get(RSSFeed, feed_id)\n    if not feed or feed.user_id != current_user.id:\n        raise HTTPException(status_code=404, detail=\"RSS源不存在\")\n    \n    entries = (\n        db.query(RSSEntry)\n        .filter_by(feed_id=feed_id)\n        .order_by(desc(RSSEntry.published))\n        .offset(skip)\n        .limit(limit)\n        .all()\n    )\n    return entries\n"}
{"type": "source_file", "path": "server/alembic/versions/fe52d265bea5_initial.py", "content": "\"\"\"initial\n\nRevision ID: fe52d265bea5\nRevises: f6e4b88ab88d\nCreate Date: 2025-01-01 16:20:26.994191\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = 'fe52d265bea5'\ndown_revision: Union[str, None] = 'f6e4b88ab88d'\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('system_config',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('key', sa.String(), nullable=False),\n    sa.Column('value', sa.String(), nullable=False),\n    sa.Column('type', sa.String(), nullable=False),\n    sa.Column('description', sa.Text(), nullable=True),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('key')\n    )\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('username', sa.String(), nullable=True),\n    sa.Column('email', sa.String(), nullable=True),\n    sa.Column('hashed_password', sa.String(), nullable=True),\n    sa.Column('nickname', sa.String(), nullable=True),\n    sa.Column('is_active', sa.Boolean(), nullable=True),\n    sa.Column('is_admin', sa.Boolean(), nullable=True),\n    sa.Column('created_at', sa.BigInteger(), nullable=False),\n    sa.Column('last_login', sa.BigInteger(), nullable=True),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)\n    op.create_index(op.f('ix_users_id'), 'users', ['id'], unique=False)\n    op.create_index(op.f('ix_users_username'), 'users', ['username'], unique=True)\n    op.create_table('rss_feeds',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('title', sa.String(), nullable=True),\n    sa.Column('url', sa.String(), nullable=True),\n    sa.Column('description', sa.String(), nullable=True),\n    sa.Column('last_fetch', sa.BigInteger(), nullable=True),\n    sa.Column('is_active', sa.Boolean(), nullable=True),\n    sa.Column('error_count', sa.Integer(), nullable=True),\n    sa.Column('fetch_interval', sa.Integer(), nullable=True),\n    sa.Column('initial_entries_count', sa.Integer(), nullable=True),\n    sa.Column('update_entries_count', sa.Integer(), nullable=True),\n    sa.Column('created_at', sa.BigInteger(), nullable=False),\n    sa.Column('updated_at', sa.BigInteger(), nullable=False),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('user_id', 'url', name='uix_user_url')\n    )\n    op.create_index(op.f('ix_rss_feeds_id'), 'rss_feeds', ['id'], unique=False)\n    op.create_index(op.f('ix_rss_feeds_title'), 'rss_feeds', ['title'], unique=False)\n    op.create_index(op.f('ix_rss_feeds_url'), 'rss_feeds', ['url'], unique=False)\n    op.create_table('tasks',\n    sa.Column('taskId', sa.String(), nullable=False),\n    sa.Column('url', sa.String(), nullable=False),\n    sa.Column('status', sa.String(), nullable=False),\n    sa.Column('progress', sa.String(), nullable=False),\n    sa.Column('title', sa.String(), nullable=True),\n    sa.Column('current_step', sa.String(), nullable=True),\n    sa.Column('current_step_index', sa.Integer(), nullable=True),\n    sa.Column('total_steps', sa.Integer(), nullable=True),\n    sa.Column('step_progress', sa.Integer(), nullable=True),\n    sa.Column('style_params', sa.JSON(), nullable=False),\n    sa.Column('files', sa.JSON(), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=False),\n    sa.Column('is_public', sa.Boolean(), nullable=False),\n    sa.Column('created_by', sa.Integer(), nullable=False),\n    sa.Column('updated_by', sa.Integer(), nullable=True),\n    sa.Column('created_at', sa.BigInteger(), nullable=False),\n    sa.Column('updated_at', sa.BigInteger(), nullable=False),\n    sa.Column('error', sa.String(), nullable=True),\n    sa.Column('progress_message', sa.String(), nullable=True),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n    sa.PrimaryKeyConstraint('taskId')\n    )\n    op.create_table('rss_entries',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('feed_id', sa.Integer(), nullable=False),\n    sa.Column('guid', sa.String(), nullable=False),\n    sa.Column('title', sa.String(), nullable=True),\n    sa.Column('link', sa.String(), nullable=True),\n    sa.Column('published', sa.BigInteger(), nullable=True),\n    sa.Column('processed', sa.Boolean(), nullable=True),\n    sa.Column('task_id', sa.String(), nullable=True),\n    sa.Column('user_id', sa.Integer(), nullable=False),\n    sa.Column('created_at', sa.BigInteger(), nullable=True),\n    sa.Column('updated_at', sa.BigInteger(), nullable=True),\n    sa.ForeignKeyConstraint(['feed_id'], ['rss_feeds.id'], ondelete='CASCADE'),\n    sa.ForeignKeyConstraint(['task_id'], ['tasks.taskId'], ondelete='CASCADE'),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('guid', 'user_id', name='uq_rss_entries_guid_user')\n    )\n    op.create_index(op.f('ix_rss_entries_id'), 'rss_entries', ['id'], unique=False)\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f('ix_rss_entries_id'), table_name='rss_entries')\n    op.drop_table('rss_entries')\n    op.drop_table('tasks')\n    op.drop_index(op.f('ix_rss_feeds_url'), table_name='rss_feeds')\n    op.drop_index(op.f('ix_rss_feeds_title'), table_name='rss_feeds')\n    op.drop_index(op.f('ix_rss_feeds_id'), table_name='rss_feeds')\n    op.drop_table('rss_feeds')\n    op.drop_index(op.f('ix_users_username'), table_name='users')\n    op.drop_index(op.f('ix_users_id'), table_name='users')\n    op.drop_index(op.f('ix_users_email'), table_name='users')\n    op.drop_table('users')\n    op.drop_table('system_config')\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "server/__init__.py", "content": ""}
{"type": "source_file", "path": "server/api/v1/configs.py", "content": "from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom typing import Dict, Any\nfrom pydantic import BaseModel\n\nfrom db.session import get_db\nfrom core.config import config_manager\nfrom models.user import User\nfrom auth.dependencies import get_admin_user\nfrom models.system_config import SystemConfig\nfrom schemas.config import ConfigUpdate, ConfigListResponse\n\nrouter = APIRouter()\n\n@router.get(\"\")\nasync def get_all_configs(\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_admin_user)\n) -> ConfigListResponse:\n    \"\"\"获取所有配置项\"\"\"\n    configs = config_manager.get_all_configs(db)\n    return ConfigListResponse(configs=configs)\n\n@router.put(\"/{key}\")\nasync def update_config(\n    key: str,\n    config_update: ConfigUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_admin_user)\n) -> Dict[str, str]:\n    \"\"\"更新配置项\"\"\"\n    if not hasattr(config_manager._settings, key) or key not in config_manager.MUTABLE_CONFIGS:\n        raise HTTPException(\n            status_code=400, \n            detail=f\"无效的配置键或该配置不允许修改: {key}\"\n        )\n    \n    try:\n        config_manager.update_config(\n            db=db,\n            key=key,\n            value=config_update.value,\n            type_name=config_update.type,\n            description=config_update.description\n        )\n        return {\"message\": f\"配置 {key} 更新成功\"}\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"更新配置失败: {str(e)}\")\n\n@router.delete(\"/{key}\")\nasync def reset_config(\n    key: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_admin_user)\n):\n    \"\"\"重置配置项为默认值\"\"\"\n    config = db.query(SystemConfig).filter(SystemConfig.key == key).first()\n    if config:\n        db.delete(config)\n        db.commit()\n        config_manager.reload_db_config(db)\n        return {\"message\": f\"配置 {key} 已重置为默认值\"}\n    raise HTTPException(status_code=404, detail=f\"配置 {key} 不存在于数据库中\")\n"}
{"type": "source_file", "path": "server/api/__init__.py", "content": ""}
{"type": "source_file", "path": "server/alembic/versions/f6e4b88ab88d_initial.py", "content": "\"\"\"initial\n\nRevision ID: f6e4b88ab88d\nRevises: \nCreate Date: 2025-01-01 16:14:17.923333\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = 'f6e4b88ab88d'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    pass\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    pass\n    # ### end Alembic commands ###\n"}
{"type": "source_file", "path": "server/api/v1/__init__.py", "content": ""}
{"type": "source_file", "path": "server/api/v1/auth.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session\nfrom datetime import timedelta\nfrom auth.utils import verify_password, get_password_hash, create_access_token\nfrom db.session import get_db\nfrom core.config import settings\nfrom schemas.user import UserCreate, UserResponse\nfrom models.user import User\nfrom auth.dependencies import get_current_active_user\nfrom utils.time_utils import TimeUtil\n\nrouter = APIRouter()\n\n@router.post(\"/login\")\nasync def login(\n    form_data: OAuth2PasswordRequestForm = Depends(),\n    db: Session = Depends(get_db)\n):\n    # 特殊处理test用户\n    if (settings.TEST_USER_ENABLED and \n        form_data.username == settings.TEST_USERNAME and \n        form_data.password == settings.TEST_PASSWORD):\n        \n        # 获取或创建test用户\n        user = db.query(User).filter(User.username == settings.TEST_USERNAME).first()\n        if not user:\n            # 创建test用户\n            user = User(\n                username=settings.TEST_USERNAME,\n                hashed_password=get_password_hash(settings.TEST_PASSWORD),\n                nickname=\"Test User\",\n                is_active=True\n            )\n            db.add(user)\n            db.commit()\n            db.refresh(user)\n    else:\n        user = db.query(User).filter(User.username == form_data.username).first()\n        if not user or not verify_password(form_data.password, user.hashed_password):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"用户名或密码错误\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        \n        if not user.is_active:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"用户已被禁用\"\n            )\n        \n        # 更新最近登录时间\n        user.last_login = TimeUtil.now_ms()\n        db.commit()\n    \n    access_token_expires = timedelta(\n        minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES\n    )\n    access_token = create_access_token(\n        data={\"sub\": user.username},\n        expires_delta=access_token_expires\n    )\n    \n    return {\n        \"access_token\": access_token,\n        \"token_type\": \"bearer\"\n    }\n\n@router.post(\"/register\", status_code=201)\nasync def register(user_data: UserCreate, db: Session = Depends(get_db)):\n    if not settings.ALLOW_REGISTRATION:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"注册功能已关闭\"\n        )\n    \n    # 检查用户名是否已存在\n    existing_user = db.query(User).filter(\n        User.username == user_data.username\n    ).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"用户名已存在\"\n        )\n    \n    user = User(\n        username=user_data.username,\n        hashed_password=get_password_hash(user_data.password),\n        nickname=user_data.nickname or user_data.username\n    )\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n    \n    return {\"username\": user.username, \"nickname\": user.nickname}\n\n@router.get(\"/me\", response_model=UserResponse)\nasync def get_current_user_info(\n    current_user: User = Depends(get_current_active_user)\n):\n    \"\"\"获取当前登录用户信息\"\"\"\n    return current_user\n"}
{"type": "source_file", "path": "server/alembic/env.py", "content": "from logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nfrom alembic import context\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\nfrom db.base import Base\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection,\n            target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"}
{"type": "source_file", "path": "server/api/v1/api.py", "content": "from fastapi import APIRouter\nfrom api.v1 import auth, tasks, users, configs, rss\n\napi_router = APIRouter()\n\n# 认证相关路由\napi_router.include_router(auth.router, prefix=\"/auth\", tags=[\"auth\"])\n\n# 任务相关路由\napi_router.include_router(tasks.router, prefix=\"/tasks\", tags=[\"tasks\"])\n\n# 用户相关路由\napi_router.include_router(users.router, prefix=\"/users\", tags=[\"users\"])\n\n# 配置相关路由\napi_router.include_router(configs.router, prefix=\"/configs\", tags=[\"configs\"])\n\n# RSS相关路由\napi_router.include_router(rss.router, prefix=\"/rss\", tags=[\"rss\"]) "}
{"type": "source_file", "path": "server/api/v1/tasks.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.responses import FileResponse\nfrom sqlalchemy.orm import Session\nfrom crud.task import task as task_crud\nfrom schemas.task import TaskCreate, TaskResponse, TaskListResponse, TaskQueryParams, TaskUpdate\nfrom models.user import User\nfrom auth.dependencies import get_current_active_user, get_current_user\nfrom db.session import get_db\nfrom core.logging import log\nimport os\nimport threading\n\nfrom models.enums import TaskProgress, TaskStatus\nfrom services.task.task_service import execute_task\nfrom services.file import FileService\nfrom services.task import TaskService\n\nrouter = APIRouter()\n\n@router.post(\"\", response_model=TaskResponse, status_code=status.HTTP_201_CREATED)\nasync def create_task(\n    task_in: TaskCreate,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n):\n    try:\n        # 创建任务\n        task = task_crud.create(db=db, obj_in=task_in, user=current_user)\n        db.commit()  # 提交事务以保存任务\n        \n        # 启动后台任务处理\n        threading.Thread(\n            target=execute_task,\n            args=(task.taskId, False),\n            daemon=True\n        ).start()\n        \n        return task\n    except Exception as e:\n        db.rollback()\n        log.error(f\"Failed to create task: error={str(e)}\")\n        log.error(\"Traceback:\", exc_info=True)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"启动任务处理失败: {str(e)}\"\n        )\n\n@router.get(\"/{task_id}\", response_model=TaskResponse)\nasync def get_task(\n    task_id: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_active_user)\n):\n    \"\"\"获取任务详情\"\"\"\n    task = task_crud.get(db, task_id=task_id)\n    if not task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    \n    # 检查任务权限\n    if task.user_id != current_user.id and not task.is_public and not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"No permission to access this task\")\n    \n    return task\n\n@router.get(\"\", response_model=TaskListResponse)\nasync def list_tasks(\n    params: TaskQueryParams = Depends(),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_active_user)\n):\n    \"\"\"获取任务列表，支持分页和过滤\"\"\"\n    \n    tasks, total = task_crud.get_tasks(\n        db,\n        current_user_id=current_user.id,\n        is_admin=current_user.is_admin,\n        params=params\n    )\n    \n    return {\n        \"total\": total,\n        \"items\": tasks\n    }\n\n@router.delete(\"/{task_id}\")\nasync def delete_task(\n    task_id: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_active_user)\n):\n    \"\"\"删除任务\"\"\"\n    task = task_crud.get(db, task_id=task_id)\n    if not task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    \n    # 检查删除权限\n    if task.user_id != current_user.id and not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"No permission to delete this task\")\n    \n    # 删除任务文件\n    FileService.delete_task_directory(task_id)\n    \n    # 删除数据库记录\n    task_crud.delete(db, task_id=task_id)\n    \n    return {\"message\": \"Task deleted successfully\"}\n\n@router.get(\"/files/{task_id}/{level}/{lang}/{file_type}\")\nasync def get_task_file(\n    task_id: str,\n    level: str,\n    lang: str,\n    file_type: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_active_user)\n):\n    \"\"\"获取任务相关文件（音频、字幕等）\n    \n    Args:\n        task_id: 任务ID\n        level: 难度等级(elementary/intermediate/advanced)\n        lang: 语言(cn/en)\n        file_type: 文件类型(audio/subtitle)\n    \"\"\"\n    task = task_crud.get(db, task_id=task_id)\n    if not task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    \n    # 检查访问权限\n    if task.user_id != current_user.id and not task.is_public and not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"No permission to access this file\")\n    \n    # 生成标准化的文件名\n    filename = FileService.get_task_file_name(\n        level=level,\n        lang=lang,\n        file_type=file_type,\n        task_id=task_id\n    )\n    \n    # 获取文件完整路径\n    file_path = FileService.get_task_file_path(task_id, filename)\n    if not os.path.exists(file_path):\n        raise HTTPException(status_code=404, detail=f\"File not found: {filename}\")\n    \n    # 根据文件类型设置 media_type\n    media_types = {\n        \"audio\": \"audio/mpeg\",\n        \"subtitle\": \"application/x-subrip\",\n    }\n    media_type = media_types.get(file_type, \"text/plain\")\n    \n    return FileResponse(file_path, media_type=media_type)\n\n@router.post(\"/{task_id}/retry\")\nasync def retry_task(\n    task_id: str,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_active_user)\n):\n    \"\"\"重试失败的任务\"\"\"\n    task = task_crud.get(db, task_id=task_id)\n    if not task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    \n    # 检查任务权限\n    if task.user_id != current_user.id and not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"No permission to retry this task\")\n    \n    # 检查任务是否处于失败状态\n    if task.status != TaskStatus.FAILED.value:\n        raise HTTPException(status_code=400, detail=\"Only failed tasks can be retried\")\n    \n    # 重置任务状态为处理中\n    task.status = TaskStatus.PROCESSING.value\n    task.progress = TaskProgress.WAITING.value\n    db.commit()\n    \n    # 启动重试处理\n    TaskService.retry_task(task)\n    \n    return {\"message\": \"Task retry started\"}\n\n@router.patch(\"/{task_id}\", response_model=TaskResponse)\nasync def update_task(\n    task_id: str,\n    task_update: TaskUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_active_user)\n):\n    \"\"\"更新任务信息\"\"\"\n    task = task_crud.get(db, task_id=task_id)\n    if not task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    \n    # 检查更新权限\n    if task.user_id != current_user.id and not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"No permission to update this task\")\n    \n    # 只更新允许的字段\n    update_data = TaskUpdate(\n        title=task_update.title if task_update.title is not None else task.title,\n        is_public=task_update.is_public if task_update.is_public is not None else task.is_public,\n        style_params=task_update.style_params if task_update.style_params is not None else task.style_params\n    )\n    \n    updated_task = task_crud.update(db, db_obj=task, obj_in=update_data)\n    return updated_task"}
{"type": "source_file", "path": "server/core/prompts/__init__.py", "content": "# 这个文件可以为空，它的存在使得目录成为一个Python包\n"}
{"type": "source_file", "path": "server/core/logging.py", "content": "from loguru import logger\nimport sys\nfrom pathlib import Path\nfrom core.config import settings\n\n# 创建日志目录\nlog_path = Path(settings.BASE_DIR) / \"logs\"\nlog_path.mkdir(exist_ok=True)\n\n# 移除默认的处理器\nlogger.remove()\n\n# 添加控制台处理器\nlogger.add(\n    sys.stdout,\n    format=\"<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> | <level>{message}</level>\",\n    level=\"INFO\",\n    colorize=True\n)\n\n# 添加文件处理器\nlogger.add(\n    log_path / \"app.log\",\n    rotation=\"500 MB\",\n    retention=\"10 days\",\n    compression=\"zip\",\n    format=\"{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} | {message}\",\n    level=\"INFO\",\n    encoding=\"utf-8\"\n)\n\n# 导出 logger 实例\nlog = logger"}
{"type": "source_file", "path": "server/models/user.py", "content": "from sqlalchemy import Column, String, BigInteger, Integer, Boolean\nfrom sqlalchemy.orm import relationship\nfrom db.base import Base\nfrom utils.time_utils import TimeUtil\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n    nickname = Column(String)\n    is_active = Column(Boolean, default=True)\n    is_admin = Column(Boolean, default=False)\n    created_at = Column(BigInteger, nullable=False, default=TimeUtil.now_ms)\n    last_login = Column(BigInteger, nullable=True)\n    \n    tasks = relationship(\n        \"Task\",\n        back_populates=\"user\",\n        foreign_keys=\"[Task.user_id]\"\n    )\n    \n    rss_feeds = relationship(\"RSSFeed\", back_populates=\"user\")"}
{"type": "source_file", "path": "server/crud/task.py", "content": "from typing import List, Optional\nfrom sqlalchemy.orm import Session\nfrom models.task import Task\nfrom schemas.task import TaskCreate, TaskUpdate, TaskQueryParams\nfrom models.enums import TaskStatus, TaskProgress\nfrom utils.time_utils import TimeUtil\nimport uuid\nfrom sqlalchemy import or_\nfrom core.logging import log\nfrom models.user import User\n\nclass TaskCRUD():\n    def create(self, db: Session, *, obj_in: TaskCreate, user: User) -> Task:\n        \"\"\"创建任务\"\"\"\n        db_obj = Task(\n            taskId=str(uuid.uuid4()),\n            url=obj_in.url,\n            status=TaskStatus.PENDING.value,\n            progress=TaskProgress.WAITING.value,  # 添加初始进度状态\n            is_public=obj_in.is_public,\n            created_by=user.id,\n            user_id=user.id,\n            created_at=TimeUtil.now_ms(),\n            updated_at=TimeUtil.now_ms()\n        )\n        db.add(db_obj)\n        db.commit()\n        db.refresh(db_obj)\n        return db_obj\n\n    def get(self, db: Session, task_id: str) -> Optional[Task]:\n        return db.query(Task).filter(Task.taskId == task_id).first()\n    \n    def get_completed_tasks(self, db: Session) -> List[Task]:\n        return (\n            db.query(Task)\n            .filter(Task.status == 'completed')\n            .order_by(Task.updated_at.desc())\n            .all()\n        )\n\n    def update(\n        self, \n        db: Session,\n        *,\n        db_obj: Task,\n        obj_in: TaskUpdate\n    ) -> Task:\n        for field, value in obj_in.model_dump(exclude_unset=True).items():\n            setattr(db_obj, field, value)\n        db_obj.updated_at = TimeUtil.now_ms()\n        db.commit()\n        db.refresh(db_obj)\n        return db_obj\n\n    def delete(self, db: Session, *, task_id: str) -> Task:\n        obj = db.query(Task).filter(Task.taskId == task_id).first()\n        db.delete(obj)\n        db.commit()\n        return obj\n\n    def get_tasks(\n        self,\n        db: Session,\n        *,\n        current_user_id: int,\n        is_admin: bool,\n        params: TaskQueryParams\n    ) -> tuple[List[Task], int]:\n        \"\"\"获取任务列表\"\"\"\n        query = db.query(Task)\n        \n        # 权限过滤 - 非管理员只能看到自己的任务\n        if not is_admin:\n            query = query.filter(Task.user_id == current_user_id)\n        \n        # 状态过滤\n        if params.status:\n            query = query.filter(Task.status == params.status)\n        \n        # 日期过滤\n        if params.start_date:\n            query = query.filter(Task.created_at >= params.start_date)\n        if params.end_date:\n            query = query.filter(Task.created_at <= params.end_date)\n            \n        # 用户过滤\n        if params.user_id:\n            query = query.filter(Task.user_id == params.user_id)\n        \n        # 标题关键词搜索\n        if params.title_keyword:\n            query = query.filter(Task.title.ilike(f\"%{params.title_keyword}%\"))\n        \n        # URL关键词搜索\n        if params.url_keyword:\n            query = query.filter(Task.url.ilike(f\"%{params.url_keyword}%\"))\n        \n        # 排序\n        query = query.order_by(Task.created_at.desc())\n        \n        # 计算总数\n        total = query.count()\n        \n        # 分页\n        if params.offset:\n            query = query.offset(params.offset)\n        if params.limit:\n            query = query.limit(params.limit)\n        \n        return query.all(), total\n\ntask = TaskCRUD()"}
{"type": "source_file", "path": "server/core/exceptions.py", "content": "from fastapi import HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom core.logging import log\nfrom pydantic import ValidationError\n\nasync def validation_exception_handler(request: Request, exc: Exception):\n    # 获取错误详情\n    errors = exc.errors()\n    error_msg = errors[0].get('msg', '') if errors else ''\n    \n    # 记录详细的错误信息\n    log.error(f\"验证失败: {exc}\")\n    \n    # 直接返回原始错误消息\n    return JSONResponse(\n        status_code=422,\n        content={\"message\": error_msg}\n    )\n    \n\nasync def general_exception_handler(request: Request, exc: Exception):\n    log.error(f\"未处理的异常: {str(exc)}\")\n    return JSONResponse(\n        status_code=500,\n        content={\"message\": \"服务器内部错误\"},\n    )"}
{"type": "source_file", "path": "server/db/base.py", "content": "from sqlalchemy.orm import declarative_base\n\nBase = declarative_base()\n\n# 导入所有模型，这样 alembic 才能发现它们\nfrom models.user import User\nfrom models.task import Task\nfrom models.rss import RSSFeed, RSSEntry\n\n# 确保所有模型都在这里导入，这样 alembic 才能检测到它们\n__all__ = [\"Base\", \"User\", \"Task\", \"RSSFeed\", \"RSSEntry\"]"}
{"type": "source_file", "path": "server/models/enums.py", "content": "from enum import Enum\n\nclass TaskStatus(str, Enum):\n    PENDING = \"pending\"\n    PROCESSING = \"processing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\nclass TaskProgress(str, Enum):\n    WAITING = \"waiting\"\n    PROCESSING = \"processing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n"}
{"type": "source_file", "path": "server/schemas/config.py", "content": "from pydantic import BaseModel, ConfigDict\nfrom typing import Any, Dict, Optional\n\nclass ConfigBase(BaseModel):\n    value: Any\n    type: str\n    description: Optional[str] = None\n\nclass ConfigUpdate(ConfigBase):\n    pass\n\nclass ConfigResponse(ConfigBase):\n    key: str\n    model_config = ConfigDict(from_attributes=True)\n\nclass ConfigListResponse(BaseModel):\n    configs: Dict[str, ConfigResponse]"}
{"type": "source_file", "path": "server/models/system_config.py", "content": "from sqlalchemy import Column, String, Integer, Text\nfrom db.base import Base\n\nclass SystemConfig(Base):\n    __tablename__ = 'system_config'\n    id = Column(Integer, primary_key=True)\n    key = Column(String, unique=True, nullable=False)\n    value = Column(String, nullable=False)\n    type = Column(String, nullable=False)\n    description = Column(Text, nullable=True)\n"}
{"type": "source_file", "path": "server/core/config.py", "content": "import os\nimport platform\nimport zoneinfo\nfrom typing import Dict, Any\n\nfrom pydantic import ConfigDict\nfrom pydantic_settings import BaseSettings\nfrom sqlalchemy.orm import Session\n\nfrom models.system_config import SystemConfig\nfrom schemas.config import ConfigResponse\n\n\nclass Settings(BaseSettings):\n    # 基础路径配置\n    BASE_DIR: str = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n    TASK_DIR: str = os.path.join(BASE_DIR, 'data', 'tasks')\n    DB_PATH: str = os.path.join(BASE_DIR, 'data', 'tasks.db')\n    \n    # 服务器配置\n    PORT: int\n    HOST: str\n    JWT_SECRET_KEY: str\n    JWT_ALGORITHM: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int\n    \n    # 管理员账号配置\n    ADMIN_USERNAME: str\n    ADMIN_PASSWORD: str\n    \n    # 系统功能开关\n    ALLOW_REGISTRATION: bool\n    \n    # API配置\n    API_BASE_URL: str\n    API_KEY: str\n    MODEL: str\n    \n    # TTS配置\n    USE_OPENAI_TTS_MODEL: bool\n    TTS_BASE_URL: str\n    TTS_API_KEY: str\n    TTS_MODEL: str\n    \n    # 代理配置\n    HTTPS_PROXY: str | None = None\n    \n    # 主播声音映射配置\n    ANCHOR_TYPE_MAP: Dict[str, str]\n    \n    # URL校验配置\n    ALLOWED_URL_PATTERN: str\n    \n    # 测试用户配置\n    TEST_USER_ENABLED: bool\n    TEST_USERNAME: str\n    TEST_PASSWORD: str\n    \n    # RSS配置\n    RSS_DEFAULT_FETCH_INTERVAL_SECONDS: int  # RSS源的默认抓取间隔（秒）\n    RSS_MAX_ENTRIES_PER_FEED: int           # 每个RSS源最多处理的条目数\n    RSS_MAX_RETRY_COUNT: int                # RSS源抓取失败最大重试次数\n    RSS_ERROR_RETRY_INTERVAL: int           # RSS源出错后重试间隔（秒）\n    RSS_CONCURRENT_TASKS: int               # RSS任务并发处理数量\n    RSS_MIN_FETCH_INTERVAL: int             # 最小抓取间隔（秒）\n    RSS_MAX_FETCH_INTERVAL: int             # 最大抓取间隔（秒）\n    RSS_MAX_INITIAL_ENTRIES: int            # 初次获取的最大条目数\n    RSS_MAX_UPDATE_ENTRIES: int             # 后续更新的最大条目数\n    \n    # 时区设置，默认使用系统时区\n    TIMEZONE: str = os.environ.get('TZ') or (\n        'Asia/Shanghai' if platform.system() == 'Windows'\n        else next(iter(zoneinfo.available_timezones()), 'Asia/Shanghai')\n    )\n    \n    # 任务处理相关配置\n    MAX_TASK_WORKERS: int # 任务处理线程池最大并发数\n    \n    model_config = ConfigDict(\n        env_file=\".env\",\n        case_sensitive=True\n    )\n\nclass ConfigManager:\n    _instance = None\n    _settings = None\n    _db_config = {}\n    _db_configs = []\n    \n    # 允许通过接口读取和修改的配置项\n    MUTABLE_CONFIGS = {\n        'API_BASE_URL',\n        'API_KEY',\n        'MODEL',\n        'USE_OPENAI_TTS_MODEL',\n        'TTS_BASE_URL',\n        'TTS_API_KEY',\n        'TTS_MODEL',\n        'ANCHOR_TYPE_MAP',\n        'HTTPS_PROXY',\n        'ALLOW_REGISTRATION',\n        'ALLOWED_URL_PATTERN',\n        'TEST_USER_ENABLED',\n        'TEST_USERNAME',\n        'TEST_PASSWORD'\n    }\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super(ConfigManager, cls).__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if self._settings is None:\n            self._settings = Settings()\n\n    def get_all_configs(self, db: Session = None) -> Dict[str, ConfigResponse]:\n        \"\"\"获取所有可修改的配置项\"\"\"\n        configs = {}\n        for key in self.MUTABLE_CONFIGS:\n            if hasattr(self._settings, key):\n                # 获取默认值\n                value = getattr(self._settings, key)\n                type_name = self._infer_type(value)\n                description = None\n                \n                # 如果提供了数据库会话，则从数据库获取最新配置\n                if db:\n                    db_config = db.query(SystemConfig).filter(\n                        SystemConfig.key == key\n                    ).first()\n                    if db_config:\n                        value = self._convert_value(db_config.value, db_config.type)\n                        type_name = db_config.type\n                        description = db_config.description\n                \n                configs[key] = ConfigResponse(\n                    key=key,\n                    value=value,\n                    type=type_name,\n                    description=description\n                )\n        return configs\n\n    def _infer_type(self, value: Any) -> str:\n        \"\"\"推断值的类型\"\"\"\n        if isinstance(value, bool):\n            return \"bool\"\n        elif isinstance(value, int):\n            return \"int\"\n        elif isinstance(value, float):\n            return \"float\"\n        elif isinstance(value, dict):\n            return \"dict\"\n        return \"str\"\n\n    def get_db_configs(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"获取数据库中的配置项\"\"\"\n        return {\n            key: {\n                'value': value,\n                'type': next(\n                    (config.type for config in self._db_configs \n                     if config.key == key), \n                    None\n                ),\n                'description': next(\n                    (config.description for config in self._db_configs \n                     if config.key == key),\n                    None\n                )\n            }\n            for key, value in self._db_config.items()\n        }\n\n    def reload_db_config(self, db: Session):\n        \"\"\"从数据库重新加载配置\"\"\"\n        configs = db.query(SystemConfig).all()\n        self._db_config = {}\n        for config in configs:\n            value = self._convert_value(config.value, config.type)\n            self._db_config[config.key] = value\n\n    def _convert_value(self, value: str, type_name: str) -> Any:\n        \"\"\"根据类型转换配置值\"\"\"\n        if type_name == \"bool\":\n            return value.lower() in (\"true\", \"1\", \"yes\")\n        elif type_name == \"int\":\n            return int(value)\n        elif type_name == \"float\":\n            return float(value)\n        elif type_name == \"dict\":\n            return eval(value)  # 注意：这里需要安全处理\n        return value\n\n    def __getattr__(self, name: str):\n        # 优先级：数据库配置 > 环境变量/Settings配置\n        if name in self._db_config:\n            return self._db_config[name]\n        return getattr(self._settings, name)\n\n    def update_config(self, db: Session, key: str, value: Any, type_name: str, description: str = None):\n        \"\"\"更新配置到数据库\"\"\"\n        if key not in self.MUTABLE_CONFIGS:\n            raise ValueError(f\"配置项 {key} 不允许修改\")\n            \n        config = db.query(SystemConfig).filter(SystemConfig.key == key).first()\n        if config:\n            config.value = str(value)\n            config.type = type_name\n            config.description = description\n        else:\n            config = SystemConfig(\n                key=key,\n                value=str(value),\n                type=type_name,\n                description=description\n            )\n            db.add(config)\n        \n        db.commit()\n        self.reload_db_config(db)\n\n# 创建全局实例\nconfig_manager = ConfigManager()\n# 创建别名以兼容现有代码\nsettings = config_manager\n\n# 为了向后兼容，保留 get_settings 函数\ndef get_settings():\n    return settings\n"}
{"type": "source_file", "path": "server/core/scheduler.py", "content": "from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.triggers.cron import CronTrigger\nfrom core.config import settings\nfrom core.logging import log\nfrom db.session import get_db\nfrom services.rss.feed_manager import FeedManager\nfrom services.task.processor import TaskProcessor\n\nasync def fetch_all_feeds():\n    \"\"\"定时任务：抓取所有需要更新的RSS源\"\"\"\n    try:\n        # 获取数据库会话\n        db = next(get_db())\n        try:\n            # 创建FeedManager\n            manager = FeedManager(db, None)  # 不需要传递 TaskProcessor\n            await manager.process_all_feeds()\n        finally:\n            db.close()\n    except Exception as e:\n        log.error(f\"RSS定时任务执行出错: {e}\")\n\ndef setup_scheduler():\n    \"\"\"设置定时任务\"\"\"\n    scheduler = AsyncIOScheduler()\n    \n    # 添加RSS抓取任务\n    scheduler.add_job(\n        fetch_all_feeds,\n        CronTrigger(minute=\"*/15\"),  # 每15分钟执行一次\n        id=\"fetch_rss_feeds\",\n        name=\"RSS Feed Fetcher\",\n        misfire_grace_time=300  # 允许延迟5分钟\n    )\n    \n    return scheduler\n"}
{"type": "source_file", "path": "server/models/task.py", "content": "from sqlalchemy import Column, String, BigInteger, Integer, Boolean, ForeignKey, JSON\nfrom sqlalchemy.orm import relationship, validates\nfrom urllib.parse import urlparse\nfrom db.base import Base\nfrom models.enums import TaskProgress, TaskStatus\nfrom utils.time_utils import TimeUtil\n\n\nclass Task(Base):\n    \"\"\"任务模型\n    \n    用于存储和管理任务的执行状态、进度和相关资源。支持多个英语等级的音频和字幕文件。\n    \"\"\"\n    __tablename__ = \"tasks\"\n\n    taskId = Column(String, primary_key=True)  # 任务唯一标识\n    url = Column(String, nullable=False)  # 待处理的URL\n    status = Column(String, nullable=False)  # 任务整体状态：pending/processing/completed/failed\n    progress = Column(String, nullable=False)  # 当前步骤的执行状态：waiting/processing/completed/failed\n    title = Column(String, nullable=True)  # 文章标题\n    current_step = Column(String, nullable=True)  # 当前执行的步骤名称\n    current_step_index = Column(Integer, nullable=True)  # 当前步骤序号\n    total_steps = Column(Integer, nullable=True)  # 总步骤数\n    step_progress = Column(Integer, nullable=True)  # 当前步骤的进度(0-100)\n    \n    # 风格参数\n    style_params = Column(JSON, nullable=False, default={\n        \"content_length\": \"medium\",\n        \"tone\": \"casual\",\n        \"emotion\": \"neutral\"\n    })\n    \n    # 文件URL，按难度等级和语言组织\n    # 格式: {\n    #   \"elementary\": {\n    #     \"en\": {\"audio\": \"url\", \"subtitle\": \"url\"},\n    #     \"cn\": {\"audio\": \"url\", \"subtitle\": \"url\"}\n    #   },\n    #   \"intermediate\": {...},\n    #   \"advanced\": {...}\n    # }\n    files = Column(JSON, nullable=False, default=dict)\n    \n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)  # 所属用户ID\n    is_public = Column(Boolean, nullable=False, default=False)  # 是否公开\n    created_by = Column(Integer, nullable=False)  # 创建者ID\n    updated_by = Column(Integer, nullable=True)  # 更新者ID\n    created_at = Column(BigInteger, nullable=False, default=TimeUtil.now_ms)  # 创建时间(毫秒时间戳)\n    updated_at = Column(BigInteger, nullable=False, default=TimeUtil.now_ms, onupdate=TimeUtil.now_ms)  # 更新时间(毫秒时间戳)\n    error = Column(String, nullable=True)  # 错误信息\n    progress_message = Column(String, nullable=True)  # 进度消息\n    \n    # 关联关系\n    user = relationship(\n        \"User\",\n        back_populates=\"tasks\",\n        foreign_keys=[user_id]\n    )\n    creator = relationship(\n        \"User\",\n        primaryjoin=\"Task.created_by == User.id\",\n        foreign_keys=[created_by],\n        uselist=False\n    )\n    updater = relationship(\n        \"User\",\n        primaryjoin=\"Task.updated_by == User.id\",\n        foreign_keys=[updated_by],\n        uselist=False\n    )\n    rss_entries = relationship(\"RSSEntry\", back_populates=\"task\")\n\n    @validates('url')\n    def validate_url(self, key, url):\n        \"\"\"验证URL格式\"\"\"\n        if not url:\n            raise ValueError(\"URL cannot be empty\")\n        parsed = urlparse(url)\n        if not parsed.scheme or not parsed.netloc:\n            raise ValueError(\"Invalid URL format\")\n        return url\n\n    @validates('step_progress')\n    def validate_step_progress(self, key, progress):\n        \"\"\"验证步骤进度值是否在有效范围内(0-100)\"\"\"\n        if progress is not None and not (0 <= progress <= 100):\n            raise ValueError(\"Step progress must be between 0 and 100, current progress: {}\".format(progress))\n        return progress\n\n    @validates('status')\n    def validate_status(self, key, status):\n        \"\"\"验证任务状态值是否有效\"\"\"\n        if isinstance(status, str):\n            status = TaskStatus(status)\n        return status\n\n    @validates('progress')\n    def validate_progress(self, key, progress):\n        \"\"\"验证进度状态值是否有效\"\"\"\n        if isinstance(progress, str):\n            progress = TaskProgress(progress)\n        return progress\n\n    def to_response(self) -> dict:\n        \"\"\"转换为API响应格式\"\"\"\n        return {\n            \"taskId\": self.taskId,\n            \"url\": self.url,\n            \"status\": self.status,\n            \"progress\": self.progress,\n            \"title\": self.title,\n            \"created_at\": self.created_at,\n            \"updated_at\": self.updated_at,\n            \"is_public\": self.is_public,\n            \"style_params\": self.style_params,\n            \"files\": self.files,\n            \"current_step\": self.current_step,\n            \"current_step_index\": self.current_step_index,\n            \"total_steps\": self.total_steps,\n            \"step_progress\": self.step_progress,\n            \"error\": self.error,\n            \"progress_message\": self.progress_message\n        }\n\n    def __repr__(self):\n        return f\"<Task(taskId={self.taskId}, status={self.status})>\""}
{"type": "source_file", "path": "server/db/session.py", "content": "import logging\nimport os\nimport configparser\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom alembic.config import Config\nfrom alembic import command\n\nfrom auth.utils import get_password_hash\nfrom core.config import settings\nfrom models.user import User\n\nSQLALCHEMY_DATABASE_URL = f\"sqlite:///{settings.DB_PATH}\"\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, \n    connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\ndef init_db():\n    from db.base import Base\n    \n    # 创建数据库目录\n    db_dir = os.path.dirname(settings.DB_PATH)\n    os.makedirs(db_dir, exist_ok=True)\n    \n    # 运行数据库迁移\n    try:\n        # 获取alembic.ini的路径（相对于当前文件的上级目录）\n        alembic_cfg = Config()\n        alembic_cfg.file_config = configparser.ConfigParser()\n        alembic_cfg.file_config.read(\n            os.path.join(os.path.dirname(__file__), \"..\", \"alembic.ini\"),\n            encoding='utf-8'\n        )\n        alembic_cfg.set_main_option('script_location', os.path.join(os.path.dirname(__file__), \"..\", \"alembic\"))\n        alembic_cfg.set_main_option('sqlalchemy.url', SQLALCHEMY_DATABASE_URL)\n        command.upgrade(alembic_cfg, \"head\")\n        logging.info(\"数据库迁移完成\")\n    except Exception as e:\n        logging.error(f\"数据库迁移失败: {str(e)}\")\n        # 如果迁移失败，回退到创建初始表结构\n        Base.metadata.create_all(bind=engine)\n        logging.info(\"已创建初始表结构\")\n    \n    # 创建初始管理员用户\n    db = SessionLocal()\n    try:\n        # 检查是否已存在管理员用户\n        admin = db.query(User).filter(User.is_admin == True).first()\n        if not admin:\n            admin_user = User(\n                username=settings.ADMIN_USERNAME,\n                hashed_password=get_password_hash(settings.ADMIN_PASSWORD),\n                nickname=\"管理员\",\n                is_admin=True,\n                is_active=True\n            )\n            db.add(admin_user)\n            db.commit()\n            logging.info(\"已创建初始管理员用户\")\n    except Exception as e:\n        logging.error(f\"创建管理员用户时出错: {str(e)}\")\n        raise\n    finally:\n        db.close()"}
{"type": "source_file", "path": "server/auth/dependencies.py", "content": "from fastapi import Depends, HTTPException, status, Request\nfrom fastapi.security import OAuth2PasswordBearer\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom jose import JWTError, jwt\nfrom sqlalchemy.orm import Session\nfrom core.config import settings\nfrom db.session import get_db\nfrom models.user import User\n\nclass OAuth2PasswordBearerWithQuery(OAuth2PasswordBearer):\n    async def __call__(self, request: Request) -> str | None:\n        # 首先尝试从请求头获取token\n        authorization = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        \n        if not authorization or scheme.lower() != \"bearer\":\n            # 如果请求头中没有有效的token，尝试从查询参数获取\n            token = request.query_params.get(\"token\")\n            if not token:\n                if self.auto_error:\n                    raise HTTPException(\n                        status_code=status.HTTP_401_UNAUTHORIZED,\n                        detail=\"未提供有效的认证信息\",\n                        headers={\"WWW-Authenticate\": \"Bearer\"},\n                    )\n                else:\n                    return None\n            return token\n        return param\n\noauth2_scheme = OAuth2PasswordBearerWithQuery(tokenUrl=\"token\")\n\nasync def get_current_user(\n    token: str = Depends(oauth2_scheme),\n    db: Session = Depends(get_db)\n) -> User:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"无效的认证凭据\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(\n            token, \n            settings.JWT_SECRET_KEY, \n            algorithms=[settings.JWT_ALGORITHM]\n        )\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n        \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    return user\n\nasync def get_current_active_user(\n    current_user: User = Depends(get_current_user)\n) -> User:\n    if not current_user.is_active:\n        raise HTTPException(status_code=400, detail=\"用户已被禁用\")\n    return current_user\n\nasync def get_admin_user(\n    current_user: User = Depends(get_current_active_user)\n) -> User:\n    if not current_user.is_admin:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"需要管理员权限\"\n        )\n    return current_user\n"}
{"type": "source_file", "path": "server/models/rss.py", "content": "from sqlalchemy import Column, Integer, String, ForeignKey, Boolean, BigInteger, UniqueConstraint\nfrom sqlalchemy.orm import relationship\n\nfrom db.base import Base\nfrom utils.time_utils import TimeUtil\n\nclass RSSFeed(Base):\n    __tablename__ = \"rss_feeds\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    title = Column(String, index=True)\n    url = Column(String, index=True)\n    description = Column(String)\n    last_fetch = Column(BigInteger)\n    is_active = Column(Boolean, default=True)\n    error_count = Column(Integer, default=0)\n    fetch_interval = Column(Integer, default=900)  # 抓取间隔（秒）\n    initial_entries_count = Column(Integer, default=2)  # 首次添加时处理的条目数\n    update_entries_count = Column(Integer, default=1)  # 每次更新时处理的条目数\n    created_at = Column(BigInteger, nullable=False, default=TimeUtil.now_ms)\n    updated_at = Column(BigInteger, nullable=False, default=TimeUtil.now_ms, onupdate=TimeUtil.now_ms)\n    \n    user = relationship(\"User\", back_populates=\"rss_feeds\")\n    entries = relationship(\"RSSEntry\", back_populates=\"feed\", cascade=\"all, delete-orphan\")\n\n    # 添加用户级别的URL唯一性约束\n    __table_args__ = (\n        UniqueConstraint('user_id', 'url', name='uix_user_url'),\n    )\n\nclass RSSEntry(Base):\n    __tablename__ = \"rss_entries\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    feed_id = Column(Integer, ForeignKey(\"rss_feeds.id\", ondelete=\"CASCADE\"), nullable=False)\n    guid = Column(String, nullable=False)\n    title = Column(String)\n    link = Column(String)\n    published = Column(BigInteger)  # 毫秒时间戳\n    processed = Column(Boolean, default=False)\n    task_id = Column(String, ForeignKey(\"tasks.taskId\", ondelete=\"CASCADE\"))\n    user_id = Column(Integer, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False)\n    created_at = Column(BigInteger, default=lambda: TimeUtil.now_ms())\n    updated_at = Column(BigInteger, default=lambda: TimeUtil.now_ms(), onupdate=lambda: TimeUtil.now_ms())\n\n    __table_args__ = (\n        UniqueConstraint('guid', 'user_id', name='uq_rss_entries_guid_user'),\n    )\n\n    # 关系\n    feed = relationship(\"RSSFeed\", back_populates=\"entries\")\n    task = relationship(\"Task\", back_populates=\"rss_entries\")\n"}
{"type": "source_file", "path": "server/run.py", "content": "import uvicorn\nfrom core.config import config_manager\n\nif __name__ == '__main__':\n    uvicorn.run(\n        \"main:app\",\n        host=config_manager.HOST,\n        port=config_manager.PORT,\n        reload=True,  # 开发模式下启用热重载\n        log_level=\"info\",\n        access_log=True,\n        timeout_keep_alive=65\n    ) "}
{"type": "source_file", "path": "server/main.py", "content": "import sys\nfrom pathlib import Path\nsys.path.append(str(Path(__file__).parent))\n\nfrom contextlib import asynccontextmanager\nimport logging\nimport threading\nimport os\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.exceptions import RequestValidationError\nfrom core.exceptions import validation_exception_handler, general_exception_handler\nfrom core.config import config_manager\nfrom core.scheduler import setup_scheduler\nfrom db.session import get_db, init_db\nfrom services.task.task_service import TaskService\nfrom api.v1.api import api_router\n\n# 配置日志\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s | %(levelname)s | %(name)s:%(funcName)s:%(lineno)d | %(message)s',\n    datefmt='%Y-%m-%d %H:%M:%S'\n)\n\n# 创建lifespan上下文管理器\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"应用程序生命周期管理\"\"\"\n    # 启动时的操作\n    init_db()\n    \n    # 确保任务目录存在\n    os.makedirs(config_manager.TASK_DIR, exist_ok=True)\n    \n    # 加载数据库配置\n    db = next(get_db())\n    try:\n        logging.info(\"正在加载数据库配置...\")\n        config_manager.reload_db_config(db)\n        \n        logging.info(\"正在启动任务检查线程...\")\n        threading.Thread(\n            target=TaskService.check_incomplete_tasks,\n            args=(db,),\n            daemon=True\n        ).start()\n        \n        # 启动RSS调度器\n        logging.info(\"正在启动RSS调度器...\")\n        scheduler = setup_scheduler()\n        scheduler.start()\n        \n        logging.info(f\"服务器已启动 - 监听地址: {config_manager.HOST}:{config_manager.PORT}\")\n        yield\n        \n        # 关闭时的操作\n        logging.info(\"正在关闭RSS调度器...\")\n        scheduler.shutdown()\n        logging.info(\"服务器正在关闭...\")\n    finally:\n        db.close()\n\n# 创建FastAPI应用\napp = FastAPI(\n    title=\"LingoPod API\",\n    lifespan=lifespan  # 使用lifespan上下文管理器\n)\n\n# 配置CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# 异常处理\napp.add_exception_handler(RequestValidationError, validation_exception_handler)\napp.add_exception_handler(Exception, general_exception_handler)\n\n# 包含API路由\napp.include_router(api_router, prefix=\"/api/v1\")\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Welcome to LingoPod API\"}"}
{"type": "source_file", "path": "server/services/llm.py", "content": "from langchain_openai import ChatOpenAI\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.output_parsers import JsonOutputParser\nfrom core.config import settings\nfrom core.logging import log\nfrom typing import List, Dict\nfrom utils.prompt_utils import PromptUtils\n\nclass LLMService:\n    def __init__(self):\n        self.llm = ChatOpenAI(\n            model_name=settings.MODEL,\n            openai_api_key=settings.API_KEY,\n            openai_api_base=settings.API_BASE_URL\n        )\n\n\n"}
{"type": "source_file", "path": "server/schemas/user.py", "content": "from typing import Optional, List\nfrom pydantic import BaseModel, EmailStr\n\n\nclass UserBase(BaseModel):\n    username: str\n    email: Optional[EmailStr] = None\n    nickname: Optional[str] = None\n    is_active: Optional[bool] = True\n    is_admin: Optional[bool] = False\n\n\nclass UserCreate(UserBase):\n    password: str\n\n\nclass UserUpdate(BaseModel):\n    nickname: Optional[str] = None\n    email: Optional[EmailStr] = None\n\n\nclass UserInDB(UserBase):\n    id: int\n    created_at: int\n    last_login: Optional[int] = None\n\n    class Config:\n        from_attributes = True\n\n\nclass UserResponse(UserInDB):\n    pass\n\n\nclass UserListResponse(BaseModel):\n    total: int\n    items: List[UserResponse]\n\n\nclass UserStatusUpdate(BaseModel):\n    is_active: bool\n\n\nclass UserPasswordUpdate(BaseModel):\n    old_password: str\n    new_password: str"}
{"type": "source_file", "path": "server/auth/utils.py", "content": "from datetime import datetime, timedelta\nfrom jose import jwt\nfrom passlib.context import CryptContext\nfrom core.config import settings\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\ndef create_access_token(data: dict, expires_delta: timedelta = None) -> str:\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(\n        to_encode, \n        settings.JWT_SECRET_KEY, \n        algorithm=settings.JWT_ALGORITHM\n    )\n    return encoded_jwt\n"}
{"type": "source_file", "path": "server/services/file.py", "content": "import os\nimport json\nimport shutil\nfrom core.config import settings\nfrom core.logging import log\nfrom models.enums import TaskProgress, TaskStatus\n\nclass FileService:\n    @staticmethod\n    def create_task_directory(task_id: str) -> str:\n        task_dir = os.path.join(settings.TASK_DIR, task_id)\n        os.makedirs(task_dir, exist_ok=True)\n        log.info(f\"创建任务文件夹: {task_dir}\")\n        return task_dir\n    \n    @staticmethod\n    def get_task_file_path(task_id: str, filename: str) -> str:\n        \"\"\"获取任务文件的完整路径\n        \n        Args:\n            task_id: 任务ID\n            filename: 文件名 (从task.files结构中获取的文件名)\n        \"\"\"\n        task_dir = os.path.join(settings.TASK_DIR, task_id)\n        file_path = os.path.join(task_dir, filename)\n        log.debug(f\"构建文件路径: {file_path}\")\n        return file_path\n    \n    @staticmethod\n    def get_task_file_name(level: str, lang: str, file_type: str, task_id: str) -> str:\n        \"\"\"生成标准化的文件名\n        \n        Args:\n            level: 难度等级 (elementary/intermediate/advanced)\n            lang: 语言 (cn/en)\n            file_type: 文件类型 (audio/subtitle)\n            task_id: 任务ID\n        \"\"\"\n        # 文件扩展名映射\n        extensions = {\n            \"audio\": \"mp3\",\n            \"subtitle\": \"srt\"\n        }\n        ext = extensions.get(file_type, \"txt\")\n        \n        # 生成标准化文件名: {level}_{lang}_{type}_{task_id}.{ext}\n        filename = f\"{level}_{lang}_{file_type}_{task_id}.{ext}\"\n        return filename\n    \n    @staticmethod\n    def read_file_content(file_path: str) -> str:\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f\"文件不存在: {file_path}\")\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                return f.read().strip()\n        except Exception as e:\n            log.error(f\"读取文件失败: {file_path}, 错误: {str(e)}\")\n            raise\n\n    @staticmethod\n    def read_json_file(file_path: str) -> dict:\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f\"文件不存在: {file_path}\")\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                return json.load(f)\n        except json.JSONDecodeError as e:\n            log(f\"JSON 解析失败: {file_path}, 错误: {str(e)}\")\n            raise\n        except Exception as e:\n            log(f\"读取 JSON 文件失败: {file_path}, 错误: {str(e)}\")\n            raise\n\n    @staticmethod\n    def delete_task_directory(task_id: str):\n        task_dir = os.path.join(settings.TASK_DIR, task_id)\n        if os.path.exists(task_dir):\n            shutil.rmtree(task_dir)\n            log.info(f\"已删除任务文件夹: {task_dir}\")\n\n    @staticmethod\n    def update_task_files(task_id: str, level: str, lang: str, file_type: str) -> str:\n        \"\"\"更新任务文件结构并返回生成的文件名\n        \n        Args:\n            task_id: 任务ID\n            level: 难度等级 (elementary/intermediate/advanced)\n            lang: 语言 (cn/en)\n            file_type: 文件类型 (audio/subtitle)\n            \n        Returns:\n            str: 生成的标准化文件名\n        \"\"\"\n        # 生成标准化文件名\n        filename = FileService.get_task_file_name(\n            level=level,\n            lang=lang,\n            file_type=file_type,\n            task_id=task_id\n        )\n        \n        # 确保任务目录存在\n        FileService.create_task_directory(task_id)\n        \n        return filename\n\n    @staticmethod\n    def write_file(task_id: str, level: str, lang: str, file_type: str, content: bytes | str) -> str:\n        \"\"\"写入文件内容并返回文件名\n        \n        Args:\n            task_id: 任务ID\n            level: 难度等级\n            lang: 语言\n            file_type: 文件类型\n            content: 文件内容(二进制或文本)\n            \n        Returns:\n            str: 生成的标准化文件名\n        \"\"\"\n        # 生成标准化文件名\n        filename = FileService.get_task_file_name(\n            level=level,\n            lang=lang,\n            file_type=file_type,\n            task_id=task_id\n        )\n        \n        # 获取完整文件路径\n        file_path = FileService.get_task_file_path(task_id, filename)\n        \n        # 确保目录存在\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        \n        # 写入文件\n        mode = 'wb' if isinstance(content, bytes) else 'w'\n        encoding = None if isinstance(content, bytes) else 'utf-8'\n        \n        try:\n            with open(file_path, mode=mode, encoding=encoding) as f:\n                f.write(content)\n            log.info(f\"文件写入成功: {file_path}\")\n        except Exception as e:\n            log.error(f\"文件写入失败: {file_path}, 错误: {str(e)}\")\n            raise\n            \n        return filename\n"}
{"type": "source_file", "path": "server/schemas/task.py", "content": "from pydantic import BaseModel, Field, ValidationError, field_validator, ConfigDict\nfrom typing import Optional, List, Dict, Literal\nfrom utils.time_utils import TimeUtil\nfrom datetime import datetime\nimport re\nfrom core.config import settings\n\n# 基础任务属性\nclass TaskBase(BaseModel):\n    url: str = Field(..., description=\"任务URL\")\n    \n    @field_validator('url')\n    @classmethod\n    def validate_url(cls, v: str) -> str:\n        # 获取允许的URL模式\n        pattern = settings.ALLOWED_URL_PATTERN\n        if not re.match(pattern, str(v)):\n            raise ValueError(f'URL必须匹配模式: {pattern}')\n        return v\n\n# 对话风格参数\nclass StyleParams(BaseModel):\n    \"\"\"对话风格参数\"\"\"\n    content_length: Literal[\"short\", \"medium\", \"long\"] = Field(\n        default=\"medium\",\n        description=\"对话长度: short(5-8轮), medium(8-12轮), long(12-15轮)\"\n    )\n    tone: Literal[\"casual\", \"formal\", \"humorous\"] = Field(\n        default=\"casual\",\n        description=\"对话语气: casual(轻松), formal(正式), humorous(幽默)\"\n    )\n    emotion: Literal[\"neutral\", \"enthusiastic\", \"professional\"] = Field(\n        default=\"neutral\",\n        description=\"情感色彩: neutral(中性), enthusiastic(热情), professional(专业)\"\n    )\n\n# 媒体文件\nclass MediaFiles(BaseModel):\n    \"\"\"媒体文件\"\"\"\n    audio: Optional[str] = Field(None, description=\"音频文件URL\")\n    subtitle: Optional[str] = Field(None, description=\"字幕文件URL\")\n\n# 语言文件\nclass LanguageFiles(BaseModel):\n    \"\"\"语言文件\"\"\"\n    en: Optional[MediaFiles] = Field(None, description=\"英文文件\")\n    cn: Optional[MediaFiles] = Field(None, description=\"中文文件\")\n\n# 创建任务时的请求模型\nclass TaskCreate(TaskBase):\n    is_public: bool = Field(default=False, description=\"是否公开\")\n    style_params: Optional[StyleParams] = Field(\n        default_factory=StyleParams,\n        description=\"对话风格参数\"\n    )\n\n# 更新任务时的请求模型\nclass TaskUpdate(BaseModel):\n    status: Optional[str] = None\n    progress: Optional[str] = None\n    title: Optional[str] = None\n    current_step: Optional[str] = None\n    total_steps: Optional[int] = Field(None, ge=0)\n    step_progress: Optional[int] = Field(None, ge=0, le=100)\n    is_public: Optional[bool] = None\n    style_params: Optional[StyleParams] = None\n\n    @field_validator('step_progress')\n    @classmethod\n    def validate_step_progress(cls, v):\n        if v is not None and not (0 <= v <= 100):\n            raise ValueError('Step progress must be between 0 and 100')\n        return v\n\n# 完整任务响应模型\nclass TaskResponse(TaskBase):\n    \"\"\"完整任务响应模型\"\"\"\n    model_config = ConfigDict(from_attributes=True)\n\n    taskId: str\n    status: str\n    progress: str\n    title: Optional[str] = None\n    created_at: int\n    updated_at: int\n    is_public: bool\n    style_params: StyleParams\n    files: Dict[str, LanguageFiles] = Field(\n        default_factory=dict,\n        description=\"按难度等级和语言组织的文件, 如: {'elementary': {'en': {...}, 'cn': {...}}}\"\n    )\n    error: Optional[str] = None\n    current_step: Optional[str] = None\n    current_step_index: Optional[int] = None\n    total_steps: Optional[int] = None\n    step_progress: Optional[int] = None\n    progress_message: Optional[str] = None\n\n# 任务查询参数模型\nclass TaskQueryParams(BaseModel):\n    status: Optional[str] = Field(None, description=\"任务状态\")\n    start_date: Optional[int] = Field(None, description=\"开始时间(毫秒时间戳)\")\n    end_date: Optional[int] = Field(None, description=\"结束时间(毫秒时间戳)\")\n    is_public: Optional[bool] = Field(None, description=\"是否公开\")\n    user_id: Optional[int] = Field(None, description=\"用户ID\")\n    title_keyword: Optional[str] = Field(None, description=\"标题关键词\")\n    url_keyword: Optional[str] = Field(None, description=\"URL关键词\")\n    limit: int = Field(10, ge=1, le=100, description=\"每页数量\")\n    offset: int = Field(0, ge=0, description=\"偏移量\")\n\n# 任务列表响应模型\nclass TaskListResponse(BaseModel):\n    total: int\n    items: List[TaskResponse]\n"}
{"type": "source_file", "path": "server/schemas/rss.py", "content": "from typing import Optional\nfrom pydantic import BaseModel, HttpUrl, Field, model_validator\nfrom core.config import settings\n\nclass RSSFeedBase(BaseModel):\n    \"\"\"RSS源基础模型\"\"\"\n    url: HttpUrl\n    title: Optional[str] = Field(\n        default=None,\n        description=\"RSS源标题，如果不指定则自动从源获取\"\n    )\n    fetch_interval: Optional[int] = Field(\n        default=settings.RSS_DEFAULT_FETCH_INTERVAL_SECONDS,\n        description=\"抓取间隔（秒）\",\n        ge=settings.RSS_MIN_FETCH_INTERVAL,\n        le=settings.RSS_MAX_FETCH_INTERVAL\n    )\n    initial_entries_count: Optional[int] = Field(\n        default=2,\n        description=\"首次获取的条目数量\",\n        ge=1\n    )\n    update_entries_count: Optional[int] = Field(\n        default=1,\n        description=\"后续更新的条目数量\",\n        ge=1\n    )\n\n    @model_validator(mode='before')\n    @classmethod\n    def validate_url(cls, data):\n        if isinstance(data, dict) and 'url' in data:\n            if isinstance(data['url'], str):\n                data['url'] = HttpUrl(data['url'])\n        return data\n\n    def model_dump(self, *args, **kwargs):\n        data = super().model_dump(*args, **kwargs)\n        if 'url' in data:\n            data['url'] = str(data['url'])\n        return data\n\nclass RSSFeedCreate(RSSFeedBase):\n    \"\"\"创建RSS源的请求模型\"\"\"\n    pass\n\nclass RSSFeedUpdate(BaseModel):\n    \"\"\"更新RSS源的请求模型\"\"\"\n    title: Optional[str] = Field(\n        default=None,\n        description=\"RSS源标题\"\n    )\n    fetch_interval: Optional[int] = Field(\n        default=None,\n        description=\"抓取间隔（秒）\",\n        ge=settings.RSS_MIN_FETCH_INTERVAL,\n        le=settings.RSS_MAX_FETCH_INTERVAL\n    )\n    initial_entries_count: Optional[int] = Field(\n        default=None,\n        description=\"首次获取的条目数量\",\n        ge=1\n    )\n    update_entries_count: Optional[int] = Field(\n        default=None,\n        description=\"后续更新的条目数量\",\n        ge=1\n    )\n\nclass RSSFeedList(RSSFeedBase):\n    \"\"\"RSS源列表响应模型\"\"\"\n    id: int\n    title: Optional[str] = None\n    user_id: int\n    last_fetch: Optional[int] = None\n    is_active: bool\n    error_count: int\n    created_at: int\n    updated_at: int\n\n    class Config:\n        from_attributes = True\n\nclass RSSFeedResponse(RSSFeedList):\n    \"\"\"RSS源详情响应模型\"\"\"\n    pass\n\nclass RSSEntryBase(BaseModel):\n    \"\"\"RSS条目基础模型\"\"\"\n    guid: str\n    title: Optional[str] = None\n    link: Optional[str] = None\n    published: Optional[int] = None\n\nclass RSSEntryResponse(RSSEntryBase):\n    \"\"\"RSS条目响应模型\"\"\"\n    id: int\n    feed_id: int\n    processed: bool\n    task_id: Optional[str] = None\n    created_at: int\n    updated_at: int\n\n    class Config:\n        from_attributes = True\n"}
{"type": "source_file", "path": "server/api/v1/users.py", "content": "import os\nimport shutil\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, Query\nfrom sqlalchemy.orm import Session\n\nfrom auth.dependencies import get_admin_user, get_current_active_user\nfrom auth.utils import verify_password, get_password_hash\nfrom core.config import settings\nfrom db.session import get_db\nfrom models.task import Task\nfrom models.user import User\nfrom schemas.user import (\n    UserResponse, UserListResponse, UserStatusUpdate,\n    UserUpdate, UserPasswordUpdate\n)\n\nrouter = APIRouter()\n\n@router.get(\"/health\", status_code=200)\nasync def health_check():\n    \"\"\"健康检查接口\"\"\"\n    return {\"status\": \"ok\", \"message\": \"服务正常运行\"}\n\n@router.delete(\"/{user_id}\", status_code=204)\nasync def delete_user(\n    user_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_admin_user)\n):\n    \"\"\"删除用户\"\"\"\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"用户未找到\")\n    \n    # 删除用户相关的任务及其文件夹\n    tasks = db.query(Task).filter(Task.user_id == user_id).all()\n    for task in tasks:\n        task_dir = os.path.join(settings.TASK_DIR, task.taskId)\n        if os.path.exists(task_dir):\n            shutil.rmtree(task_dir)\n        db.delete(task)\n    \n    # 删除用户\n    db.delete(user)\n    db.commit()\n    return {\"message\": \"用户删除成功\"}\n\n@router.get(\"/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_admin_user)\n):\n    \"\"\"获取用户信息\"\"\"\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"用户未找到\")\n    return user \n\n@router.get(\"/\", response_model=UserListResponse)\nasync def list_users(\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_admin_user),\n    limit: int = Query(10, ge=1, le=100),\n    offset: int = Query(0, ge=0),\n    username: str = None,\n    is_active: bool = None,\n    start_date: int = None,\n    end_date: int = None\n):\n    \"\"\"获取用户列表，支持分页和过滤\"\"\"\n    # 构建查询条件\n    query = db.query(User)\n    \n    if username:\n        query = query.filter(User.username.ilike(f\"%{username}%\"))\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    if start_date:\n        query = query.filter(User.created_at >= start_date)\n    if end_date:\n        query = query.filter(User.created_at <= end_date)\n    \n    # 获取总数\n    total = query.count()\n    \n    # 获取分页数据\n    users = query.offset(offset).limit(limit).all()\n    \n    return {\n        \"total\": total,\n        \"items\": users\n    }\n\n@router.patch(\"/{user_id}/status\", response_model=UserResponse)\nasync def update_user_status(\n    user_id: int,\n    status_update: UserStatusUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_admin_user)\n):\n    \"\"\"禁用或启用用户\"\"\"\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"用户未找到\")\n    \n    user.is_active = status_update.is_active\n    db.commit()\n    db.refresh(user)\n    return user\n\n@router.patch(\"/me\", response_model=UserResponse)\ndef update_user_me(\n    user_update: UserUpdate,\n    current_user: User = Depends(get_current_active_user),\n    db: Session = Depends(get_db)\n):\n    \"\"\"更新当前用户信息\"\"\"\n    if user_update.email is not None:\n        current_user.email = user_update.email\n    if user_update.nickname is not None:\n        current_user.nickname = user_update.nickname\n    \n    db.add(current_user)\n    db.commit()\n    db.refresh(current_user)\n    return current_user\n\n@router.post(\"/me/password\", status_code=200)\nasync def update_password(\n    password_update: UserPasswordUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_active_user)\n):\n    \"\"\"修改当前用户密码\"\"\"\n    # 验证旧密码\n    if not verify_password(password_update.old_password, current_user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"旧密码错误\"\n        )\n    \n    # 更新密码\n    current_user.hashed_password = get_password_hash(password_update.new_password)\n    db.commit()\n    \n    return {\"message\": \"密码修改成功\"}"}
{"type": "source_file", "path": "server/services/edgetts.py", "content": "import edge_tts\nimport asyncio\nimport tempfile\nimport subprocess\nimport os\nfrom typing import Optional, List, Dict\nfrom core.config import settings\nfrom core.logging import log\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nclass EdgeTTSService:\n    def __init__(self):\n        self.voice_mapping = {\n            'alloy': 'en-US-AvaNeural',\n            'echo': 'en-US-AndrewNeural',\n            'fable': 'en-GB-SoniaNeural',\n            'onyx': 'en-US-EricNeural',\n            'nova': 'en-US-SteffanNeural',\n            'shimmer': 'en-US-EmmaNeural'\n        }\n        self.default_language = os.getenv('DEFAULT_LANGUAGE', 'en-US')\n\n    def generate_speech(self, text: str, voice: str, response_format: str = \"mp3\", speed: float = 1.0) -> str:\n        \"\"\"生成语音文件\"\"\"\n        return asyncio.run(self._generate_audio(text, voice, response_format, speed))\n\n    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\n    async def _generate_audio(self, text: str, voice: str, response_format: str, speed: float) -> str:\n        \"\"\"生成音频文件，失败时最多重试3次\"\"\"\n        try:\n            edge_tts_voice = self.voice_mapping.get(voice, voice)\n            proxy = settings.HTTPS_PROXY\n            temp_output_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".mp3\")\n            if proxy:\n                communicator = edge_tts.Communicate(text, edge_tts_voice, connect_timeout=5, proxy=proxy)\n            else:\n                communicator = edge_tts.Communicate(text, edge_tts_voice, connect_timeout=5)\n            await communicator.save(temp_output_file.name)\n\n            if response_format == \"mp3\" and speed == 1.0:\n                return temp_output_file.name\n\n            if not self._is_ffmpeg_installed():\n                log.error(\"FFmpeg not available. Returning unmodified mp3 file.\")\n                return temp_output_file.name\n\n            return self._convert_audio(temp_output_file.name, response_format, speed)\n            \n        except Exception as e:\n            log.error(f\"Edge TTS 生成音频失败: {str(e)}\")\n            log.error(f\"使用的参数: text='{text}', voice='{edge_tts_voice}', format='{response_format}', speed={speed}\")\n            raise\n\n    def _is_ffmpeg_installed(self) -> bool:\n        \"\"\"检查 FFmpeg 是否已安装\"\"\"\n        try:\n            subprocess.run(['ffmpeg', '-version'], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            return True\n        except (subprocess.CalledProcessError, FileNotFoundError):\n            return False\n\n    def _convert_audio(self, input_file: str, response_format: str, speed: float) -> str:\n        \"\"\"转换音频格式和速度\"\"\"\n        converted_output_file = tempfile.NamedTemporaryFile(delete=False, suffix=f\".{response_format}\")\n        speed_filter = f\"atempo={speed}\" if response_format != \"pcm\" else f\"asetrate=44100*{speed},aresample=44100\"\n        \n        ffmpeg_command = [\n            \"ffmpeg\", \"-i\", input_file,\n            \"-filter:a\", speed_filter,\n            \"-f\", response_format, \"-y\",\n            converted_output_file.name\n        ]\n\n        try:\n            subprocess.run(ffmpeg_command, check=True)\n            return converted_output_file.name\n        except subprocess.CalledProcessError as e:\n            raise RuntimeError(f\"Error in audio conversion: {e}\")\n\n    def get_models(self) -> List[Dict[str, str]]:\n        \"\"\"获取可用的 TTS 模型列表\"\"\"\n        return [\n            {\"id\": \"tts-1\", \"name\": \"Text-to-speech v1\"},\n            {\"id\": \"tts-1-hd\", \"name\": \"Text-to-speech v1 HD\"}\n        ]\n\n    async def _get_voices(self, language: Optional[str] = None) -> List[Dict[str, str]]:\n        \"\"\"获取可用的语音列表\"\"\"\n        all_voices = await edge_tts.list_voices()\n        language = language or self.default_language\n        return [\n            {\"name\": v['ShortName'], \"gender\": v['Gender'], \"language\": v['Locale']}\n            for v in all_voices \n            if language == 'all' or language is None or v['Locale'] == language\n        ]\n\n    def get_voices(self, language: Optional[str] = None) -> List[Dict[str, str]]:\n        \"\"\"获取可用的语音列表（同步版本）\"\"\"\n        return asyncio.run(self._get_voices(language))\n"}
{"type": "source_file", "path": "server/core/thread_pool.py", "content": "from concurrent.futures import ThreadPoolExecutor, Future\nimport threading\nfrom typing import Callable, Any\nfrom core.logging import log\nfrom core.config import settings\n\nclass ThreadPoolManager:\n    \"\"\"线程池管理器\"\"\"\n    _instance = None\n    _lock = threading.Lock()\n    \n    def __new__(cls):\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = super().__new__(cls)\n            return cls._instance\n    \n    def __init__(self):\n        if not hasattr(self, 'initialized'):\n            # 从配置文件读取最大并发数，默认为3\n            self.max_workers = getattr(settings, 'MAX_TASK_WORKERS', 3)\n            self.executor = ThreadPoolExecutor(\n                max_workers=self.max_workers,\n                thread_name_prefix='task_worker'\n            )\n            self.initialized = True\n            log.info(f\"线程池初始化完成，最大并发数: {self.max_workers}\")\n    \n    @classmethod\n    def get_instance(cls) -> 'ThreadPoolManager':\n        \"\"\"获取线程池管理器实例\"\"\"\n        if cls._instance is None:\n            cls._instance = cls()\n        return cls._instance\n    \n    def submit(self, fn: Callable, *args, **kwargs) -> Future:\n        \"\"\"提交任务到线程池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 位置参数\n            **kwargs: 关键字参数\n            \n        Returns:\n            Future: 用于跟踪任务执行状态的Future对象\n        \"\"\"\n        return self.executor.submit(fn, *args, **kwargs)\n    \n    def set_max_workers(self, max_workers: int):\n        \"\"\"设置最大工作线程数\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers != self.max_workers:\n            log.info(f\"更新线程池最大并发数: {self.max_workers} -> {max_workers}\")\n            # 关闭当前线程池\n            self.shutdown()\n            # 创建新的线程池\n            self.max_workers = max_workers\n            self.executor = ThreadPoolExecutor(\n                max_workers=max_workers,\n                thread_name_prefix='task_worker'\n            )\n    \n    def shutdown(self, wait: bool = True):\n        \"\"\"关闭线程池\n        \n        Args:\n            wait: 是否等待所有任务完成\n        \"\"\"\n        if hasattr(self, 'executor'):\n            self.executor.shutdown(wait=wait)\n            log.info(\"线程池已关闭\") "}
{"type": "source_file", "path": "server/services/task/__init__.py", "content": "from .processor import TaskProcessor\nfrom .task_service import TaskService\n\n__all__ = ['TaskProcessor', 'TaskService']"}
{"type": "source_file", "path": "server/services/task/processor.py", "content": "from typing import List, Dict\nimport sqlalchemy\nfrom sqlalchemy.orm import Session\nimport os\nimport time\nimport json\nfrom concurrent.futures import Future\n\nfrom models.task import Task\nfrom models.enums import TaskProgress, TaskStatus\nfrom services.task.steps.audio import AudioStep\nfrom services.task.steps.audio_merge import AudioMergeStep\nfrom services.task.steps.content import ContentStep\nfrom services.task.steps.dialogue import DialogueStep\nfrom services.task.steps.subtitle import SubtitleStep\nfrom services.task.steps.translation import TranslationStep\nfrom services.task.utils.errors import TaskError\nfrom .utils.context import ContextManager\nfrom .utils.progress_tracker import ProgressTracker\nfrom .steps.base import BaseStep\nfrom core.logging import log\nfrom core.config import settings\nfrom core.thread_pool import ThreadPoolManager\nfrom services.task.steps.fetch_content import FetchContentStep\nfrom services.task.steps.generate_title import GenerateTitleStep\n\nclass TaskProcessor:\n    \"\"\"任务处理器\"\"\"\n    \n    MAX_STEP_RETRIES = 1  # 单个步骤最大重试次数\n    RETRY_DELAY = 3  # 重试等待时间(秒)\n    \n    def __init__(self, task: Task, db: Session, is_retry: bool = False):\n        self.task = task\n        self.db = db\n        self.is_retry = is_retry\n        self.temp_dir = os.path.join(settings.TASK_DIR, task.taskId)\n        os.makedirs(self.temp_dir, exist_ok=True)\n        \n        # 确保任务对象是最新的且与会话关联\n        try:\n            # 重新从数据库加载任务对象\n            self.task = self.db.merge(self.task)\n            self.db.refresh(self.task)\n        except Exception as e:\n            self.db.rollback()\n            raise Exception(f\"无法刷新任务对象: {str(e)}\")\n        \n        self.context_manager = ContextManager(task, self.temp_dir)\n        \n        # 创建难度等级目录\n        self.level_dirs = {}\n        for level in [\"elementary\", \"intermediate\", \"advanced\"]:\n            level_dir = os.path.join(self.temp_dir, level)\n            os.makedirs(level_dir, exist_ok=True)\n            self.level_dirs[level] = level_dir\n            self.context_manager.set(f\"{level}_dir\", level_dir)\n        \n        self.steps = self._create_steps_without_tracker()\n        self.progress_tracker = ProgressTracker(self.task, db, len(self.steps))\n        self._update_steps_tracker()\n        self.start_step = self._get_start_step(is_retry)\n        \n    def _create_steps_without_tracker(self) -> List[BaseStep]:\n        \"\"\"创建处理步骤列表(不包含progress_tracker)\"\"\"\n        base_params = {\n            \"progress_tracker\": None,\n            \"context_manager\": self.context_manager\n        }\n        steps = [\n            # 添加通用步骤\n            FetchContentStep(**base_params),  # 确保这是第一个步骤\n            GenerateTitleStep(**base_params),\n        ]\n        # 为每个难度等级创建步骤\n        for level in [\"elementary\", \"intermediate\", \"advanced\"]:\n            level_steps = [\n                ContentStep(level=level, **base_params),\n                DialogueStep(level=level, **base_params),\n                TranslationStep(level=level, **base_params)\n            ]\n            # 需要中英文处理的步骤类\n            bilingual_steps = [\n                (AudioStep, \"音频生成\"),\n                (SubtitleStep, \"字幕生成\"), \n                (AudioMergeStep, \"音频合并\")\n            ]\n            # 添加中英文步骤\n            for step_class, _ in bilingual_steps:\n                for lang in [\"cn\", \"en\"]:\n                    level_steps.append(\n                        step_class(level=level, lang=lang, **base_params)\n                    )\n            steps.extend(level_steps)\n        return steps\n\n    def _update_steps_tracker(self):\n        \"\"\"更新所有步骤的progress_tracker\"\"\"\n        for step in self.steps:\n            step.progress_tracker = self.progress_tracker\n\n    @classmethod\n    def process_task_async(cls, task: Task, db: Session, is_retry: bool = False) -> Future:\n        \"\"\"异步处理任务\n        \n        Args:\n            task: Task对象\n            db: 数据库会话\n            is_retry: 是否为重试任务\n            \n        Returns:\n            Future: 用于跟踪任务执行状态的Future对象\n        \"\"\"\n        processor = cls(task, db, is_retry)\n        pool = ThreadPoolManager.get_instance()\n        return pool.submit(processor.process_task)\n\n    def process_task(self, timeout: int = None):\n        \"\"\"处理任务\n        \n        Args:\n            timeout (int, optional): 任务执行超时时间(秒)。默认为None，表示不设置超时。\n        \"\"\"\n        task_id = self.task.taskId  # 预先保存taskId\n        log.info(f\"开始处理任务: {task_id}\")\n        try:\n            start_time = time.time()\n            self._execute_steps(timeout=timeout)\n            self._complete_task()\n            log.info(f\"任务处理完成: {task_id}\")\n        except Exception as e:\n            log.error(f\"任务处理失败: {task_id}, error: {str(e)}\")\n            try:\n                self._handle_failure(e)\n            except (sqlalchemy.orm.exc.ObjectDeletedError, sqlalchemy.exc.InvalidRequestError):\n                # 任务已被删除，记录日志并优雅退出\n                log.warning(f\"Task has been deleted during processing: {task_id}\")\n                return\n            raise\n\n    def _execute_steps(self, timeout: int = None):\n        \"\"\"执行所有步骤\"\"\"\n        try:\n            # 在每次重要操作前刷新任务对象\n            try:\n                # 重新从数据库加载任务对象\n                self.task = self.db.merge(self.task)\n                self.db.refresh(self.task)\n            except Exception as e:\n                self.db.rollback()\n                raise Exception(f\"无法刷新任务对象: {str(e)}\")\n            \n            # 更新总步骤数\n            self.task.total_steps = len(self.steps)\n            self.task.status = TaskStatus.PROCESSING.value\n            self.task.progress = TaskProgress.PROCESSING.value\n            self.task.progress_message = \"开始执行任务\"\n            \n            try:\n                self.db.commit()\n            except Exception as e:\n                self.db.rollback()\n                raise Exception(f\"更新任务状态失败: {str(e)}\")\n            \n            start_time = time.time()\n            for i, step in enumerate(self.steps[self.start_step:], self.start_step):\n                if timeout and (time.time() - start_time) > timeout:\n                    raise Exception(f\"任务执行超时(超过{timeout}秒)\")\n                \n                # 每个步骤开始前刷新任务对象\n                try:\n                    # 重新从数据库加载任务对象\n                    self.task = self.db.merge(self.task)\n                    self.db.refresh(self.task)\n                    self._execute_single_step(step, i)\n                except Exception as e:\n                    log.error(f\"步骤执行失败: {str(e)}\")\n                    raise e\n                \n        except sqlalchemy.exc.InvalidRequestError as e:\n            self.db.rollback()\n            raise Exception(f\"任务可能已被删除: {str(e)}\")\n        except Exception as e:\n            self.db.rollback()\n            raise e\n\n    def _execute_single_step(self, step: BaseStep, step_index: int):\n        \"\"\"执行单个步骤，失败时自动重试\"\"\"\n        level = getattr(step, 'level', None)\n        if level:\n            self.context_manager.set('current_level', level)\n            self.context_manager.set('level_dir', self.level_dirs[level])\n            \n        self.context_manager.set('current_step_index', step_index)\n        \n        retry_count = 0\n        last_error = None\n        \n        while retry_count <= self.MAX_STEP_RETRIES:\n            try:\n                self._update_step_progress(step, step_index, 0, \n                    \"开始执行\" if retry_count == 0 else f\"第{retry_count}次重试\")\n                \n                if self._should_execute_step(step):\n                    log.info(f\"步骤 {step.name} 需要执行\" + \n                            (f\" (重试 {retry_count})\" if retry_count > 0 else \"\"))\n                    result = step.execute()\n                    self._handle_step_success(step, result, step_index)\n                else:\n                    log.info(f\"步骤 {step.name} 已完成，跳过执行\")\n                    self._load_completed_step(step, step_index)\n                return  # 执行成功，直接返回\n                \n            except Exception as e:\n                last_error = e\n                retry_count += 1\n                \n                if retry_count <= self.MAX_STEP_RETRIES:\n                    log.warning(f\"步骤 {step.name} 执行失败，{self.RETRY_DELAY}秒后进行第{retry_count}次重试。错误: {str(e)}\")\n                    time.sleep(self.RETRY_DELAY)\n                    continue\n                \n                # 如果已达到最大重试次数，记录错误并重新抛出异常\n                log.error(f\"步骤 {step.name} 在重试{self.MAX_STEP_RETRIES}次后仍然失败\")\n                self._handle_step_failure(step, last_error)\n                \n                # 抛出特殊异常以触发整个任务的重试\n                raise TaskError(f\"步骤 {step.name} 执行失败，需要重试整个任务: {str(last_error)}\")\n\n    def _should_execute_step(self, step: BaseStep) -> bool:\n        \"\"\"检查步骤是否需要执行\"\"\"\n        if self.is_retry and step.name == self.task.current_step:\n            return True\n        \n        for output in step.output_files:\n            # 检查文件是否在temp_dir中存在\n            file_exists = os.path.exists(os.path.join(self.temp_dir, output))\n            # 检查context manager中是否有输出且值不为空\n            context_value = self.context_manager.get(output)\n            context_exists = context_value is not None and context_value != \"\"\n            \n            # 如果文件既不在temp_dir也不在context_manager中，需要执行步骤\n            if not (file_exists or context_exists):\n                return True\n        \n        return False\n\n    def _handle_step_success(self, step: BaseStep, result: Dict, step_index: int):\n        \"\"\"处理步骤执行成功\"\"\"\n        \n        self.context_manager.update(result)\n        self._update_step_progress(step, step_index, 100, \"执行完成\")\n\n    def _handle_step_failure(self, step: BaseStep, error: Exception):\n        \"\"\"处理步骤执行失败\"\"\"\n        error_msg = str(error)\n        log.error(f\"步骤 {step.name} 执行失败: {error_msg}\")\n        try:\n            # 重新从数据库加载任务对象\n            self.task = self.db.merge(self.task)\n            self.task.current_step = step.name\n            self.progress_tracker.update_error(error_msg)\n            self.db.commit()\n        except Exception as e:\n            self.db.rollback()\n            raise\n\n    def _handle_failure(self, error: Exception):\n        \"\"\"处理任务失败\"\"\"\n        task_id = self.task.taskId  # 预先保存taskId\n        try:\n            error_msg = str(error)\n            if not isinstance(error, TaskError):\n                error_msg = f\"任务执行异常: {error_msg}\"\n            \n            self.progress_tracker.update_error(error_msg)\n            self.context_manager.set('status', TaskStatus.FAILED.value)\n            self.context_manager.save()\n            self.db.commit()\n        except (sqlalchemy.orm.exc.ObjectDeletedError, sqlalchemy.exc.InvalidRequestError) as e:\n            # 任务已被删除，记录日志\n            log.warning(f\"Cannot update error status, task has been deleted: {task_id}\")\n            self.db.rollback()\n            raise  # 重新抛出异常以便上层处理\n\n    def _update_step_progress(self, step: BaseStep, step_index: int, \n                            progress: int, message: str):\n        \"\"\"更新步骤进度\"\"\"\n        self.progress_tracker.update_progress(\n            step_index=step_index,\n            step_name=step.name,\n            progress=progress,\n            message=f\"{message}\"\n        )\n\n    def _complete_task(self):\n        \"\"\"完成任务\"\"\"\n        try:\n            # 重新从数据库加载任务对象\n            self.task = self.db.merge(self.task)\n            self.db.refresh(self.task)\n            self.task.status = TaskStatus.COMPLETED.value\n            self.task.progress = TaskProgress.COMPLETED.value\n            self.context_manager.save()\n            self.db.commit()\n        except Exception as e:\n            self.db.rollback()\n            raise Exception(f\"更新任务状态失败: {str(e)}\")\n\n    def _get_start_step(self, is_retry: bool) -> int:\n        \"\"\"获取起始步骤\"\"\"\n        if not is_retry or not self.task.current_step:\n            return 0\n        try:\n            return [step.name for step in self.steps].index(self.task.current_step)\n        except ValueError:\n            return 0\n        \n    def _load_completed_step(self, step: BaseStep, step_index: int):\n        \"\"\"加载已完成的步骤\"\"\"\n        step_outputs = self._load_step_outputs(step)\n        self.context_manager.update(step_outputs)\n        \n        self.progress_tracker.update_progress(\n            step_index=step_index,\n            step_name=step.name,\n            progress=100,\n            message=f\"{step.name} 已完成\"\n        )\n\n    def _load_step_outputs(self, step: BaseStep) -> Dict:\n        \"\"\"加载已完成步骤的输出文件内容\n        \n        Args:\n            step: BaseStep对象\n            \n        Returns:\n            Dict: 包含步骤输出文件的字典\n        \"\"\"\n        result = {}\n        level = getattr(step, 'level', None)\n        check_dir = self.level_dirs.get(level, self.temp_dir) if level else self.temp_dir\n        \n        for output_file in step.output_files:\n            # 获取实际的文件名\n            filename = os.path.basename(output_file)\n            file_path = os.path.join(check_dir, filename)\n            \n            if os.path.exists(file_path):\n                # 如果文件存在，将其添加到结果中\n                result[output_file] = filename\n                \n                # 如果是JSON文件，读取内容并更新上下文\n                if filename.endswith('.json'):\n                    with open(file_path, 'r', encoding='utf-8') as f:\n                        content = json.load(f)\n                        if isinstance(content, dict):\n                            result.update(content)\n        \n        return result"}
{"type": "source_file", "path": "server/services/task/steps/fetch_content.py", "content": "from typing import Dict\nimport os\nimport json\n\nfrom services.task.utils.progress_tracker import ProgressTracker\nfrom services.task.steps.base import BaseStep\nfrom services.url_fetcher import fetch_url_content\nfrom services.task.utils.context import ContextManager\nfrom core.logging import log\n\nclass FetchContentStep(BaseStep):\n    def __init__(\n        self,\n        progress_tracker: ProgressTracker,\n        context_manager: ContextManager\n    ):\n        super().__init__(\n            name=\"获取页面内容\",\n            input_files=[],\n            output_files=[\"raw_content.txt\",\"raw_title\",\"raw_content\"],\n            progress_tracker=progress_tracker,\n            context_manager=context_manager\n        )\n        \n    def _execute(self, context_manager: ContextManager) -> Dict:\n        \"\"\"执行内容获取步骤\"\"\"\n        url = context_manager.get(\"url\")\n        if not url:\n            raise ValueError(\"缺少URL\")\n            \n        text_content, raw_title = fetch_url_content(url)\n        if not text_content or len(text_content) < 4:\n            raise ValueError(\"获取页面内容失败或内容太短\")\n            \n        # 保存原始内容到文件\n        task_id = context_manager.get(\"taskId\")\n        content_filename = \"raw_content.txt\"\n        content_path = os.path.join(self.context_manager.get(\"temp_dir\"), content_filename)\n        \n        with open(content_path, 'w', encoding='utf-8') as f:\n            f.write(text_content)\n            \n        return {\n            \"raw_content.txt\": content_filename,\n            \"raw_content\": text_content,\n            \"raw_title\": raw_title,\n        }"}
{"type": "source_file", "path": "server/services/task/steps/content.py", "content": "from typing import Dict\nimport os\nimport json\n\nfrom services.task.utils.progress_tracker import ProgressTracker\nfrom services.task.steps.base import BaseStep\nfrom services.task.utils.context import ContextManager\nfrom services.llm import LLMService\nfrom utils.prompt_utils import PromptUtils\nfrom core.logging import log\n\n\nclass ContentStep(BaseStep):\n    def __init__(\n        self,\n        level: str,\n        progress_tracker: ProgressTracker,\n        context_manager: ContextManager\n    ):\n        super().__init__(\n            name=f\"处理{level}难度内容\",\n            input_files=[\"raw_content.txt\", \"title\"],\n            output_files=[f\"{level}/content.txt\"],\n            progress_tracker=progress_tracker,\n            context_manager=context_manager\n        )\n        self.level = level\n        self.llm_service = LLMService()\n        \n    def _execute(self, context_manager: ContextManager) -> Dict:\n        \"\"\"执行内容处理步骤\"\"\"\n        level_dir = context_manager.get(\"level_dir\")\n        if not level_dir:\n            raise ValueError(f\"缺少{self.level}难度等级目录\")\n            \n        raw_content = context_manager.get(\"raw_content\")\n        title = context_manager.get(\"title\")\n        \n        if not raw_content:\n            raise ValueError(\"缺少原始内容\")\n        if not title:\n            raise ValueError(\"缺少标题\")\n            \n        # 根据难度等级处理内容\n        processed_content = self._process_content_by_level(raw_content)\n        \n        # 保存处理后的内容到文件\n        content_path = os.path.join(level_dir, \"content.txt\")\n        \n        with open(content_path, 'w', encoding='utf-8') as f:\n            f.write(processed_content)\n            \n        return {\n            f\"{self.level}/content.txt\": \"content.txt\"\n        }\n        \n    def _process_content_by_level(self, content: str) -> str:\n        \"\"\"根据难度等级处理内容\"\"\"\n        log.info(f\"开始处理{self.level}难度内容\")\n        try:\n            template_name = f\"content_processing_{self.level}\"\n            chat_prompt = PromptUtils.create_chat_prompt(template_name)\n            chain = chat_prompt | self.llm_service.llm\n            \n            response = chain.invoke({\n                \"content\": content,\n                \"level\": self.level,\n                \"style_params\": self.context_manager.get(\"style_params\", {})\n            })\n            \n            processed_content = response.content if hasattr(response, 'content') else str(response)\n            if not processed_content or not processed_content.strip():\n                raise ValueError(\"处理后的内容为空\")\n            \n            processed_content = processed_content.strip()\n            log.info(f\"成功处理{self.level}难度内容\")\n            return processed_content\n            \n        except Exception as e:\n            log.error(f\"处理{self.level}难度内容失败: {str(e)}\")\n            raise ValueError(f\"内容处理失败: {str(e)}\")\n"}
{"type": "source_file", "path": "server/services/task/steps/translation.py", "content": "from typing import Dict, List\nfrom .base import BaseStep\nfrom services.llm import LLMService\nfrom utils.prompt_utils import PromptUtils\nfrom langchain_core.output_parsers import JsonOutputParser\nfrom core.logging import log\nfrom services.task.utils.context import ContextManager\nfrom services.task.utils.progress_tracker import ProgressTracker\nimport os\nimport json\n\nclass TranslationStep(BaseStep):\n    def __init__(\n        self,\n        level: str,\n        progress_tracker: ProgressTracker,\n        context_manager: ContextManager\n    ):\n        super().__init__(\n            name=f\"翻译{level}对话内容\",\n            input_files=[f\"{level}/dialogue_en.json\"],\n            output_files=[f\"{level}/dialogue_cn.json\"],\n            progress_tracker=progress_tracker,\n            context_manager=context_manager\n        )\n        self.level = level\n        self.llm_service = LLMService()\n        \n    def _execute(self, context_manager: ContextManager) -> Dict:\n        \"\"\"执行翻译步骤\"\"\"\n        level_dir = context_manager.get(\"level_dir\")\n        if not level_dir:\n            raise ValueError(f\"缺少{self.level}难度等级目录\")\n            \n        dialogue_en_filename = context_manager.get(f\"{self.level}/dialogue_en.json\")\n        if not dialogue_en_filename:\n            raise ValueError(\"缺少英文对话内容\")\n        \n        # 从文件读取对话内容    \n        dialogue_path = os.path.join(level_dir, dialogue_en_filename)\n        \n        with open(dialogue_path, 'r', encoding='utf-8') as f:\n            dialogue = json.load(f)\n        \n        if not dialogue:\n            raise ValueError(\"对话内容为空\")\n            \n        translated_dialogue = self._translate_dialogue(dialogue)\n        \n        # 保存翻译结果到文件\n        dialogue_path = os.path.join(level_dir, \"dialogue_cn.json\")\n        \n        # 将翻译内容写入文件\n        with open(dialogue_path, 'w', encoding='utf-8') as f:\n            json.dump(translated_dialogue, f, ensure_ascii=False, indent=2)\n        \n        return {\n            f\"{self.level}/dialogue_cn.json\": \"dialogue_cn.json\"\n        }\n        \n    def _translate_dialogue(self, dialogue: List[Dict]) -> List[Dict]:\n        \"\"\"批量翻译对话内容\"\"\"\n        log.info(f\"开始翻译{self.level}难度对话内容\")\n        \n        # 根据难度等级选择不同的翻译提示模板\n        template_name = f\"dialogue_translation_{self.level}\"\n        chat_prompt = PromptUtils.create_chat_prompt(template_name)\n        chain = chat_prompt | self.llm_service.llm | JsonOutputParser()\n        \n        translated_dialogue = []\n        batch_size = 5\n        total = len(dialogue)\n        \n        for i in range(0, total, batch_size):\n            batch = dialogue[i:i+batch_size]\n            progress = int((i / total) * 100)\n            self.progress_tracker.update_progress(\n                step_index=int(self.context_manager.get('current_step_index', 0)),\n                step_name=self.name,\n                progress=progress,\n                message=f\"正在翻译第 {i+1} 到 {min(i+batch_size, total)} 条对话\"\n            )\n            \n            try:\n                batch_translated = chain.invoke({\n                    \"content\": batch,\n                    \"level\": self.level,\n                    \"style_params\": self.context_manager.get(\"style_params\", {})\n                })\n                translated_dialogue.extend(batch_translated)\n                log.info(f\"成功翻译批次,共 {len(batch_translated)} 条对话\")\n            except Exception as e:\n                log.error(f\"翻译批次失败: {str(e)}, 尝试逐条翻译\")\n                # 批次翻译失败时逐条翻译\n                for item in batch:\n                    try:\n                        single_translated = chain.invoke({\n                            \"content\": [item],\n                            \"level\": self.level,\n                            \"style_params\": self.context_manager.get(\"style_params\", {})\n                        })\n                        translated_dialogue.extend(single_translated)\n                    except Exception as e:\n                        log.error(f\"单条翻译失败: {str(e)}\")\n                        translated_dialogue.append({\n                            \"role\": item[\"role\"],\n                            \"content\": \"\"\n                        })\n                        \n        return translated_dialogue\n"}
{"type": "source_file", "path": "server/services/task/steps/audio_merge.py", "content": "from typing import Dict, List\nimport os\nfrom pydub import AudioSegment\nimport json\n\nfrom services.task.utils.context import ContextManager\nfrom .base import BaseStep\nfrom core.logging import log\nfrom services.task.utils.progress_tracker import ProgressTracker\nfrom services.file import FileService\n\nclass AudioMergeStep(BaseStep):\n    def __init__(\n        self,\n        level: str,\n        lang: str,\n        progress_tracker: ProgressTracker,\n        context_manager: ContextManager\n    ):\n        super().__init__(\n            name=f\"合并{level}-{lang}音频\",\n            input_files=[f\"{level}/audio_files_{lang}.json\"],\n            output_files=[f\"{level}/audio_{lang}.mp3\"],\n            progress_tracker=progress_tracker,\n            context_manager=context_manager\n        )\n        self.level = level\n        self.lang = lang\n        \n    def _execute(self, context_manager: ContextManager) -> Dict:\n        \"\"\"执行音频合并步骤\"\"\"\n        level_dir = context_manager.get(\"level_dir\")\n        if not level_dir:\n            raise ValueError(f\"缺少{self.level}难度等级目录\")\n\n        audio_files_key = f\"{self.level}/audio_files_{self.lang}.json\"\n        audio_files_filename = context_manager.get(audio_files_key)\n        if not audio_files_filename:\n            raise ValueError(f\"缺少{self.lang}音频文件\")\n            \n        # 从文件读取音频文件列表\n        audio_files_path = os.path.join(level_dir, audio_files_filename)\n        \n        with open(audio_files_path, 'r', encoding='utf-8') as f:\n            audio_files = json.load(f)\n            \n        if not audio_files:\n            raise ValueError(\"音频文件列表为空\")\n                \n        merged_file = self._merge_audio(audio_files, context_manager)\n        \n        # 更新files结构中对应语言的音频URL\n        self.progress_tracker.update_files(\n            level=self.level,\n            lang=self.lang,\n            file_type='audio'\n        )\n        \n        # 清理临时音频文件\n        self._cleanup_files(audio_files, context_manager)\n        # 清理context\n        context_manager.delete(audio_files_key)\n        \n        return {\n            f\"{self.level}/audio_{self.lang}.mp3\": merged_file\n        }\n        \n    def _merge_audio(self, audio_files: List[Dict], context_manager: ContextManager) -> str:\n        \"\"\"合并音频文件\"\"\"\n        log.info(f\"开始合并{self.lang}音频文件\")\n        \n        merged = AudioSegment.empty()\n        silence = AudioSegment.silent(duration=500)  # 0.5秒静音\n        \n        level_dir = context_manager.get(\"level_dir\")\n        if not level_dir:\n            raise ValueError(\"缺少level_dir\")\n            \n        # 合并音频\n        for audio_file in audio_files:\n            try:\n                audio_path = os.path.join(level_dir, audio_file[\"filename\"])\n                if not os.path.exists(audio_path):\n                    raise FileNotFoundError(f\"音频文件不存在: {audio_file['filename']}\")\n                \n                segment = AudioSegment.from_file(audio_path)\n                merged += segment + silence\n                \n            except Exception as e:\n                log.error(f\"合并音频文件失败: {str(e)}\")\n                raise ValueError(f\"音频文件 {audio_file['filename']} 处理失败: {str(e)}\")\n        \n        # 导出合并后的音频到字节流\n        audio_data = merged.export(format=\"mp3\").read()\n        \n        # 使用 FileService 写入文件\n        filename = FileService.write_file(\n            task_id=self.context_manager.get(\"taskId\"),\n            level=self.level,\n            lang=self.lang,\n            file_type='audio',\n            content=audio_data\n        )\n        \n        log.info(f\"音频合并完成: {filename}\")\n        return filename\n        \n    def _cleanup_files(self, audio_files: List[Dict], context_manager: ContextManager) -> None:\n        \"\"\"清理临时音频文件和JSON配置文件\"\"\"\n        level_dir = context_manager.get(\"level_dir\")\n        if not level_dir:\n            log.warning(\"缺少level_dir，跳过清理\")\n            return\n        \n        # 清理音频文件\n        for audio_file in audio_files:\n            try:\n                file_path = os.path.join(level_dir, audio_file[\"filename\"])\n                if os.path.exists(file_path):\n                    os.remove(file_path)\n                    log.info(f\"已删除临时文件: {file_path}\")\n            except Exception as e:\n                log.error(f\"删除临时文件失败: {str(e)}\")\n        \n        # 清理JSON配置文件\n        try:\n            json_file = f\"audio_files_{self.lang}.json\"\n            json_path = os.path.join(level_dir, json_file)\n            if os.path.exists(json_path):\n                os.remove(json_path)\n                log.info(f\"已删除配置文件: {json_path}\")\n        except Exception as e:\n            log.error(f\"删除配置文件失败: {str(e)}\")\n"}
{"type": "source_file", "path": "server/services/task/steps/audio.py", "content": "import json\nfrom typing import Dict, List\nimport os\nimport shutil\nfrom pydub import AudioSegment\nimport time\n\nfrom services.task.utils.context import ContextManager\nfrom utils.decorators import error_handler\nfrom .base import BaseStep\nfrom services.edgetts import EdgeTTSService\nfrom openai import OpenAI\nfrom core.config import settings\nfrom core.logging import log\nfrom services.task.utils.progress_tracker import ProgressTracker\n\nclass AudioStep(BaseStep):\n    def __init__(\n        self,\n        level: str,\n        lang: str,\n        progress_tracker: ProgressTracker,\n        context_manager: ContextManager\n    ):\n        super().__init__(\n            name=f\"生成{level}-{lang}音频\",\n            input_files=[f\"{level}/dialogue_{lang}.json\"],\n            output_files=[f\"{level}/audio_files_{lang}.json\"],\n            progress_tracker=progress_tracker,\n            context_manager=context_manager\n        )\n        self.level = level\n        self.lang = lang\n        self.edge_tts = EdgeTTSService()\n        self.openai_tts = OpenAI(\n            base_url=settings.TTS_BASE_URL,\n            api_key=settings.TTS_API_KEY\n        )\n        \n    def _verify_audio_file(self, file_path: str) -> bool:\n        \"\"\"验证音频文件是否有效\"\"\"\n        try:\n            if not os.path.exists(file_path):\n                return False\n                \n            file_size = os.path.getsize(file_path)\n            if file_size == 0:\n                return False\n                \n            audio_segment = AudioSegment.from_mp3(file_path)\n            if len(audio_segment) == 0:\n                return False\n                \n            return True\n        except Exception as e:\n            log.error(f\"音频文件验证失败: {str(e)}\")\n            return False\n    \n    def _generate_audio_with_retry(self, item: dict, file_path: str, anchor_type: str, max_retries: int = 3) -> bool:\n        \"\"\"生成音频文件，支持重试\"\"\"\n        for attempt in range(max_retries):\n            try:\n                if settings.USE_OPENAI_TTS_MODEL:\n                    audio_content = self._sync_openai_tts_request(item['content'], anchor_type)\n                    if audio_content is None:\n                        raise Exception(\"OpenAI TTS 返回空内容\")\n                    \n                    with open(file_path, 'wb') as f:\n                        f.write(audio_content)\n                else:\n                    temp_audio_file = self.edge_tts.generate_speech(item['content'], anchor_type)\n                    if not temp_audio_file or not os.path.exists(temp_audio_file):\n                        raise Exception(\"Edge TTS 生成失败\")\n                    \n                    shutil.move(temp_audio_file, file_path)\n                \n                # 验证生成的音频文件\n                if self._verify_audio_file(file_path):\n                    return True\n                    \n                log.warning(f\"音频文件验证失败，尝试重试 {attempt + 1}/{max_retries}\")\n                \n                # 如果验证失败，删除无效文件\n                if os.path.exists(file_path):\n                    os.remove(file_path)\n                    \n                # 添加短暂延迟后重试\n                if attempt < max_retries - 1:\n                    time.sleep(1 * (attempt + 1))\n                    \n            except Exception as e:\n                log.error(f\"音频生成失败 (尝试 {attempt + 1}/{max_retries}): {str(e)}\")\n                if attempt < max_retries - 1:\n                    time.sleep(1 * (attempt + 1))\n                continue\n                \n        return False\n    \n    def _execute(self, context_manager: ContextManager) -> Dict:\n        \"\"\"执行音频生成步骤\"\"\"\n        level_dir = context_manager.get(\"level_dir\")\n        if not level_dir:\n            raise ValueError(f\"缺少{self.level}难度等级目录\")\n            \n        dialogue_key = f\"{self.level}/dialogue_{self.lang}.json\"\n        dialogue_filename = context_manager.get(dialogue_key)\n        if not dialogue_filename:\n            raise ValueError(f\"缺少{self.lang}对话内容\")\n            \n        # 从文件读取对话内容\n        dialogue_path = os.path.join(level_dir, dialogue_filename)\n        \n        with open(dialogue_path, 'r', encoding='utf-8') as f:\n            dialogue = json.load(f)\n        \n        if not dialogue:\n            raise ValueError(\"对话内容为空\")\n            \n        step_index = int(context_manager.get('current_step_index', 0))\n        audio_files = []\n        total = len(dialogue)\n        \n        for i, item in enumerate(dialogue):\n            progress = int((i / total) * 100)\n            self.progress_tracker.update_progress(\n                step_index=step_index,\n                step_name=self.name,\n                progress=progress,\n                message=f\"正在合成第 {i+1}/{total} 条对话\"\n            )\n            \n            anchor_type = settings.ANCHOR_TYPE_MAP.get(\n                item['role']+f\"_{self.lang}\", \n                settings.ANCHOR_TYPE_MAP['default']\n            )\n\n            audio_filename = f\"{i:04d}_{self.lang}_{item['role']}.mp3\"\n            file_path = os.path.join(level_dir, audio_filename)\n            \n            if not self._generate_audio_with_retry(item, file_path, anchor_type):\n                raise Exception(f\"第 {i+1} 条{self.lang}对话音频生成失败，已重试最大次数:{item['content']}\")\n            \n            audio_files.append({\n                \"index\": i,\n                \"role\": item[\"role\"],\n                \"filename\": audio_filename\n            })\n        \n        # 保存音频文件列表\n        audio_files_filename = f\"audio_files_{self.lang}.json\"\n        audio_files_path = os.path.join(level_dir, audio_files_filename)\n        \n        with open(audio_files_path, 'w', encoding='utf-8') as f:\n            json.dump(audio_files, f, ensure_ascii=False, indent=2)\n            \n        return {\n            f\"{self.level}/audio_files_{self.lang}.json\": audio_files_filename\n        }\n\n    @error_handler\n    def _sync_openai_tts_request(self, text, anchor_type):\n        \"\"\"同步方式调用 OpenAI TTS\"\"\"\n        log.info(f\"正在使用OpenAI语音接口生成音频，文本: {text}, 角色: {anchor_type}\")\n        try:\n            response = self.openai_tts.audio.speech.create(\n                model=settings.TTS_MODEL,\n                voice=anchor_type,\n                input=text\n            )\n            return response.content\n        except Exception as e:\n            log.error(f\"音频生成失败: {str(e)}\")\n            return None"}
{"type": "source_file", "path": "server/services/task/task_service.py", "content": "import threading\nimport os\nimport shutil\nfrom models.task import Task\nfrom core.config import settings\nfrom db.session import SessionLocal, get_db\nfrom models.enums import TaskProgress, TaskStatus\nfrom services.task.utils.errors import TaskError\nfrom utils.time_utils import TimeUtil\nfrom services.task.processor import TaskProcessor\nfrom utils.decorators import error_handler\nfrom core.logging import log\nimport sqlalchemy.orm.exc\nimport sqlalchemy.exc\nfrom sqlalchemy.orm import Session\nimport time\n\n@error_handler\ndef execute_task(task_id: str, is_retry: bool = False, db_session = None):\n    \"\"\"执行任务的入口函数\n    \n    Args:\n        task_id: 任务ID\n        is_retry: 是否为重试执行\n        db_session: 可选的数据库会话，用于测试环境\n    \"\"\"\n    MAX_RETRIES = 1  # 最大重试次数\n    RETRY_DELAY = 5  # 重试等待时间(秒)\n    \n    log.info(f\"Starting task execution: task_id={task_id}, is_retry={is_retry}\")\n    \n    if db_session:\n        db = db_session\n        should_close = False\n    else:\n        db = next(get_db())\n        should_close = True\n    \n    retry_count = 0\n    temp_dir = os.path.join(settings.TASK_DIR, task_id)\n        \n    try:\n        while retry_count <= MAX_RETRIES:\n            try:\n                # 在会话中获取任务对象\n                task = db.query(Task).filter(Task.taskId == task_id).first()\n                if not task:\n                    log.error(f\"Task not found in execute_task: {task_id}\")\n                    return\n\n                # 如果是重试，重置任务状态和清理临时文件\n                if retry_count > 0:\n                    log.info(f\"Retrying task {task_id} (attempt {retry_count}/{MAX_RETRIES})\")\n                    # 清理临时文件\n                    if os.path.exists(temp_dir):\n                        shutil.rmtree(temp_dir)\n                    os.makedirs(temp_dir, exist_ok=True)\n                    \n                    # 重置任务状态\n                    task.current_step = None\n                    task.current_step_index = 0\n                    task.step_progress = 0\n                    task.files = {}\n                    task.progress_message = f\"第{retry_count}次重试任务\"\n                \n                # 更新任务状态\n                task.status = TaskStatus.PROCESSING.value\n                task.progress = TaskProgress.PROCESSING.value\n                task.error = None\n                db.commit()\n                db.refresh(task)\n                \n                log.info(f\"Task found, current status: {task.status}, progress: {task.progress}\")\n                future = TaskProcessor.process_task_async(task, db, is_retry)\n                future.result()  # 等待任务完成\n                log.info(f\"Task processing completed successfully: {task_id}\")\n                return  # 任务成功完成，直接返回\n                \n            except TaskError as e:\n                retry_count += 1\n                if retry_count <= MAX_RETRIES:\n                    log.warning(f\"Task failed, will retry: {task_id}, error: {str(e)}\")\n                    time.sleep(RETRY_DELAY)\n                    continue\n                    \n                log.error(f\"Task failed after {MAX_RETRIES} retries: {task_id}\")\n                raise  # 重试次数用完，重新抛出异常\n                \n            except (sqlalchemy.orm.exc.ObjectDeletedError, sqlalchemy.exc.InvalidRequestError) as e:\n                # 任务已被删除，记录日志并优雅退出\n                log.warning(f\"Task has been deleted during processing: {task_id}, error: {str(e)}\")\n                return\n                \n            except Exception as e:\n                # 记录详细错误信息\n                log.error(f\"Error processing task: {task_id}, error: {str(e)}\")\n                if hasattr(e, '__traceback__'):\n                    import traceback\n                    log.error(f\"Traceback:\\n{''.join(traceback.format_tb(e.__traceback__))}\")\n                raise\n                \n    finally:\n        if should_close and db:\n            try:\n                db.close()\n                log.info(f\"Task execution finished, database session closed: {task_id}\")\n            except Exception as e:\n                log.warning(f\"Error closing database session: {str(e)}\")\n\nclass TaskService:\n    @staticmethod\n    def retry_task(task: Task):\n        \"\"\"重试失败的任务\"\"\"\n        threading.Thread(target=execute_task, args=(task.taskId, True)).start()\n\n    @staticmethod\n    def start_processing(task: Task):\n        \"\"\"启动任务处理线程\"\"\"\n        task_id = task.taskId  # 保存taskId\n        db = SessionLocal()\n        \n        try:\n            # 在当前会话中获取新的任务对象\n            current_task = db.query(Task).filter(Task.taskId == task_id).first()\n            if not current_task:\n                log.error(f\"Task not found in start_processing: {task_id}\")\n                raise Exception(f\"Task not found: {task_id}\")\n            \n            # 检查任务状态\n            if current_task.status not in [TaskStatus.PENDING.value, TaskStatus.FAILED.value]:\n                log.warning(f\"Task is not in a valid state for processing: {task_id}, current status: {current_task.status}\")\n                return\n                \n            # 更新任务状态\n            current_task.status = TaskStatus.PROCESSING.value\n            current_task.progress = TaskProgress.PROCESSING.value\n            current_task.progress_message = \"任务开始处理\"\n            current_task.error = None  # 清除之前的错误信息\n            db.commit()\n            \n            # 使用线程池处理任务\n            log.info(f\"Starting task processing: {task_id}\")\n            future = TaskProcessor.process_task_async(current_task, db, False)\n            log.info(f\"Task processing started: {task_id}\")\n            \n        except Exception as e:\n            if db:\n                db.rollback()\n            log.error(f\"Failed to start task processing: {str(e)}\")\n            if hasattr(e, '__traceback__'):\n                import traceback\n                log.error(f\"Traceback:\\n{''.join(traceback.format_tb(e.__traceback__))}\")\n            raise\n        finally:\n            if db:\n                db.close()\n                log.info(f\"Task processing start finished, database session closed: {task_id}\")\n\n    @staticmethod\n    def check_incomplete_tasks(db):\n        \"\"\"检查未完成的任务并清理文件\"\"\"\n        try:\n            # 1. 将所有未完成任务标记为失败\n            incomplete_tasks = (\n                db.query(Task)\n                .filter(Task.status.in_(['pending', 'processing']))\n                .all()\n            )\n            \n            for task in incomplete_tasks:\n                db.refresh(task)  # 刷新任务对象\n                task.status = TaskStatus.FAILED.value\n                task.progress = TaskProgress.FAILED.value\n                task.progress_message = \"应用重启时任务未完成\"\n                task.updatedAt = TimeUtil.now_ms()\n            \n            db.commit()\n        except Exception as e:\n            db.rollback()\n            raise Exception(f\"更新未完成任务状态失败: {str(e)}\")\n\n    @classmethod\n    def start_processing_with_task(cls, task: Task, db: Session):\n        \"\"\"使用已有任务对象启动处理\"\"\"\n        try:\n            # 检查任务状态\n            if task.status not in [TaskStatus.PENDING.value, TaskStatus.FAILED.value]:\n                log.warning(f\"Task is not in a valid state for processing: {task.taskId}, current status: {task.status}\")\n                return\n                \n            # 更新任务状态\n            task.status = TaskStatus.PROCESSING.value\n            task.progress = TaskProgress.PROCESSING.value\n            task.progress_message = \"任务开始处理\"\n            task.error = None\n            db.commit()\n            \n            # 确保任务目录存在\n            task_dir = os.path.join(settings.TASK_DIR, task.taskId)\n            os.makedirs(task_dir, exist_ok=True)\n            \n            # 使用线程池处理任务\n            log.info(f\"Starting task processing: {task.taskId}\")\n            future = TaskProcessor.process_task_async(task, db, False)\n            log.info(f\"Task processing started: {task.taskId}\")\n            \n        except Exception as e:\n            db.rollback()\n            log.error(f\"Failed to start task processing: {str(e)}\")\n            if hasattr(e, '__traceback__'):\n                import traceback\n                log.error(f\"Traceback:\\n{''.join(traceback.format_tb(e.__traceback__))}\")\n            raise\n"}
{"type": "source_file", "path": "server/services/task/steps/subtitle.py", "content": "import json\nfrom typing import Dict, List\nfrom .base import BaseStep\nfrom services.task.utils.context import ContextManager\nimport os\nfrom services.task.utils.progress_tracker import ProgressTracker\nfrom pydub import AudioSegment\nfrom services.file import FileService\n\nclass SubtitleStep(BaseStep):\n    def __init__(\n        self,\n        level: str,\n        lang: str,\n        progress_tracker: ProgressTracker,\n        context_manager: ContextManager\n    ):\n        super().__init__(\n            name=f\"生成{level}-{lang}字幕\",\n            input_files=[\n                f\"{level}/dialogue_en.json\",\n                f\"{level}/dialogue_cn.json\",\n                f\"{level}/audio_files_{lang}.json\"\n            ],\n            output_files=[f\"{level}/subtitle_{lang}.srt\"],\n            progress_tracker=progress_tracker,\n            context_manager=context_manager\n        )\n        self.level = level\n        self.lang = lang\n        \n    def _execute(self, context_manager: ContextManager) -> Dict:\n        \"\"\"执行字幕生成步骤\"\"\"\n        dialogue_cn_filename = context_manager.get(f\"{self.level}/dialogue_cn.json\")\n        dialogue_en_filename = context_manager.get(f\"{self.level}/dialogue_en.json\")\n        audio_files_filename = context_manager.get(f\"{self.level}/audio_files_{self.lang}.json\")\n        \n        if not all([dialogue_cn_filename, dialogue_en_filename, audio_files_filename]):\n            raise ValueError(f\"缺少生成{self.lang}字幕所需的文件\")\n            \n        # 从文件读取内容\n        level_dir = context_manager.get(\"level_dir\")\n        if not level_dir:\n            raise ValueError(f\"缺少{self.level}难度等级目录\")\n            \n        # 读取中文对话\n        dialogue_cn_path = os.path.join(level_dir, dialogue_cn_filename)\n        if not os.path.exists(dialogue_cn_path):\n            raise FileNotFoundError(f\"找不到中文对话文件: {dialogue_cn_path}\")\n        with open(dialogue_cn_path, 'r', encoding='utf-8') as f:\n            dialogue_cn = json.load(f)\n            \n        # 读取英文对话    \n        dialogue_en_path = os.path.join(level_dir, dialogue_en_filename)\n        if not os.path.exists(dialogue_en_path):\n            raise FileNotFoundError(f\"找不到英文对话文件: {dialogue_en_path}\")\n        with open(dialogue_en_path, 'r', encoding='utf-8') as f:\n            dialogue_en = json.load(f)\n            \n        # 读取音频文件列表\n        audio_files_path = os.path.join(level_dir, audio_files_filename)\n        if not os.path.exists(audio_files_path):\n            raise FileNotFoundError(f\"找不到音频文件列表: {audio_files_path}\")\n        with open(audio_files_path, 'r', encoding='utf-8') as f:\n            audio_files = json.load(f)\n        \n        if not all([dialogue_cn, dialogue_en, audio_files]):\n            raise ValueError(\"读取文件内容为空\")\n                \n        subtitle_content = self._generate_subtitles(\n            dialogue_cn,\n            dialogue_en,\n            audio_files\n        )\n        \n        # 使用 FileService 写入字幕文件\n        srt_filename = FileService.write_file(\n            task_id=context_manager.get(\"taskId\"),\n            level=self.level,\n            lang=self.lang,\n            file_type='subtitle',\n            content='\\n'.join(subtitle_content)\n        )\n        \n        # 更新files结构中对应语言的字幕URL\n        self.progress_tracker.update_files(\n            level=self.level,\n            lang=self.lang,\n            file_type='subtitle'\n        )\n        \n        return {\n            f\"{self.level}/subtitle_{self.lang}.srt\": srt_filename\n        }\n        \n    def _generate_subtitles(\n        self,\n        dialogue_cn: List[Dict],\n        dialogue_en: List[Dict],\n        audio_files: List[Dict]\n    ) -> List[str]:\n        \"\"\"生成双语字幕内容\"\"\"\n        # 打印长度信息以便调试\n        print(f\"对话长度检查 - 中文: {len(dialogue_cn)}, 英文: {len(dialogue_en)}, 音频: {len(audio_files)}\")\n        \n        subtitles = []\n        current_time = 0\n        silence_duration = 0.5\n        \n        for i, audio in enumerate(audio_files):\n            try:\n                # 安全地获取对话内容\n                primary_content = dialogue_cn[i][\"content\"] if i < len(dialogue_cn) else \"【缺失中文内容】\"\n                secondary_content = dialogue_en[i][\"content\"] if i < len(dialogue_en) else \"【Missing English content】\"\n                \n                # 从临时文件夹读取音频文件\n                audio_path = os.path.join(self.context_manager.get(\"level_dir\"), audio[\"filename\"])\n                if not os.path.exists(audio_path):\n                    raise ValueError(f\"音频文件不存在: {audio_path}\")\n                \n                # 添加文件大小检查\n                file_size = os.path.getsize(audio_path)\n                if file_size == 0:\n                    raise ValueError(f\"音频文件大小为0: {audio_path}\")\n                \n                try:\n                    # 直接使用 pydub 尝试加载文件\n                    audio_segment = AudioSegment.from_mp3(audio_path)\n                    if len(audio_segment) == 0:\n                        raise ValueError(f\"音频文件长度为0: {audio_path}\")\n                except Exception as e:\n                    raise ValueError(f\"音频文件读取失败: {audio_path}, 错误: {str(e)}\")\n                \n                # 计算音频时长\n                duration = len(audio_segment) / 1000.0  # 转换为秒\n                audio_end_time = current_time + duration\n                \n                # 字幕结束时间延续到下一段开始\n                subtitle_end_time = audio_end_time + silence_duration\n                \n                subtitle = self._format_subtitle(\n                    i,\n                    current_time,\n                    subtitle_end_time,\n                    primary_content,\n                    secondary_content\n                )\n                subtitles.append(subtitle)\n                \n                current_time = audio_end_time + silence_duration\n                \n            except Exception as e:\n                print(f\"处理第 {i+1} 条字幕时出错: {str(e)}\")\n                print(f\"当前索引: {i}\")\n                print(f\"中文对话长度: {len(dialogue_cn)}\")\n                print(f\"英文对话长度: {len(dialogue_en)}\")\n                print(f\"音频文件长度: {len(audio_files)}\")\n                raise\n        \n        return subtitles\n        \n    def _format_subtitle(\n        self,\n        index: int,\n        start: float,\n        end: float,\n        primary_content: str,\n        secondary_content: str\n    ) -> str:\n        \"\"\"格式化字幕\n        Args:\n            index: 字幕序号\n            start: 开始时间（秒）\n            end: 结束时间（秒）\n            primary_content: 主要语言内容（中文）\n            secondary_content: 次要语言内容（英文）\n        Returns:\n            格式化后的字幕文本\n        \"\"\"\n        return (\n            f\"{index + 1}\\n\"\n            f\"{self._format_timestamp(start)} --> {self._format_timestamp(end)}\\n\"\n            f\"{primary_content}\\n{secondary_content}\\n\"\n        )\n        \n    def _format_timestamp(self, seconds: float) -> str:\n        \"\"\"格式化时间戳\"\"\"\n        hours = int(seconds // 3600)\n        minutes = int((seconds % 3600) // 60)\n        secs = seconds % 60\n        msecs = int((secs - int(secs)) * 1000)\n        return f\"{hours:02d}:{minutes:02d}:{int(secs):02d},{msecs:03d}\"\n"}
{"type": "source_file", "path": "server/services/task/steps/base.py", "content": "from abc import ABC, abstractmethod\nfrom typing import List, Dict, Optional\n\nfrom ..utils.context import ContextManager\nfrom ..utils.errors import StepInputError, StepOutputError\nfrom ..utils.progress_tracker import ProgressTracker\nfrom core.logging import log\n\nclass BaseStep(ABC):\n    def __init__(\n        self,\n        name: str,\n        input_files: List[str],\n        output_files: List[str],\n        progress_tracker: Optional[ProgressTracker],\n        context_manager: ContextManager\n    ):\n        self.name = name\n        self.input_files = input_files\n        self.output_files = output_files\n        self.progress_tracker = progress_tracker\n        self.context_manager = context_manager\n        \n    def execute(self) -> Dict:\n        \"\"\"执行步骤\"\"\"\n        # 验证输入\n        missing_inputs = self._validate_inputs(self.context_manager)\n        if missing_inputs:\n            raise StepInputError(self.name, missing_inputs)\n            \n        # 执行步骤\n        result = self._execute(self.context_manager)\n        log.info(f\"步骤 {self.name} 执行结果: {result}\")\n        \n        # 验证输出\n        if not self._validate_outputs(result):\n            raise StepOutputError(self.name, f\"步骤输出不完整，当前输出: {result}\")\n            \n        return result\n        \n    def _validate_inputs(self, context_manager: ContextManager) -> List[str]:\n        \"\"\"验证输入数据\"\"\"\n        return context_manager.validate_keys(self.input_files)\n        \n    def _validate_outputs(self, result: Dict) -> bool:\n        \"\"\"验证步骤输出\"\"\"\n        if not isinstance(result, dict):\n            log.error(f\"步骤 {self.name} 输出类型错误: 期望 dict, 实际是 {type(result)}\")\n            return False\n        \n        missing_outputs = []\n        for output_file in self.output_files:\n            if output_file not in result:\n                missing_outputs.append(output_file)\n        \n        if missing_outputs:\n            log.error(f\"步骤 {self.name} 输出不完整，缺少以下文件: {missing_outputs}\")\n            return False\n        \n        return True\n    \n    @abstractmethod\n    def _execute(self, context_manager: ContextManager) -> Dict:\n        \"\"\"具体步骤实现\"\"\"\n        pass\n"}
{"type": "source_file", "path": "server/services/task/steps/dialogue.py", "content": "import json\nimport os\nfrom typing import Dict, List\n\nfrom services.task.utils.context import ContextManager\nfrom .base import BaseStep\nfrom services.llm import LLMService\nfrom core.logging import log\nfrom services.task.utils.progress_tracker import ProgressTracker\nfrom utils.prompt_utils import PromptUtils\nfrom langchain_core.output_parsers import JsonOutputParser\n\nclass DialogueStep(BaseStep):\n    def __init__(\n        self,\n        level: str,\n        progress_tracker: ProgressTracker,\n        context_manager: ContextManager\n    ):\n        super().__init__(\n            name=f\"生成{level}对话内容\",\n            input_files=[f\"{level}/content.txt\"],\n            output_files=[f\"{level}/dialogue_en.json\"],\n            progress_tracker=progress_tracker,\n            context_manager=context_manager\n        )\n        self.level = level\n        self.llm_service = LLMService()\n        context_manager.set(\"current_level\", level)  # 添加这行，确保当前level被设置\n        \n    def _execute(self, context_manager: ContextManager) -> Dict:\n        \"\"\"执行对话生成步骤\"\"\"\n        try:\n            level_dir = context_manager.get(\"level_dir\")\n            log.info(f\"获取到level_dir: {level_dir}\")\n            \n            if not level_dir:\n                raise ValueError(f\"缺少{self.level}难度等级目录\")\n            \n            content_filename = context_manager.get(f\"{self.level}/content.txt\")\n            log.info(f\"获取到content_filename: {content_filename}\")\n            \n            if not content_filename:\n                raise ValueError(\"缺少页面内容\")\n            \n            # 从文件读取内容    \n            content_path = os.path.join(level_dir, content_filename)\n            \n            text_content = open(content_path, 'r', encoding='utf-8').read()\n            \n            if not text_content:\n                raise ValueError(\"页面内容为空\")\n            \n            # 获取风格参数\n            style_params = context_manager.get(\"style_params\", {})\n            \n            log.info(f\"开始生成{self.level}难度对话内容\")\n            dialogue = self.generate_dialogue(\n                text_content,\n                level=self.level,\n                style_params=style_params\n            )\n            \n            # 添加输出验证\n            if not dialogue:\n                raise ValueError(\"生成的对话内容为空\")\n            \n            # 验证对话格式\n            if not isinstance(dialogue, list):\n                raise ValueError(f\"对话格式错误：期望列表格式，实际得到 {type(dialogue)}\")\n            \n            # 验证对话长度\n            if len(dialogue) < 2:  # 至少需要两轮对话\n                raise ValueError(f\"对话长度不足：只有 {len(dialogue)} 轮对话\")\n            \n            # 保存对话内容到文件\n            dialogue_path = os.path.join(level_dir, \"dialogue_en.json\")\n            log.info(f\"构造对话文件路径: {dialogue_path}\")\n            \n            with open(dialogue_path, 'w', encoding='utf-8') as f:\n                json.dump(dialogue, f, ensure_ascii=False, indent=2)\n            \n            # 修改结果构造部分\n            result = {\n                f\"{self.level}/dialogue_en.json\": \"dialogue_en.json\"\n            }\n            \n            log.info(f\"返回结果: {result}\")\n            \n            # 验证返回值完整性\n            if not all(result.values()):\n                log.error(f\"返回结果验证失败: {result}\")\n                raise ValueError(\"返回结果不完整\")\n            \n            # 验证输出文件是否存在\n            output_path = os.path.join(level_dir, dialogue_path)\n            if not os.path.exists(output_path):\n                log.error(f\"输出文件不存在: {output_path}\")\n                raise ValueError(f\"输出文件不存在: {output_path}\")\n            \n            return result\n            \n        except Exception as e:\n            log.error(f\"对话生成步骤执行失败: {str(e)}\")\n            raise\n        \n    def generate_dialogue(self, text_content: str, level: str, style_params: Dict = None) -> List[Dict]:\n        \"\"\"生成对话内容\n        \n        Args:\n            text_content: 原始文本内容\n            level: 难度等级 (elementary/intermediate/advanced)\n            style_params: 风格参数，可包含：\n                - length: 对话长度 (short/medium/long)\n                - tone: 语气风格 (formal/casual/humorous)\n                - emotion: 情感色彩 (neutral/positive/negative)\n                - professionalism: 专业程度 (basic/moderate/expert)\n        \"\"\"\n        try:\n            # 根据难度等级选择不同的提示模板\n            template_name = f\"dialogue_generation_{level}\"\n            chat_prompt = PromptUtils.create_chat_prompt(template_name)\n            chain = chat_prompt | self.llm_service.llm | JsonOutputParser()\n            \n            # 添加进度更新\n            current_step_index = self.context_manager.get('current_step_index', 0)\n            self.progress_tracker.update_progress(\n                step_index=current_step_index,\n                step_name=self.name,\n                progress=30,\n                message=\"正在生成对话内容...\"\n            )\n            \n            # 准备输入参数\n            inputs = {\n                \"text_content\": text_content[:2000],  # 限制输入长度\n                \"level\": level,\n                \"style_params\": style_params or {}\n            }\n            \n            # 多次重试\n            max_retries = 3\n            last_error = None\n            \n            for attempt in range(max_retries):\n                try:\n                    result = chain.invoke(inputs)\n                    \n                    # 添加更详细的验证\n                    if not result:\n                        raise ValueError(\"对话生成结果为空\")\n                        \n                    if not isinstance(result, list):\n                        raise ValueError(f\"对话生成结果格式错误：期望列表格式，实际得到 {type(result)}\")\n                        \n                    # 验证每个对话项\n                    for i, item in enumerate(result):\n                        if not isinstance(item, dict):\n                            raise ValueError(f\"对话项 {i} 格式错误：期望字典格式，实际得到 {type(item)}\")\n                            \n                        if \"role\" not in item:\n                            raise ValueError(f\"对话项 {i} 缺少 'role' 字段\")\n                            \n                        if \"content\" not in item:\n                            raise ValueError(f\"对话项 {i} 缺少 'content' 字段\")\n                            \n                        if not item[\"role\"] in [\"host\", \"guest\"]:\n                            raise ValueError(f\"对话项 {i} 的 'role' 值无效：{item['role']}\")\n                            \n                        if not isinstance(item[\"content\"], str) or not item[\"content\"].strip():\n                            raise ValueError(f\"对话项 {i} 的 'content' 为空或格式错误\")\n                            \n                    # 更新进度\n                    self.progress_tracker.update_progress(\n                        step_index=current_step_index,\n                        step_name=self.name,\n                        progress=90,\n                        message=\"对话生成完成\"\n                    )\n                    \n                    return result\n                    \n                except Exception as e:\n                    last_error = e\n                    log.warning(f\"对话生成第{attempt + 1}次尝试失败: {str(e)}\")\n                    if attempt < max_retries - 1:\n                        # 更新进度\n                        self.progress_tracker.update_progress(\n                            step_index=current_step_index,\n                            step_name=self.name,\n                            progress=30 + attempt * 20,\n                            message=f\"对话生成重试中({attempt + 1}/{max_retries})...\"\n                        )\n                    continue\n                    \n            # 所有重试都失败了\n            error_msg = f\"对话生成失败({max_retries}次尝试): {str(last_error)}\"\n            log.error(error_msg)\n            raise Exception(error_msg)\n            \n        except Exception as e:\n            log.error(f\"对话生成发生错误: {str(e)}\")\n            raise Exception(f\"对话生成失败: {str(e)}\")"}
{"type": "source_file", "path": "server/services/rss/feed_manager.py", "content": "import feedparser\nimport asyncio\nimport time\nimport uuid\nfrom datetime import datetime\nimport zoneinfo\nfrom typing import List, Optional\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import desc, select, extract\nfrom sqlalchemy.orm import Session, attributes\nfrom sqlalchemy import desc\nfrom models.rss import RSSFeed, RSSEntry\nfrom models.task import Task\nfrom models.enums import TaskStatus, TaskProgress\nfrom core.config import settings\nfrom services.task.processor import TaskProcessor\nfrom core.logging import log\nfrom utils.time_utils import TimeUtil\nfrom db.session import SessionLocal\nimport logging\nimport aiohttp\nimport threading\n\nlogger = logging.getLogger(__name__)\n\nclass FeedManager:\n    def __init__(self, db: Session, task_processor: TaskProcessor):\n        self.db = db\n        self.task_processor = task_processor\n        self.timezone = zoneinfo.ZoneInfo(settings.TIMEZONE)\n        \n    async def fetch_feed(self, feed: RSSFeed) -> None:\n        \"\"\"获取并处理RSS源的内容\n        \n        Args:\n            feed: RSS源对象\n            \n        Raises:\n            Exception: 当获取或处理RSS内容出错时抛出\n        \"\"\"\n        try:\n            # 异步获取RSS内容\n            async with aiohttp.ClientSession() as session:\n                async with session.get(feed.url) as response:\n                    content = await response.text()\n                    parsed = feedparser.parse(content)\n            \n            # 检查状态码（如果存在）\n            status = getattr(parsed, 'status', 200)\n            if isinstance(status, int) and status >= 400:\n                raise Exception(f\"获取RSS内容失败: HTTP {status}\")\n            \n            # 更新feed信息\n            is_initial_fetch = feed.last_fetch is None\n            current_time = TimeUtil.now_ms()\n            feed.last_fetch = current_time\n            feed.error_count = 0\n            \n            # 处理条目，按发布时间倒序排序\n            entries = sorted(\n                parsed.entries,\n                key=lambda x: x.get('published_parsed', 0),\n                reverse=True\n            )\n            \n            # 根据是否首次抓取决定处理的条目数量\n            max_entries = (\n                feed.initial_entries_count if is_initial_fetch\n                else feed.update_entries_count\n            )\n            \n            # 提取所有条目的guid进行批量查重\n            entry_guids = []\n            entry_data = []\n            \n            for entry in entries[:max_entries]:\n                guid = entry.get('id') or entry.get('link')\n                if not guid:\n                    log.warning(f\"跳过无效条目: 缺少guid, feed={feed.url}\")\n                    continue\n                entry_guids.append(guid)\n                entry_data.append(entry)\n            \n            if not entry_guids:\n                log.info(f\"没有找到有效的RSS条目: {feed.url}\")\n                self.db.commit()\n                return\n                \n            # 批量查询已存在的guid，同时考虑user_id\n            stmt = (\n                select(RSSEntry.guid)\n                .where(\n                    RSSEntry.guid.in_(entry_guids),\n                    RSSEntry.user_id == feed.user_id\n                )\n            )\n            existing_guids = set(row[0] for row in self.db.execute(stmt).fetchall())\n            \n            # 批量处理新条目\n            new_entries = []\n            new_tasks = []\n            \n            for entry in entry_data:\n                guid = entry.get('id') or entry.get('link')\n                \n                # 跳过已存在的条目\n                if guid in existing_guids:\n                    log.debug(f\"跳过已存在的条目: {guid}\")\n                    continue\n                \n                # 处理发布时间\n                published = self._parse_entry_time(entry) or current_time\n                \n                try:\n                    # 创建RSS条目记录\n                    new_entry = RSSEntry(\n                        feed_id=feed.id,\n                        guid=guid,\n                        title=entry.get('title'),\n                        link=entry.get('link'),\n                        published=published,\n                        user_id=feed.user_id\n                    )\n                    new_entries.append(new_entry)\n                    \n                    # 创建播客任务\n                    task = Task(\n                        taskId=str(uuid.uuid4()),\n                        url=entry.get('link'),\n                        title=entry.get('title'),\n                        user_id=feed.user_id,\n                        is_public=True,\n                        created_by=feed.user_id,\n                        status=TaskStatus.PENDING.value,\n                        progress=TaskProgress.WAITING.value\n                    )\n                    new_tasks.append(task)\n                except Exception as e:\n                    log.error(f\"创建条目或任务失败: {str(e)}, guid={guid}\")\n                    continue\n            \n            if new_entries:\n                try:\n                    # 1. 保存条目和任务\n                    self.db.add_all(new_entries)\n                    self.db.add_all(new_tasks)\n                    self.db.flush()\n                    \n                    # 2. 更新关联关系\n                    for entry, task in zip(new_entries, new_tasks):\n                        entry.task_id = task.taskId\n                    \n                    # 3. 提交事务\n                    self.db.commit()\n                    \n                    # 4. 启动任务处理 - 使用execute_task\n                    from services.task.task_service import execute_task\n                    for task in new_tasks:\n                        # 只传递task_id，让execute_task自己创建新的数据库会话\n                        threading.Thread(\n                            target=execute_task,\n                            args=(task.taskId, False)\n                        ).start()\n                    \n                    log.info(f\"成功处理RSS源 {feed.url}: 添加了 {len(new_entries)} 个新条目\")\n                except Exception as e:\n                    log.error(f\"保存新条目时出错: {str(e)}\")\n                    self.db.rollback()\n                    raise\n            else:\n                log.info(f\"RSS源 {feed.url} 没有新的条目需要处理\")\n                self.db.commit()\n            \n        except Exception as e:\n            log.error(f\"处理RSS源出错: {feed.url}, error={str(e)}\")\n            raise\n            \n    def _parse_entry_time(self, entry) -> int:\n        \"\"\"解析RSS条目的发布时间\n        \n        Args:\n            entry: RSS条目数据\n            \n        Returns:\n            毫秒时间戳，如果解析失败返回当前时间戳\n        \"\"\"\n        try:\n            published_parsed = entry.get('published_parsed')\n            if published_parsed:\n                return int(time.mktime(published_parsed) * 1000)  # 转换为毫秒时间戳\n            return TimeUtil.now_ms()\n        except Exception as e:\n            log.warning(f\"解析发布时间失败: {str(e)}\")\n            return TimeUtil.now_ms()\n            \n    async def process_all_feeds(self) -> None:\n        \"\"\"处理所有需要更新的RSS源\"\"\"\n        try:\n            # 获取所有需要更新的活跃RSS源\n            current_time = TimeUtil.now_ms()\n            feeds = (\n                self.db.query(RSSFeed)\n                .filter(RSSFeed.is_active == True)\n                .filter(\n                    (RSSFeed.last_fetch.is_(None)) |\n                    (current_time > RSSFeed.last_fetch + RSSFeed.fetch_interval * 1000)  # 转换为毫秒\n                )\n                .all()\n            )\n            \n            if not feeds:\n                logger.info(\"没有需要更新的RSS源\")\n                return\n                \n            # 限制并发数量，避免系统负载过高\n            chunk_size = 5  # 每批处理5个feeds\n            for i in range(0, len(feeds), chunk_size):\n                chunk = feeds[i:i + chunk_size]\n                tasks = [self.fetch_feed(feed) for feed in chunk]\n                await asyncio.gather(*tasks)\n                \n                # 在每批处理之间稍作暂停，避免过度占用资源\n                if i + chunk_size < len(feeds):\n                    await asyncio.sleep(1)\n                    \n            logger.info(f\"完成所有RSS源的处理，共处理 {len(feeds)} 个源\")\n                \n        except Exception as e:\n            logger.error(f\"批量处理RSS源时出错: {str(e)}\")\n            raise\n"}
{"type": "source_file", "path": "server/services/task/steps/generate_title.py", "content": "from typing import Dict\nimport os\nimport json\n\nfrom services.task.utils.progress_tracker import ProgressTracker\nfrom services.task.steps.base import BaseStep\nfrom services.task.utils.context import ContextManager\nfrom services.llm import LLMService\nfrom utils.prompt_utils import PromptUtils\nfrom core.logging import log\n\nclass GenerateTitleStep(BaseStep):\n    def __init__(\n        self,\n        progress_tracker: ProgressTracker,\n        context_manager: ContextManager\n    ):\n        super().__init__(\n            name=\"生成标题\",\n            input_files=[\"raw_content\"],\n            output_files=[\"title\"],\n            progress_tracker=progress_tracker,\n            context_manager=context_manager\n        )\n        self.llm_service = LLMService()\n        \n    def _execute(self, context_manager: ContextManager) -> Dict:\n        \"\"\"执行标题生成步骤\"\"\"\n        raw_title = context_manager.get(\"raw_title\")\n        raw_content = context_manager.get(\"raw_content\")\n        if not raw_content:\n            raise ValueError(\"缺少原始内容\")\n            \n        # 如果原始标题为空或无效,使用LLM生成标题\n        title = raw_title if raw_title else self._generate_title(raw_content)\n        if not title or title == \"无标题\":\n            raise ValueError(\"无法获取或生成有效的标题\")\n            \n        # # 获取context文件路径\n        # temp_dir = self.context_manager.get(\"temp_dir\")\n        # context_path = os.path.join(temp_dir, \"context.json\")\n        \n        # # 读取现有context\n        # with open(context_path, 'r', encoding='utf-8') as f:\n        #     context_data = json.load(f)\n        \n        # # 更新title\n        # context_data['title'] = title\n        \n        # # 保存更新后的context\n        # with open(context_path, 'w', encoding='utf-8') as f:\n        #     json.dump(context_data, f, ensure_ascii=False, indent=2)\n        \n        # 更新任务标题\n        self.progress_tracker.db.refresh(self.progress_tracker.task)\n        self.progress_tracker.task.title = title\n        try:\n            self.progress_tracker.db.commit()\n        except Exception as e:\n            self.progress_tracker.db.rollback()\n            raise Exception(f\"更新任务标题失败: {str(e)}\")\n            \n        return {\n            \"title\": title\n        }\n        \n    def _generate_title(self, content: str) -> str:\n        \"\"\"使用LLM生成标题\"\"\"\n        log.info(\"开始生成播客标题\")\n        try:\n            chat_prompt = PromptUtils.create_chat_prompt(\"podcast_title_generation\")\n            chain = chat_prompt | self.llm_service.llm\n            response = chain.invoke({\"content\": content})\n            title = response.content if hasattr(response, 'content') else str(response)\n            if not title or not title.strip():\n                raise ValueError(\"生成的标题为空\")\n            \n            title = title.strip()\n            log.info(f\"成功生成播客标题: {title}\")\n            return title\n        except Exception as e:\n            log.error(f\"生成标题失败: {str(e)}\")\n            raise ValueError(f\"标题生成失败: {str(e)}\") "}
